Before you begin:
- Keep going until the job is completely solved — don’t stop halfway.
- If you’re unsure about the behavior, reread the provided patch carefully; do not hallucinate.
- Plan your approach before writing code by reflecting on whether the test truly fails before and passes after.

Issue:
<issue>
Editing a PDF results in unexpected content change
</issue>

PDF File:
<pdf>
bug1899804.pdf
</pdf>

Patch:
<patch>
diff --git a/src/core/annotation.js b/src/core/annotation.js
--- a/src/core/annotation.js
+++ b/src/core/annotation.js
@@ -2681,11 +2681,19 @@ class TextWidgetAnnotation extends WidgetAnnotation {
   constructor(params) {
     super(params);
 
+    const { dict } = params;
+
+    if (dict.has("PMD")) {
+      // It's used to display a barcode but it isn't specified so we just hide
+      // it to avoid any confusion.
+      this.flags |= AnnotationFlag.HIDDEN;
+      this.data.hidden = true;
+      warn("Barcodes are not supported");
+    }
+
     this.data.hasOwnCanvas = this.data.readOnly && !this.data.noHTML;
     this._hasText = true;
 
-    const dict = params.dict;
-
     // The field value is always a string.
     if (typeof this.data.fieldValue !== "string") {
       this.data.fieldValue = "";


</patch>

Imports:
<imports>
Available Packages
Dev Dependencies:
- @babel/core: ^7.24.6
- @babel/preset-env: ^7.24.6
- @babel/runtime: ^7.24.6
- @fluent/bundle: ^0.18.0
- @fluent/dom: ^0.9.0
- @jazzer.js/core: ^2.1.0
- autoprefixer: ^10.4.19
- babel-loader: ^9.1.3
- caniuse-lite: ^1.0.30001624
- canvas: ^2.11.2
- core-js: ^3.37.1
- cross-env: ^7.0.3
- eslint: ^8.57.0
- eslint-config-prettier: ^9.1.0
- eslint-plugin-fetch-options: ^0.0.5
- eslint-plugin-html: ^8.1.1
- eslint-plugin-import: ^2.29.1
- eslint-plugin-jasmine: ^4.1.3
- eslint-plugin-json: ^3.1.0
- eslint-plugin-mozilla: ^3.7.4
- eslint-plugin-no-unsanitized: ^4.0.2
- eslint-plugin-prettier: ^5.1.3
- eslint-plugin-sort-exports: ^0.9.1
- eslint-plugin-unicorn: ^53.0.0
- globals: ^15.3.0
- gulp: ^5.0.0
- gulp-cli: ^3.0.0
- gulp-postcss: ^10.0.0
- gulp-rename: ^2.0.0
- gulp-replace: ^1.1.4
- gulp-zip: ^6.0.0
- jasmine: ^5.1.0
- jsdoc: ^4.0.3
- jstransformer-markdown-it: ^3.0.0
- ordered-read-streams: ^2.0.0
- path2d: ^0.2.0
- pngjs: ^7.0.0
- postcss: ^8.4.38
- postcss-dark-theme-class: ^1.3.0
- postcss-dir-pseudo-class: ^8.0.1
- postcss-discard-comments: ^7.0.0
- postcss-nesting: ^12.1.5
- prettier: ^3.2.5
- puppeteer: ^22.10.0
- streamqueue: ^1.1.2
- stylelint: ^16.6.1
- stylelint-prettier: ^5.0.0
- terser-webpack-plugin: ^5.3.10
- tsc-alias: ^1.8.10
- ttest: ^4.0.0
- typescript: ^5.4.5
- typogr: ^0.6.8
- vinyl: ^3.0.0
- webpack: ^5.91.0
- webpack-stream: ^7.0.0
- wintersmith: ^2.5.0
- yargs: ^17.7.2

Engines:
- node: >=18

Available Relative Imports:
- `../../src/core/annotation.js`: Annotation, AnnotationBorderStyle, AnnotationFactory, MarkupAnnotation, getQuadPoints
- `../../src/core/bidi.js`: bidi
- `../../src/core/cff_parser.js`: CFFCharset, CFFCompiler, CFFFDSelect, CFFParser, CFFStrings
- `../../src/core/cmap.js`: CMap, CMapFactory, IdentityCMap
- `../../src/core/colorspace.js`: ColorSpace
- `../../src/core/core_utils.js`: arrayBuffersToBytes, encodeToXmlString, escapePDFName, escapeString, getInheritableProperty, getSizeInBytes, isAscii, isWhiteSpace, log2, numberToString, parseXFAPath, recoverJsURL, stringToUTF16HexString, stringToUTF16String, toRomanNumerals, validateCSSFont
- `../../src/core/crypto.js`: AES128Cipher, AES256Cipher, ARCFourCipher, CipherTransformFactory, PDF17, PDF20, calculateMD5, calculateSHA256, calculateSHA384, calculateSHA512
- `../../src/core/default_appearance.js`: createDefaultAppearance, parseAppearanceStream, parseDefaultAppearance
- `../../src/core/document.js`: PDFDocument, Page
- `../../src/core/encodings.js`: getEncoding
- `../../src/core/evaluator.js`: PartialEvaluator
- `../../src/core/flate_stream.js`: FlateStream
- `../../src/core/font_substitutions.js`: getFontSubstitution
- `../../src/core/fonts_utils.js`: SEAC_ANALYSIS_ENABLED
- `../../src/core/function.js`: PDFFunctionFactory, PostScriptCompiler, PostScriptEvaluator
- `../../src/core/glyphlist.js`: getDingbatsGlyphsUnicode, getGlyphsUnicode
- `../../src/core/image_utils.js`: GlobalImageCache, LocalColorSpaceCache
- `../../src/core/jbig2.js`: Jbig2Error, Jbig2Image
- `../../src/core/jpg.js`: JpegError, JpegImage
- `../../src/core/jpx.js`: JpxError, JpxImage
- `../../src/core/metadata_parser.js`: MetadataParser
- `../../src/core/operator_list.js`: OperatorList
- `../../src/core/parser.js`: Lexer, Linearization, Parser
- `../../src/core/predictor_stream.js`: PredictorStream
- `../../src/core/primitives.js`: Cmd, Dict, EOF, Name, Ref, RefSet, RefSetCache, isCmd, isDict, isName, isRefsEqual
- `../../src/core/ps_parser.js`: PostScriptLexer, PostScriptParser
- `../../src/core/stream.js`: NullStream, Stream, StringStream
- `../../src/core/type1_parser.js`: Type1Parser
- `../../src/core/unicode.js`: getCharUnicodeCategory, getUnicodeForGlyph, getUnicodeRangeFor, mapSpecialUnicodeValues
- `../../src/core/worker.js`: WorkerMessageHandler, WorkerTask
- `../../src/core/writer.js`: incrementalUpdate, writeDict
- `../../src/core/xfa/bind.js`: Binder
- `../../src/core/xfa/data.js`: DataHandler
- `../../src/core/xfa/factory.js`: XFAFactory
- `../../src/core/xfa/formcalc_lexer.js`: Lexer, TOKEN, Token
- `../../src/core/xfa/formcalc_parser.js`: Errors, Parser
- `../../src/core/xfa/parser.js`: XFAParser
- `../../src/core/xfa/som.js`: searchNode
- `../../src/core/xfa/symbol_utils.js`: $dump, $getChildren, $getChildrenByClass, $getChildrenByName, $text, $uid
- `../../src/core/xml_parser.js`: SimpleXMLParser, XMLParserBase
- `../../src/display/annotation_layer.js`: AnnotationLayer
- `../../src/display/annotation_storage.js`: AnnotationStorage
- `../../src/display/api.js`: DefaultCMapReaderFactory, DefaultCanvasFactory, DefaultStandardFontDataFactory, LoopbackPort, PDFDataRangeTransport, PDFDocumentLoadingTask, PDFDocumentProxy, PDFPageProxy, PDFWorker, PDFWorkerUtil, RenderTask, build, getDocument, version
- `../../src/display/display_utils.js`: DOMCanvasFactory, DOMSVGFactory, PDFDateString, PageViewport, PixelsPerInch, RenderingCancelledException, StatTimer, fetchData, getFilenameFromUrl, getPdfFilenameFromUrl, getXfaPageViewport, isDataScheme, isPdfFile, isValidFetchUrl, noContextMenu, setLayerDimensions
- `../../src/display/draw_layer.js`: DrawLayer
- `../../src/display/editor/annotation_editor_layer.js`: AnnotationEditorLayer
- `../../src/display/editor/color_picker.js`: ColorPicker
- `../../src/display/editor/outliner.js`: Outliner
- `../../src/display/editor/tools.js`: AnnotationEditorUIManager, CommandManager
- `../../src/display/fetch_stream.js`: PDFFetchStream
- `../../src/display/metadata.js`: Metadata
- `../../src/display/network.js`: PDFNetworkStream
- `../../src/display/network_utils.js`: createResponseStatusError, extractFilenameFromHeader, validateRangeRequestCapabilities, validateResponseStatus
- `../../src/display/node_stream.js`: PDFNodeStream
- `../../src/display/node_utils.js`: NodePackages
- `../../src/display/text_layer.js`: TextLayer, renderTextLayer, updateTextLayer
- `../../src/display/worker_options.js`: GlobalWorkerOptions
- `../../src/display/xfa_layer.js`: XfaLayer
- `../../src/shared/message_handler.js`: MessageHandler
- `../../src/shared/murmurhash3.js`: MurmurHash3_64
- `../../src/shared/util.js`: AbortException, AnnotationBorderStyleType, AnnotationEditorParamsType, AnnotationEditorType, AnnotationFieldFlag, AnnotationFlag, AnnotationMode, AnnotationType, BaseException, CMapCompressionType, FeatureTest, FormatError, ImageKind, InvalidPDFException, MissingPDFException, OPS, PasswordException, PasswordResponses, PermissionFlag, RenderingIntentFlag, UnexpectedResponseException, UnknownErrorException, Util, VerbosityLevel, assert, bytesToString, createValidAbsoluteUrl, getModificationDate, getVerbosityLevel, isNodeJS, normalizeUnicode, objectSize, setVerbosityLevel, shadow, string32, stringToBytes, stringToPDFString, stringToUTF8String
- `../../web/annotation_layer_builder.js`: AnnotationLayerBuilder
- `../../web/app_options.js`: AppOptions, OptionKind
- `../../web/download_manager.js`: DownloadManager
- `../../web/event_utils.js`: EventBus, WaitOnType, waitOnEventOrTimeout
- `../../web/genericl10n.js`: GenericL10n
- `../../web/pdf_find_controller.js`: FindState, PDFFindController
- `../../web/pdf_find_utils.js`: CharacterType, getCharacterType
- `../../web/pdf_history.js`: PDFHistory, isDestArraysEqual, isDestHashesEqual
- `../../web/pdf_link_service.js`: LinkTarget, PDFLinkService, SimpleLinkService
- `../../web/pdf_page_view.js`: PDFPageView
- `../../web/pdf_scripting_manager.component.js`: PDFScriptingManager
- `../../web/pdf_single_page_viewer.js`: PDFSinglePageViewer
- `../../web/pdf_viewer.js`: PDFPageViewBuffer, PDFViewer
- `../../web/struct_tree_layer_builder.js`: StructTreeLayerBuilder
- `../../web/text_layer_builder.js`: TextLayerBuilder
- `../../web/ui_utils.js`: AutoPrintRegExp, ProgressBar, RenderingStates, ScrollMode, SpreadMode, backtrackBeforeAllVisibleElements, binarySearchFirstItem, getPageSizeInches, getVisibleElements, isPortraitOrientation, isValidRotation, parseQueryString, removeNullCharacters
- `../../web/xfa_layer_builder.js`: XfaLayerBuilder
- `./test_utils.js`: CMAP_URL, DefaultFileReaderFactory, STANDARD_FONT_DATA_URL, TEST_PDFS_PATH, XRefMock, buildGetDocumentParams, createIdFactory, createTemporaryNodeServer
- `./testreporter.js`: TestReporter
</imports>

Code:
<code>
File:
src/core/annotation.js
1 /* Copyright 2012 Mozilla Foundation
2  *
3  * Licensed under the Apache License, Version 2.0 (the "License");
4  * you may not use this file except in compliance with the License.
5  * You may obtain a copy of the License at
6  *
7  *     http://www.apache.org/licenses/LICENSE-2.0
8  *
9  * Unless required by applicable law or agreed to in writing, software
10  * distributed under the License is distributed on an "AS IS" BASIS,
11  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
12  * See the License for the specific language governing permissions and
13  * limitations under the License.
14  */
15 
16 import {
17   AnnotationActionEventType,
18   AnnotationBorderStyleType,
19   AnnotationEditorType,
20   AnnotationFieldFlag,
21   AnnotationFlag,
22   AnnotationReplyType,
23   AnnotationType,
24   assert,
25   BASELINE_FACTOR,
26   FeatureTest,
27   getModificationDate,
28   IDENTITY_MATRIX,
29   info,
30   LINE_DESCENT_FACTOR,
31   LINE_FACTOR,
32   OPS,
33   RenderingIntentFlag,
34   shadow,
35   stringToPDFString,
36   unreachable,
37   Util,
38   warn,
39 } from "../shared/util.js";
40 import {
41   collectActions,
42   escapeString,
43   getInheritableProperty,
44   getRotationMatrix,
45   isAscii,
46   isNumberArray,
47   lookupMatrix,
48   lookupNormalRect,
49   lookupRect,
50   numberToString,
51   stringToUTF16String,
52 } from "./core_utils.js";
53 import {
54   createDefaultAppearance,
55   FakeUnicodeFont,
56   getPdfColor,
57   parseAppearanceStream,
58   parseDefaultAppearance,
59 } from "./default_appearance.js";
60 import { Dict, isName, isRefsEqual, Name, Ref, RefSet } from "./primitives.js";
61 import { Stream, StringStream } from "./stream.js";
62 import { BaseStream } from "./base_stream.js";
63 import { bidi } from "./bidi.js";
64 import { Catalog } from "./catalog.js";
65 import { ColorSpace } from "./colorspace.js";
66 import { FileSpec } from "./file_spec.js";
67 import { JpegStream } from "./jpeg_stream.js";
68 import { ObjectLoader } from "./object_loader.js";
69 import { OperatorList } from "./operator_list.js";
70 import { writeObject } from "./writer.js";
71 import { XFAFactory } from "./xfa/factory.js";
72 
73 class AnnotationFactory {
74   static createGlobals(pdfManager) {
75     return Promise.all([
76       pdfManager.ensureCatalog("acroForm"),
77       pdfManager.ensureDoc("xfaDatasets"),
78       pdfManager.ensureCatalog("structTreeRoot"),
79       // Only necessary to prevent the `Catalog.baseUrl`-getter, used
80       // with some Annotations, from throwing and thus breaking parsing:
81       pdfManager.ensureCatalog("baseUrl"),
82       // Only necessary to prevent the `Catalog.attachments`-getter, used
83       // with "GoToE" actions, from throwing and thus breaking parsing:
84       pdfManager.ensureCatalog("attachments"),
85     ]).then(
86       // eslint-disable-next-line arrow-body-style
87       ([acroForm, xfaDatasets, structTreeRoot, baseUrl, attachments]) => {
88         return {
89           pdfManager,
90           acroForm: acroForm instanceof Dict ? acroForm : Dict.empty,
91           xfaDatasets,
92           structTreeRoot,
93           baseUrl,
94           attachments,
95         };
96       },
97       reason => {
98         warn(`createGlobals: "${reason}".`);
99         return null;
100       }
101     );
102   }
103 
104   /**
105    * Create an `Annotation` object of the correct type for the given reference
106    * to an annotation dictionary. This yields a promise that is resolved when
107    * the `Annotation` object is constructed.
108    *
109    * @param {XRef} xref
110    * @param {Object} ref
111    * @params {Object} annotationGlobals
112    * @param {Object} idFactory
113    * @param {boolean} [collectFields]
114    * @param {Object} [pageRef]
115    * @returns {Promise} A promise that is resolved with an {Annotation}
116    *   instance.
117    */
118   static async create(
119     xref,
120     ref,
121     annotationGlobals,
122     idFactory,
123     collectFields,
124     pageRef
125   ) {
126     const pageIndex = collectFields
127       ? await this._getPageIndex(xref, ref, annotationGlobals.pdfManager)
128       : null;
129 
130     return annotationGlobals.pdfManager.ensure(this, "_create", [
131       xref,
132       ref,
133       annotationGlobals,
134       idFactory,
135       collectFields,
136       pageIndex,
137       pageRef,
138     ]);
139   }
140 
141   /**
142    * @private
143    */
144   static _create(
145     xref,
146     ref,
147     annotationGlobals,
148     idFactory,
149     collectFields = false,
150     pageIndex = null,
151     pageRef = null
152   ) {
153     const dict = xref.fetchIfRef(ref);
154     if (!(dict instanceof Dict)) {
155       return undefined;
156     }
157 
158     const { acroForm, pdfManager } = annotationGlobals;
159     const id =
160       ref instanceof Ref ? ref.toString() : `annot_${idFactory.createObjId()}`;
161 
162     // Determine the annotation's subtype.
163     let subtype = dict.get("Subtype");
164     subtype = subtype instanceof Name ? subtype.name : null;
165 
166     // Return the right annotation object based on the subtype and field type.
167     const parameters = {
168       xref,
169       ref,
170       dict,
171       subtype,
172       id,
173       annotationGlobals,
174       collectFields,
175       needAppearances:
176         !collectFields && acroForm.get("NeedAppearances") === true,
177       pageIndex,
178       evaluatorOptions: pdfManager.evaluatorOptions,
179       pageRef,
180     };
181 
182     switch (subtype) {
183       case "Link":
184         return new LinkAnnotation(parameters);
185 
186       case "Text":
187         return new TextAnnotation(parameters);
188 
189       case "Widget":
190         let fieldType = getInheritableProperty({ dict, key: "FT" });
191         fieldType = fieldType instanceof Name ? fieldType.name : null;
192 
193         switch (fieldType) {
194           case "Tx":
195             return new TextWidgetAnnotation(parameters);
196           case "Btn":
197             return new ButtonWidgetAnnotation(parameters);
198           case "Ch":
199             return new ChoiceWidgetAnnotation(parameters);
200           case "Sig":
201             return new SignatureWidgetAnnotation(parameters);
202         }
203         warn(
204           `Unimplemented widget field type "${fieldType}", ` +
205             "falling back to base field type."
206         );
207         return new WidgetAnnotation(parameters);
208 
209       case "Popup":
210         return new PopupAnnotation(parameters);
211 
212       case "FreeText":
213         return new FreeTextAnnotation(parameters);
214 
215       case "Line":
216         return new LineAnnotation(parameters);
217 
218       case "Square":
219         return new SquareAnnotation(parameters);
220 
221       case "Circle":
222         return new CircleAnnotation(parameters);
223 
224       case "PolyLine":
225         return new PolylineAnnotation(parameters);
226 
227       case "Polygon":
228         return new PolygonAnnotation(parameters);
229 
230       case "Caret":
231         return new CaretAnnotation(parameters);
232 
233       case "Ink":
234         return new InkAnnotation(parameters);
235 
236       case "Highlight":
237         return new HighlightAnnotation(parameters);
238 
239       case "Underline":
240         return new UnderlineAnnotation(parameters);
241 
242       case "Squiggly":
243         return new SquigglyAnnotation(parameters);
244 
245       case "StrikeOut":
246         return new StrikeOutAnnotation(parameters);
247 
248       case "Stamp":
249         return new StampAnnotation(parameters);
250 
251       case "FileAttachment":
252         return new FileAttachmentAnnotation(parameters);
253 
254       default:
255         if (!collectFields) {
256           if (!subtype) {
257             warn("Annotation is missing the required /Subtype.");
258           } else {
259             warn(
260               `Unimplemented annotation type "${subtype}", ` +
261                 "falling back to base annotation."
262             );
263           }
264         }
265         return new Annotation(parameters);
266     }
267   }
268 
269   static async _getPageIndex(xref, ref, pdfManager) {
270     try {
271       const annotDict = await xref.fetchIfRefAsync(ref);
272       if (!(annotDict instanceof Dict)) {
273         return -1;
274       }
275       const pageRef = annotDict.getRaw("P");
276       if (pageRef instanceof Ref) {
277         try {
278           const pageIndex = await pdfManager.ensureCatalog("getPageIndex", [
279             pageRef,
280           ]);
281           return pageIndex;
282         } catch (ex) {
283           info(`_getPageIndex -- not a valid page reference: "${ex}".`);
284         }
285       }
286       if (annotDict.has("Kids")) {
287         return -1; // Not an annotation reference.
288       }
289       // Fallback to, potentially, checking the annotations of all pages.
290       // PLEASE NOTE: This could force the *entire* PDF document to load,
291       //              hence it absolutely cannot be done unconditionally.
292       const numPages = await pdfManager.ensureDoc("numPages");
293 
294       for (let pageIndex = 0; pageIndex < numPages; pageIndex++) {
295         const page = await pdfManager.getPage(pageIndex);
296         const annotations = await pdfManager.ensure(page, "annotations");
297 
298         for (const annotRef of annotations) {
299           if (annotRef instanceof Ref && isRefsEqual(annotRef, ref)) {
300             return pageIndex;
301           }
302         }
303       }
304     } catch (ex) {
305       warn(`_getPageIndex: "${ex}".`);
306     }
307     return -1;
308   }
309 
310   static generateImages(annotations, xref, isOffscreenCanvasSupported) {
311     if (!isOffscreenCanvasSupported) {
312       warn(
313         "generateImages: OffscreenCanvas is not supported, cannot save or print some annotations with images."
314       );
315       return null;
316     }
317     let imagePromises;
318     for (const { bitmapId, bitmap } of annotations) {
319       if (!bitmap) {
320         continue;
321       }
322       imagePromises ||= new Map();
323       imagePromises.set(bitmapId, StampAnnotation.createImage(bitmap, xref));
324     }
325 
326     return imagePromises;
327   }
328 
329   static async saveNewAnnotations(evaluator, task, annotations, imagePromises) {
330     const xref = evaluator.xref;
331     let baseFontRef;
332     const dependencies = [];
333     const promises = [];
334     const { isOffscreenCanvasSupported } = evaluator.options;
335 
336     for (const annotation of annotations) {
337       if (annotation.deleted) {
338         continue;
339       }
340       switch (annotation.annotationType) {
341         case AnnotationEditorType.FREETEXT:
342           if (!baseFontRef) {
343             const baseFont = new Dict(xref);
344             baseFont.set("BaseFont", Name.get("Helvetica"));
345             baseFont.set("Type", Name.get("Font"));
346             baseFont.set("Subtype", Name.get("Type1"));
347             baseFont.set("Encoding", Name.get("WinAnsiEncoding"));
348             const buffer = [];
349             baseFontRef = xref.getNewTemporaryRef();
350             await writeObject(baseFontRef, baseFont, buffer, xref);
351             dependencies.push({ ref: baseFontRef, data: buffer.join("") });
352           }
353           promises.push(
354             FreeTextAnnotation.createNewAnnotation(
355               xref,
356               annotation,
357               dependencies,
358               { evaluator, task, baseFontRef }
359             )
360           );
361           break;
362         case AnnotationEditorType.HIGHLIGHT:
363           if (annotation.quadPoints) {
364             promises.push(
365               HighlightAnnotation.createNewAnnotation(
366                 xref,
367                 annotation,
368                 dependencies
369               )
370             );
371           } else {
372             promises.push(
373               InkAnnotation.createNewAnnotation(xref, annotation, dependencies)
374             );
375           }
376           break;
377         case AnnotationEditorType.INK:
378           promises.push(
379             InkAnnotation.createNewAnnotation(xref, annotation, dependencies)
380           );
381           break;
382         case AnnotationEditorType.STAMP:
383           if (!isOffscreenCanvasSupported) {
384             break;
385           }
386           const image = await imagePromises.get(annotation.bitmapId);
387           if (image.imageStream) {
388             const { imageStream, smaskStream } = image;
389             const buffer = [];
390             if (smaskStream) {
391               const smaskRef = xref.getNewTemporaryRef();
392               await writeObject(smaskRef, smaskStream, buffer, xref);
393               dependencies.push({ ref: smaskRef, data: buffer.join("") });
394               imageStream.dict.set("SMask", smaskRef);
395               buffer.length = 0;
396             }
397             const imageRef = (image.imageRef = xref.getNewTemporaryRef());
398             await writeObject(imageRef, imageStream, buffer, xref);
399             dependencies.push({ ref: imageRef, data: buffer.join("") });
400             image.imageStream = image.smaskStream = null;
401           }
402           promises.push(
403             StampAnnotation.createNewAnnotation(
404               xref,
405               annotation,
406               dependencies,
407               { image }
408             )
409           );
410           break;
411       }
412     }
413 
414     return {
415       annotations: await Promise.all(promises),
416       dependencies,
417     };
418   }
419 
420   static async printNewAnnotations(
421     annotationGlobals,
422     evaluator,
423     task,
424     annotations,
425     imagePromises
426   ) {
427     if (!annotations) {
428       return null;
429     }
430 
431     const { options, xref } = evaluator;
432     const promises = [];
433     for (const annotation of annotations) {
434       if (annotation.deleted) {
435         continue;
436       }
437       switch (annotation.annotationType) {
438         case AnnotationEditorType.FREETEXT:
439           promises.push(
440             FreeTextAnnotation.createNewPrintAnnotation(
441               annotationGlobals,
442               xref,
443               annotation,
444               {
445                 evaluator,
446                 task,
447                 evaluatorOptions: options,
448               }
449             )
450           );
451           break;
452         case AnnotationEditorType.HIGHLIGHT:
453           if (annotation.quadPoints) {
454             promises.push(
455               HighlightAnnotation.createNewPrintAnnotation(
456                 annotationGlobals,
457                 xref,
458                 annotation,
459                 {
460                   evaluatorOptions: options,
461                 }
462               )
463             );
464           } else {
465             promises.push(
466               InkAnnotation.createNewPrintAnnotation(
467                 annotationGlobals,
468                 xref,
469                 annotation,
470                 {
471                   evaluatorOptions: options,
472                 }
473               )
474             );
475           }
476           break;
477         case AnnotationEditorType.INK:
478           promises.push(
479             InkAnnotation.createNewPrintAnnotation(
480               annotationGlobals,
481               xref,
482               annotation,
483               {
484                 evaluatorOptions: options,
485               }
486             )
487           );
488           break;
489         case AnnotationEditorType.STAMP:
490           if (!options.isOffscreenCanvasSupported) {
491             break;
492           }
493           const image = await imagePromises.get(annotation.bitmapId);
494           if (image.imageStream) {
495             const { imageStream, smaskStream } = image;
496             if (smaskStream) {
497               imageStream.dict.set("SMask", smaskStream);
498             }
499             image.imageRef = new JpegStream(imageStream, imageStream.length);
500             image.imageStream = image.smaskStream = null;
501           }
502           promises.push(
503             StampAnnotation.createNewPrintAnnotation(
504               annotationGlobals,
505               xref,
506               annotation,
507               {
508                 image,
509                 evaluatorOptions: options,
510               }
511             )
512           );
513           break;
514       }
515     }
516 
517     return Promise.all(promises);
518   }
519 }
520 
521 function getRgbColor(color, defaultColor = new Uint8ClampedArray(3)) {
522   if (!Array.isArray(color)) {
523     return defaultColor;
524   }
525 
526   const rgbColor = defaultColor || new Uint8ClampedArray(3);
527   switch (color.length) {
528     case 0: // Transparent, which we indicate with a null value
529       return null;
530 
531     case 1: // Convert grayscale to RGB
532       ColorSpace.singletons.gray.getRgbItem(color, 0, rgbColor, 0);
533       return rgbColor;
534 
535     case 3: // Convert RGB percentages to RGB
536       ColorSpace.singletons.rgb.getRgbItem(color, 0, rgbColor, 0);
537       return rgbColor;
538 
539     case 4: // Convert CMYK to RGB
540       ColorSpace.singletons.cmyk.getRgbItem(color, 0, rgbColor, 0);
541       return rgbColor;
542 
543     default:
544       return defaultColor;
545   }
546 }
547 
548 function getPdfColorArray(color) {
549   return Array.from(color, c => c / 255);
550 }
551 
552 function getQuadPoints(dict, rect) {
553   // The region is described as a number of quadrilaterals.
554   // Each quadrilateral must consist of eight coordinates.
555   const quadPoints = dict.getArray("QuadPoints");
556   if (
557     !isNumberArray(quadPoints, null) ||
558     quadPoints.length === 0 ||
559     quadPoints.length % 8 > 0
560   ) {
561     return null;
562   }
563 
564   const newQuadPoints = new Float32Array(quadPoints.length);
565   for (let i = 0, ii = quadPoints.length; i < ii; i += 8) {
566     // Each series of eight numbers represents the coordinates for one
567     // quadrilateral in the order [x1, y1, x2, y2, x3, y3, x4, y4].
568     // Convert this to an array of objects with x and y coordinates.
569     const [x1, y1, x2, y2, x3, y3, x4, y4] = quadPoints.slice(i, i + 8);
570     const minX = Math.min(x1, x2, x3, x4);
571     const maxX = Math.max(x1, x2, x3, x4);
572     const minY = Math.min(y1, y2, y3, y4);
573     const maxY = Math.max(y1, y2, y3, y4);
574     // The quadpoints should be ignored if any coordinate in the array
575     // lies outside the region specified by the rectangle. The rectangle
576     // can be `null` for markup annotations since their rectangle may be
577     // incorrect (fixes bug 1538111).
578     if (
579       rect !== null &&
580       (minX < rect[0] || maxX > rect[2] || minY < rect[1] || maxY > rect[3])
581     ) {
582       return null;
583     }
584     // The PDF specification states in section 12.5.6.10 (figure 64) that the
585     // order of the quadpoints should be bottom left, bottom right, top right
586     // and top left. However, in practice PDF files use a different order,
587     // namely bottom left, bottom right, top left and top right (this is also
588     // mentioned on https://github.com/highkite/pdfAnnotate#QuadPoints), so
589     // this is the actual order we should work with. However, the situation is
590     // even worse since Adobe's own applications and other applications violate
591     // the specification and create annotations with other orders, namely top
592     // left, top right, bottom left and bottom right or even top left,
593     // top right, bottom right and bottom left. To avoid inconsistency and
594     // broken rendering, we normalize all lists to put the quadpoints in the
595     // same standard order (see https://stackoverflow.com/a/10729881).
596     newQuadPoints.set([minX, maxY, maxX, maxY, minX, minY, maxX, minY], i);
597   }
598   return newQuadPoints;
599 }
600 
601 function getTransformMatrix(rect, bbox, matrix) {
602   // 12.5.5: Algorithm: Appearance streams
603   const [minX, minY, maxX, maxY] = Util.getAxialAlignedBoundingBox(
604     bbox,
605     matrix
606   );
607   if (minX === maxX || minY === maxY) {
608     // From real-life file, bbox was [0, 0, 0, 0]. In this case,
609     // just apply the transform for rect
610     return [1, 0, 0, 1, rect[0], rect[1]];
611   }
612 
613   const xRatio = (rect[2] - rect[0]) / (maxX - minX);
614   const yRatio = (rect[3] - rect[1]) / (maxY - minY);
615   return [
616     xRatio,
617     0,
618     0,
619     yRatio,
620     rect[0] - minX * xRatio,
621     rect[1] - minY * yRatio,
622   ];
623 }
624 
625 class Annotation {
626   constructor(params) {
627     const { dict, xref, annotationGlobals } = params;
628 
629     this.setTitle(dict.get("T"));
630     this.setContents(dict.get("Contents"));
631     this.setModificationDate(dict.get("M"));
632     this.setFlags(dict.get("F"));
633     this.setRectangle(dict.getArray("Rect"));
634     this.setColor(dict.getArray("C"));
635     this.setBorderStyle(dict);
636     this.setAppearance(dict);
637     this.setOptionalContent(dict);
638 
639     const MK = dict.get("MK");
640     this.setBorderAndBackgroundColors(MK);
641     this.setRotation(MK, dict);
642     this.ref = params.ref instanceof Ref ? params.ref : null;
643 
644     this._streams = [];
645     if (this.appearance) {
646       this._streams.push(this.appearance);
647     }
648 
649     // The annotation cannot be changed (neither its position/visibility nor its
650     // contents), hence we can just display its appearance and don't generate
651     // a HTML element for it.
652     const isLocked = !!(this.flags & AnnotationFlag.LOCKED);
653     const isContentLocked = !!(this.flags & AnnotationFlag.LOCKEDCONTENTS);
654 
655     if (annotationGlobals.structTreeRoot) {
656       let structParent = dict.get("StructParent");
657       structParent =
658         Number.isInteger(structParent) && structParent >= 0 ? structParent : -1;
659 
660       annotationGlobals.structTreeRoot.addAnnotationIdToPage(
661         params.pageRef,
662         structParent
663       );
664     }
665 
666     // Expose public properties using a data object.
667     this.data = {
668       annotationFlags: this.flags,
669       borderStyle: this.borderStyle,
670       color: this.color,
671       backgroundColor: this.backgroundColor,
672       borderColor: this.borderColor,
673       rotation: this.rotation,
674       contentsObj: this._contents,
675       hasAppearance: !!this.appearance,
676       id: params.id,
677       modificationDate: this.modificationDate,
678       rect: this.rectangle,
679       subtype: params.subtype,
680       hasOwnCanvas: false,
681       noRotate: !!(this.flags & AnnotationFlag.NOROTATE),
682       noHTML: isLocked && isContentLocked,
683     };
684 
685     if (params.collectFields) {
686       // Fields can act as container for other fields and have
687       // some actions even if no Annotation inherit from them.
688       // Those fields can be referenced by CO (calculation order).
689       const kids = dict.get("Kids");
690       if (Array.isArray(kids)) {
691         const kidIds = [];
692         for (const kid of kids) {
693           if (kid instanceof Ref) {
694             kidIds.push(kid.toString());
695           }
696         }
697         if (kidIds.length !== 0) {
698           this.data.kidIds = kidIds;
699         }
700       }
701 
702       this.data.actions = collectActions(xref, dict, AnnotationActionEventType);
703       this.data.fieldName = this._constructFieldName(dict);
704       this.data.pageIndex = params.pageIndex;
705     }
706 
707     this._isOffscreenCanvasSupported =
708       params.evaluatorOptions.isOffscreenCanvasSupported;
709     this._fallbackFontDict = null;
710     this._needAppearances = false;
711   }
712 
713   /**
714    * @private
715    */
716   _hasFlag(flags, flag) {
717     return !!(flags & flag);
718   }
719 
720   /**
721    * @private
722    */
723   _isViewable(flags) {
724     return (
725       !this._hasFlag(flags, AnnotationFlag.INVISIBLE) &&
726       !this._hasFlag(flags, AnnotationFlag.NOVIEW)
727     );
728   }
729 
730   /**
731    * @private
732    */
733   _isPrintable(flags) {
734     // In Acrobat, hidden flag cancels the print one
735     // (see annotation_hidden_print.pdf).
736     return (
737       this._hasFlag(flags, AnnotationFlag.PRINT) &&
738       !this._hasFlag(flags, AnnotationFlag.HIDDEN) &&
739       !this._hasFlag(flags, AnnotationFlag.INVISIBLE)
740     );
741   }
742 
743   /**
744    * Check if the annotation must be displayed by taking into account
745    * the value found in the annotationStorage which may have been set
746    * through JS.
747    *
748    * @public
749    * @memberof Annotation
750    * @param {AnnotationStorage} [annotationStorage] - Storage for annotation
751    * @param {boolean} [_renderForms] - if true widgets are rendered thanks to
752    *                                   the annotation layer.
753    */
754   mustBeViewed(annotationStorage, _renderForms) {
755     const noView = annotationStorage?.get(this.data.id)?.noView;
756     if (noView !== undefined) {
757       return !noView;
758     }
759     return this.viewable && !this._hasFlag(this.flags, AnnotationFlag.HIDDEN);
760   }
761 
762   /**
763    * Check if the annotation must be printed by taking into account
764    * the value found in the annotationStorage which may have been set
765    * through JS.
766    *
767    * @public
768    * @memberof Annotation
769    * @param {AnnotationStorage} [annotationStorage] - Storage for annotation
770    */
771   mustBePrinted(annotationStorage) {
772     const noPrint = annotationStorage?.get(this.data.id)?.noPrint;
773     if (noPrint !== undefined) {
774       return !noPrint;
775     }
776     return this.printable;
777   }
778 
779   /**
780    * @type {boolean}
781    */
782   get viewable() {
783     if (this.data.quadPoints === null) {
784       return false;
785     }
786     if (this.flags === 0) {
787       return true;
788     }
789     return this._isViewable(this.flags);
790   }
791 
792   /**
793    * @type {boolean}
794    */
795   get printable() {
796     if (this.data.quadPoints === null) {
797       return false;
798     }
799     if (this.flags === 0) {
800       return false;
801     }
802     return this._isPrintable(this.flags);
803   }
804 
805   /**
806    * @private
807    */
808   _parseStringHelper(data) {
809     const str = typeof data === "string" ? stringToPDFString(data) : "";
810     const dir = str && bidi(str).dir === "rtl" ? "rtl" : "ltr";
811 
812     return { str, dir };
813   }
814 
815   setDefaultAppearance(params) {
816     const { dict, annotationGlobals } = params;
817 
818     const defaultAppearance =
819       getInheritableProperty({ dict, key: "DA" }) ||
820       annotationGlobals.acroForm.get("DA");
821     this._defaultAppearance =
822       typeof defaultAppearance === "string" ? defaultAppearance : "";
823     this.data.defaultAppearanceData = parseDefaultAppearance(
824       this._defaultAppearance
825     );
826   }
827 
828   /**
829    * Set the title.
830    *
831    * @param {string} title - The title of the annotation, used e.g. with
832    *   PopupAnnotations.
833    */
834   setTitle(title) {
835     this._title = this._parseStringHelper(title);
836   }
837 
838   /**
839    * Set the contents.
840    *
841    * @param {string} contents - Text to display for the annotation or, if the
842    *                            type of annotation does not display text, a
843    *                            description of the annotation's contents
844    */
845   setContents(contents) {
846     this._contents = this._parseStringHelper(contents);
847   }
848 
849   /**
850    * Set the modification date.
851    *
852    * @public
853    * @memberof Annotation
854    * @param {string} modificationDate - PDF date string that indicates when the
855    *                                    annotation was last modified
856    */
857   setModificationDate(modificationDate) {
858     this.modificationDate =
859       typeof modificationDate === "string" ? modificationDate : null;
860   }
861 
862   /**
863    * Set the flags.
864    *
865    * @public
866    * @memberof Annotation
867    * @param {number} flags - Unsigned 32-bit integer specifying annotation
868    *                         characteristics
869    * @see {@link shared/util.js}
870    */
871   setFlags(flags) {
872     this.flags = Number.isInteger(flags) && flags > 0 ? flags : 0;
873     if (
874       this.flags & AnnotationFlag.INVISIBLE &&
875       this.constructor.name !== "Annotation"
876     ) {
877       // From the pdf spec v1.7, section 12.5.3 (Annotation Flags):
878       //   If set, do not display the annotation if it does not belong to one of
879       //   the standard annotation types and no annotation handler is available.
880       //
881       // So we can remove the flag in case we have a known annotation type.
882       this.flags ^= AnnotationFlag.INVISIBLE;
883     }
884   }
885 
886   /**
887    * Check if a provided flag is set.
888    *
889    * @public
890    * @memberof Annotation
891    * @param {number} flag - Hexadecimal representation for an annotation
892    *                        characteristic
893    * @returns {boolean}
894    * @see {@link shared/util.js}
895    */
896   hasFlag(flag) {
897     return this._hasFlag(this.flags, flag);
898   }
899 
900   /**
901    * Set the rectangle.
902    *
903    * @public
904    * @memberof Annotation
905    * @param {Array} rectangle - The rectangle array with exactly four entries
906    */
907   setRectangle(rectangle) {
908     this.rectangle = lookupNormalRect(rectangle, [0, 0, 0, 0]);
909   }
910 
911   /**
912    * Set the color and take care of color space conversion.
913    * The default value is black, in RGB color space.
914    *
915    * @public
916    * @memberof Annotation
917    * @param {Array} color - The color array containing either 0
918    *                        (transparent), 1 (grayscale), 3 (RGB) or
919    *                        4 (CMYK) elements
920    */
921   setColor(color) {
922     this.color = getRgbColor(color);
923   }
924 
925   /**
926    * Set the line endings; should only be used with specific annotation types.
927    * @param {Array} lineEndings - The line endings array.
928    */
929   setLineEndings(lineEndings) {
930     if (typeof PDFJSDev !== "undefined" && PDFJSDev.test("MOZCENTRAL")) {
931       throw new Error("Not implemented: setLineEndings");
932     }
933     this.lineEndings = ["None", "None"]; // The default values.
934 
935     if (Array.isArray(lineEndings) && lineEndings.length === 2) {
936       for (let i = 0; i < 2; i++) {
937         const obj = lineEndings[i];
938 
939         if (obj instanceof Name) {
940           switch (obj.name) {
941             case "None":
942               continue;
943             case "Square":
944             case "Circle":
945             case "Diamond":
946             case "OpenArrow":
947             case "ClosedArrow":
948             case "Butt":
949             case "ROpenArrow":
950             case "RClosedArrow":
951             case "Slash":
952               this.lineEndings[i] = obj.name;
953               continue;
954           }
955         }
956         warn(`Ignoring invalid lineEnding: ${obj}`);
957       }
958     }
959   }
960 
961   setRotation(mk, dict) {
962     this.rotation = 0;
963     let angle = mk instanceof Dict ? mk.get("R") || 0 : dict.get("Rotate") || 0;
964     if (Number.isInteger(angle) && angle !== 0) {
965       angle %= 360;
966       if (angle < 0) {
967         angle += 360;
968       }
969       if (angle % 90 === 0) {
970         this.rotation = angle;
971       }
972     }
973   }
974 
975   /**
976    * Set the color for background and border if any.
977    * The default values are transparent.
978    *
979    * @public
980    * @memberof Annotation
981    * @param {Dict} mk - The MK dictionary
982    */
983   setBorderAndBackgroundColors(mk) {
984     if (mk instanceof Dict) {
985       this.borderColor = getRgbColor(mk.getArray("BC"), null);
986       this.backgroundColor = getRgbColor(mk.getArray("BG"), null);
987     } else {
988       this.borderColor = this.backgroundColor = null;
989     }
990   }
991 
992   /**
993    * Set the border style (as AnnotationBorderStyle object).
994    *
995    * @public
996    * @memberof Annotation
997    * @param {Dict} borderStyle - The border style dictionary
998    */
999   setBorderStyle(borderStyle) {
1000     if (typeof PDFJSDev === "undefined" || PDFJSDev.test("TESTING")) {
1001       assert(this.rectangle, "setRectangle must have been called previously.");
1002     }
1003 
1004     this.borderStyle = new AnnotationBorderStyle();
1005     if (!(borderStyle instanceof Dict)) {
1006       return;
1007     }
1008     if (borderStyle.has("BS")) {
1009       const dict = borderStyle.get("BS");
1010 
1011       if (dict instanceof Dict) {
1012         const dictType = dict.get("Type");
1013 
1014         if (!dictType || isName(dictType, "Border")) {
1015           this.borderStyle.setWidth(dict.get("W"), this.rectangle);
1016           this.borderStyle.setStyle(dict.get("S"));
1017           this.borderStyle.setDashArray(dict.getArray("D"));
1018         }
1019       }
1020     } else if (borderStyle.has("Border")) {
1021       const array = borderStyle.getArray("Border");
1022       if (Array.isArray(array) && array.length >= 3) {
1023         this.borderStyle.setHorizontalCornerRadius(array[0]);
1024         this.borderStyle.setVerticalCornerRadius(array[1]);
1025         this.borderStyle.setWidth(array[2], this.rectangle);
1026 
1027         if (array.length === 4) {
1028           // Dash array available
1029           this.borderStyle.setDashArray(array[3], /* forceStyle = */ true);
1030         }
1031       }
1032     } else {
1033       // There are no border entries in the dictionary. According to the
1034       // specification, we should draw a solid border of width 1 in that
1035       // case, but Adobe Reader did not implement that part of the
1036       // specification and instead draws no border at all, so we do the same.
1037       // See also https://github.com/mozilla/pdf.js/issues/6179.
1038       this.borderStyle.setWidth(0);
1039     }
1040   }
1041 
1042   /**
1043    * Set the (normal) appearance.
1044    *
1045    * @public
1046    * @memberof Annotation
1047    * @param {Dict} dict - The annotation's data dictionary
1048    */
1049   setAppearance(dict) {
1050     this.appearance = null;
1051 
1052     const appearanceStates = dict.get("AP");
1053     if (!(appearanceStates instanceof Dict)) {
1054       return;
1055     }
1056 
1057     // In case the normal appearance is a stream, then it is used directly.
1058     const normalAppearanceState = appearanceStates.get("N");
1059     if (normalAppearanceState instanceof BaseStream) {
1060       this.appearance = normalAppearanceState;
1061       return;
1062     }
1063     if (!(normalAppearanceState instanceof Dict)) {
1064       return;
1065     }
1066 
1067     // In case the normal appearance is a dictionary, the `AS` entry provides
1068     // the key of the stream in this dictionary.
1069     const as = dict.get("AS");
1070     if (!(as instanceof Name) || !normalAppearanceState.has(as.name)) {
1071       return;
1072     }
1073     const appearance = normalAppearanceState.get(as.name);
1074     if (appearance instanceof BaseStream) {
1075       this.appearance = appearance;
1076     }
1077   }
1078 
1079   setOptionalContent(dict) {
1080     this.oc = null;
1081 
1082     const oc = dict.get("OC");
1083     if (oc instanceof Name) {
1084       warn("setOptionalContent: Support for /Name-entry is not implemented.");
1085     } else if (oc instanceof Dict) {
1086       this.oc = oc;
1087     }
1088   }
1089 
1090   loadResources(keys, appearance) {
1091     return appearance.dict.getAsync("Resources").then(resources => {
1092       if (!resources) {
1093         return undefined;
1094       }
1095 
1096       const objectLoader = new ObjectLoader(resources, keys, resources.xref);
1097       return objectLoader.load().then(function () {
1098         return resources;
1099       });
1100     });
1101   }
1102 
1103   async getOperatorList(
1104     evaluator,
1105     task,
1106     intent,
1107     renderForms,
1108     annotationStorage
1109   ) {
1110     const { hasOwnCanvas, id, rect } = this.data;
1111     let appearance = this.appearance;
1112     const isUsingOwnCanvas = !!(
1113       hasOwnCanvas && intent & RenderingIntentFlag.DISPLAY
1114     );
1115     if (isUsingOwnCanvas && (rect[0] === rect[2] || rect[1] === rect[3])) {
1116       // Empty annotation, don't draw anything.
1117       this.data.hasOwnCanvas = false;
1118       return {
1119         opList: new OperatorList(),
1120         separateForm: false,
1121         separateCanvas: false,
1122       };
1123     }
1124     if (!appearance) {
1125       if (!isUsingOwnCanvas) {
1126         return {
1127           opList: new OperatorList(),
1128           separateForm: false,
1129           separateCanvas: false,
1130         };
1131       }
1132       appearance = new StringStream("");
1133       appearance.dict = new Dict();
1134     }
1135 
1136     const appearanceDict = appearance.dict;
1137     const resources = await this.loadResources(
1138       ["ExtGState", "ColorSpace", "Pattern", "Shading", "XObject", "Font"],
1139       appearance
1140     );
1141     const bbox = lookupRect(appearanceDict.getArray("BBox"), [0, 0, 1, 1]);
1142     const matrix = lookupMatrix(
1143       appearanceDict.getArray("Matrix"),
1144       IDENTITY_MATRIX
1145     );
1146     const transform = getTransformMatrix(rect, bbox, matrix);
1147 
1148     const opList = new OperatorList();
1149 
1150     let optionalContent;
1151     if (this.oc) {
1152       optionalContent = await evaluator.parseMarkedContentProps(
1153         this.oc,
1154         /* resources = */ null
1155       );
1156     }
1157     if (optionalContent !== undefined) {
1158       opList.addOp(OPS.beginMarkedContentProps, ["OC", optionalContent]);
1159     }
1160 
1161     opList.addOp(OPS.beginAnnotation, [
1162       id,
1163       rect,
1164       transform,
1165       matrix,
1166       isUsingOwnCanvas,
1167     ]);
1168 
1169     await evaluator.getOperatorList({
1170       stream: appearance,
1171       task,
1172       resources,
1173       operatorList: opList,
1174       fallbackFontDict: this._fallbackFontDict,
1175     });
1176     opList.addOp(OPS.endAnnotation, []);
1177 
1178     if (optionalContent !== undefined) {
1179       opList.addOp(OPS.endMarkedContent, []);
1180     }
1181     this.reset();
1182     return { opList, separateForm: false, separateCanvas: isUsingOwnCanvas };
1183   }
1184 
1185   async save(evaluator, task, annotationStorage) {
1186     return null;
1187   }
1188 
1189   get hasTextContent() {
1190     return false;
1191   }
1192 
1193   async extractTextContent(evaluator, task, viewBox) {
1194     if (!this.appearance) {
1195       return;
1196     }
1197 
1198     const resources = await this.loadResources(
1199       ["ExtGState", "Font", "Properties", "XObject"],
1200       this.appearance
1201     );
1202 
1203     const text = [];
1204     const buffer = [];
1205     let firstPosition = null;
1206     const sink = {
1207       desiredSize: Math.Infinity,
1208       ready: true,
1209 
1210       enqueue(chunk, size) {
1211         for (const item of chunk.items) {
1212           if (item.str === undefined) {
1213             continue;
1214           }
1215           firstPosition ||= item.transform.slice(-2);
1216           buffer.push(item.str);
1217           if (item.hasEOL) {
1218             text.push(buffer.join("").trimEnd());
1219             buffer.length = 0;
1220           }
1221         }
1222       },
1223     };
1224 
1225     await evaluator.getTextContent({
1226       stream: this.appearance,
1227       task,
1228       resources,
1229       includeMarkedContent: true,
1230       keepWhiteSpace: true,
1231       sink,
1232       viewBox,
1233     });
1234     this.reset();
1235 
1236     if (buffer.length) {
1237       text.push(buffer.join("").trimEnd());
1238     }
1239 
1240     if (text.length > 1 || text[0]) {
1241       const appearanceDict = this.appearance.dict;
1242       const bbox = lookupRect(appearanceDict.getArray("BBox"), null);
1243       const matrix = lookupMatrix(appearanceDict.getArray("Matrix"), null);
1244 
1245       this.data.textPosition = this._transformPoint(
1246         firstPosition,
1247         bbox,
1248         matrix
1249       );
1250       this.data.textContent = text;
1251     }
1252   }
1253 
1254   _transformPoint(coords, bbox, matrix) {
1255     const { rect } = this.data;
1256     bbox ||= [0, 0, 1, 1];
1257     matrix ||= [1, 0, 0, 1, 0, 0];
1258     const transform = getTransformMatrix(rect, bbox, matrix);
1259     transform[4] -= rect[0];
1260     transform[5] -= rect[1];
1261     coords = Util.applyTransform(coords, transform);
1262     return Util.applyTransform(coords, matrix);
1263   }
1264 
1265   /**
1266    * Get field data for usage in JS sandbox.
1267    *
1268    * Field object is defined here:
1269    * https://www.adobe.com/content/dam/acom/en/devnet/acrobat/pdfs/js_api_reference.pdf#page=16
1270    *
1271    * @public
1272    * @memberof Annotation
1273    * @returns {Object | null}
1274    */
1275   getFieldObject() {
1276     if (this.data.kidIds) {
1277       return {
1278         id: this.data.id,
1279         actions: this.data.actions,
1280         name: this.data.fieldName,
1281         strokeColor: this.data.borderColor,
1282         fillColor: this.data.backgroundColor,
1283         type: "",
1284         kidIds: this.data.kidIds,
1285         page: this.data.pageIndex,
1286         rotation: this.rotation,
1287       };
1288     }
1289     return null;
1290   }
1291 
1292   /**
1293    * Reset the annotation.
1294    *
1295    * This involves resetting the various streams that are either cached on the
1296    * annotation instance or created during its construction.
1297    *
1298    * @public
1299    * @memberof Annotation
1300    */
1301   reset() {
1302     if (
1303       (typeof PDFJSDev === "undefined" || PDFJSDev.test("TESTING")) &&
1304       this.appearance &&
1305       !this._streams.includes(this.appearance)
1306     ) {
1307       unreachable("The appearance stream should always be reset.");
1308     }
1309 
1310     for (const stream of this._streams) {
1311       stream.reset();
1312     }
1313   }
1314 
1315   /**
1316    * Construct the (fully qualified) field name from the (partial) field
1317    * names of the field and its ancestors.
1318    *
1319    * @private
1320    * @memberof Annotation
1321    * @param {Dict} dict - Complete widget annotation dictionary
1322    * @returns {string}
1323    */
1324   _constructFieldName(dict) {
1325     // Both the `Parent` and `T` fields are optional. While at least one of
1326     // them should be provided, bad PDF generators may fail to do so.
1327     if (!dict.has("T") && !dict.has("Parent")) {
1328       warn("Unknown field name, falling back to empty field name.");
1329       return "";
1330     }
1331 
1332     // If no parent exists, the partial and fully qualified names are equal.
1333     if (!dict.has("Parent")) {
1334       return stringToPDFString(dict.get("T"));
1335     }
1336 
1337     // Form the fully qualified field name by appending the partial name to
1338     // the parent's fully qualified name, separated by a period.
1339     const fieldName = [];
1340     if (dict.has("T")) {
1341       fieldName.unshift(stringToPDFString(dict.get("T")));
1342     }
1343 
1344     let loopDict = dict;
1345     const visited = new RefSet();
1346     if (dict.objId) {
1347       visited.put(dict.objId);
1348     }
1349     while (loopDict.has("Parent")) {
1350       loopDict = loopDict.get("Parent");
1351       if (
1352         !(loopDict instanceof Dict) ||
1353         (loopDict.objId && visited.has(loopDict.objId))
1354       ) {
1355         // Even though it is not allowed according to the PDF specification,
1356         // bad PDF generators may provide a `Parent` entry that is not a
1357         // dictionary, but `null` for example (issue 8143).
1358         //
1359         // If parent has been already visited, it means that we're
1360         // in an infinite loop.
1361         break;
1362       }
1363       if (loopDict.objId) {
1364         visited.put(loopDict.objId);
1365       }
1366 
1367       if (loopDict.has("T")) {
1368         fieldName.unshift(stringToPDFString(loopDict.get("T")));
1369       }
1370     }
1371     return fieldName.join(".");
1372   }
1373 }
1374 
1375 /**
1376  * Contains all data regarding an annotation's border style.
1377  */
1378 class AnnotationBorderStyle {
1379   constructor() {
1380     this.width = 1;
1381     this.style = AnnotationBorderStyleType.SOLID;
1382     this.dashArray = [3];
1383     this.horizontalCornerRadius = 0;
1384     this.verticalCornerRadius = 0;
1385   }
1386 
1387   /**
1388    * Set the width.
1389    *
1390    * @public
1391    * @memberof AnnotationBorderStyle
1392    * @param {number} width - The width.
1393    * @param {Array} rect - The annotation `Rect` entry.
1394    */
1395   setWidth(width, rect = [0, 0, 0, 0]) {
1396     if (typeof PDFJSDev === "undefined" || PDFJSDev.test("TESTING")) {
1397       assert(
1398         isNumberArray(rect, 4),
1399         "A valid `rect` parameter must be provided."
1400       );
1401     }
1402 
1403     // Some corrupt PDF generators may provide the width as a `Name`,
1404     // rather than as a number (fixes issue 10385).
1405     if (width instanceof Name) {
1406       this.width = 0; // This is consistent with the behaviour in Adobe Reader.
1407       return;
1408     }
1409     if (typeof width === "number") {
1410       if (width > 0) {
1411         const maxWidth = (rect[2] - rect[0]) / 2;
1412         const maxHeight = (rect[3] - rect[1]) / 2;
1413 
1414         // Ignore large `width`s, since they lead to the Annotation overflowing
1415         // the size set by the `Rect` entry thus causing the `annotationLayer`
1416         // to render it over the surrounding document (fixes bug1552113.pdf).
1417         if (
1418           maxWidth > 0 &&
1419           maxHeight > 0 &&
1420           (width > maxWidth || width > maxHeight)
1421         ) {
1422           warn(`AnnotationBorderStyle.setWidth - ignoring width: ${width}`);
1423           width = 1;
1424         }
1425       }
1426       this.width = width;
1427     }
1428   }
1429 
1430   /**
1431    * Set the style.
1432    *
1433    * @public
1434    * @memberof AnnotationBorderStyle
1435    * @param {Name} style - The annotation style.
1436    * @see {@link shared/util.js}
1437    */
1438   setStyle(style) {
1439     if (!(style instanceof Name)) {
1440       return;
1441     }
1442     switch (style.name) {
1443       case "S":
1444         this.style = AnnotationBorderStyleType.SOLID;
1445         break;
1446 
1447       case "D":
1448         this.style = AnnotationBorderStyleType.DASHED;
1449         break;
1450 
1451       case "B":
1452         this.style = AnnotationBorderStyleType.BEVELED;
1453         break;
1454 
1455       case "I":
1456         this.style = AnnotationBorderStyleType.INSET;
1457         break;
1458 
1459       case "U":
1460         this.style = AnnotationBorderStyleType.UNDERLINE;
1461         break;
1462 
1463       default:
1464         break;
1465     }
1466   }
1467 
1468   /**
1469    * Set the dash array.
1470    *
1471    * @public
1472    * @memberof AnnotationBorderStyle
1473    * @param {Array} dashArray - The dash array with at least one element
1474    * @param {boolean} [forceStyle]
1475    */
1476   setDashArray(dashArray, forceStyle = false) {
1477     // We validate the dash array, but we do not use it because CSS does not
1478     // allow us to change spacing of dashes. For more information, visit
1479     // http://www.w3.org/TR/css3-background/#the-border-style.
1480     if (Array.isArray(dashArray)) {
1481       // The PDF specification states that elements in the dash array, if
1482       // present, must be non-negative numbers and must not all equal zero.
1483       let isValid = true;
1484       let allZeros = true;
1485       for (const element of dashArray) {
1486         const validNumber = +element >= 0;
1487         if (!validNumber) {
1488           isValid = false;
1489           break;
1490         } else if (element > 0) {
1491           allZeros = false;
1492         }
1493       }
1494       if (dashArray.length === 0 || (isValid && !allZeros)) {
1495         this.dashArray = dashArray;
1496 
1497         if (forceStyle) {
1498           // Even though we cannot use the dash array in the display layer,
1499           // at least ensure that we use the correct border-style.
1500           this.setStyle(Name.get("D"));
1501         }
1502       } else {
1503         this.width = 0; // Adobe behavior when the array is invalid.
1504       }
1505     } else if (dashArray) {
1506       this.width = 0; // Adobe behavior when the array is invalid.
1507     }
1508   }
1509 
1510   /**
1511    * Set the horizontal corner radius (from a Border dictionary).
1512    *
1513    * @public
1514    * @memberof AnnotationBorderStyle
1515    * @param {number} radius - The horizontal corner radius.
1516    */
1517   setHorizontalCornerRadius(radius) {
1518     if (Number.isInteger(radius)) {
1519       this.horizontalCornerRadius = radius;
1520     }
1521   }
1522 
1523   /**
1524    * Set the vertical corner radius (from a Border dictionary).
1525    *
1526    * @public
1527    * @memberof AnnotationBorderStyle
1528    * @param {number} radius - The vertical corner radius.
1529    */
1530   setVerticalCornerRadius(radius) {
1531     if (Number.isInteger(radius)) {
1532       this.verticalCornerRadius = radius;
1533     }
1534   }
1535 }
1536 
1537 class MarkupAnnotation extends Annotation {
1538   constructor(params) {
1539     super(params);
1540 
1541     const { dict } = params;
1542 
1543     if (dict.has("IRT")) {
1544       const rawIRT = dict.getRaw("IRT");
1545       this.data.inReplyTo = rawIRT instanceof Ref ? rawIRT.toString() : null;
1546 
1547       const rt = dict.get("RT");
1548       this.data.replyType =
1549         rt instanceof Name ? rt.name : AnnotationReplyType.REPLY;
1550     }
1551     let popupRef = null;
1552 
1553     if (this.data.replyType === AnnotationReplyType.GROUP) {
1554       // Subordinate annotations in a group should inherit
1555       // the group attributes from the primary annotation.
1556       const parent = dict.get("IRT");
1557 
1558       this.setTitle(parent.get("T"));
1559       this.data.titleObj = this._title;
1560 
1561       this.setContents(parent.get("Contents"));
1562       this.data.contentsObj = this._contents;
1563 
1564       if (!parent.has("CreationDate")) {
1565         this.data.creationDate = null;
1566       } else {
1567         this.setCreationDate(parent.get("CreationDate"));
1568         this.data.creationDate = this.creationDate;
1569       }
1570 
1571       if (!parent.has("M")) {
1572         this.data.modificationDate = null;
1573       } else {
1574         this.setModificationDate(parent.get("M"));
1575         this.data.modificationDate = this.modificationDate;
1576       }
1577 
1578       popupRef = parent.getRaw("Popup");
1579 
1580       if (!parent.has("C")) {
1581         // Fall back to the default background color.
1582         this.data.color = null;
1583       } else {
1584         this.setColor(parent.getArray("C"));
1585         this.data.color = this.color;
1586       }
1587     } else {
1588       this.data.titleObj = this._title;
1589 
1590       this.setCreationDate(dict.get("CreationDate"));
1591       this.data.creationDate = this.creationDate;
1592 
1593       popupRef = dict.getRaw("Popup");
1594 
1595       if (!dict.has("C")) {
1596         // Fall back to the default background color.
1597         this.data.color = null;
1598       }
1599     }
1600 
1601     this.data.popupRef = popupRef instanceof Ref ? popupRef.toString() : null;
1602 
1603     if (dict.has("RC")) {
1604       this.data.richText = XFAFactory.getRichTextAsHtml(dict.get("RC"));
1605     }
1606   }
1607 
1608   /**
1609    * Set the creation date.
1610    *
1611    * @public
1612    * @memberof MarkupAnnotation
1613    * @param {string} creationDate - PDF date string that indicates when the
1614    *                                annotation was originally created
1615    */
1616   setCreationDate(creationDate) {
1617     this.creationDate = typeof creationDate === "string" ? creationDate : null;
1618   }
1619 
1620   _setDefaultAppearance({
1621     xref,
1622     extra,
1623     strokeColor,
1624     fillColor,
1625     blendMode,
1626     strokeAlpha,
1627     fillAlpha,
1628     pointsCallback,
1629   }) {
1630     let minX = Number.MAX_VALUE;
1631     let minY = Number.MAX_VALUE;
1632     let maxX = Number.MIN_VALUE;
1633     let maxY = Number.MIN_VALUE;
1634 
1635     const buffer = ["q"];
1636     if (extra) {
1637       buffer.push(extra);
1638     }
1639     if (strokeColor) {
1640       buffer.push(`${strokeColor[0]} ${strokeColor[1]} ${strokeColor[2]} RG`);
1641     }
1642     if (fillColor) {
1643       buffer.push(`${fillColor[0]} ${fillColor[1]} ${fillColor[2]} rg`);
1644     }
1645 
1646     let pointsArray = this.data.quadPoints;
1647     if (!pointsArray) {
1648       // If there are no quadpoints, the rectangle should be used instead.
1649       // Convert the rectangle definition to a points array similar to how the
1650       // quadpoints are defined.
1651       pointsArray = Float32Array.from([
1652         this.rectangle[0],
1653         this.rectangle[3],
1654         this.rectangle[2],
1655         this.rectangle[3],
1656         this.rectangle[0],
1657         this.rectangle[1],
1658         this.rectangle[2],
1659         this.rectangle[1],
1660       ]);
1661     }
1662 
1663     for (let i = 0, ii = pointsArray.length; i < ii; i += 8) {
1664       const [mX, MX, mY, MY] = pointsCallback(
1665         buffer,
1666         pointsArray.subarray(i, i + 8)
1667       );
1668       minX = Math.min(minX, mX);
1669       maxX = Math.max(maxX, MX);
1670       minY = Math.min(minY, mY);
1671       maxY = Math.max(maxY, MY);
1672     }
1673     buffer.push("Q");
1674 
1675     const formDict = new Dict(xref);
1676     const appearanceStreamDict = new Dict(xref);
1677     appearanceStreamDict.set("Subtype", Name.get("Form"));
1678 
1679     const appearanceStream = new StringStream(buffer.join(" "));
1680     appearanceStream.dict = appearanceStreamDict;
1681     formDict.set("Fm0", appearanceStream);
1682 
1683     const gsDict = new Dict(xref);
1684     if (blendMode) {
1685       gsDict.set("BM", Name.get(blendMode));
1686     }
1687     if (typeof strokeAlpha === "number") {
1688       gsDict.set("CA", strokeAlpha);
1689     }
1690     if (typeof fillAlpha === "number") {
1691       gsDict.set("ca", fillAlpha);
1692     }
1693 
1694     const stateDict = new Dict(xref);
1695     stateDict.set("GS0", gsDict);
1696 
1697     const resources = new Dict(xref);
1698     resources.set("ExtGState", stateDict);
1699     resources.set("XObject", formDict);
1700 
1701     const appearanceDict = new Dict(xref);
1702     appearanceDict.set("Resources", resources);
1703     const bbox = (this.data.rect = [minX, minY, maxX, maxY]);
1704     appearanceDict.set("BBox", bbox);
1705 
1706     this.appearance = new StringStream("/GS0 gs /Fm0 Do");
1707     this.appearance.dict = appearanceDict;
1708 
1709     // This method is only called if there is no appearance for the annotation,
1710     // so `this.appearance` is not pushed yet in the `Annotation` constructor.
1711     this._streams.push(this.appearance, appearanceStream);
1712   }
1713 
1714   static async createNewAnnotation(xref, annotation, dependencies, params) {
1715     const annotationRef = (annotation.ref ||= xref.getNewTemporaryRef());
1716     const ap = await this.createNewAppearanceStream(annotation, xref, params);
1717     const buffer = [];
1718     let annotationDict;
1719 
1720     if (ap) {
1721       const apRef = xref.getNewTemporaryRef();
1722       annotationDict = this.createNewDict(annotation, xref, { apRef });
1723       await writeObject(apRef, ap, buffer, xref);
1724       dependencies.push({ ref: apRef, data: buffer.join("") });
1725     } else {
1726       annotationDict = this.createNewDict(annotation, xref, {});
1727     }
1728     if (Number.isInteger(annotation.parentTreeId)) {
1729       annotationDict.set("StructParent", annotation.parentTreeId);
1730     }
1731 
1732     buffer.length = 0;
1733     await writeObject(annotationRef, annotationDict, buffer, xref);
1734 
1735     return { ref: annotationRef, data: buffer.join("") };
1736   }
1737 
1738   static async createNewPrintAnnotation(
1739     annotationGlobals,
1740     xref,
1741     annotation,
1742     params
1743   ) {
1744     const ap = await this.createNewAppearanceStream(annotation, xref, params);
1745     const annotationDict = this.createNewDict(annotation, xref, { ap });
1746 
1747     const newAnnotation = new this.prototype.constructor({
1748       dict: annotationDict,
1749       xref,
1750       annotationGlobals,
1751       evaluatorOptions: params.evaluatorOptions,
1752     });
1753 
1754     if (annotation.ref) {
1755       newAnnotation.ref = newAnnotation.refToReplace = annotation.ref;
1756     }
1757 
1758     return newAnnotation;
1759   }
1760 }
1761 
1762 class WidgetAnnotation extends Annotation {
1763   constructor(params) {
1764     super(params);
1765 
1766     const { dict, xref, annotationGlobals } = params;
1767     const data = this.data;
1768     this._needAppearances = params.needAppearances;
1769 
1770     data.annotationType = AnnotationType.WIDGET;
1771     if (data.fieldName === undefined) {
1772       data.fieldName = this._constructFieldName(dict);
1773     }
1774 
1775     if (data.actions === undefined) {
1776       data.actions = collectActions(xref, dict, AnnotationActionEventType);
1777     }
1778 
1779     let fieldValue = getInheritableProperty({
1780       dict,
1781       key: "V",
1782       getArray: true,
1783     });
1784     data.fieldValue = this._decodeFormValue(fieldValue);
1785 
1786     const defaultFieldValue = getInheritableProperty({
1787       dict,
1788       key: "DV",
1789       getArray: true,
1790     });
1791     data.defaultFieldValue = this._decodeFormValue(defaultFieldValue);
1792 
1793     if (fieldValue === undefined && annotationGlobals.xfaDatasets) {
1794       // Try to figure out if we have something in the xfa dataset.
1795       const path = this._title.str;
1796       if (path) {
1797         this._hasValueFromXFA = true;
1798         data.fieldValue = fieldValue =
1799           annotationGlobals.xfaDatasets.getValue(path);
1800       }
1801     }
1802 
1803     // When no "V" entry exists, let the fieldValue fallback to the "DV" entry
1804     // (fixes issue13823.pdf).
1805     if (fieldValue === undefined && data.defaultFieldValue !== null) {
1806       data.fieldValue = data.defaultFieldValue;
1807     }
1808 
1809     data.alternativeText = stringToPDFString(dict.get("TU") || "");
1810 
1811     this.setDefaultAppearance(params);
1812 
1813     data.hasAppearance ||=
1814       this._needAppearances &&
1815       data.fieldValue !== undefined &&
1816       data.fieldValue !== null;
1817 
1818     const fieldType = getInheritableProperty({ dict, key: "FT" });
1819     data.fieldType = fieldType instanceof Name ? fieldType.name : null;
1820 
1821     const localResources = getInheritableProperty({ dict, key: "DR" });
1822     const acroFormResources = annotationGlobals.acroForm.get("DR");
1823     const appearanceResources = this.appearance?.dict.get("Resources");
1824 
1825     this._fieldResources = {
1826       localResources,
1827       acroFormResources,
1828       appearanceResources,
1829       mergedResources: Dict.merge({
1830         xref,
1831         dictArray: [localResources, appearanceResources, acroFormResources],
1832         mergeSubDicts: true,
1833       }),
1834     };
1835 
1836     data.fieldFlags = getInheritableProperty({ dict, key: "Ff" });
1837     if (!Number.isInteger(data.fieldFlags) || data.fieldFlags < 0) {
1838       data.fieldFlags = 0;
1839     }
1840 
1841     data.readOnly = this.hasFieldFlag(AnnotationFieldFlag.READONLY);
1842     data.required = this.hasFieldFlag(AnnotationFieldFlag.REQUIRED);
1843     data.hidden =
1844       this._hasFlag(data.annotationFlags, AnnotationFlag.HIDDEN) ||
1845       this._hasFlag(data.annotationFlags, AnnotationFlag.NOVIEW);
1846   }
1847 
1848   /**
1849    * Decode the given form value.
1850    *
1851    * @private
1852    * @memberof WidgetAnnotation
1853    * @param {Array<string>|Name|string} formValue - The (possibly encoded)
1854    *   form value.
1855    * @returns {Array<string>|string|null}
1856    */
1857   _decodeFormValue(formValue) {
1858     if (Array.isArray(formValue)) {
1859       return formValue
1860         .filter(item => typeof item === "string")
1861         .map(item => stringToPDFString(item));
1862     } else if (formValue instanceof Name) {
1863       return stringToPDFString(formValue.name);
1864     } else if (typeof formValue === "string") {
1865       return stringToPDFString(formValue);
1866     }
1867     return null;
1868   }
1869 
1870   /**
1871    * Check if a provided field flag is set.
1872    *
1873    * @public
1874    * @memberof WidgetAnnotation
1875    * @param {number} flag - Hexadecimal representation for an annotation
1876    *                        field characteristic
1877    * @returns {boolean}
1878    * @see {@link shared/util.js}
1879    */
1880   hasFieldFlag(flag) {
1881     return !!(this.data.fieldFlags & flag);
1882   }
1883 
1884   /** @inheritdoc */
1885   _isViewable(flags) {
1886     // We don't take into account the `NOVIEW` or `HIDDEN` flags here,
1887     // since the visibility can be changed by js code, hence in case
1888     // it's made viewable, we should render it (with visibility set to
1889     // hidden).
1890     // We don't take into account the `INVISIBLE` flag here, since we've a known
1891     // annotation type.
1892     return true;
1893   }
1894 
1895   /** @inheritdoc */
1896   mustBeViewed(annotationStorage, renderForms) {
1897     if (renderForms) {
1898       return this.viewable;
1899     }
1900     return (
1901       super.mustBeViewed(annotationStorage, renderForms) &&
1902       !this._hasFlag(this.flags, AnnotationFlag.NOVIEW)
1903     );
1904   }
1905 
1906   getRotationMatrix(annotationStorage) {
1907     let rotation = annotationStorage?.get(this.data.id)?.rotation;
1908     if (rotation === undefined) {
1909       rotation = this.rotation;
1910     }
1911 
1912     if (rotation === 0) {
1913       return IDENTITY_MATRIX;
1914     }
1915 
1916     const width = this.data.rect[2] - this.data.rect[0];
1917     const height = this.data.rect[3] - this.data.rect[1];
1918 
1919     return getRotationMatrix(rotation, width, height);
1920   }
1921 
1922   getBorderAndBackgroundAppearances(annotationStorage) {
1923     let rotation = annotationStorage?.get(this.data.id)?.rotation;
1924     if (rotation === undefined) {
1925       rotation = this.rotation;
1926     }
1927 
1928     if (!this.backgroundColor && !this.borderColor) {
1929       return "";
1930     }
1931     const width = this.data.rect[2] - this.data.rect[0];
1932     const height = this.data.rect[3] - this.data.rect[1];
1933     const rect =
1934       rotation === 0 || rotation === 180
1935         ? `0 0 ${width} ${height} re`
1936         : `0 0 ${height} ${width} re`;
1937 
1938     let str = "";
1939     if (this.backgroundColor) {
1940       str = `${getPdfColor(
1941         this.backgroundColor,
1942         /* isFill */ true
1943       )} ${rect} f `;
1944     }
1945 
1946     if (this.borderColor) {
1947       const borderWidth = this.borderStyle.width || 1;
1948       str += `${borderWidth} w ${getPdfColor(
1949         this.borderColor,
1950         /* isFill */ false
1951       )} ${rect} S `;
1952     }
1953 
1954     return str;
1955   }
1956 
1957   async getOperatorList(
1958     evaluator,
1959     task,
1960     intent,
1961     renderForms,
1962     annotationStorage
1963   ) {
1964     // Do not render form elements on the canvas when interactive forms are
1965     // enabled. The display layer is responsible for rendering them instead.
1966     if (
1967       renderForms &&
1968       !(this instanceof SignatureWidgetAnnotation) &&
1969       !this.data.noHTML &&
1970       !this.data.hasOwnCanvas
1971     ) {
1972       return {
1973         opList: new OperatorList(),
1974         separateForm: true,
1975         separateCanvas: false,
1976       };
1977     }
1978 
1979     if (!this._hasText) {
1980       return super.getOperatorList(
1981         evaluator,
1982         task,
1983         intent,
1984         renderForms,
1985         annotationStorage
1986       );
1987     }
1988 
1989     const content = await this._getAppearance(
1990       evaluator,
1991       task,
1992       intent,
1993       annotationStorage
1994     );
1995     if (this.appearance && content === null) {
1996       return super.getOperatorList(
1997         evaluator,
1998         task,
1999         intent,
2000         renderForms,
2001         annotationStorage
2002       );
2003     }
2004 
2005     const opList = new OperatorList();
2006 
2007     // Even if there is an appearance stream, ignore it. This is the
2008     // behaviour used by Adobe Reader.
2009     if (!this._defaultAppearance || content === null) {
2010       return { opList, separateForm: false, separateCanvas: false };
2011     }
2012 
2013     const isUsingOwnCanvas = !!(
2014       this.data.hasOwnCanvas && intent & RenderingIntentFlag.DISPLAY
2015     );
2016 
2017     const matrix = [1, 0, 0, 1, 0, 0];
2018     const bbox = [
2019       0,
2020       0,
2021       this.data.rect[2] - this.data.rect[0],
2022       this.data.rect[3] - this.data.rect[1],
2023     ];
2024     const transform = getTransformMatrix(this.data.rect, bbox, matrix);
2025 
2026     let optionalContent;
2027     if (this.oc) {
2028       optionalContent = await evaluator.parseMarkedContentProps(
2029         this.oc,
2030         /* resources = */ null
2031       );
2032     }
2033     if (optionalContent !== undefined) {
2034       opList.addOp(OPS.beginMarkedContentProps, ["OC", optionalContent]);
2035     }
2036 
2037     opList.addOp(OPS.beginAnnotation, [
2038       this.data.id,
2039       this.data.rect,
2040       transform,
2041       this.getRotationMatrix(annotationStorage),
2042       isUsingOwnCanvas,
2043     ]);
2044 
2045     const stream = new StringStream(content);
2046     await evaluator.getOperatorList({
2047       stream,
2048       task,
2049       resources: this._fieldResources.mergedResources,
2050       operatorList: opList,
2051     });
2052     opList.addOp(OPS.endAnnotation, []);
2053 
2054     if (optionalContent !== undefined) {
2055       opList.addOp(OPS.endMarkedContent, []);
2056     }
2057     return { opList, separateForm: false, separateCanvas: isUsingOwnCanvas };
2058   }
2059 
2060   _getMKDict(rotation) {
2061     const mk = new Dict(null);
2062     if (rotation) {
2063       mk.set("R", rotation);
2064     }
2065     if (this.borderColor) {
2066       mk.set("BC", getPdfColorArray(this.borderColor));
2067     }
2068     if (this.backgroundColor) {
2069       mk.set("BG", getPdfColorArray(this.backgroundColor));
2070     }
2071     return mk.size > 0 ? mk : null;
2072   }
2073 
2074   amendSavedDict(annotationStorage, dict) {}
2075 
2076   async save(evaluator, task, annotationStorage) {
2077     const storageEntry = annotationStorage?.get(this.data.id);
2078     let value = storageEntry?.value,
2079       rotation = storageEntry?.rotation;
2080     if (value === this.data.fieldValue || value === undefined) {
2081       if (!this._hasValueFromXFA && rotation === undefined) {
2082         return null;
2083       }
2084       value ||= this.data.fieldValue;
2085     }
2086 
2087     // Value can be an array (with choice list and multiple selections)
2088     if (
2089       rotation === undefined &&
2090       !this._hasValueFromXFA &&
2091       Array.isArray(value) &&
2092       Array.isArray(this.data.fieldValue) &&
2093       value.length === this.data.fieldValue.length &&
2094       value.every((x, i) => x === this.data.fieldValue[i])
2095     ) {
2096       return null;
2097     }
2098 
2099     if (rotation === undefined) {
2100       rotation = this.rotation;
2101     }
2102 
2103     let appearance = null;
2104     if (!this._needAppearances) {
2105       appearance = await this._getAppearance(
2106         evaluator,
2107         task,
2108         RenderingIntentFlag.SAVE,
2109         annotationStorage
2110       );
2111       if (appearance === null) {
2112         // Appearance didn't change.
2113         return null;
2114       }
2115     } else {
2116       // No need to create an appearance: the pdf has the flag /NeedAppearances
2117       // which means that it's up to the reader to produce an appearance.
2118     }
2119 
2120     let needAppearances = false;
2121     if (appearance?.needAppearances) {
2122       needAppearances = true;
2123       appearance = null;
2124     }
2125 
2126     const { xref } = evaluator;
2127 
2128     const originalDict = xref.fetchIfRef(this.ref);
2129     if (!(originalDict instanceof Dict)) {
2130       return null;
2131     }
2132 
2133     const dict = new Dict(xref);
2134     for (const key of originalDict.getKeys()) {
2135       if (key !== "AP") {
2136         dict.set(key, originalDict.getRaw(key));
2137       }
2138     }
2139 
2140     const xfa = {
2141       path: this.data.fieldName,
2142       value,
2143     };
2144 
2145     const encoder = val =>
2146       isAscii(val) ? val : stringToUTF16String(val, /* bigEndian = */ true);
2147     dict.set("V", Array.isArray(value) ? value.map(encoder) : encoder(value));
2148     this.amendSavedDict(annotationStorage, dict);
2149 
2150     const maybeMK = this._getMKDict(rotation);
2151     if (maybeMK) {
2152       dict.set("MK", maybeMK);
2153     }
2154 
2155     const buffer = [];
2156     const changes = [
2157       // data for the original object
2158       // V field changed + reference for new AP
2159       { ref: this.ref, data: "", xfa, needAppearances },
2160     ];
2161     if (appearance !== null) {
2162       const newRef = xref.getNewTemporaryRef();
2163       const AP = new Dict(xref);
2164       dict.set("AP", AP);
2165       AP.set("N", newRef);
2166 
2167       const resources = this._getSaveFieldResources(xref);
2168       const appearanceStream = new StringStream(appearance);
2169       const appearanceDict = (appearanceStream.dict = new Dict(xref));
2170       appearanceDict.set("Subtype", Name.get("Form"));
2171       appearanceDict.set("Resources", resources);
2172       appearanceDict.set("BBox", [
2173         0,
2174         0,
2175         this.data.rect[2] - this.data.rect[0],
2176         this.data.rect[3] - this.data.rect[1],
2177       ]);
2178 
2179       const rotationMatrix = this.getRotationMatrix(annotationStorage);
2180       if (rotationMatrix !== IDENTITY_MATRIX) {
2181         // The matrix isn't the identity one.
2182         appearanceDict.set("Matrix", rotationMatrix);
2183       }
2184 
2185       await writeObject(newRef, appearanceStream, buffer, xref);
2186 
2187       changes.push(
2188         // data for the new AP
2189         {
2190           ref: newRef,
2191           data: buffer.join(""),
2192           xfa: null,
2193           needAppearances: false,
2194         }
2195       );
2196       buffer.length = 0;
2197     }
2198 
2199     dict.set("M", `D:${getModificationDate()}`);
2200     await writeObject(this.ref, dict, buffer, xref);
2201 
2202     changes[0].data = buffer.join("");
2203 
2204     return changes;
2205   }
2206 
2207   async _getAppearance(evaluator, task, intent, annotationStorage) {
2208     const isPassword = this.hasFieldFlag(AnnotationFieldFlag.PASSWORD);
2209     if (isPassword) {
2210       return null;
2211     }
2212     const storageEntry = annotationStorage?.get(this.data.id);
2213     let value, rotation;
2214     if (storageEntry) {
2215       value = storageEntry.formattedValue || storageEntry.value;
2216       rotation = storageEntry.rotation;
2217     }
2218 
2219     if (
2220       rotation === undefined &&
2221       value === undefined &&
2222       !this._needAppearances
2223     ) {
2224       if (!this._hasValueFromXFA || this.appearance) {
2225         // The annotation hasn't been rendered so use the appearance.
2226         return null;
2227       }
2228     }
2229 
2230     // Empty or it has a trailing whitespace.
2231     const colors = this.getBorderAndBackgroundAppearances(annotationStorage);
2232 
2233     if (value === undefined) {
2234       // The annotation has its value in XFA datasets but not in the V field.
2235       value = this.data.fieldValue;
2236       if (!value) {
2237         return `/Tx BMC q ${colors}Q EMC`;
2238       }
2239     }
2240 
2241     if (Array.isArray(value) && value.length === 1) {
2242       value = value[0];
2243     }
2244 
2245     assert(typeof value === "string", "Expected `value` to be a string.");
2246     value = value.trim();
2247 
2248     if (this.data.combo) {
2249       // The value can be one of the exportValue or any other values.
2250       const option = this.data.options.find(
2251         ({ exportValue }) => value === exportValue
2252       );
2253       value = option?.displayValue || value;
2254     }
2255 
2256     if (value === "") {
2257       // the field is empty: nothing to render
2258       return `/Tx BMC q ${colors}Q EMC`;
2259     }
2260 
2261     if (rotation === undefined) {
2262       rotation = this.rotation;
2263     }
2264 
2265     let lineCount = -1;
2266     let lines;
2267 
2268     // We could have a text containing for example some sequences of chars and
2269     // their diacritics (e.g. "é".normalize("NFKD") shows 1 char when it's 2).
2270     // Positioning diacritics is really something we don't want to do here.
2271     // So if a font has a glyph for a acute accent and one for "e" then we won't
2272     // get any encoding issues but we'll render "e" and then "´".
2273     // It's why we normalize the string. We use NFC to preserve the initial
2274     // string, (e.g. "²".normalize("NFC") === "²"
2275     // but "²".normalize("NFKC") === "2").
2276     //
2277     // TODO: it isn't a perfect solution, some chars like "ẹ́" will be
2278     // decomposed into two chars ("ẹ" and "´"), so we should detect such
2279     // situations and then use either FakeUnicodeFont or set the
2280     // /NeedAppearances flag.
2281     if (this.data.multiLine) {
2282       lines = value.split(/\r\n?|\n/).map(line => line.normalize("NFC"));
2283       lineCount = lines.length;
2284     } else {
2285       lines = [value.replace(/\r\n?|\n/, "").normalize("NFC")];
2286     }
2287 
2288     const defaultPadding = 1;
2289     const defaultHPadding = 2;
2290     let totalHeight = this.data.rect[3] - this.data.rect[1];
2291     let totalWidth = this.data.rect[2] - this.data.rect[0];
2292 
2293     if (rotation === 90 || rotation === 270) {
2294       [totalWidth, totalHeight] = [totalHeight, totalWidth];
2295     }
2296 
2297     if (!this._defaultAppearance) {
2298       // The DA is required and must be a string.
2299       // If there is no font named Helvetica in the resource dictionary,
2300       // the evaluator will fall back to a default font.
2301       // Doing so prevents exceptions and allows saving/printing
2302       // the file as expected.
2303       this.data.defaultAppearanceData = parseDefaultAppearance(
2304         (this._defaultAppearance = "/Helvetica 0 Tf 0 g")
2305       );
2306     }
2307 
2308     let font = await WidgetAnnotation._getFontData(
2309       evaluator,
2310       task,
2311       this.data.defaultAppearanceData,
2312       this._fieldResources.mergedResources
2313     );
2314 
2315     let defaultAppearance, fontSize, lineHeight;
2316     const encodedLines = [];
2317     let encodingError = false;
2318     for (const line of lines) {
2319       const encodedString = font.encodeString(line);
2320       if (encodedString.length > 1) {
2321         encodingError = true;
2322       }
2323       encodedLines.push(encodedString.join(""));
2324     }
2325 
2326     if (encodingError && intent & RenderingIntentFlag.SAVE) {
2327       // We don't have a way to render the field, so we just rely on the
2328       // /NeedAppearances trick to let the different sofware correctly render
2329       // this pdf.
2330       return { needAppearances: true };
2331     }
2332 
2333     // We check that the font is able to encode the string.
2334     if (encodingError && this._isOffscreenCanvasSupported) {
2335       // If it can't then we fallback on fake unicode font (mapped to sans-serif
2336       // for the rendering).
2337       // It means that a printed form can be rendered differently (it depends on
2338       // the sans-serif font) but at least we've something to render.
2339       // In an ideal world the associated font should correctly handle the
2340       // possible chars but a user can add a smiley or whatever.
2341       // We could try to embed a font but it means that we must have access
2342       // to the raw font file.
2343       const fontFamily = this.data.comb ? "monospace" : "sans-serif";
2344       const fakeUnicodeFont = new FakeUnicodeFont(evaluator.xref, fontFamily);
2345       const resources = fakeUnicodeFont.createFontResources(lines.join(""));
2346       const newFont = resources.getRaw("Font");
2347 
2348       if (this._fieldResources.mergedResources.has("Font")) {
2349         const oldFont = this._fieldResources.mergedResources.get("Font");
2350         for (const key of newFont.getKeys()) {
2351           oldFont.set(key, newFont.getRaw(key));
2352         }
2353       } else {
2354         this._fieldResources.mergedResources.set("Font", newFont);
2355       }
2356 
2357       const fontName = fakeUnicodeFont.fontName.name;
2358       font = await WidgetAnnotation._getFontData(
2359         evaluator,
2360         task,
2361         { fontName, fontSize: 0 },
2362         resources
2363       );
2364 
2365       for (let i = 0, ii = encodedLines.length; i < ii; i++) {
2366         encodedLines[i] = stringToUTF16String(lines[i]);
2367       }
2368 
2369       const savedDefaultAppearance = Object.assign(
2370         Object.create(null),
2371         this.data.defaultAppearanceData
2372       );
2373       this.data.defaultAppearanceData.fontSize = 0;
2374       this.data.defaultAppearanceData.fontName = fontName;
2375 
2376       [defaultAppearance, fontSize, lineHeight] = this._computeFontSize(
2377         totalHeight - 2 * defaultPadding,
2378         totalWidth - 2 * defaultHPadding,
2379         value,
2380         font,
2381         lineCount
2382       );
2383 
2384       this.data.defaultAppearanceData = savedDefaultAppearance;
2385     } else {
2386       if (!this._isOffscreenCanvasSupported) {
2387         warn(
2388           "_getAppearance: OffscreenCanvas is not supported, annotation may not render correctly."
2389         );
2390       }
2391 
2392       [defaultAppearance, fontSize, lineHeight] = this._computeFontSize(
2393         totalHeight - 2 * defaultPadding,
2394         totalWidth - 2 * defaultHPadding,
2395         value,
2396         font,
2397         lineCount
2398       );
2399     }
2400 
2401     let descent = font.descent;
2402     if (isNaN(descent)) {
2403       descent = BASELINE_FACTOR * lineHeight;
2404     } else {
2405       descent = Math.max(
2406         BASELINE_FACTOR * lineHeight,
2407         Math.abs(descent) * fontSize
2408       );
2409     }
2410 
2411     // Take into account the space we have to compute the default vertical
2412     // padding.
2413     const defaultVPadding = Math.min(
2414       Math.floor((totalHeight - fontSize) / 2),
2415       defaultPadding
2416     );
2417     const alignment = this.data.textAlignment;
2418 
2419     if (this.data.multiLine) {
2420       return this._getMultilineAppearance(
2421         defaultAppearance,
2422         encodedLines,
2423         font,
2424         fontSize,
2425         totalWidth,
2426         totalHeight,
2427         alignment,
2428         defaultHPadding,
2429         defaultVPadding,
2430         descent,
2431         lineHeight,
2432         annotationStorage
2433       );
2434     }
2435 
2436     if (this.data.comb) {
2437       return this._getCombAppearance(
2438         defaultAppearance,
2439         font,
2440         encodedLines[0],
2441         fontSize,
2442         totalWidth,
2443         totalHeight,
2444         defaultHPadding,
2445         defaultVPadding,
2446         descent,
2447         lineHeight,
2448         annotationStorage
2449       );
2450     }
2451 
2452     const bottomPadding = defaultVPadding + descent;
2453     if (alignment === 0 || alignment > 2) {
2454       // Left alignment: nothing to do
2455       return (
2456         `/Tx BMC q ${colors}BT ` +
2457         defaultAppearance +
2458         ` 1 0 0 1 ${numberToString(defaultHPadding)} ${numberToString(
2459           bottomPadding
2460         )} Tm (${escapeString(encodedLines[0])}) Tj` +
2461         " ET Q EMC"
2462       );
2463     }
2464 
2465     const prevInfo = { shift: 0 };
2466     const renderedText = this._renderText(
2467       encodedLines[0],
2468       font,
2469       fontSize,
2470       totalWidth,
2471       alignment,
2472       prevInfo,
2473       defaultHPadding,
2474       bottomPadding
2475     );
2476     return (
2477       `/Tx BMC q ${colors}BT ` +
2478       defaultAppearance +
2479       ` 1 0 0 1 0 0 Tm ${renderedText}` +
2480       " ET Q EMC"
2481     );
2482   }
2483 
2484   static async _getFontData(evaluator, task, appearanceData, resources) {
2485     const operatorList = new OperatorList();
2486     const initialState = {
2487       font: null,
2488       clone() {
2489         return this;
2490       },
2491     };
2492 
2493     const { fontName, fontSize } = appearanceData;
2494     await evaluator.handleSetFont(
2495       resources,
2496       [fontName && Name.get(fontName), fontSize],
2497       /* fontRef = */ null,
2498       operatorList,
2499       task,
2500       initialState,
2501       /* fallbackFontDict = */ null
2502     );
2503 
2504     return initialState.font;
2505   }
2506 
2507   _getTextWidth(text, font) {
2508     return (
2509       font
2510         .charsToGlyphs(text)
2511         .reduce((width, glyph) => width + glyph.width, 0) / 1000
2512     );
2513   }
2514 
2515   _computeFontSize(height, width, text, font, lineCount) {
2516     let { fontSize } = this.data.defaultAppearanceData;
2517     let lineHeight = (fontSize || 12) * LINE_FACTOR,
2518       numberOfLines = Math.round(height / lineHeight);
2519 
2520     if (!fontSize) {
2521       // A zero value for size means that the font shall be auto-sized:
2522       // its size shall be computed as a function of the height of the
2523       // annotation rectangle (see 12.7.3.3).
2524 
2525       const roundWithTwoDigits = x => Math.floor(x * 100) / 100;
2526 
2527       if (lineCount === -1) {
2528         const textWidth = this._getTextWidth(text, font);
2529         fontSize = roundWithTwoDigits(
2530           Math.min(
2531             height / LINE_FACTOR,
2532             textWidth > width ? width / textWidth : Infinity
2533           )
2534         );
2535         numberOfLines = 1;
2536       } else {
2537         const lines = text.split(/\r\n?|\n/);
2538         const cachedLines = [];
2539         for (const line of lines) {
2540           const encoded = font.encodeString(line).join("");
2541           const glyphs = font.charsToGlyphs(encoded);
2542           const positions = font.getCharPositions(encoded);
2543           cachedLines.push({
2544             line: encoded,
2545             glyphs,
2546             positions,
2547           });
2548         }
2549 
2550         const isTooBig = fsize => {
2551           // Return true when the text doesn't fit the given height.
2552           let totalHeight = 0;
2553           for (const cache of cachedLines) {
2554             const chunks = this._splitLine(null, font, fsize, width, cache);
2555             totalHeight += chunks.length * fsize;
2556             if (totalHeight > height) {
2557               return true;
2558             }
2559           }
2560           return false;
2561         };
2562 
2563         // Hard to guess how many lines there are.
2564         // The field may have been sized to have 10 lines
2565         // and the user entered only 1 so if we get font size from
2566         // height and number of lines then we'll get something too big.
2567         // So we compute a fake number of lines based on height and
2568         // a font size equal to 12 (this is the default font size in
2569         // Acrobat).
2570         // Then we'll adjust font size to what we have really.
2571         numberOfLines = Math.max(numberOfLines, lineCount);
2572 
2573         while (true) {
2574           lineHeight = height / numberOfLines;
2575           fontSize = roundWithTwoDigits(lineHeight / LINE_FACTOR);
2576 
2577           if (isTooBig(fontSize)) {
2578             numberOfLines++;
2579             continue;
2580           }
2581 
2582           break;
2583         }
2584       }
2585 
2586       const { fontName, fontColor } = this.data.defaultAppearanceData;
2587       this._defaultAppearance = createDefaultAppearance({
2588         fontSize,
2589         fontName,
2590         fontColor,
2591       });
2592     }
2593 
2594     return [this._defaultAppearance, fontSize, height / numberOfLines];
2595   }
2596 
2597   _renderText(
2598     text,
2599     font,
2600     fontSize,
2601     totalWidth,
2602     alignment,
2603     prevInfo,
2604     hPadding,
2605     vPadding
2606   ) {
2607     // TODO: we need to take into account (if possible) how the text
2608     // is rendered. For example in arabic, the cumulated width of some
2609     // glyphs isn't equal to the width of the rendered glyphs because
2610     // of ligatures.
2611     let shift;
2612     if (alignment === 1) {
2613       // Center
2614       const width = this._getTextWidth(text, font) * fontSize;
2615       shift = (totalWidth - width) / 2;
2616     } else if (alignment === 2) {
2617       // Right
2618       const width = this._getTextWidth(text, font) * fontSize;
2619       shift = totalWidth - width - hPadding;
2620     } else {
2621       shift = hPadding;
2622     }
2623     const shiftStr = numberToString(shift - prevInfo.shift);
2624     prevInfo.shift = shift;
2625     vPadding = numberToString(vPadding);
2626 
2627     return `${shiftStr} ${vPadding} Td (${escapeString(text)}) Tj`;
2628   }
2629 
2630   /**
2631    * @private
2632    */
2633   _getSaveFieldResources(xref) {
2634     if (typeof PDFJSDev === "undefined" || PDFJSDev.test("TESTING")) {
2635       assert(
2636         this.data.defaultAppearanceData,
2637         "Expected `_defaultAppearanceData` to have been set."
2638       );
2639     }
2640     const { localResources, appearanceResources, acroFormResources } =
2641       this._fieldResources;
2642 
2643     const fontName = this.data.defaultAppearanceData?.fontName;
2644     if (!fontName) {
2645       return localResources || Dict.empty;
2646     }
2647 
2648     for (const resources of [localResources, appearanceResources]) {
2649       if (resources instanceof Dict) {
2650         const localFont = resources.get("Font");
2651         if (localFont instanceof Dict && localFont.has(fontName)) {
2652           return resources;
2653         }
2654       }
2655     }
2656     if (acroFormResources instanceof Dict) {
2657       const acroFormFont = acroFormResources.get("Font");
2658       if (acroFormFont instanceof Dict && acroFormFont.has(fontName)) {
2659         const subFontDict = new Dict(xref);
2660         subFontDict.set(fontName, acroFormFont.getRaw(fontName));
2661 
2662         const subResourcesDict = new Dict(xref);
2663         subResourcesDict.set("Font", subFontDict);
2664 
2665         return Dict.merge({
2666           xref,
2667           dictArray: [subResourcesDict, localResources],
2668           mergeSubDicts: true,
2669         });
2670       }
2671     }
2672     return localResources || Dict.empty;
2673   }
2674 
2675   getFieldObject() {
2676     return null;
2677   }
2678 }
2679 
2680 class TextWidgetAnnotation extends WidgetAnnotation {
2681   constructor(params) {
2682     super(params);
2683 
2684     this.data.hasOwnCanvas = this.data.readOnly && !this.data.noHTML;
2685     this._hasText = true;
2686 
2687     const dict = params.dict;
2688 
2689     // The field value is always a string.
2690     if (typeof this.data.fieldValue !== "string") {
2691       this.data.fieldValue = "";
2692     }
2693 
2694     // Determine the alignment of text in the field.
2695     let alignment = getInheritableProperty({ dict, key: "Q" });
2696     if (!Number.isInteger(alignment) || alignment < 0 || alignment > 2) {
2697       alignment = null;
2698     }
2699     this.data.textAlignment = alignment;
2700 
2701     // Determine the maximum length of text in the field.
2702     let maximumLength = getInheritableProperty({ dict, key: "MaxLen" });
2703     if (!Number.isInteger(maximumLength) || maximumLength < 0) {
2704       maximumLength = 0;
2705     }
2706     this.data.maxLen = maximumLength;
2707 
2708     // Process field flags for the display layer.
2709     this.data.multiLine = this.hasFieldFlag(AnnotationFieldFlag.MULTILINE);
2710     this.data.comb =
2711       this.hasFieldFlag(AnnotationFieldFlag.COMB) &&
2712       !this.hasFieldFlag(AnnotationFieldFlag.MULTILINE) &&
2713       !this.hasFieldFlag(AnnotationFieldFlag.PASSWORD) &&
2714       !this.hasFieldFlag(AnnotationFieldFlag.FILESELECT) &&
2715       this.data.maxLen !== 0;
2716     this.data.doNotScroll = this.hasFieldFlag(AnnotationFieldFlag.DONOTSCROLL);
2717   }
2718 
2719   get hasTextContent() {
2720     return !!this.appearance && !this._needAppearances;
2721   }
2722 
2723   _getCombAppearance(
2724     defaultAppearance,
2725     font,
2726     text,
2727     fontSize,
2728     width,
2729     height,
2730     hPadding,
2731     vPadding,
2732     descent,
2733     lineHeight,
2734     annotationStorage
2735   ) {
2736     const combWidth = width / this.data.maxLen;
2737     // Empty or it has a trailing whitespace.
2738     const colors = this.getBorderAndBackgroundAppearances(annotationStorage);
2739 
2740     const buf = [];
2741     const positions = font.getCharPositions(text);
2742     for (const [start, end] of positions) {
2743       buf.push(`(${escapeString(text.substring(start, end))}) Tj`);
2744     }
2745 
2746     const renderedComb = buf.join(` ${numberToString(combWidth)} 0 Td `);
2747     return (
2748       `/Tx BMC q ${colors}BT ` +
2749       defaultAppearance +
2750       ` 1 0 0 1 ${numberToString(hPadding)} ${numberToString(
2751         vPadding + descent
2752       )} Tm ${renderedComb}` +
2753       " ET Q EMC"
2754     );
2755   }
2756 
2757   _getMultilineAppearance(
2758     defaultAppearance,
2759     lines,
2760     font,
2761     fontSize,
2762     width,
2763     height,
2764     alignment,
2765     hPadding,
2766     vPadding,
2767     descent,
2768     lineHeight,
2769     annotationStorage
2770   ) {
2771     const buf = [];
2772     const totalWidth = width - 2 * hPadding;
2773     const prevInfo = { shift: 0 };
2774     for (let i = 0, ii = lines.length; i < ii; i++) {
2775       const line = lines[i];
2776       const chunks = this._splitLine(line, font, fontSize, totalWidth);
2777       for (let j = 0, jj = chunks.length; j < jj; j++) {
2778         const chunk = chunks[j];
2779         const vShift =
2780           i === 0 && j === 0 ? -vPadding - (lineHeight - descent) : -lineHeight;
2781         buf.push(
2782           this._renderText(
2783             chunk,
2784             font,
2785             fontSize,
2786             width,
2787             alignment,
2788             prevInfo,
2789             hPadding,
2790             vShift
2791           )
2792         );
2793       }
2794     }
2795 
2796     // Empty or it has a trailing whitespace.
2797     const colors = this.getBorderAndBackgroundAppearances(annotationStorage);
2798     const renderedText = buf.join("\n");
2799 
2800     return (
2801       `/Tx BMC q ${colors}BT ` +
2802       defaultAppearance +
2803       ` 1 0 0 1 0 ${numberToString(height)} Tm ${renderedText}` +
2804       " ET Q EMC"
2805     );
2806   }
2807 
2808   _splitLine(line, font, fontSize, width, cache = {}) {
2809     line = cache.line || line;
2810 
2811     const glyphs = cache.glyphs || font.charsToGlyphs(line);
2812 
2813     if (glyphs.length <= 1) {
2814       // Nothing to split
2815       return [line];
2816     }
2817 
2818     const positions = cache.positions || font.getCharPositions(line);
2819     const scale = fontSize / 1000;
2820     const chunks = [];
2821 
2822     let lastSpacePosInStringStart = -1,
2823       lastSpacePosInStringEnd = -1,
2824       lastSpacePos = -1,
2825       startChunk = 0,
2826       currentWidth = 0;
2827 
2828     for (let i = 0, ii = glyphs.length; i < ii; i++) {
2829       const [start, end] = positions[i];
2830       const glyph = glyphs[i];
2831       const glyphWidth = glyph.width * scale;
2832       if (glyph.unicode === " ") {
2833         if (currentWidth + glyphWidth > width) {
2834           // We can break here
2835           chunks.push(line.substring(startChunk, start));
2836           startChunk = start;
2837           currentWidth = glyphWidth;
2838           lastSpacePosInStringStart = -1;
2839           lastSpacePos = -1;
2840         } else {
2841           currentWidth += glyphWidth;
2842           lastSpacePosInStringStart = start;
2843           lastSpacePosInStringEnd = end;
2844           lastSpacePos = i;
2845         }
2846       } else if (currentWidth + glyphWidth > width) {
2847         // We must break to the last white position (if available)
2848         if (lastSpacePosInStringStart !== -1) {
2849           chunks.push(line.substring(startChunk, lastSpacePosInStringEnd));
2850           startChunk = lastSpacePosInStringEnd;
2851           i = lastSpacePos + 1;
2852           lastSpacePosInStringStart = -1;
2853           currentWidth = 0;
2854         } else {
2855           // Just break in the middle of the word
2856           chunks.push(line.substring(startChunk, start));
2857           startChunk = start;
2858           currentWidth = glyphWidth;
2859         }
2860       } else {
2861         currentWidth += glyphWidth;
2862       }
2863     }
2864 
2865     if (startChunk < line.length) {
2866       chunks.push(line.substring(startChunk, line.length));
2867     }
2868 
2869     return chunks;
2870   }
2871 
2872   getFieldObject() {
2873     return {
2874       id: this.data.id,
2875       value: this.data.fieldValue,
2876       defaultValue: this.data.defaultFieldValue || "",
2877       multiline: this.data.multiLine,
2878       password: this.hasFieldFlag(AnnotationFieldFlag.PASSWORD),
2879       charLimit: this.data.maxLen,
2880       comb: this.data.comb,
2881       editable: !this.data.readOnly,
2882       hidden: this.data.hidden,
2883       name: this.data.fieldName,
2884       rect: this.data.rect,
2885       actions: this.data.actions,
2886       page: this.data.pageIndex,
2887       strokeColor: this.data.borderColor,
2888       fillColor: this.data.backgroundColor,
2889       rotation: this.rotation,
2890       type: "text",
2891     };
2892   }
2893 }
2894 
2895 class ButtonWidgetAnnotation extends WidgetAnnotation {
2896   constructor(params) {
2897     super(params);
2898 
2899     this.checkedAppearance = null;
2900     this.uncheckedAppearance = null;
2901 
2902     this.data.checkBox =
2903       !this.hasFieldFlag(AnnotationFieldFlag.RADIO) &&
2904       !this.hasFieldFlag(AnnotationFieldFlag.PUSHBUTTON);
2905     this.data.radioButton =
2906       this.hasFieldFlag(AnnotationFieldFlag.RADIO) &&
2907       !this.hasFieldFlag(AnnotationFieldFlag.PUSHBUTTON);
2908     this.data.pushButton = this.hasFieldFlag(AnnotationFieldFlag.PUSHBUTTON);
2909     this.data.isTooltipOnly = false;
2910 
2911     if (this.data.checkBox) {
2912       this._processCheckBox(params);
2913     } else if (this.data.radioButton) {
2914       this._processRadioButton(params);
2915     } else if (this.data.pushButton) {
2916       this.data.hasOwnCanvas = true;
2917       this.data.noHTML = false;
2918       this._processPushButton(params);
2919     } else {
2920       warn("Invalid field flags for button widget annotation");
2921     }
2922   }
2923 
2924   async getOperatorList(
2925     evaluator,
2926     task,
2927     intent,
2928     renderForms,
2929     annotationStorage
2930   ) {
2931     if (this.data.pushButton) {
2932       return super.getOperatorList(
2933         evaluator,
2934         task,
2935         intent,
2936         false, // we use normalAppearance to render the button
2937         annotationStorage
2938       );
2939     }
2940 
2941     let value = null;
2942     let rotation = null;
2943     if (annotationStorage) {
2944       const storageEntry = annotationStorage.get(this.data.id);
2945       value = storageEntry ? storageEntry.value : null;
2946       rotation = storageEntry ? storageEntry.rotation : null;
2947     }
2948 
2949     if (value === null && this.appearance) {
2950       // Nothing in the annotationStorage.
2951       // But we've a default appearance so use it.
2952       return super.getOperatorList(
2953         evaluator,
2954         task,
2955         intent,
2956         renderForms,
2957         annotationStorage
2958       );
2959     }
2960 
2961     if (value === null || value === undefined) {
2962       // There is no default appearance so use the one derived
2963       // from the field value.
2964       value = this.data.checkBox
2965         ? this.data.fieldValue === this.data.exportValue
2966         : this.data.fieldValue === this.data.buttonValue;
2967     }
2968 
2969     const appearance = value
2970       ? this.checkedAppearance
2971       : this.uncheckedAppearance;
2972     if (appearance) {
2973       const savedAppearance = this.appearance;
2974       const savedMatrix = lookupMatrix(
2975         appearance.dict.getArray("Matrix"),
2976         IDENTITY_MATRIX
2977       );
2978 
2979       if (rotation) {
2980         appearance.dict.set(
2981           "Matrix",
2982           this.getRotationMatrix(annotationStorage)
2983         );
2984       }
2985 
2986       this.appearance = appearance;
2987       const operatorList = super.getOperatorList(
2988         evaluator,
2989         task,
2990         intent,
2991         renderForms,
2992         annotationStorage
2993       );
2994       this.appearance = savedAppearance;
2995       appearance.dict.set("Matrix", savedMatrix);
2996       return operatorList;
2997     }
2998 
2999     // No appearance
3000     return {
3001       opList: new OperatorList(),
3002       separateForm: false,
3003       separateCanvas: false,
3004     };
3005   }
3006 
3007   async save(evaluator, task, annotationStorage) {
3008     if (this.data.checkBox) {
3009       return this._saveCheckbox(evaluator, task, annotationStorage);
3010     }
3011 
3012     if (this.data.radioButton) {
3013       return this._saveRadioButton(evaluator, task, annotationStorage);
3014     }
3015 
3016     // Nothing to save
3017     return null;
3018   }
3019 
3020   async _saveCheckbox(evaluator, task, annotationStorage) {
3021     if (!annotationStorage) {
3022       return null;
3023     }
3024     const storageEntry = annotationStorage.get(this.data.id);
3025     let rotation = storageEntry?.rotation,
3026       value = storageEntry?.value;
3027 
3028     if (rotation === undefined) {
3029       if (value === undefined) {
3030         return null;
3031       }
3032 
3033       const defaultValue = this.data.fieldValue === this.data.exportValue;
3034       if (defaultValue === value) {
3035         return null;
3036       }
3037     }
3038 
3039     const dict = evaluator.xref.fetchIfRef(this.ref);
3040     if (!(dict instanceof Dict)) {
3041       return null;
3042     }
3043 
3044     if (rotation === undefined) {
3045       rotation = this.rotation;
3046     }
3047     if (value === undefined) {
3048       value = this.data.fieldValue === this.data.exportValue;
3049     }
3050 
3051     const xfa = {
3052       path: this.data.fieldName,
3053       value: value ? this.data.exportValue : "",
3054     };
3055 
3056     const name = Name.get(value ? this.data.exportValue : "Off");
3057     dict.set("V", name);
3058     dict.set("AS", name);
3059     dict.set("M", `D:${getModificationDate()}`);
3060 
3061     const maybeMK = this._getMKDict(rotation);
3062     if (maybeMK) {
3063       dict.set("MK", maybeMK);
3064     }
3065 
3066     const buffer = [];
3067     await writeObject(this.ref, dict, buffer, evaluator.xref);
3068 
3069     return [{ ref: this.ref, data: buffer.join(""), xfa }];
3070   }
3071 
3072   async _saveRadioButton(evaluator, task, annotationStorage) {
3073     if (!annotationStorage) {
3074       return null;
3075     }
3076     const storageEntry = annotationStorage.get(this.data.id);
3077     let rotation = storageEntry?.rotation,
3078       value = storageEntry?.value;
3079 
3080     if (rotation === undefined) {
3081       if (value === undefined) {
3082         return null;
3083       }
3084 
3085       const defaultValue = this.data.fieldValue === this.data.buttonValue;
3086       if (defaultValue === value) {
3087         return null;
3088       }
3089     }
3090 
3091     const dict = evaluator.xref.fetchIfRef(this.ref);
3092     if (!(dict instanceof Dict)) {
3093       return null;
3094     }
3095 
3096     if (value === undefined) {
3097       value = this.data.fieldValue === this.data.buttonValue;
3098     }
3099 
3100     if (rotation === undefined) {
3101       rotation = this.rotation;
3102     }
3103 
3104     const xfa = {
3105       path: this.data.fieldName,
3106       value: value ? this.data.buttonValue : "",
3107     };
3108 
3109     const name = Name.get(value ? this.data.buttonValue : "Off");
3110     const buffer = [];
3111     let parentData = null;
3112 
3113     if (value) {
3114       if (this.parent instanceof Ref) {
3115         const parent = evaluator.xref.fetch(this.parent);
3116         parent.set("V", name);
3117         await writeObject(this.parent, parent, buffer, evaluator.xref);
3118         parentData = buffer.join("");
3119         buffer.length = 0;
3120       } else if (this.parent instanceof Dict) {
3121         this.parent.set("V", name);
3122       }
3123     }
3124 
3125     dict.set("AS", name);
3126     dict.set("M", `D:${getModificationDate()}`);
3127 
3128     const maybeMK = this._getMKDict(rotation);
3129     if (maybeMK) {
3130       dict.set("MK", maybeMK);
3131     }
3132 
3133     await writeObject(this.ref, dict, buffer, evaluator.xref);
3134     const newRefs = [{ ref: this.ref, data: buffer.join(""), xfa }];
3135     if (parentData) {
3136       newRefs.push({ ref: this.parent, data: parentData, xfa: null });
3137     }
3138 
3139     return newRefs;
3140   }
3141 
3142   _getDefaultCheckedAppearance(params, type) {
3143     const width = this.data.rect[2] - this.data.rect[0];
3144     const height = this.data.rect[3] - this.data.rect[1];
3145     const bbox = [0, 0, width, height];
3146 
3147     // Ratio used to have a mark slightly smaller than the bbox.
3148     const FONT_RATIO = 0.8;
3149     const fontSize = Math.min(width, height) * FONT_RATIO;
3150 
3151     // Char Metrics
3152     // Widths came from widths for ZapfDingbats.
3153     // Heights are guessed with Fontforge and FoxitDingbats.pfb.
3154     let metrics, char;
3155     if (type === "check") {
3156       // Char 33 (2713 in unicode)
3157       metrics = {
3158         width: 0.755 * fontSize,
3159         height: 0.705 * fontSize,
3160       };
3161       char = "\x33";
3162     } else if (type === "disc") {
3163       // Char 6C (25CF in unicode)
3164       metrics = {
3165         width: 0.791 * fontSize,
3166         height: 0.705 * fontSize,
3167       };
3168       char = "\x6C";
3169     } else {
3170       unreachable(`_getDefaultCheckedAppearance - unsupported type: ${type}`);
3171     }
3172 
3173     // Values to center the glyph in the bbox.
3174     const xShift = numberToString((width - metrics.width) / 2);
3175     const yShift = numberToString((height - metrics.height) / 2);
3176 
3177     const appearance = `q BT /PdfJsZaDb ${fontSize} Tf 0 g ${xShift} ${yShift} Td (${char}) Tj ET Q`;
3178 
3179     const appearanceStreamDict = new Dict(params.xref);
3180     appearanceStreamDict.set("FormType", 1);
3181     appearanceStreamDict.set("Subtype", Name.get("Form"));
3182     appearanceStreamDict.set("Type", Name.get("XObject"));
3183     appearanceStreamDict.set("BBox", bbox);
3184     appearanceStreamDict.set("Matrix", [1, 0, 0, 1, 0, 0]);
3185     appearanceStreamDict.set("Length", appearance.length);
3186 
3187     const resources = new Dict(params.xref);
3188     const font = new Dict(params.xref);
3189     font.set("PdfJsZaDb", this.fallbackFontDict);
3190     resources.set("Font", font);
3191 
3192     appearanceStreamDict.set("Resources", resources);
3193 
3194     this.checkedAppearance = new StringStream(appearance);
3195     this.checkedAppearance.dict = appearanceStreamDict;
3196 
3197     this._streams.push(this.checkedAppearance);
3198   }
3199 
3200   _processCheckBox(params) {
3201     const customAppearance = params.dict.get("AP");
3202     if (!(customAppearance instanceof Dict)) {
3203       return;
3204     }
3205 
3206     const normalAppearance = customAppearance.get("N");
3207     if (!(normalAppearance instanceof Dict)) {
3208       return;
3209     }
3210 
3211     // See https://bugzilla.mozilla.org/show_bug.cgi?id=1722036.
3212     // If we've an AS and a V then take AS.
3213     const asValue = this._decodeFormValue(params.dict.get("AS"));
3214     if (typeof asValue === "string") {
3215       this.data.fieldValue = asValue;
3216     }
3217 
3218     const yes =
3219       this.data.fieldValue !== null && this.data.fieldValue !== "Off"
3220         ? this.data.fieldValue
3221         : "Yes";
3222 
3223     const exportValues = normalAppearance.getKeys();
3224     if (exportValues.length === 0) {
3225       exportValues.push("Off", yes);
3226     } else if (exportValues.length === 1) {
3227       if (exportValues[0] === "Off") {
3228         exportValues.push(yes);
3229       } else {
3230         exportValues.unshift("Off");
3231       }
3232     } else if (exportValues.includes(yes)) {
3233       exportValues.length = 0;
3234       exportValues.push("Off", yes);
3235     } else {
3236       const otherYes = exportValues.find(v => v !== "Off");
3237       exportValues.length = 0;
3238       exportValues.push("Off", otherYes);
3239     }
3240 
3241     // Don't use a "V" entry pointing to a non-existent appearance state,
3242     // see e.g. bug1720411.pdf where it's an *empty* Name-instance.
3243     if (!exportValues.includes(this.data.fieldValue)) {
3244       this.data.fieldValue = "Off";
3245     }
3246 
3247     this.data.exportValue = exportValues[1];
3248 
3249     const checkedAppearance = normalAppearance.get(this.data.exportValue);
3250     this.checkedAppearance =
3251       checkedAppearance instanceof BaseStream ? checkedAppearance : null;
3252     const uncheckedAppearance = normalAppearance.get("Off");
3253     this.uncheckedAppearance =
3254       uncheckedAppearance instanceof BaseStream ? uncheckedAppearance : null;
3255 
3256     if (this.checkedAppearance) {
3257       this._streams.push(this.checkedAppearance);
3258     } else {
3259       this._getDefaultCheckedAppearance(params, "check");
3260     }
3261     if (this.uncheckedAppearance) {
3262       this._streams.push(this.uncheckedAppearance);
3263     }
3264     this._fallbackFontDict = this.fallbackFontDict;
3265     if (this.data.defaultFieldValue === null) {
3266       this.data.defaultFieldValue = "Off";
3267     }
3268   }
3269 
3270   _processRadioButton(params) {
3271     this.data.buttonValue = null;
3272 
3273     // The parent field's `V` entry holds a `Name` object with the appearance
3274     // state of whichever child field is currently in the "on" state.
3275     const fieldParent = params.dict.get("Parent");
3276     if (fieldParent instanceof Dict) {
3277       this.parent = params.dict.getRaw("Parent");
3278       const fieldParentValue = fieldParent.get("V");
3279       if (fieldParentValue instanceof Name) {
3280         this.data.fieldValue = this._decodeFormValue(fieldParentValue);
3281       }
3282     }
3283 
3284     // The button's value corresponds to its appearance state.
3285     const appearanceStates = params.dict.get("AP");
3286     if (!(appearanceStates instanceof Dict)) {
3287       return;
3288     }
3289     const normalAppearance = appearanceStates.get("N");
3290     if (!(normalAppearance instanceof Dict)) {
3291       return;
3292     }
3293     for (const key of normalAppearance.getKeys()) {
3294       if (key !== "Off") {
3295         this.data.buttonValue = this._decodeFormValue(key);
3296         break;
3297       }
3298     }
3299 
3300     const checkedAppearance = normalAppearance.get(this.data.buttonValue);
3301     this.checkedAppearance =
3302       checkedAppearance instanceof BaseStream ? checkedAppearance : null;
3303     const uncheckedAppearance = normalAppearance.get("Off");
3304     this.uncheckedAppearance =
3305       uncheckedAppearance instanceof BaseStream ? uncheckedAppearance : null;
3306 
3307     if (this.checkedAppearance) {
3308       this._streams.push(this.checkedAppearance);
3309     } else {
3310       this._getDefaultCheckedAppearance(params, "disc");
3311     }
3312     if (this.uncheckedAppearance) {
3313       this._streams.push(this.uncheckedAppearance);
3314     }
3315     this._fallbackFontDict = this.fallbackFontDict;
3316     if (this.data.defaultFieldValue === null) {
3317       this.data.defaultFieldValue = "Off";
3318     }
3319   }
3320 
3321   _processPushButton(params) {
3322     const { dict, annotationGlobals } = params;
3323 
3324     if (!dict.has("A") && !dict.has("AA") && !this.data.alternativeText) {
3325       warn("Push buttons without action dictionaries are not supported");
3326       return;
3327     }
3328 
3329     this.data.isTooltipOnly = !dict.has("A") && !dict.has("AA");
3330 
3331     Catalog.parseDestDictionary({
3332       destDict: dict,
3333       resultObj: this.data,
3334       docBaseUrl: annotationGlobals.baseUrl,
3335       docAttachments: annotationGlobals.attachments,
3336     });
3337   }
3338 
3339   getFieldObject() {
3340     let type = "button";
3341     let exportValues;
3342     if (this.data.checkBox) {
3343       type = "checkbox";
3344       exportValues = this.data.exportValue;
3345     } else if (this.data.radioButton) {
3346       type = "radiobutton";
3347       exportValues = this.data.buttonValue;
3348     }
3349     return {
3350       id: this.data.id,
3351       value: this.data.fieldValue || "Off",
3352       defaultValue: this.data.defaultFieldValue,
3353       exportValues,
3354       editable: !this.data.readOnly,
3355       name: this.data.fieldName,
3356       rect: this.data.rect,
3357       hidden: this.data.hidden,
3358       actions: this.data.actions,
3359       page: this.data.pageIndex,
3360       strokeColor: this.data.borderColor,
3361       fillColor: this.data.backgroundColor,
3362       rotation: this.rotation,
3363       type,
3364     };
3365   }
3366 
3367   get fallbackFontDict() {
3368     const dict = new Dict();
3369     dict.set("BaseFont", Name.get("ZapfDingbats"));
3370     dict.set("Type", Name.get("FallbackType"));
3371     dict.set("Subtype", Name.get("FallbackType"));
3372     dict.set("Encoding", Name.get("ZapfDingbatsEncoding"));
3373 
3374     return shadow(this, "fallbackFontDict", dict);
3375   }
3376 }
3377 
3378 class ChoiceWidgetAnnotation extends WidgetAnnotation {
3379   constructor(params) {
3380     super(params);
3381 
3382     const { dict, xref } = params;
3383 
3384     this.indices = dict.getArray("I");
3385     this.hasIndices = Array.isArray(this.indices) && this.indices.length > 0;
3386 
3387     // Determine the options. The options array may consist of strings or
3388     // arrays. If the array consists of arrays, then the first element of
3389     // each array is the export value and the second element of each array is
3390     // the display value. If the array consists of strings, then these
3391     // represent both the export and display value. In this case, we convert
3392     // it to an array of arrays as well for convenience in the display layer.
3393     // Note that the specification does not state that the `Opt` field is
3394     // inheritable, but in practice PDF generators do make annotations
3395     // inherit the options from a parent annotation (issue 8094).
3396     this.data.options = [];
3397 
3398     const options = getInheritableProperty({ dict, key: "Opt" });
3399     if (Array.isArray(options)) {
3400       for (let i = 0, ii = options.length; i < ii; i++) {
3401         const option = xref.fetchIfRef(options[i]);
3402         const isOptionArray = Array.isArray(option);
3403 
3404         this.data.options[i] = {
3405           exportValue: this._decodeFormValue(
3406             isOptionArray ? xref.fetchIfRef(option[0]) : option
3407           ),
3408           displayValue: this._decodeFormValue(
3409             isOptionArray ? xref.fetchIfRef(option[1]) : option
3410           ),
3411         };
3412       }
3413     }
3414 
3415     if (!this.hasIndices) {
3416       // The field value can be `null` if no item is selected, a string if one
3417       // item is selected or an array of strings if multiple items are selected.
3418       // For consistency in the API and convenience in the display layer, we
3419       // always make the field value an array with zero, one or multiple items.
3420       if (typeof this.data.fieldValue === "string") {
3421         this.data.fieldValue = [this.data.fieldValue];
3422       } else if (!this.data.fieldValue) {
3423         this.data.fieldValue = [];
3424       }
3425     } else {
3426       // The specs say that we should have an indices array only with
3427       // multiselectable Choice and the "V" entry should have the
3428       // precedence, but Acrobat itself is using it whatever the
3429       // the "V" entry is (see bug 1770750).
3430       this.data.fieldValue = [];
3431       const ii = this.data.options.length;
3432       for (const i of this.indices) {
3433         if (Number.isInteger(i) && i >= 0 && i < ii) {
3434           this.data.fieldValue.push(this.data.options[i].exportValue);
3435         }
3436       }
3437     }
3438 
3439     // Process field flags for the display layer.
3440     this.data.combo = this.hasFieldFlag(AnnotationFieldFlag.COMBO);
3441     this.data.multiSelect = this.hasFieldFlag(AnnotationFieldFlag.MULTISELECT);
3442     this._hasText = true;
3443   }
3444 
3445   getFieldObject() {
3446     const type = this.data.combo ? "combobox" : "listbox";
3447     const value =
3448       this.data.fieldValue.length > 0 ? this.data.fieldValue[0] : null;
3449     return {
3450       id: this.data.id,
3451       value,
3452       defaultValue: this.data.defaultFieldValue,
3453       editable: !this.data.readOnly,
3454       name: this.data.fieldName,
3455       rect: this.data.rect,
3456       numItems: this.data.fieldValue.length,
3457       multipleSelection: this.data.multiSelect,
3458       hidden: this.data.hidden,
3459       actions: this.data.actions,
3460       items: this.data.options,
3461       page: this.data.pageIndex,
3462       strokeColor: this.data.borderColor,
3463       fillColor: this.data.backgroundColor,
3464       rotation: this.rotation,
3465       type,
3466     };
3467   }
3468 
3469   amendSavedDict(annotationStorage, dict) {
3470     if (!this.hasIndices) {
3471       return;
3472     }
3473     let values = annotationStorage?.get(this.data.id)?.value;
3474     if (!Array.isArray(values)) {
3475       values = [values];
3476     }
3477     const indices = [];
3478     const { options } = this.data;
3479     for (let i = 0, j = 0, ii = options.length; i < ii; i++) {
3480       if (options[i].exportValue === values[j]) {
3481         indices.push(i);
3482         j += 1;
3483       }
3484     }
3485     dict.set("I", indices);
3486   }
3487 
3488   async _getAppearance(evaluator, task, intent, annotationStorage) {
3489     if (this.data.combo) {
3490       return super._getAppearance(evaluator, task, intent, annotationStorage);
3491     }
3492 
3493     let exportedValue, rotation;
3494     const storageEntry = annotationStorage?.get(this.data.id);
3495     if (storageEntry) {
3496       rotation = storageEntry.rotation;
3497       exportedValue = storageEntry.value;
3498     }
3499 
3500     if (
3501       rotation === undefined &&
3502       exportedValue === undefined &&
3503       !this._needAppearances
3504     ) {
3505       // The annotation hasn't been rendered so use the appearance
3506       return null;
3507     }
3508 
3509     if (exportedValue === undefined) {
3510       exportedValue = this.data.fieldValue;
3511     } else if (!Array.isArray(exportedValue)) {
3512       exportedValue = [exportedValue];
3513     }
3514 
3515     const defaultPadding = 1;
3516     const defaultHPadding = 2;
3517     let totalHeight = this.data.rect[3] - this.data.rect[1];
3518     let totalWidth = this.data.rect[2] - this.data.rect[0];
3519 
3520     if (rotation === 90 || rotation === 270) {
3521       [totalWidth, totalHeight] = [totalHeight, totalWidth];
3522     }
3523 
3524     const lineCount = this.data.options.length;
3525     const valueIndices = [];
3526     for (let i = 0; i < lineCount; i++) {
3527       const { exportValue } = this.data.options[i];
3528       if (exportedValue.includes(exportValue)) {
3529         valueIndices.push(i);
3530       }
3531     }
3532 
3533     if (!this._defaultAppearance) {
3534       // The DA is required and must be a string.
3535       // If there is no font named Helvetica in the resource dictionary,
3536       // the evaluator will fall back to a default font.
3537       // Doing so prevents exceptions and allows saving/printing
3538       // the file as expected.
3539       this.data.defaultAppearanceData = parseDefaultAppearance(
3540         (this._defaultAppearance = "/Helvetica 0 Tf 0 g")
3541       );
3542     }
3543 
3544     const font = await WidgetAnnotation._getFontData(
3545       evaluator,
3546       task,
3547       this.data.defaultAppearanceData,
3548       this._fieldResources.mergedResources
3549     );
3550 
3551     let defaultAppearance;
3552     let { fontSize } = this.data.defaultAppearanceData;
3553     if (!fontSize) {
3554       const lineHeight = (totalHeight - defaultPadding) / lineCount;
3555       let lineWidth = -1;
3556       let value;
3557       for (const { displayValue } of this.data.options) {
3558         const width = this._getTextWidth(displayValue, font);
3559         if (width > lineWidth) {
3560           lineWidth = width;
3561           value = displayValue;
3562         }
3563       }
3564 
3565       [defaultAppearance, fontSize] = this._computeFontSize(
3566         lineHeight,
3567         totalWidth - 2 * defaultHPadding,
3568         value,
3569         font,
3570         -1
3571       );
3572     } else {
3573       defaultAppearance = this._defaultAppearance;
3574     }
3575 
3576     const lineHeight = fontSize * LINE_FACTOR;
3577     const vPadding = (lineHeight - fontSize) / 2;
3578     const numberOfVisibleLines = Math.floor(totalHeight / lineHeight);
3579 
3580     let firstIndex = 0;
3581     if (valueIndices.length > 0) {
3582       const minIndex = Math.min(...valueIndices);
3583       const maxIndex = Math.max(...valueIndices);
3584 
3585       firstIndex = Math.max(0, maxIndex - numberOfVisibleLines + 1);
3586       if (firstIndex > minIndex) {
3587         firstIndex = minIndex;
3588       }
3589     }
3590     const end = Math.min(firstIndex + numberOfVisibleLines + 1, lineCount);
3591 
3592     const buf = ["/Tx BMC q", `1 1 ${totalWidth} ${totalHeight} re W n`];
3593 
3594     if (valueIndices.length) {
3595       // This value has been copied/pasted from annotation-choice-widget.pdf.
3596       // It corresponds to rgb(153, 193, 218).
3597       buf.push("0.600006 0.756866 0.854904 rg");
3598 
3599       // Highlight the lines in filling a blue rectangle at the selected
3600       // positions.
3601       for (const index of valueIndices) {
3602         if (firstIndex <= index && index < end) {
3603           buf.push(
3604             `1 ${
3605               totalHeight - (index - firstIndex + 1) * lineHeight
3606             } ${totalWidth} ${lineHeight} re f`
3607           );
3608         }
3609       }
3610     }
3611     buf.push("BT", defaultAppearance, `1 0 0 1 0 ${totalHeight} Tm`);
3612 
3613     const prevInfo = { shift: 0 };
3614     for (let i = firstIndex; i < end; i++) {
3615       const { displayValue } = this.data.options[i];
3616       const vpadding = i === firstIndex ? vPadding : 0;
3617       buf.push(
3618         this._renderText(
3619           displayValue,
3620           font,
3621           fontSize,
3622           totalWidth,
3623           0,
3624           prevInfo,
3625           defaultHPadding,
3626           -lineHeight + vpadding
3627         )
3628       );
3629     }
3630 
3631     buf.push("ET Q EMC");
3632 
3633     return buf.join("\n");
3634   }
3635 }
3636 
3637 class SignatureWidgetAnnotation extends WidgetAnnotation {
3638   constructor(params) {
3639     super(params);
3640 
3641     // Unset the fieldValue since it's (most likely) a `Dict` which is
3642     // non-serializable and will thus cause errors when sending annotations
3643     // to the main-thread (issue 10347).
3644     this.data.fieldValue = null;
3645     this.data.hasOwnCanvas = this.data.noRotate;
3646     this.data.noHTML = !this.data.hasOwnCanvas;
3647   }
3648 
3649   getFieldObject() {
3650     return {
3651       id: this.data.id,
3652       value: null,
3653       page: this.data.pageIndex,
3654       type: "signature",
3655     };
3656   }
3657 }
3658 
3659 class TextAnnotation extends MarkupAnnotation {
3660   constructor(params) {
3661     const DEFAULT_ICON_SIZE = 22; // px
3662 
3663     super(params);
3664 
3665     // No rotation for Text (see 12.5.6.4).
3666     this.data.noRotate = true;
3667     this.data.hasOwnCanvas = this.data.noRotate;
3668     this.data.noHTML = false;
3669 
3670     const { dict } = params;
3671     this.data.annotationType = AnnotationType.TEXT;
3672 
3673     if (this.data.hasAppearance) {
3674       this.data.name = "NoIcon";
3675     } else {
3676       this.data.rect[1] = this.data.rect[3] - DEFAULT_ICON_SIZE;
3677       this.data.rect[2] = this.data.rect[0] + DEFAULT_ICON_SIZE;
3678       this.data.name = dict.has("Name") ? dict.get("Name").name : "Note";
3679     }
3680 
3681     if (dict.has("State")) {
3682       this.data.state = dict.get("State") || null;
3683       this.data.stateModel = dict.get("StateModel") || null;
3684     } else {
3685       this.data.state = null;
3686       this.data.stateModel = null;
3687     }
3688   }
3689 }
3690 
3691 class LinkAnnotation extends Annotation {
3692   constructor(params) {
3693     super(params);
3694 
3695     const { dict, annotationGlobals } = params;
3696     this.data.annotationType = AnnotationType.LINK;
3697 
3698     // A link is never rendered on the main canvas so we must render its HTML
3699     // version.
3700     this.data.noHTML = false;
3701 
3702     const quadPoints = getQuadPoints(dict, this.rectangle);
3703     if (quadPoints) {
3704       this.data.quadPoints = quadPoints;
3705     }
3706 
3707     // The color entry for a link annotation is the color of the border.
3708     this.data.borderColor ||= this.data.color;
3709 
3710     Catalog.parseDestDictionary({
3711       destDict: dict,
3712       resultObj: this.data,
3713       docBaseUrl: annotationGlobals.baseUrl,
3714       docAttachments: annotationGlobals.attachments,
3715     });
3716   }
3717 }
3718 
3719 class PopupAnnotation extends Annotation {
3720   constructor(params) {
3721     super(params);
3722 
3723     const { dict } = params;
3724     this.data.annotationType = AnnotationType.POPUP;
3725 
3726     // A pop-up is never rendered on the main canvas so we must render its HTML
3727     // version.
3728     this.data.noHTML = false;
3729 
3730     if (
3731       this.data.rect[0] === this.data.rect[2] ||
3732       this.data.rect[1] === this.data.rect[3]
3733     ) {
3734       this.data.rect = null;
3735     }
3736 
3737     let parentItem = dict.get("Parent");
3738     if (!parentItem) {
3739       warn("Popup annotation has a missing or invalid parent annotation.");
3740       return;
3741     }
3742     this.data.parentRect = lookupNormalRect(parentItem.getArray("Rect"), null);
3743 
3744     const rt = parentItem.get("RT");
3745     if (isName(rt, AnnotationReplyType.GROUP)) {
3746       // Subordinate annotations in a group should inherit
3747       // the group attributes from the primary annotation.
3748       parentItem = parentItem.get("IRT");
3749     }
3750 
3751     if (!parentItem.has("M")) {
3752       this.data.modificationDate = null;
3753     } else {
3754       this.setModificationDate(parentItem.get("M"));
3755       this.data.modificationDate = this.modificationDate;
3756     }
3757 
3758     if (!parentItem.has("C")) {
3759       // Fall back to the default background color.
3760       this.data.color = null;
3761     } else {
3762       this.setColor(parentItem.getArray("C"));
3763       this.data.color = this.color;
3764     }
3765 
3766     // If the Popup annotation is not viewable, but the parent annotation is,
3767     // that is most likely a bug. Fallback to inherit the flags from the parent
3768     // annotation (this is consistent with the behaviour in Adobe Reader).
3769     if (!this.viewable) {
3770       const parentFlags = parentItem.get("F");
3771       if (this._isViewable(parentFlags)) {
3772         this.setFlags(parentFlags);
3773       }
3774     }
3775 
3776     this.setTitle(parentItem.get("T"));
3777     this.data.titleObj = this._title;
3778 
3779     this.setContents(parentItem.get("Contents"));
3780     this.data.contentsObj = this._contents;
3781 
3782     if (parentItem.has("RC")) {
3783       this.data.richText = XFAFactory.getRichTextAsHtml(parentItem.get("RC"));
3784     }
3785 
3786     this.data.open = !!dict.get("Open");
3787   }
3788 }
3789 
3790 class FreeTextAnnotation extends MarkupAnnotation {
3791   constructor(params) {
3792     super(params);
3793 
3794     // It uses its own canvas in order to be hidden if edited.
3795     // But if it has the noHTML flag, it means that we don't want to be able
3796     // to modify it so we can just draw it on the main canvas.
3797     this.data.hasOwnCanvas = !this.data.noHTML;
3798     // We want to be able to add mouse listeners to the annotation.
3799     this.data.noHTML = false;
3800 
3801     const { evaluatorOptions, xref } = params;
3802     this.data.annotationType = AnnotationType.FREETEXT;
3803     this.setDefaultAppearance(params);
3804     this._hasAppearance = !!this.appearance;
3805 
3806     if (this._hasAppearance) {
3807       const { fontColor, fontSize } = parseAppearanceStream(
3808         this.appearance,
3809         evaluatorOptions,
3810         xref
3811       );
3812       this.data.defaultAppearanceData.fontColor = fontColor;
3813       this.data.defaultAppearanceData.fontSize = fontSize || 10;
3814     } else {
3815       this.data.defaultAppearanceData.fontSize ||= 10;
3816       const { fontColor, fontSize } = this.data.defaultAppearanceData;
3817       if (this._contents.str) {
3818         this.data.textContent = this._contents.str
3819           .split(/\r\n?|\n/)
3820           .map(line => line.trimEnd());
3821         const { coords, bbox, matrix } = FakeUnicodeFont.getFirstPositionInfo(
3822           this.rectangle,
3823           this.rotation,
3824           fontSize
3825         );
3826         this.data.textPosition = this._transformPoint(coords, bbox, matrix);
3827       }
3828       if (this._isOffscreenCanvasSupported) {
3829         const strokeAlpha = params.dict.get("CA");
3830         const fakeUnicodeFont = new FakeUnicodeFont(xref, "sans-serif");
3831         this.appearance = fakeUnicodeFont.createAppearance(
3832           this._contents.str,
3833           this.rectangle,
3834           this.rotation,
3835           fontSize,
3836           fontColor,
3837           strokeAlpha
3838         );
3839         this._streams.push(this.appearance);
3840       } else {
3841         warn(
3842           "FreeTextAnnotation: OffscreenCanvas is not supported, annotation may not render correctly."
3843         );
3844       }
3845     }
3846   }
3847 
3848   get hasTextContent() {
3849     return this._hasAppearance;
3850   }
3851 
3852   static createNewDict(annotation, xref, { apRef, ap }) {
3853     const { color, fontSize, rect, rotation, user, value } = annotation;
3854     const freetext = new Dict(xref);
3855     freetext.set("Type", Name.get("Annot"));
3856     freetext.set("Subtype", Name.get("FreeText"));
3857     freetext.set("CreationDate", `D:${getModificationDate()}`);
3858     freetext.set("Rect", rect);
3859     const da = `/Helv ${fontSize} Tf ${getPdfColor(color, /* isFill */ true)}`;
3860     freetext.set("DA", da);
3861     freetext.set(
3862       "Contents",
3863       isAscii(value)
3864         ? value
3865         : stringToUTF16String(value, /* bigEndian = */ true)
3866     );
3867     freetext.set("F", 4);
3868     freetext.set("Border", [0, 0, 0]);
3869     freetext.set("Rotate", rotation);
3870 
3871     if (user) {
3872       freetext.set(
3873         "T",
3874         isAscii(user) ? user : stringToUTF16String(user, /* bigEndian = */ true)
3875       );
3876     }
3877 
3878     if (apRef || ap) {
3879       const n = new Dict(xref);
3880       freetext.set("AP", n);
3881 
3882       if (apRef) {
3883         n.set("N", apRef);
3884       } else {
3885         n.set("N", ap);
3886       }
3887     }
3888 
3889     return freetext;
3890   }
3891 
3892   static async createNewAppearanceStream(annotation, xref, params) {
3893     const { baseFontRef, evaluator, task } = params;
3894     const { color, fontSize, rect, rotation, value } = annotation;
3895 
3896     const resources = new Dict(xref);
3897     const font = new Dict(xref);
3898 
3899     if (baseFontRef) {
3900       font.set("Helv", baseFontRef);
3901     } else {
3902       const baseFont = new Dict(xref);
3903       baseFont.set("BaseFont", Name.get("Helvetica"));
3904       baseFont.set("Type", Name.get("Font"));
3905       baseFont.set("Subtype", Name.get("Type1"));
3906       baseFont.set("Encoding", Name.get("WinAnsiEncoding"));
3907       font.set("Helv", baseFont);
3908     }
3909     resources.set("Font", font);
3910 
3911     const helv = await WidgetAnnotation._getFontData(
3912       evaluator,
3913       task,
3914       {
3915         fontName: "Helv",
3916         fontSize,
3917       },
3918       resources
3919     );
3920 
3921     const [x1, y1, x2, y2] = rect;
3922     let w = x2 - x1;
3923     let h = y2 - y1;
3924 
3925     if (rotation % 180 !== 0) {
3926       [w, h] = [h, w];
3927     }
3928 
3929     const lines = value.split("\n");
3930     const scale = fontSize / 1000;
3931     let totalWidth = -Infinity;
3932     const encodedLines = [];
3933     for (let line of lines) {
3934       const encoded = helv.encodeString(line);
3935       if (encoded.length > 1) {
3936         // The font doesn't contain all the chars.
3937         return null;
3938       }
3939       line = encoded.join("");
3940       encodedLines.push(line);
3941       let lineWidth = 0;
3942       const glyphs = helv.charsToGlyphs(line);
3943       for (const glyph of glyphs) {
3944         lineWidth += glyph.width * scale;
3945       }
3946       totalWidth = Math.max(totalWidth, lineWidth);
3947     }
3948 
3949     let hscale = 1;
3950     if (totalWidth > w) {
3951       hscale = w / totalWidth;
3952     }
3953     let vscale = 1;
3954     const lineHeight = LINE_FACTOR * fontSize;
3955     const lineAscent = (LINE_FACTOR - LINE_DESCENT_FACTOR) * fontSize;
3956     const totalHeight = lineHeight * lines.length;
3957     if (totalHeight > h) {
3958       vscale = h / totalHeight;
3959     }
3960     const fscale = Math.min(hscale, vscale);
3961     const newFontSize = fontSize * fscale;
3962     let firstPoint, clipBox, matrix;
3963     switch (rotation) {
3964       case 0:
3965         matrix = [1, 0, 0, 1];
3966         clipBox = [rect[0], rect[1], w, h];
3967         firstPoint = [rect[0], rect[3] - lineAscent];
3968         break;
3969       case 90:
3970         matrix = [0, 1, -1, 0];
3971         clipBox = [rect[1], -rect[2], w, h];
3972         firstPoint = [rect[1], -rect[0] - lineAscent];
3973         break;
3974       case 180:
3975         matrix = [-1, 0, 0, -1];
3976         clipBox = [-rect[2], -rect[3], w, h];
3977         firstPoint = [-rect[2], -rect[1] - lineAscent];
3978         break;
3979       case 270:
3980         matrix = [0, -1, 1, 0];
3981         clipBox = [-rect[3], rect[0], w, h];
3982         firstPoint = [-rect[3], rect[2] - lineAscent];
3983         break;
3984     }
3985 
3986     const buffer = [
3987       "q",
3988       `${matrix.join(" ")} 0 0 cm`,
3989       `${clipBox.join(" ")} re W n`,
3990       `BT`,
3991       `${getPdfColor(color, /* isFill */ true)}`,
3992       `0 Tc /Helv ${numberToString(newFontSize)} Tf`,
3993     ];
3994 
3995     buffer.push(
3996       `${firstPoint.join(" ")} Td (${escapeString(encodedLines[0])}) Tj`
3997     );
3998     const vShift = numberToString(lineHeight);
3999     for (let i = 1, ii = encodedLines.length; i < ii; i++) {
4000       const line = encodedLines[i];
4001       buffer.push(`0 -${vShift} Td (${escapeString(line)}) Tj`);
4002     }
4003     buffer.push("ET", "Q");
4004     const appearance = buffer.join("\n");
4005 
4006     const appearanceStreamDict = new Dict(xref);
4007     appearanceStreamDict.set("FormType", 1);
4008     appearanceStreamDict.set("Subtype", Name.get("Form"));
4009     appearanceStreamDict.set("Type", Name.get("XObject"));
4010     appearanceStreamDict.set("BBox", rect);
4011     appearanceStreamDict.set("Resources", resources);
4012     appearanceStreamDict.set("Matrix", [1, 0, 0, 1, -rect[0], -rect[1]]);
4013 
4014     const ap = new StringStream(appearance);
4015     ap.dict = appearanceStreamDict;
4016 
4017     return ap;
4018   }
4019 }
4020 
4021 class LineAnnotation extends MarkupAnnotation {
4022   constructor(params) {
4023     super(params);
4024 
4025     const { dict, xref } = params;
4026     this.data.annotationType = AnnotationType.LINE;
4027     this.data.hasOwnCanvas = this.data.noRotate;
4028     this.data.noHTML = false;
4029 
4030     const lineCoordinates = lookupRect(dict.getArray("L"), [0, 0, 0, 0]);
4031     this.data.lineCoordinates = Util.normalizeRect(lineCoordinates);
4032 
4033     if (typeof PDFJSDev === "undefined" || !PDFJSDev.test("MOZCENTRAL")) {
4034       this.setLineEndings(dict.getArray("LE"));
4035       this.data.lineEndings = this.lineEndings;
4036     }
4037 
4038     if (!this.appearance) {
4039       // The default stroke color is black.
4040       const strokeColor = this.color ? getPdfColorArray(this.color) : [0, 0, 0];
4041       const strokeAlpha = dict.get("CA");
4042 
4043       const interiorColor = getRgbColor(dict.getArray("IC"), null);
4044       // The default fill color is transparent. Setting the fill colour is
4045       // necessary if/when we want to add support for non-default line endings.
4046       const fillColor = interiorColor ? getPdfColorArray(interiorColor) : null;
4047       const fillAlpha = fillColor ? strokeAlpha : null;
4048 
4049       const borderWidth = this.borderStyle.width || 1,
4050         borderAdjust = 2 * borderWidth;
4051 
4052       // If the /Rect-entry is empty/wrong, create a fallback rectangle so that
4053       // we get similar rendering/highlighting behaviour as in Adobe Reader.
4054       const bbox = [
4055         this.data.lineCoordinates[0] - borderAdjust,
4056         this.data.lineCoordinates[1] - borderAdjust,
4057         this.data.lineCoordinates[2] + borderAdjust,
4058         this.data.lineCoordinates[3] + borderAdjust,
4059       ];
4060       if (!Util.intersect(this.rectangle, bbox)) {
4061         this.rectangle = bbox;
4062       }
4063 
4064       this._setDefaultAppearance({
4065         xref,
4066         extra: `${borderWidth} w`,
4067         strokeColor,
4068         fillColor,
4069         strokeAlpha,
4070         fillAlpha,
4071         pointsCallback: (buffer, points) => {
4072           buffer.push(
4073             `${lineCoordinates[0]} ${lineCoordinates[1]} m`,
4074             `${lineCoordinates[2]} ${lineCoordinates[3]} l`,
4075             "S"
4076           );
4077           return [
4078             points[0] - borderWidth,
4079             points[2] + borderWidth,
4080             points[7] - borderWidth,
4081             points[3] + borderWidth,
4082           ];
4083         },
4084       });
4085     }
4086   }
4087 }
4088 
4089 class SquareAnnotation extends MarkupAnnotation {
4090   constructor(params) {
4091     super(params);
4092 
4093     const { dict, xref } = params;
4094     this.data.annotationType = AnnotationType.SQUARE;
4095     this.data.hasOwnCanvas = this.data.noRotate;
4096     this.data.noHTML = false;
4097 
4098     if (!this.appearance) {
4099       // The default stroke color is black.
4100       const strokeColor = this.color ? getPdfColorArray(this.color) : [0, 0, 0];
4101       const strokeAlpha = dict.get("CA");
4102 
4103       const interiorColor = getRgbColor(dict.getArray("IC"), null);
4104       // The default fill color is transparent.
4105       const fillColor = interiorColor ? getPdfColorArray(interiorColor) : null;
4106       const fillAlpha = fillColor ? strokeAlpha : null;
4107 
4108       if (this.borderStyle.width === 0 && !fillColor) {
4109         // Prevent rendering a "hairline" border (fixes issue14164.pdf).
4110         return;
4111       }
4112 
4113       this._setDefaultAppearance({
4114         xref,
4115         extra: `${this.borderStyle.width} w`,
4116         strokeColor,
4117         fillColor,
4118         strokeAlpha,
4119         fillAlpha,
4120         pointsCallback: (buffer, points) => {
4121           const x = points[4] + this.borderStyle.width / 2;
4122           const y = points[5] + this.borderStyle.width / 2;
4123           const width = points[6] - points[4] - this.borderStyle.width;
4124           const height = points[3] - points[7] - this.borderStyle.width;
4125           buffer.push(`${x} ${y} ${width} ${height} re`);
4126           if (fillColor) {
4127             buffer.push("B");
4128           } else {
4129             buffer.push("S");
4130           }
4131           return [points[0], points[2], points[7], points[3]];
4132         },
4133       });
4134     }
4135   }
4136 }
4137 
4138 class CircleAnnotation extends MarkupAnnotation {
4139   constructor(params) {
4140     super(params);
4141 
4142     const { dict, xref } = params;
4143     this.data.annotationType = AnnotationType.CIRCLE;
4144 
4145     if (!this.appearance) {
4146       // The default stroke color is black.
4147       const strokeColor = this.color ? getPdfColorArray(this.color) : [0, 0, 0];
4148       const strokeAlpha = dict.get("CA");
4149 
4150       const interiorColor = getRgbColor(dict.getArray("IC"), null);
4151       // The default fill color is transparent.
4152       const fillColor = interiorColor ? getPdfColorArray(interiorColor) : null;
4153       const fillAlpha = fillColor ? strokeAlpha : null;
4154 
4155       if (this.borderStyle.width === 0 && !fillColor) {
4156         // Prevent rendering a "hairline" border (fixes issue14164.pdf).
4157         return;
4158       }
4159 
4160       // Circles are approximated by Bézier curves with four segments since
4161       // there is no circle primitive in the PDF specification. For the control
4162       // points distance, see https://stackoverflow.com/a/27863181.
4163       const controlPointsDistance = (4 / 3) * Math.tan(Math.PI / (2 * 4));
4164 
4165       this._setDefaultAppearance({
4166         xref,
4167         extra: `${this.borderStyle.width} w`,
4168         strokeColor,
4169         fillColor,
4170         strokeAlpha,
4171         fillAlpha,
4172         pointsCallback: (buffer, points) => {
4173           const x0 = points[0] + this.borderStyle.width / 2;
4174           const y0 = points[1] - this.borderStyle.width / 2;
4175           const x1 = points[6] - this.borderStyle.width / 2;
4176           const y1 = points[7] + this.borderStyle.width / 2;
4177           const xMid = x0 + (x1 - x0) / 2;
4178           const yMid = y0 + (y1 - y0) / 2;
4179           const xOffset = ((x1 - x0) / 2) * controlPointsDistance;
4180           const yOffset = ((y1 - y0) / 2) * controlPointsDistance;
4181 
4182           buffer.push(
4183             `${xMid} ${y1} m`,
4184             `${xMid + xOffset} ${y1} ${x1} ${yMid + yOffset} ${x1} ${yMid} c`,
4185             `${x1} ${yMid - yOffset} ${xMid + xOffset} ${y0} ${xMid} ${y0} c`,
4186             `${xMid - xOffset} ${y0} ${x0} ${yMid - yOffset} ${x0} ${yMid} c`,
4187             `${x0} ${yMid + yOffset} ${xMid - xOffset} ${y1} ${xMid} ${y1} c`,
4188             "h"
4189           );
4190           if (fillColor) {
4191             buffer.push("B");
4192           } else {
4193             buffer.push("S");
4194           }
4195           return [points[0], points[2], points[7], points[3]];
4196         },
4197       });
4198     }
4199   }
4200 }
4201 
4202 class PolylineAnnotation extends MarkupAnnotation {
4203   constructor(params) {
4204     super(params);
4205 
4206     const { dict, xref } = params;
4207     this.data.annotationType = AnnotationType.POLYLINE;
4208     this.data.hasOwnCanvas = this.data.noRotate;
4209     this.data.noHTML = false;
4210     this.data.vertices = null;
4211 
4212     if (
4213       (typeof PDFJSDev === "undefined" || !PDFJSDev.test("MOZCENTRAL")) &&
4214       !(this instanceof PolygonAnnotation)
4215     ) {
4216       // Only meaningful for polyline annotations.
4217       this.setLineEndings(dict.getArray("LE"));
4218       this.data.lineEndings = this.lineEndings;
4219     }
4220 
4221     // The vertices array is an array of numbers representing the alternating
4222     // horizontal and vertical coordinates, respectively, of each vertex.
4223     // Convert this to an array of objects with x and y coordinates.
4224     const rawVertices = dict.getArray("Vertices");
4225     if (!isNumberArray(rawVertices, null)) {
4226       return;
4227     }
4228     const vertices = (this.data.vertices = Float32Array.from(rawVertices));
4229 
4230     if (!this.appearance) {
4231       // The default stroke color is black.
4232       const strokeColor = this.color ? getPdfColorArray(this.color) : [0, 0, 0];
4233       const strokeAlpha = dict.get("CA");
4234 
4235       const borderWidth = this.borderStyle.width || 1,
4236         borderAdjust = 2 * borderWidth;
4237 
4238       // If the /Rect-entry is empty/wrong, create a fallback rectangle so that
4239       // we get similar rendering/highlighting behaviour as in Adobe Reader.
4240       const bbox = [Infinity, Infinity, -Infinity, -Infinity];
4241       for (let i = 0, ii = vertices.length; i < ii; i += 2) {
4242         bbox[0] = Math.min(bbox[0], vertices[i] - borderAdjust);
4243         bbox[1] = Math.min(bbox[1], vertices[i + 1] - borderAdjust);
4244         bbox[2] = Math.max(bbox[2], vertices[i] + borderAdjust);
4245         bbox[3] = Math.max(bbox[3], vertices[i + 1] + borderAdjust);
4246       }
4247       if (!Util.intersect(this.rectangle, bbox)) {
4248         this.rectangle = bbox;
4249       }
4250 
4251       this._setDefaultAppearance({
4252         xref,
4253         extra: `${borderWidth} w`,
4254         strokeColor,
4255         strokeAlpha,
4256         pointsCallback: (buffer, points) => {
4257           for (let i = 0, ii = vertices.length; i < ii; i += 2) {
4258             buffer.push(
4259               `${vertices[i]} ${vertices[i + 1]} ${i === 0 ? "m" : "l"}`
4260             );
4261           }
4262           buffer.push("S");
4263           return [points[0], points[2], points[7], points[3]];
4264         },
4265       });
4266     }
4267   }
4268 }
4269 
4270 class PolygonAnnotation extends PolylineAnnotation {
4271   constructor(params) {
4272     // Polygons are specific forms of polylines, so reuse their logic.
4273     super(params);
4274 
4275     this.data.annotationType = AnnotationType.POLYGON;
4276   }
4277 }
4278 
4279 class CaretAnnotation extends MarkupAnnotation {
4280   constructor(params) {
4281     super(params);
4282 
4283     this.data.annotationType = AnnotationType.CARET;
4284   }
4285 }
4286 
4287 class InkAnnotation extends MarkupAnnotation {
4288   constructor(params) {
4289     super(params);
4290 
4291     this.data.hasOwnCanvas = this.data.noRotate;
4292     this.data.noHTML = false;
4293 
4294     const { dict, xref } = params;
4295     this.data.annotationType = AnnotationType.INK;
4296     this.data.inkLists = [];
4297 
4298     const rawInkLists = dict.getArray("InkList");
4299     if (!Array.isArray(rawInkLists)) {
4300       return;
4301     }
4302     for (let i = 0, ii = rawInkLists.length; i < ii; ++i) {
4303       // The raw ink lists array contains arrays of numbers representing
4304       // the alternating horizontal and vertical coordinates, respectively,
4305       // of each vertex. Convert this to an array of objects with x and y
4306       // coordinates.
4307       if (!Array.isArray(rawInkLists[i])) {
4308         continue;
4309       }
4310       const inkList = new Float32Array(rawInkLists[i].length);
4311       this.data.inkLists.push(inkList);
4312       for (let j = 0, jj = rawInkLists[i].length; j < jj; j += 2) {
4313         const x = xref.fetchIfRef(rawInkLists[i][j]),
4314           y = xref.fetchIfRef(rawInkLists[i][j + 1]);
4315         if (typeof x === "number" && typeof y === "number") {
4316           inkList[j] = x;
4317           inkList[j + 1] = y;
4318         }
4319       }
4320     }
4321 
4322     if (!this.appearance) {
4323       // The default stroke color is black.
4324       const strokeColor = this.color ? getPdfColorArray(this.color) : [0, 0, 0];
4325       const strokeAlpha = dict.get("CA");
4326 
4327       const borderWidth = this.borderStyle.width || 1,
4328         borderAdjust = 2 * borderWidth;
4329 
4330       // If the /Rect-entry is empty/wrong, create a fallback rectangle so that
4331       // we get similar rendering/highlighting behaviour as in Adobe Reader.
4332       const bbox = [Infinity, Infinity, -Infinity, -Infinity];
4333       for (const inkList of this.data.inkLists) {
4334         for (let i = 0, ii = inkList.length; i < ii; i += 2) {
4335           bbox[0] = Math.min(bbox[0], inkList[i] - borderAdjust);
4336           bbox[1] = Math.min(bbox[1], inkList[i + 1] - borderAdjust);
4337           bbox[2] = Math.max(bbox[2], inkList[i] + borderAdjust);
4338           bbox[3] = Math.max(bbox[3], inkList[i + 1] + borderAdjust);
4339         }
4340       }
4341       if (!Util.intersect(this.rectangle, bbox)) {
4342         this.rectangle = bbox;
4343       }
4344 
4345       this._setDefaultAppearance({
4346         xref,
4347         extra: `${borderWidth} w`,
4348         strokeColor,
4349         strokeAlpha,
4350         pointsCallback: (buffer, points) => {
4351           // According to the specification, see "12.5.6.13 Ink Annotations":
4352           //   When drawn, the points shall be connected by straight lines or
4353           //   curves in an implementation-dependent way.
4354           // In order to simplify things, we utilize straight lines for now.
4355           for (const inkList of this.data.inkLists) {
4356             for (let i = 0, ii = inkList.length; i < ii; i += 2) {
4357               buffer.push(
4358                 `${inkList[i]} ${inkList[i + 1]} ${i === 0 ? "m" : "l"}`
4359               );
4360             }
4361             buffer.push("S");
4362           }
4363           return [points[0], points[2], points[7], points[3]];
4364         },
4365       });
4366     }
4367   }
4368 
4369   static createNewDict(annotation, xref, { apRef, ap }) {
4370     const { color, opacity, paths, outlines, rect, rotation, thickness } =
4371       annotation;
4372     const ink = new Dict(xref);
4373     ink.set("Type", Name.get("Annot"));
4374     ink.set("Subtype", Name.get("Ink"));
4375     ink.set("CreationDate", `D:${getModificationDate()}`);
4376     ink.set("Rect", rect);
4377     ink.set("InkList", outlines?.points || paths.map(p => p.points));
4378     ink.set("F", 4);
4379     ink.set("Rotate", rotation);
4380 
4381     if (outlines) {
4382       // Free highlight.
4383       // There's nothing about this in the spec, but it's used when highlighting
4384       // in Edge's viewer. Acrobat takes into account this parameter to indicate
4385       // that the Ink is used for highlighting.
4386       ink.set("IT", Name.get("InkHighlight"));
4387     }
4388 
4389     // Line thickness.
4390     const bs = new Dict(xref);
4391     ink.set("BS", bs);
4392     bs.set("W", thickness);
4393 
4394     // Color.
4395     ink.set(
4396       "C",
4397       Array.from(color, c => c / 255)
4398     );
4399 
4400     // Opacity.
4401     ink.set("CA", opacity);
4402 
4403     const n = new Dict(xref);
4404     ink.set("AP", n);
4405 
4406     if (apRef) {
4407       n.set("N", apRef);
4408     } else {
4409       n.set("N", ap);
4410     }
4411 
4412     return ink;
4413   }
4414 
4415   static async createNewAppearanceStream(annotation, xref, params) {
4416     if (annotation.outlines) {
4417       return this.createNewAppearanceStreamForHighlight(
4418         annotation,
4419         xref,
4420         params
4421       );
4422     }
4423     const { color, rect, paths, thickness, opacity } = annotation;
4424 
4425     const appearanceBuffer = [
4426       `${thickness} w 1 J 1 j`,
4427       `${getPdfColor(color, /* isFill */ false)}`,
4428     ];
4429 
4430     if (opacity !== 1) {
4431       appearanceBuffer.push("/R0 gs");
4432     }
4433 
4434     const buffer = [];
4435     for (const { bezier } of paths) {
4436       buffer.length = 0;
4437       buffer.push(
4438         `${numberToString(bezier[0])} ${numberToString(bezier[1])} m`
4439       );
4440       if (bezier.length === 2) {
4441         buffer.push(
4442           `${numberToString(bezier[0])} ${numberToString(bezier[1])} l S`
4443         );
4444       } else {
4445         for (let i = 2, ii = bezier.length; i < ii; i += 6) {
4446           const curve = bezier
4447             .slice(i, i + 6)
4448             .map(numberToString)
4449             .join(" ");
4450           buffer.push(`${curve} c`);
4451         }
4452         buffer.push("S");
4453       }
4454       appearanceBuffer.push(buffer.join("\n"));
4455     }
4456     const appearance = appearanceBuffer.join("\n");
4457 
4458     const appearanceStreamDict = new Dict(xref);
4459     appearanceStreamDict.set("FormType", 1);
4460     appearanceStreamDict.set("Subtype", Name.get("Form"));
4461     appearanceStreamDict.set("Type", Name.get("XObject"));
4462     appearanceStreamDict.set("BBox", rect);
4463     appearanceStreamDict.set("Length", appearance.length);
4464 
4465     if (opacity !== 1) {
4466       const resources = new Dict(xref);
4467       const extGState = new Dict(xref);
4468       const r0 = new Dict(xref);
4469       r0.set("CA", opacity);
4470       r0.set("Type", Name.get("ExtGState"));
4471       extGState.set("R0", r0);
4472       resources.set("ExtGState", extGState);
4473       appearanceStreamDict.set("Resources", resources);
4474     }
4475 
4476     const ap = new StringStream(appearance);
4477     ap.dict = appearanceStreamDict;
4478 
4479     return ap;
4480   }
4481 
4482   static async createNewAppearanceStreamForHighlight(annotation, xref, params) {
4483     const {
4484       color,
4485       rect,
4486       outlines: { outline },
4487       opacity,
4488     } = annotation;
4489     const appearanceBuffer = [
4490       `${getPdfColor(color, /* isFill */ true)}`,
4491       "/R0 gs",
4492     ];
4493 
4494     appearanceBuffer.push(
4495       `${numberToString(outline[4])} ${numberToString(outline[5])} m`
4496     );
4497     for (let i = 6, ii = outline.length; i < ii; i += 6) {
4498       if (isNaN(outline[i]) || outline[i] === null) {
4499         appearanceBuffer.push(
4500           `${numberToString(outline[i + 4])} ${numberToString(
4501             outline[i + 5]
4502           )} l`
4503         );
4504       } else {
4505         const curve = outline
4506           .slice(i, i + 6)
4507           .map(numberToString)
4508           .join(" ");
4509         appearanceBuffer.push(`${curve} c`);
4510       }
4511     }
4512     appearanceBuffer.push("h f");
4513     const appearance = appearanceBuffer.join("\n");
4514 
4515     const appearanceStreamDict = new Dict(xref);
4516     appearanceStreamDict.set("FormType", 1);
4517     appearanceStreamDict.set("Subtype", Name.get("Form"));
4518     appearanceStreamDict.set("Type", Name.get("XObject"));
4519     appearanceStreamDict.set("BBox", rect);
4520     appearanceStreamDict.set("Length", appearance.length);
4521 
4522     const resources = new Dict(xref);
4523     const extGState = new Dict(xref);
4524     resources.set("ExtGState", extGState);
4525     appearanceStreamDict.set("Resources", resources);
4526     const r0 = new Dict(xref);
4527     extGState.set("R0", r0);
4528     r0.set("BM", Name.get("Multiply"));
4529 
4530     if (opacity !== 1) {
4531       r0.set("ca", opacity);
4532       r0.set("Type", Name.get("ExtGState"));
4533     }
4534 
4535     const ap = new StringStream(appearance);
4536     ap.dict = appearanceStreamDict;
4537 
4538     return ap;
4539   }
4540 }
4541 
4542 class HighlightAnnotation extends MarkupAnnotation {
4543   constructor(params) {
4544     super(params);
4545 
4546     const { dict, xref } = params;
4547     this.data.annotationType = AnnotationType.HIGHLIGHT;
4548 
4549     const quadPoints = (this.data.quadPoints = getQuadPoints(dict, null));
4550     if (quadPoints) {
4551       const resources = this.appearance?.dict.get("Resources");
4552 
4553       if (!this.appearance || !resources?.has("ExtGState")) {
4554         if (this.appearance) {
4555           // Workaround for cases where there's no /ExtGState-entry directly
4556           // available, e.g. when the appearance stream contains a /XObject of
4557           // the /Form-type, since that causes the highlighting to completely
4558           // obscure the PDF content below it (fixes issue13242.pdf).
4559           warn("HighlightAnnotation - ignoring built-in appearance stream.");
4560         }
4561         // Default color is yellow in Acrobat Reader
4562         const fillColor = this.color ? getPdfColorArray(this.color) : [1, 1, 0];
4563         const fillAlpha = dict.get("CA");
4564 
4565         this._setDefaultAppearance({
4566           xref,
4567           fillColor,
4568           blendMode: "Multiply",
4569           fillAlpha,
4570           pointsCallback: (buffer, points) => {
4571             buffer.push(
4572               `${points[0]} ${points[1]} m`,
4573               `${points[2]} ${points[3]} l`,
4574               `${points[6]} ${points[7]} l`,
4575               `${points[4]} ${points[5]} l`,
4576               "f"
4577             );
4578             return [points[0], points[2], points[7], points[3]];
4579           },
4580         });
4581       }
4582     } else {
4583       this.data.popupRef = null;
4584     }
4585   }
4586 
4587   static createNewDict(annotation, xref, { apRef, ap }) {
4588     const { color, opacity, rect, rotation, user, quadPoints } = annotation;
4589     const highlight = new Dict(xref);
4590     highlight.set("Type", Name.get("Annot"));
4591     highlight.set("Subtype", Name.get("Highlight"));
4592     highlight.set("CreationDate", `D:${getModificationDate()}`);
4593     highlight.set("Rect", rect);
4594     highlight.set("F", 4);
4595     highlight.set("Border", [0, 0, 0]);
4596     highlight.set("Rotate", rotation);
4597     highlight.set("QuadPoints", quadPoints);
4598 
4599     // Color.
4600     highlight.set(
4601       "C",
4602       Array.from(color, c => c / 255)
4603     );
4604 
4605     // Opacity.
4606     highlight.set("CA", opacity);
4607 
4608     if (user) {
4609       highlight.set(
4610         "T",
4611         isAscii(user) ? user : stringToUTF16String(user, /* bigEndian = */ true)
4612       );
4613     }
4614 
4615     if (apRef || ap) {
4616       const n = new Dict(xref);
4617       highlight.set("AP", n);
4618       n.set("N", apRef || ap);
4619     }
4620 
4621     return highlight;
4622   }
4623 
4624   static async createNewAppearanceStream(annotation, xref, params) {
4625     const { color, rect, outlines, opacity } = annotation;
4626 
4627     const appearanceBuffer = [
4628       `${getPdfColor(color, /* isFill */ true)}`,
4629       "/R0 gs",
4630     ];
4631 
4632     const buffer = [];
4633     for (const outline of outlines) {
4634       buffer.length = 0;
4635       buffer.push(
4636         `${numberToString(outline[0])} ${numberToString(outline[1])} m`
4637       );
4638       for (let i = 2, ii = outline.length; i < ii; i += 2) {
4639         buffer.push(
4640           `${numberToString(outline[i])} ${numberToString(outline[i + 1])} l`
4641         );
4642       }
4643       buffer.push("h");
4644       appearanceBuffer.push(buffer.join("\n"));
4645     }
4646     appearanceBuffer.push("f*");
4647     const appearance = appearanceBuffer.join("\n");
4648 
4649     const appearanceStreamDict = new Dict(xref);
4650     appearanceStreamDict.set("FormType", 1);
4651     appearanceStreamDict.set("Subtype", Name.get("Form"));
4652     appearanceStreamDict.set("Type", Name.get("XObject"));
4653     appearanceStreamDict.set("BBox", rect);
4654     appearanceStreamDict.set("Length", appearance.length);
4655 
4656     const resources = new Dict(xref);
4657     const extGState = new Dict(xref);
4658     resources.set("ExtGState", extGState);
4659     appearanceStreamDict.set("Resources", resources);
4660     const r0 = new Dict(xref);
4661     extGState.set("R0", r0);
4662     r0.set("BM", Name.get("Multiply"));
4663 
4664     if (opacity !== 1) {
4665       r0.set("ca", opacity);
4666       r0.set("Type", Name.get("ExtGState"));
4667     }
4668 
4669     const ap = new StringStream(appearance);
4670     ap.dict = appearanceStreamDict;
4671 
4672     return ap;
4673   }
4674 }
4675 
4676 class UnderlineAnnotation extends MarkupAnnotation {
4677   constructor(params) {
4678     super(params);
4679 
4680     const { dict, xref } = params;
4681     this.data.annotationType = AnnotationType.UNDERLINE;
4682 
4683     const quadPoints = (this.data.quadPoints = getQuadPoints(dict, null));
4684     if (quadPoints) {
4685       if (!this.appearance) {
4686         // Default color is black
4687         const strokeColor = this.color
4688           ? getPdfColorArray(this.color)
4689           : [0, 0, 0];
4690         const strokeAlpha = dict.get("CA");
4691 
4692         // The values 0.571 and 1.3 below corresponds to what Acrobat is doing.
4693         this._setDefaultAppearance({
4694           xref,
4695           extra: "[] 0 d 0.571 w",
4696           strokeColor,
4697           strokeAlpha,
4698           pointsCallback: (buffer, points) => {
4699             buffer.push(
4700               `${points[4]} ${points[5] + 1.3} m`,
4701               `${points[6]} ${points[7] + 1.3} l`,
4702               "S"
4703             );
4704             return [points[0], points[2], points[7], points[3]];
4705           },
4706         });
4707       }
4708     } else {
4709       this.data.popupRef = null;
4710     }
4711   }
4712 }
4713 
4714 class SquigglyAnnotation extends MarkupAnnotation {
4715   constructor(params) {
4716     super(params);
4717 
4718     const { dict, xref } = params;
4719     this.data.annotationType = AnnotationType.SQUIGGLY;
4720 
4721     const quadPoints = (this.data.quadPoints = getQuadPoints(dict, null));
4722     if (quadPoints) {
4723       if (!this.appearance) {
4724         // Default color is black
4725         const strokeColor = this.color
4726           ? getPdfColorArray(this.color)
4727           : [0, 0, 0];
4728         const strokeAlpha = dict.get("CA");
4729 
4730         this._setDefaultAppearance({
4731           xref,
4732           extra: "[] 0 d 1 w",
4733           strokeColor,
4734           strokeAlpha,
4735           pointsCallback: (buffer, points) => {
4736             const dy = (points[1] - points[5]) / 6;
4737             let shift = dy;
4738             let x = points[4];
4739             const y = points[5];
4740             const xEnd = points[6];
4741             buffer.push(`${x} ${y + shift} m`);
4742             do {
4743               x += 2;
4744               shift = shift === 0 ? dy : 0;
4745               buffer.push(`${x} ${y + shift} l`);
4746             } while (x < xEnd);
4747             buffer.push("S");
4748             return [points[4], xEnd, y - 2 * dy, y + 2 * dy];
4749           },
4750         });
4751       }
4752     } else {
4753       this.data.popupRef = null;
4754     }
4755   }
4756 }
4757 
4758 class StrikeOutAnnotation extends MarkupAnnotation {
4759   constructor(params) {
4760     super(params);
4761 
4762     const { dict, xref } = params;
4763     this.data.annotationType = AnnotationType.STRIKEOUT;
4764 
4765     const quadPoints = (this.data.quadPoints = getQuadPoints(dict, null));
4766     if (quadPoints) {
4767       if (!this.appearance) {
4768         // Default color is black
4769         const strokeColor = this.color
4770           ? getPdfColorArray(this.color)
4771           : [0, 0, 0];
4772         const strokeAlpha = dict.get("CA");
4773 
4774         this._setDefaultAppearance({
4775           xref,
4776           extra: "[] 0 d 1 w",
4777           strokeColor,
4778           strokeAlpha,
4779           pointsCallback: (buffer, points) => {
4780             buffer.push(
4781               `${(points[0] + points[4]) / 2} ` +
4782                 `${(points[1] + points[5]) / 2} m`,
4783               `${(points[2] + points[6]) / 2} ` +
4784                 `${(points[3] + points[7]) / 2} l`,
4785               "S"
4786             );
4787             return [points[0], points[2], points[7], points[3]];
4788           },
4789         });
4790       }
4791     } else {
4792       this.data.popupRef = null;
4793     }
4794   }
4795 }
4796 
4797 class StampAnnotation extends MarkupAnnotation {
4798   constructor(params) {
4799     super(params);
4800 
4801     this.data.annotationType = AnnotationType.STAMP;
4802     this.data.hasOwnCanvas = this.data.noRotate;
4803     this.data.noHTML = false;
4804   }
4805 
4806   static async createImage(bitmap, xref) {
4807     // TODO: when printing, we could have a specific internal colorspace
4808     // (e.g. something like DeviceRGBA) in order avoid any conversion (i.e. no
4809     // jpeg, no rgba to rgb conversion, etc...)
4810 
4811     const { width, height } = bitmap;
4812     const canvas = new OffscreenCanvas(width, height);
4813     const ctx = canvas.getContext("2d", { alpha: true });
4814 
4815     // Draw the image and get the data in order to extract the transparency.
4816     ctx.drawImage(bitmap, 0, 0);
4817     const data = ctx.getImageData(0, 0, width, height).data;
4818     const buf32 = new Uint32Array(data.buffer);
4819     const hasAlpha = buf32.some(
4820       FeatureTest.isLittleEndian
4821         ? x => x >>> 24 !== 0xff
4822         : x => (x & 0xff) !== 0xff
4823     );
4824 
4825     if (hasAlpha) {
4826       // Redraw the image on a white background in order to remove the thin gray
4827       // line which can appear when exporting to jpeg.
4828       ctx.fillStyle = "white";
4829       ctx.fillRect(0, 0, width, height);
4830       ctx.drawImage(bitmap, 0, 0);
4831     }
4832 
4833     const jpegBufferPromise = canvas
4834       .convertToBlob({ type: "image/jpeg", quality: 1 })
4835       .then(blob => blob.arrayBuffer());
4836 
4837     const xobjectName = Name.get("XObject");
4838     const imageName = Name.get("Image");
4839     const image = new Dict(xref);
4840     image.set("Type", xobjectName);
4841     image.set("Subtype", imageName);
4842     image.set("BitsPerComponent", 8);
4843     image.set("ColorSpace", Name.get("DeviceRGB"));
4844     image.set("Filter", Name.get("DCTDecode"));
4845     image.set("BBox", [0, 0, width, height]);
4846     image.set("Width", width);
4847     image.set("Height", height);
4848 
4849     let smaskStream = null;
4850     if (hasAlpha) {
4851       const alphaBuffer = new Uint8Array(buf32.length);
4852       if (FeatureTest.isLittleEndian) {
4853         for (let i = 0, ii = buf32.length; i < ii; i++) {
4854           alphaBuffer[i] = buf32[i] >>> 24;
4855         }
4856       } else {
4857         for (let i = 0, ii = buf32.length; i < ii; i++) {
4858           alphaBuffer[i] = buf32[i] & 0xff;
4859         }
4860       }
4861 
4862       const smask = new Dict(xref);
4863       smask.set("Type", xobjectName);
4864       smask.set("Subtype", imageName);
4865       smask.set("BitsPerComponent", 8);
4866       smask.set("ColorSpace", Name.get("DeviceGray"));
4867       smask.set("Width", width);
4868       smask.set("Height", height);
4869 
4870       smaskStream = new Stream(alphaBuffer, 0, 0, smask);
4871     }
4872     const imageStream = new Stream(await jpegBufferPromise, 0, 0, image);
4873 
4874     return {
4875       imageStream,
4876       smaskStream,
4877       width,
4878       height,
4879     };
4880   }
4881 
4882   static createNewDict(annotation, xref, { apRef, ap }) {
4883     const { rect, rotation, user } = annotation;
4884     const stamp = new Dict(xref);
4885     stamp.set("Type", Name.get("Annot"));
4886     stamp.set("Subtype", Name.get("Stamp"));
4887     stamp.set("CreationDate", `D:${getModificationDate()}`);
4888     stamp.set("Rect", rect);
4889     stamp.set("F", 4);
4890     stamp.set("Border", [0, 0, 0]);
4891     stamp.set("Rotate", rotation);
4892 
4893     if (user) {
4894       stamp.set(
4895         "T",
4896         isAscii(user) ? user : stringToUTF16String(user, /* bigEndian = */ true)
4897       );
4898     }
4899 
4900     if (apRef || ap) {
4901       const n = new Dict(xref);
4902       stamp.set("AP", n);
4903 
4904       if (apRef) {
4905         n.set("N", apRef);
4906       } else {
4907         n.set("N", ap);
4908       }
4909     }
4910 
4911     return stamp;
4912   }
4913 
4914   static async createNewAppearanceStream(annotation, xref, params) {
4915     const { rotation } = annotation;
4916     const { imageRef, width, height } = params.image;
4917     const resources = new Dict(xref);
4918     const xobject = new Dict(xref);
4919     resources.set("XObject", xobject);
4920     xobject.set("Im0", imageRef);
4921     const appearance = `q ${width} 0 0 ${height} 0 0 cm /Im0 Do Q`;
4922 
4923     const appearanceStreamDict = new Dict(xref);
4924     appearanceStreamDict.set("FormType", 1);
4925     appearanceStreamDict.set("Subtype", Name.get("Form"));
4926     appearanceStreamDict.set("Type", Name.get("XObject"));
4927     appearanceStreamDict.set("BBox", [0, 0, width, height]);
4928     appearanceStreamDict.set("Resources", resources);
4929 
4930     if (rotation) {
4931       const matrix = getRotationMatrix(rotation, width, height);
4932       appearanceStreamDict.set("Matrix", matrix);
4933     }
4934 
4935     const ap = new StringStream(appearance);
4936     ap.dict = appearanceStreamDict;
4937 
4938     return ap;
4939   }
4940 }
4941 
4942 class FileAttachmentAnnotation extends MarkupAnnotation {
4943   constructor(params) {
4944     super(params);
4945 
4946     const { dict, xref } = params;
4947     const file = new FileSpec(dict.get("FS"), xref);
4948 
4949     this.data.annotationType = AnnotationType.FILEATTACHMENT;
4950     this.data.hasOwnCanvas = this.data.noRotate;
4951     this.data.noHTML = false;
4952     this.data.file = file.serializable;
4953 
4954     const name = dict.get("Name");
4955     this.data.name =
4956       name instanceof Name ? stringToPDFString(name.name) : "PushPin";
4957 
4958     const fillAlpha = dict.get("ca");
4959     this.data.fillAlpha =
4960       typeof fillAlpha === "number" && fillAlpha >= 0 && fillAlpha <= 1
4961         ? fillAlpha
4962         : null;
4963   }
4964 }
4965 
4966 export {
4967   Annotation,
4968   AnnotationBorderStyle,
4969   AnnotationFactory,
4970   getQuadPoints,
4971   MarkupAnnotation,
4972   PopupAnnotation,
4973   WidgetAnnotation,
4974 };
</code>

Test file:
<test_file>
File:
test/unit/annotation_spec.js
/* Copyright 2017 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import {
  Annotation,
  AnnotationBorderStyle,
  AnnotationFactory,
  getQuadPoints,
  MarkupAnnotation,
} from "../../src/core/annotation.js";
import {
  AnnotationBorderStyleType,
  AnnotationEditorType,
  AnnotationFieldFlag,
  AnnotationFlag,
  AnnotationType,
  OPS,
  RenderingIntentFlag,
  stringToBytes,
  stringToUTF8String,
} from "../../src/shared/util.js";
import {
  CMAP_URL,
  createIdFactory,
  STANDARD_FONT_DATA_URL,
  XRefMock,
} from "./test_utils.js";
import {
  DefaultCMapReaderFactory,
  DefaultStandardFontDataFactory,
} from "../../src/display/api.js";
import { Dict, Name, Ref, RefSetCache } from "../../src/core/primitives.js";
import { Lexer, Parser } from "../../src/core/parser.js";
import { FlateStream } from "../../src/core/flate_stream.js";
import { PartialEvaluator } from "../../src/core/evaluator.js";
import { StringStream } from "../../src/core/stream.js";
import { WorkerTask } from "../../src/core/worker.js";
</test_file>

Your task:
You are a software tester at pdf.js.
1. Examine the existing test file. You may reuse any imports, helpers or setup blocks it already has.
2. Write exactly one javascript test `it("...", async () => {...})` block.
3. Your test must fail on the code before the patch, and pass after, hence the test will verify that the patch resolves the issue.
4. The test must be self-contained and to-the-point.
5. If you need something new use only the provided imports (respect the paths exactly how they are given) by importing dynamically for compatibility with Node.js — no new dependencies. You can use the PDF file for testing as follows:
const { getDocument } = await import('../../src/display/api.js');
const { buildGetDocumentParams } = await import('./test_utils.js');
const loadingTask = getDocument(buildGetDocumentParams('bug1899804.pdf'))
6. Return only the javascript code for the new `it(...)` block (no comments or explanations).

Example structure:
it("should <describe behavior>", async () => {
  const { example } = await import("../../src/core/example.js");
  <initialize required variables>;
  <define expected variable>;
  <generate actual variables>;
  <compare expected with actual>;
});

