Before you begin:
- Keep going until the job is completely solved — don’t stop halfway.
- If you’re unsure about the behavior, reread the provided patch carefully; do not hallucinate.
- Plan your approach before writing code by reflecting on whether the test truly fails before and passes after.

Issue:
<issue>
Unable to Redo an added image/text/drawing to the PDF file using Keyboard shortcuts
</issue>

Patch:
<patch>
diff --git a/src/display/editor/tools.js b/src/display/editor/tools.js
--- a/src/display/editor/tools.js
+++ b/src/display/editor/tools.js
@@ -555,7 +555,15 @@ class AnnotationEditorUIManager {
         ],
         [["ctrl+z", "mac+meta+z"], AnnotationEditorUIManager.prototype.undo],
         [
-          ["ctrl+y", "ctrl+shift+Z", "mac+meta+shift+Z"],
+          // On mac, depending of the OS version, the event.key is either "z" or
+          // "Z" when the user presses "meta+shift+z".
+          [
+            "ctrl+y",
+            "ctrl+shift+z",
+            "mac+meta+shift+z",
+            "ctrl+shift+Z",
+            "mac+meta+shift+Z",
+          ],
           AnnotationEditorUIManager.prototype.redo,
         ],
         [


</patch>

Imports:
<imports>
Available Packages
Dev Dependencies:
- @babel/core: ^7.22.9
- @babel/plugin-transform-modules-commonjs: ^7.22.5
- @babel/preset-env: ^7.22.9
- @babel/runtime: ^7.22.6
- @javascript-obfuscator/escodegen: 2.3.0
- acorn: ^8.10.0
- autoprefixer: ^10.4.14
- babel-loader: ^9.1.3
- caniuse-lite: ^1.0.30001516
- canvas: ^2.11.2
- core-js: ^3.31.1
- cross-env: ^7.0.3
- es-module-shims: 1.4.7
- eslint: ^8.45.0
- eslint-config-prettier: ^8.8.0
- eslint-plugin-fetch-options: ^0.0.5
- eslint-plugin-html: ^7.1.0
- eslint-plugin-import: ^2.27.5
- eslint-plugin-json: ^3.1.0
- eslint-plugin-mozilla: ^3.1.0
- eslint-plugin-no-unsanitized: ^4.0.2
- eslint-plugin-prettier: ^5.0.0
- eslint-plugin-sort-exports: ^0.8.0
- eslint-plugin-unicorn: ^48.0.0
- globals: ^13.20.0
- gulp: ^4.0.2
- gulp-postcss: ^9.0.1
- gulp-rename: ^2.0.0
- gulp-replace: ^1.1.4
- gulp-zip: ^5.1.0
- jasmine: ^5.0.2
- jsdoc: ^4.0.2
- jstransformer-markdown-it: ^3.0.0
- merge-stream: ^2.0.0
- mkdirp: ^3.0.1
- needle: ^3.2.0
- path2d-polyfill: ^2.0.1
- pngjs: ^7.0.0
- postcss: ^8.4.26
- postcss-dir-pseudo-class: ^8.0.0
- prettier: ^3.0.0
- puppeteer: ^20.8.2
- rimraf: ^3.0.2
- streamqueue: ^1.1.2
- stylelint: 15.10.0
- stylelint-prettier: ^4.0.0
- terser: ^5.19.0
- through2: ^4.0.2
- ttest: ^4.0.0
- typescript: ^5.1.6
- typogr: ^0.6.8
- vinyl: ^3.0.0
- vinyl-fs: ^3.0.3
- webpack: ^5.88.1
- webpack-stream: ^7.0.0
- wintersmith: ^2.5.0
- yargs: ^17.7.2

Engines:
- node: >=18

Available Relative Imports:
- `../../src/core/annotation.js`: Annotation, AnnotationBorderStyle, AnnotationFactory, MarkupAnnotation, getQuadPoints
- `../../src/core/bidi.js`: bidi
- `../../src/core/cff_parser.js`: CFFCharset, CFFCompiler, CFFFDSelect, CFFParser, CFFStrings
- `../../src/core/cmap.js`: CMap, CMapFactory, IdentityCMap
- `../../src/core/colorspace.js`: ColorSpace
- `../../src/core/core_utils.js`: arrayBuffersToBytes, encodeToXmlString, escapePDFName, escapeString, getInheritableProperty, isAscii, isWhiteSpace, log2, numberToString, parseXFAPath, recoverJsURL, stringToUTF16HexString, stringToUTF16String, toRomanNumerals, validateCSSFont
- `../../src/core/crypto.js`: AES128Cipher, AES256Cipher, ARCFourCipher, CipherTransformFactory, PDF17, PDF20, calculateMD5, calculateSHA256, calculateSHA384, calculateSHA512
- `../../src/core/default_appearance.js`: createDefaultAppearance, parseAppearanceStream, parseDefaultAppearance
- `../../src/core/document.js`: PDFDocument, Page
- `../../src/core/encodings.js`: getEncoding
- `../../src/core/evaluator.js`: PartialEvaluator
- `../../src/core/font_substitutions.js`: getFontSubstitution
- `../../src/core/fonts_utils.js`: SEAC_ANALYSIS_ENABLED
- `../../src/core/function.js`: PDFFunctionFactory, PostScriptCompiler, PostScriptEvaluator
- `../../src/core/glyphlist.js`: getDingbatsGlyphsUnicode, getGlyphsUnicode
- `../../src/core/image_utils.js`: GlobalImageCache, LocalColorSpaceCache
- `../../src/core/jbig2.js`: Jbig2Image
- `../../src/core/jpg.js`: JpegImage
- `../../src/core/jpx.js`: JpxImage
- `../../src/core/metadata_parser.js`: MetadataParser
- `../../src/core/operator_list.js`: OperatorList
- `../../src/core/parser.js`: Lexer, Linearization, Parser
- `../../src/core/predictor_stream.js`: PredictorStream
- `../../src/core/primitives.js`: Cmd, Dict, EOF, Name, Ref, RefSet, RefSetCache, isCmd, isDict, isName, isRefsEqual
- `../../src/core/ps_parser.js`: PostScriptLexer, PostScriptParser
- `../../src/core/stream.js`: NullStream, Stream, StringStream
- `../../src/core/type1_parser.js`: Type1Parser
- `../../src/core/unicode.js`: getCharUnicodeCategory, getUnicodeForGlyph, getUnicodeRangeFor, mapSpecialUnicodeValues
- `../../src/core/worker.js`: WorkerMessageHandler, WorkerTask
- `../../src/core/writer.js`: incrementalUpdate, writeDict
- `../../src/core/xfa/bind.js`: Binder
- `../../src/core/xfa/data.js`: DataHandler
- `../../src/core/xfa/factory.js`: XFAFactory
- `../../src/core/xfa/formcalc_lexer.js`: Lexer, TOKEN, Token
- `../../src/core/xfa/formcalc_parser.js`: Errors, Parser
- `../../src/core/xfa/parser.js`: XFAParser
- `../../src/core/xfa/som.js`: searchNode
- `../../src/core/xfa/symbol_utils.js`: $dump, $getChildren, $getChildrenByClass, $getChildrenByName, $text, $uid
- `../../src/core/xml_parser.js`: SimpleXMLParser, XMLParserBase
- `../../src/display/annotation_layer.js`: AnnotationLayer
- `../../src/display/annotation_storage.js`: AnnotationStorage
- `../../src/display/api.js`: DefaultCMapReaderFactory, DefaultCanvasFactory, DefaultStandardFontDataFactory, LoopbackPort, PDFDataRangeTransport, PDFDocumentLoadingTask, PDFDocumentProxy, PDFPageProxy, PDFWorker, PDFWorkerUtil, RenderTask, SVGGraphics, build, getDocument, version
- `../../src/display/display_utils.js`: DOMCanvasFactory, DOMSVGFactory, PDFDateString, PageViewport, PixelsPerInch, RenderingCancelledException, StatTimer, getFilenameFromUrl, getPdfFilenameFromUrl, getXfaPageViewport, isDataScheme, isPdfFile, isValidFetchUrl, loadScript, setLayerDimensions
- `../../src/display/editor/annotation_editor_layer.js`: AnnotationEditorLayer
- `../../src/display/editor/tools.js`: AnnotationEditorUIManager, CommandManager
- `../../src/display/fetch_stream.js`: PDFFetchStream
- `../../src/display/metadata.js`: Metadata
- `../../src/display/network.js`: PDFNetworkStream
- `../../src/display/network_utils.js`: createResponseStatusError, extractFilenameFromHeader, validateRangeRequestCapabilities, validateResponseStatus
- `../../src/display/node_stream.js`: PDFNodeStream
- `../../src/display/svg.js`: SVGGraphics
- `../../src/display/text_layer.js`: TextLayerRenderTask, renderTextLayer, updateTextLayer
- `../../src/display/worker_options.js`: GlobalWorkerOptions
- `../../src/display/xfa_layer.js`: XfaLayer
- `../../src/shared/message_handler.js`: MessageHandler
- `../../src/shared/murmurhash3.js`: MurmurHash3_64
- `../../src/shared/util.js`: AbortException, AnnotationBorderStyleType, AnnotationEditorParamsType, AnnotationEditorType, AnnotationFieldFlag, AnnotationFlag, AnnotationMode, AnnotationType, CMapCompressionType, FeatureTest, FormatError, ImageKind, InvalidPDFException, MissingPDFException, OPS, PasswordException, PasswordResponses, PermissionFlag, PromiseCapability, RenderingIntentFlag, UnexpectedResponseException, UnknownErrorException, Util, VerbosityLevel, bytesToString, createValidAbsoluteUrl, getModificationDate, getVerbosityLevel, isArrayBuffer, isNodeJS, normalizeUnicode, objectSize, setVerbosityLevel, shadow, string32, stringToBytes, stringToPDFString, stringToUTF8String
- `../../web/annotation_layer_builder.js`: AnnotationLayerBuilder
- `../../web/download_manager.js`: DownloadManager
- `../../web/event_utils.js`: EventBus, WaitOnType, waitOnEventOrTimeout
- `../../web/genericl10n.js`: GenericL10n
- `../../web/l10n_utils.js`: NullL10n
- `../../web/pdf_find_controller.js`: FindState, PDFFindController
- `../../web/pdf_find_utils.js`: CharacterType, getCharacterType
- `../../web/pdf_history.js`: PDFHistory, isDestArraysEqual, isDestHashesEqual
- `../../web/pdf_link_service.js`: LinkTarget, PDFLinkService, SimpleLinkService
- `../../web/pdf_page_view.js`: PDFPageView
- `../../web/pdf_scripting_manager.component.js`: PDFScriptingManager
- `../../web/pdf_single_page_viewer.js`: PDFSinglePageViewer
- `../../web/pdf_viewer.js`: PDFPageViewBuffer, PDFViewer
- `../../web/struct_tree_layer_builder.js`: StructTreeLayerBuilder
- `../../web/text_layer_builder.js`: TextLayerBuilder
- `../../web/ui_utils.js`: AutoPrintRegExp, ProgressBar, RenderingStates, ScrollMode, SpreadMode, backtrackBeforeAllVisibleElements, binarySearchFirstItem, getPageSizeInches, getVisibleElements, isPortraitOrientation, isValidRotation, parseQueryString, removeNullCharacters
- `../../web/xfa_layer_builder.js`: XfaLayerBuilder
- `./test_utils.js`: CMAP_URL, DefaultFileReaderFactory, STANDARD_FONT_DATA_URL, TEST_PDFS_PATH, XRefMock, buildGetDocumentParams, createIdFactory
- `./testreporter.js`: TestReporter
</imports>

Code:
<code>
File:
src/display/editor/tools.js
1 /* Copyright 2022 Mozilla Foundation
2  *
3  * Licensed under the Apache License, Version 2.0 (the "License");
4  * you may not use this file except in compliance with the License.
5  * You may obtain a copy of the License at
6  *
7  *     http://www.apache.org/licenses/LICENSE-2.0
8  *
9  * Unless required by applicable law or agreed to in writing, software
10  * distributed under the License is distributed on an "AS IS" BASIS,
11  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
12  * See the License for the specific language governing permissions and
13  * limitations under the License.
14  */
15 
16 /** @typedef {import("./editor.js").AnnotationEditor} AnnotationEditor */
17 // eslint-disable-next-line max-len
18 /** @typedef {import("./annotation_editor_layer.js").AnnotationEditorLayer} AnnotationEditorLayer */
19 
20 import {
21   AnnotationEditorPrefix,
22   AnnotationEditorType,
23   FeatureTest,
24   getUuid,
25   shadow,
26   Util,
27   warn,
28 } from "../../shared/util.js";
29 import { getColorValues, getRGB, PixelsPerInch } from "../display_utils.js";
30 
31 function bindEvents(obj, element, names) {
32   for (const name of names) {
33     element.addEventListener(name, obj[name].bind(obj));
34   }
35 }
36 
37 /**
38  * Convert a number between 0 and 100 into an hex number between 0 and 255.
39  * @param {number} opacity
40  * @return {string}
41  */
42 function opacityToHex(opacity) {
43   return Math.round(Math.min(255, Math.max(1, 255 * opacity)))
44     .toString(16)
45     .padStart(2, "0");
46 }
47 
48 /**
49  * Class to create some unique ids for the different editors.
50  */
51 class IdManager {
52   #id = 0;
53 
54   /**
55    * Get a unique id.
56    * @returns {string}
57    */
58   getId() {
59     return `${AnnotationEditorPrefix}${this.#id++}`;
60   }
61 }
62 
63 /**
64  * Class to manage the images used by the editors.
65  * The main idea is to try to minimize the memory used by the images.
66  * The images are cached and reused when possible
67  * We use a refCounter to know when an image is not used anymore but we need to
68  * be able to restore an image after a remove+undo, so we keep a file reference
69  * or an url one.
70  */
71 class ImageManager {
72   #baseId = getUuid();
73 
74   #id = 0;
75 
76   #cache = null;
77 
78   async #get(key, rawData) {
79     this.#cache ||= new Map();
80     let data = this.#cache.get(key);
81     if (data === null) {
82       // We already tried to load the image but it failed.
83       return null;
84     }
85     if (data?.bitmap) {
86       data.refCounter += 1;
87       return data;
88     }
89     try {
90       data ||= {
91         bitmap: null,
92         id: `image_${this.#baseId}_${this.#id++}`,
93         refCounter: 0,
94         isSvg: false,
95       };
96       let image;
97       if (typeof rawData === "string") {
98         data.url = rawData;
99 
100         const response = await fetch(rawData);
101         if (!response.ok) {
102           throw new Error(response.statusText);
103         }
104         image = await response.blob();
105       } else {
106         image = data.file = rawData;
107       }
108 
109       if (image.type === "image/svg+xml") {
110         // Unfortunately, createImageBitmap doesn't work with SVG images.
111         // (see https://bugzilla.mozilla.org/1841972).
112         const fileReader = new FileReader();
113         const imageElement = new Image();
114         const imagePromise = new Promise((resolve, reject) => {
115           imageElement.onload = () => {
116             data.bitmap = imageElement;
117             data.isSvg = true;
118             resolve();
119           };
120           fileReader.onload = () => {
121             imageElement.src = data.svgUrl = fileReader.result;
122           };
123           imageElement.onerror = fileReader.onerror = reject;
124         });
125         fileReader.readAsDataURL(image);
126         await imagePromise;
127       } else {
128         data.bitmap = await createImageBitmap(image);
129       }
130       data.refCounter = 1;
131     } catch (e) {
132       console.error(e);
133       data = null;
134     }
135     this.#cache.set(key, data);
136     if (data) {
137       this.#cache.set(data.id, data);
138     }
139     return data;
140   }
141 
142   async getFromFile(file) {
143     const { lastModified, name, size, type } = file;
144     return this.#get(`${lastModified}_${name}_${size}_${type}`, file);
145   }
146 
147   async getFromUrl(url) {
148     return this.#get(url, url);
149   }
150 
151   async getFromId(id) {
152     this.#cache ||= new Map();
153     const data = this.#cache.get(id);
154     if (!data) {
155       return null;
156     }
157     if (data.bitmap) {
158       data.refCounter += 1;
159       return data;
160     }
161 
162     if (data.file) {
163       return this.getFromFile(data.file);
164     }
165     return this.getFromUrl(data.url);
166   }
167 
168   getSvgUrl(id) {
169     const data = this.#cache.get(id);
170     if (!data?.isSvg) {
171       return null;
172     }
173     return data.svgUrl;
174   }
175 
176   deleteId(id) {
177     this.#cache ||= new Map();
178     const data = this.#cache.get(id);
179     if (!data) {
180       return;
181     }
182     data.refCounter -= 1;
183     if (data.refCounter !== 0) {
184       return;
185     }
186     data.bitmap = null;
187   }
188 
189   // We can use the id only if it belongs this manager.
190   // We must take care of having the right manager because we can copy/paste
191   // some images from other documents, hence it'd be a pity to use an id from an
192   // other manager.
193   isValidId(id) {
194     return id.startsWith(`image_${this.#baseId}_`);
195   }
196 }
197 
198 /**
199  * Class to handle undo/redo.
200  * Commands are just saved in a buffer.
201  * If we hit some memory issues we could likely use a circular buffer.
202  * It has to be used as a singleton.
203  */
204 class CommandManager {
205   #commands = [];
206 
207   #locked = false;
208 
209   #maxSize;
210 
211   #position = -1;
212 
213   constructor(maxSize = 128) {
214     this.#maxSize = maxSize;
215   }
216 
217   /**
218    * @typedef {Object} addOptions
219    * @property {function} cmd
220    * @property {function} undo
221    * @property {boolean} mustExec
222    * @property {number} type
223    * @property {boolean} overwriteIfSameType
224    * @property {boolean} keepUndo
225    */
226 
227   /**
228    * Add a new couple of commands to be used in case of redo/undo.
229    * @param {addOptions} options
230    */
231   add({
232     cmd,
233     undo,
234     mustExec,
235     type = NaN,
236     overwriteIfSameType = false,
237     keepUndo = false,
238   }) {
239     if (mustExec) {
240       cmd();
241     }
242 
243     if (this.#locked) {
244       return;
245     }
246 
247     const save = { cmd, undo, type };
248     if (this.#position === -1) {
249       if (this.#commands.length > 0) {
250         // All the commands have been undone and then a new one is added
251         // hence we clear the queue.
252         this.#commands.length = 0;
253       }
254       this.#position = 0;
255       this.#commands.push(save);
256       return;
257     }
258 
259     if (overwriteIfSameType && this.#commands[this.#position].type === type) {
260       // For example when we change a color we don't want to
261       // be able to undo all the steps, hence we only want to
262       // keep the last undoable action in this sequence of actions.
263       if (keepUndo) {
264         save.undo = this.#commands[this.#position].undo;
265       }
266       this.#commands[this.#position] = save;
267       return;
268     }
269 
270     const next = this.#position + 1;
271     if (next === this.#maxSize) {
272       this.#commands.splice(0, 1);
273     } else {
274       this.#position = next;
275       if (next < this.#commands.length) {
276         this.#commands.splice(next);
277       }
278     }
279 
280     this.#commands.push(save);
281   }
282 
283   /**
284    * Undo the last command.
285    */
286   undo() {
287     if (this.#position === -1) {
288       // Nothing to undo.
289       return;
290     }
291 
292     // Avoid to insert something during the undo execution.
293     this.#locked = true;
294     this.#commands[this.#position].undo();
295     this.#locked = false;
296 
297     this.#position -= 1;
298   }
299 
300   /**
301    * Redo the last command.
302    */
303   redo() {
304     if (this.#position < this.#commands.length - 1) {
305       this.#position += 1;
306 
307       // Avoid to insert something during the redo execution.
308       this.#locked = true;
309       this.#commands[this.#position].cmd();
310       this.#locked = false;
311     }
312   }
313 
314   /**
315    * Check if there is something to undo.
316    * @returns {boolean}
317    */
318   hasSomethingToUndo() {
319     return this.#position !== -1;
320   }
321 
322   /**
323    * Check if there is something to redo.
324    * @returns {boolean}
325    */
326   hasSomethingToRedo() {
327     return this.#position < this.#commands.length - 1;
328   }
329 
330   destroy() {
331     this.#commands = null;
332   }
333 }
334 
335 /**
336  * Class to handle the different keyboards shortcuts we can have on mac or
337  * non-mac OSes.
338  */
339 class KeyboardManager {
340   /**
341    * Create a new keyboard manager class.
342    * @param {Array<Array>} callbacks - an array containing an array of shortcuts
343    * and a callback to call.
344    * A shortcut is a string like `ctrl+c` or `mac+ctrl+c` for mac OS.
345    */
346   constructor(callbacks) {
347     this.buffer = [];
348     this.callbacks = new Map();
349     this.allKeys = new Set();
350 
351     const { isMac } = FeatureTest.platform;
352     for (const [keys, callback, bubbles = false] of callbacks) {
353       for (const key of keys) {
354         const isMacKey = key.startsWith("mac+");
355         if (isMac && isMacKey) {
356           this.callbacks.set(key.slice(4), { callback, bubbles });
357           this.allKeys.add(key.split("+").at(-1));
358         } else if (!isMac && !isMacKey) {
359           this.callbacks.set(key, { callback, bubbles });
360           this.allKeys.add(key.split("+").at(-1));
361         }
362       }
363     }
364   }
365 
366   /**
367    * Serialize an event into a string in order to match a
368    * potential key for a callback.
369    * @param {KeyboardEvent} event
370    * @returns {string}
371    */
372   #serialize(event) {
373     if (event.altKey) {
374       this.buffer.push("alt");
375     }
376     if (event.ctrlKey) {
377       this.buffer.push("ctrl");
378     }
379     if (event.metaKey) {
380       this.buffer.push("meta");
381     }
382     if (event.shiftKey) {
383       this.buffer.push("shift");
384     }
385     this.buffer.push(event.key);
386     const str = this.buffer.join("+");
387     this.buffer.length = 0;
388 
389     return str;
390   }
391 
392   /**
393    * Execute a callback, if any, for a given keyboard event.
394    * The self is used as `this` in the callback.
395    * @param {Object} self.
396    * @param {KeyboardEvent} event
397    * @returns
398    */
399   exec(self, event) {
400     if (!this.allKeys.has(event.key)) {
401       return;
402     }
403     const info = this.callbacks.get(this.#serialize(event));
404     if (!info) {
405       return;
406     }
407     const { callback, bubbles } = info;
408     callback.bind(self)();
409 
410     // For example, ctrl+s in a FreeText must be handled by the viewer, hence
411     // the event must bubble.
412     if (!bubbles) {
413       event.stopPropagation();
414       event.preventDefault();
415     }
416   }
417 }
418 
419 class ColorManager {
420   static _colorsMapping = new Map([
421     ["CanvasText", [0, 0, 0]],
422     ["Canvas", [255, 255, 255]],
423   ]);
424 
425   get _colors() {
426     if (
427       typeof PDFJSDev !== "undefined" &&
428       PDFJSDev.test("LIB") &&
429       typeof document === "undefined"
430     ) {
431       return shadow(this, "_colors", ColorManager._colorsMapping);
432     }
433 
434     const colors = new Map([
435       ["CanvasText", null],
436       ["Canvas", null],
437     ]);
438     getColorValues(colors);
439     return shadow(this, "_colors", colors);
440   }
441 
442   /**
443    * In High Contrast Mode, the color on the screen is not always the
444    * real color used in the pdf.
445    * For example in some cases white can appear to be black but when saving
446    * we want to have white.
447    * @param {string} color
448    * @returns {Array<number>}
449    */
450   convert(color) {
451     const rgb = getRGB(color);
452     if (!window.matchMedia("(forced-colors: active)").matches) {
453       return rgb;
454     }
455 
456     for (const [name, RGB] of this._colors) {
457       if (RGB.every((x, i) => x === rgb[i])) {
458         return ColorManager._colorsMapping.get(name);
459       }
460     }
461     return rgb;
462   }
463 
464   /**
465    * An input element must have its color value as a hex string
466    * and not as color name.
467    * So this function converts a name into an hex string.
468    * @param {string} name
469    * @returns {string}
470    */
471   getHexCode(name) {
472     const rgb = this._colors.get(name);
473     if (!rgb) {
474       return name;
475     }
476     return Util.makeHexColor(...rgb);
477   }
478 }
479 
480 /**
481  * A pdf has several pages and each of them when it will rendered
482  * will have an AnnotationEditorLayer which will contain the some
483  * new Annotations associated to an editor in order to modify them.
484  *
485  * This class is used to manage all the different layers, editors and
486  * some action like copy/paste, undo/redo, ...
487  */
488 class AnnotationEditorUIManager {
489   #activeEditor = null;
490 
491   #allEditors = new Map();
492 
493   #allLayers = new Map();
494 
495   #annotationStorage = null;
496 
497   #commandManager = new CommandManager();
498 
499   #currentPageIndex = 0;
500 
501   #deletedAnnotationsElementIds = new Set();
502 
503   #editorTypes = null;
504 
505   #editorsToRescale = new Set();
506 
507   #eventBus = null;
508 
509   #filterFactory = null;
510 
511   #idManager = new IdManager();
512 
513   #isEnabled = false;
514 
515   #mode = AnnotationEditorType.NONE;
516 
517   #selectedEditors = new Set();
518 
519   #pageColors = null;
520 
521   #boundCopy = this.copy.bind(this);
522 
523   #boundCut = this.cut.bind(this);
524 
525   #boundPaste = this.paste.bind(this);
526 
527   #boundKeydown = this.keydown.bind(this);
528 
529   #boundOnEditingAction = this.onEditingAction.bind(this);
530 
531   #boundOnPageChanging = this.onPageChanging.bind(this);
532 
533   #boundOnScaleChanging = this.onScaleChanging.bind(this);
534 
535   #boundOnRotationChanging = this.onRotationChanging.bind(this);
536 
537   #previousStates = {
538     isEditing: false,
539     isEmpty: true,
540     hasSomethingToUndo: false,
541     hasSomethingToRedo: false,
542     hasSelectedEditor: false,
543   };
544 
545   #container = null;
546 
547   static get _keyboardManager() {
548     return shadow(
549       this,
550       "_keyboardManager",
551       new KeyboardManager([
552         [
553           ["ctrl+a", "mac+meta+a"],
554           AnnotationEditorUIManager.prototype.selectAll,
555         ],
556         [["ctrl+z", "mac+meta+z"], AnnotationEditorUIManager.prototype.undo],
557         [
558           ["ctrl+y", "ctrl+shift+Z", "mac+meta+shift+Z"],
559           AnnotationEditorUIManager.prototype.redo,
560         ],
561         [
562           [
563             "Backspace",
564             "alt+Backspace",
565             "ctrl+Backspace",
566             "shift+Backspace",
567             "mac+Backspace",
568             "mac+alt+Backspace",
569             "mac+ctrl+Backspace",
570             "Delete",
571             "ctrl+Delete",
572             "shift+Delete",
573           ],
574           AnnotationEditorUIManager.prototype.delete,
575         ],
576         [
577           ["Escape", "mac+Escape"],
578           AnnotationEditorUIManager.prototype.unselectAll,
579         ],
580       ])
581     );
582   }
583 
584   constructor(container, eventBus, pdfDocument, pageColors) {
585     this.#container = container;
586     this.#eventBus = eventBus;
587     this.#eventBus._on("editingaction", this.#boundOnEditingAction);
588     this.#eventBus._on("pagechanging", this.#boundOnPageChanging);
589     this.#eventBus._on("scalechanging", this.#boundOnScaleChanging);
590     this.#eventBus._on("rotationchanging", this.#boundOnRotationChanging);
591     this.#annotationStorage = pdfDocument.annotationStorage;
592     this.#filterFactory = pdfDocument.filterFactory;
593     this.#pageColors = pageColors;
594     this.viewParameters = {
595       realScale: PixelsPerInch.PDF_TO_CSS_UNITS,
596       rotation: 0,
597     };
598   }
599 
600   destroy() {
601     this.#removeKeyboardManager();
602     this.#eventBus._off("editingaction", this.#boundOnEditingAction);
603     this.#eventBus._off("pagechanging", this.#boundOnPageChanging);
604     this.#eventBus._off("scalechanging", this.#boundOnScaleChanging);
605     this.#eventBus._off("rotationchanging", this.#boundOnRotationChanging);
606     for (const layer of this.#allLayers.values()) {
607       layer.destroy();
608     }
609     this.#allLayers.clear();
610     this.#allEditors.clear();
611     this.#editorsToRescale.clear();
612     this.#activeEditor = null;
613     this.#selectedEditors.clear();
614     this.#commandManager.destroy();
615   }
616 
617   get hcmFilter() {
618     return shadow(
619       this,
620       "hcmFilter",
621       this.#pageColors
622         ? this.#filterFactory.addHCMFilter(
623             this.#pageColors.foreground,
624             this.#pageColors.background
625           )
626         : "none"
627     );
628   }
629 
630   onPageChanging({ pageNumber }) {
631     this.#currentPageIndex = pageNumber - 1;
632   }
633 
634   focusMainContainer() {
635     this.#container.focus();
636   }
637 
638   addShouldRescale(editor) {
639     this.#editorsToRescale.add(editor);
640   }
641 
642   removeShouldRescale(editor) {
643     this.#editorsToRescale.delete(editor);
644   }
645 
646   onScaleChanging({ scale }) {
647     this.commitOrRemove();
648     this.viewParameters.realScale = scale * PixelsPerInch.PDF_TO_CSS_UNITS;
649     for (const editor of this.#editorsToRescale) {
650       editor.onScaleChanging();
651     }
652   }
653 
654   onRotationChanging({ pagesRotation }) {
655     this.commitOrRemove();
656     this.viewParameters.rotation = pagesRotation;
657   }
658 
659   /**
660    * Add an editor in the annotation storage.
661    * @param {AnnotationEditor} editor
662    */
663   addToAnnotationStorage(editor) {
664     if (
665       !editor.isEmpty() &&
666       this.#annotationStorage &&
667       !this.#annotationStorage.has(editor.id)
668     ) {
669       this.#annotationStorage.setValue(editor.id, editor);
670     }
671   }
672 
673   #addKeyboardManager() {
674     // The keyboard events are caught at the container level in order to be able
675     // to execute some callbacks even if the current page doesn't have focus.
676     this.#container.addEventListener("keydown", this.#boundKeydown);
677   }
678 
679   #removeKeyboardManager() {
680     this.#container.removeEventListener("keydown", this.#boundKeydown);
681   }
682 
683   #addCopyPasteListeners() {
684     document.addEventListener("copy", this.#boundCopy);
685     document.addEventListener("cut", this.#boundCut);
686     document.addEventListener("paste", this.#boundPaste);
687   }
688 
689   #removeCopyPasteListeners() {
690     document.removeEventListener("copy", this.#boundCopy);
691     document.removeEventListener("cut", this.#boundCut);
692     document.removeEventListener("paste", this.#boundPaste);
693   }
694 
695   /**
696    * Copy callback.
697    * @param {ClipboardEvent} event
698    */
699   copy(event) {
700     event.preventDefault();
701 
702     if (this.#activeEditor) {
703       // An editor is being edited so just commit it.
704       this.#activeEditor.commitOrRemove();
705     }
706 
707     if (!this.hasSelection) {
708       return;
709     }
710 
711     const editors = [];
712     for (const editor of this.#selectedEditors) {
713       const serialized = editor.serialize(/* isForCopying = */ true);
714       if (serialized) {
715         editors.push(serialized);
716       }
717     }
718     if (editors.length === 0) {
719       return;
720     }
721 
722     event.clipboardData.setData("application/pdfjs", JSON.stringify(editors));
723   }
724 
725   /**
726    * Cut callback.
727    * @param {ClipboardEvent} event
728    */
729   cut(event) {
730     this.copy(event);
731     this.delete();
732   }
733 
734   /**
735    * Paste callback.
736    * @param {ClipboardEvent} event
737    */
738   paste(event) {
739     event.preventDefault();
740 
741     let data = event.clipboardData.getData("application/pdfjs");
742     if (!data) {
743       return;
744     }
745 
746     try {
747       data = JSON.parse(data);
748     } catch (ex) {
749       warn(`paste: "${ex.message}".`);
750       return;
751     }
752 
753     if (!Array.isArray(data)) {
754       return;
755     }
756 
757     this.unselectAll();
758     const layer = this.#allLayers.get(this.#currentPageIndex);
759 
760     try {
761       const newEditors = [];
762       for (const editor of data) {
763         const deserializedEditor = layer.deserialize(editor);
764         if (!deserializedEditor) {
765           return;
766         }
767         newEditors.push(deserializedEditor);
768       }
769 
770       const cmd = () => {
771         for (const editor of newEditors) {
772           this.#addEditorToLayer(editor);
773         }
774         this.#selectEditors(newEditors);
775       };
776       const undo = () => {
777         for (const editor of newEditors) {
778           editor.remove();
779         }
780       };
781       this.addCommands({ cmd, undo, mustExec: true });
782     } catch (ex) {
783       warn(`paste: "${ex.message}".`);
784     }
785   }
786 
787   /**
788    * Keydown callback.
789    * @param {KeyboardEvent} event
790    */
791   keydown(event) {
792     if (!this.getActive()?.shouldGetKeyboardEvents()) {
793       AnnotationEditorUIManager._keyboardManager.exec(this, event);
794     }
795   }
796 
797   /**
798    * Execute an action for a given name.
799    * For example, the user can click on the "Undo" entry in the context menu
800    * and it'll trigger the undo action.
801    * @param {Object} details
802    */
803   onEditingAction(details) {
804     if (["undo", "redo", "delete", "selectAll"].includes(details.name)) {
805       this[details.name]();
806     }
807   }
808 
809   /**
810    * Update the different possible states of this manager, e.g. is there
811    * something to undo, redo, ...
812    * @param {Object} details
813    */
814   #dispatchUpdateStates(details) {
815     const hasChanged = Object.entries(details).some(
816       ([key, value]) => this.#previousStates[key] !== value
817     );
818 
819     if (hasChanged) {
820       this.#eventBus.dispatch("annotationeditorstateschanged", {
821         source: this,
822         details: Object.assign(this.#previousStates, details),
823       });
824     }
825   }
826 
827   #dispatchUpdateUI(details) {
828     this.#eventBus.dispatch("annotationeditorparamschanged", {
829       source: this,
830       details,
831     });
832   }
833 
834   /**
835    * Set the editing state.
836    * It can be useful to temporarily disable it when the user is editing a
837    * FreeText annotation.
838    * @param {boolean} isEditing
839    */
840   setEditingState(isEditing) {
841     if (isEditing) {
842       this.#addKeyboardManager();
843       this.#addCopyPasteListeners();
844       this.#dispatchUpdateStates({
845         isEditing: this.#mode !== AnnotationEditorType.NONE,
846         isEmpty: this.#isEmpty(),
847         hasSomethingToUndo: this.#commandManager.hasSomethingToUndo(),
848         hasSomethingToRedo: this.#commandManager.hasSomethingToRedo(),
849         hasSelectedEditor: false,
850       });
851     } else {
852       this.#removeKeyboardManager();
853       this.#removeCopyPasteListeners();
854       this.#dispatchUpdateStates({
855         isEditing: false,
856       });
857     }
858   }
859 
860   registerEditorTypes(types) {
861     if (this.#editorTypes) {
862       return;
863     }
864     this.#editorTypes = types;
865     for (const editorType of this.#editorTypes) {
866       this.#dispatchUpdateUI(editorType.defaultPropertiesToUpdate);
867     }
868   }
869 
870   /**
871    * Get an id.
872    * @returns {string}
873    */
874   getId() {
875     return this.#idManager.getId();
876   }
877 
878   get currentLayer() {
879     return this.#allLayers.get(this.#currentPageIndex);
880   }
881 
882   get currentPageIndex() {
883     return this.#currentPageIndex;
884   }
885 
886   /**
887    * Add a new layer for a page which will contains the editors.
888    * @param {AnnotationEditorLayer} layer
889    */
890   addLayer(layer) {
891     this.#allLayers.set(layer.pageIndex, layer);
892     if (this.#isEnabled) {
893       layer.enable();
894     } else {
895       layer.disable();
896     }
897   }
898 
899   /**
900    * Remove a layer.
901    * @param {AnnotationEditorLayer} layer
902    */
903   removeLayer(layer) {
904     this.#allLayers.delete(layer.pageIndex);
905   }
906 
907   /**
908    * Change the editor mode (None, FreeText, Ink, ...)
909    * @param {number} mode
910    * @param {string|null} editId
911    */
912   updateMode(mode, editId = null) {
913     this.#mode = mode;
914     if (mode === AnnotationEditorType.NONE) {
915       this.setEditingState(false);
916       this.#disableAll();
917       return;
918     }
919     this.setEditingState(true);
920     this.#enableAll();
921     for (const layer of this.#allLayers.values()) {
922       layer.updateMode(mode);
923     }
924     if (!editId) {
925       return;
926     }
927     for (const editor of this.#allEditors.values()) {
928       if (editor.annotationElementId === editId) {
929         this.setSelected(editor);
930         editor.enterInEditMode();
931         break;
932       }
933     }
934   }
935 
936   /**
937    * Update the toolbar if it's required to reflect the tool currently used.
938    * @param {number} mode
939    * @returns {undefined}
940    */
941   updateToolbar(mode) {
942     if (mode === this.#mode) {
943       return;
944     }
945     this.#eventBus.dispatch("switchannotationeditormode", {
946       source: this,
947       mode,
948     });
949   }
950 
951   /**
952    * Update a parameter in the current editor or globally.
953    * @param {number} type
954    * @param {*} value
955    */
956   updateParams(type, value) {
957     if (!this.#editorTypes) {
958       return;
959     }
960 
961     for (const editor of this.#selectedEditors) {
962       editor.updateParams(type, value);
963     }
964 
965     for (const editorType of this.#editorTypes) {
966       editorType.updateDefaultParams(type, value);
967     }
968   }
969 
970   /**
971    * Enable all the layers.
972    */
973   #enableAll() {
974     if (!this.#isEnabled) {
975       this.#isEnabled = true;
976       for (const layer of this.#allLayers.values()) {
977         layer.enable();
978       }
979     }
980   }
981 
982   /**
983    * Disable all the layers.
984    */
985   #disableAll() {
986     this.unselectAll();
987     if (this.#isEnabled) {
988       this.#isEnabled = false;
989       for (const layer of this.#allLayers.values()) {
990         layer.disable();
991       }
992     }
993   }
994 
995   /**
996    * Get all the editors belonging to a give page.
997    * @param {number} pageIndex
998    * @returns {Array<AnnotationEditor>}
999    */
1000   getEditors(pageIndex) {
1001     const editors = [];
1002     for (const editor of this.#allEditors.values()) {
1003       if (editor.pageIndex === pageIndex) {
1004         editors.push(editor);
1005       }
1006     }
1007     return editors;
1008   }
1009 
1010   /**
1011    * Get an editor with the given id.
1012    * @param {string} id
1013    * @returns {AnnotationEditor}
1014    */
1015   getEditor(id) {
1016     return this.#allEditors.get(id);
1017   }
1018 
1019   /**
1020    * Add a new editor.
1021    * @param {AnnotationEditor} editor
1022    */
1023   addEditor(editor) {
1024     this.#allEditors.set(editor.id, editor);
1025   }
1026 
1027   /**
1028    * Remove an editor.
1029    * @param {AnnotationEditor} editor
1030    */
1031   removeEditor(editor) {
1032     this.#allEditors.delete(editor.id);
1033     this.unselect(editor);
1034     if (
1035       !editor.annotationElementId ||
1036       !this.#deletedAnnotationsElementIds.has(editor.annotationElementId)
1037     ) {
1038       this.#annotationStorage?.remove(editor.id);
1039     }
1040   }
1041 
1042   /**
1043    * The annotation element with the given id has been deleted.
1044    * @param {AnnotationEditor} editor
1045    */
1046   addDeletedAnnotationElement(editor) {
1047     this.#deletedAnnotationsElementIds.add(editor.annotationElementId);
1048     editor.deleted = true;
1049   }
1050 
1051   /**
1052    * Check if the annotation element with the given id has been deleted.
1053    * @param {string} annotationElementId
1054    * @returns {boolean}
1055    */
1056   isDeletedAnnotationElement(annotationElementId) {
1057     return this.#deletedAnnotationsElementIds.has(annotationElementId);
1058   }
1059 
1060   /**
1061    * The annotation element with the given id have been restored.
1062    * @param {AnnotationEditor} editor
1063    */
1064   removeDeletedAnnotationElement(editor) {
1065     this.#deletedAnnotationsElementIds.delete(editor.annotationElementId);
1066     editor.deleted = false;
1067   }
1068 
1069   /**
1070    * Add an editor to the layer it belongs to or add it to the global map.
1071    * @param {AnnotationEditor} editor
1072    */
1073   #addEditorToLayer(editor) {
1074     const layer = this.#allLayers.get(editor.pageIndex);
1075     if (layer) {
1076       layer.addOrRebuild(editor);
1077     } else {
1078       this.addEditor(editor);
1079     }
1080   }
1081 
1082   /**
1083    * Set the given editor as the active one.
1084    * @param {AnnotationEditor} editor
1085    */
1086   setActiveEditor(editor) {
1087     if (this.#activeEditor === editor) {
1088       return;
1089     }
1090 
1091     this.#activeEditor = editor;
1092     if (editor) {
1093       this.#dispatchUpdateUI(editor.propertiesToUpdate);
1094     }
1095   }
1096 
1097   /**
1098    * Add or remove an editor the current selection.
1099    * @param {AnnotationEditor} editor
1100    */
1101   toggleSelected(editor) {
1102     if (this.#selectedEditors.has(editor)) {
1103       this.#selectedEditors.delete(editor);
1104       editor.unselect();
1105       this.#dispatchUpdateStates({
1106         hasSelectedEditor: this.hasSelection,
1107       });
1108       return;
1109     }
1110     this.#selectedEditors.add(editor);
1111     editor.select();
1112     this.#dispatchUpdateUI(editor.propertiesToUpdate);
1113     this.#dispatchUpdateStates({
1114       hasSelectedEditor: true,
1115     });
1116   }
1117 
1118   /**
1119    * Set the last selected editor.
1120    * @param {AnnotationEditor} editor
1121    */
1122   setSelected(editor) {
1123     for (const ed of this.#selectedEditors) {
1124       if (ed !== editor) {
1125         ed.unselect();
1126       }
1127     }
1128     this.#selectedEditors.clear();
1129 
1130     this.#selectedEditors.add(editor);
1131     editor.select();
1132     this.#dispatchUpdateUI(editor.propertiesToUpdate);
1133     this.#dispatchUpdateStates({
1134       hasSelectedEditor: true,
1135     });
1136   }
1137 
1138   /**
1139    * Check if the editor is selected.
1140    * @param {AnnotationEditor} editor
1141    */
1142   isSelected(editor) {
1143     return this.#selectedEditors.has(editor);
1144   }
1145 
1146   /**
1147    * Unselect an editor.
1148    * @param {AnnotationEditor} editor
1149    */
1150   unselect(editor) {
1151     editor.unselect();
1152     this.#selectedEditors.delete(editor);
1153     this.#dispatchUpdateStates({
1154       hasSelectedEditor: this.hasSelection,
1155     });
1156   }
1157 
1158   get hasSelection() {
1159     return this.#selectedEditors.size !== 0;
1160   }
1161 
1162   /**
1163    * Undo the last command.
1164    */
1165   undo() {
1166     this.#commandManager.undo();
1167     this.#dispatchUpdateStates({
1168       hasSomethingToUndo: this.#commandManager.hasSomethingToUndo(),
1169       hasSomethingToRedo: true,
1170       isEmpty: this.#isEmpty(),
1171     });
1172   }
1173 
1174   /**
1175    * Redo the last undoed command.
1176    */
1177   redo() {
1178     this.#commandManager.redo();
1179     this.#dispatchUpdateStates({
1180       hasSomethingToUndo: true,
1181       hasSomethingToRedo: this.#commandManager.hasSomethingToRedo(),
1182       isEmpty: this.#isEmpty(),
1183     });
1184   }
1185 
1186   /**
1187    * Add a command to execute (cmd) and another one to undo it.
1188    * @param {Object} params
1189    */
1190   addCommands(params) {
1191     this.#commandManager.add(params);
1192     this.#dispatchUpdateStates({
1193       hasSomethingToUndo: true,
1194       hasSomethingToRedo: false,
1195       isEmpty: this.#isEmpty(),
1196     });
1197   }
1198 
1199   #isEmpty() {
1200     if (this.#allEditors.size === 0) {
1201       return true;
1202     }
1203 
1204     if (this.#allEditors.size === 1) {
1205       for (const editor of this.#allEditors.values()) {
1206         return editor.isEmpty();
1207       }
1208     }
1209 
1210     return false;
1211   }
1212 
1213   /**
1214    * Delete the current editor or all.
1215    */
1216   delete() {
1217     this.commitOrRemove();
1218     if (!this.hasSelection) {
1219       return;
1220     }
1221 
1222     const editors = [...this.#selectedEditors];
1223     const cmd = () => {
1224       for (const editor of editors) {
1225         editor.remove();
1226       }
1227     };
1228     const undo = () => {
1229       for (const editor of editors) {
1230         this.#addEditorToLayer(editor);
1231       }
1232     };
1233 
1234     this.addCommands({ cmd, undo, mustExec: true });
1235   }
1236 
1237   commitOrRemove() {
1238     // An editor is being edited so just commit it.
1239     this.#activeEditor?.commitOrRemove();
1240   }
1241 
1242   /**
1243    * Select the editors.
1244    * @param {Array<AnnotationEditor>} editors
1245    */
1246   #selectEditors(editors) {
1247     this.#selectedEditors.clear();
1248     for (const editor of editors) {
1249       if (editor.isEmpty()) {
1250         continue;
1251       }
1252       this.#selectedEditors.add(editor);
1253       editor.select();
1254     }
1255     this.#dispatchUpdateStates({ hasSelectedEditor: true });
1256   }
1257 
1258   /**
1259    * Select all the editors.
1260    */
1261   selectAll() {
1262     for (const editor of this.#selectedEditors) {
1263       editor.commit();
1264     }
1265     this.#selectEditors(this.#allEditors.values());
1266   }
1267 
1268   /**
1269    * Unselect all the selected editors.
1270    */
1271   unselectAll() {
1272     if (this.#activeEditor) {
1273       // An editor is being edited so just commit it.
1274       this.#activeEditor.commitOrRemove();
1275       return;
1276     }
1277 
1278     if (this.#selectedEditors.size === 0) {
1279       return;
1280     }
1281     for (const editor of this.#selectedEditors) {
1282       editor.unselect();
1283     }
1284     this.#selectedEditors.clear();
1285     this.#dispatchUpdateStates({
1286       hasSelectedEditor: false,
1287     });
1288   }
1289 
1290   /**
1291    * Is the current editor the one passed as argument?
1292    * @param {AnnotationEditor} editor
1293    * @returns
1294    */
1295   isActive(editor) {
1296     return this.#activeEditor === editor;
1297   }
1298 
1299   /**
1300    * Get the current active editor.
1301    * @returns {AnnotationEditor|null}
1302    */
1303   getActive() {
1304     return this.#activeEditor;
1305   }
1306 
1307   /**
1308    * Get the current editor mode.
1309    * @returns {number}
1310    */
1311   getMode() {
1312     return this.#mode;
1313   }
1314 
1315   get imageManager() {
1316     return shadow(this, "imageManager", new ImageManager());
1317   }
1318 }
1319 
1320 export {
1321   AnnotationEditorUIManager,
1322   bindEvents,
1323   ColorManager,
1324   CommandManager,
1325   KeyboardManager,
1326   opacityToHex,
1327 };
</code>

Test file:
<test_file>
File:
test/unit/annotation_spec.js
/* Copyright 2017 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import {
  Annotation,
  AnnotationBorderStyle,
  AnnotationFactory,
  getQuadPoints,
  MarkupAnnotation,
} from "../../src/core/annotation.js";
import {
  AnnotationBorderStyleType,
  AnnotationEditorType,
  AnnotationFieldFlag,
  AnnotationFlag,
  AnnotationType,
  OPS,
  RenderingIntentFlag,
  stringToBytes,
  stringToUTF8String,
} from "../../src/shared/util.js";
import {
  CMAP_URL,
  createIdFactory,
  STANDARD_FONT_DATA_URL,
  XRefMock,
} from "./test_utils.js";
import {
  DefaultCMapReaderFactory,
  DefaultStandardFontDataFactory,
} from "../../src/display/api.js";
import { Dict, Name, Ref, RefSetCache } from "../../src/core/primitives.js";
import { Lexer, Parser } from "../../src/core/parser.js";
import { PartialEvaluator } from "../../src/core/evaluator.js";
import { StringStream } from "../../src/core/stream.js";
import { WorkerTask } from "../../src/core/worker.js";
</test_file>

Your task:
You are a software tester at pdf.js.
1. Examine the existing test file. You may reuse any imports, helpers or setup blocks it already has.
2. Write exactly one javascript test `it("...", async () => {...})` block.
3. Your test must fail on the code before the patch, and pass after, hence the test will verify that the patch resolves the issue.
4. The test must be self-contained and to-the-point.
5. If you need something new use only the provided imports (respect the paths exactly how they are given) by importing dynamically for compatibility with Node.js — no new dependencies. 
6. Return only the javascript code for the new `it(...)` block (no comments or explanations).

Example structure:
it("should <describe behavior>", async () => {
  const { example } = await import("../../src/core/example.js");
  <initialize required variables>;
  <define expected variable>;
  <generate actual variables>;
  <compare expected with actual>;
});

