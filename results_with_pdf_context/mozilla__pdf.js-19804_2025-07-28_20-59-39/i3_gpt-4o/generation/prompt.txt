Before you begin:
- Keep going until the job is completely solved — don’t stop halfway.
- If you’re unsure about the behavior, reread the provided patch carefully; do not hallucinate.
- Plan your approach before writing code by reflecting on whether the test truly fails before and passes after.

Issue:
<issue>
[Bug]: Character spacing wrong for embedded WinAnsiEncoding font
### Attach (recommended) or Link to PDF file

The attached file doesn't render correctly (overlapping characters). It's using a font with WinAnsiEncoding encoding

[PDFcustomFontTest.pdf](https://github.com/user-attachments/files/19700949/PDFcustomFontTest.pdf)

<img width="623" alt="Image" src="https://github.com/user-attachments/assets/1f09720d-223a-4904-bab6-f11b9614a2d6" />

### Web browser and its version

Firefox 137.0 64 bit Windows

### Operating system and its version

Windows 11

### PDF.js version

v5.1.91

### Is the bug present in the latest PDF.js version?

Yes

### Is a browser extension

No

### Steps to reproduce the problem

* load attached .PDF file into https://mozilla.github.io/pdf.js/web/viewer.html
* or Firefox 137.0 64 bit Windows


### What is the expected behavior?

* text spacing is correct
* renders the same as Acrobat & Chrome

<img width="623" alt="Image" src="https://github.com/user-attachments/assets/eca06089-45b3-4de1-97f9-bbc756389deb" />

### What went wrong?

* text is overlapping
* 

<img width="623" alt="Image" src="https://github.com/user-attachments/assets/b12b3253-d84e-471f-8229-51a937c9bda3" />

### Link to a viewer

_No response_

### Additional context

_No response_
</issue>

PDF File:
<pdf>
issue19802.pdf
</pdf>

Patch:
<patch>
diff --git a/src/core/fonts.js b/src/core/fonts.js
--- a/src/core/fonts.js
+++ b/src/core/fonts.js
@@ -1108,9 +1108,10 @@ class Font {
           // Repair the TrueType file. It is can be damaged in the point of
           // view of the sanitizer
           data = this.checkAndRepair(name, file, properties);
-          if (this.isOpenType) {
-            adjustWidths(properties);
 
+          adjustWidths(properties);
+
+          if (this.isOpenType) {
             type = "OpenType";
           }
           break;
@@ -2645,8 +2646,6 @@ class Font {
         cffFile = new Stream(tables["CFF "].data);
         cff = new CFFFont(cffFile, properties);
 
-        adjustWidths(properties);
-
         return this.convert(name, cff, properties);
       }


</patch>

Imports:
<imports>
Available Packages
Dev Dependencies:
- @babel/core: ^7.26.10
- @babel/preset-env: ^7.26.9
- @babel/runtime: ^7.27.0
- @fluent/bundle: ^0.19.0
- @fluent/dom: ^0.10.1
- @metalsmith/layouts: ^3.0.0
- @metalsmith/markdown: ^1.10.0
- @napi-rs/canvas: ^0.1.68
- @types/node: ^22.13.14
- autoprefixer: ^10.4.21
- babel-loader: ^10.0.0
- caniuse-lite: ^1.0.30001707
- core-js: ^3.41.0
- eslint: ^9.23.0
- eslint-plugin-import: ^2.31.0
- eslint-plugin-jasmine: ^4.2.2
- eslint-plugin-json: ^4.0.1
- eslint-plugin-no-unsanitized: ^4.1.2
- eslint-plugin-perfectionist: ^4.10.1
- eslint-plugin-prettier: ^5.2.5
- eslint-plugin-unicorn: ^58.0.0
- globals: ^16.0.0
- gulp: ^5.0.0
- gulp-cli: ^3.0.0
- gulp-postcss: ^10.0.0
- gulp-rename: ^2.0.0
- gulp-replace: ^1.1.4
- gulp-zip: ^6.1.0
- highlight.js: ^11.11.1
- jasmine: ^5.6.0
- jsdoc: ^4.0.4
- jstransformer-nunjucks: ^1.2.0
- metalsmith: ^2.6.3
- metalsmith-html-relative: ^2.0.6
- ordered-read-streams: ^2.0.0
- pngjs: ^7.0.0
- postcss: ^8.5.3
- postcss-dark-theme-class: ^1.3.0
- postcss-dir-pseudo-class: ^9.0.1
- postcss-discard-comments: ^7.0.3
- postcss-nesting: ^13.0.1
- prettier: ^3.5.3
- puppeteer: ^24.4.0
- stylelint: ^16.17.0
- stylelint-prettier: ^5.0.3
- svglint: ^3.1.0
- terser-webpack-plugin: ^5.3.14
- tsc-alias: ^1.8.13
- ttest: ^4.0.0
- typescript: ^5.8.2
- vinyl: ^3.0.0
- webpack: ^5.98.0
- webpack-stream: ^7.0.0
- yargs: ^17.7.2

Engines:
- node: >=20.16.0

Available Relative Imports:
- `../../src/core/annotation.js`: Annotation, AnnotationBorderStyle, AnnotationFactory, MarkupAnnotation, getQuadPoints
- `../../src/core/bidi.js`: bidi
- `../../src/core/calculate_md5.js`: calculateMD5
- `../../src/core/calculate_sha256.js`: calculateSHA256
- `../../src/core/calculate_sha_other.js`: calculateSHA384, calculateSHA512
- `../../src/core/cff_parser.js`: CFFCharset, CFFCompiler, CFFFDSelect, CFFParser, CFFStrings
- `../../src/core/cmap.js`: CMap, CMapFactory, IdentityCMap
- `../../src/core/colorspace.js`: ColorSpace
- `../../src/core/colorspace_utils.js`: ColorSpaceUtils
- `../../src/core/core_utils.js`: arrayBuffersToBytes, encodeToXmlString, escapePDFName, escapeString, getInheritableProperty, getSizeInBytes, isAscii, isWhiteSpace, log2, numberToString, parseXFAPath, recoverJsURL, stringToUTF16HexString, stringToUTF16String, toRomanNumerals, validateCSSFont
- `../../src/core/crypto.js`: AES128Cipher, AES256Cipher, ARCFourCipher, CipherTransformFactory, PDF17, PDF20
- `../../src/core/default_appearance.js`: createDefaultAppearance, parseAppearanceStream, parseDefaultAppearance
- `../../src/core/document.js`: PDFDocument, Page
- `../../src/core/encodings.js`: getEncoding
- `../../src/core/evaluator.js`: PartialEvaluator
- `../../src/core/flate_stream.js`: FlateStream
- `../../src/core/font_substitutions.js`: getFontSubstitution
- `../../src/core/fonts_utils.js`: SEAC_ANALYSIS_ENABLED
- `../../src/core/function.js`: PDFFunctionFactory, PostScriptCompiler, PostScriptEvaluator
- `../../src/core/glyphlist.js`: getDingbatsGlyphsUnicode, getGlyphsUnicode
- `../../src/core/image_utils.js`: GlobalColorSpaceCache, GlobalImageCache, LocalColorSpaceCache
- `../../src/core/jbig2.js`: Jbig2Error, Jbig2Image
- `../../src/core/jpg.js`: JpegError, JpegImage
- `../../src/core/jpx.js`: JpxError, JpxImage
- `../../src/core/metadata_parser.js`: MetadataParser
- `../../src/core/operator_list.js`: OperatorList
- `../../src/core/parser.js`: Lexer, Linearization, Parser
- `../../src/core/predictor_stream.js`: PredictorStream
- `../../src/core/primitives.js`: Cmd, Dict, EOF, Name, Ref, RefSet, RefSetCache, isCmd, isDict, isName, isRefsEqual
- `../../src/core/ps_parser.js`: PostScriptLexer, PostScriptParser
- `../../src/core/stream.js`: NullStream, Stream, StringStream
- `../../src/core/type1_parser.js`: Type1Parser
- `../../src/core/unicode.js`: getCharUnicodeCategory, getUnicodeForGlyph, getUnicodeRangeFor, mapSpecialUnicodeValues
- `../../src/core/worker.js`: WorkerMessageHandler, WorkerTask
- `../../src/core/writer.js`: incrementalUpdate, writeChanges, writeDict
- `../../src/core/xfa/bind.js`: Binder
- `../../src/core/xfa/data.js`: DataHandler
- `../../src/core/xfa/factory.js`: XFAFactory
- `../../src/core/xfa/formcalc_lexer.js`: Lexer, TOKEN, Token
- `../../src/core/xfa/formcalc_parser.js`: Errors, Parser
- `../../src/core/xfa/parser.js`: XFAParser
- `../../src/core/xfa/som.js`: searchNode
- `../../src/core/xfa/symbol_utils.js`: $dump, $getChildren, $getChildrenByClass, $getChildrenByName, $text, $uid
- `../../src/core/xml_parser.js`: SimpleXMLParser, XMLParserBase
- `../../src/display/annotation_layer.js`: AnnotationLayer
- `../../src/display/annotation_storage.js`: AnnotationStorage
- `../../src/display/api.js`: LoopbackPort, PDFDataRangeTransport, PDFDocumentLoadingTask, PDFDocumentProxy, PDFPageProxy, PDFWorker, RenderTask, build, getDocument, isValidExplicitDest, version
- `../../src/display/canvas_factory.js`: DOMCanvasFactory
- `../../src/display/cmap_reader_factory.js`: DOMCMapReaderFactory
- `../../src/display/display_utils.js`: OutputScale, PDFDateString, PageViewport, PixelsPerInch, RenderingCancelledException, StatTimer, SupportedImageMimeTypes, fetchData, getFilenameFromUrl, getPdfFilenameFromUrl, getXfaPageViewport, isDataScheme, isPdfFile, isValidFetchUrl, noContextMenu, setLayerDimensions, stopEvent
- `../../src/display/draw_layer.js`: DrawLayer
- `../../src/display/editor/annotation_editor_layer.js`: AnnotationEditorLayer
- `../../src/display/editor/color_picker.js`: ColorPicker
- `../../src/display/editor/drawers/signaturedraw.js`: SignatureExtractor
- `../../src/display/editor/tools.js`: AnnotationEditorUIManager, CommandManager
- `../../src/display/fetch_stream.js`: PDFFetchStream
- `../../src/display/metadata.js`: Metadata
- `../../src/display/network.js`: PDFNetworkStream
- `../../src/display/network_utils.js`: createHeaders, createResponseError, extractFilenameFromHeader, validateRangeRequestCapabilities, validateResponseStatus
- `../../src/display/node_stream.js`: PDFNodeStream
- `../../src/display/node_utils.js`: NodeCMapReaderFactory, NodeStandardFontDataFactory, fetchData
- `../../src/display/standard_fontdata_factory.js`: DOMStandardFontDataFactory
- `../../src/display/svg_factory.js`: DOMSVGFactory
- `../../src/display/text_layer.js`: TextLayer
- `../../src/display/touch_manager.js`: TouchManager
- `../../src/display/worker_options.js`: GlobalWorkerOptions
- `../../src/display/xfa_layer.js`: XfaLayer
- `../../src/shared/message_handler.js`: MessageHandler
- `../../src/shared/murmurhash3.js`: MurmurHash3_64
- `../../src/shared/util.js`: AbortException, AnnotationBorderStyleType, AnnotationEditorParamsType, AnnotationEditorType, AnnotationFieldFlag, AnnotationFlag, AnnotationMode, AnnotationType, BaseException, DrawOPS, FeatureTest, FormatError, ImageKind, InvalidPDFException, MathClamp, OPS, PasswordException, PasswordResponses, PermissionFlag, RenderingIntentFlag, ResponseException, UnknownErrorException, Util, VerbosityLevel, assert, bytesToString, createValidAbsoluteUrl, getModificationDate, getUuid, getVerbosityLevel, isNodeJS, normalizeUnicode, objectSize, setVerbosityLevel, shadow, string32, stringToBytes, stringToPDFString, stringToUTF8String, toBase64Util
- `../../web/annotation_layer_builder.js`: AnnotationLayerBuilder
- `../../web/app_options.js`: AppOptions, OptionKind
- `../../web/autolinker.js`: Autolinker
- `../../web/download_manager.js`: DownloadManager
- `../../web/event_utils.js`: EventBus, WaitOnType, waitOnEventOrTimeout
- `../../web/genericl10n.js`: GenericL10n
- `../../web/pdf_find_controller.js`: FindState, PDFFindController
- `../../web/pdf_find_utils.js`: CharacterType, getCharacterType
- `../../web/pdf_history.js`: PDFHistory, isDestArraysEqual, isDestHashesEqual
- `../../web/pdf_link_service.js`: LinkTarget, PDFLinkService, SimpleLinkService
- `../../web/pdf_page_view.js`: PDFPageView
- `../../web/pdf_scripting_manager.component.js`: PDFScriptingManager
- `../../web/pdf_single_page_viewer.js`: PDFSinglePageViewer
- `../../web/pdf_viewer.js`: PDFPageViewBuffer, PDFViewer
- `../../web/struct_tree_layer_builder.js`: StructTreeLayerBuilder
- `../../web/text_layer_builder.js`: TextLayerBuilder
- `../../web/ui_utils.js`: AutoPrintRegExp, ProgressBar, RenderingStates, ScrollMode, SpreadMode, backtrackBeforeAllVisibleElements, binarySearchFirstItem, calcRound, getPageSizeInches, getVisibleElements, isPortraitOrientation, isValidRotation, parseQueryString, removeNullCharacters
- `../../web/xfa_layer_builder.js`: XfaLayerBuilder
- `../reporter.js`: TestReporter
- `./common_pdfstream_tests.js`: testCrossOriginRedirects
- `./test_utils.js`: CMAP_URL, DefaultCMapReaderFactory, DefaultFileReaderFactory, DefaultStandardFontDataFactory, STANDARD_FONT_DATA_URL, TEST_PDFS_PATH, TestPdfsServer, XRefMock, buildGetDocumentParams, createIdFactory, getCrossOriginHostname
</imports>

Code:
<code>
File:
src/core/fonts.js
1 /* Copyright 2012 Mozilla Foundation
2  *
3  * Licensed under the Apache License, Version 2.0 (the "License");
4  * you may not use this file except in compliance with the License.
5  * You may obtain a copy of the License at
6  *
7  *     http://www.apache.org/licenses/LICENSE-2.0
8  *
9  * Unless required by applicable law or agreed to in writing, software
10  * distributed under the License is distributed on an "AS IS" BASIS,
11  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
12  * See the License for the specific language governing permissions and
13  * limitations under the License.
14  */
15 
16 import {
17   assert,
18   bytesToString,
19   FONT_IDENTITY_MATRIX,
20   FormatError,
21   info,
22   shadow,
23   string32,
24   warn,
25 } from "../shared/util.js";
26 import { CFFCompiler, CFFParser } from "./cff_parser.js";
27 import {
28   FontFlags,
29   getVerticalPresentationForm,
30   MacStandardGlyphOrdering,
31   normalizeFontName,
32   recoverGlyphName,
33   SEAC_ANALYSIS_ENABLED,
34 } from "./fonts_utils.js";
35 import {
36   getCharUnicodeCategory,
37   getUnicodeForGlyph,
38   getUnicodeRangeFor,
39   mapSpecialUnicodeValues,
40 } from "./unicode.js";
41 import { getDingbatsGlyphsUnicode, getGlyphsUnicode } from "./glyphlist.js";
42 import {
43   getEncoding,
44   MacRomanEncoding,
45   StandardEncoding,
46   SymbolSetEncoding,
47   WinAnsiEncoding,
48   ZapfDingbatsEncoding,
49 } from "./encodings.js";
50 import {
51   getGlyphMapForStandardFonts,
52   getNonStdFontMap,
53   getSerifFonts,
54   getStdFontMap,
55   getSupplementalGlyphMapForArialBlack,
56   getSupplementalGlyphMapForCalibri,
57 } from "./standard_fonts.js";
58 import { IdentityToUnicodeMap, ToUnicodeMap } from "./to_unicode_map.js";
59 import { CFFFont } from "./cff_font.js";
60 import { FontRendererFactory } from "./font_renderer.js";
61 import { getFontBasicMetrics } from "./metrics.js";
62 import { GlyfTable } from "./glyf.js";
63 import { IdentityCMap } from "./cmap.js";
64 import { OpenTypeFileBuilder } from "./opentype_file_builder.js";
65 import { readUint32 } from "./core_utils.js";
66 import { Stream } from "./stream.js";
67 import { Type1Font } from "./type1_font.js";
68 
69 // Unicode Private Use Areas:
70 const PRIVATE_USE_AREAS = [
71   [0xe000, 0xf8ff], // BMP (0)
72   [0x100000, 0x10fffd], // PUP (16)
73 ];
74 
75 // PDF Glyph Space Units are one Thousandth of a TextSpace Unit
76 // except for Type 3 fonts
77 const PDF_GLYPH_SPACE_UNITS = 1000;
78 
79 const EXPORT_DATA_PROPERTIES = [
80   "ascent",
81   "bbox",
82   "black",
83   "bold",
84   "charProcOperatorList",
85   "cssFontInfo",
86   "data",
87   "defaultVMetrics",
88   "defaultWidth",
89   "descent",
90   "disableFontFace",
91   "fallbackName",
92   "fontExtraProperties",
93   "fontMatrix",
94   "isInvalidPDFjsFont",
95   "isType3Font",
96   "italic",
97   "loadedName",
98   "mimetype",
99   "missingFile",
100   "name",
101   "remeasure",
102   "systemFontInfo",
103   "vertical",
104 ];
105 
106 const EXPORT_DATA_EXTRA_PROPERTIES = [
107   "cMap",
108   "composite",
109   "defaultEncoding",
110   "differences",
111   "isMonospace",
112   "isSerifFont",
113   "isSymbolicFont",
114   "seacMap",
115   "subtype",
116   "toFontChar",
117   "toUnicode",
118   "type",
119   "vmetrics",
120   "widths",
121 ];
122 
123 function adjustWidths(properties) {
124   if (!properties.fontMatrix) {
125     return;
126   }
127   if (properties.fontMatrix[0] === FONT_IDENTITY_MATRIX[0]) {
128     return;
129   }
130   // adjusting width to fontMatrix scale
131   const scale = 0.001 / properties.fontMatrix[0];
132   const glyphsWidths = properties.widths;
133   for (const glyph in glyphsWidths) {
134     glyphsWidths[glyph] *= scale;
135   }
136   properties.defaultWidth *= scale;
137 }
138 
139 function adjustTrueTypeToUnicode(properties, isSymbolicFont, nameRecords) {
140   if (properties.isInternalFont) {
141     return;
142   }
143   if (properties.hasIncludedToUnicodeMap) {
144     return; // The font dictionary has a `ToUnicode` entry.
145   }
146   if (properties.hasEncoding) {
147     return; // The font dictionary has an `Encoding` entry.
148   }
149   if (properties.toUnicode instanceof IdentityToUnicodeMap) {
150     return;
151   }
152   if (!isSymbolicFont) {
153     return; // A non-symbolic font should default to `StandardEncoding`.
154   }
155   if (nameRecords.length === 0) {
156     return;
157   }
158 
159   // Try to infer if the fallback encoding should really be `WinAnsiEncoding`.
160   if (properties.defaultEncoding === WinAnsiEncoding) {
161     return;
162   }
163   for (const r of nameRecords) {
164     if (!isWinNameRecord(r)) {
165       return; // Not Windows, hence `WinAnsiEncoding` wouldn't make sense.
166     }
167   }
168   const encoding = WinAnsiEncoding;
169 
170   const toUnicode = [],
171     glyphsUnicodeMap = getGlyphsUnicode();
172   for (const charCode in encoding) {
173     const glyphName = encoding[charCode];
174     if (glyphName === "") {
175       continue;
176     }
177     const unicode = glyphsUnicodeMap[glyphName];
178     if (unicode === undefined) {
179       continue;
180     }
181     toUnicode[charCode] = String.fromCharCode(unicode);
182   }
183   if (toUnicode.length > 0) {
184     properties.toUnicode.amend(toUnicode);
185   }
186 }
187 
188 function adjustType1ToUnicode(properties, builtInEncoding) {
189   if (properties.isInternalFont) {
190     return;
191   }
192   if (properties.hasIncludedToUnicodeMap) {
193     return; // The font dictionary has a `ToUnicode` entry.
194   }
195   if (builtInEncoding === properties.defaultEncoding) {
196     return; // No point in trying to adjust `toUnicode` if the encodings match.
197   }
198   if (properties.toUnicode instanceof IdentityToUnicodeMap) {
199     return;
200   }
201   const toUnicode = [],
202     glyphsUnicodeMap = getGlyphsUnicode();
203   for (const charCode in builtInEncoding) {
204     if (properties.hasEncoding) {
205       if (
206         properties.baseEncodingName ||
207         properties.differences[charCode] !== undefined
208       ) {
209         continue; // The font dictionary has an `Encoding`/`Differences` entry.
210       }
211     }
212     const glyphName = builtInEncoding[charCode];
213     const unicode = getUnicodeForGlyph(glyphName, glyphsUnicodeMap);
214     if (unicode !== -1) {
215       toUnicode[charCode] = String.fromCharCode(unicode);
216     }
217   }
218   if (toUnicode.length > 0) {
219     properties.toUnicode.amend(toUnicode);
220   }
221 }
222 
223 /**
224  * NOTE: This function should only be called at the *end* of font-parsing,
225  *       after e.g. `adjustType1ToUnicode` has run, to prevent any issues.
226  */
227 function amendFallbackToUnicode(properties) {
228   if (!properties.fallbackToUnicode) {
229     return;
230   }
231   if (properties.toUnicode instanceof IdentityToUnicodeMap) {
232     return;
233   }
234   const toUnicode = [];
235   for (const charCode in properties.fallbackToUnicode) {
236     if (properties.toUnicode.has(charCode)) {
237       continue; // The font dictionary has a `ToUnicode` entry.
238     }
239     toUnicode[charCode] = properties.fallbackToUnicode[charCode];
240   }
241   if (toUnicode.length > 0) {
242     properties.toUnicode.amend(toUnicode);
243   }
244 }
245 
246 class Glyph {
247   constructor(
248     originalCharCode,
249     fontChar,
250     unicode,
251     accent,
252     width,
253     vmetric,
254     operatorListId,
255     isSpace,
256     isInFont
257   ) {
258     this.originalCharCode = originalCharCode;
259     this.fontChar = fontChar;
260     this.unicode = unicode;
261     this.accent = accent;
262     this.width = width;
263     this.vmetric = vmetric;
264     this.operatorListId = operatorListId;
265     this.isSpace = isSpace;
266     this.isInFont = isInFont;
267   }
268 
269   /**
270    * This property, which is only used by `PartialEvaluator.getTextContent`,
271    * is purposely made non-serializable.
272    * @type {Object}
273    */
274   get category() {
275     return shadow(
276       this,
277       "category",
278       getCharUnicodeCategory(this.unicode),
279       /* nonSerializable = */ true
280     );
281   }
282 }
283 
284 function int16(b0, b1) {
285   return (b0 << 8) + b1;
286 }
287 
288 function writeSignedInt16(bytes, index, value) {
289   bytes[index + 1] = value;
290   bytes[index] = value >>> 8;
291 }
292 
293 function signedInt16(b0, b1) {
294   const value = (b0 << 8) + b1;
295   return value & (1 << 15) ? value - 0x10000 : value;
296 }
297 
298 function writeUint32(bytes, index, value) {
299   bytes[index + 3] = value & 0xff;
300   bytes[index + 2] = value >>> 8;
301   bytes[index + 1] = value >>> 16;
302   bytes[index] = value >>> 24;
303 }
304 
305 function int32(b0, b1, b2, b3) {
306   return (b0 << 24) + (b1 << 16) + (b2 << 8) + b3;
307 }
308 
309 function string16(value) {
310   if (typeof PDFJSDev === "undefined" || PDFJSDev.test("TESTING")) {
311     assert(
312       typeof value === "number" && Math.abs(value) < 2 ** 16,
313       `string16: Unexpected input "${value}".`
314     );
315   }
316   return String.fromCharCode((value >> 8) & 0xff, value & 0xff);
317 }
318 
319 function safeString16(value) {
320   if (typeof PDFJSDev === "undefined" || PDFJSDev.test("TESTING")) {
321     assert(
322       typeof value === "number" && !Number.isNaN(value),
323       `safeString16: Unexpected input "${value}".`
324     );
325   }
326   // clamp value to the 16-bit int range
327   if (value > 0x7fff) {
328     value = 0x7fff;
329   } else if (value < -0x8000) {
330     value = -0x8000;
331   }
332   return String.fromCharCode((value >> 8) & 0xff, value & 0xff);
333 }
334 
335 function isTrueTypeFile(file) {
336   const header = file.peekBytes(4);
337   return (
338     readUint32(header, 0) === 0x00010000 || bytesToString(header) === "true"
339   );
340 }
341 
342 function isTrueTypeCollectionFile(file) {
343   const header = file.peekBytes(4);
344   return bytesToString(header) === "ttcf";
345 }
346 
347 function isOpenTypeFile(file) {
348   const header = file.peekBytes(4);
349   return bytesToString(header) === "OTTO";
350 }
351 
352 function isType1File(file) {
353   const header = file.peekBytes(2);
354   // All Type1 font programs must begin with the comment '%!' (0x25 + 0x21).
355   if (header[0] === 0x25 && header[1] === 0x21) {
356     return true;
357   }
358   // ... obviously some fonts violate that part of the specification,
359   // please refer to the comment in |Type1Font| below (pfb file header).
360   if (header[0] === 0x80 && header[1] === 0x01) {
361     return true;
362   }
363   return false;
364 }
365 
366 /**
367  * Compared to other font formats, the header in CFF files is not constant
368  * but contains version numbers. To reduce the possibility of misclassifying
369  * font files as CFF, it's recommended to check for other font formats first.
370  */
371 function isCFFFile(file) {
372   const header = file.peekBytes(4);
373   if (
374     /* major version, [1, 255] */ header[0] >= 1 &&
375     /* minor version, [0, 255]; header[1] */
376     /* header size, [0, 255]; header[2] */
377     /* offset(0) size, [1, 4] */ header[3] >= 1 &&
378     header[3] <= 4
379   ) {
380     return true;
381   }
382   return false;
383 }
384 
385 function getFontFileType(file, { type, subtype, composite }) {
386   let fileType, fileSubtype;
387 
388   if (isTrueTypeFile(file) || isTrueTypeCollectionFile(file)) {
389     fileType = composite ? "CIDFontType2" : "TrueType";
390   } else if (isOpenTypeFile(file)) {
391     fileType = composite ? "CIDFontType2" : "OpenType";
392   } else if (isType1File(file)) {
393     if (composite) {
394       fileType = "CIDFontType0";
395     } else {
396       fileType = type === "MMType1" ? "MMType1" : "Type1";
397     }
398   } else if (isCFFFile(file)) {
399     if (composite) {
400       fileType = "CIDFontType0";
401       fileSubtype = "CIDFontType0C";
402     } else {
403       fileType = type === "MMType1" ? "MMType1" : "Type1";
404       fileSubtype = "Type1C";
405     }
406   } else {
407     warn("getFontFileType: Unable to detect correct font file Type/Subtype.");
408     fileType = type;
409     fileSubtype = subtype;
410   }
411 
412   return [fileType, fileSubtype];
413 }
414 
415 function applyStandardFontGlyphMap(map, glyphMap) {
416   for (const charCode in glyphMap) {
417     map[+charCode] = glyphMap[charCode];
418   }
419 }
420 
421 function buildToFontChar(encoding, glyphsUnicodeMap, differences) {
422   const toFontChar = [];
423   let unicode;
424   for (let i = 0, ii = encoding.length; i < ii; i++) {
425     unicode = getUnicodeForGlyph(encoding[i], glyphsUnicodeMap);
426     if (unicode !== -1) {
427       toFontChar[i] = unicode;
428     }
429   }
430   for (const charCode in differences) {
431     unicode = getUnicodeForGlyph(differences[charCode], glyphsUnicodeMap);
432     if (unicode !== -1) {
433       toFontChar[+charCode] = unicode;
434     }
435   }
436   return toFontChar;
437 }
438 
439 // Please refer to:
440 //  - https://developer.apple.com/fonts/TrueType-Reference-Manual/RM06/Chap6name.html
441 function isMacNameRecord(r) {
442   return r.platform === 1 && r.encoding === 0 && r.language === 0;
443 }
444 
445 // Please refer to:
446 //  - https://developer.apple.com/fonts/TrueType-Reference-Manual/RM06/Chap6name.html
447 //  - https://learn.microsoft.com/en-us/typography/opentype/spec/name#windows-language-ids
448 function isWinNameRecord(r) {
449   return r.platform === 3 && r.encoding === 1 && r.language === 0x409;
450 }
451 
452 function convertCidString(charCode, cid, shouldThrow = false) {
453   switch (cid.length) {
454     case 1:
455       return cid.charCodeAt(0);
456     case 2:
457       return (cid.charCodeAt(0) << 8) | cid.charCodeAt(1);
458   }
459   const msg = `Unsupported CID string (charCode ${charCode}): "${cid}".`;
460   if (shouldThrow) {
461     throw new FormatError(msg);
462   }
463   warn(msg);
464   return cid;
465 }
466 
467 /**
468  * Rebuilds the char code to glyph ID map by moving all char codes to the
469  * private use area. This is done to avoid issues with various problematic
470  * unicode areas where either a glyph won't be drawn or is deformed by a
471  * shaper.
472  * @returns {Object} Two properties:
473  * 'toFontChar' - maps original char codes(the value that will be read
474  * from commands such as show text) to the char codes that will be used in the
475  * font that we build
476  * 'charCodeToGlyphId' - maps the new font char codes to glyph ids
477  */
478 function adjustMapping(charCodeToGlyphId, hasGlyph, newGlyphZeroId, toUnicode) {
479   const newMap = Object.create(null);
480   const toUnicodeExtraMap = new Map();
481   const toFontChar = [];
482   const usedGlyphIds = new Set();
483   let privateUseAreaIndex = 0;
484   const privateUseOffetStart = PRIVATE_USE_AREAS[privateUseAreaIndex][0];
485   let nextAvailableFontCharCode = privateUseOffetStart;
486   let privateUseOffetEnd = PRIVATE_USE_AREAS[privateUseAreaIndex][1];
487   const isInPrivateArea = code =>
488     (PRIVATE_USE_AREAS[0][0] <= code && code <= PRIVATE_USE_AREAS[0][1]) ||
489     (PRIVATE_USE_AREAS[1][0] <= code && code <= PRIVATE_USE_AREAS[1][1]);
490   let LIGATURE_TO_UNICODE = null;
491 
492   for (const originalCharCode in charCodeToGlyphId) {
493     let glyphId = charCodeToGlyphId[originalCharCode];
494     // For missing glyphs don't create the mappings so the glyph isn't
495     // drawn.
496     if (!hasGlyph(glyphId)) {
497       continue;
498     }
499     if (nextAvailableFontCharCode > privateUseOffetEnd) {
500       privateUseAreaIndex++;
501       if (privateUseAreaIndex >= PRIVATE_USE_AREAS.length) {
502         warn("Ran out of space in font private use area.");
503         break;
504       }
505       nextAvailableFontCharCode = PRIVATE_USE_AREAS[privateUseAreaIndex][0];
506       privateUseOffetEnd = PRIVATE_USE_AREAS[privateUseAreaIndex][1];
507     }
508     const fontCharCode = nextAvailableFontCharCode++;
509     if (glyphId === 0) {
510       glyphId = newGlyphZeroId;
511     }
512 
513     // Fix for bug 1778484:
514     // The charcodes are moved into a private use area to fix some rendering
515     // issues (https://github.com/mozilla/pdf.js/pull/9340) but when printing
516     // to PDF the generated font will contain wrong chars. We can avoid that by
517     // adding the unicode to the cmap and the print backend will then map the
518     // glyph ids to the correct unicode.
519     let unicode = toUnicode.get(originalCharCode);
520     if (typeof unicode === "string") {
521       if (unicode.length === 1) {
522         unicode = unicode.codePointAt(0);
523       } else {
524         if (!LIGATURE_TO_UNICODE) {
525           LIGATURE_TO_UNICODE = new Map();
526           // The code range [0xfb00, 0xfb4f] contains some ligature characters
527           // but not all.
528           // See https://www.compart.com/en/unicode/block/U+FB00.
529           for (let i = 0xfb00; i <= 0xfb4f; i++) {
530             const normalized = String.fromCharCode(i).normalize("NFKD");
531             if (normalized.length > 1) {
532               LIGATURE_TO_UNICODE.set(normalized, i);
533             }
534           }
535         }
536         unicode = LIGATURE_TO_UNICODE.get(unicode) || unicode.codePointAt(0);
537       }
538     }
539     if (unicode && !isInPrivateArea(unicode) && !usedGlyphIds.has(glyphId)) {
540       toUnicodeExtraMap.set(unicode, glyphId);
541       usedGlyphIds.add(glyphId);
542     }
543 
544     newMap[fontCharCode] = glyphId;
545     toFontChar[originalCharCode] = fontCharCode;
546   }
547   return {
548     toFontChar,
549     charCodeToGlyphId: newMap,
550     toUnicodeExtraMap,
551     nextAvailableFontCharCode,
552   };
553 }
554 
555 function getRanges(glyphs, toUnicodeExtraMap, numGlyphs) {
556   // Array.sort() sorts by characters, not numerically, so convert to an
557   // array of characters.
558   const codes = [];
559   for (const charCode in glyphs) {
560     // Remove an invalid glyph ID mappings to make OTS happy.
561     if (glyphs[charCode] >= numGlyphs) {
562       continue;
563     }
564     codes.push({ fontCharCode: charCode | 0, glyphId: glyphs[charCode] });
565   }
566   if (toUnicodeExtraMap) {
567     for (const [unicode, glyphId] of toUnicodeExtraMap) {
568       if (glyphId >= numGlyphs) {
569         continue;
570       }
571       codes.push({ fontCharCode: unicode, glyphId });
572     }
573   }
574   // Some fonts have zero glyphs and are used only for text selection, but
575   // there needs to be at least one to build a valid cmap table.
576   if (codes.length === 0) {
577     codes.push({ fontCharCode: 0, glyphId: 0 });
578   }
579   codes.sort((a, b) => a.fontCharCode - b.fontCharCode);
580 
581   // Split the sorted codes into ranges.
582   const ranges = [];
583   const length = codes.length;
584   for (let n = 0; n < length; ) {
585     const start = codes[n].fontCharCode;
586     const codeIndices = [codes[n].glyphId];
587     ++n;
588     let end = start;
589     while (n < length && end + 1 === codes[n].fontCharCode) {
590       codeIndices.push(codes[n].glyphId);
591       ++end;
592       ++n;
593       if (end === 0xffff) {
594         break;
595       }
596     }
597     ranges.push([start, end, codeIndices]);
598   }
599 
600   return ranges;
601 }
602 
603 function createCmapTable(glyphs, toUnicodeExtraMap, numGlyphs) {
604   const ranges = getRanges(glyphs, toUnicodeExtraMap, numGlyphs);
605   const numTables = ranges.at(-1)[1] > 0xffff ? 2 : 1;
606   let cmap =
607     "\x00\x00" + // version
608     string16(numTables) + // numTables
609     "\x00\x03" + // platformID
610     "\x00\x01" + // encodingID
611     string32(4 + numTables * 8); // start of the table record
612 
613   let i, ii, j, jj;
614   for (i = ranges.length - 1; i >= 0; --i) {
615     if (ranges[i][0] <= 0xffff) {
616       break;
617     }
618   }
619   const bmpLength = i + 1;
620 
621   if (ranges[i][0] < 0xffff && ranges[i][1] === 0xffff) {
622     ranges[i][1] = 0xfffe;
623   }
624   const trailingRangesCount = ranges[i][1] < 0xffff ? 1 : 0;
625   const segCount = bmpLength + trailingRangesCount;
626   const searchParams = OpenTypeFileBuilder.getSearchParams(segCount, 2);
627 
628   // Fill up the 4 parallel arrays describing the segments.
629   let startCount = "";
630   let endCount = "";
631   let idDeltas = "";
632   let idRangeOffsets = "";
633   let glyphsIds = "";
634   let bias = 0;
635 
636   let range, start, end, codes;
637   for (i = 0, ii = bmpLength; i < ii; i++) {
638     range = ranges[i];
639     start = range[0];
640     end = range[1];
641     startCount += string16(start);
642     endCount += string16(end);
643     codes = range[2];
644     let contiguous = true;
645     for (j = 1, jj = codes.length; j < jj; ++j) {
646       if (codes[j] !== codes[j - 1] + 1) {
647         contiguous = false;
648         break;
649       }
650     }
651     if (!contiguous) {
652       const offset = (segCount - i) * 2 + bias * 2;
653       bias += end - start + 1;
654 
655       idDeltas += string16(0);
656       idRangeOffsets += string16(offset);
657 
658       for (j = 0, jj = codes.length; j < jj; ++j) {
659         glyphsIds += string16(codes[j]);
660       }
661     } else {
662       const startCode = codes[0];
663 
664       idDeltas += string16((startCode - start) & 0xffff);
665       idRangeOffsets += string16(0);
666     }
667   }
668 
669   if (trailingRangesCount > 0) {
670     endCount += "\xFF\xFF";
671     startCount += "\xFF\xFF";
672     idDeltas += "\x00\x01";
673     idRangeOffsets += "\x00\x00";
674   }
675 
676   const format314 =
677     "\x00\x00" + // language
678     string16(2 * segCount) +
679     string16(searchParams.range) +
680     string16(searchParams.entry) +
681     string16(searchParams.rangeShift) +
682     endCount +
683     "\x00\x00" +
684     startCount +
685     idDeltas +
686     idRangeOffsets +
687     glyphsIds;
688 
689   let format31012 = "";
690   let header31012 = "";
691   if (numTables > 1) {
692     cmap +=
693       "\x00\x03" + // platformID
694       "\x00\x0A" + // encodingID
695       string32(4 + numTables * 8 + 4 + format314.length); // start of the table record
696     format31012 = "";
697     for (i = 0, ii = ranges.length; i < ii; i++) {
698       range = ranges[i];
699       start = range[0];
700       codes = range[2];
701       let code = codes[0];
702       for (j = 1, jj = codes.length; j < jj; ++j) {
703         if (codes[j] !== codes[j - 1] + 1) {
704           end = range[0] + j - 1;
705           format31012 +=
706             string32(start) + // startCharCode
707             string32(end) + // endCharCode
708             string32(code); // startGlyphID
709           start = end + 1;
710           code = codes[j];
711         }
712       }
713       format31012 +=
714         string32(start) + // startCharCode
715         string32(range[1]) + // endCharCode
716         string32(code); // startGlyphID
717     }
718     header31012 =
719       "\x00\x0C" + // format
720       "\x00\x00" + // reserved
721       string32(format31012.length + 16) + // length
722       "\x00\x00\x00\x00" + // language
723       string32(format31012.length / 12); // nGroups
724   }
725 
726   return (
727     cmap +
728     "\x00\x04" + // format
729     string16(format314.length + 4) + // length
730     format314 +
731     header31012 +
732     format31012
733   );
734 }
735 
736 function validateOS2Table(os2, file) {
737   file.pos = (file.start || 0) + os2.offset;
738   const version = file.getUint16();
739   // TODO verify all OS/2 tables fields, but currently we validate only those
740   // that give us issues
741   file.skip(60); // skipping type, misc sizes, panose, unicode ranges
742   const selection = file.getUint16();
743   if (version < 4 && selection & 0x0300) {
744     return false;
745   }
746   const firstChar = file.getUint16();
747   const lastChar = file.getUint16();
748   if (firstChar > lastChar) {
749     return false;
750   }
751   file.skip(6); // skipping sTypoAscender/Descender/LineGap
752   const usWinAscent = file.getUint16();
753   if (usWinAscent === 0) {
754     // makes font unreadable by windows
755     return false;
756   }
757 
758   // OS/2 appears to be valid, resetting some fields
759   os2.data[8] = os2.data[9] = 0; // IE rejects fonts if fsType != 0
760   return true;
761 }
762 
763 function createOS2Table(properties, charstrings, override) {
764   override ||= {
765     unitsPerEm: 0,
766     yMax: 0,
767     yMin: 0,
768     ascent: 0,
769     descent: 0,
770   };
771 
772   let ulUnicodeRange1 = 0;
773   let ulUnicodeRange2 = 0;
774   let ulUnicodeRange3 = 0;
775   let ulUnicodeRange4 = 0;
776 
777   let firstCharIndex = null;
778   let lastCharIndex = 0;
779   let position = -1;
780 
781   if (charstrings) {
782     for (let code in charstrings) {
783       code |= 0;
784       if (firstCharIndex > code || !firstCharIndex) {
785         firstCharIndex = code;
786       }
787       if (lastCharIndex < code) {
788         lastCharIndex = code;
789       }
790 
791       position = getUnicodeRangeFor(code, position);
792       if (position < 32) {
793         ulUnicodeRange1 |= 1 << position;
794       } else if (position < 64) {
795         ulUnicodeRange2 |= 1 << (position - 32);
796       } else if (position < 96) {
797         ulUnicodeRange3 |= 1 << (position - 64);
798       } else if (position < 123) {
799         ulUnicodeRange4 |= 1 << (position - 96);
800       } else {
801         throw new FormatError(
802           "Unicode ranges Bits > 123 are reserved for internal usage"
803         );
804       }
805     }
806     if (lastCharIndex > 0xffff) {
807       // OS2 only supports a 16 bit int. The spec says if supplementary
808       // characters are used the field should just be set to 0xFFFF.
809       lastCharIndex = 0xffff;
810     }
811   } else {
812     // TODO
813     firstCharIndex = 0;
814     lastCharIndex = 255;
815   }
816 
817   const bbox = properties.bbox || [0, 0, 0, 0];
818   const unitsPerEm =
819     override.unitsPerEm ||
820     (properties.fontMatrix
821       ? 1 / Math.max(...properties.fontMatrix.slice(0, 4).map(Math.abs))
822       : 1000);
823 
824   // if the font units differ to the PDF glyph space units
825   // then scale up the values
826   const scale = properties.ascentScaled
827     ? 1.0
828     : unitsPerEm / PDF_GLYPH_SPACE_UNITS;
829 
830   const typoAscent =
831     override.ascent || Math.round(scale * (properties.ascent || bbox[3]));
832   let typoDescent =
833     override.descent || Math.round(scale * (properties.descent || bbox[1]));
834   if (typoDescent > 0 && properties.descent > 0 && bbox[1] < 0) {
835     typoDescent = -typoDescent; // fixing incorrect descent
836   }
837   const winAscent = override.yMax || typoAscent;
838   const winDescent = -override.yMin || -typoDescent;
839 
840   return (
841     "\x00\x03" + // version
842     "\x02\x24" + // xAvgCharWidth
843     "\x01\xF4" + // usWeightClass
844     "\x00\x05" + // usWidthClass
845     "\x00\x00" + // fstype (0 to let the font loads via font-face on IE)
846     "\x02\x8A" + // ySubscriptXSize
847     "\x02\xBB" + // ySubscriptYSize
848     "\x00\x00" + // ySubscriptXOffset
849     "\x00\x8C" + // ySubscriptYOffset
850     "\x02\x8A" + // ySuperScriptXSize
851     "\x02\xBB" + // ySuperScriptYSize
852     "\x00\x00" + // ySuperScriptXOffset
853     "\x01\xDF" + // ySuperScriptYOffset
854     "\x00\x31" + // yStrikeOutSize
855     "\x01\x02" + // yStrikeOutPosition
856     "\x00\x00" + // sFamilyClass
857     "\x00\x00\x06" +
858     String.fromCharCode(properties.fixedPitch ? 0x09 : 0x00) +
859     "\x00\x00\x00\x00\x00\x00" + // Panose
860     string32(ulUnicodeRange1) + // ulUnicodeRange1 (Bits 0-31)
861     string32(ulUnicodeRange2) + // ulUnicodeRange2 (Bits 32-63)
862     string32(ulUnicodeRange3) + // ulUnicodeRange3 (Bits 64-95)
863     string32(ulUnicodeRange4) + // ulUnicodeRange4 (Bits 96-127)
864     "\x2A\x32\x31\x2A" + // achVendID
865     string16(properties.italicAngle ? 1 : 0) + // fsSelection
866     string16(firstCharIndex || properties.firstChar) + // usFirstCharIndex
867     string16(lastCharIndex || properties.lastChar) + // usLastCharIndex
868     string16(typoAscent) + // sTypoAscender
869     string16(typoDescent) + // sTypoDescender
870     "\x00\x64" + // sTypoLineGap (7%-10% of the unitsPerEM value)
871     string16(winAscent) + // usWinAscent
872     string16(winDescent) + // usWinDescent
873     "\x00\x00\x00\x00" + // ulCodePageRange1 (Bits 0-31)
874     "\x00\x00\x00\x00" + // ulCodePageRange2 (Bits 32-63)
875     string16(properties.xHeight) + // sxHeight
876     string16(properties.capHeight) + // sCapHeight
877     string16(0) + // usDefaultChar
878     string16(firstCharIndex || properties.firstChar) + // usBreakChar
879     "\x00\x03"
880   ); // usMaxContext
881 }
882 
883 function createPostTable(properties) {
884   const angle = Math.floor(properties.italicAngle * 2 ** 16);
885   return (
886     "\x00\x03\x00\x00" + // Version number
887     string32(angle) + // italicAngle
888     "\x00\x00" + // underlinePosition
889     "\x00\x00" + // underlineThickness
890     string32(properties.fixedPitch ? 1 : 0) + // isFixedPitch
891     "\x00\x00\x00\x00" + // minMemType42
892     "\x00\x00\x00\x00" + // maxMemType42
893     "\x00\x00\x00\x00" + // minMemType1
894     "\x00\x00\x00\x00"
895   ); // maxMemType1
896 }
897 
898 function createPostscriptName(name) {
899   // See https://docs.microsoft.com/en-us/typography/opentype/spec/recom#name.
900   return name.replaceAll(/[^\x21-\x7E]|[[\](){}<>/%]/g, "").slice(0, 63);
901 }
902 
903 function createNameTable(name, proto) {
904   if (!proto) {
905     proto = [[], []]; // no strings and unicode strings
906   }
907 
908   const strings = [
909     proto[0][0] || "Original licence", // 0.Copyright
910     proto[0][1] || name, // 1.Font family
911     proto[0][2] || "Unknown", // 2.Font subfamily (font weight)
912     proto[0][3] || "uniqueID", // 3.Unique ID
913     proto[0][4] || name, // 4.Full font name
914     proto[0][5] || "Version 0.11", // 5.Version
915     proto[0][6] || createPostscriptName(name), // 6.Postscript name
916     proto[0][7] || "Unknown", // 7.Trademark
917     proto[0][8] || "Unknown", // 8.Manufacturer
918     proto[0][9] || "Unknown", // 9.Designer
919   ];
920 
921   // Mac want 1-byte per character strings while Windows want
922   // 2-bytes per character, so duplicate the names table
923   const stringsUnicode = [];
924   let i, ii, j, jj, str;
925   for (i = 0, ii = strings.length; i < ii; i++) {
926     str = proto[1][i] || strings[i];
927 
928     const strBufUnicode = [];
929     for (j = 0, jj = str.length; j < jj; j++) {
930       strBufUnicode.push(string16(str.charCodeAt(j)));
931     }
932     stringsUnicode.push(strBufUnicode.join(""));
933   }
934 
935   const names = [strings, stringsUnicode];
936   const platforms = ["\x00\x01", "\x00\x03"];
937   const encodings = ["\x00\x00", "\x00\x01"];
938   const languages = ["\x00\x00", "\x04\x09"];
939 
940   const namesRecordCount = strings.length * platforms.length;
941   let nameTable =
942     "\x00\x00" + // format
943     string16(namesRecordCount) + // Number of names Record
944     string16(namesRecordCount * 12 + 6); // Storage
945 
946   // Build the name records field
947   let strOffset = 0;
948   for (i = 0, ii = platforms.length; i < ii; i++) {
949     const strs = names[i];
950     for (j = 0, jj = strs.length; j < jj; j++) {
951       str = strs[j];
952       const nameRecord =
953         platforms[i] + // platform ID
954         encodings[i] + // encoding ID
955         languages[i] + // language ID
956         string16(j) + // name ID
957         string16(str.length) +
958         string16(strOffset);
959       nameTable += nameRecord;
960       strOffset += str.length;
961     }
962   }
963 
964   nameTable += strings.join("") + stringsUnicode.join("");
965   return nameTable;
966 }
967 
968 /**
969  * 'Font' is the class the outside world should use, it encapsulate all the font
970  * decoding logics whatever type it is (assuming the font type is supported).
971  */
972 class Font {
973   constructor(name, file, properties, evaluatorOptions) {
974     this.name = name;
975     this.psName = null;
976     this.mimetype = null;
977     this.disableFontFace = evaluatorOptions.disableFontFace;
978     this.fontExtraProperties = evaluatorOptions.fontExtraProperties;
979 
980     this.loadedName = properties.loadedName;
981     this.isType3Font = properties.isType3Font;
982     this.missingFile = false;
983     this.cssFontInfo = properties.cssFontInfo;
984 
985     this._charsCache = Object.create(null);
986     this._glyphCache = Object.create(null);
987 
988     let isSerifFont = !!(properties.flags & FontFlags.Serif);
989     // Fallback to checking the font name, in order to improve text-selection,
990     // since the /Flags-entry is often wrong (fixes issue13845.pdf).
991     if (!isSerifFont && !properties.isSimulatedFlags) {
992       const baseName = name.replaceAll(/[,_]/g, "-").split("-", 1)[0],
993         serifFonts = getSerifFonts();
994       for (const namePart of baseName.split("+")) {
995         if (serifFonts[namePart]) {
996           isSerifFont = true;
997           break;
998         }
999       }
1000     }
1001     this.isSerifFont = isSerifFont;
1002 
1003     this.isSymbolicFont = !!(properties.flags & FontFlags.Symbolic);
1004     this.isMonospace = !!(properties.flags & FontFlags.FixedPitch);
1005 
1006     let { type, subtype } = properties;
1007     this.type = type;
1008     this.subtype = subtype;
1009     this.systemFontInfo = properties.systemFontInfo;
1010 
1011     const matches = name.match(/^InvalidPDFjsFont_(.*)_\d+$/);
1012     this.isInvalidPDFjsFont = !!matches;
1013     if (this.isInvalidPDFjsFont) {
1014       this.fallbackName = matches[1];
1015     } else if (this.isMonospace) {
1016       this.fallbackName = "monospace";
1017     } else if (this.isSerifFont) {
1018       this.fallbackName = "serif";
1019     } else {
1020       this.fallbackName = "sans-serif";
1021     }
1022 
1023     if (this.systemFontInfo?.guessFallback) {
1024       // Once the fallback name is guessed, we don't want to guess it again.
1025       this.systemFontInfo.guessFallback = false;
1026       this.systemFontInfo.css += `,${this.fallbackName}`;
1027     }
1028 
1029     this.differences = properties.differences;
1030     this.widths = properties.widths;
1031     this.defaultWidth = properties.defaultWidth;
1032     this.composite = properties.composite;
1033     this.cMap = properties.cMap;
1034     this.capHeight = properties.capHeight / PDF_GLYPH_SPACE_UNITS;
1035     this.ascent = properties.ascent / PDF_GLYPH_SPACE_UNITS;
1036     this.descent = properties.descent / PDF_GLYPH_SPACE_UNITS;
1037     this.lineHeight = this.ascent - this.descent;
1038     this.fontMatrix = properties.fontMatrix;
1039     this.bbox = properties.bbox;
1040     this.defaultEncoding = properties.defaultEncoding;
1041 
1042     this.toUnicode = properties.toUnicode;
1043     this.toFontChar = [];
1044 
1045     if (properties.type === "Type3") {
1046       for (let charCode = 0; charCode < 256; charCode++) {
1047         this.toFontChar[charCode] =
1048           this.differences[charCode] || properties.defaultEncoding[charCode];
1049       }
1050       return;
1051     }
1052 
1053     this.cidEncoding = properties.cidEncoding || "";
1054     this.vertical = !!properties.vertical;
1055     if (this.vertical) {
1056       this.vmetrics = properties.vmetrics;
1057       this.defaultVMetrics = properties.defaultVMetrics;
1058     }
1059 
1060     if (!file || file.isEmpty) {
1061       if (file) {
1062         // Some bad PDF generators will include empty font files,
1063         // attempting to recover by assuming that no file exists.
1064         warn('Font file is empty in "' + name + '" (' + this.loadedName + ")");
1065       }
1066       this.fallbackToSystemFont(properties);
1067       return;
1068     }
1069 
1070     // Parse the font file to determine the correct type/subtype, rather than
1071     // relying on the (often incorrect) data in the font dictionary; (see e.g.
1072     //  issue6782.pdf, issue7598.pdf, and issue9949.pdf).
1073     [type, subtype] = getFontFileType(file, properties);
1074 
1075     if (type !== this.type || subtype !== this.subtype) {
1076       info(
1077         "Inconsistent font file Type/SubType, expected: " +
1078           `${this.type}/${this.subtype} but found: ${type}/${subtype}.`
1079       );
1080     }
1081 
1082     let data;
1083     try {
1084       switch (type) {
1085         case "MMType1":
1086           info("MMType1 font (" + name + "), falling back to Type1.");
1087         /* falls through */
1088         case "Type1":
1089         case "CIDFontType0":
1090           this.mimetype = "font/opentype";
1091 
1092           const cff =
1093             subtype === "Type1C" || subtype === "CIDFontType0C"
1094               ? new CFFFont(file, properties)
1095               : new Type1Font(name, file, properties);
1096 
1097           adjustWidths(properties);
1098 
1099           // Wrap the CFF data inside an OTF font file
1100           data = this.convert(name, cff, properties);
1101           break;
1102 
1103         case "OpenType":
1104         case "TrueType":
1105         case "CIDFontType2":
1106           this.mimetype = "font/opentype";
1107 
1108           // Repair the TrueType file. It is can be damaged in the point of
1109           // view of the sanitizer
1110           data = this.checkAndRepair(name, file, properties);
1111           if (this.isOpenType) {
1112             adjustWidths(properties);
1113 
1114             type = "OpenType";
1115           }
1116           break;
1117 
1118         default:
1119           throw new FormatError(`Font ${type} is not supported`);
1120       }
1121     } catch (e) {
1122       warn(e);
1123       this.fallbackToSystemFont(properties);
1124       return;
1125     }
1126 
1127     amendFallbackToUnicode(properties);
1128     this.data = data;
1129 
1130     // Transfer some properties again that could change during font conversion
1131     this.type = type;
1132     this.subtype = subtype;
1133     this.fontMatrix = properties.fontMatrix;
1134     this.widths = properties.widths;
1135     this.defaultWidth = properties.defaultWidth;
1136     this.toUnicode = properties.toUnicode;
1137     this.seacMap = properties.seacMap;
1138   }
1139 
1140   get renderer() {
1141     const renderer = FontRendererFactory.create(this, SEAC_ANALYSIS_ENABLED);
1142     return shadow(this, "renderer", renderer);
1143   }
1144 
1145   exportData() {
1146     const exportDataProps = this.fontExtraProperties
1147       ? [...EXPORT_DATA_PROPERTIES, ...EXPORT_DATA_EXTRA_PROPERTIES]
1148       : EXPORT_DATA_PROPERTIES;
1149 
1150     const data = Object.create(null);
1151     for (const prop of exportDataProps) {
1152       const value = this[prop];
1153       // Ignore properties that haven't been explicitly set.
1154       if (value !== undefined) {
1155         data[prop] = value;
1156       }
1157     }
1158     return data;
1159   }
1160 
1161   fallbackToSystemFont(properties) {
1162     this.missingFile = true;
1163     // The file data is not specified. Trying to fix the font name
1164     // to be used with the canvas.font.
1165     const { name, type } = this;
1166     let fontName = normalizeFontName(name);
1167     const stdFontMap = getStdFontMap(),
1168       nonStdFontMap = getNonStdFontMap();
1169     const isStandardFont = !!stdFontMap[fontName];
1170     const isMappedToStandardFont = !!(
1171       nonStdFontMap[fontName] && stdFontMap[nonStdFontMap[fontName]]
1172     );
1173 
1174     fontName = stdFontMap[fontName] || nonStdFontMap[fontName] || fontName;
1175 
1176     const fontBasicMetricsMap = getFontBasicMetrics();
1177     const metrics = fontBasicMetricsMap[fontName];
1178     if (metrics) {
1179       if (isNaN(this.ascent)) {
1180         this.ascent = metrics.ascent / PDF_GLYPH_SPACE_UNITS;
1181       }
1182       if (isNaN(this.descent)) {
1183         this.descent = metrics.descent / PDF_GLYPH_SPACE_UNITS;
1184       }
1185       if (isNaN(this.capHeight)) {
1186         this.capHeight = metrics.capHeight / PDF_GLYPH_SPACE_UNITS;
1187       }
1188     }
1189 
1190     this.bold = /bold/gi.test(fontName);
1191     this.italic = /oblique|italic/gi.test(fontName);
1192 
1193     // Use 'name' instead of 'fontName' here because the original
1194     // name ArialBlack for example will be replaced by Helvetica.
1195     this.black = /Black/g.test(name);
1196 
1197     // Use 'name' instead of 'fontName' here because the original
1198     // name ArialNarrow for example will be replaced by Helvetica.
1199     const isNarrow = /Narrow/g.test(name);
1200 
1201     // if at least one width is present, remeasure all chars when exists
1202     this.remeasure =
1203       (!isStandardFont || isNarrow) && Object.keys(this.widths).length > 0;
1204     if (
1205       (isStandardFont || isMappedToStandardFont) &&
1206       type === "CIDFontType2" &&
1207       this.cidEncoding.startsWith("Identity-")
1208     ) {
1209       const cidToGidMap = properties.cidToGidMap;
1210       // Standard fonts might be embedded as CID font without glyph mapping.
1211       // Building one based on GlyphMapForStandardFonts.
1212       const map = [];
1213       applyStandardFontGlyphMap(map, getGlyphMapForStandardFonts());
1214 
1215       if (/Arial-?Black/i.test(name)) {
1216         applyStandardFontGlyphMap(map, getSupplementalGlyphMapForArialBlack());
1217       } else if (/Calibri/i.test(name)) {
1218         applyStandardFontGlyphMap(map, getSupplementalGlyphMapForCalibri());
1219       }
1220 
1221       // Always update the glyph mapping with the `cidToGidMap` when it exists
1222       // (fixes issue12418_reduced.pdf).
1223       if (cidToGidMap) {
1224         for (const charCode in map) {
1225           const cid = map[charCode];
1226           if (cidToGidMap[cid] !== undefined) {
1227             map[+charCode] = cidToGidMap[cid];
1228           }
1229         }
1230         // When the /CIDToGIDMap is "incomplete", fallback to the included
1231         // /ToUnicode-map regardless of its encoding (fixes issue11915.pdf).
1232         if (
1233           cidToGidMap.length !== this.toUnicode.length &&
1234           properties.hasIncludedToUnicodeMap &&
1235           this.toUnicode instanceof IdentityToUnicodeMap
1236         ) {
1237           this.toUnicode.forEach(function (charCode, unicodeCharCode) {
1238             const cid = map[charCode];
1239             if (cidToGidMap[cid] === undefined) {
1240               map[+charCode] = unicodeCharCode;
1241             }
1242           });
1243         }
1244       }
1245 
1246       if (!(this.toUnicode instanceof IdentityToUnicodeMap)) {
1247         this.toUnicode.forEach(function (charCode, unicodeCharCode) {
1248           map[+charCode] = unicodeCharCode;
1249         });
1250       }
1251       this.toFontChar = map;
1252       this.toUnicode = new ToUnicodeMap(map);
1253     } else if (/Symbol/i.test(fontName)) {
1254       this.toFontChar = buildToFontChar(
1255         SymbolSetEncoding,
1256         getGlyphsUnicode(),
1257         this.differences
1258       );
1259     } else if (/Dingbats/i.test(fontName)) {
1260       this.toFontChar = buildToFontChar(
1261         ZapfDingbatsEncoding,
1262         getDingbatsGlyphsUnicode(),
1263         this.differences
1264       );
1265     } else if (isStandardFont || isMappedToStandardFont) {
1266       const map = buildToFontChar(
1267         this.defaultEncoding,
1268         getGlyphsUnicode(),
1269         this.differences
1270       );
1271 
1272       if (
1273         type === "CIDFontType2" &&
1274         !this.cidEncoding.startsWith("Identity-") &&
1275         !(this.toUnicode instanceof IdentityToUnicodeMap)
1276       ) {
1277         this.toUnicode.forEach(function (charCode, unicodeCharCode) {
1278           map[+charCode] = unicodeCharCode;
1279         });
1280       }
1281       this.toFontChar = map;
1282     } else {
1283       const glyphsUnicodeMap = getGlyphsUnicode();
1284       const map = [];
1285       this.toUnicode.forEach((charCode, unicodeCharCode) => {
1286         if (!this.composite) {
1287           const glyphName =
1288             this.differences[charCode] || this.defaultEncoding[charCode];
1289           const unicode = getUnicodeForGlyph(glyphName, glyphsUnicodeMap);
1290           if (unicode !== -1) {
1291             unicodeCharCode = unicode;
1292           }
1293         }
1294         map[+charCode] = unicodeCharCode;
1295       });
1296 
1297       // Attempt to improve the glyph mapping for (some) composite fonts that
1298       // appear to lack meaningful ToUnicode data.
1299       if (this.composite && this.toUnicode instanceof IdentityToUnicodeMap) {
1300         if (/Tahoma|Verdana/i.test(name)) {
1301           // Fixes issue15719.pdf and issue11242_reduced.pdf.
1302           applyStandardFontGlyphMap(map, getGlyphMapForStandardFonts());
1303         }
1304       }
1305       this.toFontChar = map;
1306     }
1307 
1308     amendFallbackToUnicode(properties);
1309     this.loadedName = fontName.split("-", 1)[0];
1310   }
1311 
1312   checkAndRepair(name, font, properties) {
1313     const VALID_TABLES = [
1314       "OS/2",
1315       "cmap",
1316       "head",
1317       "hhea",
1318       "hmtx",
1319       "maxp",
1320       "name",
1321       "post",
1322       "loca",
1323       "glyf",
1324       "fpgm",
1325       "prep",
1326       "cvt ",
1327       "CFF ",
1328     ];
1329 
1330     function readTables(file, numTables) {
1331       const tables = Object.create(null);
1332       tables["OS/2"] = null;
1333       tables.cmap = null;
1334       tables.head = null;
1335       tables.hhea = null;
1336       tables.hmtx = null;
1337       tables.maxp = null;
1338       tables.name = null;
1339       tables.post = null;
1340 
1341       for (let i = 0; i < numTables; i++) {
1342         const table = readTableEntry(file);
1343         if (!VALID_TABLES.includes(table.tag)) {
1344           continue; // skipping table if it's not a required or optional table
1345         }
1346         if (table.length === 0) {
1347           continue; // skipping empty tables
1348         }
1349         tables[table.tag] = table;
1350       }
1351       return tables;
1352     }
1353 
1354     function readTableEntry(file) {
1355       const tag = file.getString(4);
1356 
1357       const checksum = file.getInt32() >>> 0;
1358       const offset = file.getInt32() >>> 0;
1359       const length = file.getInt32() >>> 0;
1360 
1361       // Read the table associated data
1362       const previousPosition = file.pos;
1363       file.pos = file.start || 0;
1364       file.skip(offset);
1365       const data = file.getBytes(length);
1366       file.pos = previousPosition;
1367 
1368       if (tag === "head") {
1369         // clearing checksum adjustment
1370         data[8] = data[9] = data[10] = data[11] = 0;
1371         data[17] |= 0x20; // Set font optimized for cleartype flag.
1372       }
1373 
1374       return {
1375         tag,
1376         checksum,
1377         length,
1378         offset,
1379         data,
1380       };
1381     }
1382 
1383     function readOpenTypeHeader(ttf) {
1384       return {
1385         version: ttf.getString(4),
1386         numTables: ttf.getUint16(),
1387         searchRange: ttf.getUint16(),
1388         entrySelector: ttf.getUint16(),
1389         rangeShift: ttf.getUint16(),
1390       };
1391     }
1392 
1393     function readTrueTypeCollectionHeader(ttc) {
1394       const ttcTag = ttc.getString(4);
1395       assert(ttcTag === "ttcf", "Must be a TrueType Collection font.");
1396 
1397       const majorVersion = ttc.getUint16();
1398       const minorVersion = ttc.getUint16();
1399       const numFonts = ttc.getInt32() >>> 0;
1400       const offsetTable = [];
1401       for (let i = 0; i < numFonts; i++) {
1402         offsetTable.push(ttc.getInt32() >>> 0);
1403       }
1404 
1405       const header = {
1406         ttcTag,
1407         majorVersion,
1408         minorVersion,
1409         numFonts,
1410         offsetTable,
1411       };
1412       switch (majorVersion) {
1413         case 1:
1414           return header;
1415         case 2:
1416           header.dsigTag = ttc.getInt32() >>> 0;
1417           header.dsigLength = ttc.getInt32() >>> 0;
1418           header.dsigOffset = ttc.getInt32() >>> 0;
1419           return header;
1420       }
1421       throw new FormatError(
1422         `Invalid TrueType Collection majorVersion: ${majorVersion}.`
1423       );
1424     }
1425 
1426     function readTrueTypeCollectionData(ttc, fontName) {
1427       const { numFonts, offsetTable } = readTrueTypeCollectionHeader(ttc);
1428       const fontNameParts = fontName.split("+");
1429       let fallbackData;
1430 
1431       for (let i = 0; i < numFonts; i++) {
1432         ttc.pos = (ttc.start || 0) + offsetTable[i];
1433         const potentialHeader = readOpenTypeHeader(ttc);
1434         const potentialTables = readTables(ttc, potentialHeader.numTables);
1435 
1436         if (!potentialTables.name) {
1437           throw new FormatError(
1438             'TrueType Collection font must contain a "name" table.'
1439           );
1440         }
1441         const [nameTable] = readNameTable(potentialTables.name);
1442 
1443         for (let j = 0, jj = nameTable.length; j < jj; j++) {
1444           for (let k = 0, kk = nameTable[j].length; k < kk; k++) {
1445             const nameEntry = nameTable[j][k]?.replaceAll(/\s/g, "");
1446             if (!nameEntry) {
1447               continue;
1448             }
1449             if (nameEntry === fontName) {
1450               return {
1451                 header: potentialHeader,
1452                 tables: potentialTables,
1453               };
1454             }
1455             if (fontNameParts.length < 2) {
1456               continue;
1457             }
1458             for (const part of fontNameParts) {
1459               if (nameEntry === part) {
1460                 fallbackData = {
1461                   name: part,
1462                   header: potentialHeader,
1463                   tables: potentialTables,
1464                 };
1465               }
1466             }
1467           }
1468         }
1469       }
1470       if (fallbackData) {
1471         warn(
1472           `TrueType Collection does not contain "${fontName}" font, ` +
1473             `falling back to "${fallbackData.name}" font instead.`
1474         );
1475         return {
1476           header: fallbackData.header,
1477           tables: fallbackData.tables,
1478         };
1479       }
1480       throw new FormatError(
1481         `TrueType Collection does not contain "${fontName}" font.`
1482       );
1483     }
1484 
1485     /**
1486      * Read the appropriate subtable from the cmap according to 9.6.6.4 from
1487      * PDF spec
1488      */
1489     function readCmapTable(cmap, file, isSymbolicFont, hasEncoding) {
1490       if (!cmap) {
1491         warn("No cmap table available.");
1492         return {
1493           platformId: -1,
1494           encodingId: -1,
1495           mappings: [],
1496           hasShortCmap: false,
1497         };
1498       }
1499       let segment;
1500       let start = (file.start || 0) + cmap.offset;
1501       file.pos = start;
1502 
1503       file.skip(2); // version
1504       const numTables = file.getUint16();
1505 
1506       let potentialTable;
1507       let canBreak = false;
1508       // There's an order of preference in terms of which cmap subtable to
1509       // use:
1510       // - non-symbolic fonts the preference is a 3,1 table then a 1,0 table
1511       // - symbolic fonts the preference is a 3,0 table then a 1,0 table
1512       // The following takes advantage of the fact that the tables are sorted
1513       // to work.
1514       for (let i = 0; i < numTables; i++) {
1515         const platformId = file.getUint16();
1516         const encodingId = file.getUint16();
1517         const offset = file.getInt32() >>> 0;
1518         let useTable = false;
1519 
1520         // Sometimes there are multiple of the same type of table. Default
1521         // to choosing the first table and skip the rest.
1522         if (
1523           potentialTable?.platformId === platformId &&
1524           potentialTable?.encodingId === encodingId
1525         ) {
1526           continue;
1527         }
1528 
1529         if (
1530           platformId === 0 &&
1531           (encodingId === /* Unicode Default */ 0 ||
1532             encodingId === /* Unicode 1.1 */ 1 ||
1533             encodingId === /* Unicode BMP */ 3)
1534         ) {
1535           useTable = true;
1536           // Continue the loop since there still may be a higher priority
1537           // table.
1538         } else if (platformId === 1 && encodingId === 0) {
1539           useTable = true;
1540           // Continue the loop since there still may be a higher priority
1541           // table.
1542         } else if (
1543           platformId === 3 &&
1544           encodingId === 1 &&
1545           (hasEncoding || !potentialTable)
1546         ) {
1547           useTable = true;
1548           if (!isSymbolicFont) {
1549             canBreak = true;
1550           }
1551         } else if (isSymbolicFont && platformId === 3 && encodingId === 0) {
1552           useTable = true;
1553 
1554           let correctlySorted = true;
1555           if (i < numTables - 1) {
1556             const nextBytes = file.peekBytes(2),
1557               nextPlatformId = int16(nextBytes[0], nextBytes[1]);
1558             if (nextPlatformId < platformId) {
1559               correctlySorted = false;
1560             }
1561           }
1562           if (correctlySorted) {
1563             canBreak = true;
1564           }
1565         }
1566 
1567         if (useTable) {
1568           potentialTable = {
1569             platformId,
1570             encodingId,
1571             offset,
1572           };
1573         }
1574         if (canBreak) {
1575           break;
1576         }
1577       }
1578 
1579       if (potentialTable) {
1580         file.pos = start + potentialTable.offset;
1581       }
1582       if (!potentialTable || file.peekByte() === -1) {
1583         warn("Could not find a preferred cmap table.");
1584         return {
1585           platformId: -1,
1586           encodingId: -1,
1587           mappings: [],
1588           hasShortCmap: false,
1589         };
1590       }
1591 
1592       const format = file.getUint16();
1593       let hasShortCmap = false;
1594       const mappings = [];
1595       let j, glyphId;
1596 
1597       // TODO(mack): refactor this cmap subtable reading logic out
1598       if (format === 0) {
1599         file.skip(2 + 2); // length + language
1600 
1601         for (j = 0; j < 256; j++) {
1602           const index = file.getByte();
1603           if (!index) {
1604             continue;
1605           }
1606           mappings.push({
1607             charCode: j,
1608             glyphId: index,
1609           });
1610         }
1611         hasShortCmap = true;
1612       } else if (format === 2) {
1613         file.skip(2 + 2); // length + language
1614 
1615         const subHeaderKeys = [];
1616         let maxSubHeaderKey = 0;
1617         // Read subHeaderKeys. If subHeaderKeys[i] === 0, then i is a
1618         // single-byte character. Otherwise, i is the first byte of a
1619         // multi-byte character, and the value is 8*index into
1620         // subHeaders.
1621         for (let i = 0; i < 256; i++) {
1622           const subHeaderKey = file.getUint16() >> 3;
1623           subHeaderKeys.push(subHeaderKey);
1624           maxSubHeaderKey = Math.max(subHeaderKey, maxSubHeaderKey);
1625         }
1626         // Read subHeaders. The number of entries is determined
1627         // dynamically based on the subHeaderKeys found above.
1628         const subHeaders = [];
1629         for (let i = 0; i <= maxSubHeaderKey; i++) {
1630           subHeaders.push({
1631             firstCode: file.getUint16(),
1632             entryCount: file.getUint16(),
1633             idDelta: signedInt16(file.getByte(), file.getByte()),
1634             idRangePos: file.pos + file.getUint16(),
1635           });
1636         }
1637         for (let i = 0; i < 256; i++) {
1638           if (subHeaderKeys[i] === 0) {
1639             // i is a single-byte code.
1640             file.pos = subHeaders[0].idRangePos + 2 * i;
1641             glyphId = file.getUint16();
1642             mappings.push({
1643               charCode: i,
1644               glyphId,
1645             });
1646           } else {
1647             // i is the first byte of a two-byte code.
1648             const s = subHeaders[subHeaderKeys[i]];
1649             for (j = 0; j < s.entryCount; j++) {
1650               const charCode = (i << 8) + j + s.firstCode;
1651               file.pos = s.idRangePos + 2 * j;
1652               glyphId = file.getUint16();
1653               if (glyphId !== 0) {
1654                 glyphId = (glyphId + s.idDelta) % 65536;
1655               }
1656               mappings.push({
1657                 charCode,
1658                 glyphId,
1659               });
1660             }
1661           }
1662         }
1663       } else if (format === 4) {
1664         file.skip(2 + 2); // length + language
1665 
1666         // re-creating the table in format 4 since the encoding
1667         // might be changed
1668         const segCount = file.getUint16() >> 1;
1669         file.skip(6); // skipping range fields
1670         const segments = [];
1671         let segIndex;
1672         for (segIndex = 0; segIndex < segCount; segIndex++) {
1673           segments.push({ end: file.getUint16() });
1674         }
1675         file.skip(2);
1676         for (segIndex = 0; segIndex < segCount; segIndex++) {
1677           segments[segIndex].start = file.getUint16();
1678         }
1679 
1680         for (segIndex = 0; segIndex < segCount; segIndex++) {
1681           segments[segIndex].delta = file.getUint16();
1682         }
1683 
1684         let offsetsCount = 0,
1685           offsetIndex;
1686         for (segIndex = 0; segIndex < segCount; segIndex++) {
1687           segment = segments[segIndex];
1688           const rangeOffset = file.getUint16();
1689           if (!rangeOffset) {
1690             segment.offsetIndex = -1;
1691             continue;
1692           }
1693 
1694           offsetIndex = (rangeOffset >> 1) - (segCount - segIndex);
1695           segment.offsetIndex = offsetIndex;
1696           offsetsCount = Math.max(
1697             offsetsCount,
1698             offsetIndex + segment.end - segment.start + 1
1699           );
1700         }
1701 
1702         const offsets = [];
1703         for (j = 0; j < offsetsCount; j++) {
1704           offsets.push(file.getUint16());
1705         }
1706 
1707         for (segIndex = 0; segIndex < segCount; segIndex++) {
1708           segment = segments[segIndex];
1709           start = segment.start;
1710           const end = segment.end;
1711           const delta = segment.delta;
1712           offsetIndex = segment.offsetIndex;
1713 
1714           for (j = start; j <= end; j++) {
1715             if (j === 0xffff) {
1716               continue;
1717             }
1718 
1719             glyphId = offsetIndex < 0 ? j : offsets[offsetIndex + j - start];
1720             glyphId = (glyphId + delta) & 0xffff;
1721             mappings.push({
1722               charCode: j,
1723               glyphId,
1724             });
1725           }
1726         }
1727       } else if (format === 6) {
1728         file.skip(2 + 2); // length + language
1729 
1730         // Format 6 is a 2-bytes dense mapping, which means the font data
1731         // lives glue together even if they are pretty far in the unicode
1732         // table. (This looks weird, so I can have missed something), this
1733         // works on Linux but seems to fails on Mac so let's rewrite the
1734         // cmap table to a 3-1-4 style
1735         const firstCode = file.getUint16();
1736         const entryCount = file.getUint16();
1737 
1738         for (j = 0; j < entryCount; j++) {
1739           glyphId = file.getUint16();
1740           const charCode = firstCode + j;
1741 
1742           mappings.push({
1743             charCode,
1744             glyphId,
1745           });
1746         }
1747       } else if (format === 12) {
1748         file.skip(2 + 4 + 4); // reserved + length + language
1749 
1750         const nGroups = file.getInt32() >>> 0;
1751         for (j = 0; j < nGroups; j++) {
1752           const startCharCode = file.getInt32() >>> 0;
1753           const endCharCode = file.getInt32() >>> 0;
1754           let glyphCode = file.getInt32() >>> 0;
1755 
1756           for (
1757             let charCode = startCharCode;
1758             charCode <= endCharCode;
1759             charCode++
1760           ) {
1761             mappings.push({
1762               charCode,
1763               glyphId: glyphCode++,
1764             });
1765           }
1766         }
1767       } else {
1768         warn("cmap table has unsupported format: " + format);
1769         return {
1770           platformId: -1,
1771           encodingId: -1,
1772           mappings: [],
1773           hasShortCmap: false,
1774         };
1775       }
1776 
1777       // removing duplicate entries
1778       mappings.sort((a, b) => a.charCode - b.charCode);
1779       const finalMappings = [],
1780         seenCharCodes = new Set();
1781       for (const map of mappings) {
1782         const { charCode } = map;
1783 
1784         if (seenCharCodes.has(charCode)) {
1785           continue;
1786         }
1787         seenCharCodes.add(charCode);
1788         finalMappings.push(map);
1789       }
1790 
1791       return {
1792         platformId: potentialTable.platformId,
1793         encodingId: potentialTable.encodingId,
1794         mappings: finalMappings,
1795         hasShortCmap,
1796       };
1797     }
1798 
1799     function sanitizeMetrics(
1800       file,
1801       header,
1802       metrics,
1803       headTable,
1804       numGlyphs,
1805       dupFirstEntry
1806     ) {
1807       if (!header) {
1808         if (metrics) {
1809           metrics.data = null;
1810         }
1811         return;
1812       }
1813 
1814       file.pos = (file.start || 0) + header.offset;
1815       file.pos += 4; // version
1816       file.pos += 2; // ascent
1817       file.pos += 2; // descent
1818       file.pos += 2; // linegap
1819       file.pos += 2; // adv_width_max
1820       file.pos += 2; // min_sb1
1821       file.pos += 2; // min_sb2
1822       file.pos += 2; // max_extent
1823       file.pos += 2; // caret_slope_rise
1824       file.pos += 2; // caret_slope_run
1825       const caretOffset = file.getUint16();
1826       file.pos += 8; // reserved
1827       file.pos += 2; // format
1828       let numOfMetrics = file.getUint16();
1829 
1830       if (caretOffset !== 0) {
1831         const macStyle = int16(headTable.data[44], headTable.data[45]);
1832         if (!(macStyle & 2)) {
1833           // Suppress OTS warnings about the `caretOffset` in the hhea-table.
1834           header.data[22] = 0;
1835           header.data[23] = 0;
1836         }
1837       }
1838 
1839       if (numOfMetrics > numGlyphs) {
1840         info(
1841           `The numOfMetrics (${numOfMetrics}) should not be ` +
1842             `greater than the numGlyphs (${numGlyphs}).`
1843         );
1844         // Reduce numOfMetrics if it is greater than numGlyphs
1845         numOfMetrics = numGlyphs;
1846         header.data[34] = (numOfMetrics & 0xff00) >> 8;
1847         header.data[35] = numOfMetrics & 0x00ff;
1848       }
1849 
1850       const numOfSidebearings = numGlyphs - numOfMetrics;
1851       const numMissing =
1852         numOfSidebearings - ((metrics.length - numOfMetrics * 4) >> 1);
1853 
1854       if (numMissing > 0) {
1855         // For each missing glyph, we set both the width and lsb to 0 (zero).
1856         // Since we need to add two properties for each glyph, this explains
1857         // the use of |numMissing * 2| when initializing the typed array.
1858         const entries = new Uint8Array(metrics.length + numMissing * 2);
1859         entries.set(metrics.data);
1860         if (dupFirstEntry) {
1861           // Set the sidebearing value of the duplicated glyph.
1862           entries[metrics.length] = metrics.data[2];
1863           entries[metrics.length + 1] = metrics.data[3];
1864         }
1865         metrics.data = entries;
1866       }
1867     }
1868 
1869     function sanitizeGlyph(
1870       source,
1871       sourceStart,
1872       sourceEnd,
1873       dest,
1874       destStart,
1875       hintsValid
1876     ) {
1877       const glyphProfile = {
1878         length: 0,
1879         sizeOfInstructions: 0,
1880       };
1881       if (
1882         sourceStart < 0 ||
1883         sourceStart >= source.length ||
1884         sourceEnd > source.length ||
1885         sourceEnd - sourceStart <= 12
1886       ) {
1887         // If the offsets are wrong or the glyph is too small, remove it.
1888         return glyphProfile;
1889       }
1890       const glyf = source.subarray(sourceStart, sourceEnd);
1891 
1892       // Sanitize the glyph bounding box.
1893       const xMin = signedInt16(glyf[2], glyf[3]);
1894       const yMin = signedInt16(glyf[4], glyf[5]);
1895       const xMax = signedInt16(glyf[6], glyf[7]);
1896       const yMax = signedInt16(glyf[8], glyf[9]);
1897 
1898       if (xMin > xMax) {
1899         writeSignedInt16(glyf, 2, xMax);
1900         writeSignedInt16(glyf, 6, xMin);
1901       }
1902       if (yMin > yMax) {
1903         writeSignedInt16(glyf, 4, yMax);
1904         writeSignedInt16(glyf, 8, yMin);
1905       }
1906 
1907       const contoursCount = signedInt16(glyf[0], glyf[1]);
1908       if (contoursCount < 0) {
1909         if (contoursCount < -1) {
1910           // OTS doesn't like contour count to be less than -1.
1911           // The glyph data offsets are very likely wrong and
1912           // having something lower than -1, very likely, implies
1913           // to have some garbage data.
1914           return glyphProfile;
1915         }
1916         // complex glyph, writing as is
1917         dest.set(glyf, destStart);
1918         glyphProfile.length = glyf.length;
1919         return glyphProfile;
1920       }
1921 
1922       let i,
1923         j = 10,
1924         flagsCount = 0;
1925       for (i = 0; i < contoursCount; i++) {
1926         const endPoint = (glyf[j] << 8) | glyf[j + 1];
1927         flagsCount = endPoint + 1;
1928         j += 2;
1929       }
1930       // skipping instructions
1931       const instructionsStart = j;
1932       const instructionsLength = (glyf[j] << 8) | glyf[j + 1];
1933       glyphProfile.sizeOfInstructions = instructionsLength;
1934       j += 2 + instructionsLength;
1935       const instructionsEnd = j;
1936       // validating flags
1937       let coordinatesLength = 0;
1938       for (i = 0; i < flagsCount; i++) {
1939         const flag = glyf[j++];
1940         if (flag & 0xc0) {
1941           // reserved flags must be zero, cleaning up
1942           glyf[j - 1] = flag & 0x3f;
1943         }
1944         let xLength = 2;
1945         if (flag & 2) {
1946           xLength = 1;
1947         } else if (flag & 16) {
1948           xLength = 0;
1949         }
1950         let yLength = 2;
1951         if (flag & 4) {
1952           yLength = 1;
1953         } else if (flag & 32) {
1954           yLength = 0;
1955         }
1956         const xyLength = xLength + yLength;
1957         coordinatesLength += xyLength;
1958         if (flag & 8) {
1959           const repeat = glyf[j++];
1960           if (repeat === 0) {
1961             // The repeat count should be non-zero when the repeat flag is set.
1962             glyf[j - 1] ^= 8;
1963           }
1964           i += repeat;
1965           coordinatesLength += repeat * xyLength;
1966         }
1967       }
1968       // glyph without coordinates will be rejected
1969       if (coordinatesLength === 0) {
1970         return glyphProfile;
1971       }
1972       let glyphDataLength = j + coordinatesLength;
1973       if (glyphDataLength > glyf.length) {
1974         // not enough data for coordinates
1975         return glyphProfile;
1976       }
1977       if (!hintsValid && instructionsLength > 0) {
1978         dest.set(glyf.subarray(0, instructionsStart), destStart);
1979         dest.set([0, 0], destStart + instructionsStart);
1980         dest.set(
1981           glyf.subarray(instructionsEnd, glyphDataLength),
1982           destStart + instructionsStart + 2
1983         );
1984         glyphDataLength -= instructionsLength;
1985         if (glyf.length - glyphDataLength > 3) {
1986           glyphDataLength = (glyphDataLength + 3) & ~3;
1987         }
1988         glyphProfile.length = glyphDataLength;
1989         return glyphProfile;
1990       }
1991       if (glyf.length - glyphDataLength > 3) {
1992         // truncating and aligning to 4 bytes the long glyph data
1993         glyphDataLength = (glyphDataLength + 3) & ~3;
1994         dest.set(glyf.subarray(0, glyphDataLength), destStart);
1995         glyphProfile.length = glyphDataLength;
1996         return glyphProfile;
1997       }
1998       // glyph data is fine
1999       dest.set(glyf, destStart);
2000       glyphProfile.length = glyf.length;
2001       return glyphProfile;
2002     }
2003 
2004     function sanitizeHead(head, numGlyphs, locaLength) {
2005       const data = head.data;
2006 
2007       // Validate version:
2008       // Should always be 0x00010000
2009       const version = int32(data[0], data[1], data[2], data[3]);
2010       if (version >> 16 !== 1) {
2011         info("Attempting to fix invalid version in head table: " + version);
2012         data[0] = 0;
2013         data[1] = 1;
2014         data[2] = 0;
2015         data[3] = 0;
2016       }
2017 
2018       const indexToLocFormat = int16(data[50], data[51]);
2019       if (indexToLocFormat < 0 || indexToLocFormat > 1) {
2020         info(
2021           "Attempting to fix invalid indexToLocFormat in head table: " +
2022             indexToLocFormat
2023         );
2024 
2025         // The value of indexToLocFormat should be 0 if the loca table
2026         // consists of short offsets, and should be 1 if the loca table
2027         // consists of long offsets.
2028         //
2029         // The number of entries in the loca table should be numGlyphs + 1.
2030         //
2031         // Using this information, we can work backwards to deduce if the
2032         // size of each offset in the loca table, and thus figure out the
2033         // appropriate value for indexToLocFormat.
2034 
2035         const numGlyphsPlusOne = numGlyphs + 1;
2036         if (locaLength === numGlyphsPlusOne << 1) {
2037           // 0x0000 indicates the loca table consists of short offsets
2038           data[50] = 0;
2039           data[51] = 0;
2040         } else if (locaLength === numGlyphsPlusOne << 2) {
2041           // 0x0001 indicates the loca table consists of long offsets
2042           data[50] = 0;
2043           data[51] = 1;
2044         } else {
2045           throw new FormatError(
2046             "Could not fix indexToLocFormat: " + indexToLocFormat
2047           );
2048         }
2049       }
2050     }
2051 
2052     function sanitizeGlyphLocations(
2053       loca,
2054       glyf,
2055       numGlyphs,
2056       isGlyphLocationsLong,
2057       hintsValid,
2058       dupFirstEntry,
2059       maxSizeOfInstructions
2060     ) {
2061       let itemSize, itemDecode, itemEncode;
2062       if (isGlyphLocationsLong) {
2063         itemSize = 4;
2064         itemDecode = function fontItemDecodeLong(data, offset) {
2065           return (
2066             (data[offset] << 24) |
2067             (data[offset + 1] << 16) |
2068             (data[offset + 2] << 8) |
2069             data[offset + 3]
2070           );
2071         };
2072         itemEncode = function fontItemEncodeLong(data, offset, value) {
2073           data[offset] = (value >>> 24) & 0xff;
2074           data[offset + 1] = (value >> 16) & 0xff;
2075           data[offset + 2] = (value >> 8) & 0xff;
2076           data[offset + 3] = value & 0xff;
2077         };
2078       } else {
2079         itemSize = 2;
2080         itemDecode = function fontItemDecode(data, offset) {
2081           return (data[offset] << 9) | (data[offset + 1] << 1);
2082         };
2083         itemEncode = function fontItemEncode(data, offset, value) {
2084           data[offset] = (value >> 9) & 0xff;
2085           data[offset + 1] = (value >> 1) & 0xff;
2086         };
2087       }
2088       // The first glyph is duplicated.
2089       const numGlyphsOut = dupFirstEntry ? numGlyphs + 1 : numGlyphs;
2090       const locaDataSize = itemSize * (1 + numGlyphsOut);
2091       // Resize loca table to account for duplicated glyph.
2092       const locaData = new Uint8Array(locaDataSize);
2093       locaData.set(loca.data.subarray(0, locaDataSize));
2094       loca.data = locaData;
2095       // removing the invalid glyphs
2096       const oldGlyfData = glyf.data;
2097       const oldGlyfDataLength = oldGlyfData.length;
2098       const newGlyfData = new Uint8Array(oldGlyfDataLength);
2099 
2100       // The spec says the offsets should be in ascending order, however
2101       // this is not true for some fonts or they use the offset of 0 to mark a
2102       // glyph as missing. OTS requires the offsets to be in order and not to
2103       // be zero, so we must sort and rebuild the loca table and potentially
2104       // re-arrange the glyf data.
2105       let i, j;
2106       const locaEntries = [];
2107       // There are numGlyphs + 1 loca table entries.
2108       for (i = 0, j = 0; i < numGlyphs + 1; i++, j += itemSize) {
2109         let offset = itemDecode(locaData, j);
2110         if (offset > oldGlyfDataLength) {
2111           offset = oldGlyfDataLength;
2112         }
2113         locaEntries.push({
2114           index: i,
2115           offset,
2116           endOffset: 0,
2117         });
2118       }
2119       locaEntries.sort((a, b) => a.offset - b.offset);
2120       // Now the offsets are sorted, calculate the end offset of each glyph.
2121       // The last loca entry's endOffset is not calculated since it's the end
2122       // of the data and will be stored on the previous entry's endOffset.
2123       for (i = 0; i < numGlyphs; i++) {
2124         locaEntries[i].endOffset = locaEntries[i + 1].offset;
2125       }
2126       // Re-sort so glyphs aren't out of order.
2127       locaEntries.sort((a, b) => a.index - b.index);
2128       // Calculate the endOffset of the "first" glyph correctly when there are
2129       // *multiple* empty ones at the start of the data (fixes issue14618.pdf).
2130       for (i = 0; i < numGlyphs; i++) {
2131         const { offset, endOffset } = locaEntries[i];
2132         if (offset !== 0 || endOffset !== 0) {
2133           break;
2134         }
2135         const nextOffset = locaEntries[i + 1].offset;
2136         if (nextOffset === 0) {
2137           continue;
2138         }
2139         locaEntries[i].endOffset = nextOffset;
2140         break;
2141       }
2142 
2143       // If the last offset is 0 in the loca table then we can't compute the
2144       // endOffset for the last glyph. So in such a case we set the endOffset
2145       // to the end of the data (fixes issue #17671).
2146       const last = locaEntries.at(-2);
2147       if (last.offset !== 0 && last.endOffset === 0) {
2148         last.endOffset = oldGlyfDataLength;
2149       }
2150 
2151       const missingGlyphs = Object.create(null);
2152       let writeOffset = 0;
2153       itemEncode(locaData, 0, writeOffset);
2154       for (i = 0, j = itemSize; i < numGlyphs; i++, j += itemSize) {
2155         const glyphProfile = sanitizeGlyph(
2156           oldGlyfData,
2157           locaEntries[i].offset,
2158           locaEntries[i].endOffset,
2159           newGlyfData,
2160           writeOffset,
2161           hintsValid
2162         );
2163         const newLength = glyphProfile.length;
2164         if (newLength === 0) {
2165           missingGlyphs[i] = true;
2166         }
2167         if (glyphProfile.sizeOfInstructions > maxSizeOfInstructions) {
2168           maxSizeOfInstructions = glyphProfile.sizeOfInstructions;
2169         }
2170         writeOffset += newLength;
2171         itemEncode(locaData, j, writeOffset);
2172       }
2173 
2174       if (writeOffset === 0) {
2175         // glyf table cannot be empty -- redoing the glyf and loca tables
2176         // to have single glyph with one point
2177         const simpleGlyph = new Uint8Array([
2178           0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 49, 0,
2179         ]);
2180         for (i = 0, j = itemSize; i < numGlyphsOut; i++, j += itemSize) {
2181           itemEncode(locaData, j, simpleGlyph.length);
2182         }
2183         glyf.data = simpleGlyph;
2184       } else if (dupFirstEntry) {
2185         // Browsers will not display a glyph at position 0. Typically glyph 0
2186         // is notdef, but a number of fonts put a valid glyph there so it must
2187         // be duplicated and appended.
2188         const firstEntryLength = itemDecode(locaData, itemSize);
2189         if (newGlyfData.length > firstEntryLength + writeOffset) {
2190           glyf.data = newGlyfData.subarray(0, firstEntryLength + writeOffset);
2191         } else {
2192           glyf.data = new Uint8Array(firstEntryLength + writeOffset);
2193           glyf.data.set(newGlyfData.subarray(0, writeOffset));
2194         }
2195         glyf.data.set(newGlyfData.subarray(0, firstEntryLength), writeOffset);
2196         itemEncode(
2197           loca.data,
2198           locaData.length - itemSize,
2199           writeOffset + firstEntryLength
2200         );
2201       } else {
2202         glyf.data = newGlyfData.subarray(0, writeOffset);
2203       }
2204       return {
2205         missingGlyphs,
2206         maxSizeOfInstructions,
2207       };
2208     }
2209 
2210     function readPostScriptTable(post, propertiesObj, maxpNumGlyphs) {
2211       const start = (font.start || 0) + post.offset;
2212       font.pos = start;
2213 
2214       const length = post.length,
2215         end = start + length;
2216       const version = font.getInt32();
2217       // skip rest to the tables
2218       font.skip(28);
2219 
2220       let glyphNames;
2221       let valid = true;
2222       let i;
2223 
2224       switch (version) {
2225         case 0x00010000:
2226           glyphNames = MacStandardGlyphOrdering;
2227           break;
2228         case 0x00020000:
2229           const numGlyphs = font.getUint16();
2230           if (numGlyphs !== maxpNumGlyphs) {
2231             valid = false;
2232             break;
2233           }
2234           const glyphNameIndexes = [];
2235           for (i = 0; i < numGlyphs; ++i) {
2236             const index = font.getUint16();
2237             if (index >= 32768) {
2238               valid = false;
2239               break;
2240             }
2241             glyphNameIndexes.push(index);
2242           }
2243           if (!valid) {
2244             break;
2245           }
2246           const customNames = [],
2247             strBuf = [];
2248           while (font.pos < end) {
2249             const stringLength = font.getByte();
2250             strBuf.length = stringLength;
2251             for (i = 0; i < stringLength; ++i) {
2252               strBuf[i] = String.fromCharCode(font.getByte());
2253             }
2254             customNames.push(strBuf.join(""));
2255           }
2256           glyphNames = [];
2257           for (i = 0; i < numGlyphs; ++i) {
2258             const j = glyphNameIndexes[i];
2259             if (j < 258) {
2260               glyphNames.push(MacStandardGlyphOrdering[j]);
2261               continue;
2262             }
2263             glyphNames.push(customNames[j - 258]);
2264           }
2265           break;
2266         case 0x00030000:
2267           break;
2268         default:
2269           warn("Unknown/unsupported post table version " + version);
2270           valid = false;
2271           if (propertiesObj.defaultEncoding) {
2272             glyphNames = propertiesObj.defaultEncoding;
2273           }
2274           break;
2275       }
2276       propertiesObj.glyphNames = glyphNames;
2277       return valid;
2278     }
2279 
2280     function readNameTable(nameTable) {
2281       const start = (font.start || 0) + nameTable.offset;
2282       font.pos = start;
2283 
2284       const names = [[], []],
2285         records = [];
2286       const length = nameTable.length,
2287         end = start + length;
2288       const format = font.getUint16();
2289       const FORMAT_0_HEADER_LENGTH = 6;
2290       if (format !== 0 || length < FORMAT_0_HEADER_LENGTH) {
2291         // unsupported name table format or table "too" small
2292         return [names, records];
2293       }
2294       const numRecords = font.getUint16();
2295       const stringsStart = font.getUint16();
2296       const NAME_RECORD_LENGTH = 12;
2297       let i, ii;
2298 
2299       for (i = 0; i < numRecords && font.pos + NAME_RECORD_LENGTH <= end; i++) {
2300         const r = {
2301           platform: font.getUint16(),
2302           encoding: font.getUint16(),
2303           language: font.getUint16(),
2304           name: font.getUint16(),
2305           length: font.getUint16(),
2306           offset: font.getUint16(),
2307         };
2308         // using only Macintosh and Windows platform/encoding names
2309         if (isMacNameRecord(r) || isWinNameRecord(r)) {
2310           records.push(r);
2311         }
2312       }
2313       for (i = 0, ii = records.length; i < ii; i++) {
2314         const record = records[i];
2315         if (record.length <= 0) {
2316           continue; // Nothing to process, ignoring.
2317         }
2318         const pos = start + stringsStart + record.offset;
2319         if (pos + record.length > end) {
2320           continue; // outside of name table, ignoring
2321         }
2322         font.pos = pos;
2323         const nameIndex = record.name;
2324         if (record.encoding) {
2325           // unicode
2326           let str = "";
2327           for (let j = 0, jj = record.length; j < jj; j += 2) {
2328             str += String.fromCharCode(font.getUint16());
2329           }
2330           names[1][nameIndex] = str;
2331         } else {
2332           names[0][nameIndex] = font.getString(record.length);
2333         }
2334       }
2335       return [names, records];
2336     }
2337 
2338     // prettier-ignore
2339     const TTOpsStackDeltas = [
2340       0, 0, 0, 0, 0, 0, 0, 0, -2, -2, -2, -2, 0, 0, -2, -5,
2341       -1, -1, -1, -1, -1, -1, -1, -1, 0, 0, -1, 0, -1, -1, -1, -1,
2342       1, -1, -999, 0, 1, 0, -1, -2, 0, -1, -2, -1, -1, 0, -1, -1,
2343       0, 0, -999, -999, -1, -1, -1, -1, -2, -999, -2, -2, -999, 0, -2, -2,
2344       0, 0, -2, 0, -2, 0, 0, 0, -2, -1, -1, 1, 1, 0, 0, -1,
2345       -1, -1, -1, -1, -1, -1, 0, 0, -1, 0, -1, -1, 0, -999, -1, -1,
2346       -1, -1, -1, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
2347       -2, -999, -999, -999, -999, -999, -1, -1, -2, -2, 0, 0, 0, 0, -1, -1,
2348       -999, -2, -2, 0, 0, -1, -2, -2, 0, 0, 0, -1, -1, -1, -2];
2349     // 0xC0-DF == -1 and 0xE0-FF == -2
2350 
2351     function sanitizeTTProgram(table, ttContext) {
2352       let data = table.data;
2353       let i = 0,
2354         j,
2355         n,
2356         b,
2357         funcId,
2358         pc,
2359         lastEndf = 0,
2360         lastDeff = 0;
2361       const stack = [];
2362       const callstack = [];
2363       const functionsCalled = [];
2364       let tooComplexToFollowFunctions = ttContext.tooComplexToFollowFunctions;
2365       let inFDEF = false,
2366         ifLevel = 0,
2367         inELSE = 0;
2368       for (let ii = data.length; i < ii; ) {
2369         const op = data[i++];
2370         // The TrueType instruction set docs can be found at
2371         // https://developer.apple.com/fonts/TTRefMan/RM05/Chap5.html
2372         if (op === 0x40) {
2373           // NPUSHB - pushes n bytes
2374           n = data[i++];
2375           if (inFDEF || inELSE) {
2376             i += n;
2377           } else {
2378             for (j = 0; j < n; j++) {
2379               stack.push(data[i++]);
2380             }
2381           }
2382         } else if (op === 0x41) {
2383           // NPUSHW - pushes n words
2384           n = data[i++];
2385           if (inFDEF || inELSE) {
2386             i += n * 2;
2387           } else {
2388             for (j = 0; j < n; j++) {
2389               b = data[i++];
2390               stack.push((b << 8) | data[i++]);
2391             }
2392           }
2393         } else if ((op & 0xf8) === 0xb0) {
2394           // PUSHB - pushes bytes
2395           n = op - 0xb0 + 1;
2396           if (inFDEF || inELSE) {
2397             i += n;
2398           } else {
2399             for (j = 0; j < n; j++) {
2400               stack.push(data[i++]);
2401             }
2402           }
2403         } else if ((op & 0xf8) === 0xb8) {
2404           // PUSHW - pushes words
2405           n = op - 0xb8 + 1;
2406           if (inFDEF || inELSE) {
2407             i += n * 2;
2408           } else {
2409             for (j = 0; j < n; j++) {
2410               b = data[i++];
2411               stack.push(signedInt16(b, data[i++]));
2412             }
2413           }
2414         } else if (op === 0x2b && !tooComplexToFollowFunctions) {
2415           // CALL
2416           if (!inFDEF && !inELSE) {
2417             // collecting information about which functions are used
2418             funcId = stack.at(-1);
2419             if (isNaN(funcId)) {
2420               info("TT: CALL empty stack (or invalid entry).");
2421             } else {
2422               ttContext.functionsUsed[funcId] = true;
2423               if (funcId in ttContext.functionsStackDeltas) {
2424                 const newStackLength =
2425                   stack.length + ttContext.functionsStackDeltas[funcId];
2426                 if (newStackLength < 0) {
2427                   warn("TT: CALL invalid functions stack delta.");
2428                   ttContext.hintsValid = false;
2429                   return;
2430                 }
2431                 stack.length = newStackLength;
2432               } else if (
2433                 funcId in ttContext.functionsDefined &&
2434                 !functionsCalled.includes(funcId)
2435               ) {
2436                 callstack.push({ data, i, stackTop: stack.length - 1 });
2437                 functionsCalled.push(funcId);
2438                 pc = ttContext.functionsDefined[funcId];
2439                 if (!pc) {
2440                   warn("TT: CALL non-existent function");
2441                   ttContext.hintsValid = false;
2442                   return;
2443                 }
2444                 data = pc.data;
2445                 i = pc.i;
2446               }
2447             }
2448           }
2449         } else if (op === 0x2c && !tooComplexToFollowFunctions) {
2450           // FDEF
2451           if (inFDEF || inELSE) {
2452             warn("TT: nested FDEFs not allowed");
2453             tooComplexToFollowFunctions = true;
2454           }
2455           inFDEF = true;
2456           // collecting information about which functions are defined
2457           lastDeff = i;
2458           funcId = stack.pop();
2459           ttContext.functionsDefined[funcId] = { data, i };
2460         } else if (op === 0x2d) {
2461           // ENDF - end of function
2462           if (inFDEF) {
2463             inFDEF = false;
2464             lastEndf = i;
2465           } else {
2466             pc = callstack.pop();
2467             if (!pc) {
2468               warn("TT: ENDF bad stack");
2469               ttContext.hintsValid = false;
2470               return;
2471             }
2472             funcId = functionsCalled.pop();
2473             data = pc.data;
2474             i = pc.i;
2475             ttContext.functionsStackDeltas[funcId] = stack.length - pc.stackTop;
2476           }
2477         } else if (op === 0x89) {
2478           // IDEF - instruction definition
2479           if (inFDEF || inELSE) {
2480             warn("TT: nested IDEFs not allowed");
2481             tooComplexToFollowFunctions = true;
2482           }
2483           inFDEF = true;
2484           // recording it as a function to track ENDF
2485           lastDeff = i;
2486         } else if (op === 0x58) {
2487           // IF
2488           ++ifLevel;
2489         } else if (op === 0x1b) {
2490           // ELSE
2491           inELSE = ifLevel;
2492         } else if (op === 0x59) {
2493           // EIF
2494           if (inELSE === ifLevel) {
2495             inELSE = 0;
2496           }
2497           --ifLevel;
2498         } else if (op === 0x1c) {
2499           // JMPR
2500           if (!inFDEF && !inELSE) {
2501             const offset = stack.at(-1);
2502             // only jumping forward to prevent infinite loop
2503             if (offset > 0) {
2504               i += offset - 1;
2505             }
2506           }
2507         }
2508         // Adjusting stack not extactly, but just enough to get function id
2509         if (!inFDEF && !inELSE) {
2510           let stackDelta = 0;
2511           if (op <= 0x8e) {
2512             stackDelta = TTOpsStackDeltas[op];
2513           } else if (op >= 0xc0 && op <= 0xdf) {
2514             stackDelta = -1;
2515           } else if (op >= 0xe0) {
2516             stackDelta = -2;
2517           }
2518           if (op >= 0x71 && op <= 0x75) {
2519             n = stack.pop();
2520             if (!isNaN(n)) {
2521               stackDelta = -n * 2;
2522             }
2523           }
2524           while (stackDelta < 0 && stack.length > 0) {
2525             stack.pop();
2526             stackDelta++;
2527           }
2528           while (stackDelta > 0) {
2529             stack.push(NaN); // pushing any number into stack
2530             stackDelta--;
2531           }
2532         }
2533       }
2534       ttContext.tooComplexToFollowFunctions = tooComplexToFollowFunctions;
2535       const content = [data];
2536       if (i > data.length) {
2537         content.push(new Uint8Array(i - data.length));
2538       }
2539       if (lastDeff > lastEndf) {
2540         warn("TT: complementing a missing function tail");
2541         // new function definition started, but not finished
2542         // complete function by [CLEAR, ENDF]
2543         content.push(new Uint8Array([0x22, 0x2d]));
2544       }
2545       foldTTTable(table, content);
2546     }
2547 
2548     function checkInvalidFunctions(ttContext, maxFunctionDefs) {
2549       if (ttContext.tooComplexToFollowFunctions) {
2550         return;
2551       }
2552       if (ttContext.functionsDefined.length > maxFunctionDefs) {
2553         warn("TT: more functions defined than expected");
2554         ttContext.hintsValid = false;
2555         return;
2556       }
2557       for (let j = 0, jj = ttContext.functionsUsed.length; j < jj; j++) {
2558         if (j > maxFunctionDefs) {
2559           warn("TT: invalid function id: " + j);
2560           ttContext.hintsValid = false;
2561           return;
2562         }
2563         if (ttContext.functionsUsed[j] && !ttContext.functionsDefined[j]) {
2564           warn("TT: undefined function: " + j);
2565           ttContext.hintsValid = false;
2566           return;
2567         }
2568       }
2569     }
2570 
2571     function foldTTTable(table, content) {
2572       if (content.length > 1) {
2573         // concatenating the content items
2574         let newLength = 0;
2575         let j, jj;
2576         for (j = 0, jj = content.length; j < jj; j++) {
2577           newLength += content[j].length;
2578         }
2579         newLength = (newLength + 3) & ~3;
2580         const result = new Uint8Array(newLength);
2581         let pos = 0;
2582         for (j = 0, jj = content.length; j < jj; j++) {
2583           result.set(content[j], pos);
2584           pos += content[j].length;
2585         }
2586         table.data = result;
2587         table.length = newLength;
2588       }
2589     }
2590 
2591     function sanitizeTTPrograms(fpgm, prep, cvt, maxFunctionDefs) {
2592       const ttContext = {
2593         functionsDefined: [],
2594         functionsUsed: [],
2595         functionsStackDeltas: [],
2596         tooComplexToFollowFunctions: false,
2597         hintsValid: true,
2598       };
2599       if (fpgm) {
2600         sanitizeTTProgram(fpgm, ttContext);
2601       }
2602       if (prep) {
2603         sanitizeTTProgram(prep, ttContext);
2604       }
2605       if (fpgm) {
2606         checkInvalidFunctions(ttContext, maxFunctionDefs);
2607       }
2608       if (cvt && cvt.length & 1) {
2609         const cvtData = new Uint8Array(cvt.length + 1);
2610         cvtData.set(cvt.data);
2611         cvt.data = cvtData;
2612       }
2613       return ttContext.hintsValid;
2614     }
2615 
2616     // The following steps modify the original font data, making copy
2617     font = new Stream(new Uint8Array(font.getBytes()));
2618 
2619     let header, tables;
2620     if (isTrueTypeCollectionFile(font)) {
2621       const ttcData = readTrueTypeCollectionData(font, this.name);
2622       header = ttcData.header;
2623       tables = ttcData.tables;
2624     } else {
2625       header = readOpenTypeHeader(font);
2626       tables = readTables(font, header.numTables);
2627     }
2628     let cff, cffFile;
2629 
2630     const isTrueType = !tables["CFF "];
2631     if (!isTrueType) {
2632       const isComposite =
2633         properties.composite &&
2634         (properties.cidToGidMap?.length > 0 ||
2635           !(properties.cMap instanceof IdentityCMap));
2636       // OpenType font (skip composite fonts with non-default glyph mapping).
2637       if (
2638         (header.version === "OTTO" && !isComposite) ||
2639         !tables.head ||
2640         !tables.hhea ||
2641         !tables.maxp ||
2642         !tables.post
2643       ) {
2644         // No major tables: throwing everything at `CFFFont`.
2645         cffFile = new Stream(tables["CFF "].data);
2646         cff = new CFFFont(cffFile, properties);
2647 
2648         adjustWidths(properties);
2649 
2650         return this.convert(name, cff, properties);
2651       }
2652 
2653       delete tables.glyf;
2654       delete tables.loca;
2655       delete tables.fpgm;
2656       delete tables.prep;
2657       delete tables["cvt "];
2658       this.isOpenType = true;
2659     } else {
2660       if (!tables.loca) {
2661         throw new FormatError('Required "loca" table is not found');
2662       }
2663       if (!tables.glyf) {
2664         warn('Required "glyf" table is not found -- trying to recover.');
2665         // Note: We use `sanitizeGlyphLocations` to add dummy glyf data below.
2666         tables.glyf = {
2667           tag: "glyf",
2668           data: new Uint8Array(0),
2669         };
2670       }
2671       this.isOpenType = false;
2672     }
2673 
2674     if (!tables.maxp) {
2675       throw new FormatError('Required "maxp" table is not found');
2676     }
2677 
2678     font.pos = (font.start || 0) + tables.maxp.offset;
2679     let version = font.getInt32();
2680     const numGlyphs = font.getUint16();
2681 
2682     if (version !== 0x00010000 && version !== 0x00005000) {
2683       // https://learn.microsoft.com/en-us/typography/opentype/spec/maxp
2684       if (tables.maxp.length === 6) {
2685         version = 0x0005000;
2686       } else if (tables.maxp.length >= 32) {
2687         version = 0x00010000;
2688       } else {
2689         throw new FormatError(`"maxp" table has a wrong version number`);
2690       }
2691       writeUint32(tables.maxp.data, 0, version);
2692     }
2693 
2694     if (properties.scaleFactors?.length === numGlyphs && isTrueType) {
2695       const { scaleFactors } = properties;
2696       const isGlyphLocationsLong = int16(
2697         tables.head.data[50],
2698         tables.head.data[51]
2699       );
2700 
2701       const glyphs = new GlyfTable({
2702         glyfTable: tables.glyf.data,
2703         isGlyphLocationsLong,
2704         locaTable: tables.loca.data,
2705         numGlyphs,
2706       });
2707       glyphs.scale(scaleFactors);
2708 
2709       const { glyf, loca, isLocationLong } = glyphs.write();
2710       tables.glyf.data = glyf;
2711       tables.loca.data = loca;
2712 
2713       if (isLocationLong !== !!isGlyphLocationsLong) {
2714         tables.head.data[50] = 0;
2715         tables.head.data[51] = isLocationLong ? 1 : 0;
2716       }
2717 
2718       const metrics = tables.hmtx.data;
2719 
2720       for (let i = 0; i < numGlyphs; i++) {
2721         const j = 4 * i;
2722         const advanceWidth = Math.round(
2723           scaleFactors[i] * int16(metrics[j], metrics[j + 1])
2724         );
2725         metrics[j] = (advanceWidth >> 8) & 0xff;
2726         metrics[j + 1] = advanceWidth & 0xff;
2727         const lsb = Math.round(
2728           scaleFactors[i] * signedInt16(metrics[j + 2], metrics[j + 3])
2729         );
2730         writeSignedInt16(metrics, j + 2, lsb);
2731       }
2732     }
2733 
2734     // Glyph 0 is duplicated and appended.
2735     let numGlyphsOut = numGlyphs + 1;
2736     let dupFirstEntry = true;
2737     if (numGlyphsOut > 0xffff) {
2738       dupFirstEntry = false;
2739       numGlyphsOut = numGlyphs;
2740       warn("Not enough space in glyfs to duplicate first glyph.");
2741     }
2742     let maxFunctionDefs = 0;
2743     let maxSizeOfInstructions = 0;
2744     if (version >= 0x00010000 && tables.maxp.length >= 32) {
2745       // maxZones can be invalid
2746       font.pos += 8;
2747       const maxZones = font.getUint16();
2748       if (maxZones > 2) {
2749         // reset to 2 if font has invalid maxZones
2750         tables.maxp.data[14] = 0;
2751         tables.maxp.data[15] = 2;
2752       }
2753       font.pos += 4;
2754       maxFunctionDefs = font.getUint16();
2755       font.pos += 4;
2756       maxSizeOfInstructions = font.getUint16();
2757     }
2758 
2759     tables.maxp.data[4] = numGlyphsOut >> 8;
2760     tables.maxp.data[5] = numGlyphsOut & 255;
2761 
2762     const hintsValid = sanitizeTTPrograms(
2763       tables.fpgm,
2764       tables.prep,
2765       tables["cvt "],
2766       maxFunctionDefs
2767     );
2768     if (!hintsValid) {
2769       delete tables.fpgm;
2770       delete tables.prep;
2771       delete tables["cvt "];
2772     }
2773 
2774     // Ensure the hmtx table contains the advance width and
2775     // sidebearings information for numGlyphs in the maxp table
2776     sanitizeMetrics(
2777       font,
2778       tables.hhea,
2779       tables.hmtx,
2780       tables.head,
2781       numGlyphsOut,
2782       dupFirstEntry
2783     );
2784 
2785     if (!tables.head) {
2786       throw new FormatError('Required "head" table is not found');
2787     }
2788 
2789     sanitizeHead(tables.head, numGlyphs, isTrueType ? tables.loca.length : 0);
2790 
2791     let missingGlyphs = Object.create(null);
2792     if (isTrueType) {
2793       const isGlyphLocationsLong = int16(
2794         tables.head.data[50],
2795         tables.head.data[51]
2796       );
2797       const glyphsInfo = sanitizeGlyphLocations(
2798         tables.loca,
2799         tables.glyf,
2800         numGlyphs,
2801         isGlyphLocationsLong,
2802         hintsValid,
2803         dupFirstEntry,
2804         maxSizeOfInstructions
2805       );
2806       missingGlyphs = glyphsInfo.missingGlyphs;
2807 
2808       // Some fonts have incorrect maxSizeOfInstructions values, so we use
2809       // the computed value instead.
2810       if (version >= 0x00010000 && tables.maxp.length >= 32) {
2811         tables.maxp.data[26] = glyphsInfo.maxSizeOfInstructions >> 8;
2812         tables.maxp.data[27] = glyphsInfo.maxSizeOfInstructions & 255;
2813       }
2814     }
2815     if (!tables.hhea) {
2816       throw new FormatError('Required "hhea" table is not found');
2817     }
2818 
2819     // Sanitizer reduces the glyph advanceWidth to the maxAdvanceWidth
2820     // Sometimes it's 0. That needs to be fixed
2821     if (tables.hhea.data[10] === 0 && tables.hhea.data[11] === 0) {
2822       tables.hhea.data[10] = 0xff;
2823       tables.hhea.data[11] = 0xff;
2824     }
2825 
2826     // Extract some more font properties from the OpenType head and
2827     // hhea tables; yMin and descent value are always negative.
2828     const metricsOverride = {
2829       unitsPerEm: int16(tables.head.data[18], tables.head.data[19]),
2830       yMax: signedInt16(tables.head.data[42], tables.head.data[43]),
2831       yMin: signedInt16(tables.head.data[38], tables.head.data[39]),
2832       ascent: signedInt16(tables.hhea.data[4], tables.hhea.data[5]),
2833       descent: signedInt16(tables.hhea.data[6], tables.hhea.data[7]),
2834       lineGap: signedInt16(tables.hhea.data[8], tables.hhea.data[9]),
2835     };
2836 
2837     // PDF FontDescriptor metrics lie -- using data from actual font.
2838     this.ascent = metricsOverride.ascent / metricsOverride.unitsPerEm;
2839     this.descent = metricsOverride.descent / metricsOverride.unitsPerEm;
2840     this.lineGap = metricsOverride.lineGap / metricsOverride.unitsPerEm;
2841 
2842     if (this.cssFontInfo?.lineHeight) {
2843       this.lineHeight = this.cssFontInfo.metrics.lineHeight;
2844       this.lineGap = this.cssFontInfo.metrics.lineGap;
2845     } else {
2846       this.lineHeight = this.ascent - this.descent + this.lineGap;
2847     }
2848 
2849     // The 'post' table has glyphs names.
2850     if (tables.post) {
2851       readPostScriptTable(tables.post, properties, numGlyphs);
2852     }
2853 
2854     // The original 'post' table is not needed, replace it.
2855     tables.post = {
2856       tag: "post",
2857       data: createPostTable(properties),
2858     };
2859 
2860     const charCodeToGlyphId = Object.create(null);
2861 
2862     // Helper function to try to skip mapping of empty glyphs.
2863     function hasGlyph(glyphId) {
2864       return !missingGlyphs[glyphId];
2865     }
2866 
2867     if (properties.composite) {
2868       const cidToGidMap = properties.cidToGidMap || [];
2869       const isCidToGidMapEmpty = cidToGidMap.length === 0;
2870 
2871       properties.cMap.forEach(function (charCode, cid) {
2872         if (typeof cid === "string") {
2873           cid = convertCidString(charCode, cid, /* shouldThrow = */ true);
2874         }
2875         if (cid > 0xffff) {
2876           throw new FormatError("Max size of CID is 65,535");
2877         }
2878         let glyphId = -1;
2879         if (isCidToGidMapEmpty) {
2880           glyphId = cid;
2881         } else if (cidToGidMap[cid] !== undefined) {
2882           glyphId = cidToGidMap[cid];
2883         }
2884 
2885         if (glyphId >= 0 && glyphId < numGlyphs && hasGlyph(glyphId)) {
2886           charCodeToGlyphId[charCode] = glyphId;
2887         }
2888       });
2889     } else {
2890       // Most of the following logic in this code branch is based on the
2891       // 9.6.6.4 of the PDF spec.
2892       const cmapTable = readCmapTable(
2893         tables.cmap,
2894         font,
2895         this.isSymbolicFont,
2896         properties.hasEncoding
2897       );
2898       const cmapPlatformId = cmapTable.platformId;
2899       const cmapEncodingId = cmapTable.encodingId;
2900       const cmapMappings = cmapTable.mappings;
2901       let baseEncoding = [],
2902         forcePostTable = false;
2903       if (
2904         properties.hasEncoding &&
2905         (properties.baseEncodingName === "MacRomanEncoding" ||
2906           properties.baseEncodingName === "WinAnsiEncoding")
2907       ) {
2908         baseEncoding = getEncoding(properties.baseEncodingName);
2909       }
2910 
2911       // If the font has an encoding and is not symbolic then follow the rules
2912       // in section 9.6.6.4 of the spec on how to map 3,1 and 1,0 cmaps.
2913       if (
2914         properties.hasEncoding &&
2915         !this.isSymbolicFont &&
2916         ((cmapPlatformId === 3 && cmapEncodingId === 1) ||
2917           (cmapPlatformId === 1 && cmapEncodingId === 0))
2918       ) {
2919         const glyphsUnicodeMap = getGlyphsUnicode();
2920         for (let charCode = 0; charCode < 256; charCode++) {
2921           let glyphName;
2922           if (this.differences[charCode] !== undefined) {
2923             glyphName = this.differences[charCode];
2924           } else if (baseEncoding.length && baseEncoding[charCode] !== "") {
2925             glyphName = baseEncoding[charCode];
2926           } else {
2927             glyphName = StandardEncoding[charCode];
2928           }
2929           if (!glyphName) {
2930             continue;
2931           }
2932           // Ensure that non-standard glyph names are resolved to valid ones.
2933           const standardGlyphName = recoverGlyphName(
2934             glyphName,
2935             glyphsUnicodeMap
2936           );
2937 
2938           let unicodeOrCharCode;
2939           if (cmapPlatformId === 3 && cmapEncodingId === 1) {
2940             unicodeOrCharCode = glyphsUnicodeMap[standardGlyphName];
2941           } else if (cmapPlatformId === 1 && cmapEncodingId === 0) {
2942             // TODO: the encoding needs to be updated with mac os table.
2943             unicodeOrCharCode = MacRomanEncoding.indexOf(standardGlyphName);
2944           }
2945 
2946           if (unicodeOrCharCode === undefined) {
2947             // Not a valid glyph name, fallback to using the /ToUnicode map
2948             // when no post-table exists (fixes issue13316_reduced.pdf).
2949             if (
2950               !properties.glyphNames &&
2951               properties.hasIncludedToUnicodeMap &&
2952               !(this.toUnicode instanceof IdentityToUnicodeMap)
2953             ) {
2954               const unicode = this.toUnicode.get(charCode);
2955               if (unicode) {
2956                 unicodeOrCharCode = unicode.codePointAt(0);
2957               }
2958             }
2959 
2960             if (unicodeOrCharCode === undefined) {
2961               continue; // No valid glyph mapping found.
2962             }
2963           }
2964 
2965           for (const mapping of cmapMappings) {
2966             if (mapping.charCode !== unicodeOrCharCode) {
2967               continue;
2968             }
2969             charCodeToGlyphId[charCode] = mapping.glyphId;
2970             break;
2971           }
2972         }
2973       } else if (cmapPlatformId === 0) {
2974         // Default Unicode semantics, use the charcodes as is.
2975         for (const mapping of cmapMappings) {
2976           charCodeToGlyphId[mapping.charCode] = mapping.glyphId;
2977         }
2978         // Always prefer the BaseEncoding/Differences arrays, when they exist
2979         // (fixes issue13433.pdf).
2980         forcePostTable = true;
2981       } else if (cmapPlatformId === 3 && cmapEncodingId === 0) {
2982         // When a (3, 0) cmap table is present, it is used instead but the
2983         // spec has special rules for char codes in the range of 0xF000 to
2984         // 0xF0FF and it says the (3, 0) table should map the values from
2985         // the (1, 0) table by prepending 0xF0 to the char codes. To reverse
2986         // this, the upper bits of the char code are cleared, but only for the
2987         // special range since some PDFs have char codes outside of this range
2988         // (e.g. 0x2013) which when masked would overwrite other values in the
2989         // cmap.
2990         for (const mapping of cmapMappings) {
2991           let charCode = mapping.charCode;
2992           if (charCode >= 0xf000 && charCode <= 0xf0ff) {
2993             charCode &= 0xff;
2994           }
2995           charCodeToGlyphId[charCode] = mapping.glyphId;
2996         }
2997       } else {
2998         // When there is only a (1, 0) cmap table, the char code is a single
2999         // byte and it is used directly as the char code.
3000         for (const mapping of cmapMappings) {
3001           charCodeToGlyphId[mapping.charCode] = mapping.glyphId;
3002         }
3003       }
3004 
3005       // Last, try to map any missing charcodes using the post table.
3006       if (
3007         properties.glyphNames &&
3008         (baseEncoding.length || this.differences.length)
3009       ) {
3010         for (let i = 0; i < 256; ++i) {
3011           if (!forcePostTable && charCodeToGlyphId[i] !== undefined) {
3012             continue;
3013           }
3014           const glyphName = this.differences[i] || baseEncoding[i];
3015           if (!glyphName) {
3016             continue;
3017           }
3018           const glyphId = properties.glyphNames.indexOf(glyphName);
3019           if (glyphId > 0 && hasGlyph(glyphId)) {
3020             charCodeToGlyphId[i] = glyphId;
3021           }
3022         }
3023       }
3024     }
3025 
3026     if (charCodeToGlyphId.length === 0) {
3027       // defines at least one glyph
3028       charCodeToGlyphId[0] = 0;
3029     }
3030 
3031     // Typically glyph 0 is duplicated and the mapping must be updated, but if
3032     // there isn't enough room to duplicate, the glyph id is left the same. In
3033     // this case, glyph 0 may not work correctly, but that is better than
3034     // having the whole font fail.
3035     let glyphZeroId = numGlyphsOut - 1;
3036     if (!dupFirstEntry) {
3037       glyphZeroId = 0;
3038     }
3039 
3040     // When `cssFontInfo` is set, the font is used to render text in the HTML
3041     // view (e.g. with Xfa) so nothing must be moved in the private use area.
3042     if (!properties.cssFontInfo) {
3043       // Converting glyphs and ids into font's cmap table
3044       const newMapping = adjustMapping(
3045         charCodeToGlyphId,
3046         hasGlyph,
3047         glyphZeroId,
3048         this.toUnicode
3049       );
3050       this.toFontChar = newMapping.toFontChar;
3051       tables.cmap = {
3052         tag: "cmap",
3053         data: createCmapTable(
3054           newMapping.charCodeToGlyphId,
3055           newMapping.toUnicodeExtraMap,
3056           numGlyphsOut
3057         ),
3058       };
3059 
3060       if (!tables["OS/2"] || !validateOS2Table(tables["OS/2"], font)) {
3061         tables["OS/2"] = {
3062           tag: "OS/2",
3063           data: createOS2Table(
3064             properties,
3065             newMapping.charCodeToGlyphId,
3066             metricsOverride
3067           ),
3068         };
3069       }
3070     }
3071 
3072     if (!isTrueType) {
3073       try {
3074         // Trying to repair CFF file
3075         cffFile = new Stream(tables["CFF "].data);
3076         const parser = new CFFParser(
3077           cffFile,
3078           properties,
3079           SEAC_ANALYSIS_ENABLED
3080         );
3081         cff = parser.parse();
3082         cff.duplicateFirstGlyph();
3083         const compiler = new CFFCompiler(cff);
3084         tables["CFF "].data = compiler.compile();
3085       } catch {
3086         warn("Failed to compile font " + properties.loadedName);
3087       }
3088     }
3089 
3090     // Re-creating 'name' table
3091     if (!tables.name) {
3092       tables.name = {
3093         tag: "name",
3094         data: createNameTable(this.name),
3095       };
3096     } else {
3097       // ... using existing 'name' table as prototype
3098       const [namePrototype, nameRecords] = readNameTable(tables.name);
3099 
3100       tables.name.data = createNameTable(name, namePrototype);
3101       this.psName = namePrototype[0][6] || null;
3102 
3103       if (!properties.composite) {
3104         // For TrueType fonts that do not include `ToUnicode` or `Encoding`
3105         // data, attempt to use the name-table to improve text selection.
3106         adjustTrueTypeToUnicode(properties, this.isSymbolicFont, nameRecords);
3107       }
3108     }
3109 
3110     const builder = new OpenTypeFileBuilder(header.version);
3111     for (const tableTag in tables) {
3112       builder.addTable(tableTag, tables[tableTag].data);
3113     }
3114     return builder.toArray();
3115   }
3116 
3117   convert(fontName, font, properties) {
3118     // TODO: Check the charstring widths to determine this.
3119     properties.fixedPitch = false;
3120 
3121     if (properties.builtInEncoding) {
3122       // For Type1 fonts that do not include either `ToUnicode` or `Encoding`
3123       // data, attempt to use the `builtInEncoding` to improve text selection.
3124       adjustType1ToUnicode(properties, properties.builtInEncoding);
3125     }
3126 
3127     // Type 1 fonts have a notdef inserted at the beginning, so glyph 0
3128     // becomes glyph 1. In a CFF font glyph 0 is appended to the end of the
3129     // char strings.
3130     let glyphZeroId = 1;
3131     if (font instanceof CFFFont) {
3132       glyphZeroId = font.numGlyphs - 1;
3133     }
3134     const mapping = font.getGlyphMapping(properties);
3135     let newMapping = null;
3136     let newCharCodeToGlyphId = mapping;
3137     let toUnicodeExtraMap = null;
3138 
3139     // When `cssFontInfo` is set, the font is used to render text in the HTML
3140     // view (e.g. with Xfa) so nothing must be moved in the private use area.
3141     if (!properties.cssFontInfo) {
3142       newMapping = adjustMapping(
3143         mapping,
3144         font.hasGlyphId.bind(font),
3145         glyphZeroId,
3146         this.toUnicode
3147       );
3148       this.toFontChar = newMapping.toFontChar;
3149       newCharCodeToGlyphId = newMapping.charCodeToGlyphId;
3150       toUnicodeExtraMap = newMapping.toUnicodeExtraMap;
3151     }
3152     const numGlyphs = font.numGlyphs;
3153 
3154     function getCharCodes(charCodeToGlyphId, glyphId) {
3155       let charCodes = null;
3156       for (const charCode in charCodeToGlyphId) {
3157         if (glyphId === charCodeToGlyphId[charCode]) {
3158           (charCodes ||= []).push(charCode | 0);
3159         }
3160       }
3161       return charCodes;
3162     }
3163 
3164     function createCharCode(charCodeToGlyphId, glyphId) {
3165       for (const charCode in charCodeToGlyphId) {
3166         if (glyphId === charCodeToGlyphId[charCode]) {
3167           return charCode | 0;
3168         }
3169       }
3170       newMapping.charCodeToGlyphId[newMapping.nextAvailableFontCharCode] =
3171         glyphId;
3172       return newMapping.nextAvailableFontCharCode++;
3173     }
3174 
3175     const seacs = font.seacs;
3176     if (newMapping && SEAC_ANALYSIS_ENABLED && seacs?.length) {
3177       const matrix = properties.fontMatrix || FONT_IDENTITY_MATRIX;
3178       const charset = font.getCharset();
3179       const seacMap = Object.create(null);
3180       for (let glyphId in seacs) {
3181         glyphId |= 0;
3182         const seac = seacs[glyphId];
3183         const baseGlyphName = StandardEncoding[seac[2]];
3184         const accentGlyphName = StandardEncoding[seac[3]];
3185         const baseGlyphId = charset.indexOf(baseGlyphName);
3186         const accentGlyphId = charset.indexOf(accentGlyphName);
3187         if (baseGlyphId < 0 || accentGlyphId < 0) {
3188           continue;
3189         }
3190         const accentOffset = {
3191           x: seac[0] * matrix[0] + seac[1] * matrix[2] + matrix[4],
3192           y: seac[0] * matrix[1] + seac[1] * matrix[3] + matrix[5],
3193         };
3194 
3195         const charCodes = getCharCodes(mapping, glyphId);
3196         if (!charCodes) {
3197           // There's no point in mapping it if the char code was never mapped
3198           // to begin with.
3199           continue;
3200         }
3201         for (const charCode of charCodes) {
3202           // Find a fontCharCode that maps to the base and accent glyphs.
3203           // If one doesn't exists, create it.
3204           const charCodeToGlyphId = newMapping.charCodeToGlyphId;
3205           const baseFontCharCode = createCharCode(
3206             charCodeToGlyphId,
3207             baseGlyphId
3208           );
3209           const accentFontCharCode = createCharCode(
3210             charCodeToGlyphId,
3211             accentGlyphId
3212           );
3213           seacMap[charCode] = {
3214             baseFontCharCode,
3215             accentFontCharCode,
3216             accentOffset,
3217           };
3218         }
3219       }
3220       properties.seacMap = seacMap;
3221     }
3222 
3223     const unitsPerEm = properties.fontMatrix
3224       ? 1 / Math.max(...properties.fontMatrix.slice(0, 4).map(Math.abs))
3225       : 1000;
3226 
3227     const builder = new OpenTypeFileBuilder("\x4F\x54\x54\x4F");
3228     // PostScript Font Program
3229     builder.addTable("CFF ", font.data);
3230     // OS/2 and Windows Specific metrics
3231     builder.addTable("OS/2", createOS2Table(properties, newCharCodeToGlyphId));
3232     // Character to glyphs mapping
3233     builder.addTable(
3234       "cmap",
3235       createCmapTable(newCharCodeToGlyphId, toUnicodeExtraMap, numGlyphs)
3236     );
3237     // Font header
3238     builder.addTable(
3239       "head",
3240       "\x00\x01\x00\x00" + // Version number
3241         "\x00\x00\x10\x00" + // fontRevision
3242         "\x00\x00\x00\x00" + // checksumAdjustement
3243         "\x5F\x0F\x3C\xF5" + // magicNumber
3244         "\x00\x00" + // Flags
3245         safeString16(unitsPerEm) + // unitsPerEM
3246         "\x00\x00\x00\x00\x9e\x0b\x7e\x27" + // creation date
3247         "\x00\x00\x00\x00\x9e\x0b\x7e\x27" + // modifification date
3248         "\x00\x00" + // xMin
3249         safeString16(properties.descent) + // yMin
3250         "\x0F\xFF" + // xMax
3251         safeString16(properties.ascent) + // yMax
3252         string16(properties.italicAngle ? 2 : 0) + // macStyle
3253         "\x00\x11" + // lowestRecPPEM
3254         "\x00\x00" + // fontDirectionHint
3255         "\x00\x00" + // indexToLocFormat
3256         "\x00\x00"
3257     ); // glyphDataFormat
3258 
3259     // Horizontal header
3260     builder.addTable(
3261       "hhea",
3262       "\x00\x01\x00\x00" + // Version number
3263         safeString16(properties.ascent) + // Typographic Ascent
3264         safeString16(properties.descent) + // Typographic Descent
3265         "\x00\x00" + // Line Gap
3266         "\xFF\xFF" + // advanceWidthMax
3267         "\x00\x00" + // minLeftSidebearing
3268         "\x00\x00" + // minRightSidebearing
3269         "\x00\x00" + // xMaxExtent
3270         safeString16(properties.capHeight) + // caretSlopeRise
3271         safeString16(Math.tan(properties.italicAngle) * properties.xHeight) + // caretSlopeRun
3272         "\x00\x00" + // caretOffset
3273         "\x00\x00" + // -reserved-
3274         "\x00\x00" + // -reserved-
3275         "\x00\x00" + // -reserved-
3276         "\x00\x00" + // -reserved-
3277         "\x00\x00" + // metricDataFormat
3278         string16(numGlyphs)
3279     ); // Number of HMetrics
3280 
3281     // Horizontal metrics
3282     builder.addTable(
3283       "hmtx",
3284       (function fontFieldsHmtx() {
3285         const charstrings = font.charstrings;
3286         const cffWidths = font.cff ? font.cff.widths : null;
3287         let hmtx = "\x00\x00\x00\x00"; // Fake .notdef
3288         for (let i = 1, ii = numGlyphs; i < ii; i++) {
3289           let width = 0;
3290           if (charstrings) {
3291             const charstring = charstrings[i - 1];
3292             width = "width" in charstring ? charstring.width : 0;
3293           } else if (cffWidths) {
3294             width = Math.ceil(cffWidths[i] || 0);
3295           }
3296           hmtx += string16(width) + string16(0);
3297         }
3298         return hmtx;
3299       })()
3300     );
3301 
3302     // Maximum profile
3303     builder.addTable(
3304       "maxp",
3305       "\x00\x00\x50\x00" + string16(numGlyphs) // Version number
3306     ); // Num of glyphs
3307 
3308     // Naming tables
3309     builder.addTable("name", createNameTable(fontName));
3310 
3311     // PostScript information
3312     builder.addTable("post", createPostTable(properties));
3313 
3314     return builder.toArray();
3315   }
3316 
3317   /**
3318    * @private
3319    */
3320   get _spaceWidth() {
3321     // trying to estimate space character width
3322     const possibleSpaceReplacements = ["space", "minus", "one", "i", "I"];
3323     let width;
3324     for (const glyphName of possibleSpaceReplacements) {
3325       // if possible, getting width by glyph name
3326       if (glyphName in this.widths) {
3327         width = this.widths[glyphName];
3328         break;
3329       }
3330       const glyphsUnicodeMap = getGlyphsUnicode();
3331       const glyphUnicode = glyphsUnicodeMap[glyphName];
3332       // finding the charcode via unicodeToCID map
3333       let charcode = 0;
3334       if (this.composite && this.cMap.contains(glyphUnicode)) {
3335         charcode = this.cMap.lookup(glyphUnicode);
3336 
3337         if (typeof charcode === "string") {
3338           charcode = convertCidString(glyphUnicode, charcode);
3339         }
3340       }
3341       // ... via toUnicode map
3342       if (!charcode && this.toUnicode) {
3343         charcode = this.toUnicode.charCodeOf(glyphUnicode);
3344       }
3345       // setting it to unicode if negative or undefined
3346       if (charcode <= 0) {
3347         charcode = glyphUnicode;
3348       }
3349       // trying to get width via charcode
3350       width = this.widths[charcode];
3351       if (width) {
3352         break; // the non-zero width found
3353       }
3354     }
3355     return shadow(this, "_spaceWidth", width || this.defaultWidth);
3356   }
3357 
3358   /**
3359    * @private
3360    */
3361   _charToGlyph(charcode, isSpace = false) {
3362     let glyph = this._glyphCache[charcode];
3363     // All `Glyph`-properties, except `isSpace` in multi-byte strings,
3364     // depend indirectly on the `charcode`.
3365     if (glyph?.isSpace === isSpace) {
3366       return glyph;
3367     }
3368     let fontCharCode, width, operatorListId;
3369 
3370     let widthCode = charcode;
3371     if (this.cMap?.contains(charcode)) {
3372       widthCode = this.cMap.lookup(charcode);
3373 
3374       if (typeof widthCode === "string") {
3375         widthCode = convertCidString(charcode, widthCode);
3376       }
3377     }
3378     width = this.widths[widthCode];
3379     if (typeof width !== "number") {
3380       width = this.defaultWidth;
3381     }
3382     const vmetric = this.vmetrics?.[widthCode];
3383 
3384     let unicode = this.toUnicode.get(charcode) || charcode;
3385     if (typeof unicode === "number") {
3386       unicode = String.fromCharCode(unicode);
3387     }
3388 
3389     let isInFont = this.toFontChar[charcode] !== undefined;
3390     // First try the toFontChar map, if it's not there then try falling
3391     // back to the char code.
3392     fontCharCode = this.toFontChar[charcode] || charcode;
3393     if (this.missingFile) {
3394       const glyphName =
3395         this.differences[charcode] || this.defaultEncoding[charcode];
3396       if (
3397         (glyphName === ".notdef" || glyphName === "") &&
3398         this.type === "Type1"
3399       ) {
3400         // .notdef glyphs should be invisible in non-embedded Type1 fonts, so
3401         // replace them with spaces.
3402         fontCharCode = 0x20;
3403 
3404         if (glyphName === "") {
3405           // Ensure that other relevant glyph properties are also updated
3406           // (fixes issue18059.pdf).
3407           width ||= this._spaceWidth;
3408           unicode = String.fromCharCode(fontCharCode);
3409         }
3410       }
3411       fontCharCode = mapSpecialUnicodeValues(fontCharCode);
3412     }
3413 
3414     if (this.isType3Font) {
3415       // Font char code in this case is actually a glyph name.
3416       operatorListId = fontCharCode;
3417     }
3418 
3419     let accent = null;
3420     if (this.seacMap?.[charcode]) {
3421       isInFont = true;
3422       const seac = this.seacMap[charcode];
3423       fontCharCode = seac.baseFontCharCode;
3424       accent = {
3425         fontChar: String.fromCodePoint(seac.accentFontCharCode),
3426         offset: seac.accentOffset,
3427       };
3428     }
3429 
3430     let fontChar = "";
3431     if (typeof fontCharCode === "number") {
3432       if (fontCharCode <= 0x10ffff) {
3433         fontChar = String.fromCodePoint(fontCharCode);
3434       } else {
3435         warn(`charToGlyph - invalid fontCharCode: ${fontCharCode}`);
3436       }
3437     }
3438 
3439     if (this.missingFile && this.vertical && fontChar.length === 1) {
3440       const vertical = getVerticalPresentationForm()[fontChar.charCodeAt(0)];
3441       if (vertical) {
3442         fontChar = unicode = String.fromCharCode(vertical);
3443       }
3444     }
3445 
3446     glyph = new Glyph(
3447       charcode,
3448       fontChar,
3449       unicode,
3450       accent,
3451       width,
3452       vmetric,
3453       operatorListId,
3454       isSpace,
3455       isInFont
3456     );
3457     return (this._glyphCache[charcode] = glyph);
3458   }
3459 
3460   charsToGlyphs(chars) {
3461     // If we translated this string before, just grab it from the cache.
3462     let glyphs = this._charsCache[chars];
3463     if (glyphs) {
3464       return glyphs;
3465     }
3466     glyphs = [];
3467 
3468     if (this.cMap) {
3469       // Composite fonts have multi-byte strings, convert the string from
3470       // single-byte to multi-byte.
3471       const c = Object.create(null),
3472         ii = chars.length;
3473       let i = 0;
3474       while (i < ii) {
3475         this.cMap.readCharCode(chars, i, c);
3476         const { charcode, length } = c;
3477         i += length;
3478         // Space is char with code 0x20 and length 1 in multiple-byte codes.
3479         const glyph = this._charToGlyph(
3480           charcode,
3481           length === 1 && chars.charCodeAt(i - 1) === 0x20
3482         );
3483         glyphs.push(glyph);
3484       }
3485     } else {
3486       for (let i = 0, ii = chars.length; i < ii; ++i) {
3487         const charcode = chars.charCodeAt(i);
3488         const glyph = this._charToGlyph(charcode, charcode === 0x20);
3489         glyphs.push(glyph);
3490       }
3491     }
3492 
3493     // Enter the translated string into the cache.
3494     return (this._charsCache[chars] = glyphs);
3495   }
3496 
3497   /**
3498    * Chars can have different sizes (depends on the encoding).
3499    * @param {String} a string encoded with font encoding.
3500    * @returns {Array<Array<number>>} the positions of each char in the string.
3501    */
3502   getCharPositions(chars) {
3503     // This function doesn't use a cache because
3504     // it's called only when saving or printing.
3505     const positions = [];
3506 
3507     if (this.cMap) {
3508       const c = Object.create(null);
3509       let i = 0;
3510       while (i < chars.length) {
3511         this.cMap.readCharCode(chars, i, c);
3512         const length = c.length;
3513         positions.push([i, i + length]);
3514         i += length;
3515       }
3516     } else {
3517       for (let i = 0, ii = chars.length; i < ii; ++i) {
3518         positions.push([i, i + 1]);
3519       }
3520     }
3521 
3522     return positions;
3523   }
3524 
3525   get glyphCacheValues() {
3526     return Object.values(this._glyphCache);
3527   }
3528 
3529   /**
3530    * Encode a js string using font encoding.
3531    * The resulting array contains an encoded string at even positions
3532    * (can be empty) and a non-encoded one at odd positions.
3533    * @param {String} a js string.
3534    * @returns {Array<String>} an array of encoded strings or non-encoded ones.
3535    */
3536   encodeString(str) {
3537     const buffers = [];
3538     const currentBuf = [];
3539 
3540     // buffers will contain: encoded, non-encoded, encoded, ...
3541     // currentBuf is pushed in buffers each time there is a change.
3542     // So when buffers.length is odd then the last string is an encoded one
3543     // and currentBuf contains non-encoded chars.
3544     const hasCurrentBufErrors = () => buffers.length % 2 === 1;
3545 
3546     const getCharCode =
3547       this.toUnicode instanceof IdentityToUnicodeMap
3548         ? unicode => this.toUnicode.charCodeOf(unicode)
3549         : unicode => this.toUnicode.charCodeOf(String.fromCodePoint(unicode));
3550 
3551     for (let i = 0, ii = str.length; i < ii; i++) {
3552       const unicode = str.codePointAt(i);
3553       if (unicode > 0xd7ff && (unicode < 0xe000 || unicode > 0xfffd)) {
3554         // unicode is represented by two uint16
3555         i++;
3556       }
3557       if (this.toUnicode) {
3558         const charCode = getCharCode(unicode);
3559         if (charCode !== -1) {
3560           if (hasCurrentBufErrors()) {
3561             buffers.push(currentBuf.join(""));
3562             currentBuf.length = 0;
3563           }
3564           const charCodeLength = this.cMap
3565             ? this.cMap.getCharCodeLength(charCode)
3566             : 1;
3567           for (let j = charCodeLength - 1; j >= 0; j--) {
3568             currentBuf.push(String.fromCharCode((charCode >> (8 * j)) & 0xff));
3569           }
3570           continue;
3571         }
3572       }
3573 
3574       // unicode can't be encoded
3575       if (!hasCurrentBufErrors()) {
3576         buffers.push(currentBuf.join(""));
3577         currentBuf.length = 0;
3578       }
3579       currentBuf.push(String.fromCodePoint(unicode));
3580     }
3581 
3582     buffers.push(currentBuf.join(""));
3583 
3584     return buffers;
3585   }
3586 }
3587 
3588 class ErrorFont {
3589   constructor(error) {
3590     this.error = error;
3591     this.loadedName = "g_font_error";
3592     this.missingFile = true;
3593   }
3594 
3595   charsToGlyphs() {
3596     return [];
3597   }
3598 
3599   encodeString(chars) {
3600     return [chars];
3601   }
3602 
3603   exportData() {
3604     return { error: this.error };
3605   }
3606 }
3607 
3608 export { ErrorFont, Font };
</code>

Test file:
<test_file>
File:
test/unit/api_spec.js
/* Copyright 2017 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import {
  AnnotationEditorType,
  AnnotationMode,
  AnnotationType,
  DrawOPS,
  ImageKind,
  InvalidPDFException,
  isNodeJS,
  objectSize,
  OPS,
  PasswordException,
  PasswordResponses,
  PermissionFlag,
  ResponseException,
  UnknownErrorException,
} from "../../src/shared/util.js";
import {
  buildGetDocumentParams,
  CMAP_URL,
  DefaultFileReaderFactory,
  getCrossOriginHostname,
  TEST_PDFS_PATH,
  TestPdfsServer,
} from "./test_utils.js";
import {
  fetchData as fetchDataDOM,
  PageViewport,
  RenderingCancelledException,
  StatTimer,
} from "../../src/display/display_utils.js";
import {
  getDocument,
  PDFDataRangeTransport,
  PDFDocumentLoadingTask,
  PDFDocumentProxy,
  PDFPageProxy,
  PDFWorker,
  RenderTask,
} from "../../src/display/api.js";
import { AutoPrintRegExp } from "../../web/ui_utils.js";
import { GlobalImageCache } from "../../src/core/image_utils.js";
import { GlobalWorkerOptions } from "../../src/display/worker_options.js";
import { Metadata } from "../../src/display/metadata.js";
const WORKER_SRC = "../../build/generic/build/pdf.worker.mjs";
</test_file>

Your task:
You are a software tester at pdf.js.
1. Examine the existing test file. You may reuse any imports, helpers or setup blocks it already has.
2. Write exactly one javascript test `it("...", async () => {...})` block.
3. Your test must fail on the code before the patch, and pass after, hence the test will verify that the patch resolves the issue.
4. The test must be self-contained and to-the-point.
5. If you need something new use only the provided imports (respect the paths exactly how they are given) by importing dynamically for compatibility with Node.js — no new dependencies. You can use the PDF file for testing as follows:
const { getDocument } = await import('../../src/display/api.js');
const { buildGetDocumentParams } = await import('./test_utils.js');
const loadingTask = getDocument(buildGetDocumentParams('issue19802.pdf'))
6. Return only the javascript code for the new `it(...)` block (no comments or explanations).

Example structure:
it("should <describe behavior>", async () => {
  const { example } = await import("../../src/core/example.js");
  <initialize required variables>;
  <define expected variable>;
  <generate actual variables>;
  <compare expected with actual>;
});

