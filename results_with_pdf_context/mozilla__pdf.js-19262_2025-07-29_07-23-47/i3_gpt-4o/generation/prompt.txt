Before you begin:
- Keep going until the job is completely solved — don’t stop halfway.
- If you’re unsure about the behavior, reread the provided patch carefully; do not hallucinate.
- Plan your approach before writing code by reflecting on whether the test truly fails before and passes after.

Issue:
<issue>
Arbitrary Javascript injection in PDF.js through FontMatrix
</issue>

Patch:
<patch>
diff --git a/src/core/font_renderer.js b/src/core/font_renderer.js
--- a/src/core/font_renderer.js
+++ b/src/core/font_renderer.js
@@ -14,6 +14,7 @@
  */
 
 import {
+  assert,
   bytesToString,
   FONT_IDENTITY_MATRIX,
   FormatError,
@@ -23,6 +24,7 @@ import {
 } from "../shared/util.js";
 import { CFFParser } from "./cff_parser.js";
 import { getGlyphsUnicode } from "./glyphlist.js";
+import { isNumberArray } from "./core_utils.js";
 import { StandardEncoding } from "./encodings.js";
 import { Stream } from "./stream.js";
 
@@ -834,6 +836,7 @@ class CompiledFont {
         warn("Invalid fd index for glyph index.");
       }
     }
+    assert(isNumberArray(fontMatrix, 6), "Expected a valid fontMatrix.");
 
     const cmds = new Commands();
     cmds.transform(fontMatrix.slice());


</patch>

Imports:
<imports>
Available Packages
Dev Dependencies:
- @babel/core: ^7.26.0
- @babel/preset-env: ^7.26.0
- @babel/runtime: ^7.26.0
- @fluent/bundle: ^0.18.0
- @fluent/dom: ^0.10.0
- @jazzer.js/core: ^2.1.0
- @metalsmith/layouts: ^2.7.0
- @metalsmith/markdown: ^1.10.0
- @napi-rs/canvas: ^0.1.65
- @types/node: ^22.10.2
- autoprefixer: ^10.4.20
- babel-loader: ^9.2.1
- caniuse-lite: ^1.0.30001690
- core-js: ^3.39.0
- eslint: ^9.17.0
- eslint-plugin-import: ^2.31.0
- eslint-plugin-jasmine: ^4.2.2
- eslint-plugin-json: ^4.0.1
- eslint-plugin-no-unsanitized: ^4.1.2
- eslint-plugin-perfectionist: ^4.3.0
- eslint-plugin-prettier: ^5.2.1
- eslint-plugin-unicorn: ^56.0.1
- globals: ^15.14.0
- gulp: ^5.0.0
- gulp-cli: ^3.0.0
- gulp-postcss: ^10.0.0
- gulp-rename: ^2.0.0
- gulp-replace: ^1.1.4
- gulp-zip: ^6.0.0
- highlight.js: ^11.11.0
- jasmine: ^5.5.0
- jsdoc: ^4.0.4
- jstransformer-nunjucks: ^1.2.0
- metalsmith: ^2.6.3
- metalsmith-html-relative: ^2.0.6
- ordered-read-streams: ^2.0.0
- pngjs: ^7.0.0
- postcss: ^8.4.49
- postcss-dark-theme-class: ^1.3.0
- postcss-dir-pseudo-class: ^9.0.1
- postcss-discard-comments: ^7.0.3
- postcss-nesting: ^13.0.1
- prettier: ^3.4.2
- puppeteer: ^23.11.1
- stylelint: ^16.12.0
- stylelint-prettier: ^5.0.2
- svglint: ^3.1.0
- terser-webpack-plugin: ^5.3.11
- tsc-alias: ^1.8.10
- ttest: ^4.0.0
- typescript: ^5.7.2
- vinyl: ^3.0.0
- webpack: ^5.97.1
- webpack-stream: ^7.0.0
- yargs: ^17.7.2

Engines:
- node: >=20

Available Relative Imports:
- `../../src/core/annotation.js`: Annotation, AnnotationBorderStyle, AnnotationFactory, MarkupAnnotation, getQuadPoints
- `../../src/core/bidi.js`: bidi
- `../../src/core/cff_parser.js`: CFFCharset, CFFCompiler, CFFFDSelect, CFFParser, CFFStrings
- `../../src/core/cmap.js`: CMap, CMapFactory, IdentityCMap
- `../../src/core/colorspace.js`: ColorSpace
- `../../src/core/core_utils.js`: arrayBuffersToBytes, encodeToXmlString, escapePDFName, escapeString, getInheritableProperty, getSizeInBytes, isAscii, isWhiteSpace, log2, numberToString, parseXFAPath, recoverJsURL, stringToUTF16HexString, stringToUTF16String, toRomanNumerals, validateCSSFont
- `../../src/core/crypto.js`: AES128Cipher, AES256Cipher, ARCFourCipher, CipherTransformFactory, PDF17, PDF20, calculateMD5, calculateSHA256, calculateSHA384, calculateSHA512
- `../../src/core/default_appearance.js`: createDefaultAppearance, parseAppearanceStream, parseDefaultAppearance
- `../../src/core/document.js`: PDFDocument, Page
- `../../src/core/encodings.js`: getEncoding
- `../../src/core/evaluator.js`: PartialEvaluator
- `../../src/core/flate_stream.js`: FlateStream
- `../../src/core/font_substitutions.js`: getFontSubstitution
- `../../src/core/fonts_utils.js`: SEAC_ANALYSIS_ENABLED
- `../../src/core/function.js`: PDFFunctionFactory, PostScriptCompiler, PostScriptEvaluator
- `../../src/core/glyphlist.js`: getDingbatsGlyphsUnicode, getGlyphsUnicode
- `../../src/core/image_utils.js`: GlobalImageCache, LocalColorSpaceCache
- `../../src/core/jbig2.js`: Jbig2Error, Jbig2Image
- `../../src/core/jpg.js`: JpegError, JpegImage
- `../../src/core/jpx.js`: JpxError, JpxImage
- `../../src/core/metadata_parser.js`: MetadataParser
- `../../src/core/operator_list.js`: OperatorList
- `../../src/core/parser.js`: Lexer, Linearization, Parser
- `../../src/core/predictor_stream.js`: PredictorStream
- `../../src/core/primitives.js`: Cmd, Dict, EOF, Name, Ref, RefSet, RefSetCache, isCmd, isDict, isName, isRefsEqual
- `../../src/core/ps_parser.js`: PostScriptLexer, PostScriptParser
- `../../src/core/stream.js`: NullStream, Stream, StringStream
- `../../src/core/type1_parser.js`: Type1Parser
- `../../src/core/unicode.js`: getCharUnicodeCategory, getUnicodeForGlyph, getUnicodeRangeFor, mapSpecialUnicodeValues
- `../../src/core/worker.js`: WorkerMessageHandler, WorkerTask
- `../../src/core/writer.js`: incrementalUpdate, writeChanges, writeDict
- `../../src/core/xfa/bind.js`: Binder
- `../../src/core/xfa/data.js`: DataHandler
- `../../src/core/xfa/factory.js`: XFAFactory
- `../../src/core/xfa/formcalc_lexer.js`: Lexer, TOKEN, Token
- `../../src/core/xfa/formcalc_parser.js`: Errors, Parser
- `../../src/core/xfa/parser.js`: XFAParser
- `../../src/core/xfa/som.js`: searchNode
- `../../src/core/xfa/symbol_utils.js`: $dump, $getChildren, $getChildrenByClass, $getChildrenByName, $text, $uid
- `../../src/core/xml_parser.js`: SimpleXMLParser, XMLParserBase
- `../../src/display/annotation_layer.js`: AnnotationLayer
- `../../src/display/annotation_storage.js`: AnnotationStorage
- `../../src/display/api.js`: DefaultCMapReaderFactory, DefaultCanvasFactory, DefaultStandardFontDataFactory, LoopbackPort, PDFDataRangeTransport, PDFDocumentLoadingTask, PDFDocumentProxy, PDFPageProxy, PDFWorker, RenderTask, build, getDocument, version
- `../../src/display/canvas_factory.js`: DOMCanvasFactory
- `../../src/display/display_utils.js`: OutputScale, PDFDateString, PageViewport, PixelsPerInch, RenderingCancelledException, StatTimer, fetchData, getFilenameFromUrl, getPdfFilenameFromUrl, getXfaPageViewport, isDataScheme, isPdfFile, isValidFetchUrl, noContextMenu, setLayerDimensions, stopEvent
- `../../src/display/draw_layer.js`: DrawLayer
- `../../src/display/editor/annotation_editor_layer.js`: AnnotationEditorLayer
- `../../src/display/editor/color_picker.js`: ColorPicker
- `../../src/display/editor/tools.js`: AnnotationEditorUIManager, CommandManager
- `../../src/display/fetch_stream.js`: PDFFetchStream
- `../../src/display/metadata.js`: Metadata
- `../../src/display/network.js`: PDFNetworkStream
- `../../src/display/network_utils.js`: createHeaders, createResponseStatusError, extractFilenameFromHeader, validateRangeRequestCapabilities, validateResponseStatus
- `../../src/display/node_stream.js`: PDFNodeStream
- `../../src/display/node_utils.js`: fetchData
- `../../src/display/svg_factory.js`: DOMSVGFactory
- `../../src/display/text_layer.js`: TextLayer
- `../../src/display/touch_manager.js`: TouchManager
- `../../src/display/worker_options.js`: GlobalWorkerOptions
- `../../src/display/xfa_layer.js`: XfaLayer
- `../../src/shared/message_handler.js`: MessageHandler
- `../../src/shared/murmurhash3.js`: MurmurHash3_64
- `../../src/shared/util.js`: AbortException, AnnotationBorderStyleType, AnnotationEditorParamsType, AnnotationEditorType, AnnotationFieldFlag, AnnotationFlag, AnnotationMode, AnnotationType, BaseException, FeatureTest, FormatError, ImageKind, InvalidPDFException, MissingPDFException, OPS, PasswordException, PasswordResponses, PermissionFlag, RenderingIntentFlag, UnexpectedResponseException, UnknownErrorException, Util, VerbosityLevel, assert, bytesToString, createValidAbsoluteUrl, getModificationDate, getUuid, getVerbosityLevel, isNodeJS, normalizeUnicode, objectSize, setVerbosityLevel, shadow, string32, stringToBytes, stringToPDFString, stringToUTF8String, toBase64Util
- `../../web/annotation_layer_builder.js`: AnnotationLayerBuilder
- `../../web/app_options.js`: AppOptions, OptionKind
- `../../web/download_manager.js`: DownloadManager
- `../../web/event_utils.js`: EventBus, WaitOnType, waitOnEventOrTimeout
- `../../web/genericl10n.js`: GenericL10n
- `../../web/pdf_find_controller.js`: FindState, PDFFindController
- `../../web/pdf_find_utils.js`: CharacterType, getCharacterType
- `../../web/pdf_history.js`: PDFHistory, isDestArraysEqual, isDestHashesEqual
- `../../web/pdf_link_service.js`: LinkTarget, PDFLinkService, SimpleLinkService
- `../../web/pdf_page_view.js`: PDFPageView
- `../../web/pdf_scripting_manager.component.js`: PDFScriptingManager
- `../../web/pdf_single_page_viewer.js`: PDFSinglePageViewer
- `../../web/pdf_viewer.js`: PDFPageViewBuffer, PDFViewer
- `../../web/struct_tree_layer_builder.js`: StructTreeLayerBuilder
- `../../web/text_layer_builder.js`: TextLayerBuilder
- `../../web/ui_utils.js`: AutoPrintRegExp, ProgressBar, RenderingStates, ScrollMode, SpreadMode, backtrackBeforeAllVisibleElements, binarySearchFirstItem, calcRound, getPageSizeInches, getVisibleElements, isPortraitOrientation, isValidRotation, parseQueryString, removeNullCharacters
- `../../web/xfa_layer_builder.js`: XfaLayerBuilder
- `../reporter.js`: TestReporter
- `./common_pdfstream_tests.js`: testCrossOriginRedirects
- `./test_utils.js`: CMAP_URL, DefaultFileReaderFactory, STANDARD_FONT_DATA_URL, TEST_PDFS_PATH, TestPdfsServer, XRefMock, buildGetDocumentParams, createIdFactory, getCrossOriginHostname
</imports>

Code:
<code>
File:
src/core/font_renderer.js
1 /* Copyright 2012 Mozilla Foundation
2  *
3  * Licensed under the Apache License, Version 2.0 (the "License");
4  * you may not use this file except in compliance with the License.
5  * You may obtain a copy of the License at
6  *
7  *     http://www.apache.org/licenses/LICENSE-2.0
8  *
9  * Unless required by applicable law or agreed to in writing, software
10  * distributed under the License is distributed on an "AS IS" BASIS,
11  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
12  * See the License for the specific language governing permissions and
13  * limitations under the License.
14  */
15 
16 import {
17   bytesToString,
18   FONT_IDENTITY_MATRIX,
19   FormatError,
20   unreachable,
21   Util,
22   warn,
23 } from "../shared/util.js";
24 import { CFFParser } from "./cff_parser.js";
25 import { getGlyphsUnicode } from "./glyphlist.js";
26 import { StandardEncoding } from "./encodings.js";
27 import { Stream } from "./stream.js";
28 
29 // TODO: use DataView and its methods.
30 
31 function getUint32(data, offset) {
32   return (
33     ((data[offset] << 24) |
34       (data[offset + 1] << 16) |
35       (data[offset + 2] << 8) |
36       data[offset + 3]) >>>
37     0
38   );
39 }
40 
41 function getUint16(data, offset) {
42   return (data[offset] << 8) | data[offset + 1];
43 }
44 
45 function getInt16(data, offset) {
46   return ((data[offset] << 24) | (data[offset + 1] << 16)) >> 16;
47 }
48 
49 function getInt8(data, offset) {
50   return (data[offset] << 24) >> 24;
51 }
52 
53 function getFloat214(data, offset) {
54   return getInt16(data, offset) / 16384;
55 }
56 
57 function getSubroutineBias(subrs) {
58   const numSubrs = subrs.length;
59   let bias = 32768;
60   if (numSubrs < 1240) {
61     bias = 107;
62   } else if (numSubrs < 33900) {
63     bias = 1131;
64   }
65   return bias;
66 }
67 
68 function parseCmap(data, start, end) {
69   const offset =
70     getUint16(data, start + 2) === 1
71       ? getUint32(data, start + 8)
72       : getUint32(data, start + 16);
73   const format = getUint16(data, start + offset);
74   let ranges, p, i;
75   if (format === 4) {
76     getUint16(data, start + offset + 2); // length
77     const segCount = getUint16(data, start + offset + 6) >> 1;
78     p = start + offset + 14;
79     ranges = [];
80     for (i = 0; i < segCount; i++, p += 2) {
81       ranges[i] = { end: getUint16(data, p) };
82     }
83     p += 2;
84     for (i = 0; i < segCount; i++, p += 2) {
85       ranges[i].start = getUint16(data, p);
86     }
87     for (i = 0; i < segCount; i++, p += 2) {
88       ranges[i].idDelta = getUint16(data, p);
89     }
90     for (i = 0; i < segCount; i++, p += 2) {
91       let idOffset = getUint16(data, p);
92       if (idOffset === 0) {
93         continue;
94       }
95       ranges[i].ids = [];
96       for (let j = 0, jj = ranges[i].end - ranges[i].start + 1; j < jj; j++) {
97         ranges[i].ids[j] = getUint16(data, p + idOffset);
98         idOffset += 2;
99       }
100     }
101     return ranges;
102   } else if (format === 12) {
103     const groups = getUint32(data, start + offset + 12);
104     p = start + offset + 16;
105     ranges = [];
106     for (i = 0; i < groups; i++) {
107       start = getUint32(data, p);
108       ranges.push({
109         start,
110         end: getUint32(data, p + 4),
111         idDelta: getUint32(data, p + 8) - start,
112       });
113       p += 12;
114     }
115     return ranges;
116   }
117   throw new FormatError(`unsupported cmap: ${format}`);
118 }
119 
120 function parseCff(data, start, end, seacAnalysisEnabled) {
121   const properties = {};
122   const parser = new CFFParser(
123     new Stream(data, start, end - start),
124     properties,
125     seacAnalysisEnabled
126   );
127   const cff = parser.parse();
128   return {
129     glyphs: cff.charStrings.objects,
130     subrs: cff.topDict.privateDict?.subrsIndex?.objects,
131     gsubrs: cff.globalSubrIndex?.objects,
132     isCFFCIDFont: cff.isCIDFont,
133     fdSelect: cff.fdSelect,
134     fdArray: cff.fdArray,
135   };
136 }
137 
138 function parseGlyfTable(glyf, loca, isGlyphLocationsLong) {
139   let itemSize, itemDecode;
140   if (isGlyphLocationsLong) {
141     itemSize = 4;
142     itemDecode = getUint32;
143   } else {
144     itemSize = 2;
145     itemDecode = (data, offset) => 2 * getUint16(data, offset);
146   }
147   const glyphs = [];
148   let startOffset = itemDecode(loca, 0);
149   for (let j = itemSize; j < loca.length; j += itemSize) {
150     const endOffset = itemDecode(loca, j);
151     glyphs.push(glyf.subarray(startOffset, endOffset));
152     startOffset = endOffset;
153   }
154   return glyphs;
155 }
156 
157 function lookupCmap(ranges, unicode) {
158   const code = unicode.codePointAt(0);
159   let gid = 0,
160     l = 0,
161     r = ranges.length - 1;
162   while (l < r) {
163     const c = (l + r + 1) >> 1;
164     if (code < ranges[c].start) {
165       r = c - 1;
166     } else {
167       l = c;
168     }
169   }
170   if (ranges[l].start <= code && code <= ranges[l].end) {
171     gid =
172       (ranges[l].idDelta +
173         (ranges[l].ids ? ranges[l].ids[code - ranges[l].start] : code)) &
174       0xffff;
175   }
176   return {
177     charCode: code,
178     glyphId: gid,
179   };
180 }
181 
182 function compileGlyf(code, cmds, font) {
183   function moveTo(x, y) {
184     cmds.add("M", [x, y]);
185   }
186   function lineTo(x, y) {
187     cmds.add("L", [x, y]);
188   }
189   function quadraticCurveTo(xa, ya, x, y) {
190     cmds.add("Q", [xa, ya, x, y]);
191   }
192 
193   let i = 0;
194   const numberOfContours = getInt16(code, i);
195   let flags;
196   let x = 0,
197     y = 0;
198   i += 10;
199   if (numberOfContours < 0) {
200     // composite glyph
201     do {
202       flags = getUint16(code, i);
203       const glyphIndex = getUint16(code, i + 2);
204       i += 4;
205       let arg1, arg2;
206       if (flags & 0x01) {
207         if (flags & 0x02) {
208           arg1 = getInt16(code, i);
209           arg2 = getInt16(code, i + 2);
210         } else {
211           arg1 = getUint16(code, i);
212           arg2 = getUint16(code, i + 2);
213         }
214         i += 4;
215       } else if (flags & 0x02) {
216         arg1 = getInt8(code, i++);
217         arg2 = getInt8(code, i++);
218       } else {
219         arg1 = code[i++];
220         arg2 = code[i++];
221       }
222       if (flags & 0x02) {
223         x = arg1;
224         y = arg2;
225       } else {
226         x = 0;
227         y = 0;
228       }
229       let scaleX = 1,
230         scaleY = 1,
231         scale01 = 0,
232         scale10 = 0;
233       if (flags & 0x08) {
234         scaleX = scaleY = getFloat214(code, i);
235         i += 2;
236       } else if (flags & 0x40) {
237         scaleX = getFloat214(code, i);
238         scaleY = getFloat214(code, i + 2);
239         i += 4;
240       } else if (flags & 0x80) {
241         scaleX = getFloat214(code, i);
242         scale01 = getFloat214(code, i + 2);
243         scale10 = getFloat214(code, i + 4);
244         scaleY = getFloat214(code, i + 6);
245         i += 8;
246       }
247       const subglyph = font.glyphs[glyphIndex];
248       if (subglyph) {
249         // TODO: the transform should be applied only if there is a scale:
250         // https://github.com/freetype/freetype/blob/edd4fedc5427cf1cf1f4b045e53ff91eb282e9d4/src/truetype/ttgload.c#L1205
251         cmds.save();
252         cmds.transform([scaleX, scale01, scale10, scaleY, x, y]);
253 
254         if (!(flags & 0x02)) {
255           // TODO: we must use arg1 and arg2 to make something similar to:
256           // https://github.com/freetype/freetype/blob/edd4fedc5427cf1cf1f4b045e53ff91eb282e9d4/src/truetype/ttgload.c#L1209
257         }
258         compileGlyf(subglyph, cmds, font);
259         cmds.restore();
260       }
261     } while (flags & 0x20);
262   } else {
263     // simple glyph
264     const endPtsOfContours = [];
265     let j, jj;
266     for (j = 0; j < numberOfContours; j++) {
267       endPtsOfContours.push(getUint16(code, i));
268       i += 2;
269     }
270     const instructionLength = getUint16(code, i);
271     i += 2 + instructionLength; // skipping the instructions
272     const numberOfPoints = endPtsOfContours.at(-1) + 1;
273     const points = [];
274     while (points.length < numberOfPoints) {
275       flags = code[i++];
276       let repeat = 1;
277       if (flags & 0x08) {
278         repeat += code[i++];
279       }
280       while (repeat-- > 0) {
281         points.push({ flags });
282       }
283     }
284     for (j = 0; j < numberOfPoints; j++) {
285       switch (points[j].flags & 0x12) {
286         case 0x00:
287           x += getInt16(code, i);
288           i += 2;
289           break;
290         case 0x02:
291           x -= code[i++];
292           break;
293         case 0x12:
294           x += code[i++];
295           break;
296       }
297       points[j].x = x;
298     }
299     for (j = 0; j < numberOfPoints; j++) {
300       switch (points[j].flags & 0x24) {
301         case 0x00:
302           y += getInt16(code, i);
303           i += 2;
304           break;
305         case 0x04:
306           y -= code[i++];
307           break;
308         case 0x24:
309           y += code[i++];
310           break;
311       }
312       points[j].y = y;
313     }
314 
315     let startPoint = 0;
316     for (i = 0; i < numberOfContours; i++) {
317       const endPoint = endPtsOfContours[i];
318       // contours might have implicit points, which is located in the middle
319       // between two neighboring off-curve points
320       const contour = points.slice(startPoint, endPoint + 1);
321       if (contour[0].flags & 1) {
322         contour.push(contour[0]); // using start point at the contour end
323       } else if (contour.at(-1).flags & 1) {
324         // first is off-curve point, trying to use one from the end
325         contour.unshift(contour.at(-1));
326       } else {
327         // start and end are off-curve points, creating implicit one
328         const p = {
329           flags: 1,
330           x: (contour[0].x + contour.at(-1).x) / 2,
331           y: (contour[0].y + contour.at(-1).y) / 2,
332         };
333         contour.unshift(p);
334         contour.push(p);
335       }
336       moveTo(contour[0].x, contour[0].y);
337       for (j = 1, jj = contour.length; j < jj; j++) {
338         if (contour[j].flags & 1) {
339           lineTo(contour[j].x, contour[j].y);
340         } else if (contour[j + 1].flags & 1) {
341           quadraticCurveTo(
342             contour[j].x,
343             contour[j].y,
344             contour[j + 1].x,
345             contour[j + 1].y
346           );
347           j++;
348         } else {
349           quadraticCurveTo(
350             contour[j].x,
351             contour[j].y,
352             (contour[j].x + contour[j + 1].x) / 2,
353             (contour[j].y + contour[j + 1].y) / 2
354           );
355         }
356       }
357       startPoint = endPoint + 1;
358     }
359   }
360 }
361 
362 function compileCharString(charStringCode, cmds, font, glyphId) {
363   function moveTo(x, y) {
364     cmds.add("M", [x, y]);
365   }
366   function lineTo(x, y) {
367     cmds.add("L", [x, y]);
368   }
369   function bezierCurveTo(x1, y1, x2, y2, x, y) {
370     cmds.add("C", [x1, y1, x2, y2, x, y]);
371   }
372 
373   const stack = [];
374   let x = 0,
375     y = 0;
376   let stems = 0;
377 
378   function parse(code) {
379     let i = 0;
380     while (i < code.length) {
381       let stackClean = false;
382       let v = code[i++];
383       let xa, xb, ya, yb, y1, y2, y3, n, subrCode;
384       switch (v) {
385         case 1: // hstem
386           stems += stack.length >> 1;
387           stackClean = true;
388           break;
389         case 3: // vstem
390           stems += stack.length >> 1;
391           stackClean = true;
392           break;
393         case 4: // vmoveto
394           y += stack.pop();
395           moveTo(x, y);
396           stackClean = true;
397           break;
398         case 5: // rlineto
399           while (stack.length > 0) {
400             x += stack.shift();
401             y += stack.shift();
402             lineTo(x, y);
403           }
404           break;
405         case 6: // hlineto
406           while (stack.length > 0) {
407             x += stack.shift();
408             lineTo(x, y);
409             if (stack.length === 0) {
410               break;
411             }
412             y += stack.shift();
413             lineTo(x, y);
414           }
415           break;
416         case 7: // vlineto
417           while (stack.length > 0) {
418             y += stack.shift();
419             lineTo(x, y);
420             if (stack.length === 0) {
421               break;
422             }
423             x += stack.shift();
424             lineTo(x, y);
425           }
426           break;
427         case 8: // rrcurveto
428           while (stack.length > 0) {
429             xa = x + stack.shift();
430             ya = y + stack.shift();
431             xb = xa + stack.shift();
432             yb = ya + stack.shift();
433             x = xb + stack.shift();
434             y = yb + stack.shift();
435             bezierCurveTo(xa, ya, xb, yb, x, y);
436           }
437           break;
438         case 10: // callsubr
439           n = stack.pop();
440           subrCode = null;
441           if (font.isCFFCIDFont) {
442             const fdIndex = font.fdSelect.getFDIndex(glyphId);
443             if (fdIndex >= 0 && fdIndex < font.fdArray.length) {
444               const fontDict = font.fdArray[fdIndex];
445               let subrs;
446               if (fontDict.privateDict?.subrsIndex) {
447                 subrs = fontDict.privateDict.subrsIndex.objects;
448               }
449               if (subrs) {
450                 // Add subroutine bias.
451                 n += getSubroutineBias(subrs);
452                 subrCode = subrs[n];
453               }
454             } else {
455               warn("Invalid fd index for glyph index.");
456             }
457           } else {
458             subrCode = font.subrs[n + font.subrsBias];
459           }
460           if (subrCode) {
461             parse(subrCode);
462           }
463           break;
464         case 11: // return
465           return;
466         case 12:
467           v = code[i++];
468           switch (v) {
469             case 34: // flex
470               xa = x + stack.shift();
471               xb = xa + stack.shift();
472               y1 = y + stack.shift();
473               x = xb + stack.shift();
474               bezierCurveTo(xa, y, xb, y1, x, y1);
475               xa = x + stack.shift();
476               xb = xa + stack.shift();
477               x = xb + stack.shift();
478               bezierCurveTo(xa, y1, xb, y, x, y);
479               break;
480             case 35: // flex
481               xa = x + stack.shift();
482               ya = y + stack.shift();
483               xb = xa + stack.shift();
484               yb = ya + stack.shift();
485               x = xb + stack.shift();
486               y = yb + stack.shift();
487               bezierCurveTo(xa, ya, xb, yb, x, y);
488               xa = x + stack.shift();
489               ya = y + stack.shift();
490               xb = xa + stack.shift();
491               yb = ya + stack.shift();
492               x = xb + stack.shift();
493               y = yb + stack.shift();
494               bezierCurveTo(xa, ya, xb, yb, x, y);
495               stack.pop(); // fd
496               break;
497             case 36: // hflex1
498               xa = x + stack.shift();
499               y1 = y + stack.shift();
500               xb = xa + stack.shift();
501               y2 = y1 + stack.shift();
502               x = xb + stack.shift();
503               bezierCurveTo(xa, y1, xb, y2, x, y2);
504               xa = x + stack.shift();
505               xb = xa + stack.shift();
506               y3 = y2 + stack.shift();
507               x = xb + stack.shift();
508               bezierCurveTo(xa, y2, xb, y3, x, y);
509               break;
510             case 37: // flex1
511               const x0 = x,
512                 y0 = y;
513               xa = x + stack.shift();
514               ya = y + stack.shift();
515               xb = xa + stack.shift();
516               yb = ya + stack.shift();
517               x = xb + stack.shift();
518               y = yb + stack.shift();
519               bezierCurveTo(xa, ya, xb, yb, x, y);
520               xa = x + stack.shift();
521               ya = y + stack.shift();
522               xb = xa + stack.shift();
523               yb = ya + stack.shift();
524               x = xb;
525               y = yb;
526               if (Math.abs(x - x0) > Math.abs(y - y0)) {
527                 x += stack.shift();
528               } else {
529                 y += stack.shift();
530               }
531               bezierCurveTo(xa, ya, xb, yb, x, y);
532               break;
533             default:
534               throw new FormatError(`unknown operator: 12 ${v}`);
535           }
536           break;
537         case 14: // endchar
538           if (stack.length >= 4) {
539             const achar = stack.pop();
540             const bchar = stack.pop();
541             y = stack.pop();
542             x = stack.pop();
543             cmds.save();
544             cmds.translate(x, y);
545             let cmap = lookupCmap(
546               font.cmap,
547               String.fromCharCode(font.glyphNameMap[StandardEncoding[achar]])
548             );
549             compileCharString(
550               font.glyphs[cmap.glyphId],
551               cmds,
552               font,
553               cmap.glyphId
554             );
555             cmds.restore();
556 
557             cmap = lookupCmap(
558               font.cmap,
559               String.fromCharCode(font.glyphNameMap[StandardEncoding[bchar]])
560             );
561             compileCharString(
562               font.glyphs[cmap.glyphId],
563               cmds,
564               font,
565               cmap.glyphId
566             );
567           }
568           return;
569         case 18: // hstemhm
570           stems += stack.length >> 1;
571           stackClean = true;
572           break;
573         case 19: // hintmask
574           stems += stack.length >> 1;
575           i += (stems + 7) >> 3;
576           stackClean = true;
577           break;
578         case 20: // cntrmask
579           stems += stack.length >> 1;
580           i += (stems + 7) >> 3;
581           stackClean = true;
582           break;
583         case 21: // rmoveto
584           y += stack.pop();
585           x += stack.pop();
586           moveTo(x, y);
587           stackClean = true;
588           break;
589         case 22: // hmoveto
590           x += stack.pop();
591           moveTo(x, y);
592           stackClean = true;
593           break;
594         case 23: // vstemhm
595           stems += stack.length >> 1;
596           stackClean = true;
597           break;
598         case 24: // rcurveline
599           while (stack.length > 2) {
600             xa = x + stack.shift();
601             ya = y + stack.shift();
602             xb = xa + stack.shift();
603             yb = ya + stack.shift();
604             x = xb + stack.shift();
605             y = yb + stack.shift();
606             bezierCurveTo(xa, ya, xb, yb, x, y);
607           }
608           x += stack.shift();
609           y += stack.shift();
610           lineTo(x, y);
611           break;
612         case 25: // rlinecurve
613           while (stack.length > 6) {
614             x += stack.shift();
615             y += stack.shift();
616             lineTo(x, y);
617           }
618           xa = x + stack.shift();
619           ya = y + stack.shift();
620           xb = xa + stack.shift();
621           yb = ya + stack.shift();
622           x = xb + stack.shift();
623           y = yb + stack.shift();
624           bezierCurveTo(xa, ya, xb, yb, x, y);
625           break;
626         case 26: // vvcurveto
627           if (stack.length % 2) {
628             x += stack.shift();
629           }
630           while (stack.length > 0) {
631             xa = x;
632             ya = y + stack.shift();
633             xb = xa + stack.shift();
634             yb = ya + stack.shift();
635             x = xb;
636             y = yb + stack.shift();
637             bezierCurveTo(xa, ya, xb, yb, x, y);
638           }
639           break;
640         case 27: // hhcurveto
641           if (stack.length % 2) {
642             y += stack.shift();
643           }
644           while (stack.length > 0) {
645             xa = x + stack.shift();
646             ya = y;
647             xb = xa + stack.shift();
648             yb = ya + stack.shift();
649             x = xb + stack.shift();
650             y = yb;
651             bezierCurveTo(xa, ya, xb, yb, x, y);
652           }
653           break;
654         case 28:
655           stack.push(((code[i] << 24) | (code[i + 1] << 16)) >> 16);
656           i += 2;
657           break;
658         case 29: // callgsubr
659           n = stack.pop() + font.gsubrsBias;
660           subrCode = font.gsubrs[n];
661           if (subrCode) {
662             parse(subrCode);
663           }
664           break;
665         case 30: // vhcurveto
666           while (stack.length > 0) {
667             xa = x;
668             ya = y + stack.shift();
669             xb = xa + stack.shift();
670             yb = ya + stack.shift();
671             x = xb + stack.shift();
672             y = yb + (stack.length === 1 ? stack.shift() : 0);
673             bezierCurveTo(xa, ya, xb, yb, x, y);
674             if (stack.length === 0) {
675               break;
676             }
677 
678             xa = x + stack.shift();
679             ya = y;
680             xb = xa + stack.shift();
681             yb = ya + stack.shift();
682             y = yb + stack.shift();
683             x = xb + (stack.length === 1 ? stack.shift() : 0);
684             bezierCurveTo(xa, ya, xb, yb, x, y);
685           }
686           break;
687         case 31: // hvcurveto
688           while (stack.length > 0) {
689             xa = x + stack.shift();
690             ya = y;
691             xb = xa + stack.shift();
692             yb = ya + stack.shift();
693             y = yb + stack.shift();
694             x = xb + (stack.length === 1 ? stack.shift() : 0);
695             bezierCurveTo(xa, ya, xb, yb, x, y);
696             if (stack.length === 0) {
697               break;
698             }
699 
700             xa = x;
701             ya = y + stack.shift();
702             xb = xa + stack.shift();
703             yb = ya + stack.shift();
704             x = xb + stack.shift();
705             y = yb + (stack.length === 1 ? stack.shift() : 0);
706             bezierCurveTo(xa, ya, xb, yb, x, y);
707           }
708           break;
709         default:
710           if (v < 32) {
711             throw new FormatError(`unknown operator: ${v}`);
712           }
713           if (v < 247) {
714             stack.push(v - 139);
715           } else if (v < 251) {
716             stack.push((v - 247) * 256 + code[i++] + 108);
717           } else if (v < 255) {
718             stack.push(-(v - 251) * 256 - code[i++] - 108);
719           } else {
720             stack.push(
721               ((code[i] << 24) |
722                 (code[i + 1] << 16) |
723                 (code[i + 2] << 8) |
724                 code[i + 3]) /
725                 65536
726             );
727             i += 4;
728           }
729           break;
730       }
731       if (stackClean) {
732         stack.length = 0;
733       }
734     }
735   }
736   parse(charStringCode);
737 }
738 
739 const NOOP = "";
740 
741 class Commands {
742   cmds = [];
743 
744   transformStack = [];
745 
746   currentTransform = [1, 0, 0, 1, 0, 0];
747 
748   add(cmd, args) {
749     if (args) {
750       const [a, b, c, d, e, f] = this.currentTransform;
751       for (let i = 0, ii = args.length; i < ii; i += 2) {
752         const x = args[i];
753         const y = args[i + 1];
754         args[i] = a * x + c * y + e;
755         args[i + 1] = b * x + d * y + f;
756       }
757       this.cmds.push(`${cmd}${args.join(" ")}`);
758     } else {
759       this.cmds.push(cmd);
760     }
761   }
762 
763   transform(transf) {
764     this.currentTransform = Util.transform(this.currentTransform, transf);
765   }
766 
767   translate(x, y) {
768     this.transform([1, 0, 0, 1, x, y]);
769   }
770 
771   save() {
772     this.transformStack.push(this.currentTransform.slice());
773   }
774 
775   restore() {
776     this.currentTransform = this.transformStack.pop() || [1, 0, 0, 1, 0, 0];
777   }
778 
779   getSVG() {
780     return this.cmds.join("");
781   }
782 }
783 
784 class CompiledFont {
785   constructor(fontMatrix) {
786     if (
787       (typeof PDFJSDev === "undefined" || PDFJSDev.test("TESTING")) &&
788       this.constructor === CompiledFont
789     ) {
790       unreachable("Cannot initialize CompiledFont.");
791     }
792     this.fontMatrix = fontMatrix;
793 
794     this.compiledGlyphs = Object.create(null);
795     this.compiledCharCodeToGlyphId = Object.create(null);
796   }
797 
798   getPathJs(unicode) {
799     const { charCode, glyphId } = lookupCmap(this.cmap, unicode);
800     let fn = this.compiledGlyphs[glyphId],
801       compileEx;
802     if (fn === undefined) {
803       try {
804         fn = this.compileGlyph(this.glyphs[glyphId], glyphId);
805       } catch (ex) {
806         fn = NOOP; // Avoid attempting to re-compile a corrupt glyph.
807 
808         compileEx = ex;
809       }
810       this.compiledGlyphs[glyphId] = fn;
811     }
812     this.compiledCharCodeToGlyphId[charCode] ??= glyphId;
813 
814     if (compileEx) {
815       throw compileEx;
816     }
817     return fn;
818   }
819 
820   compileGlyph(code, glyphId) {
821     if (!code || code.length === 0 || code[0] === 14) {
822       return NOOP;
823     }
824 
825     let fontMatrix = this.fontMatrix;
826     if (this.isCFFCIDFont) {
827       // Top DICT's FontMatrix can be ignored because CFFCompiler always
828       // removes it and copies to FDArray DICTs.
829       const fdIndex = this.fdSelect.getFDIndex(glyphId);
830       if (fdIndex >= 0 && fdIndex < this.fdArray.length) {
831         const fontDict = this.fdArray[fdIndex];
832         fontMatrix = fontDict.getByName("FontMatrix") || FONT_IDENTITY_MATRIX;
833       } else {
834         warn("Invalid fd index for glyph index.");
835       }
836     }
837 
838     const cmds = new Commands();
839     cmds.transform(fontMatrix.slice());
840     this.compileGlyphImpl(code, cmds, glyphId);
841     cmds.add("Z");
842 
843     return cmds.getSVG();
844   }
845 
846   compileGlyphImpl() {
847     unreachable("Children classes should implement this.");
848   }
849 
850   hasBuiltPath(unicode) {
851     const { charCode, glyphId } = lookupCmap(this.cmap, unicode);
852     return (
853       this.compiledGlyphs[glyphId] !== undefined &&
854       this.compiledCharCodeToGlyphId[charCode] !== undefined
855     );
856   }
857 }
858 
859 class TrueTypeCompiled extends CompiledFont {
860   constructor(glyphs, cmap, fontMatrix) {
861     super(fontMatrix || [0.000488, 0, 0, 0.000488, 0, 0]);
862 
863     this.glyphs = glyphs;
864     this.cmap = cmap;
865   }
866 
867   compileGlyphImpl(code, cmds) {
868     compileGlyf(code, cmds, this);
869   }
870 }
871 
872 class Type2Compiled extends CompiledFont {
873   constructor(cffInfo, cmap, fontMatrix, glyphNameMap) {
874     super(fontMatrix || [0.001, 0, 0, 0.001, 0, 0]);
875 
876     this.glyphs = cffInfo.glyphs;
877     this.gsubrs = cffInfo.gsubrs || [];
878     this.subrs = cffInfo.subrs || [];
879     this.cmap = cmap;
880     this.glyphNameMap = glyphNameMap || getGlyphsUnicode();
881 
882     this.gsubrsBias = getSubroutineBias(this.gsubrs);
883     this.subrsBias = getSubroutineBias(this.subrs);
884 
885     this.isCFFCIDFont = cffInfo.isCFFCIDFont;
886     this.fdSelect = cffInfo.fdSelect;
887     this.fdArray = cffInfo.fdArray;
888   }
889 
890   compileGlyphImpl(code, cmds, glyphId) {
891     compileCharString(code, cmds, this, glyphId);
892   }
893 }
894 
895 class FontRendererFactory {
896   static create(font, seacAnalysisEnabled) {
897     const data = new Uint8Array(font.data);
898     let cmap, glyf, loca, cff, indexToLocFormat, unitsPerEm;
899     const numTables = getUint16(data, 4);
900     for (let i = 0, p = 12; i < numTables; i++, p += 16) {
901       const tag = bytesToString(data.subarray(p, p + 4));
902       const offset = getUint32(data, p + 8);
903       const length = getUint32(data, p + 12);
904       switch (tag) {
905         case "cmap":
906           cmap = parseCmap(data, offset, offset + length);
907           break;
908         case "glyf":
909           glyf = data.subarray(offset, offset + length);
910           break;
911         case "loca":
912           loca = data.subarray(offset, offset + length);
913           break;
914         case "head":
915           unitsPerEm = getUint16(data, offset + 18);
916           indexToLocFormat = getUint16(data, offset + 50);
917           break;
918         case "CFF ":
919           cff = parseCff(data, offset, offset + length, seacAnalysisEnabled);
920           break;
921       }
922     }
923 
924     if (glyf) {
925       const fontMatrix = !unitsPerEm
926         ? font.fontMatrix
927         : [1 / unitsPerEm, 0, 0, 1 / unitsPerEm, 0, 0];
928       return new TrueTypeCompiled(
929         parseGlyfTable(glyf, loca, indexToLocFormat),
930         cmap,
931         fontMatrix
932       );
933     }
934     return new Type2Compiled(cff, cmap, font.fontMatrix, font.glyphNameMap);
935   }
936 }
937 
938 export { FontRendererFactory };
</code>

Test file:
<test_file>
File:
test/unit/ui_utils_spec.js
/* Copyright 2017 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import {
  backtrackBeforeAllVisibleElements,
  binarySearchFirstItem,
  calcRound,
  getPageSizeInches,
  getVisibleElements,
  isPortraitOrientation,
  isValidRotation,
  parseQueryString,
  removeNullCharacters,
} from "../../web/ui_utils.js";
</test_file>

Your task:
You are a software tester at pdf.js.
1. Examine the existing test file. You may reuse any imports, helpers or setup blocks it already has.
2. Write exactly one javascript test `it("...", async () => {...})` block.
3. Your test must fail on the code before the patch, and pass after, hence the test will verify that the patch resolves the issue.
4. The test must be self-contained and to-the-point.
5. If you need something new use only the provided imports (respect the paths exactly how they are given) by importing dynamically for compatibility with Node.js — no new dependencies. 
6. Return only the javascript code for the new `it(...)` block (no comments or explanations).

Example structure:
it("should <describe behavior>", async () => {
  const { example } = await import("../../src/core/example.js");
  <initialize required variables>;
  <define expected variable>;
  <generate actual variables>;
  <compare expected with actual>;
});

