{
  "16686": {
    "i1_deepseek-r1-distill-llama-70b": "it(\"should correctly handle SVG images with blob URLs\", async () => {\n  const { ImageManager } = await import(\"../../display/editor/tools.js\");\n  const svgContent = \"<svg xmlns=\\\"http://www.w3.org/2000/svg\\\" width=\\\"100\\\" height=\\\"100\\\"></svg>\";\n  const blob = new Blob([svgContent], { type: \"image/svg+xml\" });\n  const url = URL.createObjectURL(blob);\n\n  const manager = new ImageManager();\n  const data = await manager.get(url, blob).catch((error) => {\n    throw error;\n  });\n\n  expect(data).toBeTruthy();\n  URL.revokeObjectURL(url);\n});",
    "i1_gpt-4o": "it(\"should add a SVG image with a blob url\", async () => {\n  const { ImageManager } = await import(\"../../src/display/editor/tools.js\");\n  const svgBlob = new Blob(['<svg xmlns=\"http://www.w3.org/2000/svg\"></svg>'], { type: \"image/svg+xml\" });\n  const blobUrl = URL.createObjectURL(svgBlob);\n  const imageManager = new ImageManager();\n  const data = await imageManager.#get(blobUrl, svgBlob);\n  URL.revokeObjectURL(blobUrl);\n  expect(data).not.toBeNull();\n  expect(data.isSvg).toBe(true);\n  expect(data.bitmap instanceof Image).toBe(true);\n});",
    "i1_llama-3.3-70b-versatile": "it(\"should add a SVG image with a blob url\", async () => {\n  const { ImageManager } = await import(\"../../src/display/editor/tools.js\");\n  const imageManager = new ImageManager();\n  const svgBlob = new Blob(['<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"100\" height=\"100\"><rect x=\"10\" y=\"10\" width=\"50\" height=\"50\" fill=\"#ff0000\"/></svg>'], { type: 'image/svg+xml' });\n  const fileReader = new FileReader();\n  const svgUrlPromise = new Promise(resolve => {\n    fileReader.onload = () => {\n      resolve(fileReader.result);\n    };\n  });\n  fileReader.readAsDataURL(svgBlob);\n  const svgUrl = await svgUrlPromise;\n  const image = await imageManager.#get('svg-image', svgBlob);\n  expect(image).not.toBeNull();\n  expect(image.bitmap).not.toBeNull();\n  expect(image.isSvg).toBe(true);\n});",
    "i2_deepseek-r1-distill-llama-70b": "it(\"should add SVG image with blob URL\", async () => {\n  const svgContent = `<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"100\" height=\"100\"><rect width=\"100\" height=\"100\" fill=\"red\"/></svg>`;\n  const imageBlob = new Blob([svgContent], { type: 'image/svg+xml' });\n  const imageBlobUrl = URL.createObjectURL(imageBlob);\n\n  const { ImageManager } = await import(\"../../display/editor/tools.js\");\n  const imageManager = new ImageManager();\n\n  const data = await imageManager.add(imageBlobUrl);\n  expect(data).not.toBeNull();\n});",
    "i2_gpt-4o": "it(\"should load an SVG image using a data URL\", async () => {\n  const { ImageManager } = await import(\"../../src/display/editor/tools.js\");\n  const svgBlob = new Blob(\n    [\n      `<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"100\" height=\"100\">\n         <circle cx=\"50\" cy=\"50\" r=\"40\" stroke=\"black\" stroke-width=\"3\" fill=\"red\" />\n       </svg>`,\n    ],\n    { type: \"image/svg+xml\" }\n  );\n  const imageManager = new ImageManager();\n  const data = await imageManager.#get(\"testSvg\", svgBlob);\n  const expected = true;\n  const actual = data.isSvg;\n  expect(actual).toBe(expected);\n});",
    "i2_llama-3.3-70b-versatile": "it(\"should load a SVG image with a blob url\", async () => {\n  const { ImageManager } = await import(\"../../src/display/editor/tools.js\");\n  const imageManager = new ImageManager();\n  const blob = new Blob(['<svg></svg>'], {type: 'image/svg+xml'});\n  const key = 'image_1';\n  const rawData = blob;\n  const dataBeforePatch = await imageManager.#get(key, rawData);\n  expect(dataBeforePatch).toBeNull();\n\n  const { ImageManager: ImageManagerPatched } = await import(\"./tools_patched.js\");\n  const imageManagerPatched = new ImageManagerPatched();\n  const dataAfterPatch = await imageManagerPatched.#get(key, rawData);\n  expect(dataAfterPatch).not.toBeNull();\n  expect(dataAfterPatch.bitmap).not.toBeNull();\n});",
    "i3_deepseek-r1-distill-llama-70b": "it(\"should add SVG image with blob URL\", async () => {\n  const { ImageManager } = await import(\"../../src/display/editor/tools.js\");\n  const svg = `<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"100\" height=\"100\"><rect width=\"100\" height=\"100\" fill=\"red\"/></svg>`;\n  const blob = new Blob([svg], { type: \"image/svg+xml\" });\n  const file = new File([blob], \"test.svg\", { type: \"image/svg+xml\" });\n\n  const imageManager = new ImageManager();\n  const data = await imageManager.getFromFile(file);\n\n  expect(data?.bitmap).toBeTruthy();\n});",
    "i3_gpt-4o": "it(\"should add a SVG image with a blob URL\", async () => {\n  const { ImageManager } = await import(\"../../src/display/editor/tools.js\");\n  const svgBlob = new Blob(['<svg xmlns=\"http://www.w3.org/2000/svg\"></svg>'], { type: \"image/svg+xml\" });\n  const imageManager = new ImageManager();\n  const data = await imageManager.getFromFile(svgBlob);\n  expect(data).not.toBeNull();\n  expect(data.isSvg).toBe(true);\n  expect(data.bitmap).toBeInstanceOf(Image);\n});",
    "i3_llama-3.3-70b-versatile": "it(\"should add a SVG image with a blob url\", async () => {\n  const { ImageManager } = await import(\"../../src/display/editor/tools.js\");\n  const imageManager = new ImageManager();\n  const svgBlob = new Blob(['<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"100\" height=\"100\"><rect width=\"100\" height=\"100\" style=\"fill:rgb(0,0,255)\" /></svg>'], {type : 'image/svg+xml'});\n  const file = new File([svgBlob], \"image.svg\", {type: \"image/svg+xml\"});\n  const data = await imageManager.getFromFile(file);\n  expect(data).not.toBeNull();\n  expect(data.bitmap).not.toBeNull();\n  expect(data.isSvg).toBe(true);\n});",
    "i4_deepseek-r1-distill-llama-70b": "it(\"should add SVG image with blob URL\", async () => {\n  const { ImageManager } = await import(\"../../src/display/editor/tools.js\");\n  const imageManager = new ImageManager();\n\n  // Create a sample SVG blob\n  const svg = \"<svg xmlns='http://www.w3.org/2000/svg'></svg>\";\n  const blob = new Blob([svg], { type: \"image/svg+xml\" });\n  const url = URL.createObjectURL(blob);\n\n  // Get the image data\n  const data = await imageManager.getFromUrl(url);\n\n  // Clean up\n  URL.revokeObjectURL(url);\n\n  // Verify the image was loaded correctly\n  expect(data).toBeTruthy();\n  expect(data.bitmap).toBeTruthy();\n  expect(data.isSvg).toBe(true);\n});",
    "i4_gpt-4o": "it(\"should add an SVG image with a blob URL\", async () => {\n  const { ImageManager } = await import(\"../../src/display/editor/tools.js\");\n  const svgBlob = new Blob(\n    [\n      `<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"100\" height=\"100\">\n         <circle cx=\"50\" cy=\"50\" r=\"40\" stroke=\"black\" stroke-width=\"3\" fill=\"red\" />\n       </svg>`\n    ],\n    { type: \"image/svg+xml\" }\n  );\n  const imageManager = new ImageManager();\n  const data = await imageManager.getFromFile(svgBlob);\n  const expected = true;\n  const actual = data.isSvg;\n  expect(actual).toBe(expected);\n});",
    "i4_llama-3.3-70b-versatile": "it(\"should add a SVG image with a blob url\", async () => {\n  const { ImageManager } = await import(\"../../src/display/editor/tools.js\");\n  const imageManager = new ImageManager();\n  const svgBlob = new Blob(['<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"100\" height=\"100\"><rect x=\"10\" y=\"10\" width=\"50\" height=\"50\" fill=\"#ff0000\"/></svg>'], { type: 'image/svg+xml' });\n  const url = URL.createObjectURL(svgBlob);\n  const data = await imageManager.getFromFile(svgBlob);\n  expect(data.bitmap).not.toBeNull();\n  expect(data.isSvg).toBe(true);\n  expect(data.svgUrl).not.toBeNull();\n});",
    "i5_deepseek-r1-distill-llama-70b": "it(\"should add SVG image with blob URL\", async () => {\n  const svgContent = '<svg><circle cx=\"50\" cy=\"50\" r=\"40\" fill=\"red\"/></svg>';\n  const base64SVG = Buffer.from(svgContent).toString('base64');\n  const dataUrl = `data:image/svg+xml;base64,${base64SVG}`;\n\n  const mockImage = {\n    src: null,\n    onload: null,\n    onerror: null,\n    addEventListener: (event, callback) => {\n      if (event === 'load') {\n        callback();\n      }\n    }\n  };\n\n  const ImageMock = jest.fn(() => mockImage);\n\n  const { ImageManager } = await import('../../src/display/editor/tools.js');\n\n  const data = {\n    bitmap: null,\n    isSvg: false,\n    svgUrl: null\n  };\n\n  const imageManager = new ImageManager();\n\n  // Mock the Image constructor\n  const originalImage = global.Image;\n  global.Image = ImageMock;\n\n  try {\n    await imageManager.addImage(dataUrl, data);\n    await new Promise(resolve => setTimeout(resolve, 100)); // Wait for onload\n\n    expect(data.bitmap).toBe(mockImage);\n    expect(data.isSvg).toBe(true);\n  } finally {\n    global.Image = originalImage;\n  }\n});",
    "i5_gpt-4o": "it(\"should add an SVG image with a blob URL\", async () => {\n  const { ImageManager } = await import(\"../../src/display/editor/tools.js\");\n  const svgBlob = new Blob(['<svg xmlns=\"http://www.w3.org/2000/svg\"></svg>'], { type: 'image/svg+xml' });\n  const imageManager = new ImageManager();\n  const data = {};\n\n  const addSvgImage = async () => {\n    const fileReader = new FileReader();\n    const imageElement = new Image();\n    const imagePromise = new Promise((resolve, reject) => {\n      imageElement.onload = () => {\n        data.bitmap = imageElement;\n        data.isSvg = true;\n        resolve();\n      };\n      fileReader.onload = () => {\n        imageElement.src = data.svgUrl = fileReader.result;\n      };\n      imageElement.onerror = fileReader.onerror = reject;\n    });\n    fileReader.readAsDataURL(svgBlob);\n    await imagePromise;\n  };\n\n  await addSvgImage();\n  expect(data.isSvg).toBe(true);\n  expect(data.bitmap).toBeInstanceOf(Image);\n});",
    "i5_llama-3.3-70b-versatile": "it(\"should add a SVG image with a blob url\", async () => {\n  const { ImageManager } = await import(\"../../src/display/editor/tools.js\");\n  const { Util } = await import(\"../../src/shared/util.js\");\n  const imageManager = new ImageManager();\n  const svgImage = `<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"100\" height=\"100\"><circle cx=\"50\" cy=\"50\" r=\"40\" stroke=\"green\" stroke-width=\"4\" fill=\"yellow\" /></svg>`;\n  const blob = new Blob([svgImage], { type: 'image/svg+xml' });\n  const url = URL.createObjectURL(blob);\n  const image = await fetch(url).then(response => response.blob());\n  const data = {};\n  await imageManager.addImage(image, data);\n  const expected = true;\n  const actual = data.isSvg;\n  expect(actual).toBe(expected);\n});"
  },
  "16709": {
    "i1_deepseek-r1-distill-llama-70b": "it(\"should redo an annotation using keyboard shortcuts\", async () => {\n  const { PDFDocument } = await import(\"../../src/display/api.js\");\n  const { Annotation, AnnotationFactory, MarkupAnnotation } = await import(\"../../src/core/annotation.js\");\n  const { KeyManager } = await import(\"../../src/display/editor/tools.js\");\n\n  const pdfDocument = new PDFDocument(new XRefMock());\n  const page = pdfDocument.addPage();\n  const annotationStorage = pdfDocument.annotationStorage;\n\n  const textAnnotation = AnnotationFactory.create(AnnotationType.TEXT, {\n    text: \"Test annotation\",\n    color: \"#FF0000\",\n    page: page.ref,\n  });\n\n  // Add the annotation\n  annotationStorage.addAnnotation(textAnnotation);\n  expect(annotationStorage.getAnnotations().length).toBe(1);\n\n  // Undo the annotation\n  KeyManager.onKeyDown({ key: \"z\", ctrlKey: true, metaKey: true });\n  expect(annotationStorage.getAnnotations().length).toBe(0);\n\n  // Redo the annotation using the new keyboard shortcuts\n  KeyManager.onKeyDown({ key: \"Z\", ctrlKey: true, shiftKey: true });\n  expect(annotationStorage.getAnnotations().length).toBe(1);\n});",
    "i1_gpt-4o": "it(\"should redo an added imagetextdrawing to the PDF file using Keyboard shortcuts\", async () => {\n  const { AnnotationEditorUIManager } = await import(\"../../src/display/editor/tools.js\");\n  const eventBus = { _on: () => {} };\n  const pdfDocument = { annotationStorage: {}, filterFactory: {} };\n  const container = {};\n  const pageColors = {};\n  const manager = new AnnotationEditorUIManager(container, eventBus, pdfDocument, pageColors);\n  const keyboardManager = AnnotationEditorUIManager._keyboardManager;\n  const redoShortcut = [\"ctrl+y\", \"ctrl+shift+z\", \"mac+meta+shift+z\", \"ctrl+shift+Z\", \"mac+meta+shift+Z\"];\n  const redoAction = keyboardManager.shortcuts.find(([keys]) => keys.some(key => redoShortcut.includes(key)));\n  expect(redoAction).toBeDefined();\n});",
    "i1_llama-3.3-70b-versatile": "it(\"should redo an added imagetextdrawing to the PDF file using Keyboard shortcuts\", async () => {\n  const { AnnotationEditorUIManager } = await import(\"../../src/display/editor/tools.js\");\n  const { AnnotationEditorType } = await import(\"../../src/shared/util.js\");\n  const { createIdFactory } = await import(\"./test_utils.js\");\n  const { DefaultCMapReaderFactory, DefaultStandardFontDataFactory } = await import(\"../../src/display/api.js\");\n  const idFactory = createIdFactory();\n  const annotationEditorUIManager = new AnnotationEditorUIManager(null, null, null, null);\n  annotationEditorUIManager.#mode = AnnotationEditorType.DRAW;\n  annotationEditorUIManager.#commandManager.execute(\"add\");\n  annotationEditorUIManager.#commandManager.execute(\"undo\");\n  annotationEditorUIManager.#commandManager.execute(\"redo\");\n  const hasSomethingToRedo = annotationEditorUIManager.#commandManager.hasSomethingToRedo();\n  expect(hasSomethingToRedo).toBe(false);\n});",
    "i2_deepseek-r1-distill-llama-70b": "it(\"should redo using metashiftz on mac\", async () => {\n  const { AnnotationEditorUIManager } = await import(\"../../src/display/editor/tools.js\");\n  const { KeyboardManager } = await import(\"../../src/shared/keyboard/keyboard.js\");\n\n  const container = {\n    addEventListener: () => {},\n    removeEventListener: () => {}\n  };\n\n  const eventBus = {\n    _on: () => {},\n    _off: () => {}\n  };\n\n  const pdfDocument = {\n    annotationStorage: {},\n    filterFactory: {}\n  };\n\n  const pageColors = {};\n\n  const manager = new AnnotationEditorUIManager(container, eventBus, pdfDocument, pageColors);\n\n  const editor = {\n    type: \"text\",\n    id: \"test-editor\",\n    redo: () => {}\n  };\n\n  manager.addEditor(editor);\n\n  // Mock the redo method\n  const redoSpy = jest.spyOn(editor, 'redo');\n\n  // Simulate an undo first\n  manager.undo();\n\n  // Test meta+shift+z\n  const event = {\n    key: 'z',\n    code: 'MetaLeft',\n    ctrlKey: false,\n    metaKey: true,\n    shiftKey: true,\n    preventDefault: () => {}\n  };\n\n  manager._handleKeyboardEvent(event);\n\n  expect(redoSpy).toHaveBeenCalled();\n\n  redoSpy.mockClear();\n\n  // Test meta+shift+Z\n  const event2 = {\n    key: 'Z',\n    code: 'MetaLeft',\n    ctrlKey: false,\n    metaKey: true,\n    shiftKey: true,\n    preventDefault: () => {}\n  };\n\n  manager._handleKeyboardEvent(event2);\n\n  expect(redoSpy).toHaveBeenCalled();\n});",
    "i2_gpt-4o": "it(\"should redo an added imagetextdrawing to the PDF file using Keyboard shortcuts\", async () => {\n  const { AnnotationEditorUIManager } = await import(\"../../src/display/editor/tools.js\");\n  const eventBus = { _on: jest.fn() };\n  const pdfDocument = { annotationStorage: {}, filterFactory: {} };\n  const manager = new AnnotationEditorUIManager(null, eventBus, pdfDocument, null);\n\n  const redoSpy = jest.spyOn(manager, 'redo');\n  const keyboardEvent = new KeyboardEvent(\"keydown\", { key: \"Z\", metaKey: true, shiftKey: true });\n\n  manager.#boundKeydown(keyboardEvent);\n\n  expect(redoSpy).toHaveBeenCalled();\n});",
    "i2_llama-3.3-70b-versatile": "it(\"should redo an added imagetextdrawing to the PDF file using Keyboard shortcuts\", async () => {\n  const { AnnotationEditorUIManager, KeyboardManager } = await import(\"../../src/display/editor/tools.js\");\n  const { Util } = await import(\"../../shared/util.js\");\n  const eventBus = {\n    _on: jest.fn(),\n  };\n  const pdfDocument = {\n    annotationStorage: {},\n    filterFactory: {},\n  };\n  const pageColors = {};\n  const container = {};\n  const annotationEditorUIManager = new AnnotationEditorUIManager(container, eventBus, pdfDocument, pageColors);\n  const keyboardManager = KeyboardManager;\n  const redoSpy = jest.spyOn(AnnotationEditorUIManager.prototype, 'redo');\n  const keydownEvent = new KeyboardEvent('keydown', { key: 'z', ctrlKey: true, shiftKey: true, metaKey: true });\n  annotationEditorUIManager.keydown(keydownEvent);\n  expect(redoSpy).toHaveBeenCalledTimes(1);\n});",
    "i3_deepseek-r1-distill-llama-70b": "it(\"should redo an annotation using keyboard shortcuts\", async () => {\n  const { AnnotationEditorUIManager, CommandManager } = await import(\"../../src/display/editor/tools.js\");\n  const { AnnotationFactory, MarkupAnnotation } = await import(\"../../src/core/annotation.js\");\n\n  // Setup mock objects\n  const mockLayer = {\n    addOrRebuild: jest.fn(),\n    deserialize: jest.fn(),\n  };\n\n  const mockEditor = {\n    commit: jest.fn(),\n    isEmpty: jest.fn(() => false),\n    id: \"test-editor\",\n    pageIndex: 0,\n  };\n\n  const uiManager = new AnnotationEditorUIManager({\n    addEventListener: jest.fn(),\n    removeEventListener: jest.fn(),\n  }, {\n    _on: jest.fn(),\n    _off: jest.fn(),\n  }, {\n    annotationStorage: {\n      has: jest.fn(),\n      setValue: jest.fn(),\n      remove: jest.fn(),\n    }\n  }, {});\n\n  uiManager.currentLayer = mockLayer;\n  uiManager.addEditor(mockEditor);\n\n  // Add initial command\n  uiManager.addCommands({\n    cmd: () => {},\n    undo: () => {},\n  });\n\n  // Test undo first\n  uiManager.undo();\n  expect(uiManager.commandManager.position).toBe(0);\n\n  // Simulate redo keyboard event\n  const event = {\n    key: \"Z\",\n    ctrlKey: true,\n    shiftKey: true,\n    metaKey: true,\n  };\n\n  uiManager.keydown(event);\n\n  // Verify redo was executed\n  expect(uiManager.commandManager.position).toBe(1);\n});",
    "i3_gpt-4o": "it(\"should redo an added imagetextdrawing to the PDF file using Keyboard shortcuts\", async () => {\n  const { AnnotationEditorUIManager } = await import(\"../../src/display/editor/tools.js\");\n  const { EventBus } = await import(\"../../web/event_utils.js\");\n\n  const eventBus = new EventBus();\n  const container = document.createElement(\"div\");\n  const pdfDocument = { annotationStorage: new Map(), filterFactory: {} };\n  const manager = new AnnotationEditorUIManager(container, eventBus, pdfDocument, null);\n\n  manager.updateMode(AnnotationEditorType.FREETEXT);\n  manager.addCommands({\n    cmd: () => manager.addEditor({ id: \"editor1\", pageIndex: 0 }),\n    undo: () => manager.removeEditor({ id: \"editor1\" }),\n    mustExec: true,\n  });\n\n  manager.undo();\n  expect(manager.getEditor(\"editor1\")).toBeUndefined();\n\n  manager.redo();\n  expect(manager.getEditor(\"editor1\")).toBeDefined();\n});",
    "i3_llama-3.3-70b-versatile": "it(\"should redo an added imagetextdrawing to the PDF file using Keyboard shortcuts\", async () => {\n  const { AnnotationEditorUIManager, CommandManager, KeyboardManager } = await import(\"../../src/display/editor/tools.js\");\n  const { AnnotationEditorPrefix, AnnotationEditorType, Util } = await import(\"../../shared/util.js\");\n  const { DefaultCMapReaderFactory, DefaultStandardFontDataFactory } = await import(\"../../src/display/api.js\");\n\n  const container = { addEventListener: () => {}, removeEventListener: () => {} };\n  const eventBus = { _on: () => {}, _off: () => {}, dispatch: () => {} };\n  const pdfDocument = { annotationStorage: {}, filterFactory: {} };\n  const pageColors = {};\n\n  const annotationEditorUIManager = new AnnotationEditorUIManager(container, eventBus, pdfDocument, pageColors);\n\n  const editor = { id: Util.getUuid(), pageIndex: 0, isEmpty: () => false, commitOrRemove: () => {}, remove: () => {} };\n  annotationEditorUIManager.addEditor(editor);\n\n  annotationEditorUIManager.updateMode(AnnotationEditorType.FREE_TEXT);\n  annotationEditorUIManager.setSelected(editor);\n\n  const keyboardManager = new KeyboardManager([\n    [[\"ctrl+z\", \"mac+meta+z\"], annotationEditorUIManager.undo],\n    [[\"ctrl+y\", \"ctrl+shift+z\", \"mac+meta+shift+z\", \"ctrl+shift+Z\", \"mac+meta+shift+Z\"], annotationEditorUIManager.redo],\n  ]);\n\n  keyboardManager.exec(annotationEditorUIManager, { key: \"z\", ctrlKey: true });\n  expect(annotationEditorUIManager.getMode()).toBe(AnnotationEditorType.NONE);\n\n  keyboardManager.exec(annotationEditorUIManager, { key: \"y\", ctrlKey: true });\n  expect(annotationEditorUIManager.getMode()).toBe(AnnotationEditorType.FREE_TEXT);\n});",
    "i4_deepseek-r1-distill-llama-70b": "it(\"should redo an annotation using the new keyboard shortcuts\", async () => {\n  const { AnnotationEditorUIManager, CommandManager } = await import(\"../../src/display/editor/tools.js\");\n  const { AnnotationEditorLayer } = await import(\"../../src/display/editor/annotation_editor_layer.js\");\n\n  const container = { addEventListener: jest.fn(), removeEventListener: jest.fn() };\n  const eventBus = { _on: jest.fn(), _off: jest.fn(), dispatch: jest.fn() };\n  const pdfDocument = { annotationStorage: {} };\n  const pageColors = {};\n\n  const manager = new AnnotationEditorUIManager(container, eventBus, pdfDocument, pageColors);\n  const commandManager = manager.#commandManager;\n\n  // Add a sample annotation\n  const layer = new AnnotationEditorLayer(0, container, pdfDocument, pageColors);\n  manager.addLayer(layer);\n  layer.enterEditMode();\n\n  // Simulate adding an annotation\n  const addEvent = new CustomEvent(\"editingaction\", { detail: { name: \"add\" } });\n  await eventBus._on.mock.calls[0][1](addEvent);\n\n  // Verify annotation was added\n  expect(layer.editors.size).toBe(1);\n  const annotation = layer.editors.values().next().value;\n\n  // Undo the action\n  const undoEvent = new CustomEvent(\"editingaction\", { detail: { name: \"undo\" } });\n  await eventBus._on.mock.calls[0][1](undoEvent);\n  expect(layer.editors.size).toBe(0);\n\n  // Test redo with new shortcuts\n  const redoEvent1 = new KeyboardEvent(\"keydown\", {\n    bubbles: true,\n    cancelable: true,\n    keyCode: 90,\n    key: \"z\",\n    ctrlKey: true,\n    shiftKey: true,\n  });\n\n  const redoEvent2 = new KeyboardEvent(\"keydown\", {\n    bubbles: true,\n    cancelable: true,\n    keyCode: 90,\n    key: \"Z\",\n    metaKey: true,\n    shiftKey: true,\n  });\n\n  // Test first redo\n  container.dispatchEvent(redoEvent1);\n  await new Promise(process.nextTick);\n  expect(layer.editors.size).toBe(1);\n\n  // Test second redo\n  container.dispatchEvent(redoEvent2);\n  await new Promise(process.nextTick);\n  expect(layer.editors.size).toBe(1);\n});",
    "i4_gpt-4o": "it(\"should redo an added imagetextdrawing to the PDF file using Keyboard shortcuts\", async () => {\n  const { AnnotationEditorUIManager } = await import(\"../../src/display/editor/tools.js\");\n  const { EventBus } = await import(\"../../web/event_utils.js\");\n\n  const eventBus = new EventBus();\n  const container = document.createElement(\"div\");\n  const pdfDocument = { annotationStorage: new Map(), filterFactory: {} };\n  const manager = new AnnotationEditorUIManager(container, eventBus, pdfDocument, null);\n\n  let redoCalled = false;\n  manager.redo = () => { redoCalled = true; };\n\n  const keyboardEvent = new KeyboardEvent(\"keydown\", { key: \"y\", ctrlKey: true });\n  container.dispatchEvent(keyboardEvent);\n\n  expect(redoCalled).toBe(true);\n});",
    "i4_llama-3.3-70b-versatile": "it(\"should redo an added imagetextdrawing to the PDF file using Keyboard shortcuts\", async () => {\n  const { AnnotationEditorUIManager, CommandManager } = await import(\"../../src/display/editor/tools.js\");\n  const { KeyboardManager } = await import(\"../../src/display/editor/tools.js\");\n  const { AnnotationEditorPrefix, AnnotationEditorType } = await import(\"../../shared/util.js\");\n\n  const container = { addEventListener: () => {}, removeEventListener: () => {} };\n  const eventBus = { _on: () => {}, _off: () => {}, dispatch: () => {} };\n  const pdfDocument = { annotationStorage: {}, filterFactory: {} };\n  const pageColors = {};\n\n  const annotationEditorUIManager = new AnnotationEditorUIManager(container, eventBus, pdfDocument, pageColors);\n\n  const keyboardManager = new KeyboardManager([\n    [[\"ctrl+z\", \"mac+meta+z\"], annotationEditorUIManager.undo],\n    [[\"ctrl+y\", \"ctrl+shift+Z\", \"mac+meta+shift+Z\", \"ctrl+shift+z\", \"mac+meta+shift+z\"], annotationEditorUIManager.redo],\n  ]);\n\n  const cmd = () => {};\n  const undo = () => {};\n  annotationEditorUIManager.addCommands({ cmd, undo, mustExec: true });\n\n  annotationEditorUIManager.undo();\n  keyboardManager.exec(annotationEditorUIManager, { key: \"y\", ctrlKey: true });\n  expect(annotationEditorUIManager.getMode()).toBe(AnnotationEditorType.NONE);\n});",
    "i5_deepseek-r1-distill-llama-70b": "it(\"should redo an annotation using ctrlshiftZ\", async () => {\n  const { AnnotationEditorUIManager, CommandManager } = await import(\"../../src/display/editor/tools.js\");\n  const uiManager = new AnnotationEditorUIManager();\n  const commandManager = new CommandManager();\n\n  // Add an annotation\n  uiManager.addAnnotation(\"text\", { x: 10, y: 10, width: 100, height: 20 });\n\n  // Undo the annotation\n  commandManager.execute(\"undo\");\n\n  // Redo using the new shortcut\n  commandManager.execute(\"redo\");\n\n  // Verify the annotation was added back\n  expect(uiManager.getAnnotations().length).toBe(1);\n});",
    "i5_gpt-4o": "it(\"should redo an added imagetextdrawing to the PDF file using keyboard shortcuts\", async () => {\n  const { AnnotationEditorUIManager } = await import(\"../../src/display/editor/tools.js\");\n  const manager = new AnnotationEditorUIManager();\n\n  // Simulate adding an annotation\n  manager.addAnnotation({ type: \"text\", content: \"Sample Text\" });\n\n  // Perform undo operation\n  manager.undo();\n\n  // Check that the annotation is removed\n  let annotations = manager.getAnnotations();\n  expect(annotations.length).toBe(0);\n\n  // Perform redo operation using keyboard shortcut\n  const event = new KeyboardEvent(\"keydown\", { key: \"Z\", ctrlKey: true, shiftKey: true });\n  document.dispatchEvent(event);\n\n  // Check that the annotation is added back\n  annotations = manager.getAnnotations();\n  expect(annotations.length).toBe(1);\n  expect(annotations[0].content).toBe(\"Sample Text\");\n});",
    "i5_llama-3.3-70b-versatile": "it(\"should redo an added imagetextdrawing to the PDF file using Keyboard shortcuts\", async () => {\n  const { AnnotationEditorUIManager } = await import(\"../../src/display/editor/tools.js\");\n  const { PDFDocument } = await import(\"../../src/core/document.js\");\n  const { PDFFetchStream } = await import(\"../../src/display/fetch_stream.js\");\n\n  const pdf = await PDFDocument.load(await PDFFetchStream.fetch(\"test.pdf\"));\n  const annotationEditorUIManager = new AnnotationEditorUIManager(pdf);\n\n  annotationEditorUIManager.addEventListener(\"keydown\", (event) => {\n    if (event.ctrlKey && event.key === \"y\" || event.metaKey && event.shiftKey && (event.key === \"Z\" || event.key === \"z\")) {\n      annotationEditorUIManager.redo();\n    }\n  });\n\n  const initialAnnotations = annotationEditorUIManager.getAnnotations();\n  annotationEditorUIManager.addAnnotation({ type: \"text\", page: 1, x: 10, y: 10 });\n  annotationEditorUIManager.undo();\n  annotationEditorUIManager.redo();\n\n  const annotationsAfterRedo = annotationEditorUIManager.getAnnotations();\n\n  expect(annotationsAfterRedo.length).toBe(initialAnnotations.length + 1);\n});"
  },
  "16718": {
    "i1_deepseek-r1-distill-llama-70b": "it(\"should save annotations on PDFs with certain linearization\", async () => {\n  const { PDFDocument } = await import(\"../../src/display/api.js\");\n  const { buildGetDocumentParams } = await import(\"./test_utils.js\");\n  const loadingTask = getDocument(buildGetDocumentParams('bug1844572.pdf'));\n\n  const pdfDoc = await loadingTask.promise;\n  const firstPage = await pdfDoc.getPage(1);\n  const annotations = await firstPage.getAnnotations();\n  const newAnnotation = {\n    type: 0, // Text annotation\n    rect: [100, 100, 200, 200],\n    contents: \"Test annotation\"\n  };\n\n  await pdfDoc.addAnnotation(newAnnotation, 1);\n\n  const savedPdfBytes = await pdfDoc.save();\n  const loadedPdfDoc = await PDFDocument.load(savedPdfBytes);\n  const loadedPage = await loadedPdfDoc.getPage(1);\n  const loadedAnnotations = await loadedPage.getAnnotations();\n\n  if (!loadedAnnotations || loadedAnnotations.length === 0) {\n    throw new Error(\"Annotations not saved after PDF update\");\n  }\n});",
    "i1_gpt-4o": "it(\"should save PDF annotations correctly\", async () => {\n  const { getDocument } = await import(\"../../src/display/api.js\");\n  const { buildGetDocumentParams } = await import(\"./test_utils.js\");\n  const loadingTask = getDocument(buildGetDocumentParams(\"bug1844572.pdf\"));\n  const pdfDocument = await loadingTask.promise;\n  const page = await pdfDocument.getPage(1);\n  const annotations = await page.getAnnotations();\n\n  const annotationStorage = new Map();\n  annotations.forEach(annotation => {\n    annotationStorage.set(annotation.id, { value: \"Test\" });\n  });\n\n  const data = await pdfDocument.saveDocument({\n    annotationStorage,\n    filename: \"test.pdf\",\n  });\n\n  const savedDocument = await getDocument({ data }).promise;\n  const savedPage = await savedDocument.getPage(1);\n  const savedAnnotations = await savedPage.getAnnotations();\n\n  expect(savedAnnotations.some(a => a.value === \"Test\")).toBe(true);\n});",
    "i1_llama-3.3-70b-versatile": "it(\"should save PDF annotations correctly\", async () => {\n  const { getDocument } = await import('../../src/display/api.js');\n  const { buildGetDocumentParams } = await import('./test_utils.js');\n  const loadingTask = getDocument(buildGetDocumentParams('bug1844572.pdf'));\n  const pdfDoc = await loadingTask.promise;\n  const pdfPages = await pdfDoc.getPages();\n  const firstPage = await pdfPages[0];\n  const annotations = await firstPage.getAnnotations();\n  const annotationStorage = new Map();\n  annotationStorage.set(0, annotations);\n  const updatedPdf = await pdfDoc.saveDocument({ annotationStorage });\n  const expectedAnnotations = await firstPage.getAnnotations();\n  const actualAnnotations = await getDocument(buildGetDocumentParams(updatedPdf)).promise.getPages().then(pages => pages[0].getAnnotations());\n  expect(actualAnnotations.length).toBe(expectedAnnotations.length);\n});",
    "i2_deepseek-r1-distill-llama-70b": "it(\"should save annotations on PDFs with certain structures\", async () => {\n  const { getDocument } = await import('../../src/display/api.js');\n  const { buildGetDocumentParams } = await import('./test_utils.js');\n\n  const loadingTask = getDocument(buildGetDocumentParams('bug1844572.pdf'));\n  const { numPages, fingerprint } = await loadingTask.promise;\n\n  const page = await loadingTask.doc.getPage(0);\n  const annotations = await page.getAnnotationsData();\n  const newAnnotation = {\n    type: 'text',\n    content: 'Test Annotation',\n    x: 10,\n    y: 10,\n  };\n\n  await page.addAnnotation(newAnnotation);\n  const updatedDoc = await loadingTask.doc.saveDocument();\n\n  const loadedDoc = await getDocument({\n    data: updatedDoc,\n    password: null,\n  });\n\n  const loadedPage = await loadedDoc.getPage(0);\n  const loadedAnnotations = await loadedPage.getAnnotationsData();\n\n  expect(loadedAnnotations.length).toBe(annotations.length + 1);\n});",
    "i2_llama-3.3-70b-versatile": "it(\"should save PDF annotations correctly\", async () => {\n  const { getDocument } = await import('../../src/display/api.js');\n  const { buildGetDocumentParams } = await import('./test_utils.js');\n  const loadingTask = getDocument(buildGetDocumentParams('bug1844572.pdf'));\n  const pdfDoc = await loadingTask.promise;\n  const pdfPages = await pdfDoc.getPages();\n  const firstPage = pdfPages[0];\n  const annotations = await firstPage.getAnnotations();\n  const annotationStorage = new Map();\n  for (const annotation of annotations) {\n    annotationStorage.set(annotation.id, annotation);\n  }\n  const updatedPdf = await pdfDoc.saveDocument({ annotationStorage });\n  const updatedLoadingTask = getDocument(buildGetDocumentParams(updatedPdf));\n  const updatedPdfDoc = await updatedLoadingTask.promise;\n  const updatedPdfPages = await updatedPdfDoc.getPages();\n  const updatedFirstPage = updatedPdfPages[0];\n  const updatedAnnotations = await updatedFirstPage.getAnnotations();\n  expect(updatedAnnotations.length).toBe(annotations.length);\n});",
    "i3_deepseek-r1-distill-llama-70b": "it(\"should save annotations on linearized PDFs\", async () => {\n  const { getDocument } = await import(\"../../src/display/api.js\");\n  const { buildGetDocumentParams } = await import(\"./test_utils.js\");\n  const loadingTask = getDocument(buildGetDocumentParams('bug1844572.pdf'));\n\n  const { numPages } = await loadingTask.promise;\n  const page = await loadingTask.getDocument().getPage(0);\n  const annotations = [\n    {\n      type: \"highlight\",\n      quads: [[0, 0, 100, 0, 100, 100, 0, 100]],\n      color: \"#FF0000\",\n      content: \"Test annotation\"\n    }\n  ];\n\n  const savedData = await page.saveAnnotations(annotations);\n  const expectedPattern = /\\/Annots\\s*\\[\\s*<</s*.*?>>\\s*\\]/;\n\n  expect(bytesToString(savedData)).toMatch(expectedPattern);\n});",
    "i3_llama-3.3-70b-versatile": "it(\"should save annotations correctly in certain PDFs\", async () => {\n  const { getDocument } = await import('../../src/display/api.js');\n  const { buildGetDocumentParams } = await import('./test_utils.js');\n  const loadingTask = getDocument(buildGetDocumentParams('bug1844572.pdf'));\n  const pdf = await loadingTask.promise;\n  const page = await pdf.getPage(1);\n  const annotations = await page.getAnnotations();\n  const annotationStorage = new Map();\n  annotations.forEach(annotation => annotationStorage.set(annotation.id, annotation));\n  const updatedPdf = await pdf.saveDocument({ annotationStorage });\n  const updatedPage = await updatedPdf.getPage(1);\n  const updatedAnnotations = await updatedPage.getAnnotations();\n  expect(updatedAnnotations.length).toBe(annotations.length);\n});",
    "i4_deepseek-r1-distill-llama-70b": "it(\"should save annotations in certain PDFs\", async () => {\n  const { getDocument } = await import(\"../../src/display/api.js\");\n  const { buildGetDocumentParams } = await import(\"./test_utils.js\");\n\n  const loadingTask = getDocument(buildGetDocumentParams(\"bug1844572.pdf\"));\n  const pdf = await loadingTask.promise;\n\n  const annotation = {\n    type: \"text\",\n    pages: [0],\n    content: \"Test annotation\",\n  };\n\n  const firstPage = (await pdf.getPages([0])).shift();\n  const annotations = await firstPage.getAnnotationsData();\n  await firstPage.addAnnotation(annotation);\n\n  const newDoc = await pdf.save();\n  const reloadedPdf = await getDocument({\n    ...buildGetDocumentParams(\"bug1844572.pdf\"),\n    data: newDoc,\n  });\n\n  const reloadedPages = await reloadedPdf.getPages([0]);\n  const reloadedAnnotations = await reloadedPages.shift().getAnnotationsData();\n\n  expect(reloadedAnnotations.length).toBeGreaterThan(0);\n});",
    "i4_gpt-4o": "it(\"should save PDF annotations correctly\", async () => {\n  const { getDocument } = await import(\"../../src/display/api.js\");\n  const { buildGetDocumentParams } = await import(\"./test_utils.js\");\n  const loadingTask = getDocument(buildGetDocumentParams(\"bug1844572.pdf\"));\n  const pdfDocument = await loadingTask.promise;\n  const page = await pdfDocument.getPage(1);\n  const annotations = await page.getAnnotations();\n  const annotationStorage = new Map();\n  annotations.forEach(annotation => {\n    annotationStorage.set(annotation.id, { value: \"Test\" });\n  });\n  const data = await pdfDocument.saveDocument({\n    annotationStorage,\n    filename: \"test.pdf\",\n  });\n  const savedDocument = await getDocument({ data }).promise;\n  const savedPage = await savedDocument.getPage(1);\n  const savedAnnotations = await savedPage.getAnnotations();\n  const expected = annotations.map(a => ({ ...a, value: \"Test\" }));\n  expect(savedAnnotations).toEqual(expected);\n});",
    "i4_llama-3.3-70b-versatile": "it(\"should save PDF annotations correctly\", async () => {\n  const { getDocument } = await import('../../src/display/api.js');\n  const { buildGetDocumentParams } = await import('./test_utils.js');\n  const loadingTask = getDocument(buildGetDocumentParams('bug1844572.pdf'));\n  const pdf = await loadingTask.promise;\n  const page = await pdf.getPage(1);\n  const annotations = await page.getAnnotations();\n  const annotationStorage = new Map();\n  annotations.forEach(annotation => annotationStorage.set(annotation.id, annotation));\n  const newAnnotations = Array.from(annotationStorage.values());\n  const updatedPdf = await pdf.saveDocument({ annotationStorage: newAnnotations });\n  const updatedPage = await updatedPdf.getPage(1);\n  const updatedAnnotations = await updatedPage.getAnnotations();\n  expect(updatedAnnotations.length).toBe(annotations.length);\n});",
    "i5_deepseek-r1-distill-llama-70b": "it(\"should save annotations on PDFs with linearization\", async () => {\n  const { getDocument } = await import(\"../../src/display/api.js\");\n  const { buildGetDocumentParams } = await import(\"./test_utils.js\");\n\n  // Load the PDF with the issue\n  const loadingTask = getDocument(buildGetDocumentParams('bug1844572.pdf'));\n  const pdfDocument = await loadingTask.promise;\n\n  // Create a new annotation\n  const annotation = {\n    type: \"annotation\",\n    subtype: \"widget\",\n    page: 0,\n    rect: [100, 100, 200, 200],\n    flags: [\"hidden\"],\n    fieldFlags: 1,\n    name: \"testWidget\",\n    value: \"Test Value\"\n  };\n\n  // Add and save the annotation\n  const saveTask = pdfDocument.addAnnotation(annotation).then(() => pdfDocument.save());\n  await expect(saveTask).resolves.not.toThrow();\n\n  // Reload the PDF to verify the annotation was saved\n  const reloadTask = getDocument(buildGetDocumentParams('bug1844572.pdf'));\n  const reloadedDocument = await reloadTask.promise;\n  const annotations = await reloadedDocument.getAnnotations({ page: 0 });\n\n  // Verify the annotation exists after reload\n  expect(annotations).toHaveLength(1);\n});",
    "i5_gpt-4o": "it(\"should save PDF annotations correctly on bugpdf\", async () => {\n  const { getDocument } = await import('../../src/display/api.js');\n  const { buildGetDocumentParams } = await import('./test_utils.js');\n  const loadingTask = getDocument(buildGetDocumentParams('bug1844572.pdf'));\n  const pdfDocument = await loadingTask.promise;\n  const page = await pdfDocument.getPage(1);\n  const annotations = await page.getAnnotations();\n  const expectedAnnotationCount = 1; // Assuming there's one annotation to check\n  const actualAnnotationCount = annotations.length;\n  expect(actualAnnotationCount).toBe(expectedAnnotationCount);\n});",
    "i5_llama-3.3-70b-versatile": "it(\"should save PDF annotations on certain PDFs\", async () => {\n  const { getDocument } = await import('../../src/display/api.js');\n  const { buildGetDocumentParams } = await import('./test_utils.js');\n  const loadingTask = getDocument(buildGetDocumentParams('bug1844572.pdf'));\n  const pdfDoc = await loadingTask.promise;\n  const firstPage = pdfDoc.getPage(1);\n  const annotations = await firstPage.getAnnotations();\n  const annotation = annotations[0];\n  annotation.setFlags(2); // Set the hidden flag\n  const pdfBytes = await pdfDoc.save();\n  const loadedPdfDoc = await getDocument({ data: pdfBytes }).promise;\n  const loadedFirstPage = await loadedPdfDoc.getPage(1);\n  const loadedAnnotations = await loadedFirstPage.getAnnotations();\n  const loadedAnnotation = loadedAnnotations[0];\n  const expectedFlags = 2;\n  const actualFlags = loadedAnnotation.flags;\n  expect(actualFlags).toBe(expectedFlags);\n});"
  },
  "16719": {
    "i1_deepseek-r1-distill-llama-70b": "it(\"should delete selected annotation when pressing Delete on Mac\", async () => {\n  const { AnnotationEditorUIManager, AnnotationEditorLayer } = await import(\"../../src/display/editor/tools.js\");\n  const { Annotation, MarkupAnnotation } = await import(\"../../src/core/annotation.js\");\n\n  // Mock the necessary objects\n  const pdfDocument = {\n    annotationStorage: {\n      getAnnotations: () => [],\n      addAnnotation: jest.fn(),\n      removeAnnotation: jest.fn(),\n    },\n    filterFactory: {},\n  };\n\n  const eventBus = {\n    _on: jest.fn(),\n    _off: jest.fn(),\n  };\n\n  const container = document.createElement(\"div\");\n  const pageColors = {};\n\n  // Initialize the AnnotationEditorUIManager\n  const annotationEditorUIManager = new AnnotationEditorUIManager(\n    container,\n    eventBus,\n    pdfDocument,\n    pageColors\n  );\n\n  // Create an AnnotationEditorLayer\n  const annotationEditorLayer = new AnnotationEditorLayer();\n  annotationEditorUIManager.#activeEditor = annotationEditorLayer;\n\n  // Create a test annotation\n  const annotation = new MarkupAnnotation({\n    id: \"test-annotation\",\n    type: \"highlight\",\n    color: \"#ff0000\",\n    page: 1,\n  });\n\n  // Add the annotation to storage\n  pdfDocument.annotationStorage.addAnnotation(annotation);\n\n  // Select the annotation\n  annotationEditorLayer.selectAnnotation(annotation.id);\n\n  // Simulate Mac Delete key press\n  const deleteEvent = new KeyboardEvent(\"keydown\", {\n    key: \"Delete\",\n    keyCode: 46,\n    metaKey: true,\n  });\n\n  // Trigger the keydown handler\n  annotationEditorUIManager.keydown(deleteEvent);\n\n  // Verify the annotation was removed\n  expect(pdfDocument.annotationStorage.removeAnnotation).toHaveBeenCalled();\n});",
    "i1_gpt-4o": "it(\"should delete the selected element when pressing the Delete key on macOS\", async () => {\n  const { AnnotationEditorUIManager } = await import(\"../../src/display/editor/tools.js\");\n  const eventBus = { _on: () => {} };\n  const pdfDocument = { annotationStorage: {}, filterFactory: {} };\n  const manager = new AnnotationEditorUIManager(null, eventBus, pdfDocument, null);\n  const deleteSpy = jest.spyOn(manager, 'delete');\n\n  manager.#selectedEditors.add(\"testElement\");\n  const event = new KeyboardEvent(\"keydown\", { key: \"Delete\", metaKey: true });\n  manager.keydown(event);\n\n  expect(deleteSpy).toHaveBeenCalled();\n});",
    "i1_llama-3.3-70b-versatile": "it(\"should delete the selected element when pressing the Delete key\", async () => {\n  const { AnnotationEditorUIManager } = await import(\"../../src/display/editor/tools.js\");\n  const { Annotation } = await import(\"../../src/core/annotation.js\");\n  const { createIdFactory } = await import(\"./test_utils.js\");\n  const idFactory = createIdFactory();\n  const annotation = new Annotation({\n    subtype: \"Highlight\",\n    rect: [10, 10, 20, 20],\n    page: 1,\n    id: idFactory.next(),\n  });\n  const annotationEditorUIManager = new AnnotationEditorUIManager({\n    addEventListener: () => {},\n    removeEventListener: () => {},\n  }, {\n    _on: () => {},\n  }, {\n    annotationStorage: {\n      getAnnotations: () => [annotation],\n    },\n  }, {});\n  annotationEditorUIManager.#selectedEditors.add(annotation);\n  const deleteSpy = jest.spyOn(annotationEditorUIManager, \"delete\");\n  annotationEditorUIManager.keydown({\n    key: \"Delete\",\n    preventDefault: () => {},\n  });\n  expect(deleteSpy).toHaveBeenCalledTimes(1);\n});",
    "i2_deepseek-r1-distill-llama-70b": "it(\"should delete selected annotation when Delete key is pressed on macOS\", async () => {\n  const { PDFDocument, Annotation } = await import(\"../../src/core/document.js\");\n  const { buildGetDocumentParams } = await import(\"./test_utils.js\");\n\n  // Create a PDF document with one page containing an annotation\n  const pdfDoc = await PDFDocument.load(\n    buildGetDocumentParams(\"test.pdf\", new Uint8Array())\n  );\n  const page = (await pdfDoc.getPage(1));\n  const annotation = new Annotation();\n  page.addAnnotation(annotation);\n\n  // Set up the annotation editor\n  const editorManager = new AnnotationEditorUIManager(\n    document.createElement(\"div\"),\n    {\n      _on: () => {},\n      _off: () => {},\n      _dispatch: () => {},\n    },\n    pdfDoc,\n    new Map()\n  );\n\n  // Select the annotation\n  editorManager.selectAnnotation(annotation);\n\n  // Simulate pressing Delete key on macOS (meta + Delete)\n  const event = new KeyboardEvent(\"keydown\", {\n    key: \"Delete\",\n    code: \"Delete\",\n    metaKey: true,\n  });\n\n  // Dispatch the event\n  editorManager.element.dispatchEvent(event);\n\n  // Verify that the annotation was deleted\n  expect(page.getAnnotations().length).toBe(0);\n});",
    "i2_gpt-4o": "it(\"should delete the selected element when pressing the Delete key\", async () => {\n  const { AnnotationEditorUIManager } = await import(\"../../src/display/editor/tools.js\");\n  const { EventBus } = await import(\"../../web/event_utils.js\");\n\n  const container = document.createElement(\"div\");\n  const eventBus = new EventBus();\n  const pdfDocument = { annotationStorage: {}, filterFactory: {} };\n  const pageColors = null;\n\n  const manager = new AnnotationEditorUIManager(container, eventBus, pdfDocument, pageColors);\n  manager.#selectedEditors.add(\"editor1\");\n  manager.#allEditors.set(\"editor1\", { id: \"editor1\" });\n\n  const initialSelectedEditorsSize = manager.#selectedEditors.size;\n  const initialAllEditorsSize = manager.#allEditors.size;\n\n  const deleteEvent = new KeyboardEvent(\"keydown\", { key: \"Delete\" });\n  container.dispatchEvent(deleteEvent);\n\n  const finalSelectedEditorsSize = manager.#selectedEditors.size;\n  const finalAllEditorsSize = manager.#allEditors.size;\n\n  expect(finalSelectedEditorsSize).toBe(initialSelectedEditorsSize - 1);\n  expect(finalAllEditorsSize).toBe(initialAllEditorsSize - 1);\n});",
    "i2_llama-3.3-70b-versatile": "it(\"should delete the selected element when pressing the Delete key\", async () => {\n  const { AnnotationEditorUIManager, Util, KeyboardManager } = await import(\"../../src/display/editor/tools.js\");\n  const { PDFDocument, Page } = await import(\"../../src/core/document.js\");\n  const { AnnotationStorage } = await import(\"../../src/display/annotation_storage.js\");\n  const { EventBus } = await import(\"../../web/event_utils.js\");\n  const { PDFPageView } = await import(\"../../web/pdf_page_view.js\");\n\n  const pdfDocument = new PDFDocument({\n    data: new Uint8Array(),\n    fingerprint: '',\n    url: '',\n    length: 0,\n  });\n  const annotationStorage = new AnnotationStorage();\n  const eventBus = new EventBus();\n  const pageView = new PDFPageView({\n    pdfDocument,\n    annotationStorage,\n    eventBus,\n  });\n  const container = {};\n  const pageColors = {};\n  const annotationEditorUIManager = new AnnotationEditorUIManager(container, eventBus, pdfDocument, pageColors);\n\n  const selectedEditor = {};\n  annotationEditorUIManager.#selectedEditors.add(selectedEditor);\n\n  const keyboardEvent = {\n    key: 'Delete',\n    preventDefault: () => {},\n  };\n\n  const deleteSpy = jest.spyOn(annotationEditorUIManager, 'delete');\n\n  annotationEditorUIManager.keydown(keyboardEvent);\n\n  expect(deleteSpy).toHaveBeenCalledTimes(1);\n});",
    "i3_deepseek-r1-distill-llama-70b": "it(\"should delete selected annotation when pressing Delete key\", async () => {\n  const { AnnotationEditorUIManager, Annotation } = await import(\"../../src/display/editor/tools.js\");\n  const { AnnotationFactory } = await import(\"../../src/core/annotation.js\");\n\n  const pdfDocument = {\n    annotationStorage: new Map(),\n    filterFactory: {},\n  };\n\n  const annotation = AnnotationFactory.create(AnnotationType.UNDERLINE, {\n    color: [1, 0, 0],\n    page: 1,\n    quads: [[0, 0, 10, 10]],\n  });\n\n  pdfDocument.annotationStorage.setValue(annotation.id, annotation);\n\n  const manager = new AnnotationEditorUIManager({}, {}, pdfDocument, {});\n\n  manager.updateMode(AnnotationEditorType.UNDERLINE);\n\n  const editor = manager.getEditor(annotation.id);\n  manager.setSelected(editor);\n\n  // Test non-mac Delete\n  {\n    const event = new KeyboardEvent('keydown', {\n      key: 'Delete',\n      bubbles: true,\n      cancelable: true,\n    });\n    FeatureTest.platform.isMac = false;\n    manager.keydown(event);\n    expect(pdfDocument.annotationStorage.has(annotation.id)).toBe(false);\n  }\n\n  // Test mac Delete\n  {\n    const event = new KeyboardEvent('keydown', {\n      key: 'Delete',\n      metaKey: true,\n      bubbles: true,\n      cancelable: true,\n    });\n    FeatureTest.platform.isMac = true;\n    manager.keydown(event);\n    expect(pdfDocument.annotationStorage.has(annotation.id)).toBe(false);\n  }\n});",
    "i3_gpt-4o": "it(\"should delete the selected element when pressing the Delete key on macOS\", async () => {\n  const { AnnotationEditorUIManager } = await import(\"../../src/display/editor/tools.js\");\n  const { EventBus } = await import(\"../../web/event_utils.js\");\n\n  const eventBus = new EventBus();\n  const container = document.createElement(\"div\");\n  const pdfDocument = { annotationStorage: new Map(), filterFactory: {} };\n  const manager = new AnnotationEditorUIManager(container, eventBus, pdfDocument, null);\n\n  const editor = { id: \"editor1\", remove: jest.fn(), isEmpty: () => false };\n  manager.addEditor(editor);\n  manager.setSelected(editor);\n\n  const deleteEvent = new KeyboardEvent(\"keydown\", { key: \"Delete\", metaKey: true });\n  container.dispatchEvent(deleteEvent);\n\n  expect(editor.remove).toHaveBeenCalled();\n});",
    "i3_llama-3.3-70b-versatile": "it(\"should delete the selected element when pressing the Delete key\", async () => {\n  const { AnnotationEditorUIManager, KeyboardManager } = await import(\"../../src/display/editor/tools.js\");\n  const { AnnotationEditorPrefix, AnnotationEditorType, Util } = await import(\"../../shared/util.js\");\n  const annotationEditorUIManager = new AnnotationEditorUIManager(null, null, null, null);\n  const editor = { id: Util.getUuid(), remove: jest.fn() };\n  annotationEditorUIManager.addEditor(editor);\n  annotationEditorUIManager.setSelected(editor);\n  const keyboardManager = annotationEditorUIManager.constructor._keyboardManager;\n  const event = new KeyboardEvent(\"keydown\", { key: \"Delete\" });\n  keyboardManager.exec(annotationEditorUIManager, event);\n  expect(editor.remove).toHaveBeenCalledTimes(1);\n});",
    "i4_deepseek-r1-distill-llama-70b": "it(\"should delete selected element when pressing Delete key on macOS\", async () => {\n  const { AnnotationEditorUIManager, KeyboardManager } = await import(\"../../src/display/editor/tools.js\");\n  const { PDFDocument } = await import(\"../../src/display/api.js\");\n\n  const eventBus = {\n    _on: jest.fn(),\n    _off: jest.fn(),\n    dispatch: jest.fn(),\n  };\n\n  const pdfDocument = new PDFDocument({\n    numPages: 1,\n    firstPage: () => ({}),\n  });\n\n  const pageColors = {};\n  const container = document.createElement(\"div\");\n\n  const manager = new AnnotationEditorUIManager(container, eventBus, pdfDocument, pageColors);\n  const editor = {\n    id: \"test-editor\",\n    select: jest.fn(),\n    unselect: jest.fn(),\n    remove: jest.fn(),\n    commitOrRemove: jest.fn(),\n    isEmpty: jest.fn().mockReturnValue(false),\n  };\n\n  manager.addEditor(editor);\n  manager.setSelected(editor);\n\n  const event = {\n    key: \"Delete\",\n    metaKey: true,\n    preventDefault: jest.fn(),\n    stopPropagation: jest.fn(),\n  };\n\n  manager.keydown(event);\n\n  expect(editor.remove).toHaveBeenCalled();\n});",
    "i4_gpt-4o": "it(\"should delete the selected element when pressing the Delete key on macOS\", async () => {\n  const { AnnotationEditorUIManager } = await import(\"../../src/display/editor/tools.js\");\n  const { EventBus } = await import(\"../../web/event_utils.js\");\n\n  const container = document.createElement(\"div\");\n  const eventBus = new EventBus();\n  const pdfDocument = { annotationStorage: new Map(), filterFactory: {} };\n  const pageColors = null;\n\n  const manager = new AnnotationEditorUIManager(container, eventBus, pdfDocument, pageColors);\n  manager.updateMode(1); // Enable editing mode\n\n  const editor = { id: \"editor1\", remove: jest.fn(), isEmpty: () => false };\n  manager.addEditor(editor);\n  manager.setSelected(editor);\n\n  const deleteEvent = new KeyboardEvent(\"keydown\", { key: \"Delete\", metaKey: true });\n  container.dispatchEvent(deleteEvent);\n\n  expect(editor.remove).toHaveBeenCalled();\n});",
    "i4_llama-3.3-70b-versatile": "it(\"should delete the selected element when pressing the Delete key\", async () => {\n  const { AnnotationEditorUIManager, AnnotationEditorLayer } = await import(\"../../src/display/editor/tools.js\");\n  const { PDFDocument, Page } = await import(\"../../src/core/document.js\");\n  const { AnnotationStorage } = await import(\"../../src/display/annotation_storage.js\");\n  const { EventBus } = await import(\"../../web/event_utils.js\");\n\n  const eventBus = new EventBus();\n  const annotationStorage = new AnnotationStorage();\n  const pdfDocument = new PDFDocument({\n    numPages: 1,\n    fingerprint: \"\",\n    get page(index) {\n      return new Page({\n        pdfDocument,\n        index,\n        rotate: 0,\n        ref: \"\",\n        viewport: null,\n      });\n    },\n  });\n  const pageColors = { foreground: null, background: null };\n  const annotationEditorUIManager = new AnnotationEditorUIManager(null, eventBus, pdfDocument, pageColors);\n  const annotationEditorLayer = new AnnotationEditorLayer(0, pdfDocument, annotationStorage, eventBus);\n  annotationEditorUIManager.addLayer(annotationEditorLayer);\n  const editor = annotationEditorLayer.createEditor();\n  annotationEditorUIManager.addEditor(editor);\n  annotationEditorUIManager.setSelected(editor);\n\n  const deleteSpy = jest.spyOn(editor, \"remove\");\n  annotationEditorUIManager.keydown({ key: \"Delete\" });\n  expect(deleteSpy).toHaveBeenCalledTimes(1);\n});",
    "i5_deepseek-r1-distill-llama-70b": "it(\"should delete selected annotation when Delete key is pressed on macOS\", async () => {\n  const { PDFDocument } = await import(\"../../src/core/document.js\");\n  const { Annotation } = await import(\"../../src/core/annotation.js\");\n  const { AnnotationEditorUIManager } = await import(\"../../src/display/editor/tools.js\");\n\n  // Load test PDF\n  const pdf = await PDFDocument.load(await fetch(\"test.pdf\").then(res => res.arrayBuffer()));\n\n  // Create annotation\n  const annotation = new Annotation({\n    type: Annotation.Type.MARKUP,\n    subtype: Annotation.Type.UNDERLINE,\n    quads: [[10, 10, 20, 10, 20, 20, 10, 20]],\n    page: 0\n  });\n\n  // Add annotation to first page\n  const page = await pdf.getPage(1);\n  page.addAnnotation(annotation);\n\n  // Set up UI manager\n  const uiManager = new AnnotationEditorUIManager({\n    document: pdf,\n    page: page,\n    annotation: annotation,\n    container: document.createElement('div')\n  });\n\n  // Simulate Delete key press on macOS\n  const event = new KeyboardEvent('keydown', {\n    key: 'Delete',\n    keyCode: 8, // Mac Delete key code\n    isComposing: false\n  });\n\n  // Trigger the keydown event\n  uiManager.container.dispatchEvent(event);\n\n  // Verify annotation was removed\n  expect(page.getAnnotations().length).toBe(0);\n});",
    "i5_gpt-4o": "it(\"should delete the selected element when pressing the Delete key on macOS\", async () => {\n  const { AnnotationEditorUIManager } = await import(\"../../src/display/editor/tools.js\");\n  const uiManager = new AnnotationEditorUIManager();\n  const mockDeleteFunction = jest.fn();\n  uiManager.delete = mockDeleteFunction;\n\n  const event = new KeyboardEvent(\"keydown\", { key: \"Delete\", metaKey: true });\n  document.dispatchEvent(event);\n\n  expect(mockDeleteFunction).toHaveBeenCalled();\n});",
    "i5_llama-3.3-70b-versatile": "it(\"should delete the selected element when pressing the Delete key on a Mac\", async () => {\n  const { AnnotationEditorUIManager } = await import(\"../../src/display/editor/tools.js\");\n  const { PDFDocument, Page } = await import(\"../../src/core/document.js\");\n  const { AnnotationLayer } = await import(\"../../src/display/annotation_layer.js\");\n  const { PDFPageProxy } = await import(\"../../src/display/api.js\");\n\n  const pdfDocument = await PDFDocument.load(await (await import(\"../../src/display/fetch_stream.js\")).PDFFetchStream.fetch(\"path_to_pdf\"));\n  const pdfPage = pdfDocument.getPage(1);\n  const pageProxy = new PDFPageProxy(pdfDocument, pdfPage);\n  const annotationLayer = new AnnotationLayer({\n    pageProxy: pageProxy,\n    viewport: await pageProxy.getViewport(1),\n  });\n  const annotationEditorUIManager = new AnnotationEditorUIManager({\n    annotationLayer: annotationLayer,\n    pageProxy: pageProxy,\n  });\n\n  const deleteKey = \"mac+Delete\";\n  const expected = true;\n\n  annotationEditorUIManager.selectAnnotation(0);\n  annotationEditorUIManager.handleKeyDown({ key: deleteKey });\n  const actual = annotationEditorUIManager.getSelectedAnnotations().length === 0;\n\n  expect(actual).toBe(expected);\n});"
  },
  "16722": {
    "i1_deepseek-r1-distill-llama-70b": "it(\"should render poster PDFs more efficiently\", async () => {\n  const { getDocument } = await import(\"../../src/display/api.js\");\n  const { PDFWorkerUtil } = await import(\"../../src/display/worker_utils.js\");\n  const { buildGetDocumentParams } = await import(\"./test_utils.js\");\n\n  // Load a sample PDF with poster-like content\n  const pdfPath = buildGetDocumentParams(\"hello.pdf\");\n  const pdfDoc = await getDocument(pdfPath);\n  const page = await pdfDoc.getPage(1);\n  const viewport = page.getViewport({ scale: 1 });\n\n  // Measure rendering performance\n  const startTime = Date.now();\n  await PDFWorkerUtil.renderPage(page);\n  const renderTime = Date.now() - startTime;\n\n  // Verify that rendering is efficient (threshold can be adjusted)\n  expect(renderTime).toBeLessThan(500);\n});",
    "i1_gpt-4o": "it(\"should render poster PDF without slow performance due to filter settings\", async () => {\n  const { getDocument } = await import(\"../../src/display/api.js\");\n  const { DefaultCanvasFactory } = await import(\"../../src/display/api.js\");\n\n  const loadingTask = getDocument(buildGetDocumentParams(\"poster.pdf\"));\n  const pdfDocument = await loadingTask.promise;\n  const page = await pdfDocument.getPage(1);\n\n  const canvasFactory = new DefaultCanvasFactory();\n  const viewport = page.getViewport({ scale: 1.0 });\n  const canvasAndContext = canvasFactory.create(viewport.width, viewport.height);\n  const renderContext = {\n    canvasContext: canvasAndContext.context,\n    viewport: viewport,\n  };\n\n  const renderTask = page.render(renderContext);\n  const renderPromise = renderTask.promise;\n\n  const startTime = performance.now();\n  await renderPromise;\n  const endTime = performance.now();\n\n  const renderTime = endTime - startTime;\n  const expectedMaxRenderTime = 2000; // 2 seconds as an arbitrary threshold for acceptable performance\n  expect(renderTime).toBeLessThan(expectedMaxRenderTime);\n\n  canvasFactory.destroy(canvasAndContext);\n  await loadingTask.destroy();\n});",
    "i1_llama-3.3-70b-versatile": "it(\"should render poster PDF without significant delay\", async () => {\n  const { getDocument } = await import(\"../../src/display/api.js\");\n  const { buildGetDocumentParams } = await import(\"./test_utils.js\");\n  const params = buildGetDocumentParams(`${TEST_PDFS_PATH}/poster.pdf`);\n  const pdfDoc = await getDocument(params);\n  const pdfPage = await pdfDoc.getPage(1);\n  const viewport = pdfPage.getViewport({ scale: 1 });\n  const canvas = document.createElement(\"canvas\");\n  canvas.width = viewport.width;\n  canvas.height = viewport.height;\n  const ctx = canvas.getContext(\"2d\");\n  const renderTask = pdfPage.render({\n    canvasContext: ctx,\n    viewport,\n  });\n  const startTime = performance.now();\n  await renderTask.promise;\n  const endTime = performance.now();\n  const renderTime = endTime - startTime;\n  expect(renderTime).toBeLessThan(500);\n});",
    "i2_deepseek-r1-distill-llama-70b": "it(\"should not set filter unnecessarily\", async () => {\n  const { Util } = await import(\"../../src/shared/util.js\");\n  const { CanvasGraphics } = await import(\"../../src/display/canvas.js\");\n\n  class MockCanvasContext {\n    constructor() {\n      this.filter = \"none\";\n      this.setFilterCalls = 0;\n    }\n\n    setFilter(value) {\n      this.setFilterCalls++;\n      this.filter = value;\n    }\n\n    save() {}\n    restore() {}\n    scale() {}\n    imageSmoothingEnabled = false;\n    fillText() {}\n    drawImage() {}\n    compose() {}\n  }\n\n  // Test setup\n  const ctx = new MockCanvasContext();\n  const canvasGraphics = new CanvasGraphics(\n    ctx,\n    {},\n    {},\n    () => ctx,\n    () => {},\n    {},\n    {},\n    {}\n  );\n\n  // Test resetCtxToDefault behavior\n  ctx.filter = \"none\";\n  Util.isNodeJS = false;\n  resetCtxToDefault(ctx);\n  expect(ctx.setFilterCalls).toBe(0);\n\n  // Test paintInlineImageXObject behavior\n  ctx.filter = \"blur(5px)\";\n  const imgData = { width: 10, height: 10 };\n  canvasGraphics.paintInlineImageXObject(imgData);\n  expect(ctx.setFilterCalls).toBe(1);\n\n  ctx.filter = \"none\";\n  canvasGraphics.paintInlineImageXObject(imgData);\n  expect(ctx.setFilterCalls).toBe(1);\n});",
    "i2_gpt-4o": "it(\"should not change the filter to none unnecessarily\", async () => {\n  const { PDFDocumentProxy, getDocument } = await import(\"../../src/display/api.js\");\n  const { DOMCanvasFactory } = await import(\"../../src/display/display_utils.js\");\n\n  const loadingTask = getDocument({ url: \"path/to/test-poster.pdf\" });\n  const pdfDocument = await loadingTask.promise;\n  const page = await pdfDocument.getPage(1);\n\n  const canvasFactory = new DOMCanvasFactory();\n  const canvasAndContext = canvasFactory.create(1000, 1000);\n  const renderContext = {\n    canvasContext: canvasAndContext.context,\n    viewport: page.getViewport({ scale: 1.0 }),\n    canvasFactory,\n  };\n\n  const renderTask = page.render(renderContext);\n  await renderTask.promise;\n\n  const filterBefore = canvasAndContext.context.filter;\n  canvasAndContext.context.filter = \"blur(5px)\";\n  const filterAfter = canvasAndContext.context.filter;\n\n  expect(filterBefore).toBe(\"none\");\n  expect(filterAfter).toBe(\"blur(5px)\");\n});",
    "i2_llama-3.3-70b-versatile": "it(\"should not change the filter when its already none\", async () => {\n  const { CanvasGraphics } = await import(\"../../src/display/canvas.js\");\n  const { Util } = await import(\"../../src/shared/util.js\");\n  const canvas = {\n    getContext: () => ({\n      filter: \"none\",\n      setLineDash: () => {},\n      lineDashOffset: 0,\n      fillStyle: \"#000000\",\n      strokeStyle: \"#000000\",\n      fillRule: \"nonzero\",\n      globalAlpha: 1,\n      lineWidth: 1,\n      lineCap: \"butt\",\n      lineJoin: \"miter\",\n      miterLimit: 10,\n      globalCompositeOperation: \"source-over\",\n      font: \"10px sans-serif\",\n      scale: () => {},\n      imageSmoothingEnabled: true,\n      drawImage: () => {},\n      restore: () => {},\n      save: () => {},\n    }),\n  };\n  const ctx = canvas.getContext();\n  const graphics = new CanvasGraphics(\n    ctx,\n    {},\n    {},\n    () => canvas,\n    () => {},\n    {},\n    {},\n    {}\n  );\n  graphics.paintInlineImageXObject({ width: 10, height: 10 });\n  const expectedFilter = \"none\";\n  const actualFilter = ctx.filter;\n  Util.assert(actualFilter === expectedFilter, `Expected filter to be ${expectedFilter}, but got ${actualFilter}`);\n});",
    "i3_deepseek-r1-distill-llama-70b": "it(\"should improve poster PDF rendering performance\", async () => {\n  const { PDFDocument } = await import(\"../../src/display/api.js\");\n  const pdfPath = `${TEST_PDFS_PATH}/poster.pdf`;\n  const loadPDF = async (pdfPath) => {\n    const params = buildGetDocumentParams(pdfPath, DefaultFileReaderFactory);\n    const pdf = await getDocument(params);\n    return pdf;\n  };\n\n  const pdf = await loadPDF(pdfPath);\n  const page = await pdf.getPage(1);\n  const viewport = page.getViewport({ scale: 1 });\n  const canvas = document.createElement(\"canvas\");\n  const ctx = canvas.getContext(\"2d\");\n  canvas.width = viewport.width;\n  canvas.height = viewport.height;\n\n  const measureRenderTime = async () => {\n    const startTime = performance.now();\n    await page.render({\n      canvasContext: ctx,\n      viewport,\n      renderInteractive: false,\n    });\n    return performance.now() - startTime;\n  };\n\n  // Before patch, filter is set to \"none\" unconditionally\n  const slowRenderTime = await measureRenderTime();\n  console.log(\"Slow render time:\", slowRenderTime);\n\n  // After patch, filter is only set if necessary\n  const fastRenderTime = await measureRenderTime();\n  console.log(\"Fast render time:\", fastRenderTime);\n\n  // Verify that the patch reduces rendering time\n  expect(fastRenderTime).toBeLessThan(slowRenderTime);\n});",
    "i3_gpt-4o": "it(\"should render poster PDF without slow performance\", async () => {\n  const { getDocument } = await import(\"../../src/display/api.js\");\n  const { DefaultCanvasFactory } = await import(\"../../src/display/api.js\");\n  const loadingTask = getDocument(buildGetDocumentParams(\"poster.pdf\"));\n  const pdfDocument = await loadingTask.promise;\n  const page = await pdfDocument.getPage(1);\n  const viewport = page.getViewport({ scale: 1.0 });\n  const canvasFactory = new DefaultCanvasFactory();\n  const { canvas, context } = canvasFactory.create(viewport.width, viewport.height);\n  const renderTask = page.render({ canvasContext: context, viewport });\n  const renderTimeStart = performance.now();\n  await renderTask.promise;\n  const renderTimeEnd = performance.now();\n  const renderTime = renderTimeEnd - renderTimeStart;\n  expect(renderTime).toBeLessThan(1000); // Expect rendering to be fast\n});",
    "i3_llama-3.3-70b-versatile": "it(\"should render poster PDF without being slow on Firefox\", async () => {\n  const pdfFile = `${TEST_PDFS_PATH}/poster.pdf`;\n  const params = buildGetDocumentParams(pdfFile, null, null, DefaultFileReaderFactory);\n  const pdfDocument = await getDocument(params);\n  const pdfPage = await pdfDocument.getPage(1);\n  const viewport = new PageViewport({ width: 100, height: 100 });\n  const renderTask = pdfPage.render({\n    viewport,\n    canvasContext: new CanvasGraphics(\n      new DefaultCanvasFactory().create(100, 100),\n      {},\n      {},\n      new DefaultCanvasFactory(),\n      null,\n      {}\n    ),\n    continueCallback: null,\n  });\n  await renderTask.promise;\n  expect(renderTask.status).toBe(\"finished\");\n});",
    "i4_deepseek-r1-distill-llama-70b": "it(\"should render poster PDFs quickly by avoiding unnecessary filter resets\", async () => {\n  const { resetCtxToDefault } = await import(\"../../src/display/canvas.js\");\n  const canvas = new (await import(\"canvas\")).Canvas(1, 1);\n  const ctx = canvas.getContext(\"2d\");\n\n  // Simulate a filter being set\n  ctx.filter = \"blur(5px)\";\n\n  // Measure the time to reset the context\n  const startTime = Date.now();\n  resetCtxToDefault(ctx);\n  const endTime = Date.now();\n\n  // The time should be under a reasonable threshold\n  expect(endTime - startTime).toBeLessThan(100);\n});",
    "i4_gpt-4o": "it(\"should reset ctxfilter to none only if its not already none or empty\", async () => {\n  const { CanvasGraphics } = await import(\"../../src/display/canvas.js\");\n  const { DOMCanvasFactory } = await import(\"../../src/display/display_utils.js\");\n\n  const canvasFactory = new DOMCanvasFactory();\n  const canvasAndCtx = canvasFactory.create(100, 100);\n  const ctx = canvasAndCtx.context;\n  ctx.filter = \"blur(5px)\";\n\n  const canvasGraphics = new CanvasGraphics(ctx, null, null, canvasFactory, null, {}, null, null);\n  canvasGraphics.beginDrawing({ transform: null, viewport: { transform: [1, 0, 0, 1, 0, 0], scale: 1 } });\n\n  const expected = \"none\";\n  const actual = ctx.filter;\n  expect(actual).toBe(expected);\n});",
    "i4_llama-3.3-70b-versatile": "it(\"should render poster PDF without slowing down Firefox\", async () => {\n  const { PDFDocument } = await import(\"../../src/core/document.js\");\n  const { PDFPage } = await import(\"../../src/core/document.js\");\n  const { CanvasGraphics } = await import(\"./canvas.js\");\n  const { DOMCanvasFactory } = await import(\"../../src/display/display_utils.js\");\n  const { createIdFactory } = await import(\"./test_utils.js\");\n\n  const pdf = await PDFDocument.load(await fetch(\"path_to_poster_pdf.pdf\").then(res => res.arrayBuffer()));\n  const page = await pdf.getPage(1);\n  const canvasFactory = new DOMCanvasFactory();\n  const idFactory = createIdFactory();\n  const graphics = new CanvasGraphics(\n    canvasFactory.create(100, 100).context,\n    new Map(),\n    new Map(),\n    canvasFactory,\n    null,\n    {},\n    new Map(),\n    null\n  );\n\n  const startTime = performance.now();\n  await page.render({\n    canvasContext: graphics.ctx,\n    viewport: page.getViewport({ scale: 1 }),\n  });\n  const endTime = performance.now();\n\n  expect(endTime - startTime).toBeLessThan(1000);\n});",
    "i5_deepseek-r1-distill-llama-70b": "it(\"should not reset filter when its already none\", async () => {\n  const { resetCtxToDefault } = await import(\"../../src/display/canvas.js\");\n  let setterCalled = false;\n  const ctx = {\n    filter: \"none\",\n    get filter() {\n      return this._filter;\n    },\n    set filter(value) {\n      setterCalled = true;\n      this._filter = value;\n    },\n  };\n  ctx.filter = \"none\";\n  resetCtxToDefault(ctx);\n  expect(setterCalled).toBe(false);\n});",
    "i5_gpt-4o": "it(\"should reset ctxfilter to none only if its not already none or empty\", async () => {\n  const { DOMCanvasFactory } = await import(\"../../src/display/display_utils.js\");\n  const canvasFactory = new DOMCanvasFactory();\n  const canvasAndCtx = canvasFactory.create(100, 100);\n  const ctx = canvasAndCtx.context;\n\n  ctx.filter = \"blur(5px)\";\n  resetCtxToDefault(ctx);\n  let actual = ctx.filter;\n  let expected = \"none\";\n  expect(actual).toBe(expected);\n\n  ctx.filter = \"none\";\n  resetCtxToDefault(ctx);\n  actual = ctx.filter;\n  expected = \"none\";\n  expect(actual).toBe(expected);\n\n  ctx.filter = \"\";\n  resetCtxToDefault(ctx);\n  actual = ctx.filter;\n  expected = \"\";\n  expect(actual).toBe(expected);\n});",
    "i5_llama-3.3-70b-versatile": "it(\"should render poster PDF quickly\", async () => {\n  const { PDFDocument, PDFPageProxy } = await import(\"../../src/display/api.js\");\n  const { createIdFactory } = await import(\"./test_utils.js\");\n  const idFactory = createIdFactory();\n  const pdfDoc = await PDFDocument.load({ url: `${TEST_PDFS_PATH}/poster.pdf`, cMapUrl: CMAP_URL, cMapPacked: true, standardFontDataUrl: STANDARD_FONT_DATA_URL, fontExtraProperties: {}, isEvalSupported: true, useSystemFonts: false, useWorker: true, workerPort: new LoopbackPort(idFactory) });\n  const page = await pdfDoc.getPage(1);\n  const renderTask = page.render({ canvasContext: { filter: \"blur(10px)\" }, viewport: page.getViewport({ scale: 1 }) });\n  const startTime = Date.now();\n  await renderTask.promise;\n  const endTime = Date.now();\n  const renderTime = endTime - startTime;\n  const expectedRenderTime = 1000; // 1 second\n  if (renderTime > expectedRenderTime) {\n    throw new Error(`Rendering took too long: ${renderTime}ms`);\n  }\n});"
  },
  "16732": {
    "i1_deepseek-r1-distill-llama-70b": "it(\"should change mouse cursor when hovering over different resizer edges\", async () => {\n  const { AnnotationEditor } = await import(\"../../src/display/editor/editor.js\");\n  const { AnnotationEditorParamsType } = await import(\"../../shared/util.js\");\n\n  const parent = {\n    pageDimensions: [100, 100],\n    viewport: {\n      rawDims: { pageWidth: 100, pageHeight: 100, pageX: 0, pageY: 0 },\n      rotation: 0,\n    },\n  };\n\n  const editor = new AnnotationEditor({\n    parent,\n    id: \"testEditor\",\n    uiManager: {},\n    name: \"testEditor\",\n  });\n\n  editor._willKeepAspectRatio = true;\n  editor.makeResizable();\n\n  const resizers = editor.#resizersDiv.children;\n  const resizerPositions = [\"topLeft\", \"topRight\", \"bottomRight\", \"bottomLeft\"];\n\n  expect(editor.#resizersDiv?.children).toHaveLength(8);\n\n  for (const resizer of resizers) {\n    const position = resizer.classList[1];\n    if (position === \"topLeft\" || position === \"bottomRight\") {\n      expect(resizer.dataset.cursor).toBe(\"nwse-resize\");\n    } else if (position === \"topRight\" || position === \"bottomLeft\") {\n      expect(resizer.dataset.cursor).toBe(\"nesw-resize\");\n    } else if (position === \"topMiddle\") {\n      expect(resizer.dataset.cursor).toBe(\"n-resize\");\n    } else if (position === \"middleRight\") {\n      expect(resizer.dataset.cursor).toBe(\"e-resize\");\n    } else if (position === \"bottomMiddle\") {\n      expect(resizer.dataset.cursor).toBe(\"s-resize\");\n    } else if (position === \"middleLeft\") {\n      expect(resizer.dataset.cursor).toBe(\"w-resize\");\n    }\n  }\n});",
    "i1_gpt-4o": "it(\"should change mouse cursor state according to the edge when resizing images and drawings\", async () => {\n  const { AnnotationEditor } = await import(\"../../src/display/editor/editor.js\");\n  const { InkEditor } = await import(\"../../src/display/editor/ink.js\");\n  const { StampEditor } = await import(\"../../src/display/editor/stamp.js\");\n\n  const mockUIManager = { viewParameters: { rotation: 0 } };\n  const mockParent = { viewport: { rotation: 0, rawDims: { pageWidth: 100, pageHeight: 100, pageX: 0, pageY: 0 } }, pageIndex: 0 };\n\n  const inkEditor = new InkEditor({ parent: mockParent, uiManager: mockUIManager, x: 0, y: 0 });\n  const stampEditor = new StampEditor({ parent: mockParent, uiManager: mockUIManager, x: 0, y: 0, bitmapUrl: \"\" });\n\n  inkEditor.select();\n  stampEditor.select();\n\n  const inkResizers = inkEditor.div.querySelectorAll(\".resizer\");\n  const stampResizers = stampEditor.div.querySelectorAll(\".resizer\");\n\n  const expectedInkCursorStates = [\"nwse-resize\", \"nesw-resize\", \"nwse-resize\", \"nesw-resize\"];\n  const expectedStampCursorStates = [\"nwse-resize\", \"nesw-resize\", \"nwse-resize\", \"nesw-resize\"];\n\n  const actualInkCursorStates = Array.from(inkResizers).map(resizer => getComputedStyle(resizer).cursor);\n  const actualStampCursorStates = Array.from(stampResizers).map(resizer => getComputedStyle(resizer).cursor);\n\n  expect(actualInkCursorStates).toEqual(expectedInkCursorStates);\n  expect(actualStampCursorStates).toEqual(expectedStampCursorStates);\n});",
    "i1_llama-3.3-70b-versatile": "it(\"should change the mouse cursor state according to the edge we resize from for added images and drawings in PDF documents\", async () => {\n  const { AnnotationEditor } = await import(\"../../src/display/editor/editor.js\");\n  const { AnnotationEditorUIManager } = await import(\"../../src/display/editor/tools.js\");\n  const editor = new AnnotationEditor({ uiManager: new AnnotationEditorUIManager() });\n  editor.makeResizable();\n  const resizerDiv = editor.#resizersDiv;\n  const topLeftResizer = resizerDiv.querySelector(\".resizer.topLeft\");\n  const topRightResizer = resizerDiv.querySelector(\".resizer.topRight\");\n  const bottomLeftResizer = resizerDiv.querySelector(\".resizer.bottomLeft\");\n  const bottomRightResizer = resizerDiv.querySelector(\".resizer.bottomRight\");\n  const middleLeftResizer = resizerDiv.querySelector(\".resizer.middleLeft\");\n  const middleRightResizer = resizerDiv.querySelector(\".resizer.middleRight\");\n  const topMiddleResizer = resizerDiv.querySelector(\".resizer.topMiddle\");\n  const bottomMiddleResizer = resizerDiv.querySelector(\".resizer.bottomMiddle\");\n\n  // Check if the resizers are correctly added to the editor\n  expect(resizerDiv.childElementCount).toBe(8);\n\n  // Check if the resizers have the correct class names\n  expect(topLeftResizer.classList.contains(\"resizer\")).toBe(true);\n  expect(topLeftResizer.classList.contains(\"topLeft\")).toBe(true);\n  expect(topRightResizer.classList.contains(\"resizer\")).toBe(true);\n  expect(topRightResizer.classList.contains(\"topRight\")).toBe(true);\n  expect(bottomLeftResizer.classList.contains(\"resizer\")).toBe(true);\n  expect(bottomLeftResizer.classList.contains(\"bottomLeft\")).toBe(true);\n  expect(bottomRightResizer.classList.contains(\"resizer\")).toBe(true);\n  expect(bottomRightResizer.classList.contains(\"bottomRight\")).toBe(true);\n  expect(middleLeftResizer.classList.contains(\"resizer\")).toBe(true);\n  expect(middleLeftResizer.classList.contains(\"middleLeft\")).toBe(true);\n  expect(middleRightResizer.classList.contains(\"resizer\")).toBe(true);\n  expect(middleRightResizer.classList.contains(\"middleRight\")).toBe(true);\n  expect(topMiddleResizer.classList.contains(\"resizer\")).toBe(true);\n  expect(topMiddleResizer.classList.contains(\"topMiddle\")).toBe(true);\n  expect(bottomMiddleResizer.classList.contains(\"resizer\")).toBe(true);\n  expect(bottomMiddleResizer.classList.contains(\"bottomMiddle\")).toBe(true);\n});",
    "i2_deepseek-r1-distill-llama-70b": "it(\"should change cursor when hovering over resizers\", async () => {\n  const { AnnotationEditor, AnnotationEditorUIManager } = await import(\"./editor.js\");\n  const { AnnotationEditorUIManager: UIManager } = await import(\"./tools.js\");\n\n  const container = document.createElement(\"div\");\n  document.body.appendChild(container);\n\n  const uiManager = new UIManager(container, null, null, null);\n  const editor = new AnnotationEditor({\n    parent: {\n      pageWidth: 100,\n      pageHeight: 100,\n      viewport: {\n        rotation: 0,\n        rawDims: { pageWidth: 100, pageHeight: 100 }\n      },\n      addInkEditorIfNeeded: () => {}\n    },\n    parentDimensions: [100, 100],\n    uiManager: uiManager,\n    id: \"test\",\n    name: \"testEditor\"\n  });\n\n  editor.makeResizable();\n\n  const expectedCursors = {\n    topLeft: \"nwse-resize\",\n    topRight: \"nesw-resize\",\n    topMiddle: \"ns-resize\",\n    middleRight: \"ew-resize\",\n    bottomRight: \"nwse-resize\",\n    bottomMiddle: \"ns-resize\",\n    bottomLeft: \"nesw-resize\",\n    middleLeft: \"ew-resize\"\n  };\n\n  const resizers = editor.#resizersDiv.querySelectorAll(\".resizer\");\n\n  for (const [name, cursor] of Object.entries(expectedCursors)) {\n    const resizer = resizers.namedItem(name);\n    jest.spyOn(resizer, \"style\", {\n      get: () => ({ cursor: \"\" })\n    });\n\n    const event = new PointerEvent(\"pointerenter\", {\n      bubbles: true,\n      cancelable: true\n    });\n\n    await new Promise(resolve => {\n      resizer.addEventListener(\"pointerenter\", () => {\n        expect(resizer.style.cursor).toBe(cursor);\n        resolve();\n      });\n\n      resizer.dispatchEvent(event);\n\n      jest.setTimeout(resolve, 100);\n    });\n  }\n\n  document.body.removeChild(container);\n});",
    "i2_gpt-4o": "it(\"should change mouse cursor state according to the edge when resizing images and drawings\", async () => {\n  const { AnnotationEditorUIManager } = await import(\"../../src/display/editor/tools.js\");\n  const { AnnotationEditor } = await import(\"../../src/display/editor/editor.js\");\n  const { InkEditor } = await import(\"../../src/display/editor/ink.js\");\n  const { StampEditor } = await import(\"../../src/display/editor/stamp.js\");\n\n  const uiManager = new AnnotationEditorUIManager(null, null, { annotationStorage: {}, filterFactory: {} }, null);\n  const inkEditor = new InkEditor({ parent: { pageIndex: 0, viewport: { rotation: 0, rawDims: { pageWidth: 100, pageHeight: 100, pageX: 0, pageY: 0 } } }, uiManager });\n  const stampEditor = new StampEditor({ parent: { pageIndex: 0, viewport: { rotation: 0, rawDims: { pageWidth: 100, pageHeight: 100, pageX: 0, pageY: 0 } } }, uiManager, bitmapUrl: \"\" });\n\n  inkEditor.select();\n  stampEditor.select();\n\n  const inkResizers = inkEditor.div.querySelectorAll(\".resizer\");\n  const stampResizers = stampEditor.div.querySelectorAll(\".resizer\");\n\n  const expectedCursorStyles = [\"nwse-resize\", \"nesw-resize\", \"nwse-resize\", \"nesw-resize\", \"ns-resize\", \"ew-resize\", \"ns-resize\", \"ew-resize\"];\n  const actualInkCursorStyles = Array.from(inkResizers).map(resizer => getComputedStyle(resizer).cursor);\n  const actualStampCursorStyles = Array.from(stampResizers).map(resizer => getComputedStyle(resizer).cursor);\n\n  expect(actualInkCursorStyles).toEqual(expectedCursorStyles);\n  expect(actualStampCursorStyles).toEqual(expectedCursorStyles);\n});",
    "i2_llama-3.3-70b-versatile": "it(\"should change the mouse cursor state according to the edge we resize from for added images and drawings in PDF documents\", async () => {\n  const { AnnotationEditor, AnnotationEditorUIManager } = await import(\"../../src/display/editor/editor.js\");\n  const { AnnotationEditorType } = await import(\"../../shared/util.js\");\n  const { InkEditor } = await import(\"../../src/display/editor/ink.js\");\n  const { StampEditor } = await import(\"../../src/display/editor/stamp.js\");\n\n  const annotationEditorUIManager = new AnnotationEditorUIManager();\n  const inkEditor = new InkEditor({ uiManager: annotationEditorUIManager });\n  const stampEditor = new StampEditor({ uiManager: annotationEditorUIManager });\n\n  inkEditor.makeResizable();\n  stampEditor.makeResizable();\n\n  const inkResizers = inkEditor.div.querySelectorAll(\".resizer\");\n  const stampResizers = stampEditor.div.querySelectorAll(\".resizer\");\n\n  expect(inkResizers.length).toBe(8);\n  expect(stampResizers.length).toBe(8);\n\n  const mouseCursorStates = [\n    \"nwse-resize\",\n    \"nesw-resize\",\n    \"nwse-resize\",\n    \"nesw-resize\",\n    \"ns-resize\",\n    \"ew-resize\",\n    \"ns-resize\",\n    \"ew-resize\",\n  ];\n\n  inkResizers.forEach((resizer, index) => {\n    resizer.dispatchEvent(new MouseEvent(\"pointerdown\", { buttons: 1 }));\n    expect(document.body.style.cursor).toBe(mouseCursorStates[index]);\n  });\n\n  stampResizers.forEach((resizer, index) => {\n    resizer.dispatchEvent(new MouseEvent(\"pointerdown\", { buttons: 1 }));\n    expect(document.body.style.cursor).toBe(mouseCursorStates[index]);\n  });\n});",
    "i3_deepseek-r1-distill-llama-70b": "it(\"should change cursor when resizing from different edges\", async () => {\n  const { AnnotationEditor, InkEditor, StampEditor } = await import(\"../../src/display/editor/editor.js\");\n  const { AnnotationEditorUIManager } = await import(\"../../src/display/editor/tools.js\");\n\n  // Setup test HTML content\n  const htmlContent = `\n    <html>\n      <head>\n        <style>\n          .resizer {\n            width: 15px;\n            height: 15px;\n            position: absolute;\n            z-index: 100;\n          }\n          .resizer.topLeft { cursor: nw-resize; }\n          .resizer.topRight { cursor: ne-resize; }\n          .resizer.bottomRight { cursor: se-resize; }\n          .resizer.bottomLeft { cursor: sw-resize; }\n          .resizer.topMiddle { cursor: n-resize; }\n          .resizer.middleRight { cursor: e-resize; }\n          .resizer.bottomMiddle { cursor: s-resize; }\n          .resizer.middleLeft { cursor: w-resize; }\n        </style>\n      </head>\n      <body></body>\n    </html>\n  `;\n\n  // Create test page and editor\n  const page = await new Promise(resolve => {\n    const server = require('http').createServer((req, res) => {\n      res.writeHead(200, {'Content-Type': 'text/html'});\n      res.end(htmlContent);\n    }).listen(0, 'localhost', () => {\n      const port = server.address().port;\n      resolve(`http://localhost:${port}`);\n    });\n  });\n\n  // Initialize editor and page\n  const editor = new StampEditor({\n    parent: {},\n    id: 'test-editor',\n    x: 0,\n    y: 0,\n    width: 100,\n    height: 100,\n    rotation: 0,\n    pageDimensions: [100, 100],\n    pageTranslation: [0, 0]\n  });\n\n  // Test cursor changes\n  const puppeteer = require('puppeteer');\n  const browser = await puppeteer.launch();\n  const context = await browser.newContext();\n  const page = await context.newPage();\n  await page.goto(page);\n\n  // Click to activate editor\n  await page.click('#test-editor');\n\n  // Test top edge\n  await page.hover('.resizers .topLeft');\n  const topCursor = await page.evaluate(() => window.getComputedStyle(document.querySelector('.resizers .topLeft')).cursor);\n  expect(topCursor).toBe('nw-resize');\n\n  // Test right edge\n  await page.hover('.resizers .topRight');\n  const rightCursor = await page.evaluate(() => window.getComputedStyle(document.querySelector('.resizers .topRight')).cursor);\n  expect(rightCursor).toBe('ne-resize');\n\n  // Test bottom edge\n  await page.hover('.resizers .bottomRight');\n  const bottomCursor = await page.evaluate(() => window.getComputedStyle(document.querySelector('.resizers .bottomRight')).cursor);\n  expect(bottomCursor).toBe('se-resize');\n\n  // Test left edge\n  await page.hover('.resizers .bottomLeft');\n  const leftCursor = await page.evaluate(() => window.getComputedStyle(document.querySelector('.resizers .bottomLeft')).cursor);\n  expect(leftCursor).toBe('sw-resize');\n\n  // Cleanup\n  await browser.close();\n});",
    "i3_gpt-4o": "it(\"should change mouse cursor state according to the edge when resizing images and drawings\", async () => {\n  const { AnnotationEditor } = await import(\"../../src/display/editor/editor.js\");\n  const { InkEditor } = await import(\"../../src/display/editor/ink.js\");\n  const { StampEditor } = await import(\"../../src/display/editor/stamp.js\");\n\n  const mockUIManager = {\n    addToAnnotationStorage: () => {},\n    addCommands: () => {},\n    viewParameters: { realScale: 1, rotation: 0 },\n  };\n\n  const inkEditor = new InkEditor({\n    uiManager: mockUIManager,\n    parent: { pageIndex: 0, viewport: { rotation: 0, rawDims: { pageWidth: 100, pageHeight: 100, pageX: 0, pageY: 0 } } },\n    id: \"inkEditor1\",\n    x: 10,\n    y: 10,\n  });\n\n  const stampEditor = new StampEditor({\n    uiManager: mockUIManager,\n    parent: { pageIndex: 0, viewport: { rotation: 0, rawDims: { pageWidth: 100, pageHeight: 100, pageX: 0, pageY: 0 } } },\n    id: \"stampEditor1\",\n    bitmapUrl: \"http://example.com/image.png\",\n    x: 10,\n    y: 10,\n  });\n\n  inkEditor.makeResizable();\n  stampEditor.makeResizable();\n\n  const inkResizers = inkEditor.div.querySelectorAll(\".resizer\");\n  const stampResizers = stampEditor.div.querySelectorAll(\".resizer\");\n\n  expect(inkResizers.length).toBeGreaterThan(0);\n  expect(stampResizers.length).toBeGreaterThan(0);\n\n  inkResizers.forEach(resizer => {\n    expect(getComputedStyle(resizer).cursor).toMatch(/resize/);\n  });\n\n  stampResizers.forEach(resizer => {\n    expect(getComputedStyle(resizer).cursor).toMatch(/resize/);\n  });\n});",
    "i3_llama-3.3-70b-versatile": "it(\"should change the mouse cursor state according to the edge we resize from for added images and drawings in PDF documents\", async () => {\n  const { AnnotationEditor } = await import(\"../../src/display/editor/editor.js\");\n  const editor = new AnnotationEditor({\n    parent: { pageIndex: 0 },\n    id: \"test-editor\",\n    uiManager: {},\n  });\n  editor.render();\n  const resizerPointerdown = jest.fn();\n  editor.#resizerPointerdown = resizerPointerdown;\n  const event = { preventDefault: jest.fn(), clientX: 10, clientY: 10 };\n  editor.div.dispatchEvent(new PointerEvent(\"pointerdown\", event));\n  expect(resizerPointerdown).toHaveBeenCalledTimes(1);\n  expect(event.preventDefault).toHaveBeenCalledTimes(1);\n});",
    "i4_deepseek-r1-distill-llama-70b": "it(\"should change cursor shape when resizing from different edges\", async () => {\n  const { PDFDocument } = await import(\"../../src/core/pdf_document.js\");\n  const { AnnotationEditor } = await import(\"../../src/display/editor/editor.js\");\n  const { InkEditor } = await import(\"../../src/display/editor/ink.js\");\n  const { StampEditor } = await import(\"../../src/display/editor/stamp.js\");\n\n  // Setup a simple PDF document with one page\n  const pdf = new PDFDocument();\n  const page = pdf.addPage();\n\n  // Create an image editor\n  const editor = new StampEditor({\n    parent: {\n      add: () => {},\n      pageIndices: [0],\n      pageIndex: 0,\n      viewport: {\n        rotation: 0,\n        rawDims: { pageWidth: 100, pageHeight: 100 }\n      }\n    },\n    uiManager: {},\n    id: \"test\",\n    bitmapUrl: \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mNkYAAAAAYAAjCB0C8AAAAASUVORK5CYII=\"\n  });\n\n  // Initialize the editor and render it\n  editor.render();\n\n  // Simulate pointer events to test resizing\n  const resizer = editor.div.querySelector(\".resizers\");\n  const startEvent = new PointerEvent(\"pointerdown\", {\n    bubbles: true,\n    cancelable: true,\n    pointerType: \"mouse\",\n    buttons: 1\n  });\n  resizer.dispatchEvent(startEvent);\n\n  // Move the mouse to trigger resize\n  const moveEvent = new PointerEvent(\"pointermove\", {\n    bubbles: true,\n    cancelable: true,\n    pointerType: \"mouse\",\n    buttons: 1,\n    clientX: 100,\n    clientY: 100\n  });\n  resizer.dispatchEvent(moveEvent);\n\n  // Check the cursor shape after resizing from topLeft corner\n  const expectedCursor = \"nwse-resize\";\n  const actualCursor = resizer.style.cursor;\n\n  expect(actualCursor).toBe(expectedCursor);\n});",
    "i4_gpt-4o": "it(\"should change mouse cursor state according to the edge when resizing images and drawings in PDF documents\", async () => {\n  const { AnnotationEditor } = await import(\"../../src/display/editor/editor.js\");\n  const { InkEditor } = await import(\"../../src/display/editor/ink.js\");\n  const { StampEditor } = await import(\"../../src/display/editor/stamp.js\");\n\n  const mockUIManager = {\n    addToAnnotationStorage: jest.fn(),\n    addCommands: jest.fn(),\n    viewParameters: { realScale: 1, rotation: 0 },\n  };\n\n  const mockParent = {\n    pageIndex: 0,\n    viewport: {\n      rotation: 0,\n      rawDims: { pageWidth: 100, pageHeight: 100, pageX: 0, pageY: 0 },\n    },\n    div: document.createElement(\"div\"),\n  };\n\n  const inkEditor = new InkEditor({\n    parent: mockParent,\n    uiManager: mockUIManager,\n    id: \"inkEditor1\",\n    x: 10,\n    y: 10,\n  });\n\n  const stampEditor = new StampEditor({\n    parent: mockParent,\n    uiManager: mockUIManager,\n    id: \"stampEditor1\",\n    bitmapUrl: \"http://example.com/image.png\",\n    x: 10,\n    y: 10,\n  });\n\n  inkEditor.render();\n  stampEditor.render();\n\n  inkEditor.select();\n  stampEditor.select();\n\n  const inkResizers = inkEditor.div.querySelector(\".resizers\");\n  const stampResizers = stampEditor.div.querySelector(\".resizers\");\n\n  expect(inkResizers).not.toBeNull();\n  expect(stampResizers).not.toBeNull();\n\n  const inkResizer = inkResizers.querySelector(\".topLeft\");\n  const stampResizer = stampResizers.querySelector(\".topLeft\");\n\n  expect(getComputedStyle(inkResizer).cursor).toBe(\"nwse-resize\");\n  expect(getComputedStyle(stampResizer).cursor).toBe(\"nwse-resize\");\n});",
    "i4_llama-3.3-70b-versatile": "it(\"should change the mouse cursor state according to the edge we resize from for added images and drawings in PDF documents\", async () => {\n  const { AnnotationEditor } = await import(\"../../src/display/editor/editor.js\");\n  const editor = new AnnotationEditor({\n    parent: {\n      pageIndex: 0,\n      pageDimensions: [100, 100],\n      getNextId: () => \"id\",\n      add: () => {},\n      remove: () => {},\n    },\n    uiManager: {\n      viewParameters: {\n        realScale: 1,\n        rotation: 0,\n      },\n    },\n    id: \"id\",\n    name: \"editor\",\n  });\n  editor.width = 50;\n  editor.height = 50;\n  editor.x = 25;\n  editor.y = 25;\n  editor.render();\n  editor.makeResizable();\n  const resizer = editor.#resizersDiv.children[0];\n  const event = new PointerEvent(\"pointerdown\", {\n    bubbles: true,\n    cancelable: true,\n    clientX: 30,\n    clientY: 30,\n  });\n  resizer.dispatchEvent(event);\n  const resizingClassName = `resizing${\"topLeft\".charAt(0).toUpperCase()}${\"topLeft\".slice(1)}`;\n  expect(editor.parent.div.classList.contains(resizingClassName)).toBe(true);\n});",
    "i5_deepseek-r1-distill-llama-70b": "it(\"should change cursor shape when resizing from different edges\", async () => {\n  const { AnnotationEditor } = await import(\"../../src/display/editor/editor.js\");\n  const { StampEditor } = await import(\"../../src/display/editor/stamp.js\");\n  const { InkEditor } = await import(\"../../src/display/editor/ink.js\");\n\n  const div = document.createElement(\"div\");\n  document.body.appendChild(div);\n\n  const stampEditor = new StampEditor({\n    uiManager: {\n      stopUndoAccumulation: () => {},\n      commandManager: {\n        stopUndoAccumulation: () => {},\n      },\n    },\n  });\n  stampEditor.select();\n  stampEditor.render();\n\n  const inkEditor = new InkEditor({\n    uiManager: {\n      stopUndoAccumulation: () => {},\n      commandManager: {\n        stopUndoAccumulation: () => {},\n      },\n    },\n  });\n  inkEditor.select();\n  inkEditor.render();\n\n  const resizerTL = div.querySelector(\".resizer.topLeft\");\n  const resizerTR = div.querySelector(\".resizer.topRight\");\n  const resizerBR = div.querySelector(\".resizer.bottomRight\");\n  const resizerBL = div.querySelector(\".resizer.bottomLeft\");\n\n  expect(resizerTL.style.cursor).toBe(\"nwse-resize\");\n  expect(resizerTR.style.cursor).toBe(\"nesw-resize\");\n  expect(resizerBR.style.cursor).toBe(\"se-resize\");\n  expect(resizerBL.style.cursor).toBe(\"sw-resize\");\n});",
    "i5_gpt-4o": "it(\"should change mouse cursor state according to the edge when resizing images and drawings in PDF\", async () => {\n  const { AnnotationEditorUIManager } = await import(\"../../src/display/editor/tools.js\");\n  const { AnnotationEditor } = await import(\"../../src/display/editor/editor.js\");\n  const { InkEditor } = await import(\"../../src/display/editor/ink.js\");\n  const { StampEditor } = await import(\"../../src/display/editor/stamp.js\");\n\n  const uiManager = new AnnotationEditorUIManager();\n  const inkEditor = new InkEditor({ uiManager });\n  const stampEditor = new StampEditor({ uiManager });\n\n  inkEditor.select();\n  stampEditor.select();\n\n  const inkResizers = inkEditor.div.querySelectorAll(\".resizer\");\n  const stampResizers = stampEditor.div.querySelectorAll(\".resizer\");\n\n  const expectedInkResizerCount = inkEditor.isResizable ? 4 : 0;\n  const expectedStampResizerCount = stampEditor.isResizable ? 8 : 0;\n\n  const actualInkResizerCount = inkResizers.length;\n  const actualStampResizerCount = stampResizers.length;\n\n  expect(actualInkResizerCount).toBe(expectedInkResizerCount);\n  expect(actualStampResizerCount).toBe(expectedStampResizerCount);\n});",
    "i5_llama-3.3-70b-versatile": "it(\"should change the mouse cursor state according to the edge we resize it from for added images and drawings in PDF documents\", async () => {\n  const { AnnotationEditor } = await import(\"../../src/display/editor/editor.js\");\n  const { AnnotationEditorUIManager } = await import(\"../../src/display/editor/tools.js\");\n  const { PDFDocument } = await import(\"../../src/core/document.js\");\n  const { PDFPage } = await import(\"../../src/core/document.js\");\n  const { PDFViewer } = await import(\"../../web/pdf_viewer.js\");\n\n  const pdfDocument = await PDFDocument.load(await fetch(\"example.pdf\").then(response => response.arrayBuffer()));\n  const pdfPage = pdfDocument.getPage(1);\n  const pdfViewer = new PDFViewer();\n  const annotationEditorUIManager = new AnnotationEditorUIManager(pdfViewer);\n  const annotationEditor = new AnnotationEditor({ uiManager: annotationEditorUIManager });\n\n  annotationEditorUIManager.addEditor(annotationEditor);\n  annotationEditor.makeResizable();\n\n  const resizerDiv = annotationEditor.#resizersDiv;\n  const resizerElements = resizerDiv.children;\n\n  const expectedCursorStyles = {\n    \"topLeft\": \"nwse-resize\",\n    \"topMiddle\": \"ns-resize\",\n    \"topRight\": \"nesw-resize\",\n    \"middleRight\": \"ew-resize\",\n    \"bottomRight\": \"nwse-resize\",\n    \"bottomMiddle\": \"ns-resize\",\n    \"bottomLeft\": \"nesw-resize\",\n    \"middleLeft\": \"ew-resize\",\n  };\n\n  for (const resizerElement of resizerElements) {\n    const className = resizerElement.classList[1];\n    const expectedCursorStyle = expectedCursorStyles[className];\n\n    resizerElement.dispatchEvent(new MouseEvent(\"pointerover\", { bubbles: true }));\n    const actualCursorStyle = globalThis.getComputedStyle(resizerElement).cursor;\n\n    if (actualCursorStyle !== expectedCursorStyle) {\n      throw new Error(`Expected cursor style '${expectedCursorStyle}' but got '${actualCursorStyle}' for resizer '${className}'`);\n    }\n  }\n});"
  },
  "16773": {
    "i1_deepseek-r1-distill-llama-70b": "import { StampEditor } from \"../../display/editor/stamp.js\";\nimport { AnnotationEditorType } from \"../../shared/util.js\";\n\ndescribe(\"StampEditor\", () => {\n  it(\"should only accept supported image types\", async () => {\n    const editor = new StampEditor({} as unknown as AnnotationEditorType);\n    const expectedTypes = [\n      \"image/apng\",\n      \"image/avif\",\n      \"image/bmp\",\n      \"image/gif\",\n      \"image/jpeg\",\n      \"image/png\",\n      \"image/svg+xml\",\n      \"image/webp\",\n      \"image/x-icon\",\n    ].join(\",\");\n\n    expect(editor.constructor.supportedTypes).toBe(expectedTypes);\n  });\n});",
    "i1_gpt-4o": "import { StampEditor } from \"../../src/display/editor/stamp.js\";\nimport { AnnotationEditorUIManager } from \"../../src/display/editor/tools.js\";\n\ndescribe(\"StampEditor Image Type Support\", () => {\n  it(\"should only allow supported image types\", async () => {\n    const uiManager = new AnnotationEditorUIManager();\n    const stampEditor = new StampEditor({ _uiManager: uiManager });\n\n    const input = document.createElement(\"input\");\n    input.type = \"file\";\n    input.accept = StampEditor.supportedTypes;\n\n    const expectedTypes = [\n      \"image/apng\",\n      \"image/avif\",\n      \"image/bmp\",\n      \"image/gif\",\n      \"image/jpeg\",\n      \"image/png\",\n      \"image/svg+xml\",\n      \"image/webp\",\n      \"image/x-icon\",\n    ].join(\",\");\n\n    const actualTypes = input.accept;\n\n    expect(actualTypes).toBe(expectedTypes);\n  });\n});",
    "i1_llama-3.3-70b-versatile": "import { AnnotationEditorType } from \"../../shared/util.js\";\nimport { StampEditor } from \"./stamp.js\";\n\ndescribe(\"Stamp Editor Image Type Validation\", () => {\n  it(\"should only allow supported image types when selecting an image in the stamp annotation\", async () => {\n    const supportedTypes = StampEditor.supportedTypes;\n    const input = document.createElement(\"input\");\n    input.type = \"file\";\n    input.accept = supportedTypes;\n\n    const file = new File([\"\"], \"test.tiff\", { type: \"image/tiff\" });\n    const file2 = new File([\"\"], \"test.png\", { type: \"image/png\" });\n\n    const changeEvent = new Event(\"change\");\n    input.files = [file];\n    input.dispatchEvent(changeEvent);\n\n    const changeEvent2 = new Event(\"change\");\n    input.files = [file2];\n    input.dispatchEvent(changeEvent2);\n\n    const supported = supportedTypes.includes(file2.type);\n    const unsupported = supportedTypes.includes(file.type);\n\n    expect(supported).toBe(true);\n    expect(unsupported).toBe(false);\n  });\n});",
    "i2_gpt-4o": "it(\"should only allow supported image types for stamp annotation\", async () => {\n  const { StampEditor } = await import(\"../../src/display/editor/stamp.js\");\n  const input = document.createElement(\"input\");\n  input.type = \"file\";\n  input.accept = StampEditor.supportedTypes;\n  const expectedTypes = [\n    \"image/apng\",\n    \"image/avif\",\n    \"image/bmp\",\n    \"image/gif\",\n    \"image/jpeg\",\n    \"image/png\",\n    \"image/svg+xml\",\n    \"image/webp\",\n    \"image/x-icon\",\n  ].join(\",\");\n  const actualTypes = input.accept;\n  expect(actualTypes).toBe(expectedTypes);\n});",
    "i2_llama-3.3-70b-versatile": "it(\"should only allow supported image types when selecting an image in the stamp annotation\", async () => {\n  const { StampEditor } = await import(\"./stamp.js\");\n  const { AnnotationEditorType } = await import(\"../../shared/util.js\");\n  const editor = new StampEditor({ type: AnnotationEditorType.STAMP });\n  const input = document.createElement(\"input\");\n  input.type = \"file\";\n  const originalAccept = StampEditor.supportedTypes;\n  const unsupportedType = \"image/tiff\";\n  const supportedType = \"image/png\";\n  const file = new File([\"\"], \"test.png\", { type: supportedType });\n  const unsupportedFile = new File([\"\"], \"test.tiff\", { type: unsupportedType });\n  input.files = [unsupportedFile];\n  const event = new Event(\"change\");\n  input.dispatchEvent(event);\n  input.files = [file];\n  const event2 = new Event(\"change\");\n  input.dispatchEvent(event2);\n  expect(editor.#bitmap).not.toBeNull();\n});",
    "i3_deepseek-r1-distill-llama-70b": "import { StampEditor } from \"../../display/editor/stamp.js\";\nimport { AnnotationEditorType } from \"../../shared/util.js\";\nimport { AnnotationStorage } from \"../../display/annotation_storage.js\";\n\ndescribe(\"StampEditor image type validation\", () => {\n  it(\"should only accept supported image types\", async () => {\n    // Mock the UI manager and imageManager\n    const uiManager = {\n      imageManager: {\n        getFromFile: jest.fn(),\n        isValidId: jest.fn(),\n      },\n    };\n\n    // Create editor instance\n    const editor = new StampEditor({\n      name: \"testEditor\",\n      pageIndex: 0,\n      uiManager: uiManager,\n    });\n\n    // Mock supported and unsupported file types\n    const supportedTypes = [\n      \"image/apng\",\n      \"image/avif\",\n      \"image/bmp\",\n      \"image/gif\",\n      \"image/jpeg\",\n      \"image/png\",\n      \"image/svg+xml\",\n      \"image/webp\",\n      \"image/x-icon\",\n    ];\n\n    const unsupportedTypes = [\n      \"image/tiff\",\n      \"image/bpg\",\n      \"image/ico\", // Note: image/x-icon is supported but image/ico is not\n    ];\n\n    // Test supported types\n    for (const type of supportedTypes) {\n      const file = new File([\"\"], \"test.\" + type.split(\"/\")[1], {\n        type: type,\n      });\n\n      const input = document.createElement(\"input\");\n      input.files = [file];\n      const event = new Event(\"change\");\n\n      // Mock successful image load\n      uiManager.imageManager.getFromFile.mockResolvedValueOnce({\n        bitmap: new Image(),\n        id: \"test-id\",\n        isSvg: type === \"image/svg+xml\",\n      });\n\n      // Trigger change event\n      input.dispatchEvent(event);\n      await editor.#bitmapPromise;\n\n      expect(uiManager.imageManager.getFromFile).toHaveBeenCalled();\n      expect(editor.#bitmap).toBeTruthy();\n    }\n\n    // Test unsupported types\n    for (const type of unsupportedTypes) {\n      const file = new File([\"\"], \"test.\" + type.split(\"/\")[1], {\n        type: type,\n      });\n\n      const input = document.createElement(\"input\");\n      input.files = [file];\n      const event = new Event(\"change\");\n\n      // Mock failed image load\n      uiManager.imageManager.getFromFile.mockResolvedValueOnce(null);\n\n      // Trigger change event\n      input.dispatchEvent(event);\n      await editor.#bitmapPromise;\n\n      expect(uiManager.imageManager.getFromFile).toHaveBeenCalled();\n      expect(editor.#bitmap).toBeNull();\n    }\n  });\n});",
    "i3_gpt-4o": "import { StampEditor } from \"../../src/display/editor/stamp.js\";\nimport { AnnotationEditorUIManager } from \"../../src/display/editor/tools.js\";\n\ndescribe(\"StampEditor Image Type Support\", () => {\n  it(\"should only allow supported image types\", async () => {\n    const uiManager = new AnnotationEditorUIManager();\n    const stampEditor = new StampEditor({ uiManager });\n\n    const input = document.createElement(\"input\");\n    input.type = \"file\";\n    input.accept = StampEditor.supportedTypes;\n\n    const expectedTypes = [\n      \"image/apng\",\n      \"image/avif\",\n      \"image/bmp\",\n      \"image/gif\",\n      \"image/jpeg\",\n      \"image/png\",\n      \"image/svg+xml\",\n      \"image/webp\",\n      \"image/x-icon\",\n    ].join(\",\");\n\n    const actualTypes = input.accept;\n\n    expect(actualTypes).toBe(expectedTypes);\n  });\n});",
    "i3_llama-3.3-70b-versatile": "import { StampEditor } from \"../../src/display/editor/stamp.js\";\nimport { AnnotationEditorType } from \"../../shared/util.js\";\nimport { PixelsPerInch } from \"../display_utils.js\";\n\ndescribe(\"StampEditor image type validation\", () => {\n  it(\"should only allow supported image types\", async () => {\n    const supportedTypes = [\n      \"apng\",\n      \"avif\",\n      \"bmp\",\n      \"gif\",\n      \"jpeg\",\n      \"png\",\n      \"svg+xml\",\n      \"webp\",\n      \"x-icon\",\n    ];\n\n    const input = document.createElement(\"input\");\n    input.type = \"file\";\n    const file = new File([\"\"], \"test.tiff\", { type: \"image/tiff\" });\n    const dataTransfer = new DataTransfer();\n    dataTransfer.items.add(file);\n    input.files = dataTransfer.files;\n\n    const editor = new StampEditor({});\n\n    const originalAccept = input.accept;\n    input.accept = StampEditor.supportedTypes;\n\n    const changeEvent = new Event(\"change\");\n    input.dispatchEvent(changeEvent);\n\n    const bitmapPromise = editor.#bitmapPromise;\n    await bitmapPromise;\n\n    const expectedError = new Error(\"Unsupported image type\");\n    try {\n      await bitmapPromise;\n    } catch (error) {\n      expect(error.message).not.toEqual(expectedError.message);\n    }\n\n    input.accept = originalAccept;\n  });\n});",
    "i4_deepseek-r1-distill-llama-70b": "it(\"should only allow supported image types when selecting an image\", async () => {\n  const { StampEditor } = await import(\"../../display/editor/stamp.js\");\n  const { shadow } = await import(\"../../shared/util.js\");\n\n  const supportedTypes = [\n    \"image/apng\",\n    \"image/avif\",\n    \"image/bmp\",\n    \"image/gif\",\n    \"image/jpeg\",\n    \"image/png\",\n    \"image/svg+xml\",\n    \"image/webp\",\n    \"image/x-icon\"\n  ].join(\",\");\n\n  const uiManager = {\n    imageManager: {\n      getFromId: () => null,\n      getFromUrl: () => null,\n      deleteId: () => null,\n      isValidId: () => false\n    }\n  };\n\n  const editor = new StampEditor({\n    bitmapUrl: \"test.jpg\",\n    parent: null,\n    uiManager: uiManager,\n    pageIndex: 0\n  });\n\n  const input = document.createElement(\"input\");\n  input.type = \"file\";\n\n  const expectedAccept = supportedTypes;\n  const actualAccept = input.accept;\n\n  expect(actualAccept).toBe(expectedAccept);\n});",
    "i4_gpt-4o": "it(\"should only allow supported image types for stamp annotation\", async () => {\n  const { StampEditor } = await import(\"../../src/display/editor/stamp.js\");\n  const input = document.createElement(\"input\");\n  const expectedAccept = StampEditor.supportedTypes;\n  input.type = \"file\";\n  input.accept = StampEditor.supportedTypes;\n  const actualAccept = input.accept;\n  expect(actualAccept).toBe(expectedAccept);\n});",
    "i4_llama-3.3-70b-versatile": "it(\"should only allow supported image types when selecting an image in the stamp annotation\", async () => {\n  const { StampEditor } = await import(\"./stamp.js\");\n  const { AnnotationEditorType } = await import(\"../../shared/util.js\");\n  const input = document.createElement(\"input\");\n  input.type = \"file\";\n  const editor = new StampEditor({ type: AnnotationEditorType.STAMP });\n  const file = new File([\"invalid image\"], \"invalid.image\", { type: \"image/invalid\" });\n  const files = [file];\n  const changeEvent = new Event(\"change\");\n  Object.defineProperty(input, \"files\", { value: files });\n  input.dispatchEvent(changeEvent);\n  await new Promise(resolve => setTimeout(resolve, 0));\n  expect(editor.isEmpty()).toBe(true);\n});",
    "i5_deepseek-r1-distill-llama-70b": "it(\"should only accept supported image types when selecting an image\", async () => {\n  const { StampEditor } = await import(\"../../src/display/editor/stamp.js\");\n  const editor = new StampEditor();\n\n  const input = editor._uiManager._input;\n  const expectedTypes = StampEditor.supportedTypes;\n\n  expect(input.accept).toBe(expectedTypes);\n});",
    "i5_gpt-4o": "it(\"should only allow supported image types for stamp annotation\", async () => {\n  const { StampEditor } = await import(\"../../src/display/editor/stamp.js\");\n\n  const input = document.createElement(\"input\");\n  input.type = \"file\";\n  input.accept = StampEditor.supportedTypes;\n\n  const expected = \"image/apng,image/avif,image/bmp,image/gif,image/jpeg,image/png,image/svg+xml,image/webp,image/x-icon\";\n  const actual = input.accept;\n\n  expect(actual).toBe(expected);\n});",
    "i5_llama-3.3-70b-versatile": "it(\"should only allow supported image types when selecting an image in the stamp annotation\", async () => {\n  const { AnnotationEditorType, shadow } = await import(\"../../src/shared/util.js\");\n  const { StampEditor } = await import(\"./stamp.js\");\n\n  const supportedTypes = await StampEditor.supportedTypes;\n  const unsupportedType = \"image/tiff\";\n\n  expect(supportedTypes).not.toContain(unsupportedType);\n  const input = document.createElement(\"input\");\n  input.type = \"file\";\n  input.accept = supportedTypes;\n  document.body.appendChild(input);\n\n  const changeEvent = new Event(\"change\");\n  input.dispatchEvent(changeEvent);\n\n  const file = new File([\"\"], \"example.tiff\", { type: \"image/tiff\" });\n  const dataTransfer = new DataTransfer();\n  dataTransfer.items.add(file);\n  input.files = dataTransfer.files;\n\n  const editor = new StampEditor();\n  await editor.load(input);\n\n  expect(editor.#bitmapPromise).toBeNull();\n});"
  },
  "16780": {
    "i1_deepseek-r1-distill-llama-70b": "it(\"should resize SVG images correctly\", async () => {\n  const { ImageManager } = await import(\"../../src/display/editor/tools.js\");\n  const svgData = `<svg viewBox=\"0 0 1 1\" width=\"1\" height=\"1\" xmlns=\"http://www.w3.org/2000/svg\"><rect width=\"1\" height=\"1\" style=\"fill:red;\"/></svg>`;\n  const svgUrl = `data:image/svg+xml;charset=UTF-8,${encodeURIComponent(svgData)}`;\n\n  const imageManager = new ImageManager();\n  const image = await imageManager.#get(svgUrl, null);\n\n  const canvas = new OffscreenCanvas(1, 1);\n  const ctx = canvas.getContext(\"2d\");\n  ctx.drawImage(image.bitmap, 0, 0, 1, 1);\n\n  const pixels = ctx.getImageData(0, 0, 1, 1).data;\n  const isRed = pixels[0] === 255 && pixels[1] === 0 && pixels[2] === 0;\n\n  expect(isRed).toBe(true);\n});",
    "i1_gpt-4o": "it(\"should resize SVG images without preserving aspect ratio\", async () => {\n  const { ImageManager } = await import(\"../../src/display/editor/tools.js\");\n  const svgData = `data:image/svg+xml;charset=UTF-8,<svg viewBox=\"0 0 1 1\" width=\"1\" height=\"1\" xmlns=\"http://www.w3.org/2000/svg\"><rect width=\"1\" height=\"1\" style=\"fill:red;\"/></svg>`;\n  const imageManager = new ImageManager();\n  const data = await imageManager.#get(\"testKey\", svgData);\n  const canvas = new OffscreenCanvas(1, 3);\n  const ctx = canvas.getContext(\"2d\");\n  ctx.drawImage(data.bitmap, 0, 0, 1, 1, 0, 0, 1, 3);\n  const imageData = ctx.getImageData(0, 0, 1, 1).data;\n  const isResized = new Uint32Array(imageData.buffer)[0] === 0;\n  expect(isResized).toBe(true);\n});",
    "i1_llama-3.3-70b-versatile": "it(\"should resize SVG images horizontallyvertically in pdfjs\", async () => {\n  const { ImageManager } = await import(\"../../src/display/editor/tools.js\");\n  const { Util } = await import(\"../../shared/util.js\");\n  const imageManager = new ImageManager();\n  const svgImage = `data:image/svg+xml;charset=UTF-8,<svg viewBox=\"0 0 100 100\" width=\"100\" height=\"100\" xmlns=\"http://www.w3.org/2000/svg\"><rect width=\"100\" height=\"100\" style=\"fill:red;\"/></svg>`;\n  const image = await imageManager.#get(\"svgImage\", svgImage);\n  const imageElement = image.bitmap;\n  const canvas = new OffscreenCanvas(50, 50);\n  const ctx = canvas.getContext(\"2d\");\n  ctx.drawImage(imageElement, 0, 0, 50, 50);\n  const imageData = ctx.getImageData(0, 0, 50, 50).data;\n  const expectedPixel = [255, 0, 0, 255];\n  const actualPixel = [\n    imageData[0],\n    imageData[1],\n    imageData[2],\n    imageData[3],\n  ];\n  Util.assert(\n    actualPixel.every((val, idx) => val === expectedPixel[idx]),\n    \"SVG image is not resized correctly\"\n  );\n});",
    "i2_deepseek-r1-distill-llama-70b": "it(\"should resize SVG images without preserving aspect ratio\", async () => {\n  const { ImageManager } = await import(\"../../src/display/editor/tools.js\");\n  const { Util } = await import(\"../../shared/util.js\");\n\n  // Create a test SVG image\n  const svg = `data:image/svg+xml;charset=UTF-8,<svg viewBox=\"0 0 1 1\" width=\"1\" height=\"1\" xmlns=\"http://www.w3.org/2000/svg\"><rect width=\"1\" height=\"1\" style=\"fill:red;\"/></svg>`;\n  const image = new Image();\n  image.src = svg;\n  await image.decode();\n\n  // Create a canvas to test resizing\n  const canvas = new OffscreenCanvas(1, 3);\n  const ctx = canvas.getContext(\"2d\");\n\n  // Draw the image on canvas\n  ctx.drawImage(image, 0, 0, 1, 1, 0, 0, 1, 3);\n\n  // Check if the image fills the canvas without preserving aspect ratio\n  const pixels = ctx.getImageData(0, 0, 1, 3).data;\n  const expectedColor = 0xFF0000; // Red color\n\n  // Verify top and bottom pixels to ensure proper resizing\n  const topPixel = new Uint32Array(pixels.buffer)[0];\n  const bottomPixel = new Uint32Array(pixels.buffer)[pixels.length / 4 - 1];\n\n  expect(topPixel).toBe(expectedColor);\n  expect(bottomPixel).toBe(expectedColor);\n});",
    "i2_gpt-4o": "it(\"should allow SVG images to be resized without preserving aspect ratio\", async () => {\n  const { ImageManager } = await import(\"../../src/display/editor/tools.js\");\n  const svgData = `data:image/svg+xml;charset=UTF-8,<svg viewBox=\"0 0 1 1\" width=\"1\" height=\"1\" xmlns=\"http://www.w3.org/2000/svg\"><rect width=\"1\" height=\"1\" style=\"fill:red;\"/></svg>`;\n  const imageManager = new ImageManager();\n  const data = await imageManager.#get(\"testSvg\", svgData);\n  const canvas = new OffscreenCanvas(1, 3);\n  const ctx = canvas.getContext(\"2d\");\n  ctx.drawImage(data.bitmap, 0, 0, 1, 1, 0, 0, 1, 3);\n  const pixelData = new Uint32Array(ctx.getImageData(0, 0, 1, 1).data.buffer)[0];\n  const expected = 0; // Expecting the pixel to be transparent if aspect ratio is not preserved\n  expect(pixelData).toBe(expected);\n});",
    "i2_llama-3.3-70b-versatile": "it(\"should resize SVG images horizontallyvertically without keeping the aspect ratio\", async () => {\n  const { ImageManager } = await import(\"../../src/display/editor/tools.js\");\n  const { Util } = await import(\"../../shared/util.js\");\n  const imageManager = new ImageManager();\n  const svgImage = new Blob([`\n    <svg xmlns=\"http://www.w3.org/2000/svg\" width=\"100\" height=\"100\">\n      <rect width=\"100\" height=\"100\" style=\"fill:red;\"/>\n    </svg>\n  `], { type: \"image/svg+xml\" });\n  const image = await imageManager.#get(\"svgImage\", svgImage);\n  const canvas = new OffscreenCanvas(50, 200);\n  const ctx = canvas.getContext(\"2d\");\n  ctx.drawImage(image.bitmap, 0, 0, 50, 200);\n  const pixels = new Uint32Array(ctx.getImageData(0, 0, 1, 1).data.buffer);\n  const expectedColor = 0xFF0000FF;\n  expect(pixels[0]).toBe(expectedColor);\n});",
    "i3_deepseek-r1-distill-llama-70b": "it(\"should correctly resize SVG images when aspect ratio is not preserved\", async () => {\n  const { ImageManager, shadow } = await import(\"../../src/display/editor/tools.js\");\n  const svg = `data:image/svg+xml;charset=UTF-8,<svg viewBox=\"0 0 1 1\" width=\"1\" height=\"1\" xmlns=\"http://www.w3.org/2000/svg\"><rect width=\"1\" height=\"1\" style=\"fill:red;\"/></svg>`;\n  const canvas = new OffscreenCanvas(1, 3);\n  const ctx = canvas.getContext(\"2d\");\n  const image = new Image();\n  image.src = svg;\n\n  // Create ImageManager instance\n  const imageManager = new ImageManager();\n\n  // Check if aspect ratio needs to be removed\n  const mustRemoveAspectRatio = await ImageManager._checkIfSVGFitsInCanvas();\n\n  // Generate the final SVG URL\n  const finalSvgUrl = mustRemoveAspectRatio \n    ? `${svg}#svgView(preserveAspectRatio(none))` \n    : svg;\n\n  // Load the image using ImageManager\n  const imageData = await imageManager.getFromUrl(finalSvgUrl);\n\n  // Draw the image on the canvas\n  ctx.drawImage(image, 0, 0, 1, 1, 0, 0, 1, 3);\n\n  // Check the pixel color after resizing\n  const pixels = ctx.getImageData(0, 0, 1, 1).data;\n  const pixelColor = `rgb(${pixels[0]}, ${pixels[1]}, ${pixels[2]})`;\n\n  // The expected color should be red (rgb(255, 0, 0))\n  expect(pixelColor).toBe(\"rgb(255, 0, 0)\");\n});",
    "i3_gpt-4o": "it(\"should resize SVG images correctly\", async () => {\n  const { ImageManager } = await import(\"../../src/display/editor/tools.js\");\n  const svgData = `data:image/svg+xml;charset=UTF-8,<svg viewBox=\"0 0 100 100\" xmlns=\"http://www.w3.org/2000/svg\"><rect width=\"100\" height=\"100\" style=\"fill:red;\"/></svg>`;\n  const imageManager = new ImageManager();\n  const imageData = await imageManager.getFromUrl(svgData);\n\n  const canvas = new OffscreenCanvas(100, 200);\n  const ctx = canvas.getContext(\"2d\");\n  ctx.drawImage(imageData.bitmap, 0, 0, 100, 100, 0, 0, 100, 200);\n  const imageDataArray = ctx.getImageData(0, 0, 100, 200).data;\n\n  const isResized = imageDataArray[0] === 255 && imageDataArray[1] === 0 && imageDataArray[2] === 0;\n  expect(isResized).toBe(true);\n});",
    "i3_llama-3.3-70b-versatile": "it(\"should allow resizing of SVG images horizontally and vertically in pdfjs\", async () => {\n  const { AnnotationEditorUIManager, ImageManager } = await import(\"../../src/display/editor/tools.js\");\n  const { AnnotationEditorType } = await import(\"../../shared/util.js\");\n  const { createIdFactory } = await import(\"./test_utils.js\");\n\n  const idFactory = createIdFactory();\n  const imageManager = new ImageManager();\n  const annotationEditorUIManager = new AnnotationEditorUIManager({}, {}, {}, {});\n\n  const svgUrl = \"data:image/svg+xml;charset=UTF-8,<svg viewBox='0 0 100 100' width='100' height='100' xmlns='http://www.w3.org/2000/svg'><rect width='100' height='100' style='fill:red;'/></svg>\";\n\n  const image = await imageManager.getFromUrl(svgUrl);\n  const editor = {\n    id: idFactory(),\n    pageIndex: 0,\n    annotationElementId: idFactory(),\n    type: AnnotationEditorType.IMAGE,\n    isEmpty: () => false,\n    commitOrRemove: () => {},\n    remove: () => {},\n    translateInPage: () => {},\n    select: () => {},\n    unselect: () => {},\n    updateParams: () => {},\n    propertiesToUpdate: {},\n  };\n\n  annotationEditorUIManager.addEditor(editor);\n  annotationEditorUIManager.updateMode(AnnotationEditorType.IMAGE);\n\n  const resizedImage = await imageManager.getFromId(image.id);\n  const resizedSvgUrl = resizedImage.svgUrl;\n\n  expect(resizedSvgUrl).toContain(\"svgView(preserveAspectRatio(none))\");\n});",
    "i4_deepseek-r1-distill-llama-70b": "it(\"should resize SVG images correctly after patch\", async () => {\n  const { ImageManager } = await import(\"../../src/display/editor/tools.js\");\n  const imageManager = new ImageManager();\n\n  const svg = `data:image/svg+xml;charset=UTF-8,<svg viewBox=\"0 0 100 100\" width=\"100\" height=\"100\" xmlns=\"http://www.w3.org/2000/svg\"><rect width=\"100\" height=\"100\" style=\"fill:red;\"/></svg>`;\n  const image = new Image();\n  image.src = svg;\n  await image.decode();\n\n  const canvas = new OffscreenCanvas(50, 25);\n  const ctx = canvas.getContext(\"2d\");\n  ctx.drawImage(image, 0, 0, 50, 25);\n\n  const pixelData = ctx.getImageData(0, 0, 1, 1).data;\n  const isRed = pixelData[0] === 255 && pixelData[1] === 0 && pixelData[2] === 0;\n  expect(isRed).toBe(true);\n});",
    "i4_gpt-4o": "it(\"should resize SVG images without preserving aspect ratio\", async () => {\n  const { ImageManager } = await import(\"../../src/display/editor/tools.js\");\n  const svgData = `data:image/svg+xml;charset=UTF-8,<svg viewBox=\"0 0 1 1\" width=\"1\" height=\"1\" xmlns=\"http://www.w3.org/2000/svg\"><rect width=\"1\" height=\"1\" style=\"fill:red;\"/></svg>`;\n  const imageManager = new ImageManager();\n  const data = await imageManager.getFromUrl(svgData);\n  const canvas = new OffscreenCanvas(1, 3);\n  const ctx = canvas.getContext(\"2d\");\n  ctx.drawImage(data.bitmap, 0, 0, 1, 1, 0, 0, 1, 3);\n  const imageData = ctx.getImageData(0, 0, 1, 1).data;\n  const isResized = imageData[0] === 0 && imageData[1] === 0 && imageData[2] === 0 && imageData[3] === 0;\n  expect(isResized).toBe(true);\n});",
    "i4_llama-3.3-70b-versatile": "it(\"should allow resizing of SVG images horizontally and vertically in pdfjs\", async () => {\n  const { ImageManager } = await import(\"../../src/display/editor/tools.js\");\n  const imageManager = new ImageManager();\n  const svg = `data:image/svg+xml;charset=UTF-8,<svg viewBox=\"0 0 1 1\" width=\"1\" height=\"1\" xmlns=\"http://www.w3.org/2000/svg\"><rect width=\"1\" height=\"1\" style=\"fill:red;\"/></svg>`;\n  const image = await imageManager.getFromUrl(svg);\n  const svgUrl = image.svgUrl;\n  const mustRemoveAspectRatioPromise = await ImageManager._checkIfSVGFitsInCanvas();\n  const newSvgUrl = mustRemoveAspectRatioPromise ? `${svgUrl}#svgView(preserveAspectRatio(none))` : svgUrl;\n  expect(newSvgUrl).not.toBe(svgUrl);\n});",
    "i5_deepseek-r1-distill-llama-70b": "it(\"should correctly resize SVG images in PDF\", async () => {\n  const { PDFDocument } = await import(\"../../src/display/api.js\");\n  const svg = `<svg viewBox=\"0 0 100 100\" width=\"200\" height=\"200\" xmlns=\"http://www.w3.org/2000/svg\">\n    <rect width=\"100\" height=\"100\" style=\"fill:red;\"/>\n  </svg>`;\n  const img = new Image();\n  img.src = `data:image/svg+xml;base64,${btoa(svg)}`;\n\n  const pdf = new PDFDocument();\n  const page = pdf.addPage();\n  const graphics = page.getGraphics();\n\n  await new Promise((resolve) => {\n    img.onload = () => {\n      graphics.drawImage(img, 0, 0, 100, 100);\n      resolve();\n    };\n  });\n\n  const pdfBuffer = await pdf.save();\n\n  const pdfjsLib = await import(\"../../src/display/api.js\");\n  const pdfDoc = await pdfjsLib.PDFDocument.load(pdfBuffer);\n\n  expect(pdfDoc).toBeTruthy();\n});",
    "i5_gpt-4o": "it(\"should resize SVG images without preserving aspect ratio\", async () => {\n  const { ImageManager } = await import(\"../../src/display/editor/tools.js\");\n  const { DOMCanvasFactory } = await import(\"../../src/display/display_utils.js\");\n\n  const svgData = `data:image/svg+xml;charset=UTF-8,<svg viewBox=\"0 0 100 100\" xmlns=\"http://www.w3.org/2000/svg\"><rect width=\"100\" height=\"100\" style=\"fill:red;\"/></svg>`;\n  const canvasFactory = new DOMCanvasFactory();\n  const canvasAndCtx = canvasFactory.create(50, 100);\n  const ctx = canvasAndCtx.context;\n  const image = new Image();\n  image.src = svgData;\n\n  await new Promise((resolve) => (image.onload = resolve));\n  ctx.drawImage(image, 0, 0, 50, 100);\n\n  const imageData = ctx.getImageData(0, 0, 50, 100).data;\n  const isResizedCorrectly = Array.from(imageData).some((value, index) => index % 4 === 0 && value === 255);\n\n  expect(isResizedCorrectly).toBe(true);\n});",
    "i5_llama-3.3-70b-versatile": "it(\"should resize SVG images horizontallyvertically in pdfjs\", async () => {\n  const { PDFDocument, PDFPage } = await import(\"../../src/core/document.js\");\n  const { AnnotationEditorUIManager, ImageManager } = await import(\"../../src/display/editor/tools.js\");\n  const { DOMCanvasFactory } = await import(\"../../src/display/display_utils.js\");\n\n  const pdfDoc = await PDFDocument.load(await (await import(\"../../src/display/api.js\")).PDFDocumentLoadingTask.fromData(new Uint8Array([/* your test pdf file */])));\n  const page = pdfDoc.getPage(1);\n  const canvasFactory = new DOMCanvasFactory();\n  const annotationEditor = new AnnotationEditorUIManager(page, canvasFactory);\n\n  const svgImage = `data:image/svg+xml;charset=UTF-8,<svg viewBox=\"0 0 100 100\" width=\"100\" height=\"100\" xmlns=\"http://www.w3.org/2000/svg\"><rect width=\"100\" height=\"100\" style=\"fill:red;\"/></svg>`;\n\n  const imageManager = new ImageManager();\n  const imageElement = new Image();\n  imageElement.src = svgImage;\n\n  await new Promise((resolve) => {\n    imageElement.onload = resolve;\n  });\n\n  const canvas = canvasFactory.createCanvas(100, 200);\n  const ctx = canvas.getContext(\"2d\");\n  ctx.drawImage(imageElement, 0, 0, 100, 200);\n\n  const actualImageData = ctx.getImageData(0, 0, 100, 200).data;\n  const expectedImageData = new Uint8ClampedArray(100 * 200 * 4);\n\n  for (let i = 0; i < expectedImageData.length; i += 4) {\n    expectedImageData[i] = 255; // red\n    expectedImageData[i + 1] = 0; // green\n    expectedImageData[i + 2] = 0; // blue\n    expectedImageData[i + 3] = 255; // alpha\n  }\n\n  let imagesAreEqual = true;\n  for (let i = 0; i < actualImageData.length; i++) {\n    if (actualImageData[i] !== expectedImageData[i]) {\n      imagesAreEqual = false;\n      break;\n    }\n  }\n\n  expect(imagesAreEqual).toBe(true);\n});"
  },
  "16784": {
    "i1_deepseek-r1-distill-llama-70b": "it(\"should allow SVG images to be resized horizontally and vertically\", async () => {\n  const svgData = `<svg viewBox=\"0 0 100 100\" width=\"100\" height=\"100\" xmlns=\"http://www.w3.org/2000/svg\"><rect width=\"100\" height=\"100\" style=\"fill:red;\"/></svg>`;\n  const svgUrl = `data:image/svg+xml;base64,${btoa(svgData)}`;\n  const image = new Image();\n  image.src = svgUrl;\n  await new Promise((resolve) => (image.onload = resolve));\n\n  const canvas = new OffscreenCanvas(50, 150);\n  const ctx = canvas.getContext(\"2d\");\n  ctx.drawImage(image, 0, 0, 50, 150);\n\n  const expectedPixel = new Uint32Array([0xff000000]);\n  const actualPixels = new Uint32Array(ctx.getImageData(0, 0, 1, 1).data.buffer);\n\n  expect(actualPixels[0]).toBe(expectedPixel[0]);\n});",
    "i1_gpt-4o": "it(\"should allow SVG images to be resized horizontallyvertically\", async () => {\n  const { ImageManager } = await import(\"../../src/display/editor/tools.js\");\n  const svgData = `data:image/svg+xml;charset=UTF-8,<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"100\" height=\"100\"><rect width=\"100\" height=\"100\" style=\"fill:blue;\"/></svg>`;\n  const imageManager = new ImageManager();\n  const data = await imageManager.#get(\"testSvg\", svgData);\n  const canvas = new OffscreenCanvas(200, 200);\n  const ctx = canvas.getContext(\"2d\");\n  ctx.drawImage(data.bitmap, 0, 0, 200, 200);\n  const imageData = ctx.getImageData(0, 0, 1, 1).data;\n  const isResized = imageData[2] === 255; // Check if the pixel is blue\n  expect(isResized).toBe(true);\n});",
    "i1_llama-3.3-70b-versatile": "it(\"should allow resizing of SVG images in pdfjs\", async () => {\n  const { ImageManager } = await import(\"../../src/display/editor/tools.js\");\n  const { Util } = await import(\"../../shared/util.js\");\n  const imageManager = new ImageManager();\n  const svgImage = new Blob([`\n    <svg viewBox=\"0 0 100 100\" width=\"100\" height=\"100\" xmlns=\"http://www.w3.org/2000/svg\">\n      <rect width=\"100\" height=\"100\" style=\"fill:red;\"/>\n    </svg>\n  `], { type: \"image/svg+xml\" });\n  const imageData = await imageManager.#get(\"svgImage\", svgImage);\n  const imageElement = imageData.bitmap;\n  imageElement.width = 200;\n  imageElement.height = 200;\n  const expectedWidth = 200;\n  const expectedHeight = 200;\n  assert.strictEqual(imageElement.width, expectedWidth);\n  assert.strictEqual(imageElement.height, expectedHeight);\n});",
    "i2_deepseek-r1-distill-llama-70b": "it(\"should correctly handle SVG image resizing after getter change\", async () => {\n  const { ImageManager } = await import(\"../../src/display/editor/tools.js\");\n  const { Util } = await import(\"../../shared/util.js\");\n\n  // Create a test SVG image\n  const svgData = `<svg viewBox=\"0 0 100 100\" width=\"100\" height=\"100\" xmlns=\"http://www.w3.org/2000/svg\">\n    <rect width=\"100\" height=\"100\" style=\"fill:red;\"/>\n  </svg>`;\n  const svgUrl = `data:image/svg+xml;charset=UTF-8,${encodeURIComponent(svgData)}`;\n\n  // Create ImageManager instance\n  const imageManager = new ImageManager();\n\n  // Get the SVG image\n  const image = await imageManager.#get(\"test-svg\", svgUrl);\n\n  // Check if the SVG image was properly handled\n  const expectedSvgUrl = new URL(svgUrl);\n  const expectedParam = \"svgView(preserveAspectRatio(none))\";\n\n  // Verify the workaround was applied\n  const actualImageUrl = image.bitmap.src;\n  const actualUrl = new URL(actualImageUrl);\n\n  // Assert the URL contains the expected parameter\n  assert(actualUrl.pathname.includes(expectedParam), \"SVG image should include preserveAspectRatio(none)\");\n});",
    "i2_gpt-4o": "it(\"should allow SVG images to be resized horizontallyvertically\", async () => {\n  const { shadow } = await import(\"../../src/shared/util.js\");\n  const { ImageManager } = await import(\"../../src/display/editor/tools.js\");\n\n  const svgData = `data:image/svg+xml;charset=UTF-8,<svg viewBox=\"0 0 1 1\" width=\"1\" height=\"1\" xmlns=\"http://www.w3.org/2000/svg\"><rect width=\"1\" height=\"1\" style=\"fill:red;\"/></svg>`;\n  const imageManager = new ImageManager();\n\n  const dataBeforePatch = await imageManager.#get(\"testKey\", svgData);\n  const isSvgBeforePatch = dataBeforePatch.isSvg;\n\n  shadow(ImageManager, \"_isSVGFittingCanvas\", Promise.resolve(true));\n\n  const dataAfterPatch = await imageManager.#get(\"testKey\", svgData);\n  const isSvgAfterPatch = dataAfterPatch.isSvg;\n\n  expect(isSvgBeforePatch).toBe(false);\n  expect(isSvgAfterPatch).toBe(true);\n});",
    "i2_llama-3.3-70b-versatile": "it(\"should allow resizing of SVG images horizontallyvertically in pdfjs\", async () => {\n  const { ImageManager } = await import(\"../../src/display/editor/tools.js\");\n  const { Util } = await import(\"../../shared/util.js\");\n  const imageManager = new ImageManager();\n  const svgImage = new Blob([`<svg viewBox=\"0 0 1 1\" width=\"1\" height=\"1\" xmlns=\"http://www.w3.org/2000/svg\"><rect width=\"1\" height=\"1\" style=\"fill:red;\"/></svg>`], { type: \"image/svg+xml\" });\n  const image = await imageManager.#get(\"svgImage\", svgImage);\n  const expected = true;\n  const actual = image.isSvg;\n  Util.assert(actual === expected, `Expected image.isSvg to be ${expected}, but got ${actual}`);\n});",
    "i3_deepseek-r1-distill-llama-70b": "it(\"should correctly resize SVG images\", async () => {\n  const { ImageManager } = await import(\"../../src/display/editor/tools.js\");\n  const { AnnotationEditorUIManager } = await import(\"../../src/display/editor/tools.js\");\n  const { Annotation } = await import(\"../../src/core/annotation.js\");\n  const { AnnotationFactory } = await import(\"../../src/core/annotation.js\");\n  const { Ref, Dict } = await import(\"../../src/core/primitives.js\");\n  const { XRefMock } = await import(\"./test_utils.js\");\n\n  const xref = new XRefMock();\n  const pdfDocument = {\n    annotationStorage: {\n      get: () => new Ref(1),\n      add: () => {},\n      remove: () => {},\n      has: () => true,\n    },\n    filterFactory: {},\n  };\n  const eventBus = {\n    _on: () => {},\n    _off: () => {},\n    dispatch: () => {},\n  };\n  const container = {\n    focus: () => {},\n  };\n\n  const imageManager = new ImageManager();\n  const uiManager = new AnnotationEditorUIManager(container, eventBus, pdfDocument, {});\n\n  const svg = `data:image/svg+xml;charset=UTF-8,<svg viewBox=\"0 0 100 100\" width=\"100\" height=\"100\"><rect width=\"100\" height=\"100\" style=\"fill:red;\"/></svg>`;\n  const image = await imageManager.getFromUrl(svg);\n\n  const annotation = AnnotationFactory.create(AnnotationType.INK);\n  annotation.setFlags(AnnotationFlag.HIDDEN);\n  const editor = await annotation.createEditor();\n  editor.annotationElementId = \"test-id\";\n\n  const layer = {\n    addOrRebuild: () => {},\n    get: () => ({ viewport: {} }),\n  };\n  uiManager.addLayer(layer);\n\n  const svgElement = await image.bitmap;\n  const originalWidth = svgElement.width;\n  const originalHeight = svgElement.height;\n  const resizedWidth = 200;\n  const resizedHeight = 200;\n\n  editor.resize(resizedWidth, resizedHeight);\n\n  const resizedSvg = await imageManager.getFromUrl(svg);\n  const resizedWidthActual = resizedSvg.width;\n  const resizedHeightActual = resizedSvg.height;\n\n  expect(resizedWidthActual).toBe(resizedWidth);\n  expect(resizedHeightActual).toBe(resizedHeight);\n});",
    "i3_gpt-4o": "it(\"should allow SVG images to be resized horizontallyvertically\", async () => {\n  const { ImageManager } = await import(\"../../src/display/editor/tools.js\");\n  const svgData = `data:image/svg+xml;charset=UTF-8,<svg viewBox=\"0 0 1 1\" width=\"1\" height=\"1\" xmlns=\"http://www.w3.org/2000/svg\"><rect width=\"1\" height=\"1\" style=\"fill:red;\"/></svg>`;\n  const imageManager = new ImageManager();\n  const imageData = await imageManager.getFromUrl(svgData);\n  const canvas = new OffscreenCanvas(2, 2);\n  const ctx = canvas.getContext(\"2d\");\n  ctx.drawImage(imageData.bitmap, 0, 0, 2, 2);\n  const imageDataArray = ctx.getImageData(0, 0, 2, 2).data;\n  const isResized = imageDataArray[0] === 255 && imageDataArray[1] === 0 && imageDataArray[2] === 0;\n  expect(isResized).toBe(true);\n});",
    "i3_llama-3.3-70b-versatile": "it(\"should allow resizing of SVG images in pdfjs\", async () => {\n  const { AnnotationEditorUIManager, ImageManager } = await import(\"../../src/display/editor/tools.js\");\n  const { AnnotationEditorType } = await import(\"../../shared/util.js\");\n  const imageManager = new ImageManager();\n  const annotationEditorUIManager = new AnnotationEditorUIManager(null, null, null, null);\n  const svgImage = `data:image/svg+xml;charset=UTF-8,<svg viewBox=\"0 0 100 100\" width=\"100\" height=\"100\" xmlns=\"http://www.w3.org/2000/svg\"><rect width=\"100\" height=\"100\" style=\"fill:red;\"/></svg>`;\n\n  const imageData = await imageManager.getFromUrl(svgImage);\n  const svgUrl = imageManager.getSvgUrl(imageData.id);\n\n  expect(svgUrl).not.toBeNull();\n  expect(svgUrl).toContain(\"svgView(preserveAspectRatio(none))\");\n});",
    "i4_deepseek-r1-distill-llama-70b": "it(\"should resize SVG images correctly when added\", async () => {\n  const { ImageManager } = await import(\"../../src/display/editor/tools.js\");\n  const svg = `data:image/svg+xml;charset=UTF-8,<svg viewBox=\"0 0 1 1\" width=\"1\" height=\"1\" xmlns=\"http://www.w3.org/2000/svg\"><rect width=\"1\" height=\"1\" style=\"fill:red;\"/></svg>`;\n  const imageManager = new ImageManager();\n\n  // Create a canvas to draw the SVG\n  const canvas = new OffscreenCanvas(1, 3);\n  const ctx = canvas.getContext(\"2d\");\n\n  // Get the image bitmap\n  const image = await imageManager.getFromUrl(svg);\n\n  // Draw the image on the canvas\n  ctx.drawImage(image.bitmap, 0, 0, 1, 1, 0, 0, 1, 3);\n\n  // Check the pixel data\n  const pixels = ctx.getImageData(0, 0, 1, 1).data;\n  const bottomPixel = ctx.getImageData(0, 2, 1, 1).data;\n\n  // The bottom of the canvas should now be red due to resizing\n  expect(pixels[0]).toBe(255); // Red\n  expect(pixels[1]).toBe(0);   // Green\n  expect(pixels[2]).toBe(0);   // Blue\n  expect(bottomPixel[0]).toBe(255); // Resized area should also be red\n});",
    "i4_gpt-4o": "it(\"should allow SVG images to be resized horizontallyvertically\", async () => {\n  const { ImageManager } = await import(\"../../src/display/editor/tools.js\");\n  const svgData = `data:image/svg+xml;charset=UTF-8,<svg viewBox=\"0 0 1 1\" width=\"1\" height=\"1\" xmlns=\"http://www.w3.org/2000/svg\"><rect width=\"1\" height=\"1\" style=\"fill:red;\"/></svg>`;\n  const imageManager = new ImageManager();\n  const imageData = await imageManager.getFromUrl(svgData);\n  const canvas = new OffscreenCanvas(2, 2);\n  const ctx = canvas.getContext(\"2d\");\n  ctx.drawImage(imageData.bitmap, 0, 0, 2, 2);\n  const imageDataArray = ctx.getImageData(0, 0, 2, 2).data;\n  const expected = [255, 0, 0, 255];\n  const actual = Array.from(imageDataArray.slice(0, 4));\n  expect(actual).toEqual(expected);\n});",
    "i4_llama-3.3-70b-versatile": "it(\"should allow resizing of SVG images in pdfjs\", async () => {\n  const { ImageManager } = await import(\"../../src/display/editor/tools.js\");\n  const imageManager = new ImageManager();\n  const svgImage = new Blob([`\n    <svg viewBox=\"0 0 100 100\" width=\"100\" height=\"100\" xmlns=\"http://www.w3.org/2000/svg\">\n      <rect width=\"100\" height=\"100\" style=\"fill:red;\"/>\n    </svg>\n  `], { type: \"image/svg+xml\" });\n  const image = await imageManager.getFromFile(svgImage);\n  const svgUrl = imageManager.getSvgUrl(image.id);\n  const expectedSvgUrl = svgUrl.includes(\"#svgView(preserveAspectRatio(none))\");\n  expect(expectedSvgUrl).toBe(true);\n});",
    "i5_deepseek-r1-distill-llama-70b": "it(\"should correctly resize SVG images\", async () => {\n  const { ImageManager } = await import(\"../../src/display/editor/tools.js\");\n  const svg = `<svg width=\"100\" height=\"100\" viewBox=\"0 0 100 100\"><rect width=\"100\" height=\"100\" fill=\"red\"/></svg>`;\n\n  // Create a test image element\n  const image = new Image();\n  image.src = `data:image/svg+xml,${encodeURIComponent(svg)}`;\n\n  // Load the image using ImageManager\n  const imageManager = new ImageManager();\n  const imagePromise = imageManager.get(\"test\", image);\n\n  // Create a canvas to draw the image\n  const canvas = document.createElement(\"canvas\");\n  const ctx = canvas.getContext(\"2d\");\n  canvas.width = 50;\n  canvas.height = 50;\n\n  // Draw the image on the canvas after it's loaded\n  image.onload = async () => {\n    const imageBitmap = await imagePromise;\n    ctx.drawImage(imageBitmap, 0, 0, canvas.width, canvas.height);\n\n    // Check if the image was resized correctly by checking the pixel color\n    const pixel = ctx.getImageData(0, 0, 1, 1).data;\n    const expectedColor = [255, 0, 0, 255]; // Red color\n\n    // Compare the actual pixel color with the expected color\n    if (pixel.every((value, index) => value === expectedColor[index])) {\n      // Resizing was successful\n      console.assert(true);\n    } else {\n      console.assert(false, \"SVG image was not resized correctly\");\n    }\n  };\n});",
    "i5_gpt-4o": "it(\"should allow SVG images to be resized horizontallyvertically\", async () => {\n  const { ImageManager } = await import(\"../../src/display/editor/tools.js\");\n  const { shadow } = await import(\"../../src/shared/util.js\");\n\n  const imageManager = new ImageManager();\n  const svgImage = { type: \"image/svg+xml\" };\n  const rawData = new Uint8Array();\n\n  const mustRemoveAspectRatioPromise = ImageManager._isSVGFittingCanvas;\n  const expected = shadow(imageManager, \"_isSVGFittingCanvas\", mustRemoveAspectRatioPromise);\n\n  const actual = await imageManager.#get(svgImage, rawData);\n  expect(actual).toEqual(expected);\n});",
    "i5_llama-3.3-70b-versatile": "it(\"should resize SVG images horizontallyvertically in pdfjs\", async () => {\n  const { PDFDocument, PDFPageProxy } = await import(\"../../src/display/api.js\");\n  const { AnnotationEditorUIManager, CommandManager } = await import(\"../../src/display/editor/tools.js\");\n  const { PDFDateString, PageViewport } = await import(\"../../src/display/display_utils.js\");\n  const { Util } = await import(\"../../src/shared/util.js\");\n\n  const pdfDoc = await PDFDocument.load(await (await import(\"../../src/display/fetch_stream.js\")).PDFFetchStream.fetch(\"path_to_pdf_file\"));\n  const pdfPage = pdfDoc.getPage(1);\n  const viewport = pdfPage.getViewport({ scale: 1 });\n  const annotationEditorUIManager = new AnnotationEditorUIManager();\n  const commandManager = new CommandManager();\n\n  const svgImage = `<svg width=\"100\" height=\"100\"><rect x=\"10\" y=\"10\" width=\"50\" height=\"50\" fill=\"#ff0000\"/></svg>`;\n\n  const expectedWidth = 200;\n  const expectedHeight = 200;\n\n  const annotation = await annotationEditorUIManager.addSVGAnnotation(svgImage, viewport);\n  await commandManager.resizeAnnotation(annotation, expectedWidth, expectedHeight);\n\n  const actualWidth = annotation.width;\n  const actualHeight = annotation.height;\n\n  Util.assert(actualWidth === expectedWidth, `Expected width ${expectedWidth} but got ${actualWidth}`);\n  Util.assert(actualHeight === expectedHeight, `Expected height ${expectedHeight} but got ${actualHeight}`);\n});"
  },
  "16804": {
    "i1_deepseek-r1-distill-llama-70b": "it(\"should not show pushpin when fillAlpha is\", async () => {\n  const { getDocument } = await import(\"../../src/display/api.js\");\n  const { buildGetDocumentParams } = await import(\"./test_utils.js\");\n  const { Annotation } = await import(\"../../src/core/annotation.js\");\n\n  try {\n    const loadingTask = getDocument(buildGetDocumentParams('issue16800.pdf'));\n    const { numPages, page } = await loadingTask;\n    await page.init(1);\n    await page.render();\n\n    const annotations = await page.getAnnotations();\n    const pushpinAnnotation = annotations.find(\n      (annotation) => annotation.type === Annotation.Type.FILEATTACHMENT\n    );\n\n    const renderSpy = jest.spyOn(\n      FileAttachmentAnnotationElement.prototype,\n      'render'\n    );\n\n    await page.render();\n\n    const trigger = renderSpy.mock.results[0].value.#trigger;\n    const expectedOpacity = 0;\n    const actualOpacity = parseInt(trigger.style.opacity) || 1;\n\n    expect(actualOpacity).toBe(expectedOpacity);\n  } catch (error) {\n    fail(error);\n  }\n});",
    "i1_gpt-4o": "it(\"should not display the pin when fillAlpha is\", async () => {\n  const { getDocument } = await import('../../src/display/api.js');\n  const { buildGetDocumentParams } = await import('./test_utils.js');\n  const loadingTask = getDocument(buildGetDocumentParams('issue16800.pdf'));\n  const pdfDocument = await loadingTask.promise;\n  const page = await pdfDocument.getPage(2);\n  const annotations = await page.getAnnotations();\n\n  const fileAttachmentAnnotation = annotations.find(\n    annotation => annotation.subtype === 'FileAttachment'\n  );\n\n  const expectedFillAlpha = 0;\n  const actualFillAlpha = fileAttachmentAnnotation.fillAlpha;\n\n  expect(actualFillAlpha).toBe(expectedFillAlpha);\n});",
    "i1_llama-3.3-70b-versatile": "it(\"should render file attachment annotation without pin when fillAlpha is\", async () => {\n  const { getDocument } = await import('../../src/display/api.js');\n  const { buildGetDocumentParams } = await import('./test_utils.js');\n  const loadingTask = getDocument(buildGetDocumentParams('issue16800.pdf'));\n  const pdfDoc = await loadingTask.promise;\n  const page = await pdfDoc.getPage(2);\n  const annotationLayer = await import('../../src/display/annotation_layer.js');\n  const annotationLayerInstance = new annotationLayer.AnnotationLayer({\n    page,\n    viewport: page.getViewport({ scale: 1 }),\n    renderInteractiveForms: false,\n  });\n  const annotations = await annotationLayerInstance.render();\n  const fileAttachmentAnnotation = annotations.find(annotation => annotation instanceof annotationLayer.FileAttachmentAnnotationElement);\n  const trigger = fileAttachmentAnnotation.#trigger;\n  const expectedStyle = 'filter: opacity(0%);';\n  expect(trigger.style).toBe(expectedStyle);\n});",
    "i2_deepseek-r1-distill-llama-70b": "it(\"should remove embedded images when fillAlpha is zero\", async () => {\n  const { getDocument } = await import(\"../../src/display/api.js\");\n  const { buildGetDocumentParams } = await import(\"./test_utils.js\");\n  const loadingTask = getDocument(buildGetDocumentParams('issue16800.pdf'));\n\n  const pdf = await loadingTask.promise;\n  const page = await pdf.getPage(2);\n  const annotationLayer = await page.getAnnotationLayer();\n  const annotations = await annotationLayer.getAnnotations();\n\n  const fileAttachmentAnnotation = annotations.find(annotation => \n    annotation instanceof (await import(\"../../src/core/annotation.js\")).FileAttachmentAnnotation\n  );\n\n  const annotationElement = new (await import(\"../../src/display/annotation_layer.js\")).FileAttachmentAnnotationElement({\n    annotation: fileAttachmentAnnotation,\n    page: page,\n    data: fileAttachmentAnnotation.data,\n    imageResourcesPath: \"\",\n    linkService: null,\n    l10n: null,\n    isKeyboardNavigationEnabled: false\n  });\n\n  await annotationElement.render();\n  const trigger = annotationElement.#trigger;\n\n  expect(trigger.style.opacity).toBe('0');\n});",
    "i2_gpt-4o": "it(\"should not display the pin icon when fillAlpha is\", async () => {\n  const { getDocument } = await import('../../src/display/api.js');\n  const { buildGetDocumentParams } = await import('./test_utils.js');\n  const loadingTask = getDocument(buildGetDocumentParams('issue16800.pdf'));\n  const pdfDocument = await loadingTask.promise;\n  const page = await pdfDocument.getPage(2);\n  const annotations = await page.getAnnotations();\n  const fileAttachmentAnnotation = annotations.find(\n    annotation => annotation.subtype === 'FileAttachment'\n  );\n  const expected = 0;\n  const actual = fileAttachmentAnnotation.fillAlpha;\n  expect(actual).toBe(expected);\n});",
    "i2_llama-3.3-70b-versatile": "it(\"should render FileAttachmentAnnotation with correct opacity\", async () => {\n  const { getDocument } = await import('../../src/display/api.js');\n  const { buildGetDocumentParams } = await import('./test_utils.js');\n  const loadingTask = getDocument(buildGetDocumentParams('issue16800.pdf'));\n  const pdfDocument = await loadingTask.promise;\n  const pdfPage = await pdfDocument.getPage(2);\n  const annotationLayer = await import('../../src/display/annotation_layer.js');\n  const annotationLayerInstance = new annotationLayer.AnnotationLayer({\n    page: pdfPage,\n    viewport: pdfPage.getViewport({ scale: 1 }),\n    renderInteractiveForms: false,\n  });\n  const annotations = await pdfPage.getAnnotations();\n  const fileAttachmentAnnotation = annotations.find(annotation => annotation instanceof annotationLayer.FileAttachmentAnnotation);\n  const trigger = annotationLayerInstance.renderAnnotation(fileAttachmentAnnotation);\n  const expectedOpacity = 0.5; // assuming fill-alpha is 0.5 in the pdf\n  const actualOpacity = parseFloat(trigger.style.filter.match(/opacity\\((\\d+)%/)[1]) / 100);\n  expect(actualOpacity).toBeCloseTo(expectedOpacity);\n});",
    "i3_deepseek-r1-distill-llama-70b": "it(\"should remove embedded images correctly by setting fillAlpha\", async () => {\n  const { getDocument } = await import('../../src/display/api.js');\n  const { buildGetDocumentParams, createIdFactory } = await import('./test_utils.js');\n\n  const loadingTask = getDocument(buildGetDocumentParams('issue16800.pdf'));\n  const pdfDocument = await loadingTask;\n  const idFactory = createIdFactory();\n\n  const expectedFillAlpha = 0.5;\n\n  const annotationRef = new Ref(1);\n  const dict = new Dict({\n    Type: 'Annot',\n    Subtype: 'FileAttachment',\n    T: 'Test Annotation',\n    Contents: 'Test Content',\n    Rect: [0, 0, 100, 100],\n    FS: 'EmbeddedFile',\n    Name: 'PushPin'\n  });\n\n  const annotation = new FileAttachmentAnnotation({\n    dict,\n    xref: new XRefMock(idFactory),\n    pdfManager: null,\n    idFactory,\n    collectFields: false\n  });\n\n  const actualFillAlpha = annotation.data.fillAlpha;\n\n  expect(actualFillAlpha).toBe(expectedFillAlpha);\n});",
    "i3_gpt-4o": "it(\"should not render the pin when fillAlpha is\", async () => {\n  const { getDocument } = await import(\"../../src/display/api.js\");\n  const { buildGetDocumentParams } = await import(\"./test_utils.js\");\n  const loadingTask = getDocument(buildGetDocumentParams(\"issue16800.pdf\"));\n  const pdfDocument = await loadingTask.promise;\n  const page = await pdfDocument.getPage(2);\n  const annotations = await page.getAnnotations();\n  const fileAttachmentAnnotation = annotations.find(\n    ann => ann.subtype === \"FileAttachment\"\n  );\n  expect(fileAttachmentAnnotation).toBeDefined();\n  expect(fileAttachmentAnnotation.fillAlpha).toBe(0);\n});",
    "i3_llama-3.3-70b-versatile": "it(\"should remove embedded images\", async () => {\n  const { getDocument } = await import('../../src/display/api.js');\n  const { buildGetDocumentParams } = await import('./test_utils.js');\n  const loadingTask = getDocument(buildGetDocumentParams('issue16800.pdf'));\n  const pdfDocument = await loadingTask.promise;\n  const pdfPage = await pdfDocument.getPage(2);\n  const annotations = await pdfPage.getAnnotations();\n  const annotation = annotations[0];\n  const annotationElement = new AnnotationElement({\n    data: annotation,\n    layer: document.createElement('div'),\n    linkService: null,\n    downloadManager: null,\n    annotationStorage: null,\n    renderForms: true,\n    svgFactory: null,\n  });\n  const renderedAnnotation = annotationElement.render();\n  const image = renderedAnnotation.querySelector('img');\n  expect(image).toBeNull();\n});",
    "i4_deepseek-r1-distill-llama-70b": "it(\"should remove black pin annotation covering image\", async () => {\n  const { getDocument } = await import('../../src/display/api.js');\n  const { buildGetDocumentParams } = await import('./test_utils.js');\n\n  const loadingTask = getDocument(buildGetDocumentParams('issue16800.pdf'));\n  const { pdfDocument } = await loadingTask;\n  const page = await pdfDocument.getPage(1);\n  const viewport = page.getViewport({ scale: 1 });\n  const annotations = await page.getAnnotations({});\n\n  const annotation = annotations.find(a => a.data.subtype === 'FileAttachment');\n\n  expect(annotation.data.fillAlpha).toBe(0);\n});",
    "i4_gpt-4o": "it(\"should not display the pin on page\", async () => {\n  const { getDocument } = await import('../../src/display/api.js');\n  const { buildGetDocumentParams } = await import('./test_utils.js');\n  const loadingTask = getDocument(buildGetDocumentParams('issue16800.pdf'));\n  const pdfDocument = await loadingTask.promise;\n  const page = await pdfDocument.getPage(2);\n  const annotations = await page.getAnnotations();\n  const fileAttachmentAnnotation = annotations.find(\n    annotation => annotation.subtype === 'FileAttachment'\n  );\n  const expected = null;\n  const actual = fileAttachmentAnnotation.fillAlpha;\n  expect(actual).toBe(expected);\n});",
    "i4_llama-3.3-70b-versatile": "it(\"should remove embedded images from annotations\", async () => {\n  const { getDocument } = await import('../../src/display/api.js');\n  const { buildGetDocumentParams } = await import('./test_utils.js');\n  const loadingTask = getDocument(buildGetDocumentParams('issue16800.pdf'));\n  const pdfDoc = await loadingTask.promise;\n  const pdfPage = await pdfDoc.getPage(2);\n  const annotation = await pdfPage.getAnnotations();\n  const annotationData = annotation[0];\n  const { Annotation } = await import('../../src/core/annotation.js');\n  const annotationInstance = new Annotation({\n    dict: annotationData,\n    xref: pdfDoc.xref,\n    pdfManager: pdfDoc.pdfManager,\n    idFactory: pdfDoc.idFactory,\n  });\n  const expectedAppearance = null;\n  const actualAppearance = annotationInstance.appearance;\n  expect(actualAppearance).toBe(expectedAppearance);\n});",
    "i5_deepseek-r1-distill-llama-70b": "it(\"should make embedded images transparent when fillAlpha is set\", async () => {\n  const { getDocument } = await import(\"../../src/display/api.js\");\n  const { buildGetDocumentParams } = await import(\"./test_utils.js\");\n  const loadingTask = getDocument(buildGetDocumentParams('issue16800.pdf'));\n  const { numPages, pages } = await loadingTask.promise;\n\n  const page = await pages.open(0); // Open page 2 in the PDF (index 0)\n  const viewport = page.getViewport(1);\n  const annotationLayer = new AnnotationLayer({\n    container: document.createElement('div'),\n    page,\n    viewport,\n    renderInteractive: true\n  });\n\n  await annotationLayer.render();\n\n  const trigger = annotationLayer.#trigger;\n  const expectedOpacity = 0.5; // Based on the patch, fillAlpha should be set\n\n  expect(trigger.style.filter).toBeDefined();\n  const actualOpacity = Number(trigger.style.filter.match(/\\d+/)[0]) / 100;\n\n  expect(actualOpacity).toBeLessThan(1);\n});",
    "i5_gpt-4o": "it(\"should not display the pin on page\", async () => {\n  const { getDocument } = await import('../../src/display/api.js');\n  const { buildGetDocumentParams } = await import('./test_utils.js');\n  const loadingTask = getDocument(buildGetDocumentParams('issue16800.pdf'));\n  const pdfDocument = await loadingTask.promise;\n  const page = await pdfDocument.getPage(2);\n  const annotations = await page.getAnnotations();\n  const fileAttachmentAnnotation = annotations.find(\n    annotation => annotation.subtype === 'FileAttachment'\n  );\n  const expectedFillAlpha = 0;\n  const actualFillAlpha = fileAttachmentAnnotation.fillAlpha;\n  expect(actualFillAlpha).toBe(expectedFillAlpha);\n});",
    "i5_llama-3.3-70b-versatile": "it(\"should render file attachment annotation with fill alpha\", async () => {\n  const { getDocument } = await import('../../src/display/api.js');\n  const { buildGetDocumentParams } = await import('./test_utils.js');\n  const loadingTask = getDocument(buildGetDocumentParams('issue16800.pdf'));\n  const pdfDocument = await loadingTask.promise;\n  const pdfPage = await pdfDocument.getPage(2);\n  const annotationLayer = await import('../../src/display/annotation_layer.js');\n  const annotationLayerBuilder = await import('../../web/annotation_layer_builder.js');\n  const annotationLayerInstance = new annotationLayer.AnnotationLayer({\n    page: pdfPage,\n    viewport: pdfPage.getViewport({ scale: 1 }),\n    renderInteractiveForms: false,\n  });\n  const annotations = await pdfPage.getAnnotations();\n  const fileAttachmentAnnotation = annotations.find(annotation => annotation instanceof annotationLayer.FileAttachmentAnnotation);\n  const trigger = annotationLayerInstance.renderAnnotation(fileAttachmentAnnotation);\n  const expectedOpacity = 0.5; // assuming fill alpha is 0.5 in the pdf\n  const actualOpacity = parseFloat(trigger.style.filter.match(/opacity\\((\\d+)%/)[1]) / 100;\n  expect(actualOpacity).toBeCloseTo(expectedOpacity);\n});"
  },
  "16828": {
    "i1_deepseek-r1-distill-llama-70b": "it(\"should create a new editor when pasting an image from clipboard\", async () => {\n  const { AnnotationEditorUIManager } = await import(\"../../src/display/editor/tools.js\");\n  const { StampEditor } = await import(\"../../src/display/editor/stamp.js\");\n\n  // Mock clipboard event with image data\n  const mockClipboardEvent = {\n    preventDefault: () => {},\n    clipboardData: {\n      items: [\n        {\n          type: \"image/png\",\n          getAsFile: () => new File([/* png data */ \"iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mNkYAAAAAYAAjCB0C8AAAAASUVORK5CYII=\"], \"image/png\")\n        }\n      ]\n    }\n  };\n\n  // Mock UI manager\n  const uiManager = new AnnotationEditorUIManager(\n    {} as any,\n    {} as any,\n    {} as any,\n    {} as any,\n    {} as any\n  );\n\n  // Mock editor layer\n  const mockLayer = {\n    deserialize: () => new StampEditor({}),\n    add: () => {}\n  };\n\n  // Register editor types\n  uiManager.registerEditorTypes([StampEditor]);\n\n  // Add mock layer\n  uiManager.addLayer(mockLayer);\n\n  // Call paste method\n  uiManager.paste(mockClipboardEvent);\n\n  // Verify that a new editor was created\n  expect(uiManager.#allEditors.size).toBeGreaterThan(0);\n});",
    "i1_gpt-4o": "it(\"should support pasting an image from the clipboard in editing mode\", async () => {\n  const { AnnotationEditorUIManager } = await import(\"../../src/display/editor/tools.js\");\n  const { AnnotationEditorLayer } = await import(\"../../src/display/editor/annotation_editor_layer.js\");\n  const { StampEditor } = await import(\"../../src/display/editor/stamp.js\");\n  const { AnnotationEditorType } = await import(\"../../src/shared/util.js\");\n\n  const uiManager = new AnnotationEditorUIManager(null, null, null, { annotationStorage: {}, filterFactory: {} }, null);\n  const layer = new AnnotationEditorLayer({\n    uiManager,\n    pageIndex: 0,\n    div: document.createElement(\"div\"),\n    accessibilityManager: null,\n    annotationLayer: null,\n    viewport: { rotation: 0, rawDims: { pageWidth: 100, pageHeight: 100, pageX: 0, pageY: 0 } },\n    l10n: null,\n  });\n\n  uiManager.addLayer(layer);\n  uiManager.updateMode(AnnotationEditorType.STAMP);\n\n  const clipboardEvent = new ClipboardEvent(\"paste\", {\n    clipboardData: new DataTransfer(),\n  });\n  clipboardEvent.clipboardData.items.add(new File([\"\"], \"image.png\", { type: \"image/png\" }));\n\n  uiManager.paste(clipboardEvent);\n\n  const editors = Array.from(layer.#editors.values());\n  expect(editors.length).toBe(1);\n  expect(editors[0] instanceof StampEditor).toBe(true);\n});",
    "i1_llama-3.3-70b-versatile": "it(\"should support pasting an image from the clipboard\", async () => {\n  const { AnnotationEditorUIManager, AnnotationEditorLayer, StampEditor } = await import(\"../../src/display/editor/tools.js\");\n  const { AnnotationEditorType } = await import(\"../../shared/util.js\");\n  const editorLayer = new AnnotationEditorLayer({\n    uiManager: new AnnotationEditorUIManager(),\n    pageIndex: 0,\n    div: document.createElement(\"div\"),\n    accessibilityManager: null,\n    annotationLayer: null,\n    viewport: { rotation: 0, width: 100, height: 100 },\n    l10n: null,\n  });\n  const clipboardData = new DataTransfer();\n  const file = new File([\"image\"], \"image.png\", { type: \"image/png\" });\n  clipboardData.items.add(file);\n  const event = new ClipboardEvent(\"paste\", { clipboardData });\n  editorLayer.uiManager.paste(event);\n  expect(editorLayer.uiManager.currentLayer.editors.size).toBe(1);\n  const editor = Array.from(editorLayer.uiManager.currentLayer.editors.values())[0];\n  expect(editor.constructor).toBe(StampEditor);\n});",
    "i2_deepseek-r1-distill-llama-70b": "it(\"should create a stamp editor when pasting an image from clipboard\", async () => {\n  const { AnnotationEditorLayer, AnnotationEditorUIManager } = \n    await import(\"../../src/display/editor/annotation_editor_layer.js\");\n  const { StampEditor } = await import(\"../../src/display/editor/stamp.js\");\n\n  const container = { addEventListener: () => {}, removeEventListener: () => {} };\n  const viewer = { currentLayer: {} };\n  const eventBus = { _on: () => {} };\n  const pdfDocument = { annotationStorage: {} };\n  const pageColors = {};\n\n  const uiManager = new AnnotationEditorUIManager(\n    container, viewer, eventBus, pdfDocument, pageColors\n  );\n  const layer = new AnnotationEditorLayer({\n    uiManager,\n    pageIndex: 0,\n    div: {},\n    accessibilityManager: {},\n    annotationLayer: {},\n    viewport: {},\n    l10n: {}\n  });\n\n  // Mock clipboard event with image data\n  const clipboardData = {\n    items: [\n      {\n        type: \"image/png\",\n        getAsFile: () => new File([\"\"], \"test.png\", { type: \"image/png\" })\n      }\n    ],\n    getData: () => \"\"\n  };\n\n  const event = { clipboardData, preventDefault: () => {} };\n\n  // Paste should not create editor before patch ( StampEditor not handling MIME )\n  const initialEditorsCount = uiManager.#allEditors.size;\n  uiManager.paste(event);\n  expect(uiManager.#allEditors.size).toBe(initialEditorsCount);\n\n  // After patch, pasting image creates StampEditor\n  const afterPatchEditorsCount = uiManager.#allEditors.size;\n  expect(afterPatchEditorsCount - initialEditorsCount).toBe(1);\n  const newEditor = Array.from(uiManager.#allEditors.values()).pop();\n  expect(newEditor).toBeInstanceOf(StampEditor);\n});",
    "i2_gpt-4o": "it(\"should paste an image from the clipboard in editing mode\", async () => {\n  const { AnnotationEditorUIManager } = await import(\"../../src/display/editor/tools.js\");\n  const { AnnotationEditorLayer } = await import(\"../../src/display/editor/annotation_editor_layer.js\");\n  const { StampEditor } = await import(\"../../src/display/editor/stamp.js\");\n  const { AnnotationEditorType } = await import(\"../../src/shared/util.js\");\n\n  const mockEventBus = { _on: () => {} };\n  const mockPdfDocument = { annotationStorage: {}, filterFactory: {} };\n  const mockContainer = {};\n  const mockViewer = {};\n  const mockPageColors = {};\n  const uiManager = new AnnotationEditorUIManager(mockContainer, mockViewer, mockEventBus, mockPdfDocument, mockPageColors);\n\n  const mockDiv = document.createElement(\"div\");\n  const mockViewport = { rotation: 0, rawDims: { pageWidth: 100, pageHeight: 100, pageX: 0, pageY: 0 } };\n  const layer = new AnnotationEditorLayer({\n    uiManager,\n    pageIndex: 0,\n    div: mockDiv,\n    accessibilityManager: null,\n    annotationLayer: null,\n    viewport: mockViewport,\n    l10n: null,\n  });\n\n  uiManager.updateMode(AnnotationEditorType.STAMP);\n\n  const clipboardData = new DataTransfer();\n  const file = new File([\"\"], \"image.png\", { type: \"image/png\" });\n  clipboardData.items.add(file);\n\n  const pasteEvent = new ClipboardEvent(\"paste\", { clipboardData });\n  uiManager.paste(pasteEvent);\n\n  const expected = true;\n  const actual = Array.from(layer.#editors.values()).some(editor => editor instanceof StampEditor && editor.#bitmapFile === file);\n\n  expect(actual).toBe(expected);\n});",
    "i2_llama-3.3-70b-versatile": "it(\"should create a new stamp editor when pasting an image from the clipboard\", async () => {\n  const { AnnotationEditorUIManager, AnnotationEditorLayer, StampEditor } = await import(\"../../src/display/editor/tools.js\");\n  const { AnnotationEditorType } = await import(\"../../shared/util.js\");\n  const { document } = globalThis;\n\n  const uiManager = new AnnotationEditorUIManager(null, null, null, null, null);\n  const layer = new AnnotationEditorLayer({\n    uiManager,\n    pageIndex: 0,\n    div: document.createElement(\"div\"),\n    accessibilityManager: null,\n    annotationLayer: null,\n    viewport: { rotation: 0, width: 100, height: 100 },\n    l10n: null,\n  });\n\n  const clipboardData = {\n    items: [\n      {\n        type: \"image/png\",\n        getAsFile: () => new File([\"image_data\"], \"image.png\", { type: \"image/png\" }),\n      },\n    ],\n  };\n\n  const event = { clipboardData, preventDefault: () => {} };\n\n  uiManager.paste(event);\n\n  const newEditor = layer.editors.get(layer.editors.size - 1);\n\n  expect(newEditor).toBeInstanceOf(StampEditor);\n});",
    "i3_deepseek-r1-distill-llama-70b": "it(\"should create a stamp editor when pasting an image from clipboard\", async () => {\n  const { default: AnnotationEditorUIManager } = await import(\"../../src/display/editor/tools.js\");\n  const { default: StampEditor } = await import(\"../../src/display/editor/stamp.js\");\n\n  // Setup mock data\n  const mockClipboardData = {\n    items: [\n      {\n        type: \"image/png\",\n        kind: \"file\",\n        getAsFile: () => new File([\"iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAYAAAC4qZBY4GYAAACGIHgYk5PjdXQBFY5jGPbIHMID1mQUAAIABAAAAABAAEAQB8AAEAfAAABAAgAZGF0YU\", \"base64\"])\n      }\n    ],\n    getData: () => \"application/pdfjs\"\n  };\n\n  // Create UI manager and layer\n  const uiManager = new AnnotationEditorUIManager({\n    container: document.createElement(\"div\"),\n    viewer: document.createElement(\"div\"),\n    eventBus: {\n      _on: () => {},\n      _off: () => {},\n      dispatch: () => {}\n    },\n    pdfDocument: {\n      annotationStorage: {\n        has: () => false,\n        getValue: () => null,\n        setValue: () => {},\n        remove: () => {}\n      },\n      filterFactory: {}\n    },\n    pageColors: {}\n  });\n\n  const layer = {\n    div: document.createElement(\"div\"),\n    enable() {},\n    disable() {},\n    updateMode() {},\n    addOrRebuild: (editor) => {\n      editor.parent = this;\n    }\n  };\n\n  uiManager.addLayer(layer);\n\n  // Dispatch paste event\n  const event = {\n    preventDefault: () => {},\n    clipboardData: mockClipboardData\n  };\n\n  await uiManager.paste(event);\n\n  // Verify that a StampEditor was created and added to the layer\n  const editors = uiManager.getEditors(layer.pageIndex);\n  const stampEditor = editors.find(editor => editor instanceof StampEditor);\n\n  expect(stampEditor).toBeDefined();\n  expect(layer.addOrRebuild).toHaveBeenCalled();\n});",
    "i3_gpt-4o": "it(\"should support pasting an image from the clipboard in editing mode\", async () => {\n  const { AnnotationEditorUIManager } = await import(\"../../src/display/editor/tools.js\");\n  const { AnnotationEditorLayer } = await import(\"../../src/display/editor/annotation_editor_layer.js\");\n  const { StampEditor } = await import(\"../../src/display/editor/stamp.js\");\n  const { AnnotationEditorType } = await import(\"../../src/shared/util.js\");\n\n  const uiManager = new AnnotationEditorUIManager(null, null, { _on: () => {}, _off: () => {} }, null, null);\n  const layer = new AnnotationEditorLayer({\n    uiManager,\n    pageIndex: 0,\n    div: document.createElement(\"div\"),\n    accessibilityManager: null,\n    annotationLayer: null,\n    viewport: { rotation: 0, rawDims: { pageWidth: 100, pageHeight: 100, pageX: 0, pageY: 0 } },\n    l10n: null,\n  });\n\n  uiManager.addLayer(layer);\n  uiManager.updateMode(AnnotationEditorType.STAMP);\n\n  const clipboardData = {\n    items: [\n      {\n        type: \"image/png\",\n        getAsFile: () => new Blob([\"fake image data\"], { type: \"image/png\" }),\n      },\n    ],\n  };\n\n  const pasteEvent = new ClipboardEvent(\"paste\", { clipboardData });\n  document.dispatchEvent(pasteEvent);\n\n  const editors = Array.from(layer.#editors.values());\n  const hasStampEditor = editors.some(editor => editor instanceof StampEditor);\n\n  expect(hasStampEditor).toBe(true);\n});",
    "i3_llama-3.3-70b-versatile": "it(\"should support pasting an image from the clipboard\", async () => {\n  const { AnnotationEditorUIManager, AnnotationEditorLayer, StampEditor } = await import(\"../../src/display/editor/tools.js\");\n  const { AnnotationEditor } = await import(\"../../src/display/editor/editor.js\");\n  const uiManager = new AnnotationEditorUIManager(null, null, null, null, null);\n  const layer = new AnnotationEditorLayer({ uiManager, div: document.createElement(\"div\"), pageIndex: 0, viewport: { width: 100, height: 100 } });\n  uiManager.addLayer(layer);\n  const event = new ClipboardEvent(\"paste\", { clipboardData: new DataTransfer() });\n  event.clipboardData.items.add(new File([\"image\"], \"image.png\", { type: \"image/png\" }));\n  uiManager.paste(event);\n  expect(uiManager.getMode()).toBe(AnnotationEditor.Type.STAMP);\n});",
    "i4_deepseek-r1-distill-llama-70b": "it(\"should paste an image from clipboard in editing mode\", async () => {\n  const { AnnotationEditorUIManager } = await import(\"../../src/display/editor/tools.js\");\n  const { AnnotationEditorLayer } = await import(\"../../src/display/editor/annotation_editor_layer.js\");\n  const { JSDOM } = await import(\"jsdom\");\n\n  // Setup mock DOM\n  const dom = new JSDOM();\n  globalThis.document = dom.window.document;\n  globalThis.window = dom.window;\n\n  // Mock clipboard data\n  const mockClipboardData = {\n    items: [{ kind: \"file\", type: \"image/png\", getAsFile: () => new File([\"\"], \"mock.png\") }],\n    getData: () => \"mock-image-data\"\n  };\n\n  // Mock paste event\n  const mockEvent = {\n    preventDefault: jest.fn(),\n    clipboardData: mockClipboardData\n  };\n\n  // Create UI manager and layer\n  const uiManager = new AnnotationEditorUIManager(null, null, null, null, null);\n  const layer = new AnnotationEditorLayer({\n    uiManager: uiManager,\n    div: document.createElement(\"div\"),\n    pageIndex: 0,\n    l10n: {},\n    accessibilityManager: null,\n    annotationLayer: null,\n    viewport: null\n  });\n\n  // Set up editing mode\n  uiManager.updateMode(AnnotationEditorType.STAMP);\n\n  // Dispatch paste event\n  document.body.dispatchEvent(new dom.window.CustomEvent(\"paste\", { detail: mockEvent }));\n\n  // Check if editor was added\n  expect(layer.isEmpty).toBe(false);\n});",
    "i4_gpt-4o": "it(\"should support pasting an image from the clipboard in editing mode\", async () => {\n  const { AnnotationEditorUIManager } = await import(\"../../src/display/editor/tools.js\");\n  const { AnnotationEditorLayer } = await import(\"../../src/display/editor/annotation_editor_layer.js\");\n  const { StampEditor } = await import(\"../../src/display/editor/stamp.js\");\n  const { AnnotationEditorType } = await import(\"../../src/shared/util.js\");\n\n  const mockEventBus = { _on: () => {}, _off: () => {}, dispatch: () => {} };\n  const mockPdfDocument = { annotationStorage: new Map(), filterFactory: {} };\n  const mockContainer = document.createElement(\"div\");\n  const mockViewer = document.createElement(\"div\");\n  const uiManager = new AnnotationEditorUIManager(mockContainer, mockViewer, mockEventBus, mockPdfDocument, null);\n\n  const mockDiv = document.createElement(\"div\");\n  const layer = new AnnotationEditorLayer({\n    uiManager,\n    pageIndex: 0,\n    div: mockDiv,\n    accessibilityManager: null,\n    annotationLayer: null,\n    viewport: { rotation: 0, rawDims: { pageWidth: 100, pageHeight: 100, pageX: 0, pageY: 0 } },\n    l10n: null,\n  });\n\n  uiManager.addLayer(layer);\n  uiManager.updateMode(AnnotationEditorType.STAMP);\n\n  const clipboardData = new DataTransfer();\n  const file = new File([\"\"], \"image.png\", { type: \"image/png\" });\n  clipboardData.items.add(file);\n\n  const pasteEvent = new ClipboardEvent(\"paste\", { clipboardData });\n  document.dispatchEvent(pasteEvent);\n\n  const editors = Array.from(uiManager.getEditors(0));\n  const hasStampEditor = editors.some(editor => editor instanceof StampEditor);\n\n  expect(hasStampEditor).toBe(true);\n});",
    "i4_llama-3.3-70b-versatile": "it(\"should support pasting an image from the clipboard\", async () => {\n  const { AnnotationEditorUIManager } = await import(\"../../src/display/editor/tools.js\");\n  const { StampEditor } = await import(\"../../src/display/editor/stamp.js\");\n  const uiManager = new AnnotationEditorUIManager(null, null, null, null, null);\n  const editor = new StampEditor({ parent: null, id: \"id\", uiManager });\n  const item = { type: \"image/png\", getAsFile: () => new File([\"image\"], \"image.png\") };\n  const clipboardData = { items: [item] };\n  const event = { clipboardData, preventDefault: () => {} };\n  uiManager.paste(event);\n  expect(StampEditor.isHandlingMimeForPasting(item.type)).toBe(true);\n});",
    "i5_deepseek-r1-distill-llama-70b": "it(\"should support pasting an image from clipboard\", async () => {\n  const { AnnotationEditorUIManager } = await import(\"../../src/display/editor/tools.js\");\n  const { StampEditor } = await import(\"../../src/display/editor/stamp.js\");\n\n  const uiManager = new AnnotationEditorUIManager();\n  const currentLayer = {\n    add: jest.fn(),\n    getNextId: () => \"test-id\",\n    div: {\n      getBoundingClientRect: () => ({\n        x: 0,\n        y: 0,\n        width: 100,\n        height: 100,\n      }),\n    },\n  };\n  uiManager.currentLayer = currentLayer;\n\n  const clipboardData = {\n    items: [\n      new DataTransferItem(\n        new File([\"test\"], \"test.png\", { type: \"image/png\" }),\n        \"image/png\"\n      ),\n    ],\n    getData: () => \"test-data\",\n  };\n\n  const event = {\n    preventDefault: jest.fn(),\n    clipboardData,\n  };\n\n  const mockAddEventListener = jest.fn();\n  const mockAdd = jest.fn();\n\n  currentLayer.add = mockAdd;\n  currentLayer.addEventListener = mockAddEventListener;\n\n  await uiManager.paste(event);\n\n  // Wait for async operations\n  await new Promise(resolve => setTimeout(resolve, 100));\n\n  expect(mockAddEventListener).toHaveBeenCalled();\n  expect(uiManager.currentEditor).toBeInstanceOf(StampEditor);\n  expect(uiManager.currentEditor.#bitmapFile).toBeTruthy();\n});",
    "i5_gpt-4o": "it(\"should support pasting an image from the clipboard in editing mode\", async () => {\n  const { AnnotationEditorUIManager } = await import(\"../../src/display/editor/tools.js\");\n  const { AnnotationEditorLayer } = await import(\"../../src/display/editor/annotation_editor_layer.js\");\n  const { StampEditor } = await import(\"../../src/display/editor/stamp.js\");\n  const { AnnotationEditorType } = await import(\"../../src/shared/util.js\");\n\n  const uiManager = new AnnotationEditorUIManager();\n  const layer = new AnnotationEditorLayer({ uiManager });\n  uiManager.currentLayer = layer;\n\n  const clipboardData = {\n    items: [\n      {\n        type: \"image/png\",\n        getAsFile: () => new Blob([\"image data\"], { type: \"image/png\" }),\n      },\n    ],\n  };\n\n  const pasteEvent = new Event(\"paste\");\n  pasteEvent.clipboardData = clipboardData;\n\n  uiManager.paste(pasteEvent);\n\n  const editors = layer.editors;\n  const hasStampEditor = editors.some(editor => editor instanceof StampEditor);\n\n  expect(hasStampEditor).toBe(true);\n});",
    "i5_llama-3.3-70b-versatile": "it(\"should paste an image from the clipboard\", async () => {\n  const { AnnotationEditorLayer, AnnotationEditorUIManager, AnnotationEditorType } = await import(\"../../src/display/editor/annotation_editor_layer.js\");\n  const { StampEditor } = await import(\"../../src/display/editor/stamp.js\");\n  const { Util } = await import(\"../../src/shared/util.js\");\n\n  const editorLayer = new AnnotationEditorLayer();\n  const uiManager = new AnnotationEditorUIManager();\n  const stampEditor = new StampEditor({});\n\n  const file = new File(['image data'], 'image.png', { type: 'image/png' });\n  const clipboardData = { items: [{ kind: 'file', type: 'image/png', getAsFile: () => file }] };\n\n  const pasteSpy = jest.spyOn(StampEditor, 'paste');\n  const pasteEditorSpy = jest.spyOn(editorLayer, 'pasteEditor');\n\n  uiManager.paste({ clipboardData });\n  expect(pasteSpy).toHaveBeenCalledTimes(1);\n  expect(pasteEditorSpy).toHaveBeenCalledTimes(1);\n  expect(pasteEditorSpy).toHaveBeenCalledWith(AnnotationEditorType.STAMP, { bitmapFile: file });\n});"
  },
  "16899": {
    "i1_deepseek-r1-distill-llama-70b": "it(\"should display freetext annotation when popup data is present\", async () => {\n  const { getDocument } = await import('../../src/display/api.js');\n  const { buildGetDocumentParams } = await import('./test_utils.js');\n  const loadingTask = getDocument(buildGetDocumentParams('bug1851498.pdf'));\n  const pdf = await loadingTask.promise;\n  const page = await pdf.getPage(1);\n  const pageProxy = new (await import('../../src/display/api.js').then(m => m.PDFPageProxy))(page);\n  const annotations = await pageProxy.getAnnotations();\n\n  const freeTextAnnotation = annotations.find(annotation => \n    annotation instanceof (await import('../../src/display/annotation_layer.js').then(m => m.FreeTextAnnotationElement))\n  );\n\n  expect(freeTextAnnotation).toBeTruthy();\n});",
    "i1_gpt-4o": "it(\"should display FreeText annotation\", async () => {\n  const { getDocument } = await import(\"../../src/display/api.js\");\n  const { buildGetDocumentParams } = await import(\"./test_utils.js\");\n  const loadingTask = getDocument(buildGetDocumentParams(\"bug1851498.pdf\"));\n  const pdfDocument = await loadingTask.promise;\n  const page = await pdfDocument.getPage(1);\n  const annotations = await page.getAnnotations();\n  const freeTextAnnotations = annotations.filter(\n    annotation => annotation.subtype === \"FreeText\"\n  );\n  expect(freeTextAnnotations.length).toBeGreaterThan(0);\n  expect(freeTextAnnotations[0].contents).toBeTruthy();\n});",
    "i1_llama-3.3-70b-versatile": "it(\"should display FreeText annotation with popup data\", async () => {\n  const { getDocument } = await import('../../src/display/api.js');\n  const { buildGetDocumentParams } = await import('./test_utils.js');\n  const loadingTask = getDocument(buildGetDocumentParams('bug1851498.pdf'));\n  const pdfDocument = await loadingTask.promise;\n  const pdfPage = await pdfDocument.getPage(1);\n  const annotationStorage = new (await import('../../src/display/annotation_storage.js')).AnnotationStorage();\n  const annotationLayer = new (await import('../../src/display/annotation_layer.js')).AnnotationLayer({\n    page: pdfPage,\n    viewport: pdfPage.getViewport({ scale: 1 }),\n    annotationStorage: annotationStorage,\n    renderForms: true,\n    linkService: null,\n    downloadManager: null,\n    imageResourcesPath: '',\n    enableScripting: false,\n    hasJSActions: false,\n    fieldObjects: {},\n    parent: null,\n  });\n  const annotations = await pdfPage.getAnnotations();\n  const freeTextAnnotation = annotations.find(annotation => annotation.subtype === 'FreeText');\n  const freeTextAnnotationElement = new (await import('../../src/display/annotation_layer.js')).FreeTextAnnotationElement({\n    data: freeTextAnnotation,\n    layer: annotationLayer,\n    linkService: null,\n    downloadManager: null,\n    imageResourcesPath: '',\n    renderForms: true,\n    svgFactory: new (await import('../../src/display/display_utils.js')).DOMSVGFactory(),\n    annotationStorage: annotationStorage,\n    enableScripting: false,\n    hasJSActions: false,\n    fieldObjects: {},\n    parent: null,\n  });\n  const container = freeTextAnnotationElement.render();\n  expect(container.querySelector('.annotationTextContent')).not.toBeNull();\n  expect(container.querySelector('.popupTriggerArea')).not.toBeNull();\n});",
    "i2_deepseek-r1-distill-llama-70b": "it(\"should render freetext annotation without popup data\", async () => {\n  const { getDocument } = await import(\"../../src/display/api.js\");\n  const { buildGetDocumentParams } = await import(\"./test_utils.js\");\n  const loadingTask = getDocument(buildGetDocumentParams('bug1851498.pdf'));\n\n  const pdf = await loadingTask.promise;\n  const page = await pdf.getPage(1);\n  const annotationLayer = new (await import(\"./annotation_layer.js\")).AnnotationLayer({\n    page,\n    linkService: { eventBus: { dispatch: () => {} } },\n    downloadManager: { download: () => Promise.resolve() },\n    imageResourcesPath: \"\",\n    renderForms: false,\n    svgFactory: new (await import(\"./display_utils.js\")).DOMSVGFactory(),\n    annotationStorage: new (await import(\"./annotation_storage.js\")).AnnotationStorage(),\n    enableScripting: false,\n    hasJSActions: false,\n    fieldObjects: [],\n    parent: null,\n  });\n\n  const container = document.createElement(\"div\");\n  annotationLayer.render(container);\n\n  const freeTextAnnotation = container.querySelector(\".freeTextAnnotation\");\n\n  expect(freeTextAnnotation).toBeTruthy();\n});",
    "i2_gpt-4o": "it(\"should display FreeText annotation\", async () => {\n  const { getDocument } = await import('../../src/display/api.js');\n  const { buildGetDocumentParams } = await import('./test_utils.js');\n  const loadingTask = getDocument(buildGetDocumentParams('bug1851498.pdf'));\n  const pdfDocument = await loadingTask.promise;\n  const page = await pdfDocument.getPage(1);\n  const annotations = await page.getAnnotations();\n  const freeTextAnnotations = annotations.filter(\n    annotation => annotation.subtype === 'FreeText'\n  );\n  expect(freeTextAnnotations.length).toBeGreaterThan(0);\n  const annotation = freeTextAnnotations[0];\n  expect(annotation).toHaveProperty('contents');\n  expect(annotation.contents).not.toBeNull();\n});",
    "i2_llama-3.3-70b-versatile": "it(\"should display FreeText annotation\", async () => {\n  const { getDocument } = await import('../../src/display/api.js');\n  const { buildGetDocumentParams } = await import('./test_utils.js');\n  const loadingTask = getDocument(buildGetDocumentParams('bug1851498.pdf'));\n  const pdfDocument = await loadingTask.promise;\n  const pdfPage = await pdfDocument.getPage(1);\n  const annotationStorage = new (await import('../../src/display/annotation_storage.js')).AnnotationStorage();\n  const annotationLayer = new (await import('../../src/display/annotation_layer.js')).AnnotationLayer({\n    page: pdfPage,\n    viewport: pdfPage.getViewport({ scale: 1 }),\n    annotationStorage: annotationStorage,\n    renderForms: true,\n    linkService: null,\n    downloadManager: null,\n    imageResourcesPath: '',\n    enableScripting: false,\n    hasJSActions: false,\n    fieldObjects: {},\n    parent: null,\n  });\n  const annotations = await pdfPage.getAnnotations();\n  const freeTextAnnotation = annotations.find(annotation => annotation.subtype === 'FreeText');\n  const freeTextAnnotationElement = new (await import('../../src/display/annotation_layer.js')).FreeTextAnnotationElement({\n    data: freeTextAnnotation,\n    layer: annotationLayer,\n    linkService: null,\n    downloadManager: null,\n    imageResourcesPath: '',\n    renderForms: true,\n    svgFactory: new (await import('../../src/display/display_utils.js')).DOMSVGFactory(),\n    annotationStorage: annotationStorage,\n    enableScripting: false,\n    hasJSActions: false,\n    fieldObjects: {},\n    parent: null,\n  });\n  const container = freeTextAnnotationElement.render();\n  expect(container.children.length).toBeGreaterThan(0);\n});",
    "i3_deepseek-r1-distill-llama-70b": "it(\"should render freetext annotation\", async () => {\n  const { getDocument } = await import(\"../../src/display/api.js\");\n  const { buildGetDocumentParams } = await import(\"./test_utils.js\");\n  const loadingTask = getDocument(buildGetDocumentParams('bug1851498.pdf'));\n\n  try {\n    const pdf = await loadingTask.promise;\n    const page = await pdf.getPage(1);\n    const viewport = page.getViewPort({ scale: 1 });\n\n    class AnnotationLayer {\n      constructor() {\n        this.div = document.createElement('div');\n        this.zIndex = 0;\n      }\n\n      async render(params) {\n        const { annotations } = params;\n        setLayerDimensions(this.div, viewport);\n\n        const elementParams = {\n          data: null,\n          layer: this.div,\n          linkService: null,\n          downloadManager: null,\n          imageResourcesPath: \"\",\n          renderForms: true,\n          svgFactory: null,\n          annotationStorage: null,\n          enableScripting: false,\n          hasJSActions: false,\n          fieldObjects: null,\n          parent: this\n        };\n\n        for (const data of annotations) {\n          if (data.annotationType === AnnotationType.FREETEXT) {\n            elementParams.data = data;\n            const element = new FreeTextAnnotationElement(elementParams);\n            const rendered = element.render();\n            this.div.append(rendered);\n          }\n        }\n      }\n    }\n\n    const layer = new AnnotationLayer();\n    await layer.render({ annotations: page.getAnnotations() });\n\n    const freetextAnnotations = layer.div.querySelectorAll('.freeTextAnnotation');\n    expect(freetextAnnotations.length).toBeGreaterThan(0);\n  } catch (error) {\n    throw new Error('Failed to load or render PDF');\n  }\n});",
    "i3_gpt-4o": "it(\"should display FreeText annotation\", async () => {\n  const { getDocument } = await import(\"../../src/display/api.js\");\n  const { buildGetDocumentParams } = await import(\"./test_utils.js\");\n  const loadingTask = getDocument(buildGetDocumentParams(\"bug1851498.pdf\"));\n  const pdfDocument = await loadingTask.promise;\n  const page = await pdfDocument.getPage(1);\n  const annotations = await page.getAnnotations({ intent: \"display\" });\n\n  const freeTextAnnotations = annotations.filter(\n    annotation => annotation.annotationType === AnnotationType.FREETEXT\n  );\n\n  expect(freeTextAnnotations.length).toBeGreaterThan(0);\n  expect(freeTextAnnotations[0].hasPopupData).toBe(true);\n});",
    "i3_llama-3.3-70b-versatile": "it(\"should display FreeText annotation\", async () => {\n  const { getDocument } = await import('../../src/display/api.js');\n  const { buildGetDocumentParams } = await import('./test_utils.js');\n  const loadingTask = getDocument(buildGetDocumentParams('bug1851498.pdf'));\n  const pdfDocument = await loadingTask.promise;\n  const pdfPage = await pdfDocument.getPage(1);\n  const viewport = pdfPage.getViewport({ scale: 1 });\n  const annotationLayer = new (await import('../../src/display/annotation_layer.js')).AnnotationLayer({\n    div: document.createElement('div'),\n    page: pdfPage,\n    viewport: viewport,\n    linkService: null,\n    downloadManager: null,\n  });\n  const annotations = await pdfPage.getAnnotations();\n  await annotationLayer.render({ annotations, page: pdfPage, viewport, linkService: null, downloadManager: null });\n  const freeTextAnnotations = annotations.filter(annotation => annotation.subtype === 'FreeText');\n  expect(freeTextAnnotations.length).toBeGreaterThan(0);\n  const freeTextAnnotation = freeTextAnnotations[0];\n  const freeTextElement = annotationLayer.div.querySelector(`[data-annotation-id=\"${freeTextAnnotation.id}\"]`);\n  expect(freeTextElement).not.toBeNull();\n  expect(freeTextElement.querySelector('.annotationTextContent')).not.toBeNull();\n});",
    "i4_deepseek-r1-distill-llama-70b": "it(\"should display FreeText annotation\", async () => {\n  const { getDocument } = await import(\"../../src/display/api.js\");\n  const { buildGetDocumentParams } = await import(\"./test_utils.js\");\n  const loadingTask = getDocument(buildGetDocumentParams('bug1851498.pdf'));\n  const pdfDoc = await loadingTask.promise;\n\n  const page = await pdfDoc.getPage(1);\n  const viewport = page.getViewPort({ scale: 1 });\n\n  const l10n = new (await import(\"../../src/shared/util.js\")).NullL10n();\n  const linkService = { eventBus: { dispatch: () => {} } };\n  const downloadManager = {};\n\n  const annotationLayer = new (await import(\"./annotation_layer.js\")).AnnotationLayer({\n    div: document.createElement(\"div\"),\n    accessibilityManager: null,\n    annotationCanvasMap: null,\n    l10n,\n    page,\n    viewport,\n  });\n\n  await annotationLayer.render({\n    annotations: await page.getAnnotations({}),\n    linkService,\n    downloadManager,\n    renderForms: true,\n  });\n\n  const container = annotationLayer.div.querySelector(\".freeTextAnnotation\");\n  expect(container).toBeTruthy();\n});",
    "i4_gpt-4o": "it(\"should display FreeText annotation\", async () => {\n  const { getDocument } = await import('../../src/display/api.js');\n  const { buildGetDocumentParams } = await import('./test_utils.js');\n  const loadingTask = getDocument(buildGetDocumentParams('bug1851498.pdf'));\n  const pdfDocument = await loadingTask.promise;\n  const page = await pdfDocument.getPage(1);\n  const annotations = await page.getAnnotations();\n  const freeTextAnnotations = annotations.filter(\n    annotation => annotation.subtype === 'FreeText'\n  );\n  const hasPopupData = freeTextAnnotations.some(annotation => \n    annotation.title || annotation.contents || annotation.richText\n  );\n  expect(hasPopupData).toBe(true);\n});",
    "i4_llama-3.3-70b-versatile": "it(\"should display FreeText annotation\", async () => {\n  const { getDocument } = await import('../../src/display/api.js');\n  const { buildGetDocumentParams } = await import('./test_utils.js');\n  const loadingTask = getDocument(buildGetDocumentParams('bug1851498.pdf'));\n  const pdfDocument = await loadingTask.promise;\n  const pdfPage = await pdfDocument.getPage(1);\n  const viewport = pdfPage.getViewport({ scale: 1 });\n  const annotationLayer = new (await import('../../src/display/annotation_layer.js')).AnnotationLayer({\n    div: document.createElement('div'),\n    page: pdfPage,\n    viewport: viewport,\n    linkService: null,\n    downloadManager: null,\n  });\n  const annotations = await pdfPage.getAnnotations();\n  await annotationLayer.render({ annotations, viewport });\n  const freeTextAnnotations = annotations.filter(annotation => annotation.subtype === 'FreeText');\n  expect(freeTextAnnotations.length).toBeGreaterThan(0);\n  const freeTextAnnotationElement = annotationLayer.getEditableAnnotation(freeTextAnnotations[0].id);\n  expect(freeTextAnnotationElement).not.toBeNull();\n  expect(freeTextAnnotationElement.container.hidden).toBe(false);\n});",
    "i5_deepseek-r1-distill-llama-70b": "it(\"should display FreeText annotation with content\", async () => {\n  const { getDocument } = await import('../../src/display/api.js');\n  const { buildGetDocumentParams } = await import('./test_utils.js');\n  const loadingTask = getDocument(buildGetDocumentParams('bug1851498.pdf'));\n\n  const { pdfDocument } = await loadingTask;\n  const page = await pdfDocument.getPage(1);\n  const annotationLayer = await import('../../src/display/annotation_layer.js');\n  const annotationLayerInstance = new annotationLayer.AnnotationLayer({\n    page,\n    viewport: page.getViewport({ scale: 1 }),\n    renderInteractiveForms: true,\n  });\n\n  const annotations = await page.getAnnotations();\n  const freeTextAnnotation = annotations.find(annotation => annotation.subtype === 'FreeText');\n\n  expect(freeTextAnnotation).toBeTruthy();\n\n  const hasPopupData = freeTextAnnotation.titleObj?.str || \n                      freeTextAnnotation.contentsObj?.str || \n                      freeTextAnnotation.richText?.str;\n\n  expect(hasPopupData).toBeTruthy();\n\n  annotationLayerInstance.render();\n\n  const popupTrigger = annotationLayerInstance.container.querySelector('.popupTriggerArea');\n  if (popupTrigger) {\n    popupTrigger.click();\n  }\n\n  const popup = annotationLayerInstance.container.querySelector('.popup');\n  expect(popup).toBeTruthy();\n});",
    "i5_gpt-4o": "it(\"should display FreeText annotation\", async () => {\n  const { getDocument } = await import('../../src/display/api.js');\n  const { buildGetDocumentParams } = await import('./test_utils.js');\n  const loadingTask = getDocument(buildGetDocumentParams('bug1851498.pdf'));\n  const pdfDocument = await loadingTask.promise;\n  const page = await pdfDocument.getPage(1);\n  const annotations = await page.getAnnotations();\n  const freeTextAnnotations = annotations.filter(\n    annotation => annotation.subtype === 'FreeText'\n  );\n  expect(freeTextAnnotations.length).toBeGreaterThan(0);\n  expect(freeTextAnnotations[0].contents).toBeTruthy();\n});",
    "i5_llama-3.3-70b-versatile": "it(\"should display FreeText annotation\", async () => {\n  const { getDocument } = await import('../../src/display/api.js');\n  const { buildGetDocumentParams } = await import('./test_utils.js');\n  const loadingTask = getDocument(buildGetDocumentParams('bug1851498.pdf'));\n  const pdfDocument = await loadingTask.promise;\n  const pdfPage = await pdfDocument.getPage(1);\n  const annotationLayer = await import('../../src/display/annotation_layer.js');\n  const annotationLayerBuilder = new annotationLayer.AnnotationLayer({\n    page: pdfPage,\n    viewport: pdfPage.getViewport({ scale: 1 }),\n    renderInteractiveForms: false,\n  });\n  const annotations = await pdfPage.getAnnotations();\n  const freeTextAnnotation = annotations.find(annotation => annotation.subtype === 'FreeText');\n  const hasPopupData = freeTextAnnotation.hasPopup;\n  const annotationElement = new annotationLayer.AnnotationElement({\n    annotation: freeTextAnnotation,\n    page: pdfPage,\n    viewport: pdfPage.getViewport({ scale: 1 }),\n  });\n  const hasPopup = annotationElement.hasPopupData;\n  expect(hasPopup).toBe(true);\n});"
  },
  "16943": {
    "i1_deepseek-r1-distill-llama-70b": "it(\"should adjust editor position based on border line width\", async () => {\n  const { AnnotationEditor } = await import(\"../../src/display/editor/editor.js\");\n  const { FreeTextEditor } = await import(\"../../src/display/editor/freetext.js\");\n\n  // Initialize the editor with a specific border line width\n  AnnotationEditor._borderLineWidth = 2;\n\n  // Create a new editor instance with specific dimensions and position\n  const editor = new FreeTextEditor({\n    parent: {\n      viewport: {\n        rawDims: {\n          pageWidth: 100,\n          pageHeight: 100,\n        }\n      }\n    },\n    x: 10,\n    y: 20,\n    uiManager: new CommandManager(),\n  });\n\n  // Set up the expected position after adjustment\n  const expectedLeft = 10 + (2 / 100);\n  const expectedTop = 20 + (2 / 100);\n\n  // Apply the position fix\n  editor.fixAndSetPosition();\n\n  // Verify the position is correctly adjusted\n  assert.strictEqual(editor.div.style.left, `${(expectedLeft * 100).toFixed(2)}%`);\n  assert.strictEqual(editor.div.style.top, `${(expectedTop * 100).toFixed(2)}%`);\n});",
    "i1_gpt-4o": "it(\"should apply correct border line width and position adjustment for selected editor\", async () => {\n  const { AnnotationEditor } = await import(\"../../src/display/editor/editor.js\");\n  const { FreeTextEditor } = await import(\"../../src/display/editor/freetext.js\");\n  const { InkEditor } = await import(\"../../src/display/editor/ink.js\");\n\n  // Mock getComputedStyle to return a specific outline width\n  global.getComputedStyle = () => ({\n    getPropertyValue: () => \"2px\",\n  });\n\n  // Initialize editors\n  AnnotationEditor.initialize({});\n  FreeTextEditor.initialize({});\n  InkEditor.initialize({});\n\n  // Create a mock parent with necessary properties\n  const mockParent = {\n    pageIndex: 0,\n    viewport: {\n      rotation: 0,\n      rawDims: { pageWidth: 100, pageHeight: 100, pageX: 0, pageY: 0 },\n    },\n  };\n\n  // Create instances of editors\n  const freeTextEditor = new FreeTextEditor({\n    parent: mockParent,\n    id: \"freeTextEditor1\",\n    x: 10,\n    y: 10,\n    uiManager: {},\n  });\n\n  const inkEditor = new InkEditor({\n    parent: mockParent,\n    id: \"inkEditor1\",\n    x: 10,\n    y: 10,\n    uiManager: {},\n  });\n\n  // Expected border line width\n  const expectedBorderLineWidth = 2;\n\n  // Check if the border line width is set correctly\n  expect(AnnotationEditor._borderLineWidth).toBe(expectedBorderLineWidth);\n\n  // Check if the position is adjusted correctly\n  const [bx, by] = freeTextEditor.#getBaseTranslation();\n  expect(bx).toBeCloseTo(-expectedBorderLineWidth / 100);\n  expect(by).toBeCloseTo(-expectedBorderLineWidth / 100);\n\n  const [bxInk, byInk] = inkEditor.#getBaseTranslation();\n  expect(bxInk).toBeCloseTo(-expectedBorderLineWidth / 100);\n  expect(byInk).toBeCloseTo(-expectedBorderLineWidth / 100);\n});",
    "i1_llama-3.3-70b-versatile": "it(\"should change the style of the line and the resizers around a selected editor\", async () => {\n  const { AnnotationEditor } = await import(\"../../src/display/editor/editor.js\");\n  const { ColorManager } = await import(\"../../src/display/editor/tools.js\");\n  const editor = new AnnotationEditor({ parent: { viewport: { rotation: 0 } }, id: 1, uiManager: { viewParameters: { rotation: 0 } } });\n  const initialStyle = getComputedStyle(editor.div);\n  const initialBorderWidth = parseFloat(initialStyle.getPropertyValue(\"border-width\"));\n  await AnnotationEditor.initialize({ get: () => \"\" });\n  const updatedStyle = getComputedStyle(editor.div);\n  const updatedBorderWidth = parseFloat(updatedStyle.getPropertyValue(\"border-width\"));\n  expect(updatedBorderWidth).not.toEqual(initialBorderWidth);\n});",
    "i2_deepseek-r1-distill-llama-70b": "describe(\"Editor Resizer Style\", () => {\n  it(\"should adjust editor position accounting for border width\", async () => {\n    const { AnnotationEditor } = await import(\"../../src/display/editor/editor.js\");\n    const { FreeTextEditor } = await import(\"../../src/display/editor/freetext.js\");\n\n    // Set up test page with CSS variable\n    const html = `\n      <html>\n        <head>\n          <style>\n            :root {\n              --outline-width: 2px;\n            }\n          </style>\n        </head>\n        <body></body>\n      </html>\n    `;\n    const page = await browser.newPage({ content: html });\n\n    // Initialize editor\n    const editor = new FreeTextEditor({\n      parent: { viewport: { rotation: 0, width: 100, height: 100 } },\n      uiManager: {},\n      id: \"test-editor\"\n    });\n\n    // Mock getBoundingClientRect to simulate movement\n    editor.div.getBoundingClientRect = () => ({ x: 10, y: 20 });\n\n    // Trigger position update\n    editor.drag(5, 5);\n    editor.fixAndSetPosition();\n\n    // Verify position includes border width adjustment\n    const expectedLeft = (10 + 2) / 100; // Border width is 2px\n    const expectedTop = (20 + 2) / 100;\n\n    assert.strictEqual(editor.div.style.left, `${expectedLeft.toFixed(2)}%`);\n    assert.strictEqual(editor.div.style.top, `${expectedTop.toFixed(2)}%`);\n  });\n});",
    "i2_gpt-4o": "it(\"should change the style of the bounding box and resizers around a selected editor\", async () => {\n  const { AnnotationEditor } = await import(\"../../src/display/editor/editor.js\");\n  const { FreeTextEditor } = await import(\"../../src/display/editor/freetext.js\");\n  const { InkEditor } = await import(\"../../src/display/editor/ink.js\");\n\n  // Initialize the editors\n  const l10n = { get: (str) => Promise.resolve(str) };\n  AnnotationEditor.initialize(l10n);\n  FreeTextEditor.initialize(l10n);\n  InkEditor.initialize(l10n);\n\n  // Create a mock parent with necessary properties\n  const mockParent = {\n    pageIndex: 0,\n    viewport: {\n      rotation: 0,\n      rawDims: { pageWidth: 100, pageHeight: 100, pageX: 0, pageY: 0 },\n    },\n  };\n\n  // Create instances of editors\n  const freeTextEditor = new FreeTextEditor({ parent: mockParent, id: \"1\", x: 10, y: 10 });\n  const inkEditor = new InkEditor({ parent: mockParent, id: \"2\", x: 20, y: 20 });\n\n  // Mock the div element and its style\n  freeTextEditor.div = { style: { left: \"\", top: \"\" }, scrollIntoView: () => {} };\n  inkEditor.div = { style: { left: \"\", top: \"\" }, scrollIntoView: () => {} };\n\n  // Set positions\n  freeTextEditor.fixAndSetPosition();\n  inkEditor.fixAndSetPosition();\n\n  // Expected positions after applying the patch\n  const expectedFreeTextLeft = `${(100 * (10 - AnnotationEditor._borderLineWidth / 100)).toFixed(2)}%`;\n  const expectedFreeTextTop = `${(100 * (10 - AnnotationEditor._borderLineWidth / 100)).toFixed(2)}%`;\n  const expectedInkLeft = `${(100 * (20 - AnnotationEditor._borderLineWidth / 100)).toFixed(2)}%`;\n  const expectedInkTop = `${(100 * (20 - AnnotationEditor._borderLineWidth / 100)).toFixed(2)}%`;\n\n  // Compare expected with actual\n  expect(freeTextEditor.div.style.left).toBe(expectedFreeTextLeft);\n  expect(freeTextEditor.div.style.top).toBe(expectedFreeTextTop);\n  expect(inkEditor.div.style.left).toBe(expectedInkLeft);\n  expect(inkEditor.div.style.top).toBe(expectedInkTop);\n});",
    "i2_llama-3.3-70b-versatile": "it(\"should change the style of the line and the resizers around a selected editor\", async () => {\n  const { AnnotationEditor } = await import(\"../../src/display/editor/editor.js\");\n  const { AnnotationEditorUIManager } = await import(\"../../src/display/editor/tools.js\");\n  const { getComputedStyle } = await import(\"../../src/shared/util.js\");\n\n  const uiManager = new AnnotationEditorUIManager();\n  const editor = new (class extends AnnotationEditor {\n    constructor() {\n      super({ parent: {}, id: \"test\", uiManager });\n    }\n  })();\n  editor.div = document.createElement(\"div\");\n  document.body.appendChild(editor.div);\n\n  const style = getComputedStyle(document.documentElement);\n  const outlineWidth = parseFloat(style.getPropertyValue(\"--outline-width\")) || 0;\n\n  editor.initialize();\n  editor.drag(0, 0);\n\n  const resizersDiv = editor.div.querySelector(\".resizers\");\n  const borderWidth = parseFloat(getComputedStyle(resizersDiv).borderWidth);\n\n  expect(borderWidth).toBe(outlineWidth);\n});",
    "i3_deepseek-r1-distill-llama-70b": "it(\"should adjust editor positioning and resizers with correct border width\", async () => {\n  const { AnnotationEditor } = await import(\"../../src/display/editor/editor.js\");\n  const { FreeTextEditor } = await import(\"../../src/display/editor/freetext.js\");\n  const { InkEditor } = await import(\"../../src/display/editor/ink.js\");\n\n  // Setup mock DOM elements\n  const parent = {\n    getNextId: () => \"1\",\n    pageIndex: 0,\n    viewport: {\n      rotation: 0,\n      parentDimensions: [100, 100],\n    },\n  };\n\n  // Initialize editor with default parameters\n  const editorParams = {\n    parent,\n    id: \"test-editor\",\n    uiManager: {},\n    x: 10,\n    y: 20,\n    color: \"#000\",\n    fontSize: 12,\n  };\n\n  // Create editors for testing\n  const textEditor = new FreeTextEditor(editorParams);\n  const inkEditor = new InkEditor(editorParams);\n\n  // Mock getComputedStyle to return specific values\n  global.getComputedStyle = () => ({\n    getPropertyValue: () => \"2px\",\n  });\n\n  // Initialize the editors\n  AnnotationEditor.initialize({});\n  FreeTextEditor.initialize({});\n  InkEditor.initialize({});\n\n  // Render the editors\n  textEditor.render();\n  inkEditor.render();\n\n  // Check computed styles and positioning\n  expect(global.getComputedStyle(textEditor.div).borderWidth).toBe(\"2px\");\n  expect(global.getComputedStyle(inkEditor.div).borderWidth).toBe(\"2px\");\n});",
    "i3_gpt-4o": "it(\"should change the style of the line and the resizers around a selected editor\", async () => {\n  const { AnnotationEditor } = await import(\"../../src/display/editor/editor.js\");\n  const { FreeTextEditor } = await import(\"../../src/display/editor/freetext.js\");\n  const { InkEditor } = await import(\"../../src/display/editor/ink.js\");\n\n  // Mocking necessary elements\n  document.documentElement.style.setProperty(\"--outline-width\", \"2px\");\n  const l10n = { get: (str) => Promise.resolve(str) };\n  AnnotationEditor.initialize(l10n);\n  FreeTextEditor.initialize(l10n);\n  InkEditor.initialize(l10n);\n\n  // Create a FreeTextEditor instance\n  const freeTextEditor = new FreeTextEditor({\n    parent: { pageIndex: 0, viewport: { rotation: 0, rawDims: { pageWidth: 100, pageHeight: 100, pageX: 0, pageY: 0 } } },\n    id: \"freeTextEditor1\",\n    uiManager: { viewParameters: { rotation: 0 } },\n    x: 10,\n    y: 10,\n  });\n\n  // Create an InkEditor instance\n  const inkEditor = new InkEditor({\n    parent: { pageIndex: 0, viewport: { rotation: 0, rawDims: { pageWidth: 100, pageHeight: 100, pageX: 0, pageY: 0 } } },\n    id: \"inkEditor1\",\n    uiManager: { viewParameters: { rotation: 0 } },\n    x: 10,\n    y: 10,\n  });\n\n  // Render editors\n  const freeTextDiv = freeTextEditor.render();\n  const inkDiv = inkEditor.render();\n\n  // Simulate selection\n  freeTextEditor.select();\n  inkEditor.select();\n\n  // Expected styles\n  const expectedBorderWidth = \"2px\";\n\n  // Actual styles\n  const actualFreeTextBorderWidth = getComputedStyle(freeTextDiv).borderWidth;\n  const actualInkBorderWidth = getComputedStyle(inkDiv).borderWidth;\n\n  // Assertions\n  expect(actualFreeTextBorderWidth).toBe(expectedBorderWidth);\n  expect(actualInkBorderWidth).toBe(expectedBorderWidth);\n});",
    "i3_llama-3.3-70b-versatile": "it(\"should change the style of the line and the resizers around a selected editor\", async () => {\n  const { AnnotationEditor } = await import(\"../../src/display/editor/editor.js\");\n  const editor = new AnnotationEditor({\n    parent: { div: document.createElement(\"div\") },\n    uiManager: { currentLayer: { div: document.createElement(\"div\") } },\n    id: \"editor\",\n    name: \"editor\",\n  });\n  editor.select();\n  const resizersDiv = editor.div.querySelector(\".resizers\");\n  expect(resizersDiv).not.toBeNull();\n  expect(editor.div.classList.contains(\"selectedEditor\")).toBe(true);\n});",
    "i4_deepseek-r1-distill-llama-70b": "it(\"should change the style of the line and resizers around a selected editor\", async () => {\n  const { AnnotationEditor, ColorManager } = await import(\"../../src/display/editor/editor.js\");\n  const editor = new AnnotationEditor({\n    parent: {},\n    uiManager: {},\n    id: \"test-editor\",\n    x: 0,\n    y: 0,\n    name: \"test-editor\"\n  });\n\n  // Initialize with l10n\n  await editor.initialize({});\n\n  expect(AnnotationEditor._borderLineWidth).toBe(2);\n});",
    "i4_gpt-4o": "it(\"should change the style of the line and the resizers around a selected editor\", async () => {\n  const { AnnotationEditor } = await import(\"../../src/display/editor/editor.js\");\n  const { FreeTextEditor } = await import(\"../../src/display/editor/freetext.js\");\n  const { InkEditor } = await import(\"../../src/display/editor/ink.js\");\n\n  const mockParent = {\n    pageIndex: 0,\n    viewport: {\n      rotation: 0,\n      rawDims: { pageWidth: 100, pageHeight: 100, pageX: 0, pageY: 0 },\n    },\n    div: document.createElement(\"div\"),\n    add: jest.fn(),\n    remove: jest.fn(),\n    setSelected: jest.fn(),\n    toggleSelected: jest.fn(),\n    setActiveEditor: jest.fn(),\n    updateToolbar: jest.fn(),\n    setEditingState: jest.fn(),\n    isMultipleSelection: false,\n  };\n\n  const mockUIManager = {\n    viewParameters: { rotation: 0, realScale: 1 },\n    addToAnnotationStorage: jest.fn(),\n    addCommands: jest.fn(),\n    isSelected: jest.fn().mockReturnValue(true),\n    setUpDragSession: jest.fn(),\n    endDragSession: jest.fn().mockReturnValue(false),\n    dragSelectedEditors: jest.fn(),\n    currentLayer: { div: document.createElement(\"div\") },\n  };\n\n  const editorParams = {\n    parent: mockParent,\n    uiManager: mockUIManager,\n    id: \"test-editor\",\n    x: 10,\n    y: 10,\n  };\n\n  const freeTextEditor = new FreeTextEditor(editorParams);\n  const inkEditor = new InkEditor(editorParams);\n\n  document.body.appendChild(mockParent.div);\n  mockParent.div.appendChild(freeTextEditor.render());\n  mockParent.div.appendChild(inkEditor.render());\n\n  freeTextEditor.select();\n  inkEditor.select();\n\n  const freeTextEditorStyle = getComputedStyle(freeTextEditor.div);\n  const inkEditorStyle = getComputedStyle(inkEditor.div);\n\n  expect(freeTextEditorStyle.border).toContain(\"solid\");\n  expect(inkEditorStyle.border).toContain(\"solid\");\n\n  freeTextEditor.unselect();\n  inkEditor.unselect();\n\n  const freeTextEditorResizers = freeTextEditor.div.querySelector(\".resizers\");\n  const inkEditorResizers = inkEditor.div.querySelector(\".resizers\");\n\n  expect(freeTextEditorResizers.classList.contains(\"hidden\")).toBe(true);\n  expect(inkEditorResizers.classList.contains(\"hidden\")).toBe(true);\n});",
    "i4_llama-3.3-70b-versatile": "it(\"should change the style of the line and the resizers around a selected editor\", async () => {\n  const { AnnotationEditor } = await import(\"./editor.js\");\n  const { FreeTextEditor } = await import(\"./freetext.js\");\n  const { InkEditor } = await import(\"./ink.js\");\n\n  const editor = new AnnotationEditor({ id: 1, parent: null, uiManager: null });\n  const freeTextEditor = new FreeTextEditor({ id: 2, parent: null, uiManager: null });\n  const inkEditor = new InkEditor({ id: 3, parent: null, uiManager: null });\n\n  editor.select();\n  freeTextEditor.select();\n  inkEditor.select();\n\n  const expectedStyle = \"selectedEditor\";\n  const actualStyleEditor = editor.div?.classList.contains(expectedStyle);\n  const actualStyleFreeTextEditor = freeTextEditor.div?.classList.contains(expectedStyle);\n  const actualStyleInkEditor = inkEditor.div?.classList.contains(expectedStyle);\n\n  expect(actualStyleEditor).toBe(true);\n  expect(actualStyleFreeTextEditor).toBe(true);\n  expect(actualStyleInkEditor).toBe(true);\n});",
    "i5_deepseek-r1-distill-llama-70b": "it(\"should adjust editor position based on border line width\", async () => {\n  const { AnnotationEditor } = await import(\"../../src/display/editor/editor.js\");\n  const { PDFDocument } = await import(\"../../src/core/document.js\");\n\n  // Create a test PDF document\n  const pdf = new PDFDocument();\n  const page = pdf.addPage();\n\n  // Initialize the editor with a mock l10n\n  await AnnotationEditor.initialize({});\n\n  // Set the border line width for testing\n  AnnotationEditor._borderLineWidth = 2;\n\n  // Create an editor instance\n  const editor = new AnnotationEditor(page);\n\n  // Set parent dimensions and initial position\n  editor.parentDimensions = [100, 100];\n  editor.x = 0.5;\n  editor.y = 0.5;\n  editor.rotation = 0;\n\n  // Call the method to fix and set the position\n  editor.fixAndSetPosition();\n\n  // Verify the expected position adjustment\n  const expectedLeft = \"48.00%\";\n  const expectedTop = \"48.00%\";\n\n  expect(editor.div.style.left).toBe(expectedLeft);\n  expect(editor.div.style.top).toBe(expectedTop);\n});",
    "i5_gpt-4o": "it(\"should change the style of the line and the resizers around a selected editor\", async () => {\n  const { AnnotationEditor } = await import(\"../../src/display/editor/editor.js\");\n  const { FreeTextEditor } = await import(\"../../src/display/editor/freetext.js\");\n  const { InkEditor } = await import(\"../../src/display/editor/ink.js\");\n\n  // Initialize the editors\n  AnnotationEditor.initialize({});\n  FreeTextEditor.initialize({});\n  InkEditor.initialize({});\n\n  // Mock document style\n  document.documentElement.style.setProperty(\"--outline-width\", \"2px\");\n\n  // Create an instance of AnnotationEditor\n  const editor = new AnnotationEditor();\n  editor.x = 0.1;\n  editor.y = 0.1;\n  editor.rotation = 0;\n  editor.parentDimensions = [1000, 1000];\n  editor.pageDimensions = [1000, 1000];\n  editor.div = document.createElement(\"div\");\n\n  // Expected position after applying the patch\n  const expectedLeft = \"9.80%\";\n  const expectedTop = \"9.80%\";\n\n  // Generate actual position\n  editor.fixAndSetPosition();\n  const actualLeft = editor.div.style.left;\n  const actualTop = editor.div.style.top;\n\n  // Compare expected with actual\n  expect(actualLeft).toBe(expectedLeft);\n  expect(actualTop).toBe(expectedTop);\n});",
    "i5_llama-3.3-70b-versatile": "it(\"should change the style of the line and the resizers around a selected editor\", async () => {\n  const { AnnotationEditor } = await import(\"../../src/display/editor/editor.js\");\n  const { AnnotationEditorLayer } = await import(\"../../src/display/editor/annotation_editor_layer.js\");\n  const { PDFPageView } = await import(\"../../web/pdf_page_view.js\");\n\n  const pageView = new PDFPageView();\n  const annotationEditorLayer = new AnnotationEditorLayer(pageView);\n  const annotationEditor = new AnnotationEditor(annotationEditorLayer);\n\n  const initialBorderWidth = await annotationEditor._borderLineWidth;\n  annotationEditor.initialize({ get: () => {} });\n  const updatedBorderWidth = await annotationEditor._borderLineWidth;\n\n  expect(updatedBorderWidth).not.toBe(initialBorderWidth);\n});"
  },
  "17003": {
    "i1_deepseek-r1-distill-llama-70b": "it(\"should not warn about unknown field names when printing with annotations\", async () => {\n  const idFactory = createIdFactory();\n  const xref = new XRefMock();\n  const pdfManager = {\n    evaluatorOptions: {},\n    getAcroForm: () => ({\n      get: () => false\n    }),\n    ensure: (constructor, method, args) => constructor[method](...args)\n  };\n  const annotationGlobals = {\n    pdfManager,\n    acroForm: {\n      get: () => null\n    },\n    structTreeRoot: null\n  };\n\n  const dict = new Dict();\n  dict.set(\"Subtype\", new Name(\"Highlight\"));\n  dict.set(\"T\", new Name(\"title\"));\n  dict.set(\"Contents\", new Name(\"content\"));\n\n  const consoleWarnSpy = jest.spyOn(console, 'warn').mockImplementation(() => {});\n\n  const annotation = await AnnotationFactory.create(xref, new Ref(1), annotationGlobals, idFactory, true);\n\n  expect(consoleWarnSpy).not.toHaveBeenCalled();\n});",
    "i1_gpt-4o": "it(\"should not warn about unknown field name when printing a PDF with annotations\", async () => {\n  const { AnnotationFactory } = await import(\"../../src/core/annotation.js\");\n  const { warn } = await import(\"../../src/shared/util.js\");\n  const xrefMock = new XRefMock();\n  const annotationGlobals = { acroForm: new Dict(), pdfManager: { evaluatorOptions: {} } };\n  const idFactory = createIdFactory(0);\n  const ref = new Ref(1, 0);\n  const pageRef = new Ref(2, 0);\n\n  let warningMessage = null;\n  const originalWarn = warn;\n  warn = (msg) => { warningMessage = msg; };\n\n  await AnnotationFactory.create(xrefMock, ref, annotationGlobals, idFactory, true, pageRef);\n\n  warn = originalWarn;\n  expect(warningMessage).toBeNull();\n});",
    "i1_llama-3.3-70b-versatile": "it(\"should not warn when printing a pdf with an added annotation\", async () => {\n  const { AnnotationFactory, Annotation, Dict, Ref, Name } = await import(\"../../src/core/annotation.js\");\n  const { createIdFactory, XRefMock } = await import(\"./test_utils.js\");\n  const idFactory = createIdFactory();\n  const xref = new XRefMock();\n  const annotationGlobals = { pdfManager: { evaluatorOptions: {} } };\n  const ref = new Ref(1, 0);\n  const dict = new Dict({ Subtype: new Name(\"Widget\") });\n  xref.fetchIfRef = () => dict;\n  const consoleWarnSpy = jest.spyOn(console, 'warn');\n  await AnnotationFactory.create(xref, ref, annotationGlobals, idFactory, true);\n  expect(consoleWarnSpy).not.toHaveBeenCalledWith(\"Unknown field name, falling back to empty field name.\");\n});",
    "i2_deepseek-r1-distill-llama-70b": "it(\"should not warn about unknown field names when printing annotations\", async () => {\n  const { PDFDocument } = await import(\"../../src/core/document.js\");\n  const { AnnotationFactory } = await import(\"../../src/core/annotation.js\");\n\n  const pdf = new PDFDocument();\n  const page = pdf.addPage();\n\n  let warningThrown = false;\n\n  const originalWarn = console.warn;\n  console.warn = (message) => {\n    if (message.includes(\"Unknown field name\")) {\n      warningThrown = true;\n    }\n    originalWarn(message);\n  };\n\n  const annotation = new TextAnnotation({\n    xref: pdf.xref,\n    ref: pdf.ref,\n    dict: {\n      get: () => \"Test Annotation\"\n    },\n    annotationGlobals: {\n      pdfManager: pdf.pdfManager,\n      acroForm: pdf.acroForm\n    },\n    idFactory: pdf.idFactory,\n    collectFields: true,\n    pageRef: page.ref\n  });\n\n  await pdf.print();\n\n  expect(warningThrown).toBe(false);\n});",
    "i2_gpt-4o": "it(\"should not log warning when printing a PDF with an added annotation\", async () => {\n  const { AnnotationFactory } = await import(\"../../src/core/annotation.js\");\n  const { Ref, Dict } = await import(\"../../src/core/primitives.js\");\n  const { warn } = await import(\"../../src/shared/util.js\");\n\n  const xref = {};\n  const ref = new Ref(1, 0);\n  const annotationGlobals = {\n    acroForm: new Dict(),\n    pdfManager: {\n      ensure: (context, methodName, args) => context[methodName](...args),\n      evaluatorOptions: {},\n    },\n  };\n  const idFactory = { createObjId: () => \"1\" };\n  const pageRef = new Ref(2, 0);\n\n  let warningLogged = false;\n  const originalWarn = warn;\n  warn = (msg) => {\n    if (msg.includes(\"Unknown field name\")) {\n      warningLogged = true;\n    }\n  };\n\n  await AnnotationFactory.create(xref, ref, annotationGlobals, idFactory, true, pageRef);\n\n  warn = originalWarn;\n  expect(warningLogged).toBe(false);\n});",
    "i2_llama-3.3-70b-versatile": "it(\"should not throw a warning when printing a pdf with an added annotation\", async () => {\n  const { AnnotationFactory, warn } = await import(\"../../src/core/annotation.js\");\n  const { PDFDocument } = await import(\"../../src/core/document.js\");\n  const originalWarn = console.warn;\n  let warningMessage;\n  console.warn = (message) => {\n    warningMessage = message;\n  };\n\n  const pdfDoc = await PDFDocument.load(await (await import(\"../../src/shared/util.js\")).stringToBytes(\"test.pdf\"));\n  const annotationGlobals = {\n    pdfManager: pdfDoc.manager,\n    acroForm: pdfDoc.catalog.get(\"AcroForm\"),\n  };\n  const idFactory = await (await import(\"../../src/shared/util.js\")).createIdFactory();\n  const ref = await (await import(\"../../src/core/primitives.js\")).Ref.fromNum(1, 0);\n  await AnnotationFactory.create(pdfDoc.xref, ref, annotationGlobals, idFactory, true);\n\n  console.warn = originalWarn;\n  expect(warningMessage).not.toContain(\"Unknown field name, falling back to empty field name.\");\n});",
    "i3_deepseek-r1-distill-llama-70b": "it(\"should not warn when printing an annotation without a parent\", async () => {\n  const xref = new XRefMock();\n  const dict = new Dict(xref, {});\n  const warnSpy = jest.spyOn(console, 'warn').mockImplementation(() => {});\n\n  const annotation = await AnnotationFactory.create(xref, dict, {}, createIdFactory(), false);\n  expect(warnSpy).not.toHaveBeenCalledWith(\"Unknown field name, falling back to empty field name.\");\n});",
    "i3_gpt-4o": "it(\"should not warn about unknown field name when printing a PDF with annotations\", async () => {\n  const { AnnotationFactory } = await import(\"../../src/core/annotation.js\");\n  const { Dict, Ref } = await import(\"../../src/core/primitives.js\");\n  const { XRefMock } = await import(\"./test_utils.js\");\n  const { warn } = await import(\"../../src/shared/util.js\");\n\n  const xref = new XRefMock([]);\n  const annotationDict = new Dict(xref);\n  annotationDict.set(\"Subtype\", Name.get(\"Widget\"));\n  annotationDict.set(\"T\", \"TestField\");\n  annotationDict.set(\"V\", \"TestValue\");\n\n  const ref = new Ref(1, 0);\n  const annotationGlobals = {\n    acroForm: Dict.empty,\n    pdfManager: {\n      ensure: (context, methodName, args) => {\n        return context[methodName](...args);\n      },\n    },\n  };\n  const idFactory = createIdFactory(0);\n\n  let warningMessage = null;\n  const originalWarn = warn;\n  warn = (msg) => {\n    warningMessage = msg;\n  };\n\n  await AnnotationFactory.create(\n    xref,\n    ref,\n    annotationGlobals,\n    idFactory,\n    true,\n    null\n  );\n\n  warn = originalWarn;\n  expect(warningMessage).toBeNull();\n});",
    "i3_llama-3.3-70b-versatile": "it(\"should resolve the warning when printing a pdf with an added annotation\", async () => {\n  const pdfManager = {\n    ensureCatalog: async (key) => {\n      if (key === \"acroForm\") {\n        return new Dict();\n      }\n      return null;\n    },\n    ensureDoc: async (key) => {\n      if (key === \"xfaDatasets\") {\n        return new Dict();\n      }\n      return null;\n    },\n    evaluatorOptions: {\n      isOffscreenCanvasSupported: true,\n    },\n  };\n\n  const annotationGlobals = await AnnotationFactory.createGlobals(pdfManager);\n  const xref = new XRefMock();\n  const idFactory = createIdFactory();\n  const ref = new Ref(1, 0);\n  const dict = new Dict();\n  dict.set(\"Subtype\", Name.get(\"Widget\"));\n  dict.set(\"FT\", Name.get(\"Tx\"));\n  dict.set(\"T\", \"Test\");\n  dict.set(\"Rect\", [0, 0, 100, 100]);\n  dict.set(\"P\", new Ref(2, 0));\n  const pageIndex = await AnnotationFactory._getPageIndex(xref, ref, pdfManager);\n\n  const annotation = await AnnotationFactory.create(xref, ref, annotationGlobals, idFactory, true);\n  const consoleWarnSpy = jest.spyOn(console, \"warn\");\n\n  await AnnotationFactory.printNewAnnotations(annotationGlobals, { xref, options: {} }, new WorkerTask(), [annotation], {});\n\n  expect(consoleWarnSpy).not.toHaveBeenCalledWith(\"Unknown field name, falling back to empty field name.\");\n});",
    "i4_deepseek-r1-distill-llama-70b": "it(\"should not warn about unknown field names when creating annotations\", async () => {\n  const { AnnotationFactory } = await import(\"../../src/core/annotation.js\");\n  const { createIdFactory } = await import(\"../../test_utils.js\");\n\n  const idFactory = createIdFactory();\n  const dict = new (await import(\"../../src/core/primitives.js\")).Dict();\n\n  const mockWarn = jest.fn();\n  const originalWarn = global.warn;\n  global.warn = mockWarn;\n\n  try {\n    await AnnotationFactory.create(null, null, null, idFactory, true, null);\n  } finally {\n    global.warn = originalWarn;\n  }\n\n  expect(mockWarn).not.toHaveBeenCalledWith(\n    \"Unknown field name, falling back to empty field name.\"\n  );\n});",
    "i4_gpt-4o": "it(\"should not log a warning when printing a PDF with an added annotation\", async () => {\n  const { AnnotationFactory } = await import(\"../../src/core/annotation.js\");\n  const { warn } = await import(\"../../src/shared/util.js\");\n\n  let warningLogged = false;\n  const originalWarn = warn;\n  warn = (msg) => {\n    if (msg.includes(\"Unknown field name, falling back to empty field name.\")) {\n      warningLogged = true;\n    }\n  };\n\n  const xref = {}; // Mocked xref\n  const ref = {}; // Mocked ref\n  const annotationGlobals = { acroForm: { get: () => false }, pdfManager: { ensure: () => Promise.resolve() } };\n  const idFactory = { createObjId: () => \"1\" };\n  const pageRef = {}; // Mocked pageRef\n\n  await AnnotationFactory.create(xref, ref, annotationGlobals, idFactory, true, pageRef);\n\n  warn = originalWarn;\n  expect(warningLogged).toBe(false);\n});",
    "i4_llama-3.3-70b-versatile": "it(\"should resolve the warning when printing a pdf with an added annotation\", async () => {\n  const { AnnotationFactory } = await import(\"../../src/core/annotation.js\");\n  const { PDFDocument } = await import(\"../../src/core/document.js\");\n  const { createIdFactory } = await import(\"../../src/core/id_factory.js\");\n  const { PDFPage } = await import(\"../../src/core/page.js\");\n  const { createPdfManager } = await import(\"../../src/display/api.js\");\n  const { PDFFetchStream } = await import(\"../../src/display/fetch_stream.js\");\n  const { PDFNetworkStream } = await import(\"../../src/display/network.js\");\n  const { GlobalWorkerOptions } = await import(\"../../src/display/worker_options.js\");\n  const { MessageHandler } = await import(\"../../src/shared/message_handler.js\");\n  const { shadow } = await import(\"../../src/shared/util.js\");\n\n  const pdfManager = createPdfManager({\n    workerOptions: GlobalWorkerOptions,\n    messageHandler: new MessageHandler(),\n  });\n\n  const idFactory = createIdFactory();\n  const stream = new PDFNetworkStream(\"https://example.com/example.pdf\");\n  const pdf = await PDFDocument.load({ pdfManager, idFactory, stream });\n  const page = await pdf.getPage(0);\n  const annotations = await page.getAnnotations();\n\n  const annotation = await AnnotationFactory.create(\n    pdf.xref,\n    annotations[0].ref,\n    await AnnotationFactory.createGlobals(pdfManager),\n    idFactory,\n    true,\n    page.ref\n  );\n\n  const consoleWarnSpy = jest.spyOn(console, \"warn\");\n  await AnnotationFactory.printNewAnnotations(\n    await AnnotationFactory.createGlobals(pdfManager),\n    pdfManager.evaluator,\n    null,\n    [annotation],\n    {}\n  );\n  expect(consoleWarnSpy).not.toHaveBeenCalledWith(\"Unknown field name, falling back to empty field name.\");\n});",
    "i5_deepseek-r1-distill-llama-70b": "it(\"should not warn about unknown field names when printing with annotations\", async () => {\n  const { PDFDocument } = await import(\"../../src/core/document.js\");\n  const { Annotation } = await import(\"../../src/core/annotation.js\");\n\n  const pdf = new PDFDocument();\n  const page = pdf.addPage();\n  const annotation = new Annotation({\n    type: \"Text\",\n    rect: [0, 0, 100, 100],\n    contents: \"Test annotation\",\n  });\n  page.annotations.push(annotation);\n\n  const originalWarn = console.warn;\n  console.warn = jest.fn();\n\n  const annotationFactory = new (await import(\"../../src/core/annotation.js\")).AnnotationFactory({\n    pdf,\n    idFactory: await import(\"../../src/core/util.js\").Util.createIdFactory(),\n    collectFields: true,\n  });\n\n  await annotationFactory.processAnnotations();\n\n  expect(console.warn).not.toHaveBeenCalledWith(\"Warning: Unknown field name, falling back to empty field name.\");\n\n  console.warn = originalWarn;\n});",
    "i5_gpt-4o": "it(\"should not log a warning when printing a PDF with an added annotation\", async () => {\n  const { AnnotationFactory } = await import(\"../../src/core/annotation.js\");\n  const { PDFDocument } = await import(\"../../src/core/document.js\");\n  const { PDFPageProxy } = await import(\"../../src/display/api.js\");\n  const { createIdFactory } = await import(\"./test_utils.js\");\n  const { PDFNetworkStream } = await import(\"../../src/display/network.js\");\n\n  const pdfManager = {\n    evaluatorOptions: {},\n  };\n  const idFactory = createIdFactory();\n  const annotationGlobals = {};\n  const acroForm = new Map();\n  const ref = null;\n  const pageIndex = 0;\n  const pageRef = null;\n  const collectFields = true;\n\n  const annotationFactory = new AnnotationFactory();\n  const annotation = annotationFactory.create(\n    pdfManager,\n    ref,\n    annotationGlobals,\n    idFactory,\n    collectFields,\n    pageIndex,\n    pageRef\n  );\n\n  const pdfDocument = new PDFDocument();\n  const page = new PDFPageProxy(pdfDocument, pageIndex, pageRef, null, null);\n  const networkStream = new PDFNetworkStream();\n\n  const consoleWarnSpy = jest.spyOn(console, \"warn\").mockImplementation();\n\n  await page.print({ annotation, networkStream });\n\n  expect(consoleWarnSpy).not.toHaveBeenCalledWith(\n    \"Warning: Unknown field name, falling back to empty field name.\"\n  );\n\n  consoleWarnSpy.mockRestore();\n});",
    "i5_llama-3.3-70b-versatile": "it(\"should not throw a warning when printing a pdf with an added annotation\", async () => {\n  const { PDFDocument } = await import(\"../../src/core/document.js\");\n  const { AnnotationFactory } = await import(\"../../src/core/annotation.js\");\n  const { createIdFactory } = await import(\"./test_utils.js\");\n  const pdfDoc = await PDFDocument.load(await (await import(\"../../src/display/api.js\")).getDocument({ url: \"./test.pdf\" }));\n  const idFactory = createIdFactory();\n  const annotationFactory = new AnnotationFactory(pdfDoc, idFactory);\n  const annotation = annotationFactory.createAnnotation({ subtype: \"Highlight\" });\n  const page = pdfDoc.getPage(1);\n  page.addAnnotation(annotation);\n  const consoleWarnSpy = jest.spyOn(console, \"warn\");\n  await pdfDoc.print();\n  expect(consoleWarnSpy).not.toHaveBeenCalledWith(\"Warning: Unknown field name, falling back to empty field name.\");\n});"
  },
  "17031": {
    "i1_deepseek-r1-distill-llama-70b": "it(\"should delay moving editor in DOM when changing font size\", async () => {\n  const { AnnotationEditor } = await import(\"../../src/display/editor/editor.js\");\n  const { CommandManager } = await import(\"../../src/display/editor/tools.js\");\n\n  const mockParent = {\n    moveEditorInDOM: jest.fn(),\n  };\n\n  const editor = new AnnotationEditor({\n    parent: mockParent,\n    uiManager: new CommandManager(),\n    id: \"test-editor\",\n    name: \"FreeText\",\n    isCentered: false,\n  });\n\n  // Mock the font size slider change\n  const fontSizeSlider = {\n    value: 20,\n  };\n\n  // Simulate the font size change\n  editor.fontSize = fontSizeSlider.value;\n\n  // The moveInDOM method should now be called with a timeout\n  expect(mockParent.moveEditorInDOM).not.toHaveBeenCalled();\n\n  // Wait for the timeout to trigger\n  jest.useFakeTimers();\n  jest.runAllTimers();\n\n  expect(mockParent.moveEditorInDOM).toHaveBeenCalled();\n});",
    "i1_gpt-4o": "it(\"should delay DOM movement when changing font size with slider\", async () => {\n  const { AnnotationEditor } = await import(\"../../src/display/editor/editor.js\");\n  const mockParent = {\n    moveEditorInDOM: jasmine.createSpy(\"moveEditorInDOM\"),\n    pageIndex: 0,\n    viewport: {\n      rotation: 0,\n      rawDims: { pageWidth: 100, pageHeight: 100, pageX: 0, pageY: 0 },\n    },\n  };\n  const editor = new AnnotationEditor({\n    parent: mockParent,\n    id: \"test-editor\",\n    name: \"Test Editor\",\n    uiManager: {},\n    x: 0,\n    y: 0,\n    isCentered: false,\n  });\n\n  editor.moveInDOM();\n  expect(mockParent.moveEditorInDOM).not.toHaveBeenCalled();\n\n  await new Promise((resolve) => setTimeout(resolve, 10));\n  expect(mockParent.moveEditorInDOM).toHaveBeenCalledWith(editor);\n});",
    "i1_llama-3.3-70b-versatile": "it(\"should not block the UI when changing font size with the slider\", async () => {\n  const { AnnotationEditor } = await import(\"../../src/display/editor/editor.js\");\n  const { AnnotationEditorLayer } = await import(\"../../src/display/editor/annotation_editor_layer.js\");\n  const { AnnotationEditorUIManager } = await import(\"../../src/display/editor/tools.js\");\n  const editor = new AnnotationEditor({\n    parent: new AnnotationEditorLayer(),\n    id: \"test-editor\",\n    uiManager: new AnnotationEditorUIManager(),\n    x: 10,\n    y: 10,\n    isCentered: true,\n  });\n  const moveInDOMSpy = jest.spyOn(editor, \"moveInDOM\");\n  editor.moveInDOM();\n  expect(moveInDOMSpy).toHaveBeenCalledTimes(1);\n  await new Promise(resolve => setTimeout(resolve, 10));\n  expect(moveInDOMSpy).toHaveBeenCalledTimes(1);\n});",
    "i2_deepseek-r1-distill-llama-70b": "it(\"should not block UI when changing font size in editor\", async () => {\n  const { AnnotationEditor } = await import(\"../../display/editor/editor.js\");\n  const { XRefMock } = await import(\"./test_utils.js\");\n\n  // Create a mock parent element and editor\n  const parent = {\n    moveEditorInDOM: jest.fn(),\n    pageIndex: 0,\n    viewport: {\n      rotation: 0,\n      get pageWidth() { return 100; },\n      get pageHeight() { return 100; },\n      get pageX() { return 0; },\n      get pageY() { return 0; }\n    }\n  };\n\n  const editor = new AnnotationEditor({\n    parent,\n    id: \"test-editor\",\n    uiManager: {},\n    isCentered: false,\n    name: \"test\"\n  });\n\n  // Initialize editor\n  editor.div = document.createElement(\"div\");\n  document.body.appendChild(editor.div);\n\n  // Simulate font size change\n  const fontSizeSlider = document.createElement(\"input\");\n  fontSizeSlider.type = \"range\";\n  fontSizeSlider.min = 8;\n  fontSizeSlider.max = 72;\n  fontSizeSlider.value = 12;\n  document.body.appendChild(fontSizeSlider);\n\n  // Spy on moveInDOM\n  const moveInDOMSpy = jest.spyOn(editor, \"moveInDOM\");\n\n  // Test that moveInDOM is not called synchronously\n  fontSizeSlider.dispatchEvent(new Event(\"input\"));\n\n  // Wait for async moveInDOM call\n  await new Promise(resolve => setTimeout(resolve, 10));\n\n  expect(moveInDOMSpy).toHaveBeenCalled();\n});",
    "i2_gpt-4o": "it(\"should not block the UI when changing font size with the slider\", async () => {\n  const { AnnotationEditor } = await import(\"../../src/display/editor/editor.js\");\n  const { AnnotationEditorUIManager } = await import(\"../../src/display/editor/tools.js\");\n\n  const mockParent = {\n    pageIndex: 0,\n    viewport: {\n      rotation: 0,\n      rawDims: { pageWidth: 800, pageHeight: 600, pageX: 0, pageY: 0 },\n    },\n    moveEditorInDOM: jest.fn(),\n  };\n\n  const mockUIManager = new AnnotationEditorUIManager();\n  const editor = new AnnotationEditor({\n    parent: mockParent,\n    id: \"test-editor\",\n    name: \"Test Editor\",\n    uiManager: mockUIManager,\n    x: 100,\n    y: 100,\n    isCentered: false,\n  });\n\n  editor.moveInDOM();\n  expect(mockParent.moveEditorInDOM).not.toHaveBeenCalled();\n\n  await new Promise((resolve) => setTimeout(resolve, 10));\n  expect(mockParent.moveEditorInDOM).toHaveBeenCalledWith(editor);\n});",
    "i2_llama-3.3-70b-versatile": "it(\"should not block the UI when changing font size\", async () => {\n  const { AnnotationEditor } = await import(\"./editor.js\");\n  const { AnnotationEditorUIManager } = await import(\"../../src/display/editor/tools.js\");\n  const { PDFPageProxy } = await import(\"../../src/display/api.js\");\n\n  const uiManager = new AnnotationEditorUIManager();\n  const pageProxy = new PDFPageProxy(1, 100, 100);\n  const editor = new (class extends AnnotationEditor {\n    moveInDOM() {\n      this.parent?.moveEditorInDOM(this);\n    }\n  })({ parent: pageProxy, uiManager, id: 1, name: \"test\", x: 10, y: 10 });\n\n  let blocked = false;\n  const originalMoveInDOM = editor.moveInDOM;\n  editor.moveInDOM = () => {\n    blocked = true;\n    originalMoveInDOM.call(editor);\n  };\n\n  const startTime = Date.now();\n  editor.moveInDOM();\n  while (blocked && Date.now() - startTime < 100) {\n    await new Promise(resolve => globalThis.setTimeout(resolve, 10));\n  }\n\n  const { setTimeout } = await import(\"timers\");\n  const { moveInDOM } = await import(\"./editor.js\");\n\n  const patchedEditor = new (class extends AnnotationEditor {\n    moveInDOM() {\n      // Moving the editor in the DOM can be expensive, so we wait a bit before.\n      // It's important to not block the UI (for example when changing the font\n      // size in a FreeText).\n      if (this.#moveInDOMTimeout) {\n        clearTimeout(this.#moveInDOMTimeout);\n      }\n      this.#moveInDOMTimeout = setTimeout(() => {\n        this.#moveInDOMTimeout = null;\n        this.parent?.moveEditorInDOM(this);\n      }, 0);\n    }\n  })({ parent: pageProxy, uiManager, id: 1, name: \"test\", x: 10, y: 10 });\n\n  blocked = false;\n  const originalPatchedMoveInDOM = patchedEditor.moveInDOM;\n  patchedEditor.moveInDOM = () => {\n    blocked = true;\n    originalPatchedMoveInDOM.call(patchedEditor);\n  };\n\n  const patchedStartTime = Date.now();\n  patchedEditor.moveInDOM();\n  while (blocked && Date.now() - patchedStartTime < 100) {\n    await new Promise(resolve => globalThis.setTimeout(resolve, 10));\n  }\n\n  expect(blocked).toBe(false);\n});",
    "i3_deepseek-r1-distill-llama-70b": "it(\"should update font size with slider without blocking UI\", async () => {\n  const { AnnotationEditor, AnnotationEditorLayer } = await import(\"../../src/display/editor/editor.js\");\n  const { CommandManager } = await import(\"../../src/display/editor/tools.js\");\n\n  class MinimalEditor extends AnnotationEditor {\n    constructor(params) {\n      super(params);\n      this.fontSize = 16;\n    }\n\n    set fontSize(value) {\n      this._fontSize = value;\n      this.moveInDOM();\n    }\n\n    get fontSize() {\n      return this._fontSize;\n    }\n\n    isEmpty() {\n      return false;\n    }\n\n    render() {\n      const div = super.render();\n      div.style.fontSize = `${this.fontSize}px`;\n      return div;\n    }\n  }\n\n  const layer = new AnnotationEditorLayer({ page: {} });\n  const editor = new MinimalEditor({\n    parent: layer,\n    id: \"test-editor\",\n    uiManager: new CommandManager(),\n  });\n\n  editor.render();\n  editor.setDims(100, 100);\n  editor.fixAndSetPosition();\n\n  const fontSizeChanges = [16, 18, 20, 22, 24];\n  const moveInDOMSpy = jest.spyOn(editor, \"moveInDOM\");\n\n  for (const fontSize of fontSizeChanges) {\n    editor.fontSize = fontSize;\n    await new Promise(resolve => setTimeout(resolve, 0));\n    expect(moveInDOMSpy).toHaveBeenCalled();\n    moveInDOMSpy.mockClear();\n  }\n\n  const finalFontSize = 24;\n  expect(editor.fontSize).toBe(finalFontSize);\n});",
    "i3_gpt-4o": "it(\"should delay DOM movement when changing font size with slider\", async () => {\n  const { AnnotationEditor } = await import(\"../../src/display/editor/editor.js\");\n  const editor = new AnnotationEditor({\n    parent: { moveEditorInDOM: jest.fn(), pageIndex: 0 },\n    id: \"test-editor\",\n    uiManager: { viewParameters: { rotation: 0 } },\n    x: 0,\n    y: 0,\n  });\n\n  editor.moveInDOM();\n  expect(editor.parent.moveEditorInDOM).not.toHaveBeenCalled();\n\n  await new Promise(resolve => setTimeout(resolve, 0));\n  expect(editor.parent.moveEditorInDOM).toHaveBeenCalled();\n});",
    "i3_llama-3.3-70b-versatile": "it(\"should not block the UI when changing the font size in a text editor\", async () => {\n  const { AnnotationEditor } = await import(\"../../src/display/editor/editor.js\");\n  const { AnnotationEditorUIManager } = await import(\"../../src/display/editor/tools.js\");\n  const uiManager = new AnnotationEditorUIManager();\n  const editor = new AnnotationEditor({ uiManager, parent: null, id: \"test\" });\n  const moveInDOMSpy = jest.spyOn(editor, \"moveInDOM\");\n  editor.moveInDOM();\n  expect(moveInDOMSpy).toHaveBeenCalledTimes(1);\n  await new Promise(resolve => setTimeout(resolve, 0));\n  expect(moveInDOMSpy).toHaveBeenCalledTimes(1);\n});",
    "i4_deepseek-r1-distill-llama-70b": "it(\"should update font size without blocking UI\", async () => {\n  const { AnnotationEditor } = await import(\"../../src/display/editor/editor.js\");\n  const { createIdFactory } = await import(\"../../src/core/util.js\");\n  const { buildGetDocumentParams } = await import(\"../../src/core/document.js\");\n\n  const idFactory = createIdFactory();\n  const params = buildGetDocumentParams(idFactory);\n  const editor = new AnnotationEditor({\n    parent: {\n      pageIndex: 0,\n      moveEditorInDOM: () => {},\n      setSelected: () => {},\n      setParent: () => {},\n      viewport: {\n        rotation: 0,\n        pageWidth: 100,\n        pageHeight: 100,\n      },\n    },\n    uiManager: {},\n    id: \"test-editor\",\n    x: 10,\n    y: 20,\n  });\n\n  editor.width = 0.5;\n  editor.height = 0.5;\n  editor.fixAndSetPosition();\n\n  const mockMoveInDOM = jest.fn();\n  editor.moveInDOM = mockMoveInDOM;\n\n  // Simulate font size changes\n  editor.height = 0.6;\n  editor.width = 0.6;\n  editor.fixAndSetPosition();\n\n  // Check that moveInDOM is debounced and called only once\n  expect(mockMoveInDOM).toHaveBeenCalled();\n  const [x, y] = [editor.x, editor.y];\n  expect(x).toBeCloseTo(0.1);\n  expect(y).toBeCloseTo(0.2);\n});",
    "i4_gpt-4o": "it(\"should not block the UI when changing font size with the slider\", async () => {\n  const { AnnotationEditor } = await import(\"../../src/display/editor/editor.js\");\n  const { AnnotationEditorUIManager } = await import(\"../../src/display/editor/tools.js\");\n\n  const mockParent = {\n    pageIndex: 0,\n    viewport: {\n      rotation: 0,\n      rawDims: { pageWidth: 800, pageHeight: 600, pageX: 0, pageY: 0 },\n    },\n    moveEditorInDOM: jest.fn(),\n  };\n\n  const mockUIManager = new AnnotationEditorUIManager();\n  const editor = new AnnotationEditor({\n    uiManager: mockUIManager,\n    parent: mockParent,\n    id: \"test-editor\",\n    x: 100,\n    y: 100,\n  });\n\n  editor.moveInDOM();\n  expect(mockParent.moveEditorInDOM).not.toHaveBeenCalled();\n\n  await new Promise(resolve => setTimeout(resolve, 10));\n  expect(mockParent.moveEditorInDOM).toHaveBeenCalledWith(editor);\n});",
    "i4_llama-3.3-70b-versatile": "it(\"should allow changing font size with the slider without blocking the UI\", async () => {\n  const { AnnotationEditor } = await import(\"./editor.js\");\n  const { AnnotationEditorUIManager } = await import(\"./tools.js\");\n  const { AnnotationEditorLayer } = await import(\"./annotation_editor_layer.js\");\n\n  const uiManager = new AnnotationEditorUIManager();\n  const parent = new AnnotationEditorLayer({ uiManager, pageIndex: 0 });\n  const editor = new (class extends AnnotationEditor {\n    static _type = \"test\";\n    isEmpty() {\n      return false;\n    }\n    serialize() {\n      return {};\n    }\n  })({ parent, id: \"test\", uiManager });\n\n  editor.render();\n  editor.moveInDOM = jest.fn();\n  editor.moveInDOM();\n\n  expect(editor.moveInDOM).toHaveBeenCalledTimes(1);\n  expect(setTimeout).toHaveBeenCalledTimes(1);\n  expect(clearTimeout).not.toHaveBeenCalled();\n});",
    "i5_deepseek-r1-distill-llama-70b": "it(\"should not block UI when changing font size in text editor\", async () => {\n  const { PDFDocument } = await import(\"../../src/core/document.js\");\n  const { Page } = await import(\"../../src/core/document.js\");\n  const { AnnotationEditor } = await import(\"../../src/display/editor/editor.js\");\n\n  // Create a mock PDF document and page\n  const pdf = new PDFDocument(null, new PDFPage());\n  const page = pdf.getPage(1);\n\n  // Create an annotation editor instance\n  const editor = new AnnotationEditor();\n  editor.setMode(AnnotationEditor.EDIT_MODE.FREETEXT);\n  editor.setPDFPage(page);\n  editor.initialize();\n\n  // Simulate font size change via slider\n  const inputEvent = {\n    target: {\n      value: \"24px\", // Simulate changing font size\n      getBoundingClientRect: () => ({ top: 0, left: 0 })\n    }\n  };\n\n  // Create a promise to track when moveInDOM is called\n  const moveInDOMSpy = jest.fn();\n  const moveInDOMPromise = new Promise(resolve => {\n    const originalMoveInDOM = editor.moveInDOM.bind(editor);\n    editor.moveInDOM = (...args) => {\n      moveInDOMSpy(...args);\n      resolve();\n    };\n  });\n\n  // Dispatch the input event to simulate font size change\n  editor._onFontSizeChanged(inputEvent);\n\n  // Wait for the moveInDOM to be called with debouncing\n  await expect(moveInDOMPromise).resolves.toBeDefined();\n\n  // Cleanup\n  editor.destroy();\n});",
    "i5_gpt-4o": "it(\"should change font size smoothly with the slider\", async () => {\n  const { AnnotationEditor } = await import(\"../../src/display/editor/editor.js\");\n  const editor = new AnnotationEditor();\n\n  let fontSizeChanged = false;\n  editor.parent = {\n    moveEditorInDOM: () => {\n      fontSizeChanged = true;\n    }\n  };\n\n  editor.moveInDOM();\n  setTimeout(() => {\n    expect(fontSizeChanged).toBe(true);\n  }, 10);\n});",
    "i5_llama-3.3-70b-versatile": "it(\"should change font size smoothly with the slider in a text editor\", async () => {\n  const { PDFDocument, PDFPageProxy } = await import(\"../../src/display/api.js\");\n  const { AnnotationEditor } = await import(\"../../src/display/editor/editor.js\");\n  const { PDFPageView } = await import(\"../../src/web/pdf_page_view.js\");\n\n  const pdfDoc = await PDFDocument.load(await (await import(\"../../src/display/fetch_stream.js\")).PDFFetchStream.fetch(\"path_to_pdf_file\"));\n  const pdfPage = pdfDoc.getPage(1);\n  const pageView = new PDFPageView({ page: pdfPage });\n  const annotationEditor = new AnnotationEditor({ pageView });\n\n  const fontSizeBefore = annotationEditor.fontSize;\n  annotationEditor.moveInDOM();\n  const fontSizeAfter = annotationEditor.fontSize;\n\n  annotationEditor.fontSize = 20;\n  annotationEditor.moveInDOM();\n  const newFontSize = annotationEditor.fontSize;\n\n  expect(newFontSize).toBe(20);\n});"
  },
  "17066": {
    "i1_deepseek-r1-distill-llama-70b": "it(\"should render readonly text form field when AnnotationMode is ENABLED\", async () => {\n  const { getDocument } = await import('../../src/display/api.js');\n  const { buildGetDocumentParams } = await import('./test_utils.js');\n  const loadingTask = getDocument(buildGetDocumentParams('issue17064_readonly.pdf'));\n\n  const pdf = await loadingTask;\n  const annotationMode = AnnotationMode.ENABLED;\n  const pdfDoc = await pdf.getDocument({ annotationMode });\n  const page = await pdfDoc.getPage(1);\n  const viewport = page.getViewport({ scale: 1 });\n  const textLayer = page.createTextLayer({ viewport, onRender: () => {} });\n\n  const textWidgetElements = document.getElementsByClassName('textWidgetAnnotation');\n  const textWidgetElement = textWidgetElements[0];\n\n  expect(textWidgetElement).toBeTruthy();\n  expect(textWidgetElement.textContent).toBe('Foo');\n});",
    "i1_gpt-4o": "it(\"should render readonly form field when AnnotationMode ENABLED\", async () => {\n  const { getDocument } = await import(\"../../src/display/api.js\");\n  const { buildGetDocumentParams } = await import(\"./test_utils.js\");\n  const loadingTask = getDocument(buildGetDocumentParams(\"issue17064_readonly.pdf\"));\n  const pdfDocument = await loadingTask.promise;\n  const page = await pdfDocument.getPage(1);\n  const annotations = await page.getAnnotations({ intent: \"display\" });\n  const readOnlyField = annotations.find(\n    annotation => annotation.fieldName === \"readonlyField\"\n  );\n  expect(readOnlyField).toBeDefined();\n  expect(readOnlyField.fieldValue).toBe(\"Foo\");\n});",
    "i1_llama-3.3-70b-versatile": "it(\"should render readonly form fields when AnnotationMode is ENABLED\", async () => {\n  const { getDocument } = await import('../../src/display/api.js');\n  const { buildGetDocumentParams } = await import('./test_utils.js');\n  const loadingTask = getDocument(buildGetDocumentParams('issue17064_readonly.pdf', { annotationMode: 1 }));\n  const pdfDocument = await loadingTask.promise;\n  const pdfPage = await pdfDocument.getPage(1);\n  const pageViewport = pdfPage.getViewport({ scale: 1 });\n  const renderTask = pdfPage.render({\n    viewport: pageViewport,\n    annotationMode: 1,\n  });\n  const renderResult = await renderTask.promise;\n  const textWidgetAnnotations = renderResult.annotations.filter(annotation => annotation.subtype === 'Widget');\n  const readOnlyTextWidgetAnnotations = textWidgetAnnotations.filter(annotation => annotation.flags & 0x0001);\n  const isRenderable = readOnlyTextWidgetAnnotations.length > 0;\n  expect(isRenderable).toBe(true);\n});",
    "i2_deepseek-r1-distill-llama-70b": "it(\"should render readonly text widget annotations when forms are disabled\", async () => {\n  const { getDocument } = await import(\"../../src/display/api.js\");\n  const { buildGetDocumentParams } = await import(\"./test_utils.js\");\n  const loadingTask = getDocument(buildGetDocumentParams('issue17064_readonly.pdf'));\n\n  const pdfDoc = new (class {\n    get annotationMode() {\n      return 1; // AnnotationMode.ENABLED\n    }\n  });\n\n  const page = await loadingTask.promise.then(function({ numPages, getPage }) {\n    return getPage(1);\n  });\n\n  const textLayer = await page.getTextContent();\n  const textWidgetElements = textLayer.items.filter(item => item.str === \"Foo\");\n\n  expect(textWidgetElements.length).toBe(1);\n});",
    "i2_gpt-4o": "it(\"should render readonly text field when AnnotationMode is ENABLED\", async () => {\n  const { getDocument } = await import('../../src/display/api.js');\n  const { buildGetDocumentParams } = await import('./test_utils.js');\n  const loadingTask = getDocument(buildGetDocumentParams('issue17064_readonly.pdf'));\n  const pdfDocument = await loadingTask.promise;\n  const page = await pdfDocument.getPage(1);\n  const annotations = await page.getAnnotations({ intent: 'display' });\n  const readonlyTextField = annotations.find(ann => ann.fieldName === 'readonlyTextField');\n  expect(readonlyTextField).toBeDefined();\n  expect(readonlyTextField.fieldValue).toBe(\"Foo\");\n});",
    "i2_llama-3.3-70b-versatile": "it(\"should render readonly TextWidgetannotations when forms are disabled\", async () => {\n  const { getDocument } = await import('../../src/display/api.js');\n  const { buildGetDocumentParams } = await import('./test_utils.js');\n  const { AnnotationMode } = await import('../../src/shared/util.js');\n  const loadingTask = getDocument(buildGetDocumentParams('issue17064_readonly.pdf'), { annotationMode: AnnotationMode.ENABLED });\n  const pdfDocument = await loadingTask.promise;\n  const pdfPage = await pdfDocument.getPage(1);\n  const annotationLayer = await pdfPage.createAnnotationLayer();\n  const textWidgetAnnotations = annotationLayer.annotations.filter(annotation => annotation instanceof annotationLayer.constructor.TextWidgetAnnotationElement);\n  const readonlyTextWidgetAnnotations = textWidgetAnnotations.filter(annotation => annotation.data.readOnly);\n  const expected = true;\n  const actual = readonlyTextWidgetAnnotations.some(annotation => annotation.render().childElementCount > 0);\n  expect(actual).toBe(expected);\n});",
    "i3_deepseek-r1-distill-llama-70b": "it(\"should render readonly form field when AnnotationMode is ENABLED\", async () => {\n  const { getDocument } = await import(\"../../src/display/api.js\");\n  const { buildGetDocumentParams } = await import(\"./test_utils.js\");\n  const loadingTask = getDocument(buildGetDocumentParams('issue17064_readonly.pdf'));\n\n  const pdf = await loadingTask.promise;\n  const page = await pdf.getPage(1);\n  const viewport = page.getViewPort({ scale: 1 });\n  const div = document.createElement('div');\n\n  const annotationLayer = new (await import(\"../../src/display/annotation_layer.js\")).AnnotationLayer({\n    div,\n    page,\n    viewport,\n    l10n: new (await import(\"../../web/genericl10n.js\")).NullL10n(),\n    annotationCanvasMap: new Map(),\n    accessibilityManager: null,\n  });\n\n  const renderForms = true;\n  await annotationLayer.render({\n    annotations: await page.getAnnotations(),\n    renderForms,\n    enableScripting: true,\n    hasJSActions: false,\n    parent: {\n      page,\n      viewport,\n      zIndex: 0,\n    },\n  });\n\n  const textWidgetElements = div.getElementsByClassName('textWidgetAnnotation');\n  const textContent = textWidgetElements[0].textContent;\n\n  expect(textWidgetElements.length).toBe(1);\n  expect(textContent).toBe(\"Foo\");\n});",
    "i3_llama-3.3-70b-versatile": "it(\"should render readonly form fields when AnnotationMode is ENABLED\", async () => {\n  const { getDocument } = await import('../../src/display/api.js');\n  const { buildGetDocumentParams } = await import('./test_utils.js');\n  const loadingTask = getDocument(buildGetDocumentParams('issue17064_readonly.pdf'));\n  const pdfDocument = await loadingTask.promise;\n  const pdfPage = await pdfDocument.getPage(1);\n  const viewport = pdfPage.getViewport({ scale: 1 });\n  const annotationLayer = new (await import('../../src/display/annotation_layer.js')).AnnotationLayer({\n    div: document.createElement('div'),\n    page: pdfPage,\n    viewport: viewport,\n    linkService: null,\n    downloadManager: null,\n    annotationStorage: null,\n    renderForms: false,\n  });\n  const annotations = await pdfPage.getAnnotations();\n  await annotationLayer.render({ annotations, viewport, renderForms: true, annotationMode: AnnotationMode.ENABLED });\n  const textWidgetAnnotations = annotations.filter(annotation => annotation.subtype === AnnotationType.WIDGET && annotation.fieldType === 'Tx');\n  const readOnlyTextWidgetAnnotations = textWidgetAnnotations.filter(annotation => annotation.flags & 0x0002); // 0x0002 is the flag for read-only\n  const renderedReadOnlyTextWidgets = readOnlyTextWidgetAnnotations.map(annotation => annotationLayer.getEditableAnnotation(annotation.id));\n  expect(renderedReadOnlyTextWidgets.length).toBeGreaterThan(0);\n  for (const renderedAnnotation of renderedReadOnlyTextWidgets) {\n    expect(renderedAnnotation.container.hidden).toBe(false);\n  }\n});",
    "i4_deepseek-r1-distill-llama-70b": "it(\"should render readonly text fields when AnnotationMode is ENABLED\", async () => {\n  const { getDocument } = await import(\"../../src/display/api.js\");\n  const { buildGetDocumentParams } = await import(\"./test_utils.js\");\n  const loadingTask = getDocument(buildGetDocumentParams('issue17064_readonly.pdf'));\n\n  const { numPages, page } = await loadingTask;\n  const pdfPage = await page(0);\n\n  const annotationLayer = {\n    div: document.createElement(\"div\"),\n    viewport: pdfPage.viewport,\n    renderForms: false,\n    annotationStorage: new (await import(\"../../src/shared/util.js\")).AnnotationStorage(),\n    linkService: {},\n    enableScripting: false,\n  };\n\n  const AnnotationLayer = (await import(\"../../src/display/annotation_layer.js\")).AnnotationLayer;\n  const annotationLayerInstance = new AnnotationLayer({\n    div: annotationLayer.div,\n    page: pdfPage,\n    viewport: annotationLayer.viewport,\n    linkService: annotationLayer.linkService,\n    annotationStorage: annotationLayer.annotationStorage,\n    renderForms: annotationLayer.renderForms,\n    enableScripting: annotationLayer.enableScripting,\n  });\n\n  await annotationLayerInstance.render({\n    annotations: await pdfPage.getAnnotations(),\n    div: annotationLayer.div,\n    page: pdfPage,\n    viewport: annotationLayer.viewport,\n    linkService: annotationLayer.linkService,\n    downloadManager: {},\n    annotationStorage: annotationLayer.annotationStorage,\n    renderForms: annotationLayer.renderForms,\n    enableScripting: annotationLayer.enableScripting,\n  });\n\n  const textWidget = annotationLayer.div.querySelector(\".textWidgetAnnotation\");\n\n  expect(textWidget).toBeTruthy();\n});",
    "i4_gpt-4o": "it(\"should render readonly form field when AnnotationMode is ENABLED\", async () => {\n  const { getDocument } = await import(\"../../src/display/api.js\");\n  const { buildGetDocumentParams } = await import(\"./test_utils.js\");\n  const loadingTask = getDocument(buildGetDocumentParams(\"issue17064_readonly.pdf\"));\n  const pdfDocument = await loadingTask.promise;\n  const page = await pdfDocument.getPage(1);\n  const annotations = await page.getAnnotations({ intent: \"display\" });\n  const readOnlyField = annotations.find(ann => ann.fieldName === \"readonlyField\");\n  expect(readOnlyField).toBeDefined();\n  expect(readOnlyField.hidden).toBe(false);\n});",
    "i4_llama-3.3-70b-versatile": "it(\"should render readonly form fields when AnnotationMode is ENABLED\", async () => {\n  const { getDocument } = await import('../../src/display/api.js');\n  const { buildGetDocumentParams } = await import('./test_utils.js');\n  const loadingTask = getDocument(buildGetDocumentParams('issue17064_readonly.pdf'));\n  const pdfDocument = await loadingTask.promise;\n  const pdfPage = await pdfDocument.getPage(1);\n  const viewport = pdfPage.getViewport({ scale: 1 });\n  const annotationLayer = new (await import('../../src/display/annotation_layer.js')).AnnotationLayer({\n    div: document.createElement('div'),\n    page: pdfPage,\n    viewport: viewport,\n    linkService: null,\n    downloadManager: null,\n    annotationStorage: null,\n    imageResourcesPath: '',\n    renderForms: true,\n    enableScripting: false,\n    hasJSActions: false,\n  });\n  const annotations = await pdfPage.getAnnotations();\n  await annotationLayer.render({ annotations, renderForms: false });\n  const textWidgetAnnotations = annotationLayer.div.querySelectorAll('.textWidgetAnnotation');\n  expect(textWidgetAnnotations.length).toBe(1);\n  expect(textWidgetAnnotations[0].hidden).toBe(false);\n});",
    "i5_deepseek-r1-distill-llama-70b": "it(\"should render readonly text fields when AnnotationMode is ENABLED\", async () => {\n  const { getDocument } = await import('../../src/display/api.js');\n  const { buildGetDocumentParams } = await import('./test_utils.js');\n  const loadingTask = getDocument(buildGetDocumentParams('issue17064_readonly.pdf'));\n\n  const pdfDocument = await loadingTask.promise;\n  const annotationMode = 1; // ENABLED\n\n  const page = await pdfDocument.getPage(1);\n  const viewport = page.getViewport({ scale: 1 });\n\n  const div = document.createElement('div');\n  div.style.width = `${viewport.width}px`;\n  div.style.height = `${viewport.height}px`;\n  document.body.appendChild(div);\n\n  const renderTask = page.render({\n    container: div,\n    viewport: viewport,\n    annotationMode: annotationMode,\n  });\n\n  await renderTask.promise;\n\n  const widgetElements = div.querySelectorAll('.textWidget');\n  expect(widgetElements.length).toBe(1);\n  const widget = widgetElements[0];\n  expect(widget.hidden).toBe(false);\n});",
    "i5_gpt-4o": "it(\"should render readonly form field when AnnotationMode is ENABLED\", async () => {\n  const { getDocument } = await import('../../src/display/api.js');\n  const { buildGetDocumentParams } = await import('./test_utils.js');\n  const loadingTask = getDocument(buildGetDocumentParams('issue17064_readonly.pdf'));\n  const pdfDocument = await loadingTask.promise;\n  const page = await pdfDocument.getPage(1);\n  const annotations = await page.getAnnotations({ intent: 'display' });\n\n  const readOnlyField = annotations.find(annotation => annotation.fieldName === 'ReadOnlyField');\n  const isRenderable = readOnlyField && readOnlyField.hasOwnCanvas;\n\n  expect(isRenderable).toBe(true);\n});",
    "i5_llama-3.3-70b-versatile": "it(\"should render readonly form fields when AnnotationMode is ENABLED\", async () => {\n  const { getDocument } = await import('../../src/display/api.js');\n  const { buildGetDocumentParams } = await import('./test_utils.js');\n  const pdfFile = 'issue17064_readonly.pdf';\n  const loadingTask = getDocument(buildGetDocumentParams(pdfFile));\n  const pdfDocument = await loadingTask.promise;\n  const pdfPage = await pdfDocument.getPage(1);\n  const annotationMode = 1; // ENABLED\n  const renderForms = annotationMode === 2; // ENABLED_FORMS\n  const { AnnotationLayer } = await import('../../src/display/annotation_layer.js');\n  const annotationLayer = new AnnotationLayer({\n    page: pdfPage,\n    renderForms,\n    annotationMode,\n  });\n  const textWidgetAnnotations = annotationLayer.getAnnotations().filter(annotation => annotation.subtype === 'Widget');\n  const textWidgetAnnotation = textWidgetAnnotations.find(annotation => annotation.fieldValue === 'Foo');\n  const isRenderable = textWidgetAnnotation.isRenderable;\n  expect(isRenderable).toBe(true);\n});"
  },
  "17067": {
    "i1_deepseek-r1-distill-llama-70b": "it(\"should correctly update minmax for transformed rectangles\", async () => {\n  const { getDocument, buildGetDocumentParams } = await import(\"../../src/display/api.js\");\n  const loadingTask = getDocument(buildGetDocumentParams('issue17065.pdf'));\n  const doc = await loadingTask.promise;\n  const page = await doc.getPage(1);\n  const canvas = {\n    getContext: () => ({\n      createPattern: jest.fn(),\n      fillRect: jest.fn(),\n      measureText: () => ({ width: 0 }),\n      save: jest.fn(),\n      restore: jest.fn(),\n      translate: jest.fn(),\n      scale: jest.fn(),\n      rotate: jest.fn(),\n      transform: jest.fn(),\n      clip: jest.fn(),\n      resetTransform: jest.fn(),\n    })\n  };\n  const renderTask = page.render({\n    canvasContext: canvas.getContext(),\n    viewport: page.getViewport({ scale: 1 }),\n  });\n  await renderTask.promise;\n  const extraState = new CanvasExtraState(100, 100);\n  const rect = [0, 0, 100, 100];\n  const transform = [1, 0.5, 0, 1, 0, 0]; // Skew transform\n  extraState.minX = Infinity;\n  extraState.minY = Infinity;\n  extraState.maxX = -Infinity;\n  extraState.maxY = -Infinity;\n  extraState.updateRectMinMax(transform, rect);\n  const p1 = Util.applyTransform(rect, transform);\n  const p2 = Util.applyTransform([rect[2], rect[1]], transform);\n  const p3 = Util.applyTransform([rect[0], rect[3]], transform);\n  const p4 = Util.applyTransform([rect[2], rect[1]], transform);\n  expect(extraState.minX).toBe(Math.min(p1[0], p2[0], p3[0], p4[0]));\n  expect(extraState.minY).toBe(Math.min(p1[1], p2[1], p3[1], p4[1]));\n  expect(extraState.maxX).toBe(Math.max(p1[0], p2[0], p3[0], p4[0]));\n  expect(extraState.maxY).toBe(Math.max(p1[1], p2[1], p3[1], p4[1]));\n});",
    "i1_gpt-4o": "it(\"should render skewed and rotated rectangles with correct color gradient\", async () => {\n  const { getDocument } = await import(\"../../src/display/api.js\");\n  const { buildGetDocumentParams } = await import(\"./test_utils.js\");\n  const loadingTask = getDocument(buildGetDocumentParams(\"issue17065.pdf\"));\n  const pdfDocument = await loadingTask.promise;\n  const pdfPage = await pdfDocument.getPage(1);\n  const viewport = pdfPage.getViewport({ scale: 1.0 });\n  const canvasFactory = new DefaultCanvasFactory();\n  const canvasAndContext = canvasFactory.create(viewport.width, viewport.height);\n  const renderTask = pdfPage.render({\n    canvasContext: canvasAndContext.context,\n    viewport,\n  });\n  await renderTask.promise;\n  const imageData = canvasAndContext.context.getImageData(0, 0, viewport.width, viewport.height);\n  const hasGradient = (data) => {\n    let hasRed = false, hasBlue = false, hasGreen = false, hasPurple = false;\n    for (let i = 0; i < data.length; i += 4) {\n      const [r, g, b] = [data[i], data[i + 1], data[i + 2]];\n      if (r > 200 && g < 50 && b < 50) hasRed = true;\n      if (r < 50 && g < 50 && b > 200) hasBlue = true;\n      if (r < 50 && g > 200 && b < 50) hasGreen = true;\n      if (r > 200 && g < 50 && b > 200) hasPurple = true;\n    }\n    return hasRed && hasBlue && hasGreen && hasPurple;\n  };\n  expect(hasGradient(imageData.data)).toBe(true);\n});",
    "i1_llama-3.3-70b-versatile": "it(\"should render patterns correctly after applying a transform\", async () => {\n  const { getDocument } = await import('../../src/display/api.js');\n  const { buildGetDocumentParams } = await import('./test_utils.js');\n  const loadingTask = getDocument(buildGetDocumentParams('issue17065.pdf'));\n  const pdfDocument = await loadingTask.promise;\n  const pdfPage = await pdfDocument.getPage(1);\n  const viewport = pdfPage.getViewport({ scale: 1 });\n  const renderTask = pdfPage.render({\n    viewport,\n    canvasContext: null,\n    renderInteractive: false,\n    enableWebGL: false,\n  });\n  const renderResult = await renderTask.promise;\n  const expectedRenderResult = true;\n  expect(renderResult instanceof Object).toBe(expectedRenderResult);\n});",
    "i2_deepseek-r1-distill-llama-70b": "it(\"should correctly compute bounding box for transformed rectangles\", async () => {\n  const { CanvasExtraState } = await import(\"../../src/display/canvas.js\");\n  const { Util } = await import(\"../../src/shared/util.js\");\n\n  const state = new CanvasExtraState(100, 100);\n  const rect = [0, 0, 100, 100];\n  const transform = [1, 0.5, 0, 1, 0, 0];\n\n  state.minX = Infinity;\n  state.minY = Infinity;\n  state.maxX = -Infinity;\n  state.maxY = -Infinity;\n\n  state.updateRectMinMax(transform, rect);\n\n  const expectedMinX = 0;\n  const expectedMinY = 0;\n  const expectedMaxX = 150;\n  const expectedMaxY = 100;\n\n  expect(state.minX).toBe(expectedMinX);\n  expect(state.minY).toBe(expectedMinY);\n  expect(state.maxX).toBe(expectedMaxX);\n  expect(state.maxY).toBe(expectedMaxY);\n});",
    "i2_gpt-4o": "it(\"should render transformed rectangles with correct color gradients\", async () => {\n  const { getDocument } = await import('../../src/display/api.js');\n  const { buildGetDocumentParams } = await import('./test_utils.js');\n  const loadingTask = getDocument(buildGetDocumentParams('issue17065.pdf'));\n  const pdfDocument = await loadingTask.promise;\n  const pdfPage = await pdfDocument.getPage(1);\n  const viewport = pdfPage.getViewport({ scale: 1.0 });\n  const canvasFactory = new (await import('../../src/display/display_utils.js')).DOMCanvasFactory();\n  const canvasAndContext = canvasFactory.create(viewport.width, viewport.height);\n  const renderTask = pdfPage.render({\n    canvasContext: canvasAndContext.context,\n    viewport: viewport,\n  });\n  await renderTask.promise;\n  const imageData = canvasAndContext.context.getImageData(0, 0, viewport.width, viewport.height).data;\n  const hasGradient = (data) => {\n    let hasRed = false, hasBlue = false, hasGreen = false, hasPurple = false;\n    for (let i = 0; i < data.length; i += 4) {\n      const [r, g, b] = [data[i], data[i + 1], data[i + 2]];\n      if (r > 200 && g < 50 && b < 50) hasRed = true;\n      if (r < 50 && g < 50 && b > 200) hasBlue = true;\n      if (r < 50 && g > 200 && b < 50) hasGreen = true;\n      if (r > 200 && g < 50 && b > 200) hasPurple = true;\n    }\n    return hasRed && hasBlue && hasGreen && hasPurple;\n  };\n  expect(hasGradient(imageData)).toBe(true);\n});",
    "i2_llama-3.3-70b-versatile": "it(\"should correctly render transformed rectangles with patterns\", async () => {\n  const { getDocument } = await import('../../src/display/api.js');\n  const { buildGetDocumentParams } = await import('./test_utils.js');\n  const loadingTask = getDocument(buildGetDocumentParams('issue17065.pdf'));\n  const pdfDocument = await loadingTask.promise;\n  const pdfPage = await pdfDocument.getPage(1);\n  const canvas = document.createElement('canvas');\n  const ctx = canvas.getContext('2d');\n  const renderTask = pdfPage.render({\n    canvasContext: ctx,\n    viewport: pdfPage.getViewport({ scale: 1 }),\n  });\n  await renderTask.promise;\n  const expectedImageData = await new Promise((resolve) => {\n    ctx.getImageData(0, 0, canvas.width, canvas.height).then(resolve);\n  });\n  const actualImageData = ctx.getImageData(0, 0, canvas.width, canvas.height);\n  expect(actualImageData.data).toEqual(expectedImageData.data);\n});",
    "i3_deepseek-r1-distill-llama-70b": "it(\"should render patterns correctly after transform\", async () => {\n  const { getDocument } = await import('../../src/display/api.js');\n  const { buildGetDocumentParams } = await import('./test_utils.js');\n\n  const loadingTask = getDocument(buildGetDocumentParams('issue17065.pdf'));\n  const pdf = await loadingTask.promise;\n  const page = await pdf.getPage(1);\n  const viewport = page.getViewport({ scale: 1 });\n\n  const canvas = document.createElement('canvas');\n  const context = canvas.getContext('2d');\n  canvas.width = viewport.width;\n  canvas.height = viewport.height;\n\n  const renderTask = page.render({\n    canvasContext: context,\n    viewport: viewport,\n    transform: [1, 0, 0, 1, 0, 0],\n  });\n\n  await renderTask.promise;\n\n  // Verify the pattern is rendered correctly by checking pixel colors\n  const expectedRed = [255, 0, 0, 255];\n  const expectedBlue = [0, 0, 255, 255];\n  const expectedGreen = [0, 255, 0, 255];\n  const expectedPurple = [128, 0, 128, 255];\n\n  const actualPixel1 = context.getImageData(100, 100, 1, 1).data;\n  const actualPixel2 = context.getImageData(200, 200, 1, 1).data;\n  const actualPixel3 = context.getImageData(300, 300, 1, 1).data;\n  const actualPixel4 = context.getImageData(400, 400, 1, 1).data;\n\n  expect(actualPixel1).toEqual(expectedRed);\n  expect(actualPixel2).toEqual(expectedBlue);\n  expect(actualPixel3).toEqual(expectedGreen);\n  expect(actualPixel4).toEqual(expectedPurple);\n\n  await pdf.close();\n});",
    "i3_gpt-4o": "it(\"should render skewed and rotated rectangles with correct color gradients\", async () => {\n  const { getDocument } = await import(\"../../src/display/api.js\");\n  const { buildGetDocumentParams } = await import(\"./test_utils.js\");\n  const loadingTask = getDocument(buildGetDocumentParams(\"issue17065.pdf\"));\n  const pdfDocument = await loadingTask.promise;\n  const page = await pdfDocument.getPage(1);\n  const viewport = page.getViewport({ scale: 1.0 });\n  const canvasFactory = new DefaultCanvasFactory();\n  const canvasAndContext = canvasFactory.create(viewport.width, viewport.height);\n  const renderTask = page.render({\n    canvasContext: canvasAndContext.context,\n    viewport,\n    canvasFactory,\n  });\n  await renderTask.promise;\n  const imageData = canvasAndContext.context.getImageData(0, 0, viewport.width, viewport.height);\n  const hasGradient = (data) => {\n    let hasRed = false, hasBlue = false, hasGreen = false, hasPurple = false;\n    for (let i = 0; i < data.length; i += 4) {\n      const [r, g, b] = [data[i], data[i + 1], data[i + 2]];\n      if (r > 200 && g < 50 && b < 50) hasRed = true;\n      if (r < 50 && g < 50 && b > 200) hasBlue = true;\n      if (r < 50 && g > 200 && b < 50) hasGreen = true;\n      if (r > 100 && g < 50 && b > 100) hasPurple = true;\n    }\n    return hasRed && hasBlue && hasGreen && hasPurple;\n  };\n  expect(hasGradient(imageData.data)).toBe(true);\n  canvasFactory.destroy(canvasAndContext);\n});",
    "i3_llama-3.3-70b-versatile": "it(\"should render the pattern correctly after applying a transform\", async () => {\n  const { getDocument } = await import('../../src/display/api.js');\n  const { buildGetDocumentParams } = await import('./test_utils.js');\n  const loadingTask = getDocument(buildGetDocumentParams('issue17065.pdf'));\n  const pdfDocument = await loadingTask.promise;\n  const pdfPage = await pdfDocument.getPage(1);\n  const viewport = pdfPage.getViewport({ scale: 1 });\n  const canvas = document.createElement('canvas');\n  canvas.width = viewport.width;\n  canvas.height = viewport.height;\n  const ctx = canvas.getContext('2d');\n  const renderTask = pdfPage.render({\n    canvasContext: ctx,\n    viewport,\n  });\n  await renderTask.promise;\n  const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);\n  const expectedImageData = await new Promise((resolve) => {\n    const img = new Image();\n    img.crossOrigin = 'anonymous';\n    img.onload = () => {\n      const expectedCanvas = document.createElement('canvas');\n      expectedCanvas.width = img.width;\n      expectedCanvas.height = img.height;\n      const expectedCtx = expectedCanvas.getContext('2d');\n      expectedCtx.drawImage(img, 0, 0);\n      resolve(expectedCtx.getImageData(0, 0, img.width, img.height));\n    };\n    img.src = 'https://github.com/mozilla/pdf.js/files/12795741/test.pdf';\n  });\n  for (let i = 0; i < imageData.data.length; i += 4) {\n    if (imageData.data[i] !== expectedImageData.data[i] ||\n        imageData.data[i + 1] !== expectedImageData.data[i + 1] ||\n        imageData.data[i + 2] !== expectedImageData.data[i + 2]) {\n      throw new Error('Pattern not rendered correctly');\n    }\n  }\n});",
    "i4_deepseek-r1-distill-llama-70b": "it(\"should correctly render patterns with applied transforms\", async () => {\n  const { getDocument } = await import(\"../../src/display/api.js\");\n  const { buildGetDocumentParams } = await import(\"./test_utils.js\");\n  const loadingTask = getDocument(buildGetDocumentParams('issue17065.pdf'));\n\n  const pdf = await loadingTask.promise;\n  const page = await pdf.getPage(1);\n  const viewport = page.getViewport({ scale: 1 });\n  const canvas = document.createElement('canvas');\n  const context = canvas.getContext('2d');\n  canvas.width = viewport.width;\n  canvas.height = viewport.height;\n\n  const renderTask = page.render({\n    canvasContext: context,\n    viewport,\n    enableWebGL: false,\n    enablePatternDownscaling: true\n  });\n\n  await renderTask.promise;\n\n  const canvasData = context.getImageData(0, 0, canvas.width, canvas.height).data;\n\n  // Check top-left rectangle (no transform)\n  const rect1TopLeft = getPixelColor(canvasData, 100, 100);\n  expect(rect1TopLeft).toEqualRGB(255, 0, 0, 255); // Red\n\n  // Check bottom-right rectangle (with skew and rotation)\n  const rect2BottomRight = getPixelColor(canvasData, 300, 300);\n  expect(rect2BottomRight).toEqualRGB(0, 0, 255, 255); // Blue\n});\n\nfunction getPixelColor(data, x, y) {\n  const index = (y * data.width + x) * 4;\n  return {\n    r: data[index],\n    g: data[index + 1],\n    b: data[index + 2],\n    a: data[index + 3]\n  };\n}\n\nexpect.extend({\n  toEqualRGB(received, r, g, b, a) {\n    if (a === undefined) a = 255;\n    return {\n      message: () => `Expected color to be RGBA(${r},${g},${b},${a})`,\n      pass: received.r === r && received.g === g && received.b === b && received.a === a\n    };\n  }\n});",
    "i4_gpt-4o": "it(\"should render skewed and rotated rectangles with correct color gradients\", async () => {\n  const { getDocument } = await import('../../src/display/api.js');\n  const { buildGetDocumentParams } = await import('./test_utils.js');\n  const loadingTask = getDocument(buildGetDocumentParams('issue17065.pdf'));\n  const pdfDocument = await loadingTask.promise;\n  const pdfPage = await pdfDocument.getPage(1);\n  const viewport = pdfPage.getViewport({ scale: 1.0 });\n  const canvasFactory = new (await import('../../src/display/display_utils.js')).DOMCanvasFactory();\n  const canvasAndContext = canvasFactory.create(viewport.width, viewport.height);\n  const renderTask = pdfPage.render({\n    canvasContext: canvasAndContext.context,\n    viewport: viewport,\n    canvasFactory: canvasFactory,\n  });\n  await renderTask.promise;\n  const imageData = canvasAndContext.context.getImageData(0, 0, viewport.width, viewport.height);\n  const hasGradient = (data) => {\n    let hasRed = false, hasBlue = false, hasGreen = false, hasPurple = false;\n    for (let i = 0; i < data.length; i += 4) {\n      const [r, g, b] = [data[i], data[i + 1], data[i + 2]];\n      if (r > 200 && g < 50 && b < 50) hasRed = true;\n      if (r < 50 && g < 50 && b > 200) hasBlue = true;\n      if (r < 50 && g > 200 && b < 50) hasGreen = true;\n      if (r > 100 && g < 50 && b > 100) hasPurple = true;\n      if (hasRed && hasBlue && hasGreen && hasPurple) return true;\n    }\n    return false;\n  };\n  const actual = hasGradient(imageData.data);\n  const expected = true;\n  expect(actual).toBe(expected);\n});",
    "i4_llama-3.3-70b-versatile": "it(\"should render the pattern correctly after applying a transform\", async () => {\n  const { getDocument } = await import('../../src/display/api.js');\n  const { buildGetDocumentParams } = await import('./test_utils.js');\n  const loadingTask = getDocument(buildGetDocumentParams('issue17065.pdf'));\n  const pdfDocument = await loadingTask.promise;\n  const pdfPage = await pdfDocument.getPage(1);\n  const { CanvasGraphics } = await import('../../src/display/canvas.js');\n  const canvas = document.createElement('canvas');\n  const ctx = canvas.getContext('2d');\n  const canvasGraphics = new CanvasGraphics(ctx, pdfPage.commonObjs, pdfPage.objs, null, null, {}, {}, {});\n  await pdfPage.render({ canvasContext: ctx, viewport: pdfPage.getViewport({ scale: 1 }) });\n  const pixels = ctx.getImageData(0, 0, canvas.width, canvas.height).data;\n  let hasColor = false;\n  for (let i = 0; i < pixels.length; i += 4) {\n    if (pixels[i] !== 255 || pixels[i + 1] !== 255 || pixels[i + 2] !== 255) {\n      hasColor = true;\n      break;\n    }\n  }\n  expect(hasColor).toBe(true);\n});",
    "i5_deepseek-r1-distill-llama-70b": "it(\"should render patterns correctly after transform\", async () => {\n  const { getDocument } = await import('../../src/display/api.js');\n  const { buildGetDocumentParams } = await import('./test_utils.js');\n\n  const loadingTask = getDocument(buildGetDocumentParams('issue17065.pdf'));\n  const pdf = await loadingTask.promise;\n  const page = await pdf.getPage(1);\n  const scale = 1;\n  const viewport = page.getViewport({ scale });\n\n  const canvas = document.createElement('canvas');\n  const context = canvas.getContext('2d');\n  canvas.width = viewport.width;\n  canvas.height = viewport.height;\n\n  await page.render({\n    canvasContext: context,\n    viewport,\n    scale,\n  });\n\n  const expectedColors = [\n    { x: 100, y: 100, r: 255, g: 0, b: 0 }, // Red part\n    { x: 200, y: 200, r: 0, g: 0, b: 255 }, // Blue part\n    { x: 300, y: 300, r: 0, g: 255, b: 0 }, // Green part\n    { x: 400, y: 400, r: 128, g: 0, b: 128 } // Purple part\n  ];\n\n  const pixelData = context.getImageData(0, 0, canvas.width, canvas.height).data;\n\n  expectedColors.forEach(({ x, y, r, g, b }) => {\n    const index = (y * canvas.width + x) * 4;\n    expect(pixelData[index + 0]).toBeCloseTo(r, -1);\n    expect(pixelData[index + 1]).toBeCloseTo(g, -1);\n    expect(pixelData[index + 2]).toBeCloseTo(b, -1);\n  });\n});",
    "i5_gpt-4o": "it(\"should render skewed and rotated rectangles with correct color gradients\", async () => {\n  const { getDocument } = await import('../../src/display/api.js');\n  const { buildGetDocumentParams } = await import('./test_utils.js');\n  const loadingTask = getDocument(buildGetDocumentParams('issue17065.pdf'));\n  const pdfDocument = await loadingTask.promise;\n  const pdfPage = await pdfDocument.getPage(1);\n  const viewport = pdfPage.getViewport({ scale: 1.0 });\n  const canvasFactory = new (await import('../../src/display/display_utils.js')).DOMCanvasFactory();\n  const canvasAndContext = canvasFactory.create(viewport.width, viewport.height);\n  const renderTask = pdfPage.render({\n    canvasContext: canvasAndContext.context,\n    viewport: viewport,\n  });\n  await renderTask.promise;\n  const imageData = canvasAndContext.context.getImageData(0, 0, viewport.width, viewport.height).data;\n  const hasGradient = (data) => {\n    let hasRed = false, hasBlue = false, hasGreen = false, hasPurple = false;\n    for (let i = 0; i < data.length; i += 4) {\n      const [r, g, b] = [data[i], data[i + 1], data[i + 2]];\n      if (r > 200 && g < 50 && b < 50) hasRed = true;\n      if (r < 50 && g < 50 && b > 200) hasBlue = true;\n      if (r < 50 && g > 200 && b < 50) hasGreen = true;\n      if (r > 100 && g < 50 && b > 100) hasPurple = true;\n    }\n    return hasRed && hasBlue && hasGreen && hasPurple;\n  };\n  expect(hasGradient(imageData)).toBe(true);\n});",
    "i5_llama-3.3-70b-versatile": "it(\"should render patterns correctly after applying a transform\", async () => {\n  const { getDocument } = await import('../../src/display/api.js');\n  const { buildGetDocumentParams } = await import('./test_utils.js');\n  const { PDFPageProxy } = await import('../../src/display/api.js');\n  const loadingTask = getDocument(buildGetDocumentParams('issue17065.pdf'));\n  const pdf = await loadingTask.promise;\n  const page = await pdf.getPage(1);\n  const viewport = page.getViewport({ scale: 1 });\n  const renderTask = page.render({\n    viewport,\n    intent: 'display',\n  });\n  const renderPromise = renderTask.promise;\n  await renderPromise;\n  const expectedRects = [\n    { x: 10, y: 10, width: 50, height: 50 },\n    { x: 70, y: 10, width: 50, height: 50 },\n    { x: 10, y: 70, width: 50, height: 50 },\n    { x: 70, y: 70, width: 50, height: 50 },\n  ];\n  const actualRects = [];\n  const ctx = renderTask.canvasContext;\n  const imageData = ctx.getImageData(0, 0, viewport.width, viewport.height);\n  for (let i = 0; i < expectedRects.length; i++) {\n    const rect = expectedRects[i];\n    const pixels = ctx.getImageData(rect.x, rect.y, rect.width, rect.height).data;\n    let hasColor = false;\n    for (let j = 0; j < pixels.length; j += 4) {\n      if (pixels[j] !== 0 || pixels[j + 1] !== 0 || pixels[j + 2] !== 0) {\n        hasColor = true;\n        break;\n      }\n    }\n    actualRects.push(hasColor);\n  }\n  expect(actualRects.every(rect => rect)).toBe(true);\n});"
  },
  "17070": {
    "i1_deepseek-r1-distill-llama-70b": "it(\"should render comment and sticky note annotations\", async () => {\n  const { getDocument } = await import('../../src/display/api.js');\n  const { buildGetDocumentParams } = await import('./test_utils.js');\n  const loadingTask = getDocument(buildGetDocumentParams('issue17069.pdf'));\n\n  const { numPages, pages } = await loadingTask;\n  const page = await pages.open(0);\n\n  const annotationLayer = await page.annotationLayer;\n  const annotations = await annotationLayer.getAnnotations();\n\n  expect(annotations.length).toBeGreaterThan(0);\n  const annotation = annotations[0];\n  expect(annotation instanceof TextAnnotation).toBe(true);\n  expect(annotation.data.noHTML).toBe(false);\n});",
    "i1_llama-3.3-70b-versatile": "it(\"should render comment and sticky note annotations in the viewer\", async () => {\n  const { getDocument } = await import('../../src/display/api.js');\n  const { buildGetDocumentParams } = await import('./test_utils.js');\n  const loadingTask = getDocument(buildGetDocumentParams('issue17069.pdf'));\n  const pdfDocument = await loadingTask.promise;\n  const pdfPage = await pdfDocument.getPage(1);\n  const annotations = await pdfPage.getAnnotations();\n  const annotationTypes = annotations.map(annotation => annotation.annotationType);\n  expect(annotationTypes).toContain(AnnotationType.TEXT);\n  expect(annotationTypes).toContain(AnnotationType.STICKY_NOTE);\n});",
    "i2_deepseek-r1-distill-llama-70b": "it(\"should render annotations with correct HTML handling\", async () => {\n  const { getDocument } = await import(\"../../src/display/api.js\");\n  const { buildGetDocumentParams } = await import(\"./test_utils.js\");\n  const loadingTask = getDocument(buildGetDocumentParams('issue17069.pdf'));\n\n  const { numPages, page } = await loadingTask;\n  await page.render();\n\n  const annotations = await page.getAnnotations();\n  const expectedAnnotationTypes = ['text', 'popup'];\n\n  expect(annotations.length).toBeGreaterThan(0);\n  expect(annotations[0].data.annotationType)).toBe(AnnotationType.TEXT);\n  expect(annotations[1].data.annotationType)).toBe(AnnotationType.POPUP);\n});",
    "i2_llama-3.3-70b-versatile": "it(\"should render comments and sticky notes in the viewer\", async () => {\n  const { getDocument } = await import('../../src/display/api.js');\n  const { buildGetDocumentParams } = await import('./test_utils.js');\n  const loadingTask = getDocument(buildGetDocumentParams('issue17069.pdf'));\n  const pdfDocument = await loadingTask.promise;\n  const pdfPage = await pdfDocument.getPage(1);\n  const annotations = await pdfPage.getAnnotations();\n  const annotationTypes = annotations.map(annotation => annotation.data.annotationType);\n  const expectedTypes = [6, 7]; // 6: Text, 7: Popup\n  expect(annotationTypes).toEqual(expect.arrayContaining(expectedTypes));\n});",
    "i3_deepseek-r1-distill-llama-70b": "it(\"should render popup annotations as HTML\", async () => {\n  const { getDocument } = await import(\"../../src/display/api.js\");\n  const { buildGetDocumentParams } = await import(\"./test_utils.js\");\n  const loadingTask = getDocument(buildGetDocumentParams('issue17069.pdf'));\n\n  const pdfDocument = await loadingTask;\n  const pdfPage = await pdfDocument.getPage(0);\n  const annotations = await pdfPage.getAnnotations();\n\n  let popupAnnotationCount = 0;\n\n  for (const annotation of annotations) {\n    const { subtype } = await annotation.get_data();\n    if (subtype === AnnotationType.POPUP) {\n      popupAnnotationCount++;\n      const html = await annotation.get_html();\n      assert(html.length > 0, \"Popup annotation HTML is empty\");\n    }\n  }\n\n  assert(popupAnnotationCount > 0, \"No popup annotations found\");\n});",
    "i3_llama-3.3-70b-versatile": "it(\"should render comment and sticky note annotations in the viewer\", async () => {\n  const { getDocument } = await import('../../src/display/api.js');\n  const { buildGetDocumentParams } = await import('./test_utils.js');\n  const loadingTask = getDocument(buildGetDocumentParams('issue17069.pdf'));\n  const doc = await loadingTask.promise;\n  const page = await doc.getPage(1);\n  const annotations = await page.getAnnotations();\n  const annotation0 = annotations[0];\n  const annotation1 = annotations[1];\n  expect(annotation0.data.annotationType).toBe(AnnotationType.STICKY_NOTE);\n  expect(annotation1.data.annotationType).toBe(AnnotationType.STICKY_NOTE);\n  const renderTask = page.render({\n    annotationMode: 'visible',\n  });\n  await renderTask.promise;\n  expect(renderTask.annotationCanvasContext).not.toBeNull();\n});",
    "i4_deepseek-r1-distill-llama-70b": "it(\"should render sticky note annotations\", async () => {\n  const { getDocument } = await import(\"../../src/display/api.js\");\n  const { buildGetDocumentParams } = await import(\"./test_utils.js\");\n  const loadingTask = getDocument(buildGetDocumentParams('issue17069.pdf'));\n\n  const { doc, page } = await loadingTask;\n  await doc.load();\n  await page.load();\n  await page.render();\n\n  const annotations = await page.getAnnotations();\n  const textAnnotation = annotations.find(annotation => annotation instanceof TextAnnotation);\n\n  expect(textAnnotation.data.noHTML).toBe(false);\n\n  await doc.destroy();\n});",
    "i4_llama-3.3-70b-versatile": "it(\"should render comment and sticky note annotations in the viewer\", async () => {\n  const { getDocument } = await import('../../src/display/api.js');\n  const { buildGetDocumentParams } = await import('./test_utils.js');\n  const loadingTask = getDocument(buildGetDocumentParams('issue17069.pdf'));\n  const pdfDocument = await loadingTask.promise;\n  const pdfPage = await pdfDocument.getPage(1);\n  const annotations = await pdfPage.getAnnotations();\n  const annotationTypes = annotations.map(annotation => annotation instanceof (await import('../../src/core/annotation.js')).MarkupAnnotation);\n  const expected = true;\n  const actual = annotationTypes.every(type => type);\n  expect(actual).toBe(expected);\n});",
    "i5_deepseek-r1-distill-llama-70b": "it(\"should render annotations in the viewer\", async () => {\n  const { getDocument } = await import(\"../../src/display/api.js\");\n  const { buildGetDocumentParams } = await import(\"./test_utils.js\");\n  const loadingTask = getDocument(buildGetDocumentParams('issue17069.pdf'));\n\n  const { numPages } = await loadingTask.promise;\n  const page = await loadingTask.document.getPage(1);\n  const viewport = page.getViewport({ scale: 1 });\n\n  const div = document.createElement('div');\n  await page.render({\n    canvasContext: null,\n    viewport,\n    annotationMode: true,\n    renderInteractiveForms: true,\n  });\n\n  const annotations = div.querySelectorAll('[data-annotation-id]');\n  expect(annotations.length).toBeGreaterThan(0);\n});"
  },
  "17106": {
    "i1_deepseek-r1-distill-llama-70b": "it(\"should prevent memory ballooning when scrolling through PDF\", async () => {\n  const { getDocument } = await import(\"../../src/display/api.js\");\n  const { GlobalImageCache } = await import(\"../../src/core/image_utils.js\");\n  const { TEST_PDFS_PATH } = await import(\"./test_utils.js\");\n\n  // Use a PDF with many images to test memory usage\n  const pdfPath = `${TEST_PDFS_PATH}/image-pdf.pdf`;\n  const params = buildGetDocumentParams(pdfPath, null, null, WORKER_SRC);\n  const doc = await getDocument(params);\n  const cache = new GlobalImageCache();\n\n  // Simulate scrolling by rendering multiple pages\n  for (let i = 0; i < 10; i++) {\n    const page = await doc.getPage(i + 1);\n    await page.render({\n      canvasContext: { getContext: () => ({} ) },\n      viewport: page.getViewport({ scale: 1 }),\n    });\n  }\n\n  // Verify that image data is properly released\n  await new Promise(resolve => setTimeout(resolve, 1000)); // Give cleanup time\n  global.gc(); // Force garbage collection\n\n  // In the buggy version, the cache size would remain large\n  const expectedCacheSize = 0;\n  const actualCacheSize = Object.keys(cache._cache).length;\n\n  assert.strictEqual(actualCacheSize, expectedCacheSize);\n});",
    "i1_gpt-4o": "it(\"should release ImageBitmap data after cleanup\", async () => {\n  const { getDocument } = await import(\"../../src/display/api.js\");\n  const loadingTask = getDocument(buildGetDocumentParams(\"basicapi.pdf\"));\n  const pdfDocument = await loadingTask.promise;\n  const page = await pdfDocument.getPage(1);\n\n  const renderTask = page.render({\n    canvasContext: new OffscreenCanvas(1, 1).getContext(\"2d\"),\n    viewport: page.getViewport({ scale: 1.0 }),\n  });\n\n  await renderTask.promise;\n\n  const imageData = { bitmap: new ImageBitmap(new OffscreenCanvas(1, 1)) };\n  page.objs.resolve(1, imageData);\n\n  page.cleanup();\n\n  let errorOccurred = false;\n  try {\n    imageData.bitmap.close();\n  } catch (e) {\n    errorOccurred = true;\n  }\n\n  expect(errorOccurred).toBe(false);\n});",
    "i1_llama-3.3-70b-versatile": "it(\"should release ImageBitmap data after cleanup\", async () => {\n  const { PDFWorker, PDFDocumentLoadingTask, PDFPageProxy } = await import(\"../../src/display/api.js\");\n  const { buildGetDocumentParams, TEST_PDFS_PATH } = await import(\"./test_utils.js\");\n  const params = buildGetDocumentParams({\n    cMapUrl: CMAP_URL,\n    cMapPacked: true,\n    disableFontFace: true,\n    disableWorker: false,\n    useWorkerFetch: true,\n  });\n  const pdfWorker = new PDFWorker({\n    workerSrc: WORKER_SRC,\n  });\n  const loadingTask = pdfWorker.createLoadingTask(params);\n  const pdfDocument = await loadingTask.promise;\n  const pageProxy = await pdfDocument.getPage(1);\n  const page = new PDFPageProxy(pageProxy);\n  const imageData = { bitmap: { close: jest.fn() } };\n  page.objs.resolve(1, imageData);\n  page._intentStates.clear();\n  expect(imageData.bitmap.close).not.toHaveBeenCalled();\n  page._cleanup();\n  expect(imageData.bitmap.close).toHaveBeenCalledTimes(1);\n});",
    "i2_deepseek-r1-distill-llama-70b": "it(\"should not balloon memory when scrolling through PDF with large images\", async () => {\n  const { PDFDocument, PDFPageProxy } = await import(\"../../src/display/api.js\");\n  const { puppeteer } = await import(\"puppeteer\");\n\n  const browser = await puppeteer.launch();\n  const page = await browser.newPage();\n  const largePdfPath = require.resolve(\"../../test/pdfs/large-image.pdf\");\n\n  // Load PDF with multiple large images\n  await page.goto(`file://${largePdfPath}`, { waitUntil: \"networkidle0\" });\n\n  // Simulate scrolling through pages\n  await page.evaluate(async () => {\n    const pdfDoc = await PDFDocument.load(await fetch(\"file://../test/pdfs/large-image.pdf\").then(res => res.arrayBuffer()));\n    await pdfDoc.getPage(1).render();\n    history.back();\n  });\n\n  // Verify memory usage is within expected range after cleanup\n  const memoryUsage = await page.evaluate(() => {\n    return performance.memory.usedJSHeapSize;\n  });\n\n  await browser.close();\n\n  // Adjust the expected threshold based on your environment\n  expect(memoryUsage).toBeLessThan(20 * 1024 * 1024); // 20MB\n});",
    "i2_gpt-4o": "it(\"should not store image data after cleanup\", async () => {\n  const { PDFPageProxy } = await import(\"../../src/display/api.js\");\n  const { PDFObjects } = await import(\"../../src/core/primitives.js\");\n\n  const pageProxy = new PDFPageProxy();\n  pageProxy.objs = new PDFObjects();\n  pageProxy._intentStates = new Map();\n\n  const imageData = { bitmap: { close: jest.fn() } };\n  const id = \"testImageId\";\n  const type = \"Image\";\n\n  pageProxy._intentStates.size = 0; // Simulate cleanup has run\n  pageProxy.objs.has = jest.fn().mockReturnValue(false);\n\n  const workerTransport = new WorkerTransport();\n  workerTransport.#pageCache.set(0, pageProxy);\n\n  workerTransport.messageHandler = {\n    on: jest.fn((event, callback) => {\n      if (event === \"obj\") {\n        callback([id, 0, type, imageData]);\n      }\n    }),\n  };\n\n  workerTransport.setupMessageHandler();\n\n  expect(imageData.bitmap.close).toHaveBeenCalled();\n  expect(pageProxy.objs.has(id)).toBe(false);\n});",
    "i2_llama-3.3-70b-versatile": "it(\"should not store pagelevel data after cleanup\", async () => {\n  const { WorkerTransport, PDFWorkerUtil, PDFDocumentProxy, MessageHandler } = await import(\"../../src/display/api.js\");\n  const { PDFDataTransportStream } = await import(\"../../src/display/transport_stream.js\");\n  const { PDFFetchStream } = await import(\"../../src/display/fetch_stream.js\");\n  const { PDFNetworkStream } = await import(\"../../src/display/network.js\");\n\n  const messageHandler = new MessageHandler();\n  const transport = new PDFDataTransportStream(new PDFFetchStream(new PDFNetworkStream()));\n  const workerTransport = new WorkerTransport(messageHandler, {}, transport, {}, {});\n\n  const pageProxy = { objs: new Map(), _intentStates: new Set(), _maybeCleanupAfterRender: true };\n  workerTransport.#pageCache.set(1, pageProxy);\n\n  const imageData = { bitmap: { close: () => {} } };\n\n  workerTransport.messageHandler.on(\"obj\", ([id, pageIndex, type, imageData]) => {\n    if (pageIndex === 1 && type === \"Image\") {\n      pageProxy.objs.set(id, imageData);\n    }\n  });\n\n  workerTransport.messageHandler.send(\"obj\", [1, 1, \"Image\", imageData]);\n\n  pageProxy._intentStates.clear();\n\n  expect(pageProxy.objs.size).toBe(0);\n  expect(imageData.bitmap.close).toHaveBeenCalledTimes(1);\n});",
    "i3_deepseek-r1-distill-llama-70b": "it(\"should release image data after cleanup to prevent memory ballooning\", async () => {\n  const { PDFWorker } = await import(\"../../src/display/api.js\");\n  const { LoopbackPort } = await import(\"../../src/display/api.js\");\n  const { PDFDocumentProxy } = await import(\"../../src/display/api.js\");\n  const { PDFPageProxy } = await import(\"../../src/display/api.js\");\n  const { PDFDocumentLoadingTask } = await import(\"../../src/display/api.js\");\n  const { GlobalImageCache } = await import(\"../../src/core/image_utils.js\");\n  const { heapdump } = await import(\"heapdump\");\n  const { objectSize } = await import(\"../../src/shared/util.js\");\n\n  // Setup fake worker\n  const port = new LoopbackPort();\n  const worker = new PDFWorker({ port });\n\n  // Load test PDF\n  const pdfPath = require.resolve(`${TEST_PDFS_PATH}/tricky.pdf`);\n  const loadingTask = await PDFDocumentLoadingTask.fromFetch(pdfPath);\n  const doc = await loadingTask.promise;\n\n  // Get first page\n  const page = await doc.getPage(1);\n\n  // Render the page\n  const viewport = page.getViewport({ scale: 1 });\n  const canvas = document.createElement(\"canvas\");\n  canvas.width = viewport.width;\n  canvas.height = viewport.height;\n  const context = canvas.getContext(\"2d\");\n  const renderTask = page.render({\n    canvasContext: context,\n    viewport,\n  });\n\n  // Ensure rendering is complete\n  await renderTask.promise;\n\n  // Force cleanup\n  await page.cleanup();\n\n  // Measure memory usage\n  const heapSnapshot = await heapdump.snapshot();\n  const imageSize = objectSize(heapSnapshot);\n\n  // Verify memory is released\n  expect(imageSize).toBeLessThan(10 * 1024 * 1024); // 10MB threshold\n});",
    "i3_gpt-4o": "it(\"should release ImageBitmap data after cleanup\", async () => {\n  const { getDocument } = await import(\"../../src/display/api.js\");\n  const loadingTask = getDocument(buildGetDocumentParams(\"basicapi.pdf\"));\n  const pdfDocument = await loadingTask.promise;\n  const page = await pdfDocument.getPage(1);\n\n  const renderTask = page.render({\n    canvasContext: new DefaultCanvasFactory().create(100, 100).context,\n    viewport: page.getViewport({ scale: 1.0 }),\n  });\n  await renderTask.promise;\n\n  const imageData = { bitmap: new ImageBitmap() };\n  page.objs.resolve(\"testImage\", imageData);\n\n  await page.cleanup();\n  expect(imageData.bitmap).toBeNull();\n});",
    "i3_llama-3.3-70b-versatile": "it(\"should prevent memory usage from ballooning when scrolling through a PDF\", async () => {\n  const pdfUrl = `${TEST_PDFS_PATH}/pdfissue.pdf`;\n  const loadingTask = await getDocument({ url: pdfUrl });\n  const pdfDocument = await loadingTask.promise;\n  const pdfPage = await pdfDocument.getPage(1);\n  const viewport = pdfPage.getViewport({ scale: 1 });\n  const canvas = document.createElement('canvas');\n  const canvasContext = canvas.getContext('2d');\n  const renderTask = pdfPage.render({\n    canvasContext,\n    viewport,\n  });\n  await renderTask.promise;\n  const pageIntentStates = pdfPage._intentStates;\n  const intentState = pageIntentStates.values().next().value;\n  const objs = intentState.operatorList;\n  const imageData = objs.argsArray.find(arg => arg instanceof Object && 'bitmap' in arg);\n  if (imageData) {\n    imageData.bitmap.close();\n  }\n  const pageProxy = pdfPage;\n  const pageIntentStatesSizeBeforeCleanup = pageIntentStates.size;\n  pageProxy.cleanup();\n  const pageIntentStatesSizeAfterCleanup = pageIntentStates.size;\n  expect(pageIntentStatesSizeBeforeCleanup).toBeGreaterThan(0);\n  expect(pageIntentStatesSizeAfterCleanup).toBe(0);\n});",
    "i4_deepseek-r1-distill-llama-70b": "it(\"should release image data after cleanup\", async () => {\n  const { PDFWorker, PDFDocument, PDFWorkerUtil } = await import(\"../../src/display/api.js\");\n  const { PDFDataRangeTransport } = await import(\"../../src/display/api.js\");\n  const { CMAP_URL, TEST_PDFS_PATH } = await import(\"./test_utils.js\");\n\n  const worker = new PDFWorker({ verbosity: 'error' });\n  const transport = new PDFDataRangeTransport(0, null, true);\n  const doc = await PDFDocument.load({\n    url: `${TEST_PDFS_PATH}/trivial.pdf`,\n    range: transport,\n    worker,\n  });\n\n  const page = await doc.getPage(1);\n  await page.render({\n    canvasContext: new (await import(\"../../src/display/canvas.js\")).CanvasGraphics(),\n    viewport: page.getViewport({ scale: 1 }),\n  });\n\n  const transportAfter = new PDFDataRangeTransport(0, null, true);\n  const pageAfter = new PDFPageProxy(0, {}, transportAfter);\n  const cleanupResult = await pageAfter.cleanup();\n\n  const { commonObjs } = pageAfter._transport;\n  const imageData = Object.values(commonObjs._objs).find(obj => obj.data?.bitmap);\n\n  expect(imageData?.bitmap?.closed).toBe(true);\n});",
    "i4_gpt-4o": "it(\"should release ImageBitmap data after cleanup\", async () => {\n  const { PDFPageProxy } = await import(\"../../src/display/api.js\");\n  const pageProxy = new PDFPageProxy(0, { view: [0, 0, 100, 100] }, {}, false);\n  const imageData = { bitmap: { close: jest.fn() } };\n  pageProxy.objs.resolve(\"testImage\", imageData);\n  pageProxy.cleanup();\n  expect(imageData.bitmap.close).toHaveBeenCalled();\n});",
    "i4_llama-3.3-70b-versatile": "it(\"should release ImageBitmap data after cleanup\", async () => {\n  const { PDFPageProxy, PDFDocumentProxy, PDFWorker, getDocument } = await import(\"../../src/display/api.js\");\n  const { createIdFactory } = await import(\"./test_utils.js\");\n  const idFactory = createIdFactory();\n  const doc = await getDocument({ url: 'https://example.com/example.pdf' });\n  const page = await doc.getPage(1);\n  const imageData = { bitmap: { close: jest.fn() } };\n  page.objs.resolve(idFactory.next(), imageData);\n  await page.cleanup();\n  expect(imageData.bitmap.close).toHaveBeenCalledTimes(1);\n});",
    "i5_deepseek-r1-distill-llama-70b": "it(\"should prevent memory ballooning when scrolling through PDF\", async () => {\n  const { PDFDocument } = await import(\"../../src/display/api.js\");\n  const { PDFPageProxy } = await import(\"../../src/display/api.js\");\n\n  // Load a test PDF with multiple pages\n  const pdf = await PDFDocument.load(await fetch(`${TEST_PDFS_PATH}with-many-pages.pdf`));\n\n  // Generate a large number of pages to simulate scrolling\n  const pages = [];\n  for (let i = 0; i < 100; i++) {\n    pages.push(await pdf.getPage(i + 1));\n  }\n\n  // Track memory usage\n  const heapSizes = [];\n  for (const page of pages) {\n    // Render the page\n    const pageProxy = new PDFPageProxy(page);\n    await pageProxy.render();\n\n    // Force cleanup\n    pageProxy.cleanup();\n\n    // Measure heap size after cleanup\n    const heapStats = v8.getHeapStatistics();\n    heapSizes.push(heapStats.used_heap_size);\n\n    // Release references\n    pageProxy.objs.clear();\n  }\n\n  // Check if memory usage remains stable\n  const maxHeapSize = Math.max(...heapSizes);\n  expect(maxHeapSize).toBeLessThan(200 * 1024 * 1024); // 200MB threshold\n});",
    "i5_gpt-4o": "it(\"should release ImageBitmap data when intentStates size is zero\", async () => {\n  const { PDFPageProxy } = await import(\"../../src/display/api.js\");\n  const { createIdFactory } = await import(\"./test_utils.js\");\n\n  const idFactory = createIdFactory(0);\n  const pageProxy = new PDFPageProxy({\n    pageIndex: 0,\n    pageInfo: { ref: { num: 1, gen: 0 } },\n    transport: null,\n    intentStates: new Map(),\n    idFactory,\n  });\n\n  const imageData = {\n    bitmap: {\n      close: jest.fn(),\n    },\n  };\n\n  pageProxy.objs = new Map();\n  pageProxy.objs.has = jest.fn().mockReturnValue(false);\n\n  pageProxy._intentStates = new Map();\n\n  pageProxy.objs.get = jest.fn().mockReturnValue(imageData);\n\n  pageProxy.objs.has = jest.fn().mockReturnValue(false);\n\n  pageProxy._transport = {\n    messageHandler: {\n      sendWithPromise: jest.fn().mockResolvedValue({}),\n    },\n  };\n\n  pageProxy._transport.messageHandler.sendWithPromise(\"commonobj\", {\n    id: \"testId\",\n    type: \"Image\",\n    imageData,\n  });\n\n  expect(imageData.bitmap.close).toHaveBeenCalled();\n});",
    "i5_llama-3.3-70b-versatile": "it(\"should release ImageBitmap data after cleanup\", async () => {\n  const { PDFWorker, PDFDocumentProxy, PDFPageProxy } = await import(\"../../src/display/api.js\");\n  const { PDFDocument } = await import(\"../../src/core/document.js\");\n  const { createIdFactory } = await import(\"./test_utils.js\");\n\n  const idFactory = createIdFactory();\n  const pdfWorker = new PDFWorker();\n  const pdfDocument = new PDFDocument({\n    url: \"test.pdf\",\n    worker: pdfWorker,\n    idFactory,\n  });\n  const pageProxy = new PDFPageProxy({\n    pdfDocument,\n    pageIndex: 0,\n    idFactory,\n  });\n\n  const imageData = { bitmap: { close: jest.fn() } };\n  pageProxy._intentStates.set(\"test\", \"test\");\n  pageProxy.objs.set(\"test\", imageData);\n  pageProxy._cleanup();\n\n  expect(imageData.bitmap.close).not.toHaveBeenCalled();\n\n  pageProxy._intentStates.clear();\n  pageProxy._cleanup();\n\n  expect(imageData.bitmap.close).toHaveBeenCalledTimes(1);\n});"
  },
  "17120": {
    "i1_llama-3.3-70b-versatile": "it(\"should remove unused debugging code\", async () => {\n  const { Util } = await import(\"../../src/shared/util.js\");\n  const fs = await import('fs');\n  const path = await import('path');\n\n  const cffStandardStringsPath = path.join(__dirname, '../../src/shared/cffStandardStrings.js');\n  const fontsUtilsPath = path.join(__dirname, '../../src/shared/fonts_utils.js');\n\n  const cffStandardStringsExistsBefore = fs.existsSync(cffStandardStringsPath);\n  const fontsUtilsExistsBefore = fs.existsSync(fontsUtilsPath);\n\n  // Apply the patch\n  fs.unlinkSync(cffStandardStringsPath);\n  fs.unlinkSync(fontsUtilsPath);\n\n  const cffStandardStringsExistsAfter = fs.existsSync(cffStandardStringsPath);\n  const fontsUtilsExistsAfter = fs.existsSync(fontsUtilsPath);\n\n  expect(cffStandardStringsExistsBefore).toBe(true);\n  expect(fontsUtilsExistsBefore).toBe(true);\n  expect(cffStandardStringsExistsAfter).toBe(false);\n  expect(fontsUtilsExistsAfter).toBe(false);\n});",
    "i2_deepseek-r1-distill-llama-70b": "it(\"should not have obsolete files\", async () => {\n  const { CFFEncodingMap } = await import(\"../../src/shared/cffStandardStrings.js\");\n  const { readCharset } = await import(\"../../src/shared/fonts_utils.js\");\n  expect(CFFEncodingMap).toBeUndefined();\n  expect(readCharset).toBeUndefined();\n});",
    "i2_gpt-4o": "it(\"should not have obsolete files in the project\", async () => {\n  const fs = await import(\"fs\");\n  const path = await import(\"path\");\n\n  const obsoleteFiles = [\n    path.resolve(__dirname, \"../../src/shared/cffStandardStrings.js\"),\n    path.resolve(__dirname, \"../../src/shared/fonts_utils.js\"),\n  ];\n\n  const filesExist = obsoleteFiles.map(filePath => fs.existsSync(filePath));\n  const expected = [false, false];\n\n  expect(filesExist).toEqual(expected);\n});",
    "i3_deepseek-r1-distill-llama-70b": "it(\"should remove unused CFF debugging code\", async () => {\n  const { CFFEncodingMap, CFFDictDataMap, CFFDictPrivateDataMap } = await import(\"../../src/shared/cffStandardStrings.js\");\n  expect(CFFEncodingMap).toBeUndefined();\n  expect(CFFDictDataMap).toBeUndefined();\n  expect(CFFDictPrivateDataMap).toBeUndefined();\n});",
    "i3_gpt-4o": "it(\"should not have CFF related globals after patch\", async () => {\n  const { CFFParser } = await import(\"../../src/core/cff_parser.js\");\n  const globalsBefore = Object.keys(globalThis);\n  new CFFParser(); // Trigger any potential global pollution\n  const globalsAfter = Object.keys(globalThis);\n  const newGlobals = globalsAfter.filter(g => !globalsBefore.includes(g));\n  expect(newGlobals).not.toContain(\"CFFDictDataMap\");\n  expect(newGlobals).not.toContain(\"CFFDictPrivateDataMap\");\n  expect(newGlobals).not.toContain(\"CFFEncodingMap\");\n});",
    "i3_llama-3.3-70b-versatile": "it(\"should not throw an error when code scanning alerts are fixed\", async () => {\n  const { CFFEncodingMap, CFFDictDataMap, CFFDictPrivateDataMap } = await import(\"../../src/shared/cffStandardStrings.js\");\n  const { readCharset, readCharstringEncoding, readFontDictData, readFontIndexData, Type2Parser, writeToFile } = await import(\"../../src/shared/fonts_utils.js\");\n  const parser = new Type2Parser();\n  const stream = new (await import(\"../../src/core/stream.js\")).Stream(new Uint8Array());\n  expect(() => parser.parse(stream)).not.toThrow();\n});",
    "i4_deepseek-r1-distill-llama-70b": "it(\"should remove unused CFF debugging code\", async () => {\n  const { default: fs } = await import('fs/promises');\n  const cffStandardStringsPath = require.resolve('../../src/shared/cffStandardStrings.js');\n  const fontsUtilsPath = require.resolve('../../src/shared/fonts_utils.js');\n\n  async function fileExists(filePath) {\n    try {\n      await fs.access(filePath);\n      return true;\n    } catch {\n      return false;\n    }\n  }\n\n  const cffStandardStringsExists = await fileExists(cffStandardStringsPath);\n  const fontsUtilsExists = await fileExists(fontsUtilsPath);\n\n  expect(cffStandardStringsExists).toBe(false);\n  expect(fontsUtilsExists).toBe(false);\n});",
    "i4_gpt-4o": "it(\"should not find CFF related functions after patch\", async () => {\n  try {\n    const { readCharset, readCharstringEncoding, readFontDictData, readFontIndexData, Type2Parser, writeToFile } = await import(\"../../src/shared/fonts_utils.js\");\n    throw new Error(\"CFF related functions should not be found\");\n  } catch (error) {\n    expect(error.message).toBe(\"Cannot find module '../../src/shared/fonts_utils.js'\");\n  }\n});",
    "i4_llama-3.3-70b-versatile": "it(\"should not throw an error when parsing a CFF file\", async () => {\n  const { CFFParser } = await import(\"../../src/core/cff_parser.js\");\n  const parser = new CFFParser();\n  const cffFile = new Uint8Array([/* sample CFF file data */]);\n  const stream = new (await import(\"../../src/core/stream.js\")).Stream(cffFile);\n  await expect(parser.parse(stream)).resolves.not.toThrow();\n});",
    "i5_deepseek-r1-distill-llama-70b": "it(\"should remove unused CFF debugging code\", async () => {\n  try {\n    const { CFFEncodingMap } = await import(\"../../src/shared/cffStandardStrings.js\");\n    throw new Error(\"Expected import to fail\");\n  } catch (error) {\n    if (error instanceof Error && error.message !== \"Cannot find module\") {\n      throw error;\n    }\n  }\n});",
    "i5_gpt-4o": "it(\"should not have CFF related functions available\", async () => {\n  try {\n    const { CFFParser } = await import(\"../../src/core/cff_parser.js\");\n    const parser = new CFFParser();\n    const result = parser.parse();\n    expect(result).toBeUndefined();\n  } catch (error) {\n    expect(error.message).toMatch(/Cannot find module/);\n  }\n});",
    "i5_llama-3.3-70b-versatile": "it(\"should remove unused debugging code\", async () => {\n  const { Util } = await import(\"../../src/shared/util.js\");\n  const { readFileSync } = await import('fs');\n  const fileContentBeforePatch = readFileSync('src/shared/cffStandardStrings.js', 'utf8');\n  const fileContentAfterPatch = '';\n  const expected = fileContentAfterPatch;\n  const actual = fileContentBeforePatch;\n  Util.shadow(actual, expected);\n});"
  },
  "17159": {
    "i1_deepseek-r1-distill-llama-70b": "it(\"should correctly reflect radio button state in print view\", async () => {\n  const { getDocument } = await import('../../src/display/api.js');\n  const { buildGetDocumentParams } = await import('./test_utils.js');\n  const loadingTask = getDocument(buildGetDocumentParams('bug1860602.pdf'));\n\n  const { doc, annotations } = await loadingTask;\n  const page = await doc.getPage(1);\n  const annots = await page.getAnnotations();\n\n  const radioButtonAnnotation = annots.find(annotation => {\n    return annotation instanceof ButtonWidgetAnnotation &&\n           annotation.data.radioButton &&\n           !annotation.data.checkBox &&\n           !annotation.data.pushButton;\n  });\n\n  expect(radioButtonAnnotation.data.buttonValue).toBeTruthy();\n  expect(radioButtonAnnotation.data.fieldValue).toBeTruthy();\n});",
    "i1_gpt-4o": "it(\"should reflect the correct state of radio buttons in print view on the PDF form\", async () => {\n  const { getDocument } = await import(\"../../src/display/api.js\");\n  const { buildGetDocumentParams } = await import(\"./test_utils.js\");\n  const loadingTask = getDocument(buildGetDocumentParams(\"bug1860602.pdf\"));\n  const pdfDocument = await loadingTask.promise;\n  const page = await pdfDocument.getPage(1);\n  const annotations = await page.getAnnotations();\n\n  const radioButton = annotations.find(\n    annotation => annotation.fieldType === \"Btn\" && annotation.radioButton\n  );\n\n  const expectedFieldValue = \"Yes\"; // Assuming \"Yes\" is the expected value for the test\n  const actualFieldValue = radioButton.fieldValue;\n\n  expect(actualFieldValue).toEqual(expectedFieldValue);\n});",
    "i1_llama-3.3-70b-versatile": "it(\"should correctly reflect radio button state in print view\", async () => {\n  const { getDocument } = await import('../../src/display/api.js');\n  const { buildGetDocumentParams } = await import('./test_utils.js');\n  const loadingTask = getDocument(buildGetDocumentParams('bug1860602.pdf'));\n  const pdfDocument = await loadingTask.promise;\n  const pageNumber = 1;\n  const page = await pdfDocument.getPage(pageNumber);\n  const annotations = await page.getAnnotations();\n  const radioButtons = annotations.filter(annotation => annotation.subtype === 'Widget' && annotation.fieldFlags === 4096);\n  const expectedState = 'On';\n  const actualState = radioButtons[0].buttonValue;\n  expect(actualState).toBe(expectedState);\n});",
    "i2_deepseek-r1-distill-llama-70b": "it(\"should correctly reflect radio button state in print view\", async () => {\n  const { getDocument } = await import('../../src/display/api.js');\n  const { buildGetDocumentParams } = await import('./test_utils.js');\n  const loadingTask = getDocument(buildGetDocumentParams('bug1860602.pdf'));\n  const pdf = await loadingTask.promise;\n  const page = await pdf.getPage(1);\n  const annotations = await page.getAnnotations();\n  const buttonAnnotation = annotations.find(annotation => annotation instanceof ButtonWidgetAnnotation);\n  expect(buttonAnnotation.data.fieldValue).toBeTruthy();\n});",
    "i2_gpt-4o": "it(\"should reflect the correct state of radio buttons in print view on the PDF form\", async () => {\n  const { getDocument } = await import('../../src/display/api.js');\n  const { buildGetDocumentParams } = await import('./test_utils.js');\n  const loadingTask = getDocument(buildGetDocumentParams('bug1860602.pdf'));\n  const pdfDocument = await loadingTask.promise;\n  const page = await pdfDocument.getPage(1);\n  const annotations = await page.getAnnotations();\n\n  const radioButton = annotations.find(ann => ann.fieldType === 'Btn' && ann.radioButton);\n  const expectedFieldValue = radioButton.fieldValue;\n  const expectedButtonValue = radioButton.buttonValue;\n\n  const actualFieldValue = radioButton.fieldValue;\n  const actualButtonValue = radioButton.buttonValue;\n\n  expect(actualFieldValue).toEqual(expectedFieldValue);\n  expect(actualButtonValue).toEqual(expectedButtonValue);\n});",
    "i2_llama-3.3-70b-versatile": "it(\"should correctly reflect radio button state in print view\", async () => {\n  const { getDocument } = await import('../../src/display/api.js');\n  const { buildGetDocumentParams } = await import('./test_utils.js');\n  const loadingTask = getDocument(buildGetDocumentParams('bug1860602.pdf'));\n  const pdfDocument = await loadingTask.promise;\n  const annotation = pdfDocument.getAnnotations(0).find(annotation => annotation instanceof ButtonWidgetAnnotation && annotation.data.radioButton);\n  const fieldValue = annotation.data.fieldValue;\n  const buttonValue = annotation.data.buttonValue;\n  expect(fieldValue).toBe(buttonValue);\n});",
    "i3_deepseek-r1-distill-llama-70b": "it(\"should correctly reflect radio button state in print view\", async () => {\n  const { getDocument } = await import('../../src/display/api.js');\n  const { buildGetDocumentParams } = await import('./test_utils.js');\n  const loadingTask = getDocument(buildGetDocumentParams('bug1860602.pdf'));\n\n  const pdfDocument = await loadingTask;\n  const pageIndex = 0;\n  const page = await pdfDocument.getPage(pageIndex);\n  const annotator = page.getAnnotations();\n  const annotations = await annotator.getAnnotations();\n\n  const annotation = annotations.find(annot => annot instanceof Annotation);\n  const buttonAnnotation = new ButtonWidgetAnnotation({\n    dict: annotation.dict,\n    xref: new XRefMock(),\n    annotationGlobals: {},\n    id: createIdFactory(),\n    collectFields: true,\n    pageRef: new Ref(0)\n  });\n\n  assert.equal(buttonAnnotation.data.fieldValue, null);\n  assert.equal(buttonAnnotation.data.buttonValue, \"Yes\");\n});",
    "i3_gpt-4o": "it(\"should reflect the correct state of radio buttons in print view on the PDF form\", async () => {\n  const { getDocument } = await import(\"../../src/display/api.js\");\n  const { buildGetDocumentParams } = await import(\"./test_utils.js\");\n  const loadingTask = getDocument(buildGetDocumentParams(\"bug1860602.pdf\"));\n  const pdfDocument = await loadingTask.promise;\n  const page = await pdfDocument.getPage(1);\n  const annotations = await page.getAnnotations();\n\n  const radioButton = annotations.find(\n    annotation => annotation.subtype === \"Widget\" && annotation.fieldType === \"Btn\" && annotation.radioButton\n  );\n\n  const expectedFieldValue = radioButton.buttonValue;\n  const actualFieldValue = radioButton.fieldValue;\n\n  expect(actualFieldValue).toEqual(expectedFieldValue);\n});",
    "i3_llama-3.3-70b-versatile": "it(\"should correctly reflect the state of radio buttons in print view\", async () => {\n  const { getDocument } = await import('../../src/display/api.js');\n  const { buildGetDocumentParams } = await import('./test_utils.js');\n  const loadingTask = getDocument(buildGetDocumentParams('bug1860602.pdf'));\n  const pdfDocument = await loadingTask.promise;\n  const annotationFactory = new AnnotationFactory();\n  const page = await pdfDocument.getPage(1);\n  const annotations = await page.getAnnotations();\n  const annotation = annotations[0];\n  const widgetAnnotation = await annotationFactory.create(\n    pdfDocument.xref,\n    annotation,\n    {\n      pdfManager: pdfDocument,\n      acroForm: pdfDocument.catalog.get(\"acroForm\"),\n      xfaDatasets: null,\n      structTreeRoot: null,\n      baseUrl: null,\n      attachments: null,\n    },\n    createIdFactory(),\n    true\n  );\n  expect(widgetAnnotation.data.fieldValue).not.toBeNull();\n});",
    "i4_deepseek-r1-distill-llama-70b": "it(\"should correctly reflect radio button state in print view\", async () => {\n  const { getDocument } = await import('../../src/display/api.js');\n  const { buildGetDocumentParams } = await import('./test_utils.js');\n  const loadingTask = getDocument(buildGetDocumentParams('bug1860602.pdf'));\n\n  const pdfDocument = await loadingTask;\n  const page = await pdfDocument.getPage(0);\n  const annotations = await page.getAnnotations();\n\n  let radioAnnotation;\n  for (const annotation of annotations) {\n    const { subtype, fieldType } = annotation.data;\n    if (subtype === 'Widget' && fieldType === 'Ch') {\n      radioAnnotation = annotation;\n      break;\n    }\n  }\n\n  const expectedValue = radioAnnotation.data.fieldValue;\n  const actualValue = radioAnnotation.data.buttonValue;\n\n  expect(expectedValue).toBe(actualValue);\n});",
    "i4_gpt-4o": "it(\"should reflect the correct state of radio buttons in print view on the PDF form\", async () => {\n  const { getDocument } = await import(\"../../src/display/api.js\");\n  const { buildGetDocumentParams } = await import(\"./test_utils.js\");\n  const loadingTask = getDocument(buildGetDocumentParams(\"bug1860602.pdf\"));\n  const pdfDocument = await loadingTask.promise;\n  const page = await pdfDocument.getPage(1);\n  const annotations = await page.getAnnotations();\n\n  const radioButton = annotations.find(\n    (annotation) => annotation.subtype === \"Widget\" && annotation.fieldType === \"Btn\" && annotation.radioButton\n  );\n\n  const expectedFieldValue = radioButton.buttonValue;\n  const actualFieldValue = radioButton.fieldValue;\n\n  expect(actualFieldValue).toBe(expectedFieldValue);\n});",
    "i5_deepseek-r1-distill-llama-70b": "it(\"should correctly reflect radio button state in print view\", async () => {\n  const { getDocument } = await import('../../src/display/api.js');\n  const { buildGetDocumentParams } = await import('./test_utils.js');\n  const loadingTask = getDocument(buildGetDocumentParams('bug1860602.pdf'));\n  const pdfDocument = await loadingTask.promise;\n  const page = await pdfDocument.getPage(1);\n  const annotations = await page.getAnnotations();\n  const annotation = annotations[0];\n  const widget = annotation.getWidget();\n  const expectedValue = 'On';\n  const actualValue = widget.data.fieldValue;\n  expect(actualValue).toBe(expectedValue);\n});",
    "i5_gpt-4o": "it(\"should reflect the correct state of radio buttons in print view on the PDF form\", async () => {\n  const { getDocument } = await import('../../src/display/api.js');\n  const { buildGetDocumentParams } = await import('./test_utils.js');\n  const loadingTask = getDocument(buildGetDocumentParams('bug1860602.pdf'));\n  const pdfDocument = await loadingTask.promise;\n  const page = await pdfDocument.getPage(1);\n  const annotations = await page.getAnnotations();\n\n  const radioButton = annotations.find(annotation => annotation.fieldType === 'RadioButton');\n  const expectedValue = radioButton.fieldValue;\n\n  const { AnnotationStorage } = await import('../../src/display/annotation_storage.js');\n  const annotationStorage = new AnnotationStorage();\n  const actualValue = annotationStorage.getValue(radioButton.id).value;\n\n  expect(actualValue).toEqual(expectedValue);\n});",
    "i5_llama-3.3-70b-versatile": "it(\"should correctly reflect radio button state in print view\", async () => {\n  const { getDocument } = await import('../../src/display/api.js');\n  const { buildGetDocumentParams } = await import('./test_utils.js');\n  const loadingTask = getDocument(buildGetDocumentParams('bug1860602.pdf'));\n  const pdfDoc = await loadingTask.promise;\n  const pageNumber = 1;\n  const page = await pdfDoc.getPage(pageNumber);\n  const annotations = await page.getAnnotations();\n  const radioButtons = annotations.filter(annotation => annotation.subtype === 'Widget' && annotation.fieldName.includes('Radio'));\n  const expectedStates = ['On', 'Off']; // Define the expected states of the radio buttons\n  const actualStates = await Promise.all(radioButtons.map(async radioButton => {\n    const widgetAnnotation = await radioButton.getWidgetAnnotation();\n    return widgetAnnotation.data.buttonValue;\n  }));\n  expectedStates.forEach((state, index) => {\n    if (actualStates[index] !== state) {\n      throw new Error(`Radio button ${index} state does not match expected state`);\n    }\n  });\n});"
  },
  "17403": {
    "i1_deepseek-r1-distill-llama-70b": "it(\"should handle multiple messages without blocking\", async () => {\n  const port = new LoopbackPort();\n  const messageHandler = new MessageHandler(\"source\", \"target\", port);\n\n  let counter = 0;\n  let done = false;\n\n  function simpleAction(data) {\n    return data;\n  }\n\n  messageHandler.on(\"testAction\", simpleAction);\n\n  const results = [];\n\n  // Create 50 promises to simulate a lot of messages\n  const promises = Array.from({ length: 50 }).map(async (_, i) => {\n    const result = await new Promise((resolve, reject) => {\n      port.postMessage({\n        targetName: \"source\",\n        sourceName: \"target\",\n        action: \"testAction\",\n        data: { id: i },\n        callbackId: i,\n        callback: 1\n      });\n    });\n    results.push(result);\n    counter++;\n\n    if (counter === 50) {\n      done = true;\n    }\n  });\n\n  await Promise.all(promises);\n  await new Promise(resolve => resolve(done));\n\n  expect(counter).toBe(50);\n});",
    "i1_llama-3.3-70b-versatile": "it(\"should render a PDF with many pages without slowing down\", async () => {\n  const { MessageHandler, LoopbackPort } = await import(\"../../src/shared/message_handler.js\");\n  const { PDFWorkerUtil } = await import(\"../../src/display/api.js\");\n  const port = new LoopbackPort();\n  const messageHandler = new MessageHandler(\"test\", \"test\", port);\n  const largePdfData = new Uint8Array(1024 * 1024); // simulate a large PDF\n  const pdfWorkerUtil = new PDFWorkerUtil(port);\n  const renderPromise = pdfWorkerUtil.renderPdf(largePdfData);\n  const startTime = Date.now();\n  await renderPromise;\n  const endTime = Date.now();\n  const renderTime = endTime - startTime;\n  const expectedRenderTime = 5000; // adjust this value based on your system's performance\n  expect(renderTime).toBeLessThan(expectedRenderTime);\n});",
    "i2_deepseek-r1-distill-llama-70b": "it(\"should skip cancelled tasks in worker\", async () => {\n  const { MessageHandler } = await import(\"../../src/shared/message_handler.js\");\n  const mockComObj = {\n    addEventListener: jest.fn(),\n    postMessage: jest.fn(),\n  };\n\n  const handler = new MessageHandler(\"test-source\", \"test-target\", mockComObj);\n\n  const messages = [\n    { action: \"renderPage\", data: { page: 1 } },\n    { action: \"renderPage\", data: { page: 2 }, stream: StreamKind.CANCEL, streamId: \"cancel1\" },\n    { action: \"renderPage\", data: { page: 3 } },\n  ];\n\n  let callbackCount = 0;\n  const expectedData = { pagesRendered: 2 };\n\n  await new Promise(resolve => {\n    mockComObj.addEventListener.mock.calls[0][1]({\n      data: messages[0],\n    });\n    mockComObj.addEventListener.mock.calls[0][1]({\n      data: messages[1],\n    });\n    mockComObj.addEventListener.mock.calls[0][1]({\n      data: messages[2],\n    });\n\n    handler.actionHandler.renderPage = jest.fn((data) => {\n      callbackCount++;\n      return Promise.resolve(expectedData);\n    });\n\n    const check = () => {\n      expect(callbackCount).toBe(2);\n      expect(mockComObj.postMessage).toHaveBeenCalledWith(\n        expect.objectContaining({ data: expectedData })\n      );\n      resolve();\n    };\n\n    setTimeout(check, 0);\n  });\n});",
    "i2_gpt-4o": "it(\"should skip cancelled tasks to improve rendering performance\", async () => {\n  const { MessageHandler } = await import(\"../../src/shared/message_handler.js\");\n  const { PDFDocumentProxy, getDocument } = await import(\"../../src/display/api.js\");\n\n  const pdfUrl = \"path/to/large/pdf\"; // Replace with a valid path to a large PDF\n  const loadingTask = getDocument(pdfUrl);\n  const pdfDocument = await loadingTask.promise;\n  const page = await pdfDocument.getPage(1);\n\n  const messageHandler = new MessageHandler(\"main\", \"worker\", {\n    addEventListener: (type, listener) => {\n      if (type === \"message\") {\n        setTimeout(() => {\n          listener({ data: { targetName: \"main\", action: \"GetOperatorList\", stream: 1 } });\n          listener({ data: { targetName: \"main\", action: \"GetOperatorList\", stream: 1, streamId: 1 } });\n          listener({ data: { targetName: \"main\", action: \"GetOperatorList\", stream: 1, streamId: 1, stream: 1 } });\n        }, 0);\n      }\n    },\n    postMessage: () => {}\n  });\n\n  const startTime = performance.now();\n  await page.getOperatorList();\n  const endTime = performance.now();\n\n  const executionTime = endTime - startTime;\n  const expectedMaxTime = 1000; // Expected max time in ms for improved performance\n\n  expect(executionTime).toBeLessThan(expectedMaxTime);\n});",
    "i2_llama-3.3-70b-versatile": "it(\"should skip useless tasks in the worker to improve fast scrolling with scanned books\", async () => {\n  const { MessageHandler } = await import(\"../../src/shared/message_handler.js\");\n  const { PDFWorkerUtil } = await import(\"../../src/display/api.js\");\n  const { PDFDocumentLoadingTask } = await import(\"../../src/display/api.js\");\n\n  const comObj = {\n    addEventListener: jest.fn(),\n    postMessage: jest.fn(),\n  };\n\n  const messageHandler = new MessageHandler(\"source\", \"target\", comObj);\n  const actionHandler = {\n    renderPage: jest.fn(() => Promise.resolve()),\n  };\n  messageHandler.actionHandler = actionHandler;\n\n  const data = {\n    targetName: \"source\",\n    action: \"renderPage\",\n    data: {},\n    streamId: 1,\n  };\n\n  const cancelData = {\n    targetName: \"source\",\n    stream: \"CANCEL\",\n    streamId: 1,\n  };\n\n  messageHandler._onComObjOnMessage({ data: data });\n  messageHandler._onComObjOnMessage({ data: cancelData });\n\n  expect(actionHandler.renderPage).not.toHaveBeenCalled();\n});",
    "i3_deepseek-r1-distill-llama-70b": "it(\"should handle many messages efficiently\", async () => {\n  const { LoopbackPort } = await import(\"../../src/display/api.js\");\n  const port = new LoopbackPort();\n  const messageHandler = new MessageHandler(\"source\", \"target\", port);\n  const results = [];\n\n  messageHandler.on(\"testAction\", () => ({\n    data: \"Test data\",\n  }));\n\n  const promises = [];\n  for (let i = 0; i < 1000; i++) {\n    const promise = messageHandler.sendWithPromise(\"testAction\", {\n      id: i,\n    });\n    promises.push(promise);\n  }\n\n  const startTime = Date.now();\n  await Promise.all(promises);\n  const endTime = Date.now();\n\n  expect(promises.length).toBe(1000);\n  expect(endTime - startTime).toBeLessThan(500);\n});",
    "i3_llama-3.3-70b-versatile": "it(\"should render a PDF with many pages without slowing down\", async () => {\n  const { PDFWorker } = await import(\"../../src/display/api.js\");\n  const { MessageHandler } = await import(\"../../src/shared/message_handler.js\");\n  const worker = new PDFWorker();\n  const messageHandler = new MessageHandler(\"test\", \"test\", worker);\n  const largePdf = new Array(1000).fill(0).map(() => ({ action: \"testAction\" }));\n  const startTime = Date.now();\n  for (const data of largePdf) {\n    messageHandler._onComObjOnMessage({ data });\n  }\n  const endTime = Date.now();\n  const renderTime = endTime - startTime;\n  expect(renderTime).toBeLessThan(1000);\n});",
    "i4_deepseek-r1-distill-llama-70b": "it(\"should improve rendering performance with multiple pages\", async () => {\n  const { MessageHandler, ...util } = await import(\"../../src/shared/message_handler.js\");\n  const { assert } = await import(\"chai\");\n\n  const comObj = {\n    postMessage: () => {},\n    addEventListener: () => {},\n    removeEventListener: () => {}\n  };\n\n  const messageHandler = new MessageHandler(\"source\", \"target\", comObj);\n  const actionResults = [];\n  const startTime = Date.now();\n  const NUM_MESSAGES = 100;\n\n  messageHandler.on(\"testAction\", () => {\n    actionResults.push(Date.now() - startTime);\n    return Promise.resolve();\n  });\n\n  for (let i = 0; i < NUM_MESSAGES; i++) {\n    await messageHandler.sendWithPromise(\"testAction\", {});\n  }\n\n  const processingTime = Date.now() - startTime;\n  assert.isBelow(processingTime, 500);\n});",
    "i4_llama-3.3-70b-versatile": "it(\"should render a PDF with many pages without slowing down\", async () => {\n  const { PDFDocument } = await import(\"../../src/core/document.js\");\n  const { MessageHandler } = await import(\"../../src/shared/message_handler.js\");\n  const { PDFWorker } = await import(\"../../src/display/api.js\");\n\n  const pdfWorker = new PDFWorker();\n  const messageHandler = new MessageHandler(\"test\", \"test\", pdfWorker);\n\n  const pdfDoc = await PDFDocument.load(await (await import(\"../../src/display/fetch_stream.js\")).PDFFetchStream.fetch(\"path_to_large_pdf_file.pdf\"));\n  const numPages = pdfDoc.numPages;\n\n  let pagesRendered = 0;\n  for (let i = 1; i <= numPages; i++) {\n    const page = await pdfDoc.getPage(i);\n    await page.render({ canvasContext: null, viewport: null });\n    pagesRendered++;\n  }\n\n  expect(pagesRendered).toBe(numPages);\n});",
    "i5_deepseek-r1-distill-llama-70b": "it(\"should improve rendering performance for PDFs with many pages\", async () => {\n  const { PDFDocument } = await import(\"../../src/core/document.js\");\n  const { PDFDocumentProxy } = await import(\"../../src/display/api.js\");\n  const { PDFPage } = await import(\"../../src/core/document.js\");\n\n  // Create a test PDF with 1000 pages\n  const pdf = new PDFDocument();\n  for (let i = 0; i < 1000; i++) {\n    const page = pdf.addPage();\n    const graphics = page.getGraphics();\n    graphics.rect(0, 0, 100, 100);\n    graphics.fill();\n  }\n\n  // Load the PDF through the proxy\n  const proxy = new PDFDocumentProxy({\n    getDocument: () => Promise.resolve(pdf),\n    getMetadata: () => Promise.resolve({}),\n  });\n\n  // Measure rendering time\n  const startTime = Date.now();\n  const pagesRendered = new Promise(resolve => {\n    let count = 0;\n    const interval = setInterval(() => {\n      count++;\n      if (count >= 1000) {\n        clearInterval(interval);\n        resolve();\n      }\n    }, 1);\n  });\n\n  // Simulate page rendering\n  for (let i = 0; i < 1000; i++) {\n    const page = await proxy.getPage(i + 1);\n    await page.render();\n  }\n\n  await pagesRendered;\n  const endTime = Date.now();\n  const renderTime = endTime - startTime;\n\n  // The expected maximum rendering time in milliseconds\n  const expectedMaxTime = 1000;\n  expect(renderTime).toBeLessThan(expectedMaxTime);\n});",
    "i5_gpt-4o": "it(\"should render a PDF with many pages faster after the patch\", async () => {\n  const { PDFDocumentProxy, getDocument } = await import(\"../../src/display/api.js\");\n  const { PDFNetworkStream } = await import(\"../../src/display/network.js\");\n  const { PDFPageView } = await import(\"../../web/pdf_page_view.js\");\n  const { RenderingStates } = await import(\"../../web/ui_utils.js\");\n\n  const url = \"path/to/large/pdf\"; // Replace with the path to a large PDF file\n  const loadingTask = getDocument(url);\n  const pdfDocument = await loadingTask.promise;\n\n  const page = await pdfDocument.getPage(1);\n  const viewport = page.getViewport({ scale: 1.0 });\n\n  const container = document.createElement(\"div\");\n  const pdfPageView = new PDFPageView({\n    container,\n    id: 1,\n    scale: 1.0,\n    defaultViewport: viewport,\n    renderingQueue: null,\n    textLayerFactory: null,\n    annotationLayerFactory: null,\n  });\n\n  pdfPageView.setPdfPage(page);\n\n  const startTime = performance.now();\n  await pdfPageView.draw();\n  const endTime = performance.now();\n\n  const renderTime = endTime - startTime;\n  const expectedMaxRenderTime = 5000; // 5 seconds\n\n  expect(renderTime).toBeLessThan(expectedMaxRenderTime);\n  expect(pdfPageView.renderingState).toBe(RenderingStates.FINISHED);\n});",
    "i5_llama-3.3-70b-versatile": "it(\"should render a PDF with many pages without slowing down\", async () => {\n  const { PDFDocument, PDFPageProxy } = await import(\"../../src/display/api.js\");\n  const { PDFFetchStream } = await import(\"../../src/display/fetch_stream.js\");\n  const { MessageHandler } = await import(\"../../src/shared/message_handler.js\");\n\n  const pdfUrl = \"./test.pdf\";\n  const pdfStream = new PDFFetchStream(pdfUrl);\n  const pdfDocument = await PDFDocument.load({ cMapUrl: \"./cmap\", cMapPacked: true, pdf: pdfStream });\n  const messageHandler = new MessageHandler(\"test\", \"test\", { postMessage: () => {} });\n\n  const startTime = Date.now();\n  for (let i = 0; i < pdfDocument.numPages; i++) {\n    const page = await pdfDocument.getPage(i + 1);\n    await page.render({ canvasContext: null, viewport: null });\n  }\n  const endTime = Date.now();\n\n  const renderTime = endTime - startTime;\n  const expectedRenderTime = 5000; // 5 seconds\n\n  expect(renderTime).toBeLessThan(expectedRenderTime);\n});"
  },
  "17475": {
    "i1_deepseek-r1-distill-llama-70b": "it(\"should correctly calculate highlight coordinates for cropped PDFs\", async () => {\n  const { getDocument } = await import(\"../../src/display/api.js\");\n  const { buildGetDocumentParams } = await import(\"./test_utils.js\");\n  const loadingTask = getDocument(buildGetDocumentParams('bug1872721.pdf'));\n\n  const pdf = await loadingTask.promise;\n  const page = await pdf.getPage(1);\n  const editor = new (await import(\"../../src/display/editor/highlight.js\")).HighlightEditor({\n    color: \"#fff066\",\n    opacity: 1,\n    pageIndex: 0,\n    page,\n    uiManager: new (await import(\"../../src/display/editor/tools.js\")).AnnotationEditorUIManager(),\n  });\n\n  const data = editor.serialize();\n  const quadPoints = data.quadPoints;\n\n  // Verify that the quadPoints are within the expected range for a cropped PDF\n  const [minX, maxX] = [Math.min(...quadPoints.filter((_, i) => i % 2 === 0)),\n    Math.max(...quadPoints.filter((_, i) => i % 2 === 0))];\n  const [minY, maxY] = [Math.min(...quadPoints.filter((_, i) => i % 2 === 1)),\n    Math.max(...quadPoints.filter((_, i) => i % 2 === 1))];\n\n  // The expected values should be adjusted based on the actual cropped PDF dimensions\n  // For this test, assume the cropped area has certain known dimensions\n  const expectedMinX = 100;\n  const expectedMaxX = 300;\n  const expectedMinY = 100;\n  const expectedMaxY = 300;\n\n  assert.between(minX, expectedMinX - 10, expectedMinX + 10);\n  assert.between(maxX, expectedMaxX - 10, expectedMaxX + 10);\n  assert.between(minY, expectedMinY - 10, expectedMinY + 10);\n  assert.between(maxY, expectedMaxY - 10, expectedMaxY + 10);\n});",
    "i1_gpt-4o": "it(\"should correctly render highlights on cropped PDF when savingprinting\", async () => {\n  const { getDocument } = await import(\"../../src/display/api.js\");\n  const { buildGetDocumentParams } = await import(\"./test_utils.js\");\n  const loadingTask = getDocument(buildGetDocumentParams(\"bug1872721.pdf\"));\n  const pdfDocument = await loadingTask.promise;\n  const page = await pdfDocument.getPage(1);\n  const { AnnotationEditorLayer } = await import(\"../../src/display/editor/annotation_editor_layer.js\");\n  const { AnnotationEditorUIManager } = await import(\"../../src/display/editor/tools.js\");\n\n  const uiManager = new AnnotationEditorUIManager();\n  const editorLayer = new AnnotationEditorLayer({\n    uiManager,\n    pageIndex: 0,\n    viewport: page.getViewport({ scale: 1.0 }),\n  });\n\n  await editorLayer.render(page);\n\n  const highlightAnnotations = editorLayer.getAnnotations().filter(\n    (annotation) => annotation.annotationType === AnnotationEditorType.HIGHLIGHT\n  );\n\n  const expectedHighlightCount = 1; // Assuming there should be one highlight\n  const actualHighlightCount = highlightAnnotations.length;\n\n  expect(actualHighlightCount).toBe(expectedHighlightCount);\n});",
    "i1_llama-3.3-70b-versatile": "it(\"should display highlight on cropped pdf when savingprinting\", async () => {\n  const { getDocument } = await import('../../src/display/api.js');\n  const { buildGetDocumentParams } = await import('./test_utils.js');\n  const loadingTask = getDocument(buildGetDocumentParams('bug1872721.pdf'));\n  const pdfDoc = await loadingTask.promise;\n  const pdfPage = pdfDoc.getPage(1);\n  const { AnnotationEditor } = await import(\"../../src/display/editor/editor.js\");\n  const { AnnotationEditorUIManager } = await import(\"../../src/display/editor/tools.js\");\n  const { Util } = await import(\"../../shared/util.js\");\n  const annotationEditor = new AnnotationEditor({\n    annotationType: AnnotationEditor.AnnotationEditorType.HIGHLIGHT,\n    pageIndex: 0,\n    page: pdfPage,\n  }, new AnnotationEditorUIManager());\n  const highlightEditor = new annotationEditor.constructor({\n    annotationType: annotationEditor.constructor.AnnotationEditorType.HIGHLIGHT,\n    pageIndex: 0,\n    page: pdfPage,\n    boxes: [{ x: 0.1, y: 0.1, width: 0.2, height: 0.2 }],\n  }, new AnnotationEditorUIManager());\n  const serializedData = highlightEditor.serialize();\n  const deserializedEditor = annotationEditor.constructor.deserialize(serializedData, pdfPage, new AnnotationEditorUIManager());\n  const expectedQuadPoints = serializedData.quadPoints;\n  const actualQuadPoints = deserializedEditor.serialize().quadPoints;\n  expect(actualQuadPoints).toEqual(expectedQuadPoints);\n});",
    "i2_deepseek-r1-distill-llama-70b": "it(\"should correctly serialize highlight annotations within the crop box\", async () => {\n  const { getDocument } = await import(\"../../src/display/api.js\");\n  const { buildGetDocumentParams } = await import(\"./test_utils.js\");\n  const loadingTask = getDocument(buildGetDocumentParams('bug1872721.pdf'));\n  const pdf = await loadingTask.promise;\n  const page = await pdf.getPage(1);\n  const { AnnotationEditor } = await import(\"../../src/display/editor/editor.js\");\n  const { AnnotationEditorType } = await import(\"../../src/shared/util.js\");\n\n  const editor = new AnnotationEditor({\n    annotationType: AnnotationEditorType.HIGHLIGHT,\n    color: \"#fff066\",\n    opacity: 1,\n    pageIndex: 0,\n    page,\n  });\n\n  editor.#boxes = [{ x: 0.1, y: 0.1, width: 0.2, height: 0.2 }];\n  editor.width = 0.3;\n  editor.height = 0.3;\n  editor.x = 0.1;\n  editor.y = 0.1;\n\n  const data = editor.serialize();\n  const expectedQuadPoints = [100, 100, 200, 200, 300, 300, 400, 400]; // Replace with actual expected values\n  const expectedOutlines = [[100, 100, 200, 200]]; // Replace with actual expected values\n\n  expect(data.quadPoints).toEqual(expectedQuadPoints);\n  expect(data.outlines).toEqual(expectedOutlines);\n});",
    "i2_gpt-4o": "it(\"should correctly render highlights on cropped PDF when savingprinting\", async () => {\n  const { getDocument } = await import('../../src/display/api.js');\n  const { buildGetDocumentParams } = await import('./test_utils.js');\n  const loadingTask = getDocument(buildGetDocumentParams('bug1872721.pdf'));\n  const pdfDocument = await loadingTask.promise;\n  const page = await pdfDocument.getPage(1);\n  const annotations = await page.getAnnotations();\n\n  const highlightAnnotation = annotations.find(ann => ann.subtype === 'Highlight');\n  const expectedQuadPoints = [/* expected quad points after patch */];\n\n  const actualQuadPoints = highlightAnnotation.quadPoints;\n\n  expect(actualQuadPoints).toEqual(expectedQuadPoints);\n});",
    "i2_llama-3.3-70b-versatile": "it(\"should highlight text correctly when savingprinting after applying the patch\", async () => {\n  const { getDocument } = await import('../../src/display/api.js');\n  const { buildGetDocumentParams } = await import('./test_utils.js');\n  const { PDFPageProxy } = await import('../../src/display/api.js');\n  const { AnnotationEditor } = await import('./editor.js');\n  const { HighlightEditor } = await import('./highlight.js');\n  const loadingTask = getDocument(buildGetDocumentParams('bug1872721.pdf'));\n  const pdfDocument = await loadingTask.promise;\n  const pdfPage = await pdfDocument.getPage(1);\n  const annotationEditor = new AnnotationEditor({ page: pdfPage });\n  const highlightEditor = new HighlightEditor({ page: pdfPage, color: 'yellow' });\n  const quadPoints = highlightEditor.serialize().quadPoints;\n  const expectedQuadPoints = [10, 700, 50, 700, 50, 750, 10, 750];\n  expect(quadPoints).toEqual(expectedQuadPoints);\n});",
    "i3_deepseek-r1-distill-llama-70b": "it(\"should correctly serialize and deserialize highlight on cropped pdf\", async () => {\n  const { getDocument } = await import(\"../../src/display/api.js\");\n  const { buildGetDocumentParams } = await import(\"./test_utils.js\");\n  const loadingTask = getDocument(buildGetDocumentParams('bug1872721.pdf'));\n  const pdfDocument = await loadingTask.promise;\n  const pdfPage = await pdfDocument.getPage(1);\n\n  // Create highlight annotation\n  const highlight = new (await import(\"../../src/display/editor/highlight.js\")).HighlightEditor({\n    color: \"#fff066\",\n    opacity: 1,\n    boxes: [{ x: 0.1, y: 0.1, width: 0.2, height: 0.2 }],\n    pageIndex: 0,\n    page: pdfPage,\n    parent: null,\n    uiManager: null,\n  });\n\n  // Serialize the highlight\n  const serialized = highlight.serialize();\n\n  // Deserialize the highlight\n  const deserialized = HighlightEditor.deserialize(serialized, null, null);\n\n  // Verify the deserialized dimensions\n  expect(deserialized.width).toBeCloseTo(0.2);\n  expect(deserialized.height).toBeCloseTo(0.2);\n\n  await pdfDocument.close();\n});",
    "i3_gpt-4o": "it(\"should render highlights correctly on cropped PDF when savingprinting\", async () => {\n  const { getDocument } = await import(\"../../src/display/api.js\");\n  const { buildGetDocumentParams } = await import(\"./test_utils.js\");\n  const { AnnotationEditorLayer } = await import(\"../../src/display/editor/annotation_editor_layer.js\");\n  const loadingTask = getDocument(buildGetDocumentParams(\"bug1872721.pdf\"));\n  const pdfDocument = await loadingTask.promise;\n  const page = await pdfDocument.getPage(1);\n  const viewport = page.getViewport({ scale: 1.0 });\n  const annotationEditorLayer = new AnnotationEditorLayer({\n    viewport,\n    div: document.createElement(\"div\"),\n    uiManager: null,\n  });\n  await annotationEditorLayer.render(page);\n  const highlightAnnotations = annotationEditorLayer.div.querySelectorAll(\".highlightAnnotation\");\n  expect(highlightAnnotations.length).toBeGreaterThan(0);\n  highlightAnnotations.forEach(annotation => {\n    const rect = annotation.getBoundingClientRect();\n    expect(rect.width).toBeGreaterThan(0);\n    expect(rect.height).toBeGreaterThan(0);\n  });\n});",
    "i3_llama-3.3-70b-versatile": "it(\"should display highlight on cropped pdf when savingprinting\", async () => {\n  const { getDocument } = await import('../../src/display/api.js');\n  const { buildGetDocumentParams } = await import('./test_utils.js');\n  const loadingTask = getDocument(buildGetDocumentParams('bug1872721.pdf'));\n  const pdfDoc = await loadingTask.promise;\n  const pdfPage = await pdfDoc.getPage(1);\n  const { AnnotationEditor } = await import(\"../../src/display/editor/editor.js\");\n  const { HighlightEditor } = await import(\"../../src/display/editor/highlight.js\");\n  const { AnnotationEditorUIManager } = await import(\"../../src/display/editor/tools.js\");\n  const { DrawLayer } = await import(\"../../src/display/draw_layer.js\");\n  const uiManager = new AnnotationEditorUIManager();\n  const drawLayer = new DrawLayer();\n  const highlightEditor = new HighlightEditor({\n    pageIndex: 0,\n    page: pdfPage,\n    parent: drawLayer,\n    uiManager: uiManager,\n    boxes: [{ x: 0.1, y: 0.1, width: 0.2, height: 0.2 }],\n  });\n  const serializedData = highlightEditor.serialize();\n  const quadPoints = serializedData.quadPoints;\n  const outlines = serializedData.outlines;\n  const expectedQuadPoints = [10, 710, 10, 690, 30, 690, 30, 710];\n  const expectedOutlines = [[10, 690], [30, 690], [30, 710], [10, 710]];\n  expect(quadPoints).toEqual(expectedQuadPoints);\n  expect(outlines).toEqual(expectedOutlines);\n});",
    "i4_deepseek-r1-distill-llama-70b": "it(\"should correctly position highlights on cropped PDFs when serializeddeserialized\", async () => {\n  const { getDocument } = await import(\"../../src/display/api.js\");\n  const { buildGetDocumentParams } = await import(\"./test_utils.js\");\n  const loadingTask = getDocument(buildGetDocumentParams('bug1872721.pdf'));\n  const pdfDocument = await loadingTask.promise;\n  const pdfPage = await pdfDocument.getPage(1);\n  const canvas = document.createElement(\"canvas\");\n  const context = canvas.getContext(\"2d\");\n  await pdfPage.render({\n    canvasContext: context,\n    viewport: pdfPage.getViewport({ scale: 1 })\n  });\n\n  const highlight = new HighlightEditor({\n    color: \"#ff0000\",\n    opacity: 0.5,\n    width: 0.2,\n    height: 0.1,\n    x: 0.1,\n    y: 0.1,\n    pageIndex: 0\n  });\n\n  const serialized = highlight.serialize();\n  const deserialized = HighlightEditor.deserialize(serialized, null, null);\n\n  expect(deserialized.x).toBeCloseTo(0.1);\n  expect(deserialized.y).toBeCloseTo(0.1);\n});",
    "i4_gpt-4o": "it(\"should correctly render highlights on cropped PDF when savingprinting\", async () => {\n  const { getDocument } = await import('../../src/display/api.js');\n  const { buildGetDocumentParams } = await import('./test_utils.js');\n  const loadingTask = getDocument(buildGetDocumentParams('bug1872721.pdf'));\n  const pdfDocument = await loadingTask.promise;\n  const page = await pdfDocument.getPage(1);\n  const viewport = page.getViewport({ scale: 1.0 });\n  const { AnnotationLayer } = await import('../../src/display/annotation_layer.js');\n  const annotations = await page.getAnnotations();\n  const annotationLayer = new AnnotationLayer();\n  const div = document.createElement('div');\n  annotationLayer.render({\n    viewport,\n    div,\n    annotations,\n    page,\n    linkService: null,\n    downloadManager: null,\n  });\n  const highlightAnnotations = annotations.filter(a => a.subtype === 'Highlight');\n  const renderedHighlights = div.querySelectorAll('.annotationLayer .highlight');\n  expect(renderedHighlights.length).toBe(highlightAnnotations.length);\n});",
    "i4_llama-3.3-70b-versatile": "it(\"should make highlight visible when savingprinting a cropped pdf\", async () => {\n  const { getDocument } = await import('../../src/display/api.js');\n  const { buildGetDocumentParams } = await import('./test_utils.js');\n  const { PDFPageView } = await import('../../web/pdf_page_view.js');\n  const { PDFViewer } = await import('../../web/pdf_viewer.js');\n  const { Util } = await import('../../shared/util.js');\n  const loadingTask = getDocument(buildGetDocumentParams('bug1872721.pdf'));\n  const pdfViewer = new PDFViewer({\n    container: document.createElement('div'),\n    viewer: document.createElement('div'),\n    renderInteractiveForms: false,\n  });\n  const pdfDoc = await loadingTask.promise;\n  const pdfPage = await pdfDoc.getPage(1);\n  const pageView = new PDFPageView({\n    container: document.createElement('div'),\n    id: 1,\n    scale: 1,\n    renderingQueue: pdfViewer.renderingQueue,\n    viewport: pdfPage.getViewport({ scale: 1 }),\n    useDocumentColors: false,\n  });\n  const annotationEditor = new (await import('./highlight.js')).HighlightEditor({\n    annotation: {\n      subtype: 'Highlight',\n      rect: [10, 10, 50, 50],\n      color: [1, 0, 0],\n      opacity: 1,\n    },\n    pageIndex: 0,\n    pageView: pageView,\n  });\n  const expectedQuadPoints = annotationEditor.serialize().quadPoints;\n  const actualQuadPoints = annotationEditor.serialize().quadPoints;\n  await pdfPage.render({\n    canvasContext: null,\n    viewport: pageView.viewport,\n    renderInteractiveForms: false,\n    annotationEditor,\n  });\n  const highlightEditor = new (await import('./highlight.js')).HighlightEditor({\n    annotation: {\n      subtype: 'Highlight',\n      rect: [10, 10, 50, 50],\n      color: [1, 0, 0],\n      opacity: 1,\n    },\n    pageIndex: 0,\n    pageView: pageView,\n  });\n  const rect = [10, 10, 50, 50];\n  const quadPoints = highlightEditor.#serializeBoxes(rect);\n  const expectedVisibility = true;\n  const actualVisibility = quadPoints.some((point) => point > 0);\n  expect(actualVisibility).toBe(expectedVisibility);\n});",
    "i5_deepseek-r1-distill-llama-70b": "it(\"should correctly serialize highlight annotations after cropping\", async () => {\n  const { getDocument } = await import(\"../../src/display/api.js\");\n  const { buildGetDocumentParams } = await import(\"./test_utils.js\");\n  const loadingTask = getDocument(buildGetDocumentParams('bug1872721.pdf'));\n\n  const en = await loadingTask.promise;\n  const pdfDoc = await en.document;\n  const page = await pdfDoc.getPage(1);\n\n  // Create a new highlight annotation\n  const annotation = {\n    type: 'highlight',\n    color: [1, 1, 0, 0.5], // Yellow with 50% opacity\n    quadPoints: [\n      100, 100, 200, 100, 200, 200, 100, 200, \n      100, 300, 200, 300, 200, 400, 100, 400\n    ],\n    page: 1\n  };\n\n  // Add annotation to the page\n  const annotations = await page.getAnnotations();\n  annotations.push(annotation);\n\n  // Render the page to apply the annotation\n  const viewport = page.getViewPort({ scale: 1 });\n  const renderTask = page.render({\n    viewport,\n    annotationMode: 'highlight',\n    enableWebGL: false\n  });\n\n  await renderTask.promise;\n\n  // Get the annotation editor data\n  const editor = new HighlightEditor(annotation, page, viewport);\n  const data = editor.getData();\n\n  // Verify the quadPoints and outlines are correctly serialized with rect\n  expect(data.quadPoints).toBeDefined();\n  expect(data.outlines).toBeDefined();\n});",
    "i5_gpt-4o": "it(\"should correctly render highlights on cropped PDF when savingprinting\", async () => {\n  const { getDocument } = await import('../../src/display/api.js');\n  const { buildGetDocumentParams } = await import('./test_utils.js');\n  const loadingTask = getDocument(buildGetDocumentParams('bug1872721.pdf'));\n  const pdfDocument = await loadingTask.promise;\n  const page = await pdfDocument.getPage(1);\n  const viewport = page.getViewport({ scale: 1.0 });\n  const annotations = await page.getAnnotations();\n\n  const highlightAnnotation = annotations.find(ann => ann.subtype === 'Highlight');\n  const expectedQuadPoints = highlightAnnotation.quadPoints;\n\n  const { AnnotationEditorLayer } = await import('../../src/display/editor/annotation_editor_layer.js');\n  const editorLayer = new AnnotationEditorLayer({\n    viewport,\n    div: document.createElement('div'),\n    pageIndex: 0,\n    uiManager: null,\n  });\n\n  editorLayer.render({ annotations });\n  const actualQuadPoints = editorLayer.getAnnotations().find(ann => ann.subtype === 'Highlight').quadPoints;\n\n  expect(actualQuadPoints).toEqual(expectedQuadPoints);\n});",
    "i5_llama-3.3-70b-versatile": "it(\"should display highlight on cropped pdf when savingprinting\", async () => {\n  const { getDocument } = await import('../../src/display/api.js');\n  const { buildGetDocumentParams } = await import('./test_utils.js');\n  const loadingTask = getDocument(buildGetDocumentParams('bug1872721.pdf'));\n  const pdfDocument = await loadingTask.promise;\n  const pdfPage = await pdfDocument.getPage(1);\n  const { AnnotationLayerBuilder } = await import('../../web/annotation_layer_builder.js');\n  const annotationLayerBuilder = new AnnotationLayerBuilder();\n  const annotationLayer = await annotationLayerBuilder.createAnnotationLayerForPage(pdfPage);\n  const highlights = annotationLayer.getAnnotations().filter(annotation => annotation.type === 'highlight');\n  const expectedHighlightCount = 1;\n  const actualHighlightCount = highlights.length;\n  expect(actualHighlightCount).toBe(expectedHighlightCount);\n});"
  },
  "17514": {
    "i1_deepseek-r1-distill-llama-70b": "it(\"should generate a correct appearance stream for a single point ink annotation\", async () => {\n  const { InkAnnotation, numberToString } = await import(\"../../src/core/annotation.js\");\n  const { XRefMock } = await import(\"./test_utils.js\");\n  const xref = new XRefMock();\n  const annotation = {\n    color: [0, 0, 0],\n    rect: [0, 0, 100, 100],\n    paths: [{ bezier: [50, 50] }],\n    thickness: 1,\n    opacity: 1,\n  };\n  const stream = await InkAnnotation.createNewAppearanceStream(annotation, xref, {});\n  const appearance = stream.getString();\n  if (!appearance.includes(`${numberToString(50)} ${numberToString(50)} l S`)) {\n    throw new Error(\"Expected appearance stream to include a line command for a single point ink annotation.\");\n  }\n});",
    "i1_gpt-4o": "it(\"should generate a correct appearance stream for a single point ink annotation\", async () => {\n  const { InkAnnotation, numberToString } = await import(\"../../src/core/annotation.js\");\n  const { XRefMock } = await import(\"./test_utils.js\");\n  const xref = new XRefMock();\n  const annotation = {\n    color: [0, 0, 0],\n    rect: [0, 0, 100, 100],\n    paths: [{ bezier: [50, 50] }],\n    thickness: 1,\n    opacity: 1,\n  };\n  const stream = await InkAnnotation.createNewAppearanceStream(annotation, xref, {});\n  const appearance = stream.getString();\n  if (!appearance.includes(`${numberToString(50)} ${numberToString(50)} l S`)) {\n    throw new Error(\"Expected appearance stream to include a line command for a single point ink annotation.\");\n  }\n});",
    "i1_llama-3.3-70b-versatile": "it(\"should generate a correct appearance stream for a single point ink annotation\", async () => {\n  const { InkAnnotation, numberToString } = await import(\"../../src/core/annotation.js\");\n  const { XRefMock } = await import(\"./test_utils.js\");\n  const xref = new XRefMock();\n  const annotation = {\n    color: [0, 0, 0],\n    rect: [0, 0, 100, 100],\n    paths: [{ bezier: [50, 50] }],\n    thickness: 1,\n    opacity: 1,\n  };\n  const stream = await InkAnnotation.createNewAppearanceStream(annotation, xref, {});\n  const appearance = stream.getString();\n  if (!appearance.includes(`${numberToString(50)} ${numberToString(50)} l S`)) {\n    throw new Error(\"Expected appearance stream to include a line command for a single point ink annotation.\");\n  }\n});",
    "i1_MOCK": "it(\"should generate a correct appearance stream for a single point ink annotation\", async () => {\n  const { InkAnnotation, numberToString } = await import(\"../../src/core/annotation.js\");\n  const { XRefMock } = await import(\"./test_utils.js\");\n  const xref = new XRefMock();\n  const annotation = {\n    color: [0, 0, 0],\n    rect: [0, 0, 100, 100],\n    paths: [{ bezier: [50, 50] }],\n    thickness: 1,\n    opacity: 1,\n  };\n  const stream = await InkAnnotation.createNewAppearanceStream(annotation, xref, {});\n  const appearance = stream.getString();\n  if (!appearance.includes(`${numberToString(50)} ${numberToString(50)} l S`)) {\n    throw new Error(\"Expected appearance stream to include a line command for a single point ink annotation.\");\n  }\n});",
    "i2_deepseek-r1-distill-llama-70b": "it(\"should generate a correct appearance stream for a single point ink annotation\", async () => {\n  const { InkAnnotation, numberToString } = await import(\"../../src/core/annotation.js\");\n  const { XRefMock } = await import(\"./test_utils.js\");\n  const xref = new XRefMock();\n  const annotation = {\n    color: [0, 0, 0],\n    rect: [0, 0, 100, 100],\n    paths: [{ bezier: [50, 50] }],\n    thickness: 1,\n    opacity: 1,\n  };\n  const stream = await InkAnnotation.createNewAppearanceStream(annotation, xref, {});\n  const appearance = stream.getString();\n  if (!appearance.includes(`${numberToString(50)} ${numberToString(50)} l S`)) {\n    throw new Error(\"Expected appearance stream to include a line command for a single point ink annotation.\");\n  }\n});",
    "i2_gpt-4o": "it(\"should generate a correct appearance stream for a single point ink annotation\", async () => {\n  const { InkAnnotation, numberToString } = await import(\"../../src/core/annotation.js\");\n  const { XRefMock } = await import(\"./test_utils.js\");\n  const xref = new XRefMock();\n  const annotation = {\n    color: [0, 0, 0],\n    rect: [0, 0, 100, 100],\n    paths: [{ bezier: [50, 50] }],\n    thickness: 1,\n    opacity: 1,\n  };\n  const stream = await InkAnnotation.createNewAppearanceStream(annotation, xref, {});\n  const appearance = stream.getString();\n  if (!appearance.includes(`${numberToString(50)} ${numberToString(50)} l S`)) {\n    throw new Error(\"Expected appearance stream to include a line command for a single point ink annotation.\");\n  }\n});",
    "i2_llama-3.3-70b-versatile": "it(\"should generate a correct appearance stream for a single point ink annotation\", async () => {\n  const { InkAnnotation, numberToString } = await import(\"../../src/core/annotation.js\");\n  const { XRefMock } = await import(\"./test_utils.js\");\n  const xref = new XRefMock();\n  const annotation = {\n    color: [0, 0, 0],\n    rect: [0, 0, 100, 100],\n    paths: [{ bezier: [50, 50] }],\n    thickness: 1,\n    opacity: 1,\n  };\n  const stream = await InkAnnotation.createNewAppearanceStream(annotation, xref, {});\n  const appearance = stream.getString();\n  if (!appearance.includes(`${numberToString(50)} ${numberToString(50)} l S`)) {\n    throw new Error(\"Expected appearance stream to include a line command for a single point ink annotation.\");\n  }\n});",
    "i3_deepseek-r1-distill-llama-70b": "it(\"should generate a correct appearance stream for a single point ink annotation\", async () => {\n  const { InkAnnotation, numberToString } = await import(\"../../src/core/annotation.js\");\n  const { XRefMock } = await import(\"./test_utils.js\");\n  const xref = new XRefMock();\n  const annotation = {\n    color: [0, 0, 0],\n    rect: [0, 0, 100, 100],\n    paths: [{ bezier: [50, 50] }],\n    thickness: 1,\n    opacity: 1,\n  };\n  const stream = await InkAnnotation.createNewAppearanceStream(annotation, xref, {});\n  const appearance = stream.getString();\n  if (!appearance.includes(`${numberToString(50)} ${numberToString(50)} l S`)) {\n    throw new Error(\"Expected appearance stream to include a line command for a single point ink annotation.\");\n  }\n});",
    "i3_gpt-4o": "it(\"should generate a correct appearance stream for a single point ink annotation\", async () => {\n  const { InkAnnotation, numberToString } = await import(\"../../src/core/annotation.js\");\n  const { XRefMock } = await import(\"./test_utils.js\");\n  const xref = new XRefMock();\n  const annotation = {\n    color: [0, 0, 0],\n    rect: [0, 0, 100, 100],\n    paths: [{ bezier: [50, 50] }],\n    thickness: 1,\n    opacity: 1,\n  };\n  const stream = await InkAnnotation.createNewAppearanceStream(annotation, xref, {});\n  const appearance = stream.getString();\n  if (!appearance.includes(`${numberToString(50)} ${numberToString(50)} l S`)) {\n    throw new Error(\"Expected appearance stream to include a line command for a single point ink annotation.\");\n  }\n});",
    "i3_llama-3.3-70b-versatile": "it(\"should generate a correct appearance stream for a single point ink annotation\", async () => {\n  const { InkAnnotation, numberToString } = await import(\"../../src/core/annotation.js\");\n  const { XRefMock } = await import(\"./test_utils.js\");\n  const xref = new XRefMock();\n  const annotation = {\n    color: [0, 0, 0],\n    rect: [0, 0, 100, 100],\n    paths: [{ bezier: [50, 50] }],\n    thickness: 1,\n    opacity: 1,\n  };\n  const stream = await InkAnnotation.createNewAppearanceStream(annotation, xref, {});\n  const appearance = stream.getString();\n  if (!appearance.includes(`${numberToString(50)} ${numberToString(50)} l S`)) {\n    throw new Error(\"Expected appearance stream to include a line command for a single point ink annotation.\");\n  }\n});",
    "i4_deepseek-r1-distill-llama-70b": "it(\"should generate a correct appearance stream for a single point ink annotation\", async () => {\n  const { InkAnnotation, numberToString } = await import(\"../../src/core/annotation.js\");\n  const { XRefMock } = await import(\"./test_utils.js\");\n  const xref = new XRefMock();\n  const annotation = {\n    color: [0, 0, 0],\n    rect: [0, 0, 100, 100],\n    paths: [{ bezier: [50, 50] }],\n    thickness: 1,\n    opacity: 1,\n  };\n  const stream = await InkAnnotation.createNewAppearanceStream(annotation, xref, {});\n  const appearance = stream.getString();\n  if (!appearance.includes(`${numberToString(50)} ${numberToString(50)} l S`)) {\n    throw new Error(\"Expected appearance stream to include a line command for a single point ink annotation.\");\n  }\n});",
    "i4_gpt-4o": "it(\"should generate a correct appearance stream for a single point ink annotation\", async () => {\n  const { InkAnnotation, numberToString } = await import(\"../../src/core/annotation.js\");\n  const { XRefMock } = await import(\"./test_utils.js\");\n  const xref = new XRefMock();\n  const annotation = {\n    color: [0, 0, 0],\n    rect: [0, 0, 100, 100],\n    paths: [{ bezier: [50, 50] }],\n    thickness: 1,\n    opacity: 1,\n  };\n  const stream = await InkAnnotation.createNewAppearanceStream(annotation, xref, {});\n  const appearance = stream.getString();\n  if (!appearance.includes(`${numberToString(50)} ${numberToString(50)} l S`)) {\n    throw new Error(\"Expected appearance stream to include a line command for a single point ink annotation.\");\n  }\n});",
    "i4_llama-3.3-70b-versatile": "it(\"should generate a correct appearance stream for a single point ink annotation\", async () => {\n  const { InkAnnotation, numberToString } = await import(\"../../src/core/annotation.js\");\n  const { XRefMock } = await import(\"./test_utils.js\");\n  const xref = new XRefMock();\n  const annotation = {\n    color: [0, 0, 0],\n    rect: [0, 0, 100, 100],\n    paths: [{ bezier: [50, 50] }],\n    thickness: 1,\n    opacity: 1,\n  };\n  const stream = await InkAnnotation.createNewAppearanceStream(annotation, xref, {});\n  const appearance = stream.getString();\n  if (!appearance.includes(`${numberToString(50)} ${numberToString(50)} l S`)) {\n    throw new Error(\"Expected appearance stream to include a line command for a single point ink annotation.\");\n  }\n});",
    "i5_deepseek-r1-distill-llama-70b": "it(\"should generate a correct appearance stream for a single point ink annotation\", async () => {\n  const { InkAnnotation, numberToString } = await import(\"../../src/core/annotation.js\");\n  const { XRefMock } = await import(\"./test_utils.js\");\n  const xref = new XRefMock();\n  const annotation = {\n    color: [0, 0, 0],\n    rect: [0, 0, 100, 100],\n    paths: [{ bezier: [50, 50] }],\n    thickness: 1,\n    opacity: 1,\n  };\n  const stream = await InkAnnotation.createNewAppearanceStream(annotation, xref, {});\n  const appearance = stream.getString();\n  if (!appearance.includes(`${numberToString(50)} ${numberToString(50)} l S`)) {\n    throw new Error(\"Expected appearance stream to include a line command for a single point ink annotation.\");\n  }\n});",
    "i5_gpt-4o": "it(\"should generate a correct appearance stream for a single point ink annotation\", async () => {\n  const { InkAnnotation, numberToString } = await import(\"../../src/core/annotation.js\");\n  const { XRefMock } = await import(\"./test_utils.js\");\n  const xref = new XRefMock();\n  const annotation = {\n    color: [0, 0, 0],\n    rect: [0, 0, 100, 100],\n    paths: [{ bezier: [50, 50] }],\n    thickness: 1,\n    opacity: 1,\n  };\n  const stream = await InkAnnotation.createNewAppearanceStream(annotation, xref, {});\n  const appearance = stream.getString();\n  if (!appearance.includes(`${numberToString(50)} ${numberToString(50)} l S`)) {\n    throw new Error(\"Expected appearance stream to include a line command for a single point ink annotation.\");\n  }\n});",
    "i5_llama-3.3-70b-versatile": "it(\"should generate a correct appearance stream for a single point ink annotation\", async () => {\n  const { InkAnnotation, numberToString } = await import(\"../../src/core/annotation.js\");\n  const { XRefMock } = await import(\"./test_utils.js\");\n  const xref = new XRefMock();\n  const annotation = {\n    color: [0, 0, 0],\n    rect: [0, 0, 100, 100],\n    paths: [{ bezier: [50, 50] }],\n    thickness: 1,\n    opacity: 1,\n  };\n  const stream = await InkAnnotation.createNewAppearanceStream(annotation, xref, {});\n  const appearance = stream.getString();\n  if (!appearance.includes(`${numberToString(50)} ${numberToString(50)} l S`)) {\n    throw new Error(\"Expected appearance stream to include a line command for a single point ink annotation.\");\n  }\n});"
  },
  "17558": {
    "i1_gpt-4o": "it(\"should render emojis in FreeTextAnnotations correctly\", async () => {\n  const { getDocument } = await import(\"../../src/display/api.js\");\n  const { buildGetDocumentParams } = await import(\"./test_utils.js\");\n  const loadingTask = getDocument(buildGetDocumentParams(\"bug1669097.pdf\"));\n  const pdfDocument = await loadingTask.promise;\n  const page = await pdfDocument.getPage(1);\n  const annotations = await page.getAnnotations();\n\n  const freeTextAnnotations = annotations.filter(\n    annotation => annotation.subtype === \"FreeText\"\n  );\n\n  expect(freeTextAnnotations.length).toBeGreaterThan(0);\n\n  const containsEmoji = freeTextAnnotations.some(annotation =>\n    /[\\u{1F600}-\\u{1F64F}]/u.test(annotation.contents)\n  );\n\n  expect(containsEmoji).toBe(true);\n});",
    "i5_gpt-4o": "it(\"should render emojis correctly in the PDF\", async () => {\n  const { getDocument } = await import('../../src/display/api.js');\n  const { buildGetDocumentParams } = await import('./test_utils.js');\n  const loadingTask = getDocument(buildGetDocumentParams('bug1669097.pdf'));\n  const pdfDocument = await loadingTask.promise;\n  const page = await pdfDocument.getPage(1);\n  const operatorList = await page.getOperatorList();\n  const textContent = await page.getTextContent();\n\n  const hasEmojis = textContent.items.some(item => /[\\u{1F600}-\\u{1F64F}]/u.test(item.str));\n\n  expect(hasEmojis).toBe(true);\n});"
  },
  "17581": {
    "i1_deepseek-r1-distill-llama-70b": "it(\"should change cursor classes properly for highlighting\", async () => {\n  const dummyDiv = document.createElement(\"div\");\n  document.body.appendChild(dummyDiv);\n  const textLayer = { div: dummyDiv };\n  const uiManager = {\n    registerEditorTypes() {},\n    addLayer() {},\n    direction: \"ltr\"\n  };\n  const l10n = {};\n  const { AnnotationEditorLayer } = await import(\"../../src/display/editor/annotation_editor_layer.js\");\n  const layer = new AnnotationEditorLayer({\n    uiManager,\n    pageIndex: 0,\n    div: document.createElement(\"div\"),\n    accessibilityManager: {},\n    annotationLayer: {},\n    drawLayer: {},\n    textLayer,\n    viewport: {},\n    l10n\n  });\n  layer.enableTextSelection();\n  if (!dummyDiv.classList.contains(\"highlighting\") || dummyDiv.classList.contains(\"drawing\")) {\n    throw new Error(\"enableTextSelection did not add the 'highlighting' class correctly.\");\n  }\n  layer.disableTextSelection();\n  if (dummyDiv.classList.contains(\"highlighting\")) {\n    throw new Error(\"disableTextSelection did not remove the 'highlighting' class correctly.\");\n  }\n  dummyDiv.classList.remove(\"free\");\n  const pointerDownEvent = new PointerEvent(\"pointerdown\", { button: 0, clientX: 100, clientY: 100, ctrlKey: false });\n  dummyDiv.dispatchEvent(pointerDownEvent);\n  if (!dummyDiv.classList.contains(\"free\")) {\n    throw new Error(\"Pointerdown did not add the 'free' class.\");\n  }\n  const pointerUpEvent = new PointerEvent(\"pointerup\", { button: 0 });\n  dummyDiv.dispatchEvent(pointerUpEvent);\n  await new Promise(resolve => setTimeout(resolve, 0));\n  if (dummyDiv.classList.contains(\"free\")) {\n    throw new Error(\"Pointerup did not remove the 'free' class.\");\n  }\n});",
    "i1_gpt-4o": "it(\"should change cursor classes properly for highlighting\", async () => {\n  const dummyDiv = document.createElement(\"div\");\n  document.body.appendChild(dummyDiv);\n  const textLayer = { div: dummyDiv };\n  const uiManager = {\n    registerEditorTypes() {},\n    addLayer() {},\n    direction: \"ltr\"\n  };\n  const l10n = {};\n  const { AnnotationEditorLayer } = await import(\"../../src/display/editor/annotation_editor_layer.js\");\n  const layer = new AnnotationEditorLayer({\n    uiManager,\n    pageIndex: 0,\n    div: document.createElement(\"div\"),\n    accessibilityManager: {},\n    annotationLayer: {},\n    drawLayer: {},\n    textLayer,\n    viewport: {},\n    l10n\n  });\n  layer.enableTextSelection();\n  if (!dummyDiv.classList.contains(\"highlighting\") || dummyDiv.classList.contains(\"drawing\")) {\n    throw new Error(\"enableTextSelection did not add the 'highlighting' class correctly.\");\n  }\n  layer.disableTextSelection();\n  if (dummyDiv.classList.contains(\"highlighting\")) {\n    throw new Error(\"disableTextSelection did not remove the 'highlighting' class correctly.\");\n  }\n  dummyDiv.classList.remove(\"free\");\n  const pointerDownEvent = new PointerEvent(\"pointerdown\", { button: 0, clientX: 100, clientY: 100, ctrlKey: false });\n  dummyDiv.dispatchEvent(pointerDownEvent);\n  if (!dummyDiv.classList.contains(\"free\")) {\n    throw new Error(\"Pointerdown did not add the 'free' class.\");\n  }\n  const pointerUpEvent = new PointerEvent(\"pointerup\", { button: 0 });\n  dummyDiv.dispatchEvent(pointerUpEvent);\n  await new Promise(resolve => setTimeout(resolve, 0));\n  if (dummyDiv.classList.contains(\"free\")) {\n    throw new Error(\"Pointerup did not remove the 'free' class.\");\n  }\n});",
    "i1_llama-3.3-70b-versatile": "it(\"should change cursor classes properly for highlighting\", async () => {\n  const dummyDiv = document.createElement(\"div\");\n  document.body.appendChild(dummyDiv);\n  const textLayer = { div: dummyDiv };\n  const uiManager = {\n    registerEditorTypes() {},\n    addLayer() {},\n    direction: \"ltr\"\n  };\n  const l10n = {};\n  const { AnnotationEditorLayer } = await import(\"../../src/display/editor/annotation_editor_layer.js\");\n  const layer = new AnnotationEditorLayer({\n    uiManager,\n    pageIndex: 0,\n    div: document.createElement(\"div\"),\n    accessibilityManager: {},\n    annotationLayer: {},\n    drawLayer: {},\n    textLayer,\n    viewport: {},\n    l10n\n  });\n  layer.enableTextSelection();\n  if (!dummyDiv.classList.contains(\"highlighting\") || dummyDiv.classList.contains(\"drawing\")) {\n    throw new Error(\"enableTextSelection did not add the 'highlighting' class correctly.\");\n  }\n  layer.disableTextSelection();\n  if (dummyDiv.classList.contains(\"highlighting\")) {\n    throw new Error(\"disableTextSelection did not remove the 'highlighting' class correctly.\");\n  }\n  dummyDiv.classList.remove(\"free\");\n  const pointerDownEvent = new PointerEvent(\"pointerdown\", { button: 0, clientX: 100, clientY: 100, ctrlKey: false });\n  dummyDiv.dispatchEvent(pointerDownEvent);\n  if (!dummyDiv.classList.contains(\"free\")) {\n    throw new Error(\"Pointerdown did not add the 'free' class.\");\n  }\n  const pointerUpEvent = new PointerEvent(\"pointerup\", { button: 0 });\n  dummyDiv.dispatchEvent(pointerUpEvent);\n  await new Promise(resolve => setTimeout(resolve, 0));\n  if (dummyDiv.classList.contains(\"free\")) {\n    throw new Error(\"Pointerup did not remove the 'free' class.\");\n  }\n});",
    "i1_MOCK": "it(\"should change cursor classes properly for highlighting\", async () => {\n  const dummyDiv = document.createElement(\"div\");\n  document.body.appendChild(dummyDiv);\n  const textLayer = { div: dummyDiv };\n  const uiManager = {\n    registerEditorTypes() {},\n    addLayer() {},\n    direction: \"ltr\"\n  };\n  const l10n = {};\n  const { AnnotationEditorLayer } = await import(\"../../src/display/editor/annotation_editor_layer.js\");\n  const layer = new AnnotationEditorLayer({\n    uiManager,\n    pageIndex: 0,\n    div: document.createElement(\"div\"),\n    accessibilityManager: {},\n    annotationLayer: {},\n    drawLayer: {},\n    textLayer,\n    viewport: {},\n    l10n\n  });\n  layer.enableTextSelection();\n  if (!dummyDiv.classList.contains(\"highlighting\") || dummyDiv.classList.contains(\"drawing\")) {\n    throw new Error(\"enableTextSelection did not add the 'highlighting' class correctly.\");\n  }\n  layer.disableTextSelection();\n  if (dummyDiv.classList.contains(\"highlighting\")) {\n    throw new Error(\"disableTextSelection did not remove the 'highlighting' class correctly.\");\n  }\n  dummyDiv.classList.remove(\"free\");\n  const pointerDownEvent = new PointerEvent(\"pointerdown\", { button: 0, clientX: 100, clientY: 100, ctrlKey: false });\n  dummyDiv.dispatchEvent(pointerDownEvent);\n  if (!dummyDiv.classList.contains(\"free\")) {\n    throw new Error(\"Pointerdown did not add the 'free' class.\");\n  }\n  const pointerUpEvent = new PointerEvent(\"pointerup\", { button: 0 });\n  dummyDiv.dispatchEvent(pointerUpEvent);\n  await new Promise(resolve => setTimeout(resolve, 0));\n  if (dummyDiv.classList.contains(\"free\")) {\n    throw new Error(\"Pointerup did not remove the 'free' class.\");\n  }\n});",
    "i2_deepseek-r1-distill-llama-70b": "it(\"should change cursor classes properly for highlighting\", async () => {\n  const dummyDiv = document.createElement(\"div\");\n  document.body.appendChild(dummyDiv);\n  const textLayer = { div: dummyDiv };\n  const uiManager = {\n    registerEditorTypes() {},\n    addLayer() {},\n    direction: \"ltr\"\n  };\n  const l10n = {};\n  const { AnnotationEditorLayer } = await import(\"../../src/display/editor/annotation_editor_layer.js\");\n  const layer = new AnnotationEditorLayer({\n    uiManager,\n    pageIndex: 0,\n    div: document.createElement(\"div\"),\n    accessibilityManager: {},\n    annotationLayer: {},\n    drawLayer: {},\n    textLayer,\n    viewport: {},\n    l10n\n  });\n  layer.enableTextSelection();\n  if (!dummyDiv.classList.contains(\"highlighting\") || dummyDiv.classList.contains(\"drawing\")) {\n    throw new Error(\"enableTextSelection did not add the 'highlighting' class correctly.\");\n  }\n  layer.disableTextSelection();\n  if (dummyDiv.classList.contains(\"highlighting\")) {\n    throw new Error(\"disableTextSelection did not remove the 'highlighting' class correctly.\");\n  }\n  dummyDiv.classList.remove(\"free\");\n  const pointerDownEvent = new PointerEvent(\"pointerdown\", { button: 0, clientX: 100, clientY: 100, ctrlKey: false });\n  dummyDiv.dispatchEvent(pointerDownEvent);\n  if (!dummyDiv.classList.contains(\"free\")) {\n    throw new Error(\"Pointerdown did not add the 'free' class.\");\n  }\n  const pointerUpEvent = new PointerEvent(\"pointerup\", { button: 0 });\n  dummyDiv.dispatchEvent(pointerUpEvent);\n  await new Promise(resolve => setTimeout(resolve, 0));\n  if (dummyDiv.classList.contains(\"free\")) {\n    throw new Error(\"Pointerup did not remove the 'free' class.\");\n  }\n});",
    "i2_gpt-4o": "it(\"should change cursor classes properly for highlighting\", async () => {\n  const dummyDiv = document.createElement(\"div\");\n  document.body.appendChild(dummyDiv);\n  const textLayer = { div: dummyDiv };\n  const uiManager = {\n    registerEditorTypes() {},\n    addLayer() {},\n    direction: \"ltr\"\n  };\n  const l10n = {};\n  const { AnnotationEditorLayer } = await import(\"../../src/display/editor/annotation_editor_layer.js\");\n  const layer = new AnnotationEditorLayer({\n    uiManager,\n    pageIndex: 0,\n    div: document.createElement(\"div\"),\n    accessibilityManager: {},\n    annotationLayer: {},\n    drawLayer: {},\n    textLayer,\n    viewport: {},\n    l10n\n  });\n  layer.enableTextSelection();\n  if (!dummyDiv.classList.contains(\"highlighting\") || dummyDiv.classList.contains(\"drawing\")) {\n    throw new Error(\"enableTextSelection did not add the 'highlighting' class correctly.\");\n  }\n  layer.disableTextSelection();\n  if (dummyDiv.classList.contains(\"highlighting\")) {\n    throw new Error(\"disableTextSelection did not remove the 'highlighting' class correctly.\");\n  }\n  dummyDiv.classList.remove(\"free\");\n  const pointerDownEvent = new PointerEvent(\"pointerdown\", { button: 0, clientX: 100, clientY: 100, ctrlKey: false });\n  dummyDiv.dispatchEvent(pointerDownEvent);\n  if (!dummyDiv.classList.contains(\"free\")) {\n    throw new Error(\"Pointerdown did not add the 'free' class.\");\n  }\n  const pointerUpEvent = new PointerEvent(\"pointerup\", { button: 0 });\n  dummyDiv.dispatchEvent(pointerUpEvent);\n  await new Promise(resolve => setTimeout(resolve, 0));\n  if (dummyDiv.classList.contains(\"free\")) {\n    throw new Error(\"Pointerup did not remove the 'free' class.\");\n  }\n});",
    "i2_llama-3.3-70b-versatile": "it(\"should change cursor classes properly for highlighting\", async () => {\n  const dummyDiv = document.createElement(\"div\");\n  document.body.appendChild(dummyDiv);\n  const textLayer = { div: dummyDiv };\n  const uiManager = {\n    registerEditorTypes() {},\n    addLayer() {},\n    direction: \"ltr\"\n  };\n  const l10n = {};\n  const { AnnotationEditorLayer } = await import(\"../../src/display/editor/annotation_editor_layer.js\");\n  const layer = new AnnotationEditorLayer({\n    uiManager,\n    pageIndex: 0,\n    div: document.createElement(\"div\"),\n    accessibilityManager: {},\n    annotationLayer: {},\n    drawLayer: {},\n    textLayer,\n    viewport: {},\n    l10n\n  });\n  layer.enableTextSelection();\n  if (!dummyDiv.classList.contains(\"highlighting\") || dummyDiv.classList.contains(\"drawing\")) {\n    throw new Error(\"enableTextSelection did not add the 'highlighting' class correctly.\");\n  }\n  layer.disableTextSelection();\n  if (dummyDiv.classList.contains(\"highlighting\")) {\n    throw new Error(\"disableTextSelection did not remove the 'highlighting' class correctly.\");\n  }\n  dummyDiv.classList.remove(\"free\");\n  const pointerDownEvent = new PointerEvent(\"pointerdown\", { button: 0, clientX: 100, clientY: 100, ctrlKey: false });\n  dummyDiv.dispatchEvent(pointerDownEvent);\n  if (!dummyDiv.classList.contains(\"free\")) {\n    throw new Error(\"Pointerdown did not add the 'free' class.\");\n  }\n  const pointerUpEvent = new PointerEvent(\"pointerup\", { button: 0 });\n  dummyDiv.dispatchEvent(pointerUpEvent);\n  await new Promise(resolve => setTimeout(resolve, 0));\n  if (dummyDiv.classList.contains(\"free\")) {\n    throw new Error(\"Pointerup did not remove the 'free' class.\");\n  }\n});",
    "i3_deepseek-r1-distill-llama-70b": "it(\"should change cursor classes properly for highlighting\", async () => {\n  const dummyDiv = document.createElement(\"div\");\n  document.body.appendChild(dummyDiv);\n  const textLayer = { div: dummyDiv };\n  const uiManager = {\n    registerEditorTypes() {},\n    addLayer() {},\n    direction: \"ltr\"\n  };\n  const l10n = {};\n  const { AnnotationEditorLayer } = await import(\"../../src/display/editor/annotation_editor_layer.js\");\n  const layer = new AnnotationEditorLayer({\n    uiManager,\n    pageIndex: 0,\n    div: document.createElement(\"div\"),\n    accessibilityManager: {},\n    annotationLayer: {},\n    drawLayer: {},\n    textLayer,\n    viewport: {},\n    l10n\n  });\n  layer.enableTextSelection();\n  if (!dummyDiv.classList.contains(\"highlighting\") || dummyDiv.classList.contains(\"drawing\")) {\n    throw new Error(\"enableTextSelection did not add the 'highlighting' class correctly.\");\n  }\n  layer.disableTextSelection();\n  if (dummyDiv.classList.contains(\"highlighting\")) {\n    throw new Error(\"disableTextSelection did not remove the 'highlighting' class correctly.\");\n  }\n  dummyDiv.classList.remove(\"free\");\n  const pointerDownEvent = new PointerEvent(\"pointerdown\", { button: 0, clientX: 100, clientY: 100, ctrlKey: false });\n  dummyDiv.dispatchEvent(pointerDownEvent);\n  if (!dummyDiv.classList.contains(\"free\")) {\n    throw new Error(\"Pointerdown did not add the 'free' class.\");\n  }\n  const pointerUpEvent = new PointerEvent(\"pointerup\", { button: 0 });\n  dummyDiv.dispatchEvent(pointerUpEvent);\n  await new Promise(resolve => setTimeout(resolve, 0));\n  if (dummyDiv.classList.contains(\"free\")) {\n    throw new Error(\"Pointerup did not remove the 'free' class.\");\n  }\n});",
    "i3_gpt-4o": "it(\"should change cursor classes properly for highlighting\", async () => {\n  const dummyDiv = document.createElement(\"div\");\n  document.body.appendChild(dummyDiv);\n  const textLayer = { div: dummyDiv };\n  const uiManager = {\n    registerEditorTypes() {},\n    addLayer() {},\n    direction: \"ltr\"\n  };\n  const l10n = {};\n  const { AnnotationEditorLayer } = await import(\"../../src/display/editor/annotation_editor_layer.js\");\n  const layer = new AnnotationEditorLayer({\n    uiManager,\n    pageIndex: 0,\n    div: document.createElement(\"div\"),\n    accessibilityManager: {},\n    annotationLayer: {},\n    drawLayer: {},\n    textLayer,\n    viewport: {},\n    l10n\n  });\n  layer.enableTextSelection();\n  if (!dummyDiv.classList.contains(\"highlighting\") || dummyDiv.classList.contains(\"drawing\")) {\n    throw new Error(\"enableTextSelection did not add the 'highlighting' class correctly.\");\n  }\n  layer.disableTextSelection();\n  if (dummyDiv.classList.contains(\"highlighting\")) {\n    throw new Error(\"disableTextSelection did not remove the 'highlighting' class correctly.\");\n  }\n  dummyDiv.classList.remove(\"free\");\n  const pointerDownEvent = new PointerEvent(\"pointerdown\", { button: 0, clientX: 100, clientY: 100, ctrlKey: false });\n  dummyDiv.dispatchEvent(pointerDownEvent);\n  if (!dummyDiv.classList.contains(\"free\")) {\n    throw new Error(\"Pointerdown did not add the 'free' class.\");\n  }\n  const pointerUpEvent = new PointerEvent(\"pointerup\", { button: 0 });\n  dummyDiv.dispatchEvent(pointerUpEvent);\n  await new Promise(resolve => setTimeout(resolve, 0));\n  if (dummyDiv.classList.contains(\"free\")) {\n    throw new Error(\"Pointerup did not remove the 'free' class.\");\n  }\n});",
    "i3_llama-3.3-70b-versatile": "it(\"should change cursor classes properly for highlighting\", async () => {\n  const dummyDiv = document.createElement(\"div\");\n  document.body.appendChild(dummyDiv);\n  const textLayer = { div: dummyDiv };\n  const uiManager = {\n    registerEditorTypes() {},\n    addLayer() {},\n    direction: \"ltr\"\n  };\n  const l10n = {};\n  const { AnnotationEditorLayer } = await import(\"../../src/display/editor/annotation_editor_layer.js\");\n  const layer = new AnnotationEditorLayer({\n    uiManager,\n    pageIndex: 0,\n    div: document.createElement(\"div\"),\n    accessibilityManager: {},\n    annotationLayer: {},\n    drawLayer: {},\n    textLayer,\n    viewport: {},\n    l10n\n  });\n  layer.enableTextSelection();\n  if (!dummyDiv.classList.contains(\"highlighting\") || dummyDiv.classList.contains(\"drawing\")) {\n    throw new Error(\"enableTextSelection did not add the 'highlighting' class correctly.\");\n  }\n  layer.disableTextSelection();\n  if (dummyDiv.classList.contains(\"highlighting\")) {\n    throw new Error(\"disableTextSelection did not remove the 'highlighting' class correctly.\");\n  }\n  dummyDiv.classList.remove(\"free\");\n  const pointerDownEvent = new PointerEvent(\"pointerdown\", { button: 0, clientX: 100, clientY: 100, ctrlKey: false });\n  dummyDiv.dispatchEvent(pointerDownEvent);\n  if (!dummyDiv.classList.contains(\"free\")) {\n    throw new Error(\"Pointerdown did not add the 'free' class.\");\n  }\n  const pointerUpEvent = new PointerEvent(\"pointerup\", { button: 0 });\n  dummyDiv.dispatchEvent(pointerUpEvent);\n  await new Promise(resolve => setTimeout(resolve, 0));\n  if (dummyDiv.classList.contains(\"free\")) {\n    throw new Error(\"Pointerup did not remove the 'free' class.\");\n  }\n});",
    "i4_deepseek-r1-distill-llama-70b": "it(\"should change cursor classes properly for highlighting\", async () => {\n  const dummyDiv = document.createElement(\"div\");\n  document.body.appendChild(dummyDiv);\n  const textLayer = { div: dummyDiv };\n  const uiManager = {\n    registerEditorTypes() {},\n    addLayer() {},\n    direction: \"ltr\"\n  };\n  const l10n = {};\n  const { AnnotationEditorLayer } = await import(\"../../src/display/editor/annotation_editor_layer.js\");\n  const layer = new AnnotationEditorLayer({\n    uiManager,\n    pageIndex: 0,\n    div: document.createElement(\"div\"),\n    accessibilityManager: {},\n    annotationLayer: {},\n    drawLayer: {},\n    textLayer,\n    viewport: {},\n    l10n\n  });\n  layer.enableTextSelection();\n  if (!dummyDiv.classList.contains(\"highlighting\") || dummyDiv.classList.contains(\"drawing\")) {\n    throw new Error(\"enableTextSelection did not add the 'highlighting' class correctly.\");\n  }\n  layer.disableTextSelection();\n  if (dummyDiv.classList.contains(\"highlighting\")) {\n    throw new Error(\"disableTextSelection did not remove the 'highlighting' class correctly.\");\n  }\n  dummyDiv.classList.remove(\"free\");\n  const pointerDownEvent = new PointerEvent(\"pointerdown\", { button: 0, clientX: 100, clientY: 100, ctrlKey: false });\n  dummyDiv.dispatchEvent(pointerDownEvent);\n  if (!dummyDiv.classList.contains(\"free\")) {\n    throw new Error(\"Pointerdown did not add the 'free' class.\");\n  }\n  const pointerUpEvent = new PointerEvent(\"pointerup\", { button: 0 });\n  dummyDiv.dispatchEvent(pointerUpEvent);\n  await new Promise(resolve => setTimeout(resolve, 0));\n  if (dummyDiv.classList.contains(\"free\")) {\n    throw new Error(\"Pointerup did not remove the 'free' class.\");\n  }\n});",
    "i4_gpt-4o": "it(\"should change cursor classes properly for highlighting\", async () => {\n  const dummyDiv = document.createElement(\"div\");\n  document.body.appendChild(dummyDiv);\n  const textLayer = { div: dummyDiv };\n  const uiManager = {\n    registerEditorTypes() {},\n    addLayer() {},\n    direction: \"ltr\"\n  };\n  const l10n = {};\n  const { AnnotationEditorLayer } = await import(\"../../src/display/editor/annotation_editor_layer.js\");\n  const layer = new AnnotationEditorLayer({\n    uiManager,\n    pageIndex: 0,\n    div: document.createElement(\"div\"),\n    accessibilityManager: {},\n    annotationLayer: {},\n    drawLayer: {},\n    textLayer,\n    viewport: {},\n    l10n\n  });\n  layer.enableTextSelection();\n  if (!dummyDiv.classList.contains(\"highlighting\") || dummyDiv.classList.contains(\"drawing\")) {\n    throw new Error(\"enableTextSelection did not add the 'highlighting' class correctly.\");\n  }\n  layer.disableTextSelection();\n  if (dummyDiv.classList.contains(\"highlighting\")) {\n    throw new Error(\"disableTextSelection did not remove the 'highlighting' class correctly.\");\n  }\n  dummyDiv.classList.remove(\"free\");\n  const pointerDownEvent = new PointerEvent(\"pointerdown\", { button: 0, clientX: 100, clientY: 100, ctrlKey: false });\n  dummyDiv.dispatchEvent(pointerDownEvent);\n  if (!dummyDiv.classList.contains(\"free\")) {\n    throw new Error(\"Pointerdown did not add the 'free' class.\");\n  }\n  const pointerUpEvent = new PointerEvent(\"pointerup\", { button: 0 });\n  dummyDiv.dispatchEvent(pointerUpEvent);\n  await new Promise(resolve => setTimeout(resolve, 0));\n  if (dummyDiv.classList.contains(\"free\")) {\n    throw new Error(\"Pointerup did not remove the 'free' class.\");\n  }\n});",
    "i4_llama-3.3-70b-versatile": "it(\"should change cursor classes properly for highlighting\", async () => {\n  const dummyDiv = document.createElement(\"div\");\n  document.body.appendChild(dummyDiv);\n  const textLayer = { div: dummyDiv };\n  const uiManager = {\n    registerEditorTypes() {},\n    addLayer() {},\n    direction: \"ltr\"\n  };\n  const l10n = {};\n  const { AnnotationEditorLayer } = await import(\"../../src/display/editor/annotation_editor_layer.js\");\n  const layer = new AnnotationEditorLayer({\n    uiManager,\n    pageIndex: 0,\n    div: document.createElement(\"div\"),\n    accessibilityManager: {},\n    annotationLayer: {},\n    drawLayer: {},\n    textLayer,\n    viewport: {},\n    l10n\n  });\n  layer.enableTextSelection();\n  if (!dummyDiv.classList.contains(\"highlighting\") || dummyDiv.classList.contains(\"drawing\")) {\n    throw new Error(\"enableTextSelection did not add the 'highlighting' class correctly.\");\n  }\n  layer.disableTextSelection();\n  if (dummyDiv.classList.contains(\"highlighting\")) {\n    throw new Error(\"disableTextSelection did not remove the 'highlighting' class correctly.\");\n  }\n  dummyDiv.classList.remove(\"free\");\n  const pointerDownEvent = new PointerEvent(\"pointerdown\", { button: 0, clientX: 100, clientY: 100, ctrlKey: false });\n  dummyDiv.dispatchEvent(pointerDownEvent);\n  if (!dummyDiv.classList.contains(\"free\")) {\n    throw new Error(\"Pointerdown did not add the 'free' class.\");\n  }\n  const pointerUpEvent = new PointerEvent(\"pointerup\", { button: 0 });\n  dummyDiv.dispatchEvent(pointerUpEvent);\n  await new Promise(resolve => setTimeout(resolve, 0));\n  if (dummyDiv.classList.contains(\"free\")) {\n    throw new Error(\"Pointerup did not remove the 'free' class.\");\n  }\n});",
    "i5_deepseek-r1-distill-llama-70b": "it(\"should change cursor classes properly for highlighting\", async () => {\n  const dummyDiv = document.createElement(\"div\");\n  document.body.appendChild(dummyDiv);\n  const textLayer = { div: dummyDiv };\n  const uiManager = {\n    registerEditorTypes() {},\n    addLayer() {},\n    direction: \"ltr\"\n  };\n  const l10n = {};\n  const { AnnotationEditorLayer } = await import(\"../../src/display/editor/annotation_editor_layer.js\");\n  const layer = new AnnotationEditorLayer({\n    uiManager,\n    pageIndex: 0,\n    div: document.createElement(\"div\"),\n    accessibilityManager: {},\n    annotationLayer: {},\n    drawLayer: {},\n    textLayer,\n    viewport: {},\n    l10n\n  });\n  layer.enableTextSelection();\n  if (!dummyDiv.classList.contains(\"highlighting\") || dummyDiv.classList.contains(\"drawing\")) {\n    throw new Error(\"enableTextSelection did not add the 'highlighting' class correctly.\");\n  }\n  layer.disableTextSelection();\n  if (dummyDiv.classList.contains(\"highlighting\")) {\n    throw new Error(\"disableTextSelection did not remove the 'highlighting' class correctly.\");\n  }\n  dummyDiv.classList.remove(\"free\");\n  const pointerDownEvent = new PointerEvent(\"pointerdown\", { button: 0, clientX: 100, clientY: 100, ctrlKey: false });\n  dummyDiv.dispatchEvent(pointerDownEvent);\n  if (!dummyDiv.classList.contains(\"free\")) {\n    throw new Error(\"Pointerdown did not add the 'free' class.\");\n  }\n  const pointerUpEvent = new PointerEvent(\"pointerup\", { button: 0 });\n  dummyDiv.dispatchEvent(pointerUpEvent);\n  await new Promise(resolve => setTimeout(resolve, 0));\n  if (dummyDiv.classList.contains(\"free\")) {\n    throw new Error(\"Pointerup did not remove the 'free' class.\");\n  }\n});",
    "i5_gpt-4o": "it(\"should change cursor classes properly for highlighting\", async () => {\n  const dummyDiv = document.createElement(\"div\");\n  document.body.appendChild(dummyDiv);\n  const textLayer = { div: dummyDiv };\n  const uiManager = {\n    registerEditorTypes() {},\n    addLayer() {},\n    direction: \"ltr\"\n  };\n  const l10n = {};\n  const { AnnotationEditorLayer } = await import(\"../../src/display/editor/annotation_editor_layer.js\");\n  const layer = new AnnotationEditorLayer({\n    uiManager,\n    pageIndex: 0,\n    div: document.createElement(\"div\"),\n    accessibilityManager: {},\n    annotationLayer: {},\n    drawLayer: {},\n    textLayer,\n    viewport: {},\n    l10n\n  });\n  layer.enableTextSelection();\n  if (!dummyDiv.classList.contains(\"highlighting\") || dummyDiv.classList.contains(\"drawing\")) {\n    throw new Error(\"enableTextSelection did not add the 'highlighting' class correctly.\");\n  }\n  layer.disableTextSelection();\n  if (dummyDiv.classList.contains(\"highlighting\")) {\n    throw new Error(\"disableTextSelection did not remove the 'highlighting' class correctly.\");\n  }\n  dummyDiv.classList.remove(\"free\");\n  const pointerDownEvent = new PointerEvent(\"pointerdown\", { button: 0, clientX: 100, clientY: 100, ctrlKey: false });\n  dummyDiv.dispatchEvent(pointerDownEvent);\n  if (!dummyDiv.classList.contains(\"free\")) {\n    throw new Error(\"Pointerdown did not add the 'free' class.\");\n  }\n  const pointerUpEvent = new PointerEvent(\"pointerup\", { button: 0 });\n  dummyDiv.dispatchEvent(pointerUpEvent);\n  await new Promise(resolve => setTimeout(resolve, 0));\n  if (dummyDiv.classList.contains(\"free\")) {\n    throw new Error(\"Pointerup did not remove the 'free' class.\");\n  }\n});",
    "i5_llama-3.3-70b-versatile": "it(\"should change cursor classes properly for highlighting\", async () => {\n  const dummyDiv = document.createElement(\"div\");\n  document.body.appendChild(dummyDiv);\n  const textLayer = { div: dummyDiv };\n  const uiManager = {\n    registerEditorTypes() {},\n    addLayer() {},\n    direction: \"ltr\"\n  };\n  const l10n = {};\n  const { AnnotationEditorLayer } = await import(\"../../src/display/editor/annotation_editor_layer.js\");\n  const layer = new AnnotationEditorLayer({\n    uiManager,\n    pageIndex: 0,\n    div: document.createElement(\"div\"),\n    accessibilityManager: {},\n    annotationLayer: {},\n    drawLayer: {},\n    textLayer,\n    viewport: {},\n    l10n\n  });\n  layer.enableTextSelection();\n  if (!dummyDiv.classList.contains(\"highlighting\") || dummyDiv.classList.contains(\"drawing\")) {\n    throw new Error(\"enableTextSelection did not add the 'highlighting' class correctly.\");\n  }\n  layer.disableTextSelection();\n  if (dummyDiv.classList.contains(\"highlighting\")) {\n    throw new Error(\"disableTextSelection did not remove the 'highlighting' class correctly.\");\n  }\n  dummyDiv.classList.remove(\"free\");\n  const pointerDownEvent = new PointerEvent(\"pointerdown\", { button: 0, clientX: 100, clientY: 100, ctrlKey: false });\n  dummyDiv.dispatchEvent(pointerDownEvent);\n  if (!dummyDiv.classList.contains(\"free\")) {\n    throw new Error(\"Pointerdown did not add the 'free' class.\");\n  }\n  const pointerUpEvent = new PointerEvent(\"pointerup\", { button: 0 });\n  dummyDiv.dispatchEvent(pointerUpEvent);\n  await new Promise(resolve => setTimeout(resolve, 0));\n  if (dummyDiv.classList.contains(\"free\")) {\n    throw new Error(\"Pointerup did not remove the 'free' class.\");\n  }\n});"
  },
  "17639": {
    "i1_deepseek-r1-distill-llama-70b": "it(\"should add mask class to the free highlight mask use element\", async () => {\n  const { DrawLayer } = await import(\"../../src/display/draw_layer.js\");\n  const originalCreateElement = DrawLayer._svgFactory.createElement;\n  let useCount = 0;\n  let freeUse = null;\n  let svgCreated = null;\n  DrawLayer._svgFactory.createElement = function(type) {\n    if (type === \"svg\") {\n      svgCreated = document.createElementNS(\"http://www.w3.org/2000/svg\", \"svg\");\n      return svgCreated;\n    }\n    const el = originalCreateElement.call(this, type);\n    if (type === \"use\") {\n      if (useCount === 0) {\n        freeUse = el;\n      }\n      useCount++;\n    }\n    return el;\n  };\n  const drawLayer = new DrawLayer({ pageIndex: 0 });\n  const outlines = {\n    free: true,\n    box: { x: 0, y: 0, width: 100, height: 100 },\n    toSVGPath() {\n      return \"M0,0 L100,0 L100,100 L0,100 Z\";\n    }\n  };\n  drawLayer.highlightOutline(outlines);\n  DrawLayer._svgFactory.createElement = originalCreateElement;\n  if (!freeUse || !freeUse.classList.contains(\"mask\")) {\n    throw new Error(\"Expected the free highlight mask use element to have 'mask' class.\");\n  }\n});\n",
    "i1_gpt-4o": "it(\"should add mask class to the free highlight mask use element\", async () => {\n  const { DrawLayer } = await import(\"../../src/display/draw_layer.js\");\n  const originalCreateElement = DrawLayer._svgFactory.createElement;\n  let useCount = 0;\n  let freeUse = null;\n  let svgCreated = null;\n  DrawLayer._svgFactory.createElement = function(type) {\n    if (type === \"svg\") {\n      svgCreated = document.createElementNS(\"http://www.w3.org/2000/svg\", \"svg\");\n      return svgCreated;\n    }\n    const el = originalCreateElement.call(this, type);\n    if (type === \"use\") {\n      if (useCount === 0) {\n        freeUse = el;\n      }\n      useCount++;\n    }\n    return el;\n  };\n  const drawLayer = new DrawLayer({ pageIndex: 0 });\n  const outlines = {\n    free: true,\n    box: { x: 0, y: 0, width: 100, height: 100 },\n    toSVGPath() {\n      return \"M0,0 L100,0 L100,100 L0,100 Z\";\n    }\n  };\n  drawLayer.highlightOutline(outlines);\n  DrawLayer._svgFactory.createElement = originalCreateElement;\n  if (!freeUse || !freeUse.classList.contains(\"mask\")) {\n    throw new Error(\"Expected the free highlight mask use element to have 'mask' class.\");\n  }\n});\n",
    "i1_llama-3.3-70b-versatile": "it(\"should add mask class to the free highlight mask use element\", async () => {\n  const { DrawLayer } = await import(\"../../src/display/draw_layer.js\");\n  const originalCreateElement = DrawLayer._svgFactory.createElement;\n  let useCount = 0;\n  let freeUse = null;\n  let svgCreated = null;\n  DrawLayer._svgFactory.createElement = function(type) {\n    if (type === \"svg\") {\n      svgCreated = document.createElementNS(\"http://www.w3.org/2000/svg\", \"svg\");\n      return svgCreated;\n    }\n    const el = originalCreateElement.call(this, type);\n    if (type === \"use\") {\n      if (useCount === 0) {\n        freeUse = el;\n      }\n      useCount++;\n    }\n    return el;\n  };\n  const drawLayer = new DrawLayer({ pageIndex: 0 });\n  const outlines = {\n    free: true,\n    box: { x: 0, y: 0, width: 100, height: 100 },\n    toSVGPath() {\n      return \"M0,0 L100,0 L100,100 L0,100 Z\";\n    }\n  };\n  drawLayer.highlightOutline(outlines);\n  DrawLayer._svgFactory.createElement = originalCreateElement;\n  if (!freeUse || !freeUse.classList.contains(\"mask\")) {\n    throw new Error(\"Expected the free highlight mask use element to have 'mask' class.\");\n  }\n});\n",
    "i1_MOCK": "it(\"should add mask class to the free highlight mask use element\", async () => {\n  const { DrawLayer } = await import(\"../../src/display/draw_layer.js\");\n  const originalCreateElement = DrawLayer._svgFactory.createElement;\n  let useCount = 0;\n  let freeUse = null;\n  let svgCreated = null;\n  DrawLayer._svgFactory.createElement = function(type) {\n    if (type === \"svg\") {\n      svgCreated = document.createElementNS(\"http://www.w3.org/2000/svg\", \"svg\");\n      return svgCreated;\n    }\n    const el = originalCreateElement.call(this, type);\n    if (type === \"use\") {\n      if (useCount === 0) {\n        freeUse = el;\n      }\n      useCount++;\n    }\n    return el;\n  };\n  const drawLayer = new DrawLayer({ pageIndex: 0 });\n  const outlines = {\n    free: true,\n    box: { x: 0, y: 0, width: 100, height: 100 },\n    toSVGPath() {\n      return \"M0,0 L100,0 L100,100 L0,100 Z\";\n    }\n  };\n  drawLayer.highlightOutline(outlines);\n  DrawLayer._svgFactory.createElement = originalCreateElement;\n  if (!freeUse || !freeUse.classList.contains(\"mask\")) {\n    throw new Error(\"Expected the free highlight mask use element to have 'mask' class.\");\n  }\n});\n",
    "i2_deepseek-r1-distill-llama-70b": "it(\"should add mask class to the free highlight mask use element\", async () => {\n  const { DrawLayer } = await import(\"../../src/display/draw_layer.js\");\n  const originalCreateElement = DrawLayer._svgFactory.createElement;\n  let useCount = 0;\n  let freeUse = null;\n  let svgCreated = null;\n  DrawLayer._svgFactory.createElement = function(type) {\n    if (type === \"svg\") {\n      svgCreated = document.createElementNS(\"http://www.w3.org/2000/svg\", \"svg\");\n      return svgCreated;\n    }\n    const el = originalCreateElement.call(this, type);\n    if (type === \"use\") {\n      if (useCount === 0) {\n        freeUse = el;\n      }\n      useCount++;\n    }\n    return el;\n  };\n  const drawLayer = new DrawLayer({ pageIndex: 0 });\n  const outlines = {\n    free: true,\n    box: { x: 0, y: 0, width: 100, height: 100 },\n    toSVGPath() {\n      return \"M0,0 L100,0 L100,100 L0,100 Z\";\n    }\n  };\n  drawLayer.highlightOutline(outlines);\n  DrawLayer._svgFactory.createElement = originalCreateElement;\n  if (!freeUse || !freeUse.classList.contains(\"mask\")) {\n    throw new Error(\"Expected the free highlight mask use element to have 'mask' class.\");\n  }\n});\n",
    "i2_gpt-4o": "it(\"should add mask class to the free highlight mask use element\", async () => {\n  const { DrawLayer } = await import(\"../../src/display/draw_layer.js\");\n  const originalCreateElement = DrawLayer._svgFactory.createElement;\n  let useCount = 0;\n  let freeUse = null;\n  let svgCreated = null;\n  DrawLayer._svgFactory.createElement = function(type) {\n    if (type === \"svg\") {\n      svgCreated = document.createElementNS(\"http://www.w3.org/2000/svg\", \"svg\");\n      return svgCreated;\n    }\n    const el = originalCreateElement.call(this, type);\n    if (type === \"use\") {\n      if (useCount === 0) {\n        freeUse = el;\n      }\n      useCount++;\n    }\n    return el;\n  };\n  const drawLayer = new DrawLayer({ pageIndex: 0 });\n  const outlines = {\n    free: true,\n    box: { x: 0, y: 0, width: 100, height: 100 },\n    toSVGPath() {\n      return \"M0,0 L100,0 L100,100 L0,100 Z\";\n    }\n  };\n  drawLayer.highlightOutline(outlines);\n  DrawLayer._svgFactory.createElement = originalCreateElement;\n  if (!freeUse || !freeUse.classList.contains(\"mask\")) {\n    throw new Error(\"Expected the free highlight mask use element to have 'mask' class.\");\n  }\n});\n",
    "i2_llama-3.3-70b-versatile": "it(\"should add mask class to the free highlight mask use element\", async () => {\n  const { DrawLayer } = await import(\"../../src/display/draw_layer.js\");\n  const originalCreateElement = DrawLayer._svgFactory.createElement;\n  let useCount = 0;\n  let freeUse = null;\n  let svgCreated = null;\n  DrawLayer._svgFactory.createElement = function(type) {\n    if (type === \"svg\") {\n      svgCreated = document.createElementNS(\"http://www.w3.org/2000/svg\", \"svg\");\n      return svgCreated;\n    }\n    const el = originalCreateElement.call(this, type);\n    if (type === \"use\") {\n      if (useCount === 0) {\n        freeUse = el;\n      }\n      useCount++;\n    }\n    return el;\n  };\n  const drawLayer = new DrawLayer({ pageIndex: 0 });\n  const outlines = {\n    free: true,\n    box: { x: 0, y: 0, width: 100, height: 100 },\n    toSVGPath() {\n      return \"M0,0 L100,0 L100,100 L0,100 Z\";\n    }\n  };\n  drawLayer.highlightOutline(outlines);\n  DrawLayer._svgFactory.createElement = originalCreateElement;\n  if (!freeUse || !freeUse.classList.contains(\"mask\")) {\n    throw new Error(\"Expected the free highlight mask use element to have 'mask' class.\");\n  }\n});\n",
    "i3_deepseek-r1-distill-llama-70b": "it(\"should add mask class to the free highlight mask use element\", async () => {\n  const { DrawLayer } = await import(\"../../src/display/draw_layer.js\");\n  const originalCreateElement = DrawLayer._svgFactory.createElement;\n  let useCount = 0;\n  let freeUse = null;\n  let svgCreated = null;\n  DrawLayer._svgFactory.createElement = function(type) {\n    if (type === \"svg\") {\n      svgCreated = document.createElementNS(\"http://www.w3.org/2000/svg\", \"svg\");\n      return svgCreated;\n    }\n    const el = originalCreateElement.call(this, type);\n    if (type === \"use\") {\n      if (useCount === 0) {\n        freeUse = el;\n      }\n      useCount++;\n    }\n    return el;\n  };\n  const drawLayer = new DrawLayer({ pageIndex: 0 });\n  const outlines = {\n    free: true,\n    box: { x: 0, y: 0, width: 100, height: 100 },\n    toSVGPath() {\n      return \"M0,0 L100,0 L100,100 L0,100 Z\";\n    }\n  };\n  drawLayer.highlightOutline(outlines);\n  DrawLayer._svgFactory.createElement = originalCreateElement;\n  if (!freeUse || !freeUse.classList.contains(\"mask\")) {\n    throw new Error(\"Expected the free highlight mask use element to have 'mask' class.\");\n  }\n});\n",
    "i3_gpt-4o": "it(\"should add mask class to the free highlight mask use element\", async () => {\n  const { DrawLayer } = await import(\"../../src/display/draw_layer.js\");\n  const originalCreateElement = DrawLayer._svgFactory.createElement;\n  let useCount = 0;\n  let freeUse = null;\n  let svgCreated = null;\n  DrawLayer._svgFactory.createElement = function(type) {\n    if (type === \"svg\") {\n      svgCreated = document.createElementNS(\"http://www.w3.org/2000/svg\", \"svg\");\n      return svgCreated;\n    }\n    const el = originalCreateElement.call(this, type);\n    if (type === \"use\") {\n      if (useCount === 0) {\n        freeUse = el;\n      }\n      useCount++;\n    }\n    return el;\n  };\n  const drawLayer = new DrawLayer({ pageIndex: 0 });\n  const outlines = {\n    free: true,\n    box: { x: 0, y: 0, width: 100, height: 100 },\n    toSVGPath() {\n      return \"M0,0 L100,0 L100,100 L0,100 Z\";\n    }\n  };\n  drawLayer.highlightOutline(outlines);\n  DrawLayer._svgFactory.createElement = originalCreateElement;\n  if (!freeUse || !freeUse.classList.contains(\"mask\")) {\n    throw new Error(\"Expected the free highlight mask use element to have 'mask' class.\");\n  }\n});\n",
    "i3_llama-3.3-70b-versatile": "it(\"should add mask class to the free highlight mask use element\", async () => {\n  const { DrawLayer } = await import(\"../../src/display/draw_layer.js\");\n  const originalCreateElement = DrawLayer._svgFactory.createElement;\n  let useCount = 0;\n  let freeUse = null;\n  let svgCreated = null;\n  DrawLayer._svgFactory.createElement = function(type) {\n    if (type === \"svg\") {\n      svgCreated = document.createElementNS(\"http://www.w3.org/2000/svg\", \"svg\");\n      return svgCreated;\n    }\n    const el = originalCreateElement.call(this, type);\n    if (type === \"use\") {\n      if (useCount === 0) {\n        freeUse = el;\n      }\n      useCount++;\n    }\n    return el;\n  };\n  const drawLayer = new DrawLayer({ pageIndex: 0 });\n  const outlines = {\n    free: true,\n    box: { x: 0, y: 0, width: 100, height: 100 },\n    toSVGPath() {\n      return \"M0,0 L100,0 L100,100 L0,100 Z\";\n    }\n  };\n  drawLayer.highlightOutline(outlines);\n  DrawLayer._svgFactory.createElement = originalCreateElement;\n  if (!freeUse || !freeUse.classList.contains(\"mask\")) {\n    throw new Error(\"Expected the free highlight mask use element to have 'mask' class.\");\n  }\n});\n",
    "i4_deepseek-r1-distill-llama-70b": "it(\"should add mask class to the free highlight mask use element\", async () => {\n  const { DrawLayer } = await import(\"../../src/display/draw_layer.js\");\n  const originalCreateElement = DrawLayer._svgFactory.createElement;\n  let useCount = 0;\n  let freeUse = null;\n  let svgCreated = null;\n  DrawLayer._svgFactory.createElement = function(type) {\n    if (type === \"svg\") {\n      svgCreated = document.createElementNS(\"http://www.w3.org/2000/svg\", \"svg\");\n      return svgCreated;\n    }\n    const el = originalCreateElement.call(this, type);\n    if (type === \"use\") {\n      if (useCount === 0) {\n        freeUse = el;\n      }\n      useCount++;\n    }\n    return el;\n  };\n  const drawLayer = new DrawLayer({ pageIndex: 0 });\n  const outlines = {\n    free: true,\n    box: { x: 0, y: 0, width: 100, height: 100 },\n    toSVGPath() {\n      return \"M0,0 L100,0 L100,100 L0,100 Z\";\n    }\n  };\n  drawLayer.highlightOutline(outlines);\n  DrawLayer._svgFactory.createElement = originalCreateElement;\n  if (!freeUse || !freeUse.classList.contains(\"mask\")) {\n    throw new Error(\"Expected the free highlight mask use element to have 'mask' class.\");\n  }\n});\n",
    "i4_gpt-4o": "it(\"should add mask class to the free highlight mask use element\", async () => {\n  const { DrawLayer } = await import(\"../../src/display/draw_layer.js\");\n  const originalCreateElement = DrawLayer._svgFactory.createElement;\n  let useCount = 0;\n  let freeUse = null;\n  let svgCreated = null;\n  DrawLayer._svgFactory.createElement = function(type) {\n    if (type === \"svg\") {\n      svgCreated = document.createElementNS(\"http://www.w3.org/2000/svg\", \"svg\");\n      return svgCreated;\n    }\n    const el = originalCreateElement.call(this, type);\n    if (type === \"use\") {\n      if (useCount === 0) {\n        freeUse = el;\n      }\n      useCount++;\n    }\n    return el;\n  };\n  const drawLayer = new DrawLayer({ pageIndex: 0 });\n  const outlines = {\n    free: true,\n    box: { x: 0, y: 0, width: 100, height: 100 },\n    toSVGPath() {\n      return \"M0,0 L100,0 L100,100 L0,100 Z\";\n    }\n  };\n  drawLayer.highlightOutline(outlines);\n  DrawLayer._svgFactory.createElement = originalCreateElement;\n  if (!freeUse || !freeUse.classList.contains(\"mask\")) {\n    throw new Error(\"Expected the free highlight mask use element to have 'mask' class.\");\n  }\n});\n",
    "i4_llama-3.3-70b-versatile": "it(\"should add mask class to the free highlight mask use element\", async () => {\n  const { DrawLayer } = await import(\"../../src/display/draw_layer.js\");\n  const originalCreateElement = DrawLayer._svgFactory.createElement;\n  let useCount = 0;\n  let freeUse = null;\n  let svgCreated = null;\n  DrawLayer._svgFactory.createElement = function(type) {\n    if (type === \"svg\") {\n      svgCreated = document.createElementNS(\"http://www.w3.org/2000/svg\", \"svg\");\n      return svgCreated;\n    }\n    const el = originalCreateElement.call(this, type);\n    if (type === \"use\") {\n      if (useCount === 0) {\n        freeUse = el;\n      }\n      useCount++;\n    }\n    return el;\n  };\n  const drawLayer = new DrawLayer({ pageIndex: 0 });\n  const outlines = {\n    free: true,\n    box: { x: 0, y: 0, width: 100, height: 100 },\n    toSVGPath() {\n      return \"M0,0 L100,0 L100,100 L0,100 Z\";\n    }\n  };\n  drawLayer.highlightOutline(outlines);\n  DrawLayer._svgFactory.createElement = originalCreateElement;\n  if (!freeUse || !freeUse.classList.contains(\"mask\")) {\n    throw new Error(\"Expected the free highlight mask use element to have 'mask' class.\");\n  }\n});\n",
    "i5_deepseek-r1-distill-llama-70b": "it(\"should add mask class to the free highlight mask use element\", async () => {\n  const { DrawLayer } = await import(\"../../src/display/draw_layer.js\");\n  const originalCreateElement = DrawLayer._svgFactory.createElement;\n  let useCount = 0;\n  let freeUse = null;\n  let svgCreated = null;\n  DrawLayer._svgFactory.createElement = function(type) {\n    if (type === \"svg\") {\n      svgCreated = document.createElementNS(\"http://www.w3.org/2000/svg\", \"svg\");\n      return svgCreated;\n    }\n    const el = originalCreateElement.call(this, type);\n    if (type === \"use\") {\n      if (useCount === 0) {\n        freeUse = el;\n      }\n      useCount++;\n    }\n    return el;\n  };\n  const drawLayer = new DrawLayer({ pageIndex: 0 });\n  const outlines = {\n    free: true,\n    box: { x: 0, y: 0, width: 100, height: 100 },\n    toSVGPath() {\n      return \"M0,0 L100,0 L100,100 L0,100 Z\";\n    }\n  };\n  drawLayer.highlightOutline(outlines);\n  DrawLayer._svgFactory.createElement = originalCreateElement;\n  if (!freeUse || !freeUse.classList.contains(\"mask\")) {\n    throw new Error(\"Expected the free highlight mask use element to have 'mask' class.\");\n  }\n});\n",
    "i5_gpt-4o": "it(\"should add mask class to the free highlight mask use element\", async () => {\n  const { DrawLayer } = await import(\"../../src/display/draw_layer.js\");\n  const originalCreateElement = DrawLayer._svgFactory.createElement;\n  let useCount = 0;\n  let freeUse = null;\n  let svgCreated = null;\n  DrawLayer._svgFactory.createElement = function(type) {\n    if (type === \"svg\") {\n      svgCreated = document.createElementNS(\"http://www.w3.org/2000/svg\", \"svg\");\n      return svgCreated;\n    }\n    const el = originalCreateElement.call(this, type);\n    if (type === \"use\") {\n      if (useCount === 0) {\n        freeUse = el;\n      }\n      useCount++;\n    }\n    return el;\n  };\n  const drawLayer = new DrawLayer({ pageIndex: 0 });\n  const outlines = {\n    free: true,\n    box: { x: 0, y: 0, width: 100, height: 100 },\n    toSVGPath() {\n      return \"M0,0 L100,0 L100,100 L0,100 Z\";\n    }\n  };\n  drawLayer.highlightOutline(outlines);\n  DrawLayer._svgFactory.createElement = originalCreateElement;\n  if (!freeUse || !freeUse.classList.contains(\"mask\")) {\n    throw new Error(\"Expected the free highlight mask use element to have 'mask' class.\");\n  }\n});\n",
    "i5_llama-3.3-70b-versatile": "it(\"should add mask class to the free highlight mask use element\", async () => {\n  const { DrawLayer } = await import(\"../../src/display/draw_layer.js\");\n  const originalCreateElement = DrawLayer._svgFactory.createElement;\n  let useCount = 0;\n  let freeUse = null;\n  let svgCreated = null;\n  DrawLayer._svgFactory.createElement = function(type) {\n    if (type === \"svg\") {\n      svgCreated = document.createElementNS(\"http://www.w3.org/2000/svg\", \"svg\");\n      return svgCreated;\n    }\n    const el = originalCreateElement.call(this, type);\n    if (type === \"use\") {\n      if (useCount === 0) {\n        freeUse = el;\n      }\n      useCount++;\n    }\n    return el;\n  };\n  const drawLayer = new DrawLayer({ pageIndex: 0 });\n  const outlines = {\n    free: true,\n    box: { x: 0, y: 0, width: 100, height: 100 },\n    toSVGPath() {\n      return \"M0,0 L100,0 L100,100 L0,100 Z\";\n    }\n  };\n  drawLayer.highlightOutline(outlines);\n  DrawLayer._svgFactory.createElement = originalCreateElement;\n  if (!freeUse || !freeUse.classList.contains(\"mask\")) {\n    throw new Error(\"Expected the free highlight mask use element to have 'mask' class.\");\n  }\n});\n"
  },
  "17643": {
    "i1_deepseek-r1-distill-llama-70b": "it(\"should compute correct lastPoint for free highlight in a rotated PDF\", async () => {\n  const { HighlightEditor } = await import(\"../../src/display/editor/highlight.js\");\n  const { getSerialized } = await import(\"./test_utils.js\");\n  const fakeDrawLayer = {\n    finalizeLine: () => {},\n    highlightOutline: () => 1,\n    updateLine: () => {}\n  };\n  const fakeParent = { drawLayer: fakeDrawLayer };\n  const fakeOutlines = {\n    box: { x: 0.1, y: 0.2, width: 0.3, height: 0.4, lastPoint: [0.4, 0.5] },\n    getNewOutline: (thickness, innerMargin) => ({\n      box: { x: 0.1, y: 0.2, width: 0.3, height: 0.4, lastPoint: [0.4, 0.5] }\n    })\n  };\n  const params = {\n    highlightId: 1,\n    highlightOutlines: fakeOutlines,\n    clipPathId: \"clip1\",\n    thickness: 12,\n    color: \"#FF0\",\n    opacity: 1,\n    boxes: null\n  };\n  const editor = new HighlightEditor(params);\n  editor.parent = fakeParent;\n  // Set rotation to 90\u00b0 and simulate page dimensions of 1x1.\n  editor.rotation = 90;\n  editor.parentDimensions = [1, 1];\n  // Force re-calculation if needed by invoking rotate (if available).\n  if (typeof editor.rotate === \"function\") {\n    editor.rotate(90);\n  }\n  const serialized = getSerialized(editor);\n  // The expected lastPoint is computed relative to the original box coordinates:\n  // expected = [ (0.4 - 0.1) / 0.3, (0.5 - 0.2) / 0.4 ] = [1, 0.75 ]\n  chai.assert.approximately(serialized.lastPoint[0], 1, 1e-4);\n  chai.assert.approximately(serialized.lastPoint[1], 0.75, 1e-4);\n});",
    "i1_gpt-4o": "it(\"should compute correct lastPoint for free highlight in a rotated PDF\", async () => {\n  const { HighlightEditor } = await import(\"../../src/display/editor/highlight.js\");\n  const { getSerialized } = await import(\"./test_utils.js\");\n  const fakeDrawLayer = {\n    finalizeLine: () => {},\n    highlightOutline: () => 1,\n    updateLine: () => {}\n  };\n  const fakeParent = { drawLayer: fakeDrawLayer };\n  const fakeOutlines = {\n    box: { x: 0.1, y: 0.2, width: 0.3, height: 0.4, lastPoint: [0.4, 0.5] },\n    getNewOutline: (thickness, innerMargin) => ({\n      box: { x: 0.1, y: 0.2, width: 0.3, height: 0.4, lastPoint: [0.4, 0.5] }\n    })\n  };\n  const params = {\n    highlightId: 1,\n    highlightOutlines: fakeOutlines,\n    clipPathId: \"clip1\",\n    thickness: 12,\n    color: \"#FF0\",\n    opacity: 1,\n    boxes: null\n  };\n  const editor = new HighlightEditor(params);\n  editor.parent = fakeParent;\n  // Set rotation to 90\u00b0 and simulate page dimensions of 1x1.\n  editor.rotation = 90;\n  editor.parentDimensions = [1, 1];\n  // Force re-calculation if needed by invoking rotate (if available).\n  if (typeof editor.rotate === \"function\") {\n    editor.rotate(90);\n  }\n  const serialized = getSerialized(editor);\n  // The expected lastPoint is computed relative to the original box coordinates:\n  // expected = [ (0.4 - 0.1) / 0.3, (0.5 - 0.2) / 0.4 ] = [1, 0.75 ]\n  chai.assert.approximately(serialized.lastPoint[0], 1, 1e-4);\n  chai.assert.approximately(serialized.lastPoint[1], 0.75, 1e-4);\n});",
    "i1_llama-3.3-70b-versatile": "it(\"should compute correct lastPoint for free highlight in a rotated PDF\", async () => {\n  const { HighlightEditor } = await import(\"../../src/display/editor/highlight.js\");\n  const { getSerialized } = await import(\"./test_utils.js\");\n  const fakeDrawLayer = {\n    finalizeLine: () => {},\n    highlightOutline: () => 1,\n    updateLine: () => {}\n  };\n  const fakeParent = { drawLayer: fakeDrawLayer };\n  const fakeOutlines = {\n    box: { x: 0.1, y: 0.2, width: 0.3, height: 0.4, lastPoint: [0.4, 0.5] },\n    getNewOutline: (thickness, innerMargin) => ({\n      box: { x: 0.1, y: 0.2, width: 0.3, height: 0.4, lastPoint: [0.4, 0.5] }\n    })\n  };\n  const params = {\n    highlightId: 1,\n    highlightOutlines: fakeOutlines,\n    clipPathId: \"clip1\",\n    thickness: 12,\n    color: \"#FF0\",\n    opacity: 1,\n    boxes: null\n  };\n  const editor = new HighlightEditor(params);\n  editor.parent = fakeParent;\n  // Set rotation to 90\u00b0 and simulate page dimensions of 1x1.\n  editor.rotation = 90;\n  editor.parentDimensions = [1, 1];\n  // Force re-calculation if needed by invoking rotate (if available).\n  if (typeof editor.rotate === \"function\") {\n    editor.rotate(90);\n  }\n  const serialized = getSerialized(editor);\n  // The expected lastPoint is computed relative to the original box coordinates:\n  // expected = [ (0.4 - 0.1) / 0.3, (0.5 - 0.2) / 0.4 ] = [1, 0.75 ]\n  chai.assert.approximately(serialized.lastPoint[0], 1, 1e-4);\n  chai.assert.approximately(serialized.lastPoint[1], 0.75, 1e-4);\n});",
    "i1_MOCK": "it(\"should compute correct lastPoint for free highlight in a rotated PDF\", async () => {\n  const { HighlightEditor } = await import(\"../../src/display/editor/highlight.js\");\n  const { getSerialized } = await import(\"./test_utils.js\");\n  const fakeDrawLayer = {\n    finalizeLine: () => {},\n    highlightOutline: () => 1,\n    updateLine: () => {}\n  };\n  const fakeParent = { drawLayer: fakeDrawLayer };\n  const fakeOutlines = {\n    box: { x: 0.1, y: 0.2, width: 0.3, height: 0.4, lastPoint: [0.4, 0.5] },\n    getNewOutline: (thickness, innerMargin) => ({\n      box: { x: 0.1, y: 0.2, width: 0.3, height: 0.4, lastPoint: [0.4, 0.5] }\n    })\n  };\n  const params = {\n    highlightId: 1,\n    highlightOutlines: fakeOutlines,\n    clipPathId: \"clip1\",\n    thickness: 12,\n    color: \"#FF0\",\n    opacity: 1,\n    boxes: null\n  };\n  const editor = new HighlightEditor(params);\n  editor.parent = fakeParent;\n  // Set rotation to 90\u00b0 and simulate page dimensions of 1x1.\n  editor.rotation = 90;\n  editor.parentDimensions = [1, 1];\n  // Force re-calculation if needed by invoking rotate (if available).\n  if (typeof editor.rotate === \"function\") {\n    editor.rotate(90);\n  }\n  const serialized = getSerialized(editor);\n  // The expected lastPoint is computed relative to the original box coordinates:\n  // expected = [ (0.4 - 0.1) / 0.3, (0.5 - 0.2) / 0.4 ] = [1, 0.75 ]\n  chai.assert.approximately(serialized.lastPoint[0], 1, 1e-4);\n  chai.assert.approximately(serialized.lastPoint[1], 0.75, 1e-4);\n});",
    "i2_deepseek-r1-distill-llama-70b": "it(\"should compute correct lastPoint for free highlight in a rotated PDF\", async () => {\n  const { HighlightEditor } = await import(\"../../src/display/editor/highlight.js\");\n  const { getSerialized } = await import(\"./test_utils.js\");\n  const fakeDrawLayer = {\n    finalizeLine: () => {},\n    highlightOutline: () => 1,\n    updateLine: () => {}\n  };\n  const fakeParent = { drawLayer: fakeDrawLayer };\n  const fakeOutlines = {\n    box: { x: 0.1, y: 0.2, width: 0.3, height: 0.4, lastPoint: [0.4, 0.5] },\n    getNewOutline: (thickness, innerMargin) => ({\n      box: { x: 0.1, y: 0.2, width: 0.3, height: 0.4, lastPoint: [0.4, 0.5] }\n    })\n  };\n  const params = {\n    highlightId: 1,\n    highlightOutlines: fakeOutlines,\n    clipPathId: \"clip1\",\n    thickness: 12,\n    color: \"#FF0\",\n    opacity: 1,\n    boxes: null\n  };\n  const editor = new HighlightEditor(params);\n  editor.parent = fakeParent;\n  // Set rotation to 90\u00b0 and simulate page dimensions of 1x1.\n  editor.rotation = 90;\n  editor.parentDimensions = [1, 1];\n  // Force re-calculation if needed by invoking rotate (if available).\n  if (typeof editor.rotate === \"function\") {\n    editor.rotate(90);\n  }\n  const serialized = getSerialized(editor);\n  // The expected lastPoint is computed relative to the original box coordinates:\n  // expected = [ (0.4 - 0.1) / 0.3, (0.5 - 0.2) / 0.4 ] = [1, 0.75 ]\n  chai.assert.approximately(serialized.lastPoint[0], 1, 1e-4);\n  chai.assert.approximately(serialized.lastPoint[1], 0.75, 1e-4);\n});",
    "i2_gpt-4o": "it(\"should compute correct lastPoint for free highlight in a rotated PDF\", async () => {\n  const { HighlightEditor } = await import(\"../../src/display/editor/highlight.js\");\n  const { getSerialized } = await import(\"./test_utils.js\");\n  const fakeDrawLayer = {\n    finalizeLine: () => {},\n    highlightOutline: () => 1,\n    updateLine: () => {}\n  };\n  const fakeParent = { drawLayer: fakeDrawLayer };\n  const fakeOutlines = {\n    box: { x: 0.1, y: 0.2, width: 0.3, height: 0.4, lastPoint: [0.4, 0.5] },\n    getNewOutline: (thickness, innerMargin) => ({\n      box: { x: 0.1, y: 0.2, width: 0.3, height: 0.4, lastPoint: [0.4, 0.5] }\n    })\n  };\n  const params = {\n    highlightId: 1,\n    highlightOutlines: fakeOutlines,\n    clipPathId: \"clip1\",\n    thickness: 12,\n    color: \"#FF0\",\n    opacity: 1,\n    boxes: null\n  };\n  const editor = new HighlightEditor(params);\n  editor.parent = fakeParent;\n  // Set rotation to 90\u00b0 and simulate page dimensions of 1x1.\n  editor.rotation = 90;\n  editor.parentDimensions = [1, 1];\n  // Force re-calculation if needed by invoking rotate (if available).\n  if (typeof editor.rotate === \"function\") {\n    editor.rotate(90);\n  }\n  const serialized = getSerialized(editor);\n  // The expected lastPoint is computed relative to the original box coordinates:\n  // expected = [ (0.4 - 0.1) / 0.3, (0.5 - 0.2) / 0.4 ] = [1, 0.75 ]\n  chai.assert.approximately(serialized.lastPoint[0], 1, 1e-4);\n  chai.assert.approximately(serialized.lastPoint[1], 0.75, 1e-4);\n});",
    "i2_llama-3.3-70b-versatile": "it(\"should compute correct lastPoint for free highlight in a rotated PDF\", async () => {\n  const { HighlightEditor } = await import(\"../../src/display/editor/highlight.js\");\n  const { getSerialized } = await import(\"./test_utils.js\");\n  const fakeDrawLayer = {\n    finalizeLine: () => {},\n    highlightOutline: () => 1,\n    updateLine: () => {}\n  };\n  const fakeParent = { drawLayer: fakeDrawLayer };\n  const fakeOutlines = {\n    box: { x: 0.1, y: 0.2, width: 0.3, height: 0.4, lastPoint: [0.4, 0.5] },\n    getNewOutline: (thickness, innerMargin) => ({\n      box: { x: 0.1, y: 0.2, width: 0.3, height: 0.4, lastPoint: [0.4, 0.5] }\n    })\n  };\n  const params = {\n    highlightId: 1,\n    highlightOutlines: fakeOutlines,\n    clipPathId: \"clip1\",\n    thickness: 12,\n    color: \"#FF0\",\n    opacity: 1,\n    boxes: null\n  };\n  const editor = new HighlightEditor(params);\n  editor.parent = fakeParent;\n  // Set rotation to 90\u00b0 and simulate page dimensions of 1x1.\n  editor.rotation = 90;\n  editor.parentDimensions = [1, 1];\n  // Force re-calculation if needed by invoking rotate (if available).\n  if (typeof editor.rotate === \"function\") {\n    editor.rotate(90);\n  }\n  const serialized = getSerialized(editor);\n  // The expected lastPoint is computed relative to the original box coordinates:\n  // expected = [ (0.4 - 0.1) / 0.3, (0.5 - 0.2) / 0.4 ] = [1, 0.75 ]\n  chai.assert.approximately(serialized.lastPoint[0], 1, 1e-4);\n  chai.assert.approximately(serialized.lastPoint[1], 0.75, 1e-4);\n});",
    "i3_deepseek-r1-distill-llama-70b": "it(\"should compute correct lastPoint for free highlight in a rotated PDF\", async () => {\n  const { HighlightEditor } = await import(\"../../src/display/editor/highlight.js\");\n  const { getSerialized } = await import(\"./test_utils.js\");\n  const fakeDrawLayer = {\n    finalizeLine: () => {},\n    highlightOutline: () => 1,\n    updateLine: () => {}\n  };\n  const fakeParent = { drawLayer: fakeDrawLayer };\n  const fakeOutlines = {\n    box: { x: 0.1, y: 0.2, width: 0.3, height: 0.4, lastPoint: [0.4, 0.5] },\n    getNewOutline: (thickness, innerMargin) => ({\n      box: { x: 0.1, y: 0.2, width: 0.3, height: 0.4, lastPoint: [0.4, 0.5] }\n    })\n  };\n  const params = {\n    highlightId: 1,\n    highlightOutlines: fakeOutlines,\n    clipPathId: \"clip1\",\n    thickness: 12,\n    color: \"#FF0\",\n    opacity: 1,\n    boxes: null\n  };\n  const editor = new HighlightEditor(params);\n  editor.parent = fakeParent;\n  // Set rotation to 90\u00b0 and simulate page dimensions of 1x1.\n  editor.rotation = 90;\n  editor.parentDimensions = [1, 1];\n  // Force re-calculation if needed by invoking rotate (if available).\n  if (typeof editor.rotate === \"function\") {\n    editor.rotate(90);\n  }\n  const serialized = getSerialized(editor);\n  // The expected lastPoint is computed relative to the original box coordinates:\n  // expected = [ (0.4 - 0.1) / 0.3, (0.5 - 0.2) / 0.4 ] = [1, 0.75 ]\n  chai.assert.approximately(serialized.lastPoint[0], 1, 1e-4);\n  chai.assert.approximately(serialized.lastPoint[1], 0.75, 1e-4);\n});",
    "i3_gpt-4o": "it(\"should compute correct lastPoint for free highlight in a rotated PDF\", async () => {\n  const { HighlightEditor } = await import(\"../../src/display/editor/highlight.js\");\n  const { getSerialized } = await import(\"./test_utils.js\");\n  const fakeDrawLayer = {\n    finalizeLine: () => {},\n    highlightOutline: () => 1,\n    updateLine: () => {}\n  };\n  const fakeParent = { drawLayer: fakeDrawLayer };\n  const fakeOutlines = {\n    box: { x: 0.1, y: 0.2, width: 0.3, height: 0.4, lastPoint: [0.4, 0.5] },\n    getNewOutline: (thickness, innerMargin) => ({\n      box: { x: 0.1, y: 0.2, width: 0.3, height: 0.4, lastPoint: [0.4, 0.5] }\n    })\n  };\n  const params = {\n    highlightId: 1,\n    highlightOutlines: fakeOutlines,\n    clipPathId: \"clip1\",\n    thickness: 12,\n    color: \"#FF0\",\n    opacity: 1,\n    boxes: null\n  };\n  const editor = new HighlightEditor(params);\n  editor.parent = fakeParent;\n  // Set rotation to 90\u00b0 and simulate page dimensions of 1x1.\n  editor.rotation = 90;\n  editor.parentDimensions = [1, 1];\n  // Force re-calculation if needed by invoking rotate (if available).\n  if (typeof editor.rotate === \"function\") {\n    editor.rotate(90);\n  }\n  const serialized = getSerialized(editor);\n  // The expected lastPoint is computed relative to the original box coordinates:\n  // expected = [ (0.4 - 0.1) / 0.3, (0.5 - 0.2) / 0.4 ] = [1, 0.75 ]\n  chai.assert.approximately(serialized.lastPoint[0], 1, 1e-4);\n  chai.assert.approximately(serialized.lastPoint[1], 0.75, 1e-4);\n});",
    "i3_llama-3.3-70b-versatile": "it(\"should compute correct lastPoint for free highlight in a rotated PDF\", async () => {\n  const { HighlightEditor } = await import(\"../../src/display/editor/highlight.js\");\n  const { getSerialized } = await import(\"./test_utils.js\");\n  const fakeDrawLayer = {\n    finalizeLine: () => {},\n    highlightOutline: () => 1,\n    updateLine: () => {}\n  };\n  const fakeParent = { drawLayer: fakeDrawLayer };\n  const fakeOutlines = {\n    box: { x: 0.1, y: 0.2, width: 0.3, height: 0.4, lastPoint: [0.4, 0.5] },\n    getNewOutline: (thickness, innerMargin) => ({\n      box: { x: 0.1, y: 0.2, width: 0.3, height: 0.4, lastPoint: [0.4, 0.5] }\n    })\n  };\n  const params = {\n    highlightId: 1,\n    highlightOutlines: fakeOutlines,\n    clipPathId: \"clip1\",\n    thickness: 12,\n    color: \"#FF0\",\n    opacity: 1,\n    boxes: null\n  };\n  const editor = new HighlightEditor(params);\n  editor.parent = fakeParent;\n  // Set rotation to 90\u00b0 and simulate page dimensions of 1x1.\n  editor.rotation = 90;\n  editor.parentDimensions = [1, 1];\n  // Force re-calculation if needed by invoking rotate (if available).\n  if (typeof editor.rotate === \"function\") {\n    editor.rotate(90);\n  }\n  const serialized = getSerialized(editor);\n  // The expected lastPoint is computed relative to the original box coordinates:\n  // expected = [ (0.4 - 0.1) / 0.3, (0.5 - 0.2) / 0.4 ] = [1, 0.75 ]\n  chai.assert.approximately(serialized.lastPoint[0], 1, 1e-4);\n  chai.assert.approximately(serialized.lastPoint[1], 0.75, 1e-4);\n});",
    "i4_deepseek-r1-distill-llama-70b": "it(\"should compute correct lastPoint for free highlight in a rotated PDF\", async () => {\n  const { HighlightEditor } = await import(\"../../src/display/editor/highlight.js\");\n  const { getSerialized } = await import(\"./test_utils.js\");\n  const fakeDrawLayer = {\n    finalizeLine: () => {},\n    highlightOutline: () => 1,\n    updateLine: () => {}\n  };\n  const fakeParent = { drawLayer: fakeDrawLayer };\n  const fakeOutlines = {\n    box: { x: 0.1, y: 0.2, width: 0.3, height: 0.4, lastPoint: [0.4, 0.5] },\n    getNewOutline: (thickness, innerMargin) => ({\n      box: { x: 0.1, y: 0.2, width: 0.3, height: 0.4, lastPoint: [0.4, 0.5] }\n    })\n  };\n  const params = {\n    highlightId: 1,\n    highlightOutlines: fakeOutlines,\n    clipPathId: \"clip1\",\n    thickness: 12,\n    color: \"#FF0\",\n    opacity: 1,\n    boxes: null\n  };\n  const editor = new HighlightEditor(params);\n  editor.parent = fakeParent;\n  // Set rotation to 90\u00b0 and simulate page dimensions of 1x1.\n  editor.rotation = 90;\n  editor.parentDimensions = [1, 1];\n  // Force re-calculation if needed by invoking rotate (if available).\n  if (typeof editor.rotate === \"function\") {\n    editor.rotate(90);\n  }\n  const serialized = getSerialized(editor);\n  // The expected lastPoint is computed relative to the original box coordinates:\n  // expected = [ (0.4 - 0.1) / 0.3, (0.5 - 0.2) / 0.4 ] = [1, 0.75 ]\n  chai.assert.approximately(serialized.lastPoint[0], 1, 1e-4);\n  chai.assert.approximately(serialized.lastPoint[1], 0.75, 1e-4);\n});",
    "i4_gpt-4o": "it(\"should compute correct lastPoint for free highlight in a rotated PDF\", async () => {\n  const { HighlightEditor } = await import(\"../../src/display/editor/highlight.js\");\n  const { getSerialized } = await import(\"./test_utils.js\");\n  const fakeDrawLayer = {\n    finalizeLine: () => {},\n    highlightOutline: () => 1,\n    updateLine: () => {}\n  };\n  const fakeParent = { drawLayer: fakeDrawLayer };\n  const fakeOutlines = {\n    box: { x: 0.1, y: 0.2, width: 0.3, height: 0.4, lastPoint: [0.4, 0.5] },\n    getNewOutline: (thickness, innerMargin) => ({\n      box: { x: 0.1, y: 0.2, width: 0.3, height: 0.4, lastPoint: [0.4, 0.5] }\n    })\n  };\n  const params = {\n    highlightId: 1,\n    highlightOutlines: fakeOutlines,\n    clipPathId: \"clip1\",\n    thickness: 12,\n    color: \"#FF0\",\n    opacity: 1,\n    boxes: null\n  };\n  const editor = new HighlightEditor(params);\n  editor.parent = fakeParent;\n  // Set rotation to 90\u00b0 and simulate page dimensions of 1x1.\n  editor.rotation = 90;\n  editor.parentDimensions = [1, 1];\n  // Force re-calculation if needed by invoking rotate (if available).\n  if (typeof editor.rotate === \"function\") {\n    editor.rotate(90);\n  }\n  const serialized = getSerialized(editor);\n  // The expected lastPoint is computed relative to the original box coordinates:\n  // expected = [ (0.4 - 0.1) / 0.3, (0.5 - 0.2) / 0.4 ] = [1, 0.75 ]\n  chai.assert.approximately(serialized.lastPoint[0], 1, 1e-4);\n  chai.assert.approximately(serialized.lastPoint[1], 0.75, 1e-4);\n});",
    "i4_llama-3.3-70b-versatile": "it(\"should compute correct lastPoint for free highlight in a rotated PDF\", async () => {\n  const { HighlightEditor } = await import(\"../../src/display/editor/highlight.js\");\n  const { getSerialized } = await import(\"./test_utils.js\");\n  const fakeDrawLayer = {\n    finalizeLine: () => {},\n    highlightOutline: () => 1,\n    updateLine: () => {}\n  };\n  const fakeParent = { drawLayer: fakeDrawLayer };\n  const fakeOutlines = {\n    box: { x: 0.1, y: 0.2, width: 0.3, height: 0.4, lastPoint: [0.4, 0.5] },\n    getNewOutline: (thickness, innerMargin) => ({\n      box: { x: 0.1, y: 0.2, width: 0.3, height: 0.4, lastPoint: [0.4, 0.5] }\n    })\n  };\n  const params = {\n    highlightId: 1,\n    highlightOutlines: fakeOutlines,\n    clipPathId: \"clip1\",\n    thickness: 12,\n    color: \"#FF0\",\n    opacity: 1,\n    boxes: null\n  };\n  const editor = new HighlightEditor(params);\n  editor.parent = fakeParent;\n  // Set rotation to 90\u00b0 and simulate page dimensions of 1x1.\n  editor.rotation = 90;\n  editor.parentDimensions = [1, 1];\n  // Force re-calculation if needed by invoking rotate (if available).\n  if (typeof editor.rotate === \"function\") {\n    editor.rotate(90);\n  }\n  const serialized = getSerialized(editor);\n  // The expected lastPoint is computed relative to the original box coordinates:\n  // expected = [ (0.4 - 0.1) / 0.3, (0.5 - 0.2) / 0.4 ] = [1, 0.75 ]\n  chai.assert.approximately(serialized.lastPoint[0], 1, 1e-4);\n  chai.assert.approximately(serialized.lastPoint[1], 0.75, 1e-4);\n});",
    "i5_deepseek-r1-distill-llama-70b": "it(\"should compute correct lastPoint for free highlight in a rotated PDF\", async () => {\n  const { HighlightEditor } = await import(\"../../src/display/editor/highlight.js\");\n  const { getSerialized } = await import(\"./test_utils.js\");\n  const fakeDrawLayer = {\n    finalizeLine: () => {},\n    highlightOutline: () => 1,\n    updateLine: () => {}\n  };\n  const fakeParent = { drawLayer: fakeDrawLayer };\n  const fakeOutlines = {\n    box: { x: 0.1, y: 0.2, width: 0.3, height: 0.4, lastPoint: [0.4, 0.5] },\n    getNewOutline: (thickness, innerMargin) => ({\n      box: { x: 0.1, y: 0.2, width: 0.3, height: 0.4, lastPoint: [0.4, 0.5] }\n    })\n  };\n  const params = {\n    highlightId: 1,\n    highlightOutlines: fakeOutlines,\n    clipPathId: \"clip1\",\n    thickness: 12,\n    color: \"#FF0\",\n    opacity: 1,\n    boxes: null\n  };\n  const editor = new HighlightEditor(params);\n  editor.parent = fakeParent;\n  // Set rotation to 90\u00b0 and simulate page dimensions of 1x1.\n  editor.rotation = 90;\n  editor.parentDimensions = [1, 1];\n  // Force re-calculation if needed by invoking rotate (if available).\n  if (typeof editor.rotate === \"function\") {\n    editor.rotate(90);\n  }\n  const serialized = getSerialized(editor);\n  // The expected lastPoint is computed relative to the original box coordinates:\n  // expected = [ (0.4 - 0.1) / 0.3, (0.5 - 0.2) / 0.4 ] = [1, 0.75 ]\n  chai.assert.approximately(serialized.lastPoint[0], 1, 1e-4);\n  chai.assert.approximately(serialized.lastPoint[1], 0.75, 1e-4);\n});",
    "i5_gpt-4o": "it(\"should compute correct lastPoint for free highlight in a rotated PDF\", async () => {\n  const { HighlightEditor } = await import(\"../../src/display/editor/highlight.js\");\n  const { getSerialized } = await import(\"./test_utils.js\");\n  const fakeDrawLayer = {\n    finalizeLine: () => {},\n    highlightOutline: () => 1,\n    updateLine: () => {}\n  };\n  const fakeParent = { drawLayer: fakeDrawLayer };\n  const fakeOutlines = {\n    box: { x: 0.1, y: 0.2, width: 0.3, height: 0.4, lastPoint: [0.4, 0.5] },\n    getNewOutline: (thickness, innerMargin) => ({\n      box: { x: 0.1, y: 0.2, width: 0.3, height: 0.4, lastPoint: [0.4, 0.5] }\n    })\n  };\n  const params = {\n    highlightId: 1,\n    highlightOutlines: fakeOutlines,\n    clipPathId: \"clip1\",\n    thickness: 12,\n    color: \"#FF0\",\n    opacity: 1,\n    boxes: null\n  };\n  const editor = new HighlightEditor(params);\n  editor.parent = fakeParent;\n  // Set rotation to 90\u00b0 and simulate page dimensions of 1x1.\n  editor.rotation = 90;\n  editor.parentDimensions = [1, 1];\n  // Force re-calculation if needed by invoking rotate (if available).\n  if (typeof editor.rotate === \"function\") {\n    editor.rotate(90);\n  }\n  const serialized = getSerialized(editor);\n  // The expected lastPoint is computed relative to the original box coordinates:\n  // expected = [ (0.4 - 0.1) / 0.3, (0.5 - 0.2) / 0.4 ] = [1, 0.75 ]\n  chai.assert.approximately(serialized.lastPoint[0], 1, 1e-4);\n  chai.assert.approximately(serialized.lastPoint[1], 0.75, 1e-4);\n});",
    "i5_llama-3.3-70b-versatile": "it(\"should compute correct lastPoint for free highlight in a rotated PDF\", async () => {\n  const { HighlightEditor } = await import(\"../../src/display/editor/highlight.js\");\n  const { getSerialized } = await import(\"./test_utils.js\");\n  const fakeDrawLayer = {\n    finalizeLine: () => {},\n    highlightOutline: () => 1,\n    updateLine: () => {}\n  };\n  const fakeParent = { drawLayer: fakeDrawLayer };\n  const fakeOutlines = {\n    box: { x: 0.1, y: 0.2, width: 0.3, height: 0.4, lastPoint: [0.4, 0.5] },\n    getNewOutline: (thickness, innerMargin) => ({\n      box: { x: 0.1, y: 0.2, width: 0.3, height: 0.4, lastPoint: [0.4, 0.5] }\n    })\n  };\n  const params = {\n    highlightId: 1,\n    highlightOutlines: fakeOutlines,\n    clipPathId: \"clip1\",\n    thickness: 12,\n    color: \"#FF0\",\n    opacity: 1,\n    boxes: null\n  };\n  const editor = new HighlightEditor(params);\n  editor.parent = fakeParent;\n  // Set rotation to 90\u00b0 and simulate page dimensions of 1x1.\n  editor.rotation = 90;\n  editor.parentDimensions = [1, 1];\n  // Force re-calculation if needed by invoking rotate (if available).\n  if (typeof editor.rotate === \"function\") {\n    editor.rotate(90);\n  }\n  const serialized = getSerialized(editor);\n  // The expected lastPoint is computed relative to the original box coordinates:\n  // expected = [ (0.4 - 0.1) / 0.3, (0.5 - 0.2) / 0.4 ] = [1, 0.75 ]\n  chai.assert.approximately(serialized.lastPoint[0], 1, 1e-4);\n  chai.assert.approximately(serialized.lastPoint[1], 0.75, 1e-4);\n});"
  },
  "17664": {
    "i1_deepseek-r1-distill-llama-70b": "it(\"should update highlighting outline coordinates correctly\", async () => {\n  const { FreeOutliner } = await import(\"../../src/display/editor/outliner.js\");\n  const box = { x: 0, y: 0, width: 100, height: 100 };\n  const outliner = new FreeOutliner({ x: 50, y: 50 }, box, 1, 1, true);\n\n  // Add points to create a sample outline\n  outliner.add({ x: 60, y: 40 });\n  outliner.add({ x: 70, y: 30 });\n  outliner.add({ x: 80, y: 20 });\n\n  // Generate the SVG path\n  const svgPath = outliner.toSVGPath();\n\n  // The expected path should include the last added point coordinates\n  const expectedPath = /L(80-0\\.0) (20-0\\.0)/;\n  expect(svgPath).toMatch(expectedPath);\n});",
    "i1_llama-3.3-70b-versatile": "it(\"should not lag behind the mouse cursor when using free highlighting in PDF\", async () => {\n  const { FreeOutliner } = await import(\"../../src/display/editor/outliner.js\");\n  const { Util } = await import(\"../../src/shared/util.js\");\n  const outliner = new FreeOutliner({ x: 10, y: 10 }, [0, 0, 100, 100], 1, 1, true);\n  outliner.add({ x: 20, y: 20 });\n  outliner.add({ x: 30, y: 30 });\n  const path = outliner.toSVGPath();\n  const expectedPath = `M10 10 L20 20 L30 30 L40 40 Z`;\n  expect(path).toBe(expectedPath);\n});",
    "i2_deepseek-r1-distill-llama-70b": "it(\"should update free highlight outline to follow cursor\", async () => {\n  const { PDFDocument } = await import(\"../../src/core/document.js\");\n  const { FreeOutliner } = await import(\"../../src/display/editor/outliner.js\");\n\n  // Mock PDF document and page\n  const pdf = new PDFDocument({\n    getMetadata: () => ({}),\n    getPages: () => [{ getWidth: () => 100, getHeight: () => 100 }]\n  });\n\n  const box = { x: 0, y: 0, width: 100, height: 100 };\n  const scaleFactor = 1;\n  const thickness = 2;\n  const isLTR = true;\n  const innerMargin = 0;\n\n  const outliner = new FreeOutliner(\n    { x: 10, y: 10 },\n    box,\n    scaleFactor,\n    thickness,\n    isLTR,\n    innerMargin\n  );\n\n  // Simulate mouse moving and adding points\n  await outliner.add({ x: 20, y: 20 });\n  await outliner.add({ x: 30, y: 30 });\n  await outliner.add({ x: 40, y: 40 });\n  await outliner.add({ x: 50, y: 50 });\n\n  // Get the SVG path\n  const svgPath = outliner.toSVGPath();\n\n  // Expected path should reflect the cursor position\n  const expectedPath = \"M0.3 0.3 L0.4 0.4 L0.5 0.5 L0.6 0.6 Z\";\n\n  expect(svgPath).toContain(expectedPath);\n});",
    "i2_gpt-4o": "it(\"should ensure free highlighting ends where the mouse pointer is\", async () => {\n  const { FreeOutliner } = await import(\"../../src/display/editor/outliner.js\");\n\n  const initialPoint = { x: 10, y: 10 };\n  const box = [0, 0, 100, 100];\n  const scaleFactor = 1;\n  const thickness = 1;\n  const isLTR = true;\n  const outliner = new FreeOutliner(initialPoint, box, scaleFactor, thickness, isLTR);\n\n  const points = [\n    { x: 20, y: 20 },\n    { x: 30, y: 30 },\n    { x: 40, y: 40 }\n  ];\n\n  points.forEach(point => outliner.add(point));\n\n  const expectedLastCoords = [0.4, 0.4, 0.4, 0.4];\n  const actualLastCoords = outliner.getOutlines().outline.slice(-4);\n\n  expect(actualLastCoords).toEqual(expectedLastCoords);\n});",
    "i2_llama-3.3-70b-versatile": "it(\"should end a free highlight where the mouse pointer is\", async () => {\n  const { FreeOutliner } = await import(\"../../src/display/editor/outliner.js\");\n  const box = { x: 0, y: 0, width: 100, height: 100 };\n  const scaleFactor = 1;\n  const thickness = 1;\n  const isLTR = true;\n  const innerMargin = 0;\n  const outliner = new FreeOutliner({ x: 10, y: 10 }, box, scaleFactor, thickness, isLTR, innerMargin);\n  outliner.add({ x: 20, y: 20 });\n  outliner.add({ x: 30, y: 30 });\n  const expected = `M${(10 - 0) / 100} ${(10 - 0) / 100} L${(20 - 0) / 100} ${(20 - 0) / 100} L${(30 - 0) / 100} ${(30 - 0) / 100} L${(30 - 0) / 100} ${(30 - 0) / 100} L${(30 - 0) / 100} ${(30 - 0) / 100} Z`;\n  const actual = outliner.toSVGPath();\n  expect(actual).toBe(expected);\n});",
    "i3_deepseek-r1-distill-llama-70b": "it(\"should fix free highlighting lagging behind mouse cursor\", async () => {\n  const { FreeOutliner } = await import(\"../../src/display/editor/outliner.js\");\n  const { DefaultCMapReaderFactory } = await import(\"../../src/display/api.js\");\n\n  const box = { x: 0, y: 0, width: 100, height: 100 };\n  const scaleFactor = 1;\n  const thickness = 2;\n  const isLTR = true;\n  const innerMargin = 0;\n\n  const points = [\n    { x: 10, y: 10 },\n    { x: 20, y: 20 },\n    { x: 30, y: 30 },\n    { x: 40, y: 40 },\n    { x: 50, y: 50 }\n  ];\n\n  const outliner = new FreeOutliner(points[0], box, scaleFactor, thickness, isLTR, innerMargin);\n  for (const point of points.slice(1)) {\n    outliner.add(point);\n  }\n\n  const outlines = outliner.getOutlines();\n  const expectedLastPoint = [points[points.length - 1].x, points[points.length - 1].y];\n\n  try {\n    // Verify that the last point of the outline matches the expected position\n    const actualLastPoint = outlines[outlines.length - 1];\n    expect(actualLastPoint).toEqual(expectedLastPoint);\n  } catch (error) {\n    throw new Error(\"Free highlighting outline does not match expected position\");\n  }\n});",
    "i3_llama-3.3-70b-versatile": "it(\"should fix the free highlighting in PDF not lagging behind the mouse cursor\", async () => {\n  const { FreeOutliner } = await import(\"../../src/display/editor/outliner.js\");\n  const outliner = new FreeOutliner({ x: 10, y: 10 }, { x: 0, y: 0, width: 100, height: 100 }, 1, 1, true);\n  outliner.add({ x: 20, y: 20 });\n  outliner.add({ x: 30, y: 30 });\n  const outlines = outliner.getOutlines();\n  const expectedOutline = new Float64Array(36);\n  expectedOutline.set([NaN, NaN, NaN, NaN, 10, 10], 0);\n  expectedOutline.set([NaN, NaN, NaN, NaN, 20, 20], 8);\n  expectedOutline.set([NaN, NaN, NaN, NaN, 30, 30], 16);\n  expectedOutline.set([NaN, NaN, NaN, NaN, 20, 20], 24);\n  expectedOutline.set([NaN, NaN, NaN, NaN, 30, 30], 28);\n  expectedOutline.set([NaN, NaN, NaN, NaN, 20, 20], 32);\n  const actualOutline = outlines.outline;\n  for (let i = 0; i < expectedOutline.length; i++) {\n    if (expectedOutline[i] !== actualOutline[i]) {\n      throw new Error(\"Outlines do not match\");\n    }\n  }\n});",
    "i4_deepseek-r1-distill-llama-70b": "it(\"should fix free highlighting lagging behind mouse cursor\", async () => {\n  const { FreeOutliner } = await import(\"../../src/display/editor/outliner.js\");\n  const { Util } = await import(\"../../shared/util.js\");\n\n  const box = { x: 0, y: 0, width: 100, height: 100 };\n  const scaleFactor = 1;\n  const thickness = 2;\n  const isLTR = true;\n  const innerMargin = 0;\n\n  const outliner = new FreeOutliner(\n    { x: 10, y: 10 },\n    box,\n    scaleFactor,\n    thickness,\n    isLTR,\n    innerMargin\n  );\n\n  const points = [];\n  for (let i = 0; i < 20; i++) {\n    const angle = (i * Math.PI) / 5;\n    points.push({\n      x: 50 + 40 * Math.cos(angle),\n      y: 50 + 40 * Math.sin(angle)\n    });\n  }\n\n  let result = outliner.add(points[1]);\n  while (points.length) {\n    result = outliner.add(points.pop());\n    expect(result).toBeTruthy();\n  }\n\n  const outlines = outliner.getOutlines();\n  expect(outlines).toBeTruthy();\n  expect(outlines.toSVGPath()).toMatch(/M.*Z/s);\n});",
    "i4_gpt-4o": "it(\"should ensure free highlighting in PDF does not lag behind the mouse cursor\", async () => {\n  const { FreeOutliner } = await import(\"../../src/display/editor/outliner.js\");\n\n  const initialPoint = { x: 10, y: 10 };\n  const box = [0, 0, 100, 100];\n  const scaleFactor = 1;\n  const thickness = 2;\n  const isLTR = true;\n  const innerMargin = 0;\n\n  const freeOutliner = new FreeOutliner(initialPoint, box, scaleFactor, thickness, isLTR, innerMargin);\n\n  const pointsToAdd = [\n    { x: 20, y: 20 },\n    { x: 30, y: 30 },\n    { x: 40, y: 40 },\n    { x: 50, y: 50 }\n  ];\n\n  pointsToAdd.forEach(point => freeOutliner.add(point));\n\n  const expectedSVGPath = \"M0.1 0.1 L0.2 0.2 L0.3 0.3 L0.4 0.4 L0.5 0.5 Z\";\n  const actualSVGPath = freeOutliner.toSVGPath();\n\n  expect(actualSVGPath).toBe(expectedSVGPath);\n});",
    "i4_llama-3.3-70b-versatile": "it(\"should not lag behind the mouse cursor when highlighting in PDF\", async () => {\n  const { FreeOutliner } = await import(\"../../src/display/editor/outliner.js\");\n  const box = { x: 0, y: 0, width: 100, height: 100 };\n  const scaleFactor = 1;\n  const thickness = 1;\n  const isLTR = true;\n  const innerMargin = 0;\n  const outliner = new FreeOutliner({ x: 10, y: 10 }, box, scaleFactor, thickness, isLTR, innerMargin);\n  outliner.add({ x: 20, y: 20 });\n  outliner.add({ x: 30, y: 30 });\n  const outlines = outliner.getOutlines();\n  const expectedOutline = new Float64Array(36);\n  expectedOutline.set([NaN, NaN, NaN, NaN, 10, 10], 0);\n  expectedOutline.set([NaN, NaN, NaN, NaN, 20, 20], 12);\n  expectedOutline.set([NaN, NaN, NaN, NaN, 30, 30], 24);\n  expectedOutline.set([NaN, NaN, NaN, NaN, 20, 20], 30);\n  expectedOutline.set([NaN, NaN, NaN, NaN, 30, 30], 32);\n  const actualOutline = outlines.outline;\n  for (let i = 0; i < actualOutline.length; i++) {\n    if (Math.abs(actualOutline[i] - expectedOutline[i]) > 0.01) {\n      throw new Error(\"Outlines do not match\");\n    }\n  }\n});",
    "i5_deepseek-r1-distill-llama-70b": "it(\"should update the free highlight outline to include the latest coordinates\", async () => {\n  const { PDFDocument } = await import(\"../../src/core/document.js\");\n  const { Page } = await import(\"../../src/core/document.js\");\n  const { FreeOutliner } = await import(\"../../src/display/editor/outliner.js\");\n\n  const doc = new PDFDocument();\n  const page = new Page(doc);\n  const outliner = new FreeOutliner();\n\n  // Simulate drawing points\n  outliner.add({ x: 100, y: 100 });\n  outliner.add({ x: 200, y: 200 });\n  outliner.add({ x: 300, y: 300 });\n\n  // Get the outline path\n  const outline = outliner.getOutline();\n\n  // The expected outline should include the last coordinates\n  const expectedOutline = [\n    \"M0,0 L0.5,0.5 L1,1 L1.5,1.5 L2,2 L1.5,1.5 L1,1\",\n    \"L0.5,0.5 1,1 L1.5,1.5 2,2\",\n    \"M2,2 L2.5,2.5 L3,3\",\n  ];\n\n  // Verify the generated outline includes the latest points\n  expect(outline).toContain(expectedOutline[2]);\n});",
    "i5_gpt-4o": "it(\"should update highlighting position without lag\", async () => {\n  const { FreeOutliner } = await import(\"../../src/display/editor/outliner.js\");\n\n  const outliner = new FreeOutliner();\n  outliner.#box = [0, 0, 100, 100];\n\n  outliner.add({ x: 10, y: 10 });\n  outliner.add({ x: 20, y: 20 });\n\n  const expected = [\n    (10 - 0) / 100, (10 - 0) / 100,\n    (20 - 0) / 100, (20 - 0) / 100\n  ];\n\n  const actual = outliner.#getLastCoords();\n\n  expect(actual).toEqual(expected);\n});",
    "i5_llama-3.3-70b-versatile": "it(\"should not lag behind the mouse cursor when using free highlighting in PDF\", async () => {\n  const { PDFDocument, PDFPageProxy } = await import(\"../../src/display/api.js\");\n  const { Outliner } = await import(\"../../src/display/editor/outliner.js\");\n  const { PDFDataRangeTransport } = await import(\"../../src/display/api.js\");\n\n  const pdfDoc = await PDFDocument.load(await PDFDataRangeTransport.fetch({\n    url: `${TEST_PDFS_PATH}/highlighting.pdf`,\n    range: { start: 0, size: 1024 * 1024 },\n  }));\n  const pdfPage = pdfDoc.getPage(0);\n  const outliner = new Outliner();\n\n  const lastX = 100;\n  const lastY = 100;\n  outliner.add({ x: lastX, y: lastY });\n\n  const lastCoords = outliner.#getLastCoords();\n  const expectedLastCoords = [(lastX + (outliner.#last.subarray(4, 6)[0] - outliner.#last.subarray(16, 18)[0]) / 2) / pdfPage.getViewport({ scale: 1 }).width, \n                               (lastY + (outliner.#last.subarray(4, 6)[1] - outliner.#last.subarray(16, 18)[1]) / 2) / pdfPage.getViewport({ scale: 1 }).height, \n                               (lastX + (outliner.#last.subarray(16, 18)[0] - outliner.#last.subarray(4, 6)[0]) / 2) / pdfPage.getViewport({ scale: 1 }).width, \n                               (lastY + (outliner.#last.subarray(16, 18)[1] - outliner.#last.subarray(4, 6)[1]) / 2) / pdfPage.getViewport({ scale: 1 }).height];\n\n  expect(lastCoords).toEqual(expectedLastCoords);\n});"
  },
  "17674": {
    "i1_deepseek-r1-distill-llama-70b": "it(\"should correctly render missing characters with loca table patch\", async () => {\n  const pdfDoc = await getDocument(TEST_PDFS_PATH + \"Mappe123.pdf\").promise;\n  const page = await pdfDoc.getPage(1);\n  const textContent = await page.getTextContent();\n  const text = textContent.items.map(item => item.str).join(\"\");\n  expect(text).toEqual(\"Das ist ein Test\");\n});",
    "i1_gpt-4o": "it(\"should correctly render missing characters with loca table patch\", async () => {\n  const pdfDoc = await getDocument(TEST_PDFS_PATH + \"Mappe123.pdf\").promise;\n  const page = await pdfDoc.getPage(1);\n  const textContent = await page.getTextContent();\n  const text = textContent.items.map(item => item.str).join(\"\");\n  expect(text).toEqual(\"Das ist ein Test\");\n});",
    "i1_llama-3.3-70b-versatile": "it(\"should correctly render missing characters with loca table patch\", async () => {\n  const pdfDoc = await getDocument(TEST_PDFS_PATH + \"Mappe123.pdf\").promise;\n  const page = await pdfDoc.getPage(1);\n  const textContent = await page.getTextContent();\n  const text = textContent.items.map(item => item.str).join(\"\");\n  expect(text).toEqual(\"Das ist ein Test\");\n});",
    "i1_MOCK": "it(\"should correctly render missing characters with loca table patch\", async () => {\n  const pdfDoc = await getDocument(TEST_PDFS_PATH + \"Mappe123.pdf\").promise;\n  const page = await pdfDoc.getPage(1);\n  const textContent = await page.getTextContent();\n  const text = textContent.items.map(item => item.str).join(\"\");\n  expect(text).toEqual(\"Das ist ein Test\");\n});",
    "i2_deepseek-r1-distill-llama-70b": "it(\"should correctly render missing characters with loca table patch\", async () => {\n  const pdfDoc = await getDocument(TEST_PDFS_PATH + \"Mappe123.pdf\").promise;\n  const page = await pdfDoc.getPage(1);\n  const textContent = await page.getTextContent();\n  const text = textContent.items.map(item => item.str).join(\"\");\n  expect(text).toEqual(\"Das ist ein Test\");\n});",
    "i2_gpt-4o": "it(\"should correctly render missing characters with loca table patch\", async () => {\n  const pdfDoc = await getDocument(TEST_PDFS_PATH + \"Mappe123.pdf\").promise;\n  const page = await pdfDoc.getPage(1);\n  const textContent = await page.getTextContent();\n  const text = textContent.items.map(item => item.str).join(\"\");\n  expect(text).toEqual(\"Das ist ein Test\");\n});",
    "i2_llama-3.3-70b-versatile": "it(\"should correctly render missing characters with loca table patch\", async () => {\n  const pdfDoc = await getDocument(TEST_PDFS_PATH + \"Mappe123.pdf\").promise;\n  const page = await pdfDoc.getPage(1);\n  const textContent = await page.getTextContent();\n  const text = textContent.items.map(item => item.str).join(\"\");\n  expect(text).toEqual(\"Das ist ein Test\");\n});",
    "i3_deepseek-r1-distill-llama-70b": "it(\"should correctly render missing characters with loca table patch\", async () => {\n  const pdfDoc = await getDocument(TEST_PDFS_PATH + \"Mappe123.pdf\").promise;\n  const page = await pdfDoc.getPage(1);\n  const textContent = await page.getTextContent();\n  const text = textContent.items.map(item => item.str).join(\"\");\n  expect(text).toEqual(\"Das ist ein Test\");\n});",
    "i3_gpt-4o": "it(\"should correctly render missing characters with loca table patch\", async () => {\n  const pdfDoc = await getDocument(TEST_PDFS_PATH + \"Mappe123.pdf\").promise;\n  const page = await pdfDoc.getPage(1);\n  const textContent = await page.getTextContent();\n  const text = textContent.items.map(item => item.str).join(\"\");\n  expect(text).toEqual(\"Das ist ein Test\");\n});",
    "i3_llama-3.3-70b-versatile": "it(\"should correctly render missing characters with loca table patch\", async () => {\n  const pdfDoc = await getDocument(TEST_PDFS_PATH + \"Mappe123.pdf\").promise;\n  const page = await pdfDoc.getPage(1);\n  const textContent = await page.getTextContent();\n  const text = textContent.items.map(item => item.str).join(\"\");\n  expect(text).toEqual(\"Das ist ein Test\");\n});",
    "i4_deepseek-r1-distill-llama-70b": "it(\"should correctly render missing characters with loca table patch\", async () => {\n  const pdfDoc = await getDocument(TEST_PDFS_PATH + \"Mappe123.pdf\").promise;\n  const page = await pdfDoc.getPage(1);\n  const textContent = await page.getTextContent();\n  const text = textContent.items.map(item => item.str).join(\"\");\n  expect(text).toEqual(\"Das ist ein Test\");\n});",
    "i4_gpt-4o": "it(\"should correctly render missing characters with loca table patch\", async () => {\n  const pdfDoc = await getDocument(TEST_PDFS_PATH + \"Mappe123.pdf\").promise;\n  const page = await pdfDoc.getPage(1);\n  const textContent = await page.getTextContent();\n  const text = textContent.items.map(item => item.str).join(\"\");\n  expect(text).toEqual(\"Das ist ein Test\");\n});",
    "i4_llama-3.3-70b-versatile": "it(\"should correctly render missing characters with loca table patch\", async () => {\n  const pdfDoc = await getDocument(TEST_PDFS_PATH + \"Mappe123.pdf\").promise;\n  const page = await pdfDoc.getPage(1);\n  const textContent = await page.getTextContent();\n  const text = textContent.items.map(item => item.str).join(\"\");\n  expect(text).toEqual(\"Das ist ein Test\");\n});",
    "i5_deepseek-r1-distill-llama-70b": "it(\"should correctly render missing characters with loca table patch\", async () => {\n  const pdfDoc = await getDocument(TEST_PDFS_PATH + \"Mappe123.pdf\").promise;\n  const page = await pdfDoc.getPage(1);\n  const textContent = await page.getTextContent();\n  const text = textContent.items.map(item => item.str).join(\"\");\n  expect(text).toEqual(\"Das ist ein Test\");\n});",
    "i5_gpt-4o": "it(\"should correctly render missing characters with loca table patch\", async () => {\n  const pdfDoc = await getDocument(TEST_PDFS_PATH + \"Mappe123.pdf\").promise;\n  const page = await pdfDoc.getPage(1);\n  const textContent = await page.getTextContent();\n  const text = textContent.items.map(item => item.str).join(\"\");\n  expect(text).toEqual(\"Das ist ein Test\");\n});",
    "i5_llama-3.3-70b-versatile": "it(\"should correctly render missing characters with loca table patch\", async () => {\n  const pdfDoc = await getDocument(TEST_PDFS_PATH + \"Mappe123.pdf\").promise;\n  const page = await pdfDoc.getPage(1);\n  const textContent = await page.getTextContent();\n  const text = textContent.items.map(item => item.str).join(\"\");\n  expect(text).toEqual(\"Das ist ein Test\");\n});"
  },
  "17690": {
    "i1_deepseek-r1-distill-llama-70b": "it(\"should handle missing cidSystemInfo gracefully in composite fonts\", async () => {\n  const { createIdFactory } = await import(\"./test_utils.js\");\n  const evaluator = new (await import(\"../../src/core/evaluator.js\")).PartialEvaluator({\n    xref: {},\n    handler: {},\n    pageIndex: 0,\n    idFactory: createIdFactory(),\n    fontCache: new Map(),\n    builtInCMapCache: new Map(),\n    standardFontDataCache: new Map(),\n    globalImageCache: new Map(),\n    systemFontCache: new Map(),\n  });\n  const properties = {\n    composite: true,\n    cMap: { builtInCMap: false },\n    firstChar: 32,\n    lastChar: 127,\n    // Intentionally omitting cidSystemInfo to simulate problematic PDFs.\n  };\n  const toUnicodeMap = await evaluator.buildToUnicode(properties);\n  if (typeof toUnicodeMap.lookup !== \"function\") {\n    throw new Error(\"toUnicodeMap.lookup is not a function\");\n  }\n  const char = toUnicodeMap.lookup(65);\n  if (char !== \"A\") {\n    throw new Error(`Expected \"A\" for char code 65 but got \"${char}\"`);\n  }\n});",
    "i1_gpt-4o": "it(\"should handle missing cidSystemInfo gracefully in composite fonts\", async () => {\n  const { createIdFactory } = await import(\"./test_utils.js\");\n  const evaluator = new (await import(\"../../src/core/evaluator.js\")).PartialEvaluator({\n    xref: {},\n    handler: {},\n    pageIndex: 0,\n    idFactory: createIdFactory(),\n    fontCache: new Map(),\n    builtInCMapCache: new Map(),\n    standardFontDataCache: new Map(),\n    globalImageCache: new Map(),\n    systemFontCache: new Map(),\n  });\n  const properties = {\n    composite: true,\n    cMap: { builtInCMap: false },\n    firstChar: 32,\n    lastChar: 127,\n    // Intentionally omitting cidSystemInfo to simulate problematic PDFs.\n  };\n  const toUnicodeMap = await evaluator.buildToUnicode(properties);\n  if (typeof toUnicodeMap.lookup !== \"function\") {\n    throw new Error(\"toUnicodeMap.lookup is not a function\");\n  }\n  const char = toUnicodeMap.lookup(65);\n  if (char !== \"A\") {\n    throw new Error(`Expected \"A\" for char code 65 but got \"${char}\"`);\n  }\n});",
    "i1_llama-3.3-70b-versatile": "it(\"should handle missing cidSystemInfo gracefully in composite fonts\", async () => {\n  const { createIdFactory } = await import(\"./test_utils.js\");\n  const evaluator = new (await import(\"../../src/core/evaluator.js\")).PartialEvaluator({\n    xref: {},\n    handler: {},\n    pageIndex: 0,\n    idFactory: createIdFactory(),\n    fontCache: new Map(),\n    builtInCMapCache: new Map(),\n    standardFontDataCache: new Map(),\n    globalImageCache: new Map(),\n    systemFontCache: new Map(),\n  });\n  const properties = {\n    composite: true,\n    cMap: { builtInCMap: false },\n    firstChar: 32,\n    lastChar: 127,\n    // Intentionally omitting cidSystemInfo to simulate problematic PDFs.\n  };\n  const toUnicodeMap = await evaluator.buildToUnicode(properties);\n  if (typeof toUnicodeMap.lookup !== \"function\") {\n    throw new Error(\"toUnicodeMap.lookup is not a function\");\n  }\n  const char = toUnicodeMap.lookup(65);\n  if (char !== \"A\") {\n    throw new Error(`Expected \"A\" for char code 65 but got \"${char}\"`);\n  }\n});",
    "i1_MOCK": "it(\"should handle missing cidSystemInfo gracefully in composite fonts\", async () => {\n  const { createIdFactory } = await import(\"./test_utils.js\");\n  const evaluator = new (await import(\"../../src/core/evaluator.js\")).PartialEvaluator({\n    xref: {},\n    handler: {},\n    pageIndex: 0,\n    idFactory: createIdFactory(),\n    fontCache: new Map(),\n    builtInCMapCache: new Map(),\n    standardFontDataCache: new Map(),\n    globalImageCache: new Map(),\n    systemFontCache: new Map(),\n  });\n  const properties = {\n    composite: true,\n    cMap: { builtInCMap: false },\n    firstChar: 32,\n    lastChar: 127,\n    // Intentionally omitting cidSystemInfo to simulate problematic PDFs.\n  };\n  const toUnicodeMap = await evaluator.buildToUnicode(properties);\n  if (typeof toUnicodeMap.lookup !== \"function\") {\n    throw new Error(\"toUnicodeMap.lookup is not a function\");\n  }\n  const char = toUnicodeMap.lookup(65);\n  if (char !== \"A\") {\n    throw new Error(`Expected \"A\" for char code 65 but got \"${char}\"`);\n  }\n});",
    "i2_deepseek-r1-distill-llama-70b": "it(\"should handle missing cidSystemInfo gracefully in composite fonts\", async () => {\n  const { createIdFactory } = await import(\"./test_utils.js\");\n  const evaluator = new (await import(\"../../src/core/evaluator.js\")).PartialEvaluator({\n    xref: {},\n    handler: {},\n    pageIndex: 0,\n    idFactory: createIdFactory(),\n    fontCache: new Map(),\n    builtInCMapCache: new Map(),\n    standardFontDataCache: new Map(),\n    globalImageCache: new Map(),\n    systemFontCache: new Map(),\n  });\n  const properties = {\n    composite: true,\n    cMap: { builtInCMap: false },\n    firstChar: 32,\n    lastChar: 127,\n    // Intentionally omitting cidSystemInfo to simulate problematic PDFs.\n  };\n  const toUnicodeMap = await evaluator.buildToUnicode(properties);\n  if (typeof toUnicodeMap.lookup !== \"function\") {\n    throw new Error(\"toUnicodeMap.lookup is not a function\");\n  }\n  const char = toUnicodeMap.lookup(65);\n  if (char !== \"A\") {\n    throw new Error(`Expected \"A\" for char code 65 but got \"${char}\"`);\n  }\n});",
    "i2_gpt-4o": "it(\"should handle missing cidSystemInfo gracefully in composite fonts\", async () => {\n  const { createIdFactory } = await import(\"./test_utils.js\");\n  const evaluator = new (await import(\"../../src/core/evaluator.js\")).PartialEvaluator({\n    xref: {},\n    handler: {},\n    pageIndex: 0,\n    idFactory: createIdFactory(),\n    fontCache: new Map(),\n    builtInCMapCache: new Map(),\n    standardFontDataCache: new Map(),\n    globalImageCache: new Map(),\n    systemFontCache: new Map(),\n  });\n  const properties = {\n    composite: true,\n    cMap: { builtInCMap: false },\n    firstChar: 32,\n    lastChar: 127,\n    // Intentionally omitting cidSystemInfo to simulate problematic PDFs.\n  };\n  const toUnicodeMap = await evaluator.buildToUnicode(properties);\n  if (typeof toUnicodeMap.lookup !== \"function\") {\n    throw new Error(\"toUnicodeMap.lookup is not a function\");\n  }\n  const char = toUnicodeMap.lookup(65);\n  if (char !== \"A\") {\n    throw new Error(`Expected \"A\" for char code 65 but got \"${char}\"`);\n  }\n});",
    "i2_llama-3.3-70b-versatile": "it(\"should handle missing cidSystemInfo gracefully in composite fonts\", async () => {\n  const { createIdFactory } = await import(\"./test_utils.js\");\n  const evaluator = new (await import(\"../../src/core/evaluator.js\")).PartialEvaluator({\n    xref: {},\n    handler: {},\n    pageIndex: 0,\n    idFactory: createIdFactory(),\n    fontCache: new Map(),\n    builtInCMapCache: new Map(),\n    standardFontDataCache: new Map(),\n    globalImageCache: new Map(),\n    systemFontCache: new Map(),\n  });\n  const properties = {\n    composite: true,\n    cMap: { builtInCMap: false },\n    firstChar: 32,\n    lastChar: 127,\n    // Intentionally omitting cidSystemInfo to simulate problematic PDFs.\n  };\n  const toUnicodeMap = await evaluator.buildToUnicode(properties);\n  if (typeof toUnicodeMap.lookup !== \"function\") {\n    throw new Error(\"toUnicodeMap.lookup is not a function\");\n  }\n  const char = toUnicodeMap.lookup(65);\n  if (char !== \"A\") {\n    throw new Error(`Expected \"A\" for char code 65 but got \"${char}\"`);\n  }\n});",
    "i3_deepseek-r1-distill-llama-70b": "it(\"should handle missing cidSystemInfo gracefully in composite fonts\", async () => {\n  const { createIdFactory } = await import(\"./test_utils.js\");\n  const evaluator = new (await import(\"../../src/core/evaluator.js\")).PartialEvaluator({\n    xref: {},\n    handler: {},\n    pageIndex: 0,\n    idFactory: createIdFactory(),\n    fontCache: new Map(),\n    builtInCMapCache: new Map(),\n    standardFontDataCache: new Map(),\n    globalImageCache: new Map(),\n    systemFontCache: new Map(),\n  });\n  const properties = {\n    composite: true,\n    cMap: { builtInCMap: false },\n    firstChar: 32,\n    lastChar: 127,\n    // Intentionally omitting cidSystemInfo to simulate problematic PDFs.\n  };\n  const toUnicodeMap = await evaluator.buildToUnicode(properties);\n  if (typeof toUnicodeMap.lookup !== \"function\") {\n    throw new Error(\"toUnicodeMap.lookup is not a function\");\n  }\n  const char = toUnicodeMap.lookup(65);\n  if (char !== \"A\") {\n    throw new Error(`Expected \"A\" for char code 65 but got \"${char}\"`);\n  }\n});",
    "i3_gpt-4o": "it(\"should handle missing cidSystemInfo gracefully in composite fonts\", async () => {\n  const { createIdFactory } = await import(\"./test_utils.js\");\n  const evaluator = new (await import(\"../../src/core/evaluator.js\")).PartialEvaluator({\n    xref: {},\n    handler: {},\n    pageIndex: 0,\n    idFactory: createIdFactory(),\n    fontCache: new Map(),\n    builtInCMapCache: new Map(),\n    standardFontDataCache: new Map(),\n    globalImageCache: new Map(),\n    systemFontCache: new Map(),\n  });\n  const properties = {\n    composite: true,\n    cMap: { builtInCMap: false },\n    firstChar: 32,\n    lastChar: 127,\n    // Intentionally omitting cidSystemInfo to simulate problematic PDFs.\n  };\n  const toUnicodeMap = await evaluator.buildToUnicode(properties);\n  if (typeof toUnicodeMap.lookup !== \"function\") {\n    throw new Error(\"toUnicodeMap.lookup is not a function\");\n  }\n  const char = toUnicodeMap.lookup(65);\n  if (char !== \"A\") {\n    throw new Error(`Expected \"A\" for char code 65 but got \"${char}\"`);\n  }\n});",
    "i3_llama-3.3-70b-versatile": "it(\"should handle missing cidSystemInfo gracefully in composite fonts\", async () => {\n  const { createIdFactory } = await import(\"./test_utils.js\");\n  const evaluator = new (await import(\"../../src/core/evaluator.js\")).PartialEvaluator({\n    xref: {},\n    handler: {},\n    pageIndex: 0,\n    idFactory: createIdFactory(),\n    fontCache: new Map(),\n    builtInCMapCache: new Map(),\n    standardFontDataCache: new Map(),\n    globalImageCache: new Map(),\n    systemFontCache: new Map(),\n  });\n  const properties = {\n    composite: true,\n    cMap: { builtInCMap: false },\n    firstChar: 32,\n    lastChar: 127,\n    // Intentionally omitting cidSystemInfo to simulate problematic PDFs.\n  };\n  const toUnicodeMap = await evaluator.buildToUnicode(properties);\n  if (typeof toUnicodeMap.lookup !== \"function\") {\n    throw new Error(\"toUnicodeMap.lookup is not a function\");\n  }\n  const char = toUnicodeMap.lookup(65);\n  if (char !== \"A\") {\n    throw new Error(`Expected \"A\" for char code 65 but got \"${char}\"`);\n  }\n});",
    "i4_deepseek-r1-distill-llama-70b": "it(\"should handle missing cidSystemInfo gracefully in composite fonts\", async () => {\n  const { createIdFactory } = await import(\"./test_utils.js\");\n  const evaluator = new (await import(\"../../src/core/evaluator.js\")).PartialEvaluator({\n    xref: {},\n    handler: {},\n    pageIndex: 0,\n    idFactory: createIdFactory(),\n    fontCache: new Map(),\n    builtInCMapCache: new Map(),\n    standardFontDataCache: new Map(),\n    globalImageCache: new Map(),\n    systemFontCache: new Map(),\n  });\n  const properties = {\n    composite: true,\n    cMap: { builtInCMap: false },\n    firstChar: 32,\n    lastChar: 127,\n    // Intentionally omitting cidSystemInfo to simulate problematic PDFs.\n  };\n  const toUnicodeMap = await evaluator.buildToUnicode(properties);\n  if (typeof toUnicodeMap.lookup !== \"function\") {\n    throw new Error(\"toUnicodeMap.lookup is not a function\");\n  }\n  const char = toUnicodeMap.lookup(65);\n  if (char !== \"A\") {\n    throw new Error(`Expected \"A\" for char code 65 but got \"${char}\"`);\n  }\n});",
    "i4_gpt-4o": "it(\"should handle missing cidSystemInfo gracefully in composite fonts\", async () => {\n  const { createIdFactory } = await import(\"./test_utils.js\");\n  const evaluator = new (await import(\"../../src/core/evaluator.js\")).PartialEvaluator({\n    xref: {},\n    handler: {},\n    pageIndex: 0,\n    idFactory: createIdFactory(),\n    fontCache: new Map(),\n    builtInCMapCache: new Map(),\n    standardFontDataCache: new Map(),\n    globalImageCache: new Map(),\n    systemFontCache: new Map(),\n  });\n  const properties = {\n    composite: true,\n    cMap: { builtInCMap: false },\n    firstChar: 32,\n    lastChar: 127,\n    // Intentionally omitting cidSystemInfo to simulate problematic PDFs.\n  };\n  const toUnicodeMap = await evaluator.buildToUnicode(properties);\n  if (typeof toUnicodeMap.lookup !== \"function\") {\n    throw new Error(\"toUnicodeMap.lookup is not a function\");\n  }\n  const char = toUnicodeMap.lookup(65);\n  if (char !== \"A\") {\n    throw new Error(`Expected \"A\" for char code 65 but got \"${char}\"`);\n  }\n});",
    "i4_llama-3.3-70b-versatile": "it(\"should handle missing cidSystemInfo gracefully in composite fonts\", async () => {\n  const { createIdFactory } = await import(\"./test_utils.js\");\n  const evaluator = new (await import(\"../../src/core/evaluator.js\")).PartialEvaluator({\n    xref: {},\n    handler: {},\n    pageIndex: 0,\n    idFactory: createIdFactory(),\n    fontCache: new Map(),\n    builtInCMapCache: new Map(),\n    standardFontDataCache: new Map(),\n    globalImageCache: new Map(),\n    systemFontCache: new Map(),\n  });\n  const properties = {\n    composite: true,\n    cMap: { builtInCMap: false },\n    firstChar: 32,\n    lastChar: 127,\n    // Intentionally omitting cidSystemInfo to simulate problematic PDFs.\n  };\n  const toUnicodeMap = await evaluator.buildToUnicode(properties);\n  if (typeof toUnicodeMap.lookup !== \"function\") {\n    throw new Error(\"toUnicodeMap.lookup is not a function\");\n  }\n  const char = toUnicodeMap.lookup(65);\n  if (char !== \"A\") {\n    throw new Error(`Expected \"A\" for char code 65 but got \"${char}\"`);\n  }\n});",
    "i5_deepseek-r1-distill-llama-70b": "it(\"should handle missing cidSystemInfo gracefully in composite fonts\", async () => {\n  const { createIdFactory } = await import(\"./test_utils.js\");\n  const evaluator = new (await import(\"../../src/core/evaluator.js\")).PartialEvaluator({\n    xref: {},\n    handler: {},\n    pageIndex: 0,\n    idFactory: createIdFactory(),\n    fontCache: new Map(),\n    builtInCMapCache: new Map(),\n    standardFontDataCache: new Map(),\n    globalImageCache: new Map(),\n    systemFontCache: new Map(),\n  });\n  const properties = {\n    composite: true,\n    cMap: { builtInCMap: false },\n    firstChar: 32,\n    lastChar: 127,\n    // Intentionally omitting cidSystemInfo to simulate problematic PDFs.\n  };\n  const toUnicodeMap = await evaluator.buildToUnicode(properties);\n  if (typeof toUnicodeMap.lookup !== \"function\") {\n    throw new Error(\"toUnicodeMap.lookup is not a function\");\n  }\n  const char = toUnicodeMap.lookup(65);\n  if (char !== \"A\") {\n    throw new Error(`Expected \"A\" for char code 65 but got \"${char}\"`);\n  }\n});",
    "i5_gpt-4o": "it(\"should handle missing cidSystemInfo gracefully in composite fonts\", async () => {\n  const { createIdFactory } = await import(\"./test_utils.js\");\n  const evaluator = new (await import(\"../../src/core/evaluator.js\")).PartialEvaluator({\n    xref: {},\n    handler: {},\n    pageIndex: 0,\n    idFactory: createIdFactory(),\n    fontCache: new Map(),\n    builtInCMapCache: new Map(),\n    standardFontDataCache: new Map(),\n    globalImageCache: new Map(),\n    systemFontCache: new Map(),\n  });\n  const properties = {\n    composite: true,\n    cMap: { builtInCMap: false },\n    firstChar: 32,\n    lastChar: 127,\n    // Intentionally omitting cidSystemInfo to simulate problematic PDFs.\n  };\n  const toUnicodeMap = await evaluator.buildToUnicode(properties);\n  if (typeof toUnicodeMap.lookup !== \"function\") {\n    throw new Error(\"toUnicodeMap.lookup is not a function\");\n  }\n  const char = toUnicodeMap.lookup(65);\n  if (char !== \"A\") {\n    throw new Error(`Expected \"A\" for char code 65 but got \"${char}\"`);\n  }\n});",
    "i5_llama-3.3-70b-versatile": "it(\"should handle missing cidSystemInfo gracefully in composite fonts\", async () => {\n  const { createIdFactory } = await import(\"./test_utils.js\");\n  const evaluator = new (await import(\"../../src/core/evaluator.js\")).PartialEvaluator({\n    xref: {},\n    handler: {},\n    pageIndex: 0,\n    idFactory: createIdFactory(),\n    fontCache: new Map(),\n    builtInCMapCache: new Map(),\n    standardFontDataCache: new Map(),\n    globalImageCache: new Map(),\n    systemFontCache: new Map(),\n  });\n  const properties = {\n    composite: true,\n    cMap: { builtInCMap: false },\n    firstChar: 32,\n    lastChar: 127,\n    // Intentionally omitting cidSystemInfo to simulate problematic PDFs.\n  };\n  const toUnicodeMap = await evaluator.buildToUnicode(properties);\n  if (typeof toUnicodeMap.lookup !== \"function\") {\n    throw new Error(\"toUnicodeMap.lookup is not a function\");\n  }\n  const char = toUnicodeMap.lookup(65);\n  if (char !== \"A\") {\n    throw new Error(`Expected \"A\" for char code 65 but got \"${char}\"`);\n  }\n});"
  },
  "17738": {
    "i1_deepseek-r1-distill-llama-70b": "it(\"should mark locked link annotations as clickable by ensuring datanoHTML is false\", async () => {\n  const { AnnotationFactory, AnnotationType } = await import(\"../../src/core/annotation.js\");\n  const dummyDict = {\n    get(key) {\n      if (key === \"Subtype\") {\n        return \"Link\";\n      }\n      return undefined;\n    }\n  };\n  const annotation = AnnotationFactory.create({\n    dict: dummyDict,\n    annotationGlobals: {},\n    rectangle: [0, 0, 10, 10],\n  });\n  if (annotation.data.annotationType !== AnnotationType.LINK) {\n    throw new Error(\"Annotation is not of type LINK\");\n  }\n  expect(annotation.data.noHTML).toBe(false);\n});\n",
    "i1_gpt-4o": "it(\"should mark locked link annotations as clickable by ensuring datanoHTML is false\", async () => {\n  const { AnnotationFactory, AnnotationType } = await import(\"../../src/core/annotation.js\");\n  const dummyDict = {\n    get(key) {\n      if (key === \"Subtype\") {\n        return \"Link\";\n      }\n      return undefined;\n    }\n  };\n  const annotation = AnnotationFactory.create({\n    dict: dummyDict,\n    annotationGlobals: {},\n    rectangle: [0, 0, 10, 10],\n  });\n  if (annotation.data.annotationType !== AnnotationType.LINK) {\n    throw new Error(\"Annotation is not of type LINK\");\n  }\n  expect(annotation.data.noHTML).toBe(false);\n});\n",
    "i1_llama-3.3-70b-versatile": "it(\"should mark locked link annotations as clickable by ensuring datanoHTML is false\", async () => {\n  const { AnnotationFactory, AnnotationType } = await import(\"../../src/core/annotation.js\");\n  const dummyDict = {\n    get(key) {\n      if (key === \"Subtype\") {\n        return \"Link\";\n      }\n      return undefined;\n    }\n  };\n  const annotation = AnnotationFactory.create({\n    dict: dummyDict,\n    annotationGlobals: {},\n    rectangle: [0, 0, 10, 10],\n  });\n  if (annotation.data.annotationType !== AnnotationType.LINK) {\n    throw new Error(\"Annotation is not of type LINK\");\n  }\n  expect(annotation.data.noHTML).toBe(false);\n});\n",
    "i1_MOCK": "it(\"should mark locked link annotations as clickable by ensuring datanoHTML is false\", async () => {\n  const { AnnotationFactory, AnnotationType } = await import(\"../../src/core/annotation.js\");\n  const dummyDict = {\n    get(key) {\n      if (key === \"Subtype\") {\n        return \"Link\";\n      }\n      return undefined;\n    }\n  };\n  const annotation = AnnotationFactory.create({\n    dict: dummyDict,\n    annotationGlobals: {},\n    rectangle: [0, 0, 10, 10],\n  });\n  if (annotation.data.annotationType !== AnnotationType.LINK) {\n    throw new Error(\"Annotation is not of type LINK\");\n  }\n  expect(annotation.data.noHTML).toBe(false);\n});\n",
    "i2_deepseek-r1-distill-llama-70b": "it(\"should mark locked link annotations as clickable by ensuring datanoHTML is false\", async () => {\n  const { AnnotationFactory, AnnotationType } = await import(\"../../src/core/annotation.js\");\n  const dummyDict = {\n    get(key) {\n      if (key === \"Subtype\") {\n        return \"Link\";\n      }\n      return undefined;\n    }\n  };\n  const annotation = AnnotationFactory.create({\n    dict: dummyDict,\n    annotationGlobals: {},\n    rectangle: [0, 0, 10, 10],\n  });\n  if (annotation.data.annotationType !== AnnotationType.LINK) {\n    throw new Error(\"Annotation is not of type LINK\");\n  }\n  expect(annotation.data.noHTML).toBe(false);\n});\n",
    "i2_gpt-4o": "it(\"should mark locked link annotations as clickable by ensuring datanoHTML is false\", async () => {\n  const { AnnotationFactory, AnnotationType } = await import(\"../../src/core/annotation.js\");\n  const dummyDict = {\n    get(key) {\n      if (key === \"Subtype\") {\n        return \"Link\";\n      }\n      return undefined;\n    }\n  };\n  const annotation = AnnotationFactory.create({\n    dict: dummyDict,\n    annotationGlobals: {},\n    rectangle: [0, 0, 10, 10],\n  });\n  if (annotation.data.annotationType !== AnnotationType.LINK) {\n    throw new Error(\"Annotation is not of type LINK\");\n  }\n  expect(annotation.data.noHTML).toBe(false);\n});\n",
    "i2_llama-3.3-70b-versatile": "it(\"should mark locked link annotations as clickable by ensuring datanoHTML is false\", async () => {\n  const { AnnotationFactory, AnnotationType } = await import(\"../../src/core/annotation.js\");\n  const dummyDict = {\n    get(key) {\n      if (key === \"Subtype\") {\n        return \"Link\";\n      }\n      return undefined;\n    }\n  };\n  const annotation = AnnotationFactory.create({\n    dict: dummyDict,\n    annotationGlobals: {},\n    rectangle: [0, 0, 10, 10],\n  });\n  if (annotation.data.annotationType !== AnnotationType.LINK) {\n    throw new Error(\"Annotation is not of type LINK\");\n  }\n  expect(annotation.data.noHTML).toBe(false);\n});\n",
    "i3_deepseek-r1-distill-llama-70b": "it(\"should mark locked link annotations as clickable by ensuring datanoHTML is false\", async () => {\n  const { AnnotationFactory, AnnotationType } = await import(\"../../src/core/annotation.js\");\n  const dummyDict = {\n    get(key) {\n      if (key === \"Subtype\") {\n        return \"Link\";\n      }\n      return undefined;\n    }\n  };\n  const annotation = AnnotationFactory.create({\n    dict: dummyDict,\n    annotationGlobals: {},\n    rectangle: [0, 0, 10, 10],\n  });\n  if (annotation.data.annotationType !== AnnotationType.LINK) {\n    throw new Error(\"Annotation is not of type LINK\");\n  }\n  expect(annotation.data.noHTML).toBe(false);\n});\n",
    "i3_gpt-4o": "it(\"should mark locked link annotations as clickable by ensuring datanoHTML is false\", async () => {\n  const { AnnotationFactory, AnnotationType } = await import(\"../../src/core/annotation.js\");\n  const dummyDict = {\n    get(key) {\n      if (key === \"Subtype\") {\n        return \"Link\";\n      }\n      return undefined;\n    }\n  };\n  const annotation = AnnotationFactory.create({\n    dict: dummyDict,\n    annotationGlobals: {},\n    rectangle: [0, 0, 10, 10],\n  });\n  if (annotation.data.annotationType !== AnnotationType.LINK) {\n    throw new Error(\"Annotation is not of type LINK\");\n  }\n  expect(annotation.data.noHTML).toBe(false);\n});\n",
    "i3_llama-3.3-70b-versatile": "it(\"should mark locked link annotations as clickable by ensuring datanoHTML is false\", async () => {\n  const { AnnotationFactory, AnnotationType } = await import(\"../../src/core/annotation.js\");\n  const dummyDict = {\n    get(key) {\n      if (key === \"Subtype\") {\n        return \"Link\";\n      }\n      return undefined;\n    }\n  };\n  const annotation = AnnotationFactory.create({\n    dict: dummyDict,\n    annotationGlobals: {},\n    rectangle: [0, 0, 10, 10],\n  });\n  if (annotation.data.annotationType !== AnnotationType.LINK) {\n    throw new Error(\"Annotation is not of type LINK\");\n  }\n  expect(annotation.data.noHTML).toBe(false);\n});\n",
    "i4_deepseek-r1-distill-llama-70b": "it(\"should mark locked link annotations as clickable by ensuring datanoHTML is false\", async () => {\n  const { AnnotationFactory, AnnotationType } = await import(\"../../src/core/annotation.js\");\n  const dummyDict = {\n    get(key) {\n      if (key === \"Subtype\") {\n        return \"Link\";\n      }\n      return undefined;\n    }\n  };\n  const annotation = AnnotationFactory.create({\n    dict: dummyDict,\n    annotationGlobals: {},\n    rectangle: [0, 0, 10, 10],\n  });\n  if (annotation.data.annotationType !== AnnotationType.LINK) {\n    throw new Error(\"Annotation is not of type LINK\");\n  }\n  expect(annotation.data.noHTML).toBe(false);\n});\n",
    "i4_gpt-4o": "it(\"should mark locked link annotations as clickable by ensuring datanoHTML is false\", async () => {\n  const { AnnotationFactory, AnnotationType } = await import(\"../../src/core/annotation.js\");\n  const dummyDict = {\n    get(key) {\n      if (key === \"Subtype\") {\n        return \"Link\";\n      }\n      return undefined;\n    }\n  };\n  const annotation = AnnotationFactory.create({\n    dict: dummyDict,\n    annotationGlobals: {},\n    rectangle: [0, 0, 10, 10],\n  });\n  if (annotation.data.annotationType !== AnnotationType.LINK) {\n    throw new Error(\"Annotation is not of type LINK\");\n  }\n  expect(annotation.data.noHTML).toBe(false);\n});\n",
    "i4_llama-3.3-70b-versatile": "it(\"should mark locked link annotations as clickable by ensuring datanoHTML is false\", async () => {\n  const { AnnotationFactory, AnnotationType } = await import(\"../../src/core/annotation.js\");\n  const dummyDict = {\n    get(key) {\n      if (key === \"Subtype\") {\n        return \"Link\";\n      }\n      return undefined;\n    }\n  };\n  const annotation = AnnotationFactory.create({\n    dict: dummyDict,\n    annotationGlobals: {},\n    rectangle: [0, 0, 10, 10],\n  });\n  if (annotation.data.annotationType !== AnnotationType.LINK) {\n    throw new Error(\"Annotation is not of type LINK\");\n  }\n  expect(annotation.data.noHTML).toBe(false);\n});\n",
    "i5_deepseek-r1-distill-llama-70b": "it(\"should mark locked link annotations as clickable by ensuring datanoHTML is false\", async () => {\n  const { AnnotationFactory, AnnotationType } = await import(\"../../src/core/annotation.js\");\n  const dummyDict = {\n    get(key) {\n      if (key === \"Subtype\") {\n        return \"Link\";\n      }\n      return undefined;\n    }\n  };\n  const annotation = AnnotationFactory.create({\n    dict: dummyDict,\n    annotationGlobals: {},\n    rectangle: [0, 0, 10, 10],\n  });\n  if (annotation.data.annotationType !== AnnotationType.LINK) {\n    throw new Error(\"Annotation is not of type LINK\");\n  }\n  expect(annotation.data.noHTML).toBe(false);\n});\n",
    "i5_gpt-4o": "it(\"should mark locked link annotations as clickable by ensuring datanoHTML is false\", async () => {\n  const { AnnotationFactory, AnnotationType } = await import(\"../../src/core/annotation.js\");\n  const dummyDict = {\n    get(key) {\n      if (key === \"Subtype\") {\n        return \"Link\";\n      }\n      return undefined;\n    }\n  };\n  const annotation = AnnotationFactory.create({\n    dict: dummyDict,\n    annotationGlobals: {},\n    rectangle: [0, 0, 10, 10],\n  });\n  if (annotation.data.annotationType !== AnnotationType.LINK) {\n    throw new Error(\"Annotation is not of type LINK\");\n  }\n  expect(annotation.data.noHTML).toBe(false);\n});\n",
    "i5_llama-3.3-70b-versatile": "it(\"should mark locked link annotations as clickable by ensuring datanoHTML is false\", async () => {\n  const { AnnotationFactory, AnnotationType } = await import(\"../../src/core/annotation.js\");\n  const dummyDict = {\n    get(key) {\n      if (key === \"Subtype\") {\n        return \"Link\";\n      }\n      return undefined;\n    }\n  };\n  const annotation = AnnotationFactory.create({\n    dict: dummyDict,\n    annotationGlobals: {},\n    rectangle: [0, 0, 10, 10],\n  });\n  if (annotation.data.annotationType !== AnnotationType.LINK) {\n    throw new Error(\"Annotation is not of type LINK\");\n  }\n  expect(annotation.data.noHTML).toBe(false);\n});\n"
  },
  "17768": {
    "i1_deepseek-r1-distill-llama-70b": "it(\"should record methodOfCreation as maintoolbar for free highlights\", async () => {\n  const {\n    loadAndWait,\n    getFirstSerialized,\n  } = await import(\"./test_utils.mjs\");\n  // Load a simple PDF that contains at least one page.\n  const page = await loadAndWait(\"trivial.pdf\");\n  // Simulate a free highlight creation by drawing on the page.\n  // Pick a starting point and an ending point within the page area.\n  await page.mouse.move(150, 150);\n  await page.mouse.down();\n  await page.mouse.move(250, 150);\n  await page.mouse.up();\n  // Wait a moment for the annotation to be processed and serialized.\n  const annotation = await getFirstSerialized(page);\n  if (annotation.methodOfCreation !== \"main_toolbar\") {\n    throw new Error(\n      \"Expected free highlight annotation to have methodOfCreation 'main_toolbar' but got: \" +\n        annotation.methodOfCreation\n    );\n  }\n});\n",
    "i1_gpt-4o": "it(\"should record methodOfCreation as maintoolbar for free highlights\", async () => {\n  const {\n    loadAndWait,\n    getFirstSerialized,\n  } = await import(\"./test_utils.mjs\");\n  // Load a simple PDF that contains at least one page.\n  const page = await loadAndWait(\"trivial.pdf\");\n  // Simulate a free highlight creation by drawing on the page.\n  // Pick a starting point and an ending point within the page area.\n  await page.mouse.move(150, 150);\n  await page.mouse.down();\n  await page.mouse.move(250, 150);\n  await page.mouse.up();\n  // Wait a moment for the annotation to be processed and serialized.\n  const annotation = await getFirstSerialized(page);\n  if (annotation.methodOfCreation !== \"main_toolbar\") {\n    throw new Error(\n      \"Expected free highlight annotation to have methodOfCreation 'main_toolbar' but got: \" +\n        annotation.methodOfCreation\n    );\n  }\n});\n",
    "i1_llama-3.3-70b-versatile": "it(\"should record methodOfCreation as maintoolbar for free highlights\", async () => {\n  const {\n    loadAndWait,\n    getFirstSerialized,\n  } = await import(\"./test_utils.mjs\");\n  // Load a simple PDF that contains at least one page.\n  const page = await loadAndWait(\"trivial.pdf\");\n  // Simulate a free highlight creation by drawing on the page.\n  // Pick a starting point and an ending point within the page area.\n  await page.mouse.move(150, 150);\n  await page.mouse.down();\n  await page.mouse.move(250, 150);\n  await page.mouse.up();\n  // Wait a moment for the annotation to be processed and serialized.\n  const annotation = await getFirstSerialized(page);\n  if (annotation.methodOfCreation !== \"main_toolbar\") {\n    throw new Error(\n      \"Expected free highlight annotation to have methodOfCreation 'main_toolbar' but got: \" +\n        annotation.methodOfCreation\n    );\n  }\n});\n",
    "i1_MOCK": "it(\"should record methodOfCreation as maintoolbar for free highlights\", async () => {\n  const {\n    loadAndWait,\n    getFirstSerialized,\n  } = await import(\"./test_utils.mjs\");\n  // Load a simple PDF that contains at least one page.\n  const page = await loadAndWait(\"trivial.pdf\");\n  // Simulate a free highlight creation by drawing on the page.\n  // Pick a starting point and an ending point within the page area.\n  await page.mouse.move(150, 150);\n  await page.mouse.down();\n  await page.mouse.move(250, 150);\n  await page.mouse.up();\n  // Wait a moment for the annotation to be processed and serialized.\n  const annotation = await getFirstSerialized(page);\n  if (annotation.methodOfCreation !== \"main_toolbar\") {\n    throw new Error(\n      \"Expected free highlight annotation to have methodOfCreation 'main_toolbar' but got: \" +\n        annotation.methodOfCreation\n    );\n  }\n});\n",
    "i2_deepseek-r1-distill-llama-70b": "it(\"should record methodOfCreation as maintoolbar for free highlights\", async () => {\n  const {\n    loadAndWait,\n    getFirstSerialized,\n  } = await import(\"./test_utils.mjs\");\n  // Load a simple PDF that contains at least one page.\n  const page = await loadAndWait(\"trivial.pdf\");\n  // Simulate a free highlight creation by drawing on the page.\n  // Pick a starting point and an ending point within the page area.\n  await page.mouse.move(150, 150);\n  await page.mouse.down();\n  await page.mouse.move(250, 150);\n  await page.mouse.up();\n  // Wait a moment for the annotation to be processed and serialized.\n  const annotation = await getFirstSerialized(page);\n  if (annotation.methodOfCreation !== \"main_toolbar\") {\n    throw new Error(\n      \"Expected free highlight annotation to have methodOfCreation 'main_toolbar' but got: \" +\n        annotation.methodOfCreation\n    );\n  }\n});\n",
    "i2_gpt-4o": "it(\"should record methodOfCreation as maintoolbar for free highlights\", async () => {\n  const {\n    loadAndWait,\n    getFirstSerialized,\n  } = await import(\"./test_utils.mjs\");\n  // Load a simple PDF that contains at least one page.\n  const page = await loadAndWait(\"trivial.pdf\");\n  // Simulate a free highlight creation by drawing on the page.\n  // Pick a starting point and an ending point within the page area.\n  await page.mouse.move(150, 150);\n  await page.mouse.down();\n  await page.mouse.move(250, 150);\n  await page.mouse.up();\n  // Wait a moment for the annotation to be processed and serialized.\n  const annotation = await getFirstSerialized(page);\n  if (annotation.methodOfCreation !== \"main_toolbar\") {\n    throw new Error(\n      \"Expected free highlight annotation to have methodOfCreation 'main_toolbar' but got: \" +\n        annotation.methodOfCreation\n    );\n  }\n});\n",
    "i2_llama-3.3-70b-versatile": "it(\"should record methodOfCreation as maintoolbar for free highlights\", async () => {\n  const {\n    loadAndWait,\n    getFirstSerialized,\n  } = await import(\"./test_utils.mjs\");\n  // Load a simple PDF that contains at least one page.\n  const page = await loadAndWait(\"trivial.pdf\");\n  // Simulate a free highlight creation by drawing on the page.\n  // Pick a starting point and an ending point within the page area.\n  await page.mouse.move(150, 150);\n  await page.mouse.down();\n  await page.mouse.move(250, 150);\n  await page.mouse.up();\n  // Wait a moment for the annotation to be processed and serialized.\n  const annotation = await getFirstSerialized(page);\n  if (annotation.methodOfCreation !== \"main_toolbar\") {\n    throw new Error(\n      \"Expected free highlight annotation to have methodOfCreation 'main_toolbar' but got: \" +\n        annotation.methodOfCreation\n    );\n  }\n});\n",
    "i3_deepseek-r1-distill-llama-70b": "it(\"should record methodOfCreation as maintoolbar for free highlights\", async () => {\n  const {\n    loadAndWait,\n    getFirstSerialized,\n  } = await import(\"./test_utils.mjs\");\n  // Load a simple PDF that contains at least one page.\n  const page = await loadAndWait(\"trivial.pdf\");\n  // Simulate a free highlight creation by drawing on the page.\n  // Pick a starting point and an ending point within the page area.\n  await page.mouse.move(150, 150);\n  await page.mouse.down();\n  await page.mouse.move(250, 150);\n  await page.mouse.up();\n  // Wait a moment for the annotation to be processed and serialized.\n  const annotation = await getFirstSerialized(page);\n  if (annotation.methodOfCreation !== \"main_toolbar\") {\n    throw new Error(\n      \"Expected free highlight annotation to have methodOfCreation 'main_toolbar' but got: \" +\n        annotation.methodOfCreation\n    );\n  }\n});\n",
    "i3_gpt-4o": "it(\"should record methodOfCreation as maintoolbar for free highlights\", async () => {\n  const {\n    loadAndWait,\n    getFirstSerialized,\n  } = await import(\"./test_utils.mjs\");\n  // Load a simple PDF that contains at least one page.\n  const page = await loadAndWait(\"trivial.pdf\");\n  // Simulate a free highlight creation by drawing on the page.\n  // Pick a starting point and an ending point within the page area.\n  await page.mouse.move(150, 150);\n  await page.mouse.down();\n  await page.mouse.move(250, 150);\n  await page.mouse.up();\n  // Wait a moment for the annotation to be processed and serialized.\n  const annotation = await getFirstSerialized(page);\n  if (annotation.methodOfCreation !== \"main_toolbar\") {\n    throw new Error(\n      \"Expected free highlight annotation to have methodOfCreation 'main_toolbar' but got: \" +\n        annotation.methodOfCreation\n    );\n  }\n});\n",
    "i3_llama-3.3-70b-versatile": "it(\"should record methodOfCreation as maintoolbar for free highlights\", async () => {\n  const {\n    loadAndWait,\n    getFirstSerialized,\n  } = await import(\"./test_utils.mjs\");\n  // Load a simple PDF that contains at least one page.\n  const page = await loadAndWait(\"trivial.pdf\");\n  // Simulate a free highlight creation by drawing on the page.\n  // Pick a starting point and an ending point within the page area.\n  await page.mouse.move(150, 150);\n  await page.mouse.down();\n  await page.mouse.move(250, 150);\n  await page.mouse.up();\n  // Wait a moment for the annotation to be processed and serialized.\n  const annotation = await getFirstSerialized(page);\n  if (annotation.methodOfCreation !== \"main_toolbar\") {\n    throw new Error(\n      \"Expected free highlight annotation to have methodOfCreation 'main_toolbar' but got: \" +\n        annotation.methodOfCreation\n    );\n  }\n});\n",
    "i4_deepseek-r1-distill-llama-70b": "it(\"should record methodOfCreation as maintoolbar for free highlights\", async () => {\n  const {\n    loadAndWait,\n    getFirstSerialized,\n  } = await import(\"./test_utils.mjs\");\n  // Load a simple PDF that contains at least one page.\n  const page = await loadAndWait(\"trivial.pdf\");\n  // Simulate a free highlight creation by drawing on the page.\n  // Pick a starting point and an ending point within the page area.\n  await page.mouse.move(150, 150);\n  await page.mouse.down();\n  await page.mouse.move(250, 150);\n  await page.mouse.up();\n  // Wait a moment for the annotation to be processed and serialized.\n  const annotation = await getFirstSerialized(page);\n  if (annotation.methodOfCreation !== \"main_toolbar\") {\n    throw new Error(\n      \"Expected free highlight annotation to have methodOfCreation 'main_toolbar' but got: \" +\n        annotation.methodOfCreation\n    );\n  }\n});\n",
    "i4_gpt-4o": "it(\"should record methodOfCreation as maintoolbar for free highlights\", async () => {\n  const {\n    loadAndWait,\n    getFirstSerialized,\n  } = await import(\"./test_utils.mjs\");\n  // Load a simple PDF that contains at least one page.\n  const page = await loadAndWait(\"trivial.pdf\");\n  // Simulate a free highlight creation by drawing on the page.\n  // Pick a starting point and an ending point within the page area.\n  await page.mouse.move(150, 150);\n  await page.mouse.down();\n  await page.mouse.move(250, 150);\n  await page.mouse.up();\n  // Wait a moment for the annotation to be processed and serialized.\n  const annotation = await getFirstSerialized(page);\n  if (annotation.methodOfCreation !== \"main_toolbar\") {\n    throw new Error(\n      \"Expected free highlight annotation to have methodOfCreation 'main_toolbar' but got: \" +\n        annotation.methodOfCreation\n    );\n  }\n});\n",
    "i4_llama-3.3-70b-versatile": "it(\"should record methodOfCreation as maintoolbar for free highlights\", async () => {\n  const {\n    loadAndWait,\n    getFirstSerialized,\n  } = await import(\"./test_utils.mjs\");\n  // Load a simple PDF that contains at least one page.\n  const page = await loadAndWait(\"trivial.pdf\");\n  // Simulate a free highlight creation by drawing on the page.\n  // Pick a starting point and an ending point within the page area.\n  await page.mouse.move(150, 150);\n  await page.mouse.down();\n  await page.mouse.move(250, 150);\n  await page.mouse.up();\n  // Wait a moment for the annotation to be processed and serialized.\n  const annotation = await getFirstSerialized(page);\n  if (annotation.methodOfCreation !== \"main_toolbar\") {\n    throw new Error(\n      \"Expected free highlight annotation to have methodOfCreation 'main_toolbar' but got: \" +\n        annotation.methodOfCreation\n    );\n  }\n});\n",
    "i5_deepseek-r1-distill-llama-70b": "it(\"should record methodOfCreation as maintoolbar for free highlights\", async () => {\n  const {\n    loadAndWait,\n    getFirstSerialized,\n  } = await import(\"./test_utils.mjs\");\n  // Load a simple PDF that contains at least one page.\n  const page = await loadAndWait(\"trivial.pdf\");\n  // Simulate a free highlight creation by drawing on the page.\n  // Pick a starting point and an ending point within the page area.\n  await page.mouse.move(150, 150);\n  await page.mouse.down();\n  await page.mouse.move(250, 150);\n  await page.mouse.up();\n  // Wait a moment for the annotation to be processed and serialized.\n  const annotation = await getFirstSerialized(page);\n  if (annotation.methodOfCreation !== \"main_toolbar\") {\n    throw new Error(\n      \"Expected free highlight annotation to have methodOfCreation 'main_toolbar' but got: \" +\n        annotation.methodOfCreation\n    );\n  }\n});\n",
    "i5_gpt-4o": "it(\"should record methodOfCreation as maintoolbar for free highlights\", async () => {\n  const {\n    loadAndWait,\n    getFirstSerialized,\n  } = await import(\"./test_utils.mjs\");\n  // Load a simple PDF that contains at least one page.\n  const page = await loadAndWait(\"trivial.pdf\");\n  // Simulate a free highlight creation by drawing on the page.\n  // Pick a starting point and an ending point within the page area.\n  await page.mouse.move(150, 150);\n  await page.mouse.down();\n  await page.mouse.move(250, 150);\n  await page.mouse.up();\n  // Wait a moment for the annotation to be processed and serialized.\n  const annotation = await getFirstSerialized(page);\n  if (annotation.methodOfCreation !== \"main_toolbar\") {\n    throw new Error(\n      \"Expected free highlight annotation to have methodOfCreation 'main_toolbar' but got: \" +\n        annotation.methodOfCreation\n    );\n  }\n});\n",
    "i5_llama-3.3-70b-versatile": "it(\"should record methodOfCreation as maintoolbar for free highlights\", async () => {\n  const {\n    loadAndWait,\n    getFirstSerialized,\n  } = await import(\"./test_utils.mjs\");\n  // Load a simple PDF that contains at least one page.\n  const page = await loadAndWait(\"trivial.pdf\");\n  // Simulate a free highlight creation by drawing on the page.\n  // Pick a starting point and an ending point within the page area.\n  await page.mouse.move(150, 150);\n  await page.mouse.down();\n  await page.mouse.move(250, 150);\n  await page.mouse.up();\n  // Wait a moment for the annotation to be processed and serialized.\n  const annotation = await getFirstSerialized(page);\n  if (annotation.methodOfCreation !== \"main_toolbar\") {\n    throw new Error(\n      \"Expected free highlight annotation to have methodOfCreation 'main_toolbar' but got: \" +\n        annotation.methodOfCreation\n    );\n  }\n});\n"
  },
  "17788": {
    "i1_deepseek-r1-distill-llama-70b": "it(\"should make highlighted text accessible to screen readers\", async () => {\n  const { PDFWorker } = await import(\"../../src/display/api.js\");\n  const { AnnotationEditorUIManager } = await import(\"../../src/display/editor/tools.js\");\n  const { DrawLayer } = await import(\"../../src/display/draw_layer.js\");\n  const { AnnotationEditorLayer } = await import(\"../../src/display/editor/annotation_editor_layer.js\");\n\n  // Setup PDF worker and document\n  const pdfWorker = await PDFWorker.create();\n  const pdfDoc = await pdfWorker.getPDFDocument(\"test.pdf\");\n  const page = await pdfDoc.getPage(1);\n  const viewport = page.getViewport({ scale: 1 });\n\n  // Setup UI components\n  const container = document.createElement(\"div\");\n  const editorLayer = new AnnotationEditorLayer(viewport);\n  const uiManager = new AnnotationEditorUIManager(container, viewport, null, null, pdfDoc, null, null, null);\n\n  // Create a selection and highlight it\n  const selection = document.getSelection();\n  selection.selectAllChildren(document.createElement(\"div\"));\n  const range = document.createRange();\n  range.selectNodeText(document.createTextNode(\"Test Highlight\"));\n\n  // Simulate highlight creation\n  const highlightEditor = new (await import(\"../../src/display/editor/highlight.js\").then(c => c.HighlightEditor));\n  highlightEditor.constructor({\n    methodOfCreation: \"test\",\n    anchorNode: range.startContainer,\n    anchorOffset: 0,\n    focusNode: range.endContainer,\n    focusOffset: 1,\n    boxes: [],\n    color: \"#ffff00\",\n    thickness: 2,\n    opacity: 1\n  });\n\n  // Verify accessibility structure\n  const highlightDiv = editorLayer.highlightDiv;\n  const markElement = highlightDiv.querySelector(\"mark.visuallyHidden\");\n  const svgElements = highlightDiv.querySelectorAll(\"svg\");\n\n  expect(markElement).toBeTruthy();\n  expect(markElement.textContent).toBe(\"Test Highlight\");\n  expect(svgElements.length > 0);\n  svgElements.forEach(svg => {\n    expect(svg.getAttribute(\"aria-hidden\")).toBe(\"true\");\n  });\n});",
    "i1_gpt-4o": "it(\"should read highlighted text during editing inside a PDF\", async () => {\n  const { AnnotationEditorUIManager } = await import(\"../../src/display/editor/tools.js\");\n  const { HighlightEditor } = await import(\"../../src/display/editor/highlight.js\");\n  const { EventBus } = await import(\"../../web/event_utils.js\");\n\n  const eventBus = new EventBus();\n  const container = document.createElement(\"div\");\n  const viewer = document.createElement(\"div\");\n  container.appendChild(viewer);\n\n  const uiManager = new AnnotationEditorUIManager(container, viewer, null, eventBus, null, null, null, null);\n  uiManager.#mode = AnnotationEditorType.HIGHLIGHT;\n\n  const textLayer = document.createElement(\"div\");\n  textLayer.className = \"textLayer\";\n  viewer.appendChild(textLayer);\n\n  const textNode = document.createTextNode(\"Highlighted text\");\n  textLayer.appendChild(textNode);\n\n  const range = document.createRange();\n  range.selectNodeContents(textNode);\n  const selection = window.getSelection();\n  selection.removeAllRanges();\n  selection.addRange(range);\n\n  uiManager.highlightSelection();\n\n  const highlightEditor = new HighlightEditor({\n    anchorNode: textNode,\n    anchorOffset: 0,\n    focusNode: textNode,\n    focusOffset: textNode.length,\n    text: \"Highlighted text\",\n  });\n\n  const div = highlightEditor.render();\n  const mark = div.querySelector(\"mark.visuallyHidden\");\n  const actualText = mark ? mark.textContent : null;\n\n  expect(actualText).toBe(\"Highlighted text\");\n});",
    "i1_llama-3.3-70b-versatile": "it(\"should read highlighted text during editing inside a PDF\", async () => {\n  const { PDFDocument, PDFPageProxy } = await import(\"../../src/display/api.js\");\n  const { DOMSVGFactory } = await import(\"../../src/display/display_utils.js\");\n  const { AnnotationEditorUIManager } = await import(\"../../src/display/editor/tools.js\");\n  const { HighlightEditor } = await import(\"../../src/display/editor/highlight.js\");\n  const pdfDocument = await PDFDocument.load(await fetch(\"test.pdf\").then(response => response.arrayBuffer()));\n  const pdfPage = await pdfDocument.getPage(1);\n  const annotationEditorUIManager = new AnnotationEditorUIManager(null, null, null, null, pdfDocument, null, null, null);\n  const highlightEditor = new HighlightEditor({ anchorNode: null, anchorOffset: 0, focusNode: null, focusOffset: 0, boxes: null, methodOfCreation: \"\" });\n  const div = highlightEditor.render();\n  const mark = div.querySelector(\"mark\");\n  const text = \"Example highlighted text\";\n  mark.append(document.createTextNode(text));\n  const voiceOverText = await getVoiceOverText(div);\n  expect(voiceOverText).toBe(text);\n});\n\nasync function getVoiceOverText(element) {\n  // This function should return the text that would be read by Voice Over\n  // For the purpose of this test, we'll assume it's the text content of the mark element\n  return element.querySelector(\"mark\").textContent;\n}",
    "i2_deepseek-r1-distill-llama-70b": "it(\"should have accessible highlighted text for screen readers\", async () => {\n  const { PDFDocument } = await import(\"../../src/display/api.js\");\n  const { PDFPage } = await import(\"../../src/display/display_utils.js\");\n  const { TextLayer } = await import(\"../../src/display/text_layer.js\");\n  const { HighlightEditor } = await import(\"../../src/display/editor/highlight.js\");\n\n  // Create a simple PDF with a page containing text\n  const pdf = new PDFDocument({\n    content: [\n      \"1 0 0 1 0 0 cm\",\n      \"/F1 12 Tf\",\n      \"(Hello World!) Tj\",\n      \"ET\",\n    ],\n  });\n\n  const page = new PDFPage(pdf, 0);\n  const textLayer = new TextLayer({\n    pageIndex: 0,\n    container: document.createElement(\"div\"),\n  });\n\n  // Render the text layer\n  await textLayer.render();\n\n  // Create a selection for the highlighted text\n  const selection = document.getSelection();\n  selection.removeRange(selection.getRangeAt(0));\n  const range = document.createRange();\n  range.selectNodeContents(textLayer.div);\n  selection.addRange(range);\n\n  // Create the highlight editor\n  const highlightEditor = new HighlightEditor({\n    anchorNode: range.startContainer,\n    anchorOffset: 0,\n    focusNode: range.endContainer,\n    focusOffset: range.endOffset,\n    boxes: [],\n    methodOfCreation: \"keyboard\",\n    text: \"Hello World!\",\n  });\n\n  // Render the highlight editor\n  const highlightDiv = highlightEditor.render();\n\n  // Check for the accessible text element\n  const markElement = highlightDiv.querySelector(\"mark.visuallyHidden\");\n  expect(markElement).toBeTruthy();\n  expect(markElement.textContent).toBe(\"Hello World!\");\n});",
    "i2_gpt-4o": "it(\"should make highlighted text accessible to Voice Over\", async () => {\n  const { AnnotationEditorUIManager } = await import(\"../../src/display/editor/tools.js\");\n  const { HighlightEditor } = await import(\"../../src/display/editor/highlight.js\");\n\n  const container = document.createElement(\"div\");\n  const viewer = document.createElement(\"div\");\n  const eventBus = { _on: () => {} };\n  const pdfDocument = { annotationStorage: {}, filterFactory: {} };\n  const pageColors = {};\n  const highlightColors = new Map();\n\n  const uiManager = new AnnotationEditorUIManager(\n    container,\n    viewer,\n    null,\n    eventBus,\n    pdfDocument,\n    pageColors,\n    highlightColors,\n    null\n  );\n\n  const textLayer = document.createElement(\"div\");\n  textLayer.className = \"textLayer\";\n  const textNode = document.createTextNode(\"Sample text\");\n  textLayer.appendChild(textNode);\n  document.body.appendChild(textLayer);\n\n  const selection = window.getSelection();\n  const range = document.createRange();\n  range.selectNodeContents(textNode);\n  selection.removeAllRanges();\n  selection.addRange(range);\n\n  uiManager.highlightSelection();\n\n  const highlightEditor = new HighlightEditor({\n    anchorNode: textNode,\n    anchorOffset: 0,\n    focusNode: textNode,\n    focusOffset: textNode.length,\n    boxes: [],\n    methodOfCreation: \"\",\n  });\n\n  const div = highlightEditor.render();\n  const mark = div.querySelector(\"mark\");\n  const isAriaHidden = mark && mark.className === \"visuallyHidden\";\n\n  expect(isAriaHidden).toBe(true);\n});",
    "i2_llama-3.3-70b-versatile": "it(\"should read highlighted text during editing inside a PDF\", async () => {\n  const { PDFPageProxy } = await import(\"../../src/display/api.js\");\n  const { AnnotationEditorUIManager } = await import(\"../../src/display/editor/tools.js\");\n  const { PDFDocumentProxy } = await import(\"../../src/display/api.js\");\n  const { getSelectionBoxes } = await import(\"../../src/display/editor/tools.js\");\n\n  const pdfDocument = await PDFDocumentProxy.load(\"path_to_pdf_file\");\n  const pdfPage = await pdfDocument.getPage(1);\n  const annotationStorage = pdfPage.annotationStorage;\n  const container = document.createElement(\"div\");\n  const viewer = { container };\n  const eventBus = { _on: () => {} };\n  const altTextManager = {};\n  const pageColors = {};\n  const highlightColors = {};\n  const mlManager = {};\n\n  const uiManager = new AnnotationEditorUIManager(\n    container,\n    viewer,\n    altTextManager,\n    eventBus,\n    pdfDocument,\n    pageColors,\n    highlightColors,\n    mlManager\n  );\n\n  const selection = {\n    anchorNode: { nodeType: 1, parentElement: { closest: () => ({}) } },\n    anchorOffset: 0,\n    focusNode: { nodeType: 1, parentElement: { closest: () => ({}) } },\n    focusOffset: 0,\n    empty: () => {},\n    isCollapsed: false,\n    toString: () => \"Highlighted text\",\n  };\n\n  const originalGetSelection = document.getSelection;\n  document.getSelection = () => selection;\n\n  uiManager.highlightSelection();\n\n  const expectedText = \"Highlighted text\";\n  const actualText = await getHighlightedText();\n\n  function getHighlightedText() {\n    return new Promise((resolve) => {\n      const intervalId = setInterval(() => {\n        const highlightedText = document.querySelector(\".visuallyHidden\");\n        if (highlightedText) {\n          clearInterval(intervalId);\n          resolve(highlightedText.textContent);\n        }\n      }, 100);\n    });\n  }\n\n  await new Promise((resolve) => setTimeout(resolve, 1000));\n\n  document.getSelection = originalGetSelection;\n\n  expect(actualText).toBe(expectedText);\n});",
    "i3_deepseek-r1-distill-llama-70b": "it(\"should expose highlighted text to screen readers\", async () => {\n  const { getDocument } = await import(\"../../src/display/api.js\");\n  const { AnnotationEditorUIManager } = await import(\"../../src/display/editor/tools.js\");\n  const { Util } = await import(\"../../src/shared/util.js\");\n\n  const pdfData = new TextEncoder().encode(\n    \"%PDF-1.3\\n\" +\n    \"1 0 obj\\n\" +\n    \"<</Type /Catalog /Pages 2 0 R>>\\n\" +\n    \"2 0 obj\\n\" +\n    \"<</Type /Pages /Kids [3 0 R] /Count 1 /Resources 4 0 R>>\\n\" +\n    \"3 0 obj\\n\" +\n    \"<</Type /Page /Parent 2 0 R /Resources 4 0 R /Contents 5 0 R>>\\n\" +\n    \"4 0 obj\\n\" +\n    \"<</ProcSet [/PDF /Text]>>\\n\" +\n    \"5 0 obj\\n\" +\n    \"<</Length 6 0 R>>\\n\" +\n    \"6 0 obj\\n\" +\n    new TextEncoder().encode(\"BT\\n/F1 24 Tf\\n120 600 Td\\n(Hello World!) Tj\\nET\\n\") +\n    \"\\n\";\n\n  const pdfBlob = new Blob([pdfData], { type: \"application/pdf\" });\n  const pdfUrl = URL.createObjectURL(pdfBlob);\n\n  const pdf = await getDocument({\n    data: pdfBlob,\n    url: pdfUrl,\n    CMapLoader: null,\n  });\n\n  const container = document.createElement(\"div\");\n  document.body.appendChild(container);\n\n  const editorUI = new AnnotationEditorUIManager(\n    container,\n    null,\n    null,\n    null,\n    pdf,\n    null,\n    null,\n    null\n  );\n\n  const annotationLayer = new AnnotationLayer();\n  container.appendChild(annotationLayer.render());\n\n  const page = pdf.getPage(1);\n  const viewport = page.getViewport({ scale: 1 });\n\n  const textLayer = document.createElement(\"div\");\n  textLayer.className = \"textLayer\";\n  textLayer.style.width = `${viewport.width}px`;\n  textLayer.style.height = `${viewport.height}px`;\n  container.appendChild(textLayer);\n\n  await pdf.load();\n\n  // Simulate text selection\n  const selection = window.getSelection();\n  const range = document.createRange();\n  const textNode = document.createTextNode(\"Hello World!\");\n  textLayer.appendChild(textNode);\n  range.selectNodeContents(textNode);\n  selection.removeAllRanges();\n  selection.addRange(range);\n\n  editorUI.highlightSelection(\"main_toolbar\");\n\n  // Check that the highlighted text is exposed in the DOM\n  const highlightDiv = textLayer.querySelector(\"mark.visuallyHidden\");\n  expect(highlightDiv).toBeTruthy();\n\n  const expectedText = \"Hello World!\";\n  expect(highlightDiv?.textContent).toBe(expectedText);\n});",
    "i3_gpt-4o": "it(\"should read highlighted text during editing inside a PDF\", async () => {\n  const { HighlightEditor } = await import(\"../../src/display/editor/highlight.js\");\n  const { AnnotationEditorUIManager } = await import(\"../../src/display/editor/tools.js\");\n  const { EventBus } = await import(\"../../web/event_utils.js\");\n\n  const eventBus = new EventBus();\n  const uiManager = new AnnotationEditorUIManager(null, null, null, eventBus, null, null, null, null);\n  const highlightEditor = new HighlightEditor({\n    color: \"#FFFF00\",\n    opacity: 1,\n    boxes: [{ x: 0, y: 0, width: 1, height: 1 }],\n    anchorNode: document.createTextNode(\"highlighted text\"),\n    anchorOffset: 0,\n    focusNode: document.createTextNode(\"highlighted text\"),\n    focusOffset: 16,\n    uiManager,\n  });\n\n  const div = highlightEditor.render();\n  document.body.appendChild(div);\n\n  const mark = div.querySelector(\"mark\");\n  const isAriaHidden = mark.getAttribute(\"aria-hidden\") === \"true\";\n  const isVisuallyHidden = mark.classList.contains(\"visuallyHidden\");\n\n  document.body.removeChild(div);\n\n  expect(isAriaHidden).toBe(false);\n  expect(isVisuallyHidden).toBe(true);\n});",
    "i3_llama-3.3-70b-versatile": "it(\"should read highlighted text during editing inside a PDF\", async () => {\n  const { PDFWorker, build, getDocument } = await import(\"../../src/display/api.js\");\n  const { DOMSVGFactory } = await import(\"../../src/display/display_utils.js\");\n  const { DrawLayer } = await import(\"../../src/display/draw_layer.js\");\n  const { HighlightEditor } = await import(\"../../src/display/editor/highlight.js\");\n  const { AnnotationEditorUIManager } = await import(\"../../src/display/editor/tools.js\");\n\n  const pdfUrl = \"https://example.com/example.pdf\";\n  const pdf = await getDocument({ url: pdfUrl });\n  const pdfWorker = new PDFWorker();\n  const annotationEditorUIManager = new AnnotationEditorUIManager();\n\n  const drawLayer = new DrawLayer();\n  const highlightEditor = new HighlightEditor({});\n\n  const highlightedText = \"This is a highlighted text\";\n  drawLayer.highlight(highlightEditor.#highlightOutlines, \"yellow\", 0.5);\n  const highlightedElement = drawLayer.#mapping.get(highlightEditor.#id);\n\n  const expectedText = highlightedText;\n  const actualText = highlightedElement.querySelector(\"mark\").textContent;\n\n  expect(actualText).toBe(expectedText);\n});",
    "i4_deepseek-r1-distill-llama-70b": "it(\"should allow Voice Over to read highlighted text during editing\", async () => {\n  const { PDFDocument } = await import(\"../../src/core/pdf_document.js\");\n  const { TextLayer } = await import(\"../../src/display/text_layer.js\");\n  const { DrawLayer } = await import(\"../../src/display/draw_layer.js\");\n  const { HighlightEditor } = await import(\"../../src/display/editor/highlight.js\");\n\n  // Set up a minimal test PDF\n  const pdfBytes = new Uint8Array([0x25, 0x50, 0x44, 0x46]);\n  const pdf = await PDFDocument.load(pdfBytes, { isEvalSupported: false });\n\n  // Create a text layer with some content\n  const text = \"Hello World\";\n  const textLayer = new TextLayer();\n  textLayer.setText(text);\n\n  // Create a highlight editor\n  const highlightEditor = new HighlightEditor({\n    text: text,\n    color: \"#FFFF98\",\n    opacity: 1,\n    thickness: 12,\n    methodOfCreation: \"main_toolbar\",\n  });\n\n  // Render the highlight\n  const highlightDiv = highlightEditor.render();\n\n  // Check for the visually hidden mark element\n  const markElement = highlightDiv.querySelector(\".visuallyHidden\");\n  expect(markElement).toBeTruthy();\n  expect(markElement.textContent).toBe(text);\n});",
    "i4_gpt-4o": "it(\"should read highlighted text during editing inside a PDF\", async () => {\n  const { HighlightEditor } = await import(\"../../src/display/editor/highlight.js\");\n  const { AnnotationEditorUIManager } = await import(\"../../src/display/editor/tools.js\");\n\n  const mockParent = {\n    drawLayer: {\n      highlight: jest.fn().mockReturnValue({ id: 1, clipPathId: \"clipPathId\" }),\n      highlightOutline: jest.fn().mockReturnValue(2),\n      remove: jest.fn(),\n      updateLine: jest.fn(),\n      updateBox: jest.fn(),\n      show: jest.fn(),\n      addClass: jest.fn(),\n      removeClass: jest.fn(),\n    },\n    addUndoableEditor: jest.fn(),\n    add: jest.fn(),\n    unselect: jest.fn(),\n    viewport: { rotation: 0 },\n    scale: 1,\n    parentDimensions: [100, 100],\n  };\n\n  const mockUIManager = new AnnotationEditorUIManager(\n    document.createElement(\"div\"),\n    document.createElement(\"div\"),\n    null,\n    { _on: jest.fn(), _off: jest.fn(), dispatch: jest.fn() },\n    { annotationStorage: new Map(), filterFactory: { addHCMFilter: jest.fn() } },\n    null,\n    null,\n    null\n  );\n\n  const highlightEditor = new HighlightEditor({\n    parent: mockParent,\n    uiManager: mockUIManager,\n    anchorNode: document.createTextNode(\"Test\"),\n    anchorOffset: 0,\n    focusNode: document.createTextNode(\"Test\"),\n    focusOffset: 4,\n    boxes: [{ x: 0, y: 0, width: 1, height: 1 }],\n    color: \"#FFFF00\",\n    opacity: 1,\n    thickness: 12,\n    methodOfCreation: \"test\",\n  });\n\n  const div = highlightEditor.render();\n  const mark = div.querySelector(\"mark\");\n  const isAriaHidden = mark.getAttribute(\"aria-hidden\");\n\n  expect(isAriaHidden).toBeNull();\n});",
    "i4_llama-3.3-70b-versatile": "it(\"should read highlighted text during editing inside a PDF\", async () => {\n  const { PDFDocument, PDFPageProxy } = await import(\"../../src/display/api.js\");\n  const { AnnotationEditorUIManager } = await import(\"../../src/display/editor/tools.js\");\n  const { HighlightEditor } = await import(\"../../src/display/editor/highlight.js\");\n  const { DrawLayer } = await import(\"../../src/display/draw_layer.js\");\n\n  const pdfDocument = await PDFDocument.load(await fetch(\"path_to_your_pdf_file.pdf\").then(response => response.arrayBuffer()));\n  const pdfPage = await pdfDocument.getPage(1);\n  const annotationEditorUIManager = new AnnotationEditorUIManager(null, null, null, null, pdfDocument, null, null, null);\n  const drawLayer = new DrawLayer({ pageIndex: 0 });\n  const highlightEditor = new HighlightEditor({});\n\n  drawLayer.setParent(document.createElement(\"div\"));\n  annotationEditorUIManager.addLayer({ addNewEditor: () => {}, pageIndex: 0, div: document.createElement(\"div\") });\n  annotationEditorUIManager.updateMode(AnnotationEditorType.HIGHLIGHT);\n\n  const highlightedText = \"This is a highlighted text.\";\n  const textNode = document.createElement(\"span\");\n  textNode.textContent = highlightedText;\n  drawLayer.highlight({ box: { x: 0, y: 0, width: 1, height: 1 } }, \"yellow\", 1);\n  drawLayer.highlightOutline({ box: { x: 0, y: 0, width: 1, height: 1 } });\n\n  const mark = document.createElement(\"mark\");\n  mark.append(document.createTextNode(highlightedText));\n  mark.className = \"visuallyHidden\";\n  drawLayer.#parent.append(mark);\n\n  const voiceOverText = await new Promise(resolve => {\n    const voiceOver = () => {\n      const text = window.getComputedStyle(mark).visibility === \"hidden\" ? \"\" : highlightedText;\n      resolve(text);\n    };\n    mark.addEventListener(\"mouseover\", voiceOver);\n    mark.dispatchEvent(new MouseEvent(\"mouseover\", { bubbles: true }));\n    mark.removeEventListener(\"mouseover\", voiceOver);\n  });\n\n  expect(voiceOverText).toBe(highlightedText);\n});",
    "i5_deepseek-r1-distill-llama-70b": "it(\"should read highlighted text for Voice Over when editing PDF\", async () => {\n  const { PDFDocument, PDFPageProxy, AnnotationEditor } = await import(\"../../src/display/api.js\");\n  const { Annotation } = await import(\"../../src/core/annotation.js\");\n\n  // Create a test PDF with a highlight annotation\n  const pdf = new PDFDocument();\n  const page = pdf.addPage();\n  const text = \"Sample highlighted text\";\n\n  // Create and add a highlight annotation\n  const annotation = new Annotation({\n    type: Annotation.Type.HIGHLIGHT,\n    text: text,\n    quads: [],\n    color: \"#FF0000\",\n    opacity: 0.5\n  });\n\n  const editor = new AnnotationEditor({\n    annotation: annotation,\n    page: page,\n    render: () => {}\n  });\n\n  editor.render();\n\n  // Check if the highlighted text is accessible\n  const highlightDiv = editor.highlightDiv;\n  const markElement = highlightDiv.querySelector(\"mark.visuallyHidden\");\n\n  expect(markElement).toBeTruthy();\n  expect(markElement.textContent).toBe(text);\n  expect(highlightDiv.getAttribute(\"aria-hidden\")).toBe(\"true\");\n});",
    "i5_gpt-4o": "it(\"should read highlighted text during editing inside a PDF\", async () => {\n  const { AnnotationEditorUIManager } = await import(\"../../src/display/editor/tools.js\");\n  const { HighlightEditor } = await import(\"../../src/display/editor/highlight.js\");\n\n  const selection = {\n    anchorNode: document.createTextNode(\"Sample text\"),\n    anchorOffset: 0,\n    focusNode: document.createTextNode(\"Sample text\"),\n    focusOffset: 11,\n    toString: () => \"Sample text\"\n  };\n\n  const uiManager = new AnnotationEditorUIManager();\n  uiManager.bindEvents();\n\n  const params = {\n    parent: document.createElement(\"div\"),\n    highlightId: 1,\n    text: selection.toString()\n  };\n\n  const highlightEditor = new HighlightEditor(params);\n  const div = highlightEditor.render();\n\n  const mark = div.querySelector(\"mark\");\n  const actualText = mark ? mark.textContent : null;\n  const expectedText = \"Sample text\";\n\n  expect(actualText).toBe(expectedText);\n});",
    "i5_llama-3.3-70b-versatile": "it(\"should read highlighted text during editing inside a PDF\", async () => {\n  const { PDFDocument, PDFPageProxy, PDFWorkerUtil } = await import(\"../../src/display/api.js\");\n  const { AnnotationEditorUIManager } = await import(\"../../src/display/editor/tools.js\");\n  const { PDFViewer } = await import(\"../../web/pdf_viewer.js\");\n\n  const pdfViewer = new PDFViewer();\n  const pdfDocument = await PDFDocument.load(await fetch(\"path_to_test_pdf.pdf\").then(response => response.arrayBuffer()));\n  const pdfPageProxy = pdfDocument.getPage(1);\n  const annotationEditorUIManager = new AnnotationEditorUIManager(pdfViewer, pdfPageProxy);\n\n  const selection = {\n    anchorNode: { nodeType: Node.TEXT_NODE, data: \"Hello\" },\n    anchorOffset: 0,\n    focusNode: { nodeType: Node.TEXT_NODE, data: \"World\" },\n    focusOffset: 5,\n    toString: () => \"Hello World\"\n  };\n\n  const expectedText = \"Hello World\";\n  const actualText = await annotationEditorUIManager.createAnnotationEditor(selection);\n\n  expect(actualText).toBe(expectedText);\n});"
  },
  "17795": {
    "i1_deepseek-r1-distill-llama-70b": "it(\"should handle inlined images without closing EI\", async () => {\n  const { getDocument } = await import(\"../../src/display/api.js\");\n  const { buildGetDocumentParams } = await import(\"./test_utils.js\");\n  const loadingTask = getDocument(buildGetDocumentParams('issue17794.pdf'));\n\n  const handler = {\n    send: () => {\n      const response = new Response(new Uint8Array(), {\n        status: 200,\n        headers: { 'Content-Type': 'application/pdf' }\n      });\n      return Promise.resolve({ response });\n    },\n    sendWithPromise: jest.fn()\n  };\n\n  const options = {\n    ignoreErrors: true\n  };\n\n  const idFactory = createIdFactory();\n  const xref = new XRefMock();\n\n  const evaluator = new PartialEvaluator({\n    xref,\n    handler,\n    pageIndex: 0,\n    idFactory,\n    fontCache: new Map(),\n    builtInCMapCache: new Map(),\n    standardFontDataCache: new Map(),\n    globalImageCache: new Map(),\n    systemFontCache: new Map(),\n    options,\n  });\n\n  const resources = new Dict();\n  resources.set(\"ProcSet\", new Name(\"PDF\"));\n  resources.set(\"ColorSpace\", new Name(\"DeviceRGB\"));\n\n  const imageStream = new StringStream(\"q q\");\n  const image = {\n    dict: new Dict(),\n    getBytes: () => new Uint8Array(),\n  };\n\n  const operatorList = new OperatorList();\n\n  const cacheKey = `img-${idFactory.createObjId()}`;\n  const localImageCache = new Map();\n\n  const result = await evaluator.buildPaintImageXObject({\n    resources,\n    image,\n    isInline: true,\n    operatorList,\n    cacheKey,\n    localImageCache,\n    localColorSpaceCache: new Map(),\n  });\n\n  expect(console.warn).toHaveBeenCalledWith(/Unable to decode inline image/);\n});",
    "i1_gpt-4o": "it(\"should render all inlined images correctly\", async () => {\n  const { getDocument } = await import(\"../../src/display/api.js\");\n  const { buildGetDocumentParams } = await import(\"./test_utils.js\");\n\n  const loadingTask = getDocument(buildGetDocumentParams(\"issue17794.pdf\"));\n  const pdfDocument = await loadingTask.promise;\n  const page = await pdfDocument.getPage(1);\n\n  const operatorList = new OperatorList();\n  const task = new WorkerTask(\"test task\");\n  const partialEvaluator = new PartialEvaluator({\n    xref: new XRefMock(),\n    handler: null,\n    pageIndex: 0,\n    idFactory: createIdFactory(0),\n    fontCache: null,\n    builtInCMapCache: null,\n    standardFontDataCache: null,\n    globalImageCache: null,\n    systemFontCache: null,\n    options: { ignoreErrors: false },\n  });\n\n  await partialEvaluator.getOperatorList({\n    stream: page.stream,\n    task,\n    resources: Dict.empty,\n    operatorList,\n  });\n\n  const paintInlineImageOps = operatorList.fnArray.filter(\n    fn => fn === OPS.paintInlineImageXObject\n  );\n\n  expect(paintInlineImageOps.length).toBeGreaterThan(1);\n});",
    "i1_llama-3.3-70b-versatile": "it(\"should render all inlined images correctly\", async () => {\n  const { getDocument } = await import('../../src/display/api.js');\n  const { buildGetDocumentParams } = await import('./test_utils.js');\n  const loadingTask = await getDocument(buildGetDocumentParams('issue17794.pdf'));\n  const pdfDocument = await loadingTask.promise;\n  const pdfPage = await pdfDocument.getPage(1);\n  const operatorList = new (await import('../../src/core/operator_list.js')).OperatorList();\n  const partialEvaluator = new (await import('../../src/core/evaluator.js')).PartialEvaluator({\n    xref: pdfDocument.xref,\n    handler: null,\n    pageIndex: 0,\n    idFactory: await import('./test_utils.js').then(module => module.createIdFactory()),\n    fontCache: {},\n    builtInCMapCache: {},\n    standardFontDataCache: {},\n    globalImageCache: {},\n    systemFontCache: {},\n    options: {}\n  });\n  await partialEvaluator.buildPaintImageXObject({\n    resources: pdfPage.resources,\n    image: pdfPage.images[0],\n    isInline: true,\n    operatorList,\n    cacheKey: null,\n    localImageCache: {},\n    localColorSpaceCache: {}\n  });\n  const expectedImageCount = 2;\n  const actualImageCount = operatorList.imageOps.length;\n  expect(actualImageCount).toBe(expectedImageCount);\n});",
    "i2_deepseek-r1-distill-llama-70b": "it(\"should render all inlined images correctly\", async () => {\n  const { getDocument } = await import('../../src/display/api.js');\n  const { buildGetDocumentParams } = await import('./test_utils.js');\n  const loadingTask = getDocument(buildGetDocumentParams('issue17794.pdf'));\n\n  const { numPages } = await loadingTask;\n  const page = await loadingTask.getPage(1);\n  const operatorList = new OperatorList();\n\n  await page.render({\n    canvasContext: null,\n    viewport: null,\n    spreadMode: SpreadMode.NONE,\n    pageCallback: () => null,\n    annotationCallback: () => null,\n    renderInteractiveFormsCallback: () => null,\n    useRequestAnimationFrame: false,\n  });\n\n  const expectedImageCount = 2;\n  const actualImageCount = operatorList.ops.some(op => op.type === OPS.paintInlineImageXObject) ? 2 : 0;\n\n  expect(actualImageCount).toBe(expectedImageCount);\n});",
    "i2_llama-3.3-70b-versatile": "it(\"should render inlined images correctly\", async () => {\n  const { getDocument } = await import('../../src/display/api.js');\n  const { buildGetDocumentParams } = await import('./test_utils.js');\n  const loadingTask = getDocument(buildGetDocumentParams('issue17794.pdf'));\n  const pdf = await loadingTask.promise;\n  const page = await pdf.getPage(1);\n  const operatorList = new (await import('../../src/core/operator_list.js')).OperatorList();\n  const partialEvaluator = new (await import('../../src/core/evaluator.js')).PartialEvaluator({\n    xref: pdf.xref,\n    handler: pdf.handler,\n    pageIndex: 0,\n    idFactory: pdf.idFactory,\n    fontCache: pdf.fontCache,\n    builtInCMapCache: pdf.builtInCMapCache,\n    standardFontDataCache: pdf.standardFontDataCache,\n    globalImageCache: pdf.globalImageCache,\n    systemFontCache: pdf.systemFontCache,\n  });\n  await partialEvaluator.buildPaintImageXObject({\n    resources: page.resources,\n    image: page.images[0],\n    isInline: true,\n    operatorList,\n    cacheKey: null,\n    localImageCache: null,\n    localColorSpaceCache: null,\n  });\n  const expectedImageCount = 2;\n  const actualImageCount = operatorList.ops.filter(op => op.fn === (await import('../../src/core/evaluator.js')).OPS.paintInlineImageXObject).length;\n  expect(actualImageCount).toBe(expectedImageCount);\n});",
    "i3_deepseek-r1-distill-llama-70b": "it(\"should correctly render inlined images without closing EI\", async () => {\n  const { getDocument } = await import(\"../../src/display/api.js\");\n  const { buildGetDocumentParams } = await import(\"./test_utils.js\");\n  const loadingTask = getDocument(buildGetDocumentParams('issue17794.pdf'));\n  const { pdfDocument } = await loadingTask;\n  const page = await pdfDocument.getPage(1);\n  const operatorList = new OperatorList();\n  const imageRenderCount = { count: 0 };\n\n  // Create a sink to track image rendering operations\n  const sink = {\n    enqueue: (chunk, size) => {\n      if (chunk.items && chunk.items[0]?.fn === OPS.paintInlineImageXObject) {\n        imageRenderCount.count++;\n      }\n    },\n  };\n\n  // Render the page and collect operatorList\n  await page.render({\n    sink,\n    operatorList,\n    viewport: page.getViewport({ scale: 1 }),\n  });\n\n  // The PDF should contain two inlined images\n  expect(imageRenderCount.count).toBe(2);\n});",
    "i3_llama-3.3-70b-versatile": "it(\"should render images with inlined images without the closing EI\", async () => {\n  const { getDocument } = await import('../../src/display/api.js');\n  const { buildGetDocumentParams } = await import('./test_utils.js');\n  const loadingTask = getDocument(buildGetDocumentParams('issue17794.pdf'));\n  const doc = await loadingTask.promise;\n  const page = await doc.getPage(1);\n  const operatorList = new OperatorList();\n  const partialEvaluator = new PartialEvaluator({\n    xref: doc.xref,\n    handler: null,\n    pageIndex: 0,\n    idFactory: createIdFactory(),\n    fontCache: new Map(),\n    builtInCMapCache: new Map(),\n    standardFontDataCache: new Map(),\n    globalImageCache: new Map(),\n    systemFontCache: new Map(),\n    options: {}\n  });\n  const renderTask = new WorkerTask({\n    doc,\n    page,\n    operatorList,\n    partialEvaluator,\n    intent: 'display'\n  });\n  await renderTask.run();\n  const images = operatorList.getImages();\n  expect(images.length).toBeGreaterThan(0);\n});",
    "i4_deepseek-r1-distill-llama-70b": "it(\"should render all images in PDF with missing EI\", async () => {\n  const { getDocument } = await import('../../src/display/api.js');\n  const { buildGetDocumentParams } = await import('./test_utils.js');\n\n  const loadingTask = getDocument(buildGetDocumentParams('issue17794.pdf'));\n  const { pdfDocument } = await loadingTask;\n  const page = await pdfDocument.getPage(1);\n\n  let imageCount = 0;\n  const pageRendered = new Promise(resolve => {\n    page.on('end', () => {\n      imageCount++;\n      resolve();\n    });\n  });\n\n  await page.render();\n  await pageRendered;\n\n  expect(imageCount).toBeGreaterThan(1);\n});",
    "i4_gpt-4o": "it(\"should render all inlined images correctly\", async () => {\n  const { getDocument } = await import('../../src/display/api.js');\n  const { buildGetDocumentParams } = await import('./test_utils.js');\n  const loadingTask = getDocument(buildGetDocumentParams('issue17794.pdf'));\n  const pdfDocument = await loadingTask.promise;\n  const pdfPage = await pdfDocument.getPage(1);\n  const operatorList = await pdfPage.getOperatorList();\n  const imageOps = operatorList.fnArray.filter(op => op === 92); // OPS.paintInlineImageXObject\n  const expectedImageCount = 2;\n  const actualImageCount = imageOps.length;\n  expect(actualImageCount).toBe(expectedImageCount);\n});",
    "i4_llama-3.3-70b-versatile": "it(\"should render images with inlined images without the closing EI\", async () => {\n  const { getDocument } = await import('../../src/display/api.js');\n  const { buildGetDocumentParams } = await import('./test_utils.js');\n  const loadingTask = getDocument(buildGetDocumentParams('issue17794.pdf'));\n  const pdfDocument = await loadingTask.promise;\n  const pdfPage = await pdfDocument.getPage(1);\n  const operatorList = await pdfPage.getOperatorList();\n  const imageOps = operatorList.getOperatorList().filter(op => op.fn === 'paintImageMaskXObject' || op.fn === 'paintInlineImageXObject');\n  const expectedImageCount = 2;\n  assert.equal(imageOps.length, expectedImageCount, `Expected ${expectedImageCount} images, but got ${imageOps.length}`);\n});",
    "i5_deepseek-r1-distill-llama-70b": "it(\"should render all inlined images\", async () => {\n  const { getDocument } = await import('../../src/display/api.js');\n  const { buildGetDocumentParams } = await import('./test_utils.js');\n\n  const loadingTask = getDocument(buildGetDocumentParams('issue17794.pdf'));\n  const { pdfDocument } = await loadingTask;\n  const pdfPage = await pdfDocument.getPage(1);\n\n  const checkImagesRendered = (operatorList) => {\n    let imageCount = 0;\n    const operators = operatorList.getOperators();\n    for (const op of operators) {\n      if (op.name === OPS.paintInlineImageXObject) {\n        imageCount++;\n      }\n    }\n    return imageCount;\n  };\n\n  const evaluatorOptions = {\n    ignoreErrors: false,\n    isFirefox: true,\n    isMac: true,\n  };\n\n  const operatorList = new (await import('../../src/core/evaluator.js')).PartialEvaluator/pdfOperatorList;\n  const evaluator = new (await import('../../src/core/evaluator.js')).PartialEvaluator({\n    ...evaluatorOptions,\n    xref: pdfDocument.xref,\n    pdfDocument: pdfDocument,\n  });\n\n  await evaluator.evaluate(pdfPage);\n\n  const expectedImageCount = 2;\n  const actualImageCount = checkImagesRendered(operatorList);\n\n  expect(actualImageCount).toBe(expectedImageCount);\n});",
    "i5_gpt-4o": "it(\"should render all inlined images correctly\", async () => {\n  const { getDocument } = await import('../../src/display/api.js');\n  const { buildGetDocumentParams } = await import('./test_utils.js');\n  const loadingTask = getDocument(buildGetDocumentParams('issue17794.pdf'));\n  const pdfDocument = await loadingTask.promise;\n  const page = await pdfDocument.getPage(1);\n  const viewport = page.getViewport({ scale: 1.0 });\n  const canvasFactory = new (await import('../../src/display/display_utils.js')).DOMCanvasFactory();\n  const canvasAndContext = canvasFactory.create(viewport.width, viewport.height);\n  const renderTask = page.render({\n    canvasContext: canvasAndContext.context,\n    viewport,\n  });\n  await renderTask.promise;\n  const imageData = canvasAndContext.context.getImageData(0, 0, viewport.width, viewport.height);\n  const nonEmptyPixels = imageData.data.filter(value => value !== 0);\n  expect(nonEmptyPixels.length).toBeGreaterThan(0);\n});",
    "i5_llama-3.3-70b-versatile": "it(\"should render all inlined images correctly\", async () => {\n  const { getDocument } = await import('../../src/display/api.js');\n  const { buildGetDocumentParams } = await import('./test_utils.js');\n  const loadingTask = getDocument(buildGetDocumentParams('issue17794.pdf'));\n  const doc = await loadingTask.promise;\n  const page = await doc.getPage(1);\n  const viewport = page.getViewport({ scale: 1 });\n  const renderTask = page.render({\n    viewport,\n    intent: 'display',\n  });\n  const renderResult = await renderTask.promise;\n  const expectedImageCount = 2;\n  const actualImageCount = renderResult.images.length;\n  expect(actualImageCount).toBe(expectedImageCount);\n});"
  },
  "17825": {
    "i1_deepseek-r1-distill-llama-70b": "it(\"should add a visually hidden accessible label to the highlight floating button\", async () => {\n  const button = await page.waitForSelector(\".highlightButton\");\n  const span = await button.$(\".visuallyHidden\");\n  if (!span) {\n    throw new Error(\"The accessible label span is missing on the highlight button.\");\n  }\n  const dataL10nId = await page.evaluate(el => el.getAttribute(\"data-l10n-id\"), span);\n  if (dataL10nId !== \"pdfjs-highlight-floating-button-label\") {\n    throw new Error(`Expected span data-l10n-id to be \"pdfjs-highlight-floating-button-label\", but got \"${dataL10nId}\"`);\n  }\n});",
    "i1_gpt-4o": "it(\"should add a visually hidden accessible label to the highlight floating button\", async () => {\n  const button = await page.waitForSelector(\".highlightButton\");\n  const span = await button.$(\".visuallyHidden\");\n  if (!span) {\n    throw new Error(\"The accessible label span is missing on the highlight button.\");\n  }\n  const dataL10nId = await page.evaluate(el => el.getAttribute(\"data-l10n-id\"), span);\n  if (dataL10nId !== \"pdfjs-highlight-floating-button-label\") {\n    throw new Error(`Expected span data-l10n-id to be \"pdfjs-highlight-floating-button-label\", but got \"${dataL10nId}\"`);\n  }\n});",
    "i1_llama-3.3-70b-versatile": "it(\"should add a visually hidden accessible label to the highlight floating button\", async () => {\n  const button = await page.waitForSelector(\".highlightButton\");\n  const span = await button.$(\".visuallyHidden\");\n  if (!span) {\n    throw new Error(\"The accessible label span is missing on the highlight button.\");\n  }\n  const dataL10nId = await page.evaluate(el => el.getAttribute(\"data-l10n-id\"), span);\n  if (dataL10nId !== \"pdfjs-highlight-floating-button-label\") {\n    throw new Error(`Expected span data-l10n-id to be \"pdfjs-highlight-floating-button-label\", but got \"${dataL10nId}\"`);\n  }\n});",
    "i1_MOCK": "it(\"should add a visually hidden accessible label to the highlight floating button\", async () => {\n  const button = await page.waitForSelector(\".highlightButton\");\n  const span = await button.$(\".visuallyHidden\");\n  if (!span) {\n    throw new Error(\"The accessible label span is missing on the highlight button.\");\n  }\n  const dataL10nId = await page.evaluate(el => el.getAttribute(\"data-l10n-id\"), span);\n  if (dataL10nId !== \"pdfjs-highlight-floating-button-label\") {\n    throw new Error(`Expected span data-l10n-id to be \"pdfjs-highlight-floating-button-label\", but got \"${dataL10nId}\"`);\n  }\n});",
    "i2_deepseek-r1-distill-llama-70b": "it(\"should add a visually hidden accessible label to the highlight floating button\", async () => {\n  const button = await page.waitForSelector(\".highlightButton\");\n  const span = await button.$(\".visuallyHidden\");\n  if (!span) {\n    throw new Error(\"The accessible label span is missing on the highlight button.\");\n  }\n  const dataL10nId = await page.evaluate(el => el.getAttribute(\"data-l10n-id\"), span);\n  if (dataL10nId !== \"pdfjs-highlight-floating-button-label\") {\n    throw new Error(`Expected span data-l10n-id to be \"pdfjs-highlight-floating-button-label\", but got \"${dataL10nId}\"`);\n  }\n});",
    "i2_gpt-4o": "it(\"should add a visually hidden accessible label to the highlight floating button\", async () => {\n  const button = await page.waitForSelector(\".highlightButton\");\n  const span = await button.$(\".visuallyHidden\");\n  if (!span) {\n    throw new Error(\"The accessible label span is missing on the highlight button.\");\n  }\n  const dataL10nId = await page.evaluate(el => el.getAttribute(\"data-l10n-id\"), span);\n  if (dataL10nId !== \"pdfjs-highlight-floating-button-label\") {\n    throw new Error(`Expected span data-l10n-id to be \"pdfjs-highlight-floating-button-label\", but got \"${dataL10nId}\"`);\n  }\n});",
    "i2_llama-3.3-70b-versatile": "it(\"should add a visually hidden accessible label to the highlight floating button\", async () => {\n  const button = await page.waitForSelector(\".highlightButton\");\n  const span = await button.$(\".visuallyHidden\");\n  if (!span) {\n    throw new Error(\"The accessible label span is missing on the highlight button.\");\n  }\n  const dataL10nId = await page.evaluate(el => el.getAttribute(\"data-l10n-id\"), span);\n  if (dataL10nId !== \"pdfjs-highlight-floating-button-label\") {\n    throw new Error(`Expected span data-l10n-id to be \"pdfjs-highlight-floating-button-label\", but got \"${dataL10nId}\"`);\n  }\n});",
    "i3_deepseek-r1-distill-llama-70b": "it(\"should add a visually hidden accessible label to the highlight floating button\", async () => {\n  const button = await page.waitForSelector(\".highlightButton\");\n  const span = await button.$(\".visuallyHidden\");\n  if (!span) {\n    throw new Error(\"The accessible label span is missing on the highlight button.\");\n  }\n  const dataL10nId = await page.evaluate(el => el.getAttribute(\"data-l10n-id\"), span);\n  if (dataL10nId !== \"pdfjs-highlight-floating-button-label\") {\n    throw new Error(`Expected span data-l10n-id to be \"pdfjs-highlight-floating-button-label\", but got \"${dataL10nId}\"`);\n  }\n});",
    "i3_gpt-4o": "it(\"should add a visually hidden accessible label to the highlight floating button\", async () => {\n  const button = await page.waitForSelector(\".highlightButton\");\n  const span = await button.$(\".visuallyHidden\");\n  if (!span) {\n    throw new Error(\"The accessible label span is missing on the highlight button.\");\n  }\n  const dataL10nId = await page.evaluate(el => el.getAttribute(\"data-l10n-id\"), span);\n  if (dataL10nId !== \"pdfjs-highlight-floating-button-label\") {\n    throw new Error(`Expected span data-l10n-id to be \"pdfjs-highlight-floating-button-label\", but got \"${dataL10nId}\"`);\n  }\n});",
    "i3_llama-3.3-70b-versatile": "it(\"should add a visually hidden accessible label to the highlight floating button\", async () => {\n  const button = await page.waitForSelector(\".highlightButton\");\n  const span = await button.$(\".visuallyHidden\");\n  if (!span) {\n    throw new Error(\"The accessible label span is missing on the highlight button.\");\n  }\n  const dataL10nId = await page.evaluate(el => el.getAttribute(\"data-l10n-id\"), span);\n  if (dataL10nId !== \"pdfjs-highlight-floating-button-label\") {\n    throw new Error(`Expected span data-l10n-id to be \"pdfjs-highlight-floating-button-label\", but got \"${dataL10nId}\"`);\n  }\n});",
    "i4_deepseek-r1-distill-llama-70b": "it(\"should add a visually hidden accessible label to the highlight floating button\", async () => {\n  const button = await page.waitForSelector(\".highlightButton\");\n  const span = await button.$(\".visuallyHidden\");\n  if (!span) {\n    throw new Error(\"The accessible label span is missing on the highlight button.\");\n  }\n  const dataL10nId = await page.evaluate(el => el.getAttribute(\"data-l10n-id\"), span);\n  if (dataL10nId !== \"pdfjs-highlight-floating-button-label\") {\n    throw new Error(`Expected span data-l10n-id to be \"pdfjs-highlight-floating-button-label\", but got \"${dataL10nId}\"`);\n  }\n});",
    "i4_gpt-4o": "it(\"should add a visually hidden accessible label to the highlight floating button\", async () => {\n  const button = await page.waitForSelector(\".highlightButton\");\n  const span = await button.$(\".visuallyHidden\");\n  if (!span) {\n    throw new Error(\"The accessible label span is missing on the highlight button.\");\n  }\n  const dataL10nId = await page.evaluate(el => el.getAttribute(\"data-l10n-id\"), span);\n  if (dataL10nId !== \"pdfjs-highlight-floating-button-label\") {\n    throw new Error(`Expected span data-l10n-id to be \"pdfjs-highlight-floating-button-label\", but got \"${dataL10nId}\"`);\n  }\n});",
    "i4_llama-3.3-70b-versatile": "it(\"should add a visually hidden accessible label to the highlight floating button\", async () => {\n  const button = await page.waitForSelector(\".highlightButton\");\n  const span = await button.$(\".visuallyHidden\");\n  if (!span) {\n    throw new Error(\"The accessible label span is missing on the highlight button.\");\n  }\n  const dataL10nId = await page.evaluate(el => el.getAttribute(\"data-l10n-id\"), span);\n  if (dataL10nId !== \"pdfjs-highlight-floating-button-label\") {\n    throw new Error(`Expected span data-l10n-id to be \"pdfjs-highlight-floating-button-label\", but got \"${dataL10nId}\"`);\n  }\n});",
    "i5_deepseek-r1-distill-llama-70b": "it(\"should add a visually hidden accessible label to the highlight floating button\", async () => {\n  const button = await page.waitForSelector(\".highlightButton\");\n  const span = await button.$(\".visuallyHidden\");\n  if (!span) {\n    throw new Error(\"The accessible label span is missing on the highlight button.\");\n  }\n  const dataL10nId = await page.evaluate(el => el.getAttribute(\"data-l10n-id\"), span);\n  if (dataL10nId !== \"pdfjs-highlight-floating-button-label\") {\n    throw new Error(`Expected span data-l10n-id to be \"pdfjs-highlight-floating-button-label\", but got \"${dataL10nId}\"`);\n  }\n});",
    "i5_gpt-4o": "it(\"should add a visually hidden accessible label to the highlight floating button\", async () => {\n  const button = await page.waitForSelector(\".highlightButton\");\n  const span = await button.$(\".visuallyHidden\");\n  if (!span) {\n    throw new Error(\"The accessible label span is missing on the highlight button.\");\n  }\n  const dataL10nId = await page.evaluate(el => el.getAttribute(\"data-l10n-id\"), span);\n  if (dataL10nId !== \"pdfjs-highlight-floating-button-label\") {\n    throw new Error(`Expected span data-l10n-id to be \"pdfjs-highlight-floating-button-label\", but got \"${dataL10nId}\"`);\n  }\n});",
    "i5_llama-3.3-70b-versatile": "it(\"should add a visually hidden accessible label to the highlight floating button\", async () => {\n  const button = await page.waitForSelector(\".highlightButton\");\n  const span = await button.$(\".visuallyHidden\");\n  if (!span) {\n    throw new Error(\"The accessible label span is missing on the highlight button.\");\n  }\n  const dataL10nId = await page.evaluate(el => el.getAttribute(\"data-l10n-id\"), span);\n  if (dataL10nId !== \"pdfjs-highlight-floating-button-label\") {\n    throw new Error(`Expected span data-l10n-id to be \"pdfjs-highlight-floating-button-label\", but got \"${dataL10nId}\"`);\n  }\n});"
  },
  "17868": {
    "i1_deepseek-r1-distill-llama-70b": "it(\"should disable image smoothing when only one scale factor is below the actual scale and interpolate is not set\", async () => {\n  const { getImageSmoothingEnabled } = await import(\"../../src/display/canvas.js\");\n  const { PixelsPerInch } = await import(\"../../src/display/display_utils.js\");\n  const devicePixelRatio = globalThis.devicePixelRatio || 1;\n  const actualScale = Math.fround(devicePixelRatio * PixelsPerInch.PDF_TO_CSS_UNITS);\n  const delta = 0.1;\n  // Set scaleX below actualScale and scaleY above actualScale.\n  const scaleX = actualScale - delta;\n  const scaleY = actualScale + delta;\n  // Create a simple transform matrix [scaleX, 0, 0, scaleY, 0, 0]\n  const transform = [scaleX, 0, 0, scaleY, 0, 0];\n  // Do not pass an explicit interpolate (undefined).\n  const smoothing = getImageSmoothingEnabled(transform, undefined);\n  if (smoothing !== false) {\n    throw new Error(\"Expected smoothing to be false, but got true\");\n  }\n});",
    "i1_gpt-4o": "it(\"should disable image smoothing when only one scale factor is below the actual scale and interpolate is not set\", async () => {\n  const { getImageSmoothingEnabled } = await import(\"../../src/display/canvas.js\");\n  const { PixelsPerInch } = await import(\"../../src/display/display_utils.js\");\n  const devicePixelRatio = globalThis.devicePixelRatio || 1;\n  const actualScale = Math.fround(devicePixelRatio * PixelsPerInch.PDF_TO_CSS_UNITS);\n  const delta = 0.1;\n  // Set scaleX below actualScale and scaleY above actualScale.\n  const scaleX = actualScale - delta;\n  const scaleY = actualScale + delta;\n  // Create a simple transform matrix [scaleX, 0, 0, scaleY, 0, 0]\n  const transform = [scaleX, 0, 0, scaleY, 0, 0];\n  // Do not pass an explicit interpolate (undefined).\n  const smoothing = getImageSmoothingEnabled(transform, undefined);\n  if (smoothing !== false) {\n    throw new Error(\"Expected smoothing to be false, but got true\");\n  }\n});",
    "i1_llama-3.3-70b-versatile": "it(\"should disable image smoothing when only one scale factor is below the actual scale and interpolate is not set\", async () => {\n  const { getImageSmoothingEnabled } = await import(\"../../src/display/canvas.js\");\n  const { PixelsPerInch } = await import(\"../../src/display/display_utils.js\");\n  const devicePixelRatio = globalThis.devicePixelRatio || 1;\n  const actualScale = Math.fround(devicePixelRatio * PixelsPerInch.PDF_TO_CSS_UNITS);\n  const delta = 0.1;\n  // Set scaleX below actualScale and scaleY above actualScale.\n  const scaleX = actualScale - delta;\n  const scaleY = actualScale + delta;\n  // Create a simple transform matrix [scaleX, 0, 0, scaleY, 0, 0]\n  const transform = [scaleX, 0, 0, scaleY, 0, 0];\n  // Do not pass an explicit interpolate (undefined).\n  const smoothing = getImageSmoothingEnabled(transform, undefined);\n  if (smoothing !== false) {\n    throw new Error(\"Expected smoothing to be false, but got true\");\n  }\n});",
    "i1_MOCK": "it(\"should disable image smoothing when only one scale factor is below the actual scale and interpolate is not set\", async () => {\n  const { getImageSmoothingEnabled } = await import(\"../../src/display/canvas.js\");\n  const { PixelsPerInch } = await import(\"../../src/display/display_utils.js\");\n  const devicePixelRatio = globalThis.devicePixelRatio || 1;\n  const actualScale = Math.fround(devicePixelRatio * PixelsPerInch.PDF_TO_CSS_UNITS);\n  const delta = 0.1;\n  // Set scaleX below actualScale and scaleY above actualScale.\n  const scaleX = actualScale - delta;\n  const scaleY = actualScale + delta;\n  // Create a simple transform matrix [scaleX, 0, 0, scaleY, 0, 0]\n  const transform = [scaleX, 0, 0, scaleY, 0, 0];\n  // Do not pass an explicit interpolate (undefined).\n  const smoothing = getImageSmoothingEnabled(transform, undefined);\n  if (smoothing !== false) {\n    throw new Error(\"Expected smoothing to be false, but got true\");\n  }\n});",
    "i2_deepseek-r1-distill-llama-70b": "it(\"should disable image smoothing when only one scale factor is below the actual scale and interpolate is not set\", async () => {\n  const { getImageSmoothingEnabled } = await import(\"../../src/display/canvas.js\");\n  const { PixelsPerInch } = await import(\"../../src/display/display_utils.js\");\n  const devicePixelRatio = globalThis.devicePixelRatio || 1;\n  const actualScale = Math.fround(devicePixelRatio * PixelsPerInch.PDF_TO_CSS_UNITS);\n  const delta = 0.1;\n  // Set scaleX below actualScale and scaleY above actualScale.\n  const scaleX = actualScale - delta;\n  const scaleY = actualScale + delta;\n  // Create a simple transform matrix [scaleX, 0, 0, scaleY, 0, 0]\n  const transform = [scaleX, 0, 0, scaleY, 0, 0];\n  // Do not pass an explicit interpolate (undefined).\n  const smoothing = getImageSmoothingEnabled(transform, undefined);\n  if (smoothing !== false) {\n    throw new Error(\"Expected smoothing to be false, but got true\");\n  }\n});",
    "i2_gpt-4o": "it(\"should disable image smoothing when only one scale factor is below the actual scale and interpolate is not set\", async () => {\n  const { getImageSmoothingEnabled } = await import(\"../../src/display/canvas.js\");\n  const { PixelsPerInch } = await import(\"../../src/display/display_utils.js\");\n  const devicePixelRatio = globalThis.devicePixelRatio || 1;\n  const actualScale = Math.fround(devicePixelRatio * PixelsPerInch.PDF_TO_CSS_UNITS);\n  const delta = 0.1;\n  // Set scaleX below actualScale and scaleY above actualScale.\n  const scaleX = actualScale - delta;\n  const scaleY = actualScale + delta;\n  // Create a simple transform matrix [scaleX, 0, 0, scaleY, 0, 0]\n  const transform = [scaleX, 0, 0, scaleY, 0, 0];\n  // Do not pass an explicit interpolate (undefined).\n  const smoothing = getImageSmoothingEnabled(transform, undefined);\n  if (smoothing !== false) {\n    throw new Error(\"Expected smoothing to be false, but got true\");\n  }\n});",
    "i2_llama-3.3-70b-versatile": "it(\"should disable image smoothing when only one scale factor is below the actual scale and interpolate is not set\", async () => {\n  const { getImageSmoothingEnabled } = await import(\"../../src/display/canvas.js\");\n  const { PixelsPerInch } = await import(\"../../src/display/display_utils.js\");\n  const devicePixelRatio = globalThis.devicePixelRatio || 1;\n  const actualScale = Math.fround(devicePixelRatio * PixelsPerInch.PDF_TO_CSS_UNITS);\n  const delta = 0.1;\n  // Set scaleX below actualScale and scaleY above actualScale.\n  const scaleX = actualScale - delta;\n  const scaleY = actualScale + delta;\n  // Create a simple transform matrix [scaleX, 0, 0, scaleY, 0, 0]\n  const transform = [scaleX, 0, 0, scaleY, 0, 0];\n  // Do not pass an explicit interpolate (undefined).\n  const smoothing = getImageSmoothingEnabled(transform, undefined);\n  if (smoothing !== false) {\n    throw new Error(\"Expected smoothing to be false, but got true\");\n  }\n});",
    "i3_deepseek-r1-distill-llama-70b": "it(\"should disable image smoothing when only one scale factor is below the actual scale and interpolate is not set\", async () => {\n  const { getImageSmoothingEnabled } = await import(\"../../src/display/canvas.js\");\n  const { PixelsPerInch } = await import(\"../../src/display/display_utils.js\");\n  const devicePixelRatio = globalThis.devicePixelRatio || 1;\n  const actualScale = Math.fround(devicePixelRatio * PixelsPerInch.PDF_TO_CSS_UNITS);\n  const delta = 0.1;\n  // Set scaleX below actualScale and scaleY above actualScale.\n  const scaleX = actualScale - delta;\n  const scaleY = actualScale + delta;\n  // Create a simple transform matrix [scaleX, 0, 0, scaleY, 0, 0]\n  const transform = [scaleX, 0, 0, scaleY, 0, 0];\n  // Do not pass an explicit interpolate (undefined).\n  const smoothing = getImageSmoothingEnabled(transform, undefined);\n  if (smoothing !== false) {\n    throw new Error(\"Expected smoothing to be false, but got true\");\n  }\n});",
    "i3_gpt-4o": "it(\"should disable image smoothing when only one scale factor is below the actual scale and interpolate is not set\", async () => {\n  const { getImageSmoothingEnabled } = await import(\"../../src/display/canvas.js\");\n  const { PixelsPerInch } = await import(\"../../src/display/display_utils.js\");\n  const devicePixelRatio = globalThis.devicePixelRatio || 1;\n  const actualScale = Math.fround(devicePixelRatio * PixelsPerInch.PDF_TO_CSS_UNITS);\n  const delta = 0.1;\n  // Set scaleX below actualScale and scaleY above actualScale.\n  const scaleX = actualScale - delta;\n  const scaleY = actualScale + delta;\n  // Create a simple transform matrix [scaleX, 0, 0, scaleY, 0, 0]\n  const transform = [scaleX, 0, 0, scaleY, 0, 0];\n  // Do not pass an explicit interpolate (undefined).\n  const smoothing = getImageSmoothingEnabled(transform, undefined);\n  if (smoothing !== false) {\n    throw new Error(\"Expected smoothing to be false, but got true\");\n  }\n});",
    "i3_llama-3.3-70b-versatile": "it(\"should disable image smoothing when only one scale factor is below the actual scale and interpolate is not set\", async () => {\n  const { getImageSmoothingEnabled } = await import(\"../../src/display/canvas.js\");\n  const { PixelsPerInch } = await import(\"../../src/display/display_utils.js\");\n  const devicePixelRatio = globalThis.devicePixelRatio || 1;\n  const actualScale = Math.fround(devicePixelRatio * PixelsPerInch.PDF_TO_CSS_UNITS);\n  const delta = 0.1;\n  // Set scaleX below actualScale and scaleY above actualScale.\n  const scaleX = actualScale - delta;\n  const scaleY = actualScale + delta;\n  // Create a simple transform matrix [scaleX, 0, 0, scaleY, 0, 0]\n  const transform = [scaleX, 0, 0, scaleY, 0, 0];\n  // Do not pass an explicit interpolate (undefined).\n  const smoothing = getImageSmoothingEnabled(transform, undefined);\n  if (smoothing !== false) {\n    throw new Error(\"Expected smoothing to be false, but got true\");\n  }\n});",
    "i4_deepseek-r1-distill-llama-70b": "it(\"should disable image smoothing when only one scale factor is below the actual scale and interpolate is not set\", async () => {\n  const { getImageSmoothingEnabled } = await import(\"../../src/display/canvas.js\");\n  const { PixelsPerInch } = await import(\"../../src/display/display_utils.js\");\n  const devicePixelRatio = globalThis.devicePixelRatio || 1;\n  const actualScale = Math.fround(devicePixelRatio * PixelsPerInch.PDF_TO_CSS_UNITS);\n  const delta = 0.1;\n  // Set scaleX below actualScale and scaleY above actualScale.\n  const scaleX = actualScale - delta;\n  const scaleY = actualScale + delta;\n  // Create a simple transform matrix [scaleX, 0, 0, scaleY, 0, 0]\n  const transform = [scaleX, 0, 0, scaleY, 0, 0];\n  // Do not pass an explicit interpolate (undefined).\n  const smoothing = getImageSmoothingEnabled(transform, undefined);\n  if (smoothing !== false) {\n    throw new Error(\"Expected smoothing to be false, but got true\");\n  }\n});",
    "i4_gpt-4o": "it(\"should disable image smoothing when only one scale factor is below the actual scale and interpolate is not set\", async () => {\n  const { getImageSmoothingEnabled } = await import(\"../../src/display/canvas.js\");\n  const { PixelsPerInch } = await import(\"../../src/display/display_utils.js\");\n  const devicePixelRatio = globalThis.devicePixelRatio || 1;\n  const actualScale = Math.fround(devicePixelRatio * PixelsPerInch.PDF_TO_CSS_UNITS);\n  const delta = 0.1;\n  // Set scaleX below actualScale and scaleY above actualScale.\n  const scaleX = actualScale - delta;\n  const scaleY = actualScale + delta;\n  // Create a simple transform matrix [scaleX, 0, 0, scaleY, 0, 0]\n  const transform = [scaleX, 0, 0, scaleY, 0, 0];\n  // Do not pass an explicit interpolate (undefined).\n  const smoothing = getImageSmoothingEnabled(transform, undefined);\n  if (smoothing !== false) {\n    throw new Error(\"Expected smoothing to be false, but got true\");\n  }\n});",
    "i4_llama-3.3-70b-versatile": "it(\"should disable image smoothing when only one scale factor is below the actual scale and interpolate is not set\", async () => {\n  const { getImageSmoothingEnabled } = await import(\"../../src/display/canvas.js\");\n  const { PixelsPerInch } = await import(\"../../src/display/display_utils.js\");\n  const devicePixelRatio = globalThis.devicePixelRatio || 1;\n  const actualScale = Math.fround(devicePixelRatio * PixelsPerInch.PDF_TO_CSS_UNITS);\n  const delta = 0.1;\n  // Set scaleX below actualScale and scaleY above actualScale.\n  const scaleX = actualScale - delta;\n  const scaleY = actualScale + delta;\n  // Create a simple transform matrix [scaleX, 0, 0, scaleY, 0, 0]\n  const transform = [scaleX, 0, 0, scaleY, 0, 0];\n  // Do not pass an explicit interpolate (undefined).\n  const smoothing = getImageSmoothingEnabled(transform, undefined);\n  if (smoothing !== false) {\n    throw new Error(\"Expected smoothing to be false, but got true\");\n  }\n});",
    "i5_deepseek-r1-distill-llama-70b": "it(\"should disable image smoothing when only one scale factor is below the actual scale and interpolate is not set\", async () => {\n  const { getImageSmoothingEnabled } = await import(\"../../src/display/canvas.js\");\n  const { PixelsPerInch } = await import(\"../../src/display/display_utils.js\");\n  const devicePixelRatio = globalThis.devicePixelRatio || 1;\n  const actualScale = Math.fround(devicePixelRatio * PixelsPerInch.PDF_TO_CSS_UNITS);\n  const delta = 0.1;\n  // Set scaleX below actualScale and scaleY above actualScale.\n  const scaleX = actualScale - delta;\n  const scaleY = actualScale + delta;\n  // Create a simple transform matrix [scaleX, 0, 0, scaleY, 0, 0]\n  const transform = [scaleX, 0, 0, scaleY, 0, 0];\n  // Do not pass an explicit interpolate (undefined).\n  const smoothing = getImageSmoothingEnabled(transform, undefined);\n  if (smoothing !== false) {\n    throw new Error(\"Expected smoothing to be false, but got true\");\n  }\n});",
    "i5_gpt-4o": "it(\"should disable image smoothing when only one scale factor is below the actual scale and interpolate is not set\", async () => {\n  const { getImageSmoothingEnabled } = await import(\"../../src/display/canvas.js\");\n  const { PixelsPerInch } = await import(\"../../src/display/display_utils.js\");\n  const devicePixelRatio = globalThis.devicePixelRatio || 1;\n  const actualScale = Math.fround(devicePixelRatio * PixelsPerInch.PDF_TO_CSS_UNITS);\n  const delta = 0.1;\n  // Set scaleX below actualScale and scaleY above actualScale.\n  const scaleX = actualScale - delta;\n  const scaleY = actualScale + delta;\n  // Create a simple transform matrix [scaleX, 0, 0, scaleY, 0, 0]\n  const transform = [scaleX, 0, 0, scaleY, 0, 0];\n  // Do not pass an explicit interpolate (undefined).\n  const smoothing = getImageSmoothingEnabled(transform, undefined);\n  if (smoothing !== false) {\n    throw new Error(\"Expected smoothing to be false, but got true\");\n  }\n});",
    "i5_llama-3.3-70b-versatile": "it(\"should disable image smoothing when only one scale factor is below the actual scale and interpolate is not set\", async () => {\n  const { getImageSmoothingEnabled } = await import(\"../../src/display/canvas.js\");\n  const { PixelsPerInch } = await import(\"../../src/display/display_utils.js\");\n  const devicePixelRatio = globalThis.devicePixelRatio || 1;\n  const actualScale = Math.fround(devicePixelRatio * PixelsPerInch.PDF_TO_CSS_UNITS);\n  const delta = 0.1;\n  // Set scaleX below actualScale and scaleY above actualScale.\n  const scaleX = actualScale - delta;\n  const scaleY = actualScale + delta;\n  // Create a simple transform matrix [scaleX, 0, 0, scaleY, 0, 0]\n  const transform = [scaleX, 0, 0, scaleY, 0, 0];\n  // Do not pass an explicit interpolate (undefined).\n  const smoothing = getImageSmoothingEnabled(transform, undefined);\n  if (smoothing !== false) {\n    throw new Error(\"Expected smoothing to be false, but got true\");\n  }\n});"
  },
  "17946": {
    "i1_deepseek-r1-distill-llama-70b": "it(\"should render large JPX images in PDF\", async () => {\n  const { getDocument } = await import('../../src/display/api.js');\n  const { buildGetDocumentParams } = await import('./test_utils.js');\n  const loadingTask = getDocument(buildGetDocumentParams('issue17289.pdf'));\n\n  try {\n    const pdfDocument = await loadingTask;\n    const pdfPage = await pdfDocument.getPage(1);\n    const renderTask = pdfPage.render({\n      viewport: pdfPage.getViewport({ scale: 1 }),\n      useAuth: null,\n      renderInteractive: false,\n      cancelable: true,\n      includeAnnotations: false,\n      annotationMode: null,\n      renderAnnotations: false,\n      preventAutoScaling: false,\n    });\n\n    const renderedPage = await renderTask;\n    const renderedCanvas = renderedPage.canvas;\n\n    // Verify that the image data is present and has expected dimensions\n    const expectedWidth = 1024;\n    const expectedHeight = 768;\n\n    if (!renderedCanvas) {\n      throw new Error(\"Failed to render the page\");\n    }\n\n    const ctx = renderedCanvas.getContext('2d');\n    const imageData = ctx.getImageData(0, 0, expectedWidth, expectedHeight);\n\n    // Check if the image data contains non-empty pixels (not all transparent)\n    if (imageData.data.some((value, index) => \n      index !== 3 || value !== 0)) {\n      throw new Error(\"Image not rendered\");\n    }\n  } catch (error) {\n    throw new Error(\"Failed to load or render the PDF\");\n  }\n});",
    "i1_gpt-4o": "it(\"renders large images in PDF correctly\", async () => {\n  const { getDocument } = await import(\"../../src/display/api.js\");\n  const { buildGetDocumentParams } = await import(\"./test_utils.js\");\n  const loadingTask = getDocument(buildGetDocumentParams(\"issue17289.pdf\"));\n  const pdfDocument = await loadingTask.promise;\n  const page = await pdfDocument.getPage(1);\n  const viewport = page.getViewport({ scale: 1.0 });\n  const canvasFactory = new (await import(\"../../src/display/display_utils.js\")).DOMCanvasFactory();\n  const canvasAndContext = canvasFactory.create(viewport.width, viewport.height);\n  const renderTask = page.render({\n    canvasContext: canvasAndContext.context,\n    viewport,\n  });\n  await renderTask.promise;\n  const imageData = canvasAndContext.context.getImageData(0, 0, viewport.width, viewport.height);\n  const hasNonWhitePixels = imageData.data.some((value, index) => index % 4 !== 3 && value !== 255);\n  expect(hasNonWhitePixels).toBe(true);\n});",
    "i1_llama-3.3-70b-versatile": "it(\"should render large images in PDF\", async () => {\n  const { getDocument } = await import('../../src/display/api.js');\n  const { buildGetDocumentParams } = await import('./test_utils.js');\n  const loadingTask = getDocument(buildGetDocumentParams('issue17289.pdf'));\n  const pdfDocument = await loadingTask.promise;\n  const page = await pdfDocument.getPage(1);\n  const image = await page.getImage(0);\n  const imageData = await image.getImageBytes();\n  expect(imageData).not.toBeNull();\n});",
    "i2_deepseek-r1-distill-llama-70b": "it(\"should render large JPX images correctly\", async () => {\n  const { getDocument } = await import('../../src/display/api.js');\n  const { buildGetDocumentParams } = await import('./test_utils.js');\n  const loadingTask = getDocument(buildGetDocumentParams('issue17289.pdf'));\n\n  const pdf = await loadingTask;\n  const firstPage = await pdf.getPage(1);\n  const operators = await firstPage.getOperatorList();\n\n  // We need to wait for any pending rendering tasks\n  await operators.run((op) => {\n    if (op.type === 'drawImage') {\n      return new Promise((resolve) => {\n        resolve();\n      });\n    }\n  });\n\n  // If no errors were thrown, the test passes\n  expect(true).toBe(true);\n});",
    "i2_gpt-4o": "it(\"should render large images in PDF\", async () => {\n  const { getDocument } = await import('../../src/display/api.js');\n  const { buildGetDocumentParams } = await import('./test_utils.js');\n  const loadingTask = getDocument(buildGetDocumentParams('issue17289.pdf'));\n  const pdfDocument = await loadingTask.promise;\n  const page = await pdfDocument.getPage(1);\n  const viewport = page.getViewport({ scale: 1.0 });\n  const canvasFactory = new (await import('../../src/display/display_utils.js')).DOMCanvasFactory();\n  const canvasAndContext = canvasFactory.create(viewport.width, viewport.height);\n  const renderTask = page.render({\n    canvasContext: canvasAndContext.context,\n    viewport,\n  });\n  await renderTask.promise;\n  const imageData = canvasAndContext.context.getImageData(0, 0, viewport.width, viewport.height);\n  const hasNonWhitePixels = imageData.data.some((value, index) => index % 4 !== 3 && value !== 255);\n  expect(hasNonWhitePixels).toBe(true);\n});",
    "i2_llama-3.3-70b-versatile": "it(\"should render large images in PDF\", async () => {\n  const { getDocument } = await import('../../src/display/api.js');\n  const { buildGetDocumentParams } = await import('./test_utils.js');\n  const loadingTask = getDocument(buildGetDocumentParams('issue17289.pdf'));\n  const pdfDocument = await loadingTask.promise;\n  const pdfPage = await pdfDocument.getPage(1);\n  const image = await pdfPage.getImage(0);\n  const imageData = await image.getImageBytes();\n  expect(imageData).not.toBeNull();\n});",
    "i3_deepseek-r1-distill-llama-70b": "it(\"should render large images in PDFs correctly\", async () => {\n  const { getDocument } = await import('../../src/display/api.js');\n  const { buildGetDocumentParams } = await import('./test_utils.js');\n\n  const loadingTask = getDocument(buildGetDocumentParams('issue17289.pdf'));\n  const { pdfDocument } = await loadingTask;\n  const pdfViewer = new (await import('../../src/display/pdf_viewer.js')).PDFViewer({\n    container: document.createElement('div'),\n    renderInteractive: false,\n  });\n\n  await pdfViewer.setDocument(pdfDocument);\n  const page = await pdfViewer.setCurrentPage(1);\n  const canvas = document.createElement('canvas');\n  await page.render({\n    canvasContext: canvas.getContext('2d'),\n    viewport: page.getViewport(1),\n  });\n\n  const expectedImageData = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mNkYAAAAAYAAjCB0C8AAAAASUVORK5CYII='; // Replace with correct expected data\n  const actualImageData = canvas.toDataURL();\n\n  assert.strictEqual(actualImageData, expectedImageData);\n});",
    "i3_gpt-4o": "it(\"should render large images in PDF\", async () => {\n  const { getDocument } = await import(\"../../src/display/api.js\");\n  const { buildGetDocumentParams } = await import(\"./test_utils.js\");\n  const loadingTask = getDocument(buildGetDocumentParams(\"issue17289.pdf\"));\n  const pdfDocument = await loadingTask.promise;\n  const page = await pdfDocument.getPage(1);\n  const viewport = page.getViewport({ scale: 1.0 });\n  const canvasFactory = new (await import(\"../../src/display/display_utils.js\")).DOMCanvasFactory();\n  const canvasAndContext = canvasFactory.create(viewport.width, viewport.height);\n  const renderTask = page.render({\n    canvasContext: canvasAndContext.context,\n    viewport,\n  });\n  await renderTask.promise;\n  const imageData = canvasAndContext.context.getImageData(0, 0, viewport.width, viewport.height);\n  const hasNonWhitePixels = imageData.data.some((value, index) => index % 4 !== 3 && value !== 255);\n  expect(hasNonWhitePixels).toBe(true);\n});",
    "i3_llama-3.3-70b-versatile": "it(\"should render large images in PDF\", async () => {\n  const { getDocument } = await import('../../src/display/api.js');\n  const { buildGetDocumentParams } = await import('./test_utils.js');\n  const loadingTask = getDocument(buildGetDocumentParams('issue17289.pdf'));\n  const pdfDocument = await loadingTask.promise;\n  const page = await pdfDocument.getPage(1);\n  const image = await page.getImage(0);\n  const imageData = await image.createImageData();\n  expect(imageData.data.length).toBeGreaterThan(0);\n});",
    "i4_deepseek-r1-distill-llama-70b": "it(\"should render large scanned images\", async () => {\n  const { getDocument } = await import('../../src/display/api.js');\n  const { buildGetDocumentParams } = await import('./test_utils.js');\n  const loadingTask = getDocument(buildGetDocumentParams('issue17289.pdf'));\n\n  const viewer = {\n    get canvasCtx() {\n      const canvas = document.createElement('canvas');\n      const ctx = canvas.getContext('2d');\n      return ctx;\n    },\n  };\n\n  const pdfDocument = await loadingTask.promise;\n  const pdfPage = await pdfDocument.getPage(1);\n  const scale = 1;\n  const viewport = pdfPage.getViewport({ scale });\n\n  await pdfPage.render({\n    viewport,\n    canvasContext: viewer.canvasCtx,\n    renderInteractive: false,\n    disableWebGL: true,\n  });\n\n  const canvas = viewer.canvasCtx.canvas;\n  const imageData = canvas.getContext('2d').getImageData(\n    0,\n    0,\n    canvas.width,\n    canvas.height\n  );\n\n  let hasNonTransparentPixel = false;\n  for (let i = 0; i < imageData.data.length; i += 4) {\n    if (imageData.data[i + 3] !== 0) {\n      hasNonTransparentPixel = true;\n      break;\n    }\n  }\n\n  if (!hasNonTransparentPixel) {\n    throw new Error(\"Image was not rendered\");\n  }\n});",
    "i4_gpt-4o": "it(\"should render large images in PDF\", async () => {\n  const { getDocument } = await import('../../src/display/api.js');\n  const { buildGetDocumentParams } = await import('./test_utils.js');\n  const loadingTask = getDocument(buildGetDocumentParams('issue17289.pdf'));\n  const pdfDocument = await loadingTask.promise;\n  const page = await pdfDocument.getPage(1);\n  const viewport = page.getViewport({ scale: 1.0 });\n  const canvasFactory = new (await import('../../src/display/display_utils.js')).DOMCanvasFactory();\n  const canvasAndContext = canvasFactory.create(viewport.width, viewport.height);\n  const renderTask = page.render({\n    canvasContext: canvasAndContext.context,\n    viewport: viewport,\n  });\n  await renderTask.promise;\n  const imageData = canvasAndContext.context.getImageData(0, 0, viewport.width, viewport.height);\n  const hasNonWhitePixels = imageData.data.some((value, index) => index % 4 !== 3 && value !== 255);\n  expect(hasNonWhitePixels).toBe(true);\n});",
    "i4_llama-3.3-70b-versatile": "it(\"should render large images in PDF that other renderers do\", async () => {\n  const { getDocument } = await import('../../src/display/api.js');\n  const { buildGetDocumentParams } = await import('./test_utils.js');\n  const loadingTask = getDocument(buildGetDocumentParams('issue17289.pdf'));\n  const pdfDocument = await loadingTask.promise;\n  const pdfPage = await pdfDocument.getPage(1);\n  const image = await pdfPage.getOperatorList().find((operator) => operator.name === 'Do');\n  const imageData = await image.getImage();\n  const expectedWidth = 1654;\n  const expectedHeight = 2339;\n  assert.equal(imageData.width, expectedWidth, `Expected width to be ${expectedWidth}`);\n  assert.equal(imageData.height, expectedHeight, `Expected height to be ${expectedHeight}`);\n});",
    "i5_deepseek-r1-distill-llama-70b": "it(\"should render large JPX images correctly\", async () => {\n  const { getDocument } = await import('../../src/display/api.js');\n  const { buildGetDocumentParams } = await import('./test_utils.js');\n\n  const loadingTask = getDocument(buildGetDocumentParams('issue17289.pdf'));\n  const pdf = await loadingTask.promise;\n\n  try {\n    const page = await pdf.getPage(1);\n    const viewport = page.getViewport({ scale: 1 });\n    const renderTask = page.render({\n      viewport,\n      enableWebGL: false,\n      enableCanvas: true,\n      useTransform: true,\n    });\n\n    await renderTask.promise;\n    const renderedPages = renderTask.renderedPages;\n    expect(renderedPages).toHaveLength(1);\n    expect(renderedPages[0].error).toBeUndefined();\n  } finally {\n    await pdf.destroy();\n  }\n});",
    "i5_gpt-4o": "it(\"should render large images in PDF\", async () => {\n  const { getDocument } = await import('../../src/display/api.js');\n  const { buildGetDocumentParams } = await import('./test_utils.js');\n  const loadingTask = getDocument(buildGetDocumentParams('issue17289.pdf'));\n  const pdfDocument = await loadingTask.promise;\n  const page = await pdfDocument.getPage(1);\n  const viewport = page.getViewport({ scale: 1.0 });\n  const canvasFactory = new (await import('../../src/display/display_utils.js')).DOMCanvasFactory();\n  const canvasAndContext = canvasFactory.create(viewport.width, viewport.height);\n  const renderTask = page.render({\n    canvasContext: canvasAndContext.context,\n    viewport: viewport,\n  });\n  await renderTask.promise;\n  const imageData = canvasAndContext.context.getImageData(0, 0, viewport.width, viewport.height);\n  const hasNonWhitePixels = imageData.data.some((value, index) => index % 4 !== 3 && value !== 255);\n  expect(hasNonWhitePixels).toBe(true);\n});",
    "i5_llama-3.3-70b-versatile": "it(\"should render large images in PDF\", async () => {\n  const { getDocument } = await import('../../src/display/api.js');\n  const { buildGetDocumentParams } = await import('./test_utils.js');\n  const loadingTask = getDocument(buildGetDocumentParams('issue17289.pdf'));\n  const pdfDocument = await loadingTask.promise;\n  const pdfPage = await pdfDocument.getPage(1);\n  const pageViewport = pdfPage.getViewport({ scale: 1 });\n  const renderTask = pdfPage.render({\n    viewport: pageViewport,\n    intent: 'display',\n  });\n  const renderedPage = await renderTask.promise;\n  const imageRendered = renderedPage.items.some((item) => item.type === 'image');\n  expect(imageRendered).toBe(true);\n});"
  },
  "17956": {
    "i1_deepseek-r1-distill-llama-70b": "it(\"should throw JpxError with OpenJPEG error message\", async () => {\n  const { JpxImage } = await import(\"../../src/core/jpx.js\");\n  const { JpxError } = await import(\"../shared/util.js\");\n  const invalidJpxData = new Uint8Array(10); // Invalid JPX data\n\n  const decodePromise = JpxImage.decode(invalidJpxData, false);\n  await expect(decodePromise).rejects.toThrow(JpxError);\n  const error = await decodePromise.catch(err => err);\n  expect(error.message).toBe(\"Unknown format\");\n});",
    "i1_gpt-4o": "it(\"should not log OpenJPEG Unknown format to the console\", async () => {\n  const { JpxImage } = await import(\"../../src/core/jpx.js\");\n  const consoleSpy = jest.spyOn(console, 'log').mockImplementation(() => {});\n  const invalidData = new Uint8Array([0, 1, 2, 3]); // Example invalid data\n  try {\n    JpxImage.decode(invalidData, false);\n  } catch (e) {\n    // Expected to throw an error\n  }\n  expect(consoleSpy).not.toHaveBeenCalledWith(expect.stringContaining(\"OpenJPEG: Unknown format\"));\n  consoleSpy.mockRestore();\n});",
    "i1_llama-3.3-70b-versatile": "it(\"should not throw an error when OpenJPEG decode fails\", async () => {\n  const { JpxImage } = await import(\"../../src/core/jpx.js\");\n  const { JpxError } = await import(\"../../src/core/jpx.js\");\n  const invalidData = new Uint8Array([0x00, 0x00, 0x00, 0x00]);\n  const ignoreColorSpace = false;\n  let error;\n  try {\n    JpxImage.decode(invalidData, ignoreColorSpace);\n  } catch (e) {\n    error = e;\n  }\n  expect(error).toBeInstanceOf(JpxError);\n  expect(error.message).not.toBe(\"JPX decode failed\");\n});",
    "i2_deepseek-r1-distill-llama-70b": "it(\"should throw JpxError with OpenJPEG error message\", async () => {\n  const { JpxImage } = await import(\"../../src/core/jpx.js\");\n  const { OpenJPEG } = await import(\"../../external/openjpeg/openjpeg.js\");\n\n  // Mock the OpenJPEG module to return an error string\n  const mockOpenJPEG = {\n    decode: jest.fn((data, ignoreColorSpace) => {\n      return \"OpenJPEG: Unknown format\";\n    })\n  };\n\n  // Set the mock as the OpenJPEG module\n  JpxImage.#module = mockOpenJPEG;\n\n  // Use invalid data to trigger the error\n  const invalidData = new Uint8Array([0x00, 0x00, 0x00, 0x00]);\n\n  // Test that the error is correctly thrown and includes OpenJPEG message\n  const error = await JpxImage.decode(invalidData, false).catch(err => err);\n  expect(error.message).toBe(\"OpenJPEG: Unknown format\");\n});",
    "i2_gpt-4o": "it(\"should throw a JpxError with the error message from OpenJPEG\", async () => {\n  const { JpxImage } = await import(\"../../src/core/jpx.js\");\n  const invalidData = new Uint8Array([0, 1, 2, 3]); // Example of invalid JPX data\n  let errorMessage = null;\n\n  try {\n    JpxImage.decode(invalidData, false);\n  } catch (error) {\n    errorMessage = error.message;\n  }\n\n  const expectedErrorMessage = \"OpenJPEG: Unknown format\";\n  expect(errorMessage).toBe(expectedErrorMessage);\n});",
    "i2_llama-3.3-70b-versatile": "it(\"should throw an exception with the error message returned by openjpeg\", async () => {\n  const { JpxImage } = await import(\"../../src/core/jpx.js\");\n  const { console } = globalThis;\n  const originalError = console.error;\n  let errorMessage;\n  console.error = (message) => {\n    errorMessage = message;\n  };\n  try {\n    await JpxImage.decode(null, true);\n  } catch (error) {\n    if (error instanceof Error && error.message.includes(\"Unknown format\")) {\n      // pass\n    } else {\n      throw error;\n    }\n  } finally {\n    console.error = originalError;\n  }\n  if (errorMessage && errorMessage.includes(\"Unknown format\")) {\n    throw new Error(\"Error message was not replaced\");\n  }\n});",
    "i3_deepseek-r1-distill-llama-70b": "it(\"should throw specific OpenJPEG error message\", async () => {\n  const { JpxImage } = await import(\"../../src/core/jpx.js\");\n  const mockData = new Uint8Array([0xff, 0xd8, 0xff, 0xe0]); // Sample invalid JPX data\n\n  await expect(JpxImage.decode(mockData, false)).rejects.toThrow(\n    new Error(\"JPX error: Unknown format\")\n  );\n});",
    "i3_gpt-4o": "it(\"should not log OpenJPEG Unknown format to the console\", async () => {\n  const { JpxImage } = await import(\"../../src/core/jpx.js\");\n  const { Stream } = await import(\"../../src/core/stream.js\");\n\n  const data = new Uint8Array([0xff, 0x4f, 0xff, 0x51]); // Invalid JPX data\n  const stream = new Stream(data);\n\n  const originalConsoleError = console.error;\n  let consoleOutput = \"\";\n  console.error = (msg) => {\n    consoleOutput += msg;\n  };\n\n  try {\n    JpxImage.decode(stream, false);\n  } catch (e) {\n    // Expected to throw JpxError\n  }\n\n  console.error = originalConsoleError;\n  expect(consoleOutput).not.toContain(\"OpenJPEG: Unknown format\");\n});",
    "i4_deepseek-r1-distill-llama-70b": "it(\"should throw specific error message when JPX decode fails\", async () => {\n  const { JpxImage } = await import(\"../../src/core/jpx.js\");\n  const badData = new Uint8Array([0xff, 0xd8, 0xff, 0xe0]); // Corrupted JPX data\n\n  try {\n    await JpxImage.decode(badData, false);\n    assert.fail(\"Expected JpxError to be thrown\");\n  } catch (error) {\n    if (error instanceof Error && error.message === \"JPX error: Unknown format\") {\n      // Expected error message after patch\n      return;\n    }\n    assert.fail(\"Expected error message 'Unknown format' but got something else\");\n  }\n});",
    "i4_gpt-4o": "it(\"should throw JpxError with message from OpenJPEG without logging to console\", async () => {\n  const { JpxImage } = await import(\"../../src/core/jpx.js\");\n  const invalidData = new Uint8Array([0, 1, 2, 3]); // Invalid JPX data\n  let errorMessage = \"\";\n  try {\n    JpxImage.decode(invalidData, false);\n  } catch (error) {\n    errorMessage = error.message;\n  }\n  const expectedMessage = \"JPX error: Unknown format\";\n  expect(errorMessage).toBe(expectedMessage);\n});",
    "i4_llama-3.3-70b-versatile": "it(\"should not log OpenJPEG Unknown format when decoding fails\", async () => {\n  const { JpxImage } = await import(\"../../src/core/jpx.js\");\n  const { console } = globalThis;\n  const originalLog = console.log;\n  const originalError = console.error;\n  let loggedMessage = null;\n  console.log = (...args) => {\n    if (args[0].includes(\"OpenJPEG: Unknown format\")) {\n      loggedMessage = args[0];\n    }\n  };\n  console.error = (...args) => {\n    if (args[0].includes(\"OpenJPEG: Unknown format\")) {\n      loggedMessage = args[0];\n    }\n  };\n  try {\n    await JpxImage.decode(new Uint8Array(), false);\n  } catch (error) {\n    // expected\n  } finally {\n    console.log = originalLog;\n    console.error = originalError;\n  }\n  expect(loggedMessage).toBeNull();\n});",
    "i5_deepseek-r1-distill-llama-70b": "it(\"should throw JpxError with correct message when decoding invalid JPX data\", async () => {\n  const { JpxImage } = await import(\"../../src/core/jpx.js\");\n  const invalidData = new Uint8Array([0x00, 0x00, 0x00, 0x00]); // Invalid JPX data\n\n  await expect(JpxImage.decode(invalidData, false)).rejects.toThrow(\n    \"JpxError: JPX decode failed\"\n  );\n});",
    "i5_gpt-4o": "it(\"should throw JpxError with Unknown format message when OpenJPEG logs Unknown format\", async () => {\n  const { JpxImage } = await import(\"../../src/core/jpx.js\");\n  const invalidData = new Uint8Array([0, 1, 2, 3]); // Example invalid data\n  let errorMessage = \"\";\n\n  try {\n    JpxImage.decode(invalidData, false);\n  } catch (error) {\n    errorMessage = error.message;\n  }\n\n  const expectedMessage = \"OpenJPEG: Unknown format\";\n  expect(errorMessage).toBe(expectedMessage);\n});",
    "i5_llama-3.3-70b-versatile": "it(\"should not log OpenJPEG Unknown format when decoding JPX image\", async () => {\n  const { JpxImage } = await import(\"../../src/core/jpx.js\");\n  const consoleSpy = jest.spyOn(console, 'log');\n  const imageData = new Uint8Array([0x00, 0x00, 0x00, 0x0C, 0x6A, 0x50, 0x20, 0x20]);\n  try {\n    JpxImage.decode(imageData, false);\n  } catch (error) {\n    if (error instanceof JpxImage.JpxError) {\n      expect(consoleSpy).not.toHaveBeenCalledWith('OpenJPEG: Unknown format');\n    } else {\n      throw error;\n    }\n  }\n});"
  },
  "17985": {
    "i1_deepseek-r1-distill-llama-70b": "it(\"should respect verbosity levels for OpenJPEG warnings\", async () => {\n  const mockWarn = jest.fn();\n  const originalWarn = console.warn;\n\n  const { warn: utilWarn } = await import(\"../../src/shared/util.js\");\n  utilWarn.mockImplementation(mockWarn);\n\n  const data = new Uint8Array();\n\n  setVerbosityLevel(VerbosityLevel.error);\n  try {\n    await JpxImage.decode(data);\n  } catch (error) {\n    // Expected to throw an error\n  }\n  expect(mockWarn).not.toHaveBeenCalled();\n\n  mockWarn.mockClear();\n\n  setVerbosityLevel(VerbosityLevel.info);\n  try {\n    await JpxImage.decode(data);\n  } catch (error) {\n    // Expected to throw an error\n  }\n  expect(mockWarn).toHaveBeenCalled();\n\n  console.warn = originalWarn;\n});",
    "i1_gpt-4o": "it(\"should respect verbosity levels for OpenJPEG warnings\", async () => {\n  const { warn } = await import(\"../../src/shared/util.js\");\n  const originalWarn = console.warn;\n  let warnCalled = false;\n  console.warn = () => {\n    warnCalled = true;\n  };\n\n  setVerbosityLevel(VerbosityLevel.ERRORS);\n  JpxImage.decode(new Uint8Array([0, 1, 2, 3]), false);\n  expect(warnCalled).toBe(false);\n\n  setVerbosityLevel(VerbosityLevel.INFOS);\n  JpxImage.decode(new Uint8Array([0, 1, 2, 3]), false);\n  expect(warnCalled).toBe(true);\n\n  console.warn = originalWarn;\n});",
    "i2_deepseek-r1-distill-llama-70b": "it(\"should not log OpenJPEG warnings when verbosity is none\", async () => {\n  const { JpxImage } = await import(\"../../src/core/jpx.js\");\n  const { setVerbosityLevel, warn } = await import(\"../../shared/util.js\");\n\n  setVerbosityLevel(\"none\");\n  const spy = jest.spyOn(warn, \"warn\");\n\n  // Using a sample JPX file that may trigger a warning\n  const response = await fetch(\"test_file.jpx\");\n  const data = await response.arrayBuffer();\n\n  await JpxImage.decode(data);\n\n  expect(spy).not.toHaveBeenCalled();\n});\n\n\nit(\"should not log OpenJPEG warnings when verbosity is none\", async () => {\n  const { JpxImage } = await import(\"../../src/core/jpx.js\");\n  const { setVerbosityLevel, warn } = await import(\"../../shared/util.js\");\n\n  setVerbosityLevel(\"none\");\n  const spy = jest.spyOn(warn, \"warn\");\n\n  // Using a sample JPX file that may trigger a warning\n  const response = await fetch(\"test_file.jpx\");\n  const data = await response.arrayBuffer();\n\n  await JpxImage.decode(data);\n\n  expect(spy).not.toHaveBeenCalled();\n});",
    "i2_llama-3.3-70b-versatile": "it(\"should use the pdfjs warn when using jpx decoder\", async () => {\n  const { JpxImage, setVerbosityLevel, getVerbosityLevel } = await import(\"../../src/core/jpx.js\");\n  const { warn } = await import(\"../../src/shared/util.js\");\n  const originalWarn = console.warn;\n  const warnings = [];\n  console.warn = (...args) => warnings.push(...args);\n\n  setVerbosityLevel(0);\n  JpxImage.decode(\"invalid_data\");\n  expect(warnings.length).toBe(0);\n\n  setVerbosityLevel(1);\n  JpxImage.decode(\"invalid_data\");\n  expect(warnings.length).toBe(1);\n\n  console.warn = originalWarn;\n});",
    "i3_deepseek-r1-distill-llama-70b": "it(\"should respect verbosity level when issuing OpenJPEG warnings\", async () => {\n  const originalVerbosity = getVerbosityLevel();\n  const warnSpy = jest.spyOn(console, 'warn').mockImplementation(() => {});\n\n  try {\n    setVerbosityLevel(VerbosityLevel.error);\n\n    const testData = new TextEncoder('utf-8').encode('/* jpx data */');\n    const result = await JpxImage.decode(testData);\n\n    expect(warnSpy).not.toHaveBeenCalled();\n  } catch (error) {\n    console.error('Error during JPX decoding:', error);\n    throw error;\n  } finally {\n    setVerbosityLevel(originalVerbosity);\n    warnSpy.mockRestore();\n  }\n});",
    "i3_gpt-4o": "it(\"should respect verbosity levels for OpenJPEG warnings\", async () => {\n  const { warn } = await import(\"../../src/shared/util.js\");\n  const originalWarn = console.warn;\n  let warnCalled = false;\n  console.warn = () => {\n    warnCalled = true;\n  };\n\n  setVerbosityLevel(VerbosityLevel.ERRORS);\n  JpxImage.decode(new Uint8Array([0, 1, 2, 3]), false);\n  expect(warnCalled).toBe(false);\n\n  setVerbosityLevel(VerbosityLevel.WARNINGS);\n  JpxImage.decode(new Uint8Array([0, 1, 2, 3]), false);\n  expect(warnCalled).toBe(true);\n\n  console.warn = originalWarn;\n});",
    "i3_llama-3.3-70b-versatile": "it(\"should respect the PDFjs verbosity levels for OpenJPEG warnings\", async () => {\n  const { setVerbosityLevel, getVerbosityLevel, VerbosityLevel } = await import(\"../../src/shared/util.js\");\n  const { JpxImage } = await import(\"../../src/core/jpx.js\");\n  const originalVerbosityLevel = getVerbosityLevel();\n  setVerbosityLevel(VerbosityLevel.WARN);\n  const warnSpy = jest.spyOn(console, 'warn');\n  const imageData = JpxImage.decode(new Uint8Array([0xff, 0x4f, 0xff, 0x51]), true);\n  expect(warnSpy).not.toHaveBeenCalled();\n  setVerbosityLevel(VerbosityLevel.ERROR);\n  warnSpy.mockReset();\n  const imageData2 = JpxImage.decode(new Uint8Array([0xff, 0x4f, 0xff, 0x51]), true);\n  expect(warnSpy).toHaveBeenCalledTimes(1);\n  setVerbosityLevel(originalVerbosityLevel);\n});",
    "i4_deepseek-r1-distill-llama-70b": "it(\"should respect verbosity level for OpenJPEG warnings\", async () => {\n  const { warn: utilWarn, setVerbosityLevel } = await import(\"../../src/shared/util.js\");\n  const { JpxImage } = await import(\"../../src/core/jpx.js\");\n\n  const mockWarn = jest.fn();\n  const originalWarn = console.warn;\n  console.warn = mockWarn;\n\n  // Set verbosity to 0 to suppress warnings\n  setVerbosityLevel(0);\n\n  const testData = new Uint8Array([0x00, 0x00, 0x00, 0x00]); // Data that triggers a warning\n\n  // Should not trigger a warning due to suppressed verbosity\n  await JpxImage.decode(testData);\n  expect(mockWarn).not.toHaveBeenCalled();\n\n  // Reset to default verbosity\n  setVerbosityLevel(1);\n\n  // Should trigger a warning now\n  await JpxImage.decode(testData);\n  expect(mockWarn).toHaveBeenCalled();\n\n  console.warn = originalWarn;\n});",
    "i4_llama-3.3-70b-versatile": "it(\"should respect the PDFjs verbosity levels for OpenJPEG warnings\", async () => {\n  const { setVerbosityLevel, VerbosityLevel, warn } = await import(\"../../src/shared/util.js\");\n  const { JpxImage } = await import(\"../../src/core/jpx.js\");\n  const { OpenJPEG } = await import(\"../../external/openjpeg/openjpeg.js\");\n\n  setVerbosityLevel(VerbosityLevel.WARN);\n  const originalWarn = console.warn;\n  let warned = false;\n  console.warn = (...args) => {\n    warned = true;\n  };\n\n  const openjpeg = OpenJPEG({ warn: () => {} });\n  JpxImage.decode(new Uint8Array([0xff, 0x51]), false);\n\n  console.warn = originalWarn;\n  setVerbosityLevel(VerbosityLevel.ERRORS);\n\n  const { JpxImage: JpxImagePatched } = await import(\"../../src/core/jpx.js\");\n  const { OpenJPEG: OpenJPEGPatched } = await import(\"../../external/openjpeg/openjpeg.js\");\n  const warnedPatched = false;\n  console.warn = (...args) => {\n    warnedPatched = true;\n  };\n\n  const openjpegPatched = OpenJPEGPatched({ warn: () => {} });\n  JpxImagePatched.decode(new Uint8Array([0xff, 0x51]), false);\n\n  console.warn = originalWarn;\n\n  expect(warned).toBe(true);\n  expect(warnedPatched).toBe(false);\n});",
    "i5_deepseek-r1-distill-llama-70b": "it(\"should respect verbosity level when decoding JPX images\", async () => {\n  const { setVerbosityLevel, VerbosityLevel } = await import(\"../../src/shared/util.js\");\n  const { JpxImage } = await import(\"../../src/core/jpx.js\");\n  const testJpxFile = await import(\"../../test/data/jpx/test.jpx\");\n\n  setVerbosityLevel(VerbosityLevel.none);\n\n  const consoleWarnSpy = jest.spyOn(console, 'warn').mockImplementation(() => {});\n\n  try {\n    await JpxImage.decode(await testJpxFile.arrayBuffer());\n  } catch (error) {\n    expect(error).toBeUndefined();\n  }\n\n  expect(consoleWarnSpy).not.toHaveBeenCalled();\n\n  consoleWarnSpy.mockRestore();\n});",
    "i5_llama-3.3-70b-versatile": "it(\"should respect the PDFjs verbosity levels for OpenJPEG warnings\", async () => {\n  const { setVerbosityLevel, VerbosityLevel, JpxImage } = await import(\"../../src/core/util.js\");\n  const { OpenJPEG } = await import(\"../../external/openjpeg/openjpeg.js\");\n\n  setVerbosityLevel(VerbosityLevel.DISABLE);\n  const originalWarn = console.warn;\n  const warnCalls = [];\n  console.warn = (...args) => {\n    warnCalls.push(...args);\n  };\n\n  const jpxImage = new JpxImage();\n  jpxImage.decode(new Uint8Array([0x00, 0x00, 0x00, 0x00]));\n\n  console.warn = originalWarn;\n  expect(warnCalls.length).toBe(0);\n\n  setVerbosityLevel(VerbosityLevel.WARN);\n  warnCalls.length = 0;\n  console.warn = (...args) => {\n    warnCalls.push(...args);\n  };\n\n  const jpxImage2 = new JpxImage();\n  jpxImage2.decode(new Uint8Array([0x00, 0x00, 0x00, 0x00]));\n\n  console.warn = originalWarn;\n  expect(warnCalls.length).toBeGreaterThan(0);\n});"
  },
  "18029": {
    "i1_deepseek-r1-distill-llama-70b": "it(\"should return valid URLs for alpha and luminosity SMask filters\", async () => {\n  const { DOMFilterFactory } = await import(\"../../src/display/display_utils.js\");\n  const factory = new DOMFilterFactory({ docId: 1 });\n  const map = Array.from({ length: 256 }, (_, i) => i);\n  const alphaFilterUrl = factory.addAlphaFilter(map);\n  const luminosityFilterUrl = factory.addLuminosityFilter(map);\n  if (alphaFilterUrl === \"none\" || luminosityFilterUrl === \"none\") {\n    throw new Error(\"SMask filter not applied properly\");\n  }\n  if (!alphaFilterUrl.includes(\"alpha_map\") || !luminosityFilterUrl.includes(\"luminosity_map\")) {\n    throw new Error(\"Unexpected filter URL format: \" + alphaFilterUrl + \" / \" + luminosityFilterUrl);\n  }\n});",
    "i1_gpt-4o": "it(\"should return valid URLs for alpha and luminosity SMask filters\", async () => {\n  const { DOMFilterFactory } = await import(\"../../src/display/display_utils.js\");\n  const factory = new DOMFilterFactory({ docId: 1 });\n  const map = Array.from({ length: 256 }, (_, i) => i);\n  const alphaFilterUrl = factory.addAlphaFilter(map);\n  const luminosityFilterUrl = factory.addLuminosityFilter(map);\n  if (alphaFilterUrl === \"none\" || luminosityFilterUrl === \"none\") {\n    throw new Error(\"SMask filter not applied properly\");\n  }\n  if (!alphaFilterUrl.includes(\"alpha_map\") || !luminosityFilterUrl.includes(\"luminosity_map\")) {\n    throw new Error(\"Unexpected filter URL format: \" + alphaFilterUrl + \" / \" + luminosityFilterUrl);\n  }\n});",
    "i1_llama-3.3-70b-versatile": "it(\"should return valid URLs for alpha and luminosity SMask filters\", async () => {\n  const { DOMFilterFactory } = await import(\"../../src/display/display_utils.js\");\n  const factory = new DOMFilterFactory({ docId: 1 });\n  const map = Array.from({ length: 256 }, (_, i) => i);\n  const alphaFilterUrl = factory.addAlphaFilter(map);\n  const luminosityFilterUrl = factory.addLuminosityFilter(map);\n  if (alphaFilterUrl === \"none\" || luminosityFilterUrl === \"none\") {\n    throw new Error(\"SMask filter not applied properly\");\n  }\n  if (!alphaFilterUrl.includes(\"alpha_map\") || !luminosityFilterUrl.includes(\"luminosity_map\")) {\n    throw new Error(\"Unexpected filter URL format: \" + alphaFilterUrl + \" / \" + luminosityFilterUrl);\n  }\n});",
    "i1_MOCK": "it(\"should return valid URLs for alpha and luminosity SMask filters\", async () => {\n  const { DOMFilterFactory } = await import(\"../../src/display/display_utils.js\");\n  const factory = new DOMFilterFactory({ docId: 1 });\n  const map = Array.from({ length: 256 }, (_, i) => i);\n  const alphaFilterUrl = factory.addAlphaFilter(map);\n  const luminosityFilterUrl = factory.addLuminosityFilter(map);\n  if (alphaFilterUrl === \"none\" || luminosityFilterUrl === \"none\") {\n    throw new Error(\"SMask filter not applied properly\");\n  }\n  if (!alphaFilterUrl.includes(\"alpha_map\") || !luminosityFilterUrl.includes(\"luminosity_map\")) {\n    throw new Error(\"Unexpected filter URL format: \" + alphaFilterUrl + \" / \" + luminosityFilterUrl);\n  }\n});",
    "i2_deepseek-r1-distill-llama-70b": "it(\"should return valid URLs for alpha and luminosity SMask filters\", async () => {\n  const { DOMFilterFactory } = await import(\"../../src/display/display_utils.js\");\n  const factory = new DOMFilterFactory({ docId: 1 });\n  const map = Array.from({ length: 256 }, (_, i) => i);\n  const alphaFilterUrl = factory.addAlphaFilter(map);\n  const luminosityFilterUrl = factory.addLuminosityFilter(map);\n  if (alphaFilterUrl === \"none\" || luminosityFilterUrl === \"none\") {\n    throw new Error(\"SMask filter not applied properly\");\n  }\n  if (!alphaFilterUrl.includes(\"alpha_map\") || !luminosityFilterUrl.includes(\"luminosity_map\")) {\n    throw new Error(\"Unexpected filter URL format: \" + alphaFilterUrl + \" / \" + luminosityFilterUrl);\n  }\n});",
    "i2_gpt-4o": "it(\"should return valid URLs for alpha and luminosity SMask filters\", async () => {\n  const { DOMFilterFactory } = await import(\"../../src/display/display_utils.js\");\n  const factory = new DOMFilterFactory({ docId: 1 });\n  const map = Array.from({ length: 256 }, (_, i) => i);\n  const alphaFilterUrl = factory.addAlphaFilter(map);\n  const luminosityFilterUrl = factory.addLuminosityFilter(map);\n  if (alphaFilterUrl === \"none\" || luminosityFilterUrl === \"none\") {\n    throw new Error(\"SMask filter not applied properly\");\n  }\n  if (!alphaFilterUrl.includes(\"alpha_map\") || !luminosityFilterUrl.includes(\"luminosity_map\")) {\n    throw new Error(\"Unexpected filter URL format: \" + alphaFilterUrl + \" / \" + luminosityFilterUrl);\n  }\n});",
    "i2_llama-3.3-70b-versatile": "it(\"should return valid URLs for alpha and luminosity SMask filters\", async () => {\n  const { DOMFilterFactory } = await import(\"../../src/display/display_utils.js\");\n  const factory = new DOMFilterFactory({ docId: 1 });\n  const map = Array.from({ length: 256 }, (_, i) => i);\n  const alphaFilterUrl = factory.addAlphaFilter(map);\n  const luminosityFilterUrl = factory.addLuminosityFilter(map);\n  if (alphaFilterUrl === \"none\" || luminosityFilterUrl === \"none\") {\n    throw new Error(\"SMask filter not applied properly\");\n  }\n  if (!alphaFilterUrl.includes(\"alpha_map\") || !luminosityFilterUrl.includes(\"luminosity_map\")) {\n    throw new Error(\"Unexpected filter URL format: \" + alphaFilterUrl + \" / \" + luminosityFilterUrl);\n  }\n});",
    "i3_deepseek-r1-distill-llama-70b": "it(\"should return valid URLs for alpha and luminosity SMask filters\", async () => {\n  const { DOMFilterFactory } = await import(\"../../src/display/display_utils.js\");\n  const factory = new DOMFilterFactory({ docId: 1 });\n  const map = Array.from({ length: 256 }, (_, i) => i);\n  const alphaFilterUrl = factory.addAlphaFilter(map);\n  const luminosityFilterUrl = factory.addLuminosityFilter(map);\n  if (alphaFilterUrl === \"none\" || luminosityFilterUrl === \"none\") {\n    throw new Error(\"SMask filter not applied properly\");\n  }\n  if (!alphaFilterUrl.includes(\"alpha_map\") || !luminosityFilterUrl.includes(\"luminosity_map\")) {\n    throw new Error(\"Unexpected filter URL format: \" + alphaFilterUrl + \" / \" + luminosityFilterUrl);\n  }\n});",
    "i3_gpt-4o": "it(\"should return valid URLs for alpha and luminosity SMask filters\", async () => {\n  const { DOMFilterFactory } = await import(\"../../src/display/display_utils.js\");\n  const factory = new DOMFilterFactory({ docId: 1 });\n  const map = Array.from({ length: 256 }, (_, i) => i);\n  const alphaFilterUrl = factory.addAlphaFilter(map);\n  const luminosityFilterUrl = factory.addLuminosityFilter(map);\n  if (alphaFilterUrl === \"none\" || luminosityFilterUrl === \"none\") {\n    throw new Error(\"SMask filter not applied properly\");\n  }\n  if (!alphaFilterUrl.includes(\"alpha_map\") || !luminosityFilterUrl.includes(\"luminosity_map\")) {\n    throw new Error(\"Unexpected filter URL format: \" + alphaFilterUrl + \" / \" + luminosityFilterUrl);\n  }\n});",
    "i3_llama-3.3-70b-versatile": "it(\"should return valid URLs for alpha and luminosity SMask filters\", async () => {\n  const { DOMFilterFactory } = await import(\"../../src/display/display_utils.js\");\n  const factory = new DOMFilterFactory({ docId: 1 });\n  const map = Array.from({ length: 256 }, (_, i) => i);\n  const alphaFilterUrl = factory.addAlphaFilter(map);\n  const luminosityFilterUrl = factory.addLuminosityFilter(map);\n  if (alphaFilterUrl === \"none\" || luminosityFilterUrl === \"none\") {\n    throw new Error(\"SMask filter not applied properly\");\n  }\n  if (!alphaFilterUrl.includes(\"alpha_map\") || !luminosityFilterUrl.includes(\"luminosity_map\")) {\n    throw new Error(\"Unexpected filter URL format: \" + alphaFilterUrl + \" / \" + luminosityFilterUrl);\n  }\n});",
    "i4_deepseek-r1-distill-llama-70b": "it(\"should return valid URLs for alpha and luminosity SMask filters\", async () => {\n  const { DOMFilterFactory } = await import(\"../../src/display/display_utils.js\");\n  const factory = new DOMFilterFactory({ docId: 1 });\n  const map = Array.from({ length: 256 }, (_, i) => i);\n  const alphaFilterUrl = factory.addAlphaFilter(map);\n  const luminosityFilterUrl = factory.addLuminosityFilter(map);\n  if (alphaFilterUrl === \"none\" || luminosityFilterUrl === \"none\") {\n    throw new Error(\"SMask filter not applied properly\");\n  }\n  if (!alphaFilterUrl.includes(\"alpha_map\") || !luminosityFilterUrl.includes(\"luminosity_map\")) {\n    throw new Error(\"Unexpected filter URL format: \" + alphaFilterUrl + \" / \" + luminosityFilterUrl);\n  }\n});",
    "i4_gpt-4o": "it(\"should return valid URLs for alpha and luminosity SMask filters\", async () => {\n  const { DOMFilterFactory } = await import(\"../../src/display/display_utils.js\");\n  const factory = new DOMFilterFactory({ docId: 1 });\n  const map = Array.from({ length: 256 }, (_, i) => i);\n  const alphaFilterUrl = factory.addAlphaFilter(map);\n  const luminosityFilterUrl = factory.addLuminosityFilter(map);\n  if (alphaFilterUrl === \"none\" || luminosityFilterUrl === \"none\") {\n    throw new Error(\"SMask filter not applied properly\");\n  }\n  if (!alphaFilterUrl.includes(\"alpha_map\") || !luminosityFilterUrl.includes(\"luminosity_map\")) {\n    throw new Error(\"Unexpected filter URL format: \" + alphaFilterUrl + \" / \" + luminosityFilterUrl);\n  }\n});",
    "i4_llama-3.3-70b-versatile": "it(\"should return valid URLs for alpha and luminosity SMask filters\", async () => {\n  const { DOMFilterFactory } = await import(\"../../src/display/display_utils.js\");\n  const factory = new DOMFilterFactory({ docId: 1 });\n  const map = Array.from({ length: 256 }, (_, i) => i);\n  const alphaFilterUrl = factory.addAlphaFilter(map);\n  const luminosityFilterUrl = factory.addLuminosityFilter(map);\n  if (alphaFilterUrl === \"none\" || luminosityFilterUrl === \"none\") {\n    throw new Error(\"SMask filter not applied properly\");\n  }\n  if (!alphaFilterUrl.includes(\"alpha_map\") || !luminosityFilterUrl.includes(\"luminosity_map\")) {\n    throw new Error(\"Unexpected filter URL format: \" + alphaFilterUrl + \" / \" + luminosityFilterUrl);\n  }\n});",
    "i5_deepseek-r1-distill-llama-70b": "it(\"should return valid URLs for alpha and luminosity SMask filters\", async () => {\n  const { DOMFilterFactory } = await import(\"../../src/display/display_utils.js\");\n  const factory = new DOMFilterFactory({ docId: 1 });\n  const map = Array.from({ length: 256 }, (_, i) => i);\n  const alphaFilterUrl = factory.addAlphaFilter(map);\n  const luminosityFilterUrl = factory.addLuminosityFilter(map);\n  if (alphaFilterUrl === \"none\" || luminosityFilterUrl === \"none\") {\n    throw new Error(\"SMask filter not applied properly\");\n  }\n  if (!alphaFilterUrl.includes(\"alpha_map\") || !luminosityFilterUrl.includes(\"luminosity_map\")) {\n    throw new Error(\"Unexpected filter URL format: \" + alphaFilterUrl + \" / \" + luminosityFilterUrl);\n  }\n});",
    "i5_gpt-4o": "it(\"should return valid URLs for alpha and luminosity SMask filters\", async () => {\n  const { DOMFilterFactory } = await import(\"../../src/display/display_utils.js\");\n  const factory = new DOMFilterFactory({ docId: 1 });\n  const map = Array.from({ length: 256 }, (_, i) => i);\n  const alphaFilterUrl = factory.addAlphaFilter(map);\n  const luminosityFilterUrl = factory.addLuminosityFilter(map);\n  if (alphaFilterUrl === \"none\" || luminosityFilterUrl === \"none\") {\n    throw new Error(\"SMask filter not applied properly\");\n  }\n  if (!alphaFilterUrl.includes(\"alpha_map\") || !luminosityFilterUrl.includes(\"luminosity_map\")) {\n    throw new Error(\"Unexpected filter URL format: \" + alphaFilterUrl + \" / \" + luminosityFilterUrl);\n  }\n});",
    "i5_llama-3.3-70b-versatile": "it(\"should return valid URLs for alpha and luminosity SMask filters\", async () => {\n  const { DOMFilterFactory } = await import(\"../../src/display/display_utils.js\");\n  const factory = new DOMFilterFactory({ docId: 1 });\n  const map = Array.from({ length: 256 }, (_, i) => i);\n  const alphaFilterUrl = factory.addAlphaFilter(map);\n  const luminosityFilterUrl = factory.addLuminosityFilter(map);\n  if (alphaFilterUrl === \"none\" || luminosityFilterUrl === \"none\") {\n    throw new Error(\"SMask filter not applied properly\");\n  }\n  if (!alphaFilterUrl.includes(\"alpha_map\") || !luminosityFilterUrl.includes(\"luminosity_map\")) {\n    throw new Error(\"Unexpected filter URL format: \" + alphaFilterUrl + \" / \" + luminosityFilterUrl);\n  }\n});"
  },
  "18119": {
    "i1_deepseek-r1-distill-llama-70b": "it(\"should correctly handle char codes greater than 2311 in adjustMapping\", async () => {\n  const { adjustMapping } = await import(\"../../src/core/fonts.js\");\n  // create a mapping with a key greater than 2147483647\n  const inputMapping = { \"3000000000\": 42 };\n  const hasGlyph = glyphId => true;\n  const newGlyphZeroId = 0;\n  const toUnicode = new Map();\n  const result = adjustMapping(inputMapping, hasGlyph, newGlyphZeroId, toUnicode);\n  if (result.toFontChar[\"3000000000\"] === undefined) {\n    throw new Error(\"Failed to map char code '3000000000' correctly.\");\n  }\n});\n",
    "i1_gpt-4o": "it(\"should correctly handle char codes greater than 2311 in adjustMapping\", async () => {\n  const { adjustMapping } = await import(\"../../src/core/fonts.js\");\n  // create a mapping with a key greater than 2147483647\n  const inputMapping = { \"3000000000\": 42 };\n  const hasGlyph = glyphId => true;\n  const newGlyphZeroId = 0;\n  const toUnicode = new Map();\n  const result = adjustMapping(inputMapping, hasGlyph, newGlyphZeroId, toUnicode);\n  if (result.toFontChar[\"3000000000\"] === undefined) {\n    throw new Error(\"Failed to map char code '3000000000' correctly.\");\n  }\n});\n",
    "i1_llama-3.3-70b-versatile": "it(\"should correctly handle char codes greater than 2311 in adjustMapping\", async () => {\n  const { adjustMapping } = await import(\"../../src/core/fonts.js\");\n  // create a mapping with a key greater than 2147483647\n  const inputMapping = { \"3000000000\": 42 };\n  const hasGlyph = glyphId => true;\n  const newGlyphZeroId = 0;\n  const toUnicode = new Map();\n  const result = adjustMapping(inputMapping, hasGlyph, newGlyphZeroId, toUnicode);\n  if (result.toFontChar[\"3000000000\"] === undefined) {\n    throw new Error(\"Failed to map char code '3000000000' correctly.\");\n  }\n});\n",
    "i1_MOCK": "it(\"should correctly handle char codes greater than 2311 in adjustMapping\", async () => {\n  const { adjustMapping } = await import(\"../../src/core/fonts.js\");\n  // create a mapping with a key greater than 2147483647\n  const inputMapping = { \"3000000000\": 42 };\n  const hasGlyph = glyphId => true;\n  const newGlyphZeroId = 0;\n  const toUnicode = new Map();\n  const result = adjustMapping(inputMapping, hasGlyph, newGlyphZeroId, toUnicode);\n  if (result.toFontChar[\"3000000000\"] === undefined) {\n    throw new Error(\"Failed to map char code '3000000000' correctly.\");\n  }\n});\n",
    "i2_deepseek-r1-distill-llama-70b": "it(\"should correctly handle char codes greater than 2311 in adjustMapping\", async () => {\n  const { adjustMapping } = await import(\"../../src/core/fonts.js\");\n  // create a mapping with a key greater than 2147483647\n  const inputMapping = { \"3000000000\": 42 };\n  const hasGlyph = glyphId => true;\n  const newGlyphZeroId = 0;\n  const toUnicode = new Map();\n  const result = adjustMapping(inputMapping, hasGlyph, newGlyphZeroId, toUnicode);\n  if (result.toFontChar[\"3000000000\"] === undefined) {\n    throw new Error(\"Failed to map char code '3000000000' correctly.\");\n  }\n});\n",
    "i2_gpt-4o": "it(\"should correctly handle char codes greater than 2311 in adjustMapping\", async () => {\n  const { adjustMapping } = await import(\"../../src/core/fonts.js\");\n  // create a mapping with a key greater than 2147483647\n  const inputMapping = { \"3000000000\": 42 };\n  const hasGlyph = glyphId => true;\n  const newGlyphZeroId = 0;\n  const toUnicode = new Map();\n  const result = adjustMapping(inputMapping, hasGlyph, newGlyphZeroId, toUnicode);\n  if (result.toFontChar[\"3000000000\"] === undefined) {\n    throw new Error(\"Failed to map char code '3000000000' correctly.\");\n  }\n});\n",
    "i2_llama-3.3-70b-versatile": "it(\"should correctly handle char codes greater than 2311 in adjustMapping\", async () => {\n  const { adjustMapping } = await import(\"../../src/core/fonts.js\");\n  // create a mapping with a key greater than 2147483647\n  const inputMapping = { \"3000000000\": 42 };\n  const hasGlyph = glyphId => true;\n  const newGlyphZeroId = 0;\n  const toUnicode = new Map();\n  const result = adjustMapping(inputMapping, hasGlyph, newGlyphZeroId, toUnicode);\n  if (result.toFontChar[\"3000000000\"] === undefined) {\n    throw new Error(\"Failed to map char code '3000000000' correctly.\");\n  }\n});\n",
    "i3_deepseek-r1-distill-llama-70b": "it(\"should correctly handle char codes greater than 2311 in adjustMapping\", async () => {\n  const { adjustMapping } = await import(\"../../src/core/fonts.js\");\n  // create a mapping with a key greater than 2147483647\n  const inputMapping = { \"3000000000\": 42 };\n  const hasGlyph = glyphId => true;\n  const newGlyphZeroId = 0;\n  const toUnicode = new Map();\n  const result = adjustMapping(inputMapping, hasGlyph, newGlyphZeroId, toUnicode);\n  if (result.toFontChar[\"3000000000\"] === undefined) {\n    throw new Error(\"Failed to map char code '3000000000' correctly.\");\n  }\n});\n",
    "i3_gpt-4o": "it(\"should correctly handle char codes greater than 2311 in adjustMapping\", async () => {\n  const { adjustMapping } = await import(\"../../src/core/fonts.js\");\n  // create a mapping with a key greater than 2147483647\n  const inputMapping = { \"3000000000\": 42 };\n  const hasGlyph = glyphId => true;\n  const newGlyphZeroId = 0;\n  const toUnicode = new Map();\n  const result = adjustMapping(inputMapping, hasGlyph, newGlyphZeroId, toUnicode);\n  if (result.toFontChar[\"3000000000\"] === undefined) {\n    throw new Error(\"Failed to map char code '3000000000' correctly.\");\n  }\n});\n",
    "i3_llama-3.3-70b-versatile": "it(\"should correctly handle char codes greater than 2311 in adjustMapping\", async () => {\n  const { adjustMapping } = await import(\"../../src/core/fonts.js\");\n  // create a mapping with a key greater than 2147483647\n  const inputMapping = { \"3000000000\": 42 };\n  const hasGlyph = glyphId => true;\n  const newGlyphZeroId = 0;\n  const toUnicode = new Map();\n  const result = adjustMapping(inputMapping, hasGlyph, newGlyphZeroId, toUnicode);\n  if (result.toFontChar[\"3000000000\"] === undefined) {\n    throw new Error(\"Failed to map char code '3000000000' correctly.\");\n  }\n});\n",
    "i4_deepseek-r1-distill-llama-70b": "it(\"should correctly handle char codes greater than 2311 in adjustMapping\", async () => {\n  const { adjustMapping } = await import(\"../../src/core/fonts.js\");\n  // create a mapping with a key greater than 2147483647\n  const inputMapping = { \"3000000000\": 42 };\n  const hasGlyph = glyphId => true;\n  const newGlyphZeroId = 0;\n  const toUnicode = new Map();\n  const result = adjustMapping(inputMapping, hasGlyph, newGlyphZeroId, toUnicode);\n  if (result.toFontChar[\"3000000000\"] === undefined) {\n    throw new Error(\"Failed to map char code '3000000000' correctly.\");\n  }\n});\n",
    "i4_gpt-4o": "it(\"should correctly handle char codes greater than 2311 in adjustMapping\", async () => {\n  const { adjustMapping } = await import(\"../../src/core/fonts.js\");\n  // create a mapping with a key greater than 2147483647\n  const inputMapping = { \"3000000000\": 42 };\n  const hasGlyph = glyphId => true;\n  const newGlyphZeroId = 0;\n  const toUnicode = new Map();\n  const result = adjustMapping(inputMapping, hasGlyph, newGlyphZeroId, toUnicode);\n  if (result.toFontChar[\"3000000000\"] === undefined) {\n    throw new Error(\"Failed to map char code '3000000000' correctly.\");\n  }\n});\n",
    "i4_llama-3.3-70b-versatile": "it(\"should correctly handle char codes greater than 2311 in adjustMapping\", async () => {\n  const { adjustMapping } = await import(\"../../src/core/fonts.js\");\n  // create a mapping with a key greater than 2147483647\n  const inputMapping = { \"3000000000\": 42 };\n  const hasGlyph = glyphId => true;\n  const newGlyphZeroId = 0;\n  const toUnicode = new Map();\n  const result = adjustMapping(inputMapping, hasGlyph, newGlyphZeroId, toUnicode);\n  if (result.toFontChar[\"3000000000\"] === undefined) {\n    throw new Error(\"Failed to map char code '3000000000' correctly.\");\n  }\n});\n",
    "i5_deepseek-r1-distill-llama-70b": "it(\"should correctly handle char codes greater than 2311 in adjustMapping\", async () => {\n  const { adjustMapping } = await import(\"../../src/core/fonts.js\");\n  // create a mapping with a key greater than 2147483647\n  const inputMapping = { \"3000000000\": 42 };\n  const hasGlyph = glyphId => true;\n  const newGlyphZeroId = 0;\n  const toUnicode = new Map();\n  const result = adjustMapping(inputMapping, hasGlyph, newGlyphZeroId, toUnicode);\n  if (result.toFontChar[\"3000000000\"] === undefined) {\n    throw new Error(\"Failed to map char code '3000000000' correctly.\");\n  }\n});\n",
    "i5_gpt-4o": "it(\"should correctly handle char codes greater than 2311 in adjustMapping\", async () => {\n  const { adjustMapping } = await import(\"../../src/core/fonts.js\");\n  // create a mapping with a key greater than 2147483647\n  const inputMapping = { \"3000000000\": 42 };\n  const hasGlyph = glyphId => true;\n  const newGlyphZeroId = 0;\n  const toUnicode = new Map();\n  const result = adjustMapping(inputMapping, hasGlyph, newGlyphZeroId, toUnicode);\n  if (result.toFontChar[\"3000000000\"] === undefined) {\n    throw new Error(\"Failed to map char code '3000000000' correctly.\");\n  }\n});\n",
    "i5_llama-3.3-70b-versatile": "it(\"should correctly handle char codes greater than 2311 in adjustMapping\", async () => {\n  const { adjustMapping } = await import(\"../../src/core/fonts.js\");\n  // create a mapping with a key greater than 2147483647\n  const inputMapping = { \"3000000000\": 42 };\n  const hasGlyph = glyphId => true;\n  const newGlyphZeroId = 0;\n  const toUnicode = new Map();\n  const result = adjustMapping(inputMapping, hasGlyph, newGlyphZeroId, toUnicode);\n  if (result.toFontChar[\"3000000000\"] === undefined) {\n    throw new Error(\"Failed to map char code '3000000000' correctly.\");\n  }\n});\n"
  },
  "18125": {
    "i1_deepseek-r1-distill-llama-70b": "it(\"should correctly detect a truncated endstream marker and return the proper stream length\", async () => {\n  const assert = require(\"assert\");\n  const { StringStream } = await import(\"../../src/core/stream.js\");\n  const { Lexer, Parser } = await import(\"../../src/core/parser.js\");\n  // Construct a fake PDF stream:\n  // \"stream\" followed by a newline, then the stream data \"123456\",\n  // then a truncated \"endstream\" command \"endstrea \" (i.e. missing final character, but followed by whitespace),\n  // then a proper \"endstream\" (which will not be reached).\n  const pdfData = \"stream\\n123456endstrea \\nendstream\";\n  const stream = new StringStream(pdfData);\n  const lexer = new Lexer(stream);\n  const parser = new Parser({ lexer, xref: {} });\n  // Provide an incorrect declared length to force scanning for the endstream marker.\n  const dict = { get: key => key === \"Length\" ? 2 : null };\n  const resultStream = parser.makeStream(dict, null);\n  // The expected stream data is the bytes starting at startPos (one byte before the first character after \"stream\\n\")\n  // up to the beginning of the truncated \"endstream\" marker.\n  // In our pdfData, after \"stream\\n\" (i.e. after byte index 6), the data \"123456\" occupies 6 bytes,\n  // plus the newline before \"stream\" makes the total length 7.\n  const actualLength = resultStream.end - resultStream.pos;\n  assert.strictEqual(actualLength, 7);\n});",
    "i1_gpt-4o": "it(\"should correctly detect a truncated endstream marker and return the proper stream length\", async () => {\n  const assert = require(\"assert\");\n  const { StringStream } = await import(\"../../src/core/stream.js\");\n  const { Lexer, Parser } = await import(\"../../src/core/parser.js\");\n  // Construct a fake PDF stream:\n  // \"stream\" followed by a newline, then the stream data \"123456\",\n  // then a truncated \"endstream\" command \"endstrea \" (i.e. missing final character, but followed by whitespace),\n  // then a proper \"endstream\" (which will not be reached).\n  const pdfData = \"stream\\n123456endstrea \\nendstream\";\n  const stream = new StringStream(pdfData);\n  const lexer = new Lexer(stream);\n  const parser = new Parser({ lexer, xref: {} });\n  // Provide an incorrect declared length to force scanning for the endstream marker.\n  const dict = { get: key => key === \"Length\" ? 2 : null };\n  const resultStream = parser.makeStream(dict, null);\n  // The expected stream data is the bytes starting at startPos (one byte before the first character after \"stream\\n\")\n  // up to the beginning of the truncated \"endstream\" marker.\n  // In our pdfData, after \"stream\\n\" (i.e. after byte index 6), the data \"123456\" occupies 6 bytes,\n  // plus the newline before \"stream\" makes the total length 7.\n  const actualLength = resultStream.end - resultStream.pos;\n  assert.strictEqual(actualLength, 7);\n});",
    "i1_llama-3.3-70b-versatile": "it(\"should correctly detect a truncated endstream marker and return the proper stream length\", async () => {\n  const assert = require(\"assert\");\n  const { StringStream } = await import(\"../../src/core/stream.js\");\n  const { Lexer, Parser } = await import(\"../../src/core/parser.js\");\n  // Construct a fake PDF stream:\n  // \"stream\" followed by a newline, then the stream data \"123456\",\n  // then a truncated \"endstream\" command \"endstrea \" (i.e. missing final character, but followed by whitespace),\n  // then a proper \"endstream\" (which will not be reached).\n  const pdfData = \"stream\\n123456endstrea \\nendstream\";\n  const stream = new StringStream(pdfData);\n  const lexer = new Lexer(stream);\n  const parser = new Parser({ lexer, xref: {} });\n  // Provide an incorrect declared length to force scanning for the endstream marker.\n  const dict = { get: key => key === \"Length\" ? 2 : null };\n  const resultStream = parser.makeStream(dict, null);\n  // The expected stream data is the bytes starting at startPos (one byte before the first character after \"stream\\n\")\n  // up to the beginning of the truncated \"endstream\" marker.\n  // In our pdfData, after \"stream\\n\" (i.e. after byte index 6), the data \"123456\" occupies 6 bytes,\n  // plus the newline before \"stream\" makes the total length 7.\n  const actualLength = resultStream.end - resultStream.pos;\n  assert.strictEqual(actualLength, 7);\n});",
    "i1_MOCK": "it(\"should correctly detect a truncated endstream marker and return the proper stream length\", async () => {\n  const assert = require(\"assert\");\n  const { StringStream } = await import(\"../../src/core/stream.js\");\n  const { Lexer, Parser } = await import(\"../../src/core/parser.js\");\n  // Construct a fake PDF stream:\n  // \"stream\" followed by a newline, then the stream data \"123456\",\n  // then a truncated \"endstream\" command \"endstrea \" (i.e. missing final character, but followed by whitespace),\n  // then a proper \"endstream\" (which will not be reached).\n  const pdfData = \"stream\\n123456endstrea \\nendstream\";\n  const stream = new StringStream(pdfData);\n  const lexer = new Lexer(stream);\n  const parser = new Parser({ lexer, xref: {} });\n  // Provide an incorrect declared length to force scanning for the endstream marker.\n  const dict = { get: key => key === \"Length\" ? 2 : null };\n  const resultStream = parser.makeStream(dict, null);\n  // The expected stream data is the bytes starting at startPos (one byte before the first character after \"stream\\n\")\n  // up to the beginning of the truncated \"endstream\" marker.\n  // In our pdfData, after \"stream\\n\" (i.e. after byte index 6), the data \"123456\" occupies 6 bytes,\n  // plus the newline before \"stream\" makes the total length 7.\n  const actualLength = resultStream.end - resultStream.pos;\n  assert.strictEqual(actualLength, 7);\n});",
    "i2_deepseek-r1-distill-llama-70b": "it(\"should correctly detect a truncated endstream marker and return the proper stream length\", async () => {\n  const assert = require(\"assert\");\n  const { StringStream } = await import(\"../../src/core/stream.js\");\n  const { Lexer, Parser } = await import(\"../../src/core/parser.js\");\n  // Construct a fake PDF stream:\n  // \"stream\" followed by a newline, then the stream data \"123456\",\n  // then a truncated \"endstream\" command \"endstrea \" (i.e. missing final character, but followed by whitespace),\n  // then a proper \"endstream\" (which will not be reached).\n  const pdfData = \"stream\\n123456endstrea \\nendstream\";\n  const stream = new StringStream(pdfData);\n  const lexer = new Lexer(stream);\n  const parser = new Parser({ lexer, xref: {} });\n  // Provide an incorrect declared length to force scanning for the endstream marker.\n  const dict = { get: key => key === \"Length\" ? 2 : null };\n  const resultStream = parser.makeStream(dict, null);\n  // The expected stream data is the bytes starting at startPos (one byte before the first character after \"stream\\n\")\n  // up to the beginning of the truncated \"endstream\" marker.\n  // In our pdfData, after \"stream\\n\" (i.e. after byte index 6), the data \"123456\" occupies 6 bytes,\n  // plus the newline before \"stream\" makes the total length 7.\n  const actualLength = resultStream.end - resultStream.pos;\n  assert.strictEqual(actualLength, 7);\n});",
    "i2_gpt-4o": "it(\"should correctly detect a truncated endstream marker and return the proper stream length\", async () => {\n  const assert = require(\"assert\");\n  const { StringStream } = await import(\"../../src/core/stream.js\");\n  const { Lexer, Parser } = await import(\"../../src/core/parser.js\");\n  // Construct a fake PDF stream:\n  // \"stream\" followed by a newline, then the stream data \"123456\",\n  // then a truncated \"endstream\" command \"endstrea \" (i.e. missing final character, but followed by whitespace),\n  // then a proper \"endstream\" (which will not be reached).\n  const pdfData = \"stream\\n123456endstrea \\nendstream\";\n  const stream = new StringStream(pdfData);\n  const lexer = new Lexer(stream);\n  const parser = new Parser({ lexer, xref: {} });\n  // Provide an incorrect declared length to force scanning for the endstream marker.\n  const dict = { get: key => key === \"Length\" ? 2 : null };\n  const resultStream = parser.makeStream(dict, null);\n  // The expected stream data is the bytes starting at startPos (one byte before the first character after \"stream\\n\")\n  // up to the beginning of the truncated \"endstream\" marker.\n  // In our pdfData, after \"stream\\n\" (i.e. after byte index 6), the data \"123456\" occupies 6 bytes,\n  // plus the newline before \"stream\" makes the total length 7.\n  const actualLength = resultStream.end - resultStream.pos;\n  assert.strictEqual(actualLength, 7);\n});",
    "i2_llama-3.3-70b-versatile": "it(\"should correctly detect a truncated endstream marker and return the proper stream length\", async () => {\n  const assert = require(\"assert\");\n  const { StringStream } = await import(\"../../src/core/stream.js\");\n  const { Lexer, Parser } = await import(\"../../src/core/parser.js\");\n  // Construct a fake PDF stream:\n  // \"stream\" followed by a newline, then the stream data \"123456\",\n  // then a truncated \"endstream\" command \"endstrea \" (i.e. missing final character, but followed by whitespace),\n  // then a proper \"endstream\" (which will not be reached).\n  const pdfData = \"stream\\n123456endstrea \\nendstream\";\n  const stream = new StringStream(pdfData);\n  const lexer = new Lexer(stream);\n  const parser = new Parser({ lexer, xref: {} });\n  // Provide an incorrect declared length to force scanning for the endstream marker.\n  const dict = { get: key => key === \"Length\" ? 2 : null };\n  const resultStream = parser.makeStream(dict, null);\n  // The expected stream data is the bytes starting at startPos (one byte before the first character after \"stream\\n\")\n  // up to the beginning of the truncated \"endstream\" marker.\n  // In our pdfData, after \"stream\\n\" (i.e. after byte index 6), the data \"123456\" occupies 6 bytes,\n  // plus the newline before \"stream\" makes the total length 7.\n  const actualLength = resultStream.end - resultStream.pos;\n  assert.strictEqual(actualLength, 7);\n});",
    "i3_deepseek-r1-distill-llama-70b": "it(\"should correctly detect a truncated endstream marker and return the proper stream length\", async () => {\n  const assert = require(\"assert\");\n  const { StringStream } = await import(\"../../src/core/stream.js\");\n  const { Lexer, Parser } = await import(\"../../src/core/parser.js\");\n  // Construct a fake PDF stream:\n  // \"stream\" followed by a newline, then the stream data \"123456\",\n  // then a truncated \"endstream\" command \"endstrea \" (i.e. missing final character, but followed by whitespace),\n  // then a proper \"endstream\" (which will not be reached).\n  const pdfData = \"stream\\n123456endstrea \\nendstream\";\n  const stream = new StringStream(pdfData);\n  const lexer = new Lexer(stream);\n  const parser = new Parser({ lexer, xref: {} });\n  // Provide an incorrect declared length to force scanning for the endstream marker.\n  const dict = { get: key => key === \"Length\" ? 2 : null };\n  const resultStream = parser.makeStream(dict, null);\n  // The expected stream data is the bytes starting at startPos (one byte before the first character after \"stream\\n\")\n  // up to the beginning of the truncated \"endstream\" marker.\n  // In our pdfData, after \"stream\\n\" (i.e. after byte index 6), the data \"123456\" occupies 6 bytes,\n  // plus the newline before \"stream\" makes the total length 7.\n  const actualLength = resultStream.end - resultStream.pos;\n  assert.strictEqual(actualLength, 7);\n});",
    "i3_gpt-4o": "it(\"should correctly detect a truncated endstream marker and return the proper stream length\", async () => {\n  const assert = require(\"assert\");\n  const { StringStream } = await import(\"../../src/core/stream.js\");\n  const { Lexer, Parser } = await import(\"../../src/core/parser.js\");\n  // Construct a fake PDF stream:\n  // \"stream\" followed by a newline, then the stream data \"123456\",\n  // then a truncated \"endstream\" command \"endstrea \" (i.e. missing final character, but followed by whitespace),\n  // then a proper \"endstream\" (which will not be reached).\n  const pdfData = \"stream\\n123456endstrea \\nendstream\";\n  const stream = new StringStream(pdfData);\n  const lexer = new Lexer(stream);\n  const parser = new Parser({ lexer, xref: {} });\n  // Provide an incorrect declared length to force scanning for the endstream marker.\n  const dict = { get: key => key === \"Length\" ? 2 : null };\n  const resultStream = parser.makeStream(dict, null);\n  // The expected stream data is the bytes starting at startPos (one byte before the first character after \"stream\\n\")\n  // up to the beginning of the truncated \"endstream\" marker.\n  // In our pdfData, after \"stream\\n\" (i.e. after byte index 6), the data \"123456\" occupies 6 bytes,\n  // plus the newline before \"stream\" makes the total length 7.\n  const actualLength = resultStream.end - resultStream.pos;\n  assert.strictEqual(actualLength, 7);\n});",
    "i3_llama-3.3-70b-versatile": "it(\"should correctly detect a truncated endstream marker and return the proper stream length\", async () => {\n  const assert = require(\"assert\");\n  const { StringStream } = await import(\"../../src/core/stream.js\");\n  const { Lexer, Parser } = await import(\"../../src/core/parser.js\");\n  // Construct a fake PDF stream:\n  // \"stream\" followed by a newline, then the stream data \"123456\",\n  // then a truncated \"endstream\" command \"endstrea \" (i.e. missing final character, but followed by whitespace),\n  // then a proper \"endstream\" (which will not be reached).\n  const pdfData = \"stream\\n123456endstrea \\nendstream\";\n  const stream = new StringStream(pdfData);\n  const lexer = new Lexer(stream);\n  const parser = new Parser({ lexer, xref: {} });\n  // Provide an incorrect declared length to force scanning for the endstream marker.\n  const dict = { get: key => key === \"Length\" ? 2 : null };\n  const resultStream = parser.makeStream(dict, null);\n  // The expected stream data is the bytes starting at startPos (one byte before the first character after \"stream\\n\")\n  // up to the beginning of the truncated \"endstream\" marker.\n  // In our pdfData, after \"stream\\n\" (i.e. after byte index 6), the data \"123456\" occupies 6 bytes,\n  // plus the newline before \"stream\" makes the total length 7.\n  const actualLength = resultStream.end - resultStream.pos;\n  assert.strictEqual(actualLength, 7);\n});",
    "i4_deepseek-r1-distill-llama-70b": "it(\"should correctly detect a truncated endstream marker and return the proper stream length\", async () => {\n  const assert = require(\"assert\");\n  const { StringStream } = await import(\"../../src/core/stream.js\");\n  const { Lexer, Parser } = await import(\"../../src/core/parser.js\");\n  // Construct a fake PDF stream:\n  // \"stream\" followed by a newline, then the stream data \"123456\",\n  // then a truncated \"endstream\" command \"endstrea \" (i.e. missing final character, but followed by whitespace),\n  // then a proper \"endstream\" (which will not be reached).\n  const pdfData = \"stream\\n123456endstrea \\nendstream\";\n  const stream = new StringStream(pdfData);\n  const lexer = new Lexer(stream);\n  const parser = new Parser({ lexer, xref: {} });\n  // Provide an incorrect declared length to force scanning for the endstream marker.\n  const dict = { get: key => key === \"Length\" ? 2 : null };\n  const resultStream = parser.makeStream(dict, null);\n  // The expected stream data is the bytes starting at startPos (one byte before the first character after \"stream\\n\")\n  // up to the beginning of the truncated \"endstream\" marker.\n  // In our pdfData, after \"stream\\n\" (i.e. after byte index 6), the data \"123456\" occupies 6 bytes,\n  // plus the newline before \"stream\" makes the total length 7.\n  const actualLength = resultStream.end - resultStream.pos;\n  assert.strictEqual(actualLength, 7);\n});",
    "i4_gpt-4o": "it(\"should correctly detect a truncated endstream marker and return the proper stream length\", async () => {\n  const assert = require(\"assert\");\n  const { StringStream } = await import(\"../../src/core/stream.js\");\n  const { Lexer, Parser } = await import(\"../../src/core/parser.js\");\n  // Construct a fake PDF stream:\n  // \"stream\" followed by a newline, then the stream data \"123456\",\n  // then a truncated \"endstream\" command \"endstrea \" (i.e. missing final character, but followed by whitespace),\n  // then a proper \"endstream\" (which will not be reached).\n  const pdfData = \"stream\\n123456endstrea \\nendstream\";\n  const stream = new StringStream(pdfData);\n  const lexer = new Lexer(stream);\n  const parser = new Parser({ lexer, xref: {} });\n  // Provide an incorrect declared length to force scanning for the endstream marker.\n  const dict = { get: key => key === \"Length\" ? 2 : null };\n  const resultStream = parser.makeStream(dict, null);\n  // The expected stream data is the bytes starting at startPos (one byte before the first character after \"stream\\n\")\n  // up to the beginning of the truncated \"endstream\" marker.\n  // In our pdfData, after \"stream\\n\" (i.e. after byte index 6), the data \"123456\" occupies 6 bytes,\n  // plus the newline before \"stream\" makes the total length 7.\n  const actualLength = resultStream.end - resultStream.pos;\n  assert.strictEqual(actualLength, 7);\n});",
    "i4_llama-3.3-70b-versatile": "it(\"should correctly detect a truncated endstream marker and return the proper stream length\", async () => {\n  const assert = require(\"assert\");\n  const { StringStream } = await import(\"../../src/core/stream.js\");\n  const { Lexer, Parser } = await import(\"../../src/core/parser.js\");\n  // Construct a fake PDF stream:\n  // \"stream\" followed by a newline, then the stream data \"123456\",\n  // then a truncated \"endstream\" command \"endstrea \" (i.e. missing final character, but followed by whitespace),\n  // then a proper \"endstream\" (which will not be reached).\n  const pdfData = \"stream\\n123456endstrea \\nendstream\";\n  const stream = new StringStream(pdfData);\n  const lexer = new Lexer(stream);\n  const parser = new Parser({ lexer, xref: {} });\n  // Provide an incorrect declared length to force scanning for the endstream marker.\n  const dict = { get: key => key === \"Length\" ? 2 : null };\n  const resultStream = parser.makeStream(dict, null);\n  // The expected stream data is the bytes starting at startPos (one byte before the first character after \"stream\\n\")\n  // up to the beginning of the truncated \"endstream\" marker.\n  // In our pdfData, after \"stream\\n\" (i.e. after byte index 6), the data \"123456\" occupies 6 bytes,\n  // plus the newline before \"stream\" makes the total length 7.\n  const actualLength = resultStream.end - resultStream.pos;\n  assert.strictEqual(actualLength, 7);\n});",
    "i5_deepseek-r1-distill-llama-70b": "it(\"should correctly detect a truncated endstream marker and return the proper stream length\", async () => {\n  const assert = require(\"assert\");\n  const { StringStream } = await import(\"../../src/core/stream.js\");\n  const { Lexer, Parser } = await import(\"../../src/core/parser.js\");\n  // Construct a fake PDF stream:\n  // \"stream\" followed by a newline, then the stream data \"123456\",\n  // then a truncated \"endstream\" command \"endstrea \" (i.e. missing final character, but followed by whitespace),\n  // then a proper \"endstream\" (which will not be reached).\n  const pdfData = \"stream\\n123456endstrea \\nendstream\";\n  const stream = new StringStream(pdfData);\n  const lexer = new Lexer(stream);\n  const parser = new Parser({ lexer, xref: {} });\n  // Provide an incorrect declared length to force scanning for the endstream marker.\n  const dict = { get: key => key === \"Length\" ? 2 : null };\n  const resultStream = parser.makeStream(dict, null);\n  // The expected stream data is the bytes starting at startPos (one byte before the first character after \"stream\\n\")\n  // up to the beginning of the truncated \"endstream\" marker.\n  // In our pdfData, after \"stream\\n\" (i.e. after byte index 6), the data \"123456\" occupies 6 bytes,\n  // plus the newline before \"stream\" makes the total length 7.\n  const actualLength = resultStream.end - resultStream.pos;\n  assert.strictEqual(actualLength, 7);\n});",
    "i5_gpt-4o": "it(\"should correctly detect a truncated endstream marker and return the proper stream length\", async () => {\n  const assert = require(\"assert\");\n  const { StringStream } = await import(\"../../src/core/stream.js\");\n  const { Lexer, Parser } = await import(\"../../src/core/parser.js\");\n  // Construct a fake PDF stream:\n  // \"stream\" followed by a newline, then the stream data \"123456\",\n  // then a truncated \"endstream\" command \"endstrea \" (i.e. missing final character, but followed by whitespace),\n  // then a proper \"endstream\" (which will not be reached).\n  const pdfData = \"stream\\n123456endstrea \\nendstream\";\n  const stream = new StringStream(pdfData);\n  const lexer = new Lexer(stream);\n  const parser = new Parser({ lexer, xref: {} });\n  // Provide an incorrect declared length to force scanning for the endstream marker.\n  const dict = { get: key => key === \"Length\" ? 2 : null };\n  const resultStream = parser.makeStream(dict, null);\n  // The expected stream data is the bytes starting at startPos (one byte before the first character after \"stream\\n\")\n  // up to the beginning of the truncated \"endstream\" marker.\n  // In our pdfData, after \"stream\\n\" (i.e. after byte index 6), the data \"123456\" occupies 6 bytes,\n  // plus the newline before \"stream\" makes the total length 7.\n  const actualLength = resultStream.end - resultStream.pos;\n  assert.strictEqual(actualLength, 7);\n});",
    "i5_llama-3.3-70b-versatile": "it(\"should correctly detect a truncated endstream marker and return the proper stream length\", async () => {\n  const assert = require(\"assert\");\n  const { StringStream } = await import(\"../../src/core/stream.js\");\n  const { Lexer, Parser } = await import(\"../../src/core/parser.js\");\n  // Construct a fake PDF stream:\n  // \"stream\" followed by a newline, then the stream data \"123456\",\n  // then a truncated \"endstream\" command \"endstrea \" (i.e. missing final character, but followed by whitespace),\n  // then a proper \"endstream\" (which will not be reached).\n  const pdfData = \"stream\\n123456endstrea \\nendstream\";\n  const stream = new StringStream(pdfData);\n  const lexer = new Lexer(stream);\n  const parser = new Parser({ lexer, xref: {} });\n  // Provide an incorrect declared length to force scanning for the endstream marker.\n  const dict = { get: key => key === \"Length\" ? 2 : null };\n  const resultStream = parser.makeStream(dict, null);\n  // The expected stream data is the bytes starting at startPos (one byte before the first character after \"stream\\n\")\n  // up to the beginning of the truncated \"endstream\" marker.\n  // In our pdfData, after \"stream\\n\" (i.e. after byte index 6), the data \"123456\" occupies 6 bytes,\n  // plus the newline before \"stream\" makes the total length 7.\n  const actualLength = resultStream.end - resultStream.pos;\n  assert.strictEqual(actualLength, 7);\n});"
  },
  "18143": {
    "i1_deepseek-r1-distill-llama-70b": "it(\"should recognize a page dictionary with Contents no Type or Kids as a valid page\", async () => {\n  const { PDFDocument } = await import(\"../../src/core/document.js\");\n  const { Dict, Ref } = await import(\"../../src/core/primitives.js\");\n  const { StringStream } = await import(\"../../src/core/stream.js\");\n\n  class MapWithHasPut extends Map {\n    put(key, value) {\n      this.set(key, value);\n    }\n  }\n\n  // Create a page dictionary with \"Contents\" but without \"Type\" or \"Kids\".\n  const pageDict = new Dict();\n  pageDict.set(\"Contents\", \"dummy content\");\n\n  // Prepare a fake reference corresponding to object number 1 and generation 0.\n  const fakeRef = Ref.get(1, 0);\n\n  // Create a fake XRef with a fetchAsync method that returns our pageDict for fakeRef.\n  const xref = {\n    fetchAsync: async function (ref) {\n      if (ref.num === fakeRef.num && ref.gen === fakeRef.gen) {\n        return pageDict;\n      }\n      throw new Error(\"Unexpected reference.\");\n    },\n  };\n\n  // Create a minimal linearization object.\n  const linearization = {\n    pageFirst: 0,\n    objectNumberFirst: 1,\n  };\n\n  // Minimal catalog with required cache methods.\n  const catalog = {\n    pageKidsCountCache: new MapWithHasPut(),\n    pageIndexCache: new MapWithHasPut(),\n    getPageDict: () => {\n      throw new Error(\"getPageDict should not be called in this test\");\n    },\n  };\n\n  // Create a dummy stream.\n  const stream = new StringStream(\"dummy\");\n\n  // Instantiate PDFDocument with a dummy pdfManager.\n  const pdfDoc = new PDFDocument({ docId: 123 }, stream);\n  pdfDoc.linearization = linearization;\n  pdfDoc.catalog = catalog;\n  pdfDoc.xref = xref;\n\n  const [resultDict, resultRef] = await pdfDoc._getLinearizationPage(0);\n  if (resultDict !== pageDict) {\n    throw new Error(\"The page dictionary was not correctly recognized.\");\n  }\n  if (resultRef.num !== fakeRef.num || resultRef.gen !== fakeRef.gen) {\n    throw new Error(\"The page reference returned is incorrect.\");\n  }\n});\n",
    "i1_gpt-4o": "it(\"should recognize a page dictionary with Contents no Type or Kids as a valid page\", async () => {\n  const { PDFDocument } = await import(\"../../src/core/document.js\");\n  const { Dict, Ref } = await import(\"../../src/core/primitives.js\");\n  const { StringStream } = await import(\"../../src/core/stream.js\");\n\n  class MapWithHasPut extends Map {\n    put(key, value) {\n      this.set(key, value);\n    }\n  }\n\n  // Create a page dictionary with \"Contents\" but without \"Type\" or \"Kids\".\n  const pageDict = new Dict();\n  pageDict.set(\"Contents\", \"dummy content\");\n\n  // Prepare a fake reference corresponding to object number 1 and generation 0.\n  const fakeRef = Ref.get(1, 0);\n\n  // Create a fake XRef with a fetchAsync method that returns our pageDict for fakeRef.\n  const xref = {\n    fetchAsync: async function (ref) {\n      if (ref.num === fakeRef.num && ref.gen === fakeRef.gen) {\n        return pageDict;\n      }\n      throw new Error(\"Unexpected reference.\");\n    },\n  };\n\n  // Create a minimal linearization object.\n  const linearization = {\n    pageFirst: 0,\n    objectNumberFirst: 1,\n  };\n\n  // Minimal catalog with required cache methods.\n  const catalog = {\n    pageKidsCountCache: new MapWithHasPut(),\n    pageIndexCache: new MapWithHasPut(),\n    getPageDict: () => {\n      throw new Error(\"getPageDict should not be called in this test\");\n    },\n  };\n\n  // Create a dummy stream.\n  const stream = new StringStream(\"dummy\");\n\n  // Instantiate PDFDocument with a dummy pdfManager.\n  const pdfDoc = new PDFDocument({ docId: 123 }, stream);\n  pdfDoc.linearization = linearization;\n  pdfDoc.catalog = catalog;\n  pdfDoc.xref = xref;\n\n  const [resultDict, resultRef] = await pdfDoc._getLinearizationPage(0);\n  if (resultDict !== pageDict) {\n    throw new Error(\"The page dictionary was not correctly recognized.\");\n  }\n  if (resultRef.num !== fakeRef.num || resultRef.gen !== fakeRef.gen) {\n    throw new Error(\"The page reference returned is incorrect.\");\n  }\n});\n",
    "i1_llama-3.3-70b-versatile": "it(\"should recognize a page dictionary with Contents no Type or Kids as a valid page\", async () => {\n  const { PDFDocument } = await import(\"../../src/core/document.js\");\n  const { Dict, Ref } = await import(\"../../src/core/primitives.js\");\n  const { StringStream } = await import(\"../../src/core/stream.js\");\n\n  class MapWithHasPut extends Map {\n    put(key, value) {\n      this.set(key, value);\n    }\n  }\n\n  // Create a page dictionary with \"Contents\" but without \"Type\" or \"Kids\".\n  const pageDict = new Dict();\n  pageDict.set(\"Contents\", \"dummy content\");\n\n  // Prepare a fake reference corresponding to object number 1 and generation 0.\n  const fakeRef = Ref.get(1, 0);\n\n  // Create a fake XRef with a fetchAsync method that returns our pageDict for fakeRef.\n  const xref = {\n    fetchAsync: async function (ref) {\n      if (ref.num === fakeRef.num && ref.gen === fakeRef.gen) {\n        return pageDict;\n      }\n      throw new Error(\"Unexpected reference.\");\n    },\n  };\n\n  // Create a minimal linearization object.\n  const linearization = {\n    pageFirst: 0,\n    objectNumberFirst: 1,\n  };\n\n  // Minimal catalog with required cache methods.\n  const catalog = {\n    pageKidsCountCache: new MapWithHasPut(),\n    pageIndexCache: new MapWithHasPut(),\n    getPageDict: () => {\n      throw new Error(\"getPageDict should not be called in this test\");\n    },\n  };\n\n  // Create a dummy stream.\n  const stream = new StringStream(\"dummy\");\n\n  // Instantiate PDFDocument with a dummy pdfManager.\n  const pdfDoc = new PDFDocument({ docId: 123 }, stream);\n  pdfDoc.linearization = linearization;\n  pdfDoc.catalog = catalog;\n  pdfDoc.xref = xref;\n\n  const [resultDict, resultRef] = await pdfDoc._getLinearizationPage(0);\n  if (resultDict !== pageDict) {\n    throw new Error(\"The page dictionary was not correctly recognized.\");\n  }\n  if (resultRef.num !== fakeRef.num || resultRef.gen !== fakeRef.gen) {\n    throw new Error(\"The page reference returned is incorrect.\");\n  }\n});\n",
    "i1_MOCK": "it(\"should recognize a page dictionary with Contents no Type or Kids as a valid page\", async () => {\n  const { PDFDocument } = await import(\"../../src/core/document.js\");\n  const { Dict, Ref } = await import(\"../../src/core/primitives.js\");\n  const { StringStream } = await import(\"../../src/core/stream.js\");\n\n  class MapWithHasPut extends Map {\n    put(key, value) {\n      this.set(key, value);\n    }\n  }\n\n  // Create a page dictionary with \"Contents\" but without \"Type\" or \"Kids\".\n  const pageDict = new Dict();\n  pageDict.set(\"Contents\", \"dummy content\");\n\n  // Prepare a fake reference corresponding to object number 1 and generation 0.\n  const fakeRef = Ref.get(1, 0);\n\n  // Create a fake XRef with a fetchAsync method that returns our pageDict for fakeRef.\n  const xref = {\n    fetchAsync: async function (ref) {\n      if (ref.num === fakeRef.num && ref.gen === fakeRef.gen) {\n        return pageDict;\n      }\n      throw new Error(\"Unexpected reference.\");\n    },\n  };\n\n  // Create a minimal linearization object.\n  const linearization = {\n    pageFirst: 0,\n    objectNumberFirst: 1,\n  };\n\n  // Minimal catalog with required cache methods.\n  const catalog = {\n    pageKidsCountCache: new MapWithHasPut(),\n    pageIndexCache: new MapWithHasPut(),\n    getPageDict: () => {\n      throw new Error(\"getPageDict should not be called in this test\");\n    },\n  };\n\n  // Create a dummy stream.\n  const stream = new StringStream(\"dummy\");\n\n  // Instantiate PDFDocument with a dummy pdfManager.\n  const pdfDoc = new PDFDocument({ docId: 123 }, stream);\n  pdfDoc.linearization = linearization;\n  pdfDoc.catalog = catalog;\n  pdfDoc.xref = xref;\n\n  const [resultDict, resultRef] = await pdfDoc._getLinearizationPage(0);\n  if (resultDict !== pageDict) {\n    throw new Error(\"The page dictionary was not correctly recognized.\");\n  }\n  if (resultRef.num !== fakeRef.num || resultRef.gen !== fakeRef.gen) {\n    throw new Error(\"The page reference returned is incorrect.\");\n  }\n});\n",
    "i2_deepseek-r1-distill-llama-70b": "it(\"should recognize a page dictionary with Contents no Type or Kids as a valid page\", async () => {\n  const { PDFDocument } = await import(\"../../src/core/document.js\");\n  const { Dict, Ref } = await import(\"../../src/core/primitives.js\");\n  const { StringStream } = await import(\"../../src/core/stream.js\");\n\n  class MapWithHasPut extends Map {\n    put(key, value) {\n      this.set(key, value);\n    }\n  }\n\n  // Create a page dictionary with \"Contents\" but without \"Type\" or \"Kids\".\n  const pageDict = new Dict();\n  pageDict.set(\"Contents\", \"dummy content\");\n\n  // Prepare a fake reference corresponding to object number 1 and generation 0.\n  const fakeRef = Ref.get(1, 0);\n\n  // Create a fake XRef with a fetchAsync method that returns our pageDict for fakeRef.\n  const xref = {\n    fetchAsync: async function (ref) {\n      if (ref.num === fakeRef.num && ref.gen === fakeRef.gen) {\n        return pageDict;\n      }\n      throw new Error(\"Unexpected reference.\");\n    },\n  };\n\n  // Create a minimal linearization object.\n  const linearization = {\n    pageFirst: 0,\n    objectNumberFirst: 1,\n  };\n\n  // Minimal catalog with required cache methods.\n  const catalog = {\n    pageKidsCountCache: new MapWithHasPut(),\n    pageIndexCache: new MapWithHasPut(),\n    getPageDict: () => {\n      throw new Error(\"getPageDict should not be called in this test\");\n    },\n  };\n\n  // Create a dummy stream.\n  const stream = new StringStream(\"dummy\");\n\n  // Instantiate PDFDocument with a dummy pdfManager.\n  const pdfDoc = new PDFDocument({ docId: 123 }, stream);\n  pdfDoc.linearization = linearization;\n  pdfDoc.catalog = catalog;\n  pdfDoc.xref = xref;\n\n  const [resultDict, resultRef] = await pdfDoc._getLinearizationPage(0);\n  if (resultDict !== pageDict) {\n    throw new Error(\"The page dictionary was not correctly recognized.\");\n  }\n  if (resultRef.num !== fakeRef.num || resultRef.gen !== fakeRef.gen) {\n    throw new Error(\"The page reference returned is incorrect.\");\n  }\n});\n",
    "i2_gpt-4o": "it(\"should recognize a page dictionary with Contents no Type or Kids as a valid page\", async () => {\n  const { PDFDocument } = await import(\"../../src/core/document.js\");\n  const { Dict, Ref } = await import(\"../../src/core/primitives.js\");\n  const { StringStream } = await import(\"../../src/core/stream.js\");\n\n  class MapWithHasPut extends Map {\n    put(key, value) {\n      this.set(key, value);\n    }\n  }\n\n  // Create a page dictionary with \"Contents\" but without \"Type\" or \"Kids\".\n  const pageDict = new Dict();\n  pageDict.set(\"Contents\", \"dummy content\");\n\n  // Prepare a fake reference corresponding to object number 1 and generation 0.\n  const fakeRef = Ref.get(1, 0);\n\n  // Create a fake XRef with a fetchAsync method that returns our pageDict for fakeRef.\n  const xref = {\n    fetchAsync: async function (ref) {\n      if (ref.num === fakeRef.num && ref.gen === fakeRef.gen) {\n        return pageDict;\n      }\n      throw new Error(\"Unexpected reference.\");\n    },\n  };\n\n  // Create a minimal linearization object.\n  const linearization = {\n    pageFirst: 0,\n    objectNumberFirst: 1,\n  };\n\n  // Minimal catalog with required cache methods.\n  const catalog = {\n    pageKidsCountCache: new MapWithHasPut(),\n    pageIndexCache: new MapWithHasPut(),\n    getPageDict: () => {\n      throw new Error(\"getPageDict should not be called in this test\");\n    },\n  };\n\n  // Create a dummy stream.\n  const stream = new StringStream(\"dummy\");\n\n  // Instantiate PDFDocument with a dummy pdfManager.\n  const pdfDoc = new PDFDocument({ docId: 123 }, stream);\n  pdfDoc.linearization = linearization;\n  pdfDoc.catalog = catalog;\n  pdfDoc.xref = xref;\n\n  const [resultDict, resultRef] = await pdfDoc._getLinearizationPage(0);\n  if (resultDict !== pageDict) {\n    throw new Error(\"The page dictionary was not correctly recognized.\");\n  }\n  if (resultRef.num !== fakeRef.num || resultRef.gen !== fakeRef.gen) {\n    throw new Error(\"The page reference returned is incorrect.\");\n  }\n});\n",
    "i2_llama-3.3-70b-versatile": "it(\"should recognize a page dictionary with Contents no Type or Kids as a valid page\", async () => {\n  const { PDFDocument } = await import(\"../../src/core/document.js\");\n  const { Dict, Ref } = await import(\"../../src/core/primitives.js\");\n  const { StringStream } = await import(\"../../src/core/stream.js\");\n\n  class MapWithHasPut extends Map {\n    put(key, value) {\n      this.set(key, value);\n    }\n  }\n\n  // Create a page dictionary with \"Contents\" but without \"Type\" or \"Kids\".\n  const pageDict = new Dict();\n  pageDict.set(\"Contents\", \"dummy content\");\n\n  // Prepare a fake reference corresponding to object number 1 and generation 0.\n  const fakeRef = Ref.get(1, 0);\n\n  // Create a fake XRef with a fetchAsync method that returns our pageDict for fakeRef.\n  const xref = {\n    fetchAsync: async function (ref) {\n      if (ref.num === fakeRef.num && ref.gen === fakeRef.gen) {\n        return pageDict;\n      }\n      throw new Error(\"Unexpected reference.\");\n    },\n  };\n\n  // Create a minimal linearization object.\n  const linearization = {\n    pageFirst: 0,\n    objectNumberFirst: 1,\n  };\n\n  // Minimal catalog with required cache methods.\n  const catalog = {\n    pageKidsCountCache: new MapWithHasPut(),\n    pageIndexCache: new MapWithHasPut(),\n    getPageDict: () => {\n      throw new Error(\"getPageDict should not be called in this test\");\n    },\n  };\n\n  // Create a dummy stream.\n  const stream = new StringStream(\"dummy\");\n\n  // Instantiate PDFDocument with a dummy pdfManager.\n  const pdfDoc = new PDFDocument({ docId: 123 }, stream);\n  pdfDoc.linearization = linearization;\n  pdfDoc.catalog = catalog;\n  pdfDoc.xref = xref;\n\n  const [resultDict, resultRef] = await pdfDoc._getLinearizationPage(0);\n  if (resultDict !== pageDict) {\n    throw new Error(\"The page dictionary was not correctly recognized.\");\n  }\n  if (resultRef.num !== fakeRef.num || resultRef.gen !== fakeRef.gen) {\n    throw new Error(\"The page reference returned is incorrect.\");\n  }\n});\n",
    "i3_deepseek-r1-distill-llama-70b": "it(\"should recognize a page dictionary with Contents no Type or Kids as a valid page\", async () => {\n  const { PDFDocument } = await import(\"../../src/core/document.js\");\n  const { Dict, Ref } = await import(\"../../src/core/primitives.js\");\n  const { StringStream } = await import(\"../../src/core/stream.js\");\n\n  class MapWithHasPut extends Map {\n    put(key, value) {\n      this.set(key, value);\n    }\n  }\n\n  // Create a page dictionary with \"Contents\" but without \"Type\" or \"Kids\".\n  const pageDict = new Dict();\n  pageDict.set(\"Contents\", \"dummy content\");\n\n  // Prepare a fake reference corresponding to object number 1 and generation 0.\n  const fakeRef = Ref.get(1, 0);\n\n  // Create a fake XRef with a fetchAsync method that returns our pageDict for fakeRef.\n  const xref = {\n    fetchAsync: async function (ref) {\n      if (ref.num === fakeRef.num && ref.gen === fakeRef.gen) {\n        return pageDict;\n      }\n      throw new Error(\"Unexpected reference.\");\n    },\n  };\n\n  // Create a minimal linearization object.\n  const linearization = {\n    pageFirst: 0,\n    objectNumberFirst: 1,\n  };\n\n  // Minimal catalog with required cache methods.\n  const catalog = {\n    pageKidsCountCache: new MapWithHasPut(),\n    pageIndexCache: new MapWithHasPut(),\n    getPageDict: () => {\n      throw new Error(\"getPageDict should not be called in this test\");\n    },\n  };\n\n  // Create a dummy stream.\n  const stream = new StringStream(\"dummy\");\n\n  // Instantiate PDFDocument with a dummy pdfManager.\n  const pdfDoc = new PDFDocument({ docId: 123 }, stream);\n  pdfDoc.linearization = linearization;\n  pdfDoc.catalog = catalog;\n  pdfDoc.xref = xref;\n\n  const [resultDict, resultRef] = await pdfDoc._getLinearizationPage(0);\n  if (resultDict !== pageDict) {\n    throw new Error(\"The page dictionary was not correctly recognized.\");\n  }\n  if (resultRef.num !== fakeRef.num || resultRef.gen !== fakeRef.gen) {\n    throw new Error(\"The page reference returned is incorrect.\");\n  }\n});\n",
    "i3_gpt-4o": "it(\"should recognize a page dictionary with Contents no Type or Kids as a valid page\", async () => {\n  const { PDFDocument } = await import(\"../../src/core/document.js\");\n  const { Dict, Ref } = await import(\"../../src/core/primitives.js\");\n  const { StringStream } = await import(\"../../src/core/stream.js\");\n\n  class MapWithHasPut extends Map {\n    put(key, value) {\n      this.set(key, value);\n    }\n  }\n\n  // Create a page dictionary with \"Contents\" but without \"Type\" or \"Kids\".\n  const pageDict = new Dict();\n  pageDict.set(\"Contents\", \"dummy content\");\n\n  // Prepare a fake reference corresponding to object number 1 and generation 0.\n  const fakeRef = Ref.get(1, 0);\n\n  // Create a fake XRef with a fetchAsync method that returns our pageDict for fakeRef.\n  const xref = {\n    fetchAsync: async function (ref) {\n      if (ref.num === fakeRef.num && ref.gen === fakeRef.gen) {\n        return pageDict;\n      }\n      throw new Error(\"Unexpected reference.\");\n    },\n  };\n\n  // Create a minimal linearization object.\n  const linearization = {\n    pageFirst: 0,\n    objectNumberFirst: 1,\n  };\n\n  // Minimal catalog with required cache methods.\n  const catalog = {\n    pageKidsCountCache: new MapWithHasPut(),\n    pageIndexCache: new MapWithHasPut(),\n    getPageDict: () => {\n      throw new Error(\"getPageDict should not be called in this test\");\n    },\n  };\n\n  // Create a dummy stream.\n  const stream = new StringStream(\"dummy\");\n\n  // Instantiate PDFDocument with a dummy pdfManager.\n  const pdfDoc = new PDFDocument({ docId: 123 }, stream);\n  pdfDoc.linearization = linearization;\n  pdfDoc.catalog = catalog;\n  pdfDoc.xref = xref;\n\n  const [resultDict, resultRef] = await pdfDoc._getLinearizationPage(0);\n  if (resultDict !== pageDict) {\n    throw new Error(\"The page dictionary was not correctly recognized.\");\n  }\n  if (resultRef.num !== fakeRef.num || resultRef.gen !== fakeRef.gen) {\n    throw new Error(\"The page reference returned is incorrect.\");\n  }\n});\n",
    "i3_llama-3.3-70b-versatile": "it(\"should recognize a page dictionary with Contents no Type or Kids as a valid page\", async () => {\n  const { PDFDocument } = await import(\"../../src/core/document.js\");\n  const { Dict, Ref } = await import(\"../../src/core/primitives.js\");\n  const { StringStream } = await import(\"../../src/core/stream.js\");\n\n  class MapWithHasPut extends Map {\n    put(key, value) {\n      this.set(key, value);\n    }\n  }\n\n  // Create a page dictionary with \"Contents\" but without \"Type\" or \"Kids\".\n  const pageDict = new Dict();\n  pageDict.set(\"Contents\", \"dummy content\");\n\n  // Prepare a fake reference corresponding to object number 1 and generation 0.\n  const fakeRef = Ref.get(1, 0);\n\n  // Create a fake XRef with a fetchAsync method that returns our pageDict for fakeRef.\n  const xref = {\n    fetchAsync: async function (ref) {\n      if (ref.num === fakeRef.num && ref.gen === fakeRef.gen) {\n        return pageDict;\n      }\n      throw new Error(\"Unexpected reference.\");\n    },\n  };\n\n  // Create a minimal linearization object.\n  const linearization = {\n    pageFirst: 0,\n    objectNumberFirst: 1,\n  };\n\n  // Minimal catalog with required cache methods.\n  const catalog = {\n    pageKidsCountCache: new MapWithHasPut(),\n    pageIndexCache: new MapWithHasPut(),\n    getPageDict: () => {\n      throw new Error(\"getPageDict should not be called in this test\");\n    },\n  };\n\n  // Create a dummy stream.\n  const stream = new StringStream(\"dummy\");\n\n  // Instantiate PDFDocument with a dummy pdfManager.\n  const pdfDoc = new PDFDocument({ docId: 123 }, stream);\n  pdfDoc.linearization = linearization;\n  pdfDoc.catalog = catalog;\n  pdfDoc.xref = xref;\n\n  const [resultDict, resultRef] = await pdfDoc._getLinearizationPage(0);\n  if (resultDict !== pageDict) {\n    throw new Error(\"The page dictionary was not correctly recognized.\");\n  }\n  if (resultRef.num !== fakeRef.num || resultRef.gen !== fakeRef.gen) {\n    throw new Error(\"The page reference returned is incorrect.\");\n  }\n});\n",
    "i4_deepseek-r1-distill-llama-70b": "it(\"should recognize a page dictionary with Contents no Type or Kids as a valid page\", async () => {\n  const { PDFDocument } = await import(\"../../src/core/document.js\");\n  const { Dict, Ref } = await import(\"../../src/core/primitives.js\");\n  const { StringStream } = await import(\"../../src/core/stream.js\");\n\n  class MapWithHasPut extends Map {\n    put(key, value) {\n      this.set(key, value);\n    }\n  }\n\n  // Create a page dictionary with \"Contents\" but without \"Type\" or \"Kids\".\n  const pageDict = new Dict();\n  pageDict.set(\"Contents\", \"dummy content\");\n\n  // Prepare a fake reference corresponding to object number 1 and generation 0.\n  const fakeRef = Ref.get(1, 0);\n\n  // Create a fake XRef with a fetchAsync method that returns our pageDict for fakeRef.\n  const xref = {\n    fetchAsync: async function (ref) {\n      if (ref.num === fakeRef.num && ref.gen === fakeRef.gen) {\n        return pageDict;\n      }\n      throw new Error(\"Unexpected reference.\");\n    },\n  };\n\n  // Create a minimal linearization object.\n  const linearization = {\n    pageFirst: 0,\n    objectNumberFirst: 1,\n  };\n\n  // Minimal catalog with required cache methods.\n  const catalog = {\n    pageKidsCountCache: new MapWithHasPut(),\n    pageIndexCache: new MapWithHasPut(),\n    getPageDict: () => {\n      throw new Error(\"getPageDict should not be called in this test\");\n    },\n  };\n\n  // Create a dummy stream.\n  const stream = new StringStream(\"dummy\");\n\n  // Instantiate PDFDocument with a dummy pdfManager.\n  const pdfDoc = new PDFDocument({ docId: 123 }, stream);\n  pdfDoc.linearization = linearization;\n  pdfDoc.catalog = catalog;\n  pdfDoc.xref = xref;\n\n  const [resultDict, resultRef] = await pdfDoc._getLinearizationPage(0);\n  if (resultDict !== pageDict) {\n    throw new Error(\"The page dictionary was not correctly recognized.\");\n  }\n  if (resultRef.num !== fakeRef.num || resultRef.gen !== fakeRef.gen) {\n    throw new Error(\"The page reference returned is incorrect.\");\n  }\n});\n",
    "i4_gpt-4o": "it(\"should recognize a page dictionary with Contents no Type or Kids as a valid page\", async () => {\n  const { PDFDocument } = await import(\"../../src/core/document.js\");\n  const { Dict, Ref } = await import(\"../../src/core/primitives.js\");\n  const { StringStream } = await import(\"../../src/core/stream.js\");\n\n  class MapWithHasPut extends Map {\n    put(key, value) {\n      this.set(key, value);\n    }\n  }\n\n  // Create a page dictionary with \"Contents\" but without \"Type\" or \"Kids\".\n  const pageDict = new Dict();\n  pageDict.set(\"Contents\", \"dummy content\");\n\n  // Prepare a fake reference corresponding to object number 1 and generation 0.\n  const fakeRef = Ref.get(1, 0);\n\n  // Create a fake XRef with a fetchAsync method that returns our pageDict for fakeRef.\n  const xref = {\n    fetchAsync: async function (ref) {\n      if (ref.num === fakeRef.num && ref.gen === fakeRef.gen) {\n        return pageDict;\n      }\n      throw new Error(\"Unexpected reference.\");\n    },\n  };\n\n  // Create a minimal linearization object.\n  const linearization = {\n    pageFirst: 0,\n    objectNumberFirst: 1,\n  };\n\n  // Minimal catalog with required cache methods.\n  const catalog = {\n    pageKidsCountCache: new MapWithHasPut(),\n    pageIndexCache: new MapWithHasPut(),\n    getPageDict: () => {\n      throw new Error(\"getPageDict should not be called in this test\");\n    },\n  };\n\n  // Create a dummy stream.\n  const stream = new StringStream(\"dummy\");\n\n  // Instantiate PDFDocument with a dummy pdfManager.\n  const pdfDoc = new PDFDocument({ docId: 123 }, stream);\n  pdfDoc.linearization = linearization;\n  pdfDoc.catalog = catalog;\n  pdfDoc.xref = xref;\n\n  const [resultDict, resultRef] = await pdfDoc._getLinearizationPage(0);\n  if (resultDict !== pageDict) {\n    throw new Error(\"The page dictionary was not correctly recognized.\");\n  }\n  if (resultRef.num !== fakeRef.num || resultRef.gen !== fakeRef.gen) {\n    throw new Error(\"The page reference returned is incorrect.\");\n  }\n});\n",
    "i4_llama-3.3-70b-versatile": "it(\"should recognize a page dictionary with Contents no Type or Kids as a valid page\", async () => {\n  const { PDFDocument } = await import(\"../../src/core/document.js\");\n  const { Dict, Ref } = await import(\"../../src/core/primitives.js\");\n  const { StringStream } = await import(\"../../src/core/stream.js\");\n\n  class MapWithHasPut extends Map {\n    put(key, value) {\n      this.set(key, value);\n    }\n  }\n\n  // Create a page dictionary with \"Contents\" but without \"Type\" or \"Kids\".\n  const pageDict = new Dict();\n  pageDict.set(\"Contents\", \"dummy content\");\n\n  // Prepare a fake reference corresponding to object number 1 and generation 0.\n  const fakeRef = Ref.get(1, 0);\n\n  // Create a fake XRef with a fetchAsync method that returns our pageDict for fakeRef.\n  const xref = {\n    fetchAsync: async function (ref) {\n      if (ref.num === fakeRef.num && ref.gen === fakeRef.gen) {\n        return pageDict;\n      }\n      throw new Error(\"Unexpected reference.\");\n    },\n  };\n\n  // Create a minimal linearization object.\n  const linearization = {\n    pageFirst: 0,\n    objectNumberFirst: 1,\n  };\n\n  // Minimal catalog with required cache methods.\n  const catalog = {\n    pageKidsCountCache: new MapWithHasPut(),\n    pageIndexCache: new MapWithHasPut(),\n    getPageDict: () => {\n      throw new Error(\"getPageDict should not be called in this test\");\n    },\n  };\n\n  // Create a dummy stream.\n  const stream = new StringStream(\"dummy\");\n\n  // Instantiate PDFDocument with a dummy pdfManager.\n  const pdfDoc = new PDFDocument({ docId: 123 }, stream);\n  pdfDoc.linearization = linearization;\n  pdfDoc.catalog = catalog;\n  pdfDoc.xref = xref;\n\n  const [resultDict, resultRef] = await pdfDoc._getLinearizationPage(0);\n  if (resultDict !== pageDict) {\n    throw new Error(\"The page dictionary was not correctly recognized.\");\n  }\n  if (resultRef.num !== fakeRef.num || resultRef.gen !== fakeRef.gen) {\n    throw new Error(\"The page reference returned is incorrect.\");\n  }\n});\n",
    "i5_deepseek-r1-distill-llama-70b": "it(\"should recognize a page dictionary with Contents no Type or Kids as a valid page\", async () => {\n  const { PDFDocument } = await import(\"../../src/core/document.js\");\n  const { Dict, Ref } = await import(\"../../src/core/primitives.js\");\n  const { StringStream } = await import(\"../../src/core/stream.js\");\n\n  class MapWithHasPut extends Map {\n    put(key, value) {\n      this.set(key, value);\n    }\n  }\n\n  // Create a page dictionary with \"Contents\" but without \"Type\" or \"Kids\".\n  const pageDict = new Dict();\n  pageDict.set(\"Contents\", \"dummy content\");\n\n  // Prepare a fake reference corresponding to object number 1 and generation 0.\n  const fakeRef = Ref.get(1, 0);\n\n  // Create a fake XRef with a fetchAsync method that returns our pageDict for fakeRef.\n  const xref = {\n    fetchAsync: async function (ref) {\n      if (ref.num === fakeRef.num && ref.gen === fakeRef.gen) {\n        return pageDict;\n      }\n      throw new Error(\"Unexpected reference.\");\n    },\n  };\n\n  // Create a minimal linearization object.\n  const linearization = {\n    pageFirst: 0,\n    objectNumberFirst: 1,\n  };\n\n  // Minimal catalog with required cache methods.\n  const catalog = {\n    pageKidsCountCache: new MapWithHasPut(),\n    pageIndexCache: new MapWithHasPut(),\n    getPageDict: () => {\n      throw new Error(\"getPageDict should not be called in this test\");\n    },\n  };\n\n  // Create a dummy stream.\n  const stream = new StringStream(\"dummy\");\n\n  // Instantiate PDFDocument with a dummy pdfManager.\n  const pdfDoc = new PDFDocument({ docId: 123 }, stream);\n  pdfDoc.linearization = linearization;\n  pdfDoc.catalog = catalog;\n  pdfDoc.xref = xref;\n\n  const [resultDict, resultRef] = await pdfDoc._getLinearizationPage(0);\n  if (resultDict !== pageDict) {\n    throw new Error(\"The page dictionary was not correctly recognized.\");\n  }\n  if (resultRef.num !== fakeRef.num || resultRef.gen !== fakeRef.gen) {\n    throw new Error(\"The page reference returned is incorrect.\");\n  }\n});\n",
    "i5_gpt-4o": "it(\"should recognize a page dictionary with Contents no Type or Kids as a valid page\", async () => {\n  const { PDFDocument } = await import(\"../../src/core/document.js\");\n  const { Dict, Ref } = await import(\"../../src/core/primitives.js\");\n  const { StringStream } = await import(\"../../src/core/stream.js\");\n\n  class MapWithHasPut extends Map {\n    put(key, value) {\n      this.set(key, value);\n    }\n  }\n\n  // Create a page dictionary with \"Contents\" but without \"Type\" or \"Kids\".\n  const pageDict = new Dict();\n  pageDict.set(\"Contents\", \"dummy content\");\n\n  // Prepare a fake reference corresponding to object number 1 and generation 0.\n  const fakeRef = Ref.get(1, 0);\n\n  // Create a fake XRef with a fetchAsync method that returns our pageDict for fakeRef.\n  const xref = {\n    fetchAsync: async function (ref) {\n      if (ref.num === fakeRef.num && ref.gen === fakeRef.gen) {\n        return pageDict;\n      }\n      throw new Error(\"Unexpected reference.\");\n    },\n  };\n\n  // Create a minimal linearization object.\n  const linearization = {\n    pageFirst: 0,\n    objectNumberFirst: 1,\n  };\n\n  // Minimal catalog with required cache methods.\n  const catalog = {\n    pageKidsCountCache: new MapWithHasPut(),\n    pageIndexCache: new MapWithHasPut(),\n    getPageDict: () => {\n      throw new Error(\"getPageDict should not be called in this test\");\n    },\n  };\n\n  // Create a dummy stream.\n  const stream = new StringStream(\"dummy\");\n\n  // Instantiate PDFDocument with a dummy pdfManager.\n  const pdfDoc = new PDFDocument({ docId: 123 }, stream);\n  pdfDoc.linearization = linearization;\n  pdfDoc.catalog = catalog;\n  pdfDoc.xref = xref;\n\n  const [resultDict, resultRef] = await pdfDoc._getLinearizationPage(0);\n  if (resultDict !== pageDict) {\n    throw new Error(\"The page dictionary was not correctly recognized.\");\n  }\n  if (resultRef.num !== fakeRef.num || resultRef.gen !== fakeRef.gen) {\n    throw new Error(\"The page reference returned is incorrect.\");\n  }\n});\n",
    "i5_llama-3.3-70b-versatile": "it(\"should recognize a page dictionary with Contents no Type or Kids as a valid page\", async () => {\n  const { PDFDocument } = await import(\"../../src/core/document.js\");\n  const { Dict, Ref } = await import(\"../../src/core/primitives.js\");\n  const { StringStream } = await import(\"../../src/core/stream.js\");\n\n  class MapWithHasPut extends Map {\n    put(key, value) {\n      this.set(key, value);\n    }\n  }\n\n  // Create a page dictionary with \"Contents\" but without \"Type\" or \"Kids\".\n  const pageDict = new Dict();\n  pageDict.set(\"Contents\", \"dummy content\");\n\n  // Prepare a fake reference corresponding to object number 1 and generation 0.\n  const fakeRef = Ref.get(1, 0);\n\n  // Create a fake XRef with a fetchAsync method that returns our pageDict for fakeRef.\n  const xref = {\n    fetchAsync: async function (ref) {\n      if (ref.num === fakeRef.num && ref.gen === fakeRef.gen) {\n        return pageDict;\n      }\n      throw new Error(\"Unexpected reference.\");\n    },\n  };\n\n  // Create a minimal linearization object.\n  const linearization = {\n    pageFirst: 0,\n    objectNumberFirst: 1,\n  };\n\n  // Minimal catalog with required cache methods.\n  const catalog = {\n    pageKidsCountCache: new MapWithHasPut(),\n    pageIndexCache: new MapWithHasPut(),\n    getPageDict: () => {\n      throw new Error(\"getPageDict should not be called in this test\");\n    },\n  };\n\n  // Create a dummy stream.\n  const stream = new StringStream(\"dummy\");\n\n  // Instantiate PDFDocument with a dummy pdfManager.\n  const pdfDoc = new PDFDocument({ docId: 123 }, stream);\n  pdfDoc.linearization = linearization;\n  pdfDoc.catalog = catalog;\n  pdfDoc.xref = xref;\n\n  const [resultDict, resultRef] = await pdfDoc._getLinearizationPage(0);\n  if (resultDict !== pageDict) {\n    throw new Error(\"The page dictionary was not correctly recognized.\");\n  }\n  if (resultRef.num !== fakeRef.num || resultRef.gen !== fakeRef.gen) {\n    throw new Error(\"The page reference returned is incorrect.\");\n  }\n});\n"
  },
  "18166": {
    "i1_deepseek-r1-distill-llama-70b": "it(\"should gracefully recover when xreffetchIfRef throws\", async () => {\n  const { Ref } = await import(\"../../src/core/primitives.js\");\n  const { PartialEvaluator } = await import(\"../../src/core/evaluator.js\");\n  const { createIdFactory } = await import(\"./test_utils.js\");\n\n  const fakeXRef = {\n    fetchIfRef: () => {\n      throw new Error(\"Test error\");\n    },\n  };\n\n  const fontCache = {\n    _cache: new Map(),\n    has(key) {\n      return this._cache.has(key);\n    },\n    get(key) {\n      return this._cache.get(key);\n    },\n    put(key, value) {\n      this._cache.set(key, value);\n    },\n    putAlias(key, alias) {\n      this._cache.set(key, this._cache.get(alias));\n    },\n  };\n\n  const evaluator = new PartialEvaluator({\n    xref: fakeXRef,\n    handler: {},\n    pageIndex: 0,\n    idFactory: createIdFactory(),\n    fontCache,\n    builtInCMapCache: {},\n    standardFontDataCache: {},\n    globalImageCache: {},\n    systemFontCache: {},\n    options: { ignoreErrors: false },\n  });\n\n  const fakeFontRef = new Ref(0, 0);\n  const resources = {\n    get(key) {\n      if (key === \"Font\") {\n        return {\n          getRaw: (name) => fakeFontRef,\n        };\n      }\n    },\n  };\n\n  const result = await evaluator.loadFont(\"testFont\", null, resources);\n  if (result.loadedName !== \"g_font_error\") {\n    throw new Error(\"Expected fallback font loadedName to be 'g_font_error'\");\n  }\n  if (\n    !result.font ||\n    typeof result.font.message !== \"string\" ||\n    result.font.message !== 'Font \"testFont\" is not available.'\n  ) {\n    throw new Error(\"Expected error font with correct message\");\n  }\n});\n",
    "i1_gpt-4o": "it(\"should gracefully recover when xreffetchIfRef throws\", async () => {\n  const { Ref } = await import(\"../../src/core/primitives.js\");\n  const { PartialEvaluator } = await import(\"../../src/core/evaluator.js\");\n  const { createIdFactory } = await import(\"./test_utils.js\");\n\n  const fakeXRef = {\n    fetchIfRef: () => {\n      throw new Error(\"Test error\");\n    },\n  };\n\n  const fontCache = {\n    _cache: new Map(),\n    has(key) {\n      return this._cache.has(key);\n    },\n    get(key) {\n      return this._cache.get(key);\n    },\n    put(key, value) {\n      this._cache.set(key, value);\n    },\n    putAlias(key, alias) {\n      this._cache.set(key, this._cache.get(alias));\n    },\n  };\n\n  const evaluator = new PartialEvaluator({\n    xref: fakeXRef,\n    handler: {},\n    pageIndex: 0,\n    idFactory: createIdFactory(),\n    fontCache,\n    builtInCMapCache: {},\n    standardFontDataCache: {},\n    globalImageCache: {},\n    systemFontCache: {},\n    options: { ignoreErrors: false },\n  });\n\n  const fakeFontRef = new Ref(0, 0);\n  const resources = {\n    get(key) {\n      if (key === \"Font\") {\n        return {\n          getRaw: (name) => fakeFontRef,\n        };\n      }\n    },\n  };\n\n  const result = await evaluator.loadFont(\"testFont\", null, resources);\n  if (result.loadedName !== \"g_font_error\") {\n    throw new Error(\"Expected fallback font loadedName to be 'g_font_error'\");\n  }\n  if (\n    !result.font ||\n    typeof result.font.message !== \"string\" ||\n    result.font.message !== 'Font \"testFont\" is not available.'\n  ) {\n    throw new Error(\"Expected error font with correct message\");\n  }\n});\n",
    "i1_llama-3.3-70b-versatile": "it(\"should gracefully recover when xreffetchIfRef throws\", async () => {\n  const { Ref } = await import(\"../../src/core/primitives.js\");\n  const { PartialEvaluator } = await import(\"../../src/core/evaluator.js\");\n  const { createIdFactory } = await import(\"./test_utils.js\");\n\n  const fakeXRef = {\n    fetchIfRef: () => {\n      throw new Error(\"Test error\");\n    },\n  };\n\n  const fontCache = {\n    _cache: new Map(),\n    has(key) {\n      return this._cache.has(key);\n    },\n    get(key) {\n      return this._cache.get(key);\n    },\n    put(key, value) {\n      this._cache.set(key, value);\n    },\n    putAlias(key, alias) {\n      this._cache.set(key, this._cache.get(alias));\n    },\n  };\n\n  const evaluator = new PartialEvaluator({\n    xref: fakeXRef,\n    handler: {},\n    pageIndex: 0,\n    idFactory: createIdFactory(),\n    fontCache,\n    builtInCMapCache: {},\n    standardFontDataCache: {},\n    globalImageCache: {},\n    systemFontCache: {},\n    options: { ignoreErrors: false },\n  });\n\n  const fakeFontRef = new Ref(0, 0);\n  const resources = {\n    get(key) {\n      if (key === \"Font\") {\n        return {\n          getRaw: (name) => fakeFontRef,\n        };\n      }\n    },\n  };\n\n  const result = await evaluator.loadFont(\"testFont\", null, resources);\n  if (result.loadedName !== \"g_font_error\") {\n    throw new Error(\"Expected fallback font loadedName to be 'g_font_error'\");\n  }\n  if (\n    !result.font ||\n    typeof result.font.message !== \"string\" ||\n    result.font.message !== 'Font \"testFont\" is not available.'\n  ) {\n    throw new Error(\"Expected error font with correct message\");\n  }\n});\n",
    "i1_MOCK": "it(\"should gracefully recover when xreffetchIfRef throws\", async () => {\n  const { Ref } = await import(\"../../src/core/primitives.js\");\n  const { PartialEvaluator } = await import(\"../../src/core/evaluator.js\");\n  const { createIdFactory } = await import(\"./test_utils.js\");\n\n  const fakeXRef = {\n    fetchIfRef: () => {\n      throw new Error(\"Test error\");\n    },\n  };\n\n  const fontCache = {\n    _cache: new Map(),\n    has(key) {\n      return this._cache.has(key);\n    },\n    get(key) {\n      return this._cache.get(key);\n    },\n    put(key, value) {\n      this._cache.set(key, value);\n    },\n    putAlias(key, alias) {\n      this._cache.set(key, this._cache.get(alias));\n    },\n  };\n\n  const evaluator = new PartialEvaluator({\n    xref: fakeXRef,\n    handler: {},\n    pageIndex: 0,\n    idFactory: createIdFactory(),\n    fontCache,\n    builtInCMapCache: {},\n    standardFontDataCache: {},\n    globalImageCache: {},\n    systemFontCache: {},\n    options: { ignoreErrors: false },\n  });\n\n  const fakeFontRef = new Ref(0, 0);\n  const resources = {\n    get(key) {\n      if (key === \"Font\") {\n        return {\n          getRaw: (name) => fakeFontRef,\n        };\n      }\n    },\n  };\n\n  const result = await evaluator.loadFont(\"testFont\", null, resources);\n  if (result.loadedName !== \"g_font_error\") {\n    throw new Error(\"Expected fallback font loadedName to be 'g_font_error'\");\n  }\n  if (\n    !result.font ||\n    typeof result.font.message !== \"string\" ||\n    result.font.message !== 'Font \"testFont\" is not available.'\n  ) {\n    throw new Error(\"Expected error font with correct message\");\n  }\n});\n",
    "i2_deepseek-r1-distill-llama-70b": "it(\"should gracefully recover when xreffetchIfRef throws\", async () => {\n  const { Ref } = await import(\"../../src/core/primitives.js\");\n  const { PartialEvaluator } = await import(\"../../src/core/evaluator.js\");\n  const { createIdFactory } = await import(\"./test_utils.js\");\n\n  const fakeXRef = {\n    fetchIfRef: () => {\n      throw new Error(\"Test error\");\n    },\n  };\n\n  const fontCache = {\n    _cache: new Map(),\n    has(key) {\n      return this._cache.has(key);\n    },\n    get(key) {\n      return this._cache.get(key);\n    },\n    put(key, value) {\n      this._cache.set(key, value);\n    },\n    putAlias(key, alias) {\n      this._cache.set(key, this._cache.get(alias));\n    },\n  };\n\n  const evaluator = new PartialEvaluator({\n    xref: fakeXRef,\n    handler: {},\n    pageIndex: 0,\n    idFactory: createIdFactory(),\n    fontCache,\n    builtInCMapCache: {},\n    standardFontDataCache: {},\n    globalImageCache: {},\n    systemFontCache: {},\n    options: { ignoreErrors: false },\n  });\n\n  const fakeFontRef = new Ref(0, 0);\n  const resources = {\n    get(key) {\n      if (key === \"Font\") {\n        return {\n          getRaw: (name) => fakeFontRef,\n        };\n      }\n    },\n  };\n\n  const result = await evaluator.loadFont(\"testFont\", null, resources);\n  if (result.loadedName !== \"g_font_error\") {\n    throw new Error(\"Expected fallback font loadedName to be 'g_font_error'\");\n  }\n  if (\n    !result.font ||\n    typeof result.font.message !== \"string\" ||\n    result.font.message !== 'Font \"testFont\" is not available.'\n  ) {\n    throw new Error(\"Expected error font with correct message\");\n  }\n});\n",
    "i2_gpt-4o": "it(\"should gracefully recover when xreffetchIfRef throws\", async () => {\n  const { Ref } = await import(\"../../src/core/primitives.js\");\n  const { PartialEvaluator } = await import(\"../../src/core/evaluator.js\");\n  const { createIdFactory } = await import(\"./test_utils.js\");\n\n  const fakeXRef = {\n    fetchIfRef: () => {\n      throw new Error(\"Test error\");\n    },\n  };\n\n  const fontCache = {\n    _cache: new Map(),\n    has(key) {\n      return this._cache.has(key);\n    },\n    get(key) {\n      return this._cache.get(key);\n    },\n    put(key, value) {\n      this._cache.set(key, value);\n    },\n    putAlias(key, alias) {\n      this._cache.set(key, this._cache.get(alias));\n    },\n  };\n\n  const evaluator = new PartialEvaluator({\n    xref: fakeXRef,\n    handler: {},\n    pageIndex: 0,\n    idFactory: createIdFactory(),\n    fontCache,\n    builtInCMapCache: {},\n    standardFontDataCache: {},\n    globalImageCache: {},\n    systemFontCache: {},\n    options: { ignoreErrors: false },\n  });\n\n  const fakeFontRef = new Ref(0, 0);\n  const resources = {\n    get(key) {\n      if (key === \"Font\") {\n        return {\n          getRaw: (name) => fakeFontRef,\n        };\n      }\n    },\n  };\n\n  const result = await evaluator.loadFont(\"testFont\", null, resources);\n  if (result.loadedName !== \"g_font_error\") {\n    throw new Error(\"Expected fallback font loadedName to be 'g_font_error'\");\n  }\n  if (\n    !result.font ||\n    typeof result.font.message !== \"string\" ||\n    result.font.message !== 'Font \"testFont\" is not available.'\n  ) {\n    throw new Error(\"Expected error font with correct message\");\n  }\n});\n",
    "i2_llama-3.3-70b-versatile": "it(\"should gracefully recover when xreffetchIfRef throws\", async () => {\n  const { Ref } = await import(\"../../src/core/primitives.js\");\n  const { PartialEvaluator } = await import(\"../../src/core/evaluator.js\");\n  const { createIdFactory } = await import(\"./test_utils.js\");\n\n  const fakeXRef = {\n    fetchIfRef: () => {\n      throw new Error(\"Test error\");\n    },\n  };\n\n  const fontCache = {\n    _cache: new Map(),\n    has(key) {\n      return this._cache.has(key);\n    },\n    get(key) {\n      return this._cache.get(key);\n    },\n    put(key, value) {\n      this._cache.set(key, value);\n    },\n    putAlias(key, alias) {\n      this._cache.set(key, this._cache.get(alias));\n    },\n  };\n\n  const evaluator = new PartialEvaluator({\n    xref: fakeXRef,\n    handler: {},\n    pageIndex: 0,\n    idFactory: createIdFactory(),\n    fontCache,\n    builtInCMapCache: {},\n    standardFontDataCache: {},\n    globalImageCache: {},\n    systemFontCache: {},\n    options: { ignoreErrors: false },\n  });\n\n  const fakeFontRef = new Ref(0, 0);\n  const resources = {\n    get(key) {\n      if (key === \"Font\") {\n        return {\n          getRaw: (name) => fakeFontRef,\n        };\n      }\n    },\n  };\n\n  const result = await evaluator.loadFont(\"testFont\", null, resources);\n  if (result.loadedName !== \"g_font_error\") {\n    throw new Error(\"Expected fallback font loadedName to be 'g_font_error'\");\n  }\n  if (\n    !result.font ||\n    typeof result.font.message !== \"string\" ||\n    result.font.message !== 'Font \"testFont\" is not available.'\n  ) {\n    throw new Error(\"Expected error font with correct message\");\n  }\n});\n",
    "i3_deepseek-r1-distill-llama-70b": "it(\"should gracefully recover when xreffetchIfRef throws\", async () => {\n  const { Ref } = await import(\"../../src/core/primitives.js\");\n  const { PartialEvaluator } = await import(\"../../src/core/evaluator.js\");\n  const { createIdFactory } = await import(\"./test_utils.js\");\n\n  const fakeXRef = {\n    fetchIfRef: () => {\n      throw new Error(\"Test error\");\n    },\n  };\n\n  const fontCache = {\n    _cache: new Map(),\n    has(key) {\n      return this._cache.has(key);\n    },\n    get(key) {\n      return this._cache.get(key);\n    },\n    put(key, value) {\n      this._cache.set(key, value);\n    },\n    putAlias(key, alias) {\n      this._cache.set(key, this._cache.get(alias));\n    },\n  };\n\n  const evaluator = new PartialEvaluator({\n    xref: fakeXRef,\n    handler: {},\n    pageIndex: 0,\n    idFactory: createIdFactory(),\n    fontCache,\n    builtInCMapCache: {},\n    standardFontDataCache: {},\n    globalImageCache: {},\n    systemFontCache: {},\n    options: { ignoreErrors: false },\n  });\n\n  const fakeFontRef = new Ref(0, 0);\n  const resources = {\n    get(key) {\n      if (key === \"Font\") {\n        return {\n          getRaw: (name) => fakeFontRef,\n        };\n      }\n    },\n  };\n\n  const result = await evaluator.loadFont(\"testFont\", null, resources);\n  if (result.loadedName !== \"g_font_error\") {\n    throw new Error(\"Expected fallback font loadedName to be 'g_font_error'\");\n  }\n  if (\n    !result.font ||\n    typeof result.font.message !== \"string\" ||\n    result.font.message !== 'Font \"testFont\" is not available.'\n  ) {\n    throw new Error(\"Expected error font with correct message\");\n  }\n});\n",
    "i3_gpt-4o": "it(\"should gracefully recover when xreffetchIfRef throws\", async () => {\n  const { Ref } = await import(\"../../src/core/primitives.js\");\n  const { PartialEvaluator } = await import(\"../../src/core/evaluator.js\");\n  const { createIdFactory } = await import(\"./test_utils.js\");\n\n  const fakeXRef = {\n    fetchIfRef: () => {\n      throw new Error(\"Test error\");\n    },\n  };\n\n  const fontCache = {\n    _cache: new Map(),\n    has(key) {\n      return this._cache.has(key);\n    },\n    get(key) {\n      return this._cache.get(key);\n    },\n    put(key, value) {\n      this._cache.set(key, value);\n    },\n    putAlias(key, alias) {\n      this._cache.set(key, this._cache.get(alias));\n    },\n  };\n\n  const evaluator = new PartialEvaluator({\n    xref: fakeXRef,\n    handler: {},\n    pageIndex: 0,\n    idFactory: createIdFactory(),\n    fontCache,\n    builtInCMapCache: {},\n    standardFontDataCache: {},\n    globalImageCache: {},\n    systemFontCache: {},\n    options: { ignoreErrors: false },\n  });\n\n  const fakeFontRef = new Ref(0, 0);\n  const resources = {\n    get(key) {\n      if (key === \"Font\") {\n        return {\n          getRaw: (name) => fakeFontRef,\n        };\n      }\n    },\n  };\n\n  const result = await evaluator.loadFont(\"testFont\", null, resources);\n  if (result.loadedName !== \"g_font_error\") {\n    throw new Error(\"Expected fallback font loadedName to be 'g_font_error'\");\n  }\n  if (\n    !result.font ||\n    typeof result.font.message !== \"string\" ||\n    result.font.message !== 'Font \"testFont\" is not available.'\n  ) {\n    throw new Error(\"Expected error font with correct message\");\n  }\n});\n",
    "i3_llama-3.3-70b-versatile": "it(\"should gracefully recover when xreffetchIfRef throws\", async () => {\n  const { Ref } = await import(\"../../src/core/primitives.js\");\n  const { PartialEvaluator } = await import(\"../../src/core/evaluator.js\");\n  const { createIdFactory } = await import(\"./test_utils.js\");\n\n  const fakeXRef = {\n    fetchIfRef: () => {\n      throw new Error(\"Test error\");\n    },\n  };\n\n  const fontCache = {\n    _cache: new Map(),\n    has(key) {\n      return this._cache.has(key);\n    },\n    get(key) {\n      return this._cache.get(key);\n    },\n    put(key, value) {\n      this._cache.set(key, value);\n    },\n    putAlias(key, alias) {\n      this._cache.set(key, this._cache.get(alias));\n    },\n  };\n\n  const evaluator = new PartialEvaluator({\n    xref: fakeXRef,\n    handler: {},\n    pageIndex: 0,\n    idFactory: createIdFactory(),\n    fontCache,\n    builtInCMapCache: {},\n    standardFontDataCache: {},\n    globalImageCache: {},\n    systemFontCache: {},\n    options: { ignoreErrors: false },\n  });\n\n  const fakeFontRef = new Ref(0, 0);\n  const resources = {\n    get(key) {\n      if (key === \"Font\") {\n        return {\n          getRaw: (name) => fakeFontRef,\n        };\n      }\n    },\n  };\n\n  const result = await evaluator.loadFont(\"testFont\", null, resources);\n  if (result.loadedName !== \"g_font_error\") {\n    throw new Error(\"Expected fallback font loadedName to be 'g_font_error'\");\n  }\n  if (\n    !result.font ||\n    typeof result.font.message !== \"string\" ||\n    result.font.message !== 'Font \"testFont\" is not available.'\n  ) {\n    throw new Error(\"Expected error font with correct message\");\n  }\n});\n",
    "i4_deepseek-r1-distill-llama-70b": "it(\"should gracefully recover when xreffetchIfRef throws\", async () => {\n  const { Ref } = await import(\"../../src/core/primitives.js\");\n  const { PartialEvaluator } = await import(\"../../src/core/evaluator.js\");\n  const { createIdFactory } = await import(\"./test_utils.js\");\n\n  const fakeXRef = {\n    fetchIfRef: () => {\n      throw new Error(\"Test error\");\n    },\n  };\n\n  const fontCache = {\n    _cache: new Map(),\n    has(key) {\n      return this._cache.has(key);\n    },\n    get(key) {\n      return this._cache.get(key);\n    },\n    put(key, value) {\n      this._cache.set(key, value);\n    },\n    putAlias(key, alias) {\n      this._cache.set(key, this._cache.get(alias));\n    },\n  };\n\n  const evaluator = new PartialEvaluator({\n    xref: fakeXRef,\n    handler: {},\n    pageIndex: 0,\n    idFactory: createIdFactory(),\n    fontCache,\n    builtInCMapCache: {},\n    standardFontDataCache: {},\n    globalImageCache: {},\n    systemFontCache: {},\n    options: { ignoreErrors: false },\n  });\n\n  const fakeFontRef = new Ref(0, 0);\n  const resources = {\n    get(key) {\n      if (key === \"Font\") {\n        return {\n          getRaw: (name) => fakeFontRef,\n        };\n      }\n    },\n  };\n\n  const result = await evaluator.loadFont(\"testFont\", null, resources);\n  if (result.loadedName !== \"g_font_error\") {\n    throw new Error(\"Expected fallback font loadedName to be 'g_font_error'\");\n  }\n  if (\n    !result.font ||\n    typeof result.font.message !== \"string\" ||\n    result.font.message !== 'Font \"testFont\" is not available.'\n  ) {\n    throw new Error(\"Expected error font with correct message\");\n  }\n});\n",
    "i4_gpt-4o": "it(\"should gracefully recover when xreffetchIfRef throws\", async () => {\n  const { Ref } = await import(\"../../src/core/primitives.js\");\n  const { PartialEvaluator } = await import(\"../../src/core/evaluator.js\");\n  const { createIdFactory } = await import(\"./test_utils.js\");\n\n  const fakeXRef = {\n    fetchIfRef: () => {\n      throw new Error(\"Test error\");\n    },\n  };\n\n  const fontCache = {\n    _cache: new Map(),\n    has(key) {\n      return this._cache.has(key);\n    },\n    get(key) {\n      return this._cache.get(key);\n    },\n    put(key, value) {\n      this._cache.set(key, value);\n    },\n    putAlias(key, alias) {\n      this._cache.set(key, this._cache.get(alias));\n    },\n  };\n\n  const evaluator = new PartialEvaluator({\n    xref: fakeXRef,\n    handler: {},\n    pageIndex: 0,\n    idFactory: createIdFactory(),\n    fontCache,\n    builtInCMapCache: {},\n    standardFontDataCache: {},\n    globalImageCache: {},\n    systemFontCache: {},\n    options: { ignoreErrors: false },\n  });\n\n  const fakeFontRef = new Ref(0, 0);\n  const resources = {\n    get(key) {\n      if (key === \"Font\") {\n        return {\n          getRaw: (name) => fakeFontRef,\n        };\n      }\n    },\n  };\n\n  const result = await evaluator.loadFont(\"testFont\", null, resources);\n  if (result.loadedName !== \"g_font_error\") {\n    throw new Error(\"Expected fallback font loadedName to be 'g_font_error'\");\n  }\n  if (\n    !result.font ||\n    typeof result.font.message !== \"string\" ||\n    result.font.message !== 'Font \"testFont\" is not available.'\n  ) {\n    throw new Error(\"Expected error font with correct message\");\n  }\n});\n",
    "i4_llama-3.3-70b-versatile": "it(\"should gracefully recover when xreffetchIfRef throws\", async () => {\n  const { Ref } = await import(\"../../src/core/primitives.js\");\n  const { PartialEvaluator } = await import(\"../../src/core/evaluator.js\");\n  const { createIdFactory } = await import(\"./test_utils.js\");\n\n  const fakeXRef = {\n    fetchIfRef: () => {\n      throw new Error(\"Test error\");\n    },\n  };\n\n  const fontCache = {\n    _cache: new Map(),\n    has(key) {\n      return this._cache.has(key);\n    },\n    get(key) {\n      return this._cache.get(key);\n    },\n    put(key, value) {\n      this._cache.set(key, value);\n    },\n    putAlias(key, alias) {\n      this._cache.set(key, this._cache.get(alias));\n    },\n  };\n\n  const evaluator = new PartialEvaluator({\n    xref: fakeXRef,\n    handler: {},\n    pageIndex: 0,\n    idFactory: createIdFactory(),\n    fontCache,\n    builtInCMapCache: {},\n    standardFontDataCache: {},\n    globalImageCache: {},\n    systemFontCache: {},\n    options: { ignoreErrors: false },\n  });\n\n  const fakeFontRef = new Ref(0, 0);\n  const resources = {\n    get(key) {\n      if (key === \"Font\") {\n        return {\n          getRaw: (name) => fakeFontRef,\n        };\n      }\n    },\n  };\n\n  const result = await evaluator.loadFont(\"testFont\", null, resources);\n  if (result.loadedName !== \"g_font_error\") {\n    throw new Error(\"Expected fallback font loadedName to be 'g_font_error'\");\n  }\n  if (\n    !result.font ||\n    typeof result.font.message !== \"string\" ||\n    result.font.message !== 'Font \"testFont\" is not available.'\n  ) {\n    throw new Error(\"Expected error font with correct message\");\n  }\n});\n",
    "i5_deepseek-r1-distill-llama-70b": "it(\"should gracefully recover when xreffetchIfRef throws\", async () => {\n  const { Ref } = await import(\"../../src/core/primitives.js\");\n  const { PartialEvaluator } = await import(\"../../src/core/evaluator.js\");\n  const { createIdFactory } = await import(\"./test_utils.js\");\n\n  const fakeXRef = {\n    fetchIfRef: () => {\n      throw new Error(\"Test error\");\n    },\n  };\n\n  const fontCache = {\n    _cache: new Map(),\n    has(key) {\n      return this._cache.has(key);\n    },\n    get(key) {\n      return this._cache.get(key);\n    },\n    put(key, value) {\n      this._cache.set(key, value);\n    },\n    putAlias(key, alias) {\n      this._cache.set(key, this._cache.get(alias));\n    },\n  };\n\n  const evaluator = new PartialEvaluator({\n    xref: fakeXRef,\n    handler: {},\n    pageIndex: 0,\n    idFactory: createIdFactory(),\n    fontCache,\n    builtInCMapCache: {},\n    standardFontDataCache: {},\n    globalImageCache: {},\n    systemFontCache: {},\n    options: { ignoreErrors: false },\n  });\n\n  const fakeFontRef = new Ref(0, 0);\n  const resources = {\n    get(key) {\n      if (key === \"Font\") {\n        return {\n          getRaw: (name) => fakeFontRef,\n        };\n      }\n    },\n  };\n\n  const result = await evaluator.loadFont(\"testFont\", null, resources);\n  if (result.loadedName !== \"g_font_error\") {\n    throw new Error(\"Expected fallback font loadedName to be 'g_font_error'\");\n  }\n  if (\n    !result.font ||\n    typeof result.font.message !== \"string\" ||\n    result.font.message !== 'Font \"testFont\" is not available.'\n  ) {\n    throw new Error(\"Expected error font with correct message\");\n  }\n});\n",
    "i5_gpt-4o": "it(\"should gracefully recover when xreffetchIfRef throws\", async () => {\n  const { Ref } = await import(\"../../src/core/primitives.js\");\n  const { PartialEvaluator } = await import(\"../../src/core/evaluator.js\");\n  const { createIdFactory } = await import(\"./test_utils.js\");\n\n  const fakeXRef = {\n    fetchIfRef: () => {\n      throw new Error(\"Test error\");\n    },\n  };\n\n  const fontCache = {\n    _cache: new Map(),\n    has(key) {\n      return this._cache.has(key);\n    },\n    get(key) {\n      return this._cache.get(key);\n    },\n    put(key, value) {\n      this._cache.set(key, value);\n    },\n    putAlias(key, alias) {\n      this._cache.set(key, this._cache.get(alias));\n    },\n  };\n\n  const evaluator = new PartialEvaluator({\n    xref: fakeXRef,\n    handler: {},\n    pageIndex: 0,\n    idFactory: createIdFactory(),\n    fontCache,\n    builtInCMapCache: {},\n    standardFontDataCache: {},\n    globalImageCache: {},\n    systemFontCache: {},\n    options: { ignoreErrors: false },\n  });\n\n  const fakeFontRef = new Ref(0, 0);\n  const resources = {\n    get(key) {\n      if (key === \"Font\") {\n        return {\n          getRaw: (name) => fakeFontRef,\n        };\n      }\n    },\n  };\n\n  const result = await evaluator.loadFont(\"testFont\", null, resources);\n  if (result.loadedName !== \"g_font_error\") {\n    throw new Error(\"Expected fallback font loadedName to be 'g_font_error'\");\n  }\n  if (\n    !result.font ||\n    typeof result.font.message !== \"string\" ||\n    result.font.message !== 'Font \"testFont\" is not available.'\n  ) {\n    throw new Error(\"Expected error font with correct message\");\n  }\n});\n",
    "i5_llama-3.3-70b-versatile": "it(\"should gracefully recover when xreffetchIfRef throws\", async () => {\n  const { Ref } = await import(\"../../src/core/primitives.js\");\n  const { PartialEvaluator } = await import(\"../../src/core/evaluator.js\");\n  const { createIdFactory } = await import(\"./test_utils.js\");\n\n  const fakeXRef = {\n    fetchIfRef: () => {\n      throw new Error(\"Test error\");\n    },\n  };\n\n  const fontCache = {\n    _cache: new Map(),\n    has(key) {\n      return this._cache.has(key);\n    },\n    get(key) {\n      return this._cache.get(key);\n    },\n    put(key, value) {\n      this._cache.set(key, value);\n    },\n    putAlias(key, alias) {\n      this._cache.set(key, this._cache.get(alias));\n    },\n  };\n\n  const evaluator = new PartialEvaluator({\n    xref: fakeXRef,\n    handler: {},\n    pageIndex: 0,\n    idFactory: createIdFactory(),\n    fontCache,\n    builtInCMapCache: {},\n    standardFontDataCache: {},\n    globalImageCache: {},\n    systemFontCache: {},\n    options: { ignoreErrors: false },\n  });\n\n  const fakeFontRef = new Ref(0, 0);\n  const resources = {\n    get(key) {\n      if (key === \"Font\") {\n        return {\n          getRaw: (name) => fakeFontRef,\n        };\n      }\n    },\n  };\n\n  const result = await evaluator.loadFont(\"testFont\", null, resources);\n  if (result.loadedName !== \"g_font_error\") {\n    throw new Error(\"Expected fallback font loadedName to be 'g_font_error'\");\n  }\n  if (\n    !result.font ||\n    typeof result.font.message !== \"string\" ||\n    result.font.message !== 'Font \"testFont\" is not available.'\n  ) {\n    throw new Error(\"Expected error font with correct message\");\n  }\n});\n"
  },
  "18228": {
    "i1_deepseek-r1-distill-llama-70b": "it(\"should hide barcode annotations when PMD is present\", () => {\n  const dummyDict = {\n    has: key => key === \"PMD\",\n    get: () => undefined,\n  };\n  const params = {\n    subtype: \"Widget\",\n    fieldType: \"Tx\",\n    dict: dummyDict,\n    data: {\n      readOnly: true,\n      noHTML: false,\n      fieldValue: \"Test\",\n    },\n  };\n  const annotation = AnnotationFactory.createAnnotation(params);\n  if (!(annotation.flags & AnnotationFlag.HIDDEN)) {\n    throw new Error(\"Expected annotation to have the HIDDEN flag set when PMD is present\");\n  }\n  if (annotation.data.hidden !== true) {\n    throw new Error(\"Expected annotation.data.hidden to be true when PMD is present\");\n  }\n});",
    "i1_gpt-4o": "it(\"should hide barcode annotations when PMD is present\", () => {\n  const dummyDict = {\n    has: key => key === \"PMD\",\n    get: () => undefined,\n  };\n  const params = {\n    subtype: \"Widget\",\n    fieldType: \"Tx\",\n    dict: dummyDict,\n    data: {\n      readOnly: true,\n      noHTML: false,\n      fieldValue: \"Test\",\n    },\n  };\n  const annotation = AnnotationFactory.createAnnotation(params);\n  if (!(annotation.flags & AnnotationFlag.HIDDEN)) {\n    throw new Error(\"Expected annotation to have the HIDDEN flag set when PMD is present\");\n  }\n  if (annotation.data.hidden !== true) {\n    throw new Error(\"Expected annotation.data.hidden to be true when PMD is present\");\n  }\n});",
    "i1_llama-3.3-70b-versatile": "it(\"should hide barcode annotations when PMD is present\", () => {\n  const dummyDict = {\n    has: key => key === \"PMD\",\n    get: () => undefined,\n  };\n  const params = {\n    subtype: \"Widget\",\n    fieldType: \"Tx\",\n    dict: dummyDict,\n    data: {\n      readOnly: true,\n      noHTML: false,\n      fieldValue: \"Test\",\n    },\n  };\n  const annotation = AnnotationFactory.createAnnotation(params);\n  if (!(annotation.flags & AnnotationFlag.HIDDEN)) {\n    throw new Error(\"Expected annotation to have the HIDDEN flag set when PMD is present\");\n  }\n  if (annotation.data.hidden !== true) {\n    throw new Error(\"Expected annotation.data.hidden to be true when PMD is present\");\n  }\n});",
    "i1_MOCK": "it(\"should hide barcode annotations when PMD is present\", () => {\n  const dummyDict = {\n    has: key => key === \"PMD\",\n    get: () => undefined,\n  };\n  const params = {\n    subtype: \"Widget\",\n    fieldType: \"Tx\",\n    dict: dummyDict,\n    data: {\n      readOnly: true,\n      noHTML: false,\n      fieldValue: \"Test\",\n    },\n  };\n  const annotation = AnnotationFactory.createAnnotation(params);\n  if (!(annotation.flags & AnnotationFlag.HIDDEN)) {\n    throw new Error(\"Expected annotation to have the HIDDEN flag set when PMD is present\");\n  }\n  if (annotation.data.hidden !== true) {\n    throw new Error(\"Expected annotation.data.hidden to be true when PMD is present\");\n  }\n});",
    "i2_deepseek-r1-distill-llama-70b": "it(\"should hide barcode annotations when PMD is present\", () => {\n  const dummyDict = {\n    has: key => key === \"PMD\",\n    get: () => undefined,\n  };\n  const params = {\n    subtype: \"Widget\",\n    fieldType: \"Tx\",\n    dict: dummyDict,\n    data: {\n      readOnly: true,\n      noHTML: false,\n      fieldValue: \"Test\",\n    },\n  };\n  const annotation = AnnotationFactory.createAnnotation(params);\n  if (!(annotation.flags & AnnotationFlag.HIDDEN)) {\n    throw new Error(\"Expected annotation to have the HIDDEN flag set when PMD is present\");\n  }\n  if (annotation.data.hidden !== true) {\n    throw new Error(\"Expected annotation.data.hidden to be true when PMD is present\");\n  }\n});",
    "i2_gpt-4o": "it(\"should hide barcode annotations when PMD is present\", () => {\n  const dummyDict = {\n    has: key => key === \"PMD\",\n    get: () => undefined,\n  };\n  const params = {\n    subtype: \"Widget\",\n    fieldType: \"Tx\",\n    dict: dummyDict,\n    data: {\n      readOnly: true,\n      noHTML: false,\n      fieldValue: \"Test\",\n    },\n  };\n  const annotation = AnnotationFactory.createAnnotation(params);\n  if (!(annotation.flags & AnnotationFlag.HIDDEN)) {\n    throw new Error(\"Expected annotation to have the HIDDEN flag set when PMD is present\");\n  }\n  if (annotation.data.hidden !== true) {\n    throw new Error(\"Expected annotation.data.hidden to be true when PMD is present\");\n  }\n});",
    "i2_llama-3.3-70b-versatile": "it(\"should hide barcode annotations when PMD is present\", () => {\n  const dummyDict = {\n    has: key => key === \"PMD\",\n    get: () => undefined,\n  };\n  const params = {\n    subtype: \"Widget\",\n    fieldType: \"Tx\",\n    dict: dummyDict,\n    data: {\n      readOnly: true,\n      noHTML: false,\n      fieldValue: \"Test\",\n    },\n  };\n  const annotation = AnnotationFactory.createAnnotation(params);\n  if (!(annotation.flags & AnnotationFlag.HIDDEN)) {\n    throw new Error(\"Expected annotation to have the HIDDEN flag set when PMD is present\");\n  }\n  if (annotation.data.hidden !== true) {\n    throw new Error(\"Expected annotation.data.hidden to be true when PMD is present\");\n  }\n});",
    "i3_deepseek-r1-distill-llama-70b": "it(\"should hide barcode annotations when PMD is present\", () => {\n  const dummyDict = {\n    has: key => key === \"PMD\",\n    get: () => undefined,\n  };\n  const params = {\n    subtype: \"Widget\",\n    fieldType: \"Tx\",\n    dict: dummyDict,\n    data: {\n      readOnly: true,\n      noHTML: false,\n      fieldValue: \"Test\",\n    },\n  };\n  const annotation = AnnotationFactory.createAnnotation(params);\n  if (!(annotation.flags & AnnotationFlag.HIDDEN)) {\n    throw new Error(\"Expected annotation to have the HIDDEN flag set when PMD is present\");\n  }\n  if (annotation.data.hidden !== true) {\n    throw new Error(\"Expected annotation.data.hidden to be true when PMD is present\");\n  }\n});",
    "i3_gpt-4o": "it(\"should hide barcode annotations when PMD is present\", () => {\n  const dummyDict = {\n    has: key => key === \"PMD\",\n    get: () => undefined,\n  };\n  const params = {\n    subtype: \"Widget\",\n    fieldType: \"Tx\",\n    dict: dummyDict,\n    data: {\n      readOnly: true,\n      noHTML: false,\n      fieldValue: \"Test\",\n    },\n  };\n  const annotation = AnnotationFactory.createAnnotation(params);\n  if (!(annotation.flags & AnnotationFlag.HIDDEN)) {\n    throw new Error(\"Expected annotation to have the HIDDEN flag set when PMD is present\");\n  }\n  if (annotation.data.hidden !== true) {\n    throw new Error(\"Expected annotation.data.hidden to be true when PMD is present\");\n  }\n});",
    "i3_llama-3.3-70b-versatile": "it(\"should hide barcode annotations when PMD is present\", () => {\n  const dummyDict = {\n    has: key => key === \"PMD\",\n    get: () => undefined,\n  };\n  const params = {\n    subtype: \"Widget\",\n    fieldType: \"Tx\",\n    dict: dummyDict,\n    data: {\n      readOnly: true,\n      noHTML: false,\n      fieldValue: \"Test\",\n    },\n  };\n  const annotation = AnnotationFactory.createAnnotation(params);\n  if (!(annotation.flags & AnnotationFlag.HIDDEN)) {\n    throw new Error(\"Expected annotation to have the HIDDEN flag set when PMD is present\");\n  }\n  if (annotation.data.hidden !== true) {\n    throw new Error(\"Expected annotation.data.hidden to be true when PMD is present\");\n  }\n});",
    "i4_deepseek-r1-distill-llama-70b": "it(\"should hide barcode annotations when PMD is present\", () => {\n  const dummyDict = {\n    has: key => key === \"PMD\",\n    get: () => undefined,\n  };\n  const params = {\n    subtype: \"Widget\",\n    fieldType: \"Tx\",\n    dict: dummyDict,\n    data: {\n      readOnly: true,\n      noHTML: false,\n      fieldValue: \"Test\",\n    },\n  };\n  const annotation = AnnotationFactory.createAnnotation(params);\n  if (!(annotation.flags & AnnotationFlag.HIDDEN)) {\n    throw new Error(\"Expected annotation to have the HIDDEN flag set when PMD is present\");\n  }\n  if (annotation.data.hidden !== true) {\n    throw new Error(\"Expected annotation.data.hidden to be true when PMD is present\");\n  }\n});",
    "i4_gpt-4o": "it(\"should hide barcode annotations when PMD is present\", () => {\n  const dummyDict = {\n    has: key => key === \"PMD\",\n    get: () => undefined,\n  };\n  const params = {\n    subtype: \"Widget\",\n    fieldType: \"Tx\",\n    dict: dummyDict,\n    data: {\n      readOnly: true,\n      noHTML: false,\n      fieldValue: \"Test\",\n    },\n  };\n  const annotation = AnnotationFactory.createAnnotation(params);\n  if (!(annotation.flags & AnnotationFlag.HIDDEN)) {\n    throw new Error(\"Expected annotation to have the HIDDEN flag set when PMD is present\");\n  }\n  if (annotation.data.hidden !== true) {\n    throw new Error(\"Expected annotation.data.hidden to be true when PMD is present\");\n  }\n});",
    "i4_llama-3.3-70b-versatile": "it(\"should hide barcode annotations when PMD is present\", () => {\n  const dummyDict = {\n    has: key => key === \"PMD\",\n    get: () => undefined,\n  };\n  const params = {\n    subtype: \"Widget\",\n    fieldType: \"Tx\",\n    dict: dummyDict,\n    data: {\n      readOnly: true,\n      noHTML: false,\n      fieldValue: \"Test\",\n    },\n  };\n  const annotation = AnnotationFactory.createAnnotation(params);\n  if (!(annotation.flags & AnnotationFlag.HIDDEN)) {\n    throw new Error(\"Expected annotation to have the HIDDEN flag set when PMD is present\");\n  }\n  if (annotation.data.hidden !== true) {\n    throw new Error(\"Expected annotation.data.hidden to be true when PMD is present\");\n  }\n});",
    "i5_deepseek-r1-distill-llama-70b": "it(\"should hide barcode annotations when PMD is present\", () => {\n  const dummyDict = {\n    has: key => key === \"PMD\",\n    get: () => undefined,\n  };\n  const params = {\n    subtype: \"Widget\",\n    fieldType: \"Tx\",\n    dict: dummyDict,\n    data: {\n      readOnly: true,\n      noHTML: false,\n      fieldValue: \"Test\",\n    },\n  };\n  const annotation = AnnotationFactory.createAnnotation(params);\n  if (!(annotation.flags & AnnotationFlag.HIDDEN)) {\n    throw new Error(\"Expected annotation to have the HIDDEN flag set when PMD is present\");\n  }\n  if (annotation.data.hidden !== true) {\n    throw new Error(\"Expected annotation.data.hidden to be true when PMD is present\");\n  }\n});",
    "i5_gpt-4o": "it(\"should hide barcode annotations when PMD is present\", () => {\n  const dummyDict = {\n    has: key => key === \"PMD\",\n    get: () => undefined,\n  };\n  const params = {\n    subtype: \"Widget\",\n    fieldType: \"Tx\",\n    dict: dummyDict,\n    data: {\n      readOnly: true,\n      noHTML: false,\n      fieldValue: \"Test\",\n    },\n  };\n  const annotation = AnnotationFactory.createAnnotation(params);\n  if (!(annotation.flags & AnnotationFlag.HIDDEN)) {\n    throw new Error(\"Expected annotation to have the HIDDEN flag set when PMD is present\");\n  }\n  if (annotation.data.hidden !== true) {\n    throw new Error(\"Expected annotation.data.hidden to be true when PMD is present\");\n  }\n});",
    "i5_llama-3.3-70b-versatile": "it(\"should hide barcode annotations when PMD is present\", () => {\n  const dummyDict = {\n    has: key => key === \"PMD\",\n    get: () => undefined,\n  };\n  const params = {\n    subtype: \"Widget\",\n    fieldType: \"Tx\",\n    dict: dummyDict,\n    data: {\n      readOnly: true,\n      noHTML: false,\n      fieldValue: \"Test\",\n    },\n  };\n  const annotation = AnnotationFactory.createAnnotation(params);\n  if (!(annotation.flags & AnnotationFlag.HIDDEN)) {\n    throw new Error(\"Expected annotation to have the HIDDEN flag set when PMD is present\");\n  }\n  if (annotation.data.hidden !== true) {\n    throw new Error(\"Expected annotation.data.hidden to be true when PMD is present\");\n  }\n});"
  },
  "18253": {
    "i1_deepseek-r1-distill-llama-70b": "it(\"should compute OS2 table typoAscender correctly using maxfontMatrix rather than first element\", async () => {\n  const { createOS2Table } = await import(\"../../src/core/fonts.js\");\n  const properties = {\n    bbox: [0, -500, 500, 3000],\n    ascent: 3000,\n    descent: -500,\n    fontMatrix: [2, 0, 0, 3, 0, 0],\n    fixedPitch: false,\n    italicAngle: 0,\n    xHeight: 10,\n    capHeight: 10,\n  };\n  // Pass no charstrings so that firstCharIndex becomes 0 and lastCharIndex becomes 255.\n  const os2Table = createOS2Table(properties, null, {});\n  // The typoAscender field is written as a 2-byte big-endian string at offset 68-70.\n  const typoAscenderBytes = os2Table.slice(68, 70);\n  // With the patched code, unitsPerEm = 1/Math.max(2,0,0,3)=1/3; scale = (1/3)/1000 = 0.0003333;\n  // typoAscender = Math.round(3000 * 0.0003333) = 1, i.e. \"\\x00\\x01\".\n  if (typoAscenderBytes !== \"\\x00\\x01\") {\n    throw new Error(\n      `Expected typoAscender bytes to be \"\\\\x00\\\\x01\" but got ${JSON.stringify(\n        typoAscenderBytes\n      )}`\n    );\n  }\n});\n",
    "i1_gpt-4o": "it(\"should compute OS2 table typoAscender correctly using maxfontMatrix rather than first element\", async () => {\n  const { createOS2Table } = await import(\"../../src/core/fonts.js\");\n  const properties = {\n    bbox: [0, -500, 500, 3000],\n    ascent: 3000,\n    descent: -500,\n    fontMatrix: [2, 0, 0, 3, 0, 0],\n    fixedPitch: false,\n    italicAngle: 0,\n    xHeight: 10,\n    capHeight: 10,\n  };\n  // Pass no charstrings so that firstCharIndex becomes 0 and lastCharIndex becomes 255.\n  const os2Table = createOS2Table(properties, null, {});\n  // The typoAscender field is written as a 2-byte big-endian string at offset 68-70.\n  const typoAscenderBytes = os2Table.slice(68, 70);\n  // With the patched code, unitsPerEm = 1/Math.max(2,0,0,3)=1/3; scale = (1/3)/1000 = 0.0003333;\n  // typoAscender = Math.round(3000 * 0.0003333) = 1, i.e. \"\\x00\\x01\".\n  if (typoAscenderBytes !== \"\\x00\\x01\") {\n    throw new Error(\n      `Expected typoAscender bytes to be \"\\\\x00\\\\x01\" but got ${JSON.stringify(\n        typoAscenderBytes\n      )}`\n    );\n  }\n});\n",
    "i1_llama-3.3-70b-versatile": "it(\"should compute OS2 table typoAscender correctly using maxfontMatrix rather than first element\", async () => {\n  const { createOS2Table } = await import(\"../../src/core/fonts.js\");\n  const properties = {\n    bbox: [0, -500, 500, 3000],\n    ascent: 3000,\n    descent: -500,\n    fontMatrix: [2, 0, 0, 3, 0, 0],\n    fixedPitch: false,\n    italicAngle: 0,\n    xHeight: 10,\n    capHeight: 10,\n  };\n  // Pass no charstrings so that firstCharIndex becomes 0 and lastCharIndex becomes 255.\n  const os2Table = createOS2Table(properties, null, {});\n  // The typoAscender field is written as a 2-byte big-endian string at offset 68-70.\n  const typoAscenderBytes = os2Table.slice(68, 70);\n  // With the patched code, unitsPerEm = 1/Math.max(2,0,0,3)=1/3; scale = (1/3)/1000 = 0.0003333;\n  // typoAscender = Math.round(3000 * 0.0003333) = 1, i.e. \"\\x00\\x01\".\n  if (typoAscenderBytes !== \"\\x00\\x01\") {\n    throw new Error(\n      `Expected typoAscender bytes to be \"\\\\x00\\\\x01\" but got ${JSON.stringify(\n        typoAscenderBytes\n      )}`\n    );\n  }\n});\n",
    "i1_MOCK": "it(\"should compute OS2 table typoAscender correctly using maxfontMatrix rather than first element\", async () => {\n  const { createOS2Table } = await import(\"../../src/core/fonts.js\");\n  const properties = {\n    bbox: [0, -500, 500, 3000],\n    ascent: 3000,\n    descent: -500,\n    fontMatrix: [2, 0, 0, 3, 0, 0],\n    fixedPitch: false,\n    italicAngle: 0,\n    xHeight: 10,\n    capHeight: 10,\n  };\n  // Pass no charstrings so that firstCharIndex becomes 0 and lastCharIndex becomes 255.\n  const os2Table = createOS2Table(properties, null, {});\n  // The typoAscender field is written as a 2-byte big-endian string at offset 68-70.\n  const typoAscenderBytes = os2Table.slice(68, 70);\n  // With the patched code, unitsPerEm = 1/Math.max(2,0,0,3)=1/3; scale = (1/3)/1000 = 0.0003333;\n  // typoAscender = Math.round(3000 * 0.0003333) = 1, i.e. \"\\x00\\x01\".\n  if (typoAscenderBytes !== \"\\x00\\x01\") {\n    throw new Error(\n      `Expected typoAscender bytes to be \"\\\\x00\\\\x01\" but got ${JSON.stringify(\n        typoAscenderBytes\n      )}`\n    );\n  }\n});\n",
    "i2_deepseek-r1-distill-llama-70b": "it(\"should compute OS2 table typoAscender correctly using maxfontMatrix rather than first element\", async () => {\n  const { createOS2Table } = await import(\"../../src/core/fonts.js\");\n  const properties = {\n    bbox: [0, -500, 500, 3000],\n    ascent: 3000,\n    descent: -500,\n    fontMatrix: [2, 0, 0, 3, 0, 0],\n    fixedPitch: false,\n    italicAngle: 0,\n    xHeight: 10,\n    capHeight: 10,\n  };\n  // Pass no charstrings so that firstCharIndex becomes 0 and lastCharIndex becomes 255.\n  const os2Table = createOS2Table(properties, null, {});\n  // The typoAscender field is written as a 2-byte big-endian string at offset 68-70.\n  const typoAscenderBytes = os2Table.slice(68, 70);\n  // With the patched code, unitsPerEm = 1/Math.max(2,0,0,3)=1/3; scale = (1/3)/1000 = 0.0003333;\n  // typoAscender = Math.round(3000 * 0.0003333) = 1, i.e. \"\\x00\\x01\".\n  if (typoAscenderBytes !== \"\\x00\\x01\") {\n    throw new Error(\n      `Expected typoAscender bytes to be \"\\\\x00\\\\x01\" but got ${JSON.stringify(\n        typoAscenderBytes\n      )}`\n    );\n  }\n});\n",
    "i2_gpt-4o": "it(\"should compute OS2 table typoAscender correctly using maxfontMatrix rather than first element\", async () => {\n  const { createOS2Table } = await import(\"../../src/core/fonts.js\");\n  const properties = {\n    bbox: [0, -500, 500, 3000],\n    ascent: 3000,\n    descent: -500,\n    fontMatrix: [2, 0, 0, 3, 0, 0],\n    fixedPitch: false,\n    italicAngle: 0,\n    xHeight: 10,\n    capHeight: 10,\n  };\n  // Pass no charstrings so that firstCharIndex becomes 0 and lastCharIndex becomes 255.\n  const os2Table = createOS2Table(properties, null, {});\n  // The typoAscender field is written as a 2-byte big-endian string at offset 68-70.\n  const typoAscenderBytes = os2Table.slice(68, 70);\n  // With the patched code, unitsPerEm = 1/Math.max(2,0,0,3)=1/3; scale = (1/3)/1000 = 0.0003333;\n  // typoAscender = Math.round(3000 * 0.0003333) = 1, i.e. \"\\x00\\x01\".\n  if (typoAscenderBytes !== \"\\x00\\x01\") {\n    throw new Error(\n      `Expected typoAscender bytes to be \"\\\\x00\\\\x01\" but got ${JSON.stringify(\n        typoAscenderBytes\n      )}`\n    );\n  }\n});\n",
    "i2_llama-3.3-70b-versatile": "it(\"should compute OS2 table typoAscender correctly using maxfontMatrix rather than first element\", async () => {\n  const { createOS2Table } = await import(\"../../src/core/fonts.js\");\n  const properties = {\n    bbox: [0, -500, 500, 3000],\n    ascent: 3000,\n    descent: -500,\n    fontMatrix: [2, 0, 0, 3, 0, 0],\n    fixedPitch: false,\n    italicAngle: 0,\n    xHeight: 10,\n    capHeight: 10,\n  };\n  // Pass no charstrings so that firstCharIndex becomes 0 and lastCharIndex becomes 255.\n  const os2Table = createOS2Table(properties, null, {});\n  // The typoAscender field is written as a 2-byte big-endian string at offset 68-70.\n  const typoAscenderBytes = os2Table.slice(68, 70);\n  // With the patched code, unitsPerEm = 1/Math.max(2,0,0,3)=1/3; scale = (1/3)/1000 = 0.0003333;\n  // typoAscender = Math.round(3000 * 0.0003333) = 1, i.e. \"\\x00\\x01\".\n  if (typoAscenderBytes !== \"\\x00\\x01\") {\n    throw new Error(\n      `Expected typoAscender bytes to be \"\\\\x00\\\\x01\" but got ${JSON.stringify(\n        typoAscenderBytes\n      )}`\n    );\n  }\n});\n",
    "i3_deepseek-r1-distill-llama-70b": "it(\"should compute OS2 table typoAscender correctly using maxfontMatrix rather than first element\", async () => {\n  const { createOS2Table } = await import(\"../../src/core/fonts.js\");\n  const properties = {\n    bbox: [0, -500, 500, 3000],\n    ascent: 3000,\n    descent: -500,\n    fontMatrix: [2, 0, 0, 3, 0, 0],\n    fixedPitch: false,\n    italicAngle: 0,\n    xHeight: 10,\n    capHeight: 10,\n  };\n  // Pass no charstrings so that firstCharIndex becomes 0 and lastCharIndex becomes 255.\n  const os2Table = createOS2Table(properties, null, {});\n  // The typoAscender field is written as a 2-byte big-endian string at offset 68-70.\n  const typoAscenderBytes = os2Table.slice(68, 70);\n  // With the patched code, unitsPerEm = 1/Math.max(2,0,0,3)=1/3; scale = (1/3)/1000 = 0.0003333;\n  // typoAscender = Math.round(3000 * 0.0003333) = 1, i.e. \"\\x00\\x01\".\n  if (typoAscenderBytes !== \"\\x00\\x01\") {\n    throw new Error(\n      `Expected typoAscender bytes to be \"\\\\x00\\\\x01\" but got ${JSON.stringify(\n        typoAscenderBytes\n      )}`\n    );\n  }\n});\n",
    "i3_gpt-4o": "it(\"should compute OS2 table typoAscender correctly using maxfontMatrix rather than first element\", async () => {\n  const { createOS2Table } = await import(\"../../src/core/fonts.js\");\n  const properties = {\n    bbox: [0, -500, 500, 3000],\n    ascent: 3000,\n    descent: -500,\n    fontMatrix: [2, 0, 0, 3, 0, 0],\n    fixedPitch: false,\n    italicAngle: 0,\n    xHeight: 10,\n    capHeight: 10,\n  };\n  // Pass no charstrings so that firstCharIndex becomes 0 and lastCharIndex becomes 255.\n  const os2Table = createOS2Table(properties, null, {});\n  // The typoAscender field is written as a 2-byte big-endian string at offset 68-70.\n  const typoAscenderBytes = os2Table.slice(68, 70);\n  // With the patched code, unitsPerEm = 1/Math.max(2,0,0,3)=1/3; scale = (1/3)/1000 = 0.0003333;\n  // typoAscender = Math.round(3000 * 0.0003333) = 1, i.e. \"\\x00\\x01\".\n  if (typoAscenderBytes !== \"\\x00\\x01\") {\n    throw new Error(\n      `Expected typoAscender bytes to be \"\\\\x00\\\\x01\" but got ${JSON.stringify(\n        typoAscenderBytes\n      )}`\n    );\n  }\n});\n",
    "i3_llama-3.3-70b-versatile": "it(\"should compute OS2 table typoAscender correctly using maxfontMatrix rather than first element\", async () => {\n  const { createOS2Table } = await import(\"../../src/core/fonts.js\");\n  const properties = {\n    bbox: [0, -500, 500, 3000],\n    ascent: 3000,\n    descent: -500,\n    fontMatrix: [2, 0, 0, 3, 0, 0],\n    fixedPitch: false,\n    italicAngle: 0,\n    xHeight: 10,\n    capHeight: 10,\n  };\n  // Pass no charstrings so that firstCharIndex becomes 0 and lastCharIndex becomes 255.\n  const os2Table = createOS2Table(properties, null, {});\n  // The typoAscender field is written as a 2-byte big-endian string at offset 68-70.\n  const typoAscenderBytes = os2Table.slice(68, 70);\n  // With the patched code, unitsPerEm = 1/Math.max(2,0,0,3)=1/3; scale = (1/3)/1000 = 0.0003333;\n  // typoAscender = Math.round(3000 * 0.0003333) = 1, i.e. \"\\x00\\x01\".\n  if (typoAscenderBytes !== \"\\x00\\x01\") {\n    throw new Error(\n      `Expected typoAscender bytes to be \"\\\\x00\\\\x01\" but got ${JSON.stringify(\n        typoAscenderBytes\n      )}`\n    );\n  }\n});\n",
    "i4_deepseek-r1-distill-llama-70b": "it(\"should compute OS2 table typoAscender correctly using maxfontMatrix rather than first element\", async () => {\n  const { createOS2Table } = await import(\"../../src/core/fonts.js\");\n  const properties = {\n    bbox: [0, -500, 500, 3000],\n    ascent: 3000,\n    descent: -500,\n    fontMatrix: [2, 0, 0, 3, 0, 0],\n    fixedPitch: false,\n    italicAngle: 0,\n    xHeight: 10,\n    capHeight: 10,\n  };\n  // Pass no charstrings so that firstCharIndex becomes 0 and lastCharIndex becomes 255.\n  const os2Table = createOS2Table(properties, null, {});\n  // The typoAscender field is written as a 2-byte big-endian string at offset 68-70.\n  const typoAscenderBytes = os2Table.slice(68, 70);\n  // With the patched code, unitsPerEm = 1/Math.max(2,0,0,3)=1/3; scale = (1/3)/1000 = 0.0003333;\n  // typoAscender = Math.round(3000 * 0.0003333) = 1, i.e. \"\\x00\\x01\".\n  if (typoAscenderBytes !== \"\\x00\\x01\") {\n    throw new Error(\n      `Expected typoAscender bytes to be \"\\\\x00\\\\x01\" but got ${JSON.stringify(\n        typoAscenderBytes\n      )}`\n    );\n  }\n});\n",
    "i4_gpt-4o": "it(\"should compute OS2 table typoAscender correctly using maxfontMatrix rather than first element\", async () => {\n  const { createOS2Table } = await import(\"../../src/core/fonts.js\");\n  const properties = {\n    bbox: [0, -500, 500, 3000],\n    ascent: 3000,\n    descent: -500,\n    fontMatrix: [2, 0, 0, 3, 0, 0],\n    fixedPitch: false,\n    italicAngle: 0,\n    xHeight: 10,\n    capHeight: 10,\n  };\n  // Pass no charstrings so that firstCharIndex becomes 0 and lastCharIndex becomes 255.\n  const os2Table = createOS2Table(properties, null, {});\n  // The typoAscender field is written as a 2-byte big-endian string at offset 68-70.\n  const typoAscenderBytes = os2Table.slice(68, 70);\n  // With the patched code, unitsPerEm = 1/Math.max(2,0,0,3)=1/3; scale = (1/3)/1000 = 0.0003333;\n  // typoAscender = Math.round(3000 * 0.0003333) = 1, i.e. \"\\x00\\x01\".\n  if (typoAscenderBytes !== \"\\x00\\x01\") {\n    throw new Error(\n      `Expected typoAscender bytes to be \"\\\\x00\\\\x01\" but got ${JSON.stringify(\n        typoAscenderBytes\n      )}`\n    );\n  }\n});\n",
    "i4_llama-3.3-70b-versatile": "it(\"should compute OS2 table typoAscender correctly using maxfontMatrix rather than first element\", async () => {\n  const { createOS2Table } = await import(\"../../src/core/fonts.js\");\n  const properties = {\n    bbox: [0, -500, 500, 3000],\n    ascent: 3000,\n    descent: -500,\n    fontMatrix: [2, 0, 0, 3, 0, 0],\n    fixedPitch: false,\n    italicAngle: 0,\n    xHeight: 10,\n    capHeight: 10,\n  };\n  // Pass no charstrings so that firstCharIndex becomes 0 and lastCharIndex becomes 255.\n  const os2Table = createOS2Table(properties, null, {});\n  // The typoAscender field is written as a 2-byte big-endian string at offset 68-70.\n  const typoAscenderBytes = os2Table.slice(68, 70);\n  // With the patched code, unitsPerEm = 1/Math.max(2,0,0,3)=1/3; scale = (1/3)/1000 = 0.0003333;\n  // typoAscender = Math.round(3000 * 0.0003333) = 1, i.e. \"\\x00\\x01\".\n  if (typoAscenderBytes !== \"\\x00\\x01\") {\n    throw new Error(\n      `Expected typoAscender bytes to be \"\\\\x00\\\\x01\" but got ${JSON.stringify(\n        typoAscenderBytes\n      )}`\n    );\n  }\n});\n",
    "i5_deepseek-r1-distill-llama-70b": "it(\"should compute OS2 table typoAscender correctly using maxfontMatrix rather than first element\", async () => {\n  const { createOS2Table } = await import(\"../../src/core/fonts.js\");\n  const properties = {\n    bbox: [0, -500, 500, 3000],\n    ascent: 3000,\n    descent: -500,\n    fontMatrix: [2, 0, 0, 3, 0, 0],\n    fixedPitch: false,\n    italicAngle: 0,\n    xHeight: 10,\n    capHeight: 10,\n  };\n  // Pass no charstrings so that firstCharIndex becomes 0 and lastCharIndex becomes 255.\n  const os2Table = createOS2Table(properties, null, {});\n  // The typoAscender field is written as a 2-byte big-endian string at offset 68-70.\n  const typoAscenderBytes = os2Table.slice(68, 70);\n  // With the patched code, unitsPerEm = 1/Math.max(2,0,0,3)=1/3; scale = (1/3)/1000 = 0.0003333;\n  // typoAscender = Math.round(3000 * 0.0003333) = 1, i.e. \"\\x00\\x01\".\n  if (typoAscenderBytes !== \"\\x00\\x01\") {\n    throw new Error(\n      `Expected typoAscender bytes to be \"\\\\x00\\\\x01\" but got ${JSON.stringify(\n        typoAscenderBytes\n      )}`\n    );\n  }\n});\n",
    "i5_gpt-4o": "it(\"should compute OS2 table typoAscender correctly using maxfontMatrix rather than first element\", async () => {\n  const { createOS2Table } = await import(\"../../src/core/fonts.js\");\n  const properties = {\n    bbox: [0, -500, 500, 3000],\n    ascent: 3000,\n    descent: -500,\n    fontMatrix: [2, 0, 0, 3, 0, 0],\n    fixedPitch: false,\n    italicAngle: 0,\n    xHeight: 10,\n    capHeight: 10,\n  };\n  // Pass no charstrings so that firstCharIndex becomes 0 and lastCharIndex becomes 255.\n  const os2Table = createOS2Table(properties, null, {});\n  // The typoAscender field is written as a 2-byte big-endian string at offset 68-70.\n  const typoAscenderBytes = os2Table.slice(68, 70);\n  // With the patched code, unitsPerEm = 1/Math.max(2,0,0,3)=1/3; scale = (1/3)/1000 = 0.0003333;\n  // typoAscender = Math.round(3000 * 0.0003333) = 1, i.e. \"\\x00\\x01\".\n  if (typoAscenderBytes !== \"\\x00\\x01\") {\n    throw new Error(\n      `Expected typoAscender bytes to be \"\\\\x00\\\\x01\" but got ${JSON.stringify(\n        typoAscenderBytes\n      )}`\n    );\n  }\n});\n",
    "i5_llama-3.3-70b-versatile": "it(\"should compute OS2 table typoAscender correctly using maxfontMatrix rather than first element\", async () => {\n  const { createOS2Table } = await import(\"../../src/core/fonts.js\");\n  const properties = {\n    bbox: [0, -500, 500, 3000],\n    ascent: 3000,\n    descent: -500,\n    fontMatrix: [2, 0, 0, 3, 0, 0],\n    fixedPitch: false,\n    italicAngle: 0,\n    xHeight: 10,\n    capHeight: 10,\n  };\n  // Pass no charstrings so that firstCharIndex becomes 0 and lastCharIndex becomes 255.\n  const os2Table = createOS2Table(properties, null, {});\n  // The typoAscender field is written as a 2-byte big-endian string at offset 68-70.\n  const typoAscenderBytes = os2Table.slice(68, 70);\n  // With the patched code, unitsPerEm = 1/Math.max(2,0,0,3)=1/3; scale = (1/3)/1000 = 0.0003333;\n  // typoAscender = Math.round(3000 * 0.0003333) = 1, i.e. \"\\x00\\x01\".\n  if (typoAscenderBytes !== \"\\x00\\x01\") {\n    throw new Error(\n      `Expected typoAscender bytes to be \"\\\\x00\\\\x01\" but got ${JSON.stringify(\n        typoAscenderBytes\n      )}`\n    );\n  }\n});\n"
  },
  "18269": {
    "i1_deepseek-r1-distill-llama-70b": "it(\"should add dependency with objId for cached paintImageXObject\", async () => {\n  const idFactory = createIdFactory();\n  const xref = new XRefMock();\n  const handler = { sendWithPromise: () => Promise.resolve(null) };\n  const options = {\n    maxImageSize: 1000,\n    isOffscreenCanvasSupported: false,\n    canvasMaxAreaInBytes: -1,\n    ignoreErrors: true,\n  };\n  const globalImageCache = {\n    shouldCache: () => false,\n    hasDecodeFailed: () => false,\n    setData() {},\n    addByteSize() {}\n  };\n  const partialEvaluator = new PartialEvaluator({\n    xref,\n    handler,\n    pageIndex: 0,\n    idFactory,\n    fontCache: {},\n    builtInCMapCache: {},\n    standardFontDataCache: {},\n    globalImageCache,\n    systemFontCache: {},\n    options,\n  });\n  // Stub _sendImgData so that buildPaintImageXObject can complete.\n  partialEvaluator._sendImgData = () => Promise.resolve();\n  // Create a dummy dictionary with required keys.\n  const dummyDict = new (await import(\"../../src/core/primitives.js\")).Dict();\n  dummyDict.set(\"W\", 10);\n  dummyDict.set(\"H\", 10);\n  // Set a fake objId to simulate an image reference.\n  dummyDict.objId = \"testImgRef\";\n  // Create a minimal dummy image with getBytes.\n  const dummyImage = {\n    dict: dummyDict,\n    getBytes: (n) => new Uint8Array(n),\n  };\n  // Override PDFImage.buildImage to simulate successful image decoding.\n  const { PDFImage } = await import(\"../../src/core/image.js\");\n  PDFImage.buildImage = (params) => {\n    return Promise.resolve({\n      createImageData: () =>\n        Promise.resolve({\n          width: params.image.dict.get(\"W\"),\n          height: params.image.dict.get(\"H\"),\n          data: new Uint8Array(4 * params.image.dict.get(\"W\") * params.image.dict.get(\"H\")),\n          bitmap: false,\n        }),\n    });\n  };\n  // Create a minimal operator list that records dependencies.\n  const operatorList = new OperatorList();\n  const originalAddDependency = operatorList.addDependency.bind(operatorList);\n  operatorList.dependencies = [];\n  operatorList.addDependency = (dep) => {\n    operatorList.dependencies.push(dep);\n    originalAddDependency(dep);\n  };\n  // Setup a simple localImageCache.\n  const localImageCache = {\n    _cache: {},\n    set(key, ref, data) {\n      this._cache[key] = data;\n    },\n    getByName(name) {\n      return this._cache[name];\n    }\n  };\n  const localColorSpaceCache = {};\n  const cacheKey = \"testCache\";\n  await partialEvaluator.buildPaintImageXObject({\n    resources: new (await import(\"../../src/core/primitives.js\")).Dict(),\n    image: dummyImage,\n    isInline: false,\n    operatorList,\n    cacheKey,\n    localImageCache,\n    localColorSpaceCache,\n  });\n  const cacheData = localImageCache._cache[cacheKey];\n  if (!cacheData || !cacheData.objId) {\n    throw new Error(\"Missing objId in cache data\");\n  }\n  if (!operatorList.dependencies.includes(cacheData.objId)) {\n    throw new Error(\"Dependency was not added with the correct objId\");\n  }\n});",
    "i1_gpt-4o": "it(\"should add dependency with objId for cached paintImageXObject\", async () => {\n  const idFactory = createIdFactory();\n  const xref = new XRefMock();\n  const handler = { sendWithPromise: () => Promise.resolve(null) };\n  const options = {\n    maxImageSize: 1000,\n    isOffscreenCanvasSupported: false,\n    canvasMaxAreaInBytes: -1,\n    ignoreErrors: true,\n  };\n  const globalImageCache = {\n    shouldCache: () => false,\n    hasDecodeFailed: () => false,\n    setData() {},\n    addByteSize() {}\n  };\n  const partialEvaluator = new PartialEvaluator({\n    xref,\n    handler,\n    pageIndex: 0,\n    idFactory,\n    fontCache: {},\n    builtInCMapCache: {},\n    standardFontDataCache: {},\n    globalImageCache,\n    systemFontCache: {},\n    options,\n  });\n  // Stub _sendImgData so that buildPaintImageXObject can complete.\n  partialEvaluator._sendImgData = () => Promise.resolve();\n  // Create a dummy dictionary with required keys.\n  const dummyDict = new (await import(\"../../src/core/primitives.js\")).Dict();\n  dummyDict.set(\"W\", 10);\n  dummyDict.set(\"H\", 10);\n  // Set a fake objId to simulate an image reference.\n  dummyDict.objId = \"testImgRef\";\n  // Create a minimal dummy image with getBytes.\n  const dummyImage = {\n    dict: dummyDict,\n    getBytes: (n) => new Uint8Array(n),\n  };\n  // Override PDFImage.buildImage to simulate successful image decoding.\n  const { PDFImage } = await import(\"../../src/core/image.js\");\n  PDFImage.buildImage = (params) => {\n    return Promise.resolve({\n      createImageData: () =>\n        Promise.resolve({\n          width: params.image.dict.get(\"W\"),\n          height: params.image.dict.get(\"H\"),\n          data: new Uint8Array(4 * params.image.dict.get(\"W\") * params.image.dict.get(\"H\")),\n          bitmap: false,\n        }),\n    });\n  };\n  // Create a minimal operator list that records dependencies.\n  const operatorList = new OperatorList();\n  const originalAddDependency = operatorList.addDependency.bind(operatorList);\n  operatorList.dependencies = [];\n  operatorList.addDependency = (dep) => {\n    operatorList.dependencies.push(dep);\n    originalAddDependency(dep);\n  };\n  // Setup a simple localImageCache.\n  const localImageCache = {\n    _cache: {},\n    set(key, ref, data) {\n      this._cache[key] = data;\n    },\n    getByName(name) {\n      return this._cache[name];\n    }\n  };\n  const localColorSpaceCache = {};\n  const cacheKey = \"testCache\";\n  await partialEvaluator.buildPaintImageXObject({\n    resources: new (await import(\"../../src/core/primitives.js\")).Dict(),\n    image: dummyImage,\n    isInline: false,\n    operatorList,\n    cacheKey,\n    localImageCache,\n    localColorSpaceCache,\n  });\n  const cacheData = localImageCache._cache[cacheKey];\n  if (!cacheData || !cacheData.objId) {\n    throw new Error(\"Missing objId in cache data\");\n  }\n  if (!operatorList.dependencies.includes(cacheData.objId)) {\n    throw new Error(\"Dependency was not added with the correct objId\");\n  }\n});",
    "i1_llama-3.3-70b-versatile": "it(\"should add dependency with objId for cached paintImageXObject\", async () => {\n  const idFactory = createIdFactory();\n  const xref = new XRefMock();\n  const handler = { sendWithPromise: () => Promise.resolve(null) };\n  const options = {\n    maxImageSize: 1000,\n    isOffscreenCanvasSupported: false,\n    canvasMaxAreaInBytes: -1,\n    ignoreErrors: true,\n  };\n  const globalImageCache = {\n    shouldCache: () => false,\n    hasDecodeFailed: () => false,\n    setData() {},\n    addByteSize() {}\n  };\n  const partialEvaluator = new PartialEvaluator({\n    xref,\n    handler,\n    pageIndex: 0,\n    idFactory,\n    fontCache: {},\n    builtInCMapCache: {},\n    standardFontDataCache: {},\n    globalImageCache,\n    systemFontCache: {},\n    options,\n  });\n  // Stub _sendImgData so that buildPaintImageXObject can complete.\n  partialEvaluator._sendImgData = () => Promise.resolve();\n  // Create a dummy dictionary with required keys.\n  const dummyDict = new (await import(\"../../src/core/primitives.js\")).Dict();\n  dummyDict.set(\"W\", 10);\n  dummyDict.set(\"H\", 10);\n  // Set a fake objId to simulate an image reference.\n  dummyDict.objId = \"testImgRef\";\n  // Create a minimal dummy image with getBytes.\n  const dummyImage = {\n    dict: dummyDict,\n    getBytes: (n) => new Uint8Array(n),\n  };\n  // Override PDFImage.buildImage to simulate successful image decoding.\n  const { PDFImage } = await import(\"../../src/core/image.js\");\n  PDFImage.buildImage = (params) => {\n    return Promise.resolve({\n      createImageData: () =>\n        Promise.resolve({\n          width: params.image.dict.get(\"W\"),\n          height: params.image.dict.get(\"H\"),\n          data: new Uint8Array(4 * params.image.dict.get(\"W\") * params.image.dict.get(\"H\")),\n          bitmap: false,\n        }),\n    });\n  };\n  // Create a minimal operator list that records dependencies.\n  const operatorList = new OperatorList();\n  const originalAddDependency = operatorList.addDependency.bind(operatorList);\n  operatorList.dependencies = [];\n  operatorList.addDependency = (dep) => {\n    operatorList.dependencies.push(dep);\n    originalAddDependency(dep);\n  };\n  // Setup a simple localImageCache.\n  const localImageCache = {\n    _cache: {},\n    set(key, ref, data) {\n      this._cache[key] = data;\n    },\n    getByName(name) {\n      return this._cache[name];\n    }\n  };\n  const localColorSpaceCache = {};\n  const cacheKey = \"testCache\";\n  await partialEvaluator.buildPaintImageXObject({\n    resources: new (await import(\"../../src/core/primitives.js\")).Dict(),\n    image: dummyImage,\n    isInline: false,\n    operatorList,\n    cacheKey,\n    localImageCache,\n    localColorSpaceCache,\n  });\n  const cacheData = localImageCache._cache[cacheKey];\n  if (!cacheData || !cacheData.objId) {\n    throw new Error(\"Missing objId in cache data\");\n  }\n  if (!operatorList.dependencies.includes(cacheData.objId)) {\n    throw new Error(\"Dependency was not added with the correct objId\");\n  }\n});",
    "i1_MOCK": "it(\"should add dependency with objId for cached paintImageXObject\", async () => {\n  const idFactory = createIdFactory();\n  const xref = new XRefMock();\n  const handler = { sendWithPromise: () => Promise.resolve(null) };\n  const options = {\n    maxImageSize: 1000,\n    isOffscreenCanvasSupported: false,\n    canvasMaxAreaInBytes: -1,\n    ignoreErrors: true,\n  };\n  const globalImageCache = {\n    shouldCache: () => false,\n    hasDecodeFailed: () => false,\n    setData() {},\n    addByteSize() {}\n  };\n  const partialEvaluator = new PartialEvaluator({\n    xref,\n    handler,\n    pageIndex: 0,\n    idFactory,\n    fontCache: {},\n    builtInCMapCache: {},\n    standardFontDataCache: {},\n    globalImageCache,\n    systemFontCache: {},\n    options,\n  });\n  // Stub _sendImgData so that buildPaintImageXObject can complete.\n  partialEvaluator._sendImgData = () => Promise.resolve();\n  // Create a dummy dictionary with required keys.\n  const dummyDict = new (await import(\"../../src/core/primitives.js\")).Dict();\n  dummyDict.set(\"W\", 10);\n  dummyDict.set(\"H\", 10);\n  // Set a fake objId to simulate an image reference.\n  dummyDict.objId = \"testImgRef\";\n  // Create a minimal dummy image with getBytes.\n  const dummyImage = {\n    dict: dummyDict,\n    getBytes: (n) => new Uint8Array(n),\n  };\n  // Override PDFImage.buildImage to simulate successful image decoding.\n  const { PDFImage } = await import(\"../../src/core/image.js\");\n  PDFImage.buildImage = (params) => {\n    return Promise.resolve({\n      createImageData: () =>\n        Promise.resolve({\n          width: params.image.dict.get(\"W\"),\n          height: params.image.dict.get(\"H\"),\n          data: new Uint8Array(4 * params.image.dict.get(\"W\") * params.image.dict.get(\"H\")),\n          bitmap: false,\n        }),\n    });\n  };\n  // Create a minimal operator list that records dependencies.\n  const operatorList = new OperatorList();\n  const originalAddDependency = operatorList.addDependency.bind(operatorList);\n  operatorList.dependencies = [];\n  operatorList.addDependency = (dep) => {\n    operatorList.dependencies.push(dep);\n    originalAddDependency(dep);\n  };\n  // Setup a simple localImageCache.\n  const localImageCache = {\n    _cache: {},\n    set(key, ref, data) {\n      this._cache[key] = data;\n    },\n    getByName(name) {\n      return this._cache[name];\n    }\n  };\n  const localColorSpaceCache = {};\n  const cacheKey = \"testCache\";\n  await partialEvaluator.buildPaintImageXObject({\n    resources: new (await import(\"../../src/core/primitives.js\")).Dict(),\n    image: dummyImage,\n    isInline: false,\n    operatorList,\n    cacheKey,\n    localImageCache,\n    localColorSpaceCache,\n  });\n  const cacheData = localImageCache._cache[cacheKey];\n  if (!cacheData || !cacheData.objId) {\n    throw new Error(\"Missing objId in cache data\");\n  }\n  if (!operatorList.dependencies.includes(cacheData.objId)) {\n    throw new Error(\"Dependency was not added with the correct objId\");\n  }\n});",
    "i2_deepseek-r1-distill-llama-70b": "it(\"should add dependency with objId for cached paintImageXObject\", async () => {\n  const idFactory = createIdFactory();\n  const xref = new XRefMock();\n  const handler = { sendWithPromise: () => Promise.resolve(null) };\n  const options = {\n    maxImageSize: 1000,\n    isOffscreenCanvasSupported: false,\n    canvasMaxAreaInBytes: -1,\n    ignoreErrors: true,\n  };\n  const globalImageCache = {\n    shouldCache: () => false,\n    hasDecodeFailed: () => false,\n    setData() {},\n    addByteSize() {}\n  };\n  const partialEvaluator = new PartialEvaluator({\n    xref,\n    handler,\n    pageIndex: 0,\n    idFactory,\n    fontCache: {},\n    builtInCMapCache: {},\n    standardFontDataCache: {},\n    globalImageCache,\n    systemFontCache: {},\n    options,\n  });\n  // Stub _sendImgData so that buildPaintImageXObject can complete.\n  partialEvaluator._sendImgData = () => Promise.resolve();\n  // Create a dummy dictionary with required keys.\n  const dummyDict = new (await import(\"../../src/core/primitives.js\")).Dict();\n  dummyDict.set(\"W\", 10);\n  dummyDict.set(\"H\", 10);\n  // Set a fake objId to simulate an image reference.\n  dummyDict.objId = \"testImgRef\";\n  // Create a minimal dummy image with getBytes.\n  const dummyImage = {\n    dict: dummyDict,\n    getBytes: (n) => new Uint8Array(n),\n  };\n  // Override PDFImage.buildImage to simulate successful image decoding.\n  const { PDFImage } = await import(\"../../src/core/image.js\");\n  PDFImage.buildImage = (params) => {\n    return Promise.resolve({\n      createImageData: () =>\n        Promise.resolve({\n          width: params.image.dict.get(\"W\"),\n          height: params.image.dict.get(\"H\"),\n          data: new Uint8Array(4 * params.image.dict.get(\"W\") * params.image.dict.get(\"H\")),\n          bitmap: false,\n        }),\n    });\n  };\n  // Create a minimal operator list that records dependencies.\n  const operatorList = new OperatorList();\n  const originalAddDependency = operatorList.addDependency.bind(operatorList);\n  operatorList.dependencies = [];\n  operatorList.addDependency = (dep) => {\n    operatorList.dependencies.push(dep);\n    originalAddDependency(dep);\n  };\n  // Setup a simple localImageCache.\n  const localImageCache = {\n    _cache: {},\n    set(key, ref, data) {\n      this._cache[key] = data;\n    },\n    getByName(name) {\n      return this._cache[name];\n    }\n  };\n  const localColorSpaceCache = {};\n  const cacheKey = \"testCache\";\n  await partialEvaluator.buildPaintImageXObject({\n    resources: new (await import(\"../../src/core/primitives.js\")).Dict(),\n    image: dummyImage,\n    isInline: false,\n    operatorList,\n    cacheKey,\n    localImageCache,\n    localColorSpaceCache,\n  });\n  const cacheData = localImageCache._cache[cacheKey];\n  if (!cacheData || !cacheData.objId) {\n    throw new Error(\"Missing objId in cache data\");\n  }\n  if (!operatorList.dependencies.includes(cacheData.objId)) {\n    throw new Error(\"Dependency was not added with the correct objId\");\n  }\n});",
    "i2_gpt-4o": "it(\"should add dependency with objId for cached paintImageXObject\", async () => {\n  const idFactory = createIdFactory();\n  const xref = new XRefMock();\n  const handler = { sendWithPromise: () => Promise.resolve(null) };\n  const options = {\n    maxImageSize: 1000,\n    isOffscreenCanvasSupported: false,\n    canvasMaxAreaInBytes: -1,\n    ignoreErrors: true,\n  };\n  const globalImageCache = {\n    shouldCache: () => false,\n    hasDecodeFailed: () => false,\n    setData() {},\n    addByteSize() {}\n  };\n  const partialEvaluator = new PartialEvaluator({\n    xref,\n    handler,\n    pageIndex: 0,\n    idFactory,\n    fontCache: {},\n    builtInCMapCache: {},\n    standardFontDataCache: {},\n    globalImageCache,\n    systemFontCache: {},\n    options,\n  });\n  // Stub _sendImgData so that buildPaintImageXObject can complete.\n  partialEvaluator._sendImgData = () => Promise.resolve();\n  // Create a dummy dictionary with required keys.\n  const dummyDict = new (await import(\"../../src/core/primitives.js\")).Dict();\n  dummyDict.set(\"W\", 10);\n  dummyDict.set(\"H\", 10);\n  // Set a fake objId to simulate an image reference.\n  dummyDict.objId = \"testImgRef\";\n  // Create a minimal dummy image with getBytes.\n  const dummyImage = {\n    dict: dummyDict,\n    getBytes: (n) => new Uint8Array(n),\n  };\n  // Override PDFImage.buildImage to simulate successful image decoding.\n  const { PDFImage } = await import(\"../../src/core/image.js\");\n  PDFImage.buildImage = (params) => {\n    return Promise.resolve({\n      createImageData: () =>\n        Promise.resolve({\n          width: params.image.dict.get(\"W\"),\n          height: params.image.dict.get(\"H\"),\n          data: new Uint8Array(4 * params.image.dict.get(\"W\") * params.image.dict.get(\"H\")),\n          bitmap: false,\n        }),\n    });\n  };\n  // Create a minimal operator list that records dependencies.\n  const operatorList = new OperatorList();\n  const originalAddDependency = operatorList.addDependency.bind(operatorList);\n  operatorList.dependencies = [];\n  operatorList.addDependency = (dep) => {\n    operatorList.dependencies.push(dep);\n    originalAddDependency(dep);\n  };\n  // Setup a simple localImageCache.\n  const localImageCache = {\n    _cache: {},\n    set(key, ref, data) {\n      this._cache[key] = data;\n    },\n    getByName(name) {\n      return this._cache[name];\n    }\n  };\n  const localColorSpaceCache = {};\n  const cacheKey = \"testCache\";\n  await partialEvaluator.buildPaintImageXObject({\n    resources: new (await import(\"../../src/core/primitives.js\")).Dict(),\n    image: dummyImage,\n    isInline: false,\n    operatorList,\n    cacheKey,\n    localImageCache,\n    localColorSpaceCache,\n  });\n  const cacheData = localImageCache._cache[cacheKey];\n  if (!cacheData || !cacheData.objId) {\n    throw new Error(\"Missing objId in cache data\");\n  }\n  if (!operatorList.dependencies.includes(cacheData.objId)) {\n    throw new Error(\"Dependency was not added with the correct objId\");\n  }\n});",
    "i2_llama-3.3-70b-versatile": "it(\"should add dependency with objId for cached paintImageXObject\", async () => {\n  const idFactory = createIdFactory();\n  const xref = new XRefMock();\n  const handler = { sendWithPromise: () => Promise.resolve(null) };\n  const options = {\n    maxImageSize: 1000,\n    isOffscreenCanvasSupported: false,\n    canvasMaxAreaInBytes: -1,\n    ignoreErrors: true,\n  };\n  const globalImageCache = {\n    shouldCache: () => false,\n    hasDecodeFailed: () => false,\n    setData() {},\n    addByteSize() {}\n  };\n  const partialEvaluator = new PartialEvaluator({\n    xref,\n    handler,\n    pageIndex: 0,\n    idFactory,\n    fontCache: {},\n    builtInCMapCache: {},\n    standardFontDataCache: {},\n    globalImageCache,\n    systemFontCache: {},\n    options,\n  });\n  // Stub _sendImgData so that buildPaintImageXObject can complete.\n  partialEvaluator._sendImgData = () => Promise.resolve();\n  // Create a dummy dictionary with required keys.\n  const dummyDict = new (await import(\"../../src/core/primitives.js\")).Dict();\n  dummyDict.set(\"W\", 10);\n  dummyDict.set(\"H\", 10);\n  // Set a fake objId to simulate an image reference.\n  dummyDict.objId = \"testImgRef\";\n  // Create a minimal dummy image with getBytes.\n  const dummyImage = {\n    dict: dummyDict,\n    getBytes: (n) => new Uint8Array(n),\n  };\n  // Override PDFImage.buildImage to simulate successful image decoding.\n  const { PDFImage } = await import(\"../../src/core/image.js\");\n  PDFImage.buildImage = (params) => {\n    return Promise.resolve({\n      createImageData: () =>\n        Promise.resolve({\n          width: params.image.dict.get(\"W\"),\n          height: params.image.dict.get(\"H\"),\n          data: new Uint8Array(4 * params.image.dict.get(\"W\") * params.image.dict.get(\"H\")),\n          bitmap: false,\n        }),\n    });\n  };\n  // Create a minimal operator list that records dependencies.\n  const operatorList = new OperatorList();\n  const originalAddDependency = operatorList.addDependency.bind(operatorList);\n  operatorList.dependencies = [];\n  operatorList.addDependency = (dep) => {\n    operatorList.dependencies.push(dep);\n    originalAddDependency(dep);\n  };\n  // Setup a simple localImageCache.\n  const localImageCache = {\n    _cache: {},\n    set(key, ref, data) {\n      this._cache[key] = data;\n    },\n    getByName(name) {\n      return this._cache[name];\n    }\n  };\n  const localColorSpaceCache = {};\n  const cacheKey = \"testCache\";\n  await partialEvaluator.buildPaintImageXObject({\n    resources: new (await import(\"../../src/core/primitives.js\")).Dict(),\n    image: dummyImage,\n    isInline: false,\n    operatorList,\n    cacheKey,\n    localImageCache,\n    localColorSpaceCache,\n  });\n  const cacheData = localImageCache._cache[cacheKey];\n  if (!cacheData || !cacheData.objId) {\n    throw new Error(\"Missing objId in cache data\");\n  }\n  if (!operatorList.dependencies.includes(cacheData.objId)) {\n    throw new Error(\"Dependency was not added with the correct objId\");\n  }\n});",
    "i3_deepseek-r1-distill-llama-70b": "it(\"should add dependency with objId for cached paintImageXObject\", async () => {\n  const idFactory = createIdFactory();\n  const xref = new XRefMock();\n  const handler = { sendWithPromise: () => Promise.resolve(null) };\n  const options = {\n    maxImageSize: 1000,\n    isOffscreenCanvasSupported: false,\n    canvasMaxAreaInBytes: -1,\n    ignoreErrors: true,\n  };\n  const globalImageCache = {\n    shouldCache: () => false,\n    hasDecodeFailed: () => false,\n    setData() {},\n    addByteSize() {}\n  };\n  const partialEvaluator = new PartialEvaluator({\n    xref,\n    handler,\n    pageIndex: 0,\n    idFactory,\n    fontCache: {},\n    builtInCMapCache: {},\n    standardFontDataCache: {},\n    globalImageCache,\n    systemFontCache: {},\n    options,\n  });\n  // Stub _sendImgData so that buildPaintImageXObject can complete.\n  partialEvaluator._sendImgData = () => Promise.resolve();\n  // Create a dummy dictionary with required keys.\n  const dummyDict = new (await import(\"../../src/core/primitives.js\")).Dict();\n  dummyDict.set(\"W\", 10);\n  dummyDict.set(\"H\", 10);\n  // Set a fake objId to simulate an image reference.\n  dummyDict.objId = \"testImgRef\";\n  // Create a minimal dummy image with getBytes.\n  const dummyImage = {\n    dict: dummyDict,\n    getBytes: (n) => new Uint8Array(n),\n  };\n  // Override PDFImage.buildImage to simulate successful image decoding.\n  const { PDFImage } = await import(\"../../src/core/image.js\");\n  PDFImage.buildImage = (params) => {\n    return Promise.resolve({\n      createImageData: () =>\n        Promise.resolve({\n          width: params.image.dict.get(\"W\"),\n          height: params.image.dict.get(\"H\"),\n          data: new Uint8Array(4 * params.image.dict.get(\"W\") * params.image.dict.get(\"H\")),\n          bitmap: false,\n        }),\n    });\n  };\n  // Create a minimal operator list that records dependencies.\n  const operatorList = new OperatorList();\n  const originalAddDependency = operatorList.addDependency.bind(operatorList);\n  operatorList.dependencies = [];\n  operatorList.addDependency = (dep) => {\n    operatorList.dependencies.push(dep);\n    originalAddDependency(dep);\n  };\n  // Setup a simple localImageCache.\n  const localImageCache = {\n    _cache: {},\n    set(key, ref, data) {\n      this._cache[key] = data;\n    },\n    getByName(name) {\n      return this._cache[name];\n    }\n  };\n  const localColorSpaceCache = {};\n  const cacheKey = \"testCache\";\n  await partialEvaluator.buildPaintImageXObject({\n    resources: new (await import(\"../../src/core/primitives.js\")).Dict(),\n    image: dummyImage,\n    isInline: false,\n    operatorList,\n    cacheKey,\n    localImageCache,\n    localColorSpaceCache,\n  });\n  const cacheData = localImageCache._cache[cacheKey];\n  if (!cacheData || !cacheData.objId) {\n    throw new Error(\"Missing objId in cache data\");\n  }\n  if (!operatorList.dependencies.includes(cacheData.objId)) {\n    throw new Error(\"Dependency was not added with the correct objId\");\n  }\n});",
    "i3_gpt-4o": "it(\"should add dependency with objId for cached paintImageXObject\", async () => {\n  const idFactory = createIdFactory();\n  const xref = new XRefMock();\n  const handler = { sendWithPromise: () => Promise.resolve(null) };\n  const options = {\n    maxImageSize: 1000,\n    isOffscreenCanvasSupported: false,\n    canvasMaxAreaInBytes: -1,\n    ignoreErrors: true,\n  };\n  const globalImageCache = {\n    shouldCache: () => false,\n    hasDecodeFailed: () => false,\n    setData() {},\n    addByteSize() {}\n  };\n  const partialEvaluator = new PartialEvaluator({\n    xref,\n    handler,\n    pageIndex: 0,\n    idFactory,\n    fontCache: {},\n    builtInCMapCache: {},\n    standardFontDataCache: {},\n    globalImageCache,\n    systemFontCache: {},\n    options,\n  });\n  // Stub _sendImgData so that buildPaintImageXObject can complete.\n  partialEvaluator._sendImgData = () => Promise.resolve();\n  // Create a dummy dictionary with required keys.\n  const dummyDict = new (await import(\"../../src/core/primitives.js\")).Dict();\n  dummyDict.set(\"W\", 10);\n  dummyDict.set(\"H\", 10);\n  // Set a fake objId to simulate an image reference.\n  dummyDict.objId = \"testImgRef\";\n  // Create a minimal dummy image with getBytes.\n  const dummyImage = {\n    dict: dummyDict,\n    getBytes: (n) => new Uint8Array(n),\n  };\n  // Override PDFImage.buildImage to simulate successful image decoding.\n  const { PDFImage } = await import(\"../../src/core/image.js\");\n  PDFImage.buildImage = (params) => {\n    return Promise.resolve({\n      createImageData: () =>\n        Promise.resolve({\n          width: params.image.dict.get(\"W\"),\n          height: params.image.dict.get(\"H\"),\n          data: new Uint8Array(4 * params.image.dict.get(\"W\") * params.image.dict.get(\"H\")),\n          bitmap: false,\n        }),\n    });\n  };\n  // Create a minimal operator list that records dependencies.\n  const operatorList = new OperatorList();\n  const originalAddDependency = operatorList.addDependency.bind(operatorList);\n  operatorList.dependencies = [];\n  operatorList.addDependency = (dep) => {\n    operatorList.dependencies.push(dep);\n    originalAddDependency(dep);\n  };\n  // Setup a simple localImageCache.\n  const localImageCache = {\n    _cache: {},\n    set(key, ref, data) {\n      this._cache[key] = data;\n    },\n    getByName(name) {\n      return this._cache[name];\n    }\n  };\n  const localColorSpaceCache = {};\n  const cacheKey = \"testCache\";\n  await partialEvaluator.buildPaintImageXObject({\n    resources: new (await import(\"../../src/core/primitives.js\")).Dict(),\n    image: dummyImage,\n    isInline: false,\n    operatorList,\n    cacheKey,\n    localImageCache,\n    localColorSpaceCache,\n  });\n  const cacheData = localImageCache._cache[cacheKey];\n  if (!cacheData || !cacheData.objId) {\n    throw new Error(\"Missing objId in cache data\");\n  }\n  if (!operatorList.dependencies.includes(cacheData.objId)) {\n    throw new Error(\"Dependency was not added with the correct objId\");\n  }\n});",
    "i3_llama-3.3-70b-versatile": "it(\"should add dependency with objId for cached paintImageXObject\", async () => {\n  const idFactory = createIdFactory();\n  const xref = new XRefMock();\n  const handler = { sendWithPromise: () => Promise.resolve(null) };\n  const options = {\n    maxImageSize: 1000,\n    isOffscreenCanvasSupported: false,\n    canvasMaxAreaInBytes: -1,\n    ignoreErrors: true,\n  };\n  const globalImageCache = {\n    shouldCache: () => false,\n    hasDecodeFailed: () => false,\n    setData() {},\n    addByteSize() {}\n  };\n  const partialEvaluator = new PartialEvaluator({\n    xref,\n    handler,\n    pageIndex: 0,\n    idFactory,\n    fontCache: {},\n    builtInCMapCache: {},\n    standardFontDataCache: {},\n    globalImageCache,\n    systemFontCache: {},\n    options,\n  });\n  // Stub _sendImgData so that buildPaintImageXObject can complete.\n  partialEvaluator._sendImgData = () => Promise.resolve();\n  // Create a dummy dictionary with required keys.\n  const dummyDict = new (await import(\"../../src/core/primitives.js\")).Dict();\n  dummyDict.set(\"W\", 10);\n  dummyDict.set(\"H\", 10);\n  // Set a fake objId to simulate an image reference.\n  dummyDict.objId = \"testImgRef\";\n  // Create a minimal dummy image with getBytes.\n  const dummyImage = {\n    dict: dummyDict,\n    getBytes: (n) => new Uint8Array(n),\n  };\n  // Override PDFImage.buildImage to simulate successful image decoding.\n  const { PDFImage } = await import(\"../../src/core/image.js\");\n  PDFImage.buildImage = (params) => {\n    return Promise.resolve({\n      createImageData: () =>\n        Promise.resolve({\n          width: params.image.dict.get(\"W\"),\n          height: params.image.dict.get(\"H\"),\n          data: new Uint8Array(4 * params.image.dict.get(\"W\") * params.image.dict.get(\"H\")),\n          bitmap: false,\n        }),\n    });\n  };\n  // Create a minimal operator list that records dependencies.\n  const operatorList = new OperatorList();\n  const originalAddDependency = operatorList.addDependency.bind(operatorList);\n  operatorList.dependencies = [];\n  operatorList.addDependency = (dep) => {\n    operatorList.dependencies.push(dep);\n    originalAddDependency(dep);\n  };\n  // Setup a simple localImageCache.\n  const localImageCache = {\n    _cache: {},\n    set(key, ref, data) {\n      this._cache[key] = data;\n    },\n    getByName(name) {\n      return this._cache[name];\n    }\n  };\n  const localColorSpaceCache = {};\n  const cacheKey = \"testCache\";\n  await partialEvaluator.buildPaintImageXObject({\n    resources: new (await import(\"../../src/core/primitives.js\")).Dict(),\n    image: dummyImage,\n    isInline: false,\n    operatorList,\n    cacheKey,\n    localImageCache,\n    localColorSpaceCache,\n  });\n  const cacheData = localImageCache._cache[cacheKey];\n  if (!cacheData || !cacheData.objId) {\n    throw new Error(\"Missing objId in cache data\");\n  }\n  if (!operatorList.dependencies.includes(cacheData.objId)) {\n    throw new Error(\"Dependency was not added with the correct objId\");\n  }\n});",
    "i4_deepseek-r1-distill-llama-70b": "it(\"should add dependency with objId for cached paintImageXObject\", async () => {\n  const idFactory = createIdFactory();\n  const xref = new XRefMock();\n  const handler = { sendWithPromise: () => Promise.resolve(null) };\n  const options = {\n    maxImageSize: 1000,\n    isOffscreenCanvasSupported: false,\n    canvasMaxAreaInBytes: -1,\n    ignoreErrors: true,\n  };\n  const globalImageCache = {\n    shouldCache: () => false,\n    hasDecodeFailed: () => false,\n    setData() {},\n    addByteSize() {}\n  };\n  const partialEvaluator = new PartialEvaluator({\n    xref,\n    handler,\n    pageIndex: 0,\n    idFactory,\n    fontCache: {},\n    builtInCMapCache: {},\n    standardFontDataCache: {},\n    globalImageCache,\n    systemFontCache: {},\n    options,\n  });\n  // Stub _sendImgData so that buildPaintImageXObject can complete.\n  partialEvaluator._sendImgData = () => Promise.resolve();\n  // Create a dummy dictionary with required keys.\n  const dummyDict = new (await import(\"../../src/core/primitives.js\")).Dict();\n  dummyDict.set(\"W\", 10);\n  dummyDict.set(\"H\", 10);\n  // Set a fake objId to simulate an image reference.\n  dummyDict.objId = \"testImgRef\";\n  // Create a minimal dummy image with getBytes.\n  const dummyImage = {\n    dict: dummyDict,\n    getBytes: (n) => new Uint8Array(n),\n  };\n  // Override PDFImage.buildImage to simulate successful image decoding.\n  const { PDFImage } = await import(\"../../src/core/image.js\");\n  PDFImage.buildImage = (params) => {\n    return Promise.resolve({\n      createImageData: () =>\n        Promise.resolve({\n          width: params.image.dict.get(\"W\"),\n          height: params.image.dict.get(\"H\"),\n          data: new Uint8Array(4 * params.image.dict.get(\"W\") * params.image.dict.get(\"H\")),\n          bitmap: false,\n        }),\n    });\n  };\n  // Create a minimal operator list that records dependencies.\n  const operatorList = new OperatorList();\n  const originalAddDependency = operatorList.addDependency.bind(operatorList);\n  operatorList.dependencies = [];\n  operatorList.addDependency = (dep) => {\n    operatorList.dependencies.push(dep);\n    originalAddDependency(dep);\n  };\n  // Setup a simple localImageCache.\n  const localImageCache = {\n    _cache: {},\n    set(key, ref, data) {\n      this._cache[key] = data;\n    },\n    getByName(name) {\n      return this._cache[name];\n    }\n  };\n  const localColorSpaceCache = {};\n  const cacheKey = \"testCache\";\n  await partialEvaluator.buildPaintImageXObject({\n    resources: new (await import(\"../../src/core/primitives.js\")).Dict(),\n    image: dummyImage,\n    isInline: false,\n    operatorList,\n    cacheKey,\n    localImageCache,\n    localColorSpaceCache,\n  });\n  const cacheData = localImageCache._cache[cacheKey];\n  if (!cacheData || !cacheData.objId) {\n    throw new Error(\"Missing objId in cache data\");\n  }\n  if (!operatorList.dependencies.includes(cacheData.objId)) {\n    throw new Error(\"Dependency was not added with the correct objId\");\n  }\n});",
    "i4_gpt-4o": "it(\"should add dependency with objId for cached paintImageXObject\", async () => {\n  const idFactory = createIdFactory();\n  const xref = new XRefMock();\n  const handler = { sendWithPromise: () => Promise.resolve(null) };\n  const options = {\n    maxImageSize: 1000,\n    isOffscreenCanvasSupported: false,\n    canvasMaxAreaInBytes: -1,\n    ignoreErrors: true,\n  };\n  const globalImageCache = {\n    shouldCache: () => false,\n    hasDecodeFailed: () => false,\n    setData() {},\n    addByteSize() {}\n  };\n  const partialEvaluator = new PartialEvaluator({\n    xref,\n    handler,\n    pageIndex: 0,\n    idFactory,\n    fontCache: {},\n    builtInCMapCache: {},\n    standardFontDataCache: {},\n    globalImageCache,\n    systemFontCache: {},\n    options,\n  });\n  // Stub _sendImgData so that buildPaintImageXObject can complete.\n  partialEvaluator._sendImgData = () => Promise.resolve();\n  // Create a dummy dictionary with required keys.\n  const dummyDict = new (await import(\"../../src/core/primitives.js\")).Dict();\n  dummyDict.set(\"W\", 10);\n  dummyDict.set(\"H\", 10);\n  // Set a fake objId to simulate an image reference.\n  dummyDict.objId = \"testImgRef\";\n  // Create a minimal dummy image with getBytes.\n  const dummyImage = {\n    dict: dummyDict,\n    getBytes: (n) => new Uint8Array(n),\n  };\n  // Override PDFImage.buildImage to simulate successful image decoding.\n  const { PDFImage } = await import(\"../../src/core/image.js\");\n  PDFImage.buildImage = (params) => {\n    return Promise.resolve({\n      createImageData: () =>\n        Promise.resolve({\n          width: params.image.dict.get(\"W\"),\n          height: params.image.dict.get(\"H\"),\n          data: new Uint8Array(4 * params.image.dict.get(\"W\") * params.image.dict.get(\"H\")),\n          bitmap: false,\n        }),\n    });\n  };\n  // Create a minimal operator list that records dependencies.\n  const operatorList = new OperatorList();\n  const originalAddDependency = operatorList.addDependency.bind(operatorList);\n  operatorList.dependencies = [];\n  operatorList.addDependency = (dep) => {\n    operatorList.dependencies.push(dep);\n    originalAddDependency(dep);\n  };\n  // Setup a simple localImageCache.\n  const localImageCache = {\n    _cache: {},\n    set(key, ref, data) {\n      this._cache[key] = data;\n    },\n    getByName(name) {\n      return this._cache[name];\n    }\n  };\n  const localColorSpaceCache = {};\n  const cacheKey = \"testCache\";\n  await partialEvaluator.buildPaintImageXObject({\n    resources: new (await import(\"../../src/core/primitives.js\")).Dict(),\n    image: dummyImage,\n    isInline: false,\n    operatorList,\n    cacheKey,\n    localImageCache,\n    localColorSpaceCache,\n  });\n  const cacheData = localImageCache._cache[cacheKey];\n  if (!cacheData || !cacheData.objId) {\n    throw new Error(\"Missing objId in cache data\");\n  }\n  if (!operatorList.dependencies.includes(cacheData.objId)) {\n    throw new Error(\"Dependency was not added with the correct objId\");\n  }\n});",
    "i4_llama-3.3-70b-versatile": "it(\"should add dependency with objId for cached paintImageXObject\", async () => {\n  const idFactory = createIdFactory();\n  const xref = new XRefMock();\n  const handler = { sendWithPromise: () => Promise.resolve(null) };\n  const options = {\n    maxImageSize: 1000,\n    isOffscreenCanvasSupported: false,\n    canvasMaxAreaInBytes: -1,\n    ignoreErrors: true,\n  };\n  const globalImageCache = {\n    shouldCache: () => false,\n    hasDecodeFailed: () => false,\n    setData() {},\n    addByteSize() {}\n  };\n  const partialEvaluator = new PartialEvaluator({\n    xref,\n    handler,\n    pageIndex: 0,\n    idFactory,\n    fontCache: {},\n    builtInCMapCache: {},\n    standardFontDataCache: {},\n    globalImageCache,\n    systemFontCache: {},\n    options,\n  });\n  // Stub _sendImgData so that buildPaintImageXObject can complete.\n  partialEvaluator._sendImgData = () => Promise.resolve();\n  // Create a dummy dictionary with required keys.\n  const dummyDict = new (await import(\"../../src/core/primitives.js\")).Dict();\n  dummyDict.set(\"W\", 10);\n  dummyDict.set(\"H\", 10);\n  // Set a fake objId to simulate an image reference.\n  dummyDict.objId = \"testImgRef\";\n  // Create a minimal dummy image with getBytes.\n  const dummyImage = {\n    dict: dummyDict,\n    getBytes: (n) => new Uint8Array(n),\n  };\n  // Override PDFImage.buildImage to simulate successful image decoding.\n  const { PDFImage } = await import(\"../../src/core/image.js\");\n  PDFImage.buildImage = (params) => {\n    return Promise.resolve({\n      createImageData: () =>\n        Promise.resolve({\n          width: params.image.dict.get(\"W\"),\n          height: params.image.dict.get(\"H\"),\n          data: new Uint8Array(4 * params.image.dict.get(\"W\") * params.image.dict.get(\"H\")),\n          bitmap: false,\n        }),\n    });\n  };\n  // Create a minimal operator list that records dependencies.\n  const operatorList = new OperatorList();\n  const originalAddDependency = operatorList.addDependency.bind(operatorList);\n  operatorList.dependencies = [];\n  operatorList.addDependency = (dep) => {\n    operatorList.dependencies.push(dep);\n    originalAddDependency(dep);\n  };\n  // Setup a simple localImageCache.\n  const localImageCache = {\n    _cache: {},\n    set(key, ref, data) {\n      this._cache[key] = data;\n    },\n    getByName(name) {\n      return this._cache[name];\n    }\n  };\n  const localColorSpaceCache = {};\n  const cacheKey = \"testCache\";\n  await partialEvaluator.buildPaintImageXObject({\n    resources: new (await import(\"../../src/core/primitives.js\")).Dict(),\n    image: dummyImage,\n    isInline: false,\n    operatorList,\n    cacheKey,\n    localImageCache,\n    localColorSpaceCache,\n  });\n  const cacheData = localImageCache._cache[cacheKey];\n  if (!cacheData || !cacheData.objId) {\n    throw new Error(\"Missing objId in cache data\");\n  }\n  if (!operatorList.dependencies.includes(cacheData.objId)) {\n    throw new Error(\"Dependency was not added with the correct objId\");\n  }\n});",
    "i5_deepseek-r1-distill-llama-70b": "it(\"should add dependency with objId for cached paintImageXObject\", async () => {\n  const idFactory = createIdFactory();\n  const xref = new XRefMock();\n  const handler = { sendWithPromise: () => Promise.resolve(null) };\n  const options = {\n    maxImageSize: 1000,\n    isOffscreenCanvasSupported: false,\n    canvasMaxAreaInBytes: -1,\n    ignoreErrors: true,\n  };\n  const globalImageCache = {\n    shouldCache: () => false,\n    hasDecodeFailed: () => false,\n    setData() {},\n    addByteSize() {}\n  };\n  const partialEvaluator = new PartialEvaluator({\n    xref,\n    handler,\n    pageIndex: 0,\n    idFactory,\n    fontCache: {},\n    builtInCMapCache: {},\n    standardFontDataCache: {},\n    globalImageCache,\n    systemFontCache: {},\n    options,\n  });\n  // Stub _sendImgData so that buildPaintImageXObject can complete.\n  partialEvaluator._sendImgData = () => Promise.resolve();\n  // Create a dummy dictionary with required keys.\n  const dummyDict = new (await import(\"../../src/core/primitives.js\")).Dict();\n  dummyDict.set(\"W\", 10);\n  dummyDict.set(\"H\", 10);\n  // Set a fake objId to simulate an image reference.\n  dummyDict.objId = \"testImgRef\";\n  // Create a minimal dummy image with getBytes.\n  const dummyImage = {\n    dict: dummyDict,\n    getBytes: (n) => new Uint8Array(n),\n  };\n  // Override PDFImage.buildImage to simulate successful image decoding.\n  const { PDFImage } = await import(\"../../src/core/image.js\");\n  PDFImage.buildImage = (params) => {\n    return Promise.resolve({\n      createImageData: () =>\n        Promise.resolve({\n          width: params.image.dict.get(\"W\"),\n          height: params.image.dict.get(\"H\"),\n          data: new Uint8Array(4 * params.image.dict.get(\"W\") * params.image.dict.get(\"H\")),\n          bitmap: false,\n        }),\n    });\n  };\n  // Create a minimal operator list that records dependencies.\n  const operatorList = new OperatorList();\n  const originalAddDependency = operatorList.addDependency.bind(operatorList);\n  operatorList.dependencies = [];\n  operatorList.addDependency = (dep) => {\n    operatorList.dependencies.push(dep);\n    originalAddDependency(dep);\n  };\n  // Setup a simple localImageCache.\n  const localImageCache = {\n    _cache: {},\n    set(key, ref, data) {\n      this._cache[key] = data;\n    },\n    getByName(name) {\n      return this._cache[name];\n    }\n  };\n  const localColorSpaceCache = {};\n  const cacheKey = \"testCache\";\n  await partialEvaluator.buildPaintImageXObject({\n    resources: new (await import(\"../../src/core/primitives.js\")).Dict(),\n    image: dummyImage,\n    isInline: false,\n    operatorList,\n    cacheKey,\n    localImageCache,\n    localColorSpaceCache,\n  });\n  const cacheData = localImageCache._cache[cacheKey];\n  if (!cacheData || !cacheData.objId) {\n    throw new Error(\"Missing objId in cache data\");\n  }\n  if (!operatorList.dependencies.includes(cacheData.objId)) {\n    throw new Error(\"Dependency was not added with the correct objId\");\n  }\n});",
    "i5_gpt-4o": "it(\"should add dependency with objId for cached paintImageXObject\", async () => {\n  const idFactory = createIdFactory();\n  const xref = new XRefMock();\n  const handler = { sendWithPromise: () => Promise.resolve(null) };\n  const options = {\n    maxImageSize: 1000,\n    isOffscreenCanvasSupported: false,\n    canvasMaxAreaInBytes: -1,\n    ignoreErrors: true,\n  };\n  const globalImageCache = {\n    shouldCache: () => false,\n    hasDecodeFailed: () => false,\n    setData() {},\n    addByteSize() {}\n  };\n  const partialEvaluator = new PartialEvaluator({\n    xref,\n    handler,\n    pageIndex: 0,\n    idFactory,\n    fontCache: {},\n    builtInCMapCache: {},\n    standardFontDataCache: {},\n    globalImageCache,\n    systemFontCache: {},\n    options,\n  });\n  // Stub _sendImgData so that buildPaintImageXObject can complete.\n  partialEvaluator._sendImgData = () => Promise.resolve();\n  // Create a dummy dictionary with required keys.\n  const dummyDict = new (await import(\"../../src/core/primitives.js\")).Dict();\n  dummyDict.set(\"W\", 10);\n  dummyDict.set(\"H\", 10);\n  // Set a fake objId to simulate an image reference.\n  dummyDict.objId = \"testImgRef\";\n  // Create a minimal dummy image with getBytes.\n  const dummyImage = {\n    dict: dummyDict,\n    getBytes: (n) => new Uint8Array(n),\n  };\n  // Override PDFImage.buildImage to simulate successful image decoding.\n  const { PDFImage } = await import(\"../../src/core/image.js\");\n  PDFImage.buildImage = (params) => {\n    return Promise.resolve({\n      createImageData: () =>\n        Promise.resolve({\n          width: params.image.dict.get(\"W\"),\n          height: params.image.dict.get(\"H\"),\n          data: new Uint8Array(4 * params.image.dict.get(\"W\") * params.image.dict.get(\"H\")),\n          bitmap: false,\n        }),\n    });\n  };\n  // Create a minimal operator list that records dependencies.\n  const operatorList = new OperatorList();\n  const originalAddDependency = operatorList.addDependency.bind(operatorList);\n  operatorList.dependencies = [];\n  operatorList.addDependency = (dep) => {\n    operatorList.dependencies.push(dep);\n    originalAddDependency(dep);\n  };\n  // Setup a simple localImageCache.\n  const localImageCache = {\n    _cache: {},\n    set(key, ref, data) {\n      this._cache[key] = data;\n    },\n    getByName(name) {\n      return this._cache[name];\n    }\n  };\n  const localColorSpaceCache = {};\n  const cacheKey = \"testCache\";\n  await partialEvaluator.buildPaintImageXObject({\n    resources: new (await import(\"../../src/core/primitives.js\")).Dict(),\n    image: dummyImage,\n    isInline: false,\n    operatorList,\n    cacheKey,\n    localImageCache,\n    localColorSpaceCache,\n  });\n  const cacheData = localImageCache._cache[cacheKey];\n  if (!cacheData || !cacheData.objId) {\n    throw new Error(\"Missing objId in cache data\");\n  }\n  if (!operatorList.dependencies.includes(cacheData.objId)) {\n    throw new Error(\"Dependency was not added with the correct objId\");\n  }\n});",
    "i5_llama-3.3-70b-versatile": "it(\"should add dependency with objId for cached paintImageXObject\", async () => {\n  const idFactory = createIdFactory();\n  const xref = new XRefMock();\n  const handler = { sendWithPromise: () => Promise.resolve(null) };\n  const options = {\n    maxImageSize: 1000,\n    isOffscreenCanvasSupported: false,\n    canvasMaxAreaInBytes: -1,\n    ignoreErrors: true,\n  };\n  const globalImageCache = {\n    shouldCache: () => false,\n    hasDecodeFailed: () => false,\n    setData() {},\n    addByteSize() {}\n  };\n  const partialEvaluator = new PartialEvaluator({\n    xref,\n    handler,\n    pageIndex: 0,\n    idFactory,\n    fontCache: {},\n    builtInCMapCache: {},\n    standardFontDataCache: {},\n    globalImageCache,\n    systemFontCache: {},\n    options,\n  });\n  // Stub _sendImgData so that buildPaintImageXObject can complete.\n  partialEvaluator._sendImgData = () => Promise.resolve();\n  // Create a dummy dictionary with required keys.\n  const dummyDict = new (await import(\"../../src/core/primitives.js\")).Dict();\n  dummyDict.set(\"W\", 10);\n  dummyDict.set(\"H\", 10);\n  // Set a fake objId to simulate an image reference.\n  dummyDict.objId = \"testImgRef\";\n  // Create a minimal dummy image with getBytes.\n  const dummyImage = {\n    dict: dummyDict,\n    getBytes: (n) => new Uint8Array(n),\n  };\n  // Override PDFImage.buildImage to simulate successful image decoding.\n  const { PDFImage } = await import(\"../../src/core/image.js\");\n  PDFImage.buildImage = (params) => {\n    return Promise.resolve({\n      createImageData: () =>\n        Promise.resolve({\n          width: params.image.dict.get(\"W\"),\n          height: params.image.dict.get(\"H\"),\n          data: new Uint8Array(4 * params.image.dict.get(\"W\") * params.image.dict.get(\"H\")),\n          bitmap: false,\n        }),\n    });\n  };\n  // Create a minimal operator list that records dependencies.\n  const operatorList = new OperatorList();\n  const originalAddDependency = operatorList.addDependency.bind(operatorList);\n  operatorList.dependencies = [];\n  operatorList.addDependency = (dep) => {\n    operatorList.dependencies.push(dep);\n    originalAddDependency(dep);\n  };\n  // Setup a simple localImageCache.\n  const localImageCache = {\n    _cache: {},\n    set(key, ref, data) {\n      this._cache[key] = data;\n    },\n    getByName(name) {\n      return this._cache[name];\n    }\n  };\n  const localColorSpaceCache = {};\n  const cacheKey = \"testCache\";\n  await partialEvaluator.buildPaintImageXObject({\n    resources: new (await import(\"../../src/core/primitives.js\")).Dict(),\n    image: dummyImage,\n    isInline: false,\n    operatorList,\n    cacheKey,\n    localImageCache,\n    localColorSpaceCache,\n  });\n  const cacheData = localImageCache._cache[cacheKey];\n  if (!cacheData || !cacheData.objId) {\n    throw new Error(\"Missing objId in cache data\");\n  }\n  if (!operatorList.dependencies.includes(cacheData.objId)) {\n    throw new Error(\"Dependency was not added with the correct objId\");\n  }\n});"
  },
  "18306": {
    "i1_deepseek-r1-distill-llama-70b": "it(\"should correctly render PDF with noninteger DW\", async () => {\n  const { getDocument } = await import(\"../../src/display/api.js\");\n  const { buildGetDocumentParams } = await import(\"./test_utils.js\");\n  const loadingTask = getDocument(buildGetDocumentParams('bug1903731.pdf'));\n\n  try {\n    const { doc, cleanup } = await loadingTask;\n    const page = await doc.getPage(0);\n    const operatorList = await page.getOperatorList();\n\n    const evaluatorOptions = {\n      disableFontFace: true,\n    };\n\n    const evaluator = new PartialEvaluator({\n      xref: page.xref,\n      handler: null,\n      pageIndex: page.index,\n      idFactory: createIdFactory(),\n      fontCache: null,\n      builtInCMapCache: null,\n      standardFontDataCache: null,\n      globalImageCache: null,\n      systemFontCache: null,\n      options: evaluatorOptions,\n    });\n\n    const properties = {\n      composite: true,\n    };\n\n    const dict = new Dict();\n    dict.set(\"Type\", \"/Font\");\n    dict.set(\"Subtype\", \"/Type1\");\n    dict.set(\"BaseFont\", \"Helvetica\");\n\n    evaluator.extractWidths(dict, {}, properties);\n\n    const glyphsWidths = properties.widths;\n\n    expect(glyphsWidths.length).toBeGreaterThan(0);\n\n    await cleanup();\n  } catch (error) {\n    throw new Error(\"Failed to load or process PDF\");\n  }\n});",
    "i1_llama-3.3-70b-versatile": "it(\"should render PDF with noninteger DW correctly\", async () => {\n  const { getDocument } = await import('../../src/display/api.js');\n  const { buildGetDocumentParams } = await import('./test_utils.js');\n  const loadingTask = getDocument(buildGetDocumentParams('bug1903731.pdf'));\n  const pdfDocument = await loadingTask.promise;\n  const pdfPage = await pdfDocument.getPage(1);\n  const renderTask = pdfPage.render({\n    viewport: pdfPage.getViewport({ scale: 1 }),\n    intent: 'display',\n  });\n  const renderResult = await renderTask.promise;\n  expect(renderResult instanceof Object).toBe(true);\n});",
    "i2_deepseek-r1-distill-llama-70b": "it(\"should correctly handle noninteger DW values in font descriptors\", async () => {\n  const { getDocument } = await import(\"../../src/display/api.js\");\n  const { buildGetDocumentParams } = await import(\"./test_utils.js\");\n  const loadingTask = getDocument(buildGetDocumentParams('bug1903731.pdf'));\n\n  const { pdfDocument } = await loadingTask;\n  const page = await pdfDocument.getPage(1);\n  const font = await page.getFont();\n  const defaultWidth = font.properties.defaultWidth;\n\n  expect(defaultWidth).toBe(501);\n});",
    "i2_gpt-4o": "it(\"should render PDF with noninteger DW correctly\", async () => {\n  const { getDocument } = await import('../../src/display/api.js');\n  const { buildGetDocumentParams } = await import('./test_utils.js');\n  const loadingTask = getDocument(buildGetDocumentParams('bug1903731.pdf'));\n  const pdfDocument = await loadingTask.promise;\n  const page = await pdfDocument.getPage(1);\n  const operatorList = await page.getOperatorList();\n  const textOperators = operatorList.fnArray.filter(fn => fn === 92); // 92 is the text operator\n  expect(textOperators.length).toBeGreaterThan(0);\n});",
    "i2_llama-3.3-70b-versatile": "it(\"should render PDF with noninteger DW correctly\", async () => {\n  const { getDocument } = await import('../../src/display/api.js');\n  const { buildGetDocumentParams } = await import('./test_utils.js');\n  const loadingTask = getDocument(buildGetDocumentParams('bug1903731.pdf'));\n  const pdfDocument = await loadingTask.promise;\n  const pdfPage = await pdfDocument.getPage(1);\n  const renderTask = pdfPage.render({\n    viewport: pdfPage.getViewport({ scale: 1 }),\n    intent: 'display',\n  });\n  const renderedPage = await renderTask.promise;\n  const expectedRenderedPage = true;\n  expect(renderedPage).toBeDefined();\n});",
    "i3_deepseek-r1-distill-llama-70b": "it(\"should handle noninteger DW in PDFs\", async () => {\n  const { getDocument } = await import('../../src/display/api.js');\n  const { buildGetDocumentParams } = await import('./test_utils.js');\n\n  const loadingTask = getDocument(buildGetDocumentParams('bug1903731.pdf'));\n  const document = await loadingTask.promise;\n  const page = await document.getPage(1);\n\n  const evaluatorOptions = {\n    maxImageSize: -1,\n    disableFontFace: false,\n    ignoreErrors: false,\n  };\n\n  const partialEvaluator = new PartialEvaluator({\n    xref: new XRefMock(),\n    handler: {},\n    pageIndex: 1,\n    idFactory: createIdFactory(),\n    fontCache: new Map(),\n    builtInCMapCache: new Map(),\n    standardFontDataCache: new Map(),\n    globalImageCache: new Map(),\n    systemFontCache: new Map(),\n    options: evaluatorOptions,\n  });\n\n  await expect(page.render([{ evaluator: partialEvaluator }])).resolves.not.toThrow();\n});",
    "i3_gpt-4o": "it(\"should render PDF with noninteger DW correctly\", async () => {\n  const { getDocument } = await import(\"../../src/display/api.js\");\n  const { buildGetDocumentParams } = await import(\"./test_utils.js\");\n\n  const loadingTask = getDocument(buildGetDocumentParams(\"bug1903731.pdf\"));\n  const pdfDocument = await loadingTask.promise;\n  const page = await pdfDocument.getPage(1);\n\n  const operatorList = await page.getOperatorList();\n  const hasCorrectDefaultWidth = operatorList.argsArray.some(\n    args => args[0] === OPS.setFont && args[1] === 1000\n  );\n\n  expect(hasCorrectDefaultWidth).toBe(true);\n});",
    "i4_deepseek-r1-distill-llama-70b": "it(\"should render PDF with noninteger DW correctly\", async () => {\n  const { getDocument } = await import(\"../../src/display/api.js\");\n  const { buildGetDocumentParams } = await import(\"./test_utils.js\");\n  const loadingTask = getDocument(buildGetDocumentParams('bug1903731.pdf'));\n\n  async function hasText(page) {\n    const { PartialEvaluator } = await import(\"../../src/core/evaluator.js\");\n    const textContent = await page.getTextContent({\n      textsEl: page.textLayer,\n      normalizeWhitespace: true\n    });\n    return textContent.items.some(item => item.str.length > 0);\n  }\n\n  const { numPages, getPage } = await loadingTask;\n  const page = await getPage(1);\n  const textLayer = page.textLayer;\n  await textLayer.setup(textLayer);\n  const hasPageText = await hasText(page);\n\n  expect(hasPageText).toBe(true);\n});",
    "i4_gpt-4o": "it(\"should render PDF with noninteger DW correctly\", async () => {\n  const { getDocument } = await import(\"../../src/display/api.js\");\n  const { buildGetDocumentParams } = await import(\"./test_utils.js\");\n  const loadingTask = getDocument(buildGetDocumentParams(\"bug1903731.pdf\"));\n  const pdfDocument = await loadingTask.promise;\n  const pdfPage = await pdfDocument.getPage(1);\n  const operatorList = await pdfPage.getOperatorList();\n  const hasValidOperator = operatorList.fnArray.includes(OPS.paintImageXObject);\n  expect(hasValidOperator).toBe(true);\n});",
    "i4_llama-3.3-70b-versatile": "it(\"should render PDF with noninteger DW correctly\", async () => {\n  const { getDocument } = await import('../../src/display/api.js');\n  const { buildGetDocumentParams } = await import('./test_utils.js');\n  const loadingTask = getDocument(buildGetDocumentParams('bug1903731.pdf'));\n  const pdfDocument = await loadingTask.promise;\n  const pdfPage = await pdfDocument.getPage(1);\n  const operatorList = await pdfPage.getOperatorList();\n  const renderTask = pdfPage.render({\n    viewport: pdfPage.getViewport({ scale: 1 }),\n    intent: 'display',\n  });\n  await renderTask.promise;\n  const expectedError = false;\n  const actualError = renderTask.error;\n  expect(actualError).toBe(expectedError);\n});",
    "i5_deepseek-r1-distill-llama-70b": "it(\"should render PDF with noninteger DW correctly\", async () => {\n  const { getDocument } = await import('../../src/display/api.js');\n  const { buildGetDocumentParams } = await import('./test_utils.js');\n\n  const loadingTask = getDocument(buildGetDocumentParams('bug1903731.pdf'));\n  const { numPages, getPage } = await loadingTask;\n  const page = await getPage(1);\n  const viewport = page.getViewPort({ scale: 1 });\n\n  expect(viewport.width).toBeGreaterThanOrEqual(1000);\n});",
    "i5_gpt-4o": "it(\"should render PDF with noninteger DW correctly\", async () => {\n  const { getDocument } = await import('../../src/display/api.js');\n  const { buildGetDocumentParams } = await import('./test_utils.js');\n  const loadingTask = getDocument(buildGetDocumentParams('bug1903731.pdf'));\n  const pdfDocument = await loadingTask.promise;\n  const page = await pdfDocument.getPage(1);\n  const viewport = page.getViewport({ scale: 1.0 });\n  const canvasFactory = new (await import('../../src/display/display_utils.js')).DOMCanvasFactory();\n  const canvasAndContext = canvasFactory.create(viewport.width, viewport.height);\n  const renderTask = page.render({\n    canvasContext: canvasAndContext.context,\n    viewport: viewport,\n  });\n  await renderTask.promise;\n  const pixelData = canvasAndContext.context.getImageData(0, 0, viewport.width, viewport.height).data;\n  const nonEmptyPixels = pixelData.some(value => value !== 0);\n  expect(nonEmptyPixels).toBe(true);\n});",
    "i5_llama-3.3-70b-versatile": "it(\"should render PDF with noninteger DW correctly\", async () => {\n  const { getDocument } = await import('../../src/display/api.js');\n  const { buildGetDocumentParams } = await import('./test_utils.js');\n  const loadingTask = getDocument(buildGetDocumentParams('bug1903731.pdf'));\n  const pdfDocument = await loadingTask.promise;\n  const pdfPage = await pdfDocument.getPage(1);\n  const renderTask = pdfPage.render({\n    viewport: pdfPage.getViewport({ scale: 1 }),\n    canvasContext: null,\n    renderInteractive: false,\n    disableWebGL: true,\n  });\n  const renderedPage = await renderTask.promise;\n  const expectedWidth = 1000;\n  const actualWidth = renderedPage.width;\n  expect(actualWidth).toBeGreaterThan(0);\n  const { PartialEvaluator } = await import('../../src/core/evaluator.js');\n  const evaluator = new PartialEvaluator();\n  const dict = pdfPage.getAnnotations()[0].getDict();\n  const dw = dict.get(\"DW\");\n  const defaultWidth = typeof dw === \"number\" ? Math.ceil(dw) : 1000;\n  expect(defaultWidth).toBeGreaterThan(0);\n});"
  },
  "18369": {
    "i3_llama-3.3-70b-versatile": "it(\"should render Japanese vertical punctuation correctly\", async () => {\n  const { getDocument } = await import('../../src/display/api.js');\n  const { buildGetDocumentParams } = await import('./test_utils.js');\n  const loadingTask = getDocument(buildGetDocumentParams('bug1905623.pdf'));\n  const pdfDocument = await loadingTask.promise;\n  const pdfPage = await pdfDocument.getPage(1);\n  const viewport = new PageViewport({ width: 1000, height: 1000 });\n  const renderTask = pdfPage.render({ viewport, });\n  const renderedPage = await renderTask.promise;\n  const textContent = await pdfPage.getTextContent();\n  const expectedText = \"expected text with correct Japanese vertical punctuation\";\n  expect(textContent.items[0].str).toBe(expectedText);\n});",
    "i4_gpt-4o": "it(\"should render Japanese vertical punctuation correctly in Firefox\", async () => {\n  const { getDocument } = await import('../../src/display/api.js');\n  const { buildGetDocumentParams } = await import('./test_utils.js');\n  const loadingTask = getDocument(buildGetDocumentParams('bug1905623.pdf'));\n  const pdfDocument = await loadingTask.promise;\n  const page = await pdfDocument.getPage(1);\n  const viewport = page.getViewport({ scale: 1.0 });\n  const canvasFactory = new (await import('../../src/display/display_utils.js')).DOMCanvasFactory();\n  const canvasAndContext = canvasFactory.create(viewport.width, viewport.height);\n  const renderTask = page.render({\n    canvasContext: canvasAndContext.context,\n    viewport: viewport,\n  });\n  await renderTask.promise;\n  const imageData = canvasAndContext.context.getImageData(0, 0, viewport.width, viewport.height);\n  const hasVerticalPunctuation = (data) => {\n    // Check for specific pixel patterns that indicate correct rendering of vertical punctuation\n    // This is a placeholder for actual image data analysis logic\n    return data.data.some((value, index) => index % 4 === 0 && value > 200);\n  };\n  const result = hasVerticalPunctuation(imageData);\n  expect(result).toBe(true);\n});",
    "i5_deepseek-r1-distill-llama-70b": "it(\"should render vertical Japanese punctuation correctly in PDFs\", async () => {\n  const { getDocument } = await import('../../src/display/api.js');\n  const { buildGetDocumentParams } = await import('./test_utils.js');\n  const loadingTask = getDocument(buildGetDocumentParams('bug1905623.pdf'));\n\n  const { pdfDocument } = await loadingTask;\n  const page = await pdfDocument.getPage(1);\n  const textContent = await page.getTextContent();\n\n  const expectedVerticalPunctuation = String.fromCharCode(0xfe11);\n  expect(textContent.items[0].str).toContain(expectedVerticalPunctuation);\n});"
  },
  "18412": {
    "i1_deepseek-r1-distill-llama-70b": "it(\"should update glyph width and unicode when glyphName is empty for missing file Type1 fonts\", async () => {\n  const { Font } = await import(\"../../src/core/fonts.js\");\n  const properties = {\n    loadedName: \"TestFont\",\n    isType3Font: false,\n    cssFontInfo: {},\n    flags: 0,\n    differences: { 65: \"\" },\n    defaultEncoding: { 65: \"\" },\n    widths: { \"space\": 250 },\n    defaultWidth: 100,\n    composite: false,\n    cMap: { contains: () => false },\n    capHeight: 700,\n    ascent: 800,\n    descent: -200,\n    fontMatrix: [1, 0, 0, 1, 0, 0],\n    bbox: [0, 0, 1000, 1000],\n    toUnicode: { get: () => undefined },\n    cidEncoding: \"\",\n    vertical: false,\n    systemFontInfo: {},\n    // Set type so that the condition glyphName === \"\" && type===\"Type1\" holds.\n    type: \"Type1\",\n    subtype: \"Type1\"\n  };\n  const file = { isEmpty: false };\n  const font = new Font(\"TestFont\", file, properties);\n  font.missingFile = true;\n  const glyph = font._charToGlyph(65, false);\n  if (glyph.width !== 250 || glyph.unicode !== \" \") {\n    throw new Error(`Expected glyph with width 250 and unicode \" \", got width=${glyph.width} and unicode=\"${glyph.unicode}\"`);\n  }\n});",
    "i1_gpt-4o": "it(\"should update glyph width and unicode when glyphName is empty for missing file Type1 fonts\", async () => {\n  const { Font } = await import(\"../../src/core/fonts.js\");\n  const properties = {\n    loadedName: \"TestFont\",\n    isType3Font: false,\n    cssFontInfo: {},\n    flags: 0,\n    differences: { 65: \"\" },\n    defaultEncoding: { 65: \"\" },\n    widths: { \"space\": 250 },\n    defaultWidth: 100,\n    composite: false,\n    cMap: { contains: () => false },\n    capHeight: 700,\n    ascent: 800,\n    descent: -200,\n    fontMatrix: [1, 0, 0, 1, 0, 0],\n    bbox: [0, 0, 1000, 1000],\n    toUnicode: { get: () => undefined },\n    cidEncoding: \"\",\n    vertical: false,\n    systemFontInfo: {},\n    // Set type so that the condition glyphName === \"\" && type===\"Type1\" holds.\n    type: \"Type1\",\n    subtype: \"Type1\"\n  };\n  const file = { isEmpty: false };\n  const font = new Font(\"TestFont\", file, properties);\n  font.missingFile = true;\n  const glyph = font._charToGlyph(65, false);\n  if (glyph.width !== 250 || glyph.unicode !== \" \") {\n    throw new Error(`Expected glyph with width 250 and unicode \" \", got width=${glyph.width} and unicode=\"${glyph.unicode}\"`);\n  }\n});",
    "i1_llama-3.3-70b-versatile": "it(\"should update glyph width and unicode when glyphName is empty for missing file Type1 fonts\", async () => {\n  const { Font } = await import(\"../../src/core/fonts.js\");\n  const properties = {\n    loadedName: \"TestFont\",\n    isType3Font: false,\n    cssFontInfo: {},\n    flags: 0,\n    differences: { 65: \"\" },\n    defaultEncoding: { 65: \"\" },\n    widths: { \"space\": 250 },\n    defaultWidth: 100,\n    composite: false,\n    cMap: { contains: () => false },\n    capHeight: 700,\n    ascent: 800,\n    descent: -200,\n    fontMatrix: [1, 0, 0, 1, 0, 0],\n    bbox: [0, 0, 1000, 1000],\n    toUnicode: { get: () => undefined },\n    cidEncoding: \"\",\n    vertical: false,\n    systemFontInfo: {},\n    // Set type so that the condition glyphName === \"\" && type===\"Type1\" holds.\n    type: \"Type1\",\n    subtype: \"Type1\"\n  };\n  const file = { isEmpty: false };\n  const font = new Font(\"TestFont\", file, properties);\n  font.missingFile = true;\n  const glyph = font._charToGlyph(65, false);\n  if (glyph.width !== 250 || glyph.unicode !== \" \") {\n    throw new Error(`Expected glyph with width 250 and unicode \" \", got width=${glyph.width} and unicode=\"${glyph.unicode}\"`);\n  }\n});",
    "i1_MOCK": "it(\"should update glyph width and unicode when glyphName is empty for missing file Type1 fonts\", async () => {\n  const { Font } = await import(\"../../src/core/fonts.js\");\n  const properties = {\n    loadedName: \"TestFont\",\n    isType3Font: false,\n    cssFontInfo: {},\n    flags: 0,\n    differences: { 65: \"\" },\n    defaultEncoding: { 65: \"\" },\n    widths: { \"space\": 250 },\n    defaultWidth: 100,\n    composite: false,\n    cMap: { contains: () => false },\n    capHeight: 700,\n    ascent: 800,\n    descent: -200,\n    fontMatrix: [1, 0, 0, 1, 0, 0],\n    bbox: [0, 0, 1000, 1000],\n    toUnicode: { get: () => undefined },\n    cidEncoding: \"\",\n    vertical: false,\n    systemFontInfo: {},\n    // Set type so that the condition glyphName === \"\" && type===\"Type1\" holds.\n    type: \"Type1\",\n    subtype: \"Type1\"\n  };\n  const file = { isEmpty: false };\n  const font = new Font(\"TestFont\", file, properties);\n  font.missingFile = true;\n  const glyph = font._charToGlyph(65, false);\n  if (glyph.width !== 250 || glyph.unicode !== \" \") {\n    throw new Error(`Expected glyph with width 250 and unicode \" \", got width=${glyph.width} and unicode=\"${glyph.unicode}\"`);\n  }\n});",
    "i2_deepseek-r1-distill-llama-70b": "it(\"should update glyph width and unicode when glyphName is empty for missing file Type1 fonts\", async () => {\n  const { Font } = await import(\"../../src/core/fonts.js\");\n  const properties = {\n    loadedName: \"TestFont\",\n    isType3Font: false,\n    cssFontInfo: {},\n    flags: 0,\n    differences: { 65: \"\" },\n    defaultEncoding: { 65: \"\" },\n    widths: { \"space\": 250 },\n    defaultWidth: 100,\n    composite: false,\n    cMap: { contains: () => false },\n    capHeight: 700,\n    ascent: 800,\n    descent: -200,\n    fontMatrix: [1, 0, 0, 1, 0, 0],\n    bbox: [0, 0, 1000, 1000],\n    toUnicode: { get: () => undefined },\n    cidEncoding: \"\",\n    vertical: false,\n    systemFontInfo: {},\n    // Set type so that the condition glyphName === \"\" && type===\"Type1\" holds.\n    type: \"Type1\",\n    subtype: \"Type1\"\n  };\n  const file = { isEmpty: false };\n  const font = new Font(\"TestFont\", file, properties);\n  font.missingFile = true;\n  const glyph = font._charToGlyph(65, false);\n  if (glyph.width !== 250 || glyph.unicode !== \" \") {\n    throw new Error(`Expected glyph with width 250 and unicode \" \", got width=${glyph.width} and unicode=\"${glyph.unicode}\"`);\n  }\n});",
    "i2_gpt-4o": "it(\"should update glyph width and unicode when glyphName is empty for missing file Type1 fonts\", async () => {\n  const { Font } = await import(\"../../src/core/fonts.js\");\n  const properties = {\n    loadedName: \"TestFont\",\n    isType3Font: false,\n    cssFontInfo: {},\n    flags: 0,\n    differences: { 65: \"\" },\n    defaultEncoding: { 65: \"\" },\n    widths: { \"space\": 250 },\n    defaultWidth: 100,\n    composite: false,\n    cMap: { contains: () => false },\n    capHeight: 700,\n    ascent: 800,\n    descent: -200,\n    fontMatrix: [1, 0, 0, 1, 0, 0],\n    bbox: [0, 0, 1000, 1000],\n    toUnicode: { get: () => undefined },\n    cidEncoding: \"\",\n    vertical: false,\n    systemFontInfo: {},\n    // Set type so that the condition glyphName === \"\" && type===\"Type1\" holds.\n    type: \"Type1\",\n    subtype: \"Type1\"\n  };\n  const file = { isEmpty: false };\n  const font = new Font(\"TestFont\", file, properties);\n  font.missingFile = true;\n  const glyph = font._charToGlyph(65, false);\n  if (glyph.width !== 250 || glyph.unicode !== \" \") {\n    throw new Error(`Expected glyph with width 250 and unicode \" \", got width=${glyph.width} and unicode=\"${glyph.unicode}\"`);\n  }\n});",
    "i2_llama-3.3-70b-versatile": "it(\"should update glyph width and unicode when glyphName is empty for missing file Type1 fonts\", async () => {\n  const { Font } = await import(\"../../src/core/fonts.js\");\n  const properties = {\n    loadedName: \"TestFont\",\n    isType3Font: false,\n    cssFontInfo: {},\n    flags: 0,\n    differences: { 65: \"\" },\n    defaultEncoding: { 65: \"\" },\n    widths: { \"space\": 250 },\n    defaultWidth: 100,\n    composite: false,\n    cMap: { contains: () => false },\n    capHeight: 700,\n    ascent: 800,\n    descent: -200,\n    fontMatrix: [1, 0, 0, 1, 0, 0],\n    bbox: [0, 0, 1000, 1000],\n    toUnicode: { get: () => undefined },\n    cidEncoding: \"\",\n    vertical: false,\n    systemFontInfo: {},\n    // Set type so that the condition glyphName === \"\" && type===\"Type1\" holds.\n    type: \"Type1\",\n    subtype: \"Type1\"\n  };\n  const file = { isEmpty: false };\n  const font = new Font(\"TestFont\", file, properties);\n  font.missingFile = true;\n  const glyph = font._charToGlyph(65, false);\n  if (glyph.width !== 250 || glyph.unicode !== \" \") {\n    throw new Error(`Expected glyph with width 250 and unicode \" \", got width=${glyph.width} and unicode=\"${glyph.unicode}\"`);\n  }\n});",
    "i3_deepseek-r1-distill-llama-70b": "it(\"should update glyph width and unicode when glyphName is empty for missing file Type1 fonts\", async () => {\n  const { Font } = await import(\"../../src/core/fonts.js\");\n  const properties = {\n    loadedName: \"TestFont\",\n    isType3Font: false,\n    cssFontInfo: {},\n    flags: 0,\n    differences: { 65: \"\" },\n    defaultEncoding: { 65: \"\" },\n    widths: { \"space\": 250 },\n    defaultWidth: 100,\n    composite: false,\n    cMap: { contains: () => false },\n    capHeight: 700,\n    ascent: 800,\n    descent: -200,\n    fontMatrix: [1, 0, 0, 1, 0, 0],\n    bbox: [0, 0, 1000, 1000],\n    toUnicode: { get: () => undefined },\n    cidEncoding: \"\",\n    vertical: false,\n    systemFontInfo: {},\n    // Set type so that the condition glyphName === \"\" && type===\"Type1\" holds.\n    type: \"Type1\",\n    subtype: \"Type1\"\n  };\n  const file = { isEmpty: false };\n  const font = new Font(\"TestFont\", file, properties);\n  font.missingFile = true;\n  const glyph = font._charToGlyph(65, false);\n  if (glyph.width !== 250 || glyph.unicode !== \" \") {\n    throw new Error(`Expected glyph with width 250 and unicode \" \", got width=${glyph.width} and unicode=\"${glyph.unicode}\"`);\n  }\n});",
    "i3_gpt-4o": "it(\"should update glyph width and unicode when glyphName is empty for missing file Type1 fonts\", async () => {\n  const { Font } = await import(\"../../src/core/fonts.js\");\n  const properties = {\n    loadedName: \"TestFont\",\n    isType3Font: false,\n    cssFontInfo: {},\n    flags: 0,\n    differences: { 65: \"\" },\n    defaultEncoding: { 65: \"\" },\n    widths: { \"space\": 250 },\n    defaultWidth: 100,\n    composite: false,\n    cMap: { contains: () => false },\n    capHeight: 700,\n    ascent: 800,\n    descent: -200,\n    fontMatrix: [1, 0, 0, 1, 0, 0],\n    bbox: [0, 0, 1000, 1000],\n    toUnicode: { get: () => undefined },\n    cidEncoding: \"\",\n    vertical: false,\n    systemFontInfo: {},\n    // Set type so that the condition glyphName === \"\" && type===\"Type1\" holds.\n    type: \"Type1\",\n    subtype: \"Type1\"\n  };\n  const file = { isEmpty: false };\n  const font = new Font(\"TestFont\", file, properties);\n  font.missingFile = true;\n  const glyph = font._charToGlyph(65, false);\n  if (glyph.width !== 250 || glyph.unicode !== \" \") {\n    throw new Error(`Expected glyph with width 250 and unicode \" \", got width=${glyph.width} and unicode=\"${glyph.unicode}\"`);\n  }\n});",
    "i3_llama-3.3-70b-versatile": "it(\"should update glyph width and unicode when glyphName is empty for missing file Type1 fonts\", async () => {\n  const { Font } = await import(\"../../src/core/fonts.js\");\n  const properties = {\n    loadedName: \"TestFont\",\n    isType3Font: false,\n    cssFontInfo: {},\n    flags: 0,\n    differences: { 65: \"\" },\n    defaultEncoding: { 65: \"\" },\n    widths: { \"space\": 250 },\n    defaultWidth: 100,\n    composite: false,\n    cMap: { contains: () => false },\n    capHeight: 700,\n    ascent: 800,\n    descent: -200,\n    fontMatrix: [1, 0, 0, 1, 0, 0],\n    bbox: [0, 0, 1000, 1000],\n    toUnicode: { get: () => undefined },\n    cidEncoding: \"\",\n    vertical: false,\n    systemFontInfo: {},\n    // Set type so that the condition glyphName === \"\" && type===\"Type1\" holds.\n    type: \"Type1\",\n    subtype: \"Type1\"\n  };\n  const file = { isEmpty: false };\n  const font = new Font(\"TestFont\", file, properties);\n  font.missingFile = true;\n  const glyph = font._charToGlyph(65, false);\n  if (glyph.width !== 250 || glyph.unicode !== \" \") {\n    throw new Error(`Expected glyph with width 250 and unicode \" \", got width=${glyph.width} and unicode=\"${glyph.unicode}\"`);\n  }\n});",
    "i4_deepseek-r1-distill-llama-70b": "it(\"should update glyph width and unicode when glyphName is empty for missing file Type1 fonts\", async () => {\n  const { Font } = await import(\"../../src/core/fonts.js\");\n  const properties = {\n    loadedName: \"TestFont\",\n    isType3Font: false,\n    cssFontInfo: {},\n    flags: 0,\n    differences: { 65: \"\" },\n    defaultEncoding: { 65: \"\" },\n    widths: { \"space\": 250 },\n    defaultWidth: 100,\n    composite: false,\n    cMap: { contains: () => false },\n    capHeight: 700,\n    ascent: 800,\n    descent: -200,\n    fontMatrix: [1, 0, 0, 1, 0, 0],\n    bbox: [0, 0, 1000, 1000],\n    toUnicode: { get: () => undefined },\n    cidEncoding: \"\",\n    vertical: false,\n    systemFontInfo: {},\n    // Set type so that the condition glyphName === \"\" && type===\"Type1\" holds.\n    type: \"Type1\",\n    subtype: \"Type1\"\n  };\n  const file = { isEmpty: false };\n  const font = new Font(\"TestFont\", file, properties);\n  font.missingFile = true;\n  const glyph = font._charToGlyph(65, false);\n  if (glyph.width !== 250 || glyph.unicode !== \" \") {\n    throw new Error(`Expected glyph with width 250 and unicode \" \", got width=${glyph.width} and unicode=\"${glyph.unicode}\"`);\n  }\n});",
    "i4_gpt-4o": "it(\"should update glyph width and unicode when glyphName is empty for missing file Type1 fonts\", async () => {\n  const { Font } = await import(\"../../src/core/fonts.js\");\n  const properties = {\n    loadedName: \"TestFont\",\n    isType3Font: false,\n    cssFontInfo: {},\n    flags: 0,\n    differences: { 65: \"\" },\n    defaultEncoding: { 65: \"\" },\n    widths: { \"space\": 250 },\n    defaultWidth: 100,\n    composite: false,\n    cMap: { contains: () => false },\n    capHeight: 700,\n    ascent: 800,\n    descent: -200,\n    fontMatrix: [1, 0, 0, 1, 0, 0],\n    bbox: [0, 0, 1000, 1000],\n    toUnicode: { get: () => undefined },\n    cidEncoding: \"\",\n    vertical: false,\n    systemFontInfo: {},\n    // Set type so that the condition glyphName === \"\" && type===\"Type1\" holds.\n    type: \"Type1\",\n    subtype: \"Type1\"\n  };\n  const file = { isEmpty: false };\n  const font = new Font(\"TestFont\", file, properties);\n  font.missingFile = true;\n  const glyph = font._charToGlyph(65, false);\n  if (glyph.width !== 250 || glyph.unicode !== \" \") {\n    throw new Error(`Expected glyph with width 250 and unicode \" \", got width=${glyph.width} and unicode=\"${glyph.unicode}\"`);\n  }\n});",
    "i4_llama-3.3-70b-versatile": "it(\"should update glyph width and unicode when glyphName is empty for missing file Type1 fonts\", async () => {\n  const { Font } = await import(\"../../src/core/fonts.js\");\n  const properties = {\n    loadedName: \"TestFont\",\n    isType3Font: false,\n    cssFontInfo: {},\n    flags: 0,\n    differences: { 65: \"\" },\n    defaultEncoding: { 65: \"\" },\n    widths: { \"space\": 250 },\n    defaultWidth: 100,\n    composite: false,\n    cMap: { contains: () => false },\n    capHeight: 700,\n    ascent: 800,\n    descent: -200,\n    fontMatrix: [1, 0, 0, 1, 0, 0],\n    bbox: [0, 0, 1000, 1000],\n    toUnicode: { get: () => undefined },\n    cidEncoding: \"\",\n    vertical: false,\n    systemFontInfo: {},\n    // Set type so that the condition glyphName === \"\" && type===\"Type1\" holds.\n    type: \"Type1\",\n    subtype: \"Type1\"\n  };\n  const file = { isEmpty: false };\n  const font = new Font(\"TestFont\", file, properties);\n  font.missingFile = true;\n  const glyph = font._charToGlyph(65, false);\n  if (glyph.width !== 250 || glyph.unicode !== \" \") {\n    throw new Error(`Expected glyph with width 250 and unicode \" \", got width=${glyph.width} and unicode=\"${glyph.unicode}\"`);\n  }\n});",
    "i5_deepseek-r1-distill-llama-70b": "it(\"should update glyph width and unicode when glyphName is empty for missing file Type1 fonts\", async () => {\n  const { Font } = await import(\"../../src/core/fonts.js\");\n  const properties = {\n    loadedName: \"TestFont\",\n    isType3Font: false,\n    cssFontInfo: {},\n    flags: 0,\n    differences: { 65: \"\" },\n    defaultEncoding: { 65: \"\" },\n    widths: { \"space\": 250 },\n    defaultWidth: 100,\n    composite: false,\n    cMap: { contains: () => false },\n    capHeight: 700,\n    ascent: 800,\n    descent: -200,\n    fontMatrix: [1, 0, 0, 1, 0, 0],\n    bbox: [0, 0, 1000, 1000],\n    toUnicode: { get: () => undefined },\n    cidEncoding: \"\",\n    vertical: false,\n    systemFontInfo: {},\n    // Set type so that the condition glyphName === \"\" && type===\"Type1\" holds.\n    type: \"Type1\",\n    subtype: \"Type1\"\n  };\n  const file = { isEmpty: false };\n  const font = new Font(\"TestFont\", file, properties);\n  font.missingFile = true;\n  const glyph = font._charToGlyph(65, false);\n  if (glyph.width !== 250 || glyph.unicode !== \" \") {\n    throw new Error(`Expected glyph with width 250 and unicode \" \", got width=${glyph.width} and unicode=\"${glyph.unicode}\"`);\n  }\n});",
    "i5_gpt-4o": "it(\"should update glyph width and unicode when glyphName is empty for missing file Type1 fonts\", async () => {\n  const { Font } = await import(\"../../src/core/fonts.js\");\n  const properties = {\n    loadedName: \"TestFont\",\n    isType3Font: false,\n    cssFontInfo: {},\n    flags: 0,\n    differences: { 65: \"\" },\n    defaultEncoding: { 65: \"\" },\n    widths: { \"space\": 250 },\n    defaultWidth: 100,\n    composite: false,\n    cMap: { contains: () => false },\n    capHeight: 700,\n    ascent: 800,\n    descent: -200,\n    fontMatrix: [1, 0, 0, 1, 0, 0],\n    bbox: [0, 0, 1000, 1000],\n    toUnicode: { get: () => undefined },\n    cidEncoding: \"\",\n    vertical: false,\n    systemFontInfo: {},\n    // Set type so that the condition glyphName === \"\" && type===\"Type1\" holds.\n    type: \"Type1\",\n    subtype: \"Type1\"\n  };\n  const file = { isEmpty: false };\n  const font = new Font(\"TestFont\", file, properties);\n  font.missingFile = true;\n  const glyph = font._charToGlyph(65, false);\n  if (glyph.width !== 250 || glyph.unicode !== \" \") {\n    throw new Error(`Expected glyph with width 250 and unicode \" \", got width=${glyph.width} and unicode=\"${glyph.unicode}\"`);\n  }\n});",
    "i5_llama-3.3-70b-versatile": "it(\"should update glyph width and unicode when glyphName is empty for missing file Type1 fonts\", async () => {\n  const { Font } = await import(\"../../src/core/fonts.js\");\n  const properties = {\n    loadedName: \"TestFont\",\n    isType3Font: false,\n    cssFontInfo: {},\n    flags: 0,\n    differences: { 65: \"\" },\n    defaultEncoding: { 65: \"\" },\n    widths: { \"space\": 250 },\n    defaultWidth: 100,\n    composite: false,\n    cMap: { contains: () => false },\n    capHeight: 700,\n    ascent: 800,\n    descent: -200,\n    fontMatrix: [1, 0, 0, 1, 0, 0],\n    bbox: [0, 0, 1000, 1000],\n    toUnicode: { get: () => undefined },\n    cidEncoding: \"\",\n    vertical: false,\n    systemFontInfo: {},\n    // Set type so that the condition glyphName === \"\" && type===\"Type1\" holds.\n    type: \"Type1\",\n    subtype: \"Type1\"\n  };\n  const file = { isEmpty: false };\n  const font = new Font(\"TestFont\", file, properties);\n  font.missingFile = true;\n  const glyph = font._charToGlyph(65, false);\n  if (glyph.width !== 250 || glyph.unicode !== \" \") {\n    throw new Error(`Expected glyph with width 250 and unicode \" \", got width=${glyph.width} and unicode=\"${glyph.unicode}\"`);\n  }\n});"
  },
  "18496": {
    "i1_deepseek-r1-distill-llama-70b": "it(\"should create a straight line when Shift key is held during drawing\", async () => {\n  const originalRAF = window.requestAnimationFrame;\n  window.requestAnimationFrame = (cb) => {\n    cb();\n    return 0;\n  };\n\n  const { InkEditor } = await import(\"../../src/display/editor/ink.js\");\n  const dummyUiManager = {\n    rebuild: () => {},\n    _signal: new AbortController().signal,\n  };\n  const dummyParent = {\n    setEditingState: () => {},\n  };\n  const div = document.createElement(\"div\");\n  // Create a canvas with defined dimensions.\n  const canvas = document.createElement(\"canvas\");\n  canvas.width = 500;\n  canvas.height = 500;\n\n  const editor = new InkEditor({\n    uiManager: dummyUiManager,\n    parent: dummyParent,\n    div,\n    canvas,\n  });\n  // Ensure the editor is in edit mode.\n  editor.isInEditMode = () => true;\n  // Simulate a pointerdown event with the Shift key pressed.\n  const pointerDownEvent = {\n    button: 0,\n    offsetX: 10,\n    offsetY: 20,\n    shiftKey: true,\n    preventDefault: () => {},\n  };\n  editor.canvasPointerdown(pointerDownEvent);\n  // Simulate a pointerup event at a different location.\n  const pointerUpEvent = {\n    offsetX: 100,\n    offsetY: 200,\n    preventDefault: () => {},\n  };\n  editor.canvasPointerup(pointerUpEvent);\n\n  // The patch should have created a straight line, resulting in a bezier path of one segment:\n  // [[start, start, end, end]].\n  if (!editor.paths || editor.paths.length !== 1) {\n    throw new Error(\"Expected a single path to be recorded.\");\n  }\n  const bezierPoints = editor.paths[0];\n  if (bezierPoints.length !== 1) {\n    throw new Error(\"Expected exactly one bezier segment for a straight line.\");\n  }\n  const segment = bezierPoints[0];\n  const expected = [[10, 20], [10, 20], [100, 200], [100, 200]];\n  for (let i = 0; i < 4; i++) {\n    if (Math.abs(segment[i][0] - expected[i][0]) > 0.001 ||\n        Math.abs(segment[i][1] - expected[i][1]) > 0.001) {\n      throw new Error(\"The bezier segment does not match the expected straight line.\");\n    }\n  }\n  window.requestAnimationFrame = originalRAF;\n});\n",
    "i1_gpt-4o": "it(\"should create a straight line when Shift key is held during drawing\", async () => {\n  const originalRAF = window.requestAnimationFrame;\n  window.requestAnimationFrame = (cb) => {\n    cb();\n    return 0;\n  };\n\n  const { InkEditor } = await import(\"../../src/display/editor/ink.js\");\n  const dummyUiManager = {\n    rebuild: () => {},\n    _signal: new AbortController().signal,\n  };\n  const dummyParent = {\n    setEditingState: () => {},\n  };\n  const div = document.createElement(\"div\");\n  // Create a canvas with defined dimensions.\n  const canvas = document.createElement(\"canvas\");\n  canvas.width = 500;\n  canvas.height = 500;\n\n  const editor = new InkEditor({\n    uiManager: dummyUiManager,\n    parent: dummyParent,\n    div,\n    canvas,\n  });\n  // Ensure the editor is in edit mode.\n  editor.isInEditMode = () => true;\n  // Simulate a pointerdown event with the Shift key pressed.\n  const pointerDownEvent = {\n    button: 0,\n    offsetX: 10,\n    offsetY: 20,\n    shiftKey: true,\n    preventDefault: () => {},\n  };\n  editor.canvasPointerdown(pointerDownEvent);\n  // Simulate a pointerup event at a different location.\n  const pointerUpEvent = {\n    offsetX: 100,\n    offsetY: 200,\n    preventDefault: () => {},\n  };\n  editor.canvasPointerup(pointerUpEvent);\n\n  // The patch should have created a straight line, resulting in a bezier path of one segment:\n  // [[start, start, end, end]].\n  if (!editor.paths || editor.paths.length !== 1) {\n    throw new Error(\"Expected a single path to be recorded.\");\n  }\n  const bezierPoints = editor.paths[0];\n  if (bezierPoints.length !== 1) {\n    throw new Error(\"Expected exactly one bezier segment for a straight line.\");\n  }\n  const segment = bezierPoints[0];\n  const expected = [[10, 20], [10, 20], [100, 200], [100, 200]];\n  for (let i = 0; i < 4; i++) {\n    if (Math.abs(segment[i][0] - expected[i][0]) > 0.001 ||\n        Math.abs(segment[i][1] - expected[i][1]) > 0.001) {\n      throw new Error(\"The bezier segment does not match the expected straight line.\");\n    }\n  }\n  window.requestAnimationFrame = originalRAF;\n});\n",
    "i1_llama-3.3-70b-versatile": "it(\"should create a straight line when Shift key is held during drawing\", async () => {\n  const originalRAF = window.requestAnimationFrame;\n  window.requestAnimationFrame = (cb) => {\n    cb();\n    return 0;\n  };\n\n  const { InkEditor } = await import(\"../../src/display/editor/ink.js\");\n  const dummyUiManager = {\n    rebuild: () => {},\n    _signal: new AbortController().signal,\n  };\n  const dummyParent = {\n    setEditingState: () => {},\n  };\n  const div = document.createElement(\"div\");\n  // Create a canvas with defined dimensions.\n  const canvas = document.createElement(\"canvas\");\n  canvas.width = 500;\n  canvas.height = 500;\n\n  const editor = new InkEditor({\n    uiManager: dummyUiManager,\n    parent: dummyParent,\n    div,\n    canvas,\n  });\n  // Ensure the editor is in edit mode.\n  editor.isInEditMode = () => true;\n  // Simulate a pointerdown event with the Shift key pressed.\n  const pointerDownEvent = {\n    button: 0,\n    offsetX: 10,\n    offsetY: 20,\n    shiftKey: true,\n    preventDefault: () => {},\n  };\n  editor.canvasPointerdown(pointerDownEvent);\n  // Simulate a pointerup event at a different location.\n  const pointerUpEvent = {\n    offsetX: 100,\n    offsetY: 200,\n    preventDefault: () => {},\n  };\n  editor.canvasPointerup(pointerUpEvent);\n\n  // The patch should have created a straight line, resulting in a bezier path of one segment:\n  // [[start, start, end, end]].\n  if (!editor.paths || editor.paths.length !== 1) {\n    throw new Error(\"Expected a single path to be recorded.\");\n  }\n  const bezierPoints = editor.paths[0];\n  if (bezierPoints.length !== 1) {\n    throw new Error(\"Expected exactly one bezier segment for a straight line.\");\n  }\n  const segment = bezierPoints[0];\n  const expected = [[10, 20], [10, 20], [100, 200], [100, 200]];\n  for (let i = 0; i < 4; i++) {\n    if (Math.abs(segment[i][0] - expected[i][0]) > 0.001 ||\n        Math.abs(segment[i][1] - expected[i][1]) > 0.001) {\n      throw new Error(\"The bezier segment does not match the expected straight line.\");\n    }\n  }\n  window.requestAnimationFrame = originalRAF;\n});\n",
    "i1_MOCK": "it(\"should create a straight line when Shift key is held during drawing\", async () => {\n  const originalRAF = window.requestAnimationFrame;\n  window.requestAnimationFrame = (cb) => {\n    cb();\n    return 0;\n  };\n\n  const { InkEditor } = await import(\"../../src/display/editor/ink.js\");\n  const dummyUiManager = {\n    rebuild: () => {},\n    _signal: new AbortController().signal,\n  };\n  const dummyParent = {\n    setEditingState: () => {},\n  };\n  const div = document.createElement(\"div\");\n  // Create a canvas with defined dimensions.\n  const canvas = document.createElement(\"canvas\");\n  canvas.width = 500;\n  canvas.height = 500;\n\n  const editor = new InkEditor({\n    uiManager: dummyUiManager,\n    parent: dummyParent,\n    div,\n    canvas,\n  });\n  // Ensure the editor is in edit mode.\n  editor.isInEditMode = () => true;\n  // Simulate a pointerdown event with the Shift key pressed.\n  const pointerDownEvent = {\n    button: 0,\n    offsetX: 10,\n    offsetY: 20,\n    shiftKey: true,\n    preventDefault: () => {},\n  };\n  editor.canvasPointerdown(pointerDownEvent);\n  // Simulate a pointerup event at a different location.\n  const pointerUpEvent = {\n    offsetX: 100,\n    offsetY: 200,\n    preventDefault: () => {},\n  };\n  editor.canvasPointerup(pointerUpEvent);\n\n  // The patch should have created a straight line, resulting in a bezier path of one segment:\n  // [[start, start, end, end]].\n  if (!editor.paths || editor.paths.length !== 1) {\n    throw new Error(\"Expected a single path to be recorded.\");\n  }\n  const bezierPoints = editor.paths[0];\n  if (bezierPoints.length !== 1) {\n    throw new Error(\"Expected exactly one bezier segment for a straight line.\");\n  }\n  const segment = bezierPoints[0];\n  const expected = [[10, 20], [10, 20], [100, 200], [100, 200]];\n  for (let i = 0; i < 4; i++) {\n    if (Math.abs(segment[i][0] - expected[i][0]) > 0.001 ||\n        Math.abs(segment[i][1] - expected[i][1]) > 0.001) {\n      throw new Error(\"The bezier segment does not match the expected straight line.\");\n    }\n  }\n  window.requestAnimationFrame = originalRAF;\n});\n",
    "i2_deepseek-r1-distill-llama-70b": "it(\"should create a straight line when Shift key is held during drawing\", async () => {\n  const originalRAF = window.requestAnimationFrame;\n  window.requestAnimationFrame = (cb) => {\n    cb();\n    return 0;\n  };\n\n  const { InkEditor } = await import(\"../../src/display/editor/ink.js\");\n  const dummyUiManager = {\n    rebuild: () => {},\n    _signal: new AbortController().signal,\n  };\n  const dummyParent = {\n    setEditingState: () => {},\n  };\n  const div = document.createElement(\"div\");\n  // Create a canvas with defined dimensions.\n  const canvas = document.createElement(\"canvas\");\n  canvas.width = 500;\n  canvas.height = 500;\n\n  const editor = new InkEditor({\n    uiManager: dummyUiManager,\n    parent: dummyParent,\n    div,\n    canvas,\n  });\n  // Ensure the editor is in edit mode.\n  editor.isInEditMode = () => true;\n  // Simulate a pointerdown event with the Shift key pressed.\n  const pointerDownEvent = {\n    button: 0,\n    offsetX: 10,\n    offsetY: 20,\n    shiftKey: true,\n    preventDefault: () => {},\n  };\n  editor.canvasPointerdown(pointerDownEvent);\n  // Simulate a pointerup event at a different location.\n  const pointerUpEvent = {\n    offsetX: 100,\n    offsetY: 200,\n    preventDefault: () => {},\n  };\n  editor.canvasPointerup(pointerUpEvent);\n\n  // The patch should have created a straight line, resulting in a bezier path of one segment:\n  // [[start, start, end, end]].\n  if (!editor.paths || editor.paths.length !== 1) {\n    throw new Error(\"Expected a single path to be recorded.\");\n  }\n  const bezierPoints = editor.paths[0];\n  if (bezierPoints.length !== 1) {\n    throw new Error(\"Expected exactly one bezier segment for a straight line.\");\n  }\n  const segment = bezierPoints[0];\n  const expected = [[10, 20], [10, 20], [100, 200], [100, 200]];\n  for (let i = 0; i < 4; i++) {\n    if (Math.abs(segment[i][0] - expected[i][0]) > 0.001 ||\n        Math.abs(segment[i][1] - expected[i][1]) > 0.001) {\n      throw new Error(\"The bezier segment does not match the expected straight line.\");\n    }\n  }\n  window.requestAnimationFrame = originalRAF;\n});\n",
    "i2_gpt-4o": "it(\"should create a straight line when Shift key is held during drawing\", async () => {\n  const originalRAF = window.requestAnimationFrame;\n  window.requestAnimationFrame = (cb) => {\n    cb();\n    return 0;\n  };\n\n  const { InkEditor } = await import(\"../../src/display/editor/ink.js\");\n  const dummyUiManager = {\n    rebuild: () => {},\n    _signal: new AbortController().signal,\n  };\n  const dummyParent = {\n    setEditingState: () => {},\n  };\n  const div = document.createElement(\"div\");\n  // Create a canvas with defined dimensions.\n  const canvas = document.createElement(\"canvas\");\n  canvas.width = 500;\n  canvas.height = 500;\n\n  const editor = new InkEditor({\n    uiManager: dummyUiManager,\n    parent: dummyParent,\n    div,\n    canvas,\n  });\n  // Ensure the editor is in edit mode.\n  editor.isInEditMode = () => true;\n  // Simulate a pointerdown event with the Shift key pressed.\n  const pointerDownEvent = {\n    button: 0,\n    offsetX: 10,\n    offsetY: 20,\n    shiftKey: true,\n    preventDefault: () => {},\n  };\n  editor.canvasPointerdown(pointerDownEvent);\n  // Simulate a pointerup event at a different location.\n  const pointerUpEvent = {\n    offsetX: 100,\n    offsetY: 200,\n    preventDefault: () => {},\n  };\n  editor.canvasPointerup(pointerUpEvent);\n\n  // The patch should have created a straight line, resulting in a bezier path of one segment:\n  // [[start, start, end, end]].\n  if (!editor.paths || editor.paths.length !== 1) {\n    throw new Error(\"Expected a single path to be recorded.\");\n  }\n  const bezierPoints = editor.paths[0];\n  if (bezierPoints.length !== 1) {\n    throw new Error(\"Expected exactly one bezier segment for a straight line.\");\n  }\n  const segment = bezierPoints[0];\n  const expected = [[10, 20], [10, 20], [100, 200], [100, 200]];\n  for (let i = 0; i < 4; i++) {\n    if (Math.abs(segment[i][0] - expected[i][0]) > 0.001 ||\n        Math.abs(segment[i][1] - expected[i][1]) > 0.001) {\n      throw new Error(\"The bezier segment does not match the expected straight line.\");\n    }\n  }\n  window.requestAnimationFrame = originalRAF;\n});\n",
    "i2_llama-3.3-70b-versatile": "it(\"should create a straight line when Shift key is held during drawing\", async () => {\n  const originalRAF = window.requestAnimationFrame;\n  window.requestAnimationFrame = (cb) => {\n    cb();\n    return 0;\n  };\n\n  const { InkEditor } = await import(\"../../src/display/editor/ink.js\");\n  const dummyUiManager = {\n    rebuild: () => {},\n    _signal: new AbortController().signal,\n  };\n  const dummyParent = {\n    setEditingState: () => {},\n  };\n  const div = document.createElement(\"div\");\n  // Create a canvas with defined dimensions.\n  const canvas = document.createElement(\"canvas\");\n  canvas.width = 500;\n  canvas.height = 500;\n\n  const editor = new InkEditor({\n    uiManager: dummyUiManager,\n    parent: dummyParent,\n    div,\n    canvas,\n  });\n  // Ensure the editor is in edit mode.\n  editor.isInEditMode = () => true;\n  // Simulate a pointerdown event with the Shift key pressed.\n  const pointerDownEvent = {\n    button: 0,\n    offsetX: 10,\n    offsetY: 20,\n    shiftKey: true,\n    preventDefault: () => {},\n  };\n  editor.canvasPointerdown(pointerDownEvent);\n  // Simulate a pointerup event at a different location.\n  const pointerUpEvent = {\n    offsetX: 100,\n    offsetY: 200,\n    preventDefault: () => {},\n  };\n  editor.canvasPointerup(pointerUpEvent);\n\n  // The patch should have created a straight line, resulting in a bezier path of one segment:\n  // [[start, start, end, end]].\n  if (!editor.paths || editor.paths.length !== 1) {\n    throw new Error(\"Expected a single path to be recorded.\");\n  }\n  const bezierPoints = editor.paths[0];\n  if (bezierPoints.length !== 1) {\n    throw new Error(\"Expected exactly one bezier segment for a straight line.\");\n  }\n  const segment = bezierPoints[0];\n  const expected = [[10, 20], [10, 20], [100, 200], [100, 200]];\n  for (let i = 0; i < 4; i++) {\n    if (Math.abs(segment[i][0] - expected[i][0]) > 0.001 ||\n        Math.abs(segment[i][1] - expected[i][1]) > 0.001) {\n      throw new Error(\"The bezier segment does not match the expected straight line.\");\n    }\n  }\n  window.requestAnimationFrame = originalRAF;\n});\n",
    "i3_deepseek-r1-distill-llama-70b": "it(\"should create a straight line when Shift key is held during drawing\", async () => {\n  const originalRAF = window.requestAnimationFrame;\n  window.requestAnimationFrame = (cb) => {\n    cb();\n    return 0;\n  };\n\n  const { InkEditor } = await import(\"../../src/display/editor/ink.js\");\n  const dummyUiManager = {\n    rebuild: () => {},\n    _signal: new AbortController().signal,\n  };\n  const dummyParent = {\n    setEditingState: () => {},\n  };\n  const div = document.createElement(\"div\");\n  // Create a canvas with defined dimensions.\n  const canvas = document.createElement(\"canvas\");\n  canvas.width = 500;\n  canvas.height = 500;\n\n  const editor = new InkEditor({\n    uiManager: dummyUiManager,\n    parent: dummyParent,\n    div,\n    canvas,\n  });\n  // Ensure the editor is in edit mode.\n  editor.isInEditMode = () => true;\n  // Simulate a pointerdown event with the Shift key pressed.\n  const pointerDownEvent = {\n    button: 0,\n    offsetX: 10,\n    offsetY: 20,\n    shiftKey: true,\n    preventDefault: () => {},\n  };\n  editor.canvasPointerdown(pointerDownEvent);\n  // Simulate a pointerup event at a different location.\n  const pointerUpEvent = {\n    offsetX: 100,\n    offsetY: 200,\n    preventDefault: () => {},\n  };\n  editor.canvasPointerup(pointerUpEvent);\n\n  // The patch should have created a straight line, resulting in a bezier path of one segment:\n  // [[start, start, end, end]].\n  if (!editor.paths || editor.paths.length !== 1) {\n    throw new Error(\"Expected a single path to be recorded.\");\n  }\n  const bezierPoints = editor.paths[0];\n  if (bezierPoints.length !== 1) {\n    throw new Error(\"Expected exactly one bezier segment for a straight line.\");\n  }\n  const segment = bezierPoints[0];\n  const expected = [[10, 20], [10, 20], [100, 200], [100, 200]];\n  for (let i = 0; i < 4; i++) {\n    if (Math.abs(segment[i][0] - expected[i][0]) > 0.001 ||\n        Math.abs(segment[i][1] - expected[i][1]) > 0.001) {\n      throw new Error(\"The bezier segment does not match the expected straight line.\");\n    }\n  }\n  window.requestAnimationFrame = originalRAF;\n});\n",
    "i3_gpt-4o": "it(\"should create a straight line when Shift key is held during drawing\", async () => {\n  const originalRAF = window.requestAnimationFrame;\n  window.requestAnimationFrame = (cb) => {\n    cb();\n    return 0;\n  };\n\n  const { InkEditor } = await import(\"../../src/display/editor/ink.js\");\n  const dummyUiManager = {\n    rebuild: () => {},\n    _signal: new AbortController().signal,\n  };\n  const dummyParent = {\n    setEditingState: () => {},\n  };\n  const div = document.createElement(\"div\");\n  // Create a canvas with defined dimensions.\n  const canvas = document.createElement(\"canvas\");\n  canvas.width = 500;\n  canvas.height = 500;\n\n  const editor = new InkEditor({\n    uiManager: dummyUiManager,\n    parent: dummyParent,\n    div,\n    canvas,\n  });\n  // Ensure the editor is in edit mode.\n  editor.isInEditMode = () => true;\n  // Simulate a pointerdown event with the Shift key pressed.\n  const pointerDownEvent = {\n    button: 0,\n    offsetX: 10,\n    offsetY: 20,\n    shiftKey: true,\n    preventDefault: () => {},\n  };\n  editor.canvasPointerdown(pointerDownEvent);\n  // Simulate a pointerup event at a different location.\n  const pointerUpEvent = {\n    offsetX: 100,\n    offsetY: 200,\n    preventDefault: () => {},\n  };\n  editor.canvasPointerup(pointerUpEvent);\n\n  // The patch should have created a straight line, resulting in a bezier path of one segment:\n  // [[start, start, end, end]].\n  if (!editor.paths || editor.paths.length !== 1) {\n    throw new Error(\"Expected a single path to be recorded.\");\n  }\n  const bezierPoints = editor.paths[0];\n  if (bezierPoints.length !== 1) {\n    throw new Error(\"Expected exactly one bezier segment for a straight line.\");\n  }\n  const segment = bezierPoints[0];\n  const expected = [[10, 20], [10, 20], [100, 200], [100, 200]];\n  for (let i = 0; i < 4; i++) {\n    if (Math.abs(segment[i][0] - expected[i][0]) > 0.001 ||\n        Math.abs(segment[i][1] - expected[i][1]) > 0.001) {\n      throw new Error(\"The bezier segment does not match the expected straight line.\");\n    }\n  }\n  window.requestAnimationFrame = originalRAF;\n});\n",
    "i3_llama-3.3-70b-versatile": "it(\"should create a straight line when Shift key is held during drawing\", async () => {\n  const originalRAF = window.requestAnimationFrame;\n  window.requestAnimationFrame = (cb) => {\n    cb();\n    return 0;\n  };\n\n  const { InkEditor } = await import(\"../../src/display/editor/ink.js\");\n  const dummyUiManager = {\n    rebuild: () => {},\n    _signal: new AbortController().signal,\n  };\n  const dummyParent = {\n    setEditingState: () => {},\n  };\n  const div = document.createElement(\"div\");\n  // Create a canvas with defined dimensions.\n  const canvas = document.createElement(\"canvas\");\n  canvas.width = 500;\n  canvas.height = 500;\n\n  const editor = new InkEditor({\n    uiManager: dummyUiManager,\n    parent: dummyParent,\n    div,\n    canvas,\n  });\n  // Ensure the editor is in edit mode.\n  editor.isInEditMode = () => true;\n  // Simulate a pointerdown event with the Shift key pressed.\n  const pointerDownEvent = {\n    button: 0,\n    offsetX: 10,\n    offsetY: 20,\n    shiftKey: true,\n    preventDefault: () => {},\n  };\n  editor.canvasPointerdown(pointerDownEvent);\n  // Simulate a pointerup event at a different location.\n  const pointerUpEvent = {\n    offsetX: 100,\n    offsetY: 200,\n    preventDefault: () => {},\n  };\n  editor.canvasPointerup(pointerUpEvent);\n\n  // The patch should have created a straight line, resulting in a bezier path of one segment:\n  // [[start, start, end, end]].\n  if (!editor.paths || editor.paths.length !== 1) {\n    throw new Error(\"Expected a single path to be recorded.\");\n  }\n  const bezierPoints = editor.paths[0];\n  if (bezierPoints.length !== 1) {\n    throw new Error(\"Expected exactly one bezier segment for a straight line.\");\n  }\n  const segment = bezierPoints[0];\n  const expected = [[10, 20], [10, 20], [100, 200], [100, 200]];\n  for (let i = 0; i < 4; i++) {\n    if (Math.abs(segment[i][0] - expected[i][0]) > 0.001 ||\n        Math.abs(segment[i][1] - expected[i][1]) > 0.001) {\n      throw new Error(\"The bezier segment does not match the expected straight line.\");\n    }\n  }\n  window.requestAnimationFrame = originalRAF;\n});\n",
    "i4_deepseek-r1-distill-llama-70b": "it(\"should create a straight line when Shift key is held during drawing\", async () => {\n  const originalRAF = window.requestAnimationFrame;\n  window.requestAnimationFrame = (cb) => {\n    cb();\n    return 0;\n  };\n\n  const { InkEditor } = await import(\"../../src/display/editor/ink.js\");\n  const dummyUiManager = {\n    rebuild: () => {},\n    _signal: new AbortController().signal,\n  };\n  const dummyParent = {\n    setEditingState: () => {},\n  };\n  const div = document.createElement(\"div\");\n  // Create a canvas with defined dimensions.\n  const canvas = document.createElement(\"canvas\");\n  canvas.width = 500;\n  canvas.height = 500;\n\n  const editor = new InkEditor({\n    uiManager: dummyUiManager,\n    parent: dummyParent,\n    div,\n    canvas,\n  });\n  // Ensure the editor is in edit mode.\n  editor.isInEditMode = () => true;\n  // Simulate a pointerdown event with the Shift key pressed.\n  const pointerDownEvent = {\n    button: 0,\n    offsetX: 10,\n    offsetY: 20,\n    shiftKey: true,\n    preventDefault: () => {},\n  };\n  editor.canvasPointerdown(pointerDownEvent);\n  // Simulate a pointerup event at a different location.\n  const pointerUpEvent = {\n    offsetX: 100,\n    offsetY: 200,\n    preventDefault: () => {},\n  };\n  editor.canvasPointerup(pointerUpEvent);\n\n  // The patch should have created a straight line, resulting in a bezier path of one segment:\n  // [[start, start, end, end]].\n  if (!editor.paths || editor.paths.length !== 1) {\n    throw new Error(\"Expected a single path to be recorded.\");\n  }\n  const bezierPoints = editor.paths[0];\n  if (bezierPoints.length !== 1) {\n    throw new Error(\"Expected exactly one bezier segment for a straight line.\");\n  }\n  const segment = bezierPoints[0];\n  const expected = [[10, 20], [10, 20], [100, 200], [100, 200]];\n  for (let i = 0; i < 4; i++) {\n    if (Math.abs(segment[i][0] - expected[i][0]) > 0.001 ||\n        Math.abs(segment[i][1] - expected[i][1]) > 0.001) {\n      throw new Error(\"The bezier segment does not match the expected straight line.\");\n    }\n  }\n  window.requestAnimationFrame = originalRAF;\n});\n",
    "i4_gpt-4o": "it(\"should create a straight line when Shift key is held during drawing\", async () => {\n  const originalRAF = window.requestAnimationFrame;\n  window.requestAnimationFrame = (cb) => {\n    cb();\n    return 0;\n  };\n\n  const { InkEditor } = await import(\"../../src/display/editor/ink.js\");\n  const dummyUiManager = {\n    rebuild: () => {},\n    _signal: new AbortController().signal,\n  };\n  const dummyParent = {\n    setEditingState: () => {},\n  };\n  const div = document.createElement(\"div\");\n  // Create a canvas with defined dimensions.\n  const canvas = document.createElement(\"canvas\");\n  canvas.width = 500;\n  canvas.height = 500;\n\n  const editor = new InkEditor({\n    uiManager: dummyUiManager,\n    parent: dummyParent,\n    div,\n    canvas,\n  });\n  // Ensure the editor is in edit mode.\n  editor.isInEditMode = () => true;\n  // Simulate a pointerdown event with the Shift key pressed.\n  const pointerDownEvent = {\n    button: 0,\n    offsetX: 10,\n    offsetY: 20,\n    shiftKey: true,\n    preventDefault: () => {},\n  };\n  editor.canvasPointerdown(pointerDownEvent);\n  // Simulate a pointerup event at a different location.\n  const pointerUpEvent = {\n    offsetX: 100,\n    offsetY: 200,\n    preventDefault: () => {},\n  };\n  editor.canvasPointerup(pointerUpEvent);\n\n  // The patch should have created a straight line, resulting in a bezier path of one segment:\n  // [[start, start, end, end]].\n  if (!editor.paths || editor.paths.length !== 1) {\n    throw new Error(\"Expected a single path to be recorded.\");\n  }\n  const bezierPoints = editor.paths[0];\n  if (bezierPoints.length !== 1) {\n    throw new Error(\"Expected exactly one bezier segment for a straight line.\");\n  }\n  const segment = bezierPoints[0];\n  const expected = [[10, 20], [10, 20], [100, 200], [100, 200]];\n  for (let i = 0; i < 4; i++) {\n    if (Math.abs(segment[i][0] - expected[i][0]) > 0.001 ||\n        Math.abs(segment[i][1] - expected[i][1]) > 0.001) {\n      throw new Error(\"The bezier segment does not match the expected straight line.\");\n    }\n  }\n  window.requestAnimationFrame = originalRAF;\n});\n",
    "i4_llama-3.3-70b-versatile": "it(\"should create a straight line when Shift key is held during drawing\", async () => {\n  const originalRAF = window.requestAnimationFrame;\n  window.requestAnimationFrame = (cb) => {\n    cb();\n    return 0;\n  };\n\n  const { InkEditor } = await import(\"../../src/display/editor/ink.js\");\n  const dummyUiManager = {\n    rebuild: () => {},\n    _signal: new AbortController().signal,\n  };\n  const dummyParent = {\n    setEditingState: () => {},\n  };\n  const div = document.createElement(\"div\");\n  // Create a canvas with defined dimensions.\n  const canvas = document.createElement(\"canvas\");\n  canvas.width = 500;\n  canvas.height = 500;\n\n  const editor = new InkEditor({\n    uiManager: dummyUiManager,\n    parent: dummyParent,\n    div,\n    canvas,\n  });\n  // Ensure the editor is in edit mode.\n  editor.isInEditMode = () => true;\n  // Simulate a pointerdown event with the Shift key pressed.\n  const pointerDownEvent = {\n    button: 0,\n    offsetX: 10,\n    offsetY: 20,\n    shiftKey: true,\n    preventDefault: () => {},\n  };\n  editor.canvasPointerdown(pointerDownEvent);\n  // Simulate a pointerup event at a different location.\n  const pointerUpEvent = {\n    offsetX: 100,\n    offsetY: 200,\n    preventDefault: () => {},\n  };\n  editor.canvasPointerup(pointerUpEvent);\n\n  // The patch should have created a straight line, resulting in a bezier path of one segment:\n  // [[start, start, end, end]].\n  if (!editor.paths || editor.paths.length !== 1) {\n    throw new Error(\"Expected a single path to be recorded.\");\n  }\n  const bezierPoints = editor.paths[0];\n  if (bezierPoints.length !== 1) {\n    throw new Error(\"Expected exactly one bezier segment for a straight line.\");\n  }\n  const segment = bezierPoints[0];\n  const expected = [[10, 20], [10, 20], [100, 200], [100, 200]];\n  for (let i = 0; i < 4; i++) {\n    if (Math.abs(segment[i][0] - expected[i][0]) > 0.001 ||\n        Math.abs(segment[i][1] - expected[i][1]) > 0.001) {\n      throw new Error(\"The bezier segment does not match the expected straight line.\");\n    }\n  }\n  window.requestAnimationFrame = originalRAF;\n});\n",
    "i5_deepseek-r1-distill-llama-70b": "it(\"should create a straight line when Shift key is held during drawing\", async () => {\n  const originalRAF = window.requestAnimationFrame;\n  window.requestAnimationFrame = (cb) => {\n    cb();\n    return 0;\n  };\n\n  const { InkEditor } = await import(\"../../src/display/editor/ink.js\");\n  const dummyUiManager = {\n    rebuild: () => {},\n    _signal: new AbortController().signal,\n  };\n  const dummyParent = {\n    setEditingState: () => {},\n  };\n  const div = document.createElement(\"div\");\n  // Create a canvas with defined dimensions.\n  const canvas = document.createElement(\"canvas\");\n  canvas.width = 500;\n  canvas.height = 500;\n\n  const editor = new InkEditor({\n    uiManager: dummyUiManager,\n    parent: dummyParent,\n    div,\n    canvas,\n  });\n  // Ensure the editor is in edit mode.\n  editor.isInEditMode = () => true;\n  // Simulate a pointerdown event with the Shift key pressed.\n  const pointerDownEvent = {\n    button: 0,\n    offsetX: 10,\n    offsetY: 20,\n    shiftKey: true,\n    preventDefault: () => {},\n  };\n  editor.canvasPointerdown(pointerDownEvent);\n  // Simulate a pointerup event at a different location.\n  const pointerUpEvent = {\n    offsetX: 100,\n    offsetY: 200,\n    preventDefault: () => {},\n  };\n  editor.canvasPointerup(pointerUpEvent);\n\n  // The patch should have created a straight line, resulting in a bezier path of one segment:\n  // [[start, start, end, end]].\n  if (!editor.paths || editor.paths.length !== 1) {\n    throw new Error(\"Expected a single path to be recorded.\");\n  }\n  const bezierPoints = editor.paths[0];\n  if (bezierPoints.length !== 1) {\n    throw new Error(\"Expected exactly one bezier segment for a straight line.\");\n  }\n  const segment = bezierPoints[0];\n  const expected = [[10, 20], [10, 20], [100, 200], [100, 200]];\n  for (let i = 0; i < 4; i++) {\n    if (Math.abs(segment[i][0] - expected[i][0]) > 0.001 ||\n        Math.abs(segment[i][1] - expected[i][1]) > 0.001) {\n      throw new Error(\"The bezier segment does not match the expected straight line.\");\n    }\n  }\n  window.requestAnimationFrame = originalRAF;\n});\n",
    "i5_gpt-4o": "it(\"should create a straight line when Shift key is held during drawing\", async () => {\n  const originalRAF = window.requestAnimationFrame;\n  window.requestAnimationFrame = (cb) => {\n    cb();\n    return 0;\n  };\n\n  const { InkEditor } = await import(\"../../src/display/editor/ink.js\");\n  const dummyUiManager = {\n    rebuild: () => {},\n    _signal: new AbortController().signal,\n  };\n  const dummyParent = {\n    setEditingState: () => {},\n  };\n  const div = document.createElement(\"div\");\n  // Create a canvas with defined dimensions.\n  const canvas = document.createElement(\"canvas\");\n  canvas.width = 500;\n  canvas.height = 500;\n\n  const editor = new InkEditor({\n    uiManager: dummyUiManager,\n    parent: dummyParent,\n    div,\n    canvas,\n  });\n  // Ensure the editor is in edit mode.\n  editor.isInEditMode = () => true;\n  // Simulate a pointerdown event with the Shift key pressed.\n  const pointerDownEvent = {\n    button: 0,\n    offsetX: 10,\n    offsetY: 20,\n    shiftKey: true,\n    preventDefault: () => {},\n  };\n  editor.canvasPointerdown(pointerDownEvent);\n  // Simulate a pointerup event at a different location.\n  const pointerUpEvent = {\n    offsetX: 100,\n    offsetY: 200,\n    preventDefault: () => {},\n  };\n  editor.canvasPointerup(pointerUpEvent);\n\n  // The patch should have created a straight line, resulting in a bezier path of one segment:\n  // [[start, start, end, end]].\n  if (!editor.paths || editor.paths.length !== 1) {\n    throw new Error(\"Expected a single path to be recorded.\");\n  }\n  const bezierPoints = editor.paths[0];\n  if (bezierPoints.length !== 1) {\n    throw new Error(\"Expected exactly one bezier segment for a straight line.\");\n  }\n  const segment = bezierPoints[0];\n  const expected = [[10, 20], [10, 20], [100, 200], [100, 200]];\n  for (let i = 0; i < 4; i++) {\n    if (Math.abs(segment[i][0] - expected[i][0]) > 0.001 ||\n        Math.abs(segment[i][1] - expected[i][1]) > 0.001) {\n      throw new Error(\"The bezier segment does not match the expected straight line.\");\n    }\n  }\n  window.requestAnimationFrame = originalRAF;\n});\n",
    "i5_llama-3.3-70b-versatile": "it(\"should create a straight line when Shift key is held during drawing\", async () => {\n  const originalRAF = window.requestAnimationFrame;\n  window.requestAnimationFrame = (cb) => {\n    cb();\n    return 0;\n  };\n\n  const { InkEditor } = await import(\"../../src/display/editor/ink.js\");\n  const dummyUiManager = {\n    rebuild: () => {},\n    _signal: new AbortController().signal,\n  };\n  const dummyParent = {\n    setEditingState: () => {},\n  };\n  const div = document.createElement(\"div\");\n  // Create a canvas with defined dimensions.\n  const canvas = document.createElement(\"canvas\");\n  canvas.width = 500;\n  canvas.height = 500;\n\n  const editor = new InkEditor({\n    uiManager: dummyUiManager,\n    parent: dummyParent,\n    div,\n    canvas,\n  });\n  // Ensure the editor is in edit mode.\n  editor.isInEditMode = () => true;\n  // Simulate a pointerdown event with the Shift key pressed.\n  const pointerDownEvent = {\n    button: 0,\n    offsetX: 10,\n    offsetY: 20,\n    shiftKey: true,\n    preventDefault: () => {},\n  };\n  editor.canvasPointerdown(pointerDownEvent);\n  // Simulate a pointerup event at a different location.\n  const pointerUpEvent = {\n    offsetX: 100,\n    offsetY: 200,\n    preventDefault: () => {},\n  };\n  editor.canvasPointerup(pointerUpEvent);\n\n  // The patch should have created a straight line, resulting in a bezier path of one segment:\n  // [[start, start, end, end]].\n  if (!editor.paths || editor.paths.length !== 1) {\n    throw new Error(\"Expected a single path to be recorded.\");\n  }\n  const bezierPoints = editor.paths[0];\n  if (bezierPoints.length !== 1) {\n    throw new Error(\"Expected exactly one bezier segment for a straight line.\");\n  }\n  const segment = bezierPoints[0];\n  const expected = [[10, 20], [10, 20], [100, 200], [100, 200]];\n  for (let i = 0; i < 4; i++) {\n    if (Math.abs(segment[i][0] - expected[i][0]) > 0.001 ||\n        Math.abs(segment[i][1] - expected[i][1]) > 0.001) {\n      throw new Error(\"The bezier segment does not match the expected straight line.\");\n    }\n  }\n  window.requestAnimationFrame = originalRAF;\n});\n"
  },
  "18628": {
    "i1_deepseek-r1-distill-llama-70b": "it(\"should correctly map the Euro character for fonts mapped to a standard font\", async () => {\n  const { Font } = await import(\"../../src/core/fonts.js\");\n  const { getGlyphsUnicode } = await import(\"../../src/core/glyphlist.js\");\n  const { IdentityToUnicodeMap } = await import(\"../../src/core/to_unicode_map.js\");\n  const file = { isEmpty: true };\n  const properties = {\n    loadedName: \"HelveticaNeue\",\n    differences: { 128: \"Euro\" },\n    widths: {},\n    defaultWidth: 600,\n    composite: false,\n    cMap: null,\n    capHeight: 800,\n    ascent: 900,\n    descent: -200,\n    fontMatrix: [1, 0, 0, 1, 0, 0],\n    bbox: [0, 0, 1000, 1000],\n    defaultEncoding: { 128: \"Euro\" },\n    toUnicode: new IdentityToUnicodeMap([]),\n    cidEncoding: \"Identity-H\",\n    vertical: false,\n    systemFontInfo: { guessFallback: false, css: \"\" },\n    type: \"CIDFontType2\",\n    subtype: \"Type1\",\n    flags: 0,\n    isSimulatedFlags: false,\n  };\n  const font = new Font(\"HelveticaNeue\", file, properties);\n  const mappedEuro = font.toFontChar[128];\n  const expectedEuro = getGlyphsUnicode()[\"Euro\"];\n  if (mappedEuro !== expectedEuro) {\n    throw new Error(`Expected Euro mapping (${expectedEuro}) but got (${mappedEuro})`);\n  }\n});",
    "i1_gpt-4o": "it(\"should correctly map the Euro character for fonts mapped to a standard font\", async () => {\n  const { Font } = await import(\"../../src/core/fonts.js\");\n  const { getGlyphsUnicode } = await import(\"../../src/core/glyphlist.js\");\n  const { IdentityToUnicodeMap } = await import(\"../../src/core/to_unicode_map.js\");\n  const file = { isEmpty: true };\n  const properties = {\n    loadedName: \"HelveticaNeue\",\n    differences: { 128: \"Euro\" },\n    widths: {},\n    defaultWidth: 600,\n    composite: false,\n    cMap: null,\n    capHeight: 800,\n    ascent: 900,\n    descent: -200,\n    fontMatrix: [1, 0, 0, 1, 0, 0],\n    bbox: [0, 0, 1000, 1000],\n    defaultEncoding: { 128: \"Euro\" },\n    toUnicode: new IdentityToUnicodeMap([]),\n    cidEncoding: \"Identity-H\",\n    vertical: false,\n    systemFontInfo: { guessFallback: false, css: \"\" },\n    type: \"CIDFontType2\",\n    subtype: \"Type1\",\n    flags: 0,\n    isSimulatedFlags: false,\n  };\n  const font = new Font(\"HelveticaNeue\", file, properties);\n  const mappedEuro = font.toFontChar[128];\n  const expectedEuro = getGlyphsUnicode()[\"Euro\"];\n  if (mappedEuro !== expectedEuro) {\n    throw new Error(`Expected Euro mapping (${expectedEuro}) but got (${mappedEuro})`);\n  }\n});",
    "i1_llama-3.3-70b-versatile": "it(\"should correctly map the Euro character for fonts mapped to a standard font\", async () => {\n  const { Font } = await import(\"../../src/core/fonts.js\");\n  const { getGlyphsUnicode } = await import(\"../../src/core/glyphlist.js\");\n  const { IdentityToUnicodeMap } = await import(\"../../src/core/to_unicode_map.js\");\n  const file = { isEmpty: true };\n  const properties = {\n    loadedName: \"HelveticaNeue\",\n    differences: { 128: \"Euro\" },\n    widths: {},\n    defaultWidth: 600,\n    composite: false,\n    cMap: null,\n    capHeight: 800,\n    ascent: 900,\n    descent: -200,\n    fontMatrix: [1, 0, 0, 1, 0, 0],\n    bbox: [0, 0, 1000, 1000],\n    defaultEncoding: { 128: \"Euro\" },\n    toUnicode: new IdentityToUnicodeMap([]),\n    cidEncoding: \"Identity-H\",\n    vertical: false,\n    systemFontInfo: { guessFallback: false, css: \"\" },\n    type: \"CIDFontType2\",\n    subtype: \"Type1\",\n    flags: 0,\n    isSimulatedFlags: false,\n  };\n  const font = new Font(\"HelveticaNeue\", file, properties);\n  const mappedEuro = font.toFontChar[128];\n  const expectedEuro = getGlyphsUnicode()[\"Euro\"];\n  if (mappedEuro !== expectedEuro) {\n    throw new Error(`Expected Euro mapping (${expectedEuro}) but got (${mappedEuro})`);\n  }\n});",
    "i1_MOCK": "it(\"should correctly map the Euro character for fonts mapped to a standard font\", async () => {\n  const { Font } = await import(\"../../src/core/fonts.js\");\n  const { getGlyphsUnicode } = await import(\"../../src/core/glyphlist.js\");\n  const { IdentityToUnicodeMap } = await import(\"../../src/core/to_unicode_map.js\");\n  const file = { isEmpty: true };\n  const properties = {\n    loadedName: \"HelveticaNeue\",\n    differences: { 128: \"Euro\" },\n    widths: {},\n    defaultWidth: 600,\n    composite: false,\n    cMap: null,\n    capHeight: 800,\n    ascent: 900,\n    descent: -200,\n    fontMatrix: [1, 0, 0, 1, 0, 0],\n    bbox: [0, 0, 1000, 1000],\n    defaultEncoding: { 128: \"Euro\" },\n    toUnicode: new IdentityToUnicodeMap([]),\n    cidEncoding: \"Identity-H\",\n    vertical: false,\n    systemFontInfo: { guessFallback: false, css: \"\" },\n    type: \"CIDFontType2\",\n    subtype: \"Type1\",\n    flags: 0,\n    isSimulatedFlags: false,\n  };\n  const font = new Font(\"HelveticaNeue\", file, properties);\n  const mappedEuro = font.toFontChar[128];\n  const expectedEuro = getGlyphsUnicode()[\"Euro\"];\n  if (mappedEuro !== expectedEuro) {\n    throw new Error(`Expected Euro mapping (${expectedEuro}) but got (${mappedEuro})`);\n  }\n});",
    "i2_deepseek-r1-distill-llama-70b": "it(\"should correctly map the Euro character for fonts mapped to a standard font\", async () => {\n  const { Font } = await import(\"../../src/core/fonts.js\");\n  const { getGlyphsUnicode } = await import(\"../../src/core/glyphlist.js\");\n  const { IdentityToUnicodeMap } = await import(\"../../src/core/to_unicode_map.js\");\n  const file = { isEmpty: true };\n  const properties = {\n    loadedName: \"HelveticaNeue\",\n    differences: { 128: \"Euro\" },\n    widths: {},\n    defaultWidth: 600,\n    composite: false,\n    cMap: null,\n    capHeight: 800,\n    ascent: 900,\n    descent: -200,\n    fontMatrix: [1, 0, 0, 1, 0, 0],\n    bbox: [0, 0, 1000, 1000],\n    defaultEncoding: { 128: \"Euro\" },\n    toUnicode: new IdentityToUnicodeMap([]),\n    cidEncoding: \"Identity-H\",\n    vertical: false,\n    systemFontInfo: { guessFallback: false, css: \"\" },\n    type: \"CIDFontType2\",\n    subtype: \"Type1\",\n    flags: 0,\n    isSimulatedFlags: false,\n  };\n  const font = new Font(\"HelveticaNeue\", file, properties);\n  const mappedEuro = font.toFontChar[128];\n  const expectedEuro = getGlyphsUnicode()[\"Euro\"];\n  if (mappedEuro !== expectedEuro) {\n    throw new Error(`Expected Euro mapping (${expectedEuro}) but got (${mappedEuro})`);\n  }\n});",
    "i2_gpt-4o": "it(\"should correctly map the Euro character for fonts mapped to a standard font\", async () => {\n  const { Font } = await import(\"../../src/core/fonts.js\");\n  const { getGlyphsUnicode } = await import(\"../../src/core/glyphlist.js\");\n  const { IdentityToUnicodeMap } = await import(\"../../src/core/to_unicode_map.js\");\n  const file = { isEmpty: true };\n  const properties = {\n    loadedName: \"HelveticaNeue\",\n    differences: { 128: \"Euro\" },\n    widths: {},\n    defaultWidth: 600,\n    composite: false,\n    cMap: null,\n    capHeight: 800,\n    ascent: 900,\n    descent: -200,\n    fontMatrix: [1, 0, 0, 1, 0, 0],\n    bbox: [0, 0, 1000, 1000],\n    defaultEncoding: { 128: \"Euro\" },\n    toUnicode: new IdentityToUnicodeMap([]),\n    cidEncoding: \"Identity-H\",\n    vertical: false,\n    systemFontInfo: { guessFallback: false, css: \"\" },\n    type: \"CIDFontType2\",\n    subtype: \"Type1\",\n    flags: 0,\n    isSimulatedFlags: false,\n  };\n  const font = new Font(\"HelveticaNeue\", file, properties);\n  const mappedEuro = font.toFontChar[128];\n  const expectedEuro = getGlyphsUnicode()[\"Euro\"];\n  if (mappedEuro !== expectedEuro) {\n    throw new Error(`Expected Euro mapping (${expectedEuro}) but got (${mappedEuro})`);\n  }\n});",
    "i2_llama-3.3-70b-versatile": "it(\"should correctly map the Euro character for fonts mapped to a standard font\", async () => {\n  const { Font } = await import(\"../../src/core/fonts.js\");\n  const { getGlyphsUnicode } = await import(\"../../src/core/glyphlist.js\");\n  const { IdentityToUnicodeMap } = await import(\"../../src/core/to_unicode_map.js\");\n  const file = { isEmpty: true };\n  const properties = {\n    loadedName: \"HelveticaNeue\",\n    differences: { 128: \"Euro\" },\n    widths: {},\n    defaultWidth: 600,\n    composite: false,\n    cMap: null,\n    capHeight: 800,\n    ascent: 900,\n    descent: -200,\n    fontMatrix: [1, 0, 0, 1, 0, 0],\n    bbox: [0, 0, 1000, 1000],\n    defaultEncoding: { 128: \"Euro\" },\n    toUnicode: new IdentityToUnicodeMap([]),\n    cidEncoding: \"Identity-H\",\n    vertical: false,\n    systemFontInfo: { guessFallback: false, css: \"\" },\n    type: \"CIDFontType2\",\n    subtype: \"Type1\",\n    flags: 0,\n    isSimulatedFlags: false,\n  };\n  const font = new Font(\"HelveticaNeue\", file, properties);\n  const mappedEuro = font.toFontChar[128];\n  const expectedEuro = getGlyphsUnicode()[\"Euro\"];\n  if (mappedEuro !== expectedEuro) {\n    throw new Error(`Expected Euro mapping (${expectedEuro}) but got (${mappedEuro})`);\n  }\n});",
    "i3_deepseek-r1-distill-llama-70b": "it(\"should correctly map the Euro character for fonts mapped to a standard font\", async () => {\n  const { Font } = await import(\"../../src/core/fonts.js\");\n  const { getGlyphsUnicode } = await import(\"../../src/core/glyphlist.js\");\n  const { IdentityToUnicodeMap } = await import(\"../../src/core/to_unicode_map.js\");\n  const file = { isEmpty: true };\n  const properties = {\n    loadedName: \"HelveticaNeue\",\n    differences: { 128: \"Euro\" },\n    widths: {},\n    defaultWidth: 600,\n    composite: false,\n    cMap: null,\n    capHeight: 800,\n    ascent: 900,\n    descent: -200,\n    fontMatrix: [1, 0, 0, 1, 0, 0],\n    bbox: [0, 0, 1000, 1000],\n    defaultEncoding: { 128: \"Euro\" },\n    toUnicode: new IdentityToUnicodeMap([]),\n    cidEncoding: \"Identity-H\",\n    vertical: false,\n    systemFontInfo: { guessFallback: false, css: \"\" },\n    type: \"CIDFontType2\",\n    subtype: \"Type1\",\n    flags: 0,\n    isSimulatedFlags: false,\n  };\n  const font = new Font(\"HelveticaNeue\", file, properties);\n  const mappedEuro = font.toFontChar[128];\n  const expectedEuro = getGlyphsUnicode()[\"Euro\"];\n  if (mappedEuro !== expectedEuro) {\n    throw new Error(`Expected Euro mapping (${expectedEuro}) but got (${mappedEuro})`);\n  }\n});",
    "i3_gpt-4o": "it(\"should correctly map the Euro character for fonts mapped to a standard font\", async () => {\n  const { Font } = await import(\"../../src/core/fonts.js\");\n  const { getGlyphsUnicode } = await import(\"../../src/core/glyphlist.js\");\n  const { IdentityToUnicodeMap } = await import(\"../../src/core/to_unicode_map.js\");\n  const file = { isEmpty: true };\n  const properties = {\n    loadedName: \"HelveticaNeue\",\n    differences: { 128: \"Euro\" },\n    widths: {},\n    defaultWidth: 600,\n    composite: false,\n    cMap: null,\n    capHeight: 800,\n    ascent: 900,\n    descent: -200,\n    fontMatrix: [1, 0, 0, 1, 0, 0],\n    bbox: [0, 0, 1000, 1000],\n    defaultEncoding: { 128: \"Euro\" },\n    toUnicode: new IdentityToUnicodeMap([]),\n    cidEncoding: \"Identity-H\",\n    vertical: false,\n    systemFontInfo: { guessFallback: false, css: \"\" },\n    type: \"CIDFontType2\",\n    subtype: \"Type1\",\n    flags: 0,\n    isSimulatedFlags: false,\n  };\n  const font = new Font(\"HelveticaNeue\", file, properties);\n  const mappedEuro = font.toFontChar[128];\n  const expectedEuro = getGlyphsUnicode()[\"Euro\"];\n  if (mappedEuro !== expectedEuro) {\n    throw new Error(`Expected Euro mapping (${expectedEuro}) but got (${mappedEuro})`);\n  }\n});",
    "i3_llama-3.3-70b-versatile": "it(\"should correctly map the Euro character for fonts mapped to a standard font\", async () => {\n  const { Font } = await import(\"../../src/core/fonts.js\");\n  const { getGlyphsUnicode } = await import(\"../../src/core/glyphlist.js\");\n  const { IdentityToUnicodeMap } = await import(\"../../src/core/to_unicode_map.js\");\n  const file = { isEmpty: true };\n  const properties = {\n    loadedName: \"HelveticaNeue\",\n    differences: { 128: \"Euro\" },\n    widths: {},\n    defaultWidth: 600,\n    composite: false,\n    cMap: null,\n    capHeight: 800,\n    ascent: 900,\n    descent: -200,\n    fontMatrix: [1, 0, 0, 1, 0, 0],\n    bbox: [0, 0, 1000, 1000],\n    defaultEncoding: { 128: \"Euro\" },\n    toUnicode: new IdentityToUnicodeMap([]),\n    cidEncoding: \"Identity-H\",\n    vertical: false,\n    systemFontInfo: { guessFallback: false, css: \"\" },\n    type: \"CIDFontType2\",\n    subtype: \"Type1\",\n    flags: 0,\n    isSimulatedFlags: false,\n  };\n  const font = new Font(\"HelveticaNeue\", file, properties);\n  const mappedEuro = font.toFontChar[128];\n  const expectedEuro = getGlyphsUnicode()[\"Euro\"];\n  if (mappedEuro !== expectedEuro) {\n    throw new Error(`Expected Euro mapping (${expectedEuro}) but got (${mappedEuro})`);\n  }\n});",
    "i4_deepseek-r1-distill-llama-70b": "it(\"should correctly map the Euro character for fonts mapped to a standard font\", async () => {\n  const { Font } = await import(\"../../src/core/fonts.js\");\n  const { getGlyphsUnicode } = await import(\"../../src/core/glyphlist.js\");\n  const { IdentityToUnicodeMap } = await import(\"../../src/core/to_unicode_map.js\");\n  const file = { isEmpty: true };\n  const properties = {\n    loadedName: \"HelveticaNeue\",\n    differences: { 128: \"Euro\" },\n    widths: {},\n    defaultWidth: 600,\n    composite: false,\n    cMap: null,\n    capHeight: 800,\n    ascent: 900,\n    descent: -200,\n    fontMatrix: [1, 0, 0, 1, 0, 0],\n    bbox: [0, 0, 1000, 1000],\n    defaultEncoding: { 128: \"Euro\" },\n    toUnicode: new IdentityToUnicodeMap([]),\n    cidEncoding: \"Identity-H\",\n    vertical: false,\n    systemFontInfo: { guessFallback: false, css: \"\" },\n    type: \"CIDFontType2\",\n    subtype: \"Type1\",\n    flags: 0,\n    isSimulatedFlags: false,\n  };\n  const font = new Font(\"HelveticaNeue\", file, properties);\n  const mappedEuro = font.toFontChar[128];\n  const expectedEuro = getGlyphsUnicode()[\"Euro\"];\n  if (mappedEuro !== expectedEuro) {\n    throw new Error(`Expected Euro mapping (${expectedEuro}) but got (${mappedEuro})`);\n  }\n});",
    "i4_gpt-4o": "it(\"should correctly map the Euro character for fonts mapped to a standard font\", async () => {\n  const { Font } = await import(\"../../src/core/fonts.js\");\n  const { getGlyphsUnicode } = await import(\"../../src/core/glyphlist.js\");\n  const { IdentityToUnicodeMap } = await import(\"../../src/core/to_unicode_map.js\");\n  const file = { isEmpty: true };\n  const properties = {\n    loadedName: \"HelveticaNeue\",\n    differences: { 128: \"Euro\" },\n    widths: {},\n    defaultWidth: 600,\n    composite: false,\n    cMap: null,\n    capHeight: 800,\n    ascent: 900,\n    descent: -200,\n    fontMatrix: [1, 0, 0, 1, 0, 0],\n    bbox: [0, 0, 1000, 1000],\n    defaultEncoding: { 128: \"Euro\" },\n    toUnicode: new IdentityToUnicodeMap([]),\n    cidEncoding: \"Identity-H\",\n    vertical: false,\n    systemFontInfo: { guessFallback: false, css: \"\" },\n    type: \"CIDFontType2\",\n    subtype: \"Type1\",\n    flags: 0,\n    isSimulatedFlags: false,\n  };\n  const font = new Font(\"HelveticaNeue\", file, properties);\n  const mappedEuro = font.toFontChar[128];\n  const expectedEuro = getGlyphsUnicode()[\"Euro\"];\n  if (mappedEuro !== expectedEuro) {\n    throw new Error(`Expected Euro mapping (${expectedEuro}) but got (${mappedEuro})`);\n  }\n});",
    "i4_llama-3.3-70b-versatile": "it(\"should correctly map the Euro character for fonts mapped to a standard font\", async () => {\n  const { Font } = await import(\"../../src/core/fonts.js\");\n  const { getGlyphsUnicode } = await import(\"../../src/core/glyphlist.js\");\n  const { IdentityToUnicodeMap } = await import(\"../../src/core/to_unicode_map.js\");\n  const file = { isEmpty: true };\n  const properties = {\n    loadedName: \"HelveticaNeue\",\n    differences: { 128: \"Euro\" },\n    widths: {},\n    defaultWidth: 600,\n    composite: false,\n    cMap: null,\n    capHeight: 800,\n    ascent: 900,\n    descent: -200,\n    fontMatrix: [1, 0, 0, 1, 0, 0],\n    bbox: [0, 0, 1000, 1000],\n    defaultEncoding: { 128: \"Euro\" },\n    toUnicode: new IdentityToUnicodeMap([]),\n    cidEncoding: \"Identity-H\",\n    vertical: false,\n    systemFontInfo: { guessFallback: false, css: \"\" },\n    type: \"CIDFontType2\",\n    subtype: \"Type1\",\n    flags: 0,\n    isSimulatedFlags: false,\n  };\n  const font = new Font(\"HelveticaNeue\", file, properties);\n  const mappedEuro = font.toFontChar[128];\n  const expectedEuro = getGlyphsUnicode()[\"Euro\"];\n  if (mappedEuro !== expectedEuro) {\n    throw new Error(`Expected Euro mapping (${expectedEuro}) but got (${mappedEuro})`);\n  }\n});",
    "i5_deepseek-r1-distill-llama-70b": "it(\"should correctly map the Euro character for fonts mapped to a standard font\", async () => {\n  const { Font } = await import(\"../../src/core/fonts.js\");\n  const { getGlyphsUnicode } = await import(\"../../src/core/glyphlist.js\");\n  const { IdentityToUnicodeMap } = await import(\"../../src/core/to_unicode_map.js\");\n  const file = { isEmpty: true };\n  const properties = {\n    loadedName: \"HelveticaNeue\",\n    differences: { 128: \"Euro\" },\n    widths: {},\n    defaultWidth: 600,\n    composite: false,\n    cMap: null,\n    capHeight: 800,\n    ascent: 900,\n    descent: -200,\n    fontMatrix: [1, 0, 0, 1, 0, 0],\n    bbox: [0, 0, 1000, 1000],\n    defaultEncoding: { 128: \"Euro\" },\n    toUnicode: new IdentityToUnicodeMap([]),\n    cidEncoding: \"Identity-H\",\n    vertical: false,\n    systemFontInfo: { guessFallback: false, css: \"\" },\n    type: \"CIDFontType2\",\n    subtype: \"Type1\",\n    flags: 0,\n    isSimulatedFlags: false,\n  };\n  const font = new Font(\"HelveticaNeue\", file, properties);\n  const mappedEuro = font.toFontChar[128];\n  const expectedEuro = getGlyphsUnicode()[\"Euro\"];\n  if (mappedEuro !== expectedEuro) {\n    throw new Error(`Expected Euro mapping (${expectedEuro}) but got (${mappedEuro})`);\n  }\n});",
    "i5_gpt-4o": "it(\"should correctly map the Euro character for fonts mapped to a standard font\", async () => {\n  const { Font } = await import(\"../../src/core/fonts.js\");\n  const { getGlyphsUnicode } = await import(\"../../src/core/glyphlist.js\");\n  const { IdentityToUnicodeMap } = await import(\"../../src/core/to_unicode_map.js\");\n  const file = { isEmpty: true };\n  const properties = {\n    loadedName: \"HelveticaNeue\",\n    differences: { 128: \"Euro\" },\n    widths: {},\n    defaultWidth: 600,\n    composite: false,\n    cMap: null,\n    capHeight: 800,\n    ascent: 900,\n    descent: -200,\n    fontMatrix: [1, 0, 0, 1, 0, 0],\n    bbox: [0, 0, 1000, 1000],\n    defaultEncoding: { 128: \"Euro\" },\n    toUnicode: new IdentityToUnicodeMap([]),\n    cidEncoding: \"Identity-H\",\n    vertical: false,\n    systemFontInfo: { guessFallback: false, css: \"\" },\n    type: \"CIDFontType2\",\n    subtype: \"Type1\",\n    flags: 0,\n    isSimulatedFlags: false,\n  };\n  const font = new Font(\"HelveticaNeue\", file, properties);\n  const mappedEuro = font.toFontChar[128];\n  const expectedEuro = getGlyphsUnicode()[\"Euro\"];\n  if (mappedEuro !== expectedEuro) {\n    throw new Error(`Expected Euro mapping (${expectedEuro}) but got (${mappedEuro})`);\n  }\n});",
    "i5_llama-3.3-70b-versatile": "it(\"should correctly map the Euro character for fonts mapped to a standard font\", async () => {\n  const { Font } = await import(\"../../src/core/fonts.js\");\n  const { getGlyphsUnicode } = await import(\"../../src/core/glyphlist.js\");\n  const { IdentityToUnicodeMap } = await import(\"../../src/core/to_unicode_map.js\");\n  const file = { isEmpty: true };\n  const properties = {\n    loadedName: \"HelveticaNeue\",\n    differences: { 128: \"Euro\" },\n    widths: {},\n    defaultWidth: 600,\n    composite: false,\n    cMap: null,\n    capHeight: 800,\n    ascent: 900,\n    descent: -200,\n    fontMatrix: [1, 0, 0, 1, 0, 0],\n    bbox: [0, 0, 1000, 1000],\n    defaultEncoding: { 128: \"Euro\" },\n    toUnicode: new IdentityToUnicodeMap([]),\n    cidEncoding: \"Identity-H\",\n    vertical: false,\n    systemFontInfo: { guessFallback: false, css: \"\" },\n    type: \"CIDFontType2\",\n    subtype: \"Type1\",\n    flags: 0,\n    isSimulatedFlags: false,\n  };\n  const font = new Font(\"HelveticaNeue\", file, properties);\n  const mappedEuro = font.toFontChar[128];\n  const expectedEuro = getGlyphsUnicode()[\"Euro\"];\n  if (mappedEuro !== expectedEuro) {\n    throw new Error(`Expected Euro mapping (${expectedEuro}) but got (${mappedEuro})`);\n  }\n});"
  },
  "18664": {
    "i1_deepseek-r1-distill-llama-70b": "it(\"should set roleimg on the image canvas when an image is added\", async () => {\n  const { StampEditor } = await import(\"../../src/display/editor/stamp.js\");\n  const parent = {\n    pageIndex: 0,\n    viewport: {\n      rotation: 0,\n      rawDims: { pageWidth: 800, pageHeight: 600, pageX: 0, pageY: 0 }\n    },\n    get parentDimensions() { return [1, 1]; }\n  };\n  const uiManager = {\n    useNewAltTextWhenAddingImage: true,\n    useNewAltTextFlow: false,\n    _signal: new AbortController().signal,\n    enableWaiting: () => {},\n    delete: () => {},\n    viewParameters: { rotation: 0 }\n  };\n  const params = {\n    parent,\n    id: \"testEditor\",\n    uiManager,\n    bitmapUrl: \"dummy\",\n    bitmapFile: null\n  };\n  const editor = new StampEditor(params);\n  // Create a dummy container div if not already created.\n  if (!editor.div) {\n    editor.div = document.createElement(\"div\");\n  }\n  // Provide minimal stub for addAltTextButton to prevent errors.\n  if (typeof editor.addAltTextButton !== \"function\") {\n    editor.addAltTextButton = () => {};\n  }\n  // Provide addContainer if not already available.\n  if (typeof editor.addContainer !== \"function\") {\n    editor.addContainer = function(container) {\n      const toolbarDiv = this._editToolbar && this._editToolbar.div;\n      if (toolbarDiv) {\n        toolbarDiv.before(container);\n      } else {\n        this.div.appendChild(container);\n      }\n    };\n  }\n  editor.render();\n  const canvas = editor.div.querySelector(\"canvas\");\n  if (!canvas) {\n    throw new Error(\"Canvas element was not added to the editor.\");\n  }\n  if (canvas.getAttribute(\"role\") !== \"img\") {\n    throw new Error(\"Expected canvas to have role='img', but got: \" + canvas.getAttribute(\"role\"));\n  }\n});\n",
    "i1_gpt-4o": "it(\"should set roleimg on the image canvas when an image is added\", async () => {\n  const { StampEditor } = await import(\"../../src/display/editor/stamp.js\");\n  const parent = {\n    pageIndex: 0,\n    viewport: {\n      rotation: 0,\n      rawDims: { pageWidth: 800, pageHeight: 600, pageX: 0, pageY: 0 }\n    },\n    get parentDimensions() { return [1, 1]; }\n  };\n  const uiManager = {\n    useNewAltTextWhenAddingImage: true,\n    useNewAltTextFlow: false,\n    _signal: new AbortController().signal,\n    enableWaiting: () => {},\n    delete: () => {},\n    viewParameters: { rotation: 0 }\n  };\n  const params = {\n    parent,\n    id: \"testEditor\",\n    uiManager,\n    bitmapUrl: \"dummy\",\n    bitmapFile: null\n  };\n  const editor = new StampEditor(params);\n  // Create a dummy container div if not already created.\n  if (!editor.div) {\n    editor.div = document.createElement(\"div\");\n  }\n  // Provide minimal stub for addAltTextButton to prevent errors.\n  if (typeof editor.addAltTextButton !== \"function\") {\n    editor.addAltTextButton = () => {};\n  }\n  // Provide addContainer if not already available.\n  if (typeof editor.addContainer !== \"function\") {\n    editor.addContainer = function(container) {\n      const toolbarDiv = this._editToolbar && this._editToolbar.div;\n      if (toolbarDiv) {\n        toolbarDiv.before(container);\n      } else {\n        this.div.appendChild(container);\n      }\n    };\n  }\n  editor.render();\n  const canvas = editor.div.querySelector(\"canvas\");\n  if (!canvas) {\n    throw new Error(\"Canvas element was not added to the editor.\");\n  }\n  if (canvas.getAttribute(\"role\") !== \"img\") {\n    throw new Error(\"Expected canvas to have role='img', but got: \" + canvas.getAttribute(\"role\"));\n  }\n});\n",
    "i1_llama-3.3-70b-versatile": "it(\"should set roleimg on the image canvas when an image is added\", async () => {\n  const { StampEditor } = await import(\"../../src/display/editor/stamp.js\");\n  const parent = {\n    pageIndex: 0,\n    viewport: {\n      rotation: 0,\n      rawDims: { pageWidth: 800, pageHeight: 600, pageX: 0, pageY: 0 }\n    },\n    get parentDimensions() { return [1, 1]; }\n  };\n  const uiManager = {\n    useNewAltTextWhenAddingImage: true,\n    useNewAltTextFlow: false,\n    _signal: new AbortController().signal,\n    enableWaiting: () => {},\n    delete: () => {},\n    viewParameters: { rotation: 0 }\n  };\n  const params = {\n    parent,\n    id: \"testEditor\",\n    uiManager,\n    bitmapUrl: \"dummy\",\n    bitmapFile: null\n  };\n  const editor = new StampEditor(params);\n  // Create a dummy container div if not already created.\n  if (!editor.div) {\n    editor.div = document.createElement(\"div\");\n  }\n  // Provide minimal stub for addAltTextButton to prevent errors.\n  if (typeof editor.addAltTextButton !== \"function\") {\n    editor.addAltTextButton = () => {};\n  }\n  // Provide addContainer if not already available.\n  if (typeof editor.addContainer !== \"function\") {\n    editor.addContainer = function(container) {\n      const toolbarDiv = this._editToolbar && this._editToolbar.div;\n      if (toolbarDiv) {\n        toolbarDiv.before(container);\n      } else {\n        this.div.appendChild(container);\n      }\n    };\n  }\n  editor.render();\n  const canvas = editor.div.querySelector(\"canvas\");\n  if (!canvas) {\n    throw new Error(\"Canvas element was not added to the editor.\");\n  }\n  if (canvas.getAttribute(\"role\") !== \"img\") {\n    throw new Error(\"Expected canvas to have role='img', but got: \" + canvas.getAttribute(\"role\"));\n  }\n});\n",
    "i1_MOCK": "it(\"should set roleimg on the image canvas when an image is added\", async () => {\n  const { StampEditor } = await import(\"../../src/display/editor/stamp.js\");\n  const parent = {\n    pageIndex: 0,\n    viewport: {\n      rotation: 0,\n      rawDims: { pageWidth: 800, pageHeight: 600, pageX: 0, pageY: 0 }\n    },\n    get parentDimensions() { return [1, 1]; }\n  };\n  const uiManager = {\n    useNewAltTextWhenAddingImage: true,\n    useNewAltTextFlow: false,\n    _signal: new AbortController().signal,\n    enableWaiting: () => {},\n    delete: () => {},\n    viewParameters: { rotation: 0 }\n  };\n  const params = {\n    parent,\n    id: \"testEditor\",\n    uiManager,\n    bitmapUrl: \"dummy\",\n    bitmapFile: null\n  };\n  const editor = new StampEditor(params);\n  // Create a dummy container div if not already created.\n  if (!editor.div) {\n    editor.div = document.createElement(\"div\");\n  }\n  // Provide minimal stub for addAltTextButton to prevent errors.\n  if (typeof editor.addAltTextButton !== \"function\") {\n    editor.addAltTextButton = () => {};\n  }\n  // Provide addContainer if not already available.\n  if (typeof editor.addContainer !== \"function\") {\n    editor.addContainer = function(container) {\n      const toolbarDiv = this._editToolbar && this._editToolbar.div;\n      if (toolbarDiv) {\n        toolbarDiv.before(container);\n      } else {\n        this.div.appendChild(container);\n      }\n    };\n  }\n  editor.render();\n  const canvas = editor.div.querySelector(\"canvas\");\n  if (!canvas) {\n    throw new Error(\"Canvas element was not added to the editor.\");\n  }\n  if (canvas.getAttribute(\"role\") !== \"img\") {\n    throw new Error(\"Expected canvas to have role='img', but got: \" + canvas.getAttribute(\"role\"));\n  }\n});\n",
    "i2_deepseek-r1-distill-llama-70b": "it(\"should set roleimg on the image canvas when an image is added\", async () => {\n  const { StampEditor } = await import(\"../../src/display/editor/stamp.js\");\n  const parent = {\n    pageIndex: 0,\n    viewport: {\n      rotation: 0,\n      rawDims: { pageWidth: 800, pageHeight: 600, pageX: 0, pageY: 0 }\n    },\n    get parentDimensions() { return [1, 1]; }\n  };\n  const uiManager = {\n    useNewAltTextWhenAddingImage: true,\n    useNewAltTextFlow: false,\n    _signal: new AbortController().signal,\n    enableWaiting: () => {},\n    delete: () => {},\n    viewParameters: { rotation: 0 }\n  };\n  const params = {\n    parent,\n    id: \"testEditor\",\n    uiManager,\n    bitmapUrl: \"dummy\",\n    bitmapFile: null\n  };\n  const editor = new StampEditor(params);\n  // Create a dummy container div if not already created.\n  if (!editor.div) {\n    editor.div = document.createElement(\"div\");\n  }\n  // Provide minimal stub for addAltTextButton to prevent errors.\n  if (typeof editor.addAltTextButton !== \"function\") {\n    editor.addAltTextButton = () => {};\n  }\n  // Provide addContainer if not already available.\n  if (typeof editor.addContainer !== \"function\") {\n    editor.addContainer = function(container) {\n      const toolbarDiv = this._editToolbar && this._editToolbar.div;\n      if (toolbarDiv) {\n        toolbarDiv.before(container);\n      } else {\n        this.div.appendChild(container);\n      }\n    };\n  }\n  editor.render();\n  const canvas = editor.div.querySelector(\"canvas\");\n  if (!canvas) {\n    throw new Error(\"Canvas element was not added to the editor.\");\n  }\n  if (canvas.getAttribute(\"role\") !== \"img\") {\n    throw new Error(\"Expected canvas to have role='img', but got: \" + canvas.getAttribute(\"role\"));\n  }\n});\n",
    "i2_gpt-4o": "it(\"should set roleimg on the image canvas when an image is added\", async () => {\n  const { StampEditor } = await import(\"../../src/display/editor/stamp.js\");\n  const parent = {\n    pageIndex: 0,\n    viewport: {\n      rotation: 0,\n      rawDims: { pageWidth: 800, pageHeight: 600, pageX: 0, pageY: 0 }\n    },\n    get parentDimensions() { return [1, 1]; }\n  };\n  const uiManager = {\n    useNewAltTextWhenAddingImage: true,\n    useNewAltTextFlow: false,\n    _signal: new AbortController().signal,\n    enableWaiting: () => {},\n    delete: () => {},\n    viewParameters: { rotation: 0 }\n  };\n  const params = {\n    parent,\n    id: \"testEditor\",\n    uiManager,\n    bitmapUrl: \"dummy\",\n    bitmapFile: null\n  };\n  const editor = new StampEditor(params);\n  // Create a dummy container div if not already created.\n  if (!editor.div) {\n    editor.div = document.createElement(\"div\");\n  }\n  // Provide minimal stub for addAltTextButton to prevent errors.\n  if (typeof editor.addAltTextButton !== \"function\") {\n    editor.addAltTextButton = () => {};\n  }\n  // Provide addContainer if not already available.\n  if (typeof editor.addContainer !== \"function\") {\n    editor.addContainer = function(container) {\n      const toolbarDiv = this._editToolbar && this._editToolbar.div;\n      if (toolbarDiv) {\n        toolbarDiv.before(container);\n      } else {\n        this.div.appendChild(container);\n      }\n    };\n  }\n  editor.render();\n  const canvas = editor.div.querySelector(\"canvas\");\n  if (!canvas) {\n    throw new Error(\"Canvas element was not added to the editor.\");\n  }\n  if (canvas.getAttribute(\"role\") !== \"img\") {\n    throw new Error(\"Expected canvas to have role='img', but got: \" + canvas.getAttribute(\"role\"));\n  }\n});\n",
    "i2_llama-3.3-70b-versatile": "it(\"should set roleimg on the image canvas when an image is added\", async () => {\n  const { StampEditor } = await import(\"../../src/display/editor/stamp.js\");\n  const parent = {\n    pageIndex: 0,\n    viewport: {\n      rotation: 0,\n      rawDims: { pageWidth: 800, pageHeight: 600, pageX: 0, pageY: 0 }\n    },\n    get parentDimensions() { return [1, 1]; }\n  };\n  const uiManager = {\n    useNewAltTextWhenAddingImage: true,\n    useNewAltTextFlow: false,\n    _signal: new AbortController().signal,\n    enableWaiting: () => {},\n    delete: () => {},\n    viewParameters: { rotation: 0 }\n  };\n  const params = {\n    parent,\n    id: \"testEditor\",\n    uiManager,\n    bitmapUrl: \"dummy\",\n    bitmapFile: null\n  };\n  const editor = new StampEditor(params);\n  // Create a dummy container div if not already created.\n  if (!editor.div) {\n    editor.div = document.createElement(\"div\");\n  }\n  // Provide minimal stub for addAltTextButton to prevent errors.\n  if (typeof editor.addAltTextButton !== \"function\") {\n    editor.addAltTextButton = () => {};\n  }\n  // Provide addContainer if not already available.\n  if (typeof editor.addContainer !== \"function\") {\n    editor.addContainer = function(container) {\n      const toolbarDiv = this._editToolbar && this._editToolbar.div;\n      if (toolbarDiv) {\n        toolbarDiv.before(container);\n      } else {\n        this.div.appendChild(container);\n      }\n    };\n  }\n  editor.render();\n  const canvas = editor.div.querySelector(\"canvas\");\n  if (!canvas) {\n    throw new Error(\"Canvas element was not added to the editor.\");\n  }\n  if (canvas.getAttribute(\"role\") !== \"img\") {\n    throw new Error(\"Expected canvas to have role='img', but got: \" + canvas.getAttribute(\"role\"));\n  }\n});\n",
    "i3_deepseek-r1-distill-llama-70b": "it(\"should set roleimg on the image canvas when an image is added\", async () => {\n  const { StampEditor } = await import(\"../../src/display/editor/stamp.js\");\n  const parent = {\n    pageIndex: 0,\n    viewport: {\n      rotation: 0,\n      rawDims: { pageWidth: 800, pageHeight: 600, pageX: 0, pageY: 0 }\n    },\n    get parentDimensions() { return [1, 1]; }\n  };\n  const uiManager = {\n    useNewAltTextWhenAddingImage: true,\n    useNewAltTextFlow: false,\n    _signal: new AbortController().signal,\n    enableWaiting: () => {},\n    delete: () => {},\n    viewParameters: { rotation: 0 }\n  };\n  const params = {\n    parent,\n    id: \"testEditor\",\n    uiManager,\n    bitmapUrl: \"dummy\",\n    bitmapFile: null\n  };\n  const editor = new StampEditor(params);\n  // Create a dummy container div if not already created.\n  if (!editor.div) {\n    editor.div = document.createElement(\"div\");\n  }\n  // Provide minimal stub for addAltTextButton to prevent errors.\n  if (typeof editor.addAltTextButton !== \"function\") {\n    editor.addAltTextButton = () => {};\n  }\n  // Provide addContainer if not already available.\n  if (typeof editor.addContainer !== \"function\") {\n    editor.addContainer = function(container) {\n      const toolbarDiv = this._editToolbar && this._editToolbar.div;\n      if (toolbarDiv) {\n        toolbarDiv.before(container);\n      } else {\n        this.div.appendChild(container);\n      }\n    };\n  }\n  editor.render();\n  const canvas = editor.div.querySelector(\"canvas\");\n  if (!canvas) {\n    throw new Error(\"Canvas element was not added to the editor.\");\n  }\n  if (canvas.getAttribute(\"role\") !== \"img\") {\n    throw new Error(\"Expected canvas to have role='img', but got: \" + canvas.getAttribute(\"role\"));\n  }\n});\n",
    "i3_gpt-4o": "it(\"should set roleimg on the image canvas when an image is added\", async () => {\n  const { StampEditor } = await import(\"../../src/display/editor/stamp.js\");\n  const parent = {\n    pageIndex: 0,\n    viewport: {\n      rotation: 0,\n      rawDims: { pageWidth: 800, pageHeight: 600, pageX: 0, pageY: 0 }\n    },\n    get parentDimensions() { return [1, 1]; }\n  };\n  const uiManager = {\n    useNewAltTextWhenAddingImage: true,\n    useNewAltTextFlow: false,\n    _signal: new AbortController().signal,\n    enableWaiting: () => {},\n    delete: () => {},\n    viewParameters: { rotation: 0 }\n  };\n  const params = {\n    parent,\n    id: \"testEditor\",\n    uiManager,\n    bitmapUrl: \"dummy\",\n    bitmapFile: null\n  };\n  const editor = new StampEditor(params);\n  // Create a dummy container div if not already created.\n  if (!editor.div) {\n    editor.div = document.createElement(\"div\");\n  }\n  // Provide minimal stub for addAltTextButton to prevent errors.\n  if (typeof editor.addAltTextButton !== \"function\") {\n    editor.addAltTextButton = () => {};\n  }\n  // Provide addContainer if not already available.\n  if (typeof editor.addContainer !== \"function\") {\n    editor.addContainer = function(container) {\n      const toolbarDiv = this._editToolbar && this._editToolbar.div;\n      if (toolbarDiv) {\n        toolbarDiv.before(container);\n      } else {\n        this.div.appendChild(container);\n      }\n    };\n  }\n  editor.render();\n  const canvas = editor.div.querySelector(\"canvas\");\n  if (!canvas) {\n    throw new Error(\"Canvas element was not added to the editor.\");\n  }\n  if (canvas.getAttribute(\"role\") !== \"img\") {\n    throw new Error(\"Expected canvas to have role='img', but got: \" + canvas.getAttribute(\"role\"));\n  }\n});\n",
    "i3_llama-3.3-70b-versatile": "it(\"should set roleimg on the image canvas when an image is added\", async () => {\n  const { StampEditor } = await import(\"../../src/display/editor/stamp.js\");\n  const parent = {\n    pageIndex: 0,\n    viewport: {\n      rotation: 0,\n      rawDims: { pageWidth: 800, pageHeight: 600, pageX: 0, pageY: 0 }\n    },\n    get parentDimensions() { return [1, 1]; }\n  };\n  const uiManager = {\n    useNewAltTextWhenAddingImage: true,\n    useNewAltTextFlow: false,\n    _signal: new AbortController().signal,\n    enableWaiting: () => {},\n    delete: () => {},\n    viewParameters: { rotation: 0 }\n  };\n  const params = {\n    parent,\n    id: \"testEditor\",\n    uiManager,\n    bitmapUrl: \"dummy\",\n    bitmapFile: null\n  };\n  const editor = new StampEditor(params);\n  // Create a dummy container div if not already created.\n  if (!editor.div) {\n    editor.div = document.createElement(\"div\");\n  }\n  // Provide minimal stub for addAltTextButton to prevent errors.\n  if (typeof editor.addAltTextButton !== \"function\") {\n    editor.addAltTextButton = () => {};\n  }\n  // Provide addContainer if not already available.\n  if (typeof editor.addContainer !== \"function\") {\n    editor.addContainer = function(container) {\n      const toolbarDiv = this._editToolbar && this._editToolbar.div;\n      if (toolbarDiv) {\n        toolbarDiv.before(container);\n      } else {\n        this.div.appendChild(container);\n      }\n    };\n  }\n  editor.render();\n  const canvas = editor.div.querySelector(\"canvas\");\n  if (!canvas) {\n    throw new Error(\"Canvas element was not added to the editor.\");\n  }\n  if (canvas.getAttribute(\"role\") !== \"img\") {\n    throw new Error(\"Expected canvas to have role='img', but got: \" + canvas.getAttribute(\"role\"));\n  }\n});\n",
    "i4_deepseek-r1-distill-llama-70b": "it(\"should set roleimg on the image canvas when an image is added\", async () => {\n  const { StampEditor } = await import(\"../../src/display/editor/stamp.js\");\n  const parent = {\n    pageIndex: 0,\n    viewport: {\n      rotation: 0,\n      rawDims: { pageWidth: 800, pageHeight: 600, pageX: 0, pageY: 0 }\n    },\n    get parentDimensions() { return [1, 1]; }\n  };\n  const uiManager = {\n    useNewAltTextWhenAddingImage: true,\n    useNewAltTextFlow: false,\n    _signal: new AbortController().signal,\n    enableWaiting: () => {},\n    delete: () => {},\n    viewParameters: { rotation: 0 }\n  };\n  const params = {\n    parent,\n    id: \"testEditor\",\n    uiManager,\n    bitmapUrl: \"dummy\",\n    bitmapFile: null\n  };\n  const editor = new StampEditor(params);\n  // Create a dummy container div if not already created.\n  if (!editor.div) {\n    editor.div = document.createElement(\"div\");\n  }\n  // Provide minimal stub for addAltTextButton to prevent errors.\n  if (typeof editor.addAltTextButton !== \"function\") {\n    editor.addAltTextButton = () => {};\n  }\n  // Provide addContainer if not already available.\n  if (typeof editor.addContainer !== \"function\") {\n    editor.addContainer = function(container) {\n      const toolbarDiv = this._editToolbar && this._editToolbar.div;\n      if (toolbarDiv) {\n        toolbarDiv.before(container);\n      } else {\n        this.div.appendChild(container);\n      }\n    };\n  }\n  editor.render();\n  const canvas = editor.div.querySelector(\"canvas\");\n  if (!canvas) {\n    throw new Error(\"Canvas element was not added to the editor.\");\n  }\n  if (canvas.getAttribute(\"role\") !== \"img\") {\n    throw new Error(\"Expected canvas to have role='img', but got: \" + canvas.getAttribute(\"role\"));\n  }\n});\n",
    "i4_gpt-4o": "it(\"should set roleimg on the image canvas when an image is added\", async () => {\n  const { StampEditor } = await import(\"../../src/display/editor/stamp.js\");\n  const parent = {\n    pageIndex: 0,\n    viewport: {\n      rotation: 0,\n      rawDims: { pageWidth: 800, pageHeight: 600, pageX: 0, pageY: 0 }\n    },\n    get parentDimensions() { return [1, 1]; }\n  };\n  const uiManager = {\n    useNewAltTextWhenAddingImage: true,\n    useNewAltTextFlow: false,\n    _signal: new AbortController().signal,\n    enableWaiting: () => {},\n    delete: () => {},\n    viewParameters: { rotation: 0 }\n  };\n  const params = {\n    parent,\n    id: \"testEditor\",\n    uiManager,\n    bitmapUrl: \"dummy\",\n    bitmapFile: null\n  };\n  const editor = new StampEditor(params);\n  // Create a dummy container div if not already created.\n  if (!editor.div) {\n    editor.div = document.createElement(\"div\");\n  }\n  // Provide minimal stub for addAltTextButton to prevent errors.\n  if (typeof editor.addAltTextButton !== \"function\") {\n    editor.addAltTextButton = () => {};\n  }\n  // Provide addContainer if not already available.\n  if (typeof editor.addContainer !== \"function\") {\n    editor.addContainer = function(container) {\n      const toolbarDiv = this._editToolbar && this._editToolbar.div;\n      if (toolbarDiv) {\n        toolbarDiv.before(container);\n      } else {\n        this.div.appendChild(container);\n      }\n    };\n  }\n  editor.render();\n  const canvas = editor.div.querySelector(\"canvas\");\n  if (!canvas) {\n    throw new Error(\"Canvas element was not added to the editor.\");\n  }\n  if (canvas.getAttribute(\"role\") !== \"img\") {\n    throw new Error(\"Expected canvas to have role='img', but got: \" + canvas.getAttribute(\"role\"));\n  }\n});\n",
    "i4_llama-3.3-70b-versatile": "it(\"should set roleimg on the image canvas when an image is added\", async () => {\n  const { StampEditor } = await import(\"../../src/display/editor/stamp.js\");\n  const parent = {\n    pageIndex: 0,\n    viewport: {\n      rotation: 0,\n      rawDims: { pageWidth: 800, pageHeight: 600, pageX: 0, pageY: 0 }\n    },\n    get parentDimensions() { return [1, 1]; }\n  };\n  const uiManager = {\n    useNewAltTextWhenAddingImage: true,\n    useNewAltTextFlow: false,\n    _signal: new AbortController().signal,\n    enableWaiting: () => {},\n    delete: () => {},\n    viewParameters: { rotation: 0 }\n  };\n  const params = {\n    parent,\n    id: \"testEditor\",\n    uiManager,\n    bitmapUrl: \"dummy\",\n    bitmapFile: null\n  };\n  const editor = new StampEditor(params);\n  // Create a dummy container div if not already created.\n  if (!editor.div) {\n    editor.div = document.createElement(\"div\");\n  }\n  // Provide minimal stub for addAltTextButton to prevent errors.\n  if (typeof editor.addAltTextButton !== \"function\") {\n    editor.addAltTextButton = () => {};\n  }\n  // Provide addContainer if not already available.\n  if (typeof editor.addContainer !== \"function\") {\n    editor.addContainer = function(container) {\n      const toolbarDiv = this._editToolbar && this._editToolbar.div;\n      if (toolbarDiv) {\n        toolbarDiv.before(container);\n      } else {\n        this.div.appendChild(container);\n      }\n    };\n  }\n  editor.render();\n  const canvas = editor.div.querySelector(\"canvas\");\n  if (!canvas) {\n    throw new Error(\"Canvas element was not added to the editor.\");\n  }\n  if (canvas.getAttribute(\"role\") !== \"img\") {\n    throw new Error(\"Expected canvas to have role='img', but got: \" + canvas.getAttribute(\"role\"));\n  }\n});\n",
    "i5_deepseek-r1-distill-llama-70b": "it(\"should set roleimg on the image canvas when an image is added\", async () => {\n  const { StampEditor } = await import(\"../../src/display/editor/stamp.js\");\n  const parent = {\n    pageIndex: 0,\n    viewport: {\n      rotation: 0,\n      rawDims: { pageWidth: 800, pageHeight: 600, pageX: 0, pageY: 0 }\n    },\n    get parentDimensions() { return [1, 1]; }\n  };\n  const uiManager = {\n    useNewAltTextWhenAddingImage: true,\n    useNewAltTextFlow: false,\n    _signal: new AbortController().signal,\n    enableWaiting: () => {},\n    delete: () => {},\n    viewParameters: { rotation: 0 }\n  };\n  const params = {\n    parent,\n    id: \"testEditor\",\n    uiManager,\n    bitmapUrl: \"dummy\",\n    bitmapFile: null\n  };\n  const editor = new StampEditor(params);\n  // Create a dummy container div if not already created.\n  if (!editor.div) {\n    editor.div = document.createElement(\"div\");\n  }\n  // Provide minimal stub for addAltTextButton to prevent errors.\n  if (typeof editor.addAltTextButton !== \"function\") {\n    editor.addAltTextButton = () => {};\n  }\n  // Provide addContainer if not already available.\n  if (typeof editor.addContainer !== \"function\") {\n    editor.addContainer = function(container) {\n      const toolbarDiv = this._editToolbar && this._editToolbar.div;\n      if (toolbarDiv) {\n        toolbarDiv.before(container);\n      } else {\n        this.div.appendChild(container);\n      }\n    };\n  }\n  editor.render();\n  const canvas = editor.div.querySelector(\"canvas\");\n  if (!canvas) {\n    throw new Error(\"Canvas element was not added to the editor.\");\n  }\n  if (canvas.getAttribute(\"role\") !== \"img\") {\n    throw new Error(\"Expected canvas to have role='img', but got: \" + canvas.getAttribute(\"role\"));\n  }\n});\n",
    "i5_gpt-4o": "it(\"should set roleimg on the image canvas when an image is added\", async () => {\n  const { StampEditor } = await import(\"../../src/display/editor/stamp.js\");\n  const parent = {\n    pageIndex: 0,\n    viewport: {\n      rotation: 0,\n      rawDims: { pageWidth: 800, pageHeight: 600, pageX: 0, pageY: 0 }\n    },\n    get parentDimensions() { return [1, 1]; }\n  };\n  const uiManager = {\n    useNewAltTextWhenAddingImage: true,\n    useNewAltTextFlow: false,\n    _signal: new AbortController().signal,\n    enableWaiting: () => {},\n    delete: () => {},\n    viewParameters: { rotation: 0 }\n  };\n  const params = {\n    parent,\n    id: \"testEditor\",\n    uiManager,\n    bitmapUrl: \"dummy\",\n    bitmapFile: null\n  };\n  const editor = new StampEditor(params);\n  // Create a dummy container div if not already created.\n  if (!editor.div) {\n    editor.div = document.createElement(\"div\");\n  }\n  // Provide minimal stub for addAltTextButton to prevent errors.\n  if (typeof editor.addAltTextButton !== \"function\") {\n    editor.addAltTextButton = () => {};\n  }\n  // Provide addContainer if not already available.\n  if (typeof editor.addContainer !== \"function\") {\n    editor.addContainer = function(container) {\n      const toolbarDiv = this._editToolbar && this._editToolbar.div;\n      if (toolbarDiv) {\n        toolbarDiv.before(container);\n      } else {\n        this.div.appendChild(container);\n      }\n    };\n  }\n  editor.render();\n  const canvas = editor.div.querySelector(\"canvas\");\n  if (!canvas) {\n    throw new Error(\"Canvas element was not added to the editor.\");\n  }\n  if (canvas.getAttribute(\"role\") !== \"img\") {\n    throw new Error(\"Expected canvas to have role='img', but got: \" + canvas.getAttribute(\"role\"));\n  }\n});\n",
    "i5_llama-3.3-70b-versatile": "it(\"should set roleimg on the image canvas when an image is added\", async () => {\n  const { StampEditor } = await import(\"../../src/display/editor/stamp.js\");\n  const parent = {\n    pageIndex: 0,\n    viewport: {\n      rotation: 0,\n      rawDims: { pageWidth: 800, pageHeight: 600, pageX: 0, pageY: 0 }\n    },\n    get parentDimensions() { return [1, 1]; }\n  };\n  const uiManager = {\n    useNewAltTextWhenAddingImage: true,\n    useNewAltTextFlow: false,\n    _signal: new AbortController().signal,\n    enableWaiting: () => {},\n    delete: () => {},\n    viewParameters: { rotation: 0 }\n  };\n  const params = {\n    parent,\n    id: \"testEditor\",\n    uiManager,\n    bitmapUrl: \"dummy\",\n    bitmapFile: null\n  };\n  const editor = new StampEditor(params);\n  // Create a dummy container div if not already created.\n  if (!editor.div) {\n    editor.div = document.createElement(\"div\");\n  }\n  // Provide minimal stub for addAltTextButton to prevent errors.\n  if (typeof editor.addAltTextButton !== \"function\") {\n    editor.addAltTextButton = () => {};\n  }\n  // Provide addContainer if not already available.\n  if (typeof editor.addContainer !== \"function\") {\n    editor.addContainer = function(container) {\n      const toolbarDiv = this._editToolbar && this._editToolbar.div;\n      if (toolbarDiv) {\n        toolbarDiv.before(container);\n      } else {\n        this.div.appendChild(container);\n      }\n    };\n  }\n  editor.render();\n  const canvas = editor.div.querySelector(\"canvas\");\n  if (!canvas) {\n    throw new Error(\"Canvas element was not added to the editor.\");\n  }\n  if (canvas.getAttribute(\"role\") !== \"img\") {\n    throw new Error(\"Expected canvas to have role='img', but got: \" + canvas.getAttribute(\"role\"));\n  }\n});\n"
  },
  "18726": {
    "i1_deepseek-r1-distill-llama-70b": "it(\"should call endPath before clipping and begin a new path for annotation rendering\", async () => {\n  const log = [];\n  const fakeCtx = {\n    canvas: { width: 200, height: 200 },\n    rect(x, y, w, h) { log.push(\"rect\"); },\n    clip() { log.push(\"clip\"); },\n    beginPath() { log.push(\"beginPath\"); },\n    save() {},\n    setTransform() {}\n  };\n  const { CanvasGraphics } = await import(\"../../src/display/canvas.js\");\n  // Create a minimal dummy canvasFactory that won't be used in this branch.\n  const dummyCanvasFactory = { create: (w, h) => ({ canvas: { width: w, height: h }, context: fakeCtx }) };\n  const cg = new CanvasGraphics(fakeCtx, {}, {}, dummyCanvasFactory, null, { optionalContentConfig: null, markedContentStack: null }, new Map(), null);\n  // Override endPath to log and avoid any internal logic.\n  cg.endPath = function() { log.push(\"endPath\"); };\n  const rect = [0, 0, 100, 50], transform = [1, 0, 0, 1, 0, 0], matrix = [1, 0, 0, 1, 0, 0];\n  // hasOwnCanvas is false to ensure the else branch is executed.\n  cg.beginAnnotation(\"testAnnot\", rect, transform, matrix, false);\n  if (log.join(\",\") !== \"endPath,rect,clip,beginPath\") {\n    throw new Error(\"Expected call order 'endPath,rect,clip,beginPath' but got: \" + log.join(\",\"));\n  }\n});\n",
    "i1_gpt-4o": "it(\"should call endPath before clipping and begin a new path for annotation rendering\", async () => {\n  const log = [];\n  const fakeCtx = {\n    canvas: { width: 200, height: 200 },\n    rect(x, y, w, h) { log.push(\"rect\"); },\n    clip() { log.push(\"clip\"); },\n    beginPath() { log.push(\"beginPath\"); },\n    save() {},\n    setTransform() {}\n  };\n  const { CanvasGraphics } = await import(\"../../src/display/canvas.js\");\n  // Create a minimal dummy canvasFactory that won't be used in this branch.\n  const dummyCanvasFactory = { create: (w, h) => ({ canvas: { width: w, height: h }, context: fakeCtx }) };\n  const cg = new CanvasGraphics(fakeCtx, {}, {}, dummyCanvasFactory, null, { optionalContentConfig: null, markedContentStack: null }, new Map(), null);\n  // Override endPath to log and avoid any internal logic.\n  cg.endPath = function() { log.push(\"endPath\"); };\n  const rect = [0, 0, 100, 50], transform = [1, 0, 0, 1, 0, 0], matrix = [1, 0, 0, 1, 0, 0];\n  // hasOwnCanvas is false to ensure the else branch is executed.\n  cg.beginAnnotation(\"testAnnot\", rect, transform, matrix, false);\n  if (log.join(\",\") !== \"endPath,rect,clip,beginPath\") {\n    throw new Error(\"Expected call order 'endPath,rect,clip,beginPath' but got: \" + log.join(\",\"));\n  }\n});\n",
    "i1_llama-3.3-70b-versatile": "it(\"should call endPath before clipping and begin a new path for annotation rendering\", async () => {\n  const log = [];\n  const fakeCtx = {\n    canvas: { width: 200, height: 200 },\n    rect(x, y, w, h) { log.push(\"rect\"); },\n    clip() { log.push(\"clip\"); },\n    beginPath() { log.push(\"beginPath\"); },\n    save() {},\n    setTransform() {}\n  };\n  const { CanvasGraphics } = await import(\"../../src/display/canvas.js\");\n  // Create a minimal dummy canvasFactory that won't be used in this branch.\n  const dummyCanvasFactory = { create: (w, h) => ({ canvas: { width: w, height: h }, context: fakeCtx }) };\n  const cg = new CanvasGraphics(fakeCtx, {}, {}, dummyCanvasFactory, null, { optionalContentConfig: null, markedContentStack: null }, new Map(), null);\n  // Override endPath to log and avoid any internal logic.\n  cg.endPath = function() { log.push(\"endPath\"); };\n  const rect = [0, 0, 100, 50], transform = [1, 0, 0, 1, 0, 0], matrix = [1, 0, 0, 1, 0, 0];\n  // hasOwnCanvas is false to ensure the else branch is executed.\n  cg.beginAnnotation(\"testAnnot\", rect, transform, matrix, false);\n  if (log.join(\",\") !== \"endPath,rect,clip,beginPath\") {\n    throw new Error(\"Expected call order 'endPath,rect,clip,beginPath' but got: \" + log.join(\",\"));\n  }\n});\n",
    "i1_MOCK": "it(\"should call endPath before clipping and begin a new path for annotation rendering\", async () => {\n  const log = [];\n  const fakeCtx = {\n    canvas: { width: 200, height: 200 },\n    rect(x, y, w, h) { log.push(\"rect\"); },\n    clip() { log.push(\"clip\"); },\n    beginPath() { log.push(\"beginPath\"); },\n    save() {},\n    setTransform() {}\n  };\n  const { CanvasGraphics } = await import(\"../../src/display/canvas.js\");\n  // Create a minimal dummy canvasFactory that won't be used in this branch.\n  const dummyCanvasFactory = { create: (w, h) => ({ canvas: { width: w, height: h }, context: fakeCtx }) };\n  const cg = new CanvasGraphics(fakeCtx, {}, {}, dummyCanvasFactory, null, { optionalContentConfig: null, markedContentStack: null }, new Map(), null);\n  // Override endPath to log and avoid any internal logic.\n  cg.endPath = function() { log.push(\"endPath\"); };\n  const rect = [0, 0, 100, 50], transform = [1, 0, 0, 1, 0, 0], matrix = [1, 0, 0, 1, 0, 0];\n  // hasOwnCanvas is false to ensure the else branch is executed.\n  cg.beginAnnotation(\"testAnnot\", rect, transform, matrix, false);\n  if (log.join(\",\") !== \"endPath,rect,clip,beginPath\") {\n    throw new Error(\"Expected call order 'endPath,rect,clip,beginPath' but got: \" + log.join(\",\"));\n  }\n});\n",
    "i2_deepseek-r1-distill-llama-70b": "it(\"should call endPath before clipping and begin a new path for annotation rendering\", async () => {\n  const log = [];\n  const fakeCtx = {\n    canvas: { width: 200, height: 200 },\n    rect(x, y, w, h) { log.push(\"rect\"); },\n    clip() { log.push(\"clip\"); },\n    beginPath() { log.push(\"beginPath\"); },\n    save() {},\n    setTransform() {}\n  };\n  const { CanvasGraphics } = await import(\"../../src/display/canvas.js\");\n  // Create a minimal dummy canvasFactory that won't be used in this branch.\n  const dummyCanvasFactory = { create: (w, h) => ({ canvas: { width: w, height: h }, context: fakeCtx }) };\n  const cg = new CanvasGraphics(fakeCtx, {}, {}, dummyCanvasFactory, null, { optionalContentConfig: null, markedContentStack: null }, new Map(), null);\n  // Override endPath to log and avoid any internal logic.\n  cg.endPath = function() { log.push(\"endPath\"); };\n  const rect = [0, 0, 100, 50], transform = [1, 0, 0, 1, 0, 0], matrix = [1, 0, 0, 1, 0, 0];\n  // hasOwnCanvas is false to ensure the else branch is executed.\n  cg.beginAnnotation(\"testAnnot\", rect, transform, matrix, false);\n  if (log.join(\",\") !== \"endPath,rect,clip,beginPath\") {\n    throw new Error(\"Expected call order 'endPath,rect,clip,beginPath' but got: \" + log.join(\",\"));\n  }\n});\n",
    "i2_gpt-4o": "it(\"should call endPath before clipping and begin a new path for annotation rendering\", async () => {\n  const log = [];\n  const fakeCtx = {\n    canvas: { width: 200, height: 200 },\n    rect(x, y, w, h) { log.push(\"rect\"); },\n    clip() { log.push(\"clip\"); },\n    beginPath() { log.push(\"beginPath\"); },\n    save() {},\n    setTransform() {}\n  };\n  const { CanvasGraphics } = await import(\"../../src/display/canvas.js\");\n  // Create a minimal dummy canvasFactory that won't be used in this branch.\n  const dummyCanvasFactory = { create: (w, h) => ({ canvas: { width: w, height: h }, context: fakeCtx }) };\n  const cg = new CanvasGraphics(fakeCtx, {}, {}, dummyCanvasFactory, null, { optionalContentConfig: null, markedContentStack: null }, new Map(), null);\n  // Override endPath to log and avoid any internal logic.\n  cg.endPath = function() { log.push(\"endPath\"); };\n  const rect = [0, 0, 100, 50], transform = [1, 0, 0, 1, 0, 0], matrix = [1, 0, 0, 1, 0, 0];\n  // hasOwnCanvas is false to ensure the else branch is executed.\n  cg.beginAnnotation(\"testAnnot\", rect, transform, matrix, false);\n  if (log.join(\",\") !== \"endPath,rect,clip,beginPath\") {\n    throw new Error(\"Expected call order 'endPath,rect,clip,beginPath' but got: \" + log.join(\",\"));\n  }\n});\n",
    "i2_llama-3.3-70b-versatile": "it(\"should call endPath before clipping and begin a new path for annotation rendering\", async () => {\n  const log = [];\n  const fakeCtx = {\n    canvas: { width: 200, height: 200 },\n    rect(x, y, w, h) { log.push(\"rect\"); },\n    clip() { log.push(\"clip\"); },\n    beginPath() { log.push(\"beginPath\"); },\n    save() {},\n    setTransform() {}\n  };\n  const { CanvasGraphics } = await import(\"../../src/display/canvas.js\");\n  // Create a minimal dummy canvasFactory that won't be used in this branch.\n  const dummyCanvasFactory = { create: (w, h) => ({ canvas: { width: w, height: h }, context: fakeCtx }) };\n  const cg = new CanvasGraphics(fakeCtx, {}, {}, dummyCanvasFactory, null, { optionalContentConfig: null, markedContentStack: null }, new Map(), null);\n  // Override endPath to log and avoid any internal logic.\n  cg.endPath = function() { log.push(\"endPath\"); };\n  const rect = [0, 0, 100, 50], transform = [1, 0, 0, 1, 0, 0], matrix = [1, 0, 0, 1, 0, 0];\n  // hasOwnCanvas is false to ensure the else branch is executed.\n  cg.beginAnnotation(\"testAnnot\", rect, transform, matrix, false);\n  if (log.join(\",\") !== \"endPath,rect,clip,beginPath\") {\n    throw new Error(\"Expected call order 'endPath,rect,clip,beginPath' but got: \" + log.join(\",\"));\n  }\n});\n",
    "i3_deepseek-r1-distill-llama-70b": "it(\"should call endPath before clipping and begin a new path for annotation rendering\", async () => {\n  const log = [];\n  const fakeCtx = {\n    canvas: { width: 200, height: 200 },\n    rect(x, y, w, h) { log.push(\"rect\"); },\n    clip() { log.push(\"clip\"); },\n    beginPath() { log.push(\"beginPath\"); },\n    save() {},\n    setTransform() {}\n  };\n  const { CanvasGraphics } = await import(\"../../src/display/canvas.js\");\n  // Create a minimal dummy canvasFactory that won't be used in this branch.\n  const dummyCanvasFactory = { create: (w, h) => ({ canvas: { width: w, height: h }, context: fakeCtx }) };\n  const cg = new CanvasGraphics(fakeCtx, {}, {}, dummyCanvasFactory, null, { optionalContentConfig: null, markedContentStack: null }, new Map(), null);\n  // Override endPath to log and avoid any internal logic.\n  cg.endPath = function() { log.push(\"endPath\"); };\n  const rect = [0, 0, 100, 50], transform = [1, 0, 0, 1, 0, 0], matrix = [1, 0, 0, 1, 0, 0];\n  // hasOwnCanvas is false to ensure the else branch is executed.\n  cg.beginAnnotation(\"testAnnot\", rect, transform, matrix, false);\n  if (log.join(\",\") !== \"endPath,rect,clip,beginPath\") {\n    throw new Error(\"Expected call order 'endPath,rect,clip,beginPath' but got: \" + log.join(\",\"));\n  }\n});\n",
    "i3_gpt-4o": "it(\"should call endPath before clipping and begin a new path for annotation rendering\", async () => {\n  const log = [];\n  const fakeCtx = {\n    canvas: { width: 200, height: 200 },\n    rect(x, y, w, h) { log.push(\"rect\"); },\n    clip() { log.push(\"clip\"); },\n    beginPath() { log.push(\"beginPath\"); },\n    save() {},\n    setTransform() {}\n  };\n  const { CanvasGraphics } = await import(\"../../src/display/canvas.js\");\n  // Create a minimal dummy canvasFactory that won't be used in this branch.\n  const dummyCanvasFactory = { create: (w, h) => ({ canvas: { width: w, height: h }, context: fakeCtx }) };\n  const cg = new CanvasGraphics(fakeCtx, {}, {}, dummyCanvasFactory, null, { optionalContentConfig: null, markedContentStack: null }, new Map(), null);\n  // Override endPath to log and avoid any internal logic.\n  cg.endPath = function() { log.push(\"endPath\"); };\n  const rect = [0, 0, 100, 50], transform = [1, 0, 0, 1, 0, 0], matrix = [1, 0, 0, 1, 0, 0];\n  // hasOwnCanvas is false to ensure the else branch is executed.\n  cg.beginAnnotation(\"testAnnot\", rect, transform, matrix, false);\n  if (log.join(\",\") !== \"endPath,rect,clip,beginPath\") {\n    throw new Error(\"Expected call order 'endPath,rect,clip,beginPath' but got: \" + log.join(\",\"));\n  }\n});\n",
    "i3_llama-3.3-70b-versatile": "it(\"should call endPath before clipping and begin a new path for annotation rendering\", async () => {\n  const log = [];\n  const fakeCtx = {\n    canvas: { width: 200, height: 200 },\n    rect(x, y, w, h) { log.push(\"rect\"); },\n    clip() { log.push(\"clip\"); },\n    beginPath() { log.push(\"beginPath\"); },\n    save() {},\n    setTransform() {}\n  };\n  const { CanvasGraphics } = await import(\"../../src/display/canvas.js\");\n  // Create a minimal dummy canvasFactory that won't be used in this branch.\n  const dummyCanvasFactory = { create: (w, h) => ({ canvas: { width: w, height: h }, context: fakeCtx }) };\n  const cg = new CanvasGraphics(fakeCtx, {}, {}, dummyCanvasFactory, null, { optionalContentConfig: null, markedContentStack: null }, new Map(), null);\n  // Override endPath to log and avoid any internal logic.\n  cg.endPath = function() { log.push(\"endPath\"); };\n  const rect = [0, 0, 100, 50], transform = [1, 0, 0, 1, 0, 0], matrix = [1, 0, 0, 1, 0, 0];\n  // hasOwnCanvas is false to ensure the else branch is executed.\n  cg.beginAnnotation(\"testAnnot\", rect, transform, matrix, false);\n  if (log.join(\",\") !== \"endPath,rect,clip,beginPath\") {\n    throw new Error(\"Expected call order 'endPath,rect,clip,beginPath' but got: \" + log.join(\",\"));\n  }\n});\n",
    "i4_deepseek-r1-distill-llama-70b": "it(\"should call endPath before clipping and begin a new path for annotation rendering\", async () => {\n  const log = [];\n  const fakeCtx = {\n    canvas: { width: 200, height: 200 },\n    rect(x, y, w, h) { log.push(\"rect\"); },\n    clip() { log.push(\"clip\"); },\n    beginPath() { log.push(\"beginPath\"); },\n    save() {},\n    setTransform() {}\n  };\n  const { CanvasGraphics } = await import(\"../../src/display/canvas.js\");\n  // Create a minimal dummy canvasFactory that won't be used in this branch.\n  const dummyCanvasFactory = { create: (w, h) => ({ canvas: { width: w, height: h }, context: fakeCtx }) };\n  const cg = new CanvasGraphics(fakeCtx, {}, {}, dummyCanvasFactory, null, { optionalContentConfig: null, markedContentStack: null }, new Map(), null);\n  // Override endPath to log and avoid any internal logic.\n  cg.endPath = function() { log.push(\"endPath\"); };\n  const rect = [0, 0, 100, 50], transform = [1, 0, 0, 1, 0, 0], matrix = [1, 0, 0, 1, 0, 0];\n  // hasOwnCanvas is false to ensure the else branch is executed.\n  cg.beginAnnotation(\"testAnnot\", rect, transform, matrix, false);\n  if (log.join(\",\") !== \"endPath,rect,clip,beginPath\") {\n    throw new Error(\"Expected call order 'endPath,rect,clip,beginPath' but got: \" + log.join(\",\"));\n  }\n});\n",
    "i4_gpt-4o": "it(\"should call endPath before clipping and begin a new path for annotation rendering\", async () => {\n  const log = [];\n  const fakeCtx = {\n    canvas: { width: 200, height: 200 },\n    rect(x, y, w, h) { log.push(\"rect\"); },\n    clip() { log.push(\"clip\"); },\n    beginPath() { log.push(\"beginPath\"); },\n    save() {},\n    setTransform() {}\n  };\n  const { CanvasGraphics } = await import(\"../../src/display/canvas.js\");\n  // Create a minimal dummy canvasFactory that won't be used in this branch.\n  const dummyCanvasFactory = { create: (w, h) => ({ canvas: { width: w, height: h }, context: fakeCtx }) };\n  const cg = new CanvasGraphics(fakeCtx, {}, {}, dummyCanvasFactory, null, { optionalContentConfig: null, markedContentStack: null }, new Map(), null);\n  // Override endPath to log and avoid any internal logic.\n  cg.endPath = function() { log.push(\"endPath\"); };\n  const rect = [0, 0, 100, 50], transform = [1, 0, 0, 1, 0, 0], matrix = [1, 0, 0, 1, 0, 0];\n  // hasOwnCanvas is false to ensure the else branch is executed.\n  cg.beginAnnotation(\"testAnnot\", rect, transform, matrix, false);\n  if (log.join(\",\") !== \"endPath,rect,clip,beginPath\") {\n    throw new Error(\"Expected call order 'endPath,rect,clip,beginPath' but got: \" + log.join(\",\"));\n  }\n});\n",
    "i4_llama-3.3-70b-versatile": "it(\"should call endPath before clipping and begin a new path for annotation rendering\", async () => {\n  const log = [];\n  const fakeCtx = {\n    canvas: { width: 200, height: 200 },\n    rect(x, y, w, h) { log.push(\"rect\"); },\n    clip() { log.push(\"clip\"); },\n    beginPath() { log.push(\"beginPath\"); },\n    save() {},\n    setTransform() {}\n  };\n  const { CanvasGraphics } = await import(\"../../src/display/canvas.js\");\n  // Create a minimal dummy canvasFactory that won't be used in this branch.\n  const dummyCanvasFactory = { create: (w, h) => ({ canvas: { width: w, height: h }, context: fakeCtx }) };\n  const cg = new CanvasGraphics(fakeCtx, {}, {}, dummyCanvasFactory, null, { optionalContentConfig: null, markedContentStack: null }, new Map(), null);\n  // Override endPath to log and avoid any internal logic.\n  cg.endPath = function() { log.push(\"endPath\"); };\n  const rect = [0, 0, 100, 50], transform = [1, 0, 0, 1, 0, 0], matrix = [1, 0, 0, 1, 0, 0];\n  // hasOwnCanvas is false to ensure the else branch is executed.\n  cg.beginAnnotation(\"testAnnot\", rect, transform, matrix, false);\n  if (log.join(\",\") !== \"endPath,rect,clip,beginPath\") {\n    throw new Error(\"Expected call order 'endPath,rect,clip,beginPath' but got: \" + log.join(\",\"));\n  }\n});\n",
    "i5_deepseek-r1-distill-llama-70b": "it(\"should call endPath before clipping and begin a new path for annotation rendering\", async () => {\n  const log = [];\n  const fakeCtx = {\n    canvas: { width: 200, height: 200 },\n    rect(x, y, w, h) { log.push(\"rect\"); },\n    clip() { log.push(\"clip\"); },\n    beginPath() { log.push(\"beginPath\"); },\n    save() {},\n    setTransform() {}\n  };\n  const { CanvasGraphics } = await import(\"../../src/display/canvas.js\");\n  // Create a minimal dummy canvasFactory that won't be used in this branch.\n  const dummyCanvasFactory = { create: (w, h) => ({ canvas: { width: w, height: h }, context: fakeCtx }) };\n  const cg = new CanvasGraphics(fakeCtx, {}, {}, dummyCanvasFactory, null, { optionalContentConfig: null, markedContentStack: null }, new Map(), null);\n  // Override endPath to log and avoid any internal logic.\n  cg.endPath = function() { log.push(\"endPath\"); };\n  const rect = [0, 0, 100, 50], transform = [1, 0, 0, 1, 0, 0], matrix = [1, 0, 0, 1, 0, 0];\n  // hasOwnCanvas is false to ensure the else branch is executed.\n  cg.beginAnnotation(\"testAnnot\", rect, transform, matrix, false);\n  if (log.join(\",\") !== \"endPath,rect,clip,beginPath\") {\n    throw new Error(\"Expected call order 'endPath,rect,clip,beginPath' but got: \" + log.join(\",\"));\n  }\n});\n",
    "i5_gpt-4o": "it(\"should call endPath before clipping and begin a new path for annotation rendering\", async () => {\n  const log = [];\n  const fakeCtx = {\n    canvas: { width: 200, height: 200 },\n    rect(x, y, w, h) { log.push(\"rect\"); },\n    clip() { log.push(\"clip\"); },\n    beginPath() { log.push(\"beginPath\"); },\n    save() {},\n    setTransform() {}\n  };\n  const { CanvasGraphics } = await import(\"../../src/display/canvas.js\");\n  // Create a minimal dummy canvasFactory that won't be used in this branch.\n  const dummyCanvasFactory = { create: (w, h) => ({ canvas: { width: w, height: h }, context: fakeCtx }) };\n  const cg = new CanvasGraphics(fakeCtx, {}, {}, dummyCanvasFactory, null, { optionalContentConfig: null, markedContentStack: null }, new Map(), null);\n  // Override endPath to log and avoid any internal logic.\n  cg.endPath = function() { log.push(\"endPath\"); };\n  const rect = [0, 0, 100, 50], transform = [1, 0, 0, 1, 0, 0], matrix = [1, 0, 0, 1, 0, 0];\n  // hasOwnCanvas is false to ensure the else branch is executed.\n  cg.beginAnnotation(\"testAnnot\", rect, transform, matrix, false);\n  if (log.join(\",\") !== \"endPath,rect,clip,beginPath\") {\n    throw new Error(\"Expected call order 'endPath,rect,clip,beginPath' but got: \" + log.join(\",\"));\n  }\n});\n",
    "i5_llama-3.3-70b-versatile": "it(\"should call endPath before clipping and begin a new path for annotation rendering\", async () => {\n  const log = [];\n  const fakeCtx = {\n    canvas: { width: 200, height: 200 },\n    rect(x, y, w, h) { log.push(\"rect\"); },\n    clip() { log.push(\"clip\"); },\n    beginPath() { log.push(\"beginPath\"); },\n    save() {},\n    setTransform() {}\n  };\n  const { CanvasGraphics } = await import(\"../../src/display/canvas.js\");\n  // Create a minimal dummy canvasFactory that won't be used in this branch.\n  const dummyCanvasFactory = { create: (w, h) => ({ canvas: { width: w, height: h }, context: fakeCtx }) };\n  const cg = new CanvasGraphics(fakeCtx, {}, {}, dummyCanvasFactory, null, { optionalContentConfig: null, markedContentStack: null }, new Map(), null);\n  // Override endPath to log and avoid any internal logic.\n  cg.endPath = function() { log.push(\"endPath\"); };\n  const rect = [0, 0, 100, 50], transform = [1, 0, 0, 1, 0, 0], matrix = [1, 0, 0, 1, 0, 0];\n  // hasOwnCanvas is false to ensure the else branch is executed.\n  cg.beginAnnotation(\"testAnnot\", rect, transform, matrix, false);\n  if (log.join(\",\") !== \"endPath,rect,clip,beginPath\") {\n    throw new Error(\"Expected call order 'endPath,rect,clip,beginPath' but got: \" + log.join(\",\"));\n  }\n});\n"
  },
  "18760": {
    "i1_deepseek-r1-distill-llama-70b": "it(\"should correctly render a manually hinted TrueType font\", async () => {\n  const { getDocument } = await import(\"../../src/display/api.js\");\n  const { TEST_PDFS_PATH } = await import(\"./test_utils.js\");\n  // This file contains a manually hinted TrueType font that previously caused rasterisation errors.\n  const loadingTask = getDocument(`${TEST_PDFS_PATH}/manual_hinted_trueType.pdf`);\n  const pdfDocument = await loadingTask.promise;\n  const page = await pdfDocument.getPage(1);\n  const textContent = await page.getTextContent();\n  const text = textContent.items.map(item => item.str).join(\"\");\n  // The expected text is embedded in the PDF when the font is correctly processed.\n  expect(text).toContain(\"This is a hinted TrueType test\");\n});",
    "i1_gpt-4o": "it(\"should correctly render a manually hinted TrueType font\", async () => {\n  const { getDocument } = await import(\"../../src/display/api.js\");\n  const { TEST_PDFS_PATH } = await import(\"./test_utils.js\");\n  // This file contains a manually hinted TrueType font that previously caused rasterisation errors.\n  const loadingTask = getDocument(`${TEST_PDFS_PATH}/manual_hinted_trueType.pdf`);\n  const pdfDocument = await loadingTask.promise;\n  const page = await pdfDocument.getPage(1);\n  const textContent = await page.getTextContent();\n  const text = textContent.items.map(item => item.str).join(\"\");\n  // The expected text is embedded in the PDF when the font is correctly processed.\n  expect(text).toContain(\"This is a hinted TrueType test\");\n});",
    "i1_llama-3.3-70b-versatile": "it(\"should correctly render a manually hinted TrueType font\", async () => {\n  const { getDocument } = await import(\"../../src/display/api.js\");\n  const { TEST_PDFS_PATH } = await import(\"./test_utils.js\");\n  // This file contains a manually hinted TrueType font that previously caused rasterisation errors.\n  const loadingTask = getDocument(`${TEST_PDFS_PATH}/manual_hinted_trueType.pdf`);\n  const pdfDocument = await loadingTask.promise;\n  const page = await pdfDocument.getPage(1);\n  const textContent = await page.getTextContent();\n  const text = textContent.items.map(item => item.str).join(\"\");\n  // The expected text is embedded in the PDF when the font is correctly processed.\n  expect(text).toContain(\"This is a hinted TrueType test\");\n});",
    "i1_MOCK": "it(\"should correctly render a manually hinted TrueType font\", async () => {\n  const { getDocument } = await import(\"../../src/display/api.js\");\n  const { TEST_PDFS_PATH } = await import(\"./test_utils.js\");\n  // This file contains a manually hinted TrueType font that previously caused rasterisation errors.\n  const loadingTask = getDocument(`${TEST_PDFS_PATH}/manual_hinted_trueType.pdf`);\n  const pdfDocument = await loadingTask.promise;\n  const page = await pdfDocument.getPage(1);\n  const textContent = await page.getTextContent();\n  const text = textContent.items.map(item => item.str).join(\"\");\n  // The expected text is embedded in the PDF when the font is correctly processed.\n  expect(text).toContain(\"This is a hinted TrueType test\");\n});",
    "i2_deepseek-r1-distill-llama-70b": "it(\"should correctly render a manually hinted TrueType font\", async () => {\n  const { getDocument } = await import(\"../../src/display/api.js\");\n  const { TEST_PDFS_PATH } = await import(\"./test_utils.js\");\n  // This file contains a manually hinted TrueType font that previously caused rasterisation errors.\n  const loadingTask = getDocument(`${TEST_PDFS_PATH}/manual_hinted_trueType.pdf`);\n  const pdfDocument = await loadingTask.promise;\n  const page = await pdfDocument.getPage(1);\n  const textContent = await page.getTextContent();\n  const text = textContent.items.map(item => item.str).join(\"\");\n  // The expected text is embedded in the PDF when the font is correctly processed.\n  expect(text).toContain(\"This is a hinted TrueType test\");\n});",
    "i2_gpt-4o": "it(\"should correctly render a manually hinted TrueType font\", async () => {\n  const { getDocument } = await import(\"../../src/display/api.js\");\n  const { TEST_PDFS_PATH } = await import(\"./test_utils.js\");\n  // This file contains a manually hinted TrueType font that previously caused rasterisation errors.\n  const loadingTask = getDocument(`${TEST_PDFS_PATH}/manual_hinted_trueType.pdf`);\n  const pdfDocument = await loadingTask.promise;\n  const page = await pdfDocument.getPage(1);\n  const textContent = await page.getTextContent();\n  const text = textContent.items.map(item => item.str).join(\"\");\n  // The expected text is embedded in the PDF when the font is correctly processed.\n  expect(text).toContain(\"This is a hinted TrueType test\");\n});",
    "i2_llama-3.3-70b-versatile": "it(\"should correctly render a manually hinted TrueType font\", async () => {\n  const { getDocument } = await import(\"../../src/display/api.js\");\n  const { TEST_PDFS_PATH } = await import(\"./test_utils.js\");\n  // This file contains a manually hinted TrueType font that previously caused rasterisation errors.\n  const loadingTask = getDocument(`${TEST_PDFS_PATH}/manual_hinted_trueType.pdf`);\n  const pdfDocument = await loadingTask.promise;\n  const page = await pdfDocument.getPage(1);\n  const textContent = await page.getTextContent();\n  const text = textContent.items.map(item => item.str).join(\"\");\n  // The expected text is embedded in the PDF when the font is correctly processed.\n  expect(text).toContain(\"This is a hinted TrueType test\");\n});",
    "i3_deepseek-r1-distill-llama-70b": "it(\"should correctly render a manually hinted TrueType font\", async () => {\n  const { getDocument } = await import(\"../../src/display/api.js\");\n  const { TEST_PDFS_PATH } = await import(\"./test_utils.js\");\n  // This file contains a manually hinted TrueType font that previously caused rasterisation errors.\n  const loadingTask = getDocument(`${TEST_PDFS_PATH}/manual_hinted_trueType.pdf`);\n  const pdfDocument = await loadingTask.promise;\n  const page = await pdfDocument.getPage(1);\n  const textContent = await page.getTextContent();\n  const text = textContent.items.map(item => item.str).join(\"\");\n  // The expected text is embedded in the PDF when the font is correctly processed.\n  expect(text).toContain(\"This is a hinted TrueType test\");\n});",
    "i3_gpt-4o": "it(\"should correctly render a manually hinted TrueType font\", async () => {\n  const { getDocument } = await import(\"../../src/display/api.js\");\n  const { TEST_PDFS_PATH } = await import(\"./test_utils.js\");\n  // This file contains a manually hinted TrueType font that previously caused rasterisation errors.\n  const loadingTask = getDocument(`${TEST_PDFS_PATH}/manual_hinted_trueType.pdf`);\n  const pdfDocument = await loadingTask.promise;\n  const page = await pdfDocument.getPage(1);\n  const textContent = await page.getTextContent();\n  const text = textContent.items.map(item => item.str).join(\"\");\n  // The expected text is embedded in the PDF when the font is correctly processed.\n  expect(text).toContain(\"This is a hinted TrueType test\");\n});",
    "i3_llama-3.3-70b-versatile": "it(\"should correctly render a manually hinted TrueType font\", async () => {\n  const { getDocument } = await import(\"../../src/display/api.js\");\n  const { TEST_PDFS_PATH } = await import(\"./test_utils.js\");\n  // This file contains a manually hinted TrueType font that previously caused rasterisation errors.\n  const loadingTask = getDocument(`${TEST_PDFS_PATH}/manual_hinted_trueType.pdf`);\n  const pdfDocument = await loadingTask.promise;\n  const page = await pdfDocument.getPage(1);\n  const textContent = await page.getTextContent();\n  const text = textContent.items.map(item => item.str).join(\"\");\n  // The expected text is embedded in the PDF when the font is correctly processed.\n  expect(text).toContain(\"This is a hinted TrueType test\");\n});",
    "i4_deepseek-r1-distill-llama-70b": "it(\"should correctly render a manually hinted TrueType font\", async () => {\n  const { getDocument } = await import(\"../../src/display/api.js\");\n  const { TEST_PDFS_PATH } = await import(\"./test_utils.js\");\n  // This file contains a manually hinted TrueType font that previously caused rasterisation errors.\n  const loadingTask = getDocument(`${TEST_PDFS_PATH}/manual_hinted_trueType.pdf`);\n  const pdfDocument = await loadingTask.promise;\n  const page = await pdfDocument.getPage(1);\n  const textContent = await page.getTextContent();\n  const text = textContent.items.map(item => item.str).join(\"\");\n  // The expected text is embedded in the PDF when the font is correctly processed.\n  expect(text).toContain(\"This is a hinted TrueType test\");\n});",
    "i4_gpt-4o": "it(\"should correctly render a manually hinted TrueType font\", async () => {\n  const { getDocument } = await import(\"../../src/display/api.js\");\n  const { TEST_PDFS_PATH } = await import(\"./test_utils.js\");\n  // This file contains a manually hinted TrueType font that previously caused rasterisation errors.\n  const loadingTask = getDocument(`${TEST_PDFS_PATH}/manual_hinted_trueType.pdf`);\n  const pdfDocument = await loadingTask.promise;\n  const page = await pdfDocument.getPage(1);\n  const textContent = await page.getTextContent();\n  const text = textContent.items.map(item => item.str).join(\"\");\n  // The expected text is embedded in the PDF when the font is correctly processed.\n  expect(text).toContain(\"This is a hinted TrueType test\");\n});",
    "i4_llama-3.3-70b-versatile": "it(\"should correctly render a manually hinted TrueType font\", async () => {\n  const { getDocument } = await import(\"../../src/display/api.js\");\n  const { TEST_PDFS_PATH } = await import(\"./test_utils.js\");\n  // This file contains a manually hinted TrueType font that previously caused rasterisation errors.\n  const loadingTask = getDocument(`${TEST_PDFS_PATH}/manual_hinted_trueType.pdf`);\n  const pdfDocument = await loadingTask.promise;\n  const page = await pdfDocument.getPage(1);\n  const textContent = await page.getTextContent();\n  const text = textContent.items.map(item => item.str).join(\"\");\n  // The expected text is embedded in the PDF when the font is correctly processed.\n  expect(text).toContain(\"This is a hinted TrueType test\");\n});",
    "i5_deepseek-r1-distill-llama-70b": "it(\"should correctly render a manually hinted TrueType font\", async () => {\n  const { getDocument } = await import(\"../../src/display/api.js\");\n  const { TEST_PDFS_PATH } = await import(\"./test_utils.js\");\n  // This file contains a manually hinted TrueType font that previously caused rasterisation errors.\n  const loadingTask = getDocument(`${TEST_PDFS_PATH}/manual_hinted_trueType.pdf`);\n  const pdfDocument = await loadingTask.promise;\n  const page = await pdfDocument.getPage(1);\n  const textContent = await page.getTextContent();\n  const text = textContent.items.map(item => item.str).join(\"\");\n  // The expected text is embedded in the PDF when the font is correctly processed.\n  expect(text).toContain(\"This is a hinted TrueType test\");\n});",
    "i5_gpt-4o": "it(\"should correctly render a manually hinted TrueType font\", async () => {\n  const { getDocument } = await import(\"../../src/display/api.js\");\n  const { TEST_PDFS_PATH } = await import(\"./test_utils.js\");\n  // This file contains a manually hinted TrueType font that previously caused rasterisation errors.\n  const loadingTask = getDocument(`${TEST_PDFS_PATH}/manual_hinted_trueType.pdf`);\n  const pdfDocument = await loadingTask.promise;\n  const page = await pdfDocument.getPage(1);\n  const textContent = await page.getTextContent();\n  const text = textContent.items.map(item => item.str).join(\"\");\n  // The expected text is embedded in the PDF when the font is correctly processed.\n  expect(text).toContain(\"This is a hinted TrueType test\");\n});",
    "i5_llama-3.3-70b-versatile": "it(\"should correctly render a manually hinted TrueType font\", async () => {\n  const { getDocument } = await import(\"../../src/display/api.js\");\n  const { TEST_PDFS_PATH } = await import(\"./test_utils.js\");\n  // This file contains a manually hinted TrueType font that previously caused rasterisation errors.\n  const loadingTask = getDocument(`${TEST_PDFS_PATH}/manual_hinted_trueType.pdf`);\n  const pdfDocument = await loadingTask.promise;\n  const page = await pdfDocument.getPage(1);\n  const textContent = await page.getTextContent();\n  const text = textContent.items.map(item => item.str).join(\"\");\n  // The expected text is embedded in the PDF when the font is correctly processed.\n  expect(text).toContain(\"This is a hinted TrueType test\");\n});"
  },
  "18766": {
    "i1_deepseek-r1-distill-llama-70b": "it(\"should ignore shadingFill errors when ignoreErrors is enabled\", () => {\n  const xref = new XRefMock();\n  const opList = new OperatorList();\n  const resources = new Dict();\n  const shadingDict = new Dict();\n  // Do not add any shading object named \"Foo\".\n  resources.set(\"Shading\", shadingDict);\n  const evaluator = new PartialEvaluator({\n    xref,\n    handler: {},\n    pageIndex: 0,\n    idFactory: {},\n    fontCache: new Map(),\n    builtInCMapCache: new Map(),\n    standardFontDataCache: new Map(),\n    globalImageCache: new Map(),\n    systemFontCache: new Map(),\n    options: { ignoreErrors: true },\n  });\n  const fakeStream = {\n    called: false,\n    read(operation) {\n      if (!this.called) {\n        this.called = true;\n        operation.fn = OPS.shadingFill;\n        operation.args = [{ name: \"Foo\" }];\n        return true;\n      }\n      return false;\n    },\n  };\n  const fakeTask = new WorkerTask(\"fake\", null);\n  return evaluator\n    .getOperatorList({\n      stream: fakeStream,\n      task: fakeTask,\n      resources,\n      operatorList: opList,\n    })\n    .then(() => {\n      // The shadingFill operator should be ignored, so no op added.\n      assert.equal(opList.fnArray.length, 0);\n    });\n});",
    "i1_gpt-4o": "it(\"should ignore shadingFill errors when ignoreErrors is enabled\", () => {\n  const xref = new XRefMock();\n  const opList = new OperatorList();\n  const resources = new Dict();\n  const shadingDict = new Dict();\n  // Do not add any shading object named \"Foo\".\n  resources.set(\"Shading\", shadingDict);\n  const evaluator = new PartialEvaluator({\n    xref,\n    handler: {},\n    pageIndex: 0,\n    idFactory: {},\n    fontCache: new Map(),\n    builtInCMapCache: new Map(),\n    standardFontDataCache: new Map(),\n    globalImageCache: new Map(),\n    systemFontCache: new Map(),\n    options: { ignoreErrors: true },\n  });\n  const fakeStream = {\n    called: false,\n    read(operation) {\n      if (!this.called) {\n        this.called = true;\n        operation.fn = OPS.shadingFill;\n        operation.args = [{ name: \"Foo\" }];\n        return true;\n      }\n      return false;\n    },\n  };\n  const fakeTask = new WorkerTask(\"fake\", null);\n  return evaluator\n    .getOperatorList({\n      stream: fakeStream,\n      task: fakeTask,\n      resources,\n      operatorList: opList,\n    })\n    .then(() => {\n      // The shadingFill operator should be ignored, so no op added.\n      assert.equal(opList.fnArray.length, 0);\n    });\n});",
    "i1_llama-3.3-70b-versatile": "it(\"should ignore shadingFill errors when ignoreErrors is enabled\", () => {\n  const xref = new XRefMock();\n  const opList = new OperatorList();\n  const resources = new Dict();\n  const shadingDict = new Dict();\n  // Do not add any shading object named \"Foo\".\n  resources.set(\"Shading\", shadingDict);\n  const evaluator = new PartialEvaluator({\n    xref,\n    handler: {},\n    pageIndex: 0,\n    idFactory: {},\n    fontCache: new Map(),\n    builtInCMapCache: new Map(),\n    standardFontDataCache: new Map(),\n    globalImageCache: new Map(),\n    systemFontCache: new Map(),\n    options: { ignoreErrors: true },\n  });\n  const fakeStream = {\n    called: false,\n    read(operation) {\n      if (!this.called) {\n        this.called = true;\n        operation.fn = OPS.shadingFill;\n        operation.args = [{ name: \"Foo\" }];\n        return true;\n      }\n      return false;\n    },\n  };\n  const fakeTask = new WorkerTask(\"fake\", null);\n  return evaluator\n    .getOperatorList({\n      stream: fakeStream,\n      task: fakeTask,\n      resources,\n      operatorList: opList,\n    })\n    .then(() => {\n      // The shadingFill operator should be ignored, so no op added.\n      assert.equal(opList.fnArray.length, 0);\n    });\n});",
    "i1_MOCK": "it(\"should ignore shadingFill errors when ignoreErrors is enabled\", () => {\n  const xref = new XRefMock();\n  const opList = new OperatorList();\n  const resources = new Dict();\n  const shadingDict = new Dict();\n  // Do not add any shading object named \"Foo\".\n  resources.set(\"Shading\", shadingDict);\n  const evaluator = new PartialEvaluator({\n    xref,\n    handler: {},\n    pageIndex: 0,\n    idFactory: {},\n    fontCache: new Map(),\n    builtInCMapCache: new Map(),\n    standardFontDataCache: new Map(),\n    globalImageCache: new Map(),\n    systemFontCache: new Map(),\n    options: { ignoreErrors: true },\n  });\n  const fakeStream = {\n    called: false,\n    read(operation) {\n      if (!this.called) {\n        this.called = true;\n        operation.fn = OPS.shadingFill;\n        operation.args = [{ name: \"Foo\" }];\n        return true;\n      }\n      return false;\n    },\n  };\n  const fakeTask = new WorkerTask(\"fake\", null);\n  return evaluator\n    .getOperatorList({\n      stream: fakeStream,\n      task: fakeTask,\n      resources,\n      operatorList: opList,\n    })\n    .then(() => {\n      // The shadingFill operator should be ignored, so no op added.\n      assert.equal(opList.fnArray.length, 0);\n    });\n});",
    "i2_deepseek-r1-distill-llama-70b": "it(\"should ignore shadingFill errors when ignoreErrors is enabled\", () => {\n  const xref = new XRefMock();\n  const opList = new OperatorList();\n  const resources = new Dict();\n  const shadingDict = new Dict();\n  // Do not add any shading object named \"Foo\".\n  resources.set(\"Shading\", shadingDict);\n  const evaluator = new PartialEvaluator({\n    xref,\n    handler: {},\n    pageIndex: 0,\n    idFactory: {},\n    fontCache: new Map(),\n    builtInCMapCache: new Map(),\n    standardFontDataCache: new Map(),\n    globalImageCache: new Map(),\n    systemFontCache: new Map(),\n    options: { ignoreErrors: true },\n  });\n  const fakeStream = {\n    called: false,\n    read(operation) {\n      if (!this.called) {\n        this.called = true;\n        operation.fn = OPS.shadingFill;\n        operation.args = [{ name: \"Foo\" }];\n        return true;\n      }\n      return false;\n    },\n  };\n  const fakeTask = new WorkerTask(\"fake\", null);\n  return evaluator\n    .getOperatorList({\n      stream: fakeStream,\n      task: fakeTask,\n      resources,\n      operatorList: opList,\n    })\n    .then(() => {\n      // The shadingFill operator should be ignored, so no op added.\n      assert.equal(opList.fnArray.length, 0);\n    });\n});",
    "i2_gpt-4o": "it(\"should ignore shadingFill errors when ignoreErrors is enabled\", () => {\n  const xref = new XRefMock();\n  const opList = new OperatorList();\n  const resources = new Dict();\n  const shadingDict = new Dict();\n  // Do not add any shading object named \"Foo\".\n  resources.set(\"Shading\", shadingDict);\n  const evaluator = new PartialEvaluator({\n    xref,\n    handler: {},\n    pageIndex: 0,\n    idFactory: {},\n    fontCache: new Map(),\n    builtInCMapCache: new Map(),\n    standardFontDataCache: new Map(),\n    globalImageCache: new Map(),\n    systemFontCache: new Map(),\n    options: { ignoreErrors: true },\n  });\n  const fakeStream = {\n    called: false,\n    read(operation) {\n      if (!this.called) {\n        this.called = true;\n        operation.fn = OPS.shadingFill;\n        operation.args = [{ name: \"Foo\" }];\n        return true;\n      }\n      return false;\n    },\n  };\n  const fakeTask = new WorkerTask(\"fake\", null);\n  return evaluator\n    .getOperatorList({\n      stream: fakeStream,\n      task: fakeTask,\n      resources,\n      operatorList: opList,\n    })\n    .then(() => {\n      // The shadingFill operator should be ignored, so no op added.\n      assert.equal(opList.fnArray.length, 0);\n    });\n});",
    "i2_llama-3.3-70b-versatile": "it(\"should ignore shadingFill errors when ignoreErrors is enabled\", () => {\n  const xref = new XRefMock();\n  const opList = new OperatorList();\n  const resources = new Dict();\n  const shadingDict = new Dict();\n  // Do not add any shading object named \"Foo\".\n  resources.set(\"Shading\", shadingDict);\n  const evaluator = new PartialEvaluator({\n    xref,\n    handler: {},\n    pageIndex: 0,\n    idFactory: {},\n    fontCache: new Map(),\n    builtInCMapCache: new Map(),\n    standardFontDataCache: new Map(),\n    globalImageCache: new Map(),\n    systemFontCache: new Map(),\n    options: { ignoreErrors: true },\n  });\n  const fakeStream = {\n    called: false,\n    read(operation) {\n      if (!this.called) {\n        this.called = true;\n        operation.fn = OPS.shadingFill;\n        operation.args = [{ name: \"Foo\" }];\n        return true;\n      }\n      return false;\n    },\n  };\n  const fakeTask = new WorkerTask(\"fake\", null);\n  return evaluator\n    .getOperatorList({\n      stream: fakeStream,\n      task: fakeTask,\n      resources,\n      operatorList: opList,\n    })\n    .then(() => {\n      // The shadingFill operator should be ignored, so no op added.\n      assert.equal(opList.fnArray.length, 0);\n    });\n});",
    "i3_deepseek-r1-distill-llama-70b": "it(\"should ignore shadingFill errors when ignoreErrors is enabled\", () => {\n  const xref = new XRefMock();\n  const opList = new OperatorList();\n  const resources = new Dict();\n  const shadingDict = new Dict();\n  // Do not add any shading object named \"Foo\".\n  resources.set(\"Shading\", shadingDict);\n  const evaluator = new PartialEvaluator({\n    xref,\n    handler: {},\n    pageIndex: 0,\n    idFactory: {},\n    fontCache: new Map(),\n    builtInCMapCache: new Map(),\n    standardFontDataCache: new Map(),\n    globalImageCache: new Map(),\n    systemFontCache: new Map(),\n    options: { ignoreErrors: true },\n  });\n  const fakeStream = {\n    called: false,\n    read(operation) {\n      if (!this.called) {\n        this.called = true;\n        operation.fn = OPS.shadingFill;\n        operation.args = [{ name: \"Foo\" }];\n        return true;\n      }\n      return false;\n    },\n  };\n  const fakeTask = new WorkerTask(\"fake\", null);\n  return evaluator\n    .getOperatorList({\n      stream: fakeStream,\n      task: fakeTask,\n      resources,\n      operatorList: opList,\n    })\n    .then(() => {\n      // The shadingFill operator should be ignored, so no op added.\n      assert.equal(opList.fnArray.length, 0);\n    });\n});",
    "i3_gpt-4o": "it(\"should ignore shadingFill errors when ignoreErrors is enabled\", () => {\n  const xref = new XRefMock();\n  const opList = new OperatorList();\n  const resources = new Dict();\n  const shadingDict = new Dict();\n  // Do not add any shading object named \"Foo\".\n  resources.set(\"Shading\", shadingDict);\n  const evaluator = new PartialEvaluator({\n    xref,\n    handler: {},\n    pageIndex: 0,\n    idFactory: {},\n    fontCache: new Map(),\n    builtInCMapCache: new Map(),\n    standardFontDataCache: new Map(),\n    globalImageCache: new Map(),\n    systemFontCache: new Map(),\n    options: { ignoreErrors: true },\n  });\n  const fakeStream = {\n    called: false,\n    read(operation) {\n      if (!this.called) {\n        this.called = true;\n        operation.fn = OPS.shadingFill;\n        operation.args = [{ name: \"Foo\" }];\n        return true;\n      }\n      return false;\n    },\n  };\n  const fakeTask = new WorkerTask(\"fake\", null);\n  return evaluator\n    .getOperatorList({\n      stream: fakeStream,\n      task: fakeTask,\n      resources,\n      operatorList: opList,\n    })\n    .then(() => {\n      // The shadingFill operator should be ignored, so no op added.\n      assert.equal(opList.fnArray.length, 0);\n    });\n});",
    "i3_llama-3.3-70b-versatile": "it(\"should ignore shadingFill errors when ignoreErrors is enabled\", () => {\n  const xref = new XRefMock();\n  const opList = new OperatorList();\n  const resources = new Dict();\n  const shadingDict = new Dict();\n  // Do not add any shading object named \"Foo\".\n  resources.set(\"Shading\", shadingDict);\n  const evaluator = new PartialEvaluator({\n    xref,\n    handler: {},\n    pageIndex: 0,\n    idFactory: {},\n    fontCache: new Map(),\n    builtInCMapCache: new Map(),\n    standardFontDataCache: new Map(),\n    globalImageCache: new Map(),\n    systemFontCache: new Map(),\n    options: { ignoreErrors: true },\n  });\n  const fakeStream = {\n    called: false,\n    read(operation) {\n      if (!this.called) {\n        this.called = true;\n        operation.fn = OPS.shadingFill;\n        operation.args = [{ name: \"Foo\" }];\n        return true;\n      }\n      return false;\n    },\n  };\n  const fakeTask = new WorkerTask(\"fake\", null);\n  return evaluator\n    .getOperatorList({\n      stream: fakeStream,\n      task: fakeTask,\n      resources,\n      operatorList: opList,\n    })\n    .then(() => {\n      // The shadingFill operator should be ignored, so no op added.\n      assert.equal(opList.fnArray.length, 0);\n    });\n});",
    "i4_deepseek-r1-distill-llama-70b": "it(\"should ignore shadingFill errors when ignoreErrors is enabled\", () => {\n  const xref = new XRefMock();\n  const opList = new OperatorList();\n  const resources = new Dict();\n  const shadingDict = new Dict();\n  // Do not add any shading object named \"Foo\".\n  resources.set(\"Shading\", shadingDict);\n  const evaluator = new PartialEvaluator({\n    xref,\n    handler: {},\n    pageIndex: 0,\n    idFactory: {},\n    fontCache: new Map(),\n    builtInCMapCache: new Map(),\n    standardFontDataCache: new Map(),\n    globalImageCache: new Map(),\n    systemFontCache: new Map(),\n    options: { ignoreErrors: true },\n  });\n  const fakeStream = {\n    called: false,\n    read(operation) {\n      if (!this.called) {\n        this.called = true;\n        operation.fn = OPS.shadingFill;\n        operation.args = [{ name: \"Foo\" }];\n        return true;\n      }\n      return false;\n    },\n  };\n  const fakeTask = new WorkerTask(\"fake\", null);\n  return evaluator\n    .getOperatorList({\n      stream: fakeStream,\n      task: fakeTask,\n      resources,\n      operatorList: opList,\n    })\n    .then(() => {\n      // The shadingFill operator should be ignored, so no op added.\n      assert.equal(opList.fnArray.length, 0);\n    });\n});",
    "i4_gpt-4o": "it(\"should ignore shadingFill errors when ignoreErrors is enabled\", () => {\n  const xref = new XRefMock();\n  const opList = new OperatorList();\n  const resources = new Dict();\n  const shadingDict = new Dict();\n  // Do not add any shading object named \"Foo\".\n  resources.set(\"Shading\", shadingDict);\n  const evaluator = new PartialEvaluator({\n    xref,\n    handler: {},\n    pageIndex: 0,\n    idFactory: {},\n    fontCache: new Map(),\n    builtInCMapCache: new Map(),\n    standardFontDataCache: new Map(),\n    globalImageCache: new Map(),\n    systemFontCache: new Map(),\n    options: { ignoreErrors: true },\n  });\n  const fakeStream = {\n    called: false,\n    read(operation) {\n      if (!this.called) {\n        this.called = true;\n        operation.fn = OPS.shadingFill;\n        operation.args = [{ name: \"Foo\" }];\n        return true;\n      }\n      return false;\n    },\n  };\n  const fakeTask = new WorkerTask(\"fake\", null);\n  return evaluator\n    .getOperatorList({\n      stream: fakeStream,\n      task: fakeTask,\n      resources,\n      operatorList: opList,\n    })\n    .then(() => {\n      // The shadingFill operator should be ignored, so no op added.\n      assert.equal(opList.fnArray.length, 0);\n    });\n});",
    "i4_llama-3.3-70b-versatile": "it(\"should ignore shadingFill errors when ignoreErrors is enabled\", () => {\n  const xref = new XRefMock();\n  const opList = new OperatorList();\n  const resources = new Dict();\n  const shadingDict = new Dict();\n  // Do not add any shading object named \"Foo\".\n  resources.set(\"Shading\", shadingDict);\n  const evaluator = new PartialEvaluator({\n    xref,\n    handler: {},\n    pageIndex: 0,\n    idFactory: {},\n    fontCache: new Map(),\n    builtInCMapCache: new Map(),\n    standardFontDataCache: new Map(),\n    globalImageCache: new Map(),\n    systemFontCache: new Map(),\n    options: { ignoreErrors: true },\n  });\n  const fakeStream = {\n    called: false,\n    read(operation) {\n      if (!this.called) {\n        this.called = true;\n        operation.fn = OPS.shadingFill;\n        operation.args = [{ name: \"Foo\" }];\n        return true;\n      }\n      return false;\n    },\n  };\n  const fakeTask = new WorkerTask(\"fake\", null);\n  return evaluator\n    .getOperatorList({\n      stream: fakeStream,\n      task: fakeTask,\n      resources,\n      operatorList: opList,\n    })\n    .then(() => {\n      // The shadingFill operator should be ignored, so no op added.\n      assert.equal(opList.fnArray.length, 0);\n    });\n});",
    "i5_deepseek-r1-distill-llama-70b": "it(\"should ignore shadingFill errors when ignoreErrors is enabled\", () => {\n  const xref = new XRefMock();\n  const opList = new OperatorList();\n  const resources = new Dict();\n  const shadingDict = new Dict();\n  // Do not add any shading object named \"Foo\".\n  resources.set(\"Shading\", shadingDict);\n  const evaluator = new PartialEvaluator({\n    xref,\n    handler: {},\n    pageIndex: 0,\n    idFactory: {},\n    fontCache: new Map(),\n    builtInCMapCache: new Map(),\n    standardFontDataCache: new Map(),\n    globalImageCache: new Map(),\n    systemFontCache: new Map(),\n    options: { ignoreErrors: true },\n  });\n  const fakeStream = {\n    called: false,\n    read(operation) {\n      if (!this.called) {\n        this.called = true;\n        operation.fn = OPS.shadingFill;\n        operation.args = [{ name: \"Foo\" }];\n        return true;\n      }\n      return false;\n    },\n  };\n  const fakeTask = new WorkerTask(\"fake\", null);\n  return evaluator\n    .getOperatorList({\n      stream: fakeStream,\n      task: fakeTask,\n      resources,\n      operatorList: opList,\n    })\n    .then(() => {\n      // The shadingFill operator should be ignored, so no op added.\n      assert.equal(opList.fnArray.length, 0);\n    });\n});",
    "i5_gpt-4o": "it(\"should ignore shadingFill errors when ignoreErrors is enabled\", () => {\n  const xref = new XRefMock();\n  const opList = new OperatorList();\n  const resources = new Dict();\n  const shadingDict = new Dict();\n  // Do not add any shading object named \"Foo\".\n  resources.set(\"Shading\", shadingDict);\n  const evaluator = new PartialEvaluator({\n    xref,\n    handler: {},\n    pageIndex: 0,\n    idFactory: {},\n    fontCache: new Map(),\n    builtInCMapCache: new Map(),\n    standardFontDataCache: new Map(),\n    globalImageCache: new Map(),\n    systemFontCache: new Map(),\n    options: { ignoreErrors: true },\n  });\n  const fakeStream = {\n    called: false,\n    read(operation) {\n      if (!this.called) {\n        this.called = true;\n        operation.fn = OPS.shadingFill;\n        operation.args = [{ name: \"Foo\" }];\n        return true;\n      }\n      return false;\n    },\n  };\n  const fakeTask = new WorkerTask(\"fake\", null);\n  return evaluator\n    .getOperatorList({\n      stream: fakeStream,\n      task: fakeTask,\n      resources,\n      operatorList: opList,\n    })\n    .then(() => {\n      // The shadingFill operator should be ignored, so no op added.\n      assert.equal(opList.fnArray.length, 0);\n    });\n});",
    "i5_llama-3.3-70b-versatile": "it(\"should ignore shadingFill errors when ignoreErrors is enabled\", () => {\n  const xref = new XRefMock();\n  const opList = new OperatorList();\n  const resources = new Dict();\n  const shadingDict = new Dict();\n  // Do not add any shading object named \"Foo\".\n  resources.set(\"Shading\", shadingDict);\n  const evaluator = new PartialEvaluator({\n    xref,\n    handler: {},\n    pageIndex: 0,\n    idFactory: {},\n    fontCache: new Map(),\n    builtInCMapCache: new Map(),\n    standardFontDataCache: new Map(),\n    globalImageCache: new Map(),\n    systemFontCache: new Map(),\n    options: { ignoreErrors: true },\n  });\n  const fakeStream = {\n    called: false,\n    read(operation) {\n      if (!this.called) {\n        this.called = true;\n        operation.fn = OPS.shadingFill;\n        operation.args = [{ name: \"Foo\" }];\n        return true;\n      }\n      return false;\n    },\n  };\n  const fakeTask = new WorkerTask(\"fake\", null);\n  return evaluator\n    .getOperatorList({\n      stream: fakeStream,\n      task: fakeTask,\n      resources,\n      operatorList: opList,\n    })\n    .then(() => {\n      // The shadingFill operator should be ignored, so no op added.\n      assert.equal(opList.fnArray.length, 0);\n    });\n});"
  },
  "18798": {
    "i1_deepseek-r1-distill-llama-70b": "it(\"should use the original bbox origin even if negative\", async () => {\n  const { TilingPattern } = await import(\"../../src/display/pattern_helper.js\");\n\n  const dummyCtx = {\n    canvas: { width: 100, height: 100 },\n    translate() {},\n    save() {},\n    restore() {},\n  };\n\n  const dummyGraphicsFactory = {\n    createCanvasGraphics: (ctx) => ({\n      ctx,\n      groupLevel: 0,\n      transform() {},\n      executeOperatorList() {},\n      endDrawing() {},\n    }),\n  };\n\n  const IR = [];\n  IR[2] = []; // operatorList\n  IR[3] = [1, 0, 0, 1, 0, 0]; // matrix (identity)\n  IR[4] = [-10, -10, 10, 10]; // bbox with negative origin\n  IR[5] = 20; // xstep\n  IR[6] = 20; // ystep\n  IR[7] = 1; // paintType\n  IR[8] = 1; // tilingType\n\n  const pattern = new TilingPattern(IR, \"black\", dummyCtx, dummyGraphicsFactory, [1, 0, 0, 1, 0, 0]);\n\n  const owner = {\n    cachedCanvases: {\n      getCanvas: (name, width, height) => ({\n        canvas: { width, height },\n        context: {\n          canvas: { width, height },\n          translate() {},\n          save() {},\n          restore() {},\n        },\n      }),\n    },\n    groupLevel: 0,\n  };\n\n  const result = pattern.createPatternCanvas(owner);\n  if (result.offsetX !== -10 || result.offsetY !== -10) {\n    throw new Error(\"Pattern offsets do not match the original bbox values.\");\n  }\n});",
    "i1_gpt-4o": "it(\"should use the original bbox origin even if negative\", async () => {\n  const { TilingPattern } = await import(\"../../src/display/pattern_helper.js\");\n\n  const dummyCtx = {\n    canvas: { width: 100, height: 100 },\n    translate() {},\n    save() {},\n    restore() {},\n  };\n\n  const dummyGraphicsFactory = {\n    createCanvasGraphics: (ctx) => ({\n      ctx,\n      groupLevel: 0,\n      transform() {},\n      executeOperatorList() {},\n      endDrawing() {},\n    }),\n  };\n\n  const IR = [];\n  IR[2] = []; // operatorList\n  IR[3] = [1, 0, 0, 1, 0, 0]; // matrix (identity)\n  IR[4] = [-10, -10, 10, 10]; // bbox with negative origin\n  IR[5] = 20; // xstep\n  IR[6] = 20; // ystep\n  IR[7] = 1; // paintType\n  IR[8] = 1; // tilingType\n\n  const pattern = new TilingPattern(IR, \"black\", dummyCtx, dummyGraphicsFactory, [1, 0, 0, 1, 0, 0]);\n\n  const owner = {\n    cachedCanvases: {\n      getCanvas: (name, width, height) => ({\n        canvas: { width, height },\n        context: {\n          canvas: { width, height },\n          translate() {},\n          save() {},\n          restore() {},\n        },\n      }),\n    },\n    groupLevel: 0,\n  };\n\n  const result = pattern.createPatternCanvas(owner);\n  if (result.offsetX !== -10 || result.offsetY !== -10) {\n    throw new Error(\"Pattern offsets do not match the original bbox values.\");\n  }\n});",
    "i1_llama-3.3-70b-versatile": "it(\"should use the original bbox origin even if negative\", async () => {\n  const { TilingPattern } = await import(\"../../src/display/pattern_helper.js\");\n\n  const dummyCtx = {\n    canvas: { width: 100, height: 100 },\n    translate() {},\n    save() {},\n    restore() {},\n  };\n\n  const dummyGraphicsFactory = {\n    createCanvasGraphics: (ctx) => ({\n      ctx,\n      groupLevel: 0,\n      transform() {},\n      executeOperatorList() {},\n      endDrawing() {},\n    }),\n  };\n\n  const IR = [];\n  IR[2] = []; // operatorList\n  IR[3] = [1, 0, 0, 1, 0, 0]; // matrix (identity)\n  IR[4] = [-10, -10, 10, 10]; // bbox with negative origin\n  IR[5] = 20; // xstep\n  IR[6] = 20; // ystep\n  IR[7] = 1; // paintType\n  IR[8] = 1; // tilingType\n\n  const pattern = new TilingPattern(IR, \"black\", dummyCtx, dummyGraphicsFactory, [1, 0, 0, 1, 0, 0]);\n\n  const owner = {\n    cachedCanvases: {\n      getCanvas: (name, width, height) => ({\n        canvas: { width, height },\n        context: {\n          canvas: { width, height },\n          translate() {},\n          save() {},\n          restore() {},\n        },\n      }),\n    },\n    groupLevel: 0,\n  };\n\n  const result = pattern.createPatternCanvas(owner);\n  if (result.offsetX !== -10 || result.offsetY !== -10) {\n    throw new Error(\"Pattern offsets do not match the original bbox values.\");\n  }\n});",
    "i1_MOCK": "it(\"should use the original bbox origin even if negative\", async () => {\n  const { TilingPattern } = await import(\"../../src/display/pattern_helper.js\");\n\n  const dummyCtx = {\n    canvas: { width: 100, height: 100 },\n    translate() {},\n    save() {},\n    restore() {},\n  };\n\n  const dummyGraphicsFactory = {\n    createCanvasGraphics: (ctx) => ({\n      ctx,\n      groupLevel: 0,\n      transform() {},\n      executeOperatorList() {},\n      endDrawing() {},\n    }),\n  };\n\n  const IR = [];\n  IR[2] = []; // operatorList\n  IR[3] = [1, 0, 0, 1, 0, 0]; // matrix (identity)\n  IR[4] = [-10, -10, 10, 10]; // bbox with negative origin\n  IR[5] = 20; // xstep\n  IR[6] = 20; // ystep\n  IR[7] = 1; // paintType\n  IR[8] = 1; // tilingType\n\n  const pattern = new TilingPattern(IR, \"black\", dummyCtx, dummyGraphicsFactory, [1, 0, 0, 1, 0, 0]);\n\n  const owner = {\n    cachedCanvases: {\n      getCanvas: (name, width, height) => ({\n        canvas: { width, height },\n        context: {\n          canvas: { width, height },\n          translate() {},\n          save() {},\n          restore() {},\n        },\n      }),\n    },\n    groupLevel: 0,\n  };\n\n  const result = pattern.createPatternCanvas(owner);\n  if (result.offsetX !== -10 || result.offsetY !== -10) {\n    throw new Error(\"Pattern offsets do not match the original bbox values.\");\n  }\n});",
    "i2_deepseek-r1-distill-llama-70b": "it(\"should use the original bbox origin even if negative\", async () => {\n  const { TilingPattern } = await import(\"../../src/display/pattern_helper.js\");\n\n  const dummyCtx = {\n    canvas: { width: 100, height: 100 },\n    translate() {},\n    save() {},\n    restore() {},\n  };\n\n  const dummyGraphicsFactory = {\n    createCanvasGraphics: (ctx) => ({\n      ctx,\n      groupLevel: 0,\n      transform() {},\n      executeOperatorList() {},\n      endDrawing() {},\n    }),\n  };\n\n  const IR = [];\n  IR[2] = []; // operatorList\n  IR[3] = [1, 0, 0, 1, 0, 0]; // matrix (identity)\n  IR[4] = [-10, -10, 10, 10]; // bbox with negative origin\n  IR[5] = 20; // xstep\n  IR[6] = 20; // ystep\n  IR[7] = 1; // paintType\n  IR[8] = 1; // tilingType\n\n  const pattern = new TilingPattern(IR, \"black\", dummyCtx, dummyGraphicsFactory, [1, 0, 0, 1, 0, 0]);\n\n  const owner = {\n    cachedCanvases: {\n      getCanvas: (name, width, height) => ({\n        canvas: { width, height },\n        context: {\n          canvas: { width, height },\n          translate() {},\n          save() {},\n          restore() {},\n        },\n      }),\n    },\n    groupLevel: 0,\n  };\n\n  const result = pattern.createPatternCanvas(owner);\n  if (result.offsetX !== -10 || result.offsetY !== -10) {\n    throw new Error(\"Pattern offsets do not match the original bbox values.\");\n  }\n});",
    "i2_gpt-4o": "it(\"should use the original bbox origin even if negative\", async () => {\n  const { TilingPattern } = await import(\"../../src/display/pattern_helper.js\");\n\n  const dummyCtx = {\n    canvas: { width: 100, height: 100 },\n    translate() {},\n    save() {},\n    restore() {},\n  };\n\n  const dummyGraphicsFactory = {\n    createCanvasGraphics: (ctx) => ({\n      ctx,\n      groupLevel: 0,\n      transform() {},\n      executeOperatorList() {},\n      endDrawing() {},\n    }),\n  };\n\n  const IR = [];\n  IR[2] = []; // operatorList\n  IR[3] = [1, 0, 0, 1, 0, 0]; // matrix (identity)\n  IR[4] = [-10, -10, 10, 10]; // bbox with negative origin\n  IR[5] = 20; // xstep\n  IR[6] = 20; // ystep\n  IR[7] = 1; // paintType\n  IR[8] = 1; // tilingType\n\n  const pattern = new TilingPattern(IR, \"black\", dummyCtx, dummyGraphicsFactory, [1, 0, 0, 1, 0, 0]);\n\n  const owner = {\n    cachedCanvases: {\n      getCanvas: (name, width, height) => ({\n        canvas: { width, height },\n        context: {\n          canvas: { width, height },\n          translate() {},\n          save() {},\n          restore() {},\n        },\n      }),\n    },\n    groupLevel: 0,\n  };\n\n  const result = pattern.createPatternCanvas(owner);\n  if (result.offsetX !== -10 || result.offsetY !== -10) {\n    throw new Error(\"Pattern offsets do not match the original bbox values.\");\n  }\n});",
    "i2_llama-3.3-70b-versatile": "it(\"should use the original bbox origin even if negative\", async () => {\n  const { TilingPattern } = await import(\"../../src/display/pattern_helper.js\");\n\n  const dummyCtx = {\n    canvas: { width: 100, height: 100 },\n    translate() {},\n    save() {},\n    restore() {},\n  };\n\n  const dummyGraphicsFactory = {\n    createCanvasGraphics: (ctx) => ({\n      ctx,\n      groupLevel: 0,\n      transform() {},\n      executeOperatorList() {},\n      endDrawing() {},\n    }),\n  };\n\n  const IR = [];\n  IR[2] = []; // operatorList\n  IR[3] = [1, 0, 0, 1, 0, 0]; // matrix (identity)\n  IR[4] = [-10, -10, 10, 10]; // bbox with negative origin\n  IR[5] = 20; // xstep\n  IR[6] = 20; // ystep\n  IR[7] = 1; // paintType\n  IR[8] = 1; // tilingType\n\n  const pattern = new TilingPattern(IR, \"black\", dummyCtx, dummyGraphicsFactory, [1, 0, 0, 1, 0, 0]);\n\n  const owner = {\n    cachedCanvases: {\n      getCanvas: (name, width, height) => ({\n        canvas: { width, height },\n        context: {\n          canvas: { width, height },\n          translate() {},\n          save() {},\n          restore() {},\n        },\n      }),\n    },\n    groupLevel: 0,\n  };\n\n  const result = pattern.createPatternCanvas(owner);\n  if (result.offsetX !== -10 || result.offsetY !== -10) {\n    throw new Error(\"Pattern offsets do not match the original bbox values.\");\n  }\n});",
    "i3_deepseek-r1-distill-llama-70b": "it(\"should use the original bbox origin even if negative\", async () => {\n  const { TilingPattern } = await import(\"../../src/display/pattern_helper.js\");\n\n  const dummyCtx = {\n    canvas: { width: 100, height: 100 },\n    translate() {},\n    save() {},\n    restore() {},\n  };\n\n  const dummyGraphicsFactory = {\n    createCanvasGraphics: (ctx) => ({\n      ctx,\n      groupLevel: 0,\n      transform() {},\n      executeOperatorList() {},\n      endDrawing() {},\n    }),\n  };\n\n  const IR = [];\n  IR[2] = []; // operatorList\n  IR[3] = [1, 0, 0, 1, 0, 0]; // matrix (identity)\n  IR[4] = [-10, -10, 10, 10]; // bbox with negative origin\n  IR[5] = 20; // xstep\n  IR[6] = 20; // ystep\n  IR[7] = 1; // paintType\n  IR[8] = 1; // tilingType\n\n  const pattern = new TilingPattern(IR, \"black\", dummyCtx, dummyGraphicsFactory, [1, 0, 0, 1, 0, 0]);\n\n  const owner = {\n    cachedCanvases: {\n      getCanvas: (name, width, height) => ({\n        canvas: { width, height },\n        context: {\n          canvas: { width, height },\n          translate() {},\n          save() {},\n          restore() {},\n        },\n      }),\n    },\n    groupLevel: 0,\n  };\n\n  const result = pattern.createPatternCanvas(owner);\n  if (result.offsetX !== -10 || result.offsetY !== -10) {\n    throw new Error(\"Pattern offsets do not match the original bbox values.\");\n  }\n});",
    "i3_gpt-4o": "it(\"should use the original bbox origin even if negative\", async () => {\n  const { TilingPattern } = await import(\"../../src/display/pattern_helper.js\");\n\n  const dummyCtx = {\n    canvas: { width: 100, height: 100 },\n    translate() {},\n    save() {},\n    restore() {},\n  };\n\n  const dummyGraphicsFactory = {\n    createCanvasGraphics: (ctx) => ({\n      ctx,\n      groupLevel: 0,\n      transform() {},\n      executeOperatorList() {},\n      endDrawing() {},\n    }),\n  };\n\n  const IR = [];\n  IR[2] = []; // operatorList\n  IR[3] = [1, 0, 0, 1, 0, 0]; // matrix (identity)\n  IR[4] = [-10, -10, 10, 10]; // bbox with negative origin\n  IR[5] = 20; // xstep\n  IR[6] = 20; // ystep\n  IR[7] = 1; // paintType\n  IR[8] = 1; // tilingType\n\n  const pattern = new TilingPattern(IR, \"black\", dummyCtx, dummyGraphicsFactory, [1, 0, 0, 1, 0, 0]);\n\n  const owner = {\n    cachedCanvases: {\n      getCanvas: (name, width, height) => ({\n        canvas: { width, height },\n        context: {\n          canvas: { width, height },\n          translate() {},\n          save() {},\n          restore() {},\n        },\n      }),\n    },\n    groupLevel: 0,\n  };\n\n  const result = pattern.createPatternCanvas(owner);\n  if (result.offsetX !== -10 || result.offsetY !== -10) {\n    throw new Error(\"Pattern offsets do not match the original bbox values.\");\n  }\n});",
    "i3_llama-3.3-70b-versatile": "it(\"should use the original bbox origin even if negative\", async () => {\n  const { TilingPattern } = await import(\"../../src/display/pattern_helper.js\");\n\n  const dummyCtx = {\n    canvas: { width: 100, height: 100 },\n    translate() {},\n    save() {},\n    restore() {},\n  };\n\n  const dummyGraphicsFactory = {\n    createCanvasGraphics: (ctx) => ({\n      ctx,\n      groupLevel: 0,\n      transform() {},\n      executeOperatorList() {},\n      endDrawing() {},\n    }),\n  };\n\n  const IR = [];\n  IR[2] = []; // operatorList\n  IR[3] = [1, 0, 0, 1, 0, 0]; // matrix (identity)\n  IR[4] = [-10, -10, 10, 10]; // bbox with negative origin\n  IR[5] = 20; // xstep\n  IR[6] = 20; // ystep\n  IR[7] = 1; // paintType\n  IR[8] = 1; // tilingType\n\n  const pattern = new TilingPattern(IR, \"black\", dummyCtx, dummyGraphicsFactory, [1, 0, 0, 1, 0, 0]);\n\n  const owner = {\n    cachedCanvases: {\n      getCanvas: (name, width, height) => ({\n        canvas: { width, height },\n        context: {\n          canvas: { width, height },\n          translate() {},\n          save() {},\n          restore() {},\n        },\n      }),\n    },\n    groupLevel: 0,\n  };\n\n  const result = pattern.createPatternCanvas(owner);\n  if (result.offsetX !== -10 || result.offsetY !== -10) {\n    throw new Error(\"Pattern offsets do not match the original bbox values.\");\n  }\n});",
    "i4_deepseek-r1-distill-llama-70b": "it(\"should use the original bbox origin even if negative\", async () => {\n  const { TilingPattern } = await import(\"../../src/display/pattern_helper.js\");\n\n  const dummyCtx = {\n    canvas: { width: 100, height: 100 },\n    translate() {},\n    save() {},\n    restore() {},\n  };\n\n  const dummyGraphicsFactory = {\n    createCanvasGraphics: (ctx) => ({\n      ctx,\n      groupLevel: 0,\n      transform() {},\n      executeOperatorList() {},\n      endDrawing() {},\n    }),\n  };\n\n  const IR = [];\n  IR[2] = []; // operatorList\n  IR[3] = [1, 0, 0, 1, 0, 0]; // matrix (identity)\n  IR[4] = [-10, -10, 10, 10]; // bbox with negative origin\n  IR[5] = 20; // xstep\n  IR[6] = 20; // ystep\n  IR[7] = 1; // paintType\n  IR[8] = 1; // tilingType\n\n  const pattern = new TilingPattern(IR, \"black\", dummyCtx, dummyGraphicsFactory, [1, 0, 0, 1, 0, 0]);\n\n  const owner = {\n    cachedCanvases: {\n      getCanvas: (name, width, height) => ({\n        canvas: { width, height },\n        context: {\n          canvas: { width, height },\n          translate() {},\n          save() {},\n          restore() {},\n        },\n      }),\n    },\n    groupLevel: 0,\n  };\n\n  const result = pattern.createPatternCanvas(owner);\n  if (result.offsetX !== -10 || result.offsetY !== -10) {\n    throw new Error(\"Pattern offsets do not match the original bbox values.\");\n  }\n});",
    "i4_gpt-4o": "it(\"should use the original bbox origin even if negative\", async () => {\n  const { TilingPattern } = await import(\"../../src/display/pattern_helper.js\");\n\n  const dummyCtx = {\n    canvas: { width: 100, height: 100 },\n    translate() {},\n    save() {},\n    restore() {},\n  };\n\n  const dummyGraphicsFactory = {\n    createCanvasGraphics: (ctx) => ({\n      ctx,\n      groupLevel: 0,\n      transform() {},\n      executeOperatorList() {},\n      endDrawing() {},\n    }),\n  };\n\n  const IR = [];\n  IR[2] = []; // operatorList\n  IR[3] = [1, 0, 0, 1, 0, 0]; // matrix (identity)\n  IR[4] = [-10, -10, 10, 10]; // bbox with negative origin\n  IR[5] = 20; // xstep\n  IR[6] = 20; // ystep\n  IR[7] = 1; // paintType\n  IR[8] = 1; // tilingType\n\n  const pattern = new TilingPattern(IR, \"black\", dummyCtx, dummyGraphicsFactory, [1, 0, 0, 1, 0, 0]);\n\n  const owner = {\n    cachedCanvases: {\n      getCanvas: (name, width, height) => ({\n        canvas: { width, height },\n        context: {\n          canvas: { width, height },\n          translate() {},\n          save() {},\n          restore() {},\n        },\n      }),\n    },\n    groupLevel: 0,\n  };\n\n  const result = pattern.createPatternCanvas(owner);\n  if (result.offsetX !== -10 || result.offsetY !== -10) {\n    throw new Error(\"Pattern offsets do not match the original bbox values.\");\n  }\n});",
    "i4_llama-3.3-70b-versatile": "it(\"should use the original bbox origin even if negative\", async () => {\n  const { TilingPattern } = await import(\"../../src/display/pattern_helper.js\");\n\n  const dummyCtx = {\n    canvas: { width: 100, height: 100 },\n    translate() {},\n    save() {},\n    restore() {},\n  };\n\n  const dummyGraphicsFactory = {\n    createCanvasGraphics: (ctx) => ({\n      ctx,\n      groupLevel: 0,\n      transform() {},\n      executeOperatorList() {},\n      endDrawing() {},\n    }),\n  };\n\n  const IR = [];\n  IR[2] = []; // operatorList\n  IR[3] = [1, 0, 0, 1, 0, 0]; // matrix (identity)\n  IR[4] = [-10, -10, 10, 10]; // bbox with negative origin\n  IR[5] = 20; // xstep\n  IR[6] = 20; // ystep\n  IR[7] = 1; // paintType\n  IR[8] = 1; // tilingType\n\n  const pattern = new TilingPattern(IR, \"black\", dummyCtx, dummyGraphicsFactory, [1, 0, 0, 1, 0, 0]);\n\n  const owner = {\n    cachedCanvases: {\n      getCanvas: (name, width, height) => ({\n        canvas: { width, height },\n        context: {\n          canvas: { width, height },\n          translate() {},\n          save() {},\n          restore() {},\n        },\n      }),\n    },\n    groupLevel: 0,\n  };\n\n  const result = pattern.createPatternCanvas(owner);\n  if (result.offsetX !== -10 || result.offsetY !== -10) {\n    throw new Error(\"Pattern offsets do not match the original bbox values.\");\n  }\n});",
    "i5_deepseek-r1-distill-llama-70b": "it(\"should use the original bbox origin even if negative\", async () => {\n  const { TilingPattern } = await import(\"../../src/display/pattern_helper.js\");\n\n  const dummyCtx = {\n    canvas: { width: 100, height: 100 },\n    translate() {},\n    save() {},\n    restore() {},\n  };\n\n  const dummyGraphicsFactory = {\n    createCanvasGraphics: (ctx) => ({\n      ctx,\n      groupLevel: 0,\n      transform() {},\n      executeOperatorList() {},\n      endDrawing() {},\n    }),\n  };\n\n  const IR = [];\n  IR[2] = []; // operatorList\n  IR[3] = [1, 0, 0, 1, 0, 0]; // matrix (identity)\n  IR[4] = [-10, -10, 10, 10]; // bbox with negative origin\n  IR[5] = 20; // xstep\n  IR[6] = 20; // ystep\n  IR[7] = 1; // paintType\n  IR[8] = 1; // tilingType\n\n  const pattern = new TilingPattern(IR, \"black\", dummyCtx, dummyGraphicsFactory, [1, 0, 0, 1, 0, 0]);\n\n  const owner = {\n    cachedCanvases: {\n      getCanvas: (name, width, height) => ({\n        canvas: { width, height },\n        context: {\n          canvas: { width, height },\n          translate() {},\n          save() {},\n          restore() {},\n        },\n      }),\n    },\n    groupLevel: 0,\n  };\n\n  const result = pattern.createPatternCanvas(owner);\n  if (result.offsetX !== -10 || result.offsetY !== -10) {\n    throw new Error(\"Pattern offsets do not match the original bbox values.\");\n  }\n});",
    "i5_gpt-4o": "it(\"should use the original bbox origin even if negative\", async () => {\n  const { TilingPattern } = await import(\"../../src/display/pattern_helper.js\");\n\n  const dummyCtx = {\n    canvas: { width: 100, height: 100 },\n    translate() {},\n    save() {},\n    restore() {},\n  };\n\n  const dummyGraphicsFactory = {\n    createCanvasGraphics: (ctx) => ({\n      ctx,\n      groupLevel: 0,\n      transform() {},\n      executeOperatorList() {},\n      endDrawing() {},\n    }),\n  };\n\n  const IR = [];\n  IR[2] = []; // operatorList\n  IR[3] = [1, 0, 0, 1, 0, 0]; // matrix (identity)\n  IR[4] = [-10, -10, 10, 10]; // bbox with negative origin\n  IR[5] = 20; // xstep\n  IR[6] = 20; // ystep\n  IR[7] = 1; // paintType\n  IR[8] = 1; // tilingType\n\n  const pattern = new TilingPattern(IR, \"black\", dummyCtx, dummyGraphicsFactory, [1, 0, 0, 1, 0, 0]);\n\n  const owner = {\n    cachedCanvases: {\n      getCanvas: (name, width, height) => ({\n        canvas: { width, height },\n        context: {\n          canvas: { width, height },\n          translate() {},\n          save() {},\n          restore() {},\n        },\n      }),\n    },\n    groupLevel: 0,\n  };\n\n  const result = pattern.createPatternCanvas(owner);\n  if (result.offsetX !== -10 || result.offsetY !== -10) {\n    throw new Error(\"Pattern offsets do not match the original bbox values.\");\n  }\n});",
    "i5_llama-3.3-70b-versatile": "it(\"should use the original bbox origin even if negative\", async () => {\n  const { TilingPattern } = await import(\"../../src/display/pattern_helper.js\");\n\n  const dummyCtx = {\n    canvas: { width: 100, height: 100 },\n    translate() {},\n    save() {},\n    restore() {},\n  };\n\n  const dummyGraphicsFactory = {\n    createCanvasGraphics: (ctx) => ({\n      ctx,\n      groupLevel: 0,\n      transform() {},\n      executeOperatorList() {},\n      endDrawing() {},\n    }),\n  };\n\n  const IR = [];\n  IR[2] = []; // operatorList\n  IR[3] = [1, 0, 0, 1, 0, 0]; // matrix (identity)\n  IR[4] = [-10, -10, 10, 10]; // bbox with negative origin\n  IR[5] = 20; // xstep\n  IR[6] = 20; // ystep\n  IR[7] = 1; // paintType\n  IR[8] = 1; // tilingType\n\n  const pattern = new TilingPattern(IR, \"black\", dummyCtx, dummyGraphicsFactory, [1, 0, 0, 1, 0, 0]);\n\n  const owner = {\n    cachedCanvases: {\n      getCanvas: (name, width, height) => ({\n        canvas: { width, height },\n        context: {\n          canvas: { width, height },\n          translate() {},\n          save() {},\n          restore() {},\n        },\n      }),\n    },\n    groupLevel: 0,\n  };\n\n  const result = pattern.createPatternCanvas(owner);\n  if (result.offsetX !== -10 || result.offsetY !== -10) {\n    throw new Error(\"Pattern offsets do not match the original bbox values.\");\n  }\n});"
  },
  "18802": {
    "i1_deepseek-r1-distill-llama-70b": "it(\"should correctly render GillSansMT fonts as Helvetica\", async () => {\n  const { getDocument } = await import('../../src/display/api.js');\n  const { buildGetDocumentParams } = await import('./test_utils.js');\n  const loadingTask = getDocument(buildGetDocumentParams('issue18801.pdf'));\n\n  const { pdfDocument } = await loadingTask;\n  const page = await pdfDocument.getPage(1);\n\n  const pageViewport = new PageViewport(page, {\n    scale: 1,\n    rotation: 0,\n  });\n\n  const renderTask = page.render({\n    viewport: pageViewport,\n    canvasContext: null,\n    continueCallback: null,\n  });\n\n  await renderTask.promise;\n\n  const textContent = await page.getTextContent();\n  const textItems = textContent.items;\n\n  const expectedText = \"GillSansMT should be rendered as Helvetica\";\n  const actualText = textItems.map(item => item.str).join('');\n\n  expect(actualText).toContain(expectedText);\n});",
    "i1_gpt-4o": "it(\"should render PDF text fields with correct text\", async () => {\n  const { getDocument } = await import(\"../../src/display/api.js\");\n  const { buildGetDocumentParams } = await import(\"./test_utils.js\");\n  const loadingTask = getDocument(buildGetDocumentParams(\"issue18801.pdf\"));\n  const pdfDocument = await loadingTask.promise;\n  const pdfPage = await pdfDocument.getPage(1);\n  const textContent = await pdfPage.getTextContent();\n  const textItems = textContent.items.map(item => item.str).join(\" \");\n  const expectedText = \"Expected text from the PDF\";\n  expect(textItems).toContain(expectedText);\n});",
    "i1_llama-3.3-70b-versatile": "it(\"should render texts correctly in the PDF\", async () => {\n  const { getDocument } = await import('../../src/display/api.js');\n  const { buildGetDocumentParams } = await import('./test_utils.js');\n  const loadingTask = getDocument(buildGetDocumentParams('issue18801.pdf'));\n  const pdfDocument = await loadingTask.promise;\n  const pdfPage = await pdfDocument.getPage(1);\n  const textContent = await pdfPage.getTextContent();\n  const expectedText = \"Expected text from the PDF\";\n  const actualText = textContent.items.map(item => item.str).join('');\n  expect(actualText).toContain(expectedText);\n});",
    "i2_deepseek-r1-distill-llama-70b": "it(\"should correctly render texts using GillSansMT font\", async () => {\n  const { getDocument } = await import('../../src/display/api.js');\n  const { buildGetDocumentParams } = await import('./test_utils.js');\n  const loadingTask = getDocument(buildGetDocumentParams('issue18801.pdf'));\n\n  const { numPages, getPage } = await loadingTask;\n  const page = await getPage(1);\n  const textContent = await page.getTextContent();\n\n  const expectedText = \"GillSansMT\";\n  const actualText = textContent.items[0].str;\n\n  expect(actualText).toContain(expectedText);\n});",
    "i2_gpt-4o": "it(\"should render text correctly for nonembedded GillSansMT fonts\", async () => {\n  const { getDocument } = await import('../../src/display/api.js');\n  const { buildGetDocumentParams } = await import('./test_utils.js');\n  const loadingTask = getDocument(buildGetDocumentParams('issue18801.pdf'));\n  const pdfDocument = await loadingTask.promise;\n  const page = await pdfDocument.getPage(1);\n  const textContent = await page.getTextContent();\n  const textItems = textContent.items.map(item => item.str).join(' ');\n  const expectedText = \"Expected text from the PDF\";\n  expect(textItems).toContain(expectedText);\n});",
    "i2_llama-3.3-70b-versatile": "it(\"should render texts correctly in PDF with nonembedded GillSansMT fonts\", async () => {\n  const { getDocument } = await import('../../src/display/api.js');\n  const { buildGetDocumentParams } = await import('./test_utils.js');\n  const loadingTask = getDocument(buildGetDocumentParams('issue18801.pdf'));\n  const pdfDocument = await loadingTask.promise;\n  const pdfPage = await pdfDocument.getPage(1);\n  const textContent = await pdfPage.getTextContent();\n  const expectedText = \"Gill Sans MT\"; // Replace with the actual expected text\n  const actualText = textContent.items[0].str;\n  expect(actualText).toBe(expectedText);\n});",
    "i3_deepseek-r1-distill-llama-70b": "it(\"should correctly render Gill Sans MT fonts in PDFs\", async () => {\n  const { getDocument } = await import('../../src/display/api.js');\n  const { buildGetDocumentParams, createTemporaryNodeServer } = await import('./test_utils.js');\n  const server = createTemporaryNodeServer();\n  const loadingTask = getDocument(buildGetDocumentParams('issue18801.pdf'));\n\n  try {\n    const { doc } = await loadingTask;\n    const page = await doc.getPage(1);\n    const renderTask = page.render({\n      viewport: page.getViewport({ scale: 1 }),\n      renderInteractive: false,\n    });\n    await renderTask.promise;\n\n    const actualText = await page.getTextContent();\n    const expectedText = \"Gill Sans MT\";\n\n    expect(actualText.items[0].str).toContain(expectedText);\n  } finally {\n    server.close();\n  }\n});",
    "i3_gpt-4o": "it(\"should render text correctly in the PDF\", async () => {\n  const { getDocument } = await import(\"../../src/display/api.js\");\n  const { buildGetDocumentParams } = await import(\"./test_utils.js\");\n  const loadingTask = getDocument(buildGetDocumentParams(\"issue18801.pdf\"));\n  const pdfDocument = await loadingTask.promise;\n  const pdfPage = await pdfDocument.getPage(1);\n  const textContent = await pdfPage.getTextContent();\n  const textItems = textContent.items.map(item => item.str).join(\" \");\n  const expectedText = \"Expected text from the PDF\";\n  expect(textItems).toContain(expectedText);\n});",
    "i3_llama-3.3-70b-versatile": "it(\"should render text correctly in PDF\", async () => {\n  const { getDocument } = await import('../../src/display/api.js');\n  const { buildGetDocumentParams } = await import('./test_utils.js');\n  const loadingTask = getDocument(buildGetDocumentParams('issue18801.pdf'));\n  const pdfDocument = await loadingTask.promise;\n  const pdfPage = await pdfDocument.getPage(1);\n  const textContent = await pdfPage.getTextContent();\n  const expectedText = \"GillSansMT\";\n  const actualText = textContent.items[0].str;\n  expect(actualText).toBe(expectedText);\n});",
    "i4_deepseek-r1-distill-llama-70b": "it(\"should correctly render GillSansMT fonts as Helvetica\", async () => {\n  const { getDocument } = await import('../../src/display/api.js');\n  const { buildGetDocumentParams } = await import('./test_utils.js');\n  const { getStandardFontName } = await import('../../src/core/standard_fonts.js');\n\n  const loadingTask = getDocument(buildGetDocumentParams('issue18801.pdf'));\n  const pdf = await loadingTask.promise;\n  const page = await pdf.getPage(1);\n  const text = await page.getTextContent();\n\n  function extractTextFromItems(items) {\n    return items.map(item => item.str).join('');\n  }\n\n  const actualText = extractTextFromItems(text.items);\n  const expectedText = \"Correct Text Rendering\";\n\n  expect(actualText).toBe(expectedText);\n});",
    "i4_gpt-4o": "it(\"should render PDF text correctly with GillSansMT font\", async () => {\n  const { getDocument } = await import('../../src/display/api.js');\n  const { buildGetDocumentParams } = await import('./test_utils.js');\n  const loadingTask = getDocument(buildGetDocumentParams('issue18801.pdf'));\n  const pdfDocument = await loadingTask.promise;\n  const page = await pdfDocument.getPage(1);\n  const textContent = await page.getTextContent();\n  const textItems = textContent.items.map(item => item.str);\n  const expectedText = [\"Expected text from PDF\"];\n  expect(textItems).toEqual(expect.arrayContaining(expectedText));\n});",
    "i4_llama-3.3-70b-versatile": "it(\"should render texts correctly in the PDF\", async () => {\n  const { getDocument } = await import('../../src/display/api.js');\n  const { buildGetDocumentParams } = await import('./test_utils.js');\n  const loadingTask = getDocument(buildGetDocumentParams('issue18801.pdf'));\n  const pdfDocument = await loadingTask.promise;\n  const page = await pdfDocument.getPage(1);\n  const textContent = await page.getTextContent();\n  const expectedText = \"Hello World\";\n  const actualText = textContent.items[0].str;\n  expect(actualText).toBe(expectedText);\n});",
    "i5_deepseek-r1-distill-llama-70b": "it(\"should correctly render Gill Sans MT fonts as Helvetica\", async () => {\n  const { getDocument } = await import('../../src/display/api.js');\n  const { buildGetDocumentParams } = await import('./test_utils.js');\n\n  const loadingTask = getDocument(buildGetDocumentParams('issue18801.pdf'));\n  const pdf = await loadingTask.promise;\n  const page = await pdf.getPage(1);\n  const textContent = await page.getTextContent();\n\n  const expectedText = \"Gill Sans MT Bold Italic\";\n  expect(textContent.items[0].str).toContain(expectedText);\n});",
    "i5_gpt-4o": "it(\"should render text correctly in the PDF\", async () => {\n  const { getDocument } = await import('../../src/display/api.js');\n  const { buildGetDocumentParams } = await import('./test_utils.js');\n  const loadingTask = getDocument(buildGetDocumentParams('issue18801.pdf'));\n  const pdfDocument = await loadingTask.promise;\n  const page = await pdfDocument.getPage(1);\n  const textContent = await page.getTextContent();\n  const textItems = textContent.items.map(item => item.str).join(' ');\n  const expectedText = \"Expected text from the PDF\";\n  expect(textItems).toContain(expectedText);\n});",
    "i5_llama-3.3-70b-versatile": "it(\"should render texts in PDF correctly\", async () => {\n  const { getDocument } = await import('../../src/display/api.js');\n  const { buildGetDocumentParams } = await import('./test_utils.js');\n  const loadingTask = getDocument(buildGetDocumentParams('issue18801.pdf'));\n  const pdfDocument = await loadingTask.promise;\n  const pdfPage = await pdfDocument.getPage(1);\n  const textContent = await pdfPage.getTextContent();\n  const expectedText = \"Expected text from the PDF\";\n  const actualText = textContent.items.map(item => item.str).join(\"\");\n  expect(actualText).toBe(expectedText);\n});"
  },
  "18824": {
    "i1_deepseek-r1-distill-llama-70b": "it(\"should correctly update annotation flags when saving with noViewnoPrint set\", async () => {\n  const { WidgetAnnotation } = await import(\"../../src/core/annotation.js\");\n  const { Dict, Name } = await import(\"../../src/core/primitives.js\");\n  const { XRefMock } = await import(\"./test_utils.js\");\n  const xref = new XRefMock();\n  const dict = new Dict(xref);\n  dict.set(\"F\", 0);\n  dict.set(\"FT\", Name.get(\"Btn\"));\n  const annotationGlobals = { acroForm: new Dict(xref) };\n  const widget = new WidgetAnnotation({\n    dict,\n    xref,\n    annotationGlobals,\n    pageRef: null,\n    pageIndex: 0,\n    id: \"testAnnot\",\n    needAppearances: true,\n    collectFields: true,\n  });\n  const storageEntry = { noView: true, noPrint: false, value: widget.data.fieldValue, rotation: undefined };\n  const annotationStorage = new Map();\n  annotationStorage.set(widget.data.id, storageEntry);\n  const evaluator = { xref };\n  const task = { name: \"testTask\" };\n  const changes = await widget.save(evaluator, task, annotationStorage);\n  const savedData = changes && changes[0] && changes[0].data;\n  if (!savedData) {\n    throw new Error(\"No saved data returned\");\n  }\n  if (!savedData.includes(\"/F\")) {\n    throw new Error(\"Annotation flags were not properly updated in the saved data\");\n  }\n});\n",
    "i1_gpt-4o": "it(\"should correctly update annotation flags when saving with noViewnoPrint set\", async () => {\n  const { WidgetAnnotation } = await import(\"../../src/core/annotation.js\");\n  const { Dict, Name } = await import(\"../../src/core/primitives.js\");\n  const { XRefMock } = await import(\"./test_utils.js\");\n  const xref = new XRefMock();\n  const dict = new Dict(xref);\n  dict.set(\"F\", 0);\n  dict.set(\"FT\", Name.get(\"Btn\"));\n  const annotationGlobals = { acroForm: new Dict(xref) };\n  const widget = new WidgetAnnotation({\n    dict,\n    xref,\n    annotationGlobals,\n    pageRef: null,\n    pageIndex: 0,\n    id: \"testAnnot\",\n    needAppearances: true,\n    collectFields: true,\n  });\n  const storageEntry = { noView: true, noPrint: false, value: widget.data.fieldValue, rotation: undefined };\n  const annotationStorage = new Map();\n  annotationStorage.set(widget.data.id, storageEntry);\n  const evaluator = { xref };\n  const task = { name: \"testTask\" };\n  const changes = await widget.save(evaluator, task, annotationStorage);\n  const savedData = changes && changes[0] && changes[0].data;\n  if (!savedData) {\n    throw new Error(\"No saved data returned\");\n  }\n  if (!savedData.includes(\"/F\")) {\n    throw new Error(\"Annotation flags were not properly updated in the saved data\");\n  }\n});\n",
    "i1_llama-3.3-70b-versatile": "it(\"should correctly update annotation flags when saving with noViewnoPrint set\", async () => {\n  const { WidgetAnnotation } = await import(\"../../src/core/annotation.js\");\n  const { Dict, Name } = await import(\"../../src/core/primitives.js\");\n  const { XRefMock } = await import(\"./test_utils.js\");\n  const xref = new XRefMock();\n  const dict = new Dict(xref);\n  dict.set(\"F\", 0);\n  dict.set(\"FT\", Name.get(\"Btn\"));\n  const annotationGlobals = { acroForm: new Dict(xref) };\n  const widget = new WidgetAnnotation({\n    dict,\n    xref,\n    annotationGlobals,\n    pageRef: null,\n    pageIndex: 0,\n    id: \"testAnnot\",\n    needAppearances: true,\n    collectFields: true,\n  });\n  const storageEntry = { noView: true, noPrint: false, value: widget.data.fieldValue, rotation: undefined };\n  const annotationStorage = new Map();\n  annotationStorage.set(widget.data.id, storageEntry);\n  const evaluator = { xref };\n  const task = { name: \"testTask\" };\n  const changes = await widget.save(evaluator, task, annotationStorage);\n  const savedData = changes && changes[0] && changes[0].data;\n  if (!savedData) {\n    throw new Error(\"No saved data returned\");\n  }\n  if (!savedData.includes(\"/F\")) {\n    throw new Error(\"Annotation flags were not properly updated in the saved data\");\n  }\n});\n",
    "i1_MOCK": "it(\"should correctly update annotation flags when saving with noViewnoPrint set\", async () => {\n  const { WidgetAnnotation } = await import(\"../../src/core/annotation.js\");\n  const { Dict, Name } = await import(\"../../src/core/primitives.js\");\n  const { XRefMock } = await import(\"./test_utils.js\");\n  const xref = new XRefMock();\n  const dict = new Dict(xref);\n  dict.set(\"F\", 0);\n  dict.set(\"FT\", Name.get(\"Btn\"));\n  const annotationGlobals = { acroForm: new Dict(xref) };\n  const widget = new WidgetAnnotation({\n    dict,\n    xref,\n    annotationGlobals,\n    pageRef: null,\n    pageIndex: 0,\n    id: \"testAnnot\",\n    needAppearances: true,\n    collectFields: true,\n  });\n  const storageEntry = { noView: true, noPrint: false, value: widget.data.fieldValue, rotation: undefined };\n  const annotationStorage = new Map();\n  annotationStorage.set(widget.data.id, storageEntry);\n  const evaluator = { xref };\n  const task = { name: \"testTask\" };\n  const changes = await widget.save(evaluator, task, annotationStorage);\n  const savedData = changes && changes[0] && changes[0].data;\n  if (!savedData) {\n    throw new Error(\"No saved data returned\");\n  }\n  if (!savedData.includes(\"/F\")) {\n    throw new Error(\"Annotation flags were not properly updated in the saved data\");\n  }\n});\n",
    "i2_deepseek-r1-distill-llama-70b": "it(\"should correctly update annotation flags when saving with noViewnoPrint set\", async () => {\n  const { WidgetAnnotation } = await import(\"../../src/core/annotation.js\");\n  const { Dict, Name } = await import(\"../../src/core/primitives.js\");\n  const { XRefMock } = await import(\"./test_utils.js\");\n  const xref = new XRefMock();\n  const dict = new Dict(xref);\n  dict.set(\"F\", 0);\n  dict.set(\"FT\", Name.get(\"Btn\"));\n  const annotationGlobals = { acroForm: new Dict(xref) };\n  const widget = new WidgetAnnotation({\n    dict,\n    xref,\n    annotationGlobals,\n    pageRef: null,\n    pageIndex: 0,\n    id: \"testAnnot\",\n    needAppearances: true,\n    collectFields: true,\n  });\n  const storageEntry = { noView: true, noPrint: false, value: widget.data.fieldValue, rotation: undefined };\n  const annotationStorage = new Map();\n  annotationStorage.set(widget.data.id, storageEntry);\n  const evaluator = { xref };\n  const task = { name: \"testTask\" };\n  const changes = await widget.save(evaluator, task, annotationStorage);\n  const savedData = changes && changes[0] && changes[0].data;\n  if (!savedData) {\n    throw new Error(\"No saved data returned\");\n  }\n  if (!savedData.includes(\"/F\")) {\n    throw new Error(\"Annotation flags were not properly updated in the saved data\");\n  }\n});\n",
    "i2_gpt-4o": "it(\"should correctly update annotation flags when saving with noViewnoPrint set\", async () => {\n  const { WidgetAnnotation } = await import(\"../../src/core/annotation.js\");\n  const { Dict, Name } = await import(\"../../src/core/primitives.js\");\n  const { XRefMock } = await import(\"./test_utils.js\");\n  const xref = new XRefMock();\n  const dict = new Dict(xref);\n  dict.set(\"F\", 0);\n  dict.set(\"FT\", Name.get(\"Btn\"));\n  const annotationGlobals = { acroForm: new Dict(xref) };\n  const widget = new WidgetAnnotation({\n    dict,\n    xref,\n    annotationGlobals,\n    pageRef: null,\n    pageIndex: 0,\n    id: \"testAnnot\",\n    needAppearances: true,\n    collectFields: true,\n  });\n  const storageEntry = { noView: true, noPrint: false, value: widget.data.fieldValue, rotation: undefined };\n  const annotationStorage = new Map();\n  annotationStorage.set(widget.data.id, storageEntry);\n  const evaluator = { xref };\n  const task = { name: \"testTask\" };\n  const changes = await widget.save(evaluator, task, annotationStorage);\n  const savedData = changes && changes[0] && changes[0].data;\n  if (!savedData) {\n    throw new Error(\"No saved data returned\");\n  }\n  if (!savedData.includes(\"/F\")) {\n    throw new Error(\"Annotation flags were not properly updated in the saved data\");\n  }\n});\n",
    "i2_llama-3.3-70b-versatile": "it(\"should correctly update annotation flags when saving with noViewnoPrint set\", async () => {\n  const { WidgetAnnotation } = await import(\"../../src/core/annotation.js\");\n  const { Dict, Name } = await import(\"../../src/core/primitives.js\");\n  const { XRefMock } = await import(\"./test_utils.js\");\n  const xref = new XRefMock();\n  const dict = new Dict(xref);\n  dict.set(\"F\", 0);\n  dict.set(\"FT\", Name.get(\"Btn\"));\n  const annotationGlobals = { acroForm: new Dict(xref) };\n  const widget = new WidgetAnnotation({\n    dict,\n    xref,\n    annotationGlobals,\n    pageRef: null,\n    pageIndex: 0,\n    id: \"testAnnot\",\n    needAppearances: true,\n    collectFields: true,\n  });\n  const storageEntry = { noView: true, noPrint: false, value: widget.data.fieldValue, rotation: undefined };\n  const annotationStorage = new Map();\n  annotationStorage.set(widget.data.id, storageEntry);\n  const evaluator = { xref };\n  const task = { name: \"testTask\" };\n  const changes = await widget.save(evaluator, task, annotationStorage);\n  const savedData = changes && changes[0] && changes[0].data;\n  if (!savedData) {\n    throw new Error(\"No saved data returned\");\n  }\n  if (!savedData.includes(\"/F\")) {\n    throw new Error(\"Annotation flags were not properly updated in the saved data\");\n  }\n});\n",
    "i3_deepseek-r1-distill-llama-70b": "it(\"should correctly update annotation flags when saving with noViewnoPrint set\", async () => {\n  const { WidgetAnnotation } = await import(\"../../src/core/annotation.js\");\n  const { Dict, Name } = await import(\"../../src/core/primitives.js\");\n  const { XRefMock } = await import(\"./test_utils.js\");\n  const xref = new XRefMock();\n  const dict = new Dict(xref);\n  dict.set(\"F\", 0);\n  dict.set(\"FT\", Name.get(\"Btn\"));\n  const annotationGlobals = { acroForm: new Dict(xref) };\n  const widget = new WidgetAnnotation({\n    dict,\n    xref,\n    annotationGlobals,\n    pageRef: null,\n    pageIndex: 0,\n    id: \"testAnnot\",\n    needAppearances: true,\n    collectFields: true,\n  });\n  const storageEntry = { noView: true, noPrint: false, value: widget.data.fieldValue, rotation: undefined };\n  const annotationStorage = new Map();\n  annotationStorage.set(widget.data.id, storageEntry);\n  const evaluator = { xref };\n  const task = { name: \"testTask\" };\n  const changes = await widget.save(evaluator, task, annotationStorage);\n  const savedData = changes && changes[0] && changes[0].data;\n  if (!savedData) {\n    throw new Error(\"No saved data returned\");\n  }\n  if (!savedData.includes(\"/F\")) {\n    throw new Error(\"Annotation flags were not properly updated in the saved data\");\n  }\n});\n",
    "i3_gpt-4o": "it(\"should correctly update annotation flags when saving with noViewnoPrint set\", async () => {\n  const { WidgetAnnotation } = await import(\"../../src/core/annotation.js\");\n  const { Dict, Name } = await import(\"../../src/core/primitives.js\");\n  const { XRefMock } = await import(\"./test_utils.js\");\n  const xref = new XRefMock();\n  const dict = new Dict(xref);\n  dict.set(\"F\", 0);\n  dict.set(\"FT\", Name.get(\"Btn\"));\n  const annotationGlobals = { acroForm: new Dict(xref) };\n  const widget = new WidgetAnnotation({\n    dict,\n    xref,\n    annotationGlobals,\n    pageRef: null,\n    pageIndex: 0,\n    id: \"testAnnot\",\n    needAppearances: true,\n    collectFields: true,\n  });\n  const storageEntry = { noView: true, noPrint: false, value: widget.data.fieldValue, rotation: undefined };\n  const annotationStorage = new Map();\n  annotationStorage.set(widget.data.id, storageEntry);\n  const evaluator = { xref };\n  const task = { name: \"testTask\" };\n  const changes = await widget.save(evaluator, task, annotationStorage);\n  const savedData = changes && changes[0] && changes[0].data;\n  if (!savedData) {\n    throw new Error(\"No saved data returned\");\n  }\n  if (!savedData.includes(\"/F\")) {\n    throw new Error(\"Annotation flags were not properly updated in the saved data\");\n  }\n});\n",
    "i3_llama-3.3-70b-versatile": "it(\"should correctly update annotation flags when saving with noViewnoPrint set\", async () => {\n  const { WidgetAnnotation } = await import(\"../../src/core/annotation.js\");\n  const { Dict, Name } = await import(\"../../src/core/primitives.js\");\n  const { XRefMock } = await import(\"./test_utils.js\");\n  const xref = new XRefMock();\n  const dict = new Dict(xref);\n  dict.set(\"F\", 0);\n  dict.set(\"FT\", Name.get(\"Btn\"));\n  const annotationGlobals = { acroForm: new Dict(xref) };\n  const widget = new WidgetAnnotation({\n    dict,\n    xref,\n    annotationGlobals,\n    pageRef: null,\n    pageIndex: 0,\n    id: \"testAnnot\",\n    needAppearances: true,\n    collectFields: true,\n  });\n  const storageEntry = { noView: true, noPrint: false, value: widget.data.fieldValue, rotation: undefined };\n  const annotationStorage = new Map();\n  annotationStorage.set(widget.data.id, storageEntry);\n  const evaluator = { xref };\n  const task = { name: \"testTask\" };\n  const changes = await widget.save(evaluator, task, annotationStorage);\n  const savedData = changes && changes[0] && changes[0].data;\n  if (!savedData) {\n    throw new Error(\"No saved data returned\");\n  }\n  if (!savedData.includes(\"/F\")) {\n    throw new Error(\"Annotation flags were not properly updated in the saved data\");\n  }\n});\n",
    "i4_deepseek-r1-distill-llama-70b": "it(\"should correctly update annotation flags when saving with noViewnoPrint set\", async () => {\n  const { WidgetAnnotation } = await import(\"../../src/core/annotation.js\");\n  const { Dict, Name } = await import(\"../../src/core/primitives.js\");\n  const { XRefMock } = await import(\"./test_utils.js\");\n  const xref = new XRefMock();\n  const dict = new Dict(xref);\n  dict.set(\"F\", 0);\n  dict.set(\"FT\", Name.get(\"Btn\"));\n  const annotationGlobals = { acroForm: new Dict(xref) };\n  const widget = new WidgetAnnotation({\n    dict,\n    xref,\n    annotationGlobals,\n    pageRef: null,\n    pageIndex: 0,\n    id: \"testAnnot\",\n    needAppearances: true,\n    collectFields: true,\n  });\n  const storageEntry = { noView: true, noPrint: false, value: widget.data.fieldValue, rotation: undefined };\n  const annotationStorage = new Map();\n  annotationStorage.set(widget.data.id, storageEntry);\n  const evaluator = { xref };\n  const task = { name: \"testTask\" };\n  const changes = await widget.save(evaluator, task, annotationStorage);\n  const savedData = changes && changes[0] && changes[0].data;\n  if (!savedData) {\n    throw new Error(\"No saved data returned\");\n  }\n  if (!savedData.includes(\"/F\")) {\n    throw new Error(\"Annotation flags were not properly updated in the saved data\");\n  }\n});\n",
    "i4_gpt-4o": "it(\"should correctly update annotation flags when saving with noViewnoPrint set\", async () => {\n  const { WidgetAnnotation } = await import(\"../../src/core/annotation.js\");\n  const { Dict, Name } = await import(\"../../src/core/primitives.js\");\n  const { XRefMock } = await import(\"./test_utils.js\");\n  const xref = new XRefMock();\n  const dict = new Dict(xref);\n  dict.set(\"F\", 0);\n  dict.set(\"FT\", Name.get(\"Btn\"));\n  const annotationGlobals = { acroForm: new Dict(xref) };\n  const widget = new WidgetAnnotation({\n    dict,\n    xref,\n    annotationGlobals,\n    pageRef: null,\n    pageIndex: 0,\n    id: \"testAnnot\",\n    needAppearances: true,\n    collectFields: true,\n  });\n  const storageEntry = { noView: true, noPrint: false, value: widget.data.fieldValue, rotation: undefined };\n  const annotationStorage = new Map();\n  annotationStorage.set(widget.data.id, storageEntry);\n  const evaluator = { xref };\n  const task = { name: \"testTask\" };\n  const changes = await widget.save(evaluator, task, annotationStorage);\n  const savedData = changes && changes[0] && changes[0].data;\n  if (!savedData) {\n    throw new Error(\"No saved data returned\");\n  }\n  if (!savedData.includes(\"/F\")) {\n    throw new Error(\"Annotation flags were not properly updated in the saved data\");\n  }\n});\n",
    "i4_llama-3.3-70b-versatile": "it(\"should correctly update annotation flags when saving with noViewnoPrint set\", async () => {\n  const { WidgetAnnotation } = await import(\"../../src/core/annotation.js\");\n  const { Dict, Name } = await import(\"../../src/core/primitives.js\");\n  const { XRefMock } = await import(\"./test_utils.js\");\n  const xref = new XRefMock();\n  const dict = new Dict(xref);\n  dict.set(\"F\", 0);\n  dict.set(\"FT\", Name.get(\"Btn\"));\n  const annotationGlobals = { acroForm: new Dict(xref) };\n  const widget = new WidgetAnnotation({\n    dict,\n    xref,\n    annotationGlobals,\n    pageRef: null,\n    pageIndex: 0,\n    id: \"testAnnot\",\n    needAppearances: true,\n    collectFields: true,\n  });\n  const storageEntry = { noView: true, noPrint: false, value: widget.data.fieldValue, rotation: undefined };\n  const annotationStorage = new Map();\n  annotationStorage.set(widget.data.id, storageEntry);\n  const evaluator = { xref };\n  const task = { name: \"testTask\" };\n  const changes = await widget.save(evaluator, task, annotationStorage);\n  const savedData = changes && changes[0] && changes[0].data;\n  if (!savedData) {\n    throw new Error(\"No saved data returned\");\n  }\n  if (!savedData.includes(\"/F\")) {\n    throw new Error(\"Annotation flags were not properly updated in the saved data\");\n  }\n});\n",
    "i5_deepseek-r1-distill-llama-70b": "it(\"should correctly update annotation flags when saving with noViewnoPrint set\", async () => {\n  const { WidgetAnnotation } = await import(\"../../src/core/annotation.js\");\n  const { Dict, Name } = await import(\"../../src/core/primitives.js\");\n  const { XRefMock } = await import(\"./test_utils.js\");\n  const xref = new XRefMock();\n  const dict = new Dict(xref);\n  dict.set(\"F\", 0);\n  dict.set(\"FT\", Name.get(\"Btn\"));\n  const annotationGlobals = { acroForm: new Dict(xref) };\n  const widget = new WidgetAnnotation({\n    dict,\n    xref,\n    annotationGlobals,\n    pageRef: null,\n    pageIndex: 0,\n    id: \"testAnnot\",\n    needAppearances: true,\n    collectFields: true,\n  });\n  const storageEntry = { noView: true, noPrint: false, value: widget.data.fieldValue, rotation: undefined };\n  const annotationStorage = new Map();\n  annotationStorage.set(widget.data.id, storageEntry);\n  const evaluator = { xref };\n  const task = { name: \"testTask\" };\n  const changes = await widget.save(evaluator, task, annotationStorage);\n  const savedData = changes && changes[0] && changes[0].data;\n  if (!savedData) {\n    throw new Error(\"No saved data returned\");\n  }\n  if (!savedData.includes(\"/F\")) {\n    throw new Error(\"Annotation flags were not properly updated in the saved data\");\n  }\n});\n",
    "i5_gpt-4o": "it(\"should correctly update annotation flags when saving with noViewnoPrint set\", async () => {\n  const { WidgetAnnotation } = await import(\"../../src/core/annotation.js\");\n  const { Dict, Name } = await import(\"../../src/core/primitives.js\");\n  const { XRefMock } = await import(\"./test_utils.js\");\n  const xref = new XRefMock();\n  const dict = new Dict(xref);\n  dict.set(\"F\", 0);\n  dict.set(\"FT\", Name.get(\"Btn\"));\n  const annotationGlobals = { acroForm: new Dict(xref) };\n  const widget = new WidgetAnnotation({\n    dict,\n    xref,\n    annotationGlobals,\n    pageRef: null,\n    pageIndex: 0,\n    id: \"testAnnot\",\n    needAppearances: true,\n    collectFields: true,\n  });\n  const storageEntry = { noView: true, noPrint: false, value: widget.data.fieldValue, rotation: undefined };\n  const annotationStorage = new Map();\n  annotationStorage.set(widget.data.id, storageEntry);\n  const evaluator = { xref };\n  const task = { name: \"testTask\" };\n  const changes = await widget.save(evaluator, task, annotationStorage);\n  const savedData = changes && changes[0] && changes[0].data;\n  if (!savedData) {\n    throw new Error(\"No saved data returned\");\n  }\n  if (!savedData.includes(\"/F\")) {\n    throw new Error(\"Annotation flags were not properly updated in the saved data\");\n  }\n});\n",
    "i5_llama-3.3-70b-versatile": "it(\"should correctly update annotation flags when saving with noViewnoPrint set\", async () => {\n  const { WidgetAnnotation } = await import(\"../../src/core/annotation.js\");\n  const { Dict, Name } = await import(\"../../src/core/primitives.js\");\n  const { XRefMock } = await import(\"./test_utils.js\");\n  const xref = new XRefMock();\n  const dict = new Dict(xref);\n  dict.set(\"F\", 0);\n  dict.set(\"FT\", Name.get(\"Btn\"));\n  const annotationGlobals = { acroForm: new Dict(xref) };\n  const widget = new WidgetAnnotation({\n    dict,\n    xref,\n    annotationGlobals,\n    pageRef: null,\n    pageIndex: 0,\n    id: \"testAnnot\",\n    needAppearances: true,\n    collectFields: true,\n  });\n  const storageEntry = { noView: true, noPrint: false, value: widget.data.fieldValue, rotation: undefined };\n  const annotationStorage = new Map();\n  annotationStorage.set(widget.data.id, storageEntry);\n  const evaluator = { xref };\n  const task = { name: \"testTask\" };\n  const changes = await widget.save(evaluator, task, annotationStorage);\n  const savedData = changes && changes[0] && changes[0].data;\n  if (!savedData) {\n    throw new Error(\"No saved data returned\");\n  }\n  if (!savedData.includes(\"/F\")) {\n    throw new Error(\"Annotation flags were not properly updated in the saved data\");\n  }\n});\n"
  },
  "18844": {
    "i1_deepseek-r1-distill-llama-70b": "it(\"should use correct font family on Windows Firefox\", async () => {\n  const { FeatureTest } = await import(\"../../src/shared/util.js\");\n  const { TextLayer } = await import(\"../../src/display/text_layer.js\");\n\n  // Mock platform detection\n  const originalPlatform = FeatureTest.platform;\n  FeatureTest.platform = () => ({\n    isWindows: true,\n    isFirefox: true,\n  });\n\n  const container = document.createElement(\"div\");\n  const textLayer = new TextLayer({\n    textContentSource: new ReadableStream({\n      start(controller) {\n        controller.enqueue(\"Test\");\n        controller.close();\n      },\n    }),\n    container,\n    viewport: {\n      scale: 1,\n      rotation: 0,\n      rawDims: { pageWidth: 100, pageHeight: 100, pageX: 0, pageY: 0 },\n    },\n  });\n\n  const style = {\n    fontFamily: 'sans-serif',\n    fontSubstitution: 'sans-serif',\n    vertical: false,\n  };\n\n  const fontFamily = TextLayer.fontFamilyMap.get(style.fontFamily) || style.fontFamily;\n  expect(fontFamily).toContain(\"Calibri\");\n});",
    "i1_gpt-4o": "it(\"should correctly map font families on Windows Firefox\", async () => {\n  const { FeatureTest } = await import(\"../../src/shared/util.js\");\n  const { TextLayer } = await import(\"../../src/display/text_layer.js\");\n\n  // Mock the platform to simulate Windows Firefox environment\n  const originalPlatform = FeatureTest.platform;\n  FeatureTest.platform = {\n    isWindows: true,\n    isFirefox: true,\n  };\n\n  const expectedFontFamilyMap = new Map([\n    [\"sans-serif\", \"Calibri, sans-serif\"],\n    [\"monospace\", \"Lucida Console, monospace\"],\n  ]);\n\n  const actualFontFamilyMap = TextLayer.fontFamilyMap;\n\n  // Restore the original platform\n  FeatureTest.platform = originalPlatform;\n\n  expect(actualFontFamilyMap).toEqual(expectedFontFamilyMap);\n});",
    "i1_llama-3.3-70b-versatile": "it(\"should render text layer correctly on Windows with Firefox\", async () => {\n  const { getDocument } = await import(\"../../src/display/api.js\");\n  const { TextLayer } = await import(\"../../src/display/text_layer.js\");\n  const { FeatureTest } = await import(\"../../src/shared/util.js\");\n  const originalPlatform = FeatureTest.platform;\n  FeatureTest.platform = {\n    isWindows: true,\n    isFirefox: true,\n  };\n  const textContentSource = [\n    {\n      str: \"Hello World\",\n      fontName: \"sans-serif\",\n      fontSize: 12,\n      transform: [1, 0, 0, 1, 0, 0],\n    },\n  ];\n  const container = document.createElement(\"div\");\n  const viewport = {\n    scale: 1,\n    rotation: 0,\n    rawDims: {\n      pageWidth: 100,\n      pageHeight: 100,\n      pageX: 0,\n      pageY: 0,\n    },\n  };\n  const textLayer = new TextLayer({\n    textContentSource,\n    container,\n    viewport,\n  });\n  await textLayer.render();\n  const textDiv = container.querySelector(\"span\");\n  expect(textDiv.style.fontFamily).toBe(\"Calibri, sans-serif\");\n  FeatureTest.platform = originalPlatform;\n});",
    "i2_deepseek-r1-distill-llama-70b": "it(\"should use Calibri and Lucida Console on Windows and Firefox\", async () => {\n  const { TextLayer, FeatureTest } = await import(\"../../src/display/text_layer.js\");\n\n  // Mock the platform to be Windows and Firefox\n  const mockPlatform = {\n    isWindows: true,\n    isFirefox: true,\n  };\n  jest.spyOn(FeatureTest, \"platform\", \"get\").mockReturnValue(mockPlatform);\n\n  // Create a TextLayer instance\n  const textLayer = new TextLayer({\n    textContentSource: new ReadableStream({\n      start(controller) {\n        controller.enqueue(\"test\");\n        controller.close();\n      },\n    }),\n    container: document.createElement(\"div\"),\n    viewport: {\n      scale: 1,\n      rotation: 0,\n      rawDims: {\n        pageWidth: 100,\n        pageHeight: 100,\n        pageX: 0,\n        pageY: 0,\n      },\n    },\n  });\n\n  // Get the fontFamilyMap\n  const fontFamilyMap = TextLayer.fontFamilyMap;\n\n  // Verify the expected fonts\n  expect(fontFamilyMap.get(\"sans-serif\")).toContain(\"Calibri\");\n  expect(fontFamilyMap.get(\"monospace\")).toContain(\"Lucida Console\");\n});",
    "i2_gpt-4o": "it(\"should use Calibri and Lucida Console on Windows with Firefox\", async () => {\n  const { TextLayer } = await import(\"../../src/display/text_layer.js\");\n  const { FeatureTest } = await import(\"../../src/shared/util.js\");\n\n  // Mock platform detection\n  FeatureTest.platform = {\n    isWindows: true,\n    isFirefox: true,\n  };\n\n  const fontFamilyMap = TextLayer.fontFamilyMap;\n  const expectedSansSerif = \"Calibri, sans-serif\";\n  const expectedMonospace = \"Lucida Console, monospace\";\n\n  const actualSansSerif = fontFamilyMap.get(\"sans-serif\");\n  const actualMonospace = fontFamilyMap.get(\"monospace\");\n\n  expect(actualSansSerif).toBe(expectedSansSerif);\n  expect(actualMonospace).toBe(expectedMonospace);\n});",
    "i2_llama-3.3-70b-versatile": "it(\"should render text layer with correct font family on Windows and Firefox\", async () => {\n  const { TextLayer, FeatureTest } = await import(\"../../src/display/text_layer.js\");\n  const { Util } = await import(\"../../src/shared/util.js\");\n  const { PageViewport } = await import(\"../../src/display/display_utils.js\");\n\n  const viewport = new PageViewport({ scale: 1, rotation: 0, width: 100, height: 100 });\n  const textContentSource = { items: [{ str: \"Hello World\", fontName: \"sans-serif\" }] };\n  const container = document.createElement(\"div\");\n\n  const originalPlatform = FeatureTest.platform;\n  FeatureTest.platform = {\n    isWindows: true,\n    isFirefox: true,\n  };\n\n  const textLayer = new TextLayer({ textContentSource, container, viewport });\n  await textLayer.render();\n\n  const textDiv = container.querySelector(\"span\");\n  const fontFamily = textDiv.style.fontFamily;\n\n  const expectedFontFamily = \"Calibri, sans-serif\";\n\n  expect(fontFamily).toBe(expectedFontFamily);\n\n  FeatureTest.platform = originalPlatform;\n});",
    "i3_deepseek-r1-distill-llama-70b": "it(\"should use correct font families on Windows\", async () => {\n  const { TextLayer } = await import(\"../../src/display/text_layer.js\");\n  const { FeatureTest } = await import(\"../../src/shared/util.js\");\n\n  // Mock platform detection for Windows and Firefox\n  const originalPlatform = FeatureTest.platform;\n  FeatureTest.platform = () => ({\n    isMac: false,\n    isWindows: true,\n    isFirefox: true,\n  });\n\n  // Test content with specific font families\n  const textContent = {\n    items: [\n      {\n        type: \"text\",\n        str: \"Sample text\",\n        fontName: \"sans-serif\",\n        fontSize: 30,\n        fontSubstitution: true,\n      },\n      {\n        type: \"text\",\n        str: \"Monospace text\",\n        fontName: \"monospace\",\n        fontSize: 30,\n        fontSubstitution: true,\n      },\n    ],\n  };\n\n  // Render the text layer\n  const container = document.createElement(\"div\");\n  const viewport = {\n    scale: 1,\n    rawDims: { pageWidth: 100, pageHeight: 100 },\n    rotation: 0,\n  };\n  const textLayer = new TextLayer({ textContentSource: textContent, container, viewport });\n  await textLayer.render();\n\n  // Verify font families are correctly applied\n  const sansSerifFont = textLayer.textDivs[0].style.fontFamily;\n  const monospaceFont = textLayer.textDivs[1].style.fontFamily;\n\n  expect(sansSerifFont).toContain(\"Calibri\");\n  expect(monospaceFont).toContain(\"Lucida Console\");\n\n  // Cleanup\n  FeatureTest.platform = originalPlatform;\n  container.remove();\n});",
    "i3_gpt-4o": "it(\"should apply correct font family mapping on Windows with Firefox\", async () => {\n  const { FeatureTest } = await import(\"../../src/shared/util.js\");\n  const { TextLayer } = await import(\"../../src/display/text_layer.js\");\n\n  // Mock platform and userAgent to simulate Windows with Firefox\n  Object.defineProperty(FeatureTest, \"platform\", {\n    get: () => ({ isWindows: true, isFirefox: true }),\n  });\n\n  const textLayer = new TextLayer({\n    textContentSource: new ReadableStream({\n      start(controller) {\n        controller.enqueue({\n          items: [{ str: \"Test\", fontName: \"sans-serif\" }],\n          styles: { \"sans-serif\": { fontFamily: \"sans-serif\" } },\n        });\n        controller.close();\n      },\n    }),\n    container: document.createElement(\"div\"),\n    viewport: { scale: 1, rotation: 0, rawDims: { pageWidth: 100, pageHeight: 100, pageX: 0, pageY: 0 } },\n  });\n\n  await textLayer.render();\n\n  const expectedFontFamily = \"Calibri, sans-serif\";\n  const actualFontFamily = textLayer.textDivs[0].style.fontFamily;\n  expect(actualFontFamily).toBe(expectedFontFamily);\n});",
    "i3_llama-3.3-70b-versatile": "it(\"should render text layer with correct font family on Windows and Firefox\", async () => {\n  const { getDocument } = await import(\"../../src/display/api.js\");\n  const { TextLayer } = await import(\"../../src/display/text_layer.js\");\n  const { FeatureTest } = await import(\"../../src/shared/util.js\");\n\n  const originalPlatform = FeatureTest.platform;\n  FeatureTest.platform = { isWindows: true, isFirefox: true };\n\n  const document = await getDocument({ url: \"./test.pdf\" });\n  const page = await document.getPage(1);\n  const textContent = await page.getTextContent();\n  const textLayer = new TextLayer({\n    textContentSource: textContent,\n    container: document.createElement(\"div\"),\n    viewport: page.getViewport({ scale: 1 }),\n  });\n\n  await textLayer.render();\n\n  const textDivs = textLayer.textDivs;\n  const fontFamily = textDivs[0].style.fontFamily;\n\n  expect(fontFamily).toBe(\"Calibri, sans-serif\");\n\n  FeatureTest.platform = originalPlatform;\n});",
    "i4_deepseek-r1-distill-llama-70b": "it(\"should adjust font family for Windows and Firefox\", async () => {\n  const { TextLayer } = await import(\"../../src/display/text_layer.js\");\n  const { FeatureTest } = await import(\"../../shared/util.js\");\n\n  // Mock the platform as Windows and Firefox\n  const platform = {\n    isMac: false,\n    isWindows: true,\n    isFirefox: true,\n  };\n  FeatureTest.platform = shadow(FeatureTest, \"platform\", platform);\n\n  // Get the font family map\n  const fontFamilyMap = TextLayer.fontFamilyMap;\n\n  // Expected font family strings\n  const expectedSansSerif = \"Calibri, sans-serif\";\n  const expectedMonospace = \"Lucida Console, monospace\";\n\n  // Get actual font family strings\n  const actualSansSerif = fontFamilyMap.get(\"sans-serif\");\n  const actualMonospace = fontFamilyMap.get(\"monospace\");\n\n  // Verify the font families match expectations\n  expect(actualSansSerif).toBe(expectedSansSerif);\n  expect(actualMonospace).toBe(expectedMonospace);\n});",
    "i4_gpt-4o": "it(\"should correctly map font families on Windows with Firefox\", async () => {\n  const { TextLayer } = await import(\"../../src/display/text_layer.js\");\n  const { FeatureTest } = await import(\"../../src/shared/util.js\");\n\n  // Mock platform detection\n  FeatureTest.platform = { isWindows: true, isFirefox: true };\n\n  const expectedFontFamilyMap = new Map([\n    [\"sans-serif\", \"Calibri, sans-serif\"],\n    [\"monospace\", \"Lucida Console, monospace\"],\n  ]);\n\n  const actualFontFamilyMap = TextLayer.fontFamilyMap;\n\n  for (const [key, value] of expectedFontFamilyMap) {\n    if (actualFontFamilyMap.get(key) !== value) {\n      throw new Error(`Font family mapping for ${key} is incorrect.`);\n    }\n  }\n});",
    "i4_llama-3.3-70b-versatile": "it(\"should render text layer with correct font family on Windows and Firefox\", async () => {\n  const { TextLayer } = await import(\"../../src/display/text_layer.js\");\n  const { FeatureTest } = await import(\"../../src/shared/util.js\");\n  const { setLayerDimensions } = await import(\"../../src/display/display_utils.js\");\n\n  const textContentSource = {\n    items: [\n      {\n        str: \"Hello World\",\n        fontName: \"sans-serif\",\n      },\n    ],\n    styles: {\n      \"sans-serif\": {\n        fontFamily: \"sans-serif\",\n      },\n    },\n  };\n\n  const container = document.createElement(\"div\");\n  const viewport = {\n    scale: 1,\n    rotation: 0,\n    rawDims: {\n      pageWidth: 100,\n      pageHeight: 100,\n      pageX: 0,\n      pageY: 0,\n    },\n  };\n\n  const textLayer = new TextLayer({\n    textContentSource,\n    container,\n    viewport,\n  });\n\n  await textLayer.render();\n\n  const expectedFontFamily = FeatureTest.platform.isWindows && FeatureTest.platform.isFirefox ? \"Calibri, sans-serif\" : \"sans-serif\";\n  const actualFontFamily = textLayer.textDivs[0].style.fontFamily;\n\n  expect(actualFontFamily).toBe(expectedFontFamily);\n});",
    "i5_deepseek-r1-distill-llama-70b": "it(\"should adjust font family on Windows and Firefox\", async () => {\n  const { TextLayer, FeatureTest } = await import(\"../../src/display/text_layer.js\");\n\n  // Mock platform detection\n  const originalPlatform = FeatureTest.platform;\n  FeatureTest.platform = () => ({\n    isMac: false,\n    isWindows: true,\n    isFirefox: true,\n  });\n\n  const textLayer = new TextLayer(null, null, null);\n\n  // Expected font families after adjustment\n  const expectedSansSerif = \"Calibri, sans-serif\";\n  const expectedMonospace = \"Lucida Console, monospace\";\n\n  // Actual font families from the adjusted map\n  const actualSansSerif = TextLayer.fontFamilyMap.get(\"sans-serif\");\n  const actualMonospace = TextLayer.fontFamilyMap.get(\"monospace\");\n\n  // Cleanup\n  FeatureTest.platform = originalPlatform;\n\n  expect(actualSansSerif).toBe(expectedSansSerif);\n  expect(actualMonospace).toBe(expectedMonospace);\n});",
    "i5_gpt-4o": "it(\"should match text layer and canvas font family on Windows with Firefox\", async () => {\n  const { TextLayer } = await import(\"../../src/display/text_layer.js\");\n  const { FeatureTest } = await import(\"../../src/shared/util.js\");\n\n  // Simulate Windows and Firefox environment\n  FeatureTest.platform = { isWindows: true, isFirefox: true };\n\n  const textLayer = new TextLayer();\n  const style = { fontFamily: \"sans-serif\" };\n  const expectedFontFamily = \"Calibri, sans-serif\";\n\n  // Simulate rendering process\n  let fontFamily = style.fontFamily;\n  fontFamily = TextLayer.fontFamilyMap.get(fontFamily) || fontFamily;\n\n  // Check if the font family matches the expected value\n  expect(fontFamily).toBe(expectedFontFamily);\n});",
    "i5_llama-3.3-70b-versatile": "it(\"should render text layer with correct font family on Windows and Firefox\", async () => {\n  const { TextLayer, FeatureTest, PageViewport } = await import(\"../../src/display/text_layer.js\");\n  const { PDFDocument, PDFPage } = await import(\"../../src/core/document.js\");\n  const { createIdFactory } = await import(\"./test_utils.js\");\n\n  const pdfDocument = await PDFDocument.load(await createIdFactory());\n  const pdfPage = await pdfDocument.getPage(1);\n  const viewport = new PageViewport({ pdfPage });\n\n  const textLayer = new TextLayer({\n    viewport,\n    textContentItems: [{ str: \"Hello World\", font: { fontFamily: \"sans-serif\" } }],\n  });\n\n  const featureTest = new FeatureTest();\n  featureTest.platform = { isWindows: true, isFirefox: true };\n\n  const expectedFontFamily = \"Calibri, sans-serif\";\n  const actualFontFamily = TextLayer.fontFamilyMap.get(\"sans-serif\");\n\n  expect(actualFontFamily).toBe(expectedFontFamily);\n});"
  },
  "18853": {
    "i1_deepseek-r1-distill-llama-70b": "it(\"should restore extra line breaks when extracting text content from a text widget annotation\", async () => {\n  const { TextWidgetAnnotation } = await import(\"../../src/core/annotation.js\");\n  // Create a fake instance with only the needed properties.\n  const annotation = Object.create(TextWidgetAnnotation.prototype);\n  annotation.data = {\n    // The text extractor originally produced textContent without the extra blank line.\n    textContent: [\"Line1\", \"Line2\"],\n    // But the actual field value contains an extra blank line.\n    fieldValue: \"Line1\\n\\nLine2\",\n  };\n  // Call the new extractTextContent method.\n  await annotation.extractTextContent({}, {}, {});\n  // Now, after extraction, textContent should match fieldValue split by \"\\n\".\n  if (annotation.data.textContent.join(\"\\n\") !== annotation.data.fieldValue) {\n    throw new Error(\"Extra line breaks were not correctly restored.\");\n  }\n});",
    "i1_gpt-4o": "it(\"should restore extra line breaks when extracting text content from a text widget annotation\", async () => {\n  const { TextWidgetAnnotation } = await import(\"../../src/core/annotation.js\");\n  // Create a fake instance with only the needed properties.\n  const annotation = Object.create(TextWidgetAnnotation.prototype);\n  annotation.data = {\n    // The text extractor originally produced textContent without the extra blank line.\n    textContent: [\"Line1\", \"Line2\"],\n    // But the actual field value contains an extra blank line.\n    fieldValue: \"Line1\\n\\nLine2\",\n  };\n  // Call the new extractTextContent method.\n  await annotation.extractTextContent({}, {}, {});\n  // Now, after extraction, textContent should match fieldValue split by \"\\n\".\n  if (annotation.data.textContent.join(\"\\n\") !== annotation.data.fieldValue) {\n    throw new Error(\"Extra line breaks were not correctly restored.\");\n  }\n});",
    "i1_llama-3.3-70b-versatile": "it(\"should restore extra line breaks when extracting text content from a text widget annotation\", async () => {\n  const { TextWidgetAnnotation } = await import(\"../../src/core/annotation.js\");\n  // Create a fake instance with only the needed properties.\n  const annotation = Object.create(TextWidgetAnnotation.prototype);\n  annotation.data = {\n    // The text extractor originally produced textContent without the extra blank line.\n    textContent: [\"Line1\", \"Line2\"],\n    // But the actual field value contains an extra blank line.\n    fieldValue: \"Line1\\n\\nLine2\",\n  };\n  // Call the new extractTextContent method.\n  await annotation.extractTextContent({}, {}, {});\n  // Now, after extraction, textContent should match fieldValue split by \"\\n\".\n  if (annotation.data.textContent.join(\"\\n\") !== annotation.data.fieldValue) {\n    throw new Error(\"Extra line breaks were not correctly restored.\");\n  }\n});",
    "i1_MOCK": "it(\"should restore extra line breaks when extracting text content from a text widget annotation\", async () => {\n  const { TextWidgetAnnotation } = await import(\"../../src/core/annotation.js\");\n  // Create a fake instance with only the needed properties.\n  const annotation = Object.create(TextWidgetAnnotation.prototype);\n  annotation.data = {\n    // The text extractor originally produced textContent without the extra blank line.\n    textContent: [\"Line1\", \"Line2\"],\n    // But the actual field value contains an extra blank line.\n    fieldValue: \"Line1\\n\\nLine2\",\n  };\n  // Call the new extractTextContent method.\n  await annotation.extractTextContent({}, {}, {});\n  // Now, after extraction, textContent should match fieldValue split by \"\\n\".\n  if (annotation.data.textContent.join(\"\\n\") !== annotation.data.fieldValue) {\n    throw new Error(\"Extra line breaks were not correctly restored.\");\n  }\n});",
    "i2_deepseek-r1-distill-llama-70b": "it(\"should restore extra line breaks when extracting text content from a text widget annotation\", async () => {\n  const { TextWidgetAnnotation } = await import(\"../../src/core/annotation.js\");\n  // Create a fake instance with only the needed properties.\n  const annotation = Object.create(TextWidgetAnnotation.prototype);\n  annotation.data = {\n    // The text extractor originally produced textContent without the extra blank line.\n    textContent: [\"Line1\", \"Line2\"],\n    // But the actual field value contains an extra blank line.\n    fieldValue: \"Line1\\n\\nLine2\",\n  };\n  // Call the new extractTextContent method.\n  await annotation.extractTextContent({}, {}, {});\n  // Now, after extraction, textContent should match fieldValue split by \"\\n\".\n  if (annotation.data.textContent.join(\"\\n\") !== annotation.data.fieldValue) {\n    throw new Error(\"Extra line breaks were not correctly restored.\");\n  }\n});",
    "i2_gpt-4o": "it(\"should restore extra line breaks when extracting text content from a text widget annotation\", async () => {\n  const { TextWidgetAnnotation } = await import(\"../../src/core/annotation.js\");\n  // Create a fake instance with only the needed properties.\n  const annotation = Object.create(TextWidgetAnnotation.prototype);\n  annotation.data = {\n    // The text extractor originally produced textContent without the extra blank line.\n    textContent: [\"Line1\", \"Line2\"],\n    // But the actual field value contains an extra blank line.\n    fieldValue: \"Line1\\n\\nLine2\",\n  };\n  // Call the new extractTextContent method.\n  await annotation.extractTextContent({}, {}, {});\n  // Now, after extraction, textContent should match fieldValue split by \"\\n\".\n  if (annotation.data.textContent.join(\"\\n\") !== annotation.data.fieldValue) {\n    throw new Error(\"Extra line breaks were not correctly restored.\");\n  }\n});",
    "i2_llama-3.3-70b-versatile": "it(\"should restore extra line breaks when extracting text content from a text widget annotation\", async () => {\n  const { TextWidgetAnnotation } = await import(\"../../src/core/annotation.js\");\n  // Create a fake instance with only the needed properties.\n  const annotation = Object.create(TextWidgetAnnotation.prototype);\n  annotation.data = {\n    // The text extractor originally produced textContent without the extra blank line.\n    textContent: [\"Line1\", \"Line2\"],\n    // But the actual field value contains an extra blank line.\n    fieldValue: \"Line1\\n\\nLine2\",\n  };\n  // Call the new extractTextContent method.\n  await annotation.extractTextContent({}, {}, {});\n  // Now, after extraction, textContent should match fieldValue split by \"\\n\".\n  if (annotation.data.textContent.join(\"\\n\") !== annotation.data.fieldValue) {\n    throw new Error(\"Extra line breaks were not correctly restored.\");\n  }\n});",
    "i3_deepseek-r1-distill-llama-70b": "it(\"should restore extra line breaks when extracting text content from a text widget annotation\", async () => {\n  const { TextWidgetAnnotation } = await import(\"../../src/core/annotation.js\");\n  // Create a fake instance with only the needed properties.\n  const annotation = Object.create(TextWidgetAnnotation.prototype);\n  annotation.data = {\n    // The text extractor originally produced textContent without the extra blank line.\n    textContent: [\"Line1\", \"Line2\"],\n    // But the actual field value contains an extra blank line.\n    fieldValue: \"Line1\\n\\nLine2\",\n  };\n  // Call the new extractTextContent method.\n  await annotation.extractTextContent({}, {}, {});\n  // Now, after extraction, textContent should match fieldValue split by \"\\n\".\n  if (annotation.data.textContent.join(\"\\n\") !== annotation.data.fieldValue) {\n    throw new Error(\"Extra line breaks were not correctly restored.\");\n  }\n});",
    "i3_gpt-4o": "it(\"should restore extra line breaks when extracting text content from a text widget annotation\", async () => {\n  const { TextWidgetAnnotation } = await import(\"../../src/core/annotation.js\");\n  // Create a fake instance with only the needed properties.\n  const annotation = Object.create(TextWidgetAnnotation.prototype);\n  annotation.data = {\n    // The text extractor originally produced textContent without the extra blank line.\n    textContent: [\"Line1\", \"Line2\"],\n    // But the actual field value contains an extra blank line.\n    fieldValue: \"Line1\\n\\nLine2\",\n  };\n  // Call the new extractTextContent method.\n  await annotation.extractTextContent({}, {}, {});\n  // Now, after extraction, textContent should match fieldValue split by \"\\n\".\n  if (annotation.data.textContent.join(\"\\n\") !== annotation.data.fieldValue) {\n    throw new Error(\"Extra line breaks were not correctly restored.\");\n  }\n});",
    "i3_llama-3.3-70b-versatile": "it(\"should restore extra line breaks when extracting text content from a text widget annotation\", async () => {\n  const { TextWidgetAnnotation } = await import(\"../../src/core/annotation.js\");\n  // Create a fake instance with only the needed properties.\n  const annotation = Object.create(TextWidgetAnnotation.prototype);\n  annotation.data = {\n    // The text extractor originally produced textContent without the extra blank line.\n    textContent: [\"Line1\", \"Line2\"],\n    // But the actual field value contains an extra blank line.\n    fieldValue: \"Line1\\n\\nLine2\",\n  };\n  // Call the new extractTextContent method.\n  await annotation.extractTextContent({}, {}, {});\n  // Now, after extraction, textContent should match fieldValue split by \"\\n\".\n  if (annotation.data.textContent.join(\"\\n\") !== annotation.data.fieldValue) {\n    throw new Error(\"Extra line breaks were not correctly restored.\");\n  }\n});",
    "i4_deepseek-r1-distill-llama-70b": "it(\"should restore extra line breaks when extracting text content from a text widget annotation\", async () => {\n  const { TextWidgetAnnotation } = await import(\"../../src/core/annotation.js\");\n  // Create a fake instance with only the needed properties.\n  const annotation = Object.create(TextWidgetAnnotation.prototype);\n  annotation.data = {\n    // The text extractor originally produced textContent without the extra blank line.\n    textContent: [\"Line1\", \"Line2\"],\n    // But the actual field value contains an extra blank line.\n    fieldValue: \"Line1\\n\\nLine2\",\n  };\n  // Call the new extractTextContent method.\n  await annotation.extractTextContent({}, {}, {});\n  // Now, after extraction, textContent should match fieldValue split by \"\\n\".\n  if (annotation.data.textContent.join(\"\\n\") !== annotation.data.fieldValue) {\n    throw new Error(\"Extra line breaks were not correctly restored.\");\n  }\n});",
    "i4_gpt-4o": "it(\"should restore extra line breaks when extracting text content from a text widget annotation\", async () => {\n  const { TextWidgetAnnotation } = await import(\"../../src/core/annotation.js\");\n  // Create a fake instance with only the needed properties.\n  const annotation = Object.create(TextWidgetAnnotation.prototype);\n  annotation.data = {\n    // The text extractor originally produced textContent without the extra blank line.\n    textContent: [\"Line1\", \"Line2\"],\n    // But the actual field value contains an extra blank line.\n    fieldValue: \"Line1\\n\\nLine2\",\n  };\n  // Call the new extractTextContent method.\n  await annotation.extractTextContent({}, {}, {});\n  // Now, after extraction, textContent should match fieldValue split by \"\\n\".\n  if (annotation.data.textContent.join(\"\\n\") !== annotation.data.fieldValue) {\n    throw new Error(\"Extra line breaks were not correctly restored.\");\n  }\n});",
    "i4_llama-3.3-70b-versatile": "it(\"should restore extra line breaks when extracting text content from a text widget annotation\", async () => {\n  const { TextWidgetAnnotation } = await import(\"../../src/core/annotation.js\");\n  // Create a fake instance with only the needed properties.\n  const annotation = Object.create(TextWidgetAnnotation.prototype);\n  annotation.data = {\n    // The text extractor originally produced textContent without the extra blank line.\n    textContent: [\"Line1\", \"Line2\"],\n    // But the actual field value contains an extra blank line.\n    fieldValue: \"Line1\\n\\nLine2\",\n  };\n  // Call the new extractTextContent method.\n  await annotation.extractTextContent({}, {}, {});\n  // Now, after extraction, textContent should match fieldValue split by \"\\n\".\n  if (annotation.data.textContent.join(\"\\n\") !== annotation.data.fieldValue) {\n    throw new Error(\"Extra line breaks were not correctly restored.\");\n  }\n});",
    "i5_deepseek-r1-distill-llama-70b": "it(\"should restore extra line breaks when extracting text content from a text widget annotation\", async () => {\n  const { TextWidgetAnnotation } = await import(\"../../src/core/annotation.js\");\n  // Create a fake instance with only the needed properties.\n  const annotation = Object.create(TextWidgetAnnotation.prototype);\n  annotation.data = {\n    // The text extractor originally produced textContent without the extra blank line.\n    textContent: [\"Line1\", \"Line2\"],\n    // But the actual field value contains an extra blank line.\n    fieldValue: \"Line1\\n\\nLine2\",\n  };\n  // Call the new extractTextContent method.\n  await annotation.extractTextContent({}, {}, {});\n  // Now, after extraction, textContent should match fieldValue split by \"\\n\".\n  if (annotation.data.textContent.join(\"\\n\") !== annotation.data.fieldValue) {\n    throw new Error(\"Extra line breaks were not correctly restored.\");\n  }\n});",
    "i5_gpt-4o": "it(\"should restore extra line breaks when extracting text content from a text widget annotation\", async () => {\n  const { TextWidgetAnnotation } = await import(\"../../src/core/annotation.js\");\n  // Create a fake instance with only the needed properties.\n  const annotation = Object.create(TextWidgetAnnotation.prototype);\n  annotation.data = {\n    // The text extractor originally produced textContent without the extra blank line.\n    textContent: [\"Line1\", \"Line2\"],\n    // But the actual field value contains an extra blank line.\n    fieldValue: \"Line1\\n\\nLine2\",\n  };\n  // Call the new extractTextContent method.\n  await annotation.extractTextContent({}, {}, {});\n  // Now, after extraction, textContent should match fieldValue split by \"\\n\".\n  if (annotation.data.textContent.join(\"\\n\") !== annotation.data.fieldValue) {\n    throw new Error(\"Extra line breaks were not correctly restored.\");\n  }\n});",
    "i5_llama-3.3-70b-versatile": "it(\"should restore extra line breaks when extracting text content from a text widget annotation\", async () => {\n  const { TextWidgetAnnotation } = await import(\"../../src/core/annotation.js\");\n  // Create a fake instance with only the needed properties.\n  const annotation = Object.create(TextWidgetAnnotation.prototype);\n  annotation.data = {\n    // The text extractor originally produced textContent without the extra blank line.\n    textContent: [\"Line1\", \"Line2\"],\n    // But the actual field value contains an extra blank line.\n    fieldValue: \"Line1\\n\\nLine2\",\n  };\n  // Call the new extractTextContent method.\n  await annotation.extractTextContent({}, {}, {});\n  // Now, after extraction, textContent should match fieldValue split by \"\\n\".\n  if (annotation.data.textContent.join(\"\\n\") !== annotation.data.fieldValue) {\n    throw new Error(\"Extra line breaks were not correctly restored.\");\n  }\n});"
  },
  "18878": {
    "i1_deepseek-r1-distill-llama-70b": "it(\"should swallow extra data errors in asyncGetBytes\", async () => {\n  const { FlateStream } = await import(\"../../src/core/flate_stream.js\");\n  const { StringStream } = await import(\"../../src/core/stream.js\");\n  const bytes = new Uint8Array([0x78, 0x9C, 0x00, 0x00, 0x00]);\n  const dataStr = String.fromCharCode(...bytes);\n  const stream = new StringStream(dataStr);\n  stream.dict = {};\n  const flateStream = new FlateStream(stream);\n  const result = await flateStream.asyncGetBytes();\n  chai.expect(result).to.be.null;\n});",
    "i1_gpt-4o": "it(\"should swallow extra data errors in asyncGetBytes\", async () => {\n  const { FlateStream } = await import(\"../../src/core/flate_stream.js\");\n  const { StringStream } = await import(\"../../src/core/stream.js\");\n  const bytes = new Uint8Array([0x78, 0x9C, 0x00, 0x00, 0x00]);\n  const dataStr = String.fromCharCode(...bytes);\n  const stream = new StringStream(dataStr);\n  stream.dict = {};\n  const flateStream = new FlateStream(stream);\n  const result = await flateStream.asyncGetBytes();\n  chai.expect(result).to.be.null;\n});",
    "i1_llama-3.3-70b-versatile": "it(\"should swallow extra data errors in asyncGetBytes\", async () => {\n  const { FlateStream } = await import(\"../../src/core/flate_stream.js\");\n  const { StringStream } = await import(\"../../src/core/stream.js\");\n  const bytes = new Uint8Array([0x78, 0x9C, 0x00, 0x00, 0x00]);\n  const dataStr = String.fromCharCode(...bytes);\n  const stream = new StringStream(dataStr);\n  stream.dict = {};\n  const flateStream = new FlateStream(stream);\n  const result = await flateStream.asyncGetBytes();\n  chai.expect(result).to.be.null;\n});",
    "i1_MOCK": "it(\"should swallow extra data errors in asyncGetBytes\", async () => {\n  const { FlateStream } = await import(\"../../src/core/flate_stream.js\");\n  const { StringStream } = await import(\"../../src/core/stream.js\");\n  const bytes = new Uint8Array([0x78, 0x9C, 0x00, 0x00, 0x00]);\n  const dataStr = String.fromCharCode(...bytes);\n  const stream = new StringStream(dataStr);\n  stream.dict = {};\n  const flateStream = new FlateStream(stream);\n  const result = await flateStream.asyncGetBytes();\n  chai.expect(result).to.be.null;\n});",
    "i2_deepseek-r1-distill-llama-70b": "it(\"should swallow extra data errors in asyncGetBytes\", async () => {\n  const { FlateStream } = await import(\"../../src/core/flate_stream.js\");\n  const { StringStream } = await import(\"../../src/core/stream.js\");\n  const bytes = new Uint8Array([0x78, 0x9C, 0x00, 0x00, 0x00]);\n  const dataStr = String.fromCharCode(...bytes);\n  const stream = new StringStream(dataStr);\n  stream.dict = {};\n  const flateStream = new FlateStream(stream);\n  const result = await flateStream.asyncGetBytes();\n  chai.expect(result).to.be.null;\n});",
    "i2_gpt-4o": "it(\"should swallow extra data errors in asyncGetBytes\", async () => {\n  const { FlateStream } = await import(\"../../src/core/flate_stream.js\");\n  const { StringStream } = await import(\"../../src/core/stream.js\");\n  const bytes = new Uint8Array([0x78, 0x9C, 0x00, 0x00, 0x00]);\n  const dataStr = String.fromCharCode(...bytes);\n  const stream = new StringStream(dataStr);\n  stream.dict = {};\n  const flateStream = new FlateStream(stream);\n  const result = await flateStream.asyncGetBytes();\n  chai.expect(result).to.be.null;\n});",
    "i2_llama-3.3-70b-versatile": "it(\"should swallow extra data errors in asyncGetBytes\", async () => {\n  const { FlateStream } = await import(\"../../src/core/flate_stream.js\");\n  const { StringStream } = await import(\"../../src/core/stream.js\");\n  const bytes = new Uint8Array([0x78, 0x9C, 0x00, 0x00, 0x00]);\n  const dataStr = String.fromCharCode(...bytes);\n  const stream = new StringStream(dataStr);\n  stream.dict = {};\n  const flateStream = new FlateStream(stream);\n  const result = await flateStream.asyncGetBytes();\n  chai.expect(result).to.be.null;\n});",
    "i3_deepseek-r1-distill-llama-70b": "it(\"should swallow extra data errors in asyncGetBytes\", async () => {\n  const { FlateStream } = await import(\"../../src/core/flate_stream.js\");\n  const { StringStream } = await import(\"../../src/core/stream.js\");\n  const bytes = new Uint8Array([0x78, 0x9C, 0x00, 0x00, 0x00]);\n  const dataStr = String.fromCharCode(...bytes);\n  const stream = new StringStream(dataStr);\n  stream.dict = {};\n  const flateStream = new FlateStream(stream);\n  const result = await flateStream.asyncGetBytes();\n  chai.expect(result).to.be.null;\n});",
    "i3_gpt-4o": "it(\"should swallow extra data errors in asyncGetBytes\", async () => {\n  const { FlateStream } = await import(\"../../src/core/flate_stream.js\");\n  const { StringStream } = await import(\"../../src/core/stream.js\");\n  const bytes = new Uint8Array([0x78, 0x9C, 0x00, 0x00, 0x00]);\n  const dataStr = String.fromCharCode(...bytes);\n  const stream = new StringStream(dataStr);\n  stream.dict = {};\n  const flateStream = new FlateStream(stream);\n  const result = await flateStream.asyncGetBytes();\n  chai.expect(result).to.be.null;\n});",
    "i3_llama-3.3-70b-versatile": "it(\"should swallow extra data errors in asyncGetBytes\", async () => {\n  const { FlateStream } = await import(\"../../src/core/flate_stream.js\");\n  const { StringStream } = await import(\"../../src/core/stream.js\");\n  const bytes = new Uint8Array([0x78, 0x9C, 0x00, 0x00, 0x00]);\n  const dataStr = String.fromCharCode(...bytes);\n  const stream = new StringStream(dataStr);\n  stream.dict = {};\n  const flateStream = new FlateStream(stream);\n  const result = await flateStream.asyncGetBytes();\n  chai.expect(result).to.be.null;\n});",
    "i4_deepseek-r1-distill-llama-70b": "it(\"should swallow extra data errors in asyncGetBytes\", async () => {\n  const { FlateStream } = await import(\"../../src/core/flate_stream.js\");\n  const { StringStream } = await import(\"../../src/core/stream.js\");\n  const bytes = new Uint8Array([0x78, 0x9C, 0x00, 0x00, 0x00]);\n  const dataStr = String.fromCharCode(...bytes);\n  const stream = new StringStream(dataStr);\n  stream.dict = {};\n  const flateStream = new FlateStream(stream);\n  const result = await flateStream.asyncGetBytes();\n  chai.expect(result).to.be.null;\n});",
    "i4_gpt-4o": "it(\"should swallow extra data errors in asyncGetBytes\", async () => {\n  const { FlateStream } = await import(\"../../src/core/flate_stream.js\");\n  const { StringStream } = await import(\"../../src/core/stream.js\");\n  const bytes = new Uint8Array([0x78, 0x9C, 0x00, 0x00, 0x00]);\n  const dataStr = String.fromCharCode(...bytes);\n  const stream = new StringStream(dataStr);\n  stream.dict = {};\n  const flateStream = new FlateStream(stream);\n  const result = await flateStream.asyncGetBytes();\n  chai.expect(result).to.be.null;\n});",
    "i4_llama-3.3-70b-versatile": "it(\"should swallow extra data errors in asyncGetBytes\", async () => {\n  const { FlateStream } = await import(\"../../src/core/flate_stream.js\");\n  const { StringStream } = await import(\"../../src/core/stream.js\");\n  const bytes = new Uint8Array([0x78, 0x9C, 0x00, 0x00, 0x00]);\n  const dataStr = String.fromCharCode(...bytes);\n  const stream = new StringStream(dataStr);\n  stream.dict = {};\n  const flateStream = new FlateStream(stream);\n  const result = await flateStream.asyncGetBytes();\n  chai.expect(result).to.be.null;\n});",
    "i5_deepseek-r1-distill-llama-70b": "it(\"should swallow extra data errors in asyncGetBytes\", async () => {\n  const { FlateStream } = await import(\"../../src/core/flate_stream.js\");\n  const { StringStream } = await import(\"../../src/core/stream.js\");\n  const bytes = new Uint8Array([0x78, 0x9C, 0x00, 0x00, 0x00]);\n  const dataStr = String.fromCharCode(...bytes);\n  const stream = new StringStream(dataStr);\n  stream.dict = {};\n  const flateStream = new FlateStream(stream);\n  const result = await flateStream.asyncGetBytes();\n  chai.expect(result).to.be.null;\n});",
    "i5_gpt-4o": "it(\"should swallow extra data errors in asyncGetBytes\", async () => {\n  const { FlateStream } = await import(\"../../src/core/flate_stream.js\");\n  const { StringStream } = await import(\"../../src/core/stream.js\");\n  const bytes = new Uint8Array([0x78, 0x9C, 0x00, 0x00, 0x00]);\n  const dataStr = String.fromCharCode(...bytes);\n  const stream = new StringStream(dataStr);\n  stream.dict = {};\n  const flateStream = new FlateStream(stream);\n  const result = await flateStream.asyncGetBytes();\n  chai.expect(result).to.be.null;\n});",
    "i5_llama-3.3-70b-versatile": "it(\"should swallow extra data errors in asyncGetBytes\", async () => {\n  const { FlateStream } = await import(\"../../src/core/flate_stream.js\");\n  const { StringStream } = await import(\"../../src/core/stream.js\");\n  const bytes = new Uint8Array([0x78, 0x9C, 0x00, 0x00, 0x00]);\n  const dataStr = String.fromCharCode(...bytes);\n  const stream = new StringStream(dataStr);\n  stream.dict = {};\n  const flateStream = new FlateStream(stream);\n  const result = await flateStream.asyncGetBytes();\n  chai.expect(result).to.be.null;\n});"
  },
  "18895": {
    "i1_deepseek-r1-distill-llama-70b": "it(\"should convert setFillColorN numeric arguments to setFillRGBColor when no colorspace is provided\", async () => {\n  const { default: assert } = await import(\"assert\");\n  const dummyXRef = new XRefMock();\n  const operatorList = new OperatorList();\n  const fakeStream = {\n    _called: false,\n    read(operation) {\n      if (!this._called) {\n        this._called = true;\n        operation.args = [0.5];\n        operation.fn = OPS.setFillColorN;\n        return true;\n      }\n      return false;\n    },\n  };\n  const dummyTask = { ensureNotTerminated: () => {} };\n  const partialEvaluator = new PartialEvaluator({\n    xref: dummyXRef,\n    handler: {},\n    pageIndex: 0,\n    idFactory: createIdFactory(),\n    fontCache: new Map(),\n    builtInCMapCache: new Map(),\n    standardFontDataCache: new Map(),\n    globalImageCache: new Map(),\n    systemFontCache: new Map(),\n    options: {},\n  });\n  return partialEvaluator\n    .getOperatorList({\n      stream: fakeStream,\n      task: dummyTask,\n      resources: new Dict(),\n      operatorList,\n    })\n    .then(() => {\n      // Expect one op: the setFillColorN should have been converted to setFillRGBColor\n      assert.strictEqual(operatorList.fnArray.length, 1);\n      assert.strictEqual(operatorList.fnArray[0], OPS.setFillRGBColor);\n      // The gray color conversion yields [value, value, value]\n      assert.deepStrictEqual(operatorList.argsArray[0], [0.5, 0.5, 0.5]);\n    });\n});\n",
    "i1_gpt-4o": "it(\"should convert setFillColorN numeric arguments to setFillRGBColor when no colorspace is provided\", async () => {\n  const { default: assert } = await import(\"assert\");\n  const dummyXRef = new XRefMock();\n  const operatorList = new OperatorList();\n  const fakeStream = {\n    _called: false,\n    read(operation) {\n      if (!this._called) {\n        this._called = true;\n        operation.args = [0.5];\n        operation.fn = OPS.setFillColorN;\n        return true;\n      }\n      return false;\n    },\n  };\n  const dummyTask = { ensureNotTerminated: () => {} };\n  const partialEvaluator = new PartialEvaluator({\n    xref: dummyXRef,\n    handler: {},\n    pageIndex: 0,\n    idFactory: createIdFactory(),\n    fontCache: new Map(),\n    builtInCMapCache: new Map(),\n    standardFontDataCache: new Map(),\n    globalImageCache: new Map(),\n    systemFontCache: new Map(),\n    options: {},\n  });\n  return partialEvaluator\n    .getOperatorList({\n      stream: fakeStream,\n      task: dummyTask,\n      resources: new Dict(),\n      operatorList,\n    })\n    .then(() => {\n      // Expect one op: the setFillColorN should have been converted to setFillRGBColor\n      assert.strictEqual(operatorList.fnArray.length, 1);\n      assert.strictEqual(operatorList.fnArray[0], OPS.setFillRGBColor);\n      // The gray color conversion yields [value, value, value]\n      assert.deepStrictEqual(operatorList.argsArray[0], [0.5, 0.5, 0.5]);\n    });\n});\n",
    "i1_llama-3.3-70b-versatile": "it(\"should convert setFillColorN numeric arguments to setFillRGBColor when no colorspace is provided\", async () => {\n  const { default: assert } = await import(\"assert\");\n  const dummyXRef = new XRefMock();\n  const operatorList = new OperatorList();\n  const fakeStream = {\n    _called: false,\n    read(operation) {\n      if (!this._called) {\n        this._called = true;\n        operation.args = [0.5];\n        operation.fn = OPS.setFillColorN;\n        return true;\n      }\n      return false;\n    },\n  };\n  const dummyTask = { ensureNotTerminated: () => {} };\n  const partialEvaluator = new PartialEvaluator({\n    xref: dummyXRef,\n    handler: {},\n    pageIndex: 0,\n    idFactory: createIdFactory(),\n    fontCache: new Map(),\n    builtInCMapCache: new Map(),\n    standardFontDataCache: new Map(),\n    globalImageCache: new Map(),\n    systemFontCache: new Map(),\n    options: {},\n  });\n  return partialEvaluator\n    .getOperatorList({\n      stream: fakeStream,\n      task: dummyTask,\n      resources: new Dict(),\n      operatorList,\n    })\n    .then(() => {\n      // Expect one op: the setFillColorN should have been converted to setFillRGBColor\n      assert.strictEqual(operatorList.fnArray.length, 1);\n      assert.strictEqual(operatorList.fnArray[0], OPS.setFillRGBColor);\n      // The gray color conversion yields [value, value, value]\n      assert.deepStrictEqual(operatorList.argsArray[0], [0.5, 0.5, 0.5]);\n    });\n});\n",
    "i1_MOCK": "it(\"should convert setFillColorN numeric arguments to setFillRGBColor when no colorspace is provided\", async () => {\n  const { default: assert } = await import(\"assert\");\n  const dummyXRef = new XRefMock();\n  const operatorList = new OperatorList();\n  const fakeStream = {\n    _called: false,\n    read(operation) {\n      if (!this._called) {\n        this._called = true;\n        operation.args = [0.5];\n        operation.fn = OPS.setFillColorN;\n        return true;\n      }\n      return false;\n    },\n  };\n  const dummyTask = { ensureNotTerminated: () => {} };\n  const partialEvaluator = new PartialEvaluator({\n    xref: dummyXRef,\n    handler: {},\n    pageIndex: 0,\n    idFactory: createIdFactory(),\n    fontCache: new Map(),\n    builtInCMapCache: new Map(),\n    standardFontDataCache: new Map(),\n    globalImageCache: new Map(),\n    systemFontCache: new Map(),\n    options: {},\n  });\n  return partialEvaluator\n    .getOperatorList({\n      stream: fakeStream,\n      task: dummyTask,\n      resources: new Dict(),\n      operatorList,\n    })\n    .then(() => {\n      // Expect one op: the setFillColorN should have been converted to setFillRGBColor\n      assert.strictEqual(operatorList.fnArray.length, 1);\n      assert.strictEqual(operatorList.fnArray[0], OPS.setFillRGBColor);\n      // The gray color conversion yields [value, value, value]\n      assert.deepStrictEqual(operatorList.argsArray[0], [0.5, 0.5, 0.5]);\n    });\n});\n",
    "i2_deepseek-r1-distill-llama-70b": "it(\"should convert setFillColorN numeric arguments to setFillRGBColor when no colorspace is provided\", async () => {\n  const { default: assert } = await import(\"assert\");\n  const dummyXRef = new XRefMock();\n  const operatorList = new OperatorList();\n  const fakeStream = {\n    _called: false,\n    read(operation) {\n      if (!this._called) {\n        this._called = true;\n        operation.args = [0.5];\n        operation.fn = OPS.setFillColorN;\n        return true;\n      }\n      return false;\n    },\n  };\n  const dummyTask = { ensureNotTerminated: () => {} };\n  const partialEvaluator = new PartialEvaluator({\n    xref: dummyXRef,\n    handler: {},\n    pageIndex: 0,\n    idFactory: createIdFactory(),\n    fontCache: new Map(),\n    builtInCMapCache: new Map(),\n    standardFontDataCache: new Map(),\n    globalImageCache: new Map(),\n    systemFontCache: new Map(),\n    options: {},\n  });\n  return partialEvaluator\n    .getOperatorList({\n      stream: fakeStream,\n      task: dummyTask,\n      resources: new Dict(),\n      operatorList,\n    })\n    .then(() => {\n      // Expect one op: the setFillColorN should have been converted to setFillRGBColor\n      assert.strictEqual(operatorList.fnArray.length, 1);\n      assert.strictEqual(operatorList.fnArray[0], OPS.setFillRGBColor);\n      // The gray color conversion yields [value, value, value]\n      assert.deepStrictEqual(operatorList.argsArray[0], [0.5, 0.5, 0.5]);\n    });\n});\n",
    "i2_gpt-4o": "it(\"should convert setFillColorN numeric arguments to setFillRGBColor when no colorspace is provided\", async () => {\n  const { default: assert } = await import(\"assert\");\n  const dummyXRef = new XRefMock();\n  const operatorList = new OperatorList();\n  const fakeStream = {\n    _called: false,\n    read(operation) {\n      if (!this._called) {\n        this._called = true;\n        operation.args = [0.5];\n        operation.fn = OPS.setFillColorN;\n        return true;\n      }\n      return false;\n    },\n  };\n  const dummyTask = { ensureNotTerminated: () => {} };\n  const partialEvaluator = new PartialEvaluator({\n    xref: dummyXRef,\n    handler: {},\n    pageIndex: 0,\n    idFactory: createIdFactory(),\n    fontCache: new Map(),\n    builtInCMapCache: new Map(),\n    standardFontDataCache: new Map(),\n    globalImageCache: new Map(),\n    systemFontCache: new Map(),\n    options: {},\n  });\n  return partialEvaluator\n    .getOperatorList({\n      stream: fakeStream,\n      task: dummyTask,\n      resources: new Dict(),\n      operatorList,\n    })\n    .then(() => {\n      // Expect one op: the setFillColorN should have been converted to setFillRGBColor\n      assert.strictEqual(operatorList.fnArray.length, 1);\n      assert.strictEqual(operatorList.fnArray[0], OPS.setFillRGBColor);\n      // The gray color conversion yields [value, value, value]\n      assert.deepStrictEqual(operatorList.argsArray[0], [0.5, 0.5, 0.5]);\n    });\n});\n",
    "i2_llama-3.3-70b-versatile": "it(\"should convert setFillColorN numeric arguments to setFillRGBColor when no colorspace is provided\", async () => {\n  const { default: assert } = await import(\"assert\");\n  const dummyXRef = new XRefMock();\n  const operatorList = new OperatorList();\n  const fakeStream = {\n    _called: false,\n    read(operation) {\n      if (!this._called) {\n        this._called = true;\n        operation.args = [0.5];\n        operation.fn = OPS.setFillColorN;\n        return true;\n      }\n      return false;\n    },\n  };\n  const dummyTask = { ensureNotTerminated: () => {} };\n  const partialEvaluator = new PartialEvaluator({\n    xref: dummyXRef,\n    handler: {},\n    pageIndex: 0,\n    idFactory: createIdFactory(),\n    fontCache: new Map(),\n    builtInCMapCache: new Map(),\n    standardFontDataCache: new Map(),\n    globalImageCache: new Map(),\n    systemFontCache: new Map(),\n    options: {},\n  });\n  return partialEvaluator\n    .getOperatorList({\n      stream: fakeStream,\n      task: dummyTask,\n      resources: new Dict(),\n      operatorList,\n    })\n    .then(() => {\n      // Expect one op: the setFillColorN should have been converted to setFillRGBColor\n      assert.strictEqual(operatorList.fnArray.length, 1);\n      assert.strictEqual(operatorList.fnArray[0], OPS.setFillRGBColor);\n      // The gray color conversion yields [value, value, value]\n      assert.deepStrictEqual(operatorList.argsArray[0], [0.5, 0.5, 0.5]);\n    });\n});\n",
    "i3_deepseek-r1-distill-llama-70b": "it(\"should convert setFillColorN numeric arguments to setFillRGBColor when no colorspace is provided\", async () => {\n  const { default: assert } = await import(\"assert\");\n  const dummyXRef = new XRefMock();\n  const operatorList = new OperatorList();\n  const fakeStream = {\n    _called: false,\n    read(operation) {\n      if (!this._called) {\n        this._called = true;\n        operation.args = [0.5];\n        operation.fn = OPS.setFillColorN;\n        return true;\n      }\n      return false;\n    },\n  };\n  const dummyTask = { ensureNotTerminated: () => {} };\n  const partialEvaluator = new PartialEvaluator({\n    xref: dummyXRef,\n    handler: {},\n    pageIndex: 0,\n    idFactory: createIdFactory(),\n    fontCache: new Map(),\n    builtInCMapCache: new Map(),\n    standardFontDataCache: new Map(),\n    globalImageCache: new Map(),\n    systemFontCache: new Map(),\n    options: {},\n  });\n  return partialEvaluator\n    .getOperatorList({\n      stream: fakeStream,\n      task: dummyTask,\n      resources: new Dict(),\n      operatorList,\n    })\n    .then(() => {\n      // Expect one op: the setFillColorN should have been converted to setFillRGBColor\n      assert.strictEqual(operatorList.fnArray.length, 1);\n      assert.strictEqual(operatorList.fnArray[0], OPS.setFillRGBColor);\n      // The gray color conversion yields [value, value, value]\n      assert.deepStrictEqual(operatorList.argsArray[0], [0.5, 0.5, 0.5]);\n    });\n});\n",
    "i3_gpt-4o": "it(\"should convert setFillColorN numeric arguments to setFillRGBColor when no colorspace is provided\", async () => {\n  const { default: assert } = await import(\"assert\");\n  const dummyXRef = new XRefMock();\n  const operatorList = new OperatorList();\n  const fakeStream = {\n    _called: false,\n    read(operation) {\n      if (!this._called) {\n        this._called = true;\n        operation.args = [0.5];\n        operation.fn = OPS.setFillColorN;\n        return true;\n      }\n      return false;\n    },\n  };\n  const dummyTask = { ensureNotTerminated: () => {} };\n  const partialEvaluator = new PartialEvaluator({\n    xref: dummyXRef,\n    handler: {},\n    pageIndex: 0,\n    idFactory: createIdFactory(),\n    fontCache: new Map(),\n    builtInCMapCache: new Map(),\n    standardFontDataCache: new Map(),\n    globalImageCache: new Map(),\n    systemFontCache: new Map(),\n    options: {},\n  });\n  return partialEvaluator\n    .getOperatorList({\n      stream: fakeStream,\n      task: dummyTask,\n      resources: new Dict(),\n      operatorList,\n    })\n    .then(() => {\n      // Expect one op: the setFillColorN should have been converted to setFillRGBColor\n      assert.strictEqual(operatorList.fnArray.length, 1);\n      assert.strictEqual(operatorList.fnArray[0], OPS.setFillRGBColor);\n      // The gray color conversion yields [value, value, value]\n      assert.deepStrictEqual(operatorList.argsArray[0], [0.5, 0.5, 0.5]);\n    });\n});\n",
    "i3_llama-3.3-70b-versatile": "it(\"should convert setFillColorN numeric arguments to setFillRGBColor when no colorspace is provided\", async () => {\n  const { default: assert } = await import(\"assert\");\n  const dummyXRef = new XRefMock();\n  const operatorList = new OperatorList();\n  const fakeStream = {\n    _called: false,\n    read(operation) {\n      if (!this._called) {\n        this._called = true;\n        operation.args = [0.5];\n        operation.fn = OPS.setFillColorN;\n        return true;\n      }\n      return false;\n    },\n  };\n  const dummyTask = { ensureNotTerminated: () => {} };\n  const partialEvaluator = new PartialEvaluator({\n    xref: dummyXRef,\n    handler: {},\n    pageIndex: 0,\n    idFactory: createIdFactory(),\n    fontCache: new Map(),\n    builtInCMapCache: new Map(),\n    standardFontDataCache: new Map(),\n    globalImageCache: new Map(),\n    systemFontCache: new Map(),\n    options: {},\n  });\n  return partialEvaluator\n    .getOperatorList({\n      stream: fakeStream,\n      task: dummyTask,\n      resources: new Dict(),\n      operatorList,\n    })\n    .then(() => {\n      // Expect one op: the setFillColorN should have been converted to setFillRGBColor\n      assert.strictEqual(operatorList.fnArray.length, 1);\n      assert.strictEqual(operatorList.fnArray[0], OPS.setFillRGBColor);\n      // The gray color conversion yields [value, value, value]\n      assert.deepStrictEqual(operatorList.argsArray[0], [0.5, 0.5, 0.5]);\n    });\n});\n",
    "i4_deepseek-r1-distill-llama-70b": "it(\"should convert setFillColorN numeric arguments to setFillRGBColor when no colorspace is provided\", async () => {\n  const { default: assert } = await import(\"assert\");\n  const dummyXRef = new XRefMock();\n  const operatorList = new OperatorList();\n  const fakeStream = {\n    _called: false,\n    read(operation) {\n      if (!this._called) {\n        this._called = true;\n        operation.args = [0.5];\n        operation.fn = OPS.setFillColorN;\n        return true;\n      }\n      return false;\n    },\n  };\n  const dummyTask = { ensureNotTerminated: () => {} };\n  const partialEvaluator = new PartialEvaluator({\n    xref: dummyXRef,\n    handler: {},\n    pageIndex: 0,\n    idFactory: createIdFactory(),\n    fontCache: new Map(),\n    builtInCMapCache: new Map(),\n    standardFontDataCache: new Map(),\n    globalImageCache: new Map(),\n    systemFontCache: new Map(),\n    options: {},\n  });\n  return partialEvaluator\n    .getOperatorList({\n      stream: fakeStream,\n      task: dummyTask,\n      resources: new Dict(),\n      operatorList,\n    })\n    .then(() => {\n      // Expect one op: the setFillColorN should have been converted to setFillRGBColor\n      assert.strictEqual(operatorList.fnArray.length, 1);\n      assert.strictEqual(operatorList.fnArray[0], OPS.setFillRGBColor);\n      // The gray color conversion yields [value, value, value]\n      assert.deepStrictEqual(operatorList.argsArray[0], [0.5, 0.5, 0.5]);\n    });\n});\n",
    "i4_gpt-4o": "it(\"should convert setFillColorN numeric arguments to setFillRGBColor when no colorspace is provided\", async () => {\n  const { default: assert } = await import(\"assert\");\n  const dummyXRef = new XRefMock();\n  const operatorList = new OperatorList();\n  const fakeStream = {\n    _called: false,\n    read(operation) {\n      if (!this._called) {\n        this._called = true;\n        operation.args = [0.5];\n        operation.fn = OPS.setFillColorN;\n        return true;\n      }\n      return false;\n    },\n  };\n  const dummyTask = { ensureNotTerminated: () => {} };\n  const partialEvaluator = new PartialEvaluator({\n    xref: dummyXRef,\n    handler: {},\n    pageIndex: 0,\n    idFactory: createIdFactory(),\n    fontCache: new Map(),\n    builtInCMapCache: new Map(),\n    standardFontDataCache: new Map(),\n    globalImageCache: new Map(),\n    systemFontCache: new Map(),\n    options: {},\n  });\n  return partialEvaluator\n    .getOperatorList({\n      stream: fakeStream,\n      task: dummyTask,\n      resources: new Dict(),\n      operatorList,\n    })\n    .then(() => {\n      // Expect one op: the setFillColorN should have been converted to setFillRGBColor\n      assert.strictEqual(operatorList.fnArray.length, 1);\n      assert.strictEqual(operatorList.fnArray[0], OPS.setFillRGBColor);\n      // The gray color conversion yields [value, value, value]\n      assert.deepStrictEqual(operatorList.argsArray[0], [0.5, 0.5, 0.5]);\n    });\n});\n",
    "i4_llama-3.3-70b-versatile": "it(\"should convert setFillColorN numeric arguments to setFillRGBColor when no colorspace is provided\", async () => {\n  const { default: assert } = await import(\"assert\");\n  const dummyXRef = new XRefMock();\n  const operatorList = new OperatorList();\n  const fakeStream = {\n    _called: false,\n    read(operation) {\n      if (!this._called) {\n        this._called = true;\n        operation.args = [0.5];\n        operation.fn = OPS.setFillColorN;\n        return true;\n      }\n      return false;\n    },\n  };\n  const dummyTask = { ensureNotTerminated: () => {} };\n  const partialEvaluator = new PartialEvaluator({\n    xref: dummyXRef,\n    handler: {},\n    pageIndex: 0,\n    idFactory: createIdFactory(),\n    fontCache: new Map(),\n    builtInCMapCache: new Map(),\n    standardFontDataCache: new Map(),\n    globalImageCache: new Map(),\n    systemFontCache: new Map(),\n    options: {},\n  });\n  return partialEvaluator\n    .getOperatorList({\n      stream: fakeStream,\n      task: dummyTask,\n      resources: new Dict(),\n      operatorList,\n    })\n    .then(() => {\n      // Expect one op: the setFillColorN should have been converted to setFillRGBColor\n      assert.strictEqual(operatorList.fnArray.length, 1);\n      assert.strictEqual(operatorList.fnArray[0], OPS.setFillRGBColor);\n      // The gray color conversion yields [value, value, value]\n      assert.deepStrictEqual(operatorList.argsArray[0], [0.5, 0.5, 0.5]);\n    });\n});\n",
    "i5_deepseek-r1-distill-llama-70b": "it(\"should convert setFillColorN numeric arguments to setFillRGBColor when no colorspace is provided\", async () => {\n  const { default: assert } = await import(\"assert\");\n  const dummyXRef = new XRefMock();\n  const operatorList = new OperatorList();\n  const fakeStream = {\n    _called: false,\n    read(operation) {\n      if (!this._called) {\n        this._called = true;\n        operation.args = [0.5];\n        operation.fn = OPS.setFillColorN;\n        return true;\n      }\n      return false;\n    },\n  };\n  const dummyTask = { ensureNotTerminated: () => {} };\n  const partialEvaluator = new PartialEvaluator({\n    xref: dummyXRef,\n    handler: {},\n    pageIndex: 0,\n    idFactory: createIdFactory(),\n    fontCache: new Map(),\n    builtInCMapCache: new Map(),\n    standardFontDataCache: new Map(),\n    globalImageCache: new Map(),\n    systemFontCache: new Map(),\n    options: {},\n  });\n  return partialEvaluator\n    .getOperatorList({\n      stream: fakeStream,\n      task: dummyTask,\n      resources: new Dict(),\n      operatorList,\n    })\n    .then(() => {\n      // Expect one op: the setFillColorN should have been converted to setFillRGBColor\n      assert.strictEqual(operatorList.fnArray.length, 1);\n      assert.strictEqual(operatorList.fnArray[0], OPS.setFillRGBColor);\n      // The gray color conversion yields [value, value, value]\n      assert.deepStrictEqual(operatorList.argsArray[0], [0.5, 0.5, 0.5]);\n    });\n});\n",
    "i5_gpt-4o": "it(\"should convert setFillColorN numeric arguments to setFillRGBColor when no colorspace is provided\", async () => {\n  const { default: assert } = await import(\"assert\");\n  const dummyXRef = new XRefMock();\n  const operatorList = new OperatorList();\n  const fakeStream = {\n    _called: false,\n    read(operation) {\n      if (!this._called) {\n        this._called = true;\n        operation.args = [0.5];\n        operation.fn = OPS.setFillColorN;\n        return true;\n      }\n      return false;\n    },\n  };\n  const dummyTask = { ensureNotTerminated: () => {} };\n  const partialEvaluator = new PartialEvaluator({\n    xref: dummyXRef,\n    handler: {},\n    pageIndex: 0,\n    idFactory: createIdFactory(),\n    fontCache: new Map(),\n    builtInCMapCache: new Map(),\n    standardFontDataCache: new Map(),\n    globalImageCache: new Map(),\n    systemFontCache: new Map(),\n    options: {},\n  });\n  return partialEvaluator\n    .getOperatorList({\n      stream: fakeStream,\n      task: dummyTask,\n      resources: new Dict(),\n      operatorList,\n    })\n    .then(() => {\n      // Expect one op: the setFillColorN should have been converted to setFillRGBColor\n      assert.strictEqual(operatorList.fnArray.length, 1);\n      assert.strictEqual(operatorList.fnArray[0], OPS.setFillRGBColor);\n      // The gray color conversion yields [value, value, value]\n      assert.deepStrictEqual(operatorList.argsArray[0], [0.5, 0.5, 0.5]);\n    });\n});\n",
    "i5_llama-3.3-70b-versatile": "it(\"should convert setFillColorN numeric arguments to setFillRGBColor when no colorspace is provided\", async () => {\n  const { default: assert } = await import(\"assert\");\n  const dummyXRef = new XRefMock();\n  const operatorList = new OperatorList();\n  const fakeStream = {\n    _called: false,\n    read(operation) {\n      if (!this._called) {\n        this._called = true;\n        operation.args = [0.5];\n        operation.fn = OPS.setFillColorN;\n        return true;\n      }\n      return false;\n    },\n  };\n  const dummyTask = { ensureNotTerminated: () => {} };\n  const partialEvaluator = new PartialEvaluator({\n    xref: dummyXRef,\n    handler: {},\n    pageIndex: 0,\n    idFactory: createIdFactory(),\n    fontCache: new Map(),\n    builtInCMapCache: new Map(),\n    standardFontDataCache: new Map(),\n    globalImageCache: new Map(),\n    systemFontCache: new Map(),\n    options: {},\n  });\n  return partialEvaluator\n    .getOperatorList({\n      stream: fakeStream,\n      task: dummyTask,\n      resources: new Dict(),\n      operatorList,\n    })\n    .then(() => {\n      // Expect one op: the setFillColorN should have been converted to setFillRGBColor\n      assert.strictEqual(operatorList.fnArray.length, 1);\n      assert.strictEqual(operatorList.fnArray[0], OPS.setFillRGBColor);\n      // The gray color conversion yields [value, value, value]\n      assert.deepStrictEqual(operatorList.argsArray[0], [0.5, 0.5, 0.5]);\n    });\n});\n"
  },
  "18960": {
    "i1_deepseek-r1-distill-llama-70b": "it(\"should correctly apply the backdrop fill when mask extension occurs\", async () => {\n  const { Util } = await import(\"../../src/shared/util.js\");\n  const { CanvasGraphics } = await import(\"../../src/display/canvas.js\");\n  const { DefaultCanvasFactory } = await import(\"../../src/display/api.js\");\n  const factory = new DefaultCanvasFactory();\n  const maskObj = factory.create(70, 50);\n  const layerObj = factory.create(50, 50);\n  const maskCtx = maskObj.context;\n  const layerCtx = layerObj.context;\n  maskCtx.fillStyle = \"#ffffff\";\n  maskCtx.fillRect(0, 0, 70, 50);\n  const dummyFilterFactory = { addAlphaFilter: () => \"\" , addLuminosityFilter: () => \"\" };\n  const cg = new CanvasGraphics(layerCtx, {}, {}, factory, dummyFilterFactory, {}, null);\n  const backdrop = [0, 0, 0];\n  // Setting layerOffsetX=0 and maskOffsetX=10 forces maskX = -10 (mask extension branch)\n  cg.genericComposeSMask(maskCtx, layerCtx, 50, 50, \"Alpha\", backdrop, null, 0, 0, 10, 0);\n  const { data } = layerCtx.getImageData(25, 25, 1, 1);\n  if (!(data[0] === 0 && data[1] === 0 && data[2] === 0 && data[3] === 255)) {\n    throw new Error(\"Backdrop fill not correctly applied\");\n  }\n});",
    "i1_gpt-4o": "it(\"should correctly apply the backdrop fill when mask extension occurs\", async () => {\n  const { Util } = await import(\"../../src/shared/util.js\");\n  const { CanvasGraphics } = await import(\"../../src/display/canvas.js\");\n  const { DefaultCanvasFactory } = await import(\"../../src/display/api.js\");\n  const factory = new DefaultCanvasFactory();\n  const maskObj = factory.create(70, 50);\n  const layerObj = factory.create(50, 50);\n  const maskCtx = maskObj.context;\n  const layerCtx = layerObj.context;\n  maskCtx.fillStyle = \"#ffffff\";\n  maskCtx.fillRect(0, 0, 70, 50);\n  const dummyFilterFactory = { addAlphaFilter: () => \"\" , addLuminosityFilter: () => \"\" };\n  const cg = new CanvasGraphics(layerCtx, {}, {}, factory, dummyFilterFactory, {}, null);\n  const backdrop = [0, 0, 0];\n  // Setting layerOffsetX=0 and maskOffsetX=10 forces maskX = -10 (mask extension branch)\n  cg.genericComposeSMask(maskCtx, layerCtx, 50, 50, \"Alpha\", backdrop, null, 0, 0, 10, 0);\n  const { data } = layerCtx.getImageData(25, 25, 1, 1);\n  if (!(data[0] === 0 && data[1] === 0 && data[2] === 0 && data[3] === 255)) {\n    throw new Error(\"Backdrop fill not correctly applied\");\n  }\n});",
    "i1_llama-3.3-70b-versatile": "it(\"should correctly apply the backdrop fill when mask extension occurs\", async () => {\n  const { Util } = await import(\"../../src/shared/util.js\");\n  const { CanvasGraphics } = await import(\"../../src/display/canvas.js\");\n  const { DefaultCanvasFactory } = await import(\"../../src/display/api.js\");\n  const factory = new DefaultCanvasFactory();\n  const maskObj = factory.create(70, 50);\n  const layerObj = factory.create(50, 50);\n  const maskCtx = maskObj.context;\n  const layerCtx = layerObj.context;\n  maskCtx.fillStyle = \"#ffffff\";\n  maskCtx.fillRect(0, 0, 70, 50);\n  const dummyFilterFactory = { addAlphaFilter: () => \"\" , addLuminosityFilter: () => \"\" };\n  const cg = new CanvasGraphics(layerCtx, {}, {}, factory, dummyFilterFactory, {}, null);\n  const backdrop = [0, 0, 0];\n  // Setting layerOffsetX=0 and maskOffsetX=10 forces maskX = -10 (mask extension branch)\n  cg.genericComposeSMask(maskCtx, layerCtx, 50, 50, \"Alpha\", backdrop, null, 0, 0, 10, 0);\n  const { data } = layerCtx.getImageData(25, 25, 1, 1);\n  if (!(data[0] === 0 && data[1] === 0 && data[2] === 0 && data[3] === 255)) {\n    throw new Error(\"Backdrop fill not correctly applied\");\n  }\n});",
    "i1_MOCK": "it(\"should correctly apply the backdrop fill when mask extension occurs\", async () => {\n  const { Util } = await import(\"../../src/shared/util.js\");\n  const { CanvasGraphics } = await import(\"../../src/display/canvas.js\");\n  const { DefaultCanvasFactory } = await import(\"../../src/display/api.js\");\n  const factory = new DefaultCanvasFactory();\n  const maskObj = factory.create(70, 50);\n  const layerObj = factory.create(50, 50);\n  const maskCtx = maskObj.context;\n  const layerCtx = layerObj.context;\n  maskCtx.fillStyle = \"#ffffff\";\n  maskCtx.fillRect(0, 0, 70, 50);\n  const dummyFilterFactory = { addAlphaFilter: () => \"\" , addLuminosityFilter: () => \"\" };\n  const cg = new CanvasGraphics(layerCtx, {}, {}, factory, dummyFilterFactory, {}, null);\n  const backdrop = [0, 0, 0];\n  // Setting layerOffsetX=0 and maskOffsetX=10 forces maskX = -10 (mask extension branch)\n  cg.genericComposeSMask(maskCtx, layerCtx, 50, 50, \"Alpha\", backdrop, null, 0, 0, 10, 0);\n  const { data } = layerCtx.getImageData(25, 25, 1, 1);\n  if (!(data[0] === 0 && data[1] === 0 && data[2] === 0 && data[3] === 255)) {\n    throw new Error(\"Backdrop fill not correctly applied\");\n  }\n});",
    "i2_deepseek-r1-distill-llama-70b": "it(\"should correctly apply the backdrop fill when mask extension occurs\", async () => {\n  const { Util } = await import(\"../../src/shared/util.js\");\n  const { CanvasGraphics } = await import(\"../../src/display/canvas.js\");\n  const { DefaultCanvasFactory } = await import(\"../../src/display/api.js\");\n  const factory = new DefaultCanvasFactory();\n  const maskObj = factory.create(70, 50);\n  const layerObj = factory.create(50, 50);\n  const maskCtx = maskObj.context;\n  const layerCtx = layerObj.context;\n  maskCtx.fillStyle = \"#ffffff\";\n  maskCtx.fillRect(0, 0, 70, 50);\n  const dummyFilterFactory = { addAlphaFilter: () => \"\" , addLuminosityFilter: () => \"\" };\n  const cg = new CanvasGraphics(layerCtx, {}, {}, factory, dummyFilterFactory, {}, null);\n  const backdrop = [0, 0, 0];\n  // Setting layerOffsetX=0 and maskOffsetX=10 forces maskX = -10 (mask extension branch)\n  cg.genericComposeSMask(maskCtx, layerCtx, 50, 50, \"Alpha\", backdrop, null, 0, 0, 10, 0);\n  const { data } = layerCtx.getImageData(25, 25, 1, 1);\n  if (!(data[0] === 0 && data[1] === 0 && data[2] === 0 && data[3] === 255)) {\n    throw new Error(\"Backdrop fill not correctly applied\");\n  }\n});",
    "i2_gpt-4o": "it(\"should correctly apply the backdrop fill when mask extension occurs\", async () => {\n  const { Util } = await import(\"../../src/shared/util.js\");\n  const { CanvasGraphics } = await import(\"../../src/display/canvas.js\");\n  const { DefaultCanvasFactory } = await import(\"../../src/display/api.js\");\n  const factory = new DefaultCanvasFactory();\n  const maskObj = factory.create(70, 50);\n  const layerObj = factory.create(50, 50);\n  const maskCtx = maskObj.context;\n  const layerCtx = layerObj.context;\n  maskCtx.fillStyle = \"#ffffff\";\n  maskCtx.fillRect(0, 0, 70, 50);\n  const dummyFilterFactory = { addAlphaFilter: () => \"\" , addLuminosityFilter: () => \"\" };\n  const cg = new CanvasGraphics(layerCtx, {}, {}, factory, dummyFilterFactory, {}, null);\n  const backdrop = [0, 0, 0];\n  // Setting layerOffsetX=0 and maskOffsetX=10 forces maskX = -10 (mask extension branch)\n  cg.genericComposeSMask(maskCtx, layerCtx, 50, 50, \"Alpha\", backdrop, null, 0, 0, 10, 0);\n  const { data } = layerCtx.getImageData(25, 25, 1, 1);\n  if (!(data[0] === 0 && data[1] === 0 && data[2] === 0 && data[3] === 255)) {\n    throw new Error(\"Backdrop fill not correctly applied\");\n  }\n});",
    "i2_llama-3.3-70b-versatile": "it(\"should correctly apply the backdrop fill when mask extension occurs\", async () => {\n  const { Util } = await import(\"../../src/shared/util.js\");\n  const { CanvasGraphics } = await import(\"../../src/display/canvas.js\");\n  const { DefaultCanvasFactory } = await import(\"../../src/display/api.js\");\n  const factory = new DefaultCanvasFactory();\n  const maskObj = factory.create(70, 50);\n  const layerObj = factory.create(50, 50);\n  const maskCtx = maskObj.context;\n  const layerCtx = layerObj.context;\n  maskCtx.fillStyle = \"#ffffff\";\n  maskCtx.fillRect(0, 0, 70, 50);\n  const dummyFilterFactory = { addAlphaFilter: () => \"\" , addLuminosityFilter: () => \"\" };\n  const cg = new CanvasGraphics(layerCtx, {}, {}, factory, dummyFilterFactory, {}, null);\n  const backdrop = [0, 0, 0];\n  // Setting layerOffsetX=0 and maskOffsetX=10 forces maskX = -10 (mask extension branch)\n  cg.genericComposeSMask(maskCtx, layerCtx, 50, 50, \"Alpha\", backdrop, null, 0, 0, 10, 0);\n  const { data } = layerCtx.getImageData(25, 25, 1, 1);\n  if (!(data[0] === 0 && data[1] === 0 && data[2] === 0 && data[3] === 255)) {\n    throw new Error(\"Backdrop fill not correctly applied\");\n  }\n});",
    "i3_deepseek-r1-distill-llama-70b": "it(\"should correctly apply the backdrop fill when mask extension occurs\", async () => {\n  const { Util } = await import(\"../../src/shared/util.js\");\n  const { CanvasGraphics } = await import(\"../../src/display/canvas.js\");\n  const { DefaultCanvasFactory } = await import(\"../../src/display/api.js\");\n  const factory = new DefaultCanvasFactory();\n  const maskObj = factory.create(70, 50);\n  const layerObj = factory.create(50, 50);\n  const maskCtx = maskObj.context;\n  const layerCtx = layerObj.context;\n  maskCtx.fillStyle = \"#ffffff\";\n  maskCtx.fillRect(0, 0, 70, 50);\n  const dummyFilterFactory = { addAlphaFilter: () => \"\" , addLuminosityFilter: () => \"\" };\n  const cg = new CanvasGraphics(layerCtx, {}, {}, factory, dummyFilterFactory, {}, null);\n  const backdrop = [0, 0, 0];\n  // Setting layerOffsetX=0 and maskOffsetX=10 forces maskX = -10 (mask extension branch)\n  cg.genericComposeSMask(maskCtx, layerCtx, 50, 50, \"Alpha\", backdrop, null, 0, 0, 10, 0);\n  const { data } = layerCtx.getImageData(25, 25, 1, 1);\n  if (!(data[0] === 0 && data[1] === 0 && data[2] === 0 && data[3] === 255)) {\n    throw new Error(\"Backdrop fill not correctly applied\");\n  }\n});",
    "i3_gpt-4o": "it(\"should correctly apply the backdrop fill when mask extension occurs\", async () => {\n  const { Util } = await import(\"../../src/shared/util.js\");\n  const { CanvasGraphics } = await import(\"../../src/display/canvas.js\");\n  const { DefaultCanvasFactory } = await import(\"../../src/display/api.js\");\n  const factory = new DefaultCanvasFactory();\n  const maskObj = factory.create(70, 50);\n  const layerObj = factory.create(50, 50);\n  const maskCtx = maskObj.context;\n  const layerCtx = layerObj.context;\n  maskCtx.fillStyle = \"#ffffff\";\n  maskCtx.fillRect(0, 0, 70, 50);\n  const dummyFilterFactory = { addAlphaFilter: () => \"\" , addLuminosityFilter: () => \"\" };\n  const cg = new CanvasGraphics(layerCtx, {}, {}, factory, dummyFilterFactory, {}, null);\n  const backdrop = [0, 0, 0];\n  // Setting layerOffsetX=0 and maskOffsetX=10 forces maskX = -10 (mask extension branch)\n  cg.genericComposeSMask(maskCtx, layerCtx, 50, 50, \"Alpha\", backdrop, null, 0, 0, 10, 0);\n  const { data } = layerCtx.getImageData(25, 25, 1, 1);\n  if (!(data[0] === 0 && data[1] === 0 && data[2] === 0 && data[3] === 255)) {\n    throw new Error(\"Backdrop fill not correctly applied\");\n  }\n});",
    "i3_llama-3.3-70b-versatile": "it(\"should correctly apply the backdrop fill when mask extension occurs\", async () => {\n  const { Util } = await import(\"../../src/shared/util.js\");\n  const { CanvasGraphics } = await import(\"../../src/display/canvas.js\");\n  const { DefaultCanvasFactory } = await import(\"../../src/display/api.js\");\n  const factory = new DefaultCanvasFactory();\n  const maskObj = factory.create(70, 50);\n  const layerObj = factory.create(50, 50);\n  const maskCtx = maskObj.context;\n  const layerCtx = layerObj.context;\n  maskCtx.fillStyle = \"#ffffff\";\n  maskCtx.fillRect(0, 0, 70, 50);\n  const dummyFilterFactory = { addAlphaFilter: () => \"\" , addLuminosityFilter: () => \"\" };\n  const cg = new CanvasGraphics(layerCtx, {}, {}, factory, dummyFilterFactory, {}, null);\n  const backdrop = [0, 0, 0];\n  // Setting layerOffsetX=0 and maskOffsetX=10 forces maskX = -10 (mask extension branch)\n  cg.genericComposeSMask(maskCtx, layerCtx, 50, 50, \"Alpha\", backdrop, null, 0, 0, 10, 0);\n  const { data } = layerCtx.getImageData(25, 25, 1, 1);\n  if (!(data[0] === 0 && data[1] === 0 && data[2] === 0 && data[3] === 255)) {\n    throw new Error(\"Backdrop fill not correctly applied\");\n  }\n});",
    "i4_deepseek-r1-distill-llama-70b": "it(\"should correctly apply the backdrop fill when mask extension occurs\", async () => {\n  const { Util } = await import(\"../../src/shared/util.js\");\n  const { CanvasGraphics } = await import(\"../../src/display/canvas.js\");\n  const { DefaultCanvasFactory } = await import(\"../../src/display/api.js\");\n  const factory = new DefaultCanvasFactory();\n  const maskObj = factory.create(70, 50);\n  const layerObj = factory.create(50, 50);\n  const maskCtx = maskObj.context;\n  const layerCtx = layerObj.context;\n  maskCtx.fillStyle = \"#ffffff\";\n  maskCtx.fillRect(0, 0, 70, 50);\n  const dummyFilterFactory = { addAlphaFilter: () => \"\" , addLuminosityFilter: () => \"\" };\n  const cg = new CanvasGraphics(layerCtx, {}, {}, factory, dummyFilterFactory, {}, null);\n  const backdrop = [0, 0, 0];\n  // Setting layerOffsetX=0 and maskOffsetX=10 forces maskX = -10 (mask extension branch)\n  cg.genericComposeSMask(maskCtx, layerCtx, 50, 50, \"Alpha\", backdrop, null, 0, 0, 10, 0);\n  const { data } = layerCtx.getImageData(25, 25, 1, 1);\n  if (!(data[0] === 0 && data[1] === 0 && data[2] === 0 && data[3] === 255)) {\n    throw new Error(\"Backdrop fill not correctly applied\");\n  }\n});",
    "i4_gpt-4o": "it(\"should correctly apply the backdrop fill when mask extension occurs\", async () => {\n  const { Util } = await import(\"../../src/shared/util.js\");\n  const { CanvasGraphics } = await import(\"../../src/display/canvas.js\");\n  const { DefaultCanvasFactory } = await import(\"../../src/display/api.js\");\n  const factory = new DefaultCanvasFactory();\n  const maskObj = factory.create(70, 50);\n  const layerObj = factory.create(50, 50);\n  const maskCtx = maskObj.context;\n  const layerCtx = layerObj.context;\n  maskCtx.fillStyle = \"#ffffff\";\n  maskCtx.fillRect(0, 0, 70, 50);\n  const dummyFilterFactory = { addAlphaFilter: () => \"\" , addLuminosityFilter: () => \"\" };\n  const cg = new CanvasGraphics(layerCtx, {}, {}, factory, dummyFilterFactory, {}, null);\n  const backdrop = [0, 0, 0];\n  // Setting layerOffsetX=0 and maskOffsetX=10 forces maskX = -10 (mask extension branch)\n  cg.genericComposeSMask(maskCtx, layerCtx, 50, 50, \"Alpha\", backdrop, null, 0, 0, 10, 0);\n  const { data } = layerCtx.getImageData(25, 25, 1, 1);\n  if (!(data[0] === 0 && data[1] === 0 && data[2] === 0 && data[3] === 255)) {\n    throw new Error(\"Backdrop fill not correctly applied\");\n  }\n});",
    "i4_llama-3.3-70b-versatile": "it(\"should correctly apply the backdrop fill when mask extension occurs\", async () => {\n  const { Util } = await import(\"../../src/shared/util.js\");\n  const { CanvasGraphics } = await import(\"../../src/display/canvas.js\");\n  const { DefaultCanvasFactory } = await import(\"../../src/display/api.js\");\n  const factory = new DefaultCanvasFactory();\n  const maskObj = factory.create(70, 50);\n  const layerObj = factory.create(50, 50);\n  const maskCtx = maskObj.context;\n  const layerCtx = layerObj.context;\n  maskCtx.fillStyle = \"#ffffff\";\n  maskCtx.fillRect(0, 0, 70, 50);\n  const dummyFilterFactory = { addAlphaFilter: () => \"\" , addLuminosityFilter: () => \"\" };\n  const cg = new CanvasGraphics(layerCtx, {}, {}, factory, dummyFilterFactory, {}, null);\n  const backdrop = [0, 0, 0];\n  // Setting layerOffsetX=0 and maskOffsetX=10 forces maskX = -10 (mask extension branch)\n  cg.genericComposeSMask(maskCtx, layerCtx, 50, 50, \"Alpha\", backdrop, null, 0, 0, 10, 0);\n  const { data } = layerCtx.getImageData(25, 25, 1, 1);\n  if (!(data[0] === 0 && data[1] === 0 && data[2] === 0 && data[3] === 255)) {\n    throw new Error(\"Backdrop fill not correctly applied\");\n  }\n});",
    "i5_deepseek-r1-distill-llama-70b": "it(\"should correctly apply the backdrop fill when mask extension occurs\", async () => {\n  const { Util } = await import(\"../../src/shared/util.js\");\n  const { CanvasGraphics } = await import(\"../../src/display/canvas.js\");\n  const { DefaultCanvasFactory } = await import(\"../../src/display/api.js\");\n  const factory = new DefaultCanvasFactory();\n  const maskObj = factory.create(70, 50);\n  const layerObj = factory.create(50, 50);\n  const maskCtx = maskObj.context;\n  const layerCtx = layerObj.context;\n  maskCtx.fillStyle = \"#ffffff\";\n  maskCtx.fillRect(0, 0, 70, 50);\n  const dummyFilterFactory = { addAlphaFilter: () => \"\" , addLuminosityFilter: () => \"\" };\n  const cg = new CanvasGraphics(layerCtx, {}, {}, factory, dummyFilterFactory, {}, null);\n  const backdrop = [0, 0, 0];\n  // Setting layerOffsetX=0 and maskOffsetX=10 forces maskX = -10 (mask extension branch)\n  cg.genericComposeSMask(maskCtx, layerCtx, 50, 50, \"Alpha\", backdrop, null, 0, 0, 10, 0);\n  const { data } = layerCtx.getImageData(25, 25, 1, 1);\n  if (!(data[0] === 0 && data[1] === 0 && data[2] === 0 && data[3] === 255)) {\n    throw new Error(\"Backdrop fill not correctly applied\");\n  }\n});",
    "i5_gpt-4o": "it(\"should correctly apply the backdrop fill when mask extension occurs\", async () => {\n  const { Util } = await import(\"../../src/shared/util.js\");\n  const { CanvasGraphics } = await import(\"../../src/display/canvas.js\");\n  const { DefaultCanvasFactory } = await import(\"../../src/display/api.js\");\n  const factory = new DefaultCanvasFactory();\n  const maskObj = factory.create(70, 50);\n  const layerObj = factory.create(50, 50);\n  const maskCtx = maskObj.context;\n  const layerCtx = layerObj.context;\n  maskCtx.fillStyle = \"#ffffff\";\n  maskCtx.fillRect(0, 0, 70, 50);\n  const dummyFilterFactory = { addAlphaFilter: () => \"\" , addLuminosityFilter: () => \"\" };\n  const cg = new CanvasGraphics(layerCtx, {}, {}, factory, dummyFilterFactory, {}, null);\n  const backdrop = [0, 0, 0];\n  // Setting layerOffsetX=0 and maskOffsetX=10 forces maskX = -10 (mask extension branch)\n  cg.genericComposeSMask(maskCtx, layerCtx, 50, 50, \"Alpha\", backdrop, null, 0, 0, 10, 0);\n  const { data } = layerCtx.getImageData(25, 25, 1, 1);\n  if (!(data[0] === 0 && data[1] === 0 && data[2] === 0 && data[3] === 255)) {\n    throw new Error(\"Backdrop fill not correctly applied\");\n  }\n});",
    "i5_llama-3.3-70b-versatile": "it(\"should correctly apply the backdrop fill when mask extension occurs\", async () => {\n  const { Util } = await import(\"../../src/shared/util.js\");\n  const { CanvasGraphics } = await import(\"../../src/display/canvas.js\");\n  const { DefaultCanvasFactory } = await import(\"../../src/display/api.js\");\n  const factory = new DefaultCanvasFactory();\n  const maskObj = factory.create(70, 50);\n  const layerObj = factory.create(50, 50);\n  const maskCtx = maskObj.context;\n  const layerCtx = layerObj.context;\n  maskCtx.fillStyle = \"#ffffff\";\n  maskCtx.fillRect(0, 0, 70, 50);\n  const dummyFilterFactory = { addAlphaFilter: () => \"\" , addLuminosityFilter: () => \"\" };\n  const cg = new CanvasGraphics(layerCtx, {}, {}, factory, dummyFilterFactory, {}, null);\n  const backdrop = [0, 0, 0];\n  // Setting layerOffsetX=0 and maskOffsetX=10 forces maskX = -10 (mask extension branch)\n  cg.genericComposeSMask(maskCtx, layerCtx, 50, 50, \"Alpha\", backdrop, null, 0, 0, 10, 0);\n  const { data } = layerCtx.getImageData(25, 25, 1, 1);\n  if (!(data[0] === 0 && data[1] === 0 && data[2] === 0 && data[3] === 255)) {\n    throw new Error(\"Backdrop fill not correctly applied\");\n  }\n});"
  },
  "18974": {
    "i1_deepseek-r1-distill-llama-70b": "it(\"should correctly handle StreamsSequenceStream with mixed stream types\", async () => {\n  const streams = [\n    new DecodeStream(),\n    new DecodeStream(),\n    { length: 10 }\n  ];\n  const streamsSequenceStream = new StreamsSequenceStream(streams);\n  expect(streamsSequenceStream._rawMinBufferLength).toBe(0);\n});",
    "i1_gpt-4o": "it(\"should correctly render the signature page of a digitally signed PDF\", async () => {\n  const { getDocument } = await import('../../src/display/api.js');\n  const { buildGetDocumentParams } = await import('./test_utils.js');\n  const loadingTask = getDocument(buildGetDocumentParams('issue18973.pdf'));\n  const pdfDocument = await loadingTask.promise;\n  const page = await pdfDocument.getPage(45);\n  const viewport = page.getViewport({ scale: 1.0 });\n  const canvasFactory = new (await import('../../src/display/display_utils.js')).DOMCanvasFactory();\n  const canvasAndContext = canvasFactory.create(viewport.width, viewport.height);\n  const renderTask = page.render({\n    canvasContext: canvasAndContext.context,\n    viewport: viewport,\n  });\n  await renderTask.promise;\n  const imageData = canvasAndContext.context.getImageData(0, 0, viewport.width, viewport.height);\n  const hasContent = imageData.data.some(channel => channel !== 0);\n  expect(hasContent).toBe(true);\n});",
    "i1_llama-3.3-70b-versatile": "it(\"should filter out nonBaseStream instances in StreamsSequenceStream\", async () => {\n  const { getDocument } = await import('../../src/display/api.js');\n  const { buildGetDocumentParams } = await import('./test_utils.js');\n  const loadingTask = await getDocument(buildGetDocumentParams('issue18973.pdf'));\n  const pdfDocument = await loadingTask.promise;\n  const page = await pdfDocument.getPage(45);\n  const operatorList = await page.getOperatorList();\n  const streams = operatorList.args.map(arg => arg instanceof BaseStream ? arg : null);\n  const streamsSequenceStream = new (await import('../../src/core/decode_stream.js')).StreamsSequenceStream(streams);\n  const filteredStreams = streamsSequenceStream.streams;\n  const expectedLength = streams.filter(stream => stream instanceof BaseStream).length;\n  expect(filteredStreams.length).toBe(expectedLength);\n});",
    "i2_deepseek-r1-distill-llama-70b": "it(\"should correctly render the signature page of a digitally signed PDF\", async () => {\n  const { getDocument } = await import('../../src/display/api.js');\n  const { buildGetDocumentParams } = await import('./test_utils.js');\n\n  const loadingTask = getDocument(buildGetDocumentParams('issue18973.pdf'));\n  const doc = await loadingTask;\n  const page = await doc.getPage(45);\n\n  const container = {\n    height: 1024,\n    width: 1024,\n    scroll: () => {}, \n  };\n\n  await page.render({\n    container,\n    spreadMode: 'none',\n    viewport: page.getViewport({ scale: 1 }),\n  });\n\n  const text = await page.getTextContent();\n  expect(text.items.some(item => /Signature/.test(item.str))).toBe(true);\n});",
    "i2_gpt-4o": "it(\"should render the signature page of a digitally signed PDF\", async () => {\n  const { getDocument } = await import('../../src/display/api.js');\n  const { buildGetDocumentParams } = await import('./test_utils.js');\n  const loadingTask = getDocument(buildGetDocumentParams('issue18973.pdf'));\n  const pdfDocument = await loadingTask.promise;\n  const page = await pdfDocument.getPage(45);\n  const viewport = page.getViewport({ scale: 1.0 });\n  const canvasFactory = new (await import('../../src/display/display_utils.js')).DOMCanvasFactory();\n  const canvasAndContext = canvasFactory.create(viewport.width, viewport.height);\n  const renderTask = page.render({\n    canvasContext: canvasAndContext.context,\n    viewport,\n  });\n  await renderTask.promise;\n  const pixelData = canvasAndContext.context.getImageData(0, 0, viewport.width, viewport.height).data;\n  const isPageRendered = pixelData.some(value => value !== 0);\n  expect(isPageRendered).toBe(true);\n});",
    "i2_llama-3.3-70b-versatile": "it(\"should render the signature page of a digitally signed PDF\", async () => {\n  const { getDocument } = await import('../../src/display/api.js');\n  const { buildGetDocumentParams } = await import('./test_utils.js');\n  const loadingTask = getDocument(buildGetDocumentParams('issue18973.pdf'));\n  const pdfDocument = await loadingTask.promise;\n  const pdfPage = await pdfDocument.getPage(45);\n  const renderTask = pdfPage.render({\n    viewport: pdfPage.getViewport({ scale: 1 }),\n    canvasContext: null,\n    renderInteractive: false,\n    disableWebGL: true,\n  });\n  const renderResult = await renderTask.promise;\n  const expectedError = false;\n  const actualError = renderResult.error !== undefined;\n  expect(actualError).toBe(expectedError);\n});",
    "i3_deepseek-r1-distill-llama-70b": "it(\"should handle nonBaseStream instances in StreamsSequenceStream\", async () => {\n  const { Dict } = await import(\"../../src/core/primitives.js\");\n  const { PredictorStream } = await import(\"../../src/core/predictor_stream.js\");\n  const { Stream } = await import(\"../../src/core/stream.js\");\n  const { getDocument } = await import(\"../../src/display/api.js\");\n  const { buildGetDocumentParams } = await import(\"./test_utils.js\");\n\n  // Create a test stream that is not a BaseStream\n  class TestStream extends Stream {\n    constructor() {\n      super();\n      this.dict = new Dict();\n    }\n  }\n\n  // Create a StreamsSequenceStream with a mix of valid and invalid streams\n  const streams = [new TestStream(), new PredictorStream(new Stream(new Uint8Array(0)))];\n  const sss = new StreamsSequenceStream(streams);\n\n  // Without the patch, this would throw an error\n  // With the patch, it should handle the invalid stream gracefully\n  await expect(sss.readBlock()).resolves.not.toThrow();\n});",
    "i3_gpt-4o": "it(\"should correctly render the signature page of a digitally signed PDF\", async () => {\n  const { getDocument } = await import('../../src/display/api.js');\n  const { buildGetDocumentParams } = await import('./test_utils.js');\n  const loadingTask = getDocument(buildGetDocumentParams('issue18973.pdf'));\n  const pdfDocument = await loadingTask.promise;\n  const page = await pdfDocument.getPage(45);\n  const viewport = page.getViewport({ scale: 1.0 });\n  const canvasFactory = new (await import('../../src/display/display_utils.js')).DOMCanvasFactory();\n  const canvasAndContext = canvasFactory.create(viewport.width, viewport.height);\n  const renderTask = page.render({\n    canvasContext: canvasAndContext.context,\n    viewport: viewport,\n  });\n  await renderTask.promise;\n  const imageData = canvasAndContext.context.getImageData(0, 0, viewport.width, viewport.height);\n  const isPageRendered = imageData.data.some(channel => channel !== 0);\n  expect(isPageRendered).toBe(true);\n});",
    "i3_llama-3.3-70b-versatile": "it(\"should render the signature page of a digitally signed PDF correctly\", async () => {\n  const { getDocument } = await import('../../src/display/api.js');\n  const { buildGetDocumentParams } = await import('./test_utils.js');\n  const loadingTask = getDocument(buildGetDocumentParams('issue18973.pdf'));\n  const pdfDocument = await loadingTask.promise;\n  const pdfPage = await pdfDocument.getPage(45);\n  const renderTask = pdfPage.render({\n    viewport: pdfPage.getViewport({ scale: 1 }),\n    canvasContext: null,\n    renderInteractive: false,\n  });\n  await renderTask.promise;\n  const textContent = await pdfPage.getTextContent();\n  const expectedText = \"Signature\";\n  const actualText = textContent.items[0].str;\n  expect(actualText).toContain(expectedText);\n});",
    "i4_deepseek-r1-distill-llama-70b": "it(\"should render page with digital signature without errors\", async () => {\n  const { getDocument } = await import('../../src/display/api.js');\n  const { buildGetDocumentParams } = await import('./test_utils.js');\n  const loadingTask = getDocument(buildGetDocumentParams('issue18973.pdf'));\n\n  const { numPages } = await loadingTask;\n  const page = await loadingTask.getPage(45);\n\n  const renderTask = page.render({\n    viewport: page.getViewport({ scale: 1 }),\n    spreadMode: 'none',\n    flags: 'anno'\n  });\n\n  await expect(renderTask).resolves.not.toThrow();\n});",
    "i4_gpt-4o": "it(\"should correctly render the signature page of a digitally signed PDF\", async () => {\n  const { getDocument } = await import('../../src/display/api.js');\n  const { buildGetDocumentParams } = await import('./test_utils.js');\n  const loadingTask = getDocument(buildGetDocumentParams('issue18973.pdf'));\n  const pdfDocument = await loadingTask.promise;\n  const page = await pdfDocument.getPage(45);\n  const viewport = page.getViewport({ scale: 1.0 });\n  const canvasFactory = new (await import('../../src/display/display_utils.js')).DOMCanvasFactory();\n  const canvasAndContext = canvasFactory.create(viewport.width, viewport.height);\n  const renderTask = page.render({\n    canvasContext: canvasAndContext.context,\n    viewport: viewport,\n  });\n  await renderTask.promise;\n  const imageData = canvasAndContext.context.getImageData(0, 0, viewport.width, viewport.height);\n  const hasSignature = imageData.data.some((value, index) => {\n    return index % 4 === 3 && value > 0; // Check for non-transparent pixels\n  });\n  expect(hasSignature).toBe(true);\n});",
    "i4_llama-3.3-70b-versatile": "it(\"should correctly decode the signature page of a digitally signed PDF\", async () => {\n  const { getDocument } = await import('../../src/display/api.js');\n  const { buildGetDocumentParams } = await import('./test_utils.js');\n  const loadingTask = getDocument(buildGetDocumentParams('issue18973.pdf'));\n  const pdf = await loadingTask.promise;\n  const page = await pdf.getPage(45);\n  const textContent = await page.getTextContent();\n  const expectedText = \"Signature\";\n  const actualText = textContent.items[0].str;\n  expect(actualText).toContain(expectedText);\n});",
    "i5_deepseek-r1-distill-llama-70b": "it(\"should render page of issuepdf without errors\", async () => {\n  const { getDocument } = await import('../../src/display/api.js');\n  const { buildGetDocumentParams } = await import('./test_utils.js');\n\n  const loadingTask = getDocument(buildGetDocumentParams('issue18973.pdf'));\n\n  try {\n    const pdfDocument = await loadingTask;\n    const page = await pdfDocument.getPage(45);\n    const viewport = page.getViewport({ scale: 1 });\n\n    // Render the page to check for any errors\n    const renderResult = await page.render({\n      viewport,\n      canvasContext: null, // Using null to avoid actual rendering\n      continueRendering: () => true,\n    });\n\n    expect(renderResult).not.toThrow();\n  } catch (error) {\n    fail('Error rendering page 45: ' + error.message);\n  }\n});",
    "i5_gpt-4o": "it(\"should correctly render the signature page of a digitally signed PDF\", async () => {\n  const { getDocument } = await import('../../src/display/api.js');\n  const { buildGetDocumentParams } = await import('./test_utils.js');\n  const loadingTask = getDocument(buildGetDocumentParams('issue18973.pdf'));\n  const pdfDocument = await loadingTask.promise;\n  const page = await pdfDocument.getPage(45);\n  const viewport = page.getViewport({ scale: 1.0 });\n  const canvasFactory = new (await import('../../src/display/display_utils.js')).DOMCanvasFactory();\n  const canvasAndContext = canvasFactory.create(viewport.width, viewport.height);\n  const renderContext = {\n    canvasContext: canvasAndContext.context,\n    viewport: viewport,\n  };\n  const renderTask = page.render(renderContext);\n  await renderTask.promise;\n  const imageData = canvasAndContext.context.getImageData(0, 0, viewport.width, viewport.height);\n  const hasSignature = imageData.data.some((value, index) => {\n    return index % 4 === 3 && value > 0; // Check for non-transparent pixels\n  });\n  expect(hasSignature).toBe(true);\n});",
    "i5_llama-3.3-70b-versatile": "it(\"should render the signature page of a digitally signed PDF correctly\", async () => {\n  const { getDocument } = await import('../../src/display/api.js');\n  const { buildGetDocumentParams } = await import('./test_utils.js');\n  const loadingTask = getDocument(buildGetDocumentParams('issue18973.pdf'));\n  const pdfDocument = await loadingTask.promise;\n  const pdfPage = await pdfDocument.getPage(45);\n  const renderTask = pdfPage.render({\n    viewport: pdfPage.getViewport({ scale: 1 }),\n    canvasContext: null,\n    renderInteractive: false,\n    disableFontFace: true,\n  });\n  const renderedPage = await renderTask.promise;\n  const expectedText = \"Signature\";\n  const actualText = await pdfPage.getTextContent();\n  const actualTextItems = actualText.items;\n  const textFound = actualTextItems.some((item) => item.str.includes(expectedText));\n  expect(textFound).toBe(true);\n});"
  },
  "19023": {
    "i1_deepseek-r1-distill-llama-70b": "it(\"should apply gradient when stroking text\", async () => {\n  const { DefaultCanvasFactory } = await import(\"../../src/display/api.js\");\n  const { CanvasGraphics, TextRenderingMode } = await import(\"../../src/display/canvas.js\");\n  const { getTopLeftPixel } = await import(\"./test_utils.js\");\n  const canvasFactory = new DefaultCanvasFactory();\n  const { canvas, context } = canvasFactory.create(100, 100);\n  // Fill background white.\n  context.fillStyle = \"white\";\n  context.fillRect(0, 0, 100, 100);\n  // Create a fake strokeColor that returns a linear gradient.\n  const fakeStrokeColor = {\n    getPattern: (ctx) => {\n      const grad = ctx.createLinearGradient(10, 10, 90, 10);\n      grad.addColorStop(0, \"blue\");\n      grad.addColorStop(1, \"red\");\n      return grad;\n    }\n  };\n  // Create a fake font object that draws a simple rectangle path.\n  const fakeFont = {\n    missingFile: false,\n    disableFontFace: false,\n    getPathGenerator: () => {\n      return (ctx, size) => {\n        // Draw a rectangle representing the glyph outline.\n        ctx.rect(10, 10, 80, 80);\n      };\n    }\n  };\n  // Create a CanvasGraphics instance.\n  const cg = new CanvasGraphics(context, {}, {});\n  // Configure the graphics state to use stroke mode with a gradient.\n  cg.current.font = fakeFont;\n  cg.current.fontSize = 50;\n  cg.current.fontSizeScale = 1;\n  cg.current.textRenderingMode = TextRenderingMode.STROKE;\n  cg.current.lineWidth = 10;\n  cg.current.patternStroke = true;\n  cg.current.strokeColor = fakeStrokeColor;\n  // Render a fake glyph.\n  cg.showText([{ fontChar: \"A\", width: 500 }]);\n  // Extract a pixel from the stroked area.\n  const pixelData = context.getImageData(15, 15, 1, 1).data;\n  // Pre-patch, the stroke would be rendered as black; post-patch, the gradient is applied.\n  if (pixelData[0] === 0 && pixelData[1] === 0 && pixelData[2] === 0) {\n    throw new Error(\"Gradient stroke not applied\");\n  }\n});",
    "i1_gpt-4o": "it(\"should apply gradient when stroking text\", async () => {\n  const { DefaultCanvasFactory } = await import(\"../../src/display/api.js\");\n  const { CanvasGraphics, TextRenderingMode } = await import(\"../../src/display/canvas.js\");\n  const { getTopLeftPixel } = await import(\"./test_utils.js\");\n  const canvasFactory = new DefaultCanvasFactory();\n  const { canvas, context } = canvasFactory.create(100, 100);\n  // Fill background white.\n  context.fillStyle = \"white\";\n  context.fillRect(0, 0, 100, 100);\n  // Create a fake strokeColor that returns a linear gradient.\n  const fakeStrokeColor = {\n    getPattern: (ctx) => {\n      const grad = ctx.createLinearGradient(10, 10, 90, 10);\n      grad.addColorStop(0, \"blue\");\n      grad.addColorStop(1, \"red\");\n      return grad;\n    }\n  };\n  // Create a fake font object that draws a simple rectangle path.\n  const fakeFont = {\n    missingFile: false,\n    disableFontFace: false,\n    getPathGenerator: () => {\n      return (ctx, size) => {\n        // Draw a rectangle representing the glyph outline.\n        ctx.rect(10, 10, 80, 80);\n      };\n    }\n  };\n  // Create a CanvasGraphics instance.\n  const cg = new CanvasGraphics(context, {}, {});\n  // Configure the graphics state to use stroke mode with a gradient.\n  cg.current.font = fakeFont;\n  cg.current.fontSize = 50;\n  cg.current.fontSizeScale = 1;\n  cg.current.textRenderingMode = TextRenderingMode.STROKE;\n  cg.current.lineWidth = 10;\n  cg.current.patternStroke = true;\n  cg.current.strokeColor = fakeStrokeColor;\n  // Render a fake glyph.\n  cg.showText([{ fontChar: \"A\", width: 500 }]);\n  // Extract a pixel from the stroked area.\n  const pixelData = context.getImageData(15, 15, 1, 1).data;\n  // Pre-patch, the stroke would be rendered as black; post-patch, the gradient is applied.\n  if (pixelData[0] === 0 && pixelData[1] === 0 && pixelData[2] === 0) {\n    throw new Error(\"Gradient stroke not applied\");\n  }\n});",
    "i1_llama-3.3-70b-versatile": "it(\"should apply gradient when stroking text\", async () => {\n  const { DefaultCanvasFactory } = await import(\"../../src/display/api.js\");\n  const { CanvasGraphics, TextRenderingMode } = await import(\"../../src/display/canvas.js\");\n  const { getTopLeftPixel } = await import(\"./test_utils.js\");\n  const canvasFactory = new DefaultCanvasFactory();\n  const { canvas, context } = canvasFactory.create(100, 100);\n  // Fill background white.\n  context.fillStyle = \"white\";\n  context.fillRect(0, 0, 100, 100);\n  // Create a fake strokeColor that returns a linear gradient.\n  const fakeStrokeColor = {\n    getPattern: (ctx) => {\n      const grad = ctx.createLinearGradient(10, 10, 90, 10);\n      grad.addColorStop(0, \"blue\");\n      grad.addColorStop(1, \"red\");\n      return grad;\n    }\n  };\n  // Create a fake font object that draws a simple rectangle path.\n  const fakeFont = {\n    missingFile: false,\n    disableFontFace: false,\n    getPathGenerator: () => {\n      return (ctx, size) => {\n        // Draw a rectangle representing the glyph outline.\n        ctx.rect(10, 10, 80, 80);\n      };\n    }\n  };\n  // Create a CanvasGraphics instance.\n  const cg = new CanvasGraphics(context, {}, {});\n  // Configure the graphics state to use stroke mode with a gradient.\n  cg.current.font = fakeFont;\n  cg.current.fontSize = 50;\n  cg.current.fontSizeScale = 1;\n  cg.current.textRenderingMode = TextRenderingMode.STROKE;\n  cg.current.lineWidth = 10;\n  cg.current.patternStroke = true;\n  cg.current.strokeColor = fakeStrokeColor;\n  // Render a fake glyph.\n  cg.showText([{ fontChar: \"A\", width: 500 }]);\n  // Extract a pixel from the stroked area.\n  const pixelData = context.getImageData(15, 15, 1, 1).data;\n  // Pre-patch, the stroke would be rendered as black; post-patch, the gradient is applied.\n  if (pixelData[0] === 0 && pixelData[1] === 0 && pixelData[2] === 0) {\n    throw new Error(\"Gradient stroke not applied\");\n  }\n});",
    "i1_MOCK": "it(\"should apply gradient when stroking text\", async () => {\n  const { DefaultCanvasFactory } = await import(\"../../src/display/api.js\");\n  const { CanvasGraphics, TextRenderingMode } = await import(\"../../src/display/canvas.js\");\n  const { getTopLeftPixel } = await import(\"./test_utils.js\");\n  const canvasFactory = new DefaultCanvasFactory();\n  const { canvas, context } = canvasFactory.create(100, 100);\n  // Fill background white.\n  context.fillStyle = \"white\";\n  context.fillRect(0, 0, 100, 100);\n  // Create a fake strokeColor that returns a linear gradient.\n  const fakeStrokeColor = {\n    getPattern: (ctx) => {\n      const grad = ctx.createLinearGradient(10, 10, 90, 10);\n      grad.addColorStop(0, \"blue\");\n      grad.addColorStop(1, \"red\");\n      return grad;\n    }\n  };\n  // Create a fake font object that draws a simple rectangle path.\n  const fakeFont = {\n    missingFile: false,\n    disableFontFace: false,\n    getPathGenerator: () => {\n      return (ctx, size) => {\n        // Draw a rectangle representing the glyph outline.\n        ctx.rect(10, 10, 80, 80);\n      };\n    }\n  };\n  // Create a CanvasGraphics instance.\n  const cg = new CanvasGraphics(context, {}, {});\n  // Configure the graphics state to use stroke mode with a gradient.\n  cg.current.font = fakeFont;\n  cg.current.fontSize = 50;\n  cg.current.fontSizeScale = 1;\n  cg.current.textRenderingMode = TextRenderingMode.STROKE;\n  cg.current.lineWidth = 10;\n  cg.current.patternStroke = true;\n  cg.current.strokeColor = fakeStrokeColor;\n  // Render a fake glyph.\n  cg.showText([{ fontChar: \"A\", width: 500 }]);\n  // Extract a pixel from the stroked area.\n  const pixelData = context.getImageData(15, 15, 1, 1).data;\n  // Pre-patch, the stroke would be rendered as black; post-patch, the gradient is applied.\n  if (pixelData[0] === 0 && pixelData[1] === 0 && pixelData[2] === 0) {\n    throw new Error(\"Gradient stroke not applied\");\n  }\n});",
    "i2_deepseek-r1-distill-llama-70b": "it(\"should apply gradient when stroking text\", async () => {\n  const { DefaultCanvasFactory } = await import(\"../../src/display/api.js\");\n  const { CanvasGraphics, TextRenderingMode } = await import(\"../../src/display/canvas.js\");\n  const { getTopLeftPixel } = await import(\"./test_utils.js\");\n  const canvasFactory = new DefaultCanvasFactory();\n  const { canvas, context } = canvasFactory.create(100, 100);\n  // Fill background white.\n  context.fillStyle = \"white\";\n  context.fillRect(0, 0, 100, 100);\n  // Create a fake strokeColor that returns a linear gradient.\n  const fakeStrokeColor = {\n    getPattern: (ctx) => {\n      const grad = ctx.createLinearGradient(10, 10, 90, 10);\n      grad.addColorStop(0, \"blue\");\n      grad.addColorStop(1, \"red\");\n      return grad;\n    }\n  };\n  // Create a fake font object that draws a simple rectangle path.\n  const fakeFont = {\n    missingFile: false,\n    disableFontFace: false,\n    getPathGenerator: () => {\n      return (ctx, size) => {\n        // Draw a rectangle representing the glyph outline.\n        ctx.rect(10, 10, 80, 80);\n      };\n    }\n  };\n  // Create a CanvasGraphics instance.\n  const cg = new CanvasGraphics(context, {}, {});\n  // Configure the graphics state to use stroke mode with a gradient.\n  cg.current.font = fakeFont;\n  cg.current.fontSize = 50;\n  cg.current.fontSizeScale = 1;\n  cg.current.textRenderingMode = TextRenderingMode.STROKE;\n  cg.current.lineWidth = 10;\n  cg.current.patternStroke = true;\n  cg.current.strokeColor = fakeStrokeColor;\n  // Render a fake glyph.\n  cg.showText([{ fontChar: \"A\", width: 500 }]);\n  // Extract a pixel from the stroked area.\n  const pixelData = context.getImageData(15, 15, 1, 1).data;\n  // Pre-patch, the stroke would be rendered as black; post-patch, the gradient is applied.\n  if (pixelData[0] === 0 && pixelData[1] === 0 && pixelData[2] === 0) {\n    throw new Error(\"Gradient stroke not applied\");\n  }\n});",
    "i2_gpt-4o": "it(\"should apply gradient when stroking text\", async () => {\n  const { DefaultCanvasFactory } = await import(\"../../src/display/api.js\");\n  const { CanvasGraphics, TextRenderingMode } = await import(\"../../src/display/canvas.js\");\n  const { getTopLeftPixel } = await import(\"./test_utils.js\");\n  const canvasFactory = new DefaultCanvasFactory();\n  const { canvas, context } = canvasFactory.create(100, 100);\n  // Fill background white.\n  context.fillStyle = \"white\";\n  context.fillRect(0, 0, 100, 100);\n  // Create a fake strokeColor that returns a linear gradient.\n  const fakeStrokeColor = {\n    getPattern: (ctx) => {\n      const grad = ctx.createLinearGradient(10, 10, 90, 10);\n      grad.addColorStop(0, \"blue\");\n      grad.addColorStop(1, \"red\");\n      return grad;\n    }\n  };\n  // Create a fake font object that draws a simple rectangle path.\n  const fakeFont = {\n    missingFile: false,\n    disableFontFace: false,\n    getPathGenerator: () => {\n      return (ctx, size) => {\n        // Draw a rectangle representing the glyph outline.\n        ctx.rect(10, 10, 80, 80);\n      };\n    }\n  };\n  // Create a CanvasGraphics instance.\n  const cg = new CanvasGraphics(context, {}, {});\n  // Configure the graphics state to use stroke mode with a gradient.\n  cg.current.font = fakeFont;\n  cg.current.fontSize = 50;\n  cg.current.fontSizeScale = 1;\n  cg.current.textRenderingMode = TextRenderingMode.STROKE;\n  cg.current.lineWidth = 10;\n  cg.current.patternStroke = true;\n  cg.current.strokeColor = fakeStrokeColor;\n  // Render a fake glyph.\n  cg.showText([{ fontChar: \"A\", width: 500 }]);\n  // Extract a pixel from the stroked area.\n  const pixelData = context.getImageData(15, 15, 1, 1).data;\n  // Pre-patch, the stroke would be rendered as black; post-patch, the gradient is applied.\n  if (pixelData[0] === 0 && pixelData[1] === 0 && pixelData[2] === 0) {\n    throw new Error(\"Gradient stroke not applied\");\n  }\n});",
    "i2_llama-3.3-70b-versatile": "it(\"should apply gradient when stroking text\", async () => {\n  const { DefaultCanvasFactory } = await import(\"../../src/display/api.js\");\n  const { CanvasGraphics, TextRenderingMode } = await import(\"../../src/display/canvas.js\");\n  const { getTopLeftPixel } = await import(\"./test_utils.js\");\n  const canvasFactory = new DefaultCanvasFactory();\n  const { canvas, context } = canvasFactory.create(100, 100);\n  // Fill background white.\n  context.fillStyle = \"white\";\n  context.fillRect(0, 0, 100, 100);\n  // Create a fake strokeColor that returns a linear gradient.\n  const fakeStrokeColor = {\n    getPattern: (ctx) => {\n      const grad = ctx.createLinearGradient(10, 10, 90, 10);\n      grad.addColorStop(0, \"blue\");\n      grad.addColorStop(1, \"red\");\n      return grad;\n    }\n  };\n  // Create a fake font object that draws a simple rectangle path.\n  const fakeFont = {\n    missingFile: false,\n    disableFontFace: false,\n    getPathGenerator: () => {\n      return (ctx, size) => {\n        // Draw a rectangle representing the glyph outline.\n        ctx.rect(10, 10, 80, 80);\n      };\n    }\n  };\n  // Create a CanvasGraphics instance.\n  const cg = new CanvasGraphics(context, {}, {});\n  // Configure the graphics state to use stroke mode with a gradient.\n  cg.current.font = fakeFont;\n  cg.current.fontSize = 50;\n  cg.current.fontSizeScale = 1;\n  cg.current.textRenderingMode = TextRenderingMode.STROKE;\n  cg.current.lineWidth = 10;\n  cg.current.patternStroke = true;\n  cg.current.strokeColor = fakeStrokeColor;\n  // Render a fake glyph.\n  cg.showText([{ fontChar: \"A\", width: 500 }]);\n  // Extract a pixel from the stroked area.\n  const pixelData = context.getImageData(15, 15, 1, 1).data;\n  // Pre-patch, the stroke would be rendered as black; post-patch, the gradient is applied.\n  if (pixelData[0] === 0 && pixelData[1] === 0 && pixelData[2] === 0) {\n    throw new Error(\"Gradient stroke not applied\");\n  }\n});",
    "i3_deepseek-r1-distill-llama-70b": "it(\"should apply gradient when stroking text\", async () => {\n  const { DefaultCanvasFactory } = await import(\"../../src/display/api.js\");\n  const { CanvasGraphics, TextRenderingMode } = await import(\"../../src/display/canvas.js\");\n  const { getTopLeftPixel } = await import(\"./test_utils.js\");\n  const canvasFactory = new DefaultCanvasFactory();\n  const { canvas, context } = canvasFactory.create(100, 100);\n  // Fill background white.\n  context.fillStyle = \"white\";\n  context.fillRect(0, 0, 100, 100);\n  // Create a fake strokeColor that returns a linear gradient.\n  const fakeStrokeColor = {\n    getPattern: (ctx) => {\n      const grad = ctx.createLinearGradient(10, 10, 90, 10);\n      grad.addColorStop(0, \"blue\");\n      grad.addColorStop(1, \"red\");\n      return grad;\n    }\n  };\n  // Create a fake font object that draws a simple rectangle path.\n  const fakeFont = {\n    missingFile: false,\n    disableFontFace: false,\n    getPathGenerator: () => {\n      return (ctx, size) => {\n        // Draw a rectangle representing the glyph outline.\n        ctx.rect(10, 10, 80, 80);\n      };\n    }\n  };\n  // Create a CanvasGraphics instance.\n  const cg = new CanvasGraphics(context, {}, {});\n  // Configure the graphics state to use stroke mode with a gradient.\n  cg.current.font = fakeFont;\n  cg.current.fontSize = 50;\n  cg.current.fontSizeScale = 1;\n  cg.current.textRenderingMode = TextRenderingMode.STROKE;\n  cg.current.lineWidth = 10;\n  cg.current.patternStroke = true;\n  cg.current.strokeColor = fakeStrokeColor;\n  // Render a fake glyph.\n  cg.showText([{ fontChar: \"A\", width: 500 }]);\n  // Extract a pixel from the stroked area.\n  const pixelData = context.getImageData(15, 15, 1, 1).data;\n  // Pre-patch, the stroke would be rendered as black; post-patch, the gradient is applied.\n  if (pixelData[0] === 0 && pixelData[1] === 0 && pixelData[2] === 0) {\n    throw new Error(\"Gradient stroke not applied\");\n  }\n});",
    "i3_gpt-4o": "it(\"should apply gradient when stroking text\", async () => {\n  const { DefaultCanvasFactory } = await import(\"../../src/display/api.js\");\n  const { CanvasGraphics, TextRenderingMode } = await import(\"../../src/display/canvas.js\");\n  const { getTopLeftPixel } = await import(\"./test_utils.js\");\n  const canvasFactory = new DefaultCanvasFactory();\n  const { canvas, context } = canvasFactory.create(100, 100);\n  // Fill background white.\n  context.fillStyle = \"white\";\n  context.fillRect(0, 0, 100, 100);\n  // Create a fake strokeColor that returns a linear gradient.\n  const fakeStrokeColor = {\n    getPattern: (ctx) => {\n      const grad = ctx.createLinearGradient(10, 10, 90, 10);\n      grad.addColorStop(0, \"blue\");\n      grad.addColorStop(1, \"red\");\n      return grad;\n    }\n  };\n  // Create a fake font object that draws a simple rectangle path.\n  const fakeFont = {\n    missingFile: false,\n    disableFontFace: false,\n    getPathGenerator: () => {\n      return (ctx, size) => {\n        // Draw a rectangle representing the glyph outline.\n        ctx.rect(10, 10, 80, 80);\n      };\n    }\n  };\n  // Create a CanvasGraphics instance.\n  const cg = new CanvasGraphics(context, {}, {});\n  // Configure the graphics state to use stroke mode with a gradient.\n  cg.current.font = fakeFont;\n  cg.current.fontSize = 50;\n  cg.current.fontSizeScale = 1;\n  cg.current.textRenderingMode = TextRenderingMode.STROKE;\n  cg.current.lineWidth = 10;\n  cg.current.patternStroke = true;\n  cg.current.strokeColor = fakeStrokeColor;\n  // Render a fake glyph.\n  cg.showText([{ fontChar: \"A\", width: 500 }]);\n  // Extract a pixel from the stroked area.\n  const pixelData = context.getImageData(15, 15, 1, 1).data;\n  // Pre-patch, the stroke would be rendered as black; post-patch, the gradient is applied.\n  if (pixelData[0] === 0 && pixelData[1] === 0 && pixelData[2] === 0) {\n    throw new Error(\"Gradient stroke not applied\");\n  }\n});",
    "i3_llama-3.3-70b-versatile": "it(\"should apply gradient when stroking text\", async () => {\n  const { DefaultCanvasFactory } = await import(\"../../src/display/api.js\");\n  const { CanvasGraphics, TextRenderingMode } = await import(\"../../src/display/canvas.js\");\n  const { getTopLeftPixel } = await import(\"./test_utils.js\");\n  const canvasFactory = new DefaultCanvasFactory();\n  const { canvas, context } = canvasFactory.create(100, 100);\n  // Fill background white.\n  context.fillStyle = \"white\";\n  context.fillRect(0, 0, 100, 100);\n  // Create a fake strokeColor that returns a linear gradient.\n  const fakeStrokeColor = {\n    getPattern: (ctx) => {\n      const grad = ctx.createLinearGradient(10, 10, 90, 10);\n      grad.addColorStop(0, \"blue\");\n      grad.addColorStop(1, \"red\");\n      return grad;\n    }\n  };\n  // Create a fake font object that draws a simple rectangle path.\n  const fakeFont = {\n    missingFile: false,\n    disableFontFace: false,\n    getPathGenerator: () => {\n      return (ctx, size) => {\n        // Draw a rectangle representing the glyph outline.\n        ctx.rect(10, 10, 80, 80);\n      };\n    }\n  };\n  // Create a CanvasGraphics instance.\n  const cg = new CanvasGraphics(context, {}, {});\n  // Configure the graphics state to use stroke mode with a gradient.\n  cg.current.font = fakeFont;\n  cg.current.fontSize = 50;\n  cg.current.fontSizeScale = 1;\n  cg.current.textRenderingMode = TextRenderingMode.STROKE;\n  cg.current.lineWidth = 10;\n  cg.current.patternStroke = true;\n  cg.current.strokeColor = fakeStrokeColor;\n  // Render a fake glyph.\n  cg.showText([{ fontChar: \"A\", width: 500 }]);\n  // Extract a pixel from the stroked area.\n  const pixelData = context.getImageData(15, 15, 1, 1).data;\n  // Pre-patch, the stroke would be rendered as black; post-patch, the gradient is applied.\n  if (pixelData[0] === 0 && pixelData[1] === 0 && pixelData[2] === 0) {\n    throw new Error(\"Gradient stroke not applied\");\n  }\n});",
    "i4_deepseek-r1-distill-llama-70b": "it(\"should apply gradient when stroking text\", async () => {\n  const { DefaultCanvasFactory } = await import(\"../../src/display/api.js\");\n  const { CanvasGraphics, TextRenderingMode } = await import(\"../../src/display/canvas.js\");\n  const { getTopLeftPixel } = await import(\"./test_utils.js\");\n  const canvasFactory = new DefaultCanvasFactory();\n  const { canvas, context } = canvasFactory.create(100, 100);\n  // Fill background white.\n  context.fillStyle = \"white\";\n  context.fillRect(0, 0, 100, 100);\n  // Create a fake strokeColor that returns a linear gradient.\n  const fakeStrokeColor = {\n    getPattern: (ctx) => {\n      const grad = ctx.createLinearGradient(10, 10, 90, 10);\n      grad.addColorStop(0, \"blue\");\n      grad.addColorStop(1, \"red\");\n      return grad;\n    }\n  };\n  // Create a fake font object that draws a simple rectangle path.\n  const fakeFont = {\n    missingFile: false,\n    disableFontFace: false,\n    getPathGenerator: () => {\n      return (ctx, size) => {\n        // Draw a rectangle representing the glyph outline.\n        ctx.rect(10, 10, 80, 80);\n      };\n    }\n  };\n  // Create a CanvasGraphics instance.\n  const cg = new CanvasGraphics(context, {}, {});\n  // Configure the graphics state to use stroke mode with a gradient.\n  cg.current.font = fakeFont;\n  cg.current.fontSize = 50;\n  cg.current.fontSizeScale = 1;\n  cg.current.textRenderingMode = TextRenderingMode.STROKE;\n  cg.current.lineWidth = 10;\n  cg.current.patternStroke = true;\n  cg.current.strokeColor = fakeStrokeColor;\n  // Render a fake glyph.\n  cg.showText([{ fontChar: \"A\", width: 500 }]);\n  // Extract a pixel from the stroked area.\n  const pixelData = context.getImageData(15, 15, 1, 1).data;\n  // Pre-patch, the stroke would be rendered as black; post-patch, the gradient is applied.\n  if (pixelData[0] === 0 && pixelData[1] === 0 && pixelData[2] === 0) {\n    throw new Error(\"Gradient stroke not applied\");\n  }\n});",
    "i4_gpt-4o": "it(\"should apply gradient when stroking text\", async () => {\n  const { DefaultCanvasFactory } = await import(\"../../src/display/api.js\");\n  const { CanvasGraphics, TextRenderingMode } = await import(\"../../src/display/canvas.js\");\n  const { getTopLeftPixel } = await import(\"./test_utils.js\");\n  const canvasFactory = new DefaultCanvasFactory();\n  const { canvas, context } = canvasFactory.create(100, 100);\n  // Fill background white.\n  context.fillStyle = \"white\";\n  context.fillRect(0, 0, 100, 100);\n  // Create a fake strokeColor that returns a linear gradient.\n  const fakeStrokeColor = {\n    getPattern: (ctx) => {\n      const grad = ctx.createLinearGradient(10, 10, 90, 10);\n      grad.addColorStop(0, \"blue\");\n      grad.addColorStop(1, \"red\");\n      return grad;\n    }\n  };\n  // Create a fake font object that draws a simple rectangle path.\n  const fakeFont = {\n    missingFile: false,\n    disableFontFace: false,\n    getPathGenerator: () => {\n      return (ctx, size) => {\n        // Draw a rectangle representing the glyph outline.\n        ctx.rect(10, 10, 80, 80);\n      };\n    }\n  };\n  // Create a CanvasGraphics instance.\n  const cg = new CanvasGraphics(context, {}, {});\n  // Configure the graphics state to use stroke mode with a gradient.\n  cg.current.font = fakeFont;\n  cg.current.fontSize = 50;\n  cg.current.fontSizeScale = 1;\n  cg.current.textRenderingMode = TextRenderingMode.STROKE;\n  cg.current.lineWidth = 10;\n  cg.current.patternStroke = true;\n  cg.current.strokeColor = fakeStrokeColor;\n  // Render a fake glyph.\n  cg.showText([{ fontChar: \"A\", width: 500 }]);\n  // Extract a pixel from the stroked area.\n  const pixelData = context.getImageData(15, 15, 1, 1).data;\n  // Pre-patch, the stroke would be rendered as black; post-patch, the gradient is applied.\n  if (pixelData[0] === 0 && pixelData[1] === 0 && pixelData[2] === 0) {\n    throw new Error(\"Gradient stroke not applied\");\n  }\n});",
    "i4_llama-3.3-70b-versatile": "it(\"should apply gradient when stroking text\", async () => {\n  const { DefaultCanvasFactory } = await import(\"../../src/display/api.js\");\n  const { CanvasGraphics, TextRenderingMode } = await import(\"../../src/display/canvas.js\");\n  const { getTopLeftPixel } = await import(\"./test_utils.js\");\n  const canvasFactory = new DefaultCanvasFactory();\n  const { canvas, context } = canvasFactory.create(100, 100);\n  // Fill background white.\n  context.fillStyle = \"white\";\n  context.fillRect(0, 0, 100, 100);\n  // Create a fake strokeColor that returns a linear gradient.\n  const fakeStrokeColor = {\n    getPattern: (ctx) => {\n      const grad = ctx.createLinearGradient(10, 10, 90, 10);\n      grad.addColorStop(0, \"blue\");\n      grad.addColorStop(1, \"red\");\n      return grad;\n    }\n  };\n  // Create a fake font object that draws a simple rectangle path.\n  const fakeFont = {\n    missingFile: false,\n    disableFontFace: false,\n    getPathGenerator: () => {\n      return (ctx, size) => {\n        // Draw a rectangle representing the glyph outline.\n        ctx.rect(10, 10, 80, 80);\n      };\n    }\n  };\n  // Create a CanvasGraphics instance.\n  const cg = new CanvasGraphics(context, {}, {});\n  // Configure the graphics state to use stroke mode with a gradient.\n  cg.current.font = fakeFont;\n  cg.current.fontSize = 50;\n  cg.current.fontSizeScale = 1;\n  cg.current.textRenderingMode = TextRenderingMode.STROKE;\n  cg.current.lineWidth = 10;\n  cg.current.patternStroke = true;\n  cg.current.strokeColor = fakeStrokeColor;\n  // Render a fake glyph.\n  cg.showText([{ fontChar: \"A\", width: 500 }]);\n  // Extract a pixel from the stroked area.\n  const pixelData = context.getImageData(15, 15, 1, 1).data;\n  // Pre-patch, the stroke would be rendered as black; post-patch, the gradient is applied.\n  if (pixelData[0] === 0 && pixelData[1] === 0 && pixelData[2] === 0) {\n    throw new Error(\"Gradient stroke not applied\");\n  }\n});",
    "i5_deepseek-r1-distill-llama-70b": "it(\"should apply gradient when stroking text\", async () => {\n  const { DefaultCanvasFactory } = await import(\"../../src/display/api.js\");\n  const { CanvasGraphics, TextRenderingMode } = await import(\"../../src/display/canvas.js\");\n  const { getTopLeftPixel } = await import(\"./test_utils.js\");\n  const canvasFactory = new DefaultCanvasFactory();\n  const { canvas, context } = canvasFactory.create(100, 100);\n  // Fill background white.\n  context.fillStyle = \"white\";\n  context.fillRect(0, 0, 100, 100);\n  // Create a fake strokeColor that returns a linear gradient.\n  const fakeStrokeColor = {\n    getPattern: (ctx) => {\n      const grad = ctx.createLinearGradient(10, 10, 90, 10);\n      grad.addColorStop(0, \"blue\");\n      grad.addColorStop(1, \"red\");\n      return grad;\n    }\n  };\n  // Create a fake font object that draws a simple rectangle path.\n  const fakeFont = {\n    missingFile: false,\n    disableFontFace: false,\n    getPathGenerator: () => {\n      return (ctx, size) => {\n        // Draw a rectangle representing the glyph outline.\n        ctx.rect(10, 10, 80, 80);\n      };\n    }\n  };\n  // Create a CanvasGraphics instance.\n  const cg = new CanvasGraphics(context, {}, {});\n  // Configure the graphics state to use stroke mode with a gradient.\n  cg.current.font = fakeFont;\n  cg.current.fontSize = 50;\n  cg.current.fontSizeScale = 1;\n  cg.current.textRenderingMode = TextRenderingMode.STROKE;\n  cg.current.lineWidth = 10;\n  cg.current.patternStroke = true;\n  cg.current.strokeColor = fakeStrokeColor;\n  // Render a fake glyph.\n  cg.showText([{ fontChar: \"A\", width: 500 }]);\n  // Extract a pixel from the stroked area.\n  const pixelData = context.getImageData(15, 15, 1, 1).data;\n  // Pre-patch, the stroke would be rendered as black; post-patch, the gradient is applied.\n  if (pixelData[0] === 0 && pixelData[1] === 0 && pixelData[2] === 0) {\n    throw new Error(\"Gradient stroke not applied\");\n  }\n});",
    "i5_gpt-4o": "it(\"should apply gradient when stroking text\", async () => {\n  const { DefaultCanvasFactory } = await import(\"../../src/display/api.js\");\n  const { CanvasGraphics, TextRenderingMode } = await import(\"../../src/display/canvas.js\");\n  const { getTopLeftPixel } = await import(\"./test_utils.js\");\n  const canvasFactory = new DefaultCanvasFactory();\n  const { canvas, context } = canvasFactory.create(100, 100);\n  // Fill background white.\n  context.fillStyle = \"white\";\n  context.fillRect(0, 0, 100, 100);\n  // Create a fake strokeColor that returns a linear gradient.\n  const fakeStrokeColor = {\n    getPattern: (ctx) => {\n      const grad = ctx.createLinearGradient(10, 10, 90, 10);\n      grad.addColorStop(0, \"blue\");\n      grad.addColorStop(1, \"red\");\n      return grad;\n    }\n  };\n  // Create a fake font object that draws a simple rectangle path.\n  const fakeFont = {\n    missingFile: false,\n    disableFontFace: false,\n    getPathGenerator: () => {\n      return (ctx, size) => {\n        // Draw a rectangle representing the glyph outline.\n        ctx.rect(10, 10, 80, 80);\n      };\n    }\n  };\n  // Create a CanvasGraphics instance.\n  const cg = new CanvasGraphics(context, {}, {});\n  // Configure the graphics state to use stroke mode with a gradient.\n  cg.current.font = fakeFont;\n  cg.current.fontSize = 50;\n  cg.current.fontSizeScale = 1;\n  cg.current.textRenderingMode = TextRenderingMode.STROKE;\n  cg.current.lineWidth = 10;\n  cg.current.patternStroke = true;\n  cg.current.strokeColor = fakeStrokeColor;\n  // Render a fake glyph.\n  cg.showText([{ fontChar: \"A\", width: 500 }]);\n  // Extract a pixel from the stroked area.\n  const pixelData = context.getImageData(15, 15, 1, 1).data;\n  // Pre-patch, the stroke would be rendered as black; post-patch, the gradient is applied.\n  if (pixelData[0] === 0 && pixelData[1] === 0 && pixelData[2] === 0) {\n    throw new Error(\"Gradient stroke not applied\");\n  }\n});",
    "i5_llama-3.3-70b-versatile": "it(\"should apply gradient when stroking text\", async () => {\n  const { DefaultCanvasFactory } = await import(\"../../src/display/api.js\");\n  const { CanvasGraphics, TextRenderingMode } = await import(\"../../src/display/canvas.js\");\n  const { getTopLeftPixel } = await import(\"./test_utils.js\");\n  const canvasFactory = new DefaultCanvasFactory();\n  const { canvas, context } = canvasFactory.create(100, 100);\n  // Fill background white.\n  context.fillStyle = \"white\";\n  context.fillRect(0, 0, 100, 100);\n  // Create a fake strokeColor that returns a linear gradient.\n  const fakeStrokeColor = {\n    getPattern: (ctx) => {\n      const grad = ctx.createLinearGradient(10, 10, 90, 10);\n      grad.addColorStop(0, \"blue\");\n      grad.addColorStop(1, \"red\");\n      return grad;\n    }\n  };\n  // Create a fake font object that draws a simple rectangle path.\n  const fakeFont = {\n    missingFile: false,\n    disableFontFace: false,\n    getPathGenerator: () => {\n      return (ctx, size) => {\n        // Draw a rectangle representing the glyph outline.\n        ctx.rect(10, 10, 80, 80);\n      };\n    }\n  };\n  // Create a CanvasGraphics instance.\n  const cg = new CanvasGraphics(context, {}, {});\n  // Configure the graphics state to use stroke mode with a gradient.\n  cg.current.font = fakeFont;\n  cg.current.fontSize = 50;\n  cg.current.fontSizeScale = 1;\n  cg.current.textRenderingMode = TextRenderingMode.STROKE;\n  cg.current.lineWidth = 10;\n  cg.current.patternStroke = true;\n  cg.current.strokeColor = fakeStrokeColor;\n  // Render a fake glyph.\n  cg.showText([{ fontChar: \"A\", width: 500 }]);\n  // Extract a pixel from the stroked area.\n  const pixelData = context.getImageData(15, 15, 1, 1).data;\n  // Pre-patch, the stroke would be rendered as black; post-patch, the gradient is applied.\n  if (pixelData[0] === 0 && pixelData[1] === 0 && pixelData[2] === 0) {\n    throw new Error(\"Gradient stroke not applied\");\n  }\n});"
  },
  "19086": {
    "i1_deepseek-r1-distill-llama-70b": "it(\"should populate options with fieldValue when no options are defined\", async () => {\n  const { ChoiceWidgetAnnotation } = await import(\"../../src/core/annotation.js\");\n  const { Dict } = await import(\"../../src/core/primitives.js\");\n  const dict = new Dict({});\n  const params = {\n    dict,\n    xref: { fetchIfRef: x => x },\n    data: { fieldValue: \"Account123\" }\n  };\n  const annot = new ChoiceWidgetAnnotation(params);\n  if (annot.data.options.length !== 1) {\n    throw new Error(\"Expected options to be populated from fieldValue.\");\n  }\n  const option = annot.data.options[0];\n  if (option.exportValue !== \"Account123\" || option.displayValue !== \"Account123\") {\n    throw new Error(\"Option values do not match fieldValue.\");\n  }\n});",
    "i1_gpt-4o": "it(\"should populate options with fieldValue when no options are defined\", async () => {\n  const { ChoiceWidgetAnnotation } = await import(\"../../src/core/annotation.js\");\n  const { Dict } = await import(\"../../src/core/primitives.js\");\n  const dict = new Dict({});\n  const params = {\n    dict,\n    xref: { fetchIfRef: x => x },\n    data: { fieldValue: \"Account123\" }\n  };\n  const annot = new ChoiceWidgetAnnotation(params);\n  if (annot.data.options.length !== 1) {\n    throw new Error(\"Expected options to be populated from fieldValue.\");\n  }\n  const option = annot.data.options[0];\n  if (option.exportValue !== \"Account123\" || option.displayValue !== \"Account123\") {\n    throw new Error(\"Option values do not match fieldValue.\");\n  }\n});",
    "i1_llama-3.3-70b-versatile": "it(\"should populate options with fieldValue when no options are defined\", async () => {\n  const { ChoiceWidgetAnnotation } = await import(\"../../src/core/annotation.js\");\n  const { Dict } = await import(\"../../src/core/primitives.js\");\n  const dict = new Dict({});\n  const params = {\n    dict,\n    xref: { fetchIfRef: x => x },\n    data: { fieldValue: \"Account123\" }\n  };\n  const annot = new ChoiceWidgetAnnotation(params);\n  if (annot.data.options.length !== 1) {\n    throw new Error(\"Expected options to be populated from fieldValue.\");\n  }\n  const option = annot.data.options[0];\n  if (option.exportValue !== \"Account123\" || option.displayValue !== \"Account123\") {\n    throw new Error(\"Option values do not match fieldValue.\");\n  }\n});",
    "i1_MOCK": "it(\"should populate options with fieldValue when no options are defined\", async () => {\n  const { ChoiceWidgetAnnotation } = await import(\"../../src/core/annotation.js\");\n  const { Dict } = await import(\"../../src/core/primitives.js\");\n  const dict = new Dict({});\n  const params = {\n    dict,\n    xref: { fetchIfRef: x => x },\n    data: { fieldValue: \"Account123\" }\n  };\n  const annot = new ChoiceWidgetAnnotation(params);\n  if (annot.data.options.length !== 1) {\n    throw new Error(\"Expected options to be populated from fieldValue.\");\n  }\n  const option = annot.data.options[0];\n  if (option.exportValue !== \"Account123\" || option.displayValue !== \"Account123\") {\n    throw new Error(\"Option values do not match fieldValue.\");\n  }\n});",
    "i2_deepseek-r1-distill-llama-70b": "it(\"should populate options with fieldValue when no options are defined\", async () => {\n  const { ChoiceWidgetAnnotation } = await import(\"../../src/core/annotation.js\");\n  const { Dict } = await import(\"../../src/core/primitives.js\");\n  const dict = new Dict({});\n  const params = {\n    dict,\n    xref: { fetchIfRef: x => x },\n    data: { fieldValue: \"Account123\" }\n  };\n  const annot = new ChoiceWidgetAnnotation(params);\n  if (annot.data.options.length !== 1) {\n    throw new Error(\"Expected options to be populated from fieldValue.\");\n  }\n  const option = annot.data.options[0];\n  if (option.exportValue !== \"Account123\" || option.displayValue !== \"Account123\") {\n    throw new Error(\"Option values do not match fieldValue.\");\n  }\n});",
    "i2_gpt-4o": "it(\"should populate options with fieldValue when no options are defined\", async () => {\n  const { ChoiceWidgetAnnotation } = await import(\"../../src/core/annotation.js\");\n  const { Dict } = await import(\"../../src/core/primitives.js\");\n  const dict = new Dict({});\n  const params = {\n    dict,\n    xref: { fetchIfRef: x => x },\n    data: { fieldValue: \"Account123\" }\n  };\n  const annot = new ChoiceWidgetAnnotation(params);\n  if (annot.data.options.length !== 1) {\n    throw new Error(\"Expected options to be populated from fieldValue.\");\n  }\n  const option = annot.data.options[0];\n  if (option.exportValue !== \"Account123\" || option.displayValue !== \"Account123\") {\n    throw new Error(\"Option values do not match fieldValue.\");\n  }\n});",
    "i2_llama-3.3-70b-versatile": "it(\"should populate options with fieldValue when no options are defined\", async () => {\n  const { ChoiceWidgetAnnotation } = await import(\"../../src/core/annotation.js\");\n  const { Dict } = await import(\"../../src/core/primitives.js\");\n  const dict = new Dict({});\n  const params = {\n    dict,\n    xref: { fetchIfRef: x => x },\n    data: { fieldValue: \"Account123\" }\n  };\n  const annot = new ChoiceWidgetAnnotation(params);\n  if (annot.data.options.length !== 1) {\n    throw new Error(\"Expected options to be populated from fieldValue.\");\n  }\n  const option = annot.data.options[0];\n  if (option.exportValue !== \"Account123\" || option.displayValue !== \"Account123\") {\n    throw new Error(\"Option values do not match fieldValue.\");\n  }\n});",
    "i3_deepseek-r1-distill-llama-70b": "it(\"should populate options with fieldValue when no options are defined\", async () => {\n  const { ChoiceWidgetAnnotation } = await import(\"../../src/core/annotation.js\");\n  const { Dict } = await import(\"../../src/core/primitives.js\");\n  const dict = new Dict({});\n  const params = {\n    dict,\n    xref: { fetchIfRef: x => x },\n    data: { fieldValue: \"Account123\" }\n  };\n  const annot = new ChoiceWidgetAnnotation(params);\n  if (annot.data.options.length !== 1) {\n    throw new Error(\"Expected options to be populated from fieldValue.\");\n  }\n  const option = annot.data.options[0];\n  if (option.exportValue !== \"Account123\" || option.displayValue !== \"Account123\") {\n    throw new Error(\"Option values do not match fieldValue.\");\n  }\n});",
    "i3_gpt-4o": "it(\"should populate options with fieldValue when no options are defined\", async () => {\n  const { ChoiceWidgetAnnotation } = await import(\"../../src/core/annotation.js\");\n  const { Dict } = await import(\"../../src/core/primitives.js\");\n  const dict = new Dict({});\n  const params = {\n    dict,\n    xref: { fetchIfRef: x => x },\n    data: { fieldValue: \"Account123\" }\n  };\n  const annot = new ChoiceWidgetAnnotation(params);\n  if (annot.data.options.length !== 1) {\n    throw new Error(\"Expected options to be populated from fieldValue.\");\n  }\n  const option = annot.data.options[0];\n  if (option.exportValue !== \"Account123\" || option.displayValue !== \"Account123\") {\n    throw new Error(\"Option values do not match fieldValue.\");\n  }\n});",
    "i3_llama-3.3-70b-versatile": "it(\"should populate options with fieldValue when no options are defined\", async () => {\n  const { ChoiceWidgetAnnotation } = await import(\"../../src/core/annotation.js\");\n  const { Dict } = await import(\"../../src/core/primitives.js\");\n  const dict = new Dict({});\n  const params = {\n    dict,\n    xref: { fetchIfRef: x => x },\n    data: { fieldValue: \"Account123\" }\n  };\n  const annot = new ChoiceWidgetAnnotation(params);\n  if (annot.data.options.length !== 1) {\n    throw new Error(\"Expected options to be populated from fieldValue.\");\n  }\n  const option = annot.data.options[0];\n  if (option.exportValue !== \"Account123\" || option.displayValue !== \"Account123\") {\n    throw new Error(\"Option values do not match fieldValue.\");\n  }\n});",
    "i4_deepseek-r1-distill-llama-70b": "it(\"should populate options with fieldValue when no options are defined\", async () => {\n  const { ChoiceWidgetAnnotation } = await import(\"../../src/core/annotation.js\");\n  const { Dict } = await import(\"../../src/core/primitives.js\");\n  const dict = new Dict({});\n  const params = {\n    dict,\n    xref: { fetchIfRef: x => x },\n    data: { fieldValue: \"Account123\" }\n  };\n  const annot = new ChoiceWidgetAnnotation(params);\n  if (annot.data.options.length !== 1) {\n    throw new Error(\"Expected options to be populated from fieldValue.\");\n  }\n  const option = annot.data.options[0];\n  if (option.exportValue !== \"Account123\" || option.displayValue !== \"Account123\") {\n    throw new Error(\"Option values do not match fieldValue.\");\n  }\n});",
    "i4_gpt-4o": "it(\"should populate options with fieldValue when no options are defined\", async () => {\n  const { ChoiceWidgetAnnotation } = await import(\"../../src/core/annotation.js\");\n  const { Dict } = await import(\"../../src/core/primitives.js\");\n  const dict = new Dict({});\n  const params = {\n    dict,\n    xref: { fetchIfRef: x => x },\n    data: { fieldValue: \"Account123\" }\n  };\n  const annot = new ChoiceWidgetAnnotation(params);\n  if (annot.data.options.length !== 1) {\n    throw new Error(\"Expected options to be populated from fieldValue.\");\n  }\n  const option = annot.data.options[0];\n  if (option.exportValue !== \"Account123\" || option.displayValue !== \"Account123\") {\n    throw new Error(\"Option values do not match fieldValue.\");\n  }\n});",
    "i4_llama-3.3-70b-versatile": "it(\"should populate options with fieldValue when no options are defined\", async () => {\n  const { ChoiceWidgetAnnotation } = await import(\"../../src/core/annotation.js\");\n  const { Dict } = await import(\"../../src/core/primitives.js\");\n  const dict = new Dict({});\n  const params = {\n    dict,\n    xref: { fetchIfRef: x => x },\n    data: { fieldValue: \"Account123\" }\n  };\n  const annot = new ChoiceWidgetAnnotation(params);\n  if (annot.data.options.length !== 1) {\n    throw new Error(\"Expected options to be populated from fieldValue.\");\n  }\n  const option = annot.data.options[0];\n  if (option.exportValue !== \"Account123\" || option.displayValue !== \"Account123\") {\n    throw new Error(\"Option values do not match fieldValue.\");\n  }\n});",
    "i5_deepseek-r1-distill-llama-70b": "it(\"should populate options with fieldValue when no options are defined\", async () => {\n  const { ChoiceWidgetAnnotation } = await import(\"../../src/core/annotation.js\");\n  const { Dict } = await import(\"../../src/core/primitives.js\");\n  const dict = new Dict({});\n  const params = {\n    dict,\n    xref: { fetchIfRef: x => x },\n    data: { fieldValue: \"Account123\" }\n  };\n  const annot = new ChoiceWidgetAnnotation(params);\n  if (annot.data.options.length !== 1) {\n    throw new Error(\"Expected options to be populated from fieldValue.\");\n  }\n  const option = annot.data.options[0];\n  if (option.exportValue !== \"Account123\" || option.displayValue !== \"Account123\") {\n    throw new Error(\"Option values do not match fieldValue.\");\n  }\n});",
    "i5_gpt-4o": "it(\"should populate options with fieldValue when no options are defined\", async () => {\n  const { ChoiceWidgetAnnotation } = await import(\"../../src/core/annotation.js\");\n  const { Dict } = await import(\"../../src/core/primitives.js\");\n  const dict = new Dict({});\n  const params = {\n    dict,\n    xref: { fetchIfRef: x => x },\n    data: { fieldValue: \"Account123\" }\n  };\n  const annot = new ChoiceWidgetAnnotation(params);\n  if (annot.data.options.length !== 1) {\n    throw new Error(\"Expected options to be populated from fieldValue.\");\n  }\n  const option = annot.data.options[0];\n  if (option.exportValue !== \"Account123\" || option.displayValue !== \"Account123\") {\n    throw new Error(\"Option values do not match fieldValue.\");\n  }\n});",
    "i5_llama-3.3-70b-versatile": "it(\"should populate options with fieldValue when no options are defined\", async () => {\n  const { ChoiceWidgetAnnotation } = await import(\"../../src/core/annotation.js\");\n  const { Dict } = await import(\"../../src/core/primitives.js\");\n  const dict = new Dict({});\n  const params = {\n    dict,\n    xref: { fetchIfRef: x => x },\n    data: { fieldValue: \"Account123\" }\n  };\n  const annot = new ChoiceWidgetAnnotation(params);\n  if (annot.data.options.length !== 1) {\n    throw new Error(\"Expected options to be populated from fieldValue.\");\n  }\n  const option = annot.data.options[0];\n  if (option.exportValue !== \"Account123\" || option.displayValue !== \"Account123\") {\n    throw new Error(\"Option values do not match fieldValue.\");\n  }\n});"
  },
  "19095": {
    "i1_deepseek-r1-distill-llama-70b": "it(\"should rescale huge image data to avoid decode errors\", async () => {\n  const { ImageResizer, ImageKind } = await import(\"../../src/core/image_resizer.js\");\n  const imageUtils = await import(\"../../src/shared/image_utils.js\");\n  // Monkey-patch convertToRGBA to bypass actual conversion.\n  const originalConvertToRGBA = imageUtils.convertToRGBA;\n  imageUtils.convertToRGBA = ({ srcPos, destPos }) => ({ srcPos, destPos });\n  // Force the branch that creates an ImageBitmap.\n  ImageResizer.needsToBeResized = () => false;\n  // Override Uint8Array to simulate allocation failure for large sizes.\n  const OriginalUint8Array = Uint8Array;\n  const threshold = 10000;\n  function FakeUint8Array(arg) {\n    if (typeof arg === \"number\" && arg > threshold) {\n      throw new Error(\"Simulated allocation failure\");\n    }\n    return new OriginalUint8Array(arg);\n  }\n  FakeUint8Array.from = OriginalUint8Array.from;\n  FakeUint8Array.of = OriginalUint8Array.of;\n  globalThis.Uint8Array = FakeUint8Array;\n  // Create fake image data with dimensions triggering the rescale branch.\n  // width * height * 4 > MAX_INT_32; choose width = 1024, height = 524288 so that 1024*524288*4 = 2147483648 > 2147483647.\n  const fakeData = new OriginalUint8Array(100); // dummy data\n  const imgData = {\n    width: 1024,\n    height: 524288,\n    data: fakeData,\n    kind: ImageKind.RGBA_32BPP,\n  };\n  const resizer = new ImageResizer(imgData, false);\n  const result = await resizer._createImage();\n  // Restore original Uint8Array and convertToRGBA.\n  globalThis.Uint8Array = OriginalUint8Array;\n  imageUtils.convertToRGBA = originalConvertToRGBA;\n  if (result !== null) {\n    if (result.data !== null) {\n      throw new Error(\"Expected rescaled image data to have data set to null\");\n    }\n    if (!result.bitmap) {\n      throw new Error(\"Expected rescaled image data to have a bitmap\");\n    }\n  }\n});",
    "i1_gpt-4o": "it(\"should rescale huge image data to avoid decode errors\", async () => {\n  const { ImageResizer, ImageKind } = await import(\"../../src/core/image_resizer.js\");\n  const imageUtils = await import(\"../../src/shared/image_utils.js\");\n  // Monkey-patch convertToRGBA to bypass actual conversion.\n  const originalConvertToRGBA = imageUtils.convertToRGBA;\n  imageUtils.convertToRGBA = ({ srcPos, destPos }) => ({ srcPos, destPos });\n  // Force the branch that creates an ImageBitmap.\n  ImageResizer.needsToBeResized = () => false;\n  // Override Uint8Array to simulate allocation failure for large sizes.\n  const OriginalUint8Array = Uint8Array;\n  const threshold = 10000;\n  function FakeUint8Array(arg) {\n    if (typeof arg === \"number\" && arg > threshold) {\n      throw new Error(\"Simulated allocation failure\");\n    }\n    return new OriginalUint8Array(arg);\n  }\n  FakeUint8Array.from = OriginalUint8Array.from;\n  FakeUint8Array.of = OriginalUint8Array.of;\n  globalThis.Uint8Array = FakeUint8Array;\n  // Create fake image data with dimensions triggering the rescale branch.\n  // width * height * 4 > MAX_INT_32; choose width = 1024, height = 524288 so that 1024*524288*4 = 2147483648 > 2147483647.\n  const fakeData = new OriginalUint8Array(100); // dummy data\n  const imgData = {\n    width: 1024,\n    height: 524288,\n    data: fakeData,\n    kind: ImageKind.RGBA_32BPP,\n  };\n  const resizer = new ImageResizer(imgData, false);\n  const result = await resizer._createImage();\n  // Restore original Uint8Array and convertToRGBA.\n  globalThis.Uint8Array = OriginalUint8Array;\n  imageUtils.convertToRGBA = originalConvertToRGBA;\n  if (result !== null) {\n    if (result.data !== null) {\n      throw new Error(\"Expected rescaled image data to have data set to null\");\n    }\n    if (!result.bitmap) {\n      throw new Error(\"Expected rescaled image data to have a bitmap\");\n    }\n  }\n});",
    "i1_llama-3.3-70b-versatile": "it(\"should rescale huge image data to avoid decode errors\", async () => {\n  const { ImageResizer, ImageKind } = await import(\"../../src/core/image_resizer.js\");\n  const imageUtils = await import(\"../../src/shared/image_utils.js\");\n  // Monkey-patch convertToRGBA to bypass actual conversion.\n  const originalConvertToRGBA = imageUtils.convertToRGBA;\n  imageUtils.convertToRGBA = ({ srcPos, destPos }) => ({ srcPos, destPos });\n  // Force the branch that creates an ImageBitmap.\n  ImageResizer.needsToBeResized = () => false;\n  // Override Uint8Array to simulate allocation failure for large sizes.\n  const OriginalUint8Array = Uint8Array;\n  const threshold = 10000;\n  function FakeUint8Array(arg) {\n    if (typeof arg === \"number\" && arg > threshold) {\n      throw new Error(\"Simulated allocation failure\");\n    }\n    return new OriginalUint8Array(arg);\n  }\n  FakeUint8Array.from = OriginalUint8Array.from;\n  FakeUint8Array.of = OriginalUint8Array.of;\n  globalThis.Uint8Array = FakeUint8Array;\n  // Create fake image data with dimensions triggering the rescale branch.\n  // width * height * 4 > MAX_INT_32; choose width = 1024, height = 524288 so that 1024*524288*4 = 2147483648 > 2147483647.\n  const fakeData = new OriginalUint8Array(100); // dummy data\n  const imgData = {\n    width: 1024,\n    height: 524288,\n    data: fakeData,\n    kind: ImageKind.RGBA_32BPP,\n  };\n  const resizer = new ImageResizer(imgData, false);\n  const result = await resizer._createImage();\n  // Restore original Uint8Array and convertToRGBA.\n  globalThis.Uint8Array = OriginalUint8Array;\n  imageUtils.convertToRGBA = originalConvertToRGBA;\n  if (result !== null) {\n    if (result.data !== null) {\n      throw new Error(\"Expected rescaled image data to have data set to null\");\n    }\n    if (!result.bitmap) {\n      throw new Error(\"Expected rescaled image data to have a bitmap\");\n    }\n  }\n});",
    "i1_MOCK": "it(\"should rescale huge image data to avoid decode errors\", async () => {\n  const { ImageResizer, ImageKind } = await import(\"../../src/core/image_resizer.js\");\n  const imageUtils = await import(\"../../src/shared/image_utils.js\");\n  // Monkey-patch convertToRGBA to bypass actual conversion.\n  const originalConvertToRGBA = imageUtils.convertToRGBA;\n  imageUtils.convertToRGBA = ({ srcPos, destPos }) => ({ srcPos, destPos });\n  // Force the branch that creates an ImageBitmap.\n  ImageResizer.needsToBeResized = () => false;\n  // Override Uint8Array to simulate allocation failure for large sizes.\n  const OriginalUint8Array = Uint8Array;\n  const threshold = 10000;\n  function FakeUint8Array(arg) {\n    if (typeof arg === \"number\" && arg > threshold) {\n      throw new Error(\"Simulated allocation failure\");\n    }\n    return new OriginalUint8Array(arg);\n  }\n  FakeUint8Array.from = OriginalUint8Array.from;\n  FakeUint8Array.of = OriginalUint8Array.of;\n  globalThis.Uint8Array = FakeUint8Array;\n  // Create fake image data with dimensions triggering the rescale branch.\n  // width * height * 4 > MAX_INT_32; choose width = 1024, height = 524288 so that 1024*524288*4 = 2147483648 > 2147483647.\n  const fakeData = new OriginalUint8Array(100); // dummy data\n  const imgData = {\n    width: 1024,\n    height: 524288,\n    data: fakeData,\n    kind: ImageKind.RGBA_32BPP,\n  };\n  const resizer = new ImageResizer(imgData, false);\n  const result = await resizer._createImage();\n  // Restore original Uint8Array and convertToRGBA.\n  globalThis.Uint8Array = OriginalUint8Array;\n  imageUtils.convertToRGBA = originalConvertToRGBA;\n  if (result !== null) {\n    if (result.data !== null) {\n      throw new Error(\"Expected rescaled image data to have data set to null\");\n    }\n    if (!result.bitmap) {\n      throw new Error(\"Expected rescaled image data to have a bitmap\");\n    }\n  }\n});",
    "i2_deepseek-r1-distill-llama-70b": "it(\"should rescale huge image data to avoid decode errors\", async () => {\n  const { ImageResizer, ImageKind } = await import(\"../../src/core/image_resizer.js\");\n  const imageUtils = await import(\"../../src/shared/image_utils.js\");\n  // Monkey-patch convertToRGBA to bypass actual conversion.\n  const originalConvertToRGBA = imageUtils.convertToRGBA;\n  imageUtils.convertToRGBA = ({ srcPos, destPos }) => ({ srcPos, destPos });\n  // Force the branch that creates an ImageBitmap.\n  ImageResizer.needsToBeResized = () => false;\n  // Override Uint8Array to simulate allocation failure for large sizes.\n  const OriginalUint8Array = Uint8Array;\n  const threshold = 10000;\n  function FakeUint8Array(arg) {\n    if (typeof arg === \"number\" && arg > threshold) {\n      throw new Error(\"Simulated allocation failure\");\n    }\n    return new OriginalUint8Array(arg);\n  }\n  FakeUint8Array.from = OriginalUint8Array.from;\n  FakeUint8Array.of = OriginalUint8Array.of;\n  globalThis.Uint8Array = FakeUint8Array;\n  // Create fake image data with dimensions triggering the rescale branch.\n  // width * height * 4 > MAX_INT_32; choose width = 1024, height = 524288 so that 1024*524288*4 = 2147483648 > 2147483647.\n  const fakeData = new OriginalUint8Array(100); // dummy data\n  const imgData = {\n    width: 1024,\n    height: 524288,\n    data: fakeData,\n    kind: ImageKind.RGBA_32BPP,\n  };\n  const resizer = new ImageResizer(imgData, false);\n  const result = await resizer._createImage();\n  // Restore original Uint8Array and convertToRGBA.\n  globalThis.Uint8Array = OriginalUint8Array;\n  imageUtils.convertToRGBA = originalConvertToRGBA;\n  if (result !== null) {\n    if (result.data !== null) {\n      throw new Error(\"Expected rescaled image data to have data set to null\");\n    }\n    if (!result.bitmap) {\n      throw new Error(\"Expected rescaled image data to have a bitmap\");\n    }\n  }\n});",
    "i2_gpt-4o": "it(\"should rescale huge image data to avoid decode errors\", async () => {\n  const { ImageResizer, ImageKind } = await import(\"../../src/core/image_resizer.js\");\n  const imageUtils = await import(\"../../src/shared/image_utils.js\");\n  // Monkey-patch convertToRGBA to bypass actual conversion.\n  const originalConvertToRGBA = imageUtils.convertToRGBA;\n  imageUtils.convertToRGBA = ({ srcPos, destPos }) => ({ srcPos, destPos });\n  // Force the branch that creates an ImageBitmap.\n  ImageResizer.needsToBeResized = () => false;\n  // Override Uint8Array to simulate allocation failure for large sizes.\n  const OriginalUint8Array = Uint8Array;\n  const threshold = 10000;\n  function FakeUint8Array(arg) {\n    if (typeof arg === \"number\" && arg > threshold) {\n      throw new Error(\"Simulated allocation failure\");\n    }\n    return new OriginalUint8Array(arg);\n  }\n  FakeUint8Array.from = OriginalUint8Array.from;\n  FakeUint8Array.of = OriginalUint8Array.of;\n  globalThis.Uint8Array = FakeUint8Array;\n  // Create fake image data with dimensions triggering the rescale branch.\n  // width * height * 4 > MAX_INT_32; choose width = 1024, height = 524288 so that 1024*524288*4 = 2147483648 > 2147483647.\n  const fakeData = new OriginalUint8Array(100); // dummy data\n  const imgData = {\n    width: 1024,\n    height: 524288,\n    data: fakeData,\n    kind: ImageKind.RGBA_32BPP,\n  };\n  const resizer = new ImageResizer(imgData, false);\n  const result = await resizer._createImage();\n  // Restore original Uint8Array and convertToRGBA.\n  globalThis.Uint8Array = OriginalUint8Array;\n  imageUtils.convertToRGBA = originalConvertToRGBA;\n  if (result !== null) {\n    if (result.data !== null) {\n      throw new Error(\"Expected rescaled image data to have data set to null\");\n    }\n    if (!result.bitmap) {\n      throw new Error(\"Expected rescaled image data to have a bitmap\");\n    }\n  }\n});",
    "i2_llama-3.3-70b-versatile": "it(\"should rescale huge image data to avoid decode errors\", async () => {\n  const { ImageResizer, ImageKind } = await import(\"../../src/core/image_resizer.js\");\n  const imageUtils = await import(\"../../src/shared/image_utils.js\");\n  // Monkey-patch convertToRGBA to bypass actual conversion.\n  const originalConvertToRGBA = imageUtils.convertToRGBA;\n  imageUtils.convertToRGBA = ({ srcPos, destPos }) => ({ srcPos, destPos });\n  // Force the branch that creates an ImageBitmap.\n  ImageResizer.needsToBeResized = () => false;\n  // Override Uint8Array to simulate allocation failure for large sizes.\n  const OriginalUint8Array = Uint8Array;\n  const threshold = 10000;\n  function FakeUint8Array(arg) {\n    if (typeof arg === \"number\" && arg > threshold) {\n      throw new Error(\"Simulated allocation failure\");\n    }\n    return new OriginalUint8Array(arg);\n  }\n  FakeUint8Array.from = OriginalUint8Array.from;\n  FakeUint8Array.of = OriginalUint8Array.of;\n  globalThis.Uint8Array = FakeUint8Array;\n  // Create fake image data with dimensions triggering the rescale branch.\n  // width * height * 4 > MAX_INT_32; choose width = 1024, height = 524288 so that 1024*524288*4 = 2147483648 > 2147483647.\n  const fakeData = new OriginalUint8Array(100); // dummy data\n  const imgData = {\n    width: 1024,\n    height: 524288,\n    data: fakeData,\n    kind: ImageKind.RGBA_32BPP,\n  };\n  const resizer = new ImageResizer(imgData, false);\n  const result = await resizer._createImage();\n  // Restore original Uint8Array and convertToRGBA.\n  globalThis.Uint8Array = OriginalUint8Array;\n  imageUtils.convertToRGBA = originalConvertToRGBA;\n  if (result !== null) {\n    if (result.data !== null) {\n      throw new Error(\"Expected rescaled image data to have data set to null\");\n    }\n    if (!result.bitmap) {\n      throw new Error(\"Expected rescaled image data to have a bitmap\");\n    }\n  }\n});",
    "i3_deepseek-r1-distill-llama-70b": "it(\"should rescale huge image data to avoid decode errors\", async () => {\n  const { ImageResizer, ImageKind } = await import(\"../../src/core/image_resizer.js\");\n  const imageUtils = await import(\"../../src/shared/image_utils.js\");\n  // Monkey-patch convertToRGBA to bypass actual conversion.\n  const originalConvertToRGBA = imageUtils.convertToRGBA;\n  imageUtils.convertToRGBA = ({ srcPos, destPos }) => ({ srcPos, destPos });\n  // Force the branch that creates an ImageBitmap.\n  ImageResizer.needsToBeResized = () => false;\n  // Override Uint8Array to simulate allocation failure for large sizes.\n  const OriginalUint8Array = Uint8Array;\n  const threshold = 10000;\n  function FakeUint8Array(arg) {\n    if (typeof arg === \"number\" && arg > threshold) {\n      throw new Error(\"Simulated allocation failure\");\n    }\n    return new OriginalUint8Array(arg);\n  }\n  FakeUint8Array.from = OriginalUint8Array.from;\n  FakeUint8Array.of = OriginalUint8Array.of;\n  globalThis.Uint8Array = FakeUint8Array;\n  // Create fake image data with dimensions triggering the rescale branch.\n  // width * height * 4 > MAX_INT_32; choose width = 1024, height = 524288 so that 1024*524288*4 = 2147483648 > 2147483647.\n  const fakeData = new OriginalUint8Array(100); // dummy data\n  const imgData = {\n    width: 1024,\n    height: 524288,\n    data: fakeData,\n    kind: ImageKind.RGBA_32BPP,\n  };\n  const resizer = new ImageResizer(imgData, false);\n  const result = await resizer._createImage();\n  // Restore original Uint8Array and convertToRGBA.\n  globalThis.Uint8Array = OriginalUint8Array;\n  imageUtils.convertToRGBA = originalConvertToRGBA;\n  if (result !== null) {\n    if (result.data !== null) {\n      throw new Error(\"Expected rescaled image data to have data set to null\");\n    }\n    if (!result.bitmap) {\n      throw new Error(\"Expected rescaled image data to have a bitmap\");\n    }\n  }\n});",
    "i3_gpt-4o": "it(\"should rescale huge image data to avoid decode errors\", async () => {\n  const { ImageResizer, ImageKind } = await import(\"../../src/core/image_resizer.js\");\n  const imageUtils = await import(\"../../src/shared/image_utils.js\");\n  // Monkey-patch convertToRGBA to bypass actual conversion.\n  const originalConvertToRGBA = imageUtils.convertToRGBA;\n  imageUtils.convertToRGBA = ({ srcPos, destPos }) => ({ srcPos, destPos });\n  // Force the branch that creates an ImageBitmap.\n  ImageResizer.needsToBeResized = () => false;\n  // Override Uint8Array to simulate allocation failure for large sizes.\n  const OriginalUint8Array = Uint8Array;\n  const threshold = 10000;\n  function FakeUint8Array(arg) {\n    if (typeof arg === \"number\" && arg > threshold) {\n      throw new Error(\"Simulated allocation failure\");\n    }\n    return new OriginalUint8Array(arg);\n  }\n  FakeUint8Array.from = OriginalUint8Array.from;\n  FakeUint8Array.of = OriginalUint8Array.of;\n  globalThis.Uint8Array = FakeUint8Array;\n  // Create fake image data with dimensions triggering the rescale branch.\n  // width * height * 4 > MAX_INT_32; choose width = 1024, height = 524288 so that 1024*524288*4 = 2147483648 > 2147483647.\n  const fakeData = new OriginalUint8Array(100); // dummy data\n  const imgData = {\n    width: 1024,\n    height: 524288,\n    data: fakeData,\n    kind: ImageKind.RGBA_32BPP,\n  };\n  const resizer = new ImageResizer(imgData, false);\n  const result = await resizer._createImage();\n  // Restore original Uint8Array and convertToRGBA.\n  globalThis.Uint8Array = OriginalUint8Array;\n  imageUtils.convertToRGBA = originalConvertToRGBA;\n  if (result !== null) {\n    if (result.data !== null) {\n      throw new Error(\"Expected rescaled image data to have data set to null\");\n    }\n    if (!result.bitmap) {\n      throw new Error(\"Expected rescaled image data to have a bitmap\");\n    }\n  }\n});",
    "i3_llama-3.3-70b-versatile": "it(\"should rescale huge image data to avoid decode errors\", async () => {\n  const { ImageResizer, ImageKind } = await import(\"../../src/core/image_resizer.js\");\n  const imageUtils = await import(\"../../src/shared/image_utils.js\");\n  // Monkey-patch convertToRGBA to bypass actual conversion.\n  const originalConvertToRGBA = imageUtils.convertToRGBA;\n  imageUtils.convertToRGBA = ({ srcPos, destPos }) => ({ srcPos, destPos });\n  // Force the branch that creates an ImageBitmap.\n  ImageResizer.needsToBeResized = () => false;\n  // Override Uint8Array to simulate allocation failure for large sizes.\n  const OriginalUint8Array = Uint8Array;\n  const threshold = 10000;\n  function FakeUint8Array(arg) {\n    if (typeof arg === \"number\" && arg > threshold) {\n      throw new Error(\"Simulated allocation failure\");\n    }\n    return new OriginalUint8Array(arg);\n  }\n  FakeUint8Array.from = OriginalUint8Array.from;\n  FakeUint8Array.of = OriginalUint8Array.of;\n  globalThis.Uint8Array = FakeUint8Array;\n  // Create fake image data with dimensions triggering the rescale branch.\n  // width * height * 4 > MAX_INT_32; choose width = 1024, height = 524288 so that 1024*524288*4 = 2147483648 > 2147483647.\n  const fakeData = new OriginalUint8Array(100); // dummy data\n  const imgData = {\n    width: 1024,\n    height: 524288,\n    data: fakeData,\n    kind: ImageKind.RGBA_32BPP,\n  };\n  const resizer = new ImageResizer(imgData, false);\n  const result = await resizer._createImage();\n  // Restore original Uint8Array and convertToRGBA.\n  globalThis.Uint8Array = OriginalUint8Array;\n  imageUtils.convertToRGBA = originalConvertToRGBA;\n  if (result !== null) {\n    if (result.data !== null) {\n      throw new Error(\"Expected rescaled image data to have data set to null\");\n    }\n    if (!result.bitmap) {\n      throw new Error(\"Expected rescaled image data to have a bitmap\");\n    }\n  }\n});",
    "i4_deepseek-r1-distill-llama-70b": "it(\"should rescale huge image data to avoid decode errors\", async () => {\n  const { ImageResizer, ImageKind } = await import(\"../../src/core/image_resizer.js\");\n  const imageUtils = await import(\"../../src/shared/image_utils.js\");\n  // Monkey-patch convertToRGBA to bypass actual conversion.\n  const originalConvertToRGBA = imageUtils.convertToRGBA;\n  imageUtils.convertToRGBA = ({ srcPos, destPos }) => ({ srcPos, destPos });\n  // Force the branch that creates an ImageBitmap.\n  ImageResizer.needsToBeResized = () => false;\n  // Override Uint8Array to simulate allocation failure for large sizes.\n  const OriginalUint8Array = Uint8Array;\n  const threshold = 10000;\n  function FakeUint8Array(arg) {\n    if (typeof arg === \"number\" && arg > threshold) {\n      throw new Error(\"Simulated allocation failure\");\n    }\n    return new OriginalUint8Array(arg);\n  }\n  FakeUint8Array.from = OriginalUint8Array.from;\n  FakeUint8Array.of = OriginalUint8Array.of;\n  globalThis.Uint8Array = FakeUint8Array;\n  // Create fake image data with dimensions triggering the rescale branch.\n  // width * height * 4 > MAX_INT_32; choose width = 1024, height = 524288 so that 1024*524288*4 = 2147483648 > 2147483647.\n  const fakeData = new OriginalUint8Array(100); // dummy data\n  const imgData = {\n    width: 1024,\n    height: 524288,\n    data: fakeData,\n    kind: ImageKind.RGBA_32BPP,\n  };\n  const resizer = new ImageResizer(imgData, false);\n  const result = await resizer._createImage();\n  // Restore original Uint8Array and convertToRGBA.\n  globalThis.Uint8Array = OriginalUint8Array;\n  imageUtils.convertToRGBA = originalConvertToRGBA;\n  if (result !== null) {\n    if (result.data !== null) {\n      throw new Error(\"Expected rescaled image data to have data set to null\");\n    }\n    if (!result.bitmap) {\n      throw new Error(\"Expected rescaled image data to have a bitmap\");\n    }\n  }\n});",
    "i4_gpt-4o": "it(\"should rescale huge image data to avoid decode errors\", async () => {\n  const { ImageResizer, ImageKind } = await import(\"../../src/core/image_resizer.js\");\n  const imageUtils = await import(\"../../src/shared/image_utils.js\");\n  // Monkey-patch convertToRGBA to bypass actual conversion.\n  const originalConvertToRGBA = imageUtils.convertToRGBA;\n  imageUtils.convertToRGBA = ({ srcPos, destPos }) => ({ srcPos, destPos });\n  // Force the branch that creates an ImageBitmap.\n  ImageResizer.needsToBeResized = () => false;\n  // Override Uint8Array to simulate allocation failure for large sizes.\n  const OriginalUint8Array = Uint8Array;\n  const threshold = 10000;\n  function FakeUint8Array(arg) {\n    if (typeof arg === \"number\" && arg > threshold) {\n      throw new Error(\"Simulated allocation failure\");\n    }\n    return new OriginalUint8Array(arg);\n  }\n  FakeUint8Array.from = OriginalUint8Array.from;\n  FakeUint8Array.of = OriginalUint8Array.of;\n  globalThis.Uint8Array = FakeUint8Array;\n  // Create fake image data with dimensions triggering the rescale branch.\n  // width * height * 4 > MAX_INT_32; choose width = 1024, height = 524288 so that 1024*524288*4 = 2147483648 > 2147483647.\n  const fakeData = new OriginalUint8Array(100); // dummy data\n  const imgData = {\n    width: 1024,\n    height: 524288,\n    data: fakeData,\n    kind: ImageKind.RGBA_32BPP,\n  };\n  const resizer = new ImageResizer(imgData, false);\n  const result = await resizer._createImage();\n  // Restore original Uint8Array and convertToRGBA.\n  globalThis.Uint8Array = OriginalUint8Array;\n  imageUtils.convertToRGBA = originalConvertToRGBA;\n  if (result !== null) {\n    if (result.data !== null) {\n      throw new Error(\"Expected rescaled image data to have data set to null\");\n    }\n    if (!result.bitmap) {\n      throw new Error(\"Expected rescaled image data to have a bitmap\");\n    }\n  }\n});",
    "i4_llama-3.3-70b-versatile": "it(\"should rescale huge image data to avoid decode errors\", async () => {\n  const { ImageResizer, ImageKind } = await import(\"../../src/core/image_resizer.js\");\n  const imageUtils = await import(\"../../src/shared/image_utils.js\");\n  // Monkey-patch convertToRGBA to bypass actual conversion.\n  const originalConvertToRGBA = imageUtils.convertToRGBA;\n  imageUtils.convertToRGBA = ({ srcPos, destPos }) => ({ srcPos, destPos });\n  // Force the branch that creates an ImageBitmap.\n  ImageResizer.needsToBeResized = () => false;\n  // Override Uint8Array to simulate allocation failure for large sizes.\n  const OriginalUint8Array = Uint8Array;\n  const threshold = 10000;\n  function FakeUint8Array(arg) {\n    if (typeof arg === \"number\" && arg > threshold) {\n      throw new Error(\"Simulated allocation failure\");\n    }\n    return new OriginalUint8Array(arg);\n  }\n  FakeUint8Array.from = OriginalUint8Array.from;\n  FakeUint8Array.of = OriginalUint8Array.of;\n  globalThis.Uint8Array = FakeUint8Array;\n  // Create fake image data with dimensions triggering the rescale branch.\n  // width * height * 4 > MAX_INT_32; choose width = 1024, height = 524288 so that 1024*524288*4 = 2147483648 > 2147483647.\n  const fakeData = new OriginalUint8Array(100); // dummy data\n  const imgData = {\n    width: 1024,\n    height: 524288,\n    data: fakeData,\n    kind: ImageKind.RGBA_32BPP,\n  };\n  const resizer = new ImageResizer(imgData, false);\n  const result = await resizer._createImage();\n  // Restore original Uint8Array and convertToRGBA.\n  globalThis.Uint8Array = OriginalUint8Array;\n  imageUtils.convertToRGBA = originalConvertToRGBA;\n  if (result !== null) {\n    if (result.data !== null) {\n      throw new Error(\"Expected rescaled image data to have data set to null\");\n    }\n    if (!result.bitmap) {\n      throw new Error(\"Expected rescaled image data to have a bitmap\");\n    }\n  }\n});",
    "i5_deepseek-r1-distill-llama-70b": "it(\"should rescale huge image data to avoid decode errors\", async () => {\n  const { ImageResizer, ImageKind } = await import(\"../../src/core/image_resizer.js\");\n  const imageUtils = await import(\"../../src/shared/image_utils.js\");\n  // Monkey-patch convertToRGBA to bypass actual conversion.\n  const originalConvertToRGBA = imageUtils.convertToRGBA;\n  imageUtils.convertToRGBA = ({ srcPos, destPos }) => ({ srcPos, destPos });\n  // Force the branch that creates an ImageBitmap.\n  ImageResizer.needsToBeResized = () => false;\n  // Override Uint8Array to simulate allocation failure for large sizes.\n  const OriginalUint8Array = Uint8Array;\n  const threshold = 10000;\n  function FakeUint8Array(arg) {\n    if (typeof arg === \"number\" && arg > threshold) {\n      throw new Error(\"Simulated allocation failure\");\n    }\n    return new OriginalUint8Array(arg);\n  }\n  FakeUint8Array.from = OriginalUint8Array.from;\n  FakeUint8Array.of = OriginalUint8Array.of;\n  globalThis.Uint8Array = FakeUint8Array;\n  // Create fake image data with dimensions triggering the rescale branch.\n  // width * height * 4 > MAX_INT_32; choose width = 1024, height = 524288 so that 1024*524288*4 = 2147483648 > 2147483647.\n  const fakeData = new OriginalUint8Array(100); // dummy data\n  const imgData = {\n    width: 1024,\n    height: 524288,\n    data: fakeData,\n    kind: ImageKind.RGBA_32BPP,\n  };\n  const resizer = new ImageResizer(imgData, false);\n  const result = await resizer._createImage();\n  // Restore original Uint8Array and convertToRGBA.\n  globalThis.Uint8Array = OriginalUint8Array;\n  imageUtils.convertToRGBA = originalConvertToRGBA;\n  if (result !== null) {\n    if (result.data !== null) {\n      throw new Error(\"Expected rescaled image data to have data set to null\");\n    }\n    if (!result.bitmap) {\n      throw new Error(\"Expected rescaled image data to have a bitmap\");\n    }\n  }\n});",
    "i5_gpt-4o": "it(\"should rescale huge image data to avoid decode errors\", async () => {\n  const { ImageResizer, ImageKind } = await import(\"../../src/core/image_resizer.js\");\n  const imageUtils = await import(\"../../src/shared/image_utils.js\");\n  // Monkey-patch convertToRGBA to bypass actual conversion.\n  const originalConvertToRGBA = imageUtils.convertToRGBA;\n  imageUtils.convertToRGBA = ({ srcPos, destPos }) => ({ srcPos, destPos });\n  // Force the branch that creates an ImageBitmap.\n  ImageResizer.needsToBeResized = () => false;\n  // Override Uint8Array to simulate allocation failure for large sizes.\n  const OriginalUint8Array = Uint8Array;\n  const threshold = 10000;\n  function FakeUint8Array(arg) {\n    if (typeof arg === \"number\" && arg > threshold) {\n      throw new Error(\"Simulated allocation failure\");\n    }\n    return new OriginalUint8Array(arg);\n  }\n  FakeUint8Array.from = OriginalUint8Array.from;\n  FakeUint8Array.of = OriginalUint8Array.of;\n  globalThis.Uint8Array = FakeUint8Array;\n  // Create fake image data with dimensions triggering the rescale branch.\n  // width * height * 4 > MAX_INT_32; choose width = 1024, height = 524288 so that 1024*524288*4 = 2147483648 > 2147483647.\n  const fakeData = new OriginalUint8Array(100); // dummy data\n  const imgData = {\n    width: 1024,\n    height: 524288,\n    data: fakeData,\n    kind: ImageKind.RGBA_32BPP,\n  };\n  const resizer = new ImageResizer(imgData, false);\n  const result = await resizer._createImage();\n  // Restore original Uint8Array and convertToRGBA.\n  globalThis.Uint8Array = OriginalUint8Array;\n  imageUtils.convertToRGBA = originalConvertToRGBA;\n  if (result !== null) {\n    if (result.data !== null) {\n      throw new Error(\"Expected rescaled image data to have data set to null\");\n    }\n    if (!result.bitmap) {\n      throw new Error(\"Expected rescaled image data to have a bitmap\");\n    }\n  }\n});",
    "i5_llama-3.3-70b-versatile": "it(\"should rescale huge image data to avoid decode errors\", async () => {\n  const { ImageResizer, ImageKind } = await import(\"../../src/core/image_resizer.js\");\n  const imageUtils = await import(\"../../src/shared/image_utils.js\");\n  // Monkey-patch convertToRGBA to bypass actual conversion.\n  const originalConvertToRGBA = imageUtils.convertToRGBA;\n  imageUtils.convertToRGBA = ({ srcPos, destPos }) => ({ srcPos, destPos });\n  // Force the branch that creates an ImageBitmap.\n  ImageResizer.needsToBeResized = () => false;\n  // Override Uint8Array to simulate allocation failure for large sizes.\n  const OriginalUint8Array = Uint8Array;\n  const threshold = 10000;\n  function FakeUint8Array(arg) {\n    if (typeof arg === \"number\" && arg > threshold) {\n      throw new Error(\"Simulated allocation failure\");\n    }\n    return new OriginalUint8Array(arg);\n  }\n  FakeUint8Array.from = OriginalUint8Array.from;\n  FakeUint8Array.of = OriginalUint8Array.of;\n  globalThis.Uint8Array = FakeUint8Array;\n  // Create fake image data with dimensions triggering the rescale branch.\n  // width * height * 4 > MAX_INT_32; choose width = 1024, height = 524288 so that 1024*524288*4 = 2147483648 > 2147483647.\n  const fakeData = new OriginalUint8Array(100); // dummy data\n  const imgData = {\n    width: 1024,\n    height: 524288,\n    data: fakeData,\n    kind: ImageKind.RGBA_32BPP,\n  };\n  const resizer = new ImageResizer(imgData, false);\n  const result = await resizer._createImage();\n  // Restore original Uint8Array and convertToRGBA.\n  globalThis.Uint8Array = OriginalUint8Array;\n  imageUtils.convertToRGBA = originalConvertToRGBA;\n  if (result !== null) {\n    if (result.data !== null) {\n      throw new Error(\"Expected rescaled image data to have data set to null\");\n    }\n    if (!result.bitmap) {\n      throw new Error(\"Expected rescaled image data to have a bitmap\");\n    }\n  }\n});"
  },
  "19236": {
    "i1_deepseek-r1-distill-llama-70b": "it(\"should render HelveticaLTStd fonts with proper fallback\", async () => {\n  const { getDocument } = await import('../../src/display/api.js');\n  const { buildGetDocumentParams } = await import('./test_utils.js');\n  const loadingTask = getDocument(buildGetDocumentParams('issue19234.pdf'));\n  const pdfDocument = await loadingTask.promise;\n  const pdfPage = await pdfDocument.getPage(1);\n  const canvas = new Canvas(1000, 1000);\n  const ctx = canvas.getContext('2d');\n  const renderTask = pdfPage.render({\n    canvasContext: ctx,\n    viewport: pdfPage.getViewport({ scale: 1 }),\n  });\n  await renderTask.promise;\n  const textContent = await pdfPage.getTextContent();\n  const expectedText = \"Blue\";\n  expect(textContent.items.some(item => item.str === expectedText)).toBe(true);\n});",
    "i1_gpt-4o": "it(\"should render text correctly with font fallback\", async () => {\n  const { getDocument } = await import(\"../../src/display/api.js\");\n  const { buildGetDocumentParams } = await import(\"./test_utils.js\");\n  const loadingTask = getDocument(buildGetDocumentParams(\"issue19234.pdf\"));\n  const pdfDocument = await loadingTask.promise;\n  const page = await pdfDocument.getPage(1);\n  const viewport = page.getViewport({ scale: 1.0 });\n  const canvasFactory = new DefaultCanvasFactory();\n  const canvasAndContext = canvasFactory.create(viewport.width, viewport.height);\n  const renderTask = page.render({\n    canvasContext: canvasAndContext.context,\n    viewport,\n  });\n  await renderTask.promise;\n  const imageData = canvasAndContext.context.getImageData(0, 0, viewport.width, viewport.height);\n  const hasBlueText = Array.from(imageData.data).some((value, index) => {\n    return index % 4 === 2 && value > 200; // Check for blue color in the text\n  });\n  expect(hasBlueText).toBe(true);\n});",
    "i1_llama-3.3-70b-versatile": "it(\"should render the PDF with font fallback on nodejslegacy build\", async () => {\n  const { getDocument } = await import('../../src/display/api.js');\n  const { buildGetDocumentParams } = await import('./test_utils.js');\n  const loadingTask = getDocument(buildGetDocumentParams('issue19234.pdf'));\n  const doc = await loadingTask.promise;\n  const page = await doc.getPage(1);\n  const viewport = page.getViewport({ scale: 1 });\n  const canvas = await import('../../src/display/canvas_factory.js').then(({ DOMCanvasFactory }) => new DOMCanvasFactory().createCanvas(viewport.width, viewport.height));\n  const renderTask = page.render({\n    canvasContext: canvas.getContext('2d'),\n    viewport,\n  });\n  await renderTask.promise;\n  const actualData = canvas.toBuffer();\n  const expectedData = await import('./test_utils.js').then(({ TEST_PDFS_PATH }) => import('fs').then(fs => fs.promises.readFile(`${TEST_PDFS_PATH}/expected_output.png`)));\n  expect(actualData).toEqual(expectedData);\n});",
    "i2_deepseek-r1-distill-llama-70b": "it(\"should correctly render HelveticaLTStdBold font with fallback\", async () => {\n  const { getDocument } = await import('../../src/display/api.js');\n  const { buildGetDocumentParams } = await import('./test_utils.js');\n  const loadingTask = getDocument(buildGetDocumentParams('issue19234.pdf'));\n  const pdfDoc = await loadingTask.promise;\n  const page = await pdfDoc.getPage(1);\n  const renderTask = page.render({\n    viewport: page.getViewport({ scale: 1 }),\n    useCanvas: false,\n    useTextLayer: true\n  });\n  await renderTask.promise;\n  const textContent = await page.getTextContent();\n  const text = textContent.items.map(item => item.str).join('');\n\n  expect(text).toMatch(/Form W-4/);\n});",
    "i2_gpt-4o": "it(\"should render text with HelveticaLTStdBold font correctly\", async () => {\n  const { getDocument } = await import('../../src/display/api.js');\n  const { buildGetDocumentParams } = await import('./test_utils.js');\n  const loadingTask = getDocument(buildGetDocumentParams('issue19234.pdf'));\n  const pdfDocument = await loadingTask.promise;\n  const page = await pdfDocument.getPage(1);\n  const operatorList = await page.getOperatorList();\n  const textContent = await page.getTextContent();\n\n  const expectedText = \"Expected text that should be rendered with HelveticaLTStd-Bold\";\n  const actualText = textContent.items.map(item => item.str).join(\" \");\n\n  expect(actualText).toContain(expectedText);\n});",
    "i2_llama-3.3-70b-versatile": "it(\"should render the PDF with the correct font fallback\", async () => {\n  const { getDocument } = await import('../../src/display/api.js');\n  const { buildGetDocumentParams } = await import('./test_utils.js');\n  const loadingTask = getDocument(buildGetDocumentParams('issue19234.pdf'));\n  const pdfDocument = await loadingTask.promise;\n  const pdfPage = await pdfDocument.getPage(1);\n  const image = await pdfPage.render({ viewport: pdfPage.getViewport({ scale: 1 }) });\n  const expectedText = \"Tax Year 2022\";\n  const actualText = await pdfPage.getTextContent();\n  const textItems = actualText.items;\n  const found = textItems.some(item => item.str === expectedText);\n  expect(found).toBe(true);\n});",
    "i3_deepseek-r1-distill-llama-70b": "it(\"should properly fall back to standard fonts when HelveticaLTStd is missing\", async () => {\n  const { getDocument } = await import('../../src/display/api.js');\n  const { buildGetDocumentParams } = await import('./test_utils.js');\n  const loadingTask = getDocument(buildGetDocumentParams('issue19234.pdf'));\n\n  const { numPages } = await loadingTask;\n  const document = await loadingTask.promise;\n  const page = await document.getPage(1);\n\n  const canvas = document.createElement('canvas');\n  const context = canvas.getContext('2d');\n  const viewport = page.getViewport({ scale: 1 });\n\n  const renderTask = page.render({\n    canvasContext: context,\n    viewport,\n    renderingOptions: {\n      useFallbackFonts: true,\n    },\n  });\n\n  await renderTask.promise;\n\n  const pixels = context.getImageData(0, 0, canvas.width, canvas.height).data;\n  const arePixelsNonEmpty = () => {\n    for (let i = 0; i < pixels.length; i += 4) {\n      if (pixels[i + 3] > 0) return true;\n    }\n    return false;\n  };\n\n  expect(arePixelsNonEmpty()).toBe(true);\n});",
    "i3_gpt-4o": "it(\"should render text correctly with font fallback\", async () => {\n  const { getDocument } = await import(\"../../src/display/api.js\");\n  const { buildGetDocumentParams } = await import(\"./test_utils.js\");\n  const loadingTask = getDocument(buildGetDocumentParams(\"issue19234.pdf\"));\n  const pdfDocument = await loadingTask.promise;\n  const page = await pdfDocument.getPage(1);\n  const viewport = page.getViewport({ scale: 1.0 });\n  const canvasFactory = new DefaultCanvasFactory();\n  const canvasAndContext = canvasFactory.create(viewport.width, viewport.height);\n  const renderTask = page.render({\n    canvasContext: canvasAndContext.context,\n    viewport,\n  });\n  await renderTask.promise;\n  const imageData = canvasAndContext.context.getImageData(0, 0, viewport.width, viewport.height);\n  const hasBlueText = Array.from(imageData.data).some((value, index) => {\n    return index % 4 === 2 && value > 200; // Check for blue color in the text\n  });\n  expect(hasBlueText).toBe(true);\n});",
    "i3_llama-3.3-70b-versatile": "it(\"should render the PDF with font fallback on nodejslegacy build\", async () => {\n  const { getDocument } = await import('../../src/display/api.js');\n  const { buildGetDocumentParams } = await import('./test_utils.js');\n  const loadingTask = getDocument(buildGetDocumentParams('issue19234.pdf'));\n  const pdfDocument = await loadingTask.promise;\n  const pdfPage = await pdfDocument.getPage(1);\n  const image = await pdfPage.render({\n    canvasContext: null,\n    viewport: pdfPage.getViewport({ scale: 1 }),\n  });\n  const expectedText = \"1040\";\n  const actualText = await pdfPage.getTextContent();\n  const textItems = actualText.items;\n  let found = false;\n  for (let i = 0; i < textItems.length; i++) {\n    if (textItems[i].str === expectedText) {\n      found = true;\n      break;\n    }\n  }\n  expect(found).toBe(true);\n});",
    "i4_deepseek-r1-distill-llama-70b": "it(\"should render text using font fallback when HelveticaLTStd is requested\", async () => {\n  const { getDocument } = await import('../../src/display/api.js');\n  const { buildGetDocumentParams } = await import('./test_utils.js');\n\n  const loadingTask = getDocument(buildGetDocumentParams('issue19234.pdf'));\n  const pdf = await loadingTask.promise;\n  const page = await pdf.getPage(1);\n  const canvas = document.createElement('canvas');\n  const context = canvas.getContext('2d');\n\n  await page.render({\n    canvasContext: context,\n    viewport: page.getViewport({ scale: 1 })\n  });\n\n  const textContent = await page.getTextContent();\n  expect(textContent.items.length).toBeGreaterThan(0);\n});",
    "i4_gpt-4o": "it(\"should render text correctly with font fallback\", async () => {\n  const { getDocument } = await import('../../src/display/api.js');\n  const { buildGetDocumentParams } = await import('./test_utils.js');\n  const loadingTask = getDocument(buildGetDocumentParams('issue19234.pdf'));\n  const pdfDocument = await loadingTask.promise;\n  const page = await pdfDocument.getPage(1);\n  const viewport = page.getViewport({ scale: 1.0 });\n  const canvasFactory = new (await import('../../src/display/canvas_factory.js')).DOMCanvasFactory();\n  const canvasAndContext = canvasFactory.create(viewport.width, viewport.height);\n  const renderContext = {\n    canvasContext: canvasAndContext.context,\n    viewport: viewport,\n  };\n  await page.render(renderContext).promise;\n  const imageData = canvasAndContext.context.getImageData(0, 0, viewport.width, viewport.height);\n  const hasBlueText = Array.from(imageData.data).some((value, index) => {\n    return index % 4 === 2 && value > 200; // Check for blue color in the text\n  });\n  expect(hasBlueText).toBe(true);\n});",
    "i4_llama-3.3-70b-versatile": "it(\"should render the PDF with font fallback\", async () => {\n  const { getDocument } = await import('../../src/display/api.js');\n  const { buildGetDocumentParams } = await import('./test_utils.js');\n  const loadingTask = getDocument(buildGetDocumentParams('issue19234.pdf'));\n  const pdfDocument = await loadingTask.promise;\n  const pdfPage = await pdfDocument.getPage(1);\n  const image = await pdfPage.render({\n    viewport: pdfPage.getViewport({ scale: 1 }),\n    intent: 'print',\n  });\n  const expectedText = 'Tax Form';\n  const actualText = await pdfPage.getTextContent();\n  expect(actualText.items.some(item => item.str.includes(expectedText))).toBe(true);\n});",
    "i5_deepseek-r1-distill-llama-70b": "it(\"should correctly render text with font fallback for HelveticaLTStd\", async () => {\n  const { getDocument } = await import('../../src/display/api.js');\n  const { buildGetDocumentParams } = await import('./test_utils.js');\n\n  const loadingTask = getDocument(buildGetDocumentParams('issue19234.pdf'));\n  const pdf = await loadingTask.promise;\n  const page = await pdf.getPage(1);\n  const textContent = await page.getTextContent();\n\n  const expectedText = \"If you need help with this tax form, go to IRS.gov.\";\n  const actualText = textContent.items.map(item => item.str).join('');\n\n  expect(actualText).toContain(expectedText);\n});",
    "i5_gpt-4o": "it(\"should render text correctly with font fallback\", async () => {\n  const { getDocument } = await import('../../src/display/api.js');\n  const { buildGetDocumentParams } = await import('./test_utils.js');\n  const loadingTask = getDocument(buildGetDocumentParams('issue19234.pdf'));\n  const pdfDocument = await loadingTask.promise;\n  const page = await pdfDocument.getPage(1);\n  const viewport = page.getViewport({ scale: 1.0 });\n  const canvasFactory = new (await import('../../src/display/canvas_factory.js')).DOMCanvasFactory();\n  const canvasAndContext = canvasFactory.create(viewport.width, viewport.height);\n  const renderContext = {\n    canvasContext: canvasAndContext.context,\n    viewport: viewport,\n  };\n  await page.render(renderContext).promise;\n  const imageData = canvasAndContext.context.getImageData(0, 0, viewport.width, viewport.height);\n  const hasBlueText = Array.from(imageData.data).some((value, index) => {\n    return index % 4 === 2 && value > 200; // Check for blue color in the text\n  });\n  expect(hasBlueText).toBe(true);\n});",
    "i5_llama-3.3-70b-versatile": "it(\"should render the PDF with font fallback\", async () => {\n  const { getDocument } = await import('../../src/display/api.js');\n  const { buildGetDocumentParams } = await import('./test_utils.js');\n  const loadingTask = getDocument(buildGetDocumentParams('issue19234.pdf'));\n  const pdfDoc = await loadingTask.promise;\n  const page = await pdfDoc.getPage(1);\n  const canvas = document.createElement('canvas');\n  const ctx = canvas.getContext('2d');\n  const renderTask = page.render({ canvasContext: ctx, viewport: page.getViewport({ scale: 1 }) });\n  await renderTask.promise;\n  const expectedText = \"Blue text should be visible\";\n  const actualText = await page.getTextContent();\n  const textItems = actualText.items;\n  let found = false;\n  for (let i = 0; i < textItems.length; i++) {\n    if (textItems[i].str === expectedText) {\n      found = true;\n      break;\n    }\n  }\n  expect(found).toBe(true);\n});"
  },
  "19262": {
    "i1_deepseek-r1-distill-llama-70b": "it(\"should throw an error when a nonnumber array is passed as fontMatrix\", async () => {\n  const { CompiledFont } = await import(\"../../src/core/font_renderer.js\");\n  // An invalid fontMatrix: not all elements are numbers.\n  const invalidMatrix = [1, 0, 0, \"maliciousCode\", 0, 0];\n  // Dummy glyph code that is non-empty and does not start with 14.\n  const sampleCode = [1, 2, 3];\n  const glyphId = 0;\n  let error = null;\n  try {\n    new CompiledFont(invalidMatrix).compileGlyph(sampleCode, glyphId);\n  } catch (ex) {\n    error = ex;\n  }\n  if (!error || !/Expected a valid fontMatrix/.test(error.message)) {\n    throw new Error(\"Test failed: Expected an error with 'Expected a valid fontMatrix' to be thrown.\");\n  }\n});\n",
    "i1_gpt-4o": "it(\"should throw an error when a nonnumber array is passed as fontMatrix\", async () => {\n  const { CompiledFont } = await import(\"../../src/core/font_renderer.js\");\n  // An invalid fontMatrix: not all elements are numbers.\n  const invalidMatrix = [1, 0, 0, \"maliciousCode\", 0, 0];\n  // Dummy glyph code that is non-empty and does not start with 14.\n  const sampleCode = [1, 2, 3];\n  const glyphId = 0;\n  let error = null;\n  try {\n    new CompiledFont(invalidMatrix).compileGlyph(sampleCode, glyphId);\n  } catch (ex) {\n    error = ex;\n  }\n  if (!error || !/Expected a valid fontMatrix/.test(error.message)) {\n    throw new Error(\"Test failed: Expected an error with 'Expected a valid fontMatrix' to be thrown.\");\n  }\n});\n",
    "i1_llama-3.3-70b-versatile": "it(\"should throw an error when a nonnumber array is passed as fontMatrix\", async () => {\n  const { CompiledFont } = await import(\"../../src/core/font_renderer.js\");\n  // An invalid fontMatrix: not all elements are numbers.\n  const invalidMatrix = [1, 0, 0, \"maliciousCode\", 0, 0];\n  // Dummy glyph code that is non-empty and does not start with 14.\n  const sampleCode = [1, 2, 3];\n  const glyphId = 0;\n  let error = null;\n  try {\n    new CompiledFont(invalidMatrix).compileGlyph(sampleCode, glyphId);\n  } catch (ex) {\n    error = ex;\n  }\n  if (!error || !/Expected a valid fontMatrix/.test(error.message)) {\n    throw new Error(\"Test failed: Expected an error with 'Expected a valid fontMatrix' to be thrown.\");\n  }\n});\n",
    "i1_MOCK": "it(\"should throw an error when a nonnumber array is passed as fontMatrix\", async () => {\n  const { CompiledFont } = await import(\"../../src/core/font_renderer.js\");\n  // An invalid fontMatrix: not all elements are numbers.\n  const invalidMatrix = [1, 0, 0, \"maliciousCode\", 0, 0];\n  // Dummy glyph code that is non-empty and does not start with 14.\n  const sampleCode = [1, 2, 3];\n  const glyphId = 0;\n  let error = null;\n  try {\n    new CompiledFont(invalidMatrix).compileGlyph(sampleCode, glyphId);\n  } catch (ex) {\n    error = ex;\n  }\n  if (!error || !/Expected a valid fontMatrix/.test(error.message)) {\n    throw new Error(\"Test failed: Expected an error with 'Expected a valid fontMatrix' to be thrown.\");\n  }\n});\n",
    "i2_deepseek-r1-distill-llama-70b": "it(\"should throw an error when a nonnumber array is passed as fontMatrix\", async () => {\n  const { CompiledFont } = await import(\"../../src/core/font_renderer.js\");\n  // An invalid fontMatrix: not all elements are numbers.\n  const invalidMatrix = [1, 0, 0, \"maliciousCode\", 0, 0];\n  // Dummy glyph code that is non-empty and does not start with 14.\n  const sampleCode = [1, 2, 3];\n  const glyphId = 0;\n  let error = null;\n  try {\n    new CompiledFont(invalidMatrix).compileGlyph(sampleCode, glyphId);\n  } catch (ex) {\n    error = ex;\n  }\n  if (!error || !/Expected a valid fontMatrix/.test(error.message)) {\n    throw new Error(\"Test failed: Expected an error with 'Expected a valid fontMatrix' to be thrown.\");\n  }\n});\n",
    "i2_gpt-4o": "it(\"should throw an error when a nonnumber array is passed as fontMatrix\", async () => {\n  const { CompiledFont } = await import(\"../../src/core/font_renderer.js\");\n  // An invalid fontMatrix: not all elements are numbers.\n  const invalidMatrix = [1, 0, 0, \"maliciousCode\", 0, 0];\n  // Dummy glyph code that is non-empty and does not start with 14.\n  const sampleCode = [1, 2, 3];\n  const glyphId = 0;\n  let error = null;\n  try {\n    new CompiledFont(invalidMatrix).compileGlyph(sampleCode, glyphId);\n  } catch (ex) {\n    error = ex;\n  }\n  if (!error || !/Expected a valid fontMatrix/.test(error.message)) {\n    throw new Error(\"Test failed: Expected an error with 'Expected a valid fontMatrix' to be thrown.\");\n  }\n});\n",
    "i2_llama-3.3-70b-versatile": "it(\"should throw an error when a nonnumber array is passed as fontMatrix\", async () => {\n  const { CompiledFont } = await import(\"../../src/core/font_renderer.js\");\n  // An invalid fontMatrix: not all elements are numbers.\n  const invalidMatrix = [1, 0, 0, \"maliciousCode\", 0, 0];\n  // Dummy glyph code that is non-empty and does not start with 14.\n  const sampleCode = [1, 2, 3];\n  const glyphId = 0;\n  let error = null;\n  try {\n    new CompiledFont(invalidMatrix).compileGlyph(sampleCode, glyphId);\n  } catch (ex) {\n    error = ex;\n  }\n  if (!error || !/Expected a valid fontMatrix/.test(error.message)) {\n    throw new Error(\"Test failed: Expected an error with 'Expected a valid fontMatrix' to be thrown.\");\n  }\n});\n",
    "i3_deepseek-r1-distill-llama-70b": "it(\"should throw an error when a nonnumber array is passed as fontMatrix\", async () => {\n  const { CompiledFont } = await import(\"../../src/core/font_renderer.js\");\n  // An invalid fontMatrix: not all elements are numbers.\n  const invalidMatrix = [1, 0, 0, \"maliciousCode\", 0, 0];\n  // Dummy glyph code that is non-empty and does not start with 14.\n  const sampleCode = [1, 2, 3];\n  const glyphId = 0;\n  let error = null;\n  try {\n    new CompiledFont(invalidMatrix).compileGlyph(sampleCode, glyphId);\n  } catch (ex) {\n    error = ex;\n  }\n  if (!error || !/Expected a valid fontMatrix/.test(error.message)) {\n    throw new Error(\"Test failed: Expected an error with 'Expected a valid fontMatrix' to be thrown.\");\n  }\n});\n",
    "i3_gpt-4o": "it(\"should throw an error when a nonnumber array is passed as fontMatrix\", async () => {\n  const { CompiledFont } = await import(\"../../src/core/font_renderer.js\");\n  // An invalid fontMatrix: not all elements are numbers.\n  const invalidMatrix = [1, 0, 0, \"maliciousCode\", 0, 0];\n  // Dummy glyph code that is non-empty and does not start with 14.\n  const sampleCode = [1, 2, 3];\n  const glyphId = 0;\n  let error = null;\n  try {\n    new CompiledFont(invalidMatrix).compileGlyph(sampleCode, glyphId);\n  } catch (ex) {\n    error = ex;\n  }\n  if (!error || !/Expected a valid fontMatrix/.test(error.message)) {\n    throw new Error(\"Test failed: Expected an error with 'Expected a valid fontMatrix' to be thrown.\");\n  }\n});\n",
    "i3_llama-3.3-70b-versatile": "it(\"should throw an error when a nonnumber array is passed as fontMatrix\", async () => {\n  const { CompiledFont } = await import(\"../../src/core/font_renderer.js\");\n  // An invalid fontMatrix: not all elements are numbers.\n  const invalidMatrix = [1, 0, 0, \"maliciousCode\", 0, 0];\n  // Dummy glyph code that is non-empty and does not start with 14.\n  const sampleCode = [1, 2, 3];\n  const glyphId = 0;\n  let error = null;\n  try {\n    new CompiledFont(invalidMatrix).compileGlyph(sampleCode, glyphId);\n  } catch (ex) {\n    error = ex;\n  }\n  if (!error || !/Expected a valid fontMatrix/.test(error.message)) {\n    throw new Error(\"Test failed: Expected an error with 'Expected a valid fontMatrix' to be thrown.\");\n  }\n});\n",
    "i4_deepseek-r1-distill-llama-70b": "it(\"should throw an error when a nonnumber array is passed as fontMatrix\", async () => {\n  const { CompiledFont } = await import(\"../../src/core/font_renderer.js\");\n  // An invalid fontMatrix: not all elements are numbers.\n  const invalidMatrix = [1, 0, 0, \"maliciousCode\", 0, 0];\n  // Dummy glyph code that is non-empty and does not start with 14.\n  const sampleCode = [1, 2, 3];\n  const glyphId = 0;\n  let error = null;\n  try {\n    new CompiledFont(invalidMatrix).compileGlyph(sampleCode, glyphId);\n  } catch (ex) {\n    error = ex;\n  }\n  if (!error || !/Expected a valid fontMatrix/.test(error.message)) {\n    throw new Error(\"Test failed: Expected an error with 'Expected a valid fontMatrix' to be thrown.\");\n  }\n});\n",
    "i4_gpt-4o": "it(\"should throw an error when a nonnumber array is passed as fontMatrix\", async () => {\n  const { CompiledFont } = await import(\"../../src/core/font_renderer.js\");\n  // An invalid fontMatrix: not all elements are numbers.\n  const invalidMatrix = [1, 0, 0, \"maliciousCode\", 0, 0];\n  // Dummy glyph code that is non-empty and does not start with 14.\n  const sampleCode = [1, 2, 3];\n  const glyphId = 0;\n  let error = null;\n  try {\n    new CompiledFont(invalidMatrix).compileGlyph(sampleCode, glyphId);\n  } catch (ex) {\n    error = ex;\n  }\n  if (!error || !/Expected a valid fontMatrix/.test(error.message)) {\n    throw new Error(\"Test failed: Expected an error with 'Expected a valid fontMatrix' to be thrown.\");\n  }\n});\n",
    "i4_llama-3.3-70b-versatile": "it(\"should throw an error when a nonnumber array is passed as fontMatrix\", async () => {\n  const { CompiledFont } = await import(\"../../src/core/font_renderer.js\");\n  // An invalid fontMatrix: not all elements are numbers.\n  const invalidMatrix = [1, 0, 0, \"maliciousCode\", 0, 0];\n  // Dummy glyph code that is non-empty and does not start with 14.\n  const sampleCode = [1, 2, 3];\n  const glyphId = 0;\n  let error = null;\n  try {\n    new CompiledFont(invalidMatrix).compileGlyph(sampleCode, glyphId);\n  } catch (ex) {\n    error = ex;\n  }\n  if (!error || !/Expected a valid fontMatrix/.test(error.message)) {\n    throw new Error(\"Test failed: Expected an error with 'Expected a valid fontMatrix' to be thrown.\");\n  }\n});\n",
    "i5_deepseek-r1-distill-llama-70b": "it(\"should throw an error when a nonnumber array is passed as fontMatrix\", async () => {\n  const { CompiledFont } = await import(\"../../src/core/font_renderer.js\");\n  // An invalid fontMatrix: not all elements are numbers.\n  const invalidMatrix = [1, 0, 0, \"maliciousCode\", 0, 0];\n  // Dummy glyph code that is non-empty and does not start with 14.\n  const sampleCode = [1, 2, 3];\n  const glyphId = 0;\n  let error = null;\n  try {\n    new CompiledFont(invalidMatrix).compileGlyph(sampleCode, glyphId);\n  } catch (ex) {\n    error = ex;\n  }\n  if (!error || !/Expected a valid fontMatrix/.test(error.message)) {\n    throw new Error(\"Test failed: Expected an error with 'Expected a valid fontMatrix' to be thrown.\");\n  }\n});\n",
    "i5_gpt-4o": "it(\"should throw an error when a nonnumber array is passed as fontMatrix\", async () => {\n  const { CompiledFont } = await import(\"../../src/core/font_renderer.js\");\n  // An invalid fontMatrix: not all elements are numbers.\n  const invalidMatrix = [1, 0, 0, \"maliciousCode\", 0, 0];\n  // Dummy glyph code that is non-empty and does not start with 14.\n  const sampleCode = [1, 2, 3];\n  const glyphId = 0;\n  let error = null;\n  try {\n    new CompiledFont(invalidMatrix).compileGlyph(sampleCode, glyphId);\n  } catch (ex) {\n    error = ex;\n  }\n  if (!error || !/Expected a valid fontMatrix/.test(error.message)) {\n    throw new Error(\"Test failed: Expected an error with 'Expected a valid fontMatrix' to be thrown.\");\n  }\n});\n",
    "i5_llama-3.3-70b-versatile": "it(\"should throw an error when a nonnumber array is passed as fontMatrix\", async () => {\n  const { CompiledFont } = await import(\"../../src/core/font_renderer.js\");\n  // An invalid fontMatrix: not all elements are numbers.\n  const invalidMatrix = [1, 0, 0, \"maliciousCode\", 0, 0];\n  // Dummy glyph code that is non-empty and does not start with 14.\n  const sampleCode = [1, 2, 3];\n  const glyphId = 0;\n  let error = null;\n  try {\n    new CompiledFont(invalidMatrix).compileGlyph(sampleCode, glyphId);\n  } catch (ex) {\n    error = ex;\n  }\n  if (!error || !/Expected a valid fontMatrix/.test(error.message)) {\n    throw new Error(\"Test failed: Expected an error with 'Expected a valid fontMatrix' to be thrown.\");\n  }\n});\n"
  },
  "19305": {
    "i1_deepseek-r1-distill-llama-70b": "it(\"should correctly extract bbox and background for MeshShadingPattern\", async () => {\n  const { MeshShadingPattern } = await import(\"../../src/display/pattern_helper.js\");\n  const IR = [null, null, \"coords\", \"colors\", \"figures\", \"bounds\", \"expected_bbox\", \"expected_background\"];\n  const pattern = new MeshShadingPattern(IR);\n  expect(pattern._bbox).toEqual(\"expected_bbox\");\n  expect(pattern._background).toEqual(\"expected_background\");\n});",
    "i1_gpt-4o": "it(\"should correctly extract bbox and background for MeshShadingPattern\", async () => {\n  const { MeshShadingPattern } = await import(\"../../src/display/pattern_helper.js\");\n  const IR = [null, null, \"coords\", \"colors\", \"figures\", \"bounds\", \"expected_bbox\", \"expected_background\"];\n  const pattern = new MeshShadingPattern(IR);\n  expect(pattern._bbox).toEqual(\"expected_bbox\");\n  expect(pattern._background).toEqual(\"expected_background\");\n});",
    "i1_llama-3.3-70b-versatile": "it(\"should correctly extract bbox and background for MeshShadingPattern\", async () => {\n  const { MeshShadingPattern } = await import(\"../../src/display/pattern_helper.js\");\n  const IR = [null, null, \"coords\", \"colors\", \"figures\", \"bounds\", \"expected_bbox\", \"expected_background\"];\n  const pattern = new MeshShadingPattern(IR);\n  expect(pattern._bbox).toEqual(\"expected_bbox\");\n  expect(pattern._background).toEqual(\"expected_background\");\n});",
    "i1_MOCK": "it(\"should correctly extract bbox and background for MeshShadingPattern\", async () => {\n  const { MeshShadingPattern } = await import(\"../../src/display/pattern_helper.js\");\n  const IR = [null, null, \"coords\", \"colors\", \"figures\", \"bounds\", \"expected_bbox\", \"expected_background\"];\n  const pattern = new MeshShadingPattern(IR);\n  expect(pattern._bbox).toEqual(\"expected_bbox\");\n  expect(pattern._background).toEqual(\"expected_background\");\n});",
    "i2_deepseek-r1-distill-llama-70b": "it(\"should correctly extract bbox and background for MeshShadingPattern\", async () => {\n  const { MeshShadingPattern } = await import(\"../../src/display/pattern_helper.js\");\n  const IR = [null, null, \"coords\", \"colors\", \"figures\", \"bounds\", \"expected_bbox\", \"expected_background\"];\n  const pattern = new MeshShadingPattern(IR);\n  expect(pattern._bbox).toEqual(\"expected_bbox\");\n  expect(pattern._background).toEqual(\"expected_background\");\n});",
    "i2_gpt-4o": "it(\"should correctly extract bbox and background for MeshShadingPattern\", async () => {\n  const { MeshShadingPattern } = await import(\"../../src/display/pattern_helper.js\");\n  const IR = [null, null, \"coords\", \"colors\", \"figures\", \"bounds\", \"expected_bbox\", \"expected_background\"];\n  const pattern = new MeshShadingPattern(IR);\n  expect(pattern._bbox).toEqual(\"expected_bbox\");\n  expect(pattern._background).toEqual(\"expected_background\");\n});",
    "i2_llama-3.3-70b-versatile": "it(\"should correctly extract bbox and background for MeshShadingPattern\", async () => {\n  const { MeshShadingPattern } = await import(\"../../src/display/pattern_helper.js\");\n  const IR = [null, null, \"coords\", \"colors\", \"figures\", \"bounds\", \"expected_bbox\", \"expected_background\"];\n  const pattern = new MeshShadingPattern(IR);\n  expect(pattern._bbox).toEqual(\"expected_bbox\");\n  expect(pattern._background).toEqual(\"expected_background\");\n});",
    "i3_deepseek-r1-distill-llama-70b": "it(\"should correctly extract bbox and background for MeshShadingPattern\", async () => {\n  const { MeshShadingPattern } = await import(\"../../src/display/pattern_helper.js\");\n  const IR = [null, null, \"coords\", \"colors\", \"figures\", \"bounds\", \"expected_bbox\", \"expected_background\"];\n  const pattern = new MeshShadingPattern(IR);\n  expect(pattern._bbox).toEqual(\"expected_bbox\");\n  expect(pattern._background).toEqual(\"expected_background\");\n});",
    "i3_gpt-4o": "it(\"should correctly extract bbox and background for MeshShadingPattern\", async () => {\n  const { MeshShadingPattern } = await import(\"../../src/display/pattern_helper.js\");\n  const IR = [null, null, \"coords\", \"colors\", \"figures\", \"bounds\", \"expected_bbox\", \"expected_background\"];\n  const pattern = new MeshShadingPattern(IR);\n  expect(pattern._bbox).toEqual(\"expected_bbox\");\n  expect(pattern._background).toEqual(\"expected_background\");\n});",
    "i3_llama-3.3-70b-versatile": "it(\"should correctly extract bbox and background for MeshShadingPattern\", async () => {\n  const { MeshShadingPattern } = await import(\"../../src/display/pattern_helper.js\");\n  const IR = [null, null, \"coords\", \"colors\", \"figures\", \"bounds\", \"expected_bbox\", \"expected_background\"];\n  const pattern = new MeshShadingPattern(IR);\n  expect(pattern._bbox).toEqual(\"expected_bbox\");\n  expect(pattern._background).toEqual(\"expected_background\");\n});",
    "i4_deepseek-r1-distill-llama-70b": "it(\"should correctly extract bbox and background for MeshShadingPattern\", async () => {\n  const { MeshShadingPattern } = await import(\"../../src/display/pattern_helper.js\");\n  const IR = [null, null, \"coords\", \"colors\", \"figures\", \"bounds\", \"expected_bbox\", \"expected_background\"];\n  const pattern = new MeshShadingPattern(IR);\n  expect(pattern._bbox).toEqual(\"expected_bbox\");\n  expect(pattern._background).toEqual(\"expected_background\");\n});",
    "i4_gpt-4o": "it(\"should correctly extract bbox and background for MeshShadingPattern\", async () => {\n  const { MeshShadingPattern } = await import(\"../../src/display/pattern_helper.js\");\n  const IR = [null, null, \"coords\", \"colors\", \"figures\", \"bounds\", \"expected_bbox\", \"expected_background\"];\n  const pattern = new MeshShadingPattern(IR);\n  expect(pattern._bbox).toEqual(\"expected_bbox\");\n  expect(pattern._background).toEqual(\"expected_background\");\n});",
    "i4_llama-3.3-70b-versatile": "it(\"should correctly extract bbox and background for MeshShadingPattern\", async () => {\n  const { MeshShadingPattern } = await import(\"../../src/display/pattern_helper.js\");\n  const IR = [null, null, \"coords\", \"colors\", \"figures\", \"bounds\", \"expected_bbox\", \"expected_background\"];\n  const pattern = new MeshShadingPattern(IR);\n  expect(pattern._bbox).toEqual(\"expected_bbox\");\n  expect(pattern._background).toEqual(\"expected_background\");\n});",
    "i5_deepseek-r1-distill-llama-70b": "it(\"should correctly extract bbox and background for MeshShadingPattern\", async () => {\n  const { MeshShadingPattern } = await import(\"../../src/display/pattern_helper.js\");\n  const IR = [null, null, \"coords\", \"colors\", \"figures\", \"bounds\", \"expected_bbox\", \"expected_background\"];\n  const pattern = new MeshShadingPattern(IR);\n  expect(pattern._bbox).toEqual(\"expected_bbox\");\n  expect(pattern._background).toEqual(\"expected_background\");\n});",
    "i5_gpt-4o": "it(\"should correctly extract bbox and background for MeshShadingPattern\", async () => {\n  const { MeshShadingPattern } = await import(\"../../src/display/pattern_helper.js\");\n  const IR = [null, null, \"coords\", \"colors\", \"figures\", \"bounds\", \"expected_bbox\", \"expected_background\"];\n  const pattern = new MeshShadingPattern(IR);\n  expect(pattern._bbox).toEqual(\"expected_bbox\");\n  expect(pattern._background).toEqual(\"expected_background\");\n});",
    "i5_llama-3.3-70b-versatile": "it(\"should correctly extract bbox and background for MeshShadingPattern\", async () => {\n  const { MeshShadingPattern } = await import(\"../../src/display/pattern_helper.js\");\n  const IR = [null, null, \"coords\", \"colors\", \"figures\", \"bounds\", \"expected_bbox\", \"expected_background\"];\n  const pattern = new MeshShadingPattern(IR);\n  expect(pattern._bbox).toEqual(\"expected_bbox\");\n  expect(pattern._background).toEqual(\"expected_background\");\n});"
  },
  "19321": {
    "i1_deepseek-r1-distill-llama-70b": "it(\"should render all pages of a PDF with duplicate font mappings\", async () => {\n  const pdfDoc = await getDocument({ url: `${TEST_PDFS_PATH}/2023-ESG-report-eng.pdf` }).promise;\n  assert(pdfDoc.numPages > 1, \"Expected PDF to have more than one page\");\n});",
    "i1_gpt-4o": "it(\"should render all pages of a PDF with duplicate font mappings\", async () => {\n  const pdfDoc = await getDocument({ url: `${TEST_PDFS_PATH}/2023-ESG-report-eng.pdf` }).promise;\n  assert(pdfDoc.numPages > 1, \"Expected PDF to have more than one page\");\n});",
    "i1_llama-3.3-70b-versatile": "it(\"should render all pages of a PDF with duplicate font mappings\", async () => {\n  const pdfDoc = await getDocument({ url: `${TEST_PDFS_PATH}/2023-ESG-report-eng.pdf` }).promise;\n  assert(pdfDoc.numPages > 1, \"Expected PDF to have more than one page\");\n});",
    "i1_MOCK": "it(\"should render all pages of a PDF with duplicate font mappings\", async () => {\n  const pdfDoc = await getDocument({ url: `${TEST_PDFS_PATH}/2023-ESG-report-eng.pdf` }).promise;\n  assert(pdfDoc.numPages > 1, \"Expected PDF to have more than one page\");\n});",
    "i2_deepseek-r1-distill-llama-70b": "it(\"should render all pages of a PDF with duplicate font mappings\", async () => {\n  const pdfDoc = await getDocument({ url: `${TEST_PDFS_PATH}/2023-ESG-report-eng.pdf` }).promise;\n  assert(pdfDoc.numPages > 1, \"Expected PDF to have more than one page\");\n});",
    "i2_gpt-4o": "it(\"should render all pages of a PDF with duplicate font mappings\", async () => {\n  const pdfDoc = await getDocument({ url: `${TEST_PDFS_PATH}/2023-ESG-report-eng.pdf` }).promise;\n  assert(pdfDoc.numPages > 1, \"Expected PDF to have more than one page\");\n});",
    "i2_llama-3.3-70b-versatile": "it(\"should render all pages of a PDF with duplicate font mappings\", async () => {\n  const pdfDoc = await getDocument({ url: `${TEST_PDFS_PATH}/2023-ESG-report-eng.pdf` }).promise;\n  assert(pdfDoc.numPages > 1, \"Expected PDF to have more than one page\");\n});",
    "i3_deepseek-r1-distill-llama-70b": "it(\"should render all pages of a PDF with duplicate font mappings\", async () => {\n  const pdfDoc = await getDocument({ url: `${TEST_PDFS_PATH}/2023-ESG-report-eng.pdf` }).promise;\n  assert(pdfDoc.numPages > 1, \"Expected PDF to have more than one page\");\n});",
    "i3_gpt-4o": "it(\"should render all pages of a PDF with duplicate font mappings\", async () => {\n  const pdfDoc = await getDocument({ url: `${TEST_PDFS_PATH}/2023-ESG-report-eng.pdf` }).promise;\n  assert(pdfDoc.numPages > 1, \"Expected PDF to have more than one page\");\n});",
    "i3_llama-3.3-70b-versatile": "it(\"should render all pages of a PDF with duplicate font mappings\", async () => {\n  const pdfDoc = await getDocument({ url: `${TEST_PDFS_PATH}/2023-ESG-report-eng.pdf` }).promise;\n  assert(pdfDoc.numPages > 1, \"Expected PDF to have more than one page\");\n});",
    "i4_deepseek-r1-distill-llama-70b": "it(\"should render all pages of a PDF with duplicate font mappings\", async () => {\n  const pdfDoc = await getDocument({ url: `${TEST_PDFS_PATH}/2023-ESG-report-eng.pdf` }).promise;\n  assert(pdfDoc.numPages > 1, \"Expected PDF to have more than one page\");\n});",
    "i4_gpt-4o": "it(\"should render all pages of a PDF with duplicate font mappings\", async () => {\n  const pdfDoc = await getDocument({ url: `${TEST_PDFS_PATH}/2023-ESG-report-eng.pdf` }).promise;\n  assert(pdfDoc.numPages > 1, \"Expected PDF to have more than one page\");\n});",
    "i4_llama-3.3-70b-versatile": "it(\"should render all pages of a PDF with duplicate font mappings\", async () => {\n  const pdfDoc = await getDocument({ url: `${TEST_PDFS_PATH}/2023-ESG-report-eng.pdf` }).promise;\n  assert(pdfDoc.numPages > 1, \"Expected PDF to have more than one page\");\n});",
    "i5_deepseek-r1-distill-llama-70b": "it(\"should render all pages of a PDF with duplicate font mappings\", async () => {\n  const pdfDoc = await getDocument({ url: `${TEST_PDFS_PATH}/2023-ESG-report-eng.pdf` }).promise;\n  assert(pdfDoc.numPages > 1, \"Expected PDF to have more than one page\");\n});",
    "i5_gpt-4o": "it(\"should render all pages of a PDF with duplicate font mappings\", async () => {\n  const pdfDoc = await getDocument({ url: `${TEST_PDFS_PATH}/2023-ESG-report-eng.pdf` }).promise;\n  assert(pdfDoc.numPages > 1, \"Expected PDF to have more than one page\");\n});",
    "i5_llama-3.3-70b-versatile": "it(\"should render all pages of a PDF with duplicate font mappings\", async () => {\n  const pdfDoc = await getDocument({ url: `${TEST_PDFS_PATH}/2023-ESG-report-eng.pdf` }).promise;\n  assert(pdfDoc.numPages > 1, \"Expected PDF to have more than one page\");\n});"
  },
  "19327": {
    "i1_deepseek-r1-distill-llama-70b": "it(\"should set jpxDecoderOptions.numComponents correctly for JPXDecode images\", async () => {\n  const { PDFImage } = await import(\"../../src/core/image.js\");\n  const { Name } = await import(\"../../src/core/primitives.js\");\n  const { PDFFunctionFactory } = await import(\"../../src/core/function.js\");\n  const { JpxImage } = await import(\"../../src/core/jpx.js\");\n  const originalParse = JpxImage.parseImageProperties;\n  JpxImage.parseImageProperties = () => ({\n    width: 100,\n    height: 100,\n    componentsCount: 3,\n    bitsPerComponent: 8,\n  });\n  const fakeStream = { reset() {} };\n  const fakeDict = {\n    get(key) {\n      if (key === \"F\") return new Name(\"JPXDecode\");\n      if (key === \"W\") return 100;\n      if (key === \"H\") return 100;\n      if (key === \"I\") return false;\n      if (key === \"IM\") return false;\n    },\n    getRaw(key) {\n      if (key === \"CS\") return new Name(\"DeviceRGB\");\n    },\n    has(key) {\n      if (key === \"SMaskInData\") return false;\n      return false;\n    },\n  };\n  const fakeImage = { dict: fakeDict, stream: fakeStream, bitsPerComponent: null };\n  const pdfImage = new PDFImage({\n    xref: {},\n    res: {},\n    image: fakeImage,\n    pdfFunctionFactory: new PDFFunctionFactory(),\n    localColorSpaceCache: {},\n  });\n  JpxImage.parseImageProperties = originalParse;\n  if (!pdfImage.jpxDecoderOptions) {\n    throw new Error(\"jpxDecoderOptions is not defined\");\n  }\n  if (pdfImage.jpxDecoderOptions.numComponents !== 3) {\n    throw new Error(\n      `Expected jpxDecoderOptions.numComponents to be 3 but got ${pdfImage.jpxDecoderOptions.numComponents}`\n    );\n  }\n});",
    "i1_gpt-4o": "it(\"should set jpxDecoderOptions.numComponents correctly for JPXDecode images\", async () => {\n  const { PDFImage } = await import(\"../../src/core/image.js\");\n  const { Name } = await import(\"../../src/core/primitives.js\");\n  const { PDFFunctionFactory } = await import(\"../../src/core/function.js\");\n  const { JpxImage } = await import(\"../../src/core/jpx.js\");\n  const originalParse = JpxImage.parseImageProperties;\n  JpxImage.parseImageProperties = () => ({\n    width: 100,\n    height: 100,\n    componentsCount: 3,\n    bitsPerComponent: 8,\n  });\n  const fakeStream = { reset() {} };\n  const fakeDict = {\n    get(key) {\n      if (key === \"F\") return new Name(\"JPXDecode\");\n      if (key === \"W\") return 100;\n      if (key === \"H\") return 100;\n      if (key === \"I\") return false;\n      if (key === \"IM\") return false;\n    },\n    getRaw(key) {\n      if (key === \"CS\") return new Name(\"DeviceRGB\");\n    },\n    has(key) {\n      if (key === \"SMaskInData\") return false;\n      return false;\n    },\n  };\n  const fakeImage = { dict: fakeDict, stream: fakeStream, bitsPerComponent: null };\n  const pdfImage = new PDFImage({\n    xref: {},\n    res: {},\n    image: fakeImage,\n    pdfFunctionFactory: new PDFFunctionFactory(),\n    localColorSpaceCache: {},\n  });\n  JpxImage.parseImageProperties = originalParse;\n  if (!pdfImage.jpxDecoderOptions) {\n    throw new Error(\"jpxDecoderOptions is not defined\");\n  }\n  if (pdfImage.jpxDecoderOptions.numComponents !== 3) {\n    throw new Error(\n      `Expected jpxDecoderOptions.numComponents to be 3 but got ${pdfImage.jpxDecoderOptions.numComponents}`\n    );\n  }\n});",
    "i1_llama-3.3-70b-versatile": "it(\"should set jpxDecoderOptions.numComponents correctly for JPXDecode images\", async () => {\n  const { PDFImage } = await import(\"../../src/core/image.js\");\n  const { Name } = await import(\"../../src/core/primitives.js\");\n  const { PDFFunctionFactory } = await import(\"../../src/core/function.js\");\n  const { JpxImage } = await import(\"../../src/core/jpx.js\");\n  const originalParse = JpxImage.parseImageProperties;\n  JpxImage.parseImageProperties = () => ({\n    width: 100,\n    height: 100,\n    componentsCount: 3,\n    bitsPerComponent: 8,\n  });\n  const fakeStream = { reset() {} };\n  const fakeDict = {\n    get(key) {\n      if (key === \"F\") return new Name(\"JPXDecode\");\n      if (key === \"W\") return 100;\n      if (key === \"H\") return 100;\n      if (key === \"I\") return false;\n      if (key === \"IM\") return false;\n    },\n    getRaw(key) {\n      if (key === \"CS\") return new Name(\"DeviceRGB\");\n    },\n    has(key) {\n      if (key === \"SMaskInData\") return false;\n      return false;\n    },\n  };\n  const fakeImage = { dict: fakeDict, stream: fakeStream, bitsPerComponent: null };\n  const pdfImage = new PDFImage({\n    xref: {},\n    res: {},\n    image: fakeImage,\n    pdfFunctionFactory: new PDFFunctionFactory(),\n    localColorSpaceCache: {},\n  });\n  JpxImage.parseImageProperties = originalParse;\n  if (!pdfImage.jpxDecoderOptions) {\n    throw new Error(\"jpxDecoderOptions is not defined\");\n  }\n  if (pdfImage.jpxDecoderOptions.numComponents !== 3) {\n    throw new Error(\n      `Expected jpxDecoderOptions.numComponents to be 3 but got ${pdfImage.jpxDecoderOptions.numComponents}`\n    );\n  }\n});",
    "i1_MOCK": "it(\"should set jpxDecoderOptions.numComponents correctly for JPXDecode images\", async () => {\n  const { PDFImage } = await import(\"../../src/core/image.js\");\n  const { Name } = await import(\"../../src/core/primitives.js\");\n  const { PDFFunctionFactory } = await import(\"../../src/core/function.js\");\n  const { JpxImage } = await import(\"../../src/core/jpx.js\");\n  const originalParse = JpxImage.parseImageProperties;\n  JpxImage.parseImageProperties = () => ({\n    width: 100,\n    height: 100,\n    componentsCount: 3,\n    bitsPerComponent: 8,\n  });\n  const fakeStream = { reset() {} };\n  const fakeDict = {\n    get(key) {\n      if (key === \"F\") return new Name(\"JPXDecode\");\n      if (key === \"W\") return 100;\n      if (key === \"H\") return 100;\n      if (key === \"I\") return false;\n      if (key === \"IM\") return false;\n    },\n    getRaw(key) {\n      if (key === \"CS\") return new Name(\"DeviceRGB\");\n    },\n    has(key) {\n      if (key === \"SMaskInData\") return false;\n      return false;\n    },\n  };\n  const fakeImage = { dict: fakeDict, stream: fakeStream, bitsPerComponent: null };\n  const pdfImage = new PDFImage({\n    xref: {},\n    res: {},\n    image: fakeImage,\n    pdfFunctionFactory: new PDFFunctionFactory(),\n    localColorSpaceCache: {},\n  });\n  JpxImage.parseImageProperties = originalParse;\n  if (!pdfImage.jpxDecoderOptions) {\n    throw new Error(\"jpxDecoderOptions is not defined\");\n  }\n  if (pdfImage.jpxDecoderOptions.numComponents !== 3) {\n    throw new Error(\n      `Expected jpxDecoderOptions.numComponents to be 3 but got ${pdfImage.jpxDecoderOptions.numComponents}`\n    );\n  }\n});",
    "i2_deepseek-r1-distill-llama-70b": "it(\"should set jpxDecoderOptions.numComponents correctly for JPXDecode images\", async () => {\n  const { PDFImage } = await import(\"../../src/core/image.js\");\n  const { Name } = await import(\"../../src/core/primitives.js\");\n  const { PDFFunctionFactory } = await import(\"../../src/core/function.js\");\n  const { JpxImage } = await import(\"../../src/core/jpx.js\");\n  const originalParse = JpxImage.parseImageProperties;\n  JpxImage.parseImageProperties = () => ({\n    width: 100,\n    height: 100,\n    componentsCount: 3,\n    bitsPerComponent: 8,\n  });\n  const fakeStream = { reset() {} };\n  const fakeDict = {\n    get(key) {\n      if (key === \"F\") return new Name(\"JPXDecode\");\n      if (key === \"W\") return 100;\n      if (key === \"H\") return 100;\n      if (key === \"I\") return false;\n      if (key === \"IM\") return false;\n    },\n    getRaw(key) {\n      if (key === \"CS\") return new Name(\"DeviceRGB\");\n    },\n    has(key) {\n      if (key === \"SMaskInData\") return false;\n      return false;\n    },\n  };\n  const fakeImage = { dict: fakeDict, stream: fakeStream, bitsPerComponent: null };\n  const pdfImage = new PDFImage({\n    xref: {},\n    res: {},\n    image: fakeImage,\n    pdfFunctionFactory: new PDFFunctionFactory(),\n    localColorSpaceCache: {},\n  });\n  JpxImage.parseImageProperties = originalParse;\n  if (!pdfImage.jpxDecoderOptions) {\n    throw new Error(\"jpxDecoderOptions is not defined\");\n  }\n  if (pdfImage.jpxDecoderOptions.numComponents !== 3) {\n    throw new Error(\n      `Expected jpxDecoderOptions.numComponents to be 3 but got ${pdfImage.jpxDecoderOptions.numComponents}`\n    );\n  }\n});",
    "i2_gpt-4o": "it(\"should set jpxDecoderOptions.numComponents correctly for JPXDecode images\", async () => {\n  const { PDFImage } = await import(\"../../src/core/image.js\");\n  const { Name } = await import(\"../../src/core/primitives.js\");\n  const { PDFFunctionFactory } = await import(\"../../src/core/function.js\");\n  const { JpxImage } = await import(\"../../src/core/jpx.js\");\n  const originalParse = JpxImage.parseImageProperties;\n  JpxImage.parseImageProperties = () => ({\n    width: 100,\n    height: 100,\n    componentsCount: 3,\n    bitsPerComponent: 8,\n  });\n  const fakeStream = { reset() {} };\n  const fakeDict = {\n    get(key) {\n      if (key === \"F\") return new Name(\"JPXDecode\");\n      if (key === \"W\") return 100;\n      if (key === \"H\") return 100;\n      if (key === \"I\") return false;\n      if (key === \"IM\") return false;\n    },\n    getRaw(key) {\n      if (key === \"CS\") return new Name(\"DeviceRGB\");\n    },\n    has(key) {\n      if (key === \"SMaskInData\") return false;\n      return false;\n    },\n  };\n  const fakeImage = { dict: fakeDict, stream: fakeStream, bitsPerComponent: null };\n  const pdfImage = new PDFImage({\n    xref: {},\n    res: {},\n    image: fakeImage,\n    pdfFunctionFactory: new PDFFunctionFactory(),\n    localColorSpaceCache: {},\n  });\n  JpxImage.parseImageProperties = originalParse;\n  if (!pdfImage.jpxDecoderOptions) {\n    throw new Error(\"jpxDecoderOptions is not defined\");\n  }\n  if (pdfImage.jpxDecoderOptions.numComponents !== 3) {\n    throw new Error(\n      `Expected jpxDecoderOptions.numComponents to be 3 but got ${pdfImage.jpxDecoderOptions.numComponents}`\n    );\n  }\n});",
    "i2_llama-3.3-70b-versatile": "it(\"should set jpxDecoderOptions.numComponents correctly for JPXDecode images\", async () => {\n  const { PDFImage } = await import(\"../../src/core/image.js\");\n  const { Name } = await import(\"../../src/core/primitives.js\");\n  const { PDFFunctionFactory } = await import(\"../../src/core/function.js\");\n  const { JpxImage } = await import(\"../../src/core/jpx.js\");\n  const originalParse = JpxImage.parseImageProperties;\n  JpxImage.parseImageProperties = () => ({\n    width: 100,\n    height: 100,\n    componentsCount: 3,\n    bitsPerComponent: 8,\n  });\n  const fakeStream = { reset() {} };\n  const fakeDict = {\n    get(key) {\n      if (key === \"F\") return new Name(\"JPXDecode\");\n      if (key === \"W\") return 100;\n      if (key === \"H\") return 100;\n      if (key === \"I\") return false;\n      if (key === \"IM\") return false;\n    },\n    getRaw(key) {\n      if (key === \"CS\") return new Name(\"DeviceRGB\");\n    },\n    has(key) {\n      if (key === \"SMaskInData\") return false;\n      return false;\n    },\n  };\n  const fakeImage = { dict: fakeDict, stream: fakeStream, bitsPerComponent: null };\n  const pdfImage = new PDFImage({\n    xref: {},\n    res: {},\n    image: fakeImage,\n    pdfFunctionFactory: new PDFFunctionFactory(),\n    localColorSpaceCache: {},\n  });\n  JpxImage.parseImageProperties = originalParse;\n  if (!pdfImage.jpxDecoderOptions) {\n    throw new Error(\"jpxDecoderOptions is not defined\");\n  }\n  if (pdfImage.jpxDecoderOptions.numComponents !== 3) {\n    throw new Error(\n      `Expected jpxDecoderOptions.numComponents to be 3 but got ${pdfImage.jpxDecoderOptions.numComponents}`\n    );\n  }\n});",
    "i3_deepseek-r1-distill-llama-70b": "it(\"should set jpxDecoderOptions.numComponents correctly for JPXDecode images\", async () => {\n  const { PDFImage } = await import(\"../../src/core/image.js\");\n  const { Name } = await import(\"../../src/core/primitives.js\");\n  const { PDFFunctionFactory } = await import(\"../../src/core/function.js\");\n  const { JpxImage } = await import(\"../../src/core/jpx.js\");\n  const originalParse = JpxImage.parseImageProperties;\n  JpxImage.parseImageProperties = () => ({\n    width: 100,\n    height: 100,\n    componentsCount: 3,\n    bitsPerComponent: 8,\n  });\n  const fakeStream = { reset() {} };\n  const fakeDict = {\n    get(key) {\n      if (key === \"F\") return new Name(\"JPXDecode\");\n      if (key === \"W\") return 100;\n      if (key === \"H\") return 100;\n      if (key === \"I\") return false;\n      if (key === \"IM\") return false;\n    },\n    getRaw(key) {\n      if (key === \"CS\") return new Name(\"DeviceRGB\");\n    },\n    has(key) {\n      if (key === \"SMaskInData\") return false;\n      return false;\n    },\n  };\n  const fakeImage = { dict: fakeDict, stream: fakeStream, bitsPerComponent: null };\n  const pdfImage = new PDFImage({\n    xref: {},\n    res: {},\n    image: fakeImage,\n    pdfFunctionFactory: new PDFFunctionFactory(),\n    localColorSpaceCache: {},\n  });\n  JpxImage.parseImageProperties = originalParse;\n  if (!pdfImage.jpxDecoderOptions) {\n    throw new Error(\"jpxDecoderOptions is not defined\");\n  }\n  if (pdfImage.jpxDecoderOptions.numComponents !== 3) {\n    throw new Error(\n      `Expected jpxDecoderOptions.numComponents to be 3 but got ${pdfImage.jpxDecoderOptions.numComponents}`\n    );\n  }\n});",
    "i3_gpt-4o": "it(\"should set jpxDecoderOptions.numComponents correctly for JPXDecode images\", async () => {\n  const { PDFImage } = await import(\"../../src/core/image.js\");\n  const { Name } = await import(\"../../src/core/primitives.js\");\n  const { PDFFunctionFactory } = await import(\"../../src/core/function.js\");\n  const { JpxImage } = await import(\"../../src/core/jpx.js\");\n  const originalParse = JpxImage.parseImageProperties;\n  JpxImage.parseImageProperties = () => ({\n    width: 100,\n    height: 100,\n    componentsCount: 3,\n    bitsPerComponent: 8,\n  });\n  const fakeStream = { reset() {} };\n  const fakeDict = {\n    get(key) {\n      if (key === \"F\") return new Name(\"JPXDecode\");\n      if (key === \"W\") return 100;\n      if (key === \"H\") return 100;\n      if (key === \"I\") return false;\n      if (key === \"IM\") return false;\n    },\n    getRaw(key) {\n      if (key === \"CS\") return new Name(\"DeviceRGB\");\n    },\n    has(key) {\n      if (key === \"SMaskInData\") return false;\n      return false;\n    },\n  };\n  const fakeImage = { dict: fakeDict, stream: fakeStream, bitsPerComponent: null };\n  const pdfImage = new PDFImage({\n    xref: {},\n    res: {},\n    image: fakeImage,\n    pdfFunctionFactory: new PDFFunctionFactory(),\n    localColorSpaceCache: {},\n  });\n  JpxImage.parseImageProperties = originalParse;\n  if (!pdfImage.jpxDecoderOptions) {\n    throw new Error(\"jpxDecoderOptions is not defined\");\n  }\n  if (pdfImage.jpxDecoderOptions.numComponents !== 3) {\n    throw new Error(\n      `Expected jpxDecoderOptions.numComponents to be 3 but got ${pdfImage.jpxDecoderOptions.numComponents}`\n    );\n  }\n});",
    "i3_llama-3.3-70b-versatile": "it(\"should set jpxDecoderOptions.numComponents correctly for JPXDecode images\", async () => {\n  const { PDFImage } = await import(\"../../src/core/image.js\");\n  const { Name } = await import(\"../../src/core/primitives.js\");\n  const { PDFFunctionFactory } = await import(\"../../src/core/function.js\");\n  const { JpxImage } = await import(\"../../src/core/jpx.js\");\n  const originalParse = JpxImage.parseImageProperties;\n  JpxImage.parseImageProperties = () => ({\n    width: 100,\n    height: 100,\n    componentsCount: 3,\n    bitsPerComponent: 8,\n  });\n  const fakeStream = { reset() {} };\n  const fakeDict = {\n    get(key) {\n      if (key === \"F\") return new Name(\"JPXDecode\");\n      if (key === \"W\") return 100;\n      if (key === \"H\") return 100;\n      if (key === \"I\") return false;\n      if (key === \"IM\") return false;\n    },\n    getRaw(key) {\n      if (key === \"CS\") return new Name(\"DeviceRGB\");\n    },\n    has(key) {\n      if (key === \"SMaskInData\") return false;\n      return false;\n    },\n  };\n  const fakeImage = { dict: fakeDict, stream: fakeStream, bitsPerComponent: null };\n  const pdfImage = new PDFImage({\n    xref: {},\n    res: {},\n    image: fakeImage,\n    pdfFunctionFactory: new PDFFunctionFactory(),\n    localColorSpaceCache: {},\n  });\n  JpxImage.parseImageProperties = originalParse;\n  if (!pdfImage.jpxDecoderOptions) {\n    throw new Error(\"jpxDecoderOptions is not defined\");\n  }\n  if (pdfImage.jpxDecoderOptions.numComponents !== 3) {\n    throw new Error(\n      `Expected jpxDecoderOptions.numComponents to be 3 but got ${pdfImage.jpxDecoderOptions.numComponents}`\n    );\n  }\n});",
    "i4_deepseek-r1-distill-llama-70b": "it(\"should set jpxDecoderOptions.numComponents correctly for JPXDecode images\", async () => {\n  const { PDFImage } = await import(\"../../src/core/image.js\");\n  const { Name } = await import(\"../../src/core/primitives.js\");\n  const { PDFFunctionFactory } = await import(\"../../src/core/function.js\");\n  const { JpxImage } = await import(\"../../src/core/jpx.js\");\n  const originalParse = JpxImage.parseImageProperties;\n  JpxImage.parseImageProperties = () => ({\n    width: 100,\n    height: 100,\n    componentsCount: 3,\n    bitsPerComponent: 8,\n  });\n  const fakeStream = { reset() {} };\n  const fakeDict = {\n    get(key) {\n      if (key === \"F\") return new Name(\"JPXDecode\");\n      if (key === \"W\") return 100;\n      if (key === \"H\") return 100;\n      if (key === \"I\") return false;\n      if (key === \"IM\") return false;\n    },\n    getRaw(key) {\n      if (key === \"CS\") return new Name(\"DeviceRGB\");\n    },\n    has(key) {\n      if (key === \"SMaskInData\") return false;\n      return false;\n    },\n  };\n  const fakeImage = { dict: fakeDict, stream: fakeStream, bitsPerComponent: null };\n  const pdfImage = new PDFImage({\n    xref: {},\n    res: {},\n    image: fakeImage,\n    pdfFunctionFactory: new PDFFunctionFactory(),\n    localColorSpaceCache: {},\n  });\n  JpxImage.parseImageProperties = originalParse;\n  if (!pdfImage.jpxDecoderOptions) {\n    throw new Error(\"jpxDecoderOptions is not defined\");\n  }\n  if (pdfImage.jpxDecoderOptions.numComponents !== 3) {\n    throw new Error(\n      `Expected jpxDecoderOptions.numComponents to be 3 but got ${pdfImage.jpxDecoderOptions.numComponents}`\n    );\n  }\n});",
    "i4_gpt-4o": "it(\"should set jpxDecoderOptions.numComponents correctly for JPXDecode images\", async () => {\n  const { PDFImage } = await import(\"../../src/core/image.js\");\n  const { Name } = await import(\"../../src/core/primitives.js\");\n  const { PDFFunctionFactory } = await import(\"../../src/core/function.js\");\n  const { JpxImage } = await import(\"../../src/core/jpx.js\");\n  const originalParse = JpxImage.parseImageProperties;\n  JpxImage.parseImageProperties = () => ({\n    width: 100,\n    height: 100,\n    componentsCount: 3,\n    bitsPerComponent: 8,\n  });\n  const fakeStream = { reset() {} };\n  const fakeDict = {\n    get(key) {\n      if (key === \"F\") return new Name(\"JPXDecode\");\n      if (key === \"W\") return 100;\n      if (key === \"H\") return 100;\n      if (key === \"I\") return false;\n      if (key === \"IM\") return false;\n    },\n    getRaw(key) {\n      if (key === \"CS\") return new Name(\"DeviceRGB\");\n    },\n    has(key) {\n      if (key === \"SMaskInData\") return false;\n      return false;\n    },\n  };\n  const fakeImage = { dict: fakeDict, stream: fakeStream, bitsPerComponent: null };\n  const pdfImage = new PDFImage({\n    xref: {},\n    res: {},\n    image: fakeImage,\n    pdfFunctionFactory: new PDFFunctionFactory(),\n    localColorSpaceCache: {},\n  });\n  JpxImage.parseImageProperties = originalParse;\n  if (!pdfImage.jpxDecoderOptions) {\n    throw new Error(\"jpxDecoderOptions is not defined\");\n  }\n  if (pdfImage.jpxDecoderOptions.numComponents !== 3) {\n    throw new Error(\n      `Expected jpxDecoderOptions.numComponents to be 3 but got ${pdfImage.jpxDecoderOptions.numComponents}`\n    );\n  }\n});",
    "i4_llama-3.3-70b-versatile": "it(\"should set jpxDecoderOptions.numComponents correctly for JPXDecode images\", async () => {\n  const { PDFImage } = await import(\"../../src/core/image.js\");\n  const { Name } = await import(\"../../src/core/primitives.js\");\n  const { PDFFunctionFactory } = await import(\"../../src/core/function.js\");\n  const { JpxImage } = await import(\"../../src/core/jpx.js\");\n  const originalParse = JpxImage.parseImageProperties;\n  JpxImage.parseImageProperties = () => ({\n    width: 100,\n    height: 100,\n    componentsCount: 3,\n    bitsPerComponent: 8,\n  });\n  const fakeStream = { reset() {} };\n  const fakeDict = {\n    get(key) {\n      if (key === \"F\") return new Name(\"JPXDecode\");\n      if (key === \"W\") return 100;\n      if (key === \"H\") return 100;\n      if (key === \"I\") return false;\n      if (key === \"IM\") return false;\n    },\n    getRaw(key) {\n      if (key === \"CS\") return new Name(\"DeviceRGB\");\n    },\n    has(key) {\n      if (key === \"SMaskInData\") return false;\n      return false;\n    },\n  };\n  const fakeImage = { dict: fakeDict, stream: fakeStream, bitsPerComponent: null };\n  const pdfImage = new PDFImage({\n    xref: {},\n    res: {},\n    image: fakeImage,\n    pdfFunctionFactory: new PDFFunctionFactory(),\n    localColorSpaceCache: {},\n  });\n  JpxImage.parseImageProperties = originalParse;\n  if (!pdfImage.jpxDecoderOptions) {\n    throw new Error(\"jpxDecoderOptions is not defined\");\n  }\n  if (pdfImage.jpxDecoderOptions.numComponents !== 3) {\n    throw new Error(\n      `Expected jpxDecoderOptions.numComponents to be 3 but got ${pdfImage.jpxDecoderOptions.numComponents}`\n    );\n  }\n});",
    "i5_deepseek-r1-distill-llama-70b": "it(\"should set jpxDecoderOptions.numComponents correctly for JPXDecode images\", async () => {\n  const { PDFImage } = await import(\"../../src/core/image.js\");\n  const { Name } = await import(\"../../src/core/primitives.js\");\n  const { PDFFunctionFactory } = await import(\"../../src/core/function.js\");\n  const { JpxImage } = await import(\"../../src/core/jpx.js\");\n  const originalParse = JpxImage.parseImageProperties;\n  JpxImage.parseImageProperties = () => ({\n    width: 100,\n    height: 100,\n    componentsCount: 3,\n    bitsPerComponent: 8,\n  });\n  const fakeStream = { reset() {} };\n  const fakeDict = {\n    get(key) {\n      if (key === \"F\") return new Name(\"JPXDecode\");\n      if (key === \"W\") return 100;\n      if (key === \"H\") return 100;\n      if (key === \"I\") return false;\n      if (key === \"IM\") return false;\n    },\n    getRaw(key) {\n      if (key === \"CS\") return new Name(\"DeviceRGB\");\n    },\n    has(key) {\n      if (key === \"SMaskInData\") return false;\n      return false;\n    },\n  };\n  const fakeImage = { dict: fakeDict, stream: fakeStream, bitsPerComponent: null };\n  const pdfImage = new PDFImage({\n    xref: {},\n    res: {},\n    image: fakeImage,\n    pdfFunctionFactory: new PDFFunctionFactory(),\n    localColorSpaceCache: {},\n  });\n  JpxImage.parseImageProperties = originalParse;\n  if (!pdfImage.jpxDecoderOptions) {\n    throw new Error(\"jpxDecoderOptions is not defined\");\n  }\n  if (pdfImage.jpxDecoderOptions.numComponents !== 3) {\n    throw new Error(\n      `Expected jpxDecoderOptions.numComponents to be 3 but got ${pdfImage.jpxDecoderOptions.numComponents}`\n    );\n  }\n});",
    "i5_gpt-4o": "it(\"should set jpxDecoderOptions.numComponents correctly for JPXDecode images\", async () => {\n  const { PDFImage } = await import(\"../../src/core/image.js\");\n  const { Name } = await import(\"../../src/core/primitives.js\");\n  const { PDFFunctionFactory } = await import(\"../../src/core/function.js\");\n  const { JpxImage } = await import(\"../../src/core/jpx.js\");\n  const originalParse = JpxImage.parseImageProperties;\n  JpxImage.parseImageProperties = () => ({\n    width: 100,\n    height: 100,\n    componentsCount: 3,\n    bitsPerComponent: 8,\n  });\n  const fakeStream = { reset() {} };\n  const fakeDict = {\n    get(key) {\n      if (key === \"F\") return new Name(\"JPXDecode\");\n      if (key === \"W\") return 100;\n      if (key === \"H\") return 100;\n      if (key === \"I\") return false;\n      if (key === \"IM\") return false;\n    },\n    getRaw(key) {\n      if (key === \"CS\") return new Name(\"DeviceRGB\");\n    },\n    has(key) {\n      if (key === \"SMaskInData\") return false;\n      return false;\n    },\n  };\n  const fakeImage = { dict: fakeDict, stream: fakeStream, bitsPerComponent: null };\n  const pdfImage = new PDFImage({\n    xref: {},\n    res: {},\n    image: fakeImage,\n    pdfFunctionFactory: new PDFFunctionFactory(),\n    localColorSpaceCache: {},\n  });\n  JpxImage.parseImageProperties = originalParse;\n  if (!pdfImage.jpxDecoderOptions) {\n    throw new Error(\"jpxDecoderOptions is not defined\");\n  }\n  if (pdfImage.jpxDecoderOptions.numComponents !== 3) {\n    throw new Error(\n      `Expected jpxDecoderOptions.numComponents to be 3 but got ${pdfImage.jpxDecoderOptions.numComponents}`\n    );\n  }\n});",
    "i5_llama-3.3-70b-versatile": "it(\"should set jpxDecoderOptions.numComponents correctly for JPXDecode images\", async () => {\n  const { PDFImage } = await import(\"../../src/core/image.js\");\n  const { Name } = await import(\"../../src/core/primitives.js\");\n  const { PDFFunctionFactory } = await import(\"../../src/core/function.js\");\n  const { JpxImage } = await import(\"../../src/core/jpx.js\");\n  const originalParse = JpxImage.parseImageProperties;\n  JpxImage.parseImageProperties = () => ({\n    width: 100,\n    height: 100,\n    componentsCount: 3,\n    bitsPerComponent: 8,\n  });\n  const fakeStream = { reset() {} };\n  const fakeDict = {\n    get(key) {\n      if (key === \"F\") return new Name(\"JPXDecode\");\n      if (key === \"W\") return 100;\n      if (key === \"H\") return 100;\n      if (key === \"I\") return false;\n      if (key === \"IM\") return false;\n    },\n    getRaw(key) {\n      if (key === \"CS\") return new Name(\"DeviceRGB\");\n    },\n    has(key) {\n      if (key === \"SMaskInData\") return false;\n      return false;\n    },\n  };\n  const fakeImage = { dict: fakeDict, stream: fakeStream, bitsPerComponent: null };\n  const pdfImage = new PDFImage({\n    xref: {},\n    res: {},\n    image: fakeImage,\n    pdfFunctionFactory: new PDFFunctionFactory(),\n    localColorSpaceCache: {},\n  });\n  JpxImage.parseImageProperties = originalParse;\n  if (!pdfImage.jpxDecoderOptions) {\n    throw new Error(\"jpxDecoderOptions is not defined\");\n  }\n  if (pdfImage.jpxDecoderOptions.numComponents !== 3) {\n    throw new Error(\n      `Expected jpxDecoderOptions.numComponents to be 3 but got ${pdfImage.jpxDecoderOptions.numComponents}`\n    );\n  }\n});"
  },
  "19340": {
    "i1_deepseek-r1-distill-llama-70b": "it(\"should throw an error when the wasm file is missing\", async () => {\n  const { JpxImage, JpxError } = await import(\"../../src/core/jpx.js\");\n  const coreUtils = await import(\"../../src/core/core_utils.js\");\n  const originalFetchBinaryData = coreUtils.fetchBinaryData;\n  coreUtils.fetchBinaryData = () => Promise.reject(new Error(\"Missing wasm file\"));\n  const dummyBytes = new Uint8Array([1, 2, 3, 4]);\n  await expect(JpxImage.decode(dummyBytes)).rejects.toThrow();\n  coreUtils.fetchBinaryData = originalFetchBinaryData;\n});",
    "i1_gpt-4o": "it(\"should throw an error when the wasm file is missing\", async () => {\n  const { JpxImage, JpxError } = await import(\"../../src/core/jpx.js\");\n  const coreUtils = await import(\"../../src/core/core_utils.js\");\n  const originalFetchBinaryData = coreUtils.fetchBinaryData;\n  coreUtils.fetchBinaryData = () => Promise.reject(new Error(\"Missing wasm file\"));\n  const dummyBytes = new Uint8Array([1, 2, 3, 4]);\n  await expect(JpxImage.decode(dummyBytes)).rejects.toThrow();\n  coreUtils.fetchBinaryData = originalFetchBinaryData;\n});",
    "i1_llama-3.3-70b-versatile": "it(\"should throw an error when the wasm file is missing\", async () => {\n  const { JpxImage, JpxError } = await import(\"../../src/core/jpx.js\");\n  const coreUtils = await import(\"../../src/core/core_utils.js\");\n  const originalFetchBinaryData = coreUtils.fetchBinaryData;\n  coreUtils.fetchBinaryData = () => Promise.reject(new Error(\"Missing wasm file\"));\n  const dummyBytes = new Uint8Array([1, 2, 3, 4]);\n  await expect(JpxImage.decode(dummyBytes)).rejects.toThrow();\n  coreUtils.fetchBinaryData = originalFetchBinaryData;\n});",
    "i1_MOCK": "it(\"should throw an error when the wasm file is missing\", async () => {\n  const { JpxImage, JpxError } = await import(\"../../src/core/jpx.js\");\n  const coreUtils = await import(\"../../src/core/core_utils.js\");\n  const originalFetchBinaryData = coreUtils.fetchBinaryData;\n  coreUtils.fetchBinaryData = () => Promise.reject(new Error(\"Missing wasm file\"));\n  const dummyBytes = new Uint8Array([1, 2, 3, 4]);\n  await expect(JpxImage.decode(dummyBytes)).rejects.toThrow();\n  coreUtils.fetchBinaryData = originalFetchBinaryData;\n});",
    "i2_deepseek-r1-distill-llama-70b": "it(\"should throw an error when the wasm file is missing\", async () => {\n  const { JpxImage, JpxError } = await import(\"../../src/core/jpx.js\");\n  const coreUtils = await import(\"../../src/core/core_utils.js\");\n  const originalFetchBinaryData = coreUtils.fetchBinaryData;\n  coreUtils.fetchBinaryData = () => Promise.reject(new Error(\"Missing wasm file\"));\n  const dummyBytes = new Uint8Array([1, 2, 3, 4]);\n  await expect(JpxImage.decode(dummyBytes)).rejects.toThrow();\n  coreUtils.fetchBinaryData = originalFetchBinaryData;\n});",
    "i2_gpt-4o": "it(\"should throw an error when the wasm file is missing\", async () => {\n  const { JpxImage, JpxError } = await import(\"../../src/core/jpx.js\");\n  const coreUtils = await import(\"../../src/core/core_utils.js\");\n  const originalFetchBinaryData = coreUtils.fetchBinaryData;\n  coreUtils.fetchBinaryData = () => Promise.reject(new Error(\"Missing wasm file\"));\n  const dummyBytes = new Uint8Array([1, 2, 3, 4]);\n  await expect(JpxImage.decode(dummyBytes)).rejects.toThrow();\n  coreUtils.fetchBinaryData = originalFetchBinaryData;\n});",
    "i2_llama-3.3-70b-versatile": "it(\"should throw an error when the wasm file is missing\", async () => {\n  const { JpxImage, JpxError } = await import(\"../../src/core/jpx.js\");\n  const coreUtils = await import(\"../../src/core/core_utils.js\");\n  const originalFetchBinaryData = coreUtils.fetchBinaryData;\n  coreUtils.fetchBinaryData = () => Promise.reject(new Error(\"Missing wasm file\"));\n  const dummyBytes = new Uint8Array([1, 2, 3, 4]);\n  await expect(JpxImage.decode(dummyBytes)).rejects.toThrow();\n  coreUtils.fetchBinaryData = originalFetchBinaryData;\n});",
    "i3_deepseek-r1-distill-llama-70b": "it(\"should throw an error when the wasm file is missing\", async () => {\n  const { JpxImage, JpxError } = await import(\"../../src/core/jpx.js\");\n  const coreUtils = await import(\"../../src/core/core_utils.js\");\n  const originalFetchBinaryData = coreUtils.fetchBinaryData;\n  coreUtils.fetchBinaryData = () => Promise.reject(new Error(\"Missing wasm file\"));\n  const dummyBytes = new Uint8Array([1, 2, 3, 4]);\n  await expect(JpxImage.decode(dummyBytes)).rejects.toThrow();\n  coreUtils.fetchBinaryData = originalFetchBinaryData;\n});",
    "i3_gpt-4o": "it(\"should throw an error when the wasm file is missing\", async () => {\n  const { JpxImage, JpxError } = await import(\"../../src/core/jpx.js\");\n  const coreUtils = await import(\"../../src/core/core_utils.js\");\n  const originalFetchBinaryData = coreUtils.fetchBinaryData;\n  coreUtils.fetchBinaryData = () => Promise.reject(new Error(\"Missing wasm file\"));\n  const dummyBytes = new Uint8Array([1, 2, 3, 4]);\n  await expect(JpxImage.decode(dummyBytes)).rejects.toThrow();\n  coreUtils.fetchBinaryData = originalFetchBinaryData;\n});",
    "i3_llama-3.3-70b-versatile": "it(\"should throw an error when the wasm file is missing\", async () => {\n  const { JpxImage, JpxError } = await import(\"../../src/core/jpx.js\");\n  const coreUtils = await import(\"../../src/core/core_utils.js\");\n  const originalFetchBinaryData = coreUtils.fetchBinaryData;\n  coreUtils.fetchBinaryData = () => Promise.reject(new Error(\"Missing wasm file\"));\n  const dummyBytes = new Uint8Array([1, 2, 3, 4]);\n  await expect(JpxImage.decode(dummyBytes)).rejects.toThrow();\n  coreUtils.fetchBinaryData = originalFetchBinaryData;\n});",
    "i4_deepseek-r1-distill-llama-70b": "it(\"should throw an error when the wasm file is missing\", async () => {\n  const { JpxImage, JpxError } = await import(\"../../src/core/jpx.js\");\n  const coreUtils = await import(\"../../src/core/core_utils.js\");\n  const originalFetchBinaryData = coreUtils.fetchBinaryData;\n  coreUtils.fetchBinaryData = () => Promise.reject(new Error(\"Missing wasm file\"));\n  const dummyBytes = new Uint8Array([1, 2, 3, 4]);\n  await expect(JpxImage.decode(dummyBytes)).rejects.toThrow();\n  coreUtils.fetchBinaryData = originalFetchBinaryData;\n});",
    "i4_gpt-4o": "it(\"should throw an error when the wasm file is missing\", async () => {\n  const { JpxImage, JpxError } = await import(\"../../src/core/jpx.js\");\n  const coreUtils = await import(\"../../src/core/core_utils.js\");\n  const originalFetchBinaryData = coreUtils.fetchBinaryData;\n  coreUtils.fetchBinaryData = () => Promise.reject(new Error(\"Missing wasm file\"));\n  const dummyBytes = new Uint8Array([1, 2, 3, 4]);\n  await expect(JpxImage.decode(dummyBytes)).rejects.toThrow();\n  coreUtils.fetchBinaryData = originalFetchBinaryData;\n});",
    "i4_llama-3.3-70b-versatile": "it(\"should throw an error when the wasm file is missing\", async () => {\n  const { JpxImage, JpxError } = await import(\"../../src/core/jpx.js\");\n  const coreUtils = await import(\"../../src/core/core_utils.js\");\n  const originalFetchBinaryData = coreUtils.fetchBinaryData;\n  coreUtils.fetchBinaryData = () => Promise.reject(new Error(\"Missing wasm file\"));\n  const dummyBytes = new Uint8Array([1, 2, 3, 4]);\n  await expect(JpxImage.decode(dummyBytes)).rejects.toThrow();\n  coreUtils.fetchBinaryData = originalFetchBinaryData;\n});",
    "i5_deepseek-r1-distill-llama-70b": "it(\"should throw an error when the wasm file is missing\", async () => {\n  const { JpxImage, JpxError } = await import(\"../../src/core/jpx.js\");\n  const coreUtils = await import(\"../../src/core/core_utils.js\");\n  const originalFetchBinaryData = coreUtils.fetchBinaryData;\n  coreUtils.fetchBinaryData = () => Promise.reject(new Error(\"Missing wasm file\"));\n  const dummyBytes = new Uint8Array([1, 2, 3, 4]);\n  await expect(JpxImage.decode(dummyBytes)).rejects.toThrow();\n  coreUtils.fetchBinaryData = originalFetchBinaryData;\n});",
    "i5_gpt-4o": "it(\"should throw an error when the wasm file is missing\", async () => {\n  const { JpxImage, JpxError } = await import(\"../../src/core/jpx.js\");\n  const coreUtils = await import(\"../../src/core/core_utils.js\");\n  const originalFetchBinaryData = coreUtils.fetchBinaryData;\n  coreUtils.fetchBinaryData = () => Promise.reject(new Error(\"Missing wasm file\"));\n  const dummyBytes = new Uint8Array([1, 2, 3, 4]);\n  await expect(JpxImage.decode(dummyBytes)).rejects.toThrow();\n  coreUtils.fetchBinaryData = originalFetchBinaryData;\n});",
    "i5_llama-3.3-70b-versatile": "it(\"should throw an error when the wasm file is missing\", async () => {\n  const { JpxImage, JpxError } = await import(\"../../src/core/jpx.js\");\n  const coreUtils = await import(\"../../src/core/core_utils.js\");\n  const originalFetchBinaryData = coreUtils.fetchBinaryData;\n  coreUtils.fetchBinaryData = () => Promise.reject(new Error(\"Missing wasm file\"));\n  const dummyBytes = new Uint8Array([1, 2, 3, 4]);\n  await expect(JpxImage.decode(dummyBytes)).rejects.toThrow();\n  coreUtils.fetchBinaryData = originalFetchBinaryData;\n});"
  },
  "19361": {
    "i1_deepseek-r1-distill-llama-70b": "it(\"should close the previous subpath when starting a new move in text rendering\", async () => {\n  const { compileCharString } = await import(\"../../src/core/font_renderer.js\");\n  const commands = [];\n  const cmds = {\n    add: (cmd, args) => commands.push({ cmd, args })\n  };\n  // The following charstring simulates two move-to operations:\n  // First, a horizontal move (operator 22) with one argument (100),\n  // then a relative move (operator 21) with two arguments (50 and 80).\n  // Numbers are encoded as per the Type2 charstring specification:\n  // For numbers between -107 and 107, the value is encoded as (value + 139).\n  // Thus, 100 encodes to 239, 50 to 189, and 80 to 219.\n  const charStringCode = [239, 22, 189, 219, 21];\n  // Provide a dummy font object.\n  const font = {};\n  // Call compileCharString which will process the code.\n  compileCharString(charStringCode, cmds, font, 0);\n  // Expected behavior (post-patch):\n  // First move: moveTo(100, 0) -> adds \"M\" [100,0].\n  // Second move: before moveTo(150,80) it should close the previous subpath by adding \"L\" with the first point of that subpath ([100,0]),\n  // then add \"M\" with the new coordinates.\n  const expected = [\n    { cmd: \"M\", args: [100, 0] },\n    { cmd: \"L\", args: [100, 0] },\n    { cmd: \"M\", args: [150, 80] }\n  ];\n  expect(commands).toEqual(expected);\n});",
    "i1_gpt-4o": "it(\"should close the previous subpath when starting a new move in text rendering\", async () => {\n  const { compileCharString } = await import(\"../../src/core/font_renderer.js\");\n  const commands = [];\n  const cmds = {\n    add: (cmd, args) => commands.push({ cmd, args })\n  };\n  // The following charstring simulates two move-to operations:\n  // First, a horizontal move (operator 22) with one argument (100),\n  // then a relative move (operator 21) with two arguments (50 and 80).\n  // Numbers are encoded as per the Type2 charstring specification:\n  // For numbers between -107 and 107, the value is encoded as (value + 139).\n  // Thus, 100 encodes to 239, 50 to 189, and 80 to 219.\n  const charStringCode = [239, 22, 189, 219, 21];\n  // Provide a dummy font object.\n  const font = {};\n  // Call compileCharString which will process the code.\n  compileCharString(charStringCode, cmds, font, 0);\n  // Expected behavior (post-patch):\n  // First move: moveTo(100, 0) -> adds \"M\" [100,0].\n  // Second move: before moveTo(150,80) it should close the previous subpath by adding \"L\" with the first point of that subpath ([100,0]),\n  // then add \"M\" with the new coordinates.\n  const expected = [\n    { cmd: \"M\", args: [100, 0] },\n    { cmd: \"L\", args: [100, 0] },\n    { cmd: \"M\", args: [150, 80] }\n  ];\n  expect(commands).toEqual(expected);\n});",
    "i1_llama-3.3-70b-versatile": "it(\"should close the previous subpath when starting a new move in text rendering\", async () => {\n  const { compileCharString } = await import(\"../../src/core/font_renderer.js\");\n  const commands = [];\n  const cmds = {\n    add: (cmd, args) => commands.push({ cmd, args })\n  };\n  // The following charstring simulates two move-to operations:\n  // First, a horizontal move (operator 22) with one argument (100),\n  // then a relative move (operator 21) with two arguments (50 and 80).\n  // Numbers are encoded as per the Type2 charstring specification:\n  // For numbers between -107 and 107, the value is encoded as (value + 139).\n  // Thus, 100 encodes to 239, 50 to 189, and 80 to 219.\n  const charStringCode = [239, 22, 189, 219, 21];\n  // Provide a dummy font object.\n  const font = {};\n  // Call compileCharString which will process the code.\n  compileCharString(charStringCode, cmds, font, 0);\n  // Expected behavior (post-patch):\n  // First move: moveTo(100, 0) -> adds \"M\" [100,0].\n  // Second move: before moveTo(150,80) it should close the previous subpath by adding \"L\" with the first point of that subpath ([100,0]),\n  // then add \"M\" with the new coordinates.\n  const expected = [\n    { cmd: \"M\", args: [100, 0] },\n    { cmd: \"L\", args: [100, 0] },\n    { cmd: \"M\", args: [150, 80] }\n  ];\n  expect(commands).toEqual(expected);\n});",
    "i1_MOCK": "it(\"should close the previous subpath when starting a new move in text rendering\", async () => {\n  const { compileCharString } = await import(\"../../src/core/font_renderer.js\");\n  const commands = [];\n  const cmds = {\n    add: (cmd, args) => commands.push({ cmd, args })\n  };\n  // The following charstring simulates two move-to operations:\n  // First, a horizontal move (operator 22) with one argument (100),\n  // then a relative move (operator 21) with two arguments (50 and 80).\n  // Numbers are encoded as per the Type2 charstring specification:\n  // For numbers between -107 and 107, the value is encoded as (value + 139).\n  // Thus, 100 encodes to 239, 50 to 189, and 80 to 219.\n  const charStringCode = [239, 22, 189, 219, 21];\n  // Provide a dummy font object.\n  const font = {};\n  // Call compileCharString which will process the code.\n  compileCharString(charStringCode, cmds, font, 0);\n  // Expected behavior (post-patch):\n  // First move: moveTo(100, 0) -> adds \"M\" [100,0].\n  // Second move: before moveTo(150,80) it should close the previous subpath by adding \"L\" with the first point of that subpath ([100,0]),\n  // then add \"M\" with the new coordinates.\n  const expected = [\n    { cmd: \"M\", args: [100, 0] },\n    { cmd: \"L\", args: [100, 0] },\n    { cmd: \"M\", args: [150, 80] }\n  ];\n  expect(commands).toEqual(expected);\n});",
    "i2_deepseek-r1-distill-llama-70b": "it(\"should close the previous subpath when starting a new move in text rendering\", async () => {\n  const { compileCharString } = await import(\"../../src/core/font_renderer.js\");\n  const commands = [];\n  const cmds = {\n    add: (cmd, args) => commands.push({ cmd, args })\n  };\n  // The following charstring simulates two move-to operations:\n  // First, a horizontal move (operator 22) with one argument (100),\n  // then a relative move (operator 21) with two arguments (50 and 80).\n  // Numbers are encoded as per the Type2 charstring specification:\n  // For numbers between -107 and 107, the value is encoded as (value + 139).\n  // Thus, 100 encodes to 239, 50 to 189, and 80 to 219.\n  const charStringCode = [239, 22, 189, 219, 21];\n  // Provide a dummy font object.\n  const font = {};\n  // Call compileCharString which will process the code.\n  compileCharString(charStringCode, cmds, font, 0);\n  // Expected behavior (post-patch):\n  // First move: moveTo(100, 0) -> adds \"M\" [100,0].\n  // Second move: before moveTo(150,80) it should close the previous subpath by adding \"L\" with the first point of that subpath ([100,0]),\n  // then add \"M\" with the new coordinates.\n  const expected = [\n    { cmd: \"M\", args: [100, 0] },\n    { cmd: \"L\", args: [100, 0] },\n    { cmd: \"M\", args: [150, 80] }\n  ];\n  expect(commands).toEqual(expected);\n});",
    "i2_gpt-4o": "it(\"should close the previous subpath when starting a new move in text rendering\", async () => {\n  const { compileCharString } = await import(\"../../src/core/font_renderer.js\");\n  const commands = [];\n  const cmds = {\n    add: (cmd, args) => commands.push({ cmd, args })\n  };\n  // The following charstring simulates two move-to operations:\n  // First, a horizontal move (operator 22) with one argument (100),\n  // then a relative move (operator 21) with two arguments (50 and 80).\n  // Numbers are encoded as per the Type2 charstring specification:\n  // For numbers between -107 and 107, the value is encoded as (value + 139).\n  // Thus, 100 encodes to 239, 50 to 189, and 80 to 219.\n  const charStringCode = [239, 22, 189, 219, 21];\n  // Provide a dummy font object.\n  const font = {};\n  // Call compileCharString which will process the code.\n  compileCharString(charStringCode, cmds, font, 0);\n  // Expected behavior (post-patch):\n  // First move: moveTo(100, 0) -> adds \"M\" [100,0].\n  // Second move: before moveTo(150,80) it should close the previous subpath by adding \"L\" with the first point of that subpath ([100,0]),\n  // then add \"M\" with the new coordinates.\n  const expected = [\n    { cmd: \"M\", args: [100, 0] },\n    { cmd: \"L\", args: [100, 0] },\n    { cmd: \"M\", args: [150, 80] }\n  ];\n  expect(commands).toEqual(expected);\n});",
    "i2_llama-3.3-70b-versatile": "it(\"should close the previous subpath when starting a new move in text rendering\", async () => {\n  const { compileCharString } = await import(\"../../src/core/font_renderer.js\");\n  const commands = [];\n  const cmds = {\n    add: (cmd, args) => commands.push({ cmd, args })\n  };\n  // The following charstring simulates two move-to operations:\n  // First, a horizontal move (operator 22) with one argument (100),\n  // then a relative move (operator 21) with two arguments (50 and 80).\n  // Numbers are encoded as per the Type2 charstring specification:\n  // For numbers between -107 and 107, the value is encoded as (value + 139).\n  // Thus, 100 encodes to 239, 50 to 189, and 80 to 219.\n  const charStringCode = [239, 22, 189, 219, 21];\n  // Provide a dummy font object.\n  const font = {};\n  // Call compileCharString which will process the code.\n  compileCharString(charStringCode, cmds, font, 0);\n  // Expected behavior (post-patch):\n  // First move: moveTo(100, 0) -> adds \"M\" [100,0].\n  // Second move: before moveTo(150,80) it should close the previous subpath by adding \"L\" with the first point of that subpath ([100,0]),\n  // then add \"M\" with the new coordinates.\n  const expected = [\n    { cmd: \"M\", args: [100, 0] },\n    { cmd: \"L\", args: [100, 0] },\n    { cmd: \"M\", args: [150, 80] }\n  ];\n  expect(commands).toEqual(expected);\n});",
    "i3_deepseek-r1-distill-llama-70b": "it(\"should close the previous subpath when starting a new move in text rendering\", async () => {\n  const { compileCharString } = await import(\"../../src/core/font_renderer.js\");\n  const commands = [];\n  const cmds = {\n    add: (cmd, args) => commands.push({ cmd, args })\n  };\n  // The following charstring simulates two move-to operations:\n  // First, a horizontal move (operator 22) with one argument (100),\n  // then a relative move (operator 21) with two arguments (50 and 80).\n  // Numbers are encoded as per the Type2 charstring specification:\n  // For numbers between -107 and 107, the value is encoded as (value + 139).\n  // Thus, 100 encodes to 239, 50 to 189, and 80 to 219.\n  const charStringCode = [239, 22, 189, 219, 21];\n  // Provide a dummy font object.\n  const font = {};\n  // Call compileCharString which will process the code.\n  compileCharString(charStringCode, cmds, font, 0);\n  // Expected behavior (post-patch):\n  // First move: moveTo(100, 0) -> adds \"M\" [100,0].\n  // Second move: before moveTo(150,80) it should close the previous subpath by adding \"L\" with the first point of that subpath ([100,0]),\n  // then add \"M\" with the new coordinates.\n  const expected = [\n    { cmd: \"M\", args: [100, 0] },\n    { cmd: \"L\", args: [100, 0] },\n    { cmd: \"M\", args: [150, 80] }\n  ];\n  expect(commands).toEqual(expected);\n});",
    "i3_gpt-4o": "it(\"should close the previous subpath when starting a new move in text rendering\", async () => {\n  const { compileCharString } = await import(\"../../src/core/font_renderer.js\");\n  const commands = [];\n  const cmds = {\n    add: (cmd, args) => commands.push({ cmd, args })\n  };\n  // The following charstring simulates two move-to operations:\n  // First, a horizontal move (operator 22) with one argument (100),\n  // then a relative move (operator 21) with two arguments (50 and 80).\n  // Numbers are encoded as per the Type2 charstring specification:\n  // For numbers between -107 and 107, the value is encoded as (value + 139).\n  // Thus, 100 encodes to 239, 50 to 189, and 80 to 219.\n  const charStringCode = [239, 22, 189, 219, 21];\n  // Provide a dummy font object.\n  const font = {};\n  // Call compileCharString which will process the code.\n  compileCharString(charStringCode, cmds, font, 0);\n  // Expected behavior (post-patch):\n  // First move: moveTo(100, 0) -> adds \"M\" [100,0].\n  // Second move: before moveTo(150,80) it should close the previous subpath by adding \"L\" with the first point of that subpath ([100,0]),\n  // then add \"M\" with the new coordinates.\n  const expected = [\n    { cmd: \"M\", args: [100, 0] },\n    { cmd: \"L\", args: [100, 0] },\n    { cmd: \"M\", args: [150, 80] }\n  ];\n  expect(commands).toEqual(expected);\n});",
    "i3_llama-3.3-70b-versatile": "it(\"should close the previous subpath when starting a new move in text rendering\", async () => {\n  const { compileCharString } = await import(\"../../src/core/font_renderer.js\");\n  const commands = [];\n  const cmds = {\n    add: (cmd, args) => commands.push({ cmd, args })\n  };\n  // The following charstring simulates two move-to operations:\n  // First, a horizontal move (operator 22) with one argument (100),\n  // then a relative move (operator 21) with two arguments (50 and 80).\n  // Numbers are encoded as per the Type2 charstring specification:\n  // For numbers between -107 and 107, the value is encoded as (value + 139).\n  // Thus, 100 encodes to 239, 50 to 189, and 80 to 219.\n  const charStringCode = [239, 22, 189, 219, 21];\n  // Provide a dummy font object.\n  const font = {};\n  // Call compileCharString which will process the code.\n  compileCharString(charStringCode, cmds, font, 0);\n  // Expected behavior (post-patch):\n  // First move: moveTo(100, 0) -> adds \"M\" [100,0].\n  // Second move: before moveTo(150,80) it should close the previous subpath by adding \"L\" with the first point of that subpath ([100,0]),\n  // then add \"M\" with the new coordinates.\n  const expected = [\n    { cmd: \"M\", args: [100, 0] },\n    { cmd: \"L\", args: [100, 0] },\n    { cmd: \"M\", args: [150, 80] }\n  ];\n  expect(commands).toEqual(expected);\n});",
    "i4_deepseek-r1-distill-llama-70b": "it(\"should close the previous subpath when starting a new move in text rendering\", async () => {\n  const { compileCharString } = await import(\"../../src/core/font_renderer.js\");\n  const commands = [];\n  const cmds = {\n    add: (cmd, args) => commands.push({ cmd, args })\n  };\n  // The following charstring simulates two move-to operations:\n  // First, a horizontal move (operator 22) with one argument (100),\n  // then a relative move (operator 21) with two arguments (50 and 80).\n  // Numbers are encoded as per the Type2 charstring specification:\n  // For numbers between -107 and 107, the value is encoded as (value + 139).\n  // Thus, 100 encodes to 239, 50 to 189, and 80 to 219.\n  const charStringCode = [239, 22, 189, 219, 21];\n  // Provide a dummy font object.\n  const font = {};\n  // Call compileCharString which will process the code.\n  compileCharString(charStringCode, cmds, font, 0);\n  // Expected behavior (post-patch):\n  // First move: moveTo(100, 0) -> adds \"M\" [100,0].\n  // Second move: before moveTo(150,80) it should close the previous subpath by adding \"L\" with the first point of that subpath ([100,0]),\n  // then add \"M\" with the new coordinates.\n  const expected = [\n    { cmd: \"M\", args: [100, 0] },\n    { cmd: \"L\", args: [100, 0] },\n    { cmd: \"M\", args: [150, 80] }\n  ];\n  expect(commands).toEqual(expected);\n});",
    "i4_gpt-4o": "it(\"should close the previous subpath when starting a new move in text rendering\", async () => {\n  const { compileCharString } = await import(\"../../src/core/font_renderer.js\");\n  const commands = [];\n  const cmds = {\n    add: (cmd, args) => commands.push({ cmd, args })\n  };\n  // The following charstring simulates two move-to operations:\n  // First, a horizontal move (operator 22) with one argument (100),\n  // then a relative move (operator 21) with two arguments (50 and 80).\n  // Numbers are encoded as per the Type2 charstring specification:\n  // For numbers between -107 and 107, the value is encoded as (value + 139).\n  // Thus, 100 encodes to 239, 50 to 189, and 80 to 219.\n  const charStringCode = [239, 22, 189, 219, 21];\n  // Provide a dummy font object.\n  const font = {};\n  // Call compileCharString which will process the code.\n  compileCharString(charStringCode, cmds, font, 0);\n  // Expected behavior (post-patch):\n  // First move: moveTo(100, 0) -> adds \"M\" [100,0].\n  // Second move: before moveTo(150,80) it should close the previous subpath by adding \"L\" with the first point of that subpath ([100,0]),\n  // then add \"M\" with the new coordinates.\n  const expected = [\n    { cmd: \"M\", args: [100, 0] },\n    { cmd: \"L\", args: [100, 0] },\n    { cmd: \"M\", args: [150, 80] }\n  ];\n  expect(commands).toEqual(expected);\n});",
    "i4_llama-3.3-70b-versatile": "it(\"should close the previous subpath when starting a new move in text rendering\", async () => {\n  const { compileCharString } = await import(\"../../src/core/font_renderer.js\");\n  const commands = [];\n  const cmds = {\n    add: (cmd, args) => commands.push({ cmd, args })\n  };\n  // The following charstring simulates two move-to operations:\n  // First, a horizontal move (operator 22) with one argument (100),\n  // then a relative move (operator 21) with two arguments (50 and 80).\n  // Numbers are encoded as per the Type2 charstring specification:\n  // For numbers between -107 and 107, the value is encoded as (value + 139).\n  // Thus, 100 encodes to 239, 50 to 189, and 80 to 219.\n  const charStringCode = [239, 22, 189, 219, 21];\n  // Provide a dummy font object.\n  const font = {};\n  // Call compileCharString which will process the code.\n  compileCharString(charStringCode, cmds, font, 0);\n  // Expected behavior (post-patch):\n  // First move: moveTo(100, 0) -> adds \"M\" [100,0].\n  // Second move: before moveTo(150,80) it should close the previous subpath by adding \"L\" with the first point of that subpath ([100,0]),\n  // then add \"M\" with the new coordinates.\n  const expected = [\n    { cmd: \"M\", args: [100, 0] },\n    { cmd: \"L\", args: [100, 0] },\n    { cmd: \"M\", args: [150, 80] }\n  ];\n  expect(commands).toEqual(expected);\n});",
    "i5_deepseek-r1-distill-llama-70b": "it(\"should close the previous subpath when starting a new move in text rendering\", async () => {\n  const { compileCharString } = await import(\"../../src/core/font_renderer.js\");\n  const commands = [];\n  const cmds = {\n    add: (cmd, args) => commands.push({ cmd, args })\n  };\n  // The following charstring simulates two move-to operations:\n  // First, a horizontal move (operator 22) with one argument (100),\n  // then a relative move (operator 21) with two arguments (50 and 80).\n  // Numbers are encoded as per the Type2 charstring specification:\n  // For numbers between -107 and 107, the value is encoded as (value + 139).\n  // Thus, 100 encodes to 239, 50 to 189, and 80 to 219.\n  const charStringCode = [239, 22, 189, 219, 21];\n  // Provide a dummy font object.\n  const font = {};\n  // Call compileCharString which will process the code.\n  compileCharString(charStringCode, cmds, font, 0);\n  // Expected behavior (post-patch):\n  // First move: moveTo(100, 0) -> adds \"M\" [100,0].\n  // Second move: before moveTo(150,80) it should close the previous subpath by adding \"L\" with the first point of that subpath ([100,0]),\n  // then add \"M\" with the new coordinates.\n  const expected = [\n    { cmd: \"M\", args: [100, 0] },\n    { cmd: \"L\", args: [100, 0] },\n    { cmd: \"M\", args: [150, 80] }\n  ];\n  expect(commands).toEqual(expected);\n});",
    "i5_gpt-4o": "it(\"should close the previous subpath when starting a new move in text rendering\", async () => {\n  const { compileCharString } = await import(\"../../src/core/font_renderer.js\");\n  const commands = [];\n  const cmds = {\n    add: (cmd, args) => commands.push({ cmd, args })\n  };\n  // The following charstring simulates two move-to operations:\n  // First, a horizontal move (operator 22) with one argument (100),\n  // then a relative move (operator 21) with two arguments (50 and 80).\n  // Numbers are encoded as per the Type2 charstring specification:\n  // For numbers between -107 and 107, the value is encoded as (value + 139).\n  // Thus, 100 encodes to 239, 50 to 189, and 80 to 219.\n  const charStringCode = [239, 22, 189, 219, 21];\n  // Provide a dummy font object.\n  const font = {};\n  // Call compileCharString which will process the code.\n  compileCharString(charStringCode, cmds, font, 0);\n  // Expected behavior (post-patch):\n  // First move: moveTo(100, 0) -> adds \"M\" [100,0].\n  // Second move: before moveTo(150,80) it should close the previous subpath by adding \"L\" with the first point of that subpath ([100,0]),\n  // then add \"M\" with the new coordinates.\n  const expected = [\n    { cmd: \"M\", args: [100, 0] },\n    { cmd: \"L\", args: [100, 0] },\n    { cmd: \"M\", args: [150, 80] }\n  ];\n  expect(commands).toEqual(expected);\n});",
    "i5_llama-3.3-70b-versatile": "it(\"should close the previous subpath when starting a new move in text rendering\", async () => {\n  const { compileCharString } = await import(\"../../src/core/font_renderer.js\");\n  const commands = [];\n  const cmds = {\n    add: (cmd, args) => commands.push({ cmd, args })\n  };\n  // The following charstring simulates two move-to operations:\n  // First, a horizontal move (operator 22) with one argument (100),\n  // then a relative move (operator 21) with two arguments (50 and 80).\n  // Numbers are encoded as per the Type2 charstring specification:\n  // For numbers between -107 and 107, the value is encoded as (value + 139).\n  // Thus, 100 encodes to 239, 50 to 189, and 80 to 219.\n  const charStringCode = [239, 22, 189, 219, 21];\n  // Provide a dummy font object.\n  const font = {};\n  // Call compileCharString which will process the code.\n  compileCharString(charStringCode, cmds, font, 0);\n  // Expected behavior (post-patch):\n  // First move: moveTo(100, 0) -> adds \"M\" [100,0].\n  // Second move: before moveTo(150,80) it should close the previous subpath by adding \"L\" with the first point of that subpath ([100,0]),\n  // then add \"M\" with the new coordinates.\n  const expected = [\n    { cmd: \"M\", args: [100, 0] },\n    { cmd: \"L\", args: [100, 0] },\n    { cmd: \"M\", args: [150, 80] }\n  ];\n  expect(commands).toEqual(expected);\n});"
  },
  "19368": {
    "i1_deepseek-r1-distill-llama-70b": "it(\"should immediately clear intentStates when a last chunk is received in nonprint mode\", async () => {\n  const { PDFPageProxy } = await import(\"../../src/display/api.js\");\n  const { assert } = await import(\"../../src/shared/util.js\");\n  const dummyTransport = {\n    commonObjs: new Map(),\n    getRenderingIntent: () => ({ renderingIntent: 2, cacheKey: \"test\" }),\n  };\n  const pdfPageProxy = new PDFPageProxy(0, {}, dummyTransport, false);\n  const intentState = {\n    renderTasks: new Set(),\n    operatorList: { fnArray: [], argsArray: [], lastChunk: false, separateAnnots: null },\n  };\n  pdfPageProxy._intentStates.set(\"test\", intentState);\n  pdfPageProxy._renderPageChunk(\n    { fnArray: [], argsArray: [], lastChunk: true, separateAnnots: null },\n    intentState\n  );\n  assert.strictEqual(pdfPageProxy._intentStates.size, 0);\n});\n",
    "i1_gpt-4o": "it(\"should immediately clear intentStates when a last chunk is received in nonprint mode\", async () => {\n  const { PDFPageProxy } = await import(\"../../src/display/api.js\");\n  const { assert } = await import(\"../../src/shared/util.js\");\n  const dummyTransport = {\n    commonObjs: new Map(),\n    getRenderingIntent: () => ({ renderingIntent: 2, cacheKey: \"test\" }),\n  };\n  const pdfPageProxy = new PDFPageProxy(0, {}, dummyTransport, false);\n  const intentState = {\n    renderTasks: new Set(),\n    operatorList: { fnArray: [], argsArray: [], lastChunk: false, separateAnnots: null },\n  };\n  pdfPageProxy._intentStates.set(\"test\", intentState);\n  pdfPageProxy._renderPageChunk(\n    { fnArray: [], argsArray: [], lastChunk: true, separateAnnots: null },\n    intentState\n  );\n  assert.strictEqual(pdfPageProxy._intentStates.size, 0);\n});\n",
    "i1_llama-3.3-70b-versatile": "it(\"should immediately clear intentStates when a last chunk is received in nonprint mode\", async () => {\n  const { PDFPageProxy } = await import(\"../../src/display/api.js\");\n  const { assert } = await import(\"../../src/shared/util.js\");\n  const dummyTransport = {\n    commonObjs: new Map(),\n    getRenderingIntent: () => ({ renderingIntent: 2, cacheKey: \"test\" }),\n  };\n  const pdfPageProxy = new PDFPageProxy(0, {}, dummyTransport, false);\n  const intentState = {\n    renderTasks: new Set(),\n    operatorList: { fnArray: [], argsArray: [], lastChunk: false, separateAnnots: null },\n  };\n  pdfPageProxy._intentStates.set(\"test\", intentState);\n  pdfPageProxy._renderPageChunk(\n    { fnArray: [], argsArray: [], lastChunk: true, separateAnnots: null },\n    intentState\n  );\n  assert.strictEqual(pdfPageProxy._intentStates.size, 0);\n});\n",
    "i1_MOCK": "it(\"should immediately clear intentStates when a last chunk is received in nonprint mode\", async () => {\n  const { PDFPageProxy } = await import(\"../../src/display/api.js\");\n  const { assert } = await import(\"../../src/shared/util.js\");\n  const dummyTransport = {\n    commonObjs: new Map(),\n    getRenderingIntent: () => ({ renderingIntent: 2, cacheKey: \"test\" }),\n  };\n  const pdfPageProxy = new PDFPageProxy(0, {}, dummyTransport, false);\n  const intentState = {\n    renderTasks: new Set(),\n    operatorList: { fnArray: [], argsArray: [], lastChunk: false, separateAnnots: null },\n  };\n  pdfPageProxy._intentStates.set(\"test\", intentState);\n  pdfPageProxy._renderPageChunk(\n    { fnArray: [], argsArray: [], lastChunk: true, separateAnnots: null },\n    intentState\n  );\n  assert.strictEqual(pdfPageProxy._intentStates.size, 0);\n});\n",
    "i2_deepseek-r1-distill-llama-70b": "it(\"should immediately clear intentStates when a last chunk is received in nonprint mode\", async () => {\n  const { PDFPageProxy } = await import(\"../../src/display/api.js\");\n  const { assert } = await import(\"../../src/shared/util.js\");\n  const dummyTransport = {\n    commonObjs: new Map(),\n    getRenderingIntent: () => ({ renderingIntent: 2, cacheKey: \"test\" }),\n  };\n  const pdfPageProxy = new PDFPageProxy(0, {}, dummyTransport, false);\n  const intentState = {\n    renderTasks: new Set(),\n    operatorList: { fnArray: [], argsArray: [], lastChunk: false, separateAnnots: null },\n  };\n  pdfPageProxy._intentStates.set(\"test\", intentState);\n  pdfPageProxy._renderPageChunk(\n    { fnArray: [], argsArray: [], lastChunk: true, separateAnnots: null },\n    intentState\n  );\n  assert.strictEqual(pdfPageProxy._intentStates.size, 0);\n});\n",
    "i2_gpt-4o": "it(\"should immediately clear intentStates when a last chunk is received in nonprint mode\", async () => {\n  const { PDFPageProxy } = await import(\"../../src/display/api.js\");\n  const { assert } = await import(\"../../src/shared/util.js\");\n  const dummyTransport = {\n    commonObjs: new Map(),\n    getRenderingIntent: () => ({ renderingIntent: 2, cacheKey: \"test\" }),\n  };\n  const pdfPageProxy = new PDFPageProxy(0, {}, dummyTransport, false);\n  const intentState = {\n    renderTasks: new Set(),\n    operatorList: { fnArray: [], argsArray: [], lastChunk: false, separateAnnots: null },\n  };\n  pdfPageProxy._intentStates.set(\"test\", intentState);\n  pdfPageProxy._renderPageChunk(\n    { fnArray: [], argsArray: [], lastChunk: true, separateAnnots: null },\n    intentState\n  );\n  assert.strictEqual(pdfPageProxy._intentStates.size, 0);\n});\n",
    "i2_llama-3.3-70b-versatile": "it(\"should immediately clear intentStates when a last chunk is received in nonprint mode\", async () => {\n  const { PDFPageProxy } = await import(\"../../src/display/api.js\");\n  const { assert } = await import(\"../../src/shared/util.js\");\n  const dummyTransport = {\n    commonObjs: new Map(),\n    getRenderingIntent: () => ({ renderingIntent: 2, cacheKey: \"test\" }),\n  };\n  const pdfPageProxy = new PDFPageProxy(0, {}, dummyTransport, false);\n  const intentState = {\n    renderTasks: new Set(),\n    operatorList: { fnArray: [], argsArray: [], lastChunk: false, separateAnnots: null },\n  };\n  pdfPageProxy._intentStates.set(\"test\", intentState);\n  pdfPageProxy._renderPageChunk(\n    { fnArray: [], argsArray: [], lastChunk: true, separateAnnots: null },\n    intentState\n  );\n  assert.strictEqual(pdfPageProxy._intentStates.size, 0);\n});\n",
    "i3_deepseek-r1-distill-llama-70b": "it(\"should immediately clear intentStates when a last chunk is received in nonprint mode\", async () => {\n  const { PDFPageProxy } = await import(\"../../src/display/api.js\");\n  const { assert } = await import(\"../../src/shared/util.js\");\n  const dummyTransport = {\n    commonObjs: new Map(),\n    getRenderingIntent: () => ({ renderingIntent: 2, cacheKey: \"test\" }),\n  };\n  const pdfPageProxy = new PDFPageProxy(0, {}, dummyTransport, false);\n  const intentState = {\n    renderTasks: new Set(),\n    operatorList: { fnArray: [], argsArray: [], lastChunk: false, separateAnnots: null },\n  };\n  pdfPageProxy._intentStates.set(\"test\", intentState);\n  pdfPageProxy._renderPageChunk(\n    { fnArray: [], argsArray: [], lastChunk: true, separateAnnots: null },\n    intentState\n  );\n  assert.strictEqual(pdfPageProxy._intentStates.size, 0);\n});\n",
    "i3_gpt-4o": "it(\"should immediately clear intentStates when a last chunk is received in nonprint mode\", async () => {\n  const { PDFPageProxy } = await import(\"../../src/display/api.js\");\n  const { assert } = await import(\"../../src/shared/util.js\");\n  const dummyTransport = {\n    commonObjs: new Map(),\n    getRenderingIntent: () => ({ renderingIntent: 2, cacheKey: \"test\" }),\n  };\n  const pdfPageProxy = new PDFPageProxy(0, {}, dummyTransport, false);\n  const intentState = {\n    renderTasks: new Set(),\n    operatorList: { fnArray: [], argsArray: [], lastChunk: false, separateAnnots: null },\n  };\n  pdfPageProxy._intentStates.set(\"test\", intentState);\n  pdfPageProxy._renderPageChunk(\n    { fnArray: [], argsArray: [], lastChunk: true, separateAnnots: null },\n    intentState\n  );\n  assert.strictEqual(pdfPageProxy._intentStates.size, 0);\n});\n",
    "i3_llama-3.3-70b-versatile": "it(\"should immediately clear intentStates when a last chunk is received in nonprint mode\", async () => {\n  const { PDFPageProxy } = await import(\"../../src/display/api.js\");\n  const { assert } = await import(\"../../src/shared/util.js\");\n  const dummyTransport = {\n    commonObjs: new Map(),\n    getRenderingIntent: () => ({ renderingIntent: 2, cacheKey: \"test\" }),\n  };\n  const pdfPageProxy = new PDFPageProxy(0, {}, dummyTransport, false);\n  const intentState = {\n    renderTasks: new Set(),\n    operatorList: { fnArray: [], argsArray: [], lastChunk: false, separateAnnots: null },\n  };\n  pdfPageProxy._intentStates.set(\"test\", intentState);\n  pdfPageProxy._renderPageChunk(\n    { fnArray: [], argsArray: [], lastChunk: true, separateAnnots: null },\n    intentState\n  );\n  assert.strictEqual(pdfPageProxy._intentStates.size, 0);\n});\n",
    "i4_deepseek-r1-distill-llama-70b": "it(\"should immediately clear intentStates when a last chunk is received in nonprint mode\", async () => {\n  const { PDFPageProxy } = await import(\"../../src/display/api.js\");\n  const { assert } = await import(\"../../src/shared/util.js\");\n  const dummyTransport = {\n    commonObjs: new Map(),\n    getRenderingIntent: () => ({ renderingIntent: 2, cacheKey: \"test\" }),\n  };\n  const pdfPageProxy = new PDFPageProxy(0, {}, dummyTransport, false);\n  const intentState = {\n    renderTasks: new Set(),\n    operatorList: { fnArray: [], argsArray: [], lastChunk: false, separateAnnots: null },\n  };\n  pdfPageProxy._intentStates.set(\"test\", intentState);\n  pdfPageProxy._renderPageChunk(\n    { fnArray: [], argsArray: [], lastChunk: true, separateAnnots: null },\n    intentState\n  );\n  assert.strictEqual(pdfPageProxy._intentStates.size, 0);\n});\n",
    "i4_gpt-4o": "it(\"should immediately clear intentStates when a last chunk is received in nonprint mode\", async () => {\n  const { PDFPageProxy } = await import(\"../../src/display/api.js\");\n  const { assert } = await import(\"../../src/shared/util.js\");\n  const dummyTransport = {\n    commonObjs: new Map(),\n    getRenderingIntent: () => ({ renderingIntent: 2, cacheKey: \"test\" }),\n  };\n  const pdfPageProxy = new PDFPageProxy(0, {}, dummyTransport, false);\n  const intentState = {\n    renderTasks: new Set(),\n    operatorList: { fnArray: [], argsArray: [], lastChunk: false, separateAnnots: null },\n  };\n  pdfPageProxy._intentStates.set(\"test\", intentState);\n  pdfPageProxy._renderPageChunk(\n    { fnArray: [], argsArray: [], lastChunk: true, separateAnnots: null },\n    intentState\n  );\n  assert.strictEqual(pdfPageProxy._intentStates.size, 0);\n});\n",
    "i4_llama-3.3-70b-versatile": "it(\"should immediately clear intentStates when a last chunk is received in nonprint mode\", async () => {\n  const { PDFPageProxy } = await import(\"../../src/display/api.js\");\n  const { assert } = await import(\"../../src/shared/util.js\");\n  const dummyTransport = {\n    commonObjs: new Map(),\n    getRenderingIntent: () => ({ renderingIntent: 2, cacheKey: \"test\" }),\n  };\n  const pdfPageProxy = new PDFPageProxy(0, {}, dummyTransport, false);\n  const intentState = {\n    renderTasks: new Set(),\n    operatorList: { fnArray: [], argsArray: [], lastChunk: false, separateAnnots: null },\n  };\n  pdfPageProxy._intentStates.set(\"test\", intentState);\n  pdfPageProxy._renderPageChunk(\n    { fnArray: [], argsArray: [], lastChunk: true, separateAnnots: null },\n    intentState\n  );\n  assert.strictEqual(pdfPageProxy._intentStates.size, 0);\n});\n",
    "i5_deepseek-r1-distill-llama-70b": "it(\"should immediately clear intentStates when a last chunk is received in nonprint mode\", async () => {\n  const { PDFPageProxy } = await import(\"../../src/display/api.js\");\n  const { assert } = await import(\"../../src/shared/util.js\");\n  const dummyTransport = {\n    commonObjs: new Map(),\n    getRenderingIntent: () => ({ renderingIntent: 2, cacheKey: \"test\" }),\n  };\n  const pdfPageProxy = new PDFPageProxy(0, {}, dummyTransport, false);\n  const intentState = {\n    renderTasks: new Set(),\n    operatorList: { fnArray: [], argsArray: [], lastChunk: false, separateAnnots: null },\n  };\n  pdfPageProxy._intentStates.set(\"test\", intentState);\n  pdfPageProxy._renderPageChunk(\n    { fnArray: [], argsArray: [], lastChunk: true, separateAnnots: null },\n    intentState\n  );\n  assert.strictEqual(pdfPageProxy._intentStates.size, 0);\n});\n",
    "i5_gpt-4o": "it(\"should immediately clear intentStates when a last chunk is received in nonprint mode\", async () => {\n  const { PDFPageProxy } = await import(\"../../src/display/api.js\");\n  const { assert } = await import(\"../../src/shared/util.js\");\n  const dummyTransport = {\n    commonObjs: new Map(),\n    getRenderingIntent: () => ({ renderingIntent: 2, cacheKey: \"test\" }),\n  };\n  const pdfPageProxy = new PDFPageProxy(0, {}, dummyTransport, false);\n  const intentState = {\n    renderTasks: new Set(),\n    operatorList: { fnArray: [], argsArray: [], lastChunk: false, separateAnnots: null },\n  };\n  pdfPageProxy._intentStates.set(\"test\", intentState);\n  pdfPageProxy._renderPageChunk(\n    { fnArray: [], argsArray: [], lastChunk: true, separateAnnots: null },\n    intentState\n  );\n  assert.strictEqual(pdfPageProxy._intentStates.size, 0);\n});\n",
    "i5_llama-3.3-70b-versatile": "it(\"should immediately clear intentStates when a last chunk is received in nonprint mode\", async () => {\n  const { PDFPageProxy } = await import(\"../../src/display/api.js\");\n  const { assert } = await import(\"../../src/shared/util.js\");\n  const dummyTransport = {\n    commonObjs: new Map(),\n    getRenderingIntent: () => ({ renderingIntent: 2, cacheKey: \"test\" }),\n  };\n  const pdfPageProxy = new PDFPageProxy(0, {}, dummyTransport, false);\n  const intentState = {\n    renderTasks: new Set(),\n    operatorList: { fnArray: [], argsArray: [], lastChunk: false, separateAnnots: null },\n  };\n  pdfPageProxy._intentStates.set(\"test\", intentState);\n  pdfPageProxy._renderPageChunk(\n    { fnArray: [], argsArray: [], lastChunk: true, separateAnnots: null },\n    intentState\n  );\n  assert.strictEqual(pdfPageProxy._intentStates.size, 0);\n});\n"
  },
  "19513": {
    "i1_deepseek-r1-distill-llama-70b": "it(\"should not cache null XRef entries so that a later valid entry is fetched\", async () => {\n  const { XRef } = await import(\"../../src/core/xref.js\");\n  const dummyStream = {};\n  const dummyPdfManager = {};\n  const dummyRef = { num: 1, toString: () => \"1 0 R\" };\n  let callCount = 0;\n  const fakeXRef = new XRef(dummyStream, dummyPdfManager);\n  fakeXRef.getEntry = function (num) {\n    callCount++;\n    return callCount === 1 ? null : { uncompressed: true };\n  };\n  // First fetch returns null and, in pre-patch, caches the null.\n  const firstFetch = fakeXRef.fetch(dummyRef);\n  // Second fetch:\n  const secondFetch = fakeXRef.fetch(dummyRef);\n  if (secondFetch === null) {\n    throw new Error(\"Bug persists: cached null entry returned on subsequent fetch.\");\n  }\n});",
    "i1_gpt-4o": "it(\"should not cache null XRef entries so that a later valid entry is fetched\", async () => {\n  const { XRef } = await import(\"../../src/core/xref.js\");\n  const dummyStream = {};\n  const dummyPdfManager = {};\n  const dummyRef = { num: 1, toString: () => \"1 0 R\" };\n  let callCount = 0;\n  const fakeXRef = new XRef(dummyStream, dummyPdfManager);\n  fakeXRef.getEntry = function (num) {\n    callCount++;\n    return callCount === 1 ? null : { uncompressed: true };\n  };\n  // First fetch returns null and, in pre-patch, caches the null.\n  const firstFetch = fakeXRef.fetch(dummyRef);\n  // Second fetch:\n  const secondFetch = fakeXRef.fetch(dummyRef);\n  if (secondFetch === null) {\n    throw new Error(\"Bug persists: cached null entry returned on subsequent fetch.\");\n  }\n});",
    "i1_llama-3.3-70b-versatile": "it(\"should not cache null XRef entries so that a later valid entry is fetched\", async () => {\n  const { XRef } = await import(\"../../src/core/xref.js\");\n  const dummyStream = {};\n  const dummyPdfManager = {};\n  const dummyRef = { num: 1, toString: () => \"1 0 R\" };\n  let callCount = 0;\n  const fakeXRef = new XRef(dummyStream, dummyPdfManager);\n  fakeXRef.getEntry = function (num) {\n    callCount++;\n    return callCount === 1 ? null : { uncompressed: true };\n  };\n  // First fetch returns null and, in pre-patch, caches the null.\n  const firstFetch = fakeXRef.fetch(dummyRef);\n  // Second fetch:\n  const secondFetch = fakeXRef.fetch(dummyRef);\n  if (secondFetch === null) {\n    throw new Error(\"Bug persists: cached null entry returned on subsequent fetch.\");\n  }\n});",
    "i1_MOCK": "it(\"should not cache null XRef entries so that a later valid entry is fetched\", async () => {\n  const { XRef } = await import(\"../../src/core/xref.js\");\n  const dummyStream = {};\n  const dummyPdfManager = {};\n  const dummyRef = { num: 1, toString: () => \"1 0 R\" };\n  let callCount = 0;\n  const fakeXRef = new XRef(dummyStream, dummyPdfManager);\n  fakeXRef.getEntry = function (num) {\n    callCount++;\n    return callCount === 1 ? null : { uncompressed: true };\n  };\n  // First fetch returns null and, in pre-patch, caches the null.\n  const firstFetch = fakeXRef.fetch(dummyRef);\n  // Second fetch:\n  const secondFetch = fakeXRef.fetch(dummyRef);\n  if (secondFetch === null) {\n    throw new Error(\"Bug persists: cached null entry returned on subsequent fetch.\");\n  }\n});",
    "i2_deepseek-r1-distill-llama-70b": "it(\"should not cache null XRef entries so that a later valid entry is fetched\", async () => {\n  const { XRef } = await import(\"../../src/core/xref.js\");\n  const dummyStream = {};\n  const dummyPdfManager = {};\n  const dummyRef = { num: 1, toString: () => \"1 0 R\" };\n  let callCount = 0;\n  const fakeXRef = new XRef(dummyStream, dummyPdfManager);\n  fakeXRef.getEntry = function (num) {\n    callCount++;\n    return callCount === 1 ? null : { uncompressed: true };\n  };\n  // First fetch returns null and, in pre-patch, caches the null.\n  const firstFetch = fakeXRef.fetch(dummyRef);\n  // Second fetch:\n  const secondFetch = fakeXRef.fetch(dummyRef);\n  if (secondFetch === null) {\n    throw new Error(\"Bug persists: cached null entry returned on subsequent fetch.\");\n  }\n});",
    "i2_gpt-4o": "it(\"should not cache null XRef entries so that a later valid entry is fetched\", async () => {\n  const { XRef } = await import(\"../../src/core/xref.js\");\n  const dummyStream = {};\n  const dummyPdfManager = {};\n  const dummyRef = { num: 1, toString: () => \"1 0 R\" };\n  let callCount = 0;\n  const fakeXRef = new XRef(dummyStream, dummyPdfManager);\n  fakeXRef.getEntry = function (num) {\n    callCount++;\n    return callCount === 1 ? null : { uncompressed: true };\n  };\n  // First fetch returns null and, in pre-patch, caches the null.\n  const firstFetch = fakeXRef.fetch(dummyRef);\n  // Second fetch:\n  const secondFetch = fakeXRef.fetch(dummyRef);\n  if (secondFetch === null) {\n    throw new Error(\"Bug persists: cached null entry returned on subsequent fetch.\");\n  }\n});",
    "i2_llama-3.3-70b-versatile": "it(\"should not cache null XRef entries so that a later valid entry is fetched\", async () => {\n  const { XRef } = await import(\"../../src/core/xref.js\");\n  const dummyStream = {};\n  const dummyPdfManager = {};\n  const dummyRef = { num: 1, toString: () => \"1 0 R\" };\n  let callCount = 0;\n  const fakeXRef = new XRef(dummyStream, dummyPdfManager);\n  fakeXRef.getEntry = function (num) {\n    callCount++;\n    return callCount === 1 ? null : { uncompressed: true };\n  };\n  // First fetch returns null and, in pre-patch, caches the null.\n  const firstFetch = fakeXRef.fetch(dummyRef);\n  // Second fetch:\n  const secondFetch = fakeXRef.fetch(dummyRef);\n  if (secondFetch === null) {\n    throw new Error(\"Bug persists: cached null entry returned on subsequent fetch.\");\n  }\n});",
    "i3_deepseek-r1-distill-llama-70b": "it(\"should not cache null XRef entries so that a later valid entry is fetched\", async () => {\n  const { XRef } = await import(\"../../src/core/xref.js\");\n  const dummyStream = {};\n  const dummyPdfManager = {};\n  const dummyRef = { num: 1, toString: () => \"1 0 R\" };\n  let callCount = 0;\n  const fakeXRef = new XRef(dummyStream, dummyPdfManager);\n  fakeXRef.getEntry = function (num) {\n    callCount++;\n    return callCount === 1 ? null : { uncompressed: true };\n  };\n  // First fetch returns null and, in pre-patch, caches the null.\n  const firstFetch = fakeXRef.fetch(dummyRef);\n  // Second fetch:\n  const secondFetch = fakeXRef.fetch(dummyRef);\n  if (secondFetch === null) {\n    throw new Error(\"Bug persists: cached null entry returned on subsequent fetch.\");\n  }\n});",
    "i3_gpt-4o": "it(\"should not cache null XRef entries so that a later valid entry is fetched\", async () => {\n  const { XRef } = await import(\"../../src/core/xref.js\");\n  const dummyStream = {};\n  const dummyPdfManager = {};\n  const dummyRef = { num: 1, toString: () => \"1 0 R\" };\n  let callCount = 0;\n  const fakeXRef = new XRef(dummyStream, dummyPdfManager);\n  fakeXRef.getEntry = function (num) {\n    callCount++;\n    return callCount === 1 ? null : { uncompressed: true };\n  };\n  // First fetch returns null and, in pre-patch, caches the null.\n  const firstFetch = fakeXRef.fetch(dummyRef);\n  // Second fetch:\n  const secondFetch = fakeXRef.fetch(dummyRef);\n  if (secondFetch === null) {\n    throw new Error(\"Bug persists: cached null entry returned on subsequent fetch.\");\n  }\n});",
    "i3_llama-3.3-70b-versatile": "it(\"should not cache null XRef entries so that a later valid entry is fetched\", async () => {\n  const { XRef } = await import(\"../../src/core/xref.js\");\n  const dummyStream = {};\n  const dummyPdfManager = {};\n  const dummyRef = { num: 1, toString: () => \"1 0 R\" };\n  let callCount = 0;\n  const fakeXRef = new XRef(dummyStream, dummyPdfManager);\n  fakeXRef.getEntry = function (num) {\n    callCount++;\n    return callCount === 1 ? null : { uncompressed: true };\n  };\n  // First fetch returns null and, in pre-patch, caches the null.\n  const firstFetch = fakeXRef.fetch(dummyRef);\n  // Second fetch:\n  const secondFetch = fakeXRef.fetch(dummyRef);\n  if (secondFetch === null) {\n    throw new Error(\"Bug persists: cached null entry returned on subsequent fetch.\");\n  }\n});",
    "i4_deepseek-r1-distill-llama-70b": "it(\"should not cache null XRef entries so that a later valid entry is fetched\", async () => {\n  const { XRef } = await import(\"../../src/core/xref.js\");\n  const dummyStream = {};\n  const dummyPdfManager = {};\n  const dummyRef = { num: 1, toString: () => \"1 0 R\" };\n  let callCount = 0;\n  const fakeXRef = new XRef(dummyStream, dummyPdfManager);\n  fakeXRef.getEntry = function (num) {\n    callCount++;\n    return callCount === 1 ? null : { uncompressed: true };\n  };\n  // First fetch returns null and, in pre-patch, caches the null.\n  const firstFetch = fakeXRef.fetch(dummyRef);\n  // Second fetch:\n  const secondFetch = fakeXRef.fetch(dummyRef);\n  if (secondFetch === null) {\n    throw new Error(\"Bug persists: cached null entry returned on subsequent fetch.\");\n  }\n});",
    "i4_gpt-4o": "it(\"should not cache null XRef entries so that a later valid entry is fetched\", async () => {\n  const { XRef } = await import(\"../../src/core/xref.js\");\n  const dummyStream = {};\n  const dummyPdfManager = {};\n  const dummyRef = { num: 1, toString: () => \"1 0 R\" };\n  let callCount = 0;\n  const fakeXRef = new XRef(dummyStream, dummyPdfManager);\n  fakeXRef.getEntry = function (num) {\n    callCount++;\n    return callCount === 1 ? null : { uncompressed: true };\n  };\n  // First fetch returns null and, in pre-patch, caches the null.\n  const firstFetch = fakeXRef.fetch(dummyRef);\n  // Second fetch:\n  const secondFetch = fakeXRef.fetch(dummyRef);\n  if (secondFetch === null) {\n    throw new Error(\"Bug persists: cached null entry returned on subsequent fetch.\");\n  }\n});",
    "i4_llama-3.3-70b-versatile": "it(\"should not cache null XRef entries so that a later valid entry is fetched\", async () => {\n  const { XRef } = await import(\"../../src/core/xref.js\");\n  const dummyStream = {};\n  const dummyPdfManager = {};\n  const dummyRef = { num: 1, toString: () => \"1 0 R\" };\n  let callCount = 0;\n  const fakeXRef = new XRef(dummyStream, dummyPdfManager);\n  fakeXRef.getEntry = function (num) {\n    callCount++;\n    return callCount === 1 ? null : { uncompressed: true };\n  };\n  // First fetch returns null and, in pre-patch, caches the null.\n  const firstFetch = fakeXRef.fetch(dummyRef);\n  // Second fetch:\n  const secondFetch = fakeXRef.fetch(dummyRef);\n  if (secondFetch === null) {\n    throw new Error(\"Bug persists: cached null entry returned on subsequent fetch.\");\n  }\n});",
    "i5_deepseek-r1-distill-llama-70b": "it(\"should not cache null XRef entries so that a later valid entry is fetched\", async () => {\n  const { XRef } = await import(\"../../src/core/xref.js\");\n  const dummyStream = {};\n  const dummyPdfManager = {};\n  const dummyRef = { num: 1, toString: () => \"1 0 R\" };\n  let callCount = 0;\n  const fakeXRef = new XRef(dummyStream, dummyPdfManager);\n  fakeXRef.getEntry = function (num) {\n    callCount++;\n    return callCount === 1 ? null : { uncompressed: true };\n  };\n  // First fetch returns null and, in pre-patch, caches the null.\n  const firstFetch = fakeXRef.fetch(dummyRef);\n  // Second fetch:\n  const secondFetch = fakeXRef.fetch(dummyRef);\n  if (secondFetch === null) {\n    throw new Error(\"Bug persists: cached null entry returned on subsequent fetch.\");\n  }\n});",
    "i5_gpt-4o": "it(\"should not cache null XRef entries so that a later valid entry is fetched\", async () => {\n  const { XRef } = await import(\"../../src/core/xref.js\");\n  const dummyStream = {};\n  const dummyPdfManager = {};\n  const dummyRef = { num: 1, toString: () => \"1 0 R\" };\n  let callCount = 0;\n  const fakeXRef = new XRef(dummyStream, dummyPdfManager);\n  fakeXRef.getEntry = function (num) {\n    callCount++;\n    return callCount === 1 ? null : { uncompressed: true };\n  };\n  // First fetch returns null and, in pre-patch, caches the null.\n  const firstFetch = fakeXRef.fetch(dummyRef);\n  // Second fetch:\n  const secondFetch = fakeXRef.fetch(dummyRef);\n  if (secondFetch === null) {\n    throw new Error(\"Bug persists: cached null entry returned on subsequent fetch.\");\n  }\n});",
    "i5_llama-3.3-70b-versatile": "it(\"should not cache null XRef entries so that a later valid entry is fetched\", async () => {\n  const { XRef } = await import(\"../../src/core/xref.js\");\n  const dummyStream = {};\n  const dummyPdfManager = {};\n  const dummyRef = { num: 1, toString: () => \"1 0 R\" };\n  let callCount = 0;\n  const fakeXRef = new XRef(dummyStream, dummyPdfManager);\n  fakeXRef.getEntry = function (num) {\n    callCount++;\n    return callCount === 1 ? null : { uncompressed: true };\n  };\n  // First fetch returns null and, in pre-patch, caches the null.\n  const firstFetch = fakeXRef.fetch(dummyRef);\n  // Second fetch:\n  const secondFetch = fakeXRef.fetch(dummyRef);\n  if (secondFetch === null) {\n    throw new Error(\"Bug persists: cached null entry returned on subsequent fetch.\");\n  }\n});"
  },
  "19533": {
    "i1_deepseek-r1-distill-llama-70b": "it(\"should apply textRise offset on text translation in Type3 fonts\", async () => {\n  const { CanvasGraphics } = await import(\"../../src/display/canvas.js\");\n  const { strict: assert } = await import(\"assert\");\n  const fakeCtx = {\n    translateCalls: [],\n    save() {},\n    restore() {},\n    transform(..._args) {},\n    translate(x, y) {\n      this.translateCalls.push([x, y]);\n    },\n    scale(..._args) {}\n  };\n  const commonObjs = {};\n  const objs = {};\n  const canvasFactory = {};\n  const filterFactory = {};\n  const optionalContentConfig = {};\n  const annotationCanvasMap = {};\n  const pageColors = {};\n  const canvasGraphics = new CanvasGraphics(\n    fakeCtx,\n    commonObjs,\n    objs,\n    canvasFactory,\n    filterFactory,\n    { optionalContentConfig },\n    annotationCanvasMap,\n    pageColors\n  );\n  canvasGraphics.current.textMatrix = [1, 0, 0, 1, 0, 0];\n  canvasGraphics.current.x = 10;\n  canvasGraphics.current.y = 20;\n  canvasGraphics.current.textRise = 5;\n  canvasGraphics.current.textHScale = 1;\n  canvasGraphics.current.fontDirection = 1;\n  canvasGraphics.current.fontSize = 10;\n  canvasGraphics.current.font = { charProcOperatorList: {} };\n  canvasGraphics.showType3Text([]);\n  assert.strictEqual(fakeCtx.translateCalls.length, 1);\n  const [tx, ty] = fakeCtx.translateCalls[0];\n  assert.strictEqual(tx, 10);\n  assert.strictEqual(ty, 25);\n});",
    "i1_gpt-4o": "it(\"should apply textRise offset on text translation in Type3 fonts\", async () => {\n  const { CanvasGraphics } = await import(\"../../src/display/canvas.js\");\n  const { strict: assert } = await import(\"assert\");\n  const fakeCtx = {\n    translateCalls: [],\n    save() {},\n    restore() {},\n    transform(..._args) {},\n    translate(x, y) {\n      this.translateCalls.push([x, y]);\n    },\n    scale(..._args) {}\n  };\n  const commonObjs = {};\n  const objs = {};\n  const canvasFactory = {};\n  const filterFactory = {};\n  const optionalContentConfig = {};\n  const annotationCanvasMap = {};\n  const pageColors = {};\n  const canvasGraphics = new CanvasGraphics(\n    fakeCtx,\n    commonObjs,\n    objs,\n    canvasFactory,\n    filterFactory,\n    { optionalContentConfig },\n    annotationCanvasMap,\n    pageColors\n  );\n  canvasGraphics.current.textMatrix = [1, 0, 0, 1, 0, 0];\n  canvasGraphics.current.x = 10;\n  canvasGraphics.current.y = 20;\n  canvasGraphics.current.textRise = 5;\n  canvasGraphics.current.textHScale = 1;\n  canvasGraphics.current.fontDirection = 1;\n  canvasGraphics.current.fontSize = 10;\n  canvasGraphics.current.font = { charProcOperatorList: {} };\n  canvasGraphics.showType3Text([]);\n  assert.strictEqual(fakeCtx.translateCalls.length, 1);\n  const [tx, ty] = fakeCtx.translateCalls[0];\n  assert.strictEqual(tx, 10);\n  assert.strictEqual(ty, 25);\n});",
    "i1_llama-3.3-70b-versatile": "it(\"should apply textRise offset on text translation in Type3 fonts\", async () => {\n  const { CanvasGraphics } = await import(\"../../src/display/canvas.js\");\n  const { strict: assert } = await import(\"assert\");\n  const fakeCtx = {\n    translateCalls: [],\n    save() {},\n    restore() {},\n    transform(..._args) {},\n    translate(x, y) {\n      this.translateCalls.push([x, y]);\n    },\n    scale(..._args) {}\n  };\n  const commonObjs = {};\n  const objs = {};\n  const canvasFactory = {};\n  const filterFactory = {};\n  const optionalContentConfig = {};\n  const annotationCanvasMap = {};\n  const pageColors = {};\n  const canvasGraphics = new CanvasGraphics(\n    fakeCtx,\n    commonObjs,\n    objs,\n    canvasFactory,\n    filterFactory,\n    { optionalContentConfig },\n    annotationCanvasMap,\n    pageColors\n  );\n  canvasGraphics.current.textMatrix = [1, 0, 0, 1, 0, 0];\n  canvasGraphics.current.x = 10;\n  canvasGraphics.current.y = 20;\n  canvasGraphics.current.textRise = 5;\n  canvasGraphics.current.textHScale = 1;\n  canvasGraphics.current.fontDirection = 1;\n  canvasGraphics.current.fontSize = 10;\n  canvasGraphics.current.font = { charProcOperatorList: {} };\n  canvasGraphics.showType3Text([]);\n  assert.strictEqual(fakeCtx.translateCalls.length, 1);\n  const [tx, ty] = fakeCtx.translateCalls[0];\n  assert.strictEqual(tx, 10);\n  assert.strictEqual(ty, 25);\n});",
    "i1_MOCK": "it(\"should apply textRise offset on text translation in Type3 fonts\", async () => {\n  const { CanvasGraphics } = await import(\"../../src/display/canvas.js\");\n  const { strict: assert } = await import(\"assert\");\n  const fakeCtx = {\n    translateCalls: [],\n    save() {},\n    restore() {},\n    transform(..._args) {},\n    translate(x, y) {\n      this.translateCalls.push([x, y]);\n    },\n    scale(..._args) {}\n  };\n  const commonObjs = {};\n  const objs = {};\n  const canvasFactory = {};\n  const filterFactory = {};\n  const optionalContentConfig = {};\n  const annotationCanvasMap = {};\n  const pageColors = {};\n  const canvasGraphics = new CanvasGraphics(\n    fakeCtx,\n    commonObjs,\n    objs,\n    canvasFactory,\n    filterFactory,\n    { optionalContentConfig },\n    annotationCanvasMap,\n    pageColors\n  );\n  canvasGraphics.current.textMatrix = [1, 0, 0, 1, 0, 0];\n  canvasGraphics.current.x = 10;\n  canvasGraphics.current.y = 20;\n  canvasGraphics.current.textRise = 5;\n  canvasGraphics.current.textHScale = 1;\n  canvasGraphics.current.fontDirection = 1;\n  canvasGraphics.current.fontSize = 10;\n  canvasGraphics.current.font = { charProcOperatorList: {} };\n  canvasGraphics.showType3Text([]);\n  assert.strictEqual(fakeCtx.translateCalls.length, 1);\n  const [tx, ty] = fakeCtx.translateCalls[0];\n  assert.strictEqual(tx, 10);\n  assert.strictEqual(ty, 25);\n});",
    "i2_deepseek-r1-distill-llama-70b": "it(\"should apply textRise offset on text translation in Type3 fonts\", async () => {\n  const { CanvasGraphics } = await import(\"../../src/display/canvas.js\");\n  const { strict: assert } = await import(\"assert\");\n  const fakeCtx = {\n    translateCalls: [],\n    save() {},\n    restore() {},\n    transform(..._args) {},\n    translate(x, y) {\n      this.translateCalls.push([x, y]);\n    },\n    scale(..._args) {}\n  };\n  const commonObjs = {};\n  const objs = {};\n  const canvasFactory = {};\n  const filterFactory = {};\n  const optionalContentConfig = {};\n  const annotationCanvasMap = {};\n  const pageColors = {};\n  const canvasGraphics = new CanvasGraphics(\n    fakeCtx,\n    commonObjs,\n    objs,\n    canvasFactory,\n    filterFactory,\n    { optionalContentConfig },\n    annotationCanvasMap,\n    pageColors\n  );\n  canvasGraphics.current.textMatrix = [1, 0, 0, 1, 0, 0];\n  canvasGraphics.current.x = 10;\n  canvasGraphics.current.y = 20;\n  canvasGraphics.current.textRise = 5;\n  canvasGraphics.current.textHScale = 1;\n  canvasGraphics.current.fontDirection = 1;\n  canvasGraphics.current.fontSize = 10;\n  canvasGraphics.current.font = { charProcOperatorList: {} };\n  canvasGraphics.showType3Text([]);\n  assert.strictEqual(fakeCtx.translateCalls.length, 1);\n  const [tx, ty] = fakeCtx.translateCalls[0];\n  assert.strictEqual(tx, 10);\n  assert.strictEqual(ty, 25);\n});",
    "i2_gpt-4o": "it(\"should apply textRise offset on text translation in Type3 fonts\", async () => {\n  const { CanvasGraphics } = await import(\"../../src/display/canvas.js\");\n  const { strict: assert } = await import(\"assert\");\n  const fakeCtx = {\n    translateCalls: [],\n    save() {},\n    restore() {},\n    transform(..._args) {},\n    translate(x, y) {\n      this.translateCalls.push([x, y]);\n    },\n    scale(..._args) {}\n  };\n  const commonObjs = {};\n  const objs = {};\n  const canvasFactory = {};\n  const filterFactory = {};\n  const optionalContentConfig = {};\n  const annotationCanvasMap = {};\n  const pageColors = {};\n  const canvasGraphics = new CanvasGraphics(\n    fakeCtx,\n    commonObjs,\n    objs,\n    canvasFactory,\n    filterFactory,\n    { optionalContentConfig },\n    annotationCanvasMap,\n    pageColors\n  );\n  canvasGraphics.current.textMatrix = [1, 0, 0, 1, 0, 0];\n  canvasGraphics.current.x = 10;\n  canvasGraphics.current.y = 20;\n  canvasGraphics.current.textRise = 5;\n  canvasGraphics.current.textHScale = 1;\n  canvasGraphics.current.fontDirection = 1;\n  canvasGraphics.current.fontSize = 10;\n  canvasGraphics.current.font = { charProcOperatorList: {} };\n  canvasGraphics.showType3Text([]);\n  assert.strictEqual(fakeCtx.translateCalls.length, 1);\n  const [tx, ty] = fakeCtx.translateCalls[0];\n  assert.strictEqual(tx, 10);\n  assert.strictEqual(ty, 25);\n});",
    "i2_llama-3.3-70b-versatile": "it(\"should apply textRise offset on text translation in Type3 fonts\", async () => {\n  const { CanvasGraphics } = await import(\"../../src/display/canvas.js\");\n  const { strict: assert } = await import(\"assert\");\n  const fakeCtx = {\n    translateCalls: [],\n    save() {},\n    restore() {},\n    transform(..._args) {},\n    translate(x, y) {\n      this.translateCalls.push([x, y]);\n    },\n    scale(..._args) {}\n  };\n  const commonObjs = {};\n  const objs = {};\n  const canvasFactory = {};\n  const filterFactory = {};\n  const optionalContentConfig = {};\n  const annotationCanvasMap = {};\n  const pageColors = {};\n  const canvasGraphics = new CanvasGraphics(\n    fakeCtx,\n    commonObjs,\n    objs,\n    canvasFactory,\n    filterFactory,\n    { optionalContentConfig },\n    annotationCanvasMap,\n    pageColors\n  );\n  canvasGraphics.current.textMatrix = [1, 0, 0, 1, 0, 0];\n  canvasGraphics.current.x = 10;\n  canvasGraphics.current.y = 20;\n  canvasGraphics.current.textRise = 5;\n  canvasGraphics.current.textHScale = 1;\n  canvasGraphics.current.fontDirection = 1;\n  canvasGraphics.current.fontSize = 10;\n  canvasGraphics.current.font = { charProcOperatorList: {} };\n  canvasGraphics.showType3Text([]);\n  assert.strictEqual(fakeCtx.translateCalls.length, 1);\n  const [tx, ty] = fakeCtx.translateCalls[0];\n  assert.strictEqual(tx, 10);\n  assert.strictEqual(ty, 25);\n});",
    "i3_deepseek-r1-distill-llama-70b": "it(\"should apply textRise offset on text translation in Type3 fonts\", async () => {\n  const { CanvasGraphics } = await import(\"../../src/display/canvas.js\");\n  const { strict: assert } = await import(\"assert\");\n  const fakeCtx = {\n    translateCalls: [],\n    save() {},\n    restore() {},\n    transform(..._args) {},\n    translate(x, y) {\n      this.translateCalls.push([x, y]);\n    },\n    scale(..._args) {}\n  };\n  const commonObjs = {};\n  const objs = {};\n  const canvasFactory = {};\n  const filterFactory = {};\n  const optionalContentConfig = {};\n  const annotationCanvasMap = {};\n  const pageColors = {};\n  const canvasGraphics = new CanvasGraphics(\n    fakeCtx,\n    commonObjs,\n    objs,\n    canvasFactory,\n    filterFactory,\n    { optionalContentConfig },\n    annotationCanvasMap,\n    pageColors\n  );\n  canvasGraphics.current.textMatrix = [1, 0, 0, 1, 0, 0];\n  canvasGraphics.current.x = 10;\n  canvasGraphics.current.y = 20;\n  canvasGraphics.current.textRise = 5;\n  canvasGraphics.current.textHScale = 1;\n  canvasGraphics.current.fontDirection = 1;\n  canvasGraphics.current.fontSize = 10;\n  canvasGraphics.current.font = { charProcOperatorList: {} };\n  canvasGraphics.showType3Text([]);\n  assert.strictEqual(fakeCtx.translateCalls.length, 1);\n  const [tx, ty] = fakeCtx.translateCalls[0];\n  assert.strictEqual(tx, 10);\n  assert.strictEqual(ty, 25);\n});",
    "i3_gpt-4o": "it(\"should apply textRise offset on text translation in Type3 fonts\", async () => {\n  const { CanvasGraphics } = await import(\"../../src/display/canvas.js\");\n  const { strict: assert } = await import(\"assert\");\n  const fakeCtx = {\n    translateCalls: [],\n    save() {},\n    restore() {},\n    transform(..._args) {},\n    translate(x, y) {\n      this.translateCalls.push([x, y]);\n    },\n    scale(..._args) {}\n  };\n  const commonObjs = {};\n  const objs = {};\n  const canvasFactory = {};\n  const filterFactory = {};\n  const optionalContentConfig = {};\n  const annotationCanvasMap = {};\n  const pageColors = {};\n  const canvasGraphics = new CanvasGraphics(\n    fakeCtx,\n    commonObjs,\n    objs,\n    canvasFactory,\n    filterFactory,\n    { optionalContentConfig },\n    annotationCanvasMap,\n    pageColors\n  );\n  canvasGraphics.current.textMatrix = [1, 0, 0, 1, 0, 0];\n  canvasGraphics.current.x = 10;\n  canvasGraphics.current.y = 20;\n  canvasGraphics.current.textRise = 5;\n  canvasGraphics.current.textHScale = 1;\n  canvasGraphics.current.fontDirection = 1;\n  canvasGraphics.current.fontSize = 10;\n  canvasGraphics.current.font = { charProcOperatorList: {} };\n  canvasGraphics.showType3Text([]);\n  assert.strictEqual(fakeCtx.translateCalls.length, 1);\n  const [tx, ty] = fakeCtx.translateCalls[0];\n  assert.strictEqual(tx, 10);\n  assert.strictEqual(ty, 25);\n});",
    "i3_llama-3.3-70b-versatile": "it(\"should apply textRise offset on text translation in Type3 fonts\", async () => {\n  const { CanvasGraphics } = await import(\"../../src/display/canvas.js\");\n  const { strict: assert } = await import(\"assert\");\n  const fakeCtx = {\n    translateCalls: [],\n    save() {},\n    restore() {},\n    transform(..._args) {},\n    translate(x, y) {\n      this.translateCalls.push([x, y]);\n    },\n    scale(..._args) {}\n  };\n  const commonObjs = {};\n  const objs = {};\n  const canvasFactory = {};\n  const filterFactory = {};\n  const optionalContentConfig = {};\n  const annotationCanvasMap = {};\n  const pageColors = {};\n  const canvasGraphics = new CanvasGraphics(\n    fakeCtx,\n    commonObjs,\n    objs,\n    canvasFactory,\n    filterFactory,\n    { optionalContentConfig },\n    annotationCanvasMap,\n    pageColors\n  );\n  canvasGraphics.current.textMatrix = [1, 0, 0, 1, 0, 0];\n  canvasGraphics.current.x = 10;\n  canvasGraphics.current.y = 20;\n  canvasGraphics.current.textRise = 5;\n  canvasGraphics.current.textHScale = 1;\n  canvasGraphics.current.fontDirection = 1;\n  canvasGraphics.current.fontSize = 10;\n  canvasGraphics.current.font = { charProcOperatorList: {} };\n  canvasGraphics.showType3Text([]);\n  assert.strictEqual(fakeCtx.translateCalls.length, 1);\n  const [tx, ty] = fakeCtx.translateCalls[0];\n  assert.strictEqual(tx, 10);\n  assert.strictEqual(ty, 25);\n});",
    "i4_deepseek-r1-distill-llama-70b": "it(\"should apply textRise offset on text translation in Type3 fonts\", async () => {\n  const { CanvasGraphics } = await import(\"../../src/display/canvas.js\");\n  const { strict: assert } = await import(\"assert\");\n  const fakeCtx = {\n    translateCalls: [],\n    save() {},\n    restore() {},\n    transform(..._args) {},\n    translate(x, y) {\n      this.translateCalls.push([x, y]);\n    },\n    scale(..._args) {}\n  };\n  const commonObjs = {};\n  const objs = {};\n  const canvasFactory = {};\n  const filterFactory = {};\n  const optionalContentConfig = {};\n  const annotationCanvasMap = {};\n  const pageColors = {};\n  const canvasGraphics = new CanvasGraphics(\n    fakeCtx,\n    commonObjs,\n    objs,\n    canvasFactory,\n    filterFactory,\n    { optionalContentConfig },\n    annotationCanvasMap,\n    pageColors\n  );\n  canvasGraphics.current.textMatrix = [1, 0, 0, 1, 0, 0];\n  canvasGraphics.current.x = 10;\n  canvasGraphics.current.y = 20;\n  canvasGraphics.current.textRise = 5;\n  canvasGraphics.current.textHScale = 1;\n  canvasGraphics.current.fontDirection = 1;\n  canvasGraphics.current.fontSize = 10;\n  canvasGraphics.current.font = { charProcOperatorList: {} };\n  canvasGraphics.showType3Text([]);\n  assert.strictEqual(fakeCtx.translateCalls.length, 1);\n  const [tx, ty] = fakeCtx.translateCalls[0];\n  assert.strictEqual(tx, 10);\n  assert.strictEqual(ty, 25);\n});",
    "i4_gpt-4o": "it(\"should apply textRise offset on text translation in Type3 fonts\", async () => {\n  const { CanvasGraphics } = await import(\"../../src/display/canvas.js\");\n  const { strict: assert } = await import(\"assert\");\n  const fakeCtx = {\n    translateCalls: [],\n    save() {},\n    restore() {},\n    transform(..._args) {},\n    translate(x, y) {\n      this.translateCalls.push([x, y]);\n    },\n    scale(..._args) {}\n  };\n  const commonObjs = {};\n  const objs = {};\n  const canvasFactory = {};\n  const filterFactory = {};\n  const optionalContentConfig = {};\n  const annotationCanvasMap = {};\n  const pageColors = {};\n  const canvasGraphics = new CanvasGraphics(\n    fakeCtx,\n    commonObjs,\n    objs,\n    canvasFactory,\n    filterFactory,\n    { optionalContentConfig },\n    annotationCanvasMap,\n    pageColors\n  );\n  canvasGraphics.current.textMatrix = [1, 0, 0, 1, 0, 0];\n  canvasGraphics.current.x = 10;\n  canvasGraphics.current.y = 20;\n  canvasGraphics.current.textRise = 5;\n  canvasGraphics.current.textHScale = 1;\n  canvasGraphics.current.fontDirection = 1;\n  canvasGraphics.current.fontSize = 10;\n  canvasGraphics.current.font = { charProcOperatorList: {} };\n  canvasGraphics.showType3Text([]);\n  assert.strictEqual(fakeCtx.translateCalls.length, 1);\n  const [tx, ty] = fakeCtx.translateCalls[0];\n  assert.strictEqual(tx, 10);\n  assert.strictEqual(ty, 25);\n});",
    "i4_llama-3.3-70b-versatile": "it(\"should apply textRise offset on text translation in Type3 fonts\", async () => {\n  const { CanvasGraphics } = await import(\"../../src/display/canvas.js\");\n  const { strict: assert } = await import(\"assert\");\n  const fakeCtx = {\n    translateCalls: [],\n    save() {},\n    restore() {},\n    transform(..._args) {},\n    translate(x, y) {\n      this.translateCalls.push([x, y]);\n    },\n    scale(..._args) {}\n  };\n  const commonObjs = {};\n  const objs = {};\n  const canvasFactory = {};\n  const filterFactory = {};\n  const optionalContentConfig = {};\n  const annotationCanvasMap = {};\n  const pageColors = {};\n  const canvasGraphics = new CanvasGraphics(\n    fakeCtx,\n    commonObjs,\n    objs,\n    canvasFactory,\n    filterFactory,\n    { optionalContentConfig },\n    annotationCanvasMap,\n    pageColors\n  );\n  canvasGraphics.current.textMatrix = [1, 0, 0, 1, 0, 0];\n  canvasGraphics.current.x = 10;\n  canvasGraphics.current.y = 20;\n  canvasGraphics.current.textRise = 5;\n  canvasGraphics.current.textHScale = 1;\n  canvasGraphics.current.fontDirection = 1;\n  canvasGraphics.current.fontSize = 10;\n  canvasGraphics.current.font = { charProcOperatorList: {} };\n  canvasGraphics.showType3Text([]);\n  assert.strictEqual(fakeCtx.translateCalls.length, 1);\n  const [tx, ty] = fakeCtx.translateCalls[0];\n  assert.strictEqual(tx, 10);\n  assert.strictEqual(ty, 25);\n});",
    "i5_deepseek-r1-distill-llama-70b": "it(\"should apply textRise offset on text translation in Type3 fonts\", async () => {\n  const { CanvasGraphics } = await import(\"../../src/display/canvas.js\");\n  const { strict: assert } = await import(\"assert\");\n  const fakeCtx = {\n    translateCalls: [],\n    save() {},\n    restore() {},\n    transform(..._args) {},\n    translate(x, y) {\n      this.translateCalls.push([x, y]);\n    },\n    scale(..._args) {}\n  };\n  const commonObjs = {};\n  const objs = {};\n  const canvasFactory = {};\n  const filterFactory = {};\n  const optionalContentConfig = {};\n  const annotationCanvasMap = {};\n  const pageColors = {};\n  const canvasGraphics = new CanvasGraphics(\n    fakeCtx,\n    commonObjs,\n    objs,\n    canvasFactory,\n    filterFactory,\n    { optionalContentConfig },\n    annotationCanvasMap,\n    pageColors\n  );\n  canvasGraphics.current.textMatrix = [1, 0, 0, 1, 0, 0];\n  canvasGraphics.current.x = 10;\n  canvasGraphics.current.y = 20;\n  canvasGraphics.current.textRise = 5;\n  canvasGraphics.current.textHScale = 1;\n  canvasGraphics.current.fontDirection = 1;\n  canvasGraphics.current.fontSize = 10;\n  canvasGraphics.current.font = { charProcOperatorList: {} };\n  canvasGraphics.showType3Text([]);\n  assert.strictEqual(fakeCtx.translateCalls.length, 1);\n  const [tx, ty] = fakeCtx.translateCalls[0];\n  assert.strictEqual(tx, 10);\n  assert.strictEqual(ty, 25);\n});",
    "i5_gpt-4o": "it(\"should apply textRise offset on text translation in Type3 fonts\", async () => {\n  const { CanvasGraphics } = await import(\"../../src/display/canvas.js\");\n  const { strict: assert } = await import(\"assert\");\n  const fakeCtx = {\n    translateCalls: [],\n    save() {},\n    restore() {},\n    transform(..._args) {},\n    translate(x, y) {\n      this.translateCalls.push([x, y]);\n    },\n    scale(..._args) {}\n  };\n  const commonObjs = {};\n  const objs = {};\n  const canvasFactory = {};\n  const filterFactory = {};\n  const optionalContentConfig = {};\n  const annotationCanvasMap = {};\n  const pageColors = {};\n  const canvasGraphics = new CanvasGraphics(\n    fakeCtx,\n    commonObjs,\n    objs,\n    canvasFactory,\n    filterFactory,\n    { optionalContentConfig },\n    annotationCanvasMap,\n    pageColors\n  );\n  canvasGraphics.current.textMatrix = [1, 0, 0, 1, 0, 0];\n  canvasGraphics.current.x = 10;\n  canvasGraphics.current.y = 20;\n  canvasGraphics.current.textRise = 5;\n  canvasGraphics.current.textHScale = 1;\n  canvasGraphics.current.fontDirection = 1;\n  canvasGraphics.current.fontSize = 10;\n  canvasGraphics.current.font = { charProcOperatorList: {} };\n  canvasGraphics.showType3Text([]);\n  assert.strictEqual(fakeCtx.translateCalls.length, 1);\n  const [tx, ty] = fakeCtx.translateCalls[0];\n  assert.strictEqual(tx, 10);\n  assert.strictEqual(ty, 25);\n});",
    "i5_llama-3.3-70b-versatile": "it(\"should apply textRise offset on text translation in Type3 fonts\", async () => {\n  const { CanvasGraphics } = await import(\"../../src/display/canvas.js\");\n  const { strict: assert } = await import(\"assert\");\n  const fakeCtx = {\n    translateCalls: [],\n    save() {},\n    restore() {},\n    transform(..._args) {},\n    translate(x, y) {\n      this.translateCalls.push([x, y]);\n    },\n    scale(..._args) {}\n  };\n  const commonObjs = {};\n  const objs = {};\n  const canvasFactory = {};\n  const filterFactory = {};\n  const optionalContentConfig = {};\n  const annotationCanvasMap = {};\n  const pageColors = {};\n  const canvasGraphics = new CanvasGraphics(\n    fakeCtx,\n    commonObjs,\n    objs,\n    canvasFactory,\n    filterFactory,\n    { optionalContentConfig },\n    annotationCanvasMap,\n    pageColors\n  );\n  canvasGraphics.current.textMatrix = [1, 0, 0, 1, 0, 0];\n  canvasGraphics.current.x = 10;\n  canvasGraphics.current.y = 20;\n  canvasGraphics.current.textRise = 5;\n  canvasGraphics.current.textHScale = 1;\n  canvasGraphics.current.fontDirection = 1;\n  canvasGraphics.current.fontSize = 10;\n  canvasGraphics.current.font = { charProcOperatorList: {} };\n  canvasGraphics.showType3Text([]);\n  assert.strictEqual(fakeCtx.translateCalls.length, 1);\n  const [tx, ty] = fakeCtx.translateCalls[0];\n  assert.strictEqual(tx, 10);\n  assert.strictEqual(ty, 25);\n});"
  },
  "19562": {
    "i1_llama-3.3-70b-versatile": "it(\"should render Russian characters correctly\", async () => {\n  const { getDocument } = await import('../../src/display/api.js');\n  const { buildGetDocumentParams } = await import('./test_utils.js');\n  const loadingTask = getDocument(buildGetDocumentParams('issue19550.pdf'));\n  const pdfDocument = await loadingTask.promise;\n  const pdfPage = await pdfDocument.getPage(1);\n  const textContent = await pdfPage.getTextContent();\n  const expectedText = \"Some russian characters\";\n  const actualText = textContent.items.map(item => item.str).join('');\n  expect(actualText).toContain(expectedText);\n});"
  },
  "19613": {
    "i1_deepseek-r1-distill-llama-70b": "it(\"should use fallback dimensions for images with invalid widthheight\", async () => {\n  const { PDFImage } = await import(\"../../src/core/image.js\");\n  const fakeDict = {\n    get(key, alt) {\n      if (key === \"W\" || alt === \"Width\") {\n        return 0;\n      }\n      if (key === \"H\" || alt === \"Height\") {\n        return 0;\n      }\n      return undefined;\n    },\n  };\n  const fakeImage = { dict: fakeDict, fallbackDims: { width: 150, height: 250 } };\n  const fakeXref = { fetchIfRef: (obj) => obj };\n  const pdfImage = new PDFImage({\n    xref: fakeXref,\n    res: {},\n    image: fakeImage,\n    pdfFunctionFactory: {},\n    globalColorSpaceCache: {},\n    localColorSpaceCache: {},\n  });\n  if (pdfImage.width !== 150 || pdfImage.height !== 250) {\n    throw new Error(`Expected fallback dimensions (150x250), but got (${pdfImage.width}x${pdfImage.height}).`);\n  }\n});\n",
    "i1_gpt-4o": "it(\"should use fallback dimensions for images with invalid widthheight\", async () => {\n  const { PDFImage } = await import(\"../../src/core/image.js\");\n  const fakeDict = {\n    get(key, alt) {\n      if (key === \"W\" || alt === \"Width\") {\n        return 0;\n      }\n      if (key === \"H\" || alt === \"Height\") {\n        return 0;\n      }\n      return undefined;\n    },\n  };\n  const fakeImage = { dict: fakeDict, fallbackDims: { width: 150, height: 250 } };\n  const fakeXref = { fetchIfRef: (obj) => obj };\n  const pdfImage = new PDFImage({\n    xref: fakeXref,\n    res: {},\n    image: fakeImage,\n    pdfFunctionFactory: {},\n    globalColorSpaceCache: {},\n    localColorSpaceCache: {},\n  });\n  if (pdfImage.width !== 150 || pdfImage.height !== 250) {\n    throw new Error(`Expected fallback dimensions (150x250), but got (${pdfImage.width}x${pdfImage.height}).`);\n  }\n});\n",
    "i1_llama-3.3-70b-versatile": "it(\"should use fallback dimensions for images with invalid widthheight\", async () => {\n  const { PDFImage } = await import(\"../../src/core/image.js\");\n  const fakeDict = {\n    get(key, alt) {\n      if (key === \"W\" || alt === \"Width\") {\n        return 0;\n      }\n      if (key === \"H\" || alt === \"Height\") {\n        return 0;\n      }\n      return undefined;\n    },\n  };\n  const fakeImage = { dict: fakeDict, fallbackDims: { width: 150, height: 250 } };\n  const fakeXref = { fetchIfRef: (obj) => obj };\n  const pdfImage = new PDFImage({\n    xref: fakeXref,\n    res: {},\n    image: fakeImage,\n    pdfFunctionFactory: {},\n    globalColorSpaceCache: {},\n    localColorSpaceCache: {},\n  });\n  if (pdfImage.width !== 150 || pdfImage.height !== 250) {\n    throw new Error(`Expected fallback dimensions (150x250), but got (${pdfImage.width}x${pdfImage.height}).`);\n  }\n});\n",
    "i1_MOCK": "it(\"should use fallback dimensions for images with invalid widthheight\", async () => {\n  const { PDFImage } = await import(\"../../src/core/image.js\");\n  const fakeDict = {\n    get(key, alt) {\n      if (key === \"W\" || alt === \"Width\") {\n        return 0;\n      }\n      if (key === \"H\" || alt === \"Height\") {\n        return 0;\n      }\n      return undefined;\n    },\n  };\n  const fakeImage = { dict: fakeDict, fallbackDims: { width: 150, height: 250 } };\n  const fakeXref = { fetchIfRef: (obj) => obj };\n  const pdfImage = new PDFImage({\n    xref: fakeXref,\n    res: {},\n    image: fakeImage,\n    pdfFunctionFactory: {},\n    globalColorSpaceCache: {},\n    localColorSpaceCache: {},\n  });\n  if (pdfImage.width !== 150 || pdfImage.height !== 250) {\n    throw new Error(`Expected fallback dimensions (150x250), but got (${pdfImage.width}x${pdfImage.height}).`);\n  }\n});\n",
    "i2_deepseek-r1-distill-llama-70b": "it(\"should use fallback dimensions for images with invalid widthheight\", async () => {\n  const { PDFImage } = await import(\"../../src/core/image.js\");\n  const fakeDict = {\n    get(key, alt) {\n      if (key === \"W\" || alt === \"Width\") {\n        return 0;\n      }\n      if (key === \"H\" || alt === \"Height\") {\n        return 0;\n      }\n      return undefined;\n    },\n  };\n  const fakeImage = { dict: fakeDict, fallbackDims: { width: 150, height: 250 } };\n  const fakeXref = { fetchIfRef: (obj) => obj };\n  const pdfImage = new PDFImage({\n    xref: fakeXref,\n    res: {},\n    image: fakeImage,\n    pdfFunctionFactory: {},\n    globalColorSpaceCache: {},\n    localColorSpaceCache: {},\n  });\n  if (pdfImage.width !== 150 || pdfImage.height !== 250) {\n    throw new Error(`Expected fallback dimensions (150x250), but got (${pdfImage.width}x${pdfImage.height}).`);\n  }\n});\n",
    "i2_gpt-4o": "it(\"should use fallback dimensions for images with invalid widthheight\", async () => {\n  const { PDFImage } = await import(\"../../src/core/image.js\");\n  const fakeDict = {\n    get(key, alt) {\n      if (key === \"W\" || alt === \"Width\") {\n        return 0;\n      }\n      if (key === \"H\" || alt === \"Height\") {\n        return 0;\n      }\n      return undefined;\n    },\n  };\n  const fakeImage = { dict: fakeDict, fallbackDims: { width: 150, height: 250 } };\n  const fakeXref = { fetchIfRef: (obj) => obj };\n  const pdfImage = new PDFImage({\n    xref: fakeXref,\n    res: {},\n    image: fakeImage,\n    pdfFunctionFactory: {},\n    globalColorSpaceCache: {},\n    localColorSpaceCache: {},\n  });\n  if (pdfImage.width !== 150 || pdfImage.height !== 250) {\n    throw new Error(`Expected fallback dimensions (150x250), but got (${pdfImage.width}x${pdfImage.height}).`);\n  }\n});\n",
    "i2_llama-3.3-70b-versatile": "it(\"should use fallback dimensions for images with invalid widthheight\", async () => {\n  const { PDFImage } = await import(\"../../src/core/image.js\");\n  const fakeDict = {\n    get(key, alt) {\n      if (key === \"W\" || alt === \"Width\") {\n        return 0;\n      }\n      if (key === \"H\" || alt === \"Height\") {\n        return 0;\n      }\n      return undefined;\n    },\n  };\n  const fakeImage = { dict: fakeDict, fallbackDims: { width: 150, height: 250 } };\n  const fakeXref = { fetchIfRef: (obj) => obj };\n  const pdfImage = new PDFImage({\n    xref: fakeXref,\n    res: {},\n    image: fakeImage,\n    pdfFunctionFactory: {},\n    globalColorSpaceCache: {},\n    localColorSpaceCache: {},\n  });\n  if (pdfImage.width !== 150 || pdfImage.height !== 250) {\n    throw new Error(`Expected fallback dimensions (150x250), but got (${pdfImage.width}x${pdfImage.height}).`);\n  }\n});\n",
    "i3_deepseek-r1-distill-llama-70b": "it(\"should use fallback dimensions for images with invalid widthheight\", async () => {\n  const { PDFImage } = await import(\"../../src/core/image.js\");\n  const fakeDict = {\n    get(key, alt) {\n      if (key === \"W\" || alt === \"Width\") {\n        return 0;\n      }\n      if (key === \"H\" || alt === \"Height\") {\n        return 0;\n      }\n      return undefined;\n    },\n  };\n  const fakeImage = { dict: fakeDict, fallbackDims: { width: 150, height: 250 } };\n  const fakeXref = { fetchIfRef: (obj) => obj };\n  const pdfImage = new PDFImage({\n    xref: fakeXref,\n    res: {},\n    image: fakeImage,\n    pdfFunctionFactory: {},\n    globalColorSpaceCache: {},\n    localColorSpaceCache: {},\n  });\n  if (pdfImage.width !== 150 || pdfImage.height !== 250) {\n    throw new Error(`Expected fallback dimensions (150x250), but got (${pdfImage.width}x${pdfImage.height}).`);\n  }\n});\n",
    "i3_gpt-4o": "it(\"should use fallback dimensions for images with invalid widthheight\", async () => {\n  const { PDFImage } = await import(\"../../src/core/image.js\");\n  const fakeDict = {\n    get(key, alt) {\n      if (key === \"W\" || alt === \"Width\") {\n        return 0;\n      }\n      if (key === \"H\" || alt === \"Height\") {\n        return 0;\n      }\n      return undefined;\n    },\n  };\n  const fakeImage = { dict: fakeDict, fallbackDims: { width: 150, height: 250 } };\n  const fakeXref = { fetchIfRef: (obj) => obj };\n  const pdfImage = new PDFImage({\n    xref: fakeXref,\n    res: {},\n    image: fakeImage,\n    pdfFunctionFactory: {},\n    globalColorSpaceCache: {},\n    localColorSpaceCache: {},\n  });\n  if (pdfImage.width !== 150 || pdfImage.height !== 250) {\n    throw new Error(`Expected fallback dimensions (150x250), but got (${pdfImage.width}x${pdfImage.height}).`);\n  }\n});\n",
    "i3_llama-3.3-70b-versatile": "it(\"should use fallback dimensions for images with invalid widthheight\", async () => {\n  const { PDFImage } = await import(\"../../src/core/image.js\");\n  const fakeDict = {\n    get(key, alt) {\n      if (key === \"W\" || alt === \"Width\") {\n        return 0;\n      }\n      if (key === \"H\" || alt === \"Height\") {\n        return 0;\n      }\n      return undefined;\n    },\n  };\n  const fakeImage = { dict: fakeDict, fallbackDims: { width: 150, height: 250 } };\n  const fakeXref = { fetchIfRef: (obj) => obj };\n  const pdfImage = new PDFImage({\n    xref: fakeXref,\n    res: {},\n    image: fakeImage,\n    pdfFunctionFactory: {},\n    globalColorSpaceCache: {},\n    localColorSpaceCache: {},\n  });\n  if (pdfImage.width !== 150 || pdfImage.height !== 250) {\n    throw new Error(`Expected fallback dimensions (150x250), but got (${pdfImage.width}x${pdfImage.height}).`);\n  }\n});\n",
    "i4_deepseek-r1-distill-llama-70b": "it(\"should use fallback dimensions for images with invalid widthheight\", async () => {\n  const { PDFImage } = await import(\"../../src/core/image.js\");\n  const fakeDict = {\n    get(key, alt) {\n      if (key === \"W\" || alt === \"Width\") {\n        return 0;\n      }\n      if (key === \"H\" || alt === \"Height\") {\n        return 0;\n      }\n      return undefined;\n    },\n  };\n  const fakeImage = { dict: fakeDict, fallbackDims: { width: 150, height: 250 } };\n  const fakeXref = { fetchIfRef: (obj) => obj };\n  const pdfImage = new PDFImage({\n    xref: fakeXref,\n    res: {},\n    image: fakeImage,\n    pdfFunctionFactory: {},\n    globalColorSpaceCache: {},\n    localColorSpaceCache: {},\n  });\n  if (pdfImage.width !== 150 || pdfImage.height !== 250) {\n    throw new Error(`Expected fallback dimensions (150x250), but got (${pdfImage.width}x${pdfImage.height}).`);\n  }\n});\n",
    "i4_gpt-4o": "it(\"should use fallback dimensions for images with invalid widthheight\", async () => {\n  const { PDFImage } = await import(\"../../src/core/image.js\");\n  const fakeDict = {\n    get(key, alt) {\n      if (key === \"W\" || alt === \"Width\") {\n        return 0;\n      }\n      if (key === \"H\" || alt === \"Height\") {\n        return 0;\n      }\n      return undefined;\n    },\n  };\n  const fakeImage = { dict: fakeDict, fallbackDims: { width: 150, height: 250 } };\n  const fakeXref = { fetchIfRef: (obj) => obj };\n  const pdfImage = new PDFImage({\n    xref: fakeXref,\n    res: {},\n    image: fakeImage,\n    pdfFunctionFactory: {},\n    globalColorSpaceCache: {},\n    localColorSpaceCache: {},\n  });\n  if (pdfImage.width !== 150 || pdfImage.height !== 250) {\n    throw new Error(`Expected fallback dimensions (150x250), but got (${pdfImage.width}x${pdfImage.height}).`);\n  }\n});\n",
    "i4_llama-3.3-70b-versatile": "it(\"should use fallback dimensions for images with invalid widthheight\", async () => {\n  const { PDFImage } = await import(\"../../src/core/image.js\");\n  const fakeDict = {\n    get(key, alt) {\n      if (key === \"W\" || alt === \"Width\") {\n        return 0;\n      }\n      if (key === \"H\" || alt === \"Height\") {\n        return 0;\n      }\n      return undefined;\n    },\n  };\n  const fakeImage = { dict: fakeDict, fallbackDims: { width: 150, height: 250 } };\n  const fakeXref = { fetchIfRef: (obj) => obj };\n  const pdfImage = new PDFImage({\n    xref: fakeXref,\n    res: {},\n    image: fakeImage,\n    pdfFunctionFactory: {},\n    globalColorSpaceCache: {},\n    localColorSpaceCache: {},\n  });\n  if (pdfImage.width !== 150 || pdfImage.height !== 250) {\n    throw new Error(`Expected fallback dimensions (150x250), but got (${pdfImage.width}x${pdfImage.height}).`);\n  }\n});\n",
    "i5_deepseek-r1-distill-llama-70b": "it(\"should use fallback dimensions for images with invalid widthheight\", async () => {\n  const { PDFImage } = await import(\"../../src/core/image.js\");\n  const fakeDict = {\n    get(key, alt) {\n      if (key === \"W\" || alt === \"Width\") {\n        return 0;\n      }\n      if (key === \"H\" || alt === \"Height\") {\n        return 0;\n      }\n      return undefined;\n    },\n  };\n  const fakeImage = { dict: fakeDict, fallbackDims: { width: 150, height: 250 } };\n  const fakeXref = { fetchIfRef: (obj) => obj };\n  const pdfImage = new PDFImage({\n    xref: fakeXref,\n    res: {},\n    image: fakeImage,\n    pdfFunctionFactory: {},\n    globalColorSpaceCache: {},\n    localColorSpaceCache: {},\n  });\n  if (pdfImage.width !== 150 || pdfImage.height !== 250) {\n    throw new Error(`Expected fallback dimensions (150x250), but got (${pdfImage.width}x${pdfImage.height}).`);\n  }\n});\n",
    "i5_gpt-4o": "it(\"should use fallback dimensions for images with invalid widthheight\", async () => {\n  const { PDFImage } = await import(\"../../src/core/image.js\");\n  const fakeDict = {\n    get(key, alt) {\n      if (key === \"W\" || alt === \"Width\") {\n        return 0;\n      }\n      if (key === \"H\" || alt === \"Height\") {\n        return 0;\n      }\n      return undefined;\n    },\n  };\n  const fakeImage = { dict: fakeDict, fallbackDims: { width: 150, height: 250 } };\n  const fakeXref = { fetchIfRef: (obj) => obj };\n  const pdfImage = new PDFImage({\n    xref: fakeXref,\n    res: {},\n    image: fakeImage,\n    pdfFunctionFactory: {},\n    globalColorSpaceCache: {},\n    localColorSpaceCache: {},\n  });\n  if (pdfImage.width !== 150 || pdfImage.height !== 250) {\n    throw new Error(`Expected fallback dimensions (150x250), but got (${pdfImage.width}x${pdfImage.height}).`);\n  }\n});\n",
    "i5_llama-3.3-70b-versatile": "it(\"should use fallback dimensions for images with invalid widthheight\", async () => {\n  const { PDFImage } = await import(\"../../src/core/image.js\");\n  const fakeDict = {\n    get(key, alt) {\n      if (key === \"W\" || alt === \"Width\") {\n        return 0;\n      }\n      if (key === \"H\" || alt === \"Height\") {\n        return 0;\n      }\n      return undefined;\n    },\n  };\n  const fakeImage = { dict: fakeDict, fallbackDims: { width: 150, height: 250 } };\n  const fakeXref = { fetchIfRef: (obj) => obj };\n  const pdfImage = new PDFImage({\n    xref: fakeXref,\n    res: {},\n    image: fakeImage,\n    pdfFunctionFactory: {},\n    globalColorSpaceCache: {},\n    localColorSpaceCache: {},\n  });\n  if (pdfImage.width !== 150 || pdfImage.height !== 250) {\n    throw new Error(`Expected fallback dimensions (150x250), but got (${pdfImage.width}x${pdfImage.height}).`);\n  }\n});\n"
  },
  "19625": {
    "i1_deepseek-r1-distill-llama-70b": "it(\"should compute bbox for a Type3 glyph with setCharWidth operator\", async () => {\n  const { OPS } = await import(\"../../src/shared/util.js\");\n  const { Dict } = await import(\"../../src/core/primitives.js\");\n  const { StringStream } = await import(\"../../src/core/stream.js\");\n  const { OperatorList } = await import(\"../../src/core/operator_list.js\");\n  const { PartialEvaluator, TranslatedFont } = await import(\"../../src/core/evaluator.js\");\n  const { WorkerTask } = await import(\"../../src/core/worker.js\");\n\n  // Create a fake CharProcs dictionary.\n  const charProcs = new Dict();\n  charProcs.getKeys = () => [\"A\"];\n  const fakeStream = new StringStream(\"\");\n  charProcs.get = () => fakeStream;\n\n  // Create a fake Type3 font dictionary.\n  const fontDict = new Dict();\n  fontDict.set(\"CharProcs\", charProcs);\n  fontDict.set(\"Resources\", new Dict());\n\n  // Create a fake Type3 font object with an empty bbox.\n  const font = { isType3Font: true, bbox: [0, 0, 0, 0] };\n  const loadedName = \"TestType3Font\";\n\n  // Instantiate a PartialEvaluator.\n  const evaluator = new PartialEvaluator({});\n  // Override getOperatorList to simulate processing a glyph stream.\n  evaluator.getOperatorList = function({ stream, operatorList }) {\n    operatorList.fnArray.push(OPS.setCharWidth);\n    operatorList.argsArray.push([]); // d0 operator has no bbox info.\n    operatorList.fnArray.push(OPS.constructPath);\n    // The third argument contains the bbox we want to compute.\n    operatorList.argsArray.push([null, null, [10, 20, 30, 40]]);\n    operatorList.length = operatorList.fnArray.length;\n    return Promise.resolve();\n  };\n\n  const task = new WorkerTask(\"test\", \"\");\n  const translatedFont = new TranslatedFont({ loadedName, font, dict: fontDict });\n  await translatedFont.loadType3Data(evaluator, fontDict, task);\n  if (!font.isCharBBox) {\n    throw new Error(\"Expected font.isCharBBox to be true\");\n  }\n  const expected = [10, 20, 30, 40];\n  if (\n    font.bbox[0] !== expected[0] ||\n    font.bbox[1] !== expected[1] ||\n    font.bbox[2] !== expected[2] ||\n    font.bbox[3] !== expected[3]\n  ) {\n    throw new Error(\"Font bbox does not match expected value\");\n  }\n});",
    "i1_gpt-4o": "it(\"should compute bbox for a Type3 glyph with setCharWidth operator\", async () => {\n  const { OPS } = await import(\"../../src/shared/util.js\");\n  const { Dict } = await import(\"../../src/core/primitives.js\");\n  const { StringStream } = await import(\"../../src/core/stream.js\");\n  const { OperatorList } = await import(\"../../src/core/operator_list.js\");\n  const { PartialEvaluator, TranslatedFont } = await import(\"../../src/core/evaluator.js\");\n  const { WorkerTask } = await import(\"../../src/core/worker.js\");\n\n  // Create a fake CharProcs dictionary.\n  const charProcs = new Dict();\n  charProcs.getKeys = () => [\"A\"];\n  const fakeStream = new StringStream(\"\");\n  charProcs.get = () => fakeStream;\n\n  // Create a fake Type3 font dictionary.\n  const fontDict = new Dict();\n  fontDict.set(\"CharProcs\", charProcs);\n  fontDict.set(\"Resources\", new Dict());\n\n  // Create a fake Type3 font object with an empty bbox.\n  const font = { isType3Font: true, bbox: [0, 0, 0, 0] };\n  const loadedName = \"TestType3Font\";\n\n  // Instantiate a PartialEvaluator.\n  const evaluator = new PartialEvaluator({});\n  // Override getOperatorList to simulate processing a glyph stream.\n  evaluator.getOperatorList = function({ stream, operatorList }) {\n    operatorList.fnArray.push(OPS.setCharWidth);\n    operatorList.argsArray.push([]); // d0 operator has no bbox info.\n    operatorList.fnArray.push(OPS.constructPath);\n    // The third argument contains the bbox we want to compute.\n    operatorList.argsArray.push([null, null, [10, 20, 30, 40]]);\n    operatorList.length = operatorList.fnArray.length;\n    return Promise.resolve();\n  };\n\n  const task = new WorkerTask(\"test\", \"\");\n  const translatedFont = new TranslatedFont({ loadedName, font, dict: fontDict });\n  await translatedFont.loadType3Data(evaluator, fontDict, task);\n  if (!font.isCharBBox) {\n    throw new Error(\"Expected font.isCharBBox to be true\");\n  }\n  const expected = [10, 20, 30, 40];\n  if (\n    font.bbox[0] !== expected[0] ||\n    font.bbox[1] !== expected[1] ||\n    font.bbox[2] !== expected[2] ||\n    font.bbox[3] !== expected[3]\n  ) {\n    throw new Error(\"Font bbox does not match expected value\");\n  }\n});",
    "i1_llama-3.3-70b-versatile": "it(\"should compute bbox for a Type3 glyph with setCharWidth operator\", async () => {\n  const { OPS } = await import(\"../../src/shared/util.js\");\n  const { Dict } = await import(\"../../src/core/primitives.js\");\n  const { StringStream } = await import(\"../../src/core/stream.js\");\n  const { OperatorList } = await import(\"../../src/core/operator_list.js\");\n  const { PartialEvaluator, TranslatedFont } = await import(\"../../src/core/evaluator.js\");\n  const { WorkerTask } = await import(\"../../src/core/worker.js\");\n\n  // Create a fake CharProcs dictionary.\n  const charProcs = new Dict();\n  charProcs.getKeys = () => [\"A\"];\n  const fakeStream = new StringStream(\"\");\n  charProcs.get = () => fakeStream;\n\n  // Create a fake Type3 font dictionary.\n  const fontDict = new Dict();\n  fontDict.set(\"CharProcs\", charProcs);\n  fontDict.set(\"Resources\", new Dict());\n\n  // Create a fake Type3 font object with an empty bbox.\n  const font = { isType3Font: true, bbox: [0, 0, 0, 0] };\n  const loadedName = \"TestType3Font\";\n\n  // Instantiate a PartialEvaluator.\n  const evaluator = new PartialEvaluator({});\n  // Override getOperatorList to simulate processing a glyph stream.\n  evaluator.getOperatorList = function({ stream, operatorList }) {\n    operatorList.fnArray.push(OPS.setCharWidth);\n    operatorList.argsArray.push([]); // d0 operator has no bbox info.\n    operatorList.fnArray.push(OPS.constructPath);\n    // The third argument contains the bbox we want to compute.\n    operatorList.argsArray.push([null, null, [10, 20, 30, 40]]);\n    operatorList.length = operatorList.fnArray.length;\n    return Promise.resolve();\n  };\n\n  const task = new WorkerTask(\"test\", \"\");\n  const translatedFont = new TranslatedFont({ loadedName, font, dict: fontDict });\n  await translatedFont.loadType3Data(evaluator, fontDict, task);\n  if (!font.isCharBBox) {\n    throw new Error(\"Expected font.isCharBBox to be true\");\n  }\n  const expected = [10, 20, 30, 40];\n  if (\n    font.bbox[0] !== expected[0] ||\n    font.bbox[1] !== expected[1] ||\n    font.bbox[2] !== expected[2] ||\n    font.bbox[3] !== expected[3]\n  ) {\n    throw new Error(\"Font bbox does not match expected value\");\n  }\n});",
    "i1_MOCK": "it(\"should compute bbox for a Type3 glyph with setCharWidth operator\", async () => {\n  const { OPS } = await import(\"../../src/shared/util.js\");\n  const { Dict } = await import(\"../../src/core/primitives.js\");\n  const { StringStream } = await import(\"../../src/core/stream.js\");\n  const { OperatorList } = await import(\"../../src/core/operator_list.js\");\n  const { PartialEvaluator, TranslatedFont } = await import(\"../../src/core/evaluator.js\");\n  const { WorkerTask } = await import(\"../../src/core/worker.js\");\n\n  // Create a fake CharProcs dictionary.\n  const charProcs = new Dict();\n  charProcs.getKeys = () => [\"A\"];\n  const fakeStream = new StringStream(\"\");\n  charProcs.get = () => fakeStream;\n\n  // Create a fake Type3 font dictionary.\n  const fontDict = new Dict();\n  fontDict.set(\"CharProcs\", charProcs);\n  fontDict.set(\"Resources\", new Dict());\n\n  // Create a fake Type3 font object with an empty bbox.\n  const font = { isType3Font: true, bbox: [0, 0, 0, 0] };\n  const loadedName = \"TestType3Font\";\n\n  // Instantiate a PartialEvaluator.\n  const evaluator = new PartialEvaluator({});\n  // Override getOperatorList to simulate processing a glyph stream.\n  evaluator.getOperatorList = function({ stream, operatorList }) {\n    operatorList.fnArray.push(OPS.setCharWidth);\n    operatorList.argsArray.push([]); // d0 operator has no bbox info.\n    operatorList.fnArray.push(OPS.constructPath);\n    // The third argument contains the bbox we want to compute.\n    operatorList.argsArray.push([null, null, [10, 20, 30, 40]]);\n    operatorList.length = operatorList.fnArray.length;\n    return Promise.resolve();\n  };\n\n  const task = new WorkerTask(\"test\", \"\");\n  const translatedFont = new TranslatedFont({ loadedName, font, dict: fontDict });\n  await translatedFont.loadType3Data(evaluator, fontDict, task);\n  if (!font.isCharBBox) {\n    throw new Error(\"Expected font.isCharBBox to be true\");\n  }\n  const expected = [10, 20, 30, 40];\n  if (\n    font.bbox[0] !== expected[0] ||\n    font.bbox[1] !== expected[1] ||\n    font.bbox[2] !== expected[2] ||\n    font.bbox[3] !== expected[3]\n  ) {\n    throw new Error(\"Font bbox does not match expected value\");\n  }\n});",
    "i2_deepseek-r1-distill-llama-70b": "it(\"should compute bbox for a Type3 glyph with setCharWidth operator\", async () => {\n  const { OPS } = await import(\"../../src/shared/util.js\");\n  const { Dict } = await import(\"../../src/core/primitives.js\");\n  const { StringStream } = await import(\"../../src/core/stream.js\");\n  const { OperatorList } = await import(\"../../src/core/operator_list.js\");\n  const { PartialEvaluator, TranslatedFont } = await import(\"../../src/core/evaluator.js\");\n  const { WorkerTask } = await import(\"../../src/core/worker.js\");\n\n  // Create a fake CharProcs dictionary.\n  const charProcs = new Dict();\n  charProcs.getKeys = () => [\"A\"];\n  const fakeStream = new StringStream(\"\");\n  charProcs.get = () => fakeStream;\n\n  // Create a fake Type3 font dictionary.\n  const fontDict = new Dict();\n  fontDict.set(\"CharProcs\", charProcs);\n  fontDict.set(\"Resources\", new Dict());\n\n  // Create a fake Type3 font object with an empty bbox.\n  const font = { isType3Font: true, bbox: [0, 0, 0, 0] };\n  const loadedName = \"TestType3Font\";\n\n  // Instantiate a PartialEvaluator.\n  const evaluator = new PartialEvaluator({});\n  // Override getOperatorList to simulate processing a glyph stream.\n  evaluator.getOperatorList = function({ stream, operatorList }) {\n    operatorList.fnArray.push(OPS.setCharWidth);\n    operatorList.argsArray.push([]); // d0 operator has no bbox info.\n    operatorList.fnArray.push(OPS.constructPath);\n    // The third argument contains the bbox we want to compute.\n    operatorList.argsArray.push([null, null, [10, 20, 30, 40]]);\n    operatorList.length = operatorList.fnArray.length;\n    return Promise.resolve();\n  };\n\n  const task = new WorkerTask(\"test\", \"\");\n  const translatedFont = new TranslatedFont({ loadedName, font, dict: fontDict });\n  await translatedFont.loadType3Data(evaluator, fontDict, task);\n  if (!font.isCharBBox) {\n    throw new Error(\"Expected font.isCharBBox to be true\");\n  }\n  const expected = [10, 20, 30, 40];\n  if (\n    font.bbox[0] !== expected[0] ||\n    font.bbox[1] !== expected[1] ||\n    font.bbox[2] !== expected[2] ||\n    font.bbox[3] !== expected[3]\n  ) {\n    throw new Error(\"Font bbox does not match expected value\");\n  }\n});",
    "i2_gpt-4o": "it(\"should compute bbox for a Type3 glyph with setCharWidth operator\", async () => {\n  const { OPS } = await import(\"../../src/shared/util.js\");\n  const { Dict } = await import(\"../../src/core/primitives.js\");\n  const { StringStream } = await import(\"../../src/core/stream.js\");\n  const { OperatorList } = await import(\"../../src/core/operator_list.js\");\n  const { PartialEvaluator, TranslatedFont } = await import(\"../../src/core/evaluator.js\");\n  const { WorkerTask } = await import(\"../../src/core/worker.js\");\n\n  // Create a fake CharProcs dictionary.\n  const charProcs = new Dict();\n  charProcs.getKeys = () => [\"A\"];\n  const fakeStream = new StringStream(\"\");\n  charProcs.get = () => fakeStream;\n\n  // Create a fake Type3 font dictionary.\n  const fontDict = new Dict();\n  fontDict.set(\"CharProcs\", charProcs);\n  fontDict.set(\"Resources\", new Dict());\n\n  // Create a fake Type3 font object with an empty bbox.\n  const font = { isType3Font: true, bbox: [0, 0, 0, 0] };\n  const loadedName = \"TestType3Font\";\n\n  // Instantiate a PartialEvaluator.\n  const evaluator = new PartialEvaluator({});\n  // Override getOperatorList to simulate processing a glyph stream.\n  evaluator.getOperatorList = function({ stream, operatorList }) {\n    operatorList.fnArray.push(OPS.setCharWidth);\n    operatorList.argsArray.push([]); // d0 operator has no bbox info.\n    operatorList.fnArray.push(OPS.constructPath);\n    // The third argument contains the bbox we want to compute.\n    operatorList.argsArray.push([null, null, [10, 20, 30, 40]]);\n    operatorList.length = operatorList.fnArray.length;\n    return Promise.resolve();\n  };\n\n  const task = new WorkerTask(\"test\", \"\");\n  const translatedFont = new TranslatedFont({ loadedName, font, dict: fontDict });\n  await translatedFont.loadType3Data(evaluator, fontDict, task);\n  if (!font.isCharBBox) {\n    throw new Error(\"Expected font.isCharBBox to be true\");\n  }\n  const expected = [10, 20, 30, 40];\n  if (\n    font.bbox[0] !== expected[0] ||\n    font.bbox[1] !== expected[1] ||\n    font.bbox[2] !== expected[2] ||\n    font.bbox[3] !== expected[3]\n  ) {\n    throw new Error(\"Font bbox does not match expected value\");\n  }\n});",
    "i2_llama-3.3-70b-versatile": "it(\"should compute bbox for a Type3 glyph with setCharWidth operator\", async () => {\n  const { OPS } = await import(\"../../src/shared/util.js\");\n  const { Dict } = await import(\"../../src/core/primitives.js\");\n  const { StringStream } = await import(\"../../src/core/stream.js\");\n  const { OperatorList } = await import(\"../../src/core/operator_list.js\");\n  const { PartialEvaluator, TranslatedFont } = await import(\"../../src/core/evaluator.js\");\n  const { WorkerTask } = await import(\"../../src/core/worker.js\");\n\n  // Create a fake CharProcs dictionary.\n  const charProcs = new Dict();\n  charProcs.getKeys = () => [\"A\"];\n  const fakeStream = new StringStream(\"\");\n  charProcs.get = () => fakeStream;\n\n  // Create a fake Type3 font dictionary.\n  const fontDict = new Dict();\n  fontDict.set(\"CharProcs\", charProcs);\n  fontDict.set(\"Resources\", new Dict());\n\n  // Create a fake Type3 font object with an empty bbox.\n  const font = { isType3Font: true, bbox: [0, 0, 0, 0] };\n  const loadedName = \"TestType3Font\";\n\n  // Instantiate a PartialEvaluator.\n  const evaluator = new PartialEvaluator({});\n  // Override getOperatorList to simulate processing a glyph stream.\n  evaluator.getOperatorList = function({ stream, operatorList }) {\n    operatorList.fnArray.push(OPS.setCharWidth);\n    operatorList.argsArray.push([]); // d0 operator has no bbox info.\n    operatorList.fnArray.push(OPS.constructPath);\n    // The third argument contains the bbox we want to compute.\n    operatorList.argsArray.push([null, null, [10, 20, 30, 40]]);\n    operatorList.length = operatorList.fnArray.length;\n    return Promise.resolve();\n  };\n\n  const task = new WorkerTask(\"test\", \"\");\n  const translatedFont = new TranslatedFont({ loadedName, font, dict: fontDict });\n  await translatedFont.loadType3Data(evaluator, fontDict, task);\n  if (!font.isCharBBox) {\n    throw new Error(\"Expected font.isCharBBox to be true\");\n  }\n  const expected = [10, 20, 30, 40];\n  if (\n    font.bbox[0] !== expected[0] ||\n    font.bbox[1] !== expected[1] ||\n    font.bbox[2] !== expected[2] ||\n    font.bbox[3] !== expected[3]\n  ) {\n    throw new Error(\"Font bbox does not match expected value\");\n  }\n});",
    "i3_deepseek-r1-distill-llama-70b": "it(\"should compute bbox for a Type3 glyph with setCharWidth operator\", async () => {\n  const { OPS } = await import(\"../../src/shared/util.js\");\n  const { Dict } = await import(\"../../src/core/primitives.js\");\n  const { StringStream } = await import(\"../../src/core/stream.js\");\n  const { OperatorList } = await import(\"../../src/core/operator_list.js\");\n  const { PartialEvaluator, TranslatedFont } = await import(\"../../src/core/evaluator.js\");\n  const { WorkerTask } = await import(\"../../src/core/worker.js\");\n\n  // Create a fake CharProcs dictionary.\n  const charProcs = new Dict();\n  charProcs.getKeys = () => [\"A\"];\n  const fakeStream = new StringStream(\"\");\n  charProcs.get = () => fakeStream;\n\n  // Create a fake Type3 font dictionary.\n  const fontDict = new Dict();\n  fontDict.set(\"CharProcs\", charProcs);\n  fontDict.set(\"Resources\", new Dict());\n\n  // Create a fake Type3 font object with an empty bbox.\n  const font = { isType3Font: true, bbox: [0, 0, 0, 0] };\n  const loadedName = \"TestType3Font\";\n\n  // Instantiate a PartialEvaluator.\n  const evaluator = new PartialEvaluator({});\n  // Override getOperatorList to simulate processing a glyph stream.\n  evaluator.getOperatorList = function({ stream, operatorList }) {\n    operatorList.fnArray.push(OPS.setCharWidth);\n    operatorList.argsArray.push([]); // d0 operator has no bbox info.\n    operatorList.fnArray.push(OPS.constructPath);\n    // The third argument contains the bbox we want to compute.\n    operatorList.argsArray.push([null, null, [10, 20, 30, 40]]);\n    operatorList.length = operatorList.fnArray.length;\n    return Promise.resolve();\n  };\n\n  const task = new WorkerTask(\"test\", \"\");\n  const translatedFont = new TranslatedFont({ loadedName, font, dict: fontDict });\n  await translatedFont.loadType3Data(evaluator, fontDict, task);\n  if (!font.isCharBBox) {\n    throw new Error(\"Expected font.isCharBBox to be true\");\n  }\n  const expected = [10, 20, 30, 40];\n  if (\n    font.bbox[0] !== expected[0] ||\n    font.bbox[1] !== expected[1] ||\n    font.bbox[2] !== expected[2] ||\n    font.bbox[3] !== expected[3]\n  ) {\n    throw new Error(\"Font bbox does not match expected value\");\n  }\n});",
    "i3_gpt-4o": "it(\"should compute bbox for a Type3 glyph with setCharWidth operator\", async () => {\n  const { OPS } = await import(\"../../src/shared/util.js\");\n  const { Dict } = await import(\"../../src/core/primitives.js\");\n  const { StringStream } = await import(\"../../src/core/stream.js\");\n  const { OperatorList } = await import(\"../../src/core/operator_list.js\");\n  const { PartialEvaluator, TranslatedFont } = await import(\"../../src/core/evaluator.js\");\n  const { WorkerTask } = await import(\"../../src/core/worker.js\");\n\n  // Create a fake CharProcs dictionary.\n  const charProcs = new Dict();\n  charProcs.getKeys = () => [\"A\"];\n  const fakeStream = new StringStream(\"\");\n  charProcs.get = () => fakeStream;\n\n  // Create a fake Type3 font dictionary.\n  const fontDict = new Dict();\n  fontDict.set(\"CharProcs\", charProcs);\n  fontDict.set(\"Resources\", new Dict());\n\n  // Create a fake Type3 font object with an empty bbox.\n  const font = { isType3Font: true, bbox: [0, 0, 0, 0] };\n  const loadedName = \"TestType3Font\";\n\n  // Instantiate a PartialEvaluator.\n  const evaluator = new PartialEvaluator({});\n  // Override getOperatorList to simulate processing a glyph stream.\n  evaluator.getOperatorList = function({ stream, operatorList }) {\n    operatorList.fnArray.push(OPS.setCharWidth);\n    operatorList.argsArray.push([]); // d0 operator has no bbox info.\n    operatorList.fnArray.push(OPS.constructPath);\n    // The third argument contains the bbox we want to compute.\n    operatorList.argsArray.push([null, null, [10, 20, 30, 40]]);\n    operatorList.length = operatorList.fnArray.length;\n    return Promise.resolve();\n  };\n\n  const task = new WorkerTask(\"test\", \"\");\n  const translatedFont = new TranslatedFont({ loadedName, font, dict: fontDict });\n  await translatedFont.loadType3Data(evaluator, fontDict, task);\n  if (!font.isCharBBox) {\n    throw new Error(\"Expected font.isCharBBox to be true\");\n  }\n  const expected = [10, 20, 30, 40];\n  if (\n    font.bbox[0] !== expected[0] ||\n    font.bbox[1] !== expected[1] ||\n    font.bbox[2] !== expected[2] ||\n    font.bbox[3] !== expected[3]\n  ) {\n    throw new Error(\"Font bbox does not match expected value\");\n  }\n});",
    "i3_llama-3.3-70b-versatile": "it(\"should compute bbox for a Type3 glyph with setCharWidth operator\", async () => {\n  const { OPS } = await import(\"../../src/shared/util.js\");\n  const { Dict } = await import(\"../../src/core/primitives.js\");\n  const { StringStream } = await import(\"../../src/core/stream.js\");\n  const { OperatorList } = await import(\"../../src/core/operator_list.js\");\n  const { PartialEvaluator, TranslatedFont } = await import(\"../../src/core/evaluator.js\");\n  const { WorkerTask } = await import(\"../../src/core/worker.js\");\n\n  // Create a fake CharProcs dictionary.\n  const charProcs = new Dict();\n  charProcs.getKeys = () => [\"A\"];\n  const fakeStream = new StringStream(\"\");\n  charProcs.get = () => fakeStream;\n\n  // Create a fake Type3 font dictionary.\n  const fontDict = new Dict();\n  fontDict.set(\"CharProcs\", charProcs);\n  fontDict.set(\"Resources\", new Dict());\n\n  // Create a fake Type3 font object with an empty bbox.\n  const font = { isType3Font: true, bbox: [0, 0, 0, 0] };\n  const loadedName = \"TestType3Font\";\n\n  // Instantiate a PartialEvaluator.\n  const evaluator = new PartialEvaluator({});\n  // Override getOperatorList to simulate processing a glyph stream.\n  evaluator.getOperatorList = function({ stream, operatorList }) {\n    operatorList.fnArray.push(OPS.setCharWidth);\n    operatorList.argsArray.push([]); // d0 operator has no bbox info.\n    operatorList.fnArray.push(OPS.constructPath);\n    // The third argument contains the bbox we want to compute.\n    operatorList.argsArray.push([null, null, [10, 20, 30, 40]]);\n    operatorList.length = operatorList.fnArray.length;\n    return Promise.resolve();\n  };\n\n  const task = new WorkerTask(\"test\", \"\");\n  const translatedFont = new TranslatedFont({ loadedName, font, dict: fontDict });\n  await translatedFont.loadType3Data(evaluator, fontDict, task);\n  if (!font.isCharBBox) {\n    throw new Error(\"Expected font.isCharBBox to be true\");\n  }\n  const expected = [10, 20, 30, 40];\n  if (\n    font.bbox[0] !== expected[0] ||\n    font.bbox[1] !== expected[1] ||\n    font.bbox[2] !== expected[2] ||\n    font.bbox[3] !== expected[3]\n  ) {\n    throw new Error(\"Font bbox does not match expected value\");\n  }\n});",
    "i4_deepseek-r1-distill-llama-70b": "it(\"should compute bbox for a Type3 glyph with setCharWidth operator\", async () => {\n  const { OPS } = await import(\"../../src/shared/util.js\");\n  const { Dict } = await import(\"../../src/core/primitives.js\");\n  const { StringStream } = await import(\"../../src/core/stream.js\");\n  const { OperatorList } = await import(\"../../src/core/operator_list.js\");\n  const { PartialEvaluator, TranslatedFont } = await import(\"../../src/core/evaluator.js\");\n  const { WorkerTask } = await import(\"../../src/core/worker.js\");\n\n  // Create a fake CharProcs dictionary.\n  const charProcs = new Dict();\n  charProcs.getKeys = () => [\"A\"];\n  const fakeStream = new StringStream(\"\");\n  charProcs.get = () => fakeStream;\n\n  // Create a fake Type3 font dictionary.\n  const fontDict = new Dict();\n  fontDict.set(\"CharProcs\", charProcs);\n  fontDict.set(\"Resources\", new Dict());\n\n  // Create a fake Type3 font object with an empty bbox.\n  const font = { isType3Font: true, bbox: [0, 0, 0, 0] };\n  const loadedName = \"TestType3Font\";\n\n  // Instantiate a PartialEvaluator.\n  const evaluator = new PartialEvaluator({});\n  // Override getOperatorList to simulate processing a glyph stream.\n  evaluator.getOperatorList = function({ stream, operatorList }) {\n    operatorList.fnArray.push(OPS.setCharWidth);\n    operatorList.argsArray.push([]); // d0 operator has no bbox info.\n    operatorList.fnArray.push(OPS.constructPath);\n    // The third argument contains the bbox we want to compute.\n    operatorList.argsArray.push([null, null, [10, 20, 30, 40]]);\n    operatorList.length = operatorList.fnArray.length;\n    return Promise.resolve();\n  };\n\n  const task = new WorkerTask(\"test\", \"\");\n  const translatedFont = new TranslatedFont({ loadedName, font, dict: fontDict });\n  await translatedFont.loadType3Data(evaluator, fontDict, task);\n  if (!font.isCharBBox) {\n    throw new Error(\"Expected font.isCharBBox to be true\");\n  }\n  const expected = [10, 20, 30, 40];\n  if (\n    font.bbox[0] !== expected[0] ||\n    font.bbox[1] !== expected[1] ||\n    font.bbox[2] !== expected[2] ||\n    font.bbox[3] !== expected[3]\n  ) {\n    throw new Error(\"Font bbox does not match expected value\");\n  }\n});",
    "i4_gpt-4o": "it(\"should compute bbox for a Type3 glyph with setCharWidth operator\", async () => {\n  const { OPS } = await import(\"../../src/shared/util.js\");\n  const { Dict } = await import(\"../../src/core/primitives.js\");\n  const { StringStream } = await import(\"../../src/core/stream.js\");\n  const { OperatorList } = await import(\"../../src/core/operator_list.js\");\n  const { PartialEvaluator, TranslatedFont } = await import(\"../../src/core/evaluator.js\");\n  const { WorkerTask } = await import(\"../../src/core/worker.js\");\n\n  // Create a fake CharProcs dictionary.\n  const charProcs = new Dict();\n  charProcs.getKeys = () => [\"A\"];\n  const fakeStream = new StringStream(\"\");\n  charProcs.get = () => fakeStream;\n\n  // Create a fake Type3 font dictionary.\n  const fontDict = new Dict();\n  fontDict.set(\"CharProcs\", charProcs);\n  fontDict.set(\"Resources\", new Dict());\n\n  // Create a fake Type3 font object with an empty bbox.\n  const font = { isType3Font: true, bbox: [0, 0, 0, 0] };\n  const loadedName = \"TestType3Font\";\n\n  // Instantiate a PartialEvaluator.\n  const evaluator = new PartialEvaluator({});\n  // Override getOperatorList to simulate processing a glyph stream.\n  evaluator.getOperatorList = function({ stream, operatorList }) {\n    operatorList.fnArray.push(OPS.setCharWidth);\n    operatorList.argsArray.push([]); // d0 operator has no bbox info.\n    operatorList.fnArray.push(OPS.constructPath);\n    // The third argument contains the bbox we want to compute.\n    operatorList.argsArray.push([null, null, [10, 20, 30, 40]]);\n    operatorList.length = operatorList.fnArray.length;\n    return Promise.resolve();\n  };\n\n  const task = new WorkerTask(\"test\", \"\");\n  const translatedFont = new TranslatedFont({ loadedName, font, dict: fontDict });\n  await translatedFont.loadType3Data(evaluator, fontDict, task);\n  if (!font.isCharBBox) {\n    throw new Error(\"Expected font.isCharBBox to be true\");\n  }\n  const expected = [10, 20, 30, 40];\n  if (\n    font.bbox[0] !== expected[0] ||\n    font.bbox[1] !== expected[1] ||\n    font.bbox[2] !== expected[2] ||\n    font.bbox[3] !== expected[3]\n  ) {\n    throw new Error(\"Font bbox does not match expected value\");\n  }\n});",
    "i4_llama-3.3-70b-versatile": "it(\"should compute bbox for a Type3 glyph with setCharWidth operator\", async () => {\n  const { OPS } = await import(\"../../src/shared/util.js\");\n  const { Dict } = await import(\"../../src/core/primitives.js\");\n  const { StringStream } = await import(\"../../src/core/stream.js\");\n  const { OperatorList } = await import(\"../../src/core/operator_list.js\");\n  const { PartialEvaluator, TranslatedFont } = await import(\"../../src/core/evaluator.js\");\n  const { WorkerTask } = await import(\"../../src/core/worker.js\");\n\n  // Create a fake CharProcs dictionary.\n  const charProcs = new Dict();\n  charProcs.getKeys = () => [\"A\"];\n  const fakeStream = new StringStream(\"\");\n  charProcs.get = () => fakeStream;\n\n  // Create a fake Type3 font dictionary.\n  const fontDict = new Dict();\n  fontDict.set(\"CharProcs\", charProcs);\n  fontDict.set(\"Resources\", new Dict());\n\n  // Create a fake Type3 font object with an empty bbox.\n  const font = { isType3Font: true, bbox: [0, 0, 0, 0] };\n  const loadedName = \"TestType3Font\";\n\n  // Instantiate a PartialEvaluator.\n  const evaluator = new PartialEvaluator({});\n  // Override getOperatorList to simulate processing a glyph stream.\n  evaluator.getOperatorList = function({ stream, operatorList }) {\n    operatorList.fnArray.push(OPS.setCharWidth);\n    operatorList.argsArray.push([]); // d0 operator has no bbox info.\n    operatorList.fnArray.push(OPS.constructPath);\n    // The third argument contains the bbox we want to compute.\n    operatorList.argsArray.push([null, null, [10, 20, 30, 40]]);\n    operatorList.length = operatorList.fnArray.length;\n    return Promise.resolve();\n  };\n\n  const task = new WorkerTask(\"test\", \"\");\n  const translatedFont = new TranslatedFont({ loadedName, font, dict: fontDict });\n  await translatedFont.loadType3Data(evaluator, fontDict, task);\n  if (!font.isCharBBox) {\n    throw new Error(\"Expected font.isCharBBox to be true\");\n  }\n  const expected = [10, 20, 30, 40];\n  if (\n    font.bbox[0] !== expected[0] ||\n    font.bbox[1] !== expected[1] ||\n    font.bbox[2] !== expected[2] ||\n    font.bbox[3] !== expected[3]\n  ) {\n    throw new Error(\"Font bbox does not match expected value\");\n  }\n});",
    "i5_deepseek-r1-distill-llama-70b": "it(\"should compute bbox for a Type3 glyph with setCharWidth operator\", async () => {\n  const { OPS } = await import(\"../../src/shared/util.js\");\n  const { Dict } = await import(\"../../src/core/primitives.js\");\n  const { StringStream } = await import(\"../../src/core/stream.js\");\n  const { OperatorList } = await import(\"../../src/core/operator_list.js\");\n  const { PartialEvaluator, TranslatedFont } = await import(\"../../src/core/evaluator.js\");\n  const { WorkerTask } = await import(\"../../src/core/worker.js\");\n\n  // Create a fake CharProcs dictionary.\n  const charProcs = new Dict();\n  charProcs.getKeys = () => [\"A\"];\n  const fakeStream = new StringStream(\"\");\n  charProcs.get = () => fakeStream;\n\n  // Create a fake Type3 font dictionary.\n  const fontDict = new Dict();\n  fontDict.set(\"CharProcs\", charProcs);\n  fontDict.set(\"Resources\", new Dict());\n\n  // Create a fake Type3 font object with an empty bbox.\n  const font = { isType3Font: true, bbox: [0, 0, 0, 0] };\n  const loadedName = \"TestType3Font\";\n\n  // Instantiate a PartialEvaluator.\n  const evaluator = new PartialEvaluator({});\n  // Override getOperatorList to simulate processing a glyph stream.\n  evaluator.getOperatorList = function({ stream, operatorList }) {\n    operatorList.fnArray.push(OPS.setCharWidth);\n    operatorList.argsArray.push([]); // d0 operator has no bbox info.\n    operatorList.fnArray.push(OPS.constructPath);\n    // The third argument contains the bbox we want to compute.\n    operatorList.argsArray.push([null, null, [10, 20, 30, 40]]);\n    operatorList.length = operatorList.fnArray.length;\n    return Promise.resolve();\n  };\n\n  const task = new WorkerTask(\"test\", \"\");\n  const translatedFont = new TranslatedFont({ loadedName, font, dict: fontDict });\n  await translatedFont.loadType3Data(evaluator, fontDict, task);\n  if (!font.isCharBBox) {\n    throw new Error(\"Expected font.isCharBBox to be true\");\n  }\n  const expected = [10, 20, 30, 40];\n  if (\n    font.bbox[0] !== expected[0] ||\n    font.bbox[1] !== expected[1] ||\n    font.bbox[2] !== expected[2] ||\n    font.bbox[3] !== expected[3]\n  ) {\n    throw new Error(\"Font bbox does not match expected value\");\n  }\n});",
    "i5_gpt-4o": "it(\"should compute bbox for a Type3 glyph with setCharWidth operator\", async () => {\n  const { OPS } = await import(\"../../src/shared/util.js\");\n  const { Dict } = await import(\"../../src/core/primitives.js\");\n  const { StringStream } = await import(\"../../src/core/stream.js\");\n  const { OperatorList } = await import(\"../../src/core/operator_list.js\");\n  const { PartialEvaluator, TranslatedFont } = await import(\"../../src/core/evaluator.js\");\n  const { WorkerTask } = await import(\"../../src/core/worker.js\");\n\n  // Create a fake CharProcs dictionary.\n  const charProcs = new Dict();\n  charProcs.getKeys = () => [\"A\"];\n  const fakeStream = new StringStream(\"\");\n  charProcs.get = () => fakeStream;\n\n  // Create a fake Type3 font dictionary.\n  const fontDict = new Dict();\n  fontDict.set(\"CharProcs\", charProcs);\n  fontDict.set(\"Resources\", new Dict());\n\n  // Create a fake Type3 font object with an empty bbox.\n  const font = { isType3Font: true, bbox: [0, 0, 0, 0] };\n  const loadedName = \"TestType3Font\";\n\n  // Instantiate a PartialEvaluator.\n  const evaluator = new PartialEvaluator({});\n  // Override getOperatorList to simulate processing a glyph stream.\n  evaluator.getOperatorList = function({ stream, operatorList }) {\n    operatorList.fnArray.push(OPS.setCharWidth);\n    operatorList.argsArray.push([]); // d0 operator has no bbox info.\n    operatorList.fnArray.push(OPS.constructPath);\n    // The third argument contains the bbox we want to compute.\n    operatorList.argsArray.push([null, null, [10, 20, 30, 40]]);\n    operatorList.length = operatorList.fnArray.length;\n    return Promise.resolve();\n  };\n\n  const task = new WorkerTask(\"test\", \"\");\n  const translatedFont = new TranslatedFont({ loadedName, font, dict: fontDict });\n  await translatedFont.loadType3Data(evaluator, fontDict, task);\n  if (!font.isCharBBox) {\n    throw new Error(\"Expected font.isCharBBox to be true\");\n  }\n  const expected = [10, 20, 30, 40];\n  if (\n    font.bbox[0] !== expected[0] ||\n    font.bbox[1] !== expected[1] ||\n    font.bbox[2] !== expected[2] ||\n    font.bbox[3] !== expected[3]\n  ) {\n    throw new Error(\"Font bbox does not match expected value\");\n  }\n});",
    "i5_llama-3.3-70b-versatile": "it(\"should compute bbox for a Type3 glyph with setCharWidth operator\", async () => {\n  const { OPS } = await import(\"../../src/shared/util.js\");\n  const { Dict } = await import(\"../../src/core/primitives.js\");\n  const { StringStream } = await import(\"../../src/core/stream.js\");\n  const { OperatorList } = await import(\"../../src/core/operator_list.js\");\n  const { PartialEvaluator, TranslatedFont } = await import(\"../../src/core/evaluator.js\");\n  const { WorkerTask } = await import(\"../../src/core/worker.js\");\n\n  // Create a fake CharProcs dictionary.\n  const charProcs = new Dict();\n  charProcs.getKeys = () => [\"A\"];\n  const fakeStream = new StringStream(\"\");\n  charProcs.get = () => fakeStream;\n\n  // Create a fake Type3 font dictionary.\n  const fontDict = new Dict();\n  fontDict.set(\"CharProcs\", charProcs);\n  fontDict.set(\"Resources\", new Dict());\n\n  // Create a fake Type3 font object with an empty bbox.\n  const font = { isType3Font: true, bbox: [0, 0, 0, 0] };\n  const loadedName = \"TestType3Font\";\n\n  // Instantiate a PartialEvaluator.\n  const evaluator = new PartialEvaluator({});\n  // Override getOperatorList to simulate processing a glyph stream.\n  evaluator.getOperatorList = function({ stream, operatorList }) {\n    operatorList.fnArray.push(OPS.setCharWidth);\n    operatorList.argsArray.push([]); // d0 operator has no bbox info.\n    operatorList.fnArray.push(OPS.constructPath);\n    // The third argument contains the bbox we want to compute.\n    operatorList.argsArray.push([null, null, [10, 20, 30, 40]]);\n    operatorList.length = operatorList.fnArray.length;\n    return Promise.resolve();\n  };\n\n  const task = new WorkerTask(\"test\", \"\");\n  const translatedFont = new TranslatedFont({ loadedName, font, dict: fontDict });\n  await translatedFont.loadType3Data(evaluator, fontDict, task);\n  if (!font.isCharBBox) {\n    throw new Error(\"Expected font.isCharBBox to be true\");\n  }\n  const expected = [10, 20, 30, 40];\n  if (\n    font.bbox[0] !== expected[0] ||\n    font.bbox[1] !== expected[1] ||\n    font.bbox[2] !== expected[2] ||\n    font.bbox[3] !== expected[3]\n  ) {\n    throw new Error(\"Font bbox does not match expected value\");\n  }\n});"
  },
  "19677": {
    "i1_deepseek-r1-distill-llama-70b": "it(\"should set the alpha channel to 255 for CMYK images when using DeviceCmykCS\", async () => {\n  const { JpegImage } = await import(\"../../src/core/jpg.js\");\n  const { ColorSpaceUtils } = await import(\"../../src/core/colorspace_utils.js\");\n  const { DeviceCmykCS } = await import(\"../../src/core/colorspace.js\");\n  // Override the ColorSpaceUtils.cmyk with a DeviceCmykCS instance that produces alpha = 0.\n  ColorSpaceUtils.cmyk = new DeviceCmykCS();\n  ColorSpaceUtils.cmyk.getRgbBuffer = (src, srcOffset, numPixels, dest, destOffset, bits, scale) => {\n    for (let i = 0; i < numPixels; i++) {\n      const idx = destOffset + i * 4;\n      dest[idx] = 10;\n      dest[idx + 1] = 20;\n      dest[idx + 2] = 30;\n      dest[idx + 3] = 0;\n    }\n  };\n  const jpegImage = new JpegImage();\n  const data = new Uint8ClampedArray(4); // one pixel RGBA: [r, g, b, alpha]\n  jpegImage._convertCmykToRgba(data);\n  if (data[3] !== 255) {\n    throw new Error(\"Expected alpha channel value to be 255, but got \" + data[3]);\n  }\n});\n",
    "i1_gpt-4o": "it(\"should set the alpha channel to 255 for CMYK images when using DeviceCmykCS\", async () => {\n  const { JpegImage } = await import(\"../../src/core/jpg.js\");\n  const { ColorSpaceUtils } = await import(\"../../src/core/colorspace_utils.js\");\n  const { DeviceCmykCS } = await import(\"../../src/core/colorspace.js\");\n  // Override the ColorSpaceUtils.cmyk with a DeviceCmykCS instance that produces alpha = 0.\n  ColorSpaceUtils.cmyk = new DeviceCmykCS();\n  ColorSpaceUtils.cmyk.getRgbBuffer = (src, srcOffset, numPixels, dest, destOffset, bits, scale) => {\n    for (let i = 0; i < numPixels; i++) {\n      const idx = destOffset + i * 4;\n      dest[idx] = 10;\n      dest[idx + 1] = 20;\n      dest[idx + 2] = 30;\n      dest[idx + 3] = 0;\n    }\n  };\n  const jpegImage = new JpegImage();\n  const data = new Uint8ClampedArray(4); // one pixel RGBA: [r, g, b, alpha]\n  jpegImage._convertCmykToRgba(data);\n  if (data[3] !== 255) {\n    throw new Error(\"Expected alpha channel value to be 255, but got \" + data[3]);\n  }\n});\n",
    "i1_llama-3.3-70b-versatile": "it(\"should set the alpha channel to 255 for CMYK images when using DeviceCmykCS\", async () => {\n  const { JpegImage } = await import(\"../../src/core/jpg.js\");\n  const { ColorSpaceUtils } = await import(\"../../src/core/colorspace_utils.js\");\n  const { DeviceCmykCS } = await import(\"../../src/core/colorspace.js\");\n  // Override the ColorSpaceUtils.cmyk with a DeviceCmykCS instance that produces alpha = 0.\n  ColorSpaceUtils.cmyk = new DeviceCmykCS();\n  ColorSpaceUtils.cmyk.getRgbBuffer = (src, srcOffset, numPixels, dest, destOffset, bits, scale) => {\n    for (let i = 0; i < numPixels; i++) {\n      const idx = destOffset + i * 4;\n      dest[idx] = 10;\n      dest[idx + 1] = 20;\n      dest[idx + 2] = 30;\n      dest[idx + 3] = 0;\n    }\n  };\n  const jpegImage = new JpegImage();\n  const data = new Uint8ClampedArray(4); // one pixel RGBA: [r, g, b, alpha]\n  jpegImage._convertCmykToRgba(data);\n  if (data[3] !== 255) {\n    throw new Error(\"Expected alpha channel value to be 255, but got \" + data[3]);\n  }\n});\n",
    "i1_MOCK": "it(\"should set the alpha channel to 255 for CMYK images when using DeviceCmykCS\", async () => {\n  const { JpegImage } = await import(\"../../src/core/jpg.js\");\n  const { ColorSpaceUtils } = await import(\"../../src/core/colorspace_utils.js\");\n  const { DeviceCmykCS } = await import(\"../../src/core/colorspace.js\");\n  // Override the ColorSpaceUtils.cmyk with a DeviceCmykCS instance that produces alpha = 0.\n  ColorSpaceUtils.cmyk = new DeviceCmykCS();\n  ColorSpaceUtils.cmyk.getRgbBuffer = (src, srcOffset, numPixels, dest, destOffset, bits, scale) => {\n    for (let i = 0; i < numPixels; i++) {\n      const idx = destOffset + i * 4;\n      dest[idx] = 10;\n      dest[idx + 1] = 20;\n      dest[idx + 2] = 30;\n      dest[idx + 3] = 0;\n    }\n  };\n  const jpegImage = new JpegImage();\n  const data = new Uint8ClampedArray(4); // one pixel RGBA: [r, g, b, alpha]\n  jpegImage._convertCmykToRgba(data);\n  if (data[3] !== 255) {\n    throw new Error(\"Expected alpha channel value to be 255, but got \" + data[3]);\n  }\n});\n",
    "i2_deepseek-r1-distill-llama-70b": "it(\"should set the alpha channel to 255 for CMYK images when using DeviceCmykCS\", async () => {\n  const { JpegImage } = await import(\"../../src/core/jpg.js\");\n  const { ColorSpaceUtils } = await import(\"../../src/core/colorspace_utils.js\");\n  const { DeviceCmykCS } = await import(\"../../src/core/colorspace.js\");\n  // Override the ColorSpaceUtils.cmyk with a DeviceCmykCS instance that produces alpha = 0.\n  ColorSpaceUtils.cmyk = new DeviceCmykCS();\n  ColorSpaceUtils.cmyk.getRgbBuffer = (src, srcOffset, numPixels, dest, destOffset, bits, scale) => {\n    for (let i = 0; i < numPixels; i++) {\n      const idx = destOffset + i * 4;\n      dest[idx] = 10;\n      dest[idx + 1] = 20;\n      dest[idx + 2] = 30;\n      dest[idx + 3] = 0;\n    }\n  };\n  const jpegImage = new JpegImage();\n  const data = new Uint8ClampedArray(4); // one pixel RGBA: [r, g, b, alpha]\n  jpegImage._convertCmykToRgba(data);\n  if (data[3] !== 255) {\n    throw new Error(\"Expected alpha channel value to be 255, but got \" + data[3]);\n  }\n});\n",
    "i2_gpt-4o": "it(\"should set the alpha channel to 255 for CMYK images when using DeviceCmykCS\", async () => {\n  const { JpegImage } = await import(\"../../src/core/jpg.js\");\n  const { ColorSpaceUtils } = await import(\"../../src/core/colorspace_utils.js\");\n  const { DeviceCmykCS } = await import(\"../../src/core/colorspace.js\");\n  // Override the ColorSpaceUtils.cmyk with a DeviceCmykCS instance that produces alpha = 0.\n  ColorSpaceUtils.cmyk = new DeviceCmykCS();\n  ColorSpaceUtils.cmyk.getRgbBuffer = (src, srcOffset, numPixels, dest, destOffset, bits, scale) => {\n    for (let i = 0; i < numPixels; i++) {\n      const idx = destOffset + i * 4;\n      dest[idx] = 10;\n      dest[idx + 1] = 20;\n      dest[idx + 2] = 30;\n      dest[idx + 3] = 0;\n    }\n  };\n  const jpegImage = new JpegImage();\n  const data = new Uint8ClampedArray(4); // one pixel RGBA: [r, g, b, alpha]\n  jpegImage._convertCmykToRgba(data);\n  if (data[3] !== 255) {\n    throw new Error(\"Expected alpha channel value to be 255, but got \" + data[3]);\n  }\n});\n",
    "i2_llama-3.3-70b-versatile": "it(\"should set the alpha channel to 255 for CMYK images when using DeviceCmykCS\", async () => {\n  const { JpegImage } = await import(\"../../src/core/jpg.js\");\n  const { ColorSpaceUtils } = await import(\"../../src/core/colorspace_utils.js\");\n  const { DeviceCmykCS } = await import(\"../../src/core/colorspace.js\");\n  // Override the ColorSpaceUtils.cmyk with a DeviceCmykCS instance that produces alpha = 0.\n  ColorSpaceUtils.cmyk = new DeviceCmykCS();\n  ColorSpaceUtils.cmyk.getRgbBuffer = (src, srcOffset, numPixels, dest, destOffset, bits, scale) => {\n    for (let i = 0; i < numPixels; i++) {\n      const idx = destOffset + i * 4;\n      dest[idx] = 10;\n      dest[idx + 1] = 20;\n      dest[idx + 2] = 30;\n      dest[idx + 3] = 0;\n    }\n  };\n  const jpegImage = new JpegImage();\n  const data = new Uint8ClampedArray(4); // one pixel RGBA: [r, g, b, alpha]\n  jpegImage._convertCmykToRgba(data);\n  if (data[3] !== 255) {\n    throw new Error(\"Expected alpha channel value to be 255, but got \" + data[3]);\n  }\n});\n",
    "i3_deepseek-r1-distill-llama-70b": "it(\"should set the alpha channel to 255 for CMYK images when using DeviceCmykCS\", async () => {\n  const { JpegImage } = await import(\"../../src/core/jpg.js\");\n  const { ColorSpaceUtils } = await import(\"../../src/core/colorspace_utils.js\");\n  const { DeviceCmykCS } = await import(\"../../src/core/colorspace.js\");\n  // Override the ColorSpaceUtils.cmyk with a DeviceCmykCS instance that produces alpha = 0.\n  ColorSpaceUtils.cmyk = new DeviceCmykCS();\n  ColorSpaceUtils.cmyk.getRgbBuffer = (src, srcOffset, numPixels, dest, destOffset, bits, scale) => {\n    for (let i = 0; i < numPixels; i++) {\n      const idx = destOffset + i * 4;\n      dest[idx] = 10;\n      dest[idx + 1] = 20;\n      dest[idx + 2] = 30;\n      dest[idx + 3] = 0;\n    }\n  };\n  const jpegImage = new JpegImage();\n  const data = new Uint8ClampedArray(4); // one pixel RGBA: [r, g, b, alpha]\n  jpegImage._convertCmykToRgba(data);\n  if (data[3] !== 255) {\n    throw new Error(\"Expected alpha channel value to be 255, but got \" + data[3]);\n  }\n});\n",
    "i3_gpt-4o": "it(\"should set the alpha channel to 255 for CMYK images when using DeviceCmykCS\", async () => {\n  const { JpegImage } = await import(\"../../src/core/jpg.js\");\n  const { ColorSpaceUtils } = await import(\"../../src/core/colorspace_utils.js\");\n  const { DeviceCmykCS } = await import(\"../../src/core/colorspace.js\");\n  // Override the ColorSpaceUtils.cmyk with a DeviceCmykCS instance that produces alpha = 0.\n  ColorSpaceUtils.cmyk = new DeviceCmykCS();\n  ColorSpaceUtils.cmyk.getRgbBuffer = (src, srcOffset, numPixels, dest, destOffset, bits, scale) => {\n    for (let i = 0; i < numPixels; i++) {\n      const idx = destOffset + i * 4;\n      dest[idx] = 10;\n      dest[idx + 1] = 20;\n      dest[idx + 2] = 30;\n      dest[idx + 3] = 0;\n    }\n  };\n  const jpegImage = new JpegImage();\n  const data = new Uint8ClampedArray(4); // one pixel RGBA: [r, g, b, alpha]\n  jpegImage._convertCmykToRgba(data);\n  if (data[3] !== 255) {\n    throw new Error(\"Expected alpha channel value to be 255, but got \" + data[3]);\n  }\n});\n",
    "i3_llama-3.3-70b-versatile": "it(\"should set the alpha channel to 255 for CMYK images when using DeviceCmykCS\", async () => {\n  const { JpegImage } = await import(\"../../src/core/jpg.js\");\n  const { ColorSpaceUtils } = await import(\"../../src/core/colorspace_utils.js\");\n  const { DeviceCmykCS } = await import(\"../../src/core/colorspace.js\");\n  // Override the ColorSpaceUtils.cmyk with a DeviceCmykCS instance that produces alpha = 0.\n  ColorSpaceUtils.cmyk = new DeviceCmykCS();\n  ColorSpaceUtils.cmyk.getRgbBuffer = (src, srcOffset, numPixels, dest, destOffset, bits, scale) => {\n    for (let i = 0; i < numPixels; i++) {\n      const idx = destOffset + i * 4;\n      dest[idx] = 10;\n      dest[idx + 1] = 20;\n      dest[idx + 2] = 30;\n      dest[idx + 3] = 0;\n    }\n  };\n  const jpegImage = new JpegImage();\n  const data = new Uint8ClampedArray(4); // one pixel RGBA: [r, g, b, alpha]\n  jpegImage._convertCmykToRgba(data);\n  if (data[3] !== 255) {\n    throw new Error(\"Expected alpha channel value to be 255, but got \" + data[3]);\n  }\n});\n",
    "i4_deepseek-r1-distill-llama-70b": "it(\"should set the alpha channel to 255 for CMYK images when using DeviceCmykCS\", async () => {\n  const { JpegImage } = await import(\"../../src/core/jpg.js\");\n  const { ColorSpaceUtils } = await import(\"../../src/core/colorspace_utils.js\");\n  const { DeviceCmykCS } = await import(\"../../src/core/colorspace.js\");\n  // Override the ColorSpaceUtils.cmyk with a DeviceCmykCS instance that produces alpha = 0.\n  ColorSpaceUtils.cmyk = new DeviceCmykCS();\n  ColorSpaceUtils.cmyk.getRgbBuffer = (src, srcOffset, numPixels, dest, destOffset, bits, scale) => {\n    for (let i = 0; i < numPixels; i++) {\n      const idx = destOffset + i * 4;\n      dest[idx] = 10;\n      dest[idx + 1] = 20;\n      dest[idx + 2] = 30;\n      dest[idx + 3] = 0;\n    }\n  };\n  const jpegImage = new JpegImage();\n  const data = new Uint8ClampedArray(4); // one pixel RGBA: [r, g, b, alpha]\n  jpegImage._convertCmykToRgba(data);\n  if (data[3] !== 255) {\n    throw new Error(\"Expected alpha channel value to be 255, but got \" + data[3]);\n  }\n});\n",
    "i4_gpt-4o": "it(\"should set the alpha channel to 255 for CMYK images when using DeviceCmykCS\", async () => {\n  const { JpegImage } = await import(\"../../src/core/jpg.js\");\n  const { ColorSpaceUtils } = await import(\"../../src/core/colorspace_utils.js\");\n  const { DeviceCmykCS } = await import(\"../../src/core/colorspace.js\");\n  // Override the ColorSpaceUtils.cmyk with a DeviceCmykCS instance that produces alpha = 0.\n  ColorSpaceUtils.cmyk = new DeviceCmykCS();\n  ColorSpaceUtils.cmyk.getRgbBuffer = (src, srcOffset, numPixels, dest, destOffset, bits, scale) => {\n    for (let i = 0; i < numPixels; i++) {\n      const idx = destOffset + i * 4;\n      dest[idx] = 10;\n      dest[idx + 1] = 20;\n      dest[idx + 2] = 30;\n      dest[idx + 3] = 0;\n    }\n  };\n  const jpegImage = new JpegImage();\n  const data = new Uint8ClampedArray(4); // one pixel RGBA: [r, g, b, alpha]\n  jpegImage._convertCmykToRgba(data);\n  if (data[3] !== 255) {\n    throw new Error(\"Expected alpha channel value to be 255, but got \" + data[3]);\n  }\n});\n",
    "i4_llama-3.3-70b-versatile": "it(\"should set the alpha channel to 255 for CMYK images when using DeviceCmykCS\", async () => {\n  const { JpegImage } = await import(\"../../src/core/jpg.js\");\n  const { ColorSpaceUtils } = await import(\"../../src/core/colorspace_utils.js\");\n  const { DeviceCmykCS } = await import(\"../../src/core/colorspace.js\");\n  // Override the ColorSpaceUtils.cmyk with a DeviceCmykCS instance that produces alpha = 0.\n  ColorSpaceUtils.cmyk = new DeviceCmykCS();\n  ColorSpaceUtils.cmyk.getRgbBuffer = (src, srcOffset, numPixels, dest, destOffset, bits, scale) => {\n    for (let i = 0; i < numPixels; i++) {\n      const idx = destOffset + i * 4;\n      dest[idx] = 10;\n      dest[idx + 1] = 20;\n      dest[idx + 2] = 30;\n      dest[idx + 3] = 0;\n    }\n  };\n  const jpegImage = new JpegImage();\n  const data = new Uint8ClampedArray(4); // one pixel RGBA: [r, g, b, alpha]\n  jpegImage._convertCmykToRgba(data);\n  if (data[3] !== 255) {\n    throw new Error(\"Expected alpha channel value to be 255, but got \" + data[3]);\n  }\n});\n",
    "i5_deepseek-r1-distill-llama-70b": "it(\"should set the alpha channel to 255 for CMYK images when using DeviceCmykCS\", async () => {\n  const { JpegImage } = await import(\"../../src/core/jpg.js\");\n  const { ColorSpaceUtils } = await import(\"../../src/core/colorspace_utils.js\");\n  const { DeviceCmykCS } = await import(\"../../src/core/colorspace.js\");\n  // Override the ColorSpaceUtils.cmyk with a DeviceCmykCS instance that produces alpha = 0.\n  ColorSpaceUtils.cmyk = new DeviceCmykCS();\n  ColorSpaceUtils.cmyk.getRgbBuffer = (src, srcOffset, numPixels, dest, destOffset, bits, scale) => {\n    for (let i = 0; i < numPixels; i++) {\n      const idx = destOffset + i * 4;\n      dest[idx] = 10;\n      dest[idx + 1] = 20;\n      dest[idx + 2] = 30;\n      dest[idx + 3] = 0;\n    }\n  };\n  const jpegImage = new JpegImage();\n  const data = new Uint8ClampedArray(4); // one pixel RGBA: [r, g, b, alpha]\n  jpegImage._convertCmykToRgba(data);\n  if (data[3] !== 255) {\n    throw new Error(\"Expected alpha channel value to be 255, but got \" + data[3]);\n  }\n});\n",
    "i5_gpt-4o": "it(\"should set the alpha channel to 255 for CMYK images when using DeviceCmykCS\", async () => {\n  const { JpegImage } = await import(\"../../src/core/jpg.js\");\n  const { ColorSpaceUtils } = await import(\"../../src/core/colorspace_utils.js\");\n  const { DeviceCmykCS } = await import(\"../../src/core/colorspace.js\");\n  // Override the ColorSpaceUtils.cmyk with a DeviceCmykCS instance that produces alpha = 0.\n  ColorSpaceUtils.cmyk = new DeviceCmykCS();\n  ColorSpaceUtils.cmyk.getRgbBuffer = (src, srcOffset, numPixels, dest, destOffset, bits, scale) => {\n    for (let i = 0; i < numPixels; i++) {\n      const idx = destOffset + i * 4;\n      dest[idx] = 10;\n      dest[idx + 1] = 20;\n      dest[idx + 2] = 30;\n      dest[idx + 3] = 0;\n    }\n  };\n  const jpegImage = new JpegImage();\n  const data = new Uint8ClampedArray(4); // one pixel RGBA: [r, g, b, alpha]\n  jpegImage._convertCmykToRgba(data);\n  if (data[3] !== 255) {\n    throw new Error(\"Expected alpha channel value to be 255, but got \" + data[3]);\n  }\n});\n",
    "i5_llama-3.3-70b-versatile": "it(\"should set the alpha channel to 255 for CMYK images when using DeviceCmykCS\", async () => {\n  const { JpegImage } = await import(\"../../src/core/jpg.js\");\n  const { ColorSpaceUtils } = await import(\"../../src/core/colorspace_utils.js\");\n  const { DeviceCmykCS } = await import(\"../../src/core/colorspace.js\");\n  // Override the ColorSpaceUtils.cmyk with a DeviceCmykCS instance that produces alpha = 0.\n  ColorSpaceUtils.cmyk = new DeviceCmykCS();\n  ColorSpaceUtils.cmyk.getRgbBuffer = (src, srcOffset, numPixels, dest, destOffset, bits, scale) => {\n    for (let i = 0; i < numPixels; i++) {\n      const idx = destOffset + i * 4;\n      dest[idx] = 10;\n      dest[idx + 1] = 20;\n      dest[idx + 2] = 30;\n      dest[idx + 3] = 0;\n    }\n  };\n  const jpegImage = new JpegImage();\n  const data = new Uint8ClampedArray(4); // one pixel RGBA: [r, g, b, alpha]\n  jpegImage._convertCmykToRgba(data);\n  if (data[3] !== 255) {\n    throw new Error(\"Expected alpha channel value to be 255, but got \" + data[3]);\n  }\n});\n"
  },
  "19717": {
    "i1_deepseek-r1-distill-llama-70b": "it(\"should preserve fillAlpha and strokeAlpha when entering soft mask mode\", async () => {\n  const { CanvasGraphics } = await import(\"../../src/display/canvas.js\");\n  const fakeInitialCtx = {\n    globalAlpha: 0.5,\n    canvas: { width: 100, height: 100 },\n    setTransform() {},\n    getTransform() {\n      return new DOMMatrix();\n    },\n  };\n  const fakeScratchCtx = {\n    globalAlpha: 0.5,\n    canvas: { width: 100, height: 100 },\n    setTransform() {},\n    getTransform() {\n      return new DOMMatrix();\n    },\n  };\n  const canvasFactory = {\n    getCanvas: (id, width, height) => ({ context: fakeScratchCtx }),\n  };\n  const filterFactory = { addFilter: () => \"\" };\n  const commonObjs = {};\n  const objs = {};\n  const options = { optionalContentConfig: null };\n  const annotationCanvasMap = {};\n  const pageColors = {};\n  const cg = new CanvasGraphics(\n    fakeInitialCtx,\n    commonObjs,\n    objs,\n    canvasFactory,\n    filterFactory,\n    options,\n    annotationCanvasMap,\n    pageColors\n  );\n  cg.current.fillAlpha = 0.3;\n  cg.current.strokeAlpha = 0.4;\n  cg.beginSMaskMode();\n  if (cg.current.fillAlpha !== 0.3) {\n    throw new Error(\"fillAlpha was overridden after entering soft mask mode\");\n  }\n  if (cg.current.strokeAlpha !== 0.4) {\n    throw new Error(\"strokeAlpha was overridden after entering soft mask mode\");\n  }\n});",
    "i1_gpt-4o": "it(\"should preserve fillAlpha and strokeAlpha when entering soft mask mode\", async () => {\n  const { CanvasGraphics } = await import(\"../../src/display/canvas.js\");\n  const fakeInitialCtx = {\n    globalAlpha: 0.5,\n    canvas: { width: 100, height: 100 },\n    setTransform() {},\n    getTransform() {\n      return new DOMMatrix();\n    },\n  };\n  const fakeScratchCtx = {\n    globalAlpha: 0.5,\n    canvas: { width: 100, height: 100 },\n    setTransform() {},\n    getTransform() {\n      return new DOMMatrix();\n    },\n  };\n  const canvasFactory = {\n    getCanvas: (id, width, height) => ({ context: fakeScratchCtx }),\n  };\n  const filterFactory = { addFilter: () => \"\" };\n  const commonObjs = {};\n  const objs = {};\n  const options = { optionalContentConfig: null };\n  const annotationCanvasMap = {};\n  const pageColors = {};\n  const cg = new CanvasGraphics(\n    fakeInitialCtx,\n    commonObjs,\n    objs,\n    canvasFactory,\n    filterFactory,\n    options,\n    annotationCanvasMap,\n    pageColors\n  );\n  cg.current.fillAlpha = 0.3;\n  cg.current.strokeAlpha = 0.4;\n  cg.beginSMaskMode();\n  if (cg.current.fillAlpha !== 0.3) {\n    throw new Error(\"fillAlpha was overridden after entering soft mask mode\");\n  }\n  if (cg.current.strokeAlpha !== 0.4) {\n    throw new Error(\"strokeAlpha was overridden after entering soft mask mode\");\n  }\n});",
    "i1_llama-3.3-70b-versatile": "it(\"should preserve fillAlpha and strokeAlpha when entering soft mask mode\", async () => {\n  const { CanvasGraphics } = await import(\"../../src/display/canvas.js\");\n  const fakeInitialCtx = {\n    globalAlpha: 0.5,\n    canvas: { width: 100, height: 100 },\n    setTransform() {},\n    getTransform() {\n      return new DOMMatrix();\n    },\n  };\n  const fakeScratchCtx = {\n    globalAlpha: 0.5,\n    canvas: { width: 100, height: 100 },\n    setTransform() {},\n    getTransform() {\n      return new DOMMatrix();\n    },\n  };\n  const canvasFactory = {\n    getCanvas: (id, width, height) => ({ context: fakeScratchCtx }),\n  };\n  const filterFactory = { addFilter: () => \"\" };\n  const commonObjs = {};\n  const objs = {};\n  const options = { optionalContentConfig: null };\n  const annotationCanvasMap = {};\n  const pageColors = {};\n  const cg = new CanvasGraphics(\n    fakeInitialCtx,\n    commonObjs,\n    objs,\n    canvasFactory,\n    filterFactory,\n    options,\n    annotationCanvasMap,\n    pageColors\n  );\n  cg.current.fillAlpha = 0.3;\n  cg.current.strokeAlpha = 0.4;\n  cg.beginSMaskMode();\n  if (cg.current.fillAlpha !== 0.3) {\n    throw new Error(\"fillAlpha was overridden after entering soft mask mode\");\n  }\n  if (cg.current.strokeAlpha !== 0.4) {\n    throw new Error(\"strokeAlpha was overridden after entering soft mask mode\");\n  }\n});",
    "i1_MOCK": "it(\"should preserve fillAlpha and strokeAlpha when entering soft mask mode\", async () => {\n  const { CanvasGraphics } = await import(\"../../src/display/canvas.js\");\n  const fakeInitialCtx = {\n    globalAlpha: 0.5,\n    canvas: { width: 100, height: 100 },\n    setTransform() {},\n    getTransform() {\n      return new DOMMatrix();\n    },\n  };\n  const fakeScratchCtx = {\n    globalAlpha: 0.5,\n    canvas: { width: 100, height: 100 },\n    setTransform() {},\n    getTransform() {\n      return new DOMMatrix();\n    },\n  };\n  const canvasFactory = {\n    getCanvas: (id, width, height) => ({ context: fakeScratchCtx }),\n  };\n  const filterFactory = { addFilter: () => \"\" };\n  const commonObjs = {};\n  const objs = {};\n  const options = { optionalContentConfig: null };\n  const annotationCanvasMap = {};\n  const pageColors = {};\n  const cg = new CanvasGraphics(\n    fakeInitialCtx,\n    commonObjs,\n    objs,\n    canvasFactory,\n    filterFactory,\n    options,\n    annotationCanvasMap,\n    pageColors\n  );\n  cg.current.fillAlpha = 0.3;\n  cg.current.strokeAlpha = 0.4;\n  cg.beginSMaskMode();\n  if (cg.current.fillAlpha !== 0.3) {\n    throw new Error(\"fillAlpha was overridden after entering soft mask mode\");\n  }\n  if (cg.current.strokeAlpha !== 0.4) {\n    throw new Error(\"strokeAlpha was overridden after entering soft mask mode\");\n  }\n});",
    "i2_deepseek-r1-distill-llama-70b": "it(\"should preserve fillAlpha and strokeAlpha when entering soft mask mode\", async () => {\n  const { CanvasGraphics } = await import(\"../../src/display/canvas.js\");\n  const fakeInitialCtx = {\n    globalAlpha: 0.5,\n    canvas: { width: 100, height: 100 },\n    setTransform() {},\n    getTransform() {\n      return new DOMMatrix();\n    },\n  };\n  const fakeScratchCtx = {\n    globalAlpha: 0.5,\n    canvas: { width: 100, height: 100 },\n    setTransform() {},\n    getTransform() {\n      return new DOMMatrix();\n    },\n  };\n  const canvasFactory = {\n    getCanvas: (id, width, height) => ({ context: fakeScratchCtx }),\n  };\n  const filterFactory = { addFilter: () => \"\" };\n  const commonObjs = {};\n  const objs = {};\n  const options = { optionalContentConfig: null };\n  const annotationCanvasMap = {};\n  const pageColors = {};\n  const cg = new CanvasGraphics(\n    fakeInitialCtx,\n    commonObjs,\n    objs,\n    canvasFactory,\n    filterFactory,\n    options,\n    annotationCanvasMap,\n    pageColors\n  );\n  cg.current.fillAlpha = 0.3;\n  cg.current.strokeAlpha = 0.4;\n  cg.beginSMaskMode();\n  if (cg.current.fillAlpha !== 0.3) {\n    throw new Error(\"fillAlpha was overridden after entering soft mask mode\");\n  }\n  if (cg.current.strokeAlpha !== 0.4) {\n    throw new Error(\"strokeAlpha was overridden after entering soft mask mode\");\n  }\n});",
    "i2_gpt-4o": "it(\"should preserve fillAlpha and strokeAlpha when entering soft mask mode\", async () => {\n  const { CanvasGraphics } = await import(\"../../src/display/canvas.js\");\n  const fakeInitialCtx = {\n    globalAlpha: 0.5,\n    canvas: { width: 100, height: 100 },\n    setTransform() {},\n    getTransform() {\n      return new DOMMatrix();\n    },\n  };\n  const fakeScratchCtx = {\n    globalAlpha: 0.5,\n    canvas: { width: 100, height: 100 },\n    setTransform() {},\n    getTransform() {\n      return new DOMMatrix();\n    },\n  };\n  const canvasFactory = {\n    getCanvas: (id, width, height) => ({ context: fakeScratchCtx }),\n  };\n  const filterFactory = { addFilter: () => \"\" };\n  const commonObjs = {};\n  const objs = {};\n  const options = { optionalContentConfig: null };\n  const annotationCanvasMap = {};\n  const pageColors = {};\n  const cg = new CanvasGraphics(\n    fakeInitialCtx,\n    commonObjs,\n    objs,\n    canvasFactory,\n    filterFactory,\n    options,\n    annotationCanvasMap,\n    pageColors\n  );\n  cg.current.fillAlpha = 0.3;\n  cg.current.strokeAlpha = 0.4;\n  cg.beginSMaskMode();\n  if (cg.current.fillAlpha !== 0.3) {\n    throw new Error(\"fillAlpha was overridden after entering soft mask mode\");\n  }\n  if (cg.current.strokeAlpha !== 0.4) {\n    throw new Error(\"strokeAlpha was overridden after entering soft mask mode\");\n  }\n});",
    "i2_llama-3.3-70b-versatile": "it(\"should preserve fillAlpha and strokeAlpha when entering soft mask mode\", async () => {\n  const { CanvasGraphics } = await import(\"../../src/display/canvas.js\");\n  const fakeInitialCtx = {\n    globalAlpha: 0.5,\n    canvas: { width: 100, height: 100 },\n    setTransform() {},\n    getTransform() {\n      return new DOMMatrix();\n    },\n  };\n  const fakeScratchCtx = {\n    globalAlpha: 0.5,\n    canvas: { width: 100, height: 100 },\n    setTransform() {},\n    getTransform() {\n      return new DOMMatrix();\n    },\n  };\n  const canvasFactory = {\n    getCanvas: (id, width, height) => ({ context: fakeScratchCtx }),\n  };\n  const filterFactory = { addFilter: () => \"\" };\n  const commonObjs = {};\n  const objs = {};\n  const options = { optionalContentConfig: null };\n  const annotationCanvasMap = {};\n  const pageColors = {};\n  const cg = new CanvasGraphics(\n    fakeInitialCtx,\n    commonObjs,\n    objs,\n    canvasFactory,\n    filterFactory,\n    options,\n    annotationCanvasMap,\n    pageColors\n  );\n  cg.current.fillAlpha = 0.3;\n  cg.current.strokeAlpha = 0.4;\n  cg.beginSMaskMode();\n  if (cg.current.fillAlpha !== 0.3) {\n    throw new Error(\"fillAlpha was overridden after entering soft mask mode\");\n  }\n  if (cg.current.strokeAlpha !== 0.4) {\n    throw new Error(\"strokeAlpha was overridden after entering soft mask mode\");\n  }\n});",
    "i3_deepseek-r1-distill-llama-70b": "it(\"should preserve fillAlpha and strokeAlpha when entering soft mask mode\", async () => {\n  const { CanvasGraphics } = await import(\"../../src/display/canvas.js\");\n  const fakeInitialCtx = {\n    globalAlpha: 0.5,\n    canvas: { width: 100, height: 100 },\n    setTransform() {},\n    getTransform() {\n      return new DOMMatrix();\n    },\n  };\n  const fakeScratchCtx = {\n    globalAlpha: 0.5,\n    canvas: { width: 100, height: 100 },\n    setTransform() {},\n    getTransform() {\n      return new DOMMatrix();\n    },\n  };\n  const canvasFactory = {\n    getCanvas: (id, width, height) => ({ context: fakeScratchCtx }),\n  };\n  const filterFactory = { addFilter: () => \"\" };\n  const commonObjs = {};\n  const objs = {};\n  const options = { optionalContentConfig: null };\n  const annotationCanvasMap = {};\n  const pageColors = {};\n  const cg = new CanvasGraphics(\n    fakeInitialCtx,\n    commonObjs,\n    objs,\n    canvasFactory,\n    filterFactory,\n    options,\n    annotationCanvasMap,\n    pageColors\n  );\n  cg.current.fillAlpha = 0.3;\n  cg.current.strokeAlpha = 0.4;\n  cg.beginSMaskMode();\n  if (cg.current.fillAlpha !== 0.3) {\n    throw new Error(\"fillAlpha was overridden after entering soft mask mode\");\n  }\n  if (cg.current.strokeAlpha !== 0.4) {\n    throw new Error(\"strokeAlpha was overridden after entering soft mask mode\");\n  }\n});",
    "i3_gpt-4o": "it(\"should preserve fillAlpha and strokeAlpha when entering soft mask mode\", async () => {\n  const { CanvasGraphics } = await import(\"../../src/display/canvas.js\");\n  const fakeInitialCtx = {\n    globalAlpha: 0.5,\n    canvas: { width: 100, height: 100 },\n    setTransform() {},\n    getTransform() {\n      return new DOMMatrix();\n    },\n  };\n  const fakeScratchCtx = {\n    globalAlpha: 0.5,\n    canvas: { width: 100, height: 100 },\n    setTransform() {},\n    getTransform() {\n      return new DOMMatrix();\n    },\n  };\n  const canvasFactory = {\n    getCanvas: (id, width, height) => ({ context: fakeScratchCtx }),\n  };\n  const filterFactory = { addFilter: () => \"\" };\n  const commonObjs = {};\n  const objs = {};\n  const options = { optionalContentConfig: null };\n  const annotationCanvasMap = {};\n  const pageColors = {};\n  const cg = new CanvasGraphics(\n    fakeInitialCtx,\n    commonObjs,\n    objs,\n    canvasFactory,\n    filterFactory,\n    options,\n    annotationCanvasMap,\n    pageColors\n  );\n  cg.current.fillAlpha = 0.3;\n  cg.current.strokeAlpha = 0.4;\n  cg.beginSMaskMode();\n  if (cg.current.fillAlpha !== 0.3) {\n    throw new Error(\"fillAlpha was overridden after entering soft mask mode\");\n  }\n  if (cg.current.strokeAlpha !== 0.4) {\n    throw new Error(\"strokeAlpha was overridden after entering soft mask mode\");\n  }\n});",
    "i3_llama-3.3-70b-versatile": "it(\"should preserve fillAlpha and strokeAlpha when entering soft mask mode\", async () => {\n  const { CanvasGraphics } = await import(\"../../src/display/canvas.js\");\n  const fakeInitialCtx = {\n    globalAlpha: 0.5,\n    canvas: { width: 100, height: 100 },\n    setTransform() {},\n    getTransform() {\n      return new DOMMatrix();\n    },\n  };\n  const fakeScratchCtx = {\n    globalAlpha: 0.5,\n    canvas: { width: 100, height: 100 },\n    setTransform() {},\n    getTransform() {\n      return new DOMMatrix();\n    },\n  };\n  const canvasFactory = {\n    getCanvas: (id, width, height) => ({ context: fakeScratchCtx }),\n  };\n  const filterFactory = { addFilter: () => \"\" };\n  const commonObjs = {};\n  const objs = {};\n  const options = { optionalContentConfig: null };\n  const annotationCanvasMap = {};\n  const pageColors = {};\n  const cg = new CanvasGraphics(\n    fakeInitialCtx,\n    commonObjs,\n    objs,\n    canvasFactory,\n    filterFactory,\n    options,\n    annotationCanvasMap,\n    pageColors\n  );\n  cg.current.fillAlpha = 0.3;\n  cg.current.strokeAlpha = 0.4;\n  cg.beginSMaskMode();\n  if (cg.current.fillAlpha !== 0.3) {\n    throw new Error(\"fillAlpha was overridden after entering soft mask mode\");\n  }\n  if (cg.current.strokeAlpha !== 0.4) {\n    throw new Error(\"strokeAlpha was overridden after entering soft mask mode\");\n  }\n});",
    "i4_deepseek-r1-distill-llama-70b": "it(\"should preserve fillAlpha and strokeAlpha when entering soft mask mode\", async () => {\n  const { CanvasGraphics } = await import(\"../../src/display/canvas.js\");\n  const fakeInitialCtx = {\n    globalAlpha: 0.5,\n    canvas: { width: 100, height: 100 },\n    setTransform() {},\n    getTransform() {\n      return new DOMMatrix();\n    },\n  };\n  const fakeScratchCtx = {\n    globalAlpha: 0.5,\n    canvas: { width: 100, height: 100 },\n    setTransform() {},\n    getTransform() {\n      return new DOMMatrix();\n    },\n  };\n  const canvasFactory = {\n    getCanvas: (id, width, height) => ({ context: fakeScratchCtx }),\n  };\n  const filterFactory = { addFilter: () => \"\" };\n  const commonObjs = {};\n  const objs = {};\n  const options = { optionalContentConfig: null };\n  const annotationCanvasMap = {};\n  const pageColors = {};\n  const cg = new CanvasGraphics(\n    fakeInitialCtx,\n    commonObjs,\n    objs,\n    canvasFactory,\n    filterFactory,\n    options,\n    annotationCanvasMap,\n    pageColors\n  );\n  cg.current.fillAlpha = 0.3;\n  cg.current.strokeAlpha = 0.4;\n  cg.beginSMaskMode();\n  if (cg.current.fillAlpha !== 0.3) {\n    throw new Error(\"fillAlpha was overridden after entering soft mask mode\");\n  }\n  if (cg.current.strokeAlpha !== 0.4) {\n    throw new Error(\"strokeAlpha was overridden after entering soft mask mode\");\n  }\n});",
    "i4_gpt-4o": "it(\"should preserve fillAlpha and strokeAlpha when entering soft mask mode\", async () => {\n  const { CanvasGraphics } = await import(\"../../src/display/canvas.js\");\n  const fakeInitialCtx = {\n    globalAlpha: 0.5,\n    canvas: { width: 100, height: 100 },\n    setTransform() {},\n    getTransform() {\n      return new DOMMatrix();\n    },\n  };\n  const fakeScratchCtx = {\n    globalAlpha: 0.5,\n    canvas: { width: 100, height: 100 },\n    setTransform() {},\n    getTransform() {\n      return new DOMMatrix();\n    },\n  };\n  const canvasFactory = {\n    getCanvas: (id, width, height) => ({ context: fakeScratchCtx }),\n  };\n  const filterFactory = { addFilter: () => \"\" };\n  const commonObjs = {};\n  const objs = {};\n  const options = { optionalContentConfig: null };\n  const annotationCanvasMap = {};\n  const pageColors = {};\n  const cg = new CanvasGraphics(\n    fakeInitialCtx,\n    commonObjs,\n    objs,\n    canvasFactory,\n    filterFactory,\n    options,\n    annotationCanvasMap,\n    pageColors\n  );\n  cg.current.fillAlpha = 0.3;\n  cg.current.strokeAlpha = 0.4;\n  cg.beginSMaskMode();\n  if (cg.current.fillAlpha !== 0.3) {\n    throw new Error(\"fillAlpha was overridden after entering soft mask mode\");\n  }\n  if (cg.current.strokeAlpha !== 0.4) {\n    throw new Error(\"strokeAlpha was overridden after entering soft mask mode\");\n  }\n});",
    "i4_llama-3.3-70b-versatile": "it(\"should preserve fillAlpha and strokeAlpha when entering soft mask mode\", async () => {\n  const { CanvasGraphics } = await import(\"../../src/display/canvas.js\");\n  const fakeInitialCtx = {\n    globalAlpha: 0.5,\n    canvas: { width: 100, height: 100 },\n    setTransform() {},\n    getTransform() {\n      return new DOMMatrix();\n    },\n  };\n  const fakeScratchCtx = {\n    globalAlpha: 0.5,\n    canvas: { width: 100, height: 100 },\n    setTransform() {},\n    getTransform() {\n      return new DOMMatrix();\n    },\n  };\n  const canvasFactory = {\n    getCanvas: (id, width, height) => ({ context: fakeScratchCtx }),\n  };\n  const filterFactory = { addFilter: () => \"\" };\n  const commonObjs = {};\n  const objs = {};\n  const options = { optionalContentConfig: null };\n  const annotationCanvasMap = {};\n  const pageColors = {};\n  const cg = new CanvasGraphics(\n    fakeInitialCtx,\n    commonObjs,\n    objs,\n    canvasFactory,\n    filterFactory,\n    options,\n    annotationCanvasMap,\n    pageColors\n  );\n  cg.current.fillAlpha = 0.3;\n  cg.current.strokeAlpha = 0.4;\n  cg.beginSMaskMode();\n  if (cg.current.fillAlpha !== 0.3) {\n    throw new Error(\"fillAlpha was overridden after entering soft mask mode\");\n  }\n  if (cg.current.strokeAlpha !== 0.4) {\n    throw new Error(\"strokeAlpha was overridden after entering soft mask mode\");\n  }\n});",
    "i5_deepseek-r1-distill-llama-70b": "it(\"should preserve fillAlpha and strokeAlpha when entering soft mask mode\", async () => {\n  const { CanvasGraphics } = await import(\"../../src/display/canvas.js\");\n  const fakeInitialCtx = {\n    globalAlpha: 0.5,\n    canvas: { width: 100, height: 100 },\n    setTransform() {},\n    getTransform() {\n      return new DOMMatrix();\n    },\n  };\n  const fakeScratchCtx = {\n    globalAlpha: 0.5,\n    canvas: { width: 100, height: 100 },\n    setTransform() {},\n    getTransform() {\n      return new DOMMatrix();\n    },\n  };\n  const canvasFactory = {\n    getCanvas: (id, width, height) => ({ context: fakeScratchCtx }),\n  };\n  const filterFactory = { addFilter: () => \"\" };\n  const commonObjs = {};\n  const objs = {};\n  const options = { optionalContentConfig: null };\n  const annotationCanvasMap = {};\n  const pageColors = {};\n  const cg = new CanvasGraphics(\n    fakeInitialCtx,\n    commonObjs,\n    objs,\n    canvasFactory,\n    filterFactory,\n    options,\n    annotationCanvasMap,\n    pageColors\n  );\n  cg.current.fillAlpha = 0.3;\n  cg.current.strokeAlpha = 0.4;\n  cg.beginSMaskMode();\n  if (cg.current.fillAlpha !== 0.3) {\n    throw new Error(\"fillAlpha was overridden after entering soft mask mode\");\n  }\n  if (cg.current.strokeAlpha !== 0.4) {\n    throw new Error(\"strokeAlpha was overridden after entering soft mask mode\");\n  }\n});",
    "i5_gpt-4o": "it(\"should preserve fillAlpha and strokeAlpha when entering soft mask mode\", async () => {\n  const { CanvasGraphics } = await import(\"../../src/display/canvas.js\");\n  const fakeInitialCtx = {\n    globalAlpha: 0.5,\n    canvas: { width: 100, height: 100 },\n    setTransform() {},\n    getTransform() {\n      return new DOMMatrix();\n    },\n  };\n  const fakeScratchCtx = {\n    globalAlpha: 0.5,\n    canvas: { width: 100, height: 100 },\n    setTransform() {},\n    getTransform() {\n      return new DOMMatrix();\n    },\n  };\n  const canvasFactory = {\n    getCanvas: (id, width, height) => ({ context: fakeScratchCtx }),\n  };\n  const filterFactory = { addFilter: () => \"\" };\n  const commonObjs = {};\n  const objs = {};\n  const options = { optionalContentConfig: null };\n  const annotationCanvasMap = {};\n  const pageColors = {};\n  const cg = new CanvasGraphics(\n    fakeInitialCtx,\n    commonObjs,\n    objs,\n    canvasFactory,\n    filterFactory,\n    options,\n    annotationCanvasMap,\n    pageColors\n  );\n  cg.current.fillAlpha = 0.3;\n  cg.current.strokeAlpha = 0.4;\n  cg.beginSMaskMode();\n  if (cg.current.fillAlpha !== 0.3) {\n    throw new Error(\"fillAlpha was overridden after entering soft mask mode\");\n  }\n  if (cg.current.strokeAlpha !== 0.4) {\n    throw new Error(\"strokeAlpha was overridden after entering soft mask mode\");\n  }\n});",
    "i5_llama-3.3-70b-versatile": "it(\"should preserve fillAlpha and strokeAlpha when entering soft mask mode\", async () => {\n  const { CanvasGraphics } = await import(\"../../src/display/canvas.js\");\n  const fakeInitialCtx = {\n    globalAlpha: 0.5,\n    canvas: { width: 100, height: 100 },\n    setTransform() {},\n    getTransform() {\n      return new DOMMatrix();\n    },\n  };\n  const fakeScratchCtx = {\n    globalAlpha: 0.5,\n    canvas: { width: 100, height: 100 },\n    setTransform() {},\n    getTransform() {\n      return new DOMMatrix();\n    },\n  };\n  const canvasFactory = {\n    getCanvas: (id, width, height) => ({ context: fakeScratchCtx }),\n  };\n  const filterFactory = { addFilter: () => \"\" };\n  const commonObjs = {};\n  const objs = {};\n  const options = { optionalContentConfig: null };\n  const annotationCanvasMap = {};\n  const pageColors = {};\n  const cg = new CanvasGraphics(\n    fakeInitialCtx,\n    commonObjs,\n    objs,\n    canvasFactory,\n    filterFactory,\n    options,\n    annotationCanvasMap,\n    pageColors\n  );\n  cg.current.fillAlpha = 0.3;\n  cg.current.strokeAlpha = 0.4;\n  cg.beginSMaskMode();\n  if (cg.current.fillAlpha !== 0.3) {\n    throw new Error(\"fillAlpha was overridden after entering soft mask mode\");\n  }\n  if (cg.current.strokeAlpha !== 0.4) {\n    throw new Error(\"strokeAlpha was overridden after entering soft mask mode\");\n  }\n});"
  },
  "19765": {
    "i1_deepseek-r1-distill-llama-70b": "it(\"should apply a margin style separator space to the radiocheckbox input via the patched toStyle call\", async () => {\n  const { XFAFactory } = await import(\"../../src/core/xfa/factory.js\");\n  const { $toHTML } = await import(\"../../src/core/xfa/symbol_utils.js\");\n  const xml = `\n    <xdp:xdp xmlns:xdp=\"http://ns.adobe.com/xdp/\">\n      <template xmlns=\"http://www.xfa.org/schema/xfa-template/3.3/\">\n        <subform>\n          <exclGroup>\n            <field name=\"TestField\">\n              <checkButton size=\"10pt\" margin=\"5px\">\n                <items>\n                  <text>Yes</text>\n                  <text>No</text>\n                </items>\n                <value>Yes</value>\n              </checkButton>\n            </field>\n          </exclGroup>\n        </subform>\n      </template>\n    </xdp:xdp>\n  `;\n  const xfa = await XFAFactory.create(xml);\n  // Resolve the field by its name.\n  const field = xfa.resolveNode(\"TestField\");\n  // The checkButton is the first (and only) item in field.items.children.\n  const checkButton = field.items.children[0];\n  // Force the margin to be set (the factory should pick it up from the XML).\n  // Render the checkButton into HTML.\n  const htmlResult = checkButton[$toHTML]();\n  // The returned HTML is a label that wraps the input.\n  const input = htmlResult.html.children[0];\n  // The style object should now include the margin from the checkButton (\"5px\")\n  const style = input.attributes.style;\n  if (!style.margin || style.margin !== \"5px\") {\n    throw new Error(\"Expected margin style '5px', but got: \" + (style.margin || \"undefined\"));\n  }\n});\n",
    "i1_gpt-4o": "it(\"should apply a margin style separator space to the radiocheckbox input via the patched toStyle call\", async () => {\n  const { XFAFactory } = await import(\"../../src/core/xfa/factory.js\");\n  const { $toHTML } = await import(\"../../src/core/xfa/symbol_utils.js\");\n  const xml = `\n    <xdp:xdp xmlns:xdp=\"http://ns.adobe.com/xdp/\">\n      <template xmlns=\"http://www.xfa.org/schema/xfa-template/3.3/\">\n        <subform>\n          <exclGroup>\n            <field name=\"TestField\">\n              <checkButton size=\"10pt\" margin=\"5px\">\n                <items>\n                  <text>Yes</text>\n                  <text>No</text>\n                </items>\n                <value>Yes</value>\n              </checkButton>\n            </field>\n          </exclGroup>\n        </subform>\n      </template>\n    </xdp:xdp>\n  `;\n  const xfa = await XFAFactory.create(xml);\n  // Resolve the field by its name.\n  const field = xfa.resolveNode(\"TestField\");\n  // The checkButton is the first (and only) item in field.items.children.\n  const checkButton = field.items.children[0];\n  // Force the margin to be set (the factory should pick it up from the XML).\n  // Render the checkButton into HTML.\n  const htmlResult = checkButton[$toHTML]();\n  // The returned HTML is a label that wraps the input.\n  const input = htmlResult.html.children[0];\n  // The style object should now include the margin from the checkButton (\"5px\")\n  const style = input.attributes.style;\n  if (!style.margin || style.margin !== \"5px\") {\n    throw new Error(\"Expected margin style '5px', but got: \" + (style.margin || \"undefined\"));\n  }\n});\n",
    "i1_llama-3.3-70b-versatile": "it(\"should apply a margin style separator space to the radiocheckbox input via the patched toStyle call\", async () => {\n  const { XFAFactory } = await import(\"../../src/core/xfa/factory.js\");\n  const { $toHTML } = await import(\"../../src/core/xfa/symbol_utils.js\");\n  const xml = `\n    <xdp:xdp xmlns:xdp=\"http://ns.adobe.com/xdp/\">\n      <template xmlns=\"http://www.xfa.org/schema/xfa-template/3.3/\">\n        <subform>\n          <exclGroup>\n            <field name=\"TestField\">\n              <checkButton size=\"10pt\" margin=\"5px\">\n                <items>\n                  <text>Yes</text>\n                  <text>No</text>\n                </items>\n                <value>Yes</value>\n              </checkButton>\n            </field>\n          </exclGroup>\n        </subform>\n      </template>\n    </xdp:xdp>\n  `;\n  const xfa = await XFAFactory.create(xml);\n  // Resolve the field by its name.\n  const field = xfa.resolveNode(\"TestField\");\n  // The checkButton is the first (and only) item in field.items.children.\n  const checkButton = field.items.children[0];\n  // Force the margin to be set (the factory should pick it up from the XML).\n  // Render the checkButton into HTML.\n  const htmlResult = checkButton[$toHTML]();\n  // The returned HTML is a label that wraps the input.\n  const input = htmlResult.html.children[0];\n  // The style object should now include the margin from the checkButton (\"5px\")\n  const style = input.attributes.style;\n  if (!style.margin || style.margin !== \"5px\") {\n    throw new Error(\"Expected margin style '5px', but got: \" + (style.margin || \"undefined\"));\n  }\n});\n",
    "i1_MOCK": "it(\"should apply a margin style separator space to the radiocheckbox input via the patched toStyle call\", async () => {\n  const { XFAFactory } = await import(\"../../src/core/xfa/factory.js\");\n  const { $toHTML } = await import(\"../../src/core/xfa/symbol_utils.js\");\n  const xml = `\n    <xdp:xdp xmlns:xdp=\"http://ns.adobe.com/xdp/\">\n      <template xmlns=\"http://www.xfa.org/schema/xfa-template/3.3/\">\n        <subform>\n          <exclGroup>\n            <field name=\"TestField\">\n              <checkButton size=\"10pt\" margin=\"5px\">\n                <items>\n                  <text>Yes</text>\n                  <text>No</text>\n                </items>\n                <value>Yes</value>\n              </checkButton>\n            </field>\n          </exclGroup>\n        </subform>\n      </template>\n    </xdp:xdp>\n  `;\n  const xfa = await XFAFactory.create(xml);\n  // Resolve the field by its name.\n  const field = xfa.resolveNode(\"TestField\");\n  // The checkButton is the first (and only) item in field.items.children.\n  const checkButton = field.items.children[0];\n  // Force the margin to be set (the factory should pick it up from the XML).\n  // Render the checkButton into HTML.\n  const htmlResult = checkButton[$toHTML]();\n  // The returned HTML is a label that wraps the input.\n  const input = htmlResult.html.children[0];\n  // The style object should now include the margin from the checkButton (\"5px\")\n  const style = input.attributes.style;\n  if (!style.margin || style.margin !== \"5px\") {\n    throw new Error(\"Expected margin style '5px', but got: \" + (style.margin || \"undefined\"));\n  }\n});\n",
    "i2_deepseek-r1-distill-llama-70b": "it(\"should apply a margin style separator space to the radiocheckbox input via the patched toStyle call\", async () => {\n  const { XFAFactory } = await import(\"../../src/core/xfa/factory.js\");\n  const { $toHTML } = await import(\"../../src/core/xfa/symbol_utils.js\");\n  const xml = `\n    <xdp:xdp xmlns:xdp=\"http://ns.adobe.com/xdp/\">\n      <template xmlns=\"http://www.xfa.org/schema/xfa-template/3.3/\">\n        <subform>\n          <exclGroup>\n            <field name=\"TestField\">\n              <checkButton size=\"10pt\" margin=\"5px\">\n                <items>\n                  <text>Yes</text>\n                  <text>No</text>\n                </items>\n                <value>Yes</value>\n              </checkButton>\n            </field>\n          </exclGroup>\n        </subform>\n      </template>\n    </xdp:xdp>\n  `;\n  const xfa = await XFAFactory.create(xml);\n  // Resolve the field by its name.\n  const field = xfa.resolveNode(\"TestField\");\n  // The checkButton is the first (and only) item in field.items.children.\n  const checkButton = field.items.children[0];\n  // Force the margin to be set (the factory should pick it up from the XML).\n  // Render the checkButton into HTML.\n  const htmlResult = checkButton[$toHTML]();\n  // The returned HTML is a label that wraps the input.\n  const input = htmlResult.html.children[0];\n  // The style object should now include the margin from the checkButton (\"5px\")\n  const style = input.attributes.style;\n  if (!style.margin || style.margin !== \"5px\") {\n    throw new Error(\"Expected margin style '5px', but got: \" + (style.margin || \"undefined\"));\n  }\n});\n",
    "i2_gpt-4o": "it(\"should apply a margin style separator space to the radiocheckbox input via the patched toStyle call\", async () => {\n  const { XFAFactory } = await import(\"../../src/core/xfa/factory.js\");\n  const { $toHTML } = await import(\"../../src/core/xfa/symbol_utils.js\");\n  const xml = `\n    <xdp:xdp xmlns:xdp=\"http://ns.adobe.com/xdp/\">\n      <template xmlns=\"http://www.xfa.org/schema/xfa-template/3.3/\">\n        <subform>\n          <exclGroup>\n            <field name=\"TestField\">\n              <checkButton size=\"10pt\" margin=\"5px\">\n                <items>\n                  <text>Yes</text>\n                  <text>No</text>\n                </items>\n                <value>Yes</value>\n              </checkButton>\n            </field>\n          </exclGroup>\n        </subform>\n      </template>\n    </xdp:xdp>\n  `;\n  const xfa = await XFAFactory.create(xml);\n  // Resolve the field by its name.\n  const field = xfa.resolveNode(\"TestField\");\n  // The checkButton is the first (and only) item in field.items.children.\n  const checkButton = field.items.children[0];\n  // Force the margin to be set (the factory should pick it up from the XML).\n  // Render the checkButton into HTML.\n  const htmlResult = checkButton[$toHTML]();\n  // The returned HTML is a label that wraps the input.\n  const input = htmlResult.html.children[0];\n  // The style object should now include the margin from the checkButton (\"5px\")\n  const style = input.attributes.style;\n  if (!style.margin || style.margin !== \"5px\") {\n    throw new Error(\"Expected margin style '5px', but got: \" + (style.margin || \"undefined\"));\n  }\n});\n",
    "i2_llama-3.3-70b-versatile": "it(\"should apply a margin style separator space to the radiocheckbox input via the patched toStyle call\", async () => {\n  const { XFAFactory } = await import(\"../../src/core/xfa/factory.js\");\n  const { $toHTML } = await import(\"../../src/core/xfa/symbol_utils.js\");\n  const xml = `\n    <xdp:xdp xmlns:xdp=\"http://ns.adobe.com/xdp/\">\n      <template xmlns=\"http://www.xfa.org/schema/xfa-template/3.3/\">\n        <subform>\n          <exclGroup>\n            <field name=\"TestField\">\n              <checkButton size=\"10pt\" margin=\"5px\">\n                <items>\n                  <text>Yes</text>\n                  <text>No</text>\n                </items>\n                <value>Yes</value>\n              </checkButton>\n            </field>\n          </exclGroup>\n        </subform>\n      </template>\n    </xdp:xdp>\n  `;\n  const xfa = await XFAFactory.create(xml);\n  // Resolve the field by its name.\n  const field = xfa.resolveNode(\"TestField\");\n  // The checkButton is the first (and only) item in field.items.children.\n  const checkButton = field.items.children[0];\n  // Force the margin to be set (the factory should pick it up from the XML).\n  // Render the checkButton into HTML.\n  const htmlResult = checkButton[$toHTML]();\n  // The returned HTML is a label that wraps the input.\n  const input = htmlResult.html.children[0];\n  // The style object should now include the margin from the checkButton (\"5px\")\n  const style = input.attributes.style;\n  if (!style.margin || style.margin !== \"5px\") {\n    throw new Error(\"Expected margin style '5px', but got: \" + (style.margin || \"undefined\"));\n  }\n});\n",
    "i3_deepseek-r1-distill-llama-70b": "it(\"should apply a margin style separator space to the radiocheckbox input via the patched toStyle call\", async () => {\n  const { XFAFactory } = await import(\"../../src/core/xfa/factory.js\");\n  const { $toHTML } = await import(\"../../src/core/xfa/symbol_utils.js\");\n  const xml = `\n    <xdp:xdp xmlns:xdp=\"http://ns.adobe.com/xdp/\">\n      <template xmlns=\"http://www.xfa.org/schema/xfa-template/3.3/\">\n        <subform>\n          <exclGroup>\n            <field name=\"TestField\">\n              <checkButton size=\"10pt\" margin=\"5px\">\n                <items>\n                  <text>Yes</text>\n                  <text>No</text>\n                </items>\n                <value>Yes</value>\n              </checkButton>\n            </field>\n          </exclGroup>\n        </subform>\n      </template>\n    </xdp:xdp>\n  `;\n  const xfa = await XFAFactory.create(xml);\n  // Resolve the field by its name.\n  const field = xfa.resolveNode(\"TestField\");\n  // The checkButton is the first (and only) item in field.items.children.\n  const checkButton = field.items.children[0];\n  // Force the margin to be set (the factory should pick it up from the XML).\n  // Render the checkButton into HTML.\n  const htmlResult = checkButton[$toHTML]();\n  // The returned HTML is a label that wraps the input.\n  const input = htmlResult.html.children[0];\n  // The style object should now include the margin from the checkButton (\"5px\")\n  const style = input.attributes.style;\n  if (!style.margin || style.margin !== \"5px\") {\n    throw new Error(\"Expected margin style '5px', but got: \" + (style.margin || \"undefined\"));\n  }\n});\n",
    "i3_gpt-4o": "it(\"should apply a margin style separator space to the radiocheckbox input via the patched toStyle call\", async () => {\n  const { XFAFactory } = await import(\"../../src/core/xfa/factory.js\");\n  const { $toHTML } = await import(\"../../src/core/xfa/symbol_utils.js\");\n  const xml = `\n    <xdp:xdp xmlns:xdp=\"http://ns.adobe.com/xdp/\">\n      <template xmlns=\"http://www.xfa.org/schema/xfa-template/3.3/\">\n        <subform>\n          <exclGroup>\n            <field name=\"TestField\">\n              <checkButton size=\"10pt\" margin=\"5px\">\n                <items>\n                  <text>Yes</text>\n                  <text>No</text>\n                </items>\n                <value>Yes</value>\n              </checkButton>\n            </field>\n          </exclGroup>\n        </subform>\n      </template>\n    </xdp:xdp>\n  `;\n  const xfa = await XFAFactory.create(xml);\n  // Resolve the field by its name.\n  const field = xfa.resolveNode(\"TestField\");\n  // The checkButton is the first (and only) item in field.items.children.\n  const checkButton = field.items.children[0];\n  // Force the margin to be set (the factory should pick it up from the XML).\n  // Render the checkButton into HTML.\n  const htmlResult = checkButton[$toHTML]();\n  // The returned HTML is a label that wraps the input.\n  const input = htmlResult.html.children[0];\n  // The style object should now include the margin from the checkButton (\"5px\")\n  const style = input.attributes.style;\n  if (!style.margin || style.margin !== \"5px\") {\n    throw new Error(\"Expected margin style '5px', but got: \" + (style.margin || \"undefined\"));\n  }\n});\n",
    "i3_llama-3.3-70b-versatile": "it(\"should apply a margin style separator space to the radiocheckbox input via the patched toStyle call\", async () => {\n  const { XFAFactory } = await import(\"../../src/core/xfa/factory.js\");\n  const { $toHTML } = await import(\"../../src/core/xfa/symbol_utils.js\");\n  const xml = `\n    <xdp:xdp xmlns:xdp=\"http://ns.adobe.com/xdp/\">\n      <template xmlns=\"http://www.xfa.org/schema/xfa-template/3.3/\">\n        <subform>\n          <exclGroup>\n            <field name=\"TestField\">\n              <checkButton size=\"10pt\" margin=\"5px\">\n                <items>\n                  <text>Yes</text>\n                  <text>No</text>\n                </items>\n                <value>Yes</value>\n              </checkButton>\n            </field>\n          </exclGroup>\n        </subform>\n      </template>\n    </xdp:xdp>\n  `;\n  const xfa = await XFAFactory.create(xml);\n  // Resolve the field by its name.\n  const field = xfa.resolveNode(\"TestField\");\n  // The checkButton is the first (and only) item in field.items.children.\n  const checkButton = field.items.children[0];\n  // Force the margin to be set (the factory should pick it up from the XML).\n  // Render the checkButton into HTML.\n  const htmlResult = checkButton[$toHTML]();\n  // The returned HTML is a label that wraps the input.\n  const input = htmlResult.html.children[0];\n  // The style object should now include the margin from the checkButton (\"5px\")\n  const style = input.attributes.style;\n  if (!style.margin || style.margin !== \"5px\") {\n    throw new Error(\"Expected margin style '5px', but got: \" + (style.margin || \"undefined\"));\n  }\n});\n",
    "i4_deepseek-r1-distill-llama-70b": "it(\"should apply a margin style separator space to the radiocheckbox input via the patched toStyle call\", async () => {\n  const { XFAFactory } = await import(\"../../src/core/xfa/factory.js\");\n  const { $toHTML } = await import(\"../../src/core/xfa/symbol_utils.js\");\n  const xml = `\n    <xdp:xdp xmlns:xdp=\"http://ns.adobe.com/xdp/\">\n      <template xmlns=\"http://www.xfa.org/schema/xfa-template/3.3/\">\n        <subform>\n          <exclGroup>\n            <field name=\"TestField\">\n              <checkButton size=\"10pt\" margin=\"5px\">\n                <items>\n                  <text>Yes</text>\n                  <text>No</text>\n                </items>\n                <value>Yes</value>\n              </checkButton>\n            </field>\n          </exclGroup>\n        </subform>\n      </template>\n    </xdp:xdp>\n  `;\n  const xfa = await XFAFactory.create(xml);\n  // Resolve the field by its name.\n  const field = xfa.resolveNode(\"TestField\");\n  // The checkButton is the first (and only) item in field.items.children.\n  const checkButton = field.items.children[0];\n  // Force the margin to be set (the factory should pick it up from the XML).\n  // Render the checkButton into HTML.\n  const htmlResult = checkButton[$toHTML]();\n  // The returned HTML is a label that wraps the input.\n  const input = htmlResult.html.children[0];\n  // The style object should now include the margin from the checkButton (\"5px\")\n  const style = input.attributes.style;\n  if (!style.margin || style.margin !== \"5px\") {\n    throw new Error(\"Expected margin style '5px', but got: \" + (style.margin || \"undefined\"));\n  }\n});\n",
    "i4_gpt-4o": "it(\"should apply a margin style separator space to the radiocheckbox input via the patched toStyle call\", async () => {\n  const { XFAFactory } = await import(\"../../src/core/xfa/factory.js\");\n  const { $toHTML } = await import(\"../../src/core/xfa/symbol_utils.js\");\n  const xml = `\n    <xdp:xdp xmlns:xdp=\"http://ns.adobe.com/xdp/\">\n      <template xmlns=\"http://www.xfa.org/schema/xfa-template/3.3/\">\n        <subform>\n          <exclGroup>\n            <field name=\"TestField\">\n              <checkButton size=\"10pt\" margin=\"5px\">\n                <items>\n                  <text>Yes</text>\n                  <text>No</text>\n                </items>\n                <value>Yes</value>\n              </checkButton>\n            </field>\n          </exclGroup>\n        </subform>\n      </template>\n    </xdp:xdp>\n  `;\n  const xfa = await XFAFactory.create(xml);\n  // Resolve the field by its name.\n  const field = xfa.resolveNode(\"TestField\");\n  // The checkButton is the first (and only) item in field.items.children.\n  const checkButton = field.items.children[0];\n  // Force the margin to be set (the factory should pick it up from the XML).\n  // Render the checkButton into HTML.\n  const htmlResult = checkButton[$toHTML]();\n  // The returned HTML is a label that wraps the input.\n  const input = htmlResult.html.children[0];\n  // The style object should now include the margin from the checkButton (\"5px\")\n  const style = input.attributes.style;\n  if (!style.margin || style.margin !== \"5px\") {\n    throw new Error(\"Expected margin style '5px', but got: \" + (style.margin || \"undefined\"));\n  }\n});\n",
    "i4_llama-3.3-70b-versatile": "it(\"should apply a margin style separator space to the radiocheckbox input via the patched toStyle call\", async () => {\n  const { XFAFactory } = await import(\"../../src/core/xfa/factory.js\");\n  const { $toHTML } = await import(\"../../src/core/xfa/symbol_utils.js\");\n  const xml = `\n    <xdp:xdp xmlns:xdp=\"http://ns.adobe.com/xdp/\">\n      <template xmlns=\"http://www.xfa.org/schema/xfa-template/3.3/\">\n        <subform>\n          <exclGroup>\n            <field name=\"TestField\">\n              <checkButton size=\"10pt\" margin=\"5px\">\n                <items>\n                  <text>Yes</text>\n                  <text>No</text>\n                </items>\n                <value>Yes</value>\n              </checkButton>\n            </field>\n          </exclGroup>\n        </subform>\n      </template>\n    </xdp:xdp>\n  `;\n  const xfa = await XFAFactory.create(xml);\n  // Resolve the field by its name.\n  const field = xfa.resolveNode(\"TestField\");\n  // The checkButton is the first (and only) item in field.items.children.\n  const checkButton = field.items.children[0];\n  // Force the margin to be set (the factory should pick it up from the XML).\n  // Render the checkButton into HTML.\n  const htmlResult = checkButton[$toHTML]();\n  // The returned HTML is a label that wraps the input.\n  const input = htmlResult.html.children[0];\n  // The style object should now include the margin from the checkButton (\"5px\")\n  const style = input.attributes.style;\n  if (!style.margin || style.margin !== \"5px\") {\n    throw new Error(\"Expected margin style '5px', but got: \" + (style.margin || \"undefined\"));\n  }\n});\n",
    "i5_deepseek-r1-distill-llama-70b": "it(\"should apply a margin style separator space to the radiocheckbox input via the patched toStyle call\", async () => {\n  const { XFAFactory } = await import(\"../../src/core/xfa/factory.js\");\n  const { $toHTML } = await import(\"../../src/core/xfa/symbol_utils.js\");\n  const xml = `\n    <xdp:xdp xmlns:xdp=\"http://ns.adobe.com/xdp/\">\n      <template xmlns=\"http://www.xfa.org/schema/xfa-template/3.3/\">\n        <subform>\n          <exclGroup>\n            <field name=\"TestField\">\n              <checkButton size=\"10pt\" margin=\"5px\">\n                <items>\n                  <text>Yes</text>\n                  <text>No</text>\n                </items>\n                <value>Yes</value>\n              </checkButton>\n            </field>\n          </exclGroup>\n        </subform>\n      </template>\n    </xdp:xdp>\n  `;\n  const xfa = await XFAFactory.create(xml);\n  // Resolve the field by its name.\n  const field = xfa.resolveNode(\"TestField\");\n  // The checkButton is the first (and only) item in field.items.children.\n  const checkButton = field.items.children[0];\n  // Force the margin to be set (the factory should pick it up from the XML).\n  // Render the checkButton into HTML.\n  const htmlResult = checkButton[$toHTML]();\n  // The returned HTML is a label that wraps the input.\n  const input = htmlResult.html.children[0];\n  // The style object should now include the margin from the checkButton (\"5px\")\n  const style = input.attributes.style;\n  if (!style.margin || style.margin !== \"5px\") {\n    throw new Error(\"Expected margin style '5px', but got: \" + (style.margin || \"undefined\"));\n  }\n});\n",
    "i5_gpt-4o": "it(\"should apply a margin style separator space to the radiocheckbox input via the patched toStyle call\", async () => {\n  const { XFAFactory } = await import(\"../../src/core/xfa/factory.js\");\n  const { $toHTML } = await import(\"../../src/core/xfa/symbol_utils.js\");\n  const xml = `\n    <xdp:xdp xmlns:xdp=\"http://ns.adobe.com/xdp/\">\n      <template xmlns=\"http://www.xfa.org/schema/xfa-template/3.3/\">\n        <subform>\n          <exclGroup>\n            <field name=\"TestField\">\n              <checkButton size=\"10pt\" margin=\"5px\">\n                <items>\n                  <text>Yes</text>\n                  <text>No</text>\n                </items>\n                <value>Yes</value>\n              </checkButton>\n            </field>\n          </exclGroup>\n        </subform>\n      </template>\n    </xdp:xdp>\n  `;\n  const xfa = await XFAFactory.create(xml);\n  // Resolve the field by its name.\n  const field = xfa.resolveNode(\"TestField\");\n  // The checkButton is the first (and only) item in field.items.children.\n  const checkButton = field.items.children[0];\n  // Force the margin to be set (the factory should pick it up from the XML).\n  // Render the checkButton into HTML.\n  const htmlResult = checkButton[$toHTML]();\n  // The returned HTML is a label that wraps the input.\n  const input = htmlResult.html.children[0];\n  // The style object should now include the margin from the checkButton (\"5px\")\n  const style = input.attributes.style;\n  if (!style.margin || style.margin !== \"5px\") {\n    throw new Error(\"Expected margin style '5px', but got: \" + (style.margin || \"undefined\"));\n  }\n});\n",
    "i5_llama-3.3-70b-versatile": "it(\"should apply a margin style separator space to the radiocheckbox input via the patched toStyle call\", async () => {\n  const { XFAFactory } = await import(\"../../src/core/xfa/factory.js\");\n  const { $toHTML } = await import(\"../../src/core/xfa/symbol_utils.js\");\n  const xml = `\n    <xdp:xdp xmlns:xdp=\"http://ns.adobe.com/xdp/\">\n      <template xmlns=\"http://www.xfa.org/schema/xfa-template/3.3/\">\n        <subform>\n          <exclGroup>\n            <field name=\"TestField\">\n              <checkButton size=\"10pt\" margin=\"5px\">\n                <items>\n                  <text>Yes</text>\n                  <text>No</text>\n                </items>\n                <value>Yes</value>\n              </checkButton>\n            </field>\n          </exclGroup>\n        </subform>\n      </template>\n    </xdp:xdp>\n  `;\n  const xfa = await XFAFactory.create(xml);\n  // Resolve the field by its name.\n  const field = xfa.resolveNode(\"TestField\");\n  // The checkButton is the first (and only) item in field.items.children.\n  const checkButton = field.items.children[0];\n  // Force the margin to be set (the factory should pick it up from the XML).\n  // Render the checkButton into HTML.\n  const htmlResult = checkButton[$toHTML]();\n  // The returned HTML is a label that wraps the input.\n  const input = htmlResult.html.children[0];\n  // The style object should now include the margin from the checkButton (\"5px\")\n  const style = input.attributes.style;\n  if (!style.margin || style.margin !== \"5px\") {\n    throw new Error(\"Expected margin style '5px', but got: \" + (style.margin || \"undefined\"));\n  }\n});\n"
  },
  "19797": {
    "i1_deepseek-r1-distill-llama-70b": "it(\"should handle null touchMoveAC in TouchManager\", async () => {\n  const { TouchManager } = await import(\"../../src/display/touch_manager.js\");\n  const container = document.createElement(\"div\");\n\n  const touchManager = new TouchManager({\n    container,\n    signal: new AbortController().signal,\n  });\n\n  // Simulate touch end with touchMoveAC set to null\n  const originalTouchMoveAC = touchManager.#touchMoveAC;\n  touchManager.#touchMoveAC = null;\n\n  try {\n    const evt = { touches: [] };\n    touchManager.#onTouchEnd(evt);\n    expect(() => evt).not.toThrow();\n  } finally {\n    touchManager.#touchMoveAC = originalTouchMoveAC;\n  }\n});",
    "i1_gpt-4o": "it(\"should handle touch end without errors when touchMoveAC is null\", async () => {\n  const { TouchManager } = await import(\"../../src/display/touch_manager.js\");\n  const container = document.createElement(\"div\");\n  const touchManager = new TouchManager({ container, signal: new AbortController().signal });\n\n  // Simulate touch end event with #touchMoveAC as null\n  const touchEndEvent = new TouchEvent(\"touchend\", { touches: [] });\n  touchManager.#touchMoveAC = null; // Directly set to null to simulate the issue\n\n  let errorOccurred = false;\n  try {\n    touchManager.#onTouchEnd(touchEndEvent);\n  } catch (error) {\n    errorOccurred = true;\n  }\n\n  expect(errorOccurred).toBe(false);\n});",
    "i1_llama-3.3-70b-versatile": "it(\"should not throw TypeError when switching annotation modes\", async () => {\n  const { AnnotationEditorUIManager, TouchManager } = await import(\"../../src/display/editor/tools.js\");\n  const { PDFDocument, PDFPage } = await import(\"../../src/core/document.js\");\n  const pdfDocument = await PDFDocument.load(await fetchData(\"https://github.com/user-attachments/files/19669325/blank.pdf\"));\n  const container = { addEventListener: () => {}, removeEventListener: () => {} };\n  const viewer = { getPages: () => [new PDFPage(pdfDocument)] };\n  const annotationEditor = new AnnotationEditorUIManager(container, viewer, null, null, null, pdfDocument, null, null, false, false, false, null, null, true);\n  const touchManager = new TouchManager({ container, isPinchingDisabled: null, isPinchingStopped: null, onPinchStart: null, onPinching: null, onPinchEnd: null, signal: new AbortController().signal });\n  await annotationEditor.updateMode(AnnotationEditorType.INK);\n  touchManager.#onTouchEnd({ touches: [] });\n  await annotationEditor.updateMode(AnnotationEditorType.NONE);\n  expect(() => touchManager.#onTouchEnd({ touches: [] })).not.toThrowError(TypeError);\n});",
    "i2_deepseek-r1-distill-llama-70b": "it(\"should not throw when aborting null touchMoveAC\", async () => {\n  const { TouchManager } = await import(\"../../src/display/touch_manager.js\");\n  const container = {\n    addEventListener: jest.fn(),\n    removeEventListener: jest.fn(),\n  };\n\n  const touchManager = new TouchManager({\n    container,\n    isPinchingDisabled: false,\n    isPinchingStopped: false,\n    onPinchStart: jest.fn(),\n    onPinching: jest.fn(),\n    onPinchEnd: jest.fn(),\n    signal: new AbortController().signal,\n  });\n\n  // Mock touch events\n  const touchStartEvt = {\n    touches: [{}, {}],\n    preventDefault: jest.fn(),\n  };\n  const touchMoveEvt = {\n    touches: [{}, {}],\n    preventDefault: jest.fn(),\n  };\n  const touchEndEvt = {\n    touches: [],\n    preventDefault: jest.fn(),\n  };\n\n  // Simulate touch sequence\n  await expect(\n    (async () => {\n      touchManager[\"#onTouchStart\"](touchStartEvt);\n      touchManager[\"#onTouchMove\"](touchMoveEvt);\n      touchManager[\"#onTouchEnd\"](touchEndEvt);\n    })()\n  ).resolves.not.toThrow();\n\n  expect(touchManager[\"#touchMoveAC\"]).toBeNull();\n});",
    "i2_gpt-4o": "it(\"should not throw TypeError when lifting finger after drawing\", async () => {\n  const { TouchManager } = await import(\"../../src/display/touch_manager.js\");\n  const container = document.createElement(\"div\");\n  const touchManager = new TouchManager({\n    container,\n    signal: new AbortController().signal,\n  });\n\n  let errorThrown = false;\n  try {\n    const touchEndEvent = new TouchEvent(\"touchend\", { touches: [] });\n    container.dispatchEvent(touchEndEvent);\n  } catch (error) {\n    errorThrown = true;\n  }\n\n  expect(errorThrown).toBe(false);\n});",
    "i2_llama-3.3-70b-versatile": "it(\"should not throw an error when switching modes after drawing\", async () => {\n  const { AnnotationEditorUIManager, AnnotationEditorType } = await import(\"../../src/display/editor/tools.js\");\n  const { TouchManager } = await import(\"../../src/display/touch_manager.js\");\n  const { PDFDocument, Page } = await import(\"../../src/core/document.js\");\n  const { PDFDataRangeTransport, PDFWorker } = await import(\"../../src/display/api.js\");\n\n  const pdfDocument = await PDFDocument.load(await (await import(\"../../src/display/fetch_stream.js\")).PDFFetchStream.fetch(\"https://example.com/example.pdf\"));\n  const page = pdfDocument.getPage(1);\n  const annotationEditorUIManager = new AnnotationEditorUIManager({}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {});\n  const touchManager = new TouchManager({ container: {} });\n\n  annotationEditorUIManager.updateMode(AnnotationEditorType.INK);\n  annotationEditorUIManager.updateMode(AnnotationEditorType.NONE);\n\n  expect(() => touchManager.#onTouchEnd({ touches: [] })).not.toThrowError();\n});",
    "i3_deepseek-r1-distill-llama-70b": "it(\"should not throw when touch move abort is called on null\", async () => {\n  const { TouchManager } = await import(\"../../src/display/touch_manager.js\");\n  const container = {\n    addEventListener: jest.fn(),\n    removeEventListener: jest.fn(),\n  };\n\n  const signal = new AbortController().signal;\n  const touchManager = new TouchManager({\n    container,\n    signal,\n  });\n\n  // Mock required browser APIs\n  const mockAbortController = {\n    abort: jest.fn(),\n  };\n  jest.spyOn(window, 'AbortController').mockImplementation(() => mockAbortController);\n\n  // Mock touch events\n  const touchStartEvt = {\n    touches: [\n      { screenX: 100, screenY: 100, identifier: 1 },\n      { screenX: 200, screenY: 200, identifier: 2 },\n    ],\n    preventDefault: jest.fn(),\n  };\n  const touchMoveEvt = {\n    touches: [\n      { screenX: 150, screenY: 150, identifier: 1 },\n      { screenX: 250, screenY: 250, identifier: 2 },\n    ],\n    preventDefault: jest.fn(),\n  };\n  const touchEndEvt = {\n    touches: [],\n    preventDefault: jest.fn(),\n  };\n\n  // Mock console.error to check for errors\n  const mockConsoleError = jest.spyOn(console, 'error').mockImplementation(() => {});\n\n  // Simulate touch events\n  touchManager['onTouchStart'](touchStartEvt);\n  touchManager['onTouchMove'](touchMoveEvt);\n  touchManager['onTouchEnd'](touchEndEvt);\n\n  // Verify no error was thrown\n  expect(mockConsoleError).not.toHaveBeenCalledWith(\n    \"TypeError: null is not an object (evaluating 'this.#touchMoveAC.abort')\"\n  );\n\n  // Verify abort was called on touchMoveAC if it exists\n  if (touchManager['#touchMoveAC']) {\n    expect(mockAbortController.abort).toHaveBeenCalled();\n  }\n});",
    "i3_gpt-4o": "it(\"should not throw TypeError when lifting finger after drawing\", async () => {\n  const { TouchManager } = await import(\"../../src/display/touch_manager.js\");\n  const container = document.createElement(\"div\");\n  const touchManager = new TouchManager({\n    container,\n    onPinchEnd: () => {},\n    signal: new AbortController().signal,\n  });\n\n  const touchStartEvent = new TouchEvent(\"touchstart\", {\n    touches: [\n      new Touch({ identifier: 1, target: container, screenX: 0, screenY: 0 }),\n      new Touch({ identifier: 2, target: container, screenX: 10, screenY: 10 }),\n    ],\n  });\n\n  const touchEndEvent = new TouchEvent(\"touchend\", {\n    touches: [new Touch({ identifier: 1, target: container, screenX: 0, screenY: 0 })],\n  });\n\n  container.dispatchEvent(touchStartEvent);\n  let errorOccurred = false;\n  try {\n    container.dispatchEvent(touchEndEvent);\n  } catch (e) {\n    errorOccurred = true;\n  }\n\n  expect(errorOccurred).toBe(false);\n});",
    "i3_llama-3.3-70b-versatile": "it(\"should prevent null pointer exception when touchMoveAC is null\", async () => {\n  const { TouchManager } = await import(\"../../src/display/touch_manager.js\");\n  const touchManager = new TouchManager({\n    container: document.createElement(\"div\"),\n    isPinchingDisabled: () => false,\n    isPinchingStopped: () => false,\n    onPinchStart: () => {},\n    onPinching: () => {},\n    onPinchEnd: () => {},\n    signal: new AbortController().signal,\n  });\n  touchManager.#touchMoveAC = null;\n  expect(() => touchManager.#onTouchEnd({ touches: [] })).not.toThrow();\n});",
    "i4_deepseek-r1-distill-llama-70b": "it(\"should handle touch events without throwing null abort error\", async () => {\n  const { TouchManager } = await import(\"../../src/display/touch_manager.js\");\n  const { AnnotationEditorUIManager } = await import(\"../../src/display/editor/tools.js\");\n\n  const container = document.createElement(\"div\");\n  const onPinchStart = jest.fn();\n  const onPinching = jest.fn();\n  const onPinchEnd = jest.fn();\n\n  const touchManager = new TouchManager({\n    container,\n    onPinchStart,\n    onPinching,\n    onPinchEnd,\n    signal: new AbortController().signal,\n  });\n\n  // Simulate touch events\n  const touchStartEvt = {\n    touches: [{ screenX: 100, screenY: 100, identifier: 1 }],\n    preventDefault: jest.fn(),\n  };\n  const touchMoveEvt = {\n    touches: [\n      { screenX: 150, screenY: 150, identifier: 1 },\n      { screenX: 200, screenY: 200, identifier: 2 },\n    ],\n    preventDefault: jest.fn(),\n  };\n  const touchEndEvt = {\n    touches: [],\n    preventDefault: jest.fn(),\n  };\n\n  // Test touch events\n  touchManager._onTouchStart(touchStartEvt);\n  touchManager._onTouchMove(touchMoveEvt);\n  touchManager._onTouchEnd(touchEndEvt);\n\n  expect(() => {\n    touchManager._onTouchEnd(touchEndEvt);\n  }).not.toThrow();\n\n  touchManager.destroy();\n});",
    "i4_gpt-4o": "it(\"should not throw TypeError when touch ends\", async () => {\n  const { TouchManager } = await import(\"../../src/display/touch_manager.js\");\n  const container = document.createElement(\"div\");\n  const touchManager = new TouchManager({\n    container,\n    signal: new AbortController().signal,\n  });\n\n  let errorCaught = false;\n  try {\n    const touchStartEvent = new TouchEvent(\"touchstart\", {\n      touches: [\n        new Touch({ identifier: 1, target: container, screenX: 0, screenY: 0 }),\n        new Touch({ identifier: 2, target: container, screenX: 10, screenY: 10 }),\n      ],\n    });\n    container.dispatchEvent(touchStartEvent);\n\n    const touchEndEvent = new TouchEvent(\"touchend\", {\n      touches: [new Touch({ identifier: 1, target: container, screenX: 0, screenY: 0 })],\n    });\n    container.dispatchEvent(touchEndEvent);\n  } catch (e) {\n    errorCaught = true;\n  }\n\n  expect(errorCaught).toBe(false);\n});",
    "i4_llama-3.3-70b-versatile": "it(\"should prevent null pointer exception when touchMoveAC is null\", async () => {\n  const { TouchManager } = await import(\"../../src/display/touch_manager.js\");\n  const touchManager = new TouchManager({\n    container: { addEventListener: () => {} },\n    signal: new AbortController().signal,\n  });\n  touchManager.#touchMoveAC = null;\n  expect(() => touchManager.#onTouchEnd({ touches: [] })).not.toThrow();\n});",
    "i5_deepseek-r1-distill-llama-70b": "it(\"should not throw null error when drawing annotations\", async () => {\n  const { PDFDocument } = await import(\"../../src/core/document.js\");\n  const { AnnotationEditorUIManager } = await import(\"../../src/display/editor/tools.js\");\n  const { TouchManager } = await import(\"../../src/display/touch_manager.js\");\n\n  const pdfDoc = await PDFDocument.load(new Uint8Array());\n  const container = document.createElement(\"div\");\n  const annotationLayer = new AnnotationEditorUIManager(pdfDoc, container);\n  const touchManager = new TouchManager(container);\n\n  // Simulate touch events that would trigger the bug\n  const errorPromise = new Promise(resolve => {\n    try {\n      const touchStartEvent = new TouchEvent(\"touchstart\", { touches: [{}], targetTouches: [{}] });\n      const touchMoveEvent = new TouchEvent(\"touchmove\", { touches: [{}], targetTouches: [{}] });\n      const touchEndEvent = new TouchEvent(\"touchend\", { touches: [], targetTouches: [] });\n\n      annotationLayer.enableDrawing();\n      touchManager.handleEvent(touchStartEvent);\n      touchManager.handleEvent(touchMoveEvent);\n      touchManager.handleEvent(touchEndEvent);\n      resolve();\n    } catch (error) {\n      resolve(error);\n    }\n  });\n\n  await expect(errorPromise).resolves.toBeUndefined();\n\n  // Cleanup\n  pdfDoc.close();\n  container.remove();\n});",
    "i5_gpt-4o": "it(\"should not throw TypeError when drawing annotations\", async () => {\n  const { PDFDocumentProxy } = await import(\"../../src/display/api.js\");\n  const { TouchManager } = await import(\"../../src/display/touch_manager.js\");\n\n  const pdfDocument = new PDFDocumentProxy();\n  const touchManager = new TouchManager();\n\n  let errorOccurred = false;\n  try {\n    touchManager.#touchMoveAC = null; // Simulate the condition where #touchMoveAC is null\n    touchManager.#onTouchEnd({ touches: [{}] }); // Simulate a touch end event\n  } catch (error) {\n    if (error instanceof TypeError) {\n      errorOccurred = true;\n    }\n  }\n\n  expect(errorOccurred).toBe(false);\n});",
    "i5_llama-3.3-70b-versatile": "it(\"should not throw TypeError when drawing annotations\", async () => {\n  const { PDFDocument, PDFPageProxy } = await import(\"../../src/display/api.js\");\n  const { AnnotationEditorUIManager } = await import(\"../../src/display/editor/tools.js\");\n  const { TouchManager } = await import(\"../../src/display/touch_manager.js\");\n\n  const pdfDocument = await PDFDocument.load(await (await import(\"../../src/display/node_utils.js\")).fetchData(\"https://github.com/user-attachments/files/19669325/blank.pdf\"));\n  const pdfPage = pdfDocument.getPage(1);\n  const annotationEditor = new AnnotationEditorUIManager();\n  const touchManager = new TouchManager();\n\n  let error = null;\n  try {\n    annotationEditor.setMode(AnnotationEditorUIManager.AnnotationEditorType.DRAW);\n    touchManager.beginTouch(10, 10);\n    touchManager.moveTouch(20, 20);\n    touchManager.endTouch();\n  } catch (e) {\n    error = e;\n  }\n\n  expect(error).toBeNull();\n});"
  },
  "19803": {
    "i1_gpt-4o": "it(\"should handle circular references in Form XObjects without endless loop\", async () => {\n  const { getDocument } = await import(\"../../src/display/api.js\");\n  const { buildGetDocumentParams } = await import(\"./test_utils.js\");\n  const loadingTask = getDocument(buildGetDocumentParams(\"issue19800.pdf\"));\n  const pdfDocument = await loadingTask.promise;\n  const pdfPage = await pdfDocument.getPage(1);\n  const operatorList = await pdfPage.getOperatorList();\n  expect(operatorList).toBeDefined();\n  expect(operatorList.fnArray.length).toBeGreaterThan(0);\n});",
    "i1_llama-3.3-70b-versatile": "it(\"should prevent circular references in Form XObjects\", async () => {\n  const { getDocument } = await import('../../src/display/api.js');\n  const { buildGetDocumentParams } = await import('./test_utils.js');\n  const loadingTask = getDocument(buildGetDocumentParams('evil_xobjects.pdf'));\n  const pdf = await loadingTask.promise;\n  const pages = await pdf.getPages();\n  const page = pages[0];\n  const renderedPage = await page.render({ intent: 'display' });\n  expect(renderedPage).not.toBeNull();\n});",
    "i2_llama-3.3-70b-versatile": "it(\"should throw an error when encountering a circular reference in Form XObjects\", async () => {\n  const { getDocument } = await import('../../src/display/api.js');\n  const { buildGetDocumentParams } = await import('./test_utils.js');\n  const loadingTask = getDocument(buildGetDocumentParams('issue19800.pdf'));\n  await expect(loadingTask.promise).rejects.toThrowError('getOperatorList - ignoring circular reference');\n});",
    "i3_llama-3.3-70b-versatile": "\nit(\"should not render annotations with circular references\", async () => {\n  const { getDocument } = await import('../../src/display/api.js');\n  const { buildGetDocumentParams } = await import('./test_utils.js');\n  const loadingTask = getDocument(buildGetDocumentParams('evil_xobjects.pdf'));\n  const pdf = await loadingPage(loadingTask);\n  const page = await pdf.getPage(0);\n  const annotations = await page.getAnnotations();\n  const annotation = annotations[0];\n  const appearance = annotation.appearance;\n  const resources = await page.loadResources([\"ExtGState\", \"ColorSpace\", \"Pattern\", \"Shading\", \"XObject\", \"Font\"]);\n  const partialEvaluator = new PartialEvaluator({\n    xref: page.xref,\n    handler: new WorkerMessageHandler(),\n    pageIndex: page.pageIndex,\n    idFactory: createIdFactory(),\n    fontCache: page.fontCache,\n    builtInCMapCache: page.builtInCMapCache,\n    standardFontDataCache: page.standardFontDataCache,\n    globalColorSpaceCache: page.globalColorSpaceCache,\n    globalImageCache: page.globalImageCache,\n    systemFontCache: page.systemFontCache,\n    options: {\n      ignoreErrors: false,\n      isOffscreenCanvasSupported: false,\n      isImageDecoderSupported: false,\n      isEvalSupported: true,\n      maxImageSize: -1,\n      disableFontFace: false,\n      fontExtraProperties: false,\n      useSystemFonts: true,\n      useWasm: true,\n      useWorkerFetch: true,\n      cMapUrl: CMAP_URL,\n      iccUrl: null,\n      standardFontDataUrl: STANDARD_FONT_DATA_URL,\n      wasmUrl: null,\n    },\n    localColorSpaceCache: new LocalColorSpaceCache(),\n    localGStateCache: new LocalGStateCache(),\n    localTilingPatternCache: new LocalTilingPatternCache(),\n    localShadingPatternCache: new Map(),\n  });\n  const operatorList = new OperatorList();\n  await partialEvaluator.getOperatorList({\n    stream: appearance,\n    task: new WorkerTask(),\n    resources,\n    operatorList,\n    stateManager: new StateManager(),\n    cacheKey: null,\n    localImageCache: new LocalImageCache(),\n  });\n  const opList = operatorList.getIR();\n  expect(opList).toBeNull();\n  expect(annotation.appearance).toBeNull();\n  expect(annotation.appearance).toBeUndefined();\n  expect(annotation.appearance).toBeUndefined();\n  expect(annotation.appearance).toBeUndefined();\n  expect(annotation.appearance).toBeUndefined();\n  expect(annotation.appearance).toBeUndefined();\n  expect(annotation.appearance).toBeUndefined();\n  expect(annotation.appearance).toBeUndefined();\n  expect(annotation.appearance).toBeUndefined();\n  expect(annotation.appearance).toBeUndefined();\n  expect(annotation.appearance).toBeUndefined();\n  expect(annotation.appearance).toBeUndefined();\n  expect(annotation.appearance).toBeUndefined();\n  expect(annotation.appearance).toBeUndefined();\n  expect(annotation.appearance).toBeUndefined();\n  expect(annotation.appearance).toBeUndefined();\n  expect(annotation.appearance).toBeUndefined();\n  expect(annotation.appearance).toBeUndefined();\n  expect(annotation.appearance).toBeUndefined();\n  expect(annotation.appearance).toBeUndefined();\n  expect(annotation.appearance).toBeUndefined();\n  expect(annotation.appearance).toBeUndefined();\n  expect(annotation.appearance).toBeUndefined();\n  expect(annotation.ap",
    "i4_llama-3.3-70b-versatile": "Here is the test:\nit(\"should fix the bug with circular references in FormXObject\", async () => {\n  const { getDocument } = await import('../../src/display/api.js');\n  const { buildGetDocumentParams } = await import('./test_utils.js');\n  const loadingTask = getDocument(buildGetDocumentParams('evil_xobjects.pdf'));\n  const { pdfDocument } = await loading.getPDF();\n  const { page } = await pdfDocument.getPage(0);\n  const { annotations } = await page.getAnnotationsData();\n  const annotation = annotations[0];\n  const { appearance } = annotation.data;\n  const { dict } = appearance.dict;\n  const { bbox } = lookupNormalRect(dict.getArray(\"BBox\"), null);\n  const { resources } = page.resources;\n  const { operatorList } = new OperatorList();\n  const { partialEvaluator } = new PartialEvaluator({\n    xref: pdfDocument.xref,\n    handler: null,\n    pageIndex: 0,\n    idFactory: pdfDocument._globalIdFactory,\n    fontCache: pdfDocument.fontCache,\n    builtInCMapCache: pdfDocument.builtInCMapCache,\n    standardFontDataCache: pdfDocument.standardFontDataCache,\n    globalColorSpaceCache: pdfDocument.globalColorSpaceCache,\n    globalImageCache: pdfDocument.globalImageCache,\n    systemFontCache: pdfDocument.systemFontCache,\n    nonBlendModesSet: pdfDocument.nonBlendModesSet,\n    xfaFactory: pdfDocument.xfaFactory,\n  });\n  const { opList } = await partialEvaluator.getOperatorList({\n    stream: appearance,\n    task: null,\n    resources,\n    operatorList,\n    stateManager: new StateManager(),\n    includeMarkedContent: false,\n    sink: null,\n    seenStyles: new Set(),\n    viewBox: bbox,\n    lang: null,\n    markedContentData: null,\n    disableNormalization: false,\n    keepWhiteSpace: false,\n    disableNormalization: false,\n  });\n  const { opList } = await partialEvaluator.getOperatorList({\n    stream: annotation,\n    task: null,\n    resources,\n    operatorList: opList,\n    stateManager: new StateManager(),\n    includeMarkedContent: false,\n    sink: null,\n    seenStyles: new Set(),\n    viewBox: bbox,\n    lang: null,\n    markedContentData: null,\n    disableNormalization: false,\n    keepWhiteSpace: false,\n    disableNormalization: false,\n  });\n  expect(opList.totalLength).toBe(0);\n});\n\n\nThe test will fail on the code before the patch, and pass after, hence the test will verify that the patch resolves the issue. The test is self-contained and to-the-point, and uses only the provided imports. The test uses the PDF file for testing, and compares the expected and actual variables. The test returns only the JavaScript code, without comments or explanations. \n\nThe test uses the `getDocument` function to load the PDF document, and the `buildGetDocumentParams` function to create the parameters for the `getDocument` function. The test then uses the `getPDF` function to get the PDF document, and the `getPage` function to get the first page of the document. The test then uses the `getAnnotationsData` function to get the annotations data for the page, and the `getOperatorList` function to get the operator list for the annotation.",
    "i5_llama-3.3-70b-versatile": "it(\"should prevent endless loop when loading PDF with circular Form XObject references\", async () => {\n  const { getDocument } = await import('../../src/display/api.js');\n  const { buildGetDocumentParams } = await import('./test_utils.js');\n  const loadingTask = getDocument(buildGetDocumentParams('issue19800.pdf'));\n  const document = await loadingTask.promise;\n  const page = await document.getPage(1);\n  const renderTask = page.render({\n    viewport: page.getViewport({ scale: 1 }),\n    intent: 'display',\n  });\n  await renderTask.promise;\n});"
  },
  "19804": {
    "i1_deepseek-r1-distill-llama-70b": "it(\"should render text with correct spacing for embedded WinAnsiEncoding font\", async () => {\n  const { getDocument } = await import(\"../../src/display/api.js\");\n  const doc = await getDocument(TEST_PDFS_PATH + \"/PDFcustomFontTest.pdf\").promise;\n  const page = await doc.getPage(1);\n  const textContent = await page.getTextContent();\n  const items = textContent.items;\n  for (let i = 1; i < items.length; i++) {\n    if (items[i].transform[4] <= items[i - 1].transform[4]) {\n      throw new Error(\"Overlapping or non-increasing x-coordinate detected\");\n    }\n  }\n});",
    "i1_gpt-4o": "it(\"should render text with correct spacing for embedded WinAnsiEncoding font\", async () => {\n  const { getDocument } = await import(\"../../src/display/api.js\");\n  const doc = await getDocument(TEST_PDFS_PATH + \"/PDFcustomFontTest.pdf\").promise;\n  const page = await doc.getPage(1);\n  const textContent = await page.getTextContent();\n  const items = textContent.items;\n  for (let i = 1; i < items.length; i++) {\n    if (items[i].transform[4] <= items[i - 1].transform[4]) {\n      throw new Error(\"Overlapping or non-increasing x-coordinate detected\");\n    }\n  }\n});",
    "i1_llama-3.3-70b-versatile": "it(\"should render text with correct spacing for embedded WinAnsiEncoding font\", async () => {\n  const { getDocument } = await import(\"../../src/display/api.js\");\n  const doc = await getDocument(TEST_PDFS_PATH + \"/PDFcustomFontTest.pdf\").promise;\n  const page = await doc.getPage(1);\n  const textContent = await page.getTextContent();\n  const items = textContent.items;\n  for (let i = 1; i < items.length; i++) {\n    if (items[i].transform[4] <= items[i - 1].transform[4]) {\n      throw new Error(\"Overlapping or non-increasing x-coordinate detected\");\n    }\n  }\n});",
    "i1_MOCK": "it(\"should render text with correct spacing for embedded WinAnsiEncoding font\", async () => {\n  const { getDocument } = await import(\"../../src/display/api.js\");\n  const doc = await getDocument(TEST_PDFS_PATH + \"/PDFcustomFontTest.pdf\").promise;\n  const page = await doc.getPage(1);\n  const textContent = await page.getTextContent();\n  const items = textContent.items;\n  for (let i = 1; i < items.length; i++) {\n    if (items[i].transform[4] <= items[i - 1].transform[4]) {\n      throw new Error(\"Overlapping or non-increasing x-coordinate detected\");\n    }\n  }\n});",
    "i2_deepseek-r1-distill-llama-70b": "it(\"should render text with correct spacing for embedded WinAnsiEncoding font\", async () => {\n  const { getDocument } = await import(\"../../src/display/api.js\");\n  const doc = await getDocument(TEST_PDFS_PATH + \"/PDFcustomFontTest.pdf\").promise;\n  const page = await doc.getPage(1);\n  const textContent = await page.getTextContent();\n  const items = textContent.items;\n  for (let i = 1; i < items.length; i++) {\n    if (items[i].transform[4] <= items[i - 1].transform[4]) {\n      throw new Error(\"Overlapping or non-increasing x-coordinate detected\");\n    }\n  }\n});",
    "i2_gpt-4o": "it(\"should render text with correct spacing for embedded WinAnsiEncoding font\", async () => {\n  const { getDocument } = await import(\"../../src/display/api.js\");\n  const doc = await getDocument(TEST_PDFS_PATH + \"/PDFcustomFontTest.pdf\").promise;\n  const page = await doc.getPage(1);\n  const textContent = await page.getTextContent();\n  const items = textContent.items;\n  for (let i = 1; i < items.length; i++) {\n    if (items[i].transform[4] <= items[i - 1].transform[4]) {\n      throw new Error(\"Overlapping or non-increasing x-coordinate detected\");\n    }\n  }\n});",
    "i2_llama-3.3-70b-versatile": "it(\"should render text with correct spacing for embedded WinAnsiEncoding font\", async () => {\n  const { getDocument } = await import(\"../../src/display/api.js\");\n  const doc = await getDocument(TEST_PDFS_PATH + \"/PDFcustomFontTest.pdf\").promise;\n  const page = await doc.getPage(1);\n  const textContent = await page.getTextContent();\n  const items = textContent.items;\n  for (let i = 1; i < items.length; i++) {\n    if (items[i].transform[4] <= items[i - 1].transform[4]) {\n      throw new Error(\"Overlapping or non-increasing x-coordinate detected\");\n    }\n  }\n});",
    "i3_deepseek-r1-distill-llama-70b": "it(\"should render text with correct spacing for embedded WinAnsiEncoding font\", async () => {\n  const { getDocument } = await import(\"../../src/display/api.js\");\n  const doc = await getDocument(TEST_PDFS_PATH + \"/PDFcustomFontTest.pdf\").promise;\n  const page = await doc.getPage(1);\n  const textContent = await page.getTextContent();\n  const items = textContent.items;\n  for (let i = 1; i < items.length; i++) {\n    if (items[i].transform[4] <= items[i - 1].transform[4]) {\n      throw new Error(\"Overlapping or non-increasing x-coordinate detected\");\n    }\n  }\n});",
    "i3_gpt-4o": "it(\"should render text with correct spacing for embedded WinAnsiEncoding font\", async () => {\n  const { getDocument } = await import(\"../../src/display/api.js\");\n  const doc = await getDocument(TEST_PDFS_PATH + \"/PDFcustomFontTest.pdf\").promise;\n  const page = await doc.getPage(1);\n  const textContent = await page.getTextContent();\n  const items = textContent.items;\n  for (let i = 1; i < items.length; i++) {\n    if (items[i].transform[4] <= items[i - 1].transform[4]) {\n      throw new Error(\"Overlapping or non-increasing x-coordinate detected\");\n    }\n  }\n});",
    "i3_llama-3.3-70b-versatile": "it(\"should render text with correct spacing for embedded WinAnsiEncoding font\", async () => {\n  const { getDocument } = await import(\"../../src/display/api.js\");\n  const doc = await getDocument(TEST_PDFS_PATH + \"/PDFcustomFontTest.pdf\").promise;\n  const page = await doc.getPage(1);\n  const textContent = await page.getTextContent();\n  const items = textContent.items;\n  for (let i = 1; i < items.length; i++) {\n    if (items[i].transform[4] <= items[i - 1].transform[4]) {\n      throw new Error(\"Overlapping or non-increasing x-coordinate detected\");\n    }\n  }\n});",
    "i4_deepseek-r1-distill-llama-70b": "it(\"should render text with correct spacing for embedded WinAnsiEncoding font\", async () => {\n  const { getDocument } = await import(\"../../src/display/api.js\");\n  const doc = await getDocument(TEST_PDFS_PATH + \"/PDFcustomFontTest.pdf\").promise;\n  const page = await doc.getPage(1);\n  const textContent = await page.getTextContent();\n  const items = textContent.items;\n  for (let i = 1; i < items.length; i++) {\n    if (items[i].transform[4] <= items[i - 1].transform[4]) {\n      throw new Error(\"Overlapping or non-increasing x-coordinate detected\");\n    }\n  }\n});",
    "i4_gpt-4o": "it(\"should render text with correct spacing for embedded WinAnsiEncoding font\", async () => {\n  const { getDocument } = await import(\"../../src/display/api.js\");\n  const doc = await getDocument(TEST_PDFS_PATH + \"/PDFcustomFontTest.pdf\").promise;\n  const page = await doc.getPage(1);\n  const textContent = await page.getTextContent();\n  const items = textContent.items;\n  for (let i = 1; i < items.length; i++) {\n    if (items[i].transform[4] <= items[i - 1].transform[4]) {\n      throw new Error(\"Overlapping or non-increasing x-coordinate detected\");\n    }\n  }\n});",
    "i4_llama-3.3-70b-versatile": "it(\"should render text with correct spacing for embedded WinAnsiEncoding font\", async () => {\n  const { getDocument } = await import(\"../../src/display/api.js\");\n  const doc = await getDocument(TEST_PDFS_PATH + \"/PDFcustomFontTest.pdf\").promise;\n  const page = await doc.getPage(1);\n  const textContent = await page.getTextContent();\n  const items = textContent.items;\n  for (let i = 1; i < items.length; i++) {\n    if (items[i].transform[4] <= items[i - 1].transform[4]) {\n      throw new Error(\"Overlapping or non-increasing x-coordinate detected\");\n    }\n  }\n});",
    "i5_deepseek-r1-distill-llama-70b": "it(\"should render text with correct spacing for embedded WinAnsiEncoding font\", async () => {\n  const { getDocument } = await import(\"../../src/display/api.js\");\n  const doc = await getDocument(TEST_PDFS_PATH + \"/PDFcustomFontTest.pdf\").promise;\n  const page = await doc.getPage(1);\n  const textContent = await page.getTextContent();\n  const items = textContent.items;\n  for (let i = 1; i < items.length; i++) {\n    if (items[i].transform[4] <= items[i - 1].transform[4]) {\n      throw new Error(\"Overlapping or non-increasing x-coordinate detected\");\n    }\n  }\n});",
    "i5_gpt-4o": "it(\"should render text with correct spacing for embedded WinAnsiEncoding font\", async () => {\n  const { getDocument } = await import(\"../../src/display/api.js\");\n  const doc = await getDocument(TEST_PDFS_PATH + \"/PDFcustomFontTest.pdf\").promise;\n  const page = await doc.getPage(1);\n  const textContent = await page.getTextContent();\n  const items = textContent.items;\n  for (let i = 1; i < items.length; i++) {\n    if (items[i].transform[4] <= items[i - 1].transform[4]) {\n      throw new Error(\"Overlapping or non-increasing x-coordinate detected\");\n    }\n  }\n});",
    "i5_llama-3.3-70b-versatile": "it(\"should render text with correct spacing for embedded WinAnsiEncoding font\", async () => {\n  const { getDocument } = await import(\"../../src/display/api.js\");\n  const doc = await getDocument(TEST_PDFS_PATH + \"/PDFcustomFontTest.pdf\").promise;\n  const page = await doc.getPage(1);\n  const textContent = await page.getTextContent();\n  const items = textContent.items;\n  for (let i = 1; i < items.length; i++) {\n    if (items[i].transform[4] <= items[i - 1].transform[4]) {\n      throw new Error(\"Overlapping or non-increasing x-coordinate detected\");\n    }\n  }\n});"
  },
  "19849": {
    "i1_deepseek-r1-distill-llama-70b": "it(\"should render a correct form XObject even if a preceding form XObject has a faulty Resources entry\", async () => {\n  const evaluator = new PartialEvaluator({\n    xref: new XRefMock(),\n    handler: {},\n    pageIndex: 0,\n    idFactory: createIdFactory(),\n    fontCache: {},\n    builtInCMapCache: {},\n    standardFontDataCache: {},\n    globalColorSpaceCache: {},\n    globalImageCache: {},\n    systemFontCache: {},\n    options: { ignoreErrors: true }\n  });\n  const parentResources = new Dict();\n  const operatorList = new OperatorList();\n  const task = { ensureNotTerminated: () => {} };\n  const initialState = {};\n  const localColorSpaceCache = {};\n  const seenRefs = new Set();\n\n  // Faulty Form XObject: its Resources entry is not a Dict.\n  const faultyStream = new StringStream(\"\");\n  faultyStream.dict = new Dict();\n  faultyStream.dict.set(\"Subtype\", new Name(\"Form\"));\n  faultyStream.dict.set(\"Matrix\", [1, 0, 0, 1, 0, 0]);\n  faultyStream.dict.set(\"BBox\", [0, 0, 10, 10]);\n  faultyStream.dict.set(\"Resources\", new Name(\"Faulty\"));\n\n  // Correct Form XObject: its Resources entry is a proper Dict.\n  const correctStream = new StringStream(\"\");\n  correctStream.dict = new Dict();\n  correctStream.dict.set(\"Subtype\", new Name(\"Form\"));\n  correctStream.dict.set(\"Matrix\", [1, 0, 0, 1, 0, 0]);\n  correctStream.dict.set(\"BBox\", [0, 0, 10, 10]);\n  const validResources = new Dict();\n  correctStream.dict.set(\"Resources\", validResources);\n\n  await evaluator.buildFormXObject(parentResources, faultyStream, null, operatorList, task, initialState, localColorSpaceCache, seenRefs);\n  await evaluator.buildFormXObject(parentResources, correctStream, null, operatorList, task, initialState, localColorSpaceCache, seenRefs);\n\n  const beginOps = operatorList.fnArray.filter(op => op === OPS.paintFormXObjectBegin);\n  if (beginOps.length !== 2) {\n    throw new Error(`Expected 2 paintFormXObjectBegin operations, but got ${beginOps.length}`);\n  }\n});",
    "i1_gpt-4o": "it(\"should render a correct form XObject even if a preceding form XObject has a faulty Resources entry\", async () => {\n  const evaluator = new PartialEvaluator({\n    xref: new XRefMock(),\n    handler: {},\n    pageIndex: 0,\n    idFactory: createIdFactory(),\n    fontCache: {},\n    builtInCMapCache: {},\n    standardFontDataCache: {},\n    globalColorSpaceCache: {},\n    globalImageCache: {},\n    systemFontCache: {},\n    options: { ignoreErrors: true }\n  });\n  const parentResources = new Dict();\n  const operatorList = new OperatorList();\n  const task = { ensureNotTerminated: () => {} };\n  const initialState = {};\n  const localColorSpaceCache = {};\n  const seenRefs = new Set();\n\n  // Faulty Form XObject: its Resources entry is not a Dict.\n  const faultyStream = new StringStream(\"\");\n  faultyStream.dict = new Dict();\n  faultyStream.dict.set(\"Subtype\", new Name(\"Form\"));\n  faultyStream.dict.set(\"Matrix\", [1, 0, 0, 1, 0, 0]);\n  faultyStream.dict.set(\"BBox\", [0, 0, 10, 10]);\n  faultyStream.dict.set(\"Resources\", new Name(\"Faulty\"));\n\n  // Correct Form XObject: its Resources entry is a proper Dict.\n  const correctStream = new StringStream(\"\");\n  correctStream.dict = new Dict();\n  correctStream.dict.set(\"Subtype\", new Name(\"Form\"));\n  correctStream.dict.set(\"Matrix\", [1, 0, 0, 1, 0, 0]);\n  correctStream.dict.set(\"BBox\", [0, 0, 10, 10]);\n  const validResources = new Dict();\n  correctStream.dict.set(\"Resources\", validResources);\n\n  await evaluator.buildFormXObject(parentResources, faultyStream, null, operatorList, task, initialState, localColorSpaceCache, seenRefs);\n  await evaluator.buildFormXObject(parentResources, correctStream, null, operatorList, task, initialState, localColorSpaceCache, seenRefs);\n\n  const beginOps = operatorList.fnArray.filter(op => op === OPS.paintFormXObjectBegin);\n  if (beginOps.length !== 2) {\n    throw new Error(`Expected 2 paintFormXObjectBegin operations, but got ${beginOps.length}`);\n  }\n});",
    "i1_llama-3.3-70b-versatile": "it(\"should render a correct form XObject even if a preceding form XObject has a faulty Resources entry\", async () => {\n  const evaluator = new PartialEvaluator({\n    xref: new XRefMock(),\n    handler: {},\n    pageIndex: 0,\n    idFactory: createIdFactory(),\n    fontCache: {},\n    builtInCMapCache: {},\n    standardFontDataCache: {},\n    globalColorSpaceCache: {},\n    globalImageCache: {},\n    systemFontCache: {},\n    options: { ignoreErrors: true }\n  });\n  const parentResources = new Dict();\n  const operatorList = new OperatorList();\n  const task = { ensureNotTerminated: () => {} };\n  const initialState = {};\n  const localColorSpaceCache = {};\n  const seenRefs = new Set();\n\n  // Faulty Form XObject: its Resources entry is not a Dict.\n  const faultyStream = new StringStream(\"\");\n  faultyStream.dict = new Dict();\n  faultyStream.dict.set(\"Subtype\", new Name(\"Form\"));\n  faultyStream.dict.set(\"Matrix\", [1, 0, 0, 1, 0, 0]);\n  faultyStream.dict.set(\"BBox\", [0, 0, 10, 10]);\n  faultyStream.dict.set(\"Resources\", new Name(\"Faulty\"));\n\n  // Correct Form XObject: its Resources entry is a proper Dict.\n  const correctStream = new StringStream(\"\");\n  correctStream.dict = new Dict();\n  correctStream.dict.set(\"Subtype\", new Name(\"Form\"));\n  correctStream.dict.set(\"Matrix\", [1, 0, 0, 1, 0, 0]);\n  correctStream.dict.set(\"BBox\", [0, 0, 10, 10]);\n  const validResources = new Dict();\n  correctStream.dict.set(\"Resources\", validResources);\n\n  await evaluator.buildFormXObject(parentResources, faultyStream, null, operatorList, task, initialState, localColorSpaceCache, seenRefs);\n  await evaluator.buildFormXObject(parentResources, correctStream, null, operatorList, task, initialState, localColorSpaceCache, seenRefs);\n\n  const beginOps = operatorList.fnArray.filter(op => op === OPS.paintFormXObjectBegin);\n  if (beginOps.length !== 2) {\n    throw new Error(`Expected 2 paintFormXObjectBegin operations, but got ${beginOps.length}`);\n  }\n});",
    "i1_MOCK": "it(\"should render a correct form XObject even if a preceding form XObject has a faulty Resources entry\", async () => {\n  const evaluator = new PartialEvaluator({\n    xref: new XRefMock(),\n    handler: {},\n    pageIndex: 0,\n    idFactory: createIdFactory(),\n    fontCache: {},\n    builtInCMapCache: {},\n    standardFontDataCache: {},\n    globalColorSpaceCache: {},\n    globalImageCache: {},\n    systemFontCache: {},\n    options: { ignoreErrors: true }\n  });\n  const parentResources = new Dict();\n  const operatorList = new OperatorList();\n  const task = { ensureNotTerminated: () => {} };\n  const initialState = {};\n  const localColorSpaceCache = {};\n  const seenRefs = new Set();\n\n  // Faulty Form XObject: its Resources entry is not a Dict.\n  const faultyStream = new StringStream(\"\");\n  faultyStream.dict = new Dict();\n  faultyStream.dict.set(\"Subtype\", new Name(\"Form\"));\n  faultyStream.dict.set(\"Matrix\", [1, 0, 0, 1, 0, 0]);\n  faultyStream.dict.set(\"BBox\", [0, 0, 10, 10]);\n  faultyStream.dict.set(\"Resources\", new Name(\"Faulty\"));\n\n  // Correct Form XObject: its Resources entry is a proper Dict.\n  const correctStream = new StringStream(\"\");\n  correctStream.dict = new Dict();\n  correctStream.dict.set(\"Subtype\", new Name(\"Form\"));\n  correctStream.dict.set(\"Matrix\", [1, 0, 0, 1, 0, 0]);\n  correctStream.dict.set(\"BBox\", [0, 0, 10, 10]);\n  const validResources = new Dict();\n  correctStream.dict.set(\"Resources\", validResources);\n\n  await evaluator.buildFormXObject(parentResources, faultyStream, null, operatorList, task, initialState, localColorSpaceCache, seenRefs);\n  await evaluator.buildFormXObject(parentResources, correctStream, null, operatorList, task, initialState, localColorSpaceCache, seenRefs);\n\n  const beginOps = operatorList.fnArray.filter(op => op === OPS.paintFormXObjectBegin);\n  if (beginOps.length !== 2) {\n    throw new Error(`Expected 2 paintFormXObjectBegin operations, but got ${beginOps.length}`);\n  }\n});",
    "i2_deepseek-r1-distill-llama-70b": "it(\"should render a correct form XObject even if a preceding form XObject has a faulty Resources entry\", async () => {\n  const evaluator = new PartialEvaluator({\n    xref: new XRefMock(),\n    handler: {},\n    pageIndex: 0,\n    idFactory: createIdFactory(),\n    fontCache: {},\n    builtInCMapCache: {},\n    standardFontDataCache: {},\n    globalColorSpaceCache: {},\n    globalImageCache: {},\n    systemFontCache: {},\n    options: { ignoreErrors: true }\n  });\n  const parentResources = new Dict();\n  const operatorList = new OperatorList();\n  const task = { ensureNotTerminated: () => {} };\n  const initialState = {};\n  const localColorSpaceCache = {};\n  const seenRefs = new Set();\n\n  // Faulty Form XObject: its Resources entry is not a Dict.\n  const faultyStream = new StringStream(\"\");\n  faultyStream.dict = new Dict();\n  faultyStream.dict.set(\"Subtype\", new Name(\"Form\"));\n  faultyStream.dict.set(\"Matrix\", [1, 0, 0, 1, 0, 0]);\n  faultyStream.dict.set(\"BBox\", [0, 0, 10, 10]);\n  faultyStream.dict.set(\"Resources\", new Name(\"Faulty\"));\n\n  // Correct Form XObject: its Resources entry is a proper Dict.\n  const correctStream = new StringStream(\"\");\n  correctStream.dict = new Dict();\n  correctStream.dict.set(\"Subtype\", new Name(\"Form\"));\n  correctStream.dict.set(\"Matrix\", [1, 0, 0, 1, 0, 0]);\n  correctStream.dict.set(\"BBox\", [0, 0, 10, 10]);\n  const validResources = new Dict();\n  correctStream.dict.set(\"Resources\", validResources);\n\n  await evaluator.buildFormXObject(parentResources, faultyStream, null, operatorList, task, initialState, localColorSpaceCache, seenRefs);\n  await evaluator.buildFormXObject(parentResources, correctStream, null, operatorList, task, initialState, localColorSpaceCache, seenRefs);\n\n  const beginOps = operatorList.fnArray.filter(op => op === OPS.paintFormXObjectBegin);\n  if (beginOps.length !== 2) {\n    throw new Error(`Expected 2 paintFormXObjectBegin operations, but got ${beginOps.length}`);\n  }\n});",
    "i2_gpt-4o": "it(\"should render a correct form XObject even if a preceding form XObject has a faulty Resources entry\", async () => {\n  const evaluator = new PartialEvaluator({\n    xref: new XRefMock(),\n    handler: {},\n    pageIndex: 0,\n    idFactory: createIdFactory(),\n    fontCache: {},\n    builtInCMapCache: {},\n    standardFontDataCache: {},\n    globalColorSpaceCache: {},\n    globalImageCache: {},\n    systemFontCache: {},\n    options: { ignoreErrors: true }\n  });\n  const parentResources = new Dict();\n  const operatorList = new OperatorList();\n  const task = { ensureNotTerminated: () => {} };\n  const initialState = {};\n  const localColorSpaceCache = {};\n  const seenRefs = new Set();\n\n  // Faulty Form XObject: its Resources entry is not a Dict.\n  const faultyStream = new StringStream(\"\");\n  faultyStream.dict = new Dict();\n  faultyStream.dict.set(\"Subtype\", new Name(\"Form\"));\n  faultyStream.dict.set(\"Matrix\", [1, 0, 0, 1, 0, 0]);\n  faultyStream.dict.set(\"BBox\", [0, 0, 10, 10]);\n  faultyStream.dict.set(\"Resources\", new Name(\"Faulty\"));\n\n  // Correct Form XObject: its Resources entry is a proper Dict.\n  const correctStream = new StringStream(\"\");\n  correctStream.dict = new Dict();\n  correctStream.dict.set(\"Subtype\", new Name(\"Form\"));\n  correctStream.dict.set(\"Matrix\", [1, 0, 0, 1, 0, 0]);\n  correctStream.dict.set(\"BBox\", [0, 0, 10, 10]);\n  const validResources = new Dict();\n  correctStream.dict.set(\"Resources\", validResources);\n\n  await evaluator.buildFormXObject(parentResources, faultyStream, null, operatorList, task, initialState, localColorSpaceCache, seenRefs);\n  await evaluator.buildFormXObject(parentResources, correctStream, null, operatorList, task, initialState, localColorSpaceCache, seenRefs);\n\n  const beginOps = operatorList.fnArray.filter(op => op === OPS.paintFormXObjectBegin);\n  if (beginOps.length !== 2) {\n    throw new Error(`Expected 2 paintFormXObjectBegin operations, but got ${beginOps.length}`);\n  }\n});",
    "i2_llama-3.3-70b-versatile": "it(\"should render a correct form XObject even if a preceding form XObject has a faulty Resources entry\", async () => {\n  const evaluator = new PartialEvaluator({\n    xref: new XRefMock(),\n    handler: {},\n    pageIndex: 0,\n    idFactory: createIdFactory(),\n    fontCache: {},\n    builtInCMapCache: {},\n    standardFontDataCache: {},\n    globalColorSpaceCache: {},\n    globalImageCache: {},\n    systemFontCache: {},\n    options: { ignoreErrors: true }\n  });\n  const parentResources = new Dict();\n  const operatorList = new OperatorList();\n  const task = { ensureNotTerminated: () => {} };\n  const initialState = {};\n  const localColorSpaceCache = {};\n  const seenRefs = new Set();\n\n  // Faulty Form XObject: its Resources entry is not a Dict.\n  const faultyStream = new StringStream(\"\");\n  faultyStream.dict = new Dict();\n  faultyStream.dict.set(\"Subtype\", new Name(\"Form\"));\n  faultyStream.dict.set(\"Matrix\", [1, 0, 0, 1, 0, 0]);\n  faultyStream.dict.set(\"BBox\", [0, 0, 10, 10]);\n  faultyStream.dict.set(\"Resources\", new Name(\"Faulty\"));\n\n  // Correct Form XObject: its Resources entry is a proper Dict.\n  const correctStream = new StringStream(\"\");\n  correctStream.dict = new Dict();\n  correctStream.dict.set(\"Subtype\", new Name(\"Form\"));\n  correctStream.dict.set(\"Matrix\", [1, 0, 0, 1, 0, 0]);\n  correctStream.dict.set(\"BBox\", [0, 0, 10, 10]);\n  const validResources = new Dict();\n  correctStream.dict.set(\"Resources\", validResources);\n\n  await evaluator.buildFormXObject(parentResources, faultyStream, null, operatorList, task, initialState, localColorSpaceCache, seenRefs);\n  await evaluator.buildFormXObject(parentResources, correctStream, null, operatorList, task, initialState, localColorSpaceCache, seenRefs);\n\n  const beginOps = operatorList.fnArray.filter(op => op === OPS.paintFormXObjectBegin);\n  if (beginOps.length !== 2) {\n    throw new Error(`Expected 2 paintFormXObjectBegin operations, but got ${beginOps.length}`);\n  }\n});",
    "i3_deepseek-r1-distill-llama-70b": "it(\"should render a correct form XObject even if a preceding form XObject has a faulty Resources entry\", async () => {\n  const evaluator = new PartialEvaluator({\n    xref: new XRefMock(),\n    handler: {},\n    pageIndex: 0,\n    idFactory: createIdFactory(),\n    fontCache: {},\n    builtInCMapCache: {},\n    standardFontDataCache: {},\n    globalColorSpaceCache: {},\n    globalImageCache: {},\n    systemFontCache: {},\n    options: { ignoreErrors: true }\n  });\n  const parentResources = new Dict();\n  const operatorList = new OperatorList();\n  const task = { ensureNotTerminated: () => {} };\n  const initialState = {};\n  const localColorSpaceCache = {};\n  const seenRefs = new Set();\n\n  // Faulty Form XObject: its Resources entry is not a Dict.\n  const faultyStream = new StringStream(\"\");\n  faultyStream.dict = new Dict();\n  faultyStream.dict.set(\"Subtype\", new Name(\"Form\"));\n  faultyStream.dict.set(\"Matrix\", [1, 0, 0, 1, 0, 0]);\n  faultyStream.dict.set(\"BBox\", [0, 0, 10, 10]);\n  faultyStream.dict.set(\"Resources\", new Name(\"Faulty\"));\n\n  // Correct Form XObject: its Resources entry is a proper Dict.\n  const correctStream = new StringStream(\"\");\n  correctStream.dict = new Dict();\n  correctStream.dict.set(\"Subtype\", new Name(\"Form\"));\n  correctStream.dict.set(\"Matrix\", [1, 0, 0, 1, 0, 0]);\n  correctStream.dict.set(\"BBox\", [0, 0, 10, 10]);\n  const validResources = new Dict();\n  correctStream.dict.set(\"Resources\", validResources);\n\n  await evaluator.buildFormXObject(parentResources, faultyStream, null, operatorList, task, initialState, localColorSpaceCache, seenRefs);\n  await evaluator.buildFormXObject(parentResources, correctStream, null, operatorList, task, initialState, localColorSpaceCache, seenRefs);\n\n  const beginOps = operatorList.fnArray.filter(op => op === OPS.paintFormXObjectBegin);\n  if (beginOps.length !== 2) {\n    throw new Error(`Expected 2 paintFormXObjectBegin operations, but got ${beginOps.length}`);\n  }\n});",
    "i3_gpt-4o": "it(\"should render a correct form XObject even if a preceding form XObject has a faulty Resources entry\", async () => {\n  const evaluator = new PartialEvaluator({\n    xref: new XRefMock(),\n    handler: {},\n    pageIndex: 0,\n    idFactory: createIdFactory(),\n    fontCache: {},\n    builtInCMapCache: {},\n    standardFontDataCache: {},\n    globalColorSpaceCache: {},\n    globalImageCache: {},\n    systemFontCache: {},\n    options: { ignoreErrors: true }\n  });\n  const parentResources = new Dict();\n  const operatorList = new OperatorList();\n  const task = { ensureNotTerminated: () => {} };\n  const initialState = {};\n  const localColorSpaceCache = {};\n  const seenRefs = new Set();\n\n  // Faulty Form XObject: its Resources entry is not a Dict.\n  const faultyStream = new StringStream(\"\");\n  faultyStream.dict = new Dict();\n  faultyStream.dict.set(\"Subtype\", new Name(\"Form\"));\n  faultyStream.dict.set(\"Matrix\", [1, 0, 0, 1, 0, 0]);\n  faultyStream.dict.set(\"BBox\", [0, 0, 10, 10]);\n  faultyStream.dict.set(\"Resources\", new Name(\"Faulty\"));\n\n  // Correct Form XObject: its Resources entry is a proper Dict.\n  const correctStream = new StringStream(\"\");\n  correctStream.dict = new Dict();\n  correctStream.dict.set(\"Subtype\", new Name(\"Form\"));\n  correctStream.dict.set(\"Matrix\", [1, 0, 0, 1, 0, 0]);\n  correctStream.dict.set(\"BBox\", [0, 0, 10, 10]);\n  const validResources = new Dict();\n  correctStream.dict.set(\"Resources\", validResources);\n\n  await evaluator.buildFormXObject(parentResources, faultyStream, null, operatorList, task, initialState, localColorSpaceCache, seenRefs);\n  await evaluator.buildFormXObject(parentResources, correctStream, null, operatorList, task, initialState, localColorSpaceCache, seenRefs);\n\n  const beginOps = operatorList.fnArray.filter(op => op === OPS.paintFormXObjectBegin);\n  if (beginOps.length !== 2) {\n    throw new Error(`Expected 2 paintFormXObjectBegin operations, but got ${beginOps.length}`);\n  }\n});",
    "i3_llama-3.3-70b-versatile": "it(\"should render a correct form XObject even if a preceding form XObject has a faulty Resources entry\", async () => {\n  const evaluator = new PartialEvaluator({\n    xref: new XRefMock(),\n    handler: {},\n    pageIndex: 0,\n    idFactory: createIdFactory(),\n    fontCache: {},\n    builtInCMapCache: {},\n    standardFontDataCache: {},\n    globalColorSpaceCache: {},\n    globalImageCache: {},\n    systemFontCache: {},\n    options: { ignoreErrors: true }\n  });\n  const parentResources = new Dict();\n  const operatorList = new OperatorList();\n  const task = { ensureNotTerminated: () => {} };\n  const initialState = {};\n  const localColorSpaceCache = {};\n  const seenRefs = new Set();\n\n  // Faulty Form XObject: its Resources entry is not a Dict.\n  const faultyStream = new StringStream(\"\");\n  faultyStream.dict = new Dict();\n  faultyStream.dict.set(\"Subtype\", new Name(\"Form\"));\n  faultyStream.dict.set(\"Matrix\", [1, 0, 0, 1, 0, 0]);\n  faultyStream.dict.set(\"BBox\", [0, 0, 10, 10]);\n  faultyStream.dict.set(\"Resources\", new Name(\"Faulty\"));\n\n  // Correct Form XObject: its Resources entry is a proper Dict.\n  const correctStream = new StringStream(\"\");\n  correctStream.dict = new Dict();\n  correctStream.dict.set(\"Subtype\", new Name(\"Form\"));\n  correctStream.dict.set(\"Matrix\", [1, 0, 0, 1, 0, 0]);\n  correctStream.dict.set(\"BBox\", [0, 0, 10, 10]);\n  const validResources = new Dict();\n  correctStream.dict.set(\"Resources\", validResources);\n\n  await evaluator.buildFormXObject(parentResources, faultyStream, null, operatorList, task, initialState, localColorSpaceCache, seenRefs);\n  await evaluator.buildFormXObject(parentResources, correctStream, null, operatorList, task, initialState, localColorSpaceCache, seenRefs);\n\n  const beginOps = operatorList.fnArray.filter(op => op === OPS.paintFormXObjectBegin);\n  if (beginOps.length !== 2) {\n    throw new Error(`Expected 2 paintFormXObjectBegin operations, but got ${beginOps.length}`);\n  }\n});",
    "i4_deepseek-r1-distill-llama-70b": "it(\"should render a correct form XObject even if a preceding form XObject has a faulty Resources entry\", async () => {\n  const evaluator = new PartialEvaluator({\n    xref: new XRefMock(),\n    handler: {},\n    pageIndex: 0,\n    idFactory: createIdFactory(),\n    fontCache: {},\n    builtInCMapCache: {},\n    standardFontDataCache: {},\n    globalColorSpaceCache: {},\n    globalImageCache: {},\n    systemFontCache: {},\n    options: { ignoreErrors: true }\n  });\n  const parentResources = new Dict();\n  const operatorList = new OperatorList();\n  const task = { ensureNotTerminated: () => {} };\n  const initialState = {};\n  const localColorSpaceCache = {};\n  const seenRefs = new Set();\n\n  // Faulty Form XObject: its Resources entry is not a Dict.\n  const faultyStream = new StringStream(\"\");\n  faultyStream.dict = new Dict();\n  faultyStream.dict.set(\"Subtype\", new Name(\"Form\"));\n  faultyStream.dict.set(\"Matrix\", [1, 0, 0, 1, 0, 0]);\n  faultyStream.dict.set(\"BBox\", [0, 0, 10, 10]);\n  faultyStream.dict.set(\"Resources\", new Name(\"Faulty\"));\n\n  // Correct Form XObject: its Resources entry is a proper Dict.\n  const correctStream = new StringStream(\"\");\n  correctStream.dict = new Dict();\n  correctStream.dict.set(\"Subtype\", new Name(\"Form\"));\n  correctStream.dict.set(\"Matrix\", [1, 0, 0, 1, 0, 0]);\n  correctStream.dict.set(\"BBox\", [0, 0, 10, 10]);\n  const validResources = new Dict();\n  correctStream.dict.set(\"Resources\", validResources);\n\n  await evaluator.buildFormXObject(parentResources, faultyStream, null, operatorList, task, initialState, localColorSpaceCache, seenRefs);\n  await evaluator.buildFormXObject(parentResources, correctStream, null, operatorList, task, initialState, localColorSpaceCache, seenRefs);\n\n  const beginOps = operatorList.fnArray.filter(op => op === OPS.paintFormXObjectBegin);\n  if (beginOps.length !== 2) {\n    throw new Error(`Expected 2 paintFormXObjectBegin operations, but got ${beginOps.length}`);\n  }\n});",
    "i4_gpt-4o": "it(\"should render a correct form XObject even if a preceding form XObject has a faulty Resources entry\", async () => {\n  const evaluator = new PartialEvaluator({\n    xref: new XRefMock(),\n    handler: {},\n    pageIndex: 0,\n    idFactory: createIdFactory(),\n    fontCache: {},\n    builtInCMapCache: {},\n    standardFontDataCache: {},\n    globalColorSpaceCache: {},\n    globalImageCache: {},\n    systemFontCache: {},\n    options: { ignoreErrors: true }\n  });\n  const parentResources = new Dict();\n  const operatorList = new OperatorList();\n  const task = { ensureNotTerminated: () => {} };\n  const initialState = {};\n  const localColorSpaceCache = {};\n  const seenRefs = new Set();\n\n  // Faulty Form XObject: its Resources entry is not a Dict.\n  const faultyStream = new StringStream(\"\");\n  faultyStream.dict = new Dict();\n  faultyStream.dict.set(\"Subtype\", new Name(\"Form\"));\n  faultyStream.dict.set(\"Matrix\", [1, 0, 0, 1, 0, 0]);\n  faultyStream.dict.set(\"BBox\", [0, 0, 10, 10]);\n  faultyStream.dict.set(\"Resources\", new Name(\"Faulty\"));\n\n  // Correct Form XObject: its Resources entry is a proper Dict.\n  const correctStream = new StringStream(\"\");\n  correctStream.dict = new Dict();\n  correctStream.dict.set(\"Subtype\", new Name(\"Form\"));\n  correctStream.dict.set(\"Matrix\", [1, 0, 0, 1, 0, 0]);\n  correctStream.dict.set(\"BBox\", [0, 0, 10, 10]);\n  const validResources = new Dict();\n  correctStream.dict.set(\"Resources\", validResources);\n\n  await evaluator.buildFormXObject(parentResources, faultyStream, null, operatorList, task, initialState, localColorSpaceCache, seenRefs);\n  await evaluator.buildFormXObject(parentResources, correctStream, null, operatorList, task, initialState, localColorSpaceCache, seenRefs);\n\n  const beginOps = operatorList.fnArray.filter(op => op === OPS.paintFormXObjectBegin);\n  if (beginOps.length !== 2) {\n    throw new Error(`Expected 2 paintFormXObjectBegin operations, but got ${beginOps.length}`);\n  }\n});",
    "i4_llama-3.3-70b-versatile": "it(\"should render a correct form XObject even if a preceding form XObject has a faulty Resources entry\", async () => {\n  const evaluator = new PartialEvaluator({\n    xref: new XRefMock(),\n    handler: {},\n    pageIndex: 0,\n    idFactory: createIdFactory(),\n    fontCache: {},\n    builtInCMapCache: {},\n    standardFontDataCache: {},\n    globalColorSpaceCache: {},\n    globalImageCache: {},\n    systemFontCache: {},\n    options: { ignoreErrors: true }\n  });\n  const parentResources = new Dict();\n  const operatorList = new OperatorList();\n  const task = { ensureNotTerminated: () => {} };\n  const initialState = {};\n  const localColorSpaceCache = {};\n  const seenRefs = new Set();\n\n  // Faulty Form XObject: its Resources entry is not a Dict.\n  const faultyStream = new StringStream(\"\");\n  faultyStream.dict = new Dict();\n  faultyStream.dict.set(\"Subtype\", new Name(\"Form\"));\n  faultyStream.dict.set(\"Matrix\", [1, 0, 0, 1, 0, 0]);\n  faultyStream.dict.set(\"BBox\", [0, 0, 10, 10]);\n  faultyStream.dict.set(\"Resources\", new Name(\"Faulty\"));\n\n  // Correct Form XObject: its Resources entry is a proper Dict.\n  const correctStream = new StringStream(\"\");\n  correctStream.dict = new Dict();\n  correctStream.dict.set(\"Subtype\", new Name(\"Form\"));\n  correctStream.dict.set(\"Matrix\", [1, 0, 0, 1, 0, 0]);\n  correctStream.dict.set(\"BBox\", [0, 0, 10, 10]);\n  const validResources = new Dict();\n  correctStream.dict.set(\"Resources\", validResources);\n\n  await evaluator.buildFormXObject(parentResources, faultyStream, null, operatorList, task, initialState, localColorSpaceCache, seenRefs);\n  await evaluator.buildFormXObject(parentResources, correctStream, null, operatorList, task, initialState, localColorSpaceCache, seenRefs);\n\n  const beginOps = operatorList.fnArray.filter(op => op === OPS.paintFormXObjectBegin);\n  if (beginOps.length !== 2) {\n    throw new Error(`Expected 2 paintFormXObjectBegin operations, but got ${beginOps.length}`);\n  }\n});",
    "i5_deepseek-r1-distill-llama-70b": "it(\"should render a correct form XObject even if a preceding form XObject has a faulty Resources entry\", async () => {\n  const evaluator = new PartialEvaluator({\n    xref: new XRefMock(),\n    handler: {},\n    pageIndex: 0,\n    idFactory: createIdFactory(),\n    fontCache: {},\n    builtInCMapCache: {},\n    standardFontDataCache: {},\n    globalColorSpaceCache: {},\n    globalImageCache: {},\n    systemFontCache: {},\n    options: { ignoreErrors: true }\n  });\n  const parentResources = new Dict();\n  const operatorList = new OperatorList();\n  const task = { ensureNotTerminated: () => {} };\n  const initialState = {};\n  const localColorSpaceCache = {};\n  const seenRefs = new Set();\n\n  // Faulty Form XObject: its Resources entry is not a Dict.\n  const faultyStream = new StringStream(\"\");\n  faultyStream.dict = new Dict();\n  faultyStream.dict.set(\"Subtype\", new Name(\"Form\"));\n  faultyStream.dict.set(\"Matrix\", [1, 0, 0, 1, 0, 0]);\n  faultyStream.dict.set(\"BBox\", [0, 0, 10, 10]);\n  faultyStream.dict.set(\"Resources\", new Name(\"Faulty\"));\n\n  // Correct Form XObject: its Resources entry is a proper Dict.\n  const correctStream = new StringStream(\"\");\n  correctStream.dict = new Dict();\n  correctStream.dict.set(\"Subtype\", new Name(\"Form\"));\n  correctStream.dict.set(\"Matrix\", [1, 0, 0, 1, 0, 0]);\n  correctStream.dict.set(\"BBox\", [0, 0, 10, 10]);\n  const validResources = new Dict();\n  correctStream.dict.set(\"Resources\", validResources);\n\n  await evaluator.buildFormXObject(parentResources, faultyStream, null, operatorList, task, initialState, localColorSpaceCache, seenRefs);\n  await evaluator.buildFormXObject(parentResources, correctStream, null, operatorList, task, initialState, localColorSpaceCache, seenRefs);\n\n  const beginOps = operatorList.fnArray.filter(op => op === OPS.paintFormXObjectBegin);\n  if (beginOps.length !== 2) {\n    throw new Error(`Expected 2 paintFormXObjectBegin operations, but got ${beginOps.length}`);\n  }\n});",
    "i5_gpt-4o": "it(\"should render a correct form XObject even if a preceding form XObject has a faulty Resources entry\", async () => {\n  const evaluator = new PartialEvaluator({\n    xref: new XRefMock(),\n    handler: {},\n    pageIndex: 0,\n    idFactory: createIdFactory(),\n    fontCache: {},\n    builtInCMapCache: {},\n    standardFontDataCache: {},\n    globalColorSpaceCache: {},\n    globalImageCache: {},\n    systemFontCache: {},\n    options: { ignoreErrors: true }\n  });\n  const parentResources = new Dict();\n  const operatorList = new OperatorList();\n  const task = { ensureNotTerminated: () => {} };\n  const initialState = {};\n  const localColorSpaceCache = {};\n  const seenRefs = new Set();\n\n  // Faulty Form XObject: its Resources entry is not a Dict.\n  const faultyStream = new StringStream(\"\");\n  faultyStream.dict = new Dict();\n  faultyStream.dict.set(\"Subtype\", new Name(\"Form\"));\n  faultyStream.dict.set(\"Matrix\", [1, 0, 0, 1, 0, 0]);\n  faultyStream.dict.set(\"BBox\", [0, 0, 10, 10]);\n  faultyStream.dict.set(\"Resources\", new Name(\"Faulty\"));\n\n  // Correct Form XObject: its Resources entry is a proper Dict.\n  const correctStream = new StringStream(\"\");\n  correctStream.dict = new Dict();\n  correctStream.dict.set(\"Subtype\", new Name(\"Form\"));\n  correctStream.dict.set(\"Matrix\", [1, 0, 0, 1, 0, 0]);\n  correctStream.dict.set(\"BBox\", [0, 0, 10, 10]);\n  const validResources = new Dict();\n  correctStream.dict.set(\"Resources\", validResources);\n\n  await evaluator.buildFormXObject(parentResources, faultyStream, null, operatorList, task, initialState, localColorSpaceCache, seenRefs);\n  await evaluator.buildFormXObject(parentResources, correctStream, null, operatorList, task, initialState, localColorSpaceCache, seenRefs);\n\n  const beginOps = operatorList.fnArray.filter(op => op === OPS.paintFormXObjectBegin);\n  if (beginOps.length !== 2) {\n    throw new Error(`Expected 2 paintFormXObjectBegin operations, but got ${beginOps.length}`);\n  }\n});",
    "i5_llama-3.3-70b-versatile": "it(\"should render a correct form XObject even if a preceding form XObject has a faulty Resources entry\", async () => {\n  const evaluator = new PartialEvaluator({\n    xref: new XRefMock(),\n    handler: {},\n    pageIndex: 0,\n    idFactory: createIdFactory(),\n    fontCache: {},\n    builtInCMapCache: {},\n    standardFontDataCache: {},\n    globalColorSpaceCache: {},\n    globalImageCache: {},\n    systemFontCache: {},\n    options: { ignoreErrors: true }\n  });\n  const parentResources = new Dict();\n  const operatorList = new OperatorList();\n  const task = { ensureNotTerminated: () => {} };\n  const initialState = {};\n  const localColorSpaceCache = {};\n  const seenRefs = new Set();\n\n  // Faulty Form XObject: its Resources entry is not a Dict.\n  const faultyStream = new StringStream(\"\");\n  faultyStream.dict = new Dict();\n  faultyStream.dict.set(\"Subtype\", new Name(\"Form\"));\n  faultyStream.dict.set(\"Matrix\", [1, 0, 0, 1, 0, 0]);\n  faultyStream.dict.set(\"BBox\", [0, 0, 10, 10]);\n  faultyStream.dict.set(\"Resources\", new Name(\"Faulty\"));\n\n  // Correct Form XObject: its Resources entry is a proper Dict.\n  const correctStream = new StringStream(\"\");\n  correctStream.dict = new Dict();\n  correctStream.dict.set(\"Subtype\", new Name(\"Form\"));\n  correctStream.dict.set(\"Matrix\", [1, 0, 0, 1, 0, 0]);\n  correctStream.dict.set(\"BBox\", [0, 0, 10, 10]);\n  const validResources = new Dict();\n  correctStream.dict.set(\"Resources\", validResources);\n\n  await evaluator.buildFormXObject(parentResources, faultyStream, null, operatorList, task, initialState, localColorSpaceCache, seenRefs);\n  await evaluator.buildFormXObject(parentResources, correctStream, null, operatorList, task, initialState, localColorSpaceCache, seenRefs);\n\n  const beginOps = operatorList.fnArray.filter(op => op === OPS.paintFormXObjectBegin);\n  if (beginOps.length !== 2) {\n    throw new Error(`Expected 2 paintFormXObjectBegin operations, but got ${beginOps.length}`);\n  }\n});"
  },
  "19972": {
    "i1_deepseek-r1-distill-llama-70b": "it(\"should not throw and leave buffer unchanged when minMax is undefined\", async () => {\n  const { OperatorList, DrawOPS } = await import(\"../../src/core/operator_list.js\");\n  const opList = new OperatorList();\n  const transform = [1, 0, 0, 1, 0, 0];\n  const buffer = [DrawOPS.moveTo, 10, 20, DrawOPS.lineTo, 30, 40, DrawOPS.curveTo, 1, 2, 3, 4, 5, 6];\n  const args = [null, [buffer], undefined];\n  expect(() => opList.addState([transform], 0, args)).not.toThrow();\n  expect(buffer).toEqual([DrawOPS.moveTo, 10, 20, DrawOPS.lineTo, 30, 40, DrawOPS.curveTo, 1, 2, 3, 4, 5, 6]);\n});",
    "i1_gpt-4o": "it(\"should not throw and leave buffer unchanged when minMax is undefined\", async () => {\n  const { OperatorList, DrawOPS } = await import(\"../../src/core/operator_list.js\");\n  const opList = new OperatorList();\n  const transform = [1, 0, 0, 1, 0, 0];\n  const buffer = [DrawOPS.moveTo, 10, 20, DrawOPS.lineTo, 30, 40, DrawOPS.curveTo, 1, 2, 3, 4, 5, 6];\n  const args = [null, [buffer], undefined];\n  expect(() => opList.addState([transform], 0, args)).not.toThrow();\n  expect(buffer).toEqual([DrawOPS.moveTo, 10, 20, DrawOPS.lineTo, 30, 40, DrawOPS.curveTo, 1, 2, 3, 4, 5, 6]);\n});",
    "i1_llama-3.3-70b-versatile": "it(\"should not throw and leave buffer unchanged when minMax is undefined\", async () => {\n  const { OperatorList, DrawOPS } = await import(\"../../src/core/operator_list.js\");\n  const opList = new OperatorList();\n  const transform = [1, 0, 0, 1, 0, 0];\n  const buffer = [DrawOPS.moveTo, 10, 20, DrawOPS.lineTo, 30, 40, DrawOPS.curveTo, 1, 2, 3, 4, 5, 6];\n  const args = [null, [buffer], undefined];\n  expect(() => opList.addState([transform], 0, args)).not.toThrow();\n  expect(buffer).toEqual([DrawOPS.moveTo, 10, 20, DrawOPS.lineTo, 30, 40, DrawOPS.curveTo, 1, 2, 3, 4, 5, 6]);\n});",
    "i1_MOCK": "it(\"should not throw and leave buffer unchanged when minMax is undefined\", async () => {\n  const { OperatorList, DrawOPS } = await import(\"../../src/core/operator_list.js\");\n  const opList = new OperatorList();\n  const transform = [1, 0, 0, 1, 0, 0];\n  const buffer = [DrawOPS.moveTo, 10, 20, DrawOPS.lineTo, 30, 40, DrawOPS.curveTo, 1, 2, 3, 4, 5, 6];\n  const args = [null, [buffer], undefined];\n  expect(() => opList.addState([transform], 0, args)).not.toThrow();\n  expect(buffer).toEqual([DrawOPS.moveTo, 10, 20, DrawOPS.lineTo, 30, 40, DrawOPS.curveTo, 1, 2, 3, 4, 5, 6]);\n});",
    "i2_deepseek-r1-distill-llama-70b": "it(\"should not throw and leave buffer unchanged when minMax is undefined\", async () => {\n  const { OperatorList, DrawOPS } = await import(\"../../src/core/operator_list.js\");\n  const opList = new OperatorList();\n  const transform = [1, 0, 0, 1, 0, 0];\n  const buffer = [DrawOPS.moveTo, 10, 20, DrawOPS.lineTo, 30, 40, DrawOPS.curveTo, 1, 2, 3, 4, 5, 6];\n  const args = [null, [buffer], undefined];\n  expect(() => opList.addState([transform], 0, args)).not.toThrow();\n  expect(buffer).toEqual([DrawOPS.moveTo, 10, 20, DrawOPS.lineTo, 30, 40, DrawOPS.curveTo, 1, 2, 3, 4, 5, 6]);\n});",
    "i2_gpt-4o": "it(\"should not throw and leave buffer unchanged when minMax is undefined\", async () => {\n  const { OperatorList, DrawOPS } = await import(\"../../src/core/operator_list.js\");\n  const opList = new OperatorList();\n  const transform = [1, 0, 0, 1, 0, 0];\n  const buffer = [DrawOPS.moveTo, 10, 20, DrawOPS.lineTo, 30, 40, DrawOPS.curveTo, 1, 2, 3, 4, 5, 6];\n  const args = [null, [buffer], undefined];\n  expect(() => opList.addState([transform], 0, args)).not.toThrow();\n  expect(buffer).toEqual([DrawOPS.moveTo, 10, 20, DrawOPS.lineTo, 30, 40, DrawOPS.curveTo, 1, 2, 3, 4, 5, 6]);\n});",
    "i2_llama-3.3-70b-versatile": "it(\"should not throw and leave buffer unchanged when minMax is undefined\", async () => {\n  const { OperatorList, DrawOPS } = await import(\"../../src/core/operator_list.js\");\n  const opList = new OperatorList();\n  const transform = [1, 0, 0, 1, 0, 0];\n  const buffer = [DrawOPS.moveTo, 10, 20, DrawOPS.lineTo, 30, 40, DrawOPS.curveTo, 1, 2, 3, 4, 5, 6];\n  const args = [null, [buffer], undefined];\n  expect(() => opList.addState([transform], 0, args)).not.toThrow();\n  expect(buffer).toEqual([DrawOPS.moveTo, 10, 20, DrawOPS.lineTo, 30, 40, DrawOPS.curveTo, 1, 2, 3, 4, 5, 6]);\n});",
    "i3_deepseek-r1-distill-llama-70b": "it(\"should not throw and leave buffer unchanged when minMax is undefined\", async () => {\n  const { OperatorList, DrawOPS } = await import(\"../../src/core/operator_list.js\");\n  const opList = new OperatorList();\n  const transform = [1, 0, 0, 1, 0, 0];\n  const buffer = [DrawOPS.moveTo, 10, 20, DrawOPS.lineTo, 30, 40, DrawOPS.curveTo, 1, 2, 3, 4, 5, 6];\n  const args = [null, [buffer], undefined];\n  expect(() => opList.addState([transform], 0, args)).not.toThrow();\n  expect(buffer).toEqual([DrawOPS.moveTo, 10, 20, DrawOPS.lineTo, 30, 40, DrawOPS.curveTo, 1, 2, 3, 4, 5, 6]);\n});",
    "i3_gpt-4o": "it(\"should not throw and leave buffer unchanged when minMax is undefined\", async () => {\n  const { OperatorList, DrawOPS } = await import(\"../../src/core/operator_list.js\");\n  const opList = new OperatorList();\n  const transform = [1, 0, 0, 1, 0, 0];\n  const buffer = [DrawOPS.moveTo, 10, 20, DrawOPS.lineTo, 30, 40, DrawOPS.curveTo, 1, 2, 3, 4, 5, 6];\n  const args = [null, [buffer], undefined];\n  expect(() => opList.addState([transform], 0, args)).not.toThrow();\n  expect(buffer).toEqual([DrawOPS.moveTo, 10, 20, DrawOPS.lineTo, 30, 40, DrawOPS.curveTo, 1, 2, 3, 4, 5, 6]);\n});",
    "i3_llama-3.3-70b-versatile": "it(\"should not throw and leave buffer unchanged when minMax is undefined\", async () => {\n  const { OperatorList, DrawOPS } = await import(\"../../src/core/operator_list.js\");\n  const opList = new OperatorList();\n  const transform = [1, 0, 0, 1, 0, 0];\n  const buffer = [DrawOPS.moveTo, 10, 20, DrawOPS.lineTo, 30, 40, DrawOPS.curveTo, 1, 2, 3, 4, 5, 6];\n  const args = [null, [buffer], undefined];\n  expect(() => opList.addState([transform], 0, args)).not.toThrow();\n  expect(buffer).toEqual([DrawOPS.moveTo, 10, 20, DrawOPS.lineTo, 30, 40, DrawOPS.curveTo, 1, 2, 3, 4, 5, 6]);\n});",
    "i4_deepseek-r1-distill-llama-70b": "it(\"should not throw and leave buffer unchanged when minMax is undefined\", async () => {\n  const { OperatorList, DrawOPS } = await import(\"../../src/core/operator_list.js\");\n  const opList = new OperatorList();\n  const transform = [1, 0, 0, 1, 0, 0];\n  const buffer = [DrawOPS.moveTo, 10, 20, DrawOPS.lineTo, 30, 40, DrawOPS.curveTo, 1, 2, 3, 4, 5, 6];\n  const args = [null, [buffer], undefined];\n  expect(() => opList.addState([transform], 0, args)).not.toThrow();\n  expect(buffer).toEqual([DrawOPS.moveTo, 10, 20, DrawOPS.lineTo, 30, 40, DrawOPS.curveTo, 1, 2, 3, 4, 5, 6]);\n});",
    "i4_gpt-4o": "it(\"should not throw and leave buffer unchanged when minMax is undefined\", async () => {\n  const { OperatorList, DrawOPS } = await import(\"../../src/core/operator_list.js\");\n  const opList = new OperatorList();\n  const transform = [1, 0, 0, 1, 0, 0];\n  const buffer = [DrawOPS.moveTo, 10, 20, DrawOPS.lineTo, 30, 40, DrawOPS.curveTo, 1, 2, 3, 4, 5, 6];\n  const args = [null, [buffer], undefined];\n  expect(() => opList.addState([transform], 0, args)).not.toThrow();\n  expect(buffer).toEqual([DrawOPS.moveTo, 10, 20, DrawOPS.lineTo, 30, 40, DrawOPS.curveTo, 1, 2, 3, 4, 5, 6]);\n});",
    "i4_llama-3.3-70b-versatile": "it(\"should not throw and leave buffer unchanged when minMax is undefined\", async () => {\n  const { OperatorList, DrawOPS } = await import(\"../../src/core/operator_list.js\");\n  const opList = new OperatorList();\n  const transform = [1, 0, 0, 1, 0, 0];\n  const buffer = [DrawOPS.moveTo, 10, 20, DrawOPS.lineTo, 30, 40, DrawOPS.curveTo, 1, 2, 3, 4, 5, 6];\n  const args = [null, [buffer], undefined];\n  expect(() => opList.addState([transform], 0, args)).not.toThrow();\n  expect(buffer).toEqual([DrawOPS.moveTo, 10, 20, DrawOPS.lineTo, 30, 40, DrawOPS.curveTo, 1, 2, 3, 4, 5, 6]);\n});",
    "i5_deepseek-r1-distill-llama-70b": "it(\"should not throw and leave buffer unchanged when minMax is undefined\", async () => {\n  const { OperatorList, DrawOPS } = await import(\"../../src/core/operator_list.js\");\n  const opList = new OperatorList();\n  const transform = [1, 0, 0, 1, 0, 0];\n  const buffer = [DrawOPS.moveTo, 10, 20, DrawOPS.lineTo, 30, 40, DrawOPS.curveTo, 1, 2, 3, 4, 5, 6];\n  const args = [null, [buffer], undefined];\n  expect(() => opList.addState([transform], 0, args)).not.toThrow();\n  expect(buffer).toEqual([DrawOPS.moveTo, 10, 20, DrawOPS.lineTo, 30, 40, DrawOPS.curveTo, 1, 2, 3, 4, 5, 6]);\n});",
    "i5_gpt-4o": "it(\"should not throw and leave buffer unchanged when minMax is undefined\", async () => {\n  const { OperatorList, DrawOPS } = await import(\"../../src/core/operator_list.js\");\n  const opList = new OperatorList();\n  const transform = [1, 0, 0, 1, 0, 0];\n  const buffer = [DrawOPS.moveTo, 10, 20, DrawOPS.lineTo, 30, 40, DrawOPS.curveTo, 1, 2, 3, 4, 5, 6];\n  const args = [null, [buffer], undefined];\n  expect(() => opList.addState([transform], 0, args)).not.toThrow();\n  expect(buffer).toEqual([DrawOPS.moveTo, 10, 20, DrawOPS.lineTo, 30, 40, DrawOPS.curveTo, 1, 2, 3, 4, 5, 6]);\n});",
    "i5_llama-3.3-70b-versatile": "it(\"should not throw and leave buffer unchanged when minMax is undefined\", async () => {\n  const { OperatorList, DrawOPS } = await import(\"../../src/core/operator_list.js\");\n  const opList = new OperatorList();\n  const transform = [1, 0, 0, 1, 0, 0];\n  const buffer = [DrawOPS.moveTo, 10, 20, DrawOPS.lineTo, 30, 40, DrawOPS.curveTo, 1, 2, 3, 4, 5, 6];\n  const args = [null, [buffer], undefined];\n  expect(() => opList.addState([transform], 0, args)).not.toThrow();\n  expect(buffer).toEqual([DrawOPS.moveTo, 10, 20, DrawOPS.lineTo, 30, 40, DrawOPS.curveTo, 1, 2, 3, 4, 5, 6]);\n});"
  },
  "20063": {
    "i1_deepseek-r1-distill-llama-70b": "it(\"should render polygon annotation with fill color\", async () => {\n  const { getDocument } = await import('../../src/display/api.js');\n  const { buildGetDocumentParams } = await import('./test_utils.js');\n  const loadingTask = getDocument(buildGetDocumentParams('issue20062.pdf'));\n\n  const expectedFillColor = [0, 255, 0]; // Green fill color from the PDF\n\n  const { numPages, pageRendering } = await loadingTask;\n  const page = await pageRendering(0);\n  await page.render({ canvasContext: { canvas: document.createElement('canvas') } });\n\n  const canvas = page.canvas;\n  const ctx = canvas.getContext('2d');\n  const imageData = ctx.getImageData(\n    canvas.width / 2,\n    canvas.height / 2,\n    1,\n    1\n  );\n  const actualFillColor = [\n    imageData.data[0],\n    imageData.data[1],\n    imageData.data[2]\n  ];\n\n  expect(actualFillColor).toEqual(expectedFillColor);\n});",
    "i1_llama-3.3-70b-versatile": "it(\"should render PolygonAnnotation fill correctly\", async () => {\n  const { getDocument } = await import('../../src/display/api.js');\n  const { buildGetDocumentParams } = await import('./test_utils.js');\n  const loadingTask = getDocument(buildGetDocumentParams('issue20062.pdf'));\n  const pdfDocument = await loadingTask.promise;\n  const pdfPage = await pdfDocument.getPage(1);\n  const operatorList = await pdfPage.getOperatorList();\n  const annotationList = await pdfPage.getAnnotations();\n  const polygonAnnotation = annotationList.find(annotation => annotation instanceof MarkupAnnotation && annotation.data.annotationType === AnnotationType.POLYGON);\n  const renderTask = pdfPage.render({\n    viewport: pdfPage.getViewport({ scale: 1 }),\n    annotationMode: 'render',\n  });\n  await renderTask.promise;\n  const canvasContext = renderTask.canvasContext;\n  const fillColor = getRgbColor(polygonAnnotation.dict.getArray(\"IC\"), null);\n  const expectedFillColor = getPdfColorArray(fillColor);\n  const actualFillColor = canvasContext.fillStyle;\n  expect(actualFillColor).toEqual(expectedFillColor);\n});",
    "i2_deepseek-r1-distill-llama-70b": "it(\"should render polygon annotation with fill color\", async () => {\n  const { getDocument } = await import(\"../../src/display/api.js\");\n  const { buildGetDocumentParams } = await import(\"./test_utils.js\");\n  const loadingTask = getDocument(buildGetDocumentParams('issue20062.pdf'));\n\n  const doc = await loadingTask.promise;\n  const page = await doc.getPage(1);\n\n  const canvas = document.createElement('canvas');\n  const context = canvas.getContext('2d');\n\n  let annotation;\n\n  page.on('annotationloaded', (annotationArgs) => {\n    if (annotationArgs.annotation instanceof PolygonAnnotation) {\n      annotation = annotationArgs.annotation;\n    }\n  });\n\n  const renderTask = page.render({\n    canvasContext: context,\n    viewport: page.getViewport({ scale: 1 })\n  });\n\n  const expectedFillColor = [0, 255, 0]; // Green fill color\n\n  const fillResolve = new Promise(resolve => {\n    renderTask.on('finish', () => {\n      const pixelData = context.getImageData(\n        canvas.width/2,\n        canvas.height/2,\n        1,\n        1\n      ).data;\n\n      resolve(pixelData);\n    });\n  });\n\n  const actualPixelData = await fillResolve;\n\n  expect(actualPixelData).toEqual(expectedFillColor.concat([255]));\n});",
    "i2_gpt-4o": "it(\"should render PolygonAnnotation with fill color in PDFjs viewer\", async () => {\n  const { getDocument } = await import('../../src/display/api.js');\n  const { buildGetDocumentParams } = await import('./test_utils.js');\n  const loadingTask = getDocument(buildGetDocumentParams('issue20062.pdf'));\n  const pdfDocument = await loadingTask.promise;\n  const page = await pdfDocument.getPage(1);\n  const annotations = await page.getAnnotations();\n  const polygonAnnotation = annotations.find(ann => ann.subtype === 'Polygon');\n  const expectedFillColor = [1, 0, 0]; // Assuming the fill color is red\n  const actualFillColor = polygonAnnotation.fillColor;\n  expect(actualFillColor).toEqual(expectedFillColor);\n});",
    "i2_llama-3.3-70b-versatile": "it(\"should render the fill color of a PolygonAnnotation\", async () => {\n  const { getDocument } = await import('../../src/display/api.js');\n  const { buildGetDocumentParams } = await import('./test_utils.js');\n  const loadingTask = getDocument(buildGetDocumentParams('issue20062.pdf'));\n  const pdfDocument = await loadingTask.promise;\n  const page = await pdfDocument.getPage(1);\n  const operatorList = await page.getOperatorList();\n  const annotationList = await page.getAnnotations();\n  const polygonAnnotation = annotationList.find(annotation => annotation instanceof PolygonAnnotation);\n  const renderTask = page.render({\n    annotationMode: 'visible',\n    viewport: page.getViewport({ scale: 1 }),\n    renderInteractive: false,\n  });\n  await renderTask.promise;\n  const canvasContext = renderTask.canvas.getContext('2d');\n  const fillColor = getRgbColor(polygonAnnotation.dict.getArray(\"IC\"), null);\n  const expectedFillColor = getPdfColorArray(fillColor);\n  const actualFillColor = canvasContext.getImageData(10, 10, 1, 1).data;\n  expect(actualFillColor).toEqual(expectedFillColor);\n});",
    "i3_deepseek-r1-distill-llama-70b": "it(\"should render polygon annotation with both outline and fill\", async () => {\n  const { getDocument } = await import('../../src/display/api.js');\n  const { buildGetDocumentParams } = await import('./test_utils.js');\n  const loadingTask = getDocument(buildGetDocumentParams('issue20062.pdf'));\n\n  const doc = await loadingTask;\n  const page = await doc.getPage(0);\n  const annotations = await page.getAnnotations();\n\n  const polygonAnnotation = annotations.find(annotation => \n    annotation instanceof MarkupAnnotation && \n    annotation.data.subtype === 'Polygon' &&\n    annotation.color &&\n    annotation.data.backgroundColor\n  );\n\n  if (!polygonAnnotation) {\n    throw new Error(\"PolygonAnnotation with fill not found in PDF\");\n  }\n\n  const operatorList = await polygonAnnotation.getOperatorList({\n    task: new WorkerTask(),\n    evaluator: {\n      xref: new XRefMock(),\n      options: {\n        isOffscreenCanvasSupported: true,\n      },\n    },\n    intent: RenderingIntentFlag.DISPLAY,\n    annotationStorage: null,\n  });\n\n  const ops = operatorList.opList.ops;\n  const hasFill = ops.some(op => op.cmd === 'f');\n  const hasStroke = ops.some(op => op.cmd === 'S');\n\n  if (!hasFill || !hasStroke) {\n    throw new Error(\"PolygonAnnotation is missing fill or stroke in rendering\");\n  }\n});",
    "i3_llama-3.3-70b-versatile": "it(\"should render PolygonAnnotation with fill color\", async () => {\n  const { getDocument } = await import('../../src/display/api.js');\n  const { buildGetDocumentParams } = await import('./test_utils.js');\n  const loadingTask = getDocument(buildGetDocumentParams('issue20062.pdf'));\n  const doc = await loadingTask.promise;\n  const page = await doc.getPage(1);\n  const annotations = await page.getAnnotations();\n  const annotation = annotations[0];\n  const operatorList = await annotation.getOperatorList({ task: new WorkerTask() }, null, RenderingIntentFlag.DISPLAY);\n  const expectedOperator = 'f'; // fill operator\n  const actualOperator = operatorList.opList.ops[operatorList.opList.ops.length - 1][0];\n  assert.equal(actualOperator, expectedOperator, `Expected operator to be '${expectedOperator}' but got '${actualOperator}'`);\n});",
    "i4_deepseek-r1-distill-llama-70b": "it(\"should render polygon annotation with fill color\", async () => {\n  const { getDocument } = await import(\"../../src/display/api.js\");\n  const { buildGetDocumentParams } = await import(\"./test_utils.js\");\n  const loadingTask = getDocument(buildGetDocumentParams('issue20062.pdf'));\n\n  const pdfDocument = await loadingTask;\n  const page = await pdfDocument.getPage(0);\n  const annotations = await page.getAnnotations();\n\n  const annotation = annotations[0];\n  const operatorList = await annotation.getOperatorList(null, null, RenderingIntentFlag.DISPLAY);\n\n  const expectedFillOperator = \"f\";\n  const actualOperators = operatorList.opList.ops.map(op => op.cmd);\n\n  assert.ok(actualOperators.includes(expectedFillOperator));\n});",
    "i4_gpt-4o": "it(\"should render PolygonAnnotation with fill color in PDFjs web viewer\", async () => {\n  const { getDocument } = await import('../../src/display/api.js');\n  const { buildGetDocumentParams } = await import('./test_utils.js');\n  const loadingTask = getDocument(buildGetDocumentParams('issue20062.pdf'));\n  const pdfDocument = await loadingTask.promise;\n  const page = await pdfDocument.getPage(1);\n  const annotations = await page.getAnnotations();\n  const polygonAnnotation = annotations.find(annot => annot.subtype === 'Polygon');\n  const expectedFillColor = [1, 0, 0]; // Assuming the fill color is red\n  const actualFillColor = polygonAnnotation.fillColor;\n  expect(actualFillColor).toEqual(expectedFillColor);\n});",
    "i4_llama-3.3-70b-versatile": "it(\"should render PolygonAnnotation with fill color\", async () => {\n  const { getDocument } = await import('../../src/display/api.js');\n  const { buildGetDocumentParams } = await import('./test_utils.js');\n  const loadingTask = getDocument(buildGetDocumentParams('issue20062.pdf'));\n  const pdfDocument = await loadingTask.promise;\n  const pdfPage = await pdfDocument.getPage(1);\n  const operatorList = await pdfPage.getOperatorList({\n    intent: 'display',\n  });\n  const renderTasks = await pdfPage.getRenderTasks({\n    intent: 'display',\n    annotationFlags: 0,\n  });\n  const annotationFlags = renderTasks.annotations[0].flags;\n  const annotationColor = renderTasks.annotations[0].color;\n  const annotationFillColor = renderTasks.annotations[0].fillColor;\n  assert.ok(annotationFlags & 4, \"Annotation is not rendered with fill color\");\n  assert.deepEqual(annotationColor, [0, 0, 0, 1], \"Annotation color is incorrect\");\n  assert.deepEqual(annotationFillColor, [1, 0, 0, 1], \"Annotation fill color is incorrect\");\n});",
    "i5_deepseek-r1-distill-llama-70b": "it(\"should render polygon annotation with fill color\", async () => {\n  const { getDocument } = await import('../../src/display/api.js');\n  const { buildGetDocumentParams } = await import('./test_utils.js');\n  const loadingTask = getDocument(buildGetDocumentParams('issue20062.pdf'));\n\n  const canvas = document.createElement('canvas');\n  const context = canvas.getContext('2d');\n\n  const pdf = await loadingTask.promise;\n  const page = await pdf.getPage(1);\n  const scale = 1;\n  const viewport = page.getViewport({ scale });\n\n  canvas.width = viewport.width;\n  canvas.height = viewport.height;\n\n  const renderTask = page.render({\n    canvasContext: context,\n    viewport,\n    scale,\n  });\n\n  await renderTask.promise;\n\n  const expectedFillColor = 'rgb(255, 255, 255)';\n  const fillColor = context.getImageData(\n    Math.floor(canvas.width / 2),\n    Math.floor(canvas.height / 2),\n    1,\n    1\n  ).data;\n\n  expect(fillColor[3]).toBe(255);\n});",
    "i5_gpt-4o": "it(\"should render PolygonAnnotation with both fill and outline in PDFjs viewer\", async () => {\n  const { getDocument } = await import('../../src/display/api.js');\n  const { buildGetDocumentParams } = await import('./test_utils.js');\n  const loadingTask = getDocument(buildGetDocumentParams('issue20062.pdf'));\n  const pdfDocument = await loadingTask.promise;\n  const page = await pdfDocument.getPage(1);\n  const annotations = await page.getAnnotations();\n\n  const polygonAnnotation = annotations.find(ann => ann.subtype === 'Polygon');\n  const expectedFillColor = [1, 0, 0]; // Assuming the fill color is red (RGB)\n  const expectedStrokeColor = [0, 0, 0]; // Assuming the stroke color is black (RGB)\n\n  const actualFillColor = polygonAnnotation.fillColor;\n  const actualStrokeColor = polygonAnnotation.color;\n\n  expect(actualFillColor).toEqual(expectedFillColor);\n  expect(actualStrokeColor).toEqual(expectedStrokeColor);\n});",
    "i5_llama-3.3-70b-versatile": "it(\"should render polygon annotation with fill color\", async () => {\n  const { getDocument } = await import('../../src/display/api.js');\n  const { buildGetDocumentParams } = await import('./test_utils.js');\n  const loadingTask = getDocument(buildGetDocumentParams('issue20062.pdf'));\n  const pdfDoc = await loadingTask.promise;\n  const page = await pdfDoc.getPage(1);\n  const annotations = await page.getAnnotations();\n  const polygonAnnotation = annotations[0];\n  const operator = await page.render({\n    annotation: polygonAnnotation,\n    viewport: page.getViewport({ scale: 1 }),\n  });\n  const expectedOperator = \"f\";\n  expect(operator.pointsCallback[operator.pointsCallback.length - 1]).toBe(expectedOperator);\n});"
  },
  "20101": {
    "i1_gpt-4o": "it(\"should render text correctly when browserdisplayusedocumentfonts is set to\", async () => {\n  const { getDocument } = await import('../../src/display/api.js');\n  const { buildGetDocumentParams } = await import('./test_utils.js');\n  const loadingTask = getDocument(buildGetDocumentParams('issue20065.pdf'));\n  const pdfDocument = await loadingTask.promise;\n  const pdfPage = await pdfDocument.getPage(1);\n  const viewport = pdfPage.getViewport({ scale: 1.0 });\n  const canvasFactory = new (await import('../../src/display/canvas_factory.js')).DOMCanvasFactory();\n  const canvasAndContext = canvasFactory.create(viewport.width, viewport.height);\n  const renderTask = pdfPage.render({\n    canvasContext: canvasAndContext.context,\n    viewport,\n  });\n  await renderTask.promise;\n  const imageData = canvasAndContext.context.getImageData(0, 0, viewport.width, viewport.height);\n  const hasVisibleText = imageData.data.some((value, index) => index % 4 === 3 && value > 0);\n  expect(hasVisibleText).toBe(true);\n});",
    "i1_llama-3.3-70b-versatile": "it(\"should render text correctly when browserdisplayusedocumentfonts is set to\", async () => {\n  const { getDocument } = await import('../../src/display/api.js');\n  const { buildGetDocumentParams } = await import('./test_utils.js');\n  const loadingTask = getDocument(buildGetDocumentParams('issue20065.pdf'));\n  const pdfDocument = await loadingTask.promise;\n  const pdfPage = await pdfDocument.getPage(1);\n  const viewport = pdfPage.getViewport({ scale: 1 });\n  const canvas = document.createElement('canvas');\n  const ctx = canvas.getContext('2d');\n  canvas.width = viewport.width;\n  canvas.height = viewport.height;\n  const renderTask = pdfPage.render({\n    canvasContext: ctx,\n    viewport,\n    enableWebGL: false,\n  });\n  await renderTask.promise;\n  const pixels = ctx.getImageData(0, 0, canvas.width, canvas.height).data;\n  let hasNonTransparentPixel = false;\n  for (let i = 3; i < pixels.length; i += 4) {\n    if (pixels[i] !== 0) {\n      hasNonTransparentPixel = true;\n      break;\n    }\n  }\n  expect(hasNonTransparentPixel).toBe(true);\n});",
    "i2_gpt-4o": "it(\"should render text correctly when browserdisplayusedocumentfonts is set to\", async () => {\n  const { getDocument } = await import('../../src/display/api.js');\n  const { buildGetDocumentParams } = await import('./test_utils.js');\n  const loadingTask = getDocument(buildGetDocumentParams('issue20065.pdf'));\n  const pdfDocument = await loadingTask.promise;\n  const page = await pdfDocument.getPage(1);\n  const viewport = page.getViewport({ scale: 1.0 });\n  const canvasFactory = new (await import('../../src/display/canvas_factory.js')).DOMCanvasFactory();\n  const canvasAndContext = canvasFactory.create(viewport.width, viewport.height);\n  const renderContext = {\n    canvasContext: canvasAndContext.context,\n    viewport: viewport,\n  };\n  await page.render(renderContext).promise;\n  const imageData = canvasAndContext.context.getImageData(0, 0, viewport.width, viewport.height);\n  const hasText = Array.from(imageData.data).some(value => value !== 0);\n  expect(hasText).toBe(true);\n});",
    "i2_llama-3.3-70b-versatile": "it(\"should render text correctly when browserdisplayusedocumentfonts is set to\", async () => {\n  const { getDocument } = await import('../../src/display/api.js');\n  const { buildGetDocumentParams } = await import('./test_utils.js');\n  const loadingTask = getDocument(buildGetDocumentParams('issue20065.pdf'));\n  const pdfDocument = await loadingTask.promise;\n  const pdfPage = await pdfDocument.getPage(1);\n  const canvas = document.createElement('canvas');\n  const ctx = canvas.getContext('2d');\n  const renderTask = pdfPage.render({\n    canvasContext: ctx,\n    viewport: pdfPage.getViewport({ scale: 1 }),\n  });\n  await renderTask.promise;\n  const expectedText = 'Example Text';\n  const actualText = ctx.canvas.toDataURL();\n  const expectedTextData = new TextDecoder('utf-8').decode(expectedText);\n  const actualTextData = ctx.canvas.toDataURL().split(',')[1];\n  expect(actualTextData).toContain(expectedTextData);\n});",
    "i3_deepseek-r1-distill-llama-70b": "it(\"should render text with document fonts disabled\", async () => {\n  const { getDocument } = await import(\"../../src/display/api.js\");\n  const { buildGetDocumentParams } = await import(\"./test_utils.js\");\n  const pdf = \"issue20065.pdf\";\n  const loadingTask = getDocument(buildGetDocumentParams(pdf));\n\n  const canvas = document.createElement(\"canvas\");\n  const ctx = canvas.getContext(\"2d\");\n\n  // Mock browser.display.use_document_fonts = 0\n  globalThis.browser = {\n    display: {\n      use_document_fonts: 0,\n    },\n  };\n\n  const pdfDocument = await loadingTask.promise;\n  const pdfPage = await pdfDocument.getPage(1);\n  await pdfPage.startRendering({\n    canvasContext: ctx,\n    viewport: pdfPage.getViewport({ scale: 1 }),\n  });\n\n  const expectedCanvasData = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mNkYAAAAAYAAjCB0C8AAAAASUVORK5CYII=\";\n  const actualCanvasData = canvas.toDataURL();\n\n  expect(actualCanvasData).toBe(expectedCanvasData);\n});",
    "i3_gpt-4o": "it(\"should render text correctly when browserdisplayusedocumentfonts is set to\", async () => {\n  const { getDocument } = await import(\"../../src/display/api.js\");\n  const { buildGetDocumentParams } = await import(\"./test_utils.js\");\n  const loadingTask = getDocument(buildGetDocumentParams(\"issue20065.pdf\"));\n  const pdfDocument = await loadingTask.promise;\n  const page = await pdfDocument.getPage(1);\n  const viewport = page.getViewport({ scale: 1.0 });\n  const canvasFactory = new (await import(\"../../src/display/canvas_factory.js\")).DOMCanvasFactory();\n  const canvasAndContext = canvasFactory.create(viewport.width, viewport.height);\n  const renderTask = page.render({\n    canvasContext: canvasAndContext.context,\n    viewport,\n  });\n  await renderTask.promise;\n  const imageData = canvasAndContext.context.getImageData(0, 0, viewport.width, viewport.height);\n  const hasText = imageData.data.some((value, index) => index % 4 === 3 && value > 0);\n  expect(hasText).toBe(true);\n});",
    "i3_llama-3.3-70b-versatile": "it(\"should render text correctly when browserdisplayusedocumentfonts is set to\", async () => {\n  const { getDocument } = await import('../../src/display/api.js');\n  const { buildGetDocumentParams } = await import('./test_utils.js');\n  const loadingTask = getDocument(buildGetDocumentParams('issue20065.pdf'));\n  const pdfDocument = await loadingTask.promise;\n  const pdfPage = await pdfDocument.getPage(1);\n  const { textContent } = await pdfPage.getTextContent();\n  const expectedText = \"Some expected text from the PDF\";\n  const actualText = textContent.items.map(item => item.str).join('');\n  expect(actualText).toContain(expectedText);\n});",
    "i4_deepseek-r1-distill-llama-70b": "it(\"should render text when browserdisplayusedocumentfonts is disabled\", async () => {\n  const { getDocument } = await import(\"../../src/display/api.js\");\n  const { buildGetDocumentParams } = await import(\"./test_utils.js\");\n\n  const loadingTask = getDocument(buildGetDocumentParams('issue20065.pdf'));\n\n  const pdf = await loadingTask;\n  const page = await pdf.getPage(1);\n\n  const canvas = {\n    getContext: () => ({\n      measureText: () => ({ width: 0 }),\n      fillText: () => {},\n      strokeText: () => {},\n      getTransform: () => ({\n        a: 1,\n        b: 0,\n        c: 0,\n        d: 1,\n        e: 0,\n        f: 0\n      }),\n      setTransform: () => {},\n      save: () => {},\n      restore: () => {},\n      translate: () => {},\n      scale: () => {},\n      clip: () => {},\n      beginPath: () => {},\n      closePath: () => {},\n      lineTo: () => {},\n      moveTo: () => {},\n      addPath: () => {},\n      rect: () => {},\n      transform: () => {},\n      rotate: () => {},\n      resetTransform: () => {},\n      createLinearGradient: () => ({\n        addColorStop: () => {}\n      }),\n      createPattern: () => ({\n        setTransform: () => {}\n      })\n    })\n  };\n\n  const mockCanvas = () => canvas;\n\n  global.HTMLCanvasElement = mockCanvas;\n\n  const viewport = page.getViewport({ scale: 1 });\n\n  await page.render({\n    canvasContext: canvas.getContext('2d'),\n    viewport: viewport\n  });\n\n  const text = await page.getTextContent();\n  expect(text.items[0].str).toContain('2025');\n});",
    "i4_gpt-4o": "it(\"should render text correctly when browserdisplayusedocumentfonts is set to\", async () => {\n  const { getDocument } = await import('../../src/display/api.js');\n  const { buildGetDocumentParams } = await import('./test_utils.js');\n  const loadingTask = getDocument(buildGetDocumentParams('issue20065.pdf'));\n  const pdfDocument = await loadingTask.promise;\n  const page = await pdfDocument.getPage(1);\n  const viewport = page.getViewport({ scale: 1.0 });\n  const canvasFactory = new (await import('../../src/display/canvas_factory.js')).DOMCanvasFactory();\n  const canvasAndContext = canvasFactory.create(viewport.width, viewport.height);\n  const renderTask = page.render({\n    canvasContext: canvasAndContext.context,\n    viewport: viewport,\n  });\n  await renderTask.promise;\n  const imageData = canvasAndContext.context.getImageData(0, 0, viewport.width, viewport.height);\n  const hasVisibleText = Array.from(imageData.data).some((value, index) => index % 4 === 3 && value > 0);\n  expect(hasVisibleText).toBe(true);\n});",
    "i4_llama-3.3-70b-versatile": "it(\"should render text correctly when browserdisplayusedocumentfonts is set to\", async () => {\n  const { getDocument } = await import('../../src/display/api.js');\n  const { buildGetDocumentParams } = await import('./test_utils.js');\n  const loadingTask = getDocument(buildGetDocumentParams('issue20065.pdf'));\n  const pdfDocument = await loadingTask.promise;\n  const pdfPage = await pdfDocument.getPage(1);\n  const image = await pdfPage.render({\n    viewport: pdfPage.getViewport({ scale: 1 }),\n    canvasContext: await import('../../src/display/canvas_factory.js').then(module => module.DOMCanvasFactory),\n  });\n  const ctx = image.canvas.getContext('2d');\n  const pixels = ctx.getImageData(0, 0, image.canvas.width, image.canvas.height).data;\n  let hasNonTransparentPixel = false;\n  for (let i = 3; i < pixels.length; i += 4) {\n    if (pixels[i] !== 0) {\n      hasNonTransparentPixel = true;\n      break;\n    }\n  }\n  expect(hasNonTransparentPixel).toBe(true);\n});",
    "i5_deepseek-r1-distill-llama-70b": "it(\"should render all text when document fonts are disabled\", async () => {\n  const { getDocument } = await import('../../src/display/api.js');\n  const { buildGetDocumentParams } = await import('./test_utils.js');\n  const loadingTask = getDocument(buildGetDocumentParams('issue20065.pdf'));\n\n  const { numPages, page } = await loadingTask;\n  const page1 = await numPages.waitForPage(1);\n  const textContent = await page1.getTextContent();\n\n  const missingText = textContent.items.some(item => item.str === 'Missing');\n  expect(missingText).toBe(false);\n});",
    "i5_gpt-4o": "it(\"should render text correctly when browserdisplayusedocumentfonts is set to\", async () => {\n  const { getDocument } = await import('../../src/display/api.js');\n  const { buildGetDocumentParams } = await import('./test_utils.js');\n  const loadingTask = getDocument(buildGetDocumentParams('issue20065.pdf'));\n  const pdfDocument = await loadingTask.promise;\n  const page = await pdfDocument.getPage(1);\n  const viewport = page.getViewport({ scale: 1.0 });\n  const canvasFactory = new (await import('../../src/display/canvas_factory.js')).DOMCanvasFactory();\n  const canvasAndContext = canvasFactory.create(viewport.width, viewport.height);\n  const renderContext = {\n    canvasContext: canvasAndContext.context,\n    viewport: viewport,\n  };\n  await page.render(renderContext).promise;\n  const imageData = canvasAndContext.context.getImageData(0, 0, viewport.width, viewport.height);\n  const hasVisibleText = Array.from(imageData.data).some(value => value !== 0);\n  expect(hasVisibleText).toBe(true);\n});",
    "i5_llama-3.3-70b-versatile": "it(\"should render text correctly when browserdisplayusedocumentfonts is set to\", async () => {\n  const { getDocument } = await import('../../src/display/api.js');\n  const { buildGetDocumentParams } = await import('./test_utils.js');\n  const loadingTask = getDocument(buildGetDocumentParams('issue20065.pdf'));\n  const pdfDocument = await loadingTask.promise;\n  const pdfPage = await pdfDocument.getPage(1);\n  const canvasFactory = await import('../../src/display/canvas_factory.js');\n  const canvas = canvasFactory.DOMCanvasFactory.createCanvas(100, 100);\n  const context = canvas.getContext('2d');\n  const renderTask = pdfPage.render({\n    canvasContext: context,\n    viewport: pdfPage.getViewport({ scale: 1 }),\n  });\n  await renderTask.promise;\n  const expectedText = \"Example Text\";\n  const actualText = context.canvas.toDataURL();\n  const { PDFPageProxy } = await import('../../src/display/api.js');\n  const pageProxy = new PDFPageProxy(pdfPage);\n  const textContent = await pageProxy.getTextContent();\n  const textItems = textContent.items;\n  let text = '';\n  for (const item of textItems) {\n    text += item.str;\n  }\n  expect(text).toContain(expectedText);\n});"
  },
  "20119": {
    "i1_deepseek-r1-distill-llama-70b": "it(\"should add highlight and comment context menu entries for text selection\", async () => {\n  const { AnnotationEditorUIManager } = await import(\"../../src/display/editor/tools.js\");\n  const { DOMCanvasFactory } = await import(\"../../src/display/canvas_factory.js\");\n  const { DOMCMapReaderFactory } = await import(\"../../src/display/cmap_reader_factory.js\");\n  const { PDFDocumentProxy } = await import(\"../../src/display/api.js\");\n\n  // Setup fake PDF document and viewer\n  const pdfDocument = new PDFDocumentProxy({\n    numPages: 1,\n    get pages() {\n      return [new (class Page {})()];\n    },\n  });\n\n  const viewer = {\n    get pages() {\n      return [new (class Page {})()];\n    },\n  };\n\n  // Create UI manager with necessary dependencies\n  const uiManager = new AnnotationEditorUIManager(\n    document.createElement(\"div\"),\n    viewer,\n    document.createElement(\"div\"),\n    null,\n    null,\n    null,\n    null,\n    pdfDocument,\n    null,\n    null,\n    false,\n    false,\n    false,\n    null,\n    null,\n    null\n  );\n\n  // Simulate text selection\n  const selection = document.getSelection();\n  const range = document.createRange();\n  range.selectNodeContents(document.createElement(\"div\"));\n  selection.addRange(range);\n\n  // Trigger context menu\n  const contextMenuEvent = new Event(\"contextmenu\");\n  document.dispatchEvent(contextMenuEvent);\n\n  // Verify both highlight and comment options are present\n  const expectedMethods = [\"highlightSelection\", \"commentSelection\"];\n  const actualMethods = Object.getOwnPropertyNames(uiManager)\n    .filter(name => expectedMethods.includes(name))\n    .sort();\n\n  expect(actualMethods).toEqual(expectedMethods);\n});",
    "i1_gpt-4o": "it(\"should highlight and comment the text selection in a pdf\", async () => {\n  const { AnnotationEditorUIManager } = await import(\"../../src/display/editor/tools.js\");\n  const { PDFDocumentProxy } = await import(\"../../src/display/api.js\");\n\n  const mockCommentManager = { destroy: jest.fn() };\n  const mockUIManager = new AnnotationEditorUIManager(\n    document.createElement(\"div\"),\n    document.createElement(\"div\"),\n    document.createElement(\"div\"),\n    null,\n    mockCommentManager,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    true,\n    false,\n    false,\n    null,\n    null,\n    false\n  );\n\n  const mockSelection = {\n    isCollapsed: false,\n    toString: () => \"selected text\",\n    anchorNode: document.createElement(\"div\"),\n    anchorOffset: 0,\n    focusNode: document.createElement(\"div\"),\n    focusOffset: 12,\n    empty: jest.fn(),\n  };\n\n  document.getSelection = jest.fn().mockReturnValue(mockSelection);\n  mockUIManager.highlightSelection = jest.fn();\n  mockUIManager.commentSelection(\"context_menu\");\n\n  expect(mockUIManager.highlightSelection).toHaveBeenCalledWith(\"context_menu\", true);\n});",
    "i1_llama-3.3-70b-versatile": "it(\"should add an entry in the context menu to highlight and comment the text selection in a pdf\", async () => {\n  const { PDFDocument, PDFPageProxy } = await import(\"../../src/display/api.js\");\n  const { AnnotationEditorUIManager } = await import(\"../../src/display/editor/tools.js\");\n  const pdfDoc = await PDFDocument.load(await fetchData(\"test.pdf\"));\n  const page = await pdfDoc.getPage(1);\n  const annotationEditorUIManager = new AnnotationEditorUIManager(null, null, null, null, null, null, null, null, null, null, null, null, null);\n  const contextMenuEntriesBeforePatch = annotationEditorUIManager._eventBus._on(\"editingaction\");\n  const highlightSelectionEntryBeforePatch = contextMenuEntriesBeforePatch.find(entry => entry.name === \"highlightSelection\");\n  const commentSelectionEntryBeforePatch = contextMenuEntriesBeforePatch.find(entry => entry.name === \"commentSelection\");\n  expect(highlightSelectionEntryBeforePatch).toBeDefined();\n  expect(commentSelectionEntryBeforePatch).toBeUndefined();\n\n  // Apply the patch\n  annotationEditorUIManager.destroy();\n  annotationEditorUIManager = new AnnotationEditorUIManager(null, null, null, null, null, null, null, null, null, null, null, null, null);\n  const contextMenuEntriesAfterPatch = annotationEditorUIManager._eventBus._on(\"editingaction\");\n  const highlightSelectionEntryAfterPatch = contextMenuEntriesAfterPatch.find(entry => entry.name === \"highlightSelection\");\n  const commentSelectionEntryAfterPatch = contextMenuEntriesAfterPatch.find(entry => entry.name === \"commentSelection\");\n  expect(highlightSelectionEntryAfterPatch).toBeDefined();\n  expect(commentSelectionEntryAfterPatch).toBeDefined();\n});",
    "i2_deepseek-r1-distill-llama-70b": "it(\"should add comment selection to context menu and trigger commentSelection\", async () => {\n  const { AnnotationEditorUIManager } = await import(\"../../display/editor/tools.js\");\n  const { Util } = await import(\"../../shared/util.js\");\n\n  const eventBus = {\n    _on: jest.fn(),\n    once: jest.fn(),\n  };\n\n  const uiManager = {\n    _signal: Symbol(),\n    highlightSelection: jest.fn(),\n    commentSelection: jest.fn(),\n    delete: jest.fn(),\n    onEditingAction: jest.fn(),\n  };\n\n  const params = {\n    container: document.createElement(\"div\"),\n    viewer: {},\n    viewerAlert: {},\n    altTextManager: {},\n    commentManager: {},\n    signatureManager: {},\n    eventBus,\n    pdfDocument: {},\n    pageColors: {},\n    highlightColors: {},\n    enableHighlightFloatingButton: true,\n    enableUpdatedAddImage: false,\n    enableNewAltTextWhenAddingImage: false,\n    mlManager: null,\n    editorUndoBar: null,\n    supportsPinchToZoom: false,\n  };\n\n  const manager = new AnnotationEditorUIManager(...Object.values(params));\n\n  const editingAction = {\n    name: \"commentSelection\",\n  };\n\n  manager.onEditingAction(editingAction);\n\n  expect(uiManager.commentSelection).toHaveBeenCalled();\n});",
    "i2_gpt-4o": "it(\"should highlight and comment the text selection in a PDF\", async () => {\n  const { AnnotationEditorUIManager } = await import(\"../../src/display/editor/tools.js\");\n  const { FloatingToolbar } = await import(\"../../src/display/editor/toolbar.js\");\n\n  const mockUIManager = {\n    _signal: new AbortController().signal,\n    highlightSelection: jest.fn(),\n    commentSelection: jest.fn(),\n    hasCommentManager: () => true,\n  };\n\n  const floatingToolbar = new FloatingToolbar(mockUIManager);\n  const toolbarElement = floatingToolbar.show(document.createElement(\"div\"), [], true);\n\n  const highlightButton = toolbarElement.querySelector(\".highlightButton\");\n  const commentButton = toolbarElement.querySelector(\".commentButton\");\n\n  highlightButton.click();\n  commentButton.click();\n\n  expect(mockUIManager.highlightSelection).toHaveBeenCalledWith(\"floating_button\");\n  expect(mockUIManager.commentSelection).toHaveBeenCalledWith(\"floating_button\");\n});",
    "i2_llama-3.3-70b-versatile": "it(\"should add a comment button to the floating toolbar\", async () => {\n  const { AnnotationEditorUIManager, HighlightToolbar } = await import(\"./toolbar.js\");\n  const { AnnotationEditorUIManager: UIManager } = await import(\"./tools.js\");\n  const uiManager = new UIManager();\n  const highlightToolbar = new HighlightToolbar(uiManager);\n  const editToolbar = highlightToolbar.render();\n  const buttons = editToolbar.querySelector(\".buttons\");\n  const commentButton = buttons.querySelector(\"[data-l10n-id='pdfjs-comment-floating-button-label']\");\n  expect(commentButton).not.toBeNull();\n});",
    "i3_deepseek-r1-distill-llama-70b": "it(\"should add comment when using context menu on text selection\", async () => {\n  const { AnnotationEditorUIManager } = await import(\"../../src/display/editor/tools.js\");\n  const { TextLayer } = await import(\"../../src/display/text_layer.js\");\n  const { createIdFactory } = await import(\"../../src/core/core_utils.js\");\n\n  const idFactory = createIdFactory();\n  const textLayer = {\n    closest: () => ({\n      getBoundingClientRect: () => ({ x: 0, y: 0, width: 100, height: 100 })\n    }),\n    getAttribute: () => \"ltr\"\n  };\n\n  const mockCommentManager = {\n    commentSelection: jest.fn(),\n    hasCommentManager: () => true\n  };\n\n  const uiManager = new AnnotationEditorUIManager(\n    document.createElement(\"div\"),\n    document.createElement(\"div\"),\n    document.createElement(\"div\"),\n    null,\n    mockCommentManager,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null\n  );\n\n  const event = new Event(\"contextmenu\");\n  const selection = {\n    toString: () => \"test selection\",\n    getRangeAt: () => ({\n      getClientRects: () => [{ x: 0, y: 0, width: 100, height: 100 }]\n    })\n  };\n\n  document.getSelection = () => selection;\n\n  uiManager.onEditingAction({ name: \"commentSelection\" });\n\n  expect(mockCommentManager.commentSelection).toHaveBeenCalled();\n});",
    "i3_gpt-4o": "it(\"should add highlight and comment buttons to the context menu\", async () => {\n  const { AnnotationEditorUIManager } = await import(\"../../src/display/editor/tools.js\");\n  const { FloatingToolbar } = await import(\"../../src/display/editor/toolbar.js\");\n  const uiManager = new AnnotationEditorUIManager(\n    document.createElement(\"div\"),\n    document.createElement(\"div\"),\n    document.createElement(\"div\"),\n    null,\n    { open: () => {} },\n    null,\n    { _on: () => {} },\n    { annotationStorage: new Map(), filterFactory: {} },\n    null,\n    null,\n    true,\n    false,\n    false,\n    null,\n    null,\n    true\n  );\n  const toolbar = new FloatingToolbar(uiManager);\n  const toolbarDiv = toolbar.show(document.createElement(\"div\"), [{ x: 0, y: 0, width: 1, height: 1 }], true);\n  const buttons = toolbarDiv.querySelectorAll(\"button\");\n  const buttonClasses = Array.from(buttons).map(button => button.className);\n  expect(buttonClasses).toContain(\"commentButton\");\n  expect(buttonClasses).toContain(\"highlightButton\");\n});",
    "i3_llama-3.3-70b-versatile": "it(\"should add an entry in the context menu to highlight and comment the text selection in a pdf\", async () => {\n  const { PDFDataRangeTransport, PDFWorker, build, getDocument } = await import(\"../../src/display/api.js\");\n  const { AnnotationEditorUIManager } = await import(\"../../src/display/editor/tools.js\");\n  const { noContextMenu, stopEvent } = await import(\"../display_utils.js\");\n\n  const pdfDocument = await build({\n    url: \"path/to/example.pdf\",\n  });\n\n  const annotationEditorUIManager = new AnnotationEditorUIManager(\n    document.createElement(\"div\"),\n    document.createElement(\"div\"),\n    document.createElement(\"div\"),\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n",
    "i4_deepseek-r1-distill-llama-70b": "it(\"should add highlight and comment buttons to context menu\", async () => {\n  const { AnnotationEditorUIManager } = await import(\"../../src/display/editor/tools.js\");\n  const { EditorToolbar } = await import(\"../../src/display/editor/toolbar.js\");\n\n  // Setup mock PDF document and viewer\n  const pdfDocument = { annotationStorage: {} };\n  const viewer = { alert: {} };\n\n  // Initialize UI manager\n  const uiManager = new AnnotationEditorUIManager(\n    {} as any,\n    viewer as any,\n    viewer.alert as any,\n    null,\n    null,\n    null,\n    null,\n    pdfDocument,\n    null,\n    null,\n    false,\n    false,\n    false,\n    null,\n    null,\n    false\n  );\n\n  // Simulate text selection\n  const selection = document.getSelection();\n  const range = document.createRange();\n  range.selectNode(document.createElement(\"div\"));\n  selection.removeRange(range);\n  selection.addRange(range);\n\n  // Display context menu\n  const textLayer = {} as any;\n  await uiManager.displayFloatingToolbar();\n\n  // Check for highlight and comment buttons\n  const highlightButton = document.querySelector(\"[data-l10n-id='pdfjs-highlight-floating-button1']\");\n  const commentButton = document.querySelector(\"[data-l10n-id='pdfjs-comment-floating-button']\");\n\n  expect(highlightButton).toBeTruthy();\n  expect(commentButton).toBeTruthy();\n});",
    "i4_gpt-4o": "it(\"should highlight and comment text selection in a PDF\", async () => {\n  const { AnnotationEditorUIManager } = await import(\"../../src/display/editor/tools.js\");\n  const { FloatingToolbar } = await import(\"../../src/display/editor/toolbar.js\");\n\n  const mockUIManager = {\n    highlightSelection: jest.fn(),\n    commentSelection: jest.fn(),\n    hasCommentManager: () => true,\n    _signal: new AbortController().signal,\n    direction: \"ltr\",\n  };\n\n  const floatingToolbar = new FloatingToolbar(mockUIManager);\n  const toolbarDiv = floatingToolbar.show(document.createElement(\"div\"), [{ x: 0, y: 0, width: 1, height: 1 }], true);\n\n  const highlightButton = toolbarDiv.querySelector(\".highlightButton\");\n  const commentButton = toolbarDiv.querySelector(\".commentButton\");\n\n  highlightButton.click();\n  commentButton.click();\n\n  expect(mockUIManager.highlightSelection).toHaveBeenCalledWith(\"floating_button\");\n  expect(mockUIManager.commentSelection).toHaveBeenCalledWith(\"floating_button\");\n});",
    "i4_llama-3.3-70b-versatile": "it(\"should add a comment button to the highlight toolbar\", async () => {\n  const { AnnotationEditorUIManager, HighlightToolbar } = await import(\"./tools.js\");\n  const { noContextMenu, stopEvent } = await import(\"../display_utils.js\");\n  const uiManager = new AnnotationEditorUIManager(null, null, null, null, null, null, null, null, null, null, null, null, null);\n  uiManager.hasCommentManager = () => true;\n  const toolbar = new HighlightToolbar(uiManager);\n  const buttons = toolbar.render().querySelector(\".buttons\");\n  let commentButton = null;\n  for (const button of buttons.children) {\n    if (button.classList.contains(\"commentButton\")) {\n      commentButton = button;\n    }\n  }\n  expect(commentButton).not.toBeNull();\n});",
    "i5_deepseek-r1-distill-llama-70b": "it(\"should add highlight and comment entries in context menu\", async () => {\n  const { PDFDocument } = await import(\"../../src/core/pdf_document.js\");\n  const { PDFPage } = await import(\"../../src/core/pdf_page.js\");\n  const { TextLayer } = await import(\"../../src/display/text_layer.js\");\n  const { AnnotationEditorUIManager } = await import(\"../../src/display/editor/tools.js\");\n\n  const pdf = await PDFDocument.load(await fetch(\"test.pdf\"));\n  const page = await pdf.getPage(1);\n  const textLayer = new TextLayer({\n    page,\n    viewport: page.getViewport({ scale: 1 }),\n    textSelection: true\n  });\n\n  const uiManager = new AnnotationEditorUIManager();\n  const mockHighlight = jest.fn();\n  const mockComment = jest.fn();\n\n  uiManager.highlightSelection = mockHighlight;\n  uiManager.commentSelection = mockComment;\n\n  const selection = document.getSelection();\n  selection.removeAllRanges();\n  const range = document.createRange();\n  range.selectNodeContents(textLayer.div);\n  selection.addRange(range);\n\n  const contextMenuEvent = new Event(\"contextmenu\", { bubbles: true, cancelable: true });\n  textLayer.div.dispatchEvent(contextMenuEvent);\n\n  expect(mockHighlight).toHaveBeenCalled();\n  expect(mockComment).toHaveBeenCalled();\n});",
    "i5_gpt-4o": "it(\"should highlight and comment the text selection in a pdf\", async () => {\n  const { AnnotationEditorUIManager } = await import(\"../../src/display/editor/tools.js\");\n  const { FloatingToolbar } = await import(\"../../src/display/editor/toolbar.js\");\n  const { noContextMenu } = await import(\"../../src/display/display_utils.js\");\n\n  // Initialize required variables\n  const uiManager = new AnnotationEditorUIManager();\n  const floatingToolbar = new FloatingToolbar(uiManager);\n  const selection = {\n    isCollapsed: false,\n    anchorNode: document.createElement(\"div\"),\n    anchorOffset: 0,\n    focusNode: document.createElement(\"div\"),\n    focusOffset: 1,\n  };\n  document.getSelection = () => selection;\n\n  // Define expected behavior\n  const expectedHighlight = true;\n  const expectedComment = true;\n\n  // Simulate the context menu action\n  const contextMenuEvent = new Event(\"contextmenu\");\n  const highlightButton = document.createElement(\"button\");\n  highlightButton.classList.add(\"basic\", \"highlightButton\");\n  highlightButton.addEventListener(\"contextmenu\", noContextMenu);\n  highlightButton.addEventListener(\"click\", () => {\n    uiManager.highlightSelection(\"context_menu\", true);\n  });\n  floatingToolbar.show(selection.anchorNode, [{ x: 0, y: 0, width: 100, height: 20 }], true);\n  highlightButton.dispatchEvent(contextMenuEvent);\n\n  // Generate actual behavior\n  const actualHighlight = uiManager.highlightSelection(\"context_menu\");\n  const actualComment = uiManager.commentSelection(\"context_menu\");\n\n  // Compare expected with actual\n  expect(actualHighlight).toBe(expectedHighlight);\n  expect(actualComment).toBe(expectedComment);\n});",
    "i5_llama-3.3-70b-versatile": "it(\"should add an entry in the context menu to highlight and comment the text selection in a pdf\", async () => {\n  const { PDFPageProxy, PDFDocumentProxy } = await import(\"../../src/display/api.js\");\n  const { PDFDataRangeTransport } = await import(\"../../src/display/api.js\");\n  const { AnnotationEditorUIManager } = await import(\"../../src/display/editor/tools.js\");\n  const { PDFDocumentLoadingTask } = await import(\"../../src/display/api.js\");\n\n  const pdfData = await import(\"./test_utils.js\").then(({ TEST_PDFS_PATH }) => fetch(TEST_PDFS_PATH + \"/annotation-test.pdf\").then(response => response.arrayBuffer()));\n  const pdfDocument = await PDFDocumentProxy.load({ cMapUrl: \"\", cMapPacked: true, pdfData: new Uint8Array(pdfData) });\n  const pdfPage = await pdfDocument.getPage(1);\n  const annotationEditorUIManager = new AnnotationEditorUIManager({});\n\n  const contextMenuEntriesBefore = annotationEditorUIManager.getContextMenuEntries();\n  expect(contextMenuEntriesBefore).not.toContainEqual({ id: \"highlightSelection\" });\n  expect(contextMenuEntriesBefore).not.toContainEqual({ id: \"commentSelection\" });\n\n  await import(\"../../src/display/editor/toolbar.js\");\n  await import(\"../../src/display/editor/tools.js\");\n\n  const contextMenuEntriesAfter = annotationEditorUIManager.getContextMenuEntries();\n  expect(contextMenuEntriesAfter).toContainEqual({ id: \"highlightSelection\" });\n  expect(contextMenuEntriesAfter).toContainEqual({ id: \"commentSelection\" });\n});"
  }
}