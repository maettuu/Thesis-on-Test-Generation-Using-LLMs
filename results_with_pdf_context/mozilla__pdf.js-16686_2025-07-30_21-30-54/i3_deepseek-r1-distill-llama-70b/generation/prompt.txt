Before you begin:
- Keep going until the job is completely solved — don’t stop halfway.
- If you’re unsure about the behavior, reread the provided patch carefully; do not hallucinate.
- Plan your approach before writing code by reflecting on whether the test truly fails before and passes after.

Issue:
<issue>
Cannot add a SVG image with a blob url
</issue>

Patch:
<patch>
diff --git a/src/display/editor/tools.js b/src/display/editor/tools.js
--- a/src/display/editor/tools.js
+++ b/src/display/editor/tools.js
@@ -110,25 +110,20 @@ class ImageManager {
         // Unfortunately, createImageBitmap doesn't work with SVG images.
         // (see https://bugzilla.mozilla.org/1841972).
         const fileReader = new FileReader();
-        const dataUrlPromise = new Promise(resolve => {
-          fileReader.onload = () => {
-            data.svgUrl = fileReader.result;
-            resolve();
-          };
-        });
-        fileReader.readAsDataURL(image);
-        const url = URL.createObjectURL(image);
-        image = new Image();
-        const imagePromise = new Promise(resolve => {
-          image.onload = () => {
-            URL.revokeObjectURL(url);
-            data.bitmap = image;
+        const imageElement = new Image();
+        const imagePromise = new Promise((resolve, reject) => {
+          imageElement.onload = () => {
+            data.bitmap = imageElement;
             data.isSvg = true;
             resolve();
           };
+          fileReader.onload = () => {
+            imageElement.src = data.svgUrl = fileReader.result;
+          };
+          imageElement.onerror = fileReader.onerror = reject;
         });
-        image.src = url;
-        await Promise.all([imagePromise, dataUrlPromise]);
+        fileReader.readAsDataURL(image);
+        await imagePromise;
       } else {
         data.bitmap = await createImageBitmap(image);
       }


</patch>

Imports:
<imports>
Available Packages
Dev Dependencies:
- @babel/core: ^7.22.5
- @babel/plugin-transform-modules-commonjs: ^7.22.5
- @babel/preset-env: ^7.22.5
- @babel/runtime: ^7.22.5
- @javascript-obfuscator/escodegen: 2.3.0
- acorn: ^8.9.0
- autoprefixer: ^10.4.14
- babel-loader: ^9.1.2
- caniuse-lite: ^1.0.30001507
- canvas: ^2.11.2
- core-js: ^3.31.0
- cross-env: ^7.0.3
- es-module-shims: 1.4.7
- eslint: ^8.43.0
- eslint-config-prettier: ^8.8.0
- eslint-plugin-fetch-options: ^0.0.5
- eslint-plugin-html: ^7.1.0
- eslint-plugin-import: ^2.27.5
- eslint-plugin-json: ^3.1.0
- eslint-plugin-mozilla: ^3.1.0
- eslint-plugin-no-unsanitized: ^4.0.2
- eslint-plugin-prettier: ^4.2.1
- eslint-plugin-sort-exports: ^0.8.0
- eslint-plugin-unicorn: ^47.0.0
- globals: ^13.20.0
- gulp: ^4.0.2
- gulp-postcss: ^9.0.1
- gulp-rename: ^2.0.0
- gulp-replace: ^1.1.4
- gulp-zip: ^5.1.0
- jasmine: ^5.0.2
- jsdoc: ^4.0.2
- jstransformer-markdown-it: ^3.0.0
- merge-stream: ^2.0.0
- mkdirp: ^3.0.1
- needle: ^3.2.0
- path2d-polyfill: ^2.0.1
- pngjs: ^7.0.0
- postcss: ^8.4.24
- postcss-dir-pseudo-class: ^7.0.2
- prettier: ^2.8.8
- puppeteer: ^20.7.3
- rimraf: ^3.0.2
- streamqueue: ^1.1.2
- stylelint: ^15.9.0
- stylelint-prettier: ^3.0.0
- terser: ^5.18.1
- through2: ^4.0.2
- ttest: ^4.0.0
- typescript: ^5.1.3
- typogr: ^0.6.8
- vinyl: ^3.0.0
- vinyl-fs: ^3.0.3
- webpack: ^5.88.0
- webpack-stream: ^7.0.0
- wintersmith: ^2.5.0
- yargs: ^17.7.2

Engines:
- node: >=18

Available Relative Imports:
- `../../src/core/annotation.js`: Annotation, AnnotationBorderStyle, AnnotationFactory, MarkupAnnotation, getQuadPoints
- `../../src/core/bidi.js`: bidi
- `../../src/core/cff_parser.js`: CFFCharset, CFFCompiler, CFFFDSelect, CFFParser, CFFStrings
- `../../src/core/cmap.js`: CMap, CMapFactory, IdentityCMap
- `../../src/core/colorspace.js`: ColorSpace
- `../../src/core/core_utils.js`: arrayBuffersToBytes, encodeToXmlString, escapePDFName, escapeString, getInheritableProperty, isAscii, isWhiteSpace, log2, numberToString, parseXFAPath, recoverJsURL, stringToUTF16HexString, stringToUTF16String, toRomanNumerals, validateCSSFont
- `../../src/core/crypto.js`: AES128Cipher, AES256Cipher, ARCFourCipher, CipherTransformFactory, PDF17, PDF20, calculateMD5, calculateSHA256, calculateSHA384, calculateSHA512
- `../../src/core/default_appearance.js`: createDefaultAppearance, parseAppearanceStream, parseDefaultAppearance
- `../../src/core/document.js`: PDFDocument, Page
- `../../src/core/encodings.js`: getEncoding
- `../../src/core/evaluator.js`: PartialEvaluator
- `../../src/core/font_substitutions.js`: getFontSubstitution
- `../../src/core/fonts_utils.js`: SEAC_ANALYSIS_ENABLED
- `../../src/core/function.js`: PDFFunctionFactory, PostScriptCompiler, PostScriptEvaluator
- `../../src/core/glyphlist.js`: getDingbatsGlyphsUnicode, getGlyphsUnicode
- `../../src/core/image_utils.js`: GlobalImageCache, LocalColorSpaceCache
- `../../src/core/jbig2.js`: Jbig2Image
- `../../src/core/jpg.js`: JpegImage
- `../../src/core/jpx.js`: JpxImage
- `../../src/core/metadata_parser.js`: MetadataParser
- `../../src/core/operator_list.js`: OperatorList
- `../../src/core/parser.js`: Lexer, Linearization, Parser
- `../../src/core/predictor_stream.js`: PredictorStream
- `../../src/core/primitives.js`: Cmd, Dict, EOF, Name, Ref, RefSet, RefSetCache, isCmd, isDict, isName, isRefsEqual
- `../../src/core/ps_parser.js`: PostScriptLexer, PostScriptParser
- `../../src/core/stream.js`: NullStream, Stream, StringStream
- `../../src/core/type1_parser.js`: Type1Parser
- `../../src/core/unicode.js`: getCharUnicodeCategory, getUnicodeForGlyph, getUnicodeRangeFor, mapSpecialUnicodeValues
- `../../src/core/worker.js`: WorkerMessageHandler, WorkerTask
- `../../src/core/writer.js`: incrementalUpdate, writeDict
- `../../src/core/xfa/bind.js`: Binder
- `../../src/core/xfa/data.js`: DataHandler
- `../../src/core/xfa/factory.js`: XFAFactory
- `../../src/core/xfa/formcalc_lexer.js`: Lexer, TOKEN, Token
- `../../src/core/xfa/formcalc_parser.js`: Errors, Parser
- `../../src/core/xfa/parser.js`: XFAParser
- `../../src/core/xfa/som.js`: searchNode
- `../../src/core/xfa/symbol_utils.js`: $dump, $getChildren, $getChildrenByClass, $getChildrenByName, $text, $uid
- `../../src/core/xml_parser.js`: SimpleXMLParser, XMLParserBase
- `../../src/display/annotation_layer.js`: AnnotationLayer
- `../../src/display/annotation_storage.js`: AnnotationStorage
- `../../src/display/api.js`: DefaultCMapReaderFactory, DefaultCanvasFactory, DefaultStandardFontDataFactory, LoopbackPort, PDFDataRangeTransport, PDFDocumentLoadingTask, PDFDocumentProxy, PDFPageProxy, PDFWorker, PDFWorkerUtil, RenderTask, build, getDocument, version
- `../../src/display/display_utils.js`: DOMCanvasFactory, DOMSVGFactory, PDFDateString, PageViewport, PixelsPerInch, RenderingCancelledException, StatTimer, getFilenameFromUrl, getPdfFilenameFromUrl, getXfaPageViewport, isDataScheme, isPdfFile, isValidFetchUrl, loadScript, setLayerDimensions
- `../../src/display/editor/annotation_editor_layer.js`: AnnotationEditorLayer
- `../../src/display/editor/tools.js`: AnnotationEditorUIManager, CommandManager
- `../../src/display/fetch_stream.js`: PDFFetchStream
- `../../src/display/metadata.js`: Metadata
- `../../src/display/network.js`: PDFNetworkStream
- `../../src/display/network_utils.js`: createResponseStatusError, extractFilenameFromHeader, validateRangeRequestCapabilities, validateResponseStatus
- `../../src/display/node_stream.js`: PDFNodeStream
- `../../src/display/svg.js`: SVGGraphics
- `../../src/display/text_layer.js`: TextLayerRenderTask, renderTextLayer, updateTextLayer
- `../../src/display/worker_options.js`: GlobalWorkerOptions
- `../../src/display/xfa_layer.js`: XfaLayer
- `../../src/shared/is_node.js`: isNodeJS
- `../../src/shared/message_handler.js`: MessageHandler
- `../../src/shared/murmurhash3.js`: MurmurHash3_64
- `../../src/shared/util.js`: AbortException, AnnotationBorderStyleType, AnnotationEditorParamsType, AnnotationEditorType, AnnotationFieldFlag, AnnotationFlag, AnnotationMode, AnnotationType, CMapCompressionType, FeatureTest, FormatError, ImageKind, InvalidPDFException, MissingPDFException, OPS, PasswordException, PasswordResponses, PermissionFlag, PromiseCapability, RenderingIntentFlag, UnexpectedResponseException, UnknownErrorException, Util, VerbosityLevel, bytesToString, createValidAbsoluteUrl, getModificationDate, getVerbosityLevel, isArrayBuffer, normalizeUnicode, objectSize, setVerbosityLevel, shadow, string32, stringToBytes, stringToPDFString, stringToUTF8String
- `../../web/annotation_layer_builder.js`: AnnotationLayerBuilder
- `../../web/download_manager.js`: DownloadManager
- `../../web/event_utils.js`: EventBus, WaitOnType, waitOnEventOrTimeout
- `../../web/genericl10n.js`: GenericL10n
- `../../web/l10n_utils.js`: NullL10n
- `../../web/pdf_find_controller.js`: FindState, PDFFindController
- `../../web/pdf_find_utils.js`: CharacterType, getCharacterType
- `../../web/pdf_history.js`: PDFHistory, isDestArraysEqual, isDestHashesEqual
- `../../web/pdf_link_service.js`: LinkTarget, PDFLinkService, SimpleLinkService
- `../../web/pdf_page_view.js`: PDFPageView
- `../../web/pdf_scripting_manager.js`: PDFScriptingManager
- `../../web/pdf_single_page_viewer.js`: PDFSinglePageViewer
- `../../web/pdf_viewer.js`: PDFPageViewBuffer, PDFViewer
- `../../web/struct_tree_layer_builder.js`: StructTreeLayerBuilder
- `../../web/text_layer_builder.js`: TextLayerBuilder
- `../../web/ui_utils.js`: AutoPrintRegExp, ProgressBar, RenderingStates, ScrollMode, SpreadMode, backtrackBeforeAllVisibleElements, binarySearchFirstItem, getPageSizeInches, getVisibleElements, isPortraitOrientation, isValidRotation, parseQueryString, removeNullCharacters
- `../../web/xfa_layer_builder.js`: XfaLayerBuilder
- `./test_utils.js`: CMAP_URL, DefaultFileReaderFactory, STANDARD_FONT_DATA_URL, TEST_PDFS_PATH, XRefMock, buildGetDocumentParams, createIdFactory
- `./testreporter.js`: TestReporter
</imports>

Code:
<code>
File:
src/display/editor/tools.js
1 /* Copyright 2022 Mozilla Foundation
2  *
3  * Licensed under the Apache License, Version 2.0 (the "License");
4  * you may not use this file except in compliance with the License.
5  * You may obtain a copy of the License at
6  *
7  *     http://www.apache.org/licenses/LICENSE-2.0
8  *
9  * Unless required by applicable law or agreed to in writing, software
10  * distributed under the License is distributed on an "AS IS" BASIS,
11  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
12  * See the License for the specific language governing permissions and
13  * limitations under the License.
14  */
15 
16 /** @typedef {import("./editor.js").AnnotationEditor} AnnotationEditor */
17 // eslint-disable-next-line max-len
18 /** @typedef {import("./annotation_editor_layer.js").AnnotationEditorLayer} AnnotationEditorLayer */
19 
20 import {
21   AnnotationEditorPrefix,
22   AnnotationEditorType,
23   FeatureTest,
24   getUuid,
25   shadow,
26   Util,
27   warn,
28 } from "../../shared/util.js";
29 import { getColorValues, getRGB, PixelsPerInch } from "../display_utils.js";
30 
31 function bindEvents(obj, element, names) {
32   for (const name of names) {
33     element.addEventListener(name, obj[name].bind(obj));
34   }
35 }
36 
37 /**
38  * Convert a number between 0 and 100 into an hex number between 0 and 255.
39  * @param {number} opacity
40  * @return {string}
41  */
42 function opacityToHex(opacity) {
43   return Math.round(Math.min(255, Math.max(1, 255 * opacity)))
44     .toString(16)
45     .padStart(2, "0");
46 }
47 
48 /**
49  * Class to create some unique ids for the different editors.
50  */
51 class IdManager {
52   #id = 0;
53 
54   /**
55    * Get a unique id.
56    * @returns {string}
57    */
58   getId() {
59     return `${AnnotationEditorPrefix}${this.#id++}`;
60   }
61 }
62 
63 /**
64  * Class to manage the images used by the editors.
65  * The main idea is to try to minimize the memory used by the images.
66  * The images are cached and reused when possible
67  * We use a refCounter to know when an image is not used anymore but we need to
68  * be able to restore an image after a remove+undo, so we keep a file reference
69  * or an url one.
70  */
71 class ImageManager {
72   #baseId = getUuid();
73 
74   #id = 0;
75 
76   #cache = null;
77 
78   async #get(key, rawData) {
79     this.#cache ||= new Map();
80     let data = this.#cache.get(key);
81     if (data === null) {
82       // We already tried to load the image but it failed.
83       return null;
84     }
85     if (data?.bitmap) {
86       data.refCounter += 1;
87       return data;
88     }
89     try {
90       data ||= {
91         bitmap: null,
92         id: `image_${this.#baseId}_${this.#id++}`,
93         refCounter: 0,
94         isSvg: false,
95       };
96       let image;
97       if (typeof rawData === "string") {
98         data.url = rawData;
99 
100         const response = await fetch(rawData);
101         if (!response.ok) {
102           throw new Error(response.statusText);
103         }
104         image = await response.blob();
105       } else {
106         image = data.file = rawData;
107       }
108 
109       if (image.type === "image/svg+xml") {
110         // Unfortunately, createImageBitmap doesn't work with SVG images.
111         // (see https://bugzilla.mozilla.org/1841972).
112         const fileReader = new FileReader();
113         const dataUrlPromise = new Promise(resolve => {
114           fileReader.onload = () => {
115             data.svgUrl = fileReader.result;
116             resolve();
117           };
118         });
119         fileReader.readAsDataURL(image);
120         const url = URL.createObjectURL(image);
121         image = new Image();
122         const imagePromise = new Promise(resolve => {
123           image.onload = () => {
124             URL.revokeObjectURL(url);
125             data.bitmap = image;
126             data.isSvg = true;
127             resolve();
128           };
129         });
130         image.src = url;
131         await Promise.all([imagePromise, dataUrlPromise]);
132       } else {
133         data.bitmap = await createImageBitmap(image);
134       }
135       data.refCounter = 1;
136     } catch (e) {
137       console.error(e);
138       data = null;
139     }
140     this.#cache.set(key, data);
141     if (data) {
142       this.#cache.set(data.id, data);
143     }
144     return data;
145   }
146 
147   async getFromFile(file) {
148     const { lastModified, name, size, type } = file;
149     return this.#get(`${lastModified}_${name}_${size}_${type}`, file);
150   }
151 
152   async getFromUrl(url) {
153     return this.#get(url, url);
154   }
155 
156   async getFromId(id) {
157     this.#cache ||= new Map();
158     const data = this.#cache.get(id);
159     if (!data) {
160       return null;
161     }
162     if (data.bitmap) {
163       data.refCounter += 1;
164       return data;
165     }
166 
167     if (data.file) {
168       return this.getFromFile(data.file);
169     }
170     return this.getFromUrl(data.url);
171   }
172 
173   getSvgUrl(id) {
174     const data = this.#cache.get(id);
175     if (!data?.isSvg) {
176       return null;
177     }
178     return data.svgUrl;
179   }
180 
181   deleteId(id) {
182     this.#cache ||= new Map();
183     const data = this.#cache.get(id);
184     if (!data) {
185       return;
186     }
187     data.refCounter -= 1;
188     if (data.refCounter !== 0) {
189       return;
190     }
191     data.bitmap = null;
192   }
193 
194   // We can use the id only if it belongs this manager.
195   // We must take care of having the right manager because we can copy/paste
196   // some images from other documents, hence it'd be a pity to use an id from an
197   // other manager.
198   isValidId(id) {
199     return id.startsWith(`image_${this.#baseId}_`);
200   }
201 }
202 
203 /**
204  * Class to handle undo/redo.
205  * Commands are just saved in a buffer.
206  * If we hit some memory issues we could likely use a circular buffer.
207  * It has to be used as a singleton.
208  */
209 class CommandManager {
210   #commands = [];
211 
212   #locked = false;
213 
214   #maxSize;
215 
216   #position = -1;
217 
218   constructor(maxSize = 128) {
219     this.#maxSize = maxSize;
220   }
221 
222   /**
223    * @typedef {Object} addOptions
224    * @property {function} cmd
225    * @property {function} undo
226    * @property {boolean} mustExec
227    * @property {number} type
228    * @property {boolean} overwriteIfSameType
229    * @property {boolean} keepUndo
230    */
231 
232   /**
233    * Add a new couple of commands to be used in case of redo/undo.
234    * @param {addOptions} options
235    */
236   add({
237     cmd,
238     undo,
239     mustExec,
240     type = NaN,
241     overwriteIfSameType = false,
242     keepUndo = false,
243   }) {
244     if (mustExec) {
245       cmd();
246     }
247 
248     if (this.#locked) {
249       return;
250     }
251 
252     const save = { cmd, undo, type };
253     if (this.#position === -1) {
254       if (this.#commands.length > 0) {
255         // All the commands have been undone and then a new one is added
256         // hence we clear the queue.
257         this.#commands.length = 0;
258       }
259       this.#position = 0;
260       this.#commands.push(save);
261       return;
262     }
263 
264     if (overwriteIfSameType && this.#commands[this.#position].type === type) {
265       // For example when we change a color we don't want to
266       // be able to undo all the steps, hence we only want to
267       // keep the last undoable action in this sequence of actions.
268       if (keepUndo) {
269         save.undo = this.#commands[this.#position].undo;
270       }
271       this.#commands[this.#position] = save;
272       return;
273     }
274 
275     const next = this.#position + 1;
276     if (next === this.#maxSize) {
277       this.#commands.splice(0, 1);
278     } else {
279       this.#position = next;
280       if (next < this.#commands.length) {
281         this.#commands.splice(next);
282       }
283     }
284 
285     this.#commands.push(save);
286   }
287 
288   /**
289    * Undo the last command.
290    */
291   undo() {
292     if (this.#position === -1) {
293       // Nothing to undo.
294       return;
295     }
296 
297     // Avoid to insert something during the undo execution.
298     this.#locked = true;
299     this.#commands[this.#position].undo();
300     this.#locked = false;
301 
302     this.#position -= 1;
303   }
304 
305   /**
306    * Redo the last command.
307    */
308   redo() {
309     if (this.#position < this.#commands.length - 1) {
310       this.#position += 1;
311 
312       // Avoid to insert something during the redo execution.
313       this.#locked = true;
314       this.#commands[this.#position].cmd();
315       this.#locked = false;
316     }
317   }
318 
319   /**
320    * Check if there is something to undo.
321    * @returns {boolean}
322    */
323   hasSomethingToUndo() {
324     return this.#position !== -1;
325   }
326 
327   /**
328    * Check if there is something to redo.
329    * @returns {boolean}
330    */
331   hasSomethingToRedo() {
332     return this.#position < this.#commands.length - 1;
333   }
334 
335   destroy() {
336     this.#commands = null;
337   }
338 }
339 
340 /**
341  * Class to handle the different keyboards shortcuts we can have on mac or
342  * non-mac OSes.
343  */
344 class KeyboardManager {
345   /**
346    * Create a new keyboard manager class.
347    * @param {Array<Array>} callbacks - an array containing an array of shortcuts
348    * and a callback to call.
349    * A shortcut is a string like `ctrl+c` or `mac+ctrl+c` for mac OS.
350    */
351   constructor(callbacks) {
352     this.buffer = [];
353     this.callbacks = new Map();
354     this.allKeys = new Set();
355 
356     const { isMac } = FeatureTest.platform;
357     for (const [keys, callback, bubbles = false] of callbacks) {
358       for (const key of keys) {
359         const isMacKey = key.startsWith("mac+");
360         if (isMac && isMacKey) {
361           this.callbacks.set(key.slice(4), { callback, bubbles });
362           this.allKeys.add(key.split("+").at(-1));
363         } else if (!isMac && !isMacKey) {
364           this.callbacks.set(key, { callback, bubbles });
365           this.allKeys.add(key.split("+").at(-1));
366         }
367       }
368     }
369   }
370 
371   /**
372    * Serialize an event into a string in order to match a
373    * potential key for a callback.
374    * @param {KeyboardEvent} event
375    * @returns {string}
376    */
377   #serialize(event) {
378     if (event.altKey) {
379       this.buffer.push("alt");
380     }
381     if (event.ctrlKey) {
382       this.buffer.push("ctrl");
383     }
384     if (event.metaKey) {
385       this.buffer.push("meta");
386     }
387     if (event.shiftKey) {
388       this.buffer.push("shift");
389     }
390     this.buffer.push(event.key);
391     const str = this.buffer.join("+");
392     this.buffer.length = 0;
393 
394     return str;
395   }
396 
397   /**
398    * Execute a callback, if any, for a given keyboard event.
399    * The self is used as `this` in the callback.
400    * @param {Object} self.
401    * @param {KeyboardEvent} event
402    * @returns
403    */
404   exec(self, event) {
405     if (!this.allKeys.has(event.key)) {
406       return;
407     }
408     const info = this.callbacks.get(this.#serialize(event));
409     if (!info) {
410       return;
411     }
412     const { callback, bubbles } = info;
413     callback.bind(self)();
414 
415     // For example, ctrl+s in a FreeText must be handled by the viewer, hence
416     // the event must bubble.
417     if (!bubbles) {
418       event.stopPropagation();
419       event.preventDefault();
420     }
421   }
422 }
423 
424 class ColorManager {
425   static _colorsMapping = new Map([
426     ["CanvasText", [0, 0, 0]],
427     ["Canvas", [255, 255, 255]],
428   ]);
429 
430   get _colors() {
431     if (
432       typeof PDFJSDev !== "undefined" &&
433       PDFJSDev.test("LIB") &&
434       typeof document === "undefined"
435     ) {
436       return shadow(this, "_colors", ColorManager._colorsMapping);
437     }
438 
439     const colors = new Map([
440       ["CanvasText", null],
441       ["Canvas", null],
442     ]);
443     getColorValues(colors);
444     return shadow(this, "_colors", colors);
445   }
446 
447   /**
448    * In High Contrast Mode, the color on the screen is not always the
449    * real color used in the pdf.
450    * For example in some cases white can appear to be black but when saving
451    * we want to have white.
452    * @param {string} color
453    * @returns {Array<number>}
454    */
455   convert(color) {
456     const rgb = getRGB(color);
457     if (!window.matchMedia("(forced-colors: active)").matches) {
458       return rgb;
459     }
460 
461     for (const [name, RGB] of this._colors) {
462       if (RGB.every((x, i) => x === rgb[i])) {
463         return ColorManager._colorsMapping.get(name);
464       }
465     }
466     return rgb;
467   }
468 
469   /**
470    * An input element must have its color value as a hex string
471    * and not as color name.
472    * So this function converts a name into an hex string.
473    * @param {string} name
474    * @returns {string}
475    */
476   getHexCode(name) {
477     const rgb = this._colors.get(name);
478     if (!rgb) {
479       return name;
480     }
481     return Util.makeHexColor(...rgb);
482   }
483 }
484 
485 /**
486  * A pdf has several pages and each of them when it will rendered
487  * will have an AnnotationEditorLayer which will contain the some
488  * new Annotations associated to an editor in order to modify them.
489  *
490  * This class is used to manage all the different layers, editors and
491  * some action like copy/paste, undo/redo, ...
492  */
493 class AnnotationEditorUIManager {
494   #activeEditor = null;
495 
496   #allEditors = new Map();
497 
498   #allLayers = new Map();
499 
500   #annotationStorage = null;
501 
502   #commandManager = new CommandManager();
503 
504   #currentPageIndex = 0;
505 
506   #deletedAnnotationsElementIds = new Set();
507 
508   #editorTypes = null;
509 
510   #editorsToRescale = new Set();
511 
512   #eventBus = null;
513 
514   #filterFactory = null;
515 
516   #idManager = new IdManager();
517 
518   #isEnabled = false;
519 
520   #mode = AnnotationEditorType.NONE;
521 
522   #selectedEditors = new Set();
523 
524   #pageColors = null;
525 
526   #boundCopy = this.copy.bind(this);
527 
528   #boundCut = this.cut.bind(this);
529 
530   #boundPaste = this.paste.bind(this);
531 
532   #boundKeydown = this.keydown.bind(this);
533 
534   #boundOnEditingAction = this.onEditingAction.bind(this);
535 
536   #boundOnPageChanging = this.onPageChanging.bind(this);
537 
538   #boundOnScaleChanging = this.onScaleChanging.bind(this);
539 
540   #boundOnRotationChanging = this.onRotationChanging.bind(this);
541 
542   #previousStates = {
543     isEditing: false,
544     isEmpty: true,
545     hasSomethingToUndo: false,
546     hasSomethingToRedo: false,
547     hasSelectedEditor: false,
548   };
549 
550   #container = null;
551 
552   static get _keyboardManager() {
553     return shadow(
554       this,
555       "_keyboardManager",
556       new KeyboardManager([
557         [
558           ["ctrl+a", "mac+meta+a"],
559           AnnotationEditorUIManager.prototype.selectAll,
560         ],
561         [["ctrl+z", "mac+meta+z"], AnnotationEditorUIManager.prototype.undo],
562         [
563           ["ctrl+y", "ctrl+shift+Z", "mac+meta+shift+Z"],
564           AnnotationEditorUIManager.prototype.redo,
565         ],
566         [
567           [
568             "Backspace",
569             "alt+Backspace",
570             "ctrl+Backspace",
571             "shift+Backspace",
572             "mac+Backspace",
573             "mac+alt+Backspace",
574             "mac+ctrl+Backspace",
575             "Delete",
576             "ctrl+Delete",
577             "shift+Delete",
578           ],
579           AnnotationEditorUIManager.prototype.delete,
580         ],
581         [
582           ["Escape", "mac+Escape"],
583           AnnotationEditorUIManager.prototype.unselectAll,
584         ],
585       ])
586     );
587   }
588 
589   constructor(container, eventBus, pdfDocument, pageColors) {
590     this.#container = container;
591     this.#eventBus = eventBus;
592     this.#eventBus._on("editingaction", this.#boundOnEditingAction);
593     this.#eventBus._on("pagechanging", this.#boundOnPageChanging);
594     this.#eventBus._on("scalechanging", this.#boundOnScaleChanging);
595     this.#eventBus._on("rotationchanging", this.#boundOnRotationChanging);
596     this.#annotationStorage = pdfDocument.annotationStorage;
597     this.#filterFactory = pdfDocument.filterFactory;
598     this.#pageColors = pageColors;
599     this.viewParameters = {
600       realScale: PixelsPerInch.PDF_TO_CSS_UNITS,
601       rotation: 0,
602     };
603   }
604 
605   destroy() {
606     this.#removeKeyboardManager();
607     this.#eventBus._off("editingaction", this.#boundOnEditingAction);
608     this.#eventBus._off("pagechanging", this.#boundOnPageChanging);
609     this.#eventBus._off("scalechanging", this.#boundOnScaleChanging);
610     this.#eventBus._off("rotationchanging", this.#boundOnRotationChanging);
611     for (const layer of this.#allLayers.values()) {
612       layer.destroy();
613     }
614     this.#allLayers.clear();
615     this.#allEditors.clear();
616     this.#editorsToRescale.clear();
617     this.#activeEditor = null;
618     this.#selectedEditors.clear();
619     this.#commandManager.destroy();
620   }
621 
622   get hcmFilter() {
623     return shadow(
624       this,
625       "hcmFilter",
626       this.#pageColors
627         ? this.#filterFactory.addHCMFilter(
628             this.#pageColors.foreground,
629             this.#pageColors.background
630           )
631         : "none"
632     );
633   }
634 
635   onPageChanging({ pageNumber }) {
636     this.#currentPageIndex = pageNumber - 1;
637   }
638 
639   focusMainContainer() {
640     this.#container.focus();
641   }
642 
643   addShouldRescale(editor) {
644     this.#editorsToRescale.add(editor);
645   }
646 
647   removeShouldRescale(editor) {
648     this.#editorsToRescale.delete(editor);
649   }
650 
651   onScaleChanging({ scale }) {
652     this.commitOrRemove();
653     this.viewParameters.realScale = scale * PixelsPerInch.PDF_TO_CSS_UNITS;
654     for (const editor of this.#editorsToRescale) {
655       editor.onScaleChanging();
656     }
657   }
658 
659   onRotationChanging({ pagesRotation }) {
660     this.commitOrRemove();
661     this.viewParameters.rotation = pagesRotation;
662   }
663 
664   /**
665    * Add an editor in the annotation storage.
666    * @param {AnnotationEditor} editor
667    */
668   addToAnnotationStorage(editor) {
669     if (
670       !editor.isEmpty() &&
671       this.#annotationStorage &&
672       !this.#annotationStorage.has(editor.id)
673     ) {
674       this.#annotationStorage.setValue(editor.id, editor);
675     }
676   }
677 
678   #addKeyboardManager() {
679     // The keyboard events are caught at the container level in order to be able
680     // to execute some callbacks even if the current page doesn't have focus.
681     this.#container.addEventListener("keydown", this.#boundKeydown);
682   }
683 
684   #removeKeyboardManager() {
685     this.#container.removeEventListener("keydown", this.#boundKeydown);
686   }
687 
688   #addCopyPasteListeners() {
689     document.addEventListener("copy", this.#boundCopy);
690     document.addEventListener("cut", this.#boundCut);
691     document.addEventListener("paste", this.#boundPaste);
692   }
693 
694   #removeCopyPasteListeners() {
695     document.removeEventListener("copy", this.#boundCopy);
696     document.removeEventListener("cut", this.#boundCut);
697     document.removeEventListener("paste", this.#boundPaste);
698   }
699 
700   /**
701    * Copy callback.
702    * @param {ClipboardEvent} event
703    */
704   copy(event) {
705     event.preventDefault();
706 
707     if (this.#activeEditor) {
708       // An editor is being edited so just commit it.
709       this.#activeEditor.commitOrRemove();
710     }
711 
712     if (!this.hasSelection) {
713       return;
714     }
715 
716     const editors = [];
717     for (const editor of this.#selectedEditors) {
718       const serialized = editor.serialize(/* isForCopying = */ true);
719       if (serialized) {
720         editors.push(serialized);
721       }
722     }
723     if (editors.length === 0) {
724       return;
725     }
726 
727     event.clipboardData.setData("application/pdfjs", JSON.stringify(editors));
728   }
729 
730   /**
731    * Cut callback.
732    * @param {ClipboardEvent} event
733    */
734   cut(event) {
735     this.copy(event);
736     this.delete();
737   }
738 
739   /**
740    * Paste callback.
741    * @param {ClipboardEvent} event
742    */
743   paste(event) {
744     event.preventDefault();
745 
746     let data = event.clipboardData.getData("application/pdfjs");
747     if (!data) {
748       return;
749     }
750 
751     try {
752       data = JSON.parse(data);
753     } catch (ex) {
754       warn(`paste: "${ex.message}".`);
755       return;
756     }
757 
758     if (!Array.isArray(data)) {
759       return;
760     }
761 
762     this.unselectAll();
763     const layer = this.#allLayers.get(this.#currentPageIndex);
764 
765     try {
766       const newEditors = [];
767       for (const editor of data) {
768         const deserializedEditor = layer.deserialize(editor);
769         if (!deserializedEditor) {
770           return;
771         }
772         newEditors.push(deserializedEditor);
773       }
774 
775       const cmd = () => {
776         for (const editor of newEditors) {
777           this.#addEditorToLayer(editor);
778         }
779         this.#selectEditors(newEditors);
780       };
781       const undo = () => {
782         for (const editor of newEditors) {
783           editor.remove();
784         }
785       };
786       this.addCommands({ cmd, undo, mustExec: true });
787     } catch (ex) {
788       warn(`paste: "${ex.message}".`);
789     }
790   }
791 
792   /**
793    * Keydown callback.
794    * @param {KeyboardEvent} event
795    */
796   keydown(event) {
797     if (!this.getActive()?.shouldGetKeyboardEvents()) {
798       AnnotationEditorUIManager._keyboardManager.exec(this, event);
799     }
800   }
801 
802   /**
803    * Execute an action for a given name.
804    * For example, the user can click on the "Undo" entry in the context menu
805    * and it'll trigger the undo action.
806    * @param {Object} details
807    */
808   onEditingAction(details) {
809     if (["undo", "redo", "delete", "selectAll"].includes(details.name)) {
810       this[details.name]();
811     }
812   }
813 
814   /**
815    * Update the different possible states of this manager, e.g. is there
816    * something to undo, redo, ...
817    * @param {Object} details
818    */
819   #dispatchUpdateStates(details) {
820     const hasChanged = Object.entries(details).some(
821       ([key, value]) => this.#previousStates[key] !== value
822     );
823 
824     if (hasChanged) {
825       this.#eventBus.dispatch("annotationeditorstateschanged", {
826         source: this,
827         details: Object.assign(this.#previousStates, details),
828       });
829     }
830   }
831 
832   #dispatchUpdateUI(details) {
833     this.#eventBus.dispatch("annotationeditorparamschanged", {
834       source: this,
835       details,
836     });
837   }
838 
839   /**
840    * Set the editing state.
841    * It can be useful to temporarily disable it when the user is editing a
842    * FreeText annotation.
843    * @param {boolean} isEditing
844    */
845   setEditingState(isEditing) {
846     if (isEditing) {
847       this.#addKeyboardManager();
848       this.#addCopyPasteListeners();
849       this.#dispatchUpdateStates({
850         isEditing: this.#mode !== AnnotationEditorType.NONE,
851         isEmpty: this.#isEmpty(),
852         hasSomethingToUndo: this.#commandManager.hasSomethingToUndo(),
853         hasSomethingToRedo: this.#commandManager.hasSomethingToRedo(),
854         hasSelectedEditor: false,
855       });
856     } else {
857       this.#removeKeyboardManager();
858       this.#removeCopyPasteListeners();
859       this.#dispatchUpdateStates({
860         isEditing: false,
861       });
862     }
863   }
864 
865   registerEditorTypes(types) {
866     if (this.#editorTypes) {
867       return;
868     }
869     this.#editorTypes = types;
870     for (const editorType of this.#editorTypes) {
871       this.#dispatchUpdateUI(editorType.defaultPropertiesToUpdate);
872     }
873   }
874 
875   /**
876    * Get an id.
877    * @returns {string}
878    */
879   getId() {
880     return this.#idManager.getId();
881   }
882 
883   get currentLayer() {
884     return this.#allLayers.get(this.#currentPageIndex);
885   }
886 
887   get currentPageIndex() {
888     return this.#currentPageIndex;
889   }
890 
891   /**
892    * Add a new layer for a page which will contains the editors.
893    * @param {AnnotationEditorLayer} layer
894    */
895   addLayer(layer) {
896     this.#allLayers.set(layer.pageIndex, layer);
897     if (this.#isEnabled) {
898       layer.enable();
899     } else {
900       layer.disable();
901     }
902   }
903 
904   /**
905    * Remove a layer.
906    * @param {AnnotationEditorLayer} layer
907    */
908   removeLayer(layer) {
909     this.#allLayers.delete(layer.pageIndex);
910   }
911 
912   /**
913    * Change the editor mode (None, FreeText, Ink, ...)
914    * @param {number} mode
915    * @param {string|null} editId
916    */
917   updateMode(mode, editId = null) {
918     this.#mode = mode;
919     if (mode === AnnotationEditorType.NONE) {
920       this.setEditingState(false);
921       this.#disableAll();
922       return;
923     }
924     this.setEditingState(true);
925     this.#enableAll();
926     for (const layer of this.#allLayers.values()) {
927       layer.updateMode(mode);
928     }
929     if (!editId) {
930       return;
931     }
932     for (const editor of this.#allEditors.values()) {
933       if (editor.annotationElementId === editId) {
934         this.setSelected(editor);
935         editor.enterInEditMode();
936         break;
937       }
938     }
939   }
940 
941   /**
942    * Update the toolbar if it's required to reflect the tool currently used.
943    * @param {number} mode
944    * @returns {undefined}
945    */
946   updateToolbar(mode) {
947     if (mode === this.#mode) {
948       return;
949     }
950     this.#eventBus.dispatch("switchannotationeditormode", {
951       source: this,
952       mode,
953     });
954   }
955 
956   /**
957    * Update a parameter in the current editor or globally.
958    * @param {number} type
959    * @param {*} value
960    */
961   updateParams(type, value) {
962     if (!this.#editorTypes) {
963       return;
964     }
965 
966     for (const editor of this.#selectedEditors) {
967       editor.updateParams(type, value);
968     }
969 
970     for (const editorType of this.#editorTypes) {
971       editorType.updateDefaultParams(type, value);
972     }
973   }
974 
975   /**
976    * Enable all the layers.
977    */
978   #enableAll() {
979     if (!this.#isEnabled) {
980       this.#isEnabled = true;
981       for (const layer of this.#allLayers.values()) {
982         layer.enable();
983       }
984     }
985   }
986 
987   /**
988    * Disable all the layers.
989    */
990   #disableAll() {
991     this.unselectAll();
992     if (this.#isEnabled) {
993       this.#isEnabled = false;
994       for (const layer of this.#allLayers.values()) {
995         layer.disable();
996       }
997     }
998   }
999 
1000   /**
1001    * Get all the editors belonging to a give page.
1002    * @param {number} pageIndex
1003    * @returns {Array<AnnotationEditor>}
1004    */
1005   getEditors(pageIndex) {
1006     const editors = [];
1007     for (const editor of this.#allEditors.values()) {
1008       if (editor.pageIndex === pageIndex) {
1009         editors.push(editor);
1010       }
1011     }
1012     return editors;
1013   }
1014 
1015   /**
1016    * Get an editor with the given id.
1017    * @param {string} id
1018    * @returns {AnnotationEditor}
1019    */
1020   getEditor(id) {
1021     return this.#allEditors.get(id);
1022   }
1023 
1024   /**
1025    * Add a new editor.
1026    * @param {AnnotationEditor} editor
1027    */
1028   addEditor(editor) {
1029     this.#allEditors.set(editor.id, editor);
1030   }
1031 
1032   /**
1033    * Remove an editor.
1034    * @param {AnnotationEditor} editor
1035    */
1036   removeEditor(editor) {
1037     this.#allEditors.delete(editor.id);
1038     this.unselect(editor);
1039     if (
1040       !editor.annotationElementId ||
1041       !this.#deletedAnnotationsElementIds.has(editor.annotationElementId)
1042     ) {
1043       this.#annotationStorage?.remove(editor.id);
1044     }
1045   }
1046 
1047   /**
1048    * The annotation element with the given id has been deleted.
1049    * @param {AnnotationEditor} editor
1050    */
1051   addDeletedAnnotationElement(editor) {
1052     this.#deletedAnnotationsElementIds.add(editor.annotationElementId);
1053     editor.deleted = true;
1054   }
1055 
1056   /**
1057    * Check if the annotation element with the given id has been deleted.
1058    * @param {string} annotationElementId
1059    * @returns {boolean}
1060    */
1061   isDeletedAnnotationElement(annotationElementId) {
1062     return this.#deletedAnnotationsElementIds.has(annotationElementId);
1063   }
1064 
1065   /**
1066    * The annotation element with the given id have been restored.
1067    * @param {AnnotationEditor} editor
1068    */
1069   removeDeletedAnnotationElement(editor) {
1070     this.#deletedAnnotationsElementIds.delete(editor.annotationElementId);
1071     editor.deleted = false;
1072   }
1073 
1074   /**
1075    * Add an editor to the layer it belongs to or add it to the global map.
1076    * @param {AnnotationEditor} editor
1077    */
1078   #addEditorToLayer(editor) {
1079     const layer = this.#allLayers.get(editor.pageIndex);
1080     if (layer) {
1081       layer.addOrRebuild(editor);
1082     } else {
1083       this.addEditor(editor);
1084     }
1085   }
1086 
1087   /**
1088    * Set the given editor as the active one.
1089    * @param {AnnotationEditor} editor
1090    */
1091   setActiveEditor(editor) {
1092     if (this.#activeEditor === editor) {
1093       return;
1094     }
1095 
1096     this.#activeEditor = editor;
1097     if (editor) {
1098       this.#dispatchUpdateUI(editor.propertiesToUpdate);
1099     }
1100   }
1101 
1102   /**
1103    * Add or remove an editor the current selection.
1104    * @param {AnnotationEditor} editor
1105    */
1106   toggleSelected(editor) {
1107     if (this.#selectedEditors.has(editor)) {
1108       this.#selectedEditors.delete(editor);
1109       editor.unselect();
1110       this.#dispatchUpdateStates({
1111         hasSelectedEditor: this.hasSelection,
1112       });
1113       return;
1114     }
1115     this.#selectedEditors.add(editor);
1116     editor.select();
1117     this.#dispatchUpdateUI(editor.propertiesToUpdate);
1118     this.#dispatchUpdateStates({
1119       hasSelectedEditor: true,
1120     });
1121   }
1122 
1123   /**
1124    * Set the last selected editor.
1125    * @param {AnnotationEditor} editor
1126    */
1127   setSelected(editor) {
1128     for (const ed of this.#selectedEditors) {
1129       if (ed !== editor) {
1130         ed.unselect();
1131       }
1132     }
1133     this.#selectedEditors.clear();
1134 
1135     this.#selectedEditors.add(editor);
1136     editor.select();
1137     this.#dispatchUpdateUI(editor.propertiesToUpdate);
1138     this.#dispatchUpdateStates({
1139       hasSelectedEditor: true,
1140     });
1141   }
1142 
1143   /**
1144    * Check if the editor is selected.
1145    * @param {AnnotationEditor} editor
1146    */
1147   isSelected(editor) {
1148     return this.#selectedEditors.has(editor);
1149   }
1150 
1151   /**
1152    * Unselect an editor.
1153    * @param {AnnotationEditor} editor
1154    */
1155   unselect(editor) {
1156     editor.unselect();
1157     this.#selectedEditors.delete(editor);
1158     this.#dispatchUpdateStates({
1159       hasSelectedEditor: this.hasSelection,
1160     });
1161   }
1162 
1163   get hasSelection() {
1164     return this.#selectedEditors.size !== 0;
1165   }
1166 
1167   /**
1168    * Undo the last command.
1169    */
1170   undo() {
1171     this.#commandManager.undo();
1172     this.#dispatchUpdateStates({
1173       hasSomethingToUndo: this.#commandManager.hasSomethingToUndo(),
1174       hasSomethingToRedo: true,
1175       isEmpty: this.#isEmpty(),
1176     });
1177   }
1178 
1179   /**
1180    * Redo the last undoed command.
1181    */
1182   redo() {
1183     this.#commandManager.redo();
1184     this.#dispatchUpdateStates({
1185       hasSomethingToUndo: true,
1186       hasSomethingToRedo: this.#commandManager.hasSomethingToRedo(),
1187       isEmpty: this.#isEmpty(),
1188     });
1189   }
1190 
1191   /**
1192    * Add a command to execute (cmd) and another one to undo it.
1193    * @param {Object} params
1194    */
1195   addCommands(params) {
1196     this.#commandManager.add(params);
1197     this.#dispatchUpdateStates({
1198       hasSomethingToUndo: true,
1199       hasSomethingToRedo: false,
1200       isEmpty: this.#isEmpty(),
1201     });
1202   }
1203 
1204   #isEmpty() {
1205     if (this.#allEditors.size === 0) {
1206       return true;
1207     }
1208 
1209     if (this.#allEditors.size === 1) {
1210       for (const editor of this.#allEditors.values()) {
1211         return editor.isEmpty();
1212       }
1213     }
1214 
1215     return false;
1216   }
1217 
1218   /**
1219    * Delete the current editor or all.
1220    */
1221   delete() {
1222     this.commitOrRemove();
1223     if (!this.hasSelection) {
1224       return;
1225     }
1226 
1227     const editors = [...this.#selectedEditors];
1228     const cmd = () => {
1229       for (const editor of editors) {
1230         editor.remove();
1231       }
1232     };
1233     const undo = () => {
1234       for (const editor of editors) {
1235         this.#addEditorToLayer(editor);
1236       }
1237     };
1238 
1239     this.addCommands({ cmd, undo, mustExec: true });
1240   }
1241 
1242   commitOrRemove() {
1243     // An editor is being edited so just commit it.
1244     this.#activeEditor?.commitOrRemove();
1245   }
1246 
1247   /**
1248    * Select the editors.
1249    * @param {Array<AnnotationEditor>} editors
1250    */
1251   #selectEditors(editors) {
1252     this.#selectedEditors.clear();
1253     for (const editor of editors) {
1254       if (editor.isEmpty()) {
1255         continue;
1256       }
1257       this.#selectedEditors.add(editor);
1258       editor.select();
1259     }
1260     this.#dispatchUpdateStates({ hasSelectedEditor: true });
1261   }
1262 
1263   /**
1264    * Select all the editors.
1265    */
1266   selectAll() {
1267     for (const editor of this.#selectedEditors) {
1268       editor.commit();
1269     }
1270     this.#selectEditors(this.#allEditors.values());
1271   }
1272 
1273   /**
1274    * Unselect all the selected editors.
1275    */
1276   unselectAll() {
1277     if (this.#activeEditor) {
1278       // An editor is being edited so just commit it.
1279       this.#activeEditor.commitOrRemove();
1280       return;
1281     }
1282 
1283     if (this.#selectedEditors.size === 0) {
1284       return;
1285     }
1286     for (const editor of this.#selectedEditors) {
1287       editor.unselect();
1288     }
1289     this.#selectedEditors.clear();
1290     this.#dispatchUpdateStates({
1291       hasSelectedEditor: false,
1292     });
1293   }
1294 
1295   /**
1296    * Is the current editor the one passed as argument?
1297    * @param {AnnotationEditor} editor
1298    * @returns
1299    */
1300   isActive(editor) {
1301     return this.#activeEditor === editor;
1302   }
1303 
1304   /**
1305    * Get the current active editor.
1306    * @returns {AnnotationEditor|null}
1307    */
1308   getActive() {
1309     return this.#activeEditor;
1310   }
1311 
1312   /**
1313    * Get the current editor mode.
1314    * @returns {number}
1315    */
1316   getMode() {
1317     return this.#mode;
1318   }
1319 
1320   get imageManager() {
1321     return shadow(this, "imageManager", new ImageManager());
1322   }
1323 }
1324 
1325 export {
1326   AnnotationEditorUIManager,
1327   bindEvents,
1328   ColorManager,
1329   CommandManager,
1330   KeyboardManager,
1331   opacityToHex,
1332 };
</code>

Test file:
<test_file>
File:
test/unit/annotation_spec.js
/* Copyright 2017 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import {
  Annotation,
  AnnotationBorderStyle,
  AnnotationFactory,
  getQuadPoints,
  MarkupAnnotation,
} from "../../src/core/annotation.js";
import {
  AnnotationBorderStyleType,
  AnnotationEditorType,
  AnnotationFieldFlag,
  AnnotationFlag,
  AnnotationType,
  OPS,
  RenderingIntentFlag,
  stringToBytes,
  stringToUTF8String,
} from "../../src/shared/util.js";
import {
  CMAP_URL,
  createIdFactory,
  STANDARD_FONT_DATA_URL,
  XRefMock,
} from "./test_utils.js";
import {
  DefaultCMapReaderFactory,
  DefaultStandardFontDataFactory,
} from "../../src/display/api.js";
import { Dict, Name, Ref, RefSetCache } from "../../src/core/primitives.js";
import { Lexer, Parser } from "../../src/core/parser.js";
import { PartialEvaluator } from "../../src/core/evaluator.js";
import { StringStream } from "../../src/core/stream.js";
import { WorkerTask } from "../../src/core/worker.js";
</test_file>

Your task:
You are a software tester at pdf.js.
1. Examine the existing test file. You may reuse any imports, helpers or setup blocks it already has.
2. Write exactly one javascript test `it("...", async () => {...})` block.
3. Your test must fail on the code before the patch, and pass after, hence the test will verify that the patch resolves the issue.
4. The test must be self-contained and to-the-point.
5. If you need something new use only the provided imports (respect the paths exactly how they are given) by importing dynamically for compatibility with Node.js — no new dependencies. 
6. Return only the javascript code for the new `it(...)` block (no comments or explanations).

Example structure:
it("should <describe behavior>", async () => {
  const { example } = await import("../../src/core/example.js");
  <initialize required variables>;
  <define expected variable>;
  <generate actual variables>;
  <compare expected with actual>;
});

