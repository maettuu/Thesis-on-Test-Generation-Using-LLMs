Before you begin:
- Keep going until the job is completely solved — don’t stop halfway.
- If you’re unsure about the behavior, reread the provided patch carefully; do not hallucinate.
- Plan your approach before writing code by reflecting on whether the test truly fails before and passes after.

Issue:
<issue>
Free Highlighting in PDF will record the "other" Highlight method with Glean
</issue>

Patch:
<patch>
diff --git a/src/display/editor/highlight.js b/src/display/editor/highlight.js
--- a/src/display/editor/highlight.js
+++ b/src/display/editor/highlight.js
@@ -727,6 +727,7 @@ class HighlightEditor extends AnnotationEditor {
         highlightId: this._freeHighlightId,
         highlightOutlines: this._freeHighlight.getOutlines(),
         clipPathId: this._freeHighlightClipId,
+        methodOfCreation: "main_toolbar",
       });
     } else {
       parent.drawLayer.removeFreeHighlight(this._freeHighlightId);


</patch>

Imports:
<imports>
Available Packages
Dev Dependencies:
- @babel/core: ^7.23.9
- @babel/preset-env: ^7.23.9
- @babel/runtime: ^7.23.9
- @fluent/bundle: ^0.18.0
- @fluent/dom: ^0.9.0
- @jazzer.js/core: ^2.1.0
- autoprefixer: ^10.4.17
- babel-loader: ^9.1.3
- caniuse-lite: ^1.0.30001587
- canvas: ^2.11.2
- core-js: ^3.36.0
- cross-env: ^7.0.3
- eslint: ^8.56.0
- eslint-config-prettier: ^8.10.0
- eslint-plugin-fetch-options: ^0.0.5
- eslint-plugin-html: ^7.1.0
- eslint-plugin-import: ^2.29.1
- eslint-plugin-jasmine: ^4.1.3
- eslint-plugin-json: ^3.1.0
- eslint-plugin-mozilla: ^3.3.2
- eslint-plugin-no-unsanitized: ^4.0.2
- eslint-plugin-prettier: ^5.1.3
- eslint-plugin-sort-exports: ^0.9.1
- eslint-plugin-unicorn: ^51.0.1
- globals: ^14.0.0
- gulp: ^4.0.2
- gulp-cli: ^2.3.0
- gulp-postcss: ^10.0.0
- gulp-rename: ^2.0.0
- gulp-replace: ^1.1.4
- gulp-zip: ^6.0.0
- jasmine: ^5.1.0
- jsdoc: ^4.0.2
- jstransformer-markdown-it: ^3.0.0
- merge-stream: ^2.0.0
- mkdirp: ^3.0.1
- needle: ^3.3.1
- path2d-polyfill: ^2.0.1
- pngjs: ^7.0.0
- postcss: ^8.4.35
- postcss-dark-theme-class: ^1.2.1
- postcss-dir-pseudo-class: ^8.0.1
- postcss-discard-comments: ^6.0.1
- postcss-nesting: ^12.0.2
- prettier: ^3.2.5
- puppeteer: ^22.3.0
- rimraf: ^3.0.2
- streamqueue: ^1.1.2
- stylelint: ^16.2.1
- stylelint-prettier: ^5.0.0
- terser-webpack-plugin: ^5.3.10
- through2: ^4.0.2
- tsc-alias: ^1.8.8
- ttest: ^4.0.0
- typescript: ^5.3.3
- typogr: ^0.6.8
- vinyl: ^3.0.0
- webpack: ^5.90.2
- webpack-stream: ^7.0.0
- wintersmith: ^2.5.0
- yargs: ^17.7.2

Engines:
- node: >=18

Available Relative Imports:
- `../../src/core/annotation.js`: Annotation, AnnotationBorderStyle, AnnotationFactory, MarkupAnnotation, getQuadPoints
- `../../src/core/bidi.js`: bidi
- `../../src/core/cff_parser.js`: CFFCharset, CFFCompiler, CFFFDSelect, CFFParser, CFFStrings
- `../../src/core/cmap.js`: CMap, CMapFactory, IdentityCMap
- `../../src/core/colorspace.js`: ColorSpace
- `../../src/core/core_utils.js`: arrayBuffersToBytes, encodeToXmlString, escapePDFName, escapeString, getInheritableProperty, getSizeInBytes, isAscii, isWhiteSpace, log2, numberToString, parseXFAPath, recoverJsURL, stringToUTF16HexString, stringToUTF16String, toRomanNumerals, validateCSSFont
- `../../src/core/crypto.js`: AES128Cipher, AES256Cipher, ARCFourCipher, CipherTransformFactory, PDF17, PDF20, calculateMD5, calculateSHA256, calculateSHA384, calculateSHA512
- `../../src/core/default_appearance.js`: createDefaultAppearance, parseAppearanceStream, parseDefaultAppearance
- `../../src/core/document.js`: PDFDocument, Page
- `../../src/core/encodings.js`: getEncoding
- `../../src/core/evaluator.js`: PartialEvaluator
- `../../src/core/flate_stream.js`: FlateStream
- `../../src/core/font_substitutions.js`: getFontSubstitution
- `../../src/core/fonts_utils.js`: SEAC_ANALYSIS_ENABLED
- `../../src/core/function.js`: PDFFunctionFactory, PostScriptCompiler, PostScriptEvaluator
- `../../src/core/glyphlist.js`: getDingbatsGlyphsUnicode, getGlyphsUnicode
- `../../src/core/image_utils.js`: GlobalImageCache, LocalColorSpaceCache
- `../../src/core/jbig2.js`: Jbig2Image
- `../../src/core/jpg.js`: JpegImage
- `../../src/core/jpx.js`: JpxImage
- `../../src/core/metadata_parser.js`: MetadataParser
- `../../src/core/operator_list.js`: OperatorList
- `../../src/core/parser.js`: Lexer, Linearization, Parser
- `../../src/core/predictor_stream.js`: PredictorStream
- `../../src/core/primitives.js`: Cmd, Dict, EOF, Name, Ref, RefSet, RefSetCache, isCmd, isDict, isName, isRefsEqual
- `../../src/core/ps_parser.js`: PostScriptLexer, PostScriptParser
- `../../src/core/stream.js`: NullStream, Stream, StringStream
- `../../src/core/type1_parser.js`: Type1Parser
- `../../src/core/unicode.js`: getCharUnicodeCategory, getUnicodeForGlyph, getUnicodeRangeFor, mapSpecialUnicodeValues
- `../../src/core/worker.js`: WorkerMessageHandler, WorkerTask
- `../../src/core/writer.js`: incrementalUpdate, writeDict
- `../../src/core/xfa/bind.js`: Binder
- `../../src/core/xfa/data.js`: DataHandler
- `../../src/core/xfa/factory.js`: XFAFactory
- `../../src/core/xfa/formcalc_lexer.js`: Lexer, TOKEN, Token
- `../../src/core/xfa/formcalc_parser.js`: Errors, Parser
- `../../src/core/xfa/parser.js`: XFAParser
- `../../src/core/xfa/som.js`: searchNode
- `../../src/core/xfa/symbol_utils.js`: $dump, $getChildren, $getChildrenByClass, $getChildrenByName, $text, $uid
- `../../src/core/xml_parser.js`: SimpleXMLParser, XMLParserBase
- `../../src/display/annotation_layer.js`: AnnotationLayer
- `../../src/display/annotation_storage.js`: AnnotationStorage
- `../../src/display/api.js`: DefaultCMapReaderFactory, DefaultCanvasFactory, DefaultStandardFontDataFactory, LoopbackPort, PDFDataRangeTransport, PDFDocumentLoadingTask, PDFDocumentProxy, PDFPageProxy, PDFWorker, PDFWorkerUtil, RenderTask, build, getDocument, version
- `../../src/display/display_utils.js`: DOMCanvasFactory, DOMSVGFactory, PDFDateString, PageViewport, PixelsPerInch, RenderingCancelledException, StatTimer, fetchData, getFilenameFromUrl, getPdfFilenameFromUrl, getXfaPageViewport, isDataScheme, isPdfFile, isValidFetchUrl, noContextMenu, setLayerDimensions
- `../../src/display/draw_layer.js`: DrawLayer
- `../../src/display/editor/annotation_editor_layer.js`: AnnotationEditorLayer
- `../../src/display/editor/color_picker.js`: ColorPicker
- `../../src/display/editor/outliner.js`: Outliner
- `../../src/display/editor/tools.js`: AnnotationEditorUIManager, CommandManager
- `../../src/display/fetch_stream.js`: PDFFetchStream
- `../../src/display/metadata.js`: Metadata
- `../../src/display/network.js`: PDFNetworkStream
- `../../src/display/network_utils.js`: createResponseStatusError, extractFilenameFromHeader, validateRangeRequestCapabilities, validateResponseStatus
- `../../src/display/node_stream.js`: PDFNodeStream
- `../../src/display/text_layer.js`: TextLayerRenderTask, renderTextLayer, updateTextLayer
- `../../src/display/worker_options.js`: GlobalWorkerOptions
- `../../src/display/xfa_layer.js`: XfaLayer
- `../../src/shared/message_handler.js`: MessageHandler
- `../../src/shared/murmurhash3.js`: MurmurHash3_64
- `../../src/shared/util.js`: AbortException, AnnotationBorderStyleType, AnnotationEditorParamsType, AnnotationEditorType, AnnotationFieldFlag, AnnotationFlag, AnnotationMode, AnnotationType, CMapCompressionType, FeatureTest, FormatError, ImageKind, InvalidPDFException, MissingPDFException, OPS, PasswordException, PasswordResponses, PermissionFlag, PromiseCapability, RenderingIntentFlag, UnexpectedResponseException, UnknownErrorException, Util, VerbosityLevel, bytesToString, createValidAbsoluteUrl, getModificationDate, getVerbosityLevel, isNodeJS, normalizeUnicode, objectSize, setVerbosityLevel, shadow, string32, stringToBytes, stringToPDFString, stringToUTF8String
- `../../web/annotation_layer_builder.js`: AnnotationLayerBuilder
- `../../web/download_manager.js`: DownloadManager
- `../../web/event_utils.js`: EventBus, WaitOnType, waitOnEventOrTimeout
- `../../web/genericl10n.js`: GenericL10n
- `../../web/pdf_find_controller.js`: FindState, PDFFindController
- `../../web/pdf_find_utils.js`: CharacterType, getCharacterType
- `../../web/pdf_history.js`: PDFHistory, isDestArraysEqual, isDestHashesEqual
- `../../web/pdf_link_service.js`: LinkTarget, PDFLinkService, SimpleLinkService
- `../../web/pdf_page_view.js`: PDFPageView
- `../../web/pdf_scripting_manager.component.js`: PDFScriptingManager
- `../../web/pdf_single_page_viewer.js`: PDFSinglePageViewer
- `../../web/pdf_viewer.js`: PDFPageViewBuffer, PDFViewer
- `../../web/struct_tree_layer_builder.js`: StructTreeLayerBuilder
- `../../web/text_layer_builder.js`: TextLayerBuilder
- `../../web/ui_utils.js`: AutoPrintRegExp, ProgressBar, RenderingStates, ScrollMode, SpreadMode, backtrackBeforeAllVisibleElements, binarySearchFirstItem, getPageSizeInches, getVisibleElements, isPortraitOrientation, isValidRotation, parseQueryString, removeNullCharacters
- `../../web/xfa_layer_builder.js`: XfaLayerBuilder
- `./test_utils.js`: CMAP_URL, DefaultFileReaderFactory, STANDARD_FONT_DATA_URL, TEST_PDFS_PATH, XRefMock, buildGetDocumentParams, createIdFactory
- `./testreporter.js`: TestReporter
</imports>

Code:
<code>
File:
src/display/editor/highlight.js
1 /* Copyright 2022 Mozilla Foundation
2  *
3  * Licensed under the Apache License, Version 2.0 (the "License");
4  * you may not use this file except in compliance with the License.
5  * You may obtain a copy of the License at
6  *
7  *     http://www.apache.org/licenses/LICENSE-2.0
8  *
9  * Unless required by applicable law or agreed to in writing, software
10  * distributed under the License is distributed on an "AS IS" BASIS,
11  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
12  * See the License for the specific language governing permissions and
13  * limitations under the License.
14  */
15 
16 import {
17   AnnotationEditorParamsType,
18   AnnotationEditorType,
19   shadow,
20   Util,
21 } from "../../shared/util.js";
22 import { bindEvents, KeyboardManager } from "./tools.js";
23 import { FreeOutliner, Outliner } from "./outliner.js";
24 import { AnnotationEditor } from "./editor.js";
25 import { ColorPicker } from "./color_picker.js";
26 import { noContextMenu } from "../display_utils.js";
27 
28 /**
29  * Basic draw editor in order to generate an Highlight annotation.
30  */
31 class HighlightEditor extends AnnotationEditor {
32   #anchorNode = null;
33 
34   #anchorOffset = 0;
35 
36   #boxes;
37 
38   #clipPathId = null;
39 
40   #colorPicker = null;
41 
42   #focusOutlines = null;
43 
44   #focusNode = null;
45 
46   #focusOffset = 0;
47 
48   #highlightDiv = null;
49 
50   #highlightOutlines = null;
51 
52   #id = null;
53 
54   #isFreeHighlight = false;
55 
56   #boundKeydown = this.#keydown.bind(this);
57 
58   #lastPoint = null;
59 
60   #opacity;
61 
62   #outlineId = null;
63 
64   #thickness;
65 
66   #methodOfCreation = "";
67 
68   static _defaultColor = null;
69 
70   static _defaultOpacity = 1;
71 
72   static _defaultThickness = 12;
73 
74   static _l10nPromise;
75 
76   static _type = "highlight";
77 
78   static _editorType = AnnotationEditorType.HIGHLIGHT;
79 
80   static _freeHighlightId = -1;
81 
82   static _freeHighlight = null;
83 
84   static _freeHighlightClipId = "";
85 
86   static get _keyboardManager() {
87     const proto = HighlightEditor.prototype;
88     return shadow(
89       this,
90       "_keyboardManager",
91       new KeyboardManager([
92         [["ArrowLeft", "mac+ArrowLeft"], proto._moveCaret, { args: [0] }],
93         [["ArrowRight", "mac+ArrowRight"], proto._moveCaret, { args: [1] }],
94         [["ArrowUp", "mac+ArrowUp"], proto._moveCaret, { args: [2] }],
95         [["ArrowDown", "mac+ArrowDown"], proto._moveCaret, { args: [3] }],
96       ])
97     );
98   }
99 
100   constructor(params) {
101     super({ ...params, name: "highlightEditor" });
102     this.color = params.color || HighlightEditor._defaultColor;
103     this.#thickness = params.thickness || HighlightEditor._defaultThickness;
104     this.#opacity = params.opacity || HighlightEditor._defaultOpacity;
105     this.#boxes = params.boxes || null;
106     this.#methodOfCreation = params.methodOfCreation || "";
107     this._isDraggable = false;
108 
109     if (params.highlightId > -1) {
110       this.#isFreeHighlight = true;
111       this.#createFreeOutlines(params);
112       this.#addToDrawLayer();
113     } else {
114       this.#anchorNode = params.anchorNode;
115       this.#anchorOffset = params.anchorOffset;
116       this.#focusNode = params.focusNode;
117       this.#focusOffset = params.focusOffset;
118       this.#createOutlines();
119       this.#addToDrawLayer();
120       this.rotate(this.rotation);
121     }
122   }
123 
124   /** @inheritdoc */
125   get telemetryInitialData() {
126     return {
127       action: "added",
128       type: this.#isFreeHighlight ? "free_highlight" : "highlight",
129       color: this._uiManager.highlightColorNames.get(this.color),
130       thickness: this.#thickness,
131       methodOfCreation: this.#methodOfCreation,
132     };
133   }
134 
135   /** @inheritdoc */
136   get telemetryFinalData() {
137     return {
138       type: "highlight",
139       color: this._uiManager.highlightColorNames.get(this.color),
140     };
141   }
142 
143   static computeTelemetryFinalData(data) {
144     // We want to know how many colors have been used.
145     return { numberOfColors: data.get("color").size };
146   }
147 
148   #createOutlines() {
149     const outliner = new Outliner(this.#boxes, /* borderWidth = */ 0.001);
150     this.#highlightOutlines = outliner.getOutlines();
151     ({
152       x: this.x,
153       y: this.y,
154       width: this.width,
155       height: this.height,
156     } = this.#highlightOutlines.box);
157 
158     const outlinerForOutline = new Outliner(
159       this.#boxes,
160       /* borderWidth = */ 0.0025,
161       /* innerMargin = */ 0.001,
162       this._uiManager.direction === "ltr"
163     );
164     this.#focusOutlines = outlinerForOutline.getOutlines();
165 
166     // The last point is in the pages coordinate system.
167     const { lastPoint } = this.#focusOutlines.box;
168     this.#lastPoint = [
169       (lastPoint[0] - this.x) / this.width,
170       (lastPoint[1] - this.y) / this.height,
171     ];
172   }
173 
174   #createFreeOutlines({ highlightOutlines, highlightId, clipPathId }) {
175     this.#highlightOutlines = highlightOutlines;
176     const extraThickness = 1.5;
177     this.#focusOutlines = highlightOutlines.getNewOutline(
178       /* Slightly bigger than the highlight in order to have a little
179          space between the highlight and the outline. */
180       this.#thickness / 2 + extraThickness,
181       /* innerMargin = */ 0.0025
182     );
183 
184     if (highlightId >= 0) {
185       this.#id = highlightId;
186       this.#clipPathId = clipPathId;
187       // We need to redraw the highlight because we change the coordinates to be
188       // in the box coordinate system.
189       this.parent.drawLayer.finalizeLine(highlightId, highlightOutlines);
190       this.#outlineId = this.parent.drawLayer.highlightOutline(
191         this.#focusOutlines
192       );
193     } else if (this.parent) {
194       const angle = this.parent.viewport.rotation;
195       this.parent.drawLayer.updateLine(this.#id, highlightOutlines);
196       this.parent.drawLayer.updateBox(
197         this.#id,
198         HighlightEditor.#rotateBbox(
199           this.#highlightOutlines.box,
200           (angle - this.rotation + 360) % 360
201         )
202       );
203 
204       this.parent.drawLayer.updateLine(this.#outlineId, this.#focusOutlines);
205       this.parent.drawLayer.updateBox(
206         this.#outlineId,
207         HighlightEditor.#rotateBbox(this.#focusOutlines.box, angle)
208       );
209     }
210     const { x, y, width, height } = highlightOutlines.box;
211     switch (this.rotation) {
212       case 0:
213         this.x = x;
214         this.y = y;
215         this.width = width;
216         this.height = height;
217         break;
218       case 90: {
219         const [pageWidth, pageHeight] = this.parentDimensions;
220         this.x = y;
221         this.y = 1 - x;
222         this.width = (width * pageHeight) / pageWidth;
223         this.height = (height * pageWidth) / pageHeight;
224         break;
225       }
226       case 180:
227         this.x = 1 - x;
228         this.y = 1 - y;
229         this.width = width;
230         this.height = height;
231         break;
232       case 270: {
233         const [pageWidth, pageHeight] = this.parentDimensions;
234         this.x = 1 - y;
235         this.y = x;
236         this.width = (width * pageHeight) / pageWidth;
237         this.height = (height * pageWidth) / pageHeight;
238         break;
239       }
240     }
241 
242     const { lastPoint } = this.#focusOutlines.box;
243     this.#lastPoint = [(lastPoint[0] - x) / width, (lastPoint[1] - y) / height];
244   }
245 
246   /** @inheritdoc */
247   static initialize(l10n, uiManager) {
248     AnnotationEditor.initialize(l10n, uiManager);
249     HighlightEditor._defaultColor ||=
250       uiManager.highlightColors?.values().next().value || "#fff066";
251   }
252 
253   /** @inheritdoc */
254   static updateDefaultParams(type, value) {
255     switch (type) {
256       case AnnotationEditorParamsType.HIGHLIGHT_DEFAULT_COLOR:
257         HighlightEditor._defaultColor = value;
258         break;
259       case AnnotationEditorParamsType.HIGHLIGHT_THICKNESS:
260         HighlightEditor._defaultThickness = value;
261         break;
262     }
263   }
264 
265   /** @inheritdoc */
266   translateInPage(x, y) {}
267 
268   /** @inheritdoc */
269   get toolbarPosition() {
270     return this.#lastPoint;
271   }
272 
273   /** @inheritdoc */
274   updateParams(type, value) {
275     switch (type) {
276       case AnnotationEditorParamsType.HIGHLIGHT_COLOR:
277         this.#updateColor(value);
278         break;
279       case AnnotationEditorParamsType.HIGHLIGHT_THICKNESS:
280         this.#updateThickness(value);
281         break;
282     }
283   }
284 
285   static get defaultPropertiesToUpdate() {
286     return [
287       [
288         AnnotationEditorParamsType.HIGHLIGHT_DEFAULT_COLOR,
289         HighlightEditor._defaultColor,
290       ],
291       [
292         AnnotationEditorParamsType.HIGHLIGHT_THICKNESS,
293         HighlightEditor._defaultThickness,
294       ],
295     ];
296   }
297 
298   /** @inheritdoc */
299   get propertiesToUpdate() {
300     return [
301       [
302         AnnotationEditorParamsType.HIGHLIGHT_COLOR,
303         this.color || HighlightEditor._defaultColor,
304       ],
305       [
306         AnnotationEditorParamsType.HIGHLIGHT_THICKNESS,
307         this.#thickness || HighlightEditor._defaultThickness,
308       ],
309       [AnnotationEditorParamsType.HIGHLIGHT_FREE, this.#isFreeHighlight],
310     ];
311   }
312 
313   /**
314    * Update the color and make this action undoable.
315    * @param {string} color
316    */
317   #updateColor(color) {
318     const setColor = col => {
319       this.color = col;
320       this.parent?.drawLayer.changeColor(this.#id, col);
321       this.#colorPicker?.updateColor(col);
322     };
323     const savedColor = this.color;
324     this.addCommands({
325       cmd: setColor.bind(this, color),
326       undo: setColor.bind(this, savedColor),
327       post: this._uiManager.updateUI.bind(this._uiManager, this),
328       mustExec: true,
329       type: AnnotationEditorParamsType.HIGHLIGHT_COLOR,
330       overwriteIfSameType: true,
331       keepUndo: true,
332     });
333 
334     this._reportTelemetry(
335       {
336         action: "color_changed",
337         color: this._uiManager.highlightColorNames.get(color),
338       },
339       /* mustWait = */ true
340     );
341   }
342 
343   /**
344    * Update the thickness and make this action undoable.
345    * @param {number} thickness
346    */
347   #updateThickness(thickness) {
348     const savedThickness = this.#thickness;
349     const setThickness = th => {
350       this.#thickness = th;
351       this.#changeThickness(th);
352     };
353     this.addCommands({
354       cmd: setThickness.bind(this, thickness),
355       undo: setThickness.bind(this, savedThickness),
356       post: this._uiManager.updateUI.bind(this._uiManager, this),
357       mustExec: true,
358       type: AnnotationEditorParamsType.INK_THICKNESS,
359       overwriteIfSameType: true,
360       keepUndo: true,
361     });
362     this._reportTelemetry(
363       { action: "thickness_changed", thickness },
364       /* mustWait = */ true
365     );
366   }
367 
368   /** @inheritdoc */
369   async addEditToolbar() {
370     const toolbar = await super.addEditToolbar();
371     if (!toolbar) {
372       return null;
373     }
374     if (this._uiManager.highlightColors) {
375       this.#colorPicker = new ColorPicker({ editor: this });
376       toolbar.addColorPicker(this.#colorPicker);
377     }
378     return toolbar;
379   }
380 
381   /** @inheritdoc */
382   disableEditing() {
383     super.disableEditing();
384     this.div.classList.toggle("disabled", true);
385   }
386 
387   /** @inheritdoc */
388   enableEditing() {
389     super.enableEditing();
390     this.div.classList.toggle("disabled", false);
391   }
392 
393   /** @inheritdoc */
394   fixAndSetPosition() {
395     return super.fixAndSetPosition(this.#getRotation());
396   }
397 
398   /** @inheritdoc */
399   getBaseTranslation() {
400     // The editor itself doesn't have any CSS border (we're drawing one
401     // ourselves in using SVG).
402     return [0, 0];
403   }
404 
405   /** @inheritdoc */
406   getRect(tx, ty) {
407     return super.getRect(tx, ty, this.#getRotation());
408   }
409 
410   /** @inheritdoc */
411   onceAdded() {
412     this.parent.addUndoableEditor(this);
413     this.div.focus();
414   }
415 
416   /** @inheritdoc */
417   remove() {
418     super.remove();
419     this.#cleanDrawLayer();
420     this._reportTelemetry({
421       action: "deleted",
422     });
423   }
424 
425   /** @inheritdoc */
426   rebuild() {
427     if (!this.parent) {
428       return;
429     }
430     super.rebuild();
431     if (this.div === null) {
432       return;
433     }
434 
435     this.#addToDrawLayer();
436 
437     if (!this.isAttachedToDOM) {
438       // At some point this editor was removed and we're rebuilding it,
439       // hence we must add it to its parent.
440       this.parent.add(this);
441     }
442   }
443 
444   setParent(parent) {
445     let mustBeSelected = false;
446     if (this.parent && !parent) {
447       this.#cleanDrawLayer();
448     } else if (parent) {
449       this.#addToDrawLayer(parent);
450       // If mustBeSelected is true it means that this editor was selected
451       // when its parent has been destroyed, hence we must select it again.
452       mustBeSelected =
453         !this.parent && this.div?.classList.contains("selectedEditor");
454     }
455     super.setParent(parent);
456     if (mustBeSelected) {
457       // We select it after the parent has been set.
458       this.select();
459     }
460   }
461 
462   #changeThickness(thickness) {
463     if (!this.#isFreeHighlight) {
464       return;
465     }
466     this.#createFreeOutlines({
467       highlightOutlines: this.#highlightOutlines.getNewOutline(thickness / 2),
468     });
469     this.fixAndSetPosition();
470     const [parentWidth, parentHeight] = this.parentDimensions;
471     this.setDims(this.width * parentWidth, this.height * parentHeight);
472   }
473 
474   #cleanDrawLayer() {
475     if (this.#id === null || !this.parent) {
476       return;
477     }
478     this.parent.drawLayer.remove(this.#id);
479     this.#id = null;
480     this.parent.drawLayer.remove(this.#outlineId);
481     this.#outlineId = null;
482   }
483 
484   #addToDrawLayer(parent = this.parent) {
485     if (this.#id !== null) {
486       return;
487     }
488     ({ id: this.#id, clipPathId: this.#clipPathId } =
489       parent.drawLayer.highlight(
490         this.#highlightOutlines,
491         this.color,
492         this.#opacity
493       ));
494     this.#outlineId = parent.drawLayer.highlightOutline(this.#focusOutlines);
495     if (this.#highlightDiv) {
496       this.#highlightDiv.style.clipPath = this.#clipPathId;
497     }
498   }
499 
500   static #rotateBbox({ x, y, width, height }, angle) {
501     switch (angle) {
502       case 90:
503         return {
504           x: 1 - y - height,
505           y: x,
506           width: height,
507           height: width,
508         };
509       case 180:
510         return {
511           x: 1 - x - width,
512           y: 1 - y - height,
513           width,
514           height,
515         };
516       case 270:
517         return {
518           x: y,
519           y: 1 - x - width,
520           width: height,
521           height: width,
522         };
523     }
524     return {
525       x,
526       y,
527       width,
528       height,
529     };
530   }
531 
532   /** @inheritdoc */
533   rotate(angle) {
534     // We need to rotate the svgs because of the coordinates system.
535     const { drawLayer } = this.parent;
536     let box;
537     if (this.#isFreeHighlight) {
538       angle = (angle - this.rotation + 360) % 360;
539       box = HighlightEditor.#rotateBbox(this.#highlightOutlines.box, angle);
540     } else {
541       // An highlight annotation is always drawn horizontally.
542       box = HighlightEditor.#rotateBbox(this, angle);
543     }
544     drawLayer.rotate(this.#id, angle);
545     drawLayer.rotate(this.#outlineId, angle);
546     drawLayer.updateBox(this.#id, box);
547     drawLayer.updateBox(
548       this.#outlineId,
549       HighlightEditor.#rotateBbox(this.#focusOutlines.box, angle)
550     );
551   }
552 
553   /** @inheritdoc */
554   render() {
555     if (this.div) {
556       return this.div;
557     }
558 
559     const div = super.render();
560     if (this.#isFreeHighlight) {
561       div.classList.add("free");
562     } else {
563       this.div.addEventListener("keydown", this.#boundKeydown);
564     }
565     const highlightDiv = (this.#highlightDiv = document.createElement("div"));
566     div.append(highlightDiv);
567     highlightDiv.className = "internal";
568     highlightDiv.style.clipPath = this.#clipPathId;
569     const [parentWidth, parentHeight] = this.parentDimensions;
570     this.setDims(this.width * parentWidth, this.height * parentHeight);
571 
572     bindEvents(this, this.#highlightDiv, ["pointerover", "pointerleave"]);
573     this.enableEditing();
574 
575     return div;
576   }
577 
578   pointerover() {
579     this.parent.drawLayer.addClass(this.#outlineId, "hovered");
580   }
581 
582   pointerleave() {
583     this.parent.drawLayer.removeClass(this.#outlineId, "hovered");
584   }
585 
586   #keydown(event) {
587     HighlightEditor._keyboardManager.exec(this, event);
588   }
589 
590   _moveCaret(direction) {
591     this.parent.unselect(this);
592     switch (direction) {
593       case 0 /* left */:
594       case 2 /* up */:
595         this.#setCaret(/* start = */ true);
596         break;
597       case 1 /* right */:
598       case 3 /* down */:
599         this.#setCaret(/* start = */ false);
600         break;
601     }
602   }
603 
604   #setCaret(start) {
605     if (!this.#anchorNode) {
606       return;
607     }
608     const selection = window.getSelection();
609     if (start) {
610       selection.setPosition(this.#anchorNode, this.#anchorOffset);
611     } else {
612       selection.setPosition(this.#focusNode, this.#focusOffset);
613     }
614   }
615 
616   /** @inheritdoc */
617   select() {
618     super.select();
619     this.parent?.drawLayer.removeClass(this.#outlineId, "hovered");
620     this.parent?.drawLayer.addClass(this.#outlineId, "selected");
621   }
622 
623   /** @inheritdoc */
624   unselect() {
625     super.unselect();
626     this.parent?.drawLayer.removeClass(this.#outlineId, "selected");
627     if (!this.#isFreeHighlight) {
628       this.#setCaret(/* start = */ false);
629     }
630   }
631 
632   #getRotation() {
633     // Highlight annotations are always drawn horizontally but if
634     // a free highlight annotation can be rotated.
635     return this.#isFreeHighlight ? this.rotation : 0;
636   }
637 
638   #serializeBoxes() {
639     if (this.#isFreeHighlight) {
640       return null;
641     }
642     const [pageWidth, pageHeight] = this.pageDimensions;
643     const boxes = this.#boxes;
644     const quadPoints = new Array(boxes.length * 8);
645     let i = 0;
646     for (const { x, y, width, height } of boxes) {
647       const sx = x * pageWidth;
648       const sy = (1 - y - height) * pageHeight;
649       // The specifications say that the rectangle should start from the bottom
650       // left corner and go counter-clockwise.
651       // But when opening the file in Adobe Acrobat it appears that this isn't
652       // correct hence the 4th and 6th numbers are just swapped.
653       quadPoints[i] = quadPoints[i + 4] = sx;
654       quadPoints[i + 1] = quadPoints[i + 3] = sy;
655       quadPoints[i + 2] = quadPoints[i + 6] = sx + width * pageWidth;
656       quadPoints[i + 5] = quadPoints[i + 7] = sy + height * pageHeight;
657       i += 8;
658     }
659     return quadPoints;
660   }
661 
662   #serializeOutlines(rect) {
663     return this.#highlightOutlines.serialize(rect, this.#getRotation());
664   }
665 
666   static startHighlighting(parent, isLTR, { target: textLayer, x, y }) {
667     const {
668       x: layerX,
669       y: layerY,
670       width: parentWidth,
671       height: parentHeight,
672     } = textLayer.getBoundingClientRect();
673     const pointerMove = e => {
674       this.#highlightMove(parent, e);
675     };
676     const pointerDownOptions = { capture: true, passive: false };
677     const pointerDown = e => {
678       // Avoid to have undesired clicks during the drawing.
679       e.preventDefault();
680       e.stopPropagation();
681     };
682     const pointerUpCallback = e => {
683       textLayer.removeEventListener("pointermove", pointerMove);
684       window.removeEventListener("blur", pointerUpCallback);
685       window.removeEventListener("pointerup", pointerUpCallback);
686       window.removeEventListener(
687         "pointerdown",
688         pointerDown,
689         pointerDownOptions
690       );
691       window.removeEventListener("contextmenu", noContextMenu);
692       this.#endHighlight(parent, e);
693     };
694     window.addEventListener("blur", pointerUpCallback);
695     window.addEventListener("pointerup", pointerUpCallback);
696     window.addEventListener("pointerdown", pointerDown, pointerDownOptions);
697     window.addEventListener("contextmenu", noContextMenu);
698 
699     textLayer.addEventListener("pointermove", pointerMove);
700     this._freeHighlight = new FreeOutliner(
701       { x, y },
702       [layerX, layerY, parentWidth, parentHeight],
703       parent.scale,
704       this._defaultThickness / 2,
705       isLTR,
706       /* innerMargin = */ 0.001
707     );
708     ({ id: this._freeHighlightId, clipPathId: this._freeHighlightClipId } =
709       parent.drawLayer.highlight(
710         this._freeHighlight,
711         this._defaultColor,
712         this._defaultOpacity,
713         /* isPathUpdatable = */ true
714       ));
715   }
716 
717   static #highlightMove(parent, event) {
718     if (this._freeHighlight.add(event)) {
719       // Redraw only if the point has been added.
720       parent.drawLayer.updatePath(this._freeHighlightId, this._freeHighlight);
721     }
722   }
723 
724   static #endHighlight(parent, event) {
725     if (!this._freeHighlight.isEmpty()) {
726       parent.createAndAddNewEditor(event, false, {
727         highlightId: this._freeHighlightId,
728         highlightOutlines: this._freeHighlight.getOutlines(),
729         clipPathId: this._freeHighlightClipId,
730       });
731     } else {
732       parent.drawLayer.removeFreeHighlight(this._freeHighlightId);
733     }
734     this._freeHighlightId = -1;
735     this._freeHighlight = null;
736     this._freeHighlightClipId = "";
737   }
738 
739   /** @inheritdoc */
740   static deserialize(data, parent, uiManager) {
741     const editor = super.deserialize(data, parent, uiManager);
742 
743     const {
744       rect: [blX, blY, trX, trY],
745       color,
746       quadPoints,
747     } = data;
748     editor.color = Util.makeHexColor(...color);
749     editor.#opacity = data.opacity;
750 
751     const [pageWidth, pageHeight] = editor.pageDimensions;
752     editor.width = (trX - blX) / pageWidth;
753     editor.height = (trY - blY) / pageHeight;
754     const boxes = (editor.#boxes = []);
755     for (let i = 0; i < quadPoints.length; i += 8) {
756       boxes.push({
757         x: (quadPoints[4] - trX) / pageWidth,
758         y: (trY - (1 - quadPoints[i + 5])) / pageHeight,
759         width: (quadPoints[i + 2] - quadPoints[i]) / pageWidth,
760         height: (quadPoints[i + 5] - quadPoints[i + 1]) / pageHeight,
761       });
762     }
763     editor.#createOutlines();
764 
765     return editor;
766   }
767 
768   /** @inheritdoc */
769   serialize(isForCopying = false) {
770     // It doesn't make sense to copy/paste a highlight annotation.
771     if (this.isEmpty() || isForCopying) {
772       return null;
773     }
774 
775     const rect = this.getRect(0, 0);
776     const color = AnnotationEditor._colorManager.convert(this.color);
777 
778     return {
779       annotationType: AnnotationEditorType.HIGHLIGHT,
780       color,
781       opacity: this.#opacity,
782       thickness: this.#thickness,
783       quadPoints: this.#serializeBoxes(),
784       outlines: this.#serializeOutlines(rect),
785       pageIndex: this.pageIndex,
786       rect,
787       rotation: this.#getRotation(),
788       structTreeParentId: this._structTreeParentId,
789     };
790   }
791 
792   static canCreateNewEmptyEditor() {
793     return false;
794   }
795 }
796 
797 export { HighlightEditor };
</code>

Your task:
You are a software tester at pdf.js.
1. Write exactly one javascript test `it("...", async () => {...})` block.
2. Your test must fail on the code before the patch, and pass after, hence the test will verify that the patch resolves the issue.
3. The test must be self-contained and to-the-point.
4. Use only the provided imports (respect the paths exactly how they are given) by importing dynamically for compatibility with Node.js — no new dependencies. 
5. Return only the javascript code (no comments or explanations).

Example structure:
it("should <describe behavior>", async () => {
  const { example } = await import("../../src/core/example.js");
  <initialize required variables>;
  <define expected variable>;
  <generate actual variables>;
  <compare expected with actual>;
});

