Before you begin:
- Keep going until the job is completely solved — don’t stop halfway.
- If you’re unsure about the behavior, reread the provided patch carefully; do not hallucinate.
- Plan your approach before writing code by reflecting on whether the test truly fails before and passes after.

Issue:
<issue>
Special character € does not appear
Attach (recommended) or Link to PDF file here: 
[d403d5d5-f3e1-411d-b289-9b497069b80e.pdf](https://github.com/user-attachments/files/15587595/d403d5d5-f3e1-411d-b289-9b497069b80e.pdf)

Configuration:
- Web browser and its version: 
    - Chromium-based: 125.0.6422.147
    - Mozilla Firefox 126.0.1
- Operating system and its version:
    - Windows Pro 11 Version: 10.0.22631 Build: 22631
- PDF.js version:
    - 4.4.14 -> [https://mozilla.github.io/pdf.js/web/viewer.html](https://mozilla.github.io/pdf.js/web/viewer.html)
    - 3.11.174
- Is a browser extension: No

Steps to reproduce the problem:
- Open attach document in pdf.js viewer

What is the expected behavior? (add screenshot)
- Open the document containing all special characters

![image](https://github.com/mozilla/pdf.js/assets/146735311/b09decd2-2dd3-413c-84ff-f68c6351dd58)

What went wrong? (add screenshot)
- The special character ﻿`€` does not appear

![image](https://github.com/mozilla/pdf.js/assets/146735311/84f0ee43-a037-4714-bbc3-16b1cd47350d)

Link to a viewer (if hosted on a site other than mozilla.github.io/pdf.js or as Firefox/Chrome extension):
- [https://mozilla.github.io/pdf.js/web/viewer.html](https://mozilla.github.io/pdf.js/web/viewer.html)

</issue>

PDF File:
<pdf>
issue18208.pdf
</pdf>

Patch:
<patch>
diff --git a/src/core/fonts.js b/src/core/fonts.js
--- a/src/core/fonts.js
+++ b/src/core/fonts.js
@@ -1244,7 +1244,7 @@ class Font {
         getDingbatsGlyphsUnicode(),
         this.differences
       );
-    } else if (isStandardFont) {
+    } else if (isStandardFont || isMappedToStandardFont) {
       const map = buildToFontChar(
         this.defaultEncoding,
         getGlyphsUnicode(),


</patch>

Imports:
<imports>
Available Packages
Dev Dependencies:
- @babel/core: ^7.25.2
- @babel/preset-env: ^7.25.3
- @babel/runtime: ^7.25.0
- @fluent/bundle: ^0.18.0
- @fluent/dom: ^0.10.0
- @jazzer.js/core: ^2.1.0
- @metalsmith/layouts: ^2.7.0
- @metalsmith/markdown: ^1.10.0
- autoprefixer: ^10.4.20
- babel-loader: ^9.1.3
- caniuse-lite: ^1.0.30001651
- canvas: ^2.11.2
- core-js: ^3.38.0
- cross-env: ^7.0.3
- eslint: ^8.57.0
- eslint-config-prettier: ^9.1.0
- eslint-plugin-fetch-options: ^0.0.5
- eslint-plugin-html: ^8.1.1
- eslint-plugin-import: ^2.29.1
- eslint-plugin-jasmine: ^4.2.0
- eslint-plugin-json: ^3.1.0
- eslint-plugin-no-unsanitized: ^4.0.2
- eslint-plugin-prettier: ^5.2.1
- eslint-plugin-sort-exports: ^0.9.1
- eslint-plugin-unicorn: ^55.0.0
- gulp: ^5.0.0
- gulp-cli: ^3.0.0
- gulp-postcss: ^10.0.0
- gulp-rename: ^2.0.0
- gulp-replace: ^1.1.4
- gulp-zip: ^6.0.0
- highlight.js: ^11.10.0
- jasmine: ^5.2.0
- jsdoc: ^4.0.3
- jstransformer-nunjucks: ^1.2.0
- metalsmith: ^2.6.3
- metalsmith-html-relative: ^2.0.1
- ordered-read-streams: ^2.0.0
- path2d: ^0.2.1
- pngjs: ^7.0.0
- postcss: ^8.4.41
- postcss-dark-theme-class: ^1.3.0
- postcss-dir-pseudo-class: ^9.0.0
- postcss-discard-comments: ^7.0.2
- postcss-nesting: ^13.0.0
- prettier: ^3.3.3
- puppeteer: ^22.15.0
- stylelint: ^16.8.2
- stylelint-prettier: ^5.0.2
- terser-webpack-plugin: ^5.3.10
- tsc-alias: ^1.8.10
- ttest: ^4.0.0
- typescript: ^5.5.4
- vinyl: ^3.0.0
- webpack: ^5.93.0
- webpack-stream: ^7.0.0
- yargs: ^17.7.2

Engines:
- node: >=18

Available Relative Imports:
- `../../src/core/annotation.js`: Annotation, AnnotationBorderStyle, AnnotationFactory, MarkupAnnotation, getQuadPoints
- `../../src/core/bidi.js`: bidi
- `../../src/core/cff_parser.js`: CFFCharset, CFFCompiler, CFFFDSelect, CFFParser, CFFStrings
- `../../src/core/cmap.js`: CMap, CMapFactory, IdentityCMap
- `../../src/core/colorspace.js`: ColorSpace
- `../../src/core/core_utils.js`: arrayBuffersToBytes, encodeToXmlString, escapePDFName, escapeString, getInheritableProperty, getSizeInBytes, isAscii, isWhiteSpace, log2, numberToString, parseXFAPath, recoverJsURL, stringToUTF16HexString, stringToUTF16String, toRomanNumerals, validateCSSFont
- `../../src/core/crypto.js`: AES128Cipher, AES256Cipher, ARCFourCipher, CipherTransformFactory, PDF17, PDF20, calculateMD5, calculateSHA256, calculateSHA384, calculateSHA512
- `../../src/core/default_appearance.js`: createDefaultAppearance, parseAppearanceStream, parseDefaultAppearance
- `../../src/core/document.js`: PDFDocument, Page
- `../../src/core/encodings.js`: getEncoding
- `../../src/core/evaluator.js`: PartialEvaluator
- `../../src/core/flate_stream.js`: FlateStream
- `../../src/core/font_substitutions.js`: getFontSubstitution
- `../../src/core/fonts_utils.js`: SEAC_ANALYSIS_ENABLED
- `../../src/core/function.js`: PDFFunctionFactory, PostScriptCompiler, PostScriptEvaluator
- `../../src/core/glyphlist.js`: getDingbatsGlyphsUnicode, getGlyphsUnicode
- `../../src/core/image_utils.js`: GlobalImageCache, LocalColorSpaceCache
- `../../src/core/jbig2.js`: Jbig2Error, Jbig2Image
- `../../src/core/jpg.js`: JpegError, JpegImage
- `../../src/core/jpx.js`: JpxError, JpxImage
- `../../src/core/metadata_parser.js`: MetadataParser
- `../../src/core/operator_list.js`: OperatorList
- `../../src/core/parser.js`: Lexer, Linearization, Parser
- `../../src/core/predictor_stream.js`: PredictorStream
- `../../src/core/primitives.js`: Cmd, Dict, EOF, Name, Ref, RefSet, RefSetCache, isCmd, isDict, isName, isRefsEqual
- `../../src/core/ps_parser.js`: PostScriptLexer, PostScriptParser
- `../../src/core/stream.js`: NullStream, Stream, StringStream
- `../../src/core/type1_parser.js`: Type1Parser
- `../../src/core/unicode.js`: getCharUnicodeCategory, getUnicodeForGlyph, getUnicodeRangeFor, mapSpecialUnicodeValues
- `../../src/core/worker.js`: WorkerMessageHandler, WorkerTask
- `../../src/core/writer.js`: incrementalUpdate, writeDict
- `../../src/core/xfa/bind.js`: Binder
- `../../src/core/xfa/data.js`: DataHandler
- `../../src/core/xfa/factory.js`: XFAFactory
- `../../src/core/xfa/formcalc_lexer.js`: Lexer, TOKEN, Token
- `../../src/core/xfa/formcalc_parser.js`: Errors, Parser
- `../../src/core/xfa/parser.js`: XFAParser
- `../../src/core/xfa/som.js`: searchNode
- `../../src/core/xfa/symbol_utils.js`: $dump, $getChildren, $getChildrenByClass, $getChildrenByName, $text, $uid
- `../../src/core/xml_parser.js`: SimpleXMLParser, XMLParserBase
- `../../src/display/annotation_layer.js`: AnnotationLayer
- `../../src/display/annotation_storage.js`: AnnotationStorage
- `../../src/display/api.js`: DefaultCMapReaderFactory, DefaultCanvasFactory, DefaultStandardFontDataFactory, LoopbackPort, PDFDataRangeTransport, PDFDocumentLoadingTask, PDFDocumentProxy, PDFPageProxy, PDFWorker, RenderTask, build, getDocument, version
- `../../src/display/display_utils.js`: DOMCanvasFactory, DOMSVGFactory, PDFDateString, PageViewport, PixelsPerInch, RenderingCancelledException, StatTimer, fetchData, getFilenameFromUrl, getPdfFilenameFromUrl, getXfaPageViewport, isDataScheme, isPdfFile, isValidFetchUrl, noContextMenu, setLayerDimensions
- `../../src/display/draw_layer.js`: DrawLayer
- `../../src/display/editor/annotation_editor_layer.js`: AnnotationEditorLayer
- `../../src/display/editor/color_picker.js`: ColorPicker
- `../../src/display/editor/tools.js`: AnnotationEditorUIManager, CommandManager
- `../../src/display/fetch_stream.js`: PDFFetchStream
- `../../src/display/metadata.js`: Metadata
- `../../src/display/network.js`: PDFNetworkStream
- `../../src/display/network_utils.js`: createResponseStatusError, extractFilenameFromHeader, validateRangeRequestCapabilities, validateResponseStatus
- `../../src/display/node_stream.js`: PDFNodeStream
- `../../src/display/node_utils.js`: NodePackages
- `../../src/display/text_layer.js`: TextLayer
- `../../src/display/worker_options.js`: GlobalWorkerOptions
- `../../src/display/xfa_layer.js`: XfaLayer
- `../../src/shared/message_handler.js`: MessageHandler
- `../../src/shared/murmurhash3.js`: MurmurHash3_64
- `../../src/shared/util.js`: AbortException, AnnotationBorderStyleType, AnnotationEditorParamsType, AnnotationEditorType, AnnotationFieldFlag, AnnotationFlag, AnnotationMode, AnnotationType, BaseException, CMapCompressionType, FeatureTest, FormatError, ImageKind, InvalidPDFException, MissingPDFException, OPS, PasswordException, PasswordResponses, PermissionFlag, RenderingIntentFlag, UnexpectedResponseException, UnknownErrorException, Util, VerbosityLevel, assert, bytesToString, createValidAbsoluteUrl, getModificationDate, getVerbosityLevel, isNodeJS, normalizeUnicode, objectSize, setVerbosityLevel, shadow, string32, stringToBytes, stringToPDFString, stringToUTF8String
- `../../web/annotation_layer_builder.js`: AnnotationLayerBuilder
- `../../web/app_options.js`: AppOptions, OptionKind
- `../../web/download_manager.js`: DownloadManager
- `../../web/event_utils.js`: EventBus, WaitOnType, waitOnEventOrTimeout
- `../../web/genericl10n.js`: GenericL10n
- `../../web/pdf_find_controller.js`: FindState, PDFFindController
- `../../web/pdf_find_utils.js`: CharacterType, getCharacterType
- `../../web/pdf_history.js`: PDFHistory, isDestArraysEqual, isDestHashesEqual
- `../../web/pdf_link_service.js`: LinkTarget, PDFLinkService, SimpleLinkService
- `../../web/pdf_page_view.js`: PDFPageView
- `../../web/pdf_scripting_manager.component.js`: PDFScriptingManager
- `../../web/pdf_single_page_viewer.js`: PDFSinglePageViewer
- `../../web/pdf_viewer.js`: PDFPageViewBuffer, PDFViewer
- `../../web/struct_tree_layer_builder.js`: StructTreeLayerBuilder
- `../../web/text_layer_builder.js`: TextLayerBuilder
- `../../web/ui_utils.js`: AutoPrintRegExp, ProgressBar, RenderingStates, ScrollMode, SpreadMode, backtrackBeforeAllVisibleElements, binarySearchFirstItem, getPageSizeInches, getVisibleElements, isPortraitOrientation, isValidRotation, parseQueryString, removeNullCharacters
- `../../web/xfa_layer_builder.js`: XfaLayerBuilder
- `./test_utils.js`: CMAP_URL, DefaultFileReaderFactory, STANDARD_FONT_DATA_URL, TEST_PDFS_PATH, XRefMock, buildGetDocumentParams, createIdFactory, createTemporaryNodeServer
- `./testreporter.js`: TestReporter
</imports>

Code:
<code>
File:
src/core/fonts.js
1 /* Copyright 2012 Mozilla Foundation
2  *
3  * Licensed under the Apache License, Version 2.0 (the "License");
4  * you may not use this file except in compliance with the License.
5  * You may obtain a copy of the License at
6  *
7  *     http://www.apache.org/licenses/LICENSE-2.0
8  *
9  * Unless required by applicable law or agreed to in writing, software
10  * distributed under the License is distributed on an "AS IS" BASIS,
11  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
12  * See the License for the specific language governing permissions and
13  * limitations under the License.
14  */
15 
16 import {
17   assert,
18   bytesToString,
19   FONT_IDENTITY_MATRIX,
20   FormatError,
21   info,
22   shadow,
23   string32,
24   warn,
25 } from "../shared/util.js";
26 import { CFFCompiler, CFFParser } from "./cff_parser.js";
27 import {
28   FontFlags,
29   getVerticalPresentationForm,
30   MacStandardGlyphOrdering,
31   normalizeFontName,
32   recoverGlyphName,
33   SEAC_ANALYSIS_ENABLED,
34 } from "./fonts_utils.js";
35 import {
36   getCharUnicodeCategory,
37   getUnicodeForGlyph,
38   getUnicodeRangeFor,
39   mapSpecialUnicodeValues,
40 } from "./unicode.js";
41 import { getDingbatsGlyphsUnicode, getGlyphsUnicode } from "./glyphlist.js";
42 import {
43   getEncoding,
44   MacRomanEncoding,
45   StandardEncoding,
46   SymbolSetEncoding,
47   WinAnsiEncoding,
48   ZapfDingbatsEncoding,
49 } from "./encodings.js";
50 import {
51   getGlyphMapForStandardFonts,
52   getNonStdFontMap,
53   getSerifFonts,
54   getStdFontMap,
55   getSupplementalGlyphMapForArialBlack,
56   getSupplementalGlyphMapForCalibri,
57 } from "./standard_fonts.js";
58 import { IdentityToUnicodeMap, ToUnicodeMap } from "./to_unicode_map.js";
59 import { CFFFont } from "./cff_font.js";
60 import { FontRendererFactory } from "./font_renderer.js";
61 import { getFontBasicMetrics } from "./metrics.js";
62 import { GlyfTable } from "./glyf.js";
63 import { IdentityCMap } from "./cmap.js";
64 import { OpenTypeFileBuilder } from "./opentype_file_builder.js";
65 import { readUint32 } from "./core_utils.js";
66 import { Stream } from "./stream.js";
67 import { Type1Font } from "./type1_font.js";
68 
69 // Unicode Private Use Areas:
70 const PRIVATE_USE_AREAS = [
71   [0xe000, 0xf8ff], // BMP (0)
72   [0x100000, 0x10fffd], // PUP (16)
73 ];
74 
75 // PDF Glyph Space Units are one Thousandth of a TextSpace Unit
76 // except for Type 3 fonts
77 const PDF_GLYPH_SPACE_UNITS = 1000;
78 
79 const EXPORT_DATA_PROPERTIES = [
80   "ascent",
81   "bbox",
82   "black",
83   "bold",
84   "charProcOperatorList",
85   "composite",
86   "cssFontInfo",
87   "data",
88   "defaultVMetrics",
89   "defaultWidth",
90   "descent",
91   "fallbackName",
92   "fontMatrix",
93   "isInvalidPDFjsFont",
94   "isType3Font",
95   "italic",
96   "loadedName",
97   "mimetype",
98   "missingFile",
99   "name",
100   "remeasure",
101   "subtype",
102   "systemFontInfo",
103   "type",
104   "vertical",
105 ];
106 
107 const EXPORT_DATA_EXTRA_PROPERTIES = [
108   "cMap",
109   "defaultEncoding",
110   "differences",
111   "isMonospace",
112   "isSerifFont",
113   "isSymbolicFont",
114   "seacMap",
115   "toFontChar",
116   "toUnicode",
117   "vmetrics",
118   "widths",
119 ];
120 
121 function adjustWidths(properties) {
122   if (!properties.fontMatrix) {
123     return;
124   }
125   if (properties.fontMatrix[0] === FONT_IDENTITY_MATRIX[0]) {
126     return;
127   }
128   // adjusting width to fontMatrix scale
129   const scale = 0.001 / properties.fontMatrix[0];
130   const glyphsWidths = properties.widths;
131   for (const glyph in glyphsWidths) {
132     glyphsWidths[glyph] *= scale;
133   }
134   properties.defaultWidth *= scale;
135 }
136 
137 function adjustTrueTypeToUnicode(properties, isSymbolicFont, nameRecords) {
138   if (properties.isInternalFont) {
139     return;
140   }
141   if (properties.hasIncludedToUnicodeMap) {
142     return; // The font dictionary has a `ToUnicode` entry.
143   }
144   if (properties.hasEncoding) {
145     return; // The font dictionary has an `Encoding` entry.
146   }
147   if (properties.toUnicode instanceof IdentityToUnicodeMap) {
148     return;
149   }
150   if (!isSymbolicFont) {
151     return; // A non-symbolic font should default to `StandardEncoding`.
152   }
153   if (nameRecords.length === 0) {
154     return;
155   }
156 
157   // Try to infer if the fallback encoding should really be `WinAnsiEncoding`.
158   if (properties.defaultEncoding === WinAnsiEncoding) {
159     return;
160   }
161   for (const r of nameRecords) {
162     if (!isWinNameRecord(r)) {
163       return; // Not Windows, hence `WinAnsiEncoding` wouldn't make sense.
164     }
165   }
166   const encoding = WinAnsiEncoding;
167 
168   const toUnicode = [],
169     glyphsUnicodeMap = getGlyphsUnicode();
170   for (const charCode in encoding) {
171     const glyphName = encoding[charCode];
172     if (glyphName === "") {
173       continue;
174     }
175     const unicode = glyphsUnicodeMap[glyphName];
176     if (unicode === undefined) {
177       continue;
178     }
179     toUnicode[charCode] = String.fromCharCode(unicode);
180   }
181   if (toUnicode.length > 0) {
182     properties.toUnicode.amend(toUnicode);
183   }
184 }
185 
186 function adjustType1ToUnicode(properties, builtInEncoding) {
187   if (properties.isInternalFont) {
188     return;
189   }
190   if (properties.hasIncludedToUnicodeMap) {
191     return; // The font dictionary has a `ToUnicode` entry.
192   }
193   if (builtInEncoding === properties.defaultEncoding) {
194     return; // No point in trying to adjust `toUnicode` if the encodings match.
195   }
196   if (properties.toUnicode instanceof IdentityToUnicodeMap) {
197     return;
198   }
199   const toUnicode = [],
200     glyphsUnicodeMap = getGlyphsUnicode();
201   for (const charCode in builtInEncoding) {
202     if (properties.hasEncoding) {
203       if (
204         properties.baseEncodingName ||
205         properties.differences[charCode] !== undefined
206       ) {
207         continue; // The font dictionary has an `Encoding`/`Differences` entry.
208       }
209     }
210     const glyphName = builtInEncoding[charCode];
211     const unicode = getUnicodeForGlyph(glyphName, glyphsUnicodeMap);
212     if (unicode !== -1) {
213       toUnicode[charCode] = String.fromCharCode(unicode);
214     }
215   }
216   if (toUnicode.length > 0) {
217     properties.toUnicode.amend(toUnicode);
218   }
219 }
220 
221 /**
222  * NOTE: This function should only be called at the *end* of font-parsing,
223  *       after e.g. `adjustType1ToUnicode` has run, to prevent any issues.
224  */
225 function amendFallbackToUnicode(properties) {
226   if (!properties.fallbackToUnicode) {
227     return;
228   }
229   if (properties.toUnicode instanceof IdentityToUnicodeMap) {
230     return;
231   }
232   const toUnicode = [];
233   for (const charCode in properties.fallbackToUnicode) {
234     if (properties.toUnicode.has(charCode)) {
235       continue; // The font dictionary has a `ToUnicode` entry.
236     }
237     toUnicode[charCode] = properties.fallbackToUnicode[charCode];
238   }
239   if (toUnicode.length > 0) {
240     properties.toUnicode.amend(toUnicode);
241   }
242 }
243 
244 class Glyph {
245   constructor(
246     originalCharCode,
247     fontChar,
248     unicode,
249     accent,
250     width,
251     vmetric,
252     operatorListId,
253     isSpace,
254     isInFont
255   ) {
256     this.originalCharCode = originalCharCode;
257     this.fontChar = fontChar;
258     this.unicode = unicode;
259     this.accent = accent;
260     this.width = width;
261     this.vmetric = vmetric;
262     this.operatorListId = operatorListId;
263     this.isSpace = isSpace;
264     this.isInFont = isInFont;
265   }
266 
267   /**
268    * This property, which is only used by `PartialEvaluator.getTextContent`,
269    * is purposely made non-serializable.
270    * @type {Object}
271    */
272   get category() {
273     return shadow(
274       this,
275       "category",
276       getCharUnicodeCategory(this.unicode),
277       /* nonSerializable = */ true
278     );
279   }
280 }
281 
282 function int16(b0, b1) {
283   return (b0 << 8) + b1;
284 }
285 
286 function writeSignedInt16(bytes, index, value) {
287   bytes[index + 1] = value;
288   bytes[index] = value >>> 8;
289 }
290 
291 function signedInt16(b0, b1) {
292   const value = (b0 << 8) + b1;
293   return value & (1 << 15) ? value - 0x10000 : value;
294 }
295 
296 function writeUint32(bytes, index, value) {
297   bytes[index + 3] = value & 0xff;
298   bytes[index + 2] = value >>> 8;
299   bytes[index + 1] = value >>> 16;
300   bytes[index] = value >>> 24;
301 }
302 
303 function int32(b0, b1, b2, b3) {
304   return (b0 << 24) + (b1 << 16) + (b2 << 8) + b3;
305 }
306 
307 function string16(value) {
308   if (typeof PDFJSDev === "undefined" || PDFJSDev.test("TESTING")) {
309     assert(
310       typeof value === "number" && Math.abs(value) < 2 ** 16,
311       `string16: Unexpected input "${value}".`
312     );
313   }
314   return String.fromCharCode((value >> 8) & 0xff, value & 0xff);
315 }
316 
317 function safeString16(value) {
318   if (typeof PDFJSDev === "undefined" || PDFJSDev.test("TESTING")) {
319     assert(
320       typeof value === "number" && !Number.isNaN(value),
321       `safeString16: Unexpected input "${value}".`
322     );
323   }
324   // clamp value to the 16-bit int range
325   if (value > 0x7fff) {
326     value = 0x7fff;
327   } else if (value < -0x8000) {
328     value = -0x8000;
329   }
330   return String.fromCharCode((value >> 8) & 0xff, value & 0xff);
331 }
332 
333 function isTrueTypeFile(file) {
334   const header = file.peekBytes(4);
335   return (
336     readUint32(header, 0) === 0x00010000 || bytesToString(header) === "true"
337   );
338 }
339 
340 function isTrueTypeCollectionFile(file) {
341   const header = file.peekBytes(4);
342   return bytesToString(header) === "ttcf";
343 }
344 
345 function isOpenTypeFile(file) {
346   const header = file.peekBytes(4);
347   return bytesToString(header) === "OTTO";
348 }
349 
350 function isType1File(file) {
351   const header = file.peekBytes(2);
352   // All Type1 font programs must begin with the comment '%!' (0x25 + 0x21).
353   if (header[0] === 0x25 && header[1] === 0x21) {
354     return true;
355   }
356   // ... obviously some fonts violate that part of the specification,
357   // please refer to the comment in |Type1Font| below (pfb file header).
358   if (header[0] === 0x80 && header[1] === 0x01) {
359     return true;
360   }
361   return false;
362 }
363 
364 /**
365  * Compared to other font formats, the header in CFF files is not constant
366  * but contains version numbers. To reduce the possibility of misclassifying
367  * font files as CFF, it's recommended to check for other font formats first.
368  */
369 function isCFFFile(file) {
370   const header = file.peekBytes(4);
371   if (
372     /* major version, [1, 255] */ header[0] >= 1 &&
373     /* minor version, [0, 255]; header[1] */
374     /* header size, [0, 255]; header[2] */
375     /* offset(0) size, [1, 4] */ header[3] >= 1 &&
376     header[3] <= 4
377   ) {
378     return true;
379   }
380   return false;
381 }
382 
383 function getFontFileType(file, { type, subtype, composite }) {
384   let fileType, fileSubtype;
385 
386   if (isTrueTypeFile(file) || isTrueTypeCollectionFile(file)) {
387     fileType = composite ? "CIDFontType2" : "TrueType";
388   } else if (isOpenTypeFile(file)) {
389     fileType = composite ? "CIDFontType2" : "OpenType";
390   } else if (isType1File(file)) {
391     if (composite) {
392       fileType = "CIDFontType0";
393     } else {
394       fileType = type === "MMType1" ? "MMType1" : "Type1";
395     }
396   } else if (isCFFFile(file)) {
397     if (composite) {
398       fileType = "CIDFontType0";
399       fileSubtype = "CIDFontType0C";
400     } else {
401       fileType = type === "MMType1" ? "MMType1" : "Type1";
402       fileSubtype = "Type1C";
403     }
404   } else {
405     warn("getFontFileType: Unable to detect correct font file Type/Subtype.");
406     fileType = type;
407     fileSubtype = subtype;
408   }
409 
410   return [fileType, fileSubtype];
411 }
412 
413 function applyStandardFontGlyphMap(map, glyphMap) {
414   for (const charCode in glyphMap) {
415     map[+charCode] = glyphMap[charCode];
416   }
417 }
418 
419 function buildToFontChar(encoding, glyphsUnicodeMap, differences) {
420   const toFontChar = [];
421   let unicode;
422   for (let i = 0, ii = encoding.length; i < ii; i++) {
423     unicode = getUnicodeForGlyph(encoding[i], glyphsUnicodeMap);
424     if (unicode !== -1) {
425       toFontChar[i] = unicode;
426     }
427   }
428   for (const charCode in differences) {
429     unicode = getUnicodeForGlyph(differences[charCode], glyphsUnicodeMap);
430     if (unicode !== -1) {
431       toFontChar[+charCode] = unicode;
432     }
433   }
434   return toFontChar;
435 }
436 
437 // Please refer to:
438 //  - https://developer.apple.com/fonts/TrueType-Reference-Manual/RM06/Chap6name.html
439 function isMacNameRecord(r) {
440   return r.platform === 1 && r.encoding === 0 && r.language === 0;
441 }
442 
443 // Please refer to:
444 //  - https://developer.apple.com/fonts/TrueType-Reference-Manual/RM06/Chap6name.html
445 //  - https://learn.microsoft.com/en-us/typography/opentype/spec/name#windows-language-ids
446 function isWinNameRecord(r) {
447   return r.platform === 3 && r.encoding === 1 && r.language === 0x409;
448 }
449 
450 function convertCidString(charCode, cid, shouldThrow = false) {
451   switch (cid.length) {
452     case 1:
453       return cid.charCodeAt(0);
454     case 2:
455       return (cid.charCodeAt(0) << 8) | cid.charCodeAt(1);
456   }
457   const msg = `Unsupported CID string (charCode ${charCode}): "${cid}".`;
458   if (shouldThrow) {
459     throw new FormatError(msg);
460   }
461   warn(msg);
462   return cid;
463 }
464 
465 /**
466  * Rebuilds the char code to glyph ID map by moving all char codes to the
467  * private use area. This is done to avoid issues with various problematic
468  * unicode areas where either a glyph won't be drawn or is deformed by a
469  * shaper.
470  * @returns {Object} Two properties:
471  * 'toFontChar' - maps original char codes(the value that will be read
472  * from commands such as show text) to the char codes that will be used in the
473  * font that we build
474  * 'charCodeToGlyphId' - maps the new font char codes to glyph ids
475  */
476 function adjustMapping(charCodeToGlyphId, hasGlyph, newGlyphZeroId, toUnicode) {
477   const newMap = Object.create(null);
478   const toUnicodeExtraMap = new Map();
479   const toFontChar = [];
480   const usedGlyphIds = new Set();
481   let privateUseAreaIndex = 0;
482   const privateUseOffetStart = PRIVATE_USE_AREAS[privateUseAreaIndex][0];
483   let nextAvailableFontCharCode = privateUseOffetStart;
484   let privateUseOffetEnd = PRIVATE_USE_AREAS[privateUseAreaIndex][1];
485   const isInPrivateArea = code =>
486     (PRIVATE_USE_AREAS[0][0] <= code && code <= PRIVATE_USE_AREAS[0][1]) ||
487     (PRIVATE_USE_AREAS[1][0] <= code && code <= PRIVATE_USE_AREAS[1][1]);
488   for (const originalCharCode in charCodeToGlyphId) {
489     let glyphId = charCodeToGlyphId[originalCharCode];
490     // For missing glyphs don't create the mappings so the glyph isn't
491     // drawn.
492     if (!hasGlyph(glyphId)) {
493       continue;
494     }
495     if (nextAvailableFontCharCode > privateUseOffetEnd) {
496       privateUseAreaIndex++;
497       if (privateUseAreaIndex >= PRIVATE_USE_AREAS.length) {
498         warn("Ran out of space in font private use area.");
499         break;
500       }
501       nextAvailableFontCharCode = PRIVATE_USE_AREAS[privateUseAreaIndex][0];
502       privateUseOffetEnd = PRIVATE_USE_AREAS[privateUseAreaIndex][1];
503     }
504     const fontCharCode = nextAvailableFontCharCode++;
505     if (glyphId === 0) {
506       glyphId = newGlyphZeroId;
507     }
508 
509     // Fix for bug 1778484:
510     // The charcodes are moved into a private use area to fix some rendering
511     // issues (https://github.com/mozilla/pdf.js/pull/9340) but when printing
512     // to PDF the generated font will contain wrong chars. We can avoid that by
513     // adding the unicode to the cmap and the print backend will then map the
514     // glyph ids to the correct unicode.
515     let unicode = toUnicode.get(originalCharCode);
516     if (typeof unicode === "string") {
517       unicode = unicode.codePointAt(0);
518     }
519     if (unicode && !isInPrivateArea(unicode) && !usedGlyphIds.has(glyphId)) {
520       toUnicodeExtraMap.set(unicode, glyphId);
521       usedGlyphIds.add(glyphId);
522     }
523 
524     newMap[fontCharCode] = glyphId;
525     toFontChar[originalCharCode] = fontCharCode;
526   }
527   return {
528     toFontChar,
529     charCodeToGlyphId: newMap,
530     toUnicodeExtraMap,
531     nextAvailableFontCharCode,
532   };
533 }
534 
535 function getRanges(glyphs, toUnicodeExtraMap, numGlyphs) {
536   // Array.sort() sorts by characters, not numerically, so convert to an
537   // array of characters.
538   const codes = [];
539   for (const charCode in glyphs) {
540     // Remove an invalid glyph ID mappings to make OTS happy.
541     if (glyphs[charCode] >= numGlyphs) {
542       continue;
543     }
544     codes.push({ fontCharCode: charCode | 0, glyphId: glyphs[charCode] });
545   }
546   if (toUnicodeExtraMap) {
547     for (const [unicode, glyphId] of toUnicodeExtraMap) {
548       if (glyphId >= numGlyphs) {
549         continue;
550       }
551       codes.push({ fontCharCode: unicode, glyphId });
552     }
553   }
554   // Some fonts have zero glyphs and are used only for text selection, but
555   // there needs to be at least one to build a valid cmap table.
556   if (codes.length === 0) {
557     codes.push({ fontCharCode: 0, glyphId: 0 });
558   }
559   codes.sort(function fontGetRangesSort(a, b) {
560     return a.fontCharCode - b.fontCharCode;
561   });
562 
563   // Split the sorted codes into ranges.
564   const ranges = [];
565   const length = codes.length;
566   for (let n = 0; n < length; ) {
567     const start = codes[n].fontCharCode;
568     const codeIndices = [codes[n].glyphId];
569     ++n;
570     let end = start;
571     while (n < length && end + 1 === codes[n].fontCharCode) {
572       codeIndices.push(codes[n].glyphId);
573       ++end;
574       ++n;
575       if (end === 0xffff) {
576         break;
577       }
578     }
579     ranges.push([start, end, codeIndices]);
580   }
581 
582   return ranges;
583 }
584 
585 function createCmapTable(glyphs, toUnicodeExtraMap, numGlyphs) {
586   const ranges = getRanges(glyphs, toUnicodeExtraMap, numGlyphs);
587   const numTables = ranges.at(-1)[1] > 0xffff ? 2 : 1;
588   let cmap =
589     "\x00\x00" + // version
590     string16(numTables) + // numTables
591     "\x00\x03" + // platformID
592     "\x00\x01" + // encodingID
593     string32(4 + numTables * 8); // start of the table record
594 
595   let i, ii, j, jj;
596   for (i = ranges.length - 1; i >= 0; --i) {
597     if (ranges[i][0] <= 0xffff) {
598       break;
599     }
600   }
601   const bmpLength = i + 1;
602 
603   if (ranges[i][0] < 0xffff && ranges[i][1] === 0xffff) {
604     ranges[i][1] = 0xfffe;
605   }
606   const trailingRangesCount = ranges[i][1] < 0xffff ? 1 : 0;
607   const segCount = bmpLength + trailingRangesCount;
608   const searchParams = OpenTypeFileBuilder.getSearchParams(segCount, 2);
609 
610   // Fill up the 4 parallel arrays describing the segments.
611   let startCount = "";
612   let endCount = "";
613   let idDeltas = "";
614   let idRangeOffsets = "";
615   let glyphsIds = "";
616   let bias = 0;
617 
618   let range, start, end, codes;
619   for (i = 0, ii = bmpLength; i < ii; i++) {
620     range = ranges[i];
621     start = range[0];
622     end = range[1];
623     startCount += string16(start);
624     endCount += string16(end);
625     codes = range[2];
626     let contiguous = true;
627     for (j = 1, jj = codes.length; j < jj; ++j) {
628       if (codes[j] !== codes[j - 1] + 1) {
629         contiguous = false;
630         break;
631       }
632     }
633     if (!contiguous) {
634       const offset = (segCount - i) * 2 + bias * 2;
635       bias += end - start + 1;
636 
637       idDeltas += string16(0);
638       idRangeOffsets += string16(offset);
639 
640       for (j = 0, jj = codes.length; j < jj; ++j) {
641         glyphsIds += string16(codes[j]);
642       }
643     } else {
644       const startCode = codes[0];
645 
646       idDeltas += string16((startCode - start) & 0xffff);
647       idRangeOffsets += string16(0);
648     }
649   }
650 
651   if (trailingRangesCount > 0) {
652     endCount += "\xFF\xFF";
653     startCount += "\xFF\xFF";
654     idDeltas += "\x00\x01";
655     idRangeOffsets += "\x00\x00";
656   }
657 
658   const format314 =
659     "\x00\x00" + // language
660     string16(2 * segCount) +
661     string16(searchParams.range) +
662     string16(searchParams.entry) +
663     string16(searchParams.rangeShift) +
664     endCount +
665     "\x00\x00" +
666     startCount +
667     idDeltas +
668     idRangeOffsets +
669     glyphsIds;
670 
671   let format31012 = "";
672   let header31012 = "";
673   if (numTables > 1) {
674     cmap +=
675       "\x00\x03" + // platformID
676       "\x00\x0A" + // encodingID
677       string32(4 + numTables * 8 + 4 + format314.length); // start of the table record
678     format31012 = "";
679     for (i = 0, ii = ranges.length; i < ii; i++) {
680       range = ranges[i];
681       start = range[0];
682       codes = range[2];
683       let code = codes[0];
684       for (j = 1, jj = codes.length; j < jj; ++j) {
685         if (codes[j] !== codes[j - 1] + 1) {
686           end = range[0] + j - 1;
687           format31012 +=
688             string32(start) + // startCharCode
689             string32(end) + // endCharCode
690             string32(code); // startGlyphID
691           start = end + 1;
692           code = codes[j];
693         }
694       }
695       format31012 +=
696         string32(start) + // startCharCode
697         string32(range[1]) + // endCharCode
698         string32(code); // startGlyphID
699     }
700     header31012 =
701       "\x00\x0C" + // format
702       "\x00\x00" + // reserved
703       string32(format31012.length + 16) + // length
704       "\x00\x00\x00\x00" + // language
705       string32(format31012.length / 12); // nGroups
706   }
707 
708   return (
709     cmap +
710     "\x00\x04" + // format
711     string16(format314.length + 4) + // length
712     format314 +
713     header31012 +
714     format31012
715   );
716 }
717 
718 function validateOS2Table(os2, file) {
719   file.pos = (file.start || 0) + os2.offset;
720   const version = file.getUint16();
721   // TODO verify all OS/2 tables fields, but currently we validate only those
722   // that give us issues
723   file.skip(60); // skipping type, misc sizes, panose, unicode ranges
724   const selection = file.getUint16();
725   if (version < 4 && selection & 0x0300) {
726     return false;
727   }
728   const firstChar = file.getUint16();
729   const lastChar = file.getUint16();
730   if (firstChar > lastChar) {
731     return false;
732   }
733   file.skip(6); // skipping sTypoAscender/Descender/LineGap
734   const usWinAscent = file.getUint16();
735   if (usWinAscent === 0) {
736     // makes font unreadable by windows
737     return false;
738   }
739 
740   // OS/2 appears to be valid, resetting some fields
741   os2.data[8] = os2.data[9] = 0; // IE rejects fonts if fsType != 0
742   return true;
743 }
744 
745 function createOS2Table(properties, charstrings, override) {
746   override ||= {
747     unitsPerEm: 0,
748     yMax: 0,
749     yMin: 0,
750     ascent: 0,
751     descent: 0,
752   };
753 
754   let ulUnicodeRange1 = 0;
755   let ulUnicodeRange2 = 0;
756   let ulUnicodeRange3 = 0;
757   let ulUnicodeRange4 = 0;
758 
759   let firstCharIndex = null;
760   let lastCharIndex = 0;
761   let position = -1;
762 
763   if (charstrings) {
764     for (let code in charstrings) {
765       code |= 0;
766       if (firstCharIndex > code || !firstCharIndex) {
767         firstCharIndex = code;
768       }
769       if (lastCharIndex < code) {
770         lastCharIndex = code;
771       }
772 
773       position = getUnicodeRangeFor(code, position);
774       if (position < 32) {
775         ulUnicodeRange1 |= 1 << position;
776       } else if (position < 64) {
777         ulUnicodeRange2 |= 1 << (position - 32);
778       } else if (position < 96) {
779         ulUnicodeRange3 |= 1 << (position - 64);
780       } else if (position < 123) {
781         ulUnicodeRange4 |= 1 << (position - 96);
782       } else {
783         throw new FormatError(
784           "Unicode ranges Bits > 123 are reserved for internal usage"
785         );
786       }
787     }
788     if (lastCharIndex > 0xffff) {
789       // OS2 only supports a 16 bit int. The spec says if supplementary
790       // characters are used the field should just be set to 0xFFFF.
791       lastCharIndex = 0xffff;
792     }
793   } else {
794     // TODO
795     firstCharIndex = 0;
796     lastCharIndex = 255;
797   }
798 
799   const bbox = properties.bbox || [0, 0, 0, 0];
800   const unitsPerEm =
801     override.unitsPerEm ||
802     (properties.fontMatrix
803       ? 1 / Math.max(...properties.fontMatrix.slice(0, 4).map(Math.abs))
804       : 1000);
805 
806   // if the font units differ to the PDF glyph space units
807   // then scale up the values
808   const scale = properties.ascentScaled
809     ? 1.0
810     : unitsPerEm / PDF_GLYPH_SPACE_UNITS;
811 
812   const typoAscent =
813     override.ascent || Math.round(scale * (properties.ascent || bbox[3]));
814   let typoDescent =
815     override.descent || Math.round(scale * (properties.descent || bbox[1]));
816   if (typoDescent > 0 && properties.descent > 0 && bbox[1] < 0) {
817     typoDescent = -typoDescent; // fixing incorrect descent
818   }
819   const winAscent = override.yMax || typoAscent;
820   const winDescent = -override.yMin || -typoDescent;
821 
822   return (
823     "\x00\x03" + // version
824     "\x02\x24" + // xAvgCharWidth
825     "\x01\xF4" + // usWeightClass
826     "\x00\x05" + // usWidthClass
827     "\x00\x00" + // fstype (0 to let the font loads via font-face on IE)
828     "\x02\x8A" + // ySubscriptXSize
829     "\x02\xBB" + // ySubscriptYSize
830     "\x00\x00" + // ySubscriptXOffset
831     "\x00\x8C" + // ySubscriptYOffset
832     "\x02\x8A" + // ySuperScriptXSize
833     "\x02\xBB" + // ySuperScriptYSize
834     "\x00\x00" + // ySuperScriptXOffset
835     "\x01\xDF" + // ySuperScriptYOffset
836     "\x00\x31" + // yStrikeOutSize
837     "\x01\x02" + // yStrikeOutPosition
838     "\x00\x00" + // sFamilyClass
839     "\x00\x00\x06" +
840     String.fromCharCode(properties.fixedPitch ? 0x09 : 0x00) +
841     "\x00\x00\x00\x00\x00\x00" + // Panose
842     string32(ulUnicodeRange1) + // ulUnicodeRange1 (Bits 0-31)
843     string32(ulUnicodeRange2) + // ulUnicodeRange2 (Bits 32-63)
844     string32(ulUnicodeRange3) + // ulUnicodeRange3 (Bits 64-95)
845     string32(ulUnicodeRange4) + // ulUnicodeRange4 (Bits 96-127)
846     "\x2A\x32\x31\x2A" + // achVendID
847     string16(properties.italicAngle ? 1 : 0) + // fsSelection
848     string16(firstCharIndex || properties.firstChar) + // usFirstCharIndex
849     string16(lastCharIndex || properties.lastChar) + // usLastCharIndex
850     string16(typoAscent) + // sTypoAscender
851     string16(typoDescent) + // sTypoDescender
852     "\x00\x64" + // sTypoLineGap (7%-10% of the unitsPerEM value)
853     string16(winAscent) + // usWinAscent
854     string16(winDescent) + // usWinDescent
855     "\x00\x00\x00\x00" + // ulCodePageRange1 (Bits 0-31)
856     "\x00\x00\x00\x00" + // ulCodePageRange2 (Bits 32-63)
857     string16(properties.xHeight) + // sxHeight
858     string16(properties.capHeight) + // sCapHeight
859     string16(0) + // usDefaultChar
860     string16(firstCharIndex || properties.firstChar) + // usBreakChar
861     "\x00\x03"
862   ); // usMaxContext
863 }
864 
865 function createPostTable(properties) {
866   const angle = Math.floor(properties.italicAngle * 2 ** 16);
867   return (
868     "\x00\x03\x00\x00" + // Version number
869     string32(angle) + // italicAngle
870     "\x00\x00" + // underlinePosition
871     "\x00\x00" + // underlineThickness
872     string32(properties.fixedPitch ? 1 : 0) + // isFixedPitch
873     "\x00\x00\x00\x00" + // minMemType42
874     "\x00\x00\x00\x00" + // maxMemType42
875     "\x00\x00\x00\x00" + // minMemType1
876     "\x00\x00\x00\x00"
877   ); // maxMemType1
878 }
879 
880 function createPostscriptName(name) {
881   // See https://docs.microsoft.com/en-us/typography/opentype/spec/recom#name.
882   return name.replaceAll(/[^\x21-\x7E]|[[\](){}<>/%]/g, "").slice(0, 63);
883 }
884 
885 function createNameTable(name, proto) {
886   if (!proto) {
887     proto = [[], []]; // no strings and unicode strings
888   }
889 
890   const strings = [
891     proto[0][0] || "Original licence", // 0.Copyright
892     proto[0][1] || name, // 1.Font family
893     proto[0][2] || "Unknown", // 2.Font subfamily (font weight)
894     proto[0][3] || "uniqueID", // 3.Unique ID
895     proto[0][4] || name, // 4.Full font name
896     proto[0][5] || "Version 0.11", // 5.Version
897     proto[0][6] || createPostscriptName(name), // 6.Postscript name
898     proto[0][7] || "Unknown", // 7.Trademark
899     proto[0][8] || "Unknown", // 8.Manufacturer
900     proto[0][9] || "Unknown", // 9.Designer
901   ];
902 
903   // Mac want 1-byte per character strings while Windows want
904   // 2-bytes per character, so duplicate the names table
905   const stringsUnicode = [];
906   let i, ii, j, jj, str;
907   for (i = 0, ii = strings.length; i < ii; i++) {
908     str = proto[1][i] || strings[i];
909 
910     const strBufUnicode = [];
911     for (j = 0, jj = str.length; j < jj; j++) {
912       strBufUnicode.push(string16(str.charCodeAt(j)));
913     }
914     stringsUnicode.push(strBufUnicode.join(""));
915   }
916 
917   const names = [strings, stringsUnicode];
918   const platforms = ["\x00\x01", "\x00\x03"];
919   const encodings = ["\x00\x00", "\x00\x01"];
920   const languages = ["\x00\x00", "\x04\x09"];
921 
922   const namesRecordCount = strings.length * platforms.length;
923   let nameTable =
924     "\x00\x00" + // format
925     string16(namesRecordCount) + // Number of names Record
926     string16(namesRecordCount * 12 + 6); // Storage
927 
928   // Build the name records field
929   let strOffset = 0;
930   for (i = 0, ii = platforms.length; i < ii; i++) {
931     const strs = names[i];
932     for (j = 0, jj = strs.length; j < jj; j++) {
933       str = strs[j];
934       const nameRecord =
935         platforms[i] + // platform ID
936         encodings[i] + // encoding ID
937         languages[i] + // language ID
938         string16(j) + // name ID
939         string16(str.length) +
940         string16(strOffset);
941       nameTable += nameRecord;
942       strOffset += str.length;
943     }
944   }
945 
946   nameTable += strings.join("") + stringsUnicode.join("");
947   return nameTable;
948 }
949 
950 /**
951  * 'Font' is the class the outside world should use, it encapsulate all the font
952  * decoding logics whatever type it is (assuming the font type is supported).
953  */
954 class Font {
955   constructor(name, file, properties) {
956     this.name = name;
957     this.psName = null;
958     this.mimetype = null;
959     this.disableFontFace = false;
960 
961     this.loadedName = properties.loadedName;
962     this.isType3Font = properties.isType3Font;
963     this.missingFile = false;
964     this.cssFontInfo = properties.cssFontInfo;
965 
966     this._charsCache = Object.create(null);
967     this._glyphCache = Object.create(null);
968 
969     let isSerifFont = !!(properties.flags & FontFlags.Serif);
970     // Fallback to checking the font name, in order to improve text-selection,
971     // since the /Flags-entry is often wrong (fixes issue13845.pdf).
972     if (!isSerifFont && !properties.isSimulatedFlags) {
973       const baseName = name.replaceAll(/[,_]/g, "-").split("-", 1)[0],
974         serifFonts = getSerifFonts();
975       for (const namePart of baseName.split("+")) {
976         if (serifFonts[namePart]) {
977           isSerifFont = true;
978           break;
979         }
980       }
981     }
982     this.isSerifFont = isSerifFont;
983 
984     this.isSymbolicFont = !!(properties.flags & FontFlags.Symbolic);
985     this.isMonospace = !!(properties.flags & FontFlags.FixedPitch);
986 
987     let { type, subtype } = properties;
988     this.type = type;
989     this.subtype = subtype;
990     this.systemFontInfo = properties.systemFontInfo;
991 
992     const matches = name.match(/^InvalidPDFjsFont_(.*)_\d+$/);
993     this.isInvalidPDFjsFont = !!matches;
994     if (this.isInvalidPDFjsFont) {
995       this.fallbackName = matches[1];
996     } else if (this.isMonospace) {
997       this.fallbackName = "monospace";
998     } else if (this.isSerifFont) {
999       this.fallbackName = "serif";
1000     } else {
1001       this.fallbackName = "sans-serif";
1002     }
1003 
1004     if (this.systemFontInfo?.guessFallback) {
1005       // Once the fallback name is guessed, we don't want to guess it again.
1006       this.systemFontInfo.guessFallback = false;
1007       this.systemFontInfo.css += `,${this.fallbackName}`;
1008     }
1009 
1010     this.differences = properties.differences;
1011     this.widths = properties.widths;
1012     this.defaultWidth = properties.defaultWidth;
1013     this.composite = properties.composite;
1014     this.cMap = properties.cMap;
1015     this.capHeight = properties.capHeight / PDF_GLYPH_SPACE_UNITS;
1016     this.ascent = properties.ascent / PDF_GLYPH_SPACE_UNITS;
1017     this.descent = properties.descent / PDF_GLYPH_SPACE_UNITS;
1018     this.lineHeight = this.ascent - this.descent;
1019     this.fontMatrix = properties.fontMatrix;
1020     this.bbox = properties.bbox;
1021     this.defaultEncoding = properties.defaultEncoding;
1022 
1023     this.toUnicode = properties.toUnicode;
1024     this.toFontChar = [];
1025 
1026     if (properties.type === "Type3") {
1027       for (let charCode = 0; charCode < 256; charCode++) {
1028         this.toFontChar[charCode] =
1029           this.differences[charCode] || properties.defaultEncoding[charCode];
1030       }
1031       return;
1032     }
1033 
1034     this.cidEncoding = properties.cidEncoding || "";
1035     this.vertical = !!properties.vertical;
1036     if (this.vertical) {
1037       this.vmetrics = properties.vmetrics;
1038       this.defaultVMetrics = properties.defaultVMetrics;
1039     }
1040 
1041     if (!file || file.isEmpty) {
1042       if (file) {
1043         // Some bad PDF generators will include empty font files,
1044         // attempting to recover by assuming that no file exists.
1045         warn('Font file is empty in "' + name + '" (' + this.loadedName + ")");
1046       }
1047       this.fallbackToSystemFont(properties);
1048       return;
1049     }
1050 
1051     // Parse the font file to determine the correct type/subtype, rather than
1052     // relying on the (often incorrect) data in the font dictionary; (see e.g.
1053     //  issue6782.pdf, issue7598.pdf, and issue9949.pdf).
1054     [type, subtype] = getFontFileType(file, properties);
1055 
1056     if (type !== this.type || subtype !== this.subtype) {
1057       info(
1058         "Inconsistent font file Type/SubType, expected: " +
1059           `${this.type}/${this.subtype} but found: ${type}/${subtype}.`
1060       );
1061     }
1062 
1063     let data;
1064     try {
1065       switch (type) {
1066         case "MMType1":
1067           info("MMType1 font (" + name + "), falling back to Type1.");
1068         /* falls through */
1069         case "Type1":
1070         case "CIDFontType0":
1071           this.mimetype = "font/opentype";
1072 
1073           const cff =
1074             subtype === "Type1C" || subtype === "CIDFontType0C"
1075               ? new CFFFont(file, properties)
1076               : new Type1Font(name, file, properties);
1077 
1078           adjustWidths(properties);
1079 
1080           // Wrap the CFF data inside an OTF font file
1081           data = this.convert(name, cff, properties);
1082           break;
1083 
1084         case "OpenType":
1085         case "TrueType":
1086         case "CIDFontType2":
1087           this.mimetype = "font/opentype";
1088 
1089           // Repair the TrueType file. It is can be damaged in the point of
1090           // view of the sanitizer
1091           data = this.checkAndRepair(name, file, properties);
1092           if (this.isOpenType) {
1093             adjustWidths(properties);
1094 
1095             type = "OpenType";
1096           }
1097           break;
1098 
1099         default:
1100           throw new FormatError(`Font ${type} is not supported`);
1101       }
1102     } catch (e) {
1103       warn(e);
1104       this.fallbackToSystemFont(properties);
1105       return;
1106     }
1107 
1108     amendFallbackToUnicode(properties);
1109     this.data = data;
1110 
1111     // Transfer some properties again that could change during font conversion
1112     this.type = type;
1113     this.subtype = subtype;
1114     this.fontMatrix = properties.fontMatrix;
1115     this.widths = properties.widths;
1116     this.defaultWidth = properties.defaultWidth;
1117     this.toUnicode = properties.toUnicode;
1118     this.seacMap = properties.seacMap;
1119   }
1120 
1121   get renderer() {
1122     const renderer = FontRendererFactory.create(this, SEAC_ANALYSIS_ENABLED);
1123     return shadow(this, "renderer", renderer);
1124   }
1125 
1126   exportData(extraProperties = false) {
1127     const exportDataProperties = extraProperties
1128       ? [...EXPORT_DATA_PROPERTIES, ...EXPORT_DATA_EXTRA_PROPERTIES]
1129       : EXPORT_DATA_PROPERTIES;
1130 
1131     const data = Object.create(null);
1132     let property, value;
1133     for (property of exportDataProperties) {
1134       value = this[property];
1135       // Ignore properties that haven't been explicitly set.
1136       if (value !== undefined) {
1137         data[property] = value;
1138       }
1139     }
1140     return data;
1141   }
1142 
1143   fallbackToSystemFont(properties) {
1144     this.missingFile = true;
1145     // The file data is not specified. Trying to fix the font name
1146     // to be used with the canvas.font.
1147     const { name, type } = this;
1148     let fontName = normalizeFontName(name);
1149     const stdFontMap = getStdFontMap(),
1150       nonStdFontMap = getNonStdFontMap();
1151     const isStandardFont = !!stdFontMap[fontName];
1152     const isMappedToStandardFont = !!(
1153       nonStdFontMap[fontName] && stdFontMap[nonStdFontMap[fontName]]
1154     );
1155 
1156     fontName = stdFontMap[fontName] || nonStdFontMap[fontName] || fontName;
1157 
1158     const fontBasicMetricsMap = getFontBasicMetrics();
1159     const metrics = fontBasicMetricsMap[fontName];
1160     if (metrics) {
1161       if (isNaN(this.ascent)) {
1162         this.ascent = metrics.ascent / PDF_GLYPH_SPACE_UNITS;
1163       }
1164       if (isNaN(this.descent)) {
1165         this.descent = metrics.descent / PDF_GLYPH_SPACE_UNITS;
1166       }
1167       if (isNaN(this.capHeight)) {
1168         this.capHeight = metrics.capHeight / PDF_GLYPH_SPACE_UNITS;
1169       }
1170     }
1171 
1172     this.bold = /bold/gi.test(fontName);
1173     this.italic = /oblique|italic/gi.test(fontName);
1174 
1175     // Use 'name' instead of 'fontName' here because the original
1176     // name ArialBlack for example will be replaced by Helvetica.
1177     this.black = /Black/g.test(name);
1178 
1179     // Use 'name' instead of 'fontName' here because the original
1180     // name ArialNarrow for example will be replaced by Helvetica.
1181     const isNarrow = /Narrow/g.test(name);
1182 
1183     // if at least one width is present, remeasure all chars when exists
1184     this.remeasure =
1185       (!isStandardFont || isNarrow) && Object.keys(this.widths).length > 0;
1186     if (
1187       (isStandardFont || isMappedToStandardFont) &&
1188       type === "CIDFontType2" &&
1189       this.cidEncoding.startsWith("Identity-")
1190     ) {
1191       const cidToGidMap = properties.cidToGidMap;
1192       // Standard fonts might be embedded as CID font without glyph mapping.
1193       // Building one based on GlyphMapForStandardFonts.
1194       const map = [];
1195       applyStandardFontGlyphMap(map, getGlyphMapForStandardFonts());
1196 
1197       if (/Arial-?Black/i.test(name)) {
1198         applyStandardFontGlyphMap(map, getSupplementalGlyphMapForArialBlack());
1199       } else if (/Calibri/i.test(name)) {
1200         applyStandardFontGlyphMap(map, getSupplementalGlyphMapForCalibri());
1201       }
1202 
1203       // Always update the glyph mapping with the `cidToGidMap` when it exists
1204       // (fixes issue12418_reduced.pdf).
1205       if (cidToGidMap) {
1206         for (const charCode in map) {
1207           const cid = map[charCode];
1208           if (cidToGidMap[cid] !== undefined) {
1209             map[+charCode] = cidToGidMap[cid];
1210           }
1211         }
1212         // When the /CIDToGIDMap is "incomplete", fallback to the included
1213         // /ToUnicode-map regardless of its encoding (fixes issue11915.pdf).
1214         if (
1215           cidToGidMap.length !== this.toUnicode.length &&
1216           properties.hasIncludedToUnicodeMap &&
1217           this.toUnicode instanceof IdentityToUnicodeMap
1218         ) {
1219           this.toUnicode.forEach(function (charCode, unicodeCharCode) {
1220             const cid = map[charCode];
1221             if (cidToGidMap[cid] === undefined) {
1222               map[+charCode] = unicodeCharCode;
1223             }
1224           });
1225         }
1226       }
1227 
1228       if (!(this.toUnicode instanceof IdentityToUnicodeMap)) {
1229         this.toUnicode.forEach(function (charCode, unicodeCharCode) {
1230           map[+charCode] = unicodeCharCode;
1231         });
1232       }
1233       this.toFontChar = map;
1234       this.toUnicode = new ToUnicodeMap(map);
1235     } else if (/Symbol/i.test(fontName)) {
1236       this.toFontChar = buildToFontChar(
1237         SymbolSetEncoding,
1238         getGlyphsUnicode(),
1239         this.differences
1240       );
1241     } else if (/Dingbats/i.test(fontName)) {
1242       this.toFontChar = buildToFontChar(
1243         ZapfDingbatsEncoding,
1244         getDingbatsGlyphsUnicode(),
1245         this.differences
1246       );
1247     } else if (isStandardFont) {
1248       const map = buildToFontChar(
1249         this.defaultEncoding,
1250         getGlyphsUnicode(),
1251         this.differences
1252       );
1253 
1254       if (
1255         type === "CIDFontType2" &&
1256         !this.cidEncoding.startsWith("Identity-") &&
1257         !(this.toUnicode instanceof IdentityToUnicodeMap)
1258       ) {
1259         this.toUnicode.forEach(function (charCode, unicodeCharCode) {
1260           map[+charCode] = unicodeCharCode;
1261         });
1262       }
1263       this.toFontChar = map;
1264     } else {
1265       const glyphsUnicodeMap = getGlyphsUnicode();
1266       const map = [];
1267       this.toUnicode.forEach((charCode, unicodeCharCode) => {
1268         if (!this.composite) {
1269           const glyphName =
1270             this.differences[charCode] || this.defaultEncoding[charCode];
1271           const unicode = getUnicodeForGlyph(glyphName, glyphsUnicodeMap);
1272           if (unicode !== -1) {
1273             unicodeCharCode = unicode;
1274           }
1275         }
1276         map[+charCode] = unicodeCharCode;
1277       });
1278 
1279       // Attempt to improve the glyph mapping for (some) composite fonts that
1280       // appear to lack meaningful ToUnicode data.
1281       if (this.composite && this.toUnicode instanceof IdentityToUnicodeMap) {
1282         if (/Tahoma|Verdana/i.test(name)) {
1283           // Fixes issue15719.pdf and issue11242_reduced.pdf.
1284           applyStandardFontGlyphMap(map, getGlyphMapForStandardFonts());
1285         }
1286       }
1287       this.toFontChar = map;
1288     }
1289 
1290     amendFallbackToUnicode(properties);
1291     this.loadedName = fontName.split("-", 1)[0];
1292   }
1293 
1294   checkAndRepair(name, font, properties) {
1295     const VALID_TABLES = [
1296       "OS/2",
1297       "cmap",
1298       "head",
1299       "hhea",
1300       "hmtx",
1301       "maxp",
1302       "name",
1303       "post",
1304       "loca",
1305       "glyf",
1306       "fpgm",
1307       "prep",
1308       "cvt ",
1309       "CFF ",
1310     ];
1311 
1312     function readTables(file, numTables) {
1313       const tables = Object.create(null);
1314       tables["OS/2"] = null;
1315       tables.cmap = null;
1316       tables.head = null;
1317       tables.hhea = null;
1318       tables.hmtx = null;
1319       tables.maxp = null;
1320       tables.name = null;
1321       tables.post = null;
1322 
1323       for (let i = 0; i < numTables; i++) {
1324         const table = readTableEntry(file);
1325         if (!VALID_TABLES.includes(table.tag)) {
1326           continue; // skipping table if it's not a required or optional table
1327         }
1328         if (table.length === 0) {
1329           continue; // skipping empty tables
1330         }
1331         tables[table.tag] = table;
1332       }
1333       return tables;
1334     }
1335 
1336     function readTableEntry(file) {
1337       const tag = file.getString(4);
1338 
1339       const checksum = file.getInt32() >>> 0;
1340       const offset = file.getInt32() >>> 0;
1341       const length = file.getInt32() >>> 0;
1342 
1343       // Read the table associated data
1344       const previousPosition = file.pos;
1345       file.pos = file.start || 0;
1346       file.skip(offset);
1347       const data = file.getBytes(length);
1348       file.pos = previousPosition;
1349 
1350       if (tag === "head") {
1351         // clearing checksum adjustment
1352         data[8] = data[9] = data[10] = data[11] = 0;
1353         data[17] |= 0x20; // Set font optimized for cleartype flag.
1354       }
1355 
1356       return {
1357         tag,
1358         checksum,
1359         length,
1360         offset,
1361         data,
1362       };
1363     }
1364 
1365     function readOpenTypeHeader(ttf) {
1366       return {
1367         version: ttf.getString(4),
1368         numTables: ttf.getUint16(),
1369         searchRange: ttf.getUint16(),
1370         entrySelector: ttf.getUint16(),
1371         rangeShift: ttf.getUint16(),
1372       };
1373     }
1374 
1375     function readTrueTypeCollectionHeader(ttc) {
1376       const ttcTag = ttc.getString(4);
1377       assert(ttcTag === "ttcf", "Must be a TrueType Collection font.");
1378 
1379       const majorVersion = ttc.getUint16();
1380       const minorVersion = ttc.getUint16();
1381       const numFonts = ttc.getInt32() >>> 0;
1382       const offsetTable = [];
1383       for (let i = 0; i < numFonts; i++) {
1384         offsetTable.push(ttc.getInt32() >>> 0);
1385       }
1386 
1387       const header = {
1388         ttcTag,
1389         majorVersion,
1390         minorVersion,
1391         numFonts,
1392         offsetTable,
1393       };
1394       switch (majorVersion) {
1395         case 1:
1396           return header;
1397         case 2:
1398           header.dsigTag = ttc.getInt32() >>> 0;
1399           header.dsigLength = ttc.getInt32() >>> 0;
1400           header.dsigOffset = ttc.getInt32() >>> 0;
1401           return header;
1402       }
1403       throw new FormatError(
1404         `Invalid TrueType Collection majorVersion: ${majorVersion}.`
1405       );
1406     }
1407 
1408     function readTrueTypeCollectionData(ttc, fontName) {
1409       const { numFonts, offsetTable } = readTrueTypeCollectionHeader(ttc);
1410       const fontNameParts = fontName.split("+");
1411       let fallbackData;
1412 
1413       for (let i = 0; i < numFonts; i++) {
1414         ttc.pos = (ttc.start || 0) + offsetTable[i];
1415         const potentialHeader = readOpenTypeHeader(ttc);
1416         const potentialTables = readTables(ttc, potentialHeader.numTables);
1417 
1418         if (!potentialTables.name) {
1419           throw new FormatError(
1420             'TrueType Collection font must contain a "name" table.'
1421           );
1422         }
1423         const [nameTable] = readNameTable(potentialTables.name);
1424 
1425         for (let j = 0, jj = nameTable.length; j < jj; j++) {
1426           for (let k = 0, kk = nameTable[j].length; k < kk; k++) {
1427             const nameEntry = nameTable[j][k]?.replaceAll(/\s/g, "");
1428             if (!nameEntry) {
1429               continue;
1430             }
1431             if (nameEntry === fontName) {
1432               return {
1433                 header: potentialHeader,
1434                 tables: potentialTables,
1435               };
1436             }
1437             if (fontNameParts.length < 2) {
1438               continue;
1439             }
1440             for (const part of fontNameParts) {
1441               if (nameEntry === part) {
1442                 fallbackData = {
1443                   name: part,
1444                   header: potentialHeader,
1445                   tables: potentialTables,
1446                 };
1447               }
1448             }
1449           }
1450         }
1451       }
1452       if (fallbackData) {
1453         warn(
1454           `TrueType Collection does not contain "${fontName}" font, ` +
1455             `falling back to "${fallbackData.name}" font instead.`
1456         );
1457         return {
1458           header: fallbackData.header,
1459           tables: fallbackData.tables,
1460         };
1461       }
1462       throw new FormatError(
1463         `TrueType Collection does not contain "${fontName}" font.`
1464       );
1465     }
1466 
1467     /**
1468      * Read the appropriate subtable from the cmap according to 9.6.6.4 from
1469      * PDF spec
1470      */
1471     function readCmapTable(cmap, file, isSymbolicFont, hasEncoding) {
1472       if (!cmap) {
1473         warn("No cmap table available.");
1474         return {
1475           platformId: -1,
1476           encodingId: -1,
1477           mappings: [],
1478           hasShortCmap: false,
1479         };
1480       }
1481       let segment;
1482       let start = (file.start || 0) + cmap.offset;
1483       file.pos = start;
1484 
1485       file.skip(2); // version
1486       const numTables = file.getUint16();
1487 
1488       let potentialTable;
1489       let canBreak = false;
1490       // There's an order of preference in terms of which cmap subtable to
1491       // use:
1492       // - non-symbolic fonts the preference is a 3,1 table then a 1,0 table
1493       // - symbolic fonts the preference is a 3,0 table then a 1,0 table
1494       // The following takes advantage of the fact that the tables are sorted
1495       // to work.
1496       for (let i = 0; i < numTables; i++) {
1497         const platformId = file.getUint16();
1498         const encodingId = file.getUint16();
1499         const offset = file.getInt32() >>> 0;
1500         let useTable = false;
1501 
1502         // Sometimes there are multiple of the same type of table. Default
1503         // to choosing the first table and skip the rest.
1504         if (
1505           potentialTable?.platformId === platformId &&
1506           potentialTable?.encodingId === encodingId
1507         ) {
1508           continue;
1509         }
1510 
1511         if (
1512           platformId === 0 &&
1513           (encodingId === /* Unicode Default */ 0 ||
1514             encodingId === /* Unicode 1.1 */ 1 ||
1515             encodingId === /* Unicode BMP */ 3)
1516         ) {
1517           useTable = true;
1518           // Continue the loop since there still may be a higher priority
1519           // table.
1520         } else if (platformId === 1 && encodingId === 0) {
1521           useTable = true;
1522           // Continue the loop since there still may be a higher priority
1523           // table.
1524         } else if (
1525           platformId === 3 &&
1526           encodingId === 1 &&
1527           (hasEncoding || !potentialTable)
1528         ) {
1529           useTable = true;
1530           if (!isSymbolicFont) {
1531             canBreak = true;
1532           }
1533         } else if (isSymbolicFont && platformId === 3 && encodingId === 0) {
1534           useTable = true;
1535 
1536           let correctlySorted = true;
1537           if (i < numTables - 1) {
1538             const nextBytes = file.peekBytes(2),
1539               nextPlatformId = int16(nextBytes[0], nextBytes[1]);
1540             if (nextPlatformId < platformId) {
1541               correctlySorted = false;
1542             }
1543           }
1544           if (correctlySorted) {
1545             canBreak = true;
1546           }
1547         }
1548 
1549         if (useTable) {
1550           potentialTable = {
1551             platformId,
1552             encodingId,
1553             offset,
1554           };
1555         }
1556         if (canBreak) {
1557           break;
1558         }
1559       }
1560 
1561       if (potentialTable) {
1562         file.pos = start + potentialTable.offset;
1563       }
1564       if (!potentialTable || file.peekByte() === -1) {
1565         warn("Could not find a preferred cmap table.");
1566         return {
1567           platformId: -1,
1568           encodingId: -1,
1569           mappings: [],
1570           hasShortCmap: false,
1571         };
1572       }
1573 
1574       const format = file.getUint16();
1575       let hasShortCmap = false;
1576       const mappings = [];
1577       let j, glyphId;
1578 
1579       // TODO(mack): refactor this cmap subtable reading logic out
1580       if (format === 0) {
1581         file.skip(2 + 2); // length + language
1582 
1583         for (j = 0; j < 256; j++) {
1584           const index = file.getByte();
1585           if (!index) {
1586             continue;
1587           }
1588           mappings.push({
1589             charCode: j,
1590             glyphId: index,
1591           });
1592         }
1593         hasShortCmap = true;
1594       } else if (format === 2) {
1595         file.skip(2 + 2); // length + language
1596 
1597         const subHeaderKeys = [];
1598         let maxSubHeaderKey = 0;
1599         // Read subHeaderKeys. If subHeaderKeys[i] === 0, then i is a
1600         // single-byte character. Otherwise, i is the first byte of a
1601         // multi-byte character, and the value is 8*index into
1602         // subHeaders.
1603         for (let i = 0; i < 256; i++) {
1604           const subHeaderKey = file.getUint16() >> 3;
1605           subHeaderKeys.push(subHeaderKey);
1606           maxSubHeaderKey = Math.max(subHeaderKey, maxSubHeaderKey);
1607         }
1608         // Read subHeaders. The number of entries is determined
1609         // dynamically based on the subHeaderKeys found above.
1610         const subHeaders = [];
1611         for (let i = 0; i <= maxSubHeaderKey; i++) {
1612           subHeaders.push({
1613             firstCode: file.getUint16(),
1614             entryCount: file.getUint16(),
1615             idDelta: signedInt16(file.getByte(), file.getByte()),
1616             idRangePos: file.pos + file.getUint16(),
1617           });
1618         }
1619         for (let i = 0; i < 256; i++) {
1620           if (subHeaderKeys[i] === 0) {
1621             // i is a single-byte code.
1622             file.pos = subHeaders[0].idRangePos + 2 * i;
1623             glyphId = file.getUint16();
1624             mappings.push({
1625               charCode: i,
1626               glyphId,
1627             });
1628           } else {
1629             // i is the first byte of a two-byte code.
1630             const s = subHeaders[subHeaderKeys[i]];
1631             for (j = 0; j < s.entryCount; j++) {
1632               const charCode = (i << 8) + j + s.firstCode;
1633               file.pos = s.idRangePos + 2 * j;
1634               glyphId = file.getUint16();
1635               if (glyphId !== 0) {
1636                 glyphId = (glyphId + s.idDelta) % 65536;
1637               }
1638               mappings.push({
1639                 charCode,
1640                 glyphId,
1641               });
1642             }
1643           }
1644         }
1645       } else if (format === 4) {
1646         file.skip(2 + 2); // length + language
1647 
1648         // re-creating the table in format 4 since the encoding
1649         // might be changed
1650         const segCount = file.getUint16() >> 1;
1651         file.skip(6); // skipping range fields
1652         const segments = [];
1653         let segIndex;
1654         for (segIndex = 0; segIndex < segCount; segIndex++) {
1655           segments.push({ end: file.getUint16() });
1656         }
1657         file.skip(2);
1658         for (segIndex = 0; segIndex < segCount; segIndex++) {
1659           segments[segIndex].start = file.getUint16();
1660         }
1661 
1662         for (segIndex = 0; segIndex < segCount; segIndex++) {
1663           segments[segIndex].delta = file.getUint16();
1664         }
1665 
1666         let offsetsCount = 0,
1667           offsetIndex;
1668         for (segIndex = 0; segIndex < segCount; segIndex++) {
1669           segment = segments[segIndex];
1670           const rangeOffset = file.getUint16();
1671           if (!rangeOffset) {
1672             segment.offsetIndex = -1;
1673             continue;
1674           }
1675 
1676           offsetIndex = (rangeOffset >> 1) - (segCount - segIndex);
1677           segment.offsetIndex = offsetIndex;
1678           offsetsCount = Math.max(
1679             offsetsCount,
1680             offsetIndex + segment.end - segment.start + 1
1681           );
1682         }
1683 
1684         const offsets = [];
1685         for (j = 0; j < offsetsCount; j++) {
1686           offsets.push(file.getUint16());
1687         }
1688 
1689         for (segIndex = 0; segIndex < segCount; segIndex++) {
1690           segment = segments[segIndex];
1691           start = segment.start;
1692           const end = segment.end;
1693           const delta = segment.delta;
1694           offsetIndex = segment.offsetIndex;
1695 
1696           for (j = start; j <= end; j++) {
1697             if (j === 0xffff) {
1698               continue;
1699             }
1700 
1701             glyphId = offsetIndex < 0 ? j : offsets[offsetIndex + j - start];
1702             glyphId = (glyphId + delta) & 0xffff;
1703             mappings.push({
1704               charCode: j,
1705               glyphId,
1706             });
1707           }
1708         }
1709       } else if (format === 6) {
1710         file.skip(2 + 2); // length + language
1711 
1712         // Format 6 is a 2-bytes dense mapping, which means the font data
1713         // lives glue together even if they are pretty far in the unicode
1714         // table. (This looks weird, so I can have missed something), this
1715         // works on Linux but seems to fails on Mac so let's rewrite the
1716         // cmap table to a 3-1-4 style
1717         const firstCode = file.getUint16();
1718         const entryCount = file.getUint16();
1719 
1720         for (j = 0; j < entryCount; j++) {
1721           glyphId = file.getUint16();
1722           const charCode = firstCode + j;
1723 
1724           mappings.push({
1725             charCode,
1726             glyphId,
1727           });
1728         }
1729       } else if (format === 12) {
1730         file.skip(2 + 4 + 4); // reserved + length + language
1731 
1732         const nGroups = file.getInt32() >>> 0;
1733         for (j = 0; j < nGroups; j++) {
1734           const startCharCode = file.getInt32() >>> 0;
1735           const endCharCode = file.getInt32() >>> 0;
1736           let glyphCode = file.getInt32() >>> 0;
1737 
1738           for (
1739             let charCode = startCharCode;
1740             charCode <= endCharCode;
1741             charCode++
1742           ) {
1743             mappings.push({
1744               charCode,
1745               glyphId: glyphCode++,
1746             });
1747           }
1748         }
1749       } else {
1750         warn("cmap table has unsupported format: " + format);
1751         return {
1752           platformId: -1,
1753           encodingId: -1,
1754           mappings: [],
1755           hasShortCmap: false,
1756         };
1757       }
1758 
1759       // removing duplicate entries
1760       mappings.sort(function (a, b) {
1761         return a.charCode - b.charCode;
1762       });
1763       for (let i = 1; i < mappings.length; i++) {
1764         if (mappings[i - 1].charCode === mappings[i].charCode) {
1765           mappings.splice(i, 1);
1766           i--;
1767         }
1768       }
1769 
1770       return {
1771         platformId: potentialTable.platformId,
1772         encodingId: potentialTable.encodingId,
1773         mappings,
1774         hasShortCmap,
1775       };
1776     }
1777 
1778     function sanitizeMetrics(
1779       file,
1780       header,
1781       metrics,
1782       headTable,
1783       numGlyphs,
1784       dupFirstEntry
1785     ) {
1786       if (!header) {
1787         if (metrics) {
1788           metrics.data = null;
1789         }
1790         return;
1791       }
1792 
1793       file.pos = (file.start || 0) + header.offset;
1794       file.pos += 4; // version
1795       file.pos += 2; // ascent
1796       file.pos += 2; // descent
1797       file.pos += 2; // linegap
1798       file.pos += 2; // adv_width_max
1799       file.pos += 2; // min_sb1
1800       file.pos += 2; // min_sb2
1801       file.pos += 2; // max_extent
1802       file.pos += 2; // caret_slope_rise
1803       file.pos += 2; // caret_slope_run
1804       const caretOffset = file.getUint16();
1805       file.pos += 8; // reserved
1806       file.pos += 2; // format
1807       let numOfMetrics = file.getUint16();
1808 
1809       if (caretOffset !== 0) {
1810         const macStyle = int16(headTable.data[44], headTable.data[45]);
1811         if (!(macStyle & 2)) {
1812           // Suppress OTS warnings about the `caretOffset` in the hhea-table.
1813           header.data[22] = 0;
1814           header.data[23] = 0;
1815         }
1816       }
1817 
1818       if (numOfMetrics > numGlyphs) {
1819         info(
1820           `The numOfMetrics (${numOfMetrics}) should not be ` +
1821             `greater than the numGlyphs (${numGlyphs}).`
1822         );
1823         // Reduce numOfMetrics if it is greater than numGlyphs
1824         numOfMetrics = numGlyphs;
1825         header.data[34] = (numOfMetrics & 0xff00) >> 8;
1826         header.data[35] = numOfMetrics & 0x00ff;
1827       }
1828 
1829       const numOfSidebearings = numGlyphs - numOfMetrics;
1830       const numMissing =
1831         numOfSidebearings - ((metrics.length - numOfMetrics * 4) >> 1);
1832 
1833       if (numMissing > 0) {
1834         // For each missing glyph, we set both the width and lsb to 0 (zero).
1835         // Since we need to add two properties for each glyph, this explains
1836         // the use of |numMissing * 2| when initializing the typed array.
1837         const entries = new Uint8Array(metrics.length + numMissing * 2);
1838         entries.set(metrics.data);
1839         if (dupFirstEntry) {
1840           // Set the sidebearing value of the duplicated glyph.
1841           entries[metrics.length] = metrics.data[2];
1842           entries[metrics.length + 1] = metrics.data[3];
1843         }
1844         metrics.data = entries;
1845       }
1846     }
1847 
1848     function sanitizeGlyph(
1849       source,
1850       sourceStart,
1851       sourceEnd,
1852       dest,
1853       destStart,
1854       hintsValid
1855     ) {
1856       const glyphProfile = {
1857         length: 0,
1858         sizeOfInstructions: 0,
1859       };
1860       if (
1861         sourceStart < 0 ||
1862         sourceStart >= source.length ||
1863         sourceEnd > source.length ||
1864         sourceEnd - sourceStart <= 12
1865       ) {
1866         // If the offsets are wrong or the glyph is too small, remove it.
1867         return glyphProfile;
1868       }
1869       const glyf = source.subarray(sourceStart, sourceEnd);
1870 
1871       // Sanitize the glyph bounding box.
1872       const xMin = signedInt16(glyf[2], glyf[3]);
1873       const yMin = signedInt16(glyf[4], glyf[5]);
1874       const xMax = signedInt16(glyf[6], glyf[7]);
1875       const yMax = signedInt16(glyf[8], glyf[9]);
1876 
1877       if (xMin > xMax) {
1878         writeSignedInt16(glyf, 2, xMax);
1879         writeSignedInt16(glyf, 6, xMin);
1880       }
1881       if (yMin > yMax) {
1882         writeSignedInt16(glyf, 4, yMax);
1883         writeSignedInt16(glyf, 8, yMin);
1884       }
1885 
1886       const contoursCount = signedInt16(glyf[0], glyf[1]);
1887       if (contoursCount < 0) {
1888         if (contoursCount < -1) {
1889           // OTS doesn't like contour count to be less than -1.
1890           // The glyph data offsets are very likely wrong and
1891           // having something lower than -1, very likely, implies
1892           // to have some garbage data.
1893           return glyphProfile;
1894         }
1895         // complex glyph, writing as is
1896         dest.set(glyf, destStart);
1897         glyphProfile.length = glyf.length;
1898         return glyphProfile;
1899       }
1900 
1901       let i,
1902         j = 10,
1903         flagsCount = 0;
1904       for (i = 0; i < contoursCount; i++) {
1905         const endPoint = (glyf[j] << 8) | glyf[j + 1];
1906         flagsCount = endPoint + 1;
1907         j += 2;
1908       }
1909       // skipping instructions
1910       const instructionsStart = j;
1911       const instructionsLength = (glyf[j] << 8) | glyf[j + 1];
1912       glyphProfile.sizeOfInstructions = instructionsLength;
1913       j += 2 + instructionsLength;
1914       const instructionsEnd = j;
1915       // validating flags
1916       let coordinatesLength = 0;
1917       for (i = 0; i < flagsCount; i++) {
1918         const flag = glyf[j++];
1919         if (flag & 0xc0) {
1920           // reserved flags must be zero, cleaning up
1921           glyf[j - 1] = flag & 0x3f;
1922         }
1923         let xLength = 2;
1924         if (flag & 2) {
1925           xLength = 1;
1926         } else if (flag & 16) {
1927           xLength = 0;
1928         }
1929         let yLength = 2;
1930         if (flag & 4) {
1931           yLength = 1;
1932         } else if (flag & 32) {
1933           yLength = 0;
1934         }
1935         const xyLength = xLength + yLength;
1936         coordinatesLength += xyLength;
1937         if (flag & 8) {
1938           const repeat = glyf[j++];
1939           if (repeat === 0) {
1940             // The repeat count should be non-zero when the repeat flag is set.
1941             glyf[j - 1] ^= 8;
1942           }
1943           i += repeat;
1944           coordinatesLength += repeat * xyLength;
1945         }
1946       }
1947       // glyph without coordinates will be rejected
1948       if (coordinatesLength === 0) {
1949         return glyphProfile;
1950       }
1951       let glyphDataLength = j + coordinatesLength;
1952       if (glyphDataLength > glyf.length) {
1953         // not enough data for coordinates
1954         return glyphProfile;
1955       }
1956       if (!hintsValid && instructionsLength > 0) {
1957         dest.set(glyf.subarray(0, instructionsStart), destStart);
1958         dest.set([0, 0], destStart + instructionsStart);
1959         dest.set(
1960           glyf.subarray(instructionsEnd, glyphDataLength),
1961           destStart + instructionsStart + 2
1962         );
1963         glyphDataLength -= instructionsLength;
1964         if (glyf.length - glyphDataLength > 3) {
1965           glyphDataLength = (glyphDataLength + 3) & ~3;
1966         }
1967         glyphProfile.length = glyphDataLength;
1968         return glyphProfile;
1969       }
1970       if (glyf.length - glyphDataLength > 3) {
1971         // truncating and aligning to 4 bytes the long glyph data
1972         glyphDataLength = (glyphDataLength + 3) & ~3;
1973         dest.set(glyf.subarray(0, glyphDataLength), destStart);
1974         glyphProfile.length = glyphDataLength;
1975         return glyphProfile;
1976       }
1977       // glyph data is fine
1978       dest.set(glyf, destStart);
1979       glyphProfile.length = glyf.length;
1980       return glyphProfile;
1981     }
1982 
1983     function sanitizeHead(head, numGlyphs, locaLength) {
1984       const data = head.data;
1985 
1986       // Validate version:
1987       // Should always be 0x00010000
1988       const version = int32(data[0], data[1], data[2], data[3]);
1989       if (version >> 16 !== 1) {
1990         info("Attempting to fix invalid version in head table: " + version);
1991         data[0] = 0;
1992         data[1] = 1;
1993         data[2] = 0;
1994         data[3] = 0;
1995       }
1996 
1997       const indexToLocFormat = int16(data[50], data[51]);
1998       if (indexToLocFormat < 0 || indexToLocFormat > 1) {
1999         info(
2000           "Attempting to fix invalid indexToLocFormat in head table: " +
2001             indexToLocFormat
2002         );
2003 
2004         // The value of indexToLocFormat should be 0 if the loca table
2005         // consists of short offsets, and should be 1 if the loca table
2006         // consists of long offsets.
2007         //
2008         // The number of entries in the loca table should be numGlyphs + 1.
2009         //
2010         // Using this information, we can work backwards to deduce if the
2011         // size of each offset in the loca table, and thus figure out the
2012         // appropriate value for indexToLocFormat.
2013 
2014         const numGlyphsPlusOne = numGlyphs + 1;
2015         if (locaLength === numGlyphsPlusOne << 1) {
2016           // 0x0000 indicates the loca table consists of short offsets
2017           data[50] = 0;
2018           data[51] = 0;
2019         } else if (locaLength === numGlyphsPlusOne << 2) {
2020           // 0x0001 indicates the loca table consists of long offsets
2021           data[50] = 0;
2022           data[51] = 1;
2023         } else {
2024           throw new FormatError(
2025             "Could not fix indexToLocFormat: " + indexToLocFormat
2026           );
2027         }
2028       }
2029     }
2030 
2031     function sanitizeGlyphLocations(
2032       loca,
2033       glyf,
2034       numGlyphs,
2035       isGlyphLocationsLong,
2036       hintsValid,
2037       dupFirstEntry,
2038       maxSizeOfInstructions
2039     ) {
2040       let itemSize, itemDecode, itemEncode;
2041       if (isGlyphLocationsLong) {
2042         itemSize = 4;
2043         itemDecode = function fontItemDecodeLong(data, offset) {
2044           return (
2045             (data[offset] << 24) |
2046             (data[offset + 1] << 16) |
2047             (data[offset + 2] << 8) |
2048             data[offset + 3]
2049           );
2050         };
2051         itemEncode = function fontItemEncodeLong(data, offset, value) {
2052           data[offset] = (value >>> 24) & 0xff;
2053           data[offset + 1] = (value >> 16) & 0xff;
2054           data[offset + 2] = (value >> 8) & 0xff;
2055           data[offset + 3] = value & 0xff;
2056         };
2057       } else {
2058         itemSize = 2;
2059         itemDecode = function fontItemDecode(data, offset) {
2060           return (data[offset] << 9) | (data[offset + 1] << 1);
2061         };
2062         itemEncode = function fontItemEncode(data, offset, value) {
2063           data[offset] = (value >> 9) & 0xff;
2064           data[offset + 1] = (value >> 1) & 0xff;
2065         };
2066       }
2067       // The first glyph is duplicated.
2068       const numGlyphsOut = dupFirstEntry ? numGlyphs + 1 : numGlyphs;
2069       const locaDataSize = itemSize * (1 + numGlyphsOut);
2070       // Resize loca table to account for duplicated glyph.
2071       const locaData = new Uint8Array(locaDataSize);
2072       locaData.set(loca.data.subarray(0, locaDataSize));
2073       loca.data = locaData;
2074       // removing the invalid glyphs
2075       const oldGlyfData = glyf.data;
2076       const oldGlyfDataLength = oldGlyfData.length;
2077       const newGlyfData = new Uint8Array(oldGlyfDataLength);
2078 
2079       // The spec says the offsets should be in ascending order, however
2080       // this is not true for some fonts or they use the offset of 0 to mark a
2081       // glyph as missing. OTS requires the offsets to be in order and not to
2082       // be zero, so we must sort and rebuild the loca table and potentially
2083       // re-arrange the glyf data.
2084       let i, j;
2085       const locaEntries = [];
2086       // There are numGlyphs + 1 loca table entries.
2087       for (i = 0, j = 0; i < numGlyphs + 1; i++, j += itemSize) {
2088         let offset = itemDecode(locaData, j);
2089         if (offset > oldGlyfDataLength) {
2090           offset = oldGlyfDataLength;
2091         }
2092         locaEntries.push({
2093           index: i,
2094           offset,
2095           endOffset: 0,
2096         });
2097       }
2098       locaEntries.sort((a, b) => a.offset - b.offset);
2099       // Now the offsets are sorted, calculate the end offset of each glyph.
2100       // The last loca entry's endOffset is not calculated since it's the end
2101       // of the data and will be stored on the previous entry's endOffset.
2102       for (i = 0; i < numGlyphs; i++) {
2103         locaEntries[i].endOffset = locaEntries[i + 1].offset;
2104       }
2105       // Re-sort so glyphs aren't out of order.
2106       locaEntries.sort((a, b) => a.index - b.index);
2107       // Calculate the endOffset of the "first" glyph correctly when there are
2108       // *multiple* empty ones at the start of the data (fixes issue14618.pdf).
2109       for (i = 0; i < numGlyphs; i++) {
2110         const { offset, endOffset } = locaEntries[i];
2111         if (offset !== 0 || endOffset !== 0) {
2112           break;
2113         }
2114         const nextOffset = locaEntries[i + 1].offset;
2115         if (nextOffset === 0) {
2116           continue;
2117         }
2118         locaEntries[i].endOffset = nextOffset;
2119         break;
2120       }
2121 
2122       // If the last offset is 0 in the loca table then we can't compute the
2123       // endOffset for the last glyph. So in such a case we set the endOffset
2124       // to the end of the data (fixes issue #17671).
2125       const last = locaEntries.at(-2);
2126       if (last.offset !== 0 && last.endOffset === 0) {
2127         last.endOffset = oldGlyfDataLength;
2128       }
2129 
2130       const missingGlyphs = Object.create(null);
2131       let writeOffset = 0;
2132       itemEncode(locaData, 0, writeOffset);
2133       for (i = 0, j = itemSize; i < numGlyphs; i++, j += itemSize) {
2134         const glyphProfile = sanitizeGlyph(
2135           oldGlyfData,
2136           locaEntries[i].offset,
2137           locaEntries[i].endOffset,
2138           newGlyfData,
2139           writeOffset,
2140           hintsValid
2141         );
2142         const newLength = glyphProfile.length;
2143         if (newLength === 0) {
2144           missingGlyphs[i] = true;
2145         }
2146         if (glyphProfile.sizeOfInstructions > maxSizeOfInstructions) {
2147           maxSizeOfInstructions = glyphProfile.sizeOfInstructions;
2148         }
2149         writeOffset += newLength;
2150         itemEncode(locaData, j, writeOffset);
2151       }
2152 
2153       if (writeOffset === 0) {
2154         // glyf table cannot be empty -- redoing the glyf and loca tables
2155         // to have single glyph with one point
2156         const simpleGlyph = new Uint8Array([
2157           0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 49, 0,
2158         ]);
2159         for (i = 0, j = itemSize; i < numGlyphsOut; i++, j += itemSize) {
2160           itemEncode(locaData, j, simpleGlyph.length);
2161         }
2162         glyf.data = simpleGlyph;
2163       } else if (dupFirstEntry) {
2164         // Browsers will not display a glyph at position 0. Typically glyph 0
2165         // is notdef, but a number of fonts put a valid glyph there so it must
2166         // be duplicated and appended.
2167         const firstEntryLength = itemDecode(locaData, itemSize);
2168         if (newGlyfData.length > firstEntryLength + writeOffset) {
2169           glyf.data = newGlyfData.subarray(0, firstEntryLength + writeOffset);
2170         } else {
2171           glyf.data = new Uint8Array(firstEntryLength + writeOffset);
2172           glyf.data.set(newGlyfData.subarray(0, writeOffset));
2173         }
2174         glyf.data.set(newGlyfData.subarray(0, firstEntryLength), writeOffset);
2175         itemEncode(
2176           loca.data,
2177           locaData.length - itemSize,
2178           writeOffset + firstEntryLength
2179         );
2180       } else {
2181         glyf.data = newGlyfData.subarray(0, writeOffset);
2182       }
2183       return {
2184         missingGlyphs,
2185         maxSizeOfInstructions,
2186       };
2187     }
2188 
2189     function readPostScriptTable(post, propertiesObj, maxpNumGlyphs) {
2190       const start = (font.start || 0) + post.offset;
2191       font.pos = start;
2192 
2193       const length = post.length,
2194         end = start + length;
2195       const version = font.getInt32();
2196       // skip rest to the tables
2197       font.skip(28);
2198 
2199       let glyphNames;
2200       let valid = true;
2201       let i;
2202 
2203       switch (version) {
2204         case 0x00010000:
2205           glyphNames = MacStandardGlyphOrdering;
2206           break;
2207         case 0x00020000:
2208           const numGlyphs = font.getUint16();
2209           if (numGlyphs !== maxpNumGlyphs) {
2210             valid = false;
2211             break;
2212           }
2213           const glyphNameIndexes = [];
2214           for (i = 0; i < numGlyphs; ++i) {
2215             const index = font.getUint16();
2216             if (index >= 32768) {
2217               valid = false;
2218               break;
2219             }
2220             glyphNameIndexes.push(index);
2221           }
2222           if (!valid) {
2223             break;
2224           }
2225           const customNames = [],
2226             strBuf = [];
2227           while (font.pos < end) {
2228             const stringLength = font.getByte();
2229             strBuf.length = stringLength;
2230             for (i = 0; i < stringLength; ++i) {
2231               strBuf[i] = String.fromCharCode(font.getByte());
2232             }
2233             customNames.push(strBuf.join(""));
2234           }
2235           glyphNames = [];
2236           for (i = 0; i < numGlyphs; ++i) {
2237             const j = glyphNameIndexes[i];
2238             if (j < 258) {
2239               glyphNames.push(MacStandardGlyphOrdering[j]);
2240               continue;
2241             }
2242             glyphNames.push(customNames[j - 258]);
2243           }
2244           break;
2245         case 0x00030000:
2246           break;
2247         default:
2248           warn("Unknown/unsupported post table version " + version);
2249           valid = false;
2250           if (propertiesObj.defaultEncoding) {
2251             glyphNames = propertiesObj.defaultEncoding;
2252           }
2253           break;
2254       }
2255       propertiesObj.glyphNames = glyphNames;
2256       return valid;
2257     }
2258 
2259     function readNameTable(nameTable) {
2260       const start = (font.start || 0) + nameTable.offset;
2261       font.pos = start;
2262 
2263       const names = [[], []],
2264         records = [];
2265       const length = nameTable.length,
2266         end = start + length;
2267       const format = font.getUint16();
2268       const FORMAT_0_HEADER_LENGTH = 6;
2269       if (format !== 0 || length < FORMAT_0_HEADER_LENGTH) {
2270         // unsupported name table format or table "too" small
2271         return [names, records];
2272       }
2273       const numRecords = font.getUint16();
2274       const stringsStart = font.getUint16();
2275       const NAME_RECORD_LENGTH = 12;
2276       let i, ii;
2277 
2278       for (i = 0; i < numRecords && font.pos + NAME_RECORD_LENGTH <= end; i++) {
2279         const r = {
2280           platform: font.getUint16(),
2281           encoding: font.getUint16(),
2282           language: font.getUint16(),
2283           name: font.getUint16(),
2284           length: font.getUint16(),
2285           offset: font.getUint16(),
2286         };
2287         // using only Macintosh and Windows platform/encoding names
2288         if (isMacNameRecord(r) || isWinNameRecord(r)) {
2289           records.push(r);
2290         }
2291       }
2292       for (i = 0, ii = records.length; i < ii; i++) {
2293         const record = records[i];
2294         if (record.length <= 0) {
2295           continue; // Nothing to process, ignoring.
2296         }
2297         const pos = start + stringsStart + record.offset;
2298         if (pos + record.length > end) {
2299           continue; // outside of name table, ignoring
2300         }
2301         font.pos = pos;
2302         const nameIndex = record.name;
2303         if (record.encoding) {
2304           // unicode
2305           let str = "";
2306           for (let j = 0, jj = record.length; j < jj; j += 2) {
2307             str += String.fromCharCode(font.getUint16());
2308           }
2309           names[1][nameIndex] = str;
2310         } else {
2311           names[0][nameIndex] = font.getString(record.length);
2312         }
2313       }
2314       return [names, records];
2315     }
2316 
2317     // prettier-ignore
2318     const TTOpsStackDeltas = [
2319       0, 0, 0, 0, 0, 0, 0, 0, -2, -2, -2, -2, 0, 0, -2, -5,
2320       -1, -1, -1, -1, -1, -1, -1, -1, 0, 0, -1, 0, -1, -1, -1, -1,
2321       1, -1, -999, 0, 1, 0, -1, -2, 0, -1, -2, -1, -1, 0, -1, -1,
2322       0, 0, -999, -999, -1, -1, -1, -1, -2, -999, -2, -2, -999, 0, -2, -2,
2323       0, 0, -2, 0, -2, 0, 0, 0, -2, -1, -1, 1, 1, 0, 0, -1,
2324       -1, -1, -1, -1, -1, -1, 0, 0, -1, 0, -1, -1, 0, -999, -1, -1,
2325       -1, -1, -1, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
2326       -2, -999, -999, -999, -999, -999, -1, -1, -2, -2, 0, 0, 0, 0, -1, -1,
2327       -999, -2, -2, 0, 0, -1, -2, -2, 0, 0, 0, -1, -1, -1, -2];
2328     // 0xC0-DF == -1 and 0xE0-FF == -2
2329 
2330     function sanitizeTTProgram(table, ttContext) {
2331       let data = table.data;
2332       let i = 0,
2333         j,
2334         n,
2335         b,
2336         funcId,
2337         pc,
2338         lastEndf = 0,
2339         lastDeff = 0;
2340       const stack = [];
2341       const callstack = [];
2342       const functionsCalled = [];
2343       let tooComplexToFollowFunctions = ttContext.tooComplexToFollowFunctions;
2344       let inFDEF = false,
2345         ifLevel = 0,
2346         inELSE = 0;
2347       for (let ii = data.length; i < ii; ) {
2348         const op = data[i++];
2349         // The TrueType instruction set docs can be found at
2350         // https://developer.apple.com/fonts/TTRefMan/RM05/Chap5.html
2351         if (op === 0x40) {
2352           // NPUSHB - pushes n bytes
2353           n = data[i++];
2354           if (inFDEF || inELSE) {
2355             i += n;
2356           } else {
2357             for (j = 0; j < n; j++) {
2358               stack.push(data[i++]);
2359             }
2360           }
2361         } else if (op === 0x41) {
2362           // NPUSHW - pushes n words
2363           n = data[i++];
2364           if (inFDEF || inELSE) {
2365             i += n * 2;
2366           } else {
2367             for (j = 0; j < n; j++) {
2368               b = data[i++];
2369               stack.push((b << 8) | data[i++]);
2370             }
2371           }
2372         } else if ((op & 0xf8) === 0xb0) {
2373           // PUSHB - pushes bytes
2374           n = op - 0xb0 + 1;
2375           if (inFDEF || inELSE) {
2376             i += n;
2377           } else {
2378             for (j = 0; j < n; j++) {
2379               stack.push(data[i++]);
2380             }
2381           }
2382         } else if ((op & 0xf8) === 0xb8) {
2383           // PUSHW - pushes words
2384           n = op - 0xb8 + 1;
2385           if (inFDEF || inELSE) {
2386             i += n * 2;
2387           } else {
2388             for (j = 0; j < n; j++) {
2389               b = data[i++];
2390               stack.push((b << 8) | data[i++]);
2391             }
2392           }
2393         } else if (op === 0x2b && !tooComplexToFollowFunctions) {
2394           // CALL
2395           if (!inFDEF && !inELSE) {
2396             // collecting information about which functions are used
2397             funcId = stack.at(-1);
2398             if (isNaN(funcId)) {
2399               info("TT: CALL empty stack (or invalid entry).");
2400             } else {
2401               ttContext.functionsUsed[funcId] = true;
2402               if (funcId in ttContext.functionsStackDeltas) {
2403                 const newStackLength =
2404                   stack.length + ttContext.functionsStackDeltas[funcId];
2405                 if (newStackLength < 0) {
2406                   warn("TT: CALL invalid functions stack delta.");
2407                   ttContext.hintsValid = false;
2408                   return;
2409                 }
2410                 stack.length = newStackLength;
2411               } else if (
2412                 funcId in ttContext.functionsDefined &&
2413                 !functionsCalled.includes(funcId)
2414               ) {
2415                 callstack.push({ data, i, stackTop: stack.length - 1 });
2416                 functionsCalled.push(funcId);
2417                 pc = ttContext.functionsDefined[funcId];
2418                 if (!pc) {
2419                   warn("TT: CALL non-existent function");
2420                   ttContext.hintsValid = false;
2421                   return;
2422                 }
2423                 data = pc.data;
2424                 i = pc.i;
2425               }
2426             }
2427           }
2428         } else if (op === 0x2c && !tooComplexToFollowFunctions) {
2429           // FDEF
2430           if (inFDEF || inELSE) {
2431             warn("TT: nested FDEFs not allowed");
2432             tooComplexToFollowFunctions = true;
2433           }
2434           inFDEF = true;
2435           // collecting information about which functions are defined
2436           lastDeff = i;
2437           funcId = stack.pop();
2438           ttContext.functionsDefined[funcId] = { data, i };
2439         } else if (op === 0x2d) {
2440           // ENDF - end of function
2441           if (inFDEF) {
2442             inFDEF = false;
2443             lastEndf = i;
2444           } else {
2445             pc = callstack.pop();
2446             if (!pc) {
2447               warn("TT: ENDF bad stack");
2448               ttContext.hintsValid = false;
2449               return;
2450             }
2451             funcId = functionsCalled.pop();
2452             data = pc.data;
2453             i = pc.i;
2454             ttContext.functionsStackDeltas[funcId] = stack.length - pc.stackTop;
2455           }
2456         } else if (op === 0x89) {
2457           // IDEF - instruction definition
2458           if (inFDEF || inELSE) {
2459             warn("TT: nested IDEFs not allowed");
2460             tooComplexToFollowFunctions = true;
2461           }
2462           inFDEF = true;
2463           // recording it as a function to track ENDF
2464           lastDeff = i;
2465         } else if (op === 0x58) {
2466           // IF
2467           ++ifLevel;
2468         } else if (op === 0x1b) {
2469           // ELSE
2470           inELSE = ifLevel;
2471         } else if (op === 0x59) {
2472           // EIF
2473           if (inELSE === ifLevel) {
2474             inELSE = 0;
2475           }
2476           --ifLevel;
2477         } else if (op === 0x1c) {
2478           // JMPR
2479           if (!inFDEF && !inELSE) {
2480             const offset = stack.at(-1);
2481             // only jumping forward to prevent infinite loop
2482             if (offset > 0) {
2483               i += offset - 1;
2484             }
2485           }
2486         }
2487         // Adjusting stack not extactly, but just enough to get function id
2488         if (!inFDEF && !inELSE) {
2489           let stackDelta = 0;
2490           if (op <= 0x8e) {
2491             stackDelta = TTOpsStackDeltas[op];
2492           } else if (op >= 0xc0 && op <= 0xdf) {
2493             stackDelta = -1;
2494           } else if (op >= 0xe0) {
2495             stackDelta = -2;
2496           }
2497           if (op >= 0x71 && op <= 0x75) {
2498             n = stack.pop();
2499             if (!isNaN(n)) {
2500               stackDelta = -n * 2;
2501             }
2502           }
2503           while (stackDelta < 0 && stack.length > 0) {
2504             stack.pop();
2505             stackDelta++;
2506           }
2507           while (stackDelta > 0) {
2508             stack.push(NaN); // pushing any number into stack
2509             stackDelta--;
2510           }
2511         }
2512       }
2513       ttContext.tooComplexToFollowFunctions = tooComplexToFollowFunctions;
2514       const content = [data];
2515       if (i > data.length) {
2516         content.push(new Uint8Array(i - data.length));
2517       }
2518       if (lastDeff > lastEndf) {
2519         warn("TT: complementing a missing function tail");
2520         // new function definition started, but not finished
2521         // complete function by [CLEAR, ENDF]
2522         content.push(new Uint8Array([0x22, 0x2d]));
2523       }
2524       foldTTTable(table, content);
2525     }
2526 
2527     function checkInvalidFunctions(ttContext, maxFunctionDefs) {
2528       if (ttContext.tooComplexToFollowFunctions) {
2529         return;
2530       }
2531       if (ttContext.functionsDefined.length > maxFunctionDefs) {
2532         warn("TT: more functions defined than expected");
2533         ttContext.hintsValid = false;
2534         return;
2535       }
2536       for (let j = 0, jj = ttContext.functionsUsed.length; j < jj; j++) {
2537         if (j > maxFunctionDefs) {
2538           warn("TT: invalid function id: " + j);
2539           ttContext.hintsValid = false;
2540           return;
2541         }
2542         if (ttContext.functionsUsed[j] && !ttContext.functionsDefined[j]) {
2543           warn("TT: undefined function: " + j);
2544           ttContext.hintsValid = false;
2545           return;
2546         }
2547       }
2548     }
2549 
2550     function foldTTTable(table, content) {
2551       if (content.length > 1) {
2552         // concatenating the content items
2553         let newLength = 0;
2554         let j, jj;
2555         for (j = 0, jj = content.length; j < jj; j++) {
2556           newLength += content[j].length;
2557         }
2558         newLength = (newLength + 3) & ~3;
2559         const result = new Uint8Array(newLength);
2560         let pos = 0;
2561         for (j = 0, jj = content.length; j < jj; j++) {
2562           result.set(content[j], pos);
2563           pos += content[j].length;
2564         }
2565         table.data = result;
2566         table.length = newLength;
2567       }
2568     }
2569 
2570     function sanitizeTTPrograms(fpgm, prep, cvt, maxFunctionDefs) {
2571       const ttContext = {
2572         functionsDefined: [],
2573         functionsUsed: [],
2574         functionsStackDeltas: [],
2575         tooComplexToFollowFunctions: false,
2576         hintsValid: true,
2577       };
2578       if (fpgm) {
2579         sanitizeTTProgram(fpgm, ttContext);
2580       }
2581       if (prep) {
2582         sanitizeTTProgram(prep, ttContext);
2583       }
2584       if (fpgm) {
2585         checkInvalidFunctions(ttContext, maxFunctionDefs);
2586       }
2587       if (cvt && cvt.length & 1) {
2588         const cvtData = new Uint8Array(cvt.length + 1);
2589         cvtData.set(cvt.data);
2590         cvt.data = cvtData;
2591       }
2592       return ttContext.hintsValid;
2593     }
2594 
2595     // The following steps modify the original font data, making copy
2596     font = new Stream(new Uint8Array(font.getBytes()));
2597 
2598     let header, tables;
2599     if (isTrueTypeCollectionFile(font)) {
2600       const ttcData = readTrueTypeCollectionData(font, this.name);
2601       header = ttcData.header;
2602       tables = ttcData.tables;
2603     } else {
2604       header = readOpenTypeHeader(font);
2605       tables = readTables(font, header.numTables);
2606     }
2607     let cff, cffFile;
2608 
2609     const isTrueType = !tables["CFF "];
2610     if (!isTrueType) {
2611       const isComposite =
2612         properties.composite &&
2613         (properties.cidToGidMap?.length > 0 ||
2614           !(properties.cMap instanceof IdentityCMap));
2615       // OpenType font (skip composite fonts with non-default glyph mapping).
2616       if (
2617         (header.version === "OTTO" && !isComposite) ||
2618         !tables.head ||
2619         !tables.hhea ||
2620         !tables.maxp ||
2621         !tables.post
2622       ) {
2623         // No major tables: throwing everything at `CFFFont`.
2624         cffFile = new Stream(tables["CFF "].data);
2625         cff = new CFFFont(cffFile, properties);
2626 
2627         adjustWidths(properties);
2628 
2629         return this.convert(name, cff, properties);
2630       }
2631 
2632       delete tables.glyf;
2633       delete tables.loca;
2634       delete tables.fpgm;
2635       delete tables.prep;
2636       delete tables["cvt "];
2637       this.isOpenType = true;
2638     } else {
2639       if (!tables.loca) {
2640         throw new FormatError('Required "loca" table is not found');
2641       }
2642       if (!tables.glyf) {
2643         warn('Required "glyf" table is not found -- trying to recover.');
2644         // Note: We use `sanitizeGlyphLocations` to add dummy glyf data below.
2645         tables.glyf = {
2646           tag: "glyf",
2647           data: new Uint8Array(0),
2648         };
2649       }
2650       this.isOpenType = false;
2651     }
2652 
2653     if (!tables.maxp) {
2654       throw new FormatError('Required "maxp" table is not found');
2655     }
2656 
2657     font.pos = (font.start || 0) + tables.maxp.offset;
2658     let version = font.getInt32();
2659     const numGlyphs = font.getUint16();
2660 
2661     if (version !== 0x00010000 && version !== 0x00005000) {
2662       // https://learn.microsoft.com/en-us/typography/opentype/spec/maxp
2663       if (tables.maxp.length === 6) {
2664         version = 0x0005000;
2665       } else if (tables.maxp.length >= 32) {
2666         version = 0x00010000;
2667       } else {
2668         throw new FormatError(`"maxp" table has a wrong version number`);
2669       }
2670       writeUint32(tables.maxp.data, 0, version);
2671     }
2672 
2673     if (properties.scaleFactors?.length === numGlyphs && isTrueType) {
2674       const { scaleFactors } = properties;
2675       const isGlyphLocationsLong = int16(
2676         tables.head.data[50],
2677         tables.head.data[51]
2678       );
2679 
2680       const glyphs = new GlyfTable({
2681         glyfTable: tables.glyf.data,
2682         isGlyphLocationsLong,
2683         locaTable: tables.loca.data,
2684         numGlyphs,
2685       });
2686       glyphs.scale(scaleFactors);
2687 
2688       const { glyf, loca, isLocationLong } = glyphs.write();
2689       tables.glyf.data = glyf;
2690       tables.loca.data = loca;
2691 
2692       if (isLocationLong !== !!isGlyphLocationsLong) {
2693         tables.head.data[50] = 0;
2694         tables.head.data[51] = isLocationLong ? 1 : 0;
2695       }
2696 
2697       const metrics = tables.hmtx.data;
2698 
2699       for (let i = 0; i < numGlyphs; i++) {
2700         const j = 4 * i;
2701         const advanceWidth = Math.round(
2702           scaleFactors[i] * int16(metrics[j], metrics[j + 1])
2703         );
2704         metrics[j] = (advanceWidth >> 8) & 0xff;
2705         metrics[j + 1] = advanceWidth & 0xff;
2706         const lsb = Math.round(
2707           scaleFactors[i] * signedInt16(metrics[j + 2], metrics[j + 3])
2708         );
2709         writeSignedInt16(metrics, j + 2, lsb);
2710       }
2711     }
2712 
2713     // Glyph 0 is duplicated and appended.
2714     let numGlyphsOut = numGlyphs + 1;
2715     let dupFirstEntry = true;
2716     if (numGlyphsOut > 0xffff) {
2717       dupFirstEntry = false;
2718       numGlyphsOut = numGlyphs;
2719       warn("Not enough space in glyfs to duplicate first glyph.");
2720     }
2721     let maxFunctionDefs = 0;
2722     let maxSizeOfInstructions = 0;
2723     if (version >= 0x00010000 && tables.maxp.length >= 32) {
2724       // maxZones can be invalid
2725       font.pos += 8;
2726       const maxZones = font.getUint16();
2727       if (maxZones > 2) {
2728         // reset to 2 if font has invalid maxZones
2729         tables.maxp.data[14] = 0;
2730         tables.maxp.data[15] = 2;
2731       }
2732       font.pos += 4;
2733       maxFunctionDefs = font.getUint16();
2734       font.pos += 4;
2735       maxSizeOfInstructions = font.getUint16();
2736     }
2737 
2738     tables.maxp.data[4] = numGlyphsOut >> 8;
2739     tables.maxp.data[5] = numGlyphsOut & 255;
2740 
2741     const hintsValid = sanitizeTTPrograms(
2742       tables.fpgm,
2743       tables.prep,
2744       tables["cvt "],
2745       maxFunctionDefs
2746     );
2747     if (!hintsValid) {
2748       delete tables.fpgm;
2749       delete tables.prep;
2750       delete tables["cvt "];
2751     }
2752 
2753     // Ensure the hmtx table contains the advance width and
2754     // sidebearings information for numGlyphs in the maxp table
2755     sanitizeMetrics(
2756       font,
2757       tables.hhea,
2758       tables.hmtx,
2759       tables.head,
2760       numGlyphsOut,
2761       dupFirstEntry
2762     );
2763 
2764     if (!tables.head) {
2765       throw new FormatError('Required "head" table is not found');
2766     }
2767 
2768     sanitizeHead(tables.head, numGlyphs, isTrueType ? tables.loca.length : 0);
2769 
2770     let missingGlyphs = Object.create(null);
2771     if (isTrueType) {
2772       const isGlyphLocationsLong = int16(
2773         tables.head.data[50],
2774         tables.head.data[51]
2775       );
2776       const glyphsInfo = sanitizeGlyphLocations(
2777         tables.loca,
2778         tables.glyf,
2779         numGlyphs,
2780         isGlyphLocationsLong,
2781         hintsValid,
2782         dupFirstEntry,
2783         maxSizeOfInstructions
2784       );
2785       missingGlyphs = glyphsInfo.missingGlyphs;
2786 
2787       // Some fonts have incorrect maxSizeOfInstructions values, so we use
2788       // the computed value instead.
2789       if (version >= 0x00010000 && tables.maxp.length >= 32) {
2790         tables.maxp.data[26] = glyphsInfo.maxSizeOfInstructions >> 8;
2791         tables.maxp.data[27] = glyphsInfo.maxSizeOfInstructions & 255;
2792       }
2793     }
2794     if (!tables.hhea) {
2795       throw new FormatError('Required "hhea" table is not found');
2796     }
2797 
2798     // Sanitizer reduces the glyph advanceWidth to the maxAdvanceWidth
2799     // Sometimes it's 0. That needs to be fixed
2800     if (tables.hhea.data[10] === 0 && tables.hhea.data[11] === 0) {
2801       tables.hhea.data[10] = 0xff;
2802       tables.hhea.data[11] = 0xff;
2803     }
2804 
2805     // Extract some more font properties from the OpenType head and
2806     // hhea tables; yMin and descent value are always negative.
2807     const metricsOverride = {
2808       unitsPerEm: int16(tables.head.data[18], tables.head.data[19]),
2809       yMax: signedInt16(tables.head.data[42], tables.head.data[43]),
2810       yMin: signedInt16(tables.head.data[38], tables.head.data[39]),
2811       ascent: signedInt16(tables.hhea.data[4], tables.hhea.data[5]),
2812       descent: signedInt16(tables.hhea.data[6], tables.hhea.data[7]),
2813       lineGap: signedInt16(tables.hhea.data[8], tables.hhea.data[9]),
2814     };
2815 
2816     // PDF FontDescriptor metrics lie -- using data from actual font.
2817     this.ascent = metricsOverride.ascent / metricsOverride.unitsPerEm;
2818     this.descent = metricsOverride.descent / metricsOverride.unitsPerEm;
2819     this.lineGap = metricsOverride.lineGap / metricsOverride.unitsPerEm;
2820 
2821     if (this.cssFontInfo?.lineHeight) {
2822       this.lineHeight = this.cssFontInfo.metrics.lineHeight;
2823       this.lineGap = this.cssFontInfo.metrics.lineGap;
2824     } else {
2825       this.lineHeight = this.ascent - this.descent + this.lineGap;
2826     }
2827 
2828     // The 'post' table has glyphs names.
2829     if (tables.post) {
2830       readPostScriptTable(tables.post, properties, numGlyphs);
2831     }
2832 
2833     // The original 'post' table is not needed, replace it.
2834     tables.post = {
2835       tag: "post",
2836       data: createPostTable(properties),
2837     };
2838 
2839     const charCodeToGlyphId = Object.create(null);
2840 
2841     // Helper function to try to skip mapping of empty glyphs.
2842     function hasGlyph(glyphId) {
2843       return !missingGlyphs[glyphId];
2844     }
2845 
2846     if (properties.composite) {
2847       const cidToGidMap = properties.cidToGidMap || [];
2848       const isCidToGidMapEmpty = cidToGidMap.length === 0;
2849 
2850       properties.cMap.forEach(function (charCode, cid) {
2851         if (typeof cid === "string") {
2852           cid = convertCidString(charCode, cid, /* shouldThrow = */ true);
2853         }
2854         if (cid > 0xffff) {
2855           throw new FormatError("Max size of CID is 65,535");
2856         }
2857         let glyphId = -1;
2858         if (isCidToGidMapEmpty) {
2859           glyphId = cid;
2860         } else if (cidToGidMap[cid] !== undefined) {
2861           glyphId = cidToGidMap[cid];
2862         }
2863 
2864         if (glyphId >= 0 && glyphId < numGlyphs && hasGlyph(glyphId)) {
2865           charCodeToGlyphId[charCode] = glyphId;
2866         }
2867       });
2868     } else {
2869       // Most of the following logic in this code branch is based on the
2870       // 9.6.6.4 of the PDF spec.
2871       const cmapTable = readCmapTable(
2872         tables.cmap,
2873         font,
2874         this.isSymbolicFont,
2875         properties.hasEncoding
2876       );
2877       const cmapPlatformId = cmapTable.platformId;
2878       const cmapEncodingId = cmapTable.encodingId;
2879       const cmapMappings = cmapTable.mappings;
2880       let baseEncoding = [],
2881         forcePostTable = false;
2882       if (
2883         properties.hasEncoding &&
2884         (properties.baseEncodingName === "MacRomanEncoding" ||
2885           properties.baseEncodingName === "WinAnsiEncoding")
2886       ) {
2887         baseEncoding = getEncoding(properties.baseEncodingName);
2888       }
2889 
2890       // If the font has an encoding and is not symbolic then follow the rules
2891       // in section 9.6.6.4 of the spec on how to map 3,1 and 1,0 cmaps.
2892       if (
2893         properties.hasEncoding &&
2894         !this.isSymbolicFont &&
2895         ((cmapPlatformId === 3 && cmapEncodingId === 1) ||
2896           (cmapPlatformId === 1 && cmapEncodingId === 0))
2897       ) {
2898         const glyphsUnicodeMap = getGlyphsUnicode();
2899         for (let charCode = 0; charCode < 256; charCode++) {
2900           let glyphName;
2901           if (this.differences[charCode] !== undefined) {
2902             glyphName = this.differences[charCode];
2903           } else if (baseEncoding.length && baseEncoding[charCode] !== "") {
2904             glyphName = baseEncoding[charCode];
2905           } else {
2906             glyphName = StandardEncoding[charCode];
2907           }
2908           if (!glyphName) {
2909             continue;
2910           }
2911           // Ensure that non-standard glyph names are resolved to valid ones.
2912           const standardGlyphName = recoverGlyphName(
2913             glyphName,
2914             glyphsUnicodeMap
2915           );
2916 
2917           let unicodeOrCharCode;
2918           if (cmapPlatformId === 3 && cmapEncodingId === 1) {
2919             unicodeOrCharCode = glyphsUnicodeMap[standardGlyphName];
2920           } else if (cmapPlatformId === 1 && cmapEncodingId === 0) {
2921             // TODO: the encoding needs to be updated with mac os table.
2922             unicodeOrCharCode = MacRomanEncoding.indexOf(standardGlyphName);
2923           }
2924 
2925           if (unicodeOrCharCode === undefined) {
2926             // Not a valid glyph name, fallback to using the /ToUnicode map
2927             // when no post-table exists (fixes issue13316_reduced.pdf).
2928             if (
2929               !properties.glyphNames &&
2930               properties.hasIncludedToUnicodeMap &&
2931               !(this.toUnicode instanceof IdentityToUnicodeMap)
2932             ) {
2933               const unicode = this.toUnicode.get(charCode);
2934               if (unicode) {
2935                 unicodeOrCharCode = unicode.codePointAt(0);
2936               }
2937             }
2938 
2939             if (unicodeOrCharCode === undefined) {
2940               continue; // No valid glyph mapping found.
2941             }
2942           }
2943 
2944           for (const mapping of cmapMappings) {
2945             if (mapping.charCode !== unicodeOrCharCode) {
2946               continue;
2947             }
2948             charCodeToGlyphId[charCode] = mapping.glyphId;
2949             break;
2950           }
2951         }
2952       } else if (cmapPlatformId === 0) {
2953         // Default Unicode semantics, use the charcodes as is.
2954         for (const mapping of cmapMappings) {
2955           charCodeToGlyphId[mapping.charCode] = mapping.glyphId;
2956         }
2957         // Always prefer the BaseEncoding/Differences arrays, when they exist
2958         // (fixes issue13433.pdf).
2959         forcePostTable = true;
2960       } else if (cmapPlatformId === 3 && cmapEncodingId === 0) {
2961         // When a (3, 0) cmap table is present, it is used instead but the
2962         // spec has special rules for char codes in the range of 0xF000 to
2963         // 0xF0FF and it says the (3, 0) table should map the values from
2964         // the (1, 0) table by prepending 0xF0 to the char codes. To reverse
2965         // this, the upper bits of the char code are cleared, but only for the
2966         // special range since some PDFs have char codes outside of this range
2967         // (e.g. 0x2013) which when masked would overwrite other values in the
2968         // cmap.
2969         for (const mapping of cmapMappings) {
2970           let charCode = mapping.charCode;
2971           if (charCode >= 0xf000 && charCode <= 0xf0ff) {
2972             charCode &= 0xff;
2973           }
2974           charCodeToGlyphId[charCode] = mapping.glyphId;
2975         }
2976       } else {
2977         // When there is only a (1, 0) cmap table, the char code is a single
2978         // byte and it is used directly as the char code.
2979         for (const mapping of cmapMappings) {
2980           charCodeToGlyphId[mapping.charCode] = mapping.glyphId;
2981         }
2982       }
2983 
2984       // Last, try to map any missing charcodes using the post table.
2985       if (
2986         properties.glyphNames &&
2987         (baseEncoding.length || this.differences.length)
2988       ) {
2989         for (let i = 0; i < 256; ++i) {
2990           if (!forcePostTable && charCodeToGlyphId[i] !== undefined) {
2991             continue;
2992           }
2993           const glyphName = this.differences[i] || baseEncoding[i];
2994           if (!glyphName) {
2995             continue;
2996           }
2997           const glyphId = properties.glyphNames.indexOf(glyphName);
2998           if (glyphId > 0 && hasGlyph(glyphId)) {
2999             charCodeToGlyphId[i] = glyphId;
3000           }
3001         }
3002       }
3003     }
3004 
3005     if (charCodeToGlyphId.length === 0) {
3006       // defines at least one glyph
3007       charCodeToGlyphId[0] = 0;
3008     }
3009 
3010     // Typically glyph 0 is duplicated and the mapping must be updated, but if
3011     // there isn't enough room to duplicate, the glyph id is left the same. In
3012     // this case, glyph 0 may not work correctly, but that is better than
3013     // having the whole font fail.
3014     let glyphZeroId = numGlyphsOut - 1;
3015     if (!dupFirstEntry) {
3016       glyphZeroId = 0;
3017     }
3018 
3019     // When `cssFontInfo` is set, the font is used to render text in the HTML
3020     // view (e.g. with Xfa) so nothing must be moved in the private use area.
3021     if (!properties.cssFontInfo) {
3022       // Converting glyphs and ids into font's cmap table
3023       const newMapping = adjustMapping(
3024         charCodeToGlyphId,
3025         hasGlyph,
3026         glyphZeroId,
3027         this.toUnicode
3028       );
3029       this.toFontChar = newMapping.toFontChar;
3030       tables.cmap = {
3031         tag: "cmap",
3032         data: createCmapTable(
3033           newMapping.charCodeToGlyphId,
3034           newMapping.toUnicodeExtraMap,
3035           numGlyphsOut
3036         ),
3037       };
3038 
3039       if (!tables["OS/2"] || !validateOS2Table(tables["OS/2"], font)) {
3040         tables["OS/2"] = {
3041           tag: "OS/2",
3042           data: createOS2Table(
3043             properties,
3044             newMapping.charCodeToGlyphId,
3045             metricsOverride
3046           ),
3047         };
3048       }
3049     }
3050 
3051     if (!isTrueType) {
3052       try {
3053         // Trying to repair CFF file
3054         cffFile = new Stream(tables["CFF "].data);
3055         const parser = new CFFParser(
3056           cffFile,
3057           properties,
3058           SEAC_ANALYSIS_ENABLED
3059         );
3060         cff = parser.parse();
3061         cff.duplicateFirstGlyph();
3062         const compiler = new CFFCompiler(cff);
3063         tables["CFF "].data = compiler.compile();
3064       } catch {
3065         warn("Failed to compile font " + properties.loadedName);
3066       }
3067     }
3068 
3069     // Re-creating 'name' table
3070     if (!tables.name) {
3071       tables.name = {
3072         tag: "name",
3073         data: createNameTable(this.name),
3074       };
3075     } else {
3076       // ... using existing 'name' table as prototype
3077       const [namePrototype, nameRecords] = readNameTable(tables.name);
3078 
3079       tables.name.data = createNameTable(name, namePrototype);
3080       this.psName = namePrototype[0][6] || null;
3081 
3082       if (!properties.composite) {
3083         // For TrueType fonts that do not include `ToUnicode` or `Encoding`
3084         // data, attempt to use the name-table to improve text selection.
3085         adjustTrueTypeToUnicode(properties, this.isSymbolicFont, nameRecords);
3086       }
3087     }
3088 
3089     const builder = new OpenTypeFileBuilder(header.version);
3090     for (const tableTag in tables) {
3091       builder.addTable(tableTag, tables[tableTag].data);
3092     }
3093     return builder.toArray();
3094   }
3095 
3096   convert(fontName, font, properties) {
3097     // TODO: Check the charstring widths to determine this.
3098     properties.fixedPitch = false;
3099 
3100     if (properties.builtInEncoding) {
3101       // For Type1 fonts that do not include either `ToUnicode` or `Encoding`
3102       // data, attempt to use the `builtInEncoding` to improve text selection.
3103       adjustType1ToUnicode(properties, properties.builtInEncoding);
3104     }
3105 
3106     // Type 1 fonts have a notdef inserted at the beginning, so glyph 0
3107     // becomes glyph 1. In a CFF font glyph 0 is appended to the end of the
3108     // char strings.
3109     let glyphZeroId = 1;
3110     if (font instanceof CFFFont) {
3111       glyphZeroId = font.numGlyphs - 1;
3112     }
3113     const mapping = font.getGlyphMapping(properties);
3114     let newMapping = null;
3115     let newCharCodeToGlyphId = mapping;
3116     let toUnicodeExtraMap = null;
3117 
3118     // When `cssFontInfo` is set, the font is used to render text in the HTML
3119     // view (e.g. with Xfa) so nothing must be moved in the private use area.
3120     if (!properties.cssFontInfo) {
3121       newMapping = adjustMapping(
3122         mapping,
3123         font.hasGlyphId.bind(font),
3124         glyphZeroId,
3125         this.toUnicode
3126       );
3127       this.toFontChar = newMapping.toFontChar;
3128       newCharCodeToGlyphId = newMapping.charCodeToGlyphId;
3129       toUnicodeExtraMap = newMapping.toUnicodeExtraMap;
3130     }
3131     const numGlyphs = font.numGlyphs;
3132 
3133     function getCharCodes(charCodeToGlyphId, glyphId) {
3134       let charCodes = null;
3135       for (const charCode in charCodeToGlyphId) {
3136         if (glyphId === charCodeToGlyphId[charCode]) {
3137           (charCodes ||= []).push(charCode | 0);
3138         }
3139       }
3140       return charCodes;
3141     }
3142 
3143     function createCharCode(charCodeToGlyphId, glyphId) {
3144       for (const charCode in charCodeToGlyphId) {
3145         if (glyphId === charCodeToGlyphId[charCode]) {
3146           return charCode | 0;
3147         }
3148       }
3149       newMapping.charCodeToGlyphId[newMapping.nextAvailableFontCharCode] =
3150         glyphId;
3151       return newMapping.nextAvailableFontCharCode++;
3152     }
3153 
3154     const seacs = font.seacs;
3155     if (newMapping && SEAC_ANALYSIS_ENABLED && seacs?.length) {
3156       const matrix = properties.fontMatrix || FONT_IDENTITY_MATRIX;
3157       const charset = font.getCharset();
3158       const seacMap = Object.create(null);
3159       for (let glyphId in seacs) {
3160         glyphId |= 0;
3161         const seac = seacs[glyphId];
3162         const baseGlyphName = StandardEncoding[seac[2]];
3163         const accentGlyphName = StandardEncoding[seac[3]];
3164         const baseGlyphId = charset.indexOf(baseGlyphName);
3165         const accentGlyphId = charset.indexOf(accentGlyphName);
3166         if (baseGlyphId < 0 || accentGlyphId < 0) {
3167           continue;
3168         }
3169         const accentOffset = {
3170           x: seac[0] * matrix[0] + seac[1] * matrix[2] + matrix[4],
3171           y: seac[0] * matrix[1] + seac[1] * matrix[3] + matrix[5],
3172         };
3173 
3174         const charCodes = getCharCodes(mapping, glyphId);
3175         if (!charCodes) {
3176           // There's no point in mapping it if the char code was never mapped
3177           // to begin with.
3178           continue;
3179         }
3180         for (const charCode of charCodes) {
3181           // Find a fontCharCode that maps to the base and accent glyphs.
3182           // If one doesn't exists, create it.
3183           const charCodeToGlyphId = newMapping.charCodeToGlyphId;
3184           const baseFontCharCode = createCharCode(
3185             charCodeToGlyphId,
3186             baseGlyphId
3187           );
3188           const accentFontCharCode = createCharCode(
3189             charCodeToGlyphId,
3190             accentGlyphId
3191           );
3192           seacMap[charCode] = {
3193             baseFontCharCode,
3194             accentFontCharCode,
3195             accentOffset,
3196           };
3197         }
3198       }
3199       properties.seacMap = seacMap;
3200     }
3201 
3202     const unitsPerEm = properties.fontMatrix
3203       ? 1 / Math.max(...properties.fontMatrix.slice(0, 4).map(Math.abs))
3204       : 1000;
3205 
3206     const builder = new OpenTypeFileBuilder("\x4F\x54\x54\x4F");
3207     // PostScript Font Program
3208     builder.addTable("CFF ", font.data);
3209     // OS/2 and Windows Specific metrics
3210     builder.addTable("OS/2", createOS2Table(properties, newCharCodeToGlyphId));
3211     // Character to glyphs mapping
3212     builder.addTable(
3213       "cmap",
3214       createCmapTable(newCharCodeToGlyphId, toUnicodeExtraMap, numGlyphs)
3215     );
3216     // Font header
3217     builder.addTable(
3218       "head",
3219       "\x00\x01\x00\x00" + // Version number
3220         "\x00\x00\x10\x00" + // fontRevision
3221         "\x00\x00\x00\x00" + // checksumAdjustement
3222         "\x5F\x0F\x3C\xF5" + // magicNumber
3223         "\x00\x00" + // Flags
3224         safeString16(unitsPerEm) + // unitsPerEM
3225         "\x00\x00\x00\x00\x9e\x0b\x7e\x27" + // creation date
3226         "\x00\x00\x00\x00\x9e\x0b\x7e\x27" + // modifification date
3227         "\x00\x00" + // xMin
3228         safeString16(properties.descent) + // yMin
3229         "\x0F\xFF" + // xMax
3230         safeString16(properties.ascent) + // yMax
3231         string16(properties.italicAngle ? 2 : 0) + // macStyle
3232         "\x00\x11" + // lowestRecPPEM
3233         "\x00\x00" + // fontDirectionHint
3234         "\x00\x00" + // indexToLocFormat
3235         "\x00\x00"
3236     ); // glyphDataFormat
3237 
3238     // Horizontal header
3239     builder.addTable(
3240       "hhea",
3241       "\x00\x01\x00\x00" + // Version number
3242         safeString16(properties.ascent) + // Typographic Ascent
3243         safeString16(properties.descent) + // Typographic Descent
3244         "\x00\x00" + // Line Gap
3245         "\xFF\xFF" + // advanceWidthMax
3246         "\x00\x00" + // minLeftSidebearing
3247         "\x00\x00" + // minRightSidebearing
3248         "\x00\x00" + // xMaxExtent
3249         safeString16(properties.capHeight) + // caretSlopeRise
3250         safeString16(Math.tan(properties.italicAngle) * properties.xHeight) + // caretSlopeRun
3251         "\x00\x00" + // caretOffset
3252         "\x00\x00" + // -reserved-
3253         "\x00\x00" + // -reserved-
3254         "\x00\x00" + // -reserved-
3255         "\x00\x00" + // -reserved-
3256         "\x00\x00" + // metricDataFormat
3257         string16(numGlyphs)
3258     ); // Number of HMetrics
3259 
3260     // Horizontal metrics
3261     builder.addTable(
3262       "hmtx",
3263       (function fontFieldsHmtx() {
3264         const charstrings = font.charstrings;
3265         const cffWidths = font.cff ? font.cff.widths : null;
3266         let hmtx = "\x00\x00\x00\x00"; // Fake .notdef
3267         for (let i = 1, ii = numGlyphs; i < ii; i++) {
3268           let width = 0;
3269           if (charstrings) {
3270             const charstring = charstrings[i - 1];
3271             width = "width" in charstring ? charstring.width : 0;
3272           } else if (cffWidths) {
3273             width = Math.ceil(cffWidths[i] || 0);
3274           }
3275           hmtx += string16(width) + string16(0);
3276         }
3277         return hmtx;
3278       })()
3279     );
3280 
3281     // Maximum profile
3282     builder.addTable(
3283       "maxp",
3284       "\x00\x00\x50\x00" + string16(numGlyphs) // Version number
3285     ); // Num of glyphs
3286 
3287     // Naming tables
3288     builder.addTable("name", createNameTable(fontName));
3289 
3290     // PostScript information
3291     builder.addTable("post", createPostTable(properties));
3292 
3293     return builder.toArray();
3294   }
3295 
3296   /**
3297    * @private
3298    */
3299   get _spaceWidth() {
3300     // trying to estimate space character width
3301     const possibleSpaceReplacements = ["space", "minus", "one", "i", "I"];
3302     let width;
3303     for (const glyphName of possibleSpaceReplacements) {
3304       // if possible, getting width by glyph name
3305       if (glyphName in this.widths) {
3306         width = this.widths[glyphName];
3307         break;
3308       }
3309       const glyphsUnicodeMap = getGlyphsUnicode();
3310       const glyphUnicode = glyphsUnicodeMap[glyphName];
3311       // finding the charcode via unicodeToCID map
3312       let charcode = 0;
3313       if (this.composite && this.cMap.contains(glyphUnicode)) {
3314         charcode = this.cMap.lookup(glyphUnicode);
3315 
3316         if (typeof charcode === "string") {
3317           charcode = convertCidString(glyphUnicode, charcode);
3318         }
3319       }
3320       // ... via toUnicode map
3321       if (!charcode && this.toUnicode) {
3322         charcode = this.toUnicode.charCodeOf(glyphUnicode);
3323       }
3324       // setting it to unicode if negative or undefined
3325       if (charcode <= 0) {
3326         charcode = glyphUnicode;
3327       }
3328       // trying to get width via charcode
3329       width = this.widths[charcode];
3330       if (width) {
3331         break; // the non-zero width found
3332       }
3333     }
3334     return shadow(this, "_spaceWidth", width || this.defaultWidth);
3335   }
3336 
3337   /**
3338    * @private
3339    */
3340   _charToGlyph(charcode, isSpace = false) {
3341     let glyph = this._glyphCache[charcode];
3342     // All `Glyph`-properties, except `isSpace` in multi-byte strings,
3343     // depend indirectly on the `charcode`.
3344     if (glyph?.isSpace === isSpace) {
3345       return glyph;
3346     }
3347     let fontCharCode, width, operatorListId;
3348 
3349     let widthCode = charcode;
3350     if (this.cMap?.contains(charcode)) {
3351       widthCode = this.cMap.lookup(charcode);
3352 
3353       if (typeof widthCode === "string") {
3354         widthCode = convertCidString(charcode, widthCode);
3355       }
3356     }
3357     width = this.widths[widthCode];
3358     if (typeof width !== "number") {
3359       width = this.defaultWidth;
3360     }
3361     const vmetric = this.vmetrics?.[widthCode];
3362 
3363     let unicode = this.toUnicode.get(charcode) || charcode;
3364     if (typeof unicode === "number") {
3365       unicode = String.fromCharCode(unicode);
3366     }
3367 
3368     let isInFont = this.toFontChar[charcode] !== undefined;
3369     // First try the toFontChar map, if it's not there then try falling
3370     // back to the char code.
3371     fontCharCode = this.toFontChar[charcode] || charcode;
3372     if (this.missingFile) {
3373       const glyphName =
3374         this.differences[charcode] || this.defaultEncoding[charcode];
3375       if (
3376         (glyphName === ".notdef" || glyphName === "") &&
3377         this.type === "Type1"
3378       ) {
3379         // .notdef glyphs should be invisible in non-embedded Type1 fonts, so
3380         // replace them with spaces.
3381         fontCharCode = 0x20;
3382 
3383         if (glyphName === "") {
3384           // Ensure that other relevant glyph properties are also updated
3385           // (fixes issue18059.pdf).
3386           width ||= this._spaceWidth;
3387           unicode = String.fromCharCode(fontCharCode);
3388         }
3389       }
3390       fontCharCode = mapSpecialUnicodeValues(fontCharCode);
3391     }
3392 
3393     if (this.isType3Font) {
3394       // Font char code in this case is actually a glyph name.
3395       operatorListId = fontCharCode;
3396     }
3397 
3398     let accent = null;
3399     if (this.seacMap?.[charcode]) {
3400       isInFont = true;
3401       const seac = this.seacMap[charcode];
3402       fontCharCode = seac.baseFontCharCode;
3403       accent = {
3404         fontChar: String.fromCodePoint(seac.accentFontCharCode),
3405         offset: seac.accentOffset,
3406       };
3407     }
3408 
3409     let fontChar = "";
3410     if (typeof fontCharCode === "number") {
3411       if (fontCharCode <= 0x10ffff) {
3412         fontChar = String.fromCodePoint(fontCharCode);
3413       } else {
3414         warn(`charToGlyph - invalid fontCharCode: ${fontCharCode}`);
3415       }
3416     }
3417 
3418     if (this.missingFile && this.vertical && fontChar.length === 1) {
3419       const vertical = getVerticalPresentationForm()[fontChar.charCodeAt(0)];
3420       if (vertical) {
3421         fontChar = unicode = String.fromCharCode(vertical);
3422       }
3423     }
3424 
3425     glyph = new Glyph(
3426       charcode,
3427       fontChar,
3428       unicode,
3429       accent,
3430       width,
3431       vmetric,
3432       operatorListId,
3433       isSpace,
3434       isInFont
3435     );
3436     return (this._glyphCache[charcode] = glyph);
3437   }
3438 
3439   charsToGlyphs(chars) {
3440     // If we translated this string before, just grab it from the cache.
3441     let glyphs = this._charsCache[chars];
3442     if (glyphs) {
3443       return glyphs;
3444     }
3445     glyphs = [];
3446 
3447     if (this.cMap) {
3448       // Composite fonts have multi-byte strings, convert the string from
3449       // single-byte to multi-byte.
3450       const c = Object.create(null),
3451         ii = chars.length;
3452       let i = 0;
3453       while (i < ii) {
3454         this.cMap.readCharCode(chars, i, c);
3455         const { charcode, length } = c;
3456         i += length;
3457         // Space is char with code 0x20 and length 1 in multiple-byte codes.
3458         const glyph = this._charToGlyph(
3459           charcode,
3460           length === 1 && chars.charCodeAt(i - 1) === 0x20
3461         );
3462         glyphs.push(glyph);
3463       }
3464     } else {
3465       for (let i = 0, ii = chars.length; i < ii; ++i) {
3466         const charcode = chars.charCodeAt(i);
3467         const glyph = this._charToGlyph(charcode, charcode === 0x20);
3468         glyphs.push(glyph);
3469       }
3470     }
3471 
3472     // Enter the translated string into the cache.
3473     return (this._charsCache[chars] = glyphs);
3474   }
3475 
3476   /**
3477    * Chars can have different sizes (depends on the encoding).
3478    * @param {String} a string encoded with font encoding.
3479    * @returns {Array<Array<number>>} the positions of each char in the string.
3480    */
3481   getCharPositions(chars) {
3482     // This function doesn't use a cache because
3483     // it's called only when saving or printing.
3484     const positions = [];
3485 
3486     if (this.cMap) {
3487       const c = Object.create(null);
3488       let i = 0;
3489       while (i < chars.length) {
3490         this.cMap.readCharCode(chars, i, c);
3491         const length = c.length;
3492         positions.push([i, i + length]);
3493         i += length;
3494       }
3495     } else {
3496       for (let i = 0, ii = chars.length; i < ii; ++i) {
3497         positions.push([i, i + 1]);
3498       }
3499     }
3500 
3501     return positions;
3502   }
3503 
3504   get glyphCacheValues() {
3505     return Object.values(this._glyphCache);
3506   }
3507 
3508   /**
3509    * Encode a js string using font encoding.
3510    * The resulting array contains an encoded string at even positions
3511    * (can be empty) and a non-encoded one at odd positions.
3512    * @param {String} a js string.
3513    * @returns {Array<String>} an array of encoded strings or non-encoded ones.
3514    */
3515   encodeString(str) {
3516     const buffers = [];
3517     const currentBuf = [];
3518 
3519     // buffers will contain: encoded, non-encoded, encoded, ...
3520     // currentBuf is pushed in buffers each time there is a change.
3521     // So when buffers.length is odd then the last string is an encoded one
3522     // and currentBuf contains non-encoded chars.
3523     const hasCurrentBufErrors = () => buffers.length % 2 === 1;
3524 
3525     const getCharCode =
3526       this.toUnicode instanceof IdentityToUnicodeMap
3527         ? unicode => this.toUnicode.charCodeOf(unicode)
3528         : unicode => this.toUnicode.charCodeOf(String.fromCodePoint(unicode));
3529 
3530     for (let i = 0, ii = str.length; i < ii; i++) {
3531       const unicode = str.codePointAt(i);
3532       if (unicode > 0xd7ff && (unicode < 0xe000 || unicode > 0xfffd)) {
3533         // unicode is represented by two uint16
3534         i++;
3535       }
3536       if (this.toUnicode) {
3537         const charCode = getCharCode(unicode);
3538         if (charCode !== -1) {
3539           if (hasCurrentBufErrors()) {
3540             buffers.push(currentBuf.join(""));
3541             currentBuf.length = 0;
3542           }
3543           const charCodeLength = this.cMap
3544             ? this.cMap.getCharCodeLength(charCode)
3545             : 1;
3546           for (let j = charCodeLength - 1; j >= 0; j--) {
3547             currentBuf.push(String.fromCharCode((charCode >> (8 * j)) & 0xff));
3548           }
3549           continue;
3550         }
3551       }
3552 
3553       // unicode can't be encoded
3554       if (!hasCurrentBufErrors()) {
3555         buffers.push(currentBuf.join(""));
3556         currentBuf.length = 0;
3557       }
3558       currentBuf.push(String.fromCodePoint(unicode));
3559     }
3560 
3561     buffers.push(currentBuf.join(""));
3562 
3563     return buffers;
3564   }
3565 }
3566 
3567 class ErrorFont {
3568   constructor(error) {
3569     this.error = error;
3570     this.loadedName = "g_font_error";
3571     this.missingFile = true;
3572   }
3573 
3574   charsToGlyphs() {
3575     return [];
3576   }
3577 
3578   encodeString(chars) {
3579     return [chars];
3580   }
3581 
3582   exportData(extraProperties = false) {
3583     return { error: this.error };
3584   }
3585 }
3586 
3587 export { ErrorFont, Font };
</code>

Test file:
<test_file>
File:
test/unit/api_spec.js
/* Copyright 2017 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import {
  AnnotationEditorType,
  AnnotationMode,
  AnnotationType,
  ImageKind,
  InvalidPDFException,
  isNodeJS,
  MissingPDFException,
  objectSize,
  OPS,
  PasswordException,
  PasswordResponses,
  PermissionFlag,
  UnknownErrorException,
} from "../../src/shared/util.js";
import {
  buildGetDocumentParams,
  CMAP_URL,
  createTemporaryNodeServer,
  DefaultFileReaderFactory,
  TEST_PDFS_PATH,
} from "./test_utils.js";
import {
  DefaultCanvasFactory,
  getDocument,
  PDFDataRangeTransport,
  PDFDocumentLoadingTask,
  PDFDocumentProxy,
  PDFPageProxy,
  PDFWorker,
  RenderTask,
} from "../../src/display/api.js";
import {
  PageViewport,
  RenderingCancelledException,
  StatTimer,
} from "../../src/display/display_utils.js";
import { AutoPrintRegExp } from "../../web/ui_utils.js";
import { GlobalImageCache } from "../../src/core/image_utils.js";
import { GlobalWorkerOptions } from "../../src/display/worker_options.js";
import { Metadata } from "../../src/display/metadata.js";
const WORKER_SRC = "../../build/generic/build/pdf.worker.mjs";
</test_file>

Your task:
You are a software tester at pdf.js.
1. Examine the existing test file. You may reuse any imports, helpers or setup blocks it already has.
2. Write exactly one javascript test `it("...", async () => {...})` block.
3. Your test must fail on the code before the patch, and pass after, hence the test will verify that the patch resolves the issue.
4. The test must be self-contained and to-the-point.
5. If you need something new use only the provided imports (respect the paths exactly how they are given) by importing dynamically for compatibility with Node.js — no new dependencies. You can use the PDF file for testing as follows:
const { getDocument } = await import('../../src/display/api.js');
const { buildGetDocumentParams } = await import('./test_utils.js');
const loadingTask = getDocument(buildGetDocumentParams('issue18208.pdf'))
6. Return only the javascript code for the new `it(...)` block (no comments or explanations).

Example structure:
it("should <describe behavior>", async () => {
  const { example } = await import("../../src/core/example.js");
  <initialize required variables>;
  <define expected variable>;
  <generate actual variables>;
  <compare expected with actual>;
});

