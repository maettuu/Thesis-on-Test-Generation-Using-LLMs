Before you begin:
- Keep going until the job is completely solved — don’t stop halfway.
- If you’re unsure about the behavior, reread the provided patch carefully; do not hallucinate.
- Plan your approach before writing code by reflecting on whether the test truly fails before and passes after.

Issue:
<issue>
How do I remove embedded images
Attach (recommended) or Link to PDF file here:

[TS354 Week 2 slides.pdf](https://github.com/mozilla/pdf.js/files/12287878/TS354.Week.2.slides.pdf)

Configuration:
- Web browser and its version: Chrome 115.0.5790.171
- Operating system and its version: Windows 11 home 22H2
- PDF.js version: 3.9.49
- Is a browser extension: yes

Steps to reproduce the problem:
1. Open pdf
2. Go to page 2

What is the expected behavior? (add screenshot)
Not see the pin

What went wrong? (add screenshot)
I'd just like to just see the image underneath the black pin

![image](https://github.com/mozilla/pdf.js/assets/141709691/fa12745d-3280-4f98-83d6-372b9fe18a2c)


</issue>

PDF File:
<pdf>
issue16800.pdf
</pdf>

Patch:
<patch>
diff --git a/src/core/annotation.js b/src/core/annotation.js
--- a/src/core/annotation.js
+++ b/src/core/annotation.js
@@ -4652,6 +4652,12 @@ class FileAttachmentAnnotation extends MarkupAnnotation {
     const name = dict.get("Name");
     this.data.name =
       name instanceof Name ? stringToPDFString(name.name) : "PushPin";
+
+    const fillAlpha = dict.get("ca");
+    this.data.fillAlpha =
+      typeof fillAlpha === "number" && fillAlpha >= 0 && fillAlpha <= 1
+        ? fillAlpha
+        : null;
   }
 }

diff --git a/src/display/annotation_layer.js b/src/display/annotation_layer.js
--- a/src/display/annotation_layer.js
+++ b/src/display/annotation_layer.js
@@ -2798,8 +2798,9 @@ class FileAttachmentAnnotationElement extends AnnotationElement {
   render() {
     this.container.classList.add("fileAttachmentAnnotation");
 
+    const { data } = this;
     let trigger;
-    if (this.data.hasAppearance) {
+    if (data.hasAppearance || data.fillAlpha === 0) {
       trigger = document.createElement("div");
     } else {
       // Unfortunately it seems that it's not clearly specified exactly what
@@ -2809,18 +2810,26 @@ class FileAttachmentAnnotationElement extends AnnotationElement {
       //   Additional names may be supported as well. Default value: PushPin.
       trigger = document.createElement("img");
       trigger.src = `${this.imageResourcesPath}annotation-${
-        /paperclip/i.test(this.data.name) ? "paperclip" : "pushpin"
+        /paperclip/i.test(data.name) ? "paperclip" : "pushpin"
       }.svg`;
+
+      if (data.fillAlpha && data.fillAlpha < 1) {
+        trigger.style = `filter: opacity(${Math.round(
+          data.fillAlpha * 100
+        )}%);`;
+
+        if (typeof PDFJSDev !== "undefined" && PDFJSDev.test("TESTING")) {
+          this.container.classList.add("hasFillAlpha");
+        }
+      }
     }
     trigger.classList.add("popupTriggerArea");
     trigger.addEventListener("dblclick", this._download.bind(this));
     this.#trigger = trigger;
 
     if (
-      !this.data.popupRef &&
-      (this.data.titleObj?.str ||
-        this.data.contentsObj?.str ||
-        this.data.richText)
+      !data.popupRef &&
+      (data.titleObj?.str || data.contentsObj?.str || data.richText)
     ) {
       this._createPopup();
     }


</patch>

Imports:
<imports>
Available Packages
Dev Dependencies:
- @babel/core: ^7.22.9
- @babel/plugin-transform-modules-commonjs: ^7.22.5
- @babel/preset-env: ^7.22.9
- @babel/runtime: ^7.22.6
- @javascript-obfuscator/escodegen: 2.3.0
- acorn: ^8.10.0
- autoprefixer: ^10.4.14
- babel-loader: ^9.1.3
- caniuse-lite: ^1.0.30001519
- canvas: ^2.11.2
- core-js: ^3.32.0
- cross-env: ^7.0.3
- es-module-shims: 1.4.7
- eslint: ^8.46.0
- eslint-config-prettier: ^8.10.0
- eslint-plugin-fetch-options: ^0.0.5
- eslint-plugin-html: ^7.1.0
- eslint-plugin-import: ^2.28.0
- eslint-plugin-json: ^3.1.0
- eslint-plugin-mozilla: ^3.1.0
- eslint-plugin-no-unsanitized: ^4.0.2
- eslint-plugin-prettier: ^5.0.0
- eslint-plugin-sort-exports: ^0.8.0
- eslint-plugin-unicorn: ^48.0.1
- globals: ^13.20.0
- gulp: ^4.0.2
- gulp-postcss: ^9.0.1
- gulp-rename: ^2.0.0
- gulp-replace: ^1.1.4
- gulp-zip: ^5.1.0
- jasmine: ^5.1.0
- jsdoc: ^4.0.2
- jstransformer-markdown-it: ^3.0.0
- merge-stream: ^2.0.0
- mkdirp: ^3.0.1
- needle: ^3.2.0
- path2d-polyfill: ^2.0.1
- pngjs: ^7.0.0
- postcss: ^8.4.27
- postcss-dir-pseudo-class: ^8.0.0
- prettier: ^3.0.1
- puppeteer: ^21.0.1
- rimraf: ^3.0.2
- streamqueue: ^1.1.2
- stylelint: ^15.10.2
- stylelint-prettier: ^4.0.2
- terser: ^5.19.2
- through2: ^4.0.2
- ttest: ^4.0.0
- typescript: ^5.1.6
- typogr: ^0.6.8
- vinyl: ^3.0.0
- webpack: ^5.88.2
- webpack-stream: ^7.0.0
- wintersmith: ^2.5.0
- yargs: ^17.7.2

Engines:
- node: >=18

Available Relative Imports:
- `../../src/core/annotation.js`: Annotation, AnnotationBorderStyle, AnnotationFactory, MarkupAnnotation, getQuadPoints
- `../../src/core/bidi.js`: bidi
- `../../src/core/cff_parser.js`: CFFCharset, CFFCompiler, CFFFDSelect, CFFParser, CFFStrings
- `../../src/core/cmap.js`: CMap, CMapFactory, IdentityCMap
- `../../src/core/colorspace.js`: ColorSpace
- `../../src/core/core_utils.js`: arrayBuffersToBytes, encodeToXmlString, escapePDFName, escapeString, getInheritableProperty, isAscii, isWhiteSpace, log2, numberToString, parseXFAPath, recoverJsURL, stringToUTF16HexString, stringToUTF16String, toRomanNumerals, validateCSSFont
- `../../src/core/crypto.js`: AES128Cipher, AES256Cipher, ARCFourCipher, CipherTransformFactory, PDF17, PDF20, calculateMD5, calculateSHA256, calculateSHA384, calculateSHA512
- `../../src/core/default_appearance.js`: createDefaultAppearance, parseAppearanceStream, parseDefaultAppearance
- `../../src/core/document.js`: PDFDocument, Page
- `../../src/core/encodings.js`: getEncoding
- `../../src/core/evaluator.js`: PartialEvaluator
- `../../src/core/font_substitutions.js`: getFontSubstitution
- `../../src/core/fonts_utils.js`: SEAC_ANALYSIS_ENABLED
- `../../src/core/function.js`: PDFFunctionFactory, PostScriptCompiler, PostScriptEvaluator
- `../../src/core/glyphlist.js`: getDingbatsGlyphsUnicode, getGlyphsUnicode
- `../../src/core/image_utils.js`: GlobalImageCache, LocalColorSpaceCache
- `../../src/core/jbig2.js`: Jbig2Image
- `../../src/core/jpg.js`: JpegImage
- `../../src/core/jpx.js`: JpxImage
- `../../src/core/metadata_parser.js`: MetadataParser
- `../../src/core/operator_list.js`: OperatorList
- `../../src/core/parser.js`: Lexer, Linearization, Parser
- `../../src/core/predictor_stream.js`: PredictorStream
- `../../src/core/primitives.js`: Cmd, Dict, EOF, Name, Ref, RefSet, RefSetCache, isCmd, isDict, isName, isRefsEqual
- `../../src/core/ps_parser.js`: PostScriptLexer, PostScriptParser
- `../../src/core/stream.js`: NullStream, Stream, StringStream
- `../../src/core/type1_parser.js`: Type1Parser
- `../../src/core/unicode.js`: getCharUnicodeCategory, getUnicodeForGlyph, getUnicodeRangeFor, mapSpecialUnicodeValues
- `../../src/core/worker.js`: WorkerMessageHandler, WorkerTask
- `../../src/core/writer.js`: incrementalUpdate, writeDict
- `../../src/core/xfa/bind.js`: Binder
- `../../src/core/xfa/data.js`: DataHandler
- `../../src/core/xfa/factory.js`: XFAFactory
- `../../src/core/xfa/formcalc_lexer.js`: Lexer, TOKEN, Token
- `../../src/core/xfa/formcalc_parser.js`: Errors, Parser
- `../../src/core/xfa/parser.js`: XFAParser
- `../../src/core/xfa/som.js`: searchNode
- `../../src/core/xfa/symbol_utils.js`: $dump, $getChildren, $getChildrenByClass, $getChildrenByName, $text, $uid
- `../../src/core/xml_parser.js`: SimpleXMLParser, XMLParserBase
- `../../src/display/annotation_layer.js`: AnnotationLayer
- `../../src/display/annotation_storage.js`: AnnotationStorage
- `../../src/display/api.js`: DefaultCMapReaderFactory, DefaultCanvasFactory, DefaultStandardFontDataFactory, LoopbackPort, PDFDataRangeTransport, PDFDocumentLoadingTask, PDFDocumentProxy, PDFPageProxy, PDFWorker, PDFWorkerUtil, RenderTask, SVGGraphics, build, getDocument, version
- `../../src/display/display_utils.js`: DOMCanvasFactory, DOMSVGFactory, PDFDateString, PageViewport, PixelsPerInch, RenderingCancelledException, StatTimer, getFilenameFromUrl, getPdfFilenameFromUrl, getXfaPageViewport, isDataScheme, isPdfFile, isValidFetchUrl, loadScript, setLayerDimensions
- `../../src/display/editor/annotation_editor_layer.js`: AnnotationEditorLayer
- `../../src/display/editor/tools.js`: AnnotationEditorUIManager, CommandManager
- `../../src/display/fetch_stream.js`: PDFFetchStream
- `../../src/display/metadata.js`: Metadata
- `../../src/display/network.js`: PDFNetworkStream
- `../../src/display/network_utils.js`: createResponseStatusError, extractFilenameFromHeader, validateRangeRequestCapabilities, validateResponseStatus
- `../../src/display/node_stream.js`: PDFNodeStream
- `../../src/display/svg.js`: SVGGraphics
- `../../src/display/text_layer.js`: TextLayerRenderTask, renderTextLayer, updateTextLayer
- `../../src/display/worker_options.js`: GlobalWorkerOptions
- `../../src/display/xfa_layer.js`: XfaLayer
- `../../src/shared/message_handler.js`: MessageHandler
- `../../src/shared/murmurhash3.js`: MurmurHash3_64
- `../../src/shared/util.js`: AbortException, AnnotationBorderStyleType, AnnotationEditorParamsType, AnnotationEditorType, AnnotationFieldFlag, AnnotationFlag, AnnotationMode, AnnotationType, CMapCompressionType, FeatureTest, FormatError, ImageKind, InvalidPDFException, MissingPDFException, OPS, PasswordException, PasswordResponses, PermissionFlag, PromiseCapability, RenderingIntentFlag, UnexpectedResponseException, UnknownErrorException, Util, VerbosityLevel, bytesToString, createValidAbsoluteUrl, getModificationDate, getVerbosityLevel, isArrayBuffer, isNodeJS, normalizeUnicode, objectSize, setVerbosityLevel, shadow, string32, stringToBytes, stringToPDFString, stringToUTF8String
- `../../web/annotation_layer_builder.js`: AnnotationLayerBuilder
- `../../web/download_manager.js`: DownloadManager
- `../../web/event_utils.js`: EventBus, WaitOnType, waitOnEventOrTimeout
- `../../web/genericl10n.js`: GenericL10n
- `../../web/l10n_utils.js`: NullL10n
- `../../web/pdf_find_controller.js`: FindState, PDFFindController
- `../../web/pdf_find_utils.js`: CharacterType, getCharacterType
- `../../web/pdf_history.js`: PDFHistory, isDestArraysEqual, isDestHashesEqual
- `../../web/pdf_link_service.js`: LinkTarget, PDFLinkService, SimpleLinkService
- `../../web/pdf_page_view.js`: PDFPageView
- `../../web/pdf_scripting_manager.component.js`: PDFScriptingManager
- `../../web/pdf_single_page_viewer.js`: PDFSinglePageViewer
- `../../web/pdf_viewer.js`: PDFPageViewBuffer, PDFViewer
- `../../web/struct_tree_layer_builder.js`: StructTreeLayerBuilder
- `../../web/text_layer_builder.js`: TextLayerBuilder
- `../../web/ui_utils.js`: AutoPrintRegExp, ProgressBar, RenderingStates, ScrollMode, SpreadMode, backtrackBeforeAllVisibleElements, binarySearchFirstItem, getPageSizeInches, getVisibleElements, isPortraitOrientation, isValidRotation, parseQueryString, removeNullCharacters
- `../../web/xfa_layer_builder.js`: XfaLayerBuilder
- `./test_utils.js`: CMAP_URL, DefaultFileReaderFactory, STANDARD_FONT_DATA_URL, TEST_PDFS_PATH, XRefMock, buildGetDocumentParams, createIdFactory
- `./testreporter.js`: TestReporter
</imports>

Code:
<code>
File:
src/core/annotation.js
1 /* Copyright 2012 Mozilla Foundation
2  *
3  * Licensed under the Apache License, Version 2.0 (the "License");
4  * you may not use this file except in compliance with the License.
5  * You may obtain a copy of the License at
6  *
7  *     http://www.apache.org/licenses/LICENSE-2.0
8  *
9  * Unless required by applicable law or agreed to in writing, software
10  * distributed under the License is distributed on an "AS IS" BASIS,
11  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
12  * See the License for the specific language governing permissions and
13  * limitations under the License.
14  */
15 
16 import {
17   AnnotationActionEventType,
18   AnnotationBorderStyleType,
19   AnnotationEditorType,
20   AnnotationFieldFlag,
21   AnnotationFlag,
22   AnnotationReplyType,
23   AnnotationType,
24   assert,
25   BASELINE_FACTOR,
26   FeatureTest,
27   getModificationDate,
28   IDENTITY_MATRIX,
29   LINE_DESCENT_FACTOR,
30   LINE_FACTOR,
31   OPS,
32   RenderingIntentFlag,
33   shadow,
34   stringToPDFString,
35   unreachable,
36   Util,
37   warn,
38 } from "../shared/util.js";
39 import {
40   collectActions,
41   escapeString,
42   getInheritableProperty,
43   getRotationMatrix,
44   isAscii,
45   numberToString,
46   stringToUTF16String,
47 } from "./core_utils.js";
48 import {
49   createDefaultAppearance,
50   FakeUnicodeFont,
51   getPdfColor,
52   parseAppearanceStream,
53   parseDefaultAppearance,
54 } from "./default_appearance.js";
55 import { Dict, isName, Name, Ref, RefSet } from "./primitives.js";
56 import { Stream, StringStream } from "./stream.js";
57 import { writeDict, writeObject } from "./writer.js";
58 import { BaseStream } from "./base_stream.js";
59 import { bidi } from "./bidi.js";
60 import { Catalog } from "./catalog.js";
61 import { ColorSpace } from "./colorspace.js";
62 import { FileSpec } from "./file_spec.js";
63 import { JpegStream } from "./jpeg_stream.js";
64 import { ObjectLoader } from "./object_loader.js";
65 import { OperatorList } from "./operator_list.js";
66 import { XFAFactory } from "./xfa/factory.js";
67 
68 class AnnotationFactory {
69   /**
70    * Create an `Annotation` object of the correct type for the given reference
71    * to an annotation dictionary. This yields a promise that is resolved when
72    * the `Annotation` object is constructed.
73    *
74    * @param {XRef} xref
75    * @param {Object} ref
76    * @param {PDFManager} pdfManager
77    * @param {Object} idFactory
78    * @param {boolean} collectFields
79    * @returns {Promise} A promise that is resolved with an {Annotation}
80    *   instance.
81    */
82   static create(xref, ref, pdfManager, idFactory, collectFields) {
83     return Promise.all([
84       pdfManager.ensureCatalog("acroForm"),
85       // Only necessary to prevent the `pdfManager.docBaseUrl`-getter, used
86       // with certain Annotations, from throwing and thus breaking parsing:
87       pdfManager.ensureCatalog("baseUrl"),
88       // Only necessary in the `Catalog.parseDestDictionary`-method,
89       // when parsing "GoToE" actions:
90       pdfManager.ensureCatalog("attachments"),
91       pdfManager.ensureDoc("xfaDatasets"),
92       collectFields ? this._getPageIndex(xref, ref, pdfManager) : -1,
93     ]).then(([acroForm, baseUrl, attachments, xfaDatasets, pageIndex]) =>
94       pdfManager.ensure(this, "_create", [
95         xref,
96         ref,
97         pdfManager,
98         idFactory,
99         acroForm,
100         attachments,
101         xfaDatasets,
102         collectFields,
103         pageIndex,
104       ])
105     );
106   }
107 
108   /**
109    * @private
110    */
111   static _create(
112     xref,
113     ref,
114     pdfManager,
115     idFactory,
116     acroForm,
117     attachments = null,
118     xfaDatasets,
119     collectFields,
120     pageIndex = -1
121   ) {
122     const dict = xref.fetchIfRef(ref);
123     if (!(dict instanceof Dict)) {
124       return undefined;
125     }
126 
127     const id =
128       ref instanceof Ref ? ref.toString() : `annot_${idFactory.createObjId()}`;
129 
130     // Determine the annotation's subtype.
131     let subtype = dict.get("Subtype");
132     subtype = subtype instanceof Name ? subtype.name : null;
133 
134     const acroFormDict = acroForm instanceof Dict ? acroForm : Dict.empty;
135 
136     // Return the right annotation object based on the subtype and field type.
137     const parameters = {
138       xref,
139       ref,
140       dict,
141       subtype,
142       id,
143       pdfManager,
144       acroForm: acroFormDict,
145       attachments,
146       xfaDatasets,
147       collectFields,
148       needAppearances:
149         !collectFields && acroFormDict.get("NeedAppearances") === true,
150       pageIndex,
151       evaluatorOptions: pdfManager.evaluatorOptions,
152     };
153 
154     switch (subtype) {
155       case "Link":
156         return new LinkAnnotation(parameters);
157 
158       case "Text":
159         return new TextAnnotation(parameters);
160 
161       case "Widget":
162         let fieldType = getInheritableProperty({ dict, key: "FT" });
163         fieldType = fieldType instanceof Name ? fieldType.name : null;
164 
165         switch (fieldType) {
166           case "Tx":
167             return new TextWidgetAnnotation(parameters);
168           case "Btn":
169             return new ButtonWidgetAnnotation(parameters);
170           case "Ch":
171             return new ChoiceWidgetAnnotation(parameters);
172           case "Sig":
173             return new SignatureWidgetAnnotation(parameters);
174         }
175         warn(
176           `Unimplemented widget field type "${fieldType}", ` +
177             "falling back to base field type."
178         );
179         return new WidgetAnnotation(parameters);
180 
181       case "Popup":
182         return new PopupAnnotation(parameters);
183 
184       case "FreeText":
185         return new FreeTextAnnotation(parameters);
186 
187       case "Line":
188         return new LineAnnotation(parameters);
189 
190       case "Square":
191         return new SquareAnnotation(parameters);
192 
193       case "Circle":
194         return new CircleAnnotation(parameters);
195 
196       case "PolyLine":
197         return new PolylineAnnotation(parameters);
198 
199       case "Polygon":
200         return new PolygonAnnotation(parameters);
201 
202       case "Caret":
203         return new CaretAnnotation(parameters);
204 
205       case "Ink":
206         return new InkAnnotation(parameters);
207 
208       case "Highlight":
209         return new HighlightAnnotation(parameters);
210 
211       case "Underline":
212         return new UnderlineAnnotation(parameters);
213 
214       case "Squiggly":
215         return new SquigglyAnnotation(parameters);
216 
217       case "StrikeOut":
218         return new StrikeOutAnnotation(parameters);
219 
220       case "Stamp":
221         return new StampAnnotation(parameters);
222 
223       case "FileAttachment":
224         return new FileAttachmentAnnotation(parameters);
225 
226       default:
227         if (!collectFields) {
228           if (!subtype) {
229             warn("Annotation is missing the required /Subtype.");
230           } else {
231             warn(
232               `Unimplemented annotation type "${subtype}", ` +
233                 "falling back to base annotation."
234             );
235           }
236         }
237         return new Annotation(parameters);
238     }
239   }
240 
241   static async _getPageIndex(xref, ref, pdfManager) {
242     try {
243       const annotDict = await xref.fetchIfRefAsync(ref);
244       if (!(annotDict instanceof Dict)) {
245         return -1;
246       }
247       const pageRef = annotDict.getRaw("P");
248       if (!(pageRef instanceof Ref)) {
249         return -1;
250       }
251       const pageIndex = await pdfManager.ensureCatalog("getPageIndex", [
252         pageRef,
253       ]);
254       return pageIndex;
255     } catch (ex) {
256       warn(`_getPageIndex: "${ex}".`);
257       return -1;
258     }
259   }
260 
261   static generateImages(annotations, xref, isOffscreenCanvasSupported) {
262     if (!isOffscreenCanvasSupported) {
263       warn(
264         "generateImages: OffscreenCanvas is not supported, cannot save or print some annotations with images."
265       );
266       return null;
267     }
268     let imagePromises;
269     for (const { bitmapId, bitmap } of annotations) {
270       if (!bitmap) {
271         continue;
272       }
273       imagePromises ||= new Map();
274       imagePromises.set(bitmapId, StampAnnotation.createImage(bitmap, xref));
275     }
276 
277     return imagePromises;
278   }
279 
280   static async saveNewAnnotations(evaluator, task, annotations, imagePromises) {
281     const xref = evaluator.xref;
282     let baseFontRef;
283     const dependencies = [];
284     const promises = [];
285     const { isOffscreenCanvasSupported } = evaluator.options;
286 
287     for (const annotation of annotations) {
288       if (annotation.deleted) {
289         continue;
290       }
291       switch (annotation.annotationType) {
292         case AnnotationEditorType.FREETEXT:
293           if (!baseFontRef) {
294             const baseFont = new Dict(xref);
295             baseFont.set("BaseFont", Name.get("Helvetica"));
296             baseFont.set("Type", Name.get("Font"));
297             baseFont.set("Subtype", Name.get("Type1"));
298             baseFont.set("Encoding", Name.get("WinAnsiEncoding"));
299             const buffer = [];
300             baseFontRef = xref.getNewTemporaryRef();
301             await writeObject(baseFontRef, baseFont, buffer, null);
302             dependencies.push({ ref: baseFontRef, data: buffer.join("") });
303           }
304           promises.push(
305             FreeTextAnnotation.createNewAnnotation(
306               xref,
307               annotation,
308               dependencies,
309               { evaluator, task, baseFontRef }
310             )
311           );
312           break;
313         case AnnotationEditorType.INK:
314           promises.push(
315             InkAnnotation.createNewAnnotation(xref, annotation, dependencies)
316           );
317           break;
318         case AnnotationEditorType.STAMP:
319           if (!isOffscreenCanvasSupported) {
320             break;
321           }
322           const image = await imagePromises.get(annotation.bitmapId);
323           if (image.imageStream) {
324             const { imageStream, smaskStream } = image;
325             const buffer = [];
326             if (smaskStream) {
327               const smaskRef = xref.getNewTemporaryRef();
328               await writeObject(smaskRef, smaskStream, buffer, null);
329               dependencies.push({ ref: smaskRef, data: buffer.join("") });
330               imageStream.dict.set("SMask", smaskRef);
331               buffer.length = 0;
332             }
333             const imageRef = (image.imageRef = xref.getNewTemporaryRef());
334             await writeObject(imageRef, imageStream, buffer, null);
335             dependencies.push({ ref: imageRef, data: buffer.join("") });
336             image.imageStream = image.smaskStream = null;
337           }
338           promises.push(
339             StampAnnotation.createNewAnnotation(
340               xref,
341               annotation,
342               dependencies,
343               { image }
344             )
345           );
346           break;
347       }
348     }
349 
350     return {
351       annotations: await Promise.all(promises),
352       dependencies,
353     };
354   }
355 
356   static async printNewAnnotations(
357     evaluator,
358     task,
359     annotations,
360     imagePromises
361   ) {
362     if (!annotations) {
363       return null;
364     }
365 
366     const { options, xref } = evaluator;
367     const promises = [];
368     for (const annotation of annotations) {
369       if (annotation.deleted) {
370         continue;
371       }
372       switch (annotation.annotationType) {
373         case AnnotationEditorType.FREETEXT:
374           promises.push(
375             FreeTextAnnotation.createNewPrintAnnotation(xref, annotation, {
376               evaluator,
377               task,
378               evaluatorOptions: options,
379             })
380           );
381           break;
382         case AnnotationEditorType.INK:
383           promises.push(
384             InkAnnotation.createNewPrintAnnotation(xref, annotation, {
385               evaluatorOptions: options,
386             })
387           );
388           break;
389         case AnnotationEditorType.STAMP:
390           if (!options.isOffscreenCanvasSupported) {
391             break;
392           }
393           const image = await imagePromises.get(annotation.bitmapId);
394           if (image.imageStream) {
395             const { imageStream, smaskStream } = image;
396             if (smaskStream) {
397               imageStream.dict.set("SMask", smaskStream);
398             }
399             image.imageRef = new JpegStream(imageStream, imageStream.length);
400             image.imageStream = image.smaskStream = null;
401           }
402           promises.push(
403             StampAnnotation.createNewPrintAnnotation(xref, annotation, {
404               image,
405               evaluatorOptions: options,
406             })
407           );
408           break;
409       }
410     }
411 
412     return Promise.all(promises);
413   }
414 }
415 
416 function getRgbColor(color, defaultColor = new Uint8ClampedArray(3)) {
417   if (!Array.isArray(color)) {
418     return defaultColor;
419   }
420 
421   const rgbColor = defaultColor || new Uint8ClampedArray(3);
422   switch (color.length) {
423     case 0: // Transparent, which we indicate with a null value
424       return null;
425 
426     case 1: // Convert grayscale to RGB
427       ColorSpace.singletons.gray.getRgbItem(color, 0, rgbColor, 0);
428       return rgbColor;
429 
430     case 3: // Convert RGB percentages to RGB
431       ColorSpace.singletons.rgb.getRgbItem(color, 0, rgbColor, 0);
432       return rgbColor;
433 
434     case 4: // Convert CMYK to RGB
435       ColorSpace.singletons.cmyk.getRgbItem(color, 0, rgbColor, 0);
436       return rgbColor;
437 
438     default:
439       return defaultColor;
440   }
441 }
442 
443 function getPdfColorArray(color) {
444   return Array.from(color, c => c / 255);
445 }
446 
447 function getQuadPoints(dict, rect) {
448   // The region is described as a number of quadrilaterals.
449   // Each quadrilateral must consist of eight coordinates.
450   const quadPoints = dict.getArray("QuadPoints");
451   if (
452     !Array.isArray(quadPoints) ||
453     quadPoints.length === 0 ||
454     quadPoints.length % 8 > 0
455   ) {
456     return null;
457   }
458 
459   const quadPointsLists = [];
460   for (let i = 0, ii = quadPoints.length / 8; i < ii; i++) {
461     // Each series of eight numbers represents the coordinates for one
462     // quadrilateral in the order [x1, y1, x2, y2, x3, y3, x4, y4].
463     // Convert this to an array of objects with x and y coordinates.
464     let minX = Infinity,
465       maxX = -Infinity,
466       minY = Infinity,
467       maxY = -Infinity;
468     for (let j = i * 8, jj = i * 8 + 8; j < jj; j += 2) {
469       const x = quadPoints[j];
470       const y = quadPoints[j + 1];
471 
472       minX = Math.min(x, minX);
473       maxX = Math.max(x, maxX);
474       minY = Math.min(y, minY);
475       maxY = Math.max(y, maxY);
476     }
477     // The quadpoints should be ignored if any coordinate in the array
478     // lies outside the region specified by the rectangle. The rectangle
479     // can be `null` for markup annotations since their rectangle may be
480     // incorrect (fixes bug 1538111).
481     if (
482       rect !== null &&
483       (minX < rect[0] || maxX > rect[2] || minY < rect[1] || maxY > rect[3])
484     ) {
485       return null;
486     }
487     // The PDF specification states in section 12.5.6.10 (figure 64) that the
488     // order of the quadpoints should be bottom left, bottom right, top right
489     // and top left. However, in practice PDF files use a different order,
490     // namely bottom left, bottom right, top left and top right (this is also
491     // mentioned on https://github.com/highkite/pdfAnnotate#QuadPoints), so
492     // this is the actual order we should work with. However, the situation is
493     // even worse since Adobe's own applications and other applications violate
494     // the specification and create annotations with other orders, namely top
495     // left, top right, bottom left and bottom right or even top left,
496     // top right, bottom right and bottom left. To avoid inconsistency and
497     // broken rendering, we normalize all lists to put the quadpoints in the
498     // same standard order (see https://stackoverflow.com/a/10729881).
499     quadPointsLists.push([
500       { x: minX, y: maxY },
501       { x: maxX, y: maxY },
502       { x: minX, y: minY },
503       { x: maxX, y: minY },
504     ]);
505   }
506   return quadPointsLists;
507 }
508 
509 function getTransformMatrix(rect, bbox, matrix) {
510   // 12.5.5: Algorithm: Appearance streams
511   const [minX, minY, maxX, maxY] = Util.getAxialAlignedBoundingBox(
512     bbox,
513     matrix
514   );
515   if (minX === maxX || minY === maxY) {
516     // From real-life file, bbox was [0, 0, 0, 0]. In this case,
517     // just apply the transform for rect
518     return [1, 0, 0, 1, rect[0], rect[1]];
519   }
520 
521   const xRatio = (rect[2] - rect[0]) / (maxX - minX);
522   const yRatio = (rect[3] - rect[1]) / (maxY - minY);
523   return [
524     xRatio,
525     0,
526     0,
527     yRatio,
528     rect[0] - minX * xRatio,
529     rect[1] - minY * yRatio,
530   ];
531 }
532 
533 class Annotation {
534   constructor(params) {
535     const { dict, xref } = params;
536 
537     this.setTitle(dict.get("T"));
538     this.setContents(dict.get("Contents"));
539     this.setModificationDate(dict.get("M"));
540     this.setFlags(dict.get("F"));
541     this.setRectangle(dict.getArray("Rect"));
542     this.setColor(dict.getArray("C"));
543     this.setBorderStyle(dict);
544     this.setAppearance(dict);
545     this.setOptionalContent(dict);
546 
547     const MK = dict.get("MK");
548     this.setBorderAndBackgroundColors(MK);
549     this.setRotation(MK, dict);
550     this.ref = params.ref instanceof Ref ? params.ref : null;
551 
552     this._streams = [];
553     if (this.appearance) {
554       this._streams.push(this.appearance);
555     }
556 
557     // The annotation cannot be changed (neither its position/visibility nor its
558     // contents), hence we can just display its appearance and don't generate
559     // a HTML element for it.
560     const isLocked = !!(this.flags & AnnotationFlag.LOCKED);
561     const isContentLocked = !!(this.flags & AnnotationFlag.LOCKEDCONTENTS);
562 
563     // Expose public properties using a data object.
564     this.data = {
565       annotationFlags: this.flags,
566       borderStyle: this.borderStyle,
567       color: this.color,
568       backgroundColor: this.backgroundColor,
569       borderColor: this.borderColor,
570       rotation: this.rotation,
571       contentsObj: this._contents,
572       hasAppearance: !!this.appearance,
573       id: params.id,
574       modificationDate: this.modificationDate,
575       rect: this.rectangle,
576       subtype: params.subtype,
577       hasOwnCanvas: false,
578       noRotate: !!(this.flags & AnnotationFlag.NOROTATE),
579       noHTML: isLocked && isContentLocked,
580     };
581 
582     if (params.collectFields) {
583       // Fields can act as container for other fields and have
584       // some actions even if no Annotation inherit from them.
585       // Those fields can be referenced by CO (calculation order).
586       const kids = dict.get("Kids");
587       if (Array.isArray(kids)) {
588         const kidIds = [];
589         for (const kid of kids) {
590           if (kid instanceof Ref) {
591             kidIds.push(kid.toString());
592           }
593         }
594         if (kidIds.length !== 0) {
595           this.data.kidIds = kidIds;
596         }
597       }
598 
599       this.data.actions = collectActions(xref, dict, AnnotationActionEventType);
600       this.data.fieldName = this._constructFieldName(dict);
601       this.data.pageIndex = params.pageIndex;
602     }
603 
604     this._isOffscreenCanvasSupported =
605       params.evaluatorOptions.isOffscreenCanvasSupported;
606     this._fallbackFontDict = null;
607     this._needAppearances = false;
608   }
609 
610   /**
611    * @private
612    */
613   _hasFlag(flags, flag) {
614     return !!(flags & flag);
615   }
616 
617   /**
618    * @private
619    */
620   _isViewable(flags) {
621     return (
622       !this._hasFlag(flags, AnnotationFlag.INVISIBLE) &&
623       !this._hasFlag(flags, AnnotationFlag.NOVIEW)
624     );
625   }
626 
627   /**
628    * @private
629    */
630   _isPrintable(flags) {
631     // In Acrobat, hidden flag cancels the print one
632     // (see annotation_hidden_print.pdf).
633     return (
634       this._hasFlag(flags, AnnotationFlag.PRINT) &&
635       !this._hasFlag(flags, AnnotationFlag.HIDDEN) &&
636       !this._hasFlag(flags, AnnotationFlag.INVISIBLE)
637     );
638   }
639 
640   /**
641    * Check if the annotation must be displayed by taking into account
642    * the value found in the annotationStorage which may have been set
643    * through JS.
644    *
645    * @public
646    * @memberof Annotation
647    * @param {AnnotationStorage} [annotationStorage] - Storage for annotation
648    * @param {boolean} [_renderForms] - if true widgets are rendered thanks to
649    *                                   the annotation layer.
650    */
651   mustBeViewed(annotationStorage, _renderForms) {
652     const noView = annotationStorage?.get(this.data.id)?.noView;
653     if (noView !== undefined) {
654       return !noView;
655     }
656     return this.viewable && !this._hasFlag(this.flags, AnnotationFlag.HIDDEN);
657   }
658 
659   /**
660    * Check if the annotation must be printed by taking into account
661    * the value found in the annotationStorage which may have been set
662    * through JS.
663    *
664    * @public
665    * @memberof Annotation
666    * @param {AnnotationStorage} [annotationStorage] - Storage for annotation
667    */
668   mustBePrinted(annotationStorage) {
669     const noPrint = annotationStorage?.get(this.data.id)?.noPrint;
670     if (noPrint !== undefined) {
671       return !noPrint;
672     }
673     return this.printable;
674   }
675 
676   /**
677    * @type {boolean}
678    */
679   get viewable() {
680     if (this.data.quadPoints === null) {
681       return false;
682     }
683     if (this.flags === 0) {
684       return true;
685     }
686     return this._isViewable(this.flags);
687   }
688 
689   /**
690    * @type {boolean}
691    */
692   get printable() {
693     if (this.data.quadPoints === null) {
694       return false;
695     }
696     if (this.flags === 0) {
697       return false;
698     }
699     return this._isPrintable(this.flags);
700   }
701 
702   /**
703    * @private
704    */
705   _parseStringHelper(data) {
706     const str = typeof data === "string" ? stringToPDFString(data) : "";
707     const dir = str && bidi(str).dir === "rtl" ? "rtl" : "ltr";
708 
709     return { str, dir };
710   }
711 
712   setDefaultAppearance(params) {
713     const defaultAppearance =
714       getInheritableProperty({ dict: params.dict, key: "DA" }) ||
715       params.acroForm.get("DA");
716     this._defaultAppearance =
717       typeof defaultAppearance === "string" ? defaultAppearance : "";
718     this.data.defaultAppearanceData = parseDefaultAppearance(
719       this._defaultAppearance
720     );
721   }
722 
723   /**
724    * Set the title.
725    *
726    * @param {string} title - The title of the annotation, used e.g. with
727    *   PopupAnnotations.
728    */
729   setTitle(title) {
730     this._title = this._parseStringHelper(title);
731   }
732 
733   /**
734    * Set the contents.
735    *
736    * @param {string} contents - Text to display for the annotation or, if the
737    *                            type of annotation does not display text, a
738    *                            description of the annotation's contents
739    */
740   setContents(contents) {
741     this._contents = this._parseStringHelper(contents);
742   }
743 
744   /**
745    * Set the modification date.
746    *
747    * @public
748    * @memberof Annotation
749    * @param {string} modificationDate - PDF date string that indicates when the
750    *                                    annotation was last modified
751    */
752   setModificationDate(modificationDate) {
753     this.modificationDate =
754       typeof modificationDate === "string" ? modificationDate : null;
755   }
756 
757   /**
758    * Set the flags.
759    *
760    * @public
761    * @memberof Annotation
762    * @param {number} flags - Unsigned 32-bit integer specifying annotation
763    *                         characteristics
764    * @see {@link shared/util.js}
765    */
766   setFlags(flags) {
767     this.flags = Number.isInteger(flags) && flags > 0 ? flags : 0;
768   }
769 
770   /**
771    * Check if a provided flag is set.
772    *
773    * @public
774    * @memberof Annotation
775    * @param {number} flag - Hexadecimal representation for an annotation
776    *                        characteristic
777    * @returns {boolean}
778    * @see {@link shared/util.js}
779    */
780   hasFlag(flag) {
781     return this._hasFlag(this.flags, flag);
782   }
783 
784   /**
785    * Set the rectangle.
786    *
787    * @public
788    * @memberof Annotation
789    * @param {Array} rectangle - The rectangle array with exactly four entries
790    */
791   setRectangle(rectangle) {
792     this.rectangle =
793       Array.isArray(rectangle) && rectangle.length === 4
794         ? Util.normalizeRect(rectangle)
795         : [0, 0, 0, 0];
796   }
797 
798   /**
799    * Set the color and take care of color space conversion.
800    * The default value is black, in RGB color space.
801    *
802    * @public
803    * @memberof Annotation
804    * @param {Array} color - The color array containing either 0
805    *                        (transparent), 1 (grayscale), 3 (RGB) or
806    *                        4 (CMYK) elements
807    */
808   setColor(color) {
809     this.color = getRgbColor(color);
810   }
811 
812   /**
813    * Set the line endings; should only be used with specific annotation types.
814    * @param {Array} lineEndings - The line endings array.
815    */
816   setLineEndings(lineEndings) {
817     this.lineEndings = ["None", "None"]; // The default values.
818 
819     if (Array.isArray(lineEndings) && lineEndings.length === 2) {
820       for (let i = 0; i < 2; i++) {
821         const obj = lineEndings[i];
822 
823         if (obj instanceof Name) {
824           switch (obj.name) {
825             case "None":
826               continue;
827             case "Square":
828             case "Circle":
829             case "Diamond":
830             case "OpenArrow":
831             case "ClosedArrow":
832             case "Butt":
833             case "ROpenArrow":
834             case "RClosedArrow":
835             case "Slash":
836               this.lineEndings[i] = obj.name;
837               continue;
838           }
839         }
840         warn(`Ignoring invalid lineEnding: ${obj}`);
841       }
842     }
843   }
844 
845   setRotation(mk, dict) {
846     this.rotation = 0;
847     let angle = mk instanceof Dict ? mk.get("R") || 0 : dict.get("Rotate") || 0;
848     if (Number.isInteger(angle) && angle !== 0) {
849       angle %= 360;
850       if (angle < 0) {
851         angle += 360;
852       }
853       if (angle % 90 === 0) {
854         this.rotation = angle;
855       }
856     }
857   }
858 
859   /**
860    * Set the color for background and border if any.
861    * The default values are transparent.
862    *
863    * @public
864    * @memberof Annotation
865    * @param {Dict} mk - The MK dictionary
866    */
867   setBorderAndBackgroundColors(mk) {
868     if (mk instanceof Dict) {
869       this.borderColor = getRgbColor(mk.getArray("BC"), null);
870       this.backgroundColor = getRgbColor(mk.getArray("BG"), null);
871     } else {
872       this.borderColor = this.backgroundColor = null;
873     }
874   }
875 
876   /**
877    * Set the border style (as AnnotationBorderStyle object).
878    *
879    * @public
880    * @memberof Annotation
881    * @param {Dict} borderStyle - The border style dictionary
882    */
883   setBorderStyle(borderStyle) {
884     if (typeof PDFJSDev === "undefined" || PDFJSDev.test("TESTING")) {
885       assert(this.rectangle, "setRectangle must have been called previously.");
886     }
887 
888     this.borderStyle = new AnnotationBorderStyle();
889     if (!(borderStyle instanceof Dict)) {
890       return;
891     }
892     if (borderStyle.has("BS")) {
893       const dict = borderStyle.get("BS");
894       const dictType = dict.get("Type");
895 
896       if (!dictType || isName(dictType, "Border")) {
897         this.borderStyle.setWidth(dict.get("W"), this.rectangle);
898         this.borderStyle.setStyle(dict.get("S"));
899         this.borderStyle.setDashArray(dict.getArray("D"));
900       }
901     } else if (borderStyle.has("Border")) {
902       const array = borderStyle.getArray("Border");
903       if (Array.isArray(array) && array.length >= 3) {
904         this.borderStyle.setHorizontalCornerRadius(array[0]);
905         this.borderStyle.setVerticalCornerRadius(array[1]);
906         this.borderStyle.setWidth(array[2], this.rectangle);
907 
908         if (array.length === 4) {
909           // Dash array available
910           this.borderStyle.setDashArray(array[3], /* forceStyle = */ true);
911         }
912       }
913     } else {
914       // There are no border entries in the dictionary. According to the
915       // specification, we should draw a solid border of width 1 in that
916       // case, but Adobe Reader did not implement that part of the
917       // specification and instead draws no border at all, so we do the same.
918       // See also https://github.com/mozilla/pdf.js/issues/6179.
919       this.borderStyle.setWidth(0);
920     }
921   }
922 
923   /**
924    * Set the (normal) appearance.
925    *
926    * @public
927    * @memberof Annotation
928    * @param {Dict} dict - The annotation's data dictionary
929    */
930   setAppearance(dict) {
931     this.appearance = null;
932 
933     const appearanceStates = dict.get("AP");
934     if (!(appearanceStates instanceof Dict)) {
935       return;
936     }
937 
938     // In case the normal appearance is a stream, then it is used directly.
939     const normalAppearanceState = appearanceStates.get("N");
940     if (normalAppearanceState instanceof BaseStream) {
941       this.appearance = normalAppearanceState;
942       return;
943     }
944     if (!(normalAppearanceState instanceof Dict)) {
945       return;
946     }
947 
948     // In case the normal appearance is a dictionary, the `AS` entry provides
949     // the key of the stream in this dictionary.
950     const as = dict.get("AS");
951     if (!(as instanceof Name) || !normalAppearanceState.has(as.name)) {
952       return;
953     }
954     const appearance = normalAppearanceState.get(as.name);
955     if (appearance instanceof BaseStream) {
956       this.appearance = appearance;
957     }
958   }
959 
960   setOptionalContent(dict) {
961     this.oc = null;
962 
963     const oc = dict.get("OC");
964     if (oc instanceof Name) {
965       warn("setOptionalContent: Support for /Name-entry is not implemented.");
966     } else if (oc instanceof Dict) {
967       this.oc = oc;
968     }
969   }
970 
971   loadResources(keys, appearance) {
972     return appearance.dict.getAsync("Resources").then(resources => {
973       if (!resources) {
974         return undefined;
975       }
976 
977       const objectLoader = new ObjectLoader(resources, keys, resources.xref);
978       return objectLoader.load().then(function () {
979         return resources;
980       });
981     });
982   }
983 
984   async getOperatorList(
985     evaluator,
986     task,
987     intent,
988     renderForms,
989     annotationStorage
990   ) {
991     const data = this.data;
992     let appearance = this.appearance;
993     const isUsingOwnCanvas = !!(
994       this.data.hasOwnCanvas && intent & RenderingIntentFlag.DISPLAY
995     );
996     if (!appearance) {
997       if (!isUsingOwnCanvas) {
998         return {
999           opList: new OperatorList(),
1000           separateForm: false,
1001           separateCanvas: false,
1002         };
1003       }
1004       appearance = new StringStream("");
1005       appearance.dict = new Dict();
1006     }
1007 
1008     const appearanceDict = appearance.dict;
1009     const resources = await this.loadResources(
1010       ["ExtGState", "ColorSpace", "Pattern", "Shading", "XObject", "Font"],
1011       appearance
1012     );
1013     const bbox = appearanceDict.getArray("BBox") || [0, 0, 1, 1];
1014     const matrix = appearanceDict.getArray("Matrix") || [1, 0, 0, 1, 0, 0];
1015     const transform = getTransformMatrix(data.rect, bbox, matrix);
1016 
1017     const opList = new OperatorList();
1018 
1019     let optionalContent;
1020     if (this.oc) {
1021       optionalContent = await evaluator.parseMarkedContentProps(
1022         this.oc,
1023         /* resources = */ null
1024       );
1025     }
1026     if (optionalContent !== undefined) {
1027       opList.addOp(OPS.beginMarkedContentProps, ["OC", optionalContent]);
1028     }
1029 
1030     opList.addOp(OPS.beginAnnotation, [
1031       data.id,
1032       data.rect,
1033       transform,
1034       matrix,
1035       isUsingOwnCanvas,
1036     ]);
1037 
1038     await evaluator.getOperatorList({
1039       stream: appearance,
1040       task,
1041       resources,
1042       operatorList: opList,
1043       fallbackFontDict: this._fallbackFontDict,
1044     });
1045     opList.addOp(OPS.endAnnotation, []);
1046 
1047     if (optionalContent !== undefined) {
1048       opList.addOp(OPS.endMarkedContent, []);
1049     }
1050     this.reset();
1051     return { opList, separateForm: false, separateCanvas: isUsingOwnCanvas };
1052   }
1053 
1054   async save(evaluator, task, annotationStorage) {
1055     return null;
1056   }
1057 
1058   get hasTextContent() {
1059     return false;
1060   }
1061 
1062   async extractTextContent(evaluator, task, viewBox) {
1063     if (!this.appearance) {
1064       return;
1065     }
1066 
1067     const resources = await this.loadResources(
1068       ["ExtGState", "Font", "Properties", "XObject"],
1069       this.appearance
1070     );
1071 
1072     const text = [];
1073     const buffer = [];
1074     let firstPosition = null;
1075     const sink = {
1076       desiredSize: Math.Infinity,
1077       ready: true,
1078 
1079       enqueue(chunk, size) {
1080         for (const item of chunk.items) {
1081           if (item.str === undefined) {
1082             continue;
1083           }
1084           firstPosition ||= item.transform.slice(-2);
1085           buffer.push(item.str);
1086           if (item.hasEOL) {
1087             text.push(buffer.join(""));
1088             buffer.length = 0;
1089           }
1090         }
1091       },
1092     };
1093 
1094     await evaluator.getTextContent({
1095       stream: this.appearance,
1096       task,
1097       resources,
1098       includeMarkedContent: true,
1099       sink,
1100       viewBox,
1101     });
1102     this.reset();
1103 
1104     if (buffer.length) {
1105       text.push(buffer.join(""));
1106     }
1107 
1108     if (text.length > 1 || text[0]) {
1109       const appearanceDict = this.appearance.dict;
1110       const bbox = appearanceDict.getArray("BBox") || [0, 0, 1, 1];
1111       const matrix = appearanceDict.getArray("Matrix") || [1, 0, 0, 1, 0, 0];
1112       const rect = this.data.rect;
1113       const transform = getTransformMatrix(rect, bbox, matrix);
1114       transform[4] -= rect[0];
1115       transform[5] -= rect[1];
1116       firstPosition = Util.applyTransform(firstPosition, transform);
1117       firstPosition = Util.applyTransform(firstPosition, matrix);
1118 
1119       this.data.textPosition = firstPosition;
1120       this.data.textContent = text;
1121     }
1122   }
1123 
1124   /**
1125    * Get field data for usage in JS sandbox.
1126    *
1127    * Field object is defined here:
1128    * https://www.adobe.com/content/dam/acom/en/devnet/acrobat/pdfs/js_api_reference.pdf#page=16
1129    *
1130    * @public
1131    * @memberof Annotation
1132    * @returns {Object | null}
1133    */
1134   getFieldObject() {
1135     if (this.data.kidIds) {
1136       return {
1137         id: this.data.id,
1138         actions: this.data.actions,
1139         name: this.data.fieldName,
1140         strokeColor: this.data.borderColor,
1141         fillColor: this.data.backgroundColor,
1142         type: "",
1143         kidIds: this.data.kidIds,
1144         page: this.data.pageIndex,
1145         rotation: this.rotation,
1146       };
1147     }
1148     return null;
1149   }
1150 
1151   /**
1152    * Reset the annotation.
1153    *
1154    * This involves resetting the various streams that are either cached on the
1155    * annotation instance or created during its construction.
1156    *
1157    * @public
1158    * @memberof Annotation
1159    */
1160   reset() {
1161     if (
1162       (typeof PDFJSDev === "undefined" || PDFJSDev.test("TESTING")) &&
1163       this.appearance &&
1164       !this._streams.includes(this.appearance)
1165     ) {
1166       unreachable("The appearance stream should always be reset.");
1167     }
1168 
1169     for (const stream of this._streams) {
1170       stream.reset();
1171     }
1172   }
1173 
1174   /**
1175    * Construct the (fully qualified) field name from the (partial) field
1176    * names of the field and its ancestors.
1177    *
1178    * @private
1179    * @memberof Annotation
1180    * @param {Dict} dict - Complete widget annotation dictionary
1181    * @returns {string}
1182    */
1183   _constructFieldName(dict) {
1184     // Both the `Parent` and `T` fields are optional. While at least one of
1185     // them should be provided, bad PDF generators may fail to do so.
1186     if (!dict.has("T") && !dict.has("Parent")) {
1187       warn("Unknown field name, falling back to empty field name.");
1188       return "";
1189     }
1190 
1191     // If no parent exists, the partial and fully qualified names are equal.
1192     if (!dict.has("Parent")) {
1193       return stringToPDFString(dict.get("T"));
1194     }
1195 
1196     // Form the fully qualified field name by appending the partial name to
1197     // the parent's fully qualified name, separated by a period.
1198     const fieldName = [];
1199     if (dict.has("T")) {
1200       fieldName.unshift(stringToPDFString(dict.get("T")));
1201     }
1202 
1203     let loopDict = dict;
1204     const visited = new RefSet();
1205     if (dict.objId) {
1206       visited.put(dict.objId);
1207     }
1208     while (loopDict.has("Parent")) {
1209       loopDict = loopDict.get("Parent");
1210       if (
1211         !(loopDict instanceof Dict) ||
1212         (loopDict.objId && visited.has(loopDict.objId))
1213       ) {
1214         // Even though it is not allowed according to the PDF specification,
1215         // bad PDF generators may provide a `Parent` entry that is not a
1216         // dictionary, but `null` for example (issue 8143).
1217         //
1218         // If parent has been already visited, it means that we're
1219         // in an infinite loop.
1220         break;
1221       }
1222       if (loopDict.objId) {
1223         visited.put(loopDict.objId);
1224       }
1225 
1226       if (loopDict.has("T")) {
1227         const t = stringToPDFString(loopDict.get("T"));
1228         if (!t.startsWith("#")) {
1229           // If it starts with a # then it's a class which is not a concept for
1230           // datasets elements (https://www.pdfa.org/norm-refs/XFA-3_3.pdf#page=96).
1231           fieldName.unshift(t);
1232         }
1233       }
1234     }
1235     return fieldName.join(".");
1236   }
1237 }
1238 
1239 /**
1240  * Contains all data regarding an annotation's border style.
1241  */
1242 class AnnotationBorderStyle {
1243   constructor() {
1244     this.width = 1;
1245     this.style = AnnotationBorderStyleType.SOLID;
1246     this.dashArray = [3];
1247     this.horizontalCornerRadius = 0;
1248     this.verticalCornerRadius = 0;
1249   }
1250 
1251   /**
1252    * Set the width.
1253    *
1254    * @public
1255    * @memberof AnnotationBorderStyle
1256    * @param {number} width - The width.
1257    * @param {Array} rect - The annotation `Rect` entry.
1258    */
1259   setWidth(width, rect = [0, 0, 0, 0]) {
1260     if (typeof PDFJSDev === "undefined" || PDFJSDev.test("TESTING")) {
1261       assert(
1262         Array.isArray(rect) && rect.length === 4,
1263         "A valid `rect` parameter must be provided."
1264       );
1265     }
1266 
1267     // Some corrupt PDF generators may provide the width as a `Name`,
1268     // rather than as a number (fixes issue 10385).
1269     if (width instanceof Name) {
1270       this.width = 0; // This is consistent with the behaviour in Adobe Reader.
1271       return;
1272     }
1273     if (typeof width === "number") {
1274       if (width > 0) {
1275         const maxWidth = (rect[2] - rect[0]) / 2;
1276         const maxHeight = (rect[3] - rect[1]) / 2;
1277 
1278         // Ignore large `width`s, since they lead to the Annotation overflowing
1279         // the size set by the `Rect` entry thus causing the `annotationLayer`
1280         // to render it over the surrounding document (fixes bug1552113.pdf).
1281         if (
1282           maxWidth > 0 &&
1283           maxHeight > 0 &&
1284           (width > maxWidth || width > maxHeight)
1285         ) {
1286           warn(`AnnotationBorderStyle.setWidth - ignoring width: ${width}`);
1287           width = 1;
1288         }
1289       }
1290       this.width = width;
1291     }
1292   }
1293 
1294   /**
1295    * Set the style.
1296    *
1297    * @public
1298    * @memberof AnnotationBorderStyle
1299    * @param {Name} style - The annotation style.
1300    * @see {@link shared/util.js}
1301    */
1302   setStyle(style) {
1303     if (!(style instanceof Name)) {
1304       return;
1305     }
1306     switch (style.name) {
1307       case "S":
1308         this.style = AnnotationBorderStyleType.SOLID;
1309         break;
1310 
1311       case "D":
1312         this.style = AnnotationBorderStyleType.DASHED;
1313         break;
1314 
1315       case "B":
1316         this.style = AnnotationBorderStyleType.BEVELED;
1317         break;
1318 
1319       case "I":
1320         this.style = AnnotationBorderStyleType.INSET;
1321         break;
1322 
1323       case "U":
1324         this.style = AnnotationBorderStyleType.UNDERLINE;
1325         break;
1326 
1327       default:
1328         break;
1329     }
1330   }
1331 
1332   /**
1333    * Set the dash array.
1334    *
1335    * @public
1336    * @memberof AnnotationBorderStyle
1337    * @param {Array} dashArray - The dash array with at least one element
1338    * @param {boolean} [forceStyle]
1339    */
1340   setDashArray(dashArray, forceStyle = false) {
1341     // We validate the dash array, but we do not use it because CSS does not
1342     // allow us to change spacing of dashes. For more information, visit
1343     // http://www.w3.org/TR/css3-background/#the-border-style.
1344     if (Array.isArray(dashArray) && dashArray.length > 0) {
1345       // According to the PDF specification: the elements in `dashArray`
1346       // shall be numbers that are nonnegative and not all equal to zero.
1347       let isValid = true;
1348       let allZeros = true;
1349       for (const element of dashArray) {
1350         const validNumber = +element >= 0;
1351         if (!validNumber) {
1352           isValid = false;
1353           break;
1354         } else if (element > 0) {
1355           allZeros = false;
1356         }
1357       }
1358       if (isValid && !allZeros) {
1359         this.dashArray = dashArray;
1360 
1361         if (forceStyle) {
1362           // Even though we cannot use the dash array in the display layer,
1363           // at least ensure that we use the correct border-style.
1364           this.setStyle(Name.get("D"));
1365         }
1366       } else {
1367         this.width = 0; // Adobe behavior when the array is invalid.
1368       }
1369     } else if (dashArray) {
1370       this.width = 0; // Adobe behavior when the array is invalid.
1371     }
1372   }
1373 
1374   /**
1375    * Set the horizontal corner radius (from a Border dictionary).
1376    *
1377    * @public
1378    * @memberof AnnotationBorderStyle
1379    * @param {number} radius - The horizontal corner radius.
1380    */
1381   setHorizontalCornerRadius(radius) {
1382     if (Number.isInteger(radius)) {
1383       this.horizontalCornerRadius = radius;
1384     }
1385   }
1386 
1387   /**
1388    * Set the vertical corner radius (from a Border dictionary).
1389    *
1390    * @public
1391    * @memberof AnnotationBorderStyle
1392    * @param {number} radius - The vertical corner radius.
1393    */
1394   setVerticalCornerRadius(radius) {
1395     if (Number.isInteger(radius)) {
1396       this.verticalCornerRadius = radius;
1397     }
1398   }
1399 }
1400 
1401 class MarkupAnnotation extends Annotation {
1402   constructor(params) {
1403     super(params);
1404 
1405     const { dict } = params;
1406 
1407     if (dict.has("IRT")) {
1408       const rawIRT = dict.getRaw("IRT");
1409       this.data.inReplyTo = rawIRT instanceof Ref ? rawIRT.toString() : null;
1410 
1411       const rt = dict.get("RT");
1412       this.data.replyType =
1413         rt instanceof Name ? rt.name : AnnotationReplyType.REPLY;
1414     }
1415     let popupRef = null;
1416 
1417     if (this.data.replyType === AnnotationReplyType.GROUP) {
1418       // Subordinate annotations in a group should inherit
1419       // the group attributes from the primary annotation.
1420       const parent = dict.get("IRT");
1421 
1422       this.setTitle(parent.get("T"));
1423       this.data.titleObj = this._title;
1424 
1425       this.setContents(parent.get("Contents"));
1426       this.data.contentsObj = this._contents;
1427 
1428       if (!parent.has("CreationDate")) {
1429         this.data.creationDate = null;
1430       } else {
1431         this.setCreationDate(parent.get("CreationDate"));
1432         this.data.creationDate = this.creationDate;
1433       }
1434 
1435       if (!parent.has("M")) {
1436         this.data.modificationDate = null;
1437       } else {
1438         this.setModificationDate(parent.get("M"));
1439         this.data.modificationDate = this.modificationDate;
1440       }
1441 
1442       popupRef = parent.getRaw("Popup");
1443 
1444       if (!parent.has("C")) {
1445         // Fall back to the default background color.
1446         this.data.color = null;
1447       } else {
1448         this.setColor(parent.getArray("C"));
1449         this.data.color = this.color;
1450       }
1451     } else {
1452       this.data.titleObj = this._title;
1453 
1454       this.setCreationDate(dict.get("CreationDate"));
1455       this.data.creationDate = this.creationDate;
1456 
1457       popupRef = dict.getRaw("Popup");
1458 
1459       if (!dict.has("C")) {
1460         // Fall back to the default background color.
1461         this.data.color = null;
1462       }
1463     }
1464 
1465     this.data.popupRef = popupRef instanceof Ref ? popupRef.toString() : null;
1466 
1467     if (dict.has("RC")) {
1468       this.data.richText = XFAFactory.getRichTextAsHtml(dict.get("RC"));
1469     }
1470   }
1471 
1472   /**
1473    * Set the creation date.
1474    *
1475    * @public
1476    * @memberof MarkupAnnotation
1477    * @param {string} creationDate - PDF date string that indicates when the
1478    *                                annotation was originally created
1479    */
1480   setCreationDate(creationDate) {
1481     this.creationDate = typeof creationDate === "string" ? creationDate : null;
1482   }
1483 
1484   _setDefaultAppearance({
1485     xref,
1486     extra,
1487     strokeColor,
1488     fillColor,
1489     blendMode,
1490     strokeAlpha,
1491     fillAlpha,
1492     pointsCallback,
1493   }) {
1494     let minX = Number.MAX_VALUE;
1495     let minY = Number.MAX_VALUE;
1496     let maxX = Number.MIN_VALUE;
1497     let maxY = Number.MIN_VALUE;
1498 
1499     const buffer = ["q"];
1500     if (extra) {
1501       buffer.push(extra);
1502     }
1503     if (strokeColor) {
1504       buffer.push(`${strokeColor[0]} ${strokeColor[1]} ${strokeColor[2]} RG`);
1505     }
1506     if (fillColor) {
1507       buffer.push(`${fillColor[0]} ${fillColor[1]} ${fillColor[2]} rg`);
1508     }
1509 
1510     let pointsArray = this.data.quadPoints;
1511     if (!pointsArray) {
1512       // If there are no quadpoints, the rectangle should be used instead.
1513       // Convert the rectangle definition to a points array similar to how the
1514       // quadpoints are defined.
1515       pointsArray = [
1516         [
1517           { x: this.rectangle[0], y: this.rectangle[3] },
1518           { x: this.rectangle[2], y: this.rectangle[3] },
1519           { x: this.rectangle[0], y: this.rectangle[1] },
1520           { x: this.rectangle[2], y: this.rectangle[1] },
1521         ],
1522       ];
1523     }
1524 
1525     for (const points of pointsArray) {
1526       const [mX, MX, mY, MY] = pointsCallback(buffer, points);
1527       minX = Math.min(minX, mX);
1528       maxX = Math.max(maxX, MX);
1529       minY = Math.min(minY, mY);
1530       maxY = Math.max(maxY, MY);
1531     }
1532     buffer.push("Q");
1533 
1534     const formDict = new Dict(xref);
1535     const appearanceStreamDict = new Dict(xref);
1536     appearanceStreamDict.set("Subtype", Name.get("Form"));
1537 
1538     const appearanceStream = new StringStream(buffer.join(" "));
1539     appearanceStream.dict = appearanceStreamDict;
1540     formDict.set("Fm0", appearanceStream);
1541 
1542     const gsDict = new Dict(xref);
1543     if (blendMode) {
1544       gsDict.set("BM", Name.get(blendMode));
1545     }
1546     if (typeof strokeAlpha === "number") {
1547       gsDict.set("CA", strokeAlpha);
1548     }
1549     if (typeof fillAlpha === "number") {
1550       gsDict.set("ca", fillAlpha);
1551     }
1552 
1553     const stateDict = new Dict(xref);
1554     stateDict.set("GS0", gsDict);
1555 
1556     const resources = new Dict(xref);
1557     resources.set("ExtGState", stateDict);
1558     resources.set("XObject", formDict);
1559 
1560     const appearanceDict = new Dict(xref);
1561     appearanceDict.set("Resources", resources);
1562     const bbox = (this.data.rect = [minX, minY, maxX, maxY]);
1563     appearanceDict.set("BBox", bbox);
1564 
1565     this.appearance = new StringStream("/GS0 gs /Fm0 Do");
1566     this.appearance.dict = appearanceDict;
1567 
1568     // This method is only called if there is no appearance for the annotation,
1569     // so `this.appearance` is not pushed yet in the `Annotation` constructor.
1570     this._streams.push(this.appearance, appearanceStream);
1571   }
1572 
1573   static async createNewAnnotation(xref, annotation, dependencies, params) {
1574     const annotationRef = annotation.ref || xref.getNewTemporaryRef();
1575     const ap = await this.createNewAppearanceStream(annotation, xref, params);
1576     const buffer = [];
1577     let annotationDict;
1578 
1579     if (ap) {
1580       const apRef = xref.getNewTemporaryRef();
1581       annotationDict = this.createNewDict(annotation, xref, { apRef });
1582       const transform = xref.encrypt
1583         ? xref.encrypt.createCipherTransform(apRef.num, apRef.gen)
1584         : null;
1585       await writeObject(apRef, ap, buffer, transform);
1586       dependencies.push({ ref: apRef, data: buffer.join("") });
1587     } else {
1588       annotationDict = this.createNewDict(annotation, xref, {});
1589     }
1590 
1591     buffer.length = 0;
1592     const transform = xref.encrypt
1593       ? xref.encrypt.createCipherTransform(annotationRef.num, annotationRef.gen)
1594       : null;
1595     await writeObject(annotationRef, annotationDict, buffer, transform);
1596 
1597     return { ref: annotationRef, data: buffer.join("") };
1598   }
1599 
1600   static async createNewPrintAnnotation(xref, annotation, params) {
1601     const ap = await this.createNewAppearanceStream(annotation, xref, params);
1602     const annotationDict = this.createNewDict(annotation, xref, { ap });
1603 
1604     const newAnnotation = new this.prototype.constructor({
1605       dict: annotationDict,
1606       xref,
1607       evaluatorOptions: params.evaluatorOptions,
1608     });
1609 
1610     if (annotation.ref) {
1611       newAnnotation.ref = newAnnotation.refToReplace = annotation.ref;
1612     }
1613 
1614     return newAnnotation;
1615   }
1616 }
1617 
1618 class WidgetAnnotation extends Annotation {
1619   constructor(params) {
1620     super(params);
1621 
1622     const { dict, xref } = params;
1623     const data = this.data;
1624     this._needAppearances = params.needAppearances;
1625 
1626     data.annotationType = AnnotationType.WIDGET;
1627     if (data.fieldName === undefined) {
1628       data.fieldName = this._constructFieldName(dict);
1629     }
1630     if (
1631       data.fieldName &&
1632       /\[\d+\]$/.test(data.fieldName) &&
1633       !dict.has("Kids")
1634     ) {
1635       data.baseFieldName = data.fieldName.substring(
1636         0,
1637         data.fieldName.lastIndexOf("[")
1638       );
1639     }
1640 
1641     if (data.actions === undefined) {
1642       data.actions = collectActions(xref, dict, AnnotationActionEventType);
1643     }
1644 
1645     let fieldValue = getInheritableProperty({
1646       dict,
1647       key: "V",
1648       getArray: true,
1649     });
1650     data.fieldValue = this._decodeFormValue(fieldValue);
1651 
1652     const defaultFieldValue = getInheritableProperty({
1653       dict,
1654       key: "DV",
1655       getArray: true,
1656     });
1657     data.defaultFieldValue = this._decodeFormValue(defaultFieldValue);
1658 
1659     if (fieldValue === undefined && params.xfaDatasets) {
1660       // Try to figure out if we have something in the xfa dataset.
1661       const path = this._title.str;
1662       if (path) {
1663         this._hasValueFromXFA = true;
1664         data.fieldValue = fieldValue = params.xfaDatasets.getValue(path);
1665       }
1666     }
1667 
1668     // When no "V" entry exists, let the fieldValue fallback to the "DV" entry
1669     // (fixes issue13823.pdf).
1670     if (fieldValue === undefined && data.defaultFieldValue !== null) {
1671       data.fieldValue = data.defaultFieldValue;
1672     }
1673 
1674     data.alternativeText = stringToPDFString(dict.get("TU") || "");
1675 
1676     this.setDefaultAppearance(params);
1677 
1678     data.hasAppearance ||=
1679       this._needAppearances &&
1680       data.fieldValue !== undefined &&
1681       data.fieldValue !== null;
1682 
1683     const fieldType = getInheritableProperty({ dict, key: "FT" });
1684     data.fieldType = fieldType instanceof Name ? fieldType.name : null;
1685 
1686     const localResources = getInheritableProperty({ dict, key: "DR" });
1687     const acroFormResources = params.acroForm.get("DR");
1688     const appearanceResources = this.appearance?.dict.get("Resources");
1689 
1690     this._fieldResources = {
1691       localResources,
1692       acroFormResources,
1693       appearanceResources,
1694       mergedResources: Dict.merge({
1695         xref,
1696         dictArray: [localResources, appearanceResources, acroFormResources],
1697         mergeSubDicts: true,
1698       }),
1699     };
1700 
1701     data.fieldFlags = getInheritableProperty({ dict, key: "Ff" });
1702     if (!Number.isInteger(data.fieldFlags) || data.fieldFlags < 0) {
1703       data.fieldFlags = 0;
1704     }
1705 
1706     data.readOnly = this.hasFieldFlag(AnnotationFieldFlag.READONLY);
1707     data.required = this.hasFieldFlag(AnnotationFieldFlag.REQUIRED);
1708     data.hidden =
1709       this._hasFlag(data.annotationFlags, AnnotationFlag.HIDDEN) ||
1710       this._hasFlag(data.annotationFlags, AnnotationFlag.NOVIEW);
1711   }
1712 
1713   /**
1714    * Decode the given form value.
1715    *
1716    * @private
1717    * @memberof WidgetAnnotation
1718    * @param {Array<string>|Name|string} formValue - The (possibly encoded)
1719    *   form value.
1720    * @returns {Array<string>|string|null}
1721    */
1722   _decodeFormValue(formValue) {
1723     if (Array.isArray(formValue)) {
1724       return formValue
1725         .filter(item => typeof item === "string")
1726         .map(item => stringToPDFString(item));
1727     } else if (formValue instanceof Name) {
1728       return stringToPDFString(formValue.name);
1729     } else if (typeof formValue === "string") {
1730       return stringToPDFString(formValue);
1731     }
1732     return null;
1733   }
1734 
1735   /**
1736    * Check if a provided field flag is set.
1737    *
1738    * @public
1739    * @memberof WidgetAnnotation
1740    * @param {number} flag - Hexadecimal representation for an annotation
1741    *                        field characteristic
1742    * @returns {boolean}
1743    * @see {@link shared/util.js}
1744    */
1745   hasFieldFlag(flag) {
1746     return !!(this.data.fieldFlags & flag);
1747   }
1748 
1749   /** @inheritdoc */
1750   _isViewable(flags) {
1751     // We don't take into account the `NOVIEW` or `HIDDEN` flags here,
1752     // since the visibility can be changed by js code, hence in case
1753     // it's made viewable, we should render it (with visibility set to
1754     // hidden).
1755     return !this._hasFlag(flags, AnnotationFlag.INVISIBLE);
1756   }
1757 
1758   /** @inheritdoc */
1759   mustBeViewed(annotationStorage, renderForms) {
1760     if (renderForms) {
1761       return this.viewable;
1762     }
1763     return (
1764       super.mustBeViewed(annotationStorage, renderForms) &&
1765       !this._hasFlag(this.flags, AnnotationFlag.NOVIEW)
1766     );
1767   }
1768 
1769   getRotationMatrix(annotationStorage) {
1770     let rotation = annotationStorage?.get(this.data.id)?.rotation;
1771     if (rotation === undefined) {
1772       rotation = this.rotation;
1773     }
1774 
1775     if (rotation === 0) {
1776       return IDENTITY_MATRIX;
1777     }
1778 
1779     const width = this.data.rect[2] - this.data.rect[0];
1780     const height = this.data.rect[3] - this.data.rect[1];
1781 
1782     return getRotationMatrix(rotation, width, height);
1783   }
1784 
1785   getBorderAndBackgroundAppearances(annotationStorage) {
1786     let rotation = annotationStorage?.get(this.data.id)?.rotation;
1787     if (rotation === undefined) {
1788       rotation = this.rotation;
1789     }
1790 
1791     if (!this.backgroundColor && !this.borderColor) {
1792       return "";
1793     }
1794     const width = this.data.rect[2] - this.data.rect[0];
1795     const height = this.data.rect[3] - this.data.rect[1];
1796     const rect =
1797       rotation === 0 || rotation === 180
1798         ? `0 0 ${width} ${height} re`
1799         : `0 0 ${height} ${width} re`;
1800 
1801     let str = "";
1802     if (this.backgroundColor) {
1803       str = `${getPdfColor(
1804         this.backgroundColor,
1805         /* isFill */ true
1806       )} ${rect} f `;
1807     }
1808 
1809     if (this.borderColor) {
1810       const borderWidth = this.borderStyle.width || 1;
1811       str += `${borderWidth} w ${getPdfColor(
1812         this.borderColor,
1813         /* isFill */ false
1814       )} ${rect} S `;
1815     }
1816 
1817     return str;
1818   }
1819 
1820   async getOperatorList(
1821     evaluator,
1822     task,
1823     intent,
1824     renderForms,
1825     annotationStorage
1826   ) {
1827     // Do not render form elements on the canvas when interactive forms are
1828     // enabled. The display layer is responsible for rendering them instead.
1829     if (
1830       renderForms &&
1831       !(this instanceof SignatureWidgetAnnotation) &&
1832       !this.data.noHTML &&
1833       !this.data.hasOwnCanvas
1834     ) {
1835       return {
1836         opList: new OperatorList(),
1837         separateForm: true,
1838         separateCanvas: false,
1839       };
1840     }
1841 
1842     if (!this._hasText) {
1843       return super.getOperatorList(
1844         evaluator,
1845         task,
1846         intent,
1847         renderForms,
1848         annotationStorage
1849       );
1850     }
1851 
1852     const content = await this._getAppearance(
1853       evaluator,
1854       task,
1855       intent,
1856       annotationStorage
1857     );
1858     if (this.appearance && content === null) {
1859       return super.getOperatorList(
1860         evaluator,
1861         task,
1862         intent,
1863         renderForms,
1864         annotationStorage
1865       );
1866     }
1867 
1868     const opList = new OperatorList();
1869 
1870     // Even if there is an appearance stream, ignore it. This is the
1871     // behaviour used by Adobe Reader.
1872     if (!this._defaultAppearance || content === null) {
1873       return { opList, separateForm: false, separateCanvas: false };
1874     }
1875 
1876     const isUsingOwnCanvas = !!(
1877       this.data.hasOwnCanvas && intent & RenderingIntentFlag.DISPLAY
1878     );
1879 
1880     const matrix = [1, 0, 0, 1, 0, 0];
1881     const bbox = [
1882       0,
1883       0,
1884       this.data.rect[2] - this.data.rect[0],
1885       this.data.rect[3] - this.data.rect[1],
1886     ];
1887     const transform = getTransformMatrix(this.data.rect, bbox, matrix);
1888 
1889     let optionalContent;
1890     if (this.oc) {
1891       optionalContent = await evaluator.parseMarkedContentProps(
1892         this.oc,
1893         /* resources = */ null
1894       );
1895     }
1896     if (optionalContent !== undefined) {
1897       opList.addOp(OPS.beginMarkedContentProps, ["OC", optionalContent]);
1898     }
1899 
1900     opList.addOp(OPS.beginAnnotation, [
1901       this.data.id,
1902       this.data.rect,
1903       transform,
1904       this.getRotationMatrix(annotationStorage),
1905       isUsingOwnCanvas,
1906     ]);
1907 
1908     const stream = new StringStream(content);
1909     await evaluator.getOperatorList({
1910       stream,
1911       task,
1912       resources: this._fieldResources.mergedResources,
1913       operatorList: opList,
1914     });
1915     opList.addOp(OPS.endAnnotation, []);
1916 
1917     if (optionalContent !== undefined) {
1918       opList.addOp(OPS.endMarkedContent, []);
1919     }
1920     return { opList, separateForm: false, separateCanvas: isUsingOwnCanvas };
1921   }
1922 
1923   _getMKDict(rotation) {
1924     const mk = new Dict(null);
1925     if (rotation) {
1926       mk.set("R", rotation);
1927     }
1928     if (this.borderColor) {
1929       mk.set("BC", getPdfColorArray(this.borderColor));
1930     }
1931     if (this.backgroundColor) {
1932       mk.set("BG", getPdfColorArray(this.backgroundColor));
1933     }
1934     return mk.size > 0 ? mk : null;
1935   }
1936 
1937   amendSavedDict(annotationStorage, dict) {}
1938 
1939   async save(evaluator, task, annotationStorage) {
1940     const storageEntry = annotationStorage?.get(this.data.id);
1941     let value = storageEntry?.value,
1942       rotation = storageEntry?.rotation;
1943     if (value === this.data.fieldValue || value === undefined) {
1944       if (!this._hasValueFromXFA && rotation === undefined) {
1945         return null;
1946       }
1947       value ||= this.data.fieldValue;
1948     }
1949 
1950     // Value can be an array (with choice list and multiple selections)
1951     if (
1952       rotation === undefined &&
1953       !this._hasValueFromXFA &&
1954       Array.isArray(value) &&
1955       Array.isArray(this.data.fieldValue) &&
1956       value.length === this.data.fieldValue.length &&
1957       value.every((x, i) => x === this.data.fieldValue[i])
1958     ) {
1959       return null;
1960     }
1961 
1962     if (rotation === undefined) {
1963       rotation = this.rotation;
1964     }
1965 
1966     let appearance = null;
1967     if (!this._needAppearances) {
1968       appearance = await this._getAppearance(
1969         evaluator,
1970         task,
1971         RenderingIntentFlag.SAVE,
1972         annotationStorage
1973       );
1974       if (appearance === null) {
1975         // Appearance didn't change.
1976         return null;
1977       }
1978     } else {
1979       // No need to create an appearance: the pdf has the flag /NeedAppearances
1980       // which means that it's up to the reader to produce an appearance.
1981     }
1982 
1983     let needAppearances = false;
1984     if (appearance?.needAppearances) {
1985       needAppearances = true;
1986       appearance = null;
1987     }
1988 
1989     const { xref } = evaluator;
1990 
1991     const originalDict = xref.fetchIfRef(this.ref);
1992     if (!(originalDict instanceof Dict)) {
1993       return null;
1994     }
1995 
1996     const dict = new Dict(xref);
1997     for (const key of originalDict.getKeys()) {
1998       if (key !== "AP") {
1999         dict.set(key, originalDict.getRaw(key));
2000       }
2001     }
2002 
2003     const xfa = {
2004       path: this.data.fieldName,
2005       value,
2006     };
2007 
2008     const encoder = val => {
2009       return isAscii(val)
2010         ? val
2011         : stringToUTF16String(val, /* bigEndian = */ true);
2012     };
2013     dict.set("V", Array.isArray(value) ? value.map(encoder) : encoder(value));
2014     this.amendSavedDict(annotationStorage, dict);
2015 
2016     const maybeMK = this._getMKDict(rotation);
2017     if (maybeMK) {
2018       dict.set("MK", maybeMK);
2019     }
2020 
2021     const encrypt = xref.encrypt;
2022     const originalTransform = encrypt
2023       ? encrypt.createCipherTransform(this.ref.num, this.ref.gen)
2024       : null;
2025 
2026     const buffer = [];
2027     const changes = [
2028       // data for the original object
2029       // V field changed + reference for new AP
2030       { ref: this.ref, data: "", xfa, needAppearances },
2031     ];
2032     if (appearance !== null) {
2033       const newRef = xref.getNewTemporaryRef();
2034       const AP = new Dict(xref);
2035       dict.set("AP", AP);
2036       AP.set("N", newRef);
2037 
2038       let newTransform = null;
2039       if (encrypt) {
2040         newTransform = encrypt.createCipherTransform(newRef.num, newRef.gen);
2041       }
2042 
2043       const resources = this._getSaveFieldResources(xref);
2044       const appearanceStream = new StringStream(appearance);
2045       const appearanceDict = (appearanceStream.dict = new Dict(xref));
2046       appearanceDict.set("Subtype", Name.get("Form"));
2047       appearanceDict.set("Resources", resources);
2048       appearanceDict.set("BBox", [
2049         0,
2050         0,
2051         this.data.rect[2] - this.data.rect[0],
2052         this.data.rect[3] - this.data.rect[1],
2053       ]);
2054 
2055       const rotationMatrix = this.getRotationMatrix(annotationStorage);
2056       if (rotationMatrix !== IDENTITY_MATRIX) {
2057         // The matrix isn't the identity one.
2058         appearanceDict.set("Matrix", rotationMatrix);
2059       }
2060 
2061       await writeObject(newRef, appearanceStream, buffer, newTransform);
2062 
2063       changes.push(
2064         // data for the new AP
2065         {
2066           ref: newRef,
2067           data: buffer.join(""),
2068           xfa: null,
2069           needAppearances: false,
2070         }
2071       );
2072       buffer.length = 0;
2073     }
2074 
2075     dict.set("M", `D:${getModificationDate()}`);
2076     await writeObject(this.ref, dict, buffer, originalTransform);
2077 
2078     changes[0].data = buffer.join("");
2079 
2080     return changes;
2081   }
2082 
2083   async _getAppearance(evaluator, task, intent, annotationStorage) {
2084     const isPassword = this.hasFieldFlag(AnnotationFieldFlag.PASSWORD);
2085     if (isPassword) {
2086       return null;
2087     }
2088     const storageEntry = annotationStorage?.get(this.data.id);
2089     let value, rotation;
2090     if (storageEntry) {
2091       value = storageEntry.formattedValue || storageEntry.value;
2092       rotation = storageEntry.rotation;
2093     }
2094 
2095     if (
2096       rotation === undefined &&
2097       value === undefined &&
2098       !this._needAppearances
2099     ) {
2100       if (!this._hasValueFromXFA || this.appearance) {
2101         // The annotation hasn't been rendered so use the appearance.
2102         return null;
2103       }
2104     }
2105 
2106     // Empty or it has a trailing whitespace.
2107     const colors = this.getBorderAndBackgroundAppearances(annotationStorage);
2108 
2109     if (value === undefined) {
2110       // The annotation has its value in XFA datasets but not in the V field.
2111       value = this.data.fieldValue;
2112       if (!value) {
2113         return `/Tx BMC q ${colors}Q EMC`;
2114       }
2115     }
2116 
2117     if (Array.isArray(value) && value.length === 1) {
2118       value = value[0];
2119     }
2120 
2121     assert(typeof value === "string", "Expected `value` to be a string.");
2122     value = value.trim();
2123 
2124     if (this.data.combo) {
2125       // The value can be one of the exportValue or any other values.
2126       const option = this.data.options.find(
2127         ({ exportValue }) => value === exportValue
2128       );
2129       value = option?.displayValue || value;
2130     }
2131 
2132     if (value === "") {
2133       // the field is empty: nothing to render
2134       return `/Tx BMC q ${colors}Q EMC`;
2135     }
2136 
2137     if (rotation === undefined) {
2138       rotation = this.rotation;
2139     }
2140 
2141     let lineCount = -1;
2142     let lines;
2143 
2144     // We could have a text containing for example some sequences of chars and
2145     // their diacritics (e.g. "é".normalize("NFKD") shows 1 char when it's 2).
2146     // Positioning diacritics is really something we don't want to do here.
2147     // So if a font has a glyph for a acute accent and one for "e" then we won't
2148     // get any encoding issues but we'll render "e" and then "´".
2149     // It's why we normalize the string. We use NFC to preserve the initial
2150     // string, (e.g. "²".normalize("NFC") === "²"
2151     // but "²".normalize("NFKC") === "2").
2152     //
2153     // TODO: it isn't a perfect solution, some chars like "ẹ́" will be
2154     // decomposed into two chars ("ẹ" and "´"), so we should detect such
2155     // situations and then use either FakeUnicodeFont or set the
2156     // /NeedAppearances flag.
2157     if (this.data.multiLine) {
2158       lines = value.split(/\r\n?|\n/).map(line => line.normalize("NFC"));
2159       lineCount = lines.length;
2160     } else {
2161       lines = [value.replace(/\r\n?|\n/, "").normalize("NFC")];
2162     }
2163 
2164     const defaultPadding = 1;
2165     const defaultHPadding = 2;
2166     let totalHeight = this.data.rect[3] - this.data.rect[1];
2167     let totalWidth = this.data.rect[2] - this.data.rect[0];
2168 
2169     if (rotation === 90 || rotation === 270) {
2170       [totalWidth, totalHeight] = [totalHeight, totalWidth];
2171     }
2172 
2173     if (!this._defaultAppearance) {
2174       // The DA is required and must be a string.
2175       // If there is no font named Helvetica in the resource dictionary,
2176       // the evaluator will fall back to a default font.
2177       // Doing so prevents exceptions and allows saving/printing
2178       // the file as expected.
2179       this.data.defaultAppearanceData = parseDefaultAppearance(
2180         (this._defaultAppearance = "/Helvetica 0 Tf 0 g")
2181       );
2182     }
2183 
2184     let font = await WidgetAnnotation._getFontData(
2185       evaluator,
2186       task,
2187       this.data.defaultAppearanceData,
2188       this._fieldResources.mergedResources
2189     );
2190 
2191     let defaultAppearance, fontSize, lineHeight;
2192     const encodedLines = [];
2193     let encodingError = false;
2194     for (const line of lines) {
2195       const encodedString = font.encodeString(line);
2196       if (encodedString.length > 1) {
2197         encodingError = true;
2198       }
2199       encodedLines.push(encodedString.join(""));
2200     }
2201 
2202     if (encodingError && intent & RenderingIntentFlag.SAVE) {
2203       // We don't have a way to render the field, so we just rely on the
2204       // /NeedAppearances trick to let the different sofware correctly render
2205       // this pdf.
2206       return { needAppearances: true };
2207     }
2208 
2209     // We check that the font is able to encode the string.
2210     if (encodingError && this._isOffscreenCanvasSupported) {
2211       // If it can't then we fallback on fake unicode font (mapped to sans-serif
2212       // for the rendering).
2213       // It means that a printed form can be rendered differently (it depends on
2214       // the sans-serif font) but at least we've something to render.
2215       // In an ideal world the associated font should correctly handle the
2216       // possible chars but a user can add a smiley or whatever.
2217       // We could try to embed a font but it means that we must have access
2218       // to the raw font file.
2219       const fontFamily = this.data.comb ? "monospace" : "sans-serif";
2220       const fakeUnicodeFont = new FakeUnicodeFont(evaluator.xref, fontFamily);
2221       const resources = fakeUnicodeFont.createFontResources(lines.join(""));
2222       const newFont = resources.getRaw("Font");
2223 
2224       if (this._fieldResources.mergedResources.has("Font")) {
2225         const oldFont = this._fieldResources.mergedResources.get("Font");
2226         for (const key of newFont.getKeys()) {
2227           oldFont.set(key, newFont.getRaw(key));
2228         }
2229       } else {
2230         this._fieldResources.mergedResources.set("Font", newFont);
2231       }
2232 
2233       const fontName = fakeUnicodeFont.fontName.name;
2234       font = await WidgetAnnotation._getFontData(
2235         evaluator,
2236         task,
2237         { fontName, fontSize: 0 },
2238         resources
2239       );
2240 
2241       for (let i = 0, ii = encodedLines.length; i < ii; i++) {
2242         encodedLines[i] = stringToUTF16String(lines[i]);
2243       }
2244 
2245       const savedDefaultAppearance = Object.assign(
2246         Object.create(null),
2247         this.data.defaultAppearanceData
2248       );
2249       this.data.defaultAppearanceData.fontSize = 0;
2250       this.data.defaultAppearanceData.fontName = fontName;
2251 
2252       [defaultAppearance, fontSize, lineHeight] = this._computeFontSize(
2253         totalHeight - 2 * defaultPadding,
2254         totalWidth - 2 * defaultHPadding,
2255         value,
2256         font,
2257         lineCount
2258       );
2259 
2260       this.data.defaultAppearanceData = savedDefaultAppearance;
2261     } else {
2262       if (!this._isOffscreenCanvasSupported) {
2263         warn(
2264           "_getAppearance: OffscreenCanvas is not supported, annotation may not render correctly."
2265         );
2266       }
2267 
2268       [defaultAppearance, fontSize, lineHeight] = this._computeFontSize(
2269         totalHeight - 2 * defaultPadding,
2270         totalWidth - 2 * defaultHPadding,
2271         value,
2272         font,
2273         lineCount
2274       );
2275     }
2276 
2277     let descent = font.descent;
2278     if (isNaN(descent)) {
2279       descent = BASELINE_FACTOR * lineHeight;
2280     } else {
2281       descent = Math.max(
2282         BASELINE_FACTOR * lineHeight,
2283         Math.abs(descent) * fontSize
2284       );
2285     }
2286 
2287     // Take into account the space we have to compute the default vertical
2288     // padding.
2289     const defaultVPadding = Math.min(
2290       Math.floor((totalHeight - fontSize) / 2),
2291       defaultPadding
2292     );
2293     const alignment = this.data.textAlignment;
2294 
2295     if (this.data.multiLine) {
2296       return this._getMultilineAppearance(
2297         defaultAppearance,
2298         encodedLines,
2299         font,
2300         fontSize,
2301         totalWidth,
2302         totalHeight,
2303         alignment,
2304         defaultHPadding,
2305         defaultVPadding,
2306         descent,
2307         lineHeight,
2308         annotationStorage
2309       );
2310     }
2311 
2312     if (this.data.comb) {
2313       return this._getCombAppearance(
2314         defaultAppearance,
2315         font,
2316         encodedLines[0],
2317         fontSize,
2318         totalWidth,
2319         totalHeight,
2320         defaultHPadding,
2321         defaultVPadding,
2322         descent,
2323         lineHeight,
2324         annotationStorage
2325       );
2326     }
2327 
2328     const bottomPadding = defaultVPadding + descent;
2329     if (alignment === 0 || alignment > 2) {
2330       // Left alignment: nothing to do
2331       return (
2332         `/Tx BMC q ${colors}BT ` +
2333         defaultAppearance +
2334         ` 1 0 0 1 ${numberToString(defaultHPadding)} ${numberToString(
2335           bottomPadding
2336         )} Tm (${escapeString(encodedLines[0])}) Tj` +
2337         " ET Q EMC"
2338       );
2339     }
2340 
2341     const prevInfo = { shift: 0 };
2342     const renderedText = this._renderText(
2343       encodedLines[0],
2344       font,
2345       fontSize,
2346       totalWidth,
2347       alignment,
2348       prevInfo,
2349       defaultHPadding,
2350       bottomPadding
2351     );
2352     return (
2353       `/Tx BMC q ${colors}BT ` +
2354       defaultAppearance +
2355       ` 1 0 0 1 0 0 Tm ${renderedText}` +
2356       " ET Q EMC"
2357     );
2358   }
2359 
2360   static async _getFontData(evaluator, task, appearanceData, resources) {
2361     const operatorList = new OperatorList();
2362     const initialState = {
2363       font: null,
2364       clone() {
2365         return this;
2366       },
2367     };
2368 
2369     const { fontName, fontSize } = appearanceData;
2370     await evaluator.handleSetFont(
2371       resources,
2372       [fontName && Name.get(fontName), fontSize],
2373       /* fontRef = */ null,
2374       operatorList,
2375       task,
2376       initialState,
2377       /* fallbackFontDict = */ null
2378     );
2379 
2380     return initialState.font;
2381   }
2382 
2383   _getTextWidth(text, font) {
2384     return (
2385       font
2386         .charsToGlyphs(text)
2387         .reduce((width, glyph) => width + glyph.width, 0) / 1000
2388     );
2389   }
2390 
2391   _computeFontSize(height, width, text, font, lineCount) {
2392     let { fontSize } = this.data.defaultAppearanceData;
2393     let lineHeight = (fontSize || 12) * LINE_FACTOR,
2394       numberOfLines = Math.round(height / lineHeight);
2395 
2396     if (!fontSize) {
2397       // A zero value for size means that the font shall be auto-sized:
2398       // its size shall be computed as a function of the height of the
2399       // annotation rectangle (see 12.7.3.3).
2400 
2401       const roundWithTwoDigits = x => Math.floor(x * 100) / 100;
2402 
2403       if (lineCount === -1) {
2404         const textWidth = this._getTextWidth(text, font);
2405         fontSize = roundWithTwoDigits(
2406           Math.min(
2407             height / LINE_FACTOR,
2408             textWidth > width ? width / textWidth : Infinity
2409           )
2410         );
2411         numberOfLines = 1;
2412       } else {
2413         const lines = text.split(/\r\n?|\n/);
2414         const cachedLines = [];
2415         for (const line of lines) {
2416           const encoded = font.encodeString(line).join("");
2417           const glyphs = font.charsToGlyphs(encoded);
2418           const positions = font.getCharPositions(encoded);
2419           cachedLines.push({
2420             line: encoded,
2421             glyphs,
2422             positions,
2423           });
2424         }
2425 
2426         const isTooBig = fsize => {
2427           // Return true when the text doesn't fit the given height.
2428           let totalHeight = 0;
2429           for (const cache of cachedLines) {
2430             const chunks = this._splitLine(null, font, fsize, width, cache);
2431             totalHeight += chunks.length * fsize;
2432             if (totalHeight > height) {
2433               return true;
2434             }
2435           }
2436           return false;
2437         };
2438 
2439         // Hard to guess how many lines there are.
2440         // The field may have been sized to have 10 lines
2441         // and the user entered only 1 so if we get font size from
2442         // height and number of lines then we'll get something too big.
2443         // So we compute a fake number of lines based on height and
2444         // a font size equal to 12 (this is the default font size in
2445         // Acrobat).
2446         // Then we'll adjust font size to what we have really.
2447         numberOfLines = Math.max(numberOfLines, lineCount);
2448 
2449         while (true) {
2450           lineHeight = height / numberOfLines;
2451           fontSize = roundWithTwoDigits(lineHeight / LINE_FACTOR);
2452 
2453           if (isTooBig(fontSize)) {
2454             numberOfLines++;
2455             continue;
2456           }
2457 
2458           break;
2459         }
2460       }
2461 
2462       const { fontName, fontColor } = this.data.defaultAppearanceData;
2463       this._defaultAppearance = createDefaultAppearance({
2464         fontSize,
2465         fontName,
2466         fontColor,
2467       });
2468     }
2469 
2470     return [this._defaultAppearance, fontSize, height / numberOfLines];
2471   }
2472 
2473   _renderText(
2474     text,
2475     font,
2476     fontSize,
2477     totalWidth,
2478     alignment,
2479     prevInfo,
2480     hPadding,
2481     vPadding
2482   ) {
2483     // TODO: we need to take into account (if possible) how the text
2484     // is rendered. For example in arabic, the cumulated width of some
2485     // glyphs isn't equal to the width of the rendered glyphs because
2486     // of ligatures.
2487     let shift;
2488     if (alignment === 1) {
2489       // Center
2490       const width = this._getTextWidth(text, font) * fontSize;
2491       shift = (totalWidth - width) / 2;
2492     } else if (alignment === 2) {
2493       // Right
2494       const width = this._getTextWidth(text, font) * fontSize;
2495       shift = totalWidth - width - hPadding;
2496     } else {
2497       shift = hPadding;
2498     }
2499     const shiftStr = numberToString(shift - prevInfo.shift);
2500     prevInfo.shift = shift;
2501     vPadding = numberToString(vPadding);
2502 
2503     return `${shiftStr} ${vPadding} Td (${escapeString(text)}) Tj`;
2504   }
2505 
2506   /**
2507    * @private
2508    */
2509   _getSaveFieldResources(xref) {
2510     if (typeof PDFJSDev === "undefined" || PDFJSDev.test("TESTING")) {
2511       assert(
2512         this.data.defaultAppearanceData,
2513         "Expected `_defaultAppearanceData` to have been set."
2514       );
2515     }
2516     const { localResources, appearanceResources, acroFormResources } =
2517       this._fieldResources;
2518 
2519     const fontName = this.data.defaultAppearanceData?.fontName;
2520     if (!fontName) {
2521       return localResources || Dict.empty;
2522     }
2523 
2524     for (const resources of [localResources, appearanceResources]) {
2525       if (resources instanceof Dict) {
2526         const localFont = resources.get("Font");
2527         if (localFont instanceof Dict && localFont.has(fontName)) {
2528           return resources;
2529         }
2530       }
2531     }
2532     if (acroFormResources instanceof Dict) {
2533       const acroFormFont = acroFormResources.get("Font");
2534       if (acroFormFont instanceof Dict && acroFormFont.has(fontName)) {
2535         const subFontDict = new Dict(xref);
2536         subFontDict.set(fontName, acroFormFont.getRaw(fontName));
2537 
2538         const subResourcesDict = new Dict(xref);
2539         subResourcesDict.set("Font", subFontDict);
2540 
2541         return Dict.merge({
2542           xref,
2543           dictArray: [subResourcesDict, localResources],
2544           mergeSubDicts: true,
2545         });
2546       }
2547     }
2548     return localResources || Dict.empty;
2549   }
2550 
2551   getFieldObject() {
2552     return null;
2553   }
2554 }
2555 
2556 class TextWidgetAnnotation extends WidgetAnnotation {
2557   constructor(params) {
2558     super(params);
2559 
2560     this.data.hasOwnCanvas = this.data.readOnly && !this.data.noHTML;
2561     this._hasText = true;
2562 
2563     const dict = params.dict;
2564 
2565     // The field value is always a string.
2566     if (typeof this.data.fieldValue !== "string") {
2567       this.data.fieldValue = "";
2568     }
2569 
2570     // Determine the alignment of text in the field.
2571     let alignment = getInheritableProperty({ dict, key: "Q" });
2572     if (!Number.isInteger(alignment) || alignment < 0 || alignment > 2) {
2573       alignment = null;
2574     }
2575     this.data.textAlignment = alignment;
2576 
2577     // Determine the maximum length of text in the field.
2578     let maximumLength = getInheritableProperty({ dict, key: "MaxLen" });
2579     if (!Number.isInteger(maximumLength) || maximumLength < 0) {
2580       maximumLength = 0;
2581     }
2582     this.data.maxLen = maximumLength;
2583 
2584     // Process field flags for the display layer.
2585     this.data.multiLine = this.hasFieldFlag(AnnotationFieldFlag.MULTILINE);
2586     this.data.comb =
2587       this.hasFieldFlag(AnnotationFieldFlag.COMB) &&
2588       !this.hasFieldFlag(AnnotationFieldFlag.MULTILINE) &&
2589       !this.hasFieldFlag(AnnotationFieldFlag.PASSWORD) &&
2590       !this.hasFieldFlag(AnnotationFieldFlag.FILESELECT) &&
2591       this.data.maxLen !== 0;
2592     this.data.doNotScroll = this.hasFieldFlag(AnnotationFieldFlag.DONOTSCROLL);
2593   }
2594 
2595   get hasTextContent() {
2596     return !!this.appearance && !this._needAppearances;
2597   }
2598 
2599   _getCombAppearance(
2600     defaultAppearance,
2601     font,
2602     text,
2603     fontSize,
2604     width,
2605     height,
2606     hPadding,
2607     vPadding,
2608     descent,
2609     lineHeight,
2610     annotationStorage
2611   ) {
2612     const combWidth = width / this.data.maxLen;
2613     // Empty or it has a trailing whitespace.
2614     const colors = this.getBorderAndBackgroundAppearances(annotationStorage);
2615 
2616     const buf = [];
2617     const positions = font.getCharPositions(text);
2618     for (const [start, end] of positions) {
2619       buf.push(`(${escapeString(text.substring(start, end))}) Tj`);
2620     }
2621 
2622     const renderedComb = buf.join(` ${numberToString(combWidth)} 0 Td `);
2623     return (
2624       `/Tx BMC q ${colors}BT ` +
2625       defaultAppearance +
2626       ` 1 0 0 1 ${numberToString(hPadding)} ${numberToString(
2627         vPadding + descent
2628       )} Tm ${renderedComb}` +
2629       " ET Q EMC"
2630     );
2631   }
2632 
2633   _getMultilineAppearance(
2634     defaultAppearance,
2635     lines,
2636     font,
2637     fontSize,
2638     width,
2639     height,
2640     alignment,
2641     hPadding,
2642     vPadding,
2643     descent,
2644     lineHeight,
2645     annotationStorage
2646   ) {
2647     const buf = [];
2648     const totalWidth = width - 2 * hPadding;
2649     const prevInfo = { shift: 0 };
2650     for (let i = 0, ii = lines.length; i < ii; i++) {
2651       const line = lines[i];
2652       const chunks = this._splitLine(line, font, fontSize, totalWidth);
2653       for (let j = 0, jj = chunks.length; j < jj; j++) {
2654         const chunk = chunks[j];
2655         const vShift =
2656           i === 0 && j === 0 ? -vPadding - (lineHeight - descent) : -lineHeight;
2657         buf.push(
2658           this._renderText(
2659             chunk,
2660             font,
2661             fontSize,
2662             width,
2663             alignment,
2664             prevInfo,
2665             hPadding,
2666             vShift
2667           )
2668         );
2669       }
2670     }
2671 
2672     // Empty or it has a trailing whitespace.
2673     const colors = this.getBorderAndBackgroundAppearances(annotationStorage);
2674     const renderedText = buf.join("\n");
2675 
2676     return (
2677       `/Tx BMC q ${colors}BT ` +
2678       defaultAppearance +
2679       ` 1 0 0 1 0 ${numberToString(height)} Tm ${renderedText}` +
2680       " ET Q EMC"
2681     );
2682   }
2683 
2684   _splitLine(line, font, fontSize, width, cache = {}) {
2685     line = cache.line || line;
2686 
2687     const glyphs = cache.glyphs || font.charsToGlyphs(line);
2688 
2689     if (glyphs.length <= 1) {
2690       // Nothing to split
2691       return [line];
2692     }
2693 
2694     const positions = cache.positions || font.getCharPositions(line);
2695     const scale = fontSize / 1000;
2696     const chunks = [];
2697 
2698     let lastSpacePosInStringStart = -1,
2699       lastSpacePosInStringEnd = -1,
2700       lastSpacePos = -1,
2701       startChunk = 0,
2702       currentWidth = 0;
2703 
2704     for (let i = 0, ii = glyphs.length; i < ii; i++) {
2705       const [start, end] = positions[i];
2706       const glyph = glyphs[i];
2707       const glyphWidth = glyph.width * scale;
2708       if (glyph.unicode === " ") {
2709         if (currentWidth + glyphWidth > width) {
2710           // We can break here
2711           chunks.push(line.substring(startChunk, start));
2712           startChunk = start;
2713           currentWidth = glyphWidth;
2714           lastSpacePosInStringStart = -1;
2715           lastSpacePos = -1;
2716         } else {
2717           currentWidth += glyphWidth;
2718           lastSpacePosInStringStart = start;
2719           lastSpacePosInStringEnd = end;
2720           lastSpacePos = i;
2721         }
2722       } else if (currentWidth + glyphWidth > width) {
2723         // We must break to the last white position (if available)
2724         if (lastSpacePosInStringStart !== -1) {
2725           chunks.push(line.substring(startChunk, lastSpacePosInStringEnd));
2726           startChunk = lastSpacePosInStringEnd;
2727           i = lastSpacePos + 1;
2728           lastSpacePosInStringStart = -1;
2729           currentWidth = 0;
2730         } else {
2731           // Just break in the middle of the word
2732           chunks.push(line.substring(startChunk, start));
2733           startChunk = start;
2734           currentWidth = glyphWidth;
2735         }
2736       } else {
2737         currentWidth += glyphWidth;
2738       }
2739     }
2740 
2741     if (startChunk < line.length) {
2742       chunks.push(line.substring(startChunk, line.length));
2743     }
2744 
2745     return chunks;
2746   }
2747 
2748   getFieldObject() {
2749     return {
2750       id: this.data.id,
2751       value: this.data.fieldValue,
2752       defaultValue: this.data.defaultFieldValue || "",
2753       multiline: this.data.multiLine,
2754       password: this.hasFieldFlag(AnnotationFieldFlag.PASSWORD),
2755       charLimit: this.data.maxLen,
2756       comb: this.data.comb,
2757       editable: !this.data.readOnly,
2758       hidden: this.data.hidden,
2759       name: this.data.fieldName,
2760       rect: this.data.rect,
2761       actions: this.data.actions,
2762       page: this.data.pageIndex,
2763       strokeColor: this.data.borderColor,
2764       fillColor: this.data.backgroundColor,
2765       rotation: this.rotation,
2766       type: "text",
2767     };
2768   }
2769 }
2770 
2771 class ButtonWidgetAnnotation extends WidgetAnnotation {
2772   constructor(params) {
2773     super(params);
2774 
2775     this.checkedAppearance = null;
2776     this.uncheckedAppearance = null;
2777 
2778     this.data.checkBox =
2779       !this.hasFieldFlag(AnnotationFieldFlag.RADIO) &&
2780       !this.hasFieldFlag(AnnotationFieldFlag.PUSHBUTTON);
2781     this.data.radioButton =
2782       this.hasFieldFlag(AnnotationFieldFlag.RADIO) &&
2783       !this.hasFieldFlag(AnnotationFieldFlag.PUSHBUTTON);
2784     this.data.pushButton = this.hasFieldFlag(AnnotationFieldFlag.PUSHBUTTON);
2785     this.data.isTooltipOnly = false;
2786 
2787     if (this.data.checkBox) {
2788       this._processCheckBox(params);
2789     } else if (this.data.radioButton) {
2790       this._processRadioButton(params);
2791     } else if (this.data.pushButton) {
2792       this.data.hasOwnCanvas = true;
2793       this._processPushButton(params);
2794     } else {
2795       warn("Invalid field flags for button widget annotation");
2796     }
2797   }
2798 
2799   async getOperatorList(
2800     evaluator,
2801     task,
2802     intent,
2803     renderForms,
2804     annotationStorage
2805   ) {
2806     if (this.data.pushButton) {
2807       return super.getOperatorList(
2808         evaluator,
2809         task,
2810         intent,
2811         false, // we use normalAppearance to render the button
2812         annotationStorage
2813       );
2814     }
2815 
2816     let value = null;
2817     let rotation = null;
2818     if (annotationStorage) {
2819       const storageEntry = annotationStorage.get(this.data.id);
2820       value = storageEntry ? storageEntry.value : null;
2821       rotation = storageEntry ? storageEntry.rotation : null;
2822     }
2823 
2824     if (value === null && this.appearance) {
2825       // Nothing in the annotationStorage.
2826       // But we've a default appearance so use it.
2827       return super.getOperatorList(
2828         evaluator,
2829         task,
2830         intent,
2831         renderForms,
2832         annotationStorage
2833       );
2834     }
2835 
2836     if (value === null || value === undefined) {
2837       // There is no default appearance so use the one derived
2838       // from the field value.
2839       value = this.data.checkBox
2840         ? this.data.fieldValue === this.data.exportValue
2841         : this.data.fieldValue === this.data.buttonValue;
2842     }
2843 
2844     const appearance = value
2845       ? this.checkedAppearance
2846       : this.uncheckedAppearance;
2847     if (appearance) {
2848       const savedAppearance = this.appearance;
2849       const savedMatrix = appearance.dict.getArray("Matrix") || IDENTITY_MATRIX;
2850 
2851       if (rotation) {
2852         appearance.dict.set(
2853           "Matrix",
2854           this.getRotationMatrix(annotationStorage)
2855         );
2856       }
2857 
2858       this.appearance = appearance;
2859       const operatorList = super.getOperatorList(
2860         evaluator,
2861         task,
2862         intent,
2863         renderForms,
2864         annotationStorage
2865       );
2866       this.appearance = savedAppearance;
2867       appearance.dict.set("Matrix", savedMatrix);
2868       return operatorList;
2869     }
2870 
2871     // No appearance
2872     return {
2873       opList: new OperatorList(),
2874       separateForm: false,
2875       separateCanvas: false,
2876     };
2877   }
2878 
2879   async save(evaluator, task, annotationStorage) {
2880     if (this.data.checkBox) {
2881       return this._saveCheckbox(evaluator, task, annotationStorage);
2882     }
2883 
2884     if (this.data.radioButton) {
2885       return this._saveRadioButton(evaluator, task, annotationStorage);
2886     }
2887 
2888     // Nothing to save
2889     return null;
2890   }
2891 
2892   async _saveCheckbox(evaluator, task, annotationStorage) {
2893     if (!annotationStorage) {
2894       return null;
2895     }
2896     const storageEntry = annotationStorage.get(this.data.id);
2897     let rotation = storageEntry?.rotation,
2898       value = storageEntry?.value;
2899 
2900     if (rotation === undefined) {
2901       if (value === undefined) {
2902         return null;
2903       }
2904 
2905       const defaultValue = this.data.fieldValue === this.data.exportValue;
2906       if (defaultValue === value) {
2907         return null;
2908       }
2909     }
2910 
2911     const dict = evaluator.xref.fetchIfRef(this.ref);
2912     if (!(dict instanceof Dict)) {
2913       return null;
2914     }
2915 
2916     if (rotation === undefined) {
2917       rotation = this.rotation;
2918     }
2919     if (value === undefined) {
2920       value = this.data.fieldValue === this.data.exportValue;
2921     }
2922 
2923     const xfa = {
2924       path: this.data.fieldName,
2925       value: value ? this.data.exportValue : "",
2926     };
2927 
2928     const name = Name.get(value ? this.data.exportValue : "Off");
2929     dict.set("V", name);
2930     dict.set("AS", name);
2931     dict.set("M", `D:${getModificationDate()}`);
2932 
2933     const maybeMK = this._getMKDict(rotation);
2934     if (maybeMK) {
2935       dict.set("MK", maybeMK);
2936     }
2937 
2938     const encrypt = evaluator.xref.encrypt;
2939     let originalTransform = null;
2940     if (encrypt) {
2941       originalTransform = encrypt.createCipherTransform(
2942         this.ref.num,
2943         this.ref.gen
2944       );
2945     }
2946 
2947     const buffer = [`${this.ref.num} ${this.ref.gen} obj\n`];
2948     await writeDict(dict, buffer, originalTransform);
2949     buffer.push("\nendobj\n");
2950 
2951     return [{ ref: this.ref, data: buffer.join(""), xfa }];
2952   }
2953 
2954   async _saveRadioButton(evaluator, task, annotationStorage) {
2955     if (!annotationStorage) {
2956       return null;
2957     }
2958     const storageEntry = annotationStorage.get(this.data.id);
2959     let rotation = storageEntry?.rotation,
2960       value = storageEntry?.value;
2961 
2962     if (rotation === undefined) {
2963       if (value === undefined) {
2964         return null;
2965       }
2966 
2967       const defaultValue = this.data.fieldValue === this.data.buttonValue;
2968       if (defaultValue === value) {
2969         return null;
2970       }
2971     }
2972 
2973     const dict = evaluator.xref.fetchIfRef(this.ref);
2974     if (!(dict instanceof Dict)) {
2975       return null;
2976     }
2977 
2978     if (value === undefined) {
2979       value = this.data.fieldValue === this.data.buttonValue;
2980     }
2981 
2982     if (rotation === undefined) {
2983       rotation = this.rotation;
2984     }
2985 
2986     const xfa = {
2987       path: this.data.fieldName,
2988       value: value ? this.data.buttonValue : "",
2989     };
2990 
2991     const name = Name.get(value ? this.data.buttonValue : "Off");
2992     let parentBuffer = null;
2993     const encrypt = evaluator.xref.encrypt;
2994 
2995     if (value) {
2996       if (this.parent instanceof Ref) {
2997         const parent = evaluator.xref.fetch(this.parent);
2998         let parentTransform = null;
2999         if (encrypt) {
3000           parentTransform = encrypt.createCipherTransform(
3001             this.parent.num,
3002             this.parent.gen
3003           );
3004         }
3005         parent.set("V", name);
3006         parentBuffer = [`${this.parent.num} ${this.parent.gen} obj\n`];
3007         await writeDict(parent, parentBuffer, parentTransform);
3008         parentBuffer.push("\nendobj\n");
3009       } else if (this.parent instanceof Dict) {
3010         this.parent.set("V", name);
3011       }
3012     }
3013 
3014     dict.set("AS", name);
3015     dict.set("M", `D:${getModificationDate()}`);
3016 
3017     const maybeMK = this._getMKDict(rotation);
3018     if (maybeMK) {
3019       dict.set("MK", maybeMK);
3020     }
3021 
3022     let originalTransform = null;
3023     if (encrypt) {
3024       originalTransform = encrypt.createCipherTransform(
3025         this.ref.num,
3026         this.ref.gen
3027       );
3028     }
3029 
3030     const buffer = [`${this.ref.num} ${this.ref.gen} obj\n`];
3031     await writeDict(dict, buffer, originalTransform);
3032     buffer.push("\nendobj\n");
3033 
3034     const newRefs = [{ ref: this.ref, data: buffer.join(""), xfa }];
3035     if (parentBuffer !== null) {
3036       newRefs.push({
3037         ref: this.parent,
3038         data: parentBuffer.join(""),
3039         xfa: null,
3040       });
3041     }
3042 
3043     return newRefs;
3044   }
3045 
3046   _getDefaultCheckedAppearance(params, type) {
3047     const width = this.data.rect[2] - this.data.rect[0];
3048     const height = this.data.rect[3] - this.data.rect[1];
3049     const bbox = [0, 0, width, height];
3050 
3051     // Ratio used to have a mark slightly smaller than the bbox.
3052     const FONT_RATIO = 0.8;
3053     const fontSize = Math.min(width, height) * FONT_RATIO;
3054 
3055     // Char Metrics
3056     // Widths came from widths for ZapfDingbats.
3057     // Heights are guessed with Fontforge and FoxitDingbats.pfb.
3058     let metrics, char;
3059     if (type === "check") {
3060       // Char 33 (2713 in unicode)
3061       metrics = {
3062         width: 0.755 * fontSize,
3063         height: 0.705 * fontSize,
3064       };
3065       char = "\x33";
3066     } else if (type === "disc") {
3067       // Char 6C (25CF in unicode)
3068       metrics = {
3069         width: 0.791 * fontSize,
3070         height: 0.705 * fontSize,
3071       };
3072       char = "\x6C";
3073     } else {
3074       unreachable(`_getDefaultCheckedAppearance - unsupported type: ${type}`);
3075     }
3076 
3077     // Values to center the glyph in the bbox.
3078     const xShift = numberToString((width - metrics.width) / 2);
3079     const yShift = numberToString((height - metrics.height) / 2);
3080 
3081     const appearance = `q BT /PdfJsZaDb ${fontSize} Tf 0 g ${xShift} ${yShift} Td (${char}) Tj ET Q`;
3082 
3083     const appearanceStreamDict = new Dict(params.xref);
3084     appearanceStreamDict.set("FormType", 1);
3085     appearanceStreamDict.set("Subtype", Name.get("Form"));
3086     appearanceStreamDict.set("Type", Name.get("XObject"));
3087     appearanceStreamDict.set("BBox", bbox);
3088     appearanceStreamDict.set("Matrix", [1, 0, 0, 1, 0, 0]);
3089     appearanceStreamDict.set("Length", appearance.length);
3090 
3091     const resources = new Dict(params.xref);
3092     const font = new Dict(params.xref);
3093     font.set("PdfJsZaDb", this.fallbackFontDict);
3094     resources.set("Font", font);
3095 
3096     appearanceStreamDict.set("Resources", resources);
3097 
3098     this.checkedAppearance = new StringStream(appearance);
3099     this.checkedAppearance.dict = appearanceStreamDict;
3100 
3101     this._streams.push(this.checkedAppearance);
3102   }
3103 
3104   _processCheckBox(params) {
3105     const customAppearance = params.dict.get("AP");
3106     if (!(customAppearance instanceof Dict)) {
3107       return;
3108     }
3109 
3110     const normalAppearance = customAppearance.get("N");
3111     if (!(normalAppearance instanceof Dict)) {
3112       return;
3113     }
3114 
3115     // See https://bugzilla.mozilla.org/show_bug.cgi?id=1722036.
3116     // If we've an AS and a V then take AS.
3117     const asValue = this._decodeFormValue(params.dict.get("AS"));
3118     if (typeof asValue === "string") {
3119       this.data.fieldValue = asValue;
3120     }
3121 
3122     const yes =
3123       this.data.fieldValue !== null && this.data.fieldValue !== "Off"
3124         ? this.data.fieldValue
3125         : "Yes";
3126 
3127     const exportValues = normalAppearance.getKeys();
3128     if (exportValues.length === 0) {
3129       exportValues.push("Off", yes);
3130     } else if (exportValues.length === 1) {
3131       if (exportValues[0] === "Off") {
3132         exportValues.push(yes);
3133       } else {
3134         exportValues.unshift("Off");
3135       }
3136     } else if (exportValues.includes(yes)) {
3137       exportValues.length = 0;
3138       exportValues.push("Off", yes);
3139     } else {
3140       const otherYes = exportValues.find(v => v !== "Off");
3141       exportValues.length = 0;
3142       exportValues.push("Off", otherYes);
3143     }
3144 
3145     // Don't use a "V" entry pointing to a non-existent appearance state,
3146     // see e.g. bug1720411.pdf where it's an *empty* Name-instance.
3147     if (!exportValues.includes(this.data.fieldValue)) {
3148       this.data.fieldValue = "Off";
3149     }
3150 
3151     this.data.exportValue = exportValues[1];
3152 
3153     const checkedAppearance = normalAppearance.get(this.data.exportValue);
3154     this.checkedAppearance =
3155       checkedAppearance instanceof BaseStream ? checkedAppearance : null;
3156     const uncheckedAppearance = normalAppearance.get("Off");
3157     this.uncheckedAppearance =
3158       uncheckedAppearance instanceof BaseStream ? uncheckedAppearance : null;
3159 
3160     if (this.checkedAppearance) {
3161       this._streams.push(this.checkedAppearance);
3162     } else {
3163       this._getDefaultCheckedAppearance(params, "check");
3164     }
3165     if (this.uncheckedAppearance) {
3166       this._streams.push(this.uncheckedAppearance);
3167     }
3168     this._fallbackFontDict = this.fallbackFontDict;
3169   }
3170 
3171   _processRadioButton(params) {
3172     this.data.fieldValue = this.data.buttonValue = null;
3173 
3174     // The parent field's `V` entry holds a `Name` object with the appearance
3175     // state of whichever child field is currently in the "on" state.
3176     const fieldParent = params.dict.get("Parent");
3177     if (fieldParent instanceof Dict) {
3178       this.parent = params.dict.getRaw("Parent");
3179       const fieldParentValue = fieldParent.get("V");
3180       if (fieldParentValue instanceof Name) {
3181         this.data.fieldValue = this._decodeFormValue(fieldParentValue);
3182       }
3183     }
3184 
3185     // The button's value corresponds to its appearance state.
3186     const appearanceStates = params.dict.get("AP");
3187     if (!(appearanceStates instanceof Dict)) {
3188       return;
3189     }
3190     const normalAppearance = appearanceStates.get("N");
3191     if (!(normalAppearance instanceof Dict)) {
3192       return;
3193     }
3194     for (const key of normalAppearance.getKeys()) {
3195       if (key !== "Off") {
3196         this.data.buttonValue = this._decodeFormValue(key);
3197         break;
3198       }
3199     }
3200 
3201     const checkedAppearance = normalAppearance.get(this.data.buttonValue);
3202     this.checkedAppearance =
3203       checkedAppearance instanceof BaseStream ? checkedAppearance : null;
3204     const uncheckedAppearance = normalAppearance.get("Off");
3205     this.uncheckedAppearance =
3206       uncheckedAppearance instanceof BaseStream ? uncheckedAppearance : null;
3207 
3208     if (this.checkedAppearance) {
3209       this._streams.push(this.checkedAppearance);
3210     } else {
3211       this._getDefaultCheckedAppearance(params, "disc");
3212     }
3213     if (this.uncheckedAppearance) {
3214       this._streams.push(this.uncheckedAppearance);
3215     }
3216     this._fallbackFontDict = this.fallbackFontDict;
3217   }
3218 
3219   _processPushButton(params) {
3220     if (
3221       !params.dict.has("A") &&
3222       !params.dict.has("AA") &&
3223       !this.data.alternativeText
3224     ) {
3225       warn("Push buttons without action dictionaries are not supported");
3226       return;
3227     }
3228 
3229     this.data.isTooltipOnly = !params.dict.has("A") && !params.dict.has("AA");
3230 
3231     Catalog.parseDestDictionary({
3232       destDict: params.dict,
3233       resultObj: this.data,
3234       docBaseUrl: params.pdfManager.docBaseUrl,
3235       docAttachments: params.attachments,
3236     });
3237   }
3238 
3239   getFieldObject() {
3240     let type = "button";
3241     let exportValues;
3242     if (this.data.checkBox) {
3243       type = "checkbox";
3244       exportValues = this.data.exportValue;
3245     } else if (this.data.radioButton) {
3246       type = "radiobutton";
3247       exportValues = this.data.buttonValue;
3248     }
3249     return {
3250       id: this.data.id,
3251       value: this.data.fieldValue || "Off",
3252       defaultValue: this.data.defaultFieldValue,
3253       exportValues,
3254       editable: !this.data.readOnly,
3255       name: this.data.fieldName,
3256       rect: this.data.rect,
3257       hidden: this.data.hidden,
3258       actions: this.data.actions,
3259       page: this.data.pageIndex,
3260       strokeColor: this.data.borderColor,
3261       fillColor: this.data.backgroundColor,
3262       rotation: this.rotation,
3263       type,
3264     };
3265   }
3266 
3267   get fallbackFontDict() {
3268     const dict = new Dict();
3269     dict.set("BaseFont", Name.get("ZapfDingbats"));
3270     dict.set("Type", Name.get("FallbackType"));
3271     dict.set("Subtype", Name.get("FallbackType"));
3272     dict.set("Encoding", Name.get("ZapfDingbatsEncoding"));
3273 
3274     return shadow(this, "fallbackFontDict", dict);
3275   }
3276 }
3277 
3278 class ChoiceWidgetAnnotation extends WidgetAnnotation {
3279   constructor(params) {
3280     super(params);
3281 
3282     const { dict, xref } = params;
3283 
3284     this.indices = dict.getArray("I");
3285     this.hasIndices = Array.isArray(this.indices) && this.indices.length > 0;
3286 
3287     // Determine the options. The options array may consist of strings or
3288     // arrays. If the array consists of arrays, then the first element of
3289     // each array is the export value and the second element of each array is
3290     // the display value. If the array consists of strings, then these
3291     // represent both the export and display value. In this case, we convert
3292     // it to an array of arrays as well for convenience in the display layer.
3293     // Note that the specification does not state that the `Opt` field is
3294     // inheritable, but in practice PDF generators do make annotations
3295     // inherit the options from a parent annotation (issue 8094).
3296     this.data.options = [];
3297 
3298     const options = getInheritableProperty({ dict, key: "Opt" });
3299     if (Array.isArray(options)) {
3300       for (let i = 0, ii = options.length; i < ii; i++) {
3301         const option = xref.fetchIfRef(options[i]);
3302         const isOptionArray = Array.isArray(option);
3303 
3304         this.data.options[i] = {
3305           exportValue: this._decodeFormValue(
3306             isOptionArray ? xref.fetchIfRef(option[0]) : option
3307           ),
3308           displayValue: this._decodeFormValue(
3309             isOptionArray ? xref.fetchIfRef(option[1]) : option
3310           ),
3311         };
3312       }
3313     }
3314 
3315     if (!this.hasIndices) {
3316       // The field value can be `null` if no item is selected, a string if one
3317       // item is selected or an array of strings if multiple items are selected.
3318       // For consistency in the API and convenience in the display layer, we
3319       // always make the field value an array with zero, one or multiple items.
3320       if (typeof this.data.fieldValue === "string") {
3321         this.data.fieldValue = [this.data.fieldValue];
3322       } else if (!this.data.fieldValue) {
3323         this.data.fieldValue = [];
3324       }
3325     } else {
3326       // The specs say that we should have an indices array only with
3327       // multiselectable Choice and the "V" entry should have the
3328       // precedence, but Acrobat itself is using it whatever the
3329       // the "V" entry is (see bug 1770750).
3330       this.data.fieldValue = [];
3331       const ii = this.data.options.length;
3332       for (const i of this.indices) {
3333         if (Number.isInteger(i) && i >= 0 && i < ii) {
3334           this.data.fieldValue.push(this.data.options[i].exportValue);
3335         }
3336       }
3337     }
3338 
3339     // Process field flags for the display layer.
3340     this.data.combo = this.hasFieldFlag(AnnotationFieldFlag.COMBO);
3341     this.data.multiSelect = this.hasFieldFlag(AnnotationFieldFlag.MULTISELECT);
3342     this._hasText = true;
3343   }
3344 
3345   getFieldObject() {
3346     const type = this.data.combo ? "combobox" : "listbox";
3347     const value =
3348       this.data.fieldValue.length > 0 ? this.data.fieldValue[0] : null;
3349     return {
3350       id: this.data.id,
3351       value,
3352       defaultValue: this.data.defaultFieldValue,
3353       editable: !this.data.readOnly,
3354       name: this.data.fieldName,
3355       rect: this.data.rect,
3356       numItems: this.data.fieldValue.length,
3357       multipleSelection: this.data.multiSelect,
3358       hidden: this.data.hidden,
3359       actions: this.data.actions,
3360       items: this.data.options,
3361       page: this.data.pageIndex,
3362       strokeColor: this.data.borderColor,
3363       fillColor: this.data.backgroundColor,
3364       rotation: this.rotation,
3365       type,
3366     };
3367   }
3368 
3369   amendSavedDict(annotationStorage, dict) {
3370     if (!this.hasIndices) {
3371       return;
3372     }
3373     let values = annotationStorage?.get(this.data.id)?.value;
3374     if (!Array.isArray(values)) {
3375       values = [values];
3376     }
3377     const indices = [];
3378     const { options } = this.data;
3379     for (let i = 0, j = 0, ii = options.length; i < ii; i++) {
3380       if (options[i].exportValue === values[j]) {
3381         indices.push(i);
3382         j += 1;
3383       }
3384     }
3385     dict.set("I", indices);
3386   }
3387 
3388   async _getAppearance(evaluator, task, intent, annotationStorage) {
3389     if (this.data.combo) {
3390       return super._getAppearance(evaluator, task, intent, annotationStorage);
3391     }
3392 
3393     let exportedValue, rotation;
3394     const storageEntry = annotationStorage?.get(this.data.id);
3395     if (storageEntry) {
3396       rotation = storageEntry.rotation;
3397       exportedValue = storageEntry.value;
3398     }
3399 
3400     if (
3401       rotation === undefined &&
3402       exportedValue === undefined &&
3403       !this._needAppearances
3404     ) {
3405       // The annotation hasn't been rendered so use the appearance
3406       return null;
3407     }
3408 
3409     if (exportedValue === undefined) {
3410       exportedValue = this.data.fieldValue;
3411     } else if (!Array.isArray(exportedValue)) {
3412       exportedValue = [exportedValue];
3413     }
3414 
3415     const defaultPadding = 1;
3416     const defaultHPadding = 2;
3417     let totalHeight = this.data.rect[3] - this.data.rect[1];
3418     let totalWidth = this.data.rect[2] - this.data.rect[0];
3419 
3420     if (rotation === 90 || rotation === 270) {
3421       [totalWidth, totalHeight] = [totalHeight, totalWidth];
3422     }
3423 
3424     const lineCount = this.data.options.length;
3425     const valueIndices = [];
3426     for (let i = 0; i < lineCount; i++) {
3427       const { exportValue } = this.data.options[i];
3428       if (exportedValue.includes(exportValue)) {
3429         valueIndices.push(i);
3430       }
3431     }
3432 
3433     if (!this._defaultAppearance) {
3434       // The DA is required and must be a string.
3435       // If there is no font named Helvetica in the resource dictionary,
3436       // the evaluator will fall back to a default font.
3437       // Doing so prevents exceptions and allows saving/printing
3438       // the file as expected.
3439       this.data.defaultAppearanceData = parseDefaultAppearance(
3440         (this._defaultAppearance = "/Helvetica 0 Tf 0 g")
3441       );
3442     }
3443 
3444     const font = await WidgetAnnotation._getFontData(
3445       evaluator,
3446       task,
3447       this.data.defaultAppearanceData,
3448       this._fieldResources.mergedResources
3449     );
3450 
3451     let defaultAppearance;
3452     let { fontSize } = this.data.defaultAppearanceData;
3453     if (!fontSize) {
3454       const lineHeight = (totalHeight - defaultPadding) / lineCount;
3455       let lineWidth = -1;
3456       let value;
3457       for (const { displayValue } of this.data.options) {
3458         const width = this._getTextWidth(displayValue, font);
3459         if (width > lineWidth) {
3460           lineWidth = width;
3461           value = displayValue;
3462         }
3463       }
3464 
3465       [defaultAppearance, fontSize] = this._computeFontSize(
3466         lineHeight,
3467         totalWidth - 2 * defaultHPadding,
3468         value,
3469         font,
3470         -1
3471       );
3472     } else {
3473       defaultAppearance = this._defaultAppearance;
3474     }
3475 
3476     const lineHeight = fontSize * LINE_FACTOR;
3477     const vPadding = (lineHeight - fontSize) / 2;
3478     const numberOfVisibleLines = Math.floor(totalHeight / lineHeight);
3479 
3480     let firstIndex = 0;
3481     if (valueIndices.length > 0) {
3482       const minIndex = Math.min(...valueIndices);
3483       const maxIndex = Math.max(...valueIndices);
3484 
3485       firstIndex = Math.max(0, maxIndex - numberOfVisibleLines + 1);
3486       if (firstIndex > minIndex) {
3487         firstIndex = minIndex;
3488       }
3489     }
3490     const end = Math.min(firstIndex + numberOfVisibleLines + 1, lineCount);
3491 
3492     const buf = ["/Tx BMC q", `1 1 ${totalWidth} ${totalHeight} re W n`];
3493 
3494     if (valueIndices.length) {
3495       // This value has been copied/pasted from annotation-choice-widget.pdf.
3496       // It corresponds to rgb(153, 193, 218).
3497       buf.push("0.600006 0.756866 0.854904 rg");
3498 
3499       // Highlight the lines in filling a blue rectangle at the selected
3500       // positions.
3501       for (const index of valueIndices) {
3502         if (firstIndex <= index && index < end) {
3503           buf.push(
3504             `1 ${
3505               totalHeight - (index - firstIndex + 1) * lineHeight
3506             } ${totalWidth} ${lineHeight} re f`
3507           );
3508         }
3509       }
3510     }
3511     buf.push("BT", defaultAppearance, `1 0 0 1 0 ${totalHeight} Tm`);
3512 
3513     const prevInfo = { shift: 0 };
3514     for (let i = firstIndex; i < end; i++) {
3515       const { displayValue } = this.data.options[i];
3516       const vpadding = i === firstIndex ? vPadding : 0;
3517       buf.push(
3518         this._renderText(
3519           displayValue,
3520           font,
3521           fontSize,
3522           totalWidth,
3523           0,
3524           prevInfo,
3525           defaultHPadding,
3526           -lineHeight + vpadding
3527         )
3528       );
3529     }
3530 
3531     buf.push("ET Q EMC");
3532 
3533     return buf.join("\n");
3534   }
3535 }
3536 
3537 class SignatureWidgetAnnotation extends WidgetAnnotation {
3538   constructor(params) {
3539     super(params);
3540 
3541     // Unset the fieldValue since it's (most likely) a `Dict` which is
3542     // non-serializable and will thus cause errors when sending annotations
3543     // to the main-thread (issue 10347).
3544     this.data.fieldValue = null;
3545     this.data.hasOwnCanvas = this.data.noRotate;
3546   }
3547 
3548   getFieldObject() {
3549     return {
3550       id: this.data.id,
3551       value: null,
3552       page: this.data.pageIndex,
3553       type: "signature",
3554     };
3555   }
3556 }
3557 
3558 class TextAnnotation extends MarkupAnnotation {
3559   constructor(params) {
3560     const DEFAULT_ICON_SIZE = 22; // px
3561 
3562     super(params);
3563 
3564     // No rotation for Text (see 12.5.6.4).
3565     this.data.noRotate = true;
3566     this.data.hasOwnCanvas = this.data.noRotate;
3567 
3568     const { dict } = params;
3569     this.data.annotationType = AnnotationType.TEXT;
3570 
3571     if (this.data.hasAppearance) {
3572       this.data.name = "NoIcon";
3573     } else {
3574       this.data.rect[1] = this.data.rect[3] - DEFAULT_ICON_SIZE;
3575       this.data.rect[2] = this.data.rect[0] + DEFAULT_ICON_SIZE;
3576       this.data.name = dict.has("Name") ? dict.get("Name").name : "Note";
3577     }
3578 
3579     if (dict.has("State")) {
3580       this.data.state = dict.get("State") || null;
3581       this.data.stateModel = dict.get("StateModel") || null;
3582     } else {
3583       this.data.state = null;
3584       this.data.stateModel = null;
3585     }
3586   }
3587 }
3588 
3589 class LinkAnnotation extends Annotation {
3590   constructor(params) {
3591     super(params);
3592 
3593     this.data.annotationType = AnnotationType.LINK;
3594 
3595     const quadPoints = getQuadPoints(params.dict, this.rectangle);
3596     if (quadPoints) {
3597       this.data.quadPoints = quadPoints;
3598     }
3599 
3600     // The color entry for a link annotation is the color of the border.
3601     this.data.borderColor ||= this.data.color;
3602 
3603     Catalog.parseDestDictionary({
3604       destDict: params.dict,
3605       resultObj: this.data,
3606       docBaseUrl: params.pdfManager.docBaseUrl,
3607       docAttachments: params.attachments,
3608     });
3609   }
3610 }
3611 
3612 class PopupAnnotation extends Annotation {
3613   constructor(params) {
3614     super(params);
3615 
3616     const { dict } = params;
3617     this.data.annotationType = AnnotationType.POPUP;
3618     if (
3619       this.data.rect[0] === this.data.rect[2] ||
3620       this.data.rect[1] === this.data.rect[3]
3621     ) {
3622       this.data.rect = null;
3623     }
3624 
3625     let parentItem = dict.get("Parent");
3626     if (!parentItem) {
3627       warn("Popup annotation has a missing or invalid parent annotation.");
3628       return;
3629     }
3630 
3631     const parentRect = parentItem.getArray("Rect");
3632     this.data.parentRect =
3633       Array.isArray(parentRect) && parentRect.length === 4
3634         ? Util.normalizeRect(parentRect)
3635         : null;
3636 
3637     const rt = parentItem.get("RT");
3638     if (isName(rt, AnnotationReplyType.GROUP)) {
3639       // Subordinate annotations in a group should inherit
3640       // the group attributes from the primary annotation.
3641       parentItem = parentItem.get("IRT");
3642     }
3643 
3644     if (!parentItem.has("M")) {
3645       this.data.modificationDate = null;
3646     } else {
3647       this.setModificationDate(parentItem.get("M"));
3648       this.data.modificationDate = this.modificationDate;
3649     }
3650 
3651     if (!parentItem.has("C")) {
3652       // Fall back to the default background color.
3653       this.data.color = null;
3654     } else {
3655       this.setColor(parentItem.getArray("C"));
3656       this.data.color = this.color;
3657     }
3658 
3659     // If the Popup annotation is not viewable, but the parent annotation is,
3660     // that is most likely a bug. Fallback to inherit the flags from the parent
3661     // annotation (this is consistent with the behaviour in Adobe Reader).
3662     if (!this.viewable) {
3663       const parentFlags = parentItem.get("F");
3664       if (this._isViewable(parentFlags)) {
3665         this.setFlags(parentFlags);
3666       }
3667     }
3668 
3669     this.setTitle(parentItem.get("T"));
3670     this.data.titleObj = this._title;
3671 
3672     this.setContents(parentItem.get("Contents"));
3673     this.data.contentsObj = this._contents;
3674 
3675     if (parentItem.has("RC")) {
3676       this.data.richText = XFAFactory.getRichTextAsHtml(parentItem.get("RC"));
3677     }
3678 
3679     this.data.open = !!dict.get("Open");
3680   }
3681 }
3682 
3683 class FreeTextAnnotation extends MarkupAnnotation {
3684   constructor(params) {
3685     super(params);
3686 
3687     this.data.hasOwnCanvas = true;
3688 
3689     const { evaluatorOptions, xref } = params;
3690     this.data.annotationType = AnnotationType.FREETEXT;
3691     this.setDefaultAppearance(params);
3692     if (this.appearance) {
3693       const { fontColor, fontSize } = parseAppearanceStream(
3694         this.appearance,
3695         evaluatorOptions,
3696         xref
3697       );
3698       this.data.defaultAppearanceData.fontColor = fontColor;
3699       this.data.defaultAppearanceData.fontSize = fontSize || 10;
3700     } else if (this._isOffscreenCanvasSupported) {
3701       const strokeAlpha = params.dict.get("CA");
3702       const fakeUnicodeFont = new FakeUnicodeFont(xref, "sans-serif");
3703       this.data.defaultAppearanceData.fontSize ||= 10;
3704       const { fontColor, fontSize } = this.data.defaultAppearanceData;
3705       this.appearance = fakeUnicodeFont.createAppearance(
3706         this._contents.str,
3707         this.rectangle,
3708         this.rotation,
3709         fontSize,
3710         fontColor,
3711         strokeAlpha
3712       );
3713       this._streams.push(this.appearance, FakeUnicodeFont.toUnicodeStream);
3714     } else {
3715       warn(
3716         "FreeTextAnnotation: OffscreenCanvas is not supported, annotation may not render correctly."
3717       );
3718     }
3719   }
3720 
3721   get hasTextContent() {
3722     return !!this.appearance;
3723   }
3724 
3725   static createNewDict(annotation, xref, { apRef, ap }) {
3726     const { color, fontSize, rect, rotation, user, value } = annotation;
3727     const freetext = new Dict(xref);
3728     freetext.set("Type", Name.get("Annot"));
3729     freetext.set("Subtype", Name.get("FreeText"));
3730     freetext.set("CreationDate", `D:${getModificationDate()}`);
3731     freetext.set("Rect", rect);
3732     const da = `/Helv ${fontSize} Tf ${getPdfColor(color, /* isFill */ true)}`;
3733     freetext.set("DA", da);
3734     freetext.set(
3735       "Contents",
3736       isAscii(value)
3737         ? value
3738         : stringToUTF16String(value, /* bigEndian = */ true)
3739     );
3740     freetext.set("F", 4);
3741     freetext.set("Border", [0, 0, 0]);
3742     freetext.set("Rotate", rotation);
3743 
3744     if (user) {
3745       freetext.set(
3746         "T",
3747         isAscii(user) ? user : stringToUTF16String(user, /* bigEndian = */ true)
3748       );
3749     }
3750 
3751     if (apRef || ap) {
3752       const n = new Dict(xref);
3753       freetext.set("AP", n);
3754 
3755       if (apRef) {
3756         n.set("N", apRef);
3757       } else {
3758         n.set("N", ap);
3759       }
3760     }
3761 
3762     return freetext;
3763   }
3764 
3765   static async createNewAppearanceStream(annotation, xref, params) {
3766     const { baseFontRef, evaluator, task } = params;
3767     const { color, fontSize, rect, rotation, value } = annotation;
3768 
3769     const resources = new Dict(xref);
3770     const font = new Dict(xref);
3771 
3772     if (baseFontRef) {
3773       font.set("Helv", baseFontRef);
3774     } else {
3775       const baseFont = new Dict(xref);
3776       baseFont.set("BaseFont", Name.get("Helvetica"));
3777       baseFont.set("Type", Name.get("Font"));
3778       baseFont.set("Subtype", Name.get("Type1"));
3779       baseFont.set("Encoding", Name.get("WinAnsiEncoding"));
3780       font.set("Helv", baseFont);
3781     }
3782     resources.set("Font", font);
3783 
3784     const helv = await WidgetAnnotation._getFontData(
3785       evaluator,
3786       task,
3787       {
3788         fontName: "Helv",
3789         fontSize,
3790       },
3791       resources
3792     );
3793 
3794     const [x1, y1, x2, y2] = rect;
3795     let w = x2 - x1;
3796     let h = y2 - y1;
3797 
3798     if (rotation % 180 !== 0) {
3799       [w, h] = [h, w];
3800     }
3801 
3802     const lines = value.split("\n");
3803     const scale = fontSize / 1000;
3804     let totalWidth = -Infinity;
3805     const encodedLines = [];
3806     for (let line of lines) {
3807       const encoded = helv.encodeString(line);
3808       if (encoded.length > 1) {
3809         // The font doesn't contain all the chars.
3810         return null;
3811       }
3812       line = encoded.join("");
3813       encodedLines.push(line);
3814       let lineWidth = 0;
3815       const glyphs = helv.charsToGlyphs(line);
3816       for (const glyph of glyphs) {
3817         lineWidth += glyph.width * scale;
3818       }
3819       totalWidth = Math.max(totalWidth, lineWidth);
3820     }
3821 
3822     let hscale = 1;
3823     if (totalWidth > w) {
3824       hscale = w / totalWidth;
3825     }
3826     let vscale = 1;
3827     const lineHeight = LINE_FACTOR * fontSize;
3828     const lineAscent = (LINE_FACTOR - LINE_DESCENT_FACTOR) * fontSize;
3829     const totalHeight = lineHeight * lines.length;
3830     if (totalHeight > h) {
3831       vscale = h / totalHeight;
3832     }
3833     const fscale = Math.min(hscale, vscale);
3834     const newFontSize = fontSize * fscale;
3835     let firstPoint, clipBox, matrix;
3836     switch (rotation) {
3837       case 0:
3838         matrix = [1, 0, 0, 1];
3839         clipBox = [rect[0], rect[1], w, h];
3840         firstPoint = [rect[0], rect[3] - lineAscent];
3841         break;
3842       case 90:
3843         matrix = [0, 1, -1, 0];
3844         clipBox = [rect[1], -rect[2], w, h];
3845         firstPoint = [rect[1], -rect[0] - lineAscent];
3846         break;
3847       case 180:
3848         matrix = [-1, 0, 0, -1];
3849         clipBox = [-rect[2], -rect[3], w, h];
3850         firstPoint = [-rect[2], -rect[1] - lineAscent];
3851         break;
3852       case 270:
3853         matrix = [0, -1, 1, 0];
3854         clipBox = [-rect[3], rect[0], w, h];
3855         firstPoint = [-rect[3], rect[2] - lineAscent];
3856         break;
3857     }
3858 
3859     const buffer = [
3860       "q",
3861       `${matrix.join(" ")} 0 0 cm`,
3862       `${clipBox.join(" ")} re W n`,
3863       `BT`,
3864       `${getPdfColor(color, /* isFill */ true)}`,
3865       `0 Tc /Helv ${numberToString(newFontSize)} Tf`,
3866     ];
3867 
3868     buffer.push(
3869       `${firstPoint.join(" ")} Td (${escapeString(encodedLines[0])}) Tj`
3870     );
3871     const vShift = numberToString(lineHeight);
3872     for (let i = 1, ii = encodedLines.length; i < ii; i++) {
3873       const line = encodedLines[i];
3874       buffer.push(`0 -${vShift} Td (${escapeString(line)}) Tj`);
3875     }
3876     buffer.push("ET", "Q");
3877     const appearance = buffer.join("\n");
3878 
3879     const appearanceStreamDict = new Dict(xref);
3880     appearanceStreamDict.set("FormType", 1);
3881     appearanceStreamDict.set("Subtype", Name.get("Form"));
3882     appearanceStreamDict.set("Type", Name.get("XObject"));
3883     appearanceStreamDict.set("BBox", rect);
3884     appearanceStreamDict.set("Resources", resources);
3885     appearanceStreamDict.set("Matrix", [1, 0, 0, 1, -rect[0], -rect[1]]);
3886 
3887     const ap = new StringStream(appearance);
3888     ap.dict = appearanceStreamDict;
3889 
3890     return ap;
3891   }
3892 }
3893 
3894 class LineAnnotation extends MarkupAnnotation {
3895   constructor(params) {
3896     super(params);
3897 
3898     const { dict, xref } = params;
3899     this.data.annotationType = AnnotationType.LINE;
3900     this.data.hasOwnCanvas = this.data.noRotate;
3901 
3902     const lineCoordinates = dict.getArray("L");
3903     this.data.lineCoordinates = Util.normalizeRect(lineCoordinates);
3904 
3905     this.setLineEndings(dict.getArray("LE"));
3906     this.data.lineEndings = this.lineEndings;
3907 
3908     if (!this.appearance) {
3909       // The default stroke color is black.
3910       const strokeColor = this.color ? getPdfColorArray(this.color) : [0, 0, 0];
3911       const strokeAlpha = dict.get("CA");
3912 
3913       const interiorColor = getRgbColor(dict.getArray("IC"), null);
3914       // The default fill color is transparent. Setting the fill colour is
3915       // necessary if/when we want to add support for non-default line endings.
3916       const fillColor = interiorColor ? getPdfColorArray(interiorColor) : null;
3917       const fillAlpha = fillColor ? strokeAlpha : null;
3918 
3919       const borderWidth = this.borderStyle.width || 1,
3920         borderAdjust = 2 * borderWidth;
3921 
3922       // If the /Rect-entry is empty/wrong, create a fallback rectangle so that
3923       // we get similar rendering/highlighting behaviour as in Adobe Reader.
3924       const bbox = [
3925         this.data.lineCoordinates[0] - borderAdjust,
3926         this.data.lineCoordinates[1] - borderAdjust,
3927         this.data.lineCoordinates[2] + borderAdjust,
3928         this.data.lineCoordinates[3] + borderAdjust,
3929       ];
3930       if (!Util.intersect(this.rectangle, bbox)) {
3931         this.rectangle = bbox;
3932       }
3933 
3934       this._setDefaultAppearance({
3935         xref,
3936         extra: `${borderWidth} w`,
3937         strokeColor,
3938         fillColor,
3939         strokeAlpha,
3940         fillAlpha,
3941         pointsCallback: (buffer, points) => {
3942           buffer.push(
3943             `${lineCoordinates[0]} ${lineCoordinates[1]} m`,
3944             `${lineCoordinates[2]} ${lineCoordinates[3]} l`,
3945             "S"
3946           );
3947           return [
3948             points[0].x - borderWidth,
3949             points[1].x + borderWidth,
3950             points[3].y - borderWidth,
3951             points[1].y + borderWidth,
3952           ];
3953         },
3954       });
3955     }
3956   }
3957 }
3958 
3959 class SquareAnnotation extends MarkupAnnotation {
3960   constructor(params) {
3961     super(params);
3962 
3963     const { dict, xref } = params;
3964     this.data.annotationType = AnnotationType.SQUARE;
3965     this.data.hasOwnCanvas = this.data.noRotate;
3966 
3967     if (!this.appearance) {
3968       // The default stroke color is black.
3969       const strokeColor = this.color ? getPdfColorArray(this.color) : [0, 0, 0];
3970       const strokeAlpha = dict.get("CA");
3971 
3972       const interiorColor = getRgbColor(dict.getArray("IC"), null);
3973       // The default fill color is transparent.
3974       const fillColor = interiorColor ? getPdfColorArray(interiorColor) : null;
3975       const fillAlpha = fillColor ? strokeAlpha : null;
3976 
3977       if (this.borderStyle.width === 0 && !fillColor) {
3978         // Prevent rendering a "hairline" border (fixes issue14164.pdf).
3979         return;
3980       }
3981 
3982       this._setDefaultAppearance({
3983         xref,
3984         extra: `${this.borderStyle.width} w`,
3985         strokeColor,
3986         fillColor,
3987         strokeAlpha,
3988         fillAlpha,
3989         pointsCallback: (buffer, points) => {
3990           const x = points[2].x + this.borderStyle.width / 2;
3991           const y = points[2].y + this.borderStyle.width / 2;
3992           const width = points[3].x - points[2].x - this.borderStyle.width;
3993           const height = points[1].y - points[3].y - this.borderStyle.width;
3994           buffer.push(`${x} ${y} ${width} ${height} re`);
3995           if (fillColor) {
3996             buffer.push("B");
3997           } else {
3998             buffer.push("S");
3999           }
4000           return [points[0].x, points[1].x, points[3].y, points[1].y];
4001         },
4002       });
4003     }
4004   }
4005 }
4006 
4007 class CircleAnnotation extends MarkupAnnotation {
4008   constructor(params) {
4009     super(params);
4010 
4011     const { dict, xref } = params;
4012     this.data.annotationType = AnnotationType.CIRCLE;
4013 
4014     if (!this.appearance) {
4015       // The default stroke color is black.
4016       const strokeColor = this.color ? getPdfColorArray(this.color) : [0, 0, 0];
4017       const strokeAlpha = dict.get("CA");
4018 
4019       const interiorColor = getRgbColor(dict.getArray("IC"), null);
4020       // The default fill color is transparent.
4021       const fillColor = interiorColor ? getPdfColorArray(interiorColor) : null;
4022       const fillAlpha = fillColor ? strokeAlpha : null;
4023 
4024       if (this.borderStyle.width === 0 && !fillColor) {
4025         // Prevent rendering a "hairline" border (fixes issue14164.pdf).
4026         return;
4027       }
4028 
4029       // Circles are approximated by Bézier curves with four segments since
4030       // there is no circle primitive in the PDF specification. For the control
4031       // points distance, see https://stackoverflow.com/a/27863181.
4032       const controlPointsDistance = (4 / 3) * Math.tan(Math.PI / (2 * 4));
4033 
4034       this._setDefaultAppearance({
4035         xref,
4036         extra: `${this.borderStyle.width} w`,
4037         strokeColor,
4038         fillColor,
4039         strokeAlpha,
4040         fillAlpha,
4041         pointsCallback: (buffer, points) => {
4042           const x0 = points[0].x + this.borderStyle.width / 2;
4043           const y0 = points[0].y - this.borderStyle.width / 2;
4044           const x1 = points[3].x - this.borderStyle.width / 2;
4045           const y1 = points[3].y + this.borderStyle.width / 2;
4046           const xMid = x0 + (x1 - x0) / 2;
4047           const yMid = y0 + (y1 - y0) / 2;
4048           const xOffset = ((x1 - x0) / 2) * controlPointsDistance;
4049           const yOffset = ((y1 - y0) / 2) * controlPointsDistance;
4050 
4051           buffer.push(
4052             `${xMid} ${y1} m`,
4053             `${xMid + xOffset} ${y1} ${x1} ${yMid + yOffset} ${x1} ${yMid} c`,
4054             `${x1} ${yMid - yOffset} ${xMid + xOffset} ${y0} ${xMid} ${y0} c`,
4055             `${xMid - xOffset} ${y0} ${x0} ${yMid - yOffset} ${x0} ${yMid} c`,
4056             `${x0} ${yMid + yOffset} ${xMid - xOffset} ${y1} ${xMid} ${y1} c`,
4057             "h"
4058           );
4059           if (fillColor) {
4060             buffer.push("B");
4061           } else {
4062             buffer.push("S");
4063           }
4064           return [points[0].x, points[1].x, points[3].y, points[1].y];
4065         },
4066       });
4067     }
4068   }
4069 }
4070 
4071 class PolylineAnnotation extends MarkupAnnotation {
4072   constructor(params) {
4073     super(params);
4074 
4075     const { dict, xref } = params;
4076     this.data.annotationType = AnnotationType.POLYLINE;
4077     this.data.hasOwnCanvas = this.data.noRotate;
4078     this.data.vertices = [];
4079 
4080     if (!(this instanceof PolygonAnnotation)) {
4081       // Only meaningful for polyline annotations.
4082       this.setLineEndings(dict.getArray("LE"));
4083       this.data.lineEndings = this.lineEndings;
4084     }
4085 
4086     // The vertices array is an array of numbers representing the alternating
4087     // horizontal and vertical coordinates, respectively, of each vertex.
4088     // Convert this to an array of objects with x and y coordinates.
4089     const rawVertices = dict.getArray("Vertices");
4090     if (!Array.isArray(rawVertices)) {
4091       return;
4092     }
4093     for (let i = 0, ii = rawVertices.length; i < ii; i += 2) {
4094       this.data.vertices.push({
4095         x: rawVertices[i],
4096         y: rawVertices[i + 1],
4097       });
4098     }
4099 
4100     if (!this.appearance) {
4101       // The default stroke color is black.
4102       const strokeColor = this.color ? getPdfColorArray(this.color) : [0, 0, 0];
4103       const strokeAlpha = dict.get("CA");
4104 
4105       const borderWidth = this.borderStyle.width || 1,
4106         borderAdjust = 2 * borderWidth;
4107 
4108       // If the /Rect-entry is empty/wrong, create a fallback rectangle so that
4109       // we get similar rendering/highlighting behaviour as in Adobe Reader.
4110       const bbox = [Infinity, Infinity, -Infinity, -Infinity];
4111       for (const vertex of this.data.vertices) {
4112         bbox[0] = Math.min(bbox[0], vertex.x - borderAdjust);
4113         bbox[1] = Math.min(bbox[1], vertex.y - borderAdjust);
4114         bbox[2] = Math.max(bbox[2], vertex.x + borderAdjust);
4115         bbox[3] = Math.max(bbox[3], vertex.y + borderAdjust);
4116       }
4117       if (!Util.intersect(this.rectangle, bbox)) {
4118         this.rectangle = bbox;
4119       }
4120 
4121       this._setDefaultAppearance({
4122         xref,
4123         extra: `${borderWidth} w`,
4124         strokeColor,
4125         strokeAlpha,
4126         pointsCallback: (buffer, points) => {
4127           const vertices = this.data.vertices;
4128           for (let i = 0, ii = vertices.length; i < ii; i++) {
4129             buffer.push(
4130               `${vertices[i].x} ${vertices[i].y} ${i === 0 ? "m" : "l"}`
4131             );
4132           }
4133           buffer.push("S");
4134           return [points[0].x, points[1].x, points[3].y, points[1].y];
4135         },
4136       });
4137     }
4138   }
4139 }
4140 
4141 class PolygonAnnotation extends PolylineAnnotation {
4142   constructor(params) {
4143     // Polygons are specific forms of polylines, so reuse their logic.
4144     super(params);
4145 
4146     this.data.annotationType = AnnotationType.POLYGON;
4147   }
4148 }
4149 
4150 class CaretAnnotation extends MarkupAnnotation {
4151   constructor(params) {
4152     super(params);
4153 
4154     this.data.annotationType = AnnotationType.CARET;
4155   }
4156 }
4157 
4158 class InkAnnotation extends MarkupAnnotation {
4159   constructor(params) {
4160     super(params);
4161 
4162     this.data.hasOwnCanvas = this.data.noRotate;
4163 
4164     const { dict, xref } = params;
4165     this.data.annotationType = AnnotationType.INK;
4166     this.data.inkLists = [];
4167 
4168     const rawInkLists = dict.getArray("InkList");
4169     if (!Array.isArray(rawInkLists)) {
4170       return;
4171     }
4172     for (let i = 0, ii = rawInkLists.length; i < ii; ++i) {
4173       // The raw ink lists array contains arrays of numbers representing
4174       // the alternating horizontal and vertical coordinates, respectively,
4175       // of each vertex. Convert this to an array of objects with x and y
4176       // coordinates.
4177       this.data.inkLists.push([]);
4178       for (let j = 0, jj = rawInkLists[i].length; j < jj; j += 2) {
4179         this.data.inkLists[i].push({
4180           x: xref.fetchIfRef(rawInkLists[i][j]),
4181           y: xref.fetchIfRef(rawInkLists[i][j + 1]),
4182         });
4183       }
4184     }
4185 
4186     if (!this.appearance) {
4187       // The default stroke color is black.
4188       const strokeColor = this.color ? getPdfColorArray(this.color) : [0, 0, 0];
4189       const strokeAlpha = dict.get("CA");
4190 
4191       const borderWidth = this.borderStyle.width || 1,
4192         borderAdjust = 2 * borderWidth;
4193 
4194       // If the /Rect-entry is empty/wrong, create a fallback rectangle so that
4195       // we get similar rendering/highlighting behaviour as in Adobe Reader.
4196       const bbox = [Infinity, Infinity, -Infinity, -Infinity];
4197       for (const inkLists of this.data.inkLists) {
4198         for (const vertex of inkLists) {
4199           bbox[0] = Math.min(bbox[0], vertex.x - borderAdjust);
4200           bbox[1] = Math.min(bbox[1], vertex.y - borderAdjust);
4201           bbox[2] = Math.max(bbox[2], vertex.x + borderAdjust);
4202           bbox[3] = Math.max(bbox[3], vertex.y + borderAdjust);
4203         }
4204       }
4205       if (!Util.intersect(this.rectangle, bbox)) {
4206         this.rectangle = bbox;
4207       }
4208 
4209       this._setDefaultAppearance({
4210         xref,
4211         extra: `${borderWidth} w`,
4212         strokeColor,
4213         strokeAlpha,
4214         pointsCallback: (buffer, points) => {
4215           // According to the specification, see "12.5.6.13 Ink Annotations":
4216           //   When drawn, the points shall be connected by straight lines or
4217           //   curves in an implementation-dependent way.
4218           // In order to simplify things, we utilize straight lines for now.
4219           for (const inkList of this.data.inkLists) {
4220             for (let i = 0, ii = inkList.length; i < ii; i++) {
4221               buffer.push(
4222                 `${inkList[i].x} ${inkList[i].y} ${i === 0 ? "m" : "l"}`
4223               );
4224             }
4225             buffer.push("S");
4226           }
4227           return [points[0].x, points[1].x, points[3].y, points[1].y];
4228         },
4229       });
4230     }
4231   }
4232 
4233   static createNewDict(annotation, xref, { apRef, ap }) {
4234     const { color, opacity, paths, rect, rotation, thickness } = annotation;
4235     const ink = new Dict(xref);
4236     ink.set("Type", Name.get("Annot"));
4237     ink.set("Subtype", Name.get("Ink"));
4238     ink.set("CreationDate", `D:${getModificationDate()}`);
4239     ink.set("Rect", rect);
4240     ink.set(
4241       "InkList",
4242       paths.map(p => p.points)
4243     );
4244     ink.set("F", 4);
4245     ink.set("Rotate", rotation);
4246 
4247     // Line thickness.
4248     const bs = new Dict(xref);
4249     ink.set("BS", bs);
4250     bs.set("W", thickness);
4251 
4252     // Color.
4253     ink.set(
4254       "C",
4255       Array.from(color, c => c / 255)
4256     );
4257 
4258     // Opacity.
4259     ink.set("CA", opacity);
4260 
4261     const n = new Dict(xref);
4262     ink.set("AP", n);
4263 
4264     if (apRef) {
4265       n.set("N", apRef);
4266     } else {
4267       n.set("N", ap);
4268     }
4269 
4270     return ink;
4271   }
4272 
4273   static async createNewAppearanceStream(annotation, xref, params) {
4274     const { color, rect, paths, thickness, opacity } = annotation;
4275 
4276     const appearanceBuffer = [
4277       `${thickness} w 1 J 1 j`,
4278       `${getPdfColor(color, /* isFill */ false)}`,
4279     ];
4280 
4281     if (opacity !== 1) {
4282       appearanceBuffer.push("/R0 gs");
4283     }
4284 
4285     const buffer = [];
4286     for (const { bezier } of paths) {
4287       buffer.length = 0;
4288       buffer.push(
4289         `${numberToString(bezier[0])} ${numberToString(bezier[1])} m`
4290       );
4291       for (let i = 2, ii = bezier.length; i < ii; i += 6) {
4292         const curve = bezier
4293           .slice(i, i + 6)
4294           .map(numberToString)
4295           .join(" ");
4296         buffer.push(`${curve} c`);
4297       }
4298       buffer.push("S");
4299       appearanceBuffer.push(buffer.join("\n"));
4300     }
4301     const appearance = appearanceBuffer.join("\n");
4302 
4303     const appearanceStreamDict = new Dict(xref);
4304     appearanceStreamDict.set("FormType", 1);
4305     appearanceStreamDict.set("Subtype", Name.get("Form"));
4306     appearanceStreamDict.set("Type", Name.get("XObject"));
4307     appearanceStreamDict.set("BBox", rect);
4308     appearanceStreamDict.set("Length", appearance.length);
4309 
4310     if (opacity !== 1) {
4311       const resources = new Dict(xref);
4312       const extGState = new Dict(xref);
4313       const r0 = new Dict(xref);
4314       r0.set("CA", opacity);
4315       r0.set("Type", Name.get("ExtGState"));
4316       extGState.set("R0", r0);
4317       resources.set("ExtGState", extGState);
4318       appearanceStreamDict.set("Resources", resources);
4319     }
4320 
4321     const ap = new StringStream(appearance);
4322     ap.dict = appearanceStreamDict;
4323 
4324     return ap;
4325   }
4326 }
4327 
4328 class HighlightAnnotation extends MarkupAnnotation {
4329   constructor(params) {
4330     super(params);
4331 
4332     const { dict, xref } = params;
4333     this.data.annotationType = AnnotationType.HIGHLIGHT;
4334 
4335     const quadPoints = (this.data.quadPoints = getQuadPoints(dict, null));
4336     if (quadPoints) {
4337       const resources = this.appearance?.dict.get("Resources");
4338 
4339       if (!this.appearance || !resources?.has("ExtGState")) {
4340         if (this.appearance) {
4341           // Workaround for cases where there's no /ExtGState-entry directly
4342           // available, e.g. when the appearance stream contains a /XObject of
4343           // the /Form-type, since that causes the highlighting to completely
4344           // obscure the PDF content below it (fixes issue13242.pdf).
4345           warn("HighlightAnnotation - ignoring built-in appearance stream.");
4346         }
4347         // Default color is yellow in Acrobat Reader
4348         const fillColor = this.color ? getPdfColorArray(this.color) : [1, 1, 0];
4349         const fillAlpha = dict.get("CA");
4350 
4351         this._setDefaultAppearance({
4352           xref,
4353           fillColor,
4354           blendMode: "Multiply",
4355           fillAlpha,
4356           pointsCallback: (buffer, points) => {
4357             buffer.push(
4358               `${points[0].x} ${points[0].y} m`,
4359               `${points[1].x} ${points[1].y} l`,
4360               `${points[3].x} ${points[3].y} l`,
4361               `${points[2].x} ${points[2].y} l`,
4362               "f"
4363             );
4364             return [points[0].x, points[1].x, points[3].y, points[1].y];
4365           },
4366         });
4367       }
4368     } else {
4369       this.data.popupRef = null;
4370     }
4371   }
4372 }
4373 
4374 class UnderlineAnnotation extends MarkupAnnotation {
4375   constructor(params) {
4376     super(params);
4377 
4378     const { dict, xref } = params;
4379     this.data.annotationType = AnnotationType.UNDERLINE;
4380 
4381     const quadPoints = (this.data.quadPoints = getQuadPoints(dict, null));
4382     if (quadPoints) {
4383       if (!this.appearance) {
4384         // Default color is black
4385         const strokeColor = this.color
4386           ? getPdfColorArray(this.color)
4387           : [0, 0, 0];
4388         const strokeAlpha = dict.get("CA");
4389 
4390         // The values 0.571 and 1.3 below corresponds to what Acrobat is doing.
4391         this._setDefaultAppearance({
4392           xref,
4393           extra: "[] 0 d 0.571 w",
4394           strokeColor,
4395           strokeAlpha,
4396           pointsCallback: (buffer, points) => {
4397             buffer.push(
4398               `${points[2].x} ${points[2].y + 1.3} m`,
4399               `${points[3].x} ${points[3].y + 1.3} l`,
4400               "S"
4401             );
4402             return [points[0].x, points[1].x, points[3].y, points[1].y];
4403           },
4404         });
4405       }
4406     } else {
4407       this.data.popupRef = null;
4408     }
4409   }
4410 }
4411 
4412 class SquigglyAnnotation extends MarkupAnnotation {
4413   constructor(params) {
4414     super(params);
4415 
4416     const { dict, xref } = params;
4417     this.data.annotationType = AnnotationType.SQUIGGLY;
4418 
4419     const quadPoints = (this.data.quadPoints = getQuadPoints(dict, null));
4420     if (quadPoints) {
4421       if (!this.appearance) {
4422         // Default color is black
4423         const strokeColor = this.color
4424           ? getPdfColorArray(this.color)
4425           : [0, 0, 0];
4426         const strokeAlpha = dict.get("CA");
4427 
4428         this._setDefaultAppearance({
4429           xref,
4430           extra: "[] 0 d 1 w",
4431           strokeColor,
4432           strokeAlpha,
4433           pointsCallback: (buffer, points) => {
4434             const dy = (points[0].y - points[2].y) / 6;
4435             let shift = dy;
4436             let x = points[2].x;
4437             const y = points[2].y;
4438             const xEnd = points[3].x;
4439             buffer.push(`${x} ${y + shift} m`);
4440             do {
4441               x += 2;
4442               shift = shift === 0 ? dy : 0;
4443               buffer.push(`${x} ${y + shift} l`);
4444             } while (x < xEnd);
4445             buffer.push("S");
4446             return [points[2].x, xEnd, y - 2 * dy, y + 2 * dy];
4447           },
4448         });
4449       }
4450     } else {
4451       this.data.popupRef = null;
4452     }
4453   }
4454 }
4455 
4456 class StrikeOutAnnotation extends MarkupAnnotation {
4457   constructor(params) {
4458     super(params);
4459 
4460     const { dict, xref } = params;
4461     this.data.annotationType = AnnotationType.STRIKEOUT;
4462 
4463     const quadPoints = (this.data.quadPoints = getQuadPoints(dict, null));
4464     if (quadPoints) {
4465       if (!this.appearance) {
4466         // Default color is black
4467         const strokeColor = this.color
4468           ? getPdfColorArray(this.color)
4469           : [0, 0, 0];
4470         const strokeAlpha = dict.get("CA");
4471 
4472         this._setDefaultAppearance({
4473           xref,
4474           extra: "[] 0 d 1 w",
4475           strokeColor,
4476           strokeAlpha,
4477           pointsCallback: (buffer, points) => {
4478             buffer.push(
4479               `${(points[0].x + points[2].x) / 2} ` +
4480                 `${(points[0].y + points[2].y) / 2} m`,
4481               `${(points[1].x + points[3].x) / 2} ` +
4482                 `${(points[1].y + points[3].y) / 2} l`,
4483               "S"
4484             );
4485             return [points[0].x, points[1].x, points[3].y, points[1].y];
4486           },
4487         });
4488       }
4489     } else {
4490       this.data.popupRef = null;
4491     }
4492   }
4493 }
4494 
4495 class StampAnnotation extends MarkupAnnotation {
4496   constructor(params) {
4497     super(params);
4498 
4499     this.data.annotationType = AnnotationType.STAMP;
4500     this.data.hasOwnCanvas = this.data.noRotate;
4501   }
4502 
4503   static async createImage(bitmap, xref) {
4504     // TODO: when printing, we could have a specific internal colorspace
4505     // (e.g. something like DeviceRGBA) in order avoid any conversion (i.e. no
4506     // jpeg, no rgba to rgb conversion, etc...)
4507 
4508     const { width, height } = bitmap;
4509     const canvas = new OffscreenCanvas(width, height);
4510     const ctx = canvas.getContext("2d", { alpha: true });
4511 
4512     // Draw the image and get the data in order to extract the transparency.
4513     ctx.drawImage(bitmap, 0, 0);
4514     const data = ctx.getImageData(0, 0, width, height).data;
4515     const buf32 = new Uint32Array(data.buffer);
4516     const hasAlpha = buf32.some(
4517       FeatureTest.isLittleEndian
4518         ? x => x >>> 24 !== 0xff
4519         : x => (x & 0xff) !== 0xff
4520     );
4521 
4522     if (hasAlpha) {
4523       // Redraw the image on a white background in order to remove the thin gray
4524       // line which can appear when exporting to jpeg.
4525       ctx.fillStyle = "white";
4526       ctx.fillRect(0, 0, width, height);
4527       ctx.drawImage(bitmap, 0, 0);
4528     }
4529 
4530     const jpegBufferPromise = canvas
4531       .convertToBlob({ type: "image/jpeg", quality: 1 })
4532       .then(blob => {
4533         return blob.arrayBuffer();
4534       });
4535 
4536     const xobjectName = Name.get("XObject");
4537     const imageName = Name.get("Image");
4538     const image = new Dict(xref);
4539     image.set("Type", xobjectName);
4540     image.set("Subtype", imageName);
4541     image.set("BitsPerComponent", 8);
4542     image.set("ColorSpace", Name.get("DeviceRGB"));
4543     image.set("Filter", Name.get("DCTDecode"));
4544     image.set("BBox", [0, 0, width, height]);
4545     image.set("Width", width);
4546     image.set("Height", height);
4547 
4548     let smaskStream = null;
4549     if (hasAlpha) {
4550       const alphaBuffer = new Uint8Array(buf32.length);
4551       if (FeatureTest.isLittleEndian) {
4552         for (let i = 0, ii = buf32.length; i < ii; i++) {
4553           alphaBuffer[i] = buf32[i] >>> 24;
4554         }
4555       } else {
4556         for (let i = 0, ii = buf32.length; i < ii; i++) {
4557           alphaBuffer[i] = buf32[i] & 0xff;
4558         }
4559       }
4560 
4561       const smask = new Dict(xref);
4562       smask.set("Type", xobjectName);
4563       smask.set("Subtype", imageName);
4564       smask.set("BitsPerComponent", 8);
4565       smask.set("ColorSpace", Name.get("DeviceGray"));
4566       smask.set("Width", width);
4567       smask.set("Height", height);
4568 
4569       smaskStream = new Stream(alphaBuffer, 0, 0, smask);
4570     }
4571     const imageStream = new Stream(await jpegBufferPromise, 0, 0, image);
4572 
4573     return {
4574       imageStream,
4575       smaskStream,
4576       width,
4577       height,
4578     };
4579   }
4580 
4581   static createNewDict(annotation, xref, { apRef, ap }) {
4582     const { rect, rotation, user } = annotation;
4583     const stamp = new Dict(xref);
4584     stamp.set("Type", Name.get("Annot"));
4585     stamp.set("Subtype", Name.get("Stamp"));
4586     stamp.set("CreationDate", `D:${getModificationDate()}`);
4587     stamp.set("Rect", rect);
4588     stamp.set("F", 4);
4589     stamp.set("Border", [0, 0, 0]);
4590     stamp.set("Rotate", rotation);
4591 
4592     if (user) {
4593       stamp.set(
4594         "T",
4595         isAscii(user) ? user : stringToUTF16String(user, /* bigEndian = */ true)
4596       );
4597     }
4598 
4599     if (apRef || ap) {
4600       const n = new Dict(xref);
4601       stamp.set("AP", n);
4602 
4603       if (apRef) {
4604         n.set("N", apRef);
4605       } else {
4606         n.set("N", ap);
4607       }
4608     }
4609 
4610     return stamp;
4611   }
4612 
4613   static async createNewAppearanceStream(annotation, xref, params) {
4614     const { rotation } = annotation;
4615     const { imageRef, width, height } = params.image;
4616     const resources = new Dict(xref);
4617     const xobject = new Dict(xref);
4618     resources.set("XObject", xobject);
4619     xobject.set("Im0", imageRef);
4620     const appearance = `q ${width} 0 0 ${height} 0 0 cm /Im0 Do Q`;
4621 
4622     const appearanceStreamDict = new Dict(xref);
4623     appearanceStreamDict.set("FormType", 1);
4624     appearanceStreamDict.set("Subtype", Name.get("Form"));
4625     appearanceStreamDict.set("Type", Name.get("XObject"));
4626     appearanceStreamDict.set("BBox", [0, 0, width, height]);
4627     appearanceStreamDict.set("Resources", resources);
4628 
4629     if (rotation) {
4630       const matrix = getRotationMatrix(rotation, width, height);
4631       appearanceStreamDict.set("Matrix", matrix);
4632     }
4633 
4634     const ap = new StringStream(appearance);
4635     ap.dict = appearanceStreamDict;
4636 
4637     return ap;
4638   }
4639 }
4640 
4641 class FileAttachmentAnnotation extends MarkupAnnotation {
4642   constructor(params) {
4643     super(params);
4644 
4645     const { dict, xref } = params;
4646     const file = new FileSpec(dict.get("FS"), xref);
4647 
4648     this.data.annotationType = AnnotationType.FILEATTACHMENT;
4649     this.data.hasOwnCanvas = this.data.noRotate;
4650     this.data.file = file.serializable;
4651 
4652     const name = dict.get("Name");
4653     this.data.name =
4654       name instanceof Name ? stringToPDFString(name.name) : "PushPin";
4655   }
4656 }
4657 
4658 export {
4659   Annotation,
4660   AnnotationBorderStyle,
4661   AnnotationFactory,
4662   getQuadPoints,
4663   MarkupAnnotation,
4664   PopupAnnotation,
4665 };
File:
src/display/annotation_layer.js
1 /* Copyright 2014 Mozilla Foundation
2  *
3  * Licensed under the Apache License, Version 2.0 (the "License");
4  * you may not use this file except in compliance with the License.
5  * You may obtain a copy of the License at
6  *
7  *     http://www.apache.org/licenses/LICENSE-2.0
8  *
9  * Unless required by applicable law or agreed to in writing, software
10  * distributed under the License is distributed on an "AS IS" BASIS,
11  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
12  * See the License for the specific language governing permissions and
13  * limitations under the License.
14  */
15 
16 /** @typedef {import("./api").PDFPageProxy} PDFPageProxy */
17 /** @typedef {import("./display_utils").PageViewport} PageViewport */
18 /** @typedef {import("./interfaces").IDownloadManager} IDownloadManager */
19 /** @typedef {import("../../web/interfaces").IPDFLinkService} IPDFLinkService */
20 
21 import {
22   AnnotationBorderStyleType,
23   AnnotationEditorType,
24   AnnotationType,
25   FeatureTest,
26   LINE_FACTOR,
27   shadow,
28   unreachable,
29   Util,
30   warn,
31 } from "../shared/util.js";
32 import {
33   AnnotationPrefix,
34   DOMSVGFactory,
35   getFilenameFromUrl,
36   PDFDateString,
37   setLayerDimensions,
38 } from "./display_utils.js";
39 import { AnnotationStorage } from "./annotation_storage.js";
40 import { ColorConverters } from "../shared/scripting_utils.js";
41 import { NullL10n } from "display-l10n_utils";
42 import { XfaLayer } from "./xfa_layer.js";
43 
44 const DEFAULT_TAB_INDEX = 1000;
45 const DEFAULT_FONT_SIZE = 9;
46 const GetElementsByNameSet = new WeakSet();
47 
48 function getRectDims(rect) {
49   return {
50     width: rect[2] - rect[0],
51     height: rect[3] - rect[1],
52   };
53 }
54 
55 /**
56  * @typedef {Object} AnnotationElementParameters
57  * @property {Object} data
58  * @property {HTMLDivElement} layer
59  * @property {IPDFLinkService} linkService
60  * @property {IDownloadManager} downloadManager
61  * @property {AnnotationStorage} [annotationStorage]
62  * @property {string} [imageResourcesPath] - Path for image resources, mainly
63  *   for annotation icons. Include trailing slash.
64  * @property {boolean} renderForms
65  * @property {Object} svgFactory
66  * @property {boolean} [enableScripting]
67  * @property {boolean} [hasJSActions]
68  * @property {Object} [fieldObjects]
69  */
70 
71 class AnnotationElementFactory {
72   /**
73    * @param {AnnotationElementParameters} parameters
74    * @returns {AnnotationElement}
75    */
76   static create(parameters) {
77     const subtype = parameters.data.annotationType;
78 
79     switch (subtype) {
80       case AnnotationType.LINK:
81         return new LinkAnnotationElement(parameters);
82 
83       case AnnotationType.TEXT:
84         return new TextAnnotationElement(parameters);
85 
86       case AnnotationType.WIDGET:
87         const fieldType = parameters.data.fieldType;
88 
89         switch (fieldType) {
90           case "Tx":
91             return new TextWidgetAnnotationElement(parameters);
92           case "Btn":
93             if (parameters.data.radioButton) {
94               return new RadioButtonWidgetAnnotationElement(parameters);
95             } else if (parameters.data.checkBox) {
96               return new CheckboxWidgetAnnotationElement(parameters);
97             }
98             return new PushButtonWidgetAnnotationElement(parameters);
99           case "Ch":
100             return new ChoiceWidgetAnnotationElement(parameters);
101           case "Sig":
102             return new SignatureWidgetAnnotationElement(parameters);
103         }
104         return new WidgetAnnotationElement(parameters);
105 
106       case AnnotationType.POPUP:
107         return new PopupAnnotationElement(parameters);
108 
109       case AnnotationType.FREETEXT:
110         return new FreeTextAnnotationElement(parameters);
111 
112       case AnnotationType.LINE:
113         return new LineAnnotationElement(parameters);
114 
115       case AnnotationType.SQUARE:
116         return new SquareAnnotationElement(parameters);
117 
118       case AnnotationType.CIRCLE:
119         return new CircleAnnotationElement(parameters);
120 
121       case AnnotationType.POLYLINE:
122         return new PolylineAnnotationElement(parameters);
123 
124       case AnnotationType.CARET:
125         return new CaretAnnotationElement(parameters);
126 
127       case AnnotationType.INK:
128         return new InkAnnotationElement(parameters);
129 
130       case AnnotationType.POLYGON:
131         return new PolygonAnnotationElement(parameters);
132 
133       case AnnotationType.HIGHLIGHT:
134         return new HighlightAnnotationElement(parameters);
135 
136       case AnnotationType.UNDERLINE:
137         return new UnderlineAnnotationElement(parameters);
138 
139       case AnnotationType.SQUIGGLY:
140         return new SquigglyAnnotationElement(parameters);
141 
142       case AnnotationType.STRIKEOUT:
143         return new StrikeOutAnnotationElement(parameters);
144 
145       case AnnotationType.STAMP:
146         return new StampAnnotationElement(parameters);
147 
148       case AnnotationType.FILEATTACHMENT:
149         return new FileAttachmentAnnotationElement(parameters);
150 
151       default:
152         return new AnnotationElement(parameters);
153     }
154   }
155 }
156 
157 class AnnotationElement {
158   #hasBorder = false;
159 
160   constructor(
161     parameters,
162     {
163       isRenderable = false,
164       ignoreBorder = false,
165       createQuadrilaterals = false,
166     } = {}
167   ) {
168     this.isRenderable = isRenderable;
169     this.data = parameters.data;
170     this.layer = parameters.layer;
171     this.linkService = parameters.linkService;
172     this.downloadManager = parameters.downloadManager;
173     this.imageResourcesPath = parameters.imageResourcesPath;
174     this.renderForms = parameters.renderForms;
175     this.svgFactory = parameters.svgFactory;
176     this.annotationStorage = parameters.annotationStorage;
177     this.enableScripting = parameters.enableScripting;
178     this.hasJSActions = parameters.hasJSActions;
179     this._fieldObjects = parameters.fieldObjects;
180     this.parent = parameters.parent;
181 
182     if (isRenderable) {
183       this.container = this._createContainer(ignoreBorder);
184     }
185     if (createQuadrilaterals) {
186       this._createQuadrilaterals();
187     }
188   }
189 
190   /**
191    * Create an empty container for the annotation's HTML element.
192    *
193    * @private
194    * @param {boolean} ignoreBorder
195    * @memberof AnnotationElement
196    * @returns {HTMLElement} A section element.
197    */
198   _createContainer(ignoreBorder) {
199     const {
200       data,
201       parent: { page, viewport },
202     } = this;
203 
204     const container = document.createElement("section");
205     container.setAttribute("data-annotation-id", data.id);
206 
207     // The accessibility manager will move the annotation in the DOM in
208     // order to match the visual ordering.
209     // But if an annotation is above an other one, then we must draw it
210     // after the other one whatever the order is in the DOM, hence the
211     // use of the z-index.
212     container.style.zIndex = this.parent.zIndex++;
213 
214     if (this.data.popupRef) {
215       container.setAttribute("aria-haspopup", "dialog");
216     }
217 
218     if (data.noRotate) {
219       container.classList.add("norotate");
220     }
221 
222     const { pageWidth, pageHeight, pageX, pageY } = viewport.rawDims;
223 
224     if (!data.rect || this instanceof PopupAnnotationElement) {
225       const { rotation } = data;
226       if (!data.hasOwnCanvas && rotation !== 0) {
227         this.setRotation(rotation, container);
228       }
229       return container;
230     }
231 
232     const { width, height } = getRectDims(data.rect);
233 
234     // Do *not* modify `data.rect`, since that will corrupt the annotation
235     // position on subsequent calls to `_createContainer` (see issue 6804).
236     const rect = Util.normalizeRect([
237       data.rect[0],
238       page.view[3] - data.rect[1] + page.view[1],
239       data.rect[2],
240       page.view[3] - data.rect[3] + page.view[1],
241     ]);
242 
243     if (!ignoreBorder && data.borderStyle.width > 0) {
244       container.style.borderWidth = `${data.borderStyle.width}px`;
245 
246       const horizontalRadius = data.borderStyle.horizontalCornerRadius;
247       const verticalRadius = data.borderStyle.verticalCornerRadius;
248       if (horizontalRadius > 0 || verticalRadius > 0) {
249         const radius = `calc(${horizontalRadius}px * var(--scale-factor)) / calc(${verticalRadius}px * var(--scale-factor))`;
250         container.style.borderRadius = radius;
251       } else if (this instanceof RadioButtonWidgetAnnotationElement) {
252         const radius = `calc(${width}px * var(--scale-factor)) / calc(${height}px * var(--scale-factor))`;
253         container.style.borderRadius = radius;
254       }
255 
256       switch (data.borderStyle.style) {
257         case AnnotationBorderStyleType.SOLID:
258           container.style.borderStyle = "solid";
259           break;
260 
261         case AnnotationBorderStyleType.DASHED:
262           container.style.borderStyle = "dashed";
263           break;
264 
265         case AnnotationBorderStyleType.BEVELED:
266           warn("Unimplemented border style: beveled");
267           break;
268 
269         case AnnotationBorderStyleType.INSET:
270           warn("Unimplemented border style: inset");
271           break;
272 
273         case AnnotationBorderStyleType.UNDERLINE:
274           container.style.borderBottomStyle = "solid";
275           break;
276 
277         default:
278           break;
279       }
280 
281       const borderColor = data.borderColor || null;
282       if (borderColor) {
283         this.#hasBorder = true;
284         container.style.borderColor = Util.makeHexColor(
285           borderColor[0] | 0,
286           borderColor[1] | 0,
287           borderColor[2] | 0
288         );
289       } else {
290         // Transparent (invisible) border, so do not draw it at all.
291         container.style.borderWidth = 0;
292       }
293     }
294 
295     container.style.left = `${(100 * (rect[0] - pageX)) / pageWidth}%`;
296     container.style.top = `${(100 * (rect[1] - pageY)) / pageHeight}%`;
297 
298     const { rotation } = data;
299     if (data.hasOwnCanvas || rotation === 0) {
300       container.style.width = `${(100 * width) / pageWidth}%`;
301       container.style.height = `${(100 * height) / pageHeight}%`;
302     } else {
303       this.setRotation(rotation, container);
304     }
305 
306     return container;
307   }
308 
309   setRotation(angle, container = this.container) {
310     if (!this.data.rect) {
311       return;
312     }
313     const { pageWidth, pageHeight } = this.parent.viewport.rawDims;
314     const { width, height } = getRectDims(this.data.rect);
315 
316     let elementWidth, elementHeight;
317     if (angle % 180 === 0) {
318       elementWidth = (100 * width) / pageWidth;
319       elementHeight = (100 * height) / pageHeight;
320     } else {
321       elementWidth = (100 * height) / pageWidth;
322       elementHeight = (100 * width) / pageHeight;
323     }
324 
325     container.style.width = `${elementWidth}%`;
326     container.style.height = `${elementHeight}%`;
327 
328     container.setAttribute("data-main-rotation", (360 - angle) % 360);
329   }
330 
331   get _commonActions() {
332     const setColor = (jsName, styleName, event) => {
333       const color = event.detail[jsName];
334       const colorType = color[0];
335       const colorArray = color.slice(1);
336       event.target.style[styleName] =
337         ColorConverters[`${colorType}_HTML`](colorArray);
338       this.annotationStorage.setValue(this.data.id, {
339         [styleName]: ColorConverters[`${colorType}_rgb`](colorArray),
340       });
341     };
342 
343     return shadow(this, "_commonActions", {
344       display: event => {
345         const { display } = event.detail;
346         // See scripting/constants.js for the values of `Display`.
347         // 0 = visible, 1 = hidden, 2 = noPrint and 3 = noView.
348         const hidden = display % 2 === 1;
349         this.container.style.visibility = hidden ? "hidden" : "visible";
350         this.annotationStorage.setValue(this.data.id, {
351           noView: hidden,
352           noPrint: display === 1 || display === 2,
353         });
354       },
355       print: event => {
356         this.annotationStorage.setValue(this.data.id, {
357           noPrint: !event.detail.print,
358         });
359       },
360       hidden: event => {
361         const { hidden } = event.detail;
362         this.container.style.visibility = hidden ? "hidden" : "visible";
363         this.annotationStorage.setValue(this.data.id, {
364           noPrint: hidden,
365           noView: hidden,
366         });
367       },
368       focus: event => {
369         setTimeout(() => event.target.focus({ preventScroll: false }), 0);
370       },
371       userName: event => {
372         // tooltip
373         event.target.title = event.detail.userName;
374       },
375       readonly: event => {
376         if (event.detail.readonly) {
377           event.target.setAttribute("readonly", "");
378         } else {
379           event.target.removeAttribute("readonly");
380         }
381       },
382       required: event => {
383         this._setRequired(event.target, event.detail.required);
384       },
385       bgColor: event => {
386         setColor("bgColor", "backgroundColor", event);
387       },
388       fillColor: event => {
389         setColor("fillColor", "backgroundColor", event);
390       },
391       fgColor: event => {
392         setColor("fgColor", "color", event);
393       },
394       textColor: event => {
395         setColor("textColor", "color", event);
396       },
397       borderColor: event => {
398         setColor("borderColor", "borderColor", event);
399       },
400       strokeColor: event => {
401         setColor("strokeColor", "borderColor", event);
402       },
403       rotation: event => {
404         const angle = event.detail.rotation;
405         this.setRotation(angle);
406         this.annotationStorage.setValue(this.data.id, {
407           rotation: angle,
408         });
409       },
410     });
411   }
412 
413   _dispatchEventFromSandbox(actions, jsEvent) {
414     const commonActions = this._commonActions;
415     for (const name of Object.keys(jsEvent.detail)) {
416       const action = actions[name] || commonActions[name];
417       action?.(jsEvent);
418     }
419   }
420 
421   _setDefaultPropertiesFromJS(element) {
422     if (!this.enableScripting) {
423       return;
424     }
425 
426     // Some properties may have been updated thanks to JS.
427     const storedData = this.annotationStorage.getRawValue(this.data.id);
428     if (!storedData) {
429       return;
430     }
431 
432     const commonActions = this._commonActions;
433     for (const [actionName, detail] of Object.entries(storedData)) {
434       const action = commonActions[actionName];
435       if (action) {
436         const eventProxy = {
437           detail: {
438             [actionName]: detail,
439           },
440           target: element,
441         };
442         action(eventProxy);
443         // The action has been consumed: no need to keep it.
444         delete storedData[actionName];
445       }
446     }
447   }
448 
449   /**
450    * Create quadrilaterals from the annotation's quadpoints.
451    *
452    * @private
453    * @memberof AnnotationElement
454    */
455   _createQuadrilaterals() {
456     if (!this.container) {
457       return;
458     }
459     const { quadPoints } = this.data;
460     if (!quadPoints) {
461       return;
462     }
463 
464     const [rectBlX, rectBlY, rectTrX, rectTrY] = this.data.rect;
465 
466     if (quadPoints.length === 1) {
467       const [, { x: trX, y: trY }, { x: blX, y: blY }] = quadPoints[0];
468       if (
469         rectTrX === trX &&
470         rectTrY === trY &&
471         rectBlX === blX &&
472         rectBlY === blY
473       ) {
474         // The quadpoints cover the whole annotation rectangle, so no need to
475         // create a quadrilateral.
476         return;
477       }
478     }
479 
480     const { style } = this.container;
481     let svgBuffer;
482     if (this.#hasBorder) {
483       const { borderColor, borderWidth } = style;
484       style.borderWidth = 0;
485       svgBuffer = [
486         "url('data:image/svg+xml;utf8,",
487         `<svg xmlns="http://www.w3.org/2000/svg"`,
488         ` preserveAspectRatio="none" viewBox="0 0 1 1">`,
489         `<g fill="transparent" stroke="${borderColor}" stroke-width="${borderWidth}">`,
490       ];
491       this.container.classList.add("hasBorder");
492     }
493 
494     if (typeof PDFJSDev !== "undefined" && PDFJSDev.test("TESTING")) {
495       this.container.classList.add("hasClipPath");
496     }
497 
498     const width = rectTrX - rectBlX;
499     const height = rectTrY - rectBlY;
500 
501     const { svgFactory } = this;
502     const svg = svgFactory.createElement("svg");
503     svg.classList.add("quadrilateralsContainer");
504     svg.setAttribute("width", 0);
505     svg.setAttribute("height", 0);
506     const defs = svgFactory.createElement("defs");
507     svg.append(defs);
508     const clipPath = svgFactory.createElement("clipPath");
509     const id = `clippath_${this.data.id}`;
510     clipPath.setAttribute("id", id);
511     clipPath.setAttribute("clipPathUnits", "objectBoundingBox");
512     defs.append(clipPath);
513 
514     for (const [, { x: trX, y: trY }, { x: blX, y: blY }] of quadPoints) {
515       const rect = svgFactory.createElement("rect");
516       const x = (blX - rectBlX) / width;
517       const y = (rectTrY - trY) / height;
518       const rectWidth = (trX - blX) / width;
519       const rectHeight = (trY - blY) / height;
520       rect.setAttribute("x", x);
521       rect.setAttribute("y", y);
522       rect.setAttribute("width", rectWidth);
523       rect.setAttribute("height", rectHeight);
524       clipPath.append(rect);
525       svgBuffer?.push(
526         `<rect vector-effect="non-scaling-stroke" x="${x}" y="${y}" width="${rectWidth}" height="${rectHeight}"/>`
527       );
528     }
529 
530     if (this.#hasBorder) {
531       svgBuffer.push(`</g></svg>')`);
532       style.backgroundImage = svgBuffer.join("");
533     }
534 
535     this.container.append(svg);
536     this.container.style.clipPath = `url(#${id})`;
537   }
538 
539   /**
540    * Create a popup for the annotation's HTML element. This is used for
541    * annotations that do not have a Popup entry in the dictionary, but
542    * are of a type that works with popups (such as Highlight annotations).
543    *
544    * @private
545    * @memberof AnnotationElement
546    */
547   _createPopup() {
548     const { container, data } = this;
549     container.setAttribute("aria-haspopup", "dialog");
550 
551     const popup = new PopupAnnotationElement({
552       data: {
553         color: data.color,
554         titleObj: data.titleObj,
555         modificationDate: data.modificationDate,
556         contentsObj: data.contentsObj,
557         richText: data.richText,
558         parentRect: data.rect,
559         borderStyle: 0,
560         id: `popup_${data.id}`,
561         rotation: data.rotation,
562       },
563       parent: this.parent,
564       elements: [this],
565     });
566     this.parent.div.append(popup.render());
567   }
568 
569   /**
570    * Render the annotation's HTML element(s).
571    *
572    * @public
573    * @memberof AnnotationElement
574    */
575   render() {
576     unreachable("Abstract method `AnnotationElement.render` called");
577   }
578 
579   /**
580    * @private
581    * @returns {Array}
582    */
583   _getElementsByName(name, skipId = null) {
584     const fields = [];
585 
586     if (this._fieldObjects) {
587       const fieldObj = this._fieldObjects[name];
588       if (fieldObj) {
589         for (const { page, id, exportValues } of fieldObj) {
590           if (page === -1) {
591             continue;
592           }
593           if (id === skipId) {
594             continue;
595           }
596           const exportValue =
597             typeof exportValues === "string" ? exportValues : null;
598 
599           const domElement = document.querySelector(
600             `[data-element-id="${id}"]`
601           );
602           if (domElement && !GetElementsByNameSet.has(domElement)) {
603             warn(`_getElementsByName - element not allowed: ${id}`);
604             continue;
605           }
606           fields.push({ id, exportValue, domElement });
607         }
608       }
609       return fields;
610     }
611     // Fallback to a regular DOM lookup, to ensure that the standalone
612     // viewer components won't break.
613     for (const domElement of document.getElementsByName(name)) {
614       const { exportValue } = domElement;
615       const id = domElement.getAttribute("data-element-id");
616       if (id === skipId) {
617         continue;
618       }
619       if (!GetElementsByNameSet.has(domElement)) {
620         continue;
621       }
622       fields.push({ id, exportValue, domElement });
623     }
624     return fields;
625   }
626 
627   show() {
628     if (this.container) {
629       this.container.hidden = false;
630     }
631     this.popup?.maybeShow();
632   }
633 
634   hide() {
635     if (this.container) {
636       this.container.hidden = true;
637     }
638     this.popup?.forceHide();
639   }
640 
641   /**
642    * Get the HTML element(s) which can trigger a popup when clicked or hovered.
643    *
644    * @public
645    * @memberof AnnotationElement
646    * @returns {Array<HTMLElement>|HTMLElement} An array of elements or an
647    *          element.
648    */
649   getElementsToTriggerPopup() {
650     return this.container;
651   }
652 
653   addHighlightArea() {
654     const triggers = this.getElementsToTriggerPopup();
655     if (Array.isArray(triggers)) {
656       for (const element of triggers) {
657         element.classList.add("highlightArea");
658       }
659     } else {
660       triggers.classList.add("highlightArea");
661     }
662   }
663 
664   _editOnDoubleClick() {
665     const {
666       annotationEditorType: mode,
667       data: { id: editId },
668     } = this;
669     this.container.addEventListener("dblclick", () => {
670       this.linkService.eventBus?.dispatch("switchannotationeditormode", {
671         source: this,
672         mode,
673         editId,
674       });
675     });
676   }
677 }
678 
679 class LinkAnnotationElement extends AnnotationElement {
680   constructor(parameters, options = null) {
681     super(parameters, {
682       isRenderable: true,
683       ignoreBorder: !!options?.ignoreBorder,
684       createQuadrilaterals: true,
685     });
686     this.isTooltipOnly = parameters.data.isTooltipOnly;
687   }
688 
689   render() {
690     const { data, linkService } = this;
691     const link = document.createElement("a");
692     link.setAttribute("data-element-id", data.id);
693     let isBound = false;
694 
695     if (data.url) {
696       linkService.addLinkAttributes(link, data.url, data.newWindow);
697       isBound = true;
698     } else if (data.action) {
699       this._bindNamedAction(link, data.action);
700       isBound = true;
701     } else if (data.attachment) {
702       this._bindAttachment(link, data.attachment);
703       isBound = true;
704     } else if (data.setOCGState) {
705       this.#bindSetOCGState(link, data.setOCGState);
706       isBound = true;
707     } else if (data.dest) {
708       this._bindLink(link, data.dest);
709       isBound = true;
710     } else {
711       if (
712         data.actions &&
713         (data.actions.Action ||
714           data.actions["Mouse Up"] ||
715           data.actions["Mouse Down"]) &&
716         this.enableScripting &&
717         this.hasJSActions
718       ) {
719         this._bindJSAction(link, data);
720         isBound = true;
721       }
722 
723       if (data.resetForm) {
724         this._bindResetFormAction(link, data.resetForm);
725         isBound = true;
726       } else if (this.isTooltipOnly && !isBound) {
727         this._bindLink(link, "");
728         isBound = true;
729       }
730     }
731 
732     this.container.classList.add("linkAnnotation");
733     if (isBound) {
734       this.container.append(link);
735     }
736 
737     return this.container;
738   }
739 
740   #setInternalLink() {
741     this.container.setAttribute("data-internal-link", "");
742   }
743 
744   /**
745    * Bind internal links to the link element.
746    *
747    * @private
748    * @param {Object} link
749    * @param {Object} destination
750    * @memberof LinkAnnotationElement
751    */
752   _bindLink(link, destination) {
753     link.href = this.linkService.getDestinationHash(destination);
754     link.onclick = () => {
755       if (destination) {
756         this.linkService.goToDestination(destination);
757       }
758       return false;
759     };
760     if (destination || destination === /* isTooltipOnly = */ "") {
761       this.#setInternalLink();
762     }
763   }
764 
765   /**
766    * Bind named actions to the link element.
767    *
768    * @private
769    * @param {Object} link
770    * @param {Object} action
771    * @memberof LinkAnnotationElement
772    */
773   _bindNamedAction(link, action) {
774     link.href = this.linkService.getAnchorUrl("");
775     link.onclick = () => {
776       this.linkService.executeNamedAction(action);
777       return false;
778     };
779     this.#setInternalLink();
780   }
781 
782   /**
783    * Bind attachments to the link element.
784    * @param {Object} link
785    * @param {Object} attachment
786    */
787   _bindAttachment(link, attachment) {
788     link.href = this.linkService.getAnchorUrl("");
789     link.onclick = () => {
790       this.downloadManager?.openOrDownloadData(
791         this.container,
792         attachment.content,
793         attachment.filename
794       );
795       return false;
796     };
797     this.#setInternalLink();
798   }
799 
800   /**
801    * Bind SetOCGState actions to the link element.
802    * @param {Object} link
803    * @param {Object} action
804    */
805   #bindSetOCGState(link, action) {
806     link.href = this.linkService.getAnchorUrl("");
807     link.onclick = () => {
808       this.linkService.executeSetOCGState(action);
809       return false;
810     };
811     this.#setInternalLink();
812   }
813 
814   /**
815    * Bind JS actions to the link element.
816    *
817    * @private
818    * @param {Object} link
819    * @param {Object} data
820    * @memberof LinkAnnotationElement
821    */
822   _bindJSAction(link, data) {
823     link.href = this.linkService.getAnchorUrl("");
824     const map = new Map([
825       ["Action", "onclick"],
826       ["Mouse Up", "onmouseup"],
827       ["Mouse Down", "onmousedown"],
828     ]);
829     for (const name of Object.keys(data.actions)) {
830       const jsName = map.get(name);
831       if (!jsName) {
832         continue;
833       }
834       link[jsName] = () => {
835         this.linkService.eventBus?.dispatch("dispatcheventinsandbox", {
836           source: this,
837           detail: {
838             id: data.id,
839             name,
840           },
841         });
842         return false;
843       };
844     }
845 
846     if (!link.onclick) {
847       link.onclick = () => false;
848     }
849     this.#setInternalLink();
850   }
851 
852   _bindResetFormAction(link, resetForm) {
853     const otherClickAction = link.onclick;
854     if (!otherClickAction) {
855       link.href = this.linkService.getAnchorUrl("");
856     }
857     this.#setInternalLink();
858 
859     if (!this._fieldObjects) {
860       warn(
861         `_bindResetFormAction - "resetForm" action not supported, ` +
862           "ensure that the `fieldObjects` parameter is provided."
863       );
864       if (!otherClickAction) {
865         link.onclick = () => false;
866       }
867       return;
868     }
869 
870     link.onclick = () => {
871       otherClickAction?.();
872 
873       const {
874         fields: resetFormFields,
875         refs: resetFormRefs,
876         include,
877       } = resetForm;
878 
879       const allFields = [];
880       if (resetFormFields.length !== 0 || resetFormRefs.length !== 0) {
881         const fieldIds = new Set(resetFormRefs);
882         for (const fieldName of resetFormFields) {
883           const fields = this._fieldObjects[fieldName] || [];
884           for (const { id } of fields) {
885             fieldIds.add(id);
886           }
887         }
888         for (const fields of Object.values(this._fieldObjects)) {
889           for (const field of fields) {
890             if (fieldIds.has(field.id) === include) {
891               allFields.push(field);
892             }
893           }
894         }
895       } else {
896         for (const fields of Object.values(this._fieldObjects)) {
897           allFields.push(...fields);
898         }
899       }
900 
901       const storage = this.annotationStorage;
902       const allIds = [];
903       for (const field of allFields) {
904         const { id } = field;
905         allIds.push(id);
906         switch (field.type) {
907           case "text": {
908             const value = field.defaultValue || "";
909             storage.setValue(id, { value });
910             break;
911           }
912           case "checkbox":
913           case "radiobutton": {
914             const value = field.defaultValue === field.exportValues;
915             storage.setValue(id, { value });
916             break;
917           }
918           case "combobox":
919           case "listbox": {
920             const value = field.defaultValue || "";
921             storage.setValue(id, { value });
922             break;
923           }
924           default:
925             continue;
926         }
927 
928         const domElement = document.querySelector(`[data-element-id="${id}"]`);
929         if (!domElement) {
930           continue;
931         } else if (!GetElementsByNameSet.has(domElement)) {
932           warn(`_bindResetFormAction - element not allowed: ${id}`);
933           continue;
934         }
935         domElement.dispatchEvent(new Event("resetform"));
936       }
937 
938       if (this.enableScripting) {
939         // Update the values in the sandbox.
940         this.linkService.eventBus?.dispatch("dispatcheventinsandbox", {
941           source: this,
942           detail: {
943             id: "app",
944             ids: allIds,
945             name: "ResetForm",
946           },
947         });
948       }
949 
950       return false;
951     };
952   }
953 }
954 
955 class TextAnnotationElement extends AnnotationElement {
956   constructor(parameters) {
957     const isRenderable = !!(
958       parameters.data.popupRef ||
959       parameters.data.titleObj?.str ||
960       parameters.data.contentsObj?.str ||
961       parameters.data.richText?.str
962     );
963     super(parameters, { isRenderable });
964   }
965 
966   render() {
967     this.container.classList.add("textAnnotation");
968 
969     const image = document.createElement("img");
970     image.src =
971       this.imageResourcesPath +
972       "annotation-" +
973       this.data.name.toLowerCase() +
974       ".svg";
975     image.alt = "[{{type}} Annotation]";
976     image.dataset.l10nId = "text_annotation_type";
977     image.dataset.l10nArgs = JSON.stringify({ type: this.data.name });
978 
979     if (!this.data.popupRef) {
980       this._createPopup();
981     }
982 
983     this.container.append(image);
984     return this.container;
985   }
986 }
987 
988 class WidgetAnnotationElement extends AnnotationElement {
989   render() {
990     // Show only the container for unsupported field types.
991     if (this.data.alternativeText) {
992       this.container.title = this.data.alternativeText;
993     }
994 
995     return this.container;
996   }
997 
998   showElementAndHideCanvas(element) {
999     if (this.data.hasOwnCanvas) {
1000       if (element.previousSibling?.nodeName === "CANVAS") {
1001         element.previousSibling.hidden = true;
1002       }
1003       element.hidden = false;
1004     }
1005   }
1006 
1007   _getKeyModifier(event) {
1008     const { isWin, isMac } = FeatureTest.platform;
1009     return (isWin && event.ctrlKey) || (isMac && event.metaKey);
1010   }
1011 
1012   _setEventListener(element, baseName, eventName, valueGetter) {
1013     if (baseName.includes("mouse")) {
1014       // Mouse events
1015       element.addEventListener(baseName, event => {
1016         this.linkService.eventBus?.dispatch("dispatcheventinsandbox", {
1017           source: this,
1018           detail: {
1019             id: this.data.id,
1020             name: eventName,
1021             value: valueGetter(event),
1022             shift: event.shiftKey,
1023             modifier: this._getKeyModifier(event),
1024           },
1025         });
1026       });
1027     } else {
1028       // Non mouse event
1029       element.addEventListener(baseName, event => {
1030         this.linkService.eventBus?.dispatch("dispatcheventinsandbox", {
1031           source: this,
1032           detail: {
1033             id: this.data.id,
1034             name: eventName,
1035             value: valueGetter(event),
1036           },
1037         });
1038       });
1039     }
1040   }
1041 
1042   _setEventListeners(element, names, getter) {
1043     for (const [baseName, eventName] of names) {
1044       if (eventName === "Action" || this.data.actions?.[eventName]) {
1045         this._setEventListener(element, baseName, eventName, getter);
1046       }
1047     }
1048   }
1049 
1050   _setBackgroundColor(element) {
1051     const color = this.data.backgroundColor || null;
1052     element.style.backgroundColor =
1053       color === null
1054         ? "transparent"
1055         : Util.makeHexColor(color[0], color[1], color[2]);
1056   }
1057 
1058   /**
1059    * Apply text styles to the text in the element.
1060    *
1061    * @private
1062    * @param {HTMLDivElement} element
1063    * @memberof TextWidgetAnnotationElement
1064    */
1065   _setTextStyle(element) {
1066     const TEXT_ALIGNMENT = ["left", "center", "right"];
1067     const { fontColor } = this.data.defaultAppearanceData;
1068     const fontSize =
1069       this.data.defaultAppearanceData.fontSize || DEFAULT_FONT_SIZE;
1070 
1071     const style = element.style;
1072 
1073     // TODO: If the font-size is zero, calculate it based on the height and
1074     //       width of the element.
1075     // Not setting `style.fontSize` will use the default font-size for now.
1076 
1077     // We don't use the font, as specified in the PDF document, for the <input>
1078     // element. Hence using the original `fontSize` could look bad, which is why
1079     // it's instead based on the field height.
1080     // If the height is "big" then it could lead to a too big font size
1081     // so in this case use the one we've in the pdf (hence the min).
1082     let computedFontSize;
1083     const BORDER_SIZE = 2;
1084     const roundToOneDecimal = x => Math.round(10 * x) / 10;
1085     if (this.data.multiLine) {
1086       const height = Math.abs(
1087         this.data.rect[3] - this.data.rect[1] - BORDER_SIZE
1088       );
1089       const numberOfLines = Math.round(height / (LINE_FACTOR * fontSize)) || 1;
1090       const lineHeight = height / numberOfLines;
1091       computedFontSize = Math.min(
1092         fontSize,
1093         roundToOneDecimal(lineHeight / LINE_FACTOR)
1094       );
1095     } else {
1096       const height = Math.abs(
1097         this.data.rect[3] - this.data.rect[1] - BORDER_SIZE
1098       );
1099       computedFontSize = Math.min(
1100         fontSize,
1101         roundToOneDecimal(height / LINE_FACTOR)
1102       );
1103     }
1104     style.fontSize = `calc(${computedFontSize}px * var(--scale-factor))`;
1105 
1106     style.color = Util.makeHexColor(fontColor[0], fontColor[1], fontColor[2]);
1107 
1108     if (this.data.textAlignment !== null) {
1109       style.textAlign = TEXT_ALIGNMENT[this.data.textAlignment];
1110     }
1111   }
1112 
1113   _setRequired(element, isRequired) {
1114     if (isRequired) {
1115       element.setAttribute("required", true);
1116     } else {
1117       element.removeAttribute("required");
1118     }
1119     element.setAttribute("aria-required", isRequired);
1120   }
1121 }
1122 
1123 class TextWidgetAnnotationElement extends WidgetAnnotationElement {
1124   constructor(parameters) {
1125     const isRenderable =
1126       parameters.renderForms ||
1127       (!parameters.data.hasAppearance && !!parameters.data.fieldValue);
1128     super(parameters, { isRenderable });
1129   }
1130 
1131   setPropertyOnSiblings(base, key, value, keyInStorage) {
1132     const storage = this.annotationStorage;
1133     for (const element of this._getElementsByName(
1134       base.name,
1135       /* skipId = */ base.id
1136     )) {
1137       if (element.domElement) {
1138         element.domElement[key] = value;
1139       }
1140       storage.setValue(element.id, { [keyInStorage]: value });
1141     }
1142   }
1143 
1144   render() {
1145     const storage = this.annotationStorage;
1146     const id = this.data.id;
1147 
1148     this.container.classList.add("textWidgetAnnotation");
1149 
1150     let element = null;
1151     if (this.renderForms) {
1152       // NOTE: We cannot set the values using `element.value` below, since it
1153       //       prevents the AnnotationLayer rasterizer in `test/driver.js`
1154       //       from parsing the elements correctly for the reference tests.
1155       const storedData = storage.getValue(id, {
1156         value: this.data.fieldValue,
1157       });
1158       let textContent = storedData.value || "";
1159       const maxLen = storage.getValue(id, {
1160         charLimit: this.data.maxLen,
1161       }).charLimit;
1162       if (maxLen && textContent.length > maxLen) {
1163         textContent = textContent.slice(0, maxLen);
1164       }
1165 
1166       let fieldFormattedValues =
1167         storedData.formattedValue || this.data.textContent?.join("\n") || null;
1168       if (fieldFormattedValues && this.data.comb) {
1169         fieldFormattedValues = fieldFormattedValues.replaceAll(/\s+/g, "");
1170       }
1171 
1172       const elementData = {
1173         userValue: textContent,
1174         formattedValue: fieldFormattedValues,
1175         lastCommittedValue: null,
1176         commitKey: 1,
1177       };
1178 
1179       if (this.data.multiLine) {
1180         element = document.createElement("textarea");
1181         element.textContent = fieldFormattedValues ?? textContent;
1182         if (this.data.doNotScroll) {
1183           element.style.overflowY = "hidden";
1184         }
1185       } else {
1186         element = document.createElement("input");
1187         element.type = "text";
1188         element.setAttribute("value", fieldFormattedValues ?? textContent);
1189         if (this.data.doNotScroll) {
1190           element.style.overflowX = "hidden";
1191         }
1192       }
1193       if (this.data.hasOwnCanvas) {
1194         element.hidden = true;
1195       }
1196       GetElementsByNameSet.add(element);
1197       element.setAttribute("data-element-id", id);
1198 
1199       element.disabled = this.data.readOnly;
1200       element.name = this.data.baseFieldName || this.data.fieldName;
1201       element.tabIndex = DEFAULT_TAB_INDEX;
1202 
1203       this._setRequired(element, this.data.required);
1204 
1205       if (maxLen) {
1206         element.maxLength = maxLen;
1207       }
1208 
1209       element.addEventListener("input", event => {
1210         storage.setValue(id, { value: event.target.value });
1211         this.setPropertyOnSiblings(
1212           element,
1213           "value",
1214           event.target.value,
1215           "value"
1216         );
1217         elementData.formattedValue = null;
1218       });
1219 
1220       element.addEventListener("resetform", event => {
1221         const defaultValue = this.data.defaultFieldValue ?? "";
1222         element.value = elementData.userValue = defaultValue;
1223         elementData.formattedValue = null;
1224       });
1225 
1226       let blurListener = event => {
1227         const { formattedValue } = elementData;
1228         if (formattedValue !== null && formattedValue !== undefined) {
1229           event.target.value = formattedValue;
1230         }
1231         // Reset the cursor position to the start of the field (issue 12359).
1232         event.target.scrollLeft = 0;
1233       };
1234 
1235       if (this.enableScripting && this.hasJSActions) {
1236         element.addEventListener("focus", event => {
1237           const { target } = event;
1238           if (elementData.userValue) {
1239             target.value = elementData.userValue;
1240           }
1241           elementData.lastCommittedValue = target.value;
1242           elementData.commitKey = 1;
1243         });
1244 
1245         element.addEventListener("updatefromsandbox", jsEvent => {
1246           this.showElementAndHideCanvas(jsEvent.target);
1247           const actions = {
1248             value(event) {
1249               elementData.userValue = event.detail.value ?? "";
1250               storage.setValue(id, { value: elementData.userValue.toString() });
1251               event.target.value = elementData.userValue;
1252             },
1253             formattedValue(event) {
1254               const { formattedValue } = event.detail;
1255               elementData.formattedValue = formattedValue;
1256               if (
1257                 formattedValue !== null &&
1258                 formattedValue !== undefined &&
1259                 event.target !== document.activeElement
1260               ) {
1261                 // Input hasn't the focus so display formatted string
1262                 event.target.value = formattedValue;
1263               }
1264               storage.setValue(id, {
1265                 formattedValue,
1266               });
1267             },
1268             selRange(event) {
1269               event.target.setSelectionRange(...event.detail.selRange);
1270             },
1271             charLimit: event => {
1272               const { charLimit } = event.detail;
1273               const { target } = event;
1274               if (charLimit === 0) {
1275                 target.removeAttribute("maxLength");
1276                 return;
1277               }
1278 
1279               target.setAttribute("maxLength", charLimit);
1280               let value = elementData.userValue;
1281               if (!value || value.length <= charLimit) {
1282                 return;
1283               }
1284               value = value.slice(0, charLimit);
1285               target.value = elementData.userValue = value;
1286               storage.setValue(id, { value });
1287 
1288               this.linkService.eventBus?.dispatch("dispatcheventinsandbox", {
1289                 source: this,
1290                 detail: {
1291                   id,
1292                   name: "Keystroke",
1293                   value,
1294                   willCommit: true,
1295                   commitKey: 1,
1296                   selStart: target.selectionStart,
1297                   selEnd: target.selectionEnd,
1298                 },
1299               });
1300             },
1301           };
1302           this._dispatchEventFromSandbox(actions, jsEvent);
1303         });
1304 
1305         // Even if the field hasn't any actions
1306         // leaving it can still trigger some actions with Calculate
1307         element.addEventListener("keydown", event => {
1308           elementData.commitKey = 1;
1309           // If the key is one of Escape, Enter then the data are committed.
1310           // If we've a Tab then data will be committed on blur.
1311           let commitKey = -1;
1312           if (event.key === "Escape") {
1313             commitKey = 0;
1314           } else if (event.key === "Enter" && !this.data.multiLine) {
1315             // When we've a multiline field, "Enter" key is a key as the other
1316             // hence we don't commit the data (Acrobat behaves the same way)
1317             // (see issue #15627).
1318             commitKey = 2;
1319           } else if (event.key === "Tab") {
1320             elementData.commitKey = 3;
1321           }
1322           if (commitKey === -1) {
1323             return;
1324           }
1325           const { value } = event.target;
1326           if (elementData.lastCommittedValue === value) {
1327             return;
1328           }
1329           elementData.lastCommittedValue = value;
1330           // Save the entered value
1331           elementData.userValue = value;
1332           this.linkService.eventBus?.dispatch("dispatcheventinsandbox", {
1333             source: this,
1334             detail: {
1335               id,
1336               name: "Keystroke",
1337               value,
1338               willCommit: true,
1339               commitKey,
1340               selStart: event.target.selectionStart,
1341               selEnd: event.target.selectionEnd,
1342             },
1343           });
1344         });
1345         const _blurListener = blurListener;
1346         blurListener = null;
1347         element.addEventListener("blur", event => {
1348           if (!event.relatedTarget) {
1349             return;
1350           }
1351           const { value } = event.target;
1352           elementData.userValue = value;
1353           if (elementData.lastCommittedValue !== value) {
1354             this.linkService.eventBus?.dispatch("dispatcheventinsandbox", {
1355               source: this,
1356               detail: {
1357                 id,
1358                 name: "Keystroke",
1359                 value,
1360                 willCommit: true,
1361                 commitKey: elementData.commitKey,
1362                 selStart: event.target.selectionStart,
1363                 selEnd: event.target.selectionEnd,
1364               },
1365             });
1366           }
1367           _blurListener(event);
1368         });
1369 
1370         if (this.data.actions?.Keystroke) {
1371           element.addEventListener("beforeinput", event => {
1372             elementData.lastCommittedValue = null;
1373             const { data, target } = event;
1374             const { value, selectionStart, selectionEnd } = target;
1375 
1376             let selStart = selectionStart,
1377               selEnd = selectionEnd;
1378 
1379             switch (event.inputType) {
1380               // https://rawgit.com/w3c/input-events/v1/index.html#interface-InputEvent-Attributes
1381               case "deleteWordBackward": {
1382                 const match = value
1383                   .substring(0, selectionStart)
1384                   .match(/\w*[^\w]*$/);
1385                 if (match) {
1386                   selStart -= match[0].length;
1387                 }
1388                 break;
1389               }
1390               case "deleteWordForward": {
1391                 const match = value
1392                   .substring(selectionStart)
1393                   .match(/^[^\w]*\w*/);
1394                 if (match) {
1395                   selEnd += match[0].length;
1396                 }
1397                 break;
1398               }
1399               case "deleteContentBackward":
1400                 if (selectionStart === selectionEnd) {
1401                   selStart -= 1;
1402                 }
1403                 break;
1404               case "deleteContentForward":
1405                 if (selectionStart === selectionEnd) {
1406                   selEnd += 1;
1407                 }
1408                 break;
1409             }
1410 
1411             // We handle the event ourselves.
1412             event.preventDefault();
1413             this.linkService.eventBus?.dispatch("dispatcheventinsandbox", {
1414               source: this,
1415               detail: {
1416                 id,
1417                 name: "Keystroke",
1418                 value,
1419                 change: data || "",
1420                 willCommit: false,
1421                 selStart,
1422                 selEnd,
1423               },
1424             });
1425           });
1426         }
1427 
1428         this._setEventListeners(
1429           element,
1430           [
1431             ["focus", "Focus"],
1432             ["blur", "Blur"],
1433             ["mousedown", "Mouse Down"],
1434             ["mouseenter", "Mouse Enter"],
1435             ["mouseleave", "Mouse Exit"],
1436             ["mouseup", "Mouse Up"],
1437           ],
1438           event => event.target.value
1439         );
1440       }
1441 
1442       if (blurListener) {
1443         element.addEventListener("blur", blurListener);
1444       }
1445 
1446       if (this.data.comb) {
1447         const fieldWidth = this.data.rect[2] - this.data.rect[0];
1448         const combWidth = fieldWidth / maxLen;
1449 
1450         element.classList.add("comb");
1451         element.style.letterSpacing = `calc(${combWidth}px * var(--scale-factor) - 1ch)`;
1452       }
1453     } else {
1454       element = document.createElement("div");
1455       element.textContent = this.data.fieldValue;
1456       element.style.verticalAlign = "middle";
1457       element.style.display = "table-cell";
1458     }
1459 
1460     this._setTextStyle(element);
1461     this._setBackgroundColor(element);
1462     this._setDefaultPropertiesFromJS(element);
1463 
1464     this.container.append(element);
1465     return this.container;
1466   }
1467 }
1468 
1469 class SignatureWidgetAnnotationElement extends WidgetAnnotationElement {
1470   constructor(parameters) {
1471     super(parameters, { isRenderable: !!parameters.data.hasOwnCanvas });
1472   }
1473 }
1474 
1475 class CheckboxWidgetAnnotationElement extends WidgetAnnotationElement {
1476   constructor(parameters) {
1477     super(parameters, { isRenderable: parameters.renderForms });
1478   }
1479 
1480   render() {
1481     const storage = this.annotationStorage;
1482     const data = this.data;
1483     const id = data.id;
1484     let value = storage.getValue(id, {
1485       value: data.exportValue === data.fieldValue,
1486     }).value;
1487     if (typeof value === "string") {
1488       // The value has been changed through js and set in annotationStorage.
1489       value = value !== "Off";
1490       storage.setValue(id, { value });
1491     }
1492 
1493     this.container.classList.add("buttonWidgetAnnotation", "checkBox");
1494 
1495     const element = document.createElement("input");
1496     GetElementsByNameSet.add(element);
1497     element.setAttribute("data-element-id", id);
1498 
1499     element.disabled = data.readOnly;
1500     this._setRequired(element, this.data.required);
1501     element.type = "checkbox";
1502     element.name = data.baseFieldName || data.fieldName;
1503     if (value) {
1504       element.setAttribute("checked", true);
1505     }
1506     element.setAttribute("exportValue", data.exportValue);
1507     element.tabIndex = DEFAULT_TAB_INDEX;
1508 
1509     element.addEventListener("change", event => {
1510       const { name, checked } = event.target;
1511       for (const checkbox of this._getElementsByName(name, /* skipId = */ id)) {
1512         const curChecked = checked && checkbox.exportValue === data.exportValue;
1513         if (checkbox.domElement) {
1514           checkbox.domElement.checked = curChecked;
1515         }
1516         storage.setValue(checkbox.id, { value: curChecked });
1517       }
1518       storage.setValue(id, { value: checked });
1519     });
1520 
1521     element.addEventListener("resetform", event => {
1522       const defaultValue = data.defaultFieldValue || "Off";
1523       event.target.checked = defaultValue === data.exportValue;
1524     });
1525 
1526     if (this.enableScripting && this.hasJSActions) {
1527       element.addEventListener("updatefromsandbox", jsEvent => {
1528         const actions = {
1529           value(event) {
1530             event.target.checked = event.detail.value !== "Off";
1531             storage.setValue(id, { value: event.target.checked });
1532           },
1533         };
1534         this._dispatchEventFromSandbox(actions, jsEvent);
1535       });
1536 
1537       this._setEventListeners(
1538         element,
1539         [
1540           ["change", "Validate"],
1541           ["change", "Action"],
1542           ["focus", "Focus"],
1543           ["blur", "Blur"],
1544           ["mousedown", "Mouse Down"],
1545           ["mouseenter", "Mouse Enter"],
1546           ["mouseleave", "Mouse Exit"],
1547           ["mouseup", "Mouse Up"],
1548         ],
1549         event => event.target.checked
1550       );
1551     }
1552 
1553     this._setBackgroundColor(element);
1554     this._setDefaultPropertiesFromJS(element);
1555 
1556     this.container.append(element);
1557     return this.container;
1558   }
1559 }
1560 
1561 class RadioButtonWidgetAnnotationElement extends WidgetAnnotationElement {
1562   constructor(parameters) {
1563     super(parameters, { isRenderable: parameters.renderForms });
1564   }
1565 
1566   render() {
1567     this.container.classList.add("buttonWidgetAnnotation", "radioButton");
1568     const storage = this.annotationStorage;
1569     const data = this.data;
1570     const id = data.id;
1571     let value = storage.getValue(id, {
1572       value: data.fieldValue === data.buttonValue,
1573     }).value;
1574     if (typeof value === "string") {
1575       // The value has been changed through js and set in annotationStorage.
1576       value = value !== data.buttonValue;
1577       storage.setValue(id, { value });
1578     }
1579 
1580     const element = document.createElement("input");
1581     GetElementsByNameSet.add(element);
1582     element.setAttribute("data-element-id", id);
1583 
1584     element.disabled = data.readOnly;
1585     this._setRequired(element, this.data.required);
1586     element.type = "radio";
1587     element.name = data.baseFieldName || data.fieldName;
1588     if (value) {
1589       element.setAttribute("checked", true);
1590     }
1591     element.tabIndex = DEFAULT_TAB_INDEX;
1592 
1593     element.addEventListener("change", event => {
1594       const { name, checked } = event.target;
1595       for (const radio of this._getElementsByName(name, /* skipId = */ id)) {
1596         storage.setValue(radio.id, { value: false });
1597       }
1598       storage.setValue(id, { value: checked });
1599     });
1600 
1601     element.addEventListener("resetform", event => {
1602       const defaultValue = data.defaultFieldValue;
1603       event.target.checked =
1604         defaultValue !== null &&
1605         defaultValue !== undefined &&
1606         defaultValue === data.buttonValue;
1607     });
1608 
1609     if (this.enableScripting && this.hasJSActions) {
1610       const pdfButtonValue = data.buttonValue;
1611       element.addEventListener("updatefromsandbox", jsEvent => {
1612         const actions = {
1613           value: event => {
1614             const checked = pdfButtonValue === event.detail.value;
1615             for (const radio of this._getElementsByName(event.target.name)) {
1616               const curChecked = checked && radio.id === id;
1617               if (radio.domElement) {
1618                 radio.domElement.checked = curChecked;
1619               }
1620               storage.setValue(radio.id, { value: curChecked });
1621             }
1622           },
1623         };
1624         this._dispatchEventFromSandbox(actions, jsEvent);
1625       });
1626 
1627       this._setEventListeners(
1628         element,
1629         [
1630           ["change", "Validate"],
1631           ["change", "Action"],
1632           ["focus", "Focus"],
1633           ["blur", "Blur"],
1634           ["mousedown", "Mouse Down"],
1635           ["mouseenter", "Mouse Enter"],
1636           ["mouseleave", "Mouse Exit"],
1637           ["mouseup", "Mouse Up"],
1638         ],
1639         event => event.target.checked
1640       );
1641     }
1642 
1643     this._setBackgroundColor(element);
1644     this._setDefaultPropertiesFromJS(element);
1645 
1646     this.container.append(element);
1647     return this.container;
1648   }
1649 }
1650 
1651 class PushButtonWidgetAnnotationElement extends LinkAnnotationElement {
1652   constructor(parameters) {
1653     super(parameters, { ignoreBorder: parameters.data.hasAppearance });
1654   }
1655 
1656   render() {
1657     // The rendering and functionality of a push button widget annotation is
1658     // equal to that of a link annotation, but may have more functionality, such
1659     // as performing actions on form fields (resetting, submitting, et cetera).
1660     const container = super.render();
1661     container.classList.add("buttonWidgetAnnotation", "pushButton");
1662 
1663     if (this.data.alternativeText) {
1664       container.title = this.data.alternativeText;
1665     }
1666 
1667     const linkElement = container.lastChild;
1668     if (this.enableScripting && this.hasJSActions && linkElement) {
1669       this._setDefaultPropertiesFromJS(linkElement);
1670 
1671       linkElement.addEventListener("updatefromsandbox", jsEvent => {
1672         this._dispatchEventFromSandbox({}, jsEvent);
1673       });
1674     }
1675 
1676     return container;
1677   }
1678 }
1679 
1680 class ChoiceWidgetAnnotationElement extends WidgetAnnotationElement {
1681   constructor(parameters) {
1682     super(parameters, { isRenderable: parameters.renderForms });
1683   }
1684 
1685   render() {
1686     this.container.classList.add("choiceWidgetAnnotation");
1687     const storage = this.annotationStorage;
1688     const id = this.data.id;
1689 
1690     const storedData = storage.getValue(id, {
1691       value: this.data.fieldValue,
1692     });
1693 
1694     const selectElement = document.createElement("select");
1695     GetElementsByNameSet.add(selectElement);
1696     selectElement.setAttribute("data-element-id", id);
1697 
1698     selectElement.disabled = this.data.readOnly;
1699     this._setRequired(selectElement, this.data.required);
1700     selectElement.name = this.data.baseFieldName || this.data.fieldName;
1701     selectElement.tabIndex = DEFAULT_TAB_INDEX;
1702 
1703     let addAnEmptyEntry = this.data.combo && this.data.options.length > 0;
1704 
1705     if (!this.data.combo) {
1706       // List boxes have a size and (optionally) multiple selection.
1707       selectElement.size = this.data.options.length;
1708       if (this.data.multiSelect) {
1709         selectElement.multiple = true;
1710       }
1711     }
1712 
1713     selectElement.addEventListener("resetform", event => {
1714       const defaultValue = this.data.defaultFieldValue;
1715       for (const option of selectElement.options) {
1716         option.selected = option.value === defaultValue;
1717       }
1718     });
1719 
1720     // Insert the options into the choice field.
1721     for (const option of this.data.options) {
1722       const optionElement = document.createElement("option");
1723       optionElement.textContent = option.displayValue;
1724       optionElement.value = option.exportValue;
1725       if (storedData.value.includes(option.exportValue)) {
1726         optionElement.setAttribute("selected", true);
1727         addAnEmptyEntry = false;
1728       }
1729       selectElement.append(optionElement);
1730     }
1731 
1732     let removeEmptyEntry = null;
1733     if (addAnEmptyEntry) {
1734       const noneOptionElement = document.createElement("option");
1735       noneOptionElement.value = " ";
1736       noneOptionElement.setAttribute("hidden", true);
1737       noneOptionElement.setAttribute("selected", true);
1738       selectElement.prepend(noneOptionElement);
1739 
1740       removeEmptyEntry = () => {
1741         noneOptionElement.remove();
1742         selectElement.removeEventListener("input", removeEmptyEntry);
1743         removeEmptyEntry = null;
1744       };
1745       selectElement.addEventListener("input", removeEmptyEntry);
1746     }
1747 
1748     const getValue = isExport => {
1749       const name = isExport ? "value" : "textContent";
1750       const { options, multiple } = selectElement;
1751       if (!multiple) {
1752         return options.selectedIndex === -1
1753           ? null
1754           : options[options.selectedIndex][name];
1755       }
1756       return Array.prototype.filter
1757         .call(options, option => option.selected)
1758         .map(option => option[name]);
1759     };
1760 
1761     let selectedValues = getValue(/* isExport */ false);
1762 
1763     const getItems = event => {
1764       const options = event.target.options;
1765       return Array.prototype.map.call(options, option => {
1766         return { displayValue: option.textContent, exportValue: option.value };
1767       });
1768     };
1769 
1770     if (this.enableScripting && this.hasJSActions) {
1771       selectElement.addEventListener("updatefromsandbox", jsEvent => {
1772         const actions = {
1773           value(event) {
1774             removeEmptyEntry?.();
1775             const value = event.detail.value;
1776             const values = new Set(Array.isArray(value) ? value : [value]);
1777             for (const option of selectElement.options) {
1778               option.selected = values.has(option.value);
1779             }
1780             storage.setValue(id, {
1781               value: getValue(/* isExport */ true),
1782             });
1783             selectedValues = getValue(/* isExport */ false);
1784           },
1785           multipleSelection(event) {
1786             selectElement.multiple = true;
1787           },
1788           remove(event) {
1789             const options = selectElement.options;
1790             const index = event.detail.remove;
1791             options[index].selected = false;
1792             selectElement.remove(index);
1793             if (options.length > 0) {
1794               const i = Array.prototype.findIndex.call(
1795                 options,
1796                 option => option.selected
1797               );
1798               if (i === -1) {
1799                 options[0].selected = true;
1800               }
1801             }
1802             storage.setValue(id, {
1803               value: getValue(/* isExport */ true),
1804               items: getItems(event),
1805             });
1806             selectedValues = getValue(/* isExport */ false);
1807           },
1808           clear(event) {
1809             while (selectElement.length !== 0) {
1810               selectElement.remove(0);
1811             }
1812             storage.setValue(id, { value: null, items: [] });
1813             selectedValues = getValue(/* isExport */ false);
1814           },
1815           insert(event) {
1816             const { index, displayValue, exportValue } = event.detail.insert;
1817             const selectChild = selectElement.children[index];
1818             const optionElement = document.createElement("option");
1819             optionElement.textContent = displayValue;
1820             optionElement.value = exportValue;
1821 
1822             if (selectChild) {
1823               selectChild.before(optionElement);
1824             } else {
1825               selectElement.append(optionElement);
1826             }
1827             storage.setValue(id, {
1828               value: getValue(/* isExport */ true),
1829               items: getItems(event),
1830             });
1831             selectedValues = getValue(/* isExport */ false);
1832           },
1833           items(event) {
1834             const { items } = event.detail;
1835             while (selectElement.length !== 0) {
1836               selectElement.remove(0);
1837             }
1838             for (const item of items) {
1839               const { displayValue, exportValue } = item;
1840               const optionElement = document.createElement("option");
1841               optionElement.textContent = displayValue;
1842               optionElement.value = exportValue;
1843               selectElement.append(optionElement);
1844             }
1845             if (selectElement.options.length > 0) {
1846               selectElement.options[0].selected = true;
1847             }
1848             storage.setValue(id, {
1849               value: getValue(/* isExport */ true),
1850               items: getItems(event),
1851             });
1852             selectedValues = getValue(/* isExport */ false);
1853           },
1854           indices(event) {
1855             const indices = new Set(event.detail.indices);
1856             for (const option of event.target.options) {
1857               option.selected = indices.has(option.index);
1858             }
1859             storage.setValue(id, {
1860               value: getValue(/* isExport */ true),
1861             });
1862             selectedValues = getValue(/* isExport */ false);
1863           },
1864           editable(event) {
1865             event.target.disabled = !event.detail.editable;
1866           },
1867         };
1868         this._dispatchEventFromSandbox(actions, jsEvent);
1869       });
1870 
1871       selectElement.addEventListener("input", event => {
1872         const exportValue = getValue(/* isExport */ true);
1873         storage.setValue(id, { value: exportValue });
1874 
1875         event.preventDefault();
1876 
1877         this.linkService.eventBus?.dispatch("dispatcheventinsandbox", {
1878           source: this,
1879           detail: {
1880             id,
1881             name: "Keystroke",
1882             value: selectedValues,
1883             changeEx: exportValue,
1884             willCommit: false,
1885             commitKey: 1,
1886             keyDown: false,
1887           },
1888         });
1889       });
1890 
1891       this._setEventListeners(
1892         selectElement,
1893         [
1894           ["focus", "Focus"],
1895           ["blur", "Blur"],
1896           ["mousedown", "Mouse Down"],
1897           ["mouseenter", "Mouse Enter"],
1898           ["mouseleave", "Mouse Exit"],
1899           ["mouseup", "Mouse Up"],
1900           ["input", "Action"],
1901           ["input", "Validate"],
1902         ],
1903         event => event.target.value
1904       );
1905     } else {
1906       selectElement.addEventListener("input", function (event) {
1907         storage.setValue(id, { value: getValue(/* isExport */ true) });
1908       });
1909     }
1910 
1911     if (this.data.combo) {
1912       this._setTextStyle(selectElement);
1913     } else {
1914       // Just use the default font size...
1915       // it's a bit hard to guess what is a good size.
1916     }
1917     this._setBackgroundColor(selectElement);
1918     this._setDefaultPropertiesFromJS(selectElement);
1919 
1920     this.container.append(selectElement);
1921     return this.container;
1922   }
1923 }
1924 
1925 class PopupAnnotationElement extends AnnotationElement {
1926   constructor(parameters) {
1927     const { data, elements } = parameters;
1928     const isRenderable = !!(
1929       data.titleObj?.str ||
1930       data.contentsObj?.str ||
1931       data.richText?.str
1932     );
1933     super(parameters, { isRenderable });
1934     this.elements = elements;
1935   }
1936 
1937   render() {
1938     this.container.classList.add("popupAnnotation");
1939 
1940     const popup = new PopupElement({
1941       container: this.container,
1942       color: this.data.color,
1943       titleObj: this.data.titleObj,
1944       modificationDate: this.data.modificationDate,
1945       contentsObj: this.data.contentsObj,
1946       richText: this.data.richText,
1947       rect: this.data.rect,
1948       parentRect: this.data.parentRect || null,
1949       parent: this.parent,
1950       elements: this.elements,
1951       open: this.data.open,
1952     });
1953 
1954     const elementIds = [];
1955     for (const element of this.elements) {
1956       element.popup = popup;
1957       elementIds.push(element.data.id);
1958       element.addHighlightArea();
1959     }
1960 
1961     this.container.setAttribute("aria-controls", elementIds.join(","));
1962 
1963     return this.container;
1964   }
1965 }
1966 
1967 class PopupElement {
1968   #dateTimePromise = null;
1969 
1970   #boundHide = this.#hide.bind(this);
1971 
1972   #boundShow = this.#show.bind(this);
1973 
1974   #boundToggle = this.#toggle.bind(this);
1975 
1976   #color = null;
1977 
1978   #container = null;
1979 
1980   #contentsObj = null;
1981 
1982   #elements = null;
1983 
1984   #parent = null;
1985 
1986   #parentRect = null;
1987 
1988   #pinned = false;
1989 
1990   #popup = null;
1991 
1992   #rect = null;
1993 
1994   #richText = null;
1995 
1996   #titleObj = null;
1997 
1998   #wasVisible = false;
1999 
2000   constructor({
2001     container,
2002     color,
2003     elements,
2004     titleObj,
2005     modificationDate,
2006     contentsObj,
2007     richText,
2008     parent,
2009     rect,
2010     parentRect,
2011     open,
2012   }) {
2013     this.#container = container;
2014     this.#titleObj = titleObj;
2015     this.#contentsObj = contentsObj;
2016     this.#richText = richText;
2017     this.#parent = parent;
2018     this.#color = color;
2019     this.#rect = rect;
2020     this.#parentRect = parentRect;
2021     this.#elements = elements;
2022 
2023     const dateObject = PDFDateString.toDateObject(modificationDate);
2024     if (dateObject) {
2025       // The modification date is shown in the popup instead of the creation
2026       // date if it is available and can be parsed correctly, which is
2027       // consistent with other viewers such as Adobe Acrobat.
2028       this.#dateTimePromise = parent.l10n.get("annotation_date_string", {
2029         date: dateObject.toLocaleDateString(),
2030         time: dateObject.toLocaleTimeString(),
2031       });
2032     }
2033 
2034     this.trigger = elements.flatMap(e => e.getElementsToTriggerPopup());
2035     // Attach the event listeners to the trigger element.
2036     for (const element of this.trigger) {
2037       element.addEventListener("click", this.#boundToggle);
2038       element.addEventListener("mouseenter", this.#boundShow);
2039       element.addEventListener("mouseleave", this.#boundHide);
2040       if (typeof PDFJSDev !== "undefined" && PDFJSDev.test("TESTING")) {
2041         element.classList.add("popupTriggerArea");
2042       }
2043     }
2044 
2045     this.#container.hidden = true;
2046     if (open) {
2047       this.#toggle();
2048     }
2049 
2050     if (typeof PDFJSDev !== "undefined" && PDFJSDev.test("TESTING")) {
2051       // Since the popup is lazily created, we need to ensure that it'll be
2052       // created and displayed during reference tests.
2053       this.#parent.popupShow.push(async () => {
2054         if (this.#container.hidden) {
2055           this.#show();
2056         }
2057         if (this.#dateTimePromise) {
2058           await this.#dateTimePromise;
2059         }
2060       });
2061     }
2062   }
2063 
2064   render() {
2065     if (this.#popup) {
2066       return;
2067     }
2068 
2069     const {
2070       page: { view },
2071       viewport: {
2072         rawDims: { pageWidth, pageHeight, pageX, pageY },
2073       },
2074     } = this.#parent;
2075     const popup = (this.#popup = document.createElement("div"));
2076     popup.className = "popup";
2077 
2078     if (this.#color) {
2079       const baseColor = (popup.style.outlineColor = Util.makeHexColor(
2080         ...this.#color
2081       ));
2082       if (
2083         (typeof PDFJSDev !== "undefined" && PDFJSDev.test("MOZCENTRAL")) ||
2084         CSS.supports("background-color", "color-mix(in srgb, red 30%, white)")
2085       ) {
2086         popup.style.backgroundColor = `color-mix(in srgb, ${baseColor} 30%, white)`;
2087       } else {
2088         // color-mix isn't supported in some browsers hence this version.
2089         // See https://developer.mozilla.org/en-US/docs/Web/CSS/color_value/color-mix#browser_compatibility
2090         // TODO: Use color-mix when it's supported everywhere.
2091         // Enlighten the color.
2092         const BACKGROUND_ENLIGHT = 0.7;
2093         popup.style.backgroundColor = Util.makeHexColor(
2094           ...this.#color.map(c =>
2095             Math.floor(BACKGROUND_ENLIGHT * (255 - c) + c)
2096           )
2097         );
2098       }
2099     }
2100 
2101     const header = document.createElement("span");
2102     header.className = "header";
2103     const title = document.createElement("h1");
2104     header.append(title);
2105     ({ dir: title.dir, str: title.textContent } = this.#titleObj);
2106     popup.append(header);
2107 
2108     if (this.#dateTimePromise) {
2109       const modificationDate = document.createElement("span");
2110       modificationDate.classList.add("popupDate");
2111       this.#dateTimePromise.then(localized => {
2112         modificationDate.textContent = localized;
2113       });
2114       header.append(modificationDate);
2115     }
2116 
2117     const contentsObj = this.#contentsObj;
2118     const richText = this.#richText;
2119     if (
2120       richText?.str &&
2121       (!contentsObj?.str || contentsObj.str === richText.str)
2122     ) {
2123       XfaLayer.render({
2124         xfaHtml: richText.html,
2125         intent: "richText",
2126         div: popup,
2127       });
2128       popup.lastChild.classList.add("richText", "popupContent");
2129     } else {
2130       const contents = this._formatContents(contentsObj);
2131       popup.append(contents);
2132     }
2133 
2134     let useParentRect = !!this.#parentRect;
2135     let rect = useParentRect ? this.#parentRect : this.#rect;
2136     for (const element of this.#elements) {
2137       if (!rect || Util.intersect(element.data.rect, rect) !== null) {
2138         rect = element.data.rect;
2139         useParentRect = true;
2140         break;
2141       }
2142     }
2143 
2144     const normalizedRect = Util.normalizeRect([
2145       rect[0],
2146       view[3] - rect[1] + view[1],
2147       rect[2],
2148       view[3] - rect[3] + view[1],
2149     ]);
2150 
2151     const HORIZONTAL_SPACE_AFTER_ANNOTATION = 5;
2152     const parentWidth = useParentRect
2153       ? rect[2] - rect[0] + HORIZONTAL_SPACE_AFTER_ANNOTATION
2154       : 0;
2155     const popupLeft = normalizedRect[0] + parentWidth;
2156     const popupTop = normalizedRect[1];
2157 
2158     const { style } = this.#container;
2159     style.left = `${(100 * (popupLeft - pageX)) / pageWidth}%`;
2160     style.top = `${(100 * (popupTop - pageY)) / pageHeight}%`;
2161 
2162     this.#container.append(popup);
2163   }
2164 
2165   /**
2166    * Format the contents of the popup by adding newlines where necessary.
2167    *
2168    * @private
2169    * @param {Object<string, string>} contentsObj
2170    * @memberof PopupElement
2171    * @returns {HTMLParagraphElement}
2172    */
2173   _formatContents({ str, dir }) {
2174     const p = document.createElement("p");
2175     p.classList.add("popupContent");
2176     p.dir = dir;
2177     const lines = str.split(/(?:\r\n?|\n)/);
2178     for (let i = 0, ii = lines.length; i < ii; ++i) {
2179       const line = lines[i];
2180       p.append(document.createTextNode(line));
2181       if (i < ii - 1) {
2182         p.append(document.createElement("br"));
2183       }
2184     }
2185     return p;
2186   }
2187 
2188   /**
2189    * Toggle the visibility of the popup.
2190    */
2191   #toggle() {
2192     this.#pinned = !this.#pinned;
2193     if (this.#pinned) {
2194       this.#show();
2195       this.#container.addEventListener("click", this.#boundToggle);
2196     } else {
2197       this.#hide();
2198       this.#container.removeEventListener("click", this.#boundToggle);
2199     }
2200   }
2201 
2202   /**
2203    * Show the popup.
2204    */
2205   #show() {
2206     if (!this.#popup) {
2207       this.render();
2208     }
2209     if (!this.isVisible) {
2210       this.#container.hidden = false;
2211       this.#container.style.zIndex =
2212         parseInt(this.#container.style.zIndex) + 1000;
2213     } else if (this.#pinned) {
2214       this.#container.classList.add("focused");
2215     }
2216   }
2217 
2218   /**
2219    * Hide the popup.
2220    */
2221   #hide() {
2222     this.#container.classList.remove("focused");
2223     if (this.#pinned || !this.isVisible) {
2224       return;
2225     }
2226     this.#container.hidden = true;
2227     this.#container.style.zIndex =
2228       parseInt(this.#container.style.zIndex) - 1000;
2229   }
2230 
2231   forceHide() {
2232     this.#wasVisible = this.isVisible;
2233     if (!this.#wasVisible) {
2234       return;
2235     }
2236     this.#container.hidden = true;
2237   }
2238 
2239   maybeShow() {
2240     if (!this.#wasVisible) {
2241       return;
2242     }
2243     this.#wasVisible = false;
2244     this.#container.hidden = false;
2245   }
2246 
2247   get isVisible() {
2248     return this.#container.hidden === false;
2249   }
2250 }
2251 
2252 class FreeTextAnnotationElement extends AnnotationElement {
2253   constructor(parameters) {
2254     const isRenderable = !!(
2255       parameters.data.popupRef ||
2256       parameters.data.titleObj?.str ||
2257       parameters.data.contentsObj?.str ||
2258       parameters.data.richText?.str
2259     );
2260     super(parameters, { isRenderable, ignoreBorder: true });
2261     this.textContent = parameters.data.textContent;
2262     this.textPosition = parameters.data.textPosition;
2263     this.annotationEditorType = AnnotationEditorType.FREETEXT;
2264   }
2265 
2266   render() {
2267     this.container.classList.add("freeTextAnnotation");
2268 
2269     if (this.textContent) {
2270       const content = document.createElement("div");
2271       content.classList.add("annotationTextContent");
2272       content.setAttribute("role", "comment");
2273       for (const line of this.textContent) {
2274         const lineSpan = document.createElement("span");
2275         lineSpan.textContent = line;
2276         content.append(lineSpan);
2277       }
2278       this.container.append(content);
2279     }
2280 
2281     if (!this.data.popupRef) {
2282       this._createPopup();
2283     }
2284 
2285     this._editOnDoubleClick();
2286 
2287     return this.container;
2288   }
2289 }
2290 
2291 class LineAnnotationElement extends AnnotationElement {
2292   #line = null;
2293 
2294   constructor(parameters) {
2295     const isRenderable = !!(
2296       parameters.data.popupRef ||
2297       parameters.data.titleObj?.str ||
2298       parameters.data.contentsObj?.str ||
2299       parameters.data.richText?.str
2300     );
2301     super(parameters, { isRenderable, ignoreBorder: true });
2302   }
2303 
2304   render() {
2305     this.container.classList.add("lineAnnotation");
2306 
2307     // Create an invisible line with the same starting and ending coordinates
2308     // that acts as the trigger for the popup. Only the line itself should
2309     // trigger the popup, not the entire container.
2310     const data = this.data;
2311     const { width, height } = getRectDims(data.rect);
2312     const svg = this.svgFactory.create(
2313       width,
2314       height,
2315       /* skipDimensions = */ true
2316     );
2317 
2318     // PDF coordinates are calculated from a bottom left origin, so transform
2319     // the line coordinates to a top left origin for the SVG element.
2320     const line = (this.#line = this.svgFactory.createElement("svg:line"));
2321     line.setAttribute("x1", data.rect[2] - data.lineCoordinates[0]);
2322     line.setAttribute("y1", data.rect[3] - data.lineCoordinates[1]);
2323     line.setAttribute("x2", data.rect[2] - data.lineCoordinates[2]);
2324     line.setAttribute("y2", data.rect[3] - data.lineCoordinates[3]);
2325     // Ensure that the 'stroke-width' is always non-zero, since otherwise it
2326     // won't be possible to open/close the popup (note e.g. issue 11122).
2327     line.setAttribute("stroke-width", data.borderStyle.width || 1);
2328     line.setAttribute("stroke", "transparent");
2329     line.setAttribute("fill", "transparent");
2330 
2331     svg.append(line);
2332     this.container.append(svg);
2333 
2334     // Create the popup ourselves so that we can bind it to the line instead
2335     // of to the entire container (which is the default).
2336     if (!data.popupRef) {
2337       this._createPopup();
2338     }
2339 
2340     return this.container;
2341   }
2342 
2343   getElementsToTriggerPopup() {
2344     return this.#line;
2345   }
2346 
2347   addHighlightArea() {
2348     this.container.classList.add("highlightArea");
2349   }
2350 }
2351 
2352 class SquareAnnotationElement extends AnnotationElement {
2353   #square = null;
2354 
2355   constructor(parameters) {
2356     const isRenderable = !!(
2357       parameters.data.popupRef ||
2358       parameters.data.titleObj?.str ||
2359       parameters.data.contentsObj?.str ||
2360       parameters.data.richText?.str
2361     );
2362     super(parameters, { isRenderable, ignoreBorder: true });
2363   }
2364 
2365   render() {
2366     this.container.classList.add("squareAnnotation");
2367 
2368     // Create an invisible square with the same rectangle that acts as the
2369     // trigger for the popup. Only the square itself should trigger the
2370     // popup, not the entire container.
2371     const data = this.data;
2372     const { width, height } = getRectDims(data.rect);
2373     const svg = this.svgFactory.create(
2374       width,
2375       height,
2376       /* skipDimensions = */ true
2377     );
2378 
2379     // The browser draws half of the borders inside the square and half of
2380     // the borders outside the square by default. This behavior cannot be
2381     // changed programmatically, so correct for that here.
2382     const borderWidth = data.borderStyle.width;
2383     const square = (this.#square = this.svgFactory.createElement("svg:rect"));
2384     square.setAttribute("x", borderWidth / 2);
2385     square.setAttribute("y", borderWidth / 2);
2386     square.setAttribute("width", width - borderWidth);
2387     square.setAttribute("height", height - borderWidth);
2388     // Ensure that the 'stroke-width' is always non-zero, since otherwise it
2389     // won't be possible to open/close the popup (note e.g. issue 11122).
2390     square.setAttribute("stroke-width", borderWidth || 1);
2391     square.setAttribute("stroke", "transparent");
2392     square.setAttribute("fill", "transparent");
2393 
2394     svg.append(square);
2395     this.container.append(svg);
2396 
2397     // Create the popup ourselves so that we can bind it to the square instead
2398     // of to the entire container (which is the default).
2399     if (!data.popupRef) {
2400       this._createPopup();
2401     }
2402 
2403     return this.container;
2404   }
2405 
2406   getElementsToTriggerPopup() {
2407     return this.#square;
2408   }
2409 
2410   addHighlightArea() {
2411     this.container.classList.add("highlightArea");
2412   }
2413 }
2414 
2415 class CircleAnnotationElement extends AnnotationElement {
2416   #circle = null;
2417 
2418   constructor(parameters) {
2419     const isRenderable = !!(
2420       parameters.data.popupRef ||
2421       parameters.data.titleObj?.str ||
2422       parameters.data.contentsObj?.str ||
2423       parameters.data.richText?.str
2424     );
2425     super(parameters, { isRenderable, ignoreBorder: true });
2426   }
2427 
2428   render() {
2429     this.container.classList.add("circleAnnotation");
2430 
2431     // Create an invisible circle with the same ellipse that acts as the
2432     // trigger for the popup. Only the circle itself should trigger the
2433     // popup, not the entire container.
2434     const data = this.data;
2435     const { width, height } = getRectDims(data.rect);
2436     const svg = this.svgFactory.create(
2437       width,
2438       height,
2439       /* skipDimensions = */ true
2440     );
2441 
2442     // The browser draws half of the borders inside the circle and half of
2443     // the borders outside the circle by default. This behavior cannot be
2444     // changed programmatically, so correct for that here.
2445     const borderWidth = data.borderStyle.width;
2446     const circle = (this.#circle =
2447       this.svgFactory.createElement("svg:ellipse"));
2448     circle.setAttribute("cx", width / 2);
2449     circle.setAttribute("cy", height / 2);
2450     circle.setAttribute("rx", width / 2 - borderWidth / 2);
2451     circle.setAttribute("ry", height / 2 - borderWidth / 2);
2452     // Ensure that the 'stroke-width' is always non-zero, since otherwise it
2453     // won't be possible to open/close the popup (note e.g. issue 11122).
2454     circle.setAttribute("stroke-width", borderWidth || 1);
2455     circle.setAttribute("stroke", "transparent");
2456     circle.setAttribute("fill", "transparent");
2457 
2458     svg.append(circle);
2459     this.container.append(svg);
2460 
2461     // Create the popup ourselves so that we can bind it to the circle instead
2462     // of to the entire container (which is the default).
2463     if (!data.popupRef) {
2464       this._createPopup();
2465     }
2466 
2467     return this.container;
2468   }
2469 
2470   getElementsToTriggerPopup() {
2471     return this.#circle;
2472   }
2473 
2474   addHighlightArea() {
2475     this.container.classList.add("highlightArea");
2476   }
2477 }
2478 
2479 class PolylineAnnotationElement extends AnnotationElement {
2480   #polyline = null;
2481 
2482   constructor(parameters) {
2483     const isRenderable = !!(
2484       parameters.data.popupRef ||
2485       parameters.data.titleObj?.str ||
2486       parameters.data.contentsObj?.str ||
2487       parameters.data.richText?.str
2488     );
2489     super(parameters, { isRenderable, ignoreBorder: true });
2490 
2491     this.containerClassName = "polylineAnnotation";
2492     this.svgElementName = "svg:polyline";
2493   }
2494 
2495   render() {
2496     this.container.classList.add(this.containerClassName);
2497 
2498     // Create an invisible polyline with the same points that acts as the
2499     // trigger for the popup. Only the polyline itself should trigger the
2500     // popup, not the entire container.
2501     const data = this.data;
2502     const { width, height } = getRectDims(data.rect);
2503     const svg = this.svgFactory.create(
2504       width,
2505       height,
2506       /* skipDimensions = */ true
2507     );
2508 
2509     // Convert the vertices array to a single points string that the SVG
2510     // polyline element expects ("x1,y1 x2,y2 ..."). PDF coordinates are
2511     // calculated from a bottom left origin, so transform the polyline
2512     // coordinates to a top left origin for the SVG element.
2513     let points = [];
2514     for (const coordinate of data.vertices) {
2515       const x = coordinate.x - data.rect[0];
2516       const y = data.rect[3] - coordinate.y;
2517       points.push(x + "," + y);
2518     }
2519     points = points.join(" ");
2520 
2521     const polyline = (this.#polyline = this.svgFactory.createElement(
2522       this.svgElementName
2523     ));
2524     polyline.setAttribute("points", points);
2525     // Ensure that the 'stroke-width' is always non-zero, since otherwise it
2526     // won't be possible to open/close the popup (note e.g. issue 11122).
2527     polyline.setAttribute("stroke-width", data.borderStyle.width || 1);
2528     polyline.setAttribute("stroke", "transparent");
2529     polyline.setAttribute("fill", "transparent");
2530 
2531     svg.append(polyline);
2532     this.container.append(svg);
2533 
2534     // Create the popup ourselves so that we can bind it to the polyline
2535     // instead of to the entire container (which is the default).
2536     if (!data.popupRef) {
2537       this._createPopup(polyline, data);
2538     }
2539 
2540     return this.container;
2541   }
2542 
2543   getElementsToTriggerPopup() {
2544     return this.#polyline;
2545   }
2546 
2547   addHighlightArea() {
2548     this.container.classList.add("highlightArea");
2549   }
2550 }
2551 
2552 class PolygonAnnotationElement extends PolylineAnnotationElement {
2553   constructor(parameters) {
2554     // Polygons are specific forms of polylines, so reuse their logic.
2555     super(parameters);
2556 
2557     this.containerClassName = "polygonAnnotation";
2558     this.svgElementName = "svg:polygon";
2559   }
2560 }
2561 
2562 class CaretAnnotationElement extends AnnotationElement {
2563   constructor(parameters) {
2564     const isRenderable = !!(
2565       parameters.data.popupRef ||
2566       parameters.data.titleObj?.str ||
2567       parameters.data.contentsObj?.str ||
2568       parameters.data.richText?.str
2569     );
2570     super(parameters, { isRenderable, ignoreBorder: true });
2571   }
2572 
2573   render() {
2574     this.container.classList.add("caretAnnotation");
2575 
2576     if (!this.data.popupRef) {
2577       this._createPopup();
2578     }
2579     return this.container;
2580   }
2581 }
2582 
2583 class InkAnnotationElement extends AnnotationElement {
2584   #polylines = [];
2585 
2586   constructor(parameters) {
2587     const isRenderable = !!(
2588       parameters.data.popupRef ||
2589       parameters.data.titleObj?.str ||
2590       parameters.data.contentsObj?.str ||
2591       parameters.data.richText?.str
2592     );
2593     super(parameters, { isRenderable, ignoreBorder: true });
2594 
2595     this.containerClassName = "inkAnnotation";
2596 
2597     // Use the polyline SVG element since it allows us to use coordinates
2598     // directly and to draw both straight lines and curves.
2599     this.svgElementName = "svg:polyline";
2600     this.annotationEditorType = AnnotationEditorType.INK;
2601   }
2602 
2603   render() {
2604     this.container.classList.add(this.containerClassName);
2605 
2606     // Create an invisible polyline with the same points that acts as the
2607     // trigger for the popup.
2608     const data = this.data;
2609     const { width, height } = getRectDims(data.rect);
2610     const svg = this.svgFactory.create(
2611       width,
2612       height,
2613       /* skipDimensions = */ true
2614     );
2615 
2616     for (const inkList of data.inkLists) {
2617       // Convert the ink list to a single points string that the SVG
2618       // polyline element expects ("x1,y1 x2,y2 ..."). PDF coordinates are
2619       // calculated from a bottom left origin, so transform the polyline
2620       // coordinates to a top left origin for the SVG element.
2621       let points = [];
2622       for (const coordinate of inkList) {
2623         const x = coordinate.x - data.rect[0];
2624         const y = data.rect[3] - coordinate.y;
2625         points.push(`${x},${y}`);
2626       }
2627       points = points.join(" ");
2628 
2629       const polyline = this.svgFactory.createElement(this.svgElementName);
2630       this.#polylines.push(polyline);
2631       polyline.setAttribute("points", points);
2632       // Ensure that the 'stroke-width' is always non-zero, since otherwise it
2633       // won't be possible to open/close the popup (note e.g. issue 11122).
2634       polyline.setAttribute("stroke-width", data.borderStyle.width || 1);
2635       polyline.setAttribute("stroke", "transparent");
2636       polyline.setAttribute("fill", "transparent");
2637 
2638       // Create the popup ourselves so that we can bind it to the polyline
2639       // instead of to the entire container (which is the default).
2640       if (!data.popupRef) {
2641         this._createPopup(polyline, data);
2642       }
2643 
2644       svg.append(polyline);
2645     }
2646 
2647     this.container.append(svg);
2648     return this.container;
2649   }
2650 
2651   getElementsToTriggerPopup() {
2652     return this.#polylines;
2653   }
2654 
2655   addHighlightArea() {
2656     this.container.classList.add("highlightArea");
2657   }
2658 }
2659 
2660 class HighlightAnnotationElement extends AnnotationElement {
2661   constructor(parameters) {
2662     const isRenderable = !!(
2663       parameters.data.popupRef ||
2664       parameters.data.titleObj?.str ||
2665       parameters.data.contentsObj?.str ||
2666       parameters.data.richText?.str
2667     );
2668     super(parameters, {
2669       isRenderable,
2670       ignoreBorder: true,
2671       createQuadrilaterals: true,
2672     });
2673   }
2674 
2675   render() {
2676     if (!this.data.popupRef) {
2677       this._createPopup();
2678     }
2679 
2680     this.container.classList.add("highlightAnnotation");
2681     return this.container;
2682   }
2683 }
2684 
2685 class UnderlineAnnotationElement extends AnnotationElement {
2686   constructor(parameters) {
2687     const isRenderable = !!(
2688       parameters.data.popupRef ||
2689       parameters.data.titleObj?.str ||
2690       parameters.data.contentsObj?.str ||
2691       parameters.data.richText?.str
2692     );
2693     super(parameters, {
2694       isRenderable,
2695       ignoreBorder: true,
2696       createQuadrilaterals: true,
2697     });
2698   }
2699 
2700   render() {
2701     if (!this.data.popupRef) {
2702       this._createPopup();
2703     }
2704 
2705     this.container.classList.add("underlineAnnotation");
2706     return this.container;
2707   }
2708 }
2709 
2710 class SquigglyAnnotationElement extends AnnotationElement {
2711   constructor(parameters) {
2712     const isRenderable = !!(
2713       parameters.data.popupRef ||
2714       parameters.data.titleObj?.str ||
2715       parameters.data.contentsObj?.str ||
2716       parameters.data.richText?.str
2717     );
2718     super(parameters, {
2719       isRenderable,
2720       ignoreBorder: true,
2721       createQuadrilaterals: true,
2722     });
2723   }
2724 
2725   render() {
2726     if (!this.data.popupRef) {
2727       this._createPopup();
2728     }
2729 
2730     this.container.classList.add("squigglyAnnotation");
2731     return this.container;
2732   }
2733 }
2734 
2735 class StrikeOutAnnotationElement extends AnnotationElement {
2736   constructor(parameters) {
2737     const isRenderable = !!(
2738       parameters.data.popupRef ||
2739       parameters.data.titleObj?.str ||
2740       parameters.data.contentsObj?.str ||
2741       parameters.data.richText?.str
2742     );
2743     super(parameters, {
2744       isRenderable,
2745       ignoreBorder: true,
2746       createQuadrilaterals: true,
2747     });
2748   }
2749 
2750   render() {
2751     if (!this.data.popupRef) {
2752       this._createPopup();
2753     }
2754 
2755     this.container.classList.add("strikeoutAnnotation");
2756     return this.container;
2757   }
2758 }
2759 
2760 class StampAnnotationElement extends AnnotationElement {
2761   constructor(parameters) {
2762     const isRenderable = !!(
2763       parameters.data.popupRef ||
2764       parameters.data.titleObj?.str ||
2765       parameters.data.contentsObj?.str ||
2766       parameters.data.richText?.str
2767     );
2768     super(parameters, { isRenderable, ignoreBorder: true });
2769   }
2770 
2771   render() {
2772     this.container.classList.add("stampAnnotation");
2773 
2774     if (!this.data.popupRef) {
2775       this._createPopup();
2776     }
2777     return this.container;
2778   }
2779 }
2780 
2781 class FileAttachmentAnnotationElement extends AnnotationElement {
2782   #trigger = null;
2783 
2784   constructor(parameters) {
2785     super(parameters, { isRenderable: true });
2786 
2787     const { filename, content } = this.data.file;
2788     this.filename = getFilenameFromUrl(filename, /* onlyStripPath = */ true);
2789     this.content = content;
2790 
2791     this.linkService.eventBus?.dispatch("fileattachmentannotation", {
2792       source: this,
2793       filename,
2794       content,
2795     });
2796   }
2797 
2798   render() {
2799     this.container.classList.add("fileAttachmentAnnotation");
2800 
2801     let trigger;
2802     if (this.data.hasAppearance) {
2803       trigger = document.createElement("div");
2804     } else {
2805       // Unfortunately it seems that it's not clearly specified exactly what
2806       // names are actually valid, since Table 184 contains:
2807       //   Conforming readers shall provide predefined icon appearances for at
2808       //   least the following standard names: GraphPushPin, PaperclipTag.
2809       //   Additional names may be supported as well. Default value: PushPin.
2810       trigger = document.createElement("img");
2811       trigger.src = `${this.imageResourcesPath}annotation-${
2812         /paperclip/i.test(this.data.name) ? "paperclip" : "pushpin"
2813       }.svg`;
2814     }
2815     trigger.classList.add("popupTriggerArea");
2816     trigger.addEventListener("dblclick", this._download.bind(this));
2817     this.#trigger = trigger;
2818 
2819     if (
2820       !this.data.popupRef &&
2821       (this.data.titleObj?.str ||
2822         this.data.contentsObj?.str ||
2823         this.data.richText)
2824     ) {
2825       this._createPopup();
2826     }
2827 
2828     this.container.append(trigger);
2829     return this.container;
2830   }
2831 
2832   getElementsToTriggerPopup() {
2833     return this.#trigger;
2834   }
2835 
2836   addHighlightArea() {
2837     this.container.classList.add("highlightArea");
2838   }
2839 
2840   /**
2841    * Download the file attachment associated with this annotation.
2842    *
2843    * @private
2844    * @memberof FileAttachmentAnnotationElement
2845    */
2846   _download() {
2847     this.downloadManager?.openOrDownloadData(
2848       this.container,
2849       this.content,
2850       this.filename
2851     );
2852   }
2853 }
2854 
2855 /**
2856  * @typedef {Object} AnnotationLayerParameters
2857  * @property {PageViewport} viewport
2858  * @property {HTMLDivElement} div
2859  * @property {Array} annotations
2860  * @property {PDFPageProxy} page
2861  * @property {IPDFLinkService} linkService
2862  * @property {IDownloadManager} downloadManager
2863  * @property {AnnotationStorage} [annotationStorage]
2864  * @property {string} [imageResourcesPath] - Path for image resources, mainly
2865  *   for annotation icons. Include trailing slash.
2866  * @property {boolean} renderForms
2867  * @property {boolean} [enableScripting] - Enable embedded script execution.
2868  * @property {boolean} [hasJSActions] - Some fields have JS actions.
2869  *   The default value is `false`.
2870  * @property {Object<string, Array<Object>> | null} [fieldObjects]
2871  * @property {Map<string, HTMLCanvasElement>} [annotationCanvasMap]
2872  * @property {TextAccessibilityManager} [accessibilityManager]
2873  */
2874 
2875 /**
2876  * Manage the layer containing all the annotations.
2877  */
2878 class AnnotationLayer {
2879   #accessibilityManager = null;
2880 
2881   #annotationCanvasMap = null;
2882 
2883   #editableAnnotations = new Map();
2884 
2885   constructor({
2886     div,
2887     accessibilityManager,
2888     annotationCanvasMap,
2889     l10n,
2890     page,
2891     viewport,
2892   }) {
2893     this.div = div;
2894     this.#accessibilityManager = accessibilityManager;
2895     this.#annotationCanvasMap = annotationCanvasMap;
2896     this.l10n = l10n;
2897     this.page = page;
2898     this.viewport = viewport;
2899     this.zIndex = 0;
2900 
2901     if (
2902       typeof PDFJSDev !== "undefined" &&
2903       PDFJSDev.test("GENERIC && !TESTING")
2904     ) {
2905       this.l10n ||= NullL10n;
2906     }
2907     if (typeof PDFJSDev !== "undefined" && PDFJSDev.test("TESTING")) {
2908       // For testing purposes.
2909       Object.defineProperty(this, "showPopups", {
2910         value: async () => {
2911           for (const show of this.popupShow) {
2912             await show();
2913           }
2914         },
2915       });
2916       this.popupShow = [];
2917     }
2918   }
2919 
2920   #appendElement(element, id) {
2921     const contentElement = element.firstChild || element;
2922     contentElement.id = `${AnnotationPrefix}${id}`;
2923 
2924     this.div.append(element);
2925     this.#accessibilityManager?.moveElementInDOM(
2926       this.div,
2927       element,
2928       contentElement,
2929       /* isRemovable = */ false
2930     );
2931   }
2932 
2933   /**
2934    * Render a new annotation layer with all annotation elements.
2935    *
2936    * @param {AnnotationLayerParameters} params
2937    * @memberof AnnotationLayer
2938    */
2939   async render(params) {
2940     const { annotations } = params;
2941     const layer = this.div;
2942     setLayerDimensions(layer, this.viewport);
2943 
2944     const popupToElements = new Map();
2945     const elementParams = {
2946       data: null,
2947       layer,
2948       linkService: params.linkService,
2949       downloadManager: params.downloadManager,
2950       imageResourcesPath: params.imageResourcesPath || "",
2951       renderForms: params.renderForms !== false,
2952       svgFactory: new DOMSVGFactory(),
2953       annotationStorage: params.annotationStorage || new AnnotationStorage(),
2954       enableScripting: params.enableScripting === true,
2955       hasJSActions: params.hasJSActions,
2956       fieldObjects: params.fieldObjects,
2957       parent: this,
2958       elements: null,
2959     };
2960 
2961     for (const data of annotations) {
2962       if (data.noHTML) {
2963         continue;
2964       }
2965       const isPopupAnnotation = data.annotationType === AnnotationType.POPUP;
2966       if (!isPopupAnnotation) {
2967         const { width, height } = getRectDims(data.rect);
2968         if (width <= 0 || height <= 0) {
2969           continue; // Ignore empty annotations.
2970         }
2971       } else {
2972         const elements = popupToElements.get(data.id);
2973         if (!elements) {
2974           // Ignore popup annotations without a corresponding annotation.
2975           continue;
2976         }
2977         elementParams.elements = elements;
2978       }
2979       elementParams.data = data;
2980       const element = AnnotationElementFactory.create(elementParams);
2981 
2982       if (!element.isRenderable) {
2983         continue;
2984       }
2985 
2986       if (!isPopupAnnotation && data.popupRef) {
2987         const elements = popupToElements.get(data.popupRef);
2988         if (!elements) {
2989           popupToElements.set(data.popupRef, [element]);
2990         } else {
2991           elements.push(element);
2992         }
2993       }
2994 
2995       if (element.annotationEditorType > 0) {
2996         this.#editableAnnotations.set(element.data.id, element);
2997       }
2998 
2999       const rendered = element.render();
3000       if (data.hidden) {
3001         rendered.style.visibility = "hidden";
3002       }
3003       this.#appendElement(rendered, data.id);
3004     }
3005 
3006     this.#setAnnotationCanvasMap();
3007 
3008     await this.l10n.translate(layer);
3009   }
3010 
3011   /**
3012    * Update the annotation elements on existing annotation layer.
3013    *
3014    * @param {AnnotationLayerParameters} viewport
3015    * @memberof AnnotationLayer
3016    */
3017   update({ viewport }) {
3018     const layer = this.div;
3019     this.viewport = viewport;
3020     setLayerDimensions(layer, { rotation: viewport.rotation });
3021 
3022     this.#setAnnotationCanvasMap();
3023     layer.hidden = false;
3024   }
3025 
3026   #setAnnotationCanvasMap() {
3027     if (!this.#annotationCanvasMap) {
3028       return;
3029     }
3030     const layer = this.div;
3031     for (const [id, canvas] of this.#annotationCanvasMap) {
3032       const element = layer.querySelector(`[data-annotation-id="${id}"]`);
3033       if (!element) {
3034         continue;
3035       }
3036 
3037       const { firstChild } = element;
3038       if (!firstChild) {
3039         element.append(canvas);
3040       } else if (firstChild.nodeName === "CANVAS") {
3041         firstChild.replaceWith(canvas);
3042       } else {
3043         firstChild.before(canvas);
3044       }
3045     }
3046     this.#annotationCanvasMap.clear();
3047   }
3048 
3049   getEditableAnnotations() {
3050     return Array.from(this.#editableAnnotations.values());
3051   }
3052 
3053   getEditableAnnotation(id) {
3054     return this.#editableAnnotations.get(id);
3055   }
3056 }
3057 
3058 export {
3059   AnnotationLayer,
3060   FreeTextAnnotationElement,
3061   InkAnnotationElement,
3062   StampAnnotationElement,
3063 };
</code>

Test file:
<test_file>
File:
test/unit/annotation_spec.js
/* Copyright 2017 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import {
  Annotation,
  AnnotationBorderStyle,
  AnnotationFactory,
  getQuadPoints,
  MarkupAnnotation,
} from "../../src/core/annotation.js";
import {
  AnnotationBorderStyleType,
  AnnotationEditorType,
  AnnotationFieldFlag,
  AnnotationFlag,
  AnnotationType,
  OPS,
  RenderingIntentFlag,
  stringToBytes,
  stringToUTF8String,
} from "../../src/shared/util.js";
import {
  CMAP_URL,
  createIdFactory,
  STANDARD_FONT_DATA_URL,
  XRefMock,
} from "./test_utils.js";
import {
  DefaultCMapReaderFactory,
  DefaultStandardFontDataFactory,
} from "../../src/display/api.js";
import { Dict, Name, Ref, RefSetCache } from "../../src/core/primitives.js";
import { Lexer, Parser } from "../../src/core/parser.js";
import { PartialEvaluator } from "../../src/core/evaluator.js";
import { StringStream } from "../../src/core/stream.js";
import { WorkerTask } from "../../src/core/worker.js";
</test_file>

Your task:
You are a software tester at pdf.js.
1. Examine the existing test file. You may reuse any imports, helpers or setup blocks it already has.
2. Write exactly one javascript test `it("...", async () => {...})` block.
3. Your test must fail on the code before the patch, and pass after, hence the test will verify that the patch resolves the issue.
4. The test must be self-contained and to-the-point.
5. If you need something new use only the provided imports (respect the paths exactly how they are given) by importing dynamically for compatibility with Node.js — no new dependencies. You can use the PDF file for testing as follows:
const { getDocument } = await import('../../src/display/api.js');
const { buildGetDocumentParams } = await import('./test_utils.js');
const loadingTask = getDocument(buildGetDocumentParams('issue16800.pdf'))
6. Return only the javascript code for the new `it(...)` block (no comments or explanations).

Example structure:
it("should <describe behavior>", async () => {
  const { example } = await import("../../src/core/example.js");
  <initialize required variables>;
  <define expected variable>;
  <generate actual variables>;
  <compare expected with actual>;
});

