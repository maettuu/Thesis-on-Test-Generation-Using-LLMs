Before you begin:
- Keep going until the job is completely solved — don’t stop halfway.
- If you’re unsure about the behavior, reread the provided patch carefully; do not hallucinate.
- Plan your approach before writing code by reflecting on whether the test truly fails before and passes after.

Issue:
<issue>
[Bug]: JPEG images with CMYK-data broken when WebAssembly is disabled
### Attach (recommended) or Link to PDF file

https://github.com/mozilla/pdf.js/blob/master/test/pdfs/cmykjpeg.pdf

### Web browser and its version

N/A

### Operating system and its version

N/A

### PDF.js version

`master`, or any version after PR #19620

### Is the bug present in the latest PDF.js version?

Yes

### Is a browser extension

No

### Steps to reproduce the problem

1. Apply the following diff:
   ```diff
   diff --git a/src/display/api.js b/src/display/api.js
   index 84f7c2d83..49dfd8451 100644
   --- a/src/display/api.js
   +++ b/src/display/api.js
   @@ -327,7 +327,7 @@ function getDocument(src = {}) {
          ? NodeFilterFactory
          : DOMFilterFactory);
      const enableHWA = src.enableHWA === true;
   -  const useWasm = src.useWasm !== false;
   +  const useWasm = false; // src.useWasm !== false;

      // Parameters whose default values depend on other parameters.
      const length = rangeTransport ? rangeTransport.length : (src.length ?? NaN);
   ```
2. Open http://localhost:8888/web/viewer.html?file=/test/pdfs/cmykjpeg.pdf
3. Observe the rendering.

### What is the expected behavior?

That the image renders *close to* the rendering with WebAssembly enabled. 

![Image](https://github.com/user-attachments/assets/9c79491e-480e-4b1e-b557-711a87674afb)

### What went wrong?

The image is completely broken.

![Image](https://github.com/user-attachments/assets/c748b21d-0fac-4f48-a572-1f6aaf20cdcf)

### Link to a viewer

_No response_

### Additional context

/cc @calixteman 
</issue>

Patch:
<patch>
diff --git a/src/core/jpg.js b/src/core/jpg.js
--- a/src/core/jpg.js
+++ b/src/core/jpg.js
@@ -15,6 +15,7 @@
 
 import { assert, BaseException, warn } from "../shared/util.js";
 import { ColorSpaceUtils } from "./colorspace_utils.js";
+import { DeviceCmykCS } from "./colorspace.js";
 import { grayToRGBA } from "../shared/image_utils.js";
 import { readUint16 } from "./core_utils.js";
 
@@ -1349,6 +1350,13 @@ class JpegImage {
 
   _convertCmykToRgba(data) {
     ColorSpaceUtils.cmyk.getRgbBuffer(data, 0, data.length / 4, data, 0, 8, 1);
+
+    if (ColorSpaceUtils.cmyk instanceof DeviceCmykCS) {
+      // The alpha-component isn't updated by `DeviceCmykCS`, doing it manually.
+      for (let i = 3, ii = data.length; i < ii; i += 4) {
+        data[i] = 255;
+      }
+    }
     return data;
   }


</patch>

Imports:
<imports>
Available Packages
Dev Dependencies:
- @babel/core: ^7.26.10
- @babel/preset-env: ^7.26.9
- @babel/runtime: ^7.26.10
- @fluent/bundle: ^0.18.0
- @fluent/dom: ^0.10.0
- @metalsmith/layouts: ^3.0.0
- @metalsmith/markdown: ^1.10.0
- @napi-rs/canvas: ^0.1.68
- @types/node: ^22.13.10
- autoprefixer: ^10.4.21
- babel-loader: ^10.0.0
- caniuse-lite: ^1.0.30001704
- core-js: ^3.41.0
- eslint: ^9.22.0
- eslint-plugin-import: ^2.31.0
- eslint-plugin-jasmine: ^4.2.2
- eslint-plugin-json: ^4.0.1
- eslint-plugin-no-unsanitized: ^4.1.2
- eslint-plugin-perfectionist: ^4.10.1
- eslint-plugin-prettier: ^5.2.3
- eslint-plugin-unicorn: ^57.0.0
- globals: ^16.0.0
- gulp: ^5.0.0
- gulp-cli: ^3.0.0
- gulp-postcss: ^10.0.0
- gulp-rename: ^2.0.0
- gulp-replace: ^1.1.4
- gulp-zip: ^6.1.0
- highlight.js: ^11.11.1
- jasmine: ^5.6.0
- jsdoc: ^4.0.4
- jstransformer-nunjucks: ^1.2.0
- metalsmith: ^2.6.3
- metalsmith-html-relative: ^2.0.6
- ordered-read-streams: ^2.0.0
- pngjs: ^7.0.0
- postcss: ^8.5.3
- postcss-dark-theme-class: ^1.3.0
- postcss-dir-pseudo-class: ^9.0.1
- postcss-discard-comments: ^7.0.3
- postcss-nesting: ^13.0.1
- prettier: ^3.5.3
- puppeteer: ^24.4.0
- stylelint: ^16.16.0
- stylelint-prettier: ^5.0.3
- svglint: ^3.1.0
- terser-webpack-plugin: ^5.3.14
- tsc-alias: ^1.8.11
- ttest: ^4.0.0
- typescript: ^5.8.2
- vinyl: ^3.0.0
- webpack: ^5.98.0
- webpack-stream: ^7.0.0
- yargs: ^17.7.2

Engines:
- node: >=20

Available Relative Imports:
- `../../src/core/annotation.js`: Annotation, AnnotationBorderStyle, AnnotationFactory, MarkupAnnotation, getQuadPoints
- `../../src/core/bidi.js`: bidi
- `../../src/core/calculate_md5.js`: calculateMD5
- `../../src/core/calculate_sha256.js`: calculateSHA256
- `../../src/core/calculate_sha_other.js`: calculateSHA384, calculateSHA512
- `../../src/core/cff_parser.js`: CFFCharset, CFFCompiler, CFFFDSelect, CFFParser, CFFStrings
- `../../src/core/cmap.js`: CMap, CMapFactory, IdentityCMap
- `../../src/core/colorspace.js`: ColorSpace
- `../../src/core/colorspace_utils.js`: ColorSpaceUtils
- `../../src/core/core_utils.js`: arrayBuffersToBytes, encodeToXmlString, escapePDFName, escapeString, getInheritableProperty, getSizeInBytes, isAscii, isWhiteSpace, log2, numberToString, parseXFAPath, recoverJsURL, stringToUTF16HexString, stringToUTF16String, toRomanNumerals, validateCSSFont
- `../../src/core/crypto.js`: AES128Cipher, AES256Cipher, ARCFourCipher, CipherTransformFactory, PDF17, PDF20
- `../../src/core/default_appearance.js`: createDefaultAppearance, parseAppearanceStream, parseDefaultAppearance
- `../../src/core/document.js`: PDFDocument, Page
- `../../src/core/encodings.js`: getEncoding
- `../../src/core/evaluator.js`: PartialEvaluator
- `../../src/core/flate_stream.js`: FlateStream
- `../../src/core/font_substitutions.js`: getFontSubstitution
- `../../src/core/fonts_utils.js`: SEAC_ANALYSIS_ENABLED
- `../../src/core/function.js`: PDFFunctionFactory, PostScriptCompiler, PostScriptEvaluator
- `../../src/core/glyphlist.js`: getDingbatsGlyphsUnicode, getGlyphsUnicode
- `../../src/core/image_utils.js`: GlobalColorSpaceCache, GlobalImageCache, LocalColorSpaceCache
- `../../src/core/jbig2.js`: Jbig2Error, Jbig2Image
- `../../src/core/jpg.js`: JpegError, JpegImage
- `../../src/core/jpx.js`: JpxError, JpxImage
- `../../src/core/metadata_parser.js`: MetadataParser
- `../../src/core/operator_list.js`: OperatorList
- `../../src/core/parser.js`: Lexer, Linearization, Parser
- `../../src/core/predictor_stream.js`: PredictorStream
- `../../src/core/primitives.js`: Cmd, Dict, EOF, Name, Ref, RefSet, RefSetCache, isCmd, isDict, isName, isRefsEqual
- `../../src/core/ps_parser.js`: PostScriptLexer, PostScriptParser
- `../../src/core/stream.js`: NullStream, Stream, StringStream
- `../../src/core/type1_parser.js`: Type1Parser
- `../../src/core/unicode.js`: getCharUnicodeCategory, getUnicodeForGlyph, getUnicodeRangeFor, mapSpecialUnicodeValues
- `../../src/core/worker.js`: WorkerMessageHandler, WorkerTask
- `../../src/core/writer.js`: incrementalUpdate, writeChanges, writeDict
- `../../src/core/xfa/bind.js`: Binder
- `../../src/core/xfa/data.js`: DataHandler
- `../../src/core/xfa/factory.js`: XFAFactory
- `../../src/core/xfa/formcalc_lexer.js`: Lexer, TOKEN, Token
- `../../src/core/xfa/formcalc_parser.js`: Errors, Parser
- `../../src/core/xfa/parser.js`: XFAParser
- `../../src/core/xfa/som.js`: searchNode
- `../../src/core/xfa/symbol_utils.js`: $dump, $getChildren, $getChildrenByClass, $getChildrenByName, $text, $uid
- `../../src/core/xml_parser.js`: SimpleXMLParser, XMLParserBase
- `../../src/display/annotation_layer.js`: AnnotationLayer
- `../../src/display/annotation_storage.js`: AnnotationStorage
- `../../src/display/api.js`: LoopbackPort, PDFDataRangeTransport, PDFDocumentLoadingTask, PDFDocumentProxy, PDFPageProxy, PDFWorker, RenderTask, build, getDocument, isValidExplicitDest, version
- `../../src/display/canvas_factory.js`: DOMCanvasFactory
- `../../src/display/cmap_reader_factory.js`: DOMCMapReaderFactory
- `../../src/display/display_utils.js`: OutputScale, PDFDateString, PageViewport, PixelsPerInch, RenderingCancelledException, StatTimer, SupportedImageMimeTypes, fetchData, getFilenameFromUrl, getPdfFilenameFromUrl, getXfaPageViewport, isDataScheme, isPdfFile, isValidFetchUrl, noContextMenu, setLayerDimensions, stopEvent
- `../../src/display/draw_layer.js`: DrawLayer
- `../../src/display/editor/annotation_editor_layer.js`: AnnotationEditorLayer
- `../../src/display/editor/color_picker.js`: ColorPicker
- `../../src/display/editor/drawers/signaturedraw.js`: SignatureExtractor
- `../../src/display/editor/tools.js`: AnnotationEditorUIManager, CommandManager
- `../../src/display/fetch_stream.js`: PDFFetchStream
- `../../src/display/metadata.js`: Metadata
- `../../src/display/network.js`: PDFNetworkStream
- `../../src/display/network_utils.js`: createHeaders, createResponseError, extractFilenameFromHeader, validateRangeRequestCapabilities, validateResponseStatus
- `../../src/display/node_stream.js`: PDFNodeStream
- `../../src/display/node_utils.js`: NodeCMapReaderFactory, NodeStandardFontDataFactory, fetchData
- `../../src/display/standard_fontdata_factory.js`: DOMStandardFontDataFactory
- `../../src/display/svg_factory.js`: DOMSVGFactory
- `../../src/display/text_layer.js`: TextLayer
- `../../src/display/touch_manager.js`: TouchManager
- `../../src/display/worker_options.js`: GlobalWorkerOptions
- `../../src/display/xfa_layer.js`: XfaLayer
- `../../src/shared/message_handler.js`: MessageHandler
- `../../src/shared/murmurhash3.js`: MurmurHash3_64
- `../../src/shared/util.js`: AbortException, AnnotationBorderStyleType, AnnotationEditorParamsType, AnnotationEditorType, AnnotationFieldFlag, AnnotationFlag, AnnotationMode, AnnotationType, BaseException, FeatureTest, FormatError, ImageKind, InvalidPDFException, MathClamp, OPS, PasswordException, PasswordResponses, PermissionFlag, RenderingIntentFlag, ResponseException, UnknownErrorException, Util, VerbosityLevel, assert, bytesToString, createValidAbsoluteUrl, getModificationDate, getUuid, getVerbosityLevel, isNodeJS, normalizeUnicode, objectSize, setVerbosityLevel, shadow, string32, stringToBytes, stringToPDFString, stringToUTF8String, toBase64Util
- `../../web/annotation_layer_builder.js`: AnnotationLayerBuilder
- `../../web/app_options.js`: AppOptions, OptionKind
- `../../web/autolinker.js`: Autolinker
- `../../web/download_manager.js`: DownloadManager
- `../../web/event_utils.js`: EventBus, WaitOnType, waitOnEventOrTimeout
- `../../web/genericl10n.js`: GenericL10n
- `../../web/pdf_find_controller.js`: FindState, PDFFindController
- `../../web/pdf_find_utils.js`: CharacterType, getCharacterType
- `../../web/pdf_history.js`: PDFHistory, isDestArraysEqual, isDestHashesEqual
- `../../web/pdf_link_service.js`: LinkTarget, PDFLinkService, SimpleLinkService
- `../../web/pdf_page_view.js`: PDFPageView
- `../../web/pdf_scripting_manager.component.js`: PDFScriptingManager
- `../../web/pdf_single_page_viewer.js`: PDFSinglePageViewer
- `../../web/pdf_viewer.js`: PDFPageViewBuffer, PDFViewer
- `../../web/struct_tree_layer_builder.js`: StructTreeLayerBuilder
- `../../web/text_layer_builder.js`: TextLayerBuilder
- `../../web/ui_utils.js`: AutoPrintRegExp, ProgressBar, RenderingStates, ScrollMode, SpreadMode, backtrackBeforeAllVisibleElements, binarySearchFirstItem, calcRound, getPageSizeInches, getVisibleElements, isPortraitOrientation, isValidRotation, parseQueryString, removeNullCharacters
- `../../web/xfa_layer_builder.js`: XfaLayerBuilder
- `../reporter.js`: TestReporter
- `./common_pdfstream_tests.js`: testCrossOriginRedirects
- `./test_utils.js`: CMAP_URL, DefaultCMapReaderFactory, DefaultFileReaderFactory, DefaultStandardFontDataFactory, STANDARD_FONT_DATA_URL, TEST_PDFS_PATH, TestPdfsServer, XRefMock, buildGetDocumentParams, createIdFactory, getCrossOriginHostname
</imports>

Code:
<code>
File:
src/core/jpg.js
1 /* Copyright 2014 Mozilla Foundation
2  *
3  * Licensed under the Apache License, Version 2.0 (the 'License');
4  * you may not use this file except in compliance with the License.
5  * You may obtain a copy of the License at
6  *
7  *     http://www.apache.org/licenses/LICENSE-2.0
8  *
9  * Unless required by applicable law or agreed to in writing, software
10  * distributed under the License is distributed on an 'AS IS' BASIS,
11  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
12  * See the License for the specific language governing permissions and
13  * limitations under the License.
14  */
15 
16 import { assert, BaseException, warn } from "../shared/util.js";
17 import { ColorSpaceUtils } from "./colorspace_utils.js";
18 import { grayToRGBA } from "../shared/image_utils.js";
19 import { readUint16 } from "./core_utils.js";
20 
21 class JpegError extends BaseException {
22   constructor(msg) {
23     super(msg, "JpegError");
24   }
25 }
26 
27 class DNLMarkerError extends BaseException {
28   constructor(message, scanLines) {
29     super(message, "DNLMarkerError");
30     this.scanLines = scanLines;
31   }
32 }
33 
34 class EOIMarkerError extends BaseException {
35   constructor(msg) {
36     super(msg, "EOIMarkerError");
37   }
38 }
39 
40 /**
41  * This code was forked from https://github.com/notmasteryet/jpgjs.
42  * The original version was created by GitHub user notmasteryet.
43  *
44  * - The JPEG specification can be found in the ITU CCITT Recommendation T.81
45  *   (www.w3.org/Graphics/JPEG/itu-t81.pdf)
46  * - The JFIF specification can be found in the JPEG File Interchange Format
47  *   (www.w3.org/Graphics/JPEG/jfif3.pdf)
48  * - The Adobe Application-Specific JPEG markers in the
49  *   Supporting the DCT Filters in PostScript Level 2, Technical Note #5116
50  *   (partners.adobe.com/public/developer/en/ps/sdk/5116.DCT_Filter.pdf)
51  */
52 
53 // prettier-ignore
54 const dctZigZag = new Uint8Array([
55    0,
56    1,  8,
57   16,  9,  2,
58    3, 10, 17, 24,
59   32, 25, 18, 11, 4,
60    5, 12, 19, 26, 33, 40,
61   48, 41, 34, 27, 20, 13,  6,
62    7, 14, 21, 28, 35, 42, 49, 56,
63   57, 50, 43, 36, 29, 22, 15,
64   23, 30, 37, 44, 51, 58,
65   59, 52, 45, 38, 31,
66   39, 46, 53, 60,
67   61, 54, 47,
68   55, 62,
69   63
70 ]);
71 
72 const dctCos1 = 4017; // cos(pi/16)
73 const dctSin1 = 799; // sin(pi/16)
74 const dctCos3 = 3406; // cos(3*pi/16)
75 const dctSin3 = 2276; // sin(3*pi/16)
76 const dctCos6 = 1567; // cos(6*pi/16)
77 const dctSin6 = 3784; // sin(6*pi/16)
78 const dctSqrt2 = 5793; // sqrt(2)
79 const dctSqrt1d2 = 2896; // sqrt(2) / 2
80 
81 function buildHuffmanTable(codeLengths, values) {
82   let k = 0,
83     i,
84     j,
85     length = 16;
86   while (length > 0 && !codeLengths[length - 1]) {
87     length--;
88   }
89   const code = [{ children: [], index: 0 }];
90   let p = code[0],
91     q;
92   for (i = 0; i < length; i++) {
93     for (j = 0; j < codeLengths[i]; j++) {
94       p = code.pop();
95       p.children[p.index] = values[k];
96       while (p.index > 0) {
97         p = code.pop();
98       }
99       p.index++;
100       code.push(p);
101       while (code.length <= i) {
102         code.push((q = { children: [], index: 0 }));
103         p.children[p.index] = q.children;
104         p = q;
105       }
106       k++;
107     }
108     if (i + 1 < length) {
109       // p here points to last code
110       code.push((q = { children: [], index: 0 }));
111       p.children[p.index] = q.children;
112       p = q;
113     }
114   }
115   return code[0].children;
116 }
117 
118 function getBlockBufferOffset(component, row, col) {
119   return 64 * ((component.blocksPerLine + 1) * row + col);
120 }
121 
122 function decodeScan(
123   data,
124   offset,
125   frame,
126   components,
127   resetInterval,
128   spectralStart,
129   spectralEnd,
130   successivePrev,
131   successive,
132   parseDNLMarker = false
133 ) {
134   const mcusPerLine = frame.mcusPerLine;
135   const progressive = frame.progressive;
136 
137   const startOffset = offset;
138   let bitsData = 0,
139     bitsCount = 0;
140 
141   function readBit() {
142     if (bitsCount > 0) {
143       bitsCount--;
144       return (bitsData >> bitsCount) & 1;
145     }
146     bitsData = data[offset++];
147     if (bitsData === 0xff) {
148       const nextByte = data[offset++];
149       if (nextByte) {
150         if (nextByte === /* DNL = */ 0xdc && parseDNLMarker) {
151           offset += 2; // Skip marker length.
152 
153           const scanLines = readUint16(data, offset);
154           offset += 2;
155           if (scanLines > 0 && scanLines !== frame.scanLines) {
156             throw new DNLMarkerError(
157               "Found DNL marker (0xFFDC) while parsing scan data",
158               scanLines
159             );
160           }
161         } else if (nextByte === /* EOI = */ 0xd9) {
162           if (parseDNLMarker) {
163             // NOTE: only 8-bit JPEG images are supported in this decoder.
164             const maybeScanLines = blockRow * (frame.precision === 8 ? 8 : 0);
165             // Heuristic to attempt to handle corrupt JPEG images with too
166             // large `scanLines` parameter, by falling back to the currently
167             // parsed number of scanLines when it's at least (approximately)
168             // one "half" order of magnitude smaller than expected (fixes
169             // issue10880.pdf, issue10989.pdf, issue15492.pdf).
170             if (
171               maybeScanLines > 0 &&
172               Math.round(frame.scanLines / maybeScanLines) >= 5
173             ) {
174               throw new DNLMarkerError(
175                 "Found EOI marker (0xFFD9) while parsing scan data, " +
176                   "possibly caused by incorrect `scanLines` parameter",
177                 maybeScanLines
178               );
179             }
180           }
181           throw new EOIMarkerError(
182             "Found EOI marker (0xFFD9) while parsing scan data"
183           );
184         }
185         throw new JpegError(
186           `unexpected marker ${((bitsData << 8) | nextByte).toString(16)}`
187         );
188       }
189       // unstuff 0
190     }
191     bitsCount = 7;
192     return bitsData >>> 7;
193   }
194 
195   function decodeHuffman(tree) {
196     let node = tree;
197     while (true) {
198       node = node[readBit()];
199       switch (typeof node) {
200         case "number":
201           return node;
202         case "object":
203           continue;
204       }
205       throw new JpegError("invalid huffman sequence");
206     }
207   }
208 
209   function receive(length) {
210     let n = 0;
211     while (length > 0) {
212       n = (n << 1) | readBit();
213       length--;
214     }
215     return n;
216   }
217 
218   function receiveAndExtend(length) {
219     if (length === 1) {
220       return readBit() === 1 ? 1 : -1;
221     }
222     const n = receive(length);
223     if (n >= 1 << (length - 1)) {
224       return n;
225     }
226     return n + (-1 << length) + 1;
227   }
228 
229   function decodeBaseline(component, blockOffset) {
230     const t = decodeHuffman(component.huffmanTableDC);
231     const diff = t === 0 ? 0 : receiveAndExtend(t);
232     component.blockData[blockOffset] = component.pred += diff;
233     let k = 1;
234     while (k < 64) {
235       const rs = decodeHuffman(component.huffmanTableAC);
236       const s = rs & 15,
237         r = rs >> 4;
238       if (s === 0) {
239         if (r < 15) {
240           break;
241         }
242         k += 16;
243         continue;
244       }
245       k += r;
246       const z = dctZigZag[k];
247       component.blockData[blockOffset + z] = receiveAndExtend(s);
248       k++;
249     }
250   }
251 
252   function decodeDCFirst(component, blockOffset) {
253     const t = decodeHuffman(component.huffmanTableDC);
254     const diff = t === 0 ? 0 : receiveAndExtend(t) << successive;
255     component.blockData[blockOffset] = component.pred += diff;
256   }
257 
258   function decodeDCSuccessive(component, blockOffset) {
259     component.blockData[blockOffset] |= readBit() << successive;
260   }
261 
262   let eobrun = 0;
263   function decodeACFirst(component, blockOffset) {
264     if (eobrun > 0) {
265       eobrun--;
266       return;
267     }
268     let k = spectralStart;
269     const e = spectralEnd;
270     while (k <= e) {
271       const rs = decodeHuffman(component.huffmanTableAC);
272       const s = rs & 15,
273         r = rs >> 4;
274       if (s === 0) {
275         if (r < 15) {
276           eobrun = receive(r) + (1 << r) - 1;
277           break;
278         }
279         k += 16;
280         continue;
281       }
282       k += r;
283       const z = dctZigZag[k];
284       component.blockData[blockOffset + z] =
285         receiveAndExtend(s) * (1 << successive);
286       k++;
287     }
288   }
289 
290   let successiveACState = 0,
291     successiveACNextValue;
292   function decodeACSuccessive(component, blockOffset) {
293     let k = spectralStart;
294     const e = spectralEnd;
295     let r = 0;
296     let s;
297     let rs;
298     while (k <= e) {
299       const offsetZ = blockOffset + dctZigZag[k];
300       const sign = component.blockData[offsetZ] < 0 ? -1 : 1;
301       switch (successiveACState) {
302         case 0: // initial state
303           rs = decodeHuffman(component.huffmanTableAC);
304           s = rs & 15;
305           r = rs >> 4;
306           if (s === 0) {
307             if (r < 15) {
308               eobrun = receive(r) + (1 << r);
309               successiveACState = 4;
310             } else {
311               r = 16;
312               successiveACState = 1;
313             }
314           } else {
315             if (s !== 1) {
316               throw new JpegError("invalid ACn encoding");
317             }
318             successiveACNextValue = receiveAndExtend(s);
319             successiveACState = r ? 2 : 3;
320           }
321           continue;
322         case 1: // skipping r zero items
323         case 2:
324           if (component.blockData[offsetZ]) {
325             component.blockData[offsetZ] += sign * (readBit() << successive);
326           } else {
327             r--;
328             if (r === 0) {
329               successiveACState = successiveACState === 2 ? 3 : 0;
330             }
331           }
332           break;
333         case 3: // set value for a zero item
334           if (component.blockData[offsetZ]) {
335             component.blockData[offsetZ] += sign * (readBit() << successive);
336           } else {
337             component.blockData[offsetZ] = successiveACNextValue << successive;
338             successiveACState = 0;
339           }
340           break;
341         case 4: // eob
342           if (component.blockData[offsetZ]) {
343             component.blockData[offsetZ] += sign * (readBit() << successive);
344           }
345           break;
346       }
347       k++;
348     }
349     if (successiveACState === 4) {
350       eobrun--;
351       if (eobrun === 0) {
352         successiveACState = 0;
353       }
354     }
355   }
356 
357   let blockRow = 0;
358   function decodeMcu(component, decode, mcu, row, col) {
359     const mcuRow = (mcu / mcusPerLine) | 0;
360     const mcuCol = mcu % mcusPerLine;
361     blockRow = mcuRow * component.v + row;
362     const blockCol = mcuCol * component.h + col;
363     const blockOffset = getBlockBufferOffset(component, blockRow, blockCol);
364     decode(component, blockOffset);
365   }
366 
367   function decodeBlock(component, decode, mcu) {
368     blockRow = (mcu / component.blocksPerLine) | 0;
369     const blockCol = mcu % component.blocksPerLine;
370     const blockOffset = getBlockBufferOffset(component, blockRow, blockCol);
371     decode(component, blockOffset);
372   }
373 
374   const componentsLength = components.length;
375   let component, i, j, k, n;
376   let decodeFn;
377   if (progressive) {
378     if (spectralStart === 0) {
379       decodeFn = successivePrev === 0 ? decodeDCFirst : decodeDCSuccessive;
380     } else {
381       decodeFn = successivePrev === 0 ? decodeACFirst : decodeACSuccessive;
382     }
383   } else {
384     decodeFn = decodeBaseline;
385   }
386 
387   let mcu = 0,
388     fileMarker;
389   const mcuExpected =
390     componentsLength === 1
391       ? components[0].blocksPerLine * components[0].blocksPerColumn
392       : mcusPerLine * frame.mcusPerColumn;
393 
394   let h, v;
395   while (mcu <= mcuExpected) {
396     // reset interval stuff
397     const mcuToRead = resetInterval
398       ? Math.min(mcuExpected - mcu, resetInterval)
399       : mcuExpected;
400 
401     // The `mcuToRead === 0` case should only occur when all of the expected
402     // MCU data has been already parsed, i.e. when `mcu === mcuExpected`, but
403     // some corrupt JPEG images contain more data than intended and we thus
404     // want to skip over any extra RSTx markers below (fixes issue11794.pdf).
405     if (mcuToRead > 0) {
406       for (i = 0; i < componentsLength; i++) {
407         components[i].pred = 0;
408       }
409       eobrun = 0;
410 
411       if (componentsLength === 1) {
412         component = components[0];
413         for (n = 0; n < mcuToRead; n++) {
414           decodeBlock(component, decodeFn, mcu);
415           mcu++;
416         }
417       } else {
418         for (n = 0; n < mcuToRead; n++) {
419           for (i = 0; i < componentsLength; i++) {
420             component = components[i];
421             h = component.h;
422             v = component.v;
423             for (j = 0; j < v; j++) {
424               for (k = 0; k < h; k++) {
425                 decodeMcu(component, decodeFn, mcu, j, k);
426               }
427             }
428           }
429           mcu++;
430         }
431       }
432     }
433 
434     // find marker
435     bitsCount = 0;
436     fileMarker = findNextFileMarker(data, offset);
437     if (!fileMarker) {
438       break; // Reached the end of the image data without finding any marker.
439     }
440     if (fileMarker.invalid) {
441       // Some bad images seem to pad Scan blocks with e.g. zero bytes, skip
442       // past those to attempt to find a valid marker (fixes issue4090.pdf).
443       const partialMsg = mcuToRead > 0 ? "unexpected" : "excessive";
444       warn(
445         `decodeScan - ${partialMsg} MCU data, current marker is: ${fileMarker.invalid}`
446       );
447       offset = fileMarker.offset;
448     }
449     if (fileMarker.marker >= 0xffd0 && fileMarker.marker <= 0xffd7) {
450       // RSTx
451       offset += 2;
452     } else {
453       break;
454     }
455   }
456 
457   return offset - startOffset;
458 }
459 
460 // A port of poppler's IDCT method which in turn is taken from:
461 //   Christoph Loeffler, Adriaan Ligtenberg, George S. Moschytz,
462 //   'Practical Fast 1-D DCT Algorithms with 11 Multiplications',
463 //   IEEE Intl. Conf. on Acoustics, Speech & Signal Processing, 1989,
464 //   988-991.
465 function quantizeAndInverse(component, blockBufferOffset, p) {
466   const qt = component.quantizationTable,
467     blockData = component.blockData;
468   let v0, v1, v2, v3, v4, v5, v6, v7;
469   let p0, p1, p2, p3, p4, p5, p6, p7;
470   let t;
471 
472   if (!qt) {
473     throw new JpegError("missing required Quantization Table.");
474   }
475 
476   // inverse DCT on rows
477   for (let row = 0; row < 64; row += 8) {
478     // gather block data
479     p0 = blockData[blockBufferOffset + row];
480     p1 = blockData[blockBufferOffset + row + 1];
481     p2 = blockData[blockBufferOffset + row + 2];
482     p3 = blockData[blockBufferOffset + row + 3];
483     p4 = blockData[blockBufferOffset + row + 4];
484     p5 = blockData[blockBufferOffset + row + 5];
485     p6 = blockData[blockBufferOffset + row + 6];
486     p7 = blockData[blockBufferOffset + row + 7];
487 
488     // dequant p0
489     p0 *= qt[row];
490 
491     // check for all-zero AC coefficients
492     if ((p1 | p2 | p3 | p4 | p5 | p6 | p7) === 0) {
493       t = (dctSqrt2 * p0 + 512) >> 10;
494       p[row] = t;
495       p[row + 1] = t;
496       p[row + 2] = t;
497       p[row + 3] = t;
498       p[row + 4] = t;
499       p[row + 5] = t;
500       p[row + 6] = t;
501       p[row + 7] = t;
502       continue;
503     }
504     // dequant p1 ... p7
505     p1 *= qt[row + 1];
506     p2 *= qt[row + 2];
507     p3 *= qt[row + 3];
508     p4 *= qt[row + 4];
509     p5 *= qt[row + 5];
510     p6 *= qt[row + 6];
511     p7 *= qt[row + 7];
512 
513     // stage 4
514     v0 = (dctSqrt2 * p0 + 128) >> 8;
515     v1 = (dctSqrt2 * p4 + 128) >> 8;
516     v2 = p2;
517     v3 = p6;
518     v4 = (dctSqrt1d2 * (p1 - p7) + 128) >> 8;
519     v7 = (dctSqrt1d2 * (p1 + p7) + 128) >> 8;
520     v5 = p3 << 4;
521     v6 = p5 << 4;
522 
523     // stage 3
524     v0 = (v0 + v1 + 1) >> 1;
525     v1 = v0 - v1;
526     t = (v2 * dctSin6 + v3 * dctCos6 + 128) >> 8;
527     v2 = (v2 * dctCos6 - v3 * dctSin6 + 128) >> 8;
528     v3 = t;
529     v4 = (v4 + v6 + 1) >> 1;
530     v6 = v4 - v6;
531     v7 = (v7 + v5 + 1) >> 1;
532     v5 = v7 - v5;
533 
534     // stage 2
535     v0 = (v0 + v3 + 1) >> 1;
536     v3 = v0 - v3;
537     v1 = (v1 + v2 + 1) >> 1;
538     v2 = v1 - v2;
539     t = (v4 * dctSin3 + v7 * dctCos3 + 2048) >> 12;
540     v4 = (v4 * dctCos3 - v7 * dctSin3 + 2048) >> 12;
541     v7 = t;
542     t = (v5 * dctSin1 + v6 * dctCos1 + 2048) >> 12;
543     v5 = (v5 * dctCos1 - v6 * dctSin1 + 2048) >> 12;
544     v6 = t;
545 
546     // stage 1
547     p[row] = v0 + v7;
548     p[row + 7] = v0 - v7;
549     p[row + 1] = v1 + v6;
550     p[row + 6] = v1 - v6;
551     p[row + 2] = v2 + v5;
552     p[row + 5] = v2 - v5;
553     p[row + 3] = v3 + v4;
554     p[row + 4] = v3 - v4;
555   }
556 
557   // inverse DCT on columns
558   for (let col = 0; col < 8; ++col) {
559     p0 = p[col];
560     p1 = p[col + 8];
561     p2 = p[col + 16];
562     p3 = p[col + 24];
563     p4 = p[col + 32];
564     p5 = p[col + 40];
565     p6 = p[col + 48];
566     p7 = p[col + 56];
567 
568     // check for all-zero AC coefficients
569     if ((p1 | p2 | p3 | p4 | p5 | p6 | p7) === 0) {
570       t = (dctSqrt2 * p0 + 8192) >> 14;
571       // Convert to 8-bit.
572       if (t < -2040) {
573         t = 0;
574       } else if (t >= 2024) {
575         t = 255;
576       } else {
577         t = (t + 2056) >> 4;
578       }
579       blockData[blockBufferOffset + col] = t;
580       blockData[blockBufferOffset + col + 8] = t;
581       blockData[blockBufferOffset + col + 16] = t;
582       blockData[blockBufferOffset + col + 24] = t;
583       blockData[blockBufferOffset + col + 32] = t;
584       blockData[blockBufferOffset + col + 40] = t;
585       blockData[blockBufferOffset + col + 48] = t;
586       blockData[blockBufferOffset + col + 56] = t;
587       continue;
588     }
589 
590     // stage 4
591     v0 = (dctSqrt2 * p0 + 2048) >> 12;
592     v1 = (dctSqrt2 * p4 + 2048) >> 12;
593     v2 = p2;
594     v3 = p6;
595     v4 = (dctSqrt1d2 * (p1 - p7) + 2048) >> 12;
596     v7 = (dctSqrt1d2 * (p1 + p7) + 2048) >> 12;
597     v5 = p3;
598     v6 = p5;
599 
600     // stage 3
601     // Shift v0 by 128.5 << 5 here, so we don't need to shift p0...p7 when
602     // converting to UInt8 range later.
603     v0 = ((v0 + v1 + 1) >> 1) + 4112;
604     v1 = v0 - v1;
605     t = (v2 * dctSin6 + v3 * dctCos6 + 2048) >> 12;
606     v2 = (v2 * dctCos6 - v3 * dctSin6 + 2048) >> 12;
607     v3 = t;
608     v4 = (v4 + v6 + 1) >> 1;
609     v6 = v4 - v6;
610     v7 = (v7 + v5 + 1) >> 1;
611     v5 = v7 - v5;
612 
613     // stage 2
614     v0 = (v0 + v3 + 1) >> 1;
615     v3 = v0 - v3;
616     v1 = (v1 + v2 + 1) >> 1;
617     v2 = v1 - v2;
618     t = (v4 * dctSin3 + v7 * dctCos3 + 2048) >> 12;
619     v4 = (v4 * dctCos3 - v7 * dctSin3 + 2048) >> 12;
620     v7 = t;
621     t = (v5 * dctSin1 + v6 * dctCos1 + 2048) >> 12;
622     v5 = (v5 * dctCos1 - v6 * dctSin1 + 2048) >> 12;
623     v6 = t;
624 
625     // stage 1
626     p0 = v0 + v7;
627     p7 = v0 - v7;
628     p1 = v1 + v6;
629     p6 = v1 - v6;
630     p2 = v2 + v5;
631     p5 = v2 - v5;
632     p3 = v3 + v4;
633     p4 = v3 - v4;
634 
635     // Convert to 8-bit integers.
636     if (p0 < 16) {
637       p0 = 0;
638     } else if (p0 >= 4080) {
639       p0 = 255;
640     } else {
641       p0 >>= 4;
642     }
643     if (p1 < 16) {
644       p1 = 0;
645     } else if (p1 >= 4080) {
646       p1 = 255;
647     } else {
648       p1 >>= 4;
649     }
650     if (p2 < 16) {
651       p2 = 0;
652     } else if (p2 >= 4080) {
653       p2 = 255;
654     } else {
655       p2 >>= 4;
656     }
657     if (p3 < 16) {
658       p3 = 0;
659     } else if (p3 >= 4080) {
660       p3 = 255;
661     } else {
662       p3 >>= 4;
663     }
664     if (p4 < 16) {
665       p4 = 0;
666     } else if (p4 >= 4080) {
667       p4 = 255;
668     } else {
669       p4 >>= 4;
670     }
671     if (p5 < 16) {
672       p5 = 0;
673     } else if (p5 >= 4080) {
674       p5 = 255;
675     } else {
676       p5 >>= 4;
677     }
678     if (p6 < 16) {
679       p6 = 0;
680     } else if (p6 >= 4080) {
681       p6 = 255;
682     } else {
683       p6 >>= 4;
684     }
685     if (p7 < 16) {
686       p7 = 0;
687     } else if (p7 >= 4080) {
688       p7 = 255;
689     } else {
690       p7 >>= 4;
691     }
692 
693     // store block data
694     blockData[blockBufferOffset + col] = p0;
695     blockData[blockBufferOffset + col + 8] = p1;
696     blockData[blockBufferOffset + col + 16] = p2;
697     blockData[blockBufferOffset + col + 24] = p3;
698     blockData[blockBufferOffset + col + 32] = p4;
699     blockData[blockBufferOffset + col + 40] = p5;
700     blockData[blockBufferOffset + col + 48] = p6;
701     blockData[blockBufferOffset + col + 56] = p7;
702   }
703 }
704 
705 function buildComponentData(frame, component) {
706   const blocksPerLine = component.blocksPerLine;
707   const blocksPerColumn = component.blocksPerColumn;
708   const computationBuffer = new Int16Array(64);
709 
710   for (let blockRow = 0; blockRow < blocksPerColumn; blockRow++) {
711     for (let blockCol = 0; blockCol < blocksPerLine; blockCol++) {
712       const offset = getBlockBufferOffset(component, blockRow, blockCol);
713       quantizeAndInverse(component, offset, computationBuffer);
714     }
715   }
716   return component.blockData;
717 }
718 
719 function findNextFileMarker(data, currentPos, startPos = currentPos) {
720   const maxPos = data.length - 1;
721   let newPos = startPos < currentPos ? startPos : currentPos;
722 
723   if (currentPos >= maxPos) {
724     return null; // Don't attempt to read non-existent data and just return.
725   }
726   const currentMarker = readUint16(data, currentPos);
727   if (currentMarker >= 0xffc0 && currentMarker <= 0xfffe) {
728     return {
729       invalid: null,
730       marker: currentMarker,
731       offset: currentPos,
732     };
733   }
734   let newMarker = readUint16(data, newPos);
735   while (!(newMarker >= 0xffc0 && newMarker <= 0xfffe)) {
736     if (++newPos >= maxPos) {
737       return null; // Don't attempt to read non-existent data and just return.
738     }
739     newMarker = readUint16(data, newPos);
740   }
741   return {
742     invalid: currentMarker.toString(16),
743     marker: newMarker,
744     offset: newPos,
745   };
746 }
747 
748 function prepareComponents(frame) {
749   const mcusPerLine = Math.ceil(frame.samplesPerLine / 8 / frame.maxH);
750   const mcusPerColumn = Math.ceil(frame.scanLines / 8 / frame.maxV);
751   for (const component of frame.components) {
752     const blocksPerLine = Math.ceil(
753       (Math.ceil(frame.samplesPerLine / 8) * component.h) / frame.maxH
754     );
755     const blocksPerColumn = Math.ceil(
756       (Math.ceil(frame.scanLines / 8) * component.v) / frame.maxV
757     );
758     const blocksPerLineForMcu = mcusPerLine * component.h;
759     const blocksPerColumnForMcu = mcusPerColumn * component.v;
760 
761     const blocksBufferSize =
762       64 * blocksPerColumnForMcu * (blocksPerLineForMcu + 1);
763     component.blockData = new Int16Array(blocksBufferSize);
764     component.blocksPerLine = blocksPerLine;
765     component.blocksPerColumn = blocksPerColumn;
766   }
767   frame.mcusPerLine = mcusPerLine;
768   frame.mcusPerColumn = mcusPerColumn;
769 }
770 
771 function readDataBlock(data, offset) {
772   const length = readUint16(data, offset);
773   offset += 2;
774   let endOffset = offset + length - 2;
775 
776   const fileMarker = findNextFileMarker(data, endOffset, offset);
777   if (fileMarker?.invalid) {
778     warn(
779       "readDataBlock - incorrect length, current marker is: " +
780         fileMarker.invalid
781     );
782     endOffset = fileMarker.offset;
783   }
784 
785   const array = data.subarray(offset, endOffset);
786   return {
787     appData: array,
788     oldOffset: offset,
789     newOffset: offset + array.length,
790   };
791 }
792 
793 function skipData(data, offset) {
794   const length = readUint16(data, offset);
795   offset += 2;
796   const endOffset = offset + length - 2;
797 
798   const fileMarker = findNextFileMarker(data, endOffset, offset);
799   if (fileMarker?.invalid) {
800     return fileMarker.offset;
801   }
802   return endOffset;
803 }
804 
805 class JpegImage {
806   constructor({ decodeTransform = null, colorTransform = -1 } = {}) {
807     this._decodeTransform = decodeTransform;
808     this._colorTransform = colorTransform;
809   }
810 
811   static canUseImageDecoder(data, colorTransform = -1) {
812     let exifOffsets = null;
813     let offset = 0;
814     let numComponents = null;
815     let fileMarker = readUint16(data, offset);
816     offset += 2;
817     if (fileMarker !== /* SOI (Start of Image) = */ 0xffd8) {
818       throw new JpegError("SOI not found");
819     }
820     fileMarker = readUint16(data, offset);
821     offset += 2;
822 
823     markerLoop: while (fileMarker !== /* EOI (End of Image) = */ 0xffd9) {
824       switch (fileMarker) {
825         case 0xffe1: // APP1 - Exif
826           // TODO: Remove this once https://github.com/w3c/webcodecs/issues/870
827           //       is fixed.
828           const { appData, oldOffset, newOffset } = readDataBlock(data, offset);
829           offset = newOffset;
830 
831           // 'Exif\x00\x00'
832           if (
833             appData[0] === 0x45 &&
834             appData[1] === 0x78 &&
835             appData[2] === 0x69 &&
836             appData[3] === 0x66 &&
837             appData[4] === 0 &&
838             appData[5] === 0
839           ) {
840             if (exifOffsets) {
841               throw new JpegError("Duplicate EXIF-blocks found.");
842             }
843             // Don't do the EXIF-block replacement here, see `JpegStream`,
844             // since that can modify the original PDF document.
845             exifOffsets = { exifStart: oldOffset + 6, exifEnd: newOffset };
846           }
847           fileMarker = readUint16(data, offset);
848           offset += 2;
849           continue;
850         case 0xffc0: // SOF0 (Start of Frame, Baseline DCT)
851         case 0xffc1: // SOF1 (Start of Frame, Extended DCT)
852         case 0xffc2: // SOF2 (Start of Frame, Progressive DCT)
853           // Skip marker length.
854           // Skip precision.
855           // Skip scanLines.
856           // Skip samplesPerLine.
857           numComponents = data[offset + (2 + 1 + 2 + 2)];
858           break markerLoop;
859         case 0xffff: // Fill bytes
860           if (data[offset] !== 0xff) {
861             // Avoid skipping a valid marker.
862             offset--;
863           }
864           break;
865       }
866       offset = skipData(data, offset);
867       fileMarker = readUint16(data, offset);
868       offset += 2;
869     }
870     if (numComponents === 4) {
871       return null;
872     }
873     if (numComponents === 3 && colorTransform === 0) {
874       return null;
875     }
876     return exifOffsets || {};
877   }
878 
879   parse(data, { dnlScanLines = null } = {}) {
880     let offset = 0;
881     let jfif = null;
882     let adobe = null;
883     let frame, resetInterval;
884     let numSOSMarkers = 0;
885     const quantizationTables = [];
886     const huffmanTablesAC = [],
887       huffmanTablesDC = [];
888 
889     let fileMarker = readUint16(data, offset);
890     offset += 2;
891     if (fileMarker !== /* SOI (Start of Image) = */ 0xffd8) {
892       throw new JpegError("SOI not found");
893     }
894     fileMarker = readUint16(data, offset);
895     offset += 2;
896 
897     markerLoop: while (fileMarker !== /* EOI (End of Image) = */ 0xffd9) {
898       let i, j, l;
899       switch (fileMarker) {
900         case 0xffe0: // APP0 (Application Specific)
901         case 0xffe1: // APP1
902         case 0xffe2: // APP2
903         case 0xffe3: // APP3
904         case 0xffe4: // APP4
905         case 0xffe5: // APP5
906         case 0xffe6: // APP6
907         case 0xffe7: // APP7
908         case 0xffe8: // APP8
909         case 0xffe9: // APP9
910         case 0xffea: // APP10
911         case 0xffeb: // APP11
912         case 0xffec: // APP12
913         case 0xffed: // APP13
914         case 0xffee: // APP14
915         case 0xffef: // APP15
916         case 0xfffe: // COM (Comment)
917           const { appData, newOffset } = readDataBlock(data, offset);
918           offset = newOffset;
919 
920           if (fileMarker === 0xffe0) {
921             // 'JFIF\x00'
922             if (
923               appData[0] === 0x4a &&
924               appData[1] === 0x46 &&
925               appData[2] === 0x49 &&
926               appData[3] === 0x46 &&
927               appData[4] === 0
928             ) {
929               jfif = {
930                 version: { major: appData[5], minor: appData[6] },
931                 densityUnits: appData[7],
932                 xDensity: (appData[8] << 8) | appData[9],
933                 yDensity: (appData[10] << 8) | appData[11],
934                 thumbWidth: appData[12],
935                 thumbHeight: appData[13],
936                 thumbData: appData.subarray(
937                   14,
938                   14 + 3 * appData[12] * appData[13]
939                 ),
940               };
941             }
942           }
943           // TODO APP1 - Exif
944           if (fileMarker === 0xffee) {
945             // 'Adobe'
946             if (
947               appData[0] === 0x41 &&
948               appData[1] === 0x64 &&
949               appData[2] === 0x6f &&
950               appData[3] === 0x62 &&
951               appData[4] === 0x65
952             ) {
953               adobe = {
954                 version: (appData[5] << 8) | appData[6],
955                 flags0: (appData[7] << 8) | appData[8],
956                 flags1: (appData[9] << 8) | appData[10],
957                 transformCode: appData[11],
958               };
959             }
960           }
961           break;
962 
963         case 0xffdb: // DQT (Define Quantization Tables)
964           const quantizationTablesLength = readUint16(data, offset);
965           offset += 2;
966           const quantizationTablesEnd = quantizationTablesLength + offset - 2;
967           let z;
968           while (offset < quantizationTablesEnd) {
969             const quantizationTableSpec = data[offset++];
970             const tableData = new Uint16Array(64);
971             if (quantizationTableSpec >> 4 === 0) {
972               // 8 bit values
973               for (j = 0; j < 64; j++) {
974                 z = dctZigZag[j];
975                 tableData[z] = data[offset++];
976               }
977             } else if (quantizationTableSpec >> 4 === 1) {
978               // 16 bit values
979               for (j = 0; j < 64; j++) {
980                 z = dctZigZag[j];
981                 tableData[z] = readUint16(data, offset);
982                 offset += 2;
983               }
984             } else {
985               throw new JpegError("DQT - invalid table spec");
986             }
987             quantizationTables[quantizationTableSpec & 15] = tableData;
988           }
989           break;
990 
991         case 0xffc0: // SOF0 (Start of Frame, Baseline DCT)
992         case 0xffc1: // SOF1 (Start of Frame, Extended DCT)
993         case 0xffc2: // SOF2 (Start of Frame, Progressive DCT)
994           if (frame) {
995             throw new JpegError("Only single frame JPEGs supported");
996           }
997           offset += 2; // Skip marker length.
998 
999           frame = {};
1000           frame.extended = fileMarker === 0xffc1;
1001           frame.progressive = fileMarker === 0xffc2;
1002           frame.precision = data[offset++];
1003           const sofScanLines = readUint16(data, offset);
1004           offset += 2;
1005           frame.scanLines = dnlScanLines || sofScanLines;
1006           frame.samplesPerLine = readUint16(data, offset);
1007           offset += 2;
1008           frame.components = [];
1009           frame.componentIds = {};
1010           const componentsCount = data[offset++];
1011           let maxH = 0,
1012             maxV = 0;
1013           for (i = 0; i < componentsCount; i++) {
1014             const componentId = data[offset];
1015             const h = data[offset + 1] >> 4;
1016             const v = data[offset + 1] & 15;
1017             if (maxH < h) {
1018               maxH = h;
1019             }
1020             if (maxV < v) {
1021               maxV = v;
1022             }
1023             const qId = data[offset + 2];
1024             l = frame.components.push({
1025               h,
1026               v,
1027               quantizationId: qId,
1028               quantizationTable: null, // See comment below.
1029             });
1030             frame.componentIds[componentId] = l - 1;
1031             offset += 3;
1032           }
1033           frame.maxH = maxH;
1034           frame.maxV = maxV;
1035           prepareComponents(frame);
1036           break;
1037 
1038         case 0xffc4: // DHT (Define Huffman Tables)
1039           const huffmanLength = readUint16(data, offset);
1040           offset += 2;
1041           for (i = 2; i < huffmanLength; ) {
1042             const huffmanTableSpec = data[offset++];
1043             const codeLengths = new Uint8Array(16);
1044             let codeLengthSum = 0;
1045             for (j = 0; j < 16; j++, offset++) {
1046               codeLengthSum += codeLengths[j] = data[offset];
1047             }
1048             const huffmanValues = new Uint8Array(codeLengthSum);
1049             for (j = 0; j < codeLengthSum; j++, offset++) {
1050               huffmanValues[j] = data[offset];
1051             }
1052             i += 17 + codeLengthSum;
1053 
1054             (huffmanTableSpec >> 4 === 0 ? huffmanTablesDC : huffmanTablesAC)[
1055               huffmanTableSpec & 15
1056             ] = buildHuffmanTable(codeLengths, huffmanValues);
1057           }
1058           break;
1059 
1060         case 0xffdd: // DRI (Define Restart Interval)
1061           offset += 2; // Skip marker length.
1062 
1063           resetInterval = readUint16(data, offset);
1064           offset += 2;
1065           break;
1066 
1067         case 0xffda: // SOS (Start of Scan)
1068           // A DNL marker (0xFFDC), if it exists, is only allowed at the end
1069           // of the first scan segment and may only occur once in an image.
1070           // Furthermore, to prevent an infinite loop, do *not* attempt to
1071           // parse DNL markers during re-parsing of the JPEG scan data.
1072           const parseDNLMarker = ++numSOSMarkers === 1 && !dnlScanLines;
1073 
1074           offset += 2; // Skip marker length.
1075 
1076           const selectorsCount = data[offset++],
1077             components = [];
1078           for (i = 0; i < selectorsCount; i++) {
1079             const index = data[offset++];
1080             const componentIndex = frame.componentIds[index];
1081             const component = frame.components[componentIndex];
1082             component.index = index;
1083             const tableSpec = data[offset++];
1084             component.huffmanTableDC = huffmanTablesDC[tableSpec >> 4];
1085             component.huffmanTableAC = huffmanTablesAC[tableSpec & 15];
1086             components.push(component);
1087           }
1088           const spectralStart = data[offset++],
1089             spectralEnd = data[offset++],
1090             successiveApproximation = data[offset++];
1091           try {
1092             const processed = decodeScan(
1093               data,
1094               offset,
1095               frame,
1096               components,
1097               resetInterval,
1098               spectralStart,
1099               spectralEnd,
1100               successiveApproximation >> 4,
1101               successiveApproximation & 15,
1102               parseDNLMarker
1103             );
1104             offset += processed;
1105           } catch (ex) {
1106             if (ex instanceof DNLMarkerError) {
1107               warn(`${ex.message} -- attempting to re-parse the JPEG image.`);
1108               return this.parse(data, { dnlScanLines: ex.scanLines });
1109             } else if (ex instanceof EOIMarkerError) {
1110               warn(`${ex.message} -- ignoring the rest of the image data.`);
1111               break markerLoop;
1112             }
1113             throw ex;
1114           }
1115           break;
1116 
1117         case 0xffdc: // DNL (Define Number of Lines)
1118           // Ignore the marker, since it's being handled in `decodeScan`.
1119           offset += 4;
1120           break;
1121 
1122         case 0xffff: // Fill bytes
1123           if (data[offset] !== 0xff) {
1124             // Avoid skipping a valid marker.
1125             offset--;
1126           }
1127           break;
1128 
1129         default:
1130           // Could be incorrect encoding -- the last 0xFF byte of the previous
1131           // block could have been eaten by the encoder, hence we fallback to
1132           // `startPos = offset - 3` when looking for the next valid marker.
1133           const nextFileMarker = findNextFileMarker(
1134             data,
1135             /* currentPos = */ offset - 2,
1136             /* startPos = */ offset - 3
1137           );
1138           if (nextFileMarker?.invalid) {
1139             warn(
1140               "JpegImage.parse - unexpected data, current marker is: " +
1141                 nextFileMarker.invalid
1142             );
1143             offset = nextFileMarker.offset;
1144             break;
1145           }
1146           if (!nextFileMarker || offset >= data.length - 1) {
1147             warn(
1148               "JpegImage.parse - reached the end of the image data " +
1149                 "without finding an EOI marker (0xFFD9)."
1150             );
1151             break markerLoop;
1152           }
1153           throw new JpegError(
1154             "JpegImage.parse - unknown marker: " + fileMarker.toString(16)
1155           );
1156       }
1157       fileMarker = readUint16(data, offset);
1158       offset += 2;
1159     }
1160 
1161     if (!frame) {
1162       throw new JpegError("JpegImage.parse - no frame data found.");
1163     }
1164     this.width = frame.samplesPerLine;
1165     this.height = frame.scanLines;
1166     this.jfif = jfif;
1167     this.adobe = adobe;
1168     this.components = [];
1169     for (const component of frame.components) {
1170       // Prevent errors when DQT markers are placed after SOF{n} markers,
1171       // by assigning the `quantizationTable` entry after the entire image
1172       // has been parsed (fixes issue7406.pdf).
1173       const quantizationTable = quantizationTables[component.quantizationId];
1174       if (quantizationTable) {
1175         component.quantizationTable = quantizationTable;
1176       }
1177 
1178       this.components.push({
1179         index: component.index,
1180         output: buildComponentData(frame, component),
1181         scaleX: component.h / frame.maxH,
1182         scaleY: component.v / frame.maxV,
1183         blocksPerLine: component.blocksPerLine,
1184         blocksPerColumn: component.blocksPerColumn,
1185       });
1186     }
1187     this.numComponents = this.components.length;
1188     return undefined;
1189   }
1190 
1191   _getLinearizedBlockData(width, height, isSourcePDF = false) {
1192     const scaleX = this.width / width,
1193       scaleY = this.height / height;
1194 
1195     let component, componentScaleX, componentScaleY, blocksPerScanline;
1196     let x, y, i, j, k;
1197     let index;
1198     let offset = 0;
1199     let output;
1200     const numComponents = this.components.length;
1201     const dataLength = width * height * numComponents;
1202     const data = new Uint8ClampedArray(dataLength);
1203     const xScaleBlockOffset = new Uint32Array(width);
1204     const mask3LSB = 0xfffffff8; // used to clear the 3 LSBs
1205     let lastComponentScaleX;
1206 
1207     for (i = 0; i < numComponents; i++) {
1208       component = this.components[i];
1209       componentScaleX = component.scaleX * scaleX;
1210       componentScaleY = component.scaleY * scaleY;
1211       offset = i;
1212       output = component.output;
1213       blocksPerScanline = (component.blocksPerLine + 1) << 3;
1214       // Precalculate the `xScaleBlockOffset`. Since it doesn't depend on the
1215       // component data, that's only necessary when `componentScaleX` changes.
1216       if (componentScaleX !== lastComponentScaleX) {
1217         for (x = 0; x < width; x++) {
1218           j = 0 | (x * componentScaleX);
1219           xScaleBlockOffset[x] = ((j & mask3LSB) << 3) | (j & 7);
1220         }
1221         lastComponentScaleX = componentScaleX;
1222       }
1223       // linearize the blocks of the component
1224       for (y = 0; y < height; y++) {
1225         j = 0 | (y * componentScaleY);
1226         index = (blocksPerScanline * (j & mask3LSB)) | ((j & 7) << 3);
1227         for (x = 0; x < width; x++) {
1228           data[offset] = output[index + xScaleBlockOffset[x]];
1229           offset += numComponents;
1230         }
1231       }
1232     }
1233 
1234     // decodeTransform contains pairs of multiplier (-256..256) and additive
1235     let transform = this._decodeTransform;
1236 
1237     // In PDF files, JPEG images with CMYK colour spaces are usually inverted
1238     // (this can be observed by extracting the raw image data).
1239     // Since the conversion algorithms (see below) were written primarily for
1240     // the PDF use-cases, attempting to use `JpegImage` to parse standalone
1241     // JPEG (CMYK) images may thus result in inverted images (see issue 9513).
1242     //
1243     // Unfortunately it's not (always) possible to tell, from the image data
1244     // alone, if it needs to be inverted. Thus in an attempt to provide better
1245     // out-of-box behaviour when `JpegImage` is used standalone, default to
1246     // inverting JPEG (CMYK) images if and only if the image data does *not*
1247     // come from a PDF file and no `decodeTransform` was passed by the user.
1248     if (!isSourcePDF && numComponents === 4 && !transform) {
1249       transform = new Int32Array([-256, 255, -256, 255, -256, 255, -256, 255]);
1250     }
1251 
1252     if (transform) {
1253       for (i = 0; i < dataLength; ) {
1254         for (j = 0, k = 0; j < numComponents; j++, i++, k += 2) {
1255           data[i] = ((data[i] * transform[k]) >> 8) + transform[k + 1];
1256         }
1257       }
1258     }
1259     return data;
1260   }
1261 
1262   get _isColorConversionNeeded() {
1263     if (this.adobe) {
1264       // The adobe transform marker overrides any previous setting.
1265       return !!this.adobe.transformCode;
1266     }
1267     if (this.numComponents === 3) {
1268       if (this._colorTransform === 0) {
1269         // If the Adobe transform marker is not present and the image
1270         // dictionary has a 'ColorTransform' entry, explicitly set to `0`,
1271         // then the colours should *not* be transformed.
1272         return false;
1273       } else if (
1274         this.components[0].index === /* "R" = */ 0x52 &&
1275         this.components[1].index === /* "G" = */ 0x47 &&
1276         this.components[2].index === /* "B" = */ 0x42
1277       ) {
1278         // If the three components are indexed as RGB in ASCII
1279         // then the colours should *not* be transformed.
1280         return false;
1281       }
1282       return true;
1283     }
1284     // `this.numComponents !== 3`
1285     if (this._colorTransform === 1) {
1286       // If the Adobe transform marker is not present and the image
1287       // dictionary has a 'ColorTransform' entry, explicitly set to `1`,
1288       // then the colours should be transformed.
1289       return true;
1290     }
1291     return false;
1292   }
1293 
1294   _convertYccToRgb(data) {
1295     let Y, Cb, Cr;
1296     for (let i = 0, length = data.length; i < length; i += 3) {
1297       Y = data[i];
1298       Cb = data[i + 1];
1299       Cr = data[i + 2];
1300       data[i] = Y - 179.456 + 1.402 * Cr;
1301       data[i + 1] = Y + 135.459 - 0.344 * Cb - 0.714 * Cr;
1302       data[i + 2] = Y - 226.816 + 1.772 * Cb;
1303     }
1304     return data;
1305   }
1306 
1307   _convertYccToRgba(data, out) {
1308     for (let i = 0, j = 0, length = data.length; i < length; i += 3, j += 4) {
1309       const Y = data[i];
1310       const Cb = data[i + 1];
1311       const Cr = data[i + 2];
1312       out[j] = Y - 179.456 + 1.402 * Cr;
1313       out[j + 1] = Y + 135.459 - 0.344 * Cb - 0.714 * Cr;
1314       out[j + 2] = Y - 226.816 + 1.772 * Cb;
1315       out[j + 3] = 255;
1316     }
1317     return out;
1318   }
1319 
1320   _convertYcckToRgb(data) {
1321     this._convertYcckToCmyk(data);
1322     return this._convertCmykToRgb(data);
1323   }
1324 
1325   _convertYcckToRgba(data) {
1326     this._convertYcckToCmyk(data);
1327     return this._convertCmykToRgba(data);
1328   }
1329 
1330   _convertYcckToCmyk(data) {
1331     let Y, Cb, Cr;
1332     for (let i = 0, length = data.length; i < length; i += 4) {
1333       Y = data[i];
1334       Cb = data[i + 1];
1335       Cr = data[i + 2];
1336       data[i] = 434.456 - Y - 1.402 * Cr;
1337       data[i + 1] = 119.541 - Y + 0.344 * Cb + 0.714 * Cr;
1338       data[i + 2] = 481.816 - Y - 1.772 * Cb;
1339       // K in data[i + 3] is unchanged
1340     }
1341     return data;
1342   }
1343 
1344   _convertCmykToRgb(data) {
1345     const count = data.length / 4;
1346     ColorSpaceUtils.cmyk.getRgbBuffer(data, 0, count, data, 0, 8, 0);
1347     return data.subarray(0, count * 3);
1348   }
1349 
1350   _convertCmykToRgba(data) {
1351     ColorSpaceUtils.cmyk.getRgbBuffer(data, 0, data.length / 4, data, 0, 8, 1);
1352     return data;
1353   }
1354 
1355   getData({
1356     width,
1357     height,
1358     forceRGBA = false,
1359     forceRGB = false,
1360     isSourcePDF = false,
1361   }) {
1362     if (typeof PDFJSDev === "undefined" || PDFJSDev.test("TESTING")) {
1363       assert(
1364         isSourcePDF === true,
1365         'JpegImage.getData: Unexpected "isSourcePDF" value for PDF files.'
1366       );
1367     }
1368     if (this.numComponents > 4) {
1369       throw new JpegError("Unsupported color mode");
1370     }
1371     // Type of data: Uint8ClampedArray(width * height * numComponents)
1372     const data = this._getLinearizedBlockData(width, height, isSourcePDF);
1373 
1374     if (this.numComponents === 1 && (forceRGBA || forceRGB)) {
1375       const len = data.length * (forceRGBA ? 4 : 3);
1376       const rgbaData = new Uint8ClampedArray(len);
1377       let offset = 0;
1378       if (forceRGBA) {
1379         grayToRGBA(data, new Uint32Array(rgbaData.buffer));
1380       } else {
1381         for (const grayColor of data) {
1382           rgbaData[offset++] = grayColor;
1383           rgbaData[offset++] = grayColor;
1384           rgbaData[offset++] = grayColor;
1385         }
1386       }
1387       return rgbaData;
1388     } else if (this.numComponents === 3 && this._isColorConversionNeeded) {
1389       if (forceRGBA) {
1390         const rgbaData = new Uint8ClampedArray((data.length / 3) * 4);
1391         return this._convertYccToRgba(data, rgbaData);
1392       }
1393       return this._convertYccToRgb(data);
1394     } else if (this.numComponents === 4) {
1395       if (this._isColorConversionNeeded) {
1396         if (forceRGBA) {
1397           return this._convertYcckToRgba(data);
1398         }
1399         if (forceRGB) {
1400           return this._convertYcckToRgb(data);
1401         }
1402         return this._convertYcckToCmyk(data);
1403       } else if (forceRGBA) {
1404         return this._convertCmykToRgba(data);
1405       } else if (forceRGB) {
1406         return this._convertCmykToRgb(data);
1407       }
1408     }
1409     return data;
1410   }
1411 }
1412 
1413 export { JpegError, JpegImage };
</code>

Your task:
You are a software tester at pdf.js.
1. Write exactly one javascript test `it("...", async () => {...})` block.
2. Your test must fail on the code before the patch, and pass after, hence the test will verify that the patch resolves the issue.
3. The test must be self-contained and to-the-point.
4. Use only the provided imports (respect the paths exactly how they are given) by importing dynamically for compatibility with Node.js — no new dependencies. 
5. Return only the javascript code (no comments or explanations).

Example structure:
it("should <describe behavior>", async () => {
  const { example } = await import("../../src/core/example.js");
  <initialize required variables>;
  <define expected variable>;
  <generate actual variables>;
  <compare expected with actual>;
});

