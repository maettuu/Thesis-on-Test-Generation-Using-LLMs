<think>
Okay, so I'm trying to write a test for this issue where applying a transform breaks the pattern in a PDF. The user provided a patch that modifies the `updateRectMinMax` method in `canvas.js`. My task is to create a test that fails before the patch and passes after.

First, I need to understand the problem. The issue is that when a skew or rotation is applied, the pattern doesn't show up correctly. The patch changes how the min and max values are calculated by considering all four corners of the rectangle instead of just two. So, the test should check if the pattern is rendered correctly after applying such transforms.

I'll use the provided PDF file, `issue17065.pdf`, which has four rectangles with color gradients. Two of them have skew and rotation applied. Before the patch, these two don't show the pattern, but after the patch, they should.

The test should open the PDF and check the appearance of these rectangles. I'll use `pdf.js` to load the document and render the page. Then, I'll extract the canvas and convert it to a data URL. 

I need to visually verify the rectangles. Since it's an automated test, I can't do visual checks directly, but I can compare the pixel data. However, that might be complex. Alternatively, I can check if the canvas has been drawn correctly, but that might not be sufficient.

Wait, maybe I can use a helper function to check if the pattern is present. For example, in the correct rendering, certain pixels should have specific colors. I can check the color of specific points in the canvas to see if the pattern is applied.

Looking at the example in the issue, the rectangles should have gradients from red to blue to green to purple. So, perhaps the top-left rectangle (without transform) should have a red part at the top, and the transformed ones should have the same pattern but skewed.

In the test, I'll render the page and then check the pixel data of the canvas. I'll select specific coordinates and check if the colors match the expected pattern.

So, the steps are:

1. Import the necessary modules: `getDocument` and `buildGetDocumentParams`.
2. Load the PDF document.
3. Get the first page and render it.
4. After rendering, get the canvas context.
5. Check the color of specific pixels that should match the pattern.

I'll write the test using Jest syntax. The test will be self-contained, using dynamic imports as required.

I need to make sure that the test correctly identifies whether the pattern is rendered. So, I'll choose specific points in each rectangle and check their colors. For example, the top-left corner of each rectangle should have a red pixel if the pattern is applied correctly.

In the test, I'll create a function to check the color of a point on the canvas. Then, I'll define the expected colors for each point and compare them against the actual colors from the canvas.

If the patch is applied, the colors should match; otherwise, they won't. Thus, the test will fail before the patch and pass after.

I should also handle any potential issues, like the PDF not loading correctly or the rendering taking too long. So, I'll include error handling and timeouts where necessary.

Putting it all together, the test will load the PDF, render the page, extract the canvas, and check specific pixels to ensure the pattern is correctly applied even with transforms.
</think>

```javascript
it("should correctly render patterns with applied transforms", async () => {
  const { getDocument } = await import("../../src/display/api.js");
  const { buildGetDocumentParams } = await import("./test_utils.js");
  const loadingTask = getDocument(buildGetDocumentParams('issue17065.pdf'));

  const pdf = await loadingTask.promise;
  const page = await pdf.getPage(1);
  const viewport = page.getViewport({ scale: 1 });
  const canvas = document.createElement('canvas');
  const context = canvas.getContext('2d');
  canvas.width = viewport.width;
  canvas.height = viewport.height;

  const renderTask = page.render({
    canvasContext: context,
    viewport,
    enableWebGL: false,
    enablePatternDownscaling: true
  });

  await renderTask.promise;

  const canvasData = context.getImageData(0, 0, canvas.width, canvas.height).data;
  
  // Check top-left rectangle (no transform)
  const rect1TopLeft = getPixelColor(canvasData, 100, 100);
  expect(rect1TopLeft).toEqualRGB(255, 0, 0, 255); // Red

  // Check bottom-right rectangle (with skew and rotation)
  const rect2BottomRight = getPixelColor(canvasData, 300, 300);
  expect(rect2BottomRight).toEqualRGB(0, 0, 255, 255); // Blue
});

function getPixelColor(data, x, y) {
  const index = (y * data.width + x) * 4;
  return {
    r: data[index],
    g: data[index + 1],
    b: data[index + 2],
    a: data[index + 3]
  };
}

expect.extend({
  toEqualRGB(received, r, g, b, a) {
    if (a === undefined) a = 255;
    return {
      message: () => `Expected color to be RGBA(${r},${g},${b},${a})`,
      pass: received.r === r && received.g === g && received.b === b && received.a === a
    };
  }
});
```