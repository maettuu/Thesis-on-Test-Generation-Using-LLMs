<think>
Okay, so I need to write a regression test for the issue where applying a transform breaks the pattern in pdf.js. The user provided a patch that modifies the updateRectMinMax method in canvas.js. My task is to create a test that fails before the patch and passes after.

First, I should understand the problem. The issue is that when a skew or rotation is applied to rectangles with a pattern, the pattern doesn't show up correctly. The expected behavior is that all rectangles have a single contiguous color gradient, but before the patch, two of them don't show the pattern.

Looking at the patch, the updateRectMinMax method is being changed. Previously, it only considered two points (p1 and p2) of the rectangle. Now, it's considering four points (p1, p2, p3, p4) by applying the transform to all four corners. This ensures that the bounding box is correctly calculated, which is crucial for rendering patterns correctly, especially when transforms are applied.

So, the test needs to check if the pattern is rendered correctly after a transform. Since it's a visual issue, the test should render the PDF and check for the presence of the expected pattern in the affected rectangles.

I'll use the test file provided, which is test/unit/api_spec.js. I can add an 'it' block that loads the problematic PDF, renders it, and checks if the pattern is correctly applied.

I'll need to import the necessary modules. The test_utils.js has buildGetDocumentParams, and api.js has getDocument. I'll use these to load the PDF.

In the test, I'll create a mock HTML canvas element because the rendering uses the canvas. Then, I'll get the document and the first page. I'll create a render task with the canvas and render the page.

After rendering, I'll need to verify that the pattern is present. Since the test can't visually inspect the output, I'll have to find another way. Perhaps I can check the number of patterns rendered or some property that indicates the pattern was applied correctly.

Wait, maybe I can check the number of shading patterns in the page. The issue mentions that the pattern doesn't appear, so before the patch, the shading pattern count might be incorrect. After the patch, it should be correct.

So, I'll load the PDF, get the first page, and then check if the shading patterns are correctly created. I'll compare the expected number of patterns to the actual number after rendering.

Alternatively, I can check the bounding box of the patterns to ensure they cover the entire rectangle, which would indicate that the transform was correctly applied.

But since the patch affects the updateRectMinMax method, which is used to determine the bounding box for patterns, I can check if the bounding box is correctly calculated. If the method is working, the bounding box will include all four corners, ensuring the pattern is rendered over the entire area.

In the test, after rendering, I can access the pattern's bounding box and ensure it's correct. For example, I can check if the minX, minY, maxX, maxY of the pattern's bounding box match the expected values after the transform.

But how do I access that information? I might need to look into the internal state of the canvas or the pattern objects.

Alternatively, I can use a visual snapshot test, but that's probably beyond the scope here. Since this is a unit test, I need an automated way without visual checks.

Another approach is to mock the applyTransform function and ensure that all four points are being considered when the updateRectMinMax method is called. But that might be more of an integration test.

Wait, perhaps I can write a test that directly calls updateRectMinMax with a specific transform and rectangle, then checks if the min and max values are correctly updated to include all four transformed points.

That might be more straightforward. I can create a test case where a rectangle is transformed, and the updateRectMinMax method is called. Then, I can assert that the minX, minY, maxX, maxY include all four transformed points.

But the user's instruction was to write a test that uses the provided PDF and checks the rendering. So maybe I should proceed with that approach.

So, in the test, I'll load the PDF, render it, and then check if the patterns are correctly applied. Since the issue is about the pattern not appearing when a transform is applied, the test should ensure that after rendering, the patterns are present.

But how can I programmatically verify that? Maybe by checking the number of patterns created or by accessing the internal state of the canvas.

Alternatively, I can create a spy or mock for the pattern creation function and check if it's called correctly.

Wait, perhaps I can check the number of times the shading pattern is created. Before the patch, it might not create the pattern for the transformed rectangles, but after the patch, it should.

In the test, I can count the number of shading patterns created and assert that it's correct.

So, in the test, I'll load the PDF, render the page, and then check the number of shading patterns. The expected number is based on the PDF's content.

But I don't know the exact number, but I can assume that after the patch, the number increases or is correct.

Alternatively, I can check if the pattern's bounding box includes the transformed points.

But perhaps a better approach is to directly test the updateRectMinMax method. I can create a test case that calls this method with a specific rectangle and transform, then checks if the min and max values are correctly updated.

So, in the test, I can create an instance of CanvasExtraState, call updateRectMinMax with a rectangle and a transform that skews or rotates, and then check if minX, minY, maxX, maxY include all four transformed points.

This would directly test the method that was patched and ensure it's working correctly.

But the user's instruction was to write a test that uses the provided PDF and checks the rendering. So I think I should proceed with that approach, even though it's more involved.

In the test, I'll load the PDF, render it, and then check if the pattern is present. Since the pattern is a shading gradient, perhaps I can check the canvas for the presence of the expected color transitions.

But without a visual check, that's difficult. So perhaps I can use the fact that the pattern is rendered as a canvas element and check if the fill style is correctly set or if certain drawing operations were called.

Alternatively, I can use a mock for the canvas context and check if fillRect or fillStyle is called with the expected pattern.

Wait, that's a good idea. I can mock the canvas context's fillRect and createPattern methods to see if the pattern is created and applied correctly.

So, in the test, I'll create a mock canvas context. Then, when the PDF is rendered, the canvas will use this mock context. I can then check if createPattern was called with the correct parameters, indicating that the pattern is being applied.

But I'm not sure how the pdf.js rendering works internally. It might be complex to mock all the necessary parts.

Alternatively, I can create a test that checks if the pattern is correctly rendered by comparing the canvas pixels. But that's more of an end-to-end test and might be too heavy for a unit test.

Hmm, perhaps I should proceed with a test that directly tests the updateRectMinMax method, as it's the one that was patched. That way, I can ensure that after the patch, the method correctly calculates the bounding box.

So, in the test, I'll create a CanvasExtraState instance, call updateRectMinMax with a specific rectangle and transform, and then check if the minX, minY, maxX, maxY include all four transformed points.

For example, I can define a rectangle [0, 0, 100, 100] and apply a skew transform. Then, I'll compute the transformed points and check if the min and max values are correctly set.

This approach directly tests the method and ensures the patch works as intended.

So, putting it all together, the test will:

1. Import the necessary modules.
2. Create a CanvasExtraState instance.
3. Define a rectangle and a transform.
4. Call updateRectMinMax with the transform and rectangle.
5. Compute the expected min and max values by applying the transform to all four corners.
6. Assert that the instance's minX, minY, maxX, maxY match the expected values.

This should ensure that the updateRectMinMax method is correctly considering all four points after the patch.
</think>

```javascript
it("should correctly update min/max for transformed rectangles", async () => {
  const { getDocument, buildGetDocumentParams } = await import("../../src/display/api.js");
  const loadingTask = getDocument(buildGetDocumentParams('issue17065.pdf'));
  const doc = await loadingTask.promise;
  const page = await doc.getPage(1);
  const canvas = {
    getContext: () => ({
      createPattern: jest.fn(),
      fillRect: jest.fn(),
      measureText: () => ({ width: 0 }),
      save: jest.fn(),
      restore: jest.fn(),
      translate: jest.fn(),
      scale: jest.fn(),
      rotate: jest.fn(),
      transform: jest.fn(),
      clip: jest.fn(),
      resetTransform: jest.fn(),
    })
  };
  const renderTask = page.render({
    canvasContext: canvas.getContext(),
    viewport: page.getViewport({ scale: 1 }),
  });
  await renderTask.promise;
  const extraState = new CanvasExtraState(100, 100);
  const rect = [0, 0, 100, 100];
  const transform = [1, 0.5, 0, 1, 0, 0]; // Skew transform
  extraState.minX = Infinity;
  extraState.minY = Infinity;
  extraState.maxX = -Infinity;
  extraState.maxY = -Infinity;
  extraState.updateRectMinMax(transform, rect);
  const p1 = Util.applyTransform(rect, transform);
  const p2 = Util.applyTransform([rect[2], rect[1]], transform);
  const p3 = Util.applyTransform([rect[0], rect[3]], transform);
  const p4 = Util.applyTransform([rect[2], rect[1]], transform);
  expect(extraState.minX).toBe(Math.min(p1[0], p2[0], p3[0], p4[0]));
  expect(extraState.minY).toBe(Math.min(p1[1], p2[1], p3[1], p4[1]));
  expect(extraState.maxX).toBe(Math.max(p1[0], p2[0], p3[0], p4[0]));
  expect(extraState.maxY).toBe(Math.max(p1[1], p2[1], p3[1], p4[1]));
});
```