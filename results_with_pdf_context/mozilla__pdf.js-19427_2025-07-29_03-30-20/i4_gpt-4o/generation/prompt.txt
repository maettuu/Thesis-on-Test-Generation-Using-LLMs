Before you begin:
- Keep going until the job is completely solved — don’t stop halfway.
- If you’re unsure about the behavior, reread the provided patch carefully; do not hallucinate.
- Plan your approach before writing code by reflecting on whether the test truly fails before and passes after.

Issue:
<issue>
PDFs generated by Firefox missing a character when parsed by text extraction tools, or when copypasted-from when viewed in any PDF viewer
</issue>

Patch:
<patch>
diff --git a/src/core/fonts.js b/src/core/fonts.js
--- a/src/core/fonts.js
+++ b/src/core/fonts.js
@@ -485,6 +485,8 @@ function adjustMapping(charCodeToGlyphId, hasGlyph, newGlyphZeroId, toUnicode) {
   const isInPrivateArea = code =>
     (PRIVATE_USE_AREAS[0][0] <= code && code <= PRIVATE_USE_AREAS[0][1]) ||
     (PRIVATE_USE_AREAS[1][0] <= code && code <= PRIVATE_USE_AREAS[1][1]);
+  let LIGATURE_TO_UNICODE = null;
+
   for (const originalCharCode in charCodeToGlyphId) {
     let glyphId = charCodeToGlyphId[originalCharCode];
     // For missing glyphs don't create the mappings so the glyph isn't
@@ -514,7 +516,23 @@ function adjustMapping(charCodeToGlyphId, hasGlyph, newGlyphZeroId, toUnicode) {
     // glyph ids to the correct unicode.
     let unicode = toUnicode.get(originalCharCode);
     if (typeof unicode === "string") {
-      unicode = unicode.codePointAt(0);
+      if (unicode.length === 1) {
+        unicode = unicode.codePointAt(0);
+      } else {
+        if (!LIGATURE_TO_UNICODE) {
+          LIGATURE_TO_UNICODE = new Map();
+          // The code range [0xfb00, 0xfb4f] contains some ligature characters
+          // but not all.
+          // See https://www.compart.com/en/unicode/block/U+FB00.
+          for (let i = 0xfb00; i <= 0xfb4f; i++) {
+            const normalized = String.fromCharCode(i).normalize("NFKD");
+            if (normalized.length > 1) {
+              LIGATURE_TO_UNICODE.set(normalized, i);
+            }
+          }
+        }
+        unicode = LIGATURE_TO_UNICODE.get(unicode) || unicode.codePointAt(0);
+      }
     }
     if (unicode && !isInPrivateArea(unicode) && !usedGlyphIds.has(glyphId)) {
       toUnicodeExtraMap.set(unicode, glyphId);


</patch>

Imports:
<imports>
Available Packages
Dev Dependencies:
- @babel/core: ^7.26.7
- @babel/preset-env: ^7.26.7
- @babel/runtime: ^7.26.7
- @fluent/bundle: ^0.18.0
- @fluent/dom: ^0.10.0
- @metalsmith/layouts: ^2.7.0
- @metalsmith/markdown: ^1.10.0
- @napi-rs/canvas: ^0.1.65
- @types/node: ^22.13.0
- autoprefixer: ^10.4.20
- babel-loader: ^9.2.1
- caniuse-lite: ^1.0.30001696
- core-js: ^3.40.0
- eslint: ^9.19.0
- eslint-plugin-import: ^2.31.0
- eslint-plugin-jasmine: ^4.2.2
- eslint-plugin-json: ^4.0.1
- eslint-plugin-no-unsanitized: ^4.1.2
- eslint-plugin-perfectionist: ^4.7.0
- eslint-plugin-prettier: ^5.2.3
- eslint-plugin-unicorn: ^56.0.1
- globals: ^15.14.0
- gulp: ^5.0.0
- gulp-cli: ^3.0.0
- gulp-postcss: ^10.0.0
- gulp-rename: ^2.0.0
- gulp-replace: ^1.1.4
- gulp-zip: ^6.1.0
- highlight.js: ^11.11.1
- jasmine: ^5.5.0
- jsdoc: ^4.0.4
- jstransformer-nunjucks: ^1.2.0
- metalsmith: ^2.6.3
- metalsmith-html-relative: ^2.0.6
- ordered-read-streams: ^2.0.0
- pngjs: ^7.0.0
- postcss: ^8.5.1
- postcss-dark-theme-class: ^1.3.0
- postcss-dir-pseudo-class: ^9.0.1
- postcss-discard-comments: ^7.0.3
- postcss-nesting: ^13.0.1
- prettier: ^3.4.2
- puppeteer: ^24.1.1
- stylelint: ^16.14.1
- stylelint-prettier: ^5.0.3
- svglint: ^3.1.0
- terser-webpack-plugin: ^5.3.11
- tsc-alias: ^1.8.10
- ttest: ^4.0.0
- typescript: ^5.7.3
- vinyl: ^3.0.0
- webpack: ^5.97.1
- webpack-stream: ^7.0.0
- yargs: ^17.7.2

Engines:
- node: >=20

Available Relative Imports:
- `../../src/core/annotation.js`: Annotation, AnnotationBorderStyle, AnnotationFactory, MarkupAnnotation, getQuadPoints
- `../../src/core/bidi.js`: bidi
- `../../src/core/cff_parser.js`: CFFCharset, CFFCompiler, CFFFDSelect, CFFParser, CFFStrings
- `../../src/core/cmap.js`: CMap, CMapFactory, IdentityCMap
- `../../src/core/colorspace.js`: ColorSpace
- `../../src/core/core_utils.js`: arrayBuffersToBytes, encodeToXmlString, escapePDFName, escapeString, getInheritableProperty, getSizeInBytes, isAscii, isWhiteSpace, log2, numberToString, parseXFAPath, recoverJsURL, stringToUTF16HexString, stringToUTF16String, toRomanNumerals, validateCSSFont
- `../../src/core/crypto.js`: AES128Cipher, AES256Cipher, ARCFourCipher, CipherTransformFactory, PDF17, PDF20, calculateMD5, calculateSHA256, calculateSHA384, calculateSHA512
- `../../src/core/default_appearance.js`: createDefaultAppearance, parseAppearanceStream, parseDefaultAppearance
- `../../src/core/document.js`: PDFDocument, Page
- `../../src/core/encodings.js`: getEncoding
- `../../src/core/evaluator.js`: PartialEvaluator
- `../../src/core/flate_stream.js`: FlateStream
- `../../src/core/font_substitutions.js`: getFontSubstitution
- `../../src/core/fonts_utils.js`: SEAC_ANALYSIS_ENABLED
- `../../src/core/function.js`: PDFFunctionFactory, PostScriptCompiler, PostScriptEvaluator
- `../../src/core/glyphlist.js`: getDingbatsGlyphsUnicode, getGlyphsUnicode
- `../../src/core/image_utils.js`: GlobalImageCache, LocalColorSpaceCache
- `../../src/core/jbig2.js`: Jbig2Error, Jbig2Image
- `../../src/core/jpg.js`: JpegError, JpegImage
- `../../src/core/jpx.js`: JpxError, JpxImage
- `../../src/core/metadata_parser.js`: MetadataParser
- `../../src/core/operator_list.js`: OperatorList
- `../../src/core/parser.js`: Lexer, Linearization, Parser
- `../../src/core/predictor_stream.js`: PredictorStream
- `../../src/core/primitives.js`: Cmd, Dict, EOF, Name, Ref, RefSet, RefSetCache, isCmd, isDict, isName, isRefsEqual
- `../../src/core/ps_parser.js`: PostScriptLexer, PostScriptParser
- `../../src/core/stream.js`: NullStream, Stream, StringStream
- `../../src/core/type1_parser.js`: Type1Parser
- `../../src/core/unicode.js`: getCharUnicodeCategory, getUnicodeForGlyph, getUnicodeRangeFor, mapSpecialUnicodeValues
- `../../src/core/worker.js`: WorkerMessageHandler, WorkerTask
- `../../src/core/writer.js`: incrementalUpdate, writeChanges, writeDict
- `../../src/core/xfa/bind.js`: Binder
- `../../src/core/xfa/data.js`: DataHandler
- `../../src/core/xfa/factory.js`: XFAFactory
- `../../src/core/xfa/formcalc_lexer.js`: Lexer, TOKEN, Token
- `../../src/core/xfa/formcalc_parser.js`: Errors, Parser
- `../../src/core/xfa/parser.js`: XFAParser
- `../../src/core/xfa/som.js`: searchNode
- `../../src/core/xfa/symbol_utils.js`: $dump, $getChildren, $getChildrenByClass, $getChildrenByName, $text, $uid
- `../../src/core/xml_parser.js`: SimpleXMLParser, XMLParserBase
- `../../src/display/annotation_layer.js`: AnnotationLayer
- `../../src/display/annotation_storage.js`: AnnotationStorage
- `../../src/display/api.js`: LoopbackPort, PDFDataRangeTransport, PDFDocumentLoadingTask, PDFDocumentProxy, PDFPageProxy, PDFWorker, RenderTask, build, getDocument, version
- `../../src/display/canvas_factory.js`: DOMCanvasFactory
- `../../src/display/cmap_reader_factory.js`: DOMCMapReaderFactory
- `../../src/display/display_utils.js`: OutputScale, PDFDateString, PageViewport, PixelsPerInch, RenderingCancelledException, StatTimer, SupportedImageMimeTypes, fetchData, getFilenameFromUrl, getPdfFilenameFromUrl, getXfaPageViewport, isDataScheme, isPdfFile, isValidFetchUrl, noContextMenu, setLayerDimensions, stopEvent
- `../../src/display/draw_layer.js`: DrawLayer
- `../../src/display/editor/annotation_editor_layer.js`: AnnotationEditorLayer
- `../../src/display/editor/color_picker.js`: ColorPicker
- `../../src/display/editor/tools.js`: AnnotationEditorUIManager, CommandManager
- `../../src/display/fetch_stream.js`: PDFFetchStream
- `../../src/display/metadata.js`: Metadata
- `../../src/display/network.js`: PDFNetworkStream
- `../../src/display/network_utils.js`: createHeaders, createResponseError, extractFilenameFromHeader, validateRangeRequestCapabilities, validateResponseStatus
- `../../src/display/node_stream.js`: PDFNodeStream
- `../../src/display/node_utils.js`: NodeCMapReaderFactory, NodeStandardFontDataFactory, fetchData
- `../../src/display/standard_fontdata_factory.js`: DOMStandardFontDataFactory
- `../../src/display/svg_factory.js`: DOMSVGFactory
- `../../src/display/text_layer.js`: TextLayer
- `../../src/display/touch_manager.js`: TouchManager
- `../../src/display/worker_options.js`: GlobalWorkerOptions
- `../../src/display/xfa_layer.js`: XfaLayer
- `../../src/shared/message_handler.js`: MessageHandler
- `../../src/shared/murmurhash3.js`: MurmurHash3_64
- `../../src/shared/util.js`: AbortException, AnnotationBorderStyleType, AnnotationEditorParamsType, AnnotationEditorType, AnnotationFieldFlag, AnnotationFlag, AnnotationMode, AnnotationType, BaseException, FeatureTest, FormatError, ImageKind, InvalidPDFException, OPS, PasswordException, PasswordResponses, PermissionFlag, RenderingIntentFlag, ResponseException, UnknownErrorException, Util, VerbosityLevel, assert, bytesToString, createValidAbsoluteUrl, getModificationDate, getUuid, getVerbosityLevel, isNodeJS, normalizeUnicode, objectSize, setVerbosityLevel, shadow, string32, stringToBytes, stringToPDFString, stringToUTF8String, toBase64Util
- `../../web/annotation_layer_builder.js`: AnnotationLayerBuilder
- `../../web/app_options.js`: AppOptions, OptionKind
- `../../web/download_manager.js`: DownloadManager
- `../../web/event_utils.js`: EventBus, WaitOnType, waitOnEventOrTimeout
- `../../web/genericl10n.js`: GenericL10n
- `../../web/pdf_find_controller.js`: FindState, PDFFindController
- `../../web/pdf_find_utils.js`: CharacterType, getCharacterType
- `../../web/pdf_history.js`: PDFHistory, isDestArraysEqual, isDestHashesEqual
- `../../web/pdf_link_service.js`: LinkTarget, PDFLinkService, SimpleLinkService
- `../../web/pdf_page_view.js`: PDFPageView
- `../../web/pdf_scripting_manager.component.js`: PDFScriptingManager
- `../../web/pdf_single_page_viewer.js`: PDFSinglePageViewer
- `../../web/pdf_viewer.js`: PDFPageViewBuffer, PDFViewer
- `../../web/struct_tree_layer_builder.js`: StructTreeLayerBuilder
- `../../web/text_layer_builder.js`: TextLayerBuilder
- `../../web/ui_utils.js`: AutoPrintRegExp, ProgressBar, RenderingStates, ScrollMode, SpreadMode, backtrackBeforeAllVisibleElements, binarySearchFirstItem, calcRound, getPageSizeInches, getVisibleElements, isPortraitOrientation, isValidRotation, parseQueryString, removeNullCharacters
- `../../web/xfa_layer_builder.js`: XfaLayerBuilder
- `../reporter.js`: TestReporter
- `./common_pdfstream_tests.js`: testCrossOriginRedirects
- `./test_utils.js`: CMAP_URL, DefaultCMapReaderFactory, DefaultFileReaderFactory, DefaultStandardFontDataFactory, STANDARD_FONT_DATA_URL, TEST_PDFS_PATH, TestPdfsServer, XRefMock, buildGetDocumentParams, createIdFactory, getCrossOriginHostname
</imports>

Code:
<code>
File:
src/core/fonts.js
1 /* Copyright 2012 Mozilla Foundation
2  *
3  * Licensed under the Apache License, Version 2.0 (the "License");
4  * you may not use this file except in compliance with the License.
5  * You may obtain a copy of the License at
6  *
7  *     http://www.apache.org/licenses/LICENSE-2.0
8  *
9  * Unless required by applicable law or agreed to in writing, software
10  * distributed under the License is distributed on an "AS IS" BASIS,
11  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
12  * See the License for the specific language governing permissions and
13  * limitations under the License.
14  */
15 
16 import {
17   assert,
18   bytesToString,
19   FONT_IDENTITY_MATRIX,
20   FormatError,
21   info,
22   shadow,
23   string32,
24   warn,
25 } from "../shared/util.js";
26 import { CFFCompiler, CFFParser } from "./cff_parser.js";
27 import {
28   FontFlags,
29   getVerticalPresentationForm,
30   MacStandardGlyphOrdering,
31   normalizeFontName,
32   recoverGlyphName,
33   SEAC_ANALYSIS_ENABLED,
34 } from "./fonts_utils.js";
35 import {
36   getCharUnicodeCategory,
37   getUnicodeForGlyph,
38   getUnicodeRangeFor,
39   mapSpecialUnicodeValues,
40 } from "./unicode.js";
41 import { getDingbatsGlyphsUnicode, getGlyphsUnicode } from "./glyphlist.js";
42 import {
43   getEncoding,
44   MacRomanEncoding,
45   StandardEncoding,
46   SymbolSetEncoding,
47   WinAnsiEncoding,
48   ZapfDingbatsEncoding,
49 } from "./encodings.js";
50 import {
51   getGlyphMapForStandardFonts,
52   getNonStdFontMap,
53   getSerifFonts,
54   getStdFontMap,
55   getSupplementalGlyphMapForArialBlack,
56   getSupplementalGlyphMapForCalibri,
57 } from "./standard_fonts.js";
58 import { IdentityToUnicodeMap, ToUnicodeMap } from "./to_unicode_map.js";
59 import { CFFFont } from "./cff_font.js";
60 import { FontRendererFactory } from "./font_renderer.js";
61 import { getFontBasicMetrics } from "./metrics.js";
62 import { GlyfTable } from "./glyf.js";
63 import { IdentityCMap } from "./cmap.js";
64 import { OpenTypeFileBuilder } from "./opentype_file_builder.js";
65 import { readUint32 } from "./core_utils.js";
66 import { Stream } from "./stream.js";
67 import { Type1Font } from "./type1_font.js";
68 
69 // Unicode Private Use Areas:
70 const PRIVATE_USE_AREAS = [
71   [0xe000, 0xf8ff], // BMP (0)
72   [0x100000, 0x10fffd], // PUP (16)
73 ];
74 
75 // PDF Glyph Space Units are one Thousandth of a TextSpace Unit
76 // except for Type 3 fonts
77 const PDF_GLYPH_SPACE_UNITS = 1000;
78 
79 const EXPORT_DATA_PROPERTIES = [
80   "ascent",
81   "bbox",
82   "black",
83   "bold",
84   "charProcOperatorList",
85   "composite",
86   "cssFontInfo",
87   "data",
88   "defaultVMetrics",
89   "defaultWidth",
90   "descent",
91   "fallbackName",
92   "fontMatrix",
93   "isInvalidPDFjsFont",
94   "isType3Font",
95   "italic",
96   "loadedName",
97   "mimetype",
98   "missingFile",
99   "name",
100   "remeasure",
101   "subtype",
102   "systemFontInfo",
103   "type",
104   "vertical",
105 ];
106 
107 const EXPORT_DATA_EXTRA_PROPERTIES = [
108   "cMap",
109   "defaultEncoding",
110   "differences",
111   "isMonospace",
112   "isSerifFont",
113   "isSymbolicFont",
114   "seacMap",
115   "toFontChar",
116   "toUnicode",
117   "vmetrics",
118   "widths",
119 ];
120 
121 function adjustWidths(properties) {
122   if (!properties.fontMatrix) {
123     return;
124   }
125   if (properties.fontMatrix[0] === FONT_IDENTITY_MATRIX[0]) {
126     return;
127   }
128   // adjusting width to fontMatrix scale
129   const scale = 0.001 / properties.fontMatrix[0];
130   const glyphsWidths = properties.widths;
131   for (const glyph in glyphsWidths) {
132     glyphsWidths[glyph] *= scale;
133   }
134   properties.defaultWidth *= scale;
135 }
136 
137 function adjustTrueTypeToUnicode(properties, isSymbolicFont, nameRecords) {
138   if (properties.isInternalFont) {
139     return;
140   }
141   if (properties.hasIncludedToUnicodeMap) {
142     return; // The font dictionary has a `ToUnicode` entry.
143   }
144   if (properties.hasEncoding) {
145     return; // The font dictionary has an `Encoding` entry.
146   }
147   if (properties.toUnicode instanceof IdentityToUnicodeMap) {
148     return;
149   }
150   if (!isSymbolicFont) {
151     return; // A non-symbolic font should default to `StandardEncoding`.
152   }
153   if (nameRecords.length === 0) {
154     return;
155   }
156 
157   // Try to infer if the fallback encoding should really be `WinAnsiEncoding`.
158   if (properties.defaultEncoding === WinAnsiEncoding) {
159     return;
160   }
161   for (const r of nameRecords) {
162     if (!isWinNameRecord(r)) {
163       return; // Not Windows, hence `WinAnsiEncoding` wouldn't make sense.
164     }
165   }
166   const encoding = WinAnsiEncoding;
167 
168   const toUnicode = [],
169     glyphsUnicodeMap = getGlyphsUnicode();
170   for (const charCode in encoding) {
171     const glyphName = encoding[charCode];
172     if (glyphName === "") {
173       continue;
174     }
175     const unicode = glyphsUnicodeMap[glyphName];
176     if (unicode === undefined) {
177       continue;
178     }
179     toUnicode[charCode] = String.fromCharCode(unicode);
180   }
181   if (toUnicode.length > 0) {
182     properties.toUnicode.amend(toUnicode);
183   }
184 }
185 
186 function adjustType1ToUnicode(properties, builtInEncoding) {
187   if (properties.isInternalFont) {
188     return;
189   }
190   if (properties.hasIncludedToUnicodeMap) {
191     return; // The font dictionary has a `ToUnicode` entry.
192   }
193   if (builtInEncoding === properties.defaultEncoding) {
194     return; // No point in trying to adjust `toUnicode` if the encodings match.
195   }
196   if (properties.toUnicode instanceof IdentityToUnicodeMap) {
197     return;
198   }
199   const toUnicode = [],
200     glyphsUnicodeMap = getGlyphsUnicode();
201   for (const charCode in builtInEncoding) {
202     if (properties.hasEncoding) {
203       if (
204         properties.baseEncodingName ||
205         properties.differences[charCode] !== undefined
206       ) {
207         continue; // The font dictionary has an `Encoding`/`Differences` entry.
208       }
209     }
210     const glyphName = builtInEncoding[charCode];
211     const unicode = getUnicodeForGlyph(glyphName, glyphsUnicodeMap);
212     if (unicode !== -1) {
213       toUnicode[charCode] = String.fromCharCode(unicode);
214     }
215   }
216   if (toUnicode.length > 0) {
217     properties.toUnicode.amend(toUnicode);
218   }
219 }
220 
221 /**
222  * NOTE: This function should only be called at the *end* of font-parsing,
223  *       after e.g. `adjustType1ToUnicode` has run, to prevent any issues.
224  */
225 function amendFallbackToUnicode(properties) {
226   if (!properties.fallbackToUnicode) {
227     return;
228   }
229   if (properties.toUnicode instanceof IdentityToUnicodeMap) {
230     return;
231   }
232   const toUnicode = [];
233   for (const charCode in properties.fallbackToUnicode) {
234     if (properties.toUnicode.has(charCode)) {
235       continue; // The font dictionary has a `ToUnicode` entry.
236     }
237     toUnicode[charCode] = properties.fallbackToUnicode[charCode];
238   }
239   if (toUnicode.length > 0) {
240     properties.toUnicode.amend(toUnicode);
241   }
242 }
243 
244 class Glyph {
245   constructor(
246     originalCharCode,
247     fontChar,
248     unicode,
249     accent,
250     width,
251     vmetric,
252     operatorListId,
253     isSpace,
254     isInFont
255   ) {
256     this.originalCharCode = originalCharCode;
257     this.fontChar = fontChar;
258     this.unicode = unicode;
259     this.accent = accent;
260     this.width = width;
261     this.vmetric = vmetric;
262     this.operatorListId = operatorListId;
263     this.isSpace = isSpace;
264     this.isInFont = isInFont;
265   }
266 
267   /**
268    * This property, which is only used by `PartialEvaluator.getTextContent`,
269    * is purposely made non-serializable.
270    * @type {Object}
271    */
272   get category() {
273     return shadow(
274       this,
275       "category",
276       getCharUnicodeCategory(this.unicode),
277       /* nonSerializable = */ true
278     );
279   }
280 }
281 
282 function int16(b0, b1) {
283   return (b0 << 8) + b1;
284 }
285 
286 function writeSignedInt16(bytes, index, value) {
287   bytes[index + 1] = value;
288   bytes[index] = value >>> 8;
289 }
290 
291 function signedInt16(b0, b1) {
292   const value = (b0 << 8) + b1;
293   return value & (1 << 15) ? value - 0x10000 : value;
294 }
295 
296 function writeUint32(bytes, index, value) {
297   bytes[index + 3] = value & 0xff;
298   bytes[index + 2] = value >>> 8;
299   bytes[index + 1] = value >>> 16;
300   bytes[index] = value >>> 24;
301 }
302 
303 function int32(b0, b1, b2, b3) {
304   return (b0 << 24) + (b1 << 16) + (b2 << 8) + b3;
305 }
306 
307 function string16(value) {
308   if (typeof PDFJSDev === "undefined" || PDFJSDev.test("TESTING")) {
309     assert(
310       typeof value === "number" && Math.abs(value) < 2 ** 16,
311       `string16: Unexpected input "${value}".`
312     );
313   }
314   return String.fromCharCode((value >> 8) & 0xff, value & 0xff);
315 }
316 
317 function safeString16(value) {
318   if (typeof PDFJSDev === "undefined" || PDFJSDev.test("TESTING")) {
319     assert(
320       typeof value === "number" && !Number.isNaN(value),
321       `safeString16: Unexpected input "${value}".`
322     );
323   }
324   // clamp value to the 16-bit int range
325   if (value > 0x7fff) {
326     value = 0x7fff;
327   } else if (value < -0x8000) {
328     value = -0x8000;
329   }
330   return String.fromCharCode((value >> 8) & 0xff, value & 0xff);
331 }
332 
333 function isTrueTypeFile(file) {
334   const header = file.peekBytes(4);
335   return (
336     readUint32(header, 0) === 0x00010000 || bytesToString(header) === "true"
337   );
338 }
339 
340 function isTrueTypeCollectionFile(file) {
341   const header = file.peekBytes(4);
342   return bytesToString(header) === "ttcf";
343 }
344 
345 function isOpenTypeFile(file) {
346   const header = file.peekBytes(4);
347   return bytesToString(header) === "OTTO";
348 }
349 
350 function isType1File(file) {
351   const header = file.peekBytes(2);
352   // All Type1 font programs must begin with the comment '%!' (0x25 + 0x21).
353   if (header[0] === 0x25 && header[1] === 0x21) {
354     return true;
355   }
356   // ... obviously some fonts violate that part of the specification,
357   // please refer to the comment in |Type1Font| below (pfb file header).
358   if (header[0] === 0x80 && header[1] === 0x01) {
359     return true;
360   }
361   return false;
362 }
363 
364 /**
365  * Compared to other font formats, the header in CFF files is not constant
366  * but contains version numbers. To reduce the possibility of misclassifying
367  * font files as CFF, it's recommended to check for other font formats first.
368  */
369 function isCFFFile(file) {
370   const header = file.peekBytes(4);
371   if (
372     /* major version, [1, 255] */ header[0] >= 1 &&
373     /* minor version, [0, 255]; header[1] */
374     /* header size, [0, 255]; header[2] */
375     /* offset(0) size, [1, 4] */ header[3] >= 1 &&
376     header[3] <= 4
377   ) {
378     return true;
379   }
380   return false;
381 }
382 
383 function getFontFileType(file, { type, subtype, composite }) {
384   let fileType, fileSubtype;
385 
386   if (isTrueTypeFile(file) || isTrueTypeCollectionFile(file)) {
387     fileType = composite ? "CIDFontType2" : "TrueType";
388   } else if (isOpenTypeFile(file)) {
389     fileType = composite ? "CIDFontType2" : "OpenType";
390   } else if (isType1File(file)) {
391     if (composite) {
392       fileType = "CIDFontType0";
393     } else {
394       fileType = type === "MMType1" ? "MMType1" : "Type1";
395     }
396   } else if (isCFFFile(file)) {
397     if (composite) {
398       fileType = "CIDFontType0";
399       fileSubtype = "CIDFontType0C";
400     } else {
401       fileType = type === "MMType1" ? "MMType1" : "Type1";
402       fileSubtype = "Type1C";
403     }
404   } else {
405     warn("getFontFileType: Unable to detect correct font file Type/Subtype.");
406     fileType = type;
407     fileSubtype = subtype;
408   }
409 
410   return [fileType, fileSubtype];
411 }
412 
413 function applyStandardFontGlyphMap(map, glyphMap) {
414   for (const charCode in glyphMap) {
415     map[+charCode] = glyphMap[charCode];
416   }
417 }
418 
419 function buildToFontChar(encoding, glyphsUnicodeMap, differences) {
420   const toFontChar = [];
421   let unicode;
422   for (let i = 0, ii = encoding.length; i < ii; i++) {
423     unicode = getUnicodeForGlyph(encoding[i], glyphsUnicodeMap);
424     if (unicode !== -1) {
425       toFontChar[i] = unicode;
426     }
427   }
428   for (const charCode in differences) {
429     unicode = getUnicodeForGlyph(differences[charCode], glyphsUnicodeMap);
430     if (unicode !== -1) {
431       toFontChar[+charCode] = unicode;
432     }
433   }
434   return toFontChar;
435 }
436 
437 // Please refer to:
438 //  - https://developer.apple.com/fonts/TrueType-Reference-Manual/RM06/Chap6name.html
439 function isMacNameRecord(r) {
440   return r.platform === 1 && r.encoding === 0 && r.language === 0;
441 }
442 
443 // Please refer to:
444 //  - https://developer.apple.com/fonts/TrueType-Reference-Manual/RM06/Chap6name.html
445 //  - https://learn.microsoft.com/en-us/typography/opentype/spec/name#windows-language-ids
446 function isWinNameRecord(r) {
447   return r.platform === 3 && r.encoding === 1 && r.language === 0x409;
448 }
449 
450 function convertCidString(charCode, cid, shouldThrow = false) {
451   switch (cid.length) {
452     case 1:
453       return cid.charCodeAt(0);
454     case 2:
455       return (cid.charCodeAt(0) << 8) | cid.charCodeAt(1);
456   }
457   const msg = `Unsupported CID string (charCode ${charCode}): "${cid}".`;
458   if (shouldThrow) {
459     throw new FormatError(msg);
460   }
461   warn(msg);
462   return cid;
463 }
464 
465 /**
466  * Rebuilds the char code to glyph ID map by moving all char codes to the
467  * private use area. This is done to avoid issues with various problematic
468  * unicode areas where either a glyph won't be drawn or is deformed by a
469  * shaper.
470  * @returns {Object} Two properties:
471  * 'toFontChar' - maps original char codes(the value that will be read
472  * from commands such as show text) to the char codes that will be used in the
473  * font that we build
474  * 'charCodeToGlyphId' - maps the new font char codes to glyph ids
475  */
476 function adjustMapping(charCodeToGlyphId, hasGlyph, newGlyphZeroId, toUnicode) {
477   const newMap = Object.create(null);
478   const toUnicodeExtraMap = new Map();
479   const toFontChar = [];
480   const usedGlyphIds = new Set();
481   let privateUseAreaIndex = 0;
482   const privateUseOffetStart = PRIVATE_USE_AREAS[privateUseAreaIndex][0];
483   let nextAvailableFontCharCode = privateUseOffetStart;
484   let privateUseOffetEnd = PRIVATE_USE_AREAS[privateUseAreaIndex][1];
485   const isInPrivateArea = code =>
486     (PRIVATE_USE_AREAS[0][0] <= code && code <= PRIVATE_USE_AREAS[0][1]) ||
487     (PRIVATE_USE_AREAS[1][0] <= code && code <= PRIVATE_USE_AREAS[1][1]);
488   for (const originalCharCode in charCodeToGlyphId) {
489     let glyphId = charCodeToGlyphId[originalCharCode];
490     // For missing glyphs don't create the mappings so the glyph isn't
491     // drawn.
492     if (!hasGlyph(glyphId)) {
493       continue;
494     }
495     if (nextAvailableFontCharCode > privateUseOffetEnd) {
496       privateUseAreaIndex++;
497       if (privateUseAreaIndex >= PRIVATE_USE_AREAS.length) {
498         warn("Ran out of space in font private use area.");
499         break;
500       }
501       nextAvailableFontCharCode = PRIVATE_USE_AREAS[privateUseAreaIndex][0];
502       privateUseOffetEnd = PRIVATE_USE_AREAS[privateUseAreaIndex][1];
503     }
504     const fontCharCode = nextAvailableFontCharCode++;
505     if (glyphId === 0) {
506       glyphId = newGlyphZeroId;
507     }
508 
509     // Fix for bug 1778484:
510     // The charcodes are moved into a private use area to fix some rendering
511     // issues (https://github.com/mozilla/pdf.js/pull/9340) but when printing
512     // to PDF the generated font will contain wrong chars. We can avoid that by
513     // adding the unicode to the cmap and the print backend will then map the
514     // glyph ids to the correct unicode.
515     let unicode = toUnicode.get(originalCharCode);
516     if (typeof unicode === "string") {
517       unicode = unicode.codePointAt(0);
518     }
519     if (unicode && !isInPrivateArea(unicode) && !usedGlyphIds.has(glyphId)) {
520       toUnicodeExtraMap.set(unicode, glyphId);
521       usedGlyphIds.add(glyphId);
522     }
523 
524     newMap[fontCharCode] = glyphId;
525     toFontChar[originalCharCode] = fontCharCode;
526   }
527   return {
528     toFontChar,
529     charCodeToGlyphId: newMap,
530     toUnicodeExtraMap,
531     nextAvailableFontCharCode,
532   };
533 }
534 
535 function getRanges(glyphs, toUnicodeExtraMap, numGlyphs) {
536   // Array.sort() sorts by characters, not numerically, so convert to an
537   // array of characters.
538   const codes = [];
539   for (const charCode in glyphs) {
540     // Remove an invalid glyph ID mappings to make OTS happy.
541     if (glyphs[charCode] >= numGlyphs) {
542       continue;
543     }
544     codes.push({ fontCharCode: charCode | 0, glyphId: glyphs[charCode] });
545   }
546   if (toUnicodeExtraMap) {
547     for (const [unicode, glyphId] of toUnicodeExtraMap) {
548       if (glyphId >= numGlyphs) {
549         continue;
550       }
551       codes.push({ fontCharCode: unicode, glyphId });
552     }
553   }
554   // Some fonts have zero glyphs and are used only for text selection, but
555   // there needs to be at least one to build a valid cmap table.
556   if (codes.length === 0) {
557     codes.push({ fontCharCode: 0, glyphId: 0 });
558   }
559   codes.sort(function fontGetRangesSort(a, b) {
560     return a.fontCharCode - b.fontCharCode;
561   });
562 
563   // Split the sorted codes into ranges.
564   const ranges = [];
565   const length = codes.length;
566   for (let n = 0; n < length; ) {
567     const start = codes[n].fontCharCode;
568     const codeIndices = [codes[n].glyphId];
569     ++n;
570     let end = start;
571     while (n < length && end + 1 === codes[n].fontCharCode) {
572       codeIndices.push(codes[n].glyphId);
573       ++end;
574       ++n;
575       if (end === 0xffff) {
576         break;
577       }
578     }
579     ranges.push([start, end, codeIndices]);
580   }
581 
582   return ranges;
583 }
584 
585 function createCmapTable(glyphs, toUnicodeExtraMap, numGlyphs) {
586   const ranges = getRanges(glyphs, toUnicodeExtraMap, numGlyphs);
587   const numTables = ranges.at(-1)[1] > 0xffff ? 2 : 1;
588   let cmap =
589     "\x00\x00" + // version
590     string16(numTables) + // numTables
591     "\x00\x03" + // platformID
592     "\x00\x01" + // encodingID
593     string32(4 + numTables * 8); // start of the table record
594 
595   let i, ii, j, jj;
596   for (i = ranges.length - 1; i >= 0; --i) {
597     if (ranges[i][0] <= 0xffff) {
598       break;
599     }
600   }
601   const bmpLength = i + 1;
602 
603   if (ranges[i][0] < 0xffff && ranges[i][1] === 0xffff) {
604     ranges[i][1] = 0xfffe;
605   }
606   const trailingRangesCount = ranges[i][1] < 0xffff ? 1 : 0;
607   const segCount = bmpLength + trailingRangesCount;
608   const searchParams = OpenTypeFileBuilder.getSearchParams(segCount, 2);
609 
610   // Fill up the 4 parallel arrays describing the segments.
611   let startCount = "";
612   let endCount = "";
613   let idDeltas = "";
614   let idRangeOffsets = "";
615   let glyphsIds = "";
616   let bias = 0;
617 
618   let range, start, end, codes;
619   for (i = 0, ii = bmpLength; i < ii; i++) {
620     range = ranges[i];
621     start = range[0];
622     end = range[1];
623     startCount += string16(start);
624     endCount += string16(end);
625     codes = range[2];
626     let contiguous = true;
627     for (j = 1, jj = codes.length; j < jj; ++j) {
628       if (codes[j] !== codes[j - 1] + 1) {
629         contiguous = false;
630         break;
631       }
632     }
633     if (!contiguous) {
634       const offset = (segCount - i) * 2 + bias * 2;
635       bias += end - start + 1;
636 
637       idDeltas += string16(0);
638       idRangeOffsets += string16(offset);
639 
640       for (j = 0, jj = codes.length; j < jj; ++j) {
641         glyphsIds += string16(codes[j]);
642       }
643     } else {
644       const startCode = codes[0];
645 
646       idDeltas += string16((startCode - start) & 0xffff);
647       idRangeOffsets += string16(0);
648     }
649   }
650 
651   if (trailingRangesCount > 0) {
652     endCount += "\xFF\xFF";
653     startCount += "\xFF\xFF";
654     idDeltas += "\x00\x01";
655     idRangeOffsets += "\x00\x00";
656   }
657 
658   const format314 =
659     "\x00\x00" + // language
660     string16(2 * segCount) +
661     string16(searchParams.range) +
662     string16(searchParams.entry) +
663     string16(searchParams.rangeShift) +
664     endCount +
665     "\x00\x00" +
666     startCount +
667     idDeltas +
668     idRangeOffsets +
669     glyphsIds;
670 
671   let format31012 = "";
672   let header31012 = "";
673   if (numTables > 1) {
674     cmap +=
675       "\x00\x03" + // platformID
676       "\x00\x0A" + // encodingID
677       string32(4 + numTables * 8 + 4 + format314.length); // start of the table record
678     format31012 = "";
679     for (i = 0, ii = ranges.length; i < ii; i++) {
680       range = ranges[i];
681       start = range[0];
682       codes = range[2];
683       let code = codes[0];
684       for (j = 1, jj = codes.length; j < jj; ++j) {
685         if (codes[j] !== codes[j - 1] + 1) {
686           end = range[0] + j - 1;
687           format31012 +=
688             string32(start) + // startCharCode
689             string32(end) + // endCharCode
690             string32(code); // startGlyphID
691           start = end + 1;
692           code = codes[j];
693         }
694       }
695       format31012 +=
696         string32(start) + // startCharCode
697         string32(range[1]) + // endCharCode
698         string32(code); // startGlyphID
699     }
700     header31012 =
701       "\x00\x0C" + // format
702       "\x00\x00" + // reserved
703       string32(format31012.length + 16) + // length
704       "\x00\x00\x00\x00" + // language
705       string32(format31012.length / 12); // nGroups
706   }
707 
708   return (
709     cmap +
710     "\x00\x04" + // format
711     string16(format314.length + 4) + // length
712     format314 +
713     header31012 +
714     format31012
715   );
716 }
717 
718 function validateOS2Table(os2, file) {
719   file.pos = (file.start || 0) + os2.offset;
720   const version = file.getUint16();
721   // TODO verify all OS/2 tables fields, but currently we validate only those
722   // that give us issues
723   file.skip(60); // skipping type, misc sizes, panose, unicode ranges
724   const selection = file.getUint16();
725   if (version < 4 && selection & 0x0300) {
726     return false;
727   }
728   const firstChar = file.getUint16();
729   const lastChar = file.getUint16();
730   if (firstChar > lastChar) {
731     return false;
732   }
733   file.skip(6); // skipping sTypoAscender/Descender/LineGap
734   const usWinAscent = file.getUint16();
735   if (usWinAscent === 0) {
736     // makes font unreadable by windows
737     return false;
738   }
739 
740   // OS/2 appears to be valid, resetting some fields
741   os2.data[8] = os2.data[9] = 0; // IE rejects fonts if fsType != 0
742   return true;
743 }
744 
745 function createOS2Table(properties, charstrings, override) {
746   override ||= {
747     unitsPerEm: 0,
748     yMax: 0,
749     yMin: 0,
750     ascent: 0,
751     descent: 0,
752   };
753 
754   let ulUnicodeRange1 = 0;
755   let ulUnicodeRange2 = 0;
756   let ulUnicodeRange3 = 0;
757   let ulUnicodeRange4 = 0;
758 
759   let firstCharIndex = null;
760   let lastCharIndex = 0;
761   let position = -1;
762 
763   if (charstrings) {
764     for (let code in charstrings) {
765       code |= 0;
766       if (firstCharIndex > code || !firstCharIndex) {
767         firstCharIndex = code;
768       }
769       if (lastCharIndex < code) {
770         lastCharIndex = code;
771       }
772 
773       position = getUnicodeRangeFor(code, position);
774       if (position < 32) {
775         ulUnicodeRange1 |= 1 << position;
776       } else if (position < 64) {
777         ulUnicodeRange2 |= 1 << (position - 32);
778       } else if (position < 96) {
779         ulUnicodeRange3 |= 1 << (position - 64);
780       } else if (position < 123) {
781         ulUnicodeRange4 |= 1 << (position - 96);
782       } else {
783         throw new FormatError(
784           "Unicode ranges Bits > 123 are reserved for internal usage"
785         );
786       }
787     }
788     if (lastCharIndex > 0xffff) {
789       // OS2 only supports a 16 bit int. The spec says if supplementary
790       // characters are used the field should just be set to 0xFFFF.
791       lastCharIndex = 0xffff;
792     }
793   } else {
794     // TODO
795     firstCharIndex = 0;
796     lastCharIndex = 255;
797   }
798 
799   const bbox = properties.bbox || [0, 0, 0, 0];
800   const unitsPerEm =
801     override.unitsPerEm ||
802     (properties.fontMatrix
803       ? 1 / Math.max(...properties.fontMatrix.slice(0, 4).map(Math.abs))
804       : 1000);
805 
806   // if the font units differ to the PDF glyph space units
807   // then scale up the values
808   const scale = properties.ascentScaled
809     ? 1.0
810     : unitsPerEm / PDF_GLYPH_SPACE_UNITS;
811 
812   const typoAscent =
813     override.ascent || Math.round(scale * (properties.ascent || bbox[3]));
814   let typoDescent =
815     override.descent || Math.round(scale * (properties.descent || bbox[1]));
816   if (typoDescent > 0 && properties.descent > 0 && bbox[1] < 0) {
817     typoDescent = -typoDescent; // fixing incorrect descent
818   }
819   const winAscent = override.yMax || typoAscent;
820   const winDescent = -override.yMin || -typoDescent;
821 
822   return (
823     "\x00\x03" + // version
824     "\x02\x24" + // xAvgCharWidth
825     "\x01\xF4" + // usWeightClass
826     "\x00\x05" + // usWidthClass
827     "\x00\x00" + // fstype (0 to let the font loads via font-face on IE)
828     "\x02\x8A" + // ySubscriptXSize
829     "\x02\xBB" + // ySubscriptYSize
830     "\x00\x00" + // ySubscriptXOffset
831     "\x00\x8C" + // ySubscriptYOffset
832     "\x02\x8A" + // ySuperScriptXSize
833     "\x02\xBB" + // ySuperScriptYSize
834     "\x00\x00" + // ySuperScriptXOffset
835     "\x01\xDF" + // ySuperScriptYOffset
836     "\x00\x31" + // yStrikeOutSize
837     "\x01\x02" + // yStrikeOutPosition
838     "\x00\x00" + // sFamilyClass
839     "\x00\x00\x06" +
840     String.fromCharCode(properties.fixedPitch ? 0x09 : 0x00) +
841     "\x00\x00\x00\x00\x00\x00" + // Panose
842     string32(ulUnicodeRange1) + // ulUnicodeRange1 (Bits 0-31)
843     string32(ulUnicodeRange2) + // ulUnicodeRange2 (Bits 32-63)
844     string32(ulUnicodeRange3) + // ulUnicodeRange3 (Bits 64-95)
845     string32(ulUnicodeRange4) + // ulUnicodeRange4 (Bits 96-127)
846     "\x2A\x32\x31\x2A" + // achVendID
847     string16(properties.italicAngle ? 1 : 0) + // fsSelection
848     string16(firstCharIndex || properties.firstChar) + // usFirstCharIndex
849     string16(lastCharIndex || properties.lastChar) + // usLastCharIndex
850     string16(typoAscent) + // sTypoAscender
851     string16(typoDescent) + // sTypoDescender
852     "\x00\x64" + // sTypoLineGap (7%-10% of the unitsPerEM value)
853     string16(winAscent) + // usWinAscent
854     string16(winDescent) + // usWinDescent
855     "\x00\x00\x00\x00" + // ulCodePageRange1 (Bits 0-31)
856     "\x00\x00\x00\x00" + // ulCodePageRange2 (Bits 32-63)
857     string16(properties.xHeight) + // sxHeight
858     string16(properties.capHeight) + // sCapHeight
859     string16(0) + // usDefaultChar
860     string16(firstCharIndex || properties.firstChar) + // usBreakChar
861     "\x00\x03"
862   ); // usMaxContext
863 }
864 
865 function createPostTable(properties) {
866   const angle = Math.floor(properties.italicAngle * 2 ** 16);
867   return (
868     "\x00\x03\x00\x00" + // Version number
869     string32(angle) + // italicAngle
870     "\x00\x00" + // underlinePosition
871     "\x00\x00" + // underlineThickness
872     string32(properties.fixedPitch ? 1 : 0) + // isFixedPitch
873     "\x00\x00\x00\x00" + // minMemType42
874     "\x00\x00\x00\x00" + // maxMemType42
875     "\x00\x00\x00\x00" + // minMemType1
876     "\x00\x00\x00\x00"
877   ); // maxMemType1
878 }
879 
880 function createPostscriptName(name) {
881   // See https://docs.microsoft.com/en-us/typography/opentype/spec/recom#name.
882   return name.replaceAll(/[^\x21-\x7E]|[[\](){}<>/%]/g, "").slice(0, 63);
883 }
884 
885 function createNameTable(name, proto) {
886   if (!proto) {
887     proto = [[], []]; // no strings and unicode strings
888   }
889 
890   const strings = [
891     proto[0][0] || "Original licence", // 0.Copyright
892     proto[0][1] || name, // 1.Font family
893     proto[0][2] || "Unknown", // 2.Font subfamily (font weight)
894     proto[0][3] || "uniqueID", // 3.Unique ID
895     proto[0][4] || name, // 4.Full font name
896     proto[0][5] || "Version 0.11", // 5.Version
897     proto[0][6] || createPostscriptName(name), // 6.Postscript name
898     proto[0][7] || "Unknown", // 7.Trademark
899     proto[0][8] || "Unknown", // 8.Manufacturer
900     proto[0][9] || "Unknown", // 9.Designer
901   ];
902 
903   // Mac want 1-byte per character strings while Windows want
904   // 2-bytes per character, so duplicate the names table
905   const stringsUnicode = [];
906   let i, ii, j, jj, str;
907   for (i = 0, ii = strings.length; i < ii; i++) {
908     str = proto[1][i] || strings[i];
909 
910     const strBufUnicode = [];
911     for (j = 0, jj = str.length; j < jj; j++) {
912       strBufUnicode.push(string16(str.charCodeAt(j)));
913     }
914     stringsUnicode.push(strBufUnicode.join(""));
915   }
916 
917   const names = [strings, stringsUnicode];
918   const platforms = ["\x00\x01", "\x00\x03"];
919   const encodings = ["\x00\x00", "\x00\x01"];
920   const languages = ["\x00\x00", "\x04\x09"];
921 
922   const namesRecordCount = strings.length * platforms.length;
923   let nameTable =
924     "\x00\x00" + // format
925     string16(namesRecordCount) + // Number of names Record
926     string16(namesRecordCount * 12 + 6); // Storage
927 
928   // Build the name records field
929   let strOffset = 0;
930   for (i = 0, ii = platforms.length; i < ii; i++) {
931     const strs = names[i];
932     for (j = 0, jj = strs.length; j < jj; j++) {
933       str = strs[j];
934       const nameRecord =
935         platforms[i] + // platform ID
936         encodings[i] + // encoding ID
937         languages[i] + // language ID
938         string16(j) + // name ID
939         string16(str.length) +
940         string16(strOffset);
941       nameTable += nameRecord;
942       strOffset += str.length;
943     }
944   }
945 
946   nameTable += strings.join("") + stringsUnicode.join("");
947   return nameTable;
948 }
949 
950 /**
951  * 'Font' is the class the outside world should use, it encapsulate all the font
952  * decoding logics whatever type it is (assuming the font type is supported).
953  */
954 class Font {
955   constructor(name, file, properties) {
956     this.name = name;
957     this.psName = null;
958     this.mimetype = null;
959     this.disableFontFace = false;
960 
961     this.loadedName = properties.loadedName;
962     this.isType3Font = properties.isType3Font;
963     this.missingFile = false;
964     this.cssFontInfo = properties.cssFontInfo;
965 
966     this._charsCache = Object.create(null);
967     this._glyphCache = Object.create(null);
968 
969     let isSerifFont = !!(properties.flags & FontFlags.Serif);
970     // Fallback to checking the font name, in order to improve text-selection,
971     // since the /Flags-entry is often wrong (fixes issue13845.pdf).
972     if (!isSerifFont && !properties.isSimulatedFlags) {
973       const baseName = name.replaceAll(/[,_]/g, "-").split("-", 1)[0],
974         serifFonts = getSerifFonts();
975       for (const namePart of baseName.split("+")) {
976         if (serifFonts[namePart]) {
977           isSerifFont = true;
978           break;
979         }
980       }
981     }
982     this.isSerifFont = isSerifFont;
983 
984     this.isSymbolicFont = !!(properties.flags & FontFlags.Symbolic);
985     this.isMonospace = !!(properties.flags & FontFlags.FixedPitch);
986 
987     let { type, subtype } = properties;
988     this.type = type;
989     this.subtype = subtype;
990     this.systemFontInfo = properties.systemFontInfo;
991 
992     const matches = name.match(/^InvalidPDFjsFont_(.*)_\d+$/);
993     this.isInvalidPDFjsFont = !!matches;
994     if (this.isInvalidPDFjsFont) {
995       this.fallbackName = matches[1];
996     } else if (this.isMonospace) {
997       this.fallbackName = "monospace";
998     } else if (this.isSerifFont) {
999       this.fallbackName = "serif";
1000     } else {
1001       this.fallbackName = "sans-serif";
1002     }
1003 
1004     if (this.systemFontInfo?.guessFallback) {
1005       // Once the fallback name is guessed, we don't want to guess it again.
1006       this.systemFontInfo.guessFallback = false;
1007       this.systemFontInfo.css += `,${this.fallbackName}`;
1008     }
1009 
1010     this.differences = properties.differences;
1011     this.widths = properties.widths;
1012     this.defaultWidth = properties.defaultWidth;
1013     this.composite = properties.composite;
1014     this.cMap = properties.cMap;
1015     this.capHeight = properties.capHeight / PDF_GLYPH_SPACE_UNITS;
1016     this.ascent = properties.ascent / PDF_GLYPH_SPACE_UNITS;
1017     this.descent = properties.descent / PDF_GLYPH_SPACE_UNITS;
1018     this.lineHeight = this.ascent - this.descent;
1019     this.fontMatrix = properties.fontMatrix;
1020     this.bbox = properties.bbox;
1021     this.defaultEncoding = properties.defaultEncoding;
1022 
1023     this.toUnicode = properties.toUnicode;
1024     this.toFontChar = [];
1025 
1026     if (properties.type === "Type3") {
1027       for (let charCode = 0; charCode < 256; charCode++) {
1028         this.toFontChar[charCode] =
1029           this.differences[charCode] || properties.defaultEncoding[charCode];
1030       }
1031       return;
1032     }
1033 
1034     this.cidEncoding = properties.cidEncoding || "";
1035     this.vertical = !!properties.vertical;
1036     if (this.vertical) {
1037       this.vmetrics = properties.vmetrics;
1038       this.defaultVMetrics = properties.defaultVMetrics;
1039     }
1040 
1041     if (!file || file.isEmpty) {
1042       if (file) {
1043         // Some bad PDF generators will include empty font files,
1044         // attempting to recover by assuming that no file exists.
1045         warn('Font file is empty in "' + name + '" (' + this.loadedName + ")");
1046       }
1047       this.fallbackToSystemFont(properties);
1048       return;
1049     }
1050 
1051     // Parse the font file to determine the correct type/subtype, rather than
1052     // relying on the (often incorrect) data in the font dictionary; (see e.g.
1053     //  issue6782.pdf, issue7598.pdf, and issue9949.pdf).
1054     [type, subtype] = getFontFileType(file, properties);
1055 
1056     if (type !== this.type || subtype !== this.subtype) {
1057       info(
1058         "Inconsistent font file Type/SubType, expected: " +
1059           `${this.type}/${this.subtype} but found: ${type}/${subtype}.`
1060       );
1061     }
1062 
1063     let data;
1064     try {
1065       switch (type) {
1066         case "MMType1":
1067           info("MMType1 font (" + name + "), falling back to Type1.");
1068         /* falls through */
1069         case "Type1":
1070         case "CIDFontType0":
1071           this.mimetype = "font/opentype";
1072 
1073           const cff =
1074             subtype === "Type1C" || subtype === "CIDFontType0C"
1075               ? new CFFFont(file, properties)
1076               : new Type1Font(name, file, properties);
1077 
1078           adjustWidths(properties);
1079 
1080           // Wrap the CFF data inside an OTF font file
1081           data = this.convert(name, cff, properties);
1082           break;
1083 
1084         case "OpenType":
1085         case "TrueType":
1086         case "CIDFontType2":
1087           this.mimetype = "font/opentype";
1088 
1089           // Repair the TrueType file. It is can be damaged in the point of
1090           // view of the sanitizer
1091           data = this.checkAndRepair(name, file, properties);
1092           if (this.isOpenType) {
1093             adjustWidths(properties);
1094 
1095             type = "OpenType";
1096           }
1097           break;
1098 
1099         default:
1100           throw new FormatError(`Font ${type} is not supported`);
1101       }
1102     } catch (e) {
1103       warn(e);
1104       this.fallbackToSystemFont(properties);
1105       return;
1106     }
1107 
1108     amendFallbackToUnicode(properties);
1109     this.data = data;
1110 
1111     // Transfer some properties again that could change during font conversion
1112     this.type = type;
1113     this.subtype = subtype;
1114     this.fontMatrix = properties.fontMatrix;
1115     this.widths = properties.widths;
1116     this.defaultWidth = properties.defaultWidth;
1117     this.toUnicode = properties.toUnicode;
1118     this.seacMap = properties.seacMap;
1119   }
1120 
1121   get renderer() {
1122     const renderer = FontRendererFactory.create(this, SEAC_ANALYSIS_ENABLED);
1123     return shadow(this, "renderer", renderer);
1124   }
1125 
1126   exportData(extraProperties = false) {
1127     const exportDataProperties = extraProperties
1128       ? [...EXPORT_DATA_PROPERTIES, ...EXPORT_DATA_EXTRA_PROPERTIES]
1129       : EXPORT_DATA_PROPERTIES;
1130 
1131     const data = Object.create(null);
1132     let property, value;
1133     for (property of exportDataProperties) {
1134       value = this[property];
1135       // Ignore properties that haven't been explicitly set.
1136       if (value !== undefined) {
1137         data[property] = value;
1138       }
1139     }
1140     return data;
1141   }
1142 
1143   fallbackToSystemFont(properties) {
1144     this.missingFile = true;
1145     // The file data is not specified. Trying to fix the font name
1146     // to be used with the canvas.font.
1147     const { name, type } = this;
1148     let fontName = normalizeFontName(name);
1149     const stdFontMap = getStdFontMap(),
1150       nonStdFontMap = getNonStdFontMap();
1151     const isStandardFont = !!stdFontMap[fontName];
1152     const isMappedToStandardFont = !!(
1153       nonStdFontMap[fontName] && stdFontMap[nonStdFontMap[fontName]]
1154     );
1155 
1156     fontName = stdFontMap[fontName] || nonStdFontMap[fontName] || fontName;
1157 
1158     const fontBasicMetricsMap = getFontBasicMetrics();
1159     const metrics = fontBasicMetricsMap[fontName];
1160     if (metrics) {
1161       if (isNaN(this.ascent)) {
1162         this.ascent = metrics.ascent / PDF_GLYPH_SPACE_UNITS;
1163       }
1164       if (isNaN(this.descent)) {
1165         this.descent = metrics.descent / PDF_GLYPH_SPACE_UNITS;
1166       }
1167       if (isNaN(this.capHeight)) {
1168         this.capHeight = metrics.capHeight / PDF_GLYPH_SPACE_UNITS;
1169       }
1170     }
1171 
1172     this.bold = /bold/gi.test(fontName);
1173     this.italic = /oblique|italic/gi.test(fontName);
1174 
1175     // Use 'name' instead of 'fontName' here because the original
1176     // name ArialBlack for example will be replaced by Helvetica.
1177     this.black = /Black/g.test(name);
1178 
1179     // Use 'name' instead of 'fontName' here because the original
1180     // name ArialNarrow for example will be replaced by Helvetica.
1181     const isNarrow = /Narrow/g.test(name);
1182 
1183     // if at least one width is present, remeasure all chars when exists
1184     this.remeasure =
1185       (!isStandardFont || isNarrow) && Object.keys(this.widths).length > 0;
1186     if (
1187       (isStandardFont || isMappedToStandardFont) &&
1188       type === "CIDFontType2" &&
1189       this.cidEncoding.startsWith("Identity-")
1190     ) {
1191       const cidToGidMap = properties.cidToGidMap;
1192       // Standard fonts might be embedded as CID font without glyph mapping.
1193       // Building one based on GlyphMapForStandardFonts.
1194       const map = [];
1195       applyStandardFontGlyphMap(map, getGlyphMapForStandardFonts());
1196 
1197       if (/Arial-?Black/i.test(name)) {
1198         applyStandardFontGlyphMap(map, getSupplementalGlyphMapForArialBlack());
1199       } else if (/Calibri/i.test(name)) {
1200         applyStandardFontGlyphMap(map, getSupplementalGlyphMapForCalibri());
1201       }
1202 
1203       // Always update the glyph mapping with the `cidToGidMap` when it exists
1204       // (fixes issue12418_reduced.pdf).
1205       if (cidToGidMap) {
1206         for (const charCode in map) {
1207           const cid = map[charCode];
1208           if (cidToGidMap[cid] !== undefined) {
1209             map[+charCode] = cidToGidMap[cid];
1210           }
1211         }
1212         // When the /CIDToGIDMap is "incomplete", fallback to the included
1213         // /ToUnicode-map regardless of its encoding (fixes issue11915.pdf).
1214         if (
1215           cidToGidMap.length !== this.toUnicode.length &&
1216           properties.hasIncludedToUnicodeMap &&
1217           this.toUnicode instanceof IdentityToUnicodeMap
1218         ) {
1219           this.toUnicode.forEach(function (charCode, unicodeCharCode) {
1220             const cid = map[charCode];
1221             if (cidToGidMap[cid] === undefined) {
1222               map[+charCode] = unicodeCharCode;
1223             }
1224           });
1225         }
1226       }
1227 
1228       if (!(this.toUnicode instanceof IdentityToUnicodeMap)) {
1229         this.toUnicode.forEach(function (charCode, unicodeCharCode) {
1230           map[+charCode] = unicodeCharCode;
1231         });
1232       }
1233       this.toFontChar = map;
1234       this.toUnicode = new ToUnicodeMap(map);
1235     } else if (/Symbol/i.test(fontName)) {
1236       this.toFontChar = buildToFontChar(
1237         SymbolSetEncoding,
1238         getGlyphsUnicode(),
1239         this.differences
1240       );
1241     } else if (/Dingbats/i.test(fontName)) {
1242       this.toFontChar = buildToFontChar(
1243         ZapfDingbatsEncoding,
1244         getDingbatsGlyphsUnicode(),
1245         this.differences
1246       );
1247     } else if (isStandardFont || isMappedToStandardFont) {
1248       const map = buildToFontChar(
1249         this.defaultEncoding,
1250         getGlyphsUnicode(),
1251         this.differences
1252       );
1253 
1254       if (
1255         type === "CIDFontType2" &&
1256         !this.cidEncoding.startsWith("Identity-") &&
1257         !(this.toUnicode instanceof IdentityToUnicodeMap)
1258       ) {
1259         this.toUnicode.forEach(function (charCode, unicodeCharCode) {
1260           map[+charCode] = unicodeCharCode;
1261         });
1262       }
1263       this.toFontChar = map;
1264     } else {
1265       const glyphsUnicodeMap = getGlyphsUnicode();
1266       const map = [];
1267       this.toUnicode.forEach((charCode, unicodeCharCode) => {
1268         if (!this.composite) {
1269           const glyphName =
1270             this.differences[charCode] || this.defaultEncoding[charCode];
1271           const unicode = getUnicodeForGlyph(glyphName, glyphsUnicodeMap);
1272           if (unicode !== -1) {
1273             unicodeCharCode = unicode;
1274           }
1275         }
1276         map[+charCode] = unicodeCharCode;
1277       });
1278 
1279       // Attempt to improve the glyph mapping for (some) composite fonts that
1280       // appear to lack meaningful ToUnicode data.
1281       if (this.composite && this.toUnicode instanceof IdentityToUnicodeMap) {
1282         if (/Tahoma|Verdana/i.test(name)) {
1283           // Fixes issue15719.pdf and issue11242_reduced.pdf.
1284           applyStandardFontGlyphMap(map, getGlyphMapForStandardFonts());
1285         }
1286       }
1287       this.toFontChar = map;
1288     }
1289 
1290     amendFallbackToUnicode(properties);
1291     this.loadedName = fontName.split("-", 1)[0];
1292   }
1293 
1294   checkAndRepair(name, font, properties) {
1295     const VALID_TABLES = [
1296       "OS/2",
1297       "cmap",
1298       "head",
1299       "hhea",
1300       "hmtx",
1301       "maxp",
1302       "name",
1303       "post",
1304       "loca",
1305       "glyf",
1306       "fpgm",
1307       "prep",
1308       "cvt ",
1309       "CFF ",
1310     ];
1311 
1312     function readTables(file, numTables) {
1313       const tables = Object.create(null);
1314       tables["OS/2"] = null;
1315       tables.cmap = null;
1316       tables.head = null;
1317       tables.hhea = null;
1318       tables.hmtx = null;
1319       tables.maxp = null;
1320       tables.name = null;
1321       tables.post = null;
1322 
1323       for (let i = 0; i < numTables; i++) {
1324         const table = readTableEntry(file);
1325         if (!VALID_TABLES.includes(table.tag)) {
1326           continue; // skipping table if it's not a required or optional table
1327         }
1328         if (table.length === 0) {
1329           continue; // skipping empty tables
1330         }
1331         tables[table.tag] = table;
1332       }
1333       return tables;
1334     }
1335 
1336     function readTableEntry(file) {
1337       const tag = file.getString(4);
1338 
1339       const checksum = file.getInt32() >>> 0;
1340       const offset = file.getInt32() >>> 0;
1341       const length = file.getInt32() >>> 0;
1342 
1343       // Read the table associated data
1344       const previousPosition = file.pos;
1345       file.pos = file.start || 0;
1346       file.skip(offset);
1347       const data = file.getBytes(length);
1348       file.pos = previousPosition;
1349 
1350       if (tag === "head") {
1351         // clearing checksum adjustment
1352         data[8] = data[9] = data[10] = data[11] = 0;
1353         data[17] |= 0x20; // Set font optimized for cleartype flag.
1354       }
1355 
1356       return {
1357         tag,
1358         checksum,
1359         length,
1360         offset,
1361         data,
1362       };
1363     }
1364 
1365     function readOpenTypeHeader(ttf) {
1366       return {
1367         version: ttf.getString(4),
1368         numTables: ttf.getUint16(),
1369         searchRange: ttf.getUint16(),
1370         entrySelector: ttf.getUint16(),
1371         rangeShift: ttf.getUint16(),
1372       };
1373     }
1374 
1375     function readTrueTypeCollectionHeader(ttc) {
1376       const ttcTag = ttc.getString(4);
1377       assert(ttcTag === "ttcf", "Must be a TrueType Collection font.");
1378 
1379       const majorVersion = ttc.getUint16();
1380       const minorVersion = ttc.getUint16();
1381       const numFonts = ttc.getInt32() >>> 0;
1382       const offsetTable = [];
1383       for (let i = 0; i < numFonts; i++) {
1384         offsetTable.push(ttc.getInt32() >>> 0);
1385       }
1386 
1387       const header = {
1388         ttcTag,
1389         majorVersion,
1390         minorVersion,
1391         numFonts,
1392         offsetTable,
1393       };
1394       switch (majorVersion) {
1395         case 1:
1396           return header;
1397         case 2:
1398           header.dsigTag = ttc.getInt32() >>> 0;
1399           header.dsigLength = ttc.getInt32() >>> 0;
1400           header.dsigOffset = ttc.getInt32() >>> 0;
1401           return header;
1402       }
1403       throw new FormatError(
1404         `Invalid TrueType Collection majorVersion: ${majorVersion}.`
1405       );
1406     }
1407 
1408     function readTrueTypeCollectionData(ttc, fontName) {
1409       const { numFonts, offsetTable } = readTrueTypeCollectionHeader(ttc);
1410       const fontNameParts = fontName.split("+");
1411       let fallbackData;
1412 
1413       for (let i = 0; i < numFonts; i++) {
1414         ttc.pos = (ttc.start || 0) + offsetTable[i];
1415         const potentialHeader = readOpenTypeHeader(ttc);
1416         const potentialTables = readTables(ttc, potentialHeader.numTables);
1417 
1418         if (!potentialTables.name) {
1419           throw new FormatError(
1420             'TrueType Collection font must contain a "name" table.'
1421           );
1422         }
1423         const [nameTable] = readNameTable(potentialTables.name);
1424 
1425         for (let j = 0, jj = nameTable.length; j < jj; j++) {
1426           for (let k = 0, kk = nameTable[j].length; k < kk; k++) {
1427             const nameEntry = nameTable[j][k]?.replaceAll(/\s/g, "");
1428             if (!nameEntry) {
1429               continue;
1430             }
1431             if (nameEntry === fontName) {
1432               return {
1433                 header: potentialHeader,
1434                 tables: potentialTables,
1435               };
1436             }
1437             if (fontNameParts.length < 2) {
1438               continue;
1439             }
1440             for (const part of fontNameParts) {
1441               if (nameEntry === part) {
1442                 fallbackData = {
1443                   name: part,
1444                   header: potentialHeader,
1445                   tables: potentialTables,
1446                 };
1447               }
1448             }
1449           }
1450         }
1451       }
1452       if (fallbackData) {
1453         warn(
1454           `TrueType Collection does not contain "${fontName}" font, ` +
1455             `falling back to "${fallbackData.name}" font instead.`
1456         );
1457         return {
1458           header: fallbackData.header,
1459           tables: fallbackData.tables,
1460         };
1461       }
1462       throw new FormatError(
1463         `TrueType Collection does not contain "${fontName}" font.`
1464       );
1465     }
1466 
1467     /**
1468      * Read the appropriate subtable from the cmap according to 9.6.6.4 from
1469      * PDF spec
1470      */
1471     function readCmapTable(cmap, file, isSymbolicFont, hasEncoding) {
1472       if (!cmap) {
1473         warn("No cmap table available.");
1474         return {
1475           platformId: -1,
1476           encodingId: -1,
1477           mappings: [],
1478           hasShortCmap: false,
1479         };
1480       }
1481       let segment;
1482       let start = (file.start || 0) + cmap.offset;
1483       file.pos = start;
1484 
1485       file.skip(2); // version
1486       const numTables = file.getUint16();
1487 
1488       let potentialTable;
1489       let canBreak = false;
1490       // There's an order of preference in terms of which cmap subtable to
1491       // use:
1492       // - non-symbolic fonts the preference is a 3,1 table then a 1,0 table
1493       // - symbolic fonts the preference is a 3,0 table then a 1,0 table
1494       // The following takes advantage of the fact that the tables are sorted
1495       // to work.
1496       for (let i = 0; i < numTables; i++) {
1497         const platformId = file.getUint16();
1498         const encodingId = file.getUint16();
1499         const offset = file.getInt32() >>> 0;
1500         let useTable = false;
1501 
1502         // Sometimes there are multiple of the same type of table. Default
1503         // to choosing the first table and skip the rest.
1504         if (
1505           potentialTable?.platformId === platformId &&
1506           potentialTable?.encodingId === encodingId
1507         ) {
1508           continue;
1509         }
1510 
1511         if (
1512           platformId === 0 &&
1513           (encodingId === /* Unicode Default */ 0 ||
1514             encodingId === /* Unicode 1.1 */ 1 ||
1515             encodingId === /* Unicode BMP */ 3)
1516         ) {
1517           useTable = true;
1518           // Continue the loop since there still may be a higher priority
1519           // table.
1520         } else if (platformId === 1 && encodingId === 0) {
1521           useTable = true;
1522           // Continue the loop since there still may be a higher priority
1523           // table.
1524         } else if (
1525           platformId === 3 &&
1526           encodingId === 1 &&
1527           (hasEncoding || !potentialTable)
1528         ) {
1529           useTable = true;
1530           if (!isSymbolicFont) {
1531             canBreak = true;
1532           }
1533         } else if (isSymbolicFont && platformId === 3 && encodingId === 0) {
1534           useTable = true;
1535 
1536           let correctlySorted = true;
1537           if (i < numTables - 1) {
1538             const nextBytes = file.peekBytes(2),
1539               nextPlatformId = int16(nextBytes[0], nextBytes[1]);
1540             if (nextPlatformId < platformId) {
1541               correctlySorted = false;
1542             }
1543           }
1544           if (correctlySorted) {
1545             canBreak = true;
1546           }
1547         }
1548 
1549         if (useTable) {
1550           potentialTable = {
1551             platformId,
1552             encodingId,
1553             offset,
1554           };
1555         }
1556         if (canBreak) {
1557           break;
1558         }
1559       }
1560 
1561       if (potentialTable) {
1562         file.pos = start + potentialTable.offset;
1563       }
1564       if (!potentialTable || file.peekByte() === -1) {
1565         warn("Could not find a preferred cmap table.");
1566         return {
1567           platformId: -1,
1568           encodingId: -1,
1569           mappings: [],
1570           hasShortCmap: false,
1571         };
1572       }
1573 
1574       const format = file.getUint16();
1575       let hasShortCmap = false;
1576       const mappings = [];
1577       let j, glyphId;
1578 
1579       // TODO(mack): refactor this cmap subtable reading logic out
1580       if (format === 0) {
1581         file.skip(2 + 2); // length + language
1582 
1583         for (j = 0; j < 256; j++) {
1584           const index = file.getByte();
1585           if (!index) {
1586             continue;
1587           }
1588           mappings.push({
1589             charCode: j,
1590             glyphId: index,
1591           });
1592         }
1593         hasShortCmap = true;
1594       } else if (format === 2) {
1595         file.skip(2 + 2); // length + language
1596 
1597         const subHeaderKeys = [];
1598         let maxSubHeaderKey = 0;
1599         // Read subHeaderKeys. If subHeaderKeys[i] === 0, then i is a
1600         // single-byte character. Otherwise, i is the first byte of a
1601         // multi-byte character, and the value is 8*index into
1602         // subHeaders.
1603         for (let i = 0; i < 256; i++) {
1604           const subHeaderKey = file.getUint16() >> 3;
1605           subHeaderKeys.push(subHeaderKey);
1606           maxSubHeaderKey = Math.max(subHeaderKey, maxSubHeaderKey);
1607         }
1608         // Read subHeaders. The number of entries is determined
1609         // dynamically based on the subHeaderKeys found above.
1610         const subHeaders = [];
1611         for (let i = 0; i <= maxSubHeaderKey; i++) {
1612           subHeaders.push({
1613             firstCode: file.getUint16(),
1614             entryCount: file.getUint16(),
1615             idDelta: signedInt16(file.getByte(), file.getByte()),
1616             idRangePos: file.pos + file.getUint16(),
1617           });
1618         }
1619         for (let i = 0; i < 256; i++) {
1620           if (subHeaderKeys[i] === 0) {
1621             // i is a single-byte code.
1622             file.pos = subHeaders[0].idRangePos + 2 * i;
1623             glyphId = file.getUint16();
1624             mappings.push({
1625               charCode: i,
1626               glyphId,
1627             });
1628           } else {
1629             // i is the first byte of a two-byte code.
1630             const s = subHeaders[subHeaderKeys[i]];
1631             for (j = 0; j < s.entryCount; j++) {
1632               const charCode = (i << 8) + j + s.firstCode;
1633               file.pos = s.idRangePos + 2 * j;
1634               glyphId = file.getUint16();
1635               if (glyphId !== 0) {
1636                 glyphId = (glyphId + s.idDelta) % 65536;
1637               }
1638               mappings.push({
1639                 charCode,
1640                 glyphId,
1641               });
1642             }
1643           }
1644         }
1645       } else if (format === 4) {
1646         file.skip(2 + 2); // length + language
1647 
1648         // re-creating the table in format 4 since the encoding
1649         // might be changed
1650         const segCount = file.getUint16() >> 1;
1651         file.skip(6); // skipping range fields
1652         const segments = [];
1653         let segIndex;
1654         for (segIndex = 0; segIndex < segCount; segIndex++) {
1655           segments.push({ end: file.getUint16() });
1656         }
1657         file.skip(2);
1658         for (segIndex = 0; segIndex < segCount; segIndex++) {
1659           segments[segIndex].start = file.getUint16();
1660         }
1661 
1662         for (segIndex = 0; segIndex < segCount; segIndex++) {
1663           segments[segIndex].delta = file.getUint16();
1664         }
1665 
1666         let offsetsCount = 0,
1667           offsetIndex;
1668         for (segIndex = 0; segIndex < segCount; segIndex++) {
1669           segment = segments[segIndex];
1670           const rangeOffset = file.getUint16();
1671           if (!rangeOffset) {
1672             segment.offsetIndex = -1;
1673             continue;
1674           }
1675 
1676           offsetIndex = (rangeOffset >> 1) - (segCount - segIndex);
1677           segment.offsetIndex = offsetIndex;
1678           offsetsCount = Math.max(
1679             offsetsCount,
1680             offsetIndex + segment.end - segment.start + 1
1681           );
1682         }
1683 
1684         const offsets = [];
1685         for (j = 0; j < offsetsCount; j++) {
1686           offsets.push(file.getUint16());
1687         }
1688 
1689         for (segIndex = 0; segIndex < segCount; segIndex++) {
1690           segment = segments[segIndex];
1691           start = segment.start;
1692           const end = segment.end;
1693           const delta = segment.delta;
1694           offsetIndex = segment.offsetIndex;
1695 
1696           for (j = start; j <= end; j++) {
1697             if (j === 0xffff) {
1698               continue;
1699             }
1700 
1701             glyphId = offsetIndex < 0 ? j : offsets[offsetIndex + j - start];
1702             glyphId = (glyphId + delta) & 0xffff;
1703             mappings.push({
1704               charCode: j,
1705               glyphId,
1706             });
1707           }
1708         }
1709       } else if (format === 6) {
1710         file.skip(2 + 2); // length + language
1711 
1712         // Format 6 is a 2-bytes dense mapping, which means the font data
1713         // lives glue together even if they are pretty far in the unicode
1714         // table. (This looks weird, so I can have missed something), this
1715         // works on Linux but seems to fails on Mac so let's rewrite the
1716         // cmap table to a 3-1-4 style
1717         const firstCode = file.getUint16();
1718         const entryCount = file.getUint16();
1719 
1720         for (j = 0; j < entryCount; j++) {
1721           glyphId = file.getUint16();
1722           const charCode = firstCode + j;
1723 
1724           mappings.push({
1725             charCode,
1726             glyphId,
1727           });
1728         }
1729       } else if (format === 12) {
1730         file.skip(2 + 4 + 4); // reserved + length + language
1731 
1732         const nGroups = file.getInt32() >>> 0;
1733         for (j = 0; j < nGroups; j++) {
1734           const startCharCode = file.getInt32() >>> 0;
1735           const endCharCode = file.getInt32() >>> 0;
1736           let glyphCode = file.getInt32() >>> 0;
1737 
1738           for (
1739             let charCode = startCharCode;
1740             charCode <= endCharCode;
1741             charCode++
1742           ) {
1743             mappings.push({
1744               charCode,
1745               glyphId: glyphCode++,
1746             });
1747           }
1748         }
1749       } else {
1750         warn("cmap table has unsupported format: " + format);
1751         return {
1752           platformId: -1,
1753           encodingId: -1,
1754           mappings: [],
1755           hasShortCmap: false,
1756         };
1757       }
1758 
1759       // removing duplicate entries
1760       mappings.sort(function (a, b) {
1761         return a.charCode - b.charCode;
1762       });
1763       const finalMappings = [],
1764         seenCharCodes = new Set();
1765       for (const map of mappings) {
1766         const { charCode } = map;
1767 
1768         if (seenCharCodes.has(charCode)) {
1769           continue;
1770         }
1771         seenCharCodes.add(charCode);
1772         finalMappings.push(map);
1773       }
1774 
1775       return {
1776         platformId: potentialTable.platformId,
1777         encodingId: potentialTable.encodingId,
1778         mappings: finalMappings,
1779         hasShortCmap,
1780       };
1781     }
1782 
1783     function sanitizeMetrics(
1784       file,
1785       header,
1786       metrics,
1787       headTable,
1788       numGlyphs,
1789       dupFirstEntry
1790     ) {
1791       if (!header) {
1792         if (metrics) {
1793           metrics.data = null;
1794         }
1795         return;
1796       }
1797 
1798       file.pos = (file.start || 0) + header.offset;
1799       file.pos += 4; // version
1800       file.pos += 2; // ascent
1801       file.pos += 2; // descent
1802       file.pos += 2; // linegap
1803       file.pos += 2; // adv_width_max
1804       file.pos += 2; // min_sb1
1805       file.pos += 2; // min_sb2
1806       file.pos += 2; // max_extent
1807       file.pos += 2; // caret_slope_rise
1808       file.pos += 2; // caret_slope_run
1809       const caretOffset = file.getUint16();
1810       file.pos += 8; // reserved
1811       file.pos += 2; // format
1812       let numOfMetrics = file.getUint16();
1813 
1814       if (caretOffset !== 0) {
1815         const macStyle = int16(headTable.data[44], headTable.data[45]);
1816         if (!(macStyle & 2)) {
1817           // Suppress OTS warnings about the `caretOffset` in the hhea-table.
1818           header.data[22] = 0;
1819           header.data[23] = 0;
1820         }
1821       }
1822 
1823       if (numOfMetrics > numGlyphs) {
1824         info(
1825           `The numOfMetrics (${numOfMetrics}) should not be ` +
1826             `greater than the numGlyphs (${numGlyphs}).`
1827         );
1828         // Reduce numOfMetrics if it is greater than numGlyphs
1829         numOfMetrics = numGlyphs;
1830         header.data[34] = (numOfMetrics & 0xff00) >> 8;
1831         header.data[35] = numOfMetrics & 0x00ff;
1832       }
1833 
1834       const numOfSidebearings = numGlyphs - numOfMetrics;
1835       const numMissing =
1836         numOfSidebearings - ((metrics.length - numOfMetrics * 4) >> 1);
1837 
1838       if (numMissing > 0) {
1839         // For each missing glyph, we set both the width and lsb to 0 (zero).
1840         // Since we need to add two properties for each glyph, this explains
1841         // the use of |numMissing * 2| when initializing the typed array.
1842         const entries = new Uint8Array(metrics.length + numMissing * 2);
1843         entries.set(metrics.data);
1844         if (dupFirstEntry) {
1845           // Set the sidebearing value of the duplicated glyph.
1846           entries[metrics.length] = metrics.data[2];
1847           entries[metrics.length + 1] = metrics.data[3];
1848         }
1849         metrics.data = entries;
1850       }
1851     }
1852 
1853     function sanitizeGlyph(
1854       source,
1855       sourceStart,
1856       sourceEnd,
1857       dest,
1858       destStart,
1859       hintsValid
1860     ) {
1861       const glyphProfile = {
1862         length: 0,
1863         sizeOfInstructions: 0,
1864       };
1865       if (
1866         sourceStart < 0 ||
1867         sourceStart >= source.length ||
1868         sourceEnd > source.length ||
1869         sourceEnd - sourceStart <= 12
1870       ) {
1871         // If the offsets are wrong or the glyph is too small, remove it.
1872         return glyphProfile;
1873       }
1874       const glyf = source.subarray(sourceStart, sourceEnd);
1875 
1876       // Sanitize the glyph bounding box.
1877       const xMin = signedInt16(glyf[2], glyf[3]);
1878       const yMin = signedInt16(glyf[4], glyf[5]);
1879       const xMax = signedInt16(glyf[6], glyf[7]);
1880       const yMax = signedInt16(glyf[8], glyf[9]);
1881 
1882       if (xMin > xMax) {
1883         writeSignedInt16(glyf, 2, xMax);
1884         writeSignedInt16(glyf, 6, xMin);
1885       }
1886       if (yMin > yMax) {
1887         writeSignedInt16(glyf, 4, yMax);
1888         writeSignedInt16(glyf, 8, yMin);
1889       }
1890 
1891       const contoursCount = signedInt16(glyf[0], glyf[1]);
1892       if (contoursCount < 0) {
1893         if (contoursCount < -1) {
1894           // OTS doesn't like contour count to be less than -1.
1895           // The glyph data offsets are very likely wrong and
1896           // having something lower than -1, very likely, implies
1897           // to have some garbage data.
1898           return glyphProfile;
1899         }
1900         // complex glyph, writing as is
1901         dest.set(glyf, destStart);
1902         glyphProfile.length = glyf.length;
1903         return glyphProfile;
1904       }
1905 
1906       let i,
1907         j = 10,
1908         flagsCount = 0;
1909       for (i = 0; i < contoursCount; i++) {
1910         const endPoint = (glyf[j] << 8) | glyf[j + 1];
1911         flagsCount = endPoint + 1;
1912         j += 2;
1913       }
1914       // skipping instructions
1915       const instructionsStart = j;
1916       const instructionsLength = (glyf[j] << 8) | glyf[j + 1];
1917       glyphProfile.sizeOfInstructions = instructionsLength;
1918       j += 2 + instructionsLength;
1919       const instructionsEnd = j;
1920       // validating flags
1921       let coordinatesLength = 0;
1922       for (i = 0; i < flagsCount; i++) {
1923         const flag = glyf[j++];
1924         if (flag & 0xc0) {
1925           // reserved flags must be zero, cleaning up
1926           glyf[j - 1] = flag & 0x3f;
1927         }
1928         let xLength = 2;
1929         if (flag & 2) {
1930           xLength = 1;
1931         } else if (flag & 16) {
1932           xLength = 0;
1933         }
1934         let yLength = 2;
1935         if (flag & 4) {
1936           yLength = 1;
1937         } else if (flag & 32) {
1938           yLength = 0;
1939         }
1940         const xyLength = xLength + yLength;
1941         coordinatesLength += xyLength;
1942         if (flag & 8) {
1943           const repeat = glyf[j++];
1944           if (repeat === 0) {
1945             // The repeat count should be non-zero when the repeat flag is set.
1946             glyf[j - 1] ^= 8;
1947           }
1948           i += repeat;
1949           coordinatesLength += repeat * xyLength;
1950         }
1951       }
1952       // glyph without coordinates will be rejected
1953       if (coordinatesLength === 0) {
1954         return glyphProfile;
1955       }
1956       let glyphDataLength = j + coordinatesLength;
1957       if (glyphDataLength > glyf.length) {
1958         // not enough data for coordinates
1959         return glyphProfile;
1960       }
1961       if (!hintsValid && instructionsLength > 0) {
1962         dest.set(glyf.subarray(0, instructionsStart), destStart);
1963         dest.set([0, 0], destStart + instructionsStart);
1964         dest.set(
1965           glyf.subarray(instructionsEnd, glyphDataLength),
1966           destStart + instructionsStart + 2
1967         );
1968         glyphDataLength -= instructionsLength;
1969         if (glyf.length - glyphDataLength > 3) {
1970           glyphDataLength = (glyphDataLength + 3) & ~3;
1971         }
1972         glyphProfile.length = glyphDataLength;
1973         return glyphProfile;
1974       }
1975       if (glyf.length - glyphDataLength > 3) {
1976         // truncating and aligning to 4 bytes the long glyph data
1977         glyphDataLength = (glyphDataLength + 3) & ~3;
1978         dest.set(glyf.subarray(0, glyphDataLength), destStart);
1979         glyphProfile.length = glyphDataLength;
1980         return glyphProfile;
1981       }
1982       // glyph data is fine
1983       dest.set(glyf, destStart);
1984       glyphProfile.length = glyf.length;
1985       return glyphProfile;
1986     }
1987 
1988     function sanitizeHead(head, numGlyphs, locaLength) {
1989       const data = head.data;
1990 
1991       // Validate version:
1992       // Should always be 0x00010000
1993       const version = int32(data[0], data[1], data[2], data[3]);
1994       if (version >> 16 !== 1) {
1995         info("Attempting to fix invalid version in head table: " + version);
1996         data[0] = 0;
1997         data[1] = 1;
1998         data[2] = 0;
1999         data[3] = 0;
2000       }
2001 
2002       const indexToLocFormat = int16(data[50], data[51]);
2003       if (indexToLocFormat < 0 || indexToLocFormat > 1) {
2004         info(
2005           "Attempting to fix invalid indexToLocFormat in head table: " +
2006             indexToLocFormat
2007         );
2008 
2009         // The value of indexToLocFormat should be 0 if the loca table
2010         // consists of short offsets, and should be 1 if the loca table
2011         // consists of long offsets.
2012         //
2013         // The number of entries in the loca table should be numGlyphs + 1.
2014         //
2015         // Using this information, we can work backwards to deduce if the
2016         // size of each offset in the loca table, and thus figure out the
2017         // appropriate value for indexToLocFormat.
2018 
2019         const numGlyphsPlusOne = numGlyphs + 1;
2020         if (locaLength === numGlyphsPlusOne << 1) {
2021           // 0x0000 indicates the loca table consists of short offsets
2022           data[50] = 0;
2023           data[51] = 0;
2024         } else if (locaLength === numGlyphsPlusOne << 2) {
2025           // 0x0001 indicates the loca table consists of long offsets
2026           data[50] = 0;
2027           data[51] = 1;
2028         } else {
2029           throw new FormatError(
2030             "Could not fix indexToLocFormat: " + indexToLocFormat
2031           );
2032         }
2033       }
2034     }
2035 
2036     function sanitizeGlyphLocations(
2037       loca,
2038       glyf,
2039       numGlyphs,
2040       isGlyphLocationsLong,
2041       hintsValid,
2042       dupFirstEntry,
2043       maxSizeOfInstructions
2044     ) {
2045       let itemSize, itemDecode, itemEncode;
2046       if (isGlyphLocationsLong) {
2047         itemSize = 4;
2048         itemDecode = function fontItemDecodeLong(data, offset) {
2049           return (
2050             (data[offset] << 24) |
2051             (data[offset + 1] << 16) |
2052             (data[offset + 2] << 8) |
2053             data[offset + 3]
2054           );
2055         };
2056         itemEncode = function fontItemEncodeLong(data, offset, value) {
2057           data[offset] = (value >>> 24) & 0xff;
2058           data[offset + 1] = (value >> 16) & 0xff;
2059           data[offset + 2] = (value >> 8) & 0xff;
2060           data[offset + 3] = value & 0xff;
2061         };
2062       } else {
2063         itemSize = 2;
2064         itemDecode = function fontItemDecode(data, offset) {
2065           return (data[offset] << 9) | (data[offset + 1] << 1);
2066         };
2067         itemEncode = function fontItemEncode(data, offset, value) {
2068           data[offset] = (value >> 9) & 0xff;
2069           data[offset + 1] = (value >> 1) & 0xff;
2070         };
2071       }
2072       // The first glyph is duplicated.
2073       const numGlyphsOut = dupFirstEntry ? numGlyphs + 1 : numGlyphs;
2074       const locaDataSize = itemSize * (1 + numGlyphsOut);
2075       // Resize loca table to account for duplicated glyph.
2076       const locaData = new Uint8Array(locaDataSize);
2077       locaData.set(loca.data.subarray(0, locaDataSize));
2078       loca.data = locaData;
2079       // removing the invalid glyphs
2080       const oldGlyfData = glyf.data;
2081       const oldGlyfDataLength = oldGlyfData.length;
2082       const newGlyfData = new Uint8Array(oldGlyfDataLength);
2083 
2084       // The spec says the offsets should be in ascending order, however
2085       // this is not true for some fonts or they use the offset of 0 to mark a
2086       // glyph as missing. OTS requires the offsets to be in order and not to
2087       // be zero, so we must sort and rebuild the loca table and potentially
2088       // re-arrange the glyf data.
2089       let i, j;
2090       const locaEntries = [];
2091       // There are numGlyphs + 1 loca table entries.
2092       for (i = 0, j = 0; i < numGlyphs + 1; i++, j += itemSize) {
2093         let offset = itemDecode(locaData, j);
2094         if (offset > oldGlyfDataLength) {
2095           offset = oldGlyfDataLength;
2096         }
2097         locaEntries.push({
2098           index: i,
2099           offset,
2100           endOffset: 0,
2101         });
2102       }
2103       locaEntries.sort((a, b) => a.offset - b.offset);
2104       // Now the offsets are sorted, calculate the end offset of each glyph.
2105       // The last loca entry's endOffset is not calculated since it's the end
2106       // of the data and will be stored on the previous entry's endOffset.
2107       for (i = 0; i < numGlyphs; i++) {
2108         locaEntries[i].endOffset = locaEntries[i + 1].offset;
2109       }
2110       // Re-sort so glyphs aren't out of order.
2111       locaEntries.sort((a, b) => a.index - b.index);
2112       // Calculate the endOffset of the "first" glyph correctly when there are
2113       // *multiple* empty ones at the start of the data (fixes issue14618.pdf).
2114       for (i = 0; i < numGlyphs; i++) {
2115         const { offset, endOffset } = locaEntries[i];
2116         if (offset !== 0 || endOffset !== 0) {
2117           break;
2118         }
2119         const nextOffset = locaEntries[i + 1].offset;
2120         if (nextOffset === 0) {
2121           continue;
2122         }
2123         locaEntries[i].endOffset = nextOffset;
2124         break;
2125       }
2126 
2127       // If the last offset is 0 in the loca table then we can't compute the
2128       // endOffset for the last glyph. So in such a case we set the endOffset
2129       // to the end of the data (fixes issue #17671).
2130       const last = locaEntries.at(-2);
2131       if (last.offset !== 0 && last.endOffset === 0) {
2132         last.endOffset = oldGlyfDataLength;
2133       }
2134 
2135       const missingGlyphs = Object.create(null);
2136       let writeOffset = 0;
2137       itemEncode(locaData, 0, writeOffset);
2138       for (i = 0, j = itemSize; i < numGlyphs; i++, j += itemSize) {
2139         const glyphProfile = sanitizeGlyph(
2140           oldGlyfData,
2141           locaEntries[i].offset,
2142           locaEntries[i].endOffset,
2143           newGlyfData,
2144           writeOffset,
2145           hintsValid
2146         );
2147         const newLength = glyphProfile.length;
2148         if (newLength === 0) {
2149           missingGlyphs[i] = true;
2150         }
2151         if (glyphProfile.sizeOfInstructions > maxSizeOfInstructions) {
2152           maxSizeOfInstructions = glyphProfile.sizeOfInstructions;
2153         }
2154         writeOffset += newLength;
2155         itemEncode(locaData, j, writeOffset);
2156       }
2157 
2158       if (writeOffset === 0) {
2159         // glyf table cannot be empty -- redoing the glyf and loca tables
2160         // to have single glyph with one point
2161         const simpleGlyph = new Uint8Array([
2162           0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 49, 0,
2163         ]);
2164         for (i = 0, j = itemSize; i < numGlyphsOut; i++, j += itemSize) {
2165           itemEncode(locaData, j, simpleGlyph.length);
2166         }
2167         glyf.data = simpleGlyph;
2168       } else if (dupFirstEntry) {
2169         // Browsers will not display a glyph at position 0. Typically glyph 0
2170         // is notdef, but a number of fonts put a valid glyph there so it must
2171         // be duplicated and appended.
2172         const firstEntryLength = itemDecode(locaData, itemSize);
2173         if (newGlyfData.length > firstEntryLength + writeOffset) {
2174           glyf.data = newGlyfData.subarray(0, firstEntryLength + writeOffset);
2175         } else {
2176           glyf.data = new Uint8Array(firstEntryLength + writeOffset);
2177           glyf.data.set(newGlyfData.subarray(0, writeOffset));
2178         }
2179         glyf.data.set(newGlyfData.subarray(0, firstEntryLength), writeOffset);
2180         itemEncode(
2181           loca.data,
2182           locaData.length - itemSize,
2183           writeOffset + firstEntryLength
2184         );
2185       } else {
2186         glyf.data = newGlyfData.subarray(0, writeOffset);
2187       }
2188       return {
2189         missingGlyphs,
2190         maxSizeOfInstructions,
2191       };
2192     }
2193 
2194     function readPostScriptTable(post, propertiesObj, maxpNumGlyphs) {
2195       const start = (font.start || 0) + post.offset;
2196       font.pos = start;
2197 
2198       const length = post.length,
2199         end = start + length;
2200       const version = font.getInt32();
2201       // skip rest to the tables
2202       font.skip(28);
2203 
2204       let glyphNames;
2205       let valid = true;
2206       let i;
2207 
2208       switch (version) {
2209         case 0x00010000:
2210           glyphNames = MacStandardGlyphOrdering;
2211           break;
2212         case 0x00020000:
2213           const numGlyphs = font.getUint16();
2214           if (numGlyphs !== maxpNumGlyphs) {
2215             valid = false;
2216             break;
2217           }
2218           const glyphNameIndexes = [];
2219           for (i = 0; i < numGlyphs; ++i) {
2220             const index = font.getUint16();
2221             if (index >= 32768) {
2222               valid = false;
2223               break;
2224             }
2225             glyphNameIndexes.push(index);
2226           }
2227           if (!valid) {
2228             break;
2229           }
2230           const customNames = [],
2231             strBuf = [];
2232           while (font.pos < end) {
2233             const stringLength = font.getByte();
2234             strBuf.length = stringLength;
2235             for (i = 0; i < stringLength; ++i) {
2236               strBuf[i] = String.fromCharCode(font.getByte());
2237             }
2238             customNames.push(strBuf.join(""));
2239           }
2240           glyphNames = [];
2241           for (i = 0; i < numGlyphs; ++i) {
2242             const j = glyphNameIndexes[i];
2243             if (j < 258) {
2244               glyphNames.push(MacStandardGlyphOrdering[j]);
2245               continue;
2246             }
2247             glyphNames.push(customNames[j - 258]);
2248           }
2249           break;
2250         case 0x00030000:
2251           break;
2252         default:
2253           warn("Unknown/unsupported post table version " + version);
2254           valid = false;
2255           if (propertiesObj.defaultEncoding) {
2256             glyphNames = propertiesObj.defaultEncoding;
2257           }
2258           break;
2259       }
2260       propertiesObj.glyphNames = glyphNames;
2261       return valid;
2262     }
2263 
2264     function readNameTable(nameTable) {
2265       const start = (font.start || 0) + nameTable.offset;
2266       font.pos = start;
2267 
2268       const names = [[], []],
2269         records = [];
2270       const length = nameTable.length,
2271         end = start + length;
2272       const format = font.getUint16();
2273       const FORMAT_0_HEADER_LENGTH = 6;
2274       if (format !== 0 || length < FORMAT_0_HEADER_LENGTH) {
2275         // unsupported name table format or table "too" small
2276         return [names, records];
2277       }
2278       const numRecords = font.getUint16();
2279       const stringsStart = font.getUint16();
2280       const NAME_RECORD_LENGTH = 12;
2281       let i, ii;
2282 
2283       for (i = 0; i < numRecords && font.pos + NAME_RECORD_LENGTH <= end; i++) {
2284         const r = {
2285           platform: font.getUint16(),
2286           encoding: font.getUint16(),
2287           language: font.getUint16(),
2288           name: font.getUint16(),
2289           length: font.getUint16(),
2290           offset: font.getUint16(),
2291         };
2292         // using only Macintosh and Windows platform/encoding names
2293         if (isMacNameRecord(r) || isWinNameRecord(r)) {
2294           records.push(r);
2295         }
2296       }
2297       for (i = 0, ii = records.length; i < ii; i++) {
2298         const record = records[i];
2299         if (record.length <= 0) {
2300           continue; // Nothing to process, ignoring.
2301         }
2302         const pos = start + stringsStart + record.offset;
2303         if (pos + record.length > end) {
2304           continue; // outside of name table, ignoring
2305         }
2306         font.pos = pos;
2307         const nameIndex = record.name;
2308         if (record.encoding) {
2309           // unicode
2310           let str = "";
2311           for (let j = 0, jj = record.length; j < jj; j += 2) {
2312             str += String.fromCharCode(font.getUint16());
2313           }
2314           names[1][nameIndex] = str;
2315         } else {
2316           names[0][nameIndex] = font.getString(record.length);
2317         }
2318       }
2319       return [names, records];
2320     }
2321 
2322     // prettier-ignore
2323     const TTOpsStackDeltas = [
2324       0, 0, 0, 0, 0, 0, 0, 0, -2, -2, -2, -2, 0, 0, -2, -5,
2325       -1, -1, -1, -1, -1, -1, -1, -1, 0, 0, -1, 0, -1, -1, -1, -1,
2326       1, -1, -999, 0, 1, 0, -1, -2, 0, -1, -2, -1, -1, 0, -1, -1,
2327       0, 0, -999, -999, -1, -1, -1, -1, -2, -999, -2, -2, -999, 0, -2, -2,
2328       0, 0, -2, 0, -2, 0, 0, 0, -2, -1, -1, 1, 1, 0, 0, -1,
2329       -1, -1, -1, -1, -1, -1, 0, 0, -1, 0, -1, -1, 0, -999, -1, -1,
2330       -1, -1, -1, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
2331       -2, -999, -999, -999, -999, -999, -1, -1, -2, -2, 0, 0, 0, 0, -1, -1,
2332       -999, -2, -2, 0, 0, -1, -2, -2, 0, 0, 0, -1, -1, -1, -2];
2333     // 0xC0-DF == -1 and 0xE0-FF == -2
2334 
2335     function sanitizeTTProgram(table, ttContext) {
2336       let data = table.data;
2337       let i = 0,
2338         j,
2339         n,
2340         b,
2341         funcId,
2342         pc,
2343         lastEndf = 0,
2344         lastDeff = 0;
2345       const stack = [];
2346       const callstack = [];
2347       const functionsCalled = [];
2348       let tooComplexToFollowFunctions = ttContext.tooComplexToFollowFunctions;
2349       let inFDEF = false,
2350         ifLevel = 0,
2351         inELSE = 0;
2352       for (let ii = data.length; i < ii; ) {
2353         const op = data[i++];
2354         // The TrueType instruction set docs can be found at
2355         // https://developer.apple.com/fonts/TTRefMan/RM05/Chap5.html
2356         if (op === 0x40) {
2357           // NPUSHB - pushes n bytes
2358           n = data[i++];
2359           if (inFDEF || inELSE) {
2360             i += n;
2361           } else {
2362             for (j = 0; j < n; j++) {
2363               stack.push(data[i++]);
2364             }
2365           }
2366         } else if (op === 0x41) {
2367           // NPUSHW - pushes n words
2368           n = data[i++];
2369           if (inFDEF || inELSE) {
2370             i += n * 2;
2371           } else {
2372             for (j = 0; j < n; j++) {
2373               b = data[i++];
2374               stack.push((b << 8) | data[i++]);
2375             }
2376           }
2377         } else if ((op & 0xf8) === 0xb0) {
2378           // PUSHB - pushes bytes
2379           n = op - 0xb0 + 1;
2380           if (inFDEF || inELSE) {
2381             i += n;
2382           } else {
2383             for (j = 0; j < n; j++) {
2384               stack.push(data[i++]);
2385             }
2386           }
2387         } else if ((op & 0xf8) === 0xb8) {
2388           // PUSHW - pushes words
2389           n = op - 0xb8 + 1;
2390           if (inFDEF || inELSE) {
2391             i += n * 2;
2392           } else {
2393             for (j = 0; j < n; j++) {
2394               b = data[i++];
2395               stack.push(signedInt16(b, data[i++]));
2396             }
2397           }
2398         } else if (op === 0x2b && !tooComplexToFollowFunctions) {
2399           // CALL
2400           if (!inFDEF && !inELSE) {
2401             // collecting information about which functions are used
2402             funcId = stack.at(-1);
2403             if (isNaN(funcId)) {
2404               info("TT: CALL empty stack (or invalid entry).");
2405             } else {
2406               ttContext.functionsUsed[funcId] = true;
2407               if (funcId in ttContext.functionsStackDeltas) {
2408                 const newStackLength =
2409                   stack.length + ttContext.functionsStackDeltas[funcId];
2410                 if (newStackLength < 0) {
2411                   warn("TT: CALL invalid functions stack delta.");
2412                   ttContext.hintsValid = false;
2413                   return;
2414                 }
2415                 stack.length = newStackLength;
2416               } else if (
2417                 funcId in ttContext.functionsDefined &&
2418                 !functionsCalled.includes(funcId)
2419               ) {
2420                 callstack.push({ data, i, stackTop: stack.length - 1 });
2421                 functionsCalled.push(funcId);
2422                 pc = ttContext.functionsDefined[funcId];
2423                 if (!pc) {
2424                   warn("TT: CALL non-existent function");
2425                   ttContext.hintsValid = false;
2426                   return;
2427                 }
2428                 data = pc.data;
2429                 i = pc.i;
2430               }
2431             }
2432           }
2433         } else if (op === 0x2c && !tooComplexToFollowFunctions) {
2434           // FDEF
2435           if (inFDEF || inELSE) {
2436             warn("TT: nested FDEFs not allowed");
2437             tooComplexToFollowFunctions = true;
2438           }
2439           inFDEF = true;
2440           // collecting information about which functions are defined
2441           lastDeff = i;
2442           funcId = stack.pop();
2443           ttContext.functionsDefined[funcId] = { data, i };
2444         } else if (op === 0x2d) {
2445           // ENDF - end of function
2446           if (inFDEF) {
2447             inFDEF = false;
2448             lastEndf = i;
2449           } else {
2450             pc = callstack.pop();
2451             if (!pc) {
2452               warn("TT: ENDF bad stack");
2453               ttContext.hintsValid = false;
2454               return;
2455             }
2456             funcId = functionsCalled.pop();
2457             data = pc.data;
2458             i = pc.i;
2459             ttContext.functionsStackDeltas[funcId] = stack.length - pc.stackTop;
2460           }
2461         } else if (op === 0x89) {
2462           // IDEF - instruction definition
2463           if (inFDEF || inELSE) {
2464             warn("TT: nested IDEFs not allowed");
2465             tooComplexToFollowFunctions = true;
2466           }
2467           inFDEF = true;
2468           // recording it as a function to track ENDF
2469           lastDeff = i;
2470         } else if (op === 0x58) {
2471           // IF
2472           ++ifLevel;
2473         } else if (op === 0x1b) {
2474           // ELSE
2475           inELSE = ifLevel;
2476         } else if (op === 0x59) {
2477           // EIF
2478           if (inELSE === ifLevel) {
2479             inELSE = 0;
2480           }
2481           --ifLevel;
2482         } else if (op === 0x1c) {
2483           // JMPR
2484           if (!inFDEF && !inELSE) {
2485             const offset = stack.at(-1);
2486             // only jumping forward to prevent infinite loop
2487             if (offset > 0) {
2488               i += offset - 1;
2489             }
2490           }
2491         }
2492         // Adjusting stack not extactly, but just enough to get function id
2493         if (!inFDEF && !inELSE) {
2494           let stackDelta = 0;
2495           if (op <= 0x8e) {
2496             stackDelta = TTOpsStackDeltas[op];
2497           } else if (op >= 0xc0 && op <= 0xdf) {
2498             stackDelta = -1;
2499           } else if (op >= 0xe0) {
2500             stackDelta = -2;
2501           }
2502           if (op >= 0x71 && op <= 0x75) {
2503             n = stack.pop();
2504             if (!isNaN(n)) {
2505               stackDelta = -n * 2;
2506             }
2507           }
2508           while (stackDelta < 0 && stack.length > 0) {
2509             stack.pop();
2510             stackDelta++;
2511           }
2512           while (stackDelta > 0) {
2513             stack.push(NaN); // pushing any number into stack
2514             stackDelta--;
2515           }
2516         }
2517       }
2518       ttContext.tooComplexToFollowFunctions = tooComplexToFollowFunctions;
2519       const content = [data];
2520       if (i > data.length) {
2521         content.push(new Uint8Array(i - data.length));
2522       }
2523       if (lastDeff > lastEndf) {
2524         warn("TT: complementing a missing function tail");
2525         // new function definition started, but not finished
2526         // complete function by [CLEAR, ENDF]
2527         content.push(new Uint8Array([0x22, 0x2d]));
2528       }
2529       foldTTTable(table, content);
2530     }
2531 
2532     function checkInvalidFunctions(ttContext, maxFunctionDefs) {
2533       if (ttContext.tooComplexToFollowFunctions) {
2534         return;
2535       }
2536       if (ttContext.functionsDefined.length > maxFunctionDefs) {
2537         warn("TT: more functions defined than expected");
2538         ttContext.hintsValid = false;
2539         return;
2540       }
2541       for (let j = 0, jj = ttContext.functionsUsed.length; j < jj; j++) {
2542         if (j > maxFunctionDefs) {
2543           warn("TT: invalid function id: " + j);
2544           ttContext.hintsValid = false;
2545           return;
2546         }
2547         if (ttContext.functionsUsed[j] && !ttContext.functionsDefined[j]) {
2548           warn("TT: undefined function: " + j);
2549           ttContext.hintsValid = false;
2550           return;
2551         }
2552       }
2553     }
2554 
2555     function foldTTTable(table, content) {
2556       if (content.length > 1) {
2557         // concatenating the content items
2558         let newLength = 0;
2559         let j, jj;
2560         for (j = 0, jj = content.length; j < jj; j++) {
2561           newLength += content[j].length;
2562         }
2563         newLength = (newLength + 3) & ~3;
2564         const result = new Uint8Array(newLength);
2565         let pos = 0;
2566         for (j = 0, jj = content.length; j < jj; j++) {
2567           result.set(content[j], pos);
2568           pos += content[j].length;
2569         }
2570         table.data = result;
2571         table.length = newLength;
2572       }
2573     }
2574 
2575     function sanitizeTTPrograms(fpgm, prep, cvt, maxFunctionDefs) {
2576       const ttContext = {
2577         functionsDefined: [],
2578         functionsUsed: [],
2579         functionsStackDeltas: [],
2580         tooComplexToFollowFunctions: false,
2581         hintsValid: true,
2582       };
2583       if (fpgm) {
2584         sanitizeTTProgram(fpgm, ttContext);
2585       }
2586       if (prep) {
2587         sanitizeTTProgram(prep, ttContext);
2588       }
2589       if (fpgm) {
2590         checkInvalidFunctions(ttContext, maxFunctionDefs);
2591       }
2592       if (cvt && cvt.length & 1) {
2593         const cvtData = new Uint8Array(cvt.length + 1);
2594         cvtData.set(cvt.data);
2595         cvt.data = cvtData;
2596       }
2597       return ttContext.hintsValid;
2598     }
2599 
2600     // The following steps modify the original font data, making copy
2601     font = new Stream(new Uint8Array(font.getBytes()));
2602 
2603     let header, tables;
2604     if (isTrueTypeCollectionFile(font)) {
2605       const ttcData = readTrueTypeCollectionData(font, this.name);
2606       header = ttcData.header;
2607       tables = ttcData.tables;
2608     } else {
2609       header = readOpenTypeHeader(font);
2610       tables = readTables(font, header.numTables);
2611     }
2612     let cff, cffFile;
2613 
2614     const isTrueType = !tables["CFF "];
2615     if (!isTrueType) {
2616       const isComposite =
2617         properties.composite &&
2618         (properties.cidToGidMap?.length > 0 ||
2619           !(properties.cMap instanceof IdentityCMap));
2620       // OpenType font (skip composite fonts with non-default glyph mapping).
2621       if (
2622         (header.version === "OTTO" && !isComposite) ||
2623         !tables.head ||
2624         !tables.hhea ||
2625         !tables.maxp ||
2626         !tables.post
2627       ) {
2628         // No major tables: throwing everything at `CFFFont`.
2629         cffFile = new Stream(tables["CFF "].data);
2630         cff = new CFFFont(cffFile, properties);
2631 
2632         adjustWidths(properties);
2633 
2634         return this.convert(name, cff, properties);
2635       }
2636 
2637       delete tables.glyf;
2638       delete tables.loca;
2639       delete tables.fpgm;
2640       delete tables.prep;
2641       delete tables["cvt "];
2642       this.isOpenType = true;
2643     } else {
2644       if (!tables.loca) {
2645         throw new FormatError('Required "loca" table is not found');
2646       }
2647       if (!tables.glyf) {
2648         warn('Required "glyf" table is not found -- trying to recover.');
2649         // Note: We use `sanitizeGlyphLocations` to add dummy glyf data below.
2650         tables.glyf = {
2651           tag: "glyf",
2652           data: new Uint8Array(0),
2653         };
2654       }
2655       this.isOpenType = false;
2656     }
2657 
2658     if (!tables.maxp) {
2659       throw new FormatError('Required "maxp" table is not found');
2660     }
2661 
2662     font.pos = (font.start || 0) + tables.maxp.offset;
2663     let version = font.getInt32();
2664     const numGlyphs = font.getUint16();
2665 
2666     if (version !== 0x00010000 && version !== 0x00005000) {
2667       // https://learn.microsoft.com/en-us/typography/opentype/spec/maxp
2668       if (tables.maxp.length === 6) {
2669         version = 0x0005000;
2670       } else if (tables.maxp.length >= 32) {
2671         version = 0x00010000;
2672       } else {
2673         throw new FormatError(`"maxp" table has a wrong version number`);
2674       }
2675       writeUint32(tables.maxp.data, 0, version);
2676     }
2677 
2678     if (properties.scaleFactors?.length === numGlyphs && isTrueType) {
2679       const { scaleFactors } = properties;
2680       const isGlyphLocationsLong = int16(
2681         tables.head.data[50],
2682         tables.head.data[51]
2683       );
2684 
2685       const glyphs = new GlyfTable({
2686         glyfTable: tables.glyf.data,
2687         isGlyphLocationsLong,
2688         locaTable: tables.loca.data,
2689         numGlyphs,
2690       });
2691       glyphs.scale(scaleFactors);
2692 
2693       const { glyf, loca, isLocationLong } = glyphs.write();
2694       tables.glyf.data = glyf;
2695       tables.loca.data = loca;
2696 
2697       if (isLocationLong !== !!isGlyphLocationsLong) {
2698         tables.head.data[50] = 0;
2699         tables.head.data[51] = isLocationLong ? 1 : 0;
2700       }
2701 
2702       const metrics = tables.hmtx.data;
2703 
2704       for (let i = 0; i < numGlyphs; i++) {
2705         const j = 4 * i;
2706         const advanceWidth = Math.round(
2707           scaleFactors[i] * int16(metrics[j], metrics[j + 1])
2708         );
2709         metrics[j] = (advanceWidth >> 8) & 0xff;
2710         metrics[j + 1] = advanceWidth & 0xff;
2711         const lsb = Math.round(
2712           scaleFactors[i] * signedInt16(metrics[j + 2], metrics[j + 3])
2713         );
2714         writeSignedInt16(metrics, j + 2, lsb);
2715       }
2716     }
2717 
2718     // Glyph 0 is duplicated and appended.
2719     let numGlyphsOut = numGlyphs + 1;
2720     let dupFirstEntry = true;
2721     if (numGlyphsOut > 0xffff) {
2722       dupFirstEntry = false;
2723       numGlyphsOut = numGlyphs;
2724       warn("Not enough space in glyfs to duplicate first glyph.");
2725     }
2726     let maxFunctionDefs = 0;
2727     let maxSizeOfInstructions = 0;
2728     if (version >= 0x00010000 && tables.maxp.length >= 32) {
2729       // maxZones can be invalid
2730       font.pos += 8;
2731       const maxZones = font.getUint16();
2732       if (maxZones > 2) {
2733         // reset to 2 if font has invalid maxZones
2734         tables.maxp.data[14] = 0;
2735         tables.maxp.data[15] = 2;
2736       }
2737       font.pos += 4;
2738       maxFunctionDefs = font.getUint16();
2739       font.pos += 4;
2740       maxSizeOfInstructions = font.getUint16();
2741     }
2742 
2743     tables.maxp.data[4] = numGlyphsOut >> 8;
2744     tables.maxp.data[5] = numGlyphsOut & 255;
2745 
2746     const hintsValid = sanitizeTTPrograms(
2747       tables.fpgm,
2748       tables.prep,
2749       tables["cvt "],
2750       maxFunctionDefs
2751     );
2752     if (!hintsValid) {
2753       delete tables.fpgm;
2754       delete tables.prep;
2755       delete tables["cvt "];
2756     }
2757 
2758     // Ensure the hmtx table contains the advance width and
2759     // sidebearings information for numGlyphs in the maxp table
2760     sanitizeMetrics(
2761       font,
2762       tables.hhea,
2763       tables.hmtx,
2764       tables.head,
2765       numGlyphsOut,
2766       dupFirstEntry
2767     );
2768 
2769     if (!tables.head) {
2770       throw new FormatError('Required "head" table is not found');
2771     }
2772 
2773     sanitizeHead(tables.head, numGlyphs, isTrueType ? tables.loca.length : 0);
2774 
2775     let missingGlyphs = Object.create(null);
2776     if (isTrueType) {
2777       const isGlyphLocationsLong = int16(
2778         tables.head.data[50],
2779         tables.head.data[51]
2780       );
2781       const glyphsInfo = sanitizeGlyphLocations(
2782         tables.loca,
2783         tables.glyf,
2784         numGlyphs,
2785         isGlyphLocationsLong,
2786         hintsValid,
2787         dupFirstEntry,
2788         maxSizeOfInstructions
2789       );
2790       missingGlyphs = glyphsInfo.missingGlyphs;
2791 
2792       // Some fonts have incorrect maxSizeOfInstructions values, so we use
2793       // the computed value instead.
2794       if (version >= 0x00010000 && tables.maxp.length >= 32) {
2795         tables.maxp.data[26] = glyphsInfo.maxSizeOfInstructions >> 8;
2796         tables.maxp.data[27] = glyphsInfo.maxSizeOfInstructions & 255;
2797       }
2798     }
2799     if (!tables.hhea) {
2800       throw new FormatError('Required "hhea" table is not found');
2801     }
2802 
2803     // Sanitizer reduces the glyph advanceWidth to the maxAdvanceWidth
2804     // Sometimes it's 0. That needs to be fixed
2805     if (tables.hhea.data[10] === 0 && tables.hhea.data[11] === 0) {
2806       tables.hhea.data[10] = 0xff;
2807       tables.hhea.data[11] = 0xff;
2808     }
2809 
2810     // Extract some more font properties from the OpenType head and
2811     // hhea tables; yMin and descent value are always negative.
2812     const metricsOverride = {
2813       unitsPerEm: int16(tables.head.data[18], tables.head.data[19]),
2814       yMax: signedInt16(tables.head.data[42], tables.head.data[43]),
2815       yMin: signedInt16(tables.head.data[38], tables.head.data[39]),
2816       ascent: signedInt16(tables.hhea.data[4], tables.hhea.data[5]),
2817       descent: signedInt16(tables.hhea.data[6], tables.hhea.data[7]),
2818       lineGap: signedInt16(tables.hhea.data[8], tables.hhea.data[9]),
2819     };
2820 
2821     // PDF FontDescriptor metrics lie -- using data from actual font.
2822     this.ascent = metricsOverride.ascent / metricsOverride.unitsPerEm;
2823     this.descent = metricsOverride.descent / metricsOverride.unitsPerEm;
2824     this.lineGap = metricsOverride.lineGap / metricsOverride.unitsPerEm;
2825 
2826     if (this.cssFontInfo?.lineHeight) {
2827       this.lineHeight = this.cssFontInfo.metrics.lineHeight;
2828       this.lineGap = this.cssFontInfo.metrics.lineGap;
2829     } else {
2830       this.lineHeight = this.ascent - this.descent + this.lineGap;
2831     }
2832 
2833     // The 'post' table has glyphs names.
2834     if (tables.post) {
2835       readPostScriptTable(tables.post, properties, numGlyphs);
2836     }
2837 
2838     // The original 'post' table is not needed, replace it.
2839     tables.post = {
2840       tag: "post",
2841       data: createPostTable(properties),
2842     };
2843 
2844     const charCodeToGlyphId = Object.create(null);
2845 
2846     // Helper function to try to skip mapping of empty glyphs.
2847     function hasGlyph(glyphId) {
2848       return !missingGlyphs[glyphId];
2849     }
2850 
2851     if (properties.composite) {
2852       const cidToGidMap = properties.cidToGidMap || [];
2853       const isCidToGidMapEmpty = cidToGidMap.length === 0;
2854 
2855       properties.cMap.forEach(function (charCode, cid) {
2856         if (typeof cid === "string") {
2857           cid = convertCidString(charCode, cid, /* shouldThrow = */ true);
2858         }
2859         if (cid > 0xffff) {
2860           throw new FormatError("Max size of CID is 65,535");
2861         }
2862         let glyphId = -1;
2863         if (isCidToGidMapEmpty) {
2864           glyphId = cid;
2865         } else if (cidToGidMap[cid] !== undefined) {
2866           glyphId = cidToGidMap[cid];
2867         }
2868 
2869         if (glyphId >= 0 && glyphId < numGlyphs && hasGlyph(glyphId)) {
2870           charCodeToGlyphId[charCode] = glyphId;
2871         }
2872       });
2873     } else {
2874       // Most of the following logic in this code branch is based on the
2875       // 9.6.6.4 of the PDF spec.
2876       const cmapTable = readCmapTable(
2877         tables.cmap,
2878         font,
2879         this.isSymbolicFont,
2880         properties.hasEncoding
2881       );
2882       const cmapPlatformId = cmapTable.platformId;
2883       const cmapEncodingId = cmapTable.encodingId;
2884       const cmapMappings = cmapTable.mappings;
2885       let baseEncoding = [],
2886         forcePostTable = false;
2887       if (
2888         properties.hasEncoding &&
2889         (properties.baseEncodingName === "MacRomanEncoding" ||
2890           properties.baseEncodingName === "WinAnsiEncoding")
2891       ) {
2892         baseEncoding = getEncoding(properties.baseEncodingName);
2893       }
2894 
2895       // If the font has an encoding and is not symbolic then follow the rules
2896       // in section 9.6.6.4 of the spec on how to map 3,1 and 1,0 cmaps.
2897       if (
2898         properties.hasEncoding &&
2899         !this.isSymbolicFont &&
2900         ((cmapPlatformId === 3 && cmapEncodingId === 1) ||
2901           (cmapPlatformId === 1 && cmapEncodingId === 0))
2902       ) {
2903         const glyphsUnicodeMap = getGlyphsUnicode();
2904         for (let charCode = 0; charCode < 256; charCode++) {
2905           let glyphName;
2906           if (this.differences[charCode] !== undefined) {
2907             glyphName = this.differences[charCode];
2908           } else if (baseEncoding.length && baseEncoding[charCode] !== "") {
2909             glyphName = baseEncoding[charCode];
2910           } else {
2911             glyphName = StandardEncoding[charCode];
2912           }
2913           if (!glyphName) {
2914             continue;
2915           }
2916           // Ensure that non-standard glyph names are resolved to valid ones.
2917           const standardGlyphName = recoverGlyphName(
2918             glyphName,
2919             glyphsUnicodeMap
2920           );
2921 
2922           let unicodeOrCharCode;
2923           if (cmapPlatformId === 3 && cmapEncodingId === 1) {
2924             unicodeOrCharCode = glyphsUnicodeMap[standardGlyphName];
2925           } else if (cmapPlatformId === 1 && cmapEncodingId === 0) {
2926             // TODO: the encoding needs to be updated with mac os table.
2927             unicodeOrCharCode = MacRomanEncoding.indexOf(standardGlyphName);
2928           }
2929 
2930           if (unicodeOrCharCode === undefined) {
2931             // Not a valid glyph name, fallback to using the /ToUnicode map
2932             // when no post-table exists (fixes issue13316_reduced.pdf).
2933             if (
2934               !properties.glyphNames &&
2935               properties.hasIncludedToUnicodeMap &&
2936               !(this.toUnicode instanceof IdentityToUnicodeMap)
2937             ) {
2938               const unicode = this.toUnicode.get(charCode);
2939               if (unicode) {
2940                 unicodeOrCharCode = unicode.codePointAt(0);
2941               }
2942             }
2943 
2944             if (unicodeOrCharCode === undefined) {
2945               continue; // No valid glyph mapping found.
2946             }
2947           }
2948 
2949           for (const mapping of cmapMappings) {
2950             if (mapping.charCode !== unicodeOrCharCode) {
2951               continue;
2952             }
2953             charCodeToGlyphId[charCode] = mapping.glyphId;
2954             break;
2955           }
2956         }
2957       } else if (cmapPlatformId === 0) {
2958         // Default Unicode semantics, use the charcodes as is.
2959         for (const mapping of cmapMappings) {
2960           charCodeToGlyphId[mapping.charCode] = mapping.glyphId;
2961         }
2962         // Always prefer the BaseEncoding/Differences arrays, when they exist
2963         // (fixes issue13433.pdf).
2964         forcePostTable = true;
2965       } else if (cmapPlatformId === 3 && cmapEncodingId === 0) {
2966         // When a (3, 0) cmap table is present, it is used instead but the
2967         // spec has special rules for char codes in the range of 0xF000 to
2968         // 0xF0FF and it says the (3, 0) table should map the values from
2969         // the (1, 0) table by prepending 0xF0 to the char codes. To reverse
2970         // this, the upper bits of the char code are cleared, but only for the
2971         // special range since some PDFs have char codes outside of this range
2972         // (e.g. 0x2013) which when masked would overwrite other values in the
2973         // cmap.
2974         for (const mapping of cmapMappings) {
2975           let charCode = mapping.charCode;
2976           if (charCode >= 0xf000 && charCode <= 0xf0ff) {
2977             charCode &= 0xff;
2978           }
2979           charCodeToGlyphId[charCode] = mapping.glyphId;
2980         }
2981       } else {
2982         // When there is only a (1, 0) cmap table, the char code is a single
2983         // byte and it is used directly as the char code.
2984         for (const mapping of cmapMappings) {
2985           charCodeToGlyphId[mapping.charCode] = mapping.glyphId;
2986         }
2987       }
2988 
2989       // Last, try to map any missing charcodes using the post table.
2990       if (
2991         properties.glyphNames &&
2992         (baseEncoding.length || this.differences.length)
2993       ) {
2994         for (let i = 0; i < 256; ++i) {
2995           if (!forcePostTable && charCodeToGlyphId[i] !== undefined) {
2996             continue;
2997           }
2998           const glyphName = this.differences[i] || baseEncoding[i];
2999           if (!glyphName) {
3000             continue;
3001           }
3002           const glyphId = properties.glyphNames.indexOf(glyphName);
3003           if (glyphId > 0 && hasGlyph(glyphId)) {
3004             charCodeToGlyphId[i] = glyphId;
3005           }
3006         }
3007       }
3008     }
3009 
3010     if (charCodeToGlyphId.length === 0) {
3011       // defines at least one glyph
3012       charCodeToGlyphId[0] = 0;
3013     }
3014 
3015     // Typically glyph 0 is duplicated and the mapping must be updated, but if
3016     // there isn't enough room to duplicate, the glyph id is left the same. In
3017     // this case, glyph 0 may not work correctly, but that is better than
3018     // having the whole font fail.
3019     let glyphZeroId = numGlyphsOut - 1;
3020     if (!dupFirstEntry) {
3021       glyphZeroId = 0;
3022     }
3023 
3024     // When `cssFontInfo` is set, the font is used to render text in the HTML
3025     // view (e.g. with Xfa) so nothing must be moved in the private use area.
3026     if (!properties.cssFontInfo) {
3027       // Converting glyphs and ids into font's cmap table
3028       const newMapping = adjustMapping(
3029         charCodeToGlyphId,
3030         hasGlyph,
3031         glyphZeroId,
3032         this.toUnicode
3033       );
3034       this.toFontChar = newMapping.toFontChar;
3035       tables.cmap = {
3036         tag: "cmap",
3037         data: createCmapTable(
3038           newMapping.charCodeToGlyphId,
3039           newMapping.toUnicodeExtraMap,
3040           numGlyphsOut
3041         ),
3042       };
3043 
3044       if (!tables["OS/2"] || !validateOS2Table(tables["OS/2"], font)) {
3045         tables["OS/2"] = {
3046           tag: "OS/2",
3047           data: createOS2Table(
3048             properties,
3049             newMapping.charCodeToGlyphId,
3050             metricsOverride
3051           ),
3052         };
3053       }
3054     }
3055 
3056     if (!isTrueType) {
3057       try {
3058         // Trying to repair CFF file
3059         cffFile = new Stream(tables["CFF "].data);
3060         const parser = new CFFParser(
3061           cffFile,
3062           properties,
3063           SEAC_ANALYSIS_ENABLED
3064         );
3065         cff = parser.parse();
3066         cff.duplicateFirstGlyph();
3067         const compiler = new CFFCompiler(cff);
3068         tables["CFF "].data = compiler.compile();
3069       } catch {
3070         warn("Failed to compile font " + properties.loadedName);
3071       }
3072     }
3073 
3074     // Re-creating 'name' table
3075     if (!tables.name) {
3076       tables.name = {
3077         tag: "name",
3078         data: createNameTable(this.name),
3079       };
3080     } else {
3081       // ... using existing 'name' table as prototype
3082       const [namePrototype, nameRecords] = readNameTable(tables.name);
3083 
3084       tables.name.data = createNameTable(name, namePrototype);
3085       this.psName = namePrototype[0][6] || null;
3086 
3087       if (!properties.composite) {
3088         // For TrueType fonts that do not include `ToUnicode` or `Encoding`
3089         // data, attempt to use the name-table to improve text selection.
3090         adjustTrueTypeToUnicode(properties, this.isSymbolicFont, nameRecords);
3091       }
3092     }
3093 
3094     const builder = new OpenTypeFileBuilder(header.version);
3095     for (const tableTag in tables) {
3096       builder.addTable(tableTag, tables[tableTag].data);
3097     }
3098     return builder.toArray();
3099   }
3100 
3101   convert(fontName, font, properties) {
3102     // TODO: Check the charstring widths to determine this.
3103     properties.fixedPitch = false;
3104 
3105     if (properties.builtInEncoding) {
3106       // For Type1 fonts that do not include either `ToUnicode` or `Encoding`
3107       // data, attempt to use the `builtInEncoding` to improve text selection.
3108       adjustType1ToUnicode(properties, properties.builtInEncoding);
3109     }
3110 
3111     // Type 1 fonts have a notdef inserted at the beginning, so glyph 0
3112     // becomes glyph 1. In a CFF font glyph 0 is appended to the end of the
3113     // char strings.
3114     let glyphZeroId = 1;
3115     if (font instanceof CFFFont) {
3116       glyphZeroId = font.numGlyphs - 1;
3117     }
3118     const mapping = font.getGlyphMapping(properties);
3119     let newMapping = null;
3120     let newCharCodeToGlyphId = mapping;
3121     let toUnicodeExtraMap = null;
3122 
3123     // When `cssFontInfo` is set, the font is used to render text in the HTML
3124     // view (e.g. with Xfa) so nothing must be moved in the private use area.
3125     if (!properties.cssFontInfo) {
3126       newMapping = adjustMapping(
3127         mapping,
3128         font.hasGlyphId.bind(font),
3129         glyphZeroId,
3130         this.toUnicode
3131       );
3132       this.toFontChar = newMapping.toFontChar;
3133       newCharCodeToGlyphId = newMapping.charCodeToGlyphId;
3134       toUnicodeExtraMap = newMapping.toUnicodeExtraMap;
3135     }
3136     const numGlyphs = font.numGlyphs;
3137 
3138     function getCharCodes(charCodeToGlyphId, glyphId) {
3139       let charCodes = null;
3140       for (const charCode in charCodeToGlyphId) {
3141         if (glyphId === charCodeToGlyphId[charCode]) {
3142           (charCodes ||= []).push(charCode | 0);
3143         }
3144       }
3145       return charCodes;
3146     }
3147 
3148     function createCharCode(charCodeToGlyphId, glyphId) {
3149       for (const charCode in charCodeToGlyphId) {
3150         if (glyphId === charCodeToGlyphId[charCode]) {
3151           return charCode | 0;
3152         }
3153       }
3154       newMapping.charCodeToGlyphId[newMapping.nextAvailableFontCharCode] =
3155         glyphId;
3156       return newMapping.nextAvailableFontCharCode++;
3157     }
3158 
3159     const seacs = font.seacs;
3160     if (newMapping && SEAC_ANALYSIS_ENABLED && seacs?.length) {
3161       const matrix = properties.fontMatrix || FONT_IDENTITY_MATRIX;
3162       const charset = font.getCharset();
3163       const seacMap = Object.create(null);
3164       for (let glyphId in seacs) {
3165         glyphId |= 0;
3166         const seac = seacs[glyphId];
3167         const baseGlyphName = StandardEncoding[seac[2]];
3168         const accentGlyphName = StandardEncoding[seac[3]];
3169         const baseGlyphId = charset.indexOf(baseGlyphName);
3170         const accentGlyphId = charset.indexOf(accentGlyphName);
3171         if (baseGlyphId < 0 || accentGlyphId < 0) {
3172           continue;
3173         }
3174         const accentOffset = {
3175           x: seac[0] * matrix[0] + seac[1] * matrix[2] + matrix[4],
3176           y: seac[0] * matrix[1] + seac[1] * matrix[3] + matrix[5],
3177         };
3178 
3179         const charCodes = getCharCodes(mapping, glyphId);
3180         if (!charCodes) {
3181           // There's no point in mapping it if the char code was never mapped
3182           // to begin with.
3183           continue;
3184         }
3185         for (const charCode of charCodes) {
3186           // Find a fontCharCode that maps to the base and accent glyphs.
3187           // If one doesn't exists, create it.
3188           const charCodeToGlyphId = newMapping.charCodeToGlyphId;
3189           const baseFontCharCode = createCharCode(
3190             charCodeToGlyphId,
3191             baseGlyphId
3192           );
3193           const accentFontCharCode = createCharCode(
3194             charCodeToGlyphId,
3195             accentGlyphId
3196           );
3197           seacMap[charCode] = {
3198             baseFontCharCode,
3199             accentFontCharCode,
3200             accentOffset,
3201           };
3202         }
3203       }
3204       properties.seacMap = seacMap;
3205     }
3206 
3207     const unitsPerEm = properties.fontMatrix
3208       ? 1 / Math.max(...properties.fontMatrix.slice(0, 4).map(Math.abs))
3209       : 1000;
3210 
3211     const builder = new OpenTypeFileBuilder("\x4F\x54\x54\x4F");
3212     // PostScript Font Program
3213     builder.addTable("CFF ", font.data);
3214     // OS/2 and Windows Specific metrics
3215     builder.addTable("OS/2", createOS2Table(properties, newCharCodeToGlyphId));
3216     // Character to glyphs mapping
3217     builder.addTable(
3218       "cmap",
3219       createCmapTable(newCharCodeToGlyphId, toUnicodeExtraMap, numGlyphs)
3220     );
3221     // Font header
3222     builder.addTable(
3223       "head",
3224       "\x00\x01\x00\x00" + // Version number
3225         "\x00\x00\x10\x00" + // fontRevision
3226         "\x00\x00\x00\x00" + // checksumAdjustement
3227         "\x5F\x0F\x3C\xF5" + // magicNumber
3228         "\x00\x00" + // Flags
3229         safeString16(unitsPerEm) + // unitsPerEM
3230         "\x00\x00\x00\x00\x9e\x0b\x7e\x27" + // creation date
3231         "\x00\x00\x00\x00\x9e\x0b\x7e\x27" + // modifification date
3232         "\x00\x00" + // xMin
3233         safeString16(properties.descent) + // yMin
3234         "\x0F\xFF" + // xMax
3235         safeString16(properties.ascent) + // yMax
3236         string16(properties.italicAngle ? 2 : 0) + // macStyle
3237         "\x00\x11" + // lowestRecPPEM
3238         "\x00\x00" + // fontDirectionHint
3239         "\x00\x00" + // indexToLocFormat
3240         "\x00\x00"
3241     ); // glyphDataFormat
3242 
3243     // Horizontal header
3244     builder.addTable(
3245       "hhea",
3246       "\x00\x01\x00\x00" + // Version number
3247         safeString16(properties.ascent) + // Typographic Ascent
3248         safeString16(properties.descent) + // Typographic Descent
3249         "\x00\x00" + // Line Gap
3250         "\xFF\xFF" + // advanceWidthMax
3251         "\x00\x00" + // minLeftSidebearing
3252         "\x00\x00" + // minRightSidebearing
3253         "\x00\x00" + // xMaxExtent
3254         safeString16(properties.capHeight) + // caretSlopeRise
3255         safeString16(Math.tan(properties.italicAngle) * properties.xHeight) + // caretSlopeRun
3256         "\x00\x00" + // caretOffset
3257         "\x00\x00" + // -reserved-
3258         "\x00\x00" + // -reserved-
3259         "\x00\x00" + // -reserved-
3260         "\x00\x00" + // -reserved-
3261         "\x00\x00" + // metricDataFormat
3262         string16(numGlyphs)
3263     ); // Number of HMetrics
3264 
3265     // Horizontal metrics
3266     builder.addTable(
3267       "hmtx",
3268       (function fontFieldsHmtx() {
3269         const charstrings = font.charstrings;
3270         const cffWidths = font.cff ? font.cff.widths : null;
3271         let hmtx = "\x00\x00\x00\x00"; // Fake .notdef
3272         for (let i = 1, ii = numGlyphs; i < ii; i++) {
3273           let width = 0;
3274           if (charstrings) {
3275             const charstring = charstrings[i - 1];
3276             width = "width" in charstring ? charstring.width : 0;
3277           } else if (cffWidths) {
3278             width = Math.ceil(cffWidths[i] || 0);
3279           }
3280           hmtx += string16(width) + string16(0);
3281         }
3282         return hmtx;
3283       })()
3284     );
3285 
3286     // Maximum profile
3287     builder.addTable(
3288       "maxp",
3289       "\x00\x00\x50\x00" + string16(numGlyphs) // Version number
3290     ); // Num of glyphs
3291 
3292     // Naming tables
3293     builder.addTable("name", createNameTable(fontName));
3294 
3295     // PostScript information
3296     builder.addTable("post", createPostTable(properties));
3297 
3298     return builder.toArray();
3299   }
3300 
3301   /**
3302    * @private
3303    */
3304   get _spaceWidth() {
3305     // trying to estimate space character width
3306     const possibleSpaceReplacements = ["space", "minus", "one", "i", "I"];
3307     let width;
3308     for (const glyphName of possibleSpaceReplacements) {
3309       // if possible, getting width by glyph name
3310       if (glyphName in this.widths) {
3311         width = this.widths[glyphName];
3312         break;
3313       }
3314       const glyphsUnicodeMap = getGlyphsUnicode();
3315       const glyphUnicode = glyphsUnicodeMap[glyphName];
3316       // finding the charcode via unicodeToCID map
3317       let charcode = 0;
3318       if (this.composite && this.cMap.contains(glyphUnicode)) {
3319         charcode = this.cMap.lookup(glyphUnicode);
3320 
3321         if (typeof charcode === "string") {
3322           charcode = convertCidString(glyphUnicode, charcode);
3323         }
3324       }
3325       // ... via toUnicode map
3326       if (!charcode && this.toUnicode) {
3327         charcode = this.toUnicode.charCodeOf(glyphUnicode);
3328       }
3329       // setting it to unicode if negative or undefined
3330       if (charcode <= 0) {
3331         charcode = glyphUnicode;
3332       }
3333       // trying to get width via charcode
3334       width = this.widths[charcode];
3335       if (width) {
3336         break; // the non-zero width found
3337       }
3338     }
3339     return shadow(this, "_spaceWidth", width || this.defaultWidth);
3340   }
3341 
3342   /**
3343    * @private
3344    */
3345   _charToGlyph(charcode, isSpace = false) {
3346     let glyph = this._glyphCache[charcode];
3347     // All `Glyph`-properties, except `isSpace` in multi-byte strings,
3348     // depend indirectly on the `charcode`.
3349     if (glyph?.isSpace === isSpace) {
3350       return glyph;
3351     }
3352     let fontCharCode, width, operatorListId;
3353 
3354     let widthCode = charcode;
3355     if (this.cMap?.contains(charcode)) {
3356       widthCode = this.cMap.lookup(charcode);
3357 
3358       if (typeof widthCode === "string") {
3359         widthCode = convertCidString(charcode, widthCode);
3360       }
3361     }
3362     width = this.widths[widthCode];
3363     if (typeof width !== "number") {
3364       width = this.defaultWidth;
3365     }
3366     const vmetric = this.vmetrics?.[widthCode];
3367 
3368     let unicode = this.toUnicode.get(charcode) || charcode;
3369     if (typeof unicode === "number") {
3370       unicode = String.fromCharCode(unicode);
3371     }
3372 
3373     let isInFont = this.toFontChar[charcode] !== undefined;
3374     // First try the toFontChar map, if it's not there then try falling
3375     // back to the char code.
3376     fontCharCode = this.toFontChar[charcode] || charcode;
3377     if (this.missingFile) {
3378       const glyphName =
3379         this.differences[charcode] || this.defaultEncoding[charcode];
3380       if (
3381         (glyphName === ".notdef" || glyphName === "") &&
3382         this.type === "Type1"
3383       ) {
3384         // .notdef glyphs should be invisible in non-embedded Type1 fonts, so
3385         // replace them with spaces.
3386         fontCharCode = 0x20;
3387 
3388         if (glyphName === "") {
3389           // Ensure that other relevant glyph properties are also updated
3390           // (fixes issue18059.pdf).
3391           width ||= this._spaceWidth;
3392           unicode = String.fromCharCode(fontCharCode);
3393         }
3394       }
3395       fontCharCode = mapSpecialUnicodeValues(fontCharCode);
3396     }
3397 
3398     if (this.isType3Font) {
3399       // Font char code in this case is actually a glyph name.
3400       operatorListId = fontCharCode;
3401     }
3402 
3403     let accent = null;
3404     if (this.seacMap?.[charcode]) {
3405       isInFont = true;
3406       const seac = this.seacMap[charcode];
3407       fontCharCode = seac.baseFontCharCode;
3408       accent = {
3409         fontChar: String.fromCodePoint(seac.accentFontCharCode),
3410         offset: seac.accentOffset,
3411       };
3412     }
3413 
3414     let fontChar = "";
3415     if (typeof fontCharCode === "number") {
3416       if (fontCharCode <= 0x10ffff) {
3417         fontChar = String.fromCodePoint(fontCharCode);
3418       } else {
3419         warn(`charToGlyph - invalid fontCharCode: ${fontCharCode}`);
3420       }
3421     }
3422 
3423     if (this.missingFile && this.vertical && fontChar.length === 1) {
3424       const vertical = getVerticalPresentationForm()[fontChar.charCodeAt(0)];
3425       if (vertical) {
3426         fontChar = unicode = String.fromCharCode(vertical);
3427       }
3428     }
3429 
3430     glyph = new Glyph(
3431       charcode,
3432       fontChar,
3433       unicode,
3434       accent,
3435       width,
3436       vmetric,
3437       operatorListId,
3438       isSpace,
3439       isInFont
3440     );
3441     return (this._glyphCache[charcode] = glyph);
3442   }
3443 
3444   charsToGlyphs(chars) {
3445     // If we translated this string before, just grab it from the cache.
3446     let glyphs = this._charsCache[chars];
3447     if (glyphs) {
3448       return glyphs;
3449     }
3450     glyphs = [];
3451 
3452     if (this.cMap) {
3453       // Composite fonts have multi-byte strings, convert the string from
3454       // single-byte to multi-byte.
3455       const c = Object.create(null),
3456         ii = chars.length;
3457       let i = 0;
3458       while (i < ii) {
3459         this.cMap.readCharCode(chars, i, c);
3460         const { charcode, length } = c;
3461         i += length;
3462         // Space is char with code 0x20 and length 1 in multiple-byte codes.
3463         const glyph = this._charToGlyph(
3464           charcode,
3465           length === 1 && chars.charCodeAt(i - 1) === 0x20
3466         );
3467         glyphs.push(glyph);
3468       }
3469     } else {
3470       for (let i = 0, ii = chars.length; i < ii; ++i) {
3471         const charcode = chars.charCodeAt(i);
3472         const glyph = this._charToGlyph(charcode, charcode === 0x20);
3473         glyphs.push(glyph);
3474       }
3475     }
3476 
3477     // Enter the translated string into the cache.
3478     return (this._charsCache[chars] = glyphs);
3479   }
3480 
3481   /**
3482    * Chars can have different sizes (depends on the encoding).
3483    * @param {String} a string encoded with font encoding.
3484    * @returns {Array<Array<number>>} the positions of each char in the string.
3485    */
3486   getCharPositions(chars) {
3487     // This function doesn't use a cache because
3488     // it's called only when saving or printing.
3489     const positions = [];
3490 
3491     if (this.cMap) {
3492       const c = Object.create(null);
3493       let i = 0;
3494       while (i < chars.length) {
3495         this.cMap.readCharCode(chars, i, c);
3496         const length = c.length;
3497         positions.push([i, i + length]);
3498         i += length;
3499       }
3500     } else {
3501       for (let i = 0, ii = chars.length; i < ii; ++i) {
3502         positions.push([i, i + 1]);
3503       }
3504     }
3505 
3506     return positions;
3507   }
3508 
3509   get glyphCacheValues() {
3510     return Object.values(this._glyphCache);
3511   }
3512 
3513   /**
3514    * Encode a js string using font encoding.
3515    * The resulting array contains an encoded string at even positions
3516    * (can be empty) and a non-encoded one at odd positions.
3517    * @param {String} a js string.
3518    * @returns {Array<String>} an array of encoded strings or non-encoded ones.
3519    */
3520   encodeString(str) {
3521     const buffers = [];
3522     const currentBuf = [];
3523 
3524     // buffers will contain: encoded, non-encoded, encoded, ...
3525     // currentBuf is pushed in buffers each time there is a change.
3526     // So when buffers.length is odd then the last string is an encoded one
3527     // and currentBuf contains non-encoded chars.
3528     const hasCurrentBufErrors = () => buffers.length % 2 === 1;
3529 
3530     const getCharCode =
3531       this.toUnicode instanceof IdentityToUnicodeMap
3532         ? unicode => this.toUnicode.charCodeOf(unicode)
3533         : unicode => this.toUnicode.charCodeOf(String.fromCodePoint(unicode));
3534 
3535     for (let i = 0, ii = str.length; i < ii; i++) {
3536       const unicode = str.codePointAt(i);
3537       if (unicode > 0xd7ff && (unicode < 0xe000 || unicode > 0xfffd)) {
3538         // unicode is represented by two uint16
3539         i++;
3540       }
3541       if (this.toUnicode) {
3542         const charCode = getCharCode(unicode);
3543         if (charCode !== -1) {
3544           if (hasCurrentBufErrors()) {
3545             buffers.push(currentBuf.join(""));
3546             currentBuf.length = 0;
3547           }
3548           const charCodeLength = this.cMap
3549             ? this.cMap.getCharCodeLength(charCode)
3550             : 1;
3551           for (let j = charCodeLength - 1; j >= 0; j--) {
3552             currentBuf.push(String.fromCharCode((charCode >> (8 * j)) & 0xff));
3553           }
3554           continue;
3555         }
3556       }
3557 
3558       // unicode can't be encoded
3559       if (!hasCurrentBufErrors()) {
3560         buffers.push(currentBuf.join(""));
3561         currentBuf.length = 0;
3562       }
3563       currentBuf.push(String.fromCodePoint(unicode));
3564     }
3565 
3566     buffers.push(currentBuf.join(""));
3567 
3568     return buffers;
3569   }
3570 }
3571 
3572 class ErrorFont {
3573   constructor(error) {
3574     this.error = error;
3575     this.loadedName = "g_font_error";
3576     this.missingFile = true;
3577   }
3578 
3579   charsToGlyphs() {
3580     return [];
3581   }
3582 
3583   encodeString(chars) {
3584     return [chars];
3585   }
3586 
3587   exportData(extraProperties = false) {
3588     return { error: this.error };
3589   }
3590 }
3591 
3592 export { ErrorFont, Font };
</code>

Your task:
You are a software tester at pdf.js.
1. Write exactly one javascript test `it("...", async () => {...})` block.
2. Your test must fail on the code before the patch, and pass after, hence the test will verify that the patch resolves the issue.
3. The test must be self-contained and to-the-point.
4. Use only the provided imports (respect the paths exactly how they are given) by importing dynamically for compatibility with Node.js — no new dependencies. 
5. Return only the javascript code (no comments or explanations).

Example structure:
it("should <describe behavior>", async () => {
  const { example } = await import("../../src/core/example.js");
  <initialize required variables>;
  <define expected variable>;
  <generate actual variables>;
  <compare expected with actual>;
});

