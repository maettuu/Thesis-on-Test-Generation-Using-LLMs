it("should handle inlined images without closing EI", async () => {
  const { getDocument } = await import("../../src/display/api.js");
  const { buildGetDocumentParams } = await import("./test_utils.js");
  const loadingTask = getDocument(buildGetDocumentParams('issue17794.pdf'));

  const handler = {
    send: () => {
      const response = new Response(new Uint8Array(), {
        status: 200,
        headers: { 'Content-Type': 'application/pdf' }
      });
      return Promise.resolve({ response });
    },
    sendWithPromise: jest.fn()
  };

  const options = {
    ignoreErrors: true
  };

  const idFactory = createIdFactory();
  const xref = new XRefMock();

  const evaluator = new PartialEvaluator({
    xref,
    handler,
    pageIndex: 0,
    idFactory,
    fontCache: new Map(),
    builtInCMapCache: new Map(),
    standardFontDataCache: new Map(),
    globalImageCache: new Map(),
    systemFontCache: new Map(),
    options,
  });

  const resources = new Dict();
  resources.set("ProcSet", new Name("PDF"));
  resources.set("ColorSpace", new Name("DeviceRGB"));

  const imageStream = new StringStream("q q");
  const image = {
    dict: new Dict(),
    getBytes: () => new Uint8Array(),
  };

  const operatorList = new OperatorList();

  const cacheKey = `img-${idFactory.createObjId()}`;
  const localImageCache = new Map();

  const result = await evaluator.buildPaintImageXObject({
    resources,
    image,
    isInline: true,
    operatorList,
    cacheKey,
    localImageCache,
    localColorSpaceCache: new Map(),
  });

  expect(console.warn).toHaveBeenCalledWith(/Unable to decode inline image/);
});