Before you begin:
- Keep going until the job is completely solved — don’t stop halfway.
- If you’re unsure about the behavior, reread the provided patch carefully; do not hallucinate.
- Plan your approach before writing code by reflecting on whether the test truly fails before and passes after.

Issue:
<issue>
Pdf document with image displayed in low quality
Attach (recommended) or Link to PDF file:
[Test.pdf](https://github.com/mozilla/pdf.js/files/11200736/Test.pdf)

Configuration:
- Web browser and its version: Chrome, Firefox
- Operating system and its version: Windows 10, 11
- PDF.js  version: v2.14.305, v3.5.141
- Is a browser extension: No

Steps to reproduce the problem:
1. Open attached pdf file in Firefox or Chrome
2. Open same pdf file in https://mozilla.github.io/pdf.js/web/viewer.html

What is the expected behavior?
logo image Firefox rendering
![exampleInFirefox](https://user-images.githubusercontent.com/84440240/231173752-81d24e7b-8902-4316-b7d1-0c951ed3e203.png)


What went wrong? (add screenshot)
In https://mozilla.github.io/pdf.js/web/viewer.html logo image is rendered in low quality compared to Firefox rendering

![exampleInViewer](https://user-images.githubusercontent.com/84440240/231173865-10cb29d4-674f-4685-a373-4be118a4a24d.png)

The same problem occurs when I use "pdfjs-dist" in my application code

```
    var scale = 1;
    var viewport = page.getViewport({scale: scale});
    var canvas = document.getElementById('the-canvas');
    var context = canvas.getContext('2d');
    canvas.height = viewport.height;
    canvas.width = viewport.width;
    var renderContext = {
      canvasContext: context,
      viewport: viewport
    };
    var renderTask = page.render(renderContext);
    renderTask.promise.then(function () {
	...
    }); 
```

I tried to increase the scale to 5 and set the canvas style width, height = 100%, and put canvas into wrapper

```
var scale = 5;
var viewport = page.getViewport(scale);
canvas.width = viewport.width;
canvas.height = viewport.height;
canvas.style.width = "100%";
canvas.style.height = "100%";
wrapper.style.width = Math.floor(viewport.width/scale) + 'pt';
wrapper.style.height = Math.floor(viewport.height/scale) + 'pt';
```

This slightly increased the quality of the logo, but it is still worse than when file opened in Firefox.


</issue>

Patch:
<patch>
diff --git a/src/display/canvas.js b/src/display/canvas.js
--- a/src/display/canvas.js
+++ b/src/display/canvas.js
@@ -913,6 +913,14 @@ function composeSMask(ctx, smask, layerCtx, layerBox) {
 }
 
 function getImageSmoothingEnabled(transform, interpolate) {
+  // In section 8.9.5.3 of the PDF spec, it's mentioned that the interpolate
+  // flag should be used when the image is upscaled.
+  // In Firefox, smoothing is always used when downscaling images (bug 1360415).
+
+  if (interpolate) {
+    return true;
+  }
+
   const scale = Util.singularValueDecompose2dScale(transform);
   // Round to a 32bit float so that `<=` check below will pass for numbers that
   // are very close, but not exactly the same 64bit floats.
@@ -921,15 +929,7 @@ function getImageSmoothingEnabled(transform, interpolate) {
   const actualScale = Math.fround(
     (globalThis.devicePixelRatio || 1) * PixelsPerInch.PDF_TO_CSS_UNITS
   );
-  if (interpolate !== undefined) {
-    // If the value is explicitly set use it.
-    return interpolate;
-  } else if (scale[0] <= actualScale || scale[1] <= actualScale) {
-    // Smooth when downscaling.
-    return true;
-  }
-  // Don't smooth when upscaling.
-  return false;
+  return scale[0] <= actualScale && scale[1] <= actualScale;
 }
 
 const LINE_CAP_STYLES = ["butt", "round", "square"];


</patch>

Imports:
<imports>
Available Packages
Dev Dependencies:
- @babel/core: ^7.24.4
- @babel/preset-env: ^7.24.4
- @babel/runtime: ^7.24.4
- @fluent/bundle: ^0.18.0
- @fluent/dom: ^0.9.0
- @jazzer.js/core: ^2.1.0
- autoprefixer: ^10.4.19
- babel-loader: ^9.1.3
- caniuse-lite: ^1.0.30001611
- canvas: ^2.11.2
- core-js: ^3.37.0
- cross-env: ^7.0.3
- eslint: ^8.57.0
- eslint-config-prettier: ^9.1.0
- eslint-plugin-fetch-options: ^0.0.5
- eslint-plugin-html: ^8.1.0
- eslint-plugin-import: ^2.29.1
- eslint-plugin-jasmine: ^4.1.3
- eslint-plugin-json: ^3.1.0
- eslint-plugin-mozilla: ^3.7.3
- eslint-plugin-no-unsanitized: ^4.0.2
- eslint-plugin-prettier: ^5.1.3
- eslint-plugin-sort-exports: ^0.9.1
- eslint-plugin-unicorn: ^52.0.0
- globals: ^15.0.0
- gulp: ^4.0.2
- gulp-cli: ^3.0.0
- gulp-postcss: ^10.0.0
- gulp-rename: ^2.0.0
- gulp-replace: ^1.1.4
- gulp-zip: ^6.0.0
- jasmine: ^5.1.0
- jsdoc: ^4.0.2
- jstransformer-markdown-it: ^3.0.0
- merge-stream: ^2.0.0
- needle: ^3.3.1
- path2d: ^0.2.0
- pngjs: ^7.0.0
- postcss: ^8.4.38
- postcss-dark-theme-class: ^1.2.1
- postcss-dir-pseudo-class: ^8.0.1
- postcss-discard-comments: ^6.0.2
- postcss-nesting: ^12.1.1
- prettier: ^3.2.5
- puppeteer: ^22.6.5
- rimraf: ^3.0.2
- streamqueue: ^1.1.2
- stylelint: ^16.3.1
- stylelint-prettier: ^5.0.0
- terser-webpack-plugin: ^5.3.10
- through2: ^4.0.2
- tsc-alias: ^1.8.8
- ttest: ^4.0.0
- typescript: ^5.4.5
- typogr: ^0.6.8
- vinyl: ^3.0.0
- webpack: ^5.91.0
- webpack-stream: ^7.0.0
- wintersmith: ^2.5.0
- yargs: ^17.7.2

Engines:
- node: >=18

Available Relative Imports:
- `../../src/core/annotation.js`: Annotation, AnnotationBorderStyle, AnnotationFactory, MarkupAnnotation, getQuadPoints
- `../../src/core/bidi.js`: bidi
- `../../src/core/cff_parser.js`: CFFCharset, CFFCompiler, CFFFDSelect, CFFParser, CFFStrings
- `../../src/core/cmap.js`: CMap, CMapFactory, IdentityCMap
- `../../src/core/colorspace.js`: ColorSpace
- `../../src/core/core_utils.js`: arrayBuffersToBytes, encodeToXmlString, escapePDFName, escapeString, getInheritableProperty, getSizeInBytes, isAscii, isWhiteSpace, log2, numberToString, parseXFAPath, recoverJsURL, stringToUTF16HexString, stringToUTF16String, toRomanNumerals, validateCSSFont
- `../../src/core/crypto.js`: AES128Cipher, AES256Cipher, ARCFourCipher, CipherTransformFactory, PDF17, PDF20, calculateMD5, calculateSHA256, calculateSHA384, calculateSHA512
- `../../src/core/default_appearance.js`: createDefaultAppearance, parseAppearanceStream, parseDefaultAppearance
- `../../src/core/document.js`: PDFDocument, Page
- `../../src/core/encodings.js`: getEncoding
- `../../src/core/evaluator.js`: PartialEvaluator
- `../../src/core/flate_stream.js`: FlateStream
- `../../src/core/font_substitutions.js`: getFontSubstitution
- `../../src/core/fonts_utils.js`: SEAC_ANALYSIS_ENABLED
- `../../src/core/function.js`: PDFFunctionFactory, PostScriptCompiler, PostScriptEvaluator
- `../../src/core/glyphlist.js`: getDingbatsGlyphsUnicode, getGlyphsUnicode
- `../../src/core/image_utils.js`: GlobalImageCache, LocalColorSpaceCache
- `../../src/core/jbig2.js`: Jbig2Error, Jbig2Image
- `../../src/core/jpg.js`: JpegError, JpegImage
- `../../src/core/jpx.js`: JpxError, JpxImage
- `../../src/core/metadata_parser.js`: MetadataParser
- `../../src/core/operator_list.js`: OperatorList
- `../../src/core/parser.js`: Lexer, Linearization, Parser
- `../../src/core/predictor_stream.js`: PredictorStream
- `../../src/core/primitives.js`: Cmd, Dict, EOF, Name, Ref, RefSet, RefSetCache, isCmd, isDict, isName, isRefsEqual
- `../../src/core/ps_parser.js`: PostScriptLexer, PostScriptParser
- `../../src/core/stream.js`: NullStream, Stream, StringStream
- `../../src/core/type1_parser.js`: Type1Parser
- `../../src/core/unicode.js`: getCharUnicodeCategory, getUnicodeForGlyph, getUnicodeRangeFor, mapSpecialUnicodeValues
- `../../src/core/worker.js`: WorkerMessageHandler, WorkerTask
- `../../src/core/writer.js`: incrementalUpdate, writeDict
- `../../src/core/xfa/bind.js`: Binder
- `../../src/core/xfa/data.js`: DataHandler
- `../../src/core/xfa/factory.js`: XFAFactory
- `../../src/core/xfa/formcalc_lexer.js`: Lexer, TOKEN, Token
- `../../src/core/xfa/formcalc_parser.js`: Errors, Parser
- `../../src/core/xfa/parser.js`: XFAParser
- `../../src/core/xfa/som.js`: searchNode
- `../../src/core/xfa/symbol_utils.js`: $dump, $getChildren, $getChildrenByClass, $getChildrenByName, $text, $uid
- `../../src/core/xml_parser.js`: SimpleXMLParser, XMLParserBase
- `../../src/display/annotation_layer.js`: AnnotationLayer
- `../../src/display/annotation_storage.js`: AnnotationStorage
- `../../src/display/api.js`: DefaultCMapReaderFactory, DefaultCanvasFactory, DefaultStandardFontDataFactory, LoopbackPort, PDFDataRangeTransport, PDFDocumentLoadingTask, PDFDocumentProxy, PDFPageProxy, PDFWorker, PDFWorkerUtil, RenderTask, build, getDocument, version
- `../../src/display/display_utils.js`: DOMCanvasFactory, DOMSVGFactory, PDFDateString, PageViewport, PixelsPerInch, RenderingCancelledException, StatTimer, fetchData, getFilenameFromUrl, getPdfFilenameFromUrl, getXfaPageViewport, isDataScheme, isPdfFile, isValidFetchUrl, noContextMenu, setLayerDimensions
- `../../src/display/draw_layer.js`: DrawLayer
- `../../src/display/editor/annotation_editor_layer.js`: AnnotationEditorLayer
- `../../src/display/editor/color_picker.js`: ColorPicker
- `../../src/display/editor/outliner.js`: Outliner
- `../../src/display/editor/tools.js`: AnnotationEditorUIManager, CommandManager
- `../../src/display/fetch_stream.js`: PDFFetchStream
- `../../src/display/metadata.js`: Metadata
- `../../src/display/network.js`: PDFNetworkStream
- `../../src/display/network_utils.js`: createResponseStatusError, extractFilenameFromHeader, validateRangeRequestCapabilities, validateResponseStatus
- `../../src/display/node_stream.js`: PDFNodeStream
- `../../src/display/text_layer.js`: TextLayerRenderTask, renderTextLayer, updateTextLayer
- `../../src/display/worker_options.js`: GlobalWorkerOptions
- `../../src/display/xfa_layer.js`: XfaLayer
- `../../src/shared/message_handler.js`: MessageHandler
- `../../src/shared/murmurhash3.js`: MurmurHash3_64
- `../../src/shared/util.js`: AbortException, AnnotationBorderStyleType, AnnotationEditorParamsType, AnnotationEditorType, AnnotationFieldFlag, AnnotationFlag, AnnotationMode, AnnotationType, CMapCompressionType, FeatureTest, FormatError, ImageKind, InvalidPDFException, MissingPDFException, OPS, PasswordException, PasswordResponses, PermissionFlag, RenderingIntentFlag, UnexpectedResponseException, UnknownErrorException, Util, VerbosityLevel, assert, bytesToString, createValidAbsoluteUrl, getModificationDate, getVerbosityLevel, isNodeJS, normalizeUnicode, objectSize, setVerbosityLevel, shadow, string32, stringToBytes, stringToPDFString, stringToUTF8String
- `../../web/annotation_layer_builder.js`: AnnotationLayerBuilder
- `../../web/app_options.js`: AppOptions, OptionKind
- `../../web/download_manager.js`: DownloadManager
- `../../web/event_utils.js`: EventBus, WaitOnType, waitOnEventOrTimeout
- `../../web/genericl10n.js`: GenericL10n
- `../../web/pdf_find_controller.js`: FindState, PDFFindController
- `../../web/pdf_find_utils.js`: CharacterType, getCharacterType
- `../../web/pdf_history.js`: PDFHistory, isDestArraysEqual, isDestHashesEqual
- `../../web/pdf_link_service.js`: LinkTarget, PDFLinkService, SimpleLinkService
- `../../web/pdf_page_view.js`: PDFPageView
- `../../web/pdf_scripting_manager.component.js`: PDFScriptingManager
- `../../web/pdf_single_page_viewer.js`: PDFSinglePageViewer
- `../../web/pdf_viewer.js`: PDFPageViewBuffer, PDFViewer
- `../../web/struct_tree_layer_builder.js`: StructTreeLayerBuilder
- `../../web/text_layer_builder.js`: TextLayerBuilder
- `../../web/ui_utils.js`: AutoPrintRegExp, ProgressBar, RenderingStates, ScrollMode, SpreadMode, backtrackBeforeAllVisibleElements, binarySearchFirstItem, getPageSizeInches, getVisibleElements, isPortraitOrientation, isValidRotation, parseQueryString, removeNullCharacters
- `../../web/xfa_layer_builder.js`: XfaLayerBuilder
- `./test_utils.js`: CMAP_URL, DefaultFileReaderFactory, STANDARD_FONT_DATA_URL, TEST_PDFS_PATH, XRefMock, buildGetDocumentParams, createIdFactory, createTemporaryNodeServer
- `./testreporter.js`: TestReporter
</imports>

Code:
<code>
File:
src/display/canvas.js
1 /* Copyright 2012 Mozilla Foundation
2  *
3  * Licensed under the Apache License, Version 2.0 (the "License");
4  * you may not use this file except in compliance with the License.
5  * You may obtain a copy of the License at
6  *
7  *     http://www.apache.org/licenses/LICENSE-2.0
8  *
9  * Unless required by applicable law or agreed to in writing, software
10  * distributed under the License is distributed on an "AS IS" BASIS,
11  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
12  * See the License for the specific language governing permissions and
13  * limitations under the License.
14  */
15 
16 import {
17   FeatureTest,
18   FONT_IDENTITY_MATRIX,
19   IDENTITY_MATRIX,
20   ImageKind,
21   info,
22   isNodeJS,
23   OPS,
24   shadow,
25   TextRenderingMode,
26   unreachable,
27   Util,
28   warn,
29 } from "../shared/util.js";
30 import {
31   getCurrentTransform,
32   getCurrentTransformInverse,
33   PixelsPerInch,
34 } from "./display_utils.js";
35 import {
36   getShadingPattern,
37   PathType,
38   TilingPattern,
39 } from "./pattern_helper.js";
40 import { convertBlackAndWhiteToRGBA } from "../shared/image_utils.js";
41 
42 // <canvas> contexts store most of the state we need natively.
43 // However, PDF needs a bit more state, which we store here.
44 // Minimal font size that would be used during canvas fillText operations.
45 const MIN_FONT_SIZE = 16;
46 // Maximum font size that would be used during canvas fillText operations.
47 const MAX_FONT_SIZE = 100;
48 const MAX_GROUP_SIZE = 4096;
49 
50 // Defines the time the `executeOperatorList`-method is going to be executing
51 // before it stops and schedules a continue of execution.
52 const EXECUTION_TIME = 15; // ms
53 // Defines the number of steps before checking the execution time.
54 const EXECUTION_STEPS = 10;
55 
56 // To disable Type3 compilation, set the value to `-1`.
57 const MAX_SIZE_TO_COMPILE = 1000;
58 
59 const FULL_CHUNK_HEIGHT = 16;
60 
61 /**
62  * Overrides certain methods on a 2d ctx so that when they are called they
63  * will also call the same method on the destCtx. The methods that are
64  * overridden are all the transformation state modifiers, path creation, and
65  * save/restore. We only forward these specific methods because they are the
66  * only state modifiers that we cannot copy over when we switch contexts.
67  *
68  * To remove mirroring call `ctx._removeMirroring()`.
69  *
70  * @param {Object} ctx - The 2d canvas context that will duplicate its calls on
71  *   the destCtx.
72  * @param {Object} destCtx - The 2d canvas context that will receive the
73  *   forwarded calls.
74  */
75 function mirrorContextOperations(ctx, destCtx) {
76   if (ctx._removeMirroring) {
77     throw new Error("Context is already forwarding operations.");
78   }
79   ctx.__originalSave = ctx.save;
80   ctx.__originalRestore = ctx.restore;
81   ctx.__originalRotate = ctx.rotate;
82   ctx.__originalScale = ctx.scale;
83   ctx.__originalTranslate = ctx.translate;
84   ctx.__originalTransform = ctx.transform;
85   ctx.__originalSetTransform = ctx.setTransform;
86   ctx.__originalResetTransform = ctx.resetTransform;
87   ctx.__originalClip = ctx.clip;
88   ctx.__originalMoveTo = ctx.moveTo;
89   ctx.__originalLineTo = ctx.lineTo;
90   ctx.__originalBezierCurveTo = ctx.bezierCurveTo;
91   ctx.__originalRect = ctx.rect;
92   ctx.__originalClosePath = ctx.closePath;
93   ctx.__originalBeginPath = ctx.beginPath;
94 
95   ctx._removeMirroring = () => {
96     ctx.save = ctx.__originalSave;
97     ctx.restore = ctx.__originalRestore;
98     ctx.rotate = ctx.__originalRotate;
99     ctx.scale = ctx.__originalScale;
100     ctx.translate = ctx.__originalTranslate;
101     ctx.transform = ctx.__originalTransform;
102     ctx.setTransform = ctx.__originalSetTransform;
103     ctx.resetTransform = ctx.__originalResetTransform;
104 
105     ctx.clip = ctx.__originalClip;
106     ctx.moveTo = ctx.__originalMoveTo;
107     ctx.lineTo = ctx.__originalLineTo;
108     ctx.bezierCurveTo = ctx.__originalBezierCurveTo;
109     ctx.rect = ctx.__originalRect;
110     ctx.closePath = ctx.__originalClosePath;
111     ctx.beginPath = ctx.__originalBeginPath;
112     delete ctx._removeMirroring;
113   };
114 
115   ctx.save = function ctxSave() {
116     destCtx.save();
117     this.__originalSave();
118   };
119 
120   ctx.restore = function ctxRestore() {
121     destCtx.restore();
122     this.__originalRestore();
123   };
124 
125   ctx.translate = function ctxTranslate(x, y) {
126     destCtx.translate(x, y);
127     this.__originalTranslate(x, y);
128   };
129 
130   ctx.scale = function ctxScale(x, y) {
131     destCtx.scale(x, y);
132     this.__originalScale(x, y);
133   };
134 
135   ctx.transform = function ctxTransform(a, b, c, d, e, f) {
136     destCtx.transform(a, b, c, d, e, f);
137     this.__originalTransform(a, b, c, d, e, f);
138   };
139 
140   ctx.setTransform = function ctxSetTransform(a, b, c, d, e, f) {
141     destCtx.setTransform(a, b, c, d, e, f);
142     this.__originalSetTransform(a, b, c, d, e, f);
143   };
144 
145   ctx.resetTransform = function ctxResetTransform() {
146     destCtx.resetTransform();
147     this.__originalResetTransform();
148   };
149 
150   ctx.rotate = function ctxRotate(angle) {
151     destCtx.rotate(angle);
152     this.__originalRotate(angle);
153   };
154 
155   ctx.clip = function ctxRotate(rule) {
156     destCtx.clip(rule);
157     this.__originalClip(rule);
158   };
159 
160   ctx.moveTo = function (x, y) {
161     destCtx.moveTo(x, y);
162     this.__originalMoveTo(x, y);
163   };
164 
165   ctx.lineTo = function (x, y) {
166     destCtx.lineTo(x, y);
167     this.__originalLineTo(x, y);
168   };
169 
170   ctx.bezierCurveTo = function (cp1x, cp1y, cp2x, cp2y, x, y) {
171     destCtx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y);
172     this.__originalBezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y);
173   };
174 
175   ctx.rect = function (x, y, width, height) {
176     destCtx.rect(x, y, width, height);
177     this.__originalRect(x, y, width, height);
178   };
179 
180   ctx.closePath = function () {
181     destCtx.closePath();
182     this.__originalClosePath();
183   };
184 
185   ctx.beginPath = function () {
186     destCtx.beginPath();
187     this.__originalBeginPath();
188   };
189 }
190 
191 class CachedCanvases {
192   constructor(canvasFactory) {
193     this.canvasFactory = canvasFactory;
194     this.cache = Object.create(null);
195   }
196 
197   getCanvas(id, width, height) {
198     let canvasEntry;
199     if (this.cache[id] !== undefined) {
200       canvasEntry = this.cache[id];
201       this.canvasFactory.reset(canvasEntry, width, height);
202     } else {
203       canvasEntry = this.canvasFactory.create(width, height);
204       this.cache[id] = canvasEntry;
205     }
206     return canvasEntry;
207   }
208 
209   delete(id) {
210     delete this.cache[id];
211   }
212 
213   clear() {
214     for (const id in this.cache) {
215       const canvasEntry = this.cache[id];
216       this.canvasFactory.destroy(canvasEntry);
217       delete this.cache[id];
218     }
219   }
220 }
221 
222 function drawImageAtIntegerCoords(
223   ctx,
224   srcImg,
225   srcX,
226   srcY,
227   srcW,
228   srcH,
229   destX,
230   destY,
231   destW,
232   destH
233 ) {
234   const [a, b, c, d, tx, ty] = getCurrentTransform(ctx);
235   if (b === 0 && c === 0) {
236     // top-left corner is at (X, Y) and
237     // bottom-right one is at (X + width, Y + height).
238 
239     // If leftX is 4.321 then it's rounded to 4.
240     // If width is 10.432 then it's rounded to 11 because
241     // rightX = leftX + width = 14.753 which is rounded to 15
242     // so after rounding the total width is 11 (15 - 4).
243     // It's why we can't just floor/ceil uniformly, it just depends
244     // on the values we've.
245 
246     const tlX = destX * a + tx;
247     const rTlX = Math.round(tlX);
248     const tlY = destY * d + ty;
249     const rTlY = Math.round(tlY);
250     const brX = (destX + destW) * a + tx;
251 
252     // Some pdf contains images with 1x1 images so in case of 0-width after
253     // scaling we must fallback on 1 to be sure there is something.
254     const rWidth = Math.abs(Math.round(brX) - rTlX) || 1;
255     const brY = (destY + destH) * d + ty;
256     const rHeight = Math.abs(Math.round(brY) - rTlY) || 1;
257 
258     // We must apply a transformation in order to apply it on the image itself.
259     // For example if a == 1 && d == -1, it means that the image itself is
260     // mirrored w.r.t. the x-axis.
261     ctx.setTransform(Math.sign(a), 0, 0, Math.sign(d), rTlX, rTlY);
262     ctx.drawImage(srcImg, srcX, srcY, srcW, srcH, 0, 0, rWidth, rHeight);
263     ctx.setTransform(a, b, c, d, tx, ty);
264 
265     return [rWidth, rHeight];
266   }
267 
268   if (a === 0 && d === 0) {
269     // This path is taken in issue9462.pdf (page 3).
270     const tlX = destY * c + tx;
271     const rTlX = Math.round(tlX);
272     const tlY = destX * b + ty;
273     const rTlY = Math.round(tlY);
274     const brX = (destY + destH) * c + tx;
275     const rWidth = Math.abs(Math.round(brX) - rTlX) || 1;
276     const brY = (destX + destW) * b + ty;
277     const rHeight = Math.abs(Math.round(brY) - rTlY) || 1;
278 
279     ctx.setTransform(0, Math.sign(b), Math.sign(c), 0, rTlX, rTlY);
280     ctx.drawImage(srcImg, srcX, srcY, srcW, srcH, 0, 0, rHeight, rWidth);
281     ctx.setTransform(a, b, c, d, tx, ty);
282 
283     return [rHeight, rWidth];
284   }
285 
286   // Not a scale matrix so let the render handle the case without rounding.
287   ctx.drawImage(srcImg, srcX, srcY, srcW, srcH, destX, destY, destW, destH);
288 
289   const scaleX = Math.hypot(a, b);
290   const scaleY = Math.hypot(c, d);
291   return [scaleX * destW, scaleY * destH];
292 }
293 
294 function compileType3Glyph(imgData) {
295   const { width, height } = imgData;
296   if (width > MAX_SIZE_TO_COMPILE || height > MAX_SIZE_TO_COMPILE) {
297     return null;
298   }
299 
300   const POINT_TO_PROCESS_LIMIT = 1000;
301   const POINT_TYPES = new Uint8Array([
302     0, 2, 4, 0, 1, 0, 5, 4, 8, 10, 0, 8, 0, 2, 1, 0,
303   ]);
304 
305   const width1 = width + 1;
306   let points = new Uint8Array(width1 * (height + 1));
307   let i, j, j0;
308 
309   // decodes bit-packed mask data
310   const lineSize = (width + 7) & ~7;
311   let data = new Uint8Array(lineSize * height),
312     pos = 0;
313   for (const elem of imgData.data) {
314     let mask = 128;
315     while (mask > 0) {
316       data[pos++] = elem & mask ? 0 : 255;
317       mask >>= 1;
318     }
319   }
320 
321   // finding interesting points: every point is located between mask pixels,
322   // so there will be points of the (width + 1)x(height + 1) grid. Every point
323   // will have flags assigned based on neighboring mask pixels:
324   //   4 | 8
325   //   --P--
326   //   2 | 1
327   // We are interested only in points with the flags:
328   //   - outside corners: 1, 2, 4, 8;
329   //   - inside corners: 7, 11, 13, 14;
330   //   - and, intersections: 5, 10.
331   let count = 0;
332   pos = 0;
333   if (data[pos] !== 0) {
334     points[0] = 1;
335     ++count;
336   }
337   for (j = 1; j < width; j++) {
338     if (data[pos] !== data[pos + 1]) {
339       points[j] = data[pos] ? 2 : 1;
340       ++count;
341     }
342     pos++;
343   }
344   if (data[pos] !== 0) {
345     points[j] = 2;
346     ++count;
347   }
348   for (i = 1; i < height; i++) {
349     pos = i * lineSize;
350     j0 = i * width1;
351     if (data[pos - lineSize] !== data[pos]) {
352       points[j0] = data[pos] ? 1 : 8;
353       ++count;
354     }
355     // 'sum' is the position of the current pixel configuration in the 'TYPES'
356     // array (in order 8-1-2-4, so we can use '>>2' to shift the column).
357     let sum = (data[pos] ? 4 : 0) + (data[pos - lineSize] ? 8 : 0);
358     for (j = 1; j < width; j++) {
359       sum =
360         (sum >> 2) +
361         (data[pos + 1] ? 4 : 0) +
362         (data[pos - lineSize + 1] ? 8 : 0);
363       if (POINT_TYPES[sum]) {
364         points[j0 + j] = POINT_TYPES[sum];
365         ++count;
366       }
367       pos++;
368     }
369     if (data[pos - lineSize] !== data[pos]) {
370       points[j0 + j] = data[pos] ? 2 : 4;
371       ++count;
372     }
373 
374     if (count > POINT_TO_PROCESS_LIMIT) {
375       return null;
376     }
377   }
378 
379   pos = lineSize * (height - 1);
380   j0 = i * width1;
381   if (data[pos] !== 0) {
382     points[j0] = 8;
383     ++count;
384   }
385   for (j = 1; j < width; j++) {
386     if (data[pos] !== data[pos + 1]) {
387       points[j0 + j] = data[pos] ? 4 : 8;
388       ++count;
389     }
390     pos++;
391   }
392   if (data[pos] !== 0) {
393     points[j0 + j] = 4;
394     ++count;
395   }
396   if (count > POINT_TO_PROCESS_LIMIT) {
397     return null;
398   }
399 
400   // building outlines
401   const steps = new Int32Array([0, width1, -1, 0, -width1, 0, 0, 0, 1]);
402   const path = new Path2D();
403 
404   for (i = 0; count && i <= height; i++) {
405     let p = i * width1;
406     const end = p + width;
407     while (p < end && !points[p]) {
408       p++;
409     }
410     if (p === end) {
411       continue;
412     }
413     path.moveTo(p % width1, i);
414 
415     const p0 = p;
416     let type = points[p];
417     do {
418       const step = steps[type];
419       do {
420         p += step;
421       } while (!points[p]);
422 
423       const pp = points[p];
424       if (pp !== 5 && pp !== 10) {
425         // set new direction
426         type = pp;
427         // delete mark
428         points[p] = 0;
429       } else {
430         // type is 5 or 10, ie, a crossing
431         // set new direction
432         type = pp & ((0x33 * type) >> 4);
433         // set new type for "future hit"
434         points[p] &= (type >> 2) | (type << 2);
435       }
436       path.lineTo(p % width1, (p / width1) | 0);
437 
438       if (!points[p]) {
439         --count;
440       }
441     } while (p0 !== p);
442     --i;
443   }
444 
445   // Immediately release the, potentially large, `Uint8Array`s after parsing.
446   data = null;
447   points = null;
448 
449   const drawOutline = function (c) {
450     c.save();
451     // the path shall be painted in [0..1]x[0..1] space
452     c.scale(1 / width, -1 / height);
453     c.translate(0, -height);
454     c.fill(path);
455     c.beginPath();
456     c.restore();
457   };
458 
459   return drawOutline;
460 }
461 
462 class CanvasExtraState {
463   constructor(width, height) {
464     // Are soft masks and alpha values shapes or opacities?
465     this.alphaIsShape = false;
466     this.fontSize = 0;
467     this.fontSizeScale = 1;
468     this.textMatrix = IDENTITY_MATRIX;
469     this.textMatrixScale = 1;
470     this.fontMatrix = FONT_IDENTITY_MATRIX;
471     this.leading = 0;
472     // Current point (in user coordinates)
473     this.x = 0;
474     this.y = 0;
475     // Start of text line (in text coordinates)
476     this.lineX = 0;
477     this.lineY = 0;
478     // Character and word spacing
479     this.charSpacing = 0;
480     this.wordSpacing = 0;
481     this.textHScale = 1;
482     this.textRenderingMode = TextRenderingMode.FILL;
483     this.textRise = 0;
484     // Default fore and background colors
485     this.fillColor = "#000000";
486     this.strokeColor = "#000000";
487     this.patternFill = false;
488     // Note: fill alpha applies to all non-stroking operations
489     this.fillAlpha = 1;
490     this.strokeAlpha = 1;
491     this.lineWidth = 1;
492     this.activeSMask = null;
493     this.transferMaps = "none";
494 
495     this.startNewPathAndClipBox([0, 0, width, height]);
496   }
497 
498   clone() {
499     const clone = Object.create(this);
500     clone.clipBox = this.clipBox.slice();
501     return clone;
502   }
503 
504   setCurrentPoint(x, y) {
505     this.x = x;
506     this.y = y;
507   }
508 
509   updatePathMinMax(transform, x, y) {
510     [x, y] = Util.applyTransform([x, y], transform);
511     this.minX = Math.min(this.minX, x);
512     this.minY = Math.min(this.minY, y);
513     this.maxX = Math.max(this.maxX, x);
514     this.maxY = Math.max(this.maxY, y);
515   }
516 
517   updateRectMinMax(transform, rect) {
518     const p1 = Util.applyTransform(rect, transform);
519     const p2 = Util.applyTransform(rect.slice(2), transform);
520     const p3 = Util.applyTransform([rect[0], rect[3]], transform);
521     const p4 = Util.applyTransform([rect[2], rect[1]], transform);
522 
523     this.minX = Math.min(this.minX, p1[0], p2[0], p3[0], p4[0]);
524     this.minY = Math.min(this.minY, p1[1], p2[1], p3[1], p4[1]);
525     this.maxX = Math.max(this.maxX, p1[0], p2[0], p3[0], p4[0]);
526     this.maxY = Math.max(this.maxY, p1[1], p2[1], p3[1], p4[1]);
527   }
528 
529   updateScalingPathMinMax(transform, minMax) {
530     Util.scaleMinMax(transform, minMax);
531     this.minX = Math.min(this.minX, minMax[0]);
532     this.minY = Math.min(this.minY, minMax[1]);
533     this.maxX = Math.max(this.maxX, minMax[2]);
534     this.maxY = Math.max(this.maxY, minMax[3]);
535   }
536 
537   updateCurvePathMinMax(transform, x0, y0, x1, y1, x2, y2, x3, y3, minMax) {
538     const box = Util.bezierBoundingBox(x0, y0, x1, y1, x2, y2, x3, y3, minMax);
539     if (minMax) {
540       return;
541     }
542     this.updateRectMinMax(transform, box);
543   }
544 
545   getPathBoundingBox(pathType = PathType.FILL, transform = null) {
546     const box = [this.minX, this.minY, this.maxX, this.maxY];
547     if (pathType === PathType.STROKE) {
548       if (!transform) {
549         unreachable("Stroke bounding box must include transform.");
550       }
551       // Stroked paths can be outside of the path bounding box by 1/2 the line
552       // width.
553       const scale = Util.singularValueDecompose2dScale(transform);
554       const xStrokePad = (scale[0] * this.lineWidth) / 2;
555       const yStrokePad = (scale[1] * this.lineWidth) / 2;
556       box[0] -= xStrokePad;
557       box[1] -= yStrokePad;
558       box[2] += xStrokePad;
559       box[3] += yStrokePad;
560     }
561     return box;
562   }
563 
564   updateClipFromPath() {
565     const intersect = Util.intersect(this.clipBox, this.getPathBoundingBox());
566     this.startNewPathAndClipBox(intersect || [0, 0, 0, 0]);
567   }
568 
569   isEmptyClip() {
570     return this.minX === Infinity;
571   }
572 
573   startNewPathAndClipBox(box) {
574     this.clipBox = box;
575     this.minX = Infinity;
576     this.minY = Infinity;
577     this.maxX = 0;
578     this.maxY = 0;
579   }
580 
581   getClippedPathBoundingBox(pathType = PathType.FILL, transform = null) {
582     return Util.intersect(
583       this.clipBox,
584       this.getPathBoundingBox(pathType, transform)
585     );
586   }
587 }
588 
589 function putBinaryImageData(ctx, imgData) {
590   if (typeof ImageData !== "undefined" && imgData instanceof ImageData) {
591     ctx.putImageData(imgData, 0, 0);
592     return;
593   }
594 
595   // Put the image data to the canvas in chunks, rather than putting the
596   // whole image at once.  This saves JS memory, because the ImageData object
597   // is smaller. It also possibly saves C++ memory within the implementation
598   // of putImageData(). (E.g. in Firefox we make two short-lived copies of
599   // the data passed to putImageData()). |n| shouldn't be too small, however,
600   // because too many putImageData() calls will slow things down.
601   //
602   // Note: as written, if the last chunk is partial, the putImageData() call
603   // will (conceptually) put pixels past the bounds of the canvas.  But
604   // that's ok; any such pixels are ignored.
605 
606   const height = imgData.height,
607     width = imgData.width;
608   const partialChunkHeight = height % FULL_CHUNK_HEIGHT;
609   const fullChunks = (height - partialChunkHeight) / FULL_CHUNK_HEIGHT;
610   const totalChunks = partialChunkHeight === 0 ? fullChunks : fullChunks + 1;
611 
612   const chunkImgData = ctx.createImageData(width, FULL_CHUNK_HEIGHT);
613   let srcPos = 0,
614     destPos;
615   const src = imgData.data;
616   const dest = chunkImgData.data;
617   let i, j, thisChunkHeight, elemsInThisChunk;
618 
619   // There are multiple forms in which the pixel data can be passed, and
620   // imgData.kind tells us which one this is.
621   if (imgData.kind === ImageKind.GRAYSCALE_1BPP) {
622     // Grayscale, 1 bit per pixel (i.e. black-and-white).
623     const srcLength = src.byteLength;
624     const dest32 = new Uint32Array(dest.buffer, 0, dest.byteLength >> 2);
625     const dest32DataLength = dest32.length;
626     const fullSrcDiff = (width + 7) >> 3;
627     const white = 0xffffffff;
628     const black = FeatureTest.isLittleEndian ? 0xff000000 : 0x000000ff;
629 
630     for (i = 0; i < totalChunks; i++) {
631       thisChunkHeight = i < fullChunks ? FULL_CHUNK_HEIGHT : partialChunkHeight;
632       destPos = 0;
633       for (j = 0; j < thisChunkHeight; j++) {
634         const srcDiff = srcLength - srcPos;
635         let k = 0;
636         const kEnd = srcDiff > fullSrcDiff ? width : srcDiff * 8 - 7;
637         const kEndUnrolled = kEnd & ~7;
638         let mask = 0;
639         let srcByte = 0;
640         for (; k < kEndUnrolled; k += 8) {
641           srcByte = src[srcPos++];
642           dest32[destPos++] = srcByte & 128 ? white : black;
643           dest32[destPos++] = srcByte & 64 ? white : black;
644           dest32[destPos++] = srcByte & 32 ? white : black;
645           dest32[destPos++] = srcByte & 16 ? white : black;
646           dest32[destPos++] = srcByte & 8 ? white : black;
647           dest32[destPos++] = srcByte & 4 ? white : black;
648           dest32[destPos++] = srcByte & 2 ? white : black;
649           dest32[destPos++] = srcByte & 1 ? white : black;
650         }
651         for (; k < kEnd; k++) {
652           if (mask === 0) {
653             srcByte = src[srcPos++];
654             mask = 128;
655           }
656 
657           dest32[destPos++] = srcByte & mask ? white : black;
658           mask >>= 1;
659         }
660       }
661       // We ran out of input. Make all remaining pixels transparent.
662       while (destPos < dest32DataLength) {
663         dest32[destPos++] = 0;
664       }
665 
666       ctx.putImageData(chunkImgData, 0, i * FULL_CHUNK_HEIGHT);
667     }
668   } else if (imgData.kind === ImageKind.RGBA_32BPP) {
669     // RGBA, 32-bits per pixel.
670     j = 0;
671     elemsInThisChunk = width * FULL_CHUNK_HEIGHT * 4;
672     for (i = 0; i < fullChunks; i++) {
673       dest.set(src.subarray(srcPos, srcPos + elemsInThisChunk));
674       srcPos += elemsInThisChunk;
675 
676       ctx.putImageData(chunkImgData, 0, j);
677       j += FULL_CHUNK_HEIGHT;
678     }
679     if (i < totalChunks) {
680       elemsInThisChunk = width * partialChunkHeight * 4;
681       dest.set(src.subarray(srcPos, srcPos + elemsInThisChunk));
682 
683       ctx.putImageData(chunkImgData, 0, j);
684     }
685   } else if (imgData.kind === ImageKind.RGB_24BPP) {
686     // RGB, 24-bits per pixel.
687     thisChunkHeight = FULL_CHUNK_HEIGHT;
688     elemsInThisChunk = width * thisChunkHeight;
689     for (i = 0; i < totalChunks; i++) {
690       if (i >= fullChunks) {
691         thisChunkHeight = partialChunkHeight;
692         elemsInThisChunk = width * thisChunkHeight;
693       }
694 
695       destPos = 0;
696       for (j = elemsInThisChunk; j--; ) {
697         dest[destPos++] = src[srcPos++];
698         dest[destPos++] = src[srcPos++];
699         dest[destPos++] = src[srcPos++];
700         dest[destPos++] = 255;
701       }
702 
703       ctx.putImageData(chunkImgData, 0, i * FULL_CHUNK_HEIGHT);
704     }
705   } else {
706     throw new Error(`bad image kind: ${imgData.kind}`);
707   }
708 }
709 
710 function putBinaryImageMask(ctx, imgData) {
711   if (imgData.bitmap) {
712     // The bitmap has been created in the worker.
713     ctx.drawImage(imgData.bitmap, 0, 0);
714     return;
715   }
716 
717   // Slow path: OffscreenCanvas isn't available in the worker.
718   const height = imgData.height,
719     width = imgData.width;
720   const partialChunkHeight = height % FULL_CHUNK_HEIGHT;
721   const fullChunks = (height - partialChunkHeight) / FULL_CHUNK_HEIGHT;
722   const totalChunks = partialChunkHeight === 0 ? fullChunks : fullChunks + 1;
723 
724   const chunkImgData = ctx.createImageData(width, FULL_CHUNK_HEIGHT);
725   let srcPos = 0;
726   const src = imgData.data;
727   const dest = chunkImgData.data;
728 
729   for (let i = 0; i < totalChunks; i++) {
730     const thisChunkHeight =
731       i < fullChunks ? FULL_CHUNK_HEIGHT : partialChunkHeight;
732 
733     // Expand the mask so it can be used by the canvas.  Any required
734     // inversion has already been handled.
735 
736     ({ srcPos } = convertBlackAndWhiteToRGBA({
737       src,
738       srcPos,
739       dest,
740       width,
741       height: thisChunkHeight,
742       nonBlackColor: 0,
743     }));
744 
745     ctx.putImageData(chunkImgData, 0, i * FULL_CHUNK_HEIGHT);
746   }
747 }
748 
749 function copyCtxState(sourceCtx, destCtx) {
750   const properties = [
751     "strokeStyle",
752     "fillStyle",
753     "fillRule",
754     "globalAlpha",
755     "lineWidth",
756     "lineCap",
757     "lineJoin",
758     "miterLimit",
759     "globalCompositeOperation",
760     "font",
761     "filter",
762   ];
763   for (const property of properties) {
764     if (sourceCtx[property] !== undefined) {
765       destCtx[property] = sourceCtx[property];
766     }
767   }
768   if (sourceCtx.setLineDash !== undefined) {
769     destCtx.setLineDash(sourceCtx.getLineDash());
770     destCtx.lineDashOffset = sourceCtx.lineDashOffset;
771   }
772 }
773 
774 function resetCtxToDefault(ctx) {
775   ctx.strokeStyle = ctx.fillStyle = "#000000";
776   ctx.fillRule = "nonzero";
777   ctx.globalAlpha = 1;
778   ctx.lineWidth = 1;
779   ctx.lineCap = "butt";
780   ctx.lineJoin = "miter";
781   ctx.miterLimit = 10;
782   ctx.globalCompositeOperation = "source-over";
783   ctx.font = "10px sans-serif";
784   if (ctx.setLineDash !== undefined) {
785     ctx.setLineDash([]);
786     ctx.lineDashOffset = 0;
787   }
788   if (
789     (typeof PDFJSDev !== "undefined" && PDFJSDev.test("MOZCENTRAL")) ||
790     !isNodeJS
791   ) {
792     const { filter } = ctx;
793     if (filter !== "none" && filter !== "") {
794       ctx.filter = "none";
795     }
796   }
797 }
798 
799 function composeSMaskBackdrop(bytes, r0, g0, b0) {
800   const length = bytes.length;
801   for (let i = 3; i < length; i += 4) {
802     const alpha = bytes[i];
803     if (alpha === 0) {
804       bytes[i - 3] = r0;
805       bytes[i - 2] = g0;
806       bytes[i - 1] = b0;
807     } else if (alpha < 255) {
808       const alpha_ = 255 - alpha;
809       bytes[i - 3] = (bytes[i - 3] * alpha + r0 * alpha_) >> 8;
810       bytes[i - 2] = (bytes[i - 2] * alpha + g0 * alpha_) >> 8;
811       bytes[i - 1] = (bytes[i - 1] * alpha + b0 * alpha_) >> 8;
812     }
813   }
814 }
815 
816 function composeSMaskAlpha(maskData, layerData, transferMap) {
817   const length = maskData.length;
818   const scale = 1 / 255;
819   for (let i = 3; i < length; i += 4) {
820     const alpha = transferMap ? transferMap[maskData[i]] : maskData[i];
821     layerData[i] = (layerData[i] * alpha * scale) | 0;
822   }
823 }
824 
825 function composeSMaskLuminosity(maskData, layerData, transferMap) {
826   const length = maskData.length;
827   for (let i = 3; i < length; i += 4) {
828     const y =
829       maskData[i - 3] * 77 + // * 0.3 / 255 * 0x10000
830       maskData[i - 2] * 152 + // * 0.59 ....
831       maskData[i - 1] * 28; // * 0.11 ....
832     layerData[i] = transferMap
833       ? (layerData[i] * transferMap[y >> 8]) >> 8
834       : (layerData[i] * y) >> 16;
835   }
836 }
837 
838 function genericComposeSMask(
839   maskCtx,
840   layerCtx,
841   width,
842   height,
843   subtype,
844   backdrop,
845   transferMap,
846   layerOffsetX,
847   layerOffsetY,
848   maskOffsetX,
849   maskOffsetY
850 ) {
851   const hasBackdrop = !!backdrop;
852   const r0 = hasBackdrop ? backdrop[0] : 0;
853   const g0 = hasBackdrop ? backdrop[1] : 0;
854   const b0 = hasBackdrop ? backdrop[2] : 0;
855 
856   const composeFn =
857     subtype === "Luminosity" ? composeSMaskLuminosity : composeSMaskAlpha;
858 
859   // processing image in chunks to save memory
860   const PIXELS_TO_PROCESS = 1048576;
861   const chunkSize = Math.min(height, Math.ceil(PIXELS_TO_PROCESS / width));
862   for (let row = 0; row < height; row += chunkSize) {
863     const chunkHeight = Math.min(chunkSize, height - row);
864     const maskData = maskCtx.getImageData(
865       layerOffsetX - maskOffsetX,
866       row + (layerOffsetY - maskOffsetY),
867       width,
868       chunkHeight
869     );
870     const layerData = layerCtx.getImageData(
871       layerOffsetX,
872       row + layerOffsetY,
873       width,
874       chunkHeight
875     );
876 
877     if (hasBackdrop) {
878       composeSMaskBackdrop(maskData.data, r0, g0, b0);
879     }
880     composeFn(maskData.data, layerData.data, transferMap);
881 
882     layerCtx.putImageData(layerData, layerOffsetX, row + layerOffsetY);
883   }
884 }
885 
886 function composeSMask(ctx, smask, layerCtx, layerBox) {
887   const layerOffsetX = layerBox[0];
888   const layerOffsetY = layerBox[1];
889   const layerWidth = layerBox[2] - layerOffsetX;
890   const layerHeight = layerBox[3] - layerOffsetY;
891   if (layerWidth === 0 || layerHeight === 0) {
892     return;
893   }
894   genericComposeSMask(
895     smask.context,
896     layerCtx,
897     layerWidth,
898     layerHeight,
899     smask.subtype,
900     smask.backdrop,
901     smask.transferMap,
902     layerOffsetX,
903     layerOffsetY,
904     smask.offsetX,
905     smask.offsetY
906   );
907   ctx.save();
908   ctx.globalAlpha = 1;
909   ctx.globalCompositeOperation = "source-over";
910   ctx.setTransform(1, 0, 0, 1, 0, 0);
911   ctx.drawImage(layerCtx.canvas, 0, 0);
912   ctx.restore();
913 }
914 
915 function getImageSmoothingEnabled(transform, interpolate) {
916   const scale = Util.singularValueDecompose2dScale(transform);
917   // Round to a 32bit float so that `<=` check below will pass for numbers that
918   // are very close, but not exactly the same 64bit floats.
919   scale[0] = Math.fround(scale[0]);
920   scale[1] = Math.fround(scale[1]);
921   const actualScale = Math.fround(
922     (globalThis.devicePixelRatio || 1) * PixelsPerInch.PDF_TO_CSS_UNITS
923   );
924   if (interpolate !== undefined) {
925     // If the value is explicitly set use it.
926     return interpolate;
927   } else if (scale[0] <= actualScale || scale[1] <= actualScale) {
928     // Smooth when downscaling.
929     return true;
930   }
931   // Don't smooth when upscaling.
932   return false;
933 }
934 
935 const LINE_CAP_STYLES = ["butt", "round", "square"];
936 const LINE_JOIN_STYLES = ["miter", "round", "bevel"];
937 const NORMAL_CLIP = {};
938 const EO_CLIP = {};
939 
940 class CanvasGraphics {
941   constructor(
942     canvasCtx,
943     commonObjs,
944     objs,
945     canvasFactory,
946     filterFactory,
947     { optionalContentConfig, markedContentStack = null },
948     annotationCanvasMap,
949     pageColors
950   ) {
951     this.ctx = canvasCtx;
952     this.current = new CanvasExtraState(
953       this.ctx.canvas.width,
954       this.ctx.canvas.height
955     );
956     this.stateStack = [];
957     this.pendingClip = null;
958     this.pendingEOFill = false;
959     this.res = null;
960     this.xobjs = null;
961     this.commonObjs = commonObjs;
962     this.objs = objs;
963     this.canvasFactory = canvasFactory;
964     this.filterFactory = filterFactory;
965     this.groupStack = [];
966     this.processingType3 = null;
967     // Patterns are painted relative to the initial page/form transform, see
968     // PDF spec 8.7.2 NOTE 1.
969     this.baseTransform = null;
970     this.baseTransformStack = [];
971     this.groupLevel = 0;
972     this.smaskStack = [];
973     this.smaskCounter = 0;
974     this.tempSMask = null;
975     this.suspendedCtx = null;
976     this.contentVisible = true;
977     this.markedContentStack = markedContentStack || [];
978     this.optionalContentConfig = optionalContentConfig;
979     this.cachedCanvases = new CachedCanvases(this.canvasFactory);
980     this.cachedPatterns = new Map();
981     this.annotationCanvasMap = annotationCanvasMap;
982     this.viewportScale = 1;
983     this.outputScaleX = 1;
984     this.outputScaleY = 1;
985     this.pageColors = pageColors;
986 
987     this._cachedScaleForStroking = [-1, 0];
988     this._cachedGetSinglePixelWidth = null;
989     this._cachedBitmapsMap = new Map();
990   }
991 
992   getObject(data, fallback = null) {
993     if (typeof data === "string") {
994       return data.startsWith("g_")
995         ? this.commonObjs.get(data)
996         : this.objs.get(data);
997     }
998     return fallback;
999   }
1000 
1001   beginDrawing({
1002     transform,
1003     viewport,
1004     transparency = false,
1005     background = null,
1006   }) {
1007     // For pdfs that use blend modes we have to clear the canvas else certain
1008     // blend modes can look wrong since we'd be blending with a white
1009     // backdrop. The problem with a transparent backdrop though is we then
1010     // don't get sub pixel anti aliasing on text, creating temporary
1011     // transparent canvas when we have blend modes.
1012     const width = this.ctx.canvas.width;
1013     const height = this.ctx.canvas.height;
1014 
1015     const savedFillStyle = this.ctx.fillStyle;
1016     this.ctx.fillStyle = background || "#ffffff";
1017     this.ctx.fillRect(0, 0, width, height);
1018     this.ctx.fillStyle = savedFillStyle;
1019 
1020     if (transparency) {
1021       const transparentCanvas = this.cachedCanvases.getCanvas(
1022         "transparent",
1023         width,
1024         height
1025       );
1026       this.compositeCtx = this.ctx;
1027       this.transparentCanvas = transparentCanvas.canvas;
1028       this.ctx = transparentCanvas.context;
1029       this.ctx.save();
1030       // The transform can be applied before rendering, transferring it to
1031       // the new canvas.
1032       this.ctx.transform(...getCurrentTransform(this.compositeCtx));
1033     }
1034 
1035     this.ctx.save();
1036     resetCtxToDefault(this.ctx);
1037     if (transform) {
1038       this.ctx.transform(...transform);
1039       this.outputScaleX = transform[0];
1040       this.outputScaleY = transform[0];
1041     }
1042     this.ctx.transform(...viewport.transform);
1043     this.viewportScale = viewport.scale;
1044 
1045     this.baseTransform = getCurrentTransform(this.ctx);
1046   }
1047 
1048   executeOperatorList(
1049     operatorList,
1050     executionStartIdx,
1051     continueCallback,
1052     stepper
1053   ) {
1054     const argsArray = operatorList.argsArray;
1055     const fnArray = operatorList.fnArray;
1056     let i = executionStartIdx || 0;
1057     const argsArrayLen = argsArray.length;
1058 
1059     // Sometimes the OperatorList to execute is empty.
1060     if (argsArrayLen === i) {
1061       return i;
1062     }
1063 
1064     const chunkOperations =
1065       argsArrayLen - i > EXECUTION_STEPS &&
1066       typeof continueCallback === "function";
1067     const endTime = chunkOperations ? Date.now() + EXECUTION_TIME : 0;
1068     let steps = 0;
1069 
1070     const commonObjs = this.commonObjs;
1071     const objs = this.objs;
1072     let fnId;
1073 
1074     while (true) {
1075       if (stepper !== undefined && i === stepper.nextBreakPoint) {
1076         stepper.breakIt(i, continueCallback);
1077         return i;
1078       }
1079 
1080       fnId = fnArray[i];
1081 
1082       if (fnId !== OPS.dependency) {
1083         // eslint-disable-next-line prefer-spread
1084         this[fnId].apply(this, argsArray[i]);
1085       } else {
1086         for (const depObjId of argsArray[i]) {
1087           const objsPool = depObjId.startsWith("g_") ? commonObjs : objs;
1088 
1089           // If the promise isn't resolved yet, add the continueCallback
1090           // to the promise and bail out.
1091           if (!objsPool.has(depObjId)) {
1092             objsPool.get(depObjId, continueCallback);
1093             return i;
1094           }
1095         }
1096       }
1097 
1098       i++;
1099 
1100       // If the entire operatorList was executed, stop as were done.
1101       if (i === argsArrayLen) {
1102         return i;
1103       }
1104 
1105       // If the execution took longer then a certain amount of time and
1106       // `continueCallback` is specified, interrupt the execution.
1107       if (chunkOperations && ++steps > EXECUTION_STEPS) {
1108         if (Date.now() > endTime) {
1109           continueCallback();
1110           return i;
1111         }
1112         steps = 0;
1113       }
1114 
1115       // If the operatorList isn't executed completely yet OR the execution
1116       // time was short enough, do another execution round.
1117     }
1118   }
1119 
1120   #restoreInitialState() {
1121     // Finishing all opened operations such as SMask group painting.
1122     while (this.stateStack.length || this.inSMaskMode) {
1123       this.restore();
1124     }
1125 
1126     this.ctx.restore();
1127 
1128     if (this.transparentCanvas) {
1129       this.ctx = this.compositeCtx;
1130       this.ctx.save();
1131       this.ctx.setTransform(1, 0, 0, 1, 0, 0); // Avoid apply transform twice
1132       this.ctx.drawImage(this.transparentCanvas, 0, 0);
1133       this.ctx.restore();
1134       this.transparentCanvas = null;
1135     }
1136   }
1137 
1138   endDrawing() {
1139     this.#restoreInitialState();
1140 
1141     this.cachedCanvases.clear();
1142     this.cachedPatterns.clear();
1143 
1144     for (const cache of this._cachedBitmapsMap.values()) {
1145       for (const canvas of cache.values()) {
1146         if (
1147           typeof HTMLCanvasElement !== "undefined" &&
1148           canvas instanceof HTMLCanvasElement
1149         ) {
1150           canvas.width = canvas.height = 0;
1151         }
1152       }
1153       cache.clear();
1154     }
1155     this._cachedBitmapsMap.clear();
1156     this.#drawFilter();
1157   }
1158 
1159   #drawFilter() {
1160     if (this.pageColors) {
1161       const hcmFilterId = this.filterFactory.addHCMFilter(
1162         this.pageColors.foreground,
1163         this.pageColors.background
1164       );
1165       if (hcmFilterId !== "none") {
1166         const savedFilter = this.ctx.filter;
1167         this.ctx.filter = hcmFilterId;
1168         this.ctx.drawImage(this.ctx.canvas, 0, 0);
1169         this.ctx.filter = savedFilter;
1170       }
1171     }
1172   }
1173 
1174   _scaleImage(img, inverseTransform) {
1175     // Vertical or horizontal scaling shall not be more than 2 to not lose the
1176     // pixels during drawImage operation, painting on the temporary canvas(es)
1177     // that are twice smaller in size.
1178     const width = img.width;
1179     const height = img.height;
1180     let widthScale = Math.max(
1181       Math.hypot(inverseTransform[0], inverseTransform[1]),
1182       1
1183     );
1184     let heightScale = Math.max(
1185       Math.hypot(inverseTransform[2], inverseTransform[3]),
1186       1
1187     );
1188 
1189     let paintWidth = width,
1190       paintHeight = height;
1191     let tmpCanvasId = "prescale1";
1192     let tmpCanvas, tmpCtx;
1193     while (
1194       (widthScale > 2 && paintWidth > 1) ||
1195       (heightScale > 2 && paintHeight > 1)
1196     ) {
1197       let newWidth = paintWidth,
1198         newHeight = paintHeight;
1199       if (widthScale > 2 && paintWidth > 1) {
1200         // See bug 1820511 (Windows specific bug).
1201         // TODO: once the above bug is fixed we could revert to:
1202         // newWidth = Math.ceil(paintWidth / 2);
1203         newWidth =
1204           paintWidth >= 16384
1205             ? Math.floor(paintWidth / 2) - 1 || 1
1206             : Math.ceil(paintWidth / 2);
1207         widthScale /= paintWidth / newWidth;
1208       }
1209       if (heightScale > 2 && paintHeight > 1) {
1210         // TODO: see the comment above.
1211         newHeight =
1212           paintHeight >= 16384
1213             ? Math.floor(paintHeight / 2) - 1 || 1
1214             : Math.ceil(paintHeight) / 2;
1215         heightScale /= paintHeight / newHeight;
1216       }
1217       tmpCanvas = this.cachedCanvases.getCanvas(
1218         tmpCanvasId,
1219         newWidth,
1220         newHeight
1221       );
1222       tmpCtx = tmpCanvas.context;
1223       tmpCtx.clearRect(0, 0, newWidth, newHeight);
1224       tmpCtx.drawImage(
1225         img,
1226         0,
1227         0,
1228         paintWidth,
1229         paintHeight,
1230         0,
1231         0,
1232         newWidth,
1233         newHeight
1234       );
1235       img = tmpCanvas.canvas;
1236       paintWidth = newWidth;
1237       paintHeight = newHeight;
1238       tmpCanvasId = tmpCanvasId === "prescale1" ? "prescale2" : "prescale1";
1239     }
1240     return {
1241       img,
1242       paintWidth,
1243       paintHeight,
1244     };
1245   }
1246 
1247   _createMaskCanvas(img) {
1248     const ctx = this.ctx;
1249     const { width, height } = img;
1250     const fillColor = this.current.fillColor;
1251     const isPatternFill = this.current.patternFill;
1252     const currentTransform = getCurrentTransform(ctx);
1253 
1254     let cache, cacheKey, scaled, maskCanvas;
1255     if ((img.bitmap || img.data) && img.count > 1) {
1256       const mainKey = img.bitmap || img.data.buffer;
1257       // We're reusing the same image several times, so we can cache it.
1258       // In case we've a pattern fill we just keep the scaled version of
1259       // the image.
1260       // Only the scaling part matters, the translation part is just used
1261       // to compute offsets (but not when filling patterns see #15573).
1262       // TODO: handle the case of a pattern fill if it's possible.
1263       cacheKey = JSON.stringify(
1264         isPatternFill
1265           ? currentTransform
1266           : [currentTransform.slice(0, 4), fillColor]
1267       );
1268 
1269       cache = this._cachedBitmapsMap.get(mainKey);
1270       if (!cache) {
1271         cache = new Map();
1272         this._cachedBitmapsMap.set(mainKey, cache);
1273       }
1274       const cachedImage = cache.get(cacheKey);
1275       if (cachedImage && !isPatternFill) {
1276         const offsetX = Math.round(
1277           Math.min(currentTransform[0], currentTransform[2]) +
1278             currentTransform[4]
1279         );
1280         const offsetY = Math.round(
1281           Math.min(currentTransform[1], currentTransform[3]) +
1282             currentTransform[5]
1283         );
1284         return {
1285           canvas: cachedImage,
1286           offsetX,
1287           offsetY,
1288         };
1289       }
1290       scaled = cachedImage;
1291     }
1292 
1293     if (!scaled) {
1294       maskCanvas = this.cachedCanvases.getCanvas("maskCanvas", width, height);
1295       putBinaryImageMask(maskCanvas.context, img);
1296     }
1297 
1298     // Create the mask canvas at the size it will be drawn at and also set
1299     // its transform to match the current transform so if there are any
1300     // patterns applied they will be applied relative to the correct
1301     // transform.
1302 
1303     let maskToCanvas = Util.transform(currentTransform, [
1304       1 / width,
1305       0,
1306       0,
1307       -1 / height,
1308       0,
1309       0,
1310     ]);
1311     maskToCanvas = Util.transform(maskToCanvas, [1, 0, 0, 1, 0, -height]);
1312     const [minX, minY, maxX, maxY] = Util.getAxialAlignedBoundingBox(
1313       [0, 0, width, height],
1314       maskToCanvas
1315     );
1316     const drawnWidth = Math.round(maxX - minX) || 1;
1317     const drawnHeight = Math.round(maxY - minY) || 1;
1318     const fillCanvas = this.cachedCanvases.getCanvas(
1319       "fillCanvas",
1320       drawnWidth,
1321       drawnHeight
1322     );
1323     const fillCtx = fillCanvas.context;
1324 
1325     // The offset will be the top-left cordinate mask.
1326     // If objToCanvas is [a,b,c,d,e,f] then:
1327     //   - offsetX = min(a, c) + e
1328     //   - offsetY = min(b, d) + f
1329     const offsetX = minX;
1330     const offsetY = minY;
1331     fillCtx.translate(-offsetX, -offsetY);
1332     fillCtx.transform(...maskToCanvas);
1333 
1334     if (!scaled) {
1335       // Pre-scale if needed to improve image smoothing.
1336       scaled = this._scaleImage(
1337         maskCanvas.canvas,
1338         getCurrentTransformInverse(fillCtx)
1339       );
1340       scaled = scaled.img;
1341       if (cache && isPatternFill) {
1342         cache.set(cacheKey, scaled);
1343       }
1344     }
1345 
1346     fillCtx.imageSmoothingEnabled = getImageSmoothingEnabled(
1347       getCurrentTransform(fillCtx),
1348       img.interpolate
1349     );
1350 
1351     drawImageAtIntegerCoords(
1352       fillCtx,
1353       scaled,
1354       0,
1355       0,
1356       scaled.width,
1357       scaled.height,
1358       0,
1359       0,
1360       width,
1361       height
1362     );
1363     fillCtx.globalCompositeOperation = "source-in";
1364 
1365     const inverse = Util.transform(getCurrentTransformInverse(fillCtx), [
1366       1,
1367       0,
1368       0,
1369       1,
1370       -offsetX,
1371       -offsetY,
1372     ]);
1373     fillCtx.fillStyle = isPatternFill
1374       ? fillColor.getPattern(ctx, this, inverse, PathType.FILL)
1375       : fillColor;
1376 
1377     fillCtx.fillRect(0, 0, width, height);
1378 
1379     if (cache && !isPatternFill) {
1380       // The fill canvas is put in the cache associated to the mask image
1381       // so we must remove from the cached canvas: it mustn't be used again.
1382       this.cachedCanvases.delete("fillCanvas");
1383       cache.set(cacheKey, fillCanvas.canvas);
1384     }
1385 
1386     // Round the offsets to avoid drawing fractional pixels.
1387     return {
1388       canvas: fillCanvas.canvas,
1389       offsetX: Math.round(offsetX),
1390       offsetY: Math.round(offsetY),
1391     };
1392   }
1393 
1394   // Graphics state
1395   setLineWidth(width) {
1396     if (width !== this.current.lineWidth) {
1397       this._cachedScaleForStroking[0] = -1;
1398     }
1399     this.current.lineWidth = width;
1400     this.ctx.lineWidth = width;
1401   }
1402 
1403   setLineCap(style) {
1404     this.ctx.lineCap = LINE_CAP_STYLES[style];
1405   }
1406 
1407   setLineJoin(style) {
1408     this.ctx.lineJoin = LINE_JOIN_STYLES[style];
1409   }
1410 
1411   setMiterLimit(limit) {
1412     this.ctx.miterLimit = limit;
1413   }
1414 
1415   setDash(dashArray, dashPhase) {
1416     const ctx = this.ctx;
1417     if (ctx.setLineDash !== undefined) {
1418       ctx.setLineDash(dashArray);
1419       ctx.lineDashOffset = dashPhase;
1420     }
1421   }
1422 
1423   setRenderingIntent(intent) {
1424     // This operation is ignored since we haven't found a use case for it yet.
1425   }
1426 
1427   setFlatness(flatness) {
1428     // This operation is ignored since we haven't found a use case for it yet.
1429   }
1430 
1431   setGState(states) {
1432     for (const [key, value] of states) {
1433       switch (key) {
1434         case "LW":
1435           this.setLineWidth(value);
1436           break;
1437         case "LC":
1438           this.setLineCap(value);
1439           break;
1440         case "LJ":
1441           this.setLineJoin(value);
1442           break;
1443         case "ML":
1444           this.setMiterLimit(value);
1445           break;
1446         case "D":
1447           this.setDash(value[0], value[1]);
1448           break;
1449         case "RI":
1450           this.setRenderingIntent(value);
1451           break;
1452         case "FL":
1453           this.setFlatness(value);
1454           break;
1455         case "Font":
1456           this.setFont(value[0], value[1]);
1457           break;
1458         case "CA":
1459           this.current.strokeAlpha = value;
1460           break;
1461         case "ca":
1462           this.current.fillAlpha = value;
1463           this.ctx.globalAlpha = value;
1464           break;
1465         case "BM":
1466           this.ctx.globalCompositeOperation = value;
1467           break;
1468         case "SMask":
1469           this.current.activeSMask = value ? this.tempSMask : null;
1470           this.tempSMask = null;
1471           this.checkSMaskState();
1472           break;
1473         case "TR":
1474           this.ctx.filter = this.current.transferMaps =
1475             this.filterFactory.addFilter(value);
1476           break;
1477       }
1478     }
1479   }
1480 
1481   get inSMaskMode() {
1482     return !!this.suspendedCtx;
1483   }
1484 
1485   checkSMaskState() {
1486     const inSMaskMode = this.inSMaskMode;
1487     if (this.current.activeSMask && !inSMaskMode) {
1488       this.beginSMaskMode();
1489     } else if (!this.current.activeSMask && inSMaskMode) {
1490       this.endSMaskMode();
1491     }
1492     // Else, the state is okay and nothing needs to be done.
1493   }
1494 
1495   /**
1496    * Soft mask mode takes the current main drawing canvas and replaces it with
1497    * a temporary canvas. Any drawing operations that happen on the temporary
1498    * canvas need to be composed with the main canvas that was suspended (see
1499    * `compose()`). The temporary canvas also duplicates many of its operations
1500    * on the suspended canvas to keep them in sync, so that when the soft mask
1501    * mode ends any clipping paths or transformations will still be active and in
1502    * the right order on the canvas' graphics state stack.
1503    */
1504   beginSMaskMode() {
1505     if (this.inSMaskMode) {
1506       throw new Error("beginSMaskMode called while already in smask mode");
1507     }
1508     const drawnWidth = this.ctx.canvas.width;
1509     const drawnHeight = this.ctx.canvas.height;
1510     const cacheId = "smaskGroupAt" + this.groupLevel;
1511     const scratchCanvas = this.cachedCanvases.getCanvas(
1512       cacheId,
1513       drawnWidth,
1514       drawnHeight
1515     );
1516     this.suspendedCtx = this.ctx;
1517     this.ctx = scratchCanvas.context;
1518     const ctx = this.ctx;
1519     ctx.setTransform(...getCurrentTransform(this.suspendedCtx));
1520     copyCtxState(this.suspendedCtx, ctx);
1521     mirrorContextOperations(ctx, this.suspendedCtx);
1522 
1523     this.setGState([
1524       ["BM", "source-over"],
1525       ["ca", 1],
1526       ["CA", 1],
1527     ]);
1528   }
1529 
1530   endSMaskMode() {
1531     if (!this.inSMaskMode) {
1532       throw new Error("endSMaskMode called while not in smask mode");
1533     }
1534     // The soft mask is done, now restore the suspended canvas as the main
1535     // drawing canvas.
1536     this.ctx._removeMirroring();
1537     copyCtxState(this.ctx, this.suspendedCtx);
1538     this.ctx = this.suspendedCtx;
1539 
1540     this.suspendedCtx = null;
1541   }
1542 
1543   compose(dirtyBox) {
1544     if (!this.current.activeSMask) {
1545       return;
1546     }
1547 
1548     if (!dirtyBox) {
1549       dirtyBox = [0, 0, this.ctx.canvas.width, this.ctx.canvas.height];
1550     } else {
1551       dirtyBox[0] = Math.floor(dirtyBox[0]);
1552       dirtyBox[1] = Math.floor(dirtyBox[1]);
1553       dirtyBox[2] = Math.ceil(dirtyBox[2]);
1554       dirtyBox[3] = Math.ceil(dirtyBox[3]);
1555     }
1556     const smask = this.current.activeSMask;
1557     const suspendedCtx = this.suspendedCtx;
1558 
1559     composeSMask(suspendedCtx, smask, this.ctx, dirtyBox);
1560     // Whatever was drawn has been moved to the suspended canvas, now clear it
1561     // out of the current canvas.
1562     this.ctx.save();
1563     this.ctx.setTransform(1, 0, 0, 1, 0, 0);
1564     this.ctx.clearRect(0, 0, this.ctx.canvas.width, this.ctx.canvas.height);
1565     this.ctx.restore();
1566   }
1567 
1568   save() {
1569     if (this.inSMaskMode) {
1570       // SMask mode may be turned on/off causing us to lose graphics state.
1571       // Copy the temporary canvas state to the main(suspended) canvas to keep
1572       // it in sync.
1573       copyCtxState(this.ctx, this.suspendedCtx);
1574       // Don't bother calling save on the temporary canvas since state is not
1575       // saved there.
1576       this.suspendedCtx.save();
1577     } else {
1578       this.ctx.save();
1579     }
1580     const old = this.current;
1581     this.stateStack.push(old);
1582     this.current = old.clone();
1583   }
1584 
1585   restore() {
1586     if (this.stateStack.length === 0 && this.inSMaskMode) {
1587       this.endSMaskMode();
1588     }
1589     if (this.stateStack.length !== 0) {
1590       this.current = this.stateStack.pop();
1591       if (this.inSMaskMode) {
1592         // Graphics state is stored on the main(suspended) canvas. Restore its
1593         // state then copy it over to the temporary canvas.
1594         this.suspendedCtx.restore();
1595         copyCtxState(this.suspendedCtx, this.ctx);
1596       } else {
1597         this.ctx.restore();
1598       }
1599       this.checkSMaskState();
1600 
1601       // Ensure that the clipping path is reset (fixes issue6413.pdf).
1602       this.pendingClip = null;
1603 
1604       this._cachedScaleForStroking[0] = -1;
1605       this._cachedGetSinglePixelWidth = null;
1606     }
1607   }
1608 
1609   transform(a, b, c, d, e, f) {
1610     this.ctx.transform(a, b, c, d, e, f);
1611 
1612     this._cachedScaleForStroking[0] = -1;
1613     this._cachedGetSinglePixelWidth = null;
1614   }
1615 
1616   // Path
1617   constructPath(ops, args, minMax) {
1618     const ctx = this.ctx;
1619     const current = this.current;
1620     let x = current.x,
1621       y = current.y;
1622     let startX, startY;
1623     const currentTransform = getCurrentTransform(ctx);
1624 
1625     // Most of the time the current transform is a scaling matrix
1626     // so we don't need to transform points before computing min/max:
1627     // we can compute min/max first and then smartly "apply" the
1628     // transform (see Util.scaleMinMax).
1629     // For rectangle, moveTo and lineTo, min/max are computed in the
1630     // worker (see evaluator.js).
1631     const isScalingMatrix =
1632       (currentTransform[0] === 0 && currentTransform[3] === 0) ||
1633       (currentTransform[1] === 0 && currentTransform[2] === 0);
1634     const minMaxForBezier = isScalingMatrix ? minMax.slice(0) : null;
1635 
1636     for (let i = 0, j = 0, ii = ops.length; i < ii; i++) {
1637       switch (ops[i] | 0) {
1638         case OPS.rectangle:
1639           x = args[j++];
1640           y = args[j++];
1641           const width = args[j++];
1642           const height = args[j++];
1643 
1644           const xw = x + width;
1645           const yh = y + height;
1646           ctx.moveTo(x, y);
1647           if (width === 0 || height === 0) {
1648             ctx.lineTo(xw, yh);
1649           } else {
1650             ctx.lineTo(xw, y);
1651             ctx.lineTo(xw, yh);
1652             ctx.lineTo(x, yh);
1653           }
1654           if (!isScalingMatrix) {
1655             current.updateRectMinMax(currentTransform, [x, y, xw, yh]);
1656           }
1657           ctx.closePath();
1658           break;
1659         case OPS.moveTo:
1660           x = args[j++];
1661           y = args[j++];
1662           ctx.moveTo(x, y);
1663           if (!isScalingMatrix) {
1664             current.updatePathMinMax(currentTransform, x, y);
1665           }
1666           break;
1667         case OPS.lineTo:
1668           x = args[j++];
1669           y = args[j++];
1670           ctx.lineTo(x, y);
1671           if (!isScalingMatrix) {
1672             current.updatePathMinMax(currentTransform, x, y);
1673           }
1674           break;
1675         case OPS.curveTo:
1676           startX = x;
1677           startY = y;
1678           x = args[j + 4];
1679           y = args[j + 5];
1680           ctx.bezierCurveTo(
1681             args[j],
1682             args[j + 1],
1683             args[j + 2],
1684             args[j + 3],
1685             x,
1686             y
1687           );
1688           current.updateCurvePathMinMax(
1689             currentTransform,
1690             startX,
1691             startY,
1692             args[j],
1693             args[j + 1],
1694             args[j + 2],
1695             args[j + 3],
1696             x,
1697             y,
1698             minMaxForBezier
1699           );
1700           j += 6;
1701           break;
1702         case OPS.curveTo2:
1703           startX = x;
1704           startY = y;
1705           ctx.bezierCurveTo(
1706             x,
1707             y,
1708             args[j],
1709             args[j + 1],
1710             args[j + 2],
1711             args[j + 3]
1712           );
1713           current.updateCurvePathMinMax(
1714             currentTransform,
1715             startX,
1716             startY,
1717             x,
1718             y,
1719             args[j],
1720             args[j + 1],
1721             args[j + 2],
1722             args[j + 3],
1723             minMaxForBezier
1724           );
1725           x = args[j + 2];
1726           y = args[j + 3];
1727           j += 4;
1728           break;
1729         case OPS.curveTo3:
1730           startX = x;
1731           startY = y;
1732           x = args[j + 2];
1733           y = args[j + 3];
1734           ctx.bezierCurveTo(args[j], args[j + 1], x, y, x, y);
1735           current.updateCurvePathMinMax(
1736             currentTransform,
1737             startX,
1738             startY,
1739             args[j],
1740             args[j + 1],
1741             x,
1742             y,
1743             x,
1744             y,
1745             minMaxForBezier
1746           );
1747           j += 4;
1748           break;
1749         case OPS.closePath:
1750           ctx.closePath();
1751           break;
1752       }
1753     }
1754 
1755     if (isScalingMatrix) {
1756       current.updateScalingPathMinMax(currentTransform, minMaxForBezier);
1757     }
1758 
1759     current.setCurrentPoint(x, y);
1760   }
1761 
1762   closePath() {
1763     this.ctx.closePath();
1764   }
1765 
1766   stroke(consumePath = true) {
1767     const ctx = this.ctx;
1768     const strokeColor = this.current.strokeColor;
1769     // For stroke we want to temporarily change the global alpha to the
1770     // stroking alpha.
1771     ctx.globalAlpha = this.current.strokeAlpha;
1772     if (this.contentVisible) {
1773       if (typeof strokeColor === "object" && strokeColor?.getPattern) {
1774         ctx.save();
1775         ctx.strokeStyle = strokeColor.getPattern(
1776           ctx,
1777           this,
1778           getCurrentTransformInverse(ctx),
1779           PathType.STROKE
1780         );
1781         this.rescaleAndStroke(/* saveRestore */ false);
1782         ctx.restore();
1783       } else {
1784         this.rescaleAndStroke(/* saveRestore */ true);
1785       }
1786     }
1787     if (consumePath) {
1788       this.consumePath(this.current.getClippedPathBoundingBox());
1789     }
1790     // Restore the global alpha to the fill alpha
1791     ctx.globalAlpha = this.current.fillAlpha;
1792   }
1793 
1794   closeStroke() {
1795     this.closePath();
1796     this.stroke();
1797   }
1798 
1799   fill(consumePath = true) {
1800     const ctx = this.ctx;
1801     const fillColor = this.current.fillColor;
1802     const isPatternFill = this.current.patternFill;
1803     let needRestore = false;
1804 
1805     if (isPatternFill) {
1806       ctx.save();
1807       ctx.fillStyle = fillColor.getPattern(
1808         ctx,
1809         this,
1810         getCurrentTransformInverse(ctx),
1811         PathType.FILL
1812       );
1813       needRestore = true;
1814     }
1815 
1816     const intersect = this.current.getClippedPathBoundingBox();
1817     if (this.contentVisible && intersect !== null) {
1818       if (this.pendingEOFill) {
1819         ctx.fill("evenodd");
1820         this.pendingEOFill = false;
1821       } else {
1822         ctx.fill();
1823       }
1824     }
1825 
1826     if (needRestore) {
1827       ctx.restore();
1828     }
1829     if (consumePath) {
1830       this.consumePath(intersect);
1831     }
1832   }
1833 
1834   eoFill() {
1835     this.pendingEOFill = true;
1836     this.fill();
1837   }
1838 
1839   fillStroke() {
1840     this.fill(false);
1841     this.stroke(false);
1842 
1843     this.consumePath();
1844   }
1845 
1846   eoFillStroke() {
1847     this.pendingEOFill = true;
1848     this.fillStroke();
1849   }
1850 
1851   closeFillStroke() {
1852     this.closePath();
1853     this.fillStroke();
1854   }
1855 
1856   closeEOFillStroke() {
1857     this.pendingEOFill = true;
1858     this.closePath();
1859     this.fillStroke();
1860   }
1861 
1862   endPath() {
1863     this.consumePath();
1864   }
1865 
1866   // Clipping
1867   clip() {
1868     this.pendingClip = NORMAL_CLIP;
1869   }
1870 
1871   eoClip() {
1872     this.pendingClip = EO_CLIP;
1873   }
1874 
1875   // Text
1876   beginText() {
1877     this.current.textMatrix = IDENTITY_MATRIX;
1878     this.current.textMatrixScale = 1;
1879     this.current.x = this.current.lineX = 0;
1880     this.current.y = this.current.lineY = 0;
1881   }
1882 
1883   endText() {
1884     const paths = this.pendingTextPaths;
1885     const ctx = this.ctx;
1886     if (paths === undefined) {
1887       ctx.beginPath();
1888       return;
1889     }
1890 
1891     ctx.save();
1892     ctx.beginPath();
1893     for (const path of paths) {
1894       ctx.setTransform(...path.transform);
1895       ctx.translate(path.x, path.y);
1896       path.addToPath(ctx, path.fontSize);
1897     }
1898     ctx.restore();
1899     ctx.clip();
1900     ctx.beginPath();
1901     delete this.pendingTextPaths;
1902   }
1903 
1904   setCharSpacing(spacing) {
1905     this.current.charSpacing = spacing;
1906   }
1907 
1908   setWordSpacing(spacing) {
1909     this.current.wordSpacing = spacing;
1910   }
1911 
1912   setHScale(scale) {
1913     this.current.textHScale = scale / 100;
1914   }
1915 
1916   setLeading(leading) {
1917     this.current.leading = -leading;
1918   }
1919 
1920   setFont(fontRefName, size) {
1921     const fontObj = this.commonObjs.get(fontRefName);
1922     const current = this.current;
1923 
1924     if (!fontObj) {
1925       throw new Error(`Can't find font for ${fontRefName}`);
1926     }
1927     current.fontMatrix = fontObj.fontMatrix || FONT_IDENTITY_MATRIX;
1928 
1929     // A valid matrix needs all main diagonal elements to be non-zero
1930     // This also ensures we bypass FF bugzilla bug #719844.
1931     if (current.fontMatrix[0] === 0 || current.fontMatrix[3] === 0) {
1932       warn("Invalid font matrix for font " + fontRefName);
1933     }
1934 
1935     // The spec for Tf (setFont) says that 'size' specifies the font 'scale',
1936     // and in some docs this can be negative (inverted x-y axes).
1937     if (size < 0) {
1938       size = -size;
1939       current.fontDirection = -1;
1940     } else {
1941       current.fontDirection = 1;
1942     }
1943 
1944     this.current.font = fontObj;
1945     this.current.fontSize = size;
1946 
1947     if (fontObj.isType3Font) {
1948       return; // we don't need ctx.font for Type3 fonts
1949     }
1950 
1951     const name = fontObj.loadedName || "sans-serif";
1952     const typeface =
1953       fontObj.systemFontInfo?.css || `"${name}", ${fontObj.fallbackName}`;
1954 
1955     let bold = "normal";
1956     if (fontObj.black) {
1957       bold = "900";
1958     } else if (fontObj.bold) {
1959       bold = "bold";
1960     }
1961     const italic = fontObj.italic ? "italic" : "normal";
1962 
1963     // Some font backends cannot handle fonts below certain size.
1964     // Keeping the font at minimal size and using the fontSizeScale to change
1965     // the current transformation matrix before the fillText/strokeText.
1966     // See https://bugzilla.mozilla.org/show_bug.cgi?id=726227
1967     let browserFontSize = size;
1968     if (size < MIN_FONT_SIZE) {
1969       browserFontSize = MIN_FONT_SIZE;
1970     } else if (size > MAX_FONT_SIZE) {
1971       browserFontSize = MAX_FONT_SIZE;
1972     }
1973     this.current.fontSizeScale = size / browserFontSize;
1974 
1975     this.ctx.font = `${italic} ${bold} ${browserFontSize}px ${typeface}`;
1976   }
1977 
1978   setTextRenderingMode(mode) {
1979     this.current.textRenderingMode = mode;
1980   }
1981 
1982   setTextRise(rise) {
1983     this.current.textRise = rise;
1984   }
1985 
1986   moveText(x, y) {
1987     this.current.x = this.current.lineX += x;
1988     this.current.y = this.current.lineY += y;
1989   }
1990 
1991   setLeadingMoveText(x, y) {
1992     this.setLeading(-y);
1993     this.moveText(x, y);
1994   }
1995 
1996   setTextMatrix(a, b, c, d, e, f) {
1997     this.current.textMatrix = [a, b, c, d, e, f];
1998     this.current.textMatrixScale = Math.hypot(a, b);
1999 
2000     this.current.x = this.current.lineX = 0;
2001     this.current.y = this.current.lineY = 0;
2002   }
2003 
2004   nextLine() {
2005     this.moveText(0, this.current.leading);
2006   }
2007 
2008   paintChar(character, x, y, patternTransform) {
2009     const ctx = this.ctx;
2010     const current = this.current;
2011     const font = current.font;
2012     const textRenderingMode = current.textRenderingMode;
2013     const fontSize = current.fontSize / current.fontSizeScale;
2014     const fillStrokeMode =
2015       textRenderingMode & TextRenderingMode.FILL_STROKE_MASK;
2016     const isAddToPathSet = !!(
2017       textRenderingMode & TextRenderingMode.ADD_TO_PATH_FLAG
2018     );
2019     const patternFill = current.patternFill && !font.missingFile;
2020 
2021     let addToPath;
2022     if (font.disableFontFace || isAddToPathSet || patternFill) {
2023       addToPath = font.getPathGenerator(this.commonObjs, character);
2024     }
2025 
2026     if (font.disableFontFace || patternFill) {
2027       ctx.save();
2028       ctx.translate(x, y);
2029       ctx.beginPath();
2030       addToPath(ctx, fontSize);
2031       if (patternTransform) {
2032         ctx.setTransform(...patternTransform);
2033       }
2034       if (
2035         fillStrokeMode === TextRenderingMode.FILL ||
2036         fillStrokeMode === TextRenderingMode.FILL_STROKE
2037       ) {
2038         ctx.fill();
2039       }
2040       if (
2041         fillStrokeMode === TextRenderingMode.STROKE ||
2042         fillStrokeMode === TextRenderingMode.FILL_STROKE
2043       ) {
2044         ctx.stroke();
2045       }
2046       ctx.restore();
2047     } else {
2048       if (
2049         fillStrokeMode === TextRenderingMode.FILL ||
2050         fillStrokeMode === TextRenderingMode.FILL_STROKE
2051       ) {
2052         ctx.fillText(character, x, y);
2053       }
2054       if (
2055         fillStrokeMode === TextRenderingMode.STROKE ||
2056         fillStrokeMode === TextRenderingMode.FILL_STROKE
2057       ) {
2058         ctx.strokeText(character, x, y);
2059       }
2060     }
2061 
2062     if (isAddToPathSet) {
2063       const paths = (this.pendingTextPaths ||= []);
2064       paths.push({
2065         transform: getCurrentTransform(ctx),
2066         x,
2067         y,
2068         fontSize,
2069         addToPath,
2070       });
2071     }
2072   }
2073 
2074   get isFontSubpixelAAEnabled() {
2075     // Checks if anti-aliasing is enabled when scaled text is painted.
2076     // On Windows GDI scaled fonts looks bad.
2077     const { context: ctx } = this.cachedCanvases.getCanvas(
2078       "isFontSubpixelAAEnabled",
2079       10,
2080       10
2081     );
2082     ctx.scale(1.5, 1);
2083     ctx.fillText("I", 0, 10);
2084     const data = ctx.getImageData(0, 0, 10, 10).data;
2085     let enabled = false;
2086     for (let i = 3; i < data.length; i += 4) {
2087       if (data[i] > 0 && data[i] < 255) {
2088         enabled = true;
2089         break;
2090       }
2091     }
2092     return shadow(this, "isFontSubpixelAAEnabled", enabled);
2093   }
2094 
2095   showText(glyphs) {
2096     const current = this.current;
2097     const font = current.font;
2098     if (font.isType3Font) {
2099       return this.showType3Text(glyphs);
2100     }
2101 
2102     const fontSize = current.fontSize;
2103     if (fontSize === 0) {
2104       return undefined;
2105     }
2106 
2107     const ctx = this.ctx;
2108     const fontSizeScale = current.fontSizeScale;
2109     const charSpacing = current.charSpacing;
2110     const wordSpacing = current.wordSpacing;
2111     const fontDirection = current.fontDirection;
2112     const textHScale = current.textHScale * fontDirection;
2113     const glyphsLength = glyphs.length;
2114     const vertical = font.vertical;
2115     const spacingDir = vertical ? 1 : -1;
2116     const defaultVMetrics = font.defaultVMetrics;
2117     const widthAdvanceScale = fontSize * current.fontMatrix[0];
2118 
2119     const simpleFillText =
2120       current.textRenderingMode === TextRenderingMode.FILL &&
2121       !font.disableFontFace &&
2122       !current.patternFill;
2123 
2124     ctx.save();
2125     ctx.transform(...current.textMatrix);
2126     ctx.translate(current.x, current.y + current.textRise);
2127 
2128     if (fontDirection > 0) {
2129       ctx.scale(textHScale, -1);
2130     } else {
2131       ctx.scale(textHScale, 1);
2132     }
2133 
2134     let patternTransform;
2135     if (current.patternFill) {
2136       ctx.save();
2137       const pattern = current.fillColor.getPattern(
2138         ctx,
2139         this,
2140         getCurrentTransformInverse(ctx),
2141         PathType.FILL
2142       );
2143       patternTransform = getCurrentTransform(ctx);
2144       ctx.restore();
2145       ctx.fillStyle = pattern;
2146     }
2147 
2148     let lineWidth = current.lineWidth;
2149     const scale = current.textMatrixScale;
2150     if (scale === 0 || lineWidth === 0) {
2151       const fillStrokeMode =
2152         current.textRenderingMode & TextRenderingMode.FILL_STROKE_MASK;
2153       if (
2154         fillStrokeMode === TextRenderingMode.STROKE ||
2155         fillStrokeMode === TextRenderingMode.FILL_STROKE
2156       ) {
2157         lineWidth = this.getSinglePixelWidth();
2158       }
2159     } else {
2160       lineWidth /= scale;
2161     }
2162 
2163     if (fontSizeScale !== 1.0) {
2164       ctx.scale(fontSizeScale, fontSizeScale);
2165       lineWidth /= fontSizeScale;
2166     }
2167 
2168     ctx.lineWidth = lineWidth;
2169 
2170     if (font.isInvalidPDFjsFont) {
2171       const chars = [];
2172       let width = 0;
2173       for (const glyph of glyphs) {
2174         chars.push(glyph.unicode);
2175         width += glyph.width;
2176       }
2177       ctx.fillText(chars.join(""), 0, 0);
2178       current.x += width * widthAdvanceScale * textHScale;
2179       ctx.restore();
2180       this.compose();
2181 
2182       return undefined;
2183     }
2184 
2185     let x = 0,
2186       i;
2187     for (i = 0; i < glyphsLength; ++i) {
2188       const glyph = glyphs[i];
2189       if (typeof glyph === "number") {
2190         x += (spacingDir * glyph * fontSize) / 1000;
2191         continue;
2192       }
2193 
2194       let restoreNeeded = false;
2195       const spacing = (glyph.isSpace ? wordSpacing : 0) + charSpacing;
2196       const character = glyph.fontChar;
2197       const accent = glyph.accent;
2198       let scaledX, scaledY;
2199       let width = glyph.width;
2200       if (vertical) {
2201         const vmetric = glyph.vmetric || defaultVMetrics;
2202         const vx =
2203           -(glyph.vmetric ? vmetric[1] : width * 0.5) * widthAdvanceScale;
2204         const vy = vmetric[2] * widthAdvanceScale;
2205 
2206         width = vmetric ? -vmetric[0] : width;
2207         scaledX = vx / fontSizeScale;
2208         scaledY = (x + vy) / fontSizeScale;
2209       } else {
2210         scaledX = x / fontSizeScale;
2211         scaledY = 0;
2212       }
2213 
2214       if (font.remeasure && width > 0) {
2215         // Some standard fonts may not have the exact width: rescale per
2216         // character if measured width is greater than expected glyph width
2217         // and subpixel-aa is enabled, otherwise just center the glyph.
2218         const measuredWidth =
2219           ((ctx.measureText(character).width * 1000) / fontSize) *
2220           fontSizeScale;
2221         if (width < measuredWidth && this.isFontSubpixelAAEnabled) {
2222           const characterScaleX = width / measuredWidth;
2223           restoreNeeded = true;
2224           ctx.save();
2225           ctx.scale(characterScaleX, 1);
2226           scaledX /= characterScaleX;
2227         } else if (width !== measuredWidth) {
2228           scaledX +=
2229             (((width - measuredWidth) / 2000) * fontSize) / fontSizeScale;
2230         }
2231       }
2232 
2233       // Only attempt to draw the glyph if it is actually in the embedded font
2234       // file or if there isn't a font file so the fallback font is shown.
2235       if (this.contentVisible && (glyph.isInFont || font.missingFile)) {
2236         if (simpleFillText && !accent) {
2237           // common case
2238           ctx.fillText(character, scaledX, scaledY);
2239         } else {
2240           this.paintChar(character, scaledX, scaledY, patternTransform);
2241           if (accent) {
2242             const scaledAccentX =
2243               scaledX + (fontSize * accent.offset.x) / fontSizeScale;
2244             const scaledAccentY =
2245               scaledY - (fontSize * accent.offset.y) / fontSizeScale;
2246             this.paintChar(
2247               accent.fontChar,
2248               scaledAccentX,
2249               scaledAccentY,
2250               patternTransform
2251             );
2252           }
2253         }
2254       }
2255 
2256       const charWidth = vertical
2257         ? width * widthAdvanceScale - spacing * fontDirection
2258         : width * widthAdvanceScale + spacing * fontDirection;
2259       x += charWidth;
2260 
2261       if (restoreNeeded) {
2262         ctx.restore();
2263       }
2264     }
2265     if (vertical) {
2266       current.y -= x;
2267     } else {
2268       current.x += x * textHScale;
2269     }
2270     ctx.restore();
2271     this.compose();
2272 
2273     return undefined;
2274   }
2275 
2276   showType3Text(glyphs) {
2277     // Type3 fonts - each glyph is a "mini-PDF"
2278     const ctx = this.ctx;
2279     const current = this.current;
2280     const font = current.font;
2281     const fontSize = current.fontSize;
2282     const fontDirection = current.fontDirection;
2283     const spacingDir = font.vertical ? 1 : -1;
2284     const charSpacing = current.charSpacing;
2285     const wordSpacing = current.wordSpacing;
2286     const textHScale = current.textHScale * fontDirection;
2287     const fontMatrix = current.fontMatrix || FONT_IDENTITY_MATRIX;
2288     const glyphsLength = glyphs.length;
2289     const isTextInvisible =
2290       current.textRenderingMode === TextRenderingMode.INVISIBLE;
2291     let i, glyph, width, spacingLength;
2292 
2293     if (isTextInvisible || fontSize === 0) {
2294       return;
2295     }
2296     this._cachedScaleForStroking[0] = -1;
2297     this._cachedGetSinglePixelWidth = null;
2298 
2299     ctx.save();
2300     ctx.transform(...current.textMatrix);
2301     ctx.translate(current.x, current.y);
2302 
2303     ctx.scale(textHScale, fontDirection);
2304 
2305     for (i = 0; i < glyphsLength; ++i) {
2306       glyph = glyphs[i];
2307       if (typeof glyph === "number") {
2308         spacingLength = (spacingDir * glyph * fontSize) / 1000;
2309         this.ctx.translate(spacingLength, 0);
2310         current.x += spacingLength * textHScale;
2311         continue;
2312       }
2313 
2314       const spacing = (glyph.isSpace ? wordSpacing : 0) + charSpacing;
2315       const operatorList = font.charProcOperatorList[glyph.operatorListId];
2316       if (!operatorList) {
2317         warn(`Type3 character "${glyph.operatorListId}" is not available.`);
2318         continue;
2319       }
2320       if (this.contentVisible) {
2321         this.processingType3 = glyph;
2322         this.save();
2323         ctx.scale(fontSize, fontSize);
2324         ctx.transform(...fontMatrix);
2325         this.executeOperatorList(operatorList);
2326         this.restore();
2327       }
2328 
2329       const transformed = Util.applyTransform([glyph.width, 0], fontMatrix);
2330       width = transformed[0] * fontSize + spacing;
2331 
2332       ctx.translate(width, 0);
2333       current.x += width * textHScale;
2334     }
2335     ctx.restore();
2336     this.processingType3 = null;
2337   }
2338 
2339   // Type3 fonts
2340   setCharWidth(xWidth, yWidth) {
2341     // We can safely ignore this since the width should be the same
2342     // as the width in the Widths array.
2343   }
2344 
2345   setCharWidthAndBounds(xWidth, yWidth, llx, lly, urx, ury) {
2346     this.ctx.rect(llx, lly, urx - llx, ury - lly);
2347     this.ctx.clip();
2348     this.endPath();
2349   }
2350 
2351   // Color
2352   getColorN_Pattern(IR) {
2353     let pattern;
2354     if (IR[0] === "TilingPattern") {
2355       const color = IR[1];
2356       const baseTransform = this.baseTransform || getCurrentTransform(this.ctx);
2357       const canvasGraphicsFactory = {
2358         createCanvasGraphics: ctx =>
2359           new CanvasGraphics(
2360             ctx,
2361             this.commonObjs,
2362             this.objs,
2363             this.canvasFactory,
2364             this.filterFactory,
2365             {
2366               optionalContentConfig: this.optionalContentConfig,
2367               markedContentStack: this.markedContentStack,
2368             }
2369           ),
2370       };
2371       pattern = new TilingPattern(
2372         IR,
2373         color,
2374         this.ctx,
2375         canvasGraphicsFactory,
2376         baseTransform
2377       );
2378     } else {
2379       pattern = this._getPattern(IR[1], IR[2]);
2380     }
2381     return pattern;
2382   }
2383 
2384   setStrokeColorN() {
2385     this.current.strokeColor = this.getColorN_Pattern(arguments);
2386   }
2387 
2388   setFillColorN() {
2389     this.current.fillColor = this.getColorN_Pattern(arguments);
2390     this.current.patternFill = true;
2391   }
2392 
2393   setStrokeRGBColor(r, g, b) {
2394     const color = Util.makeHexColor(r, g, b);
2395     this.ctx.strokeStyle = color;
2396     this.current.strokeColor = color;
2397   }
2398 
2399   setFillRGBColor(r, g, b) {
2400     const color = Util.makeHexColor(r, g, b);
2401     this.ctx.fillStyle = color;
2402     this.current.fillColor = color;
2403     this.current.patternFill = false;
2404   }
2405 
2406   _getPattern(objId, matrix = null) {
2407     let pattern;
2408     if (this.cachedPatterns.has(objId)) {
2409       pattern = this.cachedPatterns.get(objId);
2410     } else {
2411       pattern = getShadingPattern(this.getObject(objId));
2412       this.cachedPatterns.set(objId, pattern);
2413     }
2414     if (matrix) {
2415       pattern.matrix = matrix;
2416     }
2417     return pattern;
2418   }
2419 
2420   shadingFill(objId) {
2421     if (!this.contentVisible) {
2422       return;
2423     }
2424     const ctx = this.ctx;
2425 
2426     this.save();
2427     const pattern = this._getPattern(objId);
2428     ctx.fillStyle = pattern.getPattern(
2429       ctx,
2430       this,
2431       getCurrentTransformInverse(ctx),
2432       PathType.SHADING
2433     );
2434 
2435     const inv = getCurrentTransformInverse(ctx);
2436     if (inv) {
2437       const { width, height } = ctx.canvas;
2438       const [x0, y0, x1, y1] = Util.getAxialAlignedBoundingBox(
2439         [0, 0, width, height],
2440         inv
2441       );
2442 
2443       this.ctx.fillRect(x0, y0, x1 - x0, y1 - y0);
2444     } else {
2445       // HACK to draw the gradient onto an infinite rectangle.
2446       // PDF gradients are drawn across the entire image while
2447       // Canvas only allows gradients to be drawn in a rectangle
2448       // The following bug should allow us to remove this.
2449       // https://bugzilla.mozilla.org/show_bug.cgi?id=664884
2450 
2451       this.ctx.fillRect(-1e10, -1e10, 2e10, 2e10);
2452     }
2453 
2454     this.compose(this.current.getClippedPathBoundingBox());
2455     this.restore();
2456   }
2457 
2458   // Images
2459   beginInlineImage() {
2460     unreachable("Should not call beginInlineImage");
2461   }
2462 
2463   beginImageData() {
2464     unreachable("Should not call beginImageData");
2465   }
2466 
2467   paintFormXObjectBegin(matrix, bbox) {
2468     if (!this.contentVisible) {
2469       return;
2470     }
2471     this.save();
2472     this.baseTransformStack.push(this.baseTransform);
2473 
2474     if (Array.isArray(matrix) && matrix.length === 6) {
2475       this.transform(...matrix);
2476     }
2477 
2478     this.baseTransform = getCurrentTransform(this.ctx);
2479 
2480     if (bbox) {
2481       const width = bbox[2] - bbox[0];
2482       const height = bbox[3] - bbox[1];
2483       this.ctx.rect(bbox[0], bbox[1], width, height);
2484       this.current.updateRectMinMax(getCurrentTransform(this.ctx), bbox);
2485       this.clip();
2486       this.endPath();
2487     }
2488   }
2489 
2490   paintFormXObjectEnd() {
2491     if (!this.contentVisible) {
2492       return;
2493     }
2494     this.restore();
2495     this.baseTransform = this.baseTransformStack.pop();
2496   }
2497 
2498   beginGroup(group) {
2499     if (!this.contentVisible) {
2500       return;
2501     }
2502 
2503     this.save();
2504     // If there's an active soft mask we don't want it enabled for the group, so
2505     // clear it out. The mask and suspended canvas will be restored in endGroup.
2506     if (this.inSMaskMode) {
2507       this.endSMaskMode();
2508       this.current.activeSMask = null;
2509     }
2510 
2511     const currentCtx = this.ctx;
2512     // TODO non-isolated groups - according to Rik at adobe non-isolated
2513     // group results aren't usually that different and they even have tools
2514     // that ignore this setting. Notes from Rik on implementing:
2515     // - When you encounter an transparency group, create a new canvas with
2516     // the dimensions of the bbox
2517     // - copy the content from the previous canvas to the new canvas
2518     // - draw as usual
2519     // - remove the backdrop alpha:
2520     // alphaNew = 1 - (1 - alpha)/(1 - alphaBackdrop) with 'alpha' the alpha
2521     // value of your transparency group and 'alphaBackdrop' the alpha of the
2522     // backdrop
2523     // - remove background color:
2524     // colorNew = color - alphaNew *colorBackdrop /(1 - alphaNew)
2525     if (!group.isolated) {
2526       info("TODO: Support non-isolated groups.");
2527     }
2528 
2529     // TODO knockout - supposedly possible with the clever use of compositing
2530     // modes.
2531     if (group.knockout) {
2532       warn("Knockout groups not supported.");
2533     }
2534 
2535     const currentTransform = getCurrentTransform(currentCtx);
2536     if (group.matrix) {
2537       currentCtx.transform(...group.matrix);
2538     }
2539     if (!group.bbox) {
2540       throw new Error("Bounding box is required.");
2541     }
2542 
2543     // Based on the current transform figure out how big the bounding box
2544     // will actually be.
2545     let bounds = Util.getAxialAlignedBoundingBox(
2546       group.bbox,
2547       getCurrentTransform(currentCtx)
2548     );
2549     // Clip the bounding box to the current canvas.
2550     const canvasBounds = [
2551       0,
2552       0,
2553       currentCtx.canvas.width,
2554       currentCtx.canvas.height,
2555     ];
2556     bounds = Util.intersect(bounds, canvasBounds) || [0, 0, 0, 0];
2557     // Use ceil in case we're between sizes so we don't create canvas that is
2558     // too small and make the canvas at least 1x1 pixels.
2559     const offsetX = Math.floor(bounds[0]);
2560     const offsetY = Math.floor(bounds[1]);
2561     let drawnWidth = Math.max(Math.ceil(bounds[2]) - offsetX, 1);
2562     let drawnHeight = Math.max(Math.ceil(bounds[3]) - offsetY, 1);
2563     let scaleX = 1,
2564       scaleY = 1;
2565     if (drawnWidth > MAX_GROUP_SIZE) {
2566       scaleX = drawnWidth / MAX_GROUP_SIZE;
2567       drawnWidth = MAX_GROUP_SIZE;
2568     }
2569     if (drawnHeight > MAX_GROUP_SIZE) {
2570       scaleY = drawnHeight / MAX_GROUP_SIZE;
2571       drawnHeight = MAX_GROUP_SIZE;
2572     }
2573 
2574     this.current.startNewPathAndClipBox([0, 0, drawnWidth, drawnHeight]);
2575 
2576     let cacheId = "groupAt" + this.groupLevel;
2577     if (group.smask) {
2578       // Using two cache entries is case if masks are used one after another.
2579       cacheId += "_smask_" + (this.smaskCounter++ % 2);
2580     }
2581     const scratchCanvas = this.cachedCanvases.getCanvas(
2582       cacheId,
2583       drawnWidth,
2584       drawnHeight
2585     );
2586     const groupCtx = scratchCanvas.context;
2587 
2588     // Since we created a new canvas that is just the size of the bounding box
2589     // we have to translate the group ctx.
2590     groupCtx.scale(1 / scaleX, 1 / scaleY);
2591     groupCtx.translate(-offsetX, -offsetY);
2592     groupCtx.transform(...currentTransform);
2593 
2594     if (group.smask) {
2595       // Saving state and cached mask to be used in setGState.
2596       this.smaskStack.push({
2597         canvas: scratchCanvas.canvas,
2598         context: groupCtx,
2599         offsetX,
2600         offsetY,
2601         scaleX,
2602         scaleY,
2603         subtype: group.smask.subtype,
2604         backdrop: group.smask.backdrop,
2605         transferMap: group.smask.transferMap || null,
2606         startTransformInverse: null, // used during suspend operation
2607       });
2608     } else {
2609       // Setup the current ctx so when the group is popped we draw it at the
2610       // right location.
2611       currentCtx.setTransform(1, 0, 0, 1, 0, 0);
2612       currentCtx.translate(offsetX, offsetY);
2613       currentCtx.scale(scaleX, scaleY);
2614       currentCtx.save();
2615     }
2616     // The transparency group inherits all off the current graphics state
2617     // except the blend mode, soft mask, and alpha constants.
2618     copyCtxState(currentCtx, groupCtx);
2619     this.ctx = groupCtx;
2620     this.setGState([
2621       ["BM", "source-over"],
2622       ["ca", 1],
2623       ["CA", 1],
2624     ]);
2625     this.groupStack.push(currentCtx);
2626     this.groupLevel++;
2627   }
2628 
2629   endGroup(group) {
2630     if (!this.contentVisible) {
2631       return;
2632     }
2633     this.groupLevel--;
2634     const groupCtx = this.ctx;
2635     const ctx = this.groupStack.pop();
2636     this.ctx = ctx;
2637     // Turn off image smoothing to avoid sub pixel interpolation which can
2638     // look kind of blurry for some pdfs.
2639     this.ctx.imageSmoothingEnabled = false;
2640 
2641     if (group.smask) {
2642       this.tempSMask = this.smaskStack.pop();
2643       this.restore();
2644     } else {
2645       this.ctx.restore();
2646       const currentMtx = getCurrentTransform(this.ctx);
2647       this.restore();
2648       this.ctx.save();
2649       this.ctx.setTransform(...currentMtx);
2650       const dirtyBox = Util.getAxialAlignedBoundingBox(
2651         [0, 0, groupCtx.canvas.width, groupCtx.canvas.height],
2652         currentMtx
2653       );
2654       this.ctx.drawImage(groupCtx.canvas, 0, 0);
2655       this.ctx.restore();
2656       this.compose(dirtyBox);
2657     }
2658   }
2659 
2660   beginAnnotation(id, rect, transform, matrix, hasOwnCanvas) {
2661     // The annotations are drawn just after the page content.
2662     // The page content drawing can potentially have set a transform,
2663     // a clipping path, whatever...
2664     // So in order to have something clean, we restore the initial state.
2665     this.#restoreInitialState();
2666     resetCtxToDefault(this.ctx);
2667 
2668     this.ctx.save();
2669     this.save();
2670 
2671     if (this.baseTransform) {
2672       this.ctx.setTransform(...this.baseTransform);
2673     }
2674 
2675     if (Array.isArray(rect) && rect.length === 4) {
2676       const width = rect[2] - rect[0];
2677       const height = rect[3] - rect[1];
2678 
2679       if (hasOwnCanvas && this.annotationCanvasMap) {
2680         transform = transform.slice();
2681         transform[4] -= rect[0];
2682         transform[5] -= rect[1];
2683 
2684         rect = rect.slice();
2685         rect[0] = rect[1] = 0;
2686         rect[2] = width;
2687         rect[3] = height;
2688 
2689         const [scaleX, scaleY] = Util.singularValueDecompose2dScale(
2690           getCurrentTransform(this.ctx)
2691         );
2692         const { viewportScale } = this;
2693         const canvasWidth = Math.ceil(
2694           width * this.outputScaleX * viewportScale
2695         );
2696         const canvasHeight = Math.ceil(
2697           height * this.outputScaleY * viewportScale
2698         );
2699 
2700         this.annotationCanvas = this.canvasFactory.create(
2701           canvasWidth,
2702           canvasHeight
2703         );
2704         const { canvas, context } = this.annotationCanvas;
2705         this.annotationCanvasMap.set(id, canvas);
2706         this.annotationCanvas.savedCtx = this.ctx;
2707         this.ctx = context;
2708         this.ctx.save();
2709         this.ctx.setTransform(scaleX, 0, 0, -scaleY, 0, height * scaleY);
2710 
2711         resetCtxToDefault(this.ctx);
2712       } else {
2713         resetCtxToDefault(this.ctx);
2714 
2715         this.ctx.rect(rect[0], rect[1], width, height);
2716         this.ctx.clip();
2717         this.endPath();
2718       }
2719     }
2720 
2721     this.current = new CanvasExtraState(
2722       this.ctx.canvas.width,
2723       this.ctx.canvas.height
2724     );
2725 
2726     this.transform(...transform);
2727     this.transform(...matrix);
2728   }
2729 
2730   endAnnotation() {
2731     if (this.annotationCanvas) {
2732       this.ctx.restore();
2733       this.#drawFilter();
2734 
2735       this.ctx = this.annotationCanvas.savedCtx;
2736       delete this.annotationCanvas.savedCtx;
2737       delete this.annotationCanvas;
2738     }
2739   }
2740 
2741   paintImageMaskXObject(img) {
2742     if (!this.contentVisible) {
2743       return;
2744     }
2745     const count = img.count;
2746     img = this.getObject(img.data, img);
2747     img.count = count;
2748 
2749     const ctx = this.ctx;
2750     const glyph = this.processingType3;
2751 
2752     if (glyph) {
2753       if (glyph.compiled === undefined) {
2754         glyph.compiled = compileType3Glyph(img);
2755       }
2756 
2757       if (glyph.compiled) {
2758         glyph.compiled(ctx);
2759         return;
2760       }
2761     }
2762     const mask = this._createMaskCanvas(img);
2763     const maskCanvas = mask.canvas;
2764 
2765     ctx.save();
2766     // The mask is drawn with the transform applied. Reset the current
2767     // transform to draw to the identity.
2768     ctx.setTransform(1, 0, 0, 1, 0, 0);
2769     ctx.drawImage(maskCanvas, mask.offsetX, mask.offsetY);
2770     ctx.restore();
2771     this.compose();
2772   }
2773 
2774   paintImageMaskXObjectRepeat(
2775     img,
2776     scaleX,
2777     skewX = 0,
2778     skewY = 0,
2779     scaleY,
2780     positions
2781   ) {
2782     if (!this.contentVisible) {
2783       return;
2784     }
2785 
2786     img = this.getObject(img.data, img);
2787 
2788     const ctx = this.ctx;
2789     ctx.save();
2790     const currentTransform = getCurrentTransform(ctx);
2791     ctx.transform(scaleX, skewX, skewY, scaleY, 0, 0);
2792     const mask = this._createMaskCanvas(img);
2793 
2794     ctx.setTransform(
2795       1,
2796       0,
2797       0,
2798       1,
2799       mask.offsetX - currentTransform[4],
2800       mask.offsetY - currentTransform[5]
2801     );
2802     for (let i = 0, ii = positions.length; i < ii; i += 2) {
2803       const trans = Util.transform(currentTransform, [
2804         scaleX,
2805         skewX,
2806         skewY,
2807         scaleY,
2808         positions[i],
2809         positions[i + 1],
2810       ]);
2811 
2812       const [x, y] = Util.applyTransform([0, 0], trans);
2813       ctx.drawImage(mask.canvas, x, y);
2814     }
2815     ctx.restore();
2816     this.compose();
2817   }
2818 
2819   paintImageMaskXObjectGroup(images) {
2820     if (!this.contentVisible) {
2821       return;
2822     }
2823     const ctx = this.ctx;
2824 
2825     const fillColor = this.current.fillColor;
2826     const isPatternFill = this.current.patternFill;
2827 
2828     for (const image of images) {
2829       const { data, width, height, transform } = image;
2830 
2831       const maskCanvas = this.cachedCanvases.getCanvas(
2832         "maskCanvas",
2833         width,
2834         height
2835       );
2836       const maskCtx = maskCanvas.context;
2837       maskCtx.save();
2838 
2839       const img = this.getObject(data, image);
2840       putBinaryImageMask(maskCtx, img);
2841 
2842       maskCtx.globalCompositeOperation = "source-in";
2843 
2844       maskCtx.fillStyle = isPatternFill
2845         ? fillColor.getPattern(
2846             maskCtx,
2847             this,
2848             getCurrentTransformInverse(ctx),
2849             PathType.FILL
2850           )
2851         : fillColor;
2852       maskCtx.fillRect(0, 0, width, height);
2853 
2854       maskCtx.restore();
2855 
2856       ctx.save();
2857       ctx.transform(...transform);
2858       ctx.scale(1, -1);
2859       drawImageAtIntegerCoords(
2860         ctx,
2861         maskCanvas.canvas,
2862         0,
2863         0,
2864         width,
2865         height,
2866         0,
2867         -1,
2868         1,
2869         1
2870       );
2871       ctx.restore();
2872     }
2873     this.compose();
2874   }
2875 
2876   paintImageXObject(objId) {
2877     if (!this.contentVisible) {
2878       return;
2879     }
2880     const imgData = this.getObject(objId);
2881     if (!imgData) {
2882       warn("Dependent image isn't ready yet");
2883       return;
2884     }
2885 
2886     this.paintInlineImageXObject(imgData);
2887   }
2888 
2889   paintImageXObjectRepeat(objId, scaleX, scaleY, positions) {
2890     if (!this.contentVisible) {
2891       return;
2892     }
2893     const imgData = this.getObject(objId);
2894     if (!imgData) {
2895       warn("Dependent image isn't ready yet");
2896       return;
2897     }
2898 
2899     const width = imgData.width;
2900     const height = imgData.height;
2901     const map = [];
2902     for (let i = 0, ii = positions.length; i < ii; i += 2) {
2903       map.push({
2904         transform: [scaleX, 0, 0, scaleY, positions[i], positions[i + 1]],
2905         x: 0,
2906         y: 0,
2907         w: width,
2908         h: height,
2909       });
2910     }
2911     this.paintInlineImageXObjectGroup(imgData, map);
2912   }
2913 
2914   applyTransferMapsToCanvas(ctx) {
2915     if (this.current.transferMaps !== "none") {
2916       ctx.filter = this.current.transferMaps;
2917       ctx.drawImage(ctx.canvas, 0, 0);
2918       ctx.filter = "none";
2919     }
2920     return ctx.canvas;
2921   }
2922 
2923   applyTransferMapsToBitmap(imgData) {
2924     if (this.current.transferMaps === "none") {
2925       return imgData.bitmap;
2926     }
2927     const { bitmap, width, height } = imgData;
2928     const tmpCanvas = this.cachedCanvases.getCanvas(
2929       "inlineImage",
2930       width,
2931       height
2932     );
2933     const tmpCtx = tmpCanvas.context;
2934     tmpCtx.filter = this.current.transferMaps;
2935     tmpCtx.drawImage(bitmap, 0, 0);
2936     tmpCtx.filter = "none";
2937 
2938     return tmpCanvas.canvas;
2939   }
2940 
2941   paintInlineImageXObject(imgData) {
2942     if (!this.contentVisible) {
2943       return;
2944     }
2945     const width = imgData.width;
2946     const height = imgData.height;
2947     const ctx = this.ctx;
2948 
2949     this.save();
2950 
2951     if (
2952       (typeof PDFJSDev !== "undefined" && PDFJSDev.test("MOZCENTRAL")) ||
2953       !isNodeJS
2954     ) {
2955       // The filter, if any, will be applied in applyTransferMapsToBitmap.
2956       // It must be applied to the image before rescaling else some artifacts
2957       // could appear.
2958       // The final restore will reset it to its value.
2959       const { filter } = ctx;
2960       if (filter !== "none" && filter !== "") {
2961         ctx.filter = "none";
2962       }
2963     }
2964 
2965     // scale the image to the unit square
2966     ctx.scale(1 / width, -1 / height);
2967 
2968     let imgToPaint;
2969     if (imgData.bitmap) {
2970       imgToPaint = this.applyTransferMapsToBitmap(imgData);
2971     } else if (
2972       (typeof HTMLElement === "function" && imgData instanceof HTMLElement) ||
2973       !imgData.data
2974     ) {
2975       // typeof check is needed due to node.js support, see issue #8489
2976       imgToPaint = imgData;
2977     } else {
2978       const tmpCanvas = this.cachedCanvases.getCanvas(
2979         "inlineImage",
2980         width,
2981         height
2982       );
2983       const tmpCtx = tmpCanvas.context;
2984       putBinaryImageData(tmpCtx, imgData);
2985       imgToPaint = this.applyTransferMapsToCanvas(tmpCtx);
2986     }
2987 
2988     const scaled = this._scaleImage(
2989       imgToPaint,
2990       getCurrentTransformInverse(ctx)
2991     );
2992     ctx.imageSmoothingEnabled = getImageSmoothingEnabled(
2993       getCurrentTransform(ctx),
2994       imgData.interpolate
2995     );
2996 
2997     drawImageAtIntegerCoords(
2998       ctx,
2999       scaled.img,
3000       0,
3001       0,
3002       scaled.paintWidth,
3003       scaled.paintHeight,
3004       0,
3005       -height,
3006       width,
3007       height
3008     );
3009     this.compose();
3010     this.restore();
3011   }
3012 
3013   paintInlineImageXObjectGroup(imgData, map) {
3014     if (!this.contentVisible) {
3015       return;
3016     }
3017     const ctx = this.ctx;
3018     let imgToPaint;
3019     if (imgData.bitmap) {
3020       imgToPaint = imgData.bitmap;
3021     } else {
3022       const w = imgData.width;
3023       const h = imgData.height;
3024 
3025       const tmpCanvas = this.cachedCanvases.getCanvas("inlineImage", w, h);
3026       const tmpCtx = tmpCanvas.context;
3027       putBinaryImageData(tmpCtx, imgData);
3028       imgToPaint = this.applyTransferMapsToCanvas(tmpCtx);
3029     }
3030 
3031     for (const entry of map) {
3032       ctx.save();
3033       ctx.transform(...entry.transform);
3034       ctx.scale(1, -1);
3035       drawImageAtIntegerCoords(
3036         ctx,
3037         imgToPaint,
3038         entry.x,
3039         entry.y,
3040         entry.w,
3041         entry.h,
3042         0,
3043         -1,
3044         1,
3045         1
3046       );
3047       ctx.restore();
3048     }
3049     this.compose();
3050   }
3051 
3052   paintSolidColorImageMask() {
3053     if (!this.contentVisible) {
3054       return;
3055     }
3056     this.ctx.fillRect(0, 0, 1, 1);
3057     this.compose();
3058   }
3059 
3060   // Marked content
3061 
3062   markPoint(tag) {
3063     // TODO Marked content.
3064   }
3065 
3066   markPointProps(tag, properties) {
3067     // TODO Marked content.
3068   }
3069 
3070   beginMarkedContent(tag) {
3071     this.markedContentStack.push({
3072       visible: true,
3073     });
3074   }
3075 
3076   beginMarkedContentProps(tag, properties) {
3077     if (tag === "OC") {
3078       this.markedContentStack.push({
3079         visible: this.optionalContentConfig.isVisible(properties),
3080       });
3081     } else {
3082       this.markedContentStack.push({
3083         visible: true,
3084       });
3085     }
3086     this.contentVisible = this.isContentVisible();
3087   }
3088 
3089   endMarkedContent() {
3090     this.markedContentStack.pop();
3091     this.contentVisible = this.isContentVisible();
3092   }
3093 
3094   // Compatibility
3095 
3096   beginCompat() {
3097     // TODO ignore undefined operators (should we do that anyway?)
3098   }
3099 
3100   endCompat() {
3101     // TODO stop ignoring undefined operators
3102   }
3103 
3104   // Helper functions
3105 
3106   consumePath(clipBox) {
3107     const isEmpty = this.current.isEmptyClip();
3108     if (this.pendingClip) {
3109       this.current.updateClipFromPath();
3110     }
3111     if (!this.pendingClip) {
3112       this.compose(clipBox);
3113     }
3114     const ctx = this.ctx;
3115     if (this.pendingClip) {
3116       if (!isEmpty) {
3117         if (this.pendingClip === EO_CLIP) {
3118           ctx.clip("evenodd");
3119         } else {
3120           ctx.clip();
3121         }
3122       }
3123       this.pendingClip = null;
3124     }
3125     this.current.startNewPathAndClipBox(this.current.clipBox);
3126     ctx.beginPath();
3127   }
3128 
3129   getSinglePixelWidth() {
3130     if (!this._cachedGetSinglePixelWidth) {
3131       const m = getCurrentTransform(this.ctx);
3132       if (m[1] === 0 && m[2] === 0) {
3133         // Fast path
3134         this._cachedGetSinglePixelWidth =
3135           1 / Math.min(Math.abs(m[0]), Math.abs(m[3]));
3136       } else {
3137         const absDet = Math.abs(m[0] * m[3] - m[2] * m[1]);
3138         const normX = Math.hypot(m[0], m[2]);
3139         const normY = Math.hypot(m[1], m[3]);
3140         this._cachedGetSinglePixelWidth = Math.max(normX, normY) / absDet;
3141       }
3142     }
3143     return this._cachedGetSinglePixelWidth;
3144   }
3145 
3146   getScaleForStroking() {
3147     // A pixel has thicknessX = thicknessY = 1;
3148     // A transformed pixel is a parallelogram and the thicknesses
3149     // corresponds to the heights.
3150     // The goal of this function is to rescale before setting the
3151     // lineWidth in order to have both thicknesses greater or equal
3152     // to 1 after transform.
3153     if (this._cachedScaleForStroking[0] === -1) {
3154       const { lineWidth } = this.current;
3155       const { a, b, c, d } = this.ctx.getTransform();
3156       let scaleX, scaleY;
3157 
3158       if (b === 0 && c === 0) {
3159         // Fast path
3160         const normX = Math.abs(a);
3161         const normY = Math.abs(d);
3162         if (normX === normY) {
3163           if (lineWidth === 0) {
3164             scaleX = scaleY = 1 / normX;
3165           } else {
3166             const scaledLineWidth = normX * lineWidth;
3167             scaleX = scaleY = scaledLineWidth < 1 ? 1 / scaledLineWidth : 1;
3168           }
3169         } else if (lineWidth === 0) {
3170           scaleX = 1 / normX;
3171           scaleY = 1 / normY;
3172         } else {
3173           const scaledXLineWidth = normX * lineWidth;
3174           const scaledYLineWidth = normY * lineWidth;
3175           scaleX = scaledXLineWidth < 1 ? 1 / scaledXLineWidth : 1;
3176           scaleY = scaledYLineWidth < 1 ? 1 / scaledYLineWidth : 1;
3177         }
3178       } else {
3179         // A pixel (base (x, y)) is transformed by M into a parallelogram:
3180         //  - its area is |det(M)|;
3181         //  - heightY (orthogonal to Mx) has a length: |det(M)| / norm(Mx);
3182         //  - heightX (orthogonal to My) has a length: |det(M)| / norm(My).
3183         // heightX and heightY are the thicknesses of the transformed pixel
3184         // and they must be both greater or equal to 1.
3185         const absDet = Math.abs(a * d - b * c);
3186         const normX = Math.hypot(a, b);
3187         const normY = Math.hypot(c, d);
3188         if (lineWidth === 0) {
3189           scaleX = normY / absDet;
3190           scaleY = normX / absDet;
3191         } else {
3192           const baseArea = lineWidth * absDet;
3193           scaleX = normY > baseArea ? normY / baseArea : 1;
3194           scaleY = normX > baseArea ? normX / baseArea : 1;
3195         }
3196       }
3197       this._cachedScaleForStroking[0] = scaleX;
3198       this._cachedScaleForStroking[1] = scaleY;
3199     }
3200     return this._cachedScaleForStroking;
3201   }
3202 
3203   // Rescale before stroking in order to have a final lineWidth
3204   // with both thicknesses greater or equal to 1.
3205   rescaleAndStroke(saveRestore) {
3206     const { ctx } = this;
3207     const { lineWidth } = this.current;
3208     const [scaleX, scaleY] = this.getScaleForStroking();
3209 
3210     ctx.lineWidth = lineWidth || 1;
3211 
3212     if (scaleX === 1 && scaleY === 1) {
3213       ctx.stroke();
3214       return;
3215     }
3216 
3217     const dashes = ctx.getLineDash();
3218     if (saveRestore) {
3219       ctx.save();
3220     }
3221 
3222     ctx.scale(scaleX, scaleY);
3223 
3224     // How the dashed line is rendered depends on the current transform...
3225     // so we added a rescale to handle too thin lines and consequently
3226     // the way the line is dashed will be modified.
3227     // If scaleX === scaleY, the dashed lines will be rendered correctly
3228     // else we'll have some bugs (but only with too thin lines).
3229     // Here we take the max... why not taking the min... or something else.
3230     // Anyway, as said it's buggy when scaleX !== scaleY.
3231     if (dashes.length > 0) {
3232       const scale = Math.max(scaleX, scaleY);
3233       ctx.setLineDash(dashes.map(x => x / scale));
3234       ctx.lineDashOffset /= scale;
3235     }
3236 
3237     ctx.stroke();
3238 
3239     if (saveRestore) {
3240       ctx.restore();
3241     }
3242   }
3243 
3244   isContentVisible() {
3245     for (let i = this.markedContentStack.length - 1; i >= 0; i--) {
3246       if (!this.markedContentStack[i].visible) {
3247         return false;
3248       }
3249     }
3250     return true;
3251   }
3252 }
3253 
3254 for (const op in OPS) {
3255   if (CanvasGraphics.prototype[op] !== undefined) {
3256     CanvasGraphics.prototype[OPS[op]] = CanvasGraphics.prototype[op];
3257   }
3258 }
3259 
3260 export { CanvasGraphics };
</code>

Your task:
You are a software tester at pdf.js.
1. Write exactly one javascript test `it("...", async () => {...})` block.
2. Your test must fail on the code before the patch, and pass after, hence the test will verify that the patch resolves the issue.
3. The test must be self-contained and to-the-point.
4. Use only the provided imports (respect the paths exactly how they are given) by importing dynamically for compatibility with Node.js — no new dependencies. 
5. Return only the javascript code (no comments or explanations).

Example structure:
it("should <describe behavior>", async () => {
  const { example } = await import("../../src/core/example.js");
  <initialize required variables>;
  <define expected variable>;
  <generate actual variables>;
  <compare expected with actual>;
});

