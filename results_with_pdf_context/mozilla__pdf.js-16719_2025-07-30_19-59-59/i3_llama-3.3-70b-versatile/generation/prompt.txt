Before you begin:
- Keep going until the job is completely solved — don’t stop halfway.
- If you’re unsure about the behavior, reread the provided patch carefully; do not hallucinate.
- Plan your approach before writing code by reflecting on whether the test truly fails before and passes after.

Issue:
<issue>
Pressing the Delete key should delete the selected element when editing a PDF
</issue>

Patch:
<patch>
diff --git a/src/display/editor/tools.js b/src/display/editor/tools.js
--- a/src/display/editor/tools.js
+++ b/src/display/editor/tools.js
@@ -578,6 +578,7 @@ class AnnotationEditorUIManager {
             "Delete",
             "ctrl+Delete",
             "shift+Delete",
+            "mac+Delete",
           ],
           AnnotationEditorUIManager.prototype.delete,
         ],


</patch>

Imports:
<imports>
Available Packages
Dev Dependencies:
- @babel/core: ^7.22.9
- @babel/plugin-transform-modules-commonjs: ^7.22.5
- @babel/preset-env: ^7.22.9
- @babel/runtime: ^7.22.6
- @javascript-obfuscator/escodegen: 2.3.0
- acorn: ^8.10.0
- autoprefixer: ^10.4.14
- babel-loader: ^9.1.3
- caniuse-lite: ^1.0.30001516
- canvas: ^2.11.2
- core-js: ^3.31.1
- cross-env: ^7.0.3
- es-module-shims: 1.4.7
- eslint: ^8.45.0
- eslint-config-prettier: ^8.8.0
- eslint-plugin-fetch-options: ^0.0.5
- eslint-plugin-html: ^7.1.0
- eslint-plugin-import: ^2.27.5
- eslint-plugin-json: ^3.1.0
- eslint-plugin-mozilla: ^3.1.0
- eslint-plugin-no-unsanitized: ^4.0.2
- eslint-plugin-prettier: ^5.0.0
- eslint-plugin-sort-exports: ^0.8.0
- eslint-plugin-unicorn: ^48.0.0
- globals: ^13.20.0
- gulp: ^4.0.2
- gulp-postcss: ^9.0.1
- gulp-rename: ^2.0.0
- gulp-replace: ^1.1.4
- gulp-zip: ^5.1.0
- jasmine: ^5.0.2
- jsdoc: ^4.0.2
- jstransformer-markdown-it: ^3.0.0
- merge-stream: ^2.0.0
- mkdirp: ^3.0.1
- needle: ^3.2.0
- path2d-polyfill: ^2.0.1
- pngjs: ^7.0.0
- postcss: ^8.4.26
- postcss-dir-pseudo-class: ^8.0.0
- prettier: ^3.0.0
- puppeteer: ^20.8.2
- rimraf: ^3.0.2
- streamqueue: ^1.1.2
- stylelint: 15.10.0
- stylelint-prettier: ^4.0.0
- terser: ^5.19.0
- through2: ^4.0.2
- ttest: ^4.0.0
- typescript: ^5.1.6
- typogr: ^0.6.8
- vinyl: ^3.0.0
- vinyl-fs: ^3.0.3
- webpack: ^5.88.1
- webpack-stream: ^7.0.0
- wintersmith: ^2.5.0
- yargs: ^17.7.2

Engines:
- node: >=18

Available Relative Imports:
- `../../src/core/annotation.js`: Annotation, AnnotationBorderStyle, AnnotationFactory, MarkupAnnotation, getQuadPoints
- `../../src/core/bidi.js`: bidi
- `../../src/core/cff_parser.js`: CFFCharset, CFFCompiler, CFFFDSelect, CFFParser, CFFStrings
- `../../src/core/cmap.js`: CMap, CMapFactory, IdentityCMap
- `../../src/core/colorspace.js`: ColorSpace
- `../../src/core/core_utils.js`: arrayBuffersToBytes, encodeToXmlString, escapePDFName, escapeString, getInheritableProperty, isAscii, isWhiteSpace, log2, numberToString, parseXFAPath, recoverJsURL, stringToUTF16HexString, stringToUTF16String, toRomanNumerals, validateCSSFont
- `../../src/core/crypto.js`: AES128Cipher, AES256Cipher, ARCFourCipher, CipherTransformFactory, PDF17, PDF20, calculateMD5, calculateSHA256, calculateSHA384, calculateSHA512
- `../../src/core/default_appearance.js`: createDefaultAppearance, parseAppearanceStream, parseDefaultAppearance
- `../../src/core/document.js`: PDFDocument, Page
- `../../src/core/encodings.js`: getEncoding
- `../../src/core/evaluator.js`: PartialEvaluator
- `../../src/core/font_substitutions.js`: getFontSubstitution
- `../../src/core/fonts_utils.js`: SEAC_ANALYSIS_ENABLED
- `../../src/core/function.js`: PDFFunctionFactory, PostScriptCompiler, PostScriptEvaluator
- `../../src/core/glyphlist.js`: getDingbatsGlyphsUnicode, getGlyphsUnicode
- `../../src/core/image_utils.js`: GlobalImageCache, LocalColorSpaceCache
- `../../src/core/jbig2.js`: Jbig2Image
- `../../src/core/jpg.js`: JpegImage
- `../../src/core/jpx.js`: JpxImage
- `../../src/core/metadata_parser.js`: MetadataParser
- `../../src/core/operator_list.js`: OperatorList
- `../../src/core/parser.js`: Lexer, Linearization, Parser
- `../../src/core/predictor_stream.js`: PredictorStream
- `../../src/core/primitives.js`: Cmd, Dict, EOF, Name, Ref, RefSet, RefSetCache, isCmd, isDict, isName, isRefsEqual
- `../../src/core/ps_parser.js`: PostScriptLexer, PostScriptParser
- `../../src/core/stream.js`: NullStream, Stream, StringStream
- `../../src/core/type1_parser.js`: Type1Parser
- `../../src/core/unicode.js`: getCharUnicodeCategory, getUnicodeForGlyph, getUnicodeRangeFor, mapSpecialUnicodeValues
- `../../src/core/worker.js`: WorkerMessageHandler, WorkerTask
- `../../src/core/writer.js`: incrementalUpdate, writeDict
- `../../src/core/xfa/bind.js`: Binder
- `../../src/core/xfa/data.js`: DataHandler
- `../../src/core/xfa/factory.js`: XFAFactory
- `../../src/core/xfa/formcalc_lexer.js`: Lexer, TOKEN, Token
- `../../src/core/xfa/formcalc_parser.js`: Errors, Parser
- `../../src/core/xfa/parser.js`: XFAParser
- `../../src/core/xfa/som.js`: searchNode
- `../../src/core/xfa/symbol_utils.js`: $dump, $getChildren, $getChildrenByClass, $getChildrenByName, $text, $uid
- `../../src/core/xml_parser.js`: SimpleXMLParser, XMLParserBase
- `../../src/display/annotation_layer.js`: AnnotationLayer
- `../../src/display/annotation_storage.js`: AnnotationStorage
- `../../src/display/api.js`: DefaultCMapReaderFactory, DefaultCanvasFactory, DefaultStandardFontDataFactory, LoopbackPort, PDFDataRangeTransport, PDFDocumentLoadingTask, PDFDocumentProxy, PDFPageProxy, PDFWorker, PDFWorkerUtil, RenderTask, SVGGraphics, build, getDocument, version
- `../../src/display/display_utils.js`: DOMCanvasFactory, DOMSVGFactory, PDFDateString, PageViewport, PixelsPerInch, RenderingCancelledException, StatTimer, getFilenameFromUrl, getPdfFilenameFromUrl, getXfaPageViewport, isDataScheme, isPdfFile, isValidFetchUrl, loadScript, setLayerDimensions
- `../../src/display/editor/annotation_editor_layer.js`: AnnotationEditorLayer
- `../../src/display/editor/tools.js`: AnnotationEditorUIManager, CommandManager
- `../../src/display/fetch_stream.js`: PDFFetchStream
- `../../src/display/metadata.js`: Metadata
- `../../src/display/network.js`: PDFNetworkStream
- `../../src/display/network_utils.js`: createResponseStatusError, extractFilenameFromHeader, validateRangeRequestCapabilities, validateResponseStatus
- `../../src/display/node_stream.js`: PDFNodeStream
- `../../src/display/svg.js`: SVGGraphics
- `../../src/display/text_layer.js`: TextLayerRenderTask, renderTextLayer, updateTextLayer
- `../../src/display/worker_options.js`: GlobalWorkerOptions
- `../../src/display/xfa_layer.js`: XfaLayer
- `../../src/shared/message_handler.js`: MessageHandler
- `../../src/shared/murmurhash3.js`: MurmurHash3_64
- `../../src/shared/util.js`: AbortException, AnnotationBorderStyleType, AnnotationEditorParamsType, AnnotationEditorType, AnnotationFieldFlag, AnnotationFlag, AnnotationMode, AnnotationType, CMapCompressionType, FeatureTest, FormatError, ImageKind, InvalidPDFException, MissingPDFException, OPS, PasswordException, PasswordResponses, PermissionFlag, PromiseCapability, RenderingIntentFlag, UnexpectedResponseException, UnknownErrorException, Util, VerbosityLevel, bytesToString, createValidAbsoluteUrl, getModificationDate, getVerbosityLevel, isArrayBuffer, isNodeJS, normalizeUnicode, objectSize, setVerbosityLevel, shadow, string32, stringToBytes, stringToPDFString, stringToUTF8String
- `../../web/annotation_layer_builder.js`: AnnotationLayerBuilder
- `../../web/download_manager.js`: DownloadManager
- `../../web/event_utils.js`: EventBus, WaitOnType, waitOnEventOrTimeout
- `../../web/genericl10n.js`: GenericL10n
- `../../web/l10n_utils.js`: NullL10n
- `../../web/pdf_find_controller.js`: FindState, PDFFindController
- `../../web/pdf_find_utils.js`: CharacterType, getCharacterType
- `../../web/pdf_history.js`: PDFHistory, isDestArraysEqual, isDestHashesEqual
- `../../web/pdf_link_service.js`: LinkTarget, PDFLinkService, SimpleLinkService
- `../../web/pdf_page_view.js`: PDFPageView
- `../../web/pdf_scripting_manager.component.js`: PDFScriptingManager
- `../../web/pdf_single_page_viewer.js`: PDFSinglePageViewer
- `../../web/pdf_viewer.js`: PDFPageViewBuffer, PDFViewer
- `../../web/struct_tree_layer_builder.js`: StructTreeLayerBuilder
- `../../web/text_layer_builder.js`: TextLayerBuilder
- `../../web/ui_utils.js`: AutoPrintRegExp, ProgressBar, RenderingStates, ScrollMode, SpreadMode, backtrackBeforeAllVisibleElements, binarySearchFirstItem, getPageSizeInches, getVisibleElements, isPortraitOrientation, isValidRotation, parseQueryString, removeNullCharacters
- `../../web/xfa_layer_builder.js`: XfaLayerBuilder
- `./test_utils.js`: CMAP_URL, DefaultFileReaderFactory, STANDARD_FONT_DATA_URL, TEST_PDFS_PATH, XRefMock, buildGetDocumentParams, createIdFactory
- `./testreporter.js`: TestReporter
</imports>

Code:
<code>
File:
src/display/editor/tools.js
1 /* Copyright 2022 Mozilla Foundation
2  *
3  * Licensed under the Apache License, Version 2.0 (the "License");
4  * you may not use this file except in compliance with the License.
5  * You may obtain a copy of the License at
6  *
7  *     http://www.apache.org/licenses/LICENSE-2.0
8  *
9  * Unless required by applicable law or agreed to in writing, software
10  * distributed under the License is distributed on an "AS IS" BASIS,
11  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
12  * See the License for the specific language governing permissions and
13  * limitations under the License.
14  */
15 
16 /** @typedef {import("./editor.js").AnnotationEditor} AnnotationEditor */
17 // eslint-disable-next-line max-len
18 /** @typedef {import("./annotation_editor_layer.js").AnnotationEditorLayer} AnnotationEditorLayer */
19 
20 import {
21   AnnotationEditorPrefix,
22   AnnotationEditorType,
23   FeatureTest,
24   getUuid,
25   shadow,
26   Util,
27   warn,
28 } from "../../shared/util.js";
29 import { getColorValues, getRGB, PixelsPerInch } from "../display_utils.js";
30 
31 function bindEvents(obj, element, names) {
32   for (const name of names) {
33     element.addEventListener(name, obj[name].bind(obj));
34   }
35 }
36 
37 /**
38  * Convert a number between 0 and 100 into an hex number between 0 and 255.
39  * @param {number} opacity
40  * @return {string}
41  */
42 function opacityToHex(opacity) {
43   return Math.round(Math.min(255, Math.max(1, 255 * opacity)))
44     .toString(16)
45     .padStart(2, "0");
46 }
47 
48 /**
49  * Class to create some unique ids for the different editors.
50  */
51 class IdManager {
52   #id = 0;
53 
54   /**
55    * Get a unique id.
56    * @returns {string}
57    */
58   getId() {
59     return `${AnnotationEditorPrefix}${this.#id++}`;
60   }
61 }
62 
63 /**
64  * Class to manage the images used by the editors.
65  * The main idea is to try to minimize the memory used by the images.
66  * The images are cached and reused when possible
67  * We use a refCounter to know when an image is not used anymore but we need to
68  * be able to restore an image after a remove+undo, so we keep a file reference
69  * or an url one.
70  */
71 class ImageManager {
72   #baseId = getUuid();
73 
74   #id = 0;
75 
76   #cache = null;
77 
78   async #get(key, rawData) {
79     this.#cache ||= new Map();
80     let data = this.#cache.get(key);
81     if (data === null) {
82       // We already tried to load the image but it failed.
83       return null;
84     }
85     if (data?.bitmap) {
86       data.refCounter += 1;
87       return data;
88     }
89     try {
90       data ||= {
91         bitmap: null,
92         id: `image_${this.#baseId}_${this.#id++}`,
93         refCounter: 0,
94         isSvg: false,
95       };
96       let image;
97       if (typeof rawData === "string") {
98         data.url = rawData;
99 
100         const response = await fetch(rawData);
101         if (!response.ok) {
102           throw new Error(response.statusText);
103         }
104         image = await response.blob();
105       } else {
106         image = data.file = rawData;
107       }
108 
109       if (image.type === "image/svg+xml") {
110         // Unfortunately, createImageBitmap doesn't work with SVG images.
111         // (see https://bugzilla.mozilla.org/1841972).
112         const fileReader = new FileReader();
113         const imageElement = new Image();
114         const imagePromise = new Promise((resolve, reject) => {
115           imageElement.onload = () => {
116             data.bitmap = imageElement;
117             data.isSvg = true;
118             resolve();
119           };
120           fileReader.onload = () => {
121             imageElement.src = data.svgUrl = fileReader.result;
122           };
123           imageElement.onerror = fileReader.onerror = reject;
124         });
125         fileReader.readAsDataURL(image);
126         await imagePromise;
127       } else {
128         data.bitmap = await createImageBitmap(image);
129       }
130       data.refCounter = 1;
131     } catch (e) {
132       console.error(e);
133       data = null;
134     }
135     this.#cache.set(key, data);
136     if (data) {
137       this.#cache.set(data.id, data);
138     }
139     return data;
140   }
141 
142   async getFromFile(file) {
143     const { lastModified, name, size, type } = file;
144     return this.#get(`${lastModified}_${name}_${size}_${type}`, file);
145   }
146 
147   async getFromUrl(url) {
148     return this.#get(url, url);
149   }
150 
151   async getFromId(id) {
152     this.#cache ||= new Map();
153     const data = this.#cache.get(id);
154     if (!data) {
155       return null;
156     }
157     if (data.bitmap) {
158       data.refCounter += 1;
159       return data;
160     }
161 
162     if (data.file) {
163       return this.getFromFile(data.file);
164     }
165     return this.getFromUrl(data.url);
166   }
167 
168   getSvgUrl(id) {
169     const data = this.#cache.get(id);
170     if (!data?.isSvg) {
171       return null;
172     }
173     return data.svgUrl;
174   }
175 
176   deleteId(id) {
177     this.#cache ||= new Map();
178     const data = this.#cache.get(id);
179     if (!data) {
180       return;
181     }
182     data.refCounter -= 1;
183     if (data.refCounter !== 0) {
184       return;
185     }
186     data.bitmap = null;
187   }
188 
189   // We can use the id only if it belongs this manager.
190   // We must take care of having the right manager because we can copy/paste
191   // some images from other documents, hence it'd be a pity to use an id from an
192   // other manager.
193   isValidId(id) {
194     return id.startsWith(`image_${this.#baseId}_`);
195   }
196 }
197 
198 /**
199  * Class to handle undo/redo.
200  * Commands are just saved in a buffer.
201  * If we hit some memory issues we could likely use a circular buffer.
202  * It has to be used as a singleton.
203  */
204 class CommandManager {
205   #commands = [];
206 
207   #locked = false;
208 
209   #maxSize;
210 
211   #position = -1;
212 
213   constructor(maxSize = 128) {
214     this.#maxSize = maxSize;
215   }
216 
217   /**
218    * @typedef {Object} addOptions
219    * @property {function} cmd
220    * @property {function} undo
221    * @property {boolean} mustExec
222    * @property {number} type
223    * @property {boolean} overwriteIfSameType
224    * @property {boolean} keepUndo
225    */
226 
227   /**
228    * Add a new couple of commands to be used in case of redo/undo.
229    * @param {addOptions} options
230    */
231   add({
232     cmd,
233     undo,
234     mustExec,
235     type = NaN,
236     overwriteIfSameType = false,
237     keepUndo = false,
238   }) {
239     if (mustExec) {
240       cmd();
241     }
242 
243     if (this.#locked) {
244       return;
245     }
246 
247     const save = { cmd, undo, type };
248     if (this.#position === -1) {
249       if (this.#commands.length > 0) {
250         // All the commands have been undone and then a new one is added
251         // hence we clear the queue.
252         this.#commands.length = 0;
253       }
254       this.#position = 0;
255       this.#commands.push(save);
256       return;
257     }
258 
259     if (overwriteIfSameType && this.#commands[this.#position].type === type) {
260       // For example when we change a color we don't want to
261       // be able to undo all the steps, hence we only want to
262       // keep the last undoable action in this sequence of actions.
263       if (keepUndo) {
264         save.undo = this.#commands[this.#position].undo;
265       }
266       this.#commands[this.#position] = save;
267       return;
268     }
269 
270     const next = this.#position + 1;
271     if (next === this.#maxSize) {
272       this.#commands.splice(0, 1);
273     } else {
274       this.#position = next;
275       if (next < this.#commands.length) {
276         this.#commands.splice(next);
277       }
278     }
279 
280     this.#commands.push(save);
281   }
282 
283   /**
284    * Undo the last command.
285    */
286   undo() {
287     if (this.#position === -1) {
288       // Nothing to undo.
289       return;
290     }
291 
292     // Avoid to insert something during the undo execution.
293     this.#locked = true;
294     this.#commands[this.#position].undo();
295     this.#locked = false;
296 
297     this.#position -= 1;
298   }
299 
300   /**
301    * Redo the last command.
302    */
303   redo() {
304     if (this.#position < this.#commands.length - 1) {
305       this.#position += 1;
306 
307       // Avoid to insert something during the redo execution.
308       this.#locked = true;
309       this.#commands[this.#position].cmd();
310       this.#locked = false;
311     }
312   }
313 
314   /**
315    * Check if there is something to undo.
316    * @returns {boolean}
317    */
318   hasSomethingToUndo() {
319     return this.#position !== -1;
320   }
321 
322   /**
323    * Check if there is something to redo.
324    * @returns {boolean}
325    */
326   hasSomethingToRedo() {
327     return this.#position < this.#commands.length - 1;
328   }
329 
330   destroy() {
331     this.#commands = null;
332   }
333 }
334 
335 /**
336  * Class to handle the different keyboards shortcuts we can have on mac or
337  * non-mac OSes.
338  */
339 class KeyboardManager {
340   /**
341    * Create a new keyboard manager class.
342    * @param {Array<Array>} callbacks - an array containing an array of shortcuts
343    * and a callback to call.
344    * A shortcut is a string like `ctrl+c` or `mac+ctrl+c` for mac OS.
345    */
346   constructor(callbacks) {
347     this.buffer = [];
348     this.callbacks = new Map();
349     this.allKeys = new Set();
350 
351     const { isMac } = FeatureTest.platform;
352     for (const [keys, callback, bubbles = false] of callbacks) {
353       for (const key of keys) {
354         const isMacKey = key.startsWith("mac+");
355         if (isMac && isMacKey) {
356           this.callbacks.set(key.slice(4), { callback, bubbles });
357           this.allKeys.add(key.split("+").at(-1));
358         } else if (!isMac && !isMacKey) {
359           this.callbacks.set(key, { callback, bubbles });
360           this.allKeys.add(key.split("+").at(-1));
361         }
362       }
363     }
364   }
365 
366   /**
367    * Serialize an event into a string in order to match a
368    * potential key for a callback.
369    * @param {KeyboardEvent} event
370    * @returns {string}
371    */
372   #serialize(event) {
373     if (event.altKey) {
374       this.buffer.push("alt");
375     }
376     if (event.ctrlKey) {
377       this.buffer.push("ctrl");
378     }
379     if (event.metaKey) {
380       this.buffer.push("meta");
381     }
382     if (event.shiftKey) {
383       this.buffer.push("shift");
384     }
385     this.buffer.push(event.key);
386     const str = this.buffer.join("+");
387     this.buffer.length = 0;
388 
389     return str;
390   }
391 
392   /**
393    * Execute a callback, if any, for a given keyboard event.
394    * The self is used as `this` in the callback.
395    * @param {Object} self.
396    * @param {KeyboardEvent} event
397    * @returns
398    */
399   exec(self, event) {
400     if (!this.allKeys.has(event.key)) {
401       return;
402     }
403     const info = this.callbacks.get(this.#serialize(event));
404     if (!info) {
405       return;
406     }
407     const { callback, bubbles } = info;
408     callback.bind(self)();
409 
410     // For example, ctrl+s in a FreeText must be handled by the viewer, hence
411     // the event must bubble.
412     if (!bubbles) {
413       event.stopPropagation();
414       event.preventDefault();
415     }
416   }
417 }
418 
419 class ColorManager {
420   static _colorsMapping = new Map([
421     ["CanvasText", [0, 0, 0]],
422     ["Canvas", [255, 255, 255]],
423   ]);
424 
425   get _colors() {
426     if (
427       typeof PDFJSDev !== "undefined" &&
428       PDFJSDev.test("LIB") &&
429       typeof document === "undefined"
430     ) {
431       return shadow(this, "_colors", ColorManager._colorsMapping);
432     }
433 
434     const colors = new Map([
435       ["CanvasText", null],
436       ["Canvas", null],
437     ]);
438     getColorValues(colors);
439     return shadow(this, "_colors", colors);
440   }
441 
442   /**
443    * In High Contrast Mode, the color on the screen is not always the
444    * real color used in the pdf.
445    * For example in some cases white can appear to be black but when saving
446    * we want to have white.
447    * @param {string} color
448    * @returns {Array<number>}
449    */
450   convert(color) {
451     const rgb = getRGB(color);
452     if (!window.matchMedia("(forced-colors: active)").matches) {
453       return rgb;
454     }
455 
456     for (const [name, RGB] of this._colors) {
457       if (RGB.every((x, i) => x === rgb[i])) {
458         return ColorManager._colorsMapping.get(name);
459       }
460     }
461     return rgb;
462   }
463 
464   /**
465    * An input element must have its color value as a hex string
466    * and not as color name.
467    * So this function converts a name into an hex string.
468    * @param {string} name
469    * @returns {string}
470    */
471   getHexCode(name) {
472     const rgb = this._colors.get(name);
473     if (!rgb) {
474       return name;
475     }
476     return Util.makeHexColor(...rgb);
477   }
478 }
479 
480 /**
481  * A pdf has several pages and each of them when it will rendered
482  * will have an AnnotationEditorLayer which will contain the some
483  * new Annotations associated to an editor in order to modify them.
484  *
485  * This class is used to manage all the different layers, editors and
486  * some action like copy/paste, undo/redo, ...
487  */
488 class AnnotationEditorUIManager {
489   #activeEditor = null;
490 
491   #allEditors = new Map();
492 
493   #allLayers = new Map();
494 
495   #annotationStorage = null;
496 
497   #commandManager = new CommandManager();
498 
499   #currentPageIndex = 0;
500 
501   #deletedAnnotationsElementIds = new Set();
502 
503   #editorTypes = null;
504 
505   #editorsToRescale = new Set();
506 
507   #eventBus = null;
508 
509   #filterFactory = null;
510 
511   #idManager = new IdManager();
512 
513   #isEnabled = false;
514 
515   #mode = AnnotationEditorType.NONE;
516 
517   #selectedEditors = new Set();
518 
519   #pageColors = null;
520 
521   #boundCopy = this.copy.bind(this);
522 
523   #boundCut = this.cut.bind(this);
524 
525   #boundPaste = this.paste.bind(this);
526 
527   #boundKeydown = this.keydown.bind(this);
528 
529   #boundOnEditingAction = this.onEditingAction.bind(this);
530 
531   #boundOnPageChanging = this.onPageChanging.bind(this);
532 
533   #boundOnScaleChanging = this.onScaleChanging.bind(this);
534 
535   #boundOnRotationChanging = this.onRotationChanging.bind(this);
536 
537   #previousStates = {
538     isEditing: false,
539     isEmpty: true,
540     hasSomethingToUndo: false,
541     hasSomethingToRedo: false,
542     hasSelectedEditor: false,
543   };
544 
545   #container = null;
546 
547   static get _keyboardManager() {
548     return shadow(
549       this,
550       "_keyboardManager",
551       new KeyboardManager([
552         [
553           ["ctrl+a", "mac+meta+a"],
554           AnnotationEditorUIManager.prototype.selectAll,
555         ],
556         [["ctrl+z", "mac+meta+z"], AnnotationEditorUIManager.prototype.undo],
557         [
558           // On mac, depending of the OS version, the event.key is either "z" or
559           // "Z" when the user presses "meta+shift+z".
560           [
561             "ctrl+y",
562             "ctrl+shift+z",
563             "mac+meta+shift+z",
564             "ctrl+shift+Z",
565             "mac+meta+shift+Z",
566           ],
567           AnnotationEditorUIManager.prototype.redo,
568         ],
569         [
570           [
571             "Backspace",
572             "alt+Backspace",
573             "ctrl+Backspace",
574             "shift+Backspace",
575             "mac+Backspace",
576             "mac+alt+Backspace",
577             "mac+ctrl+Backspace",
578             "Delete",
579             "ctrl+Delete",
580             "shift+Delete",
581           ],
582           AnnotationEditorUIManager.prototype.delete,
583         ],
584         [
585           ["Escape", "mac+Escape"],
586           AnnotationEditorUIManager.prototype.unselectAll,
587         ],
588       ])
589     );
590   }
591 
592   constructor(container, eventBus, pdfDocument, pageColors) {
593     this.#container = container;
594     this.#eventBus = eventBus;
595     this.#eventBus._on("editingaction", this.#boundOnEditingAction);
596     this.#eventBus._on("pagechanging", this.#boundOnPageChanging);
597     this.#eventBus._on("scalechanging", this.#boundOnScaleChanging);
598     this.#eventBus._on("rotationchanging", this.#boundOnRotationChanging);
599     this.#annotationStorage = pdfDocument.annotationStorage;
600     this.#filterFactory = pdfDocument.filterFactory;
601     this.#pageColors = pageColors;
602     this.viewParameters = {
603       realScale: PixelsPerInch.PDF_TO_CSS_UNITS,
604       rotation: 0,
605     };
606   }
607 
608   destroy() {
609     this.#removeKeyboardManager();
610     this.#eventBus._off("editingaction", this.#boundOnEditingAction);
611     this.#eventBus._off("pagechanging", this.#boundOnPageChanging);
612     this.#eventBus._off("scalechanging", this.#boundOnScaleChanging);
613     this.#eventBus._off("rotationchanging", this.#boundOnRotationChanging);
614     for (const layer of this.#allLayers.values()) {
615       layer.destroy();
616     }
617     this.#allLayers.clear();
618     this.#allEditors.clear();
619     this.#editorsToRescale.clear();
620     this.#activeEditor = null;
621     this.#selectedEditors.clear();
622     this.#commandManager.destroy();
623   }
624 
625   get hcmFilter() {
626     return shadow(
627       this,
628       "hcmFilter",
629       this.#pageColors
630         ? this.#filterFactory.addHCMFilter(
631             this.#pageColors.foreground,
632             this.#pageColors.background
633           )
634         : "none"
635     );
636   }
637 
638   onPageChanging({ pageNumber }) {
639     this.#currentPageIndex = pageNumber - 1;
640   }
641 
642   focusMainContainer() {
643     this.#container.focus();
644   }
645 
646   addShouldRescale(editor) {
647     this.#editorsToRescale.add(editor);
648   }
649 
650   removeShouldRescale(editor) {
651     this.#editorsToRescale.delete(editor);
652   }
653 
654   onScaleChanging({ scale }) {
655     this.commitOrRemove();
656     this.viewParameters.realScale = scale * PixelsPerInch.PDF_TO_CSS_UNITS;
657     for (const editor of this.#editorsToRescale) {
658       editor.onScaleChanging();
659     }
660   }
661 
662   onRotationChanging({ pagesRotation }) {
663     this.commitOrRemove();
664     this.viewParameters.rotation = pagesRotation;
665   }
666 
667   /**
668    * Add an editor in the annotation storage.
669    * @param {AnnotationEditor} editor
670    */
671   addToAnnotationStorage(editor) {
672     if (
673       !editor.isEmpty() &&
674       this.#annotationStorage &&
675       !this.#annotationStorage.has(editor.id)
676     ) {
677       this.#annotationStorage.setValue(editor.id, editor);
678     }
679   }
680 
681   #addKeyboardManager() {
682     // The keyboard events are caught at the container level in order to be able
683     // to execute some callbacks even if the current page doesn't have focus.
684     this.#container.addEventListener("keydown", this.#boundKeydown);
685   }
686 
687   #removeKeyboardManager() {
688     this.#container.removeEventListener("keydown", this.#boundKeydown);
689   }
690 
691   #addCopyPasteListeners() {
692     document.addEventListener("copy", this.#boundCopy);
693     document.addEventListener("cut", this.#boundCut);
694     document.addEventListener("paste", this.#boundPaste);
695   }
696 
697   #removeCopyPasteListeners() {
698     document.removeEventListener("copy", this.#boundCopy);
699     document.removeEventListener("cut", this.#boundCut);
700     document.removeEventListener("paste", this.#boundPaste);
701   }
702 
703   /**
704    * Copy callback.
705    * @param {ClipboardEvent} event
706    */
707   copy(event) {
708     event.preventDefault();
709 
710     if (this.#activeEditor) {
711       // An editor is being edited so just commit it.
712       this.#activeEditor.commitOrRemove();
713     }
714 
715     if (!this.hasSelection) {
716       return;
717     }
718 
719     const editors = [];
720     for (const editor of this.#selectedEditors) {
721       const serialized = editor.serialize(/* isForCopying = */ true);
722       if (serialized) {
723         editors.push(serialized);
724       }
725     }
726     if (editors.length === 0) {
727       return;
728     }
729 
730     event.clipboardData.setData("application/pdfjs", JSON.stringify(editors));
731   }
732 
733   /**
734    * Cut callback.
735    * @param {ClipboardEvent} event
736    */
737   cut(event) {
738     this.copy(event);
739     this.delete();
740   }
741 
742   /**
743    * Paste callback.
744    * @param {ClipboardEvent} event
745    */
746   paste(event) {
747     event.preventDefault();
748 
749     let data = event.clipboardData.getData("application/pdfjs");
750     if (!data) {
751       return;
752     }
753 
754     try {
755       data = JSON.parse(data);
756     } catch (ex) {
757       warn(`paste: "${ex.message}".`);
758       return;
759     }
760 
761     if (!Array.isArray(data)) {
762       return;
763     }
764 
765     this.unselectAll();
766     const layer = this.#allLayers.get(this.#currentPageIndex);
767 
768     try {
769       const newEditors = [];
770       for (const editor of data) {
771         const deserializedEditor = layer.deserialize(editor);
772         if (!deserializedEditor) {
773           return;
774         }
775         newEditors.push(deserializedEditor);
776       }
777 
778       const cmd = () => {
779         for (const editor of newEditors) {
780           this.#addEditorToLayer(editor);
781         }
782         this.#selectEditors(newEditors);
783       };
784       const undo = () => {
785         for (const editor of newEditors) {
786           editor.remove();
787         }
788       };
789       this.addCommands({ cmd, undo, mustExec: true });
790     } catch (ex) {
791       warn(`paste: "${ex.message}".`);
792     }
793   }
794 
795   /**
796    * Keydown callback.
797    * @param {KeyboardEvent} event
798    */
799   keydown(event) {
800     if (!this.getActive()?.shouldGetKeyboardEvents()) {
801       AnnotationEditorUIManager._keyboardManager.exec(this, event);
802     }
803   }
804 
805   /**
806    * Execute an action for a given name.
807    * For example, the user can click on the "Undo" entry in the context menu
808    * and it'll trigger the undo action.
809    * @param {Object} details
810    */
811   onEditingAction(details) {
812     if (["undo", "redo", "delete", "selectAll"].includes(details.name)) {
813       this[details.name]();
814     }
815   }
816 
817   /**
818    * Update the different possible states of this manager, e.g. is there
819    * something to undo, redo, ...
820    * @param {Object} details
821    */
822   #dispatchUpdateStates(details) {
823     const hasChanged = Object.entries(details).some(
824       ([key, value]) => this.#previousStates[key] !== value
825     );
826 
827     if (hasChanged) {
828       this.#eventBus.dispatch("annotationeditorstateschanged", {
829         source: this,
830         details: Object.assign(this.#previousStates, details),
831       });
832     }
833   }
834 
835   #dispatchUpdateUI(details) {
836     this.#eventBus.dispatch("annotationeditorparamschanged", {
837       source: this,
838       details,
839     });
840   }
841 
842   /**
843    * Set the editing state.
844    * It can be useful to temporarily disable it when the user is editing a
845    * FreeText annotation.
846    * @param {boolean} isEditing
847    */
848   setEditingState(isEditing) {
849     if (isEditing) {
850       this.#addKeyboardManager();
851       this.#addCopyPasteListeners();
852       this.#dispatchUpdateStates({
853         isEditing: this.#mode !== AnnotationEditorType.NONE,
854         isEmpty: this.#isEmpty(),
855         hasSomethingToUndo: this.#commandManager.hasSomethingToUndo(),
856         hasSomethingToRedo: this.#commandManager.hasSomethingToRedo(),
857         hasSelectedEditor: false,
858       });
859     } else {
860       this.#removeKeyboardManager();
861       this.#removeCopyPasteListeners();
862       this.#dispatchUpdateStates({
863         isEditing: false,
864       });
865     }
866   }
867 
868   registerEditorTypes(types) {
869     if (this.#editorTypes) {
870       return;
871     }
872     this.#editorTypes = types;
873     for (const editorType of this.#editorTypes) {
874       this.#dispatchUpdateUI(editorType.defaultPropertiesToUpdate);
875     }
876   }
877 
878   /**
879    * Get an id.
880    * @returns {string}
881    */
882   getId() {
883     return this.#idManager.getId();
884   }
885 
886   get currentLayer() {
887     return this.#allLayers.get(this.#currentPageIndex);
888   }
889 
890   get currentPageIndex() {
891     return this.#currentPageIndex;
892   }
893 
894   /**
895    * Add a new layer for a page which will contains the editors.
896    * @param {AnnotationEditorLayer} layer
897    */
898   addLayer(layer) {
899     this.#allLayers.set(layer.pageIndex, layer);
900     if (this.#isEnabled) {
901       layer.enable();
902     } else {
903       layer.disable();
904     }
905   }
906 
907   /**
908    * Remove a layer.
909    * @param {AnnotationEditorLayer} layer
910    */
911   removeLayer(layer) {
912     this.#allLayers.delete(layer.pageIndex);
913   }
914 
915   /**
916    * Change the editor mode (None, FreeText, Ink, ...)
917    * @param {number} mode
918    * @param {string|null} editId
919    */
920   updateMode(mode, editId = null) {
921     this.#mode = mode;
922     if (mode === AnnotationEditorType.NONE) {
923       this.setEditingState(false);
924       this.#disableAll();
925       return;
926     }
927     this.setEditingState(true);
928     this.#enableAll();
929     for (const layer of this.#allLayers.values()) {
930       layer.updateMode(mode);
931     }
932     if (!editId) {
933       return;
934     }
935     for (const editor of this.#allEditors.values()) {
936       if (editor.annotationElementId === editId) {
937         this.setSelected(editor);
938         editor.enterInEditMode();
939         break;
940       }
941     }
942   }
943 
944   /**
945    * Update the toolbar if it's required to reflect the tool currently used.
946    * @param {number} mode
947    * @returns {undefined}
948    */
949   updateToolbar(mode) {
950     if (mode === this.#mode) {
951       return;
952     }
953     this.#eventBus.dispatch("switchannotationeditormode", {
954       source: this,
955       mode,
956     });
957   }
958 
959   /**
960    * Update a parameter in the current editor or globally.
961    * @param {number} type
962    * @param {*} value
963    */
964   updateParams(type, value) {
965     if (!this.#editorTypes) {
966       return;
967     }
968 
969     for (const editor of this.#selectedEditors) {
970       editor.updateParams(type, value);
971     }
972 
973     for (const editorType of this.#editorTypes) {
974       editorType.updateDefaultParams(type, value);
975     }
976   }
977 
978   /**
979    * Enable all the layers.
980    */
981   #enableAll() {
982     if (!this.#isEnabled) {
983       this.#isEnabled = true;
984       for (const layer of this.#allLayers.values()) {
985         layer.enable();
986       }
987     }
988   }
989 
990   /**
991    * Disable all the layers.
992    */
993   #disableAll() {
994     this.unselectAll();
995     if (this.#isEnabled) {
996       this.#isEnabled = false;
997       for (const layer of this.#allLayers.values()) {
998         layer.disable();
999       }
1000     }
1001   }
1002 
1003   /**
1004    * Get all the editors belonging to a give page.
1005    * @param {number} pageIndex
1006    * @returns {Array<AnnotationEditor>}
1007    */
1008   getEditors(pageIndex) {
1009     const editors = [];
1010     for (const editor of this.#allEditors.values()) {
1011       if (editor.pageIndex === pageIndex) {
1012         editors.push(editor);
1013       }
1014     }
1015     return editors;
1016   }
1017 
1018   /**
1019    * Get an editor with the given id.
1020    * @param {string} id
1021    * @returns {AnnotationEditor}
1022    */
1023   getEditor(id) {
1024     return this.#allEditors.get(id);
1025   }
1026 
1027   /**
1028    * Add a new editor.
1029    * @param {AnnotationEditor} editor
1030    */
1031   addEditor(editor) {
1032     this.#allEditors.set(editor.id, editor);
1033   }
1034 
1035   /**
1036    * Remove an editor.
1037    * @param {AnnotationEditor} editor
1038    */
1039   removeEditor(editor) {
1040     this.#allEditors.delete(editor.id);
1041     this.unselect(editor);
1042     if (
1043       !editor.annotationElementId ||
1044       !this.#deletedAnnotationsElementIds.has(editor.annotationElementId)
1045     ) {
1046       this.#annotationStorage?.remove(editor.id);
1047     }
1048   }
1049 
1050   /**
1051    * The annotation element with the given id has been deleted.
1052    * @param {AnnotationEditor} editor
1053    */
1054   addDeletedAnnotationElement(editor) {
1055     this.#deletedAnnotationsElementIds.add(editor.annotationElementId);
1056     editor.deleted = true;
1057   }
1058 
1059   /**
1060    * Check if the annotation element with the given id has been deleted.
1061    * @param {string} annotationElementId
1062    * @returns {boolean}
1063    */
1064   isDeletedAnnotationElement(annotationElementId) {
1065     return this.#deletedAnnotationsElementIds.has(annotationElementId);
1066   }
1067 
1068   /**
1069    * The annotation element with the given id have been restored.
1070    * @param {AnnotationEditor} editor
1071    */
1072   removeDeletedAnnotationElement(editor) {
1073     this.#deletedAnnotationsElementIds.delete(editor.annotationElementId);
1074     editor.deleted = false;
1075   }
1076 
1077   /**
1078    * Add an editor to the layer it belongs to or add it to the global map.
1079    * @param {AnnotationEditor} editor
1080    */
1081   #addEditorToLayer(editor) {
1082     const layer = this.#allLayers.get(editor.pageIndex);
1083     if (layer) {
1084       layer.addOrRebuild(editor);
1085     } else {
1086       this.addEditor(editor);
1087     }
1088   }
1089 
1090   /**
1091    * Set the given editor as the active one.
1092    * @param {AnnotationEditor} editor
1093    */
1094   setActiveEditor(editor) {
1095     if (this.#activeEditor === editor) {
1096       return;
1097     }
1098 
1099     this.#activeEditor = editor;
1100     if (editor) {
1101       this.#dispatchUpdateUI(editor.propertiesToUpdate);
1102     }
1103   }
1104 
1105   /**
1106    * Add or remove an editor the current selection.
1107    * @param {AnnotationEditor} editor
1108    */
1109   toggleSelected(editor) {
1110     if (this.#selectedEditors.has(editor)) {
1111       this.#selectedEditors.delete(editor);
1112       editor.unselect();
1113       this.#dispatchUpdateStates({
1114         hasSelectedEditor: this.hasSelection,
1115       });
1116       return;
1117     }
1118     this.#selectedEditors.add(editor);
1119     editor.select();
1120     this.#dispatchUpdateUI(editor.propertiesToUpdate);
1121     this.#dispatchUpdateStates({
1122       hasSelectedEditor: true,
1123     });
1124   }
1125 
1126   /**
1127    * Set the last selected editor.
1128    * @param {AnnotationEditor} editor
1129    */
1130   setSelected(editor) {
1131     for (const ed of this.#selectedEditors) {
1132       if (ed !== editor) {
1133         ed.unselect();
1134       }
1135     }
1136     this.#selectedEditors.clear();
1137 
1138     this.#selectedEditors.add(editor);
1139     editor.select();
1140     this.#dispatchUpdateUI(editor.propertiesToUpdate);
1141     this.#dispatchUpdateStates({
1142       hasSelectedEditor: true,
1143     });
1144   }
1145 
1146   /**
1147    * Check if the editor is selected.
1148    * @param {AnnotationEditor} editor
1149    */
1150   isSelected(editor) {
1151     return this.#selectedEditors.has(editor);
1152   }
1153 
1154   /**
1155    * Unselect an editor.
1156    * @param {AnnotationEditor} editor
1157    */
1158   unselect(editor) {
1159     editor.unselect();
1160     this.#selectedEditors.delete(editor);
1161     this.#dispatchUpdateStates({
1162       hasSelectedEditor: this.hasSelection,
1163     });
1164   }
1165 
1166   get hasSelection() {
1167     return this.#selectedEditors.size !== 0;
1168   }
1169 
1170   /**
1171    * Undo the last command.
1172    */
1173   undo() {
1174     this.#commandManager.undo();
1175     this.#dispatchUpdateStates({
1176       hasSomethingToUndo: this.#commandManager.hasSomethingToUndo(),
1177       hasSomethingToRedo: true,
1178       isEmpty: this.#isEmpty(),
1179     });
1180   }
1181 
1182   /**
1183    * Redo the last undoed command.
1184    */
1185   redo() {
1186     this.#commandManager.redo();
1187     this.#dispatchUpdateStates({
1188       hasSomethingToUndo: true,
1189       hasSomethingToRedo: this.#commandManager.hasSomethingToRedo(),
1190       isEmpty: this.#isEmpty(),
1191     });
1192   }
1193 
1194   /**
1195    * Add a command to execute (cmd) and another one to undo it.
1196    * @param {Object} params
1197    */
1198   addCommands(params) {
1199     this.#commandManager.add(params);
1200     this.#dispatchUpdateStates({
1201       hasSomethingToUndo: true,
1202       hasSomethingToRedo: false,
1203       isEmpty: this.#isEmpty(),
1204     });
1205   }
1206 
1207   #isEmpty() {
1208     if (this.#allEditors.size === 0) {
1209       return true;
1210     }
1211 
1212     if (this.#allEditors.size === 1) {
1213       for (const editor of this.#allEditors.values()) {
1214         return editor.isEmpty();
1215       }
1216     }
1217 
1218     return false;
1219   }
1220 
1221   /**
1222    * Delete the current editor or all.
1223    */
1224   delete() {
1225     this.commitOrRemove();
1226     if (!this.hasSelection) {
1227       return;
1228     }
1229 
1230     const editors = [...this.#selectedEditors];
1231     const cmd = () => {
1232       for (const editor of editors) {
1233         editor.remove();
1234       }
1235     };
1236     const undo = () => {
1237       for (const editor of editors) {
1238         this.#addEditorToLayer(editor);
1239       }
1240     };
1241 
1242     this.addCommands({ cmd, undo, mustExec: true });
1243   }
1244 
1245   commitOrRemove() {
1246     // An editor is being edited so just commit it.
1247     this.#activeEditor?.commitOrRemove();
1248   }
1249 
1250   /**
1251    * Select the editors.
1252    * @param {Array<AnnotationEditor>} editors
1253    */
1254   #selectEditors(editors) {
1255     this.#selectedEditors.clear();
1256     for (const editor of editors) {
1257       if (editor.isEmpty()) {
1258         continue;
1259       }
1260       this.#selectedEditors.add(editor);
1261       editor.select();
1262     }
1263     this.#dispatchUpdateStates({ hasSelectedEditor: true });
1264   }
1265 
1266   /**
1267    * Select all the editors.
1268    */
1269   selectAll() {
1270     for (const editor of this.#selectedEditors) {
1271       editor.commit();
1272     }
1273     this.#selectEditors(this.#allEditors.values());
1274   }
1275 
1276   /**
1277    * Unselect all the selected editors.
1278    */
1279   unselectAll() {
1280     if (this.#activeEditor) {
1281       // An editor is being edited so just commit it.
1282       this.#activeEditor.commitOrRemove();
1283       return;
1284     }
1285 
1286     if (this.#selectedEditors.size === 0) {
1287       return;
1288     }
1289     for (const editor of this.#selectedEditors) {
1290       editor.unselect();
1291     }
1292     this.#selectedEditors.clear();
1293     this.#dispatchUpdateStates({
1294       hasSelectedEditor: false,
1295     });
1296   }
1297 
1298   /**
1299    * Is the current editor the one passed as argument?
1300    * @param {AnnotationEditor} editor
1301    * @returns
1302    */
1303   isActive(editor) {
1304     return this.#activeEditor === editor;
1305   }
1306 
1307   /**
1308    * Get the current active editor.
1309    * @returns {AnnotationEditor|null}
1310    */
1311   getActive() {
1312     return this.#activeEditor;
1313   }
1314 
1315   /**
1316    * Get the current editor mode.
1317    * @returns {number}
1318    */
1319   getMode() {
1320     return this.#mode;
1321   }
1322 
1323   get imageManager() {
1324     return shadow(this, "imageManager", new ImageManager());
1325   }
1326 }
1327 
1328 export {
1329   AnnotationEditorUIManager,
1330   bindEvents,
1331   ColorManager,
1332   CommandManager,
1333   KeyboardManager,
1334   opacityToHex,
1335 };
</code>

Test file:
<test_file>
File:
test/unit/annotation_spec.js
/* Copyright 2017 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import {
  Annotation,
  AnnotationBorderStyle,
  AnnotationFactory,
  getQuadPoints,
  MarkupAnnotation,
} from "../../src/core/annotation.js";
import {
  AnnotationBorderStyleType,
  AnnotationEditorType,
  AnnotationFieldFlag,
  AnnotationFlag,
  AnnotationType,
  OPS,
  RenderingIntentFlag,
  stringToBytes,
  stringToUTF8String,
} from "../../src/shared/util.js";
import {
  CMAP_URL,
  createIdFactory,
  STANDARD_FONT_DATA_URL,
  XRefMock,
} from "./test_utils.js";
import {
  DefaultCMapReaderFactory,
  DefaultStandardFontDataFactory,
} from "../../src/display/api.js";
import { Dict, Name, Ref, RefSetCache } from "../../src/core/primitives.js";
import { Lexer, Parser } from "../../src/core/parser.js";
import { PartialEvaluator } from "../../src/core/evaluator.js";
import { StringStream } from "../../src/core/stream.js";
import { WorkerTask } from "../../src/core/worker.js";
</test_file>

Your task:
You are a software tester at pdf.js.
1. Examine the existing test file. You may reuse any imports, helpers or setup blocks it already has.
2. Write exactly one javascript test `it("...", async () => {...})` block.
3. Your test must fail on the code before the patch, and pass after, hence the test will verify that the patch resolves the issue.
4. The test must be self-contained and to-the-point.
5. If you need something new use only the provided imports (respect the paths exactly how they are given) by importing dynamically for compatibility with Node.js — no new dependencies. 
6. Return only the javascript code for the new `it(...)` block (no comments or explanations).

Example structure:
it("should <describe behavior>", async () => {
  const { example } = await import("../../src/core/example.js");
  <initialize required variables>;
  <define expected variable>;
  <generate actual variables>;
  <compare expected with actual>;
});

