Before you begin:
- Keep going until the job is completely solved — don’t stop halfway.
- If you’re unsure about the behavior, reread the provided patch carefully; do not hallucinate.
- Plan your approach before writing code by reflecting on whether the test truly fails before and passes after.

Issue:
<issue>
[Bug]: PolygonAnnotation fill not rendered (only outline) in PDF.js web viewer, but works in Acrobat and Edge
### Attach (recommended) or Link to PDF file

[document.pdf](https://github.com/user-attachments/files/21099399/document.pdf)

### Web browser and its version

Edge-138.0.3351.65

### Operating system and its version

Win11- 26100.4349

### PDF.js version

5.3.93

### Is the bug present in the latest PDF.js version?

Yes

### Is a browser extension

No

### Steps to reproduce the problem

1. Create a PDF with a PolygonAnnotation that has both a stroke and a fill color (libraries(https://github.com/highkite/pdfAnnotate)).(The pdf uploaded)
2. Open the PDF in the PDF.js web viewer.
3. Observe that only the polygon's outline is visible, with no fill.
4. Open the same PDF in Acrobat or Edge and observe that the polygon is correctly filled.

### What is the expected behavior?

Expected behavior
The polygon annotation should be rendered with both its outline and fill color, consistent with Acrobat and Edge.
Acrobat:
<img width="467" height="605" alt="Image" src="https://github.com/user-attachments/assets/4b1bc337-953e-44e6-8f54-6e105bf106da" />
Edge:

<img width="980" height="897" alt="Image" src="https://github.com/user-attachments/assets/bd55054d-fba3-42a1-a53f-4625de423d29" />

### What went wrong?

 When displaying a PDF containing PolygonAnnotation (with fill color) using the PDF.js web viewer, only the outline of the polygon is rendered. The fill color is missing. However, the same PDF displays correctly (with both fill and outline) in Adobe Acrobat and Microsoft Edge's built-in PDF viewer.

### Link to a viewer

_No response_

### Additional context

_No response_
</issue>

PDF File:
<pdf>
issue20062.pdf
</pdf>

Patch:
<patch>
diff --git a/src/core/annotation.js b/src/core/annotation.js
--- a/src/core/annotation.js
+++ b/src/core/annotation.js
@@ -2391,7 +2391,7 @@ class WidgetAnnotation extends Annotation {
 
     if (encodingError && intent & RenderingIntentFlag.SAVE) {
       // We don't have a way to render the field, so we just rely on the
-      // /NeedAppearances trick to let the different software correctly render
+      // /NeedAppearances trick to let the different sofware correctly render
       // this pdf.
       return { needAppearances: true };
     }
@@ -4337,6 +4337,24 @@ class PolylineAnnotation extends MarkupAnnotation {
       const strokeColor = this.color ? getPdfColorArray(this.color) : [0, 0, 0];
       const strokeAlpha = dict.get("CA");
 
+      let fillColor = getRgbColor(dict.getArray("IC"), null);
+      if (fillColor) {
+        fillColor = getPdfColorArray(fillColor);
+      }
+
+      let operator;
+      if (fillColor) {
+        if (this.color) {
+          operator = fillColor.every((c, i) => c === strokeColor[i])
+            ? "f"
+            : "B";
+        } else {
+          operator = "f";
+        }
+      } else {
+        operator = "S";
+      }
+
       const borderWidth = this.borderStyle.width || 1,
         borderAdjust = 2 * borderWidth;
 
@@ -4361,13 +4379,15 @@ class PolylineAnnotation extends MarkupAnnotation {
         extra: `${borderWidth} w`,
         strokeColor,
         strokeAlpha,
+        fillColor,
+        fillAlpha: fillColor ? strokeAlpha : null,
         pointsCallback: (buffer, points) => {
           for (let i = 0, ii = vertices.length; i < ii; i += 2) {
             buffer.push(
               `${vertices[i]} ${vertices[i + 1]} ${i === 0 ? "m" : "l"}`
             );
           }
-          buffer.push("S");
+          buffer.push(operator);
           return [points[0], points[7], points[2], points[3]];
         },
       });


</patch>

Imports:
<imports>
Available Packages
Dev Dependencies:
- @babel/core: ^7.27.4
- @babel/preset-env: ^7.27.2
- @babel/runtime: ^7.27.6
- @csstools/postcss-light-dark-function: ^2.0.9
- @fluent/bundle: ^0.19.1
- @fluent/dom: ^0.10.1
- @metalsmith/layouts: ^3.0.0
- @metalsmith/markdown: ^1.10.0
- @napi-rs/canvas: ^0.1.71
- @types/node: ^24.0.3
- autoprefixer: ^10.4.21
- babel-loader: ^10.0.0
- caniuse-lite: ^1.0.30001724
- core-js: ^3.43.0
- eslint: ^9.29.0
- eslint-plugin-import: ^2.32.0
- eslint-plugin-jasmine: ^4.2.2
- eslint-plugin-json: ^4.0.1
- eslint-plugin-no-unsanitized: ^4.1.2
- eslint-plugin-perfectionist: ^4.15.0
- eslint-plugin-prettier: ^5.5.0
- eslint-plugin-unicorn: ^59.0.1
- globals: ^16.2.0
- gulp: ^5.0.1
- gulp-cli: ^3.1.0
- gulp-postcss: ^10.0.0
- gulp-rename: ^2.0.0
- gulp-replace: ^1.1.4
- gulp-zip: ^6.1.0
- highlight.js: ^11.11.1
- jasmine: ^5.8.0
- jsdoc: ^4.0.4
- jstransformer-nunjucks: ^1.2.0
- metalsmith: ^2.6.3
- metalsmith-html-relative: ^2.0.6
- ordered-read-streams: ^2.0.0
- pngjs: ^7.0.0
- postcss: ^8.5.6
- postcss-dir-pseudo-class: ^9.0.1
- postcss-discard-comments: ^7.0.4
- postcss-nesting: ^13.0.2
- prettier: ^3.5.3
- puppeteer: ^24.10.2
- stylelint: ^16.21.0
- stylelint-prettier: ^5.0.3
- svglint: ^4.1.0
- terser-webpack-plugin: ^5.3.14
- tsc-alias: ^1.8.16
- ttest: ^4.0.0
- typescript: ^5.8.3
- vinyl: ^3.0.1
- webpack: ^5.99.9
- webpack-stream: ^7.0.0
- yargs: ^18.0.0

Engines:
- node: >=20.16.0 || >=22.3.0

Available Relative Imports:
- `../../src/core/annotation.js`: Annotation, AnnotationBorderStyle, AnnotationFactory, MarkupAnnotation, getQuadPoints
- `../../src/core/bidi.js`: bidi
- `../../src/core/calculate_md5.js`: calculateMD5
- `../../src/core/calculate_sha256.js`: calculateSHA256
- `../../src/core/calculate_sha_other.js`: calculateSHA384, calculateSHA512
- `../../src/core/cff_parser.js`: CFFCharset, CFFCompiler, CFFFDSelect, CFFParser, CFFStrings
- `../../src/core/cmap.js`: CMap, CMapFactory, IdentityCMap
- `../../src/core/colorspace.js`: ColorSpace
- `../../src/core/colorspace_utils.js`: ColorSpaceUtils
- `../../src/core/core_utils.js`: arrayBuffersToBytes, encodeToXmlString, escapePDFName, escapeString, getInheritableProperty, getSizeInBytes, isAscii, isWhiteSpace, log2, numberToString, parseXFAPath, recoverJsURL, stringToUTF16HexString, stringToUTF16String, toRomanNumerals, validateCSSFont
- `../../src/core/crypto.js`: AES128Cipher, AES256Cipher, ARCFourCipher, CipherTransformFactory, PDF17, PDF20
- `../../src/core/default_appearance.js`: createDefaultAppearance, parseAppearanceStream, parseDefaultAppearance
- `../../src/core/document.js`: PDFDocument, Page
- `../../src/core/encodings.js`: getEncoding
- `../../src/core/evaluator.js`: PartialEvaluator
- `../../src/core/flate_stream.js`: FlateStream
- `../../src/core/font_substitutions.js`: getFontSubstitution
- `../../src/core/fonts_utils.js`: SEAC_ANALYSIS_ENABLED
- `../../src/core/function.js`: PDFFunctionFactory, PostScriptCompiler, PostScriptEvaluator
- `../../src/core/glyphlist.js`: getDingbatsGlyphsUnicode, getGlyphsUnicode
- `../../src/core/image_utils.js`: GlobalColorSpaceCache, GlobalImageCache, LocalColorSpaceCache
- `../../src/core/jbig2.js`: Jbig2Error, Jbig2Image
- `../../src/core/jpg.js`: JpegError, JpegImage
- `../../src/core/jpx.js`: JpxError, JpxImage
- `../../src/core/metadata_parser.js`: MetadataParser
- `../../src/core/operator_list.js`: OperatorList
- `../../src/core/parser.js`: Lexer, Linearization, Parser
- `../../src/core/predictor_stream.js`: PredictorStream
- `../../src/core/primitives.js`: Cmd, Dict, EOF, Name, Ref, RefSet, RefSetCache, isCmd, isDict, isName, isRefsEqual
- `../../src/core/ps_parser.js`: PostScriptLexer, PostScriptParser
- `../../src/core/stream.js`: NullStream, Stream, StringStream
- `../../src/core/type1_parser.js`: Type1Parser
- `../../src/core/unicode.js`: getCharUnicodeCategory, getUnicodeForGlyph, getUnicodeRangeFor, mapSpecialUnicodeValues
- `../../src/core/worker.js`: WorkerMessageHandler, WorkerTask
- `../../src/core/writer.js`: incrementalUpdate, writeChanges, writeDict
- `../../src/core/xfa/bind.js`: Binder
- `../../src/core/xfa/data.js`: DataHandler
- `../../src/core/xfa/factory.js`: XFAFactory
- `../../src/core/xfa/formcalc_lexer.js`: Lexer, TOKEN, Token
- `../../src/core/xfa/formcalc_parser.js`: Errors, Parser
- `../../src/core/xfa/parser.js`: XFAParser
- `../../src/core/xfa/som.js`: searchNode
- `../../src/core/xfa/symbol_utils.js`: $dump, $getChildren, $getChildrenByClass, $getChildrenByName, $text, $uid
- `../../src/core/xml_parser.js`: SimpleXMLParser, XMLParserBase
- `../../src/display/annotation_layer.js`: AnnotationLayer
- `../../src/display/annotation_storage.js`: AnnotationStorage
- `../../src/display/api.js`: PDFDataRangeTransport, PDFDocumentLoadingTask, PDFDocumentProxy, PDFPageProxy, PDFWorker, RenderTask, build, getDocument, version
- `../../src/display/api_utils.js`: LoopbackPort, isValidExplicitDest
- `../../src/display/canvas_factory.js`: DOMCanvasFactory
- `../../src/display/cmap_reader_factory.js`: DOMCMapReaderFactory
- `../../src/display/display_utils.js`: OutputScale, PDFDateString, PageViewport, PixelsPerInch, RenderingCancelledException, StatTimer, SupportedImageMimeTypes, fetchData, getFilenameFromUrl, getPdfFilenameFromUrl, getXfaPageViewport, isDataScheme, isPdfFile, isValidFetchUrl, noContextMenu, setLayerDimensions, stopEvent
- `../../src/display/draw_layer.js`: DrawLayer
- `../../src/display/editor/annotation_editor_layer.js`: AnnotationEditorLayer
- `../../src/display/editor/color_picker.js`: ColorPicker
- `../../src/display/editor/drawers/signaturedraw.js`: SignatureExtractor
- `../../src/display/editor/tools.js`: AnnotationEditorUIManager, CommandManager
- `../../src/display/fetch_stream.js`: PDFFetchStream
- `../../src/display/metadata.js`: Metadata
- `../../src/display/network.js`: PDFNetworkStream
- `../../src/display/network_utils.js`: createHeaders, createResponseError, extractFilenameFromHeader, validateRangeRequestCapabilities, validateResponseStatus
- `../../src/display/node_stream.js`: PDFNodeStream
- `../../src/display/node_utils.js`: NodeCMapReaderFactory, NodeStandardFontDataFactory, fetchData
- `../../src/display/standard_fontdata_factory.js`: DOMStandardFontDataFactory
- `../../src/display/svg_factory.js`: DOMSVGFactory
- `../../src/display/text_layer.js`: TextLayer
- `../../src/display/touch_manager.js`: TouchManager
- `../../src/display/worker_options.js`: GlobalWorkerOptions
- `../../src/display/xfa_layer.js`: XfaLayer
- `../../src/shared/message_handler.js`: MessageHandler
- `../../src/shared/murmurhash3.js`: MurmurHash3_64
- `../../src/shared/util.js`: AbortException, AnnotationBorderStyleType, AnnotationEditorParamsType, AnnotationEditorType, AnnotationFieldFlag, AnnotationFlag, AnnotationMode, AnnotationType, BaseException, DrawOPS, FeatureTest, FormatError, ImageKind, InvalidPDFException, MathClamp, OPS, PasswordException, PasswordResponses, PermissionFlag, RenderingIntentFlag, ResponseException, UnknownErrorException, Util, VerbosityLevel, assert, bytesToString, createValidAbsoluteUrl, getModificationDate, getUuid, getVerbosityLevel, isNodeJS, normalizeUnicode, objectSize, setVerbosityLevel, shadow, string32, stringToBytes, stringToPDFString, stringToUTF8String, toBase64Util, updateUrlHash
- `../../web/annotation_layer_builder.js`: AnnotationLayerBuilder
- `../../web/app_options.js`: AppOptions, OptionKind
- `../../web/autolinker.js`: Autolinker
- `../../web/download_manager.js`: DownloadManager
- `../../web/event_utils.js`: EventBus, WaitOnType, waitOnEventOrTimeout
- `../../web/genericl10n.js`: GenericL10n
- `../../web/pdf_find_controller.js`: FindState, PDFFindController
- `../../web/pdf_find_utils.js`: CharacterType, getCharacterType
- `../../web/pdf_history.js`: PDFHistory, isDestArraysEqual, isDestHashesEqual
- `../../web/pdf_link_service.js`: LinkTarget, PDFLinkService, SimpleLinkService
- `../../web/pdf_page_view.js`: PDFPageView
- `../../web/pdf_scripting_manager.component.js`: PDFScriptingManager
- `../../web/pdf_single_page_viewer.js`: PDFSinglePageViewer
- `../../web/pdf_viewer.js`: PDFPageViewBuffer, PDFViewer
- `../../web/struct_tree_layer_builder.js`: StructTreeLayerBuilder
- `../../web/text_layer_builder.js`: TextLayerBuilder
- `../../web/ui_utils.js`: AutoPrintRegExp, ProgressBar, RenderingStates, ScrollMode, SpreadMode, backtrackBeforeAllVisibleElements, binarySearchFirstItem, calcRound, getPageSizeInches, getVisibleElements, isPortraitOrientation, isValidRotation, parseQueryString, removeNullCharacters
- `../../web/xfa_layer_builder.js`: XfaLayerBuilder
- `../reporter.js`: TestReporter
- `./common_pdfstream_tests.js`: testCrossOriginRedirects
- `./test_utils.js`: CMAP_URL, DefaultCMapReaderFactory, DefaultFileReaderFactory, DefaultStandardFontDataFactory, STANDARD_FONT_DATA_URL, TEST_PDFS_PATH, TestPdfsServer, XRefMock, buildGetDocumentParams, createIdFactory, getCrossOriginHostname
</imports>

Code:
<code>
File:
src/core/annotation.js
1 /* Copyright 2012 Mozilla Foundation
2  *
3  * Licensed under the Apache License, Version 2.0 (the "License");
4  * you may not use this file except in compliance with the License.
5  * You may obtain a copy of the License at
6  *
7  *     http://www.apache.org/licenses/LICENSE-2.0
8  *
9  * Unless required by applicable law or agreed to in writing, software
10  * distributed under the License is distributed on an "AS IS" BASIS,
11  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
12  * See the License for the specific language governing permissions and
13  * limitations under the License.
14  */
15 
16 import {
17   AnnotationActionEventType,
18   AnnotationBorderStyleType,
19   AnnotationEditorType,
20   AnnotationFieldFlag,
21   AnnotationFlag,
22   AnnotationReplyType,
23   AnnotationType,
24   assert,
25   BASELINE_FACTOR,
26   FeatureTest,
27   getModificationDate,
28   info,
29   isArrayEqual,
30   LINE_DESCENT_FACTOR,
31   LINE_FACTOR,
32   OPS,
33   RenderingIntentFlag,
34   shadow,
35   stringToPDFString,
36   unreachable,
37   Util,
38   warn,
39 } from "../shared/util.js";
40 import {
41   collectActions,
42   escapeString,
43   getInheritableProperty,
44   getParentToUpdate,
45   getRotationMatrix,
46   IDENTITY_MATRIX,
47   isNumberArray,
48   lookupMatrix,
49   lookupNormalRect,
50   lookupRect,
51   numberToString,
52   RESOURCES_KEYS_OPERATOR_LIST,
53   RESOURCES_KEYS_TEXT_CONTENT,
54   stringToAsciiOrUTF16BE,
55   stringToUTF16String,
56 } from "./core_utils.js";
57 import {
58   createDefaultAppearance,
59   FakeUnicodeFont,
60   getPdfColor,
61   parseAppearanceStream,
62   parseDefaultAppearance,
63 } from "./default_appearance.js";
64 import { DateFormats, TimeFormats } from "../shared/scripting_utils.js";
65 import { Dict, isName, isRefsEqual, Name, Ref, RefSet } from "./primitives.js";
66 import { Stream, StringStream } from "./stream.js";
67 import { BaseStream } from "./base_stream.js";
68 import { bidi } from "./bidi.js";
69 import { Catalog } from "./catalog.js";
70 import { ColorSpaceUtils } from "./colorspace_utils.js";
71 import { FileSpec } from "./file_spec.js";
72 import { JpegStream } from "./jpeg_stream.js";
73 import { ObjectLoader } from "./object_loader.js";
74 import { OperatorList } from "./operator_list.js";
75 import { XFAFactory } from "./xfa/factory.js";
76 
1836 class WidgetAnnotation extends Annotation {
1837   constructor(params) {
1838     super(params);
1839 
1840     const { dict, xref, annotationGlobals } = params;
1841     const data = this.data;
1842     this._needAppearances = params.needAppearances;
1843 
1844     data.annotationType = AnnotationType.WIDGET;
1845     if (data.fieldName === undefined) {
1846       data.fieldName = this._constructFieldName(dict);
1847     }
1848 
1849     if (data.actions === undefined) {
1850       data.actions = collectActions(xref, dict, AnnotationActionEventType);
1851     }
1852 
1853     let fieldValue = getInheritableProperty({
1854       dict,
1855       key: "V",
1856       getArray: true,
1857     });
1858     data.fieldValue = this._decodeFormValue(fieldValue);
1859 
1860     const defaultFieldValue = getInheritableProperty({
1861       dict,
1862       key: "DV",
1863       getArray: true,
1864     });
1865     data.defaultFieldValue = this._decodeFormValue(defaultFieldValue);
1866 
1867     if (fieldValue === undefined && annotationGlobals.xfaDatasets) {
1868       // Try to figure out if we have something in the xfa dataset.
1869       const path = this._title.str;
1870       if (path) {
1871         this._hasValueFromXFA = true;
1872         data.fieldValue = fieldValue =
1873           annotationGlobals.xfaDatasets.getValue(path);
1874       }
1875     }
1876 
1877     // When no "V" entry exists, let the fieldValue fallback to the "DV" entry
1878     // (fixes issue13823.pdf).
1879     if (fieldValue === undefined && data.defaultFieldValue !== null) {
1880       data.fieldValue = data.defaultFieldValue;
1881     }
1882 
1883     data.alternativeText = stringToPDFString(dict.get("TU") || "");
1884 
1885     this.setDefaultAppearance(params);
1886 
1887     data.hasAppearance ||=
1888       this._needAppearances &&
1889       data.fieldValue !== undefined &&
1890       data.fieldValue !== null;
1891 
1892     const fieldType = getInheritableProperty({ dict, key: "FT" });
1893     data.fieldType = fieldType instanceof Name ? fieldType.name : null;
1894 
1895     const localResources = getInheritableProperty({ dict, key: "DR" });
1896     const acroFormResources = annotationGlobals.acroForm.get("DR");
1897     const appearanceResources = this.appearance?.dict.get("Resources");
1898 
1899     this._fieldResources = {
1900       localResources,
1901       acroFormResources,
1902       appearanceResources,
1903       mergedResources: Dict.merge({
1904         xref,
1905         dictArray: [localResources, appearanceResources, acroFormResources],
1906         mergeSubDicts: true,
1907       }),
1908     };
1909 
1910     data.fieldFlags = getInheritableProperty({ dict, key: "Ff" });
1911     if (!Number.isInteger(data.fieldFlags) || data.fieldFlags < 0) {
1912       data.fieldFlags = 0;
1913     }
1914 
1915     data.password = this.hasFieldFlag(AnnotationFieldFlag.PASSWORD);
1916     data.readOnly = this.hasFieldFlag(AnnotationFieldFlag.READONLY);
1917     data.required = this.hasFieldFlag(AnnotationFieldFlag.REQUIRED);
1918     data.hidden =
1919       this._hasFlag(data.annotationFlags, AnnotationFlag.HIDDEN) ||
1920       this._hasFlag(data.annotationFlags, AnnotationFlag.NOVIEW);
1921   }
1922 
2275   async _getAppearance(evaluator, task, intent, annotationStorage) {
2276     if (this.data.password) {
2277       return null;
2278     }
2279     const storageEntry = annotationStorage?.get(this.data.id);
2280     let value, rotation;
2281     if (storageEntry) {
2282       value = storageEntry.formattedValue || storageEntry.value;
2283       rotation = storageEntry.rotation;
2284     }
2285 
2286     if (
2287       rotation === undefined &&
2288       value === undefined &&
2289       !this._needAppearances
2290     ) {
2291       if (!this._hasValueFromXFA || this.appearance) {
2292         // The annotation hasn't been rendered so use the appearance.
2293         return null;
2294       }
2295     }
2296 
2297     // Empty or it has a trailing whitespace.
2298     const colors = this.getBorderAndBackgroundAppearances(annotationStorage);
2299 
2300     if (value === undefined) {
2301       // The annotation has its value in XFA datasets but not in the V field.
2302       value = this.data.fieldValue;
2303       if (!value) {
2304         return `/Tx BMC q ${colors}Q EMC`;
2305       }
2306     }
2307 
2308     if (Array.isArray(value) && value.length === 1) {
2309       value = value[0];
2310     }
2311 
2312     assert(typeof value === "string", "Expected `value` to be a string.");
2313     value = value.trimEnd();
2314 
2315     if (this.data.combo) {
2316       // The value can be one of the exportValue or any other values.
2317       const option = this.data.options.find(
2318         ({ exportValue }) => value === exportValue
2319       );
2320       value = option?.displayValue || value;
2321     }
2322 
2323     if (value === "") {
2324       // the field is empty: nothing to render
2325       return `/Tx BMC q ${colors}Q EMC`;
2326     }
2327 
2328     if (rotation === undefined) {
2329       rotation = this.rotation;
2330     }
2331 
2332     let lineCount = -1;
2333     let lines;
2334 
2335     // We could have a text containing for example some sequences of chars and
2336     // their diacritics (e.g. "é".normalize("NFKD") shows 1 char when it's 2).
2337     // Positioning diacritics is really something we don't want to do here.
2338     // So if a font has a glyph for a acute accent and one for "e" then we won't
2339     // get any encoding issues but we'll render "e" and then "´".
2340     // It's why we normalize the string. We use NFC to preserve the initial
2341     // string, (e.g. "²".normalize("NFC") === "²"
2342     // but "²".normalize("NFKC") === "2").
2343     //
2344     // TODO: it isn't a perfect solution, some chars like "ẹ́" will be
2345     // decomposed into two chars ("ẹ" and "´"), so we should detect such
2346     // situations and then use either FakeUnicodeFont or set the
2347     // /NeedAppearances flag.
2348     if (this.data.multiLine) {
2349       lines = value.split(/\r\n?|\n/).map(line => line.normalize("NFC"));
2350       lineCount = lines.length;
2351     } else {
2352       lines = [value.replace(/\r\n?|\n/, "").normalize("NFC")];
2353     }
2354 
2355     const defaultPadding = 1;
2356     const defaultHPadding = 2;
2357     let { width: totalWidth, height: totalHeight } = this;
2358 
2359     if (rotation === 90 || rotation === 270) {
2360       [totalWidth, totalHeight] = [totalHeight, totalWidth];
2361     }
2362 
2363     if (!this._defaultAppearance) {
2364       // The DA is required and must be a string.
2365       // If there is no font named Helvetica in the resource dictionary,
2366       // the evaluator will fall back to a default font.
2367       // Doing so prevents exceptions and allows saving/printing
2368       // the file as expected.
2369       this.data.defaultAppearanceData = parseDefaultAppearance(
2370         (this._defaultAppearance = "/Helvetica 0 Tf 0 g")
2371       );
2372     }
2373 
2374     let font = await WidgetAnnotation._getFontData(
2375       evaluator,
2376       task,
2377       this.data.defaultAppearanceData,
2378       this._fieldResources.mergedResources
2379     );
2380 
2381     let defaultAppearance, fontSize, lineHeight;
2382     const encodedLines = [];
2383     let encodingError = false;
2384     for (const line of lines) {
2385       const encodedString = font.encodeString(line);
2386       if (encodedString.length > 1) {
2387         encodingError = true;
2388       }
2389       encodedLines.push(encodedString.join(""));
2390     }
2391 
2392     if (encodingError && intent & RenderingIntentFlag.SAVE) {
2393       // We don't have a way to render the field, so we just rely on the
2394       // /NeedAppearances trick to let the different software correctly render
2395       // this pdf.
2396       return { needAppearances: true };
2397     }
2398 
2399     // We check that the font is able to encode the string.
2400     if (encodingError && this._isOffscreenCanvasSupported) {
2401       // If it can't then we fallback on fake unicode font (mapped to sans-serif
2402       // for the rendering).
2403       // It means that a printed form can be rendered differently (it depends on
2404       // the sans-serif font) but at least we've something to render.
2405       // In an ideal world the associated font should correctly handle the
2406       // possible chars but a user can add a smiley or whatever.
2407       // We could try to embed a font but it means that we must have access
2408       // to the raw font file.
2409       const fontFamily = this.data.comb ? "monospace" : "sans-serif";
2410       const fakeUnicodeFont = new FakeUnicodeFont(evaluator.xref, fontFamily);
2411       const resources = fakeUnicodeFont.createFontResources(lines.join(""));
2412       const newFont = resources.getRaw("Font");
2413 
2414       if (this._fieldResources.mergedResources.has("Font")) {
2415         const oldFont = this._fieldResources.mergedResources.get("Font");
2416         for (const key of newFont.getKeys()) {
2417           oldFont.set(key, newFont.getRaw(key));
2418         }
2419       } else {
2420         this._fieldResources.mergedResources.set("Font", newFont);
2421       }
2422 
2423       const fontName = fakeUnicodeFont.fontName.name;
2424       font = await WidgetAnnotation._getFontData(
2425         evaluator,
2426         task,
2427         { fontName, fontSize: 0 },
2428         resources
2429       );
2430 
2431       for (let i = 0, ii = encodedLines.length; i < ii; i++) {
2432         encodedLines[i] = stringToUTF16String(lines[i]);
2433       }
2434 
2435       const savedDefaultAppearance = Object.assign(
2436         Object.create(null),
2437         this.data.defaultAppearanceData
2438       );
2439       this.data.defaultAppearanceData.fontSize = 0;
2440       this.data.defaultAppearanceData.fontName = fontName;
2441 
2442       [defaultAppearance, fontSize, lineHeight] = this._computeFontSize(
2443         totalHeight - 2 * defaultPadding,
2444         totalWidth - 2 * defaultHPadding,
2445         value,
2446         font,
2447         lineCount
2448       );
2449 
2450       this.data.defaultAppearanceData = savedDefaultAppearance;
2451     } else {
2452       if (!this._isOffscreenCanvasSupported) {
2453         warn(
2454           "_getAppearance: OffscreenCanvas is not supported, annotation may not render correctly."
2455         );
2456       }
2457 
2458       [defaultAppearance, fontSize, lineHeight] = this._computeFontSize(
2459         totalHeight - 2 * defaultPadding,
2460         totalWidth - 2 * defaultHPadding,
2461         value,
2462         font,
2463         lineCount
2464       );
2465     }
2466 
2467     let descent = font.descent;
2468     if (isNaN(descent)) {
2469       descent = BASELINE_FACTOR * lineHeight;
2470     } else {
2471       descent = Math.max(
2472         BASELINE_FACTOR * lineHeight,
2473         Math.abs(descent) * fontSize
2474       );
2475     }
2476 
2477     // Take into account the space we have to compute the default vertical
2478     // padding.
2479     const defaultVPadding = Math.min(
2480       Math.floor((totalHeight - fontSize) / 2),
2481       defaultPadding
2482     );
2483     const alignment = this.data.textAlignment;
2484 
2485     if (this.data.multiLine) {
2486       return this._getMultilineAppearance(
2487         defaultAppearance,
2488         encodedLines,
2489         font,
2490         fontSize,
2491         totalWidth,
2492         totalHeight,
2493         alignment,
2494         defaultHPadding,
2495         defaultVPadding,
2496         descent,
2497         lineHeight,
2498         annotationStorage
2499       );
2500     }
2501 
2502     if (this.data.comb) {
2503       return this._getCombAppearance(
2504         defaultAppearance,
2505         font,
2506         encodedLines[0],
2507         fontSize,
2508         totalWidth,
2509         totalHeight,
2510         defaultHPadding,
2511         defaultVPadding,
2512         descent,
2513         lineHeight,
2514         annotationStorage
2515       );
2516     }
2517 
2518     const bottomPadding = defaultVPadding + descent;
2519     if (alignment === 0 || alignment > 2) {
2520       // Left alignment: nothing to do
2521       return (
2522         `/Tx BMC q ${colors}BT ` +
2523         defaultAppearance +
2524         ` 1 0 0 1 ${numberToString(defaultHPadding)} ${numberToString(
2525           bottomPadding
2526         )} Tm (${escapeString(encodedLines[0])}) Tj` +
2527         " ET Q EMC"
2528       );
2529     }
2530 
2531     const prevInfo = { shift: 0 };
2532     const renderedText = this._renderText(
2533       encodedLines[0],
2534       font,
2535       fontSize,
2536       totalWidth,
2537       alignment,
2538       prevInfo,
2539       defaultHPadding,
2540       bottomPadding
2541     );
2542     return (
2543       `/Tx BMC q ${colors}BT ` +
2544       defaultAppearance +
2545       ` 1 0 0 1 0 0 Tm ${renderedText}` +
2546       " ET Q EMC"
2547     );
2548   }
2549 
2741 }
2742 
4307 class PolylineAnnotation extends MarkupAnnotation {
4308   constructor(params) {
4309     super(params);
4310 
4311     const { dict, xref } = params;
4312     this.data.annotationType = AnnotationType.POLYLINE;
4313     this.data.hasOwnCanvas = this.data.noRotate;
4314     this.data.noHTML = false;
4315     this.data.vertices = null;
4316 
4317     if (
4318       (typeof PDFJSDev === "undefined" || !PDFJSDev.test("MOZCENTRAL")) &&
4319       !(this instanceof PolygonAnnotation)
4320     ) {
4321       // Only meaningful for polyline annotations.
4322       this.setLineEndings(dict.getArray("LE"));
4323       this.data.lineEndings = this.lineEndings;
4324     }
4325 
4326     // The vertices array is an array of numbers representing the alternating
4327     // horizontal and vertical coordinates, respectively, of each vertex.
4328     // Convert this to an array of objects with x and y coordinates.
4329     const rawVertices = dict.getArray("Vertices");
4330     if (!isNumberArray(rawVertices, null)) {
4331       return;
4332     }
4333     const vertices = (this.data.vertices = Float32Array.from(rawVertices));
4334 
4335     if (!this.appearance) {
4336       // The default stroke color is black.
4337       const strokeColor = this.color ? getPdfColorArray(this.color) : [0, 0, 0];
4338       const strokeAlpha = dict.get("CA");
4339 
4340       const borderWidth = this.borderStyle.width || 1,
4341         borderAdjust = 2 * borderWidth;
4342 
4343       // If the /Rect-entry is empty/wrong, create a fallback rectangle so that
4344       // we get similar rendering/highlighting behaviour as in Adobe Reader.
4345       const bbox = [Infinity, Infinity, -Infinity, -Infinity];
4346       for (let i = 0, ii = vertices.length; i < ii; i += 2) {
4347         Util.rectBoundingBox(
4348           vertices[i] - borderAdjust,
4349           vertices[i + 1] - borderAdjust,
4350           vertices[i] + borderAdjust,
4351           vertices[i + 1] + borderAdjust,
4352           bbox
4353         );
4354       }
4355       if (!Util.intersect(this.rectangle, bbox)) {
4356         this.rectangle = bbox;
4357       }
4358 
4359       this._setDefaultAppearance({
4360         xref,
4361         extra: `${borderWidth} w`,
4362         strokeColor,
4363         strokeAlpha,
4364         pointsCallback: (buffer, points) => {
4365           for (let i = 0, ii = vertices.length; i < ii; i += 2) {
4366             buffer.push(
4367               `${vertices[i]} ${vertices[i + 1]} ${i === 0 ? "m" : "l"}`
4368             );
4369           }
4370           buffer.push("S");
4371           return [points[0], points[7], points[2], points[3]];
4372         },
4373       });
4374     }
4375   }
4376 }
4377 
5190 
</code>

Test file:
<test_file>
File:
test/unit/annotation_spec.js
/* Copyright 2017 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import {
  Annotation,
  AnnotationBorderStyle,
  AnnotationFactory,
  getQuadPoints,
  MarkupAnnotation,
} from "../../src/core/annotation.js";
import {
  AnnotationBorderStyleType,
  AnnotationEditorType,
  AnnotationFieldFlag,
  AnnotationFlag,
  AnnotationType,
  DrawOPS,
  OPS,
  RenderingIntentFlag,
  stringToBytes,
  stringToUTF8String,
} from "../../src/shared/util.js";
import {
  CMAP_URL,
  createIdFactory,
  DefaultCMapReaderFactory,
  DefaultStandardFontDataFactory,
  STANDARD_FONT_DATA_URL,
  XRefMock,
} from "./test_utils.js";
import { Dict, Name, Ref, RefSetCache } from "../../src/core/primitives.js";
import { Lexer, Parser } from "../../src/core/parser.js";
import { FlateStream } from "../../src/core/flate_stream.js";
import { PartialEvaluator } from "../../src/core/evaluator.js";
import { StringStream } from "../../src/core/stream.js";
import { WorkerTask } from "../../src/core/worker.js";
import { writeChanges } from "../../src/core/writer.js";
</test_file>

Your task:
You are a software tester at pdf.js.
1. Examine the existing test file. You may reuse any imports, helpers or setup blocks it already has.
2. Write exactly one javascript test `it("...", async () => {...})` block.
3. Your test must fail on the code before the patch, and pass after, hence the test will verify that the patch resolves the issue.
4. The test must be self-contained and to-the-point.
5. If you need something new use only the provided imports (respect the paths exactly how they are given) by importing dynamically for compatibility with Node.js — no new dependencies. You can use the PDF file for testing as follows:
const { getDocument } = await import('../../src/display/api.js');
const { buildGetDocumentParams } = await import('./test_utils.js');
const loadingTask = getDocument(buildGetDocumentParams('issue20062.pdf'))
6. Return only the javascript code for the new `it(...)` block (no comments or explanations).

Example structure:
it("should <describe behavior>", async () => {
  const { example } = await import("../../src/core/example.js");
  <initialize required variables>;
  <define expected variable>;
  <generate actual variables>;
  <compare expected with actual>;
});

