Before you begin:
- Keep going until the job is completely solved — don’t stop halfway.
- If you’re unsure about the behavior, reread the provided patch carefully; do not hallucinate.
- Plan your approach before writing code by reflecting on whether the test truly fails before and passes after.

Issue:
<issue>
Added SVG images cannot be resized horizontally/vertically in pdf.js
</issue>

Patch:
<patch>
diff --git a/src/display/editor/tools.js b/src/display/editor/tools.js
--- a/src/display/editor/tools.js
+++ b/src/display/editor/tools.js
@@ -75,7 +75,7 @@ class ImageManager {
 
   #cache = null;
 
-  static _checkIfSVGFitsInCanvas() {
+  static get _isSVGFittingCanvas() {
     // By default, Firefox doesn't rescale without preserving the aspect ratio
     // when drawing an SVG image on a canvas, see https://bugzilla.mozilla.org/1547776.
     // The "workaround" is to append "svgView(preserveAspectRatio(none))" to the
@@ -91,7 +91,7 @@ class ImageManager {
       return new Uint32Array(ctx.getImageData(0, 0, 1, 1).data.buffer)[0] === 0;
     });
 
-    return shadow(this, "_checkIfSVGFitsInCanvas", promise);
+    return shadow(this, "_isSVGFittingCanvas", promise);
   }
 
   async #get(key, rawData) {
@@ -128,8 +128,7 @@ class ImageManager {
       if (image.type === "image/svg+xml") {
         // Unfortunately, createImageBitmap doesn't work with SVG images.
         // (see https://bugzilla.mozilla.org/1841972).
-        const mustRemoveAspectRatioPromise =
-          ImageManager._checkIfSVGFitsInCanvas();
+        const mustRemoveAspectRatioPromise = ImageManager._isSVGFittingCanvas;
         const fileReader = new FileReader();
         const imageElement = new Image();
         const imagePromise = new Promise((resolve, reject) => {


</patch>

Imports:
<imports>
Available Packages
Dev Dependencies:
- @babel/core: ^7.22.9
- @babel/plugin-transform-modules-commonjs: ^7.22.5
- @babel/preset-env: ^7.22.9
- @babel/runtime: ^7.22.6
- @javascript-obfuscator/escodegen: 2.3.0
- acorn: ^8.10.0
- autoprefixer: ^10.4.14
- babel-loader: ^9.1.3
- caniuse-lite: ^1.0.30001517
- canvas: ^2.11.2
- core-js: ^3.31.1
- cross-env: ^7.0.3
- es-module-shims: 1.4.7
- eslint: ^8.45.0
- eslint-config-prettier: ^8.8.0
- eslint-plugin-fetch-options: ^0.0.5
- eslint-plugin-html: ^7.1.0
- eslint-plugin-import: ^2.27.5
- eslint-plugin-json: ^3.1.0
- eslint-plugin-mozilla: ^3.1.0
- eslint-plugin-no-unsanitized: ^4.0.2
- eslint-plugin-prettier: ^5.0.0
- eslint-plugin-sort-exports: ^0.8.0
- eslint-plugin-unicorn: ^48.0.0
- globals: ^13.20.0
- gulp: ^4.0.2
- gulp-postcss: ^9.0.1
- gulp-rename: ^2.0.0
- gulp-replace: ^1.1.4
- gulp-zip: ^5.1.0
- jasmine: ^5.1.0
- jsdoc: ^4.0.2
- jstransformer-markdown-it: ^3.0.0
- merge-stream: ^2.0.0
- mkdirp: ^3.0.1
- needle: ^3.2.0
- path2d-polyfill: ^2.0.1
- pngjs: ^7.0.0
- postcss: ^8.4.27
- postcss-dir-pseudo-class: ^8.0.0
- prettier: ^3.0.0
- puppeteer: ^20.9.0
- rimraf: ^3.0.2
- streamqueue: ^1.1.2
- stylelint: ^15.10.2
- stylelint-prettier: ^4.0.0
- terser: ^5.19.2
- through2: ^4.0.2
- ttest: ^4.0.0
- typescript: ^5.1.6
- typogr: ^0.6.8
- vinyl: ^3.0.0
- webpack: ^5.88.2
- webpack-stream: ^7.0.0
- wintersmith: ^2.5.0
- yargs: ^17.7.2

Engines:
- node: >=18

Available Relative Imports:
- `../../src/core/annotation.js`: Annotation, AnnotationBorderStyle, AnnotationFactory, MarkupAnnotation, getQuadPoints
- `../../src/core/bidi.js`: bidi
- `../../src/core/cff_parser.js`: CFFCharset, CFFCompiler, CFFFDSelect, CFFParser, CFFStrings
- `../../src/core/cmap.js`: CMap, CMapFactory, IdentityCMap
- `../../src/core/colorspace.js`: ColorSpace
- `../../src/core/core_utils.js`: arrayBuffersToBytes, encodeToXmlString, escapePDFName, escapeString, getInheritableProperty, isAscii, isWhiteSpace, log2, numberToString, parseXFAPath, recoverJsURL, stringToUTF16HexString, stringToUTF16String, toRomanNumerals, validateCSSFont
- `../../src/core/crypto.js`: AES128Cipher, AES256Cipher, ARCFourCipher, CipherTransformFactory, PDF17, PDF20, calculateMD5, calculateSHA256, calculateSHA384, calculateSHA512
- `../../src/core/default_appearance.js`: createDefaultAppearance, parseAppearanceStream, parseDefaultAppearance
- `../../src/core/document.js`: PDFDocument, Page
- `../../src/core/encodings.js`: getEncoding
- `../../src/core/evaluator.js`: PartialEvaluator
- `../../src/core/font_substitutions.js`: getFontSubstitution
- `../../src/core/fonts_utils.js`: SEAC_ANALYSIS_ENABLED
- `../../src/core/function.js`: PDFFunctionFactory, PostScriptCompiler, PostScriptEvaluator
- `../../src/core/glyphlist.js`: getDingbatsGlyphsUnicode, getGlyphsUnicode
- `../../src/core/image_utils.js`: GlobalImageCache, LocalColorSpaceCache
- `../../src/core/jbig2.js`: Jbig2Image
- `../../src/core/jpg.js`: JpegImage
- `../../src/core/jpx.js`: JpxImage
- `../../src/core/metadata_parser.js`: MetadataParser
- `../../src/core/operator_list.js`: OperatorList
- `../../src/core/parser.js`: Lexer, Linearization, Parser
- `../../src/core/predictor_stream.js`: PredictorStream
- `../../src/core/primitives.js`: Cmd, Dict, EOF, Name, Ref, RefSet, RefSetCache, isCmd, isDict, isName, isRefsEqual
- `../../src/core/ps_parser.js`: PostScriptLexer, PostScriptParser
- `../../src/core/stream.js`: NullStream, Stream, StringStream
- `../../src/core/type1_parser.js`: Type1Parser
- `../../src/core/unicode.js`: getCharUnicodeCategory, getUnicodeForGlyph, getUnicodeRangeFor, mapSpecialUnicodeValues
- `../../src/core/worker.js`: WorkerMessageHandler, WorkerTask
- `../../src/core/writer.js`: incrementalUpdate, writeDict
- `../../src/core/xfa/bind.js`: Binder
- `../../src/core/xfa/data.js`: DataHandler
- `../../src/core/xfa/factory.js`: XFAFactory
- `../../src/core/xfa/formcalc_lexer.js`: Lexer, TOKEN, Token
- `../../src/core/xfa/formcalc_parser.js`: Errors, Parser
- `../../src/core/xfa/parser.js`: XFAParser
- `../../src/core/xfa/som.js`: searchNode
- `../../src/core/xfa/symbol_utils.js`: $dump, $getChildren, $getChildrenByClass, $getChildrenByName, $text, $uid
- `../../src/core/xml_parser.js`: SimpleXMLParser, XMLParserBase
- `../../src/display/annotation_layer.js`: AnnotationLayer
- `../../src/display/annotation_storage.js`: AnnotationStorage
- `../../src/display/api.js`: DefaultCMapReaderFactory, DefaultCanvasFactory, DefaultStandardFontDataFactory, LoopbackPort, PDFDataRangeTransport, PDFDocumentLoadingTask, PDFDocumentProxy, PDFPageProxy, PDFWorker, PDFWorkerUtil, RenderTask, SVGGraphics, build, getDocument, version
- `../../src/display/display_utils.js`: DOMCanvasFactory, DOMSVGFactory, PDFDateString, PageViewport, PixelsPerInch, RenderingCancelledException, StatTimer, getFilenameFromUrl, getPdfFilenameFromUrl, getXfaPageViewport, isDataScheme, isPdfFile, isValidFetchUrl, loadScript, setLayerDimensions
- `../../src/display/editor/annotation_editor_layer.js`: AnnotationEditorLayer
- `../../src/display/editor/tools.js`: AnnotationEditorUIManager, CommandManager
- `../../src/display/fetch_stream.js`: PDFFetchStream
- `../../src/display/metadata.js`: Metadata
- `../../src/display/network.js`: PDFNetworkStream
- `../../src/display/network_utils.js`: createResponseStatusError, extractFilenameFromHeader, validateRangeRequestCapabilities, validateResponseStatus
- `../../src/display/node_stream.js`: PDFNodeStream
- `../../src/display/svg.js`: SVGGraphics
- `../../src/display/text_layer.js`: TextLayerRenderTask, renderTextLayer, updateTextLayer
- `../../src/display/worker_options.js`: GlobalWorkerOptions
- `../../src/display/xfa_layer.js`: XfaLayer
- `../../src/shared/message_handler.js`: MessageHandler
- `../../src/shared/murmurhash3.js`: MurmurHash3_64
- `../../src/shared/util.js`: AbortException, AnnotationBorderStyleType, AnnotationEditorParamsType, AnnotationEditorType, AnnotationFieldFlag, AnnotationFlag, AnnotationMode, AnnotationType, CMapCompressionType, FeatureTest, FormatError, ImageKind, InvalidPDFException, MissingPDFException, OPS, PasswordException, PasswordResponses, PermissionFlag, PromiseCapability, RenderingIntentFlag, UnexpectedResponseException, UnknownErrorException, Util, VerbosityLevel, bytesToString, createValidAbsoluteUrl, getModificationDate, getVerbosityLevel, isArrayBuffer, isNodeJS, normalizeUnicode, objectSize, setVerbosityLevel, shadow, string32, stringToBytes, stringToPDFString, stringToUTF8String
- `../../web/annotation_layer_builder.js`: AnnotationLayerBuilder
- `../../web/download_manager.js`: DownloadManager
- `../../web/event_utils.js`: EventBus, WaitOnType, waitOnEventOrTimeout
- `../../web/genericl10n.js`: GenericL10n
- `../../web/l10n_utils.js`: NullL10n
- `../../web/pdf_find_controller.js`: FindState, PDFFindController
- `../../web/pdf_find_utils.js`: CharacterType, getCharacterType
- `../../web/pdf_history.js`: PDFHistory, isDestArraysEqual, isDestHashesEqual
- `../../web/pdf_link_service.js`: LinkTarget, PDFLinkService, SimpleLinkService
- `../../web/pdf_page_view.js`: PDFPageView
- `../../web/pdf_scripting_manager.component.js`: PDFScriptingManager
- `../../web/pdf_single_page_viewer.js`: PDFSinglePageViewer
- `../../web/pdf_viewer.js`: PDFPageViewBuffer, PDFViewer
- `../../web/struct_tree_layer_builder.js`: StructTreeLayerBuilder
- `../../web/text_layer_builder.js`: TextLayerBuilder
- `../../web/ui_utils.js`: AutoPrintRegExp, ProgressBar, RenderingStates, ScrollMode, SpreadMode, backtrackBeforeAllVisibleElements, binarySearchFirstItem, getPageSizeInches, getVisibleElements, isPortraitOrientation, isValidRotation, parseQueryString, removeNullCharacters
- `../../web/xfa_layer_builder.js`: XfaLayerBuilder
- `./test_utils.js`: CMAP_URL, DefaultFileReaderFactory, STANDARD_FONT_DATA_URL, TEST_PDFS_PATH, XRefMock, buildGetDocumentParams, createIdFactory
- `./testreporter.js`: TestReporter
</imports>

Code:
<code>
File:
src/display/editor/tools.js
1 /* Copyright 2022 Mozilla Foundation
2  *
3  * Licensed under the Apache License, Version 2.0 (the "License");
4  * you may not use this file except in compliance with the License.
5  * You may obtain a copy of the License at
6  *
7  *     http://www.apache.org/licenses/LICENSE-2.0
8  *
9  * Unless required by applicable law or agreed to in writing, software
10  * distributed under the License is distributed on an "AS IS" BASIS,
11  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
12  * See the License for the specific language governing permissions and
13  * limitations under the License.
14  */
15 
16 /** @typedef {import("./editor.js").AnnotationEditor} AnnotationEditor */
17 // eslint-disable-next-line max-len
18 /** @typedef {import("./annotation_editor_layer.js").AnnotationEditorLayer} AnnotationEditorLayer */
19 
20 import {
21   AnnotationEditorPrefix,
22   AnnotationEditorType,
23   FeatureTest,
24   getUuid,
25   shadow,
26   Util,
27   warn,
28 } from "../../shared/util.js";
29 import { getColorValues, getRGB, PixelsPerInch } from "../display_utils.js";
30 
31 function bindEvents(obj, element, names) {
32   for (const name of names) {
33     element.addEventListener(name, obj[name].bind(obj));
34   }
35 }
36 
37 /**
38  * Convert a number between 0 and 100 into an hex number between 0 and 255.
39  * @param {number} opacity
40  * @return {string}
41  */
42 function opacityToHex(opacity) {
43   return Math.round(Math.min(255, Math.max(1, 255 * opacity)))
44     .toString(16)
45     .padStart(2, "0");
46 }
47 
48 /**
49  * Class to create some unique ids for the different editors.
50  */
51 class IdManager {
52   #id = 0;
53 
54   /**
55    * Get a unique id.
56    * @returns {string}
57    */
58   getId() {
59     return `${AnnotationEditorPrefix}${this.#id++}`;
60   }
61 }
62 
63 /**
64  * Class to manage the images used by the editors.
65  * The main idea is to try to minimize the memory used by the images.
66  * The images are cached and reused when possible
67  * We use a refCounter to know when an image is not used anymore but we need to
68  * be able to restore an image after a remove+undo, so we keep a file reference
69  * or an url one.
70  */
71 class ImageManager {
72   #baseId = getUuid();
73 
74   #id = 0;
75 
76   #cache = null;
77 
78   static _checkIfSVGFitsInCanvas() {
79     // By default, Firefox doesn't rescale without preserving the aspect ratio
80     // when drawing an SVG image on a canvas, see https://bugzilla.mozilla.org/1547776.
81     // The "workaround" is to append "svgView(preserveAspectRatio(none))" to the
82     // url, but according to comment #15, it seems that it leads to unexpected
83     // behavior in Safari.
84     const svg = `data:image/svg+xml;charset=UTF-8,<svg viewBox="0 0 1 1" width="1" height="1" xmlns="http://www.w3.org/2000/svg"><rect width="1" height="1" style="fill:red;"/></svg>`;
85     const canvas = new OffscreenCanvas(1, 3);
86     const ctx = canvas.getContext("2d");
87     const image = new Image();
88     image.src = svg;
89     const promise = image.decode().then(() => {
90       ctx.drawImage(image, 0, 0, 1, 1, 0, 0, 1, 3);
91       return new Uint32Array(ctx.getImageData(0, 0, 1, 1).data.buffer)[0] === 0;
92     });
93 
94     return shadow(this, "_checkIfSVGFitsInCanvas", promise);
95   }
96 
97   async #get(key, rawData) {
98     this.#cache ||= new Map();
99     let data = this.#cache.get(key);
100     if (data === null) {
101       // We already tried to load the image but it failed.
102       return null;
103     }
104     if (data?.bitmap) {
105       data.refCounter += 1;
106       return data;
107     }
108     try {
109       data ||= {
110         bitmap: null,
111         id: `image_${this.#baseId}_${this.#id++}`,
112         refCounter: 0,
113         isSvg: false,
114       };
115       let image;
116       if (typeof rawData === "string") {
117         data.url = rawData;
118 
119         const response = await fetch(rawData);
120         if (!response.ok) {
121           throw new Error(response.statusText);
122         }
123         image = await response.blob();
124       } else {
125         image = data.file = rawData;
126       }
127 
128       if (image.type === "image/svg+xml") {
129         // Unfortunately, createImageBitmap doesn't work with SVG images.
130         // (see https://bugzilla.mozilla.org/1841972).
131         const mustRemoveAspectRatioPromise =
132           ImageManager._checkIfSVGFitsInCanvas();
133         const fileReader = new FileReader();
134         const imageElement = new Image();
135         const imagePromise = new Promise((resolve, reject) => {
136           imageElement.onload = () => {
137             data.bitmap = imageElement;
138             data.isSvg = true;
139             resolve();
140           };
141           fileReader.onload = async () => {
142             const url = (data.svgUrl = fileReader.result);
143             // We need to set the preserveAspectRatio to none in order to let
144             // the image fits the canvas when resizing.
145             imageElement.src = (await mustRemoveAspectRatioPromise)
146               ? `${url}#svgView(preserveAspectRatio(none))`
147               : url;
148           };
149           imageElement.onerror = fileReader.onerror = reject;
150         });
151         fileReader.readAsDataURL(image);
152         await imagePromise;
153       } else {
154         data.bitmap = await createImageBitmap(image);
155       }
156       data.refCounter = 1;
157     } catch (e) {
158       console.error(e);
159       data = null;
160     }
161     this.#cache.set(key, data);
162     if (data) {
163       this.#cache.set(data.id, data);
164     }
165     return data;
166   }
167 
168   async getFromFile(file) {
169     const { lastModified, name, size, type } = file;
170     return this.#get(`${lastModified}_${name}_${size}_${type}`, file);
171   }
172 
173   async getFromUrl(url) {
174     return this.#get(url, url);
175   }
176 
177   async getFromId(id) {
178     this.#cache ||= new Map();
179     const data = this.#cache.get(id);
180     if (!data) {
181       return null;
182     }
183     if (data.bitmap) {
184       data.refCounter += 1;
185       return data;
186     }
187 
188     if (data.file) {
189       return this.getFromFile(data.file);
190     }
191     return this.getFromUrl(data.url);
192   }
193 
194   getSvgUrl(id) {
195     const data = this.#cache.get(id);
196     if (!data?.isSvg) {
197       return null;
198     }
199     return data.svgUrl;
200   }
201 
202   deleteId(id) {
203     this.#cache ||= new Map();
204     const data = this.#cache.get(id);
205     if (!data) {
206       return;
207     }
208     data.refCounter -= 1;
209     if (data.refCounter !== 0) {
210       return;
211     }
212     data.bitmap = null;
213   }
214 
215   // We can use the id only if it belongs this manager.
216   // We must take care of having the right manager because we can copy/paste
217   // some images from other documents, hence it'd be a pity to use an id from an
218   // other manager.
219   isValidId(id) {
220     return id.startsWith(`image_${this.#baseId}_`);
221   }
222 }
223 
224 /**
225  * Class to handle undo/redo.
226  * Commands are just saved in a buffer.
227  * If we hit some memory issues we could likely use a circular buffer.
228  * It has to be used as a singleton.
229  */
230 class CommandManager {
231   #commands = [];
232 
233   #locked = false;
234 
235   #maxSize;
236 
237   #position = -1;
238 
239   constructor(maxSize = 128) {
240     this.#maxSize = maxSize;
241   }
242 
243   /**
244    * @typedef {Object} addOptions
245    * @property {function} cmd
246    * @property {function} undo
247    * @property {boolean} mustExec
248    * @property {number} type
249    * @property {boolean} overwriteIfSameType
250    * @property {boolean} keepUndo
251    */
252 
253   /**
254    * Add a new couple of commands to be used in case of redo/undo.
255    * @param {addOptions} options
256    */
257   add({
258     cmd,
259     undo,
260     mustExec,
261     type = NaN,
262     overwriteIfSameType = false,
263     keepUndo = false,
264   }) {
265     if (mustExec) {
266       cmd();
267     }
268 
269     if (this.#locked) {
270       return;
271     }
272 
273     const save = { cmd, undo, type };
274     if (this.#position === -1) {
275       if (this.#commands.length > 0) {
276         // All the commands have been undone and then a new one is added
277         // hence we clear the queue.
278         this.#commands.length = 0;
279       }
280       this.#position = 0;
281       this.#commands.push(save);
282       return;
283     }
284 
285     if (overwriteIfSameType && this.#commands[this.#position].type === type) {
286       // For example when we change a color we don't want to
287       // be able to undo all the steps, hence we only want to
288       // keep the last undoable action in this sequence of actions.
289       if (keepUndo) {
290         save.undo = this.#commands[this.#position].undo;
291       }
292       this.#commands[this.#position] = save;
293       return;
294     }
295 
296     const next = this.#position + 1;
297     if (next === this.#maxSize) {
298       this.#commands.splice(0, 1);
299     } else {
300       this.#position = next;
301       if (next < this.#commands.length) {
302         this.#commands.splice(next);
303       }
304     }
305 
306     this.#commands.push(save);
307   }
308 
309   stopUndoAccumulation() {
310     if (this.#position !== -1) {
311       this.#commands[this.#position].type = NaN;
312     }
313   }
314 
315   /**
316    * Undo the last command.
317    */
318   undo() {
319     if (this.#position === -1) {
320       // Nothing to undo.
321       return;
322     }
323 
324     // Avoid to insert something during the undo execution.
325     this.#locked = true;
326     this.#commands[this.#position].undo();
327     this.#locked = false;
328 
329     this.#position -= 1;
330   }
331 
332   /**
333    * Redo the last command.
334    */
335   redo() {
336     if (this.#position < this.#commands.length - 1) {
337       this.#position += 1;
338 
339       // Avoid to insert something during the redo execution.
340       this.#locked = true;
341       this.#commands[this.#position].cmd();
342       this.#locked = false;
343     }
344   }
345 
346   /**
347    * Check if there is something to undo.
348    * @returns {boolean}
349    */
350   hasSomethingToUndo() {
351     return this.#position !== -1;
352   }
353 
354   /**
355    * Check if there is something to redo.
356    * @returns {boolean}
357    */
358   hasSomethingToRedo() {
359     return this.#position < this.#commands.length - 1;
360   }
361 
362   destroy() {
363     this.#commands = null;
364   }
365 }
366 
367 /**
368  * Class to handle the different keyboards shortcuts we can have on mac or
369  * non-mac OSes.
370  */
371 class KeyboardManager {
372   /**
373    * Create a new keyboard manager class.
374    * @param {Array<Array>} callbacks - an array containing an array of shortcuts
375    * and a callback to call.
376    * A shortcut is a string like `ctrl+c` or `mac+ctrl+c` for mac OS.
377    */
378   constructor(callbacks) {
379     this.buffer = [];
380     this.callbacks = new Map();
381     this.allKeys = new Set();
382 
383     const { isMac } = FeatureTest.platform;
384     for (const [keys, callback, options = {}] of callbacks) {
385       for (const key of keys) {
386         const isMacKey = key.startsWith("mac+");
387         if (isMac && isMacKey) {
388           this.callbacks.set(key.slice(4), { callback, options });
389           this.allKeys.add(key.split("+").at(-1));
390         } else if (!isMac && !isMacKey) {
391           this.callbacks.set(key, { callback, options });
392           this.allKeys.add(key.split("+").at(-1));
393         }
394       }
395     }
396   }
397 
398   /**
399    * Serialize an event into a string in order to match a
400    * potential key for a callback.
401    * @param {KeyboardEvent} event
402    * @returns {string}
403    */
404   #serialize(event) {
405     if (event.altKey) {
406       this.buffer.push("alt");
407     }
408     if (event.ctrlKey) {
409       this.buffer.push("ctrl");
410     }
411     if (event.metaKey) {
412       this.buffer.push("meta");
413     }
414     if (event.shiftKey) {
415       this.buffer.push("shift");
416     }
417     this.buffer.push(event.key);
418     const str = this.buffer.join("+");
419     this.buffer.length = 0;
420 
421     return str;
422   }
423 
424   /**
425    * Execute a callback, if any, for a given keyboard event.
426    * The self is used as `this` in the callback.
427    * @param {Object} self.
428    * @param {KeyboardEvent} event
429    * @returns
430    */
431   exec(self, event) {
432     if (!this.allKeys.has(event.key)) {
433       return;
434     }
435     const info = this.callbacks.get(this.#serialize(event));
436     if (!info) {
437       return;
438     }
439     const {
440       callback,
441       options: { bubbles = false, args = [], checker = null },
442     } = info;
443 
444     if (checker && !checker(self, event)) {
445       return;
446     }
447     callback.bind(self, ...args)();
448 
449     // For example, ctrl+s in a FreeText must be handled by the viewer, hence
450     // the event must bubble.
451     if (!bubbles) {
452       event.stopPropagation();
453       event.preventDefault();
454     }
455   }
456 }
457 
458 class ColorManager {
459   static _colorsMapping = new Map([
460     ["CanvasText", [0, 0, 0]],
461     ["Canvas", [255, 255, 255]],
462   ]);
463 
464   get _colors() {
465     if (
466       typeof PDFJSDev !== "undefined" &&
467       PDFJSDev.test("LIB") &&
468       typeof document === "undefined"
469     ) {
470       return shadow(this, "_colors", ColorManager._colorsMapping);
471     }
472 
473     const colors = new Map([
474       ["CanvasText", null],
475       ["Canvas", null],
476     ]);
477     getColorValues(colors);
478     return shadow(this, "_colors", colors);
479   }
480 
481   /**
482    * In High Contrast Mode, the color on the screen is not always the
483    * real color used in the pdf.
484    * For example in some cases white can appear to be black but when saving
485    * we want to have white.
486    * @param {string} color
487    * @returns {Array<number>}
488    */
489   convert(color) {
490     const rgb = getRGB(color);
491     if (!window.matchMedia("(forced-colors: active)").matches) {
492       return rgb;
493     }
494 
495     for (const [name, RGB] of this._colors) {
496       if (RGB.every((x, i) => x === rgb[i])) {
497         return ColorManager._colorsMapping.get(name);
498       }
499     }
500     return rgb;
501   }
502 
503   /**
504    * An input element must have its color value as a hex string
505    * and not as color name.
506    * So this function converts a name into an hex string.
507    * @param {string} name
508    * @returns {string}
509    */
510   getHexCode(name) {
511     const rgb = this._colors.get(name);
512     if (!rgb) {
513       return name;
514     }
515     return Util.makeHexColor(...rgb);
516   }
517 }
518 
519 /**
520  * A pdf has several pages and each of them when it will rendered
521  * will have an AnnotationEditorLayer which will contain the some
522  * new Annotations associated to an editor in order to modify them.
523  *
524  * This class is used to manage all the different layers, editors and
525  * some action like copy/paste, undo/redo, ...
526  */
527 class AnnotationEditorUIManager {
528   #activeEditor = null;
529 
530   #allEditors = new Map();
531 
532   #allLayers = new Map();
533 
534   #annotationStorage = null;
535 
536   #commandManager = new CommandManager();
537 
538   #currentPageIndex = 0;
539 
540   #deletedAnnotationsElementIds = new Set();
541 
542   #editorTypes = null;
543 
544   #editorsToRescale = new Set();
545 
546   #eventBus = null;
547 
548   #filterFactory = null;
549 
550   #idManager = new IdManager();
551 
552   #isEnabled = false;
553 
554   #mode = AnnotationEditorType.NONE;
555 
556   #selectedEditors = new Set();
557 
558   #pageColors = null;
559 
560   #boundCopy = this.copy.bind(this);
561 
562   #boundCut = this.cut.bind(this);
563 
564   #boundPaste = this.paste.bind(this);
565 
566   #boundKeydown = this.keydown.bind(this);
567 
568   #boundOnEditingAction = this.onEditingAction.bind(this);
569 
570   #boundOnPageChanging = this.onPageChanging.bind(this);
571 
572   #boundOnScaleChanging = this.onScaleChanging.bind(this);
573 
574   #boundOnRotationChanging = this.onRotationChanging.bind(this);
575 
576   #previousStates = {
577     isEditing: false,
578     isEmpty: true,
579     hasSomethingToUndo: false,
580     hasSomethingToRedo: false,
581     hasSelectedEditor: false,
582   };
583 
584   #translation = [0, 0];
585 
586   #translationTimeoutId = null;
587 
588   #container = null;
589 
590   static TRANSLATE_SMALL = 1; // page units.
591 
592   static TRANSLATE_BIG = 10; // page units.
593 
594   static get _keyboardManager() {
595     const proto = AnnotationEditorUIManager.prototype;
596 
597     const arrowChecker = self => {
598       // If the focused element is an input, we don't want to handle the arrow.
599       // For example, sliders can be controlled with the arrow keys.
600       const { activeElement } = document;
601       return (
602         activeElement &&
603         self.#container.contains(activeElement) &&
604         self.hasSomethingToControl()
605       );
606     };
607 
608     const small = this.TRANSLATE_SMALL;
609     const big = this.TRANSLATE_BIG;
610 
611     return shadow(
612       this,
613       "_keyboardManager",
614       new KeyboardManager([
615         [["ctrl+a", "mac+meta+a"], proto.selectAll],
616         [["ctrl+z", "mac+meta+z"], proto.undo],
617         [
618           // On mac, depending of the OS version, the event.key is either "z" or
619           // "Z" when the user presses "meta+shift+z".
620           [
621             "ctrl+y",
622             "ctrl+shift+z",
623             "mac+meta+shift+z",
624             "ctrl+shift+Z",
625             "mac+meta+shift+Z",
626           ],
627           proto.redo,
628         ],
629         [
630           [
631             "Backspace",
632             "alt+Backspace",
633             "ctrl+Backspace",
634             "shift+Backspace",
635             "mac+Backspace",
636             "mac+alt+Backspace",
637             "mac+ctrl+Backspace",
638             "Delete",
639             "ctrl+Delete",
640             "shift+Delete",
641             "mac+Delete",
642           ],
643           proto.delete,
644         ],
645         [["Escape", "mac+Escape"], proto.unselectAll],
646         [
647           ["ArrowLeft", "mac+ArrowLeft"],
648           proto.translateSelectedEditors,
649           { args: [-small, 0], checker: arrowChecker },
650         ],
651         [
652           ["ctrl+ArrowLeft", "mac+shift+ArrowLeft"],
653           proto.translateSelectedEditors,
654           { args: [-big, 0], checker: arrowChecker },
655         ],
656         [
657           ["ArrowRight", "mac+ArrowRight"],
658           proto.translateSelectedEditors,
659           { args: [small, 0], checker: arrowChecker },
660         ],
661         [
662           ["ctrl+ArrowRight", "mac+shift+ArrowRight"],
663           proto.translateSelectedEditors,
664           { args: [big, 0], checker: arrowChecker },
665         ],
666         [
667           ["ArrowUp", "mac+ArrowUp"],
668           proto.translateSelectedEditors,
669           { args: [0, -small], checker: arrowChecker },
670         ],
671         [
672           ["ctrl+ArrowUp", "mac+shift+ArrowUp"],
673           proto.translateSelectedEditors,
674           { args: [0, -big], checker: arrowChecker },
675         ],
676         [
677           ["ArrowDown", "mac+ArrowDown"],
678           proto.translateSelectedEditors,
679           { args: [0, small], checker: arrowChecker },
680         ],
681         [
682           ["ctrl+ArrowDown", "mac+shift+ArrowDown"],
683           proto.translateSelectedEditors,
684           { args: [0, big], checker: arrowChecker },
685         ],
686       ])
687     );
688   }
689 
690   constructor(container, eventBus, pdfDocument, pageColors) {
691     this.#container = container;
692     this.#eventBus = eventBus;
693     this.#eventBus._on("editingaction", this.#boundOnEditingAction);
694     this.#eventBus._on("pagechanging", this.#boundOnPageChanging);
695     this.#eventBus._on("scalechanging", this.#boundOnScaleChanging);
696     this.#eventBus._on("rotationchanging", this.#boundOnRotationChanging);
697     this.#annotationStorage = pdfDocument.annotationStorage;
698     this.#filterFactory = pdfDocument.filterFactory;
699     this.#pageColors = pageColors;
700     this.viewParameters = {
701       realScale: PixelsPerInch.PDF_TO_CSS_UNITS,
702       rotation: 0,
703     };
704   }
705 
706   destroy() {
707     this.#removeKeyboardManager();
708     this.#eventBus._off("editingaction", this.#boundOnEditingAction);
709     this.#eventBus._off("pagechanging", this.#boundOnPageChanging);
710     this.#eventBus._off("scalechanging", this.#boundOnScaleChanging);
711     this.#eventBus._off("rotationchanging", this.#boundOnRotationChanging);
712     for (const layer of this.#allLayers.values()) {
713       layer.destroy();
714     }
715     this.#allLayers.clear();
716     this.#allEditors.clear();
717     this.#editorsToRescale.clear();
718     this.#activeEditor = null;
719     this.#selectedEditors.clear();
720     this.#commandManager.destroy();
721   }
722 
723   get hcmFilter() {
724     return shadow(
725       this,
726       "hcmFilter",
727       this.#pageColors
728         ? this.#filterFactory.addHCMFilter(
729             this.#pageColors.foreground,
730             this.#pageColors.background
731           )
732         : "none"
733     );
734   }
735 
736   onPageChanging({ pageNumber }) {
737     this.#currentPageIndex = pageNumber - 1;
738   }
739 
740   focusMainContainer() {
741     this.#container.focus();
742   }
743 
744   addShouldRescale(editor) {
745     this.#editorsToRescale.add(editor);
746   }
747 
748   removeShouldRescale(editor) {
749     this.#editorsToRescale.delete(editor);
750   }
751 
752   onScaleChanging({ scale }) {
753     this.commitOrRemove();
754     this.viewParameters.realScale = scale * PixelsPerInch.PDF_TO_CSS_UNITS;
755     for (const editor of this.#editorsToRescale) {
756       editor.onScaleChanging();
757     }
758   }
759 
760   onRotationChanging({ pagesRotation }) {
761     this.commitOrRemove();
762     this.viewParameters.rotation = pagesRotation;
763   }
764 
765   /**
766    * Add an editor in the annotation storage.
767    * @param {AnnotationEditor} editor
768    */
769   addToAnnotationStorage(editor) {
770     if (
771       !editor.isEmpty() &&
772       this.#annotationStorage &&
773       !this.#annotationStorage.has(editor.id)
774     ) {
775       this.#annotationStorage.setValue(editor.id, editor);
776     }
777   }
778 
779   #addKeyboardManager() {
780     // The keyboard events are caught at the container level in order to be able
781     // to execute some callbacks even if the current page doesn't have focus.
782     window.addEventListener("keydown", this.#boundKeydown, { capture: true });
783   }
784 
785   #removeKeyboardManager() {
786     window.removeEventListener("keydown", this.#boundKeydown, {
787       capture: true,
788     });
789   }
790 
791   #addCopyPasteListeners() {
792     document.addEventListener("copy", this.#boundCopy);
793     document.addEventListener("cut", this.#boundCut);
794     document.addEventListener("paste", this.#boundPaste);
795   }
796 
797   #removeCopyPasteListeners() {
798     document.removeEventListener("copy", this.#boundCopy);
799     document.removeEventListener("cut", this.#boundCut);
800     document.removeEventListener("paste", this.#boundPaste);
801   }
802 
803   /**
804    * Copy callback.
805    * @param {ClipboardEvent} event
806    */
807   copy(event) {
808     event.preventDefault();
809 
810     if (this.#activeEditor) {
811       // An editor is being edited so just commit it.
812       this.#activeEditor.commitOrRemove();
813     }
814 
815     if (!this.hasSelection) {
816       return;
817     }
818 
819     const editors = [];
820     for (const editor of this.#selectedEditors) {
821       const serialized = editor.serialize(/* isForCopying = */ true);
822       if (serialized) {
823         editors.push(serialized);
824       }
825     }
826     if (editors.length === 0) {
827       return;
828     }
829 
830     event.clipboardData.setData("application/pdfjs", JSON.stringify(editors));
831   }
832 
833   /**
834    * Cut callback.
835    * @param {ClipboardEvent} event
836    */
837   cut(event) {
838     this.copy(event);
839     this.delete();
840   }
841 
842   /**
843    * Paste callback.
844    * @param {ClipboardEvent} event
845    */
846   paste(event) {
847     event.preventDefault();
848 
849     let data = event.clipboardData.getData("application/pdfjs");
850     if (!data) {
851       return;
852     }
853 
854     try {
855       data = JSON.parse(data);
856     } catch (ex) {
857       warn(`paste: "${ex.message}".`);
858       return;
859     }
860 
861     if (!Array.isArray(data)) {
862       return;
863     }
864 
865     this.unselectAll();
866     const layer = this.currentLayer;
867 
868     try {
869       const newEditors = [];
870       for (const editor of data) {
871         const deserializedEditor = layer.deserialize(editor);
872         if (!deserializedEditor) {
873           return;
874         }
875         newEditors.push(deserializedEditor);
876       }
877 
878       const cmd = () => {
879         for (const editor of newEditors) {
880           this.#addEditorToLayer(editor);
881         }
882         this.#selectEditors(newEditors);
883       };
884       const undo = () => {
885         for (const editor of newEditors) {
886           editor.remove();
887         }
888       };
889       this.addCommands({ cmd, undo, mustExec: true });
890     } catch (ex) {
891       warn(`paste: "${ex.message}".`);
892     }
893   }
894 
895   /**
896    * Keydown callback.
897    * @param {KeyboardEvent} event
898    */
899   keydown(event) {
900     if (!this.getActive()?.shouldGetKeyboardEvents()) {
901       AnnotationEditorUIManager._keyboardManager.exec(this, event);
902     }
903   }
904 
905   /**
906    * Execute an action for a given name.
907    * For example, the user can click on the "Undo" entry in the context menu
908    * and it'll trigger the undo action.
909    * @param {Object} details
910    */
911   onEditingAction(details) {
912     if (["undo", "redo", "delete", "selectAll"].includes(details.name)) {
913       this[details.name]();
914     }
915   }
916 
917   /**
918    * Update the different possible states of this manager, e.g. is there
919    * something to undo, redo, ...
920    * @param {Object} details
921    */
922   #dispatchUpdateStates(details) {
923     const hasChanged = Object.entries(details).some(
924       ([key, value]) => this.#previousStates[key] !== value
925     );
926 
927     if (hasChanged) {
928       this.#eventBus.dispatch("annotationeditorstateschanged", {
929         source: this,
930         details: Object.assign(this.#previousStates, details),
931       });
932     }
933   }
934 
935   #dispatchUpdateUI(details) {
936     this.#eventBus.dispatch("annotationeditorparamschanged", {
937       source: this,
938       details,
939     });
940   }
941 
942   /**
943    * Set the editing state.
944    * It can be useful to temporarily disable it when the user is editing a
945    * FreeText annotation.
946    * @param {boolean} isEditing
947    */
948   setEditingState(isEditing) {
949     if (isEditing) {
950       this.#addKeyboardManager();
951       this.#addCopyPasteListeners();
952       this.#dispatchUpdateStates({
953         isEditing: this.#mode !== AnnotationEditorType.NONE,
954         isEmpty: this.#isEmpty(),
955         hasSomethingToUndo: this.#commandManager.hasSomethingToUndo(),
956         hasSomethingToRedo: this.#commandManager.hasSomethingToRedo(),
957         hasSelectedEditor: false,
958       });
959     } else {
960       this.#removeKeyboardManager();
961       this.#removeCopyPasteListeners();
962       this.#dispatchUpdateStates({
963         isEditing: false,
964       });
965     }
966   }
967 
968   registerEditorTypes(types) {
969     if (this.#editorTypes) {
970       return;
971     }
972     this.#editorTypes = types;
973     for (const editorType of this.#editorTypes) {
974       this.#dispatchUpdateUI(editorType.defaultPropertiesToUpdate);
975     }
976   }
977 
978   /**
979    * Get an id.
980    * @returns {string}
981    */
982   getId() {
983     return this.#idManager.getId();
984   }
985 
986   get currentLayer() {
987     return this.#allLayers.get(this.#currentPageIndex);
988   }
989 
990   get currentPageIndex() {
991     return this.#currentPageIndex;
992   }
993 
994   /**
995    * Add a new layer for a page which will contains the editors.
996    * @param {AnnotationEditorLayer} layer
997    */
998   addLayer(layer) {
999     this.#allLayers.set(layer.pageIndex, layer);
1000     if (this.#isEnabled) {
1001       layer.enable();
1002     } else {
1003       layer.disable();
1004     }
1005   }
1006 
1007   /**
1008    * Remove a layer.
1009    * @param {AnnotationEditorLayer} layer
1010    */
1011   removeLayer(layer) {
1012     this.#allLayers.delete(layer.pageIndex);
1013   }
1014 
1015   /**
1016    * Change the editor mode (None, FreeText, Ink, ...)
1017    * @param {number} mode
1018    * @param {string|null} editId
1019    */
1020   updateMode(mode, editId = null) {
1021     this.#mode = mode;
1022     if (mode === AnnotationEditorType.NONE) {
1023       this.setEditingState(false);
1024       this.#disableAll();
1025       return;
1026     }
1027     this.setEditingState(true);
1028     this.#enableAll();
1029     for (const layer of this.#allLayers.values()) {
1030       layer.updateMode(mode);
1031     }
1032     if (!editId) {
1033       return;
1034     }
1035     for (const editor of this.#allEditors.values()) {
1036       if (editor.annotationElementId === editId) {
1037         this.setSelected(editor);
1038         editor.enterInEditMode();
1039         break;
1040       }
1041     }
1042   }
1043 
1044   /**
1045    * Update the toolbar if it's required to reflect the tool currently used.
1046    * @param {number} mode
1047    * @returns {undefined}
1048    */
1049   updateToolbar(mode) {
1050     if (mode === this.#mode) {
1051       return;
1052     }
1053     this.#eventBus.dispatch("switchannotationeditormode", {
1054       source: this,
1055       mode,
1056     });
1057   }
1058 
1059   /**
1060    * Update a parameter in the current editor or globally.
1061    * @param {number} type
1062    * @param {*} value
1063    */
1064   updateParams(type, value) {
1065     if (!this.#editorTypes) {
1066       return;
1067     }
1068 
1069     for (const editor of this.#selectedEditors) {
1070       editor.updateParams(type, value);
1071     }
1072 
1073     for (const editorType of this.#editorTypes) {
1074       editorType.updateDefaultParams(type, value);
1075     }
1076   }
1077 
1078   /**
1079    * Enable all the layers.
1080    */
1081   #enableAll() {
1082     if (!this.#isEnabled) {
1083       this.#isEnabled = true;
1084       for (const layer of this.#allLayers.values()) {
1085         layer.enable();
1086       }
1087     }
1088   }
1089 
1090   /**
1091    * Disable all the layers.
1092    */
1093   #disableAll() {
1094     this.unselectAll();
1095     if (this.#isEnabled) {
1096       this.#isEnabled = false;
1097       for (const layer of this.#allLayers.values()) {
1098         layer.disable();
1099       }
1100     }
1101   }
1102 
1103   /**
1104    * Get all the editors belonging to a give page.
1105    * @param {number} pageIndex
1106    * @returns {Array<AnnotationEditor>}
1107    */
1108   getEditors(pageIndex) {
1109     const editors = [];
1110     for (const editor of this.#allEditors.values()) {
1111       if (editor.pageIndex === pageIndex) {
1112         editors.push(editor);
1113       }
1114     }
1115     return editors;
1116   }
1117 
1118   /**
1119    * Get an editor with the given id.
1120    * @param {string} id
1121    * @returns {AnnotationEditor}
1122    */
1123   getEditor(id) {
1124     return this.#allEditors.get(id);
1125   }
1126 
1127   /**
1128    * Add a new editor.
1129    * @param {AnnotationEditor} editor
1130    */
1131   addEditor(editor) {
1132     this.#allEditors.set(editor.id, editor);
1133   }
1134 
1135   /**
1136    * Remove an editor.
1137    * @param {AnnotationEditor} editor
1138    */
1139   removeEditor(editor) {
1140     this.#allEditors.delete(editor.id);
1141     this.unselect(editor);
1142     if (
1143       !editor.annotationElementId ||
1144       !this.#deletedAnnotationsElementIds.has(editor.annotationElementId)
1145     ) {
1146       this.#annotationStorage?.remove(editor.id);
1147     }
1148   }
1149 
1150   /**
1151    * The annotation element with the given id has been deleted.
1152    * @param {AnnotationEditor} editor
1153    */
1154   addDeletedAnnotationElement(editor) {
1155     this.#deletedAnnotationsElementIds.add(editor.annotationElementId);
1156     editor.deleted = true;
1157   }
1158 
1159   /**
1160    * Check if the annotation element with the given id has been deleted.
1161    * @param {string} annotationElementId
1162    * @returns {boolean}
1163    */
1164   isDeletedAnnotationElement(annotationElementId) {
1165     return this.#deletedAnnotationsElementIds.has(annotationElementId);
1166   }
1167 
1168   /**
1169    * The annotation element with the given id have been restored.
1170    * @param {AnnotationEditor} editor
1171    */
1172   removeDeletedAnnotationElement(editor) {
1173     this.#deletedAnnotationsElementIds.delete(editor.annotationElementId);
1174     editor.deleted = false;
1175   }
1176 
1177   /**
1178    * Add an editor to the layer it belongs to or add it to the global map.
1179    * @param {AnnotationEditor} editor
1180    */
1181   #addEditorToLayer(editor) {
1182     const layer = this.#allLayers.get(editor.pageIndex);
1183     if (layer) {
1184       layer.addOrRebuild(editor);
1185     } else {
1186       this.addEditor(editor);
1187     }
1188   }
1189 
1190   /**
1191    * Set the given editor as the active one.
1192    * @param {AnnotationEditor} editor
1193    */
1194   setActiveEditor(editor) {
1195     if (this.#activeEditor === editor) {
1196       return;
1197     }
1198 
1199     this.#activeEditor = editor;
1200     if (editor) {
1201       this.#dispatchUpdateUI(editor.propertiesToUpdate);
1202     }
1203   }
1204 
1205   /**
1206    * Add or remove an editor the current selection.
1207    * @param {AnnotationEditor} editor
1208    */
1209   toggleSelected(editor) {
1210     if (this.#selectedEditors.has(editor)) {
1211       this.#selectedEditors.delete(editor);
1212       editor.unselect();
1213       this.#dispatchUpdateStates({
1214         hasSelectedEditor: this.hasSelection,
1215       });
1216       return;
1217     }
1218     this.#selectedEditors.add(editor);
1219     editor.select();
1220     this.#dispatchUpdateUI(editor.propertiesToUpdate);
1221     this.#dispatchUpdateStates({
1222       hasSelectedEditor: true,
1223     });
1224   }
1225 
1226   /**
1227    * Set the last selected editor.
1228    * @param {AnnotationEditor} editor
1229    */
1230   setSelected(editor) {
1231     for (const ed of this.#selectedEditors) {
1232       if (ed !== editor) {
1233         ed.unselect();
1234       }
1235     }
1236     this.#selectedEditors.clear();
1237 
1238     this.#selectedEditors.add(editor);
1239     editor.select();
1240     this.#dispatchUpdateUI(editor.propertiesToUpdate);
1241     this.#dispatchUpdateStates({
1242       hasSelectedEditor: true,
1243     });
1244   }
1245 
1246   /**
1247    * Check if the editor is selected.
1248    * @param {AnnotationEditor} editor
1249    */
1250   isSelected(editor) {
1251     return this.#selectedEditors.has(editor);
1252   }
1253 
1254   /**
1255    * Unselect an editor.
1256    * @param {AnnotationEditor} editor
1257    */
1258   unselect(editor) {
1259     editor.unselect();
1260     this.#selectedEditors.delete(editor);
1261     this.#dispatchUpdateStates({
1262       hasSelectedEditor: this.hasSelection,
1263     });
1264   }
1265 
1266   get hasSelection() {
1267     return this.#selectedEditors.size !== 0;
1268   }
1269 
1270   stopUndoAccumulation() {
1271     this.#commandManager.stopUndoAccumulation();
1272   }
1273 
1274   /**
1275    * Undo the last command.
1276    */
1277   undo() {
1278     this.#commandManager.undo();
1279     this.#dispatchUpdateStates({
1280       hasSomethingToUndo: this.#commandManager.hasSomethingToUndo(),
1281       hasSomethingToRedo: true,
1282       isEmpty: this.#isEmpty(),
1283     });
1284   }
1285 
1286   /**
1287    * Redo the last undoed command.
1288    */
1289   redo() {
1290     this.#commandManager.redo();
1291     this.#dispatchUpdateStates({
1292       hasSomethingToUndo: true,
1293       hasSomethingToRedo: this.#commandManager.hasSomethingToRedo(),
1294       isEmpty: this.#isEmpty(),
1295     });
1296   }
1297 
1298   /**
1299    * Add a command to execute (cmd) and another one to undo it.
1300    * @param {Object} params
1301    */
1302   addCommands(params) {
1303     this.#commandManager.add(params);
1304     this.#dispatchUpdateStates({
1305       hasSomethingToUndo: true,
1306       hasSomethingToRedo: false,
1307       isEmpty: this.#isEmpty(),
1308     });
1309   }
1310 
1311   #isEmpty() {
1312     if (this.#allEditors.size === 0) {
1313       return true;
1314     }
1315 
1316     if (this.#allEditors.size === 1) {
1317       for (const editor of this.#allEditors.values()) {
1318         return editor.isEmpty();
1319       }
1320     }
1321 
1322     return false;
1323   }
1324 
1325   /**
1326    * Delete the current editor or all.
1327    */
1328   delete() {
1329     this.commitOrRemove();
1330     if (!this.hasSelection) {
1331       return;
1332     }
1333 
1334     const editors = [...this.#selectedEditors];
1335     const cmd = () => {
1336       for (const editor of editors) {
1337         editor.remove();
1338       }
1339     };
1340     const undo = () => {
1341       for (const editor of editors) {
1342         this.#addEditorToLayer(editor);
1343       }
1344     };
1345 
1346     this.addCommands({ cmd, undo, mustExec: true });
1347   }
1348 
1349   commitOrRemove() {
1350     // An editor is being edited so just commit it.
1351     this.#activeEditor?.commitOrRemove();
1352   }
1353 
1354   hasSomethingToControl() {
1355     return this.#activeEditor || this.hasSelection;
1356   }
1357 
1358   /**
1359    * Select the editors.
1360    * @param {Array<AnnotationEditor>} editors
1361    */
1362   #selectEditors(editors) {
1363     this.#selectedEditors.clear();
1364     for (const editor of editors) {
1365       if (editor.isEmpty()) {
1366         continue;
1367       }
1368       this.#selectedEditors.add(editor);
1369       editor.select();
1370     }
1371     this.#dispatchUpdateStates({ hasSelectedEditor: true });
1372   }
1373 
1374   /**
1375    * Select all the editors.
1376    */
1377   selectAll() {
1378     for (const editor of this.#selectedEditors) {
1379       editor.commit();
1380     }
1381     this.#selectEditors(this.#allEditors.values());
1382   }
1383 
1384   /**
1385    * Unselect all the selected editors.
1386    */
1387   unselectAll() {
1388     if (this.#activeEditor) {
1389       // An editor is being edited so just commit it.
1390       this.#activeEditor.commitOrRemove();
1391       return;
1392     }
1393 
1394     if (!this.hasSelection) {
1395       return;
1396     }
1397     for (const editor of this.#selectedEditors) {
1398       editor.unselect();
1399     }
1400     this.#selectedEditors.clear();
1401     this.#dispatchUpdateStates({
1402       hasSelectedEditor: false,
1403     });
1404   }
1405 
1406   translateSelectedEditors(x, y, noCommit = false) {
1407     if (!noCommit) {
1408       this.commitOrRemove();
1409     }
1410     if (!this.hasSelection) {
1411       return;
1412     }
1413 
1414     this.#translation[0] += x;
1415     this.#translation[1] += y;
1416     const [totalX, totalY] = this.#translation;
1417     const editors = [...this.#selectedEditors];
1418 
1419     // We don't want to have an undo/redo for each translation so we wait a bit
1420     // before adding the command to the command manager.
1421     const TIME_TO_WAIT = 1000;
1422 
1423     if (this.#translationTimeoutId) {
1424       clearTimeout(this.#translationTimeoutId);
1425     }
1426 
1427     this.#translationTimeoutId = setTimeout(() => {
1428       this.#translationTimeoutId = null;
1429       this.#translation[0] = this.#translation[1] = 0;
1430 
1431       this.addCommands({
1432         cmd: () => {
1433           for (const editor of editors) {
1434             if (this.#allEditors.has(editor.id)) {
1435               editor.translateInPage(totalX, totalY);
1436             }
1437           }
1438         },
1439         undo: () => {
1440           for (const editor of editors) {
1441             if (this.#allEditors.has(editor.id)) {
1442               editor.translateInPage(-totalX, -totalY);
1443             }
1444           }
1445         },
1446         mustExec: false,
1447       });
1448     }, TIME_TO_WAIT);
1449 
1450     for (const editor of editors) {
1451       editor.translateInPage(x, y);
1452     }
1453   }
1454 
1455   /**
1456    * Is the current editor the one passed as argument?
1457    * @param {AnnotationEditor} editor
1458    * @returns
1459    */
1460   isActive(editor) {
1461     return this.#activeEditor === editor;
1462   }
1463 
1464   /**
1465    * Get the current active editor.
1466    * @returns {AnnotationEditor|null}
1467    */
1468   getActive() {
1469     return this.#activeEditor;
1470   }
1471 
1472   /**
1473    * Get the current editor mode.
1474    * @returns {number}
1475    */
1476   getMode() {
1477     return this.#mode;
1478   }
1479 
1480   get imageManager() {
1481     return shadow(this, "imageManager", new ImageManager());
1482   }
1483 }
1484 
1485 export {
1486   AnnotationEditorUIManager,
1487   bindEvents,
1488   ColorManager,
1489   CommandManager,
1490   KeyboardManager,
1491   opacityToHex,
1492 };
</code>

Your task:
You are a software tester at pdf.js.
1. Write exactly one javascript test `it("...", async () => {...})` block.
2. Your test must fail on the code before the patch, and pass after, hence the test will verify that the patch resolves the issue.
3. The test must be self-contained and to-the-point.
4. Use only the provided imports (respect the paths exactly how they are given) by importing dynamically for compatibility with Node.js — no new dependencies. 
5. Return only the javascript code (no comments or explanations).

Example structure:
it("should <describe behavior>", async () => {
  const { example } = await import("../../src/core/example.js");
  <initialize required variables>;
  <define expected variable>;
  <generate actual variables>;
  <compare expected with actual>;
});

