Before you begin:
- Keep going until the job is completely solved — don’t stop halfway.
- If you’re unsure about the behavior, reread the provided patch carefully; do not hallucinate.
- Plan your approach before writing code by reflecting on whether the test truly fails before and passes after.

Issue:
<issue>
NVDA reads out loud extra text when reaching an Added image with Alt text while Add image button is enabled
</issue>

Patch:
<patch>
diff --git a/src/display/editor/alt_text.js b/src/display/editor/alt_text.js
--- a/src/display/editor/alt_text.js
+++ b/src/display/editor/alt_text.js
@@ -279,8 +279,7 @@ class AltText {
       this.#altTextTooltip = tooltip = document.createElement("span");
       tooltip.className = "tooltip";
       tooltip.setAttribute("role", "tooltip");
-      const id = (tooltip.id = `alt-text-tooltip-${this.#editor.id}`);
-      button.setAttribute("aria-describedby", id);
+      tooltip.id = `alt-text-tooltip-${this.#editor.id}`;
 
       const DELAY_TO_SHOW_TOOLTIP = 100;
       const signal = this.#editor._uiManager._signal;

diff --git a/src/display/editor/editor.js b/src/display/editor/editor.js
--- a/src/display/editor/editor.js
+++ b/src/display/editor/editor.js
@@ -993,6 +993,15 @@ class AnnotationEditor {
     this.#altText?.destroy();
   }
 
+  addContainer(container) {
+    const editToolbarDiv = this._editToolbar?.div;
+    if (editToolbarDiv) {
+      editToolbarDiv.before(container);
+    } else {
+      this.div.append(container);
+    }
+  }
+
   getClientDimensions() {
     return this.div.getBoundingClientRect();
   }

diff --git a/src/display/editor/stamp.js b/src/display/editor/stamp.js
--- a/src/display/editor/stamp.js
+++ b/src/display/editor/stamp.js
@@ -373,6 +373,7 @@ class StampEditor extends AnnotationEditor {
 
     super.render();
     this.div.hidden = true;
+    this.div.setAttribute("role", "figure");
 
     this.addAltTextButton();
 
@@ -425,7 +426,9 @@ class StampEditor extends AnnotationEditor {
 
     this._uiManager.enableWaiting(false);
     const canvas = (this.#canvas = document.createElement("canvas"));
-    div.append(canvas);
+    canvas.setAttribute("role", "img");
+    this.addContainer(canvas);
+
     if (
       !this._uiManager.useNewAltTextWhenAddingImage ||
       !this._uiManager.useNewAltTextFlow

diff --git a/src/display/editor/toolbar.js b/src/display/editor/toolbar.js
--- a/src/display/editor/toolbar.js
+++ b/src/display/editor/toolbar.js
@@ -26,17 +26,8 @@ class EditorToolbar {
 
   #altText = null;
 
-  static #l10nRemove = null;
-
   constructor(editor) {
     this.#editor = editor;
-
-    EditorToolbar.#l10nRemove ||= Object.freeze({
-      freetext: "pdfjs-editor-remove-freetext-button",
-      highlight: "pdfjs-editor-remove-highlight-button",
-      ink: "pdfjs-editor-remove-ink-button",
-      stamp: "pdfjs-editor-remove-stamp-button",
-    });
   }
 
   render() {
@@ -71,6 +62,10 @@ class EditorToolbar {
     return editToolbar;
   }
 
+  get div() {
+    return this.#toolbar;
+  }
+
   static #pointerDown(e) {
     e.stopPropagation();
   }
@@ -114,19 +109,20 @@ class EditorToolbar {
   }
 
   #addDeleteButton() {
-    const { editorType, _uiManager } = this.#editor;
-
     const button = document.createElement("button");
     button.className = "delete";
     button.tabIndex = 0;
-    button.setAttribute("data-l10n-id", EditorToolbar.#l10nRemove[editorType]);
+    button.setAttribute(
+      "data-l10n-id",
+      `pdfjs-editor-remove-${this.#editor.editorType}-button`
+    );
     this.#addListenersToElement(button);
     button.addEventListener(
       "click",
       e => {
-        _uiManager.delete();
+        this.#editor._uiManager.delete();
       },
-      { signal: _uiManager._signal }
+      { signal: this.#editor._uiManager._signal }
     );
     this.#buttons.append(button);
   }


</patch>

Imports:
<imports>
Available Packages
Dev Dependencies:
- @babel/core: ^7.25.2
- @babel/preset-env: ^7.25.4
- @babel/runtime: ^7.25.4
- @fluent/bundle: ^0.18.0
- @fluent/dom: ^0.10.0
- @jazzer.js/core: ^2.1.0
- @metalsmith/layouts: ^2.7.0
- @metalsmith/markdown: ^1.10.0
- autoprefixer: ^10.4.20
- babel-loader: ^9.1.3
- caniuse-lite: ^1.0.30001653
- canvas: ^2.11.2
- core-js: ^3.38.1
- eslint: ^8.57.0
- eslint-config-prettier: ^9.1.0
- eslint-plugin-fetch-options: ^0.0.5
- eslint-plugin-html: ^8.1.1
- eslint-plugin-import: ^2.29.1
- eslint-plugin-jasmine: ^4.2.1
- eslint-plugin-json: ^3.1.0
- eslint-plugin-no-unsanitized: ^4.0.2
- eslint-plugin-prettier: ^5.2.1
- eslint-plugin-sort-exports: ^0.9.1
- eslint-plugin-unicorn: ^55.0.0
- gulp: ^5.0.0
- gulp-cli: ^3.0.0
- gulp-postcss: ^10.0.0
- gulp-rename: ^2.0.0
- gulp-replace: ^1.1.4
- gulp-zip: ^6.0.0
- highlight.js: ^11.10.0
- jasmine: ^5.2.0
- jsdoc: ^4.0.3
- jstransformer-nunjucks: ^1.2.0
- metalsmith: ^2.6.3
- metalsmith-html-relative: ^2.0.1
- ordered-read-streams: ^2.0.0
- path2d: ^0.2.1
- pngjs: ^7.0.0
- postcss: ^8.4.41
- postcss-dark-theme-class: ^1.3.0
- postcss-dir-pseudo-class: ^9.0.0
- postcss-discard-comments: ^7.0.2
- postcss-nesting: ^13.0.0
- prettier: ^3.3.3
- puppeteer: ^23.1.1
- stylelint: ^16.8.2
- stylelint-prettier: ^5.0.2
- svglint: ^3.0.0
- terser-webpack-plugin: ^5.3.10
- tsc-alias: ^1.8.10
- ttest: ^4.0.0
- typescript: ^5.5.4
- vinyl: ^3.0.0
- webpack: ^5.94.0
- webpack-stream: ^7.0.0
- yargs: ^17.7.2

Engines:
- node: >=18

Available Relative Imports:
- `../../src/core/annotation.js`: Annotation, AnnotationBorderStyle, AnnotationFactory, MarkupAnnotation, getQuadPoints
- `../../src/core/bidi.js`: bidi
- `../../src/core/cff_parser.js`: CFFCharset, CFFCompiler, CFFFDSelect, CFFParser, CFFStrings
- `../../src/core/cmap.js`: CMap, CMapFactory, IdentityCMap
- `../../src/core/colorspace.js`: ColorSpace
- `../../src/core/core_utils.js`: arrayBuffersToBytes, encodeToXmlString, escapePDFName, escapeString, getInheritableProperty, getSizeInBytes, isAscii, isWhiteSpace, log2, numberToString, parseXFAPath, recoverJsURL, stringToUTF16HexString, stringToUTF16String, toRomanNumerals, validateCSSFont
- `../../src/core/crypto.js`: AES128Cipher, AES256Cipher, ARCFourCipher, CipherTransformFactory, PDF17, PDF20, calculateMD5, calculateSHA256, calculateSHA384, calculateSHA512
- `../../src/core/default_appearance.js`: createDefaultAppearance, parseAppearanceStream, parseDefaultAppearance
- `../../src/core/document.js`: PDFDocument, Page
- `../../src/core/encodings.js`: getEncoding
- `../../src/core/evaluator.js`: PartialEvaluator
- `../../src/core/flate_stream.js`: FlateStream
- `../../src/core/font_substitutions.js`: getFontSubstitution
- `../../src/core/fonts_utils.js`: SEAC_ANALYSIS_ENABLED
- `../../src/core/function.js`: PDFFunctionFactory, PostScriptCompiler, PostScriptEvaluator
- `../../src/core/glyphlist.js`: getDingbatsGlyphsUnicode, getGlyphsUnicode
- `../../src/core/image_utils.js`: GlobalImageCache, LocalColorSpaceCache
- `../../src/core/jbig2.js`: Jbig2Error, Jbig2Image
- `../../src/core/jpg.js`: JpegError, JpegImage
- `../../src/core/jpx.js`: JpxError, JpxImage
- `../../src/core/metadata_parser.js`: MetadataParser
- `../../src/core/operator_list.js`: OperatorList
- `../../src/core/parser.js`: Lexer, Linearization, Parser
- `../../src/core/predictor_stream.js`: PredictorStream
- `../../src/core/primitives.js`: Cmd, Dict, EOF, Name, Ref, RefSet, RefSetCache, isCmd, isDict, isName, isRefsEqual
- `../../src/core/ps_parser.js`: PostScriptLexer, PostScriptParser
- `../../src/core/stream.js`: NullStream, Stream, StringStream
- `../../src/core/type1_parser.js`: Type1Parser
- `../../src/core/unicode.js`: getCharUnicodeCategory, getUnicodeForGlyph, getUnicodeRangeFor, mapSpecialUnicodeValues
- `../../src/core/worker.js`: WorkerMessageHandler, WorkerTask
- `../../src/core/writer.js`: incrementalUpdate, writeDict
- `../../src/core/xfa/bind.js`: Binder
- `../../src/core/xfa/data.js`: DataHandler
- `../../src/core/xfa/factory.js`: XFAFactory
- `../../src/core/xfa/formcalc_lexer.js`: Lexer, TOKEN, Token
- `../../src/core/xfa/formcalc_parser.js`: Errors, Parser
- `../../src/core/xfa/parser.js`: XFAParser
- `../../src/core/xfa/som.js`: searchNode
- `../../src/core/xfa/symbol_utils.js`: $dump, $getChildren, $getChildrenByClass, $getChildrenByName, $text, $uid
- `../../src/core/xml_parser.js`: SimpleXMLParser, XMLParserBase
- `../../src/display/annotation_layer.js`: AnnotationLayer
- `../../src/display/annotation_storage.js`: AnnotationStorage
- `../../src/display/api.js`: DefaultCMapReaderFactory, DefaultCanvasFactory, DefaultStandardFontDataFactory, LoopbackPort, PDFDataRangeTransport, PDFDocumentLoadingTask, PDFDocumentProxy, PDFPageProxy, PDFWorker, RenderTask, build, getDocument, version
- `../../src/display/display_utils.js`: DOMCanvasFactory, DOMSVGFactory, PDFDateString, PageViewport, PixelsPerInch, RenderingCancelledException, StatTimer, fetchData, getFilenameFromUrl, getPdfFilenameFromUrl, getXfaPageViewport, isDataScheme, isPdfFile, isValidFetchUrl, noContextMenu, setLayerDimensions
- `../../src/display/draw_layer.js`: DrawLayer
- `../../src/display/editor/annotation_editor_layer.js`: AnnotationEditorLayer
- `../../src/display/editor/color_picker.js`: ColorPicker
- `../../src/display/editor/tools.js`: AnnotationEditorUIManager, CommandManager
- `../../src/display/fetch_stream.js`: PDFFetchStream
- `../../src/display/metadata.js`: Metadata
- `../../src/display/network.js`: PDFNetworkStream
- `../../src/display/network_utils.js`: createResponseStatusError, extractFilenameFromHeader, validateRangeRequestCapabilities, validateResponseStatus
- `../../src/display/node_stream.js`: PDFNodeStream
- `../../src/display/node_utils.js`: NodePackages
- `../../src/display/text_layer.js`: TextLayer
- `../../src/display/worker_options.js`: GlobalWorkerOptions
- `../../src/display/xfa_layer.js`: XfaLayer
- `../../src/shared/message_handler.js`: MessageHandler
- `../../src/shared/murmurhash3.js`: MurmurHash3_64
- `../../src/shared/util.js`: AbortException, AnnotationBorderStyleType, AnnotationEditorParamsType, AnnotationEditorType, AnnotationFieldFlag, AnnotationFlag, AnnotationMode, AnnotationType, BaseException, CMapCompressionType, FeatureTest, FormatError, ImageKind, InvalidPDFException, MissingPDFException, OPS, PasswordException, PasswordResponses, PermissionFlag, RenderingIntentFlag, UnexpectedResponseException, UnknownErrorException, Util, VerbosityLevel, assert, bytesToString, createValidAbsoluteUrl, getModificationDate, getVerbosityLevel, isNodeJS, normalizeUnicode, objectSize, setVerbosityLevel, shadow, string32, stringToBytes, stringToPDFString, stringToUTF8String
- `../../web/annotation_layer_builder.js`: AnnotationLayerBuilder
- `../../web/app_options.js`: AppOptions, OptionKind
- `../../web/download_manager.js`: DownloadManager
- `../../web/event_utils.js`: EventBus, WaitOnType, waitOnEventOrTimeout
- `../../web/genericl10n.js`: GenericL10n
- `../../web/pdf_find_controller.js`: FindState, PDFFindController
- `../../web/pdf_find_utils.js`: CharacterType, getCharacterType
- `../../web/pdf_history.js`: PDFHistory, isDestArraysEqual, isDestHashesEqual
- `../../web/pdf_link_service.js`: LinkTarget, PDFLinkService, SimpleLinkService
- `../../web/pdf_page_view.js`: PDFPageView
- `../../web/pdf_scripting_manager.component.js`: PDFScriptingManager
- `../../web/pdf_single_page_viewer.js`: PDFSinglePageViewer
- `../../web/pdf_viewer.js`: PDFPageViewBuffer, PDFViewer
- `../../web/struct_tree_layer_builder.js`: StructTreeLayerBuilder
- `../../web/text_layer_builder.js`: TextLayerBuilder
- `../../web/ui_utils.js`: AutoPrintRegExp, ProgressBar, RenderingStates, ScrollMode, SpreadMode, backtrackBeforeAllVisibleElements, binarySearchFirstItem, getPageSizeInches, getVisibleElements, isPortraitOrientation, isValidRotation, parseQueryString, removeNullCharacters
- `../../web/xfa_layer_builder.js`: XfaLayerBuilder
- `./test_utils.js`: CMAP_URL, DefaultFileReaderFactory, STANDARD_FONT_DATA_URL, TEST_PDFS_PATH, XRefMock, buildGetDocumentParams, createIdFactory, createTemporaryNodeServer
- `./testreporter.js`: TestReporter
</imports>

Code:
<code>
File:
src/display/editor/alt_text.js
1 /* Copyright 2023 Mozilla Foundation
2  *
3  * Licensed under the Apache License, Version 2.0 (the "License");
4  * you may not use this file except in compliance with the License.
5  * You may obtain a copy of the License at
6  *
7  *     http://www.apache.org/licenses/LICENSE-2.0
8  *
9  * Unless required by applicable law or agreed to in writing, software
10  * distributed under the License is distributed on an "AS IS" BASIS,
11  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
12  * See the License for the specific language governing permissions and
13  * limitations under the License.
14  */
15 
16 import { noContextMenu } from "../display_utils.js";
17 
18 class AltText {
19   #altText = null;
20 
21   #altTextDecorative = false;
22 
23   #altTextButton = null;
24 
25   #altTextTooltip = null;
26 
27   #altTextTooltipTimeout = null;
28 
29   #altTextWasFromKeyBoard = false;
30 
31   #badge = null;
32 
33   #editor = null;
34 
35   #guessedText = null;
36 
37   #textWithDisclaimer = null;
38 
39   #useNewAltTextFlow = false;
40 
41   static _l10nPromise = null;
42 
43   constructor(editor) {
44     this.#editor = editor;
45     this.#useNewAltTextFlow = editor._uiManager.useNewAltTextFlow;
46   }
47 
48   static initialize(l10nPromise) {
49     AltText._l10nPromise ||= l10nPromise;
50   }
51 
52   async render() {
53     const altText = (this.#altTextButton = document.createElement("button"));
54     altText.className = "altText";
55     let msg;
56     if (this.#useNewAltTextFlow) {
57       altText.classList.add("new");
58       msg = await AltText._l10nPromise.get(
59         "pdfjs-editor-new-alt-text-missing-button-label"
60       );
61     } else {
62       msg = await AltText._l10nPromise.get(
63         "pdfjs-editor-alt-text-button-label"
64       );
65     }
66     altText.textContent = msg;
67     altText.setAttribute("aria-label", msg);
68     altText.tabIndex = "0";
69     const signal = this.#editor._uiManager._signal;
70     altText.addEventListener("contextmenu", noContextMenu, { signal });
71     altText.addEventListener("pointerdown", event => event.stopPropagation(), {
72       signal,
73     });
74 
75     const onClick = event => {
76       event.preventDefault();
77       this.#editor._uiManager.editAltText(this.#editor);
78       if (this.#useNewAltTextFlow) {
79         this.#editor._reportTelemetry({
80           action: "pdfjs.image.alt_text.image_status_label_clicked",
81           data: { label: this.#label },
82         });
83       }
84     };
85     altText.addEventListener("click", onClick, { capture: true, signal });
86     altText.addEventListener(
87       "keydown",
88       event => {
89         if (event.target === altText && event.key === "Enter") {
90           this.#altTextWasFromKeyBoard = true;
91           onClick(event);
92         }
93       },
94       { signal }
95     );
96     await this.#setState();
97 
98     return altText;
99   }
100 
101   get #label() {
102     return (
103       (this.#altText && "added") ||
104       (this.#altText === null && this.guessedText && "review") ||
105       "missing"
106     );
107   }
108 
109   finish() {
110     if (!this.#altTextButton) {
111       return;
112     }
113     this.#altTextButton.focus({ focusVisible: this.#altTextWasFromKeyBoard });
114     this.#altTextWasFromKeyBoard = false;
115   }
116 
117   isEmpty() {
118     if (this.#useNewAltTextFlow) {
119       return this.#altText === null;
120     }
121     return !this.#altText && !this.#altTextDecorative;
122   }
123 
124   hasData() {
125     if (this.#useNewAltTextFlow) {
126       return this.#altText !== null || !!this.#guessedText;
127     }
128     return this.isEmpty();
129   }
130 
131   get guessedText() {
132     return this.#guessedText;
133   }
134 
135   async setGuessedText(guessedText) {
136     if (this.#altText !== null) {
137       // The user provided their own alt text, so we don't want to overwrite it.
138       return;
139     }
140     this.#guessedText = guessedText;
141     this.#textWithDisclaimer = await AltText._l10nPromise.get(
142       "pdfjs-editor-new-alt-text-generated-alt-text-with-disclaimer"
143     )({ generatedAltText: guessedText });
144     this.#setState();
145   }
146 
147   toggleAltTextBadge(visibility = false) {
148     if (!this.#useNewAltTextFlow || this.#altText) {
149       this.#badge?.remove();
150       this.#badge = null;
151       return;
152     }
153     if (!this.#badge) {
154       const badge = (this.#badge = document.createElement("div"));
155       badge.className = "noAltTextBadge";
156       this.#editor.div.append(badge);
157     }
158     this.#badge.classList.toggle("hidden", !visibility);
159   }
160 
161   serialize(isForCopying) {
162     let altText = this.#altText;
163     if (!isForCopying && this.#guessedText === altText) {
164       altText = this.#textWithDisclaimer;
165     }
166     return {
167       altText,
168       decorative: this.#altTextDecorative,
169       guessedText: this.#guessedText,
170       textWithDisclaimer: this.#textWithDisclaimer,
171     };
172   }
173 
174   get data() {
175     return {
176       altText: this.#altText,
177       decorative: this.#altTextDecorative,
178     };
179   }
180 
181   /**
182    * Set the alt text data.
183    */
184   set data({
185     altText,
186     decorative,
187     guessedText,
188     textWithDisclaimer,
189     cancel = false,
190   }) {
191     if (guessedText) {
192       this.#guessedText = guessedText;
193       this.#textWithDisclaimer = textWithDisclaimer;
194     }
195     if (this.#altText === altText && this.#altTextDecorative === decorative) {
196       return;
197     }
198     if (!cancel) {
199       this.#altText = altText;
200       this.#altTextDecorative = decorative;
201     }
202     this.#setState();
203   }
204 
205   toggle(enabled = false) {
206     if (!this.#altTextButton) {
207       return;
208     }
209     if (!enabled && this.#altTextTooltipTimeout) {
210       clearTimeout(this.#altTextTooltipTimeout);
211       this.#altTextTooltipTimeout = null;
212     }
213     this.#altTextButton.disabled = !enabled;
214   }
215 
216   shown() {
217     this.#editor._reportTelemetry({
218       action: "pdfjs.image.alt_text.image_status_label_displayed",
219       data: { label: this.#label },
220     });
221   }
222 
223   destroy() {
224     this.#altTextButton?.remove();
225     this.#altTextButton = null;
226     this.#altTextTooltip = null;
227     this.#badge?.remove();
228     this.#badge = null;
229   }
230 
231   async #setState() {
232     const button = this.#altTextButton;
233     if (!button) {
234       return;
235     }
236 
237     if (this.#useNewAltTextFlow) {
238       // If we've an alt text, we get an "added".
239       // If we've a guessed text and the alt text has never been set, we get a
240       // "to-review" been set.
241       // Otherwise, we get a "missing".
242       const label = this.#label;
243       // TODO: Update the l10n keys to avoid this.
244       const type = label === "review" ? "to-review" : label;
245       button.classList.toggle("done", !!this.#altText);
246       AltText._l10nPromise
247         .get(`pdfjs-editor-new-alt-text-${type}-button-label`)
248         .then(msg => {
249           button.setAttribute("aria-label", msg);
250           // We can't just use button.textContent here, because it would remove
251           // the existing tooltip element.
252           for (const child of button.childNodes) {
253             if (child.nodeType === Node.TEXT_NODE) {
254               child.textContent = msg;
255               break;
256             }
257           }
258         });
259       if (!this.#altText) {
260         this.#altTextTooltip?.remove();
261         return;
262       }
263     } else {
264       if (!this.#altText && !this.#altTextDecorative) {
265         button.classList.remove("done");
266         this.#altTextTooltip?.remove();
267         return;
268       }
269       button.classList.add("done");
270       AltText._l10nPromise
271         .get("pdfjs-editor-alt-text-edit-button-label")
272         .then(msg => {
273           button.setAttribute("aria-label", msg);
274         });
275     }
276 
277     let tooltip = this.#altTextTooltip;
278     if (!tooltip) {
279       this.#altTextTooltip = tooltip = document.createElement("span");
280       tooltip.className = "tooltip";
281       tooltip.setAttribute("role", "tooltip");
282       const id = (tooltip.id = `alt-text-tooltip-${this.#editor.id}`);
283       button.setAttribute("aria-describedby", id);
284 
285       const DELAY_TO_SHOW_TOOLTIP = 100;
286       const signal = this.#editor._uiManager._signal;
287       signal.addEventListener(
288         "abort",
289         () => {
290           clearTimeout(this.#altTextTooltipTimeout);
291           this.#altTextTooltipTimeout = null;
292         },
293         { once: true }
294       );
295       button.addEventListener(
296         "mouseenter",
297         () => {
298           this.#altTextTooltipTimeout = setTimeout(() => {
299             this.#altTextTooltipTimeout = null;
300             this.#altTextTooltip.classList.add("show");
301             this.#editor._reportTelemetry({
302               action: "alt_text_tooltip",
303             });
304           }, DELAY_TO_SHOW_TOOLTIP);
305         },
306         { signal }
307       );
308       button.addEventListener(
309         "mouseleave",
310         () => {
311           if (this.#altTextTooltipTimeout) {
312             clearTimeout(this.#altTextTooltipTimeout);
313             this.#altTextTooltipTimeout = null;
314           }
315           this.#altTextTooltip?.classList.remove("show");
316         },
317         { signal }
318       );
319     }
320     tooltip.innerText = this.#altTextDecorative
321       ? await AltText._l10nPromise.get(
322           "pdfjs-editor-alt-text-decorative-tooltip"
323         )
324       : this.#altText;
325 
326     if (!tooltip.parentNode) {
327       button.append(tooltip);
328     }
329 
330     const element = this.#editor.getImageForAltText();
331     element?.setAttribute("aria-describedby", tooltip.id);
332   }
333 }
334 
335 export { AltText };
File:
src/display/editor/editor.js
1 /* Copyright 2022 Mozilla Foundation
2  *
3  * Licensed under the Apache License, Version 2.0 (the "License");
4  * you may not use this file except in compliance with the License.
5  * You may obtain a copy of the License at
6  *
7  *     http://www.apache.org/licenses/LICENSE-2.0
8  *
9  * Unless required by applicable law or agreed to in writing, software
10  * distributed under the License is distributed on an "AS IS" BASIS,
11  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
12  * See the License for the specific language governing permissions and
13  * limitations under the License.
14  */
15 
16 // eslint-disable-next-line max-len
17 /** @typedef {import("./annotation_editor_layer.js").AnnotationEditorLayer} AnnotationEditorLayer */
18 
19 import {
20   AnnotationEditorUIManager,
21   bindEvents,
22   ColorManager,
23   KeyboardManager,
24 } from "./tools.js";
25 import { FeatureTest, shadow, unreachable } from "../../shared/util.js";
26 import { AltText } from "./alt_text.js";
27 import { EditorToolbar } from "./toolbar.js";
28 import { noContextMenu } from "../display_utils.js";
29 
30 /**
31  * @typedef {Object} AnnotationEditorParameters
32  * @property {AnnotationEditorUIManager} uiManager - the global manager
33  * @property {AnnotationEditorLayer} parent - the layer containing this editor
34  * @property {string} id - editor id
35  * @property {number} x - x-coordinate
36  * @property {number} y - y-coordinate
37  */
38 
39 /**
40  * Base class for editors.
41  */
42 class AnnotationEditor {
43   #accessibilityData = null;
44 
45   #allResizerDivs = null;
46 
47   #altText = null;
48 
49   #disabled = false;
50 
51   #keepAspectRatio = false;
52 
53   #resizersDiv = null;
54 
55   #savedDimensions = null;
56 
57   #focusAC = null;
58 
59   #focusedResizerName = "";
60 
61   #hasBeenClicked = false;
62 
63   #initialPosition = null;
64 
65   #isEditing = false;
66 
67   #isInEditMode = false;
68 
69   #isResizerEnabledForKeyboard = false;
70 
71   #moveInDOMTimeout = null;
72 
73   #prevDragX = 0;
74 
75   #prevDragY = 0;
76 
77   #telemetryTimeouts = null;
78 
79   _editToolbar = null;
80 
81   _initialOptions = Object.create(null);
82 
83   _isVisible = true;
84 
85   _uiManager = null;
86 
87   _focusEventsAllowed = true;
88 
89   static _l10nPromise = null;
90 
91   static _l10nResizer = null;
92 
93   #isDraggable = false;
94 
95   #zIndex = AnnotationEditor._zIndex++;
96 
97   static _borderLineWidth = -1;
98 
99   static _colorManager = new ColorManager();
100 
101   static _zIndex = 1;
102 
103   // Time to wait (in ms) before sending the telemetry data.
104   // We wait a bit to avoid sending too many requests when changing something
105   // like the thickness of a line.
106   static _telemetryTimeout = 1000;
107 
108   static get _resizerKeyboardManager() {
109     const resize = AnnotationEditor.prototype._resizeWithKeyboard;
110     const small = AnnotationEditorUIManager.TRANSLATE_SMALL;
111     const big = AnnotationEditorUIManager.TRANSLATE_BIG;
112 
113     return shadow(
114       this,
115       "_resizerKeyboardManager",
116       new KeyboardManager([
117         [["ArrowLeft", "mac+ArrowLeft"], resize, { args: [-small, 0] }],
118         [
119           ["ctrl+ArrowLeft", "mac+shift+ArrowLeft"],
120           resize,
121           { args: [-big, 0] },
122         ],
123         [["ArrowRight", "mac+ArrowRight"], resize, { args: [small, 0] }],
124         [
125           ["ctrl+ArrowRight", "mac+shift+ArrowRight"],
126           resize,
127           { args: [big, 0] },
128         ],
129         [["ArrowUp", "mac+ArrowUp"], resize, { args: [0, -small] }],
130         [["ctrl+ArrowUp", "mac+shift+ArrowUp"], resize, { args: [0, -big] }],
131         [["ArrowDown", "mac+ArrowDown"], resize, { args: [0, small] }],
132         [["ctrl+ArrowDown", "mac+shift+ArrowDown"], resize, { args: [0, big] }],
133         [
134           ["Escape", "mac+Escape"],
135           AnnotationEditor.prototype._stopResizingWithKeyboard,
136         ],
137       ])
138     );
139   }
140 
141   /**
142    * @param {AnnotationEditorParameters} parameters
143    */
144   constructor(parameters) {
145     if (
146       (typeof PDFJSDev === "undefined" || PDFJSDev.test("TESTING")) &&
147       this.constructor === AnnotationEditor
148     ) {
149       unreachable("Cannot initialize AnnotationEditor.");
150     }
151 
152     this.parent = parameters.parent;
153     this.id = parameters.id;
154     this.width = this.height = null;
155     this.pageIndex = parameters.parent.pageIndex;
156     this.name = parameters.name;
157     this.div = null;
158     this._uiManager = parameters.uiManager;
159     this.annotationElementId = null;
160     this._willKeepAspectRatio = false;
161     this._initialOptions.isCentered = parameters.isCentered;
162     this._structTreeParentId = null;
163 
164     const {
165       rotation,
166       rawDims: { pageWidth, pageHeight, pageX, pageY },
167     } = this.parent.viewport;
168 
169     this.rotation = rotation;
170     this.pageRotation =
171       (360 + rotation - this._uiManager.viewParameters.rotation) % 360;
172     this.pageDimensions = [pageWidth, pageHeight];
173     this.pageTranslation = [pageX, pageY];
174 
175     const [width, height] = this.parentDimensions;
176     this.x = parameters.x / width;
177     this.y = parameters.y / height;
178 
179     this.isAttachedToDOM = false;
180     this.deleted = false;
181   }
182 
183   get editorType() {
184     return Object.getPrototypeOf(this).constructor._type;
185   }
186 
187   static get _defaultLineColor() {
188     return shadow(
189       this,
190       "_defaultLineColor",
191       this._colorManager.getHexCode("CanvasText")
192     );
193   }
194 
195   static deleteAnnotationElement(editor) {
196     const fakeEditor = new FakeEditor({
197       id: editor.parent.getNextId(),
198       parent: editor.parent,
199       uiManager: editor._uiManager,
200     });
201     fakeEditor.annotationElementId = editor.annotationElementId;
202     fakeEditor.deleted = true;
203     fakeEditor._uiManager.addToAnnotationStorage(fakeEditor);
204   }
205 
206   /**
207    * Initialize the l10n stuff for this type of editor.
208    * @param {Object} l10n
209    */
210   static initialize(l10n, _uiManager, options) {
211     AnnotationEditor._l10nResizer ||= Object.freeze({
212       topLeft: "pdfjs-editor-resizer-top-left",
213       topMiddle: "pdfjs-editor-resizer-top-middle",
214       topRight: "pdfjs-editor-resizer-top-right",
215       middleRight: "pdfjs-editor-resizer-middle-right",
216       bottomRight: "pdfjs-editor-resizer-bottom-right",
217       bottomMiddle: "pdfjs-editor-resizer-bottom-middle",
218       bottomLeft: "pdfjs-editor-resizer-bottom-left",
219       middleLeft: "pdfjs-editor-resizer-middle-left",
220     });
221 
222     AnnotationEditor._l10nPromise ||= new Map([
223       ...[
224         "pdfjs-editor-alt-text-button-label",
225         "pdfjs-editor-alt-text-edit-button-label",
226         "pdfjs-editor-alt-text-decorative-tooltip",
227         "pdfjs-editor-new-alt-text-added-button-label",
228         "pdfjs-editor-new-alt-text-missing-button-label",
229         "pdfjs-editor-new-alt-text-to-review-button-label",
230       ].map(str => [str, l10n.get(str)]),
231       ...[
232         // Strings that need l10n-arguments.
233         "pdfjs-editor-new-alt-text-generated-alt-text-with-disclaimer",
234       ].map(str => [str, l10n.get.bind(l10n, str)]),
235     ]);
236 
237     if (options?.strings) {
238       for (const str of options.strings) {
239         AnnotationEditor._l10nPromise.set(str, l10n.get(str));
240       }
241     }
242     if (AnnotationEditor._borderLineWidth !== -1) {
243       return;
244     }
245     const style = getComputedStyle(document.documentElement);
246     AnnotationEditor._borderLineWidth =
247       parseFloat(style.getPropertyValue("--outline-width")) || 0;
248   }
249 
250   /**
251    * Update the default parameters for this type of editor.
252    * @param {number} _type
253    * @param {*} _value
254    */
255   static updateDefaultParams(_type, _value) {}
256 
257   /**
258    * Get the default properties to set in the UI for this type of editor.
259    * @returns {Array}
260    */
261   static get defaultPropertiesToUpdate() {
262     return [];
263   }
264 
265   /**
266    * Check if this kind of editor is able to handle the given mime type for
267    * pasting.
268    * @param {string} mime
269    * @returns {boolean}
270    */
271   static isHandlingMimeForPasting(mime) {
272     return false;
273   }
274 
275   /**
276    * Extract the data from the clipboard item and delegate the creation of the
277    * editor to the parent.
278    * @param {DataTransferItem} item
279    * @param {AnnotationEditorLayer} parent
280    */
281   static paste(item, parent) {
282     unreachable("Not implemented");
283   }
284 
285   /**
286    * Get the properties to update in the UI for this editor.
287    * @returns {Array}
288    */
289   get propertiesToUpdate() {
290     return [];
291   }
292 
293   get _isDraggable() {
294     return this.#isDraggable;
295   }
296 
297   set _isDraggable(value) {
298     this.#isDraggable = value;
299     this.div?.classList.toggle("draggable", value);
300   }
301 
302   /**
303    * @returns {boolean} true if the editor handles the Enter key itself.
304    */
305   get isEnterHandled() {
306     return true;
307   }
308 
309   center() {
310     const [pageWidth, pageHeight] = this.pageDimensions;
311     switch (this.parentRotation) {
312       case 90:
313         this.x -= (this.height * pageHeight) / (pageWidth * 2);
314         this.y += (this.width * pageWidth) / (pageHeight * 2);
315         break;
316       case 180:
317         this.x += this.width / 2;
318         this.y += this.height / 2;
319         break;
320       case 270:
321         this.x += (this.height * pageHeight) / (pageWidth * 2);
322         this.y -= (this.width * pageWidth) / (pageHeight * 2);
323         break;
324       default:
325         this.x -= this.width / 2;
326         this.y -= this.height / 2;
327         break;
328     }
329     this.fixAndSetPosition();
330   }
331 
332   /**
333    * Add some commands into the CommandManager (undo/redo stuff).
334    * @param {Object} params
335    */
336   addCommands(params) {
337     this._uiManager.addCommands(params);
338   }
339 
340   get currentLayer() {
341     return this._uiManager.currentLayer;
342   }
343 
344   /**
345    * This editor will be behind the others.
346    */
347   setInBackground() {
348     this.div.style.zIndex = 0;
349   }
350 
351   /**
352    * This editor will be in the foreground.
353    */
354   setInForeground() {
355     this.div.style.zIndex = this.#zIndex;
356   }
357 
358   setParent(parent) {
359     if (parent !== null) {
360       this.pageIndex = parent.pageIndex;
361       this.pageDimensions = parent.pageDimensions;
362     } else {
363       // The editor is being removed from the DOM, so we need to stop resizing.
364       this.#stopResizing();
365     }
366     this.parent = parent;
367   }
368 
369   /**
370    * onfocus callback.
371    */
372   focusin(event) {
373     if (!this._focusEventsAllowed) {
374       return;
375     }
376     if (!this.#hasBeenClicked) {
377       this.parent.setSelected(this);
378     } else {
379       this.#hasBeenClicked = false;
380     }
381   }
382 
383   /**
384    * onblur callback.
385    * @param {FocusEvent} event
386    */
387   focusout(event) {
388     if (!this._focusEventsAllowed) {
389       return;
390     }
391 
392     if (!this.isAttachedToDOM) {
393       return;
394     }
395 
396     // In case of focusout, the relatedTarget is the element which
397     // is grabbing the focus.
398     // So if the related target is an element under the div for this
399     // editor, then the editor isn't unactive.
400     const target = event.relatedTarget;
401     if (target?.closest(`#${this.id}`)) {
402       return;
403     }
404 
405     event.preventDefault();
406 
407     if (!this.parent?.isMultipleSelection) {
408       this.commitOrRemove();
409     }
410   }
411 
412   commitOrRemove() {
413     if (this.isEmpty()) {
414       this.remove();
415     } else {
416       this.commit();
417     }
418   }
419 
420   /**
421    * Commit the data contained in this editor.
422    */
423   commit() {
424     this.addToAnnotationStorage();
425   }
426 
427   addToAnnotationStorage() {
428     this._uiManager.addToAnnotationStorage(this);
429   }
430 
431   /**
432    * Set the editor position within its parent.
433    * @param {number} x
434    * @param {number} y
435    * @param {number} tx - x-translation in screen coordinates.
436    * @param {number} ty - y-translation in screen coordinates.
437    */
438   setAt(x, y, tx, ty) {
439     const [width, height] = this.parentDimensions;
440     [tx, ty] = this.screenToPageTranslation(tx, ty);
441 
442     this.x = (x + tx) / width;
443     this.y = (y + ty) / height;
444 
445     this.fixAndSetPosition();
446   }
447 
448   #translate([width, height], x, y) {
449     [x, y] = this.screenToPageTranslation(x, y);
450 
451     this.x += x / width;
452     this.y += y / height;
453 
454     this.fixAndSetPosition();
455   }
456 
457   /**
458    * Translate the editor position within its parent.
459    * @param {number} x - x-translation in screen coordinates.
460    * @param {number} y - y-translation in screen coordinates.
461    */
462   translate(x, y) {
463     // We don't change the initial position because the move here hasn't been
464     // done by the user.
465     this.#translate(this.parentDimensions, x, y);
466   }
467 
468   /**
469    * Translate the editor position within its page and adjust the scroll
470    * in order to have the editor in the view.
471    * @param {number} x - x-translation in page coordinates.
472    * @param {number} y - y-translation in page coordinates.
473    */
474   translateInPage(x, y) {
475     this.#initialPosition ||= [this.x, this.y];
476     this.#translate(this.pageDimensions, x, y);
477     this.div.scrollIntoView({ block: "nearest" });
478   }
479 
480   drag(tx, ty) {
481     this.#initialPosition ||= [this.x, this.y];
482     const [parentWidth, parentHeight] = this.parentDimensions;
483     this.x += tx / parentWidth;
484     this.y += ty / parentHeight;
485     if (this.parent && (this.x < 0 || this.x > 1 || this.y < 0 || this.y > 1)) {
486       // It's possible to not have a parent: for example, when the user is
487       // dragging all the selected editors but this one on a page which has been
488       // destroyed.
489       // It's why we need to check for it. In such a situation, it isn't really
490       // a problem to not find a new parent: it's something which is related to
491       // what the user is seeing, hence it depends on how pages are layed out.
492 
493       // The element will be outside of its parent so change the parent.
494       const { x, y } = this.div.getBoundingClientRect();
495       if (this.parent.findNewParent(this, x, y)) {
496         this.x -= Math.floor(this.x);
497         this.y -= Math.floor(this.y);
498       }
499     }
500 
501     // The editor can be moved wherever the user wants, so we don't need to fix
502     // the position: it'll be done when the user will release the mouse button.
503 
504     let { x, y } = this;
505     const [bx, by] = this.getBaseTranslation();
506     x += bx;
507     y += by;
508 
509     this.div.style.left = `${(100 * x).toFixed(2)}%`;
510     this.div.style.top = `${(100 * y).toFixed(2)}%`;
511     this.div.scrollIntoView({ block: "nearest" });
512   }
513 
514   get _hasBeenMoved() {
515     return (
516       !!this.#initialPosition &&
517       (this.#initialPosition[0] !== this.x ||
518         this.#initialPosition[1] !== this.y)
519     );
520   }
521 
522   /**
523    * Get the translation to take into account the editor border.
524    * The CSS engine positions the element by taking the border into account so
525    * we must apply the opposite translation to have the editor in the right
526    * position.
527    * @returns {Array<number>}
528    */
529   getBaseTranslation() {
530     const [parentWidth, parentHeight] = this.parentDimensions;
531     const { _borderLineWidth } = AnnotationEditor;
532     const x = _borderLineWidth / parentWidth;
533     const y = _borderLineWidth / parentHeight;
534     switch (this.rotation) {
535       case 90:
536         return [-x, y];
537       case 180:
538         return [x, y];
539       case 270:
540         return [x, -y];
541       default:
542         return [-x, -y];
543     }
544   }
545 
546   /**
547    * @returns {boolean} true if position must be fixed (i.e. make the x and y
548    * living in the page).
549    */
550   get _mustFixPosition() {
551     return true;
552   }
553 
554   /**
555    * Fix the position of the editor in order to keep it inside its parent page.
556    * @param {number} [rotation] - the rotation of the page.
557    */
558   fixAndSetPosition(rotation = this.rotation) {
559     const [pageWidth, pageHeight] = this.pageDimensions;
560     let { x, y, width, height } = this;
561     width *= pageWidth;
562     height *= pageHeight;
563     x *= pageWidth;
564     y *= pageHeight;
565 
566     if (this._mustFixPosition) {
567       switch (rotation) {
568         case 0:
569           x = Math.max(0, Math.min(pageWidth - width, x));
570           y = Math.max(0, Math.min(pageHeight - height, y));
571           break;
572         case 90:
573           x = Math.max(0, Math.min(pageWidth - height, x));
574           y = Math.min(pageHeight, Math.max(width, y));
575           break;
576         case 180:
577           x = Math.min(pageWidth, Math.max(width, x));
578           y = Math.min(pageHeight, Math.max(height, y));
579           break;
580         case 270:
581           x = Math.min(pageWidth, Math.max(height, x));
582           y = Math.max(0, Math.min(pageHeight - width, y));
583           break;
584       }
585     }
586 
587     this.x = x /= pageWidth;
588     this.y = y /= pageHeight;
589 
590     const [bx, by] = this.getBaseTranslation();
591     x += bx;
592     y += by;
593 
594     const { style } = this.div;
595     style.left = `${(100 * x).toFixed(2)}%`;
596     style.top = `${(100 * y).toFixed(2)}%`;
597 
598     this.moveInDOM();
599   }
600 
601   static #rotatePoint(x, y, angle) {
602     switch (angle) {
603       case 90:
604         return [y, -x];
605       case 180:
606         return [-x, -y];
607       case 270:
608         return [-y, x];
609       default:
610         return [x, y];
611     }
612   }
613 
614   /**
615    * Convert a screen translation into a page one.
616    * @param {number} x
617    * @param {number} y
618    */
619   screenToPageTranslation(x, y) {
620     return AnnotationEditor.#rotatePoint(x, y, this.parentRotation);
621   }
622 
623   /**
624    * Convert a page translation into a screen one.
625    * @param {number} x
626    * @param {number} y
627    */
628   pageTranslationToScreen(x, y) {
629     return AnnotationEditor.#rotatePoint(x, y, 360 - this.parentRotation);
630   }
631 
632   #getRotationMatrix(rotation) {
633     switch (rotation) {
634       case 90: {
635         const [pageWidth, pageHeight] = this.pageDimensions;
636         return [0, -pageWidth / pageHeight, pageHeight / pageWidth, 0];
637       }
638       case 180:
639         return [-1, 0, 0, -1];
640       case 270: {
641         const [pageWidth, pageHeight] = this.pageDimensions;
642         return [0, pageWidth / pageHeight, -pageHeight / pageWidth, 0];
643       }
644       default:
645         return [1, 0, 0, 1];
646     }
647   }
648 
649   get parentScale() {
650     return this._uiManager.viewParameters.realScale;
651   }
652 
653   get parentRotation() {
654     return (this._uiManager.viewParameters.rotation + this.pageRotation) % 360;
655   }
656 
657   get parentDimensions() {
658     const {
659       parentScale,
660       pageDimensions: [pageWidth, pageHeight],
661     } = this;
662     const scaledWidth = pageWidth * parentScale;
663     const scaledHeight = pageHeight * parentScale;
664     return FeatureTest.isCSSRoundSupported
665       ? [Math.round(scaledWidth), Math.round(scaledHeight)]
666       : [scaledWidth, scaledHeight];
667   }
668 
669   /**
670    * Set the dimensions of this editor.
671    * @param {number} width
672    * @param {number} height
673    */
674   setDims(width, height) {
675     const [parentWidth, parentHeight] = this.parentDimensions;
676     this.div.style.width = `${((100 * width) / parentWidth).toFixed(2)}%`;
677     if (!this.#keepAspectRatio) {
678       this.div.style.height = `${((100 * height) / parentHeight).toFixed(2)}%`;
679     }
680   }
681 
682   fixDims() {
683     const { style } = this.div;
684     const { height, width } = style;
685     const widthPercent = width.endsWith("%");
686     const heightPercent = !this.#keepAspectRatio && height.endsWith("%");
687     if (widthPercent && heightPercent) {
688       return;
689     }
690 
691     const [parentWidth, parentHeight] = this.parentDimensions;
692     if (!widthPercent) {
693       style.width = `${((100 * parseFloat(width)) / parentWidth).toFixed(2)}%`;
694     }
695     if (!this.#keepAspectRatio && !heightPercent) {
696       style.height = `${((100 * parseFloat(height)) / parentHeight).toFixed(
697         2
698       )}%`;
699     }
700   }
701 
702   /**
703    * Get the translation used to position this editor when it's created.
704    * @returns {Array<number>}
705    */
706   getInitialTranslation() {
707     return [0, 0];
708   }
709 
710   #createResizers() {
711     if (this.#resizersDiv) {
712       return;
713     }
714     this.#resizersDiv = document.createElement("div");
715     this.#resizersDiv.classList.add("resizers");
716     // When the resizers are used with the keyboard, they're focusable, hence
717     // we want to have them in this order (top left, top middle, top right, ...)
718     // in the DOM to have the focus order correct.
719     const classes = this._willKeepAspectRatio
720       ? ["topLeft", "topRight", "bottomRight", "bottomLeft"]
721       : [
722           "topLeft",
723           "topMiddle",
724           "topRight",
725           "middleRight",
726           "bottomRight",
727           "bottomMiddle",
728           "bottomLeft",
729           "middleLeft",
730         ];
731     const signal = this._uiManager._signal;
732     for (const name of classes) {
733       const div = document.createElement("div");
734       this.#resizersDiv.append(div);
735       div.classList.add("resizer", name);
736       div.setAttribute("data-resizer-name", name);
737       div.addEventListener(
738         "pointerdown",
739         this.#resizerPointerdown.bind(this, name),
740         { signal }
741       );
742       div.addEventListener("contextmenu", noContextMenu, { signal });
743       div.tabIndex = -1;
744     }
745     this.div.prepend(this.#resizersDiv);
746   }
747 
748   #resizerPointerdown(name, event) {
749     event.preventDefault();
750     const { isMac } = FeatureTest.platform;
751     if (event.button !== 0 || (event.ctrlKey && isMac)) {
752       return;
753     }
754 
755     this.#altText?.toggle(false);
756 
757     const savedDraggable = this._isDraggable;
758     this._isDraggable = false;
759 
760     const ac = new AbortController();
761     const signal = this._uiManager.combinedSignal(ac);
762 
763     this.parent.togglePointerEvents(false);
764     window.addEventListener(
765       "pointermove",
766       this.#resizerPointermove.bind(this, name),
767       { passive: true, capture: true, signal }
768     );
769     window.addEventListener("contextmenu", noContextMenu, { signal });
770     const savedX = this.x;
771     const savedY = this.y;
772     const savedWidth = this.width;
773     const savedHeight = this.height;
774     const savedParentCursor = this.parent.div.style.cursor;
775     const savedCursor = this.div.style.cursor;
776     this.div.style.cursor = this.parent.div.style.cursor =
777       window.getComputedStyle(event.target).cursor;
778 
779     const pointerUpCallback = () => {
780       ac.abort();
781       this.parent.togglePointerEvents(true);
782       this.#altText?.toggle(true);
783       this._isDraggable = savedDraggable;
784       this.parent.div.style.cursor = savedParentCursor;
785       this.div.style.cursor = savedCursor;
786 
787       this.#addResizeToUndoStack(savedX, savedY, savedWidth, savedHeight);
788     };
789     window.addEventListener("pointerup", pointerUpCallback, { signal });
790     // If the user switches to another window (with alt+tab), then we end the
791     // resize session.
792     window.addEventListener("blur", pointerUpCallback, { signal });
793   }
794 
795   #addResizeToUndoStack(savedX, savedY, savedWidth, savedHeight) {
796     const newX = this.x;
797     const newY = this.y;
798     const newWidth = this.width;
799     const newHeight = this.height;
800     if (
801       newX === savedX &&
802       newY === savedY &&
803       newWidth === savedWidth &&
804       newHeight === savedHeight
805     ) {
806       return;
807     }
808 
809     this.addCommands({
810       cmd: () => {
811         this.width = newWidth;
812         this.height = newHeight;
813         this.x = newX;
814         this.y = newY;
815         const [parentWidth, parentHeight] = this.parentDimensions;
816         this.setDims(parentWidth * newWidth, parentHeight * newHeight);
817         this.fixAndSetPosition();
818       },
819       undo: () => {
820         this.width = savedWidth;
821         this.height = savedHeight;
822         this.x = savedX;
823         this.y = savedY;
824         const [parentWidth, parentHeight] = this.parentDimensions;
825         this.setDims(parentWidth * savedWidth, parentHeight * savedHeight);
826         this.fixAndSetPosition();
827       },
828       mustExec: true,
829     });
830   }
831 
832   #resizerPointermove(name, event) {
833     const [parentWidth, parentHeight] = this.parentDimensions;
834     const savedX = this.x;
835     const savedY = this.y;
836     const savedWidth = this.width;
837     const savedHeight = this.height;
838     const minWidth = AnnotationEditor.MIN_SIZE / parentWidth;
839     const minHeight = AnnotationEditor.MIN_SIZE / parentHeight;
840 
841     // 10000 because we multiply by 100 and use toFixed(2) in fixAndSetPosition.
842     // Without rounding, the positions of the corners other than the top left
843     // one can be slightly wrong.
844     const round = x => Math.round(x * 10000) / 10000;
845     const rotationMatrix = this.#getRotationMatrix(this.rotation);
846     const transf = (x, y) => [
847       rotationMatrix[0] * x + rotationMatrix[2] * y,
848       rotationMatrix[1] * x + rotationMatrix[3] * y,
849     ];
850     const invRotationMatrix = this.#getRotationMatrix(360 - this.rotation);
851     const invTransf = (x, y) => [
852       invRotationMatrix[0] * x + invRotationMatrix[2] * y,
853       invRotationMatrix[1] * x + invRotationMatrix[3] * y,
854     ];
855     let getPoint;
856     let getOpposite;
857     let isDiagonal = false;
858     let isHorizontal = false;
859 
860     switch (name) {
861       case "topLeft":
862         isDiagonal = true;
863         getPoint = (w, h) => [0, 0];
864         getOpposite = (w, h) => [w, h];
865         break;
866       case "topMiddle":
867         getPoint = (w, h) => [w / 2, 0];
868         getOpposite = (w, h) => [w / 2, h];
869         break;
870       case "topRight":
871         isDiagonal = true;
872         getPoint = (w, h) => [w, 0];
873         getOpposite = (w, h) => [0, h];
874         break;
875       case "middleRight":
876         isHorizontal = true;
877         getPoint = (w, h) => [w, h / 2];
878         getOpposite = (w, h) => [0, h / 2];
879         break;
880       case "bottomRight":
881         isDiagonal = true;
882         getPoint = (w, h) => [w, h];
883         getOpposite = (w, h) => [0, 0];
884         break;
885       case "bottomMiddle":
886         getPoint = (w, h) => [w / 2, h];
887         getOpposite = (w, h) => [w / 2, 0];
888         break;
889       case "bottomLeft":
890         isDiagonal = true;
891         getPoint = (w, h) => [0, h];
892         getOpposite = (w, h) => [w, 0];
893         break;
894       case "middleLeft":
895         isHorizontal = true;
896         getPoint = (w, h) => [0, h / 2];
897         getOpposite = (w, h) => [w, h / 2];
898         break;
899     }
900 
901     const point = getPoint(savedWidth, savedHeight);
902     const oppositePoint = getOpposite(savedWidth, savedHeight);
903     let transfOppositePoint = transf(...oppositePoint);
904     const oppositeX = round(savedX + transfOppositePoint[0]);
905     const oppositeY = round(savedY + transfOppositePoint[1]);
906     let ratioX = 1;
907     let ratioY = 1;
908 
909     let [deltaX, deltaY] = this.screenToPageTranslation(
910       event.movementX,
911       event.movementY
912     );
913     [deltaX, deltaY] = invTransf(deltaX / parentWidth, deltaY / parentHeight);
914 
915     if (isDiagonal) {
916       const oldDiag = Math.hypot(savedWidth, savedHeight);
917       ratioX = ratioY = Math.max(
918         Math.min(
919           Math.hypot(
920             oppositePoint[0] - point[0] - deltaX,
921             oppositePoint[1] - point[1] - deltaY
922           ) / oldDiag,
923           // Avoid the editor to be larger than the page.
924           1 / savedWidth,
925           1 / savedHeight
926         ),
927         // Avoid the editor to be smaller than the minimum size.
928         minWidth / savedWidth,
929         minHeight / savedHeight
930       );
931     } else if (isHorizontal) {
932       ratioX =
933         Math.max(
934           minWidth,
935           Math.min(1, Math.abs(oppositePoint[0] - point[0] - deltaX))
936         ) / savedWidth;
937     } else {
938       ratioY =
939         Math.max(
940           minHeight,
941           Math.min(1, Math.abs(oppositePoint[1] - point[1] - deltaY))
942         ) / savedHeight;
943     }
944 
945     const newWidth = round(savedWidth * ratioX);
946     const newHeight = round(savedHeight * ratioY);
947     transfOppositePoint = transf(...getOpposite(newWidth, newHeight));
948     const newX = oppositeX - transfOppositePoint[0];
949     const newY = oppositeY - transfOppositePoint[1];
950 
951     this.width = newWidth;
952     this.height = newHeight;
953     this.x = newX;
954     this.y = newY;
955 
956     this.setDims(parentWidth * newWidth, parentHeight * newHeight);
957     this.fixAndSetPosition();
958   }
959 
960   /**
961    * Called when the alt text dialog is closed.
962    */
963   altTextFinish() {
964     this.#altText?.finish();
965   }
966 
967   /**
968    * Add a toolbar for this editor.
969    * @returns {Promise<EditorToolbar|null>}
970    */
971   async addEditToolbar() {
972     if (this._editToolbar || this.#isInEditMode) {
973       return this._editToolbar;
974     }
975     this._editToolbar = new EditorToolbar(this);
976     this.div.append(this._editToolbar.render());
977     if (this.#altText) {
978       await this._editToolbar.addAltText(this.#altText);
979     }
980 
981     return this._editToolbar;
982   }
983 
984   removeEditToolbar() {
985     if (!this._editToolbar) {
986       return;
987     }
988     this._editToolbar.remove();
989     this._editToolbar = null;
990 
991     // We destroy the alt text but we don't null it because we want to be able
992     // to restore it in case the user undoes the deletion.
993     this.#altText?.destroy();
994   }
995 
996   getClientDimensions() {
997     return this.div.getBoundingClientRect();
998   }
999 
1000   async addAltTextButton() {
1001     if (this.#altText) {
1002       return;
1003     }
1004     AltText.initialize(AnnotationEditor._l10nPromise);
1005     this.#altText = new AltText(this);
1006     if (this.#accessibilityData) {
1007       this.#altText.data = this.#accessibilityData;
1008       this.#accessibilityData = null;
1009     }
1010     await this.addEditToolbar();
1011   }
1012 
1013   get altTextData() {
1014     return this.#altText?.data;
1015   }
1016 
1017   /**
1018    * Set the alt text data.
1019    */
1020   set altTextData(data) {
1021     if (!this.#altText) {
1022       return;
1023     }
1024     this.#altText.data = data;
1025   }
1026 
1027   get guessedAltText() {
1028     return this.#altText?.guessedText;
1029   }
1030 
1031   async setGuessedAltText(text) {
1032     await this.#altText?.setGuessedText(text);
1033   }
1034 
1035   serializeAltText(isForCopying) {
1036     return this.#altText?.serialize(isForCopying);
1037   }
1038 
1039   hasAltText() {
1040     return !!this.#altText && !this.#altText.isEmpty();
1041   }
1042 
1043   hasAltTextData() {
1044     return this.#altText?.hasData() ?? false;
1045   }
1046 
1047   /**
1048    * Render this editor in a div.
1049    * @returns {HTMLDivElement | null}
1050    */
1051   render() {
1052     this.div = document.createElement("div");
1053     this.div.setAttribute("data-editor-rotation", (360 - this.rotation) % 360);
1054     this.div.className = this.name;
1055     this.div.setAttribute("id", this.id);
1056     this.div.tabIndex = this.#disabled ? -1 : 0;
1057     if (!this._isVisible) {
1058       this.div.classList.add("hidden");
1059     }
1060 
1061     this.setInForeground();
1062     this.#addFocusListeners();
1063 
1064     const [parentWidth, parentHeight] = this.parentDimensions;
1065     if (this.parentRotation % 180 !== 0) {
1066       this.div.style.maxWidth = `${((100 * parentHeight) / parentWidth).toFixed(
1067         2
1068       )}%`;
1069       this.div.style.maxHeight = `${(
1070         (100 * parentWidth) /
1071         parentHeight
1072       ).toFixed(2)}%`;
1073     }
1074 
1075     const [tx, ty] = this.getInitialTranslation();
1076     this.translate(tx, ty);
1077 
1078     bindEvents(this, this.div, ["pointerdown"]);
1079 
1080     return this.div;
1081   }
1082 
1083   /**
1084    * Onpointerdown callback.
1085    * @param {PointerEvent} event
1086    */
1087   pointerdown(event) {
1088     const { isMac } = FeatureTest.platform;
1089     if (event.button !== 0 || (event.ctrlKey && isMac)) {
1090       // Avoid to focus this editor because of a non-left click.
1091       event.preventDefault();
1092       return;
1093     }
1094 
1095     this.#hasBeenClicked = true;
1096 
1097     if (this._isDraggable) {
1098       this.#setUpDragSession(event);
1099       return;
1100     }
1101 
1102     this.#selectOnPointerEvent(event);
1103   }
1104 
1105   #selectOnPointerEvent(event) {
1106     const { isMac } = FeatureTest.platform;
1107     if (
1108       (event.ctrlKey && !isMac) ||
1109       event.shiftKey ||
1110       (event.metaKey && isMac)
1111     ) {
1112       this.parent.toggleSelected(this);
1113     } else {
1114       this.parent.setSelected(this);
1115     }
1116   }
1117 
1118   #setUpDragSession(event) {
1119     const isSelected = this._uiManager.isSelected(this);
1120     this._uiManager.setUpDragSession();
1121 
1122     const ac = new AbortController();
1123     const signal = this._uiManager.combinedSignal(ac);
1124 
1125     if (isSelected) {
1126       this.div.classList.add("moving");
1127       this.#prevDragX = event.clientX;
1128       this.#prevDragY = event.clientY;
1129       const pointerMoveCallback = e => {
1130         const { clientX: x, clientY: y } = e;
1131         const [tx, ty] = this.screenToPageTranslation(
1132           x - this.#prevDragX,
1133           y - this.#prevDragY
1134         );
1135         this.#prevDragX = x;
1136         this.#prevDragY = y;
1137         this._uiManager.dragSelectedEditors(tx, ty);
1138       };
1139       window.addEventListener("pointermove", pointerMoveCallback, {
1140         passive: true,
1141         capture: true,
1142         signal,
1143       });
1144     }
1145 
1146     const pointerUpCallback = () => {
1147       ac.abort();
1148       if (isSelected) {
1149         this.div.classList.remove("moving");
1150       }
1151 
1152       this.#hasBeenClicked = false;
1153       if (!this._uiManager.endDragSession()) {
1154         this.#selectOnPointerEvent(event);
1155       }
1156     };
1157     window.addEventListener("pointerup", pointerUpCallback, { signal });
1158     // If the user is using alt+tab during the dragging session, the pointerup
1159     // event could be not fired, but a blur event is fired so we can use it in
1160     // order to interrupt the dragging session.
1161     window.addEventListener("blur", pointerUpCallback, { signal });
1162   }
1163 
1164   moveInDOM() {
1165     // Moving the editor in the DOM can be expensive, so we wait a bit before.
1166     // It's important to not block the UI (for example when changing the font
1167     // size in a FreeText).
1168     if (this.#moveInDOMTimeout) {
1169       clearTimeout(this.#moveInDOMTimeout);
1170     }
1171     this.#moveInDOMTimeout = setTimeout(() => {
1172       this.#moveInDOMTimeout = null;
1173       this.parent?.moveEditorInDOM(this);
1174     }, 0);
1175   }
1176 
1177   _setParentAndPosition(parent, x, y) {
1178     parent.changeParent(this);
1179     this.x = x;
1180     this.y = y;
1181     this.fixAndSetPosition();
1182   }
1183 
1184   /**
1185    * Convert the current rect into a page one.
1186    * @param {number} tx - x-translation in screen coordinates.
1187    * @param {number} ty - y-translation in screen coordinates.
1188    * @param {number} [rotation] - the rotation of the page.
1189    */
1190   getRect(tx, ty, rotation = this.rotation) {
1191     const scale = this.parentScale;
1192     const [pageWidth, pageHeight] = this.pageDimensions;
1193     const [pageX, pageY] = this.pageTranslation;
1194     const shiftX = tx / scale;
1195     const shiftY = ty / scale;
1196     const x = this.x * pageWidth;
1197     const y = this.y * pageHeight;
1198     const width = this.width * pageWidth;
1199     const height = this.height * pageHeight;
1200 
1201     switch (rotation) {
1202       case 0:
1203         return [
1204           x + shiftX + pageX,
1205           pageHeight - y - shiftY - height + pageY,
1206           x + shiftX + width + pageX,
1207           pageHeight - y - shiftY + pageY,
1208         ];
1209       case 90:
1210         return [
1211           x + shiftY + pageX,
1212           pageHeight - y + shiftX + pageY,
1213           x + shiftY + height + pageX,
1214           pageHeight - y + shiftX + width + pageY,
1215         ];
1216       case 180:
1217         return [
1218           x - shiftX - width + pageX,
1219           pageHeight - y + shiftY + pageY,
1220           x - shiftX + pageX,
1221           pageHeight - y + shiftY + height + pageY,
1222         ];
1223       case 270:
1224         return [
1225           x - shiftY - height + pageX,
1226           pageHeight - y - shiftX - width + pageY,
1227           x - shiftY + pageX,
1228           pageHeight - y - shiftX + pageY,
1229         ];
1230       default:
1231         throw new Error("Invalid rotation");
1232     }
1233   }
1234 
1235   getRectInCurrentCoords(rect, pageHeight) {
1236     const [x1, y1, x2, y2] = rect;
1237 
1238     const width = x2 - x1;
1239     const height = y2 - y1;
1240 
1241     switch (this.rotation) {
1242       case 0:
1243         return [x1, pageHeight - y2, width, height];
1244       case 90:
1245         return [x1, pageHeight - y1, height, width];
1246       case 180:
1247         return [x2, pageHeight - y1, width, height];
1248       case 270:
1249         return [x2, pageHeight - y2, height, width];
1250       default:
1251         throw new Error("Invalid rotation");
1252     }
1253   }
1254 
1255   /**
1256    * Executed once this editor has been rendered.
1257    */
1258   onceAdded() {}
1259 
1260   /**
1261    * Check if the editor contains something.
1262    * @returns {boolean}
1263    */
1264   isEmpty() {
1265     return false;
1266   }
1267 
1268   /**
1269    * Enable edit mode.
1270    */
1271   enableEditMode() {
1272     this.#isInEditMode = true;
1273   }
1274 
1275   /**
1276    * Disable edit mode.
1277    */
1278   disableEditMode() {
1279     this.#isInEditMode = false;
1280   }
1281 
1282   /**
1283    * Check if the editor is edited.
1284    * @returns {boolean}
1285    */
1286   isInEditMode() {
1287     return this.#isInEditMode;
1288   }
1289 
1290   /**
1291    * If it returns true, then this editor handles the keyboard
1292    * events itself.
1293    * @returns {boolean}
1294    */
1295   shouldGetKeyboardEvents() {
1296     return this.#isResizerEnabledForKeyboard;
1297   }
1298 
1299   /**
1300    * Check if this editor needs to be rebuilt or not.
1301    * @returns {boolean}
1302    */
1303   needsToBeRebuilt() {
1304     return this.div && !this.isAttachedToDOM;
1305   }
1306 
1307   #addFocusListeners() {
1308     if (this.#focusAC || !this.div) {
1309       return;
1310     }
1311     this.#focusAC = new AbortController();
1312     const signal = this._uiManager.combinedSignal(this.#focusAC);
1313 
1314     this.div.addEventListener("focusin", this.focusin.bind(this), { signal });
1315     this.div.addEventListener("focusout", this.focusout.bind(this), { signal });
1316   }
1317 
1318   /**
1319    * Rebuild the editor in case it has been removed on undo.
1320    *
1321    * To implement in subclasses.
1322    */
1323   rebuild() {
1324     this.#addFocusListeners();
1325   }
1326 
1327   /**
1328    * Rotate the editor.
1329    * @param {number} angle
1330    */
1331   rotate(_angle) {}
1332 
1333   /**
1334    * Serialize the editor.
1335    * The result of the serialization will be used to construct a
1336    * new annotation to add to the pdf document.
1337    *
1338    * To implement in subclasses.
1339    * @param {boolean} [isForCopying]
1340    * @param {Object | null} [context]
1341    * @returns {Object | null}
1342    */
1343   serialize(isForCopying = false, context = null) {
1344     unreachable("An editor must be serializable");
1345   }
1346 
1347   /**
1348    * Deserialize the editor.
1349    * The result of the deserialization is a new editor.
1350    *
1351    * @param {Object} data
1352    * @param {AnnotationEditorLayer} parent
1353    * @param {AnnotationEditorUIManager} uiManager
1354    * @returns {AnnotationEditor | null}
1355    */
1356   static deserialize(data, parent, uiManager) {
1357     const editor = new this.prototype.constructor({
1358       parent,
1359       id: parent.getNextId(),
1360       uiManager,
1361     });
1362     editor.rotation = data.rotation;
1363     editor.#accessibilityData = data.accessibilityData;
1364 
1365     const [pageWidth, pageHeight] = editor.pageDimensions;
1366     const [x, y, width, height] = editor.getRectInCurrentCoords(
1367       data.rect,
1368       pageHeight
1369     );
1370     editor.x = x / pageWidth;
1371     editor.y = y / pageHeight;
1372     editor.width = width / pageWidth;
1373     editor.height = height / pageHeight;
1374 
1375     return editor;
1376   }
1377 
1378   /**
1379    * Check if an existing annotation associated with this editor has been
1380    * modified.
1381    * @returns {boolean}
1382    */
1383   get hasBeenModified() {
1384     return (
1385       !!this.annotationElementId && (this.deleted || this.serialize() !== null)
1386     );
1387   }
1388 
1389   /**
1390    * Remove this editor.
1391    * It's used on ctrl+backspace action.
1392    */
1393   remove() {
1394     this.#focusAC?.abort();
1395     this.#focusAC = null;
1396 
1397     if (!this.isEmpty()) {
1398       // The editor is removed but it can be back at some point thanks to
1399       // undo/redo so we must commit it before.
1400       this.commit();
1401     }
1402     if (this.parent) {
1403       this.parent.remove(this);
1404     } else {
1405       this._uiManager.removeEditor(this);
1406     }
1407 
1408     if (this.#moveInDOMTimeout) {
1409       clearTimeout(this.#moveInDOMTimeout);
1410       this.#moveInDOMTimeout = null;
1411     }
1412     this.#stopResizing();
1413     this.removeEditToolbar();
1414     if (this.#telemetryTimeouts) {
1415       for (const timeout of this.#telemetryTimeouts.values()) {
1416         clearTimeout(timeout);
1417       }
1418       this.#telemetryTimeouts = null;
1419     }
1420     this.parent = null;
1421   }
1422 
1423   /**
1424    * @returns {boolean} true if this editor can be resized.
1425    */
1426   get isResizable() {
1427     return false;
1428   }
1429 
1430   /**
1431    * Add the resizers to this editor.
1432    */
1433   makeResizable() {
1434     if (this.isResizable) {
1435       this.#createResizers();
1436       this.#resizersDiv.classList.remove("hidden");
1437       bindEvents(this, this.div, ["keydown"]);
1438     }
1439   }
1440 
1441   get toolbarPosition() {
1442     return null;
1443   }
1444 
1445   /**
1446    * onkeydown callback.
1447    * @param {KeyboardEvent} event
1448    */
1449   keydown(event) {
1450     if (
1451       !this.isResizable ||
1452       event.target !== this.div ||
1453       event.key !== "Enter"
1454     ) {
1455       return;
1456     }
1457     this._uiManager.setSelected(this);
1458     this.#savedDimensions = {
1459       savedX: this.x,
1460       savedY: this.y,
1461       savedWidth: this.width,
1462       savedHeight: this.height,
1463     };
1464     const children = this.#resizersDiv.children;
1465     if (!this.#allResizerDivs) {
1466       this.#allResizerDivs = Array.from(children);
1467       const boundResizerKeydown = this.#resizerKeydown.bind(this);
1468       const boundResizerBlur = this.#resizerBlur.bind(this);
1469       const signal = this._uiManager._signal;
1470       for (const div of this.#allResizerDivs) {
1471         const name = div.getAttribute("data-resizer-name");
1472         div.setAttribute("role", "spinbutton");
1473         div.addEventListener("keydown", boundResizerKeydown, { signal });
1474         div.addEventListener("blur", boundResizerBlur, { signal });
1475         div.addEventListener("focus", this.#resizerFocus.bind(this, name), {
1476           signal,
1477         });
1478         div.setAttribute("data-l10n-id", AnnotationEditor._l10nResizer[name]);
1479       }
1480     }
1481 
1482     // We want to have the resizers in the visual order, so we move the first
1483     // (top-left) to the right place.
1484     const first = this.#allResizerDivs[0];
1485     let firstPosition = 0;
1486     for (const div of children) {
1487       if (div === first) {
1488         break;
1489       }
1490       firstPosition++;
1491     }
1492     const nextFirstPosition =
1493       (((360 - this.rotation + this.parentRotation) % 360) / 90) *
1494       (this.#allResizerDivs.length / 4);
1495 
1496     if (nextFirstPosition !== firstPosition) {
1497       // We need to reorder the resizers in the DOM in order to have the focus
1498       // on the top-left one.
1499       if (nextFirstPosition < firstPosition) {
1500         for (let i = 0; i < firstPosition - nextFirstPosition; i++) {
1501           this.#resizersDiv.append(this.#resizersDiv.firstChild);
1502         }
1503       } else if (nextFirstPosition > firstPosition) {
1504         for (let i = 0; i < nextFirstPosition - firstPosition; i++) {
1505           this.#resizersDiv.firstChild.before(this.#resizersDiv.lastChild);
1506         }
1507       }
1508 
1509       let i = 0;
1510       for (const child of children) {
1511         const div = this.#allResizerDivs[i++];
1512         const name = div.getAttribute("data-resizer-name");
1513         child.setAttribute("data-l10n-id", AnnotationEditor._l10nResizer[name]);
1514       }
1515     }
1516 
1517     this.#setResizerTabIndex(0);
1518     this.#isResizerEnabledForKeyboard = true;
1519     this.#resizersDiv.firstChild.focus({ focusVisible: true });
1520     event.preventDefault();
1521     event.stopImmediatePropagation();
1522   }
1523 
1524   #resizerKeydown(event) {
1525     AnnotationEditor._resizerKeyboardManager.exec(this, event);
1526   }
1527 
1528   #resizerBlur(event) {
1529     if (
1530       this.#isResizerEnabledForKeyboard &&
1531       event.relatedTarget?.parentNode !== this.#resizersDiv
1532     ) {
1533       this.#stopResizing();
1534     }
1535   }
1536 
1537   #resizerFocus(name) {
1538     this.#focusedResizerName = this.#isResizerEnabledForKeyboard ? name : "";
1539   }
1540 
1541   #setResizerTabIndex(value) {
1542     if (!this.#allResizerDivs) {
1543       return;
1544     }
1545     for (const div of this.#allResizerDivs) {
1546       div.tabIndex = value;
1547     }
1548   }
1549 
1550   _resizeWithKeyboard(x, y) {
1551     if (!this.#isResizerEnabledForKeyboard) {
1552       return;
1553     }
1554     this.#resizerPointermove(this.#focusedResizerName, {
1555       movementX: x,
1556       movementY: y,
1557     });
1558   }
1559 
1560   #stopResizing() {
1561     this.#isResizerEnabledForKeyboard = false;
1562     this.#setResizerTabIndex(-1);
1563     if (this.#savedDimensions) {
1564       const { savedX, savedY, savedWidth, savedHeight } = this.#savedDimensions;
1565       this.#addResizeToUndoStack(savedX, savedY, savedWidth, savedHeight);
1566       this.#savedDimensions = null;
1567     }
1568   }
1569 
1570   _stopResizingWithKeyboard() {
1571     this.#stopResizing();
1572     this.div.focus();
1573   }
1574 
1575   /**
1576    * Select this editor.
1577    */
1578   select() {
1579     this.makeResizable();
1580     this.div?.classList.add("selectedEditor");
1581     if (!this._editToolbar) {
1582       this.addEditToolbar().then(() => {
1583         if (this.div?.classList.contains("selectedEditor")) {
1584           // The editor can have been unselected while we were waiting for the
1585           // edit toolbar to be created, hence we want to be sure that this
1586           // editor is still selected.
1587           this._editToolbar?.show();
1588         }
1589       });
1590       return;
1591     }
1592     this._editToolbar?.show();
1593     this.#altText?.toggleAltTextBadge(false);
1594   }
1595 
1596   /**
1597    * Unselect this editor.
1598    */
1599   unselect() {
1600     this.#resizersDiv?.classList.add("hidden");
1601     this.div?.classList.remove("selectedEditor");
1602     if (this.div?.contains(document.activeElement)) {
1603       // Don't use this.div.blur() because we don't know where the focus will
1604       // go.
1605       this._uiManager.currentLayer.div.focus({
1606         preventScroll: true,
1607       });
1608     }
1609     this._editToolbar?.hide();
1610     this.#altText?.toggleAltTextBadge(true);
1611   }
1612 
1613   /**
1614    * Update some parameters which have been changed through the UI.
1615    * @param {number} type
1616    * @param {*} value
1617    */
1618   updateParams(type, value) {}
1619 
1620   /**
1621    * When the user disables the editing mode some editors can change some of
1622    * their properties.
1623    */
1624   disableEditing() {}
1625 
1626   /**
1627    * When the user enables the editing mode some editors can change some of
1628    * their properties.
1629    */
1630   enableEditing() {}
1631 
1632   /**
1633    * The editor is about to be edited.
1634    */
1635   enterInEditMode() {}
1636 
1637   /**
1638    * @returns {HTMLElement | null} the element requiring an alt text.
1639    */
1640   getImageForAltText() {
1641     return null;
1642   }
1643 
1644   /**
1645    * Get the div which really contains the displayed content.
1646    * @returns {HTMLDivElement | undefined}
1647    */
1648   get contentDiv() {
1649     return this.div;
1650   }
1651 
1652   /**
1653    * If true then the editor is currently edited.
1654    * @type {boolean}
1655    */
1656   get isEditing() {
1657     return this.#isEditing;
1658   }
1659 
1660   /**
1661    * When set to true, it means that this editor is currently edited.
1662    * @param {boolean} value
1663    */
1664   set isEditing(value) {
1665     this.#isEditing = value;
1666     if (!this.parent) {
1667       return;
1668     }
1669     if (value) {
1670       this.parent.setSelected(this);
1671       this.parent.setActiveEditor(this);
1672     } else {
1673       this.parent.setActiveEditor(null);
1674     }
1675   }
1676 
1677   /**
1678    * Set the aspect ratio to use when resizing.
1679    * @param {number} width
1680    * @param {number} height
1681    */
1682   setAspectRatio(width, height) {
1683     this.#keepAspectRatio = true;
1684     const aspectRatio = width / height;
1685     const { style } = this.div;
1686     style.aspectRatio = aspectRatio;
1687     style.height = "auto";
1688   }
1689 
1690   static get MIN_SIZE() {
1691     return 16;
1692   }
1693 
1694   static canCreateNewEmptyEditor() {
1695     return true;
1696   }
1697 
1698   /**
1699    * Get the data to report to the telemetry when the editor is added.
1700    * @returns {Object}
1701    */
1702   get telemetryInitialData() {
1703     return { action: "added" };
1704   }
1705 
1706   /**
1707    * The telemetry data to use when saving/printing.
1708    * @returns {Object|null}
1709    */
1710   get telemetryFinalData() {
1711     return null;
1712   }
1713 
1714   _reportTelemetry(data, mustWait = false) {
1715     if (mustWait) {
1716       this.#telemetryTimeouts ||= new Map();
1717       const { action } = data;
1718       let timeout = this.#telemetryTimeouts.get(action);
1719       if (timeout) {
1720         clearTimeout(timeout);
1721       }
1722       timeout = setTimeout(() => {
1723         this._reportTelemetry(data);
1724         this.#telemetryTimeouts.delete(action);
1725         if (this.#telemetryTimeouts.size === 0) {
1726           this.#telemetryTimeouts = null;
1727         }
1728       }, AnnotationEditor._telemetryTimeout);
1729       this.#telemetryTimeouts.set(action, timeout);
1730       return;
1731     }
1732     data.type ||= this.editorType;
1733     this._uiManager._eventBus.dispatch("reporttelemetry", {
1734       source: this,
1735       details: {
1736         type: "editing",
1737         data,
1738       },
1739     });
1740   }
1741 
1742   /**
1743    * Show or hide this editor.
1744    * @param {boolean|undefined} visible
1745    */
1746   show(visible = this._isVisible) {
1747     this.div.classList.toggle("hidden", !visible);
1748     this._isVisible = visible;
1749   }
1750 
1751   enable() {
1752     if (this.div) {
1753       this.div.tabIndex = 0;
1754     }
1755     this.#disabled = false;
1756   }
1757 
1758   disable() {
1759     if (this.div) {
1760       this.div.tabIndex = -1;
1761     }
1762     this.#disabled = true;
1763   }
1764 
1765   /**
1766    * Render an annotation in the annotation layer.
1767    * @param {Object} annotation
1768    * @returns {HTMLElement}
1769    */
1770   renderAnnotationElement(annotation) {
1771     let content = annotation.container.querySelector(".annotationContent");
1772     if (!content) {
1773       content = document.createElement("div");
1774       content.classList.add("annotationContent", this.editorType);
1775       annotation.container.prepend(content);
1776     } else if (content.nodeName === "CANVAS") {
1777       const canvas = content;
1778       content = document.createElement("div");
1779       content.classList.add("annotationContent", this.editorType);
1780       canvas.before(content);
1781     }
1782 
1783     return content;
1784   }
1785 
1786   resetAnnotationElement(annotation) {
1787     const { firstChild } = annotation.container;
1788     if (
1789       firstChild.nodeName === "DIV" &&
1790       firstChild.classList.contains("annotationContent")
1791     ) {
1792       firstChild.remove();
1793     }
1794   }
1795 }
1796 
1797 // This class is used to fake an editor which has been deleted.
1798 class FakeEditor extends AnnotationEditor {
1799   constructor(params) {
1800     super(params);
1801     this.annotationElementId = params.annotationElementId;
1802     this.deleted = true;
1803   }
1804 
1805   serialize() {
1806     return {
1807       id: this.annotationElementId,
1808       deleted: true,
1809       pageIndex: this.pageIndex,
1810     };
1811   }
1812 }
1813 
1814 export { AnnotationEditor };
File:
src/display/editor/stamp.js
1 /* Copyright 2022 Mozilla Foundation
2  *
3  * Licensed under the Apache License, Version 2.0 (the "License");
4  * you may not use this file except in compliance with the License.
5  * You may obtain a copy of the License at
6  *
7  *     http://www.apache.org/licenses/LICENSE-2.0
8  *
9  * Unless required by applicable law or agreed to in writing, software
10  * distributed under the License is distributed on an "AS IS" BASIS,
11  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
12  * See the License for the specific language governing permissions and
13  * limitations under the License.
14  */
15 
16 import { AnnotationEditorType, shadow } from "../../shared/util.js";
17 import { AnnotationEditor } from "./editor.js";
18 import { PixelsPerInch } from "../display_utils.js";
19 import { StampAnnotationElement } from "../annotation_layer.js";
20 
21 /**
22  * Basic text editor in order to create a FreeTex annotation.
23  */
24 class StampEditor extends AnnotationEditor {
25   #bitmap = null;
26 
27   #bitmapId = null;
28 
29   #bitmapPromise = null;
30 
31   #bitmapUrl = null;
32 
33   #bitmapFile = null;
34 
35   #bitmapFileName = "";
36 
37   #canvas = null;
38 
39   #observer = null;
40 
41   #resizeTimeoutId = null;
42 
43   #isSvg = false;
44 
45   #hasBeenAddedInUndoStack = false;
46 
47   static _type = "stamp";
48 
49   static _editorType = AnnotationEditorType.STAMP;
50 
51   constructor(params) {
52     super({ ...params, name: "stampEditor" });
53     this.#bitmapUrl = params.bitmapUrl;
54     this.#bitmapFile = params.bitmapFile;
55   }
56 
57   /** @inheritdoc */
58   static initialize(l10n, uiManager) {
59     AnnotationEditor.initialize(l10n, uiManager);
60   }
61 
62   static get supportedTypes() {
63     // See https://developer.mozilla.org/en-US/docs/Web/Media/Formats/Image_types
64     // to know which types are supported by the browser.
65     const types = [
66       "apng",
67       "avif",
68       "bmp",
69       "gif",
70       "jpeg",
71       "png",
72       "svg+xml",
73       "webp",
74       "x-icon",
75     ];
76     return shadow(
77       this,
78       "supportedTypes",
79       types.map(type => `image/${type}`)
80     );
81   }
82 
83   static get supportedTypesStr() {
84     return shadow(this, "supportedTypesStr", this.supportedTypes.join(","));
85   }
86 
87   /** @inheritdoc */
88   static isHandlingMimeForPasting(mime) {
89     return this.supportedTypes.includes(mime);
90   }
91 
92   /** @inheritdoc */
93   static paste(item, parent) {
94     parent.pasteEditor(AnnotationEditorType.STAMP, {
95       bitmapFile: item.getAsFile(),
96     });
97   }
98 
99   /** @inheritdoc */
100   altTextFinish() {
101     if (this._uiManager.useNewAltTextFlow) {
102       this.div.hidden = false;
103     }
104     super.altTextFinish();
105   }
106 
107   /** @inheritdoc */
108   get telemetryFinalData() {
109     return {
110       type: "stamp",
111       hasAltText: !!this.altTextData?.altText,
112     };
113   }
114 
115   static computeTelemetryFinalData(data) {
116     const hasAltTextStats = data.get("hasAltText");
117     return {
118       hasAltText: hasAltTextStats.get(true) ?? 0,
119       hasNoAltText: hasAltTextStats.get(false) ?? 0,
120     };
121   }
122 
123   #getBitmapFetched(data, fromId = false) {
124     if (!data) {
125       this.remove();
126       return;
127     }
128     this.#bitmap = data.bitmap;
129     if (!fromId) {
130       this.#bitmapId = data.id;
131       this.#isSvg = data.isSvg;
132     }
133     if (data.file) {
134       this.#bitmapFileName = data.file.name;
135     }
136     this.#createCanvas();
137   }
138 
139   #getBitmapDone() {
140     this.#bitmapPromise = null;
141     this._uiManager.enableWaiting(false);
142     if (!this.#canvas) {
143       return;
144     }
145     if (
146       this._uiManager.useNewAltTextWhenAddingImage &&
147       this._uiManager.useNewAltTextFlow &&
148       this.#bitmap
149     ) {
150       this._editToolbar.hide();
151       this._uiManager.editAltText(this, /* firstTime = */ true);
152       return;
153     }
154 
155     if (
156       !this._uiManager.useNewAltTextWhenAddingImage &&
157       this._uiManager.useNewAltTextFlow &&
158       this.#bitmap
159     ) {
160       this._reportTelemetry({
161         action: "pdfjs.image.image_added",
162         data: { alt_text_modal: false, alt_text_type: "empty" },
163       });
164       try {
165         // The alt-text dialog isn't opened but we still want to guess the alt
166         // text.
167         this.mlGuessAltText();
168       } catch {}
169     }
170 
171     this.div.focus();
172   }
173 
174   async mlGuessAltText(imageData = null, updateAltTextData = true) {
175     if (this.hasAltTextData()) {
176       return null;
177     }
178 
179     const { mlManager } = this._uiManager;
180     if (!mlManager) {
181       throw new Error("No ML.");
182     }
183     if (!(await mlManager.isEnabledFor("altText"))) {
184       throw new Error("ML isn't enabled for alt text.");
185     }
186     const { data, width, height } =
187       imageData ||
188       this.copyCanvas(null, /* createImageData = */ true).imageData;
189     const response = await mlManager.guess({
190       name: "altText",
191       request: {
192         data,
193         width,
194         height,
195         channels: data.length / (width * height),
196       },
197     });
198     if (!response) {
199       throw new Error("No response from the AI service.");
200     }
201     if (response.error) {
202       throw new Error("Error from the AI service.");
203     }
204     if (response.cancel) {
205       return null;
206     }
207     if (!response.output) {
208       throw new Error("No valid response from the AI service.");
209     }
210     const altText = response.output;
211     await this.setGuessedAltText(altText);
212     if (updateAltTextData && !this.hasAltTextData()) {
213       this.altTextData = { alt: altText, decorative: false };
214     }
215     return altText;
216   }
217 
218   #getBitmap() {
219     if (this.#bitmapId) {
220       this._uiManager.enableWaiting(true);
221       this._uiManager.imageManager
222         .getFromId(this.#bitmapId)
223         .then(data => this.#getBitmapFetched(data, /* fromId = */ true))
224         .finally(() => this.#getBitmapDone());
225       return;
226     }
227 
228     if (this.#bitmapUrl) {
229       const url = this.#bitmapUrl;
230       this.#bitmapUrl = null;
231       this._uiManager.enableWaiting(true);
232       this.#bitmapPromise = this._uiManager.imageManager
233         .getFromUrl(url)
234         .then(data => this.#getBitmapFetched(data))
235         .finally(() => this.#getBitmapDone());
236       return;
237     }
238 
239     if (this.#bitmapFile) {
240       const file = this.#bitmapFile;
241       this.#bitmapFile = null;
242       this._uiManager.enableWaiting(true);
243       this.#bitmapPromise = this._uiManager.imageManager
244         .getFromFile(file)
245         .then(data => this.#getBitmapFetched(data))
246         .finally(() => this.#getBitmapDone());
247       return;
248     }
249 
250     const input = document.createElement("input");
251     if (typeof PDFJSDev !== "undefined" && PDFJSDev.test("TESTING")) {
252       input.hidden = true;
253       input.id = "stampEditorFileInput";
254       document.body.append(input);
255     }
256     input.type = "file";
257     input.accept = StampEditor.supportedTypesStr;
258     const signal = this._uiManager._signal;
259     this.#bitmapPromise = new Promise(resolve => {
260       input.addEventListener(
261         "change",
262         async () => {
263           if (!input.files || input.files.length === 0) {
264             this.remove();
265           } else {
266             this._uiManager.enableWaiting(true);
267             const data = await this._uiManager.imageManager.getFromFile(
268               input.files[0]
269             );
270             this._reportTelemetry({
271               action: "pdfjs.image.image_selected",
272               data: { alt_text_modal: this._uiManager.useNewAltTextFlow },
273             });
274             this.#getBitmapFetched(data);
275           }
276           if (typeof PDFJSDev !== "undefined" && PDFJSDev.test("TESTING")) {
277             input.remove();
278           }
279           resolve();
280         },
281         { signal }
282       );
283       input.addEventListener(
284         "cancel",
285         () => {
286           this.remove();
287           resolve();
288         },
289         { signal }
290       );
291     }).finally(() => this.#getBitmapDone());
292     if (typeof PDFJSDev === "undefined" || !PDFJSDev.test("TESTING")) {
293       input.click();
294     }
295   }
296 
297   /** @inheritdoc */
298   remove() {
299     if (this.#bitmapId) {
300       this.#bitmap = null;
301       this._uiManager.imageManager.deleteId(this.#bitmapId);
302       this.#canvas?.remove();
303       this.#canvas = null;
304       this.#observer?.disconnect();
305       this.#observer = null;
306       if (this.#resizeTimeoutId) {
307         clearTimeout(this.#resizeTimeoutId);
308         this.#resizeTimeoutId = null;
309       }
310     }
311     super.remove();
312   }
313 
314   /** @inheritdoc */
315   rebuild() {
316     if (!this.parent) {
317       // It's possible to have to rebuild an editor which is not on a visible
318       // page.
319       if (this.#bitmapId) {
320         this.#getBitmap();
321       }
322       return;
323     }
324     super.rebuild();
325     if (this.div === null) {
326       return;
327     }
328 
329     if (this.#bitmapId && this.#canvas === null) {
330       this.#getBitmap();
331     }
332 
333     if (!this.isAttachedToDOM) {
334       // At some point this editor was removed and we're rebuilting it,
335       // hence we must add it to its parent.
336       this.parent.add(this);
337     }
338   }
339 
340   /** @inheritdoc */
341   onceAdded() {
342     this._isDraggable = true;
343     this.div.focus();
344   }
345 
346   /** @inheritdoc */
347   isEmpty() {
348     return !(
349       this.#bitmapPromise ||
350       this.#bitmap ||
351       this.#bitmapUrl ||
352       this.#bitmapFile ||
353       this.#bitmapId
354     );
355   }
356 
357   /** @inheritdoc */
358   get isResizable() {
359     return true;
360   }
361 
362   /** @inheritdoc */
363   render() {
364     if (this.div) {
365       return this.div;
366     }
367 
368     let baseX, baseY;
369     if (this.width) {
370       baseX = this.x;
371       baseY = this.y;
372     }
373 
374     super.render();
375     this.div.hidden = true;
376 
377     this.addAltTextButton();
378 
379     if (this.#bitmap) {
380       this.#createCanvas();
381     } else {
382       this.#getBitmap();
383     }
384 
385     if (this.width) {
386       // This editor was created in using copy (ctrl+c).
387       const [parentWidth, parentHeight] = this.parentDimensions;
388       this.setAt(
389         baseX * parentWidth,
390         baseY * parentHeight,
391         this.width * parentWidth,
392         this.height * parentHeight
393       );
394     }
395 
396     return this.div;
397   }
398 
399   #createCanvas() {
400     const { div } = this;
401     let { width, height } = this.#bitmap;
402     const [pageWidth, pageHeight] = this.pageDimensions;
403     const MAX_RATIO = 0.75;
404     if (this.width) {
405       width = this.width * pageWidth;
406       height = this.height * pageHeight;
407     } else if (
408       width > MAX_RATIO * pageWidth ||
409       height > MAX_RATIO * pageHeight
410     ) {
411       // If the the image is too big compared to the page dimensions
412       // (more than MAX_RATIO) then we scale it down.
413       const factor = Math.min(
414         (MAX_RATIO * pageWidth) / width,
415         (MAX_RATIO * pageHeight) / height
416       );
417       width *= factor;
418       height *= factor;
419     }
420     const [parentWidth, parentHeight] = this.parentDimensions;
421     this.setDims(
422       (width * parentWidth) / pageWidth,
423       (height * parentHeight) / pageHeight
424     );
425 
426     this._uiManager.enableWaiting(false);
427     const canvas = (this.#canvas = document.createElement("canvas"));
428     div.append(canvas);
429     if (
430       !this._uiManager.useNewAltTextWhenAddingImage ||
431       !this._uiManager.useNewAltTextFlow
432     ) {
433       div.hidden = false;
434     }
435     this.#drawBitmap(width, height);
436     this.#createObserver();
437     if (!this.#hasBeenAddedInUndoStack) {
438       this.parent.addUndoableEditor(this);
439       this.#hasBeenAddedInUndoStack = true;
440     }
441 
442     // There are multiple ways to add an image to the page, so here we just
443     // count the number of times an image is added to the page whatever the way
444     // is.
445     this._reportTelemetry({
446       action: "inserted_image",
447     });
448     if (this.#bitmapFileName) {
449       canvas.setAttribute("aria-label", this.#bitmapFileName);
450     }
451   }
452 
453   copyCanvas(maxDimension, createImageData = false) {
454     if (!maxDimension) {
455       // TODO: get this value from Firefox
456       //   (https://bugzilla.mozilla.org/show_bug.cgi?id=1908184)
457       // It's the maximum dimension that the AI can handle.
458       maxDimension = 224;
459     }
460 
461     const { width: bitmapWidth, height: bitmapHeight } = this.#bitmap;
462     const canvas = document.createElement("canvas");
463 
464     let bitmap = this.#bitmap;
465     let width = bitmapWidth,
466       height = bitmapHeight;
467     if (bitmapWidth > maxDimension || bitmapHeight > maxDimension) {
468       const ratio = Math.min(
469         maxDimension / bitmapWidth,
470         maxDimension / bitmapHeight
471       );
472       width = Math.floor(bitmapWidth * ratio);
473       height = Math.floor(bitmapHeight * ratio);
474 
475       if (!this.#isSvg) {
476         bitmap = this.#scaleBitmap(width, height);
477       }
478     }
479 
480     canvas.width = width;
481     canvas.height = height;
482     const ctx = canvas.getContext("2d");
483     ctx.filter = this._uiManager.hcmFilter;
484 
485     // Add a checkerboard pattern as a background in case the image has some
486     // transparency.
487     let white = "white",
488       black = "#cfcfd8";
489     if (this._uiManager.hcmFilter !== "none") {
490       black = "black";
491     } else if (window.matchMedia?.("(prefers-color-scheme: dark)").matches) {
492       white = "#8f8f9d";
493       black = "#42414d";
494     }
495     const boxDim = 15;
496     const pattern = new OffscreenCanvas(boxDim * 2, boxDim * 2);
497     const patternCtx = pattern.getContext("2d");
498     patternCtx.fillStyle = white;
499     patternCtx.fillRect(0, 0, boxDim * 2, boxDim * 2);
500     patternCtx.fillStyle = black;
501     patternCtx.fillRect(0, 0, boxDim, boxDim);
502     patternCtx.fillRect(boxDim, boxDim, boxDim, boxDim);
503     ctx.fillStyle = ctx.createPattern(pattern, "repeat");
504     ctx.fillRect(0, 0, width, height);
505 
506     if (createImageData) {
507       const offscreen = new OffscreenCanvas(width, height);
508       const offscreenCtx = offscreen.getContext("2d", {
509         willReadFrequently: true,
510       });
511       offscreenCtx.drawImage(
512         bitmap,
513         0,
514         0,
515         bitmap.width,
516         bitmap.height,
517         0,
518         0,
519         width,
520         height
521       );
522       const data = offscreenCtx.getImageData(0, 0, width, height).data;
523       ctx.drawImage(offscreen, 0, 0);
524 
525       return { canvas, imageData: { width, height, data } };
526     }
527 
528     ctx.drawImage(
529       bitmap,
530       0,
531       0,
532       bitmap.width,
533       bitmap.height,
534       0,
535       0,
536       width,
537       height
538     );
539     return { canvas, imageData: null };
540   }
541 
542   /**
543    * When the dimensions of the div change the inner canvas must
544    * renew its dimensions, hence it must redraw its own contents.
545    * @param {number} width - the new width of the div
546    * @param {number} height - the new height of the div
547    * @returns
548    */
549   #setDimensions(width, height) {
550     const [parentWidth, parentHeight] = this.parentDimensions;
551     this.width = width / parentWidth;
552     this.height = height / parentHeight;
553     this.setDims(width, height);
554     if (this._initialOptions?.isCentered) {
555       this.center();
556     } else {
557       this.fixAndSetPosition();
558     }
559     this._initialOptions = null;
560     if (this.#resizeTimeoutId !== null) {
561       clearTimeout(this.#resizeTimeoutId);
562     }
563     // When the user is resizing the editor we just use CSS to scale the image
564     // to avoid redrawing it too often.
565     // And once the user stops resizing the editor we redraw the image in
566     // rescaling it correctly (see this.#scaleBitmap).
567     const TIME_TO_WAIT = 200;
568     this.#resizeTimeoutId = setTimeout(() => {
569       this.#resizeTimeoutId = null;
570       this.#drawBitmap(width, height);
571     }, TIME_TO_WAIT);
572   }
573 
574   #scaleBitmap(width, height) {
575     const { width: bitmapWidth, height: bitmapHeight } = this.#bitmap;
576 
577     let newWidth = bitmapWidth;
578     let newHeight = bitmapHeight;
579     let bitmap = this.#bitmap;
580     while (newWidth > 2 * width || newHeight > 2 * height) {
581       const prevWidth = newWidth;
582       const prevHeight = newHeight;
583 
584       if (newWidth > 2 * width) {
585         // See bug 1820511 (Windows specific bug).
586         // TODO: once the above bug is fixed we could revert to:
587         // newWidth = Math.ceil(newWidth / 2);
588         newWidth =
589           newWidth >= 16384
590             ? Math.floor(newWidth / 2) - 1
591             : Math.ceil(newWidth / 2);
592       }
593       if (newHeight > 2 * height) {
594         newHeight =
595           newHeight >= 16384
596             ? Math.floor(newHeight / 2) - 1
597             : Math.ceil(newHeight / 2);
598       }
599 
600       const offscreen = new OffscreenCanvas(newWidth, newHeight);
601       const ctx = offscreen.getContext("2d");
602       ctx.drawImage(
603         bitmap,
604         0,
605         0,
606         prevWidth,
607         prevHeight,
608         0,
609         0,
610         newWidth,
611         newHeight
612       );
613       bitmap = offscreen.transferToImageBitmap();
614     }
615 
616     return bitmap;
617   }
618 
619   #drawBitmap(width, height) {
620     width = Math.ceil(width);
621     height = Math.ceil(height);
622     const canvas = this.#canvas;
623     if (!canvas || (canvas.width === width && canvas.height === height)) {
624       return;
625     }
626     canvas.width = width;
627     canvas.height = height;
628     const bitmap = this.#isSvg
629       ? this.#bitmap
630       : this.#scaleBitmap(width, height);
631 
632     const ctx = canvas.getContext("2d");
633     ctx.filter = this._uiManager.hcmFilter;
634     ctx.drawImage(
635       bitmap,
636       0,
637       0,
638       bitmap.width,
639       bitmap.height,
640       0,
641       0,
642       width,
643       height
644     );
645   }
646 
647   /** @inheritdoc */
648   getImageForAltText() {
649     return this.#canvas;
650   }
651 
652   #serializeBitmap(toUrl) {
653     if (toUrl) {
654       if (this.#isSvg) {
655         const url = this._uiManager.imageManager.getSvgUrl(this.#bitmapId);
656         if (url) {
657           return url;
658         }
659       }
660       // We convert to a data url because it's sync and the url can live in the
661       // clipboard.
662       const canvas = document.createElement("canvas");
663       ({ width: canvas.width, height: canvas.height } = this.#bitmap);
664       const ctx = canvas.getContext("2d");
665       ctx.drawImage(this.#bitmap, 0, 0);
666 
667       return canvas.toDataURL();
668     }
669 
670     if (this.#isSvg) {
671       const [pageWidth, pageHeight] = this.pageDimensions;
672       // Multiply by PixelsPerInch.PDF_TO_CSS_UNITS in order to increase the
673       // image resolution when rasterizing it.
674       const width = Math.round(
675         this.width * pageWidth * PixelsPerInch.PDF_TO_CSS_UNITS
676       );
677       const height = Math.round(
678         this.height * pageHeight * PixelsPerInch.PDF_TO_CSS_UNITS
679       );
680       const offscreen = new OffscreenCanvas(width, height);
681       const ctx = offscreen.getContext("2d");
682       ctx.drawImage(
683         this.#bitmap,
684         0,
685         0,
686         this.#bitmap.width,
687         this.#bitmap.height,
688         0,
689         0,
690         width,
691         height
692       );
693       return offscreen.transferToImageBitmap();
694     }
695 
696     return structuredClone(this.#bitmap);
697   }
698 
699   /**
700    * Create the resize observer.
701    */
702   #createObserver() {
703     if (!this._uiManager._signal) {
704       // This method is called after the canvas has been created but the canvas
705       // creation is async, so it's possible that the viewer has been closed.
706       return;
707     }
708     this.#observer = new ResizeObserver(entries => {
709       const rect = entries[0].contentRect;
710       if (rect.width && rect.height) {
711         this.#setDimensions(rect.width, rect.height);
712       }
713     });
714     this.#observer.observe(this.div);
715     this._uiManager._signal.addEventListener(
716       "abort",
717       () => {
718         this.#observer?.disconnect();
719         this.#observer = null;
720       },
721       { once: true }
722     );
723   }
724 
725   /** @inheritdoc */
726   static deserialize(data, parent, uiManager) {
727     if (data instanceof StampAnnotationElement) {
728       return null;
729     }
730     const editor = super.deserialize(data, parent, uiManager);
731     const { rect, bitmapUrl, bitmapId, isSvg, accessibilityData } = data;
732     if (bitmapId && uiManager.imageManager.isValidId(bitmapId)) {
733       editor.#bitmapId = bitmapId;
734     } else {
735       editor.#bitmapUrl = bitmapUrl;
736     }
737     editor.#isSvg = isSvg;
738 
739     const [parentWidth, parentHeight] = editor.pageDimensions;
740     editor.width = (rect[2] - rect[0]) / parentWidth;
741     editor.height = (rect[3] - rect[1]) / parentHeight;
742 
743     if (accessibilityData) {
744       editor.altTextData = accessibilityData;
745     }
746 
747     return editor;
748   }
749 
750   /** @inheritdoc */
751   serialize(isForCopying = false, context = null) {
752     if (this.isEmpty()) {
753       return null;
754     }
755 
756     const serialized = {
757       annotationType: AnnotationEditorType.STAMP,
758       bitmapId: this.#bitmapId,
759       pageIndex: this.pageIndex,
760       rect: this.getRect(0, 0),
761       rotation: this.rotation,
762       isSvg: this.#isSvg,
763       structTreeParentId: this._structTreeParentId,
764     };
765 
766     if (isForCopying) {
767       // We don't know what's the final destination (this pdf or another one)
768       // of this annotation and the clipboard doesn't support ImageBitmaps,
769       // hence we serialize the bitmap to a data url.
770       serialized.bitmapUrl = this.#serializeBitmap(/* toUrl = */ true);
771       serialized.accessibilityData = this.serializeAltText(true);
772       return serialized;
773     }
774 
775     const { decorative, altText } = this.serializeAltText(false);
776     if (!decorative && altText) {
777       serialized.accessibilityData = { type: "Figure", alt: altText };
778     }
779 
780     if (context === null) {
781       return serialized;
782     }
783 
784     context.stamps ||= new Map();
785     const area = this.#isSvg
786       ? (serialized.rect[2] - serialized.rect[0]) *
787         (serialized.rect[3] - serialized.rect[1])
788       : null;
789     if (!context.stamps.has(this.#bitmapId)) {
790       // We don't want to have multiple copies of the same bitmap in the
791       // annotationMap, hence we only add the bitmap the first time we meet it.
792       context.stamps.set(this.#bitmapId, { area, serialized });
793       serialized.bitmap = this.#serializeBitmap(/* toUrl = */ false);
794     } else if (this.#isSvg) {
795       // If we have multiple copies of the same svg but with different sizes,
796       // then we want to keep the biggest one.
797       const prevData = context.stamps.get(this.#bitmapId);
798       if (area > prevData.area) {
799         prevData.area = area;
800         prevData.serialized.bitmap.close();
801         prevData.serialized.bitmap = this.#serializeBitmap(/* toUrl = */ false);
802       }
803     }
804     return serialized;
805   }
806 }
807 
808 export { StampEditor };
File:
src/display/editor/toolbar.js
1 /* Copyright 2023 Mozilla Foundation
2  *
3  * Licensed under the Apache License, Version 2.0 (the "License");
4  * you may not use this file except in compliance with the License.
5  * You may obtain a copy of the License at
6  *
7  *     http://www.apache.org/licenses/LICENSE-2.0
8  *
9  * Unless required by applicable law or agreed to in writing, software
10  * distributed under the License is distributed on an "AS IS" BASIS,
11  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
12  * See the License for the specific language governing permissions and
13  * limitations under the License.
14  */
15 
16 import { noContextMenu } from "../display_utils.js";
17 
18 class EditorToolbar {
19   #toolbar = null;
20 
21   #colorPicker = null;
22 
23   #editor;
24 
25   #buttons = null;
26 
27   #altText = null;
28 
29   static #l10nRemove = null;
30 
31   constructor(editor) {
32     this.#editor = editor;
33 
34     EditorToolbar.#l10nRemove ||= Object.freeze({
35       freetext: "pdfjs-editor-remove-freetext-button",
36       highlight: "pdfjs-editor-remove-highlight-button",
37       ink: "pdfjs-editor-remove-ink-button",
38       stamp: "pdfjs-editor-remove-stamp-button",
39     });
40   }
41 
42   render() {
43     const editToolbar = (this.#toolbar = document.createElement("div"));
44     editToolbar.className = "editToolbar";
45     editToolbar.setAttribute("role", "toolbar");
46     const signal = this.#editor._uiManager._signal;
47     editToolbar.addEventListener("contextmenu", noContextMenu, { signal });
48     editToolbar.addEventListener("pointerdown", EditorToolbar.#pointerDown, {
49       signal,
50     });
51 
52     const buttons = (this.#buttons = document.createElement("div"));
53     buttons.className = "buttons";
54     editToolbar.append(buttons);
55 
56     const position = this.#editor.toolbarPosition;
57     if (position) {
58       const { style } = editToolbar;
59       const x =
60         this.#editor._uiManager.direction === "ltr"
61           ? 1 - position[0]
62           : position[0];
63       style.insetInlineEnd = `${100 * x}%`;
64       style.top = `calc(${
65         100 * position[1]
66       }% + var(--editor-toolbar-vert-offset))`;
67     }
68 
69     this.#addDeleteButton();
70 
71     return editToolbar;
72   }
73 
74   static #pointerDown(e) {
75     e.stopPropagation();
76   }
77 
78   #focusIn(e) {
79     this.#editor._focusEventsAllowed = false;
80     e.preventDefault();
81     e.stopPropagation();
82   }
83 
84   #focusOut(e) {
85     this.#editor._focusEventsAllowed = true;
86     e.preventDefault();
87     e.stopPropagation();
88   }
89 
90   #addListenersToElement(element) {
91     // If we're clicking on a button with the keyboard or with
92     // the mouse, we don't want to trigger any focus events on
93     // the editor.
94     const signal = this.#editor._uiManager._signal;
95     element.addEventListener("focusin", this.#focusIn.bind(this), {
96       capture: true,
97       signal,
98     });
99     element.addEventListener("focusout", this.#focusOut.bind(this), {
100       capture: true,
101       signal,
102     });
103     element.addEventListener("contextmenu", noContextMenu, { signal });
104   }
105 
106   hide() {
107     this.#toolbar.classList.add("hidden");
108     this.#colorPicker?.hideDropdown();
109   }
110 
111   show() {
112     this.#toolbar.classList.remove("hidden");
113     this.#altText?.shown();
114   }
115 
116   #addDeleteButton() {
117     const { editorType, _uiManager } = this.#editor;
118 
119     const button = document.createElement("button");
120     button.className = "delete";
121     button.tabIndex = 0;
122     button.setAttribute("data-l10n-id", EditorToolbar.#l10nRemove[editorType]);
123     this.#addListenersToElement(button);
124     button.addEventListener(
125       "click",
126       e => {
127         _uiManager.delete();
128       },
129       { signal: _uiManager._signal }
130     );
131     this.#buttons.append(button);
132   }
133 
134   get #divider() {
135     const divider = document.createElement("div");
136     divider.className = "divider";
137     return divider;
138   }
139 
140   async addAltText(altText) {
141     const button = await altText.render();
142     this.#addListenersToElement(button);
143     this.#buttons.prepend(button, this.#divider);
144     this.#altText = altText;
145   }
146 
147   addColorPicker(colorPicker) {
148     this.#colorPicker = colorPicker;
149     const button = colorPicker.renderButton();
150     this.#addListenersToElement(button);
151     this.#buttons.prepend(button, this.#divider);
152   }
153 
154   remove() {
155     this.#toolbar.remove();
156     this.#colorPicker?.destroy();
157     this.#colorPicker = null;
158   }
159 }
160 
161 class HighlightToolbar {
162   #buttons = null;
163 
164   #toolbar = null;
165 
166   #uiManager;
167 
168   constructor(uiManager) {
169     this.#uiManager = uiManager;
170   }
171 
172   #render() {
173     const editToolbar = (this.#toolbar = document.createElement("div"));
174     editToolbar.className = "editToolbar";
175     editToolbar.setAttribute("role", "toolbar");
176     editToolbar.addEventListener("contextmenu", noContextMenu, {
177       signal: this.#uiManager._signal,
178     });
179 
180     const buttons = (this.#buttons = document.createElement("div"));
181     buttons.className = "buttons";
182     editToolbar.append(buttons);
183 
184     this.#addHighlightButton();
185 
186     return editToolbar;
187   }
188 
189   #getLastPoint(boxes, isLTR) {
190     let lastY = 0;
191     let lastX = 0;
192     for (const box of boxes) {
193       const y = box.y + box.height;
194       if (y < lastY) {
195         continue;
196       }
197       const x = box.x + (isLTR ? box.width : 0);
198       if (y > lastY) {
199         lastX = x;
200         lastY = y;
201         continue;
202       }
203       if (isLTR) {
204         if (x > lastX) {
205           lastX = x;
206         }
207       } else if (x < lastX) {
208         lastX = x;
209       }
210     }
211     return [isLTR ? 1 - lastX : lastX, lastY];
212   }
213 
214   show(parent, boxes, isLTR) {
215     const [x, y] = this.#getLastPoint(boxes, isLTR);
216     const { style } = (this.#toolbar ||= this.#render());
217     parent.append(this.#toolbar);
218     style.insetInlineEnd = `${100 * x}%`;
219     style.top = `calc(${100 * y}% + var(--editor-toolbar-vert-offset))`;
220   }
221 
222   hide() {
223     this.#toolbar.remove();
224   }
225 
226   #addHighlightButton() {
227     const button = document.createElement("button");
228     button.className = "highlightButton";
229     button.tabIndex = 0;
230     button.setAttribute("data-l10n-id", `pdfjs-highlight-floating-button1`);
231     const span = document.createElement("span");
232     button.append(span);
233     span.className = "visuallyHidden";
234     span.setAttribute("data-l10n-id", "pdfjs-highlight-floating-button-label");
235     const signal = this.#uiManager._signal;
236     button.addEventListener("contextmenu", noContextMenu, { signal });
237     button.addEventListener(
238       "click",
239       () => {
240         this.#uiManager.highlightSelection("floating_button");
241       },
242       { signal }
243     );
244     this.#buttons.append(button);
245   }
246 }
247 
248 export { EditorToolbar, HighlightToolbar };
</code>

Your task:
You are a software tester at pdf.js.
1. Write exactly one javascript test `it("...", async () => {...})` block.
2. Your test must fail on the code before the patch, and pass after, hence the test will verify that the patch resolves the issue.
3. The test must be self-contained and to-the-point.
4. Use only the provided imports (respect the paths exactly how they are given) by importing dynamically for compatibility with Node.js — no new dependencies. 
5. Return only the javascript code (no comments or explanations).

Example structure:
it("should <describe behavior>", async () => {
  const { example } = await import("../../src/core/example.js");
  <initialize required variables>;
  <define expected variable>;
  <generate actual variables>;
  <compare expected with actual>;
});

