Before you begin:
- Keep going until the job is completely solved — don’t stop halfway.
- If you’re unsure about the behavior, reread the provided patch carefully; do not hallucinate.
- Plan your approach before writing code by reflecting on whether the test truly fails before and passes after.

Issue:
<issue>
memory usage ballooning when scrolling through pdf
</issue>

Patch:
<patch>
diff --git a/src/display/api.js b/src/display/api.js
--- a/src/display/api.js
+++ b/src/display/api.js
@@ -2768,6 +2768,11 @@ class WorkerTransport {
       if (pageProxy.objs.has(id)) {
         return;
       }
+      // Don't store data *after* cleanup has successfully run, see bug 1854145.
+      if (pageProxy._intentStates.size === 0) {
+        imageData?.bitmap?.close(); // Release any `ImageBitmap` data.
+        return;
+      }
 
       switch (type) {
         case "Image":


</patch>

Imports:
<imports>
Available Packages
Dev Dependencies:
- @babel/core: ^7.22.20
- @babel/plugin-transform-modules-commonjs: ^7.22.15
- @babel/preset-env: ^7.22.20
- @babel/runtime: ^7.22.15
- @javascript-obfuscator/escodegen: 2.3.0
- acorn: ^8.10.0
- autoprefixer: ^10.4.16
- babel-loader: ^9.1.3
- caniuse-lite: ^1.0.30001538
- canvas: ^2.11.2
- core-js: ^3.32.2
- cross-env: ^7.0.3
- es-module-shims: 1.4.7
- eslint: ^8.50.0
- eslint-config-prettier: ^8.10.0
- eslint-plugin-fetch-options: ^0.0.5
- eslint-plugin-html: ^7.1.0
- eslint-plugin-import: ^2.28.1
- eslint-plugin-json: ^3.1.0
- eslint-plugin-mozilla: ^3.2.0
- eslint-plugin-no-unsanitized: ^4.0.2
- eslint-plugin-prettier: ^5.0.0
- eslint-plugin-sort-exports: ^0.8.0
- eslint-plugin-unicorn: ^48.0.1
- globals: ^13.22.0
- gulp: ^4.0.2
- gulp-postcss: ^9.0.1
- gulp-rename: ^2.0.0
- gulp-replace: ^1.1.4
- gulp-zip: ^5.1.0
- jasmine: ^5.1.0
- jsdoc: ^4.0.2
- jstransformer-markdown-it: ^3.0.0
- merge-stream: ^2.0.0
- mkdirp: ^3.0.1
- needle: ^3.2.0
- path2d-polyfill: ^2.0.1
- pngjs: ^7.0.0
- postcss: ^8.4.31
- postcss-dir-pseudo-class: ^8.0.0
- postcss-discard-comments: ^6.0.0
- postcss-nesting: ^12.0.1
- prettier: ^3.0.3
- puppeteer: ^21.3.4
- rimraf: ^3.0.2
- streamqueue: ^1.1.2
- stylelint: ^15.10.3
- stylelint-prettier: ^4.0.2
- terser: ^5.20.0
- through2: ^4.0.2
- tsc-alias: ^1.8.8
- ttest: ^4.0.0
- typescript: ^5.2.2
- typogr: ^0.6.8
- vinyl: ^3.0.0
- webpack: ^5.88.2
- webpack-stream: ^7.0.0
- wintersmith: ^2.5.0
- yargs: ^17.7.2

Engines:
- node: >=18

Available Relative Imports:
- `../../src/core/annotation.js`: Annotation, AnnotationBorderStyle, AnnotationFactory, MarkupAnnotation, getQuadPoints
- `../../src/core/bidi.js`: bidi
- `../../src/core/cff_parser.js`: CFFCharset, CFFCompiler, CFFFDSelect, CFFParser, CFFStrings
- `../../src/core/cmap.js`: CMap, CMapFactory, IdentityCMap
- `../../src/core/colorspace.js`: ColorSpace
- `../../src/core/core_utils.js`: arrayBuffersToBytes, encodeToXmlString, escapePDFName, escapeString, getInheritableProperty, isAscii, isWhiteSpace, log2, numberToString, parseXFAPath, recoverJsURL, stringToUTF16HexString, stringToUTF16String, toRomanNumerals, validateCSSFont
- `../../src/core/crypto.js`: AES128Cipher, AES256Cipher, ARCFourCipher, CipherTransformFactory, PDF17, PDF20, calculateMD5, calculateSHA256, calculateSHA384, calculateSHA512
- `../../src/core/default_appearance.js`: createDefaultAppearance, parseAppearanceStream, parseDefaultAppearance
- `../../src/core/document.js`: PDFDocument, Page
- `../../src/core/encodings.js`: getEncoding
- `../../src/core/evaluator.js`: PartialEvaluator
- `../../src/core/font_substitutions.js`: getFontSubstitution
- `../../src/core/fonts_utils.js`: SEAC_ANALYSIS_ENABLED
- `../../src/core/function.js`: PDFFunctionFactory, PostScriptCompiler, PostScriptEvaluator
- `../../src/core/glyphlist.js`: getDingbatsGlyphsUnicode, getGlyphsUnicode
- `../../src/core/image_utils.js`: GlobalImageCache, LocalColorSpaceCache
- `../../src/core/jbig2.js`: Jbig2Image
- `../../src/core/jpg.js`: JpegImage
- `../../src/core/jpx.js`: JpxImage
- `../../src/core/metadata_parser.js`: MetadataParser
- `../../src/core/operator_list.js`: OperatorList
- `../../src/core/parser.js`: Lexer, Linearization, Parser
- `../../src/core/predictor_stream.js`: PredictorStream
- `../../src/core/primitives.js`: Cmd, Dict, EOF, Name, Ref, RefSet, RefSetCache, isCmd, isDict, isName, isRefsEqual
- `../../src/core/ps_parser.js`: PostScriptLexer, PostScriptParser
- `../../src/core/stream.js`: NullStream, Stream, StringStream
- `../../src/core/type1_parser.js`: Type1Parser
- `../../src/core/unicode.js`: getCharUnicodeCategory, getUnicodeForGlyph, getUnicodeRangeFor, mapSpecialUnicodeValues
- `../../src/core/worker.js`: WorkerMessageHandler, WorkerTask
- `../../src/core/writer.js`: incrementalUpdate, writeDict
- `../../src/core/xfa/bind.js`: Binder
- `../../src/core/xfa/data.js`: DataHandler
- `../../src/core/xfa/factory.js`: XFAFactory
- `../../src/core/xfa/formcalc_lexer.js`: Lexer, TOKEN, Token
- `../../src/core/xfa/formcalc_parser.js`: Errors, Parser
- `../../src/core/xfa/parser.js`: XFAParser
- `../../src/core/xfa/som.js`: searchNode
- `../../src/core/xfa/symbol_utils.js`: $dump, $getChildren, $getChildrenByClass, $getChildrenByName, $text, $uid
- `../../src/core/xml_parser.js`: SimpleXMLParser, XMLParserBase
- `../../src/display/annotation_layer.js`: AnnotationLayer
- `../../src/display/annotation_storage.js`: AnnotationStorage
- `../../src/display/api.js`: DefaultCMapReaderFactory, DefaultCanvasFactory, DefaultStandardFontDataFactory, LoopbackPort, PDFDataRangeTransport, PDFDocumentLoadingTask, PDFDocumentProxy, PDFPageProxy, PDFWorker, PDFWorkerUtil, RenderTask, build, getDocument, version
- `../../src/display/display_utils.js`: DOMCanvasFactory, DOMSVGFactory, PDFDateString, PageViewport, PixelsPerInch, RenderingCancelledException, StatTimer, getFilenameFromUrl, getPdfFilenameFromUrl, getXfaPageViewport, isDataScheme, isPdfFile, isValidFetchUrl, noContextMenu, setLayerDimensions
- `../../src/display/editor/annotation_editor_layer.js`: AnnotationEditorLayer
- `../../src/display/editor/tools.js`: AnnotationEditorUIManager, CommandManager
- `../../src/display/fetch_stream.js`: PDFFetchStream
- `../../src/display/metadata.js`: Metadata
- `../../src/display/network.js`: PDFNetworkStream
- `../../src/display/network_utils.js`: createResponseStatusError, extractFilenameFromHeader, validateRangeRequestCapabilities, validateResponseStatus
- `../../src/display/node_stream.js`: PDFNodeStream
- `../../src/display/text_layer.js`: TextLayerRenderTask, renderTextLayer, updateTextLayer
- `../../src/display/worker_options.js`: GlobalWorkerOptions
- `../../src/display/xfa_layer.js`: XfaLayer
- `../../src/shared/message_handler.js`: MessageHandler
- `../../src/shared/murmurhash3.js`: MurmurHash3_64
- `../../src/shared/util.js`: AbortException, AnnotationBorderStyleType, AnnotationEditorParamsType, AnnotationEditorType, AnnotationFieldFlag, AnnotationFlag, AnnotationMode, AnnotationType, CMapCompressionType, FeatureTest, FormatError, ImageKind, InvalidPDFException, MissingPDFException, OPS, PasswordException, PasswordResponses, PermissionFlag, PromiseCapability, RenderingIntentFlag, UnexpectedResponseException, UnknownErrorException, Util, VerbosityLevel, bytesToString, createValidAbsoluteUrl, getModificationDate, getVerbosityLevel, isArrayBuffer, isNodeJS, normalizeUnicode, objectSize, setVerbosityLevel, shadow, string32, stringToBytes, stringToPDFString, stringToUTF8String
- `../../web/annotation_layer_builder.js`: AnnotationLayerBuilder
- `../../web/download_manager.js`: DownloadManager
- `../../web/event_utils.js`: EventBus, WaitOnType, waitOnEventOrTimeout
- `../../web/genericl10n.js`: GenericL10n
- `../../web/l10n_utils.js`: NullL10n
- `../../web/pdf_find_controller.js`: FindState, PDFFindController
- `../../web/pdf_find_utils.js`: CharacterType, getCharacterType
- `../../web/pdf_history.js`: PDFHistory, isDestArraysEqual, isDestHashesEqual
- `../../web/pdf_link_service.js`: LinkTarget, PDFLinkService, SimpleLinkService
- `../../web/pdf_page_view.js`: PDFPageView
- `../../web/pdf_scripting_manager.component.js`: PDFScriptingManager
- `../../web/pdf_single_page_viewer.js`: PDFSinglePageViewer
- `../../web/pdf_viewer.js`: PDFPageViewBuffer, PDFViewer
- `../../web/struct_tree_layer_builder.js`: StructTreeLayerBuilder
- `../../web/text_layer_builder.js`: TextLayerBuilder
- `../../web/ui_utils.js`: AutoPrintRegExp, ProgressBar, RenderingStates, ScrollMode, SpreadMode, backtrackBeforeAllVisibleElements, binarySearchFirstItem, getPageSizeInches, getVisibleElements, isPortraitOrientation, isValidRotation, parseQueryString, removeNullCharacters
- `../../web/xfa_layer_builder.js`: XfaLayerBuilder
- `./test_utils.js`: CMAP_URL, DefaultFileReaderFactory, STANDARD_FONT_DATA_URL, TEST_PDFS_PATH, XRefMock, buildGetDocumentParams, createIdFactory
- `./testreporter.js`: TestReporter
</imports>

Code:
<code>
File:
src/display/api.js
1 /* Copyright 2012 Mozilla Foundation
2  *
3  * Licensed under the Apache License, Version 2.0 (the "License");
4  * you may not use this file except in compliance with the License.
5  * You may obtain a copy of the License at
6  *
7  *     http://www.apache.org/licenses/LICENSE-2.0
8  *
9  * Unless required by applicable law or agreed to in writing, software
10  * distributed under the License is distributed on an "AS IS" BASIS,
11  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
12  * See the License for the specific language governing permissions and
13  * limitations under the License.
14  */
15 
16 /**
17  * @module pdfjsLib
18  */
19 
20 import {
21   AbortException,
22   AnnotationMode,
23   assert,
24   getVerbosityLevel,
25   info,
26   InvalidPDFException,
27   isArrayBuffer,
28   isNodeJS,
29   MAX_IMAGE_SIZE_TO_CACHE,
30   MissingPDFException,
31   PasswordException,
32   PromiseCapability,
33   RenderingIntentFlag,
34   setVerbosityLevel,
35   shadow,
36   stringToBytes,
37   UnexpectedResponseException,
38   UnknownErrorException,
39   unreachable,
40   warn,
41 } from "../shared/util.js";
42 import {
43   AnnotationStorage,
44   PrintAnnotationStorage,
45   SerializableEmpty,
46 } from "./annotation_storage.js";
47 import {
48   DOMCanvasFactory,
49   DOMCMapReaderFactory,
50   DOMFilterFactory,
51   DOMStandardFontDataFactory,
52   isDataScheme,
53   isValidFetchUrl,
54   PageViewport,
55   RenderingCancelledException,
56   StatTimer,
57 } from "./display_utils.js";
58 import { FontFaceObject, FontLoader } from "./font_loader.js";
59 import {
60   NodeCanvasFactory,
61   NodeCMapReaderFactory,
62   NodeFilterFactory,
63   NodeStandardFontDataFactory,
64 } from "display-node_utils";
65 import { CanvasGraphics } from "./canvas.js";
66 import { GlobalWorkerOptions } from "./worker_options.js";
67 import { MessageHandler } from "../shared/message_handler.js";
68 import { Metadata } from "./metadata.js";
69 import { OptionalContentConfig } from "./optional_content_config.js";
70 import { PDFDataTransportStream } from "./transport_stream.js";
71 import { PDFFetchStream } from "display-fetch_stream";
72 import { PDFNetworkStream } from "display-network";
73 import { PDFNodeStream } from "display-node_stream";
74 import { XfaText } from "./xfa_text.js";
75 
76 const DEFAULT_RANGE_CHUNK_SIZE = 65536; // 2^16 = 65536
77 const RENDERING_CANCELLED_TIMEOUT = 100; // ms
78 const DELAYED_CLEANUP_TIMEOUT = 5000; // ms
79 
80 const DefaultCanvasFactory =
81   typeof PDFJSDev !== "undefined" && PDFJSDev.test("GENERIC") && isNodeJS
82     ? NodeCanvasFactory
83     : DOMCanvasFactory;
84 const DefaultCMapReaderFactory =
85   typeof PDFJSDev !== "undefined" && PDFJSDev.test("GENERIC") && isNodeJS
86     ? NodeCMapReaderFactory
87     : DOMCMapReaderFactory;
88 const DefaultFilterFactory =
89   typeof PDFJSDev !== "undefined" && PDFJSDev.test("GENERIC") && isNodeJS
90     ? NodeFilterFactory
91     : DOMFilterFactory;
92 const DefaultStandardFontDataFactory =
93   typeof PDFJSDev !== "undefined" && PDFJSDev.test("GENERIC") && isNodeJS
94     ? NodeStandardFontDataFactory
95     : DOMStandardFontDataFactory;
96 
97 /**
98  * @typedef { Int8Array | Uint8Array | Uint8ClampedArray |
99  *            Int16Array | Uint16Array |
100  *            Int32Array | Uint32Array | Float32Array |
101  *            Float64Array
102  * } TypedArray
103  */
104 
105 /**
106  * @typedef { TypedArray | ArrayBuffer | Array<number> | string } BinaryData
107  */
108 
109 /**
110  * @typedef {Object} RefProxy
111  * @property {number} num
112  * @property {number} gen
113  */
114 
115 /**
116  * Document initialization / loading parameters object.
117  *
118  * @typedef {Object} DocumentInitParameters
119  * @property {string | URL} [url] - The URL of the PDF.
120  * @property {BinaryData} [data] - Binary PDF data.
121  *   Use TypedArrays (Uint8Array) to improve the memory usage. If PDF data is
122  *   BASE64-encoded, use `atob()` to convert it to a binary string first.
123  *
124  *   NOTE: If TypedArrays are used they will generally be transferred to the
125  *   worker-thread. This will help reduce main-thread memory usage, however
126  *   it will take ownership of the TypedArrays.
127  * @property {Object} [httpHeaders] - Basic authentication headers.
128  * @property {boolean} [withCredentials] - Indicates whether or not
129  *   cross-site Access-Control requests should be made using credentials such
130  *   as cookies or authorization headers. The default is `false`.
131  * @property {string} [password] - For decrypting password-protected PDFs.
132  * @property {number} [length] - The PDF file length. It's used for progress
133  *   reports and range requests operations.
134  * @property {PDFDataRangeTransport} [range] - Allows for using a custom range
135  *   transport implementation.
136  * @property {number} [rangeChunkSize] - Specify maximum number of bytes fetched
137  *   per range request. The default value is {@link DEFAULT_RANGE_CHUNK_SIZE}.
138  * @property {PDFWorker} [worker] - The worker that will be used for loading and
139  *   parsing the PDF data.
140  * @property {number} [verbosity] - Controls the logging level; the constants
141  *   from {@link VerbosityLevel} should be used.
142  * @property {string} [docBaseUrl] - The base URL of the document, used when
143  *   attempting to recover valid absolute URLs for annotations, and outline
144  *   items, that (incorrectly) only specify relative URLs.
145  * @property {string} [cMapUrl] - The URL where the predefined Adobe CMaps are
146  *   located. Include the trailing slash.
147  * @property {boolean} [cMapPacked] - Specifies if the Adobe CMaps are binary
148  *   packed or not. The default value is `true`.
149  * @property {Object} [CMapReaderFactory] - The factory that will be used when
150  *   reading built-in CMap files. Providing a custom factory is useful for
151  *   environments without Fetch API or `XMLHttpRequest` support, such as
152  *   Node.js. The default value is {DOMCMapReaderFactory}.
153  * @property {boolean} [useSystemFonts] - When `true`, fonts that aren't
154  *   embedded in the PDF document will fallback to a system font.
155  *   The default value is `true` in web environments and `false` in Node.js;
156  *   unless `disableFontFace === true` in which case this defaults to `false`
157  *   regardless of the environment (to prevent completely broken fonts).
158  * @property {string} [standardFontDataUrl] - The URL where the standard font
159  *   files are located. Include the trailing slash.
160  * @property {Object} [StandardFontDataFactory] - The factory that will be used
161  *   when reading the standard font files. Providing a custom factory is useful
162  *   for environments without Fetch API or `XMLHttpRequest` support, such as
163  *   Node.js. The default value is {DOMStandardFontDataFactory}.
164  * @property {boolean} [useWorkerFetch] - Enable using the Fetch API in the
165  *   worker-thread when reading CMap and standard font files. When `true`,
166  *   the `CMapReaderFactory` and `StandardFontDataFactory` options are ignored.
167  *   The default value is `true` in web environments and `false` in Node.js.
168  * @property {boolean} [stopAtErrors] - Reject certain promises, e.g.
169  *   `getOperatorList`, `getTextContent`, and `RenderTask`, when the associated
170  *   PDF data cannot be successfully parsed, instead of attempting to recover
171  *   whatever possible of the data. The default value is `false`.
172  * @property {number} [maxImageSize] - The maximum allowed image size in total
173  *   pixels, i.e. width * height. Images above this value will not be rendered.
174  *   Use -1 for no limit, which is also the default value.
175  * @property {boolean} [isEvalSupported] - Determines if we can evaluate strings
176  *   as JavaScript. Primarily used to improve performance of font rendering, and
177  *   when parsing PDF functions. The default value is `true`.
178  * @property {boolean} [isOffscreenCanvasSupported] - Determines if we can use
179  *   `OffscreenCanvas` in the worker. Primarily used to improve performance of
180  *   image conversion/rendering.
181  *   The default value is `true` in web environments and `false` in Node.js.
182  * @property {number} [canvasMaxAreaInBytes] - The integer value is used to
183  *   know when an image must be resized (uses `OffscreenCanvas` in the worker).
184  *   If it's -1 then a possibly slow algorithm is used to guess the max value.
185  * @property {boolean} [disableFontFace] - By default fonts are converted to
186  *   OpenType fonts and loaded via the Font Loading API or `@font-face` rules.
187  *   If disabled, fonts will be rendered using a built-in font renderer that
188  *   constructs the glyphs with primitive path commands.
189  *   The default value is `false` in web environments and `true` in Node.js.
190  * @property {boolean} [fontExtraProperties] - Include additional properties,
191  *   which are unused during rendering of PDF documents, when exporting the
192  *   parsed font data from the worker-thread. This may be useful for debugging
193  *   purposes (and backwards compatibility), but note that it will lead to
194  *   increased memory usage. The default value is `false`.
195  * @property {boolean} [enableXfa] - Render Xfa forms if any.
196  *   The default value is `false`.
197  * @property {HTMLDocument} [ownerDocument] - Specify an explicit document
198  *   context to create elements with and to load resources, such as fonts,
199  *   into. Defaults to the current document.
200  * @property {boolean} [disableRange] - Disable range request loading of PDF
201  *   files. When enabled, and if the server supports partial content requests,
202  *   then the PDF will be fetched in chunks. The default value is `false`.
203  * @property {boolean} [disableStream] - Disable streaming of PDF file data.
204  *   By default PDF.js attempts to load PDF files in chunks. The default value
205  *   is `false`.
206  * @property {boolean} [disableAutoFetch] - Disable pre-fetching of PDF file
207  *   data. When range requests are enabled PDF.js will automatically keep
208  *   fetching more data even if it isn't needed to display the current page.
209  *   The default value is `false`.
210  *
211  *   NOTE: It is also necessary to disable streaming, see above, in order for
212  *   disabling of pre-fetching to work correctly.
213  * @property {boolean} [pdfBug] - Enables special hooks for debugging PDF.js
214  *   (see `web/debugger.js`). The default value is `false`.
215  * @property {Object} [canvasFactory] - The factory instance that will be used
216  *   when creating canvases. The default value is {new DOMCanvasFactory()}.
217  * @property {Object} [filterFactory] - A factory instance that will be used
218  *   to create SVG filters when rendering some images on the main canvas.
219  */
220 
221 /**
222  * This is the main entry point for loading a PDF and interacting with it.
223  *
224  * NOTE: If a URL is used to fetch the PDF data a standard Fetch API call (or
225  * XHR as fallback) is used, which means it must follow same origin rules,
226  * e.g. no cross-domain requests without CORS.
227  *
228  * @param {string | URL | TypedArray | ArrayBuffer | DocumentInitParameters}
229  *   src - Can be a URL where a PDF file is located, a typed array (Uint8Array)
230  *         already populated with data, or a parameter object.
231  * @returns {PDFDocumentLoadingTask}
232  */
233 function getDocument(src) {
234   if (typeof PDFJSDev === "undefined" || PDFJSDev.test("GENERIC")) {
235     if (typeof src === "string" || src instanceof URL) {
236       src = { url: src };
237     } else if (isArrayBuffer(src)) {
238       src = { data: src };
239     }
240   }
241   if (typeof src !== "object") {
242     throw new Error("Invalid parameter in getDocument, need parameter object.");
243   }
244   if (!src.url && !src.data && !src.range) {
245     throw new Error(
246       "Invalid parameter object: need either .data, .range or .url"
247     );
248   }
249   const task = new PDFDocumentLoadingTask();
250   const { docId } = task;
251 
252   const url = src.url ? getUrlProp(src.url) : null;
253   const data = src.data ? getDataProp(src.data) : null;
254   const httpHeaders = src.httpHeaders || null;
255   const withCredentials = src.withCredentials === true;
256   const password = src.password ?? null;
257   const rangeTransport =
258     src.range instanceof PDFDataRangeTransport ? src.range : null;
259   const rangeChunkSize =
260     Number.isInteger(src.rangeChunkSize) && src.rangeChunkSize > 0
261       ? src.rangeChunkSize
262       : DEFAULT_RANGE_CHUNK_SIZE;
263   let worker = src.worker instanceof PDFWorker ? src.worker : null;
264   const verbosity = src.verbosity;
265   // Ignore "data:"-URLs, since they can't be used to recover valid absolute
266   // URLs anyway. We want to avoid sending them to the worker-thread, since
267   // they contain the *entire* PDF document and can thus be arbitrarily long.
268   const docBaseUrl =
269     typeof src.docBaseUrl === "string" && !isDataScheme(src.docBaseUrl)
270       ? src.docBaseUrl
271       : null;
272   const cMapUrl = typeof src.cMapUrl === "string" ? src.cMapUrl : null;
273   const cMapPacked = src.cMapPacked !== false;
274   const CMapReaderFactory = src.CMapReaderFactory || DefaultCMapReaderFactory;
275   const standardFontDataUrl =
276     typeof src.standardFontDataUrl === "string"
277       ? src.standardFontDataUrl
278       : null;
279   const StandardFontDataFactory =
280     src.StandardFontDataFactory || DefaultStandardFontDataFactory;
281   const ignoreErrors = src.stopAtErrors !== true;
282   const maxImageSize =
283     Number.isInteger(src.maxImageSize) && src.maxImageSize > -1
284       ? src.maxImageSize
285       : -1;
286   const isEvalSupported = src.isEvalSupported !== false;
287   const isOffscreenCanvasSupported =
288     typeof src.isOffscreenCanvasSupported === "boolean"
289       ? src.isOffscreenCanvasSupported
290       : !isNodeJS;
291   const canvasMaxAreaInBytes = Number.isInteger(src.canvasMaxAreaInBytes)
292     ? src.canvasMaxAreaInBytes
293     : -1;
294   const disableFontFace =
295     typeof src.disableFontFace === "boolean" ? src.disableFontFace : isNodeJS;
296   const fontExtraProperties = src.fontExtraProperties === true;
297   const enableXfa = src.enableXfa === true;
298   const ownerDocument = src.ownerDocument || globalThis.document;
299   const disableRange = src.disableRange === true;
300   const disableStream = src.disableStream === true;
301   const disableAutoFetch = src.disableAutoFetch === true;
302   const pdfBug = src.pdfBug === true;
303 
304   // Parameters whose default values depend on other parameters.
305   const length = rangeTransport ? rangeTransport.length : src.length ?? NaN;
306   const useSystemFonts =
307     typeof src.useSystemFonts === "boolean"
308       ? src.useSystemFonts
309       : !isNodeJS && !disableFontFace;
310   const useWorkerFetch =
311     typeof src.useWorkerFetch === "boolean"
312       ? src.useWorkerFetch
313       : (typeof PDFJSDev !== "undefined" && PDFJSDev.test("MOZCENTRAL")) ||
314         (CMapReaderFactory === DOMCMapReaderFactory &&
315           StandardFontDataFactory === DOMStandardFontDataFactory &&
316           cMapUrl &&
317           standardFontDataUrl &&
318           isValidFetchUrl(cMapUrl, document.baseURI) &&
319           isValidFetchUrl(standardFontDataUrl, document.baseURI));
320   const canvasFactory =
321     src.canvasFactory || new DefaultCanvasFactory({ ownerDocument });
322   const filterFactory =
323     src.filterFactory || new DefaultFilterFactory({ docId, ownerDocument });
324 
325   // Parameters only intended for development/testing purposes.
326   const styleElement =
327     typeof PDFJSDev === "undefined" || PDFJSDev.test("TESTING")
328       ? src.styleElement
329       : null;
330 
331   // Set the main-thread verbosity level.
332   setVerbosityLevel(verbosity);
333 
334   // Ensure that the various factories can be initialized, when necessary,
335   // since the user may provide *custom* ones.
336   const transportFactory = {
337     canvasFactory,
338     filterFactory,
339   };
340   if (!useWorkerFetch) {
341     transportFactory.cMapReaderFactory = new CMapReaderFactory({
342       baseUrl: cMapUrl,
343       isCompressed: cMapPacked,
344     });
345     transportFactory.standardFontDataFactory = new StandardFontDataFactory({
346       baseUrl: standardFontDataUrl,
347     });
348   }
349 
350   if (!worker) {
351     const workerParams = {
352       verbosity,
353       port: GlobalWorkerOptions.workerPort,
354     };
355     // Worker was not provided -- creating and owning our own. If message port
356     // is specified in global worker options, using it.
357     worker = workerParams.port
358       ? PDFWorker.fromPort(workerParams)
359       : new PDFWorker(workerParams);
360     task._worker = worker;
361   }
362 
363   const fetchDocParams = {
364     docId,
365     apiVersion:
366       typeof PDFJSDev !== "undefined" && !PDFJSDev.test("TESTING")
367         ? PDFJSDev.eval("BUNDLE_VERSION")
368         : null,
369     data,
370     password,
371     disableAutoFetch,
372     rangeChunkSize,
373     length,
374     docBaseUrl,
375     enableXfa,
376     evaluatorOptions: {
377       maxImageSize,
378       disableFontFace,
379       ignoreErrors,
380       isEvalSupported,
381       isOffscreenCanvasSupported,
382       canvasMaxAreaInBytes,
383       fontExtraProperties,
384       useSystemFonts,
385       cMapUrl: useWorkerFetch ? cMapUrl : null,
386       standardFontDataUrl: useWorkerFetch ? standardFontDataUrl : null,
387     },
388   };
389   const transportParams = {
390     ignoreErrors,
391     isEvalSupported,
392     disableFontFace,
393     fontExtraProperties,
394     enableXfa,
395     ownerDocument,
396     disableAutoFetch,
397     pdfBug,
398     styleElement,
399   };
400 
401   worker.promise
402     .then(function () {
403       if (task.destroyed) {
404         throw new Error("Loading aborted");
405       }
406 
407       const workerIdPromise = _fetchDocument(worker, fetchDocParams);
408       const networkStreamPromise = new Promise(function (resolve) {
409         let networkStream;
410         if (rangeTransport) {
411           networkStream = new PDFDataTransportStream(
412             {
413               length,
414               initialData: rangeTransport.initialData,
415               progressiveDone: rangeTransport.progressiveDone,
416               contentDispositionFilename:
417                 rangeTransport.contentDispositionFilename,
418               disableRange,
419               disableStream,
420             },
421             rangeTransport
422           );
423         } else if (!data) {
424           if (typeof PDFJSDev !== "undefined" && PDFJSDev.test("MOZCENTRAL")) {
425             throw new Error("Not implemented: createPDFNetworkStream");
426           }
427           const createPDFNetworkStream = params => {
428             if (
429               typeof PDFJSDev !== "undefined" &&
430               PDFJSDev.test("GENERIC") &&
431               isNodeJS
432             ) {
433               return new PDFNodeStream(params);
434             }
435             return isValidFetchUrl(params.url)
436               ? new PDFFetchStream(params)
437               : new PDFNetworkStream(params);
438           };
439 
440           networkStream = createPDFNetworkStream({
441             url,
442             length,
443             httpHeaders,
444             withCredentials,
445             rangeChunkSize,
446             disableRange,
447             disableStream,
448           });
449         }
450         resolve(networkStream);
451       });
452 
453       return Promise.all([workerIdPromise, networkStreamPromise]).then(
454         function ([workerId, networkStream]) {
455           if (task.destroyed) {
456             throw new Error("Loading aborted");
457           }
458 
459           const messageHandler = new MessageHandler(
460             docId,
461             workerId,
462             worker.port
463           );
464           const transport = new WorkerTransport(
465             messageHandler,
466             task,
467             networkStream,
468             transportParams,
469             transportFactory
470           );
471           task._transport = transport;
472           messageHandler.send("Ready", null);
473         }
474       );
475     })
476     .catch(task._capability.reject);
477 
478   return task;
479 }
480 
481 /**
482  * Starts fetching of specified PDF document/data.
483  *
484  * @param {PDFWorker} worker
485  * @param {Object} source
486  * @returns {Promise<string>} A promise that is resolved when the worker ID of
487  *   the `MessageHandler` is known.
488  * @private
489  */
490 async function _fetchDocument(worker, source) {
491   if (worker.destroyed) {
492     throw new Error("Worker was destroyed");
493   }
494   const workerId = await worker.messageHandler.sendWithPromise(
495     "GetDocRequest",
496     source,
497     source.data ? [source.data.buffer] : null
498   );
499 
500   if (worker.destroyed) {
501     throw new Error("Worker was destroyed");
502   }
503   return workerId;
504 }
505 
506 function getUrlProp(val) {
507   if (typeof PDFJSDev !== "undefined" && PDFJSDev.test("MOZCENTRAL")) {
508     return null; // The 'url' is unused with `PDFDataRangeTransport`.
509   }
510   if (val instanceof URL) {
511     return val.href;
512   }
513   try {
514     // The full path is required in the 'url' field.
515     return new URL(val, window.location).href;
516   } catch {
517     if (
518       typeof PDFJSDev !== "undefined" &&
519       PDFJSDev.test("GENERIC") &&
520       isNodeJS &&
521       typeof val === "string"
522     ) {
523       return val; // Use the url as-is in Node.js environments.
524     }
525   }
526   throw new Error(
527     "Invalid PDF url data: " +
528       "either string or URL-object is expected in the url property."
529   );
530 }
531 
532 function getDataProp(val) {
533   // Converting string or array-like data to Uint8Array.
534   if (
535     typeof PDFJSDev !== "undefined" &&
536     PDFJSDev.test("GENERIC") &&
537     isNodeJS &&
538     typeof Buffer !== "undefined" && // eslint-disable-line no-undef
539     val instanceof Buffer // eslint-disable-line no-undef
540   ) {
541     throw new Error(
542       "Please provide binary data as `Uint8Array`, rather than `Buffer`."
543     );
544   }
545   if (val instanceof Uint8Array && val.byteLength === val.buffer.byteLength) {
546     // Use the data as-is when it's already a Uint8Array that completely
547     // "utilizes" its underlying ArrayBuffer, to prevent any possible
548     // issues when transferring it to the worker-thread.
549     return val;
550   }
551   if (typeof val === "string") {
552     return stringToBytes(val);
553   }
554   if ((typeof val === "object" && !isNaN(val?.length)) || isArrayBuffer(val)) {
555     return new Uint8Array(val);
556   }
557   throw new Error(
558     "Invalid PDF binary data: either TypedArray, " +
559       "string, or array-like object is expected in the data property."
560   );
561 }
562 
563 /**
564  * @typedef {Object} OnProgressParameters
565  * @property {number} loaded - Currently loaded number of bytes.
566  * @property {number} total - Total number of bytes in the PDF file.
567  */
568 
569 /**
570  * The loading task controls the operations required to load a PDF document
571  * (such as network requests) and provides a way to listen for completion,
572  * after which individual pages can be rendered.
573  */
574 class PDFDocumentLoadingTask {
575   static #docId = 0;
576 
577   constructor() {
578     this._capability = new PromiseCapability();
579     this._transport = null;
580     this._worker = null;
581 
582     /**
583      * Unique identifier for the document loading task.
584      * @type {string}
585      */
586     this.docId = `d${PDFDocumentLoadingTask.#docId++}`;
587 
588     /**
589      * Whether the loading task is destroyed or not.
590      * @type {boolean}
591      */
592     this.destroyed = false;
593 
594     /**
595      * Callback to request a password if a wrong or no password was provided.
596      * The callback receives two parameters: a function that should be called
597      * with the new password, and a reason (see {@link PasswordResponses}).
598      * @type {function}
599      */
600     this.onPassword = null;
601 
602     /**
603      * Callback to be able to monitor the loading progress of the PDF file
604      * (necessary to implement e.g. a loading bar).
605      * The callback receives an {@link OnProgressParameters} argument.
606      * @type {function}
607      */
608     this.onProgress = null;
609   }
610 
611   /**
612    * Promise for document loading task completion.
613    * @type {Promise<PDFDocumentProxy>}
614    */
615   get promise() {
616     return this._capability.promise;
617   }
618 
619   /**
620    * Abort all network requests and destroy the worker.
621    * @returns {Promise<void>} A promise that is resolved when destruction is
622    *   completed.
623    */
624   async destroy() {
625     this.destroyed = true;
626     try {
627       if (this._worker?.port) {
628         this._worker._pendingDestroy = true;
629       }
630       await this._transport?.destroy();
631     } catch (ex) {
632       if (this._worker?.port) {
633         delete this._worker._pendingDestroy;
634       }
635       throw ex;
636     }
637 
638     this._transport = null;
639     if (this._worker) {
640       this._worker.destroy();
641       this._worker = null;
642     }
643   }
644 }
645 
646 /**
647  * Abstract class to support range requests file loading.
648  *
649  * NOTE: The TypedArrays passed to the constructor and relevant methods below
650  * will generally be transferred to the worker-thread. This will help reduce
651  * main-thread memory usage, however it will take ownership of the TypedArrays.
652  */
653 class PDFDataRangeTransport {
654   /**
655    * @param {number} length
656    * @param {Uint8Array|null} initialData
657    * @param {boolean} [progressiveDone]
658    * @param {string} [contentDispositionFilename]
659    */
660   constructor(
661     length,
662     initialData,
663     progressiveDone = false,
664     contentDispositionFilename = null
665   ) {
666     this.length = length;
667     this.initialData = initialData;
668     this.progressiveDone = progressiveDone;
669     this.contentDispositionFilename = contentDispositionFilename;
670 
671     this._rangeListeners = [];
672     this._progressListeners = [];
673     this._progressiveReadListeners = [];
674     this._progressiveDoneListeners = [];
675     this._readyCapability = new PromiseCapability();
676   }
677 
678   /**
679    * @param {function} listener
680    */
681   addRangeListener(listener) {
682     this._rangeListeners.push(listener);
683   }
684 
685   /**
686    * @param {function} listener
687    */
688   addProgressListener(listener) {
689     this._progressListeners.push(listener);
690   }
691 
692   /**
693    * @param {function} listener
694    */
695   addProgressiveReadListener(listener) {
696     this._progressiveReadListeners.push(listener);
697   }
698 
699   /**
700    * @param {function} listener
701    */
702   addProgressiveDoneListener(listener) {
703     this._progressiveDoneListeners.push(listener);
704   }
705 
706   /**
707    * @param {number} begin
708    * @param {Uint8Array|null} chunk
709    */
710   onDataRange(begin, chunk) {
711     for (const listener of this._rangeListeners) {
712       listener(begin, chunk);
713     }
714   }
715 
716   /**
717    * @param {number} loaded
718    * @param {number|undefined} total
719    */
720   onDataProgress(loaded, total) {
721     this._readyCapability.promise.then(() => {
722       for (const listener of this._progressListeners) {
723         listener(loaded, total);
724       }
725     });
726   }
727 
728   /**
729    * @param {Uint8Array|null} chunk
730    */
731   onDataProgressiveRead(chunk) {
732     this._readyCapability.promise.then(() => {
733       for (const listener of this._progressiveReadListeners) {
734         listener(chunk);
735       }
736     });
737   }
738 
739   onDataProgressiveDone() {
740     this._readyCapability.promise.then(() => {
741       for (const listener of this._progressiveDoneListeners) {
742         listener();
743       }
744     });
745   }
746 
747   transportReady() {
748     this._readyCapability.resolve();
749   }
750 
751   /**
752    * @param {number} begin
753    * @param {number} end
754    */
755   requestDataRange(begin, end) {
756     unreachable("Abstract method PDFDataRangeTransport.requestDataRange");
757   }
758 
759   abort() {}
760 }
761 
762 /**
763  * Proxy to a `PDFDocument` in the worker thread.
764  */
765 class PDFDocumentProxy {
766   constructor(pdfInfo, transport) {
767     this._pdfInfo = pdfInfo;
768     this._transport = transport;
769 
770     if (typeof PDFJSDev === "undefined" || PDFJSDev.test("TESTING")) {
771       // For testing purposes.
772       Object.defineProperty(this, "getXFADatasets", {
773         value: () => {
774           return this._transport.getXFADatasets();
775         },
776       });
777       Object.defineProperty(this, "getXRefPrevValue", {
778         value: () => {
779           return this._transport.getXRefPrevValue();
780         },
781       });
782       Object.defineProperty(this, "getAnnotArray", {
783         value: pageIndex => {
784           return this._transport.getAnnotArray(pageIndex);
785         },
786       });
787     }
788   }
789 
790   /**
791    * @type {AnnotationStorage} Storage for annotation data in forms.
792    */
793   get annotationStorage() {
794     return this._transport.annotationStorage;
795   }
796 
797   /**
798    * @type {Object} The filter factory instance.
799    */
800   get filterFactory() {
801     return this._transport.filterFactory;
802   }
803 
804   /**
805    * @type {number} Total number of pages in the PDF file.
806    */
807   get numPages() {
808     return this._pdfInfo.numPages;
809   }
810 
811   /**
812    * @type {Array<string, string|null>} A (not guaranteed to be) unique ID to
813    *   identify the PDF document.
814    *   NOTE: The first element will always be defined for all PDF documents,
815    *   whereas the second element is only defined for *modified* PDF documents.
816    */
817   get fingerprints() {
818     return this._pdfInfo.fingerprints;
819   }
820 
821   /**
822    * @type {boolean} True if only XFA form.
823    */
824   get isPureXfa() {
825     return shadow(this, "isPureXfa", !!this._transport._htmlForXfa);
826   }
827 
828   /**
829    * NOTE: This is (mostly) intended to support printing of XFA forms.
830    *
831    * @type {Object | null} An object representing a HTML tree structure
832    *   to render the XFA, or `null` when no XFA form exists.
833    */
834   get allXfaHtml() {
835     return this._transport._htmlForXfa;
836   }
837 
838   /**
839    * @param {number} pageNumber - The page number to get. The first page is 1.
840    * @returns {Promise<PDFPageProxy>} A promise that is resolved with
841    *   a {@link PDFPageProxy} object.
842    */
843   getPage(pageNumber) {
844     return this._transport.getPage(pageNumber);
845   }
846 
847   /**
848    * @param {RefProxy} ref - The page reference.
849    * @returns {Promise<number>} A promise that is resolved with the page index,
850    *   starting from zero, that is associated with the reference.
851    */
852   getPageIndex(ref) {
853     return this._transport.getPageIndex(ref);
854   }
855 
856   /**
857    * @returns {Promise<Object<string, Array<any>>>} A promise that is resolved
858    *   with a mapping from named destinations to references.
859    *
860    * This can be slow for large documents. Use `getDestination` instead.
861    */
862   getDestinations() {
863     return this._transport.getDestinations();
864   }
865 
866   /**
867    * @param {string} id - The named destination to get.
868    * @returns {Promise<Array<any> | null>} A promise that is resolved with all
869    *   information of the given named destination, or `null` when the named
870    *   destination is not present in the PDF file.
871    */
872   getDestination(id) {
873     return this._transport.getDestination(id);
874   }
875 
876   /**
877    * @returns {Promise<Array<string> | null>} A promise that is resolved with
878    *   an {Array} containing the page labels that correspond to the page
879    *   indexes, or `null` when no page labels are present in the PDF file.
880    */
881   getPageLabels() {
882     return this._transport.getPageLabels();
883   }
884 
885   /**
886    * @returns {Promise<string>} A promise that is resolved with a {string}
887    *   containing the page layout name.
888    */
889   getPageLayout() {
890     return this._transport.getPageLayout();
891   }
892 
893   /**
894    * @returns {Promise<string>} A promise that is resolved with a {string}
895    *   containing the page mode name.
896    */
897   getPageMode() {
898     return this._transport.getPageMode();
899   }
900 
901   /**
902    * @returns {Promise<Object | null>} A promise that is resolved with an
903    *   {Object} containing the viewer preferences, or `null` when no viewer
904    *   preferences are present in the PDF file.
905    */
906   getViewerPreferences() {
907     return this._transport.getViewerPreferences();
908   }
909 
910   /**
911    * @returns {Promise<any | null>} A promise that is resolved with an {Array}
912    *   containing the destination, or `null` when no open action is present
913    *   in the PDF.
914    */
915   getOpenAction() {
916     return this._transport.getOpenAction();
917   }
918 
919   /**
920    * @returns {Promise<any>} A promise that is resolved with a lookup table
921    *   for mapping named attachments to their content.
922    */
923   getAttachments() {
924     return this._transport.getAttachments();
925   }
926 
927   /**
928    * @returns {Promise<Object | null>} A promise that is resolved with
929    *   an {Object} with the JavaScript actions:
930    *     - from the name tree.
931    *     - from A or AA entries in the catalog dictionary.
932    *   , or `null` if no JavaScript exists.
933    */
934   getJSActions() {
935     return this._transport.getDocJSActions();
936   }
937 
938   /**
939    * @typedef {Object} OutlineNode
940    * @property {string} title
941    * @property {boolean} bold
942    * @property {boolean} italic
943    * @property {Uint8ClampedArray} color - The color in RGB format to use for
944    *   display purposes.
945    * @property {string | Array<any> | null} dest
946    * @property {string | null} url
947    * @property {string | undefined} unsafeUrl
948    * @property {boolean | undefined} newWindow
949    * @property {number | undefined} count
950    * @property {Array<OutlineNode>} items
951    */
952 
953   /**
954    * @returns {Promise<Array<OutlineNode>>} A promise that is resolved with an
955    *   {Array} that is a tree outline (if it has one) of the PDF file.
956    */
957   getOutline() {
958     return this._transport.getOutline();
959   }
960 
961   /**
962    * @returns {Promise<OptionalContentConfig>} A promise that is resolved with
963    *   an {@link OptionalContentConfig} that contains all the optional content
964    *   groups (assuming that the document has any).
965    */
966   getOptionalContentConfig() {
967     return this._transport.getOptionalContentConfig();
968   }
969 
970   /**
971    * @returns {Promise<Array<number> | null>} A promise that is resolved with
972    *   an {Array} that contains the permission flags for the PDF document, or
973    *   `null` when no permissions are present in the PDF file.
974    */
975   getPermissions() {
976     return this._transport.getPermissions();
977   }
978 
979   /**
980    * @returns {Promise<{ info: Object, metadata: Metadata }>} A promise that is
981    *   resolved with an {Object} that has `info` and `metadata` properties.
982    *   `info` is an {Object} filled with anything available in the information
983    *   dictionary and similarly `metadata` is a {Metadata} object with
984    *   information from the metadata section of the PDF.
985    */
986   getMetadata() {
987     return this._transport.getMetadata();
988   }
989 
990   /**
991    * @typedef {Object} MarkInfo
992    * Properties correspond to Table 321 of the PDF 32000-1:2008 spec.
993    * @property {boolean} Marked
994    * @property {boolean} UserProperties
995    * @property {boolean} Suspects
996    */
997 
998   /**
999    * @returns {Promise<MarkInfo | null>} A promise that is resolved with
1000    *   a {MarkInfo} object that contains the MarkInfo flags for the PDF
1001    *   document, or `null` when no MarkInfo values are present in the PDF file.
1002    */
1003   getMarkInfo() {
1004     return this._transport.getMarkInfo();
1005   }
1006 
1007   /**
1008    * @returns {Promise<Uint8Array>} A promise that is resolved with a
1009    *   {Uint8Array} containing the raw data of the PDF document.
1010    */
1011   getData() {
1012     return this._transport.getData();
1013   }
1014 
1015   /**
1016    * @returns {Promise<Uint8Array>} A promise that is resolved with a
1017    *   {Uint8Array} containing the full data of the saved document.
1018    */
1019   saveDocument() {
1020     return this._transport.saveDocument();
1021   }
1022 
1023   /**
1024    * @returns {Promise<{ length: number }>} A promise that is resolved when the
1025    *   document's data is loaded. It is resolved with an {Object} that contains
1026    *   the `length` property that indicates size of the PDF data in bytes.
1027    */
1028   getDownloadInfo() {
1029     return this._transport.downloadInfoCapability.promise;
1030   }
1031 
1032   /**
1033    * Cleans up resources allocated by the document on both the main and worker
1034    * threads.
1035    *
1036    * NOTE: Do not, under any circumstances, call this method when rendering is
1037    * currently ongoing since that may lead to rendering errors.
1038    *
1039    * @param {boolean} [keepLoadedFonts] - Let fonts remain attached to the DOM.
1040    *   NOTE: This will increase persistent memory usage, hence don't use this
1041    *   option unless absolutely necessary. The default value is `false`.
1042    * @returns {Promise} A promise that is resolved when clean-up has finished.
1043    */
1044   cleanup(keepLoadedFonts = false) {
1045     return this._transport.startCleanup(keepLoadedFonts || this.isPureXfa);
1046   }
1047 
1048   /**
1049    * Destroys the current document instance and terminates the worker.
1050    */
1051   destroy() {
1052     return this.loadingTask.destroy();
1053   }
1054 
1055   /**
1056    * @type {DocumentInitParameters} A subset of the current
1057    *   {DocumentInitParameters}, which are needed in the viewer.
1058    */
1059   get loadingParams() {
1060     return this._transport.loadingParams;
1061   }
1062 
1063   /**
1064    * @type {PDFDocumentLoadingTask} The loadingTask for the current document.
1065    */
1066   get loadingTask() {
1067     return this._transport.loadingTask;
1068   }
1069 
1070   /**
1071    * @returns {Promise<Object<string, Array<Object>> | null>} A promise that is
1072    *   resolved with an {Object} containing /AcroForm field data for the JS
1073    *   sandbox, or `null` when no field data is present in the PDF file.
1074    */
1075   getFieldObjects() {
1076     return this._transport.getFieldObjects();
1077   }
1078 
1079   /**
1080    * @returns {Promise<boolean>} A promise that is resolved with `true`
1081    *   if some /AcroForm fields have JavaScript actions.
1082    */
1083   hasJSActions() {
1084     return this._transport.hasJSActions();
1085   }
1086 
1087   /**
1088    * @returns {Promise<Array<string> | null>} A promise that is resolved with an
1089    *   {Array<string>} containing IDs of annotations that have a calculation
1090    *   action, or `null` when no such annotations are present in the PDF file.
1091    */
1092   getCalculationOrderIds() {
1093     return this._transport.getCalculationOrderIds();
1094   }
1095 }
1096 
1097 /**
1098  * Page getViewport parameters.
1099  *
1100  * @typedef {Object} GetViewportParameters
1101  * @property {number} scale - The desired scale of the viewport.
1102  * @property {number} [rotation] - The desired rotation, in degrees, of
1103  *   the viewport. If omitted it defaults to the page rotation.
1104  * @property {number} [offsetX] - The horizontal, i.e. x-axis, offset.
1105  *   The default value is `0`.
1106  * @property {number} [offsetY] - The vertical, i.e. y-axis, offset.
1107  *   The default value is `0`.
1108  * @property {boolean} [dontFlip] - If true, the y-axis will not be
1109  *   flipped. The default value is `false`.
1110  */
1111 
1112 /**
1113  * Page getTextContent parameters.
1114  *
1115  * @typedef {Object} getTextContentParameters
1116  * @property {boolean} [includeMarkedContent] - When true include marked
1117  *   content items in the items array of TextContent. The default is `false`.
1118  * @property {boolean} [disableNormalization] - When true the text is *not*
1119  *   normalized in the worker-thread. The default is `false`.
1120  */
1121 
1122 /**
1123  * Page text content.
1124  *
1125  * @typedef {Object} TextContent
1126  * @property {Array<TextItem | TextMarkedContent>} items - Array of
1127  *   {@link TextItem} and {@link TextMarkedContent} objects. TextMarkedContent
1128  *   items are included when includeMarkedContent is true.
1129  * @property {Object<string, TextStyle>} styles - {@link TextStyle} objects,
1130  *   indexed by font name.
1131  */
1132 
1133 /**
1134  * Page text content part.
1135  *
1136  * @typedef {Object} TextItem
1137  * @property {string} str - Text content.
1138  * @property {string} dir - Text direction: 'ttb', 'ltr' or 'rtl'.
1139  * @property {Array<any>} transform - Transformation matrix.
1140  * @property {number} width - Width in device space.
1141  * @property {number} height - Height in device space.
1142  * @property {string} fontName - Font name used by PDF.js for converted font.
1143  * @property {boolean} hasEOL - Indicating if the text content is followed by a
1144  *   line-break.
1145  */
1146 
1147 /**
1148  * Page text marked content part.
1149  *
1150  * @typedef {Object} TextMarkedContent
1151  * @property {string} type - Either 'beginMarkedContent',
1152  *   'beginMarkedContentProps', or 'endMarkedContent'.
1153  * @property {string} id - The marked content identifier. Only used for type
1154  *   'beginMarkedContentProps'.
1155  */
1156 
1157 /**
1158  * Text style.
1159  *
1160  * @typedef {Object} TextStyle
1161  * @property {number} ascent - Font ascent.
1162  * @property {number} descent - Font descent.
1163  * @property {boolean} vertical - Whether or not the text is in vertical mode.
1164  * @property {string} fontFamily - The possible font family.
1165  */
1166 
1167 /**
1168  * Page annotation parameters.
1169  *
1170  * @typedef {Object} GetAnnotationsParameters
1171  * @property {string} [intent] - Determines the annotations that are fetched,
1172  *   can be 'display' (viewable annotations), 'print' (printable annotations),
1173  *   or 'any' (all annotations). The default value is 'display'.
1174  */
1175 
1176 /**
1177  * Page render parameters.
1178  *
1179  * @typedef {Object} RenderParameters
1180  * @property {CanvasRenderingContext2D} canvasContext - A 2D context of a DOM
1181  *   Canvas object.
1182  * @property {PageViewport} viewport - Rendering viewport obtained by calling
1183  *   the `PDFPageProxy.getViewport` method.
1184  * @property {string} [intent] - Rendering intent, can be 'display', 'print',
1185  *   or 'any'. The default value is 'display'.
1186  * @property {number} [annotationMode] Controls which annotations are rendered
1187  *   onto the canvas, for annotations with appearance-data; the values from
1188  *   {@link AnnotationMode} should be used. The following values are supported:
1189  *    - `AnnotationMode.DISABLE`, which disables all annotations.
1190  *    - `AnnotationMode.ENABLE`, which includes all possible annotations (thus
1191  *      it also depends on the `intent`-option, see above).
1192  *    - `AnnotationMode.ENABLE_FORMS`, which excludes annotations that contain
1193  *      interactive form elements (those will be rendered in the display layer).
1194  *    - `AnnotationMode.ENABLE_STORAGE`, which includes all possible annotations
1195  *      (as above) but where interactive form elements are updated with data
1196  *      from the {@link AnnotationStorage}-instance; useful e.g. for printing.
1197  *   The default value is `AnnotationMode.ENABLE`.
1198  * @property {Array<any>} [transform] - Additional transform, applied just
1199  *   before viewport transform.
1200  * @property {CanvasGradient | CanvasPattern | string} [background] - Background
1201  *   to use for the canvas.
1202  *   Any valid `canvas.fillStyle` can be used: a `DOMString` parsed as CSS
1203  *   <color> value, a `CanvasGradient` object (a linear or radial gradient) or
1204  *   a `CanvasPattern` object (a repetitive image). The default value is
1205  *   'rgb(255,255,255)'.
1206  *
1207  *   NOTE: This option may be partially, or completely, ignored when the
1208  *   `pageColors`-option is used.
1209  * @property {Object} [pageColors] - Overwrites background and foreground colors
1210  *   with user defined ones in order to improve readability in high contrast
1211  *   mode.
1212  * @property {Promise<OptionalContentConfig>} [optionalContentConfigPromise] -
1213  *   A promise that should resolve with an {@link OptionalContentConfig}
1214  *   created from `PDFDocumentProxy.getOptionalContentConfig`. If `null`,
1215  *   the configuration will be fetched automatically with the default visibility
1216  *   states set.
1217  * @property {Map<string, HTMLCanvasElement>} [annotationCanvasMap] - Map some
1218  *   annotation ids with canvases used to render them.
1219  * @property {PrintAnnotationStorage} [printAnnotationStorage]
1220  */
1221 
1222 /**
1223  * Page getOperatorList parameters.
1224  *
1225  * @typedef {Object} GetOperatorListParameters
1226  * @property {string} [intent] - Rendering intent, can be 'display', 'print',
1227  *   or 'any'. The default value is 'display'.
1228  * @property {number} [annotationMode] Controls which annotations are included
1229  *   in the operatorList, for annotations with appearance-data; the values from
1230  *   {@link AnnotationMode} should be used. The following values are supported:
1231  *    - `AnnotationMode.DISABLE`, which disables all annotations.
1232  *    - `AnnotationMode.ENABLE`, which includes all possible annotations (thus
1233  *      it also depends on the `intent`-option, see above).
1234  *    - `AnnotationMode.ENABLE_FORMS`, which excludes annotations that contain
1235  *      interactive form elements (those will be rendered in the display layer).
1236  *    - `AnnotationMode.ENABLE_STORAGE`, which includes all possible annotations
1237  *      (as above) but where interactive form elements are updated with data
1238  *      from the {@link AnnotationStorage}-instance; useful e.g. for printing.
1239  *   The default value is `AnnotationMode.ENABLE`.
1240  * @property {PrintAnnotationStorage} [printAnnotationStorage]
1241  */
1242 
1243 /**
1244  * Structure tree node. The root node will have a role "Root".
1245  *
1246  * @typedef {Object} StructTreeNode
1247  * @property {Array<StructTreeNode | StructTreeContent>} children - Array of
1248  *   {@link StructTreeNode} and {@link StructTreeContent} objects.
1249  * @property {string} role - element's role, already mapped if a role map exists
1250  * in the PDF.
1251  */
1252 
1253 /**
1254  * Structure tree content.
1255  *
1256  * @typedef {Object} StructTreeContent
1257  * @property {string} type - either "content" for page and stream structure
1258  *   elements or "object" for object references.
1259  * @property {string} id - unique id that will map to the text layer.
1260  */
1261 
1262 /**
1263  * PDF page operator list.
1264  *
1265  * @typedef {Object} PDFOperatorList
1266  * @property {Array<number>} fnArray - Array containing the operator functions.
1267  * @property {Array<any>} argsArray - Array containing the arguments of the
1268  *   functions.
1269  */
1270 
1271 /**
1272  * Proxy to a `PDFPage` in the worker thread.
1273  */
1274 class PDFPageProxy {
1275   #delayedCleanupTimeout = null;
1276 
1277   #pendingCleanup = false;
1278 
1279   constructor(pageIndex, pageInfo, transport, pdfBug = false) {
1280     this._pageIndex = pageIndex;
1281     this._pageInfo = pageInfo;
1282     this._transport = transport;
1283     this._stats = pdfBug ? new StatTimer() : null;
1284     this._pdfBug = pdfBug;
1285     /** @type {PDFObjects} */
1286     this.commonObjs = transport.commonObjs;
1287     this.objs = new PDFObjects();
1288 
1289     this._maybeCleanupAfterRender = false;
1290     this._intentStates = new Map();
1291     this.destroyed = false;
1292   }
1293 
1294   /**
1295    * @type {number} Page number of the page. First page is 1.
1296    */
1297   get pageNumber() {
1298     return this._pageIndex + 1;
1299   }
1300 
1301   /**
1302    * @type {number} The number of degrees the page is rotated clockwise.
1303    */
1304   get rotate() {
1305     return this._pageInfo.rotate;
1306   }
1307 
1308   /**
1309    * @type {RefProxy | null} The reference that points to this page.
1310    */
1311   get ref() {
1312     return this._pageInfo.ref;
1313   }
1314 
1315   /**
1316    * @type {number} The default size of units in 1/72nds of an inch.
1317    */
1318   get userUnit() {
1319     return this._pageInfo.userUnit;
1320   }
1321 
1322   /**
1323    * @type {Array<number>} An array of the visible portion of the PDF page in
1324    *   user space units [x1, y1, x2, y2].
1325    */
1326   get view() {
1327     return this._pageInfo.view;
1328   }
1329 
1330   /**
1331    * @param {GetViewportParameters} params - Viewport parameters.
1332    * @returns {PageViewport} Contains 'width' and 'height' properties
1333    *   along with transforms required for rendering.
1334    */
1335   getViewport({
1336     scale,
1337     rotation = this.rotate,
1338     offsetX = 0,
1339     offsetY = 0,
1340     dontFlip = false,
1341   } = {}) {
1342     return new PageViewport({
1343       viewBox: this.view,
1344       scale,
1345       rotation,
1346       offsetX,
1347       offsetY,
1348       dontFlip,
1349     });
1350   }
1351 
1352   /**
1353    * @param {GetAnnotationsParameters} params - Annotation parameters.
1354    * @returns {Promise<Array<any>>} A promise that is resolved with an
1355    *   {Array} of the annotation objects.
1356    */
1357   getAnnotations({ intent = "display" } = {}) {
1358     const intentArgs = this._transport.getRenderingIntent(intent);
1359 
1360     return this._transport.getAnnotations(
1361       this._pageIndex,
1362       intentArgs.renderingIntent
1363     );
1364   }
1365 
1366   /**
1367    * @returns {Promise<Object>} A promise that is resolved with an
1368    *   {Object} with JS actions.
1369    */
1370   getJSActions() {
1371     return this._transport.getPageJSActions(this._pageIndex);
1372   }
1373 
1374   /**
1375    * @type {Object} The filter factory instance.
1376    */
1377   get filterFactory() {
1378     return this._transport.filterFactory;
1379   }
1380 
1381   /**
1382    * @type {boolean} True if only XFA form.
1383    */
1384   get isPureXfa() {
1385     return shadow(this, "isPureXfa", !!this._transport._htmlForXfa);
1386   }
1387 
1388   /**
1389    * @returns {Promise<Object | null>} A promise that is resolved with
1390    *   an {Object} with a fake DOM object (a tree structure where elements
1391    *   are {Object} with a name, attributes (class, style, ...), value and
1392    *   children, very similar to a HTML DOM tree), or `null` if no XFA exists.
1393    */
1394   async getXfa() {
1395     return this._transport._htmlForXfa?.children[this._pageIndex] || null;
1396   }
1397 
1398   /**
1399    * Begins the process of rendering a page to the desired context.
1400    *
1401    * @param {RenderParameters} params - Page render parameters.
1402    * @returns {RenderTask} An object that contains a promise that is
1403    *   resolved when the page finishes rendering.
1404    */
1405   render({
1406     canvasContext,
1407     viewport,
1408     intent = "display",
1409     annotationMode = AnnotationMode.ENABLE,
1410     transform = null,
1411     background = null,
1412     optionalContentConfigPromise = null,
1413     annotationCanvasMap = null,
1414     pageColors = null,
1415     printAnnotationStorage = null,
1416   }) {
1417     this._stats?.time("Overall");
1418 
1419     const intentArgs = this._transport.getRenderingIntent(
1420       intent,
1421       annotationMode,
1422       printAnnotationStorage
1423     );
1424     // If there was a pending destroy, cancel it so no cleanup happens during
1425     // this call to render...
1426     this.#pendingCleanup = false;
1427     // ... and ensure that a delayed cleanup is always aborted.
1428     this.#abortDelayedCleanup();
1429 
1430     if (!optionalContentConfigPromise) {
1431       optionalContentConfigPromise = this._transport.getOptionalContentConfig();
1432     }
1433 
1434     let intentState = this._intentStates.get(intentArgs.cacheKey);
1435     if (!intentState) {
1436       intentState = Object.create(null);
1437       this._intentStates.set(intentArgs.cacheKey, intentState);
1438     }
1439 
1440     // Ensure that a pending `streamReader` cancel timeout is always aborted.
1441     if (intentState.streamReaderCancelTimeout) {
1442       clearTimeout(intentState.streamReaderCancelTimeout);
1443       intentState.streamReaderCancelTimeout = null;
1444     }
1445 
1446     const intentPrint = !!(
1447       intentArgs.renderingIntent & RenderingIntentFlag.PRINT
1448     );
1449 
1450     // If there's no displayReadyCapability yet, then the operatorList
1451     // was never requested before. Make the request and create the promise.
1452     if (!intentState.displayReadyCapability) {
1453       intentState.displayReadyCapability = new PromiseCapability();
1454       intentState.operatorList = {
1455         fnArray: [],
1456         argsArray: [],
1457         lastChunk: false,
1458         separateAnnots: null,
1459       };
1460 
1461       this._stats?.time("Page Request");
1462       this._pumpOperatorList(intentArgs);
1463     }
1464 
1465     const complete = error => {
1466       intentState.renderTasks.delete(internalRenderTask);
1467 
1468       // Attempt to reduce memory usage during *printing*, by always running
1469       // cleanup immediately once rendering has finished.
1470       if (this._maybeCleanupAfterRender || intentPrint) {
1471         this.#pendingCleanup = true;
1472       }
1473       this.#tryCleanup(/* delayed = */ !intentPrint);
1474 
1475       if (error) {
1476         internalRenderTask.capability.reject(error);
1477 
1478         this._abortOperatorList({
1479           intentState,
1480           reason: error instanceof Error ? error : new Error(error),
1481         });
1482       } else {
1483         internalRenderTask.capability.resolve();
1484       }
1485 
1486       this._stats?.timeEnd("Rendering");
1487       this._stats?.timeEnd("Overall");
1488     };
1489 
1490     const internalRenderTask = new InternalRenderTask({
1491       callback: complete,
1492       // Only include the required properties, and *not* the entire object.
1493       params: {
1494         canvasContext,
1495         viewport,
1496         transform,
1497         background,
1498       },
1499       objs: this.objs,
1500       commonObjs: this.commonObjs,
1501       annotationCanvasMap,
1502       operatorList: intentState.operatorList,
1503       pageIndex: this._pageIndex,
1504       canvasFactory: this._transport.canvasFactory,
1505       filterFactory: this._transport.filterFactory,
1506       useRequestAnimationFrame: !intentPrint,
1507       pdfBug: this._pdfBug,
1508       pageColors,
1509     });
1510 
1511     (intentState.renderTasks ||= new Set()).add(internalRenderTask);
1512     const renderTask = internalRenderTask.task;
1513 
1514     Promise.all([
1515       intentState.displayReadyCapability.promise,
1516       optionalContentConfigPromise,
1517     ])
1518       .then(([transparency, optionalContentConfig]) => {
1519         if (this.destroyed) {
1520           complete();
1521           return;
1522         }
1523         this._stats?.time("Rendering");
1524 
1525         internalRenderTask.initializeGraphics({
1526           transparency,
1527           optionalContentConfig,
1528         });
1529         internalRenderTask.operatorListChanged();
1530       })
1531       .catch(complete);
1532 
1533     return renderTask;
1534   }
1535 
1536   /**
1537    * @param {GetOperatorListParameters} params - Page getOperatorList
1538    *   parameters.
1539    * @returns {Promise<PDFOperatorList>} A promise resolved with an
1540    *   {@link PDFOperatorList} object that represents the page's operator list.
1541    */
1542   getOperatorList({
1543     intent = "display",
1544     annotationMode = AnnotationMode.ENABLE,
1545     printAnnotationStorage = null,
1546   } = {}) {
1547     if (typeof PDFJSDev !== "undefined" && !PDFJSDev.test("GENERIC")) {
1548       throw new Error("Not implemented: getOperatorList");
1549     }
1550     function operatorListChanged() {
1551       if (intentState.operatorList.lastChunk) {
1552         intentState.opListReadCapability.resolve(intentState.operatorList);
1553 
1554         intentState.renderTasks.delete(opListTask);
1555       }
1556     }
1557 
1558     const intentArgs = this._transport.getRenderingIntent(
1559       intent,
1560       annotationMode,
1561       printAnnotationStorage,
1562       /* isOpList = */ true
1563     );
1564     let intentState = this._intentStates.get(intentArgs.cacheKey);
1565     if (!intentState) {
1566       intentState = Object.create(null);
1567       this._intentStates.set(intentArgs.cacheKey, intentState);
1568     }
1569     let opListTask;
1570 
1571     if (!intentState.opListReadCapability) {
1572       opListTask = Object.create(null);
1573       opListTask.operatorListChanged = operatorListChanged;
1574       intentState.opListReadCapability = new PromiseCapability();
1575       (intentState.renderTasks ||= new Set()).add(opListTask);
1576       intentState.operatorList = {
1577         fnArray: [],
1578         argsArray: [],
1579         lastChunk: false,
1580         separateAnnots: null,
1581       };
1582 
1583       this._stats?.time("Page Request");
1584       this._pumpOperatorList(intentArgs);
1585     }
1586     return intentState.opListReadCapability.promise;
1587   }
1588 
1589   /**
1590    * NOTE: All occurrences of whitespace will be replaced by
1591    * standard spaces (0x20).
1592    *
1593    * @param {getTextContentParameters} params - getTextContent parameters.
1594    * @returns {ReadableStream} Stream for reading text content chunks.
1595    */
1596   streamTextContent({
1597     includeMarkedContent = false,
1598     disableNormalization = false,
1599   } = {}) {
1600     const TEXT_CONTENT_CHUNK_SIZE = 100;
1601 
1602     return this._transport.messageHandler.sendWithStream(
1603       "GetTextContent",
1604       {
1605         pageIndex: this._pageIndex,
1606         includeMarkedContent: includeMarkedContent === true,
1607         disableNormalization: disableNormalization === true,
1608       },
1609       {
1610         highWaterMark: TEXT_CONTENT_CHUNK_SIZE,
1611         size(textContent) {
1612           return textContent.items.length;
1613         },
1614       }
1615     );
1616   }
1617 
1618   /**
1619    * NOTE: All occurrences of whitespace will be replaced by
1620    * standard spaces (0x20).
1621    *
1622    * @param {getTextContentParameters} params - getTextContent parameters.
1623    * @returns {Promise<TextContent>} A promise that is resolved with a
1624    *   {@link TextContent} object that represents the page's text content.
1625    */
1626   getTextContent(params = {}) {
1627     if (this._transport._htmlForXfa) {
1628       // TODO: We need to revisit this once the XFA foreground patch lands and
1629       // only do this for non-foreground XFA.
1630       return this.getXfa().then(xfa => {
1631         return XfaText.textContent(xfa);
1632       });
1633     }
1634     const readableStream = this.streamTextContent(params);
1635 
1636     return new Promise(function (resolve, reject) {
1637       function pump() {
1638         reader.read().then(function ({ value, done }) {
1639           if (done) {
1640             resolve(textContent);
1641             return;
1642           }
1643           Object.assign(textContent.styles, value.styles);
1644           textContent.items.push(...value.items);
1645           pump();
1646         }, reject);
1647       }
1648 
1649       const reader = readableStream.getReader();
1650       const textContent = {
1651         items: [],
1652         styles: Object.create(null),
1653       };
1654       pump();
1655     });
1656   }
1657 
1658   /**
1659    * @returns {Promise<StructTreeNode>} A promise that is resolved with a
1660    *   {@link StructTreeNode} object that represents the page's structure tree,
1661    *   or `null` when no structure tree is present for the current page.
1662    */
1663   getStructTree() {
1664     return this._transport.getStructTree(this._pageIndex);
1665   }
1666 
1667   /**
1668    * Destroys the page object.
1669    * @private
1670    */
1671   _destroy() {
1672     this.destroyed = true;
1673 
1674     const waitOn = [];
1675     for (const intentState of this._intentStates.values()) {
1676       this._abortOperatorList({
1677         intentState,
1678         reason: new Error("Page was destroyed."),
1679         force: true,
1680       });
1681 
1682       if (intentState.opListReadCapability) {
1683         // Avoid errors below, since the renderTasks are just stubs.
1684         continue;
1685       }
1686       for (const internalRenderTask of intentState.renderTasks) {
1687         waitOn.push(internalRenderTask.completed);
1688         internalRenderTask.cancel();
1689       }
1690     }
1691     this.objs.clear();
1692     this.#pendingCleanup = false;
1693     this.#abortDelayedCleanup();
1694 
1695     return Promise.all(waitOn);
1696   }
1697 
1698   /**
1699    * Cleans up resources allocated by the page.
1700    *
1701    * @param {boolean} [resetStats] - Reset page stats, if enabled.
1702    *   The default value is `false`.
1703    * @returns {boolean} Indicates if clean-up was successfully run.
1704    */
1705   cleanup(resetStats = false) {
1706     this.#pendingCleanup = true;
1707     const success = this.#tryCleanup(/* delayed = */ false);
1708 
1709     if (resetStats && success) {
1710       this._stats &&= new StatTimer();
1711     }
1712     return success;
1713   }
1714 
1715   /**
1716    * Attempts to clean up if rendering is in a state where that's possible.
1717    * @param {boolean} [delayed] - Delay the cleanup, to e.g. improve zooming
1718    *   performance in documents with large images.
1719    *   The default value is `false`.
1720    * @returns {boolean} Indicates if clean-up was successfully run.
1721    */
1722   #tryCleanup(delayed = false) {
1723     this.#abortDelayedCleanup();
1724 
1725     if (!this.#pendingCleanup || this.destroyed) {
1726       return false;
1727     }
1728     if (delayed) {
1729       this.#delayedCleanupTimeout = setTimeout(() => {
1730         this.#delayedCleanupTimeout = null;
1731         this.#tryCleanup(/* delayed = */ false);
1732       }, DELAYED_CLEANUP_TIMEOUT);
1733 
1734       return false;
1735     }
1736     for (const { renderTasks, operatorList } of this._intentStates.values()) {
1737       if (renderTasks.size > 0 || !operatorList.lastChunk) {
1738         return false;
1739       }
1740     }
1741     this._intentStates.clear();
1742     this.objs.clear();
1743     this.#pendingCleanup = false;
1744     return true;
1745   }
1746 
1747   #abortDelayedCleanup() {
1748     if (this.#delayedCleanupTimeout) {
1749       clearTimeout(this.#delayedCleanupTimeout);
1750       this.#delayedCleanupTimeout = null;
1751     }
1752   }
1753 
1754   /**
1755    * @private
1756    */
1757   _startRenderPage(transparency, cacheKey) {
1758     const intentState = this._intentStates.get(cacheKey);
1759     if (!intentState) {
1760       return; // Rendering was cancelled.
1761     }
1762     this._stats?.timeEnd("Page Request");
1763 
1764     // TODO Refactor RenderPageRequest to separate rendering
1765     // and operator list logic
1766     intentState.displayReadyCapability?.resolve(transparency);
1767   }
1768 
1769   /**
1770    * @private
1771    */
1772   _renderPageChunk(operatorListChunk, intentState) {
1773     // Add the new chunk to the current operator list.
1774     for (let i = 0, ii = operatorListChunk.length; i < ii; i++) {
1775       intentState.operatorList.fnArray.push(operatorListChunk.fnArray[i]);
1776       intentState.operatorList.argsArray.push(operatorListChunk.argsArray[i]);
1777     }
1778     intentState.operatorList.lastChunk = operatorListChunk.lastChunk;
1779     intentState.operatorList.separateAnnots = operatorListChunk.separateAnnots;
1780 
1781     // Notify all the rendering tasks there are more operators to be consumed.
1782     for (const internalRenderTask of intentState.renderTasks) {
1783       internalRenderTask.operatorListChanged();
1784     }
1785 
1786     if (operatorListChunk.lastChunk) {
1787       this.#tryCleanup(/* delayed = */ true);
1788     }
1789   }
1790 
1791   /**
1792    * @private
1793    */
1794   _pumpOperatorList({
1795     renderingIntent,
1796     cacheKey,
1797     annotationStorageSerializable,
1798   }) {
1799     if (typeof PDFJSDev === "undefined" || PDFJSDev.test("TESTING")) {
1800       assert(
1801         Number.isInteger(renderingIntent) && renderingIntent > 0,
1802         '_pumpOperatorList: Expected valid "renderingIntent" argument.'
1803       );
1804     }
1805     const { map, transfer } = annotationStorageSerializable;
1806 
1807     const readableStream = this._transport.messageHandler.sendWithStream(
1808       "GetOperatorList",
1809       {
1810         pageIndex: this._pageIndex,
1811         intent: renderingIntent,
1812         cacheKey,
1813         annotationStorage: map,
1814       },
1815       transfer
1816     );
1817     const reader = readableStream.getReader();
1818 
1819     const intentState = this._intentStates.get(cacheKey);
1820     intentState.streamReader = reader;
1821 
1822     const pump = () => {
1823       reader.read().then(
1824         ({ value, done }) => {
1825           if (done) {
1826             intentState.streamReader = null;
1827             return;
1828           }
1829           if (this._transport.destroyed) {
1830             return; // Ignore any pending requests if the worker was terminated.
1831           }
1832           this._renderPageChunk(value, intentState);
1833           pump();
1834         },
1835         reason => {
1836           intentState.streamReader = null;
1837 
1838           if (this._transport.destroyed) {
1839             return; // Ignore any pending requests if the worker was terminated.
1840           }
1841           if (intentState.operatorList) {
1842             // Mark operator list as complete.
1843             intentState.operatorList.lastChunk = true;
1844 
1845             for (const internalRenderTask of intentState.renderTasks) {
1846               internalRenderTask.operatorListChanged();
1847             }
1848             this.#tryCleanup(/* delayed = */ true);
1849           }
1850 
1851           if (intentState.displayReadyCapability) {
1852             intentState.displayReadyCapability.reject(reason);
1853           } else if (intentState.opListReadCapability) {
1854             intentState.opListReadCapability.reject(reason);
1855           } else {
1856             throw reason;
1857           }
1858         }
1859       );
1860     };
1861     pump();
1862   }
1863 
1864   /**
1865    * @private
1866    */
1867   _abortOperatorList({ intentState, reason, force = false }) {
1868     if (typeof PDFJSDev === "undefined" || PDFJSDev.test("TESTING")) {
1869       assert(
1870         reason instanceof Error,
1871         '_abortOperatorList: Expected valid "reason" argument.'
1872       );
1873     }
1874 
1875     if (!intentState.streamReader) {
1876       return;
1877     }
1878     // Ensure that a pending `streamReader` cancel timeout is always aborted.
1879     if (intentState.streamReaderCancelTimeout) {
1880       clearTimeout(intentState.streamReaderCancelTimeout);
1881       intentState.streamReaderCancelTimeout = null;
1882     }
1883 
1884     if (!force) {
1885       // Ensure that an Error occurring in *only* one `InternalRenderTask`, e.g.
1886       // multiple render() calls on the same canvas, won't break all rendering.
1887       if (intentState.renderTasks.size > 0) {
1888         return;
1889       }
1890       // Don't immediately abort parsing on the worker-thread when rendering is
1891       // cancelled, since that will unnecessarily delay re-rendering when (for
1892       // partially parsed pages) e.g. zooming/rotation occurs in the viewer.
1893       if (reason instanceof RenderingCancelledException) {
1894         let delay = RENDERING_CANCELLED_TIMEOUT;
1895         if (reason.extraDelay > 0 && reason.extraDelay < /* ms = */ 1000) {
1896           // Above, we prevent the total delay from becoming arbitrarily large.
1897           delay += reason.extraDelay;
1898         }
1899 
1900         intentState.streamReaderCancelTimeout = setTimeout(() => {
1901           intentState.streamReaderCancelTimeout = null;
1902           this._abortOperatorList({ intentState, reason, force: true });
1903         }, delay);
1904         return;
1905       }
1906     }
1907     intentState.streamReader
1908       .cancel(new AbortException(reason.message))
1909       .catch(() => {
1910         // Avoid "Uncaught promise" messages in the console.
1911       });
1912     intentState.streamReader = null;
1913 
1914     if (this._transport.destroyed) {
1915       return; // Ignore any pending requests if the worker was terminated.
1916     }
1917     // Remove the current `intentState`, since a cancelled `getOperatorList`
1918     // call on the worker-thread cannot be re-started...
1919     for (const [curCacheKey, curIntentState] of this._intentStates) {
1920       if (curIntentState === intentState) {
1921         this._intentStates.delete(curCacheKey);
1922         break;
1923       }
1924     }
1925     // ... and force clean-up to ensure that any old state is always removed.
1926     this.cleanup();
1927   }
1928 
1929   /**
1930    * @type {StatTimer | null} Returns page stats, if enabled; returns `null`
1931    *   otherwise.
1932    */
1933   get stats() {
1934     return this._stats;
1935   }
1936 }
1937 
1938 class LoopbackPort {
1939   #listeners = new Set();
1940 
1941   #deferred = Promise.resolve();
1942 
1943   postMessage(obj, transfer) {
1944     const event = {
1945       data: structuredClone(obj, transfer ? { transfer } : null),
1946     };
1947 
1948     this.#deferred.then(() => {
1949       for (const listener of this.#listeners) {
1950         listener.call(this, event);
1951       }
1952     });
1953   }
1954 
1955   addEventListener(name, listener) {
1956     this.#listeners.add(listener);
1957   }
1958 
1959   removeEventListener(name, listener) {
1960     this.#listeners.delete(listener);
1961   }
1962 
1963   terminate() {
1964     this.#listeners.clear();
1965   }
1966 }
1967 
1968 /**
1969  * @typedef {Object} PDFWorkerParameters
1970  * @property {string} [name] - The name of the worker.
1971  * @property {Worker} [port] - The `workerPort` object.
1972  * @property {number} [verbosity] - Controls the logging level;
1973  *   the constants from {@link VerbosityLevel} should be used.
1974  */
1975 
1976 const PDFWorkerUtil = {
1977   isWorkerDisabled: false,
1978   fakeWorkerId: 0,
1979 };
1980 if (typeof PDFJSDev === "undefined" || PDFJSDev.test("GENERIC")) {
1981   if (isNodeJS) {
1982     // Workers aren't supported in Node.js, force-disabling them there.
1983     PDFWorkerUtil.isWorkerDisabled = true;
1984 
1985     GlobalWorkerOptions.workerSrc ||= PDFJSDev.test("LIB")
1986       ? "../pdf.worker.js"
1987       : "./pdf.worker.mjs";
1988   }
1989 
1990   // Check if URLs have the same origin. For non-HTTP based URLs, returns false.
1991   PDFWorkerUtil.isSameOrigin = function (baseUrl, otherUrl) {
1992     let base;
1993     try {
1994       base = new URL(baseUrl);
1995       if (!base.origin || base.origin === "null") {
1996         return false; // non-HTTP url
1997       }
1998     } catch {
1999       return false;
2000     }
2001 
2002     const other = new URL(otherUrl, base);
2003     return base.origin === other.origin;
2004   };
2005 
2006   PDFWorkerUtil.createCDNWrapper = function (url) {
2007     // We will rely on blob URL's property to specify origin.
2008     // We want this function to fail in case if createObjectURL or Blob do not
2009     // exist or fail for some reason -- our Worker creation will fail anyway.
2010     const wrapper = `importScripts("${url}");`;
2011     return URL.createObjectURL(new Blob([wrapper]));
2012   };
2013 }
2014 
2015 /**
2016  * PDF.js web worker abstraction that controls the instantiation of PDF
2017  * documents. Message handlers are used to pass information from the main
2018  * thread to the worker thread and vice versa. If the creation of a web
2019  * worker is not possible, a "fake" worker will be used instead.
2020  *
2021  * @param {PDFWorkerParameters} params - The worker initialization parameters.
2022  */
2023 class PDFWorker {
2024   static #workerPorts;
2025 
2026   constructor({
2027     name = null,
2028     port = null,
2029     verbosity = getVerbosityLevel(),
2030   } = {}) {
2031     this.name = name;
2032     this.destroyed = false;
2033     this.verbosity = verbosity;
2034 
2035     this._readyCapability = new PromiseCapability();
2036     this._port = null;
2037     this._webWorker = null;
2038     this._messageHandler = null;
2039 
2040     if (
2041       (typeof PDFJSDev === "undefined" || !PDFJSDev.test("MOZCENTRAL")) &&
2042       port
2043     ) {
2044       if (PDFWorker.#workerPorts?.has(port)) {
2045         throw new Error("Cannot use more than one PDFWorker per port.");
2046       }
2047       (PDFWorker.#workerPorts ||= new WeakMap()).set(port, this);
2048       this._initializeFromPort(port);
2049       return;
2050     }
2051     this._initialize();
2052   }
2053 
2054   /**
2055    * Promise for worker initialization completion.
2056    * @type {Promise<void>}
2057    */
2058   get promise() {
2059     return this._readyCapability.promise;
2060   }
2061 
2062   /**
2063    * The current `workerPort`, when it exists.
2064    * @type {Worker}
2065    */
2066   get port() {
2067     return this._port;
2068   }
2069 
2070   /**
2071    * The current MessageHandler-instance.
2072    * @type {MessageHandler}
2073    */
2074   get messageHandler() {
2075     return this._messageHandler;
2076   }
2077 
2078   _initializeFromPort(port) {
2079     if (typeof PDFJSDev !== "undefined" && PDFJSDev.test("MOZCENTRAL")) {
2080       throw new Error("Not implemented: _initializeFromPort");
2081     }
2082     this._port = port;
2083     this._messageHandler = new MessageHandler("main", "worker", port);
2084     this._messageHandler.on("ready", function () {
2085       // Ignoring "ready" event -- MessageHandler should already be initialized
2086       // and ready to accept messages.
2087     });
2088     this._readyCapability.resolve();
2089     // Send global setting, e.g. verbosity level.
2090     this._messageHandler.send("configure", {
2091       verbosity: this.verbosity,
2092     });
2093   }
2094 
2095   _initialize() {
2096     // If worker support isn't disabled explicit and the browser has worker
2097     // support, create a new web worker and test if it/the browser fulfills
2098     // all requirements to run parts of pdf.js in a web worker.
2099     // Right now, the requirement is, that an Uint8Array is still an
2100     // Uint8Array as it arrives on the worker. (Chrome added this with v.15.)
2101     if (
2102       !PDFWorkerUtil.isWorkerDisabled &&
2103       !PDFWorker.#mainThreadWorkerMessageHandler
2104     ) {
2105       let { workerSrc } = PDFWorker;
2106 
2107       try {
2108         // Wraps workerSrc path into blob URL, if the former does not belong
2109         // to the same origin.
2110         if (
2111           typeof PDFJSDev !== "undefined" &&
2112           PDFJSDev.test("GENERIC") &&
2113           !PDFWorkerUtil.isSameOrigin(window.location.href, workerSrc)
2114         ) {
2115           workerSrc = PDFWorkerUtil.createCDNWrapper(
2116             new URL(workerSrc, window.location).href
2117           );
2118         }
2119 
2120         const worker = new Worker(workerSrc, { type: "module" });
2121         const messageHandler = new MessageHandler("main", "worker", worker);
2122         const terminateEarly = () => {
2123           worker.removeEventListener("error", onWorkerError);
2124           messageHandler.destroy();
2125           worker.terminate();
2126           if (this.destroyed) {
2127             this._readyCapability.reject(new Error("Worker was destroyed"));
2128           } else {
2129             // Fall back to fake worker if the termination is caused by an
2130             // error (e.g. NetworkError / SecurityError).
2131             this._setupFakeWorker();
2132           }
2133         };
2134 
2135         const onWorkerError = () => {
2136           if (!this._webWorker) {
2137             // Worker failed to initialize due to an error. Clean up and fall
2138             // back to the fake worker.
2139             terminateEarly();
2140           }
2141         };
2142         worker.addEventListener("error", onWorkerError);
2143 
2144         messageHandler.on("test", data => {
2145           worker.removeEventListener("error", onWorkerError);
2146           if (this.destroyed) {
2147             terminateEarly();
2148             return; // worker was destroyed
2149           }
2150           if (data) {
2151             this._messageHandler = messageHandler;
2152             this._port = worker;
2153             this._webWorker = worker;
2154 
2155             this._readyCapability.resolve();
2156             // Send global setting, e.g. verbosity level.
2157             messageHandler.send("configure", {
2158               verbosity: this.verbosity,
2159             });
2160           } else {
2161             this._setupFakeWorker();
2162             messageHandler.destroy();
2163             worker.terminate();
2164           }
2165         });
2166 
2167         messageHandler.on("ready", data => {
2168           worker.removeEventListener("error", onWorkerError);
2169           if (this.destroyed) {
2170             terminateEarly();
2171             return; // worker was destroyed
2172           }
2173           try {
2174             sendTest();
2175           } catch {
2176             // We need fallback to a faked worker.
2177             this._setupFakeWorker();
2178           }
2179         });
2180 
2181         const sendTest = () => {
2182           const testObj = new Uint8Array();
2183           // Ensure that we can use `postMessage` transfers.
2184           messageHandler.send("test", testObj, [testObj.buffer]);
2185         };
2186 
2187         // It might take time for the worker to initialize. We will try to send
2188         // the "test" message immediately, and once the "ready" message arrives.
2189         // The worker shall process only the first received "test" message.
2190         sendTest();
2191         return;
2192       } catch {
2193         info("The worker has been disabled.");
2194       }
2195     }
2196     // Either workers are disabled, not supported or have thrown an exception.
2197     // Thus, we fallback to a faked worker.
2198     this._setupFakeWorker();
2199   }
2200 
2201   _setupFakeWorker() {
2202     if (!PDFWorkerUtil.isWorkerDisabled) {
2203       warn("Setting up fake worker.");
2204       PDFWorkerUtil.isWorkerDisabled = true;
2205     }
2206 
2207     PDFWorker._setupFakeWorkerGlobal
2208       .then(WorkerMessageHandler => {
2209         if (this.destroyed) {
2210           this._readyCapability.reject(new Error("Worker was destroyed"));
2211           return;
2212         }
2213         const port = new LoopbackPort();
2214         this._port = port;
2215 
2216         // All fake workers use the same port, making id unique.
2217         const id = `fake${PDFWorkerUtil.fakeWorkerId++}`;
2218 
2219         // If the main thread is our worker, setup the handling for the
2220         // messages -- the main thread sends to it self.
2221         const workerHandler = new MessageHandler(id + "_worker", id, port);
2222         WorkerMessageHandler.setup(workerHandler, port);
2223 
2224         const messageHandler = new MessageHandler(id, id + "_worker", port);
2225         this._messageHandler = messageHandler;
2226         this._readyCapability.resolve();
2227         // Send global setting, e.g. verbosity level.
2228         messageHandler.send("configure", {
2229           verbosity: this.verbosity,
2230         });
2231       })
2232       .catch(reason => {
2233         this._readyCapability.reject(
2234           new Error(`Setting up fake worker failed: "${reason.message}".`)
2235         );
2236       });
2237   }
2238 
2239   /**
2240    * Destroys the worker instance.
2241    */
2242   destroy() {
2243     this.destroyed = true;
2244     if (this._webWorker) {
2245       // We need to terminate only web worker created resource.
2246       this._webWorker.terminate();
2247       this._webWorker = null;
2248     }
2249     PDFWorker.#workerPorts?.delete(this._port);
2250     this._port = null;
2251     if (this._messageHandler) {
2252       this._messageHandler.destroy();
2253       this._messageHandler = null;
2254     }
2255   }
2256 
2257   /**
2258    * @param {PDFWorkerParameters} params - The worker initialization parameters.
2259    */
2260   static fromPort(params) {
2261     if (typeof PDFJSDev !== "undefined" && PDFJSDev.test("MOZCENTRAL")) {
2262       throw new Error("Not implemented: fromPort");
2263     }
2264     if (!params?.port) {
2265       throw new Error("PDFWorker.fromPort - invalid method signature.");
2266     }
2267     const cachedPort = this.#workerPorts?.get(params.port);
2268     if (cachedPort) {
2269       if (cachedPort._pendingDestroy) {
2270         throw new Error(
2271           "PDFWorker.fromPort - the worker is being destroyed.\n" +
2272             "Please remember to await `PDFDocumentLoadingTask.destroy()`-calls."
2273         );
2274       }
2275       return cachedPort;
2276     }
2277     return new PDFWorker(params);
2278   }
2279 
2280   /**
2281    * The current `workerSrc`, when it exists.
2282    * @type {string}
2283    */
2284   static get workerSrc() {
2285     if (GlobalWorkerOptions.workerSrc) {
2286       return GlobalWorkerOptions.workerSrc;
2287     }
2288     throw new Error('No "GlobalWorkerOptions.workerSrc" specified.');
2289   }
2290 
2291   static get #mainThreadWorkerMessageHandler() {
2292     try {
2293       return globalThis.pdfjsWorker?.WorkerMessageHandler || null;
2294     } catch {
2295       return null;
2296     }
2297   }
2298 
2299   // Loads worker code into the main-thread.
2300   static get _setupFakeWorkerGlobal() {
2301     const loader = async () => {
2302       if (this.#mainThreadWorkerMessageHandler) {
2303         // The worker was already loaded using e.g. a `<script>` tag.
2304         return this.#mainThreadWorkerMessageHandler;
2305       }
2306       const worker =
2307         typeof PDFJSDev === "undefined"
2308           ? await import("pdfjs/pdf.worker.js")
2309           : await __non_webpack_import__(this.workerSrc); // eslint-disable-line no-undef
2310       return worker.WorkerMessageHandler;
2311     };
2312 
2313     return shadow(this, "_setupFakeWorkerGlobal", loader());
2314   }
2315 }
2316 
2317 /**
2318  * For internal use only.
2319  * @ignore
2320  */
2321 class WorkerTransport {
2322   #methodPromises = new Map();
2323 
2324   #pageCache = new Map();
2325 
2326   #pagePromises = new Map();
2327 
2328   #passwordCapability = null;
2329 
2330   constructor(messageHandler, loadingTask, networkStream, params, factory) {
2331     this.messageHandler = messageHandler;
2332     this.loadingTask = loadingTask;
2333     this.commonObjs = new PDFObjects();
2334     this.fontLoader = new FontLoader({
2335       ownerDocument: params.ownerDocument,
2336       styleElement: params.styleElement,
2337     });
2338     this._params = params;
2339 
2340     this.canvasFactory = factory.canvasFactory;
2341     this.filterFactory = factory.filterFactory;
2342     this.cMapReaderFactory = factory.cMapReaderFactory;
2343     this.standardFontDataFactory = factory.standardFontDataFactory;
2344 
2345     this.destroyed = false;
2346     this.destroyCapability = null;
2347 
2348     this._networkStream = networkStream;
2349     this._fullReader = null;
2350     this._lastProgress = null;
2351     this.downloadInfoCapability = new PromiseCapability();
2352 
2353     this.setupMessageHandler();
2354 
2355     if (typeof PDFJSDev === "undefined" || PDFJSDev.test("TESTING")) {
2356       // For testing purposes.
2357       Object.defineProperty(this, "getXFADatasets", {
2358         value: () => {
2359           return this.messageHandler.sendWithPromise("GetXFADatasets", null);
2360         },
2361       });
2362       Object.defineProperty(this, "getXRefPrevValue", {
2363         value: () => {
2364           return this.messageHandler.sendWithPromise("GetXRefPrevValue", null);
2365         },
2366       });
2367       Object.defineProperty(this, "getAnnotArray", {
2368         value: pageIndex => {
2369           return this.messageHandler.sendWithPromise("GetAnnotArray", {
2370             pageIndex,
2371           });
2372         },
2373       });
2374     }
2375   }
2376 
2377   #cacheSimpleMethod(name, data = null) {
2378     const cachedPromise = this.#methodPromises.get(name);
2379     if (cachedPromise) {
2380       return cachedPromise;
2381     }
2382     const promise = this.messageHandler.sendWithPromise(name, data);
2383 
2384     this.#methodPromises.set(name, promise);
2385     return promise;
2386   }
2387 
2388   get annotationStorage() {
2389     return shadow(this, "annotationStorage", new AnnotationStorage());
2390   }
2391 
2392   getRenderingIntent(
2393     intent,
2394     annotationMode = AnnotationMode.ENABLE,
2395     printAnnotationStorage = null,
2396     isOpList = false
2397   ) {
2398     let renderingIntent = RenderingIntentFlag.DISPLAY; // Default value.
2399     let annotationStorageSerializable = SerializableEmpty;
2400 
2401     switch (intent) {
2402       case "any":
2403         renderingIntent = RenderingIntentFlag.ANY;
2404         break;
2405       case "display":
2406         break;
2407       case "print":
2408         renderingIntent = RenderingIntentFlag.PRINT;
2409         break;
2410       default:
2411         warn(`getRenderingIntent - invalid intent: ${intent}`);
2412     }
2413 
2414     switch (annotationMode) {
2415       case AnnotationMode.DISABLE:
2416         renderingIntent += RenderingIntentFlag.ANNOTATIONS_DISABLE;
2417         break;
2418       case AnnotationMode.ENABLE:
2419         break;
2420       case AnnotationMode.ENABLE_FORMS:
2421         renderingIntent += RenderingIntentFlag.ANNOTATIONS_FORMS;
2422         break;
2423       case AnnotationMode.ENABLE_STORAGE:
2424         renderingIntent += RenderingIntentFlag.ANNOTATIONS_STORAGE;
2425 
2426         const annotationStorage =
2427           renderingIntent & RenderingIntentFlag.PRINT &&
2428           printAnnotationStorage instanceof PrintAnnotationStorage
2429             ? printAnnotationStorage
2430             : this.annotationStorage;
2431 
2432         annotationStorageSerializable = annotationStorage.serializable;
2433         break;
2434       default:
2435         warn(`getRenderingIntent - invalid annotationMode: ${annotationMode}`);
2436     }
2437 
2438     if (isOpList) {
2439       renderingIntent += RenderingIntentFlag.OPLIST;
2440     }
2441 
2442     return {
2443       renderingIntent,
2444       cacheKey: `${renderingIntent}_${annotationStorageSerializable.hash}`,
2445       annotationStorageSerializable,
2446     };
2447   }
2448 
2449   destroy() {
2450     if (this.destroyCapability) {
2451       return this.destroyCapability.promise;
2452     }
2453 
2454     this.destroyed = true;
2455     this.destroyCapability = new PromiseCapability();
2456 
2457     this.#passwordCapability?.reject(
2458       new Error("Worker was destroyed during onPassword callback")
2459     );
2460 
2461     const waitOn = [];
2462     // We need to wait for all renderings to be completed, e.g.
2463     // timeout/rAF can take a long time.
2464     for (const page of this.#pageCache.values()) {
2465       waitOn.push(page._destroy());
2466     }
2467     this.#pageCache.clear();
2468     this.#pagePromises.clear();
2469     // Allow `AnnotationStorage`-related clean-up when destroying the document.
2470     if (this.hasOwnProperty("annotationStorage")) {
2471       this.annotationStorage.resetModified();
2472     }
2473     // We also need to wait for the worker to finish its long running tasks.
2474     const terminated = this.messageHandler.sendWithPromise("Terminate", null);
2475     waitOn.push(terminated);
2476 
2477     Promise.all(waitOn).then(() => {
2478       this.commonObjs.clear();
2479       this.fontLoader.clear();
2480       this.#methodPromises.clear();
2481       this.filterFactory.destroy();
2482 
2483       this._networkStream?.cancelAllRequests(
2484         new AbortException("Worker was terminated.")
2485       );
2486 
2487       if (this.messageHandler) {
2488         this.messageHandler.destroy();
2489         this.messageHandler = null;
2490       }
2491       this.destroyCapability.resolve();
2492     }, this.destroyCapability.reject);
2493     return this.destroyCapability.promise;
2494   }
2495 
2496   setupMessageHandler() {
2497     const { messageHandler, loadingTask } = this;
2498 
2499     messageHandler.on("GetReader", (data, sink) => {
2500       assert(
2501         this._networkStream,
2502         "GetReader - no `IPDFStream` instance available."
2503       );
2504       this._fullReader = this._networkStream.getFullReader();
2505       this._fullReader.onProgress = evt => {
2506         this._lastProgress = {
2507           loaded: evt.loaded,
2508           total: evt.total,
2509         };
2510       };
2511       sink.onPull = () => {
2512         this._fullReader
2513           .read()
2514           .then(function ({ value, done }) {
2515             if (done) {
2516               sink.close();
2517               return;
2518             }
2519             assert(
2520               value instanceof ArrayBuffer,
2521               "GetReader - expected an ArrayBuffer."
2522             );
2523             // Enqueue data chunk into sink, and transfer it
2524             // to other side as `Transferable` object.
2525             sink.enqueue(new Uint8Array(value), 1, [value]);
2526           })
2527           .catch(reason => {
2528             sink.error(reason);
2529           });
2530       };
2531 
2532       sink.onCancel = reason => {
2533         this._fullReader.cancel(reason);
2534 
2535         sink.ready.catch(readyReason => {
2536           if (this.destroyed) {
2537             return; // Ignore any pending requests if the worker was terminated.
2538           }
2539           throw readyReason;
2540         });
2541       };
2542     });
2543 
2544     messageHandler.on("ReaderHeadersReady", data => {
2545       const headersCapability = new PromiseCapability();
2546       const fullReader = this._fullReader;
2547       fullReader.headersReady.then(() => {
2548         // If stream or range are disabled, it's our only way to report
2549         // loading progress.
2550         if (!fullReader.isStreamingSupported || !fullReader.isRangeSupported) {
2551           if (this._lastProgress) {
2552             loadingTask.onProgress?.(this._lastProgress);
2553           }
2554           fullReader.onProgress = evt => {
2555             loadingTask.onProgress?.({
2556               loaded: evt.loaded,
2557               total: evt.total,
2558             });
2559           };
2560         }
2561 
2562         headersCapability.resolve({
2563           isStreamingSupported: fullReader.isStreamingSupported,
2564           isRangeSupported: fullReader.isRangeSupported,
2565           contentLength: fullReader.contentLength,
2566         });
2567       }, headersCapability.reject);
2568 
2569       return headersCapability.promise;
2570     });
2571 
2572     messageHandler.on("GetRangeReader", (data, sink) => {
2573       assert(
2574         this._networkStream,
2575         "GetRangeReader - no `IPDFStream` instance available."
2576       );
2577       const rangeReader = this._networkStream.getRangeReader(
2578         data.begin,
2579         data.end
2580       );
2581 
2582       // When streaming is enabled, it's possible that the data requested here
2583       // has already been fetched via the `_fullRequestReader` implementation.
2584       // However, given that the PDF data is loaded asynchronously on the
2585       // main-thread and then sent via `postMessage` to the worker-thread,
2586       // it may not have been available during parsing (hence the attempt to
2587       // use range requests here).
2588       //
2589       // To avoid wasting time and resources here, we'll thus *not* dispatch
2590       // range requests if the data was already loaded but has not been sent to
2591       // the worker-thread yet (which will happen via the `_fullRequestReader`).
2592       if (!rangeReader) {
2593         sink.close();
2594         return;
2595       }
2596 
2597       sink.onPull = () => {
2598         rangeReader
2599           .read()
2600           .then(function ({ value, done }) {
2601             if (done) {
2602               sink.close();
2603               return;
2604             }
2605             assert(
2606               value instanceof ArrayBuffer,
2607               "GetRangeReader - expected an ArrayBuffer."
2608             );
2609             sink.enqueue(new Uint8Array(value), 1, [value]);
2610           })
2611           .catch(reason => {
2612             sink.error(reason);
2613           });
2614       };
2615 
2616       sink.onCancel = reason => {
2617         rangeReader.cancel(reason);
2618 
2619         sink.ready.catch(readyReason => {
2620           if (this.destroyed) {
2621             return; // Ignore any pending requests if the worker was terminated.
2622           }
2623           throw readyReason;
2624         });
2625       };
2626     });
2627 
2628     messageHandler.on("GetDoc", ({ pdfInfo }) => {
2629       this._numPages = pdfInfo.numPages;
2630       this._htmlForXfa = pdfInfo.htmlForXfa;
2631       delete pdfInfo.htmlForXfa;
2632       loadingTask._capability.resolve(new PDFDocumentProxy(pdfInfo, this));
2633     });
2634 
2635     messageHandler.on("DocException", function (ex) {
2636       let reason;
2637       switch (ex.name) {
2638         case "PasswordException":
2639           reason = new PasswordException(ex.message, ex.code);
2640           break;
2641         case "InvalidPDFException":
2642           reason = new InvalidPDFException(ex.message);
2643           break;
2644         case "MissingPDFException":
2645           reason = new MissingPDFException(ex.message);
2646           break;
2647         case "UnexpectedResponseException":
2648           reason = new UnexpectedResponseException(ex.message, ex.status);
2649           break;
2650         case "UnknownErrorException":
2651           reason = new UnknownErrorException(ex.message, ex.details);
2652           break;
2653         default:
2654           unreachable("DocException - expected a valid Error.");
2655       }
2656       loadingTask._capability.reject(reason);
2657     });
2658 
2659     messageHandler.on("PasswordRequest", exception => {
2660       this.#passwordCapability = new PromiseCapability();
2661 
2662       if (loadingTask.onPassword) {
2663         const updatePassword = password => {
2664           if (password instanceof Error) {
2665             this.#passwordCapability.reject(password);
2666           } else {
2667             this.#passwordCapability.resolve({ password });
2668           }
2669         };
2670         try {
2671           loadingTask.onPassword(updatePassword, exception.code);
2672         } catch (ex) {
2673           this.#passwordCapability.reject(ex);
2674         }
2675       } else {
2676         this.#passwordCapability.reject(
2677           new PasswordException(exception.message, exception.code)
2678         );
2679       }
2680       return this.#passwordCapability.promise;
2681     });
2682 
2683     messageHandler.on("DataLoaded", data => {
2684       // For consistency: Ensure that progress is always reported when the
2685       // entire PDF file has been loaded, regardless of how it was fetched.
2686       loadingTask.onProgress?.({
2687         loaded: data.length,
2688         total: data.length,
2689       });
2690 
2691       this.downloadInfoCapability.resolve(data);
2692     });
2693 
2694     messageHandler.on("StartRenderPage", data => {
2695       if (this.destroyed) {
2696         return; // Ignore any pending requests if the worker was terminated.
2697       }
2698 
2699       const page = this.#pageCache.get(data.pageIndex);
2700       page._startRenderPage(data.transparency, data.cacheKey);
2701     });
2702 
2703     messageHandler.on("commonobj", ([id, type, exportedData]) => {
2704       if (this.destroyed) {
2705         return; // Ignore any pending requests if the worker was terminated.
2706       }
2707 
2708       if (this.commonObjs.has(id)) {
2709         return;
2710       }
2711 
2712       switch (type) {
2713         case "Font":
2714           const params = this._params;
2715 
2716           if ("error" in exportedData) {
2717             const exportedError = exportedData.error;
2718             warn(`Error during font loading: ${exportedError}`);
2719             this.commonObjs.resolve(id, exportedError);
2720             break;
2721           }
2722 
2723           const inspectFont =
2724             params.pdfBug && globalThis.FontInspector?.enabled
2725               ? (font, url) => globalThis.FontInspector.fontAdded(font, url)
2726               : null;
2727           const font = new FontFaceObject(exportedData, {
2728             isEvalSupported: params.isEvalSupported,
2729             disableFontFace: params.disableFontFace,
2730             ignoreErrors: params.ignoreErrors,
2731             inspectFont,
2732           });
2733 
2734           this.fontLoader
2735             .bind(font)
2736             .catch(reason => {
2737               return messageHandler.sendWithPromise("FontFallback", { id });
2738             })
2739             .finally(() => {
2740               if (!params.fontExtraProperties && font.data) {
2741                 // Immediately release the `font.data` property once the font
2742                 // has been attached to the DOM, since it's no longer needed,
2743                 // rather than waiting for a `PDFDocumentProxy.cleanup` call.
2744                 // Since `font.data` could be very large, e.g. in some cases
2745                 // multiple megabytes, this will help reduce memory usage.
2746                 font.data = null;
2747               }
2748               this.commonObjs.resolve(id, font);
2749             });
2750           break;
2751         case "FontPath":
2752         case "Image":
2753         case "Pattern":
2754           this.commonObjs.resolve(id, exportedData);
2755           break;
2756         default:
2757           throw new Error(`Got unknown common object type ${type}`);
2758       }
2759     });
2760 
2761     messageHandler.on("obj", ([id, pageIndex, type, imageData]) => {
2762       if (this.destroyed) {
2763         // Ignore any pending requests if the worker was terminated.
2764         return;
2765       }
2766 
2767       const pageProxy = this.#pageCache.get(pageIndex);
2768       if (pageProxy.objs.has(id)) {
2769         return;
2770       }
2771 
2772       switch (type) {
2773         case "Image":
2774           pageProxy.objs.resolve(id, imageData);
2775 
2776           // Heuristic that will allow us not to store large data.
2777           if (imageData) {
2778             let length;
2779             if (imageData.bitmap) {
2780               const { width, height } = imageData;
2781               length = width * height * 4;
2782             } else {
2783               length = imageData.data?.length || 0;
2784             }
2785 
2786             if (length > MAX_IMAGE_SIZE_TO_CACHE) {
2787               pageProxy._maybeCleanupAfterRender = true;
2788             }
2789           }
2790           break;
2791         case "Pattern":
2792           pageProxy.objs.resolve(id, imageData);
2793           break;
2794         default:
2795           throw new Error(`Got unknown object type ${type}`);
2796       }
2797     });
2798 
2799     messageHandler.on("DocProgress", data => {
2800       if (this.destroyed) {
2801         return; // Ignore any pending requests if the worker was terminated.
2802       }
2803       loadingTask.onProgress?.({
2804         loaded: data.loaded,
2805         total: data.total,
2806       });
2807     });
2808 
2809     messageHandler.on("FetchBuiltInCMap", data => {
2810       if (this.destroyed) {
2811         return Promise.reject(new Error("Worker was destroyed."));
2812       }
2813       if (!this.cMapReaderFactory) {
2814         return Promise.reject(
2815           new Error(
2816             "CMapReaderFactory not initialized, see the `useWorkerFetch` parameter."
2817           )
2818         );
2819       }
2820       return this.cMapReaderFactory.fetch(data);
2821     });
2822 
2823     messageHandler.on("FetchStandardFontData", data => {
2824       if (this.destroyed) {
2825         return Promise.reject(new Error("Worker was destroyed."));
2826       }
2827       if (!this.standardFontDataFactory) {
2828         return Promise.reject(
2829           new Error(
2830             "StandardFontDataFactory not initialized, see the `useWorkerFetch` parameter."
2831           )
2832         );
2833       }
2834       return this.standardFontDataFactory.fetch(data);
2835     });
2836   }
2837 
2838   getData() {
2839     return this.messageHandler.sendWithPromise("GetData", null);
2840   }
2841 
2842   saveDocument() {
2843     if (this.annotationStorage.size <= 0) {
2844       warn(
2845         "saveDocument called while `annotationStorage` is empty, " +
2846           "please use the getData-method instead."
2847       );
2848     }
2849     const { map, transfer } = this.annotationStorage.serializable;
2850 
2851     return this.messageHandler
2852       .sendWithPromise(
2853         "SaveDocument",
2854         {
2855           isPureXfa: !!this._htmlForXfa,
2856           numPages: this._numPages,
2857           annotationStorage: map,
2858           filename: this._fullReader?.filename ?? null,
2859         },
2860         transfer
2861       )
2862       .finally(() => {
2863         this.annotationStorage.resetModified();
2864       });
2865   }
2866 
2867   getPage(pageNumber) {
2868     if (
2869       !Number.isInteger(pageNumber) ||
2870       pageNumber <= 0 ||
2871       pageNumber > this._numPages
2872     ) {
2873       return Promise.reject(new Error("Invalid page request."));
2874     }
2875 
2876     const pageIndex = pageNumber - 1,
2877       cachedPromise = this.#pagePromises.get(pageIndex);
2878     if (cachedPromise) {
2879       return cachedPromise;
2880     }
2881     const promise = this.messageHandler
2882       .sendWithPromise("GetPage", {
2883         pageIndex,
2884       })
2885       .then(pageInfo => {
2886         if (this.destroyed) {
2887           throw new Error("Transport destroyed");
2888         }
2889         const page = new PDFPageProxy(
2890           pageIndex,
2891           pageInfo,
2892           this,
2893           this._params.pdfBug
2894         );
2895         this.#pageCache.set(pageIndex, page);
2896         return page;
2897       });
2898     this.#pagePromises.set(pageIndex, promise);
2899     return promise;
2900   }
2901 
2902   getPageIndex(ref) {
2903     if (
2904       typeof ref !== "object" ||
2905       ref === null ||
2906       !Number.isInteger(ref.num) ||
2907       ref.num < 0 ||
2908       !Number.isInteger(ref.gen) ||
2909       ref.gen < 0
2910     ) {
2911       return Promise.reject(new Error("Invalid pageIndex request."));
2912     }
2913     return this.messageHandler.sendWithPromise("GetPageIndex", {
2914       num: ref.num,
2915       gen: ref.gen,
2916     });
2917   }
2918 
2919   getAnnotations(pageIndex, intent) {
2920     return this.messageHandler.sendWithPromise("GetAnnotations", {
2921       pageIndex,
2922       intent,
2923     });
2924   }
2925 
2926   getFieldObjects() {
2927     return this.#cacheSimpleMethod("GetFieldObjects");
2928   }
2929 
2930   hasJSActions() {
2931     return this.#cacheSimpleMethod("HasJSActions");
2932   }
2933 
2934   getCalculationOrderIds() {
2935     return this.messageHandler.sendWithPromise("GetCalculationOrderIds", null);
2936   }
2937 
2938   getDestinations() {
2939     return this.messageHandler.sendWithPromise("GetDestinations", null);
2940   }
2941 
2942   getDestination(id) {
2943     if (typeof id !== "string") {
2944       return Promise.reject(new Error("Invalid destination request."));
2945     }
2946     return this.messageHandler.sendWithPromise("GetDestination", {
2947       id,
2948     });
2949   }
2950 
2951   getPageLabels() {
2952     return this.messageHandler.sendWithPromise("GetPageLabels", null);
2953   }
2954 
2955   getPageLayout() {
2956     return this.messageHandler.sendWithPromise("GetPageLayout", null);
2957   }
2958 
2959   getPageMode() {
2960     return this.messageHandler.sendWithPromise("GetPageMode", null);
2961   }
2962 
2963   getViewerPreferences() {
2964     return this.messageHandler.sendWithPromise("GetViewerPreferences", null);
2965   }
2966 
2967   getOpenAction() {
2968     return this.messageHandler.sendWithPromise("GetOpenAction", null);
2969   }
2970 
2971   getAttachments() {
2972     return this.messageHandler.sendWithPromise("GetAttachments", null);
2973   }
2974 
2975   getDocJSActions() {
2976     return this.#cacheSimpleMethod("GetDocJSActions");
2977   }
2978 
2979   getPageJSActions(pageIndex) {
2980     return this.messageHandler.sendWithPromise("GetPageJSActions", {
2981       pageIndex,
2982     });
2983   }
2984 
2985   getStructTree(pageIndex) {
2986     return this.messageHandler.sendWithPromise("GetStructTree", {
2987       pageIndex,
2988     });
2989   }
2990 
2991   getOutline() {
2992     return this.messageHandler.sendWithPromise("GetOutline", null);
2993   }
2994 
2995   getOptionalContentConfig() {
2996     return this.messageHandler
2997       .sendWithPromise("GetOptionalContentConfig", null)
2998       .then(results => {
2999         return new OptionalContentConfig(results);
3000       });
3001   }
3002 
3003   getPermissions() {
3004     return this.messageHandler.sendWithPromise("GetPermissions", null);
3005   }
3006 
3007   getMetadata() {
3008     const name = "GetMetadata",
3009       cachedPromise = this.#methodPromises.get(name);
3010     if (cachedPromise) {
3011       return cachedPromise;
3012     }
3013     const promise = this.messageHandler
3014       .sendWithPromise(name, null)
3015       .then(results => {
3016         return {
3017           info: results[0],
3018           metadata: results[1] ? new Metadata(results[1]) : null,
3019           contentDispositionFilename: this._fullReader?.filename ?? null,
3020           contentLength: this._fullReader?.contentLength ?? null,
3021         };
3022       });
3023     this.#methodPromises.set(name, promise);
3024     return promise;
3025   }
3026 
3027   getMarkInfo() {
3028     return this.messageHandler.sendWithPromise("GetMarkInfo", null);
3029   }
3030 
3031   async startCleanup(keepLoadedFonts = false) {
3032     if (this.destroyed) {
3033       return; // No need to manually clean-up when destruction has started.
3034     }
3035     await this.messageHandler.sendWithPromise("Cleanup", null);
3036 
3037     for (const page of this.#pageCache.values()) {
3038       const cleanupSuccessful = page.cleanup();
3039 
3040       if (!cleanupSuccessful) {
3041         throw new Error(
3042           `startCleanup: Page ${page.pageNumber} is currently rendering.`
3043         );
3044       }
3045     }
3046     this.commonObjs.clear();
3047     if (!keepLoadedFonts) {
3048       this.fontLoader.clear();
3049     }
3050     this.#methodPromises.clear();
3051     this.filterFactory.destroy(/* keepHCM = */ true);
3052   }
3053 
3054   get loadingParams() {
3055     const { disableAutoFetch, enableXfa } = this._params;
3056     return shadow(this, "loadingParams", {
3057       disableAutoFetch,
3058       enableXfa,
3059     });
3060   }
3061 }
3062 
3063 /**
3064  * A PDF document and page is built of many objects. E.g. there are objects for
3065  * fonts, images, rendering code, etc. These objects may get processed inside of
3066  * a worker. This class implements some basic methods to manage these objects.
3067  */
3068 class PDFObjects {
3069   #objs = Object.create(null);
3070 
3071   /**
3072    * Ensures there is an object defined for `objId`.
3073    *
3074    * @param {string} objId
3075    * @returns {Object}
3076    */
3077   #ensureObj(objId) {
3078     return (this.#objs[objId] ||= {
3079       capability: new PromiseCapability(),
3080       data: null,
3081     });
3082   }
3083 
3084   /**
3085    * If called *without* callback, this returns the data of `objId` but the
3086    * object needs to be resolved. If it isn't, this method throws.
3087    *
3088    * If called *with* a callback, the callback is called with the data of the
3089    * object once the object is resolved. That means, if you call this method
3090    * and the object is already resolved, the callback gets called right away.
3091    *
3092    * @param {string} objId
3093    * @param {function} [callback]
3094    * @returns {any}
3095    */
3096   get(objId, callback = null) {
3097     // If there is a callback, then the get can be async and the object is
3098     // not required to be resolved right now.
3099     if (callback) {
3100       const obj = this.#ensureObj(objId);
3101       obj.capability.promise.then(() => callback(obj.data));
3102       return null;
3103     }
3104     // If there isn't a callback, the user expects to get the resolved data
3105     // directly.
3106     const obj = this.#objs[objId];
3107     // If there isn't an object yet or the object isn't resolved, then the
3108     // data isn't ready yet!
3109     if (!obj?.capability.settled) {
3110       throw new Error(`Requesting object that isn't resolved yet ${objId}.`);
3111     }
3112     return obj.data;
3113   }
3114 
3115   /**
3116    * @param {string} objId
3117    * @returns {boolean}
3118    */
3119   has(objId) {
3120     const obj = this.#objs[objId];
3121     return obj?.capability.settled || false;
3122   }
3123 
3124   /**
3125    * Resolves the object `objId` with optional `data`.
3126    *
3127    * @param {string} objId
3128    * @param {any} [data]
3129    */
3130   resolve(objId, data = null) {
3131     const obj = this.#ensureObj(objId);
3132     obj.data = data;
3133     obj.capability.resolve();
3134   }
3135 
3136   clear() {
3137     for (const objId in this.#objs) {
3138       const { data } = this.#objs[objId];
3139       data?.bitmap?.close(); // Release any `ImageBitmap` data.
3140     }
3141     this.#objs = Object.create(null);
3142   }
3143 }
3144 
3145 /**
3146  * Allows controlling of the rendering tasks.
3147  */
3148 class RenderTask {
3149   #internalRenderTask = null;
3150 
3151   constructor(internalRenderTask) {
3152     this.#internalRenderTask = internalRenderTask;
3153 
3154     /**
3155      * Callback for incremental rendering -- a function that will be called
3156      * each time the rendering is paused.  To continue rendering call the
3157      * function that is the first argument to the callback.
3158      * @type {function}
3159      */
3160     this.onContinue = null;
3161   }
3162 
3163   /**
3164    * Promise for rendering task completion.
3165    * @type {Promise<void>}
3166    */
3167   get promise() {
3168     return this.#internalRenderTask.capability.promise;
3169   }
3170 
3171   /**
3172    * Cancels the rendering task. If the task is currently rendering it will
3173    * not be cancelled until graphics pauses with a timeout. The promise that
3174    * this object extends will be rejected when cancelled.
3175    *
3176    * @param {number} [extraDelay]
3177    */
3178   cancel(extraDelay = 0) {
3179     this.#internalRenderTask.cancel(/* error = */ null, extraDelay);
3180   }
3181 
3182   /**
3183    * Whether form fields are rendered separately from the main operatorList.
3184    * @type {boolean}
3185    */
3186   get separateAnnots() {
3187     const { separateAnnots } = this.#internalRenderTask.operatorList;
3188     if (!separateAnnots) {
3189       return false;
3190     }
3191     const { annotationCanvasMap } = this.#internalRenderTask;
3192     return (
3193       separateAnnots.form ||
3194       (separateAnnots.canvas && annotationCanvasMap?.size > 0)
3195     );
3196   }
3197 }
3198 
3199 /**
3200  * For internal use only.
3201  * @ignore
3202  */
3203 class InternalRenderTask {
3204   static #canvasInUse = new WeakSet();
3205 
3206   constructor({
3207     callback,
3208     params,
3209     objs,
3210     commonObjs,
3211     annotationCanvasMap,
3212     operatorList,
3213     pageIndex,
3214     canvasFactory,
3215     filterFactory,
3216     useRequestAnimationFrame = false,
3217     pdfBug = false,
3218     pageColors = null,
3219   }) {
3220     this.callback = callback;
3221     this.params = params;
3222     this.objs = objs;
3223     this.commonObjs = commonObjs;
3224     this.annotationCanvasMap = annotationCanvasMap;
3225     this.operatorListIdx = null;
3226     this.operatorList = operatorList;
3227     this._pageIndex = pageIndex;
3228     this.canvasFactory = canvasFactory;
3229     this.filterFactory = filterFactory;
3230     this._pdfBug = pdfBug;
3231     this.pageColors = pageColors;
3232 
3233     this.running = false;
3234     this.graphicsReadyCallback = null;
3235     this.graphicsReady = false;
3236     this._useRequestAnimationFrame =
3237       useRequestAnimationFrame === true && typeof window !== "undefined";
3238     this.cancelled = false;
3239     this.capability = new PromiseCapability();
3240     this.task = new RenderTask(this);
3241     // caching this-bound methods
3242     this._cancelBound = this.cancel.bind(this);
3243     this._continueBound = this._continue.bind(this);
3244     this._scheduleNextBound = this._scheduleNext.bind(this);
3245     this._nextBound = this._next.bind(this);
3246     this._canvas = params.canvasContext.canvas;
3247   }
3248 
3249   get completed() {
3250     return this.capability.promise.catch(function () {
3251       // Ignoring errors, since we only want to know when rendering is
3252       // no longer pending.
3253     });
3254   }
3255 
3256   initializeGraphics({ transparency = false, optionalContentConfig }) {
3257     if (this.cancelled) {
3258       return;
3259     }
3260     if (this._canvas) {
3261       if (InternalRenderTask.#canvasInUse.has(this._canvas)) {
3262         throw new Error(
3263           "Cannot use the same canvas during multiple render() operations. " +
3264             "Use different canvas or ensure previous operations were " +
3265             "cancelled or completed."
3266         );
3267       }
3268       InternalRenderTask.#canvasInUse.add(this._canvas);
3269     }
3270 
3271     if (this._pdfBug && globalThis.StepperManager?.enabled) {
3272       this.stepper = globalThis.StepperManager.create(this._pageIndex);
3273       this.stepper.init(this.operatorList);
3274       this.stepper.nextBreakPoint = this.stepper.getNextBreakPoint();
3275     }
3276     const { canvasContext, viewport, transform, background } = this.params;
3277 
3278     this.gfx = new CanvasGraphics(
3279       canvasContext,
3280       this.commonObjs,
3281       this.objs,
3282       this.canvasFactory,
3283       this.filterFactory,
3284       { optionalContentConfig },
3285       this.annotationCanvasMap,
3286       this.pageColors
3287     );
3288     this.gfx.beginDrawing({
3289       transform,
3290       viewport,
3291       transparency,
3292       background,
3293     });
3294     this.operatorListIdx = 0;
3295     this.graphicsReady = true;
3296     this.graphicsReadyCallback?.();
3297   }
3298 
3299   cancel(error = null, extraDelay = 0) {
3300     this.running = false;
3301     this.cancelled = true;
3302     this.gfx?.endDrawing();
3303     InternalRenderTask.#canvasInUse.delete(this._canvas);
3304 
3305     this.callback(
3306       error ||
3307         new RenderingCancelledException(
3308           `Rendering cancelled, page ${this._pageIndex + 1}`,
3309           extraDelay
3310         )
3311     );
3312   }
3313 
3314   operatorListChanged() {
3315     if (!this.graphicsReady) {
3316       this.graphicsReadyCallback ||= this._continueBound;
3317       return;
3318     }
3319     this.stepper?.updateOperatorList(this.operatorList);
3320 
3321     if (this.running) {
3322       return;
3323     }
3324     this._continue();
3325   }
3326 
3327   _continue() {
3328     this.running = true;
3329     if (this.cancelled) {
3330       return;
3331     }
3332     if (this.task.onContinue) {
3333       this.task.onContinue(this._scheduleNextBound);
3334     } else {
3335       this._scheduleNext();
3336     }
3337   }
3338 
3339   _scheduleNext() {
3340     if (this._useRequestAnimationFrame) {
3341       window.requestAnimationFrame(() => {
3342         this._nextBound().catch(this._cancelBound);
3343       });
3344     } else {
3345       Promise.resolve().then(this._nextBound).catch(this._cancelBound);
3346     }
3347   }
3348 
3349   async _next() {
3350     if (this.cancelled) {
3351       return;
3352     }
3353     this.operatorListIdx = this.gfx.executeOperatorList(
3354       this.operatorList,
3355       this.operatorListIdx,
3356       this._continueBound,
3357       this.stepper
3358     );
3359     if (this.operatorListIdx === this.operatorList.argsArray.length) {
3360       this.running = false;
3361       if (this.operatorList.lastChunk) {
3362         this.gfx.endDrawing();
3363         InternalRenderTask.#canvasInUse.delete(this._canvas);
3364 
3365         this.callback();
3366       }
3367     }
3368   }
3369 }
3370 
3371 /** @type {string} */
3372 const version =
3373   typeof PDFJSDev !== "undefined" ? PDFJSDev.eval("BUNDLE_VERSION") : null;
3374 /** @type {string} */
3375 const build =
3376   typeof PDFJSDev !== "undefined" ? PDFJSDev.eval("BUNDLE_BUILD") : null;
3377 
3378 export {
3379   build,
3380   DefaultCanvasFactory,
3381   DefaultCMapReaderFactory,
3382   DefaultFilterFactory,
3383   DefaultStandardFontDataFactory,
3384   getDocument,
3385   LoopbackPort,
3386   PDFDataRangeTransport,
3387   PDFDocumentLoadingTask,
3388   PDFDocumentProxy,
3389   PDFPageProxy,
3390   PDFWorker,
3391   PDFWorkerUtil,
3392   RenderTask,
3393   version,
3394 };
</code>

Your task:
You are a software tester at pdf.js.
1. Write exactly one javascript test `it("...", async () => {...})` block.
2. Your test must fail on the code before the patch, and pass after, hence the test will verify that the patch resolves the issue.
3. The test must be self-contained and to-the-point.
4. Use only the provided imports (respect the paths exactly how they are given) by importing dynamically for compatibility with Node.js — no new dependencies. 
5. Return only the javascript code (no comments or explanations).

Example structure:
it("should <describe behavior>", async () => {
  const { example } = await import("../../src/core/example.js");
  <initialize required variables>;
  <define expected variable>;
  <generate actual variables>;
  <compare expected with actual>;
});

