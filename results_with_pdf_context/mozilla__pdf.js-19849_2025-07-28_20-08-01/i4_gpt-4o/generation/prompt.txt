Before you begin:
- Keep going until the job is completely solved — don’t stop halfway.
- If you’re unsure about the behavior, reread the provided patch carefully; do not hallucinate.
- Plan your approach before writing code by reflecting on whether the test truly fails before and passes after.

Issue:
<issue>
[Bug]: Don't stop rendering on faulty Resources entry of a form XObject
### Is the feature relevant to the Firefox PDF Viewer?

Yes

### Feature description

[This PDF](https://github.com/user-attachments/files/19863018/example-flattened.pdf) draws 2 form XObjects on page one. The first one (I1) has an empty content stream and its Resource entry is faulty as it references another form XObject instead of a resource dictionary. 

The second form XObject (I2) is a simply flattened form field and correct.

The faulty resource dictionary of the first form XObject (I1) seems to prevent I2 to be rendered at all in PDF.js.

I stumbled over this behavior in the wild and for sure the PDF itself is faulty and that's why I didn't labeled this as a bug in PDF.js.



### Other PDF viewers

All other common PDF viewers render the second form field without any problem.
</issue>

PDF File:
<pdf>
issue19848.pdf
</pdf>

Patch:
<patch>
diff --git a/src/core/evaluator.js b/src/core/evaluator.js
--- a/src/core/evaluator.js
+++ b/src/core/evaluator.js
@@ -465,7 +465,7 @@ class PartialEvaluator {
     localColorSpaceCache,
     seenRefs
   ) {
-    const dict = xobj.dict;
+    const { dict } = xobj;
     const matrix = lookupMatrix(dict.getArray("Matrix"), null);
     const bbox = lookupNormalRect(dict.getArray("BBox"), null);
 
@@ -521,10 +521,12 @@ class PartialEvaluator {
     const args = [f32matrix, f32bbox];
     operatorList.addOp(OPS.paintFormXObjectBegin, args);
 
+    const localResources = dict.get("Resources");
+
     await this.getOperatorList({
       stream: xobj,
       task,
-      resources: dict.get("Resources") || resources,
+      resources: localResources instanceof Dict ? localResources : resources,
       operatorList,
       initialState,
       prevRefs: seenRefs,
@@ -3298,14 +3300,15 @@ class PartialEvaluator {
                 if (!(xobj instanceof BaseStream)) {
                   throw new FormatError("XObject should be a stream");
                 }
+                const { dict } = xobj;
 
-                const type = xobj.dict.get("Subtype");
+                const type = dict.get("Subtype");
                 if (!(type instanceof Name)) {
                   throw new FormatError("XObject should have a Name subtype");
                 }
 
                 if (type.name !== "Form") {
-                  emptyXObjectCache.set(name, xobj.dict.objId, true);
+                  emptyXObjectCache.set(name, dict.objId, true);
 
                   resolveXObject();
                   return;
@@ -3319,11 +3322,13 @@ class PartialEvaluator {
                 const currentState = stateManager.state.clone();
                 const xObjStateManager = new StateManager(currentState);
 
-                const matrix = lookupMatrix(xobj.dict.getArray("Matrix"), null);
+                const matrix = lookupMatrix(dict.getArray("Matrix"), null);
                 if (matrix) {
                   xObjStateManager.transform(matrix);
                 }
 
+                const localResources = dict.get("Resources");
+
                 // Enqueue the `textContent` chunk before parsing the /Form
                 // XObject.
                 enqueueChunk();
@@ -3348,7 +3353,10 @@ class PartialEvaluator {
                   .getTextContent({
                     stream: xobj,
                     task,
-                    resources: xobj.dict.get("Resources") || resources,
+                    resources:
+                      localResources instanceof Dict
+                        ? localResources
+                        : resources,
                     stateManager: xObjStateManager,
                     includeMarkedContent,
                     sink: sinkWrapper,
@@ -3362,7 +3370,7 @@ class PartialEvaluator {
                   })
                   .then(function () {
                     if (!sinkWrapper.enqueueInvoked) {
-                      emptyXObjectCache.set(name, xobj.dict.objId, true);
+                      emptyXObjectCache.set(name, dict.objId, true);
                     }
                     resolveXObject();
                   }, rejectXObject);


</patch>

Imports:
<imports>
Available Packages
Dev Dependencies:
- @babel/core: ^7.26.10
- @babel/preset-env: ^7.26.9
- @babel/runtime: ^7.27.0
- @fluent/bundle: ^0.19.1
- @fluent/dom: ^0.10.1
- @metalsmith/layouts: ^3.0.0
- @metalsmith/markdown: ^1.10.0
- @napi-rs/canvas: ^0.1.69
- @types/node: ^22.14.1
- autoprefixer: ^10.4.21
- babel-loader: ^10.0.0
- caniuse-lite: ^1.0.30001713
- core-js: ^3.41.0
- eslint: ^9.24.0
- eslint-plugin-import: ^2.31.0
- eslint-plugin-jasmine: ^4.2.2
- eslint-plugin-json: ^4.0.1
- eslint-plugin-no-unsanitized: ^4.1.2
- eslint-plugin-perfectionist: ^4.11.0
- eslint-plugin-prettier: ^5.2.6
- eslint-plugin-unicorn: ^58.0.0
- globals: ^16.0.0
- gulp: ^5.0.0
- gulp-cli: ^3.0.0
- gulp-postcss: ^10.0.0
- gulp-rename: ^2.0.0
- gulp-replace: ^1.1.4
- gulp-zip: ^6.1.0
- highlight.js: ^11.11.1
- jasmine: ^5.6.0
- jsdoc: ^4.0.4
- jstransformer-nunjucks: ^1.2.0
- metalsmith: ^2.6.3
- metalsmith-html-relative: ^2.0.6
- ordered-read-streams: ^2.0.0
- pngjs: ^7.0.0
- postcss: ^8.5.3
- postcss-dark-theme-class: ^1.3.0
- postcss-dir-pseudo-class: ^9.0.1
- postcss-discard-comments: ^7.0.3
- postcss-nesting: ^13.0.1
- prettier: ^3.5.3
- puppeteer: ^24.6.1
- stylelint: ^16.18.0
- stylelint-prettier: ^5.0.3
- svglint: ^3.1.0
- terser-webpack-plugin: ^5.3.14
- tsc-alias: ^1.8.15
- ttest: ^4.0.0
- typescript: ^5.8.3
- vinyl: ^3.0.0
- webpack: ^5.99.5
- webpack-stream: ^7.0.0
- yargs: ^17.7.2

Engines:
- node: >=20.16.0

Available Relative Imports:
- `../../src/core/annotation.js`: Annotation, AnnotationBorderStyle, AnnotationFactory, MarkupAnnotation, getQuadPoints
- `../../src/core/bidi.js`: bidi
- `../../src/core/calculate_md5.js`: calculateMD5
- `../../src/core/calculate_sha256.js`: calculateSHA256
- `../../src/core/calculate_sha_other.js`: calculateSHA384, calculateSHA512
- `../../src/core/cff_parser.js`: CFFCharset, CFFCompiler, CFFFDSelect, CFFParser, CFFStrings
- `../../src/core/cmap.js`: CMap, CMapFactory, IdentityCMap
- `../../src/core/colorspace.js`: ColorSpace
- `../../src/core/colorspace_utils.js`: ColorSpaceUtils
- `../../src/core/core_utils.js`: arrayBuffersToBytes, encodeToXmlString, escapePDFName, escapeString, getInheritableProperty, getSizeInBytes, isAscii, isWhiteSpace, log2, numberToString, parseXFAPath, recoverJsURL, stringToUTF16HexString, stringToUTF16String, toRomanNumerals, validateCSSFont
- `../../src/core/crypto.js`: AES128Cipher, AES256Cipher, ARCFourCipher, CipherTransformFactory, PDF17, PDF20
- `../../src/core/default_appearance.js`: createDefaultAppearance, parseAppearanceStream, parseDefaultAppearance
- `../../src/core/document.js`: PDFDocument, Page
- `../../src/core/encodings.js`: getEncoding
- `../../src/core/evaluator.js`: PartialEvaluator
- `../../src/core/flate_stream.js`: FlateStream
- `../../src/core/font_substitutions.js`: getFontSubstitution
- `../../src/core/fonts_utils.js`: SEAC_ANALYSIS_ENABLED
- `../../src/core/function.js`: PDFFunctionFactory, PostScriptCompiler, PostScriptEvaluator
- `../../src/core/glyphlist.js`: getDingbatsGlyphsUnicode, getGlyphsUnicode
- `../../src/core/image_utils.js`: GlobalColorSpaceCache, GlobalImageCache, LocalColorSpaceCache
- `../../src/core/jbig2.js`: Jbig2Error, Jbig2Image
- `../../src/core/jpg.js`: JpegError, JpegImage
- `../../src/core/jpx.js`: JpxError, JpxImage
- `../../src/core/metadata_parser.js`: MetadataParser
- `../../src/core/operator_list.js`: OperatorList
- `../../src/core/parser.js`: Lexer, Linearization, Parser
- `../../src/core/predictor_stream.js`: PredictorStream
- `../../src/core/primitives.js`: Cmd, Dict, EOF, Name, Ref, RefSet, RefSetCache, isCmd, isDict, isName, isRefsEqual
- `../../src/core/ps_parser.js`: PostScriptLexer, PostScriptParser
- `../../src/core/stream.js`: NullStream, Stream, StringStream
- `../../src/core/type1_parser.js`: Type1Parser
- `../../src/core/unicode.js`: getCharUnicodeCategory, getUnicodeForGlyph, getUnicodeRangeFor, mapSpecialUnicodeValues
- `../../src/core/worker.js`: WorkerMessageHandler, WorkerTask
- `../../src/core/writer.js`: incrementalUpdate, writeChanges, writeDict
- `../../src/core/xfa/bind.js`: Binder
- `../../src/core/xfa/data.js`: DataHandler
- `../../src/core/xfa/factory.js`: XFAFactory
- `../../src/core/xfa/formcalc_lexer.js`: Lexer, TOKEN, Token
- `../../src/core/xfa/formcalc_parser.js`: Errors, Parser
- `../../src/core/xfa/parser.js`: XFAParser
- `../../src/core/xfa/som.js`: searchNode
- `../../src/core/xfa/symbol_utils.js`: $dump, $getChildren, $getChildrenByClass, $getChildrenByName, $text, $uid
- `../../src/core/xml_parser.js`: SimpleXMLParser, XMLParserBase
- `../../src/display/annotation_layer.js`: AnnotationLayer
- `../../src/display/annotation_storage.js`: AnnotationStorage
- `../../src/display/api.js`: LoopbackPort, PDFDataRangeTransport, PDFDocumentLoadingTask, PDFDocumentProxy, PDFPageProxy, PDFWorker, RenderTask, build, getDocument, isValidExplicitDest, version
- `../../src/display/canvas_factory.js`: DOMCanvasFactory
- `../../src/display/cmap_reader_factory.js`: DOMCMapReaderFactory
- `../../src/display/display_utils.js`: OutputScale, PDFDateString, PageViewport, PixelsPerInch, RenderingCancelledException, StatTimer, SupportedImageMimeTypes, fetchData, getFilenameFromUrl, getPdfFilenameFromUrl, getXfaPageViewport, isDataScheme, isPdfFile, isValidFetchUrl, noContextMenu, setLayerDimensions, stopEvent
- `../../src/display/draw_layer.js`: DrawLayer
- `../../src/display/editor/annotation_editor_layer.js`: AnnotationEditorLayer
- `../../src/display/editor/color_picker.js`: ColorPicker
- `../../src/display/editor/drawers/signaturedraw.js`: SignatureExtractor
- `../../src/display/editor/tools.js`: AnnotationEditorUIManager, CommandManager
- `../../src/display/fetch_stream.js`: PDFFetchStream
- `../../src/display/metadata.js`: Metadata
- `../../src/display/network.js`: PDFNetworkStream
- `../../src/display/network_utils.js`: createHeaders, createResponseError, extractFilenameFromHeader, validateRangeRequestCapabilities, validateResponseStatus
- `../../src/display/node_stream.js`: PDFNodeStream
- `../../src/display/node_utils.js`: NodeCMapReaderFactory, NodeStandardFontDataFactory, fetchData
- `../../src/display/standard_fontdata_factory.js`: DOMStandardFontDataFactory
- `../../src/display/svg_factory.js`: DOMSVGFactory
- `../../src/display/text_layer.js`: TextLayer
- `../../src/display/touch_manager.js`: TouchManager
- `../../src/display/worker_options.js`: GlobalWorkerOptions
- `../../src/display/xfa_layer.js`: XfaLayer
- `../../src/shared/message_handler.js`: MessageHandler
- `../../src/shared/murmurhash3.js`: MurmurHash3_64
- `../../src/shared/util.js`: AbortException, AnnotationBorderStyleType, AnnotationEditorParamsType, AnnotationEditorType, AnnotationFieldFlag, AnnotationFlag, AnnotationMode, AnnotationType, BaseException, DrawOPS, FeatureTest, FormatError, ImageKind, InvalidPDFException, MathClamp, OPS, PasswordException, PasswordResponses, PermissionFlag, RenderingIntentFlag, ResponseException, UnknownErrorException, Util, VerbosityLevel, assert, bytesToString, createValidAbsoluteUrl, getModificationDate, getUuid, getVerbosityLevel, isNodeJS, normalizeUnicode, objectSize, setVerbosityLevel, shadow, string32, stringToBytes, stringToPDFString, stringToUTF8String, toBase64Util
- `../../web/annotation_layer_builder.js`: AnnotationLayerBuilder
- `../../web/app_options.js`: AppOptions, OptionKind
- `../../web/autolinker.js`: Autolinker
- `../../web/download_manager.js`: DownloadManager
- `../../web/event_utils.js`: EventBus, WaitOnType, waitOnEventOrTimeout
- `../../web/genericl10n.js`: GenericL10n
- `../../web/pdf_find_controller.js`: FindState, PDFFindController
- `../../web/pdf_find_utils.js`: CharacterType, getCharacterType
- `../../web/pdf_history.js`: PDFHistory, isDestArraysEqual, isDestHashesEqual
- `../../web/pdf_link_service.js`: LinkTarget, PDFLinkService, SimpleLinkService
- `../../web/pdf_page_view.js`: PDFPageView
- `../../web/pdf_scripting_manager.component.js`: PDFScriptingManager
- `../../web/pdf_single_page_viewer.js`: PDFSinglePageViewer
- `../../web/pdf_viewer.js`: PDFPageViewBuffer, PDFViewer
- `../../web/struct_tree_layer_builder.js`: StructTreeLayerBuilder
- `../../web/text_layer_builder.js`: TextLayerBuilder
- `../../web/ui_utils.js`: AutoPrintRegExp, ProgressBar, RenderingStates, ScrollMode, SpreadMode, backtrackBeforeAllVisibleElements, binarySearchFirstItem, calcRound, getPageSizeInches, getVisibleElements, isPortraitOrientation, isValidRotation, parseQueryString, removeNullCharacters
- `../../web/xfa_layer_builder.js`: XfaLayerBuilder
- `../reporter.js`: TestReporter
- `./common_pdfstream_tests.js`: testCrossOriginRedirects
- `./test_utils.js`: CMAP_URL, DefaultCMapReaderFactory, DefaultFileReaderFactory, DefaultStandardFontDataFactory, STANDARD_FONT_DATA_URL, TEST_PDFS_PATH, TestPdfsServer, XRefMock, buildGetDocumentParams, createIdFactory, getCrossOriginHostname
</imports>

Code:
<code>
File:
src/core/evaluator.js
1 /* Copyright 2012 Mozilla Foundation
2  *
3  * Licensed under the Apache License, Version 2.0 (the "License");
4  * you may not use this file except in compliance with the License.
5  * You may obtain a copy of the License at
6  *
7  *     http://www.apache.org/licenses/LICENSE-2.0
8  *
9  * Unless required by applicable law or agreed to in writing, software
10  * distributed under the License is distributed on an "AS IS" BASIS,
11  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
12  * See the License for the specific language governing permissions and
13  * limitations under the License.
14  */
15 
16 import {
17   AbortException,
18   assert,
19   DrawOPS,
20   FONT_IDENTITY_MATRIX,
21   FormatError,
22   info,
23   isArrayEqual,
24   normalizeUnicode,
25   OPS,
26   shadow,
27   stringToPDFString,
28   TextRenderingMode,
29   Util,
30   warn,
31 } from "../shared/util.js";
32 import { CMapFactory, IdentityCMap } from "./cmap.js";
33 import { Cmd, Dict, EOF, isName, Name, Ref, RefSet } from "./primitives.js";
34 import { compileType3Glyph, FontFlags } from "./fonts_utils.js";
35 import { ErrorFont, Font } from "./fonts.js";
36 import {
37   fetchBinaryData,
38   IDENTITY_MATRIX,
39   isNumberArray,
40   lookupMatrix,
41   lookupNormalRect,
42 } from "./core_utils.js";
43 import {
44   getEncoding,
45   MacRomanEncoding,
46   StandardEncoding,
47   SymbolSetEncoding,
48   WinAnsiEncoding,
49   ZapfDingbatsEncoding,
50 } from "./encodings.js";
51 import {
52   getFontNameToFileMap,
53   getSerifFonts,
54   getStandardFontName,
55   getStdFontMap,
56   getSymbolsFonts,
57   isKnownFontName,
58 } from "./standard_fonts.js";
59 import { getTilingPatternIR, Pattern } from "./pattern.js";
60 import { getXfaFontDict, getXfaFontName } from "./xfa_fonts.js";
61 import { IdentityToUnicodeMap, ToUnicodeMap } from "./to_unicode_map.js";
62 import { isPDFFunction, PDFFunctionFactory } from "./function.js";
63 import { Lexer, Parser } from "./parser.js";
64 import {
65   LocalColorSpaceCache,
66   LocalGStateCache,
67   LocalImageCache,
68   LocalTilingPatternCache,
69   RegionalImageCache,
70 } from "./image_utils.js";
71 import { BaseStream } from "./base_stream.js";
72 import { bidi } from "./bidi.js";
73 import { ColorSpace } from "./colorspace.js";
74 import { ColorSpaceUtils } from "./colorspace_utils.js";
75 import { getFontSubstitution } from "./font_substitutions.js";
76 import { getGlyphsUnicode } from "./glyphlist.js";
77 import { getMetrics } from "./metrics.js";
78 import { getUnicodeForGlyph } from "./unicode.js";
79 import { MurmurHash3_64 } from "../shared/murmurhash3.js";
80 import { OperatorList } from "./operator_list.js";
81 import { PDFImage } from "./image.js";
82 import { Stream } from "./stream.js";
83 
84 const DefaultPartialEvaluatorOptions = Object.freeze({
85   maxImageSize: -1,
86   disableFontFace: false,
87   ignoreErrors: false,
88   isEvalSupported: true,
89   isOffscreenCanvasSupported: false,
90   isImageDecoderSupported: false,
91   canvasMaxAreaInBytes: -1,
92   fontExtraProperties: false,
93   useSystemFonts: true,
94   useWasm: true,
95   useWorkerFetch: true,
96   cMapUrl: null,
97   iccUrl: null,
98   standardFontDataUrl: null,
99   wasmUrl: null,
100 });
101 
102 const PatternType = {
103   TILING: 1,
104   SHADING: 2,
105 };
106 
107 // Optionally avoid sending individual, or very few, text chunks to reduce
108 // `postMessage` overhead with ReadableStream (see issue 13962).
109 //
110 // PLEASE NOTE: This value should *not* be too large (it's used as a lower limit
111 // in `enqueueChunk`), since that would cause streaming of textContent to become
112 // essentially useless in practice by sending all (or most) chunks at once.
113 // Also, a too large value would (indirectly) affect the main-thread `textLayer`
114 // building negatively by forcing all textContent to be handled at once, which
115 // could easily end up hurting *overall* performance (e.g. rendering as well).
116 const TEXT_CHUNK_BATCH_SIZE = 10;
117 
118 const deferred = Promise.resolve();
119 
120 // Convert PDF blend mode names to HTML5 blend mode names.
121 function normalizeBlendMode(value, parsingArray = false) {
122   if (Array.isArray(value)) {
123     // Use the first *supported* BM value in the Array (fixes issue11279.pdf).
124     for (const val of value) {
125       const maybeBM = normalizeBlendMode(val, /* parsingArray = */ true);
126       if (maybeBM) {
127         return maybeBM;
128       }
129     }
130     warn(`Unsupported blend mode Array: ${value}`);
131     return "source-over";
132   }
133 
134   if (!(value instanceof Name)) {
135     if (parsingArray) {
136       return null;
137     }
138     return "source-over";
139   }
140   switch (value.name) {
141     case "Normal":
142     case "Compatible":
143       return "source-over";
144     case "Multiply":
145       return "multiply";
146     case "Screen":
147       return "screen";
148     case "Overlay":
149       return "overlay";
150     case "Darken":
151       return "darken";
152     case "Lighten":
153       return "lighten";
154     case "ColorDodge":
155       return "color-dodge";
156     case "ColorBurn":
157       return "color-burn";
158     case "HardLight":
159       return "hard-light";
160     case "SoftLight":
161       return "soft-light";
162     case "Difference":
163       return "difference";
164     case "Exclusion":
165       return "exclusion";
166     case "Hue":
167       return "hue";
168     case "Saturation":
169       return "saturation";
170     case "Color":
171       return "color";
172     case "Luminosity":
173       return "luminosity";
174   }
175   if (parsingArray) {
176     return null;
177   }
178   warn(`Unsupported blend mode: ${value.name}`);
179   return "source-over";
180 }
181 
182 function addCachedImageOps(
183   opList,
184   { objId, fn, args, optionalContent, hasMask }
185 ) {
186   if (objId) {
187     opList.addDependency(objId);
188   }
189   opList.addImageOps(fn, args, optionalContent, hasMask);
190 
191   if (fn === OPS.paintImageMaskXObject && args[0]?.count > 0) {
192     args[0].count++;
193   }
194 }
195 
196 // Trying to minimize Date.now() usage and check every 100 time.
197 class TimeSlotManager {
198   static TIME_SLOT_DURATION_MS = 20;
199 
200   static CHECK_TIME_EVERY = 100;
201 
202   constructor() {
203     this.reset();
204   }
205 
206   check() {
207     if (++this.checked < TimeSlotManager.CHECK_TIME_EVERY) {
208       return false;
209     }
210     this.checked = 0;
211     return this.endTime <= Date.now();
212   }
213 
214   reset() {
215     this.endTime = Date.now() + TimeSlotManager.TIME_SLOT_DURATION_MS;
216     this.checked = 0;
217   }
218 }
219 
220 class PartialEvaluator {
221   constructor({
222     xref,
223     handler,
224     pageIndex,
225     idFactory,
226     fontCache,
227     builtInCMapCache,
228     standardFontDataCache,
229     globalColorSpaceCache,
230     globalImageCache,
231     systemFontCache,
232     options = null,
233   }) {
234     this.xref = xref;
235     this.handler = handler;
236     this.pageIndex = pageIndex;
237     this.idFactory = idFactory;
238     this.fontCache = fontCache;
239     this.builtInCMapCache = builtInCMapCache;
240     this.standardFontDataCache = standardFontDataCache;
241     this.globalColorSpaceCache = globalColorSpaceCache;
242     this.globalImageCache = globalImageCache;
243     this.systemFontCache = systemFontCache;
244     this.options = options || DefaultPartialEvaluatorOptions;
245     this.type3FontRefs = null;
246 
247     this._regionalImageCache = new RegionalImageCache();
248     this._fetchBuiltInCMapBound = this.fetchBuiltInCMap.bind(this);
249   }
250 
251   /**
252    * Since Functions are only cached (locally) by reference, we can share one
253    * `PDFFunctionFactory` instance within this `PartialEvaluator` instance.
254    */
255   get _pdfFunctionFactory() {
256     const pdfFunctionFactory = new PDFFunctionFactory({
257       xref: this.xref,
258       isEvalSupported: this.options.isEvalSupported,
259     });
260     return shadow(this, "_pdfFunctionFactory", pdfFunctionFactory);
261   }
262 
263   get parsingType3Font() {
264     return !!this.type3FontRefs;
265   }
266 
267   clone(newOptions = null) {
268     const newEvaluator = Object.create(this);
269     newEvaluator.options = Object.assign(
270       Object.create(null),
271       this.options,
272       newOptions
273     );
274     return newEvaluator;
275   }
276 
277   hasBlendModes(resources, nonBlendModesSet) {
278     if (!(resources instanceof Dict)) {
279       return false;
280     }
281     if (resources.objId && nonBlendModesSet.has(resources.objId)) {
282       return false;
283     }
284 
285     const processed = new RefSet(nonBlendModesSet);
286     if (resources.objId) {
287       processed.put(resources.objId);
288     }
289 
290     const nodes = [resources],
291       xref = this.xref;
292     while (nodes.length) {
293       const node = nodes.shift();
294       // First check the current resources for blend modes.
295       const graphicStates = node.get("ExtGState");
296       if (graphicStates instanceof Dict) {
297         for (let graphicState of graphicStates.getRawValues()) {
298           if (graphicState instanceof Ref) {
299             if (processed.has(graphicState)) {
300               continue; // The ExtGState has already been processed.
301             }
302             try {
303               graphicState = xref.fetch(graphicState);
304             } catch (ex) {
305               // Avoid parsing a corrupt ExtGState more than once.
306               processed.put(graphicState);
307 
308               info(`hasBlendModes - ignoring ExtGState: "${ex}".`);
309               continue;
310             }
311           }
312           if (!(graphicState instanceof Dict)) {
313             continue;
314           }
315           if (graphicState.objId) {
316             processed.put(graphicState.objId);
317           }
318 
319           const bm = graphicState.get("BM");
320           if (bm instanceof Name) {
321             if (bm.name !== "Normal") {
322               return true;
323             }
324             continue;
325           }
326           if (bm !== undefined && Array.isArray(bm)) {
327             for (const element of bm) {
328               if (element instanceof Name && element.name !== "Normal") {
329                 return true;
330               }
331             }
332           }
333         }
334       }
335       // Descend into the XObjects to look for more resources and blend modes.
336       const xObjects = node.get("XObject");
337       if (!(xObjects instanceof Dict)) {
338         continue;
339       }
340       for (let xObject of xObjects.getRawValues()) {
341         if (xObject instanceof Ref) {
342           if (processed.has(xObject)) {
343             // The XObject has already been processed, and by avoiding a
344             // redundant `xref.fetch` we can *significantly* reduce the load
345             // time for badly generated PDF files (fixes issue6961.pdf).
346             continue;
347           }
348           try {
349             xObject = xref.fetch(xObject);
350           } catch (ex) {
351             // Avoid parsing a corrupt XObject more than once.
352             processed.put(xObject);
353 
354             info(`hasBlendModes - ignoring XObject: "${ex}".`);
355             continue;
356           }
357         }
358         if (!(xObject instanceof BaseStream)) {
359           continue;
360         }
361         if (xObject.dict.objId) {
362           processed.put(xObject.dict.objId);
363         }
364         const xResources = xObject.dict.get("Resources");
365         if (!(xResources instanceof Dict)) {
366           continue;
367         }
368         // Checking objId to detect an infinite loop.
369         if (xResources.objId && processed.has(xResources.objId)) {
370           continue;
371         }
372 
373         nodes.push(xResources);
374         if (xResources.objId) {
375           processed.put(xResources.objId);
376         }
377       }
378     }
379 
380     // When no blend modes exist, there's no need re-fetch/re-parse any of the
381     // processed `Ref`s again for subsequent pages. This helps reduce redundant
382     // `XRef.fetch` calls for some documents (e.g. issue6961.pdf).
383     for (const ref of processed) {
384       nonBlendModesSet.put(ref);
385     }
386     return false;
387   }
388 
389   async fetchBuiltInCMap(name) {
390     const cachedData = this.builtInCMapCache.get(name);
391     if (cachedData) {
392       return cachedData;
393     }
394     let data;
395 
396     if (this.options.useWorkerFetch) {
397       // Only compressed CMaps are (currently) supported here.
398       data = {
399         cMapData: await fetchBinaryData(`${this.options.cMapUrl}${name}.bcmap`),
400         isCompressed: true,
401       };
402     } else {
403       // Get the data on the main-thread instead.
404       data = await this.handler.sendWithPromise("FetchBinaryData", {
405         type: "cMapReaderFactory",
406         name,
407       });
408     }
409     // Cache the CMap data, to avoid fetching it repeatedly.
410     this.builtInCMapCache.set(name, data);
411 
412     return data;
413   }
414 
415   async fetchStandardFontData(name) {
416     const cachedData = this.standardFontDataCache.get(name);
417     if (cachedData) {
418       return new Stream(cachedData);
419     }
420 
421     // The symbol fonts are not consistent across platforms, always load the
422     // standard font data for them.
423     if (
424       this.options.useSystemFonts &&
425       name !== "Symbol" &&
426       name !== "ZapfDingbats"
427     ) {
428       return null;
429     }
430 
431     const standardFontNameToFileName = getFontNameToFileMap(),
432       filename = standardFontNameToFileName[name];
433     let data;
434 
435     try {
436       if (this.options.useWorkerFetch) {
437         data = await fetchBinaryData(
438           `${this.options.standardFontDataUrl}${filename}`
439         );
440       } else {
441         // Get the data on the main-thread instead.
442         data = await this.handler.sendWithPromise("FetchBinaryData", {
443           type: "standardFontDataFactory",
444           filename,
445         });
446       }
447     } catch (ex) {
448       warn(ex);
449       return null;
450     }
451     // Cache the "raw" standard font data, to avoid fetching it repeatedly
452     // (see e.g. issue 11399).
453     this.standardFontDataCache.set(name, data);
454 
455     return new Stream(data);
456   }
457 
458   async buildFormXObject(
459     resources,
460     xobj,
461     smask,
462     operatorList,
463     task,
464     initialState,
465     localColorSpaceCache,
466     seenRefs
467   ) {
468     const dict = xobj.dict;
469     const matrix = lookupMatrix(dict.getArray("Matrix"), null);
470     const bbox = lookupNormalRect(dict.getArray("BBox"), null);
471 
472     let optionalContent, groupOptions;
473     if (dict.has("OC")) {
474       optionalContent = await this.parseMarkedContentProps(
475         dict.get("OC"),
476         resources
477       );
478     }
479     if (optionalContent !== undefined) {
480       operatorList.addOp(OPS.beginMarkedContentProps, ["OC", optionalContent]);
481     }
482     const group = dict.get("Group");
483     if (group) {
484       groupOptions = {
485         matrix,
486         bbox,
487         smask,
488         isolated: false,
489         knockout: false,
490       };
491 
492       const groupSubtype = group.get("S");
493       let colorSpace = null;
494       if (isName(groupSubtype, "Transparency")) {
495         groupOptions.isolated = group.get("I") || false;
496         groupOptions.knockout = group.get("K") || false;
497         if (group.has("CS")) {
498           const cs = this._getColorSpace(
499             group.getRaw("CS"),
500             resources,
501             localColorSpaceCache
502           );
503           colorSpace =
504             cs instanceof ColorSpace ? cs : await this._handleColorSpace(cs);
505         }
506       }
507 
508       if (smask?.backdrop) {
509         colorSpace ||= ColorSpaceUtils.rgb;
510         smask.backdrop = colorSpace.getRgb(smask.backdrop, 0);
511       }
512 
513       operatorList.addOp(OPS.beginGroup, [groupOptions]);
514     }
515 
516     // If it's a group, a new canvas will be created that is the size of the
517     // bounding box and translated to the correct position so we don't need to
518     // apply the bounding box to it.
519     const f32matrix = matrix && new Float32Array(matrix);
520     const f32bbox = (!group && bbox && new Float32Array(bbox)) || null;
521     const args = [f32matrix, f32bbox];
522     operatorList.addOp(OPS.paintFormXObjectBegin, args);
523 
524     await this.getOperatorList({
525       stream: xobj,
526       task,
527       resources: dict.get("Resources") || resources,
528       operatorList,
529       initialState,
530       prevRefs: seenRefs,
531     });
532     operatorList.addOp(OPS.paintFormXObjectEnd, []);
533 
534     if (group) {
535       operatorList.addOp(OPS.endGroup, [groupOptions]);
536     }
537 
538     if (optionalContent !== undefined) {
539       operatorList.addOp(OPS.endMarkedContent, []);
540     }
541   }
542 
543   _sendImgData(objId, imgData, cacheGlobally = false) {
544     if (
545       (typeof PDFJSDev === "undefined" || PDFJSDev.test("TESTING")) &&
546       imgData
547     ) {
548       assert(Number.isInteger(imgData.dataLen), "Expected dataLen to be set.");
549     }
550     const transfers = imgData ? [imgData.bitmap || imgData.data.buffer] : null;
551 
552     if (this.parsingType3Font || cacheGlobally) {
553       return this.handler.send(
554         "commonobj",
555         [objId, "Image", imgData],
556         transfers
557       );
558     }
559     return this.handler.send(
560       "obj",
561       [objId, this.pageIndex, "Image", imgData],
562       transfers
563     );
564   }
565 
566   async buildPaintImageXObject({
567     resources,
568     image,
569     isInline = false,
570     operatorList,
571     cacheKey,
572     localImageCache,
573     localColorSpaceCache,
574   }) {
575     const { maxImageSize, ignoreErrors, isOffscreenCanvasSupported } =
576       this.options;
577 
578     const { dict } = image;
579     const imageRef = dict.objId;
580     const w = dict.get("W", "Width");
581     const h = dict.get("H", "Height");
582 
583     if (!(w && typeof w === "number") || !(h && typeof h === "number")) {
584       warn("Image dimensions are missing, or not numbers.");
585       return;
586     }
587     if (maxImageSize !== -1 && w * h > maxImageSize) {
588       const msg = "Image exceeded maximum allowed size and was removed.";
589 
590       if (!ignoreErrors) {
591         throw new Error(msg);
592       }
593       warn(msg);
594       return;
595     }
596 
597     let optionalContent;
598     if (dict.has("OC")) {
599       optionalContent = await this.parseMarkedContentProps(
600         dict.get("OC"),
601         resources
602       );
603     }
604 
605     const imageMask = dict.get("IM", "ImageMask") || false;
606     let imgData, fn, args;
607     if (imageMask) {
608       // This depends on a tmpCanvas being filled with the
609       // current fillStyle, such that processing the pixel
610       // data can't be done here. Instead of creating a
611       // complete PDFImage, only read the information needed
612       // for later.
613       imgData = await PDFImage.createMask({
614         image,
615         isOffscreenCanvasSupported:
616           isOffscreenCanvasSupported && !this.parsingType3Font,
617       });
618 
619       if (imgData.isSingleOpaquePixel) {
620         // Handles special case of mainly LaTeX documents which use image
621         // masks to draw lines with the current fill style.
622         fn = OPS.paintSolidColorImageMask;
623         args = [];
624         operatorList.addImageOps(fn, args, optionalContent);
625 
626         if (cacheKey) {
627           const cacheData = { fn, args, optionalContent };
628           localImageCache.set(cacheKey, imageRef, cacheData);
629 
630           if (imageRef) {
631             this._regionalImageCache.set(
632               /* name = */ null,
633               imageRef,
634               cacheData
635             );
636           }
637         }
638         return;
639       }
640 
641       if (this.parsingType3Font) {
642         // NOTE: Compared to other image resources we don't bother caching
643         // Type3-glyph image masks, since we've not come across any cases
644         // where that actually helps.
645         // In Type3-glyphs image masks are "always" inline resources,
646         // they're usually fairly small and aren't being re-used either.
647         if (typeof PDFJSDev === "undefined" || PDFJSDev.test("TESTING")) {
648           assert(
649             imgData.data instanceof Uint8Array,
650             "Type3 glyph image mask must be a TypedArray."
651           );
652         }
653         args = compileType3Glyph(imgData);
654 
655         if (args) {
656           operatorList.addImageOps(OPS.constructPath, args, optionalContent);
657           return;
658         }
659         warn("Cannot compile Type3 glyph.");
660 
661         // If compilation failed, or was disabled, fallback to using an inline
662         // image mask; this case should be extremely rare.
663         operatorList.addImageOps(
664           OPS.paintImageMaskXObject,
665           [imgData],
666           optionalContent
667         );
668         return;
669       }
670 
671       const objId = `mask_${this.idFactory.createObjId()}`;
672       operatorList.addDependency(objId);
673 
674       imgData.dataLen = imgData.bitmap
675         ? imgData.width * imgData.height * 4
676         : imgData.data.length;
677       this._sendImgData(objId, imgData);
678 
679       fn = OPS.paintImageMaskXObject;
680       args = [
681         {
682           data: objId,
683           width: imgData.width,
684           height: imgData.height,
685           interpolate: imgData.interpolate,
686           count: 1,
687         },
688       ];
689       operatorList.addImageOps(fn, args, optionalContent);
690 
691       if (cacheKey) {
692         const cacheData = { objId, fn, args, optionalContent };
693         localImageCache.set(cacheKey, imageRef, cacheData);
694 
695         if (imageRef) {
696           this._regionalImageCache.set(/* name = */ null, imageRef, cacheData);
697         }
698       }
699       return;
700     }
701 
702     const SMALL_IMAGE_DIMENSIONS = 200;
703     const hasMask = dict.has("SMask") || dict.has("Mask");
704     // Inlining small images into the queue as RGB data
705     if (isInline && w + h < SMALL_IMAGE_DIMENSIONS && !hasMask) {
706       try {
707         const imageObj = new PDFImage({
708           xref: this.xref,
709           res: resources,
710           image,
711           isInline,
712           pdfFunctionFactory: this._pdfFunctionFactory,
713           globalColorSpaceCache: this.globalColorSpaceCache,
714           localColorSpaceCache,
715         });
716         // We force the use of RGBA_32BPP images here, because we can't handle
717         // any other kind.
718         imgData = await imageObj.createImageData(
719           /* forceRGBA = */ true,
720           /* isOffscreenCanvasSupported = */ false
721         );
722         operatorList.addImageOps(
723           OPS.paintInlineImageXObject,
724           [imgData],
725           optionalContent
726         );
727       } catch (reason) {
728         const msg = `Unable to decode inline image: "${reason}".`;
729 
730         if (!ignoreErrors) {
731           throw new Error(msg);
732         }
733         warn(msg);
734       }
735       return;
736     }
737 
738     // If there is no imageMask, create the PDFImage and a lot
739     // of image processing can be done here.
740     let objId = `img_${this.idFactory.createObjId()}`,
741       cacheGlobally = false,
742       globalCacheData = null;
743 
744     if (this.parsingType3Font) {
745       objId = `${this.idFactory.getDocId()}_type3_${objId}`;
746     } else if (cacheKey && imageRef) {
747       cacheGlobally = this.globalImageCache.shouldCache(
748         imageRef,
749         this.pageIndex
750       );
751 
752       if (cacheGlobally) {
753         assert(!isInline, "Cannot cache an inline image globally.");
754 
755         objId = `${this.idFactory.getDocId()}_${objId}`;
756       }
757     }
758 
759     // Ensure that the dependency is added before the image is decoded.
760     operatorList.addDependency(objId);
761 
762     fn = OPS.paintImageXObject;
763     args = [objId, w, h];
764     operatorList.addImageOps(fn, args, optionalContent, hasMask);
765 
766     if (cacheGlobally) {
767       globalCacheData = {
768         objId,
769         fn,
770         args,
771         optionalContent,
772         hasMask,
773         byteSize: 0, // Temporary entry, to avoid `setData` returning early.
774       };
775 
776       if (this.globalImageCache.hasDecodeFailed(imageRef)) {
777         this.globalImageCache.setData(imageRef, globalCacheData);
778 
779         this._sendImgData(objId, /* imgData = */ null, cacheGlobally);
780         return;
781       }
782 
783       // For large (at least 500x500) or more complex images that we'll cache
784       // globally, check if the image is still cached locally on the main-thread
785       // to avoid having to re-parse the image (since that can be slow).
786       if (w * h > 250000 || hasMask) {
787         const localLength = await this.handler.sendWithPromise("commonobj", [
788           objId,
789           "CopyLocalImage",
790           { imageRef },
791         ]);
792 
793         if (localLength) {
794           this.globalImageCache.setData(imageRef, globalCacheData);
795           this.globalImageCache.addByteSize(imageRef, localLength);
796           return;
797         }
798       }
799     }
800 
801     PDFImage.buildImage({
802       xref: this.xref,
803       res: resources,
804       image,
805       isInline,
806       pdfFunctionFactory: this._pdfFunctionFactory,
807       globalColorSpaceCache: this.globalColorSpaceCache,
808       localColorSpaceCache,
809     })
810       .then(async imageObj => {
811         imgData = await imageObj.createImageData(
812           /* forceRGBA = */ false,
813           isOffscreenCanvasSupported
814         );
815         imgData.dataLen = imgData.bitmap
816           ? imgData.width * imgData.height * 4
817           : imgData.data.length;
818         imgData.ref = imageRef;
819 
820         if (cacheGlobally) {
821           this.globalImageCache.addByteSize(imageRef, imgData.dataLen);
822         }
823         return this._sendImgData(objId, imgData, cacheGlobally);
824       })
825       .catch(reason => {
826         warn(`Unable to decode image "${objId}": "${reason}".`);
827 
828         if (imageRef) {
829           this.globalImageCache.addDecodeFailed(imageRef);
830         }
831         return this._sendImgData(objId, /* imgData = */ null, cacheGlobally);
832       });
833 
834     if (cacheKey) {
835       const cacheData = { objId, fn, args, optionalContent, hasMask };
836       localImageCache.set(cacheKey, imageRef, cacheData);
837 
838       if (imageRef) {
839         this._regionalImageCache.set(/* name = */ null, imageRef, cacheData);
840 
841         if (cacheGlobally) {
842           assert(globalCacheData, "The global cache-data must be available.");
843           this.globalImageCache.setData(imageRef, globalCacheData);
844         }
845       }
846     }
847   }
848 
849   handleSMask(
850     smask,
851     resources,
852     operatorList,
853     task,
854     stateManager,
855     localColorSpaceCache,
856     seenRefs
857   ) {
858     const smaskContent = smask.get("G");
859     const smaskOptions = {
860       subtype: smask.get("S").name,
861       backdrop: smask.get("BC"),
862     };
863 
864     // The SMask might have a alpha/luminosity value transfer function --
865     // we will build a map of integer values in range 0..255 to be fast.
866     const transferObj = smask.get("TR");
867     if (isPDFFunction(transferObj)) {
868       const transferFn = this._pdfFunctionFactory.create(transferObj);
869       const transferMap = new Uint8Array(256);
870       const tmp = new Float32Array(1);
871       for (let i = 0; i < 256; i++) {
872         tmp[0] = i / 255;
873         transferFn(tmp, 0, tmp, 0);
874         transferMap[i] = (tmp[0] * 255) | 0;
875       }
876       smaskOptions.transferMap = transferMap;
877     }
878 
879     return this.buildFormXObject(
880       resources,
881       smaskContent,
882       smaskOptions,
883       operatorList,
884       task,
885       stateManager.state.clone({ newPath: true }),
886       localColorSpaceCache,
887       seenRefs
888     );
889   }
890 
891   handleTransferFunction(tr) {
892     let transferArray;
893     if (Array.isArray(tr)) {
894       transferArray = tr;
895     } else if (isPDFFunction(tr)) {
896       transferArray = [tr];
897     } else {
898       return null; // Not a valid transfer function entry.
899     }
900 
901     const transferMaps = [];
902     let numFns = 0,
903       numEffectfulFns = 0;
904     for (const entry of transferArray) {
905       const transferObj = this.xref.fetchIfRef(entry);
906       numFns++;
907 
908       if (isName(transferObj, "Identity")) {
909         transferMaps.push(null);
910         continue;
911       } else if (!isPDFFunction(transferObj)) {
912         return null; // Not a valid transfer function object.
913       }
914 
915       const transferFn = this._pdfFunctionFactory.create(transferObj);
916       const transferMap = new Uint8Array(256),
917         tmp = new Float32Array(1);
918       for (let j = 0; j < 256; j++) {
919         tmp[0] = j / 255;
920         transferFn(tmp, 0, tmp, 0);
921         transferMap[j] = (tmp[0] * 255) | 0;
922       }
923       transferMaps.push(transferMap);
924       numEffectfulFns++;
925     }
926 
927     if (!(numFns === 1 || numFns === 4)) {
928       return null; // Only 1 or 4 functions are supported, by the specification.
929     }
930     if (numEffectfulFns === 0) {
931       return null; // Only /Identity transfer functions found, which are no-ops.
932     }
933     return transferMaps;
934   }
935 
936   handleTilingType(
937     fn,
938     color,
939     resources,
940     pattern,
941     patternDict,
942     operatorList,
943     task,
944     localTilingPatternCache
945   ) {
946     // Create an IR of the pattern code.
947     const tilingOpList = new OperatorList();
948     // Merge the available resources, to prevent issues when the patternDict
949     // is missing some /Resources entries (fixes issue6541.pdf).
950     const patternResources = Dict.merge({
951       xref: this.xref,
952       dictArray: [patternDict.get("Resources"), resources],
953     });
954 
955     return this.getOperatorList({
956       stream: pattern,
957       task,
958       resources: patternResources,
959       operatorList: tilingOpList,
960     })
961       .then(function () {
962         const operatorListIR = tilingOpList.getIR();
963         const tilingPatternIR = getTilingPatternIR(
964           operatorListIR,
965           patternDict,
966           color
967         );
968         // Add the dependencies to the parent operator list so they are
969         // resolved before the sub operator list is executed synchronously.
970         operatorList.addDependencies(tilingOpList.dependencies);
971         operatorList.addOp(fn, tilingPatternIR);
972 
973         if (patternDict.objId) {
974           localTilingPatternCache.set(/* name = */ null, patternDict.objId, {
975             operatorListIR,
976             dict: patternDict,
977           });
978         }
979       })
980       .catch(reason => {
981         if (reason instanceof AbortException) {
982           return;
983         }
984         if (this.options.ignoreErrors) {
985           warn(`handleTilingType - ignoring pattern: "${reason}".`);
986           return;
987         }
988         throw reason;
989       });
990   }
991 
992   async handleSetFont(
993     resources,
994     fontArgs,
995     fontRef,
996     operatorList,
997     task,
998     state,
999     fallbackFontDict = null,
1000     cssFontInfo = null
1001   ) {
1002     const fontName = fontArgs?.[0] instanceof Name ? fontArgs[0].name : null;
1003 
1004     const translated = await this.loadFont(
1005       fontName,
1006       fontRef,
1007       resources,
1008       task,
1009       fallbackFontDict,
1010       cssFontInfo
1011     );
1012 
1013     if (translated.font.isType3Font) {
1014       // Add the dependencies to the parent operatorList so they are
1015       // resolved before Type3 operatorLists are executed synchronously.
1016       operatorList.addDependencies(translated.type3Dependencies);
1017     }
1018 
1019     state.font = translated.font;
1020     translated.send(this.handler);
1021     return translated.loadedName;
1022   }
1023 
1024   handleText(chars, state) {
1025     const font = state.font;
1026     const glyphs = font.charsToGlyphs(chars);
1027 
1028     if (font.data) {
1029       const isAddToPathSet = !!(
1030         state.textRenderingMode & TextRenderingMode.ADD_TO_PATH_FLAG
1031       );
1032       if (
1033         isAddToPathSet ||
1034         state.fillColorSpace.name === "Pattern" ||
1035         font.disableFontFace
1036       ) {
1037         PartialEvaluator.buildFontPaths(
1038           font,
1039           glyphs,
1040           this.handler,
1041           this.options
1042         );
1043       }
1044     }
1045     return glyphs;
1046   }
1047 
1048   ensureStateFont(state) {
1049     if (state.font) {
1050       return;
1051     }
1052     const reason = new FormatError(
1053       "Missing setFont (Tf) operator before text rendering operator."
1054     );
1055 
1056     if (this.options.ignoreErrors) {
1057       warn(`ensureStateFont: "${reason}".`);
1058       return;
1059     }
1060     throw reason;
1061   }
1062 
1063   async setGState({
1064     resources,
1065     gState,
1066     operatorList,
1067     cacheKey,
1068     task,
1069     stateManager,
1070     localGStateCache,
1071     localColorSpaceCache,
1072     seenRefs,
1073   }) {
1074     const gStateRef = gState.objId;
1075     let isSimpleGState = true;
1076     // This array holds the converted/processed state data.
1077     const gStateObj = [];
1078     let promise = Promise.resolve();
1079     for (const [key, value] of gState) {
1080       switch (key) {
1081         case "Type":
1082           break;
1083         case "LW":
1084           if (typeof value !== "number") {
1085             warn(`Invalid LW (line width): ${value}`);
1086             break;
1087           }
1088           gStateObj.push([key, Math.abs(value)]);
1089           break;
1090         case "LC":
1091         case "LJ":
1092         case "ML":
1093         case "D":
1094         case "RI":
1095         case "FL":
1096         case "CA":
1097         case "ca":
1098           gStateObj.push([key, value]);
1099           break;
1100         case "Font":
1101           isSimpleGState = false;
1102 
1103           promise = promise.then(() =>
1104             this.handleSetFont(
1105               resources,
1106               null,
1107               value[0],
1108               operatorList,
1109               task,
1110               stateManager.state
1111             ).then(function (loadedName) {
1112               operatorList.addDependency(loadedName);
1113               gStateObj.push([key, [loadedName, value[1]]]);
1114             })
1115           );
1116           break;
1117         case "BM":
1118           gStateObj.push([key, normalizeBlendMode(value)]);
1119           break;
1120         case "SMask":
1121           if (isName(value, "None")) {
1122             gStateObj.push([key, false]);
1123             break;
1124           }
1125           if (value instanceof Dict) {
1126             isSimpleGState = false;
1127 
1128             promise = promise.then(() =>
1129               this.handleSMask(
1130                 value,
1131                 resources,
1132                 operatorList,
1133                 task,
1134                 stateManager,
1135                 localColorSpaceCache,
1136                 seenRefs
1137               )
1138             );
1139             gStateObj.push([key, true]);
1140           } else {
1141             warn("Unsupported SMask type");
1142           }
1143           break;
1144         case "TR":
1145           const transferMaps = this.handleTransferFunction(value);
1146           gStateObj.push([key, transferMaps]);
1147           break;
1148         // Only generate info log messages for the following since
1149         // they are unlikely to have a big impact on the rendering.
1150         case "OP":
1151         case "op":
1152         case "OPM":
1153         case "BG":
1154         case "BG2":
1155         case "UCR":
1156         case "UCR2":
1157         case "TR2":
1158         case "HT":
1159         case "SM":
1160         case "SA":
1161         case "AIS":
1162         case "TK":
1163           // TODO implement these operators.
1164           info("graphic state operator " + key);
1165           break;
1166         default:
1167           info("Unknown graphic state operator " + key);
1168           break;
1169       }
1170     }
1171     await promise;
1172 
1173     if (gStateObj.length > 0) {
1174       operatorList.addOp(OPS.setGState, [gStateObj]);
1175     }
1176 
1177     if (isSimpleGState) {
1178       localGStateCache.set(cacheKey, gStateRef, gStateObj);
1179     }
1180   }
1181 
1182   loadFont(
1183     fontName,
1184     font,
1185     resources,
1186     task,
1187     fallbackFontDict = null,
1188     cssFontInfo = null
1189   ) {
1190     const errorFont = async () =>
1191       new TranslatedFont({
1192         loadedName: "g_font_error",
1193         font: new ErrorFont(`Font "${fontName}" is not available.`),
1194         dict: font,
1195       });
1196 
1197     let fontRef;
1198     if (font) {
1199       // Loading by ref.
1200       if (font instanceof Ref) {
1201         fontRef = font;
1202       }
1203     } else {
1204       // Loading by name.
1205       const fontRes = resources.get("Font");
1206       if (fontRes) {
1207         fontRef = fontRes.getRaw(fontName);
1208       }
1209     }
1210     if (fontRef) {
1211       if (this.type3FontRefs?.has(fontRef)) {
1212         return errorFont();
1213       }
1214 
1215       if (this.fontCache.has(fontRef)) {
1216         return this.fontCache.get(fontRef);
1217       }
1218 
1219       try {
1220         font = this.xref.fetchIfRef(fontRef);
1221       } catch (ex) {
1222         warn(`loadFont - lookup failed: "${ex}".`);
1223       }
1224     }
1225 
1226     if (!(font instanceof Dict)) {
1227       if (!this.options.ignoreErrors && !this.parsingType3Font) {
1228         warn(`Font "${fontName}" is not available.`);
1229         return errorFont();
1230       }
1231       warn(
1232         `Font "${fontName}" is not available -- attempting to fallback to a default font.`
1233       );
1234 
1235       // Falling back to a default font to avoid completely broken rendering,
1236       // but note that there're no guarantees that things will look "correct".
1237       font = fallbackFontDict || PartialEvaluator.fallbackFontDict;
1238     }
1239 
1240     // We are holding `font.cacheKey` references only for `fontRef`s that
1241     // are not actually `Ref`s, but rather `Dict`s. See explanation below.
1242     if (font.cacheKey && this.fontCache.has(font.cacheKey)) {
1243       return this.fontCache.get(font.cacheKey);
1244     }
1245 
1246     const { promise, resolve } = Promise.withResolvers();
1247 
1248     let preEvaluatedFont;
1249     try {
1250       preEvaluatedFont = this.preEvaluateFont(font);
1251       preEvaluatedFont.cssFontInfo = cssFontInfo;
1252     } catch (reason) {
1253       warn(`loadFont - preEvaluateFont failed: "${reason}".`);
1254       return errorFont();
1255     }
1256     const { descriptor, hash } = preEvaluatedFont;
1257 
1258     const fontRefIsRef = fontRef instanceof Ref;
1259     let fontID;
1260 
1261     if (hash && descriptor instanceof Dict) {
1262       const fontAliases = (descriptor.fontAliases ||= Object.create(null));
1263 
1264       if (fontAliases[hash]) {
1265         const aliasFontRef = fontAliases[hash].aliasRef;
1266         if (fontRefIsRef && aliasFontRef && this.fontCache.has(aliasFontRef)) {
1267           this.fontCache.putAlias(fontRef, aliasFontRef);
1268           return this.fontCache.get(fontRef);
1269         }
1270       } else {
1271         fontAliases[hash] = {
1272           fontID: this.idFactory.createFontId(),
1273         };
1274       }
1275 
1276       if (fontRefIsRef) {
1277         fontAliases[hash].aliasRef = fontRef;
1278       }
1279       fontID = fontAliases[hash].fontID;
1280     } else {
1281       fontID = this.idFactory.createFontId();
1282     }
1283     assert(
1284       fontID?.startsWith("f"),
1285       'The "fontID" must be (correctly) defined.'
1286     );
1287 
1288     // Workaround for bad PDF generators that reference fonts incorrectly,
1289     // where `fontRef` is a `Dict` rather than a `Ref` (fixes bug946506.pdf).
1290     // In this case we cannot put the font into `this.fontCache` (which is
1291     // a `RefSetCache`), since it's not possible to use a `Dict` as a key.
1292     //
1293     // However, if we don't cache the font it's not possible to remove it
1294     // when `cleanup` is triggered from the API, which causes issues on
1295     // subsequent rendering operations (see issue7403.pdf) and would force us
1296     // to unnecessarily load the same fonts over and over.
1297     //
1298     // Instead, we cheat a bit by using a modified `fontID` as a key in
1299     // `this.fontCache`, to allow the font to be cached.
1300     // NOTE: This works because `RefSetCache` calls `toString()` on provided
1301     //       keys. Also, since `fontRef` is used when getting cached fonts,
1302     //       we'll not accidentally match fonts cached with the `fontID`.
1303     if (fontRefIsRef) {
1304       this.fontCache.put(fontRef, promise);
1305     } else {
1306       font.cacheKey = `cacheKey_${fontID}`;
1307       this.fontCache.put(font.cacheKey, promise);
1308     }
1309 
1310     // Keep track of each font we translated so the caller can
1311     // load them asynchronously before calling display on a page.
1312     font.loadedName = `${this.idFactory.getDocId()}_${fontID}`;
1313 
1314     this.translateFont(preEvaluatedFont)
1315       .then(async translatedFont => {
1316         const translated = new TranslatedFont({
1317           loadedName: font.loadedName,
1318           font: translatedFont,
1319           dict: font,
1320         });
1321 
1322         if (translatedFont.isType3Font) {
1323           try {
1324             await translated.loadType3Data(this, resources, task);
1325           } catch (reason) {
1326             throw new Error(`Type3 font load error: ${reason}`);
1327           }
1328         }
1329         resolve(translated);
1330       })
1331       .catch(reason => {
1332         // TODO reject?
1333         warn(`loadFont - translateFont failed: "${reason}".`);
1334 
1335         resolve(
1336           new TranslatedFont({
1337             loadedName: font.loadedName,
1338             font: new ErrorFont(reason?.message),
1339             dict: font,
1340           })
1341         );
1342       });
1343     return promise;
1344   }
1345 
1346   buildPath(fn, args, state) {
1347     const { pathMinMax: minMax, pathBuffer } = state;
1348     switch (fn | 0) {
1349       case OPS.rectangle: {
1350         const x = (state.currentPointX = args[0]);
1351         const y = (state.currentPointY = args[1]);
1352         const width = args[2];
1353         const height = args[3];
1354         const xw = x + width;
1355         const yh = y + height;
1356         if (width === 0 || height === 0) {
1357           pathBuffer.push(
1358             DrawOPS.moveTo,
1359             x,
1360             y,
1361             DrawOPS.lineTo,
1362             xw,
1363             yh,
1364             DrawOPS.closePath
1365           );
1366         } else {
1367           pathBuffer.push(
1368             DrawOPS.moveTo,
1369             x,
1370             y,
1371             DrawOPS.lineTo,
1372             xw,
1373             y,
1374             DrawOPS.lineTo,
1375             xw,
1376             yh,
1377             DrawOPS.lineTo,
1378             x,
1379             yh,
1380             DrawOPS.closePath
1381           );
1382         }
1383         Util.rectBoundingBox(x, y, xw, yh, minMax);
1384         break;
1385       }
1386       case OPS.moveTo: {
1387         const x = (state.currentPointX = args[0]);
1388         const y = (state.currentPointY = args[1]);
1389         pathBuffer.push(DrawOPS.moveTo, x, y);
1390         Util.pointBoundingBox(x, y, minMax);
1391         break;
1392       }
1393       case OPS.lineTo: {
1394         const x = (state.currentPointX = args[0]);
1395         const y = (state.currentPointY = args[1]);
1396         pathBuffer.push(DrawOPS.lineTo, x, y);
1397         Util.pointBoundingBox(x, y, minMax);
1398         break;
1399       }
1400       case OPS.curveTo: {
1401         const startX = state.currentPointX;
1402         const startY = state.currentPointY;
1403         const [x1, y1, x2, y2, x, y] = args;
1404         state.currentPointX = x;
1405         state.currentPointY = y;
1406         pathBuffer.push(DrawOPS.curveTo, x1, y1, x2, y2, x, y);
1407         Util.bezierBoundingBox(startX, startY, x1, y1, x2, y2, x, y, minMax);
1408         break;
1409       }
1410       case OPS.curveTo2: {
1411         const startX = state.currentPointX;
1412         const startY = state.currentPointY;
1413         const [x1, y1, x, y] = args;
1414         state.currentPointX = x;
1415         state.currentPointY = y;
1416         pathBuffer.push(DrawOPS.curveTo, startX, startY, x1, y1, x, y);
1417         Util.bezierBoundingBox(
1418           startX,
1419           startY,
1420           startX,
1421           startY,
1422           x1,
1423           y1,
1424           x,
1425           y,
1426           minMax
1427         );
1428         break;
1429       }
1430       case OPS.curveTo3: {
1431         const startX = state.currentPointX;
1432         const startY = state.currentPointY;
1433         const [x1, y1, x, y] = args;
1434         state.currentPointX = x;
1435         state.currentPointY = y;
1436         pathBuffer.push(DrawOPS.curveTo, x1, y1, x, y, x, y);
1437         Util.bezierBoundingBox(startX, startY, x1, y1, x, y, x, y, minMax);
1438         break;
1439       }
1440       case OPS.closePath:
1441         pathBuffer.push(DrawOPS.closePath);
1442         break;
1443     }
1444   }
1445 
1446   _getColorSpace(cs, resources, localColorSpaceCache) {
1447     return ColorSpaceUtils.parse({
1448       cs,
1449       xref: this.xref,
1450       resources,
1451       pdfFunctionFactory: this._pdfFunctionFactory,
1452       globalColorSpaceCache: this.globalColorSpaceCache,
1453       localColorSpaceCache,
1454       asyncIfNotCached: true,
1455     });
1456   }
1457 
1458   async _handleColorSpace(csPromise) {
1459     try {
1460       return await csPromise;
1461     } catch (ex) {
1462       if (ex instanceof AbortException) {
1463         return null;
1464       }
1465       if (this.options.ignoreErrors) {
1466         warn(`_handleColorSpace - ignoring ColorSpace: "${ex}".`);
1467         return null;
1468       }
1469       throw ex;
1470     }
1471   }
1472 
1473   parseShading({
1474     shading,
1475     resources,
1476     localColorSpaceCache,
1477     localShadingPatternCache,
1478   }) {
1479     // Shadings and patterns may be referenced by the same name but the resource
1480     // dictionary could be different so we can't use the name for the cache key.
1481     let id = localShadingPatternCache.get(shading);
1482     if (id) {
1483       return id;
1484     }
1485     let patternIR;
1486 
1487     try {
1488       const shadingFill = Pattern.parseShading(
1489         shading,
1490         this.xref,
1491         resources,
1492         this._pdfFunctionFactory,
1493         this.globalColorSpaceCache,
1494         localColorSpaceCache
1495       );
1496       patternIR = shadingFill.getIR();
1497     } catch (reason) {
1498       if (reason instanceof AbortException) {
1499         return null;
1500       }
1501       if (this.options.ignoreErrors) {
1502         warn(`parseShading - ignoring shading: "${reason}".`);
1503 
1504         localShadingPatternCache.set(shading, null);
1505         return null;
1506       }
1507       throw reason;
1508     }
1509 
1510     id = `pattern_${this.idFactory.createObjId()}`;
1511     if (this.parsingType3Font) {
1512       id = `${this.idFactory.getDocId()}_type3_${id}`;
1513     }
1514     localShadingPatternCache.set(shading, id);
1515 
1516     if (this.parsingType3Font) {
1517       this.handler.send("commonobj", [id, "Pattern", patternIR]);
1518     } else {
1519       this.handler.send("obj", [id, this.pageIndex, "Pattern", patternIR]);
1520     }
1521     return id;
1522   }
1523 
1524   handleColorN(
1525     operatorList,
1526     fn,
1527     args,
1528     cs,
1529     patterns,
1530     resources,
1531     task,
1532     localColorSpaceCache,
1533     localTilingPatternCache,
1534     localShadingPatternCache
1535   ) {
1536     // compile tiling patterns
1537     const patternName = args.pop();
1538     // SCN/scn applies patterns along with normal colors
1539     if (patternName instanceof Name) {
1540       const rawPattern = patterns.getRaw(patternName.name);
1541 
1542       const localTilingPattern =
1543         rawPattern instanceof Ref &&
1544         localTilingPatternCache.getByRef(rawPattern);
1545       if (localTilingPattern) {
1546         try {
1547           const color = cs.base ? cs.base.getRgb(args, 0) : null;
1548           const tilingPatternIR = getTilingPatternIR(
1549             localTilingPattern.operatorListIR,
1550             localTilingPattern.dict,
1551             color
1552           );
1553           operatorList.addOp(fn, tilingPatternIR);
1554           return undefined;
1555         } catch {
1556           // Handle any errors during normal TilingPattern parsing.
1557         }
1558       }
1559 
1560       const pattern = this.xref.fetchIfRef(rawPattern);
1561       if (pattern) {
1562         const dict = pattern instanceof BaseStream ? pattern.dict : pattern;
1563         const typeNum = dict.get("PatternType");
1564 
1565         if (typeNum === PatternType.TILING) {
1566           const color = cs.base ? cs.base.getRgb(args, 0) : null;
1567           return this.handleTilingType(
1568             fn,
1569             color,
1570             resources,
1571             pattern,
1572             dict,
1573             operatorList,
1574             task,
1575             localTilingPatternCache
1576           );
1577         } else if (typeNum === PatternType.SHADING) {
1578           const shading = dict.get("Shading");
1579           const objId = this.parseShading({
1580             shading,
1581             resources,
1582             localColorSpaceCache,
1583             localShadingPatternCache,
1584           });
1585           if (objId) {
1586             const matrix = lookupMatrix(dict.getArray("Matrix"), null);
1587             operatorList.addOp(fn, ["Shading", objId, matrix]);
1588           }
1589           return undefined;
1590         }
1591         throw new FormatError(`Unknown PatternType: ${typeNum}`);
1592       }
1593     }
1594     throw new FormatError(`Unknown PatternName: ${patternName}`);
1595   }
1596 
1597   _parseVisibilityExpression(array, nestingCounter, currentResult) {
1598     const MAX_NESTING = 10;
1599     if (++nestingCounter > MAX_NESTING) {
1600       warn("Visibility expression is too deeply nested");
1601       return;
1602     }
1603     const length = array.length;
1604     const operator = this.xref.fetchIfRef(array[0]);
1605     if (length < 2 || !(operator instanceof Name)) {
1606       warn("Invalid visibility expression");
1607       return;
1608     }
1609     switch (operator.name) {
1610       case "And":
1611       case "Or":
1612       case "Not":
1613         currentResult.push(operator.name);
1614         break;
1615       default:
1616         warn(`Invalid operator ${operator.name} in visibility expression`);
1617         return;
1618     }
1619     for (let i = 1; i < length; i++) {
1620       const raw = array[i];
1621       const object = this.xref.fetchIfRef(raw);
1622       if (Array.isArray(object)) {
1623         const nestedResult = [];
1624         currentResult.push(nestedResult);
1625         // Recursively parse a subarray.
1626         this._parseVisibilityExpression(object, nestingCounter, nestedResult);
1627       } else if (raw instanceof Ref) {
1628         // Reference to an OCG dictionary.
1629         currentResult.push(raw.toString());
1630       }
1631     }
1632   }
1633 
1634   async parseMarkedContentProps(contentProperties, resources) {
1635     let optionalContent;
1636     if (contentProperties instanceof Name) {
1637       const properties = resources.get("Properties");
1638       optionalContent = properties.get(contentProperties.name);
1639     } else if (contentProperties instanceof Dict) {
1640       optionalContent = contentProperties;
1641     } else {
1642       throw new FormatError("Optional content properties malformed.");
1643     }
1644 
1645     const optionalContentType = optionalContent.get("Type")?.name;
1646     if (optionalContentType === "OCG") {
1647       return {
1648         type: optionalContentType,
1649         id: optionalContent.objId,
1650       };
1651     } else if (optionalContentType === "OCMD") {
1652       const expression = optionalContent.get("VE");
1653       if (Array.isArray(expression)) {
1654         const result = [];
1655         this._parseVisibilityExpression(expression, 0, result);
1656         if (result.length > 0) {
1657           return {
1658             type: "OCMD",
1659             expression: result,
1660           };
1661         }
1662       }
1663 
1664       const optionalContentGroups = optionalContent.get("OCGs");
1665       if (
1666         Array.isArray(optionalContentGroups) ||
1667         optionalContentGroups instanceof Dict
1668       ) {
1669         const groupIds = [];
1670         if (Array.isArray(optionalContentGroups)) {
1671           for (const ocg of optionalContentGroups) {
1672             groupIds.push(ocg.toString());
1673           }
1674         } else {
1675           // Dictionary, just use the obj id.
1676           groupIds.push(optionalContentGroups.objId);
1677         }
1678 
1679         return {
1680           type: optionalContentType,
1681           ids: groupIds,
1682           policy:
1683             optionalContent.get("P") instanceof Name
1684               ? optionalContent.get("P").name
1685               : null,
1686           expression: null,
1687         };
1688       } else if (optionalContentGroups instanceof Ref) {
1689         return {
1690           type: optionalContentType,
1691           id: optionalContentGroups.toString(),
1692         };
1693       }
1694     }
1695     return null;
1696   }
1697 
1698   getOperatorList({
1699     stream,
1700     task,
1701     resources,
1702     operatorList,
1703     initialState = null,
1704     fallbackFontDict = null,
1705     prevRefs = null,
1706   }) {
1707     const objId = stream.dict?.objId;
1708     const seenRefs = new RefSet(prevRefs);
1709 
1710     if (objId) {
1711       if (prevRefs?.has(objId)) {
1712         throw new Error(
1713           `getOperatorList - ignoring circular reference: ${objId}`
1714         );
1715       }
1716       seenRefs.put(objId);
1717     }
1718     // Ensure that `resources`/`initialState` is correctly initialized,
1719     // even if the provided parameter is e.g. `null`.
1720     resources ||= Dict.empty;
1721     initialState ||= new EvalState();
1722 
1723     if (!operatorList) {
1724       throw new Error('getOperatorList: missing "operatorList" parameter');
1725     }
1726 
1727     const self = this;
1728     const xref = this.xref;
1729     const localImageCache = new LocalImageCache();
1730     const localColorSpaceCache = new LocalColorSpaceCache();
1731     const localGStateCache = new LocalGStateCache();
1732     const localTilingPatternCache = new LocalTilingPatternCache();
1733     const localShadingPatternCache = new Map();
1734 
1735     const xobjs = resources.get("XObject") || Dict.empty;
1736     const patterns = resources.get("Pattern") || Dict.empty;
1737     const stateManager = new StateManager(initialState);
1738     const preprocessor = new EvaluatorPreprocessor(stream, xref, stateManager);
1739     const timeSlotManager = new TimeSlotManager();
1740 
1741     function closePendingRestoreOPS(argument) {
1742       for (let i = 0, ii = preprocessor.savedStatesDepth; i < ii; i++) {
1743         operatorList.addOp(OPS.restore, []);
1744       }
1745     }
1746 
1747     return new Promise(function promiseBody(resolve, reject) {
1748       const next = function (promise) {
1749         Promise.all([promise, operatorList.ready]).then(function () {
1750           try {
1751             promiseBody(resolve, reject);
1752           } catch (ex) {
1753             reject(ex);
1754           }
1755         }, reject);
1756       };
1757       task.ensureNotTerminated();
1758       timeSlotManager.reset();
1759 
1760       const operation = {};
1761       let stop, i, ii, cs, name, isValidName;
1762       while (!(stop = timeSlotManager.check())) {
1763         // The arguments parsed by read() are used beyond this loop, so we
1764         // cannot reuse the same array on each iteration. Therefore we pass
1765         // in |null| as the initial value (see the comment on
1766         // EvaluatorPreprocessor_read() for why).
1767         operation.args = null;
1768         if (!preprocessor.read(operation)) {
1769           break;
1770         }
1771         let args = operation.args;
1772         let fn = operation.fn;
1773 
1774         switch (fn | 0) {
1775           case OPS.paintXObject:
1776             // eagerly compile XForm objects
1777             isValidName = args[0] instanceof Name;
1778             name = args[0].name;
1779 
1780             if (isValidName) {
1781               const localImage = localImageCache.getByName(name);
1782               if (localImage) {
1783                 addCachedImageOps(operatorList, localImage);
1784                 args = null;
1785                 continue;
1786               }
1787             }
1788 
1789             next(
1790               new Promise(function (resolveXObject, rejectXObject) {
1791                 if (!isValidName) {
1792                   throw new FormatError("XObject must be referred to by name.");
1793                 }
1794 
1795                 let xobj = xobjs.getRaw(name);
1796                 if (xobj instanceof Ref) {
1797                   const cachedImage =
1798                     localImageCache.getByRef(xobj) ||
1799                     self._regionalImageCache.getByRef(xobj) ||
1800                     self.globalImageCache.getData(xobj, self.pageIndex);
1801                   if (cachedImage) {
1802                     addCachedImageOps(operatorList, cachedImage);
1803                     resolveXObject();
1804                     return;
1805                   }
1806 
1807                   xobj = xref.fetch(xobj);
1808                 }
1809 
1810                 if (!(xobj instanceof BaseStream)) {
1811                   throw new FormatError("XObject should be a stream");
1812                 }
1813 
1814                 const type = xobj.dict.get("Subtype");
1815                 if (!(type instanceof Name)) {
1816                   throw new FormatError("XObject should have a Name subtype");
1817                 }
1818 
1819                 if (type.name === "Form") {
1820                   stateManager.save();
1821                   self
1822                     .buildFormXObject(
1823                       resources,
1824                       xobj,
1825                       null,
1826                       operatorList,
1827                       task,
1828                       stateManager.state.clone({ newPath: true }),
1829                       localColorSpaceCache,
1830                       seenRefs
1831                     )
1832                     .then(function () {
1833                       stateManager.restore();
1834                       resolveXObject();
1835                     }, rejectXObject);
1836                   return;
1837                 } else if (type.name === "Image") {
1838                   self
1839                     .buildPaintImageXObject({
1840                       resources,
1841                       image: xobj,
1842                       operatorList,
1843                       cacheKey: name,
1844                       localImageCache,
1845                       localColorSpaceCache,
1846                     })
1847                     .then(resolveXObject, rejectXObject);
1848                   return;
1849                 } else if (type.name === "PS") {
1850                   // PostScript XObjects are unused when viewing documents.
1851                   // See section 4.7.1 of Adobe's PDF reference.
1852                   info("Ignored XObject subtype PS");
1853                 } else {
1854                   throw new FormatError(
1855                     `Unhandled XObject subtype ${type.name}`
1856                   );
1857                 }
1858                 resolveXObject();
1859               }).catch(function (reason) {
1860                 if (reason instanceof AbortException) {
1861                   return;
1862                 }
1863                 if (self.options.ignoreErrors) {
1864                   warn(`getOperatorList - ignoring XObject: "${reason}".`);
1865                   return;
1866                 }
1867                 throw reason;
1868               })
1869             );
1870             return;
1871           case OPS.setFont:
1872             const fontSize = args[1];
1873             // eagerly collect all fonts
1874             next(
1875               self
1876                 .handleSetFont(
1877                   resources,
1878                   args,
1879                   null,
1880                   operatorList,
1881                   task,
1882                   stateManager.state,
1883                   fallbackFontDict
1884                 )
1885                 .then(function (loadedName) {
1886                   operatorList.addDependency(loadedName);
1887                   operatorList.addOp(OPS.setFont, [loadedName, fontSize]);
1888                 })
1889             );
1890             return;
1891           case OPS.endInlineImage:
1892             const cacheKey = args[0].cacheKey;
1893             if (cacheKey) {
1894               const localImage = localImageCache.getByName(cacheKey);
1895               if (localImage) {
1896                 addCachedImageOps(operatorList, localImage);
1897                 args = null;
1898                 continue;
1899               }
1900             }
1901             next(
1902               self.buildPaintImageXObject({
1903                 resources,
1904                 image: args[0],
1905                 isInline: true,
1906                 operatorList,
1907                 cacheKey,
1908                 localImageCache,
1909                 localColorSpaceCache,
1910               })
1911             );
1912             return;
1913           case OPS.showText:
1914             if (!stateManager.state.font) {
1915               self.ensureStateFont(stateManager.state);
1916               continue;
1917             }
1918             args[0] = self.handleText(args[0], stateManager.state);
1919             break;
1920           case OPS.showSpacedText:
1921             if (!stateManager.state.font) {
1922               self.ensureStateFont(stateManager.state);
1923               continue;
1924             }
1925             const combinedGlyphs = [],
1926               state = stateManager.state;
1927             for (const arrItem of args[0]) {
1928               if (typeof arrItem === "string") {
1929                 combinedGlyphs.push(...self.handleText(arrItem, state));
1930               } else if (typeof arrItem === "number") {
1931                 combinedGlyphs.push(arrItem);
1932               }
1933             }
1934             args[0] = combinedGlyphs;
1935             fn = OPS.showText;
1936             break;
1937           case OPS.nextLineShowText:
1938             if (!stateManager.state.font) {
1939               self.ensureStateFont(stateManager.state);
1940               continue;
1941             }
1942             operatorList.addOp(OPS.nextLine);
1943             args[0] = self.handleText(args[0], stateManager.state);
1944             fn = OPS.showText;
1945             break;
1946           case OPS.nextLineSetSpacingShowText:
1947             if (!stateManager.state.font) {
1948               self.ensureStateFont(stateManager.state);
1949               continue;
1950             }
1951             operatorList.addOp(OPS.nextLine);
1952             operatorList.addOp(OPS.setWordSpacing, [args.shift()]);
1953             operatorList.addOp(OPS.setCharSpacing, [args.shift()]);
1954             args[0] = self.handleText(args[0], stateManager.state);
1955             fn = OPS.showText;
1956             break;
1957           case OPS.setTextRenderingMode:
1958             stateManager.state.textRenderingMode = args[0];
1959             break;
1960 
1961           case OPS.setFillColorSpace: {
1962             const fillCS = self._getColorSpace(
1963               args[0],
1964               resources,
1965               localColorSpaceCache
1966             );
1967             if (fillCS instanceof ColorSpace) {
1968               stateManager.state.fillColorSpace = fillCS;
1969               continue;
1970             }
1971 
1972             next(
1973               self._handleColorSpace(fillCS).then(colorSpace => {
1974                 stateManager.state.fillColorSpace =
1975                   colorSpace || ColorSpaceUtils.gray;
1976               })
1977             );
1978             return;
1979           }
1980           case OPS.setStrokeColorSpace: {
1981             const strokeCS = self._getColorSpace(
1982               args[0],
1983               resources,
1984               localColorSpaceCache
1985             );
1986             if (strokeCS instanceof ColorSpace) {
1987               stateManager.state.strokeColorSpace = strokeCS;
1988               continue;
1989             }
1990 
1991             next(
1992               self._handleColorSpace(strokeCS).then(colorSpace => {
1993                 stateManager.state.strokeColorSpace =
1994                   colorSpace || ColorSpaceUtils.gray;
1995               })
1996             );
1997             return;
1998           }
1999           case OPS.setFillColor:
2000             cs = stateManager.state.fillColorSpace;
2001             args = cs.getRgb(args, 0);
2002             fn = OPS.setFillRGBColor;
2003             break;
2004           case OPS.setStrokeColor:
2005             cs = stateManager.state.strokeColorSpace;
2006             args = cs.getRgb(args, 0);
2007             fn = OPS.setStrokeRGBColor;
2008             break;
2009           case OPS.setFillGray:
2010             stateManager.state.fillColorSpace = ColorSpaceUtils.gray;
2011             args = ColorSpaceUtils.gray.getRgb(args, 0);
2012             fn = OPS.setFillRGBColor;
2013             break;
2014           case OPS.setStrokeGray:
2015             stateManager.state.strokeColorSpace = ColorSpaceUtils.gray;
2016             args = ColorSpaceUtils.gray.getRgb(args, 0);
2017             fn = OPS.setStrokeRGBColor;
2018             break;
2019           case OPS.setFillCMYKColor:
2020             stateManager.state.fillColorSpace = ColorSpaceUtils.cmyk;
2021             args = ColorSpaceUtils.cmyk.getRgb(args, 0);
2022             fn = OPS.setFillRGBColor;
2023             break;
2024           case OPS.setStrokeCMYKColor:
2025             stateManager.state.strokeColorSpace = ColorSpaceUtils.cmyk;
2026             args = ColorSpaceUtils.cmyk.getRgb(args, 0);
2027             fn = OPS.setStrokeRGBColor;
2028             break;
2029           case OPS.setFillRGBColor:
2030             stateManager.state.fillColorSpace = ColorSpaceUtils.rgb;
2031             args = ColorSpaceUtils.rgb.getRgb(args, 0);
2032             break;
2033           case OPS.setStrokeRGBColor:
2034             stateManager.state.strokeColorSpace = ColorSpaceUtils.rgb;
2035             args = ColorSpaceUtils.rgb.getRgb(args, 0);
2036             break;
2037           case OPS.setFillColorN:
2038             cs = stateManager.state.patternFillColorSpace;
2039             if (!cs) {
2040               if (isNumberArray(args, null)) {
2041                 args = ColorSpaceUtils.gray.getRgb(args, 0);
2042                 fn = OPS.setFillRGBColor;
2043                 break;
2044               }
2045               args = [];
2046               fn = OPS.setFillTransparent;
2047               break;
2048             }
2049             if (cs.name === "Pattern") {
2050               next(
2051                 self.handleColorN(
2052                   operatorList,
2053                   OPS.setFillColorN,
2054                   args,
2055                   cs,
2056                   patterns,
2057                   resources,
2058                   task,
2059                   localColorSpaceCache,
2060                   localTilingPatternCache,
2061                   localShadingPatternCache
2062                 )
2063               );
2064               return;
2065             }
2066             args = cs.getRgb(args, 0);
2067             fn = OPS.setFillRGBColor;
2068             break;
2069           case OPS.setStrokeColorN:
2070             cs = stateManager.state.patternStrokeColorSpace;
2071             if (!cs) {
2072               if (isNumberArray(args, null)) {
2073                 args = ColorSpaceUtils.gray.getRgb(args, 0);
2074                 fn = OPS.setStrokeRGBColor;
2075                 break;
2076               }
2077               args = [];
2078               fn = OPS.setStrokeTransparent;
2079               break;
2080             }
2081             if (cs.name === "Pattern") {
2082               next(
2083                 self.handleColorN(
2084                   operatorList,
2085                   OPS.setStrokeColorN,
2086                   args,
2087                   cs,
2088                   patterns,
2089                   resources,
2090                   task,
2091                   localColorSpaceCache,
2092                   localTilingPatternCache,
2093                   localShadingPatternCache
2094                 )
2095               );
2096               return;
2097             }
2098             args = cs.getRgb(args, 0);
2099             fn = OPS.setStrokeRGBColor;
2100             break;
2101 
2102           case OPS.shadingFill:
2103             let shading;
2104             try {
2105               const shadingRes = resources.get("Shading");
2106               if (!shadingRes) {
2107                 throw new FormatError("No shading resource found");
2108               }
2109 
2110               shading = shadingRes.get(args[0].name);
2111               if (!shading) {
2112                 throw new FormatError("No shading object found");
2113               }
2114             } catch (reason) {
2115               if (reason instanceof AbortException) {
2116                 continue;
2117               }
2118               if (self.options.ignoreErrors) {
2119                 warn(`getOperatorList - ignoring Shading: "${reason}".`);
2120                 continue;
2121               }
2122               throw reason;
2123             }
2124             const patternId = self.parseShading({
2125               shading,
2126               resources,
2127               localColorSpaceCache,
2128               localShadingPatternCache,
2129             });
2130             if (!patternId) {
2131               continue;
2132             }
2133             args = [patternId];
2134             fn = OPS.shadingFill;
2135             break;
2136           case OPS.setGState:
2137             isValidName = args[0] instanceof Name;
2138             name = args[0].name;
2139 
2140             if (isValidName) {
2141               const localGStateObj = localGStateCache.getByName(name);
2142               if (localGStateObj) {
2143                 if (localGStateObj.length > 0) {
2144                   operatorList.addOp(OPS.setGState, [localGStateObj]);
2145                 }
2146                 args = null;
2147                 continue;
2148               }
2149             }
2150 
2151             next(
2152               new Promise(function (resolveGState, rejectGState) {
2153                 if (!isValidName) {
2154                   throw new FormatError("GState must be referred to by name.");
2155                 }
2156 
2157                 const extGState = resources.get("ExtGState");
2158                 if (!(extGState instanceof Dict)) {
2159                   throw new FormatError("ExtGState should be a dictionary.");
2160                 }
2161 
2162                 const gState = extGState.get(name);
2163                 // TODO: Attempt to lookup cached GStates by reference as well,
2164                 //       if and only if there are PDF documents where doing so
2165                 //       would significantly improve performance.
2166                 if (!(gState instanceof Dict)) {
2167                   throw new FormatError("GState should be a dictionary.");
2168                 }
2169 
2170                 self
2171                   .setGState({
2172                     resources,
2173                     gState,
2174                     operatorList,
2175                     cacheKey: name,
2176                     task,
2177                     stateManager,
2178                     localGStateCache,
2179                     localColorSpaceCache,
2180                     seenRefs,
2181                   })
2182                   .then(resolveGState, rejectGState);
2183               }).catch(function (reason) {
2184                 if (reason instanceof AbortException) {
2185                   return;
2186                 }
2187                 if (self.options.ignoreErrors) {
2188                   warn(`getOperatorList - ignoring ExtGState: "${reason}".`);
2189                   return;
2190                 }
2191                 throw reason;
2192               })
2193             );
2194             return;
2195           case OPS.setLineWidth: {
2196             // The thickness should be a non-negative number, as per spec.
2197             // When the value is negative, Acrobat and Poppler take the absolute
2198             // value while PDFium takes the max of 0 and the value.
2199             const [thickness] = args;
2200             if (typeof thickness !== "number") {
2201               warn(`Invalid setLineWidth: ${thickness}`);
2202               continue;
2203             }
2204             args[0] = Math.abs(thickness);
2205             break;
2206           }
2207           case OPS.moveTo:
2208           case OPS.lineTo:
2209           case OPS.curveTo:
2210           case OPS.curveTo2:
2211           case OPS.curveTo3:
2212           case OPS.closePath:
2213           case OPS.rectangle:
2214             self.buildPath(fn, args, stateManager.state);
2215             continue;
2216           case OPS.stroke:
2217           case OPS.closeStroke:
2218           case OPS.fill:
2219           case OPS.eoFill:
2220           case OPS.fillStroke:
2221           case OPS.eoFillStroke:
2222           case OPS.closeFillStroke:
2223           case OPS.closeEOFillStroke:
2224           case OPS.endPath: {
2225             const {
2226               state: { pathBuffer, pathMinMax },
2227             } = stateManager;
2228             if (
2229               fn === OPS.closeStroke ||
2230               fn === OPS.closeFillStroke ||
2231               fn === OPS.closeEOFillStroke
2232             ) {
2233               pathBuffer.push(DrawOPS.closePath);
2234             }
2235             if (pathBuffer.length === 0) {
2236               operatorList.addOp(OPS.constructPath, [fn, [null], null]);
2237             } else {
2238               operatorList.addOp(OPS.constructPath, [
2239                 fn,
2240                 [new Float32Array(pathBuffer)],
2241                 pathMinMax.slice(),
2242               ]);
2243               pathBuffer.length = 0;
2244               pathMinMax.set([Infinity, Infinity, -Infinity, -Infinity], 0);
2245             }
2246             continue;
2247           }
2248           case OPS.setTextMatrix:
2249             operatorList.addOp(fn, [new Float32Array(args)]);
2250             continue;
2251           case OPS.markPoint:
2252           case OPS.markPointProps:
2253           case OPS.beginCompat:
2254           case OPS.endCompat:
2255             // Ignore operators where the corresponding handlers are known to
2256             // be no-op in CanvasGraphics (display/canvas.js). This prevents
2257             // serialization errors and is also a bit more efficient.
2258             // We could also try to serialize all objects in a general way,
2259             // e.g. as done in https://github.com/mozilla/pdf.js/pull/6266,
2260             // but doing so is meaningless without knowing the semantics.
2261             continue;
2262           case OPS.beginMarkedContentProps:
2263             if (!(args[0] instanceof Name)) {
2264               warn(`Expected name for beginMarkedContentProps arg0=${args[0]}`);
2265               operatorList.addOp(OPS.beginMarkedContentProps, ["OC", null]);
2266               continue;
2267             }
2268             if (args[0].name === "OC") {
2269               next(
2270                 self
2271                   .parseMarkedContentProps(args[1], resources)
2272                   .then(data => {
2273                     operatorList.addOp(OPS.beginMarkedContentProps, [
2274                       "OC",
2275                       data,
2276                     ]);
2277                   })
2278                   .catch(reason => {
2279                     if (reason instanceof AbortException) {
2280                       return;
2281                     }
2282                     if (self.options.ignoreErrors) {
2283                       warn(
2284                         `getOperatorList - ignoring beginMarkedContentProps: "${reason}".`
2285                       );
2286                       operatorList.addOp(OPS.beginMarkedContentProps, [
2287                         "OC",
2288                         null,
2289                       ]);
2290                       return;
2291                     }
2292                     throw reason;
2293                   })
2294               );
2295               return;
2296             }
2297             // Other marked content types aren't supported yet.
2298             args = [
2299               args[0].name,
2300               args[1] instanceof Dict ? args[1].get("MCID") : null,
2301             ];
2302 
2303             break;
2304           case OPS.beginMarkedContent:
2305           case OPS.endMarkedContent:
2306           default:
2307             // Note: Ignore the operator if it has `Dict` arguments, since
2308             // those are non-serializable, otherwise postMessage will throw
2309             // "An object could not be cloned.".
2310             if (args !== null) {
2311               for (i = 0, ii = args.length; i < ii; i++) {
2312                 if (args[i] instanceof Dict) {
2313                   break;
2314                 }
2315               }
2316               if (i < ii) {
2317                 warn("getOperatorList - ignoring operator: " + fn);
2318                 continue;
2319               }
2320             }
2321         }
2322         operatorList.addOp(fn, args);
2323       }
2324       if (stop) {
2325         next(deferred);
2326         return;
2327       }
2328       // Some PDFs don't close all restores inside object/form.
2329       // Closing those for them.
2330       closePendingRestoreOPS();
2331       resolve();
2332     }).catch(reason => {
2333       if (reason instanceof AbortException) {
2334         return;
2335       }
2336       if (this.options.ignoreErrors) {
2337         warn(
2338           `getOperatorList - ignoring errors during "${task.name}" ` +
2339             `task: "${reason}".`
2340         );
2341 
2342         closePendingRestoreOPS();
2343         return;
2344       }
2345       throw reason;
2346     });
2347   }
2348 
2349   getTextContent({
2350     stream,
2351     task,
2352     resources,
2353     stateManager = null,
2354     includeMarkedContent = false,
2355     sink,
2356     seenStyles = new Set(),
2357     viewBox,
2358     lang = null,
2359     markedContentData = null,
2360     disableNormalization = false,
2361     keepWhiteSpace = false,
2362     prevRefs = null,
2363   }) {
2364     const objId = stream.dict?.objId;
2365     const seenRefs = new RefSet(prevRefs);
2366 
2367     if (objId) {
2368       if (prevRefs?.has(objId)) {
2369         throw new Error(
2370           `getTextContent - ignoring circular reference: ${objId}`
2371         );
2372       }
2373       seenRefs.put(objId);
2374     }
2375     // Ensure that `resources`/`stateManager` is correctly initialized,
2376     // even if the provided parameter is e.g. `null`.
2377     resources ||= Dict.empty;
2378     stateManager ||= new StateManager(new TextState());
2379 
2380     if (includeMarkedContent) {
2381       markedContentData ||= { level: 0 };
2382     }
2383 
2384     const textContent = {
2385       items: [],
2386       styles: Object.create(null),
2387       lang,
2388     };
2389     const textContentItem = {
2390       initialized: false,
2391       str: [],
2392       totalWidth: 0,
2393       totalHeight: 0,
2394       width: 0,
2395       height: 0,
2396       vertical: false,
2397       prevTransform: null,
2398       textAdvanceScale: 0,
2399       spaceInFlowMin: 0,
2400       spaceInFlowMax: 0,
2401       trackingSpaceMin: Infinity,
2402       negativeSpaceMax: -Infinity,
2403       notASpace: -Infinity,
2404       transform: null,
2405       fontName: null,
2406       hasEOL: false,
2407     };
2408 
2409     // Use a circular buffer (length === 2) to save the last chars in the
2410     // text stream.
2411     // This implementation of the circular buffer is using a fixed array
2412     // and the position of the next element:
2413     // function addElement(x) {
2414     //   buffer[pos] = x;
2415     //   pos = (pos + 1) % buffer.length;
2416     // }
2417     // It's a way faster than:
2418     // function addElement(x) {
2419     //   buffer.push(x);
2420     //   buffer.shift();
2421     // }
2422     //
2423     // It's useful to know when we need to add a whitespace in the
2424     // text chunk.
2425     const twoLastChars = [" ", " "];
2426     let twoLastCharsPos = 0;
2427 
2428     /**
2429      * Save the last char.
2430      * @param {string} char
2431      * @returns {boolean} true when the two last chars before adding the new one
2432      * are a non-whitespace followed by a whitespace.
2433      */
2434     function saveLastChar(char) {
2435       const nextPos = (twoLastCharsPos + 1) % 2;
2436       const ret =
2437         twoLastChars[twoLastCharsPos] !== " " && twoLastChars[nextPos] === " ";
2438       twoLastChars[twoLastCharsPos] = char;
2439       twoLastCharsPos = nextPos;
2440 
2441       return !keepWhiteSpace && ret;
2442     }
2443 
2444     function shouldAddWhitepsace() {
2445       return (
2446         !keepWhiteSpace &&
2447         twoLastChars[twoLastCharsPos] !== " " &&
2448         twoLastChars[(twoLastCharsPos + 1) % 2] === " "
2449       );
2450     }
2451 
2452     function resetLastChars() {
2453       twoLastChars[0] = twoLastChars[1] = " ";
2454       twoLastCharsPos = 0;
2455     }
2456 
2457     // Used in addFakeSpaces.
2458 
2459     // A white <= fontSize * TRACKING_SPACE_FACTOR is a tracking space
2460     // so it doesn't count as a space.
2461     const TRACKING_SPACE_FACTOR = 0.102;
2462 
2463     // When a white <= fontSize * NOT_A_SPACE_FACTOR, there is no space
2464     // even if one is present in the text stream.
2465     const NOT_A_SPACE_FACTOR = 0.03;
2466 
2467     // A negative white < fontSize * NEGATIVE_SPACE_FACTOR induces
2468     // a break (a new chunk of text is created).
2469     // It doesn't change anything when the text is copied but
2470     // it improves potential mismatch between text layer and canvas.
2471     const NEGATIVE_SPACE_FACTOR = -0.2;
2472 
2473     // A white with a width in [fontSize * MIN_FACTOR; fontSize * MAX_FACTOR]
2474     // is a space which will be inserted in the current flow of words.
2475     // If the width is outside of this range then the flow is broken
2476     // (which means a new span in the text layer).
2477     // It's useful to adjust the best as possible the span in the layer
2478     // to what is displayed in the canvas.
2479     const SPACE_IN_FLOW_MIN_FACTOR = 0.102;
2480     const SPACE_IN_FLOW_MAX_FACTOR = 0.6;
2481 
2482     // If a char is too high/too low compared to the previous we just create
2483     // a new chunk.
2484     // If the advance isn't in the +/-VERTICAL_SHIFT_RATIO * height range then
2485     // a new chunk is created.
2486     const VERTICAL_SHIFT_RATIO = 0.25;
2487 
2488     const self = this;
2489     const xref = this.xref;
2490     const showSpacedTextBuffer = [];
2491 
2492     // The xobj is parsed iff it's needed, e.g. if there is a `DO` cmd.
2493     let xobjs = null;
2494     const emptyXObjectCache = new LocalImageCache();
2495     const emptyGStateCache = new LocalGStateCache();
2496 
2497     const preprocessor = new EvaluatorPreprocessor(stream, xref, stateManager);
2498 
2499     let textState;
2500 
2501     function pushWhitespace({
2502       width = 0,
2503       height = 0,
2504       transform = textContentItem.prevTransform,
2505       fontName = textContentItem.fontName,
2506     }) {
2507       textContent.items.push({
2508         str: " ",
2509         dir: "ltr",
2510         width,
2511         height,
2512         transform,
2513         fontName,
2514         hasEOL: false,
2515       });
2516     }
2517 
2518     function getCurrentTextTransform() {
2519       // 9.4.4 Text Space Details
2520       const font = textState.font;
2521       const tsm = [
2522         textState.fontSize * textState.textHScale,
2523         0,
2524         0,
2525         textState.fontSize,
2526         0,
2527         textState.textRise,
2528       ];
2529 
2530       if (
2531         font.isType3Font &&
2532         (textState.fontSize <= 1 || font.isCharBBox) &&
2533         !isArrayEqual(textState.fontMatrix, FONT_IDENTITY_MATRIX)
2534       ) {
2535         const glyphHeight = font.bbox[3] - font.bbox[1];
2536         if (glyphHeight > 0) {
2537           tsm[3] *= glyphHeight * textState.fontMatrix[3];
2538         }
2539       }
2540 
2541       return Util.transform(
2542         textState.ctm,
2543         Util.transform(textState.textMatrix, tsm)
2544       );
2545     }
2546 
2547     function ensureTextContentItem() {
2548       if (textContentItem.initialized) {
2549         return textContentItem;
2550       }
2551       const { font, loadedName } = textState;
2552       if (!seenStyles.has(loadedName)) {
2553         seenStyles.add(loadedName);
2554         textContent.styles[loadedName] = {
2555           fontFamily: font.fallbackName,
2556           ascent: font.ascent,
2557           descent: font.descent,
2558           vertical: font.vertical,
2559         };
2560         if (self.options.fontExtraProperties && font.systemFontInfo) {
2561           const style = textContent.styles[loadedName];
2562           style.fontSubstitution = font.systemFontInfo.css;
2563           style.fontSubstitutionLoadedName = font.systemFontInfo.loadedName;
2564         }
2565       }
2566       textContentItem.fontName = loadedName;
2567 
2568       const trm = (textContentItem.transform = getCurrentTextTransform());
2569       if (!font.vertical) {
2570         textContentItem.width = textContentItem.totalWidth = 0;
2571         textContentItem.height = textContentItem.totalHeight = Math.hypot(
2572           trm[2],
2573           trm[3]
2574         );
2575         textContentItem.vertical = false;
2576       } else {
2577         textContentItem.width = textContentItem.totalWidth = Math.hypot(
2578           trm[0],
2579           trm[1]
2580         );
2581         textContentItem.height = textContentItem.totalHeight = 0;
2582         textContentItem.vertical = true;
2583       }
2584 
2585       const scaleLineX = Math.hypot(
2586         textState.textLineMatrix[0],
2587         textState.textLineMatrix[1]
2588       );
2589       const scaleCtmX = Math.hypot(textState.ctm[0], textState.ctm[1]);
2590       textContentItem.textAdvanceScale = scaleCtmX * scaleLineX;
2591 
2592       const { fontSize } = textState;
2593       textContentItem.trackingSpaceMin = fontSize * TRACKING_SPACE_FACTOR;
2594       textContentItem.notASpace = fontSize * NOT_A_SPACE_FACTOR;
2595       textContentItem.negativeSpaceMax = fontSize * NEGATIVE_SPACE_FACTOR;
2596       textContentItem.spaceInFlowMin = fontSize * SPACE_IN_FLOW_MIN_FACTOR;
2597       textContentItem.spaceInFlowMax = fontSize * SPACE_IN_FLOW_MAX_FACTOR;
2598       textContentItem.hasEOL = false;
2599 
2600       textContentItem.initialized = true;
2601       return textContentItem;
2602     }
2603 
2604     function updateAdvanceScale() {
2605       if (!textContentItem.initialized) {
2606         return;
2607       }
2608 
2609       const scaleLineX = Math.hypot(
2610         textState.textLineMatrix[0],
2611         textState.textLineMatrix[1]
2612       );
2613       const scaleCtmX = Math.hypot(textState.ctm[0], textState.ctm[1]);
2614       const scaleFactor = scaleCtmX * scaleLineX;
2615       if (scaleFactor === textContentItem.textAdvanceScale) {
2616         return;
2617       }
2618 
2619       if (!textContentItem.vertical) {
2620         textContentItem.totalWidth +=
2621           textContentItem.width * textContentItem.textAdvanceScale;
2622         textContentItem.width = 0;
2623       } else {
2624         textContentItem.totalHeight +=
2625           textContentItem.height * textContentItem.textAdvanceScale;
2626         textContentItem.height = 0;
2627       }
2628 
2629       textContentItem.textAdvanceScale = scaleFactor;
2630     }
2631 
2632     function runBidiTransform(textChunk) {
2633       let text = textChunk.str.join("");
2634       if (!disableNormalization) {
2635         text = normalizeUnicode(text);
2636       }
2637       const bidiResult = bidi(text, -1, textChunk.vertical);
2638       return {
2639         str: bidiResult.str,
2640         dir: bidiResult.dir,
2641         width: Math.abs(textChunk.totalWidth),
2642         height: Math.abs(textChunk.totalHeight),
2643         transform: textChunk.transform,
2644         fontName: textChunk.fontName,
2645         hasEOL: textChunk.hasEOL,
2646       };
2647     }
2648 
2649     async function handleSetFont(fontName, fontRef) {
2650       const translated = await self.loadFont(
2651         fontName,
2652         fontRef,
2653         resources,
2654         task
2655       );
2656 
2657       textState.loadedName = translated.loadedName;
2658       textState.font = translated.font;
2659       textState.fontMatrix = translated.font.fontMatrix || FONT_IDENTITY_MATRIX;
2660     }
2661 
2662     function applyInverseRotation(x, y, matrix) {
2663       const scale = Math.hypot(matrix[0], matrix[1]);
2664       return [
2665         (matrix[0] * x + matrix[1] * y) / scale,
2666         (matrix[2] * x + matrix[3] * y) / scale,
2667       ];
2668     }
2669 
2670     function compareWithLastPosition(glyphWidth) {
2671       const currentTransform = getCurrentTextTransform();
2672       let posX = currentTransform[4];
2673       let posY = currentTransform[5];
2674 
2675       // Check if the glyph is in the viewbox.
2676       if (textState.font?.vertical) {
2677         if (
2678           posX < viewBox[0] ||
2679           posX > viewBox[2] ||
2680           posY + glyphWidth < viewBox[1] ||
2681           posY > viewBox[3]
2682         ) {
2683           return false;
2684         }
2685       } else if (
2686         posX + glyphWidth < viewBox[0] ||
2687         posX > viewBox[2] ||
2688         posY < viewBox[1] ||
2689         posY > viewBox[3]
2690       ) {
2691         return false;
2692       }
2693 
2694       if (!textState.font || !textContentItem.prevTransform) {
2695         return true;
2696       }
2697 
2698       let lastPosX = textContentItem.prevTransform[4];
2699       let lastPosY = textContentItem.prevTransform[5];
2700 
2701       if (lastPosX === posX && lastPosY === posY) {
2702         return true;
2703       }
2704 
2705       let rotate = -1;
2706       // Take into account the rotation is the current transform.
2707       if (
2708         currentTransform[0] &&
2709         currentTransform[1] === 0 &&
2710         currentTransform[2] === 0
2711       ) {
2712         rotate = currentTransform[0] > 0 ? 0 : 180;
2713       } else if (
2714         currentTransform[1] &&
2715         currentTransform[0] === 0 &&
2716         currentTransform[3] === 0
2717       ) {
2718         rotate = currentTransform[1] > 0 ? 90 : 270;
2719       }
2720 
2721       switch (rotate) {
2722         case 0:
2723           break;
2724         case 90:
2725           [posX, posY] = [posY, posX];
2726           [lastPosX, lastPosY] = [lastPosY, lastPosX];
2727           break;
2728         case 180:
2729           [posX, posY, lastPosX, lastPosY] = [
2730             -posX,
2731             -posY,
2732             -lastPosX,
2733             -lastPosY,
2734           ];
2735           break;
2736         case 270:
2737           [posX, posY] = [-posY, -posX];
2738           [lastPosX, lastPosY] = [-lastPosY, -lastPosX];
2739           break;
2740         default:
2741           // This is not a 0, 90, 180, 270 rotation so:
2742           //  - remove the scale factor from the matrix to get a rotation matrix
2743           //  - apply the inverse (which is the transposed) to the positions
2744           // and we can then compare positions of the glyphes to detect
2745           // a whitespace.
2746           [posX, posY] = applyInverseRotation(posX, posY, currentTransform);
2747           [lastPosX, lastPosY] = applyInverseRotation(
2748             lastPosX,
2749             lastPosY,
2750             textContentItem.prevTransform
2751           );
2752       }
2753 
2754       if (textState.font.vertical) {
2755         const advanceY = (lastPosY - posY) / textContentItem.textAdvanceScale;
2756         const advanceX = posX - lastPosX;
2757 
2758         // When the total height of the current chunk is negative
2759         // then we're writing from bottom to top.
2760         const textOrientation = Math.sign(textContentItem.height);
2761         if (advanceY < textOrientation * textContentItem.negativeSpaceMax) {
2762           if (
2763             Math.abs(advanceX) >
2764             0.5 * textContentItem.width /* not the same column */
2765           ) {
2766             appendEOL();
2767             return true;
2768           }
2769 
2770           resetLastChars();
2771           flushTextContentItem();
2772           return true;
2773         }
2774 
2775         if (Math.abs(advanceX) > textContentItem.width) {
2776           appendEOL();
2777           return true;
2778         }
2779 
2780         if (advanceY <= textOrientation * textContentItem.notASpace) {
2781           // The real spacing between 2 consecutive chars is thin enough to be
2782           // considered a non-space.
2783           resetLastChars();
2784         }
2785 
2786         if (advanceY <= textOrientation * textContentItem.trackingSpaceMin) {
2787           if (shouldAddWhitepsace()) {
2788             // The space is very thin, hence it deserves to have its own span in
2789             // order to avoid too much shift between the canvas and the text
2790             // layer.
2791             resetLastChars();
2792             flushTextContentItem();
2793             pushWhitespace({ height: Math.abs(advanceY) });
2794           } else {
2795             textContentItem.height += advanceY;
2796           }
2797         } else if (
2798           !addFakeSpaces(
2799             advanceY,
2800             textContentItem.prevTransform,
2801             textOrientation
2802           )
2803         ) {
2804           if (textContentItem.str.length === 0) {
2805             resetLastChars();
2806             pushWhitespace({ height: Math.abs(advanceY) });
2807           } else {
2808             textContentItem.height += advanceY;
2809           }
2810         }
2811 
2812         if (Math.abs(advanceX) > textContentItem.width * VERTICAL_SHIFT_RATIO) {
2813           flushTextContentItem();
2814         }
2815 
2816         return true;
2817       }
2818 
2819       const advanceX = (posX - lastPosX) / textContentItem.textAdvanceScale;
2820       const advanceY = posY - lastPosY;
2821 
2822       // When the total width of the current chunk is negative
2823       // then we're writing from right to left.
2824       const textOrientation = Math.sign(textContentItem.width);
2825       if (advanceX < textOrientation * textContentItem.negativeSpaceMax) {
2826         if (
2827           Math.abs(advanceY) >
2828           0.5 * textContentItem.height /* not the same line */
2829         ) {
2830           appendEOL();
2831           return true;
2832         }
2833 
2834         // We're moving back so in case the last char was a whitespace
2835         // we cancel it: it doesn't make sense to insert it.
2836         resetLastChars();
2837         flushTextContentItem();
2838         return true;
2839       }
2840 
2841       if (Math.abs(advanceY) > textContentItem.height) {
2842         appendEOL();
2843         return true;
2844       }
2845 
2846       if (advanceX <= textOrientation * textContentItem.notASpace) {
2847         // The real spacing between 2 consecutive chars is thin enough to be
2848         // considered a non-space.
2849         resetLastChars();
2850       }
2851 
2852       if (advanceX <= textOrientation * textContentItem.trackingSpaceMin) {
2853         if (shouldAddWhitepsace()) {
2854           // The space is very thin, hence it deserves to have its own span in
2855           // order to avoid too much shift between the canvas and the text
2856           // layer.
2857           resetLastChars();
2858           flushTextContentItem();
2859           pushWhitespace({ width: Math.abs(advanceX) });
2860         } else {
2861           textContentItem.width += advanceX;
2862         }
2863       } else if (
2864         !addFakeSpaces(advanceX, textContentItem.prevTransform, textOrientation)
2865       ) {
2866         if (textContentItem.str.length === 0) {
2867           resetLastChars();
2868           pushWhitespace({ width: Math.abs(advanceX) });
2869         } else {
2870           textContentItem.width += advanceX;
2871         }
2872       }
2873 
2874       if (Math.abs(advanceY) > textContentItem.height * VERTICAL_SHIFT_RATIO) {
2875         flushTextContentItem();
2876       }
2877 
2878       return true;
2879     }
2880 
2881     function buildTextContentItem({ chars, extraSpacing }) {
2882       const font = textState.font;
2883       if (!chars) {
2884         // Just move according to the space we have.
2885         const charSpacing = textState.charSpacing + extraSpacing;
2886         if (charSpacing) {
2887           if (!font.vertical) {
2888             textState.translateTextMatrix(
2889               charSpacing * textState.textHScale,
2890               0
2891             );
2892           } else {
2893             textState.translateTextMatrix(0, -charSpacing);
2894           }
2895         }
2896 
2897         if (keepWhiteSpace) {
2898           compareWithLastPosition(0);
2899         }
2900 
2901         return;
2902       }
2903 
2904       const glyphs = font.charsToGlyphs(chars);
2905       const scale = textState.fontMatrix[0] * textState.fontSize;
2906 
2907       for (let i = 0, ii = glyphs.length; i < ii; i++) {
2908         const glyph = glyphs[i];
2909         const { category } = glyph;
2910 
2911         if (category.isInvisibleFormatMark) {
2912           continue;
2913         }
2914         let charSpacing =
2915           textState.charSpacing + (i + 1 === ii ? extraSpacing : 0);
2916 
2917         let glyphWidth = glyph.width;
2918         if (font.vertical) {
2919           glyphWidth = glyph.vmetric ? glyph.vmetric[0] : -glyphWidth;
2920         }
2921         let scaledDim = glyphWidth * scale;
2922 
2923         if (!keepWhiteSpace && category.isWhitespace) {
2924           // Don't push a " " in the textContentItem
2925           // (except when it's between two non-spaces chars),
2926           // it will be done (if required) in next call to
2927           // compareWithLastPosition.
2928           // This way we can merge real spaces and spaces due to cursor moves.
2929           if (!font.vertical) {
2930             charSpacing += scaledDim + textState.wordSpacing;
2931             textState.translateTextMatrix(
2932               charSpacing * textState.textHScale,
2933               0
2934             );
2935           } else {
2936             charSpacing += -scaledDim + textState.wordSpacing;
2937             textState.translateTextMatrix(0, -charSpacing);
2938           }
2939           saveLastChar(" ");
2940           continue;
2941         }
2942 
2943         if (
2944           !category.isZeroWidthDiacritic &&
2945           !compareWithLastPosition(scaledDim)
2946         ) {
2947           // The glyph is not in page so just skip it but move the cursor.
2948           if (!font.vertical) {
2949             textState.translateTextMatrix(scaledDim * textState.textHScale, 0);
2950           } else {
2951             textState.translateTextMatrix(0, scaledDim);
2952           }
2953           continue;
2954         }
2955 
2956         // Must be called after compareWithLastPosition because
2957         // the textContentItem could have been flushed.
2958         const textChunk = ensureTextContentItem();
2959         if (category.isZeroWidthDiacritic) {
2960           scaledDim = 0;
2961         }
2962 
2963         if (!font.vertical) {
2964           scaledDim *= textState.textHScale;
2965           textState.translateTextMatrix(scaledDim, 0);
2966           textChunk.width += scaledDim;
2967         } else {
2968           textState.translateTextMatrix(0, scaledDim);
2969           scaledDim = Math.abs(scaledDim);
2970           textChunk.height += scaledDim;
2971         }
2972 
2973         if (scaledDim) {
2974           // Save the position of the last visible character.
2975           textChunk.prevTransform = getCurrentTextTransform();
2976         }
2977 
2978         const glyphUnicode = glyph.unicode;
2979         if (saveLastChar(glyphUnicode)) {
2980           // The two last chars are a non-whitespace followed by a whitespace
2981           // and then this non-whitespace, so we insert a whitespace here.
2982           // Replaces all whitespaces with standard spaces (0x20), to avoid
2983           // alignment issues between the textLayer and the canvas if the text
2984           // contains e.g. tabs (fixes issue6612.pdf).
2985           textChunk.str.push(" ");
2986         }
2987         textChunk.str.push(glyphUnicode);
2988 
2989         if (charSpacing) {
2990           if (!font.vertical) {
2991             textState.translateTextMatrix(
2992               charSpacing * textState.textHScale,
2993               0
2994             );
2995           } else {
2996             textState.translateTextMatrix(0, -charSpacing);
2997           }
2998         }
2999       }
3000     }
3001 
3002     function appendEOL() {
3003       resetLastChars();
3004       if (textContentItem.initialized) {
3005         textContentItem.hasEOL = true;
3006         flushTextContentItem();
3007       } else {
3008         textContent.items.push({
3009           str: "",
3010           dir: "ltr",
3011           width: 0,
3012           height: 0,
3013           transform: getCurrentTextTransform(),
3014           fontName: textState.loadedName,
3015           hasEOL: true,
3016         });
3017       }
3018     }
3019 
3020     function addFakeSpaces(width, transf, textOrientation) {
3021       if (
3022         textOrientation * textContentItem.spaceInFlowMin <= width &&
3023         width <= textOrientation * textContentItem.spaceInFlowMax
3024       ) {
3025         if (textContentItem.initialized) {
3026           resetLastChars();
3027           textContentItem.str.push(" ");
3028         }
3029         return false;
3030       }
3031 
3032       const fontName = textContentItem.fontName;
3033 
3034       let height = 0;
3035       if (textContentItem.vertical) {
3036         height = width;
3037         width = 0;
3038       }
3039 
3040       flushTextContentItem();
3041       resetLastChars();
3042       pushWhitespace({
3043         width: Math.abs(width),
3044         height: Math.abs(height),
3045         transform: transf || getCurrentTextTransform(),
3046         fontName,
3047       });
3048 
3049       return true;
3050     }
3051 
3052     function flushTextContentItem() {
3053       if (!textContentItem.initialized || !textContentItem.str) {
3054         return;
3055       }
3056 
3057       // Do final text scaling.
3058       if (!textContentItem.vertical) {
3059         textContentItem.totalWidth +=
3060           textContentItem.width * textContentItem.textAdvanceScale;
3061       } else {
3062         textContentItem.totalHeight +=
3063           textContentItem.height * textContentItem.textAdvanceScale;
3064       }
3065 
3066       textContent.items.push(runBidiTransform(textContentItem));
3067       textContentItem.initialized = false;
3068       textContentItem.str.length = 0;
3069     }
3070 
3071     function enqueueChunk(batch = false) {
3072       const length = textContent.items.length;
3073       if (length === 0) {
3074         return;
3075       }
3076       if (batch && length < TEXT_CHUNK_BATCH_SIZE) {
3077         return;
3078       }
3079       sink.enqueue(textContent, length);
3080       textContent.items = [];
3081       textContent.styles = Object.create(null);
3082     }
3083 
3084     const timeSlotManager = new TimeSlotManager();
3085 
3086     return new Promise(function promiseBody(resolve, reject) {
3087       const next = function (promise) {
3088         enqueueChunk(/* batch = */ true);
3089         Promise.all([promise, sink.ready]).then(function () {
3090           try {
3091             promiseBody(resolve, reject);
3092           } catch (ex) {
3093             reject(ex);
3094           }
3095         }, reject);
3096       };
3097       task.ensureNotTerminated();
3098       timeSlotManager.reset();
3099 
3100       const operation = {};
3101       let stop,
3102         name,
3103         isValidName,
3104         args = [];
3105       while (!(stop = timeSlotManager.check())) {
3106         // The arguments parsed by read() are not used beyond this loop, so
3107         // we can reuse the same array on every iteration, thus avoiding
3108         // unnecessary allocations.
3109         args.length = 0;
3110         operation.args = args;
3111         if (!preprocessor.read(operation)) {
3112           break;
3113         }
3114 
3115         const previousState = textState;
3116         textState = stateManager.state;
3117         const fn = operation.fn;
3118         args = operation.args;
3119 
3120         switch (fn | 0) {
3121           case OPS.setFont:
3122             // Optimization to ignore multiple identical Tf commands.
3123             const fontNameArg = args[0].name,
3124               fontSizeArg = args[1];
3125             if (
3126               textState.font &&
3127               fontNameArg === textState.fontName &&
3128               fontSizeArg === textState.fontSize
3129             ) {
3130               break;
3131             }
3132 
3133             flushTextContentItem();
3134             textState.fontName = fontNameArg;
3135             textState.fontSize = fontSizeArg;
3136             next(handleSetFont(fontNameArg, null));
3137             return;
3138           case OPS.setTextRise:
3139             textState.textRise = args[0];
3140             break;
3141           case OPS.setHScale:
3142             textState.textHScale = args[0] / 100;
3143             break;
3144           case OPS.setLeading:
3145             textState.leading = args[0];
3146             break;
3147           case OPS.moveText:
3148             textState.translateTextLineMatrix(args[0], args[1]);
3149             textState.textMatrix = textState.textLineMatrix.slice();
3150             break;
3151           case OPS.setLeadingMoveText:
3152             textState.leading = -args[1];
3153             textState.translateTextLineMatrix(args[0], args[1]);
3154             textState.textMatrix = textState.textLineMatrix.slice();
3155             break;
3156           case OPS.nextLine:
3157             textState.carriageReturn();
3158             break;
3159           case OPS.setTextMatrix:
3160             textState.setTextMatrix(
3161               args[0],
3162               args[1],
3163               args[2],
3164               args[3],
3165               args[4],
3166               args[5]
3167             );
3168             textState.setTextLineMatrix(
3169               args[0],
3170               args[1],
3171               args[2],
3172               args[3],
3173               args[4],
3174               args[5]
3175             );
3176             updateAdvanceScale();
3177             break;
3178           case OPS.setCharSpacing:
3179             textState.charSpacing = args[0];
3180             break;
3181           case OPS.setWordSpacing:
3182             textState.wordSpacing = args[0];
3183             break;
3184           case OPS.beginText:
3185             textState.textMatrix = IDENTITY_MATRIX.slice();
3186             textState.textLineMatrix = IDENTITY_MATRIX.slice();
3187             break;
3188           case OPS.showSpacedText:
3189             if (!stateManager.state.font) {
3190               self.ensureStateFont(stateManager.state);
3191               continue;
3192             }
3193 
3194             const spaceFactor =
3195               ((textState.font.vertical ? 1 : -1) * textState.fontSize) / 1000;
3196             const elements = args[0];
3197             for (let i = 0, ii = elements.length; i < ii; i++) {
3198               const item = elements[i];
3199               if (typeof item === "string") {
3200                 showSpacedTextBuffer.push(item);
3201               } else if (typeof item === "number" && item !== 0) {
3202                 // PDF Specification 5.3.2 states:
3203                 // The number is expressed in thousandths of a unit of text
3204                 // space.
3205                 // This amount is subtracted from the current horizontal or
3206                 // vertical coordinate, depending on the writing mode.
3207                 // In the default coordinate system, a positive adjustment
3208                 // has the effect of moving the next glyph painted either to
3209                 // the left or down by the given amount.
3210                 const str = showSpacedTextBuffer.join("");
3211                 showSpacedTextBuffer.length = 0;
3212                 buildTextContentItem({
3213                   chars: str,
3214                   extraSpacing: item * spaceFactor,
3215                 });
3216               }
3217             }
3218 
3219             if (showSpacedTextBuffer.length > 0) {
3220               const str = showSpacedTextBuffer.join("");
3221               showSpacedTextBuffer.length = 0;
3222               buildTextContentItem({
3223                 chars: str,
3224                 extraSpacing: 0,
3225               });
3226             }
3227             break;
3228           case OPS.showText:
3229             if (!stateManager.state.font) {
3230               self.ensureStateFont(stateManager.state);
3231               continue;
3232             }
3233             buildTextContentItem({
3234               chars: args[0],
3235               extraSpacing: 0,
3236             });
3237             break;
3238           case OPS.nextLineShowText:
3239             if (!stateManager.state.font) {
3240               self.ensureStateFont(stateManager.state);
3241               continue;
3242             }
3243             textState.carriageReturn();
3244             buildTextContentItem({
3245               chars: args[0],
3246               extraSpacing: 0,
3247             });
3248             break;
3249           case OPS.nextLineSetSpacingShowText:
3250             if (!stateManager.state.font) {
3251               self.ensureStateFont(stateManager.state);
3252               continue;
3253             }
3254             textState.wordSpacing = args[0];
3255             textState.charSpacing = args[1];
3256             textState.carriageReturn();
3257             buildTextContentItem({
3258               chars: args[2],
3259               extraSpacing: 0,
3260             });
3261             break;
3262           case OPS.paintXObject:
3263             flushTextContentItem();
3264             xobjs ??= resources.get("XObject") || Dict.empty;
3265 
3266             isValidName = args[0] instanceof Name;
3267             name = args[0].name;
3268 
3269             if (isValidName && emptyXObjectCache.getByName(name)) {
3270               break;
3271             }
3272 
3273             next(
3274               new Promise(function (resolveXObject, rejectXObject) {
3275                 if (!isValidName) {
3276                   throw new FormatError("XObject must be referred to by name.");
3277                 }
3278 
3279                 let xobj = xobjs.getRaw(name);
3280                 if (xobj instanceof Ref) {
3281                   if (emptyXObjectCache.getByRef(xobj)) {
3282                     resolveXObject();
3283                     return;
3284                   }
3285 
3286                   const globalImage = self.globalImageCache.getData(
3287                     xobj,
3288                     self.pageIndex
3289                   );
3290                   if (globalImage) {
3291                     resolveXObject();
3292                     return;
3293                   }
3294 
3295                   xobj = xref.fetch(xobj);
3296                 }
3297 
3298                 if (!(xobj instanceof BaseStream)) {
3299                   throw new FormatError("XObject should be a stream");
3300                 }
3301 
3302                 const type = xobj.dict.get("Subtype");
3303                 if (!(type instanceof Name)) {
3304                   throw new FormatError("XObject should have a Name subtype");
3305                 }
3306 
3307                 if (type.name !== "Form") {
3308                   emptyXObjectCache.set(name, xobj.dict.objId, true);
3309 
3310                   resolveXObject();
3311                   return;
3312                 }
3313 
3314                 // Use a new `StateManager` to prevent incorrect positioning
3315                 // of textItems *after* the Form XObject, since errors in the
3316                 // data can otherwise prevent `restore` operators from
3317                 // executing.
3318                 // NOTE: Only an issue when `options.ignoreErrors === true`.
3319                 const currentState = stateManager.state.clone();
3320                 const xObjStateManager = new StateManager(currentState);
3321 
3322                 const matrix = lookupMatrix(xobj.dict.getArray("Matrix"), null);
3323                 if (matrix) {
3324                   xObjStateManager.transform(matrix);
3325                 }
3326 
3327                 // Enqueue the `textContent` chunk before parsing the /Form
3328                 // XObject.
3329                 enqueueChunk();
3330                 const sinkWrapper = {
3331                   enqueueInvoked: false,
3332 
3333                   enqueue(chunk, size) {
3334                     this.enqueueInvoked = true;
3335                     sink.enqueue(chunk, size);
3336                   },
3337 
3338                   get desiredSize() {
3339                     return sink.desiredSize;
3340                   },
3341 
3342                   get ready() {
3343                     return sink.ready;
3344                   },
3345                 };
3346 
3347                 self
3348                   .getTextContent({
3349                     stream: xobj,
3350                     task,
3351                     resources: xobj.dict.get("Resources") || resources,
3352                     stateManager: xObjStateManager,
3353                     includeMarkedContent,
3354                     sink: sinkWrapper,
3355                     seenStyles,
3356                     viewBox,
3357                     lang,
3358                     markedContentData,
3359                     disableNormalization,
3360                     keepWhiteSpace,
3361                     prevRefs: seenRefs,
3362                   })
3363                   .then(function () {
3364                     if (!sinkWrapper.enqueueInvoked) {
3365                       emptyXObjectCache.set(name, xobj.dict.objId, true);
3366                     }
3367                     resolveXObject();
3368                   }, rejectXObject);
3369               }).catch(function (reason) {
3370                 if (reason instanceof AbortException) {
3371                   return;
3372                 }
3373                 if (self.options.ignoreErrors) {
3374                   // Error(s) in the XObject -- allow text-extraction to
3375                   // continue.
3376                   warn(`getTextContent - ignoring XObject: "${reason}".`);
3377                   return;
3378                 }
3379                 throw reason;
3380               })
3381             );
3382             return;
3383           case OPS.setGState:
3384             isValidName = args[0] instanceof Name;
3385             name = args[0].name;
3386 
3387             if (isValidName && emptyGStateCache.getByName(name)) {
3388               break;
3389             }
3390 
3391             next(
3392               new Promise(function (resolveGState, rejectGState) {
3393                 if (!isValidName) {
3394                   throw new FormatError("GState must be referred to by name.");
3395                 }
3396 
3397                 const extGState = resources.get("ExtGState");
3398                 if (!(extGState instanceof Dict)) {
3399                   throw new FormatError("ExtGState should be a dictionary.");
3400                 }
3401 
3402                 const gState = extGState.get(name);
3403                 // TODO: Attempt to lookup cached GStates by reference as well,
3404                 //       if and only if there are PDF documents where doing so
3405                 //       would significantly improve performance.
3406                 if (!(gState instanceof Dict)) {
3407                   throw new FormatError("GState should be a dictionary.");
3408                 }
3409 
3410                 const gStateFont = gState.get("Font");
3411                 if (!gStateFont) {
3412                   emptyGStateCache.set(name, gState.objId, true);
3413 
3414                   resolveGState();
3415                   return;
3416                 }
3417                 flushTextContentItem();
3418 
3419                 textState.fontName = null;
3420                 textState.fontSize = gStateFont[1];
3421                 handleSetFont(null, gStateFont[0]).then(
3422                   resolveGState,
3423                   rejectGState
3424                 );
3425               }).catch(function (reason) {
3426                 if (reason instanceof AbortException) {
3427                   return;
3428                 }
3429                 if (self.options.ignoreErrors) {
3430                   // Error(s) in the ExtGState -- allow text-extraction to
3431                   // continue.
3432                   warn(`getTextContent - ignoring ExtGState: "${reason}".`);
3433                   return;
3434                 }
3435                 throw reason;
3436               })
3437             );
3438             return;
3439           case OPS.beginMarkedContent:
3440             flushTextContentItem();
3441             if (includeMarkedContent) {
3442               markedContentData.level++;
3443 
3444               textContent.items.push({
3445                 type: "beginMarkedContent",
3446                 tag: args[0] instanceof Name ? args[0].name : null,
3447               });
3448             }
3449             break;
3450           case OPS.beginMarkedContentProps:
3451             flushTextContentItem();
3452             if (includeMarkedContent) {
3453               markedContentData.level++;
3454 
3455               let mcid = null;
3456               if (args[1] instanceof Dict) {
3457                 mcid = args[1].get("MCID");
3458               }
3459               textContent.items.push({
3460                 type: "beginMarkedContentProps",
3461                 id: Number.isInteger(mcid)
3462                   ? `${self.idFactory.getPageObjId()}_mc${mcid}`
3463                   : null,
3464                 tag: args[0] instanceof Name ? args[0].name : null,
3465               });
3466             }
3467             break;
3468           case OPS.endMarkedContent:
3469             flushTextContentItem();
3470             if (includeMarkedContent) {
3471               if (markedContentData.level === 0) {
3472                 // Handle unbalanced beginMarkedContent/endMarkedContent
3473                 // operators (fixes issue15629.pdf).
3474                 break;
3475               }
3476               markedContentData.level--;
3477 
3478               textContent.items.push({
3479                 type: "endMarkedContent",
3480               });
3481             }
3482             break;
3483           case OPS.restore:
3484             if (
3485               previousState &&
3486               (previousState.font !== textState.font ||
3487                 previousState.fontSize !== textState.fontSize ||
3488                 previousState.fontName !== textState.fontName)
3489             ) {
3490               flushTextContentItem();
3491             }
3492             break;
3493         } // switch
3494         if (textContent.items.length >= sink.desiredSize) {
3495           // Wait for ready, if we reach highWaterMark.
3496           stop = true;
3497           break;
3498         }
3499       } // while
3500       if (stop) {
3501         next(deferred);
3502         return;
3503       }
3504       flushTextContentItem();
3505       enqueueChunk();
3506       resolve();
3507     }).catch(reason => {
3508       if (reason instanceof AbortException) {
3509         return;
3510       }
3511       if (this.options.ignoreErrors) {
3512         // Error(s) in the TextContent -- allow text-extraction to continue.
3513         warn(
3514           `getTextContent - ignoring errors during "${task.name}" ` +
3515             `task: "${reason}".`
3516         );
3517 
3518         flushTextContentItem();
3519         enqueueChunk();
3520         return;
3521       }
3522       throw reason;
3523     });
3524   }
3525 
3526   async extractDataStructures(dict, properties) {
3527     const xref = this.xref;
3528     let cidToGidBytes;
3529     // 9.10.2
3530     const toUnicodePromise = this.readToUnicode(properties.toUnicode);
3531 
3532     if (properties.composite) {
3533       // CIDSystemInfo helps to match CID to glyphs
3534       const cidSystemInfo = dict.get("CIDSystemInfo");
3535       if (cidSystemInfo instanceof Dict) {
3536         properties.cidSystemInfo = {
3537           registry: stringToPDFString(cidSystemInfo.get("Registry")),
3538           ordering: stringToPDFString(cidSystemInfo.get("Ordering")),
3539           supplement: cidSystemInfo.get("Supplement"),
3540         };
3541       }
3542 
3543       try {
3544         const cidToGidMap = dict.get("CIDToGIDMap");
3545         if (cidToGidMap instanceof BaseStream) {
3546           cidToGidBytes = cidToGidMap.getBytes();
3547         }
3548       } catch (ex) {
3549         if (!this.options.ignoreErrors) {
3550           throw ex;
3551         }
3552         warn(`extractDataStructures - ignoring CIDToGIDMap data: "${ex}".`);
3553       }
3554     }
3555 
3556     // Based on 9.6.6 of the spec the encoding can come from multiple places
3557     // and depends on the font type. The base encoding and differences are
3558     // read here, but the encoding that is actually used is chosen during
3559     // glyph mapping in the font.
3560     // TODO: Loading the built in encoding in the font would allow the
3561     // differences to be merged in here not require us to hold on to it.
3562     const differences = [];
3563     let baseEncodingName = null;
3564     let encoding;
3565     if (dict.has("Encoding")) {
3566       encoding = dict.get("Encoding");
3567       if (encoding instanceof Dict) {
3568         baseEncodingName = encoding.get("BaseEncoding");
3569         baseEncodingName =
3570           baseEncodingName instanceof Name ? baseEncodingName.name : null;
3571         // Load the differences between the base and original
3572         if (encoding.has("Differences")) {
3573           const diffEncoding = encoding.get("Differences");
3574           let index = 0;
3575           for (const entry of diffEncoding) {
3576             const data = xref.fetchIfRef(entry);
3577             if (typeof data === "number") {
3578               index = data;
3579             } else if (data instanceof Name) {
3580               differences[index++] = data.name;
3581             } else {
3582               throw new FormatError(
3583                 `Invalid entry in 'Differences' array: ${data}`
3584               );
3585             }
3586           }
3587         }
3588       } else if (encoding instanceof Name) {
3589         baseEncodingName = encoding.name;
3590       } else {
3591         const msg = "Encoding is not a Name nor a Dict";
3592 
3593         if (!this.options.ignoreErrors) {
3594           throw new FormatError(msg);
3595         }
3596         warn(msg);
3597       }
3598       // According to table 114 if the encoding is a named encoding it must be
3599       // one of these predefined encodings.
3600       if (
3601         baseEncodingName !== "MacRomanEncoding" &&
3602         baseEncodingName !== "MacExpertEncoding" &&
3603         baseEncodingName !== "WinAnsiEncoding"
3604       ) {
3605         baseEncodingName = null;
3606       }
3607     }
3608 
3609     const nonEmbeddedFont = !properties.file || properties.isInternalFont,
3610       isSymbolsFontName = getSymbolsFonts()[properties.name];
3611     // Ignore an incorrectly specified named encoding for non-embedded
3612     // symbol fonts (fixes issue16464.pdf).
3613     if (baseEncodingName && nonEmbeddedFont && isSymbolsFontName) {
3614       baseEncodingName = null;
3615     }
3616 
3617     if (baseEncodingName) {
3618       properties.defaultEncoding = getEncoding(baseEncodingName);
3619     } else {
3620       const isSymbolicFont = !!(properties.flags & FontFlags.Symbolic);
3621       const isNonsymbolicFont = !!(properties.flags & FontFlags.Nonsymbolic);
3622       // According to "Table 114" in section "9.6.6.1 General" (under
3623       // "9.6.6 Character Encoding") of the PDF specification, a Nonsymbolic
3624       // font should use the `StandardEncoding` if no encoding is specified.
3625       encoding = StandardEncoding;
3626       if (properties.type === "TrueType" && !isNonsymbolicFont) {
3627         encoding = WinAnsiEncoding;
3628       }
3629       // The Symbolic attribute can be misused for regular fonts
3630       // Heuristic: we have to check if the font is a standard one also
3631       if (isSymbolicFont || isSymbolsFontName) {
3632         encoding = MacRomanEncoding;
3633         if (nonEmbeddedFont) {
3634           if (/Symbol/i.test(properties.name)) {
3635             encoding = SymbolSetEncoding;
3636           } else if (/Dingbats/i.test(properties.name)) {
3637             encoding = ZapfDingbatsEncoding;
3638           } else if (/Wingdings/i.test(properties.name)) {
3639             encoding = WinAnsiEncoding;
3640           }
3641         }
3642       }
3643       properties.defaultEncoding = encoding;
3644     }
3645 
3646     properties.differences = differences;
3647     properties.baseEncodingName = baseEncodingName;
3648     properties.hasEncoding = !!baseEncodingName || differences.length > 0;
3649     properties.dict = dict;
3650 
3651     properties.toUnicode = await toUnicodePromise;
3652 
3653     const builtToUnicode = await this.buildToUnicode(properties);
3654     properties.toUnicode = builtToUnicode;
3655 
3656     if (cidToGidBytes) {
3657       properties.cidToGidMap = this.readCidToGidMap(
3658         cidToGidBytes,
3659         builtToUnicode
3660       );
3661     }
3662     return properties;
3663   }
3664 
3665   /**
3666    * @returns {Array}
3667    * @private
3668    */
3669   _simpleFontToUnicode(properties, forceGlyphs = false) {
3670     assert(!properties.composite, "Must be a simple font.");
3671 
3672     const toUnicode = [];
3673     const encoding = properties.defaultEncoding.slice();
3674     const baseEncodingName = properties.baseEncodingName;
3675     // Merge in the differences array.
3676     const differences = properties.differences;
3677     for (const charcode in differences) {
3678       const glyphName = differences[charcode];
3679       if (glyphName === ".notdef") {
3680         // Skip .notdef to prevent rendering errors, e.g. boxes appearing
3681         // where there should be spaces (fixes issue5256.pdf).
3682         continue;
3683       }
3684       encoding[charcode] = glyphName;
3685     }
3686     const glyphsUnicodeMap = getGlyphsUnicode();
3687     for (const charcode in encoding) {
3688       // a) Map the character code to a character name.
3689       let glyphName = encoding[charcode];
3690       if (glyphName === "") {
3691         continue;
3692       }
3693       // b) Look up the character name in the Adobe Glyph List (see the
3694       //    Bibliography) to obtain the corresponding Unicode value.
3695       let unicode = glyphsUnicodeMap[glyphName];
3696       if (unicode !== undefined) {
3697         toUnicode[charcode] = String.fromCharCode(unicode);
3698         continue;
3699       }
3700       // (undocumented) c) Few heuristics to recognize unknown glyphs
3701       // NOTE: Adobe Reader does not do this step, but OSX Preview does
3702       let code = 0;
3703       switch (glyphName[0]) {
3704         case "G": // Gxx glyph
3705           if (glyphName.length === 3) {
3706             code = parseInt(glyphName.substring(1), 16);
3707           }
3708           break;
3709         case "g": // g00xx glyph
3710           if (glyphName.length === 5) {
3711             code = parseInt(glyphName.substring(1), 16);
3712           }
3713           break;
3714         case "C": // Cdd{d} glyph
3715         case "c": // cdd{d} glyph
3716           if (glyphName.length >= 3 && glyphName.length <= 4) {
3717             const codeStr = glyphName.substring(1);
3718 
3719             if (forceGlyphs) {
3720               code = parseInt(codeStr, 16);
3721               break;
3722             }
3723             // Normally the Cdd{d}/cdd{d} glyphName format will contain
3724             // regular, i.e. base 10, charCodes (see issue4550.pdf)...
3725             code = +codeStr;
3726 
3727             // ... however some PDF generators violate that assumption by
3728             // containing glyph, i.e. base 16, codes instead.
3729             // In that case we need to re-parse the *entire* encoding to
3730             // prevent broken text-selection (fixes issue9655_reduced.pdf).
3731             if (Number.isNaN(code) && Number.isInteger(parseInt(codeStr, 16))) {
3732               return this._simpleFontToUnicode(
3733                 properties,
3734                 /* forceGlyphs */ true
3735               );
3736             }
3737           }
3738           break;
3739         case "u": // 'uniXXXX'/'uXXXX{XX}' glyphs
3740           unicode = getUnicodeForGlyph(glyphName, glyphsUnicodeMap);
3741           if (unicode !== -1) {
3742             code = unicode;
3743           }
3744           break;
3745         default:
3746           // Support (some) non-standard ligatures.
3747           switch (glyphName) {
3748             case "f_h":
3749             case "f_t":
3750             case "T_h":
3751               toUnicode[charcode] = glyphName.replaceAll("_", "");
3752               continue;
3753           }
3754           break;
3755       }
3756       if (code > 0 && code <= 0x10ffff && Number.isInteger(code)) {
3757         // If `baseEncodingName` is one the predefined encodings, and `code`
3758         // equals `charcode`, using the glyph defined in the baseEncoding
3759         // seems to yield a better `toUnicode` mapping (fixes issue 5070).
3760         if (baseEncodingName && code === +charcode) {
3761           const baseEncoding = getEncoding(baseEncodingName);
3762           if (baseEncoding && (glyphName = baseEncoding[charcode])) {
3763             toUnicode[charcode] = String.fromCharCode(
3764               glyphsUnicodeMap[glyphName]
3765             );
3766             continue;
3767           }
3768         }
3769         toUnicode[charcode] = String.fromCodePoint(code);
3770       }
3771     }
3772     return toUnicode;
3773   }
3774 
3775   /**
3776    * Builds a char code to unicode map based on section 9.10 of the spec.
3777    * @param {Object} properties Font properties object.
3778    * @returns {Promise} A Promise that is resolved with a
3779    *   {ToUnicodeMap|IdentityToUnicodeMap} object.
3780    */
3781   async buildToUnicode(properties) {
3782     properties.hasIncludedToUnicodeMap = properties.toUnicode?.length > 0;
3783 
3784     // Section 9.10.2 Mapping Character Codes to Unicode Values
3785     if (properties.hasIncludedToUnicodeMap) {
3786       // Some fonts contain incomplete ToUnicode data, causing issues with
3787       // text-extraction. For simple fonts, containing encoding information,
3788       // use a fallback ToUnicode map to improve this (fixes issue8229.pdf).
3789       if (!properties.composite && properties.hasEncoding) {
3790         properties.fallbackToUnicode = this._simpleFontToUnicode(properties);
3791       }
3792       return properties.toUnicode;
3793     }
3794 
3795     // According to the spec if the font is a simple font we should only map
3796     // to unicode if the base encoding is MacRoman, MacExpert, or WinAnsi or
3797     // the differences array only contains adobe standard or symbol set names,
3798     // in pratice it seems better to always try to create a toUnicode map
3799     // based of the default encoding.
3800     if (!properties.composite /* is simple font */) {
3801       return new ToUnicodeMap(this._simpleFontToUnicode(properties));
3802     }
3803 
3804     // If the font is a composite font that uses one of the predefined CMaps
3805     // listed in Table 118 (except Identity–H and Identity–V) or whose
3806     // descendant CIDFont uses the Adobe-GB1, Adobe-CNS1, Adobe-Japan1, or
3807     // Adobe-Korea1 character collection:
3808     if (
3809       properties.composite &&
3810       ((properties.cMap.builtInCMap &&
3811         !(properties.cMap instanceof IdentityCMap)) ||
3812         // The font is supposed to have a CIDSystemInfo dictionary, but some
3813         // PDFs don't include it (fixes issue 17689), hence the `?'.
3814         (properties.cidSystemInfo?.registry === "Adobe" &&
3815           (properties.cidSystemInfo.ordering === "GB1" ||
3816             properties.cidSystemInfo.ordering === "CNS1" ||
3817             properties.cidSystemInfo.ordering === "Japan1" ||
3818             properties.cidSystemInfo.ordering === "Korea1")))
3819     ) {
3820       // Then:
3821       // a) Map the character code to a character identifier (CID) according
3822       // to the font’s CMap.
3823       // b) Obtain the registry and ordering of the character collection used
3824       // by the font’s CMap (for example, Adobe and Japan1) from its
3825       // CIDSystemInfo dictionary.
3826       const { registry, ordering } = properties.cidSystemInfo;
3827       // c) Construct a second CMap name by concatenating the registry and
3828       // ordering obtained in step (b) in the format registry–ordering–UCS2
3829       // (for example, Adobe–Japan1–UCS2).
3830       const ucs2CMapName = Name.get(`${registry}-${ordering}-UCS2`);
3831       // d) Obtain the CMap with the name constructed in step (c) (available
3832       // from the ASN Web site; see the Bibliography).
3833       const ucs2CMap = await CMapFactory.create({
3834         encoding: ucs2CMapName,
3835         fetchBuiltInCMap: this._fetchBuiltInCMapBound,
3836         useCMap: null,
3837       });
3838       const toUnicode = [],
3839         buf = [];
3840       properties.cMap.forEach(function (charcode, cid) {
3841         if (cid > 0xffff) {
3842           throw new FormatError("Max size of CID is 65,535");
3843         }
3844         // e) Map the CID obtained in step (a) according to the CMap
3845         // obtained in step (d), producing a Unicode value.
3846         const ucs2 = ucs2CMap.lookup(cid);
3847         if (ucs2) {
3848           buf.length = 0;
3849           // Support multi-byte entries (fixes issue16176.pdf).
3850           for (let i = 0, ii = ucs2.length; i < ii; i += 2) {
3851             buf.push((ucs2.charCodeAt(i) << 8) + ucs2.charCodeAt(i + 1));
3852           }
3853           toUnicode[charcode] = String.fromCharCode(...buf);
3854         }
3855       });
3856       return new ToUnicodeMap(toUnicode);
3857     }
3858 
3859     // The viewer's choice, just use an identity map.
3860     return new IdentityToUnicodeMap(properties.firstChar, properties.lastChar);
3861   }
3862 
3863   async readToUnicode(cmapObj) {
3864     if (!cmapObj) {
3865       return null;
3866     }
3867     if (cmapObj instanceof Name) {
3868       const cmap = await CMapFactory.create({
3869         encoding: cmapObj,
3870         fetchBuiltInCMap: this._fetchBuiltInCMapBound,
3871         useCMap: null,
3872       });
3873 
3874       if (cmap instanceof IdentityCMap) {
3875         return new IdentityToUnicodeMap(0, 0xffff);
3876       }
3877       return new ToUnicodeMap(cmap.getMap());
3878     }
3879     if (cmapObj instanceof BaseStream) {
3880       try {
3881         const cmap = await CMapFactory.create({
3882           encoding: cmapObj,
3883           fetchBuiltInCMap: this._fetchBuiltInCMapBound,
3884           useCMap: null,
3885         });
3886 
3887         if (cmap instanceof IdentityCMap) {
3888           return new IdentityToUnicodeMap(0, 0xffff);
3889         }
3890         const map = new Array(cmap.length);
3891         // Convert UTF-16BE
3892         // NOTE: cmap can be a sparse array, so use forEach instead of
3893         // `for(;;)` to iterate over all keys.
3894         cmap.forEach(function (charCode, token) {
3895           // Some cmaps contain *only* CID characters (fixes issue9367.pdf).
3896           if (typeof token === "number") {
3897             map[charCode] = String.fromCodePoint(token);
3898             return;
3899           }
3900           // Add back omitted leading zeros on odd length tokens
3901           // (fixes issue #18099)
3902           if (token.length % 2 !== 0) {
3903             token = "\u0000" + token;
3904           }
3905           const str = [];
3906           for (let k = 0; k < token.length; k += 2) {
3907             const w1 = (token.charCodeAt(k) << 8) | token.charCodeAt(k + 1);
3908             if ((w1 & 0xf800) !== 0xd800) {
3909               // w1 < 0xD800 || w1 > 0xDFFF
3910               str.push(w1);
3911               continue;
3912             }
3913             k += 2;
3914             const w2 = (token.charCodeAt(k) << 8) | token.charCodeAt(k + 1);
3915             str.push(((w1 & 0x3ff) << 10) + (w2 & 0x3ff) + 0x10000);
3916           }
3917           map[charCode] = String.fromCodePoint(...str);
3918         });
3919         return new ToUnicodeMap(map);
3920       } catch (reason) {
3921         if (reason instanceof AbortException) {
3922           return null;
3923         }
3924         if (this.options.ignoreErrors) {
3925           warn(`readToUnicode - ignoring ToUnicode data: "${reason}".`);
3926           return null;
3927         }
3928         throw reason;
3929       }
3930     }
3931     return null;
3932   }
3933 
3934   readCidToGidMap(glyphsData, toUnicode) {
3935     // Extract the encoding from the CIDToGIDMap
3936 
3937     // Set encoding 0 to later verify the font has an encoding
3938     const result = [];
3939     for (let j = 0, jj = glyphsData.length; j < jj; j++) {
3940       const glyphID = (glyphsData[j++] << 8) | glyphsData[j];
3941       const code = j >> 1;
3942       if (glyphID === 0 && !toUnicode.has(code)) {
3943         continue;
3944       }
3945       result[code] = glyphID;
3946     }
3947     return result;
3948   }
3949 
3950   extractWidths(dict, descriptor, properties) {
3951     const xref = this.xref;
3952     let glyphsWidths = [];
3953     let defaultWidth = 0;
3954     const glyphsVMetrics = [];
3955     let defaultVMetrics;
3956     if (properties.composite) {
3957       const dw = dict.get("DW");
3958       defaultWidth = typeof dw === "number" ? Math.ceil(dw) : 1000;
3959 
3960       const widths = dict.get("W");
3961       if (Array.isArray(widths)) {
3962         for (let i = 0, ii = widths.length; i < ii; i++) {
3963           let start = xref.fetchIfRef(widths[i++]);
3964           if (!Number.isInteger(start)) {
3965             break; // Invalid /W data.
3966           }
3967           const code = xref.fetchIfRef(widths[i]);
3968 
3969           if (Array.isArray(code)) {
3970             for (const c of code) {
3971               const width = xref.fetchIfRef(c);
3972               if (typeof width === "number") {
3973                 glyphsWidths[start] = width;
3974               }
3975               start++;
3976             }
3977           } else if (Number.isInteger(code)) {
3978             const width = xref.fetchIfRef(widths[++i]);
3979             if (typeof width !== "number") {
3980               continue;
3981             }
3982             for (let j = start; j <= code; j++) {
3983               glyphsWidths[j] = width;
3984             }
3985           } else {
3986             break; // Invalid /W data.
3987           }
3988         }
3989       }
3990 
3991       if (properties.vertical) {
3992         const dw2 = dict.getArray("DW2");
3993         let vmetrics = isNumberArray(dw2, 2) ? dw2 : [880, -1000];
3994         defaultVMetrics = [vmetrics[1], defaultWidth * 0.5, vmetrics[0]];
3995         vmetrics = dict.get("W2");
3996         if (Array.isArray(vmetrics)) {
3997           for (let i = 0, ii = vmetrics.length; i < ii; i++) {
3998             let start = xref.fetchIfRef(vmetrics[i++]);
3999             if (!Number.isInteger(start)) {
4000               break; // Invalid /W2 data.
4001             }
4002             const code = xref.fetchIfRef(vmetrics[i]);
4003 
4004             if (Array.isArray(code)) {
4005               for (let j = 0, jj = code.length; j < jj; j++) {
4006                 const vmetric = [
4007                   xref.fetchIfRef(code[j++]),
4008                   xref.fetchIfRef(code[j++]),
4009                   xref.fetchIfRef(code[j]),
4010                 ];
4011                 if (isNumberArray(vmetric, null)) {
4012                   glyphsVMetrics[start] = vmetric;
4013                 }
4014                 start++;
4015               }
4016             } else if (Number.isInteger(code)) {
4017               const vmetric = [
4018                 xref.fetchIfRef(vmetrics[++i]),
4019                 xref.fetchIfRef(vmetrics[++i]),
4020                 xref.fetchIfRef(vmetrics[++i]),
4021               ];
4022               if (!isNumberArray(vmetric, null)) {
4023                 continue;
4024               }
4025               for (let j = start; j <= code; j++) {
4026                 glyphsVMetrics[j] = vmetric;
4027               }
4028             } else {
4029               break; // Invalid /W2 data.
4030             }
4031           }
4032         }
4033       }
4034     } else {
4035       const widths = dict.get("Widths");
4036       if (Array.isArray(widths)) {
4037         let j = properties.firstChar;
4038         for (const w of widths) {
4039           const width = xref.fetchIfRef(w);
4040           if (typeof width === "number") {
4041             glyphsWidths[j] = width;
4042           }
4043           j++;
4044         }
4045         const missingWidth = descriptor.get("MissingWidth");
4046         defaultWidth = typeof missingWidth === "number" ? missingWidth : 0;
4047       } else {
4048         // Trying get the BaseFont metrics (see comment above).
4049         const baseFontName = dict.get("BaseFont");
4050         if (baseFontName instanceof Name) {
4051           const metrics = this.getBaseFontMetrics(baseFontName.name);
4052 
4053           glyphsWidths = this.buildCharCodeToWidth(metrics.widths, properties);
4054           defaultWidth = metrics.defaultWidth;
4055         }
4056       }
4057     }
4058 
4059     // Heuristic: detection of monospace font by checking all non-zero widths
4060     let isMonospace = true;
4061     let firstWidth = defaultWidth;
4062     for (const glyph in glyphsWidths) {
4063       const glyphWidth = glyphsWidths[glyph];
4064       if (!glyphWidth) {
4065         continue;
4066       }
4067       if (!firstWidth) {
4068         firstWidth = glyphWidth;
4069         continue;
4070       }
4071       if (firstWidth !== glyphWidth) {
4072         isMonospace = false;
4073         break;
4074       }
4075     }
4076     if (isMonospace) {
4077       properties.flags |= FontFlags.FixedPitch;
4078     } else {
4079       // Clear the flag.
4080       properties.flags &= ~FontFlags.FixedPitch;
4081     }
4082 
4083     properties.defaultWidth = defaultWidth;
4084     properties.widths = glyphsWidths;
4085     properties.defaultVMetrics = defaultVMetrics;
4086     properties.vmetrics = glyphsVMetrics;
4087   }
4088 
4089   isSerifFont(baseFontName) {
4090     // Simulating descriptor flags attribute
4091     const fontNameWoStyle = baseFontName.split("-", 1)[0];
4092     return (
4093       fontNameWoStyle in getSerifFonts() || /serif/gi.test(fontNameWoStyle)
4094     );
4095   }
4096 
4097   getBaseFontMetrics(name) {
4098     let defaultWidth = 0;
4099     let widths = Object.create(null);
4100     let monospace = false;
4101     const stdFontMap = getStdFontMap();
4102     let lookupName = stdFontMap[name] || name;
4103     const Metrics = getMetrics();
4104 
4105     if (!(lookupName in Metrics)) {
4106       // Use default fonts for looking up font metrics if the passed
4107       // font is not a base font
4108       lookupName = this.isSerifFont(name) ? "Times-Roman" : "Helvetica";
4109     }
4110     const glyphWidths = Metrics[lookupName];
4111 
4112     if (typeof glyphWidths === "number") {
4113       defaultWidth = glyphWidths;
4114       monospace = true;
4115     } else {
4116       widths = glyphWidths(); // expand lazy widths array
4117     }
4118 
4119     return {
4120       defaultWidth,
4121       monospace,
4122       widths,
4123     };
4124   }
4125 
4126   buildCharCodeToWidth(widthsByGlyphName, properties) {
4127     const widths = Object.create(null);
4128     const differences = properties.differences;
4129     const encoding = properties.defaultEncoding;
4130     for (let charCode = 0; charCode < 256; charCode++) {
4131       if (charCode in differences && widthsByGlyphName[differences[charCode]]) {
4132         widths[charCode] = widthsByGlyphName[differences[charCode]];
4133         continue;
4134       }
4135       if (charCode in encoding && widthsByGlyphName[encoding[charCode]]) {
4136         widths[charCode] = widthsByGlyphName[encoding[charCode]];
4137         continue;
4138       }
4139     }
4140     return widths;
4141   }
4142 
4143   preEvaluateFont(dict) {
4144     const baseDict = dict;
4145     let type = dict.get("Subtype");
4146     if (!(type instanceof Name)) {
4147       throw new FormatError("invalid font Subtype");
4148     }
4149 
4150     let composite = false;
4151     let hash;
4152     if (type.name === "Type0") {
4153       // If font is a composite
4154       //  - get the descendant font
4155       //  - set the type according to the descendant font
4156       //  - get the FontDescriptor from the descendant font
4157       const df = dict.get("DescendantFonts");
4158       if (!df) {
4159         throw new FormatError("Descendant fonts are not specified");
4160       }
4161       dict = Array.isArray(df) ? this.xref.fetchIfRef(df[0]) : df;
4162 
4163       if (!(dict instanceof Dict)) {
4164         throw new FormatError("Descendant font is not a dictionary.");
4165       }
4166       type = dict.get("Subtype");
4167       if (!(type instanceof Name)) {
4168         throw new FormatError("invalid font Subtype");
4169       }
4170       composite = true;
4171     }
4172 
4173     let firstChar = dict.get("FirstChar");
4174     if (!Number.isInteger(firstChar)) {
4175       firstChar = 0;
4176     }
4177     let lastChar = dict.get("LastChar");
4178     if (!Number.isInteger(lastChar)) {
4179       lastChar = composite ? 0xffff : 0xff;
4180     }
4181     const descriptor = dict.get("FontDescriptor");
4182     const toUnicode = dict.get("ToUnicode") || baseDict.get("ToUnicode");
4183 
4184     if (descriptor) {
4185       hash = new MurmurHash3_64();
4186 
4187       const encoding = baseDict.getRaw("Encoding");
4188       if (encoding instanceof Name) {
4189         hash.update(encoding.name);
4190       } else if (encoding instanceof Ref) {
4191         hash.update(encoding.toString());
4192       } else if (encoding instanceof Dict) {
4193         for (const entry of encoding.getRawValues()) {
4194           if (entry instanceof Name) {
4195             hash.update(entry.name);
4196           } else if (entry instanceof Ref) {
4197             hash.update(entry.toString());
4198           } else if (Array.isArray(entry)) {
4199             // 'Differences' array (fixes bug1157493.pdf).
4200             const diffLength = entry.length,
4201               diffBuf = new Array(diffLength);
4202 
4203             for (let j = 0; j < diffLength; j++) {
4204               const diffEntry = entry[j];
4205               if (diffEntry instanceof Name) {
4206                 diffBuf[j] = diffEntry.name;
4207               } else if (
4208                 typeof diffEntry === "number" ||
4209                 diffEntry instanceof Ref
4210               ) {
4211                 diffBuf[j] = diffEntry.toString();
4212               }
4213             }
4214             hash.update(diffBuf.join());
4215           }
4216         }
4217       }
4218 
4219       hash.update(`${firstChar}-${lastChar}`); // Fixes issue10665_reduced.pdf
4220 
4221       if (toUnicode instanceof BaseStream) {
4222         const stream = toUnicode.str || toUnicode;
4223         const uint8array = stream.buffer
4224           ? new Uint8Array(stream.buffer.buffer, 0, stream.bufferLength)
4225           : new Uint8Array(
4226               stream.bytes.buffer,
4227               stream.start,
4228               stream.end - stream.start
4229             );
4230         hash.update(uint8array);
4231       } else if (toUnicode instanceof Name) {
4232         hash.update(toUnicode.name);
4233       }
4234 
4235       const widths = dict.get("Widths") || baseDict.get("Widths");
4236       if (Array.isArray(widths)) {
4237         const widthsBuf = [];
4238         for (const entry of widths) {
4239           if (typeof entry === "number" || entry instanceof Ref) {
4240             widthsBuf.push(entry.toString());
4241           }
4242         }
4243         hash.update(widthsBuf.join());
4244       }
4245 
4246       if (composite) {
4247         hash.update("compositeFont");
4248 
4249         const compositeWidths = dict.get("W") || baseDict.get("W");
4250         if (Array.isArray(compositeWidths)) {
4251           const widthsBuf = [];
4252           for (const entry of compositeWidths) {
4253             if (typeof entry === "number" || entry instanceof Ref) {
4254               widthsBuf.push(entry.toString());
4255             } else if (Array.isArray(entry)) {
4256               const subWidthsBuf = [];
4257               for (const element of entry) {
4258                 if (typeof element === "number" || element instanceof Ref) {
4259                   subWidthsBuf.push(element.toString());
4260                 }
4261               }
4262               widthsBuf.push(`[${subWidthsBuf.join()}]`);
4263             }
4264           }
4265           hash.update(widthsBuf.join());
4266         }
4267 
4268         const cidToGidMap =
4269           dict.getRaw("CIDToGIDMap") || baseDict.getRaw("CIDToGIDMap");
4270         if (cidToGidMap instanceof Name) {
4271           hash.update(cidToGidMap.name);
4272         } else if (cidToGidMap instanceof Ref) {
4273           hash.update(cidToGidMap.toString());
4274         } else if (cidToGidMap instanceof BaseStream) {
4275           hash.update(cidToGidMap.peekBytes());
4276         }
4277       }
4278     }
4279 
4280     return {
4281       descriptor,
4282       dict,
4283       baseDict,
4284       composite,
4285       type: type.name,
4286       firstChar,
4287       lastChar,
4288       toUnicode,
4289       hash: hash ? hash.hexdigest() : "",
4290     };
4291   }
4292 
4293   async translateFont({
4294     descriptor,
4295     dict,
4296     baseDict,
4297     composite,
4298     type,
4299     firstChar,
4300     lastChar,
4301     toUnicode,
4302     cssFontInfo,
4303   }) {
4304     const isType3Font = type === "Type3";
4305 
4306     if (!descriptor) {
4307       if (isType3Font) {
4308         const bbox = lookupNormalRect(dict.getArray("FontBBox"), [0, 0, 0, 0]);
4309         // FontDescriptor is only required for Type3 fonts when the document
4310         // is a tagged pdf. Create a barbebones one to get by.
4311         descriptor = new Dict(null);
4312         descriptor.set("FontName", Name.get(type));
4313         descriptor.set("FontBBox", bbox);
4314       } else {
4315         // Before PDF 1.5 if the font was one of the base 14 fonts, having a
4316         // FontDescriptor was not required.
4317         // This case is here for compatibility.
4318         let baseFontName = dict.get("BaseFont");
4319         if (!(baseFontName instanceof Name)) {
4320           throw new FormatError("Base font is not specified");
4321         }
4322 
4323         // Using base font name as a font name.
4324         baseFontName = baseFontName.name.replaceAll(/[,_]/g, "-");
4325         const metrics = this.getBaseFontMetrics(baseFontName);
4326 
4327         // Simulating descriptor flags attribute
4328         const fontNameWoStyle = baseFontName.split("-", 1)[0];
4329         const flags =
4330           (this.isSerifFont(fontNameWoStyle) ? FontFlags.Serif : 0) |
4331           (metrics.monospace ? FontFlags.FixedPitch : 0) |
4332           (getSymbolsFonts()[fontNameWoStyle]
4333             ? FontFlags.Symbolic
4334             : FontFlags.Nonsymbolic);
4335 
4336         const properties = {
4337           type,
4338           name: baseFontName,
4339           loadedName: baseDict.loadedName,
4340           systemFontInfo: null,
4341           widths: metrics.widths,
4342           defaultWidth: metrics.defaultWidth,
4343           isSimulatedFlags: true,
4344           flags,
4345           firstChar,
4346           lastChar,
4347           toUnicode,
4348           xHeight: 0,
4349           capHeight: 0,
4350           italicAngle: 0,
4351           isType3Font,
4352         };
4353         const widths = dict.get("Widths");
4354 
4355         const standardFontName = getStandardFontName(baseFontName);
4356         let file = null;
4357         if (standardFontName) {
4358           file = await this.fetchStandardFontData(standardFontName);
4359           properties.isInternalFont = !!file;
4360         }
4361         if (!properties.isInternalFont && this.options.useSystemFonts) {
4362           properties.systemFontInfo = getFontSubstitution(
4363             this.systemFontCache,
4364             this.idFactory,
4365             this.options.standardFontDataUrl,
4366             baseFontName,
4367             standardFontName,
4368             type
4369           );
4370         }
4371 
4372         const newProperties = await this.extractDataStructures(
4373           dict,
4374           properties
4375         );
4376         if (Array.isArray(widths)) {
4377           const glyphWidths = [];
4378           let j = firstChar;
4379           for (const w of widths) {
4380             const width = this.xref.fetchIfRef(w);
4381             if (typeof width === "number") {
4382               glyphWidths[j] = width;
4383             }
4384             j++;
4385           }
4386           newProperties.widths = glyphWidths;
4387         } else {
4388           newProperties.widths = this.buildCharCodeToWidth(
4389             metrics.widths,
4390             newProperties
4391           );
4392         }
4393         return new Font(baseFontName, file, newProperties, this.options);
4394       }
4395     }
4396 
4397     // According to the spec if 'FontDescriptor' is declared, 'FirstChar',
4398     // 'LastChar' and 'Widths' should exist too, but some PDF encoders seem
4399     // to ignore this rule when a variant of a standard font is used.
4400     // TODO Fill the width array depending on which of the base font this is
4401     // a variant.
4402 
4403     let fontName = descriptor.get("FontName");
4404     let baseFont = dict.get("BaseFont");
4405     // Some bad PDFs have a string as the font name.
4406     if (typeof fontName === "string") {
4407       fontName = Name.get(fontName);
4408     }
4409     if (typeof baseFont === "string") {
4410       baseFont = Name.get(baseFont);
4411     }
4412 
4413     const fontNameStr = fontName?.name;
4414     const baseFontStr = baseFont?.name;
4415     if (!isType3Font && fontNameStr !== baseFontStr) {
4416       info(
4417         `The FontDescriptor's FontName is "${fontNameStr}" but ` +
4418           `should be the same as the Font's BaseFont "${baseFontStr}".`
4419       );
4420       // - Workaround for cases where e.g. fontNameStr = 'Arial' and
4421       //   baseFontStr = 'Arial,Bold' (needed when no font file is embedded).
4422       //
4423       // - Workaround for cases where e.g. fontNameStr = 'wg09np' and
4424       //   baseFontStr = 'Wingdings-Regular' (fixes issue7454.pdf).
4425       if (
4426         fontNameStr &&
4427         baseFontStr &&
4428         (baseFontStr.startsWith(fontNameStr) ||
4429           (!isKnownFontName(fontNameStr) && isKnownFontName(baseFontStr)))
4430       ) {
4431         fontName = null;
4432       }
4433     }
4434     fontName ||= baseFont;
4435 
4436     if (!(fontName instanceof Name)) {
4437       throw new FormatError("invalid font name");
4438     }
4439 
4440     let fontFile, subtype, length1, length2, length3;
4441     try {
4442       fontFile = descriptor.get("FontFile", "FontFile2", "FontFile3");
4443 
4444       if (fontFile) {
4445         if (!(fontFile instanceof BaseStream)) {
4446           throw new FormatError("FontFile should be a stream");
4447         } else if (fontFile.isEmpty) {
4448           throw new FormatError("FontFile is empty");
4449         }
4450       }
4451     } catch (ex) {
4452       if (!this.options.ignoreErrors) {
4453         throw ex;
4454       }
4455       warn(`translateFont - fetching "${fontName.name}" font file: "${ex}".`);
4456       fontFile = null;
4457     }
4458     let isInternalFont = false;
4459     let glyphScaleFactors = null;
4460     let systemFontInfo = null;
4461     if (fontFile) {
4462       if (fontFile.dict) {
4463         const subtypeEntry = fontFile.dict.get("Subtype");
4464         if (subtypeEntry instanceof Name) {
4465           subtype = subtypeEntry.name;
4466         }
4467         length1 = fontFile.dict.get("Length1");
4468         length2 = fontFile.dict.get("Length2");
4469         length3 = fontFile.dict.get("Length3");
4470       }
4471     } else if (cssFontInfo) {
4472       // We've a missing XFA font.
4473       const standardFontName = getXfaFontName(fontName.name);
4474       if (standardFontName) {
4475         cssFontInfo.fontFamily = `${cssFontInfo.fontFamily}-PdfJS-XFA`;
4476         cssFontInfo.metrics = standardFontName.metrics || null;
4477         glyphScaleFactors = standardFontName.factors || null;
4478         fontFile = await this.fetchStandardFontData(standardFontName.name);
4479         isInternalFont = !!fontFile;
4480 
4481         // We're using a substitution font but for example widths (if any)
4482         // are related to the glyph positions in the font.
4483         // So we overwrite everything here to be sure that widths are
4484         // correct.
4485         baseDict = dict = getXfaFontDict(fontName.name);
4486         composite = true;
4487       }
4488     } else if (!isType3Font) {
4489       const standardFontName = getStandardFontName(fontName.name);
4490       if (standardFontName) {
4491         fontFile = await this.fetchStandardFontData(standardFontName);
4492         isInternalFont = !!fontFile;
4493       }
4494       if (!isInternalFont && this.options.useSystemFonts) {
4495         systemFontInfo = getFontSubstitution(
4496           this.systemFontCache,
4497           this.idFactory,
4498           this.options.standardFontDataUrl,
4499           fontName.name,
4500           standardFontName,
4501           type
4502         );
4503       }
4504     }
4505 
4506     const fontMatrix = lookupMatrix(
4507       dict.getArray("FontMatrix"),
4508       FONT_IDENTITY_MATRIX
4509     );
4510     const bbox = lookupNormalRect(
4511       descriptor.getArray("FontBBox") || dict.getArray("FontBBox"),
4512       undefined
4513     );
4514     let ascent = descriptor.get("Ascent");
4515     if (typeof ascent !== "number") {
4516       ascent = undefined;
4517     }
4518     let descent = descriptor.get("Descent");
4519     if (typeof descent !== "number") {
4520       descent = undefined;
4521     }
4522     let xHeight = descriptor.get("XHeight");
4523     if (typeof xHeight !== "number") {
4524       xHeight = 0;
4525     }
4526     let capHeight = descriptor.get("CapHeight");
4527     if (typeof capHeight !== "number") {
4528       capHeight = 0;
4529     }
4530     let flags = descriptor.get("Flags");
4531     if (!Number.isInteger(flags)) {
4532       flags = 0;
4533     }
4534     let italicAngle = descriptor.get("ItalicAngle");
4535     if (typeof italicAngle !== "number") {
4536       italicAngle = 0;
4537     }
4538 
4539     const properties = {
4540       type,
4541       name: fontName.name,
4542       subtype,
4543       file: fontFile,
4544       length1,
4545       length2,
4546       length3,
4547       isInternalFont,
4548       loadedName: baseDict.loadedName,
4549       composite,
4550       fixedPitch: false,
4551       fontMatrix,
4552       firstChar,
4553       lastChar,
4554       toUnicode,
4555       bbox,
4556       ascent,
4557       descent,
4558       xHeight,
4559       capHeight,
4560       flags,
4561       italicAngle,
4562       isType3Font,
4563       cssFontInfo,
4564       scaleFactors: glyphScaleFactors,
4565       systemFontInfo,
4566     };
4567 
4568     if (composite) {
4569       const cidEncoding = baseDict.get("Encoding");
4570       if (cidEncoding instanceof Name) {
4571         properties.cidEncoding = cidEncoding.name;
4572       }
4573       const cMap = await CMapFactory.create({
4574         encoding: cidEncoding,
4575         fetchBuiltInCMap: this._fetchBuiltInCMapBound,
4576         useCMap: null,
4577       });
4578       properties.cMap = cMap;
4579       properties.vertical = properties.cMap.vertical;
4580     }
4581 
4582     const newProperties = await this.extractDataStructures(dict, properties);
4583     this.extractWidths(dict, descriptor, newProperties);
4584 
4585     return new Font(fontName.name, fontFile, newProperties, this.options);
4586   }
4587 
4588   static buildFontPaths(font, glyphs, handler, evaluatorOptions) {
4589     function buildPath(fontChar) {
4590       const glyphName = `${font.loadedName}_path_${fontChar}`;
4591       try {
4592         if (font.renderer.hasBuiltPath(fontChar)) {
4593           return;
4594         }
4595         handler.send("commonobj", [
4596           glyphName,
4597           "FontPath",
4598           font.renderer.getPathJs(fontChar),
4599         ]);
4600       } catch (reason) {
4601         if (evaluatorOptions.ignoreErrors) {
4602           warn(`buildFontPaths - ignoring ${glyphName} glyph: "${reason}".`);
4603           return;
4604         }
4605         throw reason;
4606       }
4607     }
4608 
4609     for (const glyph of glyphs) {
4610       buildPath(glyph.fontChar);
4611 
4612       // If the glyph has an accent we need to build a path for its
4613       // fontChar too, otherwise CanvasGraphics_paintChar will fail.
4614       const accent = glyph.accent;
4615       if (accent?.fontChar) {
4616         buildPath(accent.fontChar);
4617       }
4618     }
4619   }
4620 
4621   static get fallbackFontDict() {
4622     const dict = new Dict();
4623     dict.set("BaseFont", Name.get("Helvetica"));
4624     dict.set("Type", Name.get("FallbackType"));
4625     dict.set("Subtype", Name.get("FallbackType"));
4626     dict.set("Encoding", Name.get("WinAnsiEncoding"));
4627 
4628     return shadow(this, "fallbackFontDict", dict);
4629   }
4630 }
4631 
4632 class TranslatedFont {
4633   #sent = false;
4634 
4635   #type3Loaded = null;
4636 
4637   constructor({ loadedName, font, dict }) {
4638     this.loadedName = loadedName;
4639     this.font = font;
4640     this.dict = dict;
4641     this.type3Dependencies = font.isType3Font ? new Set() : null;
4642   }
4643 
4644   send(handler) {
4645     if (this.#sent) {
4646       return;
4647     }
4648     this.#sent = true;
4649 
4650     handler.send("commonobj", [
4651       this.loadedName,
4652       "Font",
4653       this.font.exportData(),
4654     ]);
4655   }
4656 
4657   fallback(handler, evaluatorOptions) {
4658     if (!this.font.data) {
4659       return;
4660     }
4661     // When font loading failed, fall back to the built-in font renderer.
4662     this.font.disableFontFace = true;
4663     // An arbitrary number of text rendering operators could have been
4664     // encountered between the point in time when the 'Font' message was sent
4665     // to the main-thread, and the point in time when the 'FontFallback'
4666     // message was received on the worker-thread.
4667     // To ensure that all 'FontPath's are available on the main-thread, when
4668     // font loading failed, attempt to resend *all* previously parsed glyphs.
4669     PartialEvaluator.buildFontPaths(
4670       this.font,
4671       /* glyphs = */ this.font.glyphCacheValues,
4672       handler,
4673       evaluatorOptions
4674     );
4675   }
4676 
4677   loadType3Data(evaluator, resources, task) {
4678     if (this.#type3Loaded) {
4679       return this.#type3Loaded;
4680     }
4681     const { font, type3Dependencies } = this;
4682     assert(font.isType3Font, "Must be a Type3 font.");
4683 
4684     // When parsing Type3 glyphs, always ignore them if there are errors.
4685     // Compared to the parsing of e.g. an entire page, it doesn't really
4686     // make sense to only be able to render a Type3 glyph partially.
4687     const type3Evaluator = evaluator.clone({ ignoreErrors: false });
4688     // Prevent circular references in Type3 fonts.
4689     const type3FontRefs = new RefSet(evaluator.type3FontRefs);
4690     if (this.dict.objId && !type3FontRefs.has(this.dict.objId)) {
4691       type3FontRefs.put(this.dict.objId);
4692     }
4693     type3Evaluator.type3FontRefs = type3FontRefs;
4694 
4695     let loadCharProcsPromise = Promise.resolve();
4696     const charProcs = this.dict.get("CharProcs");
4697     const fontResources = this.dict.get("Resources") || resources;
4698     const charProcOperatorList = Object.create(null);
4699 
4700     const fontBBox = Util.normalizeRect(font.bbox || [0, 0, 0, 0]),
4701       width = fontBBox[2] - fontBBox[0],
4702       height = fontBBox[3] - fontBBox[1];
4703     const fontBBoxSize = Math.hypot(width, height);
4704 
4705     for (const key of charProcs.getKeys()) {
4706       loadCharProcsPromise = loadCharProcsPromise.then(() => {
4707         const glyphStream = charProcs.get(key);
4708         const operatorList = new OperatorList();
4709         return type3Evaluator
4710           .getOperatorList({
4711             stream: glyphStream,
4712             task,
4713             resources: fontResources,
4714             operatorList,
4715           })
4716           .then(() => {
4717             // According to the PDF specification, section "9.6.5 Type 3 Fonts"
4718             // and "Table 113":
4719             //  "A glyph description that begins with the d1 operator should
4720             //   not execute any operators that set the colour (or other
4721             //   colour-related parameters) in the graphics state;
4722             //   any use of such operators shall be ignored."
4723             switch (operatorList.fnArray[0]) {
4724               case OPS.setCharWidthAndBounds:
4725                 this.#removeType3ColorOperators(operatorList, fontBBoxSize);
4726                 break;
4727               case OPS.setCharWidth:
4728                 if (!fontBBoxSize) {
4729                   this.#guessType3FontBBox(operatorList);
4730                 }
4731                 break;
4732             }
4733             charProcOperatorList[key] = operatorList.getIR();
4734 
4735             for (const dependency of operatorList.dependencies) {
4736               type3Dependencies.add(dependency);
4737             }
4738           })
4739           .catch(function (reason) {
4740             warn(`Type3 font resource "${key}" is not available.`);
4741             const dummyOperatorList = new OperatorList();
4742             charProcOperatorList[key] = dummyOperatorList.getIR();
4743           });
4744       });
4745     }
4746     this.#type3Loaded = loadCharProcsPromise.then(() => {
4747       font.charProcOperatorList = charProcOperatorList;
4748       if (this._bbox) {
4749         font.isCharBBox = true;
4750         font.bbox = this._bbox;
4751       }
4752     });
4753     return this.#type3Loaded;
4754   }
4755 
4756   #removeType3ColorOperators(operatorList, fontBBoxSize = NaN) {
4757     if (typeof PDFJSDev === "undefined" || PDFJSDev.test("TESTING")) {
4758       assert(
4759         operatorList.fnArray[0] === OPS.setCharWidthAndBounds,
4760         "Type3 glyph shall start with the d1 operator."
4761       );
4762     }
4763     const charBBox = Util.normalizeRect(operatorList.argsArray[0].slice(2)),
4764       width = charBBox[2] - charBBox[0],
4765       height = charBBox[3] - charBBox[1];
4766     const charBBoxSize = Math.hypot(width, height);
4767 
4768     if (width === 0 || height === 0) {
4769       // Skip the d1 operator when its bounds are bogus (fixes issue14953.pdf).
4770       operatorList.fnArray.splice(0, 1);
4771       operatorList.argsArray.splice(0, 1);
4772     } else if (
4773       fontBBoxSize === 0 ||
4774       Math.round(charBBoxSize / fontBBoxSize) >= 10
4775     ) {
4776       // Override the fontBBox when it's undefined/empty, or when it's at least
4777       // (approximately) one order of magnitude smaller than the charBBox
4778       // (fixes issue14999_reduced.pdf).
4779       this._bbox ??= [Infinity, Infinity, -Infinity, -Infinity];
4780       Util.rectBoundingBox(...charBBox, this._bbox);
4781     }
4782 
4783     let i = 0,
4784       ii = operatorList.length;
4785     while (i < ii) {
4786       switch (operatorList.fnArray[i]) {
4787         case OPS.setCharWidthAndBounds:
4788           break; // Handled above.
4789         case OPS.setStrokeColorSpace:
4790         case OPS.setFillColorSpace:
4791         case OPS.setStrokeColor:
4792         case OPS.setStrokeColorN:
4793         case OPS.setFillColor:
4794         case OPS.setFillColorN:
4795         case OPS.setStrokeGray:
4796         case OPS.setFillGray:
4797         case OPS.setStrokeRGBColor:
4798         case OPS.setFillRGBColor:
4799         case OPS.setStrokeCMYKColor:
4800         case OPS.setFillCMYKColor:
4801         case OPS.shadingFill:
4802         case OPS.setRenderingIntent:
4803           operatorList.fnArray.splice(i, 1);
4804           operatorList.argsArray.splice(i, 1);
4805           ii--;
4806           continue;
4807 
4808         case OPS.setGState:
4809           const [gStateObj] = operatorList.argsArray[i];
4810           let j = 0,
4811             jj = gStateObj.length;
4812           while (j < jj) {
4813             const [gStateKey] = gStateObj[j];
4814             switch (gStateKey) {
4815               case "TR":
4816               case "TR2":
4817               case "HT":
4818               case "BG":
4819               case "BG2":
4820               case "UCR":
4821               case "UCR2":
4822                 gStateObj.splice(j, 1);
4823                 jj--;
4824                 continue;
4825             }
4826             j++;
4827           }
4828           break;
4829       }
4830       i++;
4831     }
4832   }
4833 
4834   #guessType3FontBBox(operatorList) {
4835     if (typeof PDFJSDev === "undefined" || PDFJSDev.test("TESTING")) {
4836       assert(
4837         operatorList.fnArray[0] === OPS.setCharWidth,
4838         "Type3 glyph shall start with the d0 operator."
4839       );
4840     }
4841 
4842     let i = 1;
4843     const ii = operatorList.length;
4844     while (i < ii) {
4845       switch (operatorList.fnArray[i]) {
4846         case OPS.constructPath:
4847           const minMax = operatorList.argsArray[i][2];
4848           // Override the fontBBox when it's undefined/empty (fixes 19624.pdf).
4849           this._bbox ??= [Infinity, Infinity, -Infinity, -Infinity];
4850           Util.rectBoundingBox(...minMax, this._bbox);
4851           break;
4852       }
4853       i++;
4854     }
4855   }
4856 }
4857 
4858 class StateManager {
4859   constructor(initialState = new EvalState()) {
4860     this.state = initialState;
4861     this.stateStack = [];
4862   }
4863 
4864   save() {
4865     const old = this.state;
4866     this.stateStack.push(this.state);
4867     this.state = old.clone();
4868   }
4869 
4870   restore() {
4871     const prev = this.stateStack.pop();
4872     if (prev) {
4873       this.state = prev;
4874     }
4875   }
4876 
4877   transform(args) {
4878     this.state.ctm = Util.transform(this.state.ctm, args);
4879   }
4880 }
4881 
4882 class TextState {
4883   constructor() {
4884     this.ctm = new Float32Array(IDENTITY_MATRIX);
4885     this.fontName = null;
4886     this.fontSize = 0;
4887     this.loadedName = null;
4888     this.font = null;
4889     this.fontMatrix = FONT_IDENTITY_MATRIX;
4890     this.textMatrix = IDENTITY_MATRIX.slice();
4891     this.textLineMatrix = IDENTITY_MATRIX.slice();
4892     this.charSpacing = 0;
4893     this.wordSpacing = 0;
4894     this.leading = 0;
4895     this.textHScale = 1;
4896     this.textRise = 0;
4897   }
4898 
4899   setTextMatrix(a, b, c, d, e, f) {
4900     const m = this.textMatrix;
4901     m[0] = a;
4902     m[1] = b;
4903     m[2] = c;
4904     m[3] = d;
4905     m[4] = e;
4906     m[5] = f;
4907   }
4908 
4909   setTextLineMatrix(a, b, c, d, e, f) {
4910     const m = this.textLineMatrix;
4911     m[0] = a;
4912     m[1] = b;
4913     m[2] = c;
4914     m[3] = d;
4915     m[4] = e;
4916     m[5] = f;
4917   }
4918 
4919   translateTextMatrix(x, y) {
4920     const m = this.textMatrix;
4921     m[4] = m[0] * x + m[2] * y + m[4];
4922     m[5] = m[1] * x + m[3] * y + m[5];
4923   }
4924 
4925   translateTextLineMatrix(x, y) {
4926     const m = this.textLineMatrix;
4927     m[4] = m[0] * x + m[2] * y + m[4];
4928     m[5] = m[1] * x + m[3] * y + m[5];
4929   }
4930 
4931   carriageReturn() {
4932     this.translateTextLineMatrix(0, -this.leading);
4933     this.textMatrix = this.textLineMatrix.slice();
4934   }
4935 
4936   clone() {
4937     const clone = Object.create(this);
4938     clone.textMatrix = this.textMatrix.slice();
4939     clone.textLineMatrix = this.textLineMatrix.slice();
4940     clone.fontMatrix = this.fontMatrix.slice();
4941     return clone;
4942   }
4943 }
4944 
4945 class EvalState {
4946   constructor() {
4947     this.ctm = new Float32Array(IDENTITY_MATRIX);
4948     this.font = null;
4949     this.textRenderingMode = TextRenderingMode.FILL;
4950     this._fillColorSpace = this._strokeColorSpace = ColorSpaceUtils.gray;
4951     this.patternFillColorSpace = null;
4952     this.patternStrokeColorSpace = null;
4953 
4954     // Path stuff.
4955     this.currentPointX = this.currentPointY = 0;
4956     this.pathMinMax = new Float32Array([
4957       Infinity,
4958       Infinity,
4959       -Infinity,
4960       -Infinity,
4961     ]);
4962     this.pathBuffer = [];
4963   }
4964 
4965   get fillColorSpace() {
4966     return this._fillColorSpace;
4967   }
4968 
4969   set fillColorSpace(colorSpace) {
4970     this._fillColorSpace = this.patternFillColorSpace = colorSpace;
4971   }
4972 
4973   get strokeColorSpace() {
4974     return this._strokeColorSpace;
4975   }
4976 
4977   set strokeColorSpace(colorSpace) {
4978     this._strokeColorSpace = this.patternStrokeColorSpace = colorSpace;
4979   }
4980 
4981   clone({ newPath = false } = {}) {
4982     const clone = Object.create(this);
4983     if (newPath) {
4984       clone.pathBuffer = [];
4985       clone.pathMinMax = new Float32Array([
4986         Infinity,
4987         Infinity,
4988         -Infinity,
4989         -Infinity,
4990       ]);
4991     }
4992     return clone;
4993   }
4994 }
4995 
4996 class EvaluatorPreprocessor {
4997   static get opMap() {
4998     // Specifies properties for each command
4999     //
5000     // If variableArgs === true: [0, `numArgs`] expected
5001     // If variableArgs === false: exactly `numArgs` expected
5002     return shadow(
5003       this,
5004       "opMap",
5005       Object.assign(Object.create(null), {
5006         // Graphic state
5007         w: { id: OPS.setLineWidth, numArgs: 1, variableArgs: false },
5008         J: { id: OPS.setLineCap, numArgs: 1, variableArgs: false },
5009         j: { id: OPS.setLineJoin, numArgs: 1, variableArgs: false },
5010         M: { id: OPS.setMiterLimit, numArgs: 1, variableArgs: false },
5011         d: { id: OPS.setDash, numArgs: 2, variableArgs: false },
5012         ri: { id: OPS.setRenderingIntent, numArgs: 1, variableArgs: false },
5013         i: { id: OPS.setFlatness, numArgs: 1, variableArgs: false },
5014         gs: { id: OPS.setGState, numArgs: 1, variableArgs: false },
5015         q: { id: OPS.save, numArgs: 0, variableArgs: false },
5016         Q: { id: OPS.restore, numArgs: 0, variableArgs: false },
5017         cm: { id: OPS.transform, numArgs: 6, variableArgs: false },
5018 
5019         // Path
5020         m: { id: OPS.moveTo, numArgs: 2, variableArgs: false },
5021         l: { id: OPS.lineTo, numArgs: 2, variableArgs: false },
5022         c: { id: OPS.curveTo, numArgs: 6, variableArgs: false },
5023         v: { id: OPS.curveTo2, numArgs: 4, variableArgs: false },
5024         y: { id: OPS.curveTo3, numArgs: 4, variableArgs: false },
5025         h: { id: OPS.closePath, numArgs: 0, variableArgs: false },
5026         re: { id: OPS.rectangle, numArgs: 4, variableArgs: false },
5027         S: { id: OPS.stroke, numArgs: 0, variableArgs: false },
5028         s: { id: OPS.closeStroke, numArgs: 0, variableArgs: false },
5029         f: { id: OPS.fill, numArgs: 0, variableArgs: false },
5030         F: { id: OPS.fill, numArgs: 0, variableArgs: false },
5031         "f*": { id: OPS.eoFill, numArgs: 0, variableArgs: false },
5032         B: { id: OPS.fillStroke, numArgs: 0, variableArgs: false },
5033         "B*": { id: OPS.eoFillStroke, numArgs: 0, variableArgs: false },
5034         b: { id: OPS.closeFillStroke, numArgs: 0, variableArgs: false },
5035         "b*": { id: OPS.closeEOFillStroke, numArgs: 0, variableArgs: false },
5036         n: { id: OPS.endPath, numArgs: 0, variableArgs: false },
5037 
5038         // Clipping
5039         W: { id: OPS.clip, numArgs: 0, variableArgs: false },
5040         "W*": { id: OPS.eoClip, numArgs: 0, variableArgs: false },
5041 
5042         // Text
5043         BT: { id: OPS.beginText, numArgs: 0, variableArgs: false },
5044         ET: { id: OPS.endText, numArgs: 0, variableArgs: false },
5045         Tc: { id: OPS.setCharSpacing, numArgs: 1, variableArgs: false },
5046         Tw: { id: OPS.setWordSpacing, numArgs: 1, variableArgs: false },
5047         Tz: { id: OPS.setHScale, numArgs: 1, variableArgs: false },
5048         TL: { id: OPS.setLeading, numArgs: 1, variableArgs: false },
5049         Tf: { id: OPS.setFont, numArgs: 2, variableArgs: false },
5050         Tr: { id: OPS.setTextRenderingMode, numArgs: 1, variableArgs: false },
5051         Ts: { id: OPS.setTextRise, numArgs: 1, variableArgs: false },
5052         Td: { id: OPS.moveText, numArgs: 2, variableArgs: false },
5053         TD: { id: OPS.setLeadingMoveText, numArgs: 2, variableArgs: false },
5054         Tm: { id: OPS.setTextMatrix, numArgs: 6, variableArgs: false },
5055         "T*": { id: OPS.nextLine, numArgs: 0, variableArgs: false },
5056         Tj: { id: OPS.showText, numArgs: 1, variableArgs: false },
5057         TJ: { id: OPS.showSpacedText, numArgs: 1, variableArgs: false },
5058         "'": { id: OPS.nextLineShowText, numArgs: 1, variableArgs: false },
5059         '"': {
5060           id: OPS.nextLineSetSpacingShowText,
5061           numArgs: 3,
5062           variableArgs: false,
5063         },
5064 
5065         // Type3 fonts
5066         d0: { id: OPS.setCharWidth, numArgs: 2, variableArgs: false },
5067         d1: {
5068           id: OPS.setCharWidthAndBounds,
5069           numArgs: 6,
5070           variableArgs: false,
5071         },
5072 
5073         // Color
5074         CS: { id: OPS.setStrokeColorSpace, numArgs: 1, variableArgs: false },
5075         cs: { id: OPS.setFillColorSpace, numArgs: 1, variableArgs: false },
5076         SC: { id: OPS.setStrokeColor, numArgs: 4, variableArgs: true },
5077         SCN: { id: OPS.setStrokeColorN, numArgs: 33, variableArgs: true },
5078         sc: { id: OPS.setFillColor, numArgs: 4, variableArgs: true },
5079         scn: { id: OPS.setFillColorN, numArgs: 33, variableArgs: true },
5080         G: { id: OPS.setStrokeGray, numArgs: 1, variableArgs: false },
5081         g: { id: OPS.setFillGray, numArgs: 1, variableArgs: false },
5082         RG: { id: OPS.setStrokeRGBColor, numArgs: 3, variableArgs: false },
5083         rg: { id: OPS.setFillRGBColor, numArgs: 3, variableArgs: false },
5084         K: { id: OPS.setStrokeCMYKColor, numArgs: 4, variableArgs: false },
5085         k: { id: OPS.setFillCMYKColor, numArgs: 4, variableArgs: false },
5086 
5087         // Shading
5088         sh: { id: OPS.shadingFill, numArgs: 1, variableArgs: false },
5089 
5090         // Images
5091         BI: { id: OPS.beginInlineImage, numArgs: 0, variableArgs: false },
5092         ID: { id: OPS.beginImageData, numArgs: 0, variableArgs: false },
5093         EI: { id: OPS.endInlineImage, numArgs: 1, variableArgs: false },
5094 
5095         // XObjects
5096         Do: { id: OPS.paintXObject, numArgs: 1, variableArgs: false },
5097         MP: { id: OPS.markPoint, numArgs: 1, variableArgs: false },
5098         DP: { id: OPS.markPointProps, numArgs: 2, variableArgs: false },
5099         BMC: { id: OPS.beginMarkedContent, numArgs: 1, variableArgs: false },
5100         BDC: {
5101           id: OPS.beginMarkedContentProps,
5102           numArgs: 2,
5103           variableArgs: false,
5104         },
5105         EMC: { id: OPS.endMarkedContent, numArgs: 0, variableArgs: false },
5106 
5107         // Compatibility
5108         BX: { id: OPS.beginCompat, numArgs: 0, variableArgs: false },
5109         EX: { id: OPS.endCompat, numArgs: 0, variableArgs: false },
5110 
5111         // (reserved partial commands for the lexer)
5112         BM: null,
5113         BD: null,
5114         true: null,
5115         fa: null,
5116         fal: null,
5117         fals: null,
5118         false: null,
5119         nu: null,
5120         nul: null,
5121         null: null,
5122       })
5123     );
5124   }
5125 
5126   static MAX_INVALID_PATH_OPS = 10;
5127 
5128   constructor(stream, xref, stateManager = new StateManager()) {
5129     // TODO(mduan): pass array of knownCommands rather than this.opMap
5130     // dictionary
5131     this.parser = new Parser({
5132       lexer: new Lexer(stream, EvaluatorPreprocessor.opMap),
5133       xref,
5134     });
5135     this.stateManager = stateManager;
5136     this.nonProcessedArgs = [];
5137     this._isPathOp = false;
5138     this._numInvalidPathOPS = 0;
5139   }
5140 
5141   get savedStatesDepth() {
5142     return this.stateManager.stateStack.length;
5143   }
5144 
5145   // |operation| is an object with two fields:
5146   //
5147   // - |fn| is an out param.
5148   //
5149   // - |args| is an inout param. On entry, it should have one of two values.
5150   //
5151   //   - An empty array. This indicates that the caller is providing the
5152   //     array in which the args will be stored in. The caller should use
5153   //     this value if it can reuse a single array for each call to read().
5154   //
5155   //   - |null|. This indicates that the caller needs this function to create
5156   //     the array in which any args are stored in. If there are zero args,
5157   //     this function will leave |operation.args| as |null| (thus avoiding
5158   //     allocations that would occur if we used an empty array to represent
5159   //     zero arguments). Otherwise, it will replace |null| with a new array
5160   //     containing the arguments. The caller should use this value if it
5161   //     cannot reuse an array for each call to read().
5162   //
5163   // These two modes are present because this function is very hot and so
5164   // avoiding allocations where possible is worthwhile.
5165   //
5166   read(operation) {
5167     let args = operation.args;
5168     while (true) {
5169       const obj = this.parser.getObj();
5170       if (obj instanceof Cmd) {
5171         const cmd = obj.cmd;
5172         // Check that the command is valid
5173         const opSpec = EvaluatorPreprocessor.opMap[cmd];
5174         if (!opSpec) {
5175           warn(`Unknown command "${cmd}".`);
5176           continue;
5177         }
5178 
5179         const fn = opSpec.id;
5180         const numArgs = opSpec.numArgs;
5181         let argsLength = args !== null ? args.length : 0;
5182 
5183         // If the *previous* command wasn't a path operator, reset the heuristic
5184         // used with incomplete path operators below (fixes issue14917.pdf).
5185         if (!this._isPathOp) {
5186           this._numInvalidPathOPS = 0;
5187         }
5188         this._isPathOp = fn >= OPS.moveTo && fn <= OPS.endPath;
5189 
5190         if (!opSpec.variableArgs) {
5191           // Postscript commands can be nested, e.g. /F2 /GS2 gs 5.711 Tf
5192           if (argsLength !== numArgs) {
5193             const nonProcessedArgs = this.nonProcessedArgs;
5194             while (argsLength > numArgs) {
5195               nonProcessedArgs.push(args.shift());
5196               argsLength--;
5197             }
5198             while (argsLength < numArgs && nonProcessedArgs.length !== 0) {
5199               if (args === null) {
5200                 args = [];
5201               }
5202               args.unshift(nonProcessedArgs.pop());
5203               argsLength++;
5204             }
5205           }
5206 
5207           if (argsLength < numArgs) {
5208             const partialMsg =
5209               `command ${cmd}: expected ${numArgs} args, ` +
5210               `but received ${argsLength} args.`;
5211 
5212             // Incomplete path operators, in particular, can result in fairly
5213             // chaotic rendering artifacts. Hence the following heuristics is
5214             // used to error, rather than just warn, once a number of invalid
5215             // path operators have been encountered (fixes bug1443140.pdf).
5216             if (
5217               this._isPathOp &&
5218               ++this._numInvalidPathOPS >
5219                 EvaluatorPreprocessor.MAX_INVALID_PATH_OPS
5220             ) {
5221               throw new FormatError(`Invalid ${partialMsg}`);
5222             }
5223             // If we receive too few arguments, it's not possible to execute
5224             // the command, hence we skip the command.
5225             warn(`Skipping ${partialMsg}`);
5226             if (args !== null) {
5227               args.length = 0;
5228             }
5229             continue;
5230           }
5231         } else if (argsLength > numArgs) {
5232           info(
5233             `Command ${cmd}: expected [0, ${numArgs}] args, ` +
5234               `but received ${argsLength} args.`
5235           );
5236         }
5237 
5238         // TODO figure out how to type-check vararg functions
5239         this.preprocessCommand(fn, args);
5240 
5241         operation.fn = fn;
5242         operation.args = args;
5243         return true;
5244       }
5245       if (obj === EOF) {
5246         return false; // no more commands
5247       }
5248       // argument
5249       if (obj !== null) {
5250         if (args === null) {
5251           args = [];
5252         }
5253         args.push(obj);
5254         if (args.length > 33) {
5255           throw new FormatError("Too many arguments");
5256         }
5257       }
5258     }
5259   }
5260 
5261   preprocessCommand(fn, args) {
5262     switch (fn | 0) {
5263       case OPS.save:
5264         this.stateManager.save();
5265         break;
5266       case OPS.restore:
5267         this.stateManager.restore();
5268         break;
5269       case OPS.transform:
5270         this.stateManager.transform(args);
5271         break;
5272     }
5273   }
5274 }
5275 
5276 export { EvaluatorPreprocessor, PartialEvaluator };
</code>

Your task:
You are a software tester at pdf.js.
1. Write exactly one javascript test `it("...", async () => {...})` block.
2. Your test must fail on the code before the patch, and pass after, hence the test will verify that the patch resolves the issue.
3. The test must be self-contained and to-the-point.
4. Use only the provided imports (respect the paths exactly how they are given) by importing dynamically for compatibility with Node.js — no new dependencies. You can use the PDF file for testing as follows:
const { getDocument } = await import('../../src/display/api.js');
const { buildGetDocumentParams } = await import('./test_utils.js');
const loadingTask = getDocument(buildGetDocumentParams('issue19848.pdf'))
5. Return only the javascript code (no comments or explanations).

Example structure:
it("should <describe behavior>", async () => {
  const { example } = await import("../../src/core/example.js");
  <initialize required variables>;
  <define expected variable>;
  <generate actual variables>;
  <compare expected with actual>;
});

