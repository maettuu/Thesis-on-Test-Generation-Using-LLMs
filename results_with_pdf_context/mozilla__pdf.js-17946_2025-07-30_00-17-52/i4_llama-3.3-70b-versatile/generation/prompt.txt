Before you begin:
- Keep going until the job is completely solved — don’t stop halfway.
- If you’re unsure about the behavior, reread the provided patch carefully; do not hallucinate.
- Plan your approach before writing code by reflecting on whether the test truly fails before and passes after.

Issue:
<issue>
PDF.js doesn't render large images in PDF that other renderers do
Link to PDF file: [example.pdf](https://github.com/mozilla/pdf.js/files/13391396/example.pdf)

- Firefox 119.0.1 (64-bit), Chromium 119.0.6045.159 (Official Build) snap (64-bit)
- Ubuntu Linux 23.04.
- PDF.js version: 4.0.189 [50f52b43a]
- Is a browser extension: no.

Steps to reproduce the problem:
1. Just open the PDF on PDF.js

What is the expected behavior?
Notice the scanned book page image gets rendered:
![image](https://github.com/mozilla/pdf.js/assets/163011/859e9d01-22cb-44cf-98bc-f0f77759b54c)
Screenshot take from Atril Document Viewer.

What went wrong?
Notice the scanned book page does not get rendered here:
![image](https://github.com/mozilla/pdf.js/assets/163011/90bb7ab0-a7a5-43ad-8c5a-2cc4f1cf0066)

Console log:
PDF 247b3d402477644b1b7b61c8c1311da0 [1.6 PDF24 / PDF24] (PDF.js: 4.0.189 [50f52b43a]) [viewer.mjs:12052:13]
Warning: Unsupported header type 1970628964 (uuid). 2 [pdf.worker.mjs:339:13]
Warning: JPX: Unsupported COD options (terminationOnEachCodingPass, verticallyStripe, predictableTermination). 08:55:09.017 Warning: Unable to decode image "img_p0_1": "JpxError: JPX error: JPX error: Invalid tag tree".
Warning: Dependent image isn't ready yet

Last three lines repeat for every scanned page image.
</issue>

PDF File:
<pdf>
issue17289.pdf
</pdf>

Patch:
<patch>
diff --git a/src/core/cleanup_helper.js b/src/core/cleanup_helper.js
--- a/src/core/cleanup_helper.js
+++ b/src/core/cleanup_helper.js
@@ -16,11 +16,16 @@
 import { clearPatternCaches } from "./pattern.js";
 import { clearPrimitiveCaches } from "./primitives.js";
 import { clearUnicodeCaches } from "./unicode.js";
+import { JpxImage } from "./jpx.js";
 
 function clearGlobalCaches() {
   clearPatternCaches();
   clearPrimitiveCaches();
   clearUnicodeCaches();
+
+  // Remove the global `JpxImage` instance, since it may hold a reference to
+  // the WebAssembly module.
+  JpxImage.cleanup();
 }
 
 export { clearGlobalCaches };

diff --git a/src/core/decode_stream.js b/src/core/decode_stream.js
--- a/src/core/decode_stream.js
+++ b/src/core/decode_stream.js
@@ -73,7 +73,7 @@ class DecodeStream extends BaseStream {
     return this.buffer[this.pos++];
   }
 
-  getBytes(length) {
+  getBytes(length, ignoreColorSpace = false) {
     const pos = this.pos;
     let end;
 
@@ -82,7 +82,7 @@ class DecodeStream extends BaseStream {
       end = pos + length;
 
       while (!this.eof && this.bufferLength < end) {
-        this.readBlock();
+        this.readBlock(ignoreColorSpace);
       }
       const bufEnd = this.bufferLength;
       if (end > bufEnd) {
@@ -90,7 +90,7 @@ class DecodeStream extends BaseStream {
       }
     } else {
       while (!this.eof) {
-        this.readBlock();
+        this.readBlock(ignoreColorSpace);
       }
       end = this.bufferLength;
     }

diff --git a/src/core/image.js b/src/core/image.js
--- a/src/core/image.js
+++ b/src/core/image.js
@@ -104,6 +104,7 @@ class PDFImage {
     localColorSpaceCache,
   }) {
     this.image = image;
+    let jpxDecode = false;
     const dict = image.dict;
 
     const filter = dict.get("F", "Filter");
@@ -118,14 +119,14 @@ class PDFImage {
     }
     switch (filterName) {
       case "JPXDecode":
-        const jpxImage = new JpxImage();
-        jpxImage.parseImageProperties(image.stream);
+        ({
+          width: image.width,
+          height: image.height,
+          componentsCount: image.numComps,
+          bitsPerComponent: image.bitsPerComponent,
+        } = JpxImage.parseImageProperties(image.stream));
         image.stream.reset();
-
-        image.width = jpxImage.width;
-        image.height = jpxImage.height;
-        image.bitsPerComponent = jpxImage.bitsPerComponent;
-        image.numComps = jpxImage.componentsCount;
+        jpxDecode = true;
         break;
       case "JBIG2Decode":
         image.bitsPerComponent = 1;
@@ -197,6 +198,7 @@ class PDFImage {
             );
         }
       }
+
       this.colorSpace = ColorSpace.parse({
         cs: colorSpace,
         xref,
@@ -205,6 +207,10 @@ class PDFImage {
         localColorSpaceCache,
       });
       this.numComps = this.colorSpace.numComps;
+
+      // If the jpx image has a color space then it musn't be used in order to
+      // be able to use the color space that comes from the pdf.
+      this.ignoreColorSpace = jpxDecode && this.colorSpace.name === "Indexed";
     }
 
     this.decode = dict.getArray("D", "Decode");
@@ -984,7 +990,7 @@ class PDFImage {
     this.image.drawHeight = drawHeight || this.height;
     this.image.forceRGBA = !!forceRGBA;
     this.image.forceRGB = !!forceRGB;
-    const imageBytes = this.image.getBytes(length);
+    const imageBytes = this.image.getBytes(length, this.ignoreColorSpace);
 
     // If imageBytes came from a DecodeStream, we're safe to transfer it
     // (and thus detach its underlying buffer) because it will constitute

diff --git a/src/core/jpx.js b/src/core/jpx.js
--- a/src/core/jpx.js
+++ b/src/core/jpx.js
@@ -1,4 +1,4 @@
-/* Copyright 2012 Mozilla Foundation
+/* Copyright 2024 Mozilla Foundation
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,9 +13,8 @@
  * limitations under the License.
  */
 
-import { BaseException, info, unreachable, warn } from "../shared/util.js";
-import { log2, readUint16, readUint32 } from "./core_utils.js";
-import { ArithmeticDecoder } from "./arithmetic_decoder.js";
+import { BaseException } from "../shared/util.js";
+import OpenJPEG from "../../external/openjpeg/openjpeg.js";
 
 class JpxError extends BaseException {
   constructor(msg) {
@@ -23,106 +22,25 @@ class JpxError extends BaseException {
   }
 }
 
-// Table E.1
-const SubbandsGainLog2 = {
-  LL: 0,
-  LH: 1,
-  HL: 1,
-  HH: 2,
-};
-
 class JpxImage {
-  constructor() {
-    this.failOnCorruptedImage = false;
-  }
+  static #module = null;
 
-  parse(data) {
-    const head = readUint16(data, 0);
-    // No box header, immediate start of codestream (SOC)
-    if (head === 0xff4f) {
-      this.parseCodestream(data, 0, data.length);
-      return;
+  static decode(data, ignoreColorSpace) {
+    this.#module ||= OpenJPEG();
+    const imageData = this.#module.decode(data, ignoreColorSpace);
+    if (!imageData) {
+      throw new JpxError("JPX decode failed");
     }
+    return imageData;
+  }
 
-    const length = data.length;
-    let position = 0;
-    while (position < length) {
-      let headerSize = 8;
-      let lbox = readUint32(data, position);
-      const tbox = readUint32(data, position + 4);
-      position += headerSize;
-      if (lbox === 1) {
-        // XLBox: read UInt64 according to spec.
-        // JavaScript's int precision of 53 bit should be sufficient here.
-        lbox =
-          readUint32(data, position) * 4294967296 +
-          readUint32(data, position + 4);
-        position += 8;
-        headerSize += 8;
-      }
-      if (lbox === 0) {
-        lbox = length - position + headerSize;
-      }
-      if (lbox < headerSize) {
-        throw new JpxError("Invalid box field size");
-      }
-      const dataLength = lbox - headerSize;
-      let jumpDataLength = true;
-      switch (tbox) {
-        case 0x6a703268: // 'jp2h'
-          jumpDataLength = false; // parsing child boxes
-          break;
-        case 0x636f6c72: // 'colr'
-          // Colorspaces are not used, the CS from the PDF is used.
-          const method = data[position];
-          if (method === 1) {
-            // enumerated colorspace
-            const colorspace = readUint32(data, position + 3);
-            switch (colorspace) {
-              case 16: // this indicates a sRGB colorspace
-              case 17: // this indicates a grayscale colorspace
-              case 18: // this indicates a YUV colorspace
-                break;
-              default:
-                warn("Unknown colorspace " + colorspace);
-                break;
-            }
-          } else if (method === 2) {
-            info("ICC profile not supported");
-          }
-          break;
-        case 0x6a703263: // 'jp2c'
-          this.parseCodestream(data, position, position + dataLength);
-          break;
-        case 0x6a502020: // 'jP\024\024'
-          if (readUint32(data, position) !== 0x0d0a870a) {
-            warn("Invalid JP2 signature");
-          }
-          break;
-        // The following header types are valid but currently not used:
-        case 0x6a501a1a: // 'jP\032\032'
-        case 0x66747970: // 'ftyp'
-        case 0x72726571: // 'rreq'
-        case 0x72657320: // 'res '
-        case 0x69686472: // 'ihdr'
-          break;
-        default:
-          const headerType = String.fromCharCode(
-            (tbox >> 24) & 0xff,
-            (tbox >> 16) & 0xff,
-            (tbox >> 8) & 0xff,
-            tbox & 0xff
-          );
-          warn(`Unsupported header type ${tbox} (${headerType}).`);
-          break;
-      }
-      if (jumpDataLength) {
-        position += dataLength;
-      }
-    }
+  static cleanup() {
+    this.#module = null;
   }
 
-  parseImageProperties(stream) {
+  static parseImageProperties(stream) {
+    // No need to use OpenJPEG here since we're only getting very basic
+    // information which are located in the first bytes of the file.
     let newByte = stream.getByte();
     while (newByte >= 0) {
       const oldByte = newByte;
@@ -137,2212 +55,16 @@ class JpxImage {
         const YOsiz = stream.getInt32() >>> 0; // Byte 16
         stream.skip(16);
         const Csiz = stream.getUint16(); // Byte 36
-        this.width = Xsiz - XOsiz;
-        this.height = Ysiz - YOsiz;
-        this.componentsCount = Csiz;
-        // Results are always returned as `Uint8ClampedArray`s.
-        this.bitsPerComponent = 8;
-        return;
-      }
-    }
-    throw new JpxError("No size marker found in JPX stream");
-  }
-
-  parseCodestream(data, start, end) {
-    const context = {};
-    let doNotRecover = false;
-    try {
-      let position = start;
-      while (position + 1 < end) {
-        const code = readUint16(data, position);
-        position += 2;
-
-        let length = 0,
-          j,
-          sqcd,
-          spqcds,
-          spqcdSize,
-          scalarExpounded,
-          tile;
-        switch (code) {
-          case 0xff4f: // Start of codestream (SOC)
-            context.mainHeader = true;
-            break;
-          case 0xffd9: // End of codestream (EOC)
-            break;
-          case 0xff51: // Image and tile size (SIZ)
-            length = readUint16(data, position);
-            const siz = {};
-            siz.Xsiz = readUint32(data, position + 4);
-            siz.Ysiz = readUint32(data, position + 8);
-            siz.XOsiz = readUint32(data, position + 12);
-            siz.YOsiz = readUint32(data, position + 16);
-            siz.XTsiz = readUint32(data, position + 20);
-            siz.YTsiz = readUint32(data, position + 24);
-            siz.XTOsiz = readUint32(data, position + 28);
-            siz.YTOsiz = readUint32(data, position + 32);
-            const componentsCount = readUint16(data, position + 36);
-            siz.Csiz = componentsCount;
-            const components = [];
-            j = position + 38;
-            for (let i = 0; i < componentsCount; i++) {
-              const component = {
-                precision: (data[j] & 0x7f) + 1,
-                isSigned: !!(data[j] & 0x80),
-                XRsiz: data[j + 1],
-                YRsiz: data[j + 2],
-              };
-              j += 3;
-              calculateComponentDimensions(component, siz);
-              components.push(component);
-            }
-            context.SIZ = siz;
-            context.components = components;
-            calculateTileGrids(context, components);
-            context.QCC = [];
-            context.COC = [];
-            break;
-          case 0xff5c: // Quantization default (QCD)
-            length = readUint16(data, position);
-            const qcd = {};
-            j = position + 2;
-            sqcd = data[j++];
-            switch (sqcd & 0x1f) {
-              case 0:
-                spqcdSize = 8;
-                scalarExpounded = true;
-                break;
-              case 1:
-                spqcdSize = 16;
-                scalarExpounded = false;
-                break;
-              case 2:
-                spqcdSize = 16;
-                scalarExpounded = true;
-                break;
-              default:
-                throw new Error("Invalid SQcd value " + sqcd);
-            }
-            qcd.noQuantization = spqcdSize === 8;
-            qcd.scalarExpounded = scalarExpounded;
-            qcd.guardBits = sqcd >> 5;
-            spqcds = [];
-            while (j < length + position) {
-              const spqcd = {};
-              if (spqcdSize === 8) {
-                spqcd.epsilon = data[j++] >> 3;
-                spqcd.mu = 0;
-              } else {
-                spqcd.epsilon = data[j] >> 3;
-                spqcd.mu = ((data[j] & 0x7) << 8) | data[j + 1];
-                j += 2;
-              }
-              spqcds.push(spqcd);
-            }
-            qcd.SPqcds = spqcds;
-            if (context.mainHeader) {
-              context.QCD = qcd;
-            } else {
-              context.currentTile.QCD = qcd;
-              context.currentTile.QCC = [];
-            }
-            break;
-          case 0xff5d: // Quantization component (QCC)
-            length = readUint16(data, position);
-            const qcc = {};
-            j = position + 2;
-            let cqcc;
-            if (context.SIZ.Csiz < 257) {
-              cqcc = data[j++];
-            } else {
-              cqcc = readUint16(data, j);
-              j += 2;
-            }
-            sqcd = data[j++];
-            switch (sqcd & 0x1f) {
-              case 0:
-                spqcdSize = 8;
-                scalarExpounded = true;
-                break;
-              case 1:
-                spqcdSize = 16;
-                scalarExpounded = false;
-                break;
-              case 2:
-                spqcdSize = 16;
-                scalarExpounded = true;
-                break;
-              default:
-                throw new Error("Invalid SQcd value " + sqcd);
-            }
-            qcc.noQuantization = spqcdSize === 8;
-            qcc.scalarExpounded = scalarExpounded;
-            qcc.guardBits = sqcd >> 5;
-            spqcds = [];
-            while (j < length + position) {
-              const spqcd = {};
-              if (spqcdSize === 8) {
-                spqcd.epsilon = data[j++] >> 3;
-                spqcd.mu = 0;
-              } else {
-                spqcd.epsilon = data[j] >> 3;
-                spqcd.mu = ((data[j] & 0x7) << 8) | data[j + 1];
-                j += 2;
-              }
-              spqcds.push(spqcd);
-            }
-            qcc.SPqcds = spqcds;
-            if (context.mainHeader) {
-              context.QCC[cqcc] = qcc;
-            } else {
-              context.currentTile.QCC[cqcc] = qcc;
-            }
-            break;
-          case 0xff52: // Coding style default (COD)
-            length = readUint16(data, position);
-            const cod = {};
-            j = position + 2;
-            const scod = data[j++];
-            cod.entropyCoderWithCustomPrecincts = !!(scod & 1);
-            cod.sopMarkerUsed = !!(scod & 2);
-            cod.ephMarkerUsed = !!(scod & 4);
-            cod.progressionOrder = data[j++];
-            cod.layersCount = readUint16(data, j);
-            j += 2;
-            cod.multipleComponentTransform = data[j++];
-
-            cod.decompositionLevelsCount = data[j++];
-            cod.xcb = (data[j++] & 0xf) + 2;
-            cod.ycb = (data[j++] & 0xf) + 2;
-            const blockStyle = data[j++];
-            cod.selectiveArithmeticCodingBypass = !!(blockStyle & 1);
-            cod.resetContextProbabilities = !!(blockStyle & 2);
-            cod.terminationOnEachCodingPass = !!(blockStyle & 4);
-            cod.verticallyStripe = !!(blockStyle & 8);
-            cod.predictableTermination = !!(blockStyle & 16);
-            cod.segmentationSymbolUsed = !!(blockStyle & 32);
-            cod.reversibleTransformation = data[j++];
-            if (cod.entropyCoderWithCustomPrecincts) {
-              const precinctsSizes = [];
-              while (j < length + position) {
-                const precinctsSize = data[j++];
-                precinctsSizes.push({
-                  PPx: precinctsSize & 0xf,
-                  PPy: precinctsSize >> 4,
-                });
-              }
-              cod.precinctsSizes = precinctsSizes;
-            }
-            const unsupported = [];
-            if (cod.selectiveArithmeticCodingBypass) {
-              unsupported.push("selectiveArithmeticCodingBypass");
-            }
-            if (cod.terminationOnEachCodingPass) {
-              unsupported.push("terminationOnEachCodingPass");
-            }
-            if (cod.verticallyStripe) {
-              unsupported.push("verticallyStripe");
-            }
-            if (cod.predictableTermination) {
-              unsupported.push("predictableTermination");
-            }
-            if (unsupported.length > 0) {
-              doNotRecover = true;
-              warn(`JPX: Unsupported COD options (${unsupported.join(", ")}).`);
-            }
-            if (context.mainHeader) {
-              context.COD = cod;
-            } else {
-              context.currentTile.COD = cod;
-              context.currentTile.COC = [];
-            }
-            break;
-          case 0xff90: // Start of tile-part (SOT)
-            length = readUint16(data, position);
-            tile = {};
-            tile.index = readUint16(data, position + 2);
-            tile.length = readUint32(data, position + 4);
-            tile.dataEnd = tile.length + position - 2;
-            tile.partIndex = data[position + 8];
-            tile.partsCount = data[position + 9];
-
-            context.mainHeader = false;
-            if (tile.partIndex === 0) {
-              // reset component specific settings
-              tile.COD = context.COD;
-              tile.COC = context.COC.slice(0); // clone of the global COC
-              tile.QCD = context.QCD;
-              tile.QCC = context.QCC.slice(0); // clone of the global COC
-            }
-            context.currentTile = tile;
-            break;
-          case 0xff93: // Start of data (SOD)
-            tile = context.currentTile;
-            if (tile.partIndex === 0) {
-              initializeTile(context, tile.index);
-              buildPackets(context);
-            }
-
-            // moving to the end of the data
-            length = tile.dataEnd - position;
-            parseTilePackets(context, data, position, length);
-            break;
-          case 0xff53: // Coding style component (COC)
-            warn("JPX: Codestream code 0xFF53 (COC) is not implemented.");
-          /* falls through */
-          case 0xff55: // Tile-part lengths, main header (TLM)
-          case 0xff57: // Packet length, main header (PLM)
-          case 0xff58: // Packet length, tile-part header (PLT)
-          case 0xff64: // Comment (COM)
-            length = readUint16(data, position);
-            // skipping content
-            break;
-          default:
-            throw new Error("Unknown codestream code: " + code.toString(16));
-        }
-        position += length;
-      }
-    } catch (e) {
-      if (doNotRecover || this.failOnCorruptedImage) {
-        throw new JpxError(e.message);
-      } else {
-        warn(`JPX: Trying to recover from: "${e.message}".`);
-      }
-    }
-    this.tiles = transformComponents(context);
-    this.width = context.SIZ.Xsiz - context.SIZ.XOsiz;
-    this.height = context.SIZ.Ysiz - context.SIZ.YOsiz;
-    this.componentsCount = context.SIZ.Csiz;
-  }
-}
-
-function calculateComponentDimensions(component, siz) {
-  // Section B.2 Component mapping
-  component.x0 = Math.ceil(siz.XOsiz / component.XRsiz);
-  component.x1 = Math.ceil(siz.Xsiz / component.XRsiz);
-  component.y0 = Math.ceil(siz.YOsiz / component.YRsiz);
-  component.y1 = Math.ceil(siz.Ysiz / component.YRsiz);
-  component.width = component.x1 - component.x0;
-  component.height = component.y1 - component.y0;
-}
-function calculateTileGrids(context, components) {
-  const siz = context.SIZ;
-  // Section B.3 Division into tile and tile-components
-  const tiles = [];
-  let tile;
-  const numXtiles = Math.ceil((siz.Xsiz - siz.XTOsiz) / siz.XTsiz);
-  const numYtiles = Math.ceil((siz.Ysiz - siz.YTOsiz) / siz.YTsiz);
-  for (let q = 0; q < numYtiles; q++) {
-    for (let p = 0; p < numXtiles; p++) {
-      tile = {};
-      tile.tx0 = Math.max(siz.XTOsiz + p * siz.XTsiz, siz.XOsiz);
-      tile.ty0 = Math.max(siz.YTOsiz + q * siz.YTsiz, siz.YOsiz);
-      tile.tx1 = Math.min(siz.XTOsiz + (p + 1) * siz.XTsiz, siz.Xsiz);
-      tile.ty1 = Math.min(siz.YTOsiz + (q + 1) * siz.YTsiz, siz.Ysiz);
-      tile.width = tile.tx1 - tile.tx0;
-      tile.height = tile.ty1 - tile.ty0;
-      tile.components = [];
-      tiles.push(tile);
-    }
-  }
-  context.tiles = tiles;
-
-  const componentsCount = siz.Csiz;
-  for (let i = 0, ii = componentsCount; i < ii; i++) {
-    const component = components[i];
-    for (let j = 0, jj = tiles.length; j < jj; j++) {
-      const tileComponent = {};
-      tile = tiles[j];
-      tileComponent.tcx0 = Math.ceil(tile.tx0 / component.XRsiz);
-      tileComponent.tcy0 = Math.ceil(tile.ty0 / component.YRsiz);
-      tileComponent.tcx1 = Math.ceil(tile.tx1 / component.XRsiz);
-      tileComponent.tcy1 = Math.ceil(tile.ty1 / component.YRsiz);
-      tileComponent.width = tileComponent.tcx1 - tileComponent.tcx0;
-      tileComponent.height = tileComponent.tcy1 - tileComponent.tcy0;
-      tile.components[i] = tileComponent;
-    }
-  }
-}
-function getBlocksDimensions(context, component, r) {
-  const codOrCoc = component.codingStyleParameters;
-  const result = {};
-  if (!codOrCoc.entropyCoderWithCustomPrecincts) {
-    result.PPx = 15;
-    result.PPy = 15;
-  } else {
-    result.PPx = codOrCoc.precinctsSizes[r].PPx;
-    result.PPy = codOrCoc.precinctsSizes[r].PPy;
-  }
-  // calculate codeblock size as described in section B.7
-  result.xcb_ =
-    r > 0
-      ? Math.min(codOrCoc.xcb, result.PPx - 1)
-      : Math.min(codOrCoc.xcb, result.PPx);
-  result.ycb_ =
-    r > 0
-      ? Math.min(codOrCoc.ycb, result.PPy - 1)
-      : Math.min(codOrCoc.ycb, result.PPy);
-  return result;
-}
-function buildPrecincts(context, resolution, dimensions) {
-  // Section B.6 Division resolution to precincts
-  const precinctWidth = 1 << dimensions.PPx;
-  const precinctHeight = 1 << dimensions.PPy;
-  // Jasper introduces codeblock groups for mapping each subband codeblocks
-  // to precincts. Precinct partition divides a resolution according to width
-  // and height parameters. The subband that belongs to the resolution level
-  // has a different size than the level, unless it is the zero resolution.
-
-  // From Jasper documentation: jpeg2000.pdf, section K: Tier-2 coding:
-  // The precinct partitioning for a particular subband is derived from a
-  // partitioning of its parent LL band (i.e., the LL band at the next higher
-  // resolution level)... The LL band associated with each resolution level is
-  // divided into precincts... Each of the resulting precinct regions is then
-  // mapped into its child subbands (if any) at the next lower resolution
-  // level. This is accomplished by using the coordinate transformation
-  // (u, v) = (ceil(x/2), ceil(y/2)) where (x, y) and (u, v) are the
-  // coordinates of a point in the LL band and child subband, respectively.
-  const isZeroRes = resolution.resLevel === 0;
-  const precinctWidthInSubband = 1 << (dimensions.PPx + (isZeroRes ? 0 : -1));
-  const precinctHeightInSubband = 1 << (dimensions.PPy + (isZeroRes ? 0 : -1));
-  const numprecinctswide =
-    resolution.trx1 > resolution.trx0
-      ? Math.ceil(resolution.trx1 / precinctWidth) -
-        Math.floor(resolution.trx0 / precinctWidth)
-      : 0;
-  const numprecinctshigh =
-    resolution.try1 > resolution.try0
-      ? Math.ceil(resolution.try1 / precinctHeight) -
-        Math.floor(resolution.try0 / precinctHeight)
-      : 0;
-  const numprecincts = numprecinctswide * numprecinctshigh;
-
-  resolution.precinctParameters = {
-    precinctWidth,
-    precinctHeight,
-    numprecinctswide,
-    numprecinctshigh,
-    numprecincts,
-    precinctWidthInSubband,
-    precinctHeightInSubband,
-  };
-}
-function buildCodeblocks(context, subband, dimensions) {
-  // Section B.7 Division sub-band into code-blocks
-  const xcb_ = dimensions.xcb_;
-  const ycb_ = dimensions.ycb_;
-  const codeblockWidth = 1 << xcb_;
-  const codeblockHeight = 1 << ycb_;
-  const cbx0 = subband.tbx0 >> xcb_;
-  const cby0 = subband.tby0 >> ycb_;
-  const cbx1 = (subband.tbx1 + codeblockWidth - 1) >> xcb_;
-  const cby1 = (subband.tby1 + codeblockHeight - 1) >> ycb_;
-  const precinctParameters = subband.resolution.precinctParameters;
-  const codeblocks = [];
-  const precincts = [];
-  let i, j, codeblock, precinctNumber;
-  for (j = cby0; j < cby1; j++) {
-    for (i = cbx0; i < cbx1; i++) {
-      codeblock = {
-        cbx: i,
-        cby: j,
-        tbx0: codeblockWidth * i,
-        tby0: codeblockHeight * j,
-        tbx1: codeblockWidth * (i + 1),
-        tby1: codeblockHeight * (j + 1),
-      };
-
-      codeblock.tbx0_ = Math.max(subband.tbx0, codeblock.tbx0);
-      codeblock.tby0_ = Math.max(subband.tby0, codeblock.tby0);
-      codeblock.tbx1_ = Math.min(subband.tbx1, codeblock.tbx1);
-      codeblock.tby1_ = Math.min(subband.tby1, codeblock.tby1);
-
-      // Calculate precinct number for this codeblock, codeblock position
-      // should be relative to its subband, use actual dimension and position
-      // See comment about codeblock group width and height
-      const pi = Math.floor(
-        (codeblock.tbx0_ - subband.tbx0) /
-          precinctParameters.precinctWidthInSubband
-      );
-      const pj = Math.floor(
-        (codeblock.tby0_ - subband.tby0) /
-          precinctParameters.precinctHeightInSubband
-      );
-      precinctNumber = pi + pj * precinctParameters.numprecinctswide;
-
-      codeblock.precinctNumber = precinctNumber;
-      codeblock.subbandType = subband.type;
-      codeblock.Lblock = 3;
-
-      if (
-        codeblock.tbx1_ <= codeblock.tbx0_ ||
-        codeblock.tby1_ <= codeblock.tby0_
-      ) {
-        continue;
-      }
-      codeblocks.push(codeblock);
-      // building precinct for the sub-band
-      let precinct = precincts[precinctNumber];
-      if (precinct !== undefined) {
-        if (i < precinct.cbxMin) {
-          precinct.cbxMin = i;
-        } else if (i > precinct.cbxMax) {
-          precinct.cbxMax = i;
-        }
-        if (j < precinct.cbyMin) {
-          precinct.cbxMin = j;
-        } else if (j > precinct.cbyMax) {
-          precinct.cbyMax = j;
-        }
-      } else {
-        precincts[precinctNumber] = precinct = {
-          cbxMin: i,
-          cbyMin: j,
-          cbxMax: i,
-          cbyMax: j,
+        return {
+          width: Xsiz - XOsiz,
+          height: Ysiz - YOsiz,
+          // Results are always returned as `Uint8ClampedArray`s.
+          bitsPerComponent: 8,
+          componentsCount: Csiz,
         };
       }
-      codeblock.precinct = precinct;
-    }
-  }
-  subband.codeblockParameters = {
-    codeblockWidth: xcb_,
-    codeblockHeight: ycb_,
-    numcodeblockwide: cbx1 - cbx0 + 1,
-    numcodeblockhigh: cby1 - cby0 + 1,
-  };
-  subband.codeblocks = codeblocks;
-  subband.precincts = precincts;
-}
-function createPacket(resolution, precinctNumber, layerNumber) {
-  const precinctCodeblocks = [];
-  // Section B.10.8 Order of info in packet
-  const subbands = resolution.subbands;
-  // sub-bands already ordered in 'LL', 'HL', 'LH', and 'HH' sequence
-  for (let i = 0, ii = subbands.length; i < ii; i++) {
-    const subband = subbands[i];
-    const codeblocks = subband.codeblocks;
-    for (let j = 0, jj = codeblocks.length; j < jj; j++) {
-      const codeblock = codeblocks[j];
-      if (codeblock.precinctNumber !== precinctNumber) {
-        continue;
-      }
-      precinctCodeblocks.push(codeblock);
-    }
-  }
-  return {
-    layerNumber,
-    codeblocks: precinctCodeblocks,
-  };
-}
-function LayerResolutionComponentPositionIterator(context) {
-  const siz = context.SIZ;
-  const tileIndex = context.currentTile.index;
-  const tile = context.tiles[tileIndex];
-  const layersCount = tile.codingStyleDefaultParameters.layersCount;
-  const componentsCount = siz.Csiz;
-  let maxDecompositionLevelsCount = 0;
-  for (let q = 0; q < componentsCount; q++) {
-    maxDecompositionLevelsCount = Math.max(
-      maxDecompositionLevelsCount,
-      tile.components[q].codingStyleParameters.decompositionLevelsCount
-    );
-  }
-
-  let l = 0,
-    r = 0,
-    i = 0,
-    k = 0;
-
-  this.nextPacket = function JpxImage_nextPacket() {
-    // Section B.12.1.1 Layer-resolution-component-position
-    for (; l < layersCount; l++) {
-      for (; r <= maxDecompositionLevelsCount; r++) {
-        for (; i < componentsCount; i++) {
-          const component = tile.components[i];
-          if (r > component.codingStyleParameters.decompositionLevelsCount) {
-            continue;
-          }
-
-          const resolution = component.resolutions[r];
-          const numprecincts = resolution.precinctParameters.numprecincts;
-          for (; k < numprecincts; ) {
-            const packet = createPacket(resolution, k, l);
-            k++;
-            return packet;
-          }
-          k = 0;
-        }
-        i = 0;
-      }
-      r = 0;
-    }
-    throw new JpxError("Out of packets");
-  };
-}
-function ResolutionLayerComponentPositionIterator(context) {
-  const siz = context.SIZ;
-  const tileIndex = context.currentTile.index;
-  const tile = context.tiles[tileIndex];
-  const layersCount = tile.codingStyleDefaultParameters.layersCount;
-  const componentsCount = siz.Csiz;
-  let maxDecompositionLevelsCount = 0;
-  for (let q = 0; q < componentsCount; q++) {
-    maxDecompositionLevelsCount = Math.max(
-      maxDecompositionLevelsCount,
-      tile.components[q].codingStyleParameters.decompositionLevelsCount
-    );
-  }
-
-  let r = 0,
-    l = 0,
-    i = 0,
-    k = 0;
-
-  this.nextPacket = function JpxImage_nextPacket() {
-    // Section B.12.1.2 Resolution-layer-component-position
-    for (; r <= maxDecompositionLevelsCount; r++) {
-      for (; l < layersCount; l++) {
-        for (; i < componentsCount; i++) {
-          const component = tile.components[i];
-          if (r > component.codingStyleParameters.decompositionLevelsCount) {
-            continue;
-          }
-
-          const resolution = component.resolutions[r];
-          const numprecincts = resolution.precinctParameters.numprecincts;
-          for (; k < numprecincts; ) {
-            const packet = createPacket(resolution, k, l);
-            k++;
-            return packet;
-          }
-          k = 0;
-        }
-        i = 0;
-      }
-      l = 0;
-    }
-    throw new JpxError("Out of packets");
-  };
-}
-function ResolutionPositionComponentLayerIterator(context) {
-  const siz = context.SIZ;
-  const tileIndex = context.currentTile.index;
-  const tile = context.tiles[tileIndex];
-  const layersCount = tile.codingStyleDefaultParameters.layersCount;
-  const componentsCount = siz.Csiz;
-  let l, r, c, p;
-  let maxDecompositionLevelsCount = 0;
-  for (c = 0; c < componentsCount; c++) {
-    const component = tile.components[c];
-    maxDecompositionLevelsCount = Math.max(
-      maxDecompositionLevelsCount,
-      component.codingStyleParameters.decompositionLevelsCount
-    );
-  }
-  const maxNumPrecinctsInLevel = new Int32Array(
-    maxDecompositionLevelsCount + 1
-  );
-  for (r = 0; r <= maxDecompositionLevelsCount; ++r) {
-    let maxNumPrecincts = 0;
-    for (c = 0; c < componentsCount; ++c) {
-      const resolutions = tile.components[c].resolutions;
-      if (r < resolutions.length) {
-        maxNumPrecincts = Math.max(
-          maxNumPrecincts,
-          resolutions[r].precinctParameters.numprecincts
-        );
-      }
-    }
-    maxNumPrecinctsInLevel[r] = maxNumPrecincts;
-  }
-  l = 0;
-  r = 0;
-  c = 0;
-  p = 0;
-
-  this.nextPacket = function JpxImage_nextPacket() {
-    // Section B.12.1.3 Resolution-position-component-layer
-    for (; r <= maxDecompositionLevelsCount; r++) {
-      for (; p < maxNumPrecinctsInLevel[r]; p++) {
-        for (; c < componentsCount; c++) {
-          const component = tile.components[c];
-          if (r > component.codingStyleParameters.decompositionLevelsCount) {
-            continue;
-          }
-          const resolution = component.resolutions[r];
-          const numprecincts = resolution.precinctParameters.numprecincts;
-          if (p >= numprecincts) {
-            continue;
-          }
-          for (; l < layersCount; ) {
-            const packet = createPacket(resolution, p, l);
-            l++;
-            return packet;
-          }
-          l = 0;
-        }
-        c = 0;
-      }
-      p = 0;
-    }
-    throw new JpxError("Out of packets");
-  };
-}
-function PositionComponentResolutionLayerIterator(context) {
-  const siz = context.SIZ;
-  const tileIndex = context.currentTile.index;
-  const tile = context.tiles[tileIndex];
-  const layersCount = tile.codingStyleDefaultParameters.layersCount;
-  const componentsCount = siz.Csiz;
-  const precinctsSizes = getPrecinctSizesInImageScale(tile);
-  const precinctsIterationSizes = precinctsSizes;
-  let l = 0,
-    r = 0,
-    c = 0,
-    px = 0,
-    py = 0;
-
-  this.nextPacket = function JpxImage_nextPacket() {
-    // Section B.12.1.4 Position-component-resolution-layer
-    for (; py < precinctsIterationSizes.maxNumHigh; py++) {
-      for (; px < precinctsIterationSizes.maxNumWide; px++) {
-        for (; c < componentsCount; c++) {
-          const component = tile.components[c];
-          const decompositionLevelsCount =
-            component.codingStyleParameters.decompositionLevelsCount;
-          for (; r <= decompositionLevelsCount; r++) {
-            const resolution = component.resolutions[r];
-            const sizeInImageScale =
-              precinctsSizes.components[c].resolutions[r];
-            const k = getPrecinctIndexIfExist(
-              px,
-              py,
-              sizeInImageScale,
-              precinctsIterationSizes,
-              resolution
-            );
-            if (k === null) {
-              continue;
-            }
-            for (; l < layersCount; ) {
-              const packet = createPacket(resolution, k, l);
-              l++;
-              return packet;
-            }
-            l = 0;
-          }
-          r = 0;
-        }
-        c = 0;
-      }
-      px = 0;
-    }
-    throw new JpxError("Out of packets");
-  };
-}
-function ComponentPositionResolutionLayerIterator(context) {
-  const siz = context.SIZ;
-  const tileIndex = context.currentTile.index;
-  const tile = context.tiles[tileIndex];
-  const layersCount = tile.codingStyleDefaultParameters.layersCount;
-  const componentsCount = siz.Csiz;
-  const precinctsSizes = getPrecinctSizesInImageScale(tile);
-  let l = 0,
-    r = 0,
-    c = 0,
-    px = 0,
-    py = 0;
-
-  this.nextPacket = function JpxImage_nextPacket() {
-    // Section B.12.1.5 Component-position-resolution-layer
-    for (; c < componentsCount; ++c) {
-      const component = tile.components[c];
-      const precinctsIterationSizes = precinctsSizes.components[c];
-      const decompositionLevelsCount =
-        component.codingStyleParameters.decompositionLevelsCount;
-      for (; py < precinctsIterationSizes.maxNumHigh; py++) {
-        for (; px < precinctsIterationSizes.maxNumWide; px++) {
-          for (; r <= decompositionLevelsCount; r++) {
-            const resolution = component.resolutions[r];
-            const sizeInImageScale = precinctsIterationSizes.resolutions[r];
-            const k = getPrecinctIndexIfExist(
-              px,
-              py,
-              sizeInImageScale,
-              precinctsIterationSizes,
-              resolution
-            );
-            if (k === null) {
-              continue;
-            }
-            for (; l < layersCount; ) {
-              const packet = createPacket(resolution, k, l);
-              l++;
-              return packet;
-            }
-            l = 0;
-          }
-          r = 0;
-        }
-        px = 0;
-      }
-      py = 0;
-    }
-    throw new JpxError("Out of packets");
-  };
-}
-function getPrecinctIndexIfExist(
-  pxIndex,
-  pyIndex,
-  sizeInImageScale,
-  precinctIterationSizes,
-  resolution
-) {
-  const posX = pxIndex * precinctIterationSizes.minWidth;
-  const posY = pyIndex * precinctIterationSizes.minHeight;
-  if (
-    posX % sizeInImageScale.width !== 0 ||
-    posY % sizeInImageScale.height !== 0
-  ) {
-    return null;
-  }
-  const startPrecinctRowIndex =
-    (posY / sizeInImageScale.width) *
-    resolution.precinctParameters.numprecinctswide;
-  return posX / sizeInImageScale.height + startPrecinctRowIndex;
-}
-function getPrecinctSizesInImageScale(tile) {
-  const componentsCount = tile.components.length;
-  let minWidth = Number.MAX_VALUE;
-  let minHeight = Number.MAX_VALUE;
-  let maxNumWide = 0;
-  let maxNumHigh = 0;
-  const sizePerComponent = new Array(componentsCount);
-  for (let c = 0; c < componentsCount; c++) {
-    const component = tile.components[c];
-    const decompositionLevelsCount =
-      component.codingStyleParameters.decompositionLevelsCount;
-    const sizePerResolution = new Array(decompositionLevelsCount + 1);
-    let minWidthCurrentComponent = Number.MAX_VALUE;
-    let minHeightCurrentComponent = Number.MAX_VALUE;
-    let maxNumWideCurrentComponent = 0;
-    let maxNumHighCurrentComponent = 0;
-    let scale = 1;
-    for (let r = decompositionLevelsCount; r >= 0; --r) {
-      const resolution = component.resolutions[r];
-      const widthCurrentResolution =
-        scale * resolution.precinctParameters.precinctWidth;
-      const heightCurrentResolution =
-        scale * resolution.precinctParameters.precinctHeight;
-      minWidthCurrentComponent = Math.min(
-        minWidthCurrentComponent,
-        widthCurrentResolution
-      );
-      minHeightCurrentComponent = Math.min(
-        minHeightCurrentComponent,
-        heightCurrentResolution
-      );
-      maxNumWideCurrentComponent = Math.max(
-        maxNumWideCurrentComponent,
-        resolution.precinctParameters.numprecinctswide
-      );
-      maxNumHighCurrentComponent = Math.max(
-        maxNumHighCurrentComponent,
-        resolution.precinctParameters.numprecinctshigh
-      );
-      sizePerResolution[r] = {
-        width: widthCurrentResolution,
-        height: heightCurrentResolution,
-      };
-      scale <<= 1;
-    }
-    minWidth = Math.min(minWidth, minWidthCurrentComponent);
-    minHeight = Math.min(minHeight, minHeightCurrentComponent);
-    maxNumWide = Math.max(maxNumWide, maxNumWideCurrentComponent);
-    maxNumHigh = Math.max(maxNumHigh, maxNumHighCurrentComponent);
-    sizePerComponent[c] = {
-      resolutions: sizePerResolution,
-      minWidth: minWidthCurrentComponent,
-      minHeight: minHeightCurrentComponent,
-      maxNumWide: maxNumWideCurrentComponent,
-      maxNumHigh: maxNumHighCurrentComponent,
-    };
-  }
-  return {
-    components: sizePerComponent,
-    minWidth,
-    minHeight,
-    maxNumWide,
-    maxNumHigh,
-  };
-}
-function buildPackets(context) {
-  const siz = context.SIZ;
-  const tileIndex = context.currentTile.index;
-  const tile = context.tiles[tileIndex];
-  const componentsCount = siz.Csiz;
-  // Creating resolutions and sub-bands for each component
-  for (let c = 0; c < componentsCount; c++) {
-    const component = tile.components[c];
-    const decompositionLevelsCount =
-      component.codingStyleParameters.decompositionLevelsCount;
-    // Section B.5 Resolution levels and sub-bands
-    const resolutions = [];
-    const subbands = [];
-    for (let r = 0; r <= decompositionLevelsCount; r++) {
-      const blocksDimensions = getBlocksDimensions(context, component, r);
-      const resolution = {};
-      const scale = 1 << (decompositionLevelsCount - r);
-      resolution.trx0 = Math.ceil(component.tcx0 / scale);
-      resolution.try0 = Math.ceil(component.tcy0 / scale);
-      resolution.trx1 = Math.ceil(component.tcx1 / scale);
-      resolution.try1 = Math.ceil(component.tcy1 / scale);
-      resolution.resLevel = r;
-      buildPrecincts(context, resolution, blocksDimensions);
-      resolutions.push(resolution);
-
-      let subband;
-      if (r === 0) {
-        // one sub-band (LL) with last decomposition
-        subband = {};
-        subband.type = "LL";
-        subband.tbx0 = Math.ceil(component.tcx0 / scale);
-        subband.tby0 = Math.ceil(component.tcy0 / scale);
-        subband.tbx1 = Math.ceil(component.tcx1 / scale);
-        subband.tby1 = Math.ceil(component.tcy1 / scale);
-        subband.resolution = resolution;
-        buildCodeblocks(context, subband, blocksDimensions);
-        subbands.push(subband);
-        resolution.subbands = [subband];
-      } else {
-        const bscale = 1 << (decompositionLevelsCount - r + 1);
-        const resolutionSubbands = [];
-        // three sub-bands (HL, LH and HH) with rest of decompositions
-        subband = {};
-        subband.type = "HL";
-        subband.tbx0 = Math.ceil(component.tcx0 / bscale - 0.5);
-        subband.tby0 = Math.ceil(component.tcy0 / bscale);
-        subband.tbx1 = Math.ceil(component.tcx1 / bscale - 0.5);
-        subband.tby1 = Math.ceil(component.tcy1 / bscale);
-        subband.resolution = resolution;
-        buildCodeblocks(context, subband, blocksDimensions);
-        subbands.push(subband);
-        resolutionSubbands.push(subband);
-
-        subband = {};
-        subband.type = "LH";
-        subband.tbx0 = Math.ceil(component.tcx0 / bscale);
-        subband.tby0 = Math.ceil(component.tcy0 / bscale - 0.5);
-        subband.tbx1 = Math.ceil(component.tcx1 / bscale);
-        subband.tby1 = Math.ceil(component.tcy1 / bscale - 0.5);
-        subband.resolution = resolution;
-        buildCodeblocks(context, subband, blocksDimensions);
-        subbands.push(subband);
-        resolutionSubbands.push(subband);
-
-        subband = {};
-        subband.type = "HH";
-        subband.tbx0 = Math.ceil(component.tcx0 / bscale - 0.5);
-        subband.tby0 = Math.ceil(component.tcy0 / bscale - 0.5);
-        subband.tbx1 = Math.ceil(component.tcx1 / bscale - 0.5);
-        subband.tby1 = Math.ceil(component.tcy1 / bscale - 0.5);
-        subband.resolution = resolution;
-        buildCodeblocks(context, subband, blocksDimensions);
-        subbands.push(subband);
-        resolutionSubbands.push(subband);
-
-        resolution.subbands = resolutionSubbands;
-      }
-    }
-    component.resolutions = resolutions;
-    component.subbands = subbands;
-  }
-  // Generate the packets sequence
-  const progressionOrder = tile.codingStyleDefaultParameters.progressionOrder;
-  switch (progressionOrder) {
-    case 0:
-      tile.packetsIterator = new LayerResolutionComponentPositionIterator(
-        context
-      );
-      break;
-    case 1:
-      tile.packetsIterator = new ResolutionLayerComponentPositionIterator(
-        context
-      );
-      break;
-    case 2:
-      tile.packetsIterator = new ResolutionPositionComponentLayerIterator(
-        context
-      );
-      break;
-    case 3:
-      tile.packetsIterator = new PositionComponentResolutionLayerIterator(
-        context
-      );
-      break;
-    case 4:
-      tile.packetsIterator = new ComponentPositionResolutionLayerIterator(
-        context
-      );
-      break;
-    default:
-      throw new JpxError(`Unsupported progression order ${progressionOrder}`);
-  }
-}
-function parseTilePackets(context, data, offset, dataLength) {
-  let position = 0;
-  let buffer,
-    bufferSize = 0,
-    skipNextBit = false;
-  function readBits(count) {
-    while (bufferSize < count) {
-      const b = data[offset + position];
-      position++;
-      if (skipNextBit) {
-        buffer = (buffer << 7) | b;
-        bufferSize += 7;
-        skipNextBit = false;
-      } else {
-        buffer = (buffer << 8) | b;
-        bufferSize += 8;
-      }
-      if (b === 0xff) {
-        skipNextBit = true;
-      }
-    }
-    bufferSize -= count;
-    return (buffer >>> bufferSize) & ((1 << count) - 1);
-  }
-  function skipMarkerIfEqual(value) {
-    if (
-      data[offset + position - 1] === 0xff &&
-      data[offset + position] === value
-    ) {
-      skipBytes(1);
-      return true;
-    } else if (
-      data[offset + position] === 0xff &&
-      data[offset + position + 1] === value
-    ) {
-      skipBytes(2);
-      return true;
-    }
-    return false;
-  }
-  function skipBytes(count) {
-    position += count;
-  }
-  function alignToByte() {
-    bufferSize = 0;
-    if (skipNextBit) {
-      position++;
-      skipNextBit = false;
-    }
-  }
-  function readCodingpasses() {
-    if (readBits(1) === 0) {
-      return 1;
-    }
-    if (readBits(1) === 0) {
-      return 2;
-    }
-    let value = readBits(2);
-    if (value < 3) {
-      return value + 3;
-    }
-    value = readBits(5);
-    if (value < 31) {
-      return value + 6;
-    }
-    value = readBits(7);
-    return value + 37;
-  }
-  const tileIndex = context.currentTile.index;
-  const tile = context.tiles[tileIndex];
-  const sopMarkerUsed = context.COD.sopMarkerUsed;
-  const ephMarkerUsed = context.COD.ephMarkerUsed;
-  const packetsIterator = tile.packetsIterator;
-  while (position < dataLength) {
-    alignToByte();
-    if (sopMarkerUsed && skipMarkerIfEqual(0x91)) {
-      // Skip also marker segment length and packet sequence ID
-      skipBytes(4);
-    }
-    const packet = packetsIterator.nextPacket();
-    if (!readBits(1)) {
-      continue;
-    }
-    const layerNumber = packet.layerNumber,
-      queue = [];
-    let codeblock;
-    for (let i = 0, ii = packet.codeblocks.length; i < ii; i++) {
-      codeblock = packet.codeblocks[i];
-      let precinct = codeblock.precinct;
-      const codeblockColumn = codeblock.cbx - precinct.cbxMin;
-      const codeblockRow = codeblock.cby - precinct.cbyMin;
-      let codeblockIncluded = false;
-      let firstTimeInclusion = false;
-      let valueReady, zeroBitPlanesTree;
-      if (codeblock.included !== undefined) {
-        codeblockIncluded = !!readBits(1);
-      } else {
-        // reading inclusion tree
-        precinct = codeblock.precinct;
-        let inclusionTree;
-        if (precinct.inclusionTree !== undefined) {
-          inclusionTree = precinct.inclusionTree;
-        } else {
-          // building inclusion and zero bit-planes trees
-          const width = precinct.cbxMax - precinct.cbxMin + 1;
-          const height = precinct.cbyMax - precinct.cbyMin + 1;
-          inclusionTree = new InclusionTree(width, height, layerNumber);
-          zeroBitPlanesTree = new TagTree(width, height);
-          precinct.inclusionTree = inclusionTree;
-          precinct.zeroBitPlanesTree = zeroBitPlanesTree;
-          for (let l = 0; l < layerNumber; l++) {
-            if (readBits(1) !== 0) {
-              throw new JpxError("Invalid tag tree");
-            }
-          }
-        }
-
-        if (inclusionTree.reset(codeblockColumn, codeblockRow, layerNumber)) {
-          while (true) {
-            if (readBits(1)) {
-              valueReady = !inclusionTree.nextLevel();
-              if (valueReady) {
-                codeblock.included = true;
-                codeblockIncluded = firstTimeInclusion = true;
-                break;
-              }
-            } else {
-              inclusionTree.incrementValue(layerNumber);
-              break;
-            }
-          }
-        }
-      }
-      if (!codeblockIncluded) {
-        continue;
-      }
-      if (firstTimeInclusion) {
-        zeroBitPlanesTree = precinct.zeroBitPlanesTree;
-        zeroBitPlanesTree.reset(codeblockColumn, codeblockRow);
-        while (true) {
-          if (readBits(1)) {
-            valueReady = !zeroBitPlanesTree.nextLevel();
-            if (valueReady) {
-              break;
-            }
-          } else {
-            zeroBitPlanesTree.incrementValue();
-          }
-        }
-        codeblock.zeroBitPlanes = zeroBitPlanesTree.value;
-      }
-      const codingpasses = readCodingpasses();
-      while (readBits(1)) {
-        codeblock.Lblock++;
-      }
-      const codingpassesLog2 = log2(codingpasses);
-      // rounding down log2
-      const bits =
-        (codingpasses < 1 << codingpassesLog2
-          ? codingpassesLog2 - 1
-          : codingpassesLog2) + codeblock.Lblock;
-      const codedDataLength = readBits(bits);
-      queue.push({
-        codeblock,
-        codingpasses,
-        dataLength: codedDataLength,
-      });
-    }
-    alignToByte();
-    if (ephMarkerUsed) {
-      skipMarkerIfEqual(0x92);
-    }
-    while (queue.length > 0) {
-      const packetItem = queue.shift();
-      codeblock = packetItem.codeblock;
-      if (codeblock.data === undefined) {
-        codeblock.data = [];
-      }
-      codeblock.data.push({
-        data,
-        start: offset + position,
-        end: offset + position + packetItem.dataLength,
-        codingpasses: packetItem.codingpasses,
-      });
-      position += packetItem.dataLength;
-    }
-  }
-  return position;
-}
-function copyCoefficients(
-  coefficients,
-  levelWidth,
-  levelHeight,
-  subband,
-  delta,
-  mb,
-  reversible,
-  segmentationSymbolUsed,
-  resetContextProbabilities
-) {
-  const x0 = subband.tbx0;
-  const y0 = subband.tby0;
-  const width = subband.tbx1 - subband.tbx0;
-  const codeblocks = subband.codeblocks;
-  const right = subband.type.charAt(0) === "H" ? 1 : 0;
-  const bottom = subband.type.charAt(1) === "H" ? levelWidth : 0;
-
-  for (let i = 0, ii = codeblocks.length; i < ii; ++i) {
-    const codeblock = codeblocks[i];
-    const blockWidth = codeblock.tbx1_ - codeblock.tbx0_;
-    const blockHeight = codeblock.tby1_ - codeblock.tby0_;
-    if (blockWidth === 0 || blockHeight === 0) {
-      continue;
-    }
-    if (codeblock.data === undefined) {
-      continue;
-    }
-
-    const bitModel = new BitModel(
-      blockWidth,
-      blockHeight,
-      codeblock.subbandType,
-      codeblock.zeroBitPlanes,
-      mb
-    );
-    let currentCodingpassType = 2; // first bit plane starts from cleanup
-
-    // collect data
-    const data = codeblock.data;
-    let totalLength = 0,
-      codingpasses = 0;
-    let j, jj, dataItem;
-    for (j = 0, jj = data.length; j < jj; j++) {
-      dataItem = data[j];
-      totalLength += dataItem.end - dataItem.start;
-      codingpasses += dataItem.codingpasses;
-    }
-    const encodedData = new Uint8Array(totalLength);
-    let position = 0;
-    for (j = 0, jj = data.length; j < jj; j++) {
-      dataItem = data[j];
-      const chunk = dataItem.data.subarray(dataItem.start, dataItem.end);
-      encodedData.set(chunk, position);
-      position += chunk.length;
-    }
-    // decoding the item
-    const decoder = new ArithmeticDecoder(encodedData, 0, totalLength);
-    bitModel.setDecoder(decoder);
-
-    for (j = 0; j < codingpasses; j++) {
-      switch (currentCodingpassType) {
-        case 0:
-          bitModel.runSignificancePropagationPass();
-          break;
-        case 1:
-          bitModel.runMagnitudeRefinementPass();
-          break;
-        case 2:
-          bitModel.runCleanupPass();
-          if (segmentationSymbolUsed) {
-            bitModel.checkSegmentationSymbol();
-          }
-          break;
-      }
-
-      if (resetContextProbabilities) {
-        bitModel.reset();
-      }
-
-      currentCodingpassType = (currentCodingpassType + 1) % 3;
-    }
-
-    let offset = codeblock.tbx0_ - x0 + (codeblock.tby0_ - y0) * width;
-    const sign = bitModel.coefficentsSign;
-    const magnitude = bitModel.coefficentsMagnitude;
-    const bitsDecoded = bitModel.bitsDecoded;
-    const magnitudeCorrection = reversible ? 0 : 0.5;
-    let k, n, nb;
-    position = 0;
-    // Do the interleaving of Section F.3.3 here, so we do not need
-    // to copy later. LL level is not interleaved, just copied.
-    const interleave = subband.type !== "LL";
-    for (j = 0; j < blockHeight; j++) {
-      const row = (offset / width) | 0; // row in the non-interleaved subband
-      const levelOffset = 2 * row * (levelWidth - width) + right + bottom;
-      for (k = 0; k < blockWidth; k++) {
-        n = magnitude[position];
-        if (n !== 0) {
-          n = (n + magnitudeCorrection) * delta;
-          if (sign[position] !== 0) {
-            n = -n;
-          }
-          nb = bitsDecoded[position];
-          const pos = interleave ? levelOffset + (offset << 1) : offset;
-          coefficients[pos] = reversible && nb >= mb ? n : n * (1 << (mb - nb));
-        }
-        offset++;
-        position++;
-      }
-      offset += width - blockWidth;
-    }
-  }
-}
-function transformTile(context, tile, c) {
-  const component = tile.components[c];
-  const codingStyleParameters = component.codingStyleParameters;
-  const quantizationParameters = component.quantizationParameters;
-  const decompositionLevelsCount =
-    codingStyleParameters.decompositionLevelsCount;
-  const spqcds = quantizationParameters.SPqcds;
-  const scalarExpounded = quantizationParameters.scalarExpounded;
-  const guardBits = quantizationParameters.guardBits;
-  const segmentationSymbolUsed = codingStyleParameters.segmentationSymbolUsed;
-  const resetContextProbabilities =
-    codingStyleParameters.resetContextProbabilities;
-  const precision = context.components[c].precision;
-
-  const reversible = codingStyleParameters.reversibleTransformation;
-  const transform = reversible
-    ? new ReversibleTransform()
-    : new IrreversibleTransform();
-
-  const subbandCoefficients = [];
-  let b = 0;
-  for (let i = 0; i <= decompositionLevelsCount; i++) {
-    const resolution = component.resolutions[i];
-
-    const width = resolution.trx1 - resolution.trx0;
-    const height = resolution.try1 - resolution.try0;
-    // Allocate space for the whole sublevel.
-    const coefficients = new Float32Array(width * height);
-
-    for (let j = 0, jj = resolution.subbands.length; j < jj; j++) {
-      let mu, epsilon;
-      if (!scalarExpounded) {
-        // formula E-5
-        mu = spqcds[0].mu;
-        epsilon = spqcds[0].epsilon + (i > 0 ? 1 - i : 0);
-      } else {
-        mu = spqcds[b].mu;
-        epsilon = spqcds[b].epsilon;
-        b++;
-      }
-
-      const subband = resolution.subbands[j];
-      const gainLog2 = SubbandsGainLog2[subband.type];
-
-      // calculate quantization coefficient (Section E.1.1.1)
-      const delta = reversible
-        ? 1
-        : 2 ** (precision + gainLog2 - epsilon) * (1 + mu / 2048);
-      const mb = guardBits + epsilon - 1;
-
-      // In the first resolution level, copyCoefficients will fill the
-      // whole array with coefficients. In the succeeding passes,
-      // copyCoefficients will consecutively fill in the values that belong
-      // to the interleaved positions of the HL, LH, and HH coefficients.
-      // The LL coefficients will then be interleaved in Transform.iterate().
-      copyCoefficients(
-        coefficients,
-        width,
-        height,
-        subband,
-        delta,
-        mb,
-        reversible,
-        segmentationSymbolUsed,
-        resetContextProbabilities
-      );
-    }
-    subbandCoefficients.push({
-      width,
-      height,
-      items: coefficients,
-    });
-  }
-
-  const result = transform.calculate(
-    subbandCoefficients,
-    component.tcx0,
-    component.tcy0
-  );
-  return {
-    left: component.tcx0,
-    top: component.tcy0,
-    width: result.width,
-    height: result.height,
-    items: result.items,
-  };
-}
-function transformComponents(context) {
-  const siz = context.SIZ;
-  const components = context.components;
-  const componentsCount = siz.Csiz;
-  const resultImages = [];
-  for (let i = 0, ii = context.tiles.length; i < ii; i++) {
-    const tile = context.tiles[i];
-    const transformedTiles = [];
-    for (let c = 0; c < componentsCount; c++) {
-      transformedTiles[c] = transformTile(context, tile, c);
-    }
-    const tile0 = transformedTiles[0];
-    const out = new Uint8ClampedArray(tile0.items.length * componentsCount);
-    const result = {
-      left: tile0.left,
-      top: tile0.top,
-      width: tile0.width,
-      height: tile0.height,
-      items: out,
-    };
-
-    // Section G.2.2 Inverse multi component transform
-    let shift, offset;
-    let pos = 0,
-      j,
-      jj,
-      y0,
-      y1,
-      y2;
-    if (tile.codingStyleDefaultParameters.multipleComponentTransform) {
-      const fourComponents = componentsCount === 4;
-      const y0items = transformedTiles[0].items;
-      const y1items = transformedTiles[1].items;
-      const y2items = transformedTiles[2].items;
-      const y3items = fourComponents ? transformedTiles[3].items : null;
-
-      // HACK: The multiple component transform formulas below assume that
-      // all components have the same precision. With this in mind, we
-      // compute shift and offset only once.
-      shift = components[0].precision - 8;
-      offset = (128 << shift) + 0.5;
-
-      const component0 = tile.components[0];
-      const alpha01 = componentsCount - 3;
-      jj = y0items.length;
-      if (!component0.codingStyleParameters.reversibleTransformation) {
-        // inverse irreversible multiple component transform
-        for (j = 0; j < jj; j++, pos += alpha01) {
-          y0 = y0items[j] + offset;
-          y1 = y1items[j];
-          y2 = y2items[j];
-          out[pos++] = (y0 + 1.402 * y2) >> shift;
-          out[pos++] = (y0 - 0.34413 * y1 - 0.71414 * y2) >> shift;
-          out[pos++] = (y0 + 1.772 * y1) >> shift;
-        }
-      } else {
-        // inverse reversible multiple component transform
-        for (j = 0; j < jj; j++, pos += alpha01) {
-          y0 = y0items[j] + offset;
-          y1 = y1items[j];
-          y2 = y2items[j];
-          const g = y0 - ((y2 + y1) >> 2);
-
-          out[pos++] = (g + y2) >> shift;
-          out[pos++] = g >> shift;
-          out[pos++] = (g + y1) >> shift;
-        }
-      }
-      if (fourComponents) {
-        for (j = 0, pos = 3; j < jj; j++, pos += 4) {
-          out[pos] = (y3items[j] + offset) >> shift;
-        }
-      }
-    } else {
-      // no multi-component transform
-      for (let c = 0; c < componentsCount; c++) {
-        const items = transformedTiles[c].items;
-        shift = components[c].precision - 8;
-        offset = (128 << shift) + 0.5;
-        for (pos = c, j = 0, jj = items.length; j < jj; j++) {
-          out[pos] = (items[j] + offset) >> shift;
-          pos += componentsCount;
-        }
-      }
-    }
-    resultImages.push(result);
-  }
-  return resultImages;
-}
-function initializeTile(context, tileIndex) {
-  const siz = context.SIZ;
-  const componentsCount = siz.Csiz;
-  const tile = context.tiles[tileIndex];
-  for (let c = 0; c < componentsCount; c++) {
-    const component = tile.components[c];
-    const qcdOrQcc =
-      context.currentTile.QCC[c] !== undefined
-        ? context.currentTile.QCC[c]
-        : context.currentTile.QCD;
-    component.quantizationParameters = qcdOrQcc;
-    const codOrCoc =
-      context.currentTile.COC[c] !== undefined
-        ? context.currentTile.COC[c]
-        : context.currentTile.COD;
-    component.codingStyleParameters = codOrCoc;
-  }
-  tile.codingStyleDefaultParameters = context.currentTile.COD;
-}
-
-// Section B.10.2 Tag trees
-class TagTree {
-  constructor(width, height) {
-    const levelsLength = log2(Math.max(width, height)) + 1;
-    this.levels = [];
-    for (let i = 0; i < levelsLength; i++) {
-      const level = {
-        width,
-        height,
-        items: [],
-      };
-      this.levels.push(level);
-      width = Math.ceil(width / 2);
-      height = Math.ceil(height / 2);
-    }
-  }
-
-  reset(i, j) {
-    let currentLevel = 0,
-      value = 0,
-      level;
-    while (currentLevel < this.levels.length) {
-      level = this.levels[currentLevel];
-      const index = i + j * level.width;
-      if (level.items[index] !== undefined) {
-        value = level.items[index];
-        break;
-      }
-      level.index = index;
-      i >>= 1;
-      j >>= 1;
-      currentLevel++;
-    }
-    currentLevel--;
-    level = this.levels[currentLevel];
-    level.items[level.index] = value;
-    this.currentLevel = currentLevel;
-    delete this.value;
-  }
-
-  incrementValue() {
-    const level = this.levels[this.currentLevel];
-    level.items[level.index]++;
-  }
-
-  nextLevel() {
-    let currentLevel = this.currentLevel;
-    let level = this.levels[currentLevel];
-    const value = level.items[level.index];
-    currentLevel--;
-    if (currentLevel < 0) {
-      this.value = value;
-      return false;
-    }
-
-    this.currentLevel = currentLevel;
-    level = this.levels[currentLevel];
-    level.items[level.index] = value;
-    return true;
-  }
-}
-
-class InclusionTree {
-  constructor(width, height, defaultValue) {
-    const levelsLength = log2(Math.max(width, height)) + 1;
-    this.levels = [];
-    for (let i = 0; i < levelsLength; i++) {
-      const items = new Uint8Array(width * height);
-      for (let j = 0, jj = items.length; j < jj; j++) {
-        items[j] = defaultValue;
-      }
-
-      const level = {
-        width,
-        height,
-        items,
-      };
-      this.levels.push(level);
-
-      width = Math.ceil(width / 2);
-      height = Math.ceil(height / 2);
-    }
-  }
-
-  reset(i, j, stopValue) {
-    let currentLevel = 0;
-    while (currentLevel < this.levels.length) {
-      const level = this.levels[currentLevel];
-      const index = i + j * level.width;
-      level.index = index;
-      const value = level.items[index];
-
-      if (value === 0xff) {
-        break;
-      }
-
-      if (value > stopValue) {
-        this.currentLevel = currentLevel;
-        // already know about this one, propagating the value to top levels
-        this.propagateValues();
-        return false;
-      }
-
-      i >>= 1;
-      j >>= 1;
-      currentLevel++;
-    }
-    this.currentLevel = currentLevel - 1;
-    return true;
-  }
-
-  incrementValue(stopValue) {
-    const level = this.levels[this.currentLevel];
-    level.items[level.index] = stopValue + 1;
-    this.propagateValues();
-  }
-
-  propagateValues() {
-    let levelIndex = this.currentLevel;
-    let level = this.levels[levelIndex];
-    const currentValue = level.items[level.index];
-    while (--levelIndex >= 0) {
-      level = this.levels[levelIndex];
-      level.items[level.index] = currentValue;
-    }
-  }
-
-  nextLevel() {
-    let currentLevel = this.currentLevel;
-    let level = this.levels[currentLevel];
-    const value = level.items[level.index];
-    level.items[level.index] = 0xff;
-    currentLevel--;
-    if (currentLevel < 0) {
-      return false;
-    }
-
-    this.currentLevel = currentLevel;
-    level = this.levels[currentLevel];
-    level.items[level.index] = value;
-    return true;
-  }
-}
-
-// Section D. Coefficient bit modeling
-class BitModel {
-  static UNIFORM_CONTEXT = 17;
-
-  static RUNLENGTH_CONTEXT = 18;
-
-  // Table D-1
-  // The index is binary presentation: 0dddvvhh, ddd - sum of Di (0..4),
-  // vv - sum of Vi (0..2), and hh - sum of Hi (0..2)
-  static LLAndLHContextsLabel = new Uint8Array([
-    0, 5, 8, 0, 3, 7, 8, 0, 4, 7, 8, 0, 0, 0, 0, 0, 1, 6, 8, 0, 3, 7, 8, 0, 4,
-    7, 8, 0, 0, 0, 0, 0, 2, 6, 8, 0, 3, 7, 8, 0, 4, 7, 8, 0, 0, 0, 0, 0, 2, 6,
-    8, 0, 3, 7, 8, 0, 4, 7, 8, 0, 0, 0, 0, 0, 2, 6, 8, 0, 3, 7, 8, 0, 4, 7, 8,
-  ]);
-
-  static HLContextLabel = new Uint8Array([
-    0, 3, 4, 0, 5, 7, 7, 0, 8, 8, 8, 0, 0, 0, 0, 0, 1, 3, 4, 0, 6, 7, 7, 0, 8,
-    8, 8, 0, 0, 0, 0, 0, 2, 3, 4, 0, 6, 7, 7, 0, 8, 8, 8, 0, 0, 0, 0, 0, 2, 3,
-    4, 0, 6, 7, 7, 0, 8, 8, 8, 0, 0, 0, 0, 0, 2, 3, 4, 0, 6, 7, 7, 0, 8, 8, 8,
-  ]);
-
-  static HHContextLabel = new Uint8Array([
-    0, 1, 2, 0, 1, 2, 2, 0, 2, 2, 2, 0, 0, 0, 0, 0, 3, 4, 5, 0, 4, 5, 5, 0, 5,
-    5, 5, 0, 0, 0, 0, 0, 6, 7, 7, 0, 7, 7, 7, 0, 7, 7, 7, 0, 0, 0, 0, 0, 8, 8,
-    8, 0, 8, 8, 8, 0, 8, 8, 8, 0, 0, 0, 0, 0, 8, 8, 8, 0, 8, 8, 8, 0, 8, 8, 8,
-  ]);
-
-  constructor(width, height, subband, zeroBitPlanes, mb) {
-    this.width = width;
-    this.height = height;
-
-    let contextLabelTable;
-    if (subband === "HH") {
-      contextLabelTable = BitModel.HHContextLabel;
-    } else if (subband === "HL") {
-      contextLabelTable = BitModel.HLContextLabel;
-    } else {
-      contextLabelTable = BitModel.LLAndLHContextsLabel;
-    }
-    this.contextLabelTable = contextLabelTable;
-
-    const coefficientCount = width * height;
-
-    // coefficients outside the encoding region treated as insignificant
-    // add border state cells for significanceState
-    this.neighborsSignificance = new Uint8Array(coefficientCount);
-    this.coefficentsSign = new Uint8Array(coefficientCount);
-    let coefficentsMagnitude;
-    if (mb > 14) {
-      coefficentsMagnitude = new Uint32Array(coefficientCount);
-    } else if (mb > 6) {
-      coefficentsMagnitude = new Uint16Array(coefficientCount);
-    } else {
-      coefficentsMagnitude = new Uint8Array(coefficientCount);
-    }
-    this.coefficentsMagnitude = coefficentsMagnitude;
-    this.processingFlags = new Uint8Array(coefficientCount);
-
-    const bitsDecoded = new Uint8Array(coefficientCount);
-    if (zeroBitPlanes !== 0) {
-      for (let i = 0; i < coefficientCount; i++) {
-        bitsDecoded[i] = zeroBitPlanes;
-      }
-    }
-    this.bitsDecoded = bitsDecoded;
-
-    this.reset();
-  }
-
-  setDecoder(decoder) {
-    this.decoder = decoder;
-  }
-
-  reset() {
-    // We have 17 contexts that are accessed via context labels,
-    // plus the uniform and runlength context.
-    this.contexts = new Int8Array(19);
-
-    // Contexts are packed into 1 byte:
-    // highest 7 bits carry the index, lowest bit carries mps
-    this.contexts[0] = (4 << 1) | 0;
-    this.contexts[BitModel.UNIFORM_CONTEXT] = (46 << 1) | 0;
-    this.contexts[BitModel.RUNLENGTH_CONTEXT] = (3 << 1) | 0;
-  }
-
-  setNeighborsSignificance(row, column, index) {
-    const neighborsSignificance = this.neighborsSignificance;
-    const width = this.width,
-      height = this.height;
-    const left = column > 0;
-    const right = column + 1 < width;
-    let i;
-
-    if (row > 0) {
-      i = index - width;
-      if (left) {
-        neighborsSignificance[i - 1] += 0x10;
-      }
-      if (right) {
-        neighborsSignificance[i + 1] += 0x10;
-      }
-      neighborsSignificance[i] += 0x04;
-    }
-
-    if (row + 1 < height) {
-      i = index + width;
-      if (left) {
-        neighborsSignificance[i - 1] += 0x10;
-      }
-      if (right) {
-        neighborsSignificance[i + 1] += 0x10;
-      }
-      neighborsSignificance[i] += 0x04;
-    }
-
-    if (left) {
-      neighborsSignificance[index - 1] += 0x01;
-    }
-    if (right) {
-      neighborsSignificance[index + 1] += 0x01;
-    }
-    neighborsSignificance[index] |= 0x80;
-  }
-
-  runSignificancePropagationPass() {
-    const decoder = this.decoder;
-    const width = this.width,
-      height = this.height;
-    const coefficentsMagnitude = this.coefficentsMagnitude;
-    const coefficentsSign = this.coefficentsSign;
-    const neighborsSignificance = this.neighborsSignificance;
-    const processingFlags = this.processingFlags;
-    const contexts = this.contexts;
-    const labels = this.contextLabelTable;
-    const bitsDecoded = this.bitsDecoded;
-    const processedInverseMask = ~1;
-    const processedMask = 1;
-    const firstMagnitudeBitMask = 2;
-
-    for (let i0 = 0; i0 < height; i0 += 4) {
-      for (let j = 0; j < width; j++) {
-        let index = i0 * width + j;
-        for (let i1 = 0; i1 < 4; i1++, index += width) {
-          const i = i0 + i1;
-          if (i >= height) {
-            break;
-          }
-          // clear processed flag first
-          processingFlags[index] &= processedInverseMask;
-
-          if (coefficentsMagnitude[index] || !neighborsSignificance[index]) {
-            continue;
-          }
-
-          const contextLabel = labels[neighborsSignificance[index]];
-          const decision = decoder.readBit(contexts, contextLabel);
-          if (decision) {
-            const sign = this.decodeSignBit(i, j, index);
-            coefficentsSign[index] = sign;
-            coefficentsMagnitude[index] = 1;
-            this.setNeighborsSignificance(i, j, index);
-            processingFlags[index] |= firstMagnitudeBitMask;
-          }
-          bitsDecoded[index]++;
-          processingFlags[index] |= processedMask;
-        }
-      }
-    }
-  }
-
-  decodeSignBit(row, column, index) {
-    const width = this.width,
-      height = this.height;
-    const coefficentsMagnitude = this.coefficentsMagnitude;
-    const coefficentsSign = this.coefficentsSign;
-    let contribution, sign0, sign1, significance1;
-    let contextLabel, decoded;
-
-    // calculate horizontal contribution
-    significance1 = column > 0 && coefficentsMagnitude[index - 1] !== 0;
-    if (column + 1 < width && coefficentsMagnitude[index + 1] !== 0) {
-      sign1 = coefficentsSign[index + 1];
-      if (significance1) {
-        sign0 = coefficentsSign[index - 1];
-        contribution = 1 - sign1 - sign0;
-      } else {
-        contribution = 1 - sign1 - sign1;
-      }
-    } else if (significance1) {
-      sign0 = coefficentsSign[index - 1];
-      contribution = 1 - sign0 - sign0;
-    } else {
-      contribution = 0;
-    }
-    const horizontalContribution = 3 * contribution;
-
-    // calculate vertical contribution and combine with the horizontal
-    significance1 = row > 0 && coefficentsMagnitude[index - width] !== 0;
-    if (row + 1 < height && coefficentsMagnitude[index + width] !== 0) {
-      sign1 = coefficentsSign[index + width];
-      if (significance1) {
-        sign0 = coefficentsSign[index - width];
-        contribution = 1 - sign1 - sign0 + horizontalContribution;
-      } else {
-        contribution = 1 - sign1 - sign1 + horizontalContribution;
-      }
-    } else if (significance1) {
-      sign0 = coefficentsSign[index - width];
-      contribution = 1 - sign0 - sign0 + horizontalContribution;
-    } else {
-      contribution = horizontalContribution;
-    }
-
-    if (contribution >= 0) {
-      contextLabel = 9 + contribution;
-      decoded = this.decoder.readBit(this.contexts, contextLabel);
-    } else {
-      contextLabel = 9 - contribution;
-      decoded = this.decoder.readBit(this.contexts, contextLabel) ^ 1;
-    }
-    return decoded;
-  }
-
-  runMagnitudeRefinementPass() {
-    const decoder = this.decoder;
-    const width = this.width,
-      height = this.height;
-    const coefficentsMagnitude = this.coefficentsMagnitude;
-    const neighborsSignificance = this.neighborsSignificance;
-    const contexts = this.contexts;
-    const bitsDecoded = this.bitsDecoded;
-    const processingFlags = this.processingFlags;
-    const processedMask = 1;
-    const firstMagnitudeBitMask = 2;
-    const length = width * height;
-    const width4 = width * 4;
-
-    for (let index0 = 0, indexNext; index0 < length; index0 = indexNext) {
-      indexNext = Math.min(length, index0 + width4);
-      for (let j = 0; j < width; j++) {
-        for (let index = index0 + j; index < indexNext; index += width) {
-          // significant but not those that have just become
-          if (
-            !coefficentsMagnitude[index] ||
-            (processingFlags[index] & processedMask) !== 0
-          ) {
-            continue;
-          }
-
-          let contextLabel = 16;
-          if ((processingFlags[index] & firstMagnitudeBitMask) !== 0) {
-            processingFlags[index] ^= firstMagnitudeBitMask;
-            // first refinement
-            const significance = neighborsSignificance[index] & 127;
-            contextLabel = significance === 0 ? 15 : 14;
-          }
-
-          const bit = decoder.readBit(contexts, contextLabel);
-          coefficentsMagnitude[index] =
-            (coefficentsMagnitude[index] << 1) | bit;
-          bitsDecoded[index]++;
-          processingFlags[index] |= processedMask;
-        }
-      }
-    }
-  }
-
-  runCleanupPass() {
-    const decoder = this.decoder;
-    const width = this.width,
-      height = this.height;
-    const neighborsSignificance = this.neighborsSignificance;
-    const coefficentsMagnitude = this.coefficentsMagnitude;
-    const coefficentsSign = this.coefficentsSign;
-    const contexts = this.contexts;
-    const labels = this.contextLabelTable;
-    const bitsDecoded = this.bitsDecoded;
-    const processingFlags = this.processingFlags;
-    const processedMask = 1;
-    const firstMagnitudeBitMask = 2;
-    const oneRowDown = width;
-    const twoRowsDown = width * 2;
-    const threeRowsDown = width * 3;
-    let iNext;
-    for (let i0 = 0; i0 < height; i0 = iNext) {
-      iNext = Math.min(i0 + 4, height);
-      const indexBase = i0 * width;
-      const checkAllEmpty = i0 + 3 < height;
-      for (let j = 0; j < width; j++) {
-        const index0 = indexBase + j;
-        // using the property: labels[neighborsSignificance[index]] === 0
-        // when neighborsSignificance[index] === 0
-        const allEmpty =
-          checkAllEmpty &&
-          processingFlags[index0] === 0 &&
-          processingFlags[index0 + oneRowDown] === 0 &&
-          processingFlags[index0 + twoRowsDown] === 0 &&
-          processingFlags[index0 + threeRowsDown] === 0 &&
-          neighborsSignificance[index0] === 0 &&
-          neighborsSignificance[index0 + oneRowDown] === 0 &&
-          neighborsSignificance[index0 + twoRowsDown] === 0 &&
-          neighborsSignificance[index0 + threeRowsDown] === 0;
-        let i1 = 0,
-          index = index0;
-        let i = i0,
-          sign;
-        if (allEmpty) {
-          const hasSignificantCoefficent = decoder.readBit(
-            contexts,
-            BitModel.RUNLENGTH_CONTEXT
-          );
-          if (!hasSignificantCoefficent) {
-            bitsDecoded[index0]++;
-            bitsDecoded[index0 + oneRowDown]++;
-            bitsDecoded[index0 + twoRowsDown]++;
-            bitsDecoded[index0 + threeRowsDown]++;
-            continue; // next column
-          }
-          i1 =
-            (decoder.readBit(contexts, BitModel.UNIFORM_CONTEXT) << 1) |
-            decoder.readBit(contexts, BitModel.UNIFORM_CONTEXT);
-          if (i1 !== 0) {
-            i = i0 + i1;
-            index += i1 * width;
-          }
-
-          sign = this.decodeSignBit(i, j, index);
-          coefficentsSign[index] = sign;
-          coefficentsMagnitude[index] = 1;
-          this.setNeighborsSignificance(i, j, index);
-          processingFlags[index] |= firstMagnitudeBitMask;
-
-          index = index0;
-          for (let i2 = i0; i2 <= i; i2++, index += width) {
-            bitsDecoded[index]++;
-          }
-
-          i1++;
-        }
-        for (i = i0 + i1; i < iNext; i++, index += width) {
-          if (
-            coefficentsMagnitude[index] ||
-            (processingFlags[index] & processedMask) !== 0
-          ) {
-            continue;
-          }
-
-          const contextLabel = labels[neighborsSignificance[index]];
-          const decision = decoder.readBit(contexts, contextLabel);
-          if (decision === 1) {
-            sign = this.decodeSignBit(i, j, index);
-            coefficentsSign[index] = sign;
-            coefficentsMagnitude[index] = 1;
-            this.setNeighborsSignificance(i, j, index);
-            processingFlags[index] |= firstMagnitudeBitMask;
-          }
-          bitsDecoded[index]++;
-        }
-      }
-    }
-  }
-
-  checkSegmentationSymbol() {
-    const decoder = this.decoder;
-    const contexts = this.contexts;
-    const symbol =
-      (decoder.readBit(contexts, BitModel.UNIFORM_CONTEXT) << 3) |
-      (decoder.readBit(contexts, BitModel.UNIFORM_CONTEXT) << 2) |
-      (decoder.readBit(contexts, BitModel.UNIFORM_CONTEXT) << 1) |
-      decoder.readBit(contexts, BitModel.UNIFORM_CONTEXT);
-    if (symbol !== 0xa) {
-      throw new JpxError("Invalid segmentation symbol");
-    }
-  }
-}
-
-// Section F, Discrete wavelet transformation
-class Transform {
-  constructor() {
-    if (this.constructor === Transform) {
-      unreachable("Cannot initialize Transform.");
-    }
-  }
-
-  calculate(subbands, u0, v0) {
-    let ll = subbands[0];
-    for (let i = 1, ii = subbands.length; i < ii; i++) {
-      ll = this.iterate(ll, subbands[i], u0, v0);
-    }
-    return ll;
-  }
-
-  extend(buffer, offset, size) {
-    // Section F.3.7 extending... using max extension of 4
-    let i1 = offset - 1,
-      j1 = offset + 1;
-    let i2 = offset + size - 2,
-      j2 = offset + size;
-    buffer[i1--] = buffer[j1++];
-    buffer[j2++] = buffer[i2--];
-    buffer[i1--] = buffer[j1++];
-    buffer[j2++] = buffer[i2--];
-    buffer[i1--] = buffer[j1++];
-    buffer[j2++] = buffer[i2--];
-    buffer[i1] = buffer[j1];
-    buffer[j2] = buffer[i2];
-  }
-
-  filter(x, offset, length) {
-    unreachable("Abstract method `filter` called");
-  }
-
-  iterate(ll, hl_lh_hh, u0, v0) {
-    const llWidth = ll.width,
-      llHeight = ll.height;
-    let llItems = ll.items;
-    const width = hl_lh_hh.width;
-    const height = hl_lh_hh.height;
-    const items = hl_lh_hh.items;
-    let i, j, k, l, u, v;
-
-    // Interleave LL according to Section F.3.3
-    for (k = 0, i = 0; i < llHeight; i++) {
-      l = i * 2 * width;
-      for (j = 0; j < llWidth; j++, k++, l += 2) {
-        items[l] = llItems[k];
-      }
-    }
-    // The LL band is not needed anymore.
-    llItems = ll.items = null;
-
-    const bufferPadding = 4;
-    const rowBuffer = new Float32Array(width + 2 * bufferPadding);
-
-    // Section F.3.4 HOR_SR
-    if (width === 1) {
-      // if width = 1, when u0 even keep items as is, when odd divide by 2
-      if ((u0 & 1) !== 0) {
-        for (v = 0, k = 0; v < height; v++, k += width) {
-          items[k] *= 0.5;
-        }
-      }
-    } else {
-      for (v = 0, k = 0; v < height; v++, k += width) {
-        rowBuffer.set(items.subarray(k, k + width), bufferPadding);
-
-        this.extend(rowBuffer, bufferPadding, width);
-        this.filter(rowBuffer, bufferPadding, width);
-
-        items.set(rowBuffer.subarray(bufferPadding, bufferPadding + width), k);
-      }
-    }
-
-    // Accesses to the items array can take long, because it may not fit into
-    // CPU cache and has to be fetched from main memory. Since subsequent
-    // accesses to the items array are not local when reading columns, we
-    // have a cache miss every time. To reduce cache misses, get up to
-    // 'numBuffers' items at a time and store them into the individual
-    // buffers. The colBuffers should be small enough to fit into CPU cache.
-    let numBuffers = 16;
-    const colBuffers = [];
-    for (i = 0; i < numBuffers; i++) {
-      colBuffers.push(new Float32Array(height + 2 * bufferPadding));
-    }
-    let b,
-      currentBuffer = 0;
-    ll = bufferPadding + height;
-
-    // Section F.3.5 VER_SR
-    if (height === 1) {
-      // if height = 1, when v0 even keep items as is, when odd divide by 2
-      if ((v0 & 1) !== 0) {
-        for (u = 0; u < width; u++) {
-          items[u] *= 0.5;
-        }
-      }
-    } else {
-      for (u = 0; u < width; u++) {
-        // if we ran out of buffers, copy several image columns at once
-        if (currentBuffer === 0) {
-          numBuffers = Math.min(width - u, numBuffers);
-          for (k = u, l = bufferPadding; l < ll; k += width, l++) {
-            for (b = 0; b < numBuffers; b++) {
-              colBuffers[b][l] = items[k + b];
-            }
-          }
-          currentBuffer = numBuffers;
-        }
-
-        currentBuffer--;
-        const buffer = colBuffers[currentBuffer];
-        this.extend(buffer, bufferPadding, height);
-        this.filter(buffer, bufferPadding, height);
-
-        // If this is last buffer in this group of buffers, flush all buffers.
-        if (currentBuffer === 0) {
-          k = u - numBuffers + 1;
-          for (l = bufferPadding; l < ll; k += width, l++) {
-            for (b = 0; b < numBuffers; b++) {
-              items[k + b] = colBuffers[b][l];
-            }
-          }
-        }
-      }
-    }
-
-    return { width, height, items };
-  }
-}
-
-// Section 3.8.2 Irreversible 9-7 filter
-class IrreversibleTransform extends Transform {
-  filter(x, offset, length) {
-    const len = length >> 1;
-    offset |= 0;
-    let j, n, current, next;
-
-    const alpha = -1.586134342059924;
-    const beta = -0.052980118572961;
-    const gamma = 0.882911075530934;
-    const delta = 0.443506852043971;
-    const K = 1.230174104914001;
-    const K_ = 1 / K;
-
-    // step 1 is combined with step 3
-
-    // step 2
-    j = offset - 3;
-    for (n = len + 4; n--; j += 2) {
-      x[j] *= K_;
-    }
-
-    // step 1 & 3
-    j = offset - 2;
-    current = delta * x[j - 1];
-    for (n = len + 3; n--; j += 2) {
-      next = delta * x[j + 1];
-      x[j] = K * x[j] - current - next;
-      if (n--) {
-        j += 2;
-        current = delta * x[j + 1];
-        x[j] = K * x[j] - current - next;
-      } else {
-        break;
-      }
-    }
-
-    // step 4
-    j = offset - 1;
-    current = gamma * x[j - 1];
-    for (n = len + 2; n--; j += 2) {
-      next = gamma * x[j + 1];
-      x[j] -= current + next;
-      if (n--) {
-        j += 2;
-        current = gamma * x[j + 1];
-        x[j] -= current + next;
-      } else {
-        break;
-      }
-    }
-
-    // step 5
-    j = offset;
-    current = beta * x[j - 1];
-    for (n = len + 1; n--; j += 2) {
-      next = beta * x[j + 1];
-      x[j] -= current + next;
-      if (n--) {
-        j += 2;
-        current = beta * x[j + 1];
-        x[j] -= current + next;
-      } else {
-        break;
-      }
-    }
-
-    // step 6
-    if (len !== 0) {
-      j = offset + 1;
-      current = alpha * x[j - 1];
-      for (n = len; n--; j += 2) {
-        next = alpha * x[j + 1];
-        x[j] -= current + next;
-        if (n--) {
-          j += 2;
-          current = alpha * x[j + 1];
-          x[j] -= current + next;
-        } else {
-          break;
-        }
-      }
-    }
-  }
-}
-
-// Section 3.8.1 Reversible 5-3 filter
-class ReversibleTransform extends Transform {
-  filter(x, offset, length) {
-    const len = length >> 1;
-    offset |= 0;
-    let j, n;
-
-    for (j = offset, n = len + 1; n--; j += 2) {
-      x[j] -= (x[j - 1] + x[j + 1] + 2) >> 2;
-    }
-
-    for (j = offset + 1, n = len; n--; j += 2) {
-      x[j] += (x[j - 1] + x[j + 1]) >> 1;
     }
+    throw new JpxError("No size marker found in JPX stream");
   }
 }

diff --git a/src/core/jpx_stream.js b/src/core/jpx_stream.js
--- a/src/core/jpx_stream.js
+++ b/src/core/jpx_stream.js
@@ -41,44 +41,12 @@ class JpxStream extends DecodeStream {
     // directly insert all of its data into `this.buffer`.
   }
 
-  readBlock() {
+  readBlock(ignoreColorSpace) {
     if (this.eof) {
       return;
     }
-    const jpxImage = new JpxImage();
-    jpxImage.parse(this.bytes);
 
-    const width = jpxImage.width;
-    const height = jpxImage.height;
-    const componentsCount = jpxImage.componentsCount;
-    const tileCount = jpxImage.tiles.length;
-    if (tileCount === 1) {
-      this.buffer = jpxImage.tiles[0].items;
-    } else {
-      const data = new Uint8ClampedArray(width * height * componentsCount);
-
-      for (let k = 0; k < tileCount; k++) {
-        const tileComponents = jpxImage.tiles[k];
-        const tileWidth = tileComponents.width;
-        const tileHeight = tileComponents.height;
-        const tileLeft = tileComponents.left;
-        const tileTop = tileComponents.top;
-
-        const src = tileComponents.items;
-        let srcPosition = 0;
-        let dataPosition = (width * tileTop + tileLeft) * componentsCount;
-        const imgRowSize = width * componentsCount;
-        const tileRowSize = tileWidth * componentsCount;
-
-        for (let j = 0; j < tileHeight; j++) {
-          const rowBytes = src.subarray(srcPosition, srcPosition + tileRowSize);
-          data.set(rowBytes, dataPosition);
-          srcPosition += tileRowSize;
-          dataPosition += imgRowSize;
-        }
-      }
-      this.buffer = data;
-    }
+    this.buffer = JpxImage.decode(this.bytes, ignoreColorSpace);
     this.bufferLength = this.buffer.length;
     this.eof = true;
   }


</patch>

Imports:
<imports>
Available Packages
Dev Dependencies:
- @babel/core: ^7.24.4
- @babel/preset-env: ^7.24.4
- @babel/runtime: ^7.24.4
- @fluent/bundle: ^0.18.0
- @fluent/dom: ^0.9.0
- @jazzer.js/core: ^2.1.0
- autoprefixer: ^10.4.19
- babel-loader: ^9.1.3
- caniuse-lite: ^1.0.30001608
- canvas: ^2.11.2
- core-js: ^3.36.1
- cross-env: ^7.0.3
- eslint: ^8.57.0
- eslint-config-prettier: ^9.1.0
- eslint-plugin-fetch-options: ^0.0.5
- eslint-plugin-html: ^8.1.0
- eslint-plugin-import: ^2.29.1
- eslint-plugin-jasmine: ^4.1.3
- eslint-plugin-json: ^3.1.0
- eslint-plugin-mozilla: ^3.7.3
- eslint-plugin-no-unsanitized: ^4.0.2
- eslint-plugin-prettier: ^5.1.3
- eslint-plugin-sort-exports: ^0.9.1
- eslint-plugin-unicorn: ^52.0.0
- globals: ^15.0.0
- gulp: ^4.0.2
- gulp-cli: ^3.0.0
- gulp-postcss: ^10.0.0
- gulp-rename: ^2.0.0
- gulp-replace: ^1.1.4
- gulp-zip: ^6.0.0
- jasmine: ^5.1.0
- jsdoc: ^4.0.2
- jstransformer-markdown-it: ^3.0.0
- merge-stream: ^2.0.0
- needle: ^3.3.1
- path2d: ^0.2.0
- pngjs: ^7.0.0
- postcss: ^8.4.38
- postcss-dark-theme-class: ^1.2.1
- postcss-dir-pseudo-class: ^8.0.1
- postcss-discard-comments: ^6.0.2
- postcss-nesting: ^12.1.1
- prettier: ^3.2.5
- puppeteer: ^22.6.4
- rimraf: ^3.0.2
- streamqueue: ^1.1.2
- stylelint: ^16.3.1
- stylelint-prettier: ^5.0.0
- terser-webpack-plugin: ^5.3.10
- through2: ^4.0.2
- tsc-alias: ^1.8.8
- ttest: ^4.0.0
- typescript: ^5.4.5
- typogr: ^0.6.8
- vinyl: ^3.0.0
- webpack: ^5.91.0
- webpack-stream: ^7.0.0
- wintersmith: ^2.5.0
- yargs: ^17.7.2

Engines:
- node: >=18

Available Relative Imports:
- `../../src/core/annotation.js`: Annotation, AnnotationBorderStyle, AnnotationFactory, MarkupAnnotation, getQuadPoints
- `../../src/core/bidi.js`: bidi
- `../../src/core/cff_parser.js`: CFFCharset, CFFCompiler, CFFFDSelect, CFFParser, CFFStrings
- `../../src/core/cmap.js`: CMap, CMapFactory, IdentityCMap
- `../../src/core/colorspace.js`: ColorSpace
- `../../src/core/core_utils.js`: arrayBuffersToBytes, encodeToXmlString, escapePDFName, escapeString, getInheritableProperty, getSizeInBytes, isAscii, isWhiteSpace, log2, numberToString, parseXFAPath, recoverJsURL, stringToUTF16HexString, stringToUTF16String, toRomanNumerals, validateCSSFont
- `../../src/core/crypto.js`: AES128Cipher, AES256Cipher, ARCFourCipher, CipherTransformFactory, PDF17, PDF20, calculateMD5, calculateSHA256, calculateSHA384, calculateSHA512
- `../../src/core/default_appearance.js`: createDefaultAppearance, parseAppearanceStream, parseDefaultAppearance
- `../../src/core/document.js`: PDFDocument, Page
- `../../src/core/encodings.js`: getEncoding
- `../../src/core/evaluator.js`: PartialEvaluator
- `../../src/core/flate_stream.js`: FlateStream
- `../../src/core/font_substitutions.js`: getFontSubstitution
- `../../src/core/fonts_utils.js`: SEAC_ANALYSIS_ENABLED
- `../../src/core/function.js`: PDFFunctionFactory, PostScriptCompiler, PostScriptEvaluator
- `../../src/core/glyphlist.js`: getDingbatsGlyphsUnicode, getGlyphsUnicode
- `../../src/core/image_utils.js`: GlobalImageCache, LocalColorSpaceCache
- `../../src/core/jbig2.js`: Jbig2Image
- `../../src/core/jpg.js`: JpegImage
- `../../src/core/jpx.js`: JpxImage
- `../../src/core/metadata_parser.js`: MetadataParser
- `../../src/core/operator_list.js`: OperatorList
- `../../src/core/parser.js`: Lexer, Linearization, Parser
- `../../src/core/predictor_stream.js`: PredictorStream
- `../../src/core/primitives.js`: Cmd, Dict, EOF, Name, Ref, RefSet, RefSetCache, isCmd, isDict, isName, isRefsEqual
- `../../src/core/ps_parser.js`: PostScriptLexer, PostScriptParser
- `../../src/core/stream.js`: NullStream, Stream, StringStream
- `../../src/core/type1_parser.js`: Type1Parser
- `../../src/core/unicode.js`: getCharUnicodeCategory, getUnicodeForGlyph, getUnicodeRangeFor, mapSpecialUnicodeValues
- `../../src/core/worker.js`: WorkerMessageHandler, WorkerTask
- `../../src/core/writer.js`: incrementalUpdate, writeDict
- `../../src/core/xfa/bind.js`: Binder
- `../../src/core/xfa/data.js`: DataHandler
- `../../src/core/xfa/factory.js`: XFAFactory
- `../../src/core/xfa/formcalc_lexer.js`: Lexer, TOKEN, Token
- `../../src/core/xfa/formcalc_parser.js`: Errors, Parser
- `../../src/core/xfa/parser.js`: XFAParser
- `../../src/core/xfa/som.js`: searchNode
- `../../src/core/xfa/symbol_utils.js`: $dump, $getChildren, $getChildrenByClass, $getChildrenByName, $text, $uid
- `../../src/core/xml_parser.js`: SimpleXMLParser, XMLParserBase
- `../../src/display/annotation_layer.js`: AnnotationLayer
- `../../src/display/annotation_storage.js`: AnnotationStorage
- `../../src/display/api.js`: DefaultCMapReaderFactory, DefaultCanvasFactory, DefaultStandardFontDataFactory, LoopbackPort, PDFDataRangeTransport, PDFDocumentLoadingTask, PDFDocumentProxy, PDFPageProxy, PDFWorker, PDFWorkerUtil, RenderTask, build, getDocument, version
- `../../src/display/display_utils.js`: DOMCanvasFactory, DOMSVGFactory, PDFDateString, PageViewport, PixelsPerInch, RenderingCancelledException, StatTimer, fetchData, getFilenameFromUrl, getPdfFilenameFromUrl, getXfaPageViewport, isDataScheme, isPdfFile, isValidFetchUrl, noContextMenu, setLayerDimensions
- `../../src/display/draw_layer.js`: DrawLayer
- `../../src/display/editor/annotation_editor_layer.js`: AnnotationEditorLayer
- `../../src/display/editor/color_picker.js`: ColorPicker
- `../../src/display/editor/outliner.js`: Outliner
- `../../src/display/editor/tools.js`: AnnotationEditorUIManager, CommandManager
- `../../src/display/fetch_stream.js`: PDFFetchStream
- `../../src/display/metadata.js`: Metadata
- `../../src/display/network.js`: PDFNetworkStream
- `../../src/display/network_utils.js`: createResponseStatusError, extractFilenameFromHeader, validateRangeRequestCapabilities, validateResponseStatus
- `../../src/display/node_stream.js`: PDFNodeStream
- `../../src/display/text_layer.js`: TextLayerRenderTask, renderTextLayer, updateTextLayer
- `../../src/display/worker_options.js`: GlobalWorkerOptions
- `../../src/display/xfa_layer.js`: XfaLayer
- `../../src/shared/message_handler.js`: MessageHandler
- `../../src/shared/murmurhash3.js`: MurmurHash3_64
- `../../src/shared/util.js`: AbortException, AnnotationBorderStyleType, AnnotationEditorParamsType, AnnotationEditorType, AnnotationFieldFlag, AnnotationFlag, AnnotationMode, AnnotationType, CMapCompressionType, FeatureTest, FormatError, ImageKind, InvalidPDFException, MissingPDFException, OPS, PasswordException, PasswordResponses, PermissionFlag, RenderingIntentFlag, UnexpectedResponseException, UnknownErrorException, Util, VerbosityLevel, assert, bytesToString, createValidAbsoluteUrl, getModificationDate, getVerbosityLevel, isNodeJS, normalizeUnicode, objectSize, setVerbosityLevel, shadow, string32, stringToBytes, stringToPDFString, stringToUTF8String
- `../../web/annotation_layer_builder.js`: AnnotationLayerBuilder
- `../../web/app_options.js`: AppOptions, OptionKind
- `../../web/download_manager.js`: DownloadManager
- `../../web/event_utils.js`: EventBus, WaitOnType, waitOnEventOrTimeout
- `../../web/genericl10n.js`: GenericL10n
- `../../web/pdf_find_controller.js`: FindState, PDFFindController
- `../../web/pdf_find_utils.js`: CharacterType, getCharacterType
- `../../web/pdf_history.js`: PDFHistory, isDestArraysEqual, isDestHashesEqual
- `../../web/pdf_link_service.js`: LinkTarget, PDFLinkService, SimpleLinkService
- `../../web/pdf_page_view.js`: PDFPageView
- `../../web/pdf_scripting_manager.component.js`: PDFScriptingManager
- `../../web/pdf_single_page_viewer.js`: PDFSinglePageViewer
- `../../web/pdf_viewer.js`: PDFPageViewBuffer, PDFViewer
- `../../web/struct_tree_layer_builder.js`: StructTreeLayerBuilder
- `../../web/text_layer_builder.js`: TextLayerBuilder
- `../../web/ui_utils.js`: AutoPrintRegExp, ProgressBar, RenderingStates, ScrollMode, SpreadMode, backtrackBeforeAllVisibleElements, binarySearchFirstItem, getPageSizeInches, getVisibleElements, isPortraitOrientation, isValidRotation, parseQueryString, removeNullCharacters
- `../../web/xfa_layer_builder.js`: XfaLayerBuilder
- `./test_utils.js`: CMAP_URL, DefaultFileReaderFactory, STANDARD_FONT_DATA_URL, TEST_PDFS_PATH, XRefMock, buildGetDocumentParams, createIdFactory, createTemporaryNodeServer
- `./testreporter.js`: TestReporter
</imports>

Code:
<code>
File:
src/core/cleanup_helper.js
1 /* Copyright 2022 Mozilla Foundation
2  *
3  * Licensed under the Apache License, Version 2.0 (the "License");
4  * you may not use this file except in compliance with the License.
5  * You may obtain a copy of the License at
6  *
7  *     http://www.apache.org/licenses/LICENSE-2.0
8  *
9  * Unless required by applicable law or agreed to in writing, software
10  * distributed under the License is distributed on an "AS IS" BASIS,
11  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
12  * See the License for the specific language governing permissions and
13  * limitations under the License.
14  */
15 
16 import { clearPatternCaches } from "./pattern.js";
17 import { clearPrimitiveCaches } from "./primitives.js";
18 import { clearUnicodeCaches } from "./unicode.js";
19 
20 function clearGlobalCaches() {
21   clearPatternCaches();
22   clearPrimitiveCaches();
23   clearUnicodeCaches();
24 }
25 
26 export { clearGlobalCaches };
File:
src/core/decode_stream.js
1 /* Copyright 2012 Mozilla Foundation
2  *
3  * Licensed under the Apache License, Version 2.0 (the "License");
4  * you may not use this file except in compliance with the License.
5  * You may obtain a copy of the License at
6  *
7  *     http://www.apache.org/licenses/LICENSE-2.0
8  *
9  * Unless required by applicable law or agreed to in writing, software
10  * distributed under the License is distributed on an "AS IS" BASIS,
11  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
12  * See the License for the specific language governing permissions and
13  * limitations under the License.
14  */
15 
16 import { BaseStream } from "./base_stream.js";
17 import { Stream } from "./stream.js";
18 
19 // Lots of DecodeStreams are created whose buffers are never used.  For these
20 // we share a single empty buffer. This is (a) space-efficient and (b) avoids
21 // having special cases that would be required if we used |null| for an empty
22 // buffer.
23 const emptyBuffer = new Uint8Array(0);
24 
25 // Super class for the decoding streams.
26 class DecodeStream extends BaseStream {
27   constructor(maybeMinBufferLength) {
28     super();
29     this._rawMinBufferLength = maybeMinBufferLength || 0;
30 
31     this.pos = 0;
32     this.bufferLength = 0;
33     this.eof = false;
34     this.buffer = emptyBuffer;
35     this.minBufferLength = 512;
36     if (maybeMinBufferLength) {
37       // Compute the first power of two that is as big as maybeMinBufferLength.
38       while (this.minBufferLength < maybeMinBufferLength) {
39         this.minBufferLength *= 2;
40       }
41     }
42   }
43 
44   get isEmpty() {
45     while (!this.eof && this.bufferLength === 0) {
46       this.readBlock();
47     }
48     return this.bufferLength === 0;
49   }
50 
51   ensureBuffer(requested) {
52     const buffer = this.buffer;
53     if (requested <= buffer.byteLength) {
54       return buffer;
55     }
56     let size = this.minBufferLength;
57     while (size < requested) {
58       size *= 2;
59     }
60     const buffer2 = new Uint8Array(size);
61     buffer2.set(buffer);
62     return (this.buffer = buffer2);
63   }
64 
65   getByte() {
66     const pos = this.pos;
67     while (this.bufferLength <= pos) {
68       if (this.eof) {
69         return -1;
70       }
71       this.readBlock();
72     }
73     return this.buffer[this.pos++];
74   }
75 
76   getBytes(length) {
77     const pos = this.pos;
78     let end;
79 
80     if (length) {
81       this.ensureBuffer(pos + length);
82       end = pos + length;
83 
84       while (!this.eof && this.bufferLength < end) {
85         this.readBlock();
86       }
87       const bufEnd = this.bufferLength;
88       if (end > bufEnd) {
89         end = bufEnd;
90       }
91     } else {
92       while (!this.eof) {
93         this.readBlock();
94       }
95       end = this.bufferLength;
96     }
97 
98     this.pos = end;
99     return this.buffer.subarray(pos, end);
100   }
101 
102   reset() {
103     this.pos = 0;
104   }
105 
106   makeSubStream(start, length, dict = null) {
107     if (length === undefined) {
108       while (!this.eof) {
109         this.readBlock();
110       }
111     } else {
112       const end = start + length;
113       while (this.bufferLength <= end && !this.eof) {
114         this.readBlock();
115       }
116     }
117     return new Stream(this.buffer, start, length, dict);
118   }
119 
120   getBaseStreams() {
121     return this.str ? this.str.getBaseStreams() : null;
122   }
123 }
124 
125 class StreamsSequenceStream extends DecodeStream {
126   constructor(streams, onError = null) {
127     let maybeLength = 0;
128     for (const stream of streams) {
129       maybeLength +=
130         stream instanceof DecodeStream
131           ? stream._rawMinBufferLength
132           : stream.length;
133     }
134     super(maybeLength);
135 
136     this.streams = streams;
137     this._onError = onError;
138   }
139 
140   readBlock() {
141     const streams = this.streams;
142     if (streams.length === 0) {
143       this.eof = true;
144       return;
145     }
146     const stream = streams.shift();
147     let chunk;
148     try {
149       chunk = stream.getBytes();
150     } catch (reason) {
151       if (this._onError) {
152         this._onError(reason, stream.dict?.objId);
153         return;
154       }
155       throw reason;
156     }
157     const bufferLength = this.bufferLength;
158     const newLength = bufferLength + chunk.length;
159     const buffer = this.ensureBuffer(newLength);
160     buffer.set(chunk, bufferLength);
161     this.bufferLength = newLength;
162   }
163 
164   getBaseStreams() {
165     const baseStreamsBuf = [];
166     for (const stream of this.streams) {
167       const baseStreams = stream.getBaseStreams();
168       if (baseStreams) {
169         baseStreamsBuf.push(...baseStreams);
170       }
171     }
172     return baseStreamsBuf.length > 0 ? baseStreamsBuf : null;
173   }
174 }
175 
176 export { DecodeStream, StreamsSequenceStream };
File:
src/core/image.js
1 /* Copyright 2012 Mozilla Foundation
2  *
3  * Licensed under the Apache License, Version 2.0 (the "License");
4  * you may not use this file except in compliance with the License.
5  * You may obtain a copy of the License at
6  *
7  *     http://www.apache.org/licenses/LICENSE-2.0
8  *
9  * Unless required by applicable law or agreed to in writing, software
10  * distributed under the License is distributed on an "AS IS" BASIS,
11  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
12  * See the License for the specific language governing permissions and
13  * limitations under the License.
14  */
15 
16 import {
17   assert,
18   FeatureTest,
19   FormatError,
20   ImageKind,
21   info,
22   warn,
23 } from "../shared/util.js";
24 import {
25   convertBlackAndWhiteToRGBA,
26   convertToRGBA,
27 } from "../shared/image_utils.js";
28 import { BaseStream } from "./base_stream.js";
29 import { ColorSpace } from "./colorspace.js";
30 import { DecodeStream } from "./decode_stream.js";
31 import { ImageResizer } from "./image_resizer.js";
32 import { JpegStream } from "./jpeg_stream.js";
33 import { JpxImage } from "./jpx.js";
34 import { Name } from "./primitives.js";
35 
36 /**
37  * Decode and clamp a value. The formula is different from the spec because we
38  * don't decode to float range [0,1], we decode it in the [0,max] range.
39  */
40 function decodeAndClamp(value, addend, coefficient, max) {
41   value = addend + value * coefficient;
42   // Clamp the value to the range
43   if (value < 0) {
44     value = 0;
45   } else if (value > max) {
46     value = max;
47   }
48   return value;
49 }
50 
51 /**
52  * Resizes an image mask with 1 component.
53  * @param {TypedArray} src - The source buffer.
54  * @param {number} bpc - Number of bits per component.
55  * @param {number} w1 - Original width.
56  * @param {number} h1 - Original height.
57  * @param {number} w2 - New width.
58  * @param {number} h2 - New height.
59  * @returns {TypedArray} The resized image mask buffer.
60  */
61 function resizeImageMask(src, bpc, w1, h1, w2, h2) {
62   const length = w2 * h2;
63   let dest;
64   if (bpc <= 8) {
65     dest = new Uint8Array(length);
66   } else if (bpc <= 16) {
67     dest = new Uint16Array(length);
68   } else {
69     dest = new Uint32Array(length);
70   }
71   const xRatio = w1 / w2;
72   const yRatio = h1 / h2;
73   let i,
74     j,
75     py,
76     newIndex = 0,
77     oldIndex;
78   const xScaled = new Uint16Array(w2);
79   const w1Scanline = w1;
80 
81   for (i = 0; i < w2; i++) {
82     xScaled[i] = Math.floor(i * xRatio);
83   }
84   for (i = 0; i < h2; i++) {
85     py = Math.floor(i * yRatio) * w1Scanline;
86     for (j = 0; j < w2; j++) {
87       oldIndex = py + xScaled[j];
88       dest[newIndex++] = src[oldIndex];
89     }
90   }
91   return dest;
92 }
93 
94 class PDFImage {
95   constructor({
96     xref,
97     res,
98     image,
99     isInline = false,
100     smask = null,
101     mask = null,
102     isMask = false,
103     pdfFunctionFactory,
104     localColorSpaceCache,
105   }) {
106     this.image = image;
107     const dict = image.dict;
108 
109     const filter = dict.get("F", "Filter");
110     let filterName;
111     if (filter instanceof Name) {
112       filterName = filter.name;
113     } else if (Array.isArray(filter)) {
114       const filterZero = xref.fetchIfRef(filter[0]);
115       if (filterZero instanceof Name) {
116         filterName = filterZero.name;
117       }
118     }
119     switch (filterName) {
120       case "JPXDecode":
121         const jpxImage = new JpxImage();
122         jpxImage.parseImageProperties(image.stream);
123         image.stream.reset();
124 
125         image.width = jpxImage.width;
126         image.height = jpxImage.height;
127         image.bitsPerComponent = jpxImage.bitsPerComponent;
128         image.numComps = jpxImage.componentsCount;
129         break;
130       case "JBIG2Decode":
131         image.bitsPerComponent = 1;
132         image.numComps = 1;
133         break;
134     }
135 
136     let width = dict.get("W", "Width");
137     let height = dict.get("H", "Height");
138 
139     if (
140       Number.isInteger(image.width) &&
141       image.width > 0 &&
142       Number.isInteger(image.height) &&
143       image.height > 0 &&
144       (image.width !== width || image.height !== height)
145     ) {
146       warn(
147         "PDFImage - using the Width/Height of the image data, " +
148           "rather than the image dictionary."
149       );
150       width = image.width;
151       height = image.height;
152     }
153     if (width < 1 || height < 1) {
154       throw new FormatError(
155         `Invalid image width: ${width} or height: ${height}`
156       );
157     }
158     this.width = width;
159     this.height = height;
160 
161     this.interpolate = dict.get("I", "Interpolate");
162     this.imageMask = dict.get("IM", "ImageMask") || false;
163     this.matte = dict.get("Matte") || false;
164 
165     let bitsPerComponent = image.bitsPerComponent;
166     if (!bitsPerComponent) {
167       bitsPerComponent = dict.get("BPC", "BitsPerComponent");
168       if (!bitsPerComponent) {
169         if (this.imageMask) {
170           bitsPerComponent = 1;
171         } else {
172           throw new FormatError(
173             `Bits per component missing in image: ${this.imageMask}`
174           );
175         }
176       }
177     }
178     this.bpc = bitsPerComponent;
179 
180     if (!this.imageMask) {
181       let colorSpace = dict.getRaw("CS") || dict.getRaw("ColorSpace");
182       if (!colorSpace) {
183         info("JPX images (which do not require color spaces)");
184         switch (image.numComps) {
185           case 1:
186             colorSpace = Name.get("DeviceGray");
187             break;
188           case 3:
189             colorSpace = Name.get("DeviceRGB");
190             break;
191           case 4:
192             colorSpace = Name.get("DeviceCMYK");
193             break;
194           default:
195             throw new Error(
196               `JPX images with ${image.numComps} color components not supported.`
197             );
198         }
199       }
200       this.colorSpace = ColorSpace.parse({
201         cs: colorSpace,
202         xref,
203         resources: isInline ? res : null,
204         pdfFunctionFactory,
205         localColorSpaceCache,
206       });
207       this.numComps = this.colorSpace.numComps;
208     }
209 
210     this.decode = dict.getArray("D", "Decode");
211     this.needsDecode = false;
212     if (
213       this.decode &&
214       ((this.colorSpace &&
215         !this.colorSpace.isDefaultDecode(this.decode, bitsPerComponent)) ||
216         (isMask &&
217           !ColorSpace.isDefaultDecode(this.decode, /* numComps = */ 1)))
218     ) {
219       this.needsDecode = true;
220       // Do some preprocessing to avoid more math.
221       const max = (1 << bitsPerComponent) - 1;
222       this.decodeCoefficients = [];
223       this.decodeAddends = [];
224       const isIndexed = this.colorSpace?.name === "Indexed";
225       for (let i = 0, j = 0; i < this.decode.length; i += 2, ++j) {
226         const dmin = this.decode[i];
227         const dmax = this.decode[i + 1];
228         this.decodeCoefficients[j] = isIndexed
229           ? (dmax - dmin) / max
230           : dmax - dmin;
231         this.decodeAddends[j] = isIndexed ? dmin : max * dmin;
232       }
233     }
234 
235     if (smask) {
236       this.smask = new PDFImage({
237         xref,
238         res,
239         image: smask,
240         isInline,
241         pdfFunctionFactory,
242         localColorSpaceCache,
243       });
244     } else if (mask) {
245       if (mask instanceof BaseStream) {
246         const maskDict = mask.dict,
247           imageMask = maskDict.get("IM", "ImageMask");
248         if (!imageMask) {
249           warn("Ignoring /Mask in image without /ImageMask.");
250         } else {
251           this.mask = new PDFImage({
252             xref,
253             res,
254             image: mask,
255             isInline,
256             isMask: true,
257             pdfFunctionFactory,
258             localColorSpaceCache,
259           });
260         }
261       } else {
262         // Color key mask (just an array).
263         this.mask = mask;
264       }
265     }
266   }
267 
268   /**
269    * Handles processing of image data and returns the Promise that is resolved
270    * with a PDFImage when the image is ready to be used.
271    */
272   static async buildImage({
273     xref,
274     res,
275     image,
276     isInline = false,
277     pdfFunctionFactory,
278     localColorSpaceCache,
279   }) {
280     const imageData = image;
281     let smaskData = null;
282     let maskData = null;
283 
284     const smask = image.dict.get("SMask");
285     const mask = image.dict.get("Mask");
286 
287     if (smask) {
288       if (smask instanceof BaseStream) {
289         smaskData = smask;
290       } else {
291         warn("Unsupported /SMask format.");
292       }
293     } else if (mask) {
294       if (mask instanceof BaseStream || Array.isArray(mask)) {
295         maskData = mask;
296       } else {
297         warn("Unsupported /Mask format.");
298       }
299     }
300 
301     return new PDFImage({
302       xref,
303       res,
304       image: imageData,
305       isInline,
306       smask: smaskData,
307       mask: maskData,
308       pdfFunctionFactory,
309       localColorSpaceCache,
310     });
311   }
312 
313   static createRawMask({
314     imgArray,
315     width,
316     height,
317     imageIsFromDecodeStream,
318     inverseDecode,
319     interpolate,
320   }) {
321     // |imgArray| might not contain full data for every pixel of the mask, so
322     // we need to distinguish between |computedLength| and |actualLength|.
323     // In particular, if inverseDecode is true, then the array we return must
324     // have a length of |computedLength|.
325 
326     const computedLength = ((width + 7) >> 3) * height;
327     const actualLength = imgArray.byteLength;
328     const haveFullData = computedLength === actualLength;
329     let data, i;
330 
331     if (imageIsFromDecodeStream && (!inverseDecode || haveFullData)) {
332       // imgArray came from a DecodeStream and its data is in an appropriate
333       // form, so we can just transfer it.
334       data = imgArray;
335     } else if (!inverseDecode) {
336       data = new Uint8Array(imgArray);
337     } else {
338       data = new Uint8Array(computedLength);
339       data.set(imgArray);
340       data.fill(0xff, actualLength);
341     }
342 
343     // If necessary, invert the original mask data (but not any extra we might
344     // have added above). It's safe to modify the array -- whether it's the
345     // original or a copy, we're about to transfer it anyway, so nothing else
346     // in this thread can be relying on its contents.
347     if (inverseDecode) {
348       for (i = 0; i < actualLength; i++) {
349         data[i] ^= 0xff;
350       }
351     }
352 
353     return { data, width, height, interpolate };
354   }
355 
356   static async createMask({
357     imgArray,
358     width,
359     height,
360     imageIsFromDecodeStream,
361     inverseDecode,
362     interpolate,
363     isOffscreenCanvasSupported = false,
364   }) {
365     const isSingleOpaquePixel =
366       width === 1 &&
367       height === 1 &&
368       inverseDecode === (imgArray.length === 0 || !!(imgArray[0] & 128));
369 
370     if (isSingleOpaquePixel) {
371       return { isSingleOpaquePixel };
372     }
373 
374     if (isOffscreenCanvasSupported) {
375       if (ImageResizer.needsToBeResized(width, height)) {
376         const data = new Uint8ClampedArray(width * height * 4);
377         convertBlackAndWhiteToRGBA({
378           src: imgArray,
379           dest: data,
380           width,
381           height,
382           nonBlackColor: 0,
383           inverseDecode,
384         });
385         return ImageResizer.createImage({
386           kind: ImageKind.RGBA_32BPP,
387           data,
388           width,
389           height,
390           interpolate,
391         });
392       }
393 
394       const canvas = new OffscreenCanvas(width, height);
395       const ctx = canvas.getContext("2d");
396       const imgData = ctx.createImageData(width, height);
397       convertBlackAndWhiteToRGBA({
398         src: imgArray,
399         dest: imgData.data,
400         width,
401         height,
402         nonBlackColor: 0,
403         inverseDecode,
404       });
405 
406       ctx.putImageData(imgData, 0, 0);
407       const bitmap = canvas.transferToImageBitmap();
408 
409       return {
410         data: null,
411         width,
412         height,
413         interpolate,
414         bitmap,
415       };
416     }
417 
418     // Get the data almost as they're and they'll be decoded
419     // just before being drawn.
420     return this.createRawMask({
421       imgArray,
422       width,
423       height,
424       inverseDecode,
425       imageIsFromDecodeStream,
426       interpolate,
427     });
428   }
429 
430   get drawWidth() {
431     return Math.max(this.width, this.smask?.width || 0, this.mask?.width || 0);
432   }
433 
434   get drawHeight() {
435     return Math.max(
436       this.height,
437       this.smask?.height || 0,
438       this.mask?.height || 0
439     );
440   }
441 
442   decodeBuffer(buffer) {
443     const bpc = this.bpc;
444     const numComps = this.numComps;
445 
446     const decodeAddends = this.decodeAddends;
447     const decodeCoefficients = this.decodeCoefficients;
448     const max = (1 << bpc) - 1;
449     let i, ii;
450 
451     if (bpc === 1) {
452       // If the buffer needed decode that means it just needs to be inverted.
453       for (i = 0, ii = buffer.length; i < ii; i++) {
454         buffer[i] = +!buffer[i];
455       }
456       return;
457     }
458     let index = 0;
459     for (i = 0, ii = this.width * this.height; i < ii; i++) {
460       for (let j = 0; j < numComps; j++) {
461         buffer[index] = decodeAndClamp(
462           buffer[index],
463           decodeAddends[j],
464           decodeCoefficients[j],
465           max
466         );
467         index++;
468       }
469     }
470   }
471 
472   getComponents(buffer) {
473     const bpc = this.bpc;
474 
475     // This image doesn't require any extra work.
476     if (bpc === 8) {
477       return buffer;
478     }
479 
480     const width = this.width;
481     const height = this.height;
482     const numComps = this.numComps;
483 
484     const length = width * height * numComps;
485     let bufferPos = 0;
486     let output;
487     if (bpc <= 8) {
488       output = new Uint8Array(length);
489     } else if (bpc <= 16) {
490       output = new Uint16Array(length);
491     } else {
492       output = new Uint32Array(length);
493     }
494     const rowComps = width * numComps;
495 
496     const max = (1 << bpc) - 1;
497     let i = 0,
498       ii,
499       buf;
500 
501     if (bpc === 1) {
502       // Optimization for reading 1 bpc images.
503       let mask, loop1End, loop2End;
504       for (let j = 0; j < height; j++) {
505         loop1End = i + (rowComps & ~7);
506         loop2End = i + rowComps;
507 
508         // unroll loop for all full bytes
509         while (i < loop1End) {
510           buf = buffer[bufferPos++];
511           output[i] = (buf >> 7) & 1;
512           output[i + 1] = (buf >> 6) & 1;
513           output[i + 2] = (buf >> 5) & 1;
514           output[i + 3] = (buf >> 4) & 1;
515           output[i + 4] = (buf >> 3) & 1;
516           output[i + 5] = (buf >> 2) & 1;
517           output[i + 6] = (buf >> 1) & 1;
518           output[i + 7] = buf & 1;
519           i += 8;
520         }
521 
522         // handle remaining bits
523         if (i < loop2End) {
524           buf = buffer[bufferPos++];
525           mask = 128;
526           while (i < loop2End) {
527             output[i++] = +!!(buf & mask);
528             mask >>= 1;
529           }
530         }
531       }
532     } else {
533       // The general case that handles all other bpc values.
534       let bits = 0;
535       buf = 0;
536       for (i = 0, ii = length; i < ii; ++i) {
537         if (i % rowComps === 0) {
538           buf = 0;
539           bits = 0;
540         }
541 
542         while (bits < bpc) {
543           buf = (buf << 8) | buffer[bufferPos++];
544           bits += 8;
545         }
546 
547         const remainingBits = bits - bpc;
548         let value = buf >> remainingBits;
549         if (value < 0) {
550           value = 0;
551         } else if (value > max) {
552           value = max;
553         }
554         output[i] = value;
555         buf &= (1 << remainingBits) - 1;
556         bits = remainingBits;
557       }
558     }
559     return output;
560   }
561 
562   fillOpacity(rgbaBuf, width, height, actualHeight, image) {
563     if (typeof PDFJSDev === "undefined" || PDFJSDev.test("TESTING")) {
564       assert(
565         rgbaBuf instanceof Uint8ClampedArray,
566         'PDFImage.fillOpacity: Unsupported "rgbaBuf" type.'
567       );
568     }
569     const smask = this.smask;
570     const mask = this.mask;
571     let alphaBuf, sw, sh, i, ii, j;
572 
573     if (smask) {
574       sw = smask.width;
575       sh = smask.height;
576       alphaBuf = new Uint8ClampedArray(sw * sh);
577       smask.fillGrayBuffer(alphaBuf);
578       if (sw !== width || sh !== height) {
579         alphaBuf = resizeImageMask(alphaBuf, smask.bpc, sw, sh, width, height);
580       }
581     } else if (mask) {
582       if (mask instanceof PDFImage) {
583         sw = mask.width;
584         sh = mask.height;
585         alphaBuf = new Uint8ClampedArray(sw * sh);
586         mask.numComps = 1;
587         mask.fillGrayBuffer(alphaBuf);
588 
589         // Need to invert values in rgbaBuf
590         for (i = 0, ii = sw * sh; i < ii; ++i) {
591           alphaBuf[i] = 255 - alphaBuf[i];
592         }
593 
594         if (sw !== width || sh !== height) {
595           alphaBuf = resizeImageMask(alphaBuf, mask.bpc, sw, sh, width, height);
596         }
597       } else if (Array.isArray(mask)) {
598         // Color key mask: if any of the components are outside the range
599         // then they should be painted.
600         alphaBuf = new Uint8ClampedArray(width * height);
601         const numComps = this.numComps;
602         for (i = 0, ii = width * height; i < ii; ++i) {
603           let opacity = 0;
604           const imageOffset = i * numComps;
605           for (j = 0; j < numComps; ++j) {
606             const color = image[imageOffset + j];
607             const maskOffset = j * 2;
608             if (color < mask[maskOffset] || color > mask[maskOffset + 1]) {
609               opacity = 255;
610               break;
611             }
612           }
613           alphaBuf[i] = opacity;
614         }
615       } else {
616         throw new FormatError("Unknown mask format.");
617       }
618     }
619 
620     if (alphaBuf) {
621       for (i = 0, j = 3, ii = width * actualHeight; i < ii; ++i, j += 4) {
622         rgbaBuf[j] = alphaBuf[i];
623       }
624     } else {
625       // No mask.
626       for (i = 0, j = 3, ii = width * actualHeight; i < ii; ++i, j += 4) {
627         rgbaBuf[j] = 255;
628       }
629     }
630   }
631 
632   undoPreblend(buffer, width, height) {
633     if (typeof PDFJSDev === "undefined" || PDFJSDev.test("TESTING")) {
634       assert(
635         buffer instanceof Uint8ClampedArray,
636         'PDFImage.undoPreblend: Unsupported "buffer" type.'
637       );
638     }
639     const matte = this.smask?.matte;
640     if (!matte) {
641       return;
642     }
643     const matteRgb = this.colorSpace.getRgb(matte, 0);
644     const matteR = matteRgb[0];
645     const matteG = matteRgb[1];
646     const matteB = matteRgb[2];
647     const length = width * height * 4;
648     for (let i = 0; i < length; i += 4) {
649       const alpha = buffer[i + 3];
650       if (alpha === 0) {
651         // according formula we have to get Infinity in all components
652         // making it white (typical paper color) should be okay
653         buffer[i] = 255;
654         buffer[i + 1] = 255;
655         buffer[i + 2] = 255;
656         continue;
657       }
658       const k = 255 / alpha;
659       buffer[i] = (buffer[i] - matteR) * k + matteR;
660       buffer[i + 1] = (buffer[i + 1] - matteG) * k + matteG;
661       buffer[i + 2] = (buffer[i + 2] - matteB) * k + matteB;
662     }
663   }
664 
665   async createImageData(forceRGBA = false, isOffscreenCanvasSupported = false) {
666     const drawWidth = this.drawWidth;
667     const drawHeight = this.drawHeight;
668     const imgData = {
669       width: drawWidth,
670       height: drawHeight,
671       interpolate: this.interpolate,
672       kind: 0,
673       data: null,
674       // Other fields are filled in below.
675     };
676 
677     const numComps = this.numComps;
678     const originalWidth = this.width;
679     const originalHeight = this.height;
680     const bpc = this.bpc;
681 
682     // Rows start at byte boundary.
683     const rowBytes = (originalWidth * numComps * bpc + 7) >> 3;
684     const mustBeResized =
685       isOffscreenCanvasSupported &&
686       ImageResizer.needsToBeResized(drawWidth, drawHeight);
687 
688     if (!forceRGBA) {
689       // If it is a 1-bit-per-pixel grayscale (i.e. black-and-white) image
690       // without any complications, we pass a same-sized copy to the main
691       // thread rather than expanding by 32x to RGBA form. This saves *lots*
692       // of memory for many scanned documents. It's also much faster.
693       //
694       // Similarly, if it is a 24-bit-per pixel RGB image without any
695       // complications, we avoid expanding by 1.333x to RGBA form.
696       let kind;
697       if (this.colorSpace.name === "DeviceGray" && bpc === 1) {
698         kind = ImageKind.GRAYSCALE_1BPP;
699       } else if (
700         this.colorSpace.name === "DeviceRGB" &&
701         bpc === 8 &&
702         !this.needsDecode
703       ) {
704         kind = ImageKind.RGB_24BPP;
705       }
706       if (
707         kind &&
708         !this.smask &&
709         !this.mask &&
710         drawWidth === originalWidth &&
711         drawHeight === originalHeight
712       ) {
713         const data = this.getImageBytes(originalHeight * rowBytes, {});
714         if (isOffscreenCanvasSupported) {
715           if (mustBeResized) {
716             return ImageResizer.createImage(
717               {
718                 data,
719                 kind,
720                 width: drawWidth,
721                 height: drawHeight,
722                 interpolate: this.interpolate,
723               },
724               this.needsDecode
725             );
726           }
727           return this.createBitmap(kind, originalWidth, originalHeight, data);
728         }
729         imgData.kind = kind;
730         imgData.data = data;
731 
732         if (this.needsDecode) {
733           // Invert the buffer (which must be grayscale if we reached here).
734           assert(
735             kind === ImageKind.GRAYSCALE_1BPP,
736             "PDFImage.createImageData: The image must be grayscale."
737           );
738           const buffer = imgData.data;
739           for (let i = 0, ii = buffer.length; i < ii; i++) {
740             buffer[i] ^= 0xff;
741           }
742         }
743         return imgData;
744       }
745       if (
746         this.image instanceof JpegStream &&
747         !this.smask &&
748         !this.mask &&
749         !this.needsDecode
750       ) {
751         let imageLength = originalHeight * rowBytes;
752         if (isOffscreenCanvasSupported && !mustBeResized) {
753           let isHandled = false;
754           switch (this.colorSpace.name) {
755             case "DeviceGray":
756               // Avoid truncating the image, since `JpegImage.getData`
757               // will expand the image data when `forceRGB === true`.
758               imageLength *= 4;
759               isHandled = true;
760               break;
761             case "DeviceRGB":
762               imageLength = (imageLength / 3) * 4;
763               isHandled = true;
764               break;
765             case "DeviceCMYK":
766               isHandled = true;
767               break;
768           }
769 
770           if (isHandled) {
771             const rgba = this.getImageBytes(imageLength, {
772               drawWidth,
773               drawHeight,
774               forceRGBA: true,
775             });
776             return this.createBitmap(
777               ImageKind.RGBA_32BPP,
778               drawWidth,
779               drawHeight,
780               rgba
781             );
782           }
783         } else {
784           switch (this.colorSpace.name) {
785             case "DeviceGray":
786               imageLength *= 3;
787             /* falls through */
788             case "DeviceRGB":
789             case "DeviceCMYK":
790               imgData.kind = ImageKind.RGB_24BPP;
791               imgData.data = this.getImageBytes(imageLength, {
792                 drawWidth,
793                 drawHeight,
794                 forceRGB: true,
795               });
796               if (mustBeResized) {
797                 // The image is too big so we resize it.
798                 return ImageResizer.createImage(imgData);
799               }
800               return imgData;
801           }
802         }
803       }
804     }
805 
806     const imgArray = this.getImageBytes(originalHeight * rowBytes, {
807       internal: true,
808     });
809     // imgArray can be incomplete (e.g. after CCITT fax encoding).
810     const actualHeight =
811       0 | (((imgArray.length / rowBytes) * drawHeight) / originalHeight);
812 
813     const comps = this.getComponents(imgArray);
814 
815     // If opacity data is present, use RGBA_32BPP form. Otherwise, use the
816     // more compact RGB_24BPP form if allowable.
817     let alpha01, maybeUndoPreblend;
818 
819     let canvas, ctx, canvasImgData, data;
820     if (isOffscreenCanvasSupported && !mustBeResized) {
821       canvas = new OffscreenCanvas(drawWidth, drawHeight);
822       ctx = canvas.getContext("2d");
823       canvasImgData = ctx.createImageData(drawWidth, drawHeight);
824       data = canvasImgData.data;
825     }
826 
827     imgData.kind = ImageKind.RGBA_32BPP;
828 
829     if (!forceRGBA && !this.smask && !this.mask) {
830       if (!isOffscreenCanvasSupported || mustBeResized) {
831         imgData.kind = ImageKind.RGB_24BPP;
832         data = new Uint8ClampedArray(drawWidth * drawHeight * 3);
833         alpha01 = 0;
834       } else {
835         const arr = new Uint32Array(data.buffer);
836         arr.fill(FeatureTest.isLittleEndian ? 0xff000000 : 0x000000ff);
837         alpha01 = 1;
838       }
839       maybeUndoPreblend = false;
840     } else {
841       if (!isOffscreenCanvasSupported || mustBeResized) {
842         data = new Uint8ClampedArray(drawWidth * drawHeight * 4);
843       }
844 
845       alpha01 = 1;
846       maybeUndoPreblend = true;
847 
848       // Color key masking (opacity) must be performed before decoding.
849       this.fillOpacity(data, drawWidth, drawHeight, actualHeight, comps);
850     }
851 
852     if (this.needsDecode) {
853       this.decodeBuffer(comps);
854     }
855     this.colorSpace.fillRgb(
856       data,
857       originalWidth,
858       originalHeight,
859       drawWidth,
860       drawHeight,
861       actualHeight,
862       bpc,
863       comps,
864       alpha01
865     );
866     if (maybeUndoPreblend) {
867       this.undoPreblend(data, drawWidth, actualHeight);
868     }
869 
870     if (isOffscreenCanvasSupported && !mustBeResized) {
871       ctx.putImageData(canvasImgData, 0, 0);
872       const bitmap = canvas.transferToImageBitmap();
873 
874       return {
875         data: null,
876         width: drawWidth,
877         height: drawHeight,
878         bitmap,
879         interpolate: this.interpolate,
880       };
881     }
882 
883     imgData.data = data;
884     if (mustBeResized) {
885       return ImageResizer.createImage(imgData);
886     }
887     return imgData;
888   }
889 
890   fillGrayBuffer(buffer) {
891     if (typeof PDFJSDev === "undefined" || PDFJSDev.test("TESTING")) {
892       assert(
893         buffer instanceof Uint8ClampedArray,
894         'PDFImage.fillGrayBuffer: Unsupported "buffer" type.'
895       );
896     }
897     const numComps = this.numComps;
898     if (numComps !== 1) {
899       throw new FormatError(
900         `Reading gray scale from a color image: ${numComps}`
901       );
902     }
903 
904     const width = this.width;
905     const height = this.height;
906     const bpc = this.bpc;
907 
908     // rows start at byte boundary
909     const rowBytes = (width * numComps * bpc + 7) >> 3;
910     const imgArray = this.getImageBytes(height * rowBytes, { internal: true });
911 
912     const comps = this.getComponents(imgArray);
913     let i, length;
914 
915     if (bpc === 1) {
916       // inline decoding (= inversion) for 1 bpc images
917       length = width * height;
918       if (this.needsDecode) {
919         // invert and scale to {0, 255}
920         for (i = 0; i < length; ++i) {
921           buffer[i] = (comps[i] - 1) & 255;
922         }
923       } else {
924         // scale to {0, 255}
925         for (i = 0; i < length; ++i) {
926           buffer[i] = -comps[i] & 255;
927         }
928       }
929       return;
930     }
931 
932     if (this.needsDecode) {
933       this.decodeBuffer(comps);
934     }
935     length = width * height;
936     // we aren't using a colorspace so we need to scale the value
937     const scale = 255 / ((1 << bpc) - 1);
938     for (i = 0; i < length; ++i) {
939       buffer[i] = scale * comps[i];
940     }
941   }
942 
943   createBitmap(kind, width, height, src) {
944     const canvas = new OffscreenCanvas(width, height);
945     const ctx = canvas.getContext("2d");
946     let imgData;
947     if (kind === ImageKind.RGBA_32BPP) {
948       imgData = new ImageData(src, width, height);
949     } else {
950       imgData = ctx.createImageData(width, height);
951       convertToRGBA({
952         kind,
953         src,
954         dest: new Uint32Array(imgData.data.buffer),
955         width,
956         height,
957         inverseDecode: this.needsDecode,
958       });
959     }
960     ctx.putImageData(imgData, 0, 0);
961     const bitmap = canvas.transferToImageBitmap();
962 
963     return {
964       data: null,
965       width,
966       height,
967       bitmap,
968       interpolate: this.interpolate,
969     };
970   }
971 
972   getImageBytes(
973     length,
974     {
975       drawWidth,
976       drawHeight,
977       forceRGBA = false,
978       forceRGB = false,
979       internal = false,
980     }
981   ) {
982     this.image.reset();
983     this.image.drawWidth = drawWidth || this.width;
984     this.image.drawHeight = drawHeight || this.height;
985     this.image.forceRGBA = !!forceRGBA;
986     this.image.forceRGB = !!forceRGB;
987     const imageBytes = this.image.getBytes(length);
988 
989     // If imageBytes came from a DecodeStream, we're safe to transfer it
990     // (and thus detach its underlying buffer) because it will constitute
991     // the entire DecodeStream's data.  But if it came from a Stream, we
992     // need to copy it because it'll only be a portion of the Stream's
993     // data, and the rest will be read later on.
994     if (internal || this.image instanceof DecodeStream) {
995       return imageBytes;
996     }
997     assert(
998       imageBytes instanceof Uint8Array,
999       'PDFImage.getImageBytes: Unsupported "imageBytes" type.'
1000     );
1001     return new Uint8Array(imageBytes);
1002   }
1003 }
1004 
1005 export { PDFImage };
File:
src/core/jpx.js
1 /* Copyright 2012 Mozilla Foundation
2  *
3  * Licensed under the Apache License, Version 2.0 (the "License");
4  * you may not use this file except in compliance with the License.
5  * You may obtain a copy of the License at
6  *
7  *     http://www.apache.org/licenses/LICENSE-2.0
8  *
9  * Unless required by applicable law or agreed to in writing, software
10  * distributed under the License is distributed on an "AS IS" BASIS,
11  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
12  * See the License for the specific language governing permissions and
13  * limitations under the License.
14  */
15 
16 import { BaseException, info, unreachable, warn } from "../shared/util.js";
17 import { log2, readUint16, readUint32 } from "./core_utils.js";
18 import { ArithmeticDecoder } from "./arithmetic_decoder.js";
19 
20 class JpxError extends BaseException {
21   constructor(msg) {
22     super(`JPX error: ${msg}`, "JpxError");
23   }
24 }
25 
26 // Table E.1
27 const SubbandsGainLog2 = {
28   LL: 0,
29   LH: 1,
30   HL: 1,
31   HH: 2,
32 };
33 
34 class JpxImage {
35   constructor() {
36     this.failOnCorruptedImage = false;
37   }
38 
39   parse(data) {
40     const head = readUint16(data, 0);
41     // No box header, immediate start of codestream (SOC)
42     if (head === 0xff4f) {
43       this.parseCodestream(data, 0, data.length);
44       return;
45     }
46 
47     const length = data.length;
48     let position = 0;
49     while (position < length) {
50       let headerSize = 8;
51       let lbox = readUint32(data, position);
52       const tbox = readUint32(data, position + 4);
53       position += headerSize;
54       if (lbox === 1) {
55         // XLBox: read UInt64 according to spec.
56         // JavaScript's int precision of 53 bit should be sufficient here.
57         lbox =
58           readUint32(data, position) * 4294967296 +
59           readUint32(data, position + 4);
60         position += 8;
61         headerSize += 8;
62       }
63       if (lbox === 0) {
64         lbox = length - position + headerSize;
65       }
66       if (lbox < headerSize) {
67         throw new JpxError("Invalid box field size");
68       }
69       const dataLength = lbox - headerSize;
70       let jumpDataLength = true;
71       switch (tbox) {
72         case 0x6a703268: // 'jp2h'
73           jumpDataLength = false; // parsing child boxes
74           break;
75         case 0x636f6c72: // 'colr'
76           // Colorspaces are not used, the CS from the PDF is used.
77           const method = data[position];
78           if (method === 1) {
79             // enumerated colorspace
80             const colorspace = readUint32(data, position + 3);
81             switch (colorspace) {
82               case 16: // this indicates a sRGB colorspace
83               case 17: // this indicates a grayscale colorspace
84               case 18: // this indicates a YUV colorspace
85                 break;
86               default:
87                 warn("Unknown colorspace " + colorspace);
88                 break;
89             }
90           } else if (method === 2) {
91             info("ICC profile not supported");
92           }
93           break;
94         case 0x6a703263: // 'jp2c'
95           this.parseCodestream(data, position, position + dataLength);
96           break;
97         case 0x6a502020: // 'jP\024\024'
98           if (readUint32(data, position) !== 0x0d0a870a) {
99             warn("Invalid JP2 signature");
100           }
101           break;
102         // The following header types are valid but currently not used:
103         case 0x6a501a1a: // 'jP\032\032'
104         case 0x66747970: // 'ftyp'
105         case 0x72726571: // 'rreq'
106         case 0x72657320: // 'res '
107         case 0x69686472: // 'ihdr'
108           break;
109         default:
110           const headerType = String.fromCharCode(
111             (tbox >> 24) & 0xff,
112             (tbox >> 16) & 0xff,
113             (tbox >> 8) & 0xff,
114             tbox & 0xff
115           );
116           warn(`Unsupported header type ${tbox} (${headerType}).`);
117           break;
118       }
119       if (jumpDataLength) {
120         position += dataLength;
121       }
122     }
123   }
124 
125   parseImageProperties(stream) {
126     let newByte = stream.getByte();
127     while (newByte >= 0) {
128       const oldByte = newByte;
129       newByte = stream.getByte();
130       const code = (oldByte << 8) | newByte;
131       // Image and tile size (SIZ)
132       if (code === 0xff51) {
133         stream.skip(4);
134         const Xsiz = stream.getInt32() >>> 0; // Byte 4
135         const Ysiz = stream.getInt32() >>> 0; // Byte 8
136         const XOsiz = stream.getInt32() >>> 0; // Byte 12
137         const YOsiz = stream.getInt32() >>> 0; // Byte 16
138         stream.skip(16);
139         const Csiz = stream.getUint16(); // Byte 36
140         this.width = Xsiz - XOsiz;
141         this.height = Ysiz - YOsiz;
142         this.componentsCount = Csiz;
143         // Results are always returned as `Uint8ClampedArray`s.
144         this.bitsPerComponent = 8;
145         return;
146       }
147     }
148     throw new JpxError("No size marker found in JPX stream");
149   }
150 
151   parseCodestream(data, start, end) {
152     const context = {};
153     let doNotRecover = false;
154     try {
155       let position = start;
156       while (position + 1 < end) {
157         const code = readUint16(data, position);
158         position += 2;
159 
160         let length = 0,
161           j,
162           sqcd,
163           spqcds,
164           spqcdSize,
165           scalarExpounded,
166           tile;
167         switch (code) {
168           case 0xff4f: // Start of codestream (SOC)
169             context.mainHeader = true;
170             break;
171           case 0xffd9: // End of codestream (EOC)
172             break;
173           case 0xff51: // Image and tile size (SIZ)
174             length = readUint16(data, position);
175             const siz = {};
176             siz.Xsiz = readUint32(data, position + 4);
177             siz.Ysiz = readUint32(data, position + 8);
178             siz.XOsiz = readUint32(data, position + 12);
179             siz.YOsiz = readUint32(data, position + 16);
180             siz.XTsiz = readUint32(data, position + 20);
181             siz.YTsiz = readUint32(data, position + 24);
182             siz.XTOsiz = readUint32(data, position + 28);
183             siz.YTOsiz = readUint32(data, position + 32);
184             const componentsCount = readUint16(data, position + 36);
185             siz.Csiz = componentsCount;
186             const components = [];
187             j = position + 38;
188             for (let i = 0; i < componentsCount; i++) {
189               const component = {
190                 precision: (data[j] & 0x7f) + 1,
191                 isSigned: !!(data[j] & 0x80),
192                 XRsiz: data[j + 1],
193                 YRsiz: data[j + 2],
194               };
195               j += 3;
196               calculateComponentDimensions(component, siz);
197               components.push(component);
198             }
199             context.SIZ = siz;
200             context.components = components;
201             calculateTileGrids(context, components);
202             context.QCC = [];
203             context.COC = [];
204             break;
205           case 0xff5c: // Quantization default (QCD)
206             length = readUint16(data, position);
207             const qcd = {};
208             j = position + 2;
209             sqcd = data[j++];
210             switch (sqcd & 0x1f) {
211               case 0:
212                 spqcdSize = 8;
213                 scalarExpounded = true;
214                 break;
215               case 1:
216                 spqcdSize = 16;
217                 scalarExpounded = false;
218                 break;
219               case 2:
220                 spqcdSize = 16;
221                 scalarExpounded = true;
222                 break;
223               default:
224                 throw new Error("Invalid SQcd value " + sqcd);
225             }
226             qcd.noQuantization = spqcdSize === 8;
227             qcd.scalarExpounded = scalarExpounded;
228             qcd.guardBits = sqcd >> 5;
229             spqcds = [];
230             while (j < length + position) {
231               const spqcd = {};
232               if (spqcdSize === 8) {
233                 spqcd.epsilon = data[j++] >> 3;
234                 spqcd.mu = 0;
235               } else {
236                 spqcd.epsilon = data[j] >> 3;
237                 spqcd.mu = ((data[j] & 0x7) << 8) | data[j + 1];
238                 j += 2;
239               }
240               spqcds.push(spqcd);
241             }
242             qcd.SPqcds = spqcds;
243             if (context.mainHeader) {
244               context.QCD = qcd;
245             } else {
246               context.currentTile.QCD = qcd;
247               context.currentTile.QCC = [];
248             }
249             break;
250           case 0xff5d: // Quantization component (QCC)
251             length = readUint16(data, position);
252             const qcc = {};
253             j = position + 2;
254             let cqcc;
255             if (context.SIZ.Csiz < 257) {
256               cqcc = data[j++];
257             } else {
258               cqcc = readUint16(data, j);
259               j += 2;
260             }
261             sqcd = data[j++];
262             switch (sqcd & 0x1f) {
263               case 0:
264                 spqcdSize = 8;
265                 scalarExpounded = true;
266                 break;
267               case 1:
268                 spqcdSize = 16;
269                 scalarExpounded = false;
270                 break;
271               case 2:
272                 spqcdSize = 16;
273                 scalarExpounded = true;
274                 break;
275               default:
276                 throw new Error("Invalid SQcd value " + sqcd);
277             }
278             qcc.noQuantization = spqcdSize === 8;
279             qcc.scalarExpounded = scalarExpounded;
280             qcc.guardBits = sqcd >> 5;
281             spqcds = [];
282             while (j < length + position) {
283               const spqcd = {};
284               if (spqcdSize === 8) {
285                 spqcd.epsilon = data[j++] >> 3;
286                 spqcd.mu = 0;
287               } else {
288                 spqcd.epsilon = data[j] >> 3;
289                 spqcd.mu = ((data[j] & 0x7) << 8) | data[j + 1];
290                 j += 2;
291               }
292               spqcds.push(spqcd);
293             }
294             qcc.SPqcds = spqcds;
295             if (context.mainHeader) {
296               context.QCC[cqcc] = qcc;
297             } else {
298               context.currentTile.QCC[cqcc] = qcc;
299             }
300             break;
301           case 0xff52: // Coding style default (COD)
302             length = readUint16(data, position);
303             const cod = {};
304             j = position + 2;
305             const scod = data[j++];
306             cod.entropyCoderWithCustomPrecincts = !!(scod & 1);
307             cod.sopMarkerUsed = !!(scod & 2);
308             cod.ephMarkerUsed = !!(scod & 4);
309             cod.progressionOrder = data[j++];
310             cod.layersCount = readUint16(data, j);
311             j += 2;
312             cod.multipleComponentTransform = data[j++];
313 
314             cod.decompositionLevelsCount = data[j++];
315             cod.xcb = (data[j++] & 0xf) + 2;
316             cod.ycb = (data[j++] & 0xf) + 2;
317             const blockStyle = data[j++];
318             cod.selectiveArithmeticCodingBypass = !!(blockStyle & 1);
319             cod.resetContextProbabilities = !!(blockStyle & 2);
320             cod.terminationOnEachCodingPass = !!(blockStyle & 4);
321             cod.verticallyStripe = !!(blockStyle & 8);
322             cod.predictableTermination = !!(blockStyle & 16);
323             cod.segmentationSymbolUsed = !!(blockStyle & 32);
324             cod.reversibleTransformation = data[j++];
325             if (cod.entropyCoderWithCustomPrecincts) {
326               const precinctsSizes = [];
327               while (j < length + position) {
328                 const precinctsSize = data[j++];
329                 precinctsSizes.push({
330                   PPx: precinctsSize & 0xf,
331                   PPy: precinctsSize >> 4,
332                 });
333               }
334               cod.precinctsSizes = precinctsSizes;
335             }
336             const unsupported = [];
337             if (cod.selectiveArithmeticCodingBypass) {
338               unsupported.push("selectiveArithmeticCodingBypass");
339             }
340             if (cod.terminationOnEachCodingPass) {
341               unsupported.push("terminationOnEachCodingPass");
342             }
343             if (cod.verticallyStripe) {
344               unsupported.push("verticallyStripe");
345             }
346             if (cod.predictableTermination) {
347               unsupported.push("predictableTermination");
348             }
349             if (unsupported.length > 0) {
350               doNotRecover = true;
351               warn(`JPX: Unsupported COD options (${unsupported.join(", ")}).`);
352             }
353             if (context.mainHeader) {
354               context.COD = cod;
355             } else {
356               context.currentTile.COD = cod;
357               context.currentTile.COC = [];
358             }
359             break;
360           case 0xff90: // Start of tile-part (SOT)
361             length = readUint16(data, position);
362             tile = {};
363             tile.index = readUint16(data, position + 2);
364             tile.length = readUint32(data, position + 4);
365             tile.dataEnd = tile.length + position - 2;
366             tile.partIndex = data[position + 8];
367             tile.partsCount = data[position + 9];
368 
369             context.mainHeader = false;
370             if (tile.partIndex === 0) {
371               // reset component specific settings
372               tile.COD = context.COD;
373               tile.COC = context.COC.slice(0); // clone of the global COC
374               tile.QCD = context.QCD;
375               tile.QCC = context.QCC.slice(0); // clone of the global COC
376             }
377             context.currentTile = tile;
378             break;
379           case 0xff93: // Start of data (SOD)
380             tile = context.currentTile;
381             if (tile.partIndex === 0) {
382               initializeTile(context, tile.index);
383               buildPackets(context);
384             }
385 
386             // moving to the end of the data
387             length = tile.dataEnd - position;
388             parseTilePackets(context, data, position, length);
389             break;
390           case 0xff53: // Coding style component (COC)
391             warn("JPX: Codestream code 0xFF53 (COC) is not implemented.");
392           /* falls through */
393           case 0xff55: // Tile-part lengths, main header (TLM)
394           case 0xff57: // Packet length, main header (PLM)
395           case 0xff58: // Packet length, tile-part header (PLT)
396           case 0xff64: // Comment (COM)
397             length = readUint16(data, position);
398             // skipping content
399             break;
400           default:
401             throw new Error("Unknown codestream code: " + code.toString(16));
402         }
403         position += length;
404       }
405     } catch (e) {
406       if (doNotRecover || this.failOnCorruptedImage) {
407         throw new JpxError(e.message);
408       } else {
409         warn(`JPX: Trying to recover from: "${e.message}".`);
410       }
411     }
412     this.tiles = transformComponents(context);
413     this.width = context.SIZ.Xsiz - context.SIZ.XOsiz;
414     this.height = context.SIZ.Ysiz - context.SIZ.YOsiz;
415     this.componentsCount = context.SIZ.Csiz;
416   }
417 }
418 
419 function calculateComponentDimensions(component, siz) {
420   // Section B.2 Component mapping
421   component.x0 = Math.ceil(siz.XOsiz / component.XRsiz);
422   component.x1 = Math.ceil(siz.Xsiz / component.XRsiz);
423   component.y0 = Math.ceil(siz.YOsiz / component.YRsiz);
424   component.y1 = Math.ceil(siz.Ysiz / component.YRsiz);
425   component.width = component.x1 - component.x0;
426   component.height = component.y1 - component.y0;
427 }
428 function calculateTileGrids(context, components) {
429   const siz = context.SIZ;
430   // Section B.3 Division into tile and tile-components
431   const tiles = [];
432   let tile;
433   const numXtiles = Math.ceil((siz.Xsiz - siz.XTOsiz) / siz.XTsiz);
434   const numYtiles = Math.ceil((siz.Ysiz - siz.YTOsiz) / siz.YTsiz);
435   for (let q = 0; q < numYtiles; q++) {
436     for (let p = 0; p < numXtiles; p++) {
437       tile = {};
438       tile.tx0 = Math.max(siz.XTOsiz + p * siz.XTsiz, siz.XOsiz);
439       tile.ty0 = Math.max(siz.YTOsiz + q * siz.YTsiz, siz.YOsiz);
440       tile.tx1 = Math.min(siz.XTOsiz + (p + 1) * siz.XTsiz, siz.Xsiz);
441       tile.ty1 = Math.min(siz.YTOsiz + (q + 1) * siz.YTsiz, siz.Ysiz);
442       tile.width = tile.tx1 - tile.tx0;
443       tile.height = tile.ty1 - tile.ty0;
444       tile.components = [];
445       tiles.push(tile);
446     }
447   }
448   context.tiles = tiles;
449 
450   const componentsCount = siz.Csiz;
451   for (let i = 0, ii = componentsCount; i < ii; i++) {
452     const component = components[i];
453     for (let j = 0, jj = tiles.length; j < jj; j++) {
454       const tileComponent = {};
455       tile = tiles[j];
456       tileComponent.tcx0 = Math.ceil(tile.tx0 / component.XRsiz);
457       tileComponent.tcy0 = Math.ceil(tile.ty0 / component.YRsiz);
458       tileComponent.tcx1 = Math.ceil(tile.tx1 / component.XRsiz);
459       tileComponent.tcy1 = Math.ceil(tile.ty1 / component.YRsiz);
460       tileComponent.width = tileComponent.tcx1 - tileComponent.tcx0;
461       tileComponent.height = tileComponent.tcy1 - tileComponent.tcy0;
462       tile.components[i] = tileComponent;
463     }
464   }
465 }
466 function getBlocksDimensions(context, component, r) {
467   const codOrCoc = component.codingStyleParameters;
468   const result = {};
469   if (!codOrCoc.entropyCoderWithCustomPrecincts) {
470     result.PPx = 15;
471     result.PPy = 15;
472   } else {
473     result.PPx = codOrCoc.precinctsSizes[r].PPx;
474     result.PPy = codOrCoc.precinctsSizes[r].PPy;
475   }
476   // calculate codeblock size as described in section B.7
477   result.xcb_ =
478     r > 0
479       ? Math.min(codOrCoc.xcb, result.PPx - 1)
480       : Math.min(codOrCoc.xcb, result.PPx);
481   result.ycb_ =
482     r > 0
483       ? Math.min(codOrCoc.ycb, result.PPy - 1)
484       : Math.min(codOrCoc.ycb, result.PPy);
485   return result;
486 }
487 function buildPrecincts(context, resolution, dimensions) {
488   // Section B.6 Division resolution to precincts
489   const precinctWidth = 1 << dimensions.PPx;
490   const precinctHeight = 1 << dimensions.PPy;
491   // Jasper introduces codeblock groups for mapping each subband codeblocks
492   // to precincts. Precinct partition divides a resolution according to width
493   // and height parameters. The subband that belongs to the resolution level
494   // has a different size than the level, unless it is the zero resolution.
495 
496   // From Jasper documentation: jpeg2000.pdf, section K: Tier-2 coding:
497   // The precinct partitioning for a particular subband is derived from a
498   // partitioning of its parent LL band (i.e., the LL band at the next higher
499   // resolution level)... The LL band associated with each resolution level is
500   // divided into precincts... Each of the resulting precinct regions is then
501   // mapped into its child subbands (if any) at the next lower resolution
502   // level. This is accomplished by using the coordinate transformation
503   // (u, v) = (ceil(x/2), ceil(y/2)) where (x, y) and (u, v) are the
504   // coordinates of a point in the LL band and child subband, respectively.
505   const isZeroRes = resolution.resLevel === 0;
506   const precinctWidthInSubband = 1 << (dimensions.PPx + (isZeroRes ? 0 : -1));
507   const precinctHeightInSubband = 1 << (dimensions.PPy + (isZeroRes ? 0 : -1));
508   const numprecinctswide =
509     resolution.trx1 > resolution.trx0
510       ? Math.ceil(resolution.trx1 / precinctWidth) -
511         Math.floor(resolution.trx0 / precinctWidth)
512       : 0;
513   const numprecinctshigh =
514     resolution.try1 > resolution.try0
515       ? Math.ceil(resolution.try1 / precinctHeight) -
516         Math.floor(resolution.try0 / precinctHeight)
517       : 0;
518   const numprecincts = numprecinctswide * numprecinctshigh;
519 
520   resolution.precinctParameters = {
521     precinctWidth,
522     precinctHeight,
523     numprecinctswide,
524     numprecinctshigh,
525     numprecincts,
526     precinctWidthInSubband,
527     precinctHeightInSubband,
528   };
529 }
530 function buildCodeblocks(context, subband, dimensions) {
531   // Section B.7 Division sub-band into code-blocks
532   const xcb_ = dimensions.xcb_;
533   const ycb_ = dimensions.ycb_;
534   const codeblockWidth = 1 << xcb_;
535   const codeblockHeight = 1 << ycb_;
536   const cbx0 = subband.tbx0 >> xcb_;
537   const cby0 = subband.tby0 >> ycb_;
538   const cbx1 = (subband.tbx1 + codeblockWidth - 1) >> xcb_;
539   const cby1 = (subband.tby1 + codeblockHeight - 1) >> ycb_;
540   const precinctParameters = subband.resolution.precinctParameters;
541   const codeblocks = [];
542   const precincts = [];
543   let i, j, codeblock, precinctNumber;
544   for (j = cby0; j < cby1; j++) {
545     for (i = cbx0; i < cbx1; i++) {
546       codeblock = {
547         cbx: i,
548         cby: j,
549         tbx0: codeblockWidth * i,
550         tby0: codeblockHeight * j,
551         tbx1: codeblockWidth * (i + 1),
552         tby1: codeblockHeight * (j + 1),
553       };
554 
555       codeblock.tbx0_ = Math.max(subband.tbx0, codeblock.tbx0);
556       codeblock.tby0_ = Math.max(subband.tby0, codeblock.tby0);
557       codeblock.tbx1_ = Math.min(subband.tbx1, codeblock.tbx1);
558       codeblock.tby1_ = Math.min(subband.tby1, codeblock.tby1);
559 
560       // Calculate precinct number for this codeblock, codeblock position
561       // should be relative to its subband, use actual dimension and position
562       // See comment about codeblock group width and height
563       const pi = Math.floor(
564         (codeblock.tbx0_ - subband.tbx0) /
565           precinctParameters.precinctWidthInSubband
566       );
567       const pj = Math.floor(
568         (codeblock.tby0_ - subband.tby0) /
569           precinctParameters.precinctHeightInSubband
570       );
571       precinctNumber = pi + pj * precinctParameters.numprecinctswide;
572 
573       codeblock.precinctNumber = precinctNumber;
574       codeblock.subbandType = subband.type;
575       codeblock.Lblock = 3;
576 
577       if (
578         codeblock.tbx1_ <= codeblock.tbx0_ ||
579         codeblock.tby1_ <= codeblock.tby0_
580       ) {
581         continue;
582       }
583       codeblocks.push(codeblock);
584       // building precinct for the sub-band
585       let precinct = precincts[precinctNumber];
586       if (precinct !== undefined) {
587         if (i < precinct.cbxMin) {
588           precinct.cbxMin = i;
589         } else if (i > precinct.cbxMax) {
590           precinct.cbxMax = i;
591         }
592         if (j < precinct.cbyMin) {
593           precinct.cbxMin = j;
594         } else if (j > precinct.cbyMax) {
595           precinct.cbyMax = j;
596         }
597       } else {
598         precincts[precinctNumber] = precinct = {
599           cbxMin: i,
600           cbyMin: j,
601           cbxMax: i,
602           cbyMax: j,
603         };
604       }
605       codeblock.precinct = precinct;
606     }
607   }
608   subband.codeblockParameters = {
609     codeblockWidth: xcb_,
610     codeblockHeight: ycb_,
611     numcodeblockwide: cbx1 - cbx0 + 1,
612     numcodeblockhigh: cby1 - cby0 + 1,
613   };
614   subband.codeblocks = codeblocks;
615   subband.precincts = precincts;
616 }
617 function createPacket(resolution, precinctNumber, layerNumber) {
618   const precinctCodeblocks = [];
619   // Section B.10.8 Order of info in packet
620   const subbands = resolution.subbands;
621   // sub-bands already ordered in 'LL', 'HL', 'LH', and 'HH' sequence
622   for (let i = 0, ii = subbands.length; i < ii; i++) {
623     const subband = subbands[i];
624     const codeblocks = subband.codeblocks;
625     for (let j = 0, jj = codeblocks.length; j < jj; j++) {
626       const codeblock = codeblocks[j];
627       if (codeblock.precinctNumber !== precinctNumber) {
628         continue;
629       }
630       precinctCodeblocks.push(codeblock);
631     }
632   }
633   return {
634     layerNumber,
635     codeblocks: precinctCodeblocks,
636   };
637 }
638 function LayerResolutionComponentPositionIterator(context) {
639   const siz = context.SIZ;
640   const tileIndex = context.currentTile.index;
641   const tile = context.tiles[tileIndex];
642   const layersCount = tile.codingStyleDefaultParameters.layersCount;
643   const componentsCount = siz.Csiz;
644   let maxDecompositionLevelsCount = 0;
645   for (let q = 0; q < componentsCount; q++) {
646     maxDecompositionLevelsCount = Math.max(
647       maxDecompositionLevelsCount,
648       tile.components[q].codingStyleParameters.decompositionLevelsCount
649     );
650   }
651 
652   let l = 0,
653     r = 0,
654     i = 0,
655     k = 0;
656 
657   this.nextPacket = function JpxImage_nextPacket() {
658     // Section B.12.1.1 Layer-resolution-component-position
659     for (; l < layersCount; l++) {
660       for (; r <= maxDecompositionLevelsCount; r++) {
661         for (; i < componentsCount; i++) {
662           const component = tile.components[i];
663           if (r > component.codingStyleParameters.decompositionLevelsCount) {
664             continue;
665           }
666 
667           const resolution = component.resolutions[r];
668           const numprecincts = resolution.precinctParameters.numprecincts;
669           for (; k < numprecincts; ) {
670             const packet = createPacket(resolution, k, l);
671             k++;
672             return packet;
673           }
674           k = 0;
675         }
676         i = 0;
677       }
678       r = 0;
679     }
680     throw new JpxError("Out of packets");
681   };
682 }
683 function ResolutionLayerComponentPositionIterator(context) {
684   const siz = context.SIZ;
685   const tileIndex = context.currentTile.index;
686   const tile = context.tiles[tileIndex];
687   const layersCount = tile.codingStyleDefaultParameters.layersCount;
688   const componentsCount = siz.Csiz;
689   let maxDecompositionLevelsCount = 0;
690   for (let q = 0; q < componentsCount; q++) {
691     maxDecompositionLevelsCount = Math.max(
692       maxDecompositionLevelsCount,
693       tile.components[q].codingStyleParameters.decompositionLevelsCount
694     );
695   }
696 
697   let r = 0,
698     l = 0,
699     i = 0,
700     k = 0;
701 
702   this.nextPacket = function JpxImage_nextPacket() {
703     // Section B.12.1.2 Resolution-layer-component-position
704     for (; r <= maxDecompositionLevelsCount; r++) {
705       for (; l < layersCount; l++) {
706         for (; i < componentsCount; i++) {
707           const component = tile.components[i];
708           if (r > component.codingStyleParameters.decompositionLevelsCount) {
709             continue;
710           }
711 
712           const resolution = component.resolutions[r];
713           const numprecincts = resolution.precinctParameters.numprecincts;
714           for (; k < numprecincts; ) {
715             const packet = createPacket(resolution, k, l);
716             k++;
717             return packet;
718           }
719           k = 0;
720         }
721         i = 0;
722       }
723       l = 0;
724     }
725     throw new JpxError("Out of packets");
726   };
727 }
728 function ResolutionPositionComponentLayerIterator(context) {
729   const siz = context.SIZ;
730   const tileIndex = context.currentTile.index;
731   const tile = context.tiles[tileIndex];
732   const layersCount = tile.codingStyleDefaultParameters.layersCount;
733   const componentsCount = siz.Csiz;
734   let l, r, c, p;
735   let maxDecompositionLevelsCount = 0;
736   for (c = 0; c < componentsCount; c++) {
737     const component = tile.components[c];
738     maxDecompositionLevelsCount = Math.max(
739       maxDecompositionLevelsCount,
740       component.codingStyleParameters.decompositionLevelsCount
741     );
742   }
743   const maxNumPrecinctsInLevel = new Int32Array(
744     maxDecompositionLevelsCount + 1
745   );
746   for (r = 0; r <= maxDecompositionLevelsCount; ++r) {
747     let maxNumPrecincts = 0;
748     for (c = 0; c < componentsCount; ++c) {
749       const resolutions = tile.components[c].resolutions;
750       if (r < resolutions.length) {
751         maxNumPrecincts = Math.max(
752           maxNumPrecincts,
753           resolutions[r].precinctParameters.numprecincts
754         );
755       }
756     }
757     maxNumPrecinctsInLevel[r] = maxNumPrecincts;
758   }
759   l = 0;
760   r = 0;
761   c = 0;
762   p = 0;
763 
764   this.nextPacket = function JpxImage_nextPacket() {
765     // Section B.12.1.3 Resolution-position-component-layer
766     for (; r <= maxDecompositionLevelsCount; r++) {
767       for (; p < maxNumPrecinctsInLevel[r]; p++) {
768         for (; c < componentsCount; c++) {
769           const component = tile.components[c];
770           if (r > component.codingStyleParameters.decompositionLevelsCount) {
771             continue;
772           }
773           const resolution = component.resolutions[r];
774           const numprecincts = resolution.precinctParameters.numprecincts;
775           if (p >= numprecincts) {
776             continue;
777           }
778           for (; l < layersCount; ) {
779             const packet = createPacket(resolution, p, l);
780             l++;
781             return packet;
782           }
783           l = 0;
784         }
785         c = 0;
786       }
787       p = 0;
788     }
789     throw new JpxError("Out of packets");
790   };
791 }
792 function PositionComponentResolutionLayerIterator(context) {
793   const siz = context.SIZ;
794   const tileIndex = context.currentTile.index;
795   const tile = context.tiles[tileIndex];
796   const layersCount = tile.codingStyleDefaultParameters.layersCount;
797   const componentsCount = siz.Csiz;
798   const precinctsSizes = getPrecinctSizesInImageScale(tile);
799   const precinctsIterationSizes = precinctsSizes;
800   let l = 0,
801     r = 0,
802     c = 0,
803     px = 0,
804     py = 0;
805 
806   this.nextPacket = function JpxImage_nextPacket() {
807     // Section B.12.1.4 Position-component-resolution-layer
808     for (; py < precinctsIterationSizes.maxNumHigh; py++) {
809       for (; px < precinctsIterationSizes.maxNumWide; px++) {
810         for (; c < componentsCount; c++) {
811           const component = tile.components[c];
812           const decompositionLevelsCount =
813             component.codingStyleParameters.decompositionLevelsCount;
814           for (; r <= decompositionLevelsCount; r++) {
815             const resolution = component.resolutions[r];
816             const sizeInImageScale =
817               precinctsSizes.components[c].resolutions[r];
818             const k = getPrecinctIndexIfExist(
819               px,
820               py,
821               sizeInImageScale,
822               precinctsIterationSizes,
823               resolution
824             );
825             if (k === null) {
826               continue;
827             }
828             for (; l < layersCount; ) {
829               const packet = createPacket(resolution, k, l);
830               l++;
831               return packet;
832             }
833             l = 0;
834           }
835           r = 0;
836         }
837         c = 0;
838       }
839       px = 0;
840     }
841     throw new JpxError("Out of packets");
842   };
843 }
844 function ComponentPositionResolutionLayerIterator(context) {
845   const siz = context.SIZ;
846   const tileIndex = context.currentTile.index;
847   const tile = context.tiles[tileIndex];
848   const layersCount = tile.codingStyleDefaultParameters.layersCount;
849   const componentsCount = siz.Csiz;
850   const precinctsSizes = getPrecinctSizesInImageScale(tile);
851   let l = 0,
852     r = 0,
853     c = 0,
854     px = 0,
855     py = 0;
856 
857   this.nextPacket = function JpxImage_nextPacket() {
858     // Section B.12.1.5 Component-position-resolution-layer
859     for (; c < componentsCount; ++c) {
860       const component = tile.components[c];
861       const precinctsIterationSizes = precinctsSizes.components[c];
862       const decompositionLevelsCount =
863         component.codingStyleParameters.decompositionLevelsCount;
864       for (; py < precinctsIterationSizes.maxNumHigh; py++) {
865         for (; px < precinctsIterationSizes.maxNumWide; px++) {
866           for (; r <= decompositionLevelsCount; r++) {
867             const resolution = component.resolutions[r];
868             const sizeInImageScale = precinctsIterationSizes.resolutions[r];
869             const k = getPrecinctIndexIfExist(
870               px,
871               py,
872               sizeInImageScale,
873               precinctsIterationSizes,
874               resolution
875             );
876             if (k === null) {
877               continue;
878             }
879             for (; l < layersCount; ) {
880               const packet = createPacket(resolution, k, l);
881               l++;
882               return packet;
883             }
884             l = 0;
885           }
886           r = 0;
887         }
888         px = 0;
889       }
890       py = 0;
891     }
892     throw new JpxError("Out of packets");
893   };
894 }
895 function getPrecinctIndexIfExist(
896   pxIndex,
897   pyIndex,
898   sizeInImageScale,
899   precinctIterationSizes,
900   resolution
901 ) {
902   const posX = pxIndex * precinctIterationSizes.minWidth;
903   const posY = pyIndex * precinctIterationSizes.minHeight;
904   if (
905     posX % sizeInImageScale.width !== 0 ||
906     posY % sizeInImageScale.height !== 0
907   ) {
908     return null;
909   }
910   const startPrecinctRowIndex =
911     (posY / sizeInImageScale.width) *
912     resolution.precinctParameters.numprecinctswide;
913   return posX / sizeInImageScale.height + startPrecinctRowIndex;
914 }
915 function getPrecinctSizesInImageScale(tile) {
916   const componentsCount = tile.components.length;
917   let minWidth = Number.MAX_VALUE;
918   let minHeight = Number.MAX_VALUE;
919   let maxNumWide = 0;
920   let maxNumHigh = 0;
921   const sizePerComponent = new Array(componentsCount);
922   for (let c = 0; c < componentsCount; c++) {
923     const component = tile.components[c];
924     const decompositionLevelsCount =
925       component.codingStyleParameters.decompositionLevelsCount;
926     const sizePerResolution = new Array(decompositionLevelsCount + 1);
927     let minWidthCurrentComponent = Number.MAX_VALUE;
928     let minHeightCurrentComponent = Number.MAX_VALUE;
929     let maxNumWideCurrentComponent = 0;
930     let maxNumHighCurrentComponent = 0;
931     let scale = 1;
932     for (let r = decompositionLevelsCount; r >= 0; --r) {
933       const resolution = component.resolutions[r];
934       const widthCurrentResolution =
935         scale * resolution.precinctParameters.precinctWidth;
936       const heightCurrentResolution =
937         scale * resolution.precinctParameters.precinctHeight;
938       minWidthCurrentComponent = Math.min(
939         minWidthCurrentComponent,
940         widthCurrentResolution
941       );
942       minHeightCurrentComponent = Math.min(
943         minHeightCurrentComponent,
944         heightCurrentResolution
945       );
946       maxNumWideCurrentComponent = Math.max(
947         maxNumWideCurrentComponent,
948         resolution.precinctParameters.numprecinctswide
949       );
950       maxNumHighCurrentComponent = Math.max(
951         maxNumHighCurrentComponent,
952         resolution.precinctParameters.numprecinctshigh
953       );
954       sizePerResolution[r] = {
955         width: widthCurrentResolution,
956         height: heightCurrentResolution,
957       };
958       scale <<= 1;
959     }
960     minWidth = Math.min(minWidth, minWidthCurrentComponent);
961     minHeight = Math.min(minHeight, minHeightCurrentComponent);
962     maxNumWide = Math.max(maxNumWide, maxNumWideCurrentComponent);
963     maxNumHigh = Math.max(maxNumHigh, maxNumHighCurrentComponent);
964     sizePerComponent[c] = {
965       resolutions: sizePerResolution,
966       minWidth: minWidthCurrentComponent,
967       minHeight: minHeightCurrentComponent,
968       maxNumWide: maxNumWideCurrentComponent,
969       maxNumHigh: maxNumHighCurrentComponent,
970     };
971   }
972   return {
973     components: sizePerComponent,
974     minWidth,
975     minHeight,
976     maxNumWide,
977     maxNumHigh,
978   };
979 }
980 function buildPackets(context) {
981   const siz = context.SIZ;
982   const tileIndex = context.currentTile.index;
983   const tile = context.tiles[tileIndex];
984   const componentsCount = siz.Csiz;
985   // Creating resolutions and sub-bands for each component
986   for (let c = 0; c < componentsCount; c++) {
987     const component = tile.components[c];
988     const decompositionLevelsCount =
989       component.codingStyleParameters.decompositionLevelsCount;
990     // Section B.5 Resolution levels and sub-bands
991     const resolutions = [];
992     const subbands = [];
993     for (let r = 0; r <= decompositionLevelsCount; r++) {
994       const blocksDimensions = getBlocksDimensions(context, component, r);
995       const resolution = {};
996       const scale = 1 << (decompositionLevelsCount - r);
997       resolution.trx0 = Math.ceil(component.tcx0 / scale);
998       resolution.try0 = Math.ceil(component.tcy0 / scale);
999       resolution.trx1 = Math.ceil(component.tcx1 / scale);
1000       resolution.try1 = Math.ceil(component.tcy1 / scale);
1001       resolution.resLevel = r;
1002       buildPrecincts(context, resolution, blocksDimensions);
1003       resolutions.push(resolution);
1004 
1005       let subband;
1006       if (r === 0) {
1007         // one sub-band (LL) with last decomposition
1008         subband = {};
1009         subband.type = "LL";
1010         subband.tbx0 = Math.ceil(component.tcx0 / scale);
1011         subband.tby0 = Math.ceil(component.tcy0 / scale);
1012         subband.tbx1 = Math.ceil(component.tcx1 / scale);
1013         subband.tby1 = Math.ceil(component.tcy1 / scale);
1014         subband.resolution = resolution;
1015         buildCodeblocks(context, subband, blocksDimensions);
1016         subbands.push(subband);
1017         resolution.subbands = [subband];
1018       } else {
1019         const bscale = 1 << (decompositionLevelsCount - r + 1);
1020         const resolutionSubbands = [];
1021         // three sub-bands (HL, LH and HH) with rest of decompositions
1022         subband = {};
1023         subband.type = "HL";
1024         subband.tbx0 = Math.ceil(component.tcx0 / bscale - 0.5);
1025         subband.tby0 = Math.ceil(component.tcy0 / bscale);
1026         subband.tbx1 = Math.ceil(component.tcx1 / bscale - 0.5);
1027         subband.tby1 = Math.ceil(component.tcy1 / bscale);
1028         subband.resolution = resolution;
1029         buildCodeblocks(context, subband, blocksDimensions);
1030         subbands.push(subband);
1031         resolutionSubbands.push(subband);
1032 
1033         subband = {};
1034         subband.type = "LH";
1035         subband.tbx0 = Math.ceil(component.tcx0 / bscale);
1036         subband.tby0 = Math.ceil(component.tcy0 / bscale - 0.5);
1037         subband.tbx1 = Math.ceil(component.tcx1 / bscale);
1038         subband.tby1 = Math.ceil(component.tcy1 / bscale - 0.5);
1039         subband.resolution = resolution;
1040         buildCodeblocks(context, subband, blocksDimensions);
1041         subbands.push(subband);
1042         resolutionSubbands.push(subband);
1043 
1044         subband = {};
1045         subband.type = "HH";
1046         subband.tbx0 = Math.ceil(component.tcx0 / bscale - 0.5);
1047         subband.tby0 = Math.ceil(component.tcy0 / bscale - 0.5);
1048         subband.tbx1 = Math.ceil(component.tcx1 / bscale - 0.5);
1049         subband.tby1 = Math.ceil(component.tcy1 / bscale - 0.5);
1050         subband.resolution = resolution;
1051         buildCodeblocks(context, subband, blocksDimensions);
1052         subbands.push(subband);
1053         resolutionSubbands.push(subband);
1054 
1055         resolution.subbands = resolutionSubbands;
1056       }
1057     }
1058     component.resolutions = resolutions;
1059     component.subbands = subbands;
1060   }
1061   // Generate the packets sequence
1062   const progressionOrder = tile.codingStyleDefaultParameters.progressionOrder;
1063   switch (progressionOrder) {
1064     case 0:
1065       tile.packetsIterator = new LayerResolutionComponentPositionIterator(
1066         context
1067       );
1068       break;
1069     case 1:
1070       tile.packetsIterator = new ResolutionLayerComponentPositionIterator(
1071         context
1072       );
1073       break;
1074     case 2:
1075       tile.packetsIterator = new ResolutionPositionComponentLayerIterator(
1076         context
1077       );
1078       break;
1079     case 3:
1080       tile.packetsIterator = new PositionComponentResolutionLayerIterator(
1081         context
1082       );
1083       break;
1084     case 4:
1085       tile.packetsIterator = new ComponentPositionResolutionLayerIterator(
1086         context
1087       );
1088       break;
1089     default:
1090       throw new JpxError(`Unsupported progression order ${progressionOrder}`);
1091   }
1092 }
1093 function parseTilePackets(context, data, offset, dataLength) {
1094   let position = 0;
1095   let buffer,
1096     bufferSize = 0,
1097     skipNextBit = false;
1098   function readBits(count) {
1099     while (bufferSize < count) {
1100       const b = data[offset + position];
1101       position++;
1102       if (skipNextBit) {
1103         buffer = (buffer << 7) | b;
1104         bufferSize += 7;
1105         skipNextBit = false;
1106       } else {
1107         buffer = (buffer << 8) | b;
1108         bufferSize += 8;
1109       }
1110       if (b === 0xff) {
1111         skipNextBit = true;
1112       }
1113     }
1114     bufferSize -= count;
1115     return (buffer >>> bufferSize) & ((1 << count) - 1);
1116   }
1117   function skipMarkerIfEqual(value) {
1118     if (
1119       data[offset + position - 1] === 0xff &&
1120       data[offset + position] === value
1121     ) {
1122       skipBytes(1);
1123       return true;
1124     } else if (
1125       data[offset + position] === 0xff &&
1126       data[offset + position + 1] === value
1127     ) {
1128       skipBytes(2);
1129       return true;
1130     }
1131     return false;
1132   }
1133   function skipBytes(count) {
1134     position += count;
1135   }
1136   function alignToByte() {
1137     bufferSize = 0;
1138     if (skipNextBit) {
1139       position++;
1140       skipNextBit = false;
1141     }
1142   }
1143   function readCodingpasses() {
1144     if (readBits(1) === 0) {
1145       return 1;
1146     }
1147     if (readBits(1) === 0) {
1148       return 2;
1149     }
1150     let value = readBits(2);
1151     if (value < 3) {
1152       return value + 3;
1153     }
1154     value = readBits(5);
1155     if (value < 31) {
1156       return value + 6;
1157     }
1158     value = readBits(7);
1159     return value + 37;
1160   }
1161   const tileIndex = context.currentTile.index;
1162   const tile = context.tiles[tileIndex];
1163   const sopMarkerUsed = context.COD.sopMarkerUsed;
1164   const ephMarkerUsed = context.COD.ephMarkerUsed;
1165   const packetsIterator = tile.packetsIterator;
1166   while (position < dataLength) {
1167     alignToByte();
1168     if (sopMarkerUsed && skipMarkerIfEqual(0x91)) {
1169       // Skip also marker segment length and packet sequence ID
1170       skipBytes(4);
1171     }
1172     const packet = packetsIterator.nextPacket();
1173     if (!readBits(1)) {
1174       continue;
1175     }
1176     const layerNumber = packet.layerNumber,
1177       queue = [];
1178     let codeblock;
1179     for (let i = 0, ii = packet.codeblocks.length; i < ii; i++) {
1180       codeblock = packet.codeblocks[i];
1181       let precinct = codeblock.precinct;
1182       const codeblockColumn = codeblock.cbx - precinct.cbxMin;
1183       const codeblockRow = codeblock.cby - precinct.cbyMin;
1184       let codeblockIncluded = false;
1185       let firstTimeInclusion = false;
1186       let valueReady, zeroBitPlanesTree;
1187       if (codeblock.included !== undefined) {
1188         codeblockIncluded = !!readBits(1);
1189       } else {
1190         // reading inclusion tree
1191         precinct = codeblock.precinct;
1192         let inclusionTree;
1193         if (precinct.inclusionTree !== undefined) {
1194           inclusionTree = precinct.inclusionTree;
1195         } else {
1196           // building inclusion and zero bit-planes trees
1197           const width = precinct.cbxMax - precinct.cbxMin + 1;
1198           const height = precinct.cbyMax - precinct.cbyMin + 1;
1199           inclusionTree = new InclusionTree(width, height, layerNumber);
1200           zeroBitPlanesTree = new TagTree(width, height);
1201           precinct.inclusionTree = inclusionTree;
1202           precinct.zeroBitPlanesTree = zeroBitPlanesTree;
1203           for (let l = 0; l < layerNumber; l++) {
1204             if (readBits(1) !== 0) {
1205               throw new JpxError("Invalid tag tree");
1206             }
1207           }
1208         }
1209 
1210         if (inclusionTree.reset(codeblockColumn, codeblockRow, layerNumber)) {
1211           while (true) {
1212             if (readBits(1)) {
1213               valueReady = !inclusionTree.nextLevel();
1214               if (valueReady) {
1215                 codeblock.included = true;
1216                 codeblockIncluded = firstTimeInclusion = true;
1217                 break;
1218               }
1219             } else {
1220               inclusionTree.incrementValue(layerNumber);
1221               break;
1222             }
1223           }
1224         }
1225       }
1226       if (!codeblockIncluded) {
1227         continue;
1228       }
1229       if (firstTimeInclusion) {
1230         zeroBitPlanesTree = precinct.zeroBitPlanesTree;
1231         zeroBitPlanesTree.reset(codeblockColumn, codeblockRow);
1232         while (true) {
1233           if (readBits(1)) {
1234             valueReady = !zeroBitPlanesTree.nextLevel();
1235             if (valueReady) {
1236               break;
1237             }
1238           } else {
1239             zeroBitPlanesTree.incrementValue();
1240           }
1241         }
1242         codeblock.zeroBitPlanes = zeroBitPlanesTree.value;
1243       }
1244       const codingpasses = readCodingpasses();
1245       while (readBits(1)) {
1246         codeblock.Lblock++;
1247       }
1248       const codingpassesLog2 = log2(codingpasses);
1249       // rounding down log2
1250       const bits =
1251         (codingpasses < 1 << codingpassesLog2
1252           ? codingpassesLog2 - 1
1253           : codingpassesLog2) + codeblock.Lblock;
1254       const codedDataLength = readBits(bits);
1255       queue.push({
1256         codeblock,
1257         codingpasses,
1258         dataLength: codedDataLength,
1259       });
1260     }
1261     alignToByte();
1262     if (ephMarkerUsed) {
1263       skipMarkerIfEqual(0x92);
1264     }
1265     while (queue.length > 0) {
1266       const packetItem = queue.shift();
1267       codeblock = packetItem.codeblock;
1268       if (codeblock.data === undefined) {
1269         codeblock.data = [];
1270       }
1271       codeblock.data.push({
1272         data,
1273         start: offset + position,
1274         end: offset + position + packetItem.dataLength,
1275         codingpasses: packetItem.codingpasses,
1276       });
1277       position += packetItem.dataLength;
1278     }
1279   }
1280   return position;
1281 }
1282 function copyCoefficients(
1283   coefficients,
1284   levelWidth,
1285   levelHeight,
1286   subband,
1287   delta,
1288   mb,
1289   reversible,
1290   segmentationSymbolUsed,
1291   resetContextProbabilities
1292 ) {
1293   const x0 = subband.tbx0;
1294   const y0 = subband.tby0;
1295   const width = subband.tbx1 - subband.tbx0;
1296   const codeblocks = subband.codeblocks;
1297   const right = subband.type.charAt(0) === "H" ? 1 : 0;
1298   const bottom = subband.type.charAt(1) === "H" ? levelWidth : 0;
1299 
1300   for (let i = 0, ii = codeblocks.length; i < ii; ++i) {
1301     const codeblock = codeblocks[i];
1302     const blockWidth = codeblock.tbx1_ - codeblock.tbx0_;
1303     const blockHeight = codeblock.tby1_ - codeblock.tby0_;
1304     if (blockWidth === 0 || blockHeight === 0) {
1305       continue;
1306     }
1307     if (codeblock.data === undefined) {
1308       continue;
1309     }
1310 
1311     const bitModel = new BitModel(
1312       blockWidth,
1313       blockHeight,
1314       codeblock.subbandType,
1315       codeblock.zeroBitPlanes,
1316       mb
1317     );
1318     let currentCodingpassType = 2; // first bit plane starts from cleanup
1319 
1320     // collect data
1321     const data = codeblock.data;
1322     let totalLength = 0,
1323       codingpasses = 0;
1324     let j, jj, dataItem;
1325     for (j = 0, jj = data.length; j < jj; j++) {
1326       dataItem = data[j];
1327       totalLength += dataItem.end - dataItem.start;
1328       codingpasses += dataItem.codingpasses;
1329     }
1330     const encodedData = new Uint8Array(totalLength);
1331     let position = 0;
1332     for (j = 0, jj = data.length; j < jj; j++) {
1333       dataItem = data[j];
1334       const chunk = dataItem.data.subarray(dataItem.start, dataItem.end);
1335       encodedData.set(chunk, position);
1336       position += chunk.length;
1337     }
1338     // decoding the item
1339     const decoder = new ArithmeticDecoder(encodedData, 0, totalLength);
1340     bitModel.setDecoder(decoder);
1341 
1342     for (j = 0; j < codingpasses; j++) {
1343       switch (currentCodingpassType) {
1344         case 0:
1345           bitModel.runSignificancePropagationPass();
1346           break;
1347         case 1:
1348           bitModel.runMagnitudeRefinementPass();
1349           break;
1350         case 2:
1351           bitModel.runCleanupPass();
1352           if (segmentationSymbolUsed) {
1353             bitModel.checkSegmentationSymbol();
1354           }
1355           break;
1356       }
1357 
1358       if (resetContextProbabilities) {
1359         bitModel.reset();
1360       }
1361 
1362       currentCodingpassType = (currentCodingpassType + 1) % 3;
1363     }
1364 
1365     let offset = codeblock.tbx0_ - x0 + (codeblock.tby0_ - y0) * width;
1366     const sign = bitModel.coefficentsSign;
1367     const magnitude = bitModel.coefficentsMagnitude;
1368     const bitsDecoded = bitModel.bitsDecoded;
1369     const magnitudeCorrection = reversible ? 0 : 0.5;
1370     let k, n, nb;
1371     position = 0;
1372     // Do the interleaving of Section F.3.3 here, so we do not need
1373     // to copy later. LL level is not interleaved, just copied.
1374     const interleave = subband.type !== "LL";
1375     for (j = 0; j < blockHeight; j++) {
1376       const row = (offset / width) | 0; // row in the non-interleaved subband
1377       const levelOffset = 2 * row * (levelWidth - width) + right + bottom;
1378       for (k = 0; k < blockWidth; k++) {
1379         n = magnitude[position];
1380         if (n !== 0) {
1381           n = (n + magnitudeCorrection) * delta;
1382           if (sign[position] !== 0) {
1383             n = -n;
1384           }
1385           nb = bitsDecoded[position];
1386           const pos = interleave ? levelOffset + (offset << 1) : offset;
1387           coefficients[pos] = reversible && nb >= mb ? n : n * (1 << (mb - nb));
1388         }
1389         offset++;
1390         position++;
1391       }
1392       offset += width - blockWidth;
1393     }
1394   }
1395 }
1396 function transformTile(context, tile, c) {
1397   const component = tile.components[c];
1398   const codingStyleParameters = component.codingStyleParameters;
1399   const quantizationParameters = component.quantizationParameters;
1400   const decompositionLevelsCount =
1401     codingStyleParameters.decompositionLevelsCount;
1402   const spqcds = quantizationParameters.SPqcds;
1403   const scalarExpounded = quantizationParameters.scalarExpounded;
1404   const guardBits = quantizationParameters.guardBits;
1405   const segmentationSymbolUsed = codingStyleParameters.segmentationSymbolUsed;
1406   const resetContextProbabilities =
1407     codingStyleParameters.resetContextProbabilities;
1408   const precision = context.components[c].precision;
1409 
1410   const reversible = codingStyleParameters.reversibleTransformation;
1411   const transform = reversible
1412     ? new ReversibleTransform()
1413     : new IrreversibleTransform();
1414 
1415   const subbandCoefficients = [];
1416   let b = 0;
1417   for (let i = 0; i <= decompositionLevelsCount; i++) {
1418     const resolution = component.resolutions[i];
1419 
1420     const width = resolution.trx1 - resolution.trx0;
1421     const height = resolution.try1 - resolution.try0;
1422     // Allocate space for the whole sublevel.
1423     const coefficients = new Float32Array(width * height);
1424 
1425     for (let j = 0, jj = resolution.subbands.length; j < jj; j++) {
1426       let mu, epsilon;
1427       if (!scalarExpounded) {
1428         // formula E-5
1429         mu = spqcds[0].mu;
1430         epsilon = spqcds[0].epsilon + (i > 0 ? 1 - i : 0);
1431       } else {
1432         mu = spqcds[b].mu;
1433         epsilon = spqcds[b].epsilon;
1434         b++;
1435       }
1436 
1437       const subband = resolution.subbands[j];
1438       const gainLog2 = SubbandsGainLog2[subband.type];
1439 
1440       // calculate quantization coefficient (Section E.1.1.1)
1441       const delta = reversible
1442         ? 1
1443         : 2 ** (precision + gainLog2 - epsilon) * (1 + mu / 2048);
1444       const mb = guardBits + epsilon - 1;
1445 
1446       // In the first resolution level, copyCoefficients will fill the
1447       // whole array with coefficients. In the succeeding passes,
1448       // copyCoefficients will consecutively fill in the values that belong
1449       // to the interleaved positions of the HL, LH, and HH coefficients.
1450       // The LL coefficients will then be interleaved in Transform.iterate().
1451       copyCoefficients(
1452         coefficients,
1453         width,
1454         height,
1455         subband,
1456         delta,
1457         mb,
1458         reversible,
1459         segmentationSymbolUsed,
1460         resetContextProbabilities
1461       );
1462     }
1463     subbandCoefficients.push({
1464       width,
1465       height,
1466       items: coefficients,
1467     });
1468   }
1469 
1470   const result = transform.calculate(
1471     subbandCoefficients,
1472     component.tcx0,
1473     component.tcy0
1474   );
1475   return {
1476     left: component.tcx0,
1477     top: component.tcy0,
1478     width: result.width,
1479     height: result.height,
1480     items: result.items,
1481   };
1482 }
1483 function transformComponents(context) {
1484   const siz = context.SIZ;
1485   const components = context.components;
1486   const componentsCount = siz.Csiz;
1487   const resultImages = [];
1488   for (let i = 0, ii = context.tiles.length; i < ii; i++) {
1489     const tile = context.tiles[i];
1490     const transformedTiles = [];
1491     for (let c = 0; c < componentsCount; c++) {
1492       transformedTiles[c] = transformTile(context, tile, c);
1493     }
1494     const tile0 = transformedTiles[0];
1495     const out = new Uint8ClampedArray(tile0.items.length * componentsCount);
1496     const result = {
1497       left: tile0.left,
1498       top: tile0.top,
1499       width: tile0.width,
1500       height: tile0.height,
1501       items: out,
1502     };
1503 
1504     // Section G.2.2 Inverse multi component transform
1505     let shift, offset;
1506     let pos = 0,
1507       j,
1508       jj,
1509       y0,
1510       y1,
1511       y2;
1512     if (tile.codingStyleDefaultParameters.multipleComponentTransform) {
1513       const fourComponents = componentsCount === 4;
1514       const y0items = transformedTiles[0].items;
1515       const y1items = transformedTiles[1].items;
1516       const y2items = transformedTiles[2].items;
1517       const y3items = fourComponents ? transformedTiles[3].items : null;
1518 
1519       // HACK: The multiple component transform formulas below assume that
1520       // all components have the same precision. With this in mind, we
1521       // compute shift and offset only once.
1522       shift = components[0].precision - 8;
1523       offset = (128 << shift) + 0.5;
1524 
1525       const component0 = tile.components[0];
1526       const alpha01 = componentsCount - 3;
1527       jj = y0items.length;
1528       if (!component0.codingStyleParameters.reversibleTransformation) {
1529         // inverse irreversible multiple component transform
1530         for (j = 0; j < jj; j++, pos += alpha01) {
1531           y0 = y0items[j] + offset;
1532           y1 = y1items[j];
1533           y2 = y2items[j];
1534           out[pos++] = (y0 + 1.402 * y2) >> shift;
1535           out[pos++] = (y0 - 0.34413 * y1 - 0.71414 * y2) >> shift;
1536           out[pos++] = (y0 + 1.772 * y1) >> shift;
1537         }
1538       } else {
1539         // inverse reversible multiple component transform
1540         for (j = 0; j < jj; j++, pos += alpha01) {
1541           y0 = y0items[j] + offset;
1542           y1 = y1items[j];
1543           y2 = y2items[j];
1544           const g = y0 - ((y2 + y1) >> 2);
1545 
1546           out[pos++] = (g + y2) >> shift;
1547           out[pos++] = g >> shift;
1548           out[pos++] = (g + y1) >> shift;
1549         }
1550       }
1551       if (fourComponents) {
1552         for (j = 0, pos = 3; j < jj; j++, pos += 4) {
1553           out[pos] = (y3items[j] + offset) >> shift;
1554         }
1555       }
1556     } else {
1557       // no multi-component transform
1558       for (let c = 0; c < componentsCount; c++) {
1559         const items = transformedTiles[c].items;
1560         shift = components[c].precision - 8;
1561         offset = (128 << shift) + 0.5;
1562         for (pos = c, j = 0, jj = items.length; j < jj; j++) {
1563           out[pos] = (items[j] + offset) >> shift;
1564           pos += componentsCount;
1565         }
1566       }
1567     }
1568     resultImages.push(result);
1569   }
1570   return resultImages;
1571 }
1572 function initializeTile(context, tileIndex) {
1573   const siz = context.SIZ;
1574   const componentsCount = siz.Csiz;
1575   const tile = context.tiles[tileIndex];
1576   for (let c = 0; c < componentsCount; c++) {
1577     const component = tile.components[c];
1578     const qcdOrQcc =
1579       context.currentTile.QCC[c] !== undefined
1580         ? context.currentTile.QCC[c]
1581         : context.currentTile.QCD;
1582     component.quantizationParameters = qcdOrQcc;
1583     const codOrCoc =
1584       context.currentTile.COC[c] !== undefined
1585         ? context.currentTile.COC[c]
1586         : context.currentTile.COD;
1587     component.codingStyleParameters = codOrCoc;
1588   }
1589   tile.codingStyleDefaultParameters = context.currentTile.COD;
1590 }
1591 
1592 // Section B.10.2 Tag trees
1593 class TagTree {
1594   constructor(width, height) {
1595     const levelsLength = log2(Math.max(width, height)) + 1;
1596     this.levels = [];
1597     for (let i = 0; i < levelsLength; i++) {
1598       const level = {
1599         width,
1600         height,
1601         items: [],
1602       };
1603       this.levels.push(level);
1604       width = Math.ceil(width / 2);
1605       height = Math.ceil(height / 2);
1606     }
1607   }
1608 
1609   reset(i, j) {
1610     let currentLevel = 0,
1611       value = 0,
1612       level;
1613     while (currentLevel < this.levels.length) {
1614       level = this.levels[currentLevel];
1615       const index = i + j * level.width;
1616       if (level.items[index] !== undefined) {
1617         value = level.items[index];
1618         break;
1619       }
1620       level.index = index;
1621       i >>= 1;
1622       j >>= 1;
1623       currentLevel++;
1624     }
1625     currentLevel--;
1626     level = this.levels[currentLevel];
1627     level.items[level.index] = value;
1628     this.currentLevel = currentLevel;
1629     delete this.value;
1630   }
1631 
1632   incrementValue() {
1633     const level = this.levels[this.currentLevel];
1634     level.items[level.index]++;
1635   }
1636 
1637   nextLevel() {
1638     let currentLevel = this.currentLevel;
1639     let level = this.levels[currentLevel];
1640     const value = level.items[level.index];
1641     currentLevel--;
1642     if (currentLevel < 0) {
1643       this.value = value;
1644       return false;
1645     }
1646 
1647     this.currentLevel = currentLevel;
1648     level = this.levels[currentLevel];
1649     level.items[level.index] = value;
1650     return true;
1651   }
1652 }
1653 
1654 class InclusionTree {
1655   constructor(width, height, defaultValue) {
1656     const levelsLength = log2(Math.max(width, height)) + 1;
1657     this.levels = [];
1658     for (let i = 0; i < levelsLength; i++) {
1659       const items = new Uint8Array(width * height);
1660       for (let j = 0, jj = items.length; j < jj; j++) {
1661         items[j] = defaultValue;
1662       }
1663 
1664       const level = {
1665         width,
1666         height,
1667         items,
1668       };
1669       this.levels.push(level);
1670 
1671       width = Math.ceil(width / 2);
1672       height = Math.ceil(height / 2);
1673     }
1674   }
1675 
1676   reset(i, j, stopValue) {
1677     let currentLevel = 0;
1678     while (currentLevel < this.levels.length) {
1679       const level = this.levels[currentLevel];
1680       const index = i + j * level.width;
1681       level.index = index;
1682       const value = level.items[index];
1683 
1684       if (value === 0xff) {
1685         break;
1686       }
1687 
1688       if (value > stopValue) {
1689         this.currentLevel = currentLevel;
1690         // already know about this one, propagating the value to top levels
1691         this.propagateValues();
1692         return false;
1693       }
1694 
1695       i >>= 1;
1696       j >>= 1;
1697       currentLevel++;
1698     }
1699     this.currentLevel = currentLevel - 1;
1700     return true;
1701   }
1702 
1703   incrementValue(stopValue) {
1704     const level = this.levels[this.currentLevel];
1705     level.items[level.index] = stopValue + 1;
1706     this.propagateValues();
1707   }
1708 
1709   propagateValues() {
1710     let levelIndex = this.currentLevel;
1711     let level = this.levels[levelIndex];
1712     const currentValue = level.items[level.index];
1713     while (--levelIndex >= 0) {
1714       level = this.levels[levelIndex];
1715       level.items[level.index] = currentValue;
1716     }
1717   }
1718 
1719   nextLevel() {
1720     let currentLevel = this.currentLevel;
1721     let level = this.levels[currentLevel];
1722     const value = level.items[level.index];
1723     level.items[level.index] = 0xff;
1724     currentLevel--;
1725     if (currentLevel < 0) {
1726       return false;
1727     }
1728 
1729     this.currentLevel = currentLevel;
1730     level = this.levels[currentLevel];
1731     level.items[level.index] = value;
1732     return true;
1733   }
1734 }
1735 
1736 // Section D. Coefficient bit modeling
1737 class BitModel {
1738   static UNIFORM_CONTEXT = 17;
1739 
1740   static RUNLENGTH_CONTEXT = 18;
1741 
1742   // Table D-1
1743   // The index is binary presentation: 0dddvvhh, ddd - sum of Di (0..4),
1744   // vv - sum of Vi (0..2), and hh - sum of Hi (0..2)
1745   static LLAndLHContextsLabel = new Uint8Array([
1746     0, 5, 8, 0, 3, 7, 8, 0, 4, 7, 8, 0, 0, 0, 0, 0, 1, 6, 8, 0, 3, 7, 8, 0, 4,
1747     7, 8, 0, 0, 0, 0, 0, 2, 6, 8, 0, 3, 7, 8, 0, 4, 7, 8, 0, 0, 0, 0, 0, 2, 6,
1748     8, 0, 3, 7, 8, 0, 4, 7, 8, 0, 0, 0, 0, 0, 2, 6, 8, 0, 3, 7, 8, 0, 4, 7, 8,
1749   ]);
1750 
1751   static HLContextLabel = new Uint8Array([
1752     0, 3, 4, 0, 5, 7, 7, 0, 8, 8, 8, 0, 0, 0, 0, 0, 1, 3, 4, 0, 6, 7, 7, 0, 8,
1753     8, 8, 0, 0, 0, 0, 0, 2, 3, 4, 0, 6, 7, 7, 0, 8, 8, 8, 0, 0, 0, 0, 0, 2, 3,
1754     4, 0, 6, 7, 7, 0, 8, 8, 8, 0, 0, 0, 0, 0, 2, 3, 4, 0, 6, 7, 7, 0, 8, 8, 8,
1755   ]);
1756 
1757   static HHContextLabel = new Uint8Array([
1758     0, 1, 2, 0, 1, 2, 2, 0, 2, 2, 2, 0, 0, 0, 0, 0, 3, 4, 5, 0, 4, 5, 5, 0, 5,
1759     5, 5, 0, 0, 0, 0, 0, 6, 7, 7, 0, 7, 7, 7, 0, 7, 7, 7, 0, 0, 0, 0, 0, 8, 8,
1760     8, 0, 8, 8, 8, 0, 8, 8, 8, 0, 0, 0, 0, 0, 8, 8, 8, 0, 8, 8, 8, 0, 8, 8, 8,
1761   ]);
1762 
1763   constructor(width, height, subband, zeroBitPlanes, mb) {
1764     this.width = width;
1765     this.height = height;
1766 
1767     let contextLabelTable;
1768     if (subband === "HH") {
1769       contextLabelTable = BitModel.HHContextLabel;
1770     } else if (subband === "HL") {
1771       contextLabelTable = BitModel.HLContextLabel;
1772     } else {
1773       contextLabelTable = BitModel.LLAndLHContextsLabel;
1774     }
1775     this.contextLabelTable = contextLabelTable;
1776 
1777     const coefficientCount = width * height;
1778 
1779     // coefficients outside the encoding region treated as insignificant
1780     // add border state cells for significanceState
1781     this.neighborsSignificance = new Uint8Array(coefficientCount);
1782     this.coefficentsSign = new Uint8Array(coefficientCount);
1783     let coefficentsMagnitude;
1784     if (mb > 14) {
1785       coefficentsMagnitude = new Uint32Array(coefficientCount);
1786     } else if (mb > 6) {
1787       coefficentsMagnitude = new Uint16Array(coefficientCount);
1788     } else {
1789       coefficentsMagnitude = new Uint8Array(coefficientCount);
1790     }
1791     this.coefficentsMagnitude = coefficentsMagnitude;
1792     this.processingFlags = new Uint8Array(coefficientCount);
1793 
1794     const bitsDecoded = new Uint8Array(coefficientCount);
1795     if (zeroBitPlanes !== 0) {
1796       for (let i = 0; i < coefficientCount; i++) {
1797         bitsDecoded[i] = zeroBitPlanes;
1798       }
1799     }
1800     this.bitsDecoded = bitsDecoded;
1801 
1802     this.reset();
1803   }
1804 
1805   setDecoder(decoder) {
1806     this.decoder = decoder;
1807   }
1808 
1809   reset() {
1810     // We have 17 contexts that are accessed via context labels,
1811     // plus the uniform and runlength context.
1812     this.contexts = new Int8Array(19);
1813 
1814     // Contexts are packed into 1 byte:
1815     // highest 7 bits carry the index, lowest bit carries mps
1816     this.contexts[0] = (4 << 1) | 0;
1817     this.contexts[BitModel.UNIFORM_CONTEXT] = (46 << 1) | 0;
1818     this.contexts[BitModel.RUNLENGTH_CONTEXT] = (3 << 1) | 0;
1819   }
1820 
1821   setNeighborsSignificance(row, column, index) {
1822     const neighborsSignificance = this.neighborsSignificance;
1823     const width = this.width,
1824       height = this.height;
1825     const left = column > 0;
1826     const right = column + 1 < width;
1827     let i;
1828 
1829     if (row > 0) {
1830       i = index - width;
1831       if (left) {
1832         neighborsSignificance[i - 1] += 0x10;
1833       }
1834       if (right) {
1835         neighborsSignificance[i + 1] += 0x10;
1836       }
1837       neighborsSignificance[i] += 0x04;
1838     }
1839 
1840     if (row + 1 < height) {
1841       i = index + width;
1842       if (left) {
1843         neighborsSignificance[i - 1] += 0x10;
1844       }
1845       if (right) {
1846         neighborsSignificance[i + 1] += 0x10;
1847       }
1848       neighborsSignificance[i] += 0x04;
1849     }
1850 
1851     if (left) {
1852       neighborsSignificance[index - 1] += 0x01;
1853     }
1854     if (right) {
1855       neighborsSignificance[index + 1] += 0x01;
1856     }
1857     neighborsSignificance[index] |= 0x80;
1858   }
1859 
1860   runSignificancePropagationPass() {
1861     const decoder = this.decoder;
1862     const width = this.width,
1863       height = this.height;
1864     const coefficentsMagnitude = this.coefficentsMagnitude;
1865     const coefficentsSign = this.coefficentsSign;
1866     const neighborsSignificance = this.neighborsSignificance;
1867     const processingFlags = this.processingFlags;
1868     const contexts = this.contexts;
1869     const labels = this.contextLabelTable;
1870     const bitsDecoded = this.bitsDecoded;
1871     const processedInverseMask = ~1;
1872     const processedMask = 1;
1873     const firstMagnitudeBitMask = 2;
1874 
1875     for (let i0 = 0; i0 < height; i0 += 4) {
1876       for (let j = 0; j < width; j++) {
1877         let index = i0 * width + j;
1878         for (let i1 = 0; i1 < 4; i1++, index += width) {
1879           const i = i0 + i1;
1880           if (i >= height) {
1881             break;
1882           }
1883           // clear processed flag first
1884           processingFlags[index] &= processedInverseMask;
1885 
1886           if (coefficentsMagnitude[index] || !neighborsSignificance[index]) {
1887             continue;
1888           }
1889 
1890           const contextLabel = labels[neighborsSignificance[index]];
1891           const decision = decoder.readBit(contexts, contextLabel);
1892           if (decision) {
1893             const sign = this.decodeSignBit(i, j, index);
1894             coefficentsSign[index] = sign;
1895             coefficentsMagnitude[index] = 1;
1896             this.setNeighborsSignificance(i, j, index);
1897             processingFlags[index] |= firstMagnitudeBitMask;
1898           }
1899           bitsDecoded[index]++;
1900           processingFlags[index] |= processedMask;
1901         }
1902       }
1903     }
1904   }
1905 
1906   decodeSignBit(row, column, index) {
1907     const width = this.width,
1908       height = this.height;
1909     const coefficentsMagnitude = this.coefficentsMagnitude;
1910     const coefficentsSign = this.coefficentsSign;
1911     let contribution, sign0, sign1, significance1;
1912     let contextLabel, decoded;
1913 
1914     // calculate horizontal contribution
1915     significance1 = column > 0 && coefficentsMagnitude[index - 1] !== 0;
1916     if (column + 1 < width && coefficentsMagnitude[index + 1] !== 0) {
1917       sign1 = coefficentsSign[index + 1];
1918       if (significance1) {
1919         sign0 = coefficentsSign[index - 1];
1920         contribution = 1 - sign1 - sign0;
1921       } else {
1922         contribution = 1 - sign1 - sign1;
1923       }
1924     } else if (significance1) {
1925       sign0 = coefficentsSign[index - 1];
1926       contribution = 1 - sign0 - sign0;
1927     } else {
1928       contribution = 0;
1929     }
1930     const horizontalContribution = 3 * contribution;
1931 
1932     // calculate vertical contribution and combine with the horizontal
1933     significance1 = row > 0 && coefficentsMagnitude[index - width] !== 0;
1934     if (row + 1 < height && coefficentsMagnitude[index + width] !== 0) {
1935       sign1 = coefficentsSign[index + width];
1936       if (significance1) {
1937         sign0 = coefficentsSign[index - width];
1938         contribution = 1 - sign1 - sign0 + horizontalContribution;
1939       } else {
1940         contribution = 1 - sign1 - sign1 + horizontalContribution;
1941       }
1942     } else if (significance1) {
1943       sign0 = coefficentsSign[index - width];
1944       contribution = 1 - sign0 - sign0 + horizontalContribution;
1945     } else {
1946       contribution = horizontalContribution;
1947     }
1948 
1949     if (contribution >= 0) {
1950       contextLabel = 9 + contribution;
1951       decoded = this.decoder.readBit(this.contexts, contextLabel);
1952     } else {
1953       contextLabel = 9 - contribution;
1954       decoded = this.decoder.readBit(this.contexts, contextLabel) ^ 1;
1955     }
1956     return decoded;
1957   }
1958 
1959   runMagnitudeRefinementPass() {
1960     const decoder = this.decoder;
1961     const width = this.width,
1962       height = this.height;
1963     const coefficentsMagnitude = this.coefficentsMagnitude;
1964     const neighborsSignificance = this.neighborsSignificance;
1965     const contexts = this.contexts;
1966     const bitsDecoded = this.bitsDecoded;
1967     const processingFlags = this.processingFlags;
1968     const processedMask = 1;
1969     const firstMagnitudeBitMask = 2;
1970     const length = width * height;
1971     const width4 = width * 4;
1972 
1973     for (let index0 = 0, indexNext; index0 < length; index0 = indexNext) {
1974       indexNext = Math.min(length, index0 + width4);
1975       for (let j = 0; j < width; j++) {
1976         for (let index = index0 + j; index < indexNext; index += width) {
1977           // significant but not those that have just become
1978           if (
1979             !coefficentsMagnitude[index] ||
1980             (processingFlags[index] & processedMask) !== 0
1981           ) {
1982             continue;
1983           }
1984 
1985           let contextLabel = 16;
1986           if ((processingFlags[index] & firstMagnitudeBitMask) !== 0) {
1987             processingFlags[index] ^= firstMagnitudeBitMask;
1988             // first refinement
1989             const significance = neighborsSignificance[index] & 127;
1990             contextLabel = significance === 0 ? 15 : 14;
1991           }
1992 
1993           const bit = decoder.readBit(contexts, contextLabel);
1994           coefficentsMagnitude[index] =
1995             (coefficentsMagnitude[index] << 1) | bit;
1996           bitsDecoded[index]++;
1997           processingFlags[index] |= processedMask;
1998         }
1999       }
2000     }
2001   }
2002 
2003   runCleanupPass() {
2004     const decoder = this.decoder;
2005     const width = this.width,
2006       height = this.height;
2007     const neighborsSignificance = this.neighborsSignificance;
2008     const coefficentsMagnitude = this.coefficentsMagnitude;
2009     const coefficentsSign = this.coefficentsSign;
2010     const contexts = this.contexts;
2011     const labels = this.contextLabelTable;
2012     const bitsDecoded = this.bitsDecoded;
2013     const processingFlags = this.processingFlags;
2014     const processedMask = 1;
2015     const firstMagnitudeBitMask = 2;
2016     const oneRowDown = width;
2017     const twoRowsDown = width * 2;
2018     const threeRowsDown = width * 3;
2019     let iNext;
2020     for (let i0 = 0; i0 < height; i0 = iNext) {
2021       iNext = Math.min(i0 + 4, height);
2022       const indexBase = i0 * width;
2023       const checkAllEmpty = i0 + 3 < height;
2024       for (let j = 0; j < width; j++) {
2025         const index0 = indexBase + j;
2026         // using the property: labels[neighborsSignificance[index]] === 0
2027         // when neighborsSignificance[index] === 0
2028         const allEmpty =
2029           checkAllEmpty &&
2030           processingFlags[index0] === 0 &&
2031           processingFlags[index0 + oneRowDown] === 0 &&
2032           processingFlags[index0 + twoRowsDown] === 0 &&
2033           processingFlags[index0 + threeRowsDown] === 0 &&
2034           neighborsSignificance[index0] === 0 &&
2035           neighborsSignificance[index0 + oneRowDown] === 0 &&
2036           neighborsSignificance[index0 + twoRowsDown] === 0 &&
2037           neighborsSignificance[index0 + threeRowsDown] === 0;
2038         let i1 = 0,
2039           index = index0;
2040         let i = i0,
2041           sign;
2042         if (allEmpty) {
2043           const hasSignificantCoefficent = decoder.readBit(
2044             contexts,
2045             BitModel.RUNLENGTH_CONTEXT
2046           );
2047           if (!hasSignificantCoefficent) {
2048             bitsDecoded[index0]++;
2049             bitsDecoded[index0 + oneRowDown]++;
2050             bitsDecoded[index0 + twoRowsDown]++;
2051             bitsDecoded[index0 + threeRowsDown]++;
2052             continue; // next column
2053           }
2054           i1 =
2055             (decoder.readBit(contexts, BitModel.UNIFORM_CONTEXT) << 1) |
2056             decoder.readBit(contexts, BitModel.UNIFORM_CONTEXT);
2057           if (i1 !== 0) {
2058             i = i0 + i1;
2059             index += i1 * width;
2060           }
2061 
2062           sign = this.decodeSignBit(i, j, index);
2063           coefficentsSign[index] = sign;
2064           coefficentsMagnitude[index] = 1;
2065           this.setNeighborsSignificance(i, j, index);
2066           processingFlags[index] |= firstMagnitudeBitMask;
2067 
2068           index = index0;
2069           for (let i2 = i0; i2 <= i; i2++, index += width) {
2070             bitsDecoded[index]++;
2071           }
2072 
2073           i1++;
2074         }
2075         for (i = i0 + i1; i < iNext; i++, index += width) {
2076           if (
2077             coefficentsMagnitude[index] ||
2078             (processingFlags[index] & processedMask) !== 0
2079           ) {
2080             continue;
2081           }
2082 
2083           const contextLabel = labels[neighborsSignificance[index]];
2084           const decision = decoder.readBit(contexts, contextLabel);
2085           if (decision === 1) {
2086             sign = this.decodeSignBit(i, j, index);
2087             coefficentsSign[index] = sign;
2088             coefficentsMagnitude[index] = 1;
2089             this.setNeighborsSignificance(i, j, index);
2090             processingFlags[index] |= firstMagnitudeBitMask;
2091           }
2092           bitsDecoded[index]++;
2093         }
2094       }
2095     }
2096   }
2097 
2098   checkSegmentationSymbol() {
2099     const decoder = this.decoder;
2100     const contexts = this.contexts;
2101     const symbol =
2102       (decoder.readBit(contexts, BitModel.UNIFORM_CONTEXT) << 3) |
2103       (decoder.readBit(contexts, BitModel.UNIFORM_CONTEXT) << 2) |
2104       (decoder.readBit(contexts, BitModel.UNIFORM_CONTEXT) << 1) |
2105       decoder.readBit(contexts, BitModel.UNIFORM_CONTEXT);
2106     if (symbol !== 0xa) {
2107       throw new JpxError("Invalid segmentation symbol");
2108     }
2109   }
2110 }
2111 
2112 // Section F, Discrete wavelet transformation
2113 class Transform {
2114   constructor() {
2115     if (this.constructor === Transform) {
2116       unreachable("Cannot initialize Transform.");
2117     }
2118   }
2119 
2120   calculate(subbands, u0, v0) {
2121     let ll = subbands[0];
2122     for (let i = 1, ii = subbands.length; i < ii; i++) {
2123       ll = this.iterate(ll, subbands[i], u0, v0);
2124     }
2125     return ll;
2126   }
2127 
2128   extend(buffer, offset, size) {
2129     // Section F.3.7 extending... using max extension of 4
2130     let i1 = offset - 1,
2131       j1 = offset + 1;
2132     let i2 = offset + size - 2,
2133       j2 = offset + size;
2134     buffer[i1--] = buffer[j1++];
2135     buffer[j2++] = buffer[i2--];
2136     buffer[i1--] = buffer[j1++];
2137     buffer[j2++] = buffer[i2--];
2138     buffer[i1--] = buffer[j1++];
2139     buffer[j2++] = buffer[i2--];
2140     buffer[i1] = buffer[j1];
2141     buffer[j2] = buffer[i2];
2142   }
2143 
2144   filter(x, offset, length) {
2145     unreachable("Abstract method `filter` called");
2146   }
2147 
2148   iterate(ll, hl_lh_hh, u0, v0) {
2149     const llWidth = ll.width,
2150       llHeight = ll.height;
2151     let llItems = ll.items;
2152     const width = hl_lh_hh.width;
2153     const height = hl_lh_hh.height;
2154     const items = hl_lh_hh.items;
2155     let i, j, k, l, u, v;
2156 
2157     // Interleave LL according to Section F.3.3
2158     for (k = 0, i = 0; i < llHeight; i++) {
2159       l = i * 2 * width;
2160       for (j = 0; j < llWidth; j++, k++, l += 2) {
2161         items[l] = llItems[k];
2162       }
2163     }
2164     // The LL band is not needed anymore.
2165     llItems = ll.items = null;
2166 
2167     const bufferPadding = 4;
2168     const rowBuffer = new Float32Array(width + 2 * bufferPadding);
2169 
2170     // Section F.3.4 HOR_SR
2171     if (width === 1) {
2172       // if width = 1, when u0 even keep items as is, when odd divide by 2
2173       if ((u0 & 1) !== 0) {
2174         for (v = 0, k = 0; v < height; v++, k += width) {
2175           items[k] *= 0.5;
2176         }
2177       }
2178     } else {
2179       for (v = 0, k = 0; v < height; v++, k += width) {
2180         rowBuffer.set(items.subarray(k, k + width), bufferPadding);
2181 
2182         this.extend(rowBuffer, bufferPadding, width);
2183         this.filter(rowBuffer, bufferPadding, width);
2184 
2185         items.set(rowBuffer.subarray(bufferPadding, bufferPadding + width), k);
2186       }
2187     }
2188 
2189     // Accesses to the items array can take long, because it may not fit into
2190     // CPU cache and has to be fetched from main memory. Since subsequent
2191     // accesses to the items array are not local when reading columns, we
2192     // have a cache miss every time. To reduce cache misses, get up to
2193     // 'numBuffers' items at a time and store them into the individual
2194     // buffers. The colBuffers should be small enough to fit into CPU cache.
2195     let numBuffers = 16;
2196     const colBuffers = [];
2197     for (i = 0; i < numBuffers; i++) {
2198       colBuffers.push(new Float32Array(height + 2 * bufferPadding));
2199     }
2200     let b,
2201       currentBuffer = 0;
2202     ll = bufferPadding + height;
2203 
2204     // Section F.3.5 VER_SR
2205     if (height === 1) {
2206       // if height = 1, when v0 even keep items as is, when odd divide by 2
2207       if ((v0 & 1) !== 0) {
2208         for (u = 0; u < width; u++) {
2209           items[u] *= 0.5;
2210         }
2211       }
2212     } else {
2213       for (u = 0; u < width; u++) {
2214         // if we ran out of buffers, copy several image columns at once
2215         if (currentBuffer === 0) {
2216           numBuffers = Math.min(width - u, numBuffers);
2217           for (k = u, l = bufferPadding; l < ll; k += width, l++) {
2218             for (b = 0; b < numBuffers; b++) {
2219               colBuffers[b][l] = items[k + b];
2220             }
2221           }
2222           currentBuffer = numBuffers;
2223         }
2224 
2225         currentBuffer--;
2226         const buffer = colBuffers[currentBuffer];
2227         this.extend(buffer, bufferPadding, height);
2228         this.filter(buffer, bufferPadding, height);
2229 
2230         // If this is last buffer in this group of buffers, flush all buffers.
2231         if (currentBuffer === 0) {
2232           k = u - numBuffers + 1;
2233           for (l = bufferPadding; l < ll; k += width, l++) {
2234             for (b = 0; b < numBuffers; b++) {
2235               items[k + b] = colBuffers[b][l];
2236             }
2237           }
2238         }
2239       }
2240     }
2241 
2242     return { width, height, items };
2243   }
2244 }
2245 
2246 // Section 3.8.2 Irreversible 9-7 filter
2247 class IrreversibleTransform extends Transform {
2248   filter(x, offset, length) {
2249     const len = length >> 1;
2250     offset |= 0;
2251     let j, n, current, next;
2252 
2253     const alpha = -1.586134342059924;
2254     const beta = -0.052980118572961;
2255     const gamma = 0.882911075530934;
2256     const delta = 0.443506852043971;
2257     const K = 1.230174104914001;
2258     const K_ = 1 / K;
2259 
2260     // step 1 is combined with step 3
2261 
2262     // step 2
2263     j = offset - 3;
2264     for (n = len + 4; n--; j += 2) {
2265       x[j] *= K_;
2266     }
2267 
2268     // step 1 & 3
2269     j = offset - 2;
2270     current = delta * x[j - 1];
2271     for (n = len + 3; n--; j += 2) {
2272       next = delta * x[j + 1];
2273       x[j] = K * x[j] - current - next;
2274       if (n--) {
2275         j += 2;
2276         current = delta * x[j + 1];
2277         x[j] = K * x[j] - current - next;
2278       } else {
2279         break;
2280       }
2281     }
2282 
2283     // step 4
2284     j = offset - 1;
2285     current = gamma * x[j - 1];
2286     for (n = len + 2; n--; j += 2) {
2287       next = gamma * x[j + 1];
2288       x[j] -= current + next;
2289       if (n--) {
2290         j += 2;
2291         current = gamma * x[j + 1];
2292         x[j] -= current + next;
2293       } else {
2294         break;
2295       }
2296     }
2297 
2298     // step 5
2299     j = offset;
2300     current = beta * x[j - 1];
2301     for (n = len + 1; n--; j += 2) {
2302       next = beta * x[j + 1];
2303       x[j] -= current + next;
2304       if (n--) {
2305         j += 2;
2306         current = beta * x[j + 1];
2307         x[j] -= current + next;
2308       } else {
2309         break;
2310       }
2311     }
2312 
2313     // step 6
2314     if (len !== 0) {
2315       j = offset + 1;
2316       current = alpha * x[j - 1];
2317       for (n = len; n--; j += 2) {
2318         next = alpha * x[j + 1];
2319         x[j] -= current + next;
2320         if (n--) {
2321           j += 2;
2322           current = alpha * x[j + 1];
2323           x[j] -= current + next;
2324         } else {
2325           break;
2326         }
2327       }
2328     }
2329   }
2330 }
2331 
2332 // Section 3.8.1 Reversible 5-3 filter
2333 class ReversibleTransform extends Transform {
2334   filter(x, offset, length) {
2335     const len = length >> 1;
2336     offset |= 0;
2337     let j, n;
2338 
2339     for (j = offset, n = len + 1; n--; j += 2) {
2340       x[j] -= (x[j - 1] + x[j + 1] + 2) >> 2;
2341     }
2342 
2343     for (j = offset + 1, n = len; n--; j += 2) {
2344       x[j] += (x[j - 1] + x[j + 1]) >> 1;
2345     }
2346   }
2347 }
2348 
2349 export { JpxImage };
File:
src/core/jpx_stream.js
1 /* Copyright 2012 Mozilla Foundation
2  *
3  * Licensed under the Apache License, Version 2.0 (the "License");
4  * you may not use this file except in compliance with the License.
5  * You may obtain a copy of the License at
6  *
7  *     http://www.apache.org/licenses/LICENSE-2.0
8  *
9  * Unless required by applicable law or agreed to in writing, software
10  * distributed under the License is distributed on an "AS IS" BASIS,
11  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
12  * See the License for the specific language governing permissions and
13  * limitations under the License.
14  */
15 
16 import { DecodeStream } from "./decode_stream.js";
17 import { JpxImage } from "./jpx.js";
18 import { shadow } from "../shared/util.js";
19 
20 /**
21  * For JPEG 2000's we use a library to decode these images and
22  * the stream behaves like all the other DecodeStreams.
23  */
24 class JpxStream extends DecodeStream {
25   constructor(stream, maybeLength, params) {
26     super(maybeLength);
27 
28     this.stream = stream;
29     this.dict = stream.dict;
30     this.maybeLength = maybeLength;
31     this.params = params;
32   }
33 
34   get bytes() {
35     // If `this.maybeLength` is null, we'll get the entire stream.
36     return shadow(this, "bytes", this.stream.getBytes(this.maybeLength));
37   }
38 
39   ensureBuffer(requested) {
40     // No-op, since `this.readBlock` will always parse the entire image and
41     // directly insert all of its data into `this.buffer`.
42   }
43 
44   readBlock() {
45     if (this.eof) {
46       return;
47     }
48     const jpxImage = new JpxImage();
49     jpxImage.parse(this.bytes);
50 
51     const width = jpxImage.width;
52     const height = jpxImage.height;
53     const componentsCount = jpxImage.componentsCount;
54     const tileCount = jpxImage.tiles.length;
55     if (tileCount === 1) {
56       this.buffer = jpxImage.tiles[0].items;
57     } else {
58       const data = new Uint8ClampedArray(width * height * componentsCount);
59 
60       for (let k = 0; k < tileCount; k++) {
61         const tileComponents = jpxImage.tiles[k];
62         const tileWidth = tileComponents.width;
63         const tileHeight = tileComponents.height;
64         const tileLeft = tileComponents.left;
65         const tileTop = tileComponents.top;
66 
67         const src = tileComponents.items;
68         let srcPosition = 0;
69         let dataPosition = (width * tileTop + tileLeft) * componentsCount;
70         const imgRowSize = width * componentsCount;
71         const tileRowSize = tileWidth * componentsCount;
72 
73         for (let j = 0; j < tileHeight; j++) {
74           const rowBytes = src.subarray(srcPosition, srcPosition + tileRowSize);
75           data.set(rowBytes, dataPosition);
76           srcPosition += tileRowSize;
77           dataPosition += imgRowSize;
78         }
79       }
80       this.buffer = data;
81     }
82     this.bufferLength = this.buffer.length;
83     this.eof = true;
84   }
85 }
86 
87 export { JpxStream };
</code>

Your task:
You are a software tester at pdf.js.
1. Write exactly one javascript test `it("...", async () => {...})` block.
2. Your test must fail on the code before the patch, and pass after, hence the test will verify that the patch resolves the issue.
3. The test must be self-contained and to-the-point.
4. Use only the provided imports (respect the paths exactly how they are given) by importing dynamically for compatibility with Node.js — no new dependencies. You can use the PDF file for testing as follows:
const { getDocument } = await import('../../src/display/api.js');
const { buildGetDocumentParams } = await import('./test_utils.js');
const loadingTask = getDocument(buildGetDocumentParams('issue17289.pdf'))
5. Return only the javascript code (no comments or explanations).

Example structure:
it("should <describe behavior>", async () => {
  const { example } = await import("../../src/core/example.js");
  <initialize required variables>;
  <define expected variable>;
  <generate actual variables>;
  <compare expected with actual>;
});

