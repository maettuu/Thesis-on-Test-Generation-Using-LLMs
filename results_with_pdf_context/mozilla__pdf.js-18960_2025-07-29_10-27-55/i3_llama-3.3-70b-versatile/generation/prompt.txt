Before you begin:
- Keep going until the job is completely solved — don’t stop halfway.
- If you’re unsure about the behavior, reread the provided patch carefully; do not hallucinate.
- Plan your approach before writing code by reflecting on whether the test truly fails before and passes after.

Issue:
<issue>
[Bug]: Rendering Bug
### Attach (recommended) or Link to PDF file

[PDF_-_correct.pdf](https://github.com/user-attachments/files/17522721/PDF_-_correct.pdf)


### Web browser and its version

Firefox 131.03

### Operating system and its version

WIndows 11

### PDF.js version

4.7.76 actually used https://mozilla.github.io/pdf.js/web/viewer.html today

### Is the bug present in the latest PDF.js version?

Yes

### Is a browser extension

No

### Steps to reproduce the problem

Open the PDF, on all the panels the white text should display directly on the background texture but there is some colored area between the text and the background texture. 

The most obvious areas are highlighted 

FYI the same PDF renders correctly using the native Chrome PDF viewer.

### What is the expected behavior?

Should render correctly

### What went wrong?

Not rendered correctly

### Link to a viewer

_No response_

### Additional context

_No response_
</issue>

PDF File:
<pdf>
issue18956.pdf
</pdf>

Patch:
<patch>
diff --git a/src/display/canvas.js b/src/display/canvas.js
--- a/src/display/canvas.js
+++ b/src/display/canvas.js
@@ -1498,6 +1498,7 @@ class CanvasGraphics {
     let maskY = layerOffsetY - maskOffsetY;
 
     if (backdrop) {
+      const backdropRGB = Util.makeHexColor(...backdrop);
       if (
         maskX < 0 ||
         maskY < 0 ||
@@ -1511,16 +1512,14 @@ class CanvasGraphics {
         );
         const ctx = canvas.context;
         ctx.drawImage(maskCanvas, -maskX, -maskY);
-        if (backdrop.some(c => c !== 0)) {
-          ctx.globalCompositeOperation = "destination-atop";
-          ctx.fillStyle = Util.makeHexColor(...backdrop);
-          ctx.fillRect(0, 0, width, height);
-          ctx.globalCompositeOperation = "source-over";
-        }
+        ctx.globalCompositeOperation = "destination-atop";
+        ctx.fillStyle = backdropRGB;
+        ctx.fillRect(0, 0, width, height);
+        ctx.globalCompositeOperation = "source-over";
 
         maskCanvas = canvas.canvas;
         maskX = maskY = 0;
-      } else if (backdrop.some(c => c !== 0)) {
+      } else {
         maskCtx.save();
         maskCtx.globalAlpha = 1;
         maskCtx.setTransform(1, 0, 0, 1, 0, 0);
@@ -1528,7 +1527,7 @@ class CanvasGraphics {
         clip.rect(maskX, maskY, width, height);
         maskCtx.clip(clip);
         maskCtx.globalCompositeOperation = "destination-atop";
-        maskCtx.fillStyle = Util.makeHexColor(...backdrop);
+        maskCtx.fillStyle = backdropRGB;
         maskCtx.fillRect(maskX, maskY, width, height);
         maskCtx.restore();
       }


</patch>

Imports:
<imports>
Available Packages
Dev Dependencies:
- @babel/core: ^7.25.8
- @babel/preset-env: ^7.25.8
- @babel/runtime: ^7.25.7
- @fluent/bundle: ^0.18.0
- @fluent/dom: ^0.10.0
- @jazzer.js/core: ^2.1.0
- @metalsmith/layouts: ^2.7.0
- @metalsmith/markdown: ^1.10.0
- autoprefixer: ^10.4.20
- babel-loader: ^9.2.1
- caniuse-lite: ^1.0.30001669
- canvas: ^3.0.0-rc2
- core-js: ^3.38.1
- eslint: ^8.57.1
- eslint-plugin-import: ^2.31.0
- eslint-plugin-jasmine: ^4.2.2
- eslint-plugin-json: ^3.1.0
- eslint-plugin-no-unsanitized: ^4.1.2
- eslint-plugin-perfectionist: ^3.9.1
- eslint-plugin-prettier: ^5.2.1
- eslint-plugin-unicorn: ^56.0.0
- gulp: ^5.0.0
- gulp-cli: ^3.0.0
- gulp-postcss: ^10.0.0
- gulp-rename: ^2.0.0
- gulp-replace: ^1.1.4
- gulp-zip: ^6.0.0
- highlight.js: ^11.10.0
- jasmine: ^5.4.0
- jsdoc: ^4.0.4
- jstransformer-nunjucks: ^1.2.0
- metalsmith: ^2.6.3
- metalsmith-html-relative: ^2.0.5
- ordered-read-streams: ^2.0.0
- path2d: ^0.2.1
- pngjs: ^7.0.0
- postcss: ^8.4.47
- postcss-dark-theme-class: ^1.3.0
- postcss-dir-pseudo-class: ^9.0.0
- postcss-discard-comments: ^7.0.3
- postcss-nesting: ^13.0.0
- prettier: ^3.3.3
- puppeteer: 23.3.1
- stylelint: ^16.10.0
- stylelint-prettier: ^5.0.2
- svglint: ^3.0.0
- terser-webpack-plugin: ^5.3.10
- tsc-alias: ^1.8.10
- ttest: ^4.0.0
- typescript: ^5.6.3
- vinyl: ^3.0.0
- webpack: ^5.95.0
- webpack-stream: ^7.0.0
- yargs: ^17.7.2

Engines:
- node: >=18

Available Relative Imports:
- `../../src/core/annotation.js`: Annotation, AnnotationBorderStyle, AnnotationFactory, MarkupAnnotation, getQuadPoints
- `../../src/core/bidi.js`: bidi
- `../../src/core/cff_parser.js`: CFFCharset, CFFCompiler, CFFFDSelect, CFFParser, CFFStrings
- `../../src/core/cmap.js`: CMap, CMapFactory, IdentityCMap
- `../../src/core/colorspace.js`: ColorSpace
- `../../src/core/core_utils.js`: arrayBuffersToBytes, encodeToXmlString, escapePDFName, escapeString, getInheritableProperty, getSizeInBytes, isAscii, isWhiteSpace, log2, numberToString, parseXFAPath, recoverJsURL, stringToUTF16HexString, stringToUTF16String, toRomanNumerals, validateCSSFont
- `../../src/core/crypto.js`: AES128Cipher, AES256Cipher, ARCFourCipher, CipherTransformFactory, PDF17, PDF20, calculateMD5, calculateSHA256, calculateSHA384, calculateSHA512
- `../../src/core/default_appearance.js`: createDefaultAppearance, parseAppearanceStream, parseDefaultAppearance
- `../../src/core/document.js`: PDFDocument, Page
- `../../src/core/encodings.js`: getEncoding
- `../../src/core/evaluator.js`: PartialEvaluator
- `../../src/core/flate_stream.js`: FlateStream
- `../../src/core/font_substitutions.js`: getFontSubstitution
- `../../src/core/fonts_utils.js`: SEAC_ANALYSIS_ENABLED
- `../../src/core/function.js`: PDFFunctionFactory, PostScriptCompiler, PostScriptEvaluator
- `../../src/core/glyphlist.js`: getDingbatsGlyphsUnicode, getGlyphsUnicode
- `../../src/core/image_utils.js`: GlobalImageCache, LocalColorSpaceCache
- `../../src/core/jbig2.js`: Jbig2Error, Jbig2Image
- `../../src/core/jpg.js`: JpegError, JpegImage
- `../../src/core/jpx.js`: JpxError, JpxImage
- `../../src/core/metadata_parser.js`: MetadataParser
- `../../src/core/operator_list.js`: OperatorList
- `../../src/core/parser.js`: Lexer, Linearization, Parser
- `../../src/core/predictor_stream.js`: PredictorStream
- `../../src/core/primitives.js`: Cmd, Dict, EOF, Name, Ref, RefSet, RefSetCache, isCmd, isDict, isName, isRefsEqual
- `../../src/core/ps_parser.js`: PostScriptLexer, PostScriptParser
- `../../src/core/stream.js`: NullStream, Stream, StringStream
- `../../src/core/type1_parser.js`: Type1Parser
- `../../src/core/unicode.js`: getCharUnicodeCategory, getUnicodeForGlyph, getUnicodeRangeFor, mapSpecialUnicodeValues
- `../../src/core/worker.js`: WorkerMessageHandler, WorkerTask
- `../../src/core/writer.js`: incrementalUpdate, writeDict
- `../../src/core/xfa/bind.js`: Binder
- `../../src/core/xfa/data.js`: DataHandler
- `../../src/core/xfa/factory.js`: XFAFactory
- `../../src/core/xfa/formcalc_lexer.js`: Lexer, TOKEN, Token
- `../../src/core/xfa/formcalc_parser.js`: Errors, Parser
- `../../src/core/xfa/parser.js`: XFAParser
- `../../src/core/xfa/som.js`: searchNode
- `../../src/core/xfa/symbol_utils.js`: $dump, $getChildren, $getChildrenByClass, $getChildrenByName, $text, $uid
- `../../src/core/xml_parser.js`: SimpleXMLParser, XMLParserBase
- `../../src/display/annotation_layer.js`: AnnotationLayer
- `../../src/display/annotation_storage.js`: AnnotationStorage
- `../../src/display/api.js`: DefaultCMapReaderFactory, DefaultCanvasFactory, DefaultStandardFontDataFactory, LoopbackPort, PDFDataRangeTransport, PDFDocumentLoadingTask, PDFDocumentProxy, PDFPageProxy, PDFWorker, RenderTask, build, getDocument, version
- `../../src/display/display_utils.js`: DOMCanvasFactory, DOMSVGFactory, OutputScale, PDFDateString, PageViewport, PixelsPerInch, RenderingCancelledException, StatTimer, fetchData, getFilenameFromUrl, getPdfFilenameFromUrl, getXfaPageViewport, isDataScheme, isPdfFile, isValidFetchUrl, noContextMenu, setLayerDimensions
- `../../src/display/draw_layer.js`: DrawLayer
- `../../src/display/editor/annotation_editor_layer.js`: AnnotationEditorLayer
- `../../src/display/editor/color_picker.js`: ColorPicker
- `../../src/display/editor/tools.js`: AnnotationEditorUIManager, CommandManager
- `../../src/display/fetch_stream.js`: PDFFetchStream
- `../../src/display/metadata.js`: Metadata
- `../../src/display/network.js`: PDFNetworkStream
- `../../src/display/network_utils.js`: createHeaders, createResponseStatusError, extractFilenameFromHeader, validateRangeRequestCapabilities, validateResponseStatus
- `../../src/display/node_stream.js`: PDFNodeStream
- `../../src/display/node_utils.js`: NodePackages, fetchData
- `../../src/display/text_layer.js`: TextLayer
- `../../src/display/worker_options.js`: GlobalWorkerOptions
- `../../src/display/xfa_layer.js`: XfaLayer
- `../../src/shared/message_handler.js`: MessageHandler
- `../../src/shared/murmurhash3.js`: MurmurHash3_64
- `../../src/shared/util.js`: AbortException, AnnotationBorderStyleType, AnnotationEditorParamsType, AnnotationEditorType, AnnotationFieldFlag, AnnotationFlag, AnnotationMode, AnnotationType, BaseException, CMapCompressionType, FeatureTest, FormatError, ImageKind, InvalidPDFException, MissingPDFException, OPS, PasswordException, PasswordResponses, PermissionFlag, RenderingIntentFlag, UnexpectedResponseException, UnknownErrorException, Util, VerbosityLevel, assert, bytesToString, createValidAbsoluteUrl, getModificationDate, getVerbosityLevel, isNodeJS, normalizeUnicode, objectSize, setVerbosityLevel, shadow, string32, stringToBytes, stringToPDFString, stringToUTF8String
- `../../web/annotation_layer_builder.js`: AnnotationLayerBuilder
- `../../web/app_options.js`: AppOptions, OptionKind
- `../../web/download_manager.js`: DownloadManager
- `../../web/event_utils.js`: EventBus, WaitOnType, waitOnEventOrTimeout
- `../../web/genericl10n.js`: GenericL10n
- `../../web/pdf_find_controller.js`: FindState, PDFFindController
- `../../web/pdf_find_utils.js`: CharacterType, getCharacterType
- `../../web/pdf_history.js`: PDFHistory, isDestArraysEqual, isDestHashesEqual
- `../../web/pdf_link_service.js`: LinkTarget, PDFLinkService, SimpleLinkService
- `../../web/pdf_page_view.js`: PDFPageView
- `../../web/pdf_scripting_manager.component.js`: PDFScriptingManager
- `../../web/pdf_single_page_viewer.js`: PDFSinglePageViewer
- `../../web/pdf_viewer.js`: PDFPageViewBuffer, PDFViewer
- `../../web/struct_tree_layer_builder.js`: StructTreeLayerBuilder
- `../../web/text_layer_builder.js`: TextLayerBuilder
- `../../web/ui_utils.js`: AutoPrintRegExp, ProgressBar, RenderingStates, ScrollMode, SpreadMode, backtrackBeforeAllVisibleElements, binarySearchFirstItem, calcRound, getPageSizeInches, getVisibleElements, isPortraitOrientation, isValidRotation, parseQueryString, removeNullCharacters
- `../../web/xfa_layer_builder.js`: XfaLayerBuilder
- `./test_utils.js`: CMAP_URL, DefaultFileReaderFactory, STANDARD_FONT_DATA_URL, TEST_PDFS_PATH, XRefMock, buildGetDocumentParams, createIdFactory, createTemporaryNodeServer
- `./testreporter.js`: TestReporter
</imports>

Code:
<code>
File:
src/display/canvas.js
1 /* Copyright 2012 Mozilla Foundation
2  *
3  * Licensed under the Apache License, Version 2.0 (the "License");
4  * you may not use this file except in compliance with the License.
5  * You may obtain a copy of the License at
6  *
7  *     http://www.apache.org/licenses/LICENSE-2.0
8  *
9  * Unless required by applicable law or agreed to in writing, software
10  * distributed under the License is distributed on an "AS IS" BASIS,
11  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
12  * See the License for the specific language governing permissions and
13  * limitations under the License.
14  */
15 
16 import {
17   FeatureTest,
18   FONT_IDENTITY_MATRIX,
19   IDENTITY_MATRIX,
20   ImageKind,
21   info,
22   isNodeJS,
23   OPS,
24   shadow,
25   TextRenderingMode,
26   unreachable,
27   Util,
28   warn,
29 } from "../shared/util.js";
30 import {
31   getCurrentTransform,
32   getCurrentTransformInverse,
33   PixelsPerInch,
34 } from "./display_utils.js";
35 import {
36   getShadingPattern,
37   PathType,
38   TilingPattern,
39 } from "./pattern_helper.js";
40 import { convertBlackAndWhiteToRGBA } from "../shared/image_utils.js";
41 
42 // <canvas> contexts store most of the state we need natively.
43 // However, PDF needs a bit more state, which we store here.
44 // Minimal font size that would be used during canvas fillText operations.
45 const MIN_FONT_SIZE = 16;
46 // Maximum font size that would be used during canvas fillText operations.
47 const MAX_FONT_SIZE = 100;
48 
49 // Defines the time the `executeOperatorList`-method is going to be executing
50 // before it stops and schedules a continue of execution.
51 const EXECUTION_TIME = 15; // ms
52 // Defines the number of steps before checking the execution time.
53 const EXECUTION_STEPS = 10;
54 
55 // To disable Type3 compilation, set the value to `-1`.
56 const MAX_SIZE_TO_COMPILE = 1000;
57 
58 const FULL_CHUNK_HEIGHT = 16;
59 
60 /**
61  * Overrides certain methods on a 2d ctx so that when they are called they
62  * will also call the same method on the destCtx. The methods that are
63  * overridden are all the transformation state modifiers, path creation, and
64  * save/restore. We only forward these specific methods because they are the
65  * only state modifiers that we cannot copy over when we switch contexts.
66  *
67  * To remove mirroring call `ctx._removeMirroring()`.
68  *
69  * @param {Object} ctx - The 2d canvas context that will duplicate its calls on
70  *   the destCtx.
71  * @param {Object} destCtx - The 2d canvas context that will receive the
72  *   forwarded calls.
73  */
74 function mirrorContextOperations(ctx, destCtx) {
75   if (ctx._removeMirroring) {
76     throw new Error("Context is already forwarding operations.");
77   }
78   ctx.__originalSave = ctx.save;
79   ctx.__originalRestore = ctx.restore;
80   ctx.__originalRotate = ctx.rotate;
81   ctx.__originalScale = ctx.scale;
82   ctx.__originalTranslate = ctx.translate;
83   ctx.__originalTransform = ctx.transform;
84   ctx.__originalSetTransform = ctx.setTransform;
85   ctx.__originalResetTransform = ctx.resetTransform;
86   ctx.__originalClip = ctx.clip;
87   ctx.__originalMoveTo = ctx.moveTo;
88   ctx.__originalLineTo = ctx.lineTo;
89   ctx.__originalBezierCurveTo = ctx.bezierCurveTo;
90   ctx.__originalRect = ctx.rect;
91   ctx.__originalClosePath = ctx.closePath;
92   ctx.__originalBeginPath = ctx.beginPath;
93 
94   ctx._removeMirroring = () => {
95     ctx.save = ctx.__originalSave;
96     ctx.restore = ctx.__originalRestore;
97     ctx.rotate = ctx.__originalRotate;
98     ctx.scale = ctx.__originalScale;
99     ctx.translate = ctx.__originalTranslate;
100     ctx.transform = ctx.__originalTransform;
101     ctx.setTransform = ctx.__originalSetTransform;
102     ctx.resetTransform = ctx.__originalResetTransform;
103 
104     ctx.clip = ctx.__originalClip;
105     ctx.moveTo = ctx.__originalMoveTo;
106     ctx.lineTo = ctx.__originalLineTo;
107     ctx.bezierCurveTo = ctx.__originalBezierCurveTo;
108     ctx.rect = ctx.__originalRect;
109     ctx.closePath = ctx.__originalClosePath;
110     ctx.beginPath = ctx.__originalBeginPath;
111     delete ctx._removeMirroring;
112   };
113 
114   ctx.save = function ctxSave() {
115     destCtx.save();
116     this.__originalSave();
117   };
118 
119   ctx.restore = function ctxRestore() {
120     destCtx.restore();
121     this.__originalRestore();
122   };
123 
124   ctx.translate = function ctxTranslate(x, y) {
125     destCtx.translate(x, y);
126     this.__originalTranslate(x, y);
127   };
128 
129   ctx.scale = function ctxScale(x, y) {
130     destCtx.scale(x, y);
131     this.__originalScale(x, y);
132   };
133 
134   ctx.transform = function ctxTransform(a, b, c, d, e, f) {
135     destCtx.transform(a, b, c, d, e, f);
136     this.__originalTransform(a, b, c, d, e, f);
137   };
138 
139   ctx.setTransform = function ctxSetTransform(a, b, c, d, e, f) {
140     destCtx.setTransform(a, b, c, d, e, f);
141     this.__originalSetTransform(a, b, c, d, e, f);
142   };
143 
144   ctx.resetTransform = function ctxResetTransform() {
145     destCtx.resetTransform();
146     this.__originalResetTransform();
147   };
148 
149   ctx.rotate = function ctxRotate(angle) {
150     destCtx.rotate(angle);
151     this.__originalRotate(angle);
152   };
153 
154   ctx.clip = function ctxRotate(rule) {
155     destCtx.clip(rule);
156     this.__originalClip(rule);
157   };
158 
159   ctx.moveTo = function (x, y) {
160     destCtx.moveTo(x, y);
161     this.__originalMoveTo(x, y);
162   };
163 
164   ctx.lineTo = function (x, y) {
165     destCtx.lineTo(x, y);
166     this.__originalLineTo(x, y);
167   };
168 
169   ctx.bezierCurveTo = function (cp1x, cp1y, cp2x, cp2y, x, y) {
170     destCtx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y);
171     this.__originalBezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y);
172   };
173 
174   ctx.rect = function (x, y, width, height) {
175     destCtx.rect(x, y, width, height);
176     this.__originalRect(x, y, width, height);
177   };
178 
179   ctx.closePath = function () {
180     destCtx.closePath();
181     this.__originalClosePath();
182   };
183 
184   ctx.beginPath = function () {
185     destCtx.beginPath();
186     this.__originalBeginPath();
187   };
188 }
189 
190 class CachedCanvases {
191   constructor(canvasFactory) {
192     this.canvasFactory = canvasFactory;
193     this.cache = Object.create(null);
194   }
195 
196   getCanvas(id, width, height) {
197     let canvasEntry;
198     if (this.cache[id] !== undefined) {
199       canvasEntry = this.cache[id];
200       this.canvasFactory.reset(canvasEntry, width, height);
201     } else {
202       canvasEntry = this.canvasFactory.create(width, height);
203       this.cache[id] = canvasEntry;
204     }
205     return canvasEntry;
206   }
207 
208   delete(id) {
209     delete this.cache[id];
210   }
211 
212   clear() {
213     for (const id in this.cache) {
214       const canvasEntry = this.cache[id];
215       this.canvasFactory.destroy(canvasEntry);
216       delete this.cache[id];
217     }
218   }
219 }
220 
221 function drawImageAtIntegerCoords(
222   ctx,
223   srcImg,
224   srcX,
225   srcY,
226   srcW,
227   srcH,
228   destX,
229   destY,
230   destW,
231   destH
232 ) {
233   const [a, b, c, d, tx, ty] = getCurrentTransform(ctx);
234   if (b === 0 && c === 0) {
235     // top-left corner is at (X, Y) and
236     // bottom-right one is at (X + width, Y + height).
237 
238     // If leftX is 4.321 then it's rounded to 4.
239     // If width is 10.432 then it's rounded to 11 because
240     // rightX = leftX + width = 14.753 which is rounded to 15
241     // so after rounding the total width is 11 (15 - 4).
242     // It's why we can't just floor/ceil uniformly, it just depends
243     // on the values we've.
244 
245     const tlX = destX * a + tx;
246     const rTlX = Math.round(tlX);
247     const tlY = destY * d + ty;
248     const rTlY = Math.round(tlY);
249     const brX = (destX + destW) * a + tx;
250 
251     // Some pdf contains images with 1x1 images so in case of 0-width after
252     // scaling we must fallback on 1 to be sure there is something.
253     const rWidth = Math.abs(Math.round(brX) - rTlX) || 1;
254     const brY = (destY + destH) * d + ty;
255     const rHeight = Math.abs(Math.round(brY) - rTlY) || 1;
256 
257     // We must apply a transformation in order to apply it on the image itself.
258     // For example if a == 1 && d == -1, it means that the image itself is
259     // mirrored w.r.t. the x-axis.
260     ctx.setTransform(Math.sign(a), 0, 0, Math.sign(d), rTlX, rTlY);
261     ctx.drawImage(srcImg, srcX, srcY, srcW, srcH, 0, 0, rWidth, rHeight);
262     ctx.setTransform(a, b, c, d, tx, ty);
263 
264     return [rWidth, rHeight];
265   }
266 
267   if (a === 0 && d === 0) {
268     // This path is taken in issue9462.pdf (page 3).
269     const tlX = destY * c + tx;
270     const rTlX = Math.round(tlX);
271     const tlY = destX * b + ty;
272     const rTlY = Math.round(tlY);
273     const brX = (destY + destH) * c + tx;
274     const rWidth = Math.abs(Math.round(brX) - rTlX) || 1;
275     const brY = (destX + destW) * b + ty;
276     const rHeight = Math.abs(Math.round(brY) - rTlY) || 1;
277 
278     ctx.setTransform(0, Math.sign(b), Math.sign(c), 0, rTlX, rTlY);
279     ctx.drawImage(srcImg, srcX, srcY, srcW, srcH, 0, 0, rHeight, rWidth);
280     ctx.setTransform(a, b, c, d, tx, ty);
281 
282     return [rHeight, rWidth];
283   }
284 
285   // Not a scale matrix so let the render handle the case without rounding.
286   ctx.drawImage(srcImg, srcX, srcY, srcW, srcH, destX, destY, destW, destH);
287 
288   const scaleX = Math.hypot(a, b);
289   const scaleY = Math.hypot(c, d);
290   return [scaleX * destW, scaleY * destH];
291 }
292 
293 function compileType3Glyph(imgData) {
294   const { width, height } = imgData;
295   if (width > MAX_SIZE_TO_COMPILE || height > MAX_SIZE_TO_COMPILE) {
296     return null;
297   }
298 
299   const POINT_TO_PROCESS_LIMIT = 1000;
300   const POINT_TYPES = new Uint8Array([
301     0, 2, 4, 0, 1, 0, 5, 4, 8, 10, 0, 8, 0, 2, 1, 0,
302   ]);
303 
304   const width1 = width + 1;
305   let points = new Uint8Array(width1 * (height + 1));
306   let i, j, j0;
307 
308   // decodes bit-packed mask data
309   const lineSize = (width + 7) & ~7;
310   let data = new Uint8Array(lineSize * height),
311     pos = 0;
312   for (const elem of imgData.data) {
313     let mask = 128;
314     while (mask > 0) {
315       data[pos++] = elem & mask ? 0 : 255;
316       mask >>= 1;
317     }
318   }
319 
320   // finding interesting points: every point is located between mask pixels,
321   // so there will be points of the (width + 1)x(height + 1) grid. Every point
322   // will have flags assigned based on neighboring mask pixels:
323   //   4 | 8
324   //   --P--
325   //   2 | 1
326   // We are interested only in points with the flags:
327   //   - outside corners: 1, 2, 4, 8;
328   //   - inside corners: 7, 11, 13, 14;
329   //   - and, intersections: 5, 10.
330   let count = 0;
331   pos = 0;
332   if (data[pos] !== 0) {
333     points[0] = 1;
334     ++count;
335   }
336   for (j = 1; j < width; j++) {
337     if (data[pos] !== data[pos + 1]) {
338       points[j] = data[pos] ? 2 : 1;
339       ++count;
340     }
341     pos++;
342   }
343   if (data[pos] !== 0) {
344     points[j] = 2;
345     ++count;
346   }
347   for (i = 1; i < height; i++) {
348     pos = i * lineSize;
349     j0 = i * width1;
350     if (data[pos - lineSize] !== data[pos]) {
351       points[j0] = data[pos] ? 1 : 8;
352       ++count;
353     }
354     // 'sum' is the position of the current pixel configuration in the 'TYPES'
355     // array (in order 8-1-2-4, so we can use '>>2' to shift the column).
356     let sum = (data[pos] ? 4 : 0) + (data[pos - lineSize] ? 8 : 0);
357     for (j = 1; j < width; j++) {
358       sum =
359         (sum >> 2) +
360         (data[pos + 1] ? 4 : 0) +
361         (data[pos - lineSize + 1] ? 8 : 0);
362       if (POINT_TYPES[sum]) {
363         points[j0 + j] = POINT_TYPES[sum];
364         ++count;
365       }
366       pos++;
367     }
368     if (data[pos - lineSize] !== data[pos]) {
369       points[j0 + j] = data[pos] ? 2 : 4;
370       ++count;
371     }
372 
373     if (count > POINT_TO_PROCESS_LIMIT) {
374       return null;
375     }
376   }
377 
378   pos = lineSize * (height - 1);
379   j0 = i * width1;
380   if (data[pos] !== 0) {
381     points[j0] = 8;
382     ++count;
383   }
384   for (j = 1; j < width; j++) {
385     if (data[pos] !== data[pos + 1]) {
386       points[j0 + j] = data[pos] ? 4 : 8;
387       ++count;
388     }
389     pos++;
390   }
391   if (data[pos] !== 0) {
392     points[j0 + j] = 4;
393     ++count;
394   }
395   if (count > POINT_TO_PROCESS_LIMIT) {
396     return null;
397   }
398 
399   // building outlines
400   const steps = new Int32Array([0, width1, -1, 0, -width1, 0, 0, 0, 1]);
401   const path = new Path2D();
402 
403   for (i = 0; count && i <= height; i++) {
404     let p = i * width1;
405     const end = p + width;
406     while (p < end && !points[p]) {
407       p++;
408     }
409     if (p === end) {
410       continue;
411     }
412     path.moveTo(p % width1, i);
413 
414     const p0 = p;
415     let type = points[p];
416     do {
417       const step = steps[type];
418       do {
419         p += step;
420       } while (!points[p]);
421 
422       const pp = points[p];
423       if (pp !== 5 && pp !== 10) {
424         // set new direction
425         type = pp;
426         // delete mark
427         points[p] = 0;
428       } else {
429         // type is 5 or 10, ie, a crossing
430         // set new direction
431         type = pp & ((0x33 * type) >> 4);
432         // set new type for "future hit"
433         points[p] &= (type >> 2) | (type << 2);
434       }
435       path.lineTo(p % width1, (p / width1) | 0);
436 
437       if (!points[p]) {
438         --count;
439       }
440     } while (p0 !== p);
441     --i;
442   }
443 
444   // Immediately release the, potentially large, `Uint8Array`s after parsing.
445   data = null;
446   points = null;
447 
448   const drawOutline = function (c) {
449     c.save();
450     // the path shall be painted in [0..1]x[0..1] space
451     c.scale(1 / width, -1 / height);
452     c.translate(0, -height);
453     c.fill(path);
454     c.beginPath();
455     c.restore();
456   };
457 
458   return drawOutline;
459 }
460 
461 class CanvasExtraState {
462   constructor(width, height) {
463     // Are soft masks and alpha values shapes or opacities?
464     this.alphaIsShape = false;
465     this.fontSize = 0;
466     this.fontSizeScale = 1;
467     this.textMatrix = IDENTITY_MATRIX;
468     this.textMatrixScale = 1;
469     this.fontMatrix = FONT_IDENTITY_MATRIX;
470     this.leading = 0;
471     // Current point (in user coordinates)
472     this.x = 0;
473     this.y = 0;
474     // Start of text line (in text coordinates)
475     this.lineX = 0;
476     this.lineY = 0;
477     // Character and word spacing
478     this.charSpacing = 0;
479     this.wordSpacing = 0;
480     this.textHScale = 1;
481     this.textRenderingMode = TextRenderingMode.FILL;
482     this.textRise = 0;
483     // Default fore and background colors
484     this.fillColor = "#000000";
485     this.strokeColor = "#000000";
486     this.patternFill = false;
487     // Note: fill alpha applies to all non-stroking operations
488     this.fillAlpha = 1;
489     this.strokeAlpha = 1;
490     this.lineWidth = 1;
491     this.activeSMask = null;
492     this.transferMaps = "none";
493 
494     this.startNewPathAndClipBox([0, 0, width, height]);
495   }
496 
497   clone() {
498     const clone = Object.create(this);
499     clone.clipBox = this.clipBox.slice();
500     return clone;
501   }
502 
503   setCurrentPoint(x, y) {
504     this.x = x;
505     this.y = y;
506   }
507 
508   updatePathMinMax(transform, x, y) {
509     [x, y] = Util.applyTransform([x, y], transform);
510     this.minX = Math.min(this.minX, x);
511     this.minY = Math.min(this.minY, y);
512     this.maxX = Math.max(this.maxX, x);
513     this.maxY = Math.max(this.maxY, y);
514   }
515 
516   updateRectMinMax(transform, rect) {
517     const p1 = Util.applyTransform(rect, transform);
518     const p2 = Util.applyTransform(rect.slice(2), transform);
519     const p3 = Util.applyTransform([rect[0], rect[3]], transform);
520     const p4 = Util.applyTransform([rect[2], rect[1]], transform);
521 
522     this.minX = Math.min(this.minX, p1[0], p2[0], p3[0], p4[0]);
523     this.minY = Math.min(this.minY, p1[1], p2[1], p3[1], p4[1]);
524     this.maxX = Math.max(this.maxX, p1[0], p2[0], p3[0], p4[0]);
525     this.maxY = Math.max(this.maxY, p1[1], p2[1], p3[1], p4[1]);
526   }
527 
528   updateScalingPathMinMax(transform, minMax) {
529     Util.scaleMinMax(transform, minMax);
530     this.minX = Math.min(this.minX, minMax[0]);
531     this.minY = Math.min(this.minY, minMax[1]);
532     this.maxX = Math.max(this.maxX, minMax[2]);
533     this.maxY = Math.max(this.maxY, minMax[3]);
534   }
535 
536   updateCurvePathMinMax(transform, x0, y0, x1, y1, x2, y2, x3, y3, minMax) {
537     const box = Util.bezierBoundingBox(x0, y0, x1, y1, x2, y2, x3, y3, minMax);
538     if (minMax) {
539       return;
540     }
541     this.updateRectMinMax(transform, box);
542   }
543 
544   getPathBoundingBox(pathType = PathType.FILL, transform = null) {
545     const box = [this.minX, this.minY, this.maxX, this.maxY];
546     if (pathType === PathType.STROKE) {
547       if (!transform) {
548         unreachable("Stroke bounding box must include transform.");
549       }
550       // Stroked paths can be outside of the path bounding box by 1/2 the line
551       // width.
552       const scale = Util.singularValueDecompose2dScale(transform);
553       const xStrokePad = (scale[0] * this.lineWidth) / 2;
554       const yStrokePad = (scale[1] * this.lineWidth) / 2;
555       box[0] -= xStrokePad;
556       box[1] -= yStrokePad;
557       box[2] += xStrokePad;
558       box[3] += yStrokePad;
559     }
560     return box;
561   }
562 
563   updateClipFromPath() {
564     const intersect = Util.intersect(this.clipBox, this.getPathBoundingBox());
565     this.startNewPathAndClipBox(intersect || [0, 0, 0, 0]);
566   }
567 
568   isEmptyClip() {
569     return this.minX === Infinity;
570   }
571 
572   startNewPathAndClipBox(box) {
573     this.clipBox = box;
574     this.minX = Infinity;
575     this.minY = Infinity;
576     this.maxX = 0;
577     this.maxY = 0;
578   }
579 
580   getClippedPathBoundingBox(pathType = PathType.FILL, transform = null) {
581     return Util.intersect(
582       this.clipBox,
583       this.getPathBoundingBox(pathType, transform)
584     );
585   }
586 }
587 
588 function putBinaryImageData(ctx, imgData) {
589   if (typeof ImageData !== "undefined" && imgData instanceof ImageData) {
590     ctx.putImageData(imgData, 0, 0);
591     return;
592   }
593 
594   // Put the image data to the canvas in chunks, rather than putting the
595   // whole image at once.  This saves JS memory, because the ImageData object
596   // is smaller. It also possibly saves C++ memory within the implementation
597   // of putImageData(). (E.g. in Firefox we make two short-lived copies of
598   // the data passed to putImageData()). |n| shouldn't be too small, however,
599   // because too many putImageData() calls will slow things down.
600   //
601   // Note: as written, if the last chunk is partial, the putImageData() call
602   // will (conceptually) put pixels past the bounds of the canvas.  But
603   // that's ok; any such pixels are ignored.
604 
605   const height = imgData.height,
606     width = imgData.width;
607   const partialChunkHeight = height % FULL_CHUNK_HEIGHT;
608   const fullChunks = (height - partialChunkHeight) / FULL_CHUNK_HEIGHT;
609   const totalChunks = partialChunkHeight === 0 ? fullChunks : fullChunks + 1;
610 
611   const chunkImgData = ctx.createImageData(width, FULL_CHUNK_HEIGHT);
612   let srcPos = 0,
613     destPos;
614   const src = imgData.data;
615   const dest = chunkImgData.data;
616   let i, j, thisChunkHeight, elemsInThisChunk;
617 
618   // There are multiple forms in which the pixel data can be passed, and
619   // imgData.kind tells us which one this is.
620   if (imgData.kind === ImageKind.GRAYSCALE_1BPP) {
621     // Grayscale, 1 bit per pixel (i.e. black-and-white).
622     const srcLength = src.byteLength;
623     const dest32 = new Uint32Array(dest.buffer, 0, dest.byteLength >> 2);
624     const dest32DataLength = dest32.length;
625     const fullSrcDiff = (width + 7) >> 3;
626     const white = 0xffffffff;
627     const black = FeatureTest.isLittleEndian ? 0xff000000 : 0x000000ff;
628 
629     for (i = 0; i < totalChunks; i++) {
630       thisChunkHeight = i < fullChunks ? FULL_CHUNK_HEIGHT : partialChunkHeight;
631       destPos = 0;
632       for (j = 0; j < thisChunkHeight; j++) {
633         const srcDiff = srcLength - srcPos;
634         let k = 0;
635         const kEnd = srcDiff > fullSrcDiff ? width : srcDiff * 8 - 7;
636         const kEndUnrolled = kEnd & ~7;
637         let mask = 0;
638         let srcByte = 0;
639         for (; k < kEndUnrolled; k += 8) {
640           srcByte = src[srcPos++];
641           dest32[destPos++] = srcByte & 128 ? white : black;
642           dest32[destPos++] = srcByte & 64 ? white : black;
643           dest32[destPos++] = srcByte & 32 ? white : black;
644           dest32[destPos++] = srcByte & 16 ? white : black;
645           dest32[destPos++] = srcByte & 8 ? white : black;
646           dest32[destPos++] = srcByte & 4 ? white : black;
647           dest32[destPos++] = srcByte & 2 ? white : black;
648           dest32[destPos++] = srcByte & 1 ? white : black;
649         }
650         for (; k < kEnd; k++) {
651           if (mask === 0) {
652             srcByte = src[srcPos++];
653             mask = 128;
654           }
655 
656           dest32[destPos++] = srcByte & mask ? white : black;
657           mask >>= 1;
658         }
659       }
660       // We ran out of input. Make all remaining pixels transparent.
661       while (destPos < dest32DataLength) {
662         dest32[destPos++] = 0;
663       }
664 
665       ctx.putImageData(chunkImgData, 0, i * FULL_CHUNK_HEIGHT);
666     }
667   } else if (imgData.kind === ImageKind.RGBA_32BPP) {
668     // RGBA, 32-bits per pixel.
669     j = 0;
670     elemsInThisChunk = width * FULL_CHUNK_HEIGHT * 4;
671     for (i = 0; i < fullChunks; i++) {
672       dest.set(src.subarray(srcPos, srcPos + elemsInThisChunk));
673       srcPos += elemsInThisChunk;
674 
675       ctx.putImageData(chunkImgData, 0, j);
676       j += FULL_CHUNK_HEIGHT;
677     }
678     if (i < totalChunks) {
679       elemsInThisChunk = width * partialChunkHeight * 4;
680       dest.set(src.subarray(srcPos, srcPos + elemsInThisChunk));
681 
682       ctx.putImageData(chunkImgData, 0, j);
683     }
684   } else if (imgData.kind === ImageKind.RGB_24BPP) {
685     // RGB, 24-bits per pixel.
686     thisChunkHeight = FULL_CHUNK_HEIGHT;
687     elemsInThisChunk = width * thisChunkHeight;
688     for (i = 0; i < totalChunks; i++) {
689       if (i >= fullChunks) {
690         thisChunkHeight = partialChunkHeight;
691         elemsInThisChunk = width * thisChunkHeight;
692       }
693 
694       destPos = 0;
695       for (j = elemsInThisChunk; j--; ) {
696         dest[destPos++] = src[srcPos++];
697         dest[destPos++] = src[srcPos++];
698         dest[destPos++] = src[srcPos++];
699         dest[destPos++] = 255;
700       }
701 
702       ctx.putImageData(chunkImgData, 0, i * FULL_CHUNK_HEIGHT);
703     }
704   } else {
705     throw new Error(`bad image kind: ${imgData.kind}`);
706   }
707 }
708 
709 function putBinaryImageMask(ctx, imgData) {
710   if (imgData.bitmap) {
711     // The bitmap has been created in the worker.
712     ctx.drawImage(imgData.bitmap, 0, 0);
713     return;
714   }
715 
716   // Slow path: OffscreenCanvas isn't available in the worker.
717   const height = imgData.height,
718     width = imgData.width;
719   const partialChunkHeight = height % FULL_CHUNK_HEIGHT;
720   const fullChunks = (height - partialChunkHeight) / FULL_CHUNK_HEIGHT;
721   const totalChunks = partialChunkHeight === 0 ? fullChunks : fullChunks + 1;
722 
723   const chunkImgData = ctx.createImageData(width, FULL_CHUNK_HEIGHT);
724   let srcPos = 0;
725   const src = imgData.data;
726   const dest = chunkImgData.data;
727 
728   for (let i = 0; i < totalChunks; i++) {
729     const thisChunkHeight =
730       i < fullChunks ? FULL_CHUNK_HEIGHT : partialChunkHeight;
731 
732     // Expand the mask so it can be used by the canvas.  Any required
733     // inversion has already been handled.
734 
735     ({ srcPos } = convertBlackAndWhiteToRGBA({
736       src,
737       srcPos,
738       dest,
739       width,
740       height: thisChunkHeight,
741       nonBlackColor: 0,
742     }));
743 
744     ctx.putImageData(chunkImgData, 0, i * FULL_CHUNK_HEIGHT);
745   }
746 }
747 
748 function copyCtxState(sourceCtx, destCtx) {
749   const properties = [
750     "strokeStyle",
751     "fillStyle",
752     "fillRule",
753     "globalAlpha",
754     "lineWidth",
755     "lineCap",
756     "lineJoin",
757     "miterLimit",
758     "globalCompositeOperation",
759     "font",
760     "filter",
761   ];
762   for (const property of properties) {
763     if (sourceCtx[property] !== undefined) {
764       destCtx[property] = sourceCtx[property];
765     }
766   }
767   if (sourceCtx.setLineDash !== undefined) {
768     destCtx.setLineDash(sourceCtx.getLineDash());
769     destCtx.lineDashOffset = sourceCtx.lineDashOffset;
770   }
771 }
772 
773 function resetCtxToDefault(ctx) {
774   ctx.strokeStyle = ctx.fillStyle = "#000000";
775   ctx.fillRule = "nonzero";
776   ctx.globalAlpha = 1;
777   ctx.lineWidth = 1;
778   ctx.lineCap = "butt";
779   ctx.lineJoin = "miter";
780   ctx.miterLimit = 10;
781   ctx.globalCompositeOperation = "source-over";
782   ctx.font = "10px sans-serif";
783   if (ctx.setLineDash !== undefined) {
784     ctx.setLineDash([]);
785     ctx.lineDashOffset = 0;
786   }
787   if (
788     (typeof PDFJSDev !== "undefined" && PDFJSDev.test("MOZCENTRAL")) ||
789     !isNodeJS
790   ) {
791     const { filter } = ctx;
792     if (filter !== "none" && filter !== "") {
793       ctx.filter = "none";
794     }
795   }
796 }
797 
798 function getImageSmoothingEnabled(transform, interpolate) {
799   // In section 8.9.5.3 of the PDF spec, it's mentioned that the interpolate
800   // flag should be used when the image is upscaled.
801   // In Firefox, smoothing is always used when downscaling images (bug 1360415).
802 
803   if (interpolate) {
804     return true;
805   }
806 
807   const scale = Util.singularValueDecompose2dScale(transform);
808   // Round to a 32bit float so that `<=` check below will pass for numbers that
809   // are very close, but not exactly the same 64bit floats.
810   scale[0] = Math.fround(scale[0]);
811   scale[1] = Math.fround(scale[1]);
812   const actualScale = Math.fround(
813     (globalThis.devicePixelRatio || 1) * PixelsPerInch.PDF_TO_CSS_UNITS
814   );
815   return scale[0] <= actualScale && scale[1] <= actualScale;
816 }
817 
818 const LINE_CAP_STYLES = ["butt", "round", "square"];
819 const LINE_JOIN_STYLES = ["miter", "round", "bevel"];
820 const NORMAL_CLIP = {};
821 const EO_CLIP = {};
822 
823 class CanvasGraphics {
824   constructor(
825     canvasCtx,
826     commonObjs,
827     objs,
828     canvasFactory,
829     filterFactory,
830     { optionalContentConfig, markedContentStack = null },
831     annotationCanvasMap,
832     pageColors
833   ) {
834     this.ctx = canvasCtx;
835     this.current = new CanvasExtraState(
836       this.ctx.canvas.width,
837       this.ctx.canvas.height
838     );
839     this.stateStack = [];
840     this.pendingClip = null;
841     this.pendingEOFill = false;
842     this.res = null;
843     this.xobjs = null;
844     this.commonObjs = commonObjs;
845     this.objs = objs;
846     this.canvasFactory = canvasFactory;
847     this.filterFactory = filterFactory;
848     this.groupStack = [];
849     this.processingType3 = null;
850     // Patterns are painted relative to the initial page/form transform, see
851     // PDF spec 8.7.2 NOTE 1.
852     this.baseTransform = null;
853     this.baseTransformStack = [];
854     this.groupLevel = 0;
855     this.smaskStack = [];
856     this.smaskCounter = 0;
857     this.tempSMask = null;
858     this.suspendedCtx = null;
859     this.contentVisible = true;
860     this.markedContentStack = markedContentStack || [];
861     this.optionalContentConfig = optionalContentConfig;
862     this.cachedCanvases = new CachedCanvases(this.canvasFactory);
863     this.cachedPatterns = new Map();
864     this.annotationCanvasMap = annotationCanvasMap;
865     this.viewportScale = 1;
866     this.outputScaleX = 1;
867     this.outputScaleY = 1;
868     this.pageColors = pageColors;
869 
870     this._cachedScaleForStroking = [-1, 0];
871     this._cachedGetSinglePixelWidth = null;
872     this._cachedBitmapsMap = new Map();
873   }
874 
875   getObject(data, fallback = null) {
876     if (typeof data === "string") {
877       return data.startsWith("g_")
878         ? this.commonObjs.get(data)
879         : this.objs.get(data);
880     }
881     return fallback;
882   }
883 
884   beginDrawing({
885     transform,
886     viewport,
887     transparency = false,
888     background = null,
889   }) {
890     // For pdfs that use blend modes we have to clear the canvas else certain
891     // blend modes can look wrong since we'd be blending with a white
892     // backdrop. The problem with a transparent backdrop though is we then
893     // don't get sub pixel anti aliasing on text, creating temporary
894     // transparent canvas when we have blend modes.
895     const width = this.ctx.canvas.width;
896     const height = this.ctx.canvas.height;
897 
898     const savedFillStyle = this.ctx.fillStyle;
899     this.ctx.fillStyle = background || "#ffffff";
900     this.ctx.fillRect(0, 0, width, height);
901     this.ctx.fillStyle = savedFillStyle;
902 
903     if (transparency) {
904       const transparentCanvas = this.cachedCanvases.getCanvas(
905         "transparent",
906         width,
907         height
908       );
909       this.compositeCtx = this.ctx;
910       this.transparentCanvas = transparentCanvas.canvas;
911       this.ctx = transparentCanvas.context;
912       this.ctx.save();
913       // The transform can be applied before rendering, transferring it to
914       // the new canvas.
915       this.ctx.transform(...getCurrentTransform(this.compositeCtx));
916     }
917 
918     this.ctx.save();
919     resetCtxToDefault(this.ctx);
920     if (transform) {
921       this.ctx.transform(...transform);
922       this.outputScaleX = transform[0];
923       this.outputScaleY = transform[0];
924     }
925     this.ctx.transform(...viewport.transform);
926     this.viewportScale = viewport.scale;
927 
928     this.baseTransform = getCurrentTransform(this.ctx);
929   }
930 
931   executeOperatorList(
932     operatorList,
933     executionStartIdx,
934     continueCallback,
935     stepper
936   ) {
937     const argsArray = operatorList.argsArray;
938     const fnArray = operatorList.fnArray;
939     let i = executionStartIdx || 0;
940     const argsArrayLen = argsArray.length;
941 
942     // Sometimes the OperatorList to execute is empty.
943     if (argsArrayLen === i) {
944       return i;
945     }
946 
947     const chunkOperations =
948       argsArrayLen - i > EXECUTION_STEPS &&
949       typeof continueCallback === "function";
950     const endTime = chunkOperations ? Date.now() + EXECUTION_TIME : 0;
951     let steps = 0;
952 
953     const commonObjs = this.commonObjs;
954     const objs = this.objs;
955     let fnId;
956 
957     while (true) {
958       if (stepper !== undefined && i === stepper.nextBreakPoint) {
959         stepper.breakIt(i, continueCallback);
960         return i;
961       }
962 
963       fnId = fnArray[i];
964 
965       if (fnId !== OPS.dependency) {
966         // eslint-disable-next-line prefer-spread
967         this[fnId].apply(this, argsArray[i]);
968       } else {
969         for (const depObjId of argsArray[i]) {
970           const objsPool = depObjId.startsWith("g_") ? commonObjs : objs;
971 
972           // If the promise isn't resolved yet, add the continueCallback
973           // to the promise and bail out.
974           if (!objsPool.has(depObjId)) {
975             objsPool.get(depObjId, continueCallback);
976             return i;
977           }
978         }
979       }
980 
981       i++;
982 
983       // If the entire operatorList was executed, stop as were done.
984       if (i === argsArrayLen) {
985         return i;
986       }
987 
988       // If the execution took longer then a certain amount of time and
989       // `continueCallback` is specified, interrupt the execution.
990       if (chunkOperations && ++steps > EXECUTION_STEPS) {
991         if (Date.now() > endTime) {
992           continueCallback();
993           return i;
994         }
995         steps = 0;
996       }
997 
998       // If the operatorList isn't executed completely yet OR the execution
999       // time was short enough, do another execution round.
1000     }
1001   }
1002 
1003   #restoreInitialState() {
1004     // Finishing all opened operations such as SMask group painting.
1005     while (this.stateStack.length || this.inSMaskMode) {
1006       this.restore();
1007     }
1008 
1009     this.current.activeSMask = null;
1010     this.ctx.restore();
1011 
1012     if (this.transparentCanvas) {
1013       this.ctx = this.compositeCtx;
1014       this.ctx.save();
1015       this.ctx.setTransform(1, 0, 0, 1, 0, 0); // Avoid apply transform twice
1016       this.ctx.drawImage(this.transparentCanvas, 0, 0);
1017       this.ctx.restore();
1018       this.transparentCanvas = null;
1019     }
1020   }
1021 
1022   endDrawing() {
1023     this.#restoreInitialState();
1024 
1025     this.cachedCanvases.clear();
1026     this.cachedPatterns.clear();
1027 
1028     for (const cache of this._cachedBitmapsMap.values()) {
1029       for (const canvas of cache.values()) {
1030         if (
1031           typeof HTMLCanvasElement !== "undefined" &&
1032           canvas instanceof HTMLCanvasElement
1033         ) {
1034           canvas.width = canvas.height = 0;
1035         }
1036       }
1037       cache.clear();
1038     }
1039     this._cachedBitmapsMap.clear();
1040     this.#drawFilter();
1041   }
1042 
1043   #drawFilter() {
1044     if (this.pageColors) {
1045       const hcmFilterId = this.filterFactory.addHCMFilter(
1046         this.pageColors.foreground,
1047         this.pageColors.background
1048       );
1049       if (hcmFilterId !== "none") {
1050         const savedFilter = this.ctx.filter;
1051         this.ctx.filter = hcmFilterId;
1052         this.ctx.drawImage(this.ctx.canvas, 0, 0);
1053         this.ctx.filter = savedFilter;
1054       }
1055     }
1056   }
1057 
1058   _scaleImage(img, inverseTransform) {
1059     // Vertical or horizontal scaling shall not be more than 2 to not lose the
1060     // pixels during drawImage operation, painting on the temporary canvas(es)
1061     // that are twice smaller in size.
1062 
1063     // displayWidth and displayHeight are used for VideoFrame.
1064     const width = img.width ?? img.displayWidth;
1065     const height = img.height ?? img.displayHeight;
1066     let widthScale = Math.max(
1067       Math.hypot(inverseTransform[0], inverseTransform[1]),
1068       1
1069     );
1070     let heightScale = Math.max(
1071       Math.hypot(inverseTransform[2], inverseTransform[3]),
1072       1
1073     );
1074 
1075     let paintWidth = width,
1076       paintHeight = height;
1077     let tmpCanvasId = "prescale1";
1078     let tmpCanvas, tmpCtx;
1079     while (
1080       (widthScale > 2 && paintWidth > 1) ||
1081       (heightScale > 2 && paintHeight > 1)
1082     ) {
1083       let newWidth = paintWidth,
1084         newHeight = paintHeight;
1085       if (widthScale > 2 && paintWidth > 1) {
1086         // See bug 1820511 (Windows specific bug).
1087         // TODO: once the above bug is fixed we could revert to:
1088         // newWidth = Math.ceil(paintWidth / 2);
1089         newWidth =
1090           paintWidth >= 16384
1091             ? Math.floor(paintWidth / 2) - 1 || 1
1092             : Math.ceil(paintWidth / 2);
1093         widthScale /= paintWidth / newWidth;
1094       }
1095       if (heightScale > 2 && paintHeight > 1) {
1096         // TODO: see the comment above.
1097         newHeight =
1098           paintHeight >= 16384
1099             ? Math.floor(paintHeight / 2) - 1 || 1
1100             : Math.ceil(paintHeight) / 2;
1101         heightScale /= paintHeight / newHeight;
1102       }
1103       tmpCanvas = this.cachedCanvases.getCanvas(
1104         tmpCanvasId,
1105         newWidth,
1106         newHeight
1107       );
1108       tmpCtx = tmpCanvas.context;
1109       tmpCtx.clearRect(0, 0, newWidth, newHeight);
1110       tmpCtx.drawImage(
1111         img,
1112         0,
1113         0,
1114         paintWidth,
1115         paintHeight,
1116         0,
1117         0,
1118         newWidth,
1119         newHeight
1120       );
1121       img = tmpCanvas.canvas;
1122       paintWidth = newWidth;
1123       paintHeight = newHeight;
1124       tmpCanvasId = tmpCanvasId === "prescale1" ? "prescale2" : "prescale1";
1125     }
1126     return {
1127       img,
1128       paintWidth,
1129       paintHeight,
1130     };
1131   }
1132 
1133   _createMaskCanvas(img) {
1134     const ctx = this.ctx;
1135     const { width, height } = img;
1136     const fillColor = this.current.fillColor;
1137     const isPatternFill = this.current.patternFill;
1138     const currentTransform = getCurrentTransform(ctx);
1139 
1140     let cache, cacheKey, scaled, maskCanvas;
1141     if ((img.bitmap || img.data) && img.count > 1) {
1142       const mainKey = img.bitmap || img.data.buffer;
1143       // We're reusing the same image several times, so we can cache it.
1144       // In case we've a pattern fill we just keep the scaled version of
1145       // the image.
1146       // Only the scaling part matters, the translation part is just used
1147       // to compute offsets (but not when filling patterns see #15573).
1148       // TODO: handle the case of a pattern fill if it's possible.
1149       cacheKey = JSON.stringify(
1150         isPatternFill
1151           ? currentTransform
1152           : [currentTransform.slice(0, 4), fillColor]
1153       );
1154 
1155       cache = this._cachedBitmapsMap.get(mainKey);
1156       if (!cache) {
1157         cache = new Map();
1158         this._cachedBitmapsMap.set(mainKey, cache);
1159       }
1160       const cachedImage = cache.get(cacheKey);
1161       if (cachedImage && !isPatternFill) {
1162         const offsetX = Math.round(
1163           Math.min(currentTransform[0], currentTransform[2]) +
1164             currentTransform[4]
1165         );
1166         const offsetY = Math.round(
1167           Math.min(currentTransform[1], currentTransform[3]) +
1168             currentTransform[5]
1169         );
1170         return {
1171           canvas: cachedImage,
1172           offsetX,
1173           offsetY,
1174         };
1175       }
1176       scaled = cachedImage;
1177     }
1178 
1179     if (!scaled) {
1180       maskCanvas = this.cachedCanvases.getCanvas("maskCanvas", width, height);
1181       putBinaryImageMask(maskCanvas.context, img);
1182     }
1183 
1184     // Create the mask canvas at the size it will be drawn at and also set
1185     // its transform to match the current transform so if there are any
1186     // patterns applied they will be applied relative to the correct
1187     // transform.
1188 
1189     let maskToCanvas = Util.transform(currentTransform, [
1190       1 / width,
1191       0,
1192       0,
1193       -1 / height,
1194       0,
1195       0,
1196     ]);
1197     maskToCanvas = Util.transform(maskToCanvas, [1, 0, 0, 1, 0, -height]);
1198     const [minX, minY, maxX, maxY] = Util.getAxialAlignedBoundingBox(
1199       [0, 0, width, height],
1200       maskToCanvas
1201     );
1202     const drawnWidth = Math.round(maxX - minX) || 1;
1203     const drawnHeight = Math.round(maxY - minY) || 1;
1204     const fillCanvas = this.cachedCanvases.getCanvas(
1205       "fillCanvas",
1206       drawnWidth,
1207       drawnHeight
1208     );
1209     const fillCtx = fillCanvas.context;
1210 
1211     // The offset will be the top-left cordinate mask.
1212     // If objToCanvas is [a,b,c,d,e,f] then:
1213     //   - offsetX = min(a, c) + e
1214     //   - offsetY = min(b, d) + f
1215     const offsetX = minX;
1216     const offsetY = minY;
1217     fillCtx.translate(-offsetX, -offsetY);
1218     fillCtx.transform(...maskToCanvas);
1219 
1220     if (!scaled) {
1221       // Pre-scale if needed to improve image smoothing.
1222       scaled = this._scaleImage(
1223         maskCanvas.canvas,
1224         getCurrentTransformInverse(fillCtx)
1225       );
1226       scaled = scaled.img;
1227       if (cache && isPatternFill) {
1228         cache.set(cacheKey, scaled);
1229       }
1230     }
1231 
1232     fillCtx.imageSmoothingEnabled = getImageSmoothingEnabled(
1233       getCurrentTransform(fillCtx),
1234       img.interpolate
1235     );
1236 
1237     drawImageAtIntegerCoords(
1238       fillCtx,
1239       scaled,
1240       0,
1241       0,
1242       scaled.width,
1243       scaled.height,
1244       0,
1245       0,
1246       width,
1247       height
1248     );
1249     fillCtx.globalCompositeOperation = "source-in";
1250 
1251     const inverse = Util.transform(getCurrentTransformInverse(fillCtx), [
1252       1,
1253       0,
1254       0,
1255       1,
1256       -offsetX,
1257       -offsetY,
1258     ]);
1259     fillCtx.fillStyle = isPatternFill
1260       ? fillColor.getPattern(ctx, this, inverse, PathType.FILL)
1261       : fillColor;
1262 
1263     fillCtx.fillRect(0, 0, width, height);
1264 
1265     if (cache && !isPatternFill) {
1266       // The fill canvas is put in the cache associated to the mask image
1267       // so we must remove from the cached canvas: it mustn't be used again.
1268       this.cachedCanvases.delete("fillCanvas");
1269       cache.set(cacheKey, fillCanvas.canvas);
1270     }
1271 
1272     // Round the offsets to avoid drawing fractional pixels.
1273     return {
1274       canvas: fillCanvas.canvas,
1275       offsetX: Math.round(offsetX),
1276       offsetY: Math.round(offsetY),
1277     };
1278   }
1279 
1280   // Graphics state
1281   setLineWidth(width) {
1282     if (width !== this.current.lineWidth) {
1283       this._cachedScaleForStroking[0] = -1;
1284     }
1285     this.current.lineWidth = width;
1286     this.ctx.lineWidth = width;
1287   }
1288 
1289   setLineCap(style) {
1290     this.ctx.lineCap = LINE_CAP_STYLES[style];
1291   }
1292 
1293   setLineJoin(style) {
1294     this.ctx.lineJoin = LINE_JOIN_STYLES[style];
1295   }
1296 
1297   setMiterLimit(limit) {
1298     this.ctx.miterLimit = limit;
1299   }
1300 
1301   setDash(dashArray, dashPhase) {
1302     const ctx = this.ctx;
1303     if (ctx.setLineDash !== undefined) {
1304       ctx.setLineDash(dashArray);
1305       ctx.lineDashOffset = dashPhase;
1306     }
1307   }
1308 
1309   setRenderingIntent(intent) {
1310     // This operation is ignored since we haven't found a use case for it yet.
1311   }
1312 
1313   setFlatness(flatness) {
1314     // This operation is ignored since we haven't found a use case for it yet.
1315   }
1316 
1317   setGState(states) {
1318     for (const [key, value] of states) {
1319       switch (key) {
1320         case "LW":
1321           this.setLineWidth(value);
1322           break;
1323         case "LC":
1324           this.setLineCap(value);
1325           break;
1326         case "LJ":
1327           this.setLineJoin(value);
1328           break;
1329         case "ML":
1330           this.setMiterLimit(value);
1331           break;
1332         case "D":
1333           this.setDash(value[0], value[1]);
1334           break;
1335         case "RI":
1336           this.setRenderingIntent(value);
1337           break;
1338         case "FL":
1339           this.setFlatness(value);
1340           break;
1341         case "Font":
1342           this.setFont(value[0], value[1]);
1343           break;
1344         case "CA":
1345           this.current.strokeAlpha = value;
1346           break;
1347         case "ca":
1348           this.current.fillAlpha = value;
1349           this.ctx.globalAlpha = value;
1350           break;
1351         case "BM":
1352           this.ctx.globalCompositeOperation = value;
1353           break;
1354         case "SMask":
1355           this.current.activeSMask = value ? this.tempSMask : null;
1356           this.tempSMask = null;
1357           this.checkSMaskState();
1358           break;
1359         case "TR":
1360           this.ctx.filter = this.current.transferMaps =
1361             this.filterFactory.addFilter(value);
1362           break;
1363       }
1364     }
1365   }
1366 
1367   get inSMaskMode() {
1368     return !!this.suspendedCtx;
1369   }
1370 
1371   checkSMaskState() {
1372     const inSMaskMode = this.inSMaskMode;
1373     if (this.current.activeSMask && !inSMaskMode) {
1374       this.beginSMaskMode();
1375     } else if (!this.current.activeSMask && inSMaskMode) {
1376       this.endSMaskMode();
1377     }
1378     // Else, the state is okay and nothing needs to be done.
1379   }
1380 
1381   /**
1382    * Soft mask mode takes the current main drawing canvas and replaces it with
1383    * a temporary canvas. Any drawing operations that happen on the temporary
1384    * canvas need to be composed with the main canvas that was suspended (see
1385    * `compose()`). The temporary canvas also duplicates many of its operations
1386    * on the suspended canvas to keep them in sync, so that when the soft mask
1387    * mode ends any clipping paths or transformations will still be active and in
1388    * the right order on the canvas' graphics state stack.
1389    */
1390   beginSMaskMode() {
1391     if (this.inSMaskMode) {
1392       throw new Error("beginSMaskMode called while already in smask mode");
1393     }
1394     const drawnWidth = this.ctx.canvas.width;
1395     const drawnHeight = this.ctx.canvas.height;
1396     const cacheId = "smaskGroupAt" + this.groupLevel;
1397     const scratchCanvas = this.cachedCanvases.getCanvas(
1398       cacheId,
1399       drawnWidth,
1400       drawnHeight
1401     );
1402     this.suspendedCtx = this.ctx;
1403     this.ctx = scratchCanvas.context;
1404     const ctx = this.ctx;
1405     ctx.setTransform(...getCurrentTransform(this.suspendedCtx));
1406     copyCtxState(this.suspendedCtx, ctx);
1407     mirrorContextOperations(ctx, this.suspendedCtx);
1408 
1409     this.setGState([
1410       ["BM", "source-over"],
1411       ["ca", 1],
1412       ["CA", 1],
1413     ]);
1414   }
1415 
1416   endSMaskMode() {
1417     if (!this.inSMaskMode) {
1418       throw new Error("endSMaskMode called while not in smask mode");
1419     }
1420     // The soft mask is done, now restore the suspended canvas as the main
1421     // drawing canvas.
1422     this.ctx._removeMirroring();
1423     copyCtxState(this.ctx, this.suspendedCtx);
1424     this.ctx = this.suspendedCtx;
1425 
1426     this.suspendedCtx = null;
1427   }
1428 
1429   compose(dirtyBox) {
1430     if (!this.current.activeSMask) {
1431       return;
1432     }
1433 
1434     if (!dirtyBox) {
1435       dirtyBox = [0, 0, this.ctx.canvas.width, this.ctx.canvas.height];
1436     } else {
1437       dirtyBox[0] = Math.floor(dirtyBox[0]);
1438       dirtyBox[1] = Math.floor(dirtyBox[1]);
1439       dirtyBox[2] = Math.ceil(dirtyBox[2]);
1440       dirtyBox[3] = Math.ceil(dirtyBox[3]);
1441     }
1442     const smask = this.current.activeSMask;
1443     const suspendedCtx = this.suspendedCtx;
1444 
1445     this.composeSMask(suspendedCtx, smask, this.ctx, dirtyBox);
1446     // Whatever was drawn has been moved to the suspended canvas, now clear it
1447     // out of the current canvas.
1448     this.ctx.save();
1449     this.ctx.setTransform(1, 0, 0, 1, 0, 0);
1450     this.ctx.clearRect(0, 0, this.ctx.canvas.width, this.ctx.canvas.height);
1451     this.ctx.restore();
1452   }
1453 
1454   composeSMask(ctx, smask, layerCtx, layerBox) {
1455     const layerOffsetX = layerBox[0];
1456     const layerOffsetY = layerBox[1];
1457     const layerWidth = layerBox[2] - layerOffsetX;
1458     const layerHeight = layerBox[3] - layerOffsetY;
1459     if (layerWidth === 0 || layerHeight === 0) {
1460       return;
1461     }
1462     this.genericComposeSMask(
1463       smask.context,
1464       layerCtx,
1465       layerWidth,
1466       layerHeight,
1467       smask.subtype,
1468       smask.backdrop,
1469       smask.transferMap,
1470       layerOffsetX,
1471       layerOffsetY,
1472       smask.offsetX,
1473       smask.offsetY
1474     );
1475     ctx.save();
1476     ctx.globalAlpha = 1;
1477     ctx.globalCompositeOperation = "source-over";
1478     ctx.setTransform(1, 0, 0, 1, 0, 0);
1479     ctx.drawImage(layerCtx.canvas, 0, 0);
1480     ctx.restore();
1481   }
1482 
1483   genericComposeSMask(
1484     maskCtx,
1485     layerCtx,
1486     width,
1487     height,
1488     subtype,
1489     backdrop,
1490     transferMap,
1491     layerOffsetX,
1492     layerOffsetY,
1493     maskOffsetX,
1494     maskOffsetY
1495   ) {
1496     let maskCanvas = maskCtx.canvas;
1497     let maskX = layerOffsetX - maskOffsetX;
1498     let maskY = layerOffsetY - maskOffsetY;
1499 
1500     if (backdrop) {
1501       if (
1502         maskX < 0 ||
1503         maskY < 0 ||
1504         maskX + width > maskCanvas.width ||
1505         maskY + height > maskCanvas.height
1506       ) {
1507         const canvas = this.cachedCanvases.getCanvas(
1508           "maskExtension",
1509           width,
1510           height
1511         );
1512         const ctx = canvas.context;
1513         ctx.drawImage(maskCanvas, -maskX, -maskY);
1514         if (backdrop.some(c => c !== 0)) {
1515           ctx.globalCompositeOperation = "destination-atop";
1516           ctx.fillStyle = Util.makeHexColor(...backdrop);
1517           ctx.fillRect(0, 0, width, height);
1518           ctx.globalCompositeOperation = "source-over";
1519         }
1520 
1521         maskCanvas = canvas.canvas;
1522         maskX = maskY = 0;
1523       } else if (backdrop.some(c => c !== 0)) {
1524         maskCtx.save();
1525         maskCtx.globalAlpha = 1;
1526         maskCtx.setTransform(1, 0, 0, 1, 0, 0);
1527         const clip = new Path2D();
1528         clip.rect(maskX, maskY, width, height);
1529         maskCtx.clip(clip);
1530         maskCtx.globalCompositeOperation = "destination-atop";
1531         maskCtx.fillStyle = Util.makeHexColor(...backdrop);
1532         maskCtx.fillRect(maskX, maskY, width, height);
1533         maskCtx.restore();
1534       }
1535     }
1536 
1537     layerCtx.save();
1538     layerCtx.globalAlpha = 1;
1539     layerCtx.setTransform(1, 0, 0, 1, 0, 0);
1540 
1541     if (subtype === "Alpha" && transferMap) {
1542       layerCtx.filter = this.filterFactory.addAlphaFilter(transferMap);
1543     } else if (subtype === "Luminosity") {
1544       layerCtx.filter = this.filterFactory.addLuminosityFilter(transferMap);
1545     }
1546 
1547     const clip = new Path2D();
1548     clip.rect(layerOffsetX, layerOffsetY, width, height);
1549     layerCtx.clip(clip);
1550     layerCtx.globalCompositeOperation = "destination-in";
1551     layerCtx.drawImage(
1552       maskCanvas,
1553       maskX,
1554       maskY,
1555       width,
1556       height,
1557       layerOffsetX,
1558       layerOffsetY,
1559       width,
1560       height
1561     );
1562     layerCtx.restore();
1563   }
1564 
1565   save() {
1566     if (this.inSMaskMode) {
1567       // SMask mode may be turned on/off causing us to lose graphics state.
1568       // Copy the temporary canvas state to the main(suspended) canvas to keep
1569       // it in sync.
1570       copyCtxState(this.ctx, this.suspendedCtx);
1571       // Don't bother calling save on the temporary canvas since state is not
1572       // saved there.
1573       this.suspendedCtx.save();
1574     } else {
1575       this.ctx.save();
1576     }
1577     const old = this.current;
1578     this.stateStack.push(old);
1579     this.current = old.clone();
1580   }
1581 
1582   restore() {
1583     if (this.stateStack.length === 0 && this.inSMaskMode) {
1584       this.endSMaskMode();
1585     }
1586     if (this.stateStack.length !== 0) {
1587       this.current = this.stateStack.pop();
1588       if (this.inSMaskMode) {
1589         // Graphics state is stored on the main(suspended) canvas. Restore its
1590         // state then copy it over to the temporary canvas.
1591         this.suspendedCtx.restore();
1592         copyCtxState(this.suspendedCtx, this.ctx);
1593       } else {
1594         this.ctx.restore();
1595       }
1596       this.checkSMaskState();
1597 
1598       // Ensure that the clipping path is reset (fixes issue6413.pdf).
1599       this.pendingClip = null;
1600 
1601       this._cachedScaleForStroking[0] = -1;
1602       this._cachedGetSinglePixelWidth = null;
1603     }
1604   }
1605 
1606   transform(a, b, c, d, e, f) {
1607     this.ctx.transform(a, b, c, d, e, f);
1608 
1609     this._cachedScaleForStroking[0] = -1;
1610     this._cachedGetSinglePixelWidth = null;
1611   }
1612 
1613   // Path
1614   constructPath(ops, args, minMax) {
1615     const ctx = this.ctx;
1616     const current = this.current;
1617     let x = current.x,
1618       y = current.y;
1619     let startX, startY;
1620     const currentTransform = getCurrentTransform(ctx);
1621 
1622     // Most of the time the current transform is a scaling matrix
1623     // so we don't need to transform points before computing min/max:
1624     // we can compute min/max first and then smartly "apply" the
1625     // transform (see Util.scaleMinMax).
1626     // For rectangle, moveTo and lineTo, min/max are computed in the
1627     // worker (see evaluator.js).
1628     const isScalingMatrix =
1629       (currentTransform[0] === 0 && currentTransform[3] === 0) ||
1630       (currentTransform[1] === 0 && currentTransform[2] === 0);
1631     const minMaxForBezier = isScalingMatrix ? minMax.slice(0) : null;
1632 
1633     for (let i = 0, j = 0, ii = ops.length; i < ii; i++) {
1634       switch (ops[i] | 0) {
1635         case OPS.rectangle:
1636           x = args[j++];
1637           y = args[j++];
1638           const width = args[j++];
1639           const height = args[j++];
1640 
1641           const xw = x + width;
1642           const yh = y + height;
1643           ctx.moveTo(x, y);
1644           if (width === 0 || height === 0) {
1645             ctx.lineTo(xw, yh);
1646           } else {
1647             ctx.lineTo(xw, y);
1648             ctx.lineTo(xw, yh);
1649             ctx.lineTo(x, yh);
1650           }
1651           if (!isScalingMatrix) {
1652             current.updateRectMinMax(currentTransform, [x, y, xw, yh]);
1653           }
1654           ctx.closePath();
1655           break;
1656         case OPS.moveTo:
1657           x = args[j++];
1658           y = args[j++];
1659           ctx.moveTo(x, y);
1660           if (!isScalingMatrix) {
1661             current.updatePathMinMax(currentTransform, x, y);
1662           }
1663           break;
1664         case OPS.lineTo:
1665           x = args[j++];
1666           y = args[j++];
1667           ctx.lineTo(x, y);
1668           if (!isScalingMatrix) {
1669             current.updatePathMinMax(currentTransform, x, y);
1670           }
1671           break;
1672         case OPS.curveTo:
1673           startX = x;
1674           startY = y;
1675           x = args[j + 4];
1676           y = args[j + 5];
1677           ctx.bezierCurveTo(
1678             args[j],
1679             args[j + 1],
1680             args[j + 2],
1681             args[j + 3],
1682             x,
1683             y
1684           );
1685           current.updateCurvePathMinMax(
1686             currentTransform,
1687             startX,
1688             startY,
1689             args[j],
1690             args[j + 1],
1691             args[j + 2],
1692             args[j + 3],
1693             x,
1694             y,
1695             minMaxForBezier
1696           );
1697           j += 6;
1698           break;
1699         case OPS.curveTo2:
1700           startX = x;
1701           startY = y;
1702           ctx.bezierCurveTo(
1703             x,
1704             y,
1705             args[j],
1706             args[j + 1],
1707             args[j + 2],
1708             args[j + 3]
1709           );
1710           current.updateCurvePathMinMax(
1711             currentTransform,
1712             startX,
1713             startY,
1714             x,
1715             y,
1716             args[j],
1717             args[j + 1],
1718             args[j + 2],
1719             args[j + 3],
1720             minMaxForBezier
1721           );
1722           x = args[j + 2];
1723           y = args[j + 3];
1724           j += 4;
1725           break;
1726         case OPS.curveTo3:
1727           startX = x;
1728           startY = y;
1729           x = args[j + 2];
1730           y = args[j + 3];
1731           ctx.bezierCurveTo(args[j], args[j + 1], x, y, x, y);
1732           current.updateCurvePathMinMax(
1733             currentTransform,
1734             startX,
1735             startY,
1736             args[j],
1737             args[j + 1],
1738             x,
1739             y,
1740             x,
1741             y,
1742             minMaxForBezier
1743           );
1744           j += 4;
1745           break;
1746         case OPS.closePath:
1747           ctx.closePath();
1748           break;
1749       }
1750     }
1751 
1752     if (isScalingMatrix) {
1753       current.updateScalingPathMinMax(currentTransform, minMaxForBezier);
1754     }
1755 
1756     current.setCurrentPoint(x, y);
1757   }
1758 
1759   closePath() {
1760     this.ctx.closePath();
1761   }
1762 
1763   stroke(consumePath = true) {
1764     const ctx = this.ctx;
1765     const strokeColor = this.current.strokeColor;
1766     // For stroke we want to temporarily change the global alpha to the
1767     // stroking alpha.
1768     ctx.globalAlpha = this.current.strokeAlpha;
1769     if (this.contentVisible) {
1770       if (typeof strokeColor === "object" && strokeColor?.getPattern) {
1771         ctx.save();
1772         ctx.strokeStyle = strokeColor.getPattern(
1773           ctx,
1774           this,
1775           getCurrentTransformInverse(ctx),
1776           PathType.STROKE
1777         );
1778         this.rescaleAndStroke(/* saveRestore */ false);
1779         ctx.restore();
1780       } else {
1781         this.rescaleAndStroke(/* saveRestore */ true);
1782       }
1783     }
1784     if (consumePath) {
1785       this.consumePath(this.current.getClippedPathBoundingBox());
1786     }
1787     // Restore the global alpha to the fill alpha
1788     ctx.globalAlpha = this.current.fillAlpha;
1789   }
1790 
1791   closeStroke() {
1792     this.closePath();
1793     this.stroke();
1794   }
1795 
1796   fill(consumePath = true) {
1797     const ctx = this.ctx;
1798     const fillColor = this.current.fillColor;
1799     const isPatternFill = this.current.patternFill;
1800     let needRestore = false;
1801 
1802     if (isPatternFill) {
1803       ctx.save();
1804       ctx.fillStyle = fillColor.getPattern(
1805         ctx,
1806         this,
1807         getCurrentTransformInverse(ctx),
1808         PathType.FILL
1809       );
1810       needRestore = true;
1811     }
1812 
1813     const intersect = this.current.getClippedPathBoundingBox();
1814     if (this.contentVisible && intersect !== null) {
1815       if (this.pendingEOFill) {
1816         ctx.fill("evenodd");
1817         this.pendingEOFill = false;
1818       } else {
1819         ctx.fill();
1820       }
1821     }
1822 
1823     if (needRestore) {
1824       ctx.restore();
1825     }
1826     if (consumePath) {
1827       this.consumePath(intersect);
1828     }
1829   }
1830 
1831   eoFill() {
1832     this.pendingEOFill = true;
1833     this.fill();
1834   }
1835 
1836   fillStroke() {
1837     this.fill(false);
1838     this.stroke(false);
1839 
1840     this.consumePath();
1841   }
1842 
1843   eoFillStroke() {
1844     this.pendingEOFill = true;
1845     this.fillStroke();
1846   }
1847 
1848   closeFillStroke() {
1849     this.closePath();
1850     this.fillStroke();
1851   }
1852 
1853   closeEOFillStroke() {
1854     this.pendingEOFill = true;
1855     this.closePath();
1856     this.fillStroke();
1857   }
1858 
1859   endPath() {
1860     this.consumePath();
1861   }
1862 
1863   // Clipping
1864   clip() {
1865     this.pendingClip = NORMAL_CLIP;
1866   }
1867 
1868   eoClip() {
1869     this.pendingClip = EO_CLIP;
1870   }
1871 
1872   // Text
1873   beginText() {
1874     this.current.textMatrix = IDENTITY_MATRIX;
1875     this.current.textMatrixScale = 1;
1876     this.current.x = this.current.lineX = 0;
1877     this.current.y = this.current.lineY = 0;
1878   }
1879 
1880   endText() {
1881     const paths = this.pendingTextPaths;
1882     const ctx = this.ctx;
1883     if (paths === undefined) {
1884       ctx.beginPath();
1885       return;
1886     }
1887 
1888     ctx.save();
1889     ctx.beginPath();
1890     for (const path of paths) {
1891       ctx.setTransform(...path.transform);
1892       ctx.translate(path.x, path.y);
1893       path.addToPath(ctx, path.fontSize);
1894     }
1895     ctx.restore();
1896     ctx.clip();
1897     ctx.beginPath();
1898     delete this.pendingTextPaths;
1899   }
1900 
1901   setCharSpacing(spacing) {
1902     this.current.charSpacing = spacing;
1903   }
1904 
1905   setWordSpacing(spacing) {
1906     this.current.wordSpacing = spacing;
1907   }
1908 
1909   setHScale(scale) {
1910     this.current.textHScale = scale / 100;
1911   }
1912 
1913   setLeading(leading) {
1914     this.current.leading = -leading;
1915   }
1916 
1917   setFont(fontRefName, size) {
1918     const fontObj = this.commonObjs.get(fontRefName);
1919     const current = this.current;
1920 
1921     if (!fontObj) {
1922       throw new Error(`Can't find font for ${fontRefName}`);
1923     }
1924     current.fontMatrix = fontObj.fontMatrix || FONT_IDENTITY_MATRIX;
1925 
1926     // A valid matrix needs all main diagonal elements to be non-zero
1927     // This also ensures we bypass FF bugzilla bug #719844.
1928     if (current.fontMatrix[0] === 0 || current.fontMatrix[3] === 0) {
1929       warn("Invalid font matrix for font " + fontRefName);
1930     }
1931 
1932     // The spec for Tf (setFont) says that 'size' specifies the font 'scale',
1933     // and in some docs this can be negative (inverted x-y axes).
1934     if (size < 0) {
1935       size = -size;
1936       current.fontDirection = -1;
1937     } else {
1938       current.fontDirection = 1;
1939     }
1940 
1941     this.current.font = fontObj;
1942     this.current.fontSize = size;
1943 
1944     if (fontObj.isType3Font) {
1945       return; // we don't need ctx.font for Type3 fonts
1946     }
1947 
1948     const name = fontObj.loadedName || "sans-serif";
1949     const typeface =
1950       fontObj.systemFontInfo?.css || `"${name}", ${fontObj.fallbackName}`;
1951 
1952     let bold = "normal";
1953     if (fontObj.black) {
1954       bold = "900";
1955     } else if (fontObj.bold) {
1956       bold = "bold";
1957     }
1958     const italic = fontObj.italic ? "italic" : "normal";
1959 
1960     // Some font backends cannot handle fonts below certain size.
1961     // Keeping the font at minimal size and using the fontSizeScale to change
1962     // the current transformation matrix before the fillText/strokeText.
1963     // See https://bugzilla.mozilla.org/show_bug.cgi?id=726227
1964     let browserFontSize = size;
1965     if (size < MIN_FONT_SIZE) {
1966       browserFontSize = MIN_FONT_SIZE;
1967     } else if (size > MAX_FONT_SIZE) {
1968       browserFontSize = MAX_FONT_SIZE;
1969     }
1970     this.current.fontSizeScale = size / browserFontSize;
1971 
1972     this.ctx.font = `${italic} ${bold} ${browserFontSize}px ${typeface}`;
1973   }
1974 
1975   setTextRenderingMode(mode) {
1976     this.current.textRenderingMode = mode;
1977   }
1978 
1979   setTextRise(rise) {
1980     this.current.textRise = rise;
1981   }
1982 
1983   moveText(x, y) {
1984     this.current.x = this.current.lineX += x;
1985     this.current.y = this.current.lineY += y;
1986   }
1987 
1988   setLeadingMoveText(x, y) {
1989     this.setLeading(-y);
1990     this.moveText(x, y);
1991   }
1992 
1993   setTextMatrix(a, b, c, d, e, f) {
1994     this.current.textMatrix = [a, b, c, d, e, f];
1995     this.current.textMatrixScale = Math.hypot(a, b);
1996 
1997     this.current.x = this.current.lineX = 0;
1998     this.current.y = this.current.lineY = 0;
1999   }
2000 
2001   nextLine() {
2002     this.moveText(0, this.current.leading);
2003   }
2004 
2005   paintChar(character, x, y, patternTransform) {
2006     const ctx = this.ctx;
2007     const current = this.current;
2008     const font = current.font;
2009     const textRenderingMode = current.textRenderingMode;
2010     const fontSize = current.fontSize / current.fontSizeScale;
2011     const fillStrokeMode =
2012       textRenderingMode & TextRenderingMode.FILL_STROKE_MASK;
2013     const isAddToPathSet = !!(
2014       textRenderingMode & TextRenderingMode.ADD_TO_PATH_FLAG
2015     );
2016     const patternFill = current.patternFill && !font.missingFile;
2017 
2018     let addToPath;
2019     if (font.disableFontFace || isAddToPathSet || patternFill) {
2020       addToPath = font.getPathGenerator(this.commonObjs, character);
2021     }
2022 
2023     if (font.disableFontFace || patternFill) {
2024       ctx.save();
2025       ctx.translate(x, y);
2026       ctx.beginPath();
2027       addToPath(ctx, fontSize);
2028       if (patternTransform) {
2029         ctx.setTransform(...patternTransform);
2030       }
2031       if (
2032         fillStrokeMode === TextRenderingMode.FILL ||
2033         fillStrokeMode === TextRenderingMode.FILL_STROKE
2034       ) {
2035         ctx.fill();
2036       }
2037       if (
2038         fillStrokeMode === TextRenderingMode.STROKE ||
2039         fillStrokeMode === TextRenderingMode.FILL_STROKE
2040       ) {
2041         ctx.stroke();
2042       }
2043       ctx.restore();
2044     } else {
2045       if (
2046         fillStrokeMode === TextRenderingMode.FILL ||
2047         fillStrokeMode === TextRenderingMode.FILL_STROKE
2048       ) {
2049         ctx.fillText(character, x, y);
2050       }
2051       if (
2052         fillStrokeMode === TextRenderingMode.STROKE ||
2053         fillStrokeMode === TextRenderingMode.FILL_STROKE
2054       ) {
2055         ctx.strokeText(character, x, y);
2056       }
2057     }
2058 
2059     if (isAddToPathSet) {
2060       const paths = (this.pendingTextPaths ||= []);
2061       paths.push({
2062         transform: getCurrentTransform(ctx),
2063         x,
2064         y,
2065         fontSize,
2066         addToPath,
2067       });
2068     }
2069   }
2070 
2071   get isFontSubpixelAAEnabled() {
2072     // Checks if anti-aliasing is enabled when scaled text is painted.
2073     // On Windows GDI scaled fonts looks bad.
2074     const { context: ctx } = this.cachedCanvases.getCanvas(
2075       "isFontSubpixelAAEnabled",
2076       10,
2077       10
2078     );
2079     ctx.scale(1.5, 1);
2080     ctx.fillText("I", 0, 10);
2081     const data = ctx.getImageData(0, 0, 10, 10).data;
2082     let enabled = false;
2083     for (let i = 3; i < data.length; i += 4) {
2084       if (data[i] > 0 && data[i] < 255) {
2085         enabled = true;
2086         break;
2087       }
2088     }
2089     return shadow(this, "isFontSubpixelAAEnabled", enabled);
2090   }
2091 
2092   showText(glyphs) {
2093     const current = this.current;
2094     const font = current.font;
2095     if (font.isType3Font) {
2096       return this.showType3Text(glyphs);
2097     }
2098 
2099     const fontSize = current.fontSize;
2100     if (fontSize === 0) {
2101       return undefined;
2102     }
2103 
2104     const ctx = this.ctx;
2105     const fontSizeScale = current.fontSizeScale;
2106     const charSpacing = current.charSpacing;
2107     const wordSpacing = current.wordSpacing;
2108     const fontDirection = current.fontDirection;
2109     const textHScale = current.textHScale * fontDirection;
2110     const glyphsLength = glyphs.length;
2111     const vertical = font.vertical;
2112     const spacingDir = vertical ? 1 : -1;
2113     const defaultVMetrics = font.defaultVMetrics;
2114     const widthAdvanceScale = fontSize * current.fontMatrix[0];
2115 
2116     const simpleFillText =
2117       current.textRenderingMode === TextRenderingMode.FILL &&
2118       !font.disableFontFace &&
2119       !current.patternFill;
2120 
2121     ctx.save();
2122     ctx.transform(...current.textMatrix);
2123     ctx.translate(current.x, current.y + current.textRise);
2124 
2125     if (fontDirection > 0) {
2126       ctx.scale(textHScale, -1);
2127     } else {
2128       ctx.scale(textHScale, 1);
2129     }
2130 
2131     let patternTransform;
2132     if (current.patternFill) {
2133       ctx.save();
2134       const pattern = current.fillColor.getPattern(
2135         ctx,
2136         this,
2137         getCurrentTransformInverse(ctx),
2138         PathType.FILL
2139       );
2140       patternTransform = getCurrentTransform(ctx);
2141       ctx.restore();
2142       ctx.fillStyle = pattern;
2143     }
2144 
2145     let lineWidth = current.lineWidth;
2146     const scale = current.textMatrixScale;
2147     if (scale === 0 || lineWidth === 0) {
2148       const fillStrokeMode =
2149         current.textRenderingMode & TextRenderingMode.FILL_STROKE_MASK;
2150       if (
2151         fillStrokeMode === TextRenderingMode.STROKE ||
2152         fillStrokeMode === TextRenderingMode.FILL_STROKE
2153       ) {
2154         lineWidth = this.getSinglePixelWidth();
2155       }
2156     } else {
2157       lineWidth /= scale;
2158     }
2159 
2160     if (fontSizeScale !== 1.0) {
2161       ctx.scale(fontSizeScale, fontSizeScale);
2162       lineWidth /= fontSizeScale;
2163     }
2164 
2165     ctx.lineWidth = lineWidth;
2166 
2167     if (font.isInvalidPDFjsFont) {
2168       const chars = [];
2169       let width = 0;
2170       for (const glyph of glyphs) {
2171         chars.push(glyph.unicode);
2172         width += glyph.width;
2173       }
2174       ctx.fillText(chars.join(""), 0, 0);
2175       current.x += width * widthAdvanceScale * textHScale;
2176       ctx.restore();
2177       this.compose();
2178 
2179       return undefined;
2180     }
2181 
2182     let x = 0,
2183       i;
2184     for (i = 0; i < glyphsLength; ++i) {
2185       const glyph = glyphs[i];
2186       if (typeof glyph === "number") {
2187         x += (spacingDir * glyph * fontSize) / 1000;
2188         continue;
2189       }
2190 
2191       let restoreNeeded = false;
2192       const spacing = (glyph.isSpace ? wordSpacing : 0) + charSpacing;
2193       const character = glyph.fontChar;
2194       const accent = glyph.accent;
2195       let scaledX, scaledY;
2196       let width = glyph.width;
2197       if (vertical) {
2198         const vmetric = glyph.vmetric || defaultVMetrics;
2199         const vx =
2200           -(glyph.vmetric ? vmetric[1] : width * 0.5) * widthAdvanceScale;
2201         const vy = vmetric[2] * widthAdvanceScale;
2202 
2203         width = vmetric ? -vmetric[0] : width;
2204         scaledX = vx / fontSizeScale;
2205         scaledY = (x + vy) / fontSizeScale;
2206       } else {
2207         scaledX = x / fontSizeScale;
2208         scaledY = 0;
2209       }
2210 
2211       if (font.remeasure && width > 0) {
2212         // Some standard fonts may not have the exact width: rescale per
2213         // character if measured width is greater than expected glyph width
2214         // and subpixel-aa is enabled, otherwise just center the glyph.
2215         const measuredWidth =
2216           ((ctx.measureText(character).width * 1000) / fontSize) *
2217           fontSizeScale;
2218         if (width < measuredWidth && this.isFontSubpixelAAEnabled) {
2219           const characterScaleX = width / measuredWidth;
2220           restoreNeeded = true;
2221           ctx.save();
2222           ctx.scale(characterScaleX, 1);
2223           scaledX /= characterScaleX;
2224         } else if (width !== measuredWidth) {
2225           scaledX +=
2226             (((width - measuredWidth) / 2000) * fontSize) / fontSizeScale;
2227         }
2228       }
2229 
2230       // Only attempt to draw the glyph if it is actually in the embedded font
2231       // file or if there isn't a font file so the fallback font is shown.
2232       if (this.contentVisible && (glyph.isInFont || font.missingFile)) {
2233         if (simpleFillText && !accent) {
2234           // common case
2235           ctx.fillText(character, scaledX, scaledY);
2236         } else {
2237           this.paintChar(character, scaledX, scaledY, patternTransform);
2238           if (accent) {
2239             const scaledAccentX =
2240               scaledX + (fontSize * accent.offset.x) / fontSizeScale;
2241             const scaledAccentY =
2242               scaledY - (fontSize * accent.offset.y) / fontSizeScale;
2243             this.paintChar(
2244               accent.fontChar,
2245               scaledAccentX,
2246               scaledAccentY,
2247               patternTransform
2248             );
2249           }
2250         }
2251       }
2252 
2253       const charWidth = vertical
2254         ? width * widthAdvanceScale - spacing * fontDirection
2255         : width * widthAdvanceScale + spacing * fontDirection;
2256       x += charWidth;
2257 
2258       if (restoreNeeded) {
2259         ctx.restore();
2260       }
2261     }
2262     if (vertical) {
2263       current.y -= x;
2264     } else {
2265       current.x += x * textHScale;
2266     }
2267     ctx.restore();
2268     this.compose();
2269 
2270     return undefined;
2271   }
2272 
2273   showType3Text(glyphs) {
2274     // Type3 fonts - each glyph is a "mini-PDF"
2275     const ctx = this.ctx;
2276     const current = this.current;
2277     const font = current.font;
2278     const fontSize = current.fontSize;
2279     const fontDirection = current.fontDirection;
2280     const spacingDir = font.vertical ? 1 : -1;
2281     const charSpacing = current.charSpacing;
2282     const wordSpacing = current.wordSpacing;
2283     const textHScale = current.textHScale * fontDirection;
2284     const fontMatrix = current.fontMatrix || FONT_IDENTITY_MATRIX;
2285     const glyphsLength = glyphs.length;
2286     const isTextInvisible =
2287       current.textRenderingMode === TextRenderingMode.INVISIBLE;
2288     let i, glyph, width, spacingLength;
2289 
2290     if (isTextInvisible || fontSize === 0) {
2291       return;
2292     }
2293     this._cachedScaleForStroking[0] = -1;
2294     this._cachedGetSinglePixelWidth = null;
2295 
2296     ctx.save();
2297     ctx.transform(...current.textMatrix);
2298     ctx.translate(current.x, current.y);
2299 
2300     ctx.scale(textHScale, fontDirection);
2301 
2302     for (i = 0; i < glyphsLength; ++i) {
2303       glyph = glyphs[i];
2304       if (typeof glyph === "number") {
2305         spacingLength = (spacingDir * glyph * fontSize) / 1000;
2306         this.ctx.translate(spacingLength, 0);
2307         current.x += spacingLength * textHScale;
2308         continue;
2309       }
2310 
2311       const spacing = (glyph.isSpace ? wordSpacing : 0) + charSpacing;
2312       const operatorList = font.charProcOperatorList[glyph.operatorListId];
2313       if (!operatorList) {
2314         warn(`Type3 character "${glyph.operatorListId}" is not available.`);
2315         continue;
2316       }
2317       if (this.contentVisible) {
2318         this.processingType3 = glyph;
2319         this.save();
2320         ctx.scale(fontSize, fontSize);
2321         ctx.transform(...fontMatrix);
2322         this.executeOperatorList(operatorList);
2323         this.restore();
2324       }
2325 
2326       const transformed = Util.applyTransform([glyph.width, 0], fontMatrix);
2327       width = transformed[0] * fontSize + spacing;
2328 
2329       ctx.translate(width, 0);
2330       current.x += width * textHScale;
2331     }
2332     ctx.restore();
2333     this.processingType3 = null;
2334   }
2335 
2336   // Type3 fonts
2337   setCharWidth(xWidth, yWidth) {
2338     // We can safely ignore this since the width should be the same
2339     // as the width in the Widths array.
2340   }
2341 
2342   setCharWidthAndBounds(xWidth, yWidth, llx, lly, urx, ury) {
2343     this.ctx.rect(llx, lly, urx - llx, ury - lly);
2344     this.ctx.clip();
2345     this.endPath();
2346   }
2347 
2348   // Color
2349   getColorN_Pattern(IR) {
2350     let pattern;
2351     if (IR[0] === "TilingPattern") {
2352       const color = IR[1];
2353       const baseTransform = this.baseTransform || getCurrentTransform(this.ctx);
2354       const canvasGraphicsFactory = {
2355         createCanvasGraphics: ctx =>
2356           new CanvasGraphics(
2357             ctx,
2358             this.commonObjs,
2359             this.objs,
2360             this.canvasFactory,
2361             this.filterFactory,
2362             {
2363               optionalContentConfig: this.optionalContentConfig,
2364               markedContentStack: this.markedContentStack,
2365             }
2366           ),
2367       };
2368       pattern = new TilingPattern(
2369         IR,
2370         color,
2371         this.ctx,
2372         canvasGraphicsFactory,
2373         baseTransform
2374       );
2375     } else {
2376       pattern = this._getPattern(IR[1], IR[2]);
2377     }
2378     return pattern;
2379   }
2380 
2381   setStrokeColorN() {
2382     this.current.strokeColor = this.getColorN_Pattern(arguments);
2383   }
2384 
2385   setFillColorN() {
2386     this.current.fillColor = this.getColorN_Pattern(arguments);
2387     this.current.patternFill = true;
2388   }
2389 
2390   setStrokeRGBColor(r, g, b) {
2391     this.ctx.strokeStyle = this.current.strokeColor = Util.makeHexColor(
2392       r,
2393       g,
2394       b
2395     );
2396   }
2397 
2398   setStrokeTransparent() {
2399     this.ctx.strokeStyle = this.current.strokeColor = "transparent";
2400   }
2401 
2402   setFillRGBColor(r, g, b) {
2403     this.ctx.fillStyle = this.current.fillColor = Util.makeHexColor(r, g, b);
2404     this.current.patternFill = false;
2405   }
2406 
2407   setFillTransparent() {
2408     this.ctx.fillStyle = this.current.fillColor = "transparent";
2409     this.current.patternFill = false;
2410   }
2411 
2412   _getPattern(objId, matrix = null) {
2413     let pattern;
2414     if (this.cachedPatterns.has(objId)) {
2415       pattern = this.cachedPatterns.get(objId);
2416     } else {
2417       pattern = getShadingPattern(this.getObject(objId));
2418       this.cachedPatterns.set(objId, pattern);
2419     }
2420     if (matrix) {
2421       pattern.matrix = matrix;
2422     }
2423     return pattern;
2424   }
2425 
2426   shadingFill(objId) {
2427     if (!this.contentVisible) {
2428       return;
2429     }
2430     const ctx = this.ctx;
2431 
2432     this.save();
2433     const pattern = this._getPattern(objId);
2434     ctx.fillStyle = pattern.getPattern(
2435       ctx,
2436       this,
2437       getCurrentTransformInverse(ctx),
2438       PathType.SHADING
2439     );
2440 
2441     const inv = getCurrentTransformInverse(ctx);
2442     if (inv) {
2443       const { width, height } = ctx.canvas;
2444       const [x0, y0, x1, y1] = Util.getAxialAlignedBoundingBox(
2445         [0, 0, width, height],
2446         inv
2447       );
2448 
2449       this.ctx.fillRect(x0, y0, x1 - x0, y1 - y0);
2450     } else {
2451       // HACK to draw the gradient onto an infinite rectangle.
2452       // PDF gradients are drawn across the entire image while
2453       // Canvas only allows gradients to be drawn in a rectangle
2454       // The following bug should allow us to remove this.
2455       // https://bugzilla.mozilla.org/show_bug.cgi?id=664884
2456 
2457       this.ctx.fillRect(-1e10, -1e10, 2e10, 2e10);
2458     }
2459 
2460     this.compose(this.current.getClippedPathBoundingBox());
2461     this.restore();
2462   }
2463 
2464   // Images
2465   beginInlineImage() {
2466     unreachable("Should not call beginInlineImage");
2467   }
2468 
2469   beginImageData() {
2470     unreachable("Should not call beginImageData");
2471   }
2472 
2473   paintFormXObjectBegin(matrix, bbox) {
2474     if (!this.contentVisible) {
2475       return;
2476     }
2477     this.save();
2478     this.baseTransformStack.push(this.baseTransform);
2479 
2480     if (matrix) {
2481       this.transform(...matrix);
2482     }
2483     this.baseTransform = getCurrentTransform(this.ctx);
2484 
2485     if (bbox) {
2486       const width = bbox[2] - bbox[0];
2487       const height = bbox[3] - bbox[1];
2488       this.ctx.rect(bbox[0], bbox[1], width, height);
2489       this.current.updateRectMinMax(getCurrentTransform(this.ctx), bbox);
2490       this.clip();
2491       this.endPath();
2492     }
2493   }
2494 
2495   paintFormXObjectEnd() {
2496     if (!this.contentVisible) {
2497       return;
2498     }
2499     this.restore();
2500     this.baseTransform = this.baseTransformStack.pop();
2501   }
2502 
2503   beginGroup(group) {
2504     if (!this.contentVisible) {
2505       return;
2506     }
2507 
2508     this.save();
2509     // If there's an active soft mask we don't want it enabled for the group, so
2510     // clear it out. The mask and suspended canvas will be restored in endGroup.
2511     if (this.inSMaskMode) {
2512       this.endSMaskMode();
2513       this.current.activeSMask = null;
2514     }
2515 
2516     const currentCtx = this.ctx;
2517     // TODO non-isolated groups - according to Rik at adobe non-isolated
2518     // group results aren't usually that different and they even have tools
2519     // that ignore this setting. Notes from Rik on implementing:
2520     // - When you encounter an transparency group, create a new canvas with
2521     // the dimensions of the bbox
2522     // - copy the content from the previous canvas to the new canvas
2523     // - draw as usual
2524     // - remove the backdrop alpha:
2525     // alphaNew = 1 - (1 - alpha)/(1 - alphaBackdrop) with 'alpha' the alpha
2526     // value of your transparency group and 'alphaBackdrop' the alpha of the
2527     // backdrop
2528     // - remove background color:
2529     // colorNew = color - alphaNew *colorBackdrop /(1 - alphaNew)
2530     if (!group.isolated) {
2531       info("TODO: Support non-isolated groups.");
2532     }
2533 
2534     // TODO knockout - supposedly possible with the clever use of compositing
2535     // modes.
2536     if (group.knockout) {
2537       warn("Knockout groups not supported.");
2538     }
2539 
2540     const currentTransform = getCurrentTransform(currentCtx);
2541     if (group.matrix) {
2542       currentCtx.transform(...group.matrix);
2543     }
2544     if (!group.bbox) {
2545       throw new Error("Bounding box is required.");
2546     }
2547 
2548     // Based on the current transform figure out how big the bounding box
2549     // will actually be.
2550     let bounds = Util.getAxialAlignedBoundingBox(
2551       group.bbox,
2552       getCurrentTransform(currentCtx)
2553     );
2554     // Clip the bounding box to the current canvas.
2555     const canvasBounds = [
2556       0,
2557       0,
2558       currentCtx.canvas.width,
2559       currentCtx.canvas.height,
2560     ];
2561     bounds = Util.intersect(bounds, canvasBounds) || [0, 0, 0, 0];
2562     // Use ceil in case we're between sizes so we don't create canvas that is
2563     // too small and make the canvas at least 1x1 pixels.
2564     const offsetX = Math.floor(bounds[0]);
2565     const offsetY = Math.floor(bounds[1]);
2566     const drawnWidth = Math.max(Math.ceil(bounds[2]) - offsetX, 1);
2567     const drawnHeight = Math.max(Math.ceil(bounds[3]) - offsetY, 1);
2568 
2569     this.current.startNewPathAndClipBox([0, 0, drawnWidth, drawnHeight]);
2570 
2571     let cacheId = "groupAt" + this.groupLevel;
2572     if (group.smask) {
2573       // Using two cache entries is case if masks are used one after another.
2574       cacheId += "_smask_" + (this.smaskCounter++ % 2);
2575     }
2576     const scratchCanvas = this.cachedCanvases.getCanvas(
2577       cacheId,
2578       drawnWidth,
2579       drawnHeight
2580     );
2581     const groupCtx = scratchCanvas.context;
2582 
2583     // Since we created a new canvas that is just the size of the bounding box
2584     // we have to translate the group ctx.
2585     groupCtx.translate(-offsetX, -offsetY);
2586     groupCtx.transform(...currentTransform);
2587 
2588     if (group.smask) {
2589       // Saving state and cached mask to be used in setGState.
2590       this.smaskStack.push({
2591         canvas: scratchCanvas.canvas,
2592         context: groupCtx,
2593         offsetX,
2594         offsetY,
2595         subtype: group.smask.subtype,
2596         backdrop: group.smask.backdrop,
2597         transferMap: group.smask.transferMap || null,
2598         startTransformInverse: null, // used during suspend operation
2599       });
2600     } else {
2601       // Setup the current ctx so when the group is popped we draw it at the
2602       // right location.
2603       currentCtx.setTransform(1, 0, 0, 1, 0, 0);
2604       currentCtx.translate(offsetX, offsetY);
2605       currentCtx.save();
2606     }
2607     // The transparency group inherits all off the current graphics state
2608     // except the blend mode, soft mask, and alpha constants.
2609     copyCtxState(currentCtx, groupCtx);
2610     this.ctx = groupCtx;
2611     this.setGState([
2612       ["BM", "source-over"],
2613       ["ca", 1],
2614       ["CA", 1],
2615     ]);
2616     this.groupStack.push(currentCtx);
2617     this.groupLevel++;
2618   }
2619 
2620   endGroup(group) {
2621     if (!this.contentVisible) {
2622       return;
2623     }
2624     this.groupLevel--;
2625     const groupCtx = this.ctx;
2626     const ctx = this.groupStack.pop();
2627     this.ctx = ctx;
2628     // Turn off image smoothing to avoid sub pixel interpolation which can
2629     // look kind of blurry for some pdfs.
2630     this.ctx.imageSmoothingEnabled = false;
2631 
2632     if (group.smask) {
2633       this.tempSMask = this.smaskStack.pop();
2634       this.restore();
2635     } else {
2636       this.ctx.restore();
2637       const currentMtx = getCurrentTransform(this.ctx);
2638       this.restore();
2639       this.ctx.save();
2640       this.ctx.setTransform(...currentMtx);
2641       const dirtyBox = Util.getAxialAlignedBoundingBox(
2642         [0, 0, groupCtx.canvas.width, groupCtx.canvas.height],
2643         currentMtx
2644       );
2645       this.ctx.drawImage(groupCtx.canvas, 0, 0);
2646       this.ctx.restore();
2647       this.compose(dirtyBox);
2648     }
2649   }
2650 
2651   beginAnnotation(id, rect, transform, matrix, hasOwnCanvas) {
2652     // The annotations are drawn just after the page content.
2653     // The page content drawing can potentially have set a transform,
2654     // a clipping path, whatever...
2655     // So in order to have something clean, we restore the initial state.
2656     this.#restoreInitialState();
2657     resetCtxToDefault(this.ctx);
2658 
2659     this.ctx.save();
2660     this.save();
2661 
2662     if (this.baseTransform) {
2663       this.ctx.setTransform(...this.baseTransform);
2664     }
2665 
2666     if (rect) {
2667       const width = rect[2] - rect[0];
2668       const height = rect[3] - rect[1];
2669 
2670       if (hasOwnCanvas && this.annotationCanvasMap) {
2671         transform = transform.slice();
2672         transform[4] -= rect[0];
2673         transform[5] -= rect[1];
2674 
2675         rect = rect.slice();
2676         rect[0] = rect[1] = 0;
2677         rect[2] = width;
2678         rect[3] = height;
2679 
2680         const [scaleX, scaleY] = Util.singularValueDecompose2dScale(
2681           getCurrentTransform(this.ctx)
2682         );
2683         const { viewportScale } = this;
2684         const canvasWidth = Math.ceil(
2685           width * this.outputScaleX * viewportScale
2686         );
2687         const canvasHeight = Math.ceil(
2688           height * this.outputScaleY * viewportScale
2689         );
2690 
2691         this.annotationCanvas = this.canvasFactory.create(
2692           canvasWidth,
2693           canvasHeight
2694         );
2695         const { canvas, context } = this.annotationCanvas;
2696         this.annotationCanvasMap.set(id, canvas);
2697         this.annotationCanvas.savedCtx = this.ctx;
2698         this.ctx = context;
2699         this.ctx.save();
2700         this.ctx.setTransform(scaleX, 0, 0, -scaleY, 0, height * scaleY);
2701 
2702         resetCtxToDefault(this.ctx);
2703       } else {
2704         resetCtxToDefault(this.ctx);
2705 
2706         // Consume a potential path before clipping.
2707         this.endPath();
2708 
2709         this.ctx.rect(rect[0], rect[1], width, height);
2710         this.ctx.clip();
2711         this.ctx.beginPath();
2712       }
2713     }
2714 
2715     this.current = new CanvasExtraState(
2716       this.ctx.canvas.width,
2717       this.ctx.canvas.height
2718     );
2719 
2720     this.transform(...transform);
2721     this.transform(...matrix);
2722   }
2723 
2724   endAnnotation() {
2725     if (this.annotationCanvas) {
2726       this.ctx.restore();
2727       this.#drawFilter();
2728 
2729       this.ctx = this.annotationCanvas.savedCtx;
2730       delete this.annotationCanvas.savedCtx;
2731       delete this.annotationCanvas;
2732     }
2733   }
2734 
2735   paintImageMaskXObject(img) {
2736     if (!this.contentVisible) {
2737       return;
2738     }
2739     const count = img.count;
2740     img = this.getObject(img.data, img);
2741     img.count = count;
2742 
2743     const ctx = this.ctx;
2744     const glyph = this.processingType3;
2745 
2746     if (glyph) {
2747       if (glyph.compiled === undefined) {
2748         glyph.compiled = compileType3Glyph(img);
2749       }
2750 
2751       if (glyph.compiled) {
2752         glyph.compiled(ctx);
2753         return;
2754       }
2755     }
2756     const mask = this._createMaskCanvas(img);
2757     const maskCanvas = mask.canvas;
2758 
2759     ctx.save();
2760     // The mask is drawn with the transform applied. Reset the current
2761     // transform to draw to the identity.
2762     ctx.setTransform(1, 0, 0, 1, 0, 0);
2763     ctx.drawImage(maskCanvas, mask.offsetX, mask.offsetY);
2764     ctx.restore();
2765     this.compose();
2766   }
2767 
2768   paintImageMaskXObjectRepeat(
2769     img,
2770     scaleX,
2771     skewX = 0,
2772     skewY = 0,
2773     scaleY,
2774     positions
2775   ) {
2776     if (!this.contentVisible) {
2777       return;
2778     }
2779 
2780     img = this.getObject(img.data, img);
2781 
2782     const ctx = this.ctx;
2783     ctx.save();
2784     const currentTransform = getCurrentTransform(ctx);
2785     ctx.transform(scaleX, skewX, skewY, scaleY, 0, 0);
2786     const mask = this._createMaskCanvas(img);
2787 
2788     ctx.setTransform(
2789       1,
2790       0,
2791       0,
2792       1,
2793       mask.offsetX - currentTransform[4],
2794       mask.offsetY - currentTransform[5]
2795     );
2796     for (let i = 0, ii = positions.length; i < ii; i += 2) {
2797       const trans = Util.transform(currentTransform, [
2798         scaleX,
2799         skewX,
2800         skewY,
2801         scaleY,
2802         positions[i],
2803         positions[i + 1],
2804       ]);
2805 
2806       const [x, y] = Util.applyTransform([0, 0], trans);
2807       ctx.drawImage(mask.canvas, x, y);
2808     }
2809     ctx.restore();
2810     this.compose();
2811   }
2812 
2813   paintImageMaskXObjectGroup(images) {
2814     if (!this.contentVisible) {
2815       return;
2816     }
2817     const ctx = this.ctx;
2818 
2819     const fillColor = this.current.fillColor;
2820     const isPatternFill = this.current.patternFill;
2821 
2822     for (const image of images) {
2823       const { data, width, height, transform } = image;
2824 
2825       const maskCanvas = this.cachedCanvases.getCanvas(
2826         "maskCanvas",
2827         width,
2828         height
2829       );
2830       const maskCtx = maskCanvas.context;
2831       maskCtx.save();
2832 
2833       const img = this.getObject(data, image);
2834       putBinaryImageMask(maskCtx, img);
2835 
2836       maskCtx.globalCompositeOperation = "source-in";
2837 
2838       maskCtx.fillStyle = isPatternFill
2839         ? fillColor.getPattern(
2840             maskCtx,
2841             this,
2842             getCurrentTransformInverse(ctx),
2843             PathType.FILL
2844           )
2845         : fillColor;
2846       maskCtx.fillRect(0, 0, width, height);
2847 
2848       maskCtx.restore();
2849 
2850       ctx.save();
2851       ctx.transform(...transform);
2852       ctx.scale(1, -1);
2853       drawImageAtIntegerCoords(
2854         ctx,
2855         maskCanvas.canvas,
2856         0,
2857         0,
2858         width,
2859         height,
2860         0,
2861         -1,
2862         1,
2863         1
2864       );
2865       ctx.restore();
2866     }
2867     this.compose();
2868   }
2869 
2870   paintImageXObject(objId) {
2871     if (!this.contentVisible) {
2872       return;
2873     }
2874     const imgData = this.getObject(objId);
2875     if (!imgData) {
2876       warn("Dependent image isn't ready yet");
2877       return;
2878     }
2879 
2880     this.paintInlineImageXObject(imgData);
2881   }
2882 
2883   paintImageXObjectRepeat(objId, scaleX, scaleY, positions) {
2884     if (!this.contentVisible) {
2885       return;
2886     }
2887     const imgData = this.getObject(objId);
2888     if (!imgData) {
2889       warn("Dependent image isn't ready yet");
2890       return;
2891     }
2892 
2893     const width = imgData.width;
2894     const height = imgData.height;
2895     const map = [];
2896     for (let i = 0, ii = positions.length; i < ii; i += 2) {
2897       map.push({
2898         transform: [scaleX, 0, 0, scaleY, positions[i], positions[i + 1]],
2899         x: 0,
2900         y: 0,
2901         w: width,
2902         h: height,
2903       });
2904     }
2905     this.paintInlineImageXObjectGroup(imgData, map);
2906   }
2907 
2908   applyTransferMapsToCanvas(ctx) {
2909     if (this.current.transferMaps !== "none") {
2910       ctx.filter = this.current.transferMaps;
2911       ctx.drawImage(ctx.canvas, 0, 0);
2912       ctx.filter = "none";
2913     }
2914     return ctx.canvas;
2915   }
2916 
2917   applyTransferMapsToBitmap(imgData) {
2918     if (this.current.transferMaps === "none") {
2919       return imgData.bitmap;
2920     }
2921     const { bitmap, width, height } = imgData;
2922     const tmpCanvas = this.cachedCanvases.getCanvas(
2923       "inlineImage",
2924       width,
2925       height
2926     );
2927     const tmpCtx = tmpCanvas.context;
2928     tmpCtx.filter = this.current.transferMaps;
2929     tmpCtx.drawImage(bitmap, 0, 0);
2930     tmpCtx.filter = "none";
2931 
2932     return tmpCanvas.canvas;
2933   }
2934 
2935   paintInlineImageXObject(imgData) {
2936     if (!this.contentVisible) {
2937       return;
2938     }
2939     const width = imgData.width;
2940     const height = imgData.height;
2941     const ctx = this.ctx;
2942 
2943     this.save();
2944 
2945     if (
2946       (typeof PDFJSDev !== "undefined" && PDFJSDev.test("MOZCENTRAL")) ||
2947       !isNodeJS
2948     ) {
2949       // The filter, if any, will be applied in applyTransferMapsToBitmap.
2950       // It must be applied to the image before rescaling else some artifacts
2951       // could appear.
2952       // The final restore will reset it to its value.
2953       const { filter } = ctx;
2954       if (filter !== "none" && filter !== "") {
2955         ctx.filter = "none";
2956       }
2957     }
2958 
2959     // scale the image to the unit square
2960     ctx.scale(1 / width, -1 / height);
2961 
2962     let imgToPaint;
2963     if (imgData.bitmap) {
2964       imgToPaint = this.applyTransferMapsToBitmap(imgData);
2965     } else if (
2966       (typeof HTMLElement === "function" && imgData instanceof HTMLElement) ||
2967       !imgData.data
2968     ) {
2969       // typeof check is needed due to node.js support, see issue #8489
2970       imgToPaint = imgData;
2971     } else {
2972       const tmpCanvas = this.cachedCanvases.getCanvas(
2973         "inlineImage",
2974         width,
2975         height
2976       );
2977       const tmpCtx = tmpCanvas.context;
2978       putBinaryImageData(tmpCtx, imgData);
2979       imgToPaint = this.applyTransferMapsToCanvas(tmpCtx);
2980     }
2981 
2982     const scaled = this._scaleImage(
2983       imgToPaint,
2984       getCurrentTransformInverse(ctx)
2985     );
2986     ctx.imageSmoothingEnabled = getImageSmoothingEnabled(
2987       getCurrentTransform(ctx),
2988       imgData.interpolate
2989     );
2990 
2991     drawImageAtIntegerCoords(
2992       ctx,
2993       scaled.img,
2994       0,
2995       0,
2996       scaled.paintWidth,
2997       scaled.paintHeight,
2998       0,
2999       -height,
3000       width,
3001       height
3002     );
3003     this.compose();
3004     this.restore();
3005   }
3006 
3007   paintInlineImageXObjectGroup(imgData, map) {
3008     if (!this.contentVisible) {
3009       return;
3010     }
3011     const ctx = this.ctx;
3012     let imgToPaint;
3013     if (imgData.bitmap) {
3014       imgToPaint = imgData.bitmap;
3015     } else {
3016       const w = imgData.width;
3017       const h = imgData.height;
3018 
3019       const tmpCanvas = this.cachedCanvases.getCanvas("inlineImage", w, h);
3020       const tmpCtx = tmpCanvas.context;
3021       putBinaryImageData(tmpCtx, imgData);
3022       imgToPaint = this.applyTransferMapsToCanvas(tmpCtx);
3023     }
3024 
3025     for (const entry of map) {
3026       ctx.save();
3027       ctx.transform(...entry.transform);
3028       ctx.scale(1, -1);
3029       drawImageAtIntegerCoords(
3030         ctx,
3031         imgToPaint,
3032         entry.x,
3033         entry.y,
3034         entry.w,
3035         entry.h,
3036         0,
3037         -1,
3038         1,
3039         1
3040       );
3041       ctx.restore();
3042     }
3043     this.compose();
3044   }
3045 
3046   paintSolidColorImageMask() {
3047     if (!this.contentVisible) {
3048       return;
3049     }
3050     this.ctx.fillRect(0, 0, 1, 1);
3051     this.compose();
3052   }
3053 
3054   // Marked content
3055 
3056   markPoint(tag) {
3057     // TODO Marked content.
3058   }
3059 
3060   markPointProps(tag, properties) {
3061     // TODO Marked content.
3062   }
3063 
3064   beginMarkedContent(tag) {
3065     this.markedContentStack.push({
3066       visible: true,
3067     });
3068   }
3069 
3070   beginMarkedContentProps(tag, properties) {
3071     if (tag === "OC") {
3072       this.markedContentStack.push({
3073         visible: this.optionalContentConfig.isVisible(properties),
3074       });
3075     } else {
3076       this.markedContentStack.push({
3077         visible: true,
3078       });
3079     }
3080     this.contentVisible = this.isContentVisible();
3081   }
3082 
3083   endMarkedContent() {
3084     this.markedContentStack.pop();
3085     this.contentVisible = this.isContentVisible();
3086   }
3087 
3088   // Compatibility
3089 
3090   beginCompat() {
3091     // TODO ignore undefined operators (should we do that anyway?)
3092   }
3093 
3094   endCompat() {
3095     // TODO stop ignoring undefined operators
3096   }
3097 
3098   // Helper functions
3099 
3100   consumePath(clipBox) {
3101     const isEmpty = this.current.isEmptyClip();
3102     if (this.pendingClip) {
3103       this.current.updateClipFromPath();
3104     }
3105     if (!this.pendingClip) {
3106       this.compose(clipBox);
3107     }
3108     const ctx = this.ctx;
3109     if (this.pendingClip) {
3110       if (!isEmpty) {
3111         if (this.pendingClip === EO_CLIP) {
3112           ctx.clip("evenodd");
3113         } else {
3114           ctx.clip();
3115         }
3116       }
3117       this.pendingClip = null;
3118     }
3119     this.current.startNewPathAndClipBox(this.current.clipBox);
3120     ctx.beginPath();
3121   }
3122 
3123   getSinglePixelWidth() {
3124     if (!this._cachedGetSinglePixelWidth) {
3125       const m = getCurrentTransform(this.ctx);
3126       if (m[1] === 0 && m[2] === 0) {
3127         // Fast path
3128         this._cachedGetSinglePixelWidth =
3129           1 / Math.min(Math.abs(m[0]), Math.abs(m[3]));
3130       } else {
3131         const absDet = Math.abs(m[0] * m[3] - m[2] * m[1]);
3132         const normX = Math.hypot(m[0], m[2]);
3133         const normY = Math.hypot(m[1], m[3]);
3134         this._cachedGetSinglePixelWidth = Math.max(normX, normY) / absDet;
3135       }
3136     }
3137     return this._cachedGetSinglePixelWidth;
3138   }
3139 
3140   getScaleForStroking() {
3141     // A pixel has thicknessX = thicknessY = 1;
3142     // A transformed pixel is a parallelogram and the thicknesses
3143     // corresponds to the heights.
3144     // The goal of this function is to rescale before setting the
3145     // lineWidth in order to have both thicknesses greater or equal
3146     // to 1 after transform.
3147     if (this._cachedScaleForStroking[0] === -1) {
3148       const { lineWidth } = this.current;
3149       const { a, b, c, d } = this.ctx.getTransform();
3150       let scaleX, scaleY;
3151 
3152       if (b === 0 && c === 0) {
3153         // Fast path
3154         const normX = Math.abs(a);
3155         const normY = Math.abs(d);
3156         if (normX === normY) {
3157           if (lineWidth === 0) {
3158             scaleX = scaleY = 1 / normX;
3159           } else {
3160             const scaledLineWidth = normX * lineWidth;
3161             scaleX = scaleY = scaledLineWidth < 1 ? 1 / scaledLineWidth : 1;
3162           }
3163         } else if (lineWidth === 0) {
3164           scaleX = 1 / normX;
3165           scaleY = 1 / normY;
3166         } else {
3167           const scaledXLineWidth = normX * lineWidth;
3168           const scaledYLineWidth = normY * lineWidth;
3169           scaleX = scaledXLineWidth < 1 ? 1 / scaledXLineWidth : 1;
3170           scaleY = scaledYLineWidth < 1 ? 1 / scaledYLineWidth : 1;
3171         }
3172       } else {
3173         // A pixel (base (x, y)) is transformed by M into a parallelogram:
3174         //  - its area is |det(M)|;
3175         //  - heightY (orthogonal to Mx) has a length: |det(M)| / norm(Mx);
3176         //  - heightX (orthogonal to My) has a length: |det(M)| / norm(My).
3177         // heightX and heightY are the thicknesses of the transformed pixel
3178         // and they must be both greater or equal to 1.
3179         const absDet = Math.abs(a * d - b * c);
3180         const normX = Math.hypot(a, b);
3181         const normY = Math.hypot(c, d);
3182         if (lineWidth === 0) {
3183           scaleX = normY / absDet;
3184           scaleY = normX / absDet;
3185         } else {
3186           const baseArea = lineWidth * absDet;
3187           scaleX = normY > baseArea ? normY / baseArea : 1;
3188           scaleY = normX > baseArea ? normX / baseArea : 1;
3189         }
3190       }
3191       this._cachedScaleForStroking[0] = scaleX;
3192       this._cachedScaleForStroking[1] = scaleY;
3193     }
3194     return this._cachedScaleForStroking;
3195   }
3196 
3197   // Rescale before stroking in order to have a final lineWidth
3198   // with both thicknesses greater or equal to 1.
3199   rescaleAndStroke(saveRestore) {
3200     const { ctx } = this;
3201     const { lineWidth } = this.current;
3202     const [scaleX, scaleY] = this.getScaleForStroking();
3203 
3204     ctx.lineWidth = lineWidth || 1;
3205 
3206     if (scaleX === 1 && scaleY === 1) {
3207       ctx.stroke();
3208       return;
3209     }
3210 
3211     const dashes = ctx.getLineDash();
3212     if (saveRestore) {
3213       ctx.save();
3214     }
3215 
3216     ctx.scale(scaleX, scaleY);
3217 
3218     // How the dashed line is rendered depends on the current transform...
3219     // so we added a rescale to handle too thin lines and consequently
3220     // the way the line is dashed will be modified.
3221     // If scaleX === scaleY, the dashed lines will be rendered correctly
3222     // else we'll have some bugs (but only with too thin lines).
3223     // Here we take the max... why not taking the min... or something else.
3224     // Anyway, as said it's buggy when scaleX !== scaleY.
3225     if (dashes.length > 0) {
3226       const scale = Math.max(scaleX, scaleY);
3227       ctx.setLineDash(dashes.map(x => x / scale));
3228       ctx.lineDashOffset /= scale;
3229     }
3230 
3231     ctx.stroke();
3232 
3233     if (saveRestore) {
3234       ctx.restore();
3235     }
3236   }
3237 
3238   isContentVisible() {
3239     for (let i = this.markedContentStack.length - 1; i >= 0; i--) {
3240       if (!this.markedContentStack[i].visible) {
3241         return false;
3242       }
3243     }
3244     return true;
3245   }
3246 }
3247 
3248 for (const op in OPS) {
3249   if (CanvasGraphics.prototype[op] !== undefined) {
3250     CanvasGraphics.prototype[OPS[op]] = CanvasGraphics.prototype[op];
3251   }
3252 }
3253 
3254 export { CanvasGraphics };
</code>

Test file:
<test_file>
File:
test/unit/api_spec.js
/* Copyright 2017 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import {
  AnnotationEditorType,
  AnnotationMode,
  AnnotationType,
  ImageKind,
  InvalidPDFException,
  isNodeJS,
  MissingPDFException,
  objectSize,
  OPS,
  PasswordException,
  PasswordResponses,
  PermissionFlag,
  UnknownErrorException,
} from "../../src/shared/util.js";
import {
  buildGetDocumentParams,
  CMAP_URL,
  createTemporaryNodeServer,
  DefaultFileReaderFactory,
  TEST_PDFS_PATH,
} from "./test_utils.js";
import {
  DefaultCanvasFactory,
  getDocument,
  PDFDataRangeTransport,
  PDFDocumentLoadingTask,
  PDFDocumentProxy,
  PDFPageProxy,
  PDFWorker,
  RenderTask,
} from "../../src/display/api.js";
import {
  PageViewport,
  RenderingCancelledException,
  StatTimer,
} from "../../src/display/display_utils.js";
import { AutoPrintRegExp } from "../../web/ui_utils.js";
import { GlobalImageCache } from "../../src/core/image_utils.js";
import { GlobalWorkerOptions } from "../../src/display/worker_options.js";
import { Metadata } from "../../src/display/metadata.js";
const WORKER_SRC = "../../build/generic/build/pdf.worker.mjs";
</test_file>

Your task:
You are a software tester at pdf.js.
1. Examine the existing test file. You may reuse any imports, helpers or setup blocks it already has.
2. Write exactly one javascript test `it("...", async () => {...})` block.
3. Your test must fail on the code before the patch, and pass after, hence the test will verify that the patch resolves the issue.
4. The test must be self-contained and to-the-point.
5. If you need something new use only the provided imports (respect the paths exactly how they are given) by importing dynamically for compatibility with Node.js — no new dependencies. You can use the PDF file for testing as follows:
const { getDocument } = await import('../../src/display/api.js');
const { buildGetDocumentParams } = await import('./test_utils.js');
const loadingTask = getDocument(buildGetDocumentParams('issue18956.pdf'))
6. Return only the javascript code for the new `it(...)` block (no comments or explanations).

Example structure:
it("should <describe behavior>", async () => {
  const { example } = await import("../../src/core/example.js");
  <initialize required variables>;
  <define expected variable>;
  <generate actual variables>;
  <compare expected with actual>;
});

