Before you begin:
- Keep going until the job is completely solved — don’t stop halfway.
- If you’re unsure about the behavior, reread the provided patch carefully; do not hallucinate.
- Plan your approach before writing code by reflecting on whether the test truly fails before and passes after.

Issue:
<issue>
[Bug]: Certain text shows in the text layer but isn't rendered in canva behind it
### Attach (recommended) or Link to PDF file

[LUCID - Asif Rasha-1.pdf](https://github.com/user-attachments/files/17065251/LUCID.-.Asif.Rasha-1.pdf)


### Web browser and its version

Google Chrome Version 128.0.6613.138 (Official Build) (x86_64)

### Operating system and its version

Mac OS Sonoma 14.6

### PDF.js version

v4.6.82

### Is the bug present in the latest PDF.js version?

Yes

### Is a browser extension

No

### Steps to reproduce the problem

Open the attached pdf and check the text on the left box.

### What is the expected behavior?

This or something similar would ideally show up:
<img width="317" alt="Screenshot 2024-09-19 at 16 18 13" src="https://github.com/user-attachments/assets/ddb9f2d3-2b2e-4801-aaad-065a1a31d961">

### What went wrong?

This is what is rendered (text layer is present with the needed text, and, if transparent font color is disabled temporarily, the text can be seen exactly where it should be):
<img width="341" alt="Screenshot 2024-09-19 at 16 18 29" src="https://github.com/user-attachments/assets/21388a54-1cfc-4ae2-8f41-fa2f36f11da2">



### Link to a viewer

_No response_

### Additional context

_No response_
</issue>

PDF File:
<pdf>
issue18765.pdf
</pdf>

Patch:
<patch>
diff --git a/src/core/evaluator.js b/src/core/evaluator.js
--- a/src/core/evaluator.js
+++ b/src/core/evaluator.js
@@ -2132,14 +2132,26 @@ class PartialEvaluator {
             break;
 
           case OPS.shadingFill:
-            var shadingRes = resources.get("Shading");
-            if (!shadingRes) {
-              throw new FormatError("No shading resource found");
-            }
+            let shading;
+            try {
+              const shadingRes = resources.get("Shading");
+              if (!shadingRes) {
+                throw new FormatError("No shading resource found");
+              }
 
-            var shading = shadingRes.get(args[0].name);
-            if (!shading) {
-              throw new FormatError("No shading object found");
+              shading = shadingRes.get(args[0].name);
+              if (!shading) {
+                throw new FormatError("No shading object found");
+              }
+            } catch (reason) {
+              if (reason instanceof AbortException) {
+                continue;
+              }
+              if (self.options.ignoreErrors) {
+                warn(`getOperatorList - ignoring Shading: "${reason}".`);
+                continue;
+              }
+              throw reason;
             }
             const patternId = self.parseShading({
               shading,


</patch>

Imports:
<imports>
Available Packages
Dev Dependencies:
- @babel/core: ^7.25.2
- @babel/preset-env: ^7.25.4
- @babel/runtime: ^7.25.6
- @fluent/bundle: ^0.18.0
- @fluent/dom: ^0.10.0
- @jazzer.js/core: ^2.1.0
- @metalsmith/layouts: ^2.7.0
- @metalsmith/markdown: ^1.10.0
- autoprefixer: ^10.4.20
- babel-loader: ^9.1.3
- caniuse-lite: ^1.0.30001658
- canvas: ^2.11.2
- core-js: ^3.38.1
- eslint: ^8.57.0
- eslint-config-prettier: ^9.1.0
- eslint-plugin-fetch-options: ^0.0.5
- eslint-plugin-html: ^8.1.1
- eslint-plugin-import: ^2.30.0
- eslint-plugin-jasmine: ^4.2.1
- eslint-plugin-json: ^3.1.0
- eslint-plugin-no-unsanitized: ^4.1.0
- eslint-plugin-prettier: ^5.2.1
- eslint-plugin-sort-exports: ^0.9.1
- eslint-plugin-unicorn: ^55.0.0
- gulp: ^5.0.0
- gulp-cli: ^3.0.0
- gulp-postcss: ^10.0.0
- gulp-rename: ^2.0.0
- gulp-replace: ^1.1.4
- gulp-zip: ^6.0.0
- highlight.js: ^11.10.0
- jasmine: ^5.3.0
- jsdoc: ^4.0.3
- jstransformer-nunjucks: ^1.2.0
- metalsmith: ^2.6.3
- metalsmith-html-relative: ^2.0.1
- ordered-read-streams: ^2.0.0
- path2d: ^0.2.1
- pngjs: ^7.0.0
- postcss: ^8.4.45
- postcss-dark-theme-class: ^1.3.0
- postcss-dir-pseudo-class: ^9.0.0
- postcss-discard-comments: ^7.0.3
- postcss-nesting: ^13.0.0
- prettier: ^3.3.3
- puppeteer: ^23.3.0
- stylelint: ^16.9.0
- stylelint-prettier: ^5.0.2
- svglint: ^3.0.0
- terser-webpack-plugin: ^5.3.10
- tsc-alias: ^1.8.10
- ttest: ^4.0.0
- typescript: ^5.5.4
- vinyl: ^3.0.0
- webpack: ^5.94.0
- webpack-stream: ^7.0.0
- yargs: ^17.7.2

Engines:
- node: >=18

Available Relative Imports:
- `../../src/core/annotation.js`: Annotation, AnnotationBorderStyle, AnnotationFactory, MarkupAnnotation, getQuadPoints
- `../../src/core/bidi.js`: bidi
- `../../src/core/cff_parser.js`: CFFCharset, CFFCompiler, CFFFDSelect, CFFParser, CFFStrings
- `../../src/core/cmap.js`: CMap, CMapFactory, IdentityCMap
- `../../src/core/colorspace.js`: ColorSpace
- `../../src/core/core_utils.js`: arrayBuffersToBytes, encodeToXmlString, escapePDFName, escapeString, getInheritableProperty, getSizeInBytes, isAscii, isWhiteSpace, log2, numberToString, parseXFAPath, recoverJsURL, stringToUTF16HexString, stringToUTF16String, toRomanNumerals, validateCSSFont
- `../../src/core/crypto.js`: AES128Cipher, AES256Cipher, ARCFourCipher, CipherTransformFactory, PDF17, PDF20, calculateMD5, calculateSHA256, calculateSHA384, calculateSHA512
- `../../src/core/default_appearance.js`: createDefaultAppearance, parseAppearanceStream, parseDefaultAppearance
- `../../src/core/document.js`: PDFDocument, Page
- `../../src/core/encodings.js`: getEncoding
- `../../src/core/evaluator.js`: PartialEvaluator
- `../../src/core/flate_stream.js`: FlateStream
- `../../src/core/font_substitutions.js`: getFontSubstitution
- `../../src/core/fonts_utils.js`: SEAC_ANALYSIS_ENABLED
- `../../src/core/function.js`: PDFFunctionFactory, PostScriptCompiler, PostScriptEvaluator
- `../../src/core/glyphlist.js`: getDingbatsGlyphsUnicode, getGlyphsUnicode
- `../../src/core/image_utils.js`: GlobalImageCache, LocalColorSpaceCache
- `../../src/core/jbig2.js`: Jbig2Error, Jbig2Image
- `../../src/core/jpg.js`: JpegError, JpegImage
- `../../src/core/jpx.js`: JpxError, JpxImage
- `../../src/core/metadata_parser.js`: MetadataParser
- `../../src/core/operator_list.js`: OperatorList
- `../../src/core/parser.js`: Lexer, Linearization, Parser
- `../../src/core/predictor_stream.js`: PredictorStream
- `../../src/core/primitives.js`: Cmd, Dict, EOF, Name, Ref, RefSet, RefSetCache, isCmd, isDict, isName, isRefsEqual
- `../../src/core/ps_parser.js`: PostScriptLexer, PostScriptParser
- `../../src/core/stream.js`: NullStream, Stream, StringStream
- `../../src/core/type1_parser.js`: Type1Parser
- `../../src/core/unicode.js`: getCharUnicodeCategory, getUnicodeForGlyph, getUnicodeRangeFor, mapSpecialUnicodeValues
- `../../src/core/worker.js`: WorkerMessageHandler, WorkerTask
- `../../src/core/writer.js`: incrementalUpdate, writeDict
- `../../src/core/xfa/bind.js`: Binder
- `../../src/core/xfa/data.js`: DataHandler
- `../../src/core/xfa/factory.js`: XFAFactory
- `../../src/core/xfa/formcalc_lexer.js`: Lexer, TOKEN, Token
- `../../src/core/xfa/formcalc_parser.js`: Errors, Parser
- `../../src/core/xfa/parser.js`: XFAParser
- `../../src/core/xfa/som.js`: searchNode
- `../../src/core/xfa/symbol_utils.js`: $dump, $getChildren, $getChildrenByClass, $getChildrenByName, $text, $uid
- `../../src/core/xml_parser.js`: SimpleXMLParser, XMLParserBase
- `../../src/display/annotation_layer.js`: AnnotationLayer
- `../../src/display/annotation_storage.js`: AnnotationStorage
- `../../src/display/api.js`: DefaultCMapReaderFactory, DefaultCanvasFactory, DefaultStandardFontDataFactory, LoopbackPort, PDFDataRangeTransport, PDFDocumentLoadingTask, PDFDocumentProxy, PDFPageProxy, PDFWorker, RenderTask, build, getDocument, version
- `../../src/display/display_utils.js`: DOMCanvasFactory, DOMSVGFactory, OutputScale, PDFDateString, PageViewport, PixelsPerInch, RenderingCancelledException, StatTimer, fetchData, getFilenameFromUrl, getPdfFilenameFromUrl, getXfaPageViewport, isDataScheme, isPdfFile, isValidFetchUrl, noContextMenu, setLayerDimensions
- `../../src/display/draw_layer.js`: DrawLayer
- `../../src/display/editor/annotation_editor_layer.js`: AnnotationEditorLayer
- `../../src/display/editor/color_picker.js`: ColorPicker
- `../../src/display/editor/tools.js`: AnnotationEditorUIManager, CommandManager
- `../../src/display/fetch_stream.js`: PDFFetchStream
- `../../src/display/metadata.js`: Metadata
- `../../src/display/network.js`: PDFNetworkStream
- `../../src/display/network_utils.js`: createHeaders, createResponseStatusError, extractFilenameFromHeader, validateRangeRequestCapabilities, validateResponseStatus
- `../../src/display/node_stream.js`: PDFNodeStream
- `../../src/display/node_utils.js`: NodePackages
- `../../src/display/text_layer.js`: TextLayer
- `../../src/display/worker_options.js`: GlobalWorkerOptions
- `../../src/display/xfa_layer.js`: XfaLayer
- `../../src/shared/message_handler.js`: MessageHandler
- `../../src/shared/murmurhash3.js`: MurmurHash3_64
- `../../src/shared/util.js`: AbortException, AnnotationBorderStyleType, AnnotationEditorParamsType, AnnotationEditorType, AnnotationFieldFlag, AnnotationFlag, AnnotationMode, AnnotationType, BaseException, CMapCompressionType, FeatureTest, FormatError, ImageKind, InvalidPDFException, MissingPDFException, OPS, PasswordException, PasswordResponses, PermissionFlag, RenderingIntentFlag, UnexpectedResponseException, UnknownErrorException, Util, VerbosityLevel, assert, bytesToString, createValidAbsoluteUrl, getModificationDate, getVerbosityLevel, isNodeJS, normalizeUnicode, objectSize, setVerbosityLevel, shadow, string32, stringToBytes, stringToPDFString, stringToUTF8String
- `../../web/annotation_layer_builder.js`: AnnotationLayerBuilder
- `../../web/app_options.js`: AppOptions, OptionKind
- `../../web/download_manager.js`: DownloadManager
- `../../web/event_utils.js`: EventBus, WaitOnType, waitOnEventOrTimeout
- `../../web/genericl10n.js`: GenericL10n
- `../../web/pdf_find_controller.js`: FindState, PDFFindController
- `../../web/pdf_find_utils.js`: CharacterType, getCharacterType
- `../../web/pdf_history.js`: PDFHistory, isDestArraysEqual, isDestHashesEqual
- `../../web/pdf_link_service.js`: LinkTarget, PDFLinkService, SimpleLinkService
- `../../web/pdf_page_view.js`: PDFPageView
- `../../web/pdf_scripting_manager.component.js`: PDFScriptingManager
- `../../web/pdf_single_page_viewer.js`: PDFSinglePageViewer
- `../../web/pdf_viewer.js`: PDFPageViewBuffer, PDFViewer
- `../../web/struct_tree_layer_builder.js`: StructTreeLayerBuilder
- `../../web/text_layer_builder.js`: TextLayerBuilder
- `../../web/ui_utils.js`: AutoPrintRegExp, ProgressBar, RenderingStates, ScrollMode, SpreadMode, backtrackBeforeAllVisibleElements, binarySearchFirstItem, calcRound, getPageSizeInches, getVisibleElements, isPortraitOrientation, isValidRotation, parseQueryString, removeNullCharacters
- `../../web/xfa_layer_builder.js`: XfaLayerBuilder
- `./test_utils.js`: CMAP_URL, DefaultFileReaderFactory, STANDARD_FONT_DATA_URL, TEST_PDFS_PATH, XRefMock, buildGetDocumentParams, createIdFactory, createTemporaryNodeServer
- `./testreporter.js`: TestReporter
</imports>

Code:
<code>
File:
src/core/evaluator.js
1 /* Copyright 2012 Mozilla Foundation
2  *
3  * Licensed under the Apache License, Version 2.0 (the "License");
4  * you may not use this file except in compliance with the License.
5  * You may obtain a copy of the License at
6  *
7  *     http://www.apache.org/licenses/LICENSE-2.0
8  *
9  * Unless required by applicable law or agreed to in writing, software
10  * distributed under the License is distributed on an "AS IS" BASIS,
11  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
12  * See the License for the specific language governing permissions and
13  * limitations under the License.
14  */
15 /* eslint-disable no-var */
16 
17 import {
18   AbortException,
19   assert,
20   CMapCompressionType,
21   FONT_IDENTITY_MATRIX,
22   FormatError,
23   IDENTITY_MATRIX,
24   info,
25   isArrayEqual,
26   normalizeUnicode,
27   OPS,
28   shadow,
29   stringToPDFString,
30   TextRenderingMode,
31   Util,
32   warn,
33 } from "../shared/util.js";
34 import { CMapFactory, IdentityCMap } from "./cmap.js";
35 import { Cmd, Dict, EOF, isName, Name, Ref, RefSet } from "./primitives.js";
36 import { ErrorFont, Font } from "./fonts.js";
37 import {
38   getEncoding,
39   MacRomanEncoding,
40   StandardEncoding,
41   SymbolSetEncoding,
42   WinAnsiEncoding,
43   ZapfDingbatsEncoding,
44 } from "./encodings.js";
45 import {
46   getFontNameToFileMap,
47   getSerifFonts,
48   getStandardFontName,
49   getStdFontMap,
50   getSymbolsFonts,
51   isKnownFontName,
52 } from "./standard_fonts.js";
53 import { getTilingPatternIR, Pattern } from "./pattern.js";
54 import { getXfaFontDict, getXfaFontName } from "./xfa_fonts.js";
55 import { IdentityToUnicodeMap, ToUnicodeMap } from "./to_unicode_map.js";
56 import { isNumberArray, lookupMatrix, lookupNormalRect } from "./core_utils.js";
57 import { isPDFFunction, PDFFunctionFactory } from "./function.js";
58 import { Lexer, Parser } from "./parser.js";
59 import {
60   LocalColorSpaceCache,
61   LocalGStateCache,
62   LocalImageCache,
63   LocalTilingPatternCache,
64   RegionalImageCache,
65 } from "./image_utils.js";
66 import { NullStream, Stream } from "./stream.js";
67 import { BaseStream } from "./base_stream.js";
68 import { bidi } from "./bidi.js";
69 import { ColorSpace } from "./colorspace.js";
70 import { DecodeStream } from "./decode_stream.js";
71 import { FontFlags } from "./fonts_utils.js";
72 import { getFontSubstitution } from "./font_substitutions.js";
73 import { getGlyphsUnicode } from "./glyphlist.js";
74 import { getMetrics } from "./metrics.js";
75 import { getUnicodeForGlyph } from "./unicode.js";
76 import { ImageResizer } from "./image_resizer.js";
77 import { MurmurHash3_64 } from "../shared/murmurhash3.js";
78 import { OperatorList } from "./operator_list.js";
79 import { PDFImage } from "./image.js";
80 
81 const DefaultPartialEvaluatorOptions = Object.freeze({
82   maxImageSize: -1,
83   disableFontFace: false,
84   ignoreErrors: false,
85   isEvalSupported: true,
86   isOffscreenCanvasSupported: false,
87   canvasMaxAreaInBytes: -1,
88   fontExtraProperties: false,
89   useSystemFonts: true,
90   cMapUrl: null,
91   standardFontDataUrl: null,
92 });
93 
94 const PatternType = {
95   TILING: 1,
96   SHADING: 2,
97 };
98 
99 // Optionally avoid sending individual, or very few, text chunks to reduce
100 // `postMessage` overhead with ReadableStream (see issue 13962).
101 //
102 // PLEASE NOTE: This value should *not* be too large (it's used as a lower limit
103 // in `enqueueChunk`), since that would cause streaming of textContent to become
104 // essentially useless in practice by sending all (or most) chunks at once.
105 // Also, a too large value would (indirectly) affect the main-thread `textLayer`
106 // building negatively by forcing all textContent to be handled at once, which
107 // could easily end up hurting *overall* performance (e.g. rendering as well).
108 const TEXT_CHUNK_BATCH_SIZE = 10;
109 
110 const deferred = Promise.resolve();
111 
112 // Convert PDF blend mode names to HTML5 blend mode names.
173 
185 // Trying to minimize Date.now() usage and check every 100 time.
208 
209 class PartialEvaluator {
210   constructor({
211     xref,
212     handler,
213     pageIndex,
214     idFactory,
215     fontCache,
216     builtInCMapCache,
217     standardFontDataCache,
218     globalImageCache,
219     systemFontCache,
220     options = null,
221   }) {
222     this.xref = xref;
223     this.handler = handler;
224     this.pageIndex = pageIndex;
225     this.idFactory = idFactory;
226     this.fontCache = fontCache;
227     this.builtInCMapCache = builtInCMapCache;
228     this.standardFontDataCache = standardFontDataCache;
229     this.globalImageCache = globalImageCache;
230     this.systemFontCache = systemFontCache;
231     this.options = options || DefaultPartialEvaluatorOptions;
232     this.type3FontRefs = null;
233 
234     this._regionalImageCache = new RegionalImageCache();
235     this._fetchBuiltInCMapBound = this.fetchBuiltInCMap.bind(this);
236     ImageResizer.setMaxArea(this.options.canvasMaxAreaInBytes);
237   }
238 
1719   getOperatorList({
1720     stream,
1721     task,
1722     resources,
1723     operatorList,
1724     initialState = null,
1725     fallbackFontDict = null,
1726   }) {
1727     // Ensure that `resources`/`initialState` is correctly initialized,
1728     // even if the provided parameter is e.g. `null`.
1729     resources ||= Dict.empty;
1730     initialState ||= new EvalState();
1731 
1732     if (!operatorList) {
1733       throw new Error('getOperatorList: missing "operatorList" parameter');
1734     }
1735 
1736     const self = this;
1737     const xref = this.xref;
1738     let parsingText = false;
1739     const localImageCache = new LocalImageCache();
1740     const localColorSpaceCache = new LocalColorSpaceCache();
1741     const localGStateCache = new LocalGStateCache();
1742     const localTilingPatternCache = new LocalTilingPatternCache();
1743     const localShadingPatternCache = new Map();
1744 
1745     const xobjs = resources.get("XObject") || Dict.empty;
1746     const patterns = resources.get("Pattern") || Dict.empty;
1747     const stateManager = new StateManager(initialState);
1748     const preprocessor = new EvaluatorPreprocessor(stream, xref, stateManager);
1749     const timeSlotManager = new TimeSlotManager();
1750 
1751     function closePendingRestoreOPS(argument) {
1752       for (let i = 0, ii = preprocessor.savedStatesDepth; i < ii; i++) {
1753         operatorList.addOp(OPS.restore, []);
1754       }
1755     }
1756 
1757     return new Promise(function promiseBody(resolve, reject) {
1758       const next = function (promise) {
1759         Promise.all([promise, operatorList.ready]).then(function () {
1760           try {
1761             promiseBody(resolve, reject);
1762           } catch (ex) {
1763             reject(ex);
1764           }
1765         }, reject);
1766       };
1767       task.ensureNotTerminated();
1768       timeSlotManager.reset();
1769 
1770       const operation = {};
1771       let stop, i, ii, cs, name, isValidName;
1772       while (!(stop = timeSlotManager.check())) {
1773         // The arguments parsed by read() are used beyond this loop, so we
1774         // cannot reuse the same array on each iteration. Therefore we pass
1775         // in |null| as the initial value (see the comment on
1776         // EvaluatorPreprocessor_read() for why).
1777         operation.args = null;
1778         if (!preprocessor.read(operation)) {
1779           break;
1780         }
1781         let args = operation.args;
1782         let fn = operation.fn;
1783 
1784         switch (fn | 0) {
1785           case OPS.paintXObject:
1786             // eagerly compile XForm objects
1787             isValidName = args[0] instanceof Name;
1788             name = args[0].name;
1789 
1790             if (isValidName) {
1791               const localImage = localImageCache.getByName(name);
1792               if (localImage) {
1793                 addLocallyCachedImageOps(operatorList, localImage);
1794                 args = null;
1795                 continue;
1796               }
1797             }
1798 
1799             next(
1800               new Promise(function (resolveXObject, rejectXObject) {
1801                 if (!isValidName) {
1802                   throw new FormatError("XObject must be referred to by name.");
1803                 }
1804 
1805                 let xobj = xobjs.getRaw(name);
1806                 if (xobj instanceof Ref) {
1807                   const localImage =
1808                     localImageCache.getByRef(xobj) ||
1809                     self._regionalImageCache.getByRef(xobj);
1810                   if (localImage) {
1811                     addLocallyCachedImageOps(operatorList, localImage);
1812                     resolveXObject();
1813                     return;
1814                   }
1815 
1816                   const globalImage = self.globalImageCache.getData(
1817                     xobj,
1818                     self.pageIndex
1819                   );
1820                   if (globalImage) {
1821                     operatorList.addDependency(globalImage.objId);
1822                     operatorList.addImageOps(
1823                       globalImage.fn,
1824                       globalImage.args,
1825                       globalImage.optionalContent
1826                     );
1827 
1828                     resolveXObject();
1829                     return;
1830                   }
1831 
1832                   xobj = xref.fetch(xobj);
1833                 }
1834 
1835                 if (!(xobj instanceof BaseStream)) {
1836                   throw new FormatError("XObject should be a stream");
1837                 }
1838 
1839                 const type = xobj.dict.get("Subtype");
1840                 if (!(type instanceof Name)) {
1841                   throw new FormatError("XObject should have a Name subtype");
1842                 }
1843 
1844                 if (type.name === "Form") {
1845                   stateManager.save();
1846                   self
1847                     .buildFormXObject(
1848                       resources,
1849                       xobj,
1850                       null,
1851                       operatorList,
1852                       task,
1853                       stateManager.state.clone(),
1854                       localColorSpaceCache
1855                     )
1856                     .then(function () {
1857                       stateManager.restore();
1858                       resolveXObject();
1859                     }, rejectXObject);
1860                   return;
1861                 } else if (type.name === "Image") {
1862                   self
1863                     .buildPaintImageXObject({
1864                       resources,
1865                       image: xobj,
1866                       operatorList,
1867                       cacheKey: name,
1868                       localImageCache,
1869                       localColorSpaceCache,
1870                     })
1871                     .then(resolveXObject, rejectXObject);
1872                   return;
1873                 } else if (type.name === "PS") {
1874                   // PostScript XObjects are unused when viewing documents.
1875                   // See section 4.7.1 of Adobe's PDF reference.
1876                   info("Ignored XObject subtype PS");
1877                 } else {
1878                   throw new FormatError(
1879                     `Unhandled XObject subtype ${type.name}`
1880                   );
1881                 }
1882                 resolveXObject();
1883               }).catch(function (reason) {
1884                 if (reason instanceof AbortException) {
1885                   return;
1886                 }
1887                 if (self.options.ignoreErrors) {
1888                   warn(`getOperatorList - ignoring XObject: "${reason}".`);
1889                   return;
1890                 }
1891                 throw reason;
1892               })
1893             );
1894             return;
1895           case OPS.setFont:
1896             var fontSize = args[1];
1897             // eagerly collect all fonts
1898             next(
1899               self
1900                 .handleSetFont(
1901                   resources,
1902                   args,
1903                   null,
1904                   operatorList,
1905                   task,
1906                   stateManager.state,
1907                   fallbackFontDict
1908                 )
1909                 .then(function (loadedName) {
1910                   operatorList.addDependency(loadedName);
1911                   operatorList.addOp(OPS.setFont, [loadedName, fontSize]);
1912                 })
1913             );
1914             return;
1915           case OPS.beginText:
1916             parsingText = true;
1917             break;
1918           case OPS.endText:
1919             parsingText = false;
1920             break;
1921           case OPS.endInlineImage:
1922             var cacheKey = args[0].cacheKey;
1923             if (cacheKey) {
1924               const localImage = localImageCache.getByName(cacheKey);
1925               if (localImage) {
1926                 addLocallyCachedImageOps(operatorList, localImage);
1927                 args = null;
1928                 continue;
1929               }
1930             }
1931             next(
1932               self.buildPaintImageXObject({
1933                 resources,
1934                 image: args[0],
1935                 isInline: true,
1936                 operatorList,
1937                 cacheKey,
1938                 localImageCache,
1939                 localColorSpaceCache,
1940               })
1941             );
1942             return;
1943           case OPS.showText:
1944             if (!stateManager.state.font) {
1945               self.ensureStateFont(stateManager.state);
1946               continue;
1947             }
1948             args[0] = self.handleText(args[0], stateManager.state);
1949             break;
1950           case OPS.showSpacedText:
1951             if (!stateManager.state.font) {
1952               self.ensureStateFont(stateManager.state);
1953               continue;
1954             }
1955             var combinedGlyphs = [];
1956             var state = stateManager.state;
1957             for (const arrItem of args[0]) {
1958               if (typeof arrItem === "string") {
1959                 combinedGlyphs.push(...self.handleText(arrItem, state));
1960               } else if (typeof arrItem === "number") {
1961                 combinedGlyphs.push(arrItem);
1962               }
1963             }
1964             args[0] = combinedGlyphs;
1965             fn = OPS.showText;
1966             break;
1967           case OPS.nextLineShowText:
1968             if (!stateManager.state.font) {
1969               self.ensureStateFont(stateManager.state);
1970               continue;
1971             }
1972             operatorList.addOp(OPS.nextLine);
1973             args[0] = self.handleText(args[0], stateManager.state);
1974             fn = OPS.showText;
1975             break;
1976           case OPS.nextLineSetSpacingShowText:
1977             if (!stateManager.state.font) {
1978               self.ensureStateFont(stateManager.state);
1979               continue;
1980             }
1981             operatorList.addOp(OPS.nextLine);
1982             operatorList.addOp(OPS.setWordSpacing, [args.shift()]);
1983             operatorList.addOp(OPS.setCharSpacing, [args.shift()]);
1984             args[0] = self.handleText(args[0], stateManager.state);
1985             fn = OPS.showText;
1986             break;
1987           case OPS.setTextRenderingMode:
1988             stateManager.state.textRenderingMode = args[0];
1989             break;
1990 
1991           case OPS.setFillColorSpace: {
1992             const cachedColorSpace = ColorSpace.getCached(
1993               args[0],
1994               xref,
1995               localColorSpaceCache
1996             );
1997             if (cachedColorSpace) {
1998               stateManager.state.fillColorSpace = cachedColorSpace;
1999               continue;
2000             }
2001 
2002             next(
2003               self
2004                 .parseColorSpace({
2005                   cs: args[0],
2006                   resources,
2007                   localColorSpaceCache,
2008                 })
2009                 .then(function (colorSpace) {
2010                   stateManager.state.fillColorSpace =
2011                     colorSpace || ColorSpace.singletons.gray;
2012                 })
2013             );
2014             return;
2015           }
2016           case OPS.setStrokeColorSpace: {
2017             const cachedColorSpace = ColorSpace.getCached(
2018               args[0],
2019               xref,
2020               localColorSpaceCache
2021             );
2022             if (cachedColorSpace) {
2023               stateManager.state.strokeColorSpace = cachedColorSpace;
2024               continue;
2025             }
2026 
2027             next(
2028               self
2029                 .parseColorSpace({
2030                   cs: args[0],
2031                   resources,
2032                   localColorSpaceCache,
2033                 })
2034                 .then(function (colorSpace) {
2035                   stateManager.state.strokeColorSpace =
2036                     colorSpace || ColorSpace.singletons.gray;
2037                 })
2038             );
2039             return;
2040           }
2041           case OPS.setFillColor:
2042             cs = stateManager.state.fillColorSpace;
2043             args = cs.getRgb(args, 0);
2044             fn = OPS.setFillRGBColor;
2045             break;
2046           case OPS.setStrokeColor:
2047             cs = stateManager.state.strokeColorSpace;
2048             args = cs.getRgb(args, 0);
2049             fn = OPS.setStrokeRGBColor;
2050             break;
2051           case OPS.setFillGray:
2052             stateManager.state.fillColorSpace = ColorSpace.singletons.gray;
2053             args = ColorSpace.singletons.gray.getRgb(args, 0);
2054             fn = OPS.setFillRGBColor;
2055             break;
2056           case OPS.setStrokeGray:
2057             stateManager.state.strokeColorSpace = ColorSpace.singletons.gray;
2058             args = ColorSpace.singletons.gray.getRgb(args, 0);
2059             fn = OPS.setStrokeRGBColor;
2060             break;
2061           case OPS.setFillCMYKColor:
2062             stateManager.state.fillColorSpace = ColorSpace.singletons.cmyk;
2063             args = ColorSpace.singletons.cmyk.getRgb(args, 0);
2064             fn = OPS.setFillRGBColor;
2065             break;
2066           case OPS.setStrokeCMYKColor:
2067             stateManager.state.strokeColorSpace = ColorSpace.singletons.cmyk;
2068             args = ColorSpace.singletons.cmyk.getRgb(args, 0);
2069             fn = OPS.setStrokeRGBColor;
2070             break;
2071           case OPS.setFillRGBColor:
2072             stateManager.state.fillColorSpace = ColorSpace.singletons.rgb;
2073             args = ColorSpace.singletons.rgb.getRgb(args, 0);
2074             break;
2075           case OPS.setStrokeRGBColor:
2076             stateManager.state.strokeColorSpace = ColorSpace.singletons.rgb;
2077             args = ColorSpace.singletons.rgb.getRgb(args, 0);
2078             break;
2079           case OPS.setFillColorN:
2080             cs = stateManager.state.patternFillColorSpace;
2081             if (!cs) {
2082               args = [];
2083               fn = OPS.setFillTransparent;
2084               break;
2085             }
2086             if (cs.name === "Pattern") {
2087               next(
2088                 self.handleColorN(
2089                   operatorList,
2090                   OPS.setFillColorN,
2091                   args,
2092                   cs,
2093                   patterns,
2094                   resources,
2095                   task,
2096                   localColorSpaceCache,
2097                   localTilingPatternCache,
2098                   localShadingPatternCache
2099                 )
2100               );
2101               return;
2102             }
2103             args = cs.getRgb(args, 0);
2104             fn = OPS.setFillRGBColor;
2105             break;
2106           case OPS.setStrokeColorN:
2107             cs = stateManager.state.patternStrokeColorSpace;
2108             if (!cs) {
2109               args = [];
2110               fn = OPS.setStrokeTransparent;
2111               break;
2112             }
2113             if (cs.name === "Pattern") {
2114               next(
2115                 self.handleColorN(
2116                   operatorList,
2117                   OPS.setStrokeColorN,
2118                   args,
2119                   cs,
2120                   patterns,
2121                   resources,
2122                   task,
2123                   localColorSpaceCache,
2124                   localTilingPatternCache,
2125                   localShadingPatternCache
2126                 )
2127               );
2128               return;
2129             }
2130             args = cs.getRgb(args, 0);
2131             fn = OPS.setStrokeRGBColor;
2132             break;
2133 
2134           case OPS.shadingFill:
2135             var shadingRes = resources.get("Shading");
2136             if (!shadingRes) {
2137               throw new FormatError("No shading resource found");
2138             }
2139 
2140             var shading = shadingRes.get(args[0].name);
2141             if (!shading) {
2142               throw new FormatError("No shading object found");
2143             }
2144             const patternId = self.parseShading({
2145               shading,
2146               resources,
2147               localColorSpaceCache,
2148               localShadingPatternCache,
2149             });
2150             if (!patternId) {
2151               continue;
2152             }
2153             args = [patternId];
2154             fn = OPS.shadingFill;
2155             break;
2156           case OPS.setGState:
2157             isValidName = args[0] instanceof Name;
2158             name = args[0].name;
2159 
2160             if (isValidName) {
2161               const localGStateObj = localGStateCache.getByName(name);
2162               if (localGStateObj) {
2163                 if (localGStateObj.length > 0) {
2164                   operatorList.addOp(OPS.setGState, [localGStateObj]);
2165                 }
2166                 args = null;
2167                 continue;
2168               }
2169             }
2170 
2171             next(
2172               new Promise(function (resolveGState, rejectGState) {
2173                 if (!isValidName) {
2174                   throw new FormatError("GState must be referred to by name.");
2175                 }
2176 
2177                 const extGState = resources.get("ExtGState");
2178                 if (!(extGState instanceof Dict)) {
2179                   throw new FormatError("ExtGState should be a dictionary.");
2180                 }
2181 
2182                 const gState = extGState.get(name);
2183                 // TODO: Attempt to lookup cached GStates by reference as well,
2184                 //       if and only if there are PDF documents where doing so
2185                 //       would significantly improve performance.
2186                 if (!(gState instanceof Dict)) {
2187                   throw new FormatError("GState should be a dictionary.");
2188                 }
2189 
2190                 self
2191                   .setGState({
2192                     resources,
2193                     gState,
2194                     operatorList,
2195                     cacheKey: name,
2196                     task,
2197                     stateManager,
2198                     localGStateCache,
2199                     localColorSpaceCache,
2200                   })
2201                   .then(resolveGState, rejectGState);
2202               }).catch(function (reason) {
2203                 if (reason instanceof AbortException) {
2204                   return;
2205                 }
2206                 if (self.options.ignoreErrors) {
2207                   warn(`getOperatorList - ignoring ExtGState: "${reason}".`);
2208                   return;
2209                 }
2210                 throw reason;
2211               })
2212             );
2213             return;
2214           case OPS.moveTo:
2215           case OPS.lineTo:
2216           case OPS.curveTo:
2217           case OPS.curveTo2:
2218           case OPS.curveTo3:
2219           case OPS.closePath:
2220           case OPS.rectangle:
2221             self.buildPath(operatorList, fn, args, parsingText);
2222             continue;
2223           case OPS.markPoint:
2224           case OPS.markPointProps:
2225           case OPS.beginCompat:
2226           case OPS.endCompat:
2227             // Ignore operators where the corresponding handlers are known to
2228             // be no-op in CanvasGraphics (display/canvas.js). This prevents
2229             // serialization errors and is also a bit more efficient.
2230             // We could also try to serialize all objects in a general way,
2231             // e.g. as done in https://github.com/mozilla/pdf.js/pull/6266,
2232             // but doing so is meaningless without knowing the semantics.
2233             continue;
2234           case OPS.beginMarkedContentProps:
2235             if (!(args[0] instanceof Name)) {
2236               warn(`Expected name for beginMarkedContentProps arg0=${args[0]}`);
2237               operatorList.addOp(OPS.beginMarkedContentProps, ["OC", null]);
2238               continue;
2239             }
2240             if (args[0].name === "OC") {
2241               next(
2242                 self
2243                   .parseMarkedContentProps(args[1], resources)
2244                   .then(data => {
2245                     operatorList.addOp(OPS.beginMarkedContentProps, [
2246                       "OC",
2247                       data,
2248                     ]);
2249                   })
2250                   .catch(reason => {
2251                     if (reason instanceof AbortException) {
2252                       return;
2253                     }
2254                     if (self.options.ignoreErrors) {
2255                       warn(
2256                         `getOperatorList - ignoring beginMarkedContentProps: "${reason}".`
2257                       );
2258                       operatorList.addOp(OPS.beginMarkedContentProps, [
2259                         "OC",
2260                         null,
2261                       ]);
2262                       return;
2263                     }
2264                     throw reason;
2265                   })
2266               );
2267               return;
2268             }
2269             // Other marked content types aren't supported yet.
2270             args = [
2271               args[0].name,
2272               args[1] instanceof Dict ? args[1].get("MCID") : null,
2273             ];
2274 
2275             break;
2276           case OPS.beginMarkedContent:
2277           case OPS.endMarkedContent:
2278           default:
2279             // Note: Ignore the operator if it has `Dict` arguments, since
2280             // those are non-serializable, otherwise postMessage will throw
2281             // "An object could not be cloned.".
2282             if (args !== null) {
2283               for (i = 0, ii = args.length; i < ii; i++) {
2284                 if (args[i] instanceof Dict) {
2285                   break;
2286                 }
2287               }
2288               if (i < ii) {
2289                 warn("getOperatorList - ignoring operator: " + fn);
2290                 continue;
2291               }
2292             }
2293         }
2294         operatorList.addOp(fn, args);
2295       }
2296       if (stop) {
2297         next(deferred);
2298         return;
2299       }
2300       // Some PDFs don't close all restores inside object/form.
2301       // Closing those for them.
2302       closePendingRestoreOPS();
2303       resolve();
2304     }).catch(reason => {
2305       if (reason instanceof AbortException) {
2306         return;
2307       }
2308       if (this.options.ignoreErrors) {
2309         warn(
2310           `getOperatorList - ignoring errors during "${task.name}" ` +
2311             `task: "${reason}".`
2312         );
2313 
2314         closePendingRestoreOPS();
2315         return;
2316       }
2317       throw reason;
2318     });
2319   }
2320 
4585 }
4586 
5190 
</code>

PR summary:
<pr_summary>
Ignore non-existing /Shading resources during parsing (issue 18765)
*Slightly smaller diff with https://github.com/mozilla/pdf.js/pull/18766/files?w=1*
</pr_summary>

Your task:
You are a software tester at pdf.js.
1. Write exactly one javascript test `it("...", async () => {...})` block.
2. Your test must fail on the code before the patch, and pass after, hence the test will verify that the patch resolves the issue.
3. The test must be self-contained and to-the-point.
4. Use only the provided imports (respect the paths exactly how they are given) by importing dynamically for compatibility with Node.js — no new dependencies. You can use the PDF file for testing as follows:
const { getDocument } = await import('../../src/display/api.js');
const { buildGetDocumentParams } = await import('./test_utils.js');
const loadingTask = getDocument(buildGetDocumentParams('issue18765.pdf'))
5. Return only the javascript code (no comments or explanations).

Example structure:
it("should <describe behavior>", async () => {
  const { example } = await import("../../src/core/example.js");
  <initialize required variables>;
  <define expected variable>;
  <generate actual variables>;
  <compare expected with actual>;
});

