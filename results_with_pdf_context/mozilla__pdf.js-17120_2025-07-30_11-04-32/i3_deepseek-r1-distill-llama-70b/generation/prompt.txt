Before you begin:
- Keep going until the job is completely solved — don’t stop halfway.
- If you’re unsure about the behavior, reread the provided patch carefully; do not hallucinate.
- Plan your approach before writing code by reflecting on whether the test truly fails before and passes after.

Issue:
<issue>
Fix new code scanning alerts
The following new code scanning alerts showed up recently:

- https://github.com/mozilla/pdf.js/security/code-scanning/402
- https://github.com/mozilla/pdf.js/security/code-scanning/401
- https://github.com/mozilla/pdf.js/security/code-scanning/400
- https://github.com/mozilla/pdf.js/security/code-scanning/399
- https://github.com/mozilla/pdf.js/security/code-scanning/398

There is a note in there that this is debugging code code, and it's indeed not called from anywhere. It has also mostly been changed 12 years ago.

@Snuffleupagus What do you think? Should we get rid of it, or is this something you have used or think is useful to keep? In the latter case we can just silence the alert.
</issue>

Patch:
<patch>
diff --git a/src/shared/cffStandardStrings.js b/src/shared/cffStandardStrings.js
--- a/src/shared/cffStandardStrings.js
+++ b/src/shared/cffStandardStrings.js
@@ -1,311 +0,0 @@
-/* Copyright 2012 Mozilla Foundation
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-'use strict';
-
-var CFFEncodingMap = {
-  '0': '-reserved-',
-  '1': 'hstem',
-  '2': '-reserved-',
-  '3': 'vstem',
-  '4': 'vmoveto',
-  '5': 'rlineto',
-  '6': 'hlineto',
-  '7': 'vlineto',
-  '8': 'rrcurveto',
-  '9': '-reserved-',
-  '10': 'callsubr',
-  '11': 'return',
-  '12': {
-    '3': 'and',
-    '4': 'or',
-    '5': 'not',
-    '9': 'abs',
-    '10': 'add',
-    '11': 'div',
-    '12': 'sub',
-    '14': 'neg',
-    '15': 'eq',
-    '18': 'drop',
-    '20': 'put',
-    '21': 'get',
-    '22': 'ifelse',
-    '23': 'random',
-    '24': 'mul',
-    '26': 'sqrt',
-    '27': 'dup',
-    '28': 'exch',
-    '29': 'index',
-    '30': 'roll',
-    '34': 'hflex',
-    '35': 'flex',
-    '36': 'hflex1',
-    '37': 'flex1'
-  },
-  '13': '-reserved-',
-  '14': 'endchar',
-  '15': '-reserved-',
-  '16': '-reserved-',
-  '17': '-reserved-',
-  '18': 'hstemhm',
-  '19': 'hintmask',
-  '20': 'cntrmask',
-  '21': 'rmoveto',
-  '22': 'hmoveto',
-  '23': 'vstemhm',
-  '24': 'rcurveline',
-  '25': 'rlivecurve',
-  '26': 'vvcurveto',
-  '27': 'hhcurveto',
-  '29': 'callgsubr',
-  '30': 'vhcurveto',
-  '31': 'hvcurveto'
-};
-
-var CFFDictDataMap = {
-  '0': {
-    name: 'version',
-    operand: 'SID'
-  },
-  '1': {
-    name: 'Notice',
-    operand: 'SID'
-  },
-  '2': {
-    name: 'FullName',
-    operand: 'SID'
-  },
-  '3': {
-    name: 'FamilyName',
-    operand: 'SID'
-  },
-  '4': {
-    name: 'Weight',
-    operand: 'SID'
-  },
-  '5': {
-    name: 'FontBBox',
-    operand: [0, 0, 0, 0]
-  },
-  '6': {
-    name: 'BlueValues'
-  },
-  '7': {
-    name: 'OtherBlues'
-  },
-  '8': {
-    name: 'FamilyBlues'
-  },
-  '9': {
-    name: 'FamilyOtherBlues'
-  },
-  '10': {
-    name: 'StdHW'
-  },
-  '11': {
-    name: 'StdVW'
-  },
-  '12': {
-    '0': {
-      name: 'Copyright',
-      operand: 'SID'
-    },
-    '1': {
-      name: 'IsFixedPitch',
-      operand: false
-    },
-    '2': {
-      name: 'ItalicAngle',
-      operand: 0
-    },
-    '3': {
-      name: 'UnderlinePosition',
-      operand: -100
-    },
-    '4': {
-      name: 'UnderlineThickness',
-      operand: 50
-    },
-    '5': {
-      name: 'PaintType',
-      operand: 0
-    },
-    '6': {
-      name: 'CharstringType',
-      operand: 2
-    },
-    '7': {
-      name: 'FontMatrix',
-      operand: [0.001, 0, 0, 0.001, 0, 0]
-    },
-    '8': {
-      name: 'StrokeWidth',
-      operand: 0
-    },
-    '9': {
-      name: 'BlueScale'
-    },
-    '10': {
-      name: 'BlueShift'
-    },
-    '11': {
-      name: 'BlueFuzz'
-    },
-    '12': {
-      name: 'StemSnapH'
-    },
-    '13': {
-      name: 'StemSnapV'
-    },
-    '14': {
-      name: 'ForceBold'
-    },
-    '17': {
-      name: 'LanguageGroup'
-    },
-    '18': {
-      name: 'ExpansionFactor'
-    },
-    '19': {
-      name: 'initialRandomSeed'
-    },
-    '20': {
-      name: 'SyntheticBase',
-      operand: null
-    },
-    '21': {
-      name: 'PostScript',
-      operand: 'SID'
-    },
-    '22': {
-      name: 'BaseFontName',
-      operand: 'SID'
-    },
-    '23': {
-      name: 'BaseFontBlend',
-      operand: 'delta'
-    }
-  },
-  '13': {
-    name: 'UniqueID',
-    operand: null
-  },
-  '14': {
-    name: 'XUID',
-    operand: []
-  },
-  '15': {
-    name: 'charset',
-    operand: 0
-  },
-  '16': {
-    name: 'Encoding',
-    operand: 0
-  },
-  '17': {
-    name: 'CharStrings',
-    operand: null
-  },
-  '18': {
-    name: 'Private',
-    operand: 'number number'
-  },
-  '19': {
-    name: 'Subrs'
-  },
-  '20': {
-    name: 'defaultWidthX'
-  },
-  '21': {
-    name: 'nominalWidthX'
-  }
-};
-
-var CFFDictPrivateDataMap = {
-  '6': {
-    name: 'BluesValues',
-    operand: 'delta'
-  },
-  '7': {
-    name: 'OtherBlues',
-    operand: 'delta'
-  },
-  '8': {
-    name: 'FamilyBlues',
-    operand: 'delta'
-  },
-  '9': {
-    name: 'FamilyOtherBlues',
-    operand: 'delta'
-  },
-  '10': {
-    name: 'StdHW',
-    operand: null
-  },
-  '11': {
-    name: 'StdVW',
-    operand: null
-  },
-  '12': {
-    '9': {
-      name: 'BlueScale',
-      operand: 0.039625
-    },
-    '10': {
-      name: 'BlueShift',
-      operand: 7
-    },
-    '11': {
-      name: 'BlueFuzz',
-      operand: 1
-    },
-    '12': {
-      name: 'StemSnapH',
-      operand: 'delta'
-    },
-    '13': {
-      name: 'StemSnapV',
-      operand: 'delta'
-    },
-    '14': {
-      name: 'ForceBold',
-      operand: 'boolean'
-    },
-    '17': {
-      name: 'LanguageGroup',
-      operand: 0
-    },
-    '18': {
-      name: 'ExpansionFactor',
-      operand: 0.06
-    },
-    '19': {
-      name: 'initialRandomSeed',
-      operand: 0
-    }
-  },
-  '19': {
-    name: 'Subrs',
-    operand: null
-  },
-  '20': {
-    name: 'defaultWidthX',
-    operand: 0
-  },
-  '21': {
-    name: 'nominalWidthX',
-    operand: 0
-  }
-};

diff --git a/src/shared/fonts_utils.js b/src/shared/fonts_utils.js
--- a/src/shared/fonts_utils.js
+++ b/src/shared/fonts_utils.js
@@ -1,429 +0,0 @@
-/* Copyright 2012 Mozilla Foundation
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-/* globals CFFDictDataMap, CFFDictPrivateDataMap, CFFEncodingMap, CFFStrings,
-           Components, Dict, dump, FormatError, netscape, Stream */
-
-'use strict';
-
-/*
- * The Type2 reader code below is only used for debugging purpose since Type2
- * is only a CharString format and is never used directly as a Font file.
- *
- * So the code here is useful for dumping the data content of a .cff file in
- * order to investigate the similarity between a Type1 CharString and a Type2
- * CharString or to understand the structure of the CFF format.
- */
-
-/*
- * Build a charset by assigning the glyph name and the human readable form
- * of the glyph data.
- */
-function readCharset(aStream, aCharstrings) {
-  var charset = {};
-
-  var format = aStream.getByte();
-  var count = aCharstrings.length - 1;
-  var i, sid;
-  if (format === 0) {
-    charset['.notdef'] = readCharstringEncoding(aCharstrings[0]);
-
-    for (i = 1; i < count + 1; i++) {
-      sid = aStream.getByte() << 8 | aStream.getByte();
-      charset[CFFStrings[sid]] = readCharstringEncoding(aCharstrings[i]);
-    }
-  } else if (format === 1) {
-    for (i = 1; i < count + 1; i++) {
-      var first = aStream.getByte();
-      first = (first << 8) | aStream.getByte();
-      var numLeft = aStream.getByte();
-      for (var j = 0; j <= numLeft; j++) {
-        sid = first++;
-        charset[CFFStrings[sid]] = readCharstringEncoding(aCharstrings[j]);
-      }
-    }
-  } else {
-    throw new FormatError('Invalid charset format');
-  }
-
-  return charset;
-}
-
-/*
- * Take a Type2 binary charstring as input and transform it to a human
- * readable representation as specified by the 'The Type 2 Charstring Format',
- * chapter 3.1.
- */
-function readCharstringEncoding(aString) {
-  if (!aString) {
-    return '';
-  }
-
-  var charstringTokens = [];
-
-  var count = aString.length;
-  for (var i = 0; i < count; ) {
-    var value = aString[i++] | 0;
-    var token = null;
-
-    if (value < 0) {
-      continue;
-    } else if (value <= 11) {
-      token = CFFEncodingMap[value];
-    } else if (value === 12) {
-      token = CFFEncodingMap[value][aString[i++]];
-    } else if (value <= 18) {
-      token = CFFEncodingMap[value];
-    } else if (value <= 20) {
-      ++i; // var mask = aString[i++];
-      token = CFFEncodingMap[value];
-    } else if (value <= 27) {
-      token = CFFEncodingMap[value];
-    } else if (value === 28) {
-      token = aString[i++] << 8 | aString[i++];
-    } else if (value <= 31) {
-      token = CFFEncodingMap[value];
-    } else if (value < 247) {
-      token = parseInt(value, 10) - 139;
-    } else if (value < 251) {
-      token = (value - 247) * 256 + aString[i++] + 108;
-    } else if (value < 255) {
-      token = -(value - 251) * 256 - aString[i++] - 108;
-    } else { // value === 255
-      token = aString[i++] << 24 | aString[i++] << 16 |
-              aString[i++] << 8 | aString[i];
-    }
-
-    charstringTokens.push(token);
-  }
-
-  return charstringTokens;
-}
-
-
-/*
- * Take a binary DICT Data as input and transform it into a human readable
- * form as specified by 'The Compact Font Format Specification', chapter 5.
- */
-function readFontDictData(aString, aMap) {
-  var fontDictDataTokens = [];
-
-  var count = aString.length;
-  for (var i = 0; i < count; ) {
-    var value = aString[i++] | 0;
-    var token = null;
-
-    if (value === 12) {
-      token = aMap[value][aString[i++]];
-    } else if (value === 28) {
-      token = aString[i++] << 8 | aString[i++];
-    } else if (value === 29) {
-      token = aString[i++] << 24 |
-              aString[i++] << 16 |
-              aString[i++] << 8 |
-              aString[i++];
-    } else if (value === 30) {
-      token = '';
-      var parsed = false;
-      while (!parsed) {
-        var octet = aString[i++];
-
-        var nibbles = [parseInt(octet / 16, 10), parseInt(octet % 16, 10)];
-        for (var j = 0; j < nibbles.length; j++) {
-          var nibble = nibbles[j];
-          switch (nibble) {
-            case 0xA:
-              token += '.';
-              break;
-            case 0xB:
-              token += 'E';
-              break;
-            case 0xC:
-              token += 'E-';
-              break;
-            case 0xD:
-              break;
-            case 0xE:
-              token += '-';
-              break;
-            case 0xF:
-              parsed = true;
-              break;
-            default:
-              token += nibble;
-              break;
-          }
-        }
-      }
-      token = parseFloat(token);
-    } else if (value <= 31) {
-      token = aMap[value];
-    } else if (value <= 246) {
-      token = parseInt(value, 10) - 139;
-    } else if (value <= 250) {
-      token = (value - 247) * 256 + aString[i++] + 108;
-    } else if (value <= 254) {
-      token = -(value - 251) * 256 - aString[i++] - 108;
-    } else if (value === 255) {
-      throw new FormatError('255 is not a valid DICT command');
-    }
-
-    fontDictDataTokens.push(token);
-  }
-
-  return fontDictDataTokens;
-}
-
-/*
- * Take a stream as input and return an array of objects.
- * In CFF an INDEX is a structure with the following format:
- *  {
- *    count: 2 bytes (Number of objects stored in INDEX),
- *    offsize: 1 byte (Offset array element size),
- *    offset: [count + 1] bytes (Offsets array),
- *    data: - (Objects data)
- *  }
- *
- *  More explanation are given in the 'CFF Font Format Specification',
- *  chapter 5.
- */
-function readFontIndexData(aStream, aIsByte) {
-  var count = aStream.getByte() << 8 | aStream.getByte();
-  var offsize = aStream.getByte();
-
-  function getNextOffset() {
-    switch (offsize) {
-      case 0:
-        return 0;
-      case 1:
-        return aStream.getByte();
-      case 2:
-        return aStream.getByte() << 8 | aStream.getByte();
-      case 3:
-        return aStream.getByte() << 16 | aStream.getByte() << 8 |
-               aStream.getByte();
-      case 4:
-      return aStream.getByte() << 24 | aStream.getByte() << 16 |
-             aStream.getByte() << 8 | aStream.getByte();
-    }
-    throw new FormatError(offsize + ' is not a valid offset size');
-  }
-
-  var offsets = [];
-  var i;
-  for (i = 0; i < count + 1; i++) {
-    offsets.push(getNextOffset());
-  }
-
-  dump('Found ' + count + ' objects at offsets :' +
-       offsets + ' (offsize: ' + offsize + ')');
-
-  // Now extract the objects
-  var relativeOffset = aStream.pos;
-  var objects = [];
-  for (i = 0; i < count; i++) {
-    var offset = offsets[i];
-    aStream.pos = relativeOffset + offset - 1;
-
-    var data = [];
-    var length = offsets[i + 1] - 1;
-    for (var j = offset - 1; j < length; j++) {
-      data.push(aIsByte ? aStream.getByte() : aStream.getChar());
-    }
-    objects.push(data);
-  }
-
-  return objects;
-}
-
-var Type2Parser = function type2Parser(aFilePath) {
-  var font = new Dict(null);
-
-  var xhr = new XMLHttpRequest();
-  xhr.open('GET', aFilePath, false);
-  xhr.responseType = 'arraybuffer';
-  xhr.expected = document.URL.startsWith('file:') ? 0 : 200;
-  xhr.send(null);
-  this.data = new Stream(xhr.response);
-
-  // Turn on this flag for additional debugging logs
-  var debug = false;
-
-  function dump(aStr) {
-    if (debug) {
-      console.log(aStr);
-    }
-  }
-
-  function parseAsToken(aString, aMap) {
-    var decoded = readFontDictData(aString, aMap);
-
-    var stack = [];
-    var count = decoded.length;
-    for (var i = 0; i < count; i++) {
-      var token = decoded[i];
-      if (typeof token === "number") {
-        stack.push(token);
-      } else {
-        switch (token.operand) {
-          case 'SID':
-            font.set(token.name, CFFStrings[stack.pop()]);
-            break;
-          case 'number number':
-            font.set(token.name, {
-              offset: stack.pop(),
-              size: stack.pop()
-            });
-            break;
-          case 'boolean':
-            font.set(token.name, stack.pop());
-            break;
-          case 'delta':
-            font.set(token.name, stack.pop());
-            break;
-          default:
-            if (token.operand?.length) {
-              var array = [];
-              for (var j = 0; j < token.operand.length; j++) {
-                array.push(stack.pop());
-              }
-              font.set(token.name, array);
-            } else {
-              font.set(token.name, stack.pop());
-            }
-            break;
-        }
-      }
-    }
-  }
-
-  this.parse = function type2ParserParse(aStream) {
-    font.set('major', aStream.getByte());
-    font.set('minor', aStream.getByte());
-    font.set('hdrSize', aStream.getByte());
-    font.set('offsize', aStream.getByte());
-
-    // Read the NAME Index
-    dump('Reading Index: Names');
-    font.set('Names', readFontIndexData(aStream));
-    dump('Names: ' + font.get('Names'));
-
-    // Read the Top Dict Index
-    dump('Reading Index: TopDict');
-    var topDict = readFontIndexData(aStream, true);
-    dump('TopDict: ' + topDict);
-
-    // Read the String Index
-    dump('Reading Index: Strings');
-    var strings = readFontIndexData(aStream);
-    dump('strings: ' + strings);
-
-    // Fill up the Strings dictionary with the new unique strings
-    var i;
-    for (i = 0; i < strings.length; i++) {
-      CFFStrings.push(strings[i].join(''));
-    }
-
-    // Parse the TopDict operator
-    var count = topDict.length;
-    for (i = 0; i < count; i++) {
-      parseAsToken(topDict[i], CFFDictDataMap);
-    }
-
-    // Read the Global Subr Index that comes just after the Strings Index
-    // (cf. "The Compact Font Format Specification" Chapter 16)
-    dump('Reading Global Subr Index');
-    var subrs = readFontIndexData(aStream, true);
-    dump(subrs);
-
-    // Reading Private Dict
-    var priv = font.get('Private');
-    dump('Reading Private Dict (offset: ' + priv.offset +
-        ' size: ' + priv.size + ')');
-    aStream.pos = priv.offset;
-
-    var privateDict = [];
-    for (i = 0; i < priv.size; i++) {
-      privateDict.push(aStream.getByte());
-    }
-    dump('privateData:' + privateDict);
-    parseAsToken(privateDict, CFFDictPrivateDataMap);
-
-    font.forEach(function(key, value) {
-      dump(key + '::' + value);
-    });
-
-    // Read CharStrings Index
-    var charStringsOffset = font.get('CharStrings');
-    dump('Read CharStrings Index (offset: ' + charStringsOffset + ')');
-    aStream.pos = charStringsOffset;
-    var charStrings = readFontIndexData(aStream, true);
-
-    // Read Charset
-    dump('Read Charset for ' + charStrings.length + ' glyphs');
-    var charsetEntry = font.get('charset');
-    if (charsetEntry === 0) {
-      throw new FormatError('Need to support CFFISOAdobeCharset');
-    } else if (charsetEntry === 1) {
-      throw new FormatError('Need to support CFFExpert');
-    } else if (charsetEntry === 2) {
-      throw new FormatError('Need to support CFFExpertSubsetCharset');
-    } else {
-      aStream.pos = charsetEntry;
-      readCharset(aStream, charStrings);
-    }
-  };
-};
-
-/*
- * To try the Type2 decoder on a local file in the current directory:
- *
- *  var cff = new Type2Parser("file.cff");
- *  cff.parse(this.data);
- *
- * To try the Type2 decoder on a custom built CFF array:
- *
- *  var file = new Uint8Array(cffFileArray, 0, cffFileSize);
- *  var parser = new Type2Parser();
- *  parser.parse(new Stream(file));
- */
-
-/*
- * Write to a file to the disk (works only on Firefox in privilege mode)
- * but this is useful for dumping a font file to the disk and check with
- * fontforge or the ots program what's wrong with the file.
- *
- * writeToFile(fontData, "/tmp/pdf.js." + fontCount + ".cff");
- */
-function writeToFile(aBytes, aFilePath) {
-  if (!('netscape' in window)) {
-    return;
-  }
-
-  netscape.security.PrivilegeManager.enablePrivilege('UniversalXPConnect');
-  var Cc = Components.classes,
-      Ci = Components.interfaces;
-  var file = Cc['@mozilla.org/file/local;1'].createInstance(Ci.nsILocalFile);
-  file.initWithPath(aFilePath);
-
-  var stream = Cc['@mozilla.org/network/file-output-stream;1']
-                 .createInstance(Ci.nsIFileOutputStream);
-  stream.init(file, 0x04 | 0x08 | 0x20, 0x180, 0);
-
-  var bos = Cc['@mozilla.org/binaryoutputstream;1']
-              .createInstance(Ci.nsIBinaryOutputStream);
-  bos.setOutputStream(stream);
-  bos.writeByteArray(aBytes, aBytes.length);
-  stream.close();
-}


</patch>

Imports:
<imports>
Available Packages
Dev Dependencies:
- @babel/core: ^7.22.20
- @babel/preset-env: ^7.22.20
- @babel/runtime: ^7.22.15
- @javascript-obfuscator/escodegen: 2.3.0
- acorn: ^8.10.0
- autoprefixer: ^10.4.16
- babel-loader: ^9.1.3
- caniuse-lite: ^1.0.30001538
- canvas: ^2.11.2
- core-js: ^3.32.2
- cross-env: ^7.0.3
- eslint: ^8.50.0
- eslint-config-prettier: ^8.10.0
- eslint-plugin-fetch-options: ^0.0.5
- eslint-plugin-html: ^7.1.0
- eslint-plugin-import: ^2.28.1
- eslint-plugin-json: ^3.1.0
- eslint-plugin-mozilla: ^3.2.0
- eslint-plugin-no-unsanitized: ^4.0.2
- eslint-plugin-prettier: ^5.0.0
- eslint-plugin-sort-exports: ^0.8.0
- eslint-plugin-unicorn: ^48.0.1
- globals: ^13.22.0
- gulp: ^4.0.2
- gulp-postcss: ^9.0.1
- gulp-rename: ^2.0.0
- gulp-replace: ^1.1.4
- gulp-zip: ^5.1.0
- jasmine: ^5.1.0
- jsdoc: ^4.0.2
- jstransformer-markdown-it: ^3.0.0
- merge-stream: ^2.0.0
- mkdirp: ^3.0.1
- needle: ^3.2.0
- path2d-polyfill: ^2.0.1
- pngjs: ^7.0.0
- postcss: ^8.4.31
- postcss-dir-pseudo-class: ^8.0.0
- postcss-discard-comments: ^6.0.0
- postcss-nesting: ^12.0.1
- prettier: ^3.0.3
- puppeteer: ^21.3.4
- rimraf: ^3.0.2
- streamqueue: ^1.1.2
- stylelint: ^15.10.3
- stylelint-prettier: ^4.0.2
- terser: ^5.20.0
- through2: ^4.0.2
- tsc-alias: ^1.8.8
- ttest: ^4.0.0
- typescript: ^5.2.2
- typogr: ^0.6.8
- vinyl: ^3.0.0
- webpack: ^5.88.2
- webpack-stream: ^7.0.0
- wintersmith: ^2.5.0
- yargs: ^17.7.2

Engines:
- node: >=18

Available Relative Imports:
- `../../src/core/annotation.js`: Annotation, AnnotationBorderStyle, AnnotationFactory, MarkupAnnotation, getQuadPoints
- `../../src/core/bidi.js`: bidi
- `../../src/core/cff_parser.js`: CFFCharset, CFFCompiler, CFFFDSelect, CFFParser, CFFStrings
- `../../src/core/cmap.js`: CMap, CMapFactory, IdentityCMap
- `../../src/core/colorspace.js`: ColorSpace
- `../../src/core/core_utils.js`: arrayBuffersToBytes, encodeToXmlString, escapePDFName, escapeString, getInheritableProperty, isAscii, isWhiteSpace, log2, numberToString, parseXFAPath, recoverJsURL, stringToUTF16HexString, stringToUTF16String, toRomanNumerals, validateCSSFont
- `../../src/core/crypto.js`: AES128Cipher, AES256Cipher, ARCFourCipher, CipherTransformFactory, PDF17, PDF20, calculateMD5, calculateSHA256, calculateSHA384, calculateSHA512
- `../../src/core/default_appearance.js`: createDefaultAppearance, parseAppearanceStream, parseDefaultAppearance
- `../../src/core/document.js`: PDFDocument, Page
- `../../src/core/encodings.js`: getEncoding
- `../../src/core/evaluator.js`: PartialEvaluator
- `../../src/core/font_substitutions.js`: getFontSubstitution
- `../../src/core/fonts_utils.js`: SEAC_ANALYSIS_ENABLED
- `../../src/core/function.js`: PDFFunctionFactory, PostScriptCompiler, PostScriptEvaluator
- `../../src/core/glyphlist.js`: getDingbatsGlyphsUnicode, getGlyphsUnicode
- `../../src/core/image_utils.js`: GlobalImageCache, LocalColorSpaceCache
- `../../src/core/jbig2.js`: Jbig2Image
- `../../src/core/jpg.js`: JpegImage
- `../../src/core/jpx.js`: JpxImage
- `../../src/core/metadata_parser.js`: MetadataParser
- `../../src/core/operator_list.js`: OperatorList
- `../../src/core/parser.js`: Lexer, Linearization, Parser
- `../../src/core/predictor_stream.js`: PredictorStream
- `../../src/core/primitives.js`: Cmd, Dict, EOF, Name, Ref, RefSet, RefSetCache, isCmd, isDict, isName, isRefsEqual
- `../../src/core/ps_parser.js`: PostScriptLexer, PostScriptParser
- `../../src/core/stream.js`: NullStream, Stream, StringStream
- `../../src/core/type1_parser.js`: Type1Parser
- `../../src/core/unicode.js`: getCharUnicodeCategory, getUnicodeForGlyph, getUnicodeRangeFor, mapSpecialUnicodeValues
- `../../src/core/worker.js`: WorkerMessageHandler, WorkerTask
- `../../src/core/writer.js`: incrementalUpdate, writeDict
- `../../src/core/xfa/bind.js`: Binder
- `../../src/core/xfa/data.js`: DataHandler
- `../../src/core/xfa/factory.js`: XFAFactory
- `../../src/core/xfa/formcalc_lexer.js`: Lexer, TOKEN, Token
- `../../src/core/xfa/formcalc_parser.js`: Errors, Parser
- `../../src/core/xfa/parser.js`: XFAParser
- `../../src/core/xfa/som.js`: searchNode
- `../../src/core/xfa/symbol_utils.js`: $dump, $getChildren, $getChildrenByClass, $getChildrenByName, $text, $uid
- `../../src/core/xml_parser.js`: SimpleXMLParser, XMLParserBase
- `../../src/display/annotation_layer.js`: AnnotationLayer
- `../../src/display/annotation_storage.js`: AnnotationStorage
- `../../src/display/api.js`: DefaultCMapReaderFactory, DefaultCanvasFactory, DefaultStandardFontDataFactory, LoopbackPort, PDFDataRangeTransport, PDFDocumentLoadingTask, PDFDocumentProxy, PDFPageProxy, PDFWorker, PDFWorkerUtil, RenderTask, build, getDocument, version
- `../../src/display/display_utils.js`: DOMCanvasFactory, DOMSVGFactory, PDFDateString, PageViewport, PixelsPerInch, RenderingCancelledException, StatTimer, getFilenameFromUrl, getPdfFilenameFromUrl, getXfaPageViewport, isDataScheme, isPdfFile, isValidFetchUrl, noContextMenu, setLayerDimensions
- `../../src/display/editor/annotation_editor_layer.js`: AnnotationEditorLayer
- `../../src/display/editor/tools.js`: AnnotationEditorUIManager, CommandManager
- `../../src/display/fetch_stream.js`: PDFFetchStream
- `../../src/display/metadata.js`: Metadata
- `../../src/display/network.js`: PDFNetworkStream
- `../../src/display/network_utils.js`: createResponseStatusError, extractFilenameFromHeader, validateRangeRequestCapabilities, validateResponseStatus
- `../../src/display/node_stream.js`: PDFNodeStream
- `../../src/display/text_layer.js`: TextLayerRenderTask, renderTextLayer, updateTextLayer
- `../../src/display/worker_options.js`: GlobalWorkerOptions
- `../../src/display/xfa_layer.js`: XfaLayer
- `../../src/shared/message_handler.js`: MessageHandler
- `../../src/shared/murmurhash3.js`: MurmurHash3_64
- `../../src/shared/util.js`: AbortException, AnnotationBorderStyleType, AnnotationEditorParamsType, AnnotationEditorType, AnnotationFieldFlag, AnnotationFlag, AnnotationMode, AnnotationType, CMapCompressionType, FeatureTest, FormatError, ImageKind, InvalidPDFException, MissingPDFException, OPS, PasswordException, PasswordResponses, PermissionFlag, PromiseCapability, RenderingIntentFlag, UnexpectedResponseException, UnknownErrorException, Util, VerbosityLevel, bytesToString, createValidAbsoluteUrl, getModificationDate, getVerbosityLevel, isArrayBuffer, isNodeJS, normalizeUnicode, objectSize, setVerbosityLevel, shadow, string32, stringToBytes, stringToPDFString, stringToUTF8String
- `../../web/annotation_layer_builder.js`: AnnotationLayerBuilder
- `../../web/download_manager.js`: DownloadManager
- `../../web/event_utils.js`: EventBus, WaitOnType, waitOnEventOrTimeout
- `../../web/genericl10n.js`: GenericL10n
- `../../web/l10n_utils.js`: NullL10n
- `../../web/pdf_find_controller.js`: FindState, PDFFindController
- `../../web/pdf_find_utils.js`: CharacterType, getCharacterType
- `../../web/pdf_history.js`: PDFHistory, isDestArraysEqual, isDestHashesEqual
- `../../web/pdf_link_service.js`: LinkTarget, PDFLinkService, SimpleLinkService
- `../../web/pdf_page_view.js`: PDFPageView
- `../../web/pdf_scripting_manager.component.js`: PDFScriptingManager
- `../../web/pdf_single_page_viewer.js`: PDFSinglePageViewer
- `../../web/pdf_viewer.js`: PDFPageViewBuffer, PDFViewer
- `../../web/struct_tree_layer_builder.js`: StructTreeLayerBuilder
- `../../web/text_layer_builder.js`: TextLayerBuilder
- `../../web/ui_utils.js`: AutoPrintRegExp, ProgressBar, RenderingStates, ScrollMode, SpreadMode, backtrackBeforeAllVisibleElements, binarySearchFirstItem, getPageSizeInches, getVisibleElements, isPortraitOrientation, isValidRotation, parseQueryString, removeNullCharacters
- `../../web/xfa_layer_builder.js`: XfaLayerBuilder
- `./test_utils.js`: CMAP_URL, DefaultFileReaderFactory, STANDARD_FONT_DATA_URL, TEST_PDFS_PATH, XRefMock, buildGetDocumentParams, createIdFactory
- `./testreporter.js`: TestReporter
</imports>

Code:
<code>
File:
src/shared/cffStandardStrings.js
1 /* Copyright 2012 Mozilla Foundation
2  *
3  * Licensed under the Apache License, Version 2.0 (the "License");
4  * you may not use this file except in compliance with the License.
5  * You may obtain a copy of the License at
6  *
7  *     http://www.apache.org/licenses/LICENSE-2.0
8  *
9  * Unless required by applicable law or agreed to in writing, software
10  * distributed under the License is distributed on an "AS IS" BASIS,
11  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
12  * See the License for the specific language governing permissions and
13  * limitations under the License.
14  */
15 
16 'use strict';
17 
18 var CFFEncodingMap = {
19   '0': '-reserved-',
20   '1': 'hstem',
21   '2': '-reserved-',
22   '3': 'vstem',
23   '4': 'vmoveto',
24   '5': 'rlineto',
25   '6': 'hlineto',
26   '7': 'vlineto',
27   '8': 'rrcurveto',
28   '9': '-reserved-',
29   '10': 'callsubr',
30   '11': 'return',
31   '12': {
32     '3': 'and',
33     '4': 'or',
34     '5': 'not',
35     '9': 'abs',
36     '10': 'add',
37     '11': 'div',
38     '12': 'sub',
39     '14': 'neg',
40     '15': 'eq',
41     '18': 'drop',
42     '20': 'put',
43     '21': 'get',
44     '22': 'ifelse',
45     '23': 'random',
46     '24': 'mul',
47     '26': 'sqrt',
48     '27': 'dup',
49     '28': 'exch',
50     '29': 'index',
51     '30': 'roll',
52     '34': 'hflex',
53     '35': 'flex',
54     '36': 'hflex1',
55     '37': 'flex1'
56   },
57   '13': '-reserved-',
58   '14': 'endchar',
59   '15': '-reserved-',
60   '16': '-reserved-',
61   '17': '-reserved-',
62   '18': 'hstemhm',
63   '19': 'hintmask',
64   '20': 'cntrmask',
65   '21': 'rmoveto',
66   '22': 'hmoveto',
67   '23': 'vstemhm',
68   '24': 'rcurveline',
69   '25': 'rlivecurve',
70   '26': 'vvcurveto',
71   '27': 'hhcurveto',
72   '29': 'callgsubr',
73   '30': 'vhcurveto',
74   '31': 'hvcurveto'
75 };
76 
77 var CFFDictDataMap = {
78   '0': {
79     name: 'version',
80     operand: 'SID'
81   },
82   '1': {
83     name: 'Notice',
84     operand: 'SID'
85   },
86   '2': {
87     name: 'FullName',
88     operand: 'SID'
89   },
90   '3': {
91     name: 'FamilyName',
92     operand: 'SID'
93   },
94   '4': {
95     name: 'Weight',
96     operand: 'SID'
97   },
98   '5': {
99     name: 'FontBBox',
100     operand: [0, 0, 0, 0]
101   },
102   '6': {
103     name: 'BlueValues'
104   },
105   '7': {
106     name: 'OtherBlues'
107   },
108   '8': {
109     name: 'FamilyBlues'
110   },
111   '9': {
112     name: 'FamilyOtherBlues'
113   },
114   '10': {
115     name: 'StdHW'
116   },
117   '11': {
118     name: 'StdVW'
119   },
120   '12': {
121     '0': {
122       name: 'Copyright',
123       operand: 'SID'
124     },
125     '1': {
126       name: 'IsFixedPitch',
127       operand: false
128     },
129     '2': {
130       name: 'ItalicAngle',
131       operand: 0
132     },
133     '3': {
134       name: 'UnderlinePosition',
135       operand: -100
136     },
137     '4': {
138       name: 'UnderlineThickness',
139       operand: 50
140     },
141     '5': {
142       name: 'PaintType',
143       operand: 0
144     },
145     '6': {
146       name: 'CharstringType',
147       operand: 2
148     },
149     '7': {
150       name: 'FontMatrix',
151       operand: [0.001, 0, 0, 0.001, 0, 0]
152     },
153     '8': {
154       name: 'StrokeWidth',
155       operand: 0
156     },
157     '9': {
158       name: 'BlueScale'
159     },
160     '10': {
161       name: 'BlueShift'
162     },
163     '11': {
164       name: 'BlueFuzz'
165     },
166     '12': {
167       name: 'StemSnapH'
168     },
169     '13': {
170       name: 'StemSnapV'
171     },
172     '14': {
173       name: 'ForceBold'
174     },
175     '17': {
176       name: 'LanguageGroup'
177     },
178     '18': {
179       name: 'ExpansionFactor'
180     },
181     '19': {
182       name: 'initialRandomSeed'
183     },
184     '20': {
185       name: 'SyntheticBase',
186       operand: null
187     },
188     '21': {
189       name: 'PostScript',
190       operand: 'SID'
191     },
192     '22': {
193       name: 'BaseFontName',
194       operand: 'SID'
195     },
196     '23': {
197       name: 'BaseFontBlend',
198       operand: 'delta'
199     }
200   },
201   '13': {
202     name: 'UniqueID',
203     operand: null
204   },
205   '14': {
206     name: 'XUID',
207     operand: []
208   },
209   '15': {
210     name: 'charset',
211     operand: 0
212   },
213   '16': {
214     name: 'Encoding',
215     operand: 0
216   },
217   '17': {
218     name: 'CharStrings',
219     operand: null
220   },
221   '18': {
222     name: 'Private',
223     operand: 'number number'
224   },
225   '19': {
226     name: 'Subrs'
227   },
228   '20': {
229     name: 'defaultWidthX'
230   },
231   '21': {
232     name: 'nominalWidthX'
233   }
234 };
235 
236 var CFFDictPrivateDataMap = {
237   '6': {
238     name: 'BluesValues',
239     operand: 'delta'
240   },
241   '7': {
242     name: 'OtherBlues',
243     operand: 'delta'
244   },
245   '8': {
246     name: 'FamilyBlues',
247     operand: 'delta'
248   },
249   '9': {
250     name: 'FamilyOtherBlues',
251     operand: 'delta'
252   },
253   '10': {
254     name: 'StdHW',
255     operand: null
256   },
257   '11': {
258     name: 'StdVW',
259     operand: null
260   },
261   '12': {
262     '9': {
263       name: 'BlueScale',
264       operand: 0.039625
265     },
266     '10': {
267       name: 'BlueShift',
268       operand: 7
269     },
270     '11': {
271       name: 'BlueFuzz',
272       operand: 1
273     },
274     '12': {
275       name: 'StemSnapH',
276       operand: 'delta'
277     },
278     '13': {
279       name: 'StemSnapV',
280       operand: 'delta'
281     },
282     '14': {
283       name: 'ForceBold',
284       operand: 'boolean'
285     },
286     '17': {
287       name: 'LanguageGroup',
288       operand: 0
289     },
290     '18': {
291       name: 'ExpansionFactor',
292       operand: 0.06
293     },
294     '19': {
295       name: 'initialRandomSeed',
296       operand: 0
297     }
298   },
299   '19': {
300     name: 'Subrs',
301     operand: null
302   },
303   '20': {
304     name: 'defaultWidthX',
305     operand: 0
306   },
307   '21': {
308     name: 'nominalWidthX',
309     operand: 0
310   }
311 };
File:
src/shared/fonts_utils.js
1 /* Copyright 2012 Mozilla Foundation
2  *
3  * Licensed under the Apache License, Version 2.0 (the "License");
4  * you may not use this file except in compliance with the License.
5  * You may obtain a copy of the License at
6  *
7  *     http://www.apache.org/licenses/LICENSE-2.0
8  *
9  * Unless required by applicable law or agreed to in writing, software
10  * distributed under the License is distributed on an "AS IS" BASIS,
11  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
12  * See the License for the specific language governing permissions and
13  * limitations under the License.
14  */
15 /* globals CFFDictDataMap, CFFDictPrivateDataMap, CFFEncodingMap, CFFStrings,
16            Components, Dict, dump, FormatError, netscape, Stream */
17 
18 'use strict';
19 
20 /*
21  * The Type2 reader code below is only used for debugging purpose since Type2
22  * is only a CharString format and is never used directly as a Font file.
23  *
24  * So the code here is useful for dumping the data content of a .cff file in
25  * order to investigate the similarity between a Type1 CharString and a Type2
26  * CharString or to understand the structure of the CFF format.
27  */
28 
29 /*
30  * Build a charset by assigning the glyph name and the human readable form
31  * of the glyph data.
32  */
33 function readCharset(aStream, aCharstrings) {
34   var charset = {};
35 
36   var format = aStream.getByte();
37   var count = aCharstrings.length - 1;
38   var i, sid;
39   if (format === 0) {
40     charset['.notdef'] = readCharstringEncoding(aCharstrings[0]);
41 
42     for (i = 1; i < count + 1; i++) {
43       sid = aStream.getByte() << 8 | aStream.getByte();
44       charset[CFFStrings[sid]] = readCharstringEncoding(aCharstrings[i]);
45     }
46   } else if (format === 1) {
47     for (i = 1; i < count + 1; i++) {
48       var first = aStream.getByte();
49       first = (first << 8) | aStream.getByte();
50       var numLeft = aStream.getByte();
51       for (var j = 0; j <= numLeft; j++) {
52         sid = first++;
53         charset[CFFStrings[sid]] = readCharstringEncoding(aCharstrings[j]);
54       }
55     }
56   } else {
57     throw new FormatError('Invalid charset format');
58   }
59 
60   return charset;
61 }
62 
63 /*
64  * Take a Type2 binary charstring as input and transform it to a human
65  * readable representation as specified by the 'The Type 2 Charstring Format',
66  * chapter 3.1.
67  */
68 function readCharstringEncoding(aString) {
69   if (!aString) {
70     return '';
71   }
72 
73   var charstringTokens = [];
74 
75   var count = aString.length;
76   for (var i = 0; i < count; ) {
77     var value = aString[i++] | 0;
78     var token = null;
79 
80     if (value < 0) {
81       continue;
82     } else if (value <= 11) {
83       token = CFFEncodingMap[value];
84     } else if (value === 12) {
85       token = CFFEncodingMap[value][aString[i++]];
86     } else if (value <= 18) {
87       token = CFFEncodingMap[value];
88     } else if (value <= 20) {
89       ++i; // var mask = aString[i++];
90       token = CFFEncodingMap[value];
91     } else if (value <= 27) {
92       token = CFFEncodingMap[value];
93     } else if (value === 28) {
94       token = aString[i++] << 8 | aString[i++];
95     } else if (value <= 31) {
96       token = CFFEncodingMap[value];
97     } else if (value < 247) {
98       token = parseInt(value, 10) - 139;
99     } else if (value < 251) {
100       token = (value - 247) * 256 + aString[i++] + 108;
101     } else if (value < 255) {
102       token = -(value - 251) * 256 - aString[i++] - 108;
103     } else { // value === 255
104       token = aString[i++] << 24 | aString[i++] << 16 |
105               aString[i++] << 8 | aString[i];
106     }
107 
108     charstringTokens.push(token);
109   }
110 
111   return charstringTokens;
112 }
113 
114 
115 /*
116  * Take a binary DICT Data as input and transform it into a human readable
117  * form as specified by 'The Compact Font Format Specification', chapter 5.
118  */
119 function readFontDictData(aString, aMap) {
120   var fontDictDataTokens = [];
121 
122   var count = aString.length;
123   for (var i = 0; i < count; ) {
124     var value = aString[i++] | 0;
125     var token = null;
126 
127     if (value === 12) {
128       token = aMap[value][aString[i++]];
129     } else if (value === 28) {
130       token = aString[i++] << 8 | aString[i++];
131     } else if (value === 29) {
132       token = aString[i++] << 24 |
133               aString[i++] << 16 |
134               aString[i++] << 8 |
135               aString[i++];
136     } else if (value === 30) {
137       token = '';
138       var parsed = false;
139       while (!parsed) {
140         var octet = aString[i++];
141 
142         var nibbles = [parseInt(octet / 16, 10), parseInt(octet % 16, 10)];
143         for (var j = 0; j < nibbles.length; j++) {
144           var nibble = nibbles[j];
145           switch (nibble) {
146             case 0xA:
147               token += '.';
148               break;
149             case 0xB:
150               token += 'E';
151               break;
152             case 0xC:
153               token += 'E-';
154               break;
155             case 0xD:
156               break;
157             case 0xE:
158               token += '-';
159               break;
160             case 0xF:
161               parsed = true;
162               break;
163             default:
164               token += nibble;
165               break;
166           }
167         }
168       }
169       token = parseFloat(token);
170     } else if (value <= 31) {
171       token = aMap[value];
172     } else if (value <= 246) {
173       token = parseInt(value, 10) - 139;
174     } else if (value <= 250) {
175       token = (value - 247) * 256 + aString[i++] + 108;
176     } else if (value <= 254) {
177       token = -(value - 251) * 256 - aString[i++] - 108;
178     } else if (value === 255) {
179       throw new FormatError('255 is not a valid DICT command');
180     }
181 
182     fontDictDataTokens.push(token);
183   }
184 
185   return fontDictDataTokens;
186 }
187 
188 /*
189  * Take a stream as input and return an array of objects.
190  * In CFF an INDEX is a structure with the following format:
191  *  {
192  *    count: 2 bytes (Number of objects stored in INDEX),
193  *    offsize: 1 byte (Offset array element size),
194  *    offset: [count + 1] bytes (Offsets array),
195  *    data: - (Objects data)
196  *  }
197  *
198  *  More explanation are given in the 'CFF Font Format Specification',
199  *  chapter 5.
200  */
201 function readFontIndexData(aStream, aIsByte) {
202   var count = aStream.getByte() << 8 | aStream.getByte();
203   var offsize = aStream.getByte();
204 
205   function getNextOffset() {
206     switch (offsize) {
207       case 0:
208         return 0;
209       case 1:
210         return aStream.getByte();
211       case 2:
212         return aStream.getByte() << 8 | aStream.getByte();
213       case 3:
214         return aStream.getByte() << 16 | aStream.getByte() << 8 |
215                aStream.getByte();
216       case 4:
217       return aStream.getByte() << 24 | aStream.getByte() << 16 |
218              aStream.getByte() << 8 | aStream.getByte();
219     }
220     throw new FormatError(offsize + ' is not a valid offset size');
221   }
222 
223   var offsets = [];
224   var i;
225   for (i = 0; i < count + 1; i++) {
226     offsets.push(getNextOffset());
227   }
228 
229   dump('Found ' + count + ' objects at offsets :' +
230        offsets + ' (offsize: ' + offsize + ')');
231 
232   // Now extract the objects
233   var relativeOffset = aStream.pos;
234   var objects = [];
235   for (i = 0; i < count; i++) {
236     var offset = offsets[i];
237     aStream.pos = relativeOffset + offset - 1;
238 
239     var data = [];
240     var length = offsets[i + 1] - 1;
241     for (var j = offset - 1; j < length; j++) {
242       data.push(aIsByte ? aStream.getByte() : aStream.getChar());
243     }
244     objects.push(data);
245   }
246 
247   return objects;
248 }
249 
250 var Type2Parser = function type2Parser(aFilePath) {
251   var font = new Dict(null);
252 
253   var xhr = new XMLHttpRequest();
254   xhr.open('GET', aFilePath, false);
255   xhr.responseType = 'arraybuffer';
256   xhr.expected = document.URL.startsWith('file:') ? 0 : 200;
257   xhr.send(null);
258   this.data = new Stream(xhr.response);
259 
260   // Turn on this flag for additional debugging logs
261   var debug = false;
262 
263   function dump(aStr) {
264     if (debug) {
265       console.log(aStr);
266     }
267   }
268 
269   function parseAsToken(aString, aMap) {
270     var decoded = readFontDictData(aString, aMap);
271 
272     var stack = [];
273     var count = decoded.length;
274     for (var i = 0; i < count; i++) {
275       var token = decoded[i];
276       if (typeof token === "number") {
277         stack.push(token);
278       } else {
279         switch (token.operand) {
280           case 'SID':
281             font.set(token.name, CFFStrings[stack.pop()]);
282             break;
283           case 'number number':
284             font.set(token.name, {
285               offset: stack.pop(),
286               size: stack.pop()
287             });
288             break;
289           case 'boolean':
290             font.set(token.name, stack.pop());
291             break;
292           case 'delta':
293             font.set(token.name, stack.pop());
294             break;
295           default:
296             if (token.operand?.length) {
297               var array = [];
298               for (var j = 0; j < token.operand.length; j++) {
299                 array.push(stack.pop());
300               }
301               font.set(token.name, array);
302             } else {
303               font.set(token.name, stack.pop());
304             }
305             break;
306         }
307       }
308     }
309   }
310 
311   this.parse = function type2ParserParse(aStream) {
312     font.set('major', aStream.getByte());
313     font.set('minor', aStream.getByte());
314     font.set('hdrSize', aStream.getByte());
315     font.set('offsize', aStream.getByte());
316 
317     // Read the NAME Index
318     dump('Reading Index: Names');
319     font.set('Names', readFontIndexData(aStream));
320     dump('Names: ' + font.get('Names'));
321 
322     // Read the Top Dict Index
323     dump('Reading Index: TopDict');
324     var topDict = readFontIndexData(aStream, true);
325     dump('TopDict: ' + topDict);
326 
327     // Read the String Index
328     dump('Reading Index: Strings');
329     var strings = readFontIndexData(aStream);
330     dump('strings: ' + strings);
331 
332     // Fill up the Strings dictionary with the new unique strings
333     var i;
334     for (i = 0; i < strings.length; i++) {
335       CFFStrings.push(strings[i].join(''));
336     }
337 
338     // Parse the TopDict operator
339     var count = topDict.length;
340     for (i = 0; i < count; i++) {
341       parseAsToken(topDict[i], CFFDictDataMap);
342     }
343 
344     // Read the Global Subr Index that comes just after the Strings Index
345     // (cf. "The Compact Font Format Specification" Chapter 16)
346     dump('Reading Global Subr Index');
347     var subrs = readFontIndexData(aStream, true);
348     dump(subrs);
349 
350     // Reading Private Dict
351     var priv = font.get('Private');
352     dump('Reading Private Dict (offset: ' + priv.offset +
353         ' size: ' + priv.size + ')');
354     aStream.pos = priv.offset;
355 
356     var privateDict = [];
357     for (i = 0; i < priv.size; i++) {
358       privateDict.push(aStream.getByte());
359     }
360     dump('privateData:' + privateDict);
361     parseAsToken(privateDict, CFFDictPrivateDataMap);
362 
363     font.forEach(function(key, value) {
364       dump(key + '::' + value);
365     });
366 
367     // Read CharStrings Index
368     var charStringsOffset = font.get('CharStrings');
369     dump('Read CharStrings Index (offset: ' + charStringsOffset + ')');
370     aStream.pos = charStringsOffset;
371     var charStrings = readFontIndexData(aStream, true);
372 
373     // Read Charset
374     dump('Read Charset for ' + charStrings.length + ' glyphs');
375     var charsetEntry = font.get('charset');
376     if (charsetEntry === 0) {
377       throw new FormatError('Need to support CFFISOAdobeCharset');
378     } else if (charsetEntry === 1) {
379       throw new FormatError('Need to support CFFExpert');
380     } else if (charsetEntry === 2) {
381       throw new FormatError('Need to support CFFExpertSubsetCharset');
382     } else {
383       aStream.pos = charsetEntry;
384       readCharset(aStream, charStrings);
385     }
386   };
387 };
388 
389 /*
390  * To try the Type2 decoder on a local file in the current directory:
391  *
392  *  var cff = new Type2Parser("file.cff");
393  *  cff.parse(this.data);
394  *
395  * To try the Type2 decoder on a custom built CFF array:
396  *
397  *  var file = new Uint8Array(cffFileArray, 0, cffFileSize);
398  *  var parser = new Type2Parser();
399  *  parser.parse(new Stream(file));
400  */
401 
402 /*
403  * Write to a file to the disk (works only on Firefox in privilege mode)
404  * but this is useful for dumping a font file to the disk and check with
405  * fontforge or the ots program what's wrong with the file.
406  *
407  * writeToFile(fontData, "/tmp/pdf.js." + fontCount + ".cff");
408  */
409 function writeToFile(aBytes, aFilePath) {
410   if (!('netscape' in window)) {
411     return;
412   }
413 
414   netscape.security.PrivilegeManager.enablePrivilege('UniversalXPConnect');
415   var Cc = Components.classes,
416       Ci = Components.interfaces;
417   var file = Cc['@mozilla.org/file/local;1'].createInstance(Ci.nsILocalFile);
418   file.initWithPath(aFilePath);
419 
420   var stream = Cc['@mozilla.org/network/file-output-stream;1']
421                  .createInstance(Ci.nsIFileOutputStream);
422   stream.init(file, 0x04 | 0x08 | 0x20, 0x180, 0);
423 
424   var bos = Cc['@mozilla.org/binaryoutputstream;1']
425               .createInstance(Ci.nsIBinaryOutputStream);
426   bos.setOutputStream(stream);
427   bos.writeByteArray(aBytes, aBytes.length);
428   stream.close();
429 }
</code>

Test file:
<test_file>
File:
test/unit/crypto_spec.js
/* Copyright 2017 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import {
  AES128Cipher,
  AES256Cipher,
  ARCFourCipher,
  calculateMD5,
  calculateSHA256,
  calculateSHA384,
  calculateSHA512,
  CipherTransformFactory,
  PDF17,
  PDF20,
} from "../../src/core/crypto.js";
import { Dict, Name } from "../../src/core/primitives.js";
import {
  PasswordException,
  PasswordResponses,
  stringToBytes,
} from "../../src/shared/util.js";
</test_file>

Your task:
You are a software tester at pdf.js.
1. Examine the existing test file. You may reuse any imports, helpers or setup blocks it already has.
2. Write exactly one javascript test `it("...", async () => {...})` block.
3. Your test must fail on the code before the patch, and pass after, hence the test will verify that the patch resolves the issue.
4. The test must be self-contained and to-the-point.
5. If you need something new use only the provided imports (respect the paths exactly how they are given) by importing dynamically for compatibility with Node.js — no new dependencies. 
6. Return only the javascript code for the new `it(...)` block (no comments or explanations).

Example structure:
it("should <describe behavior>", async () => {
  const { example } = await import("../../src/core/example.js");
  <initialize required variables>;
  <define expected variable>;
  <generate actual variables>;
  <compare expected with actual>;
});

