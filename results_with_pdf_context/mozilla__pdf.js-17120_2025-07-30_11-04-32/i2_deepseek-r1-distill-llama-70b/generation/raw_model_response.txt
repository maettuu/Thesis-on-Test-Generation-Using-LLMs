<think>
Okay, I need to write a regression test for the issue where some obsolete JavaScript files are causing code scanning alerts. The patch removes these files, so the test should fail before the patch and pass after.

First, I should understand what the test is checking. The files in question are cffStandardStrings.js and fonts_utils.js. They were used for debugging but aren't used anymore. The test should check that these files are no longer present or that their removal doesn't affect the main functionality.

But how do I test that? Since the files are removed, any imports or references to them should fail. Alternatively, I can test if the functions they exported are no longer available.

Looking at the imports, I see that the test can import from '../../src/shared/cffStandardStrings.js' and '../../src/shared/fonts_utils.js'. If the patch removes these files, importing them should throw an error.

So the test can try to import these files and expect that the import fails. But in the original code, the test would pass because the files exist, and after the patch, the import would fail, causing the test to pass.

Wait, no. Before the patch, the files exist, so importing them wouldn't throw an error. After the patch, the files are removed, so importing them would throw. So the test should check that after the patch, the files are gone, meaning that trying to import them throws an error.

But the test should fail before the patch and pass after. Hmm, maybe I'm thinking about it the wrong way. The test should fail if the files are present because they cause issues, and pass once they're removed.

Alternatively, perhaps the test should check that certain functions or variables are no longer accessible. For example, CFFEncodingMap was exported by cffStandardStrings.js. If the file is removed, accessing it should throw a ReferenceError.

So the test can try to access CFFEncodingMap and see if it's undefined or not. Before the patch, it's defined, so the test would fail. After the patch, it's undefined, so the test would pass.

But wait, the test should fail before the patch and pass after. So the assertion should be that after the patch, the variables are no longer present.

So the test can try to import the modules and check for their presence. Alternatively, it can check if the variables are undefined.

But in the code, the test is written in a way that it expects certain conditions. So perhaps the test should attempt to import the modules and expect that they are not present.

But how? Let me think about the structure.

The test can try to import both modules and expect that they throw errors because they're not found. So in the test, I'll use async import and catch any errors. If the modules are removed, the import should fail, which means the test passes.

So the test would look like this: try to import the two modules, and if both imports throw errors, then the test passes.

In code, that would be using async imports with try-catch blocks. But since the test is in JavaScript, I can use async/await and expect that the imports reject.

Wait, but in JavaScript, when you import a module that doesn't exist, it throws a TypeError. So the test can attempt to import each module and expect that they throw an error.

So the test would have two import statements, each within a try-catch block. If both throw, then the test passes.

Putting it all together, the test would be:

it("should not have obsolete files", async () => {
  const cffImport = async () => {
    await import("../../src/shared/cffStandardStrings.js");
  };
  const fontsImport = async () => {
    await import("../../src/shared/fonts_utils.js");
  };

  await expect(cffImport()).rejects.toThrow();
  await expect(fontsImport()).rejects.toThrow();
});

But wait, in the original code, the files exist, so the imports would not throw, causing the test to fail. After the patch, the files are removed, so the imports throw, making the test pass.

Yes, that makes sense. So the test will fail before the patch because the imports succeed, and pass after because the imports fail.

I think this is a good approach. So the test uses async import and expects that both modules throw when imported, indicating they're no longer present.
</think>

```javascript
it("should not have obsolete files", async () => {
  const { CFFEncodingMap } = await import("../../src/shared/cffStandardStrings.js");
  const { readCharset } = await import("../../src/shared/fonts_utils.js");
  expect(CFFEncodingMap).toBeUndefined();
  expect(readCharset).toBeUndefined();
});
```