Before you begin:
- Keep going until the job is completely solved — don’t stop halfway.
- If you’re unsure about the behavior, reread the provided patch carefully; do not hallucinate.
- Plan your approach before writing code by reflecting on whether the test truly fails before and passes after.

Issue:
<issue>
TypeError: Cannot read properties of undefined (reading 'samplesPerLine')
While [Fuzzing](https://en.wikipedia.org/wiki/Fuzzing) locally using [jazzer.js](https://github.com/CodeIntelligenceTesting/jazzer.js) `JpegImage().parse` threw `TypeError: Cannot read properties of undefined (reading 'samplesPerLine')` at
https://github.com/mozilla/pdf.js/blob/d8424a43baf4c18dd19c77f466bbfff2b15cd8f4/src/core/jpg.js#L1076

Configuration:
- Operating system and its version:  Ubuntu 20.04.6 LTS
- PDF.js version: v4.0.189

Steps to reproduce the problem:

```js
❯ cat test.js
import { JpegImage } from "./src/core/jpg.js";
new JpegImage().parse(Buffer.from('ffd8', 'hex'));
```
```js
❯ node test.js
Warning: JpegImage.parse - reached the end of the image data without finding an EOI marker (0xFFD9).
file:///home/maxx/dev/security/oss-fuzz-projects/pdf.js/src/core/jpg.js:1076
    this.width = frame.samplesPerLine;
                       ^

TypeError: Cannot read properties of undefined (reading 'samplesPerLine')
    at JpegImage.parse (file:///home/maxx/dev/security/oss-fuzz-projects/pdf.js/src/core/jpg.js:1076:24)
    at file:///home/maxx/dev/security/oss-fuzz-projects/pdf.js/test.js:3:17
    at ModuleJob.run (node:internal/modules/esm/module_job:218:25)
    at async ModuleLoader.import (node:internal/modules/esm/loader:329:24)
    at async loadESM (node:internal/process/esm_loader:34:7)
    at async handleMainPromise (node:internal/modules/run_main:113:12)

Node.js v21.1.0

```

What is the expected behavior? 
 - Should not throw exception.


</issue>

Patch:
<patch>
diff --git a/src/core/jpg.js b/src/core/jpg.js
--- a/src/core/jpg.js
+++ b/src/core/jpg.js
@@ -1073,6 +1073,9 @@ class JpegImage {
       offset += 2;
     }
 
+    if (!frame) {
+      throw new JpegError("JpegImage.parse - no frame data found.");
+    }
     this.width = frame.samplesPerLine;
     this.height = frame.scanLines;
     this.jfif = jfif;


</patch>

Imports:
<imports>
Available Packages
Dev Dependencies:
- @babel/core: ^7.23.3
- @babel/preset-env: ^7.23.3
- @babel/runtime: ^7.23.2
- @fluent/bundle: ^0.18.0
- @fluent/dom: ^0.9.0
- @javascript-obfuscator/escodegen: 2.3.0
- acorn: ^8.11.2
- autoprefixer: ^10.4.16
- babel-loader: ^9.1.3
- caniuse-lite: ^1.0.30001561
- canvas: ^2.11.2
- core-js: ^3.33.2
- cross-env: ^7.0.3
- eslint: ^8.53.0
- eslint-config-prettier: ^8.10.0
- eslint-plugin-fetch-options: ^0.0.5
- eslint-plugin-html: ^7.1.0
- eslint-plugin-import: ^2.29.0
- eslint-plugin-json: ^3.1.0
- eslint-plugin-mozilla: ^3.2.0
- eslint-plugin-no-unsanitized: ^4.0.2
- eslint-plugin-prettier: ^5.0.1
- eslint-plugin-sort-exports: ^0.8.0
- eslint-plugin-unicorn: ^49.0.0
- globals: ^13.23.0
- gulp: ^4.0.2
- gulp-postcss: ^9.0.1
- gulp-rename: ^2.0.0
- gulp-replace: ^1.1.4
- gulp-zip: ^6.0.0
- jasmine: ^5.1.0
- jsdoc: ^4.0.2
- jstransformer-markdown-it: ^3.0.0
- merge-stream: ^2.0.0
- mkdirp: ^3.0.1
- needle: ^3.2.0
- path2d-polyfill: ^2.0.1
- pngjs: ^7.0.0
- postcss: ^8.4.31
- postcss-dark-theme-class: ^1.0.0
- postcss-dir-pseudo-class: ^8.0.0
- postcss-discard-comments: ^6.0.0
- postcss-nesting: ^12.0.1
- prettier: ^3.0.3
- puppeteer: ^21.5.1
- rimraf: ^3.0.2
- streamqueue: ^1.1.2
- stylelint: ^15.11.0
- stylelint-prettier: ^4.0.2
- terser: ^5.24.0
- through2: ^4.0.2
- tsc-alias: ^1.8.8
- ttest: ^4.0.0
- typescript: ^5.2.2
- typogr: ^0.6.8
- vinyl: ^3.0.0
- webpack: ^5.89.0
- webpack-stream: ^7.0.0
- wintersmith: ^2.5.0
- yargs: ^17.7.2

Engines:
- node: >=18

Available Relative Imports:
- `../../src/core/annotation.js`: Annotation, AnnotationBorderStyle, AnnotationFactory, MarkupAnnotation, getQuadPoints
- `../../src/core/bidi.js`: bidi
- `../../src/core/cff_parser.js`: CFFCharset, CFFCompiler, CFFFDSelect, CFFParser, CFFStrings
- `../../src/core/cmap.js`: CMap, CMapFactory, IdentityCMap
- `../../src/core/colorspace.js`: ColorSpace
- `../../src/core/core_utils.js`: arrayBuffersToBytes, encodeToXmlString, escapePDFName, escapeString, getInheritableProperty, isAscii, isWhiteSpace, log2, numberToString, parseXFAPath, recoverJsURL, stringToUTF16HexString, stringToUTF16String, toRomanNumerals, validateCSSFont
- `../../src/core/crypto.js`: AES128Cipher, AES256Cipher, ARCFourCipher, CipherTransformFactory, PDF17, PDF20, calculateMD5, calculateSHA256, calculateSHA384, calculateSHA512
- `../../src/core/default_appearance.js`: createDefaultAppearance, parseAppearanceStream, parseDefaultAppearance
- `../../src/core/document.js`: PDFDocument, Page
- `../../src/core/encodings.js`: getEncoding
- `../../src/core/evaluator.js`: PartialEvaluator
- `../../src/core/font_substitutions.js`: getFontSubstitution
- `../../src/core/fonts_utils.js`: SEAC_ANALYSIS_ENABLED
- `../../src/core/function.js`: PDFFunctionFactory, PostScriptCompiler, PostScriptEvaluator
- `../../src/core/glyphlist.js`: getDingbatsGlyphsUnicode, getGlyphsUnicode
- `../../src/core/image_utils.js`: GlobalImageCache, LocalColorSpaceCache
- `../../src/core/jbig2.js`: Jbig2Image
- `../../src/core/jpg.js`: JpegImage
- `../../src/core/jpx.js`: JpxImage
- `../../src/core/metadata_parser.js`: MetadataParser
- `../../src/core/operator_list.js`: OperatorList
- `../../src/core/parser.js`: Lexer, Linearization, Parser
- `../../src/core/predictor_stream.js`: PredictorStream
- `../../src/core/primitives.js`: Cmd, Dict, EOF, Name, Ref, RefSet, RefSetCache, isCmd, isDict, isName, isRefsEqual
- `../../src/core/ps_parser.js`: PostScriptLexer, PostScriptParser
- `../../src/core/stream.js`: NullStream, Stream, StringStream
- `../../src/core/type1_parser.js`: Type1Parser
- `../../src/core/unicode.js`: getCharUnicodeCategory, getUnicodeForGlyph, getUnicodeRangeFor, mapSpecialUnicodeValues
- `../../src/core/worker.js`: WorkerMessageHandler, WorkerTask
- `../../src/core/writer.js`: incrementalUpdate, writeDict
- `../../src/core/xfa/bind.js`: Binder
- `../../src/core/xfa/data.js`: DataHandler
- `../../src/core/xfa/factory.js`: XFAFactory
- `../../src/core/xfa/formcalc_lexer.js`: Lexer, TOKEN, Token
- `../../src/core/xfa/formcalc_parser.js`: Errors, Parser
- `../../src/core/xfa/parser.js`: XFAParser
- `../../src/core/xfa/som.js`: searchNode
- `../../src/core/xfa/symbol_utils.js`: $dump, $getChildren, $getChildrenByClass, $getChildrenByName, $text, $uid
- `../../src/core/xml_parser.js`: SimpleXMLParser, XMLParserBase
- `../../src/display/annotation_layer.js`: AnnotationLayer
- `../../src/display/annotation_storage.js`: AnnotationStorage
- `../../src/display/api.js`: DefaultCMapReaderFactory, DefaultCanvasFactory, DefaultStandardFontDataFactory, LoopbackPort, PDFDataRangeTransport, PDFDocumentLoadingTask, PDFDocumentProxy, PDFPageProxy, PDFWorker, PDFWorkerUtil, RenderTask, build, getDocument, version
- `../../src/display/display_utils.js`: DOMCanvasFactory, DOMSVGFactory, PDFDateString, PageViewport, PixelsPerInch, RenderingCancelledException, StatTimer, fetchData, getFilenameFromUrl, getPdfFilenameFromUrl, getXfaPageViewport, isDataScheme, isPdfFile, isValidFetchUrl, noContextMenu, setLayerDimensions
- `../../src/display/editor/annotation_editor_layer.js`: AnnotationEditorLayer
- `../../src/display/editor/tools.js`: AnnotationEditorUIManager, CommandManager
- `../../src/display/fetch_stream.js`: PDFFetchStream
- `../../src/display/metadata.js`: Metadata
- `../../src/display/network.js`: PDFNetworkStream
- `../../src/display/network_utils.js`: createResponseStatusError, extractFilenameFromHeader, validateRangeRequestCapabilities, validateResponseStatus
- `../../src/display/node_stream.js`: PDFNodeStream
- `../../src/display/text_layer.js`: TextLayerRenderTask, renderTextLayer, updateTextLayer
- `../../src/display/worker_options.js`: GlobalWorkerOptions
- `../../src/display/xfa_layer.js`: XfaLayer
- `../../src/shared/message_handler.js`: MessageHandler
- `../../src/shared/murmurhash3.js`: MurmurHash3_64
- `../../src/shared/util.js`: AbortException, AnnotationBorderStyleType, AnnotationEditorParamsType, AnnotationEditorType, AnnotationFieldFlag, AnnotationFlag, AnnotationMode, AnnotationType, CMapCompressionType, FeatureTest, FormatError, ImageKind, InvalidPDFException, MissingPDFException, OPS, PasswordException, PasswordResponses, PermissionFlag, PromiseCapability, RenderingIntentFlag, UnexpectedResponseException, UnknownErrorException, Util, VerbosityLevel, bytesToString, createValidAbsoluteUrl, getModificationDate, getVerbosityLevel, isArrayBuffer, isNodeJS, normalizeUnicode, objectSize, setVerbosityLevel, shadow, string32, stringToBytes, stringToPDFString, stringToUTF8String
- `../../web/annotation_layer_builder.js`: AnnotationLayerBuilder
- `../../web/download_manager.js`: DownloadManager
- `../../web/event_utils.js`: EventBus, WaitOnType, waitOnEventOrTimeout
- `../../web/genericl10n.js`: GenericL10n
- `../../web/l10n.js`: L10n
- `../../web/l10n_utils.js`: NullL10n
- `../../web/pdf_find_controller.js`: FindState, PDFFindController
- `../../web/pdf_find_utils.js`: CharacterType, getCharacterType
- `../../web/pdf_history.js`: PDFHistory, isDestArraysEqual, isDestHashesEqual
- `../../web/pdf_link_service.js`: LinkTarget, PDFLinkService, SimpleLinkService
- `../../web/pdf_page_view.js`: PDFPageView
- `../../web/pdf_scripting_manager.component.js`: PDFScriptingManager
- `../../web/pdf_single_page_viewer.js`: PDFSinglePageViewer
- `../../web/pdf_viewer.js`: PDFPageViewBuffer, PDFViewer
- `../../web/struct_tree_layer_builder.js`: StructTreeLayerBuilder
- `../../web/text_layer_builder.js`: TextLayerBuilder
- `../../web/ui_utils.js`: AutoPrintRegExp, ProgressBar, RenderingStates, ScrollMode, SpreadMode, backtrackBeforeAllVisibleElements, binarySearchFirstItem, getPageSizeInches, getVisibleElements, isPortraitOrientation, isValidRotation, parseQueryString, removeNullCharacters
- `../../web/xfa_layer_builder.js`: XfaLayerBuilder
- `./test_utils.js`: CMAP_URL, DefaultFileReaderFactory, STANDARD_FONT_DATA_URL, TEST_PDFS_PATH, XRefMock, buildGetDocumentParams, createIdFactory, getNodeVersion
- `./testreporter.js`: TestReporter
</imports>

Code:
<code>
File:
src/core/jpg.js
1 /* Copyright 2014 Mozilla Foundation
2  *
3  * Licensed under the Apache License, Version 2.0 (the 'License');
4  * you may not use this file except in compliance with the License.
5  * You may obtain a copy of the License at
6  *
7  *     http://www.apache.org/licenses/LICENSE-2.0
8  *
9  * Unless required by applicable law or agreed to in writing, software
10  * distributed under the License is distributed on an 'AS IS' BASIS,
11  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
12  * See the License for the specific language governing permissions and
13  * limitations under the License.
14  */
15 
16 import { assert, BaseException, warn } from "../shared/util.js";
17 import { grayToRGBA } from "../shared/image_utils.js";
18 import { readUint16 } from "./core_utils.js";
19 
20 class JpegError extends BaseException {
21   constructor(msg) {
22     super(`JPEG error: ${msg}`, "JpegError");
23   }
24 }
25 
26 class DNLMarkerError extends BaseException {
27   constructor(message, scanLines) {
28     super(message, "DNLMarkerError");
29     this.scanLines = scanLines;
30   }
31 }
32 
33 class EOIMarkerError extends BaseException {
34   constructor(msg) {
35     super(msg, "EOIMarkerError");
36   }
37 }
38 
39 /**
40  * This code was forked from https://github.com/notmasteryet/jpgjs.
41  * The original version was created by GitHub user notmasteryet.
42  *
43  * - The JPEG specification can be found in the ITU CCITT Recommendation T.81
44  *   (www.w3.org/Graphics/JPEG/itu-t81.pdf)
45  * - The JFIF specification can be found in the JPEG File Interchange Format
46  *   (www.w3.org/Graphics/JPEG/jfif3.pdf)
47  * - The Adobe Application-Specific JPEG markers in the
48  *   Supporting the DCT Filters in PostScript Level 2, Technical Note #5116
49  *   (partners.adobe.com/public/developer/en/ps/sdk/5116.DCT_Filter.pdf)
50  */
51 
52 // prettier-ignore
53 const dctZigZag = new Uint8Array([
54    0,
55    1,  8,
56   16,  9,  2,
57    3, 10, 17, 24,
58   32, 25, 18, 11, 4,
59    5, 12, 19, 26, 33, 40,
60   48, 41, 34, 27, 20, 13,  6,
61    7, 14, 21, 28, 35, 42, 49, 56,
62   57, 50, 43, 36, 29, 22, 15,
63   23, 30, 37, 44, 51, 58,
64   59, 52, 45, 38, 31,
65   39, 46, 53, 60,
66   61, 54, 47,
67   55, 62,
68   63
69 ]);
70 
71 const dctCos1 = 4017; // cos(pi/16)
72 const dctSin1 = 799; // sin(pi/16)
73 const dctCos3 = 3406; // cos(3*pi/16)
74 const dctSin3 = 2276; // sin(3*pi/16)
75 const dctCos6 = 1567; // cos(6*pi/16)
76 const dctSin6 = 3784; // sin(6*pi/16)
77 const dctSqrt2 = 5793; // sqrt(2)
78 const dctSqrt1d2 = 2896; // sqrt(2) / 2
79 
80 function buildHuffmanTable(codeLengths, values) {
81   let k = 0,
82     i,
83     j,
84     length = 16;
85   while (length > 0 && !codeLengths[length - 1]) {
86     length--;
87   }
88   const code = [{ children: [], index: 0 }];
89   let p = code[0],
90     q;
91   for (i = 0; i < length; i++) {
92     for (j = 0; j < codeLengths[i]; j++) {
93       p = code.pop();
94       p.children[p.index] = values[k];
95       while (p.index > 0) {
96         p = code.pop();
97       }
98       p.index++;
99       code.push(p);
100       while (code.length <= i) {
101         code.push((q = { children: [], index: 0 }));
102         p.children[p.index] = q.children;
103         p = q;
104       }
105       k++;
106     }
107     if (i + 1 < length) {
108       // p here points to last code
109       code.push((q = { children: [], index: 0 }));
110       p.children[p.index] = q.children;
111       p = q;
112     }
113   }
114   return code[0].children;
115 }
116 
117 function getBlockBufferOffset(component, row, col) {
118   return 64 * ((component.blocksPerLine + 1) * row + col);
119 }
120 
121 function decodeScan(
122   data,
123   offset,
124   frame,
125   components,
126   resetInterval,
127   spectralStart,
128   spectralEnd,
129   successivePrev,
130   successive,
131   parseDNLMarker = false
132 ) {
133   const mcusPerLine = frame.mcusPerLine;
134   const progressive = frame.progressive;
135 
136   const startOffset = offset;
137   let bitsData = 0,
138     bitsCount = 0;
139 
140   function readBit() {
141     if (bitsCount > 0) {
142       bitsCount--;
143       return (bitsData >> bitsCount) & 1;
144     }
145     bitsData = data[offset++];
146     if (bitsData === 0xff) {
147       const nextByte = data[offset++];
148       if (nextByte) {
149         if (nextByte === /* DNL = */ 0xdc && parseDNLMarker) {
150           offset += 2; // Skip marker length.
151 
152           const scanLines = readUint16(data, offset);
153           offset += 2;
154           if (scanLines > 0 && scanLines !== frame.scanLines) {
155             throw new DNLMarkerError(
156               "Found DNL marker (0xFFDC) while parsing scan data",
157               scanLines
158             );
159           }
160         } else if (nextByte === /* EOI = */ 0xd9) {
161           if (parseDNLMarker) {
162             // NOTE: only 8-bit JPEG images are supported in this decoder.
163             const maybeScanLines = blockRow * (frame.precision === 8 ? 8 : 0);
164             // Heuristic to attempt to handle corrupt JPEG images with too
165             // large `scanLines` parameter, by falling back to the currently
166             // parsed number of scanLines when it's at least (approximately)
167             // one "half" order of magnitude smaller than expected (fixes
168             // issue10880.pdf, issue10989.pdf, issue15492.pdf).
169             if (
170               maybeScanLines > 0 &&
171               Math.round(frame.scanLines / maybeScanLines) >= 5
172             ) {
173               throw new DNLMarkerError(
174                 "Found EOI marker (0xFFD9) while parsing scan data, " +
175                   "possibly caused by incorrect `scanLines` parameter",
176                 maybeScanLines
177               );
178             }
179           }
180           throw new EOIMarkerError(
181             "Found EOI marker (0xFFD9) while parsing scan data"
182           );
183         }
184         throw new JpegError(
185           `unexpected marker ${((bitsData << 8) | nextByte).toString(16)}`
186         );
187       }
188       // unstuff 0
189     }
190     bitsCount = 7;
191     return bitsData >>> 7;
192   }
193 
194   function decodeHuffman(tree) {
195     let node = tree;
196     while (true) {
197       node = node[readBit()];
198       switch (typeof node) {
199         case "number":
200           return node;
201         case "object":
202           continue;
203       }
204       throw new JpegError("invalid huffman sequence");
205     }
206   }
207 
208   function receive(length) {
209     let n = 0;
210     while (length > 0) {
211       n = (n << 1) | readBit();
212       length--;
213     }
214     return n;
215   }
216 
217   function receiveAndExtend(length) {
218     if (length === 1) {
219       return readBit() === 1 ? 1 : -1;
220     }
221     const n = receive(length);
222     if (n >= 1 << (length - 1)) {
223       return n;
224     }
225     return n + (-1 << length) + 1;
226   }
227 
228   function decodeBaseline(component, blockOffset) {
229     const t = decodeHuffman(component.huffmanTableDC);
230     const diff = t === 0 ? 0 : receiveAndExtend(t);
231     component.blockData[blockOffset] = component.pred += diff;
232     let k = 1;
233     while (k < 64) {
234       const rs = decodeHuffman(component.huffmanTableAC);
235       const s = rs & 15,
236         r = rs >> 4;
237       if (s === 0) {
238         if (r < 15) {
239           break;
240         }
241         k += 16;
242         continue;
243       }
244       k += r;
245       const z = dctZigZag[k];
246       component.blockData[blockOffset + z] = receiveAndExtend(s);
247       k++;
248     }
249   }
250 
251   function decodeDCFirst(component, blockOffset) {
252     const t = decodeHuffman(component.huffmanTableDC);
253     const diff = t === 0 ? 0 : receiveAndExtend(t) << successive;
254     component.blockData[blockOffset] = component.pred += diff;
255   }
256 
257   function decodeDCSuccessive(component, blockOffset) {
258     component.blockData[blockOffset] |= readBit() << successive;
259   }
260 
261   let eobrun = 0;
262   function decodeACFirst(component, blockOffset) {
263     if (eobrun > 0) {
264       eobrun--;
265       return;
266     }
267     let k = spectralStart;
268     const e = spectralEnd;
269     while (k <= e) {
270       const rs = decodeHuffman(component.huffmanTableAC);
271       const s = rs & 15,
272         r = rs >> 4;
273       if (s === 0) {
274         if (r < 15) {
275           eobrun = receive(r) + (1 << r) - 1;
276           break;
277         }
278         k += 16;
279         continue;
280       }
281       k += r;
282       const z = dctZigZag[k];
283       component.blockData[blockOffset + z] =
284         receiveAndExtend(s) * (1 << successive);
285       k++;
286     }
287   }
288 
289   let successiveACState = 0,
290     successiveACNextValue;
291   function decodeACSuccessive(component, blockOffset) {
292     let k = spectralStart;
293     const e = spectralEnd;
294     let r = 0;
295     let s;
296     let rs;
297     while (k <= e) {
298       const offsetZ = blockOffset + dctZigZag[k];
299       const sign = component.blockData[offsetZ] < 0 ? -1 : 1;
300       switch (successiveACState) {
301         case 0: // initial state
302           rs = decodeHuffman(component.huffmanTableAC);
303           s = rs & 15;
304           r = rs >> 4;
305           if (s === 0) {
306             if (r < 15) {
307               eobrun = receive(r) + (1 << r);
308               successiveACState = 4;
309             } else {
310               r = 16;
311               successiveACState = 1;
312             }
313           } else {
314             if (s !== 1) {
315               throw new JpegError("invalid ACn encoding");
316             }
317             successiveACNextValue = receiveAndExtend(s);
318             successiveACState = r ? 2 : 3;
319           }
320           continue;
321         case 1: // skipping r zero items
322         case 2:
323           if (component.blockData[offsetZ]) {
324             component.blockData[offsetZ] += sign * (readBit() << successive);
325           } else {
326             r--;
327             if (r === 0) {
328               successiveACState = successiveACState === 2 ? 3 : 0;
329             }
330           }
331           break;
332         case 3: // set value for a zero item
333           if (component.blockData[offsetZ]) {
334             component.blockData[offsetZ] += sign * (readBit() << successive);
335           } else {
336             component.blockData[offsetZ] = successiveACNextValue << successive;
337             successiveACState = 0;
338           }
339           break;
340         case 4: // eob
341           if (component.blockData[offsetZ]) {
342             component.blockData[offsetZ] += sign * (readBit() << successive);
343           }
344           break;
345       }
346       k++;
347     }
348     if (successiveACState === 4) {
349       eobrun--;
350       if (eobrun === 0) {
351         successiveACState = 0;
352       }
353     }
354   }
355 
356   let blockRow = 0;
357   function decodeMcu(component, decode, mcu, row, col) {
358     const mcuRow = (mcu / mcusPerLine) | 0;
359     const mcuCol = mcu % mcusPerLine;
360     blockRow = mcuRow * component.v + row;
361     const blockCol = mcuCol * component.h + col;
362     const blockOffset = getBlockBufferOffset(component, blockRow, blockCol);
363     decode(component, blockOffset);
364   }
365 
366   function decodeBlock(component, decode, mcu) {
367     blockRow = (mcu / component.blocksPerLine) | 0;
368     const blockCol = mcu % component.blocksPerLine;
369     const blockOffset = getBlockBufferOffset(component, blockRow, blockCol);
370     decode(component, blockOffset);
371   }
372 
373   const componentsLength = components.length;
374   let component, i, j, k, n;
375   let decodeFn;
376   if (progressive) {
377     if (spectralStart === 0) {
378       decodeFn = successivePrev === 0 ? decodeDCFirst : decodeDCSuccessive;
379     } else {
380       decodeFn = successivePrev === 0 ? decodeACFirst : decodeACSuccessive;
381     }
382   } else {
383     decodeFn = decodeBaseline;
384   }
385 
386   let mcu = 0,
387     fileMarker;
388   const mcuExpected =
389     componentsLength === 1
390       ? components[0].blocksPerLine * components[0].blocksPerColumn
391       : mcusPerLine * frame.mcusPerColumn;
392 
393   let h, v;
394   while (mcu <= mcuExpected) {
395     // reset interval stuff
396     const mcuToRead = resetInterval
397       ? Math.min(mcuExpected - mcu, resetInterval)
398       : mcuExpected;
399 
400     // The `mcuToRead === 0` case should only occur when all of the expected
401     // MCU data has been already parsed, i.e. when `mcu === mcuExpected`, but
402     // some corrupt JPEG images contain more data than intended and we thus
403     // want to skip over any extra RSTx markers below (fixes issue11794.pdf).
404     if (mcuToRead > 0) {
405       for (i = 0; i < componentsLength; i++) {
406         components[i].pred = 0;
407       }
408       eobrun = 0;
409 
410       if (componentsLength === 1) {
411         component = components[0];
412         for (n = 0; n < mcuToRead; n++) {
413           decodeBlock(component, decodeFn, mcu);
414           mcu++;
415         }
416       } else {
417         for (n = 0; n < mcuToRead; n++) {
418           for (i = 0; i < componentsLength; i++) {
419             component = components[i];
420             h = component.h;
421             v = component.v;
422             for (j = 0; j < v; j++) {
423               for (k = 0; k < h; k++) {
424                 decodeMcu(component, decodeFn, mcu, j, k);
425               }
426             }
427           }
428           mcu++;
429         }
430       }
431     }
432 
433     // find marker
434     bitsCount = 0;
435     fileMarker = findNextFileMarker(data, offset);
436     if (!fileMarker) {
437       break; // Reached the end of the image data without finding any marker.
438     }
439     if (fileMarker.invalid) {
440       // Some bad images seem to pad Scan blocks with e.g. zero bytes, skip
441       // past those to attempt to find a valid marker (fixes issue4090.pdf).
442       const partialMsg = mcuToRead > 0 ? "unexpected" : "excessive";
443       warn(
444         `decodeScan - ${partialMsg} MCU data, current marker is: ${fileMarker.invalid}`
445       );
446       offset = fileMarker.offset;
447     }
448     if (fileMarker.marker >= 0xffd0 && fileMarker.marker <= 0xffd7) {
449       // RSTx
450       offset += 2;
451     } else {
452       break;
453     }
454   }
455 
456   return offset - startOffset;
457 }
458 
459 // A port of poppler's IDCT method which in turn is taken from:
460 //   Christoph Loeffler, Adriaan Ligtenberg, George S. Moschytz,
461 //   'Practical Fast 1-D DCT Algorithms with 11 Multiplications',
462 //   IEEE Intl. Conf. on Acoustics, Speech & Signal Processing, 1989,
463 //   988-991.
464 function quantizeAndInverse(component, blockBufferOffset, p) {
465   const qt = component.quantizationTable,
466     blockData = component.blockData;
467   let v0, v1, v2, v3, v4, v5, v6, v7;
468   let p0, p1, p2, p3, p4, p5, p6, p7;
469   let t;
470 
471   if (!qt) {
472     throw new JpegError("missing required Quantization Table.");
473   }
474 
475   // inverse DCT on rows
476   for (let row = 0; row < 64; row += 8) {
477     // gather block data
478     p0 = blockData[blockBufferOffset + row];
479     p1 = blockData[blockBufferOffset + row + 1];
480     p2 = blockData[blockBufferOffset + row + 2];
481     p3 = blockData[blockBufferOffset + row + 3];
482     p4 = blockData[blockBufferOffset + row + 4];
483     p5 = blockData[blockBufferOffset + row + 5];
484     p6 = blockData[blockBufferOffset + row + 6];
485     p7 = blockData[blockBufferOffset + row + 7];
486 
487     // dequant p0
488     p0 *= qt[row];
489 
490     // check for all-zero AC coefficients
491     if ((p1 | p2 | p3 | p4 | p5 | p6 | p7) === 0) {
492       t = (dctSqrt2 * p0 + 512) >> 10;
493       p[row] = t;
494       p[row + 1] = t;
495       p[row + 2] = t;
496       p[row + 3] = t;
497       p[row + 4] = t;
498       p[row + 5] = t;
499       p[row + 6] = t;
500       p[row + 7] = t;
501       continue;
502     }
503     // dequant p1 ... p7
504     p1 *= qt[row + 1];
505     p2 *= qt[row + 2];
506     p3 *= qt[row + 3];
507     p4 *= qt[row + 4];
508     p5 *= qt[row + 5];
509     p6 *= qt[row + 6];
510     p7 *= qt[row + 7];
511 
512     // stage 4
513     v0 = (dctSqrt2 * p0 + 128) >> 8;
514     v1 = (dctSqrt2 * p4 + 128) >> 8;
515     v2 = p2;
516     v3 = p6;
517     v4 = (dctSqrt1d2 * (p1 - p7) + 128) >> 8;
518     v7 = (dctSqrt1d2 * (p1 + p7) + 128) >> 8;
519     v5 = p3 << 4;
520     v6 = p5 << 4;
521 
522     // stage 3
523     v0 = (v0 + v1 + 1) >> 1;
524     v1 = v0 - v1;
525     t = (v2 * dctSin6 + v3 * dctCos6 + 128) >> 8;
526     v2 = (v2 * dctCos6 - v3 * dctSin6 + 128) >> 8;
527     v3 = t;
528     v4 = (v4 + v6 + 1) >> 1;
529     v6 = v4 - v6;
530     v7 = (v7 + v5 + 1) >> 1;
531     v5 = v7 - v5;
532 
533     // stage 2
534     v0 = (v0 + v3 + 1) >> 1;
535     v3 = v0 - v3;
536     v1 = (v1 + v2 + 1) >> 1;
537     v2 = v1 - v2;
538     t = (v4 * dctSin3 + v7 * dctCos3 + 2048) >> 12;
539     v4 = (v4 * dctCos3 - v7 * dctSin3 + 2048) >> 12;
540     v7 = t;
541     t = (v5 * dctSin1 + v6 * dctCos1 + 2048) >> 12;
542     v5 = (v5 * dctCos1 - v6 * dctSin1 + 2048) >> 12;
543     v6 = t;
544 
545     // stage 1
546     p[row] = v0 + v7;
547     p[row + 7] = v0 - v7;
548     p[row + 1] = v1 + v6;
549     p[row + 6] = v1 - v6;
550     p[row + 2] = v2 + v5;
551     p[row + 5] = v2 - v5;
552     p[row + 3] = v3 + v4;
553     p[row + 4] = v3 - v4;
554   }
555 
556   // inverse DCT on columns
557   for (let col = 0; col < 8; ++col) {
558     p0 = p[col];
559     p1 = p[col + 8];
560     p2 = p[col + 16];
561     p3 = p[col + 24];
562     p4 = p[col + 32];
563     p5 = p[col + 40];
564     p6 = p[col + 48];
565     p7 = p[col + 56];
566 
567     // check for all-zero AC coefficients
568     if ((p1 | p2 | p3 | p4 | p5 | p6 | p7) === 0) {
569       t = (dctSqrt2 * p0 + 8192) >> 14;
570       // Convert to 8-bit.
571       if (t < -2040) {
572         t = 0;
573       } else if (t >= 2024) {
574         t = 255;
575       } else {
576         t = (t + 2056) >> 4;
577       }
578       blockData[blockBufferOffset + col] = t;
579       blockData[blockBufferOffset + col + 8] = t;
580       blockData[blockBufferOffset + col + 16] = t;
581       blockData[blockBufferOffset + col + 24] = t;
582       blockData[blockBufferOffset + col + 32] = t;
583       blockData[blockBufferOffset + col + 40] = t;
584       blockData[blockBufferOffset + col + 48] = t;
585       blockData[blockBufferOffset + col + 56] = t;
586       continue;
587     }
588 
589     // stage 4
590     v0 = (dctSqrt2 * p0 + 2048) >> 12;
591     v1 = (dctSqrt2 * p4 + 2048) >> 12;
592     v2 = p2;
593     v3 = p6;
594     v4 = (dctSqrt1d2 * (p1 - p7) + 2048) >> 12;
595     v7 = (dctSqrt1d2 * (p1 + p7) + 2048) >> 12;
596     v5 = p3;
597     v6 = p5;
598 
599     // stage 3
600     // Shift v0 by 128.5 << 5 here, so we don't need to shift p0...p7 when
601     // converting to UInt8 range later.
602     v0 = ((v0 + v1 + 1) >> 1) + 4112;
603     v1 = v0 - v1;
604     t = (v2 * dctSin6 + v3 * dctCos6 + 2048) >> 12;
605     v2 = (v2 * dctCos6 - v3 * dctSin6 + 2048) >> 12;
606     v3 = t;
607     v4 = (v4 + v6 + 1) >> 1;
608     v6 = v4 - v6;
609     v7 = (v7 + v5 + 1) >> 1;
610     v5 = v7 - v5;
611 
612     // stage 2
613     v0 = (v0 + v3 + 1) >> 1;
614     v3 = v0 - v3;
615     v1 = (v1 + v2 + 1) >> 1;
616     v2 = v1 - v2;
617     t = (v4 * dctSin3 + v7 * dctCos3 + 2048) >> 12;
618     v4 = (v4 * dctCos3 - v7 * dctSin3 + 2048) >> 12;
619     v7 = t;
620     t = (v5 * dctSin1 + v6 * dctCos1 + 2048) >> 12;
621     v5 = (v5 * dctCos1 - v6 * dctSin1 + 2048) >> 12;
622     v6 = t;
623 
624     // stage 1
625     p0 = v0 + v7;
626     p7 = v0 - v7;
627     p1 = v1 + v6;
628     p6 = v1 - v6;
629     p2 = v2 + v5;
630     p5 = v2 - v5;
631     p3 = v3 + v4;
632     p4 = v3 - v4;
633 
634     // Convert to 8-bit integers.
635     if (p0 < 16) {
636       p0 = 0;
637     } else if (p0 >= 4080) {
638       p0 = 255;
639     } else {
640       p0 >>= 4;
641     }
642     if (p1 < 16) {
643       p1 = 0;
644     } else if (p1 >= 4080) {
645       p1 = 255;
646     } else {
647       p1 >>= 4;
648     }
649     if (p2 < 16) {
650       p2 = 0;
651     } else if (p2 >= 4080) {
652       p2 = 255;
653     } else {
654       p2 >>= 4;
655     }
656     if (p3 < 16) {
657       p3 = 0;
658     } else if (p3 >= 4080) {
659       p3 = 255;
660     } else {
661       p3 >>= 4;
662     }
663     if (p4 < 16) {
664       p4 = 0;
665     } else if (p4 >= 4080) {
666       p4 = 255;
667     } else {
668       p4 >>= 4;
669     }
670     if (p5 < 16) {
671       p5 = 0;
672     } else if (p5 >= 4080) {
673       p5 = 255;
674     } else {
675       p5 >>= 4;
676     }
677     if (p6 < 16) {
678       p6 = 0;
679     } else if (p6 >= 4080) {
680       p6 = 255;
681     } else {
682       p6 >>= 4;
683     }
684     if (p7 < 16) {
685       p7 = 0;
686     } else if (p7 >= 4080) {
687       p7 = 255;
688     } else {
689       p7 >>= 4;
690     }
691 
692     // store block data
693     blockData[blockBufferOffset + col] = p0;
694     blockData[blockBufferOffset + col + 8] = p1;
695     blockData[blockBufferOffset + col + 16] = p2;
696     blockData[blockBufferOffset + col + 24] = p3;
697     blockData[blockBufferOffset + col + 32] = p4;
698     blockData[blockBufferOffset + col + 40] = p5;
699     blockData[blockBufferOffset + col + 48] = p6;
700     blockData[blockBufferOffset + col + 56] = p7;
701   }
702 }
703 
704 function buildComponentData(frame, component) {
705   const blocksPerLine = component.blocksPerLine;
706   const blocksPerColumn = component.blocksPerColumn;
707   const computationBuffer = new Int16Array(64);
708 
709   for (let blockRow = 0; blockRow < blocksPerColumn; blockRow++) {
710     for (let blockCol = 0; blockCol < blocksPerLine; blockCol++) {
711       const offset = getBlockBufferOffset(component, blockRow, blockCol);
712       quantizeAndInverse(component, offset, computationBuffer);
713     }
714   }
715   return component.blockData;
716 }
717 
718 function findNextFileMarker(data, currentPos, startPos = currentPos) {
719   const maxPos = data.length - 1;
720   let newPos = startPos < currentPos ? startPos : currentPos;
721 
722   if (currentPos >= maxPos) {
723     return null; // Don't attempt to read non-existent data and just return.
724   }
725   const currentMarker = readUint16(data, currentPos);
726   if (currentMarker >= 0xffc0 && currentMarker <= 0xfffe) {
727     return {
728       invalid: null,
729       marker: currentMarker,
730       offset: currentPos,
731     };
732   }
733   let newMarker = readUint16(data, newPos);
734   while (!(newMarker >= 0xffc0 && newMarker <= 0xfffe)) {
735     if (++newPos >= maxPos) {
736       return null; // Don't attempt to read non-existent data and just return.
737     }
738     newMarker = readUint16(data, newPos);
739   }
740   return {
741     invalid: currentMarker.toString(16),
742     marker: newMarker,
743     offset: newPos,
744   };
745 }
746 
747 class JpegImage {
748   constructor({ decodeTransform = null, colorTransform = -1 } = {}) {
749     this._decodeTransform = decodeTransform;
750     this._colorTransform = colorTransform;
751   }
752 
753   parse(data, { dnlScanLines = null } = {}) {
754     function readDataBlock() {
755       const length = readUint16(data, offset);
756       offset += 2;
757       let endOffset = offset + length - 2;
758 
759       const fileMarker = findNextFileMarker(data, endOffset, offset);
760       if (fileMarker?.invalid) {
761         warn(
762           "readDataBlock - incorrect length, current marker is: " +
763             fileMarker.invalid
764         );
765         endOffset = fileMarker.offset;
766       }
767 
768       const array = data.subarray(offset, endOffset);
769       offset += array.length;
770       return array;
771     }
772 
773     function prepareComponents(frame) {
774       const mcusPerLine = Math.ceil(frame.samplesPerLine / 8 / frame.maxH);
775       const mcusPerColumn = Math.ceil(frame.scanLines / 8 / frame.maxV);
776       for (const component of frame.components) {
777         const blocksPerLine = Math.ceil(
778           (Math.ceil(frame.samplesPerLine / 8) * component.h) / frame.maxH
779         );
780         const blocksPerColumn = Math.ceil(
781           (Math.ceil(frame.scanLines / 8) * component.v) / frame.maxV
782         );
783         const blocksPerLineForMcu = mcusPerLine * component.h;
784         const blocksPerColumnForMcu = mcusPerColumn * component.v;
785 
786         const blocksBufferSize =
787           64 * blocksPerColumnForMcu * (blocksPerLineForMcu + 1);
788         component.blockData = new Int16Array(blocksBufferSize);
789         component.blocksPerLine = blocksPerLine;
790         component.blocksPerColumn = blocksPerColumn;
791       }
792       frame.mcusPerLine = mcusPerLine;
793       frame.mcusPerColumn = mcusPerColumn;
794     }
795 
796     let offset = 0;
797     let jfif = null;
798     let adobe = null;
799     let frame, resetInterval;
800     let numSOSMarkers = 0;
801     const quantizationTables = [];
802     const huffmanTablesAC = [],
803       huffmanTablesDC = [];
804 
805     let fileMarker = readUint16(data, offset);
806     offset += 2;
807     if (fileMarker !== /* SOI (Start of Image) = */ 0xffd8) {
808       throw new JpegError("SOI not found");
809     }
810     fileMarker = readUint16(data, offset);
811     offset += 2;
812 
813     markerLoop: while (fileMarker !== /* EOI (End of Image) = */ 0xffd9) {
814       let i, j, l;
815       switch (fileMarker) {
816         case 0xffe0: // APP0 (Application Specific)
817         case 0xffe1: // APP1
818         case 0xffe2: // APP2
819         case 0xffe3: // APP3
820         case 0xffe4: // APP4
821         case 0xffe5: // APP5
822         case 0xffe6: // APP6
823         case 0xffe7: // APP7
824         case 0xffe8: // APP8
825         case 0xffe9: // APP9
826         case 0xffea: // APP10
827         case 0xffeb: // APP11
828         case 0xffec: // APP12
829         case 0xffed: // APP13
830         case 0xffee: // APP14
831         case 0xffef: // APP15
832         case 0xfffe: // COM (Comment)
833           const appData = readDataBlock();
834 
835           if (fileMarker === 0xffe0) {
836             // 'JFIF\x00'
837             if (
838               appData[0] === 0x4a &&
839               appData[1] === 0x46 &&
840               appData[2] === 0x49 &&
841               appData[3] === 0x46 &&
842               appData[4] === 0
843             ) {
844               jfif = {
845                 version: { major: appData[5], minor: appData[6] },
846                 densityUnits: appData[7],
847                 xDensity: (appData[8] << 8) | appData[9],
848                 yDensity: (appData[10] << 8) | appData[11],
849                 thumbWidth: appData[12],
850                 thumbHeight: appData[13],
851                 thumbData: appData.subarray(
852                   14,
853                   14 + 3 * appData[12] * appData[13]
854                 ),
855               };
856             }
857           }
858           // TODO APP1 - Exif
859           if (fileMarker === 0xffee) {
860             // 'Adobe'
861             if (
862               appData[0] === 0x41 &&
863               appData[1] === 0x64 &&
864               appData[2] === 0x6f &&
865               appData[3] === 0x62 &&
866               appData[4] === 0x65
867             ) {
868               adobe = {
869                 version: (appData[5] << 8) | appData[6],
870                 flags0: (appData[7] << 8) | appData[8],
871                 flags1: (appData[9] << 8) | appData[10],
872                 transformCode: appData[11],
873               };
874             }
875           }
876           break;
877 
878         case 0xffdb: // DQT (Define Quantization Tables)
879           const quantizationTablesLength = readUint16(data, offset);
880           offset += 2;
881           const quantizationTablesEnd = quantizationTablesLength + offset - 2;
882           let z;
883           while (offset < quantizationTablesEnd) {
884             const quantizationTableSpec = data[offset++];
885             const tableData = new Uint16Array(64);
886             if (quantizationTableSpec >> 4 === 0) {
887               // 8 bit values
888               for (j = 0; j < 64; j++) {
889                 z = dctZigZag[j];
890                 tableData[z] = data[offset++];
891               }
892             } else if (quantizationTableSpec >> 4 === 1) {
893               // 16 bit values
894               for (j = 0; j < 64; j++) {
895                 z = dctZigZag[j];
896                 tableData[z] = readUint16(data, offset);
897                 offset += 2;
898               }
899             } else {
900               throw new JpegError("DQT - invalid table spec");
901             }
902             quantizationTables[quantizationTableSpec & 15] = tableData;
903           }
904           break;
905 
906         case 0xffc0: // SOF0 (Start of Frame, Baseline DCT)
907         case 0xffc1: // SOF1 (Start of Frame, Extended DCT)
908         case 0xffc2: // SOF2 (Start of Frame, Progressive DCT)
909           if (frame) {
910             throw new JpegError("Only single frame JPEGs supported");
911           }
912           offset += 2; // Skip marker length.
913 
914           frame = {};
915           frame.extended = fileMarker === 0xffc1;
916           frame.progressive = fileMarker === 0xffc2;
917           frame.precision = data[offset++];
918           const sofScanLines = readUint16(data, offset);
919           offset += 2;
920           frame.scanLines = dnlScanLines || sofScanLines;
921           frame.samplesPerLine = readUint16(data, offset);
922           offset += 2;
923           frame.components = [];
924           frame.componentIds = {};
925           const componentsCount = data[offset++];
926           let maxH = 0,
927             maxV = 0;
928           for (i = 0; i < componentsCount; i++) {
929             const componentId = data[offset];
930             const h = data[offset + 1] >> 4;
931             const v = data[offset + 1] & 15;
932             if (maxH < h) {
933               maxH = h;
934             }
935             if (maxV < v) {
936               maxV = v;
937             }
938             const qId = data[offset + 2];
939             l = frame.components.push({
940               h,
941               v,
942               quantizationId: qId,
943               quantizationTable: null, // See comment below.
944             });
945             frame.componentIds[componentId] = l - 1;
946             offset += 3;
947           }
948           frame.maxH = maxH;
949           frame.maxV = maxV;
950           prepareComponents(frame);
951           break;
952 
953         case 0xffc4: // DHT (Define Huffman Tables)
954           const huffmanLength = readUint16(data, offset);
955           offset += 2;
956           for (i = 2; i < huffmanLength; ) {
957             const huffmanTableSpec = data[offset++];
958             const codeLengths = new Uint8Array(16);
959             let codeLengthSum = 0;
960             for (j = 0; j < 16; j++, offset++) {
961               codeLengthSum += codeLengths[j] = data[offset];
962             }
963             const huffmanValues = new Uint8Array(codeLengthSum);
964             for (j = 0; j < codeLengthSum; j++, offset++) {
965               huffmanValues[j] = data[offset];
966             }
967             i += 17 + codeLengthSum;
968 
969             (huffmanTableSpec >> 4 === 0 ? huffmanTablesDC : huffmanTablesAC)[
970               huffmanTableSpec & 15
971             ] = buildHuffmanTable(codeLengths, huffmanValues);
972           }
973           break;
974 
975         case 0xffdd: // DRI (Define Restart Interval)
976           offset += 2; // Skip marker length.
977 
978           resetInterval = readUint16(data, offset);
979           offset += 2;
980           break;
981 
982         case 0xffda: // SOS (Start of Scan)
983           // A DNL marker (0xFFDC), if it exists, is only allowed at the end
984           // of the first scan segment and may only occur once in an image.
985           // Furthermore, to prevent an infinite loop, do *not* attempt to
986           // parse DNL markers during re-parsing of the JPEG scan data.
987           const parseDNLMarker = ++numSOSMarkers === 1 && !dnlScanLines;
988 
989           offset += 2; // Skip marker length.
990 
991           const selectorsCount = data[offset++],
992             components = [];
993           for (i = 0; i < selectorsCount; i++) {
994             const index = data[offset++];
995             const componentIndex = frame.componentIds[index];
996             const component = frame.components[componentIndex];
997             component.index = index;
998             const tableSpec = data[offset++];
999             component.huffmanTableDC = huffmanTablesDC[tableSpec >> 4];
1000             component.huffmanTableAC = huffmanTablesAC[tableSpec & 15];
1001             components.push(component);
1002           }
1003           const spectralStart = data[offset++],
1004             spectralEnd = data[offset++],
1005             successiveApproximation = data[offset++];
1006           try {
1007             const processed = decodeScan(
1008               data,
1009               offset,
1010               frame,
1011               components,
1012               resetInterval,
1013               spectralStart,
1014               spectralEnd,
1015               successiveApproximation >> 4,
1016               successiveApproximation & 15,
1017               parseDNLMarker
1018             );
1019             offset += processed;
1020           } catch (ex) {
1021             if (ex instanceof DNLMarkerError) {
1022               warn(`${ex.message} -- attempting to re-parse the JPEG image.`);
1023               return this.parse(data, { dnlScanLines: ex.scanLines });
1024             } else if (ex instanceof EOIMarkerError) {
1025               warn(`${ex.message} -- ignoring the rest of the image data.`);
1026               break markerLoop;
1027             }
1028             throw ex;
1029           }
1030           break;
1031 
1032         case 0xffdc: // DNL (Define Number of Lines)
1033           // Ignore the marker, since it's being handled in `decodeScan`.
1034           offset += 4;
1035           break;
1036 
1037         case 0xffff: // Fill bytes
1038           if (data[offset] !== 0xff) {
1039             // Avoid skipping a valid marker.
1040             offset--;
1041           }
1042           break;
1043 
1044         default:
1045           // Could be incorrect encoding -- the last 0xFF byte of the previous
1046           // block could have been eaten by the encoder, hence we fallback to
1047           // `startPos = offset - 3` when looking for the next valid marker.
1048           const nextFileMarker = findNextFileMarker(
1049             data,
1050             /* currentPos = */ offset - 2,
1051             /* startPos = */ offset - 3
1052           );
1053           if (nextFileMarker?.invalid) {
1054             warn(
1055               "JpegImage.parse - unexpected data, current marker is: " +
1056                 nextFileMarker.invalid
1057             );
1058             offset = nextFileMarker.offset;
1059             break;
1060           }
1061           if (!nextFileMarker || offset >= data.length - 1) {
1062             warn(
1063               "JpegImage.parse - reached the end of the image data " +
1064                 "without finding an EOI marker (0xFFD9)."
1065             );
1066             break markerLoop;
1067           }
1068           throw new JpegError(
1069             "JpegImage.parse - unknown marker: " + fileMarker.toString(16)
1070           );
1071       }
1072       fileMarker = readUint16(data, offset);
1073       offset += 2;
1074     }
1075 
1076     this.width = frame.samplesPerLine;
1077     this.height = frame.scanLines;
1078     this.jfif = jfif;
1079     this.adobe = adobe;
1080     this.components = [];
1081     for (const component of frame.components) {
1082       // Prevent errors when DQT markers are placed after SOF{n} markers,
1083       // by assigning the `quantizationTable` entry after the entire image
1084       // has been parsed (fixes issue7406.pdf).
1085       const quantizationTable = quantizationTables[component.quantizationId];
1086       if (quantizationTable) {
1087         component.quantizationTable = quantizationTable;
1088       }
1089 
1090       this.components.push({
1091         index: component.index,
1092         output: buildComponentData(frame, component),
1093         scaleX: component.h / frame.maxH,
1094         scaleY: component.v / frame.maxV,
1095         blocksPerLine: component.blocksPerLine,
1096         blocksPerColumn: component.blocksPerColumn,
1097       });
1098     }
1099     this.numComponents = this.components.length;
1100     return undefined;
1101   }
1102 
1103   _getLinearizedBlockData(width, height, isSourcePDF = false) {
1104     const scaleX = this.width / width,
1105       scaleY = this.height / height;
1106 
1107     let component, componentScaleX, componentScaleY, blocksPerScanline;
1108     let x, y, i, j, k;
1109     let index;
1110     let offset = 0;
1111     let output;
1112     const numComponents = this.components.length;
1113     const dataLength = width * height * numComponents;
1114     const data = new Uint8ClampedArray(dataLength);
1115     const xScaleBlockOffset = new Uint32Array(width);
1116     const mask3LSB = 0xfffffff8; // used to clear the 3 LSBs
1117     let lastComponentScaleX;
1118 
1119     for (i = 0; i < numComponents; i++) {
1120       component = this.components[i];
1121       componentScaleX = component.scaleX * scaleX;
1122       componentScaleY = component.scaleY * scaleY;
1123       offset = i;
1124       output = component.output;
1125       blocksPerScanline = (component.blocksPerLine + 1) << 3;
1126       // Precalculate the `xScaleBlockOffset`. Since it doesn't depend on the
1127       // component data, that's only necessary when `componentScaleX` changes.
1128       if (componentScaleX !== lastComponentScaleX) {
1129         for (x = 0; x < width; x++) {
1130           j = 0 | (x * componentScaleX);
1131           xScaleBlockOffset[x] = ((j & mask3LSB) << 3) | (j & 7);
1132         }
1133         lastComponentScaleX = componentScaleX;
1134       }
1135       // linearize the blocks of the component
1136       for (y = 0; y < height; y++) {
1137         j = 0 | (y * componentScaleY);
1138         index = (blocksPerScanline * (j & mask3LSB)) | ((j & 7) << 3);
1139         for (x = 0; x < width; x++) {
1140           data[offset] = output[index + xScaleBlockOffset[x]];
1141           offset += numComponents;
1142         }
1143       }
1144     }
1145 
1146     // decodeTransform contains pairs of multiplier (-256..256) and additive
1147     let transform = this._decodeTransform;
1148 
1149     // In PDF files, JPEG images with CMYK colour spaces are usually inverted
1150     // (this can be observed by extracting the raw image data).
1151     // Since the conversion algorithms (see below) were written primarily for
1152     // the PDF use-cases, attempting to use `JpegImage` to parse standalone
1153     // JPEG (CMYK) images may thus result in inverted images (see issue 9513).
1154     //
1155     // Unfortunately it's not (always) possible to tell, from the image data
1156     // alone, if it needs to be inverted. Thus in an attempt to provide better
1157     // out-of-box behaviour when `JpegImage` is used standalone, default to
1158     // inverting JPEG (CMYK) images if and only if the image data does *not*
1159     // come from a PDF file and no `decodeTransform` was passed by the user.
1160     if (!isSourcePDF && numComponents === 4 && !transform) {
1161       transform = new Int32Array([-256, 255, -256, 255, -256, 255, -256, 255]);
1162     }
1163 
1164     if (transform) {
1165       for (i = 0; i < dataLength; ) {
1166         for (j = 0, k = 0; j < numComponents; j++, i++, k += 2) {
1167           data[i] = ((data[i] * transform[k]) >> 8) + transform[k + 1];
1168         }
1169       }
1170     }
1171     return data;
1172   }
1173 
1174   get _isColorConversionNeeded() {
1175     if (this.adobe) {
1176       // The adobe transform marker overrides any previous setting.
1177       return !!this.adobe.transformCode;
1178     }
1179     if (this.numComponents === 3) {
1180       if (this._colorTransform === 0) {
1181         // If the Adobe transform marker is not present and the image
1182         // dictionary has a 'ColorTransform' entry, explicitly set to `0`,
1183         // then the colours should *not* be transformed.
1184         return false;
1185       } else if (
1186         this.components[0].index === /* "R" = */ 0x52 &&
1187         this.components[1].index === /* "G" = */ 0x47 &&
1188         this.components[2].index === /* "B" = */ 0x42
1189       ) {
1190         // If the three components are indexed as RGB in ASCII
1191         // then the colours should *not* be transformed.
1192         return false;
1193       }
1194       return true;
1195     }
1196     // `this.numComponents !== 3`
1197     if (this._colorTransform === 1) {
1198       // If the Adobe transform marker is not present and the image
1199       // dictionary has a 'ColorTransform' entry, explicitly set to `1`,
1200       // then the colours should be transformed.
1201       return true;
1202     }
1203     return false;
1204   }
1205 
1206   _convertYccToRgb(data) {
1207     let Y, Cb, Cr;
1208     for (let i = 0, length = data.length; i < length; i += 3) {
1209       Y = data[i];
1210       Cb = data[i + 1];
1211       Cr = data[i + 2];
1212       data[i] = Y - 179.456 + 1.402 * Cr;
1213       data[i + 1] = Y + 135.459 - 0.344 * Cb - 0.714 * Cr;
1214       data[i + 2] = Y - 226.816 + 1.772 * Cb;
1215     }
1216     return data;
1217   }
1218 
1219   _convertYccToRgba(data, out) {
1220     for (let i = 0, j = 0, length = data.length; i < length; i += 3, j += 4) {
1221       const Y = data[i];
1222       const Cb = data[i + 1];
1223       const Cr = data[i + 2];
1224       out[j] = Y - 179.456 + 1.402 * Cr;
1225       out[j + 1] = Y + 135.459 - 0.344 * Cb - 0.714 * Cr;
1226       out[j + 2] = Y - 226.816 + 1.772 * Cb;
1227       out[j + 3] = 255;
1228     }
1229     return out;
1230   }
1231 
1232   _convertYcckToRgb(data) {
1233     let Y, Cb, Cr, k;
1234     let offset = 0;
1235     for (let i = 0, length = data.length; i < length; i += 4) {
1236       Y = data[i];
1237       Cb = data[i + 1];
1238       Cr = data[i + 2];
1239       k = data[i + 3];
1240 
1241       data[offset++] =
1242         -122.67195406894 +
1243         Cb *
1244           (-6.60635669420364e-5 * Cb +
1245             0.000437130475926232 * Cr -
1246             5.4080610064599e-5 * Y +
1247             0.00048449797120281 * k -
1248             0.154362151871126) +
1249         Cr *
1250           (-0.000957964378445773 * Cr +
1251             0.000817076911346625 * Y -
1252             0.00477271405408747 * k +
1253             1.53380253221734) +
1254         Y *
1255           (0.000961250184130688 * Y -
1256             0.00266257332283933 * k +
1257             0.48357088451265) +
1258         k * (-0.000336197177618394 * k + 0.484791561490776);
1259 
1260       data[offset++] =
1261         107.268039397724 +
1262         Cb *
1263           (2.19927104525741e-5 * Cb -
1264             0.000640992018297945 * Cr +
1265             0.000659397001245577 * Y +
1266             0.000426105652938837 * k -
1267             0.176491792462875) +
1268         Cr *
1269           (-0.000778269941513683 * Cr +
1270             0.00130872261408275 * Y +
1271             0.000770482631801132 * k -
1272             0.151051492775562) +
1273         Y *
1274           (0.00126935368114843 * Y -
1275             0.00265090189010898 * k +
1276             0.25802910206845) +
1277         k * (-0.000318913117588328 * k - 0.213742400323665);
1278 
1279       data[offset++] =
1280         -20.810012546947 +
1281         Cb *
1282           (-0.000570115196973677 * Cb -
1283             2.63409051004589e-5 * Cr +
1284             0.0020741088115012 * Y -
1285             0.00288260236853442 * k +
1286             0.814272968359295) +
1287         Cr *
1288           (-1.53496057440975e-5 * Cr -
1289             0.000132689043961446 * Y +
1290             0.000560833691242812 * k -
1291             0.195152027534049) +
1292         Y *
1293           (0.00174418132927582 * Y -
1294             0.00255243321439347 * k +
1295             0.116935020465145) +
1296         k * (-0.000343531996510555 * k + 0.24165260232407);
1297     }
1298     // Ensure that only the converted RGB data is returned.
1299     return data.subarray(0, offset);
1300   }
1301 
1302   _convertYcckToRgba(data) {
1303     for (let i = 0, length = data.length; i < length; i += 4) {
1304       const Y = data[i];
1305       const Cb = data[i + 1];
1306       const Cr = data[i + 2];
1307       const k = data[i + 3];
1308 
1309       data[i] =
1310         -122.67195406894 +
1311         Cb *
1312           (-6.60635669420364e-5 * Cb +
1313             0.000437130475926232 * Cr -
1314             5.4080610064599e-5 * Y +
1315             0.00048449797120281 * k -
1316             0.154362151871126) +
1317         Cr *
1318           (-0.000957964378445773 * Cr +
1319             0.000817076911346625 * Y -
1320             0.00477271405408747 * k +
1321             1.53380253221734) +
1322         Y *
1323           (0.000961250184130688 * Y -
1324             0.00266257332283933 * k +
1325             0.48357088451265) +
1326         k * (-0.000336197177618394 * k + 0.484791561490776);
1327 
1328       data[i + 1] =
1329         107.268039397724 +
1330         Cb *
1331           (2.19927104525741e-5 * Cb -
1332             0.000640992018297945 * Cr +
1333             0.000659397001245577 * Y +
1334             0.000426105652938837 * k -
1335             0.176491792462875) +
1336         Cr *
1337           (-0.000778269941513683 * Cr +
1338             0.00130872261408275 * Y +
1339             0.000770482631801132 * k -
1340             0.151051492775562) +
1341         Y *
1342           (0.00126935368114843 * Y -
1343             0.00265090189010898 * k +
1344             0.25802910206845) +
1345         k * (-0.000318913117588328 * k - 0.213742400323665);
1346 
1347       data[i + 2] =
1348         -20.810012546947 +
1349         Cb *
1350           (-0.000570115196973677 * Cb -
1351             2.63409051004589e-5 * Cr +
1352             0.0020741088115012 * Y -
1353             0.00288260236853442 * k +
1354             0.814272968359295) +
1355         Cr *
1356           (-1.53496057440975e-5 * Cr -
1357             0.000132689043961446 * Y +
1358             0.000560833691242812 * k -
1359             0.195152027534049) +
1360         Y *
1361           (0.00174418132927582 * Y -
1362             0.00255243321439347 * k +
1363             0.116935020465145) +
1364         k * (-0.000343531996510555 * k + 0.24165260232407);
1365       data[i + 3] = 255;
1366     }
1367     return data;
1368   }
1369 
1370   _convertYcckToCmyk(data) {
1371     let Y, Cb, Cr;
1372     for (let i = 0, length = data.length; i < length; i += 4) {
1373       Y = data[i];
1374       Cb = data[i + 1];
1375       Cr = data[i + 2];
1376       data[i] = 434.456 - Y - 1.402 * Cr;
1377       data[i + 1] = 119.541 - Y + 0.344 * Cb + 0.714 * Cr;
1378       data[i + 2] = 481.816 - Y - 1.772 * Cb;
1379       // K in data[i + 3] is unchanged
1380     }
1381     return data;
1382   }
1383 
1384   _convertCmykToRgb(data) {
1385     let c, m, y, k;
1386     let offset = 0;
1387     for (let i = 0, length = data.length; i < length; i += 4) {
1388       c = data[i];
1389       m = data[i + 1];
1390       y = data[i + 2];
1391       k = data[i + 3];
1392 
1393       data[offset++] =
1394         255 +
1395         c *
1396           (-0.00006747147073602441 * c +
1397             0.0008379262121013727 * m +
1398             0.0002894718188643294 * y +
1399             0.003264231057537806 * k -
1400             1.1185611867203937) +
1401         m *
1402           (0.000026374107616089405 * m -
1403             0.00008626949158638572 * y -
1404             0.0002748769067499491 * k -
1405             0.02155688794978967) +
1406         y *
1407           (-0.00003878099212869363 * y -
1408             0.0003267808279485286 * k +
1409             0.0686742238595345) -
1410         k * (0.0003361971776183937 * k + 0.7430659151342254);
1411 
1412       data[offset++] =
1413         255 +
1414         c *
1415           (0.00013596372813588848 * c +
1416             0.000924537132573585 * m +
1417             0.00010567359618683593 * y +
1418             0.0004791864687436512 * k -
1419             0.3109689587515875) +
1420         m *
1421           (-0.00023545346108370344 * m +
1422             0.0002702845253534714 * y +
1423             0.0020200308977307156 * k -
1424             0.7488052167015494) +
1425         y *
1426           (0.00006834815998235662 * y +
1427             0.00015168452363460973 * k -
1428             0.09751927774728933) -
1429         k * (0.0003189131175883281 * k + 0.7364883807733168);
1430 
1431       data[offset++] =
1432         255 +
1433         c *
1434           (0.000013598650411385307 * c +
1435             0.00012423956175490851 * m +
1436             0.0004751985097583589 * y -
1437             0.0000036729317476630422 * k -
1438             0.05562186980264034) +
1439         m *
1440           (0.00016141380598724676 * m +
1441             0.0009692239130725186 * y +
1442             0.0007782692450036253 * k -
1443             0.44015232367526463) +
1444         y *
1445           (5.068882914068769e-7 * y +
1446             0.0017778369011375071 * k -
1447             0.7591454649749609) -
1448         k * (0.0003435319965105553 * k + 0.7063770186160144);
1449     }
1450     // Ensure that only the converted RGB data is returned.
1451     return data.subarray(0, offset);
1452   }
1453 
1454   _convertCmykToRgba(data) {
1455     for (let i = 0, length = data.length; i < length; i += 4) {
1456       const c = data[i];
1457       const m = data[i + 1];
1458       const y = data[i + 2];
1459       const k = data[i + 3];
1460 
1461       data[i] =
1462         255 +
1463         c *
1464           (-0.00006747147073602441 * c +
1465             0.0008379262121013727 * m +
1466             0.0002894718188643294 * y +
1467             0.003264231057537806 * k -
1468             1.1185611867203937) +
1469         m *
1470           (0.000026374107616089405 * m -
1471             0.00008626949158638572 * y -
1472             0.0002748769067499491 * k -
1473             0.02155688794978967) +
1474         y *
1475           (-0.00003878099212869363 * y -
1476             0.0003267808279485286 * k +
1477             0.0686742238595345) -
1478         k * (0.0003361971776183937 * k + 0.7430659151342254);
1479 
1480       data[i + 1] =
1481         255 +
1482         c *
1483           (0.00013596372813588848 * c +
1484             0.000924537132573585 * m +
1485             0.00010567359618683593 * y +
1486             0.0004791864687436512 * k -
1487             0.3109689587515875) +
1488         m *
1489           (-0.00023545346108370344 * m +
1490             0.0002702845253534714 * y +
1491             0.0020200308977307156 * k -
1492             0.7488052167015494) +
1493         y *
1494           (0.00006834815998235662 * y +
1495             0.00015168452363460973 * k -
1496             0.09751927774728933) -
1497         k * (0.0003189131175883281 * k + 0.7364883807733168);
1498 
1499       data[i + 2] =
1500         255 +
1501         c *
1502           (0.000013598650411385307 * c +
1503             0.00012423956175490851 * m +
1504             0.0004751985097583589 * y -
1505             0.0000036729317476630422 * k -
1506             0.05562186980264034) +
1507         m *
1508           (0.00016141380598724676 * m +
1509             0.0009692239130725186 * y +
1510             0.0007782692450036253 * k -
1511             0.44015232367526463) +
1512         y *
1513           (5.068882914068769e-7 * y +
1514             0.0017778369011375071 * k -
1515             0.7591454649749609) -
1516         k * (0.0003435319965105553 * k + 0.7063770186160144);
1517       data[i + 3] = 255;
1518     }
1519     return data;
1520   }
1521 
1522   getData({
1523     width,
1524     height,
1525     forceRGBA = false,
1526     forceRGB = false,
1527     isSourcePDF = false,
1528   }) {
1529     if (typeof PDFJSDev === "undefined" || PDFJSDev.test("TESTING")) {
1530       assert(
1531         isSourcePDF === true,
1532         'JpegImage.getData: Unexpected "isSourcePDF" value for PDF files.'
1533       );
1534     }
1535     if (this.numComponents > 4) {
1536       throw new JpegError("Unsupported color mode");
1537     }
1538     // Type of data: Uint8ClampedArray(width * height * numComponents)
1539     const data = this._getLinearizedBlockData(width, height, isSourcePDF);
1540 
1541     if (this.numComponents === 1 && (forceRGBA || forceRGB)) {
1542       const len = data.length * (forceRGBA ? 4 : 3);
1543       const rgbaData = new Uint8ClampedArray(len);
1544       let offset = 0;
1545       if (forceRGBA) {
1546         grayToRGBA(data, new Uint32Array(rgbaData.buffer));
1547       } else {
1548         for (const grayColor of data) {
1549           rgbaData[offset++] = grayColor;
1550           rgbaData[offset++] = grayColor;
1551           rgbaData[offset++] = grayColor;
1552         }
1553       }
1554       return rgbaData;
1555     } else if (this.numComponents === 3 && this._isColorConversionNeeded) {
1556       if (forceRGBA) {
1557         const rgbaData = new Uint8ClampedArray((data.length / 3) * 4);
1558         return this._convertYccToRgba(data, rgbaData);
1559       }
1560       return this._convertYccToRgb(data);
1561     } else if (this.numComponents === 4) {
1562       if (this._isColorConversionNeeded) {
1563         if (forceRGBA) {
1564           return this._convertYcckToRgba(data);
1565         }
1566         if (forceRGB) {
1567           return this._convertYcckToRgb(data);
1568         }
1569         return this._convertYcckToCmyk(data);
1570       } else if (forceRGBA) {
1571         return this._convertCmykToRgba(data);
1572       } else if (forceRGB) {
1573         return this._convertCmykToRgb(data);
1574       }
1575     }
1576     return data;
1577   }
1578 }
1579 
1580 export { JpegImage };
</code>

Test file:
<test_file>
File:
test/unit/api_spec.js
/* Copyright 2017 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import {
  AnnotationEditorType,
  AnnotationMode,
  AnnotationType,
  ImageKind,
  InvalidPDFException,
  isNodeJS,
  MissingPDFException,
  objectSize,
  OPS,
  PasswordException,
  PasswordResponses,
  PermissionFlag,
  PromiseCapability,
  UnknownErrorException,
} from "../../src/shared/util.js";
import {
  buildGetDocumentParams,
  CMAP_URL,
  DefaultFileReaderFactory,
  TEST_PDFS_PATH,
} from "./test_utils.js";
import {
  DefaultCanvasFactory,
  getDocument,
  PDFDataRangeTransport,
  PDFDocumentLoadingTask,
  PDFDocumentProxy,
  PDFPageProxy,
  PDFWorker,
  PDFWorkerUtil,
  RenderTask,
} from "../../src/display/api.js";
import {
  PageViewport,
  RenderingCancelledException,
  StatTimer,
} from "../../src/display/display_utils.js";
import { AutoPrintRegExp } from "../../web/ui_utils.js";
import { GlobalImageCache } from "../../src/core/image_utils.js";
import { GlobalWorkerOptions } from "../../src/display/worker_options.js";
import { Metadata } from "../../src/display/metadata.js";
const WORKER_SRC = "../../build/generic/build/pdf.worker.mjs";
</test_file>

Your task:
You are a software tester at pdf.js.
1. Examine the existing test file. You may reuse any imports, helpers or setup blocks it already has.
2. Write exactly one javascript test `it("...", async () => {...})` block.
3. Your test must fail on the code before the patch, and pass after, hence the test will verify that the patch resolves the issue.
4. The test must be self-contained and to-the-point.
5. If you need something new use only the provided imports (respect the paths exactly how they are given) by importing dynamically for compatibility with Node.js — no new dependencies. 
6. Return only the javascript code for the new `it(...)` block (no comments or explanations).

Example structure:
it("should <describe behavior>", async () => {
  const { example } = await import("../../src/core/example.js");
  <initialize required variables>;
  <define expected variable>;
  <generate actual variables>;
  <compare expected with actual>;
});

