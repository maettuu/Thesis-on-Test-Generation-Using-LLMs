Before you begin:
- Keep going until the job is completely solved — don’t stop halfway.
- If you’re unsure about the behavior, reread the provided patch carefully; do not hallucinate.
- Plan your approach before writing code by reflecting on whether the test truly fails before and passes after.

Issue:
<issue>
TypeError: Cannot read properties of undefined (reading 'samplesPerLine')
While [Fuzzing](https://en.wikipedia.org/wiki/Fuzzing) locally using [jazzer.js](https://github.com/CodeIntelligenceTesting/jazzer.js) `JpegImage().parse` threw `TypeError: Cannot read properties of undefined (reading 'samplesPerLine')` at
https://github.com/mozilla/pdf.js/blob/d8424a43baf4c18dd19c77f466bbfff2b15cd8f4/src/core/jpg.js#L1076

Configuration:
- Operating system and its version:  Ubuntu 20.04.6 LTS
- PDF.js version: v4.0.189

Steps to reproduce the problem:

```js
❯ cat test.js
import { JpegImage } from "./src/core/jpg.js";
new JpegImage().parse(Buffer.from('ffd8', 'hex'));
```
```js
❯ node test.js
Warning: JpegImage.parse - reached the end of the image data without finding an EOI marker (0xFFD9).
file:///home/maxx/dev/security/oss-fuzz-projects/pdf.js/src/core/jpg.js:1076
    this.width = frame.samplesPerLine;
                       ^

TypeError: Cannot read properties of undefined (reading 'samplesPerLine')
    at JpegImage.parse (file:///home/maxx/dev/security/oss-fuzz-projects/pdf.js/src/core/jpg.js:1076:24)
    at file:///home/maxx/dev/security/oss-fuzz-projects/pdf.js/test.js:3:17
    at ModuleJob.run (node:internal/modules/esm/module_job:218:25)
    at async ModuleLoader.import (node:internal/modules/esm/loader:329:24)
    at async loadESM (node:internal/process/esm_loader:34:7)
    at async handleMainPromise (node:internal/modules/run_main:113:12)

Node.js v21.1.0

```

What is the expected behavior? 
 - Should not throw exception.


</issue>

Patch:
<patch>
diff --git a/src/core/jpg.js b/src/core/jpg.js
--- a/src/core/jpg.js
+++ b/src/core/jpg.js
@@ -1073,6 +1073,9 @@ class JpegImage {
       offset += 2;
     }
 
+    if (!frame) {
+      throw new JpegError("JpegImage.parse - no frame data found.");
+    }
     this.width = frame.samplesPerLine;
     this.height = frame.scanLines;
     this.jfif = jfif;


</patch>

Imports:
<imports>
Available Packages
Dev Dependencies:
- @babel/core: ^7.23.3
- @babel/preset-env: ^7.23.3
- @babel/runtime: ^7.23.2
- @fluent/bundle: ^0.18.0
- @fluent/dom: ^0.9.0
- @javascript-obfuscator/escodegen: 2.3.0
- acorn: ^8.11.2
- autoprefixer: ^10.4.16
- babel-loader: ^9.1.3
- caniuse-lite: ^1.0.30001561
- canvas: ^2.11.2
- core-js: ^3.33.2
- cross-env: ^7.0.3
- eslint: ^8.53.0
- eslint-config-prettier: ^8.10.0
- eslint-plugin-fetch-options: ^0.0.5
- eslint-plugin-html: ^7.1.0
- eslint-plugin-import: ^2.29.0
- eslint-plugin-json: ^3.1.0
- eslint-plugin-mozilla: ^3.2.0
- eslint-plugin-no-unsanitized: ^4.0.2
- eslint-plugin-prettier: ^5.0.1
- eslint-plugin-sort-exports: ^0.8.0
- eslint-plugin-unicorn: ^49.0.0
- globals: ^13.23.0
- gulp: ^4.0.2
- gulp-postcss: ^9.0.1
- gulp-rename: ^2.0.0
- gulp-replace: ^1.1.4
- gulp-zip: ^6.0.0
- jasmine: ^5.1.0
- jsdoc: ^4.0.2
- jstransformer-markdown-it: ^3.0.0
- merge-stream: ^2.0.0
- mkdirp: ^3.0.1
- needle: ^3.2.0
- path2d-polyfill: ^2.0.1
- pngjs: ^7.0.0
- postcss: ^8.4.31
- postcss-dark-theme-class: ^1.0.0
- postcss-dir-pseudo-class: ^8.0.0
- postcss-discard-comments: ^6.0.0
- postcss-nesting: ^12.0.1
- prettier: ^3.0.3
- puppeteer: ^21.5.1
- rimraf: ^3.0.2
- streamqueue: ^1.1.2
- stylelint: ^15.11.0
- stylelint-prettier: ^4.0.2
- terser: ^5.24.0
- through2: ^4.0.2
- tsc-alias: ^1.8.8
- ttest: ^4.0.0
- typescript: ^5.2.2
- typogr: ^0.6.8
- vinyl: ^3.0.0
- webpack: ^5.89.0
- webpack-stream: ^7.0.0
- wintersmith: ^2.5.0
- yargs: ^17.7.2

Engines:
- node: >=18

Available Relative Imports:
- `../../src/core/annotation.js`: Annotation, AnnotationBorderStyle, AnnotationFactory, MarkupAnnotation, getQuadPoints
- `../../src/core/bidi.js`: bidi
- `../../src/core/cff_parser.js`: CFFCharset, CFFCompiler, CFFFDSelect, CFFParser, CFFStrings
- `../../src/core/cmap.js`: CMap, CMapFactory, IdentityCMap
- `../../src/core/colorspace.js`: ColorSpace
- `../../src/core/core_utils.js`: arrayBuffersToBytes, encodeToXmlString, escapePDFName, escapeString, getInheritableProperty, isAscii, isWhiteSpace, log2, numberToString, parseXFAPath, recoverJsURL, stringToUTF16HexString, stringToUTF16String, toRomanNumerals, validateCSSFont
- `../../src/core/crypto.js`: AES128Cipher, AES256Cipher, ARCFourCipher, CipherTransformFactory, PDF17, PDF20, calculateMD5, calculateSHA256, calculateSHA384, calculateSHA512
- `../../src/core/default_appearance.js`: createDefaultAppearance, parseAppearanceStream, parseDefaultAppearance
- `../../src/core/document.js`: PDFDocument, Page
- `../../src/core/encodings.js`: getEncoding
- `../../src/core/evaluator.js`: PartialEvaluator
- `../../src/core/font_substitutions.js`: getFontSubstitution
- `../../src/core/fonts_utils.js`: SEAC_ANALYSIS_ENABLED
- `../../src/core/function.js`: PDFFunctionFactory, PostScriptCompiler, PostScriptEvaluator
- `../../src/core/glyphlist.js`: getDingbatsGlyphsUnicode, getGlyphsUnicode
- `../../src/core/image_utils.js`: GlobalImageCache, LocalColorSpaceCache
- `../../src/core/jbig2.js`: Jbig2Image
- `../../src/core/jpg.js`: JpegImage
- `../../src/core/jpx.js`: JpxImage
- `../../src/core/metadata_parser.js`: MetadataParser
- `../../src/core/operator_list.js`: OperatorList
- `../../src/core/parser.js`: Lexer, Linearization, Parser
- `../../src/core/predictor_stream.js`: PredictorStream
- `../../src/core/primitives.js`: Cmd, Dict, EOF, Name, Ref, RefSet, RefSetCache, isCmd, isDict, isName, isRefsEqual
- `../../src/core/ps_parser.js`: PostScriptLexer, PostScriptParser
- `../../src/core/stream.js`: NullStream, Stream, StringStream
- `../../src/core/type1_parser.js`: Type1Parser
- `../../src/core/unicode.js`: getCharUnicodeCategory, getUnicodeForGlyph, getUnicodeRangeFor, mapSpecialUnicodeValues
- `../../src/core/worker.js`: WorkerMessageHandler, WorkerTask
- `../../src/core/writer.js`: incrementalUpdate, writeDict
- `../../src/core/xfa/bind.js`: Binder
- `../../src/core/xfa/data.js`: DataHandler
- `../../src/core/xfa/factory.js`: XFAFactory
- `../../src/core/xfa/formcalc_lexer.js`: Lexer, TOKEN, Token
- `../../src/core/xfa/formcalc_parser.js`: Errors, Parser
- `../../src/core/xfa/parser.js`: XFAParser
- `../../src/core/xfa/som.js`: searchNode
- `../../src/core/xfa/symbol_utils.js`: $dump, $getChildren, $getChildrenByClass, $getChildrenByName, $text, $uid
- `../../src/core/xml_parser.js`: SimpleXMLParser, XMLParserBase
- `../../src/display/annotation_layer.js`: AnnotationLayer
- `../../src/display/annotation_storage.js`: AnnotationStorage
- `../../src/display/api.js`: DefaultCMapReaderFactory, DefaultCanvasFactory, DefaultStandardFontDataFactory, LoopbackPort, PDFDataRangeTransport, PDFDocumentLoadingTask, PDFDocumentProxy, PDFPageProxy, PDFWorker, PDFWorkerUtil, RenderTask, build, getDocument, version
- `../../src/display/display_utils.js`: DOMCanvasFactory, DOMSVGFactory, PDFDateString, PageViewport, PixelsPerInch, RenderingCancelledException, StatTimer, fetchData, getFilenameFromUrl, getPdfFilenameFromUrl, getXfaPageViewport, isDataScheme, isPdfFile, isValidFetchUrl, noContextMenu, setLayerDimensions
- `../../src/display/editor/annotation_editor_layer.js`: AnnotationEditorLayer
- `../../src/display/editor/tools.js`: AnnotationEditorUIManager, CommandManager
- `../../src/display/fetch_stream.js`: PDFFetchStream
- `../../src/display/metadata.js`: Metadata
- `../../src/display/network.js`: PDFNetworkStream
- `../../src/display/network_utils.js`: createResponseStatusError, extractFilenameFromHeader, validateRangeRequestCapabilities, validateResponseStatus
- `../../src/display/node_stream.js`: PDFNodeStream
- `../../src/display/text_layer.js`: TextLayerRenderTask, renderTextLayer, updateTextLayer
- `../../src/display/worker_options.js`: GlobalWorkerOptions
- `../../src/display/xfa_layer.js`: XfaLayer
- `../../src/shared/message_handler.js`: MessageHandler
- `../../src/shared/murmurhash3.js`: MurmurHash3_64
- `../../src/shared/util.js`: AbortException, AnnotationBorderStyleType, AnnotationEditorParamsType, AnnotationEditorType, AnnotationFieldFlag, AnnotationFlag, AnnotationMode, AnnotationType, CMapCompressionType, FeatureTest, FormatError, ImageKind, InvalidPDFException, MissingPDFException, OPS, PasswordException, PasswordResponses, PermissionFlag, PromiseCapability, RenderingIntentFlag, UnexpectedResponseException, UnknownErrorException, Util, VerbosityLevel, bytesToString, createValidAbsoluteUrl, getModificationDate, getVerbosityLevel, isArrayBuffer, isNodeJS, normalizeUnicode, objectSize, setVerbosityLevel, shadow, string32, stringToBytes, stringToPDFString, stringToUTF8String
- `../../web/annotation_layer_builder.js`: AnnotationLayerBuilder
- `../../web/download_manager.js`: DownloadManager
- `../../web/event_utils.js`: EventBus, WaitOnType, waitOnEventOrTimeout
- `../../web/genericl10n.js`: GenericL10n
- `../../web/l10n.js`: L10n
- `../../web/l10n_utils.js`: NullL10n
- `../../web/pdf_find_controller.js`: FindState, PDFFindController
- `../../web/pdf_find_utils.js`: CharacterType, getCharacterType
- `../../web/pdf_history.js`: PDFHistory, isDestArraysEqual, isDestHashesEqual
- `../../web/pdf_link_service.js`: LinkTarget, PDFLinkService, SimpleLinkService
- `../../web/pdf_page_view.js`: PDFPageView
- `../../web/pdf_scripting_manager.component.js`: PDFScriptingManager
- `../../web/pdf_single_page_viewer.js`: PDFSinglePageViewer
- `../../web/pdf_viewer.js`: PDFPageViewBuffer, PDFViewer
- `../../web/struct_tree_layer_builder.js`: StructTreeLayerBuilder
- `../../web/text_layer_builder.js`: TextLayerBuilder
- `../../web/ui_utils.js`: AutoPrintRegExp, ProgressBar, RenderingStates, ScrollMode, SpreadMode, backtrackBeforeAllVisibleElements, binarySearchFirstItem, getPageSizeInches, getVisibleElements, isPortraitOrientation, isValidRotation, parseQueryString, removeNullCharacters
- `../../web/xfa_layer_builder.js`: XfaLayerBuilder
- `./test_utils.js`: CMAP_URL, DefaultFileReaderFactory, STANDARD_FONT_DATA_URL, TEST_PDFS_PATH, XRefMock, buildGetDocumentParams, createIdFactory, getNodeVersion
- `./testreporter.js`: TestReporter
</imports>

Code:
<code>
File:
src/core/jpg.js
1 /* Copyright 2014 Mozilla Foundation
2  *
3  * Licensed under the Apache License, Version 2.0 (the 'License');
4  * you may not use this file except in compliance with the License.
5  * You may obtain a copy of the License at
6  *
7  *     http://www.apache.org/licenses/LICENSE-2.0
8  *
9  * Unless required by applicable law or agreed to in writing, software
10  * distributed under the License is distributed on an 'AS IS' BASIS,
11  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
12  * See the License for the specific language governing permissions and
13  * limitations under the License.
14  */
15 
16 import { assert, BaseException, warn } from "../shared/util.js";
17 import { grayToRGBA } from "../shared/image_utils.js";
18 import { readUint16 } from "./core_utils.js";
19 
52 // prettier-ignore
53 const dctZigZag = new Uint8Array([
54    0,
55    1,  8,
56   16,  9,  2,
57    3, 10, 17, 24,
58   32, 25, 18, 11, 4,
59    5, 12, 19, 26, 33, 40,
60   48, 41, 34, 27, 20, 13,  6,
61    7, 14, 21, 28, 35, 42, 49, 56,
62   57, 50, 43, 36, 29, 22, 15,
63   23, 30, 37, 44, 51, 58,
64   59, 52, 45, 38, 31,
65   39, 46, 53, 60,
66   61, 54, 47,
67   55, 62,
68   63
69 ]);
70 
71 const dctCos1 = 4017; // cos(pi/16)
72 const dctSin1 = 799; // sin(pi/16)
73 const dctCos3 = 3406; // cos(3*pi/16)
74 const dctSin3 = 2276; // sin(3*pi/16)
75 const dctCos6 = 1567; // cos(6*pi/16)
76 const dctSin6 = 3784; // sin(6*pi/16)
77 const dctSqrt2 = 5793; // sqrt(2)
78 const dctSqrt1d2 = 2896; // sqrt(2) / 2
79 
459 // A port of poppler's IDCT method which in turn is taken from:
460 //   Christoph Loeffler, Adriaan Ligtenberg, George S. Moschytz,
461 //   'Practical Fast 1-D DCT Algorithms with 11 Multiplications',
462 //   IEEE Intl. Conf. on Acoustics, Speech & Signal Processing, 1989,
463 //   988-991.
703 
747 class JpegImage {
748   constructor({ decodeTransform = null, colorTransform = -1 } = {}) {
749     this._decodeTransform = decodeTransform;
750     this._colorTransform = colorTransform;
751   }
752 
753   parse(data, { dnlScanLines = null } = {}) {
754     function readDataBlock() {
755       const length = readUint16(data, offset);
756       offset += 2;
757       let endOffset = offset + length - 2;
758 
759       const fileMarker = findNextFileMarker(data, endOffset, offset);
760       if (fileMarker?.invalid) {
761         warn(
762           "readDataBlock - incorrect length, current marker is: " +
763             fileMarker.invalid
764         );
765         endOffset = fileMarker.offset;
766       }
767 
768       const array = data.subarray(offset, endOffset);
769       offset += array.length;
770       return array;
771     }
772 
773     function prepareComponents(frame) {
774       const mcusPerLine = Math.ceil(frame.samplesPerLine / 8 / frame.maxH);
775       const mcusPerColumn = Math.ceil(frame.scanLines / 8 / frame.maxV);
776       for (const component of frame.components) {
777         const blocksPerLine = Math.ceil(
778           (Math.ceil(frame.samplesPerLine / 8) * component.h) / frame.maxH
779         );
780         const blocksPerColumn = Math.ceil(
781           (Math.ceil(frame.scanLines / 8) * component.v) / frame.maxV
782         );
783         const blocksPerLineForMcu = mcusPerLine * component.h;
784         const blocksPerColumnForMcu = mcusPerColumn * component.v;
785 
786         const blocksBufferSize =
787           64 * blocksPerColumnForMcu * (blocksPerLineForMcu + 1);
788         component.blockData = new Int16Array(blocksBufferSize);
789         component.blocksPerLine = blocksPerLine;
790         component.blocksPerColumn = blocksPerColumn;
791       }
792       frame.mcusPerLine = mcusPerLine;
793       frame.mcusPerColumn = mcusPerColumn;
794     }
795 
796     let offset = 0;
797     let jfif = null;
798     let adobe = null;
799     let frame, resetInterval;
800     let numSOSMarkers = 0;
801     const quantizationTables = [];
802     const huffmanTablesAC = [],
803       huffmanTablesDC = [];
804 
805     let fileMarker = readUint16(data, offset);
806     offset += 2;
807     if (fileMarker !== /* SOI (Start of Image) = */ 0xffd8) {
808       throw new JpegError("SOI not found");
809     }
810     fileMarker = readUint16(data, offset);
811     offset += 2;
812 
813     markerLoop: while (fileMarker !== /* EOI (End of Image) = */ 0xffd9) {
814       let i, j, l;
815       switch (fileMarker) {
816         case 0xffe0: // APP0 (Application Specific)
817         case 0xffe1: // APP1
818         case 0xffe2: // APP2
819         case 0xffe3: // APP3
820         case 0xffe4: // APP4
821         case 0xffe5: // APP5
822         case 0xffe6: // APP6
823         case 0xffe7: // APP7
824         case 0xffe8: // APP8
825         case 0xffe9: // APP9
826         case 0xffea: // APP10
827         case 0xffeb: // APP11
828         case 0xffec: // APP12
829         case 0xffed: // APP13
830         case 0xffee: // APP14
831         case 0xffef: // APP15
832         case 0xfffe: // COM (Comment)
833           const appData = readDataBlock();
834 
835           if (fileMarker === 0xffe0) {
836             // 'JFIF\x00'
837             if (
838               appData[0] === 0x4a &&
839               appData[1] === 0x46 &&
840               appData[2] === 0x49 &&
841               appData[3] === 0x46 &&
842               appData[4] === 0
843             ) {
844               jfif = {
845                 version: { major: appData[5], minor: appData[6] },
846                 densityUnits: appData[7],
847                 xDensity: (appData[8] << 8) | appData[9],
848                 yDensity: (appData[10] << 8) | appData[11],
849                 thumbWidth: appData[12],
850                 thumbHeight: appData[13],
851                 thumbData: appData.subarray(
852                   14,
853                   14 + 3 * appData[12] * appData[13]
854                 ),
855               };
856             }
857           }
858           // TODO APP1 - Exif
859           if (fileMarker === 0xffee) {
860             // 'Adobe'
861             if (
862               appData[0] === 0x41 &&
863               appData[1] === 0x64 &&
864               appData[2] === 0x6f &&
865               appData[3] === 0x62 &&
866               appData[4] === 0x65
867             ) {
868               adobe = {
869                 version: (appData[5] << 8) | appData[6],
870                 flags0: (appData[7] << 8) | appData[8],
871                 flags1: (appData[9] << 8) | appData[10],
872                 transformCode: appData[11],
873               };
874             }
875           }
876           break;
877 
878         case 0xffdb: // DQT (Define Quantization Tables)
879           const quantizationTablesLength = readUint16(data, offset);
880           offset += 2;
881           const quantizationTablesEnd = quantizationTablesLength + offset - 2;
882           let z;
883           while (offset < quantizationTablesEnd) {
884             const quantizationTableSpec = data[offset++];
885             const tableData = new Uint16Array(64);
886             if (quantizationTableSpec >> 4 === 0) {
887               // 8 bit values
888               for (j = 0; j < 64; j++) {
889                 z = dctZigZag[j];
890                 tableData[z] = data[offset++];
891               }
892             } else if (quantizationTableSpec >> 4 === 1) {
893               // 16 bit values
894               for (j = 0; j < 64; j++) {
895                 z = dctZigZag[j];
896                 tableData[z] = readUint16(data, offset);
897                 offset += 2;
898               }
899             } else {
900               throw new JpegError("DQT - invalid table spec");
901             }
902             quantizationTables[quantizationTableSpec & 15] = tableData;
903           }
904           break;
905 
906         case 0xffc0: // SOF0 (Start of Frame, Baseline DCT)
907         case 0xffc1: // SOF1 (Start of Frame, Extended DCT)
908         case 0xffc2: // SOF2 (Start of Frame, Progressive DCT)
909           if (frame) {
910             throw new JpegError("Only single frame JPEGs supported");
911           }
912           offset += 2; // Skip marker length.
913 
914           frame = {};
915           frame.extended = fileMarker === 0xffc1;
916           frame.progressive = fileMarker === 0xffc2;
917           frame.precision = data[offset++];
918           const sofScanLines = readUint16(data, offset);
919           offset += 2;
920           frame.scanLines = dnlScanLines || sofScanLines;
921           frame.samplesPerLine = readUint16(data, offset);
922           offset += 2;
923           frame.components = [];
924           frame.componentIds = {};
925           const componentsCount = data[offset++];
926           let maxH = 0,
927             maxV = 0;
928           for (i = 0; i < componentsCount; i++) {
929             const componentId = data[offset];
930             const h = data[offset + 1] >> 4;
931             const v = data[offset + 1] & 15;
932             if (maxH < h) {
933               maxH = h;
934             }
935             if (maxV < v) {
936               maxV = v;
937             }
938             const qId = data[offset + 2];
939             l = frame.components.push({
940               h,
941               v,
942               quantizationId: qId,
943               quantizationTable: null, // See comment below.
944             });
945             frame.componentIds[componentId] = l - 1;
946             offset += 3;
947           }
948           frame.maxH = maxH;
949           frame.maxV = maxV;
950           prepareComponents(frame);
951           break;
952 
953         case 0xffc4: // DHT (Define Huffman Tables)
954           const huffmanLength = readUint16(data, offset);
955           offset += 2;
956           for (i = 2; i < huffmanLength; ) {
957             const huffmanTableSpec = data[offset++];
958             const codeLengths = new Uint8Array(16);
959             let codeLengthSum = 0;
960             for (j = 0; j < 16; j++, offset++) {
961               codeLengthSum += codeLengths[j] = data[offset];
962             }
963             const huffmanValues = new Uint8Array(codeLengthSum);
964             for (j = 0; j < codeLengthSum; j++, offset++) {
965               huffmanValues[j] = data[offset];
966             }
967             i += 17 + codeLengthSum;
968 
969             (huffmanTableSpec >> 4 === 0 ? huffmanTablesDC : huffmanTablesAC)[
970               huffmanTableSpec & 15
971             ] = buildHuffmanTable(codeLengths, huffmanValues);
972           }
973           break;
974 
975         case 0xffdd: // DRI (Define Restart Interval)
976           offset += 2; // Skip marker length.
977 
978           resetInterval = readUint16(data, offset);
979           offset += 2;
980           break;
981 
982         case 0xffda: // SOS (Start of Scan)
983           // A DNL marker (0xFFDC), if it exists, is only allowed at the end
984           // of the first scan segment and may only occur once in an image.
985           // Furthermore, to prevent an infinite loop, do *not* attempt to
986           // parse DNL markers during re-parsing of the JPEG scan data.
987           const parseDNLMarker = ++numSOSMarkers === 1 && !dnlScanLines;
988 
989           offset += 2; // Skip marker length.
990 
991           const selectorsCount = data[offset++],
992             components = [];
993           for (i = 0; i < selectorsCount; i++) {
994             const index = data[offset++];
995             const componentIndex = frame.componentIds[index];
996             const component = frame.components[componentIndex];
997             component.index = index;
998             const tableSpec = data[offset++];
999             component.huffmanTableDC = huffmanTablesDC[tableSpec >> 4];
1000             component.huffmanTableAC = huffmanTablesAC[tableSpec & 15];
1001             components.push(component);
1002           }
1003           const spectralStart = data[offset++],
1004             spectralEnd = data[offset++],
1005             successiveApproximation = data[offset++];
1006           try {
1007             const processed = decodeScan(
1008               data,
1009               offset,
1010               frame,
1011               components,
1012               resetInterval,
1013               spectralStart,
1014               spectralEnd,
1015               successiveApproximation >> 4,
1016               successiveApproximation & 15,
1017               parseDNLMarker
1018             );
1019             offset += processed;
1020           } catch (ex) {
1021             if (ex instanceof DNLMarkerError) {
1022               warn(`${ex.message} -- attempting to re-parse the JPEG image.`);
1023               return this.parse(data, { dnlScanLines: ex.scanLines });
1024             } else if (ex instanceof EOIMarkerError) {
1025               warn(`${ex.message} -- ignoring the rest of the image data.`);
1026               break markerLoop;
1027             }
1028             throw ex;
1029           }
1030           break;
1031 
1032         case 0xffdc: // DNL (Define Number of Lines)
1033           // Ignore the marker, since it's being handled in `decodeScan`.
1034           offset += 4;
1035           break;
1036 
1037         case 0xffff: // Fill bytes
1038           if (data[offset] !== 0xff) {
1039             // Avoid skipping a valid marker.
1040             offset--;
1041           }
1042           break;
1043 
1044         default:
1045           // Could be incorrect encoding -- the last 0xFF byte of the previous
1046           // block could have been eaten by the encoder, hence we fallback to
1047           // `startPos = offset - 3` when looking for the next valid marker.
1048           const nextFileMarker = findNextFileMarker(
1049             data,
1050             /* currentPos = */ offset - 2,
1051             /* startPos = */ offset - 3
1052           );
1053           if (nextFileMarker?.invalid) {
1054             warn(
1055               "JpegImage.parse - unexpected data, current marker is: " +
1056                 nextFileMarker.invalid
1057             );
1058             offset = nextFileMarker.offset;
1059             break;
1060           }
1061           if (!nextFileMarker || offset >= data.length - 1) {
1062             warn(
1063               "JpegImage.parse - reached the end of the image data " +
1064                 "without finding an EOI marker (0xFFD9)."
1065             );
1066             break markerLoop;
1067           }
1068           throw new JpegError(
1069             "JpegImage.parse - unknown marker: " + fileMarker.toString(16)
1070           );
1071       }
1072       fileMarker = readUint16(data, offset);
1073       offset += 2;
1074     }
1075 
1076     this.width = frame.samplesPerLine;
1077     this.height = frame.scanLines;
1078     this.jfif = jfif;
1079     this.adobe = adobe;
1080     this.components = [];
1081     for (const component of frame.components) {
1082       // Prevent errors when DQT markers are placed after SOF{n} markers,
1083       // by assigning the `quantizationTable` entry after the entire image
1084       // has been parsed (fixes issue7406.pdf).
1085       const quantizationTable = quantizationTables[component.quantizationId];
1086       if (quantizationTable) {
1087         component.quantizationTable = quantizationTable;
1088       }
1089 
1090       this.components.push({
1091         index: component.index,
1092         output: buildComponentData(frame, component),
1093         scaleX: component.h / frame.maxH,
1094         scaleY: component.v / frame.maxV,
1095         blocksPerLine: component.blocksPerLine,
1096         blocksPerColumn: component.blocksPerColumn,
1097       });
1098     }
1099     this.numComponents = this.components.length;
1100     return undefined;
1101   }
1102 
1578 }
1579 
</code>

PR summary:
<pr_summary>
Throw a `JpegError` when a JPEG image has no frame data (issue 17302)
Given that there's nothing to parse in this case, since we're dealing with an invalid JPEG image, throwing an *explicit* Error makes sense here.
</pr_summary>

Your task:
You are a software tester at pdf.js.
1. Write exactly one javascript test `it("...", async () => {...})` block.
2. Your test must fail on the code before the patch, and pass after, hence the test will verify that the patch resolves the issue.
3. The test must be self-contained and to-the-point.
4. Use only the provided imports (respect the paths exactly how they are given) by importing dynamically for compatibility with Node.js — no new dependencies. 
5. Return only the javascript code (no comments or explanations).

Example structure:
it("should <describe behavior>", async () => {
  const { example } = await import("../../src/core/example.js");
  <initialize required variables>;
  <define expected variable>;
  <generate actual variables>;
  <compare expected with actual>;
});

