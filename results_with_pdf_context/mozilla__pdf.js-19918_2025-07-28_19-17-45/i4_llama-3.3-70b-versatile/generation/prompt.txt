Before you begin:
- Keep going until the job is completely solved — don’t stop halfway.
- If you’re unsure about the behavior, reread the provided patch carefully; do not hallucinate.
- Plan your approach before writing code by reflecting on whether the test truly fails before and passes after.

Issue:
<issue>
Support decoding cmyk jpeg image in using ImageDecoder
</issue>

Patch:
<patch>
diff --git a/src/core/jpeg_stream.js b/src/core/jpeg_stream.js
--- a/src/core/jpeg_stream.js
+++ b/src/core/jpeg_stream.js
@@ -44,6 +44,16 @@ class JpegStream extends DecodeStream {
     );
   }
 
+  static get canUseImageDecoderCMYK() {
+    return shadow(
+      this,
+      "canUseImageDecoderCMYK",
+      this.#isImageDecoderSupported
+        ? ImageDecoder.isTypeSupported("image/x-jpeg-pdf")
+        : Promise.resolve(false)
+    );
+  }
+
   static setOptions({ isImageDecoderSupported = false }) {
     this.#isImageDecoderSupported = isImageDecoderSupported;
   }
@@ -171,6 +181,14 @@ class JpegStream extends DecodeStream {
       if (!useImageDecoder) {
         return null;
       }
+      let type = "image/jpeg";
+      if (useImageDecoder.cmyk) {
+        if (await JpegStream.canUseImageDecoderCMYK) {
+          type = "image/x-jpeg-pdf";
+        } else {
+          return null;
+        }
+      }
       if (useImageDecoder.exifStart) {
         // Replace the entire EXIF-block with dummy data, to ensure that a
         // non-default EXIF orientation won't cause the image to be rotated
@@ -182,7 +200,7 @@ class JpegStream extends DecodeStream {
       }
       decoder = new ImageDecoder({
         data,
-        type: "image/jpeg",
+        type,
         preferAnimation: false,
       });

diff --git a/src/core/jpg.js b/src/core/jpg.js
--- a/src/core/jpg.js
+++ b/src/core/jpg.js
@@ -810,7 +810,7 @@ class JpegImage {
   }
 
   static canUseImageDecoder(data, colorTransform = -1) {
-    let exifOffsets = null;
+    const jpegInfo = Object.create(null);
     let offset = 0;
     let numComponents = null;
     let fileMarker = readUint16(data, offset);
@@ -838,12 +838,13 @@ class JpegImage {
             appData[4] === 0 &&
             appData[5] === 0
           ) {
-            if (exifOffsets) {
+            if (jpegInfo.exifStart) {
               throw new JpegError("Duplicate EXIF-blocks found.");
             }
             // Don't do the EXIF-block replacement here, see `JpegStream`,
             // since that can modify the original PDF document.
-            exifOffsets = { exifStart: oldOffset + 6, exifEnd: newOffset };
+            jpegInfo.exifStart = oldOffset + 6;
+            jpegInfo.exifEnd = newOffset;
           }
           fileMarker = readUint16(data, offset);
           offset += 2;
@@ -868,13 +869,13 @@ class JpegImage {
       fileMarker = readUint16(data, offset);
       offset += 2;
     }
-    if (numComponents === 4) {
-      return null;
-    }
     if (numComponents === 3 && colorTransform === 0) {
       return null;
     }
-    return exifOffsets || {};
+    if (numComponents === 4) {
+      jpegInfo.cmyk = true;
+    }
+    return jpegInfo;
   }
 
   parse(data, { dnlScanLines = null } = {}) {


</patch>

Imports:
<imports>
Available Packages
Dev Dependencies:
- @babel/core: ^7.26.10
- @babel/preset-env: ^7.26.9
- @babel/runtime: ^7.27.0
- @csstools/postcss-light-dark-function: ^2.0.8
- @fluent/bundle: ^0.19.1
- @fluent/dom: ^0.10.1
- @metalsmith/layouts: ^3.0.0
- @metalsmith/markdown: ^1.10.0
- @napi-rs/canvas: ^0.1.69
- @types/node: ^22.15.2
- autoprefixer: ^10.4.21
- babel-loader: ^10.0.0
- caniuse-lite: ^1.0.30001715
- core-js: ^3.41.0
- eslint: ^9.25.1
- eslint-plugin-import: ^2.31.0
- eslint-plugin-jasmine: ^4.2.2
- eslint-plugin-json: ^4.0.1
- eslint-plugin-no-unsanitized: ^4.1.2
- eslint-plugin-perfectionist: ^4.12.3
- eslint-plugin-prettier: ^5.2.6
- eslint-plugin-unicorn: ^58.0.0
- globals: ^16.0.0
- gulp: ^5.0.0
- gulp-cli: ^3.0.0
- gulp-postcss: ^10.0.0
- gulp-rename: ^2.0.0
- gulp-replace: ^1.1.4
- gulp-zip: ^6.1.0
- highlight.js: ^11.11.1
- jasmine: ^5.6.0
- jsdoc: ^4.0.4
- jstransformer-nunjucks: ^1.2.0
- metalsmith: ^2.6.3
- metalsmith-html-relative: ^2.0.6
- ordered-read-streams: ^2.0.0
- pngjs: ^7.0.0
- postcss: ^8.5.3
- postcss-dir-pseudo-class: ^9.0.1
- postcss-discard-comments: ^7.0.3
- postcss-nesting: ^13.0.1
- prettier: ^3.5.3
- puppeteer: ^24.7.2
- stylelint: ^16.19.1
- stylelint-prettier: ^5.0.3
- svglint: ^3.1.0
- terser-webpack-plugin: ^5.3.14
- tsc-alias: ^1.8.15
- ttest: ^4.0.0
- typescript: ^5.8.3
- vinyl: ^3.0.0
- webpack: ^5.99.7
- webpack-stream: ^7.0.0
- yargs: ^17.7.2

Engines:
- node: >=20.16.0 || >=22.3.0

Available Relative Imports:
- `../../src/core/annotation.js`: Annotation, AnnotationBorderStyle, AnnotationFactory, MarkupAnnotation, getQuadPoints
- `../../src/core/bidi.js`: bidi
- `../../src/core/calculate_md5.js`: calculateMD5
- `../../src/core/calculate_sha256.js`: calculateSHA256
- `../../src/core/calculate_sha_other.js`: calculateSHA384, calculateSHA512
- `../../src/core/cff_parser.js`: CFFCharset, CFFCompiler, CFFFDSelect, CFFParser, CFFStrings
- `../../src/core/cmap.js`: CMap, CMapFactory, IdentityCMap
- `../../src/core/colorspace.js`: ColorSpace
- `../../src/core/colorspace_utils.js`: ColorSpaceUtils
- `../../src/core/core_utils.js`: arrayBuffersToBytes, encodeToXmlString, escapePDFName, escapeString, getInheritableProperty, getSizeInBytes, isAscii, isWhiteSpace, log2, numberToString, parseXFAPath, recoverJsURL, stringToUTF16HexString, stringToUTF16String, toRomanNumerals, validateCSSFont
- `../../src/core/crypto.js`: AES128Cipher, AES256Cipher, ARCFourCipher, CipherTransformFactory, PDF17, PDF20
- `../../src/core/default_appearance.js`: createDefaultAppearance, parseAppearanceStream, parseDefaultAppearance
- `../../src/core/document.js`: PDFDocument, Page
- `../../src/core/encodings.js`: getEncoding
- `../../src/core/evaluator.js`: PartialEvaluator
- `../../src/core/flate_stream.js`: FlateStream
- `../../src/core/font_substitutions.js`: getFontSubstitution
- `../../src/core/fonts_utils.js`: SEAC_ANALYSIS_ENABLED
- `../../src/core/function.js`: PDFFunctionFactory, PostScriptCompiler, PostScriptEvaluator
- `../../src/core/glyphlist.js`: getDingbatsGlyphsUnicode, getGlyphsUnicode
- `../../src/core/image_utils.js`: GlobalColorSpaceCache, GlobalImageCache, LocalColorSpaceCache
- `../../src/core/jbig2.js`: Jbig2Error, Jbig2Image
- `../../src/core/jpg.js`: JpegError, JpegImage
- `../../src/core/jpx.js`: JpxError, JpxImage
- `../../src/core/metadata_parser.js`: MetadataParser
- `../../src/core/operator_list.js`: OperatorList
- `../../src/core/parser.js`: Lexer, Linearization, Parser
- `../../src/core/predictor_stream.js`: PredictorStream
- `../../src/core/primitives.js`: Cmd, Dict, EOF, Name, Ref, RefSet, RefSetCache, isCmd, isDict, isName, isRefsEqual
- `../../src/core/ps_parser.js`: PostScriptLexer, PostScriptParser
- `../../src/core/stream.js`: NullStream, Stream, StringStream
- `../../src/core/type1_parser.js`: Type1Parser
- `../../src/core/unicode.js`: getCharUnicodeCategory, getUnicodeForGlyph, getUnicodeRangeFor, mapSpecialUnicodeValues
- `../../src/core/worker.js`: WorkerMessageHandler, WorkerTask
- `../../src/core/writer.js`: incrementalUpdate, writeChanges, writeDict
- `../../src/core/xfa/bind.js`: Binder
- `../../src/core/xfa/data.js`: DataHandler
- `../../src/core/xfa/factory.js`: XFAFactory
- `../../src/core/xfa/formcalc_lexer.js`: Lexer, TOKEN, Token
- `../../src/core/xfa/formcalc_parser.js`: Errors, Parser
- `../../src/core/xfa/parser.js`: XFAParser
- `../../src/core/xfa/som.js`: searchNode
- `../../src/core/xfa/symbol_utils.js`: $dump, $getChildren, $getChildrenByClass, $getChildrenByName, $text, $uid
- `../../src/core/xml_parser.js`: SimpleXMLParser, XMLParserBase
- `../../src/display/annotation_layer.js`: AnnotationLayer
- `../../src/display/annotation_storage.js`: AnnotationStorage
- `../../src/display/api.js`: LoopbackPort, PDFDataRangeTransport, PDFDocumentLoadingTask, PDFDocumentProxy, PDFPageProxy, PDFWorker, RenderTask, build, getDocument, isValidExplicitDest, version
- `../../src/display/canvas_factory.js`: DOMCanvasFactory
- `../../src/display/cmap_reader_factory.js`: DOMCMapReaderFactory
- `../../src/display/display_utils.js`: OutputScale, PDFDateString, PageViewport, PixelsPerInch, RenderingCancelledException, StatTimer, SupportedImageMimeTypes, fetchData, getFilenameFromUrl, getPdfFilenameFromUrl, getXfaPageViewport, isDataScheme, isPdfFile, isValidFetchUrl, noContextMenu, setLayerDimensions, stopEvent
- `../../src/display/draw_layer.js`: DrawLayer
- `../../src/display/editor/annotation_editor_layer.js`: AnnotationEditorLayer
- `../../src/display/editor/color_picker.js`: ColorPicker
- `../../src/display/editor/drawers/signaturedraw.js`: SignatureExtractor
- `../../src/display/editor/tools.js`: AnnotationEditorUIManager, CommandManager
- `../../src/display/fetch_stream.js`: PDFFetchStream
- `../../src/display/metadata.js`: Metadata
- `../../src/display/network.js`: PDFNetworkStream
- `../../src/display/network_utils.js`: createHeaders, createResponseError, extractFilenameFromHeader, validateRangeRequestCapabilities, validateResponseStatus
- `../../src/display/node_stream.js`: PDFNodeStream
- `../../src/display/node_utils.js`: NodeCMapReaderFactory, NodeStandardFontDataFactory, fetchData
- `../../src/display/standard_fontdata_factory.js`: DOMStandardFontDataFactory
- `../../src/display/svg_factory.js`: DOMSVGFactory
- `../../src/display/text_layer.js`: TextLayer
- `../../src/display/touch_manager.js`: TouchManager
- `../../src/display/worker_options.js`: GlobalWorkerOptions
- `../../src/display/xfa_layer.js`: XfaLayer
- `../../src/shared/message_handler.js`: MessageHandler
- `../../src/shared/murmurhash3.js`: MurmurHash3_64
- `../../src/shared/util.js`: AbortException, AnnotationBorderStyleType, AnnotationEditorParamsType, AnnotationEditorType, AnnotationFieldFlag, AnnotationFlag, AnnotationMode, AnnotationType, BaseException, DrawOPS, FeatureTest, FormatError, ImageKind, InvalidPDFException, MathClamp, OPS, PasswordException, PasswordResponses, PermissionFlag, RenderingIntentFlag, ResponseException, UnknownErrorException, Util, VerbosityLevel, assert, bytesToString, createValidAbsoluteUrl, getModificationDate, getUuid, getVerbosityLevel, isNodeJS, normalizeUnicode, objectSize, setVerbosityLevel, shadow, string32, stringToBytes, stringToPDFString, stringToUTF8String, toBase64Util, updateUrlHash
- `../../web/annotation_layer_builder.js`: AnnotationLayerBuilder
- `../../web/app_options.js`: AppOptions, OptionKind
- `../../web/autolinker.js`: Autolinker
- `../../web/download_manager.js`: DownloadManager
- `../../web/event_utils.js`: EventBus, WaitOnType, waitOnEventOrTimeout
- `../../web/genericl10n.js`: GenericL10n
- `../../web/pdf_find_controller.js`: FindState, PDFFindController
- `../../web/pdf_find_utils.js`: CharacterType, getCharacterType
- `../../web/pdf_history.js`: PDFHistory, isDestArraysEqual, isDestHashesEqual
- `../../web/pdf_link_service.js`: LinkTarget, PDFLinkService, SimpleLinkService
- `../../web/pdf_page_view.js`: PDFPageView
- `../../web/pdf_scripting_manager.component.js`: PDFScriptingManager
- `../../web/pdf_single_page_viewer.js`: PDFSinglePageViewer
- `../../web/pdf_viewer.js`: PDFPageViewBuffer, PDFViewer
- `../../web/struct_tree_layer_builder.js`: StructTreeLayerBuilder
- `../../web/text_layer_builder.js`: TextLayerBuilder
- `../../web/ui_utils.js`: AutoPrintRegExp, ProgressBar, RenderingStates, ScrollMode, SpreadMode, backtrackBeforeAllVisibleElements, binarySearchFirstItem, calcRound, getPageSizeInches, getVisibleElements, isPortraitOrientation, isValidRotation, parseQueryString, removeNullCharacters
- `../../web/xfa_layer_builder.js`: XfaLayerBuilder
- `../reporter.js`: TestReporter
- `./common_pdfstream_tests.js`: testCrossOriginRedirects
- `./test_utils.js`: CMAP_URL, DefaultCMapReaderFactory, DefaultFileReaderFactory, DefaultStandardFontDataFactory, STANDARD_FONT_DATA_URL, TEST_PDFS_PATH, TestPdfsServer, XRefMock, buildGetDocumentParams, createIdFactory, getCrossOriginHostname
</imports>

Code:
<code>
File:
src/core/jpeg_stream.js
1 /* Copyright 2012 Mozilla Foundation
2  *
3  * Licensed under the Apache License, Version 2.0 (the "License");
4  * you may not use this file except in compliance with the License.
5  * You may obtain a copy of the License at
6  *
7  *     http://www.apache.org/licenses/LICENSE-2.0
8  *
9  * Unless required by applicable law or agreed to in writing, software
10  * distributed under the License is distributed on an "AS IS" BASIS,
11  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
12  * See the License for the specific language governing permissions and
13  * limitations under the License.
14  */
15 
16 import { FeatureTest, shadow, warn } from "../shared/util.js";
17 import { DecodeStream } from "./decode_stream.js";
18 import { Dict } from "./primitives.js";
19 import { JpegImage } from "./jpg.js";
20 
21 /**
22  * For JPEG's we use a library to decode these images and the stream behaves
23  * like all the other DecodeStreams.
24  */
25 class JpegStream extends DecodeStream {
26   static #isImageDecoderSupported = FeatureTest.isImageDecoderSupported;
27 
28   constructor(stream, maybeLength, params) {
29     super(maybeLength);
30 
31     this.stream = stream;
32     this.dict = stream.dict;
33     this.maybeLength = maybeLength;
34     this.params = params;
35   }
36 
37   static get canUseImageDecoder() {
38     return shadow(
39       this,
40       "canUseImageDecoder",
41       this.#isImageDecoderSupported
42         ? ImageDecoder.isTypeSupported("image/jpeg")
43         : Promise.resolve(false)
44     );
45   }
46 
47   static setOptions({ isImageDecoderSupported = false }) {
48     this.#isImageDecoderSupported = isImageDecoderSupported;
49   }
50 
51   get bytes() {
52     // If `this.maybeLength` is null, we'll get the entire stream.
53     return shadow(this, "bytes", this.stream.getBytes(this.maybeLength));
54   }
55 
56   ensureBuffer(requested) {
57     // No-op, since `this.readBlock` will always parse the entire image and
58     // directly insert all of its data into `this.buffer`.
59   }
60 
61   readBlock() {
62     this.decodeImage();
63   }
64 
65   get jpegOptions() {
66     const jpegOptions = {
67       decodeTransform: undefined,
68       colorTransform: undefined,
69     };
70 
71     // Checking if values need to be transformed before conversion.
72     const decodeArr = this.dict.getArray("D", "Decode");
73     if ((this.forceRGBA || this.forceRGB) && Array.isArray(decodeArr)) {
74       const bitsPerComponent = this.dict.get("BPC", "BitsPerComponent") || 8;
75       const decodeArrLength = decodeArr.length;
76       const transform = new Int32Array(decodeArrLength);
77       let transformNeeded = false;
78       const maxValue = (1 << bitsPerComponent) - 1;
79       for (let i = 0; i < decodeArrLength; i += 2) {
80         transform[i] = ((decodeArr[i + 1] - decodeArr[i]) * 256) | 0;
81         transform[i + 1] = (decodeArr[i] * maxValue) | 0;
82         if (transform[i] !== 256 || transform[i + 1] !== 0) {
83           transformNeeded = true;
84         }
85       }
86       if (transformNeeded) {
87         jpegOptions.decodeTransform = transform;
88       }
89     }
90     // Fetching the 'ColorTransform' entry, if it exists.
91     if (this.params instanceof Dict) {
92       const colorTransform = this.params.get("ColorTransform");
93       if (Number.isInteger(colorTransform)) {
94         jpegOptions.colorTransform = colorTransform;
95       }
96     }
97     return shadow(this, "jpegOptions", jpegOptions);
98   }
99 
100   #skipUselessBytes(data) {
101     // Some images may contain 'junk' before the SOI (start-of-image) marker.
102     // Note: this seems to mainly affect inline images.
103     for (let i = 0, ii = data.length - 1; i < ii; i++) {
104       if (data[i] === 0xff && data[i + 1] === 0xd8) {
105         if (i > 0) {
106           data = data.subarray(i);
107         }
108         break;
109       }
110     }
111     return data;
112   }
113 
114   decodeImage(bytes) {
115     if (this.eof) {
116       return this.buffer;
117     }
118     bytes = this.#skipUselessBytes(bytes || this.bytes);
119 
120     // TODO: if an image has a mask we need to combine the data.
121     // So ideally get a VideoFrame from getTransferableImage and then use
122     // copyTo.
123 
124     const jpegImage = new JpegImage(this.jpegOptions);
125     jpegImage.parse(bytes);
126     const data = jpegImage.getData({
127       width: this.drawWidth,
128       height: this.drawHeight,
129       forceRGBA: this.forceRGBA,
130       forceRGB: this.forceRGB,
131       isSourcePDF: true,
132     });
133     this.buffer = data;
134     this.bufferLength = data.length;
135     this.eof = true;
136 
137     return this.buffer;
138   }
139 
140   get canAsyncDecodeImageFromBuffer() {
141     return this.stream.isAsync;
142   }
143 
144   async getTransferableImage() {
145     if (!(await JpegStream.canUseImageDecoder)) {
146       return null;
147     }
148     const jpegOptions = this.jpegOptions;
149     if (jpegOptions.decodeTransform) {
150       // TODO: We could decode the image thanks to ImageDecoder and then
151       // get the pixels with copyTo and apply the decodeTransform.
152       return null;
153     }
154     let decoder;
155     try {
156       // TODO: If the stream is Flate & DCT we could try to just pipe the
157       // the DecompressionStream into the ImageDecoder: it'll avoid the
158       // intermediate ArrayBuffer.
159       const bytes =
160         (this.canAsyncDecodeImageFromBuffer &&
161           (await this.stream.asyncGetBytes())) ||
162         this.bytes;
163       if (!bytes) {
164         return null;
165       }
166       let data = this.#skipUselessBytes(bytes);
167       const useImageDecoder = JpegImage.canUseImageDecoder(
168         data,
169         jpegOptions.colorTransform
170       );
171       if (!useImageDecoder) {
172         return null;
173       }
174       if (useImageDecoder.exifStart) {
175         // Replace the entire EXIF-block with dummy data, to ensure that a
176         // non-default EXIF orientation won't cause the image to be rotated
177         // when using `ImageDecoder` (fixes bug1942064.pdf).
178         //
179         // Copy the data first, to avoid modifying the original PDF document.
180         data = data.slice();
181         data.fill(0x00, useImageDecoder.exifStart, useImageDecoder.exifEnd);
182       }
183       decoder = new ImageDecoder({
184         data,
185         type: "image/jpeg",
186         preferAnimation: false,
187       });
188 
189       return (await decoder.decode()).image;
190     } catch (reason) {
191       warn(`getTransferableImage - failed: "${reason}".`);
192       return null;
193     } finally {
194       decoder?.close();
195     }
196   }
197 }
198 
199 export { JpegStream };
File:
src/core/jpg.js
1 /* Copyright 2014 Mozilla Foundation
2  *
3  * Licensed under the Apache License, Version 2.0 (the 'License');
4  * you may not use this file except in compliance with the License.
5  * You may obtain a copy of the License at
6  *
7  *     http://www.apache.org/licenses/LICENSE-2.0
8  *
9  * Unless required by applicable law or agreed to in writing, software
10  * distributed under the License is distributed on an 'AS IS' BASIS,
11  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
12  * See the License for the specific language governing permissions and
13  * limitations under the License.
14  */
15 
16 import { assert, BaseException, warn } from "../shared/util.js";
17 import { ColorSpaceUtils } from "./colorspace_utils.js";
18 import { DeviceCmykCS } from "./colorspace.js";
19 import { grayToRGBA } from "../shared/image_utils.js";
20 import { readUint16 } from "./core_utils.js";
21 
22 class JpegError extends BaseException {
23   constructor(msg) {
24     super(msg, "JpegError");
25   }
26 }
27 
28 class DNLMarkerError extends BaseException {
29   constructor(message, scanLines) {
30     super(message, "DNLMarkerError");
31     this.scanLines = scanLines;
32   }
33 }
34 
35 class EOIMarkerError extends BaseException {
36   constructor(msg) {
37     super(msg, "EOIMarkerError");
38   }
39 }
40 
41 /**
42  * This code was forked from https://github.com/notmasteryet/jpgjs.
43  * The original version was created by GitHub user notmasteryet.
44  *
45  * - The JPEG specification can be found in the ITU CCITT Recommendation T.81
46  *   (www.w3.org/Graphics/JPEG/itu-t81.pdf)
47  * - The JFIF specification can be found in the JPEG File Interchange Format
48  *   (www.w3.org/Graphics/JPEG/jfif3.pdf)
49  * - The Adobe Application-Specific JPEG markers in the
50  *   Supporting the DCT Filters in PostScript Level 2, Technical Note #5116
51  *   (partners.adobe.com/public/developer/en/ps/sdk/5116.DCT_Filter.pdf)
52  */
53 
54 // prettier-ignore
55 const dctZigZag = new Uint8Array([
56    0,
57    1,  8,
58   16,  9,  2,
59    3, 10, 17, 24,
60   32, 25, 18, 11, 4,
61    5, 12, 19, 26, 33, 40,
62   48, 41, 34, 27, 20, 13,  6,
63    7, 14, 21, 28, 35, 42, 49, 56,
64   57, 50, 43, 36, 29, 22, 15,
65   23, 30, 37, 44, 51, 58,
66   59, 52, 45, 38, 31,
67   39, 46, 53, 60,
68   61, 54, 47,
69   55, 62,
70   63
71 ]);
72 
73 const dctCos1 = 4017; // cos(pi/16)
74 const dctSin1 = 799; // sin(pi/16)
75 const dctCos3 = 3406; // cos(3*pi/16)
76 const dctSin3 = 2276; // sin(3*pi/16)
77 const dctCos6 = 1567; // cos(6*pi/16)
78 const dctSin6 = 3784; // sin(6*pi/16)
79 const dctSqrt2 = 5793; // sqrt(2)
80 const dctSqrt1d2 = 2896; // sqrt(2) / 2
81 
82 function buildHuffmanTable(codeLengths, values) {
83   let k = 0,
84     i,
85     j,
86     length = 16;
87   while (length > 0 && !codeLengths[length - 1]) {
88     length--;
89   }
90   const code = [{ children: [], index: 0 }];
91   let p = code[0],
92     q;
93   for (i = 0; i < length; i++) {
94     for (j = 0; j < codeLengths[i]; j++) {
95       p = code.pop();
96       p.children[p.index] = values[k];
97       while (p.index > 0) {
98         p = code.pop();
99       }
100       p.index++;
101       code.push(p);
102       while (code.length <= i) {
103         code.push((q = { children: [], index: 0 }));
104         p.children[p.index] = q.children;
105         p = q;
106       }
107       k++;
108     }
109     if (i + 1 < length) {
110       // p here points to last code
111       code.push((q = { children: [], index: 0 }));
112       p.children[p.index] = q.children;
113       p = q;
114     }
115   }
116   return code[0].children;
117 }
118 
119 function getBlockBufferOffset(component, row, col) {
120   return 64 * ((component.blocksPerLine + 1) * row + col);
121 }
122 
123 function decodeScan(
124   data,
125   offset,
126   frame,
127   components,
128   resetInterval,
129   spectralStart,
130   spectralEnd,
131   successivePrev,
132   successive,
133   parseDNLMarker = false
134 ) {
135   const mcusPerLine = frame.mcusPerLine;
136   const progressive = frame.progressive;
137 
138   const startOffset = offset;
139   let bitsData = 0,
140     bitsCount = 0;
141 
142   function readBit() {
143     if (bitsCount > 0) {
144       bitsCount--;
145       return (bitsData >> bitsCount) & 1;
146     }
147     bitsData = data[offset++];
148     if (bitsData === 0xff) {
149       const nextByte = data[offset++];
150       if (nextByte) {
151         if (nextByte === /* DNL = */ 0xdc && parseDNLMarker) {
152           offset += 2; // Skip marker length.
153 
154           const scanLines = readUint16(data, offset);
155           offset += 2;
156           if (scanLines > 0 && scanLines !== frame.scanLines) {
157             throw new DNLMarkerError(
158               "Found DNL marker (0xFFDC) while parsing scan data",
159               scanLines
160             );
161           }
162         } else if (nextByte === /* EOI = */ 0xd9) {
163           if (parseDNLMarker) {
164             // NOTE: only 8-bit JPEG images are supported in this decoder.
165             const maybeScanLines = blockRow * (frame.precision === 8 ? 8 : 0);
166             // Heuristic to attempt to handle corrupt JPEG images with too
167             // large `scanLines` parameter, by falling back to the currently
168             // parsed number of scanLines when it's at least (approximately)
169             // one "half" order of magnitude smaller than expected (fixes
170             // issue10880.pdf, issue10989.pdf, issue15492.pdf).
171             if (
172               maybeScanLines > 0 &&
173               Math.round(frame.scanLines / maybeScanLines) >= 5
174             ) {
175               throw new DNLMarkerError(
176                 "Found EOI marker (0xFFD9) while parsing scan data, " +
177                   "possibly caused by incorrect `scanLines` parameter",
178                 maybeScanLines
179               );
180             }
181           }
182           throw new EOIMarkerError(
183             "Found EOI marker (0xFFD9) while parsing scan data"
184           );
185         }
186         throw new JpegError(
187           `unexpected marker ${((bitsData << 8) | nextByte).toString(16)}`
188         );
189       }
190       // unstuff 0
191     }
192     bitsCount = 7;
193     return bitsData >>> 7;
194   }
195 
196   function decodeHuffman(tree) {
197     let node = tree;
198     while (true) {
199       node = node[readBit()];
200       switch (typeof node) {
201         case "number":
202           return node;
203         case "object":
204           continue;
205       }
206       throw new JpegError("invalid huffman sequence");
207     }
208   }
209 
210   function receive(length) {
211     let n = 0;
212     while (length > 0) {
213       n = (n << 1) | readBit();
214       length--;
215     }
216     return n;
217   }
218 
219   function receiveAndExtend(length) {
220     if (length === 1) {
221       return readBit() === 1 ? 1 : -1;
222     }
223     const n = receive(length);
224     if (n >= 1 << (length - 1)) {
225       return n;
226     }
227     return n + (-1 << length) + 1;
228   }
229 
230   function decodeBaseline(component, blockOffset) {
231     const t = decodeHuffman(component.huffmanTableDC);
232     const diff = t === 0 ? 0 : receiveAndExtend(t);
233     component.blockData[blockOffset] = component.pred += diff;
234     let k = 1;
235     while (k < 64) {
236       const rs = decodeHuffman(component.huffmanTableAC);
237       const s = rs & 15,
238         r = rs >> 4;
239       if (s === 0) {
240         if (r < 15) {
241           break;
242         }
243         k += 16;
244         continue;
245       }
246       k += r;
247       const z = dctZigZag[k];
248       component.blockData[blockOffset + z] = receiveAndExtend(s);
249       k++;
250     }
251   }
252 
253   function decodeDCFirst(component, blockOffset) {
254     const t = decodeHuffman(component.huffmanTableDC);
255     const diff = t === 0 ? 0 : receiveAndExtend(t) << successive;
256     component.blockData[blockOffset] = component.pred += diff;
257   }
258 
259   function decodeDCSuccessive(component, blockOffset) {
260     component.blockData[blockOffset] |= readBit() << successive;
261   }
262 
263   let eobrun = 0;
264   function decodeACFirst(component, blockOffset) {
265     if (eobrun > 0) {
266       eobrun--;
267       return;
268     }
269     let k = spectralStart;
270     const e = spectralEnd;
271     while (k <= e) {
272       const rs = decodeHuffman(component.huffmanTableAC);
273       const s = rs & 15,
274         r = rs >> 4;
275       if (s === 0) {
276         if (r < 15) {
277           eobrun = receive(r) + (1 << r) - 1;
278           break;
279         }
280         k += 16;
281         continue;
282       }
283       k += r;
284       const z = dctZigZag[k];
285       component.blockData[blockOffset + z] =
286         receiveAndExtend(s) * (1 << successive);
287       k++;
288     }
289   }
290 
291   let successiveACState = 0,
292     successiveACNextValue;
293   function decodeACSuccessive(component, blockOffset) {
294     let k = spectralStart;
295     const e = spectralEnd;
296     let r = 0;
297     let s;
298     let rs;
299     while (k <= e) {
300       const offsetZ = blockOffset + dctZigZag[k];
301       const sign = component.blockData[offsetZ] < 0 ? -1 : 1;
302       switch (successiveACState) {
303         case 0: // initial state
304           rs = decodeHuffman(component.huffmanTableAC);
305           s = rs & 15;
306           r = rs >> 4;
307           if (s === 0) {
308             if (r < 15) {
309               eobrun = receive(r) + (1 << r);
310               successiveACState = 4;
311             } else {
312               r = 16;
313               successiveACState = 1;
314             }
315           } else {
316             if (s !== 1) {
317               throw new JpegError("invalid ACn encoding");
318             }
319             successiveACNextValue = receiveAndExtend(s);
320             successiveACState = r ? 2 : 3;
321           }
322           continue;
323         case 1: // skipping r zero items
324         case 2:
325           if (component.blockData[offsetZ]) {
326             component.blockData[offsetZ] += sign * (readBit() << successive);
327           } else {
328             r--;
329             if (r === 0) {
330               successiveACState = successiveACState === 2 ? 3 : 0;
331             }
332           }
333           break;
334         case 3: // set value for a zero item
335           if (component.blockData[offsetZ]) {
336             component.blockData[offsetZ] += sign * (readBit() << successive);
337           } else {
338             component.blockData[offsetZ] = successiveACNextValue << successive;
339             successiveACState = 0;
340           }
341           break;
342         case 4: // eob
343           if (component.blockData[offsetZ]) {
344             component.blockData[offsetZ] += sign * (readBit() << successive);
345           }
346           break;
347       }
348       k++;
349     }
350     if (successiveACState === 4) {
351       eobrun--;
352       if (eobrun === 0) {
353         successiveACState = 0;
354       }
355     }
356   }
357 
358   let blockRow = 0;
359   function decodeMcu(component, decode, mcu, row, col) {
360     const mcuRow = (mcu / mcusPerLine) | 0;
361     const mcuCol = mcu % mcusPerLine;
362     blockRow = mcuRow * component.v + row;
363     const blockCol = mcuCol * component.h + col;
364     const blockOffset = getBlockBufferOffset(component, blockRow, blockCol);
365     decode(component, blockOffset);
366   }
367 
368   function decodeBlock(component, decode, mcu) {
369     blockRow = (mcu / component.blocksPerLine) | 0;
370     const blockCol = mcu % component.blocksPerLine;
371     const blockOffset = getBlockBufferOffset(component, blockRow, blockCol);
372     decode(component, blockOffset);
373   }
374 
375   const componentsLength = components.length;
376   let component, i, j, k, n;
377   let decodeFn;
378   if (progressive) {
379     if (spectralStart === 0) {
380       decodeFn = successivePrev === 0 ? decodeDCFirst : decodeDCSuccessive;
381     } else {
382       decodeFn = successivePrev === 0 ? decodeACFirst : decodeACSuccessive;
383     }
384   } else {
385     decodeFn = decodeBaseline;
386   }
387 
388   let mcu = 0,
389     fileMarker;
390   const mcuExpected =
391     componentsLength === 1
392       ? components[0].blocksPerLine * components[0].blocksPerColumn
393       : mcusPerLine * frame.mcusPerColumn;
394 
395   let h, v;
396   while (mcu <= mcuExpected) {
397     // reset interval stuff
398     const mcuToRead = resetInterval
399       ? Math.min(mcuExpected - mcu, resetInterval)
400       : mcuExpected;
401 
402     // The `mcuToRead === 0` case should only occur when all of the expected
403     // MCU data has been already parsed, i.e. when `mcu === mcuExpected`, but
404     // some corrupt JPEG images contain more data than intended and we thus
405     // want to skip over any extra RSTx markers below (fixes issue11794.pdf).
406     if (mcuToRead > 0) {
407       for (i = 0; i < componentsLength; i++) {
408         components[i].pred = 0;
409       }
410       eobrun = 0;
411 
412       if (componentsLength === 1) {
413         component = components[0];
414         for (n = 0; n < mcuToRead; n++) {
415           decodeBlock(component, decodeFn, mcu);
416           mcu++;
417         }
418       } else {
419         for (n = 0; n < mcuToRead; n++) {
420           for (i = 0; i < componentsLength; i++) {
421             component = components[i];
422             h = component.h;
423             v = component.v;
424             for (j = 0; j < v; j++) {
425               for (k = 0; k < h; k++) {
426                 decodeMcu(component, decodeFn, mcu, j, k);
427               }
428             }
429           }
430           mcu++;
431         }
432       }
433     }
434 
435     // find marker
436     bitsCount = 0;
437     fileMarker = findNextFileMarker(data, offset);
438     if (!fileMarker) {
439       break; // Reached the end of the image data without finding any marker.
440     }
441     if (fileMarker.invalid) {
442       // Some bad images seem to pad Scan blocks with e.g. zero bytes, skip
443       // past those to attempt to find a valid marker (fixes issue4090.pdf).
444       const partialMsg = mcuToRead > 0 ? "unexpected" : "excessive";
445       warn(
446         `decodeScan - ${partialMsg} MCU data, current marker is: ${fileMarker.invalid}`
447       );
448       offset = fileMarker.offset;
449     }
450     if (fileMarker.marker >= 0xffd0 && fileMarker.marker <= 0xffd7) {
451       // RSTx
452       offset += 2;
453     } else {
454       break;
455     }
456   }
457 
458   return offset - startOffset;
459 }
460 
461 // A port of poppler's IDCT method which in turn is taken from:
462 //   Christoph Loeffler, Adriaan Ligtenberg, George S. Moschytz,
463 //   'Practical Fast 1-D DCT Algorithms with 11 Multiplications',
464 //   IEEE Intl. Conf. on Acoustics, Speech & Signal Processing, 1989,
465 //   988-991.
466 function quantizeAndInverse(component, blockBufferOffset, p) {
467   const qt = component.quantizationTable,
468     blockData = component.blockData;
469   let v0, v1, v2, v3, v4, v5, v6, v7;
470   let p0, p1, p2, p3, p4, p5, p6, p7;
471   let t;
472 
473   if (!qt) {
474     throw new JpegError("missing required Quantization Table.");
475   }
476 
477   // inverse DCT on rows
478   for (let row = 0; row < 64; row += 8) {
479     // gather block data
480     p0 = blockData[blockBufferOffset + row];
481     p1 = blockData[blockBufferOffset + row + 1];
482     p2 = blockData[blockBufferOffset + row + 2];
483     p3 = blockData[blockBufferOffset + row + 3];
484     p4 = blockData[blockBufferOffset + row + 4];
485     p5 = blockData[blockBufferOffset + row + 5];
486     p6 = blockData[blockBufferOffset + row + 6];
487     p7 = blockData[blockBufferOffset + row + 7];
488 
489     // dequant p0
490     p0 *= qt[row];
491 
492     // check for all-zero AC coefficients
493     if ((p1 | p2 | p3 | p4 | p5 | p6 | p7) === 0) {
494       t = (dctSqrt2 * p0 + 512) >> 10;
495       p[row] = t;
496       p[row + 1] = t;
497       p[row + 2] = t;
498       p[row + 3] = t;
499       p[row + 4] = t;
500       p[row + 5] = t;
501       p[row + 6] = t;
502       p[row + 7] = t;
503       continue;
504     }
505     // dequant p1 ... p7
506     p1 *= qt[row + 1];
507     p2 *= qt[row + 2];
508     p3 *= qt[row + 3];
509     p4 *= qt[row + 4];
510     p5 *= qt[row + 5];
511     p6 *= qt[row + 6];
512     p7 *= qt[row + 7];
513 
514     // stage 4
515     v0 = (dctSqrt2 * p0 + 128) >> 8;
516     v1 = (dctSqrt2 * p4 + 128) >> 8;
517     v2 = p2;
518     v3 = p6;
519     v4 = (dctSqrt1d2 * (p1 - p7) + 128) >> 8;
520     v7 = (dctSqrt1d2 * (p1 + p7) + 128) >> 8;
521     v5 = p3 << 4;
522     v6 = p5 << 4;
523 
524     // stage 3
525     v0 = (v0 + v1 + 1) >> 1;
526     v1 = v0 - v1;
527     t = (v2 * dctSin6 + v3 * dctCos6 + 128) >> 8;
528     v2 = (v2 * dctCos6 - v3 * dctSin6 + 128) >> 8;
529     v3 = t;
530     v4 = (v4 + v6 + 1) >> 1;
531     v6 = v4 - v6;
532     v7 = (v7 + v5 + 1) >> 1;
533     v5 = v7 - v5;
534 
535     // stage 2
536     v0 = (v0 + v3 + 1) >> 1;
537     v3 = v0 - v3;
538     v1 = (v1 + v2 + 1) >> 1;
539     v2 = v1 - v2;
540     t = (v4 * dctSin3 + v7 * dctCos3 + 2048) >> 12;
541     v4 = (v4 * dctCos3 - v7 * dctSin3 + 2048) >> 12;
542     v7 = t;
543     t = (v5 * dctSin1 + v6 * dctCos1 + 2048) >> 12;
544     v5 = (v5 * dctCos1 - v6 * dctSin1 + 2048) >> 12;
545     v6 = t;
546 
547     // stage 1
548     p[row] = v0 + v7;
549     p[row + 7] = v0 - v7;
550     p[row + 1] = v1 + v6;
551     p[row + 6] = v1 - v6;
552     p[row + 2] = v2 + v5;
553     p[row + 5] = v2 - v5;
554     p[row + 3] = v3 + v4;
555     p[row + 4] = v3 - v4;
556   }
557 
558   // inverse DCT on columns
559   for (let col = 0; col < 8; ++col) {
560     p0 = p[col];
561     p1 = p[col + 8];
562     p2 = p[col + 16];
563     p3 = p[col + 24];
564     p4 = p[col + 32];
565     p5 = p[col + 40];
566     p6 = p[col + 48];
567     p7 = p[col + 56];
568 
569     // check for all-zero AC coefficients
570     if ((p1 | p2 | p3 | p4 | p5 | p6 | p7) === 0) {
571       t = (dctSqrt2 * p0 + 8192) >> 14;
572       // Convert to 8-bit.
573       if (t < -2040) {
574         t = 0;
575       } else if (t >= 2024) {
576         t = 255;
577       } else {
578         t = (t + 2056) >> 4;
579       }
580       blockData[blockBufferOffset + col] = t;
581       blockData[blockBufferOffset + col + 8] = t;
582       blockData[blockBufferOffset + col + 16] = t;
583       blockData[blockBufferOffset + col + 24] = t;
584       blockData[blockBufferOffset + col + 32] = t;
585       blockData[blockBufferOffset + col + 40] = t;
586       blockData[blockBufferOffset + col + 48] = t;
587       blockData[blockBufferOffset + col + 56] = t;
588       continue;
589     }
590 
591     // stage 4
592     v0 = (dctSqrt2 * p0 + 2048) >> 12;
593     v1 = (dctSqrt2 * p4 + 2048) >> 12;
594     v2 = p2;
595     v3 = p6;
596     v4 = (dctSqrt1d2 * (p1 - p7) + 2048) >> 12;
597     v7 = (dctSqrt1d2 * (p1 + p7) + 2048) >> 12;
598     v5 = p3;
599     v6 = p5;
600 
601     // stage 3
602     // Shift v0 by 128.5 << 5 here, so we don't need to shift p0...p7 when
603     // converting to UInt8 range later.
604     v0 = ((v0 + v1 + 1) >> 1) + 4112;
605     v1 = v0 - v1;
606     t = (v2 * dctSin6 + v3 * dctCos6 + 2048) >> 12;
607     v2 = (v2 * dctCos6 - v3 * dctSin6 + 2048) >> 12;
608     v3 = t;
609     v4 = (v4 + v6 + 1) >> 1;
610     v6 = v4 - v6;
611     v7 = (v7 + v5 + 1) >> 1;
612     v5 = v7 - v5;
613 
614     // stage 2
615     v0 = (v0 + v3 + 1) >> 1;
616     v3 = v0 - v3;
617     v1 = (v1 + v2 + 1) >> 1;
618     v2 = v1 - v2;
619     t = (v4 * dctSin3 + v7 * dctCos3 + 2048) >> 12;
620     v4 = (v4 * dctCos3 - v7 * dctSin3 + 2048) >> 12;
621     v7 = t;
622     t = (v5 * dctSin1 + v6 * dctCos1 + 2048) >> 12;
623     v5 = (v5 * dctCos1 - v6 * dctSin1 + 2048) >> 12;
624     v6 = t;
625 
626     // stage 1
627     p0 = v0 + v7;
628     p7 = v0 - v7;
629     p1 = v1 + v6;
630     p6 = v1 - v6;
631     p2 = v2 + v5;
632     p5 = v2 - v5;
633     p3 = v3 + v4;
634     p4 = v3 - v4;
635 
636     // Convert to 8-bit integers.
637     if (p0 < 16) {
638       p0 = 0;
639     } else if (p0 >= 4080) {
640       p0 = 255;
641     } else {
642       p0 >>= 4;
643     }
644     if (p1 < 16) {
645       p1 = 0;
646     } else if (p1 >= 4080) {
647       p1 = 255;
648     } else {
649       p1 >>= 4;
650     }
651     if (p2 < 16) {
652       p2 = 0;
653     } else if (p2 >= 4080) {
654       p2 = 255;
655     } else {
656       p2 >>= 4;
657     }
658     if (p3 < 16) {
659       p3 = 0;
660     } else if (p3 >= 4080) {
661       p3 = 255;
662     } else {
663       p3 >>= 4;
664     }
665     if (p4 < 16) {
666       p4 = 0;
667     } else if (p4 >= 4080) {
668       p4 = 255;
669     } else {
670       p4 >>= 4;
671     }
672     if (p5 < 16) {
673       p5 = 0;
674     } else if (p5 >= 4080) {
675       p5 = 255;
676     } else {
677       p5 >>= 4;
678     }
679     if (p6 < 16) {
680       p6 = 0;
681     } else if (p6 >= 4080) {
682       p6 = 255;
683     } else {
684       p6 >>= 4;
685     }
686     if (p7 < 16) {
687       p7 = 0;
688     } else if (p7 >= 4080) {
689       p7 = 255;
690     } else {
691       p7 >>= 4;
692     }
693 
694     // store block data
695     blockData[blockBufferOffset + col] = p0;
696     blockData[blockBufferOffset + col + 8] = p1;
697     blockData[blockBufferOffset + col + 16] = p2;
698     blockData[blockBufferOffset + col + 24] = p3;
699     blockData[blockBufferOffset + col + 32] = p4;
700     blockData[blockBufferOffset + col + 40] = p5;
701     blockData[blockBufferOffset + col + 48] = p6;
702     blockData[blockBufferOffset + col + 56] = p7;
703   }
704 }
705 
706 function buildComponentData(frame, component) {
707   const blocksPerLine = component.blocksPerLine;
708   const blocksPerColumn = component.blocksPerColumn;
709   const computationBuffer = new Int16Array(64);
710 
711   for (let blockRow = 0; blockRow < blocksPerColumn; blockRow++) {
712     for (let blockCol = 0; blockCol < blocksPerLine; blockCol++) {
713       const offset = getBlockBufferOffset(component, blockRow, blockCol);
714       quantizeAndInverse(component, offset, computationBuffer);
715     }
716   }
717   return component.blockData;
718 }
719 
720 function findNextFileMarker(data, currentPos, startPos = currentPos) {
721   const maxPos = data.length - 1;
722   let newPos = startPos < currentPos ? startPos : currentPos;
723 
724   if (currentPos >= maxPos) {
725     return null; // Don't attempt to read non-existent data and just return.
726   }
727   const currentMarker = readUint16(data, currentPos);
728   if (currentMarker >= 0xffc0 && currentMarker <= 0xfffe) {
729     return {
730       invalid: null,
731       marker: currentMarker,
732       offset: currentPos,
733     };
734   }
735   let newMarker = readUint16(data, newPos);
736   while (!(newMarker >= 0xffc0 && newMarker <= 0xfffe)) {
737     if (++newPos >= maxPos) {
738       return null; // Don't attempt to read non-existent data and just return.
739     }
740     newMarker = readUint16(data, newPos);
741   }
742   return {
743     invalid: currentMarker.toString(16),
744     marker: newMarker,
745     offset: newPos,
746   };
747 }
748 
749 function prepareComponents(frame) {
750   const mcusPerLine = Math.ceil(frame.samplesPerLine / 8 / frame.maxH);
751   const mcusPerColumn = Math.ceil(frame.scanLines / 8 / frame.maxV);
752   for (const component of frame.components) {
753     const blocksPerLine = Math.ceil(
754       (Math.ceil(frame.samplesPerLine / 8) * component.h) / frame.maxH
755     );
756     const blocksPerColumn = Math.ceil(
757       (Math.ceil(frame.scanLines / 8) * component.v) / frame.maxV
758     );
759     const blocksPerLineForMcu = mcusPerLine * component.h;
760     const blocksPerColumnForMcu = mcusPerColumn * component.v;
761 
762     const blocksBufferSize =
763       64 * blocksPerColumnForMcu * (blocksPerLineForMcu + 1);
764     component.blockData = new Int16Array(blocksBufferSize);
765     component.blocksPerLine = blocksPerLine;
766     component.blocksPerColumn = blocksPerColumn;
767   }
768   frame.mcusPerLine = mcusPerLine;
769   frame.mcusPerColumn = mcusPerColumn;
770 }
771 
772 function readDataBlock(data, offset) {
773   const length = readUint16(data, offset);
774   offset += 2;
775   let endOffset = offset + length - 2;
776 
777   const fileMarker = findNextFileMarker(data, endOffset, offset);
778   if (fileMarker?.invalid) {
779     warn(
780       "readDataBlock - incorrect length, current marker is: " +
781         fileMarker.invalid
782     );
783     endOffset = fileMarker.offset;
784   }
785 
786   const array = data.subarray(offset, endOffset);
787   return {
788     appData: array,
789     oldOffset: offset,
790     newOffset: offset + array.length,
791   };
792 }
793 
794 function skipData(data, offset) {
795   const length = readUint16(data, offset);
796   offset += 2;
797   const endOffset = offset + length - 2;
798 
799   const fileMarker = findNextFileMarker(data, endOffset, offset);
800   if (fileMarker?.invalid) {
801     return fileMarker.offset;
802   }
803   return endOffset;
804 }
805 
806 class JpegImage {
807   constructor({ decodeTransform = null, colorTransform = -1 } = {}) {
808     this._decodeTransform = decodeTransform;
809     this._colorTransform = colorTransform;
810   }
811 
812   static canUseImageDecoder(data, colorTransform = -1) {
813     let exifOffsets = null;
814     let offset = 0;
815     let numComponents = null;
816     let fileMarker = readUint16(data, offset);
817     offset += 2;
818     if (fileMarker !== /* SOI (Start of Image) = */ 0xffd8) {
819       throw new JpegError("SOI not found");
820     }
821     fileMarker = readUint16(data, offset);
822     offset += 2;
823 
824     markerLoop: while (fileMarker !== /* EOI (End of Image) = */ 0xffd9) {
825       switch (fileMarker) {
826         case 0xffe1: // APP1 - Exif
827           // TODO: Remove this once https://github.com/w3c/webcodecs/issues/870
828           //       is fixed.
829           const { appData, oldOffset, newOffset } = readDataBlock(data, offset);
830           offset = newOffset;
831 
832           // 'Exif\x00\x00'
833           if (
834             appData[0] === 0x45 &&
835             appData[1] === 0x78 &&
836             appData[2] === 0x69 &&
837             appData[3] === 0x66 &&
838             appData[4] === 0 &&
839             appData[5] === 0
840           ) {
841             if (exifOffsets) {
842               throw new JpegError("Duplicate EXIF-blocks found.");
843             }
844             // Don't do the EXIF-block replacement here, see `JpegStream`,
845             // since that can modify the original PDF document.
846             exifOffsets = { exifStart: oldOffset + 6, exifEnd: newOffset };
847           }
848           fileMarker = readUint16(data, offset);
849           offset += 2;
850           continue;
851         case 0xffc0: // SOF0 (Start of Frame, Baseline DCT)
852         case 0xffc1: // SOF1 (Start of Frame, Extended DCT)
853         case 0xffc2: // SOF2 (Start of Frame, Progressive DCT)
854           // Skip marker length.
855           // Skip precision.
856           // Skip scanLines.
857           // Skip samplesPerLine.
858           numComponents = data[offset + (2 + 1 + 2 + 2)];
859           break markerLoop;
860         case 0xffff: // Fill bytes
861           if (data[offset] !== 0xff) {
862             // Avoid skipping a valid marker.
863             offset--;
864           }
865           break;
866       }
867       offset = skipData(data, offset);
868       fileMarker = readUint16(data, offset);
869       offset += 2;
870     }
871     if (numComponents === 4) {
872       return null;
873     }
874     if (numComponents === 3 && colorTransform === 0) {
875       return null;
876     }
877     return exifOffsets || {};
878   }
879 
880   parse(data, { dnlScanLines = null } = {}) {
881     let offset = 0;
882     let jfif = null;
883     let adobe = null;
884     let frame, resetInterval;
885     let numSOSMarkers = 0;
886     const quantizationTables = [];
887     const huffmanTablesAC = [],
888       huffmanTablesDC = [];
889 
890     let fileMarker = readUint16(data, offset);
891     offset += 2;
892     if (fileMarker !== /* SOI (Start of Image) = */ 0xffd8) {
893       throw new JpegError("SOI not found");
894     }
895     fileMarker = readUint16(data, offset);
896     offset += 2;
897 
898     markerLoop: while (fileMarker !== /* EOI (End of Image) = */ 0xffd9) {
899       let i, j, l;
900       switch (fileMarker) {
901         case 0xffe0: // APP0 (Application Specific)
902         case 0xffe1: // APP1
903         case 0xffe2: // APP2
904         case 0xffe3: // APP3
905         case 0xffe4: // APP4
906         case 0xffe5: // APP5
907         case 0xffe6: // APP6
908         case 0xffe7: // APP7
909         case 0xffe8: // APP8
910         case 0xffe9: // APP9
911         case 0xffea: // APP10
912         case 0xffeb: // APP11
913         case 0xffec: // APP12
914         case 0xffed: // APP13
915         case 0xffee: // APP14
916         case 0xffef: // APP15
917         case 0xfffe: // COM (Comment)
918           const { appData, newOffset } = readDataBlock(data, offset);
919           offset = newOffset;
920 
921           if (fileMarker === 0xffe0) {
922             // 'JFIF\x00'
923             if (
924               appData[0] === 0x4a &&
925               appData[1] === 0x46 &&
926               appData[2] === 0x49 &&
927               appData[3] === 0x46 &&
928               appData[4] === 0
929             ) {
930               jfif = {
931                 version: { major: appData[5], minor: appData[6] },
932                 densityUnits: appData[7],
933                 xDensity: (appData[8] << 8) | appData[9],
934                 yDensity: (appData[10] << 8) | appData[11],
935                 thumbWidth: appData[12],
936                 thumbHeight: appData[13],
937                 thumbData: appData.subarray(
938                   14,
939                   14 + 3 * appData[12] * appData[13]
940                 ),
941               };
942             }
943           }
944           // TODO APP1 - Exif
945           if (fileMarker === 0xffee) {
946             // 'Adobe'
947             if (
948               appData[0] === 0x41 &&
949               appData[1] === 0x64 &&
950               appData[2] === 0x6f &&
951               appData[3] === 0x62 &&
952               appData[4] === 0x65
953             ) {
954               adobe = {
955                 version: (appData[5] << 8) | appData[6],
956                 flags0: (appData[7] << 8) | appData[8],
957                 flags1: (appData[9] << 8) | appData[10],
958                 transformCode: appData[11],
959               };
960             }
961           }
962           break;
963 
964         case 0xffdb: // DQT (Define Quantization Tables)
965           const quantizationTablesLength = readUint16(data, offset);
966           offset += 2;
967           const quantizationTablesEnd = quantizationTablesLength + offset - 2;
968           let z;
969           while (offset < quantizationTablesEnd) {
970             const quantizationTableSpec = data[offset++];
971             const tableData = new Uint16Array(64);
972             if (quantizationTableSpec >> 4 === 0) {
973               // 8 bit values
974               for (j = 0; j < 64; j++) {
975                 z = dctZigZag[j];
976                 tableData[z] = data[offset++];
977               }
978             } else if (quantizationTableSpec >> 4 === 1) {
979               // 16 bit values
980               for (j = 0; j < 64; j++) {
981                 z = dctZigZag[j];
982                 tableData[z] = readUint16(data, offset);
983                 offset += 2;
984               }
985             } else {
986               throw new JpegError("DQT - invalid table spec");
987             }
988             quantizationTables[quantizationTableSpec & 15] = tableData;
989           }
990           break;
991 
992         case 0xffc0: // SOF0 (Start of Frame, Baseline DCT)
993         case 0xffc1: // SOF1 (Start of Frame, Extended DCT)
994         case 0xffc2: // SOF2 (Start of Frame, Progressive DCT)
995           if (frame) {
996             throw new JpegError("Only single frame JPEGs supported");
997           }
998           offset += 2; // Skip marker length.
999 
1000           frame = {};
1001           frame.extended = fileMarker === 0xffc1;
1002           frame.progressive = fileMarker === 0xffc2;
1003           frame.precision = data[offset++];
1004           const sofScanLines = readUint16(data, offset);
1005           offset += 2;
1006           frame.scanLines = dnlScanLines || sofScanLines;
1007           frame.samplesPerLine = readUint16(data, offset);
1008           offset += 2;
1009           frame.components = [];
1010           frame.componentIds = {};
1011           const componentsCount = data[offset++];
1012           let maxH = 0,
1013             maxV = 0;
1014           for (i = 0; i < componentsCount; i++) {
1015             const componentId = data[offset];
1016             const h = data[offset + 1] >> 4;
1017             const v = data[offset + 1] & 15;
1018             if (maxH < h) {
1019               maxH = h;
1020             }
1021             if (maxV < v) {
1022               maxV = v;
1023             }
1024             const qId = data[offset + 2];
1025             l = frame.components.push({
1026               h,
1027               v,
1028               quantizationId: qId,
1029               quantizationTable: null, // See comment below.
1030             });
1031             frame.componentIds[componentId] = l - 1;
1032             offset += 3;
1033           }
1034           frame.maxH = maxH;
1035           frame.maxV = maxV;
1036           prepareComponents(frame);
1037           break;
1038 
1039         case 0xffc4: // DHT (Define Huffman Tables)
1040           const huffmanLength = readUint16(data, offset);
1041           offset += 2;
1042           for (i = 2; i < huffmanLength; ) {
1043             const huffmanTableSpec = data[offset++];
1044             const codeLengths = new Uint8Array(16);
1045             let codeLengthSum = 0;
1046             for (j = 0; j < 16; j++, offset++) {
1047               codeLengthSum += codeLengths[j] = data[offset];
1048             }
1049             const huffmanValues = new Uint8Array(codeLengthSum);
1050             for (j = 0; j < codeLengthSum; j++, offset++) {
1051               huffmanValues[j] = data[offset];
1052             }
1053             i += 17 + codeLengthSum;
1054 
1055             (huffmanTableSpec >> 4 === 0 ? huffmanTablesDC : huffmanTablesAC)[
1056               huffmanTableSpec & 15
1057             ] = buildHuffmanTable(codeLengths, huffmanValues);
1058           }
1059           break;
1060 
1061         case 0xffdd: // DRI (Define Restart Interval)
1062           offset += 2; // Skip marker length.
1063 
1064           resetInterval = readUint16(data, offset);
1065           offset += 2;
1066           break;
1067 
1068         case 0xffda: // SOS (Start of Scan)
1069           // A DNL marker (0xFFDC), if it exists, is only allowed at the end
1070           // of the first scan segment and may only occur once in an image.
1071           // Furthermore, to prevent an infinite loop, do *not* attempt to
1072           // parse DNL markers during re-parsing of the JPEG scan data.
1073           const parseDNLMarker = ++numSOSMarkers === 1 && !dnlScanLines;
1074 
1075           offset += 2; // Skip marker length.
1076 
1077           const selectorsCount = data[offset++],
1078             components = [];
1079           for (i = 0; i < selectorsCount; i++) {
1080             const index = data[offset++];
1081             const componentIndex = frame.componentIds[index];
1082             const component = frame.components[componentIndex];
1083             component.index = index;
1084             const tableSpec = data[offset++];
1085             component.huffmanTableDC = huffmanTablesDC[tableSpec >> 4];
1086             component.huffmanTableAC = huffmanTablesAC[tableSpec & 15];
1087             components.push(component);
1088           }
1089           const spectralStart = data[offset++],
1090             spectralEnd = data[offset++],
1091             successiveApproximation = data[offset++];
1092           try {
1093             const processed = decodeScan(
1094               data,
1095               offset,
1096               frame,
1097               components,
1098               resetInterval,
1099               spectralStart,
1100               spectralEnd,
1101               successiveApproximation >> 4,
1102               successiveApproximation & 15,
1103               parseDNLMarker
1104             );
1105             offset += processed;
1106           } catch (ex) {
1107             if (ex instanceof DNLMarkerError) {
1108               warn(`${ex.message} -- attempting to re-parse the JPEG image.`);
1109               return this.parse(data, { dnlScanLines: ex.scanLines });
1110             } else if (ex instanceof EOIMarkerError) {
1111               warn(`${ex.message} -- ignoring the rest of the image data.`);
1112               break markerLoop;
1113             }
1114             throw ex;
1115           }
1116           break;
1117 
1118         case 0xffdc: // DNL (Define Number of Lines)
1119           // Ignore the marker, since it's being handled in `decodeScan`.
1120           offset += 4;
1121           break;
1122 
1123         case 0xffff: // Fill bytes
1124           if (data[offset] !== 0xff) {
1125             // Avoid skipping a valid marker.
1126             offset--;
1127           }
1128           break;
1129 
1130         default:
1131           // Could be incorrect encoding -- the last 0xFF byte of the previous
1132           // block could have been eaten by the encoder, hence we fallback to
1133           // `startPos = offset - 3` when looking for the next valid marker.
1134           const nextFileMarker = findNextFileMarker(
1135             data,
1136             /* currentPos = */ offset - 2,
1137             /* startPos = */ offset - 3
1138           );
1139           if (nextFileMarker?.invalid) {
1140             warn(
1141               "JpegImage.parse - unexpected data, current marker is: " +
1142                 nextFileMarker.invalid
1143             );
1144             offset = nextFileMarker.offset;
1145             break;
1146           }
1147           if (!nextFileMarker || offset >= data.length - 1) {
1148             warn(
1149               "JpegImage.parse - reached the end of the image data " +
1150                 "without finding an EOI marker (0xFFD9)."
1151             );
1152             break markerLoop;
1153           }
1154           throw new JpegError(
1155             "JpegImage.parse - unknown marker: " + fileMarker.toString(16)
1156           );
1157       }
1158       fileMarker = readUint16(data, offset);
1159       offset += 2;
1160     }
1161 
1162     if (!frame) {
1163       throw new JpegError("JpegImage.parse - no frame data found.");
1164     }
1165     this.width = frame.samplesPerLine;
1166     this.height = frame.scanLines;
1167     this.jfif = jfif;
1168     this.adobe = adobe;
1169     this.components = [];
1170     for (const component of frame.components) {
1171       // Prevent errors when DQT markers are placed after SOF{n} markers,
1172       // by assigning the `quantizationTable` entry after the entire image
1173       // has been parsed (fixes issue7406.pdf).
1174       const quantizationTable = quantizationTables[component.quantizationId];
1175       if (quantizationTable) {
1176         component.quantizationTable = quantizationTable;
1177       }
1178 
1179       this.components.push({
1180         index: component.index,
1181         output: buildComponentData(frame, component),
1182         scaleX: component.h / frame.maxH,
1183         scaleY: component.v / frame.maxV,
1184         blocksPerLine: component.blocksPerLine,
1185         blocksPerColumn: component.blocksPerColumn,
1186       });
1187     }
1188     this.numComponents = this.components.length;
1189     return undefined;
1190   }
1191 
1192   _getLinearizedBlockData(width, height, isSourcePDF = false) {
1193     const scaleX = this.width / width,
1194       scaleY = this.height / height;
1195 
1196     let component, componentScaleX, componentScaleY, blocksPerScanline;
1197     let x, y, i, j, k;
1198     let index;
1199     let offset = 0;
1200     let output;
1201     const numComponents = this.components.length;
1202     const dataLength = width * height * numComponents;
1203     const data = new Uint8ClampedArray(dataLength);
1204     const xScaleBlockOffset = new Uint32Array(width);
1205     const mask3LSB = 0xfffffff8; // used to clear the 3 LSBs
1206     let lastComponentScaleX;
1207 
1208     for (i = 0; i < numComponents; i++) {
1209       component = this.components[i];
1210       componentScaleX = component.scaleX * scaleX;
1211       componentScaleY = component.scaleY * scaleY;
1212       offset = i;
1213       output = component.output;
1214       blocksPerScanline = (component.blocksPerLine + 1) << 3;
1215       // Precalculate the `xScaleBlockOffset`. Since it doesn't depend on the
1216       // component data, that's only necessary when `componentScaleX` changes.
1217       if (componentScaleX !== lastComponentScaleX) {
1218         for (x = 0; x < width; x++) {
1219           j = 0 | (x * componentScaleX);
1220           xScaleBlockOffset[x] = ((j & mask3LSB) << 3) | (j & 7);
1221         }
1222         lastComponentScaleX = componentScaleX;
1223       }
1224       // linearize the blocks of the component
1225       for (y = 0; y < height; y++) {
1226         j = 0 | (y * componentScaleY);
1227         index = (blocksPerScanline * (j & mask3LSB)) | ((j & 7) << 3);
1228         for (x = 0; x < width; x++) {
1229           data[offset] = output[index + xScaleBlockOffset[x]];
1230           offset += numComponents;
1231         }
1232       }
1233     }
1234 
1235     // decodeTransform contains pairs of multiplier (-256..256) and additive
1236     let transform = this._decodeTransform;
1237 
1238     // In PDF files, JPEG images with CMYK colour spaces are usually inverted
1239     // (this can be observed by extracting the raw image data).
1240     // Since the conversion algorithms (see below) were written primarily for
1241     // the PDF use-cases, attempting to use `JpegImage` to parse standalone
1242     // JPEG (CMYK) images may thus result in inverted images (see issue 9513).
1243     //
1244     // Unfortunately it's not (always) possible to tell, from the image data
1245     // alone, if it needs to be inverted. Thus in an attempt to provide better
1246     // out-of-box behaviour when `JpegImage` is used standalone, default to
1247     // inverting JPEG (CMYK) images if and only if the image data does *not*
1248     // come from a PDF file and no `decodeTransform` was passed by the user.
1249     if (!isSourcePDF && numComponents === 4 && !transform) {
1250       transform = new Int32Array([-256, 255, -256, 255, -256, 255, -256, 255]);
1251     }
1252 
1253     if (transform) {
1254       for (i = 0; i < dataLength; ) {
1255         for (j = 0, k = 0; j < numComponents; j++, i++, k += 2) {
1256           data[i] = ((data[i] * transform[k]) >> 8) + transform[k + 1];
1257         }
1258       }
1259     }
1260     return data;
1261   }
1262 
1263   get _isColorConversionNeeded() {
1264     if (this.adobe) {
1265       // The adobe transform marker overrides any previous setting.
1266       return !!this.adobe.transformCode;
1267     }
1268     if (this.numComponents === 3) {
1269       if (this._colorTransform === 0) {
1270         // If the Adobe transform marker is not present and the image
1271         // dictionary has a 'ColorTransform' entry, explicitly set to `0`,
1272         // then the colours should *not* be transformed.
1273         return false;
1274       } else if (
1275         this.components[0].index === /* "R" = */ 0x52 &&
1276         this.components[1].index === /* "G" = */ 0x47 &&
1277         this.components[2].index === /* "B" = */ 0x42
1278       ) {
1279         // If the three components are indexed as RGB in ASCII
1280         // then the colours should *not* be transformed.
1281         return false;
1282       }
1283       return true;
1284     }
1285     // `this.numComponents !== 3`
1286     if (this._colorTransform === 1) {
1287       // If the Adobe transform marker is not present and the image
1288       // dictionary has a 'ColorTransform' entry, explicitly set to `1`,
1289       // then the colours should be transformed.
1290       return true;
1291     }
1292     return false;
1293   }
1294 
1295   _convertYccToRgb(data) {
1296     let Y, Cb, Cr;
1297     for (let i = 0, length = data.length; i < length; i += 3) {
1298       Y = data[i];
1299       Cb = data[i + 1];
1300       Cr = data[i + 2];
1301       data[i] = Y - 179.456 + 1.402 * Cr;
1302       data[i + 1] = Y + 135.459 - 0.344 * Cb - 0.714 * Cr;
1303       data[i + 2] = Y - 226.816 + 1.772 * Cb;
1304     }
1305     return data;
1306   }
1307 
1308   _convertYccToRgba(data, out) {
1309     for (let i = 0, j = 0, length = data.length; i < length; i += 3, j += 4) {
1310       const Y = data[i];
1311       const Cb = data[i + 1];
1312       const Cr = data[i + 2];
1313       out[j] = Y - 179.456 + 1.402 * Cr;
1314       out[j + 1] = Y + 135.459 - 0.344 * Cb - 0.714 * Cr;
1315       out[j + 2] = Y - 226.816 + 1.772 * Cb;
1316       out[j + 3] = 255;
1317     }
1318     return out;
1319   }
1320 
1321   _convertYcckToRgb(data) {
1322     this._convertYcckToCmyk(data);
1323     return this._convertCmykToRgb(data);
1324   }
1325 
1326   _convertYcckToRgba(data) {
1327     this._convertYcckToCmyk(data);
1328     return this._convertCmykToRgba(data);
1329   }
1330 
1331   _convertYcckToCmyk(data) {
1332     let Y, Cb, Cr;
1333     for (let i = 0, length = data.length; i < length; i += 4) {
1334       Y = data[i];
1335       Cb = data[i + 1];
1336       Cr = data[i + 2];
1337       data[i] = 434.456 - Y - 1.402 * Cr;
1338       data[i + 1] = 119.541 - Y + 0.344 * Cb + 0.714 * Cr;
1339       data[i + 2] = 481.816 - Y - 1.772 * Cb;
1340       // K in data[i + 3] is unchanged
1341     }
1342     return data;
1343   }
1344 
1345   _convertCmykToRgb(data) {
1346     const count = data.length / 4;
1347     ColorSpaceUtils.cmyk.getRgbBuffer(data, 0, count, data, 0, 8, 0);
1348     return data.subarray(0, count * 3);
1349   }
1350 
1351   _convertCmykToRgba(data) {
1352     ColorSpaceUtils.cmyk.getRgbBuffer(data, 0, data.length / 4, data, 0, 8, 1);
1353 
1354     if (ColorSpaceUtils.cmyk instanceof DeviceCmykCS) {
1355       // The alpha-component isn't updated by `DeviceCmykCS`, doing it manually.
1356       for (let i = 3, ii = data.length; i < ii; i += 4) {
1357         data[i] = 255;
1358       }
1359     }
1360     return data;
1361   }
1362 
1363   getData({
1364     width,
1365     height,
1366     forceRGBA = false,
1367     forceRGB = false,
1368     isSourcePDF = false,
1369   }) {
1370     if (typeof PDFJSDev === "undefined" || PDFJSDev.test("TESTING")) {
1371       assert(
1372         isSourcePDF === true,
1373         'JpegImage.getData: Unexpected "isSourcePDF" value for PDF files.'
1374       );
1375     }
1376     if (this.numComponents > 4) {
1377       throw new JpegError("Unsupported color mode");
1378     }
1379     // Type of data: Uint8ClampedArray(width * height * numComponents)
1380     const data = this._getLinearizedBlockData(width, height, isSourcePDF);
1381 
1382     if (this.numComponents === 1 && (forceRGBA || forceRGB)) {
1383       const len = data.length * (forceRGBA ? 4 : 3);
1384       const rgbaData = new Uint8ClampedArray(len);
1385       let offset = 0;
1386       if (forceRGBA) {
1387         grayToRGBA(data, new Uint32Array(rgbaData.buffer));
1388       } else {
1389         for (const grayColor of data) {
1390           rgbaData[offset++] = grayColor;
1391           rgbaData[offset++] = grayColor;
1392           rgbaData[offset++] = grayColor;
1393         }
1394       }
1395       return rgbaData;
1396     } else if (this.numComponents === 3 && this._isColorConversionNeeded) {
1397       if (forceRGBA) {
1398         const rgbaData = new Uint8ClampedArray((data.length / 3) * 4);
1399         return this._convertYccToRgba(data, rgbaData);
1400       }
1401       return this._convertYccToRgb(data);
1402     } else if (this.numComponents === 4) {
1403       if (this._isColorConversionNeeded) {
1404         if (forceRGBA) {
1405           return this._convertYcckToRgba(data);
1406         }
1407         if (forceRGB) {
1408           return this._convertYcckToRgb(data);
1409         }
1410         return this._convertYcckToCmyk(data);
1411       } else if (forceRGBA) {
1412         return this._convertCmykToRgba(data);
1413       } else if (forceRGB) {
1414         return this._convertCmykToRgb(data);
1415       }
1416     }
1417     return data;
1418   }
1419 }
1420 
1421 export { JpegError, JpegImage };
</code>

Your task:
You are a software tester at pdf.js.
1. Write exactly one javascript test `it("...", async () => {...})` block.
2. Your test must fail on the code before the patch, and pass after, hence the test will verify that the patch resolves the issue.
3. The test must be self-contained and to-the-point.
4. Use only the provided imports (respect the paths exactly how they are given) by importing dynamically for compatibility with Node.js — no new dependencies. 
5. Return only the javascript code (no comments or explanations).

Example structure:
it("should <describe behavior>", async () => {
  const { example } = await import("../../src/core/example.js");
  <initialize required variables>;
  <define expected variable>;
  <generate actual variables>;
  <compare expected with actual>;
});

