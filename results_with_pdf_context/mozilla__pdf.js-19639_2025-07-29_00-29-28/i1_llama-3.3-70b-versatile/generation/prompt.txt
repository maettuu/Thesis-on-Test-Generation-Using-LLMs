Before you begin:
- Keep going until the job is completely solved — don’t stop halfway.
- If you’re unsure about the behavior, reread the provided patch carefully; do not hallucinate.
- Plan your approach before writing code by reflecting on whether the test truly fails before and passes after.

Issue:
<issue>
[Bug]: Issue with line thickness
### Attach (recommended) or Link to PDF file

[Pagine estratte senza titolo.pdf](https://github.com/user-attachments/files/19159893/Pagine.estratte.senza.titolo.pdf)

### Web browser and its version

Chrome 134.0.6998.35

### Operating system and its version

Windows 10 Pro 22H2

### PDF.js version

4.10.38

### Is the bug present in the latest PDF.js version?

Yes

### Is a browser extension

No

### Steps to reproduce the problem

In the online demo page load this PDF and you can see the problem.

### What is the expected behavior?

The line thickness should be as on the original pdf

### What went wrong?

The thickness line is wrong.

![Image](https://github.com/user-attachments/assets/16d84297-bfe0-41e8-a75e-36c84c93f3a5)

### Link to a viewer

_No response_

### Additional context

_No response_
</issue>

PDF File:
<pdf>
issue19633.pdf
</pdf>

Patch:
<patch>
diff --git a/src/core/evaluator.js b/src/core/evaluator.js
--- a/src/core/evaluator.js
+++ b/src/core/evaluator.js
@@ -1122,6 +1122,12 @@ class PartialEvaluator {
         case "Type":
           break;
         case "LW":
+          if (typeof value !== "number") {
+            warn(`Invalid LW (line width): ${value}`);
+            break;
+          }
+          gStateObj.push([key, Math.abs(value)]);
+          break;
         case "LC":
         case "LJ":
         case "ML":
@@ -2212,6 +2218,18 @@ class PartialEvaluator {
               })
             );
             return;
+          case OPS.setLineWidth: {
+            // The thickness should be a non-negative number, as per spec.
+            // When the value is negative, Acrobat and Poppler take the absolute
+            // value while PDFium takes the max of 0 and the value.
+            const [thickness] = args;
+            if (typeof thickness !== "number") {
+              warn(`Invalid setLineWidth: ${thickness}`);
+              continue;
+            }
+            args[0] = Math.abs(thickness);
+            break;
+          }
           case OPS.moveTo:
           case OPS.lineTo:
           case OPS.curveTo:


</patch>

Imports:
<imports>
Available Packages
Dev Dependencies:
- @babel/core: ^7.26.9
- @babel/preset-env: ^7.26.9
- @babel/runtime: ^7.26.9
- @fluent/bundle: ^0.18.0
- @fluent/dom: ^0.10.0
- @metalsmith/layouts: ^2.7.0
- @metalsmith/markdown: ^1.10.0
- @napi-rs/canvas: ^0.1.67
- @types/node: ^22.13.5
- autoprefixer: ^10.4.20
- babel-loader: ^9.2.1
- caniuse-lite: ^1.0.30001700
- core-js: ^3.40.0
- eslint: ^9.21.0
- eslint-plugin-import: ^2.31.0
- eslint-plugin-jasmine: ^4.2.2
- eslint-plugin-json: ^4.0.1
- eslint-plugin-no-unsanitized: ^4.1.2
- eslint-plugin-perfectionist: ^4.9.0
- eslint-plugin-prettier: ^5.2.3
- eslint-plugin-unicorn: ^57.0.0
- globals: ^16.0.0
- gulp: ^5.0.0
- gulp-cli: ^3.0.0
- gulp-postcss: ^10.0.0
- gulp-rename: ^2.0.0
- gulp-replace: ^1.1.4
- gulp-zip: ^6.1.0
- highlight.js: ^11.11.1
- jasmine: ^5.6.0
- jsdoc: ^4.0.4
- jstransformer-nunjucks: ^1.2.0
- metalsmith: ^2.6.3
- metalsmith-html-relative: ^2.0.6
- ordered-read-streams: ^2.0.0
- pngjs: ^7.0.0
- postcss: ^8.5.3
- postcss-dark-theme-class: ^1.3.0
- postcss-dir-pseudo-class: ^9.0.1
- postcss-discard-comments: ^7.0.3
- postcss-nesting: ^13.0.1
- prettier: ^3.5.2
- puppeteer: ^24.2.1
- stylelint: ^16.14.1
- stylelint-prettier: ^5.0.3
- svglint: ^3.1.0
- terser-webpack-plugin: ^5.3.11
- tsc-alias: ^1.8.10
- ttest: ^4.0.0
- typescript: ^5.7.3
- vinyl: ^3.0.0
- webpack: ^5.98.0
- webpack-stream: ^7.0.0
- yargs: ^17.7.2

Engines:
- node: >=20

Available Relative Imports:
- `../../src/core/annotation.js`: Annotation, AnnotationBorderStyle, AnnotationFactory, MarkupAnnotation, getQuadPoints
- `../../src/core/bidi.js`: bidi
- `../../src/core/calculate_md5.js`: calculateMD5
- `../../src/core/calculate_sha256.js`: calculateSHA256
- `../../src/core/calculate_sha_other.js`: calculateSHA384, calculateSHA512
- `../../src/core/cff_parser.js`: CFFCharset, CFFCompiler, CFFFDSelect, CFFParser, CFFStrings
- `../../src/core/cmap.js`: CMap, CMapFactory, IdentityCMap
- `../../src/core/colorspace.js`: ColorSpace
- `../../src/core/colorspace_utils.js`: ColorSpaceUtils
- `../../src/core/core_utils.js`: arrayBuffersToBytes, encodeToXmlString, escapePDFName, escapeString, getInheritableProperty, getSizeInBytes, isAscii, isWhiteSpace, log2, numberToString, parseXFAPath, recoverJsURL, stringToUTF16HexString, stringToUTF16String, toRomanNumerals, validateCSSFont
- `../../src/core/crypto.js`: AES128Cipher, AES256Cipher, ARCFourCipher, CipherTransformFactory, PDF17, PDF20
- `../../src/core/default_appearance.js`: createDefaultAppearance, parseAppearanceStream, parseDefaultAppearance
- `../../src/core/document.js`: PDFDocument, Page
- `../../src/core/encodings.js`: getEncoding
- `../../src/core/evaluator.js`: PartialEvaluator
- `../../src/core/flate_stream.js`: FlateStream
- `../../src/core/font_substitutions.js`: getFontSubstitution
- `../../src/core/fonts_utils.js`: SEAC_ANALYSIS_ENABLED
- `../../src/core/function.js`: PDFFunctionFactory, PostScriptCompiler, PostScriptEvaluator
- `../../src/core/glyphlist.js`: getDingbatsGlyphsUnicode, getGlyphsUnicode
- `../../src/core/image_utils.js`: GlobalColorSpaceCache, GlobalImageCache, LocalColorSpaceCache
- `../../src/core/jbig2.js`: Jbig2Error, Jbig2Image
- `../../src/core/jpg.js`: JpegError, JpegImage
- `../../src/core/jpx.js`: JpxError, JpxImage
- `../../src/core/metadata_parser.js`: MetadataParser
- `../../src/core/operator_list.js`: OperatorList
- `../../src/core/parser.js`: Lexer, Linearization, Parser
- `../../src/core/predictor_stream.js`: PredictorStream
- `../../src/core/primitives.js`: Cmd, Dict, EOF, Name, Ref, RefSet, RefSetCache, isCmd, isDict, isName, isRefsEqual
- `../../src/core/ps_parser.js`: PostScriptLexer, PostScriptParser
- `../../src/core/stream.js`: NullStream, Stream, StringStream
- `../../src/core/type1_parser.js`: Type1Parser
- `../../src/core/unicode.js`: getCharUnicodeCategory, getUnicodeForGlyph, getUnicodeRangeFor, mapSpecialUnicodeValues
- `../../src/core/worker.js`: WorkerMessageHandler, WorkerTask
- `../../src/core/writer.js`: incrementalUpdate, writeChanges, writeDict
- `../../src/core/xfa/bind.js`: Binder
- `../../src/core/xfa/data.js`: DataHandler
- `../../src/core/xfa/factory.js`: XFAFactory
- `../../src/core/xfa/formcalc_lexer.js`: Lexer, TOKEN, Token
- `../../src/core/xfa/formcalc_parser.js`: Errors, Parser
- `../../src/core/xfa/parser.js`: XFAParser
- `../../src/core/xfa/som.js`: searchNode
- `../../src/core/xfa/symbol_utils.js`: $dump, $getChildren, $getChildrenByClass, $getChildrenByName, $text, $uid
- `../../src/core/xml_parser.js`: SimpleXMLParser, XMLParserBase
- `../../src/display/annotation_layer.js`: AnnotationLayer
- `../../src/display/annotation_storage.js`: AnnotationStorage
- `../../src/display/api.js`: LoopbackPort, PDFDataRangeTransport, PDFDocumentLoadingTask, PDFDocumentProxy, PDFPageProxy, PDFWorker, RenderTask, build, getDocument, isValidExplicitDest, version
- `../../src/display/canvas_factory.js`: DOMCanvasFactory
- `../../src/display/cmap_reader_factory.js`: DOMCMapReaderFactory
- `../../src/display/display_utils.js`: OutputScale, PDFDateString, PageViewport, PixelsPerInch, RenderingCancelledException, StatTimer, SupportedImageMimeTypes, fetchData, getFilenameFromUrl, getPdfFilenameFromUrl, getXfaPageViewport, isDataScheme, isPdfFile, isValidFetchUrl, noContextMenu, setLayerDimensions, stopEvent
- `../../src/display/draw_layer.js`: DrawLayer
- `../../src/display/editor/annotation_editor_layer.js`: AnnotationEditorLayer
- `../../src/display/editor/color_picker.js`: ColorPicker
- `../../src/display/editor/drawers/signaturedraw.js`: SignatureExtractor
- `../../src/display/editor/tools.js`: AnnotationEditorUIManager, CommandManager
- `../../src/display/fetch_stream.js`: PDFFetchStream
- `../../src/display/metadata.js`: Metadata
- `../../src/display/network.js`: PDFNetworkStream
- `../../src/display/network_utils.js`: createHeaders, createResponseError, extractFilenameFromHeader, validateRangeRequestCapabilities, validateResponseStatus
- `../../src/display/node_stream.js`: PDFNodeStream
- `../../src/display/node_utils.js`: NodeCMapReaderFactory, NodeStandardFontDataFactory, fetchData
- `../../src/display/standard_fontdata_factory.js`: DOMStandardFontDataFactory
- `../../src/display/svg_factory.js`: DOMSVGFactory
- `../../src/display/text_layer.js`: TextLayer
- `../../src/display/touch_manager.js`: TouchManager
- `../../src/display/worker_options.js`: GlobalWorkerOptions
- `../../src/display/xfa_layer.js`: XfaLayer
- `../../src/shared/message_handler.js`: MessageHandler
- `../../src/shared/murmurhash3.js`: MurmurHash3_64
- `../../src/shared/util.js`: AbortException, AnnotationBorderStyleType, AnnotationEditorParamsType, AnnotationEditorType, AnnotationFieldFlag, AnnotationFlag, AnnotationMode, AnnotationType, BaseException, FeatureTest, FormatError, ImageKind, InvalidPDFException, MathClamp, OPS, PasswordException, PasswordResponses, PermissionFlag, RenderingIntentFlag, ResponseException, UnknownErrorException, Util, VerbosityLevel, assert, bytesToString, createValidAbsoluteUrl, getModificationDate, getUuid, getVerbosityLevel, isNodeJS, normalizeUnicode, objectSize, setVerbosityLevel, shadow, string32, stringToBytes, stringToPDFString, stringToUTF8String, toBase64Util
- `../../web/annotation_layer_builder.js`: AnnotationLayerBuilder
- `../../web/app_options.js`: AppOptions, OptionKind
- `../../web/autolinker.js`: Autolinker
- `../../web/download_manager.js`: DownloadManager
- `../../web/event_utils.js`: EventBus, WaitOnType, waitOnEventOrTimeout
- `../../web/genericl10n.js`: GenericL10n
- `../../web/pdf_find_controller.js`: FindState, PDFFindController
- `../../web/pdf_find_utils.js`: CharacterType, getCharacterType
- `../../web/pdf_history.js`: PDFHistory, isDestArraysEqual, isDestHashesEqual
- `../../web/pdf_link_service.js`: LinkTarget, PDFLinkService, SimpleLinkService
- `../../web/pdf_page_view.js`: PDFPageView
- `../../web/pdf_scripting_manager.component.js`: PDFScriptingManager
- `../../web/pdf_single_page_viewer.js`: PDFSinglePageViewer
- `../../web/pdf_viewer.js`: PDFPageViewBuffer, PDFViewer
- `../../web/struct_tree_layer_builder.js`: StructTreeLayerBuilder
- `../../web/text_layer_builder.js`: TextLayerBuilder
- `../../web/ui_utils.js`: AutoPrintRegExp, ProgressBar, RenderingStates, ScrollMode, SpreadMode, backtrackBeforeAllVisibleElements, binarySearchFirstItem, calcRound, getPageSizeInches, getVisibleElements, isPortraitOrientation, isValidRotation, parseQueryString, removeNullCharacters
- `../../web/xfa_layer_builder.js`: XfaLayerBuilder
- `../reporter.js`: TestReporter
- `./common_pdfstream_tests.js`: testCrossOriginRedirects
- `./test_utils.js`: CMAP_URL, DefaultCMapReaderFactory, DefaultFileReaderFactory, DefaultStandardFontDataFactory, STANDARD_FONT_DATA_URL, TEST_PDFS_PATH, TestPdfsServer, XRefMock, buildGetDocumentParams, createIdFactory, getCrossOriginHostname
</imports>

Code:
<code>
File:
src/core/evaluator.js
1 /* Copyright 2012 Mozilla Foundation
2  *
3  * Licensed under the Apache License, Version 2.0 (the "License");
4  * you may not use this file except in compliance with the License.
5  * You may obtain a copy of the License at
6  *
7  *     http://www.apache.org/licenses/LICENSE-2.0
8  *
9  * Unless required by applicable law or agreed to in writing, software
10  * distributed under the License is distributed on an "AS IS" BASIS,
11  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
12  * See the License for the specific language governing permissions and
13  * limitations under the License.
14  */
15 
16 import {
17   AbortException,
18   assert,
19   FONT_IDENTITY_MATRIX,
20   FormatError,
21   IDENTITY_MATRIX,
22   info,
23   isArrayEqual,
24   normalizeUnicode,
25   OPS,
26   shadow,
27   stringToPDFString,
28   TextRenderingMode,
29   Util,
30   warn,
31 } from "../shared/util.js";
32 import { CMapFactory, IdentityCMap } from "./cmap.js";
33 import { Cmd, Dict, EOF, isName, Name, Ref, RefSet } from "./primitives.js";
34 import { ErrorFont, Font } from "./fonts.js";
35 import {
36   fetchBinaryData,
37   isNumberArray,
38   lookupMatrix,
39   lookupNormalRect,
40 } from "./core_utils.js";
41 import {
42   getEncoding,
43   MacRomanEncoding,
44   StandardEncoding,
45   SymbolSetEncoding,
46   WinAnsiEncoding,
47   ZapfDingbatsEncoding,
48 } from "./encodings.js";
49 import {
50   getFontNameToFileMap,
51   getSerifFonts,
52   getStandardFontName,
53   getStdFontMap,
54   getSymbolsFonts,
55   isKnownFontName,
56 } from "./standard_fonts.js";
57 import { getTilingPatternIR, Pattern } from "./pattern.js";
58 import { getXfaFontDict, getXfaFontName } from "./xfa_fonts.js";
59 import { IdentityToUnicodeMap, ToUnicodeMap } from "./to_unicode_map.js";
60 import { isPDFFunction, PDFFunctionFactory } from "./function.js";
61 import { Lexer, Parser } from "./parser.js";
62 import {
63   LocalColorSpaceCache,
64   LocalGStateCache,
65   LocalImageCache,
66   LocalTilingPatternCache,
67   RegionalImageCache,
68 } from "./image_utils.js";
69 import { BaseStream } from "./base_stream.js";
70 import { bidi } from "./bidi.js";
71 import { ColorSpace } from "./colorspace.js";
72 import { ColorSpaceUtils } from "./colorspace_utils.js";
73 import { DecodeStream } from "./decode_stream.js";
74 import { FontFlags } from "./fonts_utils.js";
75 import { getFontSubstitution } from "./font_substitutions.js";
76 import { getGlyphsUnicode } from "./glyphlist.js";
77 import { getMetrics } from "./metrics.js";
78 import { getUnicodeForGlyph } from "./unicode.js";
79 import { MurmurHash3_64 } from "../shared/murmurhash3.js";
80 import { OperatorList } from "./operator_list.js";
81 import { PDFImage } from "./image.js";
82 import { Stream } from "./stream.js";
83 
84 const DefaultPartialEvaluatorOptions = Object.freeze({
85   maxImageSize: -1,
86   disableFontFace: false,
87   ignoreErrors: false,
88   isEvalSupported: true,
89   isOffscreenCanvasSupported: false,
90   isImageDecoderSupported: false,
91   canvasMaxAreaInBytes: -1,
92   fontExtraProperties: false,
93   useSystemFonts: true,
94   useWasm: true,
95   useWorkerFetch: true,
96   cMapUrl: null,
97   iccUrl: null,
98   standardFontDataUrl: null,
99   wasmUrl: null,
100 });
101 
102 const PatternType = {
103   TILING: 1,
104   SHADING: 2,
105 };
106 
107 // Optionally avoid sending individual, or very few, text chunks to reduce
108 // `postMessage` overhead with ReadableStream (see issue 13962).
109 //
110 // PLEASE NOTE: This value should *not* be too large (it's used as a lower limit
111 // in `enqueueChunk`), since that would cause streaming of textContent to become
112 // essentially useless in practice by sending all (or most) chunks at once.
113 // Also, a too large value would (indirectly) affect the main-thread `textLayer`
114 // building negatively by forcing all textContent to be handled at once, which
115 // could easily end up hurting *overall* performance (e.g. rendering as well).
116 const TEXT_CHUNK_BATCH_SIZE = 10;
117 
118 const deferred = Promise.resolve();
119 
120 // Convert PDF blend mode names to HTML5 blend mode names.
181 
193 // Trying to minimize Date.now() usage and check every 100 time.
216 
217 class PartialEvaluator {
218   constructor({
219     xref,
220     handler,
221     pageIndex,
222     idFactory,
223     fontCache,
224     builtInCMapCache,
225     standardFontDataCache,
226     globalColorSpaceCache,
227     globalImageCache,
228     systemFontCache,
229     options = null,
230   }) {
231     this.xref = xref;
232     this.handler = handler;
233     this.pageIndex = pageIndex;
234     this.idFactory = idFactory;
235     this.fontCache = fontCache;
236     this.builtInCMapCache = builtInCMapCache;
237     this.standardFontDataCache = standardFontDataCache;
238     this.globalColorSpaceCache = globalColorSpaceCache;
239     this.globalImageCache = globalImageCache;
240     this.systemFontCache = systemFontCache;
241     this.options = options || DefaultPartialEvaluatorOptions;
242     this.type3FontRefs = null;
243 
244     this._regionalImageCache = new RegionalImageCache();
245     this._fetchBuiltInCMapBound = this.fetchBuiltInCMap.bind(this);
246   }
247 
1105   async setGState({
1106     resources,
1107     gState,
1108     operatorList,
1109     cacheKey,
1110     task,
1111     stateManager,
1112     localGStateCache,
1113     localColorSpaceCache,
1114   }) {
1115     const gStateRef = gState.objId;
1116     let isSimpleGState = true;
1117     // This array holds the converted/processed state data.
1118     const gStateObj = [];
1119     let promise = Promise.resolve();
1120     for (const [key, value] of gState) {
1121       switch (key) {
1122         case "Type":
1123           break;
1124         case "LW":
1125         case "LC":
1126         case "LJ":
1127         case "ML":
1128         case "D":
1129         case "RI":
1130         case "FL":
1131         case "CA":
1132         case "ca":
1133           gStateObj.push([key, value]);
1134           break;
1135         case "Font":
1136           isSimpleGState = false;
1137 
1138           promise = promise.then(() =>
1139             this.handleSetFont(
1140               resources,
1141               null,
1142               value[0],
1143               operatorList,
1144               task,
1145               stateManager.state
1146             ).then(function (loadedName) {
1147               operatorList.addDependency(loadedName);
1148               gStateObj.push([key, [loadedName, value[1]]]);
1149             })
1150           );
1151           break;
1152         case "BM":
1153           gStateObj.push([key, normalizeBlendMode(value)]);
1154           break;
1155         case "SMask":
1156           if (isName(value, "None")) {
1157             gStateObj.push([key, false]);
1158             break;
1159           }
1160           if (value instanceof Dict) {
1161             isSimpleGState = false;
1162 
1163             promise = promise.then(() =>
1164               this.handleSMask(
1165                 value,
1166                 resources,
1167                 operatorList,
1168                 task,
1169                 stateManager,
1170                 localColorSpaceCache
1171               )
1172             );
1173             gStateObj.push([key, true]);
1174           } else {
1175             warn("Unsupported SMask type");
1176           }
1177           break;
1178         case "TR":
1179           const transferMaps = this.handleTransferFunction(value);
1180           gStateObj.push([key, transferMaps]);
1181           break;
1182         // Only generate info log messages for the following since
1183         // they are unlikely to have a big impact on the rendering.
1184         case "OP":
1185         case "op":
1186         case "OPM":
1187         case "BG":
1188         case "BG2":
1189         case "UCR":
1190         case "UCR2":
1191         case "TR2":
1192         case "HT":
1193         case "SM":
1194         case "SA":
1195         case "AIS":
1196         case "TK":
1197           // TODO implement these operators.
1198           info("graphic state operator " + key);
1199           break;
1200         default:
1201           info("Unknown graphic state operator " + key);
1202           break;
1203       }
1204     }
1205     await promise;
1206 
1207     if (gStateObj.length > 0) {
1208       operatorList.addOp(OPS.setGState, [gStateObj]);
1209     }
1210 
1211     if (isSimpleGState) {
1212       localGStateCache.set(cacheKey, gStateRef, gStateObj);
1213     }
1214   }
1215 
1709   getOperatorList({
1710     stream,
1711     task,
1712     resources,
1713     operatorList,
1714     initialState = null,
1715     fallbackFontDict = null,
1716   }) {
1717     // Ensure that `resources`/`initialState` is correctly initialized,
1718     // even if the provided parameter is e.g. `null`.
1719     resources ||= Dict.empty;
1720     initialState ||= new EvalState();
1721 
1722     if (!operatorList) {
1723       throw new Error('getOperatorList: missing "operatorList" parameter');
1724     }
1725 
1726     const self = this;
1727     const xref = this.xref;
1728     let parsingText = false;
1729     const localImageCache = new LocalImageCache();
1730     const localColorSpaceCache = new LocalColorSpaceCache();
1731     const localGStateCache = new LocalGStateCache();
1732     const localTilingPatternCache = new LocalTilingPatternCache();
1733     const localShadingPatternCache = new Map();
1734 
1735     const xobjs = resources.get("XObject") || Dict.empty;
1736     const patterns = resources.get("Pattern") || Dict.empty;
1737     const stateManager = new StateManager(initialState);
1738     const preprocessor = new EvaluatorPreprocessor(stream, xref, stateManager);
1739     const timeSlotManager = new TimeSlotManager();
1740 
1741     function closePendingRestoreOPS(argument) {
1742       for (let i = 0, ii = preprocessor.savedStatesDepth; i < ii; i++) {
1743         operatorList.addOp(OPS.restore, []);
1744       }
1745     }
1746 
1747     return new Promise(function promiseBody(resolve, reject) {
1748       const next = function (promise) {
1749         Promise.all([promise, operatorList.ready]).then(function () {
1750           try {
1751             promiseBody(resolve, reject);
1752           } catch (ex) {
1753             reject(ex);
1754           }
1755         }, reject);
1756       };
1757       task.ensureNotTerminated();
1758       timeSlotManager.reset();
1759 
1760       const operation = {};
1761       let stop, i, ii, cs, name, isValidName;
1762       while (!(stop = timeSlotManager.check())) {
1763         // The arguments parsed by read() are used beyond this loop, so we
1764         // cannot reuse the same array on each iteration. Therefore we pass
1765         // in |null| as the initial value (see the comment on
1766         // EvaluatorPreprocessor_read() for why).
1767         operation.args = null;
1768         if (!preprocessor.read(operation)) {
1769           break;
1770         }
1771         let args = operation.args;
1772         let fn = operation.fn;
1773 
1774         switch (fn | 0) {
1775           case OPS.paintXObject:
1776             // eagerly compile XForm objects
1777             isValidName = args[0] instanceof Name;
1778             name = args[0].name;
1779 
1780             if (isValidName) {
1781               const localImage = localImageCache.getByName(name);
1782               if (localImage) {
1783                 addLocallyCachedImageOps(operatorList, localImage);
1784                 args = null;
1785                 continue;
1786               }
1787             }
1788 
1789             next(
1790               new Promise(function (resolveXObject, rejectXObject) {
1791                 if (!isValidName) {
1792                   throw new FormatError("XObject must be referred to by name.");
1793                 }
1794 
1795                 let xobj = xobjs.getRaw(name);
1796                 if (xobj instanceof Ref) {
1797                   const localImage =
1798                     localImageCache.getByRef(xobj) ||
1799                     self._regionalImageCache.getByRef(xobj);
1800                   if (localImage) {
1801                     addLocallyCachedImageOps(operatorList, localImage);
1802                     resolveXObject();
1803                     return;
1804                   }
1805 
1806                   const globalImage = self.globalImageCache.getData(
1807                     xobj,
1808                     self.pageIndex
1809                   );
1810                   if (globalImage) {
1811                     operatorList.addDependency(globalImage.objId);
1812                     operatorList.addImageOps(
1813                       globalImage.fn,
1814                       globalImage.args,
1815                       globalImage.optionalContent,
1816                       globalImage.hasMask
1817                     );
1818 
1819                     resolveXObject();
1820                     return;
1821                   }
1822 
1823                   xobj = xref.fetch(xobj);
1824                 }
1825 
1826                 if (!(xobj instanceof BaseStream)) {
1827                   throw new FormatError("XObject should be a stream");
1828                 }
1829 
1830                 const type = xobj.dict.get("Subtype");
1831                 if (!(type instanceof Name)) {
1832                   throw new FormatError("XObject should have a Name subtype");
1833                 }
1834 
1835                 if (type.name === "Form") {
1836                   stateManager.save();
1837                   self
1838                     .buildFormXObject(
1839                       resources,
1840                       xobj,
1841                       null,
1842                       operatorList,
1843                       task,
1844                       stateManager.state.clone(),
1845                       localColorSpaceCache
1846                     )
1847                     .then(function () {
1848                       stateManager.restore();
1849                       resolveXObject();
1850                     }, rejectXObject);
1851                   return;
1852                 } else if (type.name === "Image") {
1853                   self
1854                     .buildPaintImageXObject({
1855                       resources,
1856                       image: xobj,
1857                       operatorList,
1858                       cacheKey: name,
1859                       localImageCache,
1860                       localColorSpaceCache,
1861                     })
1862                     .then(resolveXObject, rejectXObject);
1863                   return;
1864                 } else if (type.name === "PS") {
1865                   // PostScript XObjects are unused when viewing documents.
1866                   // See section 4.7.1 of Adobe's PDF reference.
1867                   info("Ignored XObject subtype PS");
1868                 } else {
1869                   throw new FormatError(
1870                     `Unhandled XObject subtype ${type.name}`
1871                   );
1872                 }
1873                 resolveXObject();
1874               }).catch(function (reason) {
1875                 if (reason instanceof AbortException) {
1876                   return;
1877                 }
1878                 if (self.options.ignoreErrors) {
1879                   warn(`getOperatorList - ignoring XObject: "${reason}".`);
1880                   return;
1881                 }
1882                 throw reason;
1883               })
1884             );
1885             return;
1886           case OPS.setFont:
1887             const fontSize = args[1];
1888             // eagerly collect all fonts
1889             next(
1890               self
1891                 .handleSetFont(
1892                   resources,
1893                   args,
1894                   null,
1895                   operatorList,
1896                   task,
1897                   stateManager.state,
1898                   fallbackFontDict
1899                 )
1900                 .then(function (loadedName) {
1901                   operatorList.addDependency(loadedName);
1902                   operatorList.addOp(OPS.setFont, [loadedName, fontSize]);
1903                 })
1904             );
1905             return;
1906           case OPS.beginText:
1907             parsingText = true;
1908             break;
1909           case OPS.endText:
1910             parsingText = false;
1911             break;
1912           case OPS.endInlineImage:
1913             const cacheKey = args[0].cacheKey;
1914             if (cacheKey) {
1915               const localImage = localImageCache.getByName(cacheKey);
1916               if (localImage) {
1917                 addLocallyCachedImageOps(operatorList, localImage);
1918                 args = null;
1919                 continue;
1920               }
1921             }
1922             next(
1923               self.buildPaintImageXObject({
1924                 resources,
1925                 image: args[0],
1926                 isInline: true,
1927                 operatorList,
1928                 cacheKey,
1929                 localImageCache,
1930                 localColorSpaceCache,
1931               })
1932             );
1933             return;
1934           case OPS.showText:
1935             if (!stateManager.state.font) {
1936               self.ensureStateFont(stateManager.state);
1937               continue;
1938             }
1939             args[0] = self.handleText(args[0], stateManager.state);
1940             break;
1941           case OPS.showSpacedText:
1942             if (!stateManager.state.font) {
1943               self.ensureStateFont(stateManager.state);
1944               continue;
1945             }
1946             const combinedGlyphs = [],
1947               state = stateManager.state;
1948             for (const arrItem of args[0]) {
1949               if (typeof arrItem === "string") {
1950                 combinedGlyphs.push(...self.handleText(arrItem, state));
1951               } else if (typeof arrItem === "number") {
1952                 combinedGlyphs.push(arrItem);
1953               }
1954             }
1955             args[0] = combinedGlyphs;
1956             fn = OPS.showText;
1957             break;
1958           case OPS.nextLineShowText:
1959             if (!stateManager.state.font) {
1960               self.ensureStateFont(stateManager.state);
1961               continue;
1962             }
1963             operatorList.addOp(OPS.nextLine);
1964             args[0] = self.handleText(args[0], stateManager.state);
1965             fn = OPS.showText;
1966             break;
1967           case OPS.nextLineSetSpacingShowText:
1968             if (!stateManager.state.font) {
1969               self.ensureStateFont(stateManager.state);
1970               continue;
1971             }
1972             operatorList.addOp(OPS.nextLine);
1973             operatorList.addOp(OPS.setWordSpacing, [args.shift()]);
1974             operatorList.addOp(OPS.setCharSpacing, [args.shift()]);
1975             args[0] = self.handleText(args[0], stateManager.state);
1976             fn = OPS.showText;
1977             break;
1978           case OPS.setTextRenderingMode:
1979             stateManager.state.textRenderingMode = args[0];
1980             break;
1981 
1982           case OPS.setFillColorSpace: {
1983             const fillCS = self._getColorSpace(
1984               args[0],
1985               resources,
1986               localColorSpaceCache
1987             );
1988             if (fillCS instanceof ColorSpace) {
1989               stateManager.state.fillColorSpace = fillCS;
1990               continue;
1991             }
1992 
1993             next(
1994               self._handleColorSpace(fillCS).then(colorSpace => {
1995                 stateManager.state.fillColorSpace =
1996                   colorSpace || ColorSpaceUtils.gray;
1997               })
1998             );
1999             return;
2000           }
2001           case OPS.setStrokeColorSpace: {
2002             const strokeCS = self._getColorSpace(
2003               args[0],
2004               resources,
2005               localColorSpaceCache
2006             );
2007             if (strokeCS instanceof ColorSpace) {
2008               stateManager.state.strokeColorSpace = strokeCS;
2009               continue;
2010             }
2011 
2012             next(
2013               self._handleColorSpace(strokeCS).then(colorSpace => {
2014                 stateManager.state.strokeColorSpace =
2015                   colorSpace || ColorSpaceUtils.gray;
2016               })
2017             );
2018             return;
2019           }
2020           case OPS.setFillColor:
2021             cs = stateManager.state.fillColorSpace;
2022             args = cs.getRgb(args, 0);
2023             fn = OPS.setFillRGBColor;
2024             break;
2025           case OPS.setStrokeColor:
2026             cs = stateManager.state.strokeColorSpace;
2027             args = cs.getRgb(args, 0);
2028             fn = OPS.setStrokeRGBColor;
2029             break;
2030           case OPS.setFillGray:
2031             stateManager.state.fillColorSpace = ColorSpaceUtils.gray;
2032             args = ColorSpaceUtils.gray.getRgb(args, 0);
2033             fn = OPS.setFillRGBColor;
2034             break;
2035           case OPS.setStrokeGray:
2036             stateManager.state.strokeColorSpace = ColorSpaceUtils.gray;
2037             args = ColorSpaceUtils.gray.getRgb(args, 0);
2038             fn = OPS.setStrokeRGBColor;
2039             break;
2040           case OPS.setFillCMYKColor:
2041             stateManager.state.fillColorSpace = ColorSpaceUtils.cmyk;
2042             args = ColorSpaceUtils.cmyk.getRgb(args, 0);
2043             fn = OPS.setFillRGBColor;
2044             break;
2045           case OPS.setStrokeCMYKColor:
2046             stateManager.state.strokeColorSpace = ColorSpaceUtils.cmyk;
2047             args = ColorSpaceUtils.cmyk.getRgb(args, 0);
2048             fn = OPS.setStrokeRGBColor;
2049             break;
2050           case OPS.setFillRGBColor:
2051             stateManager.state.fillColorSpace = ColorSpaceUtils.rgb;
2052             args = ColorSpaceUtils.rgb.getRgb(args, 0);
2053             break;
2054           case OPS.setStrokeRGBColor:
2055             stateManager.state.strokeColorSpace = ColorSpaceUtils.rgb;
2056             args = ColorSpaceUtils.rgb.getRgb(args, 0);
2057             break;
2058           case OPS.setFillColorN:
2059             cs = stateManager.state.patternFillColorSpace;
2060             if (!cs) {
2061               if (isNumberArray(args, null)) {
2062                 args = ColorSpaceUtils.gray.getRgb(args, 0);
2063                 fn = OPS.setFillRGBColor;
2064                 break;
2065               }
2066               args = [];
2067               fn = OPS.setFillTransparent;
2068               break;
2069             }
2070             if (cs.name === "Pattern") {
2071               next(
2072                 self.handleColorN(
2073                   operatorList,
2074                   OPS.setFillColorN,
2075                   args,
2076                   cs,
2077                   patterns,
2078                   resources,
2079                   task,
2080                   localColorSpaceCache,
2081                   localTilingPatternCache,
2082                   localShadingPatternCache
2083                 )
2084               );
2085               return;
2086             }
2087             args = cs.getRgb(args, 0);
2088             fn = OPS.setFillRGBColor;
2089             break;
2090           case OPS.setStrokeColorN:
2091             cs = stateManager.state.patternStrokeColorSpace;
2092             if (!cs) {
2093               if (isNumberArray(args, null)) {
2094                 args = ColorSpaceUtils.gray.getRgb(args, 0);
2095                 fn = OPS.setStrokeRGBColor;
2096                 break;
2097               }
2098               args = [];
2099               fn = OPS.setStrokeTransparent;
2100               break;
2101             }
2102             if (cs.name === "Pattern") {
2103               next(
2104                 self.handleColorN(
2105                   operatorList,
2106                   OPS.setStrokeColorN,
2107                   args,
2108                   cs,
2109                   patterns,
2110                   resources,
2111                   task,
2112                   localColorSpaceCache,
2113                   localTilingPatternCache,
2114                   localShadingPatternCache
2115                 )
2116               );
2117               return;
2118             }
2119             args = cs.getRgb(args, 0);
2120             fn = OPS.setStrokeRGBColor;
2121             break;
2122 
2123           case OPS.shadingFill:
2124             let shading;
2125             try {
2126               const shadingRes = resources.get("Shading");
2127               if (!shadingRes) {
2128                 throw new FormatError("No shading resource found");
2129               }
2130 
2131               shading = shadingRes.get(args[0].name);
2132               if (!shading) {
2133                 throw new FormatError("No shading object found");
2134               }
2135             } catch (reason) {
2136               if (reason instanceof AbortException) {
2137                 continue;
2138               }
2139               if (self.options.ignoreErrors) {
2140                 warn(`getOperatorList - ignoring Shading: "${reason}".`);
2141                 continue;
2142               }
2143               throw reason;
2144             }
2145             const patternId = self.parseShading({
2146               shading,
2147               resources,
2148               localColorSpaceCache,
2149               localShadingPatternCache,
2150             });
2151             if (!patternId) {
2152               continue;
2153             }
2154             args = [patternId];
2155             fn = OPS.shadingFill;
2156             break;
2157           case OPS.setGState:
2158             isValidName = args[0] instanceof Name;
2159             name = args[0].name;
2160 
2161             if (isValidName) {
2162               const localGStateObj = localGStateCache.getByName(name);
2163               if (localGStateObj) {
2164                 if (localGStateObj.length > 0) {
2165                   operatorList.addOp(OPS.setGState, [localGStateObj]);
2166                 }
2167                 args = null;
2168                 continue;
2169               }
2170             }
2171 
2172             next(
2173               new Promise(function (resolveGState, rejectGState) {
2174                 if (!isValidName) {
2175                   throw new FormatError("GState must be referred to by name.");
2176                 }
2177 
2178                 const extGState = resources.get("ExtGState");
2179                 if (!(extGState instanceof Dict)) {
2180                   throw new FormatError("ExtGState should be a dictionary.");
2181                 }
2182 
2183                 const gState = extGState.get(name);
2184                 // TODO: Attempt to lookup cached GStates by reference as well,
2185                 //       if and only if there are PDF documents where doing so
2186                 //       would significantly improve performance.
2187                 if (!(gState instanceof Dict)) {
2188                   throw new FormatError("GState should be a dictionary.");
2189                 }
2190 
2191                 self
2192                   .setGState({
2193                     resources,
2194                     gState,
2195                     operatorList,
2196                     cacheKey: name,
2197                     task,
2198                     stateManager,
2199                     localGStateCache,
2200                     localColorSpaceCache,
2201                   })
2202                   .then(resolveGState, rejectGState);
2203               }).catch(function (reason) {
2204                 if (reason instanceof AbortException) {
2205                   return;
2206                 }
2207                 if (self.options.ignoreErrors) {
2208                   warn(`getOperatorList - ignoring ExtGState: "${reason}".`);
2209                   return;
2210                 }
2211                 throw reason;
2212               })
2213             );
2214             return;
2215           case OPS.moveTo:
2216           case OPS.lineTo:
2217           case OPS.curveTo:
2218           case OPS.curveTo2:
2219           case OPS.curveTo3:
2220           case OPS.closePath:
2221           case OPS.rectangle:
2222             self.buildPath(operatorList, fn, args, parsingText);
2223             continue;
2224           case OPS.markPoint:
2225           case OPS.markPointProps:
2226           case OPS.beginCompat:
2227           case OPS.endCompat:
2228             // Ignore operators where the corresponding handlers are known to
2229             // be no-op in CanvasGraphics (display/canvas.js). This prevents
2230             // serialization errors and is also a bit more efficient.
2231             // We could also try to serialize all objects in a general way,
2232             // e.g. as done in https://github.com/mozilla/pdf.js/pull/6266,
2233             // but doing so is meaningless without knowing the semantics.
2234             continue;
2235           case OPS.beginMarkedContentProps:
2236             if (!(args[0] instanceof Name)) {
2237               warn(`Expected name for beginMarkedContentProps arg0=${args[0]}`);
2238               operatorList.addOp(OPS.beginMarkedContentProps, ["OC", null]);
2239               continue;
2240             }
2241             if (args[0].name === "OC") {
2242               next(
2243                 self
2244                   .parseMarkedContentProps(args[1], resources)
2245                   .then(data => {
2246                     operatorList.addOp(OPS.beginMarkedContentProps, [
2247                       "OC",
2248                       data,
2249                     ]);
2250                   })
2251                   .catch(reason => {
2252                     if (reason instanceof AbortException) {
2253                       return;
2254                     }
2255                     if (self.options.ignoreErrors) {
2256                       warn(
2257                         `getOperatorList - ignoring beginMarkedContentProps: "${reason}".`
2258                       );
2259                       operatorList.addOp(OPS.beginMarkedContentProps, [
2260                         "OC",
2261                         null,
2262                       ]);
2263                       return;
2264                     }
2265                     throw reason;
2266                   })
2267               );
2268               return;
2269             }
2270             // Other marked content types aren't supported yet.
2271             args = [
2272               args[0].name,
2273               args[1] instanceof Dict ? args[1].get("MCID") : null,
2274             ];
2275 
2276             break;
2277           case OPS.beginMarkedContent:
2278           case OPS.endMarkedContent:
2279           default:
2280             // Note: Ignore the operator if it has `Dict` arguments, since
2281             // those are non-serializable, otherwise postMessage will throw
2282             // "An object could not be cloned.".
2283             if (args !== null) {
2284               for (i = 0, ii = args.length; i < ii; i++) {
2285                 if (args[i] instanceof Dict) {
2286                   break;
2287                 }
2288               }
2289               if (i < ii) {
2290                 warn("getOperatorList - ignoring operator: " + fn);
2291                 continue;
2292               }
2293             }
2294         }
2295         operatorList.addOp(fn, args);
2296       }
2297       if (stop) {
2298         next(deferred);
2299         return;
2300       }
2301       // Some PDFs don't close all restores inside object/form.
2302       // Closing those for them.
2303       closePendingRestoreOPS();
2304       resolve();
2305     }).catch(reason => {
2306       if (reason instanceof AbortException) {
2307         return;
2308       }
2309       if (this.options.ignoreErrors) {
2310         warn(
2311           `getOperatorList - ignoring errors during "${task.name}" ` +
2312             `task: "${reason}".`
2313         );
2314 
2315         closePendingRestoreOPS();
2316         return;
2317       }
2318       throw reason;
2319     });
2320   }
2321 
4590 }
4591 
5222 
</code>

Test file:
<test_file>
File:
test/unit/evaluator_spec.js
/* Copyright 2017 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import { createIdFactory, XRefMock } from "./test_utils.js";
import { Dict, Name } from "../../src/core/primitives.js";
import { FormatError, OPS } from "../../src/shared/util.js";
import { Stream, StringStream } from "../../src/core/stream.js";
import { OperatorList } from "../../src/core/operator_list.js";
import { PartialEvaluator } from "../../src/core/evaluator.js";
import { WorkerTask } from "../../src/core/worker.js";
</test_file>

Your task:
You are a software tester at pdf.js.
1. Examine the existing test file. You may reuse any imports, helpers or setup blocks it already has.
2. Write exactly one javascript test `it("...", async () => {...})` block.
3. Your test must fail on the code before the patch, and pass after, hence the test will verify that the patch resolves the issue.
4. The test must be self-contained and to-the-point.
5. If you need something new use only the provided imports (respect the paths exactly how they are given) by importing dynamically for compatibility with Node.js — no new dependencies. You can use the PDF file for testing as follows:
const { getDocument } = await import('../../src/display/api.js');
const { buildGetDocumentParams } = await import('./test_utils.js');
const loadingTask = getDocument(buildGetDocumentParams('issue19633.pdf'))
6. Return only the javascript code for the new `it(...)` block (no comments or explanations).

Example structure:
it("should <describe behavior>", async () => {
  const { example } = await import("../../src/core/example.js");
  <initialize required variables>;
  <define expected variable>;
  <generate actual variables>;
  <compare expected with actual>;
});

