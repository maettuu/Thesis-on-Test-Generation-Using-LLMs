Before you begin:
- Keep going until the job is completely solved — don’t stop halfway.
- If you’re unsure about the behavior, reread the provided patch carefully; do not hallucinate.
- Plan your approach before writing code by reflecting on whether the test truly fails before and passes after.

Issue:
<issue>
[Bug]: Decoding JPEG-2000 image does not work, results in "v128 not enabled" error
### Attach (recommended) or Link to PDF file

[jpx.pdf](https://github.com/user-attachments/files/18419726/jpx.pdf), generated using `magick -background white -fill black -font 'Liberation-Sans' -pointsize 72 -units PixelsPerInch -density 300 label:'JPX' -compress JPEG2000 jpx.pdf`

### Web browser and its version

Firefox 134.0.1

### Operating system and its version

Debian GNU/Linux trixie/sid

### PDF.js version

4.10.38

### Is the bug present in the latest PDF.js version?

Yes

### Is a browser extension

No

### Steps to reproduce the problem

1. Open jpx.pdf.

### What is the expected behavior?

The letters "JPX" appear in black on a white background.

### What went wrong?

No letters appear on the white background. The following messages appear in the Developer Tools Console:

```
PDF 110dd61fd57444010b1ab5ff38782f0f [1.4 pdfeTeX-1.21a / TeX] (PDF.js: 4.10.38 [f9bea397f]) [app.js:1575:12](webpack://pdf.js/web/app.js)
PDF 4bd414b8484300b497f8dc668c7b9503 [1.5 https://imagemagick.org/ / https://imagemagick.org/] (PDF.js: 4.10.38 [f9bea397f]) [app.js:1575:12](webpack://pdf.js/web/app.js)
Warning: Unable to decode image "img_p0_1": "CompileError: at offset 231210: v128 not enabled". [pdf.worker.mjs:345:13](http://localhost:8000/build/pdf.worker.mjs)
Warning: Dependent image isn't ready yet [util.js:376:12](webpack://pdf.js/src/shared/util.js)
```

### Link to a viewer

_No response_

### Additional context

My PC has a very old CPU ([AMD Phenom II X4 810](https://en.wikipedia.org/wiki/AMD_10h#Deneb_(45_nm_SOI,_quad-core))) that does not support SSE4.1. According to <https://bugzilla.mozilla.org/show_bug.cgi?id=1823968>, WASM SIMD is disabled in this case.

[cpuinfo.txt](https://github.com/user-attachments/files/18419848/cpuinfo.txt)
</issue>

PDF File:
<pdf>
issue19326.pdf
</pdf>

Patch:
<patch>
diff --git a/src/core/image.js b/src/core/image.js
--- a/src/core/image.js
+++ b/src/core/image.js
@@ -219,7 +219,9 @@ class PDFImage {
       this.numComps = this.colorSpace.numComps;
 
       if (this.jpxDecoderOptions) {
-        this.jpxDecoderOptions.numComponents = hasColorSpace ? this.numComp : 0;
+        this.jpxDecoderOptions.numComponents = hasColorSpace
+          ? this.numComps
+          : 0;
         // If the jpx image has a color space then it musn't be used in order to
         // be able to use the color space that comes from the pdf.
         this.jpxDecoderOptions.isIndexedColormap =


</patch>

Imports:
<imports>
Available Packages
Dev Dependencies:
- @babel/core: ^7.26.0
- @babel/preset-env: ^7.26.0
- @babel/runtime: ^7.26.0
- @fluent/bundle: ^0.18.0
- @fluent/dom: ^0.10.0
- @metalsmith/layouts: ^2.7.0
- @metalsmith/markdown: ^1.10.0
- @napi-rs/canvas: ^0.1.65
- @types/node: ^22.10.5
- autoprefixer: ^10.4.20
- babel-loader: ^9.2.1
- caniuse-lite: ^1.0.30001692
- core-js: ^3.40.0
- eslint: ^9.17.0
- eslint-plugin-import: ^2.31.0
- eslint-plugin-jasmine: ^4.2.2
- eslint-plugin-json: ^4.0.1
- eslint-plugin-no-unsanitized: ^4.1.2
- eslint-plugin-perfectionist: ^4.6.0
- eslint-plugin-prettier: ^5.2.1
- eslint-plugin-unicorn: ^56.0.1
- globals: ^15.14.0
- gulp: ^5.0.0
- gulp-cli: ^3.0.0
- gulp-postcss: ^10.0.0
- gulp-rename: ^2.0.0
- gulp-replace: ^1.1.4
- gulp-zip: ^6.1.0
- highlight.js: ^11.11.1
- jasmine: ^5.5.0
- jsdoc: ^4.0.4
- jstransformer-nunjucks: ^1.2.0
- metalsmith: ^2.6.3
- metalsmith-html-relative: ^2.0.6
- ordered-read-streams: ^2.0.0
- pngjs: ^7.0.0
- postcss: ^8.4.49
- postcss-dark-theme-class: ^1.3.0
- postcss-dir-pseudo-class: ^9.0.1
- postcss-discard-comments: ^7.0.3
- postcss-nesting: ^13.0.1
- prettier: ^3.4.2
- puppeteer: ^24.0.0
- stylelint: ^16.12.0
- stylelint-prettier: ^5.0.2
- svglint: ^3.1.0
- terser-webpack-plugin: ^5.3.11
- tsc-alias: ^1.8.10
- ttest: ^4.0.0
- typescript: ^5.7.3
- vinyl: ^3.0.0
- webpack: ^5.97.1
- webpack-stream: ^7.0.0
- yargs: ^17.7.2

Engines:
- node: >=20

Available Relative Imports:
- `../../src/core/annotation.js`: Annotation, AnnotationBorderStyle, AnnotationFactory, MarkupAnnotation, getQuadPoints
- `../../src/core/bidi.js`: bidi
- `../../src/core/cff_parser.js`: CFFCharset, CFFCompiler, CFFFDSelect, CFFParser, CFFStrings
- `../../src/core/cmap.js`: CMap, CMapFactory, IdentityCMap
- `../../src/core/colorspace.js`: ColorSpace
- `../../src/core/core_utils.js`: arrayBuffersToBytes, encodeToXmlString, escapePDFName, escapeString, getInheritableProperty, getSizeInBytes, isAscii, isWhiteSpace, log2, numberToString, parseXFAPath, recoverJsURL, stringToUTF16HexString, stringToUTF16String, toRomanNumerals, validateCSSFont
- `../../src/core/crypto.js`: AES128Cipher, AES256Cipher, ARCFourCipher, CipherTransformFactory, PDF17, PDF20, calculateMD5, calculateSHA256, calculateSHA384, calculateSHA512
- `../../src/core/default_appearance.js`: createDefaultAppearance, parseAppearanceStream, parseDefaultAppearance
- `../../src/core/document.js`: PDFDocument, Page
- `../../src/core/encodings.js`: getEncoding
- `../../src/core/evaluator.js`: PartialEvaluator
- `../../src/core/flate_stream.js`: FlateStream
- `../../src/core/font_substitutions.js`: getFontSubstitution
- `../../src/core/fonts_utils.js`: SEAC_ANALYSIS_ENABLED
- `../../src/core/function.js`: PDFFunctionFactory, PostScriptCompiler, PostScriptEvaluator
- `../../src/core/glyphlist.js`: getDingbatsGlyphsUnicode, getGlyphsUnicode
- `../../src/core/image_utils.js`: GlobalImageCache, LocalColorSpaceCache
- `../../src/core/jbig2.js`: Jbig2Error, Jbig2Image
- `../../src/core/jpg.js`: JpegError, JpegImage
- `../../src/core/jpx.js`: JpxError, JpxImage
- `../../src/core/metadata_parser.js`: MetadataParser
- `../../src/core/operator_list.js`: OperatorList
- `../../src/core/parser.js`: Lexer, Linearization, Parser
- `../../src/core/predictor_stream.js`: PredictorStream
- `../../src/core/primitives.js`: Cmd, Dict, EOF, Name, Ref, RefSet, RefSetCache, isCmd, isDict, isName, isRefsEqual
- `../../src/core/ps_parser.js`: PostScriptLexer, PostScriptParser
- `../../src/core/stream.js`: NullStream, Stream, StringStream
- `../../src/core/type1_parser.js`: Type1Parser
- `../../src/core/unicode.js`: getCharUnicodeCategory, getUnicodeForGlyph, getUnicodeRangeFor, mapSpecialUnicodeValues
- `../../src/core/worker.js`: WorkerMessageHandler, WorkerTask
- `../../src/core/writer.js`: incrementalUpdate, writeChanges, writeDict
- `../../src/core/xfa/bind.js`: Binder
- `../../src/core/xfa/data.js`: DataHandler
- `../../src/core/xfa/factory.js`: XFAFactory
- `../../src/core/xfa/formcalc_lexer.js`: Lexer, TOKEN, Token
- `../../src/core/xfa/formcalc_parser.js`: Errors, Parser
- `../../src/core/xfa/parser.js`: XFAParser
- `../../src/core/xfa/som.js`: searchNode
- `../../src/core/xfa/symbol_utils.js`: $dump, $getChildren, $getChildrenByClass, $getChildrenByName, $text, $uid
- `../../src/core/xml_parser.js`: SimpleXMLParser, XMLParserBase
- `../../src/display/annotation_layer.js`: AnnotationLayer
- `../../src/display/annotation_storage.js`: AnnotationStorage
- `../../src/display/api.js`: DefaultCMapReaderFactory, DefaultCanvasFactory, DefaultStandardFontDataFactory, LoopbackPort, PDFDataRangeTransport, PDFDocumentLoadingTask, PDFDocumentProxy, PDFPageProxy, PDFWorker, RenderTask, build, getDocument, version
- `../../src/display/canvas_factory.js`: DOMCanvasFactory
- `../../src/display/display_utils.js`: OutputScale, PDFDateString, PageViewport, PixelsPerInch, RenderingCancelledException, StatTimer, fetchData, getFilenameFromUrl, getPdfFilenameFromUrl, getXfaPageViewport, isDataScheme, isPdfFile, isValidFetchUrl, noContextMenu, setLayerDimensions, stopEvent
- `../../src/display/draw_layer.js`: DrawLayer
- `../../src/display/editor/annotation_editor_layer.js`: AnnotationEditorLayer
- `../../src/display/editor/color_picker.js`: ColorPicker
- `../../src/display/editor/tools.js`: AnnotationEditorUIManager, CommandManager
- `../../src/display/fetch_stream.js`: PDFFetchStream
- `../../src/display/metadata.js`: Metadata
- `../../src/display/network.js`: PDFNetworkStream
- `../../src/display/network_utils.js`: createHeaders, createResponseStatusError, extractFilenameFromHeader, validateRangeRequestCapabilities, validateResponseStatus
- `../../src/display/node_stream.js`: PDFNodeStream
- `../../src/display/node_utils.js`: fetchData
- `../../src/display/svg_factory.js`: DOMSVGFactory
- `../../src/display/text_layer.js`: TextLayer
- `../../src/display/touch_manager.js`: TouchManager
- `../../src/display/worker_options.js`: GlobalWorkerOptions
- `../../src/display/xfa_layer.js`: XfaLayer
- `../../src/shared/message_handler.js`: MessageHandler
- `../../src/shared/murmurhash3.js`: MurmurHash3_64
- `../../src/shared/util.js`: AbortException, AnnotationBorderStyleType, AnnotationEditorParamsType, AnnotationEditorType, AnnotationFieldFlag, AnnotationFlag, AnnotationMode, AnnotationType, BaseException, FeatureTest, FormatError, ImageKind, InvalidPDFException, MissingPDFException, OPS, PasswordException, PasswordResponses, PermissionFlag, RenderingIntentFlag, UnexpectedResponseException, UnknownErrorException, Util, VerbosityLevel, assert, bytesToString, createValidAbsoluteUrl, getModificationDate, getUuid, getVerbosityLevel, isNodeJS, normalizeUnicode, objectSize, setVerbosityLevel, shadow, string32, stringToBytes, stringToPDFString, stringToUTF8String, toBase64Util
- `../../web/annotation_layer_builder.js`: AnnotationLayerBuilder
- `../../web/app_options.js`: AppOptions, OptionKind
- `../../web/download_manager.js`: DownloadManager
- `../../web/event_utils.js`: EventBus, WaitOnType, waitOnEventOrTimeout
- `../../web/genericl10n.js`: GenericL10n
- `../../web/pdf_find_controller.js`: FindState, PDFFindController
- `../../web/pdf_find_utils.js`: CharacterType, getCharacterType
- `../../web/pdf_history.js`: PDFHistory, isDestArraysEqual, isDestHashesEqual
- `../../web/pdf_link_service.js`: LinkTarget, PDFLinkService, SimpleLinkService
- `../../web/pdf_page_view.js`: PDFPageView
- `../../web/pdf_scripting_manager.component.js`: PDFScriptingManager
- `../../web/pdf_single_page_viewer.js`: PDFSinglePageViewer
- `../../web/pdf_viewer.js`: PDFPageViewBuffer, PDFViewer
- `../../web/struct_tree_layer_builder.js`: StructTreeLayerBuilder
- `../../web/text_layer_builder.js`: TextLayerBuilder
- `../../web/ui_utils.js`: AutoPrintRegExp, ProgressBar, RenderingStates, ScrollMode, SpreadMode, backtrackBeforeAllVisibleElements, binarySearchFirstItem, calcRound, getPageSizeInches, getVisibleElements, isPortraitOrientation, isValidRotation, parseQueryString, removeNullCharacters
- `../../web/xfa_layer_builder.js`: XfaLayerBuilder
- `../reporter.js`: TestReporter
- `./common_pdfstream_tests.js`: testCrossOriginRedirects
- `./test_utils.js`: CMAP_URL, DefaultFileReaderFactory, STANDARD_FONT_DATA_URL, TEST_PDFS_PATH, TestPdfsServer, XRefMock, buildGetDocumentParams, createIdFactory, getCrossOriginHostname
</imports>

Code:
<code>
File:
src/core/image.js
1 /* Copyright 2012 Mozilla Foundation
2  *
3  * Licensed under the Apache License, Version 2.0 (the "License");
4  * you may not use this file except in compliance with the License.
5  * You may obtain a copy of the License at
6  *
7  *     http://www.apache.org/licenses/LICENSE-2.0
8  *
9  * Unless required by applicable law or agreed to in writing, software
10  * distributed under the License is distributed on an "AS IS" BASIS,
11  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
12  * See the License for the specific language governing permissions and
13  * limitations under the License.
14  */
15 
16 import {
17   assert,
18   FeatureTest,
19   FormatError,
20   ImageKind,
21   warn,
22 } from "../shared/util.js";
23 import {
24   convertBlackAndWhiteToRGBA,
25   convertToRGBA,
26 } from "../shared/image_utils.js";
27 import { BaseStream } from "./base_stream.js";
28 import { ColorSpace } from "./colorspace.js";
29 import { DecodeStream } from "./decode_stream.js";
30 import { ImageResizer } from "./image_resizer.js";
31 import { JpegStream } from "./jpeg_stream.js";
32 import { JpxImage } from "./jpx.js";
33 import { Name } from "./primitives.js";
34 
35 /**
36  * Decode and clamp a value. The formula is different from the spec because we
37  * don't decode to float range [0,1], we decode it in the [0,max] range.
38  */
39 function decodeAndClamp(value, addend, coefficient, max) {
40   value = addend + value * coefficient;
41   // Clamp the value to the range
42   if (value < 0) {
43     value = 0;
44   } else if (value > max) {
45     value = max;
46   }
47   return value;
48 }
49 
50 /**
51  * Resizes an image mask with 1 component.
52  * @param {TypedArray} src - The source buffer.
53  * @param {number} bpc - Number of bits per component.
54  * @param {number} w1 - Original width.
55  * @param {number} h1 - Original height.
56  * @param {number} w2 - New width.
57  * @param {number} h2 - New height.
58  * @returns {TypedArray} The resized image mask buffer.
59  */
60 function resizeImageMask(src, bpc, w1, h1, w2, h2) {
61   const length = w2 * h2;
62   let dest;
63   if (bpc <= 8) {
64     dest = new Uint8Array(length);
65   } else if (bpc <= 16) {
66     dest = new Uint16Array(length);
67   } else {
68     dest = new Uint32Array(length);
69   }
70   const xRatio = w1 / w2;
71   const yRatio = h1 / h2;
72   let i,
73     j,
74     py,
75     newIndex = 0,
76     oldIndex;
77   const xScaled = new Uint16Array(w2);
78   const w1Scanline = w1;
79 
80   for (i = 0; i < w2; i++) {
81     xScaled[i] = Math.floor(i * xRatio);
82   }
83   for (i = 0; i < h2; i++) {
84     py = Math.floor(i * yRatio) * w1Scanline;
85     for (j = 0; j < w2; j++) {
86       oldIndex = py + xScaled[j];
87       dest[newIndex++] = src[oldIndex];
88     }
89   }
90   return dest;
91 }
92 
93 class PDFImage {
94   constructor({
95     xref,
96     res,
97     image,
98     isInline = false,
99     smask = null,
100     mask = null,
101     isMask = false,
102     pdfFunctionFactory,
103     localColorSpaceCache,
104   }) {
105     this.image = image;
106     const dict = image.dict;
107 
108     const filter = dict.get("F", "Filter");
109     let filterName;
110     if (filter instanceof Name) {
111       filterName = filter.name;
112     } else if (Array.isArray(filter)) {
113       const filterZero = xref.fetchIfRef(filter[0]);
114       if (filterZero instanceof Name) {
115         filterName = filterZero.name;
116       }
117     }
118     switch (filterName) {
119       case "JPXDecode":
120         ({
121           width: image.width,
122           height: image.height,
123           componentsCount: image.numComps,
124           bitsPerComponent: image.bitsPerComponent,
125         } = JpxImage.parseImageProperties(image.stream));
126         image.stream.reset();
127         this.jpxDecoderOptions = {
128           numComponents: 0,
129           isIndexedColormap: false,
130           smaskInData: dict.has("SMaskInData"),
131         };
132         break;
133       case "JBIG2Decode":
134         image.bitsPerComponent = 1;
135         image.numComps = 1;
136         break;
137     }
138 
139     let width = dict.get("W", "Width");
140     let height = dict.get("H", "Height");
141 
142     if (
143       Number.isInteger(image.width) &&
144       image.width > 0 &&
145       Number.isInteger(image.height) &&
146       image.height > 0 &&
147       (image.width !== width || image.height !== height)
148     ) {
149       warn(
150         "PDFImage - using the Width/Height of the image data, " +
151           "rather than the image dictionary."
152       );
153       width = image.width;
154       height = image.height;
155     }
156     if (width < 1 || height < 1) {
157       throw new FormatError(
158         `Invalid image width: ${width} or height: ${height}`
159       );
160     }
161     this.width = width;
162     this.height = height;
163 
164     this.interpolate = dict.get("I", "Interpolate");
165     this.imageMask = dict.get("IM", "ImageMask") || false;
166     this.matte = dict.get("Matte") || false;
167 
168     let bitsPerComponent = image.bitsPerComponent;
169     if (!bitsPerComponent) {
170       bitsPerComponent = dict.get("BPC", "BitsPerComponent");
171       if (!bitsPerComponent) {
172         if (this.imageMask) {
173           bitsPerComponent = 1;
174         } else {
175           throw new FormatError(
176             `Bits per component missing in image: ${this.imageMask}`
177           );
178         }
179       }
180     }
181     this.bpc = bitsPerComponent;
182 
183     if (!this.imageMask) {
184       let colorSpace = dict.getRaw("CS") || dict.getRaw("ColorSpace");
185       const hasColorSpace = !!colorSpace;
186       if (!hasColorSpace) {
187         if (this.jpxDecoderOptions) {
188           colorSpace = Name.get("DeviceRGBA");
189         } else {
190           switch (image.numComps) {
191             case 1:
192               colorSpace = Name.get("DeviceGray");
193               break;
194             case 3:
195               colorSpace = Name.get("DeviceRGB");
196               break;
197             case 4:
198               colorSpace = Name.get("DeviceCMYK");
199               break;
200             default:
201               throw new Error(
202                 `Images with ${image.numComps} color components not supported.`
203               );
204           }
205         }
206       } else if (this.jpxDecoderOptions?.smaskInData) {
207         // If the jpx image has a color space then it mustn't be used in order
208         // to be able to use the color space that comes from the pdf.
209         colorSpace = Name.get("DeviceRGBA");
210       }
211 
212       this.colorSpace = ColorSpace.parse({
213         cs: colorSpace,
214         xref,
215         resources: isInline ? res : null,
216         pdfFunctionFactory,
217         localColorSpaceCache,
218       });
219       this.numComps = this.colorSpace.numComps;
220 
221       if (this.jpxDecoderOptions) {
222         this.jpxDecoderOptions.numComponents = hasColorSpace ? this.numComp : 0;
223         // If the jpx image has a color space then it musn't be used in order to
224         // be able to use the color space that comes from the pdf.
225         this.jpxDecoderOptions.isIndexedColormap =
226           this.colorSpace.name === "Indexed";
227       }
228     }
229 
230     this.decode = dict.getArray("D", "Decode");
231     this.needsDecode = false;
232     if (
233       this.decode &&
234       ((this.colorSpace &&
235         !this.colorSpace.isDefaultDecode(this.decode, bitsPerComponent)) ||
236         (isMask &&
237           !ColorSpace.isDefaultDecode(this.decode, /* numComps = */ 1)))
238     ) {
239       this.needsDecode = true;
240       // Do some preprocessing to avoid more math.
241       const max = (1 << bitsPerComponent) - 1;
242       this.decodeCoefficients = [];
243       this.decodeAddends = [];
244       const isIndexed = this.colorSpace?.name === "Indexed";
245       for (let i = 0, j = 0; i < this.decode.length; i += 2, ++j) {
246         const dmin = this.decode[i];
247         const dmax = this.decode[i + 1];
248         this.decodeCoefficients[j] = isIndexed
249           ? (dmax - dmin) / max
250           : dmax - dmin;
251         this.decodeAddends[j] = isIndexed ? dmin : max * dmin;
252       }
253     }
254 
255     if (smask) {
256       this.smask = new PDFImage({
257         xref,
258         res,
259         image: smask,
260         isInline,
261         pdfFunctionFactory,
262         localColorSpaceCache,
263       });
264     } else if (mask) {
265       if (mask instanceof BaseStream) {
266         const maskDict = mask.dict,
267           imageMask = maskDict.get("IM", "ImageMask");
268         if (!imageMask) {
269           warn("Ignoring /Mask in image without /ImageMask.");
270         } else {
271           this.mask = new PDFImage({
272             xref,
273             res,
274             image: mask,
275             isInline,
276             isMask: true,
277             pdfFunctionFactory,
278             localColorSpaceCache,
279           });
280         }
281       } else {
282         // Color key mask (just an array).
283         this.mask = mask;
284       }
285     }
286   }
287 
288   /**
289    * Handles processing of image data and returns the Promise that is resolved
290    * with a PDFImage when the image is ready to be used.
291    */
292   static async buildImage({
293     xref,
294     res,
295     image,
296     isInline = false,
297     pdfFunctionFactory,
298     localColorSpaceCache,
299   }) {
300     const imageData = image;
301     let smaskData = null;
302     let maskData = null;
303 
304     const smask = image.dict.get("SMask");
305     const mask = image.dict.get("Mask");
306 
307     if (smask) {
308       if (smask instanceof BaseStream) {
309         smaskData = smask;
310       } else {
311         warn("Unsupported /SMask format.");
312       }
313     } else if (mask) {
314       if (mask instanceof BaseStream || Array.isArray(mask)) {
315         maskData = mask;
316       } else {
317         warn("Unsupported /Mask format.");
318       }
319     }
320 
321     return new PDFImage({
322       xref,
323       res,
324       image: imageData,
325       isInline,
326       smask: smaskData,
327       mask: maskData,
328       pdfFunctionFactory,
329       localColorSpaceCache,
330     });
331   }
332 
333   static createRawMask({
334     imgArray,
335     width,
336     height,
337     imageIsFromDecodeStream,
338     inverseDecode,
339     interpolate,
340   }) {
341     // |imgArray| might not contain full data for every pixel of the mask, so
342     // we need to distinguish between |computedLength| and |actualLength|.
343     // In particular, if inverseDecode is true, then the array we return must
344     // have a length of |computedLength|.
345 
346     const computedLength = ((width + 7) >> 3) * height;
347     const actualLength = imgArray.byteLength;
348     const haveFullData = computedLength === actualLength;
349     let data, i;
350 
351     if (imageIsFromDecodeStream && (!inverseDecode || haveFullData)) {
352       // imgArray came from a DecodeStream and its data is in an appropriate
353       // form, so we can just transfer it.
354       data = imgArray;
355     } else if (!inverseDecode) {
356       data = new Uint8Array(imgArray);
357     } else {
358       data = new Uint8Array(computedLength);
359       data.set(imgArray);
360       data.fill(0xff, actualLength);
361     }
362 
363     // If necessary, invert the original mask data (but not any extra we might
364     // have added above). It's safe to modify the array -- whether it's the
365     // original or a copy, we're about to transfer it anyway, so nothing else
366     // in this thread can be relying on its contents.
367     if (inverseDecode) {
368       for (i = 0; i < actualLength; i++) {
369         data[i] ^= 0xff;
370       }
371     }
372 
373     return { data, width, height, interpolate };
374   }
375 
376   static async createMask({
377     imgArray,
378     width,
379     height,
380     imageIsFromDecodeStream,
381     inverseDecode,
382     interpolate,
383     isOffscreenCanvasSupported = false,
384   }) {
385     const isSingleOpaquePixel =
386       width === 1 &&
387       height === 1 &&
388       inverseDecode === (imgArray.length === 0 || !!(imgArray[0] & 128));
389 
390     if (isSingleOpaquePixel) {
391       return { isSingleOpaquePixel };
392     }
393 
394     if (isOffscreenCanvasSupported) {
395       if (ImageResizer.needsToBeResized(width, height)) {
396         const data = new Uint8ClampedArray(width * height * 4);
397         convertBlackAndWhiteToRGBA({
398           src: imgArray,
399           dest: data,
400           width,
401           height,
402           nonBlackColor: 0,
403           inverseDecode,
404         });
405         return ImageResizer.createImage({
406           kind: ImageKind.RGBA_32BPP,
407           data,
408           width,
409           height,
410           interpolate,
411         });
412       }
413 
414       const canvas = new OffscreenCanvas(width, height);
415       const ctx = canvas.getContext("2d");
416       const imgData = ctx.createImageData(width, height);
417       convertBlackAndWhiteToRGBA({
418         src: imgArray,
419         dest: imgData.data,
420         width,
421         height,
422         nonBlackColor: 0,
423         inverseDecode,
424       });
425 
426       ctx.putImageData(imgData, 0, 0);
427       const bitmap = canvas.transferToImageBitmap();
428 
429       return {
430         data: null,
431         width,
432         height,
433         interpolate,
434         bitmap,
435       };
436     }
437 
438     // Get the data almost as they're and they'll be decoded
439     // just before being drawn.
440     return this.createRawMask({
441       imgArray,
442       width,
443       height,
444       inverseDecode,
445       imageIsFromDecodeStream,
446       interpolate,
447     });
448   }
449 
450   get drawWidth() {
451     return Math.max(this.width, this.smask?.width || 0, this.mask?.width || 0);
452   }
453 
454   get drawHeight() {
455     return Math.max(
456       this.height,
457       this.smask?.height || 0,
458       this.mask?.height || 0
459     );
460   }
461 
462   decodeBuffer(buffer) {
463     const bpc = this.bpc;
464     const numComps = this.numComps;
465 
466     const decodeAddends = this.decodeAddends;
467     const decodeCoefficients = this.decodeCoefficients;
468     const max = (1 << bpc) - 1;
469     let i, ii;
470 
471     if (bpc === 1) {
472       // If the buffer needed decode that means it just needs to be inverted.
473       for (i = 0, ii = buffer.length; i < ii; i++) {
474         buffer[i] = +!buffer[i];
475       }
476       return;
477     }
478     let index = 0;
479     for (i = 0, ii = this.width * this.height; i < ii; i++) {
480       for (let j = 0; j < numComps; j++) {
481         buffer[index] = decodeAndClamp(
482           buffer[index],
483           decodeAddends[j],
484           decodeCoefficients[j],
485           max
486         );
487         index++;
488       }
489     }
490   }
491 
492   getComponents(buffer) {
493     const bpc = this.bpc;
494 
495     // This image doesn't require any extra work.
496     if (bpc === 8) {
497       return buffer;
498     }
499 
500     const width = this.width;
501     const height = this.height;
502     const numComps = this.numComps;
503 
504     const length = width * height * numComps;
505     let bufferPos = 0;
506     let output;
507     if (bpc <= 8) {
508       output = new Uint8Array(length);
509     } else if (bpc <= 16) {
510       output = new Uint16Array(length);
511     } else {
512       output = new Uint32Array(length);
513     }
514     const rowComps = width * numComps;
515 
516     const max = (1 << bpc) - 1;
517     let i = 0,
518       ii,
519       buf;
520 
521     if (bpc === 1) {
522       // Optimization for reading 1 bpc images.
523       let mask, loop1End, loop2End;
524       for (let j = 0; j < height; j++) {
525         loop1End = i + (rowComps & ~7);
526         loop2End = i + rowComps;
527 
528         // unroll loop for all full bytes
529         while (i < loop1End) {
530           buf = buffer[bufferPos++];
531           output[i] = (buf >> 7) & 1;
532           output[i + 1] = (buf >> 6) & 1;
533           output[i + 2] = (buf >> 5) & 1;
534           output[i + 3] = (buf >> 4) & 1;
535           output[i + 4] = (buf >> 3) & 1;
536           output[i + 5] = (buf >> 2) & 1;
537           output[i + 6] = (buf >> 1) & 1;
538           output[i + 7] = buf & 1;
539           i += 8;
540         }
541 
542         // handle remaining bits
543         if (i < loop2End) {
544           buf = buffer[bufferPos++];
545           mask = 128;
546           while (i < loop2End) {
547             output[i++] = +!!(buf & mask);
548             mask >>= 1;
549           }
550         }
551       }
552     } else {
553       // The general case that handles all other bpc values.
554       let bits = 0;
555       buf = 0;
556       for (i = 0, ii = length; i < ii; ++i) {
557         if (i % rowComps === 0) {
558           buf = 0;
559           bits = 0;
560         }
561 
562         while (bits < bpc) {
563           buf = (buf << 8) | buffer[bufferPos++];
564           bits += 8;
565         }
566 
567         const remainingBits = bits - bpc;
568         let value = buf >> remainingBits;
569         if (value < 0) {
570           value = 0;
571         } else if (value > max) {
572           value = max;
573         }
574         output[i] = value;
575         buf &= (1 << remainingBits) - 1;
576         bits = remainingBits;
577       }
578     }
579     return output;
580   }
581 
582   async fillOpacity(rgbaBuf, width, height, actualHeight, image) {
583     if (typeof PDFJSDev === "undefined" || PDFJSDev.test("TESTING")) {
584       assert(
585         rgbaBuf instanceof Uint8ClampedArray,
586         'PDFImage.fillOpacity: Unsupported "rgbaBuf" type.'
587       );
588     }
589     const smask = this.smask;
590     const mask = this.mask;
591     let alphaBuf, sw, sh, i, ii, j;
592 
593     if (smask) {
594       sw = smask.width;
595       sh = smask.height;
596       alphaBuf = new Uint8ClampedArray(sw * sh);
597       await smask.fillGrayBuffer(alphaBuf);
598       if (sw !== width || sh !== height) {
599         alphaBuf = resizeImageMask(alphaBuf, smask.bpc, sw, sh, width, height);
600       }
601     } else if (mask) {
602       if (mask instanceof PDFImage) {
603         sw = mask.width;
604         sh = mask.height;
605         alphaBuf = new Uint8ClampedArray(sw * sh);
606         mask.numComps = 1;
607         await mask.fillGrayBuffer(alphaBuf);
608 
609         // Need to invert values in rgbaBuf
610         for (i = 0, ii = sw * sh; i < ii; ++i) {
611           alphaBuf[i] = 255 - alphaBuf[i];
612         }
613 
614         if (sw !== width || sh !== height) {
615           alphaBuf = resizeImageMask(alphaBuf, mask.bpc, sw, sh, width, height);
616         }
617       } else if (Array.isArray(mask)) {
618         // Color key mask: if any of the components are outside the range
619         // then they should be painted.
620         alphaBuf = new Uint8ClampedArray(width * height);
621         const numComps = this.numComps;
622         for (i = 0, ii = width * height; i < ii; ++i) {
623           let opacity = 0;
624           const imageOffset = i * numComps;
625           for (j = 0; j < numComps; ++j) {
626             const color = image[imageOffset + j];
627             const maskOffset = j * 2;
628             if (color < mask[maskOffset] || color > mask[maskOffset + 1]) {
629               opacity = 255;
630               break;
631             }
632           }
633           alphaBuf[i] = opacity;
634         }
635       } else {
636         throw new FormatError("Unknown mask format.");
637       }
638     }
639 
640     if (alphaBuf) {
641       for (i = 0, j = 3, ii = width * actualHeight; i < ii; ++i, j += 4) {
642         rgbaBuf[j] = alphaBuf[i];
643       }
644     } else {
645       // No mask.
646       for (i = 0, j = 3, ii = width * actualHeight; i < ii; ++i, j += 4) {
647         rgbaBuf[j] = 255;
648       }
649     }
650   }
651 
652   undoPreblend(buffer, width, height) {
653     if (typeof PDFJSDev === "undefined" || PDFJSDev.test("TESTING")) {
654       assert(
655         buffer instanceof Uint8ClampedArray,
656         'PDFImage.undoPreblend: Unsupported "buffer" type.'
657       );
658     }
659     const matte = this.smask?.matte;
660     if (!matte) {
661       return;
662     }
663     const matteRgb = this.colorSpace.getRgb(matte, 0);
664     const matteR = matteRgb[0];
665     const matteG = matteRgb[1];
666     const matteB = matteRgb[2];
667     const length = width * height * 4;
668     for (let i = 0; i < length; i += 4) {
669       const alpha = buffer[i + 3];
670       if (alpha === 0) {
671         // according formula we have to get Infinity in all components
672         // making it white (typical paper color) should be okay
673         buffer[i] = 255;
674         buffer[i + 1] = 255;
675         buffer[i + 2] = 255;
676         continue;
677       }
678       const k = 255 / alpha;
679       buffer[i] = (buffer[i] - matteR) * k + matteR;
680       buffer[i + 1] = (buffer[i + 1] - matteG) * k + matteG;
681       buffer[i + 2] = (buffer[i + 2] - matteB) * k + matteB;
682     }
683   }
684 
685   async createImageData(forceRGBA = false, isOffscreenCanvasSupported = false) {
686     const drawWidth = this.drawWidth;
687     const drawHeight = this.drawHeight;
688     const imgData = {
689       width: drawWidth,
690       height: drawHeight,
691       interpolate: this.interpolate,
692       kind: 0,
693       data: null,
694       // Other fields are filled in below.
695     };
696 
697     const numComps = this.numComps;
698     const originalWidth = this.width;
699     const originalHeight = this.height;
700     const bpc = this.bpc;
701 
702     // Rows start at byte boundary.
703     const rowBytes = (originalWidth * numComps * bpc + 7) >> 3;
704     const mustBeResized =
705       isOffscreenCanvasSupported &&
706       ImageResizer.needsToBeResized(drawWidth, drawHeight);
707 
708     if (!this.smask && !this.mask && this.colorSpace.name === "DeviceRGBA") {
709       imgData.kind = ImageKind.RGBA_32BPP;
710       const imgArray = (imgData.data = await this.getImageBytes(
711         originalHeight * originalWidth * 4,
712         {}
713       ));
714 
715       if (isOffscreenCanvasSupported) {
716         if (!mustBeResized) {
717           return this.createBitmap(
718             ImageKind.RGBA_32BPP,
719             drawWidth,
720             drawHeight,
721             imgArray
722           );
723         }
724         return ImageResizer.createImage(imgData, false);
725       }
726 
727       return imgData;
728     }
729 
730     if (!forceRGBA) {
731       // If it is a 1-bit-per-pixel grayscale (i.e. black-and-white) image
732       // without any complications, we pass a same-sized copy to the main
733       // thread rather than expanding by 32x to RGBA form. This saves *lots*
734       // of memory for many scanned documents. It's also much faster.
735       //
736       // Similarly, if it is a 24-bit-per pixel RGB image without any
737       // complications, we avoid expanding by 1.333x to RGBA form.
738       let kind;
739       if (this.colorSpace.name === "DeviceGray" && bpc === 1) {
740         kind = ImageKind.GRAYSCALE_1BPP;
741       } else if (
742         this.colorSpace.name === "DeviceRGB" &&
743         bpc === 8 &&
744         !this.needsDecode
745       ) {
746         kind = ImageKind.RGB_24BPP;
747       }
748       if (
749         kind &&
750         !this.smask &&
751         !this.mask &&
752         drawWidth === originalWidth &&
753         drawHeight === originalHeight
754       ) {
755         const image = await this.#getImage(originalWidth, originalHeight);
756         if (image) {
757           return image;
758         }
759         const data = await this.getImageBytes(originalHeight * rowBytes, {});
760         if (isOffscreenCanvasSupported) {
761           if (mustBeResized) {
762             return ImageResizer.createImage(
763               {
764                 data,
765                 kind,
766                 width: drawWidth,
767                 height: drawHeight,
768                 interpolate: this.interpolate,
769               },
770               this.needsDecode
771             );
772           }
773           return this.createBitmap(kind, originalWidth, originalHeight, data);
774         }
775         imgData.kind = kind;
776         imgData.data = data;
777 
778         if (this.needsDecode) {
779           // Invert the buffer (which must be grayscale if we reached here).
780           assert(
781             kind === ImageKind.GRAYSCALE_1BPP,
782             "PDFImage.createImageData: The image must be grayscale."
783           );
784           const buffer = imgData.data;
785           for (let i = 0, ii = buffer.length; i < ii; i++) {
786             buffer[i] ^= 0xff;
787           }
788         }
789         return imgData;
790       }
791       if (
792         this.image instanceof JpegStream &&
793         !this.smask &&
794         !this.mask &&
795         !this.needsDecode
796       ) {
797         let imageLength = originalHeight * rowBytes;
798         if (isOffscreenCanvasSupported && !mustBeResized) {
799           let isHandled = false;
800           switch (this.colorSpace.name) {
801             case "DeviceGray":
802               // Avoid truncating the image, since `JpegImage.getData`
803               // will expand the image data when `forceRGB === true`.
804               imageLength *= 4;
805               isHandled = true;
806               break;
807             case "DeviceRGB":
808               imageLength = (imageLength / 3) * 4;
809               isHandled = true;
810               break;
811             case "DeviceCMYK":
812               isHandled = true;
813               break;
814           }
815 
816           if (isHandled) {
817             const image = await this.#getImage(drawWidth, drawHeight);
818             if (image) {
819               return image;
820             }
821             const rgba = await this.getImageBytes(imageLength, {
822               drawWidth,
823               drawHeight,
824               forceRGBA: true,
825             });
826             return this.createBitmap(
827               ImageKind.RGBA_32BPP,
828               drawWidth,
829               drawHeight,
830               rgba
831             );
832           }
833         } else {
834           switch (this.colorSpace.name) {
835             case "DeviceGray":
836               imageLength *= 3;
837             /* falls through */
838             case "DeviceRGB":
839             case "DeviceCMYK":
840               imgData.kind = ImageKind.RGB_24BPP;
841               imgData.data = await this.getImageBytes(imageLength, {
842                 drawWidth,
843                 drawHeight,
844                 forceRGB: true,
845               });
846               if (mustBeResized) {
847                 // The image is too big so we resize it.
848                 return ImageResizer.createImage(imgData);
849               }
850               return imgData;
851           }
852         }
853       }
854     }
855 
856     const imgArray = await this.getImageBytes(originalHeight * rowBytes, {
857       internal: true,
858     });
859     // imgArray can be incomplete (e.g. after CCITT fax encoding).
860     const actualHeight =
861       0 | (((imgArray.length / rowBytes) * drawHeight) / originalHeight);
862 
863     const comps = this.getComponents(imgArray);
864 
865     // If opacity data is present, use RGBA_32BPP form. Otherwise, use the
866     // more compact RGB_24BPP form if allowable.
867     let alpha01, maybeUndoPreblend;
868 
869     let canvas, ctx, canvasImgData, data;
870     if (isOffscreenCanvasSupported && !mustBeResized) {
871       canvas = new OffscreenCanvas(drawWidth, drawHeight);
872       ctx = canvas.getContext("2d");
873       canvasImgData = ctx.createImageData(drawWidth, drawHeight);
874       data = canvasImgData.data;
875     }
876 
877     imgData.kind = ImageKind.RGBA_32BPP;
878 
879     if (!forceRGBA && !this.smask && !this.mask) {
880       if (!isOffscreenCanvasSupported || mustBeResized) {
881         imgData.kind = ImageKind.RGB_24BPP;
882         data = new Uint8ClampedArray(drawWidth * drawHeight * 3);
883         alpha01 = 0;
884       } else {
885         const arr = new Uint32Array(data.buffer);
886         arr.fill(FeatureTest.isLittleEndian ? 0xff000000 : 0x000000ff);
887         alpha01 = 1;
888       }
889       maybeUndoPreblend = false;
890     } else {
891       if (!isOffscreenCanvasSupported || mustBeResized) {
892         data = new Uint8ClampedArray(drawWidth * drawHeight * 4);
893       }
894 
895       alpha01 = 1;
896       maybeUndoPreblend = true;
897 
898       // Color key masking (opacity) must be performed before decoding.
899       await this.fillOpacity(data, drawWidth, drawHeight, actualHeight, comps);
900     }
901 
902     if (this.needsDecode) {
903       this.decodeBuffer(comps);
904     }
905     this.colorSpace.fillRgb(
906       data,
907       originalWidth,
908       originalHeight,
909       drawWidth,
910       drawHeight,
911       actualHeight,
912       bpc,
913       comps,
914       alpha01
915     );
916     if (maybeUndoPreblend) {
917       this.undoPreblend(data, drawWidth, actualHeight);
918     }
919 
920     if (isOffscreenCanvasSupported && !mustBeResized) {
921       ctx.putImageData(canvasImgData, 0, 0);
922       const bitmap = canvas.transferToImageBitmap();
923 
924       return {
925         data: null,
926         width: drawWidth,
927         height: drawHeight,
928         bitmap,
929         interpolate: this.interpolate,
930       };
931     }
932 
933     imgData.data = data;
934     if (mustBeResized) {
935       return ImageResizer.createImage(imgData);
936     }
937     return imgData;
938   }
939 
940   async fillGrayBuffer(buffer) {
941     if (typeof PDFJSDev === "undefined" || PDFJSDev.test("TESTING")) {
942       assert(
943         buffer instanceof Uint8ClampedArray,
944         'PDFImage.fillGrayBuffer: Unsupported "buffer" type.'
945       );
946     }
947     const numComps = this.numComps;
948     if (numComps !== 1) {
949       throw new FormatError(
950         `Reading gray scale from a color image: ${numComps}`
951       );
952     }
953 
954     const width = this.width;
955     const height = this.height;
956     const bpc = this.bpc;
957 
958     // rows start at byte boundary
959     const rowBytes = (width * numComps * bpc + 7) >> 3;
960     const imgArray = await this.getImageBytes(height * rowBytes, {
961       internal: true,
962     });
963 
964     const comps = this.getComponents(imgArray);
965     let i, length;
966 
967     if (bpc === 1) {
968       // inline decoding (= inversion) for 1 bpc images
969       length = width * height;
970       if (this.needsDecode) {
971         // invert and scale to {0, 255}
972         for (i = 0; i < length; ++i) {
973           buffer[i] = (comps[i] - 1) & 255;
974         }
975       } else {
976         // scale to {0, 255}
977         for (i = 0; i < length; ++i) {
978           buffer[i] = -comps[i] & 255;
979         }
980       }
981       return;
982     }
983 
984     if (this.needsDecode) {
985       this.decodeBuffer(comps);
986     }
987     length = width * height;
988     // we aren't using a colorspace so we need to scale the value
989     const scale = 255 / ((1 << bpc) - 1);
990     for (i = 0; i < length; ++i) {
991       buffer[i] = scale * comps[i];
992     }
993   }
994 
995   createBitmap(kind, width, height, src) {
996     const canvas = new OffscreenCanvas(width, height);
997     const ctx = canvas.getContext("2d");
998     let imgData;
999     if (kind === ImageKind.RGBA_32BPP) {
1000       imgData = new ImageData(src, width, height);
1001     } else {
1002       imgData = ctx.createImageData(width, height);
1003       convertToRGBA({
1004         kind,
1005         src,
1006         dest: new Uint32Array(imgData.data.buffer),
1007         width,
1008         height,
1009         inverseDecode: this.needsDecode,
1010       });
1011     }
1012     ctx.putImageData(imgData, 0, 0);
1013     const bitmap = canvas.transferToImageBitmap();
1014 
1015     return {
1016       data: null,
1017       width,
1018       height,
1019       bitmap,
1020       interpolate: this.interpolate,
1021     };
1022   }
1023 
1024   async #getImage(width, height) {
1025     const bitmap = await this.image.getTransferableImage();
1026     if (!bitmap) {
1027       return null;
1028     }
1029     return {
1030       data: null,
1031       width,
1032       height,
1033       bitmap,
1034       interpolate: this.interpolate,
1035     };
1036   }
1037 
1038   async getImageBytes(
1039     length,
1040     {
1041       drawWidth,
1042       drawHeight,
1043       forceRGBA = false,
1044       forceRGB = false,
1045       internal = false,
1046     }
1047   ) {
1048     this.image.reset();
1049     this.image.drawWidth = drawWidth || this.width;
1050     this.image.drawHeight = drawHeight || this.height;
1051     this.image.forceRGBA = !!forceRGBA;
1052     this.image.forceRGB = !!forceRGB;
1053     const imageBytes = await this.image.getImageData(
1054       length,
1055       this.jpxDecoderOptions
1056     );
1057 
1058     // If imageBytes came from a DecodeStream, we're safe to transfer it
1059     // (and thus detach its underlying buffer) because it will constitute
1060     // the entire DecodeStream's data.  But if it came from a Stream, we
1061     // need to copy it because it'll only be a portion of the Stream's
1062     // data, and the rest will be read later on.
1063     if (internal || this.image instanceof DecodeStream) {
1064       return imageBytes;
1065     }
1066     assert(
1067       imageBytes instanceof Uint8Array,
1068       'PDFImage.getImageBytes: Unsupported "imageBytes" type.'
1069     );
1070     return new Uint8Array(imageBytes);
1071   }
1072 }
1073 
1074 export { PDFImage };
</code>

Your task:
You are a software tester at pdf.js.
1. Write exactly one javascript test `it("...", async () => {...})` block.
2. Your test must fail on the code before the patch, and pass after, hence the test will verify that the patch resolves the issue.
3. The test must be self-contained and to-the-point.
4. Use only the provided imports (respect the paths exactly how they are given) by importing dynamically for compatibility with Node.js — no new dependencies. You can use the PDF file for testing as follows:
const { getDocument } = await import('../../src/display/api.js');
const { buildGetDocumentParams } = await import('./test_utils.js');
const loadingTask = getDocument(buildGetDocumentParams('issue19326.pdf'))
5. Return only the javascript code (no comments or explanations).

Example structure:
it("should <describe behavior>", async () => {
  const { example } = await import("../../src/core/example.js");
  <initialize required variables>;
  <define expected variable>;
  <generate actual variables>;
  <compare expected with actual>;
});

