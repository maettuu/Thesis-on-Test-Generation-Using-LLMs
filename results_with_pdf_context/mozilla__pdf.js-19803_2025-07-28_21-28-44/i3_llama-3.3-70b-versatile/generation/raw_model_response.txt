``` 
it("should not render annotations with circular references", async () => {
  const { getDocument } = await import('../../src/display/api.js');
  const { buildGetDocumentParams } = await import('./test_utils.js');
  const loadingTask = getDocument(buildGetDocumentParams('evil_xobjects.pdf'));
  const pdf = await loadingPage(loadingTask);
  const page = await pdf.getPage(0);
  const annotations = await page.getAnnotations();
  const annotation = annotations[0];
  const appearance = annotation.appearance;
  const resources = await page.loadResources(["ExtGState", "ColorSpace", "Pattern", "Shading", "XObject", "Font"]);
  const partialEvaluator = new PartialEvaluator({
    xref: page.xref,
    handler: new WorkerMessageHandler(),
    pageIndex: page.pageIndex,
    idFactory: createIdFactory(),
    fontCache: page.fontCache,
    builtInCMapCache: page.builtInCMapCache,
    standardFontDataCache: page.standardFontDataCache,
    globalColorSpaceCache: page.globalColorSpaceCache,
    globalImageCache: page.globalImageCache,
    systemFontCache: page.systemFontCache,
    options: {
      ignoreErrors: false,
      isOffscreenCanvasSupported: false,
      isImageDecoderSupported: false,
      isEvalSupported: true,
      maxImageSize: -1,
      disableFontFace: false,
      fontExtraProperties: false,
      useSystemFonts: true,
      useWasm: true,
      useWorkerFetch: true,
      cMapUrl: CMAP_URL,
      iccUrl: null,
      standardFontDataUrl: STANDARD_FONT_DATA_URL,
      wasmUrl: null,
    },
    localColorSpaceCache: new LocalColorSpaceCache(),
    localGStateCache: new LocalGStateCache(),
    localTilingPatternCache: new LocalTilingPatternCache(),
    localShadingPatternCache: new Map(),
  });
  const operatorList = new OperatorList();
  await partialEvaluator.getOperatorList({
    stream: appearance,
    task: new WorkerTask(),
    resources,
    operatorList,
    stateManager: new StateManager(),
    cacheKey: null,
    localImageCache: new LocalImageCache(),
  });
  const opList = operatorList.getIR();
  expect(opList).toBeNull();
  expect(annotation.appearance).toBeNull();
  expect(annotation.appearance).toBeUndefined();
  expect(annotation.appearance).toBeUndefined();
  expect(annotation.appearance).toBeUndefined();
  expect(annotation.appearance).toBeUndefined();
  expect(annotation.appearance).toBeUndefined();
  expect(annotation.appearance).toBeUndefined();
  expect(annotation.appearance).toBeUndefined();
  expect(annotation.appearance).toBeUndefined();
  expect(annotation.appearance).toBeUndefined();
  expect(annotation.appearance).toBeUndefined();
  expect(annotation.appearance).toBeUndefined();
  expect(annotation.appearance).toBeUndefined();
  expect(annotation.appearance).toBeUndefined();
  expect(annotation.appearance).toBeUndefined();
  expect(annotation.appearance).toBeUndefined();
  expect(annotation.appearance).toBeUndefined();
  expect(annotation.appearance).toBeUndefined();
  expect(annotation.appearance).toBeUndefined();
  expect(annotation.appearance).toBeUndefined();
  expect(annotation.appearance).toBeUndefined();
  expect(annotation.appearance).toBeUndefined();
  expect(annotation.appearance).toBeUndefined();
  expect(annotation.ap