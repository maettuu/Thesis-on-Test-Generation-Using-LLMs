Before you begin:
- Keep going until the job is completely solved — don’t stop halfway.
- If you’re unsure about the behavior, reread the provided patch carefully; do not hallucinate.
- Plan your approach before writing code by reflecting on whether the test truly fails before and passes after.

Issue:
<issue>
[Bug]: Circular references in Form XObjects cause endless loop
### Attach (recommended) or Link to PDF file

[evil_xobjects.pdf](https://github.com/user-attachments/files/19691094/evil_xobjects.pdf)

### Web browser and its version

Chrome 134.0.6998.165 (Official Build) (64-bit) 

### Operating system and its version

Debian GNU/Linux 12.9

### PDF.js version

220a28933c30c34bf32ff0ac9b43fea6649b5ca2

### Is the bug present in the latest PDF.js version?

Yes

### Is a browser extension

No

### Steps to reproduce the problem

1. Load the PDF attached
2. Watch the spinner spin forever

### What is the expected behavior?

Opinions differ on this, and you will see a different number of "Hello world" in different readers:

- Ghostscript shows 3
- Poppler shows 2
- PDFium shows 25 or so

I don't have an Apple handy to see what Preview does...


### What went wrong?

The vaguely malicious (but not really, since browser sandboxing means the worst it'll do is heat up your house a bit) PDF above contains two Form XObjects which reference each other, so invoking one of them leads to an endless loop.

I thought that this was fixed by https://github.com/mozilla/pdf.js/pull/4374 but it appears that fix was specific to circular indirect object references inside the same resources dictionary.

Here the problem only arises when XObjects actually invoke each other in a circular manner.

### Link to a viewer

_No response_

### Additional context

_No response_
</issue>

PDF File:
<pdf>
issue19800.pdf
</pdf>

Patch:
<patch>
diff --git a/src/core/annotation.js b/src/core/annotation.js
--- a/src/core/annotation.js
+++ b/src/core/annotation.js
@@ -49,6 +49,8 @@ import {
   lookupNormalRect,
   lookupRect,
   numberToString,
+  RESOURCES_KEYS_OPERATOR_LIST,
+  RESOURCES_KEYS_TEXT_CONTENT,
   stringToAsciiOrUTF16BE,
   stringToUTF16String,
 } from "./core_utils.js";
@@ -1196,7 +1198,7 @@ class Annotation {
 
     const appearanceDict = appearance.dict;
     const resources = await this.loadResources(
-      ["ExtGState", "ColorSpace", "Pattern", "Shading", "XObject", "Font"],
+      RESOURCES_KEYS_OPERATOR_LIST,
       appearance
     );
     const bbox = lookupRect(appearanceDict.getArray("BBox"), [0, 0, 1, 1]);
@@ -1257,7 +1259,7 @@ class Annotation {
     }
 
     const resources = await this.loadResources(
-      ["ExtGState", "Font", "Properties", "XObject"],
+      RESOURCES_KEYS_TEXT_CONTENT,
       this.appearance
     );

diff --git a/src/core/core_utils.js b/src/core/core_utils.js
--- a/src/core/core_utils.js
+++ b/src/core/core_utils.js
@@ -32,6 +32,23 @@ const MIN_INT_32 = -(2 ** 31);
 
 const IDENTITY_MATRIX = [1, 0, 0, 1, 0, 0];
 
+const RESOURCES_KEYS_OPERATOR_LIST = [
+  "ColorSpace",
+  "ExtGState",
+  "Font",
+  "Pattern",
+  "Properties",
+  "Shading",
+  "XObject",
+];
+
+const RESOURCES_KEYS_TEXT_CONTENT = [
+  "ExtGState",
+  "Font",
+  "Properties",
+  "XObject",
+];
+
 function getLookupTableFactory(initializer) {
   let lookup;
   return function () {
@@ -745,6 +762,8 @@ export {
   readUint16,
   readUint32,
   recoverJsURL,
+  RESOURCES_KEYS_OPERATOR_LIST,
+  RESOURCES_KEYS_TEXT_CONTENT,
   stringToAsciiOrUTF16BE,
   stringToUTF16HexString,
   stringToUTF16String,

diff --git a/src/core/document.js b/src/core/document.js
--- a/src/core/document.js
+++ b/src/core/document.js
@@ -45,6 +45,8 @@ import {
   lookupNormalRect,
   MissingDataException,
   PDF_VERSION_REGEXP,
+  RESOURCES_KEYS_OPERATOR_LIST,
+  RESOURCES_KEYS_TEXT_CONTENT,
   validateCSSFont,
   XRefEntryException,
   XRefParseException,
@@ -419,6 +421,25 @@ class Page {
     await objectLoader.load();
   }
 
+  async #getMergedResources(streamDict, keys) {
+    // In rare cases /Resources are also found in the /Contents stream-dict,
+    // in addition to in the /Page dict, hence we need to prefer those when
+    // available (see issue18894.pdf).
+    const localResources = streamDict?.get("Resources");
+
+    if (!(localResources instanceof Dict)) {
+      return this.resources;
+    }
+    const objectLoader = new ObjectLoader(localResources, keys, this.xref);
+    await objectLoader.load();
+
+    return Dict.merge({
+      xref: this.xref,
+      dictArray: [localResources, this.resources],
+      mergeSubDicts: true,
+    });
+  }
+
   async getOperatorList({
     handler,
     sink,
@@ -429,15 +450,7 @@ class Page {
     modifiedIds = null,
   }) {
     const contentStreamPromise = this.getContentStream();
-    const resourcesPromise = this.loadResources([
-      "ColorSpace",
-      "ExtGState",
-      "Font",
-      "Pattern",
-      "Properties",
-      "Shading",
-      "XObject",
-    ]);
+    const resourcesPromise = this.loadResources(RESOURCES_KEYS_OPERATOR_LIST);
 
     const partialEvaluator = new PartialEvaluator({
       xref: this.xref,
@@ -525,11 +538,15 @@ class Page {
       contentStreamPromise,
       resourcesPromise,
     ]).then(async ([contentStream]) => {
+      const resources = await this.#getMergedResources(
+        contentStream.dict,
+        RESOURCES_KEYS_OPERATOR_LIST
+      );
       const opList = new OperatorList(intent, sink);
 
       handler.send("StartRenderPage", {
         transparency: partialEvaluator.hasBlendModes(
-          this.resources,
+          resources,
           this.nonBlendModesSet
         ),
         pageIndex: this.pageIndex,
@@ -539,7 +556,7 @@ class Page {
       await partialEvaluator.getOperatorList({
         stream: contentStream,
         task,
-        resources: this.resources,
+        resources,
         operatorList: opList,
       });
       return opList;
@@ -642,12 +659,7 @@ class Page {
     sink,
   }) {
     const contentStreamPromise = this.getContentStream();
-    const resourcesPromise = this.loadResources([
-      "ExtGState",
-      "Font",
-      "Properties",
-      "XObject",
-    ]);
+    const resourcesPromise = this.loadResources(RESOURCES_KEYS_TEXT_CONTENT);
     const langPromise = this.pdfManager.ensureCatalog("lang");
 
     const [contentStream, , lang] = await Promise.all([
@@ -655,6 +667,11 @@ class Page {
       resourcesPromise,
       langPromise,
     ]);
+    const resources = await this.#getMergedResources(
+      contentStream.dict,
+      RESOURCES_KEYS_TEXT_CONTENT
+    );
+
     const partialEvaluator = new PartialEvaluator({
       xref: this.xref,
       handler,
@@ -672,7 +689,7 @@ class Page {
     return partialEvaluator.getTextContent({
       stream: contentStream,
       task,
-      resources: this.resources,
+      resources,
       includeMarkedContent,
       disableNormalization,
       sink,

diff --git a/src/core/evaluator.js b/src/core/evaluator.js
--- a/src/core/evaluator.js
+++ b/src/core/evaluator.js
@@ -462,7 +462,8 @@ class PartialEvaluator {
     operatorList,
     task,
     initialState,
-    localColorSpaceCache
+    localColorSpaceCache,
+    seenRefs
   ) {
     const dict = xobj.dict;
     const matrix = lookupMatrix(dict.getArray("Matrix"), null);
@@ -526,6 +527,7 @@ class PartialEvaluator {
       resources: dict.get("Resources") || resources,
       operatorList,
       initialState,
+      prevRefs: seenRefs,
     });
     operatorList.addOp(OPS.paintFormXObjectEnd, []);
 
@@ -850,7 +852,8 @@ class PartialEvaluator {
     operatorList,
     task,
     stateManager,
-    localColorSpaceCache
+    localColorSpaceCache,
+    seenRefs
   ) {
     const smaskContent = smask.get("G");
     const smaskOptions = {
@@ -880,7 +883,8 @@ class PartialEvaluator {
       operatorList,
       task,
       stateManager.state.clone({ newPath: true }),
-      localColorSpaceCache
+      localColorSpaceCache,
+      seenRefs
     );
   }
 
@@ -1065,6 +1069,7 @@ class PartialEvaluator {
     stateManager,
     localGStateCache,
     localColorSpaceCache,
+    seenRefs,
   }) {
     const gStateRef = gState.objId;
     let isSimpleGState = true;
@@ -1127,7 +1132,8 @@ class PartialEvaluator {
                 operatorList,
                 task,
                 stateManager,
-                localColorSpaceCache
+                localColorSpaceCache,
+                seenRefs
               )
             );
             gStateObj.push([key, true]);
@@ -1696,7 +1702,19 @@ class PartialEvaluator {
     operatorList,
     initialState = null,
     fallbackFontDict = null,
+    prevRefs = null,
   }) {
+    const objId = stream.dict?.objId;
+    const seenRefs = new RefSet(prevRefs);
+
+    if (objId) {
+      if (prevRefs?.has(objId)) {
+        throw new Error(
+          `getOperatorList - ignoring circular reference: ${objId}`
+        );
+      }
+      seenRefs.put(objId);
+    }
     // Ensure that `resources`/`initialState` is correctly initialized,
     // even if the provided parameter is e.g. `null`.
     resources ||= Dict.empty;
@@ -1808,7 +1826,8 @@ class PartialEvaluator {
                       operatorList,
                       task,
                       stateManager.state.clone({ newPath: true }),
-                      localColorSpaceCache
+                      localColorSpaceCache,
+                      seenRefs
                     )
                     .then(function () {
                       stateManager.restore();
@@ -2158,6 +2177,7 @@ class PartialEvaluator {
                     stateManager,
                     localGStateCache,
                     localColorSpaceCache,
+                    seenRefs,
                   })
                   .then(resolveGState, rejectGState);
               }).catch(function (reason) {
@@ -2339,7 +2359,19 @@ class PartialEvaluator {
     markedContentData = null,
     disableNormalization = false,
     keepWhiteSpace = false,
+    prevRefs = null,
   }) {
+    const objId = stream.dict?.objId;
+    const seenRefs = new RefSet(prevRefs);
+
+    if (objId) {
+      if (prevRefs?.has(objId)) {
+        throw new Error(
+          `getTextContent - ignoring circular reference: ${objId}`
+        );
+      }
+      seenRefs.put(objId);
+    }
     // Ensure that `resources`/`stateManager` is correctly initialized,
     // even if the provided parameter is e.g. `null`.
     resources ||= Dict.empty;
@@ -3326,6 +3358,7 @@ class PartialEvaluator {
                     markedContentData,
                     disableNormalization,
                     keepWhiteSpace,
+                    prevRefs: seenRefs,
                   })
                   .then(function () {
                     if (!sinkWrapper.enqueueInvoked) {


</patch>

Imports:
<imports>
Available Packages
Dev Dependencies:
- @babel/core: ^7.26.10
- @babel/preset-env: ^7.26.9
- @babel/runtime: ^7.27.0
- @fluent/bundle: ^0.19.0
- @fluent/dom: ^0.10.1
- @metalsmith/layouts: ^3.0.0
- @metalsmith/markdown: ^1.10.0
- @napi-rs/canvas: ^0.1.68
- @types/node: ^22.13.14
- autoprefixer: ^10.4.21
- babel-loader: ^10.0.0
- caniuse-lite: ^1.0.30001707
- core-js: ^3.41.0
- eslint: ^9.23.0
- eslint-plugin-import: ^2.31.0
- eslint-plugin-jasmine: ^4.2.2
- eslint-plugin-json: ^4.0.1
- eslint-plugin-no-unsanitized: ^4.1.2
- eslint-plugin-perfectionist: ^4.10.1
- eslint-plugin-prettier: ^5.2.5
- eslint-plugin-unicorn: ^58.0.0
- globals: ^16.0.0
- gulp: ^5.0.0
- gulp-cli: ^3.0.0
- gulp-postcss: ^10.0.0
- gulp-rename: ^2.0.0
- gulp-replace: ^1.1.4
- gulp-zip: ^6.1.0
- highlight.js: ^11.11.1
- jasmine: ^5.6.0
- jsdoc: ^4.0.4
- jstransformer-nunjucks: ^1.2.0
- metalsmith: ^2.6.3
- metalsmith-html-relative: ^2.0.6
- ordered-read-streams: ^2.0.0
- pngjs: ^7.0.0
- postcss: ^8.5.3
- postcss-dark-theme-class: ^1.3.0
- postcss-dir-pseudo-class: ^9.0.1
- postcss-discard-comments: ^7.0.3
- postcss-nesting: ^13.0.1
- prettier: ^3.5.3
- puppeteer: ^24.4.0
- stylelint: ^16.17.0
- stylelint-prettier: ^5.0.3
- svglint: ^3.1.0
- terser-webpack-plugin: ^5.3.14
- tsc-alias: ^1.8.13
- ttest: ^4.0.0
- typescript: ^5.8.2
- vinyl: ^3.0.0
- webpack: ^5.98.0
- webpack-stream: ^7.0.0
- yargs: ^17.7.2

Engines:
- node: >=20.16.0

Available Relative Imports:
- `../../src/core/annotation.js`: Annotation, AnnotationBorderStyle, AnnotationFactory, MarkupAnnotation, getQuadPoints
- `../../src/core/bidi.js`: bidi
- `../../src/core/calculate_md5.js`: calculateMD5
- `../../src/core/calculate_sha256.js`: calculateSHA256
- `../../src/core/calculate_sha_other.js`: calculateSHA384, calculateSHA512
- `../../src/core/cff_parser.js`: CFFCharset, CFFCompiler, CFFFDSelect, CFFParser, CFFStrings
- `../../src/core/cmap.js`: CMap, CMapFactory, IdentityCMap
- `../../src/core/colorspace.js`: ColorSpace
- `../../src/core/colorspace_utils.js`: ColorSpaceUtils
- `../../src/core/core_utils.js`: arrayBuffersToBytes, encodeToXmlString, escapePDFName, escapeString, getInheritableProperty, getSizeInBytes, isAscii, isWhiteSpace, log2, numberToString, parseXFAPath, recoverJsURL, stringToUTF16HexString, stringToUTF16String, toRomanNumerals, validateCSSFont
- `../../src/core/crypto.js`: AES128Cipher, AES256Cipher, ARCFourCipher, CipherTransformFactory, PDF17, PDF20
- `../../src/core/default_appearance.js`: createDefaultAppearance, parseAppearanceStream, parseDefaultAppearance
- `../../src/core/document.js`: PDFDocument, Page
- `../../src/core/encodings.js`: getEncoding
- `../../src/core/evaluator.js`: PartialEvaluator
- `../../src/core/flate_stream.js`: FlateStream
- `../../src/core/font_substitutions.js`: getFontSubstitution
- `../../src/core/fonts_utils.js`: SEAC_ANALYSIS_ENABLED
- `../../src/core/function.js`: PDFFunctionFactory, PostScriptCompiler, PostScriptEvaluator
- `../../src/core/glyphlist.js`: getDingbatsGlyphsUnicode, getGlyphsUnicode
- `../../src/core/image_utils.js`: GlobalColorSpaceCache, GlobalImageCache, LocalColorSpaceCache
- `../../src/core/jbig2.js`: Jbig2Error, Jbig2Image
- `../../src/core/jpg.js`: JpegError, JpegImage
- `../../src/core/jpx.js`: JpxError, JpxImage
- `../../src/core/metadata_parser.js`: MetadataParser
- `../../src/core/operator_list.js`: OperatorList
- `../../src/core/parser.js`: Lexer, Linearization, Parser
- `../../src/core/predictor_stream.js`: PredictorStream
- `../../src/core/primitives.js`: Cmd, Dict, EOF, Name, Ref, RefSet, RefSetCache, isCmd, isDict, isName, isRefsEqual
- `../../src/core/ps_parser.js`: PostScriptLexer, PostScriptParser
- `../../src/core/stream.js`: NullStream, Stream, StringStream
- `../../src/core/type1_parser.js`: Type1Parser
- `../../src/core/unicode.js`: getCharUnicodeCategory, getUnicodeForGlyph, getUnicodeRangeFor, mapSpecialUnicodeValues
- `../../src/core/worker.js`: WorkerMessageHandler, WorkerTask
- `../../src/core/writer.js`: incrementalUpdate, writeChanges, writeDict
- `../../src/core/xfa/bind.js`: Binder
- `../../src/core/xfa/data.js`: DataHandler
- `../../src/core/xfa/factory.js`: XFAFactory
- `../../src/core/xfa/formcalc_lexer.js`: Lexer, TOKEN, Token
- `../../src/core/xfa/formcalc_parser.js`: Errors, Parser
- `../../src/core/xfa/parser.js`: XFAParser
- `../../src/core/xfa/som.js`: searchNode
- `../../src/core/xfa/symbol_utils.js`: $dump, $getChildren, $getChildrenByClass, $getChildrenByName, $text, $uid
- `../../src/core/xml_parser.js`: SimpleXMLParser, XMLParserBase
- `../../src/display/annotation_layer.js`: AnnotationLayer
- `../../src/display/annotation_storage.js`: AnnotationStorage
- `../../src/display/api.js`: LoopbackPort, PDFDataRangeTransport, PDFDocumentLoadingTask, PDFDocumentProxy, PDFPageProxy, PDFWorker, RenderTask, build, getDocument, isValidExplicitDest, version
- `../../src/display/canvas_factory.js`: DOMCanvasFactory
- `../../src/display/cmap_reader_factory.js`: DOMCMapReaderFactory
- `../../src/display/display_utils.js`: OutputScale, PDFDateString, PageViewport, PixelsPerInch, RenderingCancelledException, StatTimer, SupportedImageMimeTypes, fetchData, getFilenameFromUrl, getPdfFilenameFromUrl, getXfaPageViewport, isDataScheme, isPdfFile, isValidFetchUrl, noContextMenu, setLayerDimensions, stopEvent
- `../../src/display/draw_layer.js`: DrawLayer
- `../../src/display/editor/annotation_editor_layer.js`: AnnotationEditorLayer
- `../../src/display/editor/color_picker.js`: ColorPicker
- `../../src/display/editor/drawers/signaturedraw.js`: SignatureExtractor
- `../../src/display/editor/tools.js`: AnnotationEditorUIManager, CommandManager
- `../../src/display/fetch_stream.js`: PDFFetchStream
- `../../src/display/metadata.js`: Metadata
- `../../src/display/network.js`: PDFNetworkStream
- `../../src/display/network_utils.js`: createHeaders, createResponseError, extractFilenameFromHeader, validateRangeRequestCapabilities, validateResponseStatus
- `../../src/display/node_stream.js`: PDFNodeStream
- `../../src/display/node_utils.js`: NodeCMapReaderFactory, NodeStandardFontDataFactory, fetchData
- `../../src/display/standard_fontdata_factory.js`: DOMStandardFontDataFactory
- `../../src/display/svg_factory.js`: DOMSVGFactory
- `../../src/display/text_layer.js`: TextLayer
- `../../src/display/touch_manager.js`: TouchManager
- `../../src/display/worker_options.js`: GlobalWorkerOptions
- `../../src/display/xfa_layer.js`: XfaLayer
- `../../src/shared/message_handler.js`: MessageHandler
- `../../src/shared/murmurhash3.js`: MurmurHash3_64
- `../../src/shared/util.js`: AbortException, AnnotationBorderStyleType, AnnotationEditorParamsType, AnnotationEditorType, AnnotationFieldFlag, AnnotationFlag, AnnotationMode, AnnotationType, BaseException, DrawOPS, FeatureTest, FormatError, ImageKind, InvalidPDFException, MathClamp, OPS, PasswordException, PasswordResponses, PermissionFlag, RenderingIntentFlag, ResponseException, UnknownErrorException, Util, VerbosityLevel, assert, bytesToString, createValidAbsoluteUrl, getModificationDate, getUuid, getVerbosityLevel, isNodeJS, normalizeUnicode, objectSize, setVerbosityLevel, shadow, string32, stringToBytes, stringToPDFString, stringToUTF8String, toBase64Util
- `../../web/annotation_layer_builder.js`: AnnotationLayerBuilder
- `../../web/app_options.js`: AppOptions, OptionKind
- `../../web/autolinker.js`: Autolinker
- `../../web/download_manager.js`: DownloadManager
- `../../web/event_utils.js`: EventBus, WaitOnType, waitOnEventOrTimeout
- `../../web/genericl10n.js`: GenericL10n
- `../../web/pdf_find_controller.js`: FindState, PDFFindController
- `../../web/pdf_find_utils.js`: CharacterType, getCharacterType
- `../../web/pdf_history.js`: PDFHistory, isDestArraysEqual, isDestHashesEqual
- `../../web/pdf_link_service.js`: LinkTarget, PDFLinkService, SimpleLinkService
- `../../web/pdf_page_view.js`: PDFPageView
- `../../web/pdf_scripting_manager.component.js`: PDFScriptingManager
- `../../web/pdf_single_page_viewer.js`: PDFSinglePageViewer
- `../../web/pdf_viewer.js`: PDFPageViewBuffer, PDFViewer
- `../../web/struct_tree_layer_builder.js`: StructTreeLayerBuilder
- `../../web/text_layer_builder.js`: TextLayerBuilder
- `../../web/ui_utils.js`: AutoPrintRegExp, ProgressBar, RenderingStates, ScrollMode, SpreadMode, backtrackBeforeAllVisibleElements, binarySearchFirstItem, calcRound, getPageSizeInches, getVisibleElements, isPortraitOrientation, isValidRotation, parseQueryString, removeNullCharacters
- `../../web/xfa_layer_builder.js`: XfaLayerBuilder
- `../reporter.js`: TestReporter
- `./common_pdfstream_tests.js`: testCrossOriginRedirects
- `./test_utils.js`: CMAP_URL, DefaultCMapReaderFactory, DefaultFileReaderFactory, DefaultStandardFontDataFactory, STANDARD_FONT_DATA_URL, TEST_PDFS_PATH, TestPdfsServer, XRefMock, buildGetDocumentParams, createIdFactory, getCrossOriginHostname
</imports>

Code:
<code>
File:
src/core/annotation.js
1 /* Copyright 2012 Mozilla Foundation
2  *
3  * Licensed under the Apache License, Version 2.0 (the "License");
4  * you may not use this file except in compliance with the License.
5  * You may obtain a copy of the License at
6  *
7  *     http://www.apache.org/licenses/LICENSE-2.0
8  *
9  * Unless required by applicable law or agreed to in writing, software
10  * distributed under the License is distributed on an "AS IS" BASIS,
11  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
12  * See the License for the specific language governing permissions and
13  * limitations under the License.
14  */
15 
16 import {
17   AnnotationActionEventType,
18   AnnotationBorderStyleType,
19   AnnotationEditorType,
20   AnnotationFieldFlag,
21   AnnotationFlag,
22   AnnotationReplyType,
23   AnnotationType,
24   assert,
25   BASELINE_FACTOR,
26   FeatureTest,
27   getModificationDate,
28   info,
29   isArrayEqual,
30   LINE_DESCENT_FACTOR,
31   LINE_FACTOR,
32   OPS,
33   RenderingIntentFlag,
34   shadow,
35   stringToPDFString,
36   unreachable,
37   Util,
38   warn,
39 } from "../shared/util.js";
40 import {
41   collectActions,
42   escapeString,
43   getInheritableProperty,
44   getParentToUpdate,
45   getRotationMatrix,
46   IDENTITY_MATRIX,
47   isNumberArray,
48   lookupMatrix,
49   lookupNormalRect,
50   lookupRect,
51   numberToString,
52   stringToAsciiOrUTF16BE,
53   stringToUTF16String,
54 } from "./core_utils.js";
55 import {
56   createDefaultAppearance,
57   FakeUnicodeFont,
58   getPdfColor,
59   parseAppearanceStream,
60   parseDefaultAppearance,
61 } from "./default_appearance.js";
62 import { Dict, isName, isRefsEqual, Name, Ref, RefSet } from "./primitives.js";
63 import { Stream, StringStream } from "./stream.js";
64 import { BaseStream } from "./base_stream.js";
65 import { bidi } from "./bidi.js";
66 import { Catalog } from "./catalog.js";
67 import { ColorSpaceUtils } from "./colorspace_utils.js";
68 import { FileSpec } from "./file_spec.js";
69 import { JpegStream } from "./jpeg_stream.js";
70 import { ObjectLoader } from "./object_loader.js";
71 import { OperatorList } from "./operator_list.js";
72 import { XFAFactory } from "./xfa/factory.js";
73 
74 class AnnotationFactory {
75   static createGlobals(pdfManager) {
76     return Promise.all([
77       pdfManager.ensureCatalog("acroForm"),
78       pdfManager.ensureDoc("xfaDatasets"),
79       pdfManager.ensureCatalog("structTreeRoot"),
80       // Only necessary to prevent the `Catalog.baseUrl`-getter, used
81       // with some Annotations, from throwing and thus breaking parsing:
82       pdfManager.ensureCatalog("baseUrl"),
83       // Only necessary to prevent the `Catalog.attachments`-getter, used
84       // with "GoToE" actions, from throwing and thus breaking parsing:
85       pdfManager.ensureCatalog("attachments"),
86       pdfManager.ensureCatalog("globalColorSpaceCache"),
87     ]).then(
88       ([
89         acroForm,
90         xfaDatasets,
91         structTreeRoot,
92         baseUrl,
93         attachments,
94         globalColorSpaceCache,
95       ]) => ({
96         pdfManager,
97         acroForm: acroForm instanceof Dict ? acroForm : Dict.empty,
98         xfaDatasets,
99         structTreeRoot,
100         baseUrl,
101         attachments,
102         globalColorSpaceCache,
103       }),
104       reason => {
105         warn(`createGlobals: "${reason}".`);
106         return null;
107       }
108     );
109   }
110 
111   /**
112    * Create an `Annotation` object of the correct type for the given reference
113    * to an annotation dictionary. This yields a promise that is resolved when
114    * the `Annotation` object is constructed.
115    *
116    * @param {XRef} xref
117    * @param {Object} ref
118    * @params {Object} annotationGlobals
119    * @param {Object} idFactory
120    * @param {boolean} [collectFields]
121    * @param {Object} [orphanFields]
122    * @param {Object} [pageRef]
123    * @returns {Promise} A promise that is resolved with an {Annotation}
124    *   instance.
125    */
126   static async create(
127     xref,
128     ref,
129     annotationGlobals,
130     idFactory,
131     collectFields,
132     orphanFields,
133     pageRef
134   ) {
135     const pageIndex = collectFields
136       ? await this._getPageIndex(xref, ref, annotationGlobals.pdfManager)
137       : null;
138 
139     return annotationGlobals.pdfManager.ensure(this, "_create", [
140       xref,
141       ref,
142       annotationGlobals,
143       idFactory,
144       collectFields,
145       orphanFields,
146       pageIndex,
147       pageRef,
148     ]);
149   }
150 
151   /**
152    * @private
153    */
154   static _create(
155     xref,
156     ref,
157     annotationGlobals,
158     idFactory,
159     collectFields = false,
160     orphanFields = null,
161     pageIndex = null,
162     pageRef = null
163   ) {
164     const dict = xref.fetchIfRef(ref);
165     if (!(dict instanceof Dict)) {
166       return undefined;
167     }
168 
169     const { acroForm, pdfManager } = annotationGlobals;
170     const id =
171       ref instanceof Ref ? ref.toString() : `annot_${idFactory.createObjId()}`;
172 
173     // Determine the annotation's subtype.
174     let subtype = dict.get("Subtype");
175     subtype = subtype instanceof Name ? subtype.name : null;
176 
177     // Return the right annotation object based on the subtype and field type.
178     const parameters = {
179       xref,
180       ref,
181       dict,
182       subtype,
183       id,
184       annotationGlobals,
185       collectFields,
186       orphanFields,
187       needAppearances:
188         !collectFields && acroForm.get("NeedAppearances") === true,
189       pageIndex,
190       evaluatorOptions: pdfManager.evaluatorOptions,
191       pageRef,
192     };
193 
194     switch (subtype) {
195       case "Link":
196         return new LinkAnnotation(parameters);
197 
198       case "Text":
199         return new TextAnnotation(parameters);
200 
201       case "Widget":
202         let fieldType = getInheritableProperty({ dict, key: "FT" });
203         fieldType = fieldType instanceof Name ? fieldType.name : null;
204 
205         switch (fieldType) {
206           case "Tx":
207             return new TextWidgetAnnotation(parameters);
208           case "Btn":
209             return new ButtonWidgetAnnotation(parameters);
210           case "Ch":
211             return new ChoiceWidgetAnnotation(parameters);
212           case "Sig":
213             return new SignatureWidgetAnnotation(parameters);
214         }
215         warn(
216           `Unimplemented widget field type "${fieldType}", ` +
217             "falling back to base field type."
218         );
219         return new WidgetAnnotation(parameters);
220 
221       case "Popup":
222         return new PopupAnnotation(parameters);
223 
224       case "FreeText":
225         return new FreeTextAnnotation(parameters);
226 
227       case "Line":
228         return new LineAnnotation(parameters);
229 
230       case "Square":
231         return new SquareAnnotation(parameters);
232 
233       case "Circle":
234         return new CircleAnnotation(parameters);
235 
236       case "PolyLine":
237         return new PolylineAnnotation(parameters);
238 
239       case "Polygon":
240         return new PolygonAnnotation(parameters);
241 
242       case "Caret":
243         return new CaretAnnotation(parameters);
244 
245       case "Ink":
246         return new InkAnnotation(parameters);
247 
248       case "Highlight":
249         return new HighlightAnnotation(parameters);
250 
251       case "Underline":
252         return new UnderlineAnnotation(parameters);
253 
254       case "Squiggly":
255         return new SquigglyAnnotation(parameters);
256 
257       case "StrikeOut":
258         return new StrikeOutAnnotation(parameters);
259 
260       case "Stamp":
261         return new StampAnnotation(parameters);
262 
263       case "FileAttachment":
264         return new FileAttachmentAnnotation(parameters);
265 
266       default:
267         if (!collectFields) {
268           if (!subtype) {
269             warn("Annotation is missing the required /Subtype.");
270           } else {
271             warn(
272               `Unimplemented annotation type "${subtype}", ` +
273                 "falling back to base annotation."
274             );
275           }
276         }
277         return new Annotation(parameters);
278     }
279   }
280 
281   static async _getPageIndex(xref, ref, pdfManager) {
282     try {
283       const annotDict = await xref.fetchIfRefAsync(ref);
284       if (!(annotDict instanceof Dict)) {
285         return -1;
286       }
287       const pageRef = annotDict.getRaw("P");
288       if (pageRef instanceof Ref) {
289         try {
290           const pageIndex = await pdfManager.ensureCatalog("getPageIndex", [
291             pageRef,
292           ]);
293           return pageIndex;
294         } catch (ex) {
295           info(`_getPageIndex -- not a valid page reference: "${ex}".`);
296         }
297       }
298       if (annotDict.has("Kids")) {
299         return -1; // Not an annotation reference.
300       }
301       // Fallback to, potentially, checking the annotations of all pages.
302       // PLEASE NOTE: This could force the *entire* PDF document to load,
303       //              hence it absolutely cannot be done unconditionally.
304       const numPages = await pdfManager.ensureDoc("numPages");
305 
306       for (let pageIndex = 0; pageIndex < numPages; pageIndex++) {
307         const page = await pdfManager.getPage(pageIndex);
308         const annotations = await pdfManager.ensure(page, "annotations");
309 
310         for (const annotRef of annotations) {
311           if (annotRef instanceof Ref && isRefsEqual(annotRef, ref)) {
312             return pageIndex;
313           }
314         }
315       }
316     } catch (ex) {
317       warn(`_getPageIndex: "${ex}".`);
318     }
319     return -1;
320   }
321 
322   static generateImages(annotations, xref, isOffscreenCanvasSupported) {
323     if (!isOffscreenCanvasSupported) {
324       warn(
325         "generateImages: OffscreenCanvas is not supported, cannot save or print some annotations with images."
326       );
327       return null;
328     }
329     let imagePromises;
330     for (const { bitmapId, bitmap } of annotations) {
331       if (!bitmap) {
332         continue;
333       }
334       imagePromises ||= new Map();
335       imagePromises.set(bitmapId, StampAnnotation.createImage(bitmap, xref));
336     }
337 
338     return imagePromises;
339   }
340 
341   static async saveNewAnnotations(
342     evaluator,
343     task,
344     annotations,
345     imagePromises,
346     changes
347   ) {
348     const xref = evaluator.xref;
349     let baseFontRef;
350     const promises = [];
351     const { isOffscreenCanvasSupported } = evaluator.options;
352 
353     for (const annotation of annotations) {
354       if (annotation.deleted) {
355         continue;
356       }
357       switch (annotation.annotationType) {
358         case AnnotationEditorType.FREETEXT:
359           if (!baseFontRef) {
360             const baseFont = new Dict(xref);
361             baseFont.set("BaseFont", Name.get("Helvetica"));
362             baseFont.set("Type", Name.get("Font"));
363             baseFont.set("Subtype", Name.get("Type1"));
364             baseFont.set("Encoding", Name.get("WinAnsiEncoding"));
365             baseFontRef = xref.getNewTemporaryRef();
366             changes.put(baseFontRef, {
367               data: baseFont,
368             });
369           }
370           promises.push(
371             FreeTextAnnotation.createNewAnnotation(xref, annotation, changes, {
372               evaluator,
373               task,
374               baseFontRef,
375             })
376           );
377           break;
378         case AnnotationEditorType.HIGHLIGHT:
379           if (annotation.quadPoints) {
380             promises.push(
381               HighlightAnnotation.createNewAnnotation(xref, annotation, changes)
382             );
383           } else {
384             promises.push(
385               InkAnnotation.createNewAnnotation(xref, annotation, changes)
386             );
387           }
388           break;
389         case AnnotationEditorType.INK:
390           promises.push(
391             InkAnnotation.createNewAnnotation(xref, annotation, changes)
392           );
393           break;
394         case AnnotationEditorType.STAMP:
395           const image = isOffscreenCanvasSupported
396             ? await imagePromises?.get(annotation.bitmapId)
397             : null;
398           if (image?.imageStream) {
399             const { imageStream, smaskStream } = image;
400             if (smaskStream) {
401               const smaskRef = xref.getNewTemporaryRef();
402               changes.put(smaskRef, {
403                 data: smaskStream,
404               });
405               imageStream.dict.set("SMask", smaskRef);
406             }
407             const imageRef = (image.imageRef = xref.getNewTemporaryRef());
408             changes.put(imageRef, {
409               data: imageStream,
410             });
411             image.imageStream = image.smaskStream = null;
412           }
413           promises.push(
414             StampAnnotation.createNewAnnotation(xref, annotation, changes, {
415               image,
416             })
417           );
418           break;
419         case AnnotationEditorType.SIGNATURE:
420           promises.push(
421             StampAnnotation.createNewAnnotation(xref, annotation, changes, {})
422           );
423           break;
424       }
425     }
426 
427     return {
428       annotations: await Promise.all(promises),
429     };
430   }
431 
432   static async printNewAnnotations(
433     annotationGlobals,
434     evaluator,
435     task,
436     annotations,
437     imagePromises
438   ) {
439     if (!annotations) {
440       return null;
441     }
442 
443     const { options, xref } = evaluator;
444     const promises = [];
445     for (const annotation of annotations) {
446       if (annotation.deleted) {
447         continue;
448       }
449       switch (annotation.annotationType) {
450         case AnnotationEditorType.FREETEXT:
451           promises.push(
452             FreeTextAnnotation.createNewPrintAnnotation(
453               annotationGlobals,
454               xref,
455               annotation,
456               {
457                 evaluator,
458                 task,
459                 evaluatorOptions: options,
460               }
461             )
462           );
463           break;
464         case AnnotationEditorType.HIGHLIGHT:
465           if (annotation.quadPoints) {
466             promises.push(
467               HighlightAnnotation.createNewPrintAnnotation(
468                 annotationGlobals,
469                 xref,
470                 annotation,
471                 {
472                   evaluatorOptions: options,
473                 }
474               )
475             );
476           } else {
477             promises.push(
478               InkAnnotation.createNewPrintAnnotation(
479                 annotationGlobals,
480                 xref,
481                 annotation,
482                 {
483                   evaluatorOptions: options,
484                 }
485               )
486             );
487           }
488           break;
489         case AnnotationEditorType.INK:
490           promises.push(
491             InkAnnotation.createNewPrintAnnotation(
492               annotationGlobals,
493               xref,
494               annotation,
495               {
496                 evaluatorOptions: options,
497               }
498             )
499           );
500           break;
501         case AnnotationEditorType.STAMP:
502           const image = options.isOffscreenCanvasSupported
503             ? await imagePromises?.get(annotation.bitmapId)
504             : null;
505           if (image?.imageStream) {
506             const { imageStream, smaskStream } = image;
507             if (smaskStream) {
508               imageStream.dict.set("SMask", smaskStream);
509             }
510             image.imageRef = new JpegStream(imageStream, imageStream.length);
511             image.imageStream = image.smaskStream = null;
512           }
513           promises.push(
514             StampAnnotation.createNewPrintAnnotation(
515               annotationGlobals,
516               xref,
517               annotation,
518               {
519                 image,
520                 evaluatorOptions: options,
521               }
522             )
523           );
524           break;
525         case AnnotationEditorType.SIGNATURE:
526           promises.push(
527             StampAnnotation.createNewPrintAnnotation(
528               annotationGlobals,
529               xref,
530               annotation,
531               {
532                 evaluatorOptions: options,
533               }
534             )
535           );
536           break;
537       }
538     }
539 
540     return Promise.all(promises);
541   }
542 }
543 
544 function getRgbColor(color, defaultColor = new Uint8ClampedArray(3)) {
545   if (!Array.isArray(color)) {
546     return defaultColor;
547   }
548 
549   const rgbColor = defaultColor || new Uint8ClampedArray(3);
550   switch (color.length) {
551     case 0: // Transparent, which we indicate with a null value
552       return null;
553 
554     case 1: // Convert grayscale to RGB
555       ColorSpaceUtils.gray.getRgbItem(color, 0, rgbColor, 0);
556       return rgbColor;
557 
558     case 3: // Convert RGB percentages to RGB
559       ColorSpaceUtils.rgb.getRgbItem(color, 0, rgbColor, 0);
560       return rgbColor;
561 
562     case 4: // Convert CMYK to RGB
563       ColorSpaceUtils.cmyk.getRgbItem(color, 0, rgbColor, 0);
564       return rgbColor;
565 
566     default:
567       return defaultColor;
568   }
569 }
570 
571 function getPdfColorArray(color) {
572   return Array.from(color, c => c / 255);
573 }
574 
575 function getQuadPoints(dict, rect) {
576   // The region is described as a number of quadrilaterals.
577   // Each quadrilateral must consist of eight coordinates.
578   const quadPoints = dict.getArray("QuadPoints");
579   if (
580     !isNumberArray(quadPoints, null) ||
581     quadPoints.length === 0 ||
582     quadPoints.length % 8 > 0
583   ) {
584     return null;
585   }
586 
587   const newQuadPoints = new Float32Array(quadPoints.length);
588   for (let i = 0, ii = quadPoints.length; i < ii; i += 8) {
589     // Each series of eight numbers represents the coordinates for one
590     // quadrilateral in the order [x1, y1, x2, y2, x3, y3, x4, y4].
591     // Convert this to an array of objects with x and y coordinates.
592     const [x1, y1, x2, y2, x3, y3, x4, y4] = quadPoints.slice(i, i + 8);
593     const minX = Math.min(x1, x2, x3, x4);
594     const maxX = Math.max(x1, x2, x3, x4);
595     const minY = Math.min(y1, y2, y3, y4);
596     const maxY = Math.max(y1, y2, y3, y4);
597     // The quadpoints should be ignored if any coordinate in the array
598     // lies outside the region specified by the rectangle. The rectangle
599     // can be `null` for markup annotations since their rectangle may be
600     // incorrect (fixes bug 1538111).
601     if (
602       rect !== null &&
603       (minX < rect[0] || maxX > rect[2] || minY < rect[1] || maxY > rect[3])
604     ) {
605       return null;
606     }
607     // The PDF specification states in section 12.5.6.10 (figure 64) that the
608     // order of the quadpoints should be bottom left, bottom right, top right
609     // and top left. However, in practice PDF files use a different order,
610     // namely bottom left, bottom right, top left and top right (this is also
611     // mentioned on https://github.com/highkite/pdfAnnotate#QuadPoints), so
612     // this is the actual order we should work with. However, the situation is
613     // even worse since Adobe's own applications and other applications violate
614     // the specification and create annotations with other orders, namely top
615     // left, top right, bottom left and bottom right or even top left,
616     // top right, bottom right and bottom left. To avoid inconsistency and
617     // broken rendering, we normalize all lists to put the quadpoints in the
618     // same standard order (see https://stackoverflow.com/a/10729881).
619     newQuadPoints.set([minX, maxY, maxX, maxY, minX, minY, maxX, minY], i);
620   }
621   return newQuadPoints;
622 }
623 
624 function getTransformMatrix(rect, bbox, matrix) {
625   // 12.5.5: Algorithm: Appearance streams
626   const minMax = new Float32Array([Infinity, Infinity, -Infinity, -Infinity]);
627   Util.axialAlignedBoundingBox(bbox, matrix, minMax);
628   const [minX, minY, maxX, maxY] = minMax;
629   if (minX === maxX || minY === maxY) {
630     // From real-life file, bbox was [0, 0, 0, 0]. In this case,
631     // just apply the transform for rect
632     return [1, 0, 0, 1, rect[0], rect[1]];
633   }
634 
635   const xRatio = (rect[2] - rect[0]) / (maxX - minX);
636   const yRatio = (rect[3] - rect[1]) / (maxY - minY);
637   return [
638     xRatio,
639     0,
640     0,
641     yRatio,
642     rect[0] - minX * xRatio,
643     rect[1] - minY * yRatio,
644   ];
645 }
646 
647 class Annotation {
648   constructor(params) {
649     const { dict, xref, annotationGlobals, ref, orphanFields } = params;
650     const parentRef = orphanFields?.get(ref);
651     if (parentRef) {
652       dict.set("Parent", parentRef);
653     }
654 
655     this.setTitle(dict.get("T"));
656     this.setContents(dict.get("Contents"));
657     this.setModificationDate(dict.get("M"));
658     this.setFlags(dict.get("F"));
659     this.setRectangle(dict.getArray("Rect"));
660     this.setColor(dict.getArray("C"));
661     this.setBorderStyle(dict);
662     this.setAppearance(dict);
663     this.setOptionalContent(dict);
664 
665     const MK = dict.get("MK");
666     this.setBorderAndBackgroundColors(MK);
667     this.setRotation(MK, dict);
668     this.ref = params.ref instanceof Ref ? params.ref : null;
669 
670     this._streams = [];
671     if (this.appearance) {
672       this._streams.push(this.appearance);
673     }
674 
675     // The annotation cannot be changed (neither its position/visibility nor its
676     // contents), hence we can just display its appearance and don't generate
677     // a HTML element for it.
678     const isLocked = !!(this.flags & AnnotationFlag.LOCKED);
679     const isContentLocked = !!(this.flags & AnnotationFlag.LOCKEDCONTENTS);
680 
681     // Expose public properties using a data object.
682     this.data = {
683       annotationFlags: this.flags,
684       borderStyle: this.borderStyle,
685       color: this.color,
686       backgroundColor: this.backgroundColor,
687       borderColor: this.borderColor,
688       rotation: this.rotation,
689       contentsObj: this._contents,
690       hasAppearance: !!this.appearance,
691       id: params.id,
692       modificationDate: this.modificationDate,
693       rect: this.rectangle,
694       subtype: params.subtype,
695       hasOwnCanvas: false,
696       noRotate: !!(this.flags & AnnotationFlag.NOROTATE),
697       noHTML: isLocked && isContentLocked,
698       isEditable: false,
699       structParent: -1,
700     };
701 
702     if (annotationGlobals.structTreeRoot) {
703       let structParent = dict.get("StructParent");
704       this.data.structParent = structParent =
705         Number.isInteger(structParent) && structParent >= 0 ? structParent : -1;
706 
707       annotationGlobals.structTreeRoot.addAnnotationIdToPage(
708         params.pageRef,
709         structParent
710       );
711     }
712 
713     if (params.collectFields) {
714       // Fields can act as container for other fields and have
715       // some actions even if no Annotation inherit from them.
716       // Those fields can be referenced by CO (calculation order).
717       const kids = dict.get("Kids");
718       if (Array.isArray(kids)) {
719         const kidIds = [];
720         for (const kid of kids) {
721           if (kid instanceof Ref) {
722             kidIds.push(kid.toString());
723           }
724         }
725         if (kidIds.length !== 0) {
726           this.data.kidIds = kidIds;
727         }
728       }
729 
730       this.data.actions = collectActions(xref, dict, AnnotationActionEventType);
731       this.data.fieldName = this._constructFieldName(dict);
732       this.data.pageIndex = params.pageIndex;
733     }
734 
735     const it = dict.get("IT");
736     if (it instanceof Name) {
737       this.data.it = it.name;
738     }
739 
740     this._isOffscreenCanvasSupported =
741       params.evaluatorOptions.isOffscreenCanvasSupported;
742     this._fallbackFontDict = null;
743     this._needAppearances = false;
744   }
745 
746   /**
747    * @private
748    */
749   _hasFlag(flags, flag) {
750     return !!(flags & flag);
751   }
752 
753   _buildFlags(noView, noPrint) {
754     let { flags } = this;
755     if (noView === undefined) {
756       if (noPrint === undefined) {
757         return undefined;
758       }
759       if (noPrint) {
760         return flags & ~AnnotationFlag.PRINT;
761       }
762       return (flags & ~AnnotationFlag.HIDDEN) | AnnotationFlag.PRINT;
763     }
764 
765     if (noView) {
766       flags |= AnnotationFlag.PRINT;
767       if (noPrint) {
768         // display === 1.
769         return (flags & ~AnnotationFlag.NOVIEW) | AnnotationFlag.HIDDEN;
770       }
771       // display === 3.
772       return (flags & ~AnnotationFlag.HIDDEN) | AnnotationFlag.NOVIEW;
773     }
774 
775     flags &= ~(AnnotationFlag.HIDDEN | AnnotationFlag.NOVIEW);
776     if (noPrint) {
777       // display === 2.
778       return flags & ~AnnotationFlag.PRINT;
779     }
780 
781     // display === 0.
782     return flags | AnnotationFlag.PRINT;
783   }
784 
785   /**
786    * @private
787    */
788   _isViewable(flags) {
789     return (
790       !this._hasFlag(flags, AnnotationFlag.INVISIBLE) &&
791       !this._hasFlag(flags, AnnotationFlag.NOVIEW)
792     );
793   }
794 
795   /**
796    * @private
797    */
798   _isPrintable(flags) {
799     // In Acrobat, hidden flag cancels the print one
800     // (see annotation_hidden_print.pdf).
801     return (
802       this._hasFlag(flags, AnnotationFlag.PRINT) &&
803       !this._hasFlag(flags, AnnotationFlag.HIDDEN) &&
804       !this._hasFlag(flags, AnnotationFlag.INVISIBLE)
805     );
806   }
807 
808   /**
809    * Check if the annotation must be displayed by taking into account
810    * the value found in the annotationStorage which may have been set
811    * through JS.
812    *
813    * @public
814    * @memberof Annotation
815    * @param {AnnotationStorage} [annotationStorage] - Storage for annotation
816    * @param {boolean} [_renderForms] - if true widgets are rendered thanks to
817    *                                   the annotation layer.
818    */
819   mustBeViewed(annotationStorage, _renderForms) {
820     const noView = annotationStorage?.get(this.data.id)?.noView;
821     if (noView !== undefined) {
822       return !noView;
823     }
824     return this.viewable && !this._hasFlag(this.flags, AnnotationFlag.HIDDEN);
825   }
826 
827   /**
828    * Check if the annotation must be printed by taking into account
829    * the value found in the annotationStorage which may have been set
830    * through JS.
831    *
832    * @public
833    * @memberof Annotation
834    * @param {AnnotationStorage} [annotationStorage] - Storage for annotation
835    */
836   mustBePrinted(annotationStorage) {
837     const noPrint = annotationStorage?.get(this.data.id)?.noPrint;
838     if (noPrint !== undefined) {
839       return !noPrint;
840     }
841     return this.printable;
842   }
843 
844   mustBeViewedWhenEditing(isEditing, modifiedIds = null) {
845     return isEditing ? !this.data.isEditable : !modifiedIds?.has(this.data.id);
846   }
847 
848   /**
849    * @type {boolean}
850    */
851   get viewable() {
852     if (this.data.quadPoints === null) {
853       return false;
854     }
855     if (this.flags === 0) {
856       return true;
857     }
858     return this._isViewable(this.flags);
859   }
860 
861   /**
862    * @type {boolean}
863    */
864   get printable() {
865     if (this.data.quadPoints === null) {
866       return false;
867     }
868     if (this.flags === 0) {
869       return false;
870     }
871     return this._isPrintable(this.flags);
872   }
873 
874   /**
875    * @private
876    */
877   _parseStringHelper(data) {
878     const str = typeof data === "string" ? stringToPDFString(data) : "";
879     const dir = str && bidi(str).dir === "rtl" ? "rtl" : "ltr";
880 
881     return { str, dir };
882   }
883 
884   setDefaultAppearance(params) {
885     const { dict, annotationGlobals } = params;
886 
887     const defaultAppearance =
888       getInheritableProperty({ dict, key: "DA" }) ||
889       annotationGlobals.acroForm.get("DA");
890     this._defaultAppearance =
891       typeof defaultAppearance === "string" ? defaultAppearance : "";
892     this.data.defaultAppearanceData = parseDefaultAppearance(
893       this._defaultAppearance
894     );
895   }
896 
897   /**
898    * Set the title.
899    *
900    * @param {string} title - The title of the annotation, used e.g. with
901    *   PopupAnnotations.
902    */
903   setTitle(title) {
904     this._title = this._parseStringHelper(title);
905   }
906 
907   /**
908    * Set the contents.
909    *
910    * @param {string} contents - Text to display for the annotation or, if the
911    *                            type of annotation does not display text, a
912    *                            description of the annotation's contents
913    */
914   setContents(contents) {
915     this._contents = this._parseStringHelper(contents);
916   }
917 
918   /**
919    * Set the modification date.
920    *
921    * @public
922    * @memberof Annotation
923    * @param {string} modificationDate - PDF date string that indicates when the
924    *                                    annotation was last modified
925    */
926   setModificationDate(modificationDate) {
927     this.modificationDate =
928       typeof modificationDate === "string" ? modificationDate : null;
929   }
930 
931   /**
932    * Set the flags.
933    *
934    * @public
935    * @memberof Annotation
936    * @param {number} flags - Unsigned 32-bit integer specifying annotation
937    *                         characteristics
938    * @see {@link shared/util.js}
939    */
940   setFlags(flags) {
941     this.flags = Number.isInteger(flags) && flags > 0 ? flags : 0;
942     if (
943       this.flags & AnnotationFlag.INVISIBLE &&
944       this.constructor.name !== "Annotation"
945     ) {
946       // From the pdf spec v1.7, section 12.5.3 (Annotation Flags):
947       //   If set, do not display the annotation if it does not belong to one of
948       //   the standard annotation types and no annotation handler is available.
949       //
950       // So we can remove the flag in case we have a known annotation type.
951       this.flags ^= AnnotationFlag.INVISIBLE;
952     }
953   }
954 
955   /**
956    * Check if a provided flag is set.
957    *
958    * @public
959    * @memberof Annotation
960    * @param {number} flag - Hexadecimal representation for an annotation
961    *                        characteristic
962    * @returns {boolean}
963    * @see {@link shared/util.js}
964    */
965   hasFlag(flag) {
966     return this._hasFlag(this.flags, flag);
967   }
968 
969   /**
970    * Set the rectangle.
971    *
972    * @public
973    * @memberof Annotation
974    * @param {Array} rectangle - The rectangle array with exactly four entries
975    */
976   setRectangle(rectangle) {
977     this.rectangle = lookupNormalRect(rectangle, [0, 0, 0, 0]);
978   }
979 
980   /**
981    * Set the color and take care of color space conversion.
982    * The default value is black, in RGB color space.
983    *
984    * @public
985    * @memberof Annotation
986    * @param {Array} color - The color array containing either 0
987    *                        (transparent), 1 (grayscale), 3 (RGB) or
988    *                        4 (CMYK) elements
989    */
990   setColor(color) {
991     this.color = getRgbColor(color);
992   }
993 
994   /**
995    * Set the line endings; should only be used with specific annotation types.
996    * @param {Array} lineEndings - The line endings array.
997    */
998   setLineEndings(lineEndings) {
999     if (typeof PDFJSDev !== "undefined" && PDFJSDev.test("MOZCENTRAL")) {
1000       throw new Error("Not implemented: setLineEndings");
1001     }
1002     this.lineEndings = ["None", "None"]; // The default values.
1003 
1004     if (Array.isArray(lineEndings) && lineEndings.length === 2) {
1005       for (let i = 0; i < 2; i++) {
1006         const obj = lineEndings[i];
1007 
1008         if (obj instanceof Name) {
1009           switch (obj.name) {
1010             case "None":
1011               continue;
1012             case "Square":
1013             case "Circle":
1014             case "Diamond":
1015             case "OpenArrow":
1016             case "ClosedArrow":
1017             case "Butt":
1018             case "ROpenArrow":
1019             case "RClosedArrow":
1020             case "Slash":
1021               this.lineEndings[i] = obj.name;
1022               continue;
1023           }
1024         }
1025         warn(`Ignoring invalid lineEnding: ${obj}`);
1026       }
1027     }
1028   }
1029 
1030   setRotation(mk, dict) {
1031     this.rotation = 0;
1032     let angle = mk instanceof Dict ? mk.get("R") || 0 : dict.get("Rotate") || 0;
1033     if (Number.isInteger(angle) && angle !== 0) {
1034       angle %= 360;
1035       if (angle < 0) {
1036         angle += 360;
1037       }
1038       if (angle % 90 === 0) {
1039         this.rotation = angle;
1040       }
1041     }
1042   }
1043 
1044   /**
1045    * Set the color for background and border if any.
1046    * The default values are transparent.
1047    *
1048    * @public
1049    * @memberof Annotation
1050    * @param {Dict} mk - The MK dictionary
1051    */
1052   setBorderAndBackgroundColors(mk) {
1053     if (mk instanceof Dict) {
1054       this.borderColor = getRgbColor(mk.getArray("BC"), null);
1055       this.backgroundColor = getRgbColor(mk.getArray("BG"), null);
1056     } else {
1057       this.borderColor = this.backgroundColor = null;
1058     }
1059   }
1060 
1061   /**
1062    * Set the border style (as AnnotationBorderStyle object).
1063    *
1064    * @public
1065    * @memberof Annotation
1066    * @param {Dict} borderStyle - The border style dictionary
1067    */
1068   setBorderStyle(borderStyle) {
1069     if (typeof PDFJSDev === "undefined" || PDFJSDev.test("TESTING")) {
1070       assert(this.rectangle, "setRectangle must have been called previously.");
1071     }
1072 
1073     this.borderStyle = new AnnotationBorderStyle();
1074     if (!(borderStyle instanceof Dict)) {
1075       return;
1076     }
1077     if (borderStyle.has("BS")) {
1078       const dict = borderStyle.get("BS");
1079 
1080       if (dict instanceof Dict) {
1081         const dictType = dict.get("Type");
1082 
1083         if (!dictType || isName(dictType, "Border")) {
1084           this.borderStyle.setWidth(dict.get("W"), this.rectangle);
1085           this.borderStyle.setStyle(dict.get("S"));
1086           this.borderStyle.setDashArray(dict.getArray("D"));
1087         }
1088       }
1089     } else if (borderStyle.has("Border")) {
1090       const array = borderStyle.getArray("Border");
1091       if (Array.isArray(array) && array.length >= 3) {
1092         this.borderStyle.setHorizontalCornerRadius(array[0]);
1093         this.borderStyle.setVerticalCornerRadius(array[1]);
1094         this.borderStyle.setWidth(array[2], this.rectangle);
1095 
1096         if (array.length === 4) {
1097           // Dash array available
1098           this.borderStyle.setDashArray(array[3], /* forceStyle = */ true);
1099         }
1100       }
1101     } else {
1102       // There are no border entries in the dictionary. According to the
1103       // specification, we should draw a solid border of width 1 in that
1104       // case, but Adobe Reader did not implement that part of the
1105       // specification and instead draws no border at all, so we do the same.
1106       // See also https://github.com/mozilla/pdf.js/issues/6179.
1107       this.borderStyle.setWidth(0);
1108     }
1109   }
1110 
1111   /**
1112    * Set the (normal) appearance.
1113    *
1114    * @public
1115    * @memberof Annotation
1116    * @param {Dict} dict - The annotation's data dictionary
1117    */
1118   setAppearance(dict) {
1119     this.appearance = null;
1120 
1121     const appearanceStates = dict.get("AP");
1122     if (!(appearanceStates instanceof Dict)) {
1123       return;
1124     }
1125 
1126     // In case the normal appearance is a stream, then it is used directly.
1127     const normalAppearanceState = appearanceStates.get("N");
1128     if (normalAppearanceState instanceof BaseStream) {
1129       this.appearance = normalAppearanceState;
1130       return;
1131     }
1132     if (!(normalAppearanceState instanceof Dict)) {
1133       return;
1134     }
1135 
1136     // In case the normal appearance is a dictionary, the `AS` entry provides
1137     // the key of the stream in this dictionary.
1138     const as = dict.get("AS");
1139     if (!(as instanceof Name) || !normalAppearanceState.has(as.name)) {
1140       return;
1141     }
1142     const appearance = normalAppearanceState.get(as.name);
1143     if (appearance instanceof BaseStream) {
1144       this.appearance = appearance;
1145     }
1146   }
1147 
1148   setOptionalContent(dict) {
1149     this.oc = null;
1150 
1151     const oc = dict.get("OC");
1152     if (oc instanceof Name) {
1153       warn("setOptionalContent: Support for /Name-entry is not implemented.");
1154     } else if (oc instanceof Dict) {
1155       this.oc = oc;
1156     }
1157   }
1158 
1159   loadResources(keys, appearance) {
1160     return appearance.dict.getAsync("Resources").then(resources => {
1161       if (!resources) {
1162         return undefined;
1163       }
1164 
1165       const objectLoader = new ObjectLoader(resources, keys, resources.xref);
1166       return objectLoader.load().then(() => resources);
1167     });
1168   }
1169 
1170   async getOperatorList(evaluator, task, intent, annotationStorage) {
1171     const { hasOwnCanvas, id, rect } = this.data;
1172     let appearance = this.appearance;
1173     const isUsingOwnCanvas = !!(
1174       hasOwnCanvas && intent & RenderingIntentFlag.DISPLAY
1175     );
1176     if (isUsingOwnCanvas && (this.width === 0 || this.height === 0)) {
1177       // Empty annotation, don't draw anything.
1178       this.data.hasOwnCanvas = false;
1179       return {
1180         opList: new OperatorList(),
1181         separateForm: false,
1182         separateCanvas: false,
1183       };
1184     }
1185     if (!appearance) {
1186       if (!isUsingOwnCanvas) {
1187         return {
1188           opList: new OperatorList(),
1189           separateForm: false,
1190           separateCanvas: false,
1191         };
1192       }
1193       appearance = new StringStream("");
1194       appearance.dict = new Dict();
1195     }
1196 
1197     const appearanceDict = appearance.dict;
1198     const resources = await this.loadResources(
1199       ["ExtGState", "ColorSpace", "Pattern", "Shading", "XObject", "Font"],
1200       appearance
1201     );
1202     const bbox = lookupRect(appearanceDict.getArray("BBox"), [0, 0, 1, 1]);
1203     const matrix = lookupMatrix(
1204       appearanceDict.getArray("Matrix"),
1205       IDENTITY_MATRIX
1206     );
1207     const transform = getTransformMatrix(rect, bbox, matrix);
1208 
1209     const opList = new OperatorList();
1210 
1211     let optionalContent;
1212     if (this.oc) {
1213       optionalContent = await evaluator.parseMarkedContentProps(
1214         this.oc,
1215         /* resources = */ null
1216       );
1217     }
1218     if (optionalContent !== undefined) {
1219       opList.addOp(OPS.beginMarkedContentProps, ["OC", optionalContent]);
1220     }
1221 
1222     opList.addOp(OPS.beginAnnotation, [
1223       id,
1224       rect,
1225       transform,
1226       matrix,
1227       isUsingOwnCanvas,
1228     ]);
1229 
1230     await evaluator.getOperatorList({
1231       stream: appearance,
1232       task,
1233       resources,
1234       operatorList: opList,
1235       fallbackFontDict: this._fallbackFontDict,
1236     });
1237     opList.addOp(OPS.endAnnotation, []);
1238 
1239     if (optionalContent !== undefined) {
1240       opList.addOp(OPS.endMarkedContent, []);
1241     }
1242     this.reset();
1243     return { opList, separateForm: false, separateCanvas: isUsingOwnCanvas };
1244   }
1245 
1246   async save(evaluator, task, annotationStorage, changes) {
1247     return null;
1248   }
1249 
1250   get hasTextContent() {
1251     return false;
1252   }
1253 
1254   async extractTextContent(evaluator, task, viewBox) {
1255     if (!this.appearance) {
1256       return;
1257     }
1258 
1259     const resources = await this.loadResources(
1260       ["ExtGState", "Font", "Properties", "XObject"],
1261       this.appearance
1262     );
1263 
1264     const text = [];
1265     const buffer = [];
1266     let firstPosition = null;
1267     const sink = {
1268       desiredSize: Math.Infinity,
1269       ready: true,
1270 
1271       enqueue(chunk, size) {
1272         for (const item of chunk.items) {
1273           if (item.str === undefined) {
1274             continue;
1275           }
1276           firstPosition ||= item.transform.slice(-2);
1277           buffer.push(item.str);
1278           if (item.hasEOL) {
1279             text.push(buffer.join("").trimEnd());
1280             buffer.length = 0;
1281           }
1282         }
1283       },
1284     };
1285 
1286     await evaluator.getTextContent({
1287       stream: this.appearance,
1288       task,
1289       resources,
1290       includeMarkedContent: true,
1291       keepWhiteSpace: true,
1292       sink,
1293       viewBox,
1294     });
1295     this.reset();
1296 
1297     if (buffer.length) {
1298       text.push(buffer.join("").trimEnd());
1299     }
1300 
1301     if (text.length > 1 || text[0]) {
1302       const appearanceDict = this.appearance.dict;
1303       const bbox = lookupRect(appearanceDict.getArray("BBox"), null);
1304       const matrix = lookupMatrix(appearanceDict.getArray("Matrix"), null);
1305 
1306       this.data.textPosition = this._transformPoint(
1307         firstPosition,
1308         bbox,
1309         matrix
1310       );
1311       this.data.textContent = text;
1312     }
1313   }
1314 
1315   _transformPoint(coords, bbox, matrix) {
1316     const { rect } = this.data;
1317     bbox ||= [0, 0, 1, 1];
1318     matrix ||= [1, 0, 0, 1, 0, 0];
1319     const transform = getTransformMatrix(rect, bbox, matrix);
1320     transform[4] -= rect[0];
1321     transform[5] -= rect[1];
1322     const p = coords.slice();
1323     Util.applyTransform(p, transform);
1324     Util.applyTransform(p, matrix);
1325     return p;
1326   }
1327 
1328   /**
1329    * Get field data for usage in JS sandbox.
1330    *
1331    * Field object is defined here:
1332    * https://www.adobe.com/content/dam/acom/en/devnet/acrobat/pdfs/js_api_reference.pdf#page=16
1333    *
1334    * @public
1335    * @memberof Annotation
1336    * @returns {Object | null}
1337    */
1338   getFieldObject() {
1339     if (this.data.kidIds) {
1340       return {
1341         id: this.data.id,
1342         actions: this.data.actions,
1343         name: this.data.fieldName,
1344         strokeColor: this.data.borderColor,
1345         fillColor: this.data.backgroundColor,
1346         type: "",
1347         kidIds: this.data.kidIds,
1348         page: this.data.pageIndex,
1349         rotation: this.rotation,
1350       };
1351     }
1352     return null;
1353   }
1354 
1355   /**
1356    * Reset the annotation.
1357    *
1358    * This involves resetting the various streams that are either cached on the
1359    * annotation instance or created during its construction.
1360    *
1361    * @public
1362    * @memberof Annotation
1363    */
1364   reset() {
1365     if (
1366       (typeof PDFJSDev === "undefined" || PDFJSDev.test("TESTING")) &&
1367       this.appearance &&
1368       !this._streams.includes(this.appearance)
1369     ) {
1370       unreachable("The appearance stream should always be reset.");
1371     }
1372 
1373     for (const stream of this._streams) {
1374       stream.reset();
1375     }
1376   }
1377 
1378   /**
1379    * Construct the (fully qualified) field name from the (partial) field
1380    * names of the field and its ancestors.
1381    *
1382    * @private
1383    * @memberof Annotation
1384    * @param {Dict} dict - Complete widget annotation dictionary
1385    * @returns {string}
1386    */
1387   _constructFieldName(dict) {
1388     // Both the `Parent` and `T` fields are optional. While at least one of
1389     // them should be provided, bad PDF generators may fail to do so.
1390     if (!dict.has("T") && !dict.has("Parent")) {
1391       warn("Unknown field name, falling back to empty field name.");
1392       return "";
1393     }
1394 
1395     // If no parent exists, the partial and fully qualified names are equal.
1396     if (!dict.has("Parent")) {
1397       return stringToPDFString(dict.get("T"));
1398     }
1399 
1400     // Form the fully qualified field name by appending the partial name to
1401     // the parent's fully qualified name, separated by a period.
1402     const fieldName = [];
1403     if (dict.has("T")) {
1404       fieldName.unshift(stringToPDFString(dict.get("T")));
1405     }
1406 
1407     let loopDict = dict;
1408     const visited = new RefSet();
1409     if (dict.objId) {
1410       visited.put(dict.objId);
1411     }
1412     while (loopDict.has("Parent")) {
1413       loopDict = loopDict.get("Parent");
1414       if (
1415         !(loopDict instanceof Dict) ||
1416         (loopDict.objId && visited.has(loopDict.objId))
1417       ) {
1418         // Even though it is not allowed according to the PDF specification,
1419         // bad PDF generators may provide a `Parent` entry that is not a
1420         // dictionary, but `null` for example (issue 8143).
1421         //
1422         // If parent has been already visited, it means that we're
1423         // in an infinite loop.
1424         break;
1425       }
1426       if (loopDict.objId) {
1427         visited.put(loopDict.objId);
1428       }
1429 
1430       if (loopDict.has("T")) {
1431         fieldName.unshift(stringToPDFString(loopDict.get("T")));
1432       }
1433     }
1434     return fieldName.join(".");
1435   }
1436 
1437   get width() {
1438     return this.data.rect[2] - this.data.rect[0];
1439   }
1440 
1441   get height() {
1442     return this.data.rect[3] - this.data.rect[1];
1443   }
1444 }
1445 
1446 /**
1447  * Contains all data regarding an annotation's border style.
1448  */
1449 class AnnotationBorderStyle {
1450   constructor() {
1451     this.width = 1;
1452     this.rawWidth = 1;
1453     this.style = AnnotationBorderStyleType.SOLID;
1454     this.dashArray = [3];
1455     this.horizontalCornerRadius = 0;
1456     this.verticalCornerRadius = 0;
1457   }
1458 
1459   /**
1460    * Set the width.
1461    *
1462    * @public
1463    * @memberof AnnotationBorderStyle
1464    * @param {number} width - The width.
1465    * @param {Array} rect - The annotation `Rect` entry.
1466    */
1467   setWidth(width, rect = [0, 0, 0, 0]) {
1468     if (typeof PDFJSDev === "undefined" || PDFJSDev.test("TESTING")) {
1469       assert(
1470         isNumberArray(rect, 4),
1471         "A valid `rect` parameter must be provided."
1472       );
1473     }
1474 
1475     // Some corrupt PDF generators may provide the width as a `Name`,
1476     // rather than as a number (fixes issue 10385).
1477     if (width instanceof Name) {
1478       this.width = 0; // This is consistent with the behaviour in Adobe Reader.
1479       return;
1480     }
1481     if (typeof width === "number") {
1482       if (width > 0) {
1483         this.rawWidth = width;
1484         const maxWidth = (rect[2] - rect[0]) / 2;
1485         const maxHeight = (rect[3] - rect[1]) / 2;
1486 
1487         // Ignore large `width`s, since they lead to the Annotation overflowing
1488         // the size set by the `Rect` entry thus causing the `annotationLayer`
1489         // to render it over the surrounding document (fixes bug1552113.pdf).
1490         if (
1491           maxWidth > 0 &&
1492           maxHeight > 0 &&
1493           (width > maxWidth || width > maxHeight)
1494         ) {
1495           warn(`AnnotationBorderStyle.setWidth - ignoring width: ${width}`);
1496           width = 1;
1497         }
1498       }
1499       this.width = width;
1500     }
1501   }
1502 
1503   /**
1504    * Set the style.
1505    *
1506    * @public
1507    * @memberof AnnotationBorderStyle
1508    * @param {Name} style - The annotation style.
1509    * @see {@link shared/util.js}
1510    */
1511   setStyle(style) {
1512     if (!(style instanceof Name)) {
1513       return;
1514     }
1515     switch (style.name) {
1516       case "S":
1517         this.style = AnnotationBorderStyleType.SOLID;
1518         break;
1519 
1520       case "D":
1521         this.style = AnnotationBorderStyleType.DASHED;
1522         break;
1523 
1524       case "B":
1525         this.style = AnnotationBorderStyleType.BEVELED;
1526         break;
1527 
1528       case "I":
1529         this.style = AnnotationBorderStyleType.INSET;
1530         break;
1531 
1532       case "U":
1533         this.style = AnnotationBorderStyleType.UNDERLINE;
1534         break;
1535 
1536       default:
1537         break;
1538     }
1539   }
1540 
1541   /**
1542    * Set the dash array.
1543    *
1544    * @public
1545    * @memberof AnnotationBorderStyle
1546    * @param {Array} dashArray - The dash array with at least one element
1547    * @param {boolean} [forceStyle]
1548    */
1549   setDashArray(dashArray, forceStyle = false) {
1550     // We validate the dash array, but we do not use it because CSS does not
1551     // allow us to change spacing of dashes. For more information, visit
1552     // http://www.w3.org/TR/css3-background/#the-border-style.
1553     if (Array.isArray(dashArray)) {
1554       // The PDF specification states that elements in the dash array, if
1555       // present, must be non-negative numbers and must not all equal zero.
1556       let isValid = true;
1557       let allZeros = true;
1558       for (const element of dashArray) {
1559         const validNumber = +element >= 0;
1560         if (!validNumber) {
1561           isValid = false;
1562           break;
1563         } else if (element > 0) {
1564           allZeros = false;
1565         }
1566       }
1567       if (dashArray.length === 0 || (isValid && !allZeros)) {
1568         this.dashArray = dashArray;
1569 
1570         if (forceStyle) {
1571           // Even though we cannot use the dash array in the display layer,
1572           // at least ensure that we use the correct border-style.
1573           this.setStyle(Name.get("D"));
1574         }
1575       } else {
1576         this.width = 0; // Adobe behavior when the array is invalid.
1577       }
1578     } else if (dashArray) {
1579       this.width = 0; // Adobe behavior when the array is invalid.
1580     }
1581   }
1582 
1583   /**
1584    * Set the horizontal corner radius (from a Border dictionary).
1585    *
1586    * @public
1587    * @memberof AnnotationBorderStyle
1588    * @param {number} radius - The horizontal corner radius.
1589    */
1590   setHorizontalCornerRadius(radius) {
1591     if (Number.isInteger(radius)) {
1592       this.horizontalCornerRadius = radius;
1593     }
1594   }
1595 
1596   /**
1597    * Set the vertical corner radius (from a Border dictionary).
1598    *
1599    * @public
1600    * @memberof AnnotationBorderStyle
1601    * @param {number} radius - The vertical corner radius.
1602    */
1603   setVerticalCornerRadius(radius) {
1604     if (Number.isInteger(radius)) {
1605       this.verticalCornerRadius = radius;
1606     }
1607   }
1608 }
1609 
1610 class MarkupAnnotation extends Annotation {
1611   constructor(params) {
1612     super(params);
1613 
1614     const { dict } = params;
1615 
1616     if (dict.has("IRT")) {
1617       const rawIRT = dict.getRaw("IRT");
1618       this.data.inReplyTo = rawIRT instanceof Ref ? rawIRT.toString() : null;
1619 
1620       const rt = dict.get("RT");
1621       this.data.replyType =
1622         rt instanceof Name ? rt.name : AnnotationReplyType.REPLY;
1623     }
1624     let popupRef = null;
1625 
1626     if (this.data.replyType === AnnotationReplyType.GROUP) {
1627       // Subordinate annotations in a group should inherit
1628       // the group attributes from the primary annotation.
1629       const parent = dict.get("IRT");
1630 
1631       this.setTitle(parent.get("T"));
1632       this.data.titleObj = this._title;
1633 
1634       this.setContents(parent.get("Contents"));
1635       this.data.contentsObj = this._contents;
1636 
1637       if (!parent.has("CreationDate")) {
1638         this.data.creationDate = null;
1639       } else {
1640         this.setCreationDate(parent.get("CreationDate"));
1641         this.data.creationDate = this.creationDate;
1642       }
1643 
1644       if (!parent.has("M")) {
1645         this.data.modificationDate = null;
1646       } else {
1647         this.setModificationDate(parent.get("M"));
1648         this.data.modificationDate = this.modificationDate;
1649       }
1650 
1651       popupRef = parent.getRaw("Popup");
1652 
1653       if (!parent.has("C")) {
1654         // Fall back to the default background color.
1655         this.data.color = null;
1656       } else {
1657         this.setColor(parent.getArray("C"));
1658         this.data.color = this.color;
1659       }
1660     } else {
1661       this.data.titleObj = this._title;
1662 
1663       this.setCreationDate(dict.get("CreationDate"));
1664       this.data.creationDate = this.creationDate;
1665 
1666       popupRef = dict.getRaw("Popup");
1667 
1668       if (!dict.has("C")) {
1669         // Fall back to the default background color.
1670         this.data.color = null;
1671       }
1672     }
1673 
1674     this.data.popupRef = popupRef instanceof Ref ? popupRef.toString() : null;
1675 
1676     if (dict.has("RC")) {
1677       this.data.richText = XFAFactory.getRichTextAsHtml(dict.get("RC"));
1678     }
1679   }
1680 
1681   /**
1682    * Set the creation date.
1683    *
1684    * @public
1685    * @memberof MarkupAnnotation
1686    * @param {string} creationDate - PDF date string that indicates when the
1687    *                                annotation was originally created
1688    */
1689   setCreationDate(creationDate) {
1690     this.creationDate = typeof creationDate === "string" ? creationDate : null;
1691   }
1692 
1693   _setDefaultAppearance({
1694     xref,
1695     extra,
1696     strokeColor,
1697     fillColor,
1698     blendMode,
1699     strokeAlpha,
1700     fillAlpha,
1701     pointsCallback,
1702   }) {
1703     const bbox = (this.data.rect = [Infinity, Infinity, -Infinity, -Infinity]);
1704 
1705     const buffer = ["q"];
1706     if (extra) {
1707       buffer.push(extra);
1708     }
1709     if (strokeColor) {
1710       buffer.push(`${strokeColor[0]} ${strokeColor[1]} ${strokeColor[2]} RG`);
1711     }
1712     if (fillColor) {
1713       buffer.push(`${fillColor[0]} ${fillColor[1]} ${fillColor[2]} rg`);
1714     }
1715 
1716     // If there are no quadpoints, the rectangle should be used instead.
1717     // Convert the rectangle definition to a points array similar to how the
1718     // quadpoints are defined.
1719     const pointsArray =
1720       this.data.quadPoints ||
1721       Float32Array.from([
1722         this.rectangle[0],
1723         this.rectangle[3],
1724         this.rectangle[2],
1725         this.rectangle[3],
1726         this.rectangle[0],
1727         this.rectangle[1],
1728         this.rectangle[2],
1729         this.rectangle[1],
1730       ]);
1731 
1732     for (let i = 0, ii = pointsArray.length; i < ii; i += 8) {
1733       const points = pointsCallback(buffer, pointsArray.subarray(i, i + 8));
1734       Util.rectBoundingBox(...points, bbox);
1735     }
1736     buffer.push("Q");
1737 
1738     const formDict = new Dict(xref);
1739     const appearanceStreamDict = new Dict(xref);
1740     appearanceStreamDict.set("Subtype", Name.get("Form"));
1741 
1742     const appearanceStream = new StringStream(buffer.join(" "));
1743     appearanceStream.dict = appearanceStreamDict;
1744     formDict.set("Fm0", appearanceStream);
1745 
1746     const gsDict = new Dict(xref);
1747     if (blendMode) {
1748       gsDict.set("BM", Name.get(blendMode));
1749     }
1750     if (typeof strokeAlpha === "number") {
1751       gsDict.set("CA", strokeAlpha);
1752     }
1753     if (typeof fillAlpha === "number") {
1754       gsDict.set("ca", fillAlpha);
1755     }
1756 
1757     const stateDict = new Dict(xref);
1758     stateDict.set("GS0", gsDict);
1759 
1760     const resources = new Dict(xref);
1761     resources.set("ExtGState", stateDict);
1762     resources.set("XObject", formDict);
1763 
1764     const appearanceDict = new Dict(xref);
1765     appearanceDict.set("Resources", resources);
1766     appearanceDict.set("BBox", bbox);
1767 
1768     this.appearance = new StringStream("/GS0 gs /Fm0 Do");
1769     this.appearance.dict = appearanceDict;
1770 
1771     // This method is only called if there is no appearance for the annotation,
1772     // so `this.appearance` is not pushed yet in the `Annotation` constructor.
1773     this._streams.push(this.appearance, appearanceStream);
1774   }
1775 
1776   static async createNewAnnotation(xref, annotation, changes, params) {
1777     const annotationRef = (annotation.ref ||= xref.getNewTemporaryRef());
1778 
1779     const ap = await this.createNewAppearanceStream(annotation, xref, params);
1780     let annotationDict;
1781 
1782     if (ap) {
1783       const apRef = xref.getNewTemporaryRef();
1784       annotationDict = this.createNewDict(annotation, xref, {
1785         apRef,
1786       });
1787       changes.put(apRef, {
1788         data: ap,
1789       });
1790     } else {
1791       annotationDict = this.createNewDict(annotation, xref, {});
1792     }
1793     if (Number.isInteger(annotation.parentTreeId)) {
1794       annotationDict.set("StructParent", annotation.parentTreeId);
1795     }
1796 
1797     changes.put(annotationRef, {
1798       data: annotationDict,
1799     });
1800 
1801     return { ref: annotationRef };
1802   }
1803 
1804   static async createNewPrintAnnotation(
1805     annotationGlobals,
1806     xref,
1807     annotation,
1808     params
1809   ) {
1810     const ap = await this.createNewAppearanceStream(annotation, xref, params);
1811     const annotationDict = this.createNewDict(
1812       annotation,
1813       xref,
1814       ap ? { ap } : {}
1815     );
1816 
1817     const newAnnotation = new this.prototype.constructor({
1818       dict: annotationDict,
1819       xref,
1820       annotationGlobals,
1821       evaluatorOptions: params.evaluatorOptions,
1822     });
1823 
1824     if (annotation.ref) {
1825       newAnnotation.ref = newAnnotation.refToReplace = annotation.ref;
1826     }
1827 
1828     return newAnnotation;
1829   }
1830 }
1831 
1832 class WidgetAnnotation extends Annotation {
1833   constructor(params) {
1834     super(params);
1835 
1836     const { dict, xref, annotationGlobals } = params;
1837     const data = this.data;
1838     this._needAppearances = params.needAppearances;
1839 
1840     data.annotationType = AnnotationType.WIDGET;
1841     if (data.fieldName === undefined) {
1842       data.fieldName = this._constructFieldName(dict);
1843     }
1844 
1845     if (data.actions === undefined) {
1846       data.actions = collectActions(xref, dict, AnnotationActionEventType);
1847     }
1848 
1849     let fieldValue = getInheritableProperty({
1850       dict,
1851       key: "V",
1852       getArray: true,
1853     });
1854     data.fieldValue = this._decodeFormValue(fieldValue);
1855 
1856     const defaultFieldValue = getInheritableProperty({
1857       dict,
1858       key: "DV",
1859       getArray: true,
1860     });
1861     data.defaultFieldValue = this._decodeFormValue(defaultFieldValue);
1862 
1863     if (fieldValue === undefined && annotationGlobals.xfaDatasets) {
1864       // Try to figure out if we have something in the xfa dataset.
1865       const path = this._title.str;
1866       if (path) {
1867         this._hasValueFromXFA = true;
1868         data.fieldValue = fieldValue =
1869           annotationGlobals.xfaDatasets.getValue(path);
1870       }
1871     }
1872 
1873     // When no "V" entry exists, let the fieldValue fallback to the "DV" entry
1874     // (fixes issue13823.pdf).
1875     if (fieldValue === undefined && data.defaultFieldValue !== null) {
1876       data.fieldValue = data.defaultFieldValue;
1877     }
1878 
1879     data.alternativeText = stringToPDFString(dict.get("TU") || "");
1880 
1881     this.setDefaultAppearance(params);
1882 
1883     data.hasAppearance ||=
1884       this._needAppearances &&
1885       data.fieldValue !== undefined &&
1886       data.fieldValue !== null;
1887 
1888     const fieldType = getInheritableProperty({ dict, key: "FT" });
1889     data.fieldType = fieldType instanceof Name ? fieldType.name : null;
1890 
1891     const localResources = getInheritableProperty({ dict, key: "DR" });
1892     const acroFormResources = annotationGlobals.acroForm.get("DR");
1893     const appearanceResources = this.appearance?.dict.get("Resources");
1894 
1895     this._fieldResources = {
1896       localResources,
1897       acroFormResources,
1898       appearanceResources,
1899       mergedResources: Dict.merge({
1900         xref,
1901         dictArray: [localResources, appearanceResources, acroFormResources],
1902         mergeSubDicts: true,
1903       }),
1904     };
1905 
1906     data.fieldFlags = getInheritableProperty({ dict, key: "Ff" });
1907     if (!Number.isInteger(data.fieldFlags) || data.fieldFlags < 0) {
1908       data.fieldFlags = 0;
1909     }
1910 
1911     data.password = this.hasFieldFlag(AnnotationFieldFlag.PASSWORD);
1912     data.readOnly = this.hasFieldFlag(AnnotationFieldFlag.READONLY);
1913     data.required = this.hasFieldFlag(AnnotationFieldFlag.REQUIRED);
1914     data.hidden =
1915       this._hasFlag(data.annotationFlags, AnnotationFlag.HIDDEN) ||
1916       this._hasFlag(data.annotationFlags, AnnotationFlag.NOVIEW);
1917   }
1918 
1919   /**
1920    * Decode the given form value.
1921    *
1922    * @private
1923    * @memberof WidgetAnnotation
1924    * @param {Array<string>|Name|string} formValue - The (possibly encoded)
1925    *   form value.
1926    * @returns {Array<string>|string|null}
1927    */
1928   _decodeFormValue(formValue) {
1929     if (Array.isArray(formValue)) {
1930       return formValue
1931         .filter(item => typeof item === "string")
1932         .map(item => stringToPDFString(item));
1933     } else if (formValue instanceof Name) {
1934       return stringToPDFString(formValue.name);
1935     } else if (typeof formValue === "string") {
1936       return stringToPDFString(formValue);
1937     }
1938     return null;
1939   }
1940 
1941   /**
1942    * Check if a provided field flag is set.
1943    *
1944    * @public
1945    * @memberof WidgetAnnotation
1946    * @param {number} flag - Hexadecimal representation for an annotation
1947    *                        field characteristic
1948    * @returns {boolean}
1949    * @see {@link shared/util.js}
1950    */
1951   hasFieldFlag(flag) {
1952     return !!(this.data.fieldFlags & flag);
1953   }
1954 
1955   /** @inheritdoc */
1956   _isViewable(flags) {
1957     // We don't take into account the `NOVIEW` or `HIDDEN` flags here,
1958     // since the visibility can be changed by js code, hence in case
1959     // it's made viewable, we should render it (with visibility set to
1960     // hidden).
1961     // We don't take into account the `INVISIBLE` flag here, since we've a known
1962     // annotation type.
1963     return true;
1964   }
1965 
1966   /** @inheritdoc */
1967   mustBeViewed(annotationStorage, renderForms) {
1968     if (renderForms) {
1969       return this.viewable;
1970     }
1971     return (
1972       super.mustBeViewed(annotationStorage, renderForms) &&
1973       !this._hasFlag(this.flags, AnnotationFlag.NOVIEW)
1974     );
1975   }
1976 
1977   getRotationMatrix(annotationStorage) {
1978     let rotation = annotationStorage?.get(this.data.id)?.rotation;
1979     if (rotation === undefined) {
1980       rotation = this.rotation;
1981     }
1982 
1983     return rotation === 0
1984       ? IDENTITY_MATRIX
1985       : getRotationMatrix(rotation, this.width, this.height);
1986   }
1987 
1988   getBorderAndBackgroundAppearances(annotationStorage) {
1989     let rotation = annotationStorage?.get(this.data.id)?.rotation;
1990     if (rotation === undefined) {
1991       rotation = this.rotation;
1992     }
1993 
1994     if (!this.backgroundColor && !this.borderColor) {
1995       return "";
1996     }
1997     const rect =
1998       rotation === 0 || rotation === 180
1999         ? `0 0 ${this.width} ${this.height} re`
2000         : `0 0 ${this.height} ${this.width} re`;
2001 
2002     let str = "";
2003     if (this.backgroundColor) {
2004       str = `${getPdfColor(
2005         this.backgroundColor,
2006         /* isFill */ true
2007       )} ${rect} f `;
2008     }
2009 
2010     if (this.borderColor) {
2011       const borderWidth = this.borderStyle.width || 1;
2012       str += `${borderWidth} w ${getPdfColor(
2013         this.borderColor,
2014         /* isFill */ false
2015       )} ${rect} S `;
2016     }
2017 
2018     return str;
2019   }
2020 
2021   async getOperatorList(evaluator, task, intent, annotationStorage) {
2022     // Do not render form elements on the canvas when interactive forms are
2023     // enabled. The display layer is responsible for rendering them instead.
2024     if (
2025       intent & RenderingIntentFlag.ANNOTATIONS_FORMS &&
2026       !(this instanceof SignatureWidgetAnnotation) &&
2027       !this.data.noHTML &&
2028       !this.data.hasOwnCanvas
2029     ) {
2030       return {
2031         opList: new OperatorList(),
2032         separateForm: true,
2033         separateCanvas: false,
2034       };
2035     }
2036 
2037     if (!this._hasText) {
2038       return super.getOperatorList(evaluator, task, intent, annotationStorage);
2039     }
2040 
2041     const content = await this._getAppearance(
2042       evaluator,
2043       task,
2044       intent,
2045       annotationStorage
2046     );
2047     if (this.appearance && content === null) {
2048       return super.getOperatorList(evaluator, task, intent, annotationStorage);
2049     }
2050 
2051     const opList = new OperatorList();
2052 
2053     // Even if there is an appearance stream, ignore it. This is the
2054     // behaviour used by Adobe Reader.
2055     if (!this._defaultAppearance || content === null) {
2056       return { opList, separateForm: false, separateCanvas: false };
2057     }
2058 
2059     const isUsingOwnCanvas = !!(
2060       this.data.hasOwnCanvas && intent & RenderingIntentFlag.DISPLAY
2061     );
2062 
2063     const matrix = [1, 0, 0, 1, 0, 0];
2064     const bbox = [0, 0, this.width, this.height];
2065     const transform = getTransformMatrix(this.data.rect, bbox, matrix);
2066 
2067     let optionalContent;
2068     if (this.oc) {
2069       optionalContent = await evaluator.parseMarkedContentProps(
2070         this.oc,
2071         /* resources = */ null
2072       );
2073     }
2074     if (optionalContent !== undefined) {
2075       opList.addOp(OPS.beginMarkedContentProps, ["OC", optionalContent]);
2076     }
2077 
2078     opList.addOp(OPS.beginAnnotation, [
2079       this.data.id,
2080       this.data.rect,
2081       transform,
2082       this.getRotationMatrix(annotationStorage),
2083       isUsingOwnCanvas,
2084     ]);
2085 
2086     const stream = new StringStream(content);
2087     await evaluator.getOperatorList({
2088       stream,
2089       task,
2090       resources: this._fieldResources.mergedResources,
2091       operatorList: opList,
2092     });
2093     opList.addOp(OPS.endAnnotation, []);
2094 
2095     if (optionalContent !== undefined) {
2096       opList.addOp(OPS.endMarkedContent, []);
2097     }
2098     return { opList, separateForm: false, separateCanvas: isUsingOwnCanvas };
2099   }
2100 
2101   _getMKDict(rotation) {
2102     const mk = new Dict(null);
2103     if (rotation) {
2104       mk.set("R", rotation);
2105     }
2106     if (this.borderColor) {
2107       mk.set("BC", getPdfColorArray(this.borderColor));
2108     }
2109     if (this.backgroundColor) {
2110       mk.set("BG", getPdfColorArray(this.backgroundColor));
2111     }
2112     return mk.size > 0 ? mk : null;
2113   }
2114 
2115   amendSavedDict(annotationStorage, dict) {}
2116 
2117   setValue(dict, value, xref, changes) {
2118     const { dict: parentDict, ref: parentRef } = getParentToUpdate(
2119       dict,
2120       this.ref,
2121       xref
2122     );
2123     if (!parentDict) {
2124       dict.set("V", value);
2125     } else if (!changes.has(parentRef)) {
2126       const newParentDict = parentDict.clone();
2127       newParentDict.set("V", value);
2128       changes.put(parentRef, { data: newParentDict });
2129       return newParentDict;
2130     }
2131 
2132     return null;
2133   }
2134 
2135   async save(evaluator, task, annotationStorage, changes) {
2136     const storageEntry = annotationStorage?.get(this.data.id);
2137     const flags = this._buildFlags(storageEntry?.noView, storageEntry?.noPrint);
2138     let value = storageEntry?.value,
2139       rotation = storageEntry?.rotation;
2140     if (value === this.data.fieldValue || value === undefined) {
2141       if (
2142         !this._hasValueFromXFA &&
2143         rotation === undefined &&
2144         flags === undefined
2145       ) {
2146         return;
2147       }
2148       value ||= this.data.fieldValue;
2149     }
2150 
2151     // Value can be an array (with choice list and multiple selections)
2152     if (
2153       rotation === undefined &&
2154       !this._hasValueFromXFA &&
2155       Array.isArray(value) &&
2156       Array.isArray(this.data.fieldValue) &&
2157       isArrayEqual(value, this.data.fieldValue) &&
2158       flags === undefined
2159     ) {
2160       return;
2161     }
2162 
2163     if (rotation === undefined) {
2164       rotation = this.rotation;
2165     }
2166 
2167     let appearance = null;
2168     if (!this._needAppearances) {
2169       appearance = await this._getAppearance(
2170         evaluator,
2171         task,
2172         RenderingIntentFlag.SAVE,
2173         annotationStorage
2174       );
2175       if (appearance === null && flags === undefined) {
2176         // Appearance didn't change.
2177         return;
2178       }
2179     } else {
2180       // No need to create an appearance: the pdf has the flag /NeedAppearances
2181       // which means that it's up to the reader to produce an appearance.
2182     }
2183 
2184     let needAppearances = false;
2185     if (appearance?.needAppearances) {
2186       needAppearances = true;
2187       appearance = null;
2188     }
2189 
2190     const { xref } = evaluator;
2191 
2192     const originalDict = xref.fetchIfRef(this.ref);
2193     if (!(originalDict instanceof Dict)) {
2194       return;
2195     }
2196 
2197     const dict = new Dict(xref);
2198     for (const key of originalDict.getKeys()) {
2199       if (key !== "AP") {
2200         dict.set(key, originalDict.getRaw(key));
2201       }
2202     }
2203     if (flags !== undefined) {
2204       dict.set("F", flags);
2205       if (appearance === null && !needAppearances) {
2206         const ap = originalDict.getRaw("AP");
2207         if (ap) {
2208           dict.set("AP", ap);
2209         }
2210       }
2211     }
2212 
2213     const xfa = {
2214       path: this.data.fieldName,
2215       value,
2216     };
2217 
2218     const newParentDict = this.setValue(
2219       dict,
2220       Array.isArray(value)
2221         ? value.map(stringToAsciiOrUTF16BE)
2222         : stringToAsciiOrUTF16BE(value),
2223       xref,
2224       changes
2225     );
2226     this.amendSavedDict(annotationStorage, newParentDict || dict);
2227 
2228     const maybeMK = this._getMKDict(rotation);
2229     if (maybeMK) {
2230       dict.set("MK", maybeMK);
2231     }
2232 
2233     changes.put(this.ref, {
2234       data: dict,
2235       xfa,
2236       needAppearances,
2237     });
2238     if (appearance !== null) {
2239       const newRef = xref.getNewTemporaryRef();
2240       const AP = new Dict(xref);
2241       dict.set("AP", AP);
2242       AP.set("N", newRef);
2243 
2244       const resources = this._getSaveFieldResources(xref);
2245       const appearanceStream = new StringStream(appearance);
2246       const appearanceDict = (appearanceStream.dict = new Dict(xref));
2247       appearanceDict.set("Subtype", Name.get("Form"));
2248       appearanceDict.set("Resources", resources);
2249       appearanceDict.set("BBox", [0, 0, this.width, this.height]);
2250 
2251       const rotationMatrix = this.getRotationMatrix(annotationStorage);
2252       if (rotationMatrix !== IDENTITY_MATRIX) {
2253         // The matrix isn't the identity one.
2254         appearanceDict.set("Matrix", rotationMatrix);
2255       }
2256 
2257       changes.put(newRef, {
2258         data: appearanceStream,
2259         xfa: null,
2260         needAppearances: false,
2261       });
2262     }
2263 
2264     dict.set("M", `D:${getModificationDate()}`);
2265   }
2266 
2267   async _getAppearance(evaluator, task, intent, annotationStorage) {
2268     if (this.data.password) {
2269       return null;
2270     }
2271     const storageEntry = annotationStorage?.get(this.data.id);
2272     let value, rotation;
2273     if (storageEntry) {
2274       value = storageEntry.formattedValue || storageEntry.value;
2275       rotation = storageEntry.rotation;
2276     }
2277 
2278     if (
2279       rotation === undefined &&
2280       value === undefined &&
2281       !this._needAppearances
2282     ) {
2283       if (!this._hasValueFromXFA || this.appearance) {
2284         // The annotation hasn't been rendered so use the appearance.
2285         return null;
2286       }
2287     }
2288 
2289     // Empty or it has a trailing whitespace.
2290     const colors = this.getBorderAndBackgroundAppearances(annotationStorage);
2291 
2292     if (value === undefined) {
2293       // The annotation has its value in XFA datasets but not in the V field.
2294       value = this.data.fieldValue;
2295       if (!value) {
2296         return `/Tx BMC q ${colors}Q EMC`;
2297       }
2298     }
2299 
2300     if (Array.isArray(value) && value.length === 1) {
2301       value = value[0];
2302     }
2303 
2304     assert(typeof value === "string", "Expected `value` to be a string.");
2305     value = value.trimEnd();
2306 
2307     if (this.data.combo) {
2308       // The value can be one of the exportValue or any other values.
2309       const option = this.data.options.find(
2310         ({ exportValue }) => value === exportValue
2311       );
2312       value = option?.displayValue || value;
2313     }
2314 
2315     if (value === "") {
2316       // the field is empty: nothing to render
2317       return `/Tx BMC q ${colors}Q EMC`;
2318     }
2319 
2320     if (rotation === undefined) {
2321       rotation = this.rotation;
2322     }
2323 
2324     let lineCount = -1;
2325     let lines;
2326 
2327     // We could have a text containing for example some sequences of chars and
2328     // their diacritics (e.g. "é".normalize("NFKD") shows 1 char when it's 2).
2329     // Positioning diacritics is really something we don't want to do here.
2330     // So if a font has a glyph for a acute accent and one for "e" then we won't
2331     // get any encoding issues but we'll render "e" and then "´".
2332     // It's why we normalize the string. We use NFC to preserve the initial
2333     // string, (e.g. "²".normalize("NFC") === "²"
2334     // but "²".normalize("NFKC") === "2").
2335     //
2336     // TODO: it isn't a perfect solution, some chars like "ẹ́" will be
2337     // decomposed into two chars ("ẹ" and "´"), so we should detect such
2338     // situations and then use either FakeUnicodeFont or set the
2339     // /NeedAppearances flag.
2340     if (this.data.multiLine) {
2341       lines = value.split(/\r\n?|\n/).map(line => line.normalize("NFC"));
2342       lineCount = lines.length;
2343     } else {
2344       lines = [value.replace(/\r\n?|\n/, "").normalize("NFC")];
2345     }
2346 
2347     const defaultPadding = 1;
2348     const defaultHPadding = 2;
2349     let { width: totalWidth, height: totalHeight } = this;
2350 
2351     if (rotation === 90 || rotation === 270) {
2352       [totalWidth, totalHeight] = [totalHeight, totalWidth];
2353     }
2354 
2355     if (!this._defaultAppearance) {
2356       // The DA is required and must be a string.
2357       // If there is no font named Helvetica in the resource dictionary,
2358       // the evaluator will fall back to a default font.
2359       // Doing so prevents exceptions and allows saving/printing
2360       // the file as expected.
2361       this.data.defaultAppearanceData = parseDefaultAppearance(
2362         (this._defaultAppearance = "/Helvetica 0 Tf 0 g")
2363       );
2364     }
2365 
2366     let font = await WidgetAnnotation._getFontData(
2367       evaluator,
2368       task,
2369       this.data.defaultAppearanceData,
2370       this._fieldResources.mergedResources
2371     );
2372 
2373     let defaultAppearance, fontSize, lineHeight;
2374     const encodedLines = [];
2375     let encodingError = false;
2376     for (const line of lines) {
2377       const encodedString = font.encodeString(line);
2378       if (encodedString.length > 1) {
2379         encodingError = true;
2380       }
2381       encodedLines.push(encodedString.join(""));
2382     }
2383 
2384     if (encodingError && intent & RenderingIntentFlag.SAVE) {
2385       // We don't have a way to render the field, so we just rely on the
2386       // /NeedAppearances trick to let the different sofware correctly render
2387       // this pdf.
2388       return { needAppearances: true };
2389     }
2390 
2391     // We check that the font is able to encode the string.
2392     if (encodingError && this._isOffscreenCanvasSupported) {
2393       // If it can't then we fallback on fake unicode font (mapped to sans-serif
2394       // for the rendering).
2395       // It means that a printed form can be rendered differently (it depends on
2396       // the sans-serif font) but at least we've something to render.
2397       // In an ideal world the associated font should correctly handle the
2398       // possible chars but a user can add a smiley or whatever.
2399       // We could try to embed a font but it means that we must have access
2400       // to the raw font file.
2401       const fontFamily = this.data.comb ? "monospace" : "sans-serif";
2402       const fakeUnicodeFont = new FakeUnicodeFont(evaluator.xref, fontFamily);
2403       const resources = fakeUnicodeFont.createFontResources(lines.join(""));
2404       const newFont = resources.getRaw("Font");
2405 
2406       if (this._fieldResources.mergedResources.has("Font")) {
2407         const oldFont = this._fieldResources.mergedResources.get("Font");
2408         for (const key of newFont.getKeys()) {
2409           oldFont.set(key, newFont.getRaw(key));
2410         }
2411       } else {
2412         this._fieldResources.mergedResources.set("Font", newFont);
2413       }
2414 
2415       const fontName = fakeUnicodeFont.fontName.name;
2416       font = await WidgetAnnotation._getFontData(
2417         evaluator,
2418         task,
2419         { fontName, fontSize: 0 },
2420         resources
2421       );
2422 
2423       for (let i = 0, ii = encodedLines.length; i < ii; i++) {
2424         encodedLines[i] = stringToUTF16String(lines[i]);
2425       }
2426 
2427       const savedDefaultAppearance = Object.assign(
2428         Object.create(null),
2429         this.data.defaultAppearanceData
2430       );
2431       this.data.defaultAppearanceData.fontSize = 0;
2432       this.data.defaultAppearanceData.fontName = fontName;
2433 
2434       [defaultAppearance, fontSize, lineHeight] = this._computeFontSize(
2435         totalHeight - 2 * defaultPadding,
2436         totalWidth - 2 * defaultHPadding,
2437         value,
2438         font,
2439         lineCount
2440       );
2441 
2442       this.data.defaultAppearanceData = savedDefaultAppearance;
2443     } else {
2444       if (!this._isOffscreenCanvasSupported) {
2445         warn(
2446           "_getAppearance: OffscreenCanvas is not supported, annotation may not render correctly."
2447         );
2448       }
2449 
2450       [defaultAppearance, fontSize, lineHeight] = this._computeFontSize(
2451         totalHeight - 2 * defaultPadding,
2452         totalWidth - 2 * defaultHPadding,
2453         value,
2454         font,
2455         lineCount
2456       );
2457     }
2458 
2459     let descent = font.descent;
2460     if (isNaN(descent)) {
2461       descent = BASELINE_FACTOR * lineHeight;
2462     } else {
2463       descent = Math.max(
2464         BASELINE_FACTOR * lineHeight,
2465         Math.abs(descent) * fontSize
2466       );
2467     }
2468 
2469     // Take into account the space we have to compute the default vertical
2470     // padding.
2471     const defaultVPadding = Math.min(
2472       Math.floor((totalHeight - fontSize) / 2),
2473       defaultPadding
2474     );
2475     const alignment = this.data.textAlignment;
2476 
2477     if (this.data.multiLine) {
2478       return this._getMultilineAppearance(
2479         defaultAppearance,
2480         encodedLines,
2481         font,
2482         fontSize,
2483         totalWidth,
2484         totalHeight,
2485         alignment,
2486         defaultHPadding,
2487         defaultVPadding,
2488         descent,
2489         lineHeight,
2490         annotationStorage
2491       );
2492     }
2493 
2494     if (this.data.comb) {
2495       return this._getCombAppearance(
2496         defaultAppearance,
2497         font,
2498         encodedLines[0],
2499         fontSize,
2500         totalWidth,
2501         totalHeight,
2502         defaultHPadding,
2503         defaultVPadding,
2504         descent,
2505         lineHeight,
2506         annotationStorage
2507       );
2508     }
2509 
2510     const bottomPadding = defaultVPadding + descent;
2511     if (alignment === 0 || alignment > 2) {
2512       // Left alignment: nothing to do
2513       return (
2514         `/Tx BMC q ${colors}BT ` +
2515         defaultAppearance +
2516         ` 1 0 0 1 ${numberToString(defaultHPadding)} ${numberToString(
2517           bottomPadding
2518         )} Tm (${escapeString(encodedLines[0])}) Tj` +
2519         " ET Q EMC"
2520       );
2521     }
2522 
2523     const prevInfo = { shift: 0 };
2524     const renderedText = this._renderText(
2525       encodedLines[0],
2526       font,
2527       fontSize,
2528       totalWidth,
2529       alignment,
2530       prevInfo,
2531       defaultHPadding,
2532       bottomPadding
2533     );
2534     return (
2535       `/Tx BMC q ${colors}BT ` +
2536       defaultAppearance +
2537       ` 1 0 0 1 0 0 Tm ${renderedText}` +
2538       " ET Q EMC"
2539     );
2540   }
2541 
2542   static async _getFontData(evaluator, task, appearanceData, resources) {
2543     const operatorList = new OperatorList();
2544     const initialState = {
2545       font: null,
2546       clone() {
2547         return this;
2548       },
2549     };
2550 
2551     const { fontName, fontSize } = appearanceData;
2552     await evaluator.handleSetFont(
2553       resources,
2554       [fontName && Name.get(fontName), fontSize],
2555       /* fontRef = */ null,
2556       operatorList,
2557       task,
2558       initialState,
2559       /* fallbackFontDict = */ null
2560     );
2561 
2562     return initialState.font;
2563   }
2564 
2565   _getTextWidth(text, font) {
2566     return Math.sumPrecise(font.charsToGlyphs(text).map(g => g.width)) / 1000;
2567   }
2568 
2569   _computeFontSize(height, width, text, font, lineCount) {
2570     let { fontSize } = this.data.defaultAppearanceData;
2571     let lineHeight = (fontSize || 12) * LINE_FACTOR,
2572       numberOfLines = Math.round(height / lineHeight);
2573 
2574     if (!fontSize) {
2575       // A zero value for size means that the font shall be auto-sized:
2576       // its size shall be computed as a function of the height of the
2577       // annotation rectangle (see 12.7.3.3).
2578 
2579       const roundWithTwoDigits = x => Math.floor(x * 100) / 100;
2580 
2581       if (lineCount === -1) {
2582         // Get the text width for a font size of 1.
2583         const textWidth = this._getTextWidth(text, font);
2584 
2585         // width / textWidth is the max font size to fit the width.
2586         // height / LINE_FACTOR is the max font size to fit the height.
2587         fontSize = roundWithTwoDigits(
2588           Math.min(height / LINE_FACTOR, width / textWidth)
2589         );
2590         numberOfLines = 1;
2591       } else {
2592         const lines = text.split(/\r\n?|\n/);
2593         const cachedLines = [];
2594         for (const line of lines) {
2595           const encoded = font.encodeString(line).join("");
2596           const glyphs = font.charsToGlyphs(encoded);
2597           const positions = font.getCharPositions(encoded);
2598           cachedLines.push({
2599             line: encoded,
2600             glyphs,
2601             positions,
2602           });
2603         }
2604 
2605         const isTooBig = fsize => {
2606           // Return true when the text doesn't fit the given height.
2607           let totalHeight = 0;
2608           for (const cache of cachedLines) {
2609             const chunks = this._splitLine(null, font, fsize, width, cache);
2610             totalHeight += chunks.length * fsize;
2611             if (totalHeight > height) {
2612               return true;
2613             }
2614           }
2615           return false;
2616         };
2617 
2618         // Hard to guess how many lines there are.
2619         // The field may have been sized to have 10 lines
2620         // and the user entered only 1 so if we get font size from
2621         // height and number of lines then we'll get something too big.
2622         // So we compute a fake number of lines based on height and
2623         // a font size equal to 12 (this is the default font size in
2624         // Acrobat).
2625         // Then we'll adjust font size to what we have really.
2626         numberOfLines = Math.max(numberOfLines, lineCount);
2627 
2628         while (true) {
2629           lineHeight = height / numberOfLines;
2630           fontSize = roundWithTwoDigits(lineHeight / LINE_FACTOR);
2631 
2632           if (isTooBig(fontSize)) {
2633             numberOfLines++;
2634             continue;
2635           }
2636 
2637           break;
2638         }
2639       }
2640 
2641       const { fontName, fontColor } = this.data.defaultAppearanceData;
2642       this._defaultAppearance = createDefaultAppearance({
2643         fontSize,
2644         fontName,
2645         fontColor,
2646       });
2647     }
2648 
2649     return [this._defaultAppearance, fontSize, height / numberOfLines];
2650   }
2651 
2652   _renderText(
2653     text,
2654     font,
2655     fontSize,
2656     totalWidth,
2657     alignment,
2658     prevInfo,
2659     hPadding,
2660     vPadding
2661   ) {
2662     // TODO: we need to take into account (if possible) how the text
2663     // is rendered. For example in arabic, the cumulated width of some
2664     // glyphs isn't equal to the width of the rendered glyphs because
2665     // of ligatures.
2666     let shift;
2667     if (alignment === 1) {
2668       // Center
2669       const width = this._getTextWidth(text, font) * fontSize;
2670       shift = (totalWidth - width) / 2;
2671     } else if (alignment === 2) {
2672       // Right
2673       const width = this._getTextWidth(text, font) * fontSize;
2674       shift = totalWidth - width - hPadding;
2675     } else {
2676       shift = hPadding;
2677     }
2678     const shiftStr = numberToString(shift - prevInfo.shift);
2679     prevInfo.shift = shift;
2680     vPadding = numberToString(vPadding);
2681 
2682     return `${shiftStr} ${vPadding} Td (${escapeString(text)}) Tj`;
2683   }
2684 
2685   /**
2686    * @private
2687    */
2688   _getSaveFieldResources(xref) {
2689     if (typeof PDFJSDev === "undefined" || PDFJSDev.test("TESTING")) {
2690       assert(
2691         this.data.defaultAppearanceData,
2692         "Expected `_defaultAppearanceData` to have been set."
2693       );
2694     }
2695     const { localResources, appearanceResources, acroFormResources } =
2696       this._fieldResources;
2697 
2698     const fontName = this.data.defaultAppearanceData?.fontName;
2699     if (!fontName) {
2700       return localResources || Dict.empty;
2701     }
2702 
2703     for (const resources of [localResources, appearanceResources]) {
2704       if (resources instanceof Dict) {
2705         const localFont = resources.get("Font");
2706         if (localFont instanceof Dict && localFont.has(fontName)) {
2707           return resources;
2708         }
2709       }
2710     }
2711     if (acroFormResources instanceof Dict) {
2712       const acroFormFont = acroFormResources.get("Font");
2713       if (acroFormFont instanceof Dict && acroFormFont.has(fontName)) {
2714         const subFontDict = new Dict(xref);
2715         subFontDict.set(fontName, acroFormFont.getRaw(fontName));
2716 
2717         const subResourcesDict = new Dict(xref);
2718         subResourcesDict.set("Font", subFontDict);
2719 
2720         return Dict.merge({
2721           xref,
2722           dictArray: [subResourcesDict, localResources],
2723           mergeSubDicts: true,
2724         });
2725       }
2726     }
2727     return localResources || Dict.empty;
2728   }
2729 
2730   getFieldObject() {
2731     return null;
2732   }
2733 }
2734 
2735 class TextWidgetAnnotation extends WidgetAnnotation {
2736   constructor(params) {
2737     super(params);
2738 
2739     const { dict } = params;
2740 
2741     if (dict.has("PMD")) {
2742       // It's used to display a barcode but it isn't specified so we just hide
2743       // it to avoid any confusion.
2744       this.flags |= AnnotationFlag.HIDDEN;
2745       this.data.hidden = true;
2746       warn("Barcodes are not supported");
2747     }
2748 
2749     this.data.hasOwnCanvas = this.data.readOnly && !this.data.noHTML;
2750     this._hasText = true;
2751 
2752     // The field value is always a string.
2753     if (typeof this.data.fieldValue !== "string") {
2754       this.data.fieldValue = "";
2755     }
2756 
2757     // Determine the alignment of text in the field.
2758     let alignment = getInheritableProperty({ dict, key: "Q" });
2759     if (!Number.isInteger(alignment) || alignment < 0 || alignment > 2) {
2760       alignment = null;
2761     }
2762     this.data.textAlignment = alignment;
2763 
2764     // Determine the maximum length of text in the field.
2765     let maximumLength = getInheritableProperty({ dict, key: "MaxLen" });
2766     if (!Number.isInteger(maximumLength) || maximumLength < 0) {
2767       maximumLength = 0;
2768     }
2769     this.data.maxLen = maximumLength;
2770 
2771     // Process field flags for the display layer.
2772     this.data.multiLine = this.hasFieldFlag(AnnotationFieldFlag.MULTILINE);
2773     this.data.comb =
2774       this.hasFieldFlag(AnnotationFieldFlag.COMB) &&
2775       !this.data.multiLine &&
2776       !this.data.password &&
2777       !this.hasFieldFlag(AnnotationFieldFlag.FILESELECT) &&
2778       this.data.maxLen !== 0;
2779     this.data.doNotScroll = this.hasFieldFlag(AnnotationFieldFlag.DONOTSCROLL);
2780   }
2781 
2782   get hasTextContent() {
2783     return !!this.appearance && !this._needAppearances;
2784   }
2785 
2786   _getCombAppearance(
2787     defaultAppearance,
2788     font,
2789     text,
2790     fontSize,
2791     width,
2792     height,
2793     hPadding,
2794     vPadding,
2795     descent,
2796     lineHeight,
2797     annotationStorage
2798   ) {
2799     const combWidth = width / this.data.maxLen;
2800     // Empty or it has a trailing whitespace.
2801     const colors = this.getBorderAndBackgroundAppearances(annotationStorage);
2802 
2803     const buf = [];
2804     const positions = font.getCharPositions(text);
2805     for (const [start, end] of positions) {
2806       buf.push(`(${escapeString(text.substring(start, end))}) Tj`);
2807     }
2808 
2809     const renderedComb = buf.join(` ${numberToString(combWidth)} 0 Td `);
2810     return (
2811       `/Tx BMC q ${colors}BT ` +
2812       defaultAppearance +
2813       ` 1 0 0 1 ${numberToString(hPadding)} ${numberToString(
2814         vPadding + descent
2815       )} Tm ${renderedComb}` +
2816       " ET Q EMC"
2817     );
2818   }
2819 
2820   _getMultilineAppearance(
2821     defaultAppearance,
2822     lines,
2823     font,
2824     fontSize,
2825     width,
2826     height,
2827     alignment,
2828     hPadding,
2829     vPadding,
2830     descent,
2831     lineHeight,
2832     annotationStorage
2833   ) {
2834     const buf = [];
2835     const totalWidth = width - 2 * hPadding;
2836     const prevInfo = { shift: 0 };
2837     for (let i = 0, ii = lines.length; i < ii; i++) {
2838       const line = lines[i];
2839       const chunks = this._splitLine(line, font, fontSize, totalWidth);
2840       for (let j = 0, jj = chunks.length; j < jj; j++) {
2841         const chunk = chunks[j];
2842         const vShift =
2843           i === 0 && j === 0 ? -vPadding - (lineHeight - descent) : -lineHeight;
2844         buf.push(
2845           this._renderText(
2846             chunk,
2847             font,
2848             fontSize,
2849             width,
2850             alignment,
2851             prevInfo,
2852             hPadding,
2853             vShift
2854           )
2855         );
2856       }
2857     }
2858 
2859     // Empty or it has a trailing whitespace.
2860     const colors = this.getBorderAndBackgroundAppearances(annotationStorage);
2861     const renderedText = buf.join("\n");
2862 
2863     return (
2864       `/Tx BMC q ${colors}BT ` +
2865       defaultAppearance +
2866       ` 1 0 0 1 0 ${numberToString(height)} Tm ${renderedText}` +
2867       " ET Q EMC"
2868     );
2869   }
2870 
2871   _splitLine(line, font, fontSize, width, cache = {}) {
2872     line = cache.line || line;
2873 
2874     const glyphs = cache.glyphs || font.charsToGlyphs(line);
2875 
2876     if (glyphs.length <= 1) {
2877       // Nothing to split
2878       return [line];
2879     }
2880 
2881     const positions = cache.positions || font.getCharPositions(line);
2882     const scale = fontSize / 1000;
2883     const chunks = [];
2884 
2885     let lastSpacePosInStringStart = -1,
2886       lastSpacePosInStringEnd = -1,
2887       lastSpacePos = -1,
2888       startChunk = 0,
2889       currentWidth = 0;
2890 
2891     for (let i = 0, ii = glyphs.length; i < ii; i++) {
2892       const [start, end] = positions[i];
2893       const glyph = glyphs[i];
2894       const glyphWidth = glyph.width * scale;
2895       if (glyph.unicode === " ") {
2896         if (currentWidth + glyphWidth > width) {
2897           // We can break here
2898           chunks.push(line.substring(startChunk, start));
2899           startChunk = start;
2900           currentWidth = glyphWidth;
2901           lastSpacePosInStringStart = -1;
2902           lastSpacePos = -1;
2903         } else {
2904           currentWidth += glyphWidth;
2905           lastSpacePosInStringStart = start;
2906           lastSpacePosInStringEnd = end;
2907           lastSpacePos = i;
2908         }
2909       } else if (currentWidth + glyphWidth > width) {
2910         // We must break to the last white position (if available)
2911         if (lastSpacePosInStringStart !== -1) {
2912           chunks.push(line.substring(startChunk, lastSpacePosInStringEnd));
2913           startChunk = lastSpacePosInStringEnd;
2914           i = lastSpacePos + 1;
2915           lastSpacePosInStringStart = -1;
2916           currentWidth = 0;
2917         } else {
2918           // Just break in the middle of the word
2919           chunks.push(line.substring(startChunk, start));
2920           startChunk = start;
2921           currentWidth = glyphWidth;
2922         }
2923       } else {
2924         currentWidth += glyphWidth;
2925       }
2926     }
2927 
2928     if (startChunk < line.length) {
2929       chunks.push(line.substring(startChunk, line.length));
2930     }
2931 
2932     return chunks;
2933   }
2934 
2935   async extractTextContent(evaluator, task, viewBox) {
2936     await super.extractTextContent(evaluator, task, viewBox);
2937     const text = this.data.textContent;
2938     if (!text) {
2939       return;
2940     }
2941 
2942     // The text extractor doesn't handle empty lines correctly, so if the
2943     // content we get is more or less (modulo whitespaces) the same as the
2944     // field value we just ignore it.
2945     const allText = text.join("\n");
2946     if (allText === this.data.fieldValue) {
2947       return;
2948     }
2949     const regex = allText.replaceAll(/([.*+?^${}()|[\]\\])|(\s+)/g, (_m, p1) =>
2950       p1 ? `\\${p1}` : "\\s+"
2951     );
2952     if (new RegExp(`^\\s*${regex}\\s*$`).test(this.data.fieldValue)) {
2953       this.data.textContent = this.data.fieldValue.split("\n");
2954     }
2955   }
2956 
2957   getFieldObject() {
2958     return {
2959       id: this.data.id,
2960       value: this.data.fieldValue,
2961       defaultValue: this.data.defaultFieldValue || "",
2962       multiline: this.data.multiLine,
2963       password: this.data.password,
2964       charLimit: this.data.maxLen,
2965       comb: this.data.comb,
2966       editable: !this.data.readOnly,
2967       hidden: this.data.hidden,
2968       name: this.data.fieldName,
2969       rect: this.data.rect,
2970       actions: this.data.actions,
2971       page: this.data.pageIndex,
2972       strokeColor: this.data.borderColor,
2973       fillColor: this.data.backgroundColor,
2974       rotation: this.rotation,
2975       type: "text",
2976     };
2977   }
2978 }
2979 
2980 class ButtonWidgetAnnotation extends WidgetAnnotation {
2981   constructor(params) {
2982     super(params);
2983 
2984     this.checkedAppearance = null;
2985     this.uncheckedAppearance = null;
2986 
2987     const isRadio = this.hasFieldFlag(AnnotationFieldFlag.RADIO),
2988       isPushButton = this.hasFieldFlag(AnnotationFieldFlag.PUSHBUTTON);
2989 
2990     this.data.checkBox = !isRadio && !isPushButton;
2991     this.data.radioButton = isRadio && !isPushButton;
2992     this.data.pushButton = isPushButton;
2993     this.data.isTooltipOnly = false;
2994 
2995     if (this.data.checkBox) {
2996       this._processCheckBox(params);
2997     } else if (this.data.radioButton) {
2998       this._processRadioButton(params);
2999     } else if (this.data.pushButton) {
3000       this.data.hasOwnCanvas = true;
3001       this.data.noHTML = false;
3002       this._processPushButton(params);
3003     } else {
3004       warn("Invalid field flags for button widget annotation");
3005     }
3006   }
3007 
3008   async getOperatorList(evaluator, task, intent, annotationStorage) {
3009     if (this.data.pushButton) {
3010       return super.getOperatorList(
3011         evaluator,
3012         task,
3013         intent,
3014         false, // we use normalAppearance to render the button
3015         annotationStorage
3016       );
3017     }
3018 
3019     let value = null;
3020     let rotation = null;
3021     if (annotationStorage) {
3022       const storageEntry = annotationStorage.get(this.data.id);
3023       value = storageEntry ? storageEntry.value : null;
3024       rotation = storageEntry ? storageEntry.rotation : null;
3025     }
3026 
3027     if (value === null && this.appearance) {
3028       // Nothing in the annotationStorage.
3029       // But we've a default appearance so use it.
3030       return super.getOperatorList(evaluator, task, intent, annotationStorage);
3031     }
3032 
3033     if (value === null || value === undefined) {
3034       // There is no default appearance so use the one derived
3035       // from the field value.
3036       value = this.data.checkBox
3037         ? this.data.fieldValue === this.data.exportValue
3038         : this.data.fieldValue === this.data.buttonValue;
3039     }
3040 
3041     const appearance = value
3042       ? this.checkedAppearance
3043       : this.uncheckedAppearance;
3044     if (appearance) {
3045       const savedAppearance = this.appearance;
3046       const savedMatrix = lookupMatrix(
3047         appearance.dict.getArray("Matrix"),
3048         IDENTITY_MATRIX
3049       );
3050 
3051       if (rotation) {
3052         appearance.dict.set(
3053           "Matrix",
3054           this.getRotationMatrix(annotationStorage)
3055         );
3056       }
3057 
3058       this.appearance = appearance;
3059       const operatorList = super.getOperatorList(
3060         evaluator,
3061         task,
3062         intent,
3063         annotationStorage
3064       );
3065       this.appearance = savedAppearance;
3066       appearance.dict.set("Matrix", savedMatrix);
3067       return operatorList;
3068     }
3069 
3070     // No appearance
3071     return {
3072       opList: new OperatorList(),
3073       separateForm: false,
3074       separateCanvas: false,
3075     };
3076   }
3077 
3078   async save(evaluator, task, annotationStorage, changes) {
3079     if (this.data.checkBox) {
3080       this._saveCheckbox(evaluator, task, annotationStorage, changes);
3081       return;
3082     }
3083 
3084     if (this.data.radioButton) {
3085       this._saveRadioButton(evaluator, task, annotationStorage, changes);
3086     }
3087   }
3088 
3089   async _saveCheckbox(evaluator, task, annotationStorage, changes) {
3090     if (!annotationStorage) {
3091       return;
3092     }
3093     const storageEntry = annotationStorage.get(this.data.id);
3094     const flags = this._buildFlags(storageEntry?.noView, storageEntry?.noPrint);
3095     let rotation = storageEntry?.rotation,
3096       value = storageEntry?.value;
3097 
3098     if (rotation === undefined && flags === undefined) {
3099       if (value === undefined) {
3100         return;
3101       }
3102 
3103       const defaultValue = this.data.fieldValue === this.data.exportValue;
3104       if (defaultValue === value) {
3105         return;
3106       }
3107     }
3108 
3109     let dict = evaluator.xref.fetchIfRef(this.ref);
3110     if (!(dict instanceof Dict)) {
3111       return;
3112     }
3113     dict = dict.clone();
3114 
3115     if (rotation === undefined) {
3116       rotation = this.rotation;
3117     }
3118     if (value === undefined) {
3119       value = this.data.fieldValue === this.data.exportValue;
3120     }
3121 
3122     const xfa = {
3123       path: this.data.fieldName,
3124       value: value ? this.data.exportValue : "",
3125     };
3126 
3127     const name = Name.get(value ? this.data.exportValue : "Off");
3128     this.setValue(dict, name, evaluator.xref, changes);
3129 
3130     dict.set("AS", name);
3131     dict.set("M", `D:${getModificationDate()}`);
3132     if (flags !== undefined) {
3133       dict.set("F", flags);
3134     }
3135 
3136     const maybeMK = this._getMKDict(rotation);
3137     if (maybeMK) {
3138       dict.set("MK", maybeMK);
3139     }
3140 
3141     changes.put(this.ref, {
3142       data: dict,
3143       xfa,
3144       needAppearances: false,
3145     });
3146   }
3147 
3148   async _saveRadioButton(evaluator, task, annotationStorage, changes) {
3149     if (!annotationStorage) {
3150       return;
3151     }
3152     const storageEntry = annotationStorage.get(this.data.id);
3153     const flags = this._buildFlags(storageEntry?.noView, storageEntry?.noPrint);
3154     let rotation = storageEntry?.rotation,
3155       value = storageEntry?.value;
3156 
3157     if (rotation === undefined && flags === undefined) {
3158       if (value === undefined) {
3159         return;
3160       }
3161 
3162       const defaultValue = this.data.fieldValue === this.data.buttonValue;
3163       if (defaultValue === value) {
3164         return;
3165       }
3166     }
3167 
3168     let dict = evaluator.xref.fetchIfRef(this.ref);
3169     if (!(dict instanceof Dict)) {
3170       return;
3171     }
3172     dict = dict.clone();
3173 
3174     if (value === undefined) {
3175       value = this.data.fieldValue === this.data.buttonValue;
3176     }
3177 
3178     if (rotation === undefined) {
3179       rotation = this.rotation;
3180     }
3181 
3182     const xfa = {
3183       path: this.data.fieldName,
3184       value: value ? this.data.buttonValue : "",
3185     };
3186 
3187     const name = Name.get(value ? this.data.buttonValue : "Off");
3188     if (value) {
3189       this.setValue(dict, name, evaluator.xref, changes);
3190     }
3191 
3192     dict.set("AS", name);
3193     dict.set("M", `D:${getModificationDate()}`);
3194     if (flags !== undefined) {
3195       dict.set("F", flags);
3196     }
3197 
3198     const maybeMK = this._getMKDict(rotation);
3199     if (maybeMK) {
3200       dict.set("MK", maybeMK);
3201     }
3202 
3203     changes.put(this.ref, {
3204       data: dict,
3205       xfa,
3206       needAppearances: false,
3207     });
3208   }
3209 
3210   _getDefaultCheckedAppearance(params, type) {
3211     const { width, height } = this;
3212     const bbox = [0, 0, width, height];
3213 
3214     // Ratio used to have a mark slightly smaller than the bbox.
3215     const FONT_RATIO = 0.8;
3216     const fontSize = Math.min(width, height) * FONT_RATIO;
3217 
3218     // Char Metrics
3219     // Widths came from widths for ZapfDingbats.
3220     // Heights are guessed with Fontforge and FoxitDingbats.pfb.
3221     let metrics, char;
3222     if (type === "check") {
3223       // Char 33 (2713 in unicode)
3224       metrics = {
3225         width: 0.755 * fontSize,
3226         height: 0.705 * fontSize,
3227       };
3228       char = "\x33";
3229     } else if (type === "disc") {
3230       // Char 6C (25CF in unicode)
3231       metrics = {
3232         width: 0.791 * fontSize,
3233         height: 0.705 * fontSize,
3234       };
3235       char = "\x6C";
3236     } else {
3237       unreachable(`_getDefaultCheckedAppearance - unsupported type: ${type}`);
3238     }
3239 
3240     // Values to center the glyph in the bbox.
3241     const xShift = numberToString((width - metrics.width) / 2);
3242     const yShift = numberToString((height - metrics.height) / 2);
3243 
3244     const appearance = `q BT /PdfJsZaDb ${fontSize} Tf 0 g ${xShift} ${yShift} Td (${char}) Tj ET Q`;
3245 
3246     const appearanceStreamDict = new Dict(params.xref);
3247     appearanceStreamDict.set("FormType", 1);
3248     appearanceStreamDict.set("Subtype", Name.get("Form"));
3249     appearanceStreamDict.set("Type", Name.get("XObject"));
3250     appearanceStreamDict.set("BBox", bbox);
3251     appearanceStreamDict.set("Matrix", [1, 0, 0, 1, 0, 0]);
3252     appearanceStreamDict.set("Length", appearance.length);
3253 
3254     const resources = new Dict(params.xref);
3255     const font = new Dict(params.xref);
3256     font.set("PdfJsZaDb", this.fallbackFontDict);
3257     resources.set("Font", font);
3258 
3259     appearanceStreamDict.set("Resources", resources);
3260 
3261     this.checkedAppearance = new StringStream(appearance);
3262     this.checkedAppearance.dict = appearanceStreamDict;
3263 
3264     this._streams.push(this.checkedAppearance);
3265   }
3266 
3267   _processCheckBox(params) {
3268     const customAppearance = params.dict.get("AP");
3269     if (!(customAppearance instanceof Dict)) {
3270       return;
3271     }
3272 
3273     const normalAppearance = customAppearance.get("N");
3274     if (!(normalAppearance instanceof Dict)) {
3275       return;
3276     }
3277 
3278     // See https://bugzilla.mozilla.org/show_bug.cgi?id=1722036.
3279     // If we've an AS and a V then take AS.
3280     const asValue = this._decodeFormValue(params.dict.get("AS"));
3281     if (typeof asValue === "string") {
3282       this.data.fieldValue = asValue;
3283     }
3284 
3285     const yes =
3286       this.data.fieldValue !== null && this.data.fieldValue !== "Off"
3287         ? this.data.fieldValue
3288         : "Yes";
3289 
3290     const exportValues = normalAppearance.getKeys();
3291     if (exportValues.length === 0) {
3292       exportValues.push("Off", yes);
3293     } else if (exportValues.length === 1) {
3294       if (exportValues[0] === "Off") {
3295         exportValues.push(yes);
3296       } else {
3297         exportValues.unshift("Off");
3298       }
3299     } else if (exportValues.includes(yes)) {
3300       exportValues.length = 0;
3301       exportValues.push("Off", yes);
3302     } else {
3303       const otherYes = exportValues.find(v => v !== "Off");
3304       exportValues.length = 0;
3305       exportValues.push("Off", otherYes);
3306     }
3307 
3308     // Don't use a "V" entry pointing to a non-existent appearance state,
3309     // see e.g. bug1720411.pdf where it's an *empty* Name-instance.
3310     if (!exportValues.includes(this.data.fieldValue)) {
3311       this.data.fieldValue = "Off";
3312     }
3313 
3314     this.data.exportValue = exportValues[1];
3315 
3316     const checkedAppearance = normalAppearance.get(this.data.exportValue);
3317     this.checkedAppearance =
3318       checkedAppearance instanceof BaseStream ? checkedAppearance : null;
3319     const uncheckedAppearance = normalAppearance.get("Off");
3320     this.uncheckedAppearance =
3321       uncheckedAppearance instanceof BaseStream ? uncheckedAppearance : null;
3322 
3323     if (this.checkedAppearance) {
3324       this._streams.push(this.checkedAppearance);
3325     } else {
3326       this._getDefaultCheckedAppearance(params, "check");
3327     }
3328     if (this.uncheckedAppearance) {
3329       this._streams.push(this.uncheckedAppearance);
3330     }
3331     this._fallbackFontDict = this.fallbackFontDict;
3332     if (this.data.defaultFieldValue === null) {
3333       this.data.defaultFieldValue = "Off";
3334     }
3335   }
3336 
3337   _processRadioButton(params) {
3338     this.data.buttonValue = null;
3339 
3340     // The parent field's `V` entry holds a `Name` object with the appearance
3341     // state of whichever child field is currently in the "on" state.
3342     const fieldParent = params.dict.get("Parent");
3343     if (fieldParent instanceof Dict) {
3344       this.parent = params.dict.getRaw("Parent");
3345       const fieldParentValue = fieldParent.get("V");
3346       if (fieldParentValue instanceof Name) {
3347         this.data.fieldValue = this._decodeFormValue(fieldParentValue);
3348       }
3349     }
3350 
3351     // The button's value corresponds to its appearance state.
3352     const appearanceStates = params.dict.get("AP");
3353     if (!(appearanceStates instanceof Dict)) {
3354       return;
3355     }
3356     const normalAppearance = appearanceStates.get("N");
3357     if (!(normalAppearance instanceof Dict)) {
3358       return;
3359     }
3360     for (const key of normalAppearance.getKeys()) {
3361       if (key !== "Off") {
3362         this.data.buttonValue = this._decodeFormValue(key);
3363         break;
3364       }
3365     }
3366 
3367     const checkedAppearance = normalAppearance.get(this.data.buttonValue);
3368     this.checkedAppearance =
3369       checkedAppearance instanceof BaseStream ? checkedAppearance : null;
3370     const uncheckedAppearance = normalAppearance.get("Off");
3371     this.uncheckedAppearance =
3372       uncheckedAppearance instanceof BaseStream ? uncheckedAppearance : null;
3373 
3374     if (this.checkedAppearance) {
3375       this._streams.push(this.checkedAppearance);
3376     } else {
3377       this._getDefaultCheckedAppearance(params, "disc");
3378     }
3379     if (this.uncheckedAppearance) {
3380       this._streams.push(this.uncheckedAppearance);
3381     }
3382     this._fallbackFontDict = this.fallbackFontDict;
3383     if (this.data.defaultFieldValue === null) {
3384       this.data.defaultFieldValue = "Off";
3385     }
3386   }
3387 
3388   _processPushButton(params) {
3389     const { dict, annotationGlobals } = params;
3390 
3391     if (!dict.has("A") && !dict.has("AA") && !this.data.alternativeText) {
3392       warn("Push buttons without action dictionaries are not supported");
3393       return;
3394     }
3395 
3396     this.data.isTooltipOnly = !dict.has("A") && !dict.has("AA");
3397 
3398     Catalog.parseDestDictionary({
3399       destDict: dict,
3400       resultObj: this.data,
3401       docBaseUrl: annotationGlobals.baseUrl,
3402       docAttachments: annotationGlobals.attachments,
3403     });
3404   }
3405 
3406   getFieldObject() {
3407     let type = "button";
3408     let exportValues;
3409     if (this.data.checkBox) {
3410       type = "checkbox";
3411       exportValues = this.data.exportValue;
3412     } else if (this.data.radioButton) {
3413       type = "radiobutton";
3414       exportValues = this.data.buttonValue;
3415     }
3416     return {
3417       id: this.data.id,
3418       value: this.data.fieldValue || "Off",
3419       defaultValue: this.data.defaultFieldValue,
3420       exportValues,
3421       editable: !this.data.readOnly,
3422       name: this.data.fieldName,
3423       rect: this.data.rect,
3424       hidden: this.data.hidden,
3425       actions: this.data.actions,
3426       page: this.data.pageIndex,
3427       strokeColor: this.data.borderColor,
3428       fillColor: this.data.backgroundColor,
3429       rotation: this.rotation,
3430       type,
3431     };
3432   }
3433 
3434   get fallbackFontDict() {
3435     const dict = new Dict();
3436     dict.set("BaseFont", Name.get("ZapfDingbats"));
3437     dict.set("Type", Name.get("FallbackType"));
3438     dict.set("Subtype", Name.get("FallbackType"));
3439     dict.set("Encoding", Name.get("ZapfDingbatsEncoding"));
3440 
3441     return shadow(this, "fallbackFontDict", dict);
3442   }
3443 }
3444 
3445 class ChoiceWidgetAnnotation extends WidgetAnnotation {
3446   constructor(params) {
3447     super(params);
3448 
3449     const { dict, xref } = params;
3450 
3451     this.indices = dict.getArray("I");
3452     this.hasIndices = Array.isArray(this.indices) && this.indices.length > 0;
3453 
3454     // Determine the options. The options array may consist of strings or
3455     // arrays. If the array consists of arrays, then the first element of
3456     // each array is the export value and the second element of each array is
3457     // the display value. If the array consists of strings, then these
3458     // represent both the export and display value. In this case, we convert
3459     // it to an array of arrays as well for convenience in the display layer.
3460     // Note that the specification does not state that the `Opt` field is
3461     // inheritable, but in practice PDF generators do make annotations
3462     // inherit the options from a parent annotation (issue 8094).
3463     this.data.options = [];
3464 
3465     const options = getInheritableProperty({ dict, key: "Opt" });
3466     if (Array.isArray(options)) {
3467       for (let i = 0, ii = options.length; i < ii; i++) {
3468         const option = xref.fetchIfRef(options[i]);
3469         const isOptionArray = Array.isArray(option);
3470 
3471         this.data.options[i] = {
3472           exportValue: this._decodeFormValue(
3473             isOptionArray ? xref.fetchIfRef(option[0]) : option
3474           ),
3475           displayValue: this._decodeFormValue(
3476             isOptionArray ? xref.fetchIfRef(option[1]) : option
3477           ),
3478         };
3479       }
3480     }
3481 
3482     if (!this.hasIndices) {
3483       // The field value can be `null` if no item is selected, a string if one
3484       // item is selected or an array of strings if multiple items are selected.
3485       // For consistency in the API and convenience in the display layer, we
3486       // always make the field value an array with zero, one or multiple items.
3487       if (typeof this.data.fieldValue === "string") {
3488         this.data.fieldValue = [this.data.fieldValue];
3489       } else if (!this.data.fieldValue) {
3490         this.data.fieldValue = [];
3491       }
3492     } else {
3493       // The specs say that we should have an indices array only with
3494       // multiselectable Choice and the "V" entry should have the
3495       // precedence, but Acrobat itself is using it whatever the
3496       // the "V" entry is (see bug 1770750).
3497       this.data.fieldValue = [];
3498       const ii = this.data.options.length;
3499       for (const i of this.indices) {
3500         if (Number.isInteger(i) && i >= 0 && i < ii) {
3501           this.data.fieldValue.push(this.data.options[i].exportValue);
3502         }
3503       }
3504     }
3505 
3506     // It's a workaround for the issue #19083.
3507     // Normally a choice widget is a mix of a text field and a listbox,
3508     // So in the case where the V entry isn't an option we should just set it
3509     // as the text field value.
3510     if (this.data.options.length === 0 && this.data.fieldValue.length > 0) {
3511       // If there are no options, then the field value is the only option.
3512       this.data.options = this.data.fieldValue.map(value => ({
3513         exportValue: value,
3514         displayValue: value,
3515       }));
3516     }
3517 
3518     // Process field flags for the display layer.
3519     this.data.combo = this.hasFieldFlag(AnnotationFieldFlag.COMBO);
3520     this.data.multiSelect = this.hasFieldFlag(AnnotationFieldFlag.MULTISELECT);
3521     this._hasText = true;
3522   }
3523 
3524   getFieldObject() {
3525     const type = this.data.combo ? "combobox" : "listbox";
3526     const value =
3527       this.data.fieldValue.length > 0 ? this.data.fieldValue[0] : null;
3528     return {
3529       id: this.data.id,
3530       value,
3531       defaultValue: this.data.defaultFieldValue,
3532       editable: !this.data.readOnly,
3533       name: this.data.fieldName,
3534       rect: this.data.rect,
3535       numItems: this.data.fieldValue.length,
3536       multipleSelection: this.data.multiSelect,
3537       hidden: this.data.hidden,
3538       actions: this.data.actions,
3539       items: this.data.options,
3540       page: this.data.pageIndex,
3541       strokeColor: this.data.borderColor,
3542       fillColor: this.data.backgroundColor,
3543       rotation: this.rotation,
3544       type,
3545     };
3546   }
3547 
3548   amendSavedDict(annotationStorage, dict) {
3549     if (!this.hasIndices) {
3550       return;
3551     }
3552     let values = annotationStorage?.get(this.data.id)?.value;
3553     if (!Array.isArray(values)) {
3554       values = [values];
3555     }
3556     const indices = [];
3557     const { options } = this.data;
3558     for (let i = 0, j = 0, ii = options.length; i < ii; i++) {
3559       if (options[i].exportValue === values[j]) {
3560         indices.push(i);
3561         j += 1;
3562       }
3563     }
3564     dict.set("I", indices);
3565   }
3566 
3567   async _getAppearance(evaluator, task, intent, annotationStorage) {
3568     if (this.data.combo) {
3569       return super._getAppearance(evaluator, task, intent, annotationStorage);
3570     }
3571 
3572     let exportedValue, rotation;
3573     const storageEntry = annotationStorage?.get(this.data.id);
3574     if (storageEntry) {
3575       rotation = storageEntry.rotation;
3576       exportedValue = storageEntry.value;
3577     }
3578 
3579     if (
3580       rotation === undefined &&
3581       exportedValue === undefined &&
3582       !this._needAppearances
3583     ) {
3584       // The annotation hasn't been rendered so use the appearance
3585       return null;
3586     }
3587 
3588     if (exportedValue === undefined) {
3589       exportedValue = this.data.fieldValue;
3590     } else if (!Array.isArray(exportedValue)) {
3591       exportedValue = [exportedValue];
3592     }
3593 
3594     const defaultPadding = 1;
3595     const defaultHPadding = 2;
3596     let { width: totalWidth, height: totalHeight } = this;
3597 
3598     if (rotation === 90 || rotation === 270) {
3599       [totalWidth, totalHeight] = [totalHeight, totalWidth];
3600     }
3601 
3602     const lineCount = this.data.options.length;
3603     const valueIndices = [];
3604     for (let i = 0; i < lineCount; i++) {
3605       const { exportValue } = this.data.options[i];
3606       if (exportedValue.includes(exportValue)) {
3607         valueIndices.push(i);
3608       }
3609     }
3610 
3611     if (!this._defaultAppearance) {
3612       // The DA is required and must be a string.
3613       // If there is no font named Helvetica in the resource dictionary,
3614       // the evaluator will fall back to a default font.
3615       // Doing so prevents exceptions and allows saving/printing
3616       // the file as expected.
3617       this.data.defaultAppearanceData = parseDefaultAppearance(
3618         (this._defaultAppearance = "/Helvetica 0 Tf 0 g")
3619       );
3620     }
3621 
3622     const font = await WidgetAnnotation._getFontData(
3623       evaluator,
3624       task,
3625       this.data.defaultAppearanceData,
3626       this._fieldResources.mergedResources
3627     );
3628 
3629     let defaultAppearance;
3630     let { fontSize } = this.data.defaultAppearanceData;
3631     if (!fontSize) {
3632       const lineHeight = (totalHeight - defaultPadding) / lineCount;
3633       let lineWidth = -1;
3634       let value;
3635       for (const { displayValue } of this.data.options) {
3636         const width = this._getTextWidth(displayValue, font);
3637         if (width > lineWidth) {
3638           lineWidth = width;
3639           value = displayValue;
3640         }
3641       }
3642 
3643       [defaultAppearance, fontSize] = this._computeFontSize(
3644         lineHeight,
3645         totalWidth - 2 * defaultHPadding,
3646         value,
3647         font,
3648         -1
3649       );
3650     } else {
3651       defaultAppearance = this._defaultAppearance;
3652     }
3653 
3654     const lineHeight = fontSize * LINE_FACTOR;
3655     const vPadding = (lineHeight - fontSize) / 2;
3656     const numberOfVisibleLines = Math.floor(totalHeight / lineHeight);
3657 
3658     let firstIndex = 0;
3659     if (valueIndices.length > 0) {
3660       const minIndex = Math.min(...valueIndices);
3661       const maxIndex = Math.max(...valueIndices);
3662 
3663       firstIndex = Math.max(0, maxIndex - numberOfVisibleLines + 1);
3664       if (firstIndex > minIndex) {
3665         firstIndex = minIndex;
3666       }
3667     }
3668     const end = Math.min(firstIndex + numberOfVisibleLines + 1, lineCount);
3669 
3670     const buf = ["/Tx BMC q", `1 1 ${totalWidth} ${totalHeight} re W n`];
3671 
3672     if (valueIndices.length) {
3673       // This value has been copied/pasted from annotation-choice-widget.pdf.
3674       // It corresponds to rgb(153, 193, 218).
3675       buf.push("0.600006 0.756866 0.854904 rg");
3676 
3677       // Highlight the lines in filling a blue rectangle at the selected
3678       // positions.
3679       for (const index of valueIndices) {
3680         if (firstIndex <= index && index < end) {
3681           buf.push(
3682             `1 ${
3683               totalHeight - (index - firstIndex + 1) * lineHeight
3684             } ${totalWidth} ${lineHeight} re f`
3685           );
3686         }
3687       }
3688     }
3689     buf.push("BT", defaultAppearance, `1 0 0 1 0 ${totalHeight} Tm`);
3690 
3691     const prevInfo = { shift: 0 };
3692     for (let i = firstIndex; i < end; i++) {
3693       const { displayValue } = this.data.options[i];
3694       const vpadding = i === firstIndex ? vPadding : 0;
3695       buf.push(
3696         this._renderText(
3697           displayValue,
3698           font,
3699           fontSize,
3700           totalWidth,
3701           0,
3702           prevInfo,
3703           defaultHPadding,
3704           -lineHeight + vpadding
3705         )
3706       );
3707     }
3708 
3709     buf.push("ET Q EMC");
3710 
3711     return buf.join("\n");
3712   }
3713 }
3714 
3715 class SignatureWidgetAnnotation extends WidgetAnnotation {
3716   constructor(params) {
3717     super(params);
3718 
3719     // Unset the fieldValue since it's (most likely) a `Dict` which is
3720     // non-serializable and will thus cause errors when sending annotations
3721     // to the main-thread (issue 10347).
3722     this.data.fieldValue = null;
3723     this.data.hasOwnCanvas = this.data.noRotate;
3724     this.data.noHTML = !this.data.hasOwnCanvas;
3725   }
3726 
3727   getFieldObject() {
3728     return {
3729       id: this.data.id,
3730       value: null,
3731       page: this.data.pageIndex,
3732       type: "signature",
3733     };
3734   }
3735 }
3736 
3737 class TextAnnotation extends MarkupAnnotation {
3738   constructor(params) {
3739     const DEFAULT_ICON_SIZE = 22; // px
3740 
3741     super(params);
3742 
3743     // No rotation for Text (see 12.5.6.4).
3744     this.data.noRotate = true;
3745     this.data.hasOwnCanvas = this.data.noRotate;
3746     this.data.noHTML = false;
3747 
3748     const { dict } = params;
3749     this.data.annotationType = AnnotationType.TEXT;
3750 
3751     if (this.data.hasAppearance) {
3752       this.data.name = "NoIcon";
3753     } else {
3754       this.data.rect[1] = this.data.rect[3] - DEFAULT_ICON_SIZE;
3755       this.data.rect[2] = this.data.rect[0] + DEFAULT_ICON_SIZE;
3756       this.data.name = dict.has("Name") ? dict.get("Name").name : "Note";
3757     }
3758 
3759     if (dict.has("State")) {
3760       this.data.state = dict.get("State") || null;
3761       this.data.stateModel = dict.get("StateModel") || null;
3762     } else {
3763       this.data.state = null;
3764       this.data.stateModel = null;
3765     }
3766   }
3767 }
3768 
3769 class LinkAnnotation extends Annotation {
3770   constructor(params) {
3771     super(params);
3772 
3773     const { dict, annotationGlobals } = params;
3774     this.data.annotationType = AnnotationType.LINK;
3775 
3776     // A link is never rendered on the main canvas so we must render its HTML
3777     // version.
3778     this.data.noHTML = false;
3779 
3780     const quadPoints = getQuadPoints(dict, this.rectangle);
3781     if (quadPoints) {
3782       this.data.quadPoints = quadPoints;
3783     }
3784 
3785     // The color entry for a link annotation is the color of the border.
3786     this.data.borderColor ||= this.data.color;
3787 
3788     Catalog.parseDestDictionary({
3789       destDict: dict,
3790       resultObj: this.data,
3791       docBaseUrl: annotationGlobals.baseUrl,
3792       docAttachments: annotationGlobals.attachments,
3793     });
3794   }
3795 }
3796 
3797 class PopupAnnotation extends Annotation {
3798   constructor(params) {
3799     super(params);
3800 
3801     const { dict } = params;
3802     this.data.annotationType = AnnotationType.POPUP;
3803 
3804     // A pop-up is never rendered on the main canvas so we must render its HTML
3805     // version.
3806     this.data.noHTML = false;
3807 
3808     if (this.width === 0 || this.height === 0) {
3809       this.data.rect = null;
3810     }
3811 
3812     let parentItem = dict.get("Parent");
3813     if (!parentItem) {
3814       warn("Popup annotation has a missing or invalid parent annotation.");
3815       return;
3816     }
3817     this.data.parentRect = lookupNormalRect(parentItem.getArray("Rect"), null);
3818 
3819     const rt = parentItem.get("RT");
3820     if (isName(rt, AnnotationReplyType.GROUP)) {
3821       // Subordinate annotations in a group should inherit
3822       // the group attributes from the primary annotation.
3823       parentItem = parentItem.get("IRT");
3824     }
3825 
3826     if (!parentItem.has("M")) {
3827       this.data.modificationDate = null;
3828     } else {
3829       this.setModificationDate(parentItem.get("M"));
3830       this.data.modificationDate = this.modificationDate;
3831     }
3832 
3833     if (!parentItem.has("C")) {
3834       // Fall back to the default background color.
3835       this.data.color = null;
3836     } else {
3837       this.setColor(parentItem.getArray("C"));
3838       this.data.color = this.color;
3839     }
3840 
3841     // If the Popup annotation is not viewable, but the parent annotation is,
3842     // that is most likely a bug. Fallback to inherit the flags from the parent
3843     // annotation (this is consistent with the behaviour in Adobe Reader).
3844     if (!this.viewable) {
3845       const parentFlags = parentItem.get("F");
3846       if (this._isViewable(parentFlags)) {
3847         this.setFlags(parentFlags);
3848       }
3849     }
3850 
3851     this.setTitle(parentItem.get("T"));
3852     this.data.titleObj = this._title;
3853 
3854     this.setContents(parentItem.get("Contents"));
3855     this.data.contentsObj = this._contents;
3856 
3857     if (parentItem.has("RC")) {
3858       this.data.richText = XFAFactory.getRichTextAsHtml(parentItem.get("RC"));
3859     }
3860 
3861     this.data.open = !!dict.get("Open");
3862   }
3863 }
3864 
3865 class FreeTextAnnotation extends MarkupAnnotation {
3866   constructor(params) {
3867     super(params);
3868 
3869     // It uses its own canvas in order to be hidden if edited.
3870     // But if it has the noHTML flag, it means that we don't want to be able
3871     // to modify it so we can just draw it on the main canvas.
3872     this.data.hasOwnCanvas = this.data.noRotate;
3873     this.data.isEditable = !this.data.noHTML;
3874     // We want to be able to add mouse listeners to the annotation.
3875     this.data.noHTML = false;
3876 
3877     const { annotationGlobals, evaluatorOptions, xref } = params;
3878     this.data.annotationType = AnnotationType.FREETEXT;
3879     this.setDefaultAppearance(params);
3880     this._hasAppearance = !!this.appearance;
3881 
3882     if (this._hasAppearance) {
3883       const { fontColor, fontSize } = parseAppearanceStream(
3884         this.appearance,
3885         evaluatorOptions,
3886         xref,
3887         annotationGlobals.globalColorSpaceCache
3888       );
3889       this.data.defaultAppearanceData.fontColor = fontColor;
3890       this.data.defaultAppearanceData.fontSize = fontSize || 10;
3891     } else {
3892       this.data.defaultAppearanceData.fontSize ||= 10;
3893       const { fontColor, fontSize } = this.data.defaultAppearanceData;
3894       if (this._contents.str) {
3895         this.data.textContent = this._contents.str
3896           .split(/\r\n?|\n/)
3897           .map(line => line.trimEnd());
3898         const { coords, bbox, matrix } = FakeUnicodeFont.getFirstPositionInfo(
3899           this.rectangle,
3900           this.rotation,
3901           fontSize
3902         );
3903         this.data.textPosition = this._transformPoint(coords, bbox, matrix);
3904       }
3905       if (this._isOffscreenCanvasSupported) {
3906         const strokeAlpha = params.dict.get("CA");
3907         const fakeUnicodeFont = new FakeUnicodeFont(xref, "sans-serif");
3908         this.appearance = fakeUnicodeFont.createAppearance(
3909           this._contents.str,
3910           this.rectangle,
3911           this.rotation,
3912           fontSize,
3913           fontColor,
3914           strokeAlpha
3915         );
3916         this._streams.push(this.appearance);
3917       } else {
3918         warn(
3919           "FreeTextAnnotation: OffscreenCanvas is not supported, annotation may not render correctly."
3920         );
3921       }
3922     }
3923   }
3924 
3925   get hasTextContent() {
3926     return this._hasAppearance;
3927   }
3928 
3929   static createNewDict(annotation, xref, { apRef, ap }) {
3930     const { color, fontSize, oldAnnotation, rect, rotation, user, value } =
3931       annotation;
3932     const freetext = oldAnnotation || new Dict(xref);
3933     freetext.set("Type", Name.get("Annot"));
3934     freetext.set("Subtype", Name.get("FreeText"));
3935     if (oldAnnotation) {
3936       freetext.set("M", `D:${getModificationDate()}`);
3937       // TODO: We should try to generate a new RC from the content we've.
3938       // For now we can just remove it to avoid any issues.
3939       freetext.delete("RC");
3940     } else {
3941       freetext.set("CreationDate", `D:${getModificationDate()}`);
3942     }
3943     freetext.set("Rect", rect);
3944     const da = `/Helv ${fontSize} Tf ${getPdfColor(color, /* isFill */ true)}`;
3945     freetext.set("DA", da);
3946     freetext.set("Contents", stringToAsciiOrUTF16BE(value));
3947     freetext.set("F", 4);
3948     freetext.set("Border", [0, 0, 0]);
3949     freetext.set("Rotate", rotation);
3950 
3951     if (user) {
3952       freetext.set("T", stringToAsciiOrUTF16BE(user));
3953     }
3954 
3955     if (apRef || ap) {
3956       const n = new Dict(xref);
3957       freetext.set("AP", n);
3958 
3959       if (apRef) {
3960         n.set("N", apRef);
3961       } else {
3962         n.set("N", ap);
3963       }
3964     }
3965 
3966     return freetext;
3967   }
3968 
3969   static async createNewAppearanceStream(annotation, xref, params) {
3970     const { baseFontRef, evaluator, task } = params;
3971     const { color, fontSize, rect, rotation, value } = annotation;
3972 
3973     const resources = new Dict(xref);
3974     const font = new Dict(xref);
3975 
3976     if (baseFontRef) {
3977       font.set("Helv", baseFontRef);
3978     } else {
3979       const baseFont = new Dict(xref);
3980       baseFont.set("BaseFont", Name.get("Helvetica"));
3981       baseFont.set("Type", Name.get("Font"));
3982       baseFont.set("Subtype", Name.get("Type1"));
3983       baseFont.set("Encoding", Name.get("WinAnsiEncoding"));
3984       font.set("Helv", baseFont);
3985     }
3986     resources.set("Font", font);
3987 
3988     const helv = await WidgetAnnotation._getFontData(
3989       evaluator,
3990       task,
3991       {
3992         fontName: "Helv",
3993         fontSize,
3994       },
3995       resources
3996     );
3997 
3998     const [x1, y1, x2, y2] = rect;
3999     let w = x2 - x1;
4000     let h = y2 - y1;
4001 
4002     if (rotation % 180 !== 0) {
4003       [w, h] = [h, w];
4004     }
4005 
4006     const lines = value.split("\n");
4007     const scale = fontSize / 1000;
4008     let totalWidth = -Infinity;
4009     const encodedLines = [];
4010     for (let line of lines) {
4011       const encoded = helv.encodeString(line);
4012       if (encoded.length > 1) {
4013         // The font doesn't contain all the chars.
4014         return null;
4015       }
4016       line = encoded.join("");
4017       encodedLines.push(line);
4018       let lineWidth = 0;
4019       const glyphs = helv.charsToGlyphs(line);
4020       for (const glyph of glyphs) {
4021         lineWidth += glyph.width * scale;
4022       }
4023       totalWidth = Math.max(totalWidth, lineWidth);
4024     }
4025 
4026     let hscale = 1;
4027     if (totalWidth > w) {
4028       hscale = w / totalWidth;
4029     }
4030     let vscale = 1;
4031     const lineHeight = LINE_FACTOR * fontSize;
4032     const lineAscent = (LINE_FACTOR - LINE_DESCENT_FACTOR) * fontSize;
4033     const totalHeight = lineHeight * lines.length;
4034     if (totalHeight > h) {
4035       vscale = h / totalHeight;
4036     }
4037     const fscale = Math.min(hscale, vscale);
4038     const newFontSize = fontSize * fscale;
4039     let firstPoint, clipBox, matrix;
4040     switch (rotation) {
4041       case 0:
4042         matrix = [1, 0, 0, 1];
4043         clipBox = [rect[0], rect[1], w, h];
4044         firstPoint = [rect[0], rect[3] - lineAscent];
4045         break;
4046       case 90:
4047         matrix = [0, 1, -1, 0];
4048         clipBox = [rect[1], -rect[2], w, h];
4049         firstPoint = [rect[1], -rect[0] - lineAscent];
4050         break;
4051       case 180:
4052         matrix = [-1, 0, 0, -1];
4053         clipBox = [-rect[2], -rect[3], w, h];
4054         firstPoint = [-rect[2], -rect[1] - lineAscent];
4055         break;
4056       case 270:
4057         matrix = [0, -1, 1, 0];
4058         clipBox = [-rect[3], rect[0], w, h];
4059         firstPoint = [-rect[3], rect[2] - lineAscent];
4060         break;
4061     }
4062 
4063     const buffer = [
4064       "q",
4065       `${matrix.join(" ")} 0 0 cm`,
4066       `${clipBox.join(" ")} re W n`,
4067       `BT`,
4068       `${getPdfColor(color, /* isFill */ true)}`,
4069       `0 Tc /Helv ${numberToString(newFontSize)} Tf`,
4070     ];
4071 
4072     buffer.push(
4073       `${firstPoint.join(" ")} Td (${escapeString(encodedLines[0])}) Tj`
4074     );
4075     const vShift = numberToString(lineHeight);
4076     for (let i = 1, ii = encodedLines.length; i < ii; i++) {
4077       const line = encodedLines[i];
4078       buffer.push(`0 -${vShift} Td (${escapeString(line)}) Tj`);
4079     }
4080     buffer.push("ET", "Q");
4081     const appearance = buffer.join("\n");
4082 
4083     const appearanceStreamDict = new Dict(xref);
4084     appearanceStreamDict.set("FormType", 1);
4085     appearanceStreamDict.set("Subtype", Name.get("Form"));
4086     appearanceStreamDict.set("Type", Name.get("XObject"));
4087     appearanceStreamDict.set("BBox", rect);
4088     appearanceStreamDict.set("Resources", resources);
4089     appearanceStreamDict.set("Matrix", [1, 0, 0, 1, -rect[0], -rect[1]]);
4090 
4091     const ap = new StringStream(appearance);
4092     ap.dict = appearanceStreamDict;
4093 
4094     return ap;
4095   }
4096 }
4097 
4098 class LineAnnotation extends MarkupAnnotation {
4099   constructor(params) {
4100     super(params);
4101 
4102     const { dict, xref } = params;
4103     this.data.annotationType = AnnotationType.LINE;
4104     this.data.hasOwnCanvas = this.data.noRotate;
4105     this.data.noHTML = false;
4106 
4107     const lineCoordinates = lookupRect(dict.getArray("L"), [0, 0, 0, 0]);
4108     this.data.lineCoordinates = Util.normalizeRect(lineCoordinates);
4109 
4110     if (typeof PDFJSDev === "undefined" || !PDFJSDev.test("MOZCENTRAL")) {
4111       this.setLineEndings(dict.getArray("LE"));
4112       this.data.lineEndings = this.lineEndings;
4113     }
4114 
4115     if (!this.appearance) {
4116       // The default stroke color is black.
4117       const strokeColor = this.color ? getPdfColorArray(this.color) : [0, 0, 0];
4118       const strokeAlpha = dict.get("CA");
4119 
4120       const interiorColor = getRgbColor(dict.getArray("IC"), null);
4121       // The default fill color is transparent. Setting the fill colour is
4122       // necessary if/when we want to add support for non-default line endings.
4123       const fillColor = interiorColor ? getPdfColorArray(interiorColor) : null;
4124       const fillAlpha = fillColor ? strokeAlpha : null;
4125 
4126       const borderWidth = this.borderStyle.width || 1,
4127         borderAdjust = 2 * borderWidth;
4128 
4129       // If the /Rect-entry is empty/wrong, create a fallback rectangle so that
4130       // we get similar rendering/highlighting behaviour as in Adobe Reader.
4131       const bbox = [
4132         this.data.lineCoordinates[0] - borderAdjust,
4133         this.data.lineCoordinates[1] - borderAdjust,
4134         this.data.lineCoordinates[2] + borderAdjust,
4135         this.data.lineCoordinates[3] + borderAdjust,
4136       ];
4137       if (!Util.intersect(this.rectangle, bbox)) {
4138         this.rectangle = bbox;
4139       }
4140 
4141       this._setDefaultAppearance({
4142         xref,
4143         extra: `${borderWidth} w`,
4144         strokeColor,
4145         fillColor,
4146         strokeAlpha,
4147         fillAlpha,
4148         pointsCallback: (buffer, points) => {
4149           buffer.push(
4150             `${lineCoordinates[0]} ${lineCoordinates[1]} m`,
4151             `${lineCoordinates[2]} ${lineCoordinates[3]} l`,
4152             "S"
4153           );
4154           return [
4155             points[0] - borderWidth,
4156             points[7] - borderWidth,
4157             points[2] + borderWidth,
4158             points[3] + borderWidth,
4159           ];
4160         },
4161       });
4162     }
4163   }
4164 }
4165 
4166 class SquareAnnotation extends MarkupAnnotation {
4167   constructor(params) {
4168     super(params);
4169 
4170     const { dict, xref } = params;
4171     this.data.annotationType = AnnotationType.SQUARE;
4172     this.data.hasOwnCanvas = this.data.noRotate;
4173     this.data.noHTML = false;
4174 
4175     if (!this.appearance) {
4176       // The default stroke color is black.
4177       const strokeColor = this.color ? getPdfColorArray(this.color) : [0, 0, 0];
4178       const strokeAlpha = dict.get("CA");
4179 
4180       const interiorColor = getRgbColor(dict.getArray("IC"), null);
4181       // The default fill color is transparent.
4182       const fillColor = interiorColor ? getPdfColorArray(interiorColor) : null;
4183       const fillAlpha = fillColor ? strokeAlpha : null;
4184 
4185       if (this.borderStyle.width === 0 && !fillColor) {
4186         // Prevent rendering a "hairline" border (fixes issue14164.pdf).
4187         return;
4188       }
4189 
4190       this._setDefaultAppearance({
4191         xref,
4192         extra: `${this.borderStyle.width} w`,
4193         strokeColor,
4194         fillColor,
4195         strokeAlpha,
4196         fillAlpha,
4197         pointsCallback: (buffer, points) => {
4198           const x = points[4] + this.borderStyle.width / 2;
4199           const y = points[5] + this.borderStyle.width / 2;
4200           const width = points[6] - points[4] - this.borderStyle.width;
4201           const height = points[3] - points[7] - this.borderStyle.width;
4202           buffer.push(`${x} ${y} ${width} ${height} re`);
4203           if (fillColor) {
4204             buffer.push("B");
4205           } else {
4206             buffer.push("S");
4207           }
4208           return [points[0], points[7], points[2], points[3]];
4209         },
4210       });
4211     }
4212   }
4213 }
4214 
4215 class CircleAnnotation extends MarkupAnnotation {
4216   constructor(params) {
4217     super(params);
4218 
4219     const { dict, xref } = params;
4220     this.data.annotationType = AnnotationType.CIRCLE;
4221 
4222     if (!this.appearance) {
4223       // The default stroke color is black.
4224       const strokeColor = this.color ? getPdfColorArray(this.color) : [0, 0, 0];
4225       const strokeAlpha = dict.get("CA");
4226 
4227       const interiorColor = getRgbColor(dict.getArray("IC"), null);
4228       // The default fill color is transparent.
4229       const fillColor = interiorColor ? getPdfColorArray(interiorColor) : null;
4230       const fillAlpha = fillColor ? strokeAlpha : null;
4231 
4232       if (this.borderStyle.width === 0 && !fillColor) {
4233         // Prevent rendering a "hairline" border (fixes issue14164.pdf).
4234         return;
4235       }
4236 
4237       // Circles are approximated by Bézier curves with four segments since
4238       // there is no circle primitive in the PDF specification. For the control
4239       // points distance, see https://stackoverflow.com/a/27863181.
4240       const controlPointsDistance = (4 / 3) * Math.tan(Math.PI / (2 * 4));
4241 
4242       this._setDefaultAppearance({
4243         xref,
4244         extra: `${this.borderStyle.width} w`,
4245         strokeColor,
4246         fillColor,
4247         strokeAlpha,
4248         fillAlpha,
4249         pointsCallback: (buffer, points) => {
4250           const x0 = points[0] + this.borderStyle.width / 2;
4251           const y0 = points[1] - this.borderStyle.width / 2;
4252           const x1 = points[6] - this.borderStyle.width / 2;
4253           const y1 = points[7] + this.borderStyle.width / 2;
4254           const xMid = x0 + (x1 - x0) / 2;
4255           const yMid = y0 + (y1 - y0) / 2;
4256           const xOffset = ((x1 - x0) / 2) * controlPointsDistance;
4257           const yOffset = ((y1 - y0) / 2) * controlPointsDistance;
4258 
4259           buffer.push(
4260             `${xMid} ${y1} m`,
4261             `${xMid + xOffset} ${y1} ${x1} ${yMid + yOffset} ${x1} ${yMid} c`,
4262             `${x1} ${yMid - yOffset} ${xMid + xOffset} ${y0} ${xMid} ${y0} c`,
4263             `${xMid - xOffset} ${y0} ${x0} ${yMid - yOffset} ${x0} ${yMid} c`,
4264             `${x0} ${yMid + yOffset} ${xMid - xOffset} ${y1} ${xMid} ${y1} c`,
4265             "h"
4266           );
4267           if (fillColor) {
4268             buffer.push("B");
4269           } else {
4270             buffer.push("S");
4271           }
4272           return [points[0], points[7], points[2], points[3]];
4273         },
4274       });
4275     }
4276   }
4277 }
4278 
4279 class PolylineAnnotation extends MarkupAnnotation {
4280   constructor(params) {
4281     super(params);
4282 
4283     const { dict, xref } = params;
4284     this.data.annotationType = AnnotationType.POLYLINE;
4285     this.data.hasOwnCanvas = this.data.noRotate;
4286     this.data.noHTML = false;
4287     this.data.vertices = null;
4288 
4289     if (
4290       (typeof PDFJSDev === "undefined" || !PDFJSDev.test("MOZCENTRAL")) &&
4291       !(this instanceof PolygonAnnotation)
4292     ) {
4293       // Only meaningful for polyline annotations.
4294       this.setLineEndings(dict.getArray("LE"));
4295       this.data.lineEndings = this.lineEndings;
4296     }
4297 
4298     // The vertices array is an array of numbers representing the alternating
4299     // horizontal and vertical coordinates, respectively, of each vertex.
4300     // Convert this to an array of objects with x and y coordinates.
4301     const rawVertices = dict.getArray("Vertices");
4302     if (!isNumberArray(rawVertices, null)) {
4303       return;
4304     }
4305     const vertices = (this.data.vertices = Float32Array.from(rawVertices));
4306 
4307     if (!this.appearance) {
4308       // The default stroke color is black.
4309       const strokeColor = this.color ? getPdfColorArray(this.color) : [0, 0, 0];
4310       const strokeAlpha = dict.get("CA");
4311 
4312       const borderWidth = this.borderStyle.width || 1,
4313         borderAdjust = 2 * borderWidth;
4314 
4315       // If the /Rect-entry is empty/wrong, create a fallback rectangle so that
4316       // we get similar rendering/highlighting behaviour as in Adobe Reader.
4317       const bbox = [Infinity, Infinity, -Infinity, -Infinity];
4318       for (let i = 0, ii = vertices.length; i < ii; i += 2) {
4319         Util.rectBoundingBox(
4320           vertices[i] - borderAdjust,
4321           vertices[i + 1] - borderAdjust,
4322           vertices[i] + borderAdjust,
4323           vertices[i + 1] + borderAdjust,
4324           bbox
4325         );
4326       }
4327       if (!Util.intersect(this.rectangle, bbox)) {
4328         this.rectangle = bbox;
4329       }
4330 
4331       this._setDefaultAppearance({
4332         xref,
4333         extra: `${borderWidth} w`,
4334         strokeColor,
4335         strokeAlpha,
4336         pointsCallback: (buffer, points) => {
4337           for (let i = 0, ii = vertices.length; i < ii; i += 2) {
4338             buffer.push(
4339               `${vertices[i]} ${vertices[i + 1]} ${i === 0 ? "m" : "l"}`
4340             );
4341           }
4342           buffer.push("S");
4343           return [points[0], points[7], points[2], points[3]];
4344         },
4345       });
4346     }
4347   }
4348 }
4349 
4350 class PolygonAnnotation extends PolylineAnnotation {
4351   constructor(params) {
4352     // Polygons are specific forms of polylines, so reuse their logic.
4353     super(params);
4354 
4355     this.data.annotationType = AnnotationType.POLYGON;
4356   }
4357 }
4358 
4359 class CaretAnnotation extends MarkupAnnotation {
4360   constructor(params) {
4361     super(params);
4362 
4363     this.data.annotationType = AnnotationType.CARET;
4364   }
4365 }
4366 
4367 class InkAnnotation extends MarkupAnnotation {
4368   constructor(params) {
4369     super(params);
4370 
4371     this.data.hasOwnCanvas = this.data.noRotate;
4372     this.data.noHTML = false;
4373 
4374     const { dict, xref } = params;
4375     this.data.annotationType = AnnotationType.INK;
4376     this.data.inkLists = [];
4377     this.data.isEditable = !this.data.noHTML;
4378     // We want to be able to add mouse listeners to the annotation.
4379     this.data.noHTML = false;
4380     this.data.opacity = dict.get("CA") || 1;
4381 
4382     const rawInkLists = dict.getArray("InkList");
4383     if (!Array.isArray(rawInkLists)) {
4384       return;
4385     }
4386     for (let i = 0, ii = rawInkLists.length; i < ii; ++i) {
4387       // The raw ink lists array contains arrays of numbers representing
4388       // the alternating horizontal and vertical coordinates, respectively,
4389       // of each vertex. Convert this to an array of objects with x and y
4390       // coordinates.
4391       if (!Array.isArray(rawInkLists[i])) {
4392         continue;
4393       }
4394       const inkList = new Float32Array(rawInkLists[i].length);
4395       this.data.inkLists.push(inkList);
4396       for (let j = 0, jj = rawInkLists[i].length; j < jj; j += 2) {
4397         const x = xref.fetchIfRef(rawInkLists[i][j]),
4398           y = xref.fetchIfRef(rawInkLists[i][j + 1]);
4399         if (typeof x === "number" && typeof y === "number") {
4400           inkList[j] = x;
4401           inkList[j + 1] = y;
4402         }
4403       }
4404     }
4405 
4406     if (!this.appearance) {
4407       // The default stroke color is black.
4408       const strokeColor = this.color ? getPdfColorArray(this.color) : [0, 0, 0];
4409       const strokeAlpha = dict.get("CA");
4410 
4411       const borderWidth = this.borderStyle.width || 1,
4412         borderAdjust = 2 * borderWidth;
4413 
4414       // If the /Rect-entry is empty/wrong, create a fallback rectangle so that
4415       // we get similar rendering/highlighting behaviour as in Adobe Reader.
4416       const bbox = [Infinity, Infinity, -Infinity, -Infinity];
4417       for (const inkList of this.data.inkLists) {
4418         for (let i = 0, ii = inkList.length; i < ii; i += 2) {
4419           Util.rectBoundingBox(
4420             inkList[i] - borderAdjust,
4421             inkList[i + 1] - borderAdjust,
4422             inkList[i] + borderAdjust,
4423             inkList[i + 1] + borderAdjust,
4424             bbox
4425           );
4426         }
4427       }
4428       if (!Util.intersect(this.rectangle, bbox)) {
4429         this.rectangle = bbox;
4430       }
4431 
4432       this._setDefaultAppearance({
4433         xref,
4434         extra: `${borderWidth} w`,
4435         strokeColor,
4436         strokeAlpha,
4437         pointsCallback: (buffer, points) => {
4438           // According to the specification, see "12.5.6.13 Ink Annotations":
4439           //   When drawn, the points shall be connected by straight lines or
4440           //   curves in an implementation-dependent way.
4441           // In order to simplify things, we utilize straight lines for now.
4442           for (const inkList of this.data.inkLists) {
4443             for (let i = 0, ii = inkList.length; i < ii; i += 2) {
4444               buffer.push(
4445                 `${inkList[i]} ${inkList[i + 1]} ${i === 0 ? "m" : "l"}`
4446               );
4447             }
4448             buffer.push("S");
4449           }
4450           return [points[0], points[7], points[2], points[3]];
4451         },
4452       });
4453     }
4454   }
4455 
4456   static createNewDict(annotation, xref, { apRef, ap }) {
4457     const {
4458       oldAnnotation,
4459       color,
4460       opacity,
4461       paths,
4462       outlines,
4463       rect,
4464       rotation,
4465       thickness,
4466       user,
4467     } = annotation;
4468     const ink = oldAnnotation || new Dict(xref);
4469     ink.set("Type", Name.get("Annot"));
4470     ink.set("Subtype", Name.get("Ink"));
4471     ink.set(oldAnnotation ? "M" : "CreationDate", `D:${getModificationDate()}`);
4472     ink.set("Rect", rect);
4473     ink.set("InkList", outlines?.points || paths.points);
4474     ink.set("F", 4);
4475     ink.set("Rotate", rotation);
4476 
4477     if (user) {
4478       ink.set("T", stringToAsciiOrUTF16BE(user));
4479     }
4480 
4481     if (outlines) {
4482       // Free highlight.
4483       // There's nothing about this in the spec, but it's used when highlighting
4484       // in Edge's viewer. Acrobat takes into account this parameter to indicate
4485       // that the Ink is used for highlighting.
4486       ink.set("IT", Name.get("InkHighlight"));
4487     }
4488 
4489     // Line thickness.
4490     const bs = new Dict(xref);
4491     ink.set("BS", bs);
4492     bs.set("W", thickness);
4493 
4494     // Color.
4495     ink.set("C", getPdfColorArray(color));
4496 
4497     // Opacity.
4498     ink.set("CA", opacity);
4499 
4500     const n = new Dict(xref);
4501     ink.set("AP", n);
4502 
4503     if (apRef) {
4504       n.set("N", apRef);
4505     } else {
4506       n.set("N", ap);
4507     }
4508 
4509     return ink;
4510   }
4511 
4512   static async createNewAppearanceStream(annotation, xref, params) {
4513     if (annotation.outlines) {
4514       return this.createNewAppearanceStreamForHighlight(
4515         annotation,
4516         xref,
4517         params
4518       );
4519     }
4520     const { color, rect, paths, thickness, opacity } = annotation;
4521 
4522     const appearanceBuffer = [
4523       `${thickness} w 1 J 1 j`,
4524       `${getPdfColor(color, /* isFill */ false)}`,
4525     ];
4526 
4527     if (opacity !== 1) {
4528       appearanceBuffer.push("/R0 gs");
4529     }
4530 
4531     for (const outline of paths.lines) {
4532       appearanceBuffer.push(
4533         `${numberToString(outline[4])} ${numberToString(outline[5])} m`
4534       );
4535       for (let i = 6, ii = outline.length; i < ii; i += 6) {
4536         if (isNaN(outline[i])) {
4537           appearanceBuffer.push(
4538             `${numberToString(outline[i + 4])} ${numberToString(
4539               outline[i + 5]
4540             )} l`
4541           );
4542         } else {
4543           const [c1x, c1y, c2x, c2y, x, y] = outline.slice(i, i + 6);
4544           appearanceBuffer.push(
4545             [c1x, c1y, c2x, c2y, x, y].map(numberToString).join(" ") + " c"
4546           );
4547         }
4548       }
4549       if (outline.length === 6) {
4550         appearanceBuffer.push(
4551           `${numberToString(outline[4])} ${numberToString(outline[5])} l`
4552         );
4553       }
4554     }
4555     appearanceBuffer.push("S");
4556 
4557     const appearance = appearanceBuffer.join("\n");
4558 
4559     const appearanceStreamDict = new Dict(xref);
4560     appearanceStreamDict.set("FormType", 1);
4561     appearanceStreamDict.set("Subtype", Name.get("Form"));
4562     appearanceStreamDict.set("Type", Name.get("XObject"));
4563     appearanceStreamDict.set("BBox", rect);
4564     appearanceStreamDict.set("Length", appearance.length);
4565 
4566     if (opacity !== 1) {
4567       const resources = new Dict(xref);
4568       const extGState = new Dict(xref);
4569       const r0 = new Dict(xref);
4570       r0.set("CA", opacity);
4571       r0.set("Type", Name.get("ExtGState"));
4572       extGState.set("R0", r0);
4573       resources.set("ExtGState", extGState);
4574       appearanceStreamDict.set("Resources", resources);
4575     }
4576 
4577     const ap = new StringStream(appearance);
4578     ap.dict = appearanceStreamDict;
4579 
4580     return ap;
4581   }
4582 
4583   static async createNewAppearanceStreamForHighlight(annotation, xref, params) {
4584     const {
4585       color,
4586       rect,
4587       outlines: { outline },
4588       opacity,
4589     } = annotation;
4590     const appearanceBuffer = [
4591       `${getPdfColor(color, /* isFill */ true)}`,
4592       "/R0 gs",
4593     ];
4594 
4595     appearanceBuffer.push(
4596       `${numberToString(outline[4])} ${numberToString(outline[5])} m`
4597     );
4598     for (let i = 6, ii = outline.length; i < ii; i += 6) {
4599       if (isNaN(outline[i])) {
4600         appearanceBuffer.push(
4601           `${numberToString(outline[i + 4])} ${numberToString(
4602             outline[i + 5]
4603           )} l`
4604         );
4605       } else {
4606         const [c1x, c1y, c2x, c2y, x, y] = outline.slice(i, i + 6);
4607         appearanceBuffer.push(
4608           [c1x, c1y, c2x, c2y, x, y].map(numberToString).join(" ") + " c"
4609         );
4610       }
4611     }
4612     appearanceBuffer.push("h f");
4613     const appearance = appearanceBuffer.join("\n");
4614 
4615     const appearanceStreamDict = new Dict(xref);
4616     appearanceStreamDict.set("FormType", 1);
4617     appearanceStreamDict.set("Subtype", Name.get("Form"));
4618     appearanceStreamDict.set("Type", Name.get("XObject"));
4619     appearanceStreamDict.set("BBox", rect);
4620     appearanceStreamDict.set("Length", appearance.length);
4621 
4622     const resources = new Dict(xref);
4623     const extGState = new Dict(xref);
4624     resources.set("ExtGState", extGState);
4625     appearanceStreamDict.set("Resources", resources);
4626     const r0 = new Dict(xref);
4627     extGState.set("R0", r0);
4628     r0.set("BM", Name.get("Multiply"));
4629 
4630     if (opacity !== 1) {
4631       r0.set("ca", opacity);
4632       r0.set("Type", Name.get("ExtGState"));
4633     }
4634 
4635     const ap = new StringStream(appearance);
4636     ap.dict = appearanceStreamDict;
4637 
4638     return ap;
4639   }
4640 }
4641 
4642 class HighlightAnnotation extends MarkupAnnotation {
4643   constructor(params) {
4644     super(params);
4645 
4646     const { dict, xref } = params;
4647     this.data.annotationType = AnnotationType.HIGHLIGHT;
4648     this.data.isEditable = !this.data.noHTML;
4649     // We want to be able to add mouse listeners to the annotation.
4650     this.data.noHTML = false;
4651     this.data.opacity = dict.get("CA") || 1;
4652 
4653     const quadPoints = (this.data.quadPoints = getQuadPoints(dict, null));
4654     if (quadPoints) {
4655       const resources = this.appearance?.dict.get("Resources");
4656 
4657       if (!this.appearance || !resources?.has("ExtGState")) {
4658         if (this.appearance) {
4659           // Workaround for cases where there's no /ExtGState-entry directly
4660           // available, e.g. when the appearance stream contains a /XObject of
4661           // the /Form-type, since that causes the highlighting to completely
4662           // obscure the PDF content below it (fixes issue13242.pdf).
4663           warn("HighlightAnnotation - ignoring built-in appearance stream.");
4664         }
4665         // Default color is yellow in Acrobat Reader
4666         const fillColor = this.color ? getPdfColorArray(this.color) : [1, 1, 0];
4667         const fillAlpha = dict.get("CA");
4668 
4669         this._setDefaultAppearance({
4670           xref,
4671           fillColor,
4672           blendMode: "Multiply",
4673           fillAlpha,
4674           pointsCallback: (buffer, points) => {
4675             buffer.push(
4676               `${points[0]} ${points[1]} m`,
4677               `${points[2]} ${points[3]} l`,
4678               `${points[6]} ${points[7]} l`,
4679               `${points[4]} ${points[5]} l`,
4680               "f"
4681             );
4682             return [points[0], points[7], points[2], points[3]];
4683           },
4684         });
4685       }
4686     } else {
4687       this.data.popupRef = null;
4688     }
4689   }
4690 
4691   static createNewDict(annotation, xref, { apRef, ap }) {
4692     const { color, oldAnnotation, opacity, rect, rotation, user, quadPoints } =
4693       annotation;
4694     const highlight = oldAnnotation || new Dict(xref);
4695     highlight.set("Type", Name.get("Annot"));
4696     highlight.set("Subtype", Name.get("Highlight"));
4697     highlight.set(
4698       oldAnnotation ? "M" : "CreationDate",
4699       `D:${getModificationDate()}`
4700     );
4701     highlight.set("CreationDate", `D:${getModificationDate()}`);
4702     highlight.set("Rect", rect);
4703     highlight.set("F", 4);
4704     highlight.set("Border", [0, 0, 0]);
4705     highlight.set("Rotate", rotation);
4706     highlight.set("QuadPoints", quadPoints);
4707 
4708     // Color.
4709     highlight.set("C", getPdfColorArray(color));
4710 
4711     // Opacity.
4712     highlight.set("CA", opacity);
4713 
4714     if (user) {
4715       highlight.set("T", stringToAsciiOrUTF16BE(user));
4716     }
4717 
4718     if (apRef || ap) {
4719       const n = new Dict(xref);
4720       highlight.set("AP", n);
4721       n.set("N", apRef || ap);
4722     }
4723 
4724     return highlight;
4725   }
4726 
4727   static async createNewAppearanceStream(annotation, xref, params) {
4728     const { color, rect, outlines, opacity } = annotation;
4729 
4730     const appearanceBuffer = [
4731       `${getPdfColor(color, /* isFill */ true)}`,
4732       "/R0 gs",
4733     ];
4734 
4735     const buffer = [];
4736     for (const outline of outlines) {
4737       buffer.length = 0;
4738       buffer.push(
4739         `${numberToString(outline[0])} ${numberToString(outline[1])} m`
4740       );
4741       for (let i = 2, ii = outline.length; i < ii; i += 2) {
4742         buffer.push(
4743           `${numberToString(outline[i])} ${numberToString(outline[i + 1])} l`
4744         );
4745       }
4746       buffer.push("h");
4747       appearanceBuffer.push(buffer.join("\n"));
4748     }
4749     appearanceBuffer.push("f*");
4750     const appearance = appearanceBuffer.join("\n");
4751 
4752     const appearanceStreamDict = new Dict(xref);
4753     appearanceStreamDict.set("FormType", 1);
4754     appearanceStreamDict.set("Subtype", Name.get("Form"));
4755     appearanceStreamDict.set("Type", Name.get("XObject"));
4756     appearanceStreamDict.set("BBox", rect);
4757     appearanceStreamDict.set("Length", appearance.length);
4758 
4759     const resources = new Dict(xref);
4760     const extGState = new Dict(xref);
4761     resources.set("ExtGState", extGState);
4762     appearanceStreamDict.set("Resources", resources);
4763     const r0 = new Dict(xref);
4764     extGState.set("R0", r0);
4765     r0.set("BM", Name.get("Multiply"));
4766 
4767     if (opacity !== 1) {
4768       r0.set("ca", opacity);
4769       r0.set("Type", Name.get("ExtGState"));
4770     }
4771 
4772     const ap = new StringStream(appearance);
4773     ap.dict = appearanceStreamDict;
4774 
4775     return ap;
4776   }
4777 }
4778 
4779 class UnderlineAnnotation extends MarkupAnnotation {
4780   constructor(params) {
4781     super(params);
4782 
4783     const { dict, xref } = params;
4784     this.data.annotationType = AnnotationType.UNDERLINE;
4785 
4786     const quadPoints = (this.data.quadPoints = getQuadPoints(dict, null));
4787     if (quadPoints) {
4788       if (!this.appearance) {
4789         // Default color is black
4790         const strokeColor = this.color
4791           ? getPdfColorArray(this.color)
4792           : [0, 0, 0];
4793         const strokeAlpha = dict.get("CA");
4794 
4795         // The values 0.571 and 1.3 below corresponds to what Acrobat is doing.
4796         this._setDefaultAppearance({
4797           xref,
4798           extra: "[] 0 d 0.571 w",
4799           strokeColor,
4800           strokeAlpha,
4801           pointsCallback: (buffer, points) => {
4802             buffer.push(
4803               `${points[4]} ${points[5] + 1.3} m`,
4804               `${points[6]} ${points[7] + 1.3} l`,
4805               "S"
4806             );
4807             return [points[0], points[7], points[2], points[3]];
4808           },
4809         });
4810       }
4811     } else {
4812       this.data.popupRef = null;
4813     }
4814   }
4815 }
4816 
4817 class SquigglyAnnotation extends MarkupAnnotation {
4818   constructor(params) {
4819     super(params);
4820 
4821     const { dict, xref } = params;
4822     this.data.annotationType = AnnotationType.SQUIGGLY;
4823 
4824     const quadPoints = (this.data.quadPoints = getQuadPoints(dict, null));
4825     if (quadPoints) {
4826       if (!this.appearance) {
4827         // Default color is black
4828         const strokeColor = this.color
4829           ? getPdfColorArray(this.color)
4830           : [0, 0, 0];
4831         const strokeAlpha = dict.get("CA");
4832 
4833         this._setDefaultAppearance({
4834           xref,
4835           extra: "[] 0 d 1 w",
4836           strokeColor,
4837           strokeAlpha,
4838           pointsCallback: (buffer, points) => {
4839             const dy = (points[1] - points[5]) / 6;
4840             let shift = dy;
4841             let x = points[4];
4842             const y = points[5];
4843             const xEnd = points[6];
4844             buffer.push(`${x} ${y + shift} m`);
4845             do {
4846               x += 2;
4847               shift = shift === 0 ? dy : 0;
4848               buffer.push(`${x} ${y + shift} l`);
4849             } while (x < xEnd);
4850             buffer.push("S");
4851             return [points[4], y - 2 * dy, xEnd, y + 2 * dy];
4852           },
4853         });
4854       }
4855     } else {
4856       this.data.popupRef = null;
4857     }
4858   }
4859 }
4860 
4861 class StrikeOutAnnotation extends MarkupAnnotation {
4862   constructor(params) {
4863     super(params);
4864 
4865     const { dict, xref } = params;
4866     this.data.annotationType = AnnotationType.STRIKEOUT;
4867 
4868     const quadPoints = (this.data.quadPoints = getQuadPoints(dict, null));
4869     if (quadPoints) {
4870       if (!this.appearance) {
4871         // Default color is black
4872         const strokeColor = this.color
4873           ? getPdfColorArray(this.color)
4874           : [0, 0, 0];
4875         const strokeAlpha = dict.get("CA");
4876 
4877         this._setDefaultAppearance({
4878           xref,
4879           extra: "[] 0 d 1 w",
4880           strokeColor,
4881           strokeAlpha,
4882           pointsCallback: (buffer, points) => {
4883             buffer.push(
4884               `${(points[0] + points[4]) / 2} ` +
4885                 `${(points[1] + points[5]) / 2} m`,
4886               `${(points[2] + points[6]) / 2} ` +
4887                 `${(points[3] + points[7]) / 2} l`,
4888               "S"
4889             );
4890             return [points[0], points[7], points[2], points[3]];
4891           },
4892         });
4893       }
4894     } else {
4895       this.data.popupRef = null;
4896     }
4897   }
4898 }
4899 
4900 class StampAnnotation extends MarkupAnnotation {
4901   #savedHasOwnCanvas = null;
4902 
4903   constructor(params) {
4904     super(params);
4905 
4906     this.data.annotationType = AnnotationType.STAMP;
4907     this.data.hasOwnCanvas = this.data.noRotate;
4908     this.data.isEditable = !this.data.noHTML;
4909     // We want to be able to add mouse listeners to the annotation.
4910     this.data.noHTML = false;
4911   }
4912 
4913   mustBeViewedWhenEditing(isEditing, modifiedIds = null) {
4914     if (isEditing) {
4915       if (!this.data.isEditable) {
4916         return true;
4917       }
4918       // When we're editing, we want to ensure that the stamp annotation is
4919       // drawn on a canvas in order to use it in the annotation editor layer.
4920       this.#savedHasOwnCanvas ??= this.data.hasOwnCanvas;
4921       this.data.hasOwnCanvas = true;
4922       return true;
4923     }
4924     if (this.#savedHasOwnCanvas !== null) {
4925       this.data.hasOwnCanvas = this.#savedHasOwnCanvas;
4926       this.#savedHasOwnCanvas = null;
4927     }
4928 
4929     return !modifiedIds?.has(this.data.id);
4930   }
4931 
4932   static async createImage(bitmap, xref) {
4933     // TODO: when printing, we could have a specific internal colorspace
4934     // (e.g. something like DeviceRGBA) in order avoid any conversion (i.e. no
4935     // jpeg, no rgba to rgb conversion, etc...)
4936 
4937     const { width, height } = bitmap;
4938     const canvas = new OffscreenCanvas(width, height);
4939     const ctx = canvas.getContext("2d", { alpha: true });
4940 
4941     // Draw the image and get the data in order to extract the transparency.
4942     ctx.drawImage(bitmap, 0, 0);
4943     const data = ctx.getImageData(0, 0, width, height).data;
4944     const buf32 = new Uint32Array(data.buffer);
4945     const hasAlpha = buf32.some(
4946       FeatureTest.isLittleEndian
4947         ? x => x >>> 24 !== 0xff
4948         : x => (x & 0xff) !== 0xff
4949     );
4950 
4951     if (hasAlpha) {
4952       // Redraw the image on a white background in order to remove the thin gray
4953       // line which can appear when exporting to jpeg.
4954       ctx.fillStyle = "white";
4955       ctx.fillRect(0, 0, width, height);
4956       ctx.drawImage(bitmap, 0, 0);
4957     }
4958 
4959     const jpegBufferPromise = canvas
4960       .convertToBlob({ type: "image/jpeg", quality: 1 })
4961       .then(blob => blob.arrayBuffer());
4962 
4963     const xobjectName = Name.get("XObject");
4964     const imageName = Name.get("Image");
4965     const image = new Dict(xref);
4966     image.set("Type", xobjectName);
4967     image.set("Subtype", imageName);
4968     image.set("BitsPerComponent", 8);
4969     image.set("ColorSpace", Name.get("DeviceRGB"));
4970     image.set("Filter", Name.get("DCTDecode"));
4971     image.set("BBox", [0, 0, width, height]);
4972     image.set("Width", width);
4973     image.set("Height", height);
4974 
4975     let smaskStream = null;
4976     if (hasAlpha) {
4977       const alphaBuffer = new Uint8Array(buf32.length);
4978       if (FeatureTest.isLittleEndian) {
4979         for (let i = 0, ii = buf32.length; i < ii; i++) {
4980           alphaBuffer[i] = buf32[i] >>> 24;
4981         }
4982       } else {
4983         for (let i = 0, ii = buf32.length; i < ii; i++) {
4984           alphaBuffer[i] = buf32[i] & 0xff;
4985         }
4986       }
4987 
4988       const smask = new Dict(xref);
4989       smask.set("Type", xobjectName);
4990       smask.set("Subtype", imageName);
4991       smask.set("BitsPerComponent", 8);
4992       smask.set("ColorSpace", Name.get("DeviceGray"));
4993       smask.set("Width", width);
4994       smask.set("Height", height);
4995 
4996       smaskStream = new Stream(alphaBuffer, 0, 0, smask);
4997     }
4998     const imageStream = new Stream(await jpegBufferPromise, 0, 0, image);
4999 
5000     return {
5001       imageStream,
5002       smaskStream,
5003       width,
5004       height,
5005     };
5006   }
5007 
5008   static createNewDict(annotation, xref, { apRef, ap }) {
5009     const { oldAnnotation, rect, rotation, user } = annotation;
5010     const stamp = oldAnnotation || new Dict(xref);
5011     stamp.set("Type", Name.get("Annot"));
5012     stamp.set("Subtype", Name.get("Stamp"));
5013     stamp.set(
5014       oldAnnotation ? "M" : "CreationDate",
5015       `D:${getModificationDate()}`
5016     );
5017     stamp.set("Rect", rect);
5018     stamp.set("F", 4);
5019     stamp.set("Border", [0, 0, 0]);
5020     stamp.set("Rotate", rotation);
5021 
5022     if (user) {
5023       stamp.set("T", stringToAsciiOrUTF16BE(user));
5024     }
5025 
5026     if (apRef || ap) {
5027       const n = new Dict(xref);
5028       stamp.set("AP", n);
5029 
5030       if (apRef) {
5031         n.set("N", apRef);
5032       } else {
5033         n.set("N", ap);
5034       }
5035     }
5036 
5037     return stamp;
5038   }
5039 
5040   static async #createNewAppearanceStreamForDrawing(annotation, xref) {
5041     const { areContours, color, rect, lines, thickness } = annotation;
5042 
5043     const appearanceBuffer = [
5044       `${thickness} w 1 J 1 j`,
5045       `${getPdfColor(color, /* isFill */ areContours)}`,
5046     ];
5047 
5048     for (const line of lines) {
5049       appearanceBuffer.push(
5050         `${numberToString(line[4])} ${numberToString(line[5])} m`
5051       );
5052       for (let i = 6, ii = line.length; i < ii; i += 6) {
5053         if (isNaN(line[i])) {
5054           appearanceBuffer.push(
5055             `${numberToString(line[i + 4])} ${numberToString(line[i + 5])} l`
5056           );
5057         } else {
5058           const [c1x, c1y, c2x, c2y, x, y] = line.slice(i, i + 6);
5059           appearanceBuffer.push(
5060             [c1x, c1y, c2x, c2y, x, y].map(numberToString).join(" ") + " c"
5061           );
5062         }
5063       }
5064       if (line.length === 6) {
5065         appearanceBuffer.push(
5066           `${numberToString(line[4])} ${numberToString(line[5])} l`
5067         );
5068       }
5069     }
5070     appearanceBuffer.push(areContours ? "F" : "S");
5071 
5072     const appearance = appearanceBuffer.join("\n");
5073 
5074     const appearanceStreamDict = new Dict(xref);
5075     appearanceStreamDict.set("FormType", 1);
5076     appearanceStreamDict.set("Subtype", Name.get("Form"));
5077     appearanceStreamDict.set("Type", Name.get("XObject"));
5078     appearanceStreamDict.set("BBox", rect);
5079     appearanceStreamDict.set("Length", appearance.length);
5080 
5081     const ap = new StringStream(appearance);
5082     ap.dict = appearanceStreamDict;
5083 
5084     return ap;
5085   }
5086 
5087   static async createNewAppearanceStream(annotation, xref, params) {
5088     if (annotation.oldAnnotation) {
5089       // We'll use the AP we already have.
5090       return null;
5091     }
5092     if (annotation.isSignature) {
5093       return this.#createNewAppearanceStreamForDrawing(annotation, xref);
5094     }
5095 
5096     const { rotation } = annotation;
5097     const { imageRef, width, height } = params.image;
5098     const resources = new Dict(xref);
5099     const xobject = new Dict(xref);
5100     resources.set("XObject", xobject);
5101     xobject.set("Im0", imageRef);
5102     const appearance = `q ${width} 0 0 ${height} 0 0 cm /Im0 Do Q`;
5103 
5104     const appearanceStreamDict = new Dict(xref);
5105     appearanceStreamDict.set("FormType", 1);
5106     appearanceStreamDict.set("Subtype", Name.get("Form"));
5107     appearanceStreamDict.set("Type", Name.get("XObject"));
5108     appearanceStreamDict.set("BBox", [0, 0, width, height]);
5109     appearanceStreamDict.set("Resources", resources);
5110 
5111     if (rotation) {
5112       const matrix = getRotationMatrix(rotation, width, height);
5113       appearanceStreamDict.set("Matrix", matrix);
5114     }
5115 
5116     const ap = new StringStream(appearance);
5117     ap.dict = appearanceStreamDict;
5118 
5119     return ap;
5120   }
5121 }
5122 
5123 class FileAttachmentAnnotation extends MarkupAnnotation {
5124   constructor(params) {
5125     super(params);
5126 
5127     const { dict, xref } = params;
5128     const file = new FileSpec(dict.get("FS"), xref);
5129 
5130     this.data.annotationType = AnnotationType.FILEATTACHMENT;
5131     this.data.hasOwnCanvas = this.data.noRotate;
5132     this.data.noHTML = false;
5133     this.data.file = file.serializable;
5134 
5135     const name = dict.get("Name");
5136     this.data.name =
5137       name instanceof Name ? stringToPDFString(name.name) : "PushPin";
5138 
5139     const fillAlpha = dict.get("ca");
5140     this.data.fillAlpha =
5141       typeof fillAlpha === "number" && fillAlpha >= 0 && fillAlpha <= 1
5142         ? fillAlpha
5143         : null;
5144   }
5145 }
5146 
5147 export {
5148   Annotation,
5149   AnnotationBorderStyle,
5150   AnnotationFactory,
5151   getQuadPoints,
5152   MarkupAnnotation,
5153   PopupAnnotation,
5154   WidgetAnnotation,
5155 };
File:
src/core/core_utils.js
1 /* Copyright 2019 Mozilla Foundation
2  *
3  * Licensed under the Apache License, Version 2.0 (the "License");
4  * you may not use this file except in compliance with the License.
5  * You may obtain a copy of the License at
6  *
7  *     http://www.apache.org/licenses/LICENSE-2.0
8  *
9  * Unless required by applicable law or agreed to in writing, software
10  * distributed under the License is distributed on an "AS IS" BASIS,
11  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
12  * See the License for the specific language governing permissions and
13  * limitations under the License.
14  */
15 
16 import {
17   AnnotationEditorPrefix,
18   assert,
19   BaseException,
20   hexNumbers,
21   objectSize,
22   stringToPDFString,
23   Util,
24   warn,
25 } from "../shared/util.js";
26 import { Dict, isName, Ref, RefSet } from "./primitives.js";
27 import { BaseStream } from "./base_stream.js";
28 
29 const PDF_VERSION_REGEXP = /^[1-9]\.\d$/;
30 const MAX_INT_32 = 2 ** 31 - 1;
31 const MIN_INT_32 = -(2 ** 31);
32 
33 const IDENTITY_MATRIX = [1, 0, 0, 1, 0, 0];
34 
35 function getLookupTableFactory(initializer) {
36   let lookup;
37   return function () {
38     if (initializer) {
39       lookup = Object.create(null);
40       initializer(lookup);
41       initializer = null;
42     }
43     return lookup;
44   };
45 }
46 
47 class MissingDataException extends BaseException {
48   constructor(begin, end) {
49     super(`Missing data [${begin}, ${end})`, "MissingDataException");
50     this.begin = begin;
51     this.end = end;
52   }
53 }
54 
55 class ParserEOFException extends BaseException {
56   constructor(msg) {
57     super(msg, "ParserEOFException");
58   }
59 }
60 
61 class XRefEntryException extends BaseException {
62   constructor(msg) {
63     super(msg, "XRefEntryException");
64   }
65 }
66 
67 class XRefParseException extends BaseException {
68   constructor(msg) {
69     super(msg, "XRefParseException");
70   }
71 }
72 
73 /**
74  * Combines multiple ArrayBuffers into a single Uint8Array.
75  * @param {Array<ArrayBuffer>} arr - An array of ArrayBuffers.
76  * @returns {Uint8Array}
77  */
78 function arrayBuffersToBytes(arr) {
79   if (typeof PDFJSDev === "undefined" || PDFJSDev.test("TESTING")) {
80     for (const item of arr) {
81       assert(
82         item instanceof ArrayBuffer,
83         "arrayBuffersToBytes - expected an ArrayBuffer."
84       );
85     }
86   }
87   const length = arr.length;
88   if (length === 0) {
89     return new Uint8Array(0);
90   }
91   if (length === 1) {
92     return new Uint8Array(arr[0]);
93   }
94   let dataLength = 0;
95   for (let i = 0; i < length; i++) {
96     dataLength += arr[i].byteLength;
97   }
98   const data = new Uint8Array(dataLength);
99   let pos = 0;
100   for (let i = 0; i < length; i++) {
101     const item = new Uint8Array(arr[i]);
102     data.set(item, pos);
103     pos += item.byteLength;
104   }
105   return data;
106 }
107 
108 async function fetchBinaryData(url) {
109   const response = await fetch(url);
110   if (!response.ok) {
111     throw new Error(
112       `Failed to fetch file "${url}" with "${response.statusText}".`
113     );
114   }
115   return new Uint8Array(await response.arrayBuffer());
116 }
117 
118 /**
119  * Get the value of an inheritable property.
120  *
121  * If the PDF specification explicitly lists a property in a dictionary as
122  * inheritable, then the value of the property may be present in the dictionary
123  * itself or in one or more parents of the dictionary.
124  *
125  * If the key is not found in the tree, `undefined` is returned. Otherwise,
126  * the value for the key is returned or, if `stopWhenFound` is `false`, a list
127  * of values is returned.
128  *
129  * @param {Dict} dict - Dictionary from where to start the traversal.
130  * @param {string} key - The key of the property to find the value for.
131  * @param {boolean} getArray - Whether or not the value should be fetched as an
132  *   array. The default value is `false`.
133  * @param {boolean} stopWhenFound - Whether or not to stop the traversal when
134  *   the key is found. If set to `false`, we always walk up the entire parent
135  *   chain, for example to be able to find `\Resources` placed on multiple
136  *   levels of the tree. The default value is `true`.
137  */
138 function getInheritableProperty({
139   dict,
140   key,
141   getArray = false,
142   stopWhenFound = true,
143 }) {
144   let values;
145   const visited = new RefSet();
146 
147   while (dict instanceof Dict && !(dict.objId && visited.has(dict.objId))) {
148     if (dict.objId) {
149       visited.put(dict.objId);
150     }
151     const value = getArray ? dict.getArray(key) : dict.get(key);
152     if (value !== undefined) {
153       if (stopWhenFound) {
154         return value;
155       }
156       (values ||= []).push(value);
157     }
158     dict = dict.get("Parent");
159   }
160   return values;
161 }
162 
163 /**
164  * Get the parent dictionary to update when a property is set.
165  *
166  * @param {Dict} dict - Dictionary from where to start the traversal.
167  * @param {Ref} ref - The reference to the dictionary.
168  * @param {XRef} xref - The `XRef` instance.
169  */
170 function getParentToUpdate(dict, ref, xref) {
171   const visited = new RefSet();
172   const firstDict = dict;
173   const result = { dict: null, ref: null };
174 
175   while (dict instanceof Dict && !visited.has(ref)) {
176     visited.put(ref);
177     if (dict.has("T")) {
178       break;
179     }
180     ref = dict.getRaw("Parent");
181     if (!(ref instanceof Ref)) {
182       return result;
183     }
184     dict = xref.fetch(ref);
185   }
186   if (dict instanceof Dict && dict !== firstDict) {
187     result.dict = dict;
188     result.ref = ref;
189   }
190   return result;
191 }
192 
193 // prettier-ignore
194 const ROMAN_NUMBER_MAP = [
195   "", "C", "CC", "CCC", "CD", "D", "DC", "DCC", "DCCC", "CM",
196   "", "X", "XX", "XXX", "XL", "L", "LX", "LXX", "LXXX", "XC",
197   "", "I", "II", "III", "IV", "V", "VI", "VII", "VIII", "IX"
198 ];
199 
200 /**
201  * Converts positive integers to (upper case) Roman numerals.
202  * @param {number} number - The number that should be converted.
203  * @param {boolean} lowerCase - Indicates if the result should be converted
204  *   to lower case letters. The default value is `false`.
205  * @returns {string} The resulting Roman number.
206  */
207 function toRomanNumerals(number, lowerCase = false) {
208   assert(
209     Number.isInteger(number) && number > 0,
210     "The number should be a positive integer."
211   );
212 
213   const roman =
214     "M".repeat((number / 1000) | 0) +
215     ROMAN_NUMBER_MAP[((number % 1000) / 100) | 0] +
216     ROMAN_NUMBER_MAP[10 + (((number % 100) / 10) | 0)] +
217     ROMAN_NUMBER_MAP[20 + (number % 10)];
218   return lowerCase ? roman.toLowerCase() : roman;
219 }
220 
221 // Calculate the base 2 logarithm of the number `x`. This differs from the
222 // native function in the sense that it returns the ceiling value and that it
223 // returns 0 instead of `Infinity`/`NaN` for `x` values smaller than/equal to 0.
224 function log2(x) {
225   return x > 0 ? Math.ceil(Math.log2(x)) : 0;
226 }
227 
228 function readInt8(data, offset) {
229   return (data[offset] << 24) >> 24;
230 }
231 
232 function readInt16(data, offset) {
233   return ((data[offset] << 24) | (data[offset + 1] << 16)) >> 16;
234 }
235 
236 function readUint16(data, offset) {
237   return (data[offset] << 8) | data[offset + 1];
238 }
239 
240 function readUint32(data, offset) {
241   return (
242     ((data[offset] << 24) |
243       (data[offset + 1] << 16) |
244       (data[offset + 2] << 8) |
245       data[offset + 3]) >>>
246     0
247   );
248 }
249 
250 // Checks if ch is one of the following characters: SPACE, TAB, CR or LF.
251 function isWhiteSpace(ch) {
252   return ch === 0x20 || ch === 0x09 || ch === 0x0d || ch === 0x0a;
253 }
254 
255 /**
256  * Checks if something is an Array containing only boolean values,
257  * and (optionally) checks its length.
258  * @param {any} arr
259  * @param {number | null} len
260  * @returns {boolean}
261  */
262 function isBooleanArray(arr, len) {
263   return (
264     Array.isArray(arr) &&
265     (len === null || arr.length === len) &&
266     arr.every(x => typeof x === "boolean")
267   );
268 }
269 
270 /**
271  * Checks if something is an Array containing only numbers,
272  * and (optionally) checks its length.
273  * @param {any} arr
274  * @param {number | null} len
275  * @returns {boolean}
276  */
277 function isNumberArray(arr, len) {
278   if (Array.isArray(arr)) {
279     return (
280       (len === null || arr.length === len) &&
281       arr.every(x => typeof x === "number")
282     );
283   }
284 
285   // This check allows us to have typed arrays but not the
286   // BigInt64Array/BigUint64Array types (their elements aren't "number").
287   return (
288     ArrayBuffer.isView(arr) &&
289     !(arr instanceof BigInt64Array || arr instanceof BigUint64Array) &&
290     (len === null || arr.length === len)
291   );
292 }
293 
294 // Returns the matrix, or the fallback value if it's invalid.
295 function lookupMatrix(arr, fallback) {
296   return isNumberArray(arr, 6) ? arr : fallback;
297 }
298 
299 // Returns the rectangle, or the fallback value if it's invalid.
300 function lookupRect(arr, fallback) {
301   return isNumberArray(arr, 4) ? arr : fallback;
302 }
303 
304 // Returns the normalized rectangle, or the fallback value if it's invalid.
305 function lookupNormalRect(arr, fallback) {
306   return isNumberArray(arr, 4) ? Util.normalizeRect(arr) : fallback;
307 }
308 
309 /**
310  * AcroForm field names use an array like notation to refer to
311  * repeated XFA elements e.g. foo.bar[nnn].
312  * see: XFA Spec Chapter 3 - Repeated Elements
313  *
314  * @param {string} path - XFA path name.
315  * @returns {Array} - Array of Objects with the name and pos of
316  * each part of the path.
317  */
318 function parseXFAPath(path) {
319   const positionPattern = /(.+)\[(\d+)\]$/;
320   return path.split(".").map(component => {
321     const m = component.match(positionPattern);
322     if (m) {
323       return { name: m[1], pos: parseInt(m[2], 10) };
324     }
325     return { name: component, pos: 0 };
326   });
327 }
328 
329 function escapePDFName(str) {
330   const buffer = [];
331   let start = 0;
332   for (let i = 0, ii = str.length; i < ii; i++) {
333     const char = str.charCodeAt(i);
334     // Whitespace or delimiters aren't regular chars, so escape them.
335     if (
336       char < 0x21 ||
337       char > 0x7e ||
338       char === 0x23 /* # */ ||
339       char === 0x28 /* ( */ ||
340       char === 0x29 /* ) */ ||
341       char === 0x3c /* < */ ||
342       char === 0x3e /* > */ ||
343       char === 0x5b /* [ */ ||
344       char === 0x5d /* ] */ ||
345       char === 0x7b /* { */ ||
346       char === 0x7d /* } */ ||
347       char === 0x2f /* / */ ||
348       char === 0x25 /* % */
349     ) {
350       if (start < i) {
351         buffer.push(str.substring(start, i));
352       }
353       buffer.push(`#${char.toString(16)}`);
354       start = i + 1;
355     }
356   }
357 
358   if (buffer.length === 0) {
359     return str;
360   }
361 
362   if (start < str.length) {
363     buffer.push(str.substring(start, str.length));
364   }
365 
366   return buffer.join("");
367 }
368 
369 // Replace "(", ")", "\n", "\r" and "\" by "\(", "\)", "\\n", "\\r" and "\\"
370 // in order to write it in a PDF file.
371 function escapeString(str) {
372   return str.replaceAll(/([()\\\n\r])/g, match => {
373     if (match === "\n") {
374       return "\\n";
375     } else if (match === "\r") {
376       return "\\r";
377     }
378     return `\\${match}`;
379   });
380 }
381 
382 function _collectJS(entry, xref, list, parents) {
383   if (!entry) {
384     return;
385   }
386 
387   let parent = null;
388   if (entry instanceof Ref) {
389     if (parents.has(entry)) {
390       // If we've already found entry then we've a cycle.
391       return;
392     }
393     parent = entry;
394     parents.put(parent);
395     entry = xref.fetch(entry);
396   }
397   if (Array.isArray(entry)) {
398     for (const element of entry) {
399       _collectJS(element, xref, list, parents);
400     }
401   } else if (entry instanceof Dict) {
402     if (isName(entry.get("S"), "JavaScript")) {
403       const js = entry.get("JS");
404       let code;
405       if (js instanceof BaseStream) {
406         code = js.getString();
407       } else if (typeof js === "string") {
408         code = js;
409       }
410       code &&= stringToPDFString(code).replaceAll("\x00", "");
411       if (code) {
412         list.push(code);
413       }
414     }
415     _collectJS(entry.getRaw("Next"), xref, list, parents);
416   }
417 
418   if (parent) {
419     parents.remove(parent);
420   }
421 }
422 
423 function collectActions(xref, dict, eventType) {
424   const actions = Object.create(null);
425   const additionalActionsDicts = getInheritableProperty({
426     dict,
427     key: "AA",
428     stopWhenFound: false,
429   });
430   if (additionalActionsDicts) {
431     // additionalActionsDicts contains dicts from ancestors
432     // as they're found in the tree from bottom to top.
433     // So the dicts are visited in reverse order to guarantee
434     // that actions from elder ancestors will be overwritten
435     // by ones from younger ancestors.
436     for (let i = additionalActionsDicts.length - 1; i >= 0; i--) {
437       const additionalActions = additionalActionsDicts[i];
438       if (!(additionalActions instanceof Dict)) {
439         continue;
440       }
441       for (const key of additionalActions.getKeys()) {
442         const action = eventType[key];
443         if (!action) {
444           continue;
445         }
446         const actionDict = additionalActions.getRaw(key);
447         const parents = new RefSet();
448         const list = [];
449         _collectJS(actionDict, xref, list, parents);
450         if (list.length > 0) {
451           actions[action] = list;
452         }
453       }
454     }
455   }
456   // Collect the Action if any (we may have one on pushbutton).
457   if (dict.has("A")) {
458     const actionDict = dict.get("A");
459     const parents = new RefSet();
460     const list = [];
461     _collectJS(actionDict, xref, list, parents);
462     if (list.length > 0) {
463       actions.Action = list;
464     }
465   }
466   return objectSize(actions) > 0 ? actions : null;
467 }
468 
469 const XMLEntities = {
470   /* < */ 0x3c: "&lt;",
471   /* > */ 0x3e: "&gt;",
472   /* & */ 0x26: "&amp;",
473   /* " */ 0x22: "&quot;",
474   /* ' */ 0x27: "&apos;",
475 };
476 
477 function* codePointIter(str) {
478   for (let i = 0, ii = str.length; i < ii; i++) {
479     const char = str.codePointAt(i);
480     if (char > 0xd7ff && (char < 0xe000 || char > 0xfffd)) {
481       // char is represented by two u16
482       i++;
483     }
484     yield char;
485   }
486 }
487 
488 function encodeToXmlString(str) {
489   const buffer = [];
490   let start = 0;
491   for (let i = 0, ii = str.length; i < ii; i++) {
492     const char = str.codePointAt(i);
493     if (0x20 <= char && char <= 0x7e) {
494       // ascii
495       const entity = XMLEntities[char];
496       if (entity) {
497         if (start < i) {
498           buffer.push(str.substring(start, i));
499         }
500         buffer.push(entity);
501         start = i + 1;
502       }
503     } else {
504       if (start < i) {
505         buffer.push(str.substring(start, i));
506       }
507       buffer.push(`&#x${char.toString(16).toUpperCase()};`);
508       if (char > 0xd7ff && (char < 0xe000 || char > 0xfffd)) {
509         // char is represented by two u16
510         i++;
511       }
512       start = i + 1;
513     }
514   }
515 
516   if (buffer.length === 0) {
517     return str;
518   }
519   if (start < str.length) {
520     buffer.push(str.substring(start, str.length));
521   }
522   return buffer.join("");
523 }
524 
525 function validateFontName(fontFamily, mustWarn = false) {
526   // See https://developer.mozilla.org/en-US/docs/Web/CSS/string.
527   const m = /^("|').*("|')$/.exec(fontFamily);
528   if (m && m[1] === m[2]) {
529     const re = new RegExp(`[^\\\\]${m[1]}`);
530     if (re.test(fontFamily.slice(1, -1))) {
531       if (mustWarn) {
532         warn(`FontFamily contains unescaped ${m[1]}: ${fontFamily}.`);
533       }
534       return false;
535     }
536   } else {
537     // See https://developer.mozilla.org/en-US/docs/Web/CSS/custom-ident.
538     for (const ident of fontFamily.split(/[ \t]+/)) {
539       if (/^(\d|(-(\d|-)))/.test(ident) || !/^[\w-\\]+$/.test(ident)) {
540         if (mustWarn) {
541           warn(`FontFamily contains invalid <custom-ident>: ${fontFamily}.`);
542         }
543         return false;
544       }
545     }
546   }
547   return true;
548 }
549 
550 function validateCSSFont(cssFontInfo) {
551   // See https://developer.mozilla.org/en-US/docs/Web/CSS/font-style.
552   const DEFAULT_CSS_FONT_OBLIQUE = "14";
553   // See https://developer.mozilla.org/en-US/docs/Web/CSS/font-weight.
554   const DEFAULT_CSS_FONT_WEIGHT = "400";
555   const CSS_FONT_WEIGHT_VALUES = new Set([
556     "100",
557     "200",
558     "300",
559     "400",
560     "500",
561     "600",
562     "700",
563     "800",
564     "900",
565     "1000",
566     "normal",
567     "bold",
568     "bolder",
569     "lighter",
570   ]);
571 
572   const { fontFamily, fontWeight, italicAngle } = cssFontInfo;
573 
574   if (!validateFontName(fontFamily, true)) {
575     return false;
576   }
577 
578   const weight = fontWeight ? fontWeight.toString() : "";
579   cssFontInfo.fontWeight = CSS_FONT_WEIGHT_VALUES.has(weight)
580     ? weight
581     : DEFAULT_CSS_FONT_WEIGHT;
582 
583   const angle = parseFloat(italicAngle);
584   cssFontInfo.italicAngle =
585     isNaN(angle) || angle < -90 || angle > 90
586       ? DEFAULT_CSS_FONT_OBLIQUE
587       : italicAngle.toString();
588 
589   return true;
590 }
591 
592 function recoverJsURL(str) {
593   // Attempt to recover valid URLs from `JS` entries with certain
594   // white-listed formats:
595   //  - window.open('http://example.com')
596   //  - app.launchURL('http://example.com', true)
597   //  - xfa.host.gotoURL('http://example.com')
598   const URL_OPEN_METHODS = ["app.launchURL", "window.open", "xfa.host.gotoURL"];
599   const regex = new RegExp(
600     "^\\s*(" +
601       URL_OPEN_METHODS.join("|").replaceAll(".", "\\.") +
602       ")\\((?:'|\")([^'\"]*)(?:'|\")(?:,\\s*(\\w+)\\)|\\))",
603     "i"
604   );
605 
606   const jsUrl = regex.exec(str);
607   if (jsUrl?.[2]) {
608     return {
609       url: jsUrl[2],
610       newWindow: jsUrl[1] === "app.launchURL" && jsUrl[3] === "true",
611     };
612   }
613 
614   return null;
615 }
616 
617 function numberToString(value) {
618   if (Number.isInteger(value)) {
619     return value.toString();
620   }
621 
622   const roundedValue = Math.round(value * 100);
623   if (roundedValue % 100 === 0) {
624     return (roundedValue / 100).toString();
625   }
626 
627   if (roundedValue % 10 === 0) {
628     return value.toFixed(1);
629   }
630 
631   return value.toFixed(2);
632 }
633 
634 function getNewAnnotationsMap(annotationStorage) {
635   if (!annotationStorage) {
636     return null;
637   }
638   const newAnnotationsByPage = new Map();
639   // The concept of page in a XFA is very different, so
640   // editing is just not implemented.
641   for (const [key, value] of annotationStorage) {
642     if (!key.startsWith(AnnotationEditorPrefix)) {
643       continue;
644     }
645     let annotations = newAnnotationsByPage.get(value.pageIndex);
646     if (!annotations) {
647       annotations = [];
648       newAnnotationsByPage.set(value.pageIndex, annotations);
649     }
650     annotations.push(value);
651   }
652   return newAnnotationsByPage.size > 0 ? newAnnotationsByPage : null;
653 }
654 
655 function stringToAsciiOrUTF16BE(str) {
656   return isAscii(str) ? str : stringToUTF16String(str, /* bigEndian = */ true);
657 }
658 
659 function isAscii(str) {
660   return /^[\x00-\x7F]*$/.test(str);
661 }
662 
663 function stringToUTF16HexString(str) {
664   const buf = [];
665   for (let i = 0, ii = str.length; i < ii; i++) {
666     const char = str.charCodeAt(i);
667     buf.push(hexNumbers[(char >> 8) & 0xff], hexNumbers[char & 0xff]);
668   }
669   return buf.join("");
670 }
671 
672 function stringToUTF16String(str, bigEndian = false) {
673   const buf = [];
674   if (bigEndian) {
675     buf.push("\xFE\xFF");
676   }
677   for (let i = 0, ii = str.length; i < ii; i++) {
678     const char = str.charCodeAt(i);
679     buf.push(
680       String.fromCharCode((char >> 8) & 0xff),
681       String.fromCharCode(char & 0xff)
682     );
683   }
684   return buf.join("");
685 }
686 
687 function getRotationMatrix(rotation, width, height) {
688   switch (rotation) {
689     case 90:
690       return [0, 1, -1, 0, width, 0];
691     case 180:
692       return [-1, 0, 0, -1, width, height];
693     case 270:
694       return [0, -1, 1, 0, 0, height];
695     default:
696       throw new Error("Invalid rotation");
697   }
698 }
699 
700 /**
701  * Get the number of bytes to use to represent the given positive integer.
702  * If n is zero, the function returns 0 which means that we don't need to waste
703  * a byte to represent it.
704  * @param {number} x - a positive integer.
705  * @returns {number}
706  */
707 function getSizeInBytes(x) {
708   // n bits are required for numbers up to 2^n - 1.
709   // So for a number x, we need ceil(log2(1 + x)) bits.
710   return Math.ceil(Math.ceil(Math.log2(1 + x)) / 8);
711 }
712 
713 export {
714   arrayBuffersToBytes,
715   codePointIter,
716   collectActions,
717   encodeToXmlString,
718   escapePDFName,
719   escapeString,
720   fetchBinaryData,
721   getInheritableProperty,
722   getLookupTableFactory,
723   getNewAnnotationsMap,
724   getParentToUpdate,
725   getRotationMatrix,
726   getSizeInBytes,
727   IDENTITY_MATRIX,
728   isAscii,
729   isBooleanArray,
730   isNumberArray,
731   isWhiteSpace,
732   log2,
733   lookupMatrix,
734   lookupNormalRect,
735   lookupRect,
736   MAX_INT_32,
737   MIN_INT_32,
738   MissingDataException,
739   numberToString,
740   ParserEOFException,
741   parseXFAPath,
742   PDF_VERSION_REGEXP,
743   readInt16,
744   readInt8,
745   readUint16,
746   readUint32,
747   recoverJsURL,
748   stringToAsciiOrUTF16BE,
749   stringToUTF16HexString,
750   stringToUTF16String,
751   toRomanNumerals,
752   validateCSSFont,
753   validateFontName,
754   XRefEntryException,
755   XRefParseException,
756 };
File:
src/core/document.js
1 /* Copyright 2012 Mozilla Foundation
2  *
3  * Licensed under the Apache License, Version 2.0 (the "License");
4  * you may not use this file except in compliance with the License.
5  * You may obtain a copy of the License at
6  *
7  *     http://www.apache.org/licenses/LICENSE-2.0
8  *
9  * Unless required by applicable law or agreed to in writing, software
10  * distributed under the License is distributed on an "AS IS" BASIS,
11  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
12  * See the License for the specific language governing permissions and
13  * limitations under the License.
14  */
15 
16 import {
17   AnnotationEditorPrefix,
18   assert,
19   FormatError,
20   info,
21   InvalidPDFException,
22   isArrayEqual,
23   objectSize,
24   PageActionEventType,
25   RenderingIntentFlag,
26   shadow,
27   stringToBytes,
28   stringToPDFString,
29   stringToUTF8String,
30   toHexUtil,
31   unreachable,
32   Util,
33   warn,
34 } from "../shared/util.js";
35 import {
36   AnnotationFactory,
37   PopupAnnotation,
38   WidgetAnnotation,
39 } from "./annotation.js";
40 import {
41   collectActions,
42   getInheritableProperty,
43   getNewAnnotationsMap,
44   isWhiteSpace,
45   lookupNormalRect,
46   MissingDataException,
47   PDF_VERSION_REGEXP,
48   validateCSSFont,
49   XRefEntryException,
50   XRefParseException,
51 } from "./core_utils.js";
52 import {
53   Dict,
54   isName,
55   isRefsEqual,
56   Name,
57   Ref,
58   RefSet,
59   RefSetCache,
60 } from "./primitives.js";
61 import { getXfaFontDict, getXfaFontName } from "./xfa_fonts.js";
62 import { BaseStream } from "./base_stream.js";
63 import { calculateMD5 } from "./calculate_md5.js";
64 import { Catalog } from "./catalog.js";
65 import { clearGlobalCaches } from "./cleanup_helper.js";
66 import { DatasetReader } from "./dataset_reader.js";
67 import { Linearization } from "./parser.js";
68 import { NullStream } from "./stream.js";
69 import { ObjectLoader } from "./object_loader.js";
70 import { OperatorList } from "./operator_list.js";
71 import { PartialEvaluator } from "./evaluator.js";
72 import { StreamsSequenceStream } from "./decode_stream.js";
73 import { StructTreePage } from "./struct_tree.js";
74 import { XFAFactory } from "./xfa/factory.js";
75 import { XRef } from "./xref.js";
76 
77 const LETTER_SIZE_MEDIABOX = [0, 0, 612, 792];
78 
79 class Page {
80   constructor({
81     pdfManager,
82     xref,
83     pageIndex,
84     pageDict,
85     ref,
86     globalIdFactory,
87     fontCache,
88     builtInCMapCache,
89     standardFontDataCache,
90     globalColorSpaceCache,
91     globalImageCache,
92     systemFontCache,
93     nonBlendModesSet,
94     xfaFactory,
95   }) {
96     this.pdfManager = pdfManager;
97     this.pageIndex = pageIndex;
98     this.pageDict = pageDict;
99     this.xref = xref;
100     this.ref = ref;
101     this.fontCache = fontCache;
102     this.builtInCMapCache = builtInCMapCache;
103     this.standardFontDataCache = standardFontDataCache;
104     this.globalColorSpaceCache = globalColorSpaceCache;
105     this.globalImageCache = globalImageCache;
106     this.systemFontCache = systemFontCache;
107     this.nonBlendModesSet = nonBlendModesSet;
108     this.evaluatorOptions = pdfManager.evaluatorOptions;
109     this.resourcesPromise = null;
110     this.xfaFactory = xfaFactory;
111 
112     const idCounters = {
113       obj: 0,
114     };
115     this._localIdFactory = class extends globalIdFactory {
116       static createObjId() {
117         return `p${pageIndex}_${++idCounters.obj}`;
118       }
119 
120       static getPageObjId() {
121         return `p${ref.toString()}`;
122       }
123     };
124   }
125 
126   /**
127    * @private
128    */
129   _getInheritableProperty(key, getArray = false) {
130     const value = getInheritableProperty({
131       dict: this.pageDict,
132       key,
133       getArray,
134       stopWhenFound: false,
135     });
136     if (!Array.isArray(value)) {
137       return value;
138     }
139     if (value.length === 1 || !(value[0] instanceof Dict)) {
140       return value[0];
141     }
142     return Dict.merge({ xref: this.xref, dictArray: value });
143   }
144 
145   get content() {
146     return this.pageDict.getArray("Contents");
147   }
148 
149   get resources() {
150     // For robustness: The spec states that a \Resources entry has to be
151     // present, but can be empty. Some documents still omit it; in this case
152     // we return an empty dictionary.
153     const resources = this._getInheritableProperty("Resources");
154 
155     return shadow(
156       this,
157       "resources",
158       resources instanceof Dict ? resources : Dict.empty
159     );
160   }
161 
162   _getBoundingBox(name) {
163     if (this.xfaData) {
164       return this.xfaData.bbox;
165     }
166     const box = lookupNormalRect(
167       this._getInheritableProperty(name, /* getArray = */ true),
168       null
169     );
170 
171     if (box) {
172       if (box[2] - box[0] > 0 && box[3] - box[1] > 0) {
173         return box;
174       }
175       warn(`Empty, or invalid, /${name} entry.`);
176     }
177     return null;
178   }
179 
180   get mediaBox() {
181     // Reset invalid media box to letter size.
182     return shadow(
183       this,
184       "mediaBox",
185       this._getBoundingBox("MediaBox") || LETTER_SIZE_MEDIABOX
186     );
187   }
188 
189   get cropBox() {
190     // Reset invalid crop box to media box.
191     return shadow(
192       this,
193       "cropBox",
194       this._getBoundingBox("CropBox") || this.mediaBox
195     );
196   }
197 
198   get userUnit() {
199     const obj = this.pageDict.get("UserUnit");
200     return shadow(
201       this,
202       "userUnit",
203       typeof obj === "number" && obj > 0 ? obj : 1.0
204     );
205   }
206 
207   get view() {
208     // From the spec, 6th ed., p.963:
209     // "The crop, bleed, trim, and art boxes should not ordinarily
210     // extend beyond the boundaries of the media box. If they do, they are
211     // effectively reduced to their intersection with the media box."
212     const { cropBox, mediaBox } = this;
213 
214     if (cropBox !== mediaBox && !isArrayEqual(cropBox, mediaBox)) {
215       const box = Util.intersect(cropBox, mediaBox);
216       if (box && box[2] - box[0] > 0 && box[3] - box[1] > 0) {
217         return shadow(this, "view", box);
218       }
219       warn("Empty /CropBox and /MediaBox intersection.");
220     }
221     return shadow(this, "view", mediaBox);
222   }
223 
224   get rotate() {
225     let rotate = this._getInheritableProperty("Rotate") || 0;
226 
227     // Normalize rotation so it's a multiple of 90 and between 0 and 270.
228     if (rotate % 90 !== 0) {
229       rotate = 0;
230     } else if (rotate >= 360) {
231       rotate %= 360;
232     } else if (rotate < 0) {
233       // The spec doesn't cover negatives. Assume it's counterclockwise
234       // rotation. The following is the other implementation of modulo.
235       rotate = ((rotate % 360) + 360) % 360;
236     }
237     return shadow(this, "rotate", rotate);
238   }
239 
240   /**
241    * @private
242    */
243   _onSubStreamError(reason, objId) {
244     if (this.evaluatorOptions.ignoreErrors) {
245       warn(`getContentStream - ignoring sub-stream (${objId}): "${reason}".`);
246       return;
247     }
248     throw reason;
249   }
250 
251   /**
252    * @returns {Promise<BaseStream>}
253    */
254   async getContentStream() {
255     const content = await this.pdfManager.ensure(this, "content");
256 
257     if (content instanceof BaseStream) {
258       return content;
259     }
260     if (Array.isArray(content)) {
261       return new StreamsSequenceStream(
262         content,
263         this._onSubStreamError.bind(this)
264       );
265     }
266     // Replace non-existent page content with empty content.
267     return new NullStream();
268   }
269 
270   get xfaData() {
271     return shadow(
272       this,
273       "xfaData",
274       this.xfaFactory
275         ? { bbox: this.xfaFactory.getBoundingBox(this.pageIndex) }
276         : null
277     );
278   }
279 
280   async #replaceIdByRef(annotations, deletedAnnotations, existingAnnotations) {
281     const promises = [];
282     for (const annotation of annotations) {
283       if (annotation.id) {
284         const ref = Ref.fromString(annotation.id);
285         if (!ref) {
286           warn(`A non-linked annotation cannot be modified: ${annotation.id}`);
287           continue;
288         }
289         if (annotation.deleted) {
290           deletedAnnotations.put(ref, ref);
291           if (annotation.popupRef) {
292             const popupRef = Ref.fromString(annotation.popupRef);
293             if (popupRef) {
294               deletedAnnotations.put(popupRef, popupRef);
295             }
296           }
297           continue;
298         }
299         existingAnnotations?.put(ref);
300         annotation.ref = ref;
301         promises.push(
302           this.xref.fetchAsync(ref).then(
303             obj => {
304               if (obj instanceof Dict) {
305                 annotation.oldAnnotation = obj.clone();
306               }
307             },
308             () => {
309               warn(`Cannot fetch \`oldAnnotation\` for: ${ref}.`);
310             }
311           )
312         );
313         delete annotation.id;
314       }
315     }
316     await Promise.all(promises);
317   }
318 
319   async saveNewAnnotations(handler, task, annotations, imagePromises, changes) {
320     if (this.xfaFactory) {
321       throw new Error("XFA: Cannot save new annotations.");
322     }
323 
324     const partialEvaluator = new PartialEvaluator({
325       xref: this.xref,
326       handler,
327       pageIndex: this.pageIndex,
328       idFactory: this._localIdFactory,
329       fontCache: this.fontCache,
330       builtInCMapCache: this.builtInCMapCache,
331       standardFontDataCache: this.standardFontDataCache,
332       globalColorSpaceCache: this.globalColorSpaceCache,
333       globalImageCache: this.globalImageCache,
334       systemFontCache: this.systemFontCache,
335       options: this.evaluatorOptions,
336     });
337 
338     const deletedAnnotations = new RefSetCache();
339     const existingAnnotations = new RefSet();
340     await this.#replaceIdByRef(
341       annotations,
342       deletedAnnotations,
343       existingAnnotations
344     );
345 
346     const pageDict = this.pageDict;
347     const annotationsArray = this.annotations.filter(
348       a => !(a instanceof Ref && deletedAnnotations.has(a))
349     );
350     const newData = await AnnotationFactory.saveNewAnnotations(
351       partialEvaluator,
352       task,
353       annotations,
354       imagePromises,
355       changes
356     );
357 
358     for (const { ref } of newData.annotations) {
359       // Don't add an existing annotation ref to the annotations array.
360       if (ref instanceof Ref && !existingAnnotations.has(ref)) {
361         annotationsArray.push(ref);
362       }
363     }
364 
365     const dict = pageDict.clone();
366     dict.set("Annots", annotationsArray);
367     changes.put(this.ref, {
368       data: dict,
369     });
370 
371     for (const deletedRef of deletedAnnotations) {
372       changes.put(deletedRef, {
373         data: null,
374       });
375     }
376   }
377 
378   async save(handler, task, annotationStorage, changes) {
379     const partialEvaluator = new PartialEvaluator({
380       xref: this.xref,
381       handler,
382       pageIndex: this.pageIndex,
383       idFactory: this._localIdFactory,
384       fontCache: this.fontCache,
385       builtInCMapCache: this.builtInCMapCache,
386       standardFontDataCache: this.standardFontDataCache,
387       globalColorSpaceCache: this.globalColorSpaceCache,
388       globalImageCache: this.globalImageCache,
389       systemFontCache: this.systemFontCache,
390       options: this.evaluatorOptions,
391     });
392 
393     // Fetch the page's annotations and save the content
394     // in case of interactive form fields.
395     const annotations = await this._parsedAnnotations;
396 
397     const promises = [];
398     for (const annotation of annotations) {
399       promises.push(
400         annotation
401           .save(partialEvaluator, task, annotationStorage, changes)
402           .catch(function (reason) {
403             warn(
404               "save - ignoring annotation data during " +
405                 `"${task.name}" task: "${reason}".`
406             );
407             return null;
408           })
409       );
410     }
411     return Promise.all(promises);
412   }
413 
414   async loadResources(keys) {
415     // TODO: add async `_getInheritableProperty` and remove this.
416     await (this.resourcesPromise ??= this.pdfManager.ensure(this, "resources"));
417 
418     const objectLoader = new ObjectLoader(this.resources, keys, this.xref);
419     await objectLoader.load();
420   }
421 
422   async getOperatorList({
423     handler,
424     sink,
425     task,
426     intent,
427     cacheKey,
428     annotationStorage = null,
429     modifiedIds = null,
430   }) {
431     const contentStreamPromise = this.getContentStream();
432     const resourcesPromise = this.loadResources([
433       "ColorSpace",
434       "ExtGState",
435       "Font",
436       "Pattern",
437       "Properties",
438       "Shading",
439       "XObject",
440     ]);
441 
442     const partialEvaluator = new PartialEvaluator({
443       xref: this.xref,
444       handler,
445       pageIndex: this.pageIndex,
446       idFactory: this._localIdFactory,
447       fontCache: this.fontCache,
448       builtInCMapCache: this.builtInCMapCache,
449       standardFontDataCache: this.standardFontDataCache,
450       globalColorSpaceCache: this.globalColorSpaceCache,
451       globalImageCache: this.globalImageCache,
452       systemFontCache: this.systemFontCache,
453       options: this.evaluatorOptions,
454     });
455 
456     const newAnnotsByPage = !this.xfaFactory
457       ? getNewAnnotationsMap(annotationStorage)
458       : null;
459     const newAnnots = newAnnotsByPage?.get(this.pageIndex);
460     let newAnnotationsPromise = Promise.resolve(null);
461     let deletedAnnotations = null;
462 
463     if (newAnnots) {
464       const annotationGlobalsPromise =
465         this.pdfManager.ensureDoc("annotationGlobals");
466       let imagePromises;
467 
468       // An annotation can contain a reference to a bitmap, but this bitmap
469       // is defined in another annotation. So we need to find this annotation
470       // and generate the bitmap.
471       const missingBitmaps = new Set();
472       for (const { bitmapId, bitmap } of newAnnots) {
473         if (bitmapId && !bitmap && !missingBitmaps.has(bitmapId)) {
474           missingBitmaps.add(bitmapId);
475         }
476       }
477 
478       const { isOffscreenCanvasSupported } = this.evaluatorOptions;
479       if (missingBitmaps.size > 0) {
480         const annotationWithBitmaps = newAnnots.slice();
481         for (const [key, annotation] of annotationStorage) {
482           if (!key.startsWith(AnnotationEditorPrefix)) {
483             continue;
484           }
485           if (annotation.bitmap && missingBitmaps.has(annotation.bitmapId)) {
486             annotationWithBitmaps.push(annotation);
487           }
488         }
489         // The array annotationWithBitmaps cannot be empty: the check above
490         // makes sure to have at least one annotation containing the bitmap.
491         imagePromises = AnnotationFactory.generateImages(
492           annotationWithBitmaps,
493           this.xref,
494           isOffscreenCanvasSupported
495         );
496       } else {
497         imagePromises = AnnotationFactory.generateImages(
498           newAnnots,
499           this.xref,
500           isOffscreenCanvasSupported
501         );
502       }
503 
504       deletedAnnotations = new RefSet();
505 
506       newAnnotationsPromise = Promise.all([
507         annotationGlobalsPromise,
508         this.#replaceIdByRef(newAnnots, deletedAnnotations, null),
509       ]).then(([annotationGlobals]) => {
510         if (!annotationGlobals) {
511           return null;
512         }
513 
514         return AnnotationFactory.printNewAnnotations(
515           annotationGlobals,
516           partialEvaluator,
517           task,
518           newAnnots,
519           imagePromises
520         );
521       });
522     }
523 
524     const pageListPromise = Promise.all([
525       contentStreamPromise,
526       resourcesPromise,
527     ]).then(async ([contentStream]) => {
528       const opList = new OperatorList(intent, sink);
529 
530       handler.send("StartRenderPage", {
531         transparency: partialEvaluator.hasBlendModes(
532           this.resources,
533           this.nonBlendModesSet
534         ),
535         pageIndex: this.pageIndex,
536         cacheKey,
537       });
538 
539       await partialEvaluator.getOperatorList({
540         stream: contentStream,
541         task,
542         resources: this.resources,
543         operatorList: opList,
544       });
545       return opList;
546     });
547 
548     // Fetch the page's annotations and add their operator lists to the
549     // page's operator list to render them.
550     // eslint-disable-next-line prefer-const
551     let [pageOpList, annotations, newAnnotations] = await Promise.all([
552       pageListPromise,
553       this._parsedAnnotations,
554       newAnnotationsPromise,
555     ]);
556 
557     if (newAnnotations) {
558       // Some annotations can already exist (if it has the refToReplace
559       // property). In this case, we replace the old annotation by the new one.
560       annotations = annotations.filter(
561         a => !(a.ref && deletedAnnotations.has(a.ref))
562       );
563       for (let i = 0, ii = newAnnotations.length; i < ii; i++) {
564         const newAnnotation = newAnnotations[i];
565         if (newAnnotation.refToReplace) {
566           const j = annotations.findIndex(
567             a => a.ref && isRefsEqual(a.ref, newAnnotation.refToReplace)
568           );
569           if (j >= 0) {
570             annotations.splice(j, 1, newAnnotation);
571             newAnnotations.splice(i--, 1);
572             ii--;
573           }
574         }
575       }
576       annotations = annotations.concat(newAnnotations);
577     }
578     if (
579       annotations.length === 0 ||
580       intent & RenderingIntentFlag.ANNOTATIONS_DISABLE
581     ) {
582       pageOpList.flush(/* lastChunk = */ true);
583       return { length: pageOpList.totalLength };
584     }
585     const renderForms = !!(intent & RenderingIntentFlag.ANNOTATIONS_FORMS),
586       isEditing = !!(intent & RenderingIntentFlag.IS_EDITING),
587       intentAny = !!(intent & RenderingIntentFlag.ANY),
588       intentDisplay = !!(intent & RenderingIntentFlag.DISPLAY),
589       intentPrint = !!(intent & RenderingIntentFlag.PRINT);
590 
591     // Collect the operator list promises for the annotations. Each promise
592     // is resolved with the complete operator list for a single annotation.
593     const opListPromises = [];
594     for (const annotation of annotations) {
595       if (
596         intentAny ||
597         (intentDisplay &&
598           annotation.mustBeViewed(annotationStorage, renderForms) &&
599           annotation.mustBeViewedWhenEditing(isEditing, modifiedIds)) ||
600         (intentPrint && annotation.mustBePrinted(annotationStorage))
601       ) {
602         opListPromises.push(
603           annotation
604             .getOperatorList(partialEvaluator, task, intent, annotationStorage)
605             .catch(function (reason) {
606               warn(
607                 "getOperatorList - ignoring annotation data during " +
608                   `"${task.name}" task: "${reason}".`
609               );
610               return {
611                 opList: null,
612                 separateForm: false,
613                 separateCanvas: false,
614               };
615             })
616         );
617       }
618     }
619 
620     const opLists = await Promise.all(opListPromises);
621     let form = false,
622       canvas = false;
623 
624     for (const { opList, separateForm, separateCanvas } of opLists) {
625       pageOpList.addOpList(opList);
626 
627       form ||= separateForm;
628       canvas ||= separateCanvas;
629     }
630     pageOpList.flush(
631       /* lastChunk = */ true,
632       /* separateAnnots = */ { form, canvas }
633     );
634     return { length: pageOpList.totalLength };
635   }
636 
637   async extractTextContent({
638     handler,
639     task,
640     includeMarkedContent,
641     disableNormalization,
642     sink,
643   }) {
644     const contentStreamPromise = this.getContentStream();
645     const resourcesPromise = this.loadResources([
646       "ExtGState",
647       "Font",
648       "Properties",
649       "XObject",
650     ]);
651     const langPromise = this.pdfManager.ensureCatalog("lang");
652 
653     const [contentStream, , lang] = await Promise.all([
654       contentStreamPromise,
655       resourcesPromise,
656       langPromise,
657     ]);
658     const partialEvaluator = new PartialEvaluator({
659       xref: this.xref,
660       handler,
661       pageIndex: this.pageIndex,
662       idFactory: this._localIdFactory,
663       fontCache: this.fontCache,
664       builtInCMapCache: this.builtInCMapCache,
665       standardFontDataCache: this.standardFontDataCache,
666       globalColorSpaceCache: this.globalColorSpaceCache,
667       globalImageCache: this.globalImageCache,
668       systemFontCache: this.systemFontCache,
669       options: this.evaluatorOptions,
670     });
671 
672     return partialEvaluator.getTextContent({
673       stream: contentStream,
674       task,
675       resources: this.resources,
676       includeMarkedContent,
677       disableNormalization,
678       sink,
679       viewBox: this.view,
680       lang,
681     });
682   }
683 
684   async getStructTree() {
685     const structTreeRoot =
686       await this.pdfManager.ensureCatalog("structTreeRoot");
687     if (!structTreeRoot) {
688       return null;
689     }
690     // Ensure that the structTree will contain the page's annotations.
691     await this._parsedAnnotations;
692 
693     const structTree = await this.pdfManager.ensure(this, "_parseStructTree", [
694       structTreeRoot,
695     ]);
696     return this.pdfManager.ensure(structTree, "serializable");
697   }
698 
699   /**
700    * @private
701    */
702   _parseStructTree(structTreeRoot) {
703     const tree = new StructTreePage(structTreeRoot, this.pageDict);
704     tree.parse(this.ref);
705     return tree;
706   }
707 
708   async getAnnotationsData(handler, task, intent) {
709     const annotations = await this._parsedAnnotations;
710     if (annotations.length === 0) {
711       return annotations;
712     }
713 
714     const annotationsData = [],
715       textContentPromises = [];
716     let partialEvaluator;
717 
718     const intentAny = !!(intent & RenderingIntentFlag.ANY),
719       intentDisplay = !!(intent & RenderingIntentFlag.DISPLAY),
720       intentPrint = !!(intent & RenderingIntentFlag.PRINT);
721 
722     for (const annotation of annotations) {
723       // Get the annotation even if it's hidden because
724       // JS can change its display.
725       const isVisible = intentAny || (intentDisplay && annotation.viewable);
726       if (isVisible || (intentPrint && annotation.printable)) {
727         annotationsData.push(annotation.data);
728       }
729 
730       if (annotation.hasTextContent && isVisible) {
731         partialEvaluator ||= new PartialEvaluator({
732           xref: this.xref,
733           handler,
734           pageIndex: this.pageIndex,
735           idFactory: this._localIdFactory,
736           fontCache: this.fontCache,
737           builtInCMapCache: this.builtInCMapCache,
738           standardFontDataCache: this.standardFontDataCache,
739           globalColorSpaceCache: this.globalColorSpaceCache,
740           globalImageCache: this.globalImageCache,
741           systemFontCache: this.systemFontCache,
742           options: this.evaluatorOptions,
743         });
744 
745         textContentPromises.push(
746           annotation
747             .extractTextContent(partialEvaluator, task, [
748               -Infinity,
749               -Infinity,
750               Infinity,
751               Infinity,
752             ])
753             .catch(function (reason) {
754               warn(
755                 `getAnnotationsData - ignoring textContent during "${task.name}" task: "${reason}".`
756               );
757             })
758         );
759       }
760     }
761 
762     await Promise.all(textContentPromises);
763     return annotationsData;
764   }
765 
766   get annotations() {
767     const annots = this._getInheritableProperty("Annots");
768     return shadow(this, "annotations", Array.isArray(annots) ? annots : []);
769   }
770 
771   get _parsedAnnotations() {
772     const promise = this.pdfManager
773       .ensure(this, "annotations")
774       .then(async annots => {
775         if (annots.length === 0) {
776           return annots;
777         }
778 
779         const [annotationGlobals, fieldObjects] = await Promise.all([
780           this.pdfManager.ensureDoc("annotationGlobals"),
781           this.pdfManager.ensureDoc("fieldObjects"),
782         ]);
783         if (!annotationGlobals) {
784           return [];
785         }
786 
787         const orphanFields = fieldObjects?.orphanFields;
788         const annotationPromises = [];
789         for (const annotationRef of annots) {
790           annotationPromises.push(
791             AnnotationFactory.create(
792               this.xref,
793               annotationRef,
794               annotationGlobals,
795               this._localIdFactory,
796               /* collectFields */ false,
797               orphanFields,
798               this.ref
799             ).catch(function (reason) {
800               warn(`_parsedAnnotations: "${reason}".`);
801               return null;
802             })
803           );
804         }
805 
806         const sortedAnnotations = [];
807         let popupAnnotations, widgetAnnotations;
808         // Ensure that PopupAnnotations are handled last, since they depend on
809         // their parent Annotation in the display layer; fixes issue 11362.
810         for (const annotation of await Promise.all(annotationPromises)) {
811           if (!annotation) {
812             continue;
813           }
814           if (annotation instanceof WidgetAnnotation) {
815             (widgetAnnotations ||= []).push(annotation);
816             continue;
817           }
818           if (annotation instanceof PopupAnnotation) {
819             (popupAnnotations ||= []).push(annotation);
820             continue;
821           }
822           sortedAnnotations.push(annotation);
823         }
824         if (widgetAnnotations) {
825           sortedAnnotations.push(...widgetAnnotations);
826         }
827         if (popupAnnotations) {
828           sortedAnnotations.push(...popupAnnotations);
829         }
830 
831         return sortedAnnotations;
832       });
833 
834     return shadow(this, "_parsedAnnotations", promise);
835   }
836 
837   get jsActions() {
838     const actions = collectActions(
839       this.xref,
840       this.pageDict,
841       PageActionEventType
842     );
843     return shadow(this, "jsActions", actions);
844   }
845 }
846 
847 const PDF_HEADER_SIGNATURE = new Uint8Array([0x25, 0x50, 0x44, 0x46, 0x2d]);
848 const STARTXREF_SIGNATURE = new Uint8Array([
849   0x73, 0x74, 0x61, 0x72, 0x74, 0x78, 0x72, 0x65, 0x66,
850 ]);
851 const ENDOBJ_SIGNATURE = new Uint8Array([0x65, 0x6e, 0x64, 0x6f, 0x62, 0x6a]);
852 
853 function find(stream, signature, limit = 1024, backwards = false) {
854   if (typeof PDFJSDev === "undefined" || PDFJSDev.test("TESTING")) {
855     assert(limit > 0, 'The "limit" must be a positive integer.');
856   }
857   const signatureLength = signature.length;
858 
859   const scanBytes = stream.peekBytes(limit);
860   const scanLength = scanBytes.length - signatureLength;
861 
862   if (scanLength <= 0) {
863     return false;
864   }
865   if (backwards) {
866     const signatureEnd = signatureLength - 1;
867 
868     let pos = scanBytes.length - 1;
869     while (pos >= signatureEnd) {
870       let j = 0;
871       while (
872         j < signatureLength &&
873         scanBytes[pos - j] === signature[signatureEnd - j]
874       ) {
875         j++;
876       }
877       if (j >= signatureLength) {
878         // `signature` found.
879         stream.pos += pos - signatureEnd;
880         return true;
881       }
882       pos--;
883     }
884   } else {
885     // forwards
886     let pos = 0;
887     while (pos <= scanLength) {
888       let j = 0;
889       while (j < signatureLength && scanBytes[pos + j] === signature[j]) {
890         j++;
891       }
892       if (j >= signatureLength) {
893         // `signature` found.
894         stream.pos += pos;
895         return true;
896       }
897       pos++;
898     }
899   }
900   return false;
901 }
902 
903 /**
904  * The `PDFDocument` class holds all the (worker-thread) data of the PDF file.
905  */
906 class PDFDocument {
907   constructor(pdfManager, stream) {
908     if (typeof PDFJSDev === "undefined" || PDFJSDev.test("TESTING")) {
909       assert(
910         stream instanceof BaseStream,
911         'PDFDocument: Invalid "stream" argument.'
912       );
913     }
914     if (stream.length <= 0) {
915       throw new InvalidPDFException(
916         "The PDF file is empty, i.e. its size is zero bytes."
917       );
918     }
919 
920     this.pdfManager = pdfManager;
921     this.stream = stream;
922     this.xref = new XRef(stream, pdfManager);
923     this._pagePromises = new Map();
924     this._version = null;
925 
926     const idCounters = {
927       font: 0,
928     };
929     this._globalIdFactory = class {
930       static getDocId() {
931         return `g_${pdfManager.docId}`;
932       }
933 
934       static createFontId() {
935         return `f${++idCounters.font}`;
936       }
937 
938       static createObjId() {
939         unreachable("Abstract method `createObjId` called.");
940       }
941 
942       static getPageObjId() {
943         unreachable("Abstract method `getPageObjId` called.");
944       }
945     };
946   }
947 
948   parse(recoveryMode) {
949     this.xref.parse(recoveryMode);
950     this.catalog = new Catalog(this.pdfManager, this.xref);
951   }
952 
953   get linearization() {
954     let linearization = null;
955     try {
956       linearization = Linearization.create(this.stream);
957     } catch (err) {
958       if (err instanceof MissingDataException) {
959         throw err;
960       }
961       info(err);
962     }
963     return shadow(this, "linearization", linearization);
964   }
965 
966   get startXRef() {
967     const stream = this.stream;
968     let startXRef = 0;
969 
970     if (this.linearization) {
971       // Find the end of the first object.
972       stream.reset();
973       if (find(stream, ENDOBJ_SIGNATURE)) {
974         stream.skip(6);
975 
976         let ch = stream.peekByte();
977         while (isWhiteSpace(ch)) {
978           stream.pos++;
979           ch = stream.peekByte();
980         }
981         startXRef = stream.pos - stream.start;
982       }
983     } else {
984       // Find `startxref` by checking backwards from the end of the file.
985       const step = 1024;
986       const startXRefLength = STARTXREF_SIGNATURE.length;
987       let found = false,
988         pos = stream.end;
989 
990       while (!found && pos > 0) {
991         pos -= step - startXRefLength;
992         if (pos < 0) {
993           pos = 0;
994         }
995         stream.pos = pos;
996         found = find(stream, STARTXREF_SIGNATURE, step, true);
997       }
998 
999       if (found) {
1000         stream.skip(9);
1001         let ch;
1002         do {
1003           ch = stream.getByte();
1004         } while (isWhiteSpace(ch));
1005         let str = "";
1006         while (ch >= /* Space = */ 0x20 && ch <= /* '9' = */ 0x39) {
1007           str += String.fromCharCode(ch);
1008           ch = stream.getByte();
1009         }
1010         startXRef = parseInt(str, 10);
1011         if (isNaN(startXRef)) {
1012           startXRef = 0;
1013         }
1014       }
1015     }
1016     return shadow(this, "startXRef", startXRef);
1017   }
1018 
1019   // Find the header, get the PDF format version and setup the
1020   // stream to start from the header.
1021   checkHeader() {
1022     const stream = this.stream;
1023     stream.reset();
1024 
1025     if (!find(stream, PDF_HEADER_SIGNATURE)) {
1026       // May not be a PDF file, but don't throw an error and let
1027       // parsing continue.
1028       return;
1029     }
1030     stream.moveStart();
1031 
1032     // Skip over the "%PDF-" prefix, since it was found above.
1033     stream.skip(PDF_HEADER_SIGNATURE.length);
1034     // Read the PDF format version.
1035     let version = "",
1036       ch;
1037     while (
1038       (ch = stream.getByte()) > /* Space = */ 0x20 &&
1039       version.length < /* MAX_PDF_VERSION_LENGTH = */ 7
1040     ) {
1041       version += String.fromCharCode(ch);
1042     }
1043 
1044     if (PDF_VERSION_REGEXP.test(version)) {
1045       this._version = version;
1046     } else {
1047       warn(`Invalid PDF header version: ${version}`);
1048     }
1049   }
1050 
1051   parseStartXRef() {
1052     this.xref.setStartXRef(this.startXRef);
1053   }
1054 
1055   get numPages() {
1056     let num = 0;
1057     if (this.catalog.hasActualNumPages) {
1058       num = this.catalog.numPages;
1059     } else if (this.xfaFactory) {
1060       // num is a Promise.
1061       num = this.xfaFactory.getNumPages();
1062     } else if (this.linearization) {
1063       num = this.linearization.numPages;
1064     } else {
1065       num = this.catalog.numPages;
1066     }
1067     return shadow(this, "numPages", num);
1068   }
1069 
1070   /**
1071    * @private
1072    */
1073   _hasOnlyDocumentSignatures(fields, recursionDepth = 0) {
1074     const RECURSION_LIMIT = 10;
1075 
1076     if (!Array.isArray(fields)) {
1077       return false;
1078     }
1079     return fields.every(field => {
1080       field = this.xref.fetchIfRef(field);
1081       if (!(field instanceof Dict)) {
1082         return false;
1083       }
1084       if (field.has("Kids")) {
1085         if (++recursionDepth > RECURSION_LIMIT) {
1086           warn("_hasOnlyDocumentSignatures: maximum recursion depth reached");
1087           return false;
1088         }
1089         return this._hasOnlyDocumentSignatures(
1090           field.get("Kids"),
1091           recursionDepth
1092         );
1093       }
1094       const isSignature = isName(field.get("FT"), "Sig");
1095       const rectangle = field.get("Rect");
1096       const isInvisible =
1097         Array.isArray(rectangle) && rectangle.every(value => value === 0);
1098       return isSignature && isInvisible;
1099     });
1100   }
1101 
1102   get _xfaStreams() {
1103     const acroForm = this.catalog.acroForm;
1104     if (!acroForm) {
1105       return null;
1106     }
1107 
1108     const xfa = acroForm.get("XFA");
1109     const entries = {
1110       "xdp:xdp": "",
1111       template: "",
1112       datasets: "",
1113       config: "",
1114       connectionSet: "",
1115       localeSet: "",
1116       stylesheet: "",
1117       "/xdp:xdp": "",
1118     };
1119     if (xfa instanceof BaseStream && !xfa.isEmpty) {
1120       entries["xdp:xdp"] = xfa;
1121       return entries;
1122     }
1123 
1124     if (!Array.isArray(xfa) || xfa.length === 0) {
1125       return null;
1126     }
1127 
1128     for (let i = 0, ii = xfa.length; i < ii; i += 2) {
1129       let name;
1130       if (i === 0) {
1131         name = "xdp:xdp";
1132       } else if (i === ii - 2) {
1133         name = "/xdp:xdp";
1134       } else {
1135         name = xfa[i];
1136       }
1137 
1138       if (!entries.hasOwnProperty(name)) {
1139         continue;
1140       }
1141       const data = this.xref.fetchIfRef(xfa[i + 1]);
1142       if (!(data instanceof BaseStream) || data.isEmpty) {
1143         continue;
1144       }
1145       entries[name] = data;
1146     }
1147     return entries;
1148   }
1149 
1150   get xfaDatasets() {
1151     const streams = this._xfaStreams;
1152     if (!streams) {
1153       return shadow(this, "xfaDatasets", null);
1154     }
1155     for (const key of ["datasets", "xdp:xdp"]) {
1156       const stream = streams[key];
1157       if (!stream) {
1158         continue;
1159       }
1160       try {
1161         const str = stringToUTF8String(stream.getString());
1162         const data = { [key]: str };
1163         return shadow(this, "xfaDatasets", new DatasetReader(data));
1164       } catch {
1165         warn("XFA - Invalid utf-8 string.");
1166         break;
1167       }
1168     }
1169     return shadow(this, "xfaDatasets", null);
1170   }
1171 
1172   get xfaData() {
1173     const streams = this._xfaStreams;
1174     if (!streams) {
1175       return null;
1176     }
1177     const data = Object.create(null);
1178     for (const [key, stream] of Object.entries(streams)) {
1179       if (!stream) {
1180         continue;
1181       }
1182       try {
1183         data[key] = stringToUTF8String(stream.getString());
1184       } catch {
1185         warn("XFA - Invalid utf-8 string.");
1186         return null;
1187       }
1188     }
1189     return data;
1190   }
1191 
1192   get xfaFactory() {
1193     let data;
1194     if (
1195       this.pdfManager.enableXfa &&
1196       this.catalog.needsRendering &&
1197       this.formInfo.hasXfa &&
1198       !this.formInfo.hasAcroForm
1199     ) {
1200       data = this.xfaData;
1201     }
1202     return shadow(this, "xfaFactory", data ? new XFAFactory(data) : null);
1203   }
1204 
1205   get isPureXfa() {
1206     return this.xfaFactory ? this.xfaFactory.isValid() : false;
1207   }
1208 
1209   get htmlForXfa() {
1210     return this.xfaFactory ? this.xfaFactory.getPages() : null;
1211   }
1212 
1213   async loadXfaImages() {
1214     const xfaImagesDict = await this.pdfManager.ensureCatalog("xfaImages");
1215     if (!xfaImagesDict) {
1216       return;
1217     }
1218 
1219     const keys = xfaImagesDict.getKeys();
1220     const objectLoader = new ObjectLoader(xfaImagesDict, keys, this.xref);
1221     await objectLoader.load();
1222 
1223     const xfaImages = new Map();
1224     for (const key of keys) {
1225       const stream = xfaImagesDict.get(key);
1226       if (stream instanceof BaseStream) {
1227         xfaImages.set(key, stream.getBytes());
1228       }
1229     }
1230 
1231     this.xfaFactory.setImages(xfaImages);
1232   }
1233 
1234   async loadXfaFonts(handler, task) {
1235     const acroForm = await this.pdfManager.ensureCatalog("acroForm");
1236     if (!acroForm) {
1237       return;
1238     }
1239     const resources = await acroForm.getAsync("DR");
1240     if (!(resources instanceof Dict)) {
1241       return;
1242     }
1243     const objectLoader = new ObjectLoader(resources, ["Font"], this.xref);
1244     await objectLoader.load();
1245 
1246     const fontRes = resources.get("Font");
1247     if (!(fontRes instanceof Dict)) {
1248       return;
1249     }
1250 
1251     const options = Object.assign(
1252       Object.create(null),
1253       this.pdfManager.evaluatorOptions
1254     );
1255     options.useSystemFonts = false;
1256 
1257     const partialEvaluator = new PartialEvaluator({
1258       xref: this.xref,
1259       handler,
1260       pageIndex: -1,
1261       idFactory: this._globalIdFactory,
1262       fontCache: this.catalog.fontCache,
1263       builtInCMapCache: this.catalog.builtInCMapCache,
1264       standardFontDataCache: this.catalog.standardFontDataCache,
1265       options,
1266     });
1267     const operatorList = new OperatorList();
1268     const pdfFonts = [];
1269     const initialState = {
1270       get font() {
1271         return pdfFonts.at(-1);
1272       },
1273       set font(font) {
1274         pdfFonts.push(font);
1275       },
1276       clone() {
1277         return this;
1278       },
1279     };
1280 
1281     const promises = [];
1282     for (const [fontName, font] of fontRes) {
1283       const descriptor = font.get("FontDescriptor");
1284       if (!(descriptor instanceof Dict)) {
1285         continue;
1286       }
1287       let fontFamily = descriptor.get("FontFamily");
1288       // For example, "Wingdings 3" is not a valid font name in the css specs.
1289       fontFamily = fontFamily.replaceAll(/[ ]+(\d)/g, "$1");
1290       const fontWeight = descriptor.get("FontWeight");
1291 
1292       // Angle is expressed in degrees counterclockwise in PDF
1293       // when it's clockwise in CSS
1294       // (see https://drafts.csswg.org/css-fonts-4/#valdef-font-style-oblique-angle)
1295       const italicAngle = -descriptor.get("ItalicAngle");
1296       const cssFontInfo = { fontFamily, fontWeight, italicAngle };
1297 
1298       if (!validateCSSFont(cssFontInfo)) {
1299         continue;
1300       }
1301       promises.push(
1302         partialEvaluator
1303           .handleSetFont(
1304             resources,
1305             [Name.get(fontName), 1],
1306             /* fontRef = */ null,
1307             operatorList,
1308             task,
1309             initialState,
1310             /* fallbackFontDict = */ null,
1311             /* cssFontInfo = */ cssFontInfo
1312           )
1313           .catch(function (reason) {
1314             warn(`loadXfaFonts: "${reason}".`);
1315             return null;
1316           })
1317       );
1318     }
1319 
1320     await Promise.all(promises);
1321     const missingFonts = this.xfaFactory.setFonts(pdfFonts);
1322 
1323     if (!missingFonts) {
1324       return;
1325     }
1326 
1327     options.ignoreErrors = true;
1328     promises.length = 0;
1329     pdfFonts.length = 0;
1330 
1331     const reallyMissingFonts = new Set();
1332     for (const missing of missingFonts) {
1333       if (!getXfaFontName(`${missing}-Regular`)) {
1334         // No substitution available: we'll fallback on Myriad.
1335         reallyMissingFonts.add(missing);
1336       }
1337     }
1338 
1339     if (reallyMissingFonts.size) {
1340       missingFonts.push("PdfJS-Fallback");
1341     }
1342 
1343     for (const missing of missingFonts) {
1344       if (reallyMissingFonts.has(missing)) {
1345         continue;
1346       }
1347       for (const fontInfo of [
1348         { name: "Regular", fontWeight: 400, italicAngle: 0 },
1349         { name: "Bold", fontWeight: 700, italicAngle: 0 },
1350         { name: "Italic", fontWeight: 400, italicAngle: 12 },
1351         { name: "BoldItalic", fontWeight: 700, italicAngle: 12 },
1352       ]) {
1353         const name = `${missing}-${fontInfo.name}`;
1354         const dict = getXfaFontDict(name);
1355 
1356         promises.push(
1357           partialEvaluator
1358             .handleSetFont(
1359               resources,
1360               [Name.get(name), 1],
1361               /* fontRef = */ null,
1362               operatorList,
1363               task,
1364               initialState,
1365               /* fallbackFontDict = */ dict,
1366               /* cssFontInfo = */ {
1367                 fontFamily: missing,
1368                 fontWeight: fontInfo.fontWeight,
1369                 italicAngle: fontInfo.italicAngle,
1370               }
1371             )
1372             .catch(function (reason) {
1373               warn(`loadXfaFonts: "${reason}".`);
1374               return null;
1375             })
1376         );
1377       }
1378     }
1379 
1380     await Promise.all(promises);
1381     this.xfaFactory.appendFonts(pdfFonts, reallyMissingFonts);
1382   }
1383 
1384   async serializeXfaData(annotationStorage) {
1385     return this.xfaFactory
1386       ? this.xfaFactory.serializeData(annotationStorage)
1387       : null;
1388   }
1389 
1390   /**
1391    * The specification states in section 7.5.2 that the version from
1392    * the catalog, if present, should overwrite the version from the header.
1393    */
1394   get version() {
1395     return this.catalog.version || this._version;
1396   }
1397 
1398   get formInfo() {
1399     const formInfo = {
1400       hasFields: false,
1401       hasAcroForm: false,
1402       hasXfa: false,
1403       hasSignatures: false,
1404     };
1405     const acroForm = this.catalog.acroForm;
1406     if (!acroForm) {
1407       return shadow(this, "formInfo", formInfo);
1408     }
1409 
1410     try {
1411       const fields = acroForm.get("Fields");
1412       const hasFields = Array.isArray(fields) && fields.length > 0;
1413       formInfo.hasFields = hasFields; // Used by the `fieldObjects` getter.
1414 
1415       // The document contains XFA data if the `XFA` entry is a non-empty
1416       // array or stream.
1417       const xfa = acroForm.get("XFA");
1418       formInfo.hasXfa =
1419         (Array.isArray(xfa) && xfa.length > 0) ||
1420         (xfa instanceof BaseStream && !xfa.isEmpty);
1421 
1422       // The document contains AcroForm data if the `Fields` entry is a
1423       // non-empty array and it doesn't consist of only document signatures.
1424       // This second check is required for files that don't actually contain
1425       // AcroForm data (only XFA data), but that use the `Fields` entry to
1426       // store (invisible) document signatures. This can be detected using
1427       // the first bit of the `SigFlags` integer (see Table 219 in the
1428       // specification).
1429       const sigFlags = acroForm.get("SigFlags");
1430       const hasSignatures = !!(sigFlags & 0x1);
1431       const hasOnlyDocumentSignatures =
1432         hasSignatures && this._hasOnlyDocumentSignatures(fields);
1433       formInfo.hasAcroForm = hasFields && !hasOnlyDocumentSignatures;
1434       formInfo.hasSignatures = hasSignatures;
1435     } catch (ex) {
1436       if (ex instanceof MissingDataException) {
1437         throw ex;
1438       }
1439       warn(`Cannot fetch form information: "${ex}".`);
1440     }
1441     return shadow(this, "formInfo", formInfo);
1442   }
1443 
1444   get documentInfo() {
1445     const docInfo = {
1446       PDFFormatVersion: this.version,
1447       Language: this.catalog.lang,
1448       EncryptFilterName: this.xref.encrypt
1449         ? this.xref.encrypt.filterName
1450         : null,
1451       IsLinearized: !!this.linearization,
1452       IsAcroFormPresent: this.formInfo.hasAcroForm,
1453       IsXFAPresent: this.formInfo.hasXfa,
1454       IsCollectionPresent: !!this.catalog.collection,
1455       IsSignaturesPresent: this.formInfo.hasSignatures,
1456     };
1457 
1458     let infoDict;
1459     try {
1460       infoDict = this.xref.trailer.get("Info");
1461     } catch (err) {
1462       if (err instanceof MissingDataException) {
1463         throw err;
1464       }
1465       info("The document information dictionary is invalid.");
1466     }
1467     if (!(infoDict instanceof Dict)) {
1468       return shadow(this, "documentInfo", docInfo);
1469     }
1470 
1471     for (const [key, value] of infoDict) {
1472       switch (key) {
1473         case "Title":
1474         case "Author":
1475         case "Subject":
1476         case "Keywords":
1477         case "Creator":
1478         case "Producer":
1479         case "CreationDate":
1480         case "ModDate":
1481           if (typeof value === "string") {
1482             docInfo[key] = stringToPDFString(value);
1483             continue;
1484           }
1485           break;
1486         case "Trapped":
1487           if (value instanceof Name) {
1488             docInfo[key] = value;
1489             continue;
1490           }
1491           break;
1492         default:
1493           // For custom values, only accept white-listed types to prevent
1494           // errors that would occur when trying to send non-serializable
1495           // objects to the main-thread (for example `Dict` or `Stream`).
1496           let customValue;
1497           switch (typeof value) {
1498             case "string":
1499               customValue = stringToPDFString(value);
1500               break;
1501             case "number":
1502             case "boolean":
1503               customValue = value;
1504               break;
1505             default:
1506               if (value instanceof Name) {
1507                 customValue = value;
1508               }
1509               break;
1510           }
1511 
1512           if (customValue === undefined) {
1513             warn(`Bad value, for custom key "${key}", in Info: ${value}.`);
1514             continue;
1515           }
1516           if (!docInfo.Custom) {
1517             docInfo.Custom = Object.create(null);
1518           }
1519           docInfo.Custom[key] = customValue;
1520           continue;
1521       }
1522       warn(`Bad value, for key "${key}", in Info: ${value}.`);
1523     }
1524     return shadow(this, "documentInfo", docInfo);
1525   }
1526 
1527   get fingerprints() {
1528     const FINGERPRINT_FIRST_BYTES = 1024;
1529     const EMPTY_FINGERPRINT = "\x00".repeat(16);
1530 
1531     function validate(data) {
1532       return (
1533         typeof data === "string" &&
1534         data.length === 16 &&
1535         data !== EMPTY_FINGERPRINT
1536       );
1537     }
1538 
1539     const id = this.xref.trailer.get("ID");
1540     let hashOriginal, hashModified;
1541     if (Array.isArray(id) && validate(id[0])) {
1542       hashOriginal = stringToBytes(id[0]);
1543 
1544       if (id[1] !== id[0] && validate(id[1])) {
1545         hashModified = stringToBytes(id[1]);
1546       }
1547     } else {
1548       hashOriginal = calculateMD5(
1549         this.stream.getByteRange(0, FINGERPRINT_FIRST_BYTES),
1550         0,
1551         FINGERPRINT_FIRST_BYTES
1552       );
1553     }
1554 
1555     return shadow(this, "fingerprints", [
1556       toHexUtil(hashOriginal),
1557       hashModified ? toHexUtil(hashModified) : null,
1558     ]);
1559   }
1560 
1561   async _getLinearizationPage(pageIndex) {
1562     const { catalog, linearization, xref } = this;
1563     if (typeof PDFJSDev === "undefined" || PDFJSDev.test("TESTING")) {
1564       assert(
1565         linearization?.pageFirst === pageIndex,
1566         "_getLinearizationPage - invalid pageIndex argument."
1567       );
1568     }
1569 
1570     const ref = Ref.get(linearization.objectNumberFirst, 0);
1571     try {
1572       const obj = await xref.fetchAsync(ref);
1573       // Ensure that the object that was found is actually a Page dictionary.
1574       if (obj instanceof Dict) {
1575         let type = obj.getRaw("Type");
1576         if (type instanceof Ref) {
1577           type = await xref.fetchAsync(type);
1578         }
1579         if (
1580           isName(type, "Page") ||
1581           (!obj.has("Type") && !obj.has("Kids") && obj.has("Contents"))
1582         ) {
1583           if (!catalog.pageKidsCountCache.has(ref)) {
1584             catalog.pageKidsCountCache.put(ref, 1); // Cache the Page reference.
1585           }
1586           // Help improve performance of the `Catalog.getPageIndex` method.
1587           if (!catalog.pageIndexCache.has(ref)) {
1588             catalog.pageIndexCache.put(ref, 0);
1589           }
1590 
1591           return [obj, ref];
1592         }
1593       }
1594       throw new FormatError(
1595         "The Linearization dictionary doesn't point to a valid Page dictionary."
1596       );
1597     } catch (reason) {
1598       warn(`_getLinearizationPage: "${reason.message}".`);
1599       return catalog.getPageDict(pageIndex);
1600     }
1601   }
1602 
1603   getPage(pageIndex) {
1604     const cachedPromise = this._pagePromises.get(pageIndex);
1605     if (cachedPromise) {
1606       return cachedPromise;
1607     }
1608     const { catalog, linearization, xfaFactory } = this;
1609 
1610     let promise;
1611     if (xfaFactory) {
1612       promise = Promise.resolve([Dict.empty, null]);
1613     } else if (linearization?.pageFirst === pageIndex) {
1614       promise = this._getLinearizationPage(pageIndex);
1615     } else {
1616       promise = catalog.getPageDict(pageIndex);
1617     }
1618     promise = promise.then(
1619       ([pageDict, ref]) =>
1620         new Page({
1621           pdfManager: this.pdfManager,
1622           xref: this.xref,
1623           pageIndex,
1624           pageDict,
1625           ref,
1626           globalIdFactory: this._globalIdFactory,
1627           fontCache: catalog.fontCache,
1628           builtInCMapCache: catalog.builtInCMapCache,
1629           standardFontDataCache: catalog.standardFontDataCache,
1630           globalColorSpaceCache: catalog.globalColorSpaceCache,
1631           globalImageCache: catalog.globalImageCache,
1632           systemFontCache: catalog.systemFontCache,
1633           nonBlendModesSet: catalog.nonBlendModesSet,
1634           xfaFactory,
1635         })
1636     );
1637 
1638     this._pagePromises.set(pageIndex, promise);
1639     return promise;
1640   }
1641 
1642   async checkFirstPage(recoveryMode = false) {
1643     if (recoveryMode) {
1644       return;
1645     }
1646     try {
1647       await this.getPage(0);
1648     } catch (reason) {
1649       if (reason instanceof XRefEntryException) {
1650         // Clear out the various caches to ensure that we haven't stored any
1651         // inconsistent and/or incorrect state, since that could easily break
1652         // subsequent `this.getPage` calls.
1653         this._pagePromises.delete(0);
1654         await this.cleanup();
1655 
1656         throw new XRefParseException();
1657       }
1658     }
1659   }
1660 
1661   async checkLastPage(recoveryMode = false) {
1662     const { catalog, pdfManager } = this;
1663 
1664     catalog.setActualNumPages(); // Ensure that it's always reset.
1665     let numPages;
1666 
1667     try {
1668       await Promise.all([
1669         pdfManager.ensureDoc("xfaFactory"),
1670         pdfManager.ensureDoc("linearization"),
1671         pdfManager.ensureCatalog("numPages"),
1672       ]);
1673 
1674       if (this.xfaFactory) {
1675         return; // The Page count is always calculated for XFA-documents.
1676       } else if (this.linearization) {
1677         numPages = this.linearization.numPages;
1678       } else {
1679         numPages = catalog.numPages;
1680       }
1681 
1682       if (!Number.isInteger(numPages)) {
1683         throw new FormatError("Page count is not an integer.");
1684       } else if (numPages <= 1) {
1685         return;
1686       }
1687       await this.getPage(numPages - 1);
1688     } catch (reason) {
1689       // Clear out the various caches to ensure that we haven't stored any
1690       // inconsistent and/or incorrect state, since that could easily break
1691       // subsequent `this.getPage` calls.
1692       this._pagePromises.delete(numPages - 1);
1693       await this.cleanup();
1694 
1695       if (reason instanceof XRefEntryException && !recoveryMode) {
1696         throw new XRefParseException();
1697       }
1698       warn(`checkLastPage - invalid /Pages tree /Count: ${numPages}.`);
1699 
1700       let pagesTree;
1701       try {
1702         pagesTree = await catalog.getAllPageDicts(recoveryMode);
1703       } catch (reasonAll) {
1704         if (reasonAll instanceof XRefEntryException && !recoveryMode) {
1705           throw new XRefParseException();
1706         }
1707         catalog.setActualNumPages(1);
1708         return;
1709       }
1710 
1711       for (const [pageIndex, [pageDict, ref]] of pagesTree) {
1712         let promise;
1713         if (pageDict instanceof Error) {
1714           promise = Promise.reject(pageDict);
1715 
1716           // Prevent "uncaught exception: Object"-messages in the console.
1717           promise.catch(() => {});
1718         } else {
1719           promise = Promise.resolve(
1720             new Page({
1721               pdfManager,
1722               xref: this.xref,
1723               pageIndex,
1724               pageDict,
1725               ref,
1726               globalIdFactory: this._globalIdFactory,
1727               fontCache: catalog.fontCache,
1728               builtInCMapCache: catalog.builtInCMapCache,
1729               standardFontDataCache: catalog.standardFontDataCache,
1730               globalColorSpaceCache: this.globalColorSpaceCache,
1731               globalImageCache: catalog.globalImageCache,
1732               systemFontCache: catalog.systemFontCache,
1733               nonBlendModesSet: catalog.nonBlendModesSet,
1734               xfaFactory: null,
1735             })
1736           );
1737         }
1738 
1739         this._pagePromises.set(pageIndex, promise);
1740       }
1741       catalog.setActualNumPages(pagesTree.size);
1742     }
1743   }
1744 
1745   async fontFallback(id, handler) {
1746     const { catalog, pdfManager } = this;
1747 
1748     for (const translatedFont of await Promise.all(catalog.fontCache)) {
1749       if (translatedFont.loadedName === id) {
1750         translatedFont.fallback(handler, pdfManager.evaluatorOptions);
1751         return;
1752       }
1753     }
1754   }
1755 
1756   async cleanup(manuallyTriggered = false) {
1757     return this.catalog
1758       ? this.catalog.cleanup(manuallyTriggered)
1759       : clearGlobalCaches();
1760   }
1761 
1762   async #collectFieldObjects(
1763     name,
1764     parentRef,
1765     fieldRef,
1766     promises,
1767     annotationGlobals,
1768     visitedRefs,
1769     orphanFields
1770   ) {
1771     const { xref } = this;
1772 
1773     if (!(fieldRef instanceof Ref) || visitedRefs.has(fieldRef)) {
1774       return;
1775     }
1776     visitedRefs.put(fieldRef);
1777     const field = await xref.fetchAsync(fieldRef);
1778     if (!(field instanceof Dict)) {
1779       return;
1780     }
1781     let subtype = await field.getAsync("Subtype");
1782     subtype = subtype instanceof Name ? subtype.name : null;
1783     // Skip unrelated annotation types (see issue 19281).
1784     switch (subtype) {
1785       case "Link":
1786         return;
1787     }
1788     if (field.has("T")) {
1789       const partName = stringToPDFString(await field.getAsync("T"));
1790       name = name === "" ? partName : `${name}.${partName}`;
1791     } else {
1792       let obj = field;
1793       while (true) {
1794         obj = obj.getRaw("Parent") || parentRef;
1795         if (obj instanceof Ref) {
1796           if (visitedRefs.has(obj)) {
1797             break;
1798           }
1799           obj = await xref.fetchAsync(obj);
1800         }
1801         if (!(obj instanceof Dict)) {
1802           break;
1803         }
1804         if (obj.has("T")) {
1805           const partName = stringToPDFString(await obj.getAsync("T"));
1806           name = name === "" ? partName : `${name}.${partName}`;
1807           break;
1808         }
1809       }
1810     }
1811 
1812     if (
1813       parentRef &&
1814       !field.has("Parent") &&
1815       isName(field.get("Subtype"), "Widget")
1816     ) {
1817       // We've a parent from the Fields array, but the field hasn't.
1818       orphanFields.put(fieldRef, parentRef);
1819     }
1820 
1821     if (!promises.has(name)) {
1822       promises.set(name, []);
1823     }
1824     promises.get(name).push(
1825       AnnotationFactory.create(
1826         xref,
1827         fieldRef,
1828         annotationGlobals,
1829         /* idFactory = */ null,
1830         /* collectFields */ true,
1831         orphanFields,
1832         /* pageRef */ null
1833       )
1834         .then(annotation => annotation?.getFieldObject())
1835         .catch(function (reason) {
1836           warn(`#collectFieldObjects: "${reason}".`);
1837           return null;
1838         })
1839     );
1840 
1841     if (!field.has("Kids")) {
1842       return;
1843     }
1844     const kids = await field.getAsync("Kids");
1845     if (Array.isArray(kids)) {
1846       for (const kid of kids) {
1847         await this.#collectFieldObjects(
1848           name,
1849           fieldRef,
1850           kid,
1851           promises,
1852           annotationGlobals,
1853           visitedRefs,
1854           orphanFields
1855         );
1856       }
1857     }
1858   }
1859 
1860   get fieldObjects() {
1861     const promise = this.pdfManager
1862       .ensureDoc("formInfo")
1863       .then(async formInfo => {
1864         if (!formInfo.hasFields) {
1865           return null;
1866         }
1867 
1868         const [annotationGlobals, acroForm] = await Promise.all([
1869           this.pdfManager.ensureDoc("annotationGlobals"),
1870           this.pdfManager.ensureCatalog("acroForm"),
1871         ]);
1872         if (!annotationGlobals) {
1873           return null;
1874         }
1875 
1876         const visitedRefs = new RefSet();
1877         const allFields = Object.create(null);
1878         const fieldPromises = new Map();
1879         const orphanFields = new RefSetCache();
1880         for (const fieldRef of await acroForm.getAsync("Fields")) {
1881           await this.#collectFieldObjects(
1882             "",
1883             null,
1884             fieldRef,
1885             fieldPromises,
1886             annotationGlobals,
1887             visitedRefs,
1888             orphanFields
1889           );
1890         }
1891 
1892         const allPromises = [];
1893         for (const [name, promises] of fieldPromises) {
1894           allPromises.push(
1895             Promise.all(promises).then(fields => {
1896               fields = fields.filter(field => !!field);
1897               if (fields.length > 0) {
1898                 allFields[name] = fields;
1899               }
1900             })
1901           );
1902         }
1903         await Promise.all(allPromises);
1904 
1905         return {
1906           allFields: objectSize(allFields) > 0 ? allFields : null,
1907           orphanFields,
1908         };
1909       });
1910 
1911     return shadow(this, "fieldObjects", promise);
1912   }
1913 
1914   get hasJSActions() {
1915     const promise = this.pdfManager.ensureDoc("_parseHasJSActions");
1916     return shadow(this, "hasJSActions", promise);
1917   }
1918 
1919   /**
1920    * @private
1921    */
1922   async _parseHasJSActions() {
1923     const [catalogJsActions, fieldObjects] = await Promise.all([
1924       this.pdfManager.ensureCatalog("jsActions"),
1925       this.pdfManager.ensureDoc("fieldObjects"),
1926     ]);
1927 
1928     if (catalogJsActions) {
1929       return true;
1930     }
1931     if (fieldObjects?.allFields) {
1932       return Object.values(fieldObjects.allFields).some(fieldObject =>
1933         fieldObject.some(object => object.actions !== null)
1934       );
1935     }
1936     return false;
1937   }
1938 
1939   get calculationOrderIds() {
1940     const calculationOrder = this.catalog.acroForm?.get("CO");
1941     if (!Array.isArray(calculationOrder) || calculationOrder.length === 0) {
1942       return shadow(this, "calculationOrderIds", null);
1943     }
1944 
1945     const ids = [];
1946     for (const id of calculationOrder) {
1947       if (id instanceof Ref) {
1948         ids.push(id.toString());
1949       }
1950     }
1951     return shadow(this, "calculationOrderIds", ids.length ? ids : null);
1952   }
1953 
1954   get annotationGlobals() {
1955     return shadow(
1956       this,
1957       "annotationGlobals",
1958       AnnotationFactory.createGlobals(this.pdfManager)
1959     );
1960   }
1961 }
1962 
1963 export { Page, PDFDocument };
File:
src/core/evaluator.js
1 /* Copyright 2012 Mozilla Foundation
2  *
3  * Licensed under the Apache License, Version 2.0 (the "License");
4  * you may not use this file except in compliance with the License.
5  * You may obtain a copy of the License at
6  *
7  *     http://www.apache.org/licenses/LICENSE-2.0
8  *
9  * Unless required by applicable law or agreed to in writing, software
10  * distributed under the License is distributed on an "AS IS" BASIS,
11  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
12  * See the License for the specific language governing permissions and
13  * limitations under the License.
14  */
15 
16 import {
17   AbortException,
18   assert,
19   DrawOPS,
20   FONT_IDENTITY_MATRIX,
21   FormatError,
22   info,
23   isArrayEqual,
24   normalizeUnicode,
25   OPS,
26   shadow,
27   stringToPDFString,
28   TextRenderingMode,
29   Util,
30   warn,
31 } from "../shared/util.js";
32 import { CMapFactory, IdentityCMap } from "./cmap.js";
33 import { Cmd, Dict, EOF, isName, Name, Ref, RefSet } from "./primitives.js";
34 import { compileType3Glyph, FontFlags } from "./fonts_utils.js";
35 import { ErrorFont, Font } from "./fonts.js";
36 import {
37   fetchBinaryData,
38   IDENTITY_MATRIX,
39   isNumberArray,
40   lookupMatrix,
41   lookupNormalRect,
42 } from "./core_utils.js";
43 import {
44   getEncoding,
45   MacRomanEncoding,
46   StandardEncoding,
47   SymbolSetEncoding,
48   WinAnsiEncoding,
49   ZapfDingbatsEncoding,
50 } from "./encodings.js";
51 import {
52   getFontNameToFileMap,
53   getSerifFonts,
54   getStandardFontName,
55   getStdFontMap,
56   getSymbolsFonts,
57   isKnownFontName,
58 } from "./standard_fonts.js";
59 import { getTilingPatternIR, Pattern } from "./pattern.js";
60 import { getXfaFontDict, getXfaFontName } from "./xfa_fonts.js";
61 import { IdentityToUnicodeMap, ToUnicodeMap } from "./to_unicode_map.js";
62 import { isPDFFunction, PDFFunctionFactory } from "./function.js";
63 import { Lexer, Parser } from "./parser.js";
64 import {
65   LocalColorSpaceCache,
66   LocalGStateCache,
67   LocalImageCache,
68   LocalTilingPatternCache,
69   RegionalImageCache,
70 } from "./image_utils.js";
71 import { BaseStream } from "./base_stream.js";
72 import { bidi } from "./bidi.js";
73 import { ColorSpace } from "./colorspace.js";
74 import { ColorSpaceUtils } from "./colorspace_utils.js";
75 import { getFontSubstitution } from "./font_substitutions.js";
76 import { getGlyphsUnicode } from "./glyphlist.js";
77 import { getMetrics } from "./metrics.js";
78 import { getUnicodeForGlyph } from "./unicode.js";
79 import { MurmurHash3_64 } from "../shared/murmurhash3.js";
80 import { OperatorList } from "./operator_list.js";
81 import { PDFImage } from "./image.js";
82 import { Stream } from "./stream.js";
83 
84 const DefaultPartialEvaluatorOptions = Object.freeze({
85   maxImageSize: -1,
86   disableFontFace: false,
87   ignoreErrors: false,
88   isEvalSupported: true,
89   isOffscreenCanvasSupported: false,
90   isImageDecoderSupported: false,
91   canvasMaxAreaInBytes: -1,
92   fontExtraProperties: false,
93   useSystemFonts: true,
94   useWasm: true,
95   useWorkerFetch: true,
96   cMapUrl: null,
97   iccUrl: null,
98   standardFontDataUrl: null,
99   wasmUrl: null,
100 });
101 
102 const PatternType = {
103   TILING: 1,
104   SHADING: 2,
105 };
106 
107 // Optionally avoid sending individual, or very few, text chunks to reduce
108 // `postMessage` overhead with ReadableStream (see issue 13962).
109 //
110 // PLEASE NOTE: This value should *not* be too large (it's used as a lower limit
111 // in `enqueueChunk`), since that would cause streaming of textContent to become
112 // essentially useless in practice by sending all (or most) chunks at once.
113 // Also, a too large value would (indirectly) affect the main-thread `textLayer`
114 // building negatively by forcing all textContent to be handled at once, which
115 // could easily end up hurting *overall* performance (e.g. rendering as well).
116 const TEXT_CHUNK_BATCH_SIZE = 10;
117 
118 const deferred = Promise.resolve();
119 
120 // Convert PDF blend mode names to HTML5 blend mode names.
121 function normalizeBlendMode(value, parsingArray = false) {
122   if (Array.isArray(value)) {
123     // Use the first *supported* BM value in the Array (fixes issue11279.pdf).
124     for (const val of value) {
125       const maybeBM = normalizeBlendMode(val, /* parsingArray = */ true);
126       if (maybeBM) {
127         return maybeBM;
128       }
129     }
130     warn(`Unsupported blend mode Array: ${value}`);
131     return "source-over";
132   }
133 
134   if (!(value instanceof Name)) {
135     if (parsingArray) {
136       return null;
137     }
138     return "source-over";
139   }
140   switch (value.name) {
141     case "Normal":
142     case "Compatible":
143       return "source-over";
144     case "Multiply":
145       return "multiply";
146     case "Screen":
147       return "screen";
148     case "Overlay":
149       return "overlay";
150     case "Darken":
151       return "darken";
152     case "Lighten":
153       return "lighten";
154     case "ColorDodge":
155       return "color-dodge";
156     case "ColorBurn":
157       return "color-burn";
158     case "HardLight":
159       return "hard-light";
160     case "SoftLight":
161       return "soft-light";
162     case "Difference":
163       return "difference";
164     case "Exclusion":
165       return "exclusion";
166     case "Hue":
167       return "hue";
168     case "Saturation":
169       return "saturation";
170     case "Color":
171       return "color";
172     case "Luminosity":
173       return "luminosity";
174   }
175   if (parsingArray) {
176     return null;
177   }
178   warn(`Unsupported blend mode: ${value.name}`);
179   return "source-over";
180 }
181 
182 function addCachedImageOps(
183   opList,
184   { objId, fn, args, optionalContent, hasMask }
185 ) {
186   if (objId) {
187     opList.addDependency(objId);
188   }
189   opList.addImageOps(fn, args, optionalContent, hasMask);
190 
191   if (fn === OPS.paintImageMaskXObject && args[0]?.count > 0) {
192     args[0].count++;
193   }
194 }
195 
196 // Trying to minimize Date.now() usage and check every 100 time.
197 class TimeSlotManager {
198   static TIME_SLOT_DURATION_MS = 20;
199 
200   static CHECK_TIME_EVERY = 100;
201 
202   constructor() {
203     this.reset();
204   }
205 
206   check() {
207     if (++this.checked < TimeSlotManager.CHECK_TIME_EVERY) {
208       return false;
209     }
210     this.checked = 0;
211     return this.endTime <= Date.now();
212   }
213 
214   reset() {
215     this.endTime = Date.now() + TimeSlotManager.TIME_SLOT_DURATION_MS;
216     this.checked = 0;
217   }
218 }
219 
220 class PartialEvaluator {
221   constructor({
222     xref,
223     handler,
224     pageIndex,
225     idFactory,
226     fontCache,
227     builtInCMapCache,
228     standardFontDataCache,
229     globalColorSpaceCache,
230     globalImageCache,
231     systemFontCache,
232     options = null,
233   }) {
234     this.xref = xref;
235     this.handler = handler;
236     this.pageIndex = pageIndex;
237     this.idFactory = idFactory;
238     this.fontCache = fontCache;
239     this.builtInCMapCache = builtInCMapCache;
240     this.standardFontDataCache = standardFontDataCache;
241     this.globalColorSpaceCache = globalColorSpaceCache;
242     this.globalImageCache = globalImageCache;
243     this.systemFontCache = systemFontCache;
244     this.options = options || DefaultPartialEvaluatorOptions;
245     this.type3FontRefs = null;
246 
247     this._regionalImageCache = new RegionalImageCache();
248     this._fetchBuiltInCMapBound = this.fetchBuiltInCMap.bind(this);
249   }
250 
251   /**
252    * Since Functions are only cached (locally) by reference, we can share one
253    * `PDFFunctionFactory` instance within this `PartialEvaluator` instance.
254    */
255   get _pdfFunctionFactory() {
256     const pdfFunctionFactory = new PDFFunctionFactory({
257       xref: this.xref,
258       isEvalSupported: this.options.isEvalSupported,
259     });
260     return shadow(this, "_pdfFunctionFactory", pdfFunctionFactory);
261   }
262 
263   get parsingType3Font() {
264     return !!this.type3FontRefs;
265   }
266 
267   clone(newOptions = null) {
268     const newEvaluator = Object.create(this);
269     newEvaluator.options = Object.assign(
270       Object.create(null),
271       this.options,
272       newOptions
273     );
274     return newEvaluator;
275   }
276 
277   hasBlendModes(resources, nonBlendModesSet) {
278     if (!(resources instanceof Dict)) {
279       return false;
280     }
281     if (resources.objId && nonBlendModesSet.has(resources.objId)) {
282       return false;
283     }
284 
285     const processed = new RefSet(nonBlendModesSet);
286     if (resources.objId) {
287       processed.put(resources.objId);
288     }
289 
290     const nodes = [resources],
291       xref = this.xref;
292     while (nodes.length) {
293       const node = nodes.shift();
294       // First check the current resources for blend modes.
295       const graphicStates = node.get("ExtGState");
296       if (graphicStates instanceof Dict) {
297         for (let graphicState of graphicStates.getRawValues()) {
298           if (graphicState instanceof Ref) {
299             if (processed.has(graphicState)) {
300               continue; // The ExtGState has already been processed.
301             }
302             try {
303               graphicState = xref.fetch(graphicState);
304             } catch (ex) {
305               // Avoid parsing a corrupt ExtGState more than once.
306               processed.put(graphicState);
307 
308               info(`hasBlendModes - ignoring ExtGState: "${ex}".`);
309               continue;
310             }
311           }
312           if (!(graphicState instanceof Dict)) {
313             continue;
314           }
315           if (graphicState.objId) {
316             processed.put(graphicState.objId);
317           }
318 
319           const bm = graphicState.get("BM");
320           if (bm instanceof Name) {
321             if (bm.name !== "Normal") {
322               return true;
323             }
324             continue;
325           }
326           if (bm !== undefined && Array.isArray(bm)) {
327             for (const element of bm) {
328               if (element instanceof Name && element.name !== "Normal") {
329                 return true;
330               }
331             }
332           }
333         }
334       }
335       // Descend into the XObjects to look for more resources and blend modes.
336       const xObjects = node.get("XObject");
337       if (!(xObjects instanceof Dict)) {
338         continue;
339       }
340       for (let xObject of xObjects.getRawValues()) {
341         if (xObject instanceof Ref) {
342           if (processed.has(xObject)) {
343             // The XObject has already been processed, and by avoiding a
344             // redundant `xref.fetch` we can *significantly* reduce the load
345             // time for badly generated PDF files (fixes issue6961.pdf).
346             continue;
347           }
348           try {
349             xObject = xref.fetch(xObject);
350           } catch (ex) {
351             // Avoid parsing a corrupt XObject more than once.
352             processed.put(xObject);
353 
354             info(`hasBlendModes - ignoring XObject: "${ex}".`);
355             continue;
356           }
357         }
358         if (!(xObject instanceof BaseStream)) {
359           continue;
360         }
361         if (xObject.dict.objId) {
362           processed.put(xObject.dict.objId);
363         }
364         const xResources = xObject.dict.get("Resources");
365         if (!(xResources instanceof Dict)) {
366           continue;
367         }
368         // Checking objId to detect an infinite loop.
369         if (xResources.objId && processed.has(xResources.objId)) {
370           continue;
371         }
372 
373         nodes.push(xResources);
374         if (xResources.objId) {
375           processed.put(xResources.objId);
376         }
377       }
378     }
379 
380     // When no blend modes exist, there's no need re-fetch/re-parse any of the
381     // processed `Ref`s again for subsequent pages. This helps reduce redundant
382     // `XRef.fetch` calls for some documents (e.g. issue6961.pdf).
383     for (const ref of processed) {
384       nonBlendModesSet.put(ref);
385     }
386     return false;
387   }
388 
389   async fetchBuiltInCMap(name) {
390     const cachedData = this.builtInCMapCache.get(name);
391     if (cachedData) {
392       return cachedData;
393     }
394     let data;
395 
396     if (this.options.useWorkerFetch) {
397       // Only compressed CMaps are (currently) supported here.
398       data = {
399         cMapData: await fetchBinaryData(`${this.options.cMapUrl}${name}.bcmap`),
400         isCompressed: true,
401       };
402     } else {
403       // Get the data on the main-thread instead.
404       data = await this.handler.sendWithPromise("FetchBinaryData", {
405         type: "cMapReaderFactory",
406         name,
407       });
408     }
409     // Cache the CMap data, to avoid fetching it repeatedly.
410     this.builtInCMapCache.set(name, data);
411 
412     return data;
413   }
414 
415   async fetchStandardFontData(name) {
416     const cachedData = this.standardFontDataCache.get(name);
417     if (cachedData) {
418       return new Stream(cachedData);
419     }
420 
421     // The symbol fonts are not consistent across platforms, always load the
422     // standard font data for them.
423     if (
424       this.options.useSystemFonts &&
425       name !== "Symbol" &&
426       name !== "ZapfDingbats"
427     ) {
428       return null;
429     }
430 
431     const standardFontNameToFileName = getFontNameToFileMap(),
432       filename = standardFontNameToFileName[name];
433     let data;
434 
435     try {
436       if (this.options.useWorkerFetch) {
437         data = await fetchBinaryData(
438           `${this.options.standardFontDataUrl}${filename}`
439         );
440       } else {
441         // Get the data on the main-thread instead.
442         data = await this.handler.sendWithPromise("FetchBinaryData", {
443           type: "standardFontDataFactory",
444           filename,
445         });
446       }
447     } catch (ex) {
448       warn(ex);
449       return null;
450     }
451     // Cache the "raw" standard font data, to avoid fetching it repeatedly
452     // (see e.g. issue 11399).
453     this.standardFontDataCache.set(name, data);
454 
455     return new Stream(data);
456   }
457 
458   async buildFormXObject(
459     resources,
460     xobj,
461     smask,
462     operatorList,
463     task,
464     initialState,
465     localColorSpaceCache
466   ) {
467     const dict = xobj.dict;
468     const matrix = lookupMatrix(dict.getArray("Matrix"), null);
469     const bbox = lookupNormalRect(dict.getArray("BBox"), null);
470 
471     let optionalContent, groupOptions;
472     if (dict.has("OC")) {
473       optionalContent = await this.parseMarkedContentProps(
474         dict.get("OC"),
475         resources
476       );
477     }
478     if (optionalContent !== undefined) {
479       operatorList.addOp(OPS.beginMarkedContentProps, ["OC", optionalContent]);
480     }
481     const group = dict.get("Group");
482     if (group) {
483       groupOptions = {
484         matrix,
485         bbox,
486         smask,
487         isolated: false,
488         knockout: false,
489       };
490 
491       const groupSubtype = group.get("S");
492       let colorSpace = null;
493       if (isName(groupSubtype, "Transparency")) {
494         groupOptions.isolated = group.get("I") || false;
495         groupOptions.knockout = group.get("K") || false;
496         if (group.has("CS")) {
497           const cs = this._getColorSpace(
498             group.getRaw("CS"),
499             resources,
500             localColorSpaceCache
501           );
502           colorSpace =
503             cs instanceof ColorSpace ? cs : await this._handleColorSpace(cs);
504         }
505       }
506 
507       if (smask?.backdrop) {
508         colorSpace ||= ColorSpaceUtils.rgb;
509         smask.backdrop = colorSpace.getRgb(smask.backdrop, 0);
510       }
511 
512       operatorList.addOp(OPS.beginGroup, [groupOptions]);
513     }
514 
515     // If it's a group, a new canvas will be created that is the size of the
516     // bounding box and translated to the correct position so we don't need to
517     // apply the bounding box to it.
518     const f32matrix = matrix && new Float32Array(matrix);
519     const f32bbox = (!group && bbox && new Float32Array(bbox)) || null;
520     const args = [f32matrix, f32bbox];
521     operatorList.addOp(OPS.paintFormXObjectBegin, args);
522 
523     await this.getOperatorList({
524       stream: xobj,
525       task,
526       resources: dict.get("Resources") || resources,
527       operatorList,
528       initialState,
529     });
530     operatorList.addOp(OPS.paintFormXObjectEnd, []);
531 
532     if (group) {
533       operatorList.addOp(OPS.endGroup, [groupOptions]);
534     }
535 
536     if (optionalContent !== undefined) {
537       operatorList.addOp(OPS.endMarkedContent, []);
538     }
539   }
540 
541   _sendImgData(objId, imgData, cacheGlobally = false) {
542     if (
543       (typeof PDFJSDev === "undefined" || PDFJSDev.test("TESTING")) &&
544       imgData
545     ) {
546       assert(Number.isInteger(imgData.dataLen), "Expected dataLen to be set.");
547     }
548     const transfers = imgData ? [imgData.bitmap || imgData.data.buffer] : null;
549 
550     if (this.parsingType3Font || cacheGlobally) {
551       return this.handler.send(
552         "commonobj",
553         [objId, "Image", imgData],
554         transfers
555       );
556     }
557     return this.handler.send(
558       "obj",
559       [objId, this.pageIndex, "Image", imgData],
560       transfers
561     );
562   }
563 
564   async buildPaintImageXObject({
565     resources,
566     image,
567     isInline = false,
568     operatorList,
569     cacheKey,
570     localImageCache,
571     localColorSpaceCache,
572   }) {
573     const { maxImageSize, ignoreErrors, isOffscreenCanvasSupported } =
574       this.options;
575 
576     const { dict } = image;
577     const imageRef = dict.objId;
578     const w = dict.get("W", "Width");
579     const h = dict.get("H", "Height");
580 
581     if (!(w && typeof w === "number") || !(h && typeof h === "number")) {
582       warn("Image dimensions are missing, or not numbers.");
583       return;
584     }
585     if (maxImageSize !== -1 && w * h > maxImageSize) {
586       const msg = "Image exceeded maximum allowed size and was removed.";
587 
588       if (!ignoreErrors) {
589         throw new Error(msg);
590       }
591       warn(msg);
592       return;
593     }
594 
595     let optionalContent;
596     if (dict.has("OC")) {
597       optionalContent = await this.parseMarkedContentProps(
598         dict.get("OC"),
599         resources
600       );
601     }
602 
603     const imageMask = dict.get("IM", "ImageMask") || false;
604     let imgData, fn, args;
605     if (imageMask) {
606       // This depends on a tmpCanvas being filled with the
607       // current fillStyle, such that processing the pixel
608       // data can't be done here. Instead of creating a
609       // complete PDFImage, only read the information needed
610       // for later.
611       imgData = await PDFImage.createMask({
612         image,
613         isOffscreenCanvasSupported:
614           isOffscreenCanvasSupported && !this.parsingType3Font,
615       });
616 
617       if (imgData.isSingleOpaquePixel) {
618         // Handles special case of mainly LaTeX documents which use image
619         // masks to draw lines with the current fill style.
620         fn = OPS.paintSolidColorImageMask;
621         args = [];
622         operatorList.addImageOps(fn, args, optionalContent);
623 
624         if (cacheKey) {
625           const cacheData = { fn, args, optionalContent };
626           localImageCache.set(cacheKey, imageRef, cacheData);
627 
628           if (imageRef) {
629             this._regionalImageCache.set(
630               /* name = */ null,
631               imageRef,
632               cacheData
633             );
634           }
635         }
636         return;
637       }
638 
639       if (this.parsingType3Font) {
640         // NOTE: Compared to other image resources we don't bother caching
641         // Type3-glyph image masks, since we've not come across any cases
642         // where that actually helps.
643         // In Type3-glyphs image masks are "always" inline resources,
644         // they're usually fairly small and aren't being re-used either.
645         if (typeof PDFJSDev === "undefined" || PDFJSDev.test("TESTING")) {
646           assert(
647             imgData.data instanceof Uint8Array,
648             "Type3 glyph image mask must be a TypedArray."
649           );
650         }
651         args = compileType3Glyph(imgData);
652 
653         if (args) {
654           operatorList.addImageOps(OPS.constructPath, args, optionalContent);
655           return;
656         }
657         warn("Cannot compile Type3 glyph.");
658 
659         // If compilation failed, or was disabled, fallback to using an inline
660         // image mask; this case should be extremely rare.
661         operatorList.addImageOps(
662           OPS.paintImageMaskXObject,
663           [imgData],
664           optionalContent
665         );
666         return;
667       }
668 
669       const objId = `mask_${this.idFactory.createObjId()}`;
670       operatorList.addDependency(objId);
671 
672       imgData.dataLen = imgData.bitmap
673         ? imgData.width * imgData.height * 4
674         : imgData.data.length;
675       this._sendImgData(objId, imgData);
676 
677       fn = OPS.paintImageMaskXObject;
678       args = [
679         {
680           data: objId,
681           width: imgData.width,
682           height: imgData.height,
683           interpolate: imgData.interpolate,
684           count: 1,
685         },
686       ];
687       operatorList.addImageOps(fn, args, optionalContent);
688 
689       if (cacheKey) {
690         const cacheData = { objId, fn, args, optionalContent };
691         localImageCache.set(cacheKey, imageRef, cacheData);
692 
693         if (imageRef) {
694           this._regionalImageCache.set(/* name = */ null, imageRef, cacheData);
695         }
696       }
697       return;
698     }
699 
700     const SMALL_IMAGE_DIMENSIONS = 200;
701     const hasMask = dict.has("SMask") || dict.has("Mask");
702     // Inlining small images into the queue as RGB data
703     if (isInline && w + h < SMALL_IMAGE_DIMENSIONS && !hasMask) {
704       try {
705         const imageObj = new PDFImage({
706           xref: this.xref,
707           res: resources,
708           image,
709           isInline,
710           pdfFunctionFactory: this._pdfFunctionFactory,
711           globalColorSpaceCache: this.globalColorSpaceCache,
712           localColorSpaceCache,
713         });
714         // We force the use of RGBA_32BPP images here, because we can't handle
715         // any other kind.
716         imgData = await imageObj.createImageData(
717           /* forceRGBA = */ true,
718           /* isOffscreenCanvasSupported = */ false
719         );
720         operatorList.addImageOps(
721           OPS.paintInlineImageXObject,
722           [imgData],
723           optionalContent
724         );
725       } catch (reason) {
726         const msg = `Unable to decode inline image: "${reason}".`;
727 
728         if (!ignoreErrors) {
729           throw new Error(msg);
730         }
731         warn(msg);
732       }
733       return;
734     }
735 
736     // If there is no imageMask, create the PDFImage and a lot
737     // of image processing can be done here.
738     let objId = `img_${this.idFactory.createObjId()}`,
739       cacheGlobally = false,
740       globalCacheData = null;
741 
742     if (this.parsingType3Font) {
743       objId = `${this.idFactory.getDocId()}_type3_${objId}`;
744     } else if (cacheKey && imageRef) {
745       cacheGlobally = this.globalImageCache.shouldCache(
746         imageRef,
747         this.pageIndex
748       );
749 
750       if (cacheGlobally) {
751         assert(!isInline, "Cannot cache an inline image globally.");
752 
753         objId = `${this.idFactory.getDocId()}_${objId}`;
754       }
755     }
756 
757     // Ensure that the dependency is added before the image is decoded.
758     operatorList.addDependency(objId);
759 
760     fn = OPS.paintImageXObject;
761     args = [objId, w, h];
762     operatorList.addImageOps(fn, args, optionalContent, hasMask);
763 
764     if (cacheGlobally) {
765       globalCacheData = {
766         objId,
767         fn,
768         args,
769         optionalContent,
770         hasMask,
771         byteSize: 0, // Temporary entry, to avoid `setData` returning early.
772       };
773 
774       if (this.globalImageCache.hasDecodeFailed(imageRef)) {
775         this.globalImageCache.setData(imageRef, globalCacheData);
776 
777         this._sendImgData(objId, /* imgData = */ null, cacheGlobally);
778         return;
779       }
780 
781       // For large (at least 500x500) or more complex images that we'll cache
782       // globally, check if the image is still cached locally on the main-thread
783       // to avoid having to re-parse the image (since that can be slow).
784       if (w * h > 250000 || hasMask) {
785         const localLength = await this.handler.sendWithPromise("commonobj", [
786           objId,
787           "CopyLocalImage",
788           { imageRef },
789         ]);
790 
791         if (localLength) {
792           this.globalImageCache.setData(imageRef, globalCacheData);
793           this.globalImageCache.addByteSize(imageRef, localLength);
794           return;
795         }
796       }
797     }
798 
799     PDFImage.buildImage({
800       xref: this.xref,
801       res: resources,
802       image,
803       isInline,
804       pdfFunctionFactory: this._pdfFunctionFactory,
805       globalColorSpaceCache: this.globalColorSpaceCache,
806       localColorSpaceCache,
807     })
808       .then(async imageObj => {
809         imgData = await imageObj.createImageData(
810           /* forceRGBA = */ false,
811           isOffscreenCanvasSupported
812         );
813         imgData.dataLen = imgData.bitmap
814           ? imgData.width * imgData.height * 4
815           : imgData.data.length;
816         imgData.ref = imageRef;
817 
818         if (cacheGlobally) {
819           this.globalImageCache.addByteSize(imageRef, imgData.dataLen);
820         }
821         return this._sendImgData(objId, imgData, cacheGlobally);
822       })
823       .catch(reason => {
824         warn(`Unable to decode image "${objId}": "${reason}".`);
825 
826         if (imageRef) {
827           this.globalImageCache.addDecodeFailed(imageRef);
828         }
829         return this._sendImgData(objId, /* imgData = */ null, cacheGlobally);
830       });
831 
832     if (cacheKey) {
833       const cacheData = { objId, fn, args, optionalContent, hasMask };
834       localImageCache.set(cacheKey, imageRef, cacheData);
835 
836       if (imageRef) {
837         this._regionalImageCache.set(/* name = */ null, imageRef, cacheData);
838 
839         if (cacheGlobally) {
840           assert(globalCacheData, "The global cache-data must be available.");
841           this.globalImageCache.setData(imageRef, globalCacheData);
842         }
843       }
844     }
845   }
846 
847   handleSMask(
848     smask,
849     resources,
850     operatorList,
851     task,
852     stateManager,
853     localColorSpaceCache
854   ) {
855     const smaskContent = smask.get("G");
856     const smaskOptions = {
857       subtype: smask.get("S").name,
858       backdrop: smask.get("BC"),
859     };
860 
861     // The SMask might have a alpha/luminosity value transfer function --
862     // we will build a map of integer values in range 0..255 to be fast.
863     const transferObj = smask.get("TR");
864     if (isPDFFunction(transferObj)) {
865       const transferFn = this._pdfFunctionFactory.create(transferObj);
866       const transferMap = new Uint8Array(256);
867       const tmp = new Float32Array(1);
868       for (let i = 0; i < 256; i++) {
869         tmp[0] = i / 255;
870         transferFn(tmp, 0, tmp, 0);
871         transferMap[i] = (tmp[0] * 255) | 0;
872       }
873       smaskOptions.transferMap = transferMap;
874     }
875 
876     return this.buildFormXObject(
877       resources,
878       smaskContent,
879       smaskOptions,
880       operatorList,
881       task,
882       stateManager.state.clone({ newPath: true }),
883       localColorSpaceCache
884     );
885   }
886 
887   handleTransferFunction(tr) {
888     let transferArray;
889     if (Array.isArray(tr)) {
890       transferArray = tr;
891     } else if (isPDFFunction(tr)) {
892       transferArray = [tr];
893     } else {
894       return null; // Not a valid transfer function entry.
895     }
896 
897     const transferMaps = [];
898     let numFns = 0,
899       numEffectfulFns = 0;
900     for (const entry of transferArray) {
901       const transferObj = this.xref.fetchIfRef(entry);
902       numFns++;
903 
904       if (isName(transferObj, "Identity")) {
905         transferMaps.push(null);
906         continue;
907       } else if (!isPDFFunction(transferObj)) {
908         return null; // Not a valid transfer function object.
909       }
910 
911       const transferFn = this._pdfFunctionFactory.create(transferObj);
912       const transferMap = new Uint8Array(256),
913         tmp = new Float32Array(1);
914       for (let j = 0; j < 256; j++) {
915         tmp[0] = j / 255;
916         transferFn(tmp, 0, tmp, 0);
917         transferMap[j] = (tmp[0] * 255) | 0;
918       }
919       transferMaps.push(transferMap);
920       numEffectfulFns++;
921     }
922 
923     if (!(numFns === 1 || numFns === 4)) {
924       return null; // Only 1 or 4 functions are supported, by the specification.
925     }
926     if (numEffectfulFns === 0) {
927       return null; // Only /Identity transfer functions found, which are no-ops.
928     }
929     return transferMaps;
930   }
931 
932   handleTilingType(
933     fn,
934     color,
935     resources,
936     pattern,
937     patternDict,
938     operatorList,
939     task,
940     localTilingPatternCache
941   ) {
942     // Create an IR of the pattern code.
943     const tilingOpList = new OperatorList();
944     // Merge the available resources, to prevent issues when the patternDict
945     // is missing some /Resources entries (fixes issue6541.pdf).
946     const patternResources = Dict.merge({
947       xref: this.xref,
948       dictArray: [patternDict.get("Resources"), resources],
949     });
950 
951     return this.getOperatorList({
952       stream: pattern,
953       task,
954       resources: patternResources,
955       operatorList: tilingOpList,
956     })
957       .then(function () {
958         const operatorListIR = tilingOpList.getIR();
959         const tilingPatternIR = getTilingPatternIR(
960           operatorListIR,
961           patternDict,
962           color
963         );
964         // Add the dependencies to the parent operator list so they are
965         // resolved before the sub operator list is executed synchronously.
966         operatorList.addDependencies(tilingOpList.dependencies);
967         operatorList.addOp(fn, tilingPatternIR);
968 
969         if (patternDict.objId) {
970           localTilingPatternCache.set(/* name = */ null, patternDict.objId, {
971             operatorListIR,
972             dict: patternDict,
973           });
974         }
975       })
976       .catch(reason => {
977         if (reason instanceof AbortException) {
978           return;
979         }
980         if (this.options.ignoreErrors) {
981           warn(`handleTilingType - ignoring pattern: "${reason}".`);
982           return;
983         }
984         throw reason;
985       });
986   }
987 
988   async handleSetFont(
989     resources,
990     fontArgs,
991     fontRef,
992     operatorList,
993     task,
994     state,
995     fallbackFontDict = null,
996     cssFontInfo = null
997   ) {
998     const fontName = fontArgs?.[0] instanceof Name ? fontArgs[0].name : null;
999 
1000     const translated = await this.loadFont(
1001       fontName,
1002       fontRef,
1003       resources,
1004       task,
1005       fallbackFontDict,
1006       cssFontInfo
1007     );
1008 
1009     if (translated.font.isType3Font) {
1010       // Add the dependencies to the parent operatorList so they are
1011       // resolved before Type3 operatorLists are executed synchronously.
1012       operatorList.addDependencies(translated.type3Dependencies);
1013     }
1014 
1015     state.font = translated.font;
1016     translated.send(this.handler);
1017     return translated.loadedName;
1018   }
1019 
1020   handleText(chars, state) {
1021     const font = state.font;
1022     const glyphs = font.charsToGlyphs(chars);
1023 
1024     if (font.data) {
1025       const isAddToPathSet = !!(
1026         state.textRenderingMode & TextRenderingMode.ADD_TO_PATH_FLAG
1027       );
1028       if (
1029         isAddToPathSet ||
1030         state.fillColorSpace.name === "Pattern" ||
1031         font.disableFontFace
1032       ) {
1033         PartialEvaluator.buildFontPaths(
1034           font,
1035           glyphs,
1036           this.handler,
1037           this.options
1038         );
1039       }
1040     }
1041     return glyphs;
1042   }
1043 
1044   ensureStateFont(state) {
1045     if (state.font) {
1046       return;
1047     }
1048     const reason = new FormatError(
1049       "Missing setFont (Tf) operator before text rendering operator."
1050     );
1051 
1052     if (this.options.ignoreErrors) {
1053       warn(`ensureStateFont: "${reason}".`);
1054       return;
1055     }
1056     throw reason;
1057   }
1058 
1059   async setGState({
1060     resources,
1061     gState,
1062     operatorList,
1063     cacheKey,
1064     task,
1065     stateManager,
1066     localGStateCache,
1067     localColorSpaceCache,
1068   }) {
1069     const gStateRef = gState.objId;
1070     let isSimpleGState = true;
1071     // This array holds the converted/processed state data.
1072     const gStateObj = [];
1073     let promise = Promise.resolve();
1074     for (const [key, value] of gState) {
1075       switch (key) {
1076         case "Type":
1077           break;
1078         case "LW":
1079           if (typeof value !== "number") {
1080             warn(`Invalid LW (line width): ${value}`);
1081             break;
1082           }
1083           gStateObj.push([key, Math.abs(value)]);
1084           break;
1085         case "LC":
1086         case "LJ":
1087         case "ML":
1088         case "D":
1089         case "RI":
1090         case "FL":
1091         case "CA":
1092         case "ca":
1093           gStateObj.push([key, value]);
1094           break;
1095         case "Font":
1096           isSimpleGState = false;
1097 
1098           promise = promise.then(() =>
1099             this.handleSetFont(
1100               resources,
1101               null,
1102               value[0],
1103               operatorList,
1104               task,
1105               stateManager.state
1106             ).then(function (loadedName) {
1107               operatorList.addDependency(loadedName);
1108               gStateObj.push([key, [loadedName, value[1]]]);
1109             })
1110           );
1111           break;
1112         case "BM":
1113           gStateObj.push([key, normalizeBlendMode(value)]);
1114           break;
1115         case "SMask":
1116           if (isName(value, "None")) {
1117             gStateObj.push([key, false]);
1118             break;
1119           }
1120           if (value instanceof Dict) {
1121             isSimpleGState = false;
1122 
1123             promise = promise.then(() =>
1124               this.handleSMask(
1125                 value,
1126                 resources,
1127                 operatorList,
1128                 task,
1129                 stateManager,
1130                 localColorSpaceCache
1131               )
1132             );
1133             gStateObj.push([key, true]);
1134           } else {
1135             warn("Unsupported SMask type");
1136           }
1137           break;
1138         case "TR":
1139           const transferMaps = this.handleTransferFunction(value);
1140           gStateObj.push([key, transferMaps]);
1141           break;
1142         // Only generate info log messages for the following since
1143         // they are unlikely to have a big impact on the rendering.
1144         case "OP":
1145         case "op":
1146         case "OPM":
1147         case "BG":
1148         case "BG2":
1149         case "UCR":
1150         case "UCR2":
1151         case "TR2":
1152         case "HT":
1153         case "SM":
1154         case "SA":
1155         case "AIS":
1156         case "TK":
1157           // TODO implement these operators.
1158           info("graphic state operator " + key);
1159           break;
1160         default:
1161           info("Unknown graphic state operator " + key);
1162           break;
1163       }
1164     }
1165     await promise;
1166 
1167     if (gStateObj.length > 0) {
1168       operatorList.addOp(OPS.setGState, [gStateObj]);
1169     }
1170 
1171     if (isSimpleGState) {
1172       localGStateCache.set(cacheKey, gStateRef, gStateObj);
1173     }
1174   }
1175 
1176   loadFont(
1177     fontName,
1178     font,
1179     resources,
1180     task,
1181     fallbackFontDict = null,
1182     cssFontInfo = null
1183   ) {
1184     const errorFont = async () =>
1185       new TranslatedFont({
1186         loadedName: "g_font_error",
1187         font: new ErrorFont(`Font "${fontName}" is not available.`),
1188         dict: font,
1189       });
1190 
1191     let fontRef;
1192     if (font) {
1193       // Loading by ref.
1194       if (font instanceof Ref) {
1195         fontRef = font;
1196       }
1197     } else {
1198       // Loading by name.
1199       const fontRes = resources.get("Font");
1200       if (fontRes) {
1201         fontRef = fontRes.getRaw(fontName);
1202       }
1203     }
1204     if (fontRef) {
1205       if (this.type3FontRefs?.has(fontRef)) {
1206         return errorFont();
1207       }
1208 
1209       if (this.fontCache.has(fontRef)) {
1210         return this.fontCache.get(fontRef);
1211       }
1212 
1213       try {
1214         font = this.xref.fetchIfRef(fontRef);
1215       } catch (ex) {
1216         warn(`loadFont - lookup failed: "${ex}".`);
1217       }
1218     }
1219 
1220     if (!(font instanceof Dict)) {
1221       if (!this.options.ignoreErrors && !this.parsingType3Font) {
1222         warn(`Font "${fontName}" is not available.`);
1223         return errorFont();
1224       }
1225       warn(
1226         `Font "${fontName}" is not available -- attempting to fallback to a default font.`
1227       );
1228 
1229       // Falling back to a default font to avoid completely broken rendering,
1230       // but note that there're no guarantees that things will look "correct".
1231       font = fallbackFontDict || PartialEvaluator.fallbackFontDict;
1232     }
1233 
1234     // We are holding `font.cacheKey` references only for `fontRef`s that
1235     // are not actually `Ref`s, but rather `Dict`s. See explanation below.
1236     if (font.cacheKey && this.fontCache.has(font.cacheKey)) {
1237       return this.fontCache.get(font.cacheKey);
1238     }
1239 
1240     const { promise, resolve } = Promise.withResolvers();
1241 
1242     let preEvaluatedFont;
1243     try {
1244       preEvaluatedFont = this.preEvaluateFont(font);
1245       preEvaluatedFont.cssFontInfo = cssFontInfo;
1246     } catch (reason) {
1247       warn(`loadFont - preEvaluateFont failed: "${reason}".`);
1248       return errorFont();
1249     }
1250     const { descriptor, hash } = preEvaluatedFont;
1251 
1252     const fontRefIsRef = fontRef instanceof Ref;
1253     let fontID;
1254 
1255     if (hash && descriptor instanceof Dict) {
1256       const fontAliases = (descriptor.fontAliases ||= Object.create(null));
1257 
1258       if (fontAliases[hash]) {
1259         const aliasFontRef = fontAliases[hash].aliasRef;
1260         if (fontRefIsRef && aliasFontRef && this.fontCache.has(aliasFontRef)) {
1261           this.fontCache.putAlias(fontRef, aliasFontRef);
1262           return this.fontCache.get(fontRef);
1263         }
1264       } else {
1265         fontAliases[hash] = {
1266           fontID: this.idFactory.createFontId(),
1267         };
1268       }
1269 
1270       if (fontRefIsRef) {
1271         fontAliases[hash].aliasRef = fontRef;
1272       }
1273       fontID = fontAliases[hash].fontID;
1274     } else {
1275       fontID = this.idFactory.createFontId();
1276     }
1277     assert(
1278       fontID?.startsWith("f"),
1279       'The "fontID" must be (correctly) defined.'
1280     );
1281 
1282     // Workaround for bad PDF generators that reference fonts incorrectly,
1283     // where `fontRef` is a `Dict` rather than a `Ref` (fixes bug946506.pdf).
1284     // In this case we cannot put the font into `this.fontCache` (which is
1285     // a `RefSetCache`), since it's not possible to use a `Dict` as a key.
1286     //
1287     // However, if we don't cache the font it's not possible to remove it
1288     // when `cleanup` is triggered from the API, which causes issues on
1289     // subsequent rendering operations (see issue7403.pdf) and would force us
1290     // to unnecessarily load the same fonts over and over.
1291     //
1292     // Instead, we cheat a bit by using a modified `fontID` as a key in
1293     // `this.fontCache`, to allow the font to be cached.
1294     // NOTE: This works because `RefSetCache` calls `toString()` on provided
1295     //       keys. Also, since `fontRef` is used when getting cached fonts,
1296     //       we'll not accidentally match fonts cached with the `fontID`.
1297     if (fontRefIsRef) {
1298       this.fontCache.put(fontRef, promise);
1299     } else {
1300       font.cacheKey = `cacheKey_${fontID}`;
1301       this.fontCache.put(font.cacheKey, promise);
1302     }
1303 
1304     // Keep track of each font we translated so the caller can
1305     // load them asynchronously before calling display on a page.
1306     font.loadedName = `${this.idFactory.getDocId()}_${fontID}`;
1307 
1308     this.translateFont(preEvaluatedFont)
1309       .then(async translatedFont => {
1310         const translated = new TranslatedFont({
1311           loadedName: font.loadedName,
1312           font: translatedFont,
1313           dict: font,
1314         });
1315 
1316         if (translatedFont.isType3Font) {
1317           try {
1318             await translated.loadType3Data(this, resources, task);
1319           } catch (reason) {
1320             throw new Error(`Type3 font load error: ${reason}`);
1321           }
1322         }
1323         resolve(translated);
1324       })
1325       .catch(reason => {
1326         // TODO reject?
1327         warn(`loadFont - translateFont failed: "${reason}".`);
1328 
1329         resolve(
1330           new TranslatedFont({
1331             loadedName: font.loadedName,
1332             font: new ErrorFont(reason?.message),
1333             dict: font,
1334           })
1335         );
1336       });
1337     return promise;
1338   }
1339 
1340   buildPath(fn, args, state) {
1341     const { pathMinMax: minMax, pathBuffer } = state;
1342     switch (fn | 0) {
1343       case OPS.rectangle: {
1344         const x = (state.currentPointX = args[0]);
1345         const y = (state.currentPointY = args[1]);
1346         const width = args[2];
1347         const height = args[3];
1348         const xw = x + width;
1349         const yh = y + height;
1350         if (width === 0 || height === 0) {
1351           pathBuffer.push(
1352             DrawOPS.moveTo,
1353             x,
1354             y,
1355             DrawOPS.lineTo,
1356             xw,
1357             yh,
1358             DrawOPS.closePath
1359           );
1360         } else {
1361           pathBuffer.push(
1362             DrawOPS.moveTo,
1363             x,
1364             y,
1365             DrawOPS.lineTo,
1366             xw,
1367             y,
1368             DrawOPS.lineTo,
1369             xw,
1370             yh,
1371             DrawOPS.lineTo,
1372             x,
1373             yh,
1374             DrawOPS.closePath
1375           );
1376         }
1377         Util.rectBoundingBox(x, y, xw, yh, minMax);
1378         break;
1379       }
1380       case OPS.moveTo: {
1381         const x = (state.currentPointX = args[0]);
1382         const y = (state.currentPointY = args[1]);
1383         pathBuffer.push(DrawOPS.moveTo, x, y);
1384         Util.pointBoundingBox(x, y, minMax);
1385         break;
1386       }
1387       case OPS.lineTo: {
1388         const x = (state.currentPointX = args[0]);
1389         const y = (state.currentPointY = args[1]);
1390         pathBuffer.push(DrawOPS.lineTo, x, y);
1391         Util.pointBoundingBox(x, y, minMax);
1392         break;
1393       }
1394       case OPS.curveTo: {
1395         const startX = state.currentPointX;
1396         const startY = state.currentPointY;
1397         const [x1, y1, x2, y2, x, y] = args;
1398         state.currentPointX = x;
1399         state.currentPointY = y;
1400         pathBuffer.push(DrawOPS.curveTo, x1, y1, x2, y2, x, y);
1401         Util.bezierBoundingBox(startX, startY, x1, y1, x2, y2, x, y, minMax);
1402         break;
1403       }
1404       case OPS.curveTo2: {
1405         const startX = state.currentPointX;
1406         const startY = state.currentPointY;
1407         const [x1, y1, x, y] = args;
1408         state.currentPointX = x;
1409         state.currentPointY = y;
1410         pathBuffer.push(DrawOPS.curveTo, startX, startY, x1, y1, x, y);
1411         Util.bezierBoundingBox(
1412           startX,
1413           startY,
1414           startX,
1415           startY,
1416           x1,
1417           y1,
1418           x,
1419           y,
1420           minMax
1421         );
1422         break;
1423       }
1424       case OPS.curveTo3: {
1425         const startX = state.currentPointX;
1426         const startY = state.currentPointY;
1427         const [x1, y1, x, y] = args;
1428         state.currentPointX = x;
1429         state.currentPointY = y;
1430         pathBuffer.push(DrawOPS.curveTo, x1, y1, x, y, x, y);
1431         Util.bezierBoundingBox(startX, startY, x1, y1, x, y, x, y, minMax);
1432         break;
1433       }
1434       case OPS.closePath:
1435         pathBuffer.push(DrawOPS.closePath);
1436         break;
1437     }
1438   }
1439 
1440   _getColorSpace(cs, resources, localColorSpaceCache) {
1441     return ColorSpaceUtils.parse({
1442       cs,
1443       xref: this.xref,
1444       resources,
1445       pdfFunctionFactory: this._pdfFunctionFactory,
1446       globalColorSpaceCache: this.globalColorSpaceCache,
1447       localColorSpaceCache,
1448       asyncIfNotCached: true,
1449     });
1450   }
1451 
1452   async _handleColorSpace(csPromise) {
1453     try {
1454       return await csPromise;
1455     } catch (ex) {
1456       if (ex instanceof AbortException) {
1457         return null;
1458       }
1459       if (this.options.ignoreErrors) {
1460         warn(`_handleColorSpace - ignoring ColorSpace: "${ex}".`);
1461         return null;
1462       }
1463       throw ex;
1464     }
1465   }
1466 
1467   parseShading({
1468     shading,
1469     resources,
1470     localColorSpaceCache,
1471     localShadingPatternCache,
1472   }) {
1473     // Shadings and patterns may be referenced by the same name but the resource
1474     // dictionary could be different so we can't use the name for the cache key.
1475     let id = localShadingPatternCache.get(shading);
1476     if (id) {
1477       return id;
1478     }
1479     let patternIR;
1480 
1481     try {
1482       const shadingFill = Pattern.parseShading(
1483         shading,
1484         this.xref,
1485         resources,
1486         this._pdfFunctionFactory,
1487         this.globalColorSpaceCache,
1488         localColorSpaceCache
1489       );
1490       patternIR = shadingFill.getIR();
1491     } catch (reason) {
1492       if (reason instanceof AbortException) {
1493         return null;
1494       }
1495       if (this.options.ignoreErrors) {
1496         warn(`parseShading - ignoring shading: "${reason}".`);
1497 
1498         localShadingPatternCache.set(shading, null);
1499         return null;
1500       }
1501       throw reason;
1502     }
1503 
1504     id = `pattern_${this.idFactory.createObjId()}`;
1505     if (this.parsingType3Font) {
1506       id = `${this.idFactory.getDocId()}_type3_${id}`;
1507     }
1508     localShadingPatternCache.set(shading, id);
1509 
1510     if (this.parsingType3Font) {
1511       this.handler.send("commonobj", [id, "Pattern", patternIR]);
1512     } else {
1513       this.handler.send("obj", [id, this.pageIndex, "Pattern", patternIR]);
1514     }
1515     return id;
1516   }
1517 
1518   handleColorN(
1519     operatorList,
1520     fn,
1521     args,
1522     cs,
1523     patterns,
1524     resources,
1525     task,
1526     localColorSpaceCache,
1527     localTilingPatternCache,
1528     localShadingPatternCache
1529   ) {
1530     // compile tiling patterns
1531     const patternName = args.pop();
1532     // SCN/scn applies patterns along with normal colors
1533     if (patternName instanceof Name) {
1534       const rawPattern = patterns.getRaw(patternName.name);
1535 
1536       const localTilingPattern =
1537         rawPattern instanceof Ref &&
1538         localTilingPatternCache.getByRef(rawPattern);
1539       if (localTilingPattern) {
1540         try {
1541           const color = cs.base ? cs.base.getRgb(args, 0) : null;
1542           const tilingPatternIR = getTilingPatternIR(
1543             localTilingPattern.operatorListIR,
1544             localTilingPattern.dict,
1545             color
1546           );
1547           operatorList.addOp(fn, tilingPatternIR);
1548           return undefined;
1549         } catch {
1550           // Handle any errors during normal TilingPattern parsing.
1551         }
1552       }
1553 
1554       const pattern = this.xref.fetchIfRef(rawPattern);
1555       if (pattern) {
1556         const dict = pattern instanceof BaseStream ? pattern.dict : pattern;
1557         const typeNum = dict.get("PatternType");
1558 
1559         if (typeNum === PatternType.TILING) {
1560           const color = cs.base ? cs.base.getRgb(args, 0) : null;
1561           return this.handleTilingType(
1562             fn,
1563             color,
1564             resources,
1565             pattern,
1566             dict,
1567             operatorList,
1568             task,
1569             localTilingPatternCache
1570           );
1571         } else if (typeNum === PatternType.SHADING) {
1572           const shading = dict.get("Shading");
1573           const objId = this.parseShading({
1574             shading,
1575             resources,
1576             localColorSpaceCache,
1577             localShadingPatternCache,
1578           });
1579           if (objId) {
1580             const matrix = lookupMatrix(dict.getArray("Matrix"), null);
1581             operatorList.addOp(fn, ["Shading", objId, matrix]);
1582           }
1583           return undefined;
1584         }
1585         throw new FormatError(`Unknown PatternType: ${typeNum}`);
1586       }
1587     }
1588     throw new FormatError(`Unknown PatternName: ${patternName}`);
1589   }
1590 
1591   _parseVisibilityExpression(array, nestingCounter, currentResult) {
1592     const MAX_NESTING = 10;
1593     if (++nestingCounter > MAX_NESTING) {
1594       warn("Visibility expression is too deeply nested");
1595       return;
1596     }
1597     const length = array.length;
1598     const operator = this.xref.fetchIfRef(array[0]);
1599     if (length < 2 || !(operator instanceof Name)) {
1600       warn("Invalid visibility expression");
1601       return;
1602     }
1603     switch (operator.name) {
1604       case "And":
1605       case "Or":
1606       case "Not":
1607         currentResult.push(operator.name);
1608         break;
1609       default:
1610         warn(`Invalid operator ${operator.name} in visibility expression`);
1611         return;
1612     }
1613     for (let i = 1; i < length; i++) {
1614       const raw = array[i];
1615       const object = this.xref.fetchIfRef(raw);
1616       if (Array.isArray(object)) {
1617         const nestedResult = [];
1618         currentResult.push(nestedResult);
1619         // Recursively parse a subarray.
1620         this._parseVisibilityExpression(object, nestingCounter, nestedResult);
1621       } else if (raw instanceof Ref) {
1622         // Reference to an OCG dictionary.
1623         currentResult.push(raw.toString());
1624       }
1625     }
1626   }
1627 
1628   async parseMarkedContentProps(contentProperties, resources) {
1629     let optionalContent;
1630     if (contentProperties instanceof Name) {
1631       const properties = resources.get("Properties");
1632       optionalContent = properties.get(contentProperties.name);
1633     } else if (contentProperties instanceof Dict) {
1634       optionalContent = contentProperties;
1635     } else {
1636       throw new FormatError("Optional content properties malformed.");
1637     }
1638 
1639     const optionalContentType = optionalContent.get("Type")?.name;
1640     if (optionalContentType === "OCG") {
1641       return {
1642         type: optionalContentType,
1643         id: optionalContent.objId,
1644       };
1645     } else if (optionalContentType === "OCMD") {
1646       const expression = optionalContent.get("VE");
1647       if (Array.isArray(expression)) {
1648         const result = [];
1649         this._parseVisibilityExpression(expression, 0, result);
1650         if (result.length > 0) {
1651           return {
1652             type: "OCMD",
1653             expression: result,
1654           };
1655         }
1656       }
1657 
1658       const optionalContentGroups = optionalContent.get("OCGs");
1659       if (
1660         Array.isArray(optionalContentGroups) ||
1661         optionalContentGroups instanceof Dict
1662       ) {
1663         const groupIds = [];
1664         if (Array.isArray(optionalContentGroups)) {
1665           for (const ocg of optionalContentGroups) {
1666             groupIds.push(ocg.toString());
1667           }
1668         } else {
1669           // Dictionary, just use the obj id.
1670           groupIds.push(optionalContentGroups.objId);
1671         }
1672 
1673         return {
1674           type: optionalContentType,
1675           ids: groupIds,
1676           policy:
1677             optionalContent.get("P") instanceof Name
1678               ? optionalContent.get("P").name
1679               : null,
1680           expression: null,
1681         };
1682       } else if (optionalContentGroups instanceof Ref) {
1683         return {
1684           type: optionalContentType,
1685           id: optionalContentGroups.toString(),
1686         };
1687       }
1688     }
1689     return null;
1690   }
1691 
1692   getOperatorList({
1693     stream,
1694     task,
1695     resources,
1696     operatorList,
1697     initialState = null,
1698     fallbackFontDict = null,
1699   }) {
1700     // Ensure that `resources`/`initialState` is correctly initialized,
1701     // even if the provided parameter is e.g. `null`.
1702     resources ||= Dict.empty;
1703     initialState ||= new EvalState();
1704 
1705     if (!operatorList) {
1706       throw new Error('getOperatorList: missing "operatorList" parameter');
1707     }
1708 
1709     const self = this;
1710     const xref = this.xref;
1711     const localImageCache = new LocalImageCache();
1712     const localColorSpaceCache = new LocalColorSpaceCache();
1713     const localGStateCache = new LocalGStateCache();
1714     const localTilingPatternCache = new LocalTilingPatternCache();
1715     const localShadingPatternCache = new Map();
1716 
1717     const xobjs = resources.get("XObject") || Dict.empty;
1718     const patterns = resources.get("Pattern") || Dict.empty;
1719     const stateManager = new StateManager(initialState);
1720     const preprocessor = new EvaluatorPreprocessor(stream, xref, stateManager);
1721     const timeSlotManager = new TimeSlotManager();
1722 
1723     function closePendingRestoreOPS(argument) {
1724       for (let i = 0, ii = preprocessor.savedStatesDepth; i < ii; i++) {
1725         operatorList.addOp(OPS.restore, []);
1726       }
1727     }
1728 
1729     return new Promise(function promiseBody(resolve, reject) {
1730       const next = function (promise) {
1731         Promise.all([promise, operatorList.ready]).then(function () {
1732           try {
1733             promiseBody(resolve, reject);
1734           } catch (ex) {
1735             reject(ex);
1736           }
1737         }, reject);
1738       };
1739       task.ensureNotTerminated();
1740       timeSlotManager.reset();
1741 
1742       const operation = {};
1743       let stop, i, ii, cs, name, isValidName;
1744       while (!(stop = timeSlotManager.check())) {
1745         // The arguments parsed by read() are used beyond this loop, so we
1746         // cannot reuse the same array on each iteration. Therefore we pass
1747         // in |null| as the initial value (see the comment on
1748         // EvaluatorPreprocessor_read() for why).
1749         operation.args = null;
1750         if (!preprocessor.read(operation)) {
1751           break;
1752         }
1753         let args = operation.args;
1754         let fn = operation.fn;
1755 
1756         switch (fn | 0) {
1757           case OPS.paintXObject:
1758             // eagerly compile XForm objects
1759             isValidName = args[0] instanceof Name;
1760             name = args[0].name;
1761 
1762             if (isValidName) {
1763               const localImage = localImageCache.getByName(name);
1764               if (localImage) {
1765                 addCachedImageOps(operatorList, localImage);
1766                 args = null;
1767                 continue;
1768               }
1769             }
1770 
1771             next(
1772               new Promise(function (resolveXObject, rejectXObject) {
1773                 if (!isValidName) {
1774                   throw new FormatError("XObject must be referred to by name.");
1775                 }
1776 
1777                 let xobj = xobjs.getRaw(name);
1778                 if (xobj instanceof Ref) {
1779                   const cachedImage =
1780                     localImageCache.getByRef(xobj) ||
1781                     self._regionalImageCache.getByRef(xobj) ||
1782                     self.globalImageCache.getData(xobj, self.pageIndex);
1783                   if (cachedImage) {
1784                     addCachedImageOps(operatorList, cachedImage);
1785                     resolveXObject();
1786                     return;
1787                   }
1788 
1789                   xobj = xref.fetch(xobj);
1790                 }
1791 
1792                 if (!(xobj instanceof BaseStream)) {
1793                   throw new FormatError("XObject should be a stream");
1794                 }
1795 
1796                 const type = xobj.dict.get("Subtype");
1797                 if (!(type instanceof Name)) {
1798                   throw new FormatError("XObject should have a Name subtype");
1799                 }
1800 
1801                 if (type.name === "Form") {
1802                   stateManager.save();
1803                   self
1804                     .buildFormXObject(
1805                       resources,
1806                       xobj,
1807                       null,
1808                       operatorList,
1809                       task,
1810                       stateManager.state.clone({ newPath: true }),
1811                       localColorSpaceCache
1812                     )
1813                     .then(function () {
1814                       stateManager.restore();
1815                       resolveXObject();
1816                     }, rejectXObject);
1817                   return;
1818                 } else if (type.name === "Image") {
1819                   self
1820                     .buildPaintImageXObject({
1821                       resources,
1822                       image: xobj,
1823                       operatorList,
1824                       cacheKey: name,
1825                       localImageCache,
1826                       localColorSpaceCache,
1827                     })
1828                     .then(resolveXObject, rejectXObject);
1829                   return;
1830                 } else if (type.name === "PS") {
1831                   // PostScript XObjects are unused when viewing documents.
1832                   // See section 4.7.1 of Adobe's PDF reference.
1833                   info("Ignored XObject subtype PS");
1834                 } else {
1835                   throw new FormatError(
1836                     `Unhandled XObject subtype ${type.name}`
1837                   );
1838                 }
1839                 resolveXObject();
1840               }).catch(function (reason) {
1841                 if (reason instanceof AbortException) {
1842                   return;
1843                 }
1844                 if (self.options.ignoreErrors) {
1845                   warn(`getOperatorList - ignoring XObject: "${reason}".`);
1846                   return;
1847                 }
1848                 throw reason;
1849               })
1850             );
1851             return;
1852           case OPS.setFont:
1853             const fontSize = args[1];
1854             // eagerly collect all fonts
1855             next(
1856               self
1857                 .handleSetFont(
1858                   resources,
1859                   args,
1860                   null,
1861                   operatorList,
1862                   task,
1863                   stateManager.state,
1864                   fallbackFontDict
1865                 )
1866                 .then(function (loadedName) {
1867                   operatorList.addDependency(loadedName);
1868                   operatorList.addOp(OPS.setFont, [loadedName, fontSize]);
1869                 })
1870             );
1871             return;
1872           case OPS.endInlineImage:
1873             const cacheKey = args[0].cacheKey;
1874             if (cacheKey) {
1875               const localImage = localImageCache.getByName(cacheKey);
1876               if (localImage) {
1877                 addCachedImageOps(operatorList, localImage);
1878                 args = null;
1879                 continue;
1880               }
1881             }
1882             next(
1883               self.buildPaintImageXObject({
1884                 resources,
1885                 image: args[0],
1886                 isInline: true,
1887                 operatorList,
1888                 cacheKey,
1889                 localImageCache,
1890                 localColorSpaceCache,
1891               })
1892             );
1893             return;
1894           case OPS.showText:
1895             if (!stateManager.state.font) {
1896               self.ensureStateFont(stateManager.state);
1897               continue;
1898             }
1899             args[0] = self.handleText(args[0], stateManager.state);
1900             break;
1901           case OPS.showSpacedText:
1902             if (!stateManager.state.font) {
1903               self.ensureStateFont(stateManager.state);
1904               continue;
1905             }
1906             const combinedGlyphs = [],
1907               state = stateManager.state;
1908             for (const arrItem of args[0]) {
1909               if (typeof arrItem === "string") {
1910                 combinedGlyphs.push(...self.handleText(arrItem, state));
1911               } else if (typeof arrItem === "number") {
1912                 combinedGlyphs.push(arrItem);
1913               }
1914             }
1915             args[0] = combinedGlyphs;
1916             fn = OPS.showText;
1917             break;
1918           case OPS.nextLineShowText:
1919             if (!stateManager.state.font) {
1920               self.ensureStateFont(stateManager.state);
1921               continue;
1922             }
1923             operatorList.addOp(OPS.nextLine);
1924             args[0] = self.handleText(args[0], stateManager.state);
1925             fn = OPS.showText;
1926             break;
1927           case OPS.nextLineSetSpacingShowText:
1928             if (!stateManager.state.font) {
1929               self.ensureStateFont(stateManager.state);
1930               continue;
1931             }
1932             operatorList.addOp(OPS.nextLine);
1933             operatorList.addOp(OPS.setWordSpacing, [args.shift()]);
1934             operatorList.addOp(OPS.setCharSpacing, [args.shift()]);
1935             args[0] = self.handleText(args[0], stateManager.state);
1936             fn = OPS.showText;
1937             break;
1938           case OPS.setTextRenderingMode:
1939             stateManager.state.textRenderingMode = args[0];
1940             break;
1941 
1942           case OPS.setFillColorSpace: {
1943             const fillCS = self._getColorSpace(
1944               args[0],
1945               resources,
1946               localColorSpaceCache
1947             );
1948             if (fillCS instanceof ColorSpace) {
1949               stateManager.state.fillColorSpace = fillCS;
1950               continue;
1951             }
1952 
1953             next(
1954               self._handleColorSpace(fillCS).then(colorSpace => {
1955                 stateManager.state.fillColorSpace =
1956                   colorSpace || ColorSpaceUtils.gray;
1957               })
1958             );
1959             return;
1960           }
1961           case OPS.setStrokeColorSpace: {
1962             const strokeCS = self._getColorSpace(
1963               args[0],
1964               resources,
1965               localColorSpaceCache
1966             );
1967             if (strokeCS instanceof ColorSpace) {
1968               stateManager.state.strokeColorSpace = strokeCS;
1969               continue;
1970             }
1971 
1972             next(
1973               self._handleColorSpace(strokeCS).then(colorSpace => {
1974                 stateManager.state.strokeColorSpace =
1975                   colorSpace || ColorSpaceUtils.gray;
1976               })
1977             );
1978             return;
1979           }
1980           case OPS.setFillColor:
1981             cs = stateManager.state.fillColorSpace;
1982             args = cs.getRgb(args, 0);
1983             fn = OPS.setFillRGBColor;
1984             break;
1985           case OPS.setStrokeColor:
1986             cs = stateManager.state.strokeColorSpace;
1987             args = cs.getRgb(args, 0);
1988             fn = OPS.setStrokeRGBColor;
1989             break;
1990           case OPS.setFillGray:
1991             stateManager.state.fillColorSpace = ColorSpaceUtils.gray;
1992             args = ColorSpaceUtils.gray.getRgb(args, 0);
1993             fn = OPS.setFillRGBColor;
1994             break;
1995           case OPS.setStrokeGray:
1996             stateManager.state.strokeColorSpace = ColorSpaceUtils.gray;
1997             args = ColorSpaceUtils.gray.getRgb(args, 0);
1998             fn = OPS.setStrokeRGBColor;
1999             break;
2000           case OPS.setFillCMYKColor:
2001             stateManager.state.fillColorSpace = ColorSpaceUtils.cmyk;
2002             args = ColorSpaceUtils.cmyk.getRgb(args, 0);
2003             fn = OPS.setFillRGBColor;
2004             break;
2005           case OPS.setStrokeCMYKColor:
2006             stateManager.state.strokeColorSpace = ColorSpaceUtils.cmyk;
2007             args = ColorSpaceUtils.cmyk.getRgb(args, 0);
2008             fn = OPS.setStrokeRGBColor;
2009             break;
2010           case OPS.setFillRGBColor:
2011             stateManager.state.fillColorSpace = ColorSpaceUtils.rgb;
2012             args = ColorSpaceUtils.rgb.getRgb(args, 0);
2013             break;
2014           case OPS.setStrokeRGBColor:
2015             stateManager.state.strokeColorSpace = ColorSpaceUtils.rgb;
2016             args = ColorSpaceUtils.rgb.getRgb(args, 0);
2017             break;
2018           case OPS.setFillColorN:
2019             cs = stateManager.state.patternFillColorSpace;
2020             if (!cs) {
2021               if (isNumberArray(args, null)) {
2022                 args = ColorSpaceUtils.gray.getRgb(args, 0);
2023                 fn = OPS.setFillRGBColor;
2024                 break;
2025               }
2026               args = [];
2027               fn = OPS.setFillTransparent;
2028               break;
2029             }
2030             if (cs.name === "Pattern") {
2031               next(
2032                 self.handleColorN(
2033                   operatorList,
2034                   OPS.setFillColorN,
2035                   args,
2036                   cs,
2037                   patterns,
2038                   resources,
2039                   task,
2040                   localColorSpaceCache,
2041                   localTilingPatternCache,
2042                   localShadingPatternCache
2043                 )
2044               );
2045               return;
2046             }
2047             args = cs.getRgb(args, 0);
2048             fn = OPS.setFillRGBColor;
2049             break;
2050           case OPS.setStrokeColorN:
2051             cs = stateManager.state.patternStrokeColorSpace;
2052             if (!cs) {
2053               if (isNumberArray(args, null)) {
2054                 args = ColorSpaceUtils.gray.getRgb(args, 0);
2055                 fn = OPS.setStrokeRGBColor;
2056                 break;
2057               }
2058               args = [];
2059               fn = OPS.setStrokeTransparent;
2060               break;
2061             }
2062             if (cs.name === "Pattern") {
2063               next(
2064                 self.handleColorN(
2065                   operatorList,
2066                   OPS.setStrokeColorN,
2067                   args,
2068                   cs,
2069                   patterns,
2070                   resources,
2071                   task,
2072                   localColorSpaceCache,
2073                   localTilingPatternCache,
2074                   localShadingPatternCache
2075                 )
2076               );
2077               return;
2078             }
2079             args = cs.getRgb(args, 0);
2080             fn = OPS.setStrokeRGBColor;
2081             break;
2082 
2083           case OPS.shadingFill:
2084             let shading;
2085             try {
2086               const shadingRes = resources.get("Shading");
2087               if (!shadingRes) {
2088                 throw new FormatError("No shading resource found");
2089               }
2090 
2091               shading = shadingRes.get(args[0].name);
2092               if (!shading) {
2093                 throw new FormatError("No shading object found");
2094               }
2095             } catch (reason) {
2096               if (reason instanceof AbortException) {
2097                 continue;
2098               }
2099               if (self.options.ignoreErrors) {
2100                 warn(`getOperatorList - ignoring Shading: "${reason}".`);
2101                 continue;
2102               }
2103               throw reason;
2104             }
2105             const patternId = self.parseShading({
2106               shading,
2107               resources,
2108               localColorSpaceCache,
2109               localShadingPatternCache,
2110             });
2111             if (!patternId) {
2112               continue;
2113             }
2114             args = [patternId];
2115             fn = OPS.shadingFill;
2116             break;
2117           case OPS.setGState:
2118             isValidName = args[0] instanceof Name;
2119             name = args[0].name;
2120 
2121             if (isValidName) {
2122               const localGStateObj = localGStateCache.getByName(name);
2123               if (localGStateObj) {
2124                 if (localGStateObj.length > 0) {
2125                   operatorList.addOp(OPS.setGState, [localGStateObj]);
2126                 }
2127                 args = null;
2128                 continue;
2129               }
2130             }
2131 
2132             next(
2133               new Promise(function (resolveGState, rejectGState) {
2134                 if (!isValidName) {
2135                   throw new FormatError("GState must be referred to by name.");
2136                 }
2137 
2138                 const extGState = resources.get("ExtGState");
2139                 if (!(extGState instanceof Dict)) {
2140                   throw new FormatError("ExtGState should be a dictionary.");
2141                 }
2142 
2143                 const gState = extGState.get(name);
2144                 // TODO: Attempt to lookup cached GStates by reference as well,
2145                 //       if and only if there are PDF documents where doing so
2146                 //       would significantly improve performance.
2147                 if (!(gState instanceof Dict)) {
2148                   throw new FormatError("GState should be a dictionary.");
2149                 }
2150 
2151                 self
2152                   .setGState({
2153                     resources,
2154                     gState,
2155                     operatorList,
2156                     cacheKey: name,
2157                     task,
2158                     stateManager,
2159                     localGStateCache,
2160                     localColorSpaceCache,
2161                   })
2162                   .then(resolveGState, rejectGState);
2163               }).catch(function (reason) {
2164                 if (reason instanceof AbortException) {
2165                   return;
2166                 }
2167                 if (self.options.ignoreErrors) {
2168                   warn(`getOperatorList - ignoring ExtGState: "${reason}".`);
2169                   return;
2170                 }
2171                 throw reason;
2172               })
2173             );
2174             return;
2175           case OPS.setLineWidth: {
2176             // The thickness should be a non-negative number, as per spec.
2177             // When the value is negative, Acrobat and Poppler take the absolute
2178             // value while PDFium takes the max of 0 and the value.
2179             const [thickness] = args;
2180             if (typeof thickness !== "number") {
2181               warn(`Invalid setLineWidth: ${thickness}`);
2182               continue;
2183             }
2184             args[0] = Math.abs(thickness);
2185             break;
2186           }
2187           case OPS.moveTo:
2188           case OPS.lineTo:
2189           case OPS.curveTo:
2190           case OPS.curveTo2:
2191           case OPS.curveTo3:
2192           case OPS.closePath:
2193           case OPS.rectangle:
2194             self.buildPath(fn, args, stateManager.state);
2195             continue;
2196           case OPS.stroke:
2197           case OPS.closeStroke:
2198           case OPS.fill:
2199           case OPS.eoFill:
2200           case OPS.fillStroke:
2201           case OPS.eoFillStroke:
2202           case OPS.closeFillStroke:
2203           case OPS.closeEOFillStroke:
2204           case OPS.endPath: {
2205             const {
2206               state: { pathBuffer, pathMinMax },
2207             } = stateManager;
2208             if (
2209               fn === OPS.closeStroke ||
2210               fn === OPS.closeFillStroke ||
2211               fn === OPS.closeEOFillStroke
2212             ) {
2213               pathBuffer.push(DrawOPS.closePath);
2214             }
2215             if (pathBuffer.length === 0) {
2216               operatorList.addOp(OPS.constructPath, [fn, [null], null]);
2217             } else {
2218               operatorList.addOp(OPS.constructPath, [
2219                 fn,
2220                 [new Float32Array(pathBuffer)],
2221                 pathMinMax.slice(),
2222               ]);
2223               pathBuffer.length = 0;
2224               pathMinMax.set([Infinity, Infinity, -Infinity, -Infinity], 0);
2225             }
2226             continue;
2227           }
2228           case OPS.setTextMatrix:
2229             operatorList.addOp(fn, [new Float32Array(args)]);
2230             continue;
2231           case OPS.markPoint:
2232           case OPS.markPointProps:
2233           case OPS.beginCompat:
2234           case OPS.endCompat:
2235             // Ignore operators where the corresponding handlers are known to
2236             // be no-op in CanvasGraphics (display/canvas.js). This prevents
2237             // serialization errors and is also a bit more efficient.
2238             // We could also try to serialize all objects in a general way,
2239             // e.g. as done in https://github.com/mozilla/pdf.js/pull/6266,
2240             // but doing so is meaningless without knowing the semantics.
2241             continue;
2242           case OPS.beginMarkedContentProps:
2243             if (!(args[0] instanceof Name)) {
2244               warn(`Expected name for beginMarkedContentProps arg0=${args[0]}`);
2245               operatorList.addOp(OPS.beginMarkedContentProps, ["OC", null]);
2246               continue;
2247             }
2248             if (args[0].name === "OC") {
2249               next(
2250                 self
2251                   .parseMarkedContentProps(args[1], resources)
2252                   .then(data => {
2253                     operatorList.addOp(OPS.beginMarkedContentProps, [
2254                       "OC",
2255                       data,
2256                     ]);
2257                   })
2258                   .catch(reason => {
2259                     if (reason instanceof AbortException) {
2260                       return;
2261                     }
2262                     if (self.options.ignoreErrors) {
2263                       warn(
2264                         `getOperatorList - ignoring beginMarkedContentProps: "${reason}".`
2265                       );
2266                       operatorList.addOp(OPS.beginMarkedContentProps, [
2267                         "OC",
2268                         null,
2269                       ]);
2270                       return;
2271                     }
2272                     throw reason;
2273                   })
2274               );
2275               return;
2276             }
2277             // Other marked content types aren't supported yet.
2278             args = [
2279               args[0].name,
2280               args[1] instanceof Dict ? args[1].get("MCID") : null,
2281             ];
2282 
2283             break;
2284           case OPS.beginMarkedContent:
2285           case OPS.endMarkedContent:
2286           default:
2287             // Note: Ignore the operator if it has `Dict` arguments, since
2288             // those are non-serializable, otherwise postMessage will throw
2289             // "An object could not be cloned.".
2290             if (args !== null) {
2291               for (i = 0, ii = args.length; i < ii; i++) {
2292                 if (args[i] instanceof Dict) {
2293                   break;
2294                 }
2295               }
2296               if (i < ii) {
2297                 warn("getOperatorList - ignoring operator: " + fn);
2298                 continue;
2299               }
2300             }
2301         }
2302         operatorList.addOp(fn, args);
2303       }
2304       if (stop) {
2305         next(deferred);
2306         return;
2307       }
2308       // Some PDFs don't close all restores inside object/form.
2309       // Closing those for them.
2310       closePendingRestoreOPS();
2311       resolve();
2312     }).catch(reason => {
2313       if (reason instanceof AbortException) {
2314         return;
2315       }
2316       if (this.options.ignoreErrors) {
2317         warn(
2318           `getOperatorList - ignoring errors during "${task.name}" ` +
2319             `task: "${reason}".`
2320         );
2321 
2322         closePendingRestoreOPS();
2323         return;
2324       }
2325       throw reason;
2326     });
2327   }
2328 
2329   getTextContent({
2330     stream,
2331     task,
2332     resources,
2333     stateManager = null,
2334     includeMarkedContent = false,
2335     sink,
2336     seenStyles = new Set(),
2337     viewBox,
2338     lang = null,
2339     markedContentData = null,
2340     disableNormalization = false,
2341     keepWhiteSpace = false,
2342   }) {
2343     // Ensure that `resources`/`stateManager` is correctly initialized,
2344     // even if the provided parameter is e.g. `null`.
2345     resources ||= Dict.empty;
2346     stateManager ||= new StateManager(new TextState());
2347 
2348     if (includeMarkedContent) {
2349       markedContentData ||= { level: 0 };
2350     }
2351 
2352     const textContent = {
2353       items: [],
2354       styles: Object.create(null),
2355       lang,
2356     };
2357     const textContentItem = {
2358       initialized: false,
2359       str: [],
2360       totalWidth: 0,
2361       totalHeight: 0,
2362       width: 0,
2363       height: 0,
2364       vertical: false,
2365       prevTransform: null,
2366       textAdvanceScale: 0,
2367       spaceInFlowMin: 0,
2368       spaceInFlowMax: 0,
2369       trackingSpaceMin: Infinity,
2370       negativeSpaceMax: -Infinity,
2371       notASpace: -Infinity,
2372       transform: null,
2373       fontName: null,
2374       hasEOL: false,
2375     };
2376 
2377     // Use a circular buffer (length === 2) to save the last chars in the
2378     // text stream.
2379     // This implementation of the circular buffer is using a fixed array
2380     // and the position of the next element:
2381     // function addElement(x) {
2382     //   buffer[pos] = x;
2383     //   pos = (pos + 1) % buffer.length;
2384     // }
2385     // It's a way faster than:
2386     // function addElement(x) {
2387     //   buffer.push(x);
2388     //   buffer.shift();
2389     // }
2390     //
2391     // It's useful to know when we need to add a whitespace in the
2392     // text chunk.
2393     const twoLastChars = [" ", " "];
2394     let twoLastCharsPos = 0;
2395 
2396     /**
2397      * Save the last char.
2398      * @param {string} char
2399      * @returns {boolean} true when the two last chars before adding the new one
2400      * are a non-whitespace followed by a whitespace.
2401      */
2402     function saveLastChar(char) {
2403       const nextPos = (twoLastCharsPos + 1) % 2;
2404       const ret =
2405         twoLastChars[twoLastCharsPos] !== " " && twoLastChars[nextPos] === " ";
2406       twoLastChars[twoLastCharsPos] = char;
2407       twoLastCharsPos = nextPos;
2408 
2409       return !keepWhiteSpace && ret;
2410     }
2411 
2412     function shouldAddWhitepsace() {
2413       return (
2414         !keepWhiteSpace &&
2415         twoLastChars[twoLastCharsPos] !== " " &&
2416         twoLastChars[(twoLastCharsPos + 1) % 2] === " "
2417       );
2418     }
2419 
2420     function resetLastChars() {
2421       twoLastChars[0] = twoLastChars[1] = " ";
2422       twoLastCharsPos = 0;
2423     }
2424 
2425     // Used in addFakeSpaces.
2426 
2427     // A white <= fontSize * TRACKING_SPACE_FACTOR is a tracking space
2428     // so it doesn't count as a space.
2429     const TRACKING_SPACE_FACTOR = 0.102;
2430 
2431     // When a white <= fontSize * NOT_A_SPACE_FACTOR, there is no space
2432     // even if one is present in the text stream.
2433     const NOT_A_SPACE_FACTOR = 0.03;
2434 
2435     // A negative white < fontSize * NEGATIVE_SPACE_FACTOR induces
2436     // a break (a new chunk of text is created).
2437     // It doesn't change anything when the text is copied but
2438     // it improves potential mismatch between text layer and canvas.
2439     const NEGATIVE_SPACE_FACTOR = -0.2;
2440 
2441     // A white with a width in [fontSize * MIN_FACTOR; fontSize * MAX_FACTOR]
2442     // is a space which will be inserted in the current flow of words.
2443     // If the width is outside of this range then the flow is broken
2444     // (which means a new span in the text layer).
2445     // It's useful to adjust the best as possible the span in the layer
2446     // to what is displayed in the canvas.
2447     const SPACE_IN_FLOW_MIN_FACTOR = 0.102;
2448     const SPACE_IN_FLOW_MAX_FACTOR = 0.6;
2449 
2450     // If a char is too high/too low compared to the previous we just create
2451     // a new chunk.
2452     // If the advance isn't in the +/-VERTICAL_SHIFT_RATIO * height range then
2453     // a new chunk is created.
2454     const VERTICAL_SHIFT_RATIO = 0.25;
2455 
2456     const self = this;
2457     const xref = this.xref;
2458     const showSpacedTextBuffer = [];
2459 
2460     // The xobj is parsed iff it's needed, e.g. if there is a `DO` cmd.
2461     let xobjs = null;
2462     const emptyXObjectCache = new LocalImageCache();
2463     const emptyGStateCache = new LocalGStateCache();
2464 
2465     const preprocessor = new EvaluatorPreprocessor(stream, xref, stateManager);
2466 
2467     let textState;
2468 
2469     function pushWhitespace({
2470       width = 0,
2471       height = 0,
2472       transform = textContentItem.prevTransform,
2473       fontName = textContentItem.fontName,
2474     }) {
2475       textContent.items.push({
2476         str: " ",
2477         dir: "ltr",
2478         width,
2479         height,
2480         transform,
2481         fontName,
2482         hasEOL: false,
2483       });
2484     }
2485 
2486     function getCurrentTextTransform() {
2487       // 9.4.4 Text Space Details
2488       const font = textState.font;
2489       const tsm = [
2490         textState.fontSize * textState.textHScale,
2491         0,
2492         0,
2493         textState.fontSize,
2494         0,
2495         textState.textRise,
2496       ];
2497 
2498       if (
2499         font.isType3Font &&
2500         (textState.fontSize <= 1 || font.isCharBBox) &&
2501         !isArrayEqual(textState.fontMatrix, FONT_IDENTITY_MATRIX)
2502       ) {
2503         const glyphHeight = font.bbox[3] - font.bbox[1];
2504         if (glyphHeight > 0) {
2505           tsm[3] *= glyphHeight * textState.fontMatrix[3];
2506         }
2507       }
2508 
2509       return Util.transform(
2510         textState.ctm,
2511         Util.transform(textState.textMatrix, tsm)
2512       );
2513     }
2514 
2515     function ensureTextContentItem() {
2516       if (textContentItem.initialized) {
2517         return textContentItem;
2518       }
2519       const { font, loadedName } = textState;
2520       if (!seenStyles.has(loadedName)) {
2521         seenStyles.add(loadedName);
2522         textContent.styles[loadedName] = {
2523           fontFamily: font.fallbackName,
2524           ascent: font.ascent,
2525           descent: font.descent,
2526           vertical: font.vertical,
2527         };
2528         if (self.options.fontExtraProperties && font.systemFontInfo) {
2529           const style = textContent.styles[loadedName];
2530           style.fontSubstitution = font.systemFontInfo.css;
2531           style.fontSubstitutionLoadedName = font.systemFontInfo.loadedName;
2532         }
2533       }
2534       textContentItem.fontName = loadedName;
2535 
2536       const trm = (textContentItem.transform = getCurrentTextTransform());
2537       if (!font.vertical) {
2538         textContentItem.width = textContentItem.totalWidth = 0;
2539         textContentItem.height = textContentItem.totalHeight = Math.hypot(
2540           trm[2],
2541           trm[3]
2542         );
2543         textContentItem.vertical = false;
2544       } else {
2545         textContentItem.width = textContentItem.totalWidth = Math.hypot(
2546           trm[0],
2547           trm[1]
2548         );
2549         textContentItem.height = textContentItem.totalHeight = 0;
2550         textContentItem.vertical = true;
2551       }
2552 
2553       const scaleLineX = Math.hypot(
2554         textState.textLineMatrix[0],
2555         textState.textLineMatrix[1]
2556       );
2557       const scaleCtmX = Math.hypot(textState.ctm[0], textState.ctm[1]);
2558       textContentItem.textAdvanceScale = scaleCtmX * scaleLineX;
2559 
2560       const { fontSize } = textState;
2561       textContentItem.trackingSpaceMin = fontSize * TRACKING_SPACE_FACTOR;
2562       textContentItem.notASpace = fontSize * NOT_A_SPACE_FACTOR;
2563       textContentItem.negativeSpaceMax = fontSize * NEGATIVE_SPACE_FACTOR;
2564       textContentItem.spaceInFlowMin = fontSize * SPACE_IN_FLOW_MIN_FACTOR;
2565       textContentItem.spaceInFlowMax = fontSize * SPACE_IN_FLOW_MAX_FACTOR;
2566       textContentItem.hasEOL = false;
2567 
2568       textContentItem.initialized = true;
2569       return textContentItem;
2570     }
2571 
2572     function updateAdvanceScale() {
2573       if (!textContentItem.initialized) {
2574         return;
2575       }
2576 
2577       const scaleLineX = Math.hypot(
2578         textState.textLineMatrix[0],
2579         textState.textLineMatrix[1]
2580       );
2581       const scaleCtmX = Math.hypot(textState.ctm[0], textState.ctm[1]);
2582       const scaleFactor = scaleCtmX * scaleLineX;
2583       if (scaleFactor === textContentItem.textAdvanceScale) {
2584         return;
2585       }
2586 
2587       if (!textContentItem.vertical) {
2588         textContentItem.totalWidth +=
2589           textContentItem.width * textContentItem.textAdvanceScale;
2590         textContentItem.width = 0;
2591       } else {
2592         textContentItem.totalHeight +=
2593           textContentItem.height * textContentItem.textAdvanceScale;
2594         textContentItem.height = 0;
2595       }
2596 
2597       textContentItem.textAdvanceScale = scaleFactor;
2598     }
2599 
2600     function runBidiTransform(textChunk) {
2601       let text = textChunk.str.join("");
2602       if (!disableNormalization) {
2603         text = normalizeUnicode(text);
2604       }
2605       const bidiResult = bidi(text, -1, textChunk.vertical);
2606       return {
2607         str: bidiResult.str,
2608         dir: bidiResult.dir,
2609         width: Math.abs(textChunk.totalWidth),
2610         height: Math.abs(textChunk.totalHeight),
2611         transform: textChunk.transform,
2612         fontName: textChunk.fontName,
2613         hasEOL: textChunk.hasEOL,
2614       };
2615     }
2616 
2617     async function handleSetFont(fontName, fontRef) {
2618       const translated = await self.loadFont(
2619         fontName,
2620         fontRef,
2621         resources,
2622         task
2623       );
2624 
2625       textState.loadedName = translated.loadedName;
2626       textState.font = translated.font;
2627       textState.fontMatrix = translated.font.fontMatrix || FONT_IDENTITY_MATRIX;
2628     }
2629 
2630     function applyInverseRotation(x, y, matrix) {
2631       const scale = Math.hypot(matrix[0], matrix[1]);
2632       return [
2633         (matrix[0] * x + matrix[1] * y) / scale,
2634         (matrix[2] * x + matrix[3] * y) / scale,
2635       ];
2636     }
2637 
2638     function compareWithLastPosition(glyphWidth) {
2639       const currentTransform = getCurrentTextTransform();
2640       let posX = currentTransform[4];
2641       let posY = currentTransform[5];
2642 
2643       // Check if the glyph is in the viewbox.
2644       if (textState.font?.vertical) {
2645         if (
2646           posX < viewBox[0] ||
2647           posX > viewBox[2] ||
2648           posY + glyphWidth < viewBox[1] ||
2649           posY > viewBox[3]
2650         ) {
2651           return false;
2652         }
2653       } else if (
2654         posX + glyphWidth < viewBox[0] ||
2655         posX > viewBox[2] ||
2656         posY < viewBox[1] ||
2657         posY > viewBox[3]
2658       ) {
2659         return false;
2660       }
2661 
2662       if (!textState.font || !textContentItem.prevTransform) {
2663         return true;
2664       }
2665 
2666       let lastPosX = textContentItem.prevTransform[4];
2667       let lastPosY = textContentItem.prevTransform[5];
2668 
2669       if (lastPosX === posX && lastPosY === posY) {
2670         return true;
2671       }
2672 
2673       let rotate = -1;
2674       // Take into account the rotation is the current transform.
2675       if (
2676         currentTransform[0] &&
2677         currentTransform[1] === 0 &&
2678         currentTransform[2] === 0
2679       ) {
2680         rotate = currentTransform[0] > 0 ? 0 : 180;
2681       } else if (
2682         currentTransform[1] &&
2683         currentTransform[0] === 0 &&
2684         currentTransform[3] === 0
2685       ) {
2686         rotate = currentTransform[1] > 0 ? 90 : 270;
2687       }
2688 
2689       switch (rotate) {
2690         case 0:
2691           break;
2692         case 90:
2693           [posX, posY] = [posY, posX];
2694           [lastPosX, lastPosY] = [lastPosY, lastPosX];
2695           break;
2696         case 180:
2697           [posX, posY, lastPosX, lastPosY] = [
2698             -posX,
2699             -posY,
2700             -lastPosX,
2701             -lastPosY,
2702           ];
2703           break;
2704         case 270:
2705           [posX, posY] = [-posY, -posX];
2706           [lastPosX, lastPosY] = [-lastPosY, -lastPosX];
2707           break;
2708         default:
2709           // This is not a 0, 90, 180, 270 rotation so:
2710           //  - remove the scale factor from the matrix to get a rotation matrix
2711           //  - apply the inverse (which is the transposed) to the positions
2712           // and we can then compare positions of the glyphes to detect
2713           // a whitespace.
2714           [posX, posY] = applyInverseRotation(posX, posY, currentTransform);
2715           [lastPosX, lastPosY] = applyInverseRotation(
2716             lastPosX,
2717             lastPosY,
2718             textContentItem.prevTransform
2719           );
2720       }
2721 
2722       if (textState.font.vertical) {
2723         const advanceY = (lastPosY - posY) / textContentItem.textAdvanceScale;
2724         const advanceX = posX - lastPosX;
2725 
2726         // When the total height of the current chunk is negative
2727         // then we're writing from bottom to top.
2728         const textOrientation = Math.sign(textContentItem.height);
2729         if (advanceY < textOrientation * textContentItem.negativeSpaceMax) {
2730           if (
2731             Math.abs(advanceX) >
2732             0.5 * textContentItem.width /* not the same column */
2733           ) {
2734             appendEOL();
2735             return true;
2736           }
2737 
2738           resetLastChars();
2739           flushTextContentItem();
2740           return true;
2741         }
2742 
2743         if (Math.abs(advanceX) > textContentItem.width) {
2744           appendEOL();
2745           return true;
2746         }
2747 
2748         if (advanceY <= textOrientation * textContentItem.notASpace) {
2749           // The real spacing between 2 consecutive chars is thin enough to be
2750           // considered a non-space.
2751           resetLastChars();
2752         }
2753 
2754         if (advanceY <= textOrientation * textContentItem.trackingSpaceMin) {
2755           if (shouldAddWhitepsace()) {
2756             // The space is very thin, hence it deserves to have its own span in
2757             // order to avoid too much shift between the canvas and the text
2758             // layer.
2759             resetLastChars();
2760             flushTextContentItem();
2761             pushWhitespace({ height: Math.abs(advanceY) });
2762           } else {
2763             textContentItem.height += advanceY;
2764           }
2765         } else if (
2766           !addFakeSpaces(
2767             advanceY,
2768             textContentItem.prevTransform,
2769             textOrientation
2770           )
2771         ) {
2772           if (textContentItem.str.length === 0) {
2773             resetLastChars();
2774             pushWhitespace({ height: Math.abs(advanceY) });
2775           } else {
2776             textContentItem.height += advanceY;
2777           }
2778         }
2779 
2780         if (Math.abs(advanceX) > textContentItem.width * VERTICAL_SHIFT_RATIO) {
2781           flushTextContentItem();
2782         }
2783 
2784         return true;
2785       }
2786 
2787       const advanceX = (posX - lastPosX) / textContentItem.textAdvanceScale;
2788       const advanceY = posY - lastPosY;
2789 
2790       // When the total width of the current chunk is negative
2791       // then we're writing from right to left.
2792       const textOrientation = Math.sign(textContentItem.width);
2793       if (advanceX < textOrientation * textContentItem.negativeSpaceMax) {
2794         if (
2795           Math.abs(advanceY) >
2796           0.5 * textContentItem.height /* not the same line */
2797         ) {
2798           appendEOL();
2799           return true;
2800         }
2801 
2802         // We're moving back so in case the last char was a whitespace
2803         // we cancel it: it doesn't make sense to insert it.
2804         resetLastChars();
2805         flushTextContentItem();
2806         return true;
2807       }
2808 
2809       if (Math.abs(advanceY) > textContentItem.height) {
2810         appendEOL();
2811         return true;
2812       }
2813 
2814       if (advanceX <= textOrientation * textContentItem.notASpace) {
2815         // The real spacing between 2 consecutive chars is thin enough to be
2816         // considered a non-space.
2817         resetLastChars();
2818       }
2819 
2820       if (advanceX <= textOrientation * textContentItem.trackingSpaceMin) {
2821         if (shouldAddWhitepsace()) {
2822           // The space is very thin, hence it deserves to have its own span in
2823           // order to avoid too much shift between the canvas and the text
2824           // layer.
2825           resetLastChars();
2826           flushTextContentItem();
2827           pushWhitespace({ width: Math.abs(advanceX) });
2828         } else {
2829           textContentItem.width += advanceX;
2830         }
2831       } else if (
2832         !addFakeSpaces(advanceX, textContentItem.prevTransform, textOrientation)
2833       ) {
2834         if (textContentItem.str.length === 0) {
2835           resetLastChars();
2836           pushWhitespace({ width: Math.abs(advanceX) });
2837         } else {
2838           textContentItem.width += advanceX;
2839         }
2840       }
2841 
2842       if (Math.abs(advanceY) > textContentItem.height * VERTICAL_SHIFT_RATIO) {
2843         flushTextContentItem();
2844       }
2845 
2846       return true;
2847     }
2848 
2849     function buildTextContentItem({ chars, extraSpacing }) {
2850       const font = textState.font;
2851       if (!chars) {
2852         // Just move according to the space we have.
2853         const charSpacing = textState.charSpacing + extraSpacing;
2854         if (charSpacing) {
2855           if (!font.vertical) {
2856             textState.translateTextMatrix(
2857               charSpacing * textState.textHScale,
2858               0
2859             );
2860           } else {
2861             textState.translateTextMatrix(0, -charSpacing);
2862           }
2863         }
2864 
2865         if (keepWhiteSpace) {
2866           compareWithLastPosition(0);
2867         }
2868 
2869         return;
2870       }
2871 
2872       const glyphs = font.charsToGlyphs(chars);
2873       const scale = textState.fontMatrix[0] * textState.fontSize;
2874 
2875       for (let i = 0, ii = glyphs.length; i < ii; i++) {
2876         const glyph = glyphs[i];
2877         const { category } = glyph;
2878 
2879         if (category.isInvisibleFormatMark) {
2880           continue;
2881         }
2882         let charSpacing =
2883           textState.charSpacing + (i + 1 === ii ? extraSpacing : 0);
2884 
2885         let glyphWidth = glyph.width;
2886         if (font.vertical) {
2887           glyphWidth = glyph.vmetric ? glyph.vmetric[0] : -glyphWidth;
2888         }
2889         let scaledDim = glyphWidth * scale;
2890 
2891         if (!keepWhiteSpace && category.isWhitespace) {
2892           // Don't push a " " in the textContentItem
2893           // (except when it's between two non-spaces chars),
2894           // it will be done (if required) in next call to
2895           // compareWithLastPosition.
2896           // This way we can merge real spaces and spaces due to cursor moves.
2897           if (!font.vertical) {
2898             charSpacing += scaledDim + textState.wordSpacing;
2899             textState.translateTextMatrix(
2900               charSpacing * textState.textHScale,
2901               0
2902             );
2903           } else {
2904             charSpacing += -scaledDim + textState.wordSpacing;
2905             textState.translateTextMatrix(0, -charSpacing);
2906           }
2907           saveLastChar(" ");
2908           continue;
2909         }
2910 
2911         if (
2912           !category.isZeroWidthDiacritic &&
2913           !compareWithLastPosition(scaledDim)
2914         ) {
2915           // The glyph is not in page so just skip it but move the cursor.
2916           if (!font.vertical) {
2917             textState.translateTextMatrix(scaledDim * textState.textHScale, 0);
2918           } else {
2919             textState.translateTextMatrix(0, scaledDim);
2920           }
2921           continue;
2922         }
2923 
2924         // Must be called after compareWithLastPosition because
2925         // the textContentItem could have been flushed.
2926         const textChunk = ensureTextContentItem();
2927         if (category.isZeroWidthDiacritic) {
2928           scaledDim = 0;
2929         }
2930 
2931         if (!font.vertical) {
2932           scaledDim *= textState.textHScale;
2933           textState.translateTextMatrix(scaledDim, 0);
2934           textChunk.width += scaledDim;
2935         } else {
2936           textState.translateTextMatrix(0, scaledDim);
2937           scaledDim = Math.abs(scaledDim);
2938           textChunk.height += scaledDim;
2939         }
2940 
2941         if (scaledDim) {
2942           // Save the position of the last visible character.
2943           textChunk.prevTransform = getCurrentTextTransform();
2944         }
2945 
2946         const glyphUnicode = glyph.unicode;
2947         if (saveLastChar(glyphUnicode)) {
2948           // The two last chars are a non-whitespace followed by a whitespace
2949           // and then this non-whitespace, so we insert a whitespace here.
2950           // Replaces all whitespaces with standard spaces (0x20), to avoid
2951           // alignment issues between the textLayer and the canvas if the text
2952           // contains e.g. tabs (fixes issue6612.pdf).
2953           textChunk.str.push(" ");
2954         }
2955         textChunk.str.push(glyphUnicode);
2956 
2957         if (charSpacing) {
2958           if (!font.vertical) {
2959             textState.translateTextMatrix(
2960               charSpacing * textState.textHScale,
2961               0
2962             );
2963           } else {
2964             textState.translateTextMatrix(0, -charSpacing);
2965           }
2966         }
2967       }
2968     }
2969 
2970     function appendEOL() {
2971       resetLastChars();
2972       if (textContentItem.initialized) {
2973         textContentItem.hasEOL = true;
2974         flushTextContentItem();
2975       } else {
2976         textContent.items.push({
2977           str: "",
2978           dir: "ltr",
2979           width: 0,
2980           height: 0,
2981           transform: getCurrentTextTransform(),
2982           fontName: textState.loadedName,
2983           hasEOL: true,
2984         });
2985       }
2986     }
2987 
2988     function addFakeSpaces(width, transf, textOrientation) {
2989       if (
2990         textOrientation * textContentItem.spaceInFlowMin <= width &&
2991         width <= textOrientation * textContentItem.spaceInFlowMax
2992       ) {
2993         if (textContentItem.initialized) {
2994           resetLastChars();
2995           textContentItem.str.push(" ");
2996         }
2997         return false;
2998       }
2999 
3000       const fontName = textContentItem.fontName;
3001 
3002       let height = 0;
3003       if (textContentItem.vertical) {
3004         height = width;
3005         width = 0;
3006       }
3007 
3008       flushTextContentItem();
3009       resetLastChars();
3010       pushWhitespace({
3011         width: Math.abs(width),
3012         height: Math.abs(height),
3013         transform: transf || getCurrentTextTransform(),
3014         fontName,
3015       });
3016 
3017       return true;
3018     }
3019 
3020     function flushTextContentItem() {
3021       if (!textContentItem.initialized || !textContentItem.str) {
3022         return;
3023       }
3024 
3025       // Do final text scaling.
3026       if (!textContentItem.vertical) {
3027         textContentItem.totalWidth +=
3028           textContentItem.width * textContentItem.textAdvanceScale;
3029       } else {
3030         textContentItem.totalHeight +=
3031           textContentItem.height * textContentItem.textAdvanceScale;
3032       }
3033 
3034       textContent.items.push(runBidiTransform(textContentItem));
3035       textContentItem.initialized = false;
3036       textContentItem.str.length = 0;
3037     }
3038 
3039     function enqueueChunk(batch = false) {
3040       const length = textContent.items.length;
3041       if (length === 0) {
3042         return;
3043       }
3044       if (batch && length < TEXT_CHUNK_BATCH_SIZE) {
3045         return;
3046       }
3047       sink.enqueue(textContent, length);
3048       textContent.items = [];
3049       textContent.styles = Object.create(null);
3050     }
3051 
3052     const timeSlotManager = new TimeSlotManager();
3053 
3054     return new Promise(function promiseBody(resolve, reject) {
3055       const next = function (promise) {
3056         enqueueChunk(/* batch = */ true);
3057         Promise.all([promise, sink.ready]).then(function () {
3058           try {
3059             promiseBody(resolve, reject);
3060           } catch (ex) {
3061             reject(ex);
3062           }
3063         }, reject);
3064       };
3065       task.ensureNotTerminated();
3066       timeSlotManager.reset();
3067 
3068       const operation = {};
3069       let stop,
3070         name,
3071         isValidName,
3072         args = [];
3073       while (!(stop = timeSlotManager.check())) {
3074         // The arguments parsed by read() are not used beyond this loop, so
3075         // we can reuse the same array on every iteration, thus avoiding
3076         // unnecessary allocations.
3077         args.length = 0;
3078         operation.args = args;
3079         if (!preprocessor.read(operation)) {
3080           break;
3081         }
3082 
3083         const previousState = textState;
3084         textState = stateManager.state;
3085         const fn = operation.fn;
3086         args = operation.args;
3087 
3088         switch (fn | 0) {
3089           case OPS.setFont:
3090             // Optimization to ignore multiple identical Tf commands.
3091             const fontNameArg = args[0].name,
3092               fontSizeArg = args[1];
3093             if (
3094               textState.font &&
3095               fontNameArg === textState.fontName &&
3096               fontSizeArg === textState.fontSize
3097             ) {
3098               break;
3099             }
3100 
3101             flushTextContentItem();
3102             textState.fontName = fontNameArg;
3103             textState.fontSize = fontSizeArg;
3104             next(handleSetFont(fontNameArg, null));
3105             return;
3106           case OPS.setTextRise:
3107             textState.textRise = args[0];
3108             break;
3109           case OPS.setHScale:
3110             textState.textHScale = args[0] / 100;
3111             break;
3112           case OPS.setLeading:
3113             textState.leading = args[0];
3114             break;
3115           case OPS.moveText:
3116             textState.translateTextLineMatrix(args[0], args[1]);
3117             textState.textMatrix = textState.textLineMatrix.slice();
3118             break;
3119           case OPS.setLeadingMoveText:
3120             textState.leading = -args[1];
3121             textState.translateTextLineMatrix(args[0], args[1]);
3122             textState.textMatrix = textState.textLineMatrix.slice();
3123             break;
3124           case OPS.nextLine:
3125             textState.carriageReturn();
3126             break;
3127           case OPS.setTextMatrix:
3128             textState.setTextMatrix(
3129               args[0],
3130               args[1],
3131               args[2],
3132               args[3],
3133               args[4],
3134               args[5]
3135             );
3136             textState.setTextLineMatrix(
3137               args[0],
3138               args[1],
3139               args[2],
3140               args[3],
3141               args[4],
3142               args[5]
3143             );
3144             updateAdvanceScale();
3145             break;
3146           case OPS.setCharSpacing:
3147             textState.charSpacing = args[0];
3148             break;
3149           case OPS.setWordSpacing:
3150             textState.wordSpacing = args[0];
3151             break;
3152           case OPS.beginText:
3153             textState.textMatrix = IDENTITY_MATRIX.slice();
3154             textState.textLineMatrix = IDENTITY_MATRIX.slice();
3155             break;
3156           case OPS.showSpacedText:
3157             if (!stateManager.state.font) {
3158               self.ensureStateFont(stateManager.state);
3159               continue;
3160             }
3161 
3162             const spaceFactor =
3163               ((textState.font.vertical ? 1 : -1) * textState.fontSize) / 1000;
3164             const elements = args[0];
3165             for (let i = 0, ii = elements.length; i < ii; i++) {
3166               const item = elements[i];
3167               if (typeof item === "string") {
3168                 showSpacedTextBuffer.push(item);
3169               } else if (typeof item === "number" && item !== 0) {
3170                 // PDF Specification 5.3.2 states:
3171                 // The number is expressed in thousandths of a unit of text
3172                 // space.
3173                 // This amount is subtracted from the current horizontal or
3174                 // vertical coordinate, depending on the writing mode.
3175                 // In the default coordinate system, a positive adjustment
3176                 // has the effect of moving the next glyph painted either to
3177                 // the left or down by the given amount.
3178                 const str = showSpacedTextBuffer.join("");
3179                 showSpacedTextBuffer.length = 0;
3180                 buildTextContentItem({
3181                   chars: str,
3182                   extraSpacing: item * spaceFactor,
3183                 });
3184               }
3185             }
3186 
3187             if (showSpacedTextBuffer.length > 0) {
3188               const str = showSpacedTextBuffer.join("");
3189               showSpacedTextBuffer.length = 0;
3190               buildTextContentItem({
3191                 chars: str,
3192                 extraSpacing: 0,
3193               });
3194             }
3195             break;
3196           case OPS.showText:
3197             if (!stateManager.state.font) {
3198               self.ensureStateFont(stateManager.state);
3199               continue;
3200             }
3201             buildTextContentItem({
3202               chars: args[0],
3203               extraSpacing: 0,
3204             });
3205             break;
3206           case OPS.nextLineShowText:
3207             if (!stateManager.state.font) {
3208               self.ensureStateFont(stateManager.state);
3209               continue;
3210             }
3211             textState.carriageReturn();
3212             buildTextContentItem({
3213               chars: args[0],
3214               extraSpacing: 0,
3215             });
3216             break;
3217           case OPS.nextLineSetSpacingShowText:
3218             if (!stateManager.state.font) {
3219               self.ensureStateFont(stateManager.state);
3220               continue;
3221             }
3222             textState.wordSpacing = args[0];
3223             textState.charSpacing = args[1];
3224             textState.carriageReturn();
3225             buildTextContentItem({
3226               chars: args[2],
3227               extraSpacing: 0,
3228             });
3229             break;
3230           case OPS.paintXObject:
3231             flushTextContentItem();
3232             xobjs ??= resources.get("XObject") || Dict.empty;
3233 
3234             isValidName = args[0] instanceof Name;
3235             name = args[0].name;
3236 
3237             if (isValidName && emptyXObjectCache.getByName(name)) {
3238               break;
3239             }
3240 
3241             next(
3242               new Promise(function (resolveXObject, rejectXObject) {
3243                 if (!isValidName) {
3244                   throw new FormatError("XObject must be referred to by name.");
3245                 }
3246 
3247                 let xobj = xobjs.getRaw(name);
3248                 if (xobj instanceof Ref) {
3249                   if (emptyXObjectCache.getByRef(xobj)) {
3250                     resolveXObject();
3251                     return;
3252                   }
3253 
3254                   const globalImage = self.globalImageCache.getData(
3255                     xobj,
3256                     self.pageIndex
3257                   );
3258                   if (globalImage) {
3259                     resolveXObject();
3260                     return;
3261                   }
3262 
3263                   xobj = xref.fetch(xobj);
3264                 }
3265 
3266                 if (!(xobj instanceof BaseStream)) {
3267                   throw new FormatError("XObject should be a stream");
3268                 }
3269 
3270                 const type = xobj.dict.get("Subtype");
3271                 if (!(type instanceof Name)) {
3272                   throw new FormatError("XObject should have a Name subtype");
3273                 }
3274 
3275                 if (type.name !== "Form") {
3276                   emptyXObjectCache.set(name, xobj.dict.objId, true);
3277 
3278                   resolveXObject();
3279                   return;
3280                 }
3281 
3282                 // Use a new `StateManager` to prevent incorrect positioning
3283                 // of textItems *after* the Form XObject, since errors in the
3284                 // data can otherwise prevent `restore` operators from
3285                 // executing.
3286                 // NOTE: Only an issue when `options.ignoreErrors === true`.
3287                 const currentState = stateManager.state.clone();
3288                 const xObjStateManager = new StateManager(currentState);
3289 
3290                 const matrix = lookupMatrix(xobj.dict.getArray("Matrix"), null);
3291                 if (matrix) {
3292                   xObjStateManager.transform(matrix);
3293                 }
3294 
3295                 // Enqueue the `textContent` chunk before parsing the /Form
3296                 // XObject.
3297                 enqueueChunk();
3298                 const sinkWrapper = {
3299                   enqueueInvoked: false,
3300 
3301                   enqueue(chunk, size) {
3302                     this.enqueueInvoked = true;
3303                     sink.enqueue(chunk, size);
3304                   },
3305 
3306                   get desiredSize() {
3307                     return sink.desiredSize;
3308                   },
3309 
3310                   get ready() {
3311                     return sink.ready;
3312                   },
3313                 };
3314 
3315                 self
3316                   .getTextContent({
3317                     stream: xobj,
3318                     task,
3319                     resources: xobj.dict.get("Resources") || resources,
3320                     stateManager: xObjStateManager,
3321                     includeMarkedContent,
3322                     sink: sinkWrapper,
3323                     seenStyles,
3324                     viewBox,
3325                     lang,
3326                     markedContentData,
3327                     disableNormalization,
3328                     keepWhiteSpace,
3329                   })
3330                   .then(function () {
3331                     if (!sinkWrapper.enqueueInvoked) {
3332                       emptyXObjectCache.set(name, xobj.dict.objId, true);
3333                     }
3334                     resolveXObject();
3335                   }, rejectXObject);
3336               }).catch(function (reason) {
3337                 if (reason instanceof AbortException) {
3338                   return;
3339                 }
3340                 if (self.options.ignoreErrors) {
3341                   // Error(s) in the XObject -- allow text-extraction to
3342                   // continue.
3343                   warn(`getTextContent - ignoring XObject: "${reason}".`);
3344                   return;
3345                 }
3346                 throw reason;
3347               })
3348             );
3349             return;
3350           case OPS.setGState:
3351             isValidName = args[0] instanceof Name;
3352             name = args[0].name;
3353 
3354             if (isValidName && emptyGStateCache.getByName(name)) {
3355               break;
3356             }
3357 
3358             next(
3359               new Promise(function (resolveGState, rejectGState) {
3360                 if (!isValidName) {
3361                   throw new FormatError("GState must be referred to by name.");
3362                 }
3363 
3364                 const extGState = resources.get("ExtGState");
3365                 if (!(extGState instanceof Dict)) {
3366                   throw new FormatError("ExtGState should be a dictionary.");
3367                 }
3368 
3369                 const gState = extGState.get(name);
3370                 // TODO: Attempt to lookup cached GStates by reference as well,
3371                 //       if and only if there are PDF documents where doing so
3372                 //       would significantly improve performance.
3373                 if (!(gState instanceof Dict)) {
3374                   throw new FormatError("GState should be a dictionary.");
3375                 }
3376 
3377                 const gStateFont = gState.get("Font");
3378                 if (!gStateFont) {
3379                   emptyGStateCache.set(name, gState.objId, true);
3380 
3381                   resolveGState();
3382                   return;
3383                 }
3384                 flushTextContentItem();
3385 
3386                 textState.fontName = null;
3387                 textState.fontSize = gStateFont[1];
3388                 handleSetFont(null, gStateFont[0]).then(
3389                   resolveGState,
3390                   rejectGState
3391                 );
3392               }).catch(function (reason) {
3393                 if (reason instanceof AbortException) {
3394                   return;
3395                 }
3396                 if (self.options.ignoreErrors) {
3397                   // Error(s) in the ExtGState -- allow text-extraction to
3398                   // continue.
3399                   warn(`getTextContent - ignoring ExtGState: "${reason}".`);
3400                   return;
3401                 }
3402                 throw reason;
3403               })
3404             );
3405             return;
3406           case OPS.beginMarkedContent:
3407             flushTextContentItem();
3408             if (includeMarkedContent) {
3409               markedContentData.level++;
3410 
3411               textContent.items.push({
3412                 type: "beginMarkedContent",
3413                 tag: args[0] instanceof Name ? args[0].name : null,
3414               });
3415             }
3416             break;
3417           case OPS.beginMarkedContentProps:
3418             flushTextContentItem();
3419             if (includeMarkedContent) {
3420               markedContentData.level++;
3421 
3422               let mcid = null;
3423               if (args[1] instanceof Dict) {
3424                 mcid = args[1].get("MCID");
3425               }
3426               textContent.items.push({
3427                 type: "beginMarkedContentProps",
3428                 id: Number.isInteger(mcid)
3429                   ? `${self.idFactory.getPageObjId()}_mc${mcid}`
3430                   : null,
3431                 tag: args[0] instanceof Name ? args[0].name : null,
3432               });
3433             }
3434             break;
3435           case OPS.endMarkedContent:
3436             flushTextContentItem();
3437             if (includeMarkedContent) {
3438               if (markedContentData.level === 0) {
3439                 // Handle unbalanced beginMarkedContent/endMarkedContent
3440                 // operators (fixes issue15629.pdf).
3441                 break;
3442               }
3443               markedContentData.level--;
3444 
3445               textContent.items.push({
3446                 type: "endMarkedContent",
3447               });
3448             }
3449             break;
3450           case OPS.restore:
3451             if (
3452               previousState &&
3453               (previousState.font !== textState.font ||
3454                 previousState.fontSize !== textState.fontSize ||
3455                 previousState.fontName !== textState.fontName)
3456             ) {
3457               flushTextContentItem();
3458             }
3459             break;
3460         } // switch
3461         if (textContent.items.length >= sink.desiredSize) {
3462           // Wait for ready, if we reach highWaterMark.
3463           stop = true;
3464           break;
3465         }
3466       } // while
3467       if (stop) {
3468         next(deferred);
3469         return;
3470       }
3471       flushTextContentItem();
3472       enqueueChunk();
3473       resolve();
3474     }).catch(reason => {
3475       if (reason instanceof AbortException) {
3476         return;
3477       }
3478       if (this.options.ignoreErrors) {
3479         // Error(s) in the TextContent -- allow text-extraction to continue.
3480         warn(
3481           `getTextContent - ignoring errors during "${task.name}" ` +
3482             `task: "${reason}".`
3483         );
3484 
3485         flushTextContentItem();
3486         enqueueChunk();
3487         return;
3488       }
3489       throw reason;
3490     });
3491   }
3492 
3493   async extractDataStructures(dict, properties) {
3494     const xref = this.xref;
3495     let cidToGidBytes;
3496     // 9.10.2
3497     const toUnicodePromise = this.readToUnicode(properties.toUnicode);
3498 
3499     if (properties.composite) {
3500       // CIDSystemInfo helps to match CID to glyphs
3501       const cidSystemInfo = dict.get("CIDSystemInfo");
3502       if (cidSystemInfo instanceof Dict) {
3503         properties.cidSystemInfo = {
3504           registry: stringToPDFString(cidSystemInfo.get("Registry")),
3505           ordering: stringToPDFString(cidSystemInfo.get("Ordering")),
3506           supplement: cidSystemInfo.get("Supplement"),
3507         };
3508       }
3509 
3510       try {
3511         const cidToGidMap = dict.get("CIDToGIDMap");
3512         if (cidToGidMap instanceof BaseStream) {
3513           cidToGidBytes = cidToGidMap.getBytes();
3514         }
3515       } catch (ex) {
3516         if (!this.options.ignoreErrors) {
3517           throw ex;
3518         }
3519         warn(`extractDataStructures - ignoring CIDToGIDMap data: "${ex}".`);
3520       }
3521     }
3522 
3523     // Based on 9.6.6 of the spec the encoding can come from multiple places
3524     // and depends on the font type. The base encoding and differences are
3525     // read here, but the encoding that is actually used is chosen during
3526     // glyph mapping in the font.
3527     // TODO: Loading the built in encoding in the font would allow the
3528     // differences to be merged in here not require us to hold on to it.
3529     const differences = [];
3530     let baseEncodingName = null;
3531     let encoding;
3532     if (dict.has("Encoding")) {
3533       encoding = dict.get("Encoding");
3534       if (encoding instanceof Dict) {
3535         baseEncodingName = encoding.get("BaseEncoding");
3536         baseEncodingName =
3537           baseEncodingName instanceof Name ? baseEncodingName.name : null;
3538         // Load the differences between the base and original
3539         if (encoding.has("Differences")) {
3540           const diffEncoding = encoding.get("Differences");
3541           let index = 0;
3542           for (const entry of diffEncoding) {
3543             const data = xref.fetchIfRef(entry);
3544             if (typeof data === "number") {
3545               index = data;
3546             } else if (data instanceof Name) {
3547               differences[index++] = data.name;
3548             } else {
3549               throw new FormatError(
3550                 `Invalid entry in 'Differences' array: ${data}`
3551               );
3552             }
3553           }
3554         }
3555       } else if (encoding instanceof Name) {
3556         baseEncodingName = encoding.name;
3557       } else {
3558         const msg = "Encoding is not a Name nor a Dict";
3559 
3560         if (!this.options.ignoreErrors) {
3561           throw new FormatError(msg);
3562         }
3563         warn(msg);
3564       }
3565       // According to table 114 if the encoding is a named encoding it must be
3566       // one of these predefined encodings.
3567       if (
3568         baseEncodingName !== "MacRomanEncoding" &&
3569         baseEncodingName !== "MacExpertEncoding" &&
3570         baseEncodingName !== "WinAnsiEncoding"
3571       ) {
3572         baseEncodingName = null;
3573       }
3574     }
3575 
3576     const nonEmbeddedFont = !properties.file || properties.isInternalFont,
3577       isSymbolsFontName = getSymbolsFonts()[properties.name];
3578     // Ignore an incorrectly specified named encoding for non-embedded
3579     // symbol fonts (fixes issue16464.pdf).
3580     if (baseEncodingName && nonEmbeddedFont && isSymbolsFontName) {
3581       baseEncodingName = null;
3582     }
3583 
3584     if (baseEncodingName) {
3585       properties.defaultEncoding = getEncoding(baseEncodingName);
3586     } else {
3587       const isSymbolicFont = !!(properties.flags & FontFlags.Symbolic);
3588       const isNonsymbolicFont = !!(properties.flags & FontFlags.Nonsymbolic);
3589       // According to "Table 114" in section "9.6.6.1 General" (under
3590       // "9.6.6 Character Encoding") of the PDF specification, a Nonsymbolic
3591       // font should use the `StandardEncoding` if no encoding is specified.
3592       encoding = StandardEncoding;
3593       if (properties.type === "TrueType" && !isNonsymbolicFont) {
3594         encoding = WinAnsiEncoding;
3595       }
3596       // The Symbolic attribute can be misused for regular fonts
3597       // Heuristic: we have to check if the font is a standard one also
3598       if (isSymbolicFont || isSymbolsFontName) {
3599         encoding = MacRomanEncoding;
3600         if (nonEmbeddedFont) {
3601           if (/Symbol/i.test(properties.name)) {
3602             encoding = SymbolSetEncoding;
3603           } else if (/Dingbats/i.test(properties.name)) {
3604             encoding = ZapfDingbatsEncoding;
3605           } else if (/Wingdings/i.test(properties.name)) {
3606             encoding = WinAnsiEncoding;
3607           }
3608         }
3609       }
3610       properties.defaultEncoding = encoding;
3611     }
3612 
3613     properties.differences = differences;
3614     properties.baseEncodingName = baseEncodingName;
3615     properties.hasEncoding = !!baseEncodingName || differences.length > 0;
3616     properties.dict = dict;
3617 
3618     properties.toUnicode = await toUnicodePromise;
3619 
3620     const builtToUnicode = await this.buildToUnicode(properties);
3621     properties.toUnicode = builtToUnicode;
3622 
3623     if (cidToGidBytes) {
3624       properties.cidToGidMap = this.readCidToGidMap(
3625         cidToGidBytes,
3626         builtToUnicode
3627       );
3628     }
3629     return properties;
3630   }
3631 
3632   /**
3633    * @returns {Array}
3634    * @private
3635    */
3636   _simpleFontToUnicode(properties, forceGlyphs = false) {
3637     assert(!properties.composite, "Must be a simple font.");
3638 
3639     const toUnicode = [];
3640     const encoding = properties.defaultEncoding.slice();
3641     const baseEncodingName = properties.baseEncodingName;
3642     // Merge in the differences array.
3643     const differences = properties.differences;
3644     for (const charcode in differences) {
3645       const glyphName = differences[charcode];
3646       if (glyphName === ".notdef") {
3647         // Skip .notdef to prevent rendering errors, e.g. boxes appearing
3648         // where there should be spaces (fixes issue5256.pdf).
3649         continue;
3650       }
3651       encoding[charcode] = glyphName;
3652     }
3653     const glyphsUnicodeMap = getGlyphsUnicode();
3654     for (const charcode in encoding) {
3655       // a) Map the character code to a character name.
3656       let glyphName = encoding[charcode];
3657       if (glyphName === "") {
3658         continue;
3659       }
3660       // b) Look up the character name in the Adobe Glyph List (see the
3661       //    Bibliography) to obtain the corresponding Unicode value.
3662       let unicode = glyphsUnicodeMap[glyphName];
3663       if (unicode !== undefined) {
3664         toUnicode[charcode] = String.fromCharCode(unicode);
3665         continue;
3666       }
3667       // (undocumented) c) Few heuristics to recognize unknown glyphs
3668       // NOTE: Adobe Reader does not do this step, but OSX Preview does
3669       let code = 0;
3670       switch (glyphName[0]) {
3671         case "G": // Gxx glyph
3672           if (glyphName.length === 3) {
3673             code = parseInt(glyphName.substring(1), 16);
3674           }
3675           break;
3676         case "g": // g00xx glyph
3677           if (glyphName.length === 5) {
3678             code = parseInt(glyphName.substring(1), 16);
3679           }
3680           break;
3681         case "C": // Cdd{d} glyph
3682         case "c": // cdd{d} glyph
3683           if (glyphName.length >= 3 && glyphName.length <= 4) {
3684             const codeStr = glyphName.substring(1);
3685 
3686             if (forceGlyphs) {
3687               code = parseInt(codeStr, 16);
3688               break;
3689             }
3690             // Normally the Cdd{d}/cdd{d} glyphName format will contain
3691             // regular, i.e. base 10, charCodes (see issue4550.pdf)...
3692             code = +codeStr;
3693 
3694             // ... however some PDF generators violate that assumption by
3695             // containing glyph, i.e. base 16, codes instead.
3696             // In that case we need to re-parse the *entire* encoding to
3697             // prevent broken text-selection (fixes issue9655_reduced.pdf).
3698             if (Number.isNaN(code) && Number.isInteger(parseInt(codeStr, 16))) {
3699               return this._simpleFontToUnicode(
3700                 properties,
3701                 /* forceGlyphs */ true
3702               );
3703             }
3704           }
3705           break;
3706         case "u": // 'uniXXXX'/'uXXXX{XX}' glyphs
3707           unicode = getUnicodeForGlyph(glyphName, glyphsUnicodeMap);
3708           if (unicode !== -1) {
3709             code = unicode;
3710           }
3711           break;
3712         default:
3713           // Support (some) non-standard ligatures.
3714           switch (glyphName) {
3715             case "f_h":
3716             case "f_t":
3717             case "T_h":
3718               toUnicode[charcode] = glyphName.replaceAll("_", "");
3719               continue;
3720           }
3721           break;
3722       }
3723       if (code > 0 && code <= 0x10ffff && Number.isInteger(code)) {
3724         // If `baseEncodingName` is one the predefined encodings, and `code`
3725         // equals `charcode`, using the glyph defined in the baseEncoding
3726         // seems to yield a better `toUnicode` mapping (fixes issue 5070).
3727         if (baseEncodingName && code === +charcode) {
3728           const baseEncoding = getEncoding(baseEncodingName);
3729           if (baseEncoding && (glyphName = baseEncoding[charcode])) {
3730             toUnicode[charcode] = String.fromCharCode(
3731               glyphsUnicodeMap[glyphName]
3732             );
3733             continue;
3734           }
3735         }
3736         toUnicode[charcode] = String.fromCodePoint(code);
3737       }
3738     }
3739     return toUnicode;
3740   }
3741 
3742   /**
3743    * Builds a char code to unicode map based on section 9.10 of the spec.
3744    * @param {Object} properties Font properties object.
3745    * @returns {Promise} A Promise that is resolved with a
3746    *   {ToUnicodeMap|IdentityToUnicodeMap} object.
3747    */
3748   async buildToUnicode(properties) {
3749     properties.hasIncludedToUnicodeMap = properties.toUnicode?.length > 0;
3750 
3751     // Section 9.10.2 Mapping Character Codes to Unicode Values
3752     if (properties.hasIncludedToUnicodeMap) {
3753       // Some fonts contain incomplete ToUnicode data, causing issues with
3754       // text-extraction. For simple fonts, containing encoding information,
3755       // use a fallback ToUnicode map to improve this (fixes issue8229.pdf).
3756       if (!properties.composite && properties.hasEncoding) {
3757         properties.fallbackToUnicode = this._simpleFontToUnicode(properties);
3758       }
3759       return properties.toUnicode;
3760     }
3761 
3762     // According to the spec if the font is a simple font we should only map
3763     // to unicode if the base encoding is MacRoman, MacExpert, or WinAnsi or
3764     // the differences array only contains adobe standard or symbol set names,
3765     // in pratice it seems better to always try to create a toUnicode map
3766     // based of the default encoding.
3767     if (!properties.composite /* is simple font */) {
3768       return new ToUnicodeMap(this._simpleFontToUnicode(properties));
3769     }
3770 
3771     // If the font is a composite font that uses one of the predefined CMaps
3772     // listed in Table 118 (except Identity–H and Identity–V) or whose
3773     // descendant CIDFont uses the Adobe-GB1, Adobe-CNS1, Adobe-Japan1, or
3774     // Adobe-Korea1 character collection:
3775     if (
3776       properties.composite &&
3777       ((properties.cMap.builtInCMap &&
3778         !(properties.cMap instanceof IdentityCMap)) ||
3779         // The font is supposed to have a CIDSystemInfo dictionary, but some
3780         // PDFs don't include it (fixes issue 17689), hence the `?'.
3781         (properties.cidSystemInfo?.registry === "Adobe" &&
3782           (properties.cidSystemInfo.ordering === "GB1" ||
3783             properties.cidSystemInfo.ordering === "CNS1" ||
3784             properties.cidSystemInfo.ordering === "Japan1" ||
3785             properties.cidSystemInfo.ordering === "Korea1")))
3786     ) {
3787       // Then:
3788       // a) Map the character code to a character identifier (CID) according
3789       // to the font’s CMap.
3790       // b) Obtain the registry and ordering of the character collection used
3791       // by the font’s CMap (for example, Adobe and Japan1) from its
3792       // CIDSystemInfo dictionary.
3793       const { registry, ordering } = properties.cidSystemInfo;
3794       // c) Construct a second CMap name by concatenating the registry and
3795       // ordering obtained in step (b) in the format registry–ordering–UCS2
3796       // (for example, Adobe–Japan1–UCS2).
3797       const ucs2CMapName = Name.get(`${registry}-${ordering}-UCS2`);
3798       // d) Obtain the CMap with the name constructed in step (c) (available
3799       // from the ASN Web site; see the Bibliography).
3800       const ucs2CMap = await CMapFactory.create({
3801         encoding: ucs2CMapName,
3802         fetchBuiltInCMap: this._fetchBuiltInCMapBound,
3803         useCMap: null,
3804       });
3805       const toUnicode = [],
3806         buf = [];
3807       properties.cMap.forEach(function (charcode, cid) {
3808         if (cid > 0xffff) {
3809           throw new FormatError("Max size of CID is 65,535");
3810         }
3811         // e) Map the CID obtained in step (a) according to the CMap
3812         // obtained in step (d), producing a Unicode value.
3813         const ucs2 = ucs2CMap.lookup(cid);
3814         if (ucs2) {
3815           buf.length = 0;
3816           // Support multi-byte entries (fixes issue16176.pdf).
3817           for (let i = 0, ii = ucs2.length; i < ii; i += 2) {
3818             buf.push((ucs2.charCodeAt(i) << 8) + ucs2.charCodeAt(i + 1));
3819           }
3820           toUnicode[charcode] = String.fromCharCode(...buf);
3821         }
3822       });
3823       return new ToUnicodeMap(toUnicode);
3824     }
3825 
3826     // The viewer's choice, just use an identity map.
3827     return new IdentityToUnicodeMap(properties.firstChar, properties.lastChar);
3828   }
3829 
3830   async readToUnicode(cmapObj) {
3831     if (!cmapObj) {
3832       return null;
3833     }
3834     if (cmapObj instanceof Name) {
3835       const cmap = await CMapFactory.create({
3836         encoding: cmapObj,
3837         fetchBuiltInCMap: this._fetchBuiltInCMapBound,
3838         useCMap: null,
3839       });
3840 
3841       if (cmap instanceof IdentityCMap) {
3842         return new IdentityToUnicodeMap(0, 0xffff);
3843       }
3844       return new ToUnicodeMap(cmap.getMap());
3845     }
3846     if (cmapObj instanceof BaseStream) {
3847       try {
3848         const cmap = await CMapFactory.create({
3849           encoding: cmapObj,
3850           fetchBuiltInCMap: this._fetchBuiltInCMapBound,
3851           useCMap: null,
3852         });
3853 
3854         if (cmap instanceof IdentityCMap) {
3855           return new IdentityToUnicodeMap(0, 0xffff);
3856         }
3857         const map = new Array(cmap.length);
3858         // Convert UTF-16BE
3859         // NOTE: cmap can be a sparse array, so use forEach instead of
3860         // `for(;;)` to iterate over all keys.
3861         cmap.forEach(function (charCode, token) {
3862           // Some cmaps contain *only* CID characters (fixes issue9367.pdf).
3863           if (typeof token === "number") {
3864             map[charCode] = String.fromCodePoint(token);
3865             return;
3866           }
3867           // Add back omitted leading zeros on odd length tokens
3868           // (fixes issue #18099)
3869           if (token.length % 2 !== 0) {
3870             token = "\u0000" + token;
3871           }
3872           const str = [];
3873           for (let k = 0; k < token.length; k += 2) {
3874             const w1 = (token.charCodeAt(k) << 8) | token.charCodeAt(k + 1);
3875             if ((w1 & 0xf800) !== 0xd800) {
3876               // w1 < 0xD800 || w1 > 0xDFFF
3877               str.push(w1);
3878               continue;
3879             }
3880             k += 2;
3881             const w2 = (token.charCodeAt(k) << 8) | token.charCodeAt(k + 1);
3882             str.push(((w1 & 0x3ff) << 10) + (w2 & 0x3ff) + 0x10000);
3883           }
3884           map[charCode] = String.fromCodePoint(...str);
3885         });
3886         return new ToUnicodeMap(map);
3887       } catch (reason) {
3888         if (reason instanceof AbortException) {
3889           return null;
3890         }
3891         if (this.options.ignoreErrors) {
3892           warn(`readToUnicode - ignoring ToUnicode data: "${reason}".`);
3893           return null;
3894         }
3895         throw reason;
3896       }
3897     }
3898     return null;
3899   }
3900 
3901   readCidToGidMap(glyphsData, toUnicode) {
3902     // Extract the encoding from the CIDToGIDMap
3903 
3904     // Set encoding 0 to later verify the font has an encoding
3905     const result = [];
3906     for (let j = 0, jj = glyphsData.length; j < jj; j++) {
3907       const glyphID = (glyphsData[j++] << 8) | glyphsData[j];
3908       const code = j >> 1;
3909       if (glyphID === 0 && !toUnicode.has(code)) {
3910         continue;
3911       }
3912       result[code] = glyphID;
3913     }
3914     return result;
3915   }
3916 
3917   extractWidths(dict, descriptor, properties) {
3918     const xref = this.xref;
3919     let glyphsWidths = [];
3920     let defaultWidth = 0;
3921     const glyphsVMetrics = [];
3922     let defaultVMetrics;
3923     if (properties.composite) {
3924       const dw = dict.get("DW");
3925       defaultWidth = typeof dw === "number" ? Math.ceil(dw) : 1000;
3926 
3927       const widths = dict.get("W");
3928       if (Array.isArray(widths)) {
3929         for (let i = 0, ii = widths.length; i < ii; i++) {
3930           let start = xref.fetchIfRef(widths[i++]);
3931           if (!Number.isInteger(start)) {
3932             break; // Invalid /W data.
3933           }
3934           const code = xref.fetchIfRef(widths[i]);
3935 
3936           if (Array.isArray(code)) {
3937             for (const c of code) {
3938               const width = xref.fetchIfRef(c);
3939               if (typeof width === "number") {
3940                 glyphsWidths[start] = width;
3941               }
3942               start++;
3943             }
3944           } else if (Number.isInteger(code)) {
3945             const width = xref.fetchIfRef(widths[++i]);
3946             if (typeof width !== "number") {
3947               continue;
3948             }
3949             for (let j = start; j <= code; j++) {
3950               glyphsWidths[j] = width;
3951             }
3952           } else {
3953             break; // Invalid /W data.
3954           }
3955         }
3956       }
3957 
3958       if (properties.vertical) {
3959         const dw2 = dict.getArray("DW2");
3960         let vmetrics = isNumberArray(dw2, 2) ? dw2 : [880, -1000];
3961         defaultVMetrics = [vmetrics[1], defaultWidth * 0.5, vmetrics[0]];
3962         vmetrics = dict.get("W2");
3963         if (Array.isArray(vmetrics)) {
3964           for (let i = 0, ii = vmetrics.length; i < ii; i++) {
3965             let start = xref.fetchIfRef(vmetrics[i++]);
3966             if (!Number.isInteger(start)) {
3967               break; // Invalid /W2 data.
3968             }
3969             const code = xref.fetchIfRef(vmetrics[i]);
3970 
3971             if (Array.isArray(code)) {
3972               for (let j = 0, jj = code.length; j < jj; j++) {
3973                 const vmetric = [
3974                   xref.fetchIfRef(code[j++]),
3975                   xref.fetchIfRef(code[j++]),
3976                   xref.fetchIfRef(code[j]),
3977                 ];
3978                 if (isNumberArray(vmetric, null)) {
3979                   glyphsVMetrics[start] = vmetric;
3980                 }
3981                 start++;
3982               }
3983             } else if (Number.isInteger(code)) {
3984               const vmetric = [
3985                 xref.fetchIfRef(vmetrics[++i]),
3986                 xref.fetchIfRef(vmetrics[++i]),
3987                 xref.fetchIfRef(vmetrics[++i]),
3988               ];
3989               if (!isNumberArray(vmetric, null)) {
3990                 continue;
3991               }
3992               for (let j = start; j <= code; j++) {
3993                 glyphsVMetrics[j] = vmetric;
3994               }
3995             } else {
3996               break; // Invalid /W2 data.
3997             }
3998           }
3999         }
4000       }
4001     } else {
4002       const widths = dict.get("Widths");
4003       if (Array.isArray(widths)) {
4004         let j = properties.firstChar;
4005         for (const w of widths) {
4006           const width = xref.fetchIfRef(w);
4007           if (typeof width === "number") {
4008             glyphsWidths[j] = width;
4009           }
4010           j++;
4011         }
4012         const missingWidth = descriptor.get("MissingWidth");
4013         defaultWidth = typeof missingWidth === "number" ? missingWidth : 0;
4014       } else {
4015         // Trying get the BaseFont metrics (see comment above).
4016         const baseFontName = dict.get("BaseFont");
4017         if (baseFontName instanceof Name) {
4018           const metrics = this.getBaseFontMetrics(baseFontName.name);
4019 
4020           glyphsWidths = this.buildCharCodeToWidth(metrics.widths, properties);
4021           defaultWidth = metrics.defaultWidth;
4022         }
4023       }
4024     }
4025 
4026     // Heuristic: detection of monospace font by checking all non-zero widths
4027     let isMonospace = true;
4028     let firstWidth = defaultWidth;
4029     for (const glyph in glyphsWidths) {
4030       const glyphWidth = glyphsWidths[glyph];
4031       if (!glyphWidth) {
4032         continue;
4033       }
4034       if (!firstWidth) {
4035         firstWidth = glyphWidth;
4036         continue;
4037       }
4038       if (firstWidth !== glyphWidth) {
4039         isMonospace = false;
4040         break;
4041       }
4042     }
4043     if (isMonospace) {
4044       properties.flags |= FontFlags.FixedPitch;
4045     } else {
4046       // Clear the flag.
4047       properties.flags &= ~FontFlags.FixedPitch;
4048     }
4049 
4050     properties.defaultWidth = defaultWidth;
4051     properties.widths = glyphsWidths;
4052     properties.defaultVMetrics = defaultVMetrics;
4053     properties.vmetrics = glyphsVMetrics;
4054   }
4055 
4056   isSerifFont(baseFontName) {
4057     // Simulating descriptor flags attribute
4058     const fontNameWoStyle = baseFontName.split("-", 1)[0];
4059     return (
4060       fontNameWoStyle in getSerifFonts() || /serif/gi.test(fontNameWoStyle)
4061     );
4062   }
4063 
4064   getBaseFontMetrics(name) {
4065     let defaultWidth = 0;
4066     let widths = Object.create(null);
4067     let monospace = false;
4068     const stdFontMap = getStdFontMap();
4069     let lookupName = stdFontMap[name] || name;
4070     const Metrics = getMetrics();
4071 
4072     if (!(lookupName in Metrics)) {
4073       // Use default fonts for looking up font metrics if the passed
4074       // font is not a base font
4075       lookupName = this.isSerifFont(name) ? "Times-Roman" : "Helvetica";
4076     }
4077     const glyphWidths = Metrics[lookupName];
4078 
4079     if (typeof glyphWidths === "number") {
4080       defaultWidth = glyphWidths;
4081       monospace = true;
4082     } else {
4083       widths = glyphWidths(); // expand lazy widths array
4084     }
4085 
4086     return {
4087       defaultWidth,
4088       monospace,
4089       widths,
4090     };
4091   }
4092 
4093   buildCharCodeToWidth(widthsByGlyphName, properties) {
4094     const widths = Object.create(null);
4095     const differences = properties.differences;
4096     const encoding = properties.defaultEncoding;
4097     for (let charCode = 0; charCode < 256; charCode++) {
4098       if (charCode in differences && widthsByGlyphName[differences[charCode]]) {
4099         widths[charCode] = widthsByGlyphName[differences[charCode]];
4100         continue;
4101       }
4102       if (charCode in encoding && widthsByGlyphName[encoding[charCode]]) {
4103         widths[charCode] = widthsByGlyphName[encoding[charCode]];
4104         continue;
4105       }
4106     }
4107     return widths;
4108   }
4109 
4110   preEvaluateFont(dict) {
4111     const baseDict = dict;
4112     let type = dict.get("Subtype");
4113     if (!(type instanceof Name)) {
4114       throw new FormatError("invalid font Subtype");
4115     }
4116 
4117     let composite = false;
4118     let hash;
4119     if (type.name === "Type0") {
4120       // If font is a composite
4121       //  - get the descendant font
4122       //  - set the type according to the descendant font
4123       //  - get the FontDescriptor from the descendant font
4124       const df = dict.get("DescendantFonts");
4125       if (!df) {
4126         throw new FormatError("Descendant fonts are not specified");
4127       }
4128       dict = Array.isArray(df) ? this.xref.fetchIfRef(df[0]) : df;
4129 
4130       if (!(dict instanceof Dict)) {
4131         throw new FormatError("Descendant font is not a dictionary.");
4132       }
4133       type = dict.get("Subtype");
4134       if (!(type instanceof Name)) {
4135         throw new FormatError("invalid font Subtype");
4136       }
4137       composite = true;
4138     }
4139 
4140     let firstChar = dict.get("FirstChar");
4141     if (!Number.isInteger(firstChar)) {
4142       firstChar = 0;
4143     }
4144     let lastChar = dict.get("LastChar");
4145     if (!Number.isInteger(lastChar)) {
4146       lastChar = composite ? 0xffff : 0xff;
4147     }
4148     const descriptor = dict.get("FontDescriptor");
4149     const toUnicode = dict.get("ToUnicode") || baseDict.get("ToUnicode");
4150 
4151     if (descriptor) {
4152       hash = new MurmurHash3_64();
4153 
4154       const encoding = baseDict.getRaw("Encoding");
4155       if (encoding instanceof Name) {
4156         hash.update(encoding.name);
4157       } else if (encoding instanceof Ref) {
4158         hash.update(encoding.toString());
4159       } else if (encoding instanceof Dict) {
4160         for (const entry of encoding.getRawValues()) {
4161           if (entry instanceof Name) {
4162             hash.update(entry.name);
4163           } else if (entry instanceof Ref) {
4164             hash.update(entry.toString());
4165           } else if (Array.isArray(entry)) {
4166             // 'Differences' array (fixes bug1157493.pdf).
4167             const diffLength = entry.length,
4168               diffBuf = new Array(diffLength);
4169 
4170             for (let j = 0; j < diffLength; j++) {
4171               const diffEntry = entry[j];
4172               if (diffEntry instanceof Name) {
4173                 diffBuf[j] = diffEntry.name;
4174               } else if (
4175                 typeof diffEntry === "number" ||
4176                 diffEntry instanceof Ref
4177               ) {
4178                 diffBuf[j] = diffEntry.toString();
4179               }
4180             }
4181             hash.update(diffBuf.join());
4182           }
4183         }
4184       }
4185 
4186       hash.update(`${firstChar}-${lastChar}`); // Fixes issue10665_reduced.pdf
4187 
4188       if (toUnicode instanceof BaseStream) {
4189         const stream = toUnicode.str || toUnicode;
4190         const uint8array = stream.buffer
4191           ? new Uint8Array(stream.buffer.buffer, 0, stream.bufferLength)
4192           : new Uint8Array(
4193               stream.bytes.buffer,
4194               stream.start,
4195               stream.end - stream.start
4196             );
4197         hash.update(uint8array);
4198       } else if (toUnicode instanceof Name) {
4199         hash.update(toUnicode.name);
4200       }
4201 
4202       const widths = dict.get("Widths") || baseDict.get("Widths");
4203       if (Array.isArray(widths)) {
4204         const widthsBuf = [];
4205         for (const entry of widths) {
4206           if (typeof entry === "number" || entry instanceof Ref) {
4207             widthsBuf.push(entry.toString());
4208           }
4209         }
4210         hash.update(widthsBuf.join());
4211       }
4212 
4213       if (composite) {
4214         hash.update("compositeFont");
4215 
4216         const compositeWidths = dict.get("W") || baseDict.get("W");
4217         if (Array.isArray(compositeWidths)) {
4218           const widthsBuf = [];
4219           for (const entry of compositeWidths) {
4220             if (typeof entry === "number" || entry instanceof Ref) {
4221               widthsBuf.push(entry.toString());
4222             } else if (Array.isArray(entry)) {
4223               const subWidthsBuf = [];
4224               for (const element of entry) {
4225                 if (typeof element === "number" || element instanceof Ref) {
4226                   subWidthsBuf.push(element.toString());
4227                 }
4228               }
4229               widthsBuf.push(`[${subWidthsBuf.join()}]`);
4230             }
4231           }
4232           hash.update(widthsBuf.join());
4233         }
4234 
4235         const cidToGidMap =
4236           dict.getRaw("CIDToGIDMap") || baseDict.getRaw("CIDToGIDMap");
4237         if (cidToGidMap instanceof Name) {
4238           hash.update(cidToGidMap.name);
4239         } else if (cidToGidMap instanceof Ref) {
4240           hash.update(cidToGidMap.toString());
4241         } else if (cidToGidMap instanceof BaseStream) {
4242           hash.update(cidToGidMap.peekBytes());
4243         }
4244       }
4245     }
4246 
4247     return {
4248       descriptor,
4249       dict,
4250       baseDict,
4251       composite,
4252       type: type.name,
4253       firstChar,
4254       lastChar,
4255       toUnicode,
4256       hash: hash ? hash.hexdigest() : "",
4257     };
4258   }
4259 
4260   async translateFont({
4261     descriptor,
4262     dict,
4263     baseDict,
4264     composite,
4265     type,
4266     firstChar,
4267     lastChar,
4268     toUnicode,
4269     cssFontInfo,
4270   }) {
4271     const isType3Font = type === "Type3";
4272 
4273     if (!descriptor) {
4274       if (isType3Font) {
4275         const bbox = lookupNormalRect(dict.getArray("FontBBox"), [0, 0, 0, 0]);
4276         // FontDescriptor is only required for Type3 fonts when the document
4277         // is a tagged pdf. Create a barbebones one to get by.
4278         descriptor = new Dict(null);
4279         descriptor.set("FontName", Name.get(type));
4280         descriptor.set("FontBBox", bbox);
4281       } else {
4282         // Before PDF 1.5 if the font was one of the base 14 fonts, having a
4283         // FontDescriptor was not required.
4284         // This case is here for compatibility.
4285         let baseFontName = dict.get("BaseFont");
4286         if (!(baseFontName instanceof Name)) {
4287           throw new FormatError("Base font is not specified");
4288         }
4289 
4290         // Using base font name as a font name.
4291         baseFontName = baseFontName.name.replaceAll(/[,_]/g, "-");
4292         const metrics = this.getBaseFontMetrics(baseFontName);
4293 
4294         // Simulating descriptor flags attribute
4295         const fontNameWoStyle = baseFontName.split("-", 1)[0];
4296         const flags =
4297           (this.isSerifFont(fontNameWoStyle) ? FontFlags.Serif : 0) |
4298           (metrics.monospace ? FontFlags.FixedPitch : 0) |
4299           (getSymbolsFonts()[fontNameWoStyle]
4300             ? FontFlags.Symbolic
4301             : FontFlags.Nonsymbolic);
4302 
4303         const properties = {
4304           type,
4305           name: baseFontName,
4306           loadedName: baseDict.loadedName,
4307           systemFontInfo: null,
4308           widths: metrics.widths,
4309           defaultWidth: metrics.defaultWidth,
4310           isSimulatedFlags: true,
4311           flags,
4312           firstChar,
4313           lastChar,
4314           toUnicode,
4315           xHeight: 0,
4316           capHeight: 0,
4317           italicAngle: 0,
4318           isType3Font,
4319         };
4320         const widths = dict.get("Widths");
4321 
4322         const standardFontName = getStandardFontName(baseFontName);
4323         let file = null;
4324         if (standardFontName) {
4325           file = await this.fetchStandardFontData(standardFontName);
4326           properties.isInternalFont = !!file;
4327         }
4328         if (!properties.isInternalFont && this.options.useSystemFonts) {
4329           properties.systemFontInfo = getFontSubstitution(
4330             this.systemFontCache,
4331             this.idFactory,
4332             this.options.standardFontDataUrl,
4333             baseFontName,
4334             standardFontName,
4335             type
4336           );
4337         }
4338 
4339         const newProperties = await this.extractDataStructures(
4340           dict,
4341           properties
4342         );
4343         if (Array.isArray(widths)) {
4344           const glyphWidths = [];
4345           let j = firstChar;
4346           for (const w of widths) {
4347             const width = this.xref.fetchIfRef(w);
4348             if (typeof width === "number") {
4349               glyphWidths[j] = width;
4350             }
4351             j++;
4352           }
4353           newProperties.widths = glyphWidths;
4354         } else {
4355           newProperties.widths = this.buildCharCodeToWidth(
4356             metrics.widths,
4357             newProperties
4358           );
4359         }
4360         return new Font(baseFontName, file, newProperties, this.options);
4361       }
4362     }
4363 
4364     // According to the spec if 'FontDescriptor' is declared, 'FirstChar',
4365     // 'LastChar' and 'Widths' should exist too, but some PDF encoders seem
4366     // to ignore this rule when a variant of a standard font is used.
4367     // TODO Fill the width array depending on which of the base font this is
4368     // a variant.
4369 
4370     let fontName = descriptor.get("FontName");
4371     let baseFont = dict.get("BaseFont");
4372     // Some bad PDFs have a string as the font name.
4373     if (typeof fontName === "string") {
4374       fontName = Name.get(fontName);
4375     }
4376     if (typeof baseFont === "string") {
4377       baseFont = Name.get(baseFont);
4378     }
4379 
4380     const fontNameStr = fontName?.name;
4381     const baseFontStr = baseFont?.name;
4382     if (!isType3Font && fontNameStr !== baseFontStr) {
4383       info(
4384         `The FontDescriptor's FontName is "${fontNameStr}" but ` +
4385           `should be the same as the Font's BaseFont "${baseFontStr}".`
4386       );
4387       // - Workaround for cases where e.g. fontNameStr = 'Arial' and
4388       //   baseFontStr = 'Arial,Bold' (needed when no font file is embedded).
4389       //
4390       // - Workaround for cases where e.g. fontNameStr = 'wg09np' and
4391       //   baseFontStr = 'Wingdings-Regular' (fixes issue7454.pdf).
4392       if (
4393         fontNameStr &&
4394         baseFontStr &&
4395         (baseFontStr.startsWith(fontNameStr) ||
4396           (!isKnownFontName(fontNameStr) && isKnownFontName(baseFontStr)))
4397       ) {
4398         fontName = null;
4399       }
4400     }
4401     fontName ||= baseFont;
4402 
4403     if (!(fontName instanceof Name)) {
4404       throw new FormatError("invalid font name");
4405     }
4406 
4407     let fontFile, subtype, length1, length2, length3;
4408     try {
4409       fontFile = descriptor.get("FontFile", "FontFile2", "FontFile3");
4410 
4411       if (fontFile) {
4412         if (!(fontFile instanceof BaseStream)) {
4413           throw new FormatError("FontFile should be a stream");
4414         } else if (fontFile.isEmpty) {
4415           throw new FormatError("FontFile is empty");
4416         }
4417       }
4418     } catch (ex) {
4419       if (!this.options.ignoreErrors) {
4420         throw ex;
4421       }
4422       warn(`translateFont - fetching "${fontName.name}" font file: "${ex}".`);
4423       fontFile = null;
4424     }
4425     let isInternalFont = false;
4426     let glyphScaleFactors = null;
4427     let systemFontInfo = null;
4428     if (fontFile) {
4429       if (fontFile.dict) {
4430         const subtypeEntry = fontFile.dict.get("Subtype");
4431         if (subtypeEntry instanceof Name) {
4432           subtype = subtypeEntry.name;
4433         }
4434         length1 = fontFile.dict.get("Length1");
4435         length2 = fontFile.dict.get("Length2");
4436         length3 = fontFile.dict.get("Length3");
4437       }
4438     } else if (cssFontInfo) {
4439       // We've a missing XFA font.
4440       const standardFontName = getXfaFontName(fontName.name);
4441       if (standardFontName) {
4442         cssFontInfo.fontFamily = `${cssFontInfo.fontFamily}-PdfJS-XFA`;
4443         cssFontInfo.metrics = standardFontName.metrics || null;
4444         glyphScaleFactors = standardFontName.factors || null;
4445         fontFile = await this.fetchStandardFontData(standardFontName.name);
4446         isInternalFont = !!fontFile;
4447 
4448         // We're using a substitution font but for example widths (if any)
4449         // are related to the glyph positions in the font.
4450         // So we overwrite everything here to be sure that widths are
4451         // correct.
4452         baseDict = dict = getXfaFontDict(fontName.name);
4453         composite = true;
4454       }
4455     } else if (!isType3Font) {
4456       const standardFontName = getStandardFontName(fontName.name);
4457       if (standardFontName) {
4458         fontFile = await this.fetchStandardFontData(standardFontName);
4459         isInternalFont = !!fontFile;
4460       }
4461       if (!isInternalFont && this.options.useSystemFonts) {
4462         systemFontInfo = getFontSubstitution(
4463           this.systemFontCache,
4464           this.idFactory,
4465           this.options.standardFontDataUrl,
4466           fontName.name,
4467           standardFontName,
4468           type
4469         );
4470       }
4471     }
4472 
4473     const fontMatrix = lookupMatrix(
4474       dict.getArray("FontMatrix"),
4475       FONT_IDENTITY_MATRIX
4476     );
4477     const bbox = lookupNormalRect(
4478       descriptor.getArray("FontBBox") || dict.getArray("FontBBox"),
4479       undefined
4480     );
4481     let ascent = descriptor.get("Ascent");
4482     if (typeof ascent !== "number") {
4483       ascent = undefined;
4484     }
4485     let descent = descriptor.get("Descent");
4486     if (typeof descent !== "number") {
4487       descent = undefined;
4488     }
4489     let xHeight = descriptor.get("XHeight");
4490     if (typeof xHeight !== "number") {
4491       xHeight = 0;
4492     }
4493     let capHeight = descriptor.get("CapHeight");
4494     if (typeof capHeight !== "number") {
4495       capHeight = 0;
4496     }
4497     let flags = descriptor.get("Flags");
4498     if (!Number.isInteger(flags)) {
4499       flags = 0;
4500     }
4501     let italicAngle = descriptor.get("ItalicAngle");
4502     if (typeof italicAngle !== "number") {
4503       italicAngle = 0;
4504     }
4505 
4506     const properties = {
4507       type,
4508       name: fontName.name,
4509       subtype,
4510       file: fontFile,
4511       length1,
4512       length2,
4513       length3,
4514       isInternalFont,
4515       loadedName: baseDict.loadedName,
4516       composite,
4517       fixedPitch: false,
4518       fontMatrix,
4519       firstChar,
4520       lastChar,
4521       toUnicode,
4522       bbox,
4523       ascent,
4524       descent,
4525       xHeight,
4526       capHeight,
4527       flags,
4528       italicAngle,
4529       isType3Font,
4530       cssFontInfo,
4531       scaleFactors: glyphScaleFactors,
4532       systemFontInfo,
4533     };
4534 
4535     if (composite) {
4536       const cidEncoding = baseDict.get("Encoding");
4537       if (cidEncoding instanceof Name) {
4538         properties.cidEncoding = cidEncoding.name;
4539       }
4540       const cMap = await CMapFactory.create({
4541         encoding: cidEncoding,
4542         fetchBuiltInCMap: this._fetchBuiltInCMapBound,
4543         useCMap: null,
4544       });
4545       properties.cMap = cMap;
4546       properties.vertical = properties.cMap.vertical;
4547     }
4548 
4549     const newProperties = await this.extractDataStructures(dict, properties);
4550     this.extractWidths(dict, descriptor, newProperties);
4551 
4552     return new Font(fontName.name, fontFile, newProperties, this.options);
4553   }
4554 
4555   static buildFontPaths(font, glyphs, handler, evaluatorOptions) {
4556     function buildPath(fontChar) {
4557       const glyphName = `${font.loadedName}_path_${fontChar}`;
4558       try {
4559         if (font.renderer.hasBuiltPath(fontChar)) {
4560           return;
4561         }
4562         handler.send("commonobj", [
4563           glyphName,
4564           "FontPath",
4565           font.renderer.getPathJs(fontChar),
4566         ]);
4567       } catch (reason) {
4568         if (evaluatorOptions.ignoreErrors) {
4569           warn(`buildFontPaths - ignoring ${glyphName} glyph: "${reason}".`);
4570           return;
4571         }
4572         throw reason;
4573       }
4574     }
4575 
4576     for (const glyph of glyphs) {
4577       buildPath(glyph.fontChar);
4578 
4579       // If the glyph has an accent we need to build a path for its
4580       // fontChar too, otherwise CanvasGraphics_paintChar will fail.
4581       const accent = glyph.accent;
4582       if (accent?.fontChar) {
4583         buildPath(accent.fontChar);
4584       }
4585     }
4586   }
4587 
4588   static get fallbackFontDict() {
4589     const dict = new Dict();
4590     dict.set("BaseFont", Name.get("Helvetica"));
4591     dict.set("Type", Name.get("FallbackType"));
4592     dict.set("Subtype", Name.get("FallbackType"));
4593     dict.set("Encoding", Name.get("WinAnsiEncoding"));
4594 
4595     return shadow(this, "fallbackFontDict", dict);
4596   }
4597 }
4598 
4599 class TranslatedFont {
4600   #sent = false;
4601 
4602   #type3Loaded = null;
4603 
4604   constructor({ loadedName, font, dict }) {
4605     this.loadedName = loadedName;
4606     this.font = font;
4607     this.dict = dict;
4608     this.type3Dependencies = font.isType3Font ? new Set() : null;
4609   }
4610 
4611   send(handler) {
4612     if (this.#sent) {
4613       return;
4614     }
4615     this.#sent = true;
4616 
4617     handler.send("commonobj", [
4618       this.loadedName,
4619       "Font",
4620       this.font.exportData(),
4621     ]);
4622   }
4623 
4624   fallback(handler, evaluatorOptions) {
4625     if (!this.font.data) {
4626       return;
4627     }
4628     // When font loading failed, fall back to the built-in font renderer.
4629     this.font.disableFontFace = true;
4630     // An arbitrary number of text rendering operators could have been
4631     // encountered between the point in time when the 'Font' message was sent
4632     // to the main-thread, and the point in time when the 'FontFallback'
4633     // message was received on the worker-thread.
4634     // To ensure that all 'FontPath's are available on the main-thread, when
4635     // font loading failed, attempt to resend *all* previously parsed glyphs.
4636     PartialEvaluator.buildFontPaths(
4637       this.font,
4638       /* glyphs = */ this.font.glyphCacheValues,
4639       handler,
4640       evaluatorOptions
4641     );
4642   }
4643 
4644   loadType3Data(evaluator, resources, task) {
4645     if (this.#type3Loaded) {
4646       return this.#type3Loaded;
4647     }
4648     const { font, type3Dependencies } = this;
4649     assert(font.isType3Font, "Must be a Type3 font.");
4650 
4651     // When parsing Type3 glyphs, always ignore them if there are errors.
4652     // Compared to the parsing of e.g. an entire page, it doesn't really
4653     // make sense to only be able to render a Type3 glyph partially.
4654     const type3Evaluator = evaluator.clone({ ignoreErrors: false });
4655     // Prevent circular references in Type3 fonts.
4656     const type3FontRefs = new RefSet(evaluator.type3FontRefs);
4657     if (this.dict.objId && !type3FontRefs.has(this.dict.objId)) {
4658       type3FontRefs.put(this.dict.objId);
4659     }
4660     type3Evaluator.type3FontRefs = type3FontRefs;
4661 
4662     let loadCharProcsPromise = Promise.resolve();
4663     const charProcs = this.dict.get("CharProcs");
4664     const fontResources = this.dict.get("Resources") || resources;
4665     const charProcOperatorList = Object.create(null);
4666 
4667     const fontBBox = Util.normalizeRect(font.bbox || [0, 0, 0, 0]),
4668       width = fontBBox[2] - fontBBox[0],
4669       height = fontBBox[3] - fontBBox[1];
4670     const fontBBoxSize = Math.hypot(width, height);
4671 
4672     for (const key of charProcs.getKeys()) {
4673       loadCharProcsPromise = loadCharProcsPromise.then(() => {
4674         const glyphStream = charProcs.get(key);
4675         const operatorList = new OperatorList();
4676         return type3Evaluator
4677           .getOperatorList({
4678             stream: glyphStream,
4679             task,
4680             resources: fontResources,
4681             operatorList,
4682           })
4683           .then(() => {
4684             // According to the PDF specification, section "9.6.5 Type 3 Fonts"
4685             // and "Table 113":
4686             //  "A glyph description that begins with the d1 operator should
4687             //   not execute any operators that set the colour (or other
4688             //   colour-related parameters) in the graphics state;
4689             //   any use of such operators shall be ignored."
4690             switch (operatorList.fnArray[0]) {
4691               case OPS.setCharWidthAndBounds:
4692                 this.#removeType3ColorOperators(operatorList, fontBBoxSize);
4693                 break;
4694               case OPS.setCharWidth:
4695                 if (!fontBBoxSize) {
4696                   this.#guessType3FontBBox(operatorList);
4697                 }
4698                 break;
4699             }
4700             charProcOperatorList[key] = operatorList.getIR();
4701 
4702             for (const dependency of operatorList.dependencies) {
4703               type3Dependencies.add(dependency);
4704             }
4705           })
4706           .catch(function (reason) {
4707             warn(`Type3 font resource "${key}" is not available.`);
4708             const dummyOperatorList = new OperatorList();
4709             charProcOperatorList[key] = dummyOperatorList.getIR();
4710           });
4711       });
4712     }
4713     this.#type3Loaded = loadCharProcsPromise.then(() => {
4714       font.charProcOperatorList = charProcOperatorList;
4715       if (this._bbox) {
4716         font.isCharBBox = true;
4717         font.bbox = this._bbox;
4718       }
4719     });
4720     return this.#type3Loaded;
4721   }
4722 
4723   #removeType3ColorOperators(operatorList, fontBBoxSize = NaN) {
4724     if (typeof PDFJSDev === "undefined" || PDFJSDev.test("TESTING")) {
4725       assert(
4726         operatorList.fnArray[0] === OPS.setCharWidthAndBounds,
4727         "Type3 glyph shall start with the d1 operator."
4728       );
4729     }
4730     const charBBox = Util.normalizeRect(operatorList.argsArray[0].slice(2)),
4731       width = charBBox[2] - charBBox[0],
4732       height = charBBox[3] - charBBox[1];
4733     const charBBoxSize = Math.hypot(width, height);
4734 
4735     if (width === 0 || height === 0) {
4736       // Skip the d1 operator when its bounds are bogus (fixes issue14953.pdf).
4737       operatorList.fnArray.splice(0, 1);
4738       operatorList.argsArray.splice(0, 1);
4739     } else if (
4740       fontBBoxSize === 0 ||
4741       Math.round(charBBoxSize / fontBBoxSize) >= 10
4742     ) {
4743       // Override the fontBBox when it's undefined/empty, or when it's at least
4744       // (approximately) one order of magnitude smaller than the charBBox
4745       // (fixes issue14999_reduced.pdf).
4746       this._bbox ??= [Infinity, Infinity, -Infinity, -Infinity];
4747       Util.rectBoundingBox(...charBBox, this._bbox);
4748     }
4749 
4750     let i = 0,
4751       ii = operatorList.length;
4752     while (i < ii) {
4753       switch (operatorList.fnArray[i]) {
4754         case OPS.setCharWidthAndBounds:
4755           break; // Handled above.
4756         case OPS.setStrokeColorSpace:
4757         case OPS.setFillColorSpace:
4758         case OPS.setStrokeColor:
4759         case OPS.setStrokeColorN:
4760         case OPS.setFillColor:
4761         case OPS.setFillColorN:
4762         case OPS.setStrokeGray:
4763         case OPS.setFillGray:
4764         case OPS.setStrokeRGBColor:
4765         case OPS.setFillRGBColor:
4766         case OPS.setStrokeCMYKColor:
4767         case OPS.setFillCMYKColor:
4768         case OPS.shadingFill:
4769         case OPS.setRenderingIntent:
4770           operatorList.fnArray.splice(i, 1);
4771           operatorList.argsArray.splice(i, 1);
4772           ii--;
4773           continue;
4774 
4775         case OPS.setGState:
4776           const [gStateObj] = operatorList.argsArray[i];
4777           let j = 0,
4778             jj = gStateObj.length;
4779           while (j < jj) {
4780             const [gStateKey] = gStateObj[j];
4781             switch (gStateKey) {
4782               case "TR":
4783               case "TR2":
4784               case "HT":
4785               case "BG":
4786               case "BG2":
4787               case "UCR":
4788               case "UCR2":
4789                 gStateObj.splice(j, 1);
4790                 jj--;
4791                 continue;
4792             }
4793             j++;
4794           }
4795           break;
4796       }
4797       i++;
4798     }
4799   }
4800 
4801   #guessType3FontBBox(operatorList) {
4802     if (typeof PDFJSDev === "undefined" || PDFJSDev.test("TESTING")) {
4803       assert(
4804         operatorList.fnArray[0] === OPS.setCharWidth,
4805         "Type3 glyph shall start with the d0 operator."
4806       );
4807     }
4808 
4809     let i = 1;
4810     const ii = operatorList.length;
4811     while (i < ii) {
4812       switch (operatorList.fnArray[i]) {
4813         case OPS.constructPath:
4814           const minMax = operatorList.argsArray[i][2];
4815           // Override the fontBBox when it's undefined/empty (fixes 19624.pdf).
4816           this._bbox ??= [Infinity, Infinity, -Infinity, -Infinity];
4817           Util.rectBoundingBox(...minMax, this._bbox);
4818           break;
4819       }
4820       i++;
4821     }
4822   }
4823 }
4824 
4825 class StateManager {
4826   constructor(initialState = new EvalState()) {
4827     this.state = initialState;
4828     this.stateStack = [];
4829   }
4830 
4831   save() {
4832     const old = this.state;
4833     this.stateStack.push(this.state);
4834     this.state = old.clone();
4835   }
4836 
4837   restore() {
4838     const prev = this.stateStack.pop();
4839     if (prev) {
4840       this.state = prev;
4841     }
4842   }
4843 
4844   transform(args) {
4845     this.state.ctm = Util.transform(this.state.ctm, args);
4846   }
4847 }
4848 
4849 class TextState {
4850   constructor() {
4851     this.ctm = new Float32Array(IDENTITY_MATRIX);
4852     this.fontName = null;
4853     this.fontSize = 0;
4854     this.loadedName = null;
4855     this.font = null;
4856     this.fontMatrix = FONT_IDENTITY_MATRIX;
4857     this.textMatrix = IDENTITY_MATRIX.slice();
4858     this.textLineMatrix = IDENTITY_MATRIX.slice();
4859     this.charSpacing = 0;
4860     this.wordSpacing = 0;
4861     this.leading = 0;
4862     this.textHScale = 1;
4863     this.textRise = 0;
4864   }
4865 
4866   setTextMatrix(a, b, c, d, e, f) {
4867     const m = this.textMatrix;
4868     m[0] = a;
4869     m[1] = b;
4870     m[2] = c;
4871     m[3] = d;
4872     m[4] = e;
4873     m[5] = f;
4874   }
4875 
4876   setTextLineMatrix(a, b, c, d, e, f) {
4877     const m = this.textLineMatrix;
4878     m[0] = a;
4879     m[1] = b;
4880     m[2] = c;
4881     m[3] = d;
4882     m[4] = e;
4883     m[5] = f;
4884   }
4885 
4886   translateTextMatrix(x, y) {
4887     const m = this.textMatrix;
4888     m[4] = m[0] * x + m[2] * y + m[4];
4889     m[5] = m[1] * x + m[3] * y + m[5];
4890   }
4891 
4892   translateTextLineMatrix(x, y) {
4893     const m = this.textLineMatrix;
4894     m[4] = m[0] * x + m[2] * y + m[4];
4895     m[5] = m[1] * x + m[3] * y + m[5];
4896   }
4897 
4898   carriageReturn() {
4899     this.translateTextLineMatrix(0, -this.leading);
4900     this.textMatrix = this.textLineMatrix.slice();
4901   }
4902 
4903   clone() {
4904     const clone = Object.create(this);
4905     clone.textMatrix = this.textMatrix.slice();
4906     clone.textLineMatrix = this.textLineMatrix.slice();
4907     clone.fontMatrix = this.fontMatrix.slice();
4908     return clone;
4909   }
4910 }
4911 
4912 class EvalState {
4913   constructor() {
4914     this.ctm = new Float32Array(IDENTITY_MATRIX);
4915     this.font = null;
4916     this.textRenderingMode = TextRenderingMode.FILL;
4917     this._fillColorSpace = this._strokeColorSpace = ColorSpaceUtils.gray;
4918     this.patternFillColorSpace = null;
4919     this.patternStrokeColorSpace = null;
4920 
4921     // Path stuff.
4922     this.currentPointX = this.currentPointY = 0;
4923     this.pathMinMax = new Float32Array([
4924       Infinity,
4925       Infinity,
4926       -Infinity,
4927       -Infinity,
4928     ]);
4929     this.pathBuffer = [];
4930   }
4931 
4932   get fillColorSpace() {
4933     return this._fillColorSpace;
4934   }
4935 
4936   set fillColorSpace(colorSpace) {
4937     this._fillColorSpace = this.patternFillColorSpace = colorSpace;
4938   }
4939 
4940   get strokeColorSpace() {
4941     return this._strokeColorSpace;
4942   }
4943 
4944   set strokeColorSpace(colorSpace) {
4945     this._strokeColorSpace = this.patternStrokeColorSpace = colorSpace;
4946   }
4947 
4948   clone({ newPath = false } = {}) {
4949     const clone = Object.create(this);
4950     if (newPath) {
4951       clone.pathBuffer = [];
4952       clone.pathMinMax = new Float32Array([
4953         Infinity,
4954         Infinity,
4955         -Infinity,
4956         -Infinity,
4957       ]);
4958     }
4959     return clone;
4960   }
4961 }
4962 
4963 class EvaluatorPreprocessor {
4964   static get opMap() {
4965     // Specifies properties for each command
4966     //
4967     // If variableArgs === true: [0, `numArgs`] expected
4968     // If variableArgs === false: exactly `numArgs` expected
4969     return shadow(
4970       this,
4971       "opMap",
4972       Object.assign(Object.create(null), {
4973         // Graphic state
4974         w: { id: OPS.setLineWidth, numArgs: 1, variableArgs: false },
4975         J: { id: OPS.setLineCap, numArgs: 1, variableArgs: false },
4976         j: { id: OPS.setLineJoin, numArgs: 1, variableArgs: false },
4977         M: { id: OPS.setMiterLimit, numArgs: 1, variableArgs: false },
4978         d: { id: OPS.setDash, numArgs: 2, variableArgs: false },
4979         ri: { id: OPS.setRenderingIntent, numArgs: 1, variableArgs: false },
4980         i: { id: OPS.setFlatness, numArgs: 1, variableArgs: false },
4981         gs: { id: OPS.setGState, numArgs: 1, variableArgs: false },
4982         q: { id: OPS.save, numArgs: 0, variableArgs: false },
4983         Q: { id: OPS.restore, numArgs: 0, variableArgs: false },
4984         cm: { id: OPS.transform, numArgs: 6, variableArgs: false },
4985 
4986         // Path
4987         m: { id: OPS.moveTo, numArgs: 2, variableArgs: false },
4988         l: { id: OPS.lineTo, numArgs: 2, variableArgs: false },
4989         c: { id: OPS.curveTo, numArgs: 6, variableArgs: false },
4990         v: { id: OPS.curveTo2, numArgs: 4, variableArgs: false },
4991         y: { id: OPS.curveTo3, numArgs: 4, variableArgs: false },
4992         h: { id: OPS.closePath, numArgs: 0, variableArgs: false },
4993         re: { id: OPS.rectangle, numArgs: 4, variableArgs: false },
4994         S: { id: OPS.stroke, numArgs: 0, variableArgs: false },
4995         s: { id: OPS.closeStroke, numArgs: 0, variableArgs: false },
4996         f: { id: OPS.fill, numArgs: 0, variableArgs: false },
4997         F: { id: OPS.fill, numArgs: 0, variableArgs: false },
4998         "f*": { id: OPS.eoFill, numArgs: 0, variableArgs: false },
4999         B: { id: OPS.fillStroke, numArgs: 0, variableArgs: false },
5000         "B*": { id: OPS.eoFillStroke, numArgs: 0, variableArgs: false },
5001         b: { id: OPS.closeFillStroke, numArgs: 0, variableArgs: false },
5002         "b*": { id: OPS.closeEOFillStroke, numArgs: 0, variableArgs: false },
5003         n: { id: OPS.endPath, numArgs: 0, variableArgs: false },
5004 
5005         // Clipping
5006         W: { id: OPS.clip, numArgs: 0, variableArgs: false },
5007         "W*": { id: OPS.eoClip, numArgs: 0, variableArgs: false },
5008 
5009         // Text
5010         BT: { id: OPS.beginText, numArgs: 0, variableArgs: false },
5011         ET: { id: OPS.endText, numArgs: 0, variableArgs: false },
5012         Tc: { id: OPS.setCharSpacing, numArgs: 1, variableArgs: false },
5013         Tw: { id: OPS.setWordSpacing, numArgs: 1, variableArgs: false },
5014         Tz: { id: OPS.setHScale, numArgs: 1, variableArgs: false },
5015         TL: { id: OPS.setLeading, numArgs: 1, variableArgs: false },
5016         Tf: { id: OPS.setFont, numArgs: 2, variableArgs: false },
5017         Tr: { id: OPS.setTextRenderingMode, numArgs: 1, variableArgs: false },
5018         Ts: { id: OPS.setTextRise, numArgs: 1, variableArgs: false },
5019         Td: { id: OPS.moveText, numArgs: 2, variableArgs: false },
5020         TD: { id: OPS.setLeadingMoveText, numArgs: 2, variableArgs: false },
5021         Tm: { id: OPS.setTextMatrix, numArgs: 6, variableArgs: false },
5022         "T*": { id: OPS.nextLine, numArgs: 0, variableArgs: false },
5023         Tj: { id: OPS.showText, numArgs: 1, variableArgs: false },
5024         TJ: { id: OPS.showSpacedText, numArgs: 1, variableArgs: false },
5025         "'": { id: OPS.nextLineShowText, numArgs: 1, variableArgs: false },
5026         '"': {
5027           id: OPS.nextLineSetSpacingShowText,
5028           numArgs: 3,
5029           variableArgs: false,
5030         },
5031 
5032         // Type3 fonts
5033         d0: { id: OPS.setCharWidth, numArgs: 2, variableArgs: false },
5034         d1: {
5035           id: OPS.setCharWidthAndBounds,
5036           numArgs: 6,
5037           variableArgs: false,
5038         },
5039 
5040         // Color
5041         CS: { id: OPS.setStrokeColorSpace, numArgs: 1, variableArgs: false },
5042         cs: { id: OPS.setFillColorSpace, numArgs: 1, variableArgs: false },
5043         SC: { id: OPS.setStrokeColor, numArgs: 4, variableArgs: true },
5044         SCN: { id: OPS.setStrokeColorN, numArgs: 33, variableArgs: true },
5045         sc: { id: OPS.setFillColor, numArgs: 4, variableArgs: true },
5046         scn: { id: OPS.setFillColorN, numArgs: 33, variableArgs: true },
5047         G: { id: OPS.setStrokeGray, numArgs: 1, variableArgs: false },
5048         g: { id: OPS.setFillGray, numArgs: 1, variableArgs: false },
5049         RG: { id: OPS.setStrokeRGBColor, numArgs: 3, variableArgs: false },
5050         rg: { id: OPS.setFillRGBColor, numArgs: 3, variableArgs: false },
5051         K: { id: OPS.setStrokeCMYKColor, numArgs: 4, variableArgs: false },
5052         k: { id: OPS.setFillCMYKColor, numArgs: 4, variableArgs: false },
5053 
5054         // Shading
5055         sh: { id: OPS.shadingFill, numArgs: 1, variableArgs: false },
5056 
5057         // Images
5058         BI: { id: OPS.beginInlineImage, numArgs: 0, variableArgs: false },
5059         ID: { id: OPS.beginImageData, numArgs: 0, variableArgs: false },
5060         EI: { id: OPS.endInlineImage, numArgs: 1, variableArgs: false },
5061 
5062         // XObjects
5063         Do: { id: OPS.paintXObject, numArgs: 1, variableArgs: false },
5064         MP: { id: OPS.markPoint, numArgs: 1, variableArgs: false },
5065         DP: { id: OPS.markPointProps, numArgs: 2, variableArgs: false },
5066         BMC: { id: OPS.beginMarkedContent, numArgs: 1, variableArgs: false },
5067         BDC: {
5068           id: OPS.beginMarkedContentProps,
5069           numArgs: 2,
5070           variableArgs: false,
5071         },
5072         EMC: { id: OPS.endMarkedContent, numArgs: 0, variableArgs: false },
5073 
5074         // Compatibility
5075         BX: { id: OPS.beginCompat, numArgs: 0, variableArgs: false },
5076         EX: { id: OPS.endCompat, numArgs: 0, variableArgs: false },
5077 
5078         // (reserved partial commands for the lexer)
5079         BM: null,
5080         BD: null,
5081         true: null,
5082         fa: null,
5083         fal: null,
5084         fals: null,
5085         false: null,
5086         nu: null,
5087         nul: null,
5088         null: null,
5089       })
5090     );
5091   }
5092 
5093   static MAX_INVALID_PATH_OPS = 10;
5094 
5095   constructor(stream, xref, stateManager = new StateManager()) {
5096     // TODO(mduan): pass array of knownCommands rather than this.opMap
5097     // dictionary
5098     this.parser = new Parser({
5099       lexer: new Lexer(stream, EvaluatorPreprocessor.opMap),
5100       xref,
5101     });
5102     this.stateManager = stateManager;
5103     this.nonProcessedArgs = [];
5104     this._isPathOp = false;
5105     this._numInvalidPathOPS = 0;
5106   }
5107 
5108   get savedStatesDepth() {
5109     return this.stateManager.stateStack.length;
5110   }
5111 
5112   // |operation| is an object with two fields:
5113   //
5114   // - |fn| is an out param.
5115   //
5116   // - |args| is an inout param. On entry, it should have one of two values.
5117   //
5118   //   - An empty array. This indicates that the caller is providing the
5119   //     array in which the args will be stored in. The caller should use
5120   //     this value if it can reuse a single array for each call to read().
5121   //
5122   //   - |null|. This indicates that the caller needs this function to create
5123   //     the array in which any args are stored in. If there are zero args,
5124   //     this function will leave |operation.args| as |null| (thus avoiding
5125   //     allocations that would occur if we used an empty array to represent
5126   //     zero arguments). Otherwise, it will replace |null| with a new array
5127   //     containing the arguments. The caller should use this value if it
5128   //     cannot reuse an array for each call to read().
5129   //
5130   // These two modes are present because this function is very hot and so
5131   // avoiding allocations where possible is worthwhile.
5132   //
5133   read(operation) {
5134     let args = operation.args;
5135     while (true) {
5136       const obj = this.parser.getObj();
5137       if (obj instanceof Cmd) {
5138         const cmd = obj.cmd;
5139         // Check that the command is valid
5140         const opSpec = EvaluatorPreprocessor.opMap[cmd];
5141         if (!opSpec) {
5142           warn(`Unknown command "${cmd}".`);
5143           continue;
5144         }
5145 
5146         const fn = opSpec.id;
5147         const numArgs = opSpec.numArgs;
5148         let argsLength = args !== null ? args.length : 0;
5149 
5150         // If the *previous* command wasn't a path operator, reset the heuristic
5151         // used with incomplete path operators below (fixes issue14917.pdf).
5152         if (!this._isPathOp) {
5153           this._numInvalidPathOPS = 0;
5154         }
5155         this._isPathOp = fn >= OPS.moveTo && fn <= OPS.endPath;
5156 
5157         if (!opSpec.variableArgs) {
5158           // Postscript commands can be nested, e.g. /F2 /GS2 gs 5.711 Tf
5159           if (argsLength !== numArgs) {
5160             const nonProcessedArgs = this.nonProcessedArgs;
5161             while (argsLength > numArgs) {
5162               nonProcessedArgs.push(args.shift());
5163               argsLength--;
5164             }
5165             while (argsLength < numArgs && nonProcessedArgs.length !== 0) {
5166               if (args === null) {
5167                 args = [];
5168               }
5169               args.unshift(nonProcessedArgs.pop());
5170               argsLength++;
5171             }
5172           }
5173 
5174           if (argsLength < numArgs) {
5175             const partialMsg =
5176               `command ${cmd}: expected ${numArgs} args, ` +
5177               `but received ${argsLength} args.`;
5178 
5179             // Incomplete path operators, in particular, can result in fairly
5180             // chaotic rendering artifacts. Hence the following heuristics is
5181             // used to error, rather than just warn, once a number of invalid
5182             // path operators have been encountered (fixes bug1443140.pdf).
5183             if (
5184               this._isPathOp &&
5185               ++this._numInvalidPathOPS >
5186                 EvaluatorPreprocessor.MAX_INVALID_PATH_OPS
5187             ) {
5188               throw new FormatError(`Invalid ${partialMsg}`);
5189             }
5190             // If we receive too few arguments, it's not possible to execute
5191             // the command, hence we skip the command.
5192             warn(`Skipping ${partialMsg}`);
5193             if (args !== null) {
5194               args.length = 0;
5195             }
5196             continue;
5197           }
5198         } else if (argsLength > numArgs) {
5199           info(
5200             `Command ${cmd}: expected [0, ${numArgs}] args, ` +
5201               `but received ${argsLength} args.`
5202           );
5203         }
5204 
5205         // TODO figure out how to type-check vararg functions
5206         this.preprocessCommand(fn, args);
5207 
5208         operation.fn = fn;
5209         operation.args = args;
5210         return true;
5211       }
5212       if (obj === EOF) {
5213         return false; // no more commands
5214       }
5215       // argument
5216       if (obj !== null) {
5217         if (args === null) {
5218           args = [];
5219         }
5220         args.push(obj);
5221         if (args.length > 33) {
5222           throw new FormatError("Too many arguments");
5223         }
5224       }
5225     }
5226   }
5227 
5228   preprocessCommand(fn, args) {
5229     switch (fn | 0) {
5230       case OPS.save:
5231         this.stateManager.save();
5232         break;
5233       case OPS.restore:
5234         this.stateManager.restore();
5235         break;
5236       case OPS.transform:
5237         this.stateManager.transform(args);
5238         break;
5239     }
5240   }
5241 }
5242 
5243 export { EvaluatorPreprocessor, PartialEvaluator };
</code>

Your task:
You are a software tester at pdf.js.
1. Write exactly one javascript test `it("...", async () => {...})` block.
2. Your test must fail on the code before the patch, and pass after, hence the test will verify that the patch resolves the issue.
3. The test must be self-contained and to-the-point.
4. Use only the provided imports (respect the paths exactly how they are given) by importing dynamically for compatibility with Node.js — no new dependencies. You can use the PDF file for testing as follows:
const { getDocument } = await import('../../src/display/api.js');
const { buildGetDocumentParams } = await import('./test_utils.js');
const loadingTask = getDocument(buildGetDocumentParams('issue19800.pdf'))
5. Return only the javascript code (no comments or explanations).

Example structure:
it("should <describe behavior>", async () => {
  const { example } = await import("../../src/core/example.js");
  <initialize required variables>;
  <define expected variable>;
  <generate actual variables>;
  <compare expected with actual>;
});

