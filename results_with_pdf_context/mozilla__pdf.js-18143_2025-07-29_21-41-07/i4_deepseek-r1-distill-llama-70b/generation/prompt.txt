Before you begin:
- Keep going until the job is completely solved — don’t stop halfway.
- If you’re unsure about the behavior, reread the provided patch carefully; do not hallucinate.
- Plan your approach before writing code by reflecting on whether the test truly fails before and passes after.

Issue:
<issue>
Doesnt't render first page of PDF
[Приказ (2).pdf](https://github.com/mozilla/pdf.js/files/15398373/2.pdf)

Configuration:
Chrome 124.0.6367.202 
Windows 10 Pro 19045.4046
4-0-267 but repeats on demo too
NO

Steps to reproduce the problem:
1. Open attached file

What is the expected behavior? - First page rendered

</issue>

PDF File:
<pdf>
issue18138.pdf
</pdf>

Patch:
<patch>
diff --git a/src/core/document.js b/src/core/document.js
--- a/src/core/document.js
+++ b/src/core/document.js
@@ -1576,7 +1576,10 @@ class PDFDocument {
         if (type instanceof Ref) {
           type = await xref.fetchAsync(type);
         }
-        if (isName(type, "Page") || (!obj.has("Type") && !obj.has("Kids"))) {
+        if (
+          isName(type, "Page") ||
+          (!obj.has("Type") && !obj.has("Kids") && obj.has("Contents"))
+        ) {
           if (!catalog.pageKidsCountCache.has(ref)) {
             catalog.pageKidsCountCache.put(ref, 1); // Cache the Page reference.
           }


</patch>

Imports:
<imports>
Available Packages
Dev Dependencies:
- @babel/core: ^7.24.5
- @babel/preset-env: ^7.24.5
- @babel/runtime: ^7.24.5
- @fluent/bundle: ^0.18.0
- @fluent/dom: ^0.9.0
- @jazzer.js/core: ^2.1.0
- autoprefixer: ^10.4.19
- babel-loader: ^9.1.3
- caniuse-lite: ^1.0.30001618
- canvas: ^2.11.2
- core-js: ^3.37.1
- cross-env: ^7.0.3
- eslint: ^8.57.0
- eslint-config-prettier: ^9.1.0
- eslint-plugin-fetch-options: ^0.0.5
- eslint-plugin-html: ^8.1.1
- eslint-plugin-import: ^2.29.1
- eslint-plugin-jasmine: ^4.1.3
- eslint-plugin-json: ^3.1.0
- eslint-plugin-mozilla: ^3.7.3
- eslint-plugin-no-unsanitized: ^4.0.2
- eslint-plugin-prettier: ^5.1.3
- eslint-plugin-sort-exports: ^0.9.1
- eslint-plugin-unicorn: ^53.0.0
- globals: ^15.2.0
- gulp: ^4.0.2
- gulp-cli: ^3.0.0
- gulp-postcss: ^10.0.0
- gulp-rename: ^2.0.0
- gulp-replace: ^1.1.4
- gulp-zip: ^6.0.0
- jasmine: ^5.1.0
- jsdoc: ^4.0.3
- jstransformer-markdown-it: ^3.0.0
- merge-stream: ^2.0.0
- path2d: ^0.2.0
- pngjs: ^7.0.0
- postcss: ^8.4.38
- postcss-dark-theme-class: ^1.3.0
- postcss-dir-pseudo-class: ^8.0.1
- postcss-discard-comments: ^7.0.0
- postcss-nesting: ^12.1.4
- prettier: ^3.2.5
- puppeteer: ^22.9.0
- streamqueue: ^1.1.2
- stylelint: ^16.5.0
- stylelint-prettier: ^5.0.0
- terser-webpack-plugin: ^5.3.10
- tsc-alias: ^1.8.10
- ttest: ^4.0.0
- typescript: ^5.4.5
- typogr: ^0.6.8
- vinyl: ^3.0.0
- webpack: ^5.91.0
- webpack-stream: ^7.0.0
- wintersmith: ^2.5.0
- yargs: ^17.7.2

Engines:
- node: >=18

Available Relative Imports:
- `../../src/core/annotation.js`: Annotation, AnnotationBorderStyle, AnnotationFactory, MarkupAnnotation, getQuadPoints
- `../../src/core/bidi.js`: bidi
- `../../src/core/cff_parser.js`: CFFCharset, CFFCompiler, CFFFDSelect, CFFParser, CFFStrings
- `../../src/core/cmap.js`: CMap, CMapFactory, IdentityCMap
- `../../src/core/colorspace.js`: ColorSpace
- `../../src/core/core_utils.js`: arrayBuffersToBytes, encodeToXmlString, escapePDFName, escapeString, getInheritableProperty, getSizeInBytes, isAscii, isWhiteSpace, log2, numberToString, parseXFAPath, recoverJsURL, stringToUTF16HexString, stringToUTF16String, toRomanNumerals, validateCSSFont
- `../../src/core/crypto.js`: AES128Cipher, AES256Cipher, ARCFourCipher, CipherTransformFactory, PDF17, PDF20, calculateMD5, calculateSHA256, calculateSHA384, calculateSHA512
- `../../src/core/default_appearance.js`: createDefaultAppearance, parseAppearanceStream, parseDefaultAppearance
- `../../src/core/document.js`: PDFDocument, Page
- `../../src/core/encodings.js`: getEncoding
- `../../src/core/evaluator.js`: PartialEvaluator
- `../../src/core/flate_stream.js`: FlateStream
- `../../src/core/font_substitutions.js`: getFontSubstitution
- `../../src/core/fonts_utils.js`: SEAC_ANALYSIS_ENABLED
- `../../src/core/function.js`: PDFFunctionFactory, PostScriptCompiler, PostScriptEvaluator
- `../../src/core/glyphlist.js`: getDingbatsGlyphsUnicode, getGlyphsUnicode
- `../../src/core/image_utils.js`: GlobalImageCache, LocalColorSpaceCache
- `../../src/core/jbig2.js`: Jbig2Error, Jbig2Image
- `../../src/core/jpg.js`: JpegError, JpegImage
- `../../src/core/jpx.js`: JpxError, JpxImage
- `../../src/core/metadata_parser.js`: MetadataParser
- `../../src/core/operator_list.js`: OperatorList
- `../../src/core/parser.js`: Lexer, Linearization, Parser
- `../../src/core/predictor_stream.js`: PredictorStream
- `../../src/core/primitives.js`: Cmd, Dict, EOF, Name, Ref, RefSet, RefSetCache, isCmd, isDict, isName, isRefsEqual
- `../../src/core/ps_parser.js`: PostScriptLexer, PostScriptParser
- `../../src/core/stream.js`: NullStream, Stream, StringStream
- `../../src/core/type1_parser.js`: Type1Parser
- `../../src/core/unicode.js`: getCharUnicodeCategory, getUnicodeForGlyph, getUnicodeRangeFor, mapSpecialUnicodeValues
- `../../src/core/worker.js`: WorkerMessageHandler, WorkerTask
- `../../src/core/writer.js`: incrementalUpdate, writeDict
- `../../src/core/xfa/bind.js`: Binder
- `../../src/core/xfa/data.js`: DataHandler
- `../../src/core/xfa/factory.js`: XFAFactory
- `../../src/core/xfa/formcalc_lexer.js`: Lexer, TOKEN, Token
- `../../src/core/xfa/formcalc_parser.js`: Errors, Parser
- `../../src/core/xfa/parser.js`: XFAParser
- `../../src/core/xfa/som.js`: searchNode
- `../../src/core/xfa/symbol_utils.js`: $dump, $getChildren, $getChildrenByClass, $getChildrenByName, $text, $uid
- `../../src/core/xml_parser.js`: SimpleXMLParser, XMLParserBase
- `../../src/display/annotation_layer.js`: AnnotationLayer
- `../../src/display/annotation_storage.js`: AnnotationStorage
- `../../src/display/api.js`: DefaultCMapReaderFactory, DefaultCanvasFactory, DefaultStandardFontDataFactory, LoopbackPort, PDFDataRangeTransport, PDFDocumentLoadingTask, PDFDocumentProxy, PDFPageProxy, PDFWorker, PDFWorkerUtil, RenderTask, build, getDocument, version
- `../../src/display/display_utils.js`: DOMCanvasFactory, DOMSVGFactory, PDFDateString, PageViewport, PixelsPerInch, RenderingCancelledException, StatTimer, fetchData, getFilenameFromUrl, getPdfFilenameFromUrl, getXfaPageViewport, isDataScheme, isPdfFile, isValidFetchUrl, noContextMenu, setLayerDimensions
- `../../src/display/draw_layer.js`: DrawLayer
- `../../src/display/editor/annotation_editor_layer.js`: AnnotationEditorLayer
- `../../src/display/editor/color_picker.js`: ColorPicker
- `../../src/display/editor/outliner.js`: Outliner
- `../../src/display/editor/tools.js`: AnnotationEditorUIManager, CommandManager
- `../../src/display/fetch_stream.js`: PDFFetchStream
- `../../src/display/metadata.js`: Metadata
- `../../src/display/network.js`: PDFNetworkStream
- `../../src/display/network_utils.js`: createResponseStatusError, extractFilenameFromHeader, validateRangeRequestCapabilities, validateResponseStatus
- `../../src/display/node_stream.js`: PDFNodeStream
- `../../src/display/node_utils.js`: NodePackages
- `../../src/display/text_layer.js`: TextLayer, renderTextLayer, updateTextLayer
- `../../src/display/worker_options.js`: GlobalWorkerOptions
- `../../src/display/xfa_layer.js`: XfaLayer
- `../../src/shared/message_handler.js`: MessageHandler
- `../../src/shared/murmurhash3.js`: MurmurHash3_64
- `../../src/shared/util.js`: AbortException, AnnotationBorderStyleType, AnnotationEditorParamsType, AnnotationEditorType, AnnotationFieldFlag, AnnotationFlag, AnnotationMode, AnnotationType, BaseException, CMapCompressionType, FeatureTest, FormatError, ImageKind, InvalidPDFException, MissingPDFException, OPS, PasswordException, PasswordResponses, PermissionFlag, RenderingIntentFlag, UnexpectedResponseException, UnknownErrorException, Util, VerbosityLevel, assert, bytesToString, createValidAbsoluteUrl, getModificationDate, getVerbosityLevel, isNodeJS, normalizeUnicode, objectSize, setVerbosityLevel, shadow, string32, stringToBytes, stringToPDFString, stringToUTF8String
- `../../web/annotation_layer_builder.js`: AnnotationLayerBuilder
- `../../web/app_options.js`: AppOptions, OptionKind
- `../../web/download_manager.js`: DownloadManager
- `../../web/event_utils.js`: EventBus, WaitOnType, waitOnEventOrTimeout
- `../../web/genericl10n.js`: GenericL10n
- `../../web/pdf_find_controller.js`: FindState, PDFFindController
- `../../web/pdf_find_utils.js`: CharacterType, getCharacterType
- `../../web/pdf_history.js`: PDFHistory, isDestArraysEqual, isDestHashesEqual
- `../../web/pdf_link_service.js`: LinkTarget, PDFLinkService, SimpleLinkService
- `../../web/pdf_page_view.js`: PDFPageView
- `../../web/pdf_scripting_manager.component.js`: PDFScriptingManager
- `../../web/pdf_single_page_viewer.js`: PDFSinglePageViewer
- `../../web/pdf_viewer.js`: PDFPageViewBuffer, PDFViewer
- `../../web/struct_tree_layer_builder.js`: StructTreeLayerBuilder
- `../../web/text_layer_builder.js`: TextLayerBuilder
- `../../web/ui_utils.js`: AutoPrintRegExp, ProgressBar, RenderingStates, ScrollMode, SpreadMode, backtrackBeforeAllVisibleElements, binarySearchFirstItem, getPageSizeInches, getVisibleElements, isPortraitOrientation, isValidRotation, parseQueryString, removeNullCharacters
- `../../web/xfa_layer_builder.js`: XfaLayerBuilder
- `./test_utils.js`: CMAP_URL, DefaultFileReaderFactory, STANDARD_FONT_DATA_URL, TEST_PDFS_PATH, XRefMock, buildGetDocumentParams, createIdFactory, createTemporaryNodeServer
- `./testreporter.js`: TestReporter
</imports>

Code:
<code>
File:
src/core/document.js
1 /* Copyright 2012 Mozilla Foundation
2  *
3  * Licensed under the Apache License, Version 2.0 (the "License");
4  * you may not use this file except in compliance with the License.
5  * You may obtain a copy of the License at
6  *
7  *     http://www.apache.org/licenses/LICENSE-2.0
8  *
9  * Unless required by applicable law or agreed to in writing, software
10  * distributed under the License is distributed on an "AS IS" BASIS,
11  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
12  * See the License for the specific language governing permissions and
13  * limitations under the License.
14  */
15 
16 import {
17   AnnotationEditorPrefix,
18   assert,
19   FormatError,
20   info,
21   InvalidPDFException,
22   isArrayEqual,
23   PageActionEventType,
24   RenderingIntentFlag,
25   shadow,
26   stringToBytes,
27   stringToPDFString,
28   stringToUTF8String,
29   unreachable,
30   Util,
31   warn,
32 } from "../shared/util.js";
33 import {
34   AnnotationFactory,
35   PopupAnnotation,
36   WidgetAnnotation,
37 } from "./annotation.js";
38 import {
39   collectActions,
40   getInheritableProperty,
41   getNewAnnotationsMap,
42   isWhiteSpace,
43   lookupNormalRect,
44   MissingDataException,
45   PDF_VERSION_REGEXP,
46   validateCSSFont,
47   XRefEntryException,
48   XRefParseException,
49 } from "./core_utils.js";
50 import {
51   Dict,
52   isName,
53   isRefsEqual,
54   Name,
55   Ref,
56   RefSet,
57   RefSetCache,
58 } from "./primitives.js";
59 import { getXfaFontDict, getXfaFontName } from "./xfa_fonts.js";
60 import { BaseStream } from "./base_stream.js";
61 import { calculateMD5 } from "./crypto.js";
62 import { Catalog } from "./catalog.js";
63 import { clearGlobalCaches } from "./cleanup_helper.js";
64 import { DatasetReader } from "./dataset_reader.js";
65 import { Linearization } from "./parser.js";
66 import { NullStream } from "./stream.js";
67 import { ObjectLoader } from "./object_loader.js";
68 import { OperatorList } from "./operator_list.js";
69 import { PartialEvaluator } from "./evaluator.js";
70 import { StreamsSequenceStream } from "./decode_stream.js";
71 import { StructTreePage } from "./struct_tree.js";
72 import { writeObject } from "./writer.js";
73 import { XFAFactory } from "./xfa/factory.js";
74 import { XRef } from "./xref.js";
75 
76 const DEFAULT_USER_UNIT = 1.0;
77 const LETTER_SIZE_MEDIABOX = [0, 0, 612, 792];
78 
79 class Page {
80   constructor({
81     pdfManager,
82     xref,
83     pageIndex,
84     pageDict,
85     ref,
86     globalIdFactory,
87     fontCache,
88     builtInCMapCache,
89     standardFontDataCache,
90     globalImageCache,
91     systemFontCache,
92     nonBlendModesSet,
93     xfaFactory,
94   }) {
95     this.pdfManager = pdfManager;
96     this.pageIndex = pageIndex;
97     this.pageDict = pageDict;
98     this.xref = xref;
99     this.ref = ref;
100     this.fontCache = fontCache;
101     this.builtInCMapCache = builtInCMapCache;
102     this.standardFontDataCache = standardFontDataCache;
103     this.globalImageCache = globalImageCache;
104     this.systemFontCache = systemFontCache;
105     this.nonBlendModesSet = nonBlendModesSet;
106     this.evaluatorOptions = pdfManager.evaluatorOptions;
107     this.resourcesPromise = null;
108     this.xfaFactory = xfaFactory;
109 
110     const idCounters = {
111       obj: 0,
112     };
113     this._localIdFactory = class extends globalIdFactory {
114       static createObjId() {
115         return `p${pageIndex}_${++idCounters.obj}`;
116       }
117 
118       static getPageObjId() {
119         return `p${ref.toString()}`;
120       }
121     };
122   }
123 
124   /**
125    * @private
126    */
127   _getInheritableProperty(key, getArray = false) {
128     const value = getInheritableProperty({
129       dict: this.pageDict,
130       key,
131       getArray,
132       stopWhenFound: false,
133     });
134     if (!Array.isArray(value)) {
135       return value;
136     }
137     if (value.length === 1 || !(value[0] instanceof Dict)) {
138       return value[0];
139     }
140     return Dict.merge({ xref: this.xref, dictArray: value });
141   }
142 
143   get content() {
144     return this.pageDict.getArray("Contents");
145   }
146 
147   get resources() {
148     // For robustness: The spec states that a \Resources entry has to be
149     // present, but can be empty. Some documents still omit it; in this case
150     // we return an empty dictionary.
151     const resources = this._getInheritableProperty("Resources");
152 
153     return shadow(
154       this,
155       "resources",
156       resources instanceof Dict ? resources : Dict.empty
157     );
158   }
159 
160   _getBoundingBox(name) {
161     if (this.xfaData) {
162       return this.xfaData.bbox;
163     }
164     const box = lookupNormalRect(
165       this._getInheritableProperty(name, /* getArray = */ true),
166       null
167     );
168 
169     if (box) {
170       if (box[2] - box[0] > 0 && box[3] - box[1] > 0) {
171         return box;
172       }
173       warn(`Empty, or invalid, /${name} entry.`);
174     }
175     return null;
176   }
177 
178   get mediaBox() {
179     // Reset invalid media box to letter size.
180     return shadow(
181       this,
182       "mediaBox",
183       this._getBoundingBox("MediaBox") || LETTER_SIZE_MEDIABOX
184     );
185   }
186 
187   get cropBox() {
188     // Reset invalid crop box to media box.
189     return shadow(
190       this,
191       "cropBox",
192       this._getBoundingBox("CropBox") || this.mediaBox
193     );
194   }
195 
196   get userUnit() {
197     let obj = this.pageDict.get("UserUnit");
198     if (typeof obj !== "number" || obj <= 0) {
199       obj = DEFAULT_USER_UNIT;
200     }
201     return shadow(this, "userUnit", obj);
202   }
203 
204   get view() {
205     // From the spec, 6th ed., p.963:
206     // "The crop, bleed, trim, and art boxes should not ordinarily
207     // extend beyond the boundaries of the media box. If they do, they are
208     // effectively reduced to their intersection with the media box."
209     const { cropBox, mediaBox } = this;
210 
211     if (cropBox !== mediaBox && !isArrayEqual(cropBox, mediaBox)) {
212       const box = Util.intersect(cropBox, mediaBox);
213       if (box && box[2] - box[0] > 0 && box[3] - box[1] > 0) {
214         return shadow(this, "view", box);
215       }
216       warn("Empty /CropBox and /MediaBox intersection.");
217     }
218     return shadow(this, "view", mediaBox);
219   }
220 
221   get rotate() {
222     let rotate = this._getInheritableProperty("Rotate") || 0;
223 
224     // Normalize rotation so it's a multiple of 90 and between 0 and 270.
225     if (rotate % 90 !== 0) {
226       rotate = 0;
227     } else if (rotate >= 360) {
228       rotate %= 360;
229     } else if (rotate < 0) {
230       // The spec doesn't cover negatives. Assume it's counterclockwise
231       // rotation. The following is the other implementation of modulo.
232       rotate = ((rotate % 360) + 360) % 360;
233     }
234     return shadow(this, "rotate", rotate);
235   }
236 
237   /**
238    * @private
239    */
240   _onSubStreamError(reason, objId) {
241     if (this.evaluatorOptions.ignoreErrors) {
242       warn(`getContentStream - ignoring sub-stream (${objId}): "${reason}".`);
243       return;
244     }
245     throw reason;
246   }
247 
248   /**
249    * @returns {Promise<BaseStream>}
250    */
251   getContentStream() {
252     return this.pdfManager.ensure(this, "content").then(content => {
253       if (content instanceof BaseStream) {
254         return content;
255       }
256       if (Array.isArray(content)) {
257         return new StreamsSequenceStream(
258           content,
259           this._onSubStreamError.bind(this)
260         );
261       }
262       // Replace non-existent page content with empty content.
263       return new NullStream();
264     });
265   }
266 
267   get xfaData() {
268     return shadow(
269       this,
270       "xfaData",
271       this.xfaFactory
272         ? { bbox: this.xfaFactory.getBoundingBox(this.pageIndex) }
273         : null
274     );
275   }
276 
277   #replaceIdByRef(annotations, deletedAnnotations, existingAnnotations) {
278     for (const annotation of annotations) {
279       if (annotation.id) {
280         const ref = Ref.fromString(annotation.id);
281         if (!ref) {
282           warn(`A non-linked annotation cannot be modified: ${annotation.id}`);
283           continue;
284         }
285         if (annotation.deleted) {
286           deletedAnnotations.put(ref, ref);
287           continue;
288         }
289         existingAnnotations?.put(ref);
290         annotation.ref = ref;
291         delete annotation.id;
292       }
293     }
294   }
295 
296   async saveNewAnnotations(handler, task, annotations, imagePromises) {
297     if (this.xfaFactory) {
298       throw new Error("XFA: Cannot save new annotations.");
299     }
300 
301     const partialEvaluator = new PartialEvaluator({
302       xref: this.xref,
303       handler,
304       pageIndex: this.pageIndex,
305       idFactory: this._localIdFactory,
306       fontCache: this.fontCache,
307       builtInCMapCache: this.builtInCMapCache,
308       standardFontDataCache: this.standardFontDataCache,
309       globalImageCache: this.globalImageCache,
310       systemFontCache: this.systemFontCache,
311       options: this.evaluatorOptions,
312     });
313 
314     const deletedAnnotations = new RefSetCache();
315     const existingAnnotations = new RefSet();
316     this.#replaceIdByRef(annotations, deletedAnnotations, existingAnnotations);
317 
318     const pageDict = this.pageDict;
319     const annotationsArray = this.annotations.filter(
320       a => !(a instanceof Ref && deletedAnnotations.has(a))
321     );
322     const newData = await AnnotationFactory.saveNewAnnotations(
323       partialEvaluator,
324       task,
325       annotations,
326       imagePromises
327     );
328 
329     for (const { ref } of newData.annotations) {
330       // Don't add an existing annotation ref to the annotations array.
331       if (ref instanceof Ref && !existingAnnotations.has(ref)) {
332         annotationsArray.push(ref);
333       }
334     }
335 
336     const savedDict = pageDict.get("Annots");
337     pageDict.set("Annots", annotationsArray);
338     const buffer = [];
339     await writeObject(this.ref, pageDict, buffer, this.xref);
340     if (savedDict) {
341       pageDict.set("Annots", savedDict);
342     }
343 
344     const objects = newData.dependencies;
345     objects.push(
346       { ref: this.ref, data: buffer.join("") },
347       ...newData.annotations
348     );
349     for (const deletedRef of deletedAnnotations) {
350       objects.push({ ref: deletedRef, data: null });
351     }
352 
353     return objects;
354   }
355 
356   save(handler, task, annotationStorage) {
357     const partialEvaluator = new PartialEvaluator({
358       xref: this.xref,
359       handler,
360       pageIndex: this.pageIndex,
361       idFactory: this._localIdFactory,
362       fontCache: this.fontCache,
363       builtInCMapCache: this.builtInCMapCache,
364       standardFontDataCache: this.standardFontDataCache,
365       globalImageCache: this.globalImageCache,
366       systemFontCache: this.systemFontCache,
367       options: this.evaluatorOptions,
368     });
369 
370     // Fetch the page's annotations and save the content
371     // in case of interactive form fields.
372     return this._parsedAnnotations.then(function (annotations) {
373       const newRefsPromises = [];
374       for (const annotation of annotations) {
375         if (!annotation.mustBePrinted(annotationStorage)) {
376           continue;
377         }
378         newRefsPromises.push(
379           annotation
380             .save(partialEvaluator, task, annotationStorage)
381             .catch(function (reason) {
382               warn(
383                 "save - ignoring annotation data during " +
384                   `"${task.name}" task: "${reason}".`
385               );
386               return null;
387             })
388         );
389       }
390 
391       return Promise.all(newRefsPromises).then(function (newRefs) {
392         return newRefs.filter(newRef => !!newRef);
393       });
394     });
395   }
396 
397   loadResources(keys) {
398     // TODO: add async `_getInheritableProperty` and remove this.
399     this.resourcesPromise ||= this.pdfManager.ensure(this, "resources");
400 
401     return this.resourcesPromise.then(() => {
402       const objectLoader = new ObjectLoader(this.resources, keys, this.xref);
403       return objectLoader.load();
404     });
405   }
406 
407   getOperatorList({
408     handler,
409     sink,
410     task,
411     intent,
412     cacheKey,
413     annotationStorage = null,
414   }) {
415     const contentStreamPromise = this.getContentStream();
416     const resourcesPromise = this.loadResources([
417       "ColorSpace",
418       "ExtGState",
419       "Font",
420       "Pattern",
421       "Properties",
422       "Shading",
423       "XObject",
424     ]);
425 
426     const partialEvaluator = new PartialEvaluator({
427       xref: this.xref,
428       handler,
429       pageIndex: this.pageIndex,
430       idFactory: this._localIdFactory,
431       fontCache: this.fontCache,
432       builtInCMapCache: this.builtInCMapCache,
433       standardFontDataCache: this.standardFontDataCache,
434       globalImageCache: this.globalImageCache,
435       systemFontCache: this.systemFontCache,
436       options: this.evaluatorOptions,
437     });
438 
439     const newAnnotationsByPage = !this.xfaFactory
440       ? getNewAnnotationsMap(annotationStorage)
441       : null;
442     let deletedAnnotations = null;
443 
444     let newAnnotationsPromise = Promise.resolve(null);
445     if (newAnnotationsByPage) {
446       const newAnnotations = newAnnotationsByPage.get(this.pageIndex);
447       if (newAnnotations) {
448         const annotationGlobalsPromise =
449           this.pdfManager.ensureDoc("annotationGlobals");
450         let imagePromises;
451 
452         // An annotation can contain a reference to a bitmap, but this bitmap
453         // is defined in another annotation. So we need to find this annotation
454         // and generate the bitmap.
455         const missingBitmaps = new Set();
456         for (const { bitmapId, bitmap } of newAnnotations) {
457           if (bitmapId && !bitmap && !missingBitmaps.has(bitmapId)) {
458             missingBitmaps.add(bitmapId);
459           }
460         }
461 
462         const { isOffscreenCanvasSupported } = this.evaluatorOptions;
463         if (missingBitmaps.size > 0) {
464           const annotationWithBitmaps = newAnnotations.slice();
465           for (const [key, annotation] of annotationStorage) {
466             if (!key.startsWith(AnnotationEditorPrefix)) {
467               continue;
468             }
469             if (annotation.bitmap && missingBitmaps.has(annotation.bitmapId)) {
470               annotationWithBitmaps.push(annotation);
471             }
472           }
473           // The array annotationWithBitmaps cannot be empty: the check above
474           // makes sure to have at least one annotation containing the bitmap.
475           imagePromises = AnnotationFactory.generateImages(
476             annotationWithBitmaps,
477             this.xref,
478             isOffscreenCanvasSupported
479           );
480         } else {
481           imagePromises = AnnotationFactory.generateImages(
482             newAnnotations,
483             this.xref,
484             isOffscreenCanvasSupported
485           );
486         }
487 
488         deletedAnnotations = new RefSet();
489         this.#replaceIdByRef(newAnnotations, deletedAnnotations, null);
490 
491         newAnnotationsPromise = annotationGlobalsPromise.then(
492           annotationGlobals => {
493             if (!annotationGlobals) {
494               return null;
495             }
496 
497             return AnnotationFactory.printNewAnnotations(
498               annotationGlobals,
499               partialEvaluator,
500               task,
501               newAnnotations,
502               imagePromises
503             );
504           }
505         );
506       }
507     }
508     const dataPromises = Promise.all([contentStreamPromise, resourcesPromise]);
509     const pageListPromise = dataPromises.then(([contentStream]) => {
510       const opList = new OperatorList(intent, sink);
511 
512       handler.send("StartRenderPage", {
513         transparency: partialEvaluator.hasBlendModes(
514           this.resources,
515           this.nonBlendModesSet
516         ),
517         pageIndex: this.pageIndex,
518         cacheKey,
519       });
520 
521       return partialEvaluator
522         .getOperatorList({
523           stream: contentStream,
524           task,
525           resources: this.resources,
526           operatorList: opList,
527         })
528         .then(function () {
529           return opList;
530         });
531     });
532 
533     // Fetch the page's annotations and add their operator lists to the
534     // page's operator list to render them.
535     return Promise.all([
536       pageListPromise,
537       this._parsedAnnotations,
538       newAnnotationsPromise,
539     ]).then(function ([pageOpList, annotations, newAnnotations]) {
540       if (newAnnotations) {
541         // Some annotations can already exist (if it has the refToReplace
542         // property). In this case, we replace the old annotation by the new
543         // one.
544         annotations = annotations.filter(
545           a => !(a.ref && deletedAnnotations.has(a.ref))
546         );
547         for (let i = 0, ii = newAnnotations.length; i < ii; i++) {
548           const newAnnotation = newAnnotations[i];
549           if (newAnnotation.refToReplace) {
550             const j = annotations.findIndex(
551               a => a.ref && isRefsEqual(a.ref, newAnnotation.refToReplace)
552             );
553             if (j >= 0) {
554               annotations.splice(j, 1, newAnnotation);
555               newAnnotations.splice(i--, 1);
556               ii--;
557             }
558           }
559         }
560         annotations = annotations.concat(newAnnotations);
561       }
562       if (
563         annotations.length === 0 ||
564         intent & RenderingIntentFlag.ANNOTATIONS_DISABLE
565       ) {
566         pageOpList.flush(/* lastChunk = */ true);
567         return { length: pageOpList.totalLength };
568       }
569       const renderForms = !!(intent & RenderingIntentFlag.ANNOTATIONS_FORMS),
570         intentAny = !!(intent & RenderingIntentFlag.ANY),
571         intentDisplay = !!(intent & RenderingIntentFlag.DISPLAY),
572         intentPrint = !!(intent & RenderingIntentFlag.PRINT);
573 
574       // Collect the operator list promises for the annotations. Each promise
575       // is resolved with the complete operator list for a single annotation.
576       const opListPromises = [];
577       for (const annotation of annotations) {
578         if (
579           intentAny ||
580           (intentDisplay &&
581             annotation.mustBeViewed(annotationStorage, renderForms)) ||
582           (intentPrint && annotation.mustBePrinted(annotationStorage))
583         ) {
584           opListPromises.push(
585             annotation
586               .getOperatorList(
587                 partialEvaluator,
588                 task,
589                 intent,
590                 renderForms,
591                 annotationStorage
592               )
593               .catch(function (reason) {
594                 warn(
595                   "getOperatorList - ignoring annotation data during " +
596                     `"${task.name}" task: "${reason}".`
597                 );
598                 return {
599                   opList: null,
600                   separateForm: false,
601                   separateCanvas: false,
602                 };
603               })
604           );
605         }
606       }
607 
608       return Promise.all(opListPromises).then(function (opLists) {
609         let form = false,
610           canvas = false;
611 
612         for (const { opList, separateForm, separateCanvas } of opLists) {
613           pageOpList.addOpList(opList);
614 
615           form ||= separateForm;
616           canvas ||= separateCanvas;
617         }
618         pageOpList.flush(
619           /* lastChunk = */ true,
620           /* separateAnnots = */ { form, canvas }
621         );
622         return { length: pageOpList.totalLength };
623       });
624     });
625   }
626 
627   async extractTextContent({
628     handler,
629     task,
630     includeMarkedContent,
631     disableNormalization,
632     sink,
633   }) {
634     const contentStreamPromise = this.getContentStream();
635     const resourcesPromise = this.loadResources([
636       "ExtGState",
637       "Font",
638       "Properties",
639       "XObject",
640     ]);
641     const langPromise = this.pdfManager.ensureCatalog("lang");
642 
643     const [contentStream, , lang] = await Promise.all([
644       contentStreamPromise,
645       resourcesPromise,
646       langPromise,
647     ]);
648     const partialEvaluator = new PartialEvaluator({
649       xref: this.xref,
650       handler,
651       pageIndex: this.pageIndex,
652       idFactory: this._localIdFactory,
653       fontCache: this.fontCache,
654       builtInCMapCache: this.builtInCMapCache,
655       standardFontDataCache: this.standardFontDataCache,
656       globalImageCache: this.globalImageCache,
657       systemFontCache: this.systemFontCache,
658       options: this.evaluatorOptions,
659     });
660 
661     return partialEvaluator.getTextContent({
662       stream: contentStream,
663       task,
664       resources: this.resources,
665       includeMarkedContent,
666       disableNormalization,
667       sink,
668       viewBox: this.view,
669       lang,
670     });
671   }
672 
673   async getStructTree() {
674     const structTreeRoot =
675       await this.pdfManager.ensureCatalog("structTreeRoot");
676     if (!structTreeRoot) {
677       return null;
678     }
679     // Ensure that the structTree will contain the page's annotations.
680     await this._parsedAnnotations;
681 
682     const structTree = await this.pdfManager.ensure(this, "_parseStructTree", [
683       structTreeRoot,
684     ]);
685     return structTree.serializable;
686   }
687 
688   /**
689    * @private
690    */
691   _parseStructTree(structTreeRoot) {
692     const tree = new StructTreePage(structTreeRoot, this.pageDict);
693     tree.parse(this.ref);
694     return tree;
695   }
696 
697   async getAnnotationsData(handler, task, intent) {
698     const annotations = await this._parsedAnnotations;
699     if (annotations.length === 0) {
700       return annotations;
701     }
702 
703     const annotationsData = [],
704       textContentPromises = [];
705     let partialEvaluator;
706 
707     const intentAny = !!(intent & RenderingIntentFlag.ANY),
708       intentDisplay = !!(intent & RenderingIntentFlag.DISPLAY),
709       intentPrint = !!(intent & RenderingIntentFlag.PRINT);
710 
711     for (const annotation of annotations) {
712       // Get the annotation even if it's hidden because
713       // JS can change its display.
714       const isVisible = intentAny || (intentDisplay && annotation.viewable);
715       if (isVisible || (intentPrint && annotation.printable)) {
716         annotationsData.push(annotation.data);
717       }
718 
719       if (annotation.hasTextContent && isVisible) {
720         partialEvaluator ||= new PartialEvaluator({
721           xref: this.xref,
722           handler,
723           pageIndex: this.pageIndex,
724           idFactory: this._localIdFactory,
725           fontCache: this.fontCache,
726           builtInCMapCache: this.builtInCMapCache,
727           standardFontDataCache: this.standardFontDataCache,
728           globalImageCache: this.globalImageCache,
729           systemFontCache: this.systemFontCache,
730           options: this.evaluatorOptions,
731         });
732 
733         textContentPromises.push(
734           annotation
735             .extractTextContent(partialEvaluator, task, [
736               -Infinity,
737               -Infinity,
738               Infinity,
739               Infinity,
740             ])
741             .catch(function (reason) {
742               warn(
743                 `getAnnotationsData - ignoring textContent during "${task.name}" task: "${reason}".`
744               );
745             })
746         );
747       }
748     }
749 
750     await Promise.all(textContentPromises);
751     return annotationsData;
752   }
753 
754   get annotations() {
755     const annots = this._getInheritableProperty("Annots");
756     return shadow(this, "annotations", Array.isArray(annots) ? annots : []);
757   }
758 
759   get _parsedAnnotations() {
760     const promise = this.pdfManager
761       .ensure(this, "annotations")
762       .then(async annots => {
763         if (annots.length === 0) {
764           return annots;
765         }
766         const annotationGlobals =
767           await this.pdfManager.ensureDoc("annotationGlobals");
768         if (!annotationGlobals) {
769           return [];
770         }
771 
772         const annotationPromises = [];
773         for (const annotationRef of annots) {
774           annotationPromises.push(
775             AnnotationFactory.create(
776               this.xref,
777               annotationRef,
778               annotationGlobals,
779               this._localIdFactory,
780               /* collectFields */ false,
781               this.ref
782             ).catch(function (reason) {
783               warn(`_parsedAnnotations: "${reason}".`);
784               return null;
785             })
786           );
787         }
788 
789         const sortedAnnotations = [];
790         let popupAnnotations, widgetAnnotations;
791         // Ensure that PopupAnnotations are handled last, since they depend on
792         // their parent Annotation in the display layer; fixes issue 11362.
793         for (const annotation of await Promise.all(annotationPromises)) {
794           if (!annotation) {
795             continue;
796           }
797           if (annotation instanceof WidgetAnnotation) {
798             (widgetAnnotations ||= []).push(annotation);
799             continue;
800           }
801           if (annotation instanceof PopupAnnotation) {
802             (popupAnnotations ||= []).push(annotation);
803             continue;
804           }
805           sortedAnnotations.push(annotation);
806         }
807         if (widgetAnnotations) {
808           sortedAnnotations.push(...widgetAnnotations);
809         }
810         if (popupAnnotations) {
811           sortedAnnotations.push(...popupAnnotations);
812         }
813 
814         return sortedAnnotations;
815       });
816 
817     return shadow(this, "_parsedAnnotations", promise);
818   }
819 
820   get jsActions() {
821     const actions = collectActions(
822       this.xref,
823       this.pageDict,
824       PageActionEventType
825     );
826     return shadow(this, "jsActions", actions);
827   }
828 }
829 
830 const PDF_HEADER_SIGNATURE = new Uint8Array([0x25, 0x50, 0x44, 0x46, 0x2d]);
831 const STARTXREF_SIGNATURE = new Uint8Array([
832   0x73, 0x74, 0x61, 0x72, 0x74, 0x78, 0x72, 0x65, 0x66,
833 ]);
834 const ENDOBJ_SIGNATURE = new Uint8Array([0x65, 0x6e, 0x64, 0x6f, 0x62, 0x6a]);
835 
836 const FINGERPRINT_FIRST_BYTES = 1024;
837 const EMPTY_FINGERPRINT =
838   "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00";
839 
840 function find(stream, signature, limit = 1024, backwards = false) {
841   if (typeof PDFJSDev === "undefined" || PDFJSDev.test("TESTING")) {
842     assert(limit > 0, 'The "limit" must be a positive integer.');
843   }
844   const signatureLength = signature.length;
845 
846   const scanBytes = stream.peekBytes(limit);
847   const scanLength = scanBytes.length - signatureLength;
848 
849   if (scanLength <= 0) {
850     return false;
851   }
852   if (backwards) {
853     const signatureEnd = signatureLength - 1;
854 
855     let pos = scanBytes.length - 1;
856     while (pos >= signatureEnd) {
857       let j = 0;
858       while (
859         j < signatureLength &&
860         scanBytes[pos - j] === signature[signatureEnd - j]
861       ) {
862         j++;
863       }
864       if (j >= signatureLength) {
865         // `signature` found.
866         stream.pos += pos - signatureEnd;
867         return true;
868       }
869       pos--;
870     }
871   } else {
872     // forwards
873     let pos = 0;
874     while (pos <= scanLength) {
875       let j = 0;
876       while (j < signatureLength && scanBytes[pos + j] === signature[j]) {
877         j++;
878       }
879       if (j >= signatureLength) {
880         // `signature` found.
881         stream.pos += pos;
882         return true;
883       }
884       pos++;
885     }
886   }
887   return false;
888 }
889 
890 /**
891  * The `PDFDocument` class holds all the (worker-thread) data of the PDF file.
892  */
893 class PDFDocument {
894   constructor(pdfManager, stream) {
895     if (typeof PDFJSDev === "undefined" || PDFJSDev.test("TESTING")) {
896       assert(
897         stream instanceof BaseStream,
898         'PDFDocument: Invalid "stream" argument.'
899       );
900     }
901     if (stream.length <= 0) {
902       throw new InvalidPDFException(
903         "The PDF file is empty, i.e. its size is zero bytes."
904       );
905     }
906 
907     this.pdfManager = pdfManager;
908     this.stream = stream;
909     this.xref = new XRef(stream, pdfManager);
910     this._pagePromises = new Map();
911     this._version = null;
912 
913     const idCounters = {
914       font: 0,
915     };
916     this._globalIdFactory = class {
917       static getDocId() {
918         return `g_${pdfManager.docId}`;
919       }
920 
921       static createFontId() {
922         return `f${++idCounters.font}`;
923       }
924 
925       static createObjId() {
926         unreachable("Abstract method `createObjId` called.");
927       }
928 
929       static getPageObjId() {
930         unreachable("Abstract method `getPageObjId` called.");
931       }
932     };
933   }
934 
935   parse(recoveryMode) {
936     this.xref.parse(recoveryMode);
937     this.catalog = new Catalog(this.pdfManager, this.xref);
938   }
939 
940   get linearization() {
941     let linearization = null;
942     try {
943       linearization = Linearization.create(this.stream);
944     } catch (err) {
945       if (err instanceof MissingDataException) {
946         throw err;
947       }
948       info(err);
949     }
950     return shadow(this, "linearization", linearization);
951   }
952 
953   get startXRef() {
954     const stream = this.stream;
955     let startXRef = 0;
956 
957     if (this.linearization) {
958       // Find the end of the first object.
959       stream.reset();
960       if (find(stream, ENDOBJ_SIGNATURE)) {
961         stream.skip(6);
962 
963         let ch = stream.peekByte();
964         while (isWhiteSpace(ch)) {
965           stream.pos++;
966           ch = stream.peekByte();
967         }
968         startXRef = stream.pos - stream.start;
969       }
970     } else {
971       // Find `startxref` by checking backwards from the end of the file.
972       const step = 1024;
973       const startXRefLength = STARTXREF_SIGNATURE.length;
974       let found = false,
975         pos = stream.end;
976 
977       while (!found && pos > 0) {
978         pos -= step - startXRefLength;
979         if (pos < 0) {
980           pos = 0;
981         }
982         stream.pos = pos;
983         found = find(stream, STARTXREF_SIGNATURE, step, true);
984       }
985 
986       if (found) {
987         stream.skip(9);
988         let ch;
989         do {
990           ch = stream.getByte();
991         } while (isWhiteSpace(ch));
992         let str = "";
993         while (ch >= /* Space = */ 0x20 && ch <= /* '9' = */ 0x39) {
994           str += String.fromCharCode(ch);
995           ch = stream.getByte();
996         }
997         startXRef = parseInt(str, 10);
998         if (isNaN(startXRef)) {
999           startXRef = 0;
1000         }
1001       }
1002     }
1003     return shadow(this, "startXRef", startXRef);
1004   }
1005 
1006   // Find the header, get the PDF format version and setup the
1007   // stream to start from the header.
1008   checkHeader() {
1009     const stream = this.stream;
1010     stream.reset();
1011 
1012     if (!find(stream, PDF_HEADER_SIGNATURE)) {
1013       // May not be a PDF file, but don't throw an error and let
1014       // parsing continue.
1015       return;
1016     }
1017     stream.moveStart();
1018 
1019     // Skip over the "%PDF-" prefix, since it was found above.
1020     stream.skip(PDF_HEADER_SIGNATURE.length);
1021     // Read the PDF format version.
1022     let version = "",
1023       ch;
1024     while (
1025       (ch = stream.getByte()) > /* Space = */ 0x20 &&
1026       version.length < /* MAX_PDF_VERSION_LENGTH = */ 7
1027     ) {
1028       version += String.fromCharCode(ch);
1029     }
1030 
1031     if (PDF_VERSION_REGEXP.test(version)) {
1032       this._version = version;
1033     } else {
1034       warn(`Invalid PDF header version: ${version}`);
1035     }
1036   }
1037 
1038   parseStartXRef() {
1039     this.xref.setStartXRef(this.startXRef);
1040   }
1041 
1042   get numPages() {
1043     let num = 0;
1044     if (this.catalog.hasActualNumPages) {
1045       num = this.catalog.numPages;
1046     } else if (this.xfaFactory) {
1047       // num is a Promise.
1048       num = this.xfaFactory.getNumPages();
1049     } else if (this.linearization) {
1050       num = this.linearization.numPages;
1051     } else {
1052       num = this.catalog.numPages;
1053     }
1054     return shadow(this, "numPages", num);
1055   }
1056 
1057   /**
1058    * @private
1059    */
1060   _hasOnlyDocumentSignatures(fields, recursionDepth = 0) {
1061     const RECURSION_LIMIT = 10;
1062 
1063     if (!Array.isArray(fields)) {
1064       return false;
1065     }
1066     return fields.every(field => {
1067       field = this.xref.fetchIfRef(field);
1068       if (!(field instanceof Dict)) {
1069         return false;
1070       }
1071       if (field.has("Kids")) {
1072         if (++recursionDepth > RECURSION_LIMIT) {
1073           warn("_hasOnlyDocumentSignatures: maximum recursion depth reached");
1074           return false;
1075         }
1076         return this._hasOnlyDocumentSignatures(
1077           field.get("Kids"),
1078           recursionDepth
1079         );
1080       }
1081       const isSignature = isName(field.get("FT"), "Sig");
1082       const rectangle = field.get("Rect");
1083       const isInvisible =
1084         Array.isArray(rectangle) && rectangle.every(value => value === 0);
1085       return isSignature && isInvisible;
1086     });
1087   }
1088 
1089   get _xfaStreams() {
1090     const acroForm = this.catalog.acroForm;
1091     if (!acroForm) {
1092       return null;
1093     }
1094 
1095     const xfa = acroForm.get("XFA");
1096     const entries = {
1097       "xdp:xdp": "",
1098       template: "",
1099       datasets: "",
1100       config: "",
1101       connectionSet: "",
1102       localeSet: "",
1103       stylesheet: "",
1104       "/xdp:xdp": "",
1105     };
1106     if (xfa instanceof BaseStream && !xfa.isEmpty) {
1107       entries["xdp:xdp"] = xfa;
1108       return entries;
1109     }
1110 
1111     if (!Array.isArray(xfa) || xfa.length === 0) {
1112       return null;
1113     }
1114 
1115     for (let i = 0, ii = xfa.length; i < ii; i += 2) {
1116       let name;
1117       if (i === 0) {
1118         name = "xdp:xdp";
1119       } else if (i === ii - 2) {
1120         name = "/xdp:xdp";
1121       } else {
1122         name = xfa[i];
1123       }
1124 
1125       if (!entries.hasOwnProperty(name)) {
1126         continue;
1127       }
1128       const data = this.xref.fetchIfRef(xfa[i + 1]);
1129       if (!(data instanceof BaseStream) || data.isEmpty) {
1130         continue;
1131       }
1132       entries[name] = data;
1133     }
1134     return entries;
1135   }
1136 
1137   get xfaDatasets() {
1138     const streams = this._xfaStreams;
1139     if (!streams) {
1140       return shadow(this, "xfaDatasets", null);
1141     }
1142     for (const key of ["datasets", "xdp:xdp"]) {
1143       const stream = streams[key];
1144       if (!stream) {
1145         continue;
1146       }
1147       try {
1148         const str = stringToUTF8String(stream.getString());
1149         const data = { [key]: str };
1150         return shadow(this, "xfaDatasets", new DatasetReader(data));
1151       } catch {
1152         warn("XFA - Invalid utf-8 string.");
1153         break;
1154       }
1155     }
1156     return shadow(this, "xfaDatasets", null);
1157   }
1158 
1159   get xfaData() {
1160     const streams = this._xfaStreams;
1161     if (!streams) {
1162       return null;
1163     }
1164     const data = Object.create(null);
1165     for (const [key, stream] of Object.entries(streams)) {
1166       if (!stream) {
1167         continue;
1168       }
1169       try {
1170         data[key] = stringToUTF8String(stream.getString());
1171       } catch {
1172         warn("XFA - Invalid utf-8 string.");
1173         return null;
1174       }
1175     }
1176     return data;
1177   }
1178 
1179   get xfaFactory() {
1180     let data;
1181     if (
1182       this.pdfManager.enableXfa &&
1183       this.catalog.needsRendering &&
1184       this.formInfo.hasXfa &&
1185       !this.formInfo.hasAcroForm
1186     ) {
1187       data = this.xfaData;
1188     }
1189     return shadow(this, "xfaFactory", data ? new XFAFactory(data) : null);
1190   }
1191 
1192   get isPureXfa() {
1193     return this.xfaFactory ? this.xfaFactory.isValid() : false;
1194   }
1195 
1196   get htmlForXfa() {
1197     return this.xfaFactory ? this.xfaFactory.getPages() : null;
1198   }
1199 
1200   async loadXfaImages() {
1201     const xfaImagesDict = await this.pdfManager.ensureCatalog("xfaImages");
1202     if (!xfaImagesDict) {
1203       return;
1204     }
1205 
1206     const keys = xfaImagesDict.getKeys();
1207     const objectLoader = new ObjectLoader(xfaImagesDict, keys, this.xref);
1208     await objectLoader.load();
1209 
1210     const xfaImages = new Map();
1211     for (const key of keys) {
1212       const stream = xfaImagesDict.get(key);
1213       if (stream instanceof BaseStream) {
1214         xfaImages.set(key, stream.getBytes());
1215       }
1216     }
1217 
1218     this.xfaFactory.setImages(xfaImages);
1219   }
1220 
1221   async loadXfaFonts(handler, task) {
1222     const acroForm = await this.pdfManager.ensureCatalog("acroForm");
1223     if (!acroForm) {
1224       return;
1225     }
1226     const resources = await acroForm.getAsync("DR");
1227     if (!(resources instanceof Dict)) {
1228       return;
1229     }
1230     const objectLoader = new ObjectLoader(resources, ["Font"], this.xref);
1231     await objectLoader.load();
1232 
1233     const fontRes = resources.get("Font");
1234     if (!(fontRes instanceof Dict)) {
1235       return;
1236     }
1237 
1238     const options = Object.assign(
1239       Object.create(null),
1240       this.pdfManager.evaluatorOptions
1241     );
1242     options.useSystemFonts = false;
1243 
1244     const partialEvaluator = new PartialEvaluator({
1245       xref: this.xref,
1246       handler,
1247       pageIndex: -1,
1248       idFactory: this._globalIdFactory,
1249       fontCache: this.catalog.fontCache,
1250       builtInCMapCache: this.catalog.builtInCMapCache,
1251       standardFontDataCache: this.catalog.standardFontDataCache,
1252       options,
1253     });
1254     const operatorList = new OperatorList();
1255     const pdfFonts = [];
1256     const initialState = {
1257       get font() {
1258         return pdfFonts.at(-1);
1259       },
1260       set font(font) {
1261         pdfFonts.push(font);
1262       },
1263       clone() {
1264         return this;
1265       },
1266     };
1267 
1268     const fonts = new Map();
1269     fontRes.forEach((fontName, font) => {
1270       fonts.set(fontName, font);
1271     });
1272     const promises = [];
1273 
1274     for (const [fontName, font] of fonts) {
1275       const descriptor = font.get("FontDescriptor");
1276       if (!(descriptor instanceof Dict)) {
1277         continue;
1278       }
1279       let fontFamily = descriptor.get("FontFamily");
1280       // For example, "Wingdings 3" is not a valid font name in the css specs.
1281       fontFamily = fontFamily.replaceAll(/[ ]+(\d)/g, "$1");
1282       const fontWeight = descriptor.get("FontWeight");
1283 
1284       // Angle is expressed in degrees counterclockwise in PDF
1285       // when it's clockwise in CSS
1286       // (see https://drafts.csswg.org/css-fonts-4/#valdef-font-style-oblique-angle)
1287       const italicAngle = -descriptor.get("ItalicAngle");
1288       const cssFontInfo = { fontFamily, fontWeight, italicAngle };
1289 
1290       if (!validateCSSFont(cssFontInfo)) {
1291         continue;
1292       }
1293       promises.push(
1294         partialEvaluator
1295           .handleSetFont(
1296             resources,
1297             [Name.get(fontName), 1],
1298             /* fontRef = */ null,
1299             operatorList,
1300             task,
1301             initialState,
1302             /* fallbackFontDict = */ null,
1303             /* cssFontInfo = */ cssFontInfo
1304           )
1305           .catch(function (reason) {
1306             warn(`loadXfaFonts: "${reason}".`);
1307             return null;
1308           })
1309       );
1310     }
1311 
1312     await Promise.all(promises);
1313     const missingFonts = this.xfaFactory.setFonts(pdfFonts);
1314 
1315     if (!missingFonts) {
1316       return;
1317     }
1318 
1319     options.ignoreErrors = true;
1320     promises.length = 0;
1321     pdfFonts.length = 0;
1322 
1323     const reallyMissingFonts = new Set();
1324     for (const missing of missingFonts) {
1325       if (!getXfaFontName(`${missing}-Regular`)) {
1326         // No substitution available: we'll fallback on Myriad.
1327         reallyMissingFonts.add(missing);
1328       }
1329     }
1330 
1331     if (reallyMissingFonts.size) {
1332       missingFonts.push("PdfJS-Fallback");
1333     }
1334 
1335     for (const missing of missingFonts) {
1336       if (reallyMissingFonts.has(missing)) {
1337         continue;
1338       }
1339       for (const fontInfo of [
1340         { name: "Regular", fontWeight: 400, italicAngle: 0 },
1341         { name: "Bold", fontWeight: 700, italicAngle: 0 },
1342         { name: "Italic", fontWeight: 400, italicAngle: 12 },
1343         { name: "BoldItalic", fontWeight: 700, italicAngle: 12 },
1344       ]) {
1345         const name = `${missing}-${fontInfo.name}`;
1346         const dict = getXfaFontDict(name);
1347 
1348         promises.push(
1349           partialEvaluator
1350             .handleSetFont(
1351               resources,
1352               [Name.get(name), 1],
1353               /* fontRef = */ null,
1354               operatorList,
1355               task,
1356               initialState,
1357               /* fallbackFontDict = */ dict,
1358               /* cssFontInfo = */ {
1359                 fontFamily: missing,
1360                 fontWeight: fontInfo.fontWeight,
1361                 italicAngle: fontInfo.italicAngle,
1362               }
1363             )
1364             .catch(function (reason) {
1365               warn(`loadXfaFonts: "${reason}".`);
1366               return null;
1367             })
1368         );
1369       }
1370     }
1371 
1372     await Promise.all(promises);
1373     this.xfaFactory.appendFonts(pdfFonts, reallyMissingFonts);
1374   }
1375 
1376   async serializeXfaData(annotationStorage) {
1377     return this.xfaFactory
1378       ? this.xfaFactory.serializeData(annotationStorage)
1379       : null;
1380   }
1381 
1382   /**
1383    * The specification states in section 7.5.2 that the version from
1384    * the catalog, if present, should overwrite the version from the header.
1385    */
1386   get version() {
1387     return this.catalog.version || this._version;
1388   }
1389 
1390   get formInfo() {
1391     const formInfo = {
1392       hasFields: false,
1393       hasAcroForm: false,
1394       hasXfa: false,
1395       hasSignatures: false,
1396     };
1397     const acroForm = this.catalog.acroForm;
1398     if (!acroForm) {
1399       return shadow(this, "formInfo", formInfo);
1400     }
1401 
1402     try {
1403       const fields = acroForm.get("Fields");
1404       const hasFields = Array.isArray(fields) && fields.length > 0;
1405       formInfo.hasFields = hasFields; // Used by the `fieldObjects` getter.
1406 
1407       // The document contains XFA data if the `XFA` entry is a non-empty
1408       // array or stream.
1409       const xfa = acroForm.get("XFA");
1410       formInfo.hasXfa =
1411         (Array.isArray(xfa) && xfa.length > 0) ||
1412         (xfa instanceof BaseStream && !xfa.isEmpty);
1413 
1414       // The document contains AcroForm data if the `Fields` entry is a
1415       // non-empty array and it doesn't consist of only document signatures.
1416       // This second check is required for files that don't actually contain
1417       // AcroForm data (only XFA data), but that use the `Fields` entry to
1418       // store (invisible) document signatures. This can be detected using
1419       // the first bit of the `SigFlags` integer (see Table 219 in the
1420       // specification).
1421       const sigFlags = acroForm.get("SigFlags");
1422       const hasSignatures = !!(sigFlags & 0x1);
1423       const hasOnlyDocumentSignatures =
1424         hasSignatures && this._hasOnlyDocumentSignatures(fields);
1425       formInfo.hasAcroForm = hasFields && !hasOnlyDocumentSignatures;
1426       formInfo.hasSignatures = hasSignatures;
1427     } catch (ex) {
1428       if (ex instanceof MissingDataException) {
1429         throw ex;
1430       }
1431       warn(`Cannot fetch form information: "${ex}".`);
1432     }
1433     return shadow(this, "formInfo", formInfo);
1434   }
1435 
1436   get documentInfo() {
1437     const docInfo = {
1438       PDFFormatVersion: this.version,
1439       Language: this.catalog.lang,
1440       EncryptFilterName: this.xref.encrypt
1441         ? this.xref.encrypt.filterName
1442         : null,
1443       IsLinearized: !!this.linearization,
1444       IsAcroFormPresent: this.formInfo.hasAcroForm,
1445       IsXFAPresent: this.formInfo.hasXfa,
1446       IsCollectionPresent: !!this.catalog.collection,
1447       IsSignaturesPresent: this.formInfo.hasSignatures,
1448     };
1449 
1450     let infoDict;
1451     try {
1452       infoDict = this.xref.trailer.get("Info");
1453     } catch (err) {
1454       if (err instanceof MissingDataException) {
1455         throw err;
1456       }
1457       info("The document information dictionary is invalid.");
1458     }
1459     if (!(infoDict instanceof Dict)) {
1460       return shadow(this, "documentInfo", docInfo);
1461     }
1462 
1463     for (const key of infoDict.getKeys()) {
1464       const value = infoDict.get(key);
1465 
1466       switch (key) {
1467         case "Title":
1468         case "Author":
1469         case "Subject":
1470         case "Keywords":
1471         case "Creator":
1472         case "Producer":
1473         case "CreationDate":
1474         case "ModDate":
1475           if (typeof value === "string") {
1476             docInfo[key] = stringToPDFString(value);
1477             continue;
1478           }
1479           break;
1480         case "Trapped":
1481           if (value instanceof Name) {
1482             docInfo[key] = value;
1483             continue;
1484           }
1485           break;
1486         default:
1487           // For custom values, only accept white-listed types to prevent
1488           // errors that would occur when trying to send non-serializable
1489           // objects to the main-thread (for example `Dict` or `Stream`).
1490           let customValue;
1491           switch (typeof value) {
1492             case "string":
1493               customValue = stringToPDFString(value);
1494               break;
1495             case "number":
1496             case "boolean":
1497               customValue = value;
1498               break;
1499             default:
1500               if (value instanceof Name) {
1501                 customValue = value;
1502               }
1503               break;
1504           }
1505 
1506           if (customValue === undefined) {
1507             warn(`Bad value, for custom key "${key}", in Info: ${value}.`);
1508             continue;
1509           }
1510           if (!docInfo.Custom) {
1511             docInfo.Custom = Object.create(null);
1512           }
1513           docInfo.Custom[key] = customValue;
1514           continue;
1515       }
1516       warn(`Bad value, for key "${key}", in Info: ${value}.`);
1517     }
1518     return shadow(this, "documentInfo", docInfo);
1519   }
1520 
1521   get fingerprints() {
1522     function validate(data) {
1523       return (
1524         typeof data === "string" &&
1525         data.length > 0 &&
1526         data !== EMPTY_FINGERPRINT
1527       );
1528     }
1529 
1530     function hexString(hash) {
1531       const buf = [];
1532       for (const num of hash) {
1533         const hex = num.toString(16);
1534         buf.push(hex.padStart(2, "0"));
1535       }
1536       return buf.join("");
1537     }
1538 
1539     const idArray = this.xref.trailer.get("ID");
1540     let hashOriginal, hashModified;
1541     if (Array.isArray(idArray) && validate(idArray[0])) {
1542       hashOriginal = stringToBytes(idArray[0]);
1543 
1544       if (idArray[1] !== idArray[0] && validate(idArray[1])) {
1545         hashModified = stringToBytes(idArray[1]);
1546       }
1547     } else {
1548       hashOriginal = calculateMD5(
1549         this.stream.getByteRange(0, FINGERPRINT_FIRST_BYTES),
1550         0,
1551         FINGERPRINT_FIRST_BYTES
1552       );
1553     }
1554 
1555     return shadow(this, "fingerprints", [
1556       hexString(hashOriginal),
1557       hashModified ? hexString(hashModified) : null,
1558     ]);
1559   }
1560 
1561   async _getLinearizationPage(pageIndex) {
1562     const { catalog, linearization, xref } = this;
1563     if (typeof PDFJSDev === "undefined" || PDFJSDev.test("TESTING")) {
1564       assert(
1565         linearization?.pageFirst === pageIndex,
1566         "_getLinearizationPage - invalid pageIndex argument."
1567       );
1568     }
1569 
1570     const ref = Ref.get(linearization.objectNumberFirst, 0);
1571     try {
1572       const obj = await xref.fetchAsync(ref);
1573       // Ensure that the object that was found is actually a Page dictionary.
1574       if (obj instanceof Dict) {
1575         let type = obj.getRaw("Type");
1576         if (type instanceof Ref) {
1577           type = await xref.fetchAsync(type);
1578         }
1579         if (isName(type, "Page") || (!obj.has("Type") && !obj.has("Kids"))) {
1580           if (!catalog.pageKidsCountCache.has(ref)) {
1581             catalog.pageKidsCountCache.put(ref, 1); // Cache the Page reference.
1582           }
1583           // Help improve performance of the `Catalog.getPageIndex` method.
1584           if (!catalog.pageIndexCache.has(ref)) {
1585             catalog.pageIndexCache.put(ref, 0);
1586           }
1587 
1588           return [obj, ref];
1589         }
1590       }
1591       throw new FormatError(
1592         "The Linearization dictionary doesn't point to a valid Page dictionary."
1593       );
1594     } catch (reason) {
1595       warn(`_getLinearizationPage: "${reason.message}".`);
1596       return catalog.getPageDict(pageIndex);
1597     }
1598   }
1599 
1600   getPage(pageIndex) {
1601     const cachedPromise = this._pagePromises.get(pageIndex);
1602     if (cachedPromise) {
1603       return cachedPromise;
1604     }
1605     const { catalog, linearization, xfaFactory } = this;
1606 
1607     let promise;
1608     if (xfaFactory) {
1609       promise = Promise.resolve([Dict.empty, null]);
1610     } else if (linearization?.pageFirst === pageIndex) {
1611       promise = this._getLinearizationPage(pageIndex);
1612     } else {
1613       promise = catalog.getPageDict(pageIndex);
1614     }
1615     // eslint-disable-next-line arrow-body-style
1616     promise = promise.then(([pageDict, ref]) => {
1617       return new Page({
1618         pdfManager: this.pdfManager,
1619         xref: this.xref,
1620         pageIndex,
1621         pageDict,
1622         ref,
1623         globalIdFactory: this._globalIdFactory,
1624         fontCache: catalog.fontCache,
1625         builtInCMapCache: catalog.builtInCMapCache,
1626         standardFontDataCache: catalog.standardFontDataCache,
1627         globalImageCache: catalog.globalImageCache,
1628         systemFontCache: catalog.systemFontCache,
1629         nonBlendModesSet: catalog.nonBlendModesSet,
1630         xfaFactory,
1631       });
1632     });
1633 
1634     this._pagePromises.set(pageIndex, promise);
1635     return promise;
1636   }
1637 
1638   async checkFirstPage(recoveryMode = false) {
1639     if (recoveryMode) {
1640       return;
1641     }
1642     try {
1643       await this.getPage(0);
1644     } catch (reason) {
1645       if (reason instanceof XRefEntryException) {
1646         // Clear out the various caches to ensure that we haven't stored any
1647         // inconsistent and/or incorrect state, since that could easily break
1648         // subsequent `this.getPage` calls.
1649         this._pagePromises.delete(0);
1650         await this.cleanup();
1651 
1652         throw new XRefParseException();
1653       }
1654     }
1655   }
1656 
1657   async checkLastPage(recoveryMode = false) {
1658     const { catalog, pdfManager } = this;
1659 
1660     catalog.setActualNumPages(); // Ensure that it's always reset.
1661     let numPages;
1662 
1663     try {
1664       await Promise.all([
1665         pdfManager.ensureDoc("xfaFactory"),
1666         pdfManager.ensureDoc("linearization"),
1667         pdfManager.ensureCatalog("numPages"),
1668       ]);
1669 
1670       if (this.xfaFactory) {
1671         return; // The Page count is always calculated for XFA-documents.
1672       } else if (this.linearization) {
1673         numPages = this.linearization.numPages;
1674       } else {
1675         numPages = catalog.numPages;
1676       }
1677 
1678       if (!Number.isInteger(numPages)) {
1679         throw new FormatError("Page count is not an integer.");
1680       } else if (numPages <= 1) {
1681         return;
1682       }
1683       await this.getPage(numPages - 1);
1684     } catch (reason) {
1685       // Clear out the various caches to ensure that we haven't stored any
1686       // inconsistent and/or incorrect state, since that could easily break
1687       // subsequent `this.getPage` calls.
1688       this._pagePromises.delete(numPages - 1);
1689       await this.cleanup();
1690 
1691       if (reason instanceof XRefEntryException && !recoveryMode) {
1692         throw new XRefParseException();
1693       }
1694       warn(`checkLastPage - invalid /Pages tree /Count: ${numPages}.`);
1695 
1696       let pagesTree;
1697       try {
1698         pagesTree = await catalog.getAllPageDicts(recoveryMode);
1699       } catch (reasonAll) {
1700         if (reasonAll instanceof XRefEntryException && !recoveryMode) {
1701           throw new XRefParseException();
1702         }
1703         catalog.setActualNumPages(1);
1704         return;
1705       }
1706 
1707       for (const [pageIndex, [pageDict, ref]] of pagesTree) {
1708         let promise;
1709         if (pageDict instanceof Error) {
1710           promise = Promise.reject(pageDict);
1711 
1712           // Prevent "uncaught exception: Object"-messages in the console.
1713           promise.catch(() => {});
1714         } else {
1715           promise = Promise.resolve(
1716             new Page({
1717               pdfManager,
1718               xref: this.xref,
1719               pageIndex,
1720               pageDict,
1721               ref,
1722               globalIdFactory: this._globalIdFactory,
1723               fontCache: catalog.fontCache,
1724               builtInCMapCache: catalog.builtInCMapCache,
1725               standardFontDataCache: catalog.standardFontDataCache,
1726               globalImageCache: catalog.globalImageCache,
1727               systemFontCache: catalog.systemFontCache,
1728               nonBlendModesSet: catalog.nonBlendModesSet,
1729               xfaFactory: null,
1730             })
1731           );
1732         }
1733 
1734         this._pagePromises.set(pageIndex, promise);
1735       }
1736       catalog.setActualNumPages(pagesTree.size);
1737     }
1738   }
1739 
1740   fontFallback(id, handler) {
1741     return this.catalog.fontFallback(id, handler);
1742   }
1743 
1744   async cleanup(manuallyTriggered = false) {
1745     return this.catalog
1746       ? this.catalog.cleanup(manuallyTriggered)
1747       : clearGlobalCaches();
1748   }
1749 
1750   async #collectFieldObjects(
1751     name,
1752     fieldRef,
1753     promises,
1754     annotationGlobals,
1755     visitedRefs
1756   ) {
1757     const { xref } = this;
1758 
1759     if (!(fieldRef instanceof Ref) || visitedRefs.has(fieldRef)) {
1760       return;
1761     }
1762     visitedRefs.put(fieldRef);
1763     const field = await xref.fetchAsync(fieldRef);
1764     if (!(field instanceof Dict)) {
1765       return;
1766     }
1767     if (field.has("T")) {
1768       const partName = stringToPDFString(await field.getAsync("T"));
1769       name = name === "" ? partName : `${name}.${partName}`;
1770     } else {
1771       let obj = field;
1772       while (true) {
1773         obj = obj.getRaw("Parent");
1774         if (obj instanceof Ref) {
1775           if (visitedRefs.has(obj)) {
1776             break;
1777           }
1778           obj = await xref.fetchAsync(obj);
1779         }
1780         if (!(obj instanceof Dict)) {
1781           break;
1782         }
1783         if (obj.has("T")) {
1784           const partName = stringToPDFString(await obj.getAsync("T"));
1785           name = name === "" ? partName : `${name}.${partName}`;
1786           break;
1787         }
1788       }
1789     }
1790 
1791     if (!promises.has(name)) {
1792       promises.set(name, []);
1793     }
1794     promises.get(name).push(
1795       AnnotationFactory.create(
1796         xref,
1797         fieldRef,
1798         annotationGlobals,
1799         /* idFactory = */ null,
1800         /* collectFields */ true,
1801         /* pageRef */ null
1802       )
1803         .then(annotation => annotation?.getFieldObject())
1804         .catch(function (reason) {
1805           warn(`#collectFieldObjects: "${reason}".`);
1806           return null;
1807         })
1808     );
1809 
1810     if (!field.has("Kids")) {
1811       return;
1812     }
1813     const kids = await field.getAsync("Kids");
1814     if (Array.isArray(kids)) {
1815       for (const kid of kids) {
1816         await this.#collectFieldObjects(
1817           name,
1818           kid,
1819           promises,
1820           annotationGlobals,
1821           visitedRefs
1822         );
1823       }
1824     }
1825   }
1826 
1827   get fieldObjects() {
1828     if (!this.formInfo.hasFields) {
1829       return shadow(this, "fieldObjects", Promise.resolve(null));
1830     }
1831 
1832     const promise = Promise.all([
1833       this.pdfManager.ensureDoc("annotationGlobals"),
1834       this.pdfManager.ensureCatalog("acroForm"),
1835     ]).then(async ([annotationGlobals, acroForm]) => {
1836       if (!annotationGlobals) {
1837         return null;
1838       }
1839 
1840       const visitedRefs = new RefSet();
1841       const allFields = Object.create(null);
1842       const fieldPromises = new Map();
1843       for (const fieldRef of await acroForm.getAsync("Fields")) {
1844         await this.#collectFieldObjects(
1845           "",
1846           fieldRef,
1847           fieldPromises,
1848           annotationGlobals,
1849           visitedRefs
1850         );
1851       }
1852 
1853       const allPromises = [];
1854       for (const [name, promises] of fieldPromises) {
1855         allPromises.push(
1856           Promise.all(promises).then(fields => {
1857             fields = fields.filter(field => !!field);
1858             if (fields.length > 0) {
1859               allFields[name] = fields;
1860             }
1861           })
1862         );
1863       }
1864 
1865       await Promise.all(allPromises);
1866       return allFields;
1867     });
1868 
1869     return shadow(this, "fieldObjects", promise);
1870   }
1871 
1872   get hasJSActions() {
1873     const promise = this.pdfManager.ensureDoc("_parseHasJSActions");
1874     return shadow(this, "hasJSActions", promise);
1875   }
1876 
1877   /**
1878    * @private
1879    */
1880   async _parseHasJSActions() {
1881     const [catalogJsActions, fieldObjects] = await Promise.all([
1882       this.pdfManager.ensureCatalog("jsActions"),
1883       this.pdfManager.ensureDoc("fieldObjects"),
1884     ]);
1885 
1886     if (catalogJsActions) {
1887       return true;
1888     }
1889     if (fieldObjects) {
1890       return Object.values(fieldObjects).some(fieldObject =>
1891         fieldObject.some(object => object.actions !== null)
1892       );
1893     }
1894     return false;
1895   }
1896 
1897   get calculationOrderIds() {
1898     const acroForm = this.catalog.acroForm;
1899     if (!acroForm?.has("CO")) {
1900       return shadow(this, "calculationOrderIds", null);
1901     }
1902 
1903     const calculationOrder = acroForm.get("CO");
1904     if (!Array.isArray(calculationOrder) || calculationOrder.length === 0) {
1905       return shadow(this, "calculationOrderIds", null);
1906     }
1907 
1908     const ids = [];
1909     for (const id of calculationOrder) {
1910       if (id instanceof Ref) {
1911         ids.push(id.toString());
1912       }
1913     }
1914     if (ids.length === 0) {
1915       return shadow(this, "calculationOrderIds", null);
1916     }
1917     return shadow(this, "calculationOrderIds", ids);
1918   }
1919 
1920   get annotationGlobals() {
1921     return shadow(
1922       this,
1923       "annotationGlobals",
1924       AnnotationFactory.createGlobals(this.pdfManager)
1925     );
1926   }
1927 }
1928 
1929 export { Page, PDFDocument };
</code>

Your task:
You are a software tester at pdf.js.
1. Write exactly one javascript test `it("...", async () => {...})` block.
2. Your test must fail on the code before the patch, and pass after, hence the test will verify that the patch resolves the issue.
3. The test must be self-contained and to-the-point.
4. Use only the provided imports (respect the paths exactly how they are given) by importing dynamically for compatibility with Node.js — no new dependencies. You can use the PDF file for testing as follows:
const { getDocument } = await import('../../src/display/api.js');
const { buildGetDocumentParams } = await import('./test_utils.js');
const loadingTask = getDocument(buildGetDocumentParams('issue18138.pdf'))
5. Return only the javascript code (no comments or explanations).

Example structure:
it("should <describe behavior>", async () => {
  const { example } = await import("../../src/core/example.js");
  <initialize required variables>;
  <define expected variable>;
  <generate actual variables>;
  <compare expected with actual>;
});

