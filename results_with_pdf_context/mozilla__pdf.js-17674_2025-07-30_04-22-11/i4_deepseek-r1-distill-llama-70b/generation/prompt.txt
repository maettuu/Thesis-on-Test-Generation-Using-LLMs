Before you begin:
- Keep going until the job is completely solved — don’t stop halfway.
- If you’re unsure about the behavior, reread the provided patch carefully; do not hallucinate.
- Plan your approach before writing code by reflecting on whether the test truly fails before and passes after.

Issue:
<issue>
Some characters are not displayed / rendered.
When we create simple and complex pdfs with Oracle Outside in Technology, we get pdfs as a result where some characters will not be displayed in pdf.js. But rendering / displaying these pdfs in Adobe Acrobat Reader and other web pdf viewer works fine.

Attached you will find a simple Excel converted to pdf with the text: Das ist ein Test
The t is missing , but text layer is working.

[Mappe123.pdf](https://github.com/mozilla/pdf.js/files/14277861/Mappe123.pdf)

Configuration:
- Web browser and its version:
Microsoft Edge (Chromium) Windows Version 121.0.2277.112, Chrome (Mac OS) Version 121.0.6167.160

- Operating system and its version:
Windows 11, MacOS 14.2.1

- PDF.js version:
PDF.js: 4.1.181 and PDF.js: 4.0.379

- Is a browser extension:
no

Steps to reproduce the problem:
1. open attached pdf in pdf.js
2. compare displaying result with adobe acrobat reader (and other)

What is the expected behavior? (add screenshot)
![expecteddisplay](https://github.com/mozilla/pdf.js/assets/113769563/a51dd847-2321-40c3-95e5-1fb8a3f177b3)

What went wrong? (add screenshot)
![result](https://github.com/mozilla/pdf.js/assets/113769563/0c9e0fc4-b82c-4389-b8c0-cc02614acb02)


</issue>

PDF File:
<pdf>
issue17671.pdf
</pdf>

Patch:
<patch>
diff --git a/src/core/fonts.js b/src/core/fonts.js
--- a/src/core/fonts.js
+++ b/src/core/fonts.js
@@ -2117,6 +2117,14 @@ class Font {
         break;
       }
 
+      // If the last offset is 0 in the loca table then we can't compute the
+      // endOffset for the last glyph. So in such a case we set the endOffset
+      // to the end of the data (fixes issue #17671).
+      const last = locaEntries.at(-2);
+      if (last.offset !== 0 && last.endOffset === 0) {
+        last.endOffset = oldGlyfDataLength;
+      }
+
       const missingGlyphs = Object.create(null);
       let writeOffset = 0;
       itemEncode(locaData, 0, writeOffset);


</patch>

Imports:
<imports>
Available Packages
Dev Dependencies:
- @babel/core: ^7.23.9
- @babel/preset-env: ^7.23.9
- @babel/runtime: ^7.23.9
- @fluent/bundle: ^0.18.0
- @fluent/dom: ^0.9.0
- @jazzer.js/core: ^2.1.0
- autoprefixer: ^10.4.17
- babel-loader: ^9.1.3
- caniuse-lite: ^1.0.30001585
- canvas: ^2.11.2
- core-js: ^3.35.1
- cross-env: ^7.0.3
- eslint: ^8.56.0
- eslint-config-prettier: ^8.10.0
- eslint-plugin-fetch-options: ^0.0.5
- eslint-plugin-html: ^7.1.0
- eslint-plugin-import: ^2.29.1
- eslint-plugin-jasmine: ^4.1.3
- eslint-plugin-json: ^3.1.0
- eslint-plugin-mozilla: ^3.3.2
- eslint-plugin-no-unsanitized: ^4.0.2
- eslint-plugin-prettier: ^5.1.3
- eslint-plugin-sort-exports: ^0.9.1
- eslint-plugin-unicorn: ^51.0.1
- globals: ^14.0.0
- gulp: ^4.0.2
- gulp-cli: ^2.3.0
- gulp-postcss: ^10.0.0
- gulp-rename: ^2.0.0
- gulp-replace: ^1.1.4
- gulp-zip: ^6.0.0
- jasmine: ^5.1.0
- jsdoc: ^4.0.2
- jstransformer-markdown-it: ^3.0.0
- merge-stream: ^2.0.0
- mkdirp: ^3.0.1
- needle: ^3.3.1
- path2d-polyfill: ^2.0.1
- pngjs: ^7.0.0
- postcss: ^8.4.35
- postcss-dark-theme-class: ^1.1.0
- postcss-dir-pseudo-class: ^8.0.1
- postcss-discard-comments: ^6.0.1
- postcss-nesting: ^12.0.2
- prettier: ^3.2.5
- puppeteer: ^22.0.0
- rimraf: ^3.0.2
- streamqueue: ^1.1.2
- stylelint: ^16.2.1
- stylelint-prettier: ^5.0.0
- terser: ^5.27.0
- through2: ^4.0.2
- tsc-alias: ^1.8.8
- ttest: ^4.0.0
- typescript: ^5.3.3
- typogr: ^0.6.8
- vinyl: ^3.0.0
- webpack: ^5.90.1
- webpack-stream: ^7.0.0
- wintersmith: ^2.5.0
- yargs: ^17.7.2

Engines:
- node: >=18

Available Relative Imports:
- `../../src/core/annotation.js`: Annotation, AnnotationBorderStyle, AnnotationFactory, MarkupAnnotation, getQuadPoints
- `../../src/core/bidi.js`: bidi
- `../../src/core/cff_parser.js`: CFFCharset, CFFCompiler, CFFFDSelect, CFFParser, CFFStrings
- `../../src/core/cmap.js`: CMap, CMapFactory, IdentityCMap
- `../../src/core/colorspace.js`: ColorSpace
- `../../src/core/core_utils.js`: arrayBuffersToBytes, encodeToXmlString, escapePDFName, escapeString, getInheritableProperty, getSizeInBytes, isAscii, isWhiteSpace, log2, numberToString, parseXFAPath, recoverJsURL, stringToUTF16HexString, stringToUTF16String, toRomanNumerals, validateCSSFont
- `../../src/core/crypto.js`: AES128Cipher, AES256Cipher, ARCFourCipher, CipherTransformFactory, PDF17, PDF20, calculateMD5, calculateSHA256, calculateSHA384, calculateSHA512
- `../../src/core/default_appearance.js`: createDefaultAppearance, parseAppearanceStream, parseDefaultAppearance
- `../../src/core/document.js`: PDFDocument, Page
- `../../src/core/encodings.js`: getEncoding
- `../../src/core/evaluator.js`: PartialEvaluator
- `../../src/core/flate_stream.js`: FlateStream
- `../../src/core/font_substitutions.js`: getFontSubstitution
- `../../src/core/fonts_utils.js`: SEAC_ANALYSIS_ENABLED
- `../../src/core/function.js`: PDFFunctionFactory, PostScriptCompiler, PostScriptEvaluator
- `../../src/core/glyphlist.js`: getDingbatsGlyphsUnicode, getGlyphsUnicode
- `../../src/core/image_utils.js`: GlobalImageCache, LocalColorSpaceCache
- `../../src/core/jbig2.js`: Jbig2Image
- `../../src/core/jpg.js`: JpegImage
- `../../src/core/jpx.js`: JpxImage
- `../../src/core/metadata_parser.js`: MetadataParser
- `../../src/core/operator_list.js`: OperatorList
- `../../src/core/parser.js`: Lexer, Linearization, Parser
- `../../src/core/predictor_stream.js`: PredictorStream
- `../../src/core/primitives.js`: Cmd, Dict, EOF, Name, Ref, RefSet, RefSetCache, isCmd, isDict, isName, isRefsEqual
- `../../src/core/ps_parser.js`: PostScriptLexer, PostScriptParser
- `../../src/core/stream.js`: NullStream, Stream, StringStream
- `../../src/core/type1_parser.js`: Type1Parser
- `../../src/core/unicode.js`: getCharUnicodeCategory, getUnicodeForGlyph, getUnicodeRangeFor, mapSpecialUnicodeValues
- `../../src/core/worker.js`: WorkerMessageHandler, WorkerTask
- `../../src/core/writer.js`: incrementalUpdate, writeDict
- `../../src/core/xfa/bind.js`: Binder
- `../../src/core/xfa/data.js`: DataHandler
- `../../src/core/xfa/factory.js`: XFAFactory
- `../../src/core/xfa/formcalc_lexer.js`: Lexer, TOKEN, Token
- `../../src/core/xfa/formcalc_parser.js`: Errors, Parser
- `../../src/core/xfa/parser.js`: XFAParser
- `../../src/core/xfa/som.js`: searchNode
- `../../src/core/xfa/symbol_utils.js`: $dump, $getChildren, $getChildrenByClass, $getChildrenByName, $text, $uid
- `../../src/core/xml_parser.js`: SimpleXMLParser, XMLParserBase
- `../../src/display/annotation_layer.js`: AnnotationLayer
- `../../src/display/annotation_storage.js`: AnnotationStorage
- `../../src/display/api.js`: DefaultCMapReaderFactory, DefaultCanvasFactory, DefaultStandardFontDataFactory, LoopbackPort, PDFDataRangeTransport, PDFDocumentLoadingTask, PDFDocumentProxy, PDFPageProxy, PDFWorker, PDFWorkerUtil, RenderTask, build, getDocument, version
- `../../src/display/display_utils.js`: DOMCanvasFactory, DOMSVGFactory, PDFDateString, PageViewport, PixelsPerInch, RenderingCancelledException, StatTimer, fetchData, getFilenameFromUrl, getPdfFilenameFromUrl, getXfaPageViewport, isDataScheme, isPdfFile, isValidFetchUrl, noContextMenu, setLayerDimensions
- `../../src/display/draw_layer.js`: DrawLayer
- `../../src/display/editor/annotation_editor_layer.js`: AnnotationEditorLayer
- `../../src/display/editor/color_picker.js`: ColorPicker
- `../../src/display/editor/outliner.js`: Outliner
- `../../src/display/editor/tools.js`: AnnotationEditorUIManager, CommandManager
- `../../src/display/fetch_stream.js`: PDFFetchStream
- `../../src/display/metadata.js`: Metadata
- `../../src/display/network.js`: PDFNetworkStream
- `../../src/display/network_utils.js`: createResponseStatusError, extractFilenameFromHeader, validateRangeRequestCapabilities, validateResponseStatus
- `../../src/display/node_stream.js`: PDFNodeStream
- `../../src/display/text_layer.js`: TextLayerRenderTask, renderTextLayer, updateTextLayer
- `../../src/display/worker_options.js`: GlobalWorkerOptions
- `../../src/display/xfa_layer.js`: XfaLayer
- `../../src/shared/message_handler.js`: MessageHandler
- `../../src/shared/murmurhash3.js`: MurmurHash3_64
- `../../src/shared/util.js`: AbortException, AnnotationBorderStyleType, AnnotationEditorParamsType, AnnotationEditorType, AnnotationFieldFlag, AnnotationFlag, AnnotationMode, AnnotationType, CMapCompressionType, FeatureTest, FormatError, ImageKind, InvalidPDFException, MissingPDFException, OPS, PasswordException, PasswordResponses, PermissionFlag, PromiseCapability, RenderingIntentFlag, UnexpectedResponseException, UnknownErrorException, Util, VerbosityLevel, bytesToString, createValidAbsoluteUrl, getModificationDate, getVerbosityLevel, isNodeJS, normalizeUnicode, objectSize, setVerbosityLevel, shadow, string32, stringToBytes, stringToPDFString, stringToUTF8String
- `../../web/annotation_layer_builder.js`: AnnotationLayerBuilder
- `../../web/download_manager.js`: DownloadManager
- `../../web/event_utils.js`: EventBus, WaitOnType, waitOnEventOrTimeout
- `../../web/genericl10n.js`: GenericL10n
- `../../web/pdf_find_controller.js`: FindState, PDFFindController
- `../../web/pdf_find_utils.js`: CharacterType, getCharacterType
- `../../web/pdf_history.js`: PDFHistory, isDestArraysEqual, isDestHashesEqual
- `../../web/pdf_link_service.js`: LinkTarget, PDFLinkService, SimpleLinkService
- `../../web/pdf_page_view.js`: PDFPageView
- `../../web/pdf_scripting_manager.component.js`: PDFScriptingManager
- `../../web/pdf_single_page_viewer.js`: PDFSinglePageViewer
- `../../web/pdf_viewer.js`: PDFPageViewBuffer, PDFViewer
- `../../web/struct_tree_layer_builder.js`: StructTreeLayerBuilder
- `../../web/text_layer_builder.js`: TextLayerBuilder
- `../../web/ui_utils.js`: AutoPrintRegExp, ProgressBar, RenderingStates, ScrollMode, SpreadMode, backtrackBeforeAllVisibleElements, binarySearchFirstItem, getPageSizeInches, getVisibleElements, isPortraitOrientation, isValidRotation, parseQueryString, removeNullCharacters
- `../../web/xfa_layer_builder.js`: XfaLayerBuilder
- `./test_utils.js`: CMAP_URL, DefaultFileReaderFactory, STANDARD_FONT_DATA_URL, TEST_PDFS_PATH, XRefMock, buildGetDocumentParams, createIdFactory
- `./testreporter.js`: TestReporter
</imports>

Code:
<code>
File:
src/core/fonts.js
1 /* Copyright 2012 Mozilla Foundation
2  *
3  * Licensed under the Apache License, Version 2.0 (the "License");
4  * you may not use this file except in compliance with the License.
5  * You may obtain a copy of the License at
6  *
7  *     http://www.apache.org/licenses/LICENSE-2.0
8  *
9  * Unless required by applicable law or agreed to in writing, software
10  * distributed under the License is distributed on an "AS IS" BASIS,
11  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
12  * See the License for the specific language governing permissions and
13  * limitations under the License.
14  */
15 
16 import {
17   assert,
18   bytesToString,
19   FONT_IDENTITY_MATRIX,
20   FormatError,
21   info,
22   shadow,
23   string32,
24   warn,
25 } from "../shared/util.js";
26 import { CFFCompiler, CFFParser } from "./cff_parser.js";
27 import {
28   FontFlags,
29   MacStandardGlyphOrdering,
30   normalizeFontName,
31   recoverGlyphName,
32   SEAC_ANALYSIS_ENABLED,
33 } from "./fonts_utils.js";
34 import {
35   getCharUnicodeCategory,
36   getUnicodeForGlyph,
37   getUnicodeRangeFor,
38   mapSpecialUnicodeValues,
39 } from "./unicode.js";
40 import { getDingbatsGlyphsUnicode, getGlyphsUnicode } from "./glyphlist.js";
41 import {
42   getEncoding,
43   MacRomanEncoding,
44   StandardEncoding,
45   SymbolSetEncoding,
46   WinAnsiEncoding,
47   ZapfDingbatsEncoding,
48 } from "./encodings.js";
49 import {
50   getGlyphMapForStandardFonts,
51   getNonStdFontMap,
52   getSerifFonts,
53   getStdFontMap,
54   getSupplementalGlyphMapForArialBlack,
55   getSupplementalGlyphMapForCalibri,
56 } from "./standard_fonts.js";
57 import { IdentityToUnicodeMap, ToUnicodeMap } from "./to_unicode_map.js";
58 import { CFFFont } from "./cff_font.js";
59 import { FontRendererFactory } from "./font_renderer.js";
60 import { getFontBasicMetrics } from "./metrics.js";
61 import { GlyfTable } from "./glyf.js";
62 import { IdentityCMap } from "./cmap.js";
63 import { OpenTypeFileBuilder } from "./opentype_file_builder.js";
64 import { readUint32 } from "./core_utils.js";
65 import { Stream } from "./stream.js";
66 import { Type1Font } from "./type1_font.js";
67 
68 // Unicode Private Use Areas:
69 const PRIVATE_USE_AREAS = [
70   [0xe000, 0xf8ff], // BMP (0)
71   [0x100000, 0x10fffd], // PUP (16)
72 ];
73 
74 // PDF Glyph Space Units are one Thousandth of a TextSpace Unit
75 // except for Type 3 fonts
76 const PDF_GLYPH_SPACE_UNITS = 1000;
77 
78 const EXPORT_DATA_PROPERTIES = [
79   "ascent",
80   "bbox",
81   "black",
82   "bold",
83   "charProcOperatorList",
84   "composite",
85   "cssFontInfo",
86   "data",
87   "defaultVMetrics",
88   "defaultWidth",
89   "descent",
90   "fallbackName",
91   "fontMatrix",
92   "isInvalidPDFjsFont",
93   "isType3Font",
94   "italic",
95   "loadedName",
96   "mimetype",
97   "missingFile",
98   "name",
99   "remeasure",
100   "subtype",
101   "systemFontInfo",
102   "type",
103   "vertical",
104 ];
105 
106 const EXPORT_DATA_EXTRA_PROPERTIES = [
107   "cMap",
108   "defaultEncoding",
109   "differences",
110   "isMonospace",
111   "isSerifFont",
112   "isSymbolicFont",
113   "seacMap",
114   "toFontChar",
115   "toUnicode",
116   "vmetrics",
117   "widths",
118 ];
119 
120 function adjustWidths(properties) {
121   if (!properties.fontMatrix) {
122     return;
123   }
124   if (properties.fontMatrix[0] === FONT_IDENTITY_MATRIX[0]) {
125     return;
126   }
127   // adjusting width to fontMatrix scale
128   const scale = 0.001 / properties.fontMatrix[0];
129   const glyphsWidths = properties.widths;
130   for (const glyph in glyphsWidths) {
131     glyphsWidths[glyph] *= scale;
132   }
133   properties.defaultWidth *= scale;
134 }
135 
136 function adjustTrueTypeToUnicode(properties, isSymbolicFont, nameRecords) {
137   if (properties.isInternalFont) {
138     return;
139   }
140   if (properties.hasIncludedToUnicodeMap) {
141     return; // The font dictionary has a `ToUnicode` entry.
142   }
143   if (properties.hasEncoding) {
144     return; // The font dictionary has an `Encoding` entry.
145   }
146   if (properties.toUnicode instanceof IdentityToUnicodeMap) {
147     return;
148   }
149   if (!isSymbolicFont) {
150     return; // A non-symbolic font should default to `StandardEncoding`.
151   }
152   if (nameRecords.length === 0) {
153     return;
154   }
155 
156   // Try to infer if the fallback encoding should really be `WinAnsiEncoding`.
157   if (properties.defaultEncoding === WinAnsiEncoding) {
158     return;
159   }
160   for (const r of nameRecords) {
161     if (!isWinNameRecord(r)) {
162       return; // Not Windows, hence `WinAnsiEncoding` wouldn't make sense.
163     }
164   }
165   const encoding = WinAnsiEncoding;
166 
167   const toUnicode = [],
168     glyphsUnicodeMap = getGlyphsUnicode();
169   for (const charCode in encoding) {
170     const glyphName = encoding[charCode];
171     if (glyphName === "") {
172       continue;
173     }
174     const unicode = glyphsUnicodeMap[glyphName];
175     if (unicode === undefined) {
176       continue;
177     }
178     toUnicode[charCode] = String.fromCharCode(unicode);
179   }
180   if (toUnicode.length > 0) {
181     properties.toUnicode.amend(toUnicode);
182   }
183 }
184 
185 function adjustType1ToUnicode(properties, builtInEncoding) {
186   if (properties.isInternalFont) {
187     return;
188   }
189   if (properties.hasIncludedToUnicodeMap) {
190     return; // The font dictionary has a `ToUnicode` entry.
191   }
192   if (builtInEncoding === properties.defaultEncoding) {
193     return; // No point in trying to adjust `toUnicode` if the encodings match.
194   }
195   if (properties.toUnicode instanceof IdentityToUnicodeMap) {
196     return;
197   }
198   const toUnicode = [],
199     glyphsUnicodeMap = getGlyphsUnicode();
200   for (const charCode in builtInEncoding) {
201     if (properties.hasEncoding) {
202       if (
203         properties.baseEncodingName ||
204         properties.differences[charCode] !== undefined
205       ) {
206         continue; // The font dictionary has an `Encoding`/`Differences` entry.
207       }
208     }
209     const glyphName = builtInEncoding[charCode];
210     const unicode = getUnicodeForGlyph(glyphName, glyphsUnicodeMap);
211     if (unicode !== -1) {
212       toUnicode[charCode] = String.fromCharCode(unicode);
213     }
214   }
215   if (toUnicode.length > 0) {
216     properties.toUnicode.amend(toUnicode);
217   }
218 }
219 
220 /**
221  * NOTE: This function should only be called at the *end* of font-parsing,
222  *       after e.g. `adjustType1ToUnicode` has run, to prevent any issues.
223  */
224 function amendFallbackToUnicode(properties) {
225   if (!properties.fallbackToUnicode) {
226     return;
227   }
228   if (properties.toUnicode instanceof IdentityToUnicodeMap) {
229     return;
230   }
231   const toUnicode = [];
232   for (const charCode in properties.fallbackToUnicode) {
233     if (properties.toUnicode.has(charCode)) {
234       continue; // The font dictionary has a `ToUnicode` entry.
235     }
236     toUnicode[charCode] = properties.fallbackToUnicode[charCode];
237   }
238   if (toUnicode.length > 0) {
239     properties.toUnicode.amend(toUnicode);
240   }
241 }
242 
243 class Glyph {
244   constructor(
245     originalCharCode,
246     fontChar,
247     unicode,
248     accent,
249     width,
250     vmetric,
251     operatorListId,
252     isSpace,
253     isInFont
254   ) {
255     this.originalCharCode = originalCharCode;
256     this.fontChar = fontChar;
257     this.unicode = unicode;
258     this.accent = accent;
259     this.width = width;
260     this.vmetric = vmetric;
261     this.operatorListId = operatorListId;
262     this.isSpace = isSpace;
263     this.isInFont = isInFont;
264   }
265 
266   /**
267    * This property, which is only used by `PartialEvaluator.getTextContent`,
268    * is purposely made non-serializable.
269    * @type {Object}
270    */
271   get category() {
272     return shadow(
273       this,
274       "category",
275       getCharUnicodeCategory(this.unicode),
276       /* nonSerializable = */ true
277     );
278   }
279 }
280 
281 function int16(b0, b1) {
282   return (b0 << 8) + b1;
283 }
284 
285 function writeSignedInt16(bytes, index, value) {
286   bytes[index + 1] = value;
287   bytes[index] = value >>> 8;
288 }
289 
290 function signedInt16(b0, b1) {
291   const value = (b0 << 8) + b1;
292   return value & (1 << 15) ? value - 0x10000 : value;
293 }
294 
295 function writeUint32(bytes, index, value) {
296   bytes[index + 3] = value & 0xff;
297   bytes[index + 2] = value >>> 8;
298   bytes[index + 1] = value >>> 16;
299   bytes[index] = value >>> 24;
300 }
301 
302 function int32(b0, b1, b2, b3) {
303   return (b0 << 24) + (b1 << 16) + (b2 << 8) + b3;
304 }
305 
306 function string16(value) {
307   if (typeof PDFJSDev === "undefined" || PDFJSDev.test("TESTING")) {
308     assert(
309       typeof value === "number" && Math.abs(value) < 2 ** 16,
310       `string16: Unexpected input "${value}".`
311     );
312   }
313   return String.fromCharCode((value >> 8) & 0xff, value & 0xff);
314 }
315 
316 function safeString16(value) {
317   if (typeof PDFJSDev === "undefined" || PDFJSDev.test("TESTING")) {
318     assert(
319       typeof value === "number" && !Number.isNaN(value),
320       `safeString16: Unexpected input "${value}".`
321     );
322   }
323   // clamp value to the 16-bit int range
324   if (value > 0x7fff) {
325     value = 0x7fff;
326   } else if (value < -0x8000) {
327     value = -0x8000;
328   }
329   return String.fromCharCode((value >> 8) & 0xff, value & 0xff);
330 }
331 
332 function isTrueTypeFile(file) {
333   const header = file.peekBytes(4);
334   return (
335     readUint32(header, 0) === 0x00010000 || bytesToString(header) === "true"
336   );
337 }
338 
339 function isTrueTypeCollectionFile(file) {
340   const header = file.peekBytes(4);
341   return bytesToString(header) === "ttcf";
342 }
343 
344 function isOpenTypeFile(file) {
345   const header = file.peekBytes(4);
346   return bytesToString(header) === "OTTO";
347 }
348 
349 function isType1File(file) {
350   const header = file.peekBytes(2);
351   // All Type1 font programs must begin with the comment '%!' (0x25 + 0x21).
352   if (header[0] === 0x25 && header[1] === 0x21) {
353     return true;
354   }
355   // ... obviously some fonts violate that part of the specification,
356   // please refer to the comment in |Type1Font| below (pfb file header).
357   if (header[0] === 0x80 && header[1] === 0x01) {
358     return true;
359   }
360   return false;
361 }
362 
363 /**
364  * Compared to other font formats, the header in CFF files is not constant
365  * but contains version numbers. To reduce the possibility of misclassifying
366  * font files as CFF, it's recommended to check for other font formats first.
367  */
368 function isCFFFile(file) {
369   const header = file.peekBytes(4);
370   if (
371     /* major version, [1, 255] */ header[0] >= 1 &&
372     /* minor version, [0, 255]; header[1] */
373     /* header size, [0, 255]; header[2] */
374     /* offset(0) size, [1, 4] */ header[3] >= 1 &&
375     header[3] <= 4
376   ) {
377     return true;
378   }
379   return false;
380 }
381 
382 function getFontFileType(file, { type, subtype, composite }) {
383   let fileType, fileSubtype;
384 
385   if (isTrueTypeFile(file) || isTrueTypeCollectionFile(file)) {
386     fileType = composite ? "CIDFontType2" : "TrueType";
387   } else if (isOpenTypeFile(file)) {
388     fileType = composite ? "CIDFontType2" : "OpenType";
389   } else if (isType1File(file)) {
390     if (composite) {
391       fileType = "CIDFontType0";
392     } else {
393       fileType = type === "MMType1" ? "MMType1" : "Type1";
394     }
395   } else if (isCFFFile(file)) {
396     if (composite) {
397       fileType = "CIDFontType0";
398       fileSubtype = "CIDFontType0C";
399     } else {
400       fileType = type === "MMType1" ? "MMType1" : "Type1";
401       fileSubtype = "Type1C";
402     }
403   } else {
404     warn("getFontFileType: Unable to detect correct font file Type/Subtype.");
405     fileType = type;
406     fileSubtype = subtype;
407   }
408 
409   return [fileType, fileSubtype];
410 }
411 
412 function applyStandardFontGlyphMap(map, glyphMap) {
413   for (const charCode in glyphMap) {
414     map[+charCode] = glyphMap[charCode];
415   }
416 }
417 
418 function buildToFontChar(encoding, glyphsUnicodeMap, differences) {
419   const toFontChar = [];
420   let unicode;
421   for (let i = 0, ii = encoding.length; i < ii; i++) {
422     unicode = getUnicodeForGlyph(encoding[i], glyphsUnicodeMap);
423     if (unicode !== -1) {
424       toFontChar[i] = unicode;
425     }
426   }
427   for (const charCode in differences) {
428     unicode = getUnicodeForGlyph(differences[charCode], glyphsUnicodeMap);
429     if (unicode !== -1) {
430       toFontChar[+charCode] = unicode;
431     }
432   }
433   return toFontChar;
434 }
435 
436 // Please refer to:
437 //  - https://developer.apple.com/fonts/TrueType-Reference-Manual/RM06/Chap6name.html
438 function isMacNameRecord(r) {
439   return r.platform === 1 && r.encoding === 0 && r.language === 0;
440 }
441 
442 // Please refer to:
443 //  - https://developer.apple.com/fonts/TrueType-Reference-Manual/RM06/Chap6name.html
444 //  - https://learn.microsoft.com/en-us/typography/opentype/spec/name#windows-language-ids
445 function isWinNameRecord(r) {
446   return r.platform === 3 && r.encoding === 1 && r.language === 0x409;
447 }
448 
449 function convertCidString(charCode, cid, shouldThrow = false) {
450   switch (cid.length) {
451     case 1:
452       return cid.charCodeAt(0);
453     case 2:
454       return (cid.charCodeAt(0) << 8) | cid.charCodeAt(1);
455   }
456   const msg = `Unsupported CID string (charCode ${charCode}): "${cid}".`;
457   if (shouldThrow) {
458     throw new FormatError(msg);
459   }
460   warn(msg);
461   return cid;
462 }
463 
464 /**
465  * Rebuilds the char code to glyph ID map by moving all char codes to the
466  * private use area. This is done to avoid issues with various problematic
467  * unicode areas where either a glyph won't be drawn or is deformed by a
468  * shaper.
469  * @returns {Object} Two properties:
470  * 'toFontChar' - maps original char codes(the value that will be read
471  * from commands such as show text) to the char codes that will be used in the
472  * font that we build
473  * 'charCodeToGlyphId' - maps the new font char codes to glyph ids
474  */
475 function adjustMapping(charCodeToGlyphId, hasGlyph, newGlyphZeroId, toUnicode) {
476   const newMap = Object.create(null);
477   const toUnicodeExtraMap = new Map();
478   const toFontChar = [];
479   const usedGlyphIds = new Set();
480   let privateUseAreaIndex = 0;
481   const privateUseOffetStart = PRIVATE_USE_AREAS[privateUseAreaIndex][0];
482   let nextAvailableFontCharCode = privateUseOffetStart;
483   let privateUseOffetEnd = PRIVATE_USE_AREAS[privateUseAreaIndex][1];
484   const isInPrivateArea = code =>
485     (PRIVATE_USE_AREAS[0][0] <= code && code <= PRIVATE_USE_AREAS[0][1]) ||
486     (PRIVATE_USE_AREAS[1][0] <= code && code <= PRIVATE_USE_AREAS[1][1]);
487   for (let originalCharCode in charCodeToGlyphId) {
488     originalCharCode |= 0;
489     let glyphId = charCodeToGlyphId[originalCharCode];
490     // For missing glyphs don't create the mappings so the glyph isn't
491     // drawn.
492     if (!hasGlyph(glyphId)) {
493       continue;
494     }
495     if (nextAvailableFontCharCode > privateUseOffetEnd) {
496       privateUseAreaIndex++;
497       if (privateUseAreaIndex >= PRIVATE_USE_AREAS.length) {
498         warn("Ran out of space in font private use area.");
499         break;
500       }
501       nextAvailableFontCharCode = PRIVATE_USE_AREAS[privateUseAreaIndex][0];
502       privateUseOffetEnd = PRIVATE_USE_AREAS[privateUseAreaIndex][1];
503     }
504     const fontCharCode = nextAvailableFontCharCode++;
505     if (glyphId === 0) {
506       glyphId = newGlyphZeroId;
507     }
508 
509     // Fix for bug 1778484:
510     // The charcodes are moved into a private use area to fix some rendering
511     // issues (https://github.com/mozilla/pdf.js/pull/9340) but when printing
512     // to PDF the generated font will contain wrong chars. We can avoid that by
513     // adding the unicode to the cmap and the print backend will then map the
514     // glyph ids to the correct unicode.
515     let unicode = toUnicode.get(originalCharCode);
516     if (typeof unicode === "string") {
517       unicode = unicode.codePointAt(0);
518     }
519     if (unicode && !isInPrivateArea(unicode) && !usedGlyphIds.has(glyphId)) {
520       toUnicodeExtraMap.set(unicode, glyphId);
521       usedGlyphIds.add(glyphId);
522     }
523 
524     newMap[fontCharCode] = glyphId;
525     toFontChar[originalCharCode] = fontCharCode;
526   }
527   return {
528     toFontChar,
529     charCodeToGlyphId: newMap,
530     toUnicodeExtraMap,
531     nextAvailableFontCharCode,
532   };
533 }
534 
535 function getRanges(glyphs, toUnicodeExtraMap, numGlyphs) {
536   // Array.sort() sorts by characters, not numerically, so convert to an
537   // array of characters.
538   const codes = [];
539   for (const charCode in glyphs) {
540     // Remove an invalid glyph ID mappings to make OTS happy.
541     if (glyphs[charCode] >= numGlyphs) {
542       continue;
543     }
544     codes.push({ fontCharCode: charCode | 0, glyphId: glyphs[charCode] });
545   }
546   if (toUnicodeExtraMap) {
547     for (const [unicode, glyphId] of toUnicodeExtraMap) {
548       if (glyphId >= numGlyphs) {
549         continue;
550       }
551       codes.push({ fontCharCode: unicode, glyphId });
552     }
553   }
554   // Some fonts have zero glyphs and are used only for text selection, but
555   // there needs to be at least one to build a valid cmap table.
556   if (codes.length === 0) {
557     codes.push({ fontCharCode: 0, glyphId: 0 });
558   }
559   codes.sort(function fontGetRangesSort(a, b) {
560     return a.fontCharCode - b.fontCharCode;
561   });
562 
563   // Split the sorted codes into ranges.
564   const ranges = [];
565   const length = codes.length;
566   for (let n = 0; n < length; ) {
567     const start = codes[n].fontCharCode;
568     const codeIndices = [codes[n].glyphId];
569     ++n;
570     let end = start;
571     while (n < length && end + 1 === codes[n].fontCharCode) {
572       codeIndices.push(codes[n].glyphId);
573       ++end;
574       ++n;
575       if (end === 0xffff) {
576         break;
577       }
578     }
579     ranges.push([start, end, codeIndices]);
580   }
581 
582   return ranges;
583 }
584 
585 function createCmapTable(glyphs, toUnicodeExtraMap, numGlyphs) {
586   const ranges = getRanges(glyphs, toUnicodeExtraMap, numGlyphs);
587   const numTables = ranges.at(-1)[1] > 0xffff ? 2 : 1;
588   let cmap =
589     "\x00\x00" + // version
590     string16(numTables) + // numTables
591     "\x00\x03" + // platformID
592     "\x00\x01" + // encodingID
593     string32(4 + numTables * 8); // start of the table record
594 
595   let i, ii, j, jj;
596   for (i = ranges.length - 1; i >= 0; --i) {
597     if (ranges[i][0] <= 0xffff) {
598       break;
599     }
600   }
601   const bmpLength = i + 1;
602 
603   if (ranges[i][0] < 0xffff && ranges[i][1] === 0xffff) {
604     ranges[i][1] = 0xfffe;
605   }
606   const trailingRangesCount = ranges[i][1] < 0xffff ? 1 : 0;
607   const segCount = bmpLength + trailingRangesCount;
608   const searchParams = OpenTypeFileBuilder.getSearchParams(segCount, 2);
609 
610   // Fill up the 4 parallel arrays describing the segments.
611   let startCount = "";
612   let endCount = "";
613   let idDeltas = "";
614   let idRangeOffsets = "";
615   let glyphsIds = "";
616   let bias = 0;
617 
618   let range, start, end, codes;
619   for (i = 0, ii = bmpLength; i < ii; i++) {
620     range = ranges[i];
621     start = range[0];
622     end = range[1];
623     startCount += string16(start);
624     endCount += string16(end);
625     codes = range[2];
626     let contiguous = true;
627     for (j = 1, jj = codes.length; j < jj; ++j) {
628       if (codes[j] !== codes[j - 1] + 1) {
629         contiguous = false;
630         break;
631       }
632     }
633     if (!contiguous) {
634       const offset = (segCount - i) * 2 + bias * 2;
635       bias += end - start + 1;
636 
637       idDeltas += string16(0);
638       idRangeOffsets += string16(offset);
639 
640       for (j = 0, jj = codes.length; j < jj; ++j) {
641         glyphsIds += string16(codes[j]);
642       }
643     } else {
644       const startCode = codes[0];
645 
646       idDeltas += string16((startCode - start) & 0xffff);
647       idRangeOffsets += string16(0);
648     }
649   }
650 
651   if (trailingRangesCount > 0) {
652     endCount += "\xFF\xFF";
653     startCount += "\xFF\xFF";
654     idDeltas += "\x00\x01";
655     idRangeOffsets += "\x00\x00";
656   }
657 
658   const format314 =
659     "\x00\x00" + // language
660     string16(2 * segCount) +
661     string16(searchParams.range) +
662     string16(searchParams.entry) +
663     string16(searchParams.rangeShift) +
664     endCount +
665     "\x00\x00" +
666     startCount +
667     idDeltas +
668     idRangeOffsets +
669     glyphsIds;
670 
671   let format31012 = "";
672   let header31012 = "";
673   if (numTables > 1) {
674     cmap +=
675       "\x00\x03" + // platformID
676       "\x00\x0A" + // encodingID
677       string32(4 + numTables * 8 + 4 + format314.length); // start of the table record
678     format31012 = "";
679     for (i = 0, ii = ranges.length; i < ii; i++) {
680       range = ranges[i];
681       start = range[0];
682       codes = range[2];
683       let code = codes[0];
684       for (j = 1, jj = codes.length; j < jj; ++j) {
685         if (codes[j] !== codes[j - 1] + 1) {
686           end = range[0] + j - 1;
687           format31012 +=
688             string32(start) + // startCharCode
689             string32(end) + // endCharCode
690             string32(code); // startGlyphID
691           start = end + 1;
692           code = codes[j];
693         }
694       }
695       format31012 +=
696         string32(start) + // startCharCode
697         string32(range[1]) + // endCharCode
698         string32(code); // startGlyphID
699     }
700     header31012 =
701       "\x00\x0C" + // format
702       "\x00\x00" + // reserved
703       string32(format31012.length + 16) + // length
704       "\x00\x00\x00\x00" + // language
705       string32(format31012.length / 12); // nGroups
706   }
707 
708   return (
709     cmap +
710     "\x00\x04" + // format
711     string16(format314.length + 4) + // length
712     format314 +
713     header31012 +
714     format31012
715   );
716 }
717 
718 function validateOS2Table(os2, file) {
719   file.pos = (file.start || 0) + os2.offset;
720   const version = file.getUint16();
721   // TODO verify all OS/2 tables fields, but currently we validate only those
722   // that give us issues
723   file.skip(60); // skipping type, misc sizes, panose, unicode ranges
724   const selection = file.getUint16();
725   if (version < 4 && selection & 0x0300) {
726     return false;
727   }
728   const firstChar = file.getUint16();
729   const lastChar = file.getUint16();
730   if (firstChar > lastChar) {
731     return false;
732   }
733   file.skip(6); // skipping sTypoAscender/Descender/LineGap
734   const usWinAscent = file.getUint16();
735   if (usWinAscent === 0) {
736     // makes font unreadable by windows
737     return false;
738   }
739 
740   // OS/2 appears to be valid, resetting some fields
741   os2.data[8] = os2.data[9] = 0; // IE rejects fonts if fsType != 0
742   return true;
743 }
744 
745 function createOS2Table(properties, charstrings, override) {
746   override ||= {
747     unitsPerEm: 0,
748     yMax: 0,
749     yMin: 0,
750     ascent: 0,
751     descent: 0,
752   };
753 
754   let ulUnicodeRange1 = 0;
755   let ulUnicodeRange2 = 0;
756   let ulUnicodeRange3 = 0;
757   let ulUnicodeRange4 = 0;
758 
759   let firstCharIndex = null;
760   let lastCharIndex = 0;
761   let position = -1;
762 
763   if (charstrings) {
764     for (let code in charstrings) {
765       code |= 0;
766       if (firstCharIndex > code || !firstCharIndex) {
767         firstCharIndex = code;
768       }
769       if (lastCharIndex < code) {
770         lastCharIndex = code;
771       }
772 
773       position = getUnicodeRangeFor(code, position);
774       if (position < 32) {
775         ulUnicodeRange1 |= 1 << position;
776       } else if (position < 64) {
777         ulUnicodeRange2 |= 1 << (position - 32);
778       } else if (position < 96) {
779         ulUnicodeRange3 |= 1 << (position - 64);
780       } else if (position < 123) {
781         ulUnicodeRange4 |= 1 << (position - 96);
782       } else {
783         throw new FormatError(
784           "Unicode ranges Bits > 123 are reserved for internal usage"
785         );
786       }
787     }
788     if (lastCharIndex > 0xffff) {
789       // OS2 only supports a 16 bit int. The spec says if supplementary
790       // characters are used the field should just be set to 0xFFFF.
791       lastCharIndex = 0xffff;
792     }
793   } else {
794     // TODO
795     firstCharIndex = 0;
796     lastCharIndex = 255;
797   }
798 
799   const bbox = properties.bbox || [0, 0, 0, 0];
800   const unitsPerEm =
801     override.unitsPerEm ||
802     1 / (properties.fontMatrix || FONT_IDENTITY_MATRIX)[0];
803 
804   // if the font units differ to the PDF glyph space units
805   // then scale up the values
806   const scale = properties.ascentScaled
807     ? 1.0
808     : unitsPerEm / PDF_GLYPH_SPACE_UNITS;
809 
810   const typoAscent =
811     override.ascent || Math.round(scale * (properties.ascent || bbox[3]));
812   let typoDescent =
813     override.descent || Math.round(scale * (properties.descent || bbox[1]));
814   if (typoDescent > 0 && properties.descent > 0 && bbox[1] < 0) {
815     typoDescent = -typoDescent; // fixing incorrect descent
816   }
817   const winAscent = override.yMax || typoAscent;
818   const winDescent = -override.yMin || -typoDescent;
819 
820   return (
821     "\x00\x03" + // version
822     "\x02\x24" + // xAvgCharWidth
823     "\x01\xF4" + // usWeightClass
824     "\x00\x05" + // usWidthClass
825     "\x00\x00" + // fstype (0 to let the font loads via font-face on IE)
826     "\x02\x8A" + // ySubscriptXSize
827     "\x02\xBB" + // ySubscriptYSize
828     "\x00\x00" + // ySubscriptXOffset
829     "\x00\x8C" + // ySubscriptYOffset
830     "\x02\x8A" + // ySuperScriptXSize
831     "\x02\xBB" + // ySuperScriptYSize
832     "\x00\x00" + // ySuperScriptXOffset
833     "\x01\xDF" + // ySuperScriptYOffset
834     "\x00\x31" + // yStrikeOutSize
835     "\x01\x02" + // yStrikeOutPosition
836     "\x00\x00" + // sFamilyClass
837     "\x00\x00\x06" +
838     String.fromCharCode(properties.fixedPitch ? 0x09 : 0x00) +
839     "\x00\x00\x00\x00\x00\x00" + // Panose
840     string32(ulUnicodeRange1) + // ulUnicodeRange1 (Bits 0-31)
841     string32(ulUnicodeRange2) + // ulUnicodeRange2 (Bits 32-63)
842     string32(ulUnicodeRange3) + // ulUnicodeRange3 (Bits 64-95)
843     string32(ulUnicodeRange4) + // ulUnicodeRange4 (Bits 96-127)
844     "\x2A\x32\x31\x2A" + // achVendID
845     string16(properties.italicAngle ? 1 : 0) + // fsSelection
846     string16(firstCharIndex || properties.firstChar) + // usFirstCharIndex
847     string16(lastCharIndex || properties.lastChar) + // usLastCharIndex
848     string16(typoAscent) + // sTypoAscender
849     string16(typoDescent) + // sTypoDescender
850     "\x00\x64" + // sTypoLineGap (7%-10% of the unitsPerEM value)
851     string16(winAscent) + // usWinAscent
852     string16(winDescent) + // usWinDescent
853     "\x00\x00\x00\x00" + // ulCodePageRange1 (Bits 0-31)
854     "\x00\x00\x00\x00" + // ulCodePageRange2 (Bits 32-63)
855     string16(properties.xHeight) + // sxHeight
856     string16(properties.capHeight) + // sCapHeight
857     string16(0) + // usDefaultChar
858     string16(firstCharIndex || properties.firstChar) + // usBreakChar
859     "\x00\x03"
860   ); // usMaxContext
861 }
862 
863 function createPostTable(properties) {
864   const angle = Math.floor(properties.italicAngle * 2 ** 16);
865   return (
866     "\x00\x03\x00\x00" + // Version number
867     string32(angle) + // italicAngle
868     "\x00\x00" + // underlinePosition
869     "\x00\x00" + // underlineThickness
870     string32(properties.fixedPitch ? 1 : 0) + // isFixedPitch
871     "\x00\x00\x00\x00" + // minMemType42
872     "\x00\x00\x00\x00" + // maxMemType42
873     "\x00\x00\x00\x00" + // minMemType1
874     "\x00\x00\x00\x00"
875   ); // maxMemType1
876 }
877 
878 function createPostscriptName(name) {
879   // See https://docs.microsoft.com/en-us/typography/opentype/spec/recom#name.
880   return name.replaceAll(/[^\x21-\x7E]|[[\](){}<>/%]/g, "").slice(0, 63);
881 }
882 
883 function createNameTable(name, proto) {
884   if (!proto) {
885     proto = [[], []]; // no strings and unicode strings
886   }
887 
888   const strings = [
889     proto[0][0] || "Original licence", // 0.Copyright
890     proto[0][1] || name, // 1.Font family
891     proto[0][2] || "Unknown", // 2.Font subfamily (font weight)
892     proto[0][3] || "uniqueID", // 3.Unique ID
893     proto[0][4] || name, // 4.Full font name
894     proto[0][5] || "Version 0.11", // 5.Version
895     proto[0][6] || createPostscriptName(name), // 6.Postscript name
896     proto[0][7] || "Unknown", // 7.Trademark
897     proto[0][8] || "Unknown", // 8.Manufacturer
898     proto[0][9] || "Unknown", // 9.Designer
899   ];
900 
901   // Mac want 1-byte per character strings while Windows want
902   // 2-bytes per character, so duplicate the names table
903   const stringsUnicode = [];
904   let i, ii, j, jj, str;
905   for (i = 0, ii = strings.length; i < ii; i++) {
906     str = proto[1][i] || strings[i];
907 
908     const strBufUnicode = [];
909     for (j = 0, jj = str.length; j < jj; j++) {
910       strBufUnicode.push(string16(str.charCodeAt(j)));
911     }
912     stringsUnicode.push(strBufUnicode.join(""));
913   }
914 
915   const names = [strings, stringsUnicode];
916   const platforms = ["\x00\x01", "\x00\x03"];
917   const encodings = ["\x00\x00", "\x00\x01"];
918   const languages = ["\x00\x00", "\x04\x09"];
919 
920   const namesRecordCount = strings.length * platforms.length;
921   let nameTable =
922     "\x00\x00" + // format
923     string16(namesRecordCount) + // Number of names Record
924     string16(namesRecordCount * 12 + 6); // Storage
925 
926   // Build the name records field
927   let strOffset = 0;
928   for (i = 0, ii = platforms.length; i < ii; i++) {
929     const strs = names[i];
930     for (j = 0, jj = strs.length; j < jj; j++) {
931       str = strs[j];
932       const nameRecord =
933         platforms[i] + // platform ID
934         encodings[i] + // encoding ID
935         languages[i] + // language ID
936         string16(j) + // name ID
937         string16(str.length) +
938         string16(strOffset);
939       nameTable += nameRecord;
940       strOffset += str.length;
941     }
942   }
943 
944   nameTable += strings.join("") + stringsUnicode.join("");
945   return nameTable;
946 }
947 
948 /**
949  * 'Font' is the class the outside world should use, it encapsulate all the font
950  * decoding logics whatever type it is (assuming the font type is supported).
951  */
952 class Font {
953   constructor(name, file, properties) {
954     this.name = name;
955     this.psName = null;
956     this.mimetype = null;
957     this.disableFontFace = false;
958 
959     this.loadedName = properties.loadedName;
960     this.isType3Font = properties.isType3Font;
961     this.missingFile = false;
962     this.cssFontInfo = properties.cssFontInfo;
963 
964     this._charsCache = Object.create(null);
965     this._glyphCache = Object.create(null);
966 
967     let isSerifFont = !!(properties.flags & FontFlags.Serif);
968     // Fallback to checking the font name, in order to improve text-selection,
969     // since the /Flags-entry is often wrong (fixes issue13845.pdf).
970     if (!isSerifFont && !properties.isSimulatedFlags) {
971       const baseName = name.replaceAll(/[,_]/g, "-").split("-", 1)[0],
972         serifFonts = getSerifFonts();
973       for (const namePart of baseName.split("+")) {
974         if (serifFonts[namePart]) {
975           isSerifFont = true;
976           break;
977         }
978       }
979     }
980     this.isSerifFont = isSerifFont;
981 
982     this.isSymbolicFont = !!(properties.flags & FontFlags.Symbolic);
983     this.isMonospace = !!(properties.flags & FontFlags.FixedPitch);
984 
985     let { type, subtype } = properties;
986     this.type = type;
987     this.subtype = subtype;
988     this.systemFontInfo = properties.systemFontInfo;
989 
990     const matches = name.match(/^InvalidPDFjsFont_(.*)_\d+$/);
991     this.isInvalidPDFjsFont = !!matches;
992     if (this.isInvalidPDFjsFont) {
993       this.fallbackName = matches[1];
994     } else if (this.isMonospace) {
995       this.fallbackName = "monospace";
996     } else if (this.isSerifFont) {
997       this.fallbackName = "serif";
998     } else {
999       this.fallbackName = "sans-serif";
1000     }
1001 
1002     if (this.systemFontInfo?.guessFallback) {
1003       // Once the fallback name is guessed, we don't want to guess it again.
1004       this.systemFontInfo.guessFallback = false;
1005       this.systemFontInfo.css += `,${this.fallbackName}`;
1006     }
1007 
1008     this.differences = properties.differences;
1009     this.widths = properties.widths;
1010     this.defaultWidth = properties.defaultWidth;
1011     this.composite = properties.composite;
1012     this.cMap = properties.cMap;
1013     this.capHeight = properties.capHeight / PDF_GLYPH_SPACE_UNITS;
1014     this.ascent = properties.ascent / PDF_GLYPH_SPACE_UNITS;
1015     this.descent = properties.descent / PDF_GLYPH_SPACE_UNITS;
1016     this.lineHeight = this.ascent - this.descent;
1017     this.fontMatrix = properties.fontMatrix;
1018     this.bbox = properties.bbox;
1019     this.defaultEncoding = properties.defaultEncoding;
1020 
1021     this.toUnicode = properties.toUnicode;
1022     this.toFontChar = [];
1023 
1024     if (properties.type === "Type3") {
1025       for (let charCode = 0; charCode < 256; charCode++) {
1026         this.toFontChar[charCode] =
1027           this.differences[charCode] || properties.defaultEncoding[charCode];
1028       }
1029       return;
1030     }
1031 
1032     this.cidEncoding = properties.cidEncoding || "";
1033     this.vertical = !!properties.vertical;
1034     if (this.vertical) {
1035       this.vmetrics = properties.vmetrics;
1036       this.defaultVMetrics = properties.defaultVMetrics;
1037     }
1038 
1039     if (!file || file.isEmpty) {
1040       if (file) {
1041         // Some bad PDF generators will include empty font files,
1042         // attempting to recover by assuming that no file exists.
1043         warn('Font file is empty in "' + name + '" (' + this.loadedName + ")");
1044       }
1045       this.fallbackToSystemFont(properties);
1046       return;
1047     }
1048 
1049     // Parse the font file to determine the correct type/subtype, rather than
1050     // relying on the (often incorrect) data in the font dictionary; (see e.g.
1051     //  issue6782.pdf, issue7598.pdf, and issue9949.pdf).
1052     [type, subtype] = getFontFileType(file, properties);
1053 
1054     if (type !== this.type || subtype !== this.subtype) {
1055       info(
1056         "Inconsistent font file Type/SubType, expected: " +
1057           `${this.type}/${this.subtype} but found: ${type}/${subtype}.`
1058       );
1059     }
1060 
1061     let data;
1062     try {
1063       switch (type) {
1064         case "MMType1":
1065           info("MMType1 font (" + name + "), falling back to Type1.");
1066         /* falls through */
1067         case "Type1":
1068         case "CIDFontType0":
1069           this.mimetype = "font/opentype";
1070 
1071           const cff =
1072             subtype === "Type1C" || subtype === "CIDFontType0C"
1073               ? new CFFFont(file, properties)
1074               : new Type1Font(name, file, properties);
1075 
1076           adjustWidths(properties);
1077 
1078           // Wrap the CFF data inside an OTF font file
1079           data = this.convert(name, cff, properties);
1080           break;
1081 
1082         case "OpenType":
1083         case "TrueType":
1084         case "CIDFontType2":
1085           this.mimetype = "font/opentype";
1086 
1087           // Repair the TrueType file. It is can be damaged in the point of
1088           // view of the sanitizer
1089           data = this.checkAndRepair(name, file, properties);
1090           if (this.isOpenType) {
1091             adjustWidths(properties);
1092 
1093             type = "OpenType";
1094           }
1095           break;
1096 
1097         default:
1098           throw new FormatError(`Font ${type} is not supported`);
1099       }
1100     } catch (e) {
1101       warn(e);
1102       this.fallbackToSystemFont(properties);
1103       return;
1104     }
1105 
1106     amendFallbackToUnicode(properties);
1107     this.data = data;
1108 
1109     // Transfer some properties again that could change during font conversion
1110     this.type = type;
1111     this.subtype = subtype;
1112     this.fontMatrix = properties.fontMatrix;
1113     this.widths = properties.widths;
1114     this.defaultWidth = properties.defaultWidth;
1115     this.toUnicode = properties.toUnicode;
1116     this.seacMap = properties.seacMap;
1117   }
1118 
1119   get renderer() {
1120     const renderer = FontRendererFactory.create(this, SEAC_ANALYSIS_ENABLED);
1121     return shadow(this, "renderer", renderer);
1122   }
1123 
1124   exportData(extraProperties = false) {
1125     const exportDataProperties = extraProperties
1126       ? [...EXPORT_DATA_PROPERTIES, ...EXPORT_DATA_EXTRA_PROPERTIES]
1127       : EXPORT_DATA_PROPERTIES;
1128 
1129     const data = Object.create(null);
1130     let property, value;
1131     for (property of exportDataProperties) {
1132       value = this[property];
1133       // Ignore properties that haven't been explicitly set.
1134       if (value !== undefined) {
1135         data[property] = value;
1136       }
1137     }
1138     return data;
1139   }
1140 
1141   fallbackToSystemFont(properties) {
1142     this.missingFile = true;
1143     // The file data is not specified. Trying to fix the font name
1144     // to be used with the canvas.font.
1145     const { name, type } = this;
1146     let fontName = normalizeFontName(name);
1147     const stdFontMap = getStdFontMap(),
1148       nonStdFontMap = getNonStdFontMap();
1149     const isStandardFont = !!stdFontMap[fontName];
1150     const isMappedToStandardFont = !!(
1151       nonStdFontMap[fontName] && stdFontMap[nonStdFontMap[fontName]]
1152     );
1153 
1154     fontName = stdFontMap[fontName] || nonStdFontMap[fontName] || fontName;
1155 
1156     const fontBasicMetricsMap = getFontBasicMetrics();
1157     const metrics = fontBasicMetricsMap[fontName];
1158     if (metrics) {
1159       if (isNaN(this.ascent)) {
1160         this.ascent = metrics.ascent / PDF_GLYPH_SPACE_UNITS;
1161       }
1162       if (isNaN(this.descent)) {
1163         this.descent = metrics.descent / PDF_GLYPH_SPACE_UNITS;
1164       }
1165       if (isNaN(this.capHeight)) {
1166         this.capHeight = metrics.capHeight / PDF_GLYPH_SPACE_UNITS;
1167       }
1168     }
1169 
1170     this.bold = /bold/gi.test(fontName);
1171     this.italic = /oblique|italic/gi.test(fontName);
1172 
1173     // Use 'name' instead of 'fontName' here because the original
1174     // name ArialBlack for example will be replaced by Helvetica.
1175     this.black = /Black/g.test(name);
1176 
1177     // Use 'name' instead of 'fontName' here because the original
1178     // name ArialNarrow for example will be replaced by Helvetica.
1179     const isNarrow = /Narrow/g.test(name);
1180 
1181     // if at least one width is present, remeasure all chars when exists
1182     this.remeasure =
1183       (!isStandardFont || isNarrow) && Object.keys(this.widths).length > 0;
1184     if (
1185       (isStandardFont || isMappedToStandardFont) &&
1186       type === "CIDFontType2" &&
1187       this.cidEncoding.startsWith("Identity-")
1188     ) {
1189       const cidToGidMap = properties.cidToGidMap;
1190       // Standard fonts might be embedded as CID font without glyph mapping.
1191       // Building one based on GlyphMapForStandardFonts.
1192       const map = [];
1193       applyStandardFontGlyphMap(map, getGlyphMapForStandardFonts());
1194 
1195       if (/Arial-?Black/i.test(name)) {
1196         applyStandardFontGlyphMap(map, getSupplementalGlyphMapForArialBlack());
1197       } else if (/Calibri/i.test(name)) {
1198         applyStandardFontGlyphMap(map, getSupplementalGlyphMapForCalibri());
1199       }
1200 
1201       // Always update the glyph mapping with the `cidToGidMap` when it exists
1202       // (fixes issue12418_reduced.pdf).
1203       if (cidToGidMap) {
1204         for (const charCode in map) {
1205           const cid = map[charCode];
1206           if (cidToGidMap[cid] !== undefined) {
1207             map[+charCode] = cidToGidMap[cid];
1208           }
1209         }
1210         // When the /CIDToGIDMap is "incomplete", fallback to the included
1211         // /ToUnicode-map regardless of its encoding (fixes issue11915.pdf).
1212         if (
1213           cidToGidMap.length !== this.toUnicode.length &&
1214           properties.hasIncludedToUnicodeMap &&
1215           this.toUnicode instanceof IdentityToUnicodeMap
1216         ) {
1217           this.toUnicode.forEach(function (charCode, unicodeCharCode) {
1218             const cid = map[charCode];
1219             if (cidToGidMap[cid] === undefined) {
1220               map[+charCode] = unicodeCharCode;
1221             }
1222           });
1223         }
1224       }
1225 
1226       if (!(this.toUnicode instanceof IdentityToUnicodeMap)) {
1227         this.toUnicode.forEach(function (charCode, unicodeCharCode) {
1228           map[+charCode] = unicodeCharCode;
1229         });
1230       }
1231       this.toFontChar = map;
1232       this.toUnicode = new ToUnicodeMap(map);
1233     } else if (/Symbol/i.test(fontName)) {
1234       this.toFontChar = buildToFontChar(
1235         SymbolSetEncoding,
1236         getGlyphsUnicode(),
1237         this.differences
1238       );
1239     } else if (/Dingbats/i.test(fontName)) {
1240       this.toFontChar = buildToFontChar(
1241         ZapfDingbatsEncoding,
1242         getDingbatsGlyphsUnicode(),
1243         this.differences
1244       );
1245     } else if (isStandardFont) {
1246       const map = buildToFontChar(
1247         this.defaultEncoding,
1248         getGlyphsUnicode(),
1249         this.differences
1250       );
1251 
1252       if (
1253         type === "CIDFontType2" &&
1254         !this.cidEncoding.startsWith("Identity-") &&
1255         !(this.toUnicode instanceof IdentityToUnicodeMap)
1256       ) {
1257         this.toUnicode.forEach(function (charCode, unicodeCharCode) {
1258           map[+charCode] = unicodeCharCode;
1259         });
1260       }
1261       this.toFontChar = map;
1262     } else {
1263       const glyphsUnicodeMap = getGlyphsUnicode();
1264       const map = [];
1265       this.toUnicode.forEach((charCode, unicodeCharCode) => {
1266         if (!this.composite) {
1267           const glyphName =
1268             this.differences[charCode] || this.defaultEncoding[charCode];
1269           const unicode = getUnicodeForGlyph(glyphName, glyphsUnicodeMap);
1270           if (unicode !== -1) {
1271             unicodeCharCode = unicode;
1272           }
1273         }
1274         map[+charCode] = unicodeCharCode;
1275       });
1276 
1277       // Attempt to improve the glyph mapping for (some) composite fonts that
1278       // appear to lack meaningful ToUnicode data.
1279       if (this.composite && this.toUnicode instanceof IdentityToUnicodeMap) {
1280         if (/Tahoma|Verdana/i.test(name)) {
1281           // Fixes issue15719.pdf and issue11242_reduced.pdf.
1282           applyStandardFontGlyphMap(map, getGlyphMapForStandardFonts());
1283         }
1284       }
1285       this.toFontChar = map;
1286     }
1287 
1288     amendFallbackToUnicode(properties);
1289     this.loadedName = fontName.split("-", 1)[0];
1290   }
1291 
1292   checkAndRepair(name, font, properties) {
1293     const VALID_TABLES = [
1294       "OS/2",
1295       "cmap",
1296       "head",
1297       "hhea",
1298       "hmtx",
1299       "maxp",
1300       "name",
1301       "post",
1302       "loca",
1303       "glyf",
1304       "fpgm",
1305       "prep",
1306       "cvt ",
1307       "CFF ",
1308     ];
1309 
1310     function readTables(file, numTables) {
1311       const tables = Object.create(null);
1312       tables["OS/2"] = null;
1313       tables.cmap = null;
1314       tables.head = null;
1315       tables.hhea = null;
1316       tables.hmtx = null;
1317       tables.maxp = null;
1318       tables.name = null;
1319       tables.post = null;
1320 
1321       for (let i = 0; i < numTables; i++) {
1322         const table = readTableEntry(file);
1323         if (!VALID_TABLES.includes(table.tag)) {
1324           continue; // skipping table if it's not a required or optional table
1325         }
1326         if (table.length === 0) {
1327           continue; // skipping empty tables
1328         }
1329         tables[table.tag] = table;
1330       }
1331       return tables;
1332     }
1333 
1334     function readTableEntry(file) {
1335       const tag = file.getString(4);
1336 
1337       const checksum = file.getInt32() >>> 0;
1338       const offset = file.getInt32() >>> 0;
1339       const length = file.getInt32() >>> 0;
1340 
1341       // Read the table associated data
1342       const previousPosition = file.pos;
1343       file.pos = file.start || 0;
1344       file.skip(offset);
1345       const data = file.getBytes(length);
1346       file.pos = previousPosition;
1347 
1348       if (tag === "head") {
1349         // clearing checksum adjustment
1350         data[8] = data[9] = data[10] = data[11] = 0;
1351         data[17] |= 0x20; // Set font optimized for cleartype flag.
1352       }
1353 
1354       return {
1355         tag,
1356         checksum,
1357         length,
1358         offset,
1359         data,
1360       };
1361     }
1362 
1363     function readOpenTypeHeader(ttf) {
1364       return {
1365         version: ttf.getString(4),
1366         numTables: ttf.getUint16(),
1367         searchRange: ttf.getUint16(),
1368         entrySelector: ttf.getUint16(),
1369         rangeShift: ttf.getUint16(),
1370       };
1371     }
1372 
1373     function readTrueTypeCollectionHeader(ttc) {
1374       const ttcTag = ttc.getString(4);
1375       assert(ttcTag === "ttcf", "Must be a TrueType Collection font.");
1376 
1377       const majorVersion = ttc.getUint16();
1378       const minorVersion = ttc.getUint16();
1379       const numFonts = ttc.getInt32() >>> 0;
1380       const offsetTable = [];
1381       for (let i = 0; i < numFonts; i++) {
1382         offsetTable.push(ttc.getInt32() >>> 0);
1383       }
1384 
1385       const header = {
1386         ttcTag,
1387         majorVersion,
1388         minorVersion,
1389         numFonts,
1390         offsetTable,
1391       };
1392       switch (majorVersion) {
1393         case 1:
1394           return header;
1395         case 2:
1396           header.dsigTag = ttc.getInt32() >>> 0;
1397           header.dsigLength = ttc.getInt32() >>> 0;
1398           header.dsigOffset = ttc.getInt32() >>> 0;
1399           return header;
1400       }
1401       throw new FormatError(
1402         `Invalid TrueType Collection majorVersion: ${majorVersion}.`
1403       );
1404     }
1405 
1406     function readTrueTypeCollectionData(ttc, fontName) {
1407       const { numFonts, offsetTable } = readTrueTypeCollectionHeader(ttc);
1408       const fontNameParts = fontName.split("+");
1409       let fallbackData;
1410 
1411       for (let i = 0; i < numFonts; i++) {
1412         ttc.pos = (ttc.start || 0) + offsetTable[i];
1413         const potentialHeader = readOpenTypeHeader(ttc);
1414         const potentialTables = readTables(ttc, potentialHeader.numTables);
1415 
1416         if (!potentialTables.name) {
1417           throw new FormatError(
1418             'TrueType Collection font must contain a "name" table.'
1419           );
1420         }
1421         const [nameTable] = readNameTable(potentialTables.name);
1422 
1423         for (let j = 0, jj = nameTable.length; j < jj; j++) {
1424           for (let k = 0, kk = nameTable[j].length; k < kk; k++) {
1425             const nameEntry = nameTable[j][k]?.replaceAll(/\s/g, "");
1426             if (!nameEntry) {
1427               continue;
1428             }
1429             if (nameEntry === fontName) {
1430               return {
1431                 header: potentialHeader,
1432                 tables: potentialTables,
1433               };
1434             }
1435             if (fontNameParts.length < 2) {
1436               continue;
1437             }
1438             for (const part of fontNameParts) {
1439               if (nameEntry === part) {
1440                 fallbackData = {
1441                   name: part,
1442                   header: potentialHeader,
1443                   tables: potentialTables,
1444                 };
1445               }
1446             }
1447           }
1448         }
1449       }
1450       if (fallbackData) {
1451         warn(
1452           `TrueType Collection does not contain "${fontName}" font, ` +
1453             `falling back to "${fallbackData.name}" font instead.`
1454         );
1455         return {
1456           header: fallbackData.header,
1457           tables: fallbackData.tables,
1458         };
1459       }
1460       throw new FormatError(
1461         `TrueType Collection does not contain "${fontName}" font.`
1462       );
1463     }
1464 
1465     /**
1466      * Read the appropriate subtable from the cmap according to 9.6.6.4 from
1467      * PDF spec
1468      */
1469     function readCmapTable(cmap, file, isSymbolicFont, hasEncoding) {
1470       if (!cmap) {
1471         warn("No cmap table available.");
1472         return {
1473           platformId: -1,
1474           encodingId: -1,
1475           mappings: [],
1476           hasShortCmap: false,
1477         };
1478       }
1479       let segment;
1480       let start = (file.start || 0) + cmap.offset;
1481       file.pos = start;
1482 
1483       file.skip(2); // version
1484       const numTables = file.getUint16();
1485 
1486       let potentialTable;
1487       let canBreak = false;
1488       // There's an order of preference in terms of which cmap subtable to
1489       // use:
1490       // - non-symbolic fonts the preference is a 3,1 table then a 1,0 table
1491       // - symbolic fonts the preference is a 3,0 table then a 1,0 table
1492       // The following takes advantage of the fact that the tables are sorted
1493       // to work.
1494       for (let i = 0; i < numTables; i++) {
1495         const platformId = file.getUint16();
1496         const encodingId = file.getUint16();
1497         const offset = file.getInt32() >>> 0;
1498         let useTable = false;
1499 
1500         // Sometimes there are multiple of the same type of table. Default
1501         // to choosing the first table and skip the rest.
1502         if (
1503           potentialTable?.platformId === platformId &&
1504           potentialTable?.encodingId === encodingId
1505         ) {
1506           continue;
1507         }
1508 
1509         if (
1510           platformId === 0 &&
1511           (encodingId === /* Unicode Default */ 0 ||
1512             encodingId === /* Unicode 1.1 */ 1 ||
1513             encodingId === /* Unicode BMP */ 3)
1514         ) {
1515           useTable = true;
1516           // Continue the loop since there still may be a higher priority
1517           // table.
1518         } else if (platformId === 1 && encodingId === 0) {
1519           useTable = true;
1520           // Continue the loop since there still may be a higher priority
1521           // table.
1522         } else if (
1523           platformId === 3 &&
1524           encodingId === 1 &&
1525           (hasEncoding || !potentialTable)
1526         ) {
1527           useTable = true;
1528           if (!isSymbolicFont) {
1529             canBreak = true;
1530           }
1531         } else if (isSymbolicFont && platformId === 3 && encodingId === 0) {
1532           useTable = true;
1533 
1534           let correctlySorted = true;
1535           if (i < numTables - 1) {
1536             const nextBytes = file.peekBytes(2),
1537               nextPlatformId = int16(nextBytes[0], nextBytes[1]);
1538             if (nextPlatformId < platformId) {
1539               correctlySorted = false;
1540             }
1541           }
1542           if (correctlySorted) {
1543             canBreak = true;
1544           }
1545         }
1546 
1547         if (useTable) {
1548           potentialTable = {
1549             platformId,
1550             encodingId,
1551             offset,
1552           };
1553         }
1554         if (canBreak) {
1555           break;
1556         }
1557       }
1558 
1559       if (potentialTable) {
1560         file.pos = start + potentialTable.offset;
1561       }
1562       if (!potentialTable || file.peekByte() === -1) {
1563         warn("Could not find a preferred cmap table.");
1564         return {
1565           platformId: -1,
1566           encodingId: -1,
1567           mappings: [],
1568           hasShortCmap: false,
1569         };
1570       }
1571 
1572       const format = file.getUint16();
1573       let hasShortCmap = false;
1574       const mappings = [];
1575       let j, glyphId;
1576 
1577       // TODO(mack): refactor this cmap subtable reading logic out
1578       if (format === 0) {
1579         file.skip(2 + 2); // length + language
1580 
1581         for (j = 0; j < 256; j++) {
1582           const index = file.getByte();
1583           if (!index) {
1584             continue;
1585           }
1586           mappings.push({
1587             charCode: j,
1588             glyphId: index,
1589           });
1590         }
1591         hasShortCmap = true;
1592       } else if (format === 2) {
1593         file.skip(2 + 2); // length + language
1594 
1595         const subHeaderKeys = [];
1596         let maxSubHeaderKey = 0;
1597         // Read subHeaderKeys. If subHeaderKeys[i] === 0, then i is a
1598         // single-byte character. Otherwise, i is the first byte of a
1599         // multi-byte character, and the value is 8*index into
1600         // subHeaders.
1601         for (let i = 0; i < 256; i++) {
1602           const subHeaderKey = file.getUint16() >> 3;
1603           subHeaderKeys.push(subHeaderKey);
1604           maxSubHeaderKey = Math.max(subHeaderKey, maxSubHeaderKey);
1605         }
1606         // Read subHeaders. The number of entries is determined
1607         // dynamically based on the subHeaderKeys found above.
1608         const subHeaders = [];
1609         for (let i = 0; i <= maxSubHeaderKey; i++) {
1610           subHeaders.push({
1611             firstCode: file.getUint16(),
1612             entryCount: file.getUint16(),
1613             idDelta: signedInt16(file.getByte(), file.getByte()),
1614             idRangePos: file.pos + file.getUint16(),
1615           });
1616         }
1617         for (let i = 0; i < 256; i++) {
1618           if (subHeaderKeys[i] === 0) {
1619             // i is a single-byte code.
1620             file.pos = subHeaders[0].idRangePos + 2 * i;
1621             glyphId = file.getUint16();
1622             mappings.push({
1623               charCode: i,
1624               glyphId,
1625             });
1626           } else {
1627             // i is the first byte of a two-byte code.
1628             const s = subHeaders[subHeaderKeys[i]];
1629             for (j = 0; j < s.entryCount; j++) {
1630               const charCode = (i << 8) + j + s.firstCode;
1631               file.pos = s.idRangePos + 2 * j;
1632               glyphId = file.getUint16();
1633               if (glyphId !== 0) {
1634                 glyphId = (glyphId + s.idDelta) % 65536;
1635               }
1636               mappings.push({
1637                 charCode,
1638                 glyphId,
1639               });
1640             }
1641           }
1642         }
1643       } else if (format === 4) {
1644         file.skip(2 + 2); // length + language
1645 
1646         // re-creating the table in format 4 since the encoding
1647         // might be changed
1648         const segCount = file.getUint16() >> 1;
1649         file.skip(6); // skipping range fields
1650         const segments = [];
1651         let segIndex;
1652         for (segIndex = 0; segIndex < segCount; segIndex++) {
1653           segments.push({ end: file.getUint16() });
1654         }
1655         file.skip(2);
1656         for (segIndex = 0; segIndex < segCount; segIndex++) {
1657           segments[segIndex].start = file.getUint16();
1658         }
1659 
1660         for (segIndex = 0; segIndex < segCount; segIndex++) {
1661           segments[segIndex].delta = file.getUint16();
1662         }
1663 
1664         let offsetsCount = 0,
1665           offsetIndex;
1666         for (segIndex = 0; segIndex < segCount; segIndex++) {
1667           segment = segments[segIndex];
1668           const rangeOffset = file.getUint16();
1669           if (!rangeOffset) {
1670             segment.offsetIndex = -1;
1671             continue;
1672           }
1673 
1674           offsetIndex = (rangeOffset >> 1) - (segCount - segIndex);
1675           segment.offsetIndex = offsetIndex;
1676           offsetsCount = Math.max(
1677             offsetsCount,
1678             offsetIndex + segment.end - segment.start + 1
1679           );
1680         }
1681 
1682         const offsets = [];
1683         for (j = 0; j < offsetsCount; j++) {
1684           offsets.push(file.getUint16());
1685         }
1686 
1687         for (segIndex = 0; segIndex < segCount; segIndex++) {
1688           segment = segments[segIndex];
1689           start = segment.start;
1690           const end = segment.end;
1691           const delta = segment.delta;
1692           offsetIndex = segment.offsetIndex;
1693 
1694           for (j = start; j <= end; j++) {
1695             if (j === 0xffff) {
1696               continue;
1697             }
1698 
1699             glyphId = offsetIndex < 0 ? j : offsets[offsetIndex + j - start];
1700             glyphId = (glyphId + delta) & 0xffff;
1701             mappings.push({
1702               charCode: j,
1703               glyphId,
1704             });
1705           }
1706         }
1707       } else if (format === 6) {
1708         file.skip(2 + 2); // length + language
1709 
1710         // Format 6 is a 2-bytes dense mapping, which means the font data
1711         // lives glue together even if they are pretty far in the unicode
1712         // table. (This looks weird, so I can have missed something), this
1713         // works on Linux but seems to fails on Mac so let's rewrite the
1714         // cmap table to a 3-1-4 style
1715         const firstCode = file.getUint16();
1716         const entryCount = file.getUint16();
1717 
1718         for (j = 0; j < entryCount; j++) {
1719           glyphId = file.getUint16();
1720           const charCode = firstCode + j;
1721 
1722           mappings.push({
1723             charCode,
1724             glyphId,
1725           });
1726         }
1727       } else if (format === 12) {
1728         file.skip(2 + 4 + 4); // reserved + length + language
1729 
1730         const nGroups = file.getInt32() >>> 0;
1731         for (j = 0; j < nGroups; j++) {
1732           const startCharCode = file.getInt32() >>> 0;
1733           const endCharCode = file.getInt32() >>> 0;
1734           let glyphCode = file.getInt32() >>> 0;
1735 
1736           for (
1737             let charCode = startCharCode;
1738             charCode <= endCharCode;
1739             charCode++
1740           ) {
1741             mappings.push({
1742               charCode,
1743               glyphId: glyphCode++,
1744             });
1745           }
1746         }
1747       } else {
1748         warn("cmap table has unsupported format: " + format);
1749         return {
1750           platformId: -1,
1751           encodingId: -1,
1752           mappings: [],
1753           hasShortCmap: false,
1754         };
1755       }
1756 
1757       // removing duplicate entries
1758       mappings.sort(function (a, b) {
1759         return a.charCode - b.charCode;
1760       });
1761       for (let i = 1; i < mappings.length; i++) {
1762         if (mappings[i - 1].charCode === mappings[i].charCode) {
1763           mappings.splice(i, 1);
1764           i--;
1765         }
1766       }
1767 
1768       return {
1769         platformId: potentialTable.platformId,
1770         encodingId: potentialTable.encodingId,
1771         mappings,
1772         hasShortCmap,
1773       };
1774     }
1775 
1776     function sanitizeMetrics(
1777       file,
1778       header,
1779       metrics,
1780       headTable,
1781       numGlyphs,
1782       dupFirstEntry
1783     ) {
1784       if (!header) {
1785         if (metrics) {
1786           metrics.data = null;
1787         }
1788         return;
1789       }
1790 
1791       file.pos = (file.start || 0) + header.offset;
1792       file.pos += 4; // version
1793       file.pos += 2; // ascent
1794       file.pos += 2; // descent
1795       file.pos += 2; // linegap
1796       file.pos += 2; // adv_width_max
1797       file.pos += 2; // min_sb1
1798       file.pos += 2; // min_sb2
1799       file.pos += 2; // max_extent
1800       file.pos += 2; // caret_slope_rise
1801       file.pos += 2; // caret_slope_run
1802       const caretOffset = file.getUint16();
1803       file.pos += 8; // reserved
1804       file.pos += 2; // format
1805       let numOfMetrics = file.getUint16();
1806 
1807       if (caretOffset !== 0) {
1808         const macStyle = int16(headTable.data[44], headTable.data[45]);
1809         if (!(macStyle & 2)) {
1810           // Suppress OTS warnings about the `caretOffset` in the hhea-table.
1811           header.data[22] = 0;
1812           header.data[23] = 0;
1813         }
1814       }
1815 
1816       if (numOfMetrics > numGlyphs) {
1817         info(
1818           `The numOfMetrics (${numOfMetrics}) should not be ` +
1819             `greater than the numGlyphs (${numGlyphs}).`
1820         );
1821         // Reduce numOfMetrics if it is greater than numGlyphs
1822         numOfMetrics = numGlyphs;
1823         header.data[34] = (numOfMetrics & 0xff00) >> 8;
1824         header.data[35] = numOfMetrics & 0x00ff;
1825       }
1826 
1827       const numOfSidebearings = numGlyphs - numOfMetrics;
1828       const numMissing =
1829         numOfSidebearings - ((metrics.length - numOfMetrics * 4) >> 1);
1830 
1831       if (numMissing > 0) {
1832         // For each missing glyph, we set both the width and lsb to 0 (zero).
1833         // Since we need to add two properties for each glyph, this explains
1834         // the use of |numMissing * 2| when initializing the typed array.
1835         const entries = new Uint8Array(metrics.length + numMissing * 2);
1836         entries.set(metrics.data);
1837         if (dupFirstEntry) {
1838           // Set the sidebearing value of the duplicated glyph.
1839           entries[metrics.length] = metrics.data[2];
1840           entries[metrics.length + 1] = metrics.data[3];
1841         }
1842         metrics.data = entries;
1843       }
1844     }
1845 
1846     function sanitizeGlyph(
1847       source,
1848       sourceStart,
1849       sourceEnd,
1850       dest,
1851       destStart,
1852       hintsValid
1853     ) {
1854       const glyphProfile = {
1855         length: 0,
1856         sizeOfInstructions: 0,
1857       };
1858       if (
1859         sourceStart < 0 ||
1860         sourceStart >= source.length ||
1861         sourceEnd > source.length ||
1862         sourceEnd - sourceStart <= 12
1863       ) {
1864         // If the offsets are wrong or the glyph is too small, remove it.
1865         return glyphProfile;
1866       }
1867       const glyf = source.subarray(sourceStart, sourceEnd);
1868 
1869       // Sanitize the glyph bounding box.
1870       const xMin = signedInt16(glyf[2], glyf[3]);
1871       const yMin = signedInt16(glyf[4], glyf[5]);
1872       const xMax = signedInt16(glyf[6], glyf[7]);
1873       const yMax = signedInt16(glyf[8], glyf[9]);
1874 
1875       if (xMin > xMax) {
1876         writeSignedInt16(glyf, 2, xMax);
1877         writeSignedInt16(glyf, 6, xMin);
1878       }
1879       if (yMin > yMax) {
1880         writeSignedInt16(glyf, 4, yMax);
1881         writeSignedInt16(glyf, 8, yMin);
1882       }
1883 
1884       const contoursCount = signedInt16(glyf[0], glyf[1]);
1885       if (contoursCount < 0) {
1886         if (contoursCount < -1) {
1887           // OTS doesn't like contour count to be less than -1.
1888           // The glyph data offsets are very likely wrong and
1889           // having something lower than -1, very likely, implies
1890           // to have some garbage data.
1891           return glyphProfile;
1892         }
1893         // complex glyph, writing as is
1894         dest.set(glyf, destStart);
1895         glyphProfile.length = glyf.length;
1896         return glyphProfile;
1897       }
1898 
1899       let i,
1900         j = 10,
1901         flagsCount = 0;
1902       for (i = 0; i < contoursCount; i++) {
1903         const endPoint = (glyf[j] << 8) | glyf[j + 1];
1904         flagsCount = endPoint + 1;
1905         j += 2;
1906       }
1907       // skipping instructions
1908       const instructionsStart = j;
1909       const instructionsLength = (glyf[j] << 8) | glyf[j + 1];
1910       glyphProfile.sizeOfInstructions = instructionsLength;
1911       j += 2 + instructionsLength;
1912       const instructionsEnd = j;
1913       // validating flags
1914       let coordinatesLength = 0;
1915       for (i = 0; i < flagsCount; i++) {
1916         const flag = glyf[j++];
1917         if (flag & 0xc0) {
1918           // reserved flags must be zero, cleaning up
1919           glyf[j - 1] = flag & 0x3f;
1920         }
1921         let xLength = 2;
1922         if (flag & 2) {
1923           xLength = 1;
1924         } else if (flag & 16) {
1925           xLength = 0;
1926         }
1927         let yLength = 2;
1928         if (flag & 4) {
1929           yLength = 1;
1930         } else if (flag & 32) {
1931           yLength = 0;
1932         }
1933         const xyLength = xLength + yLength;
1934         coordinatesLength += xyLength;
1935         if (flag & 8) {
1936           const repeat = glyf[j++];
1937           if (repeat === 0) {
1938             // The repeat count should be non-zero when the repeat flag is set.
1939             glyf[j - 1] ^= 8;
1940           }
1941           i += repeat;
1942           coordinatesLength += repeat * xyLength;
1943         }
1944       }
1945       // glyph without coordinates will be rejected
1946       if (coordinatesLength === 0) {
1947         return glyphProfile;
1948       }
1949       let glyphDataLength = j + coordinatesLength;
1950       if (glyphDataLength > glyf.length) {
1951         // not enough data for coordinates
1952         return glyphProfile;
1953       }
1954       if (!hintsValid && instructionsLength > 0) {
1955         dest.set(glyf.subarray(0, instructionsStart), destStart);
1956         dest.set([0, 0], destStart + instructionsStart);
1957         dest.set(
1958           glyf.subarray(instructionsEnd, glyphDataLength),
1959           destStart + instructionsStart + 2
1960         );
1961         glyphDataLength -= instructionsLength;
1962         if (glyf.length - glyphDataLength > 3) {
1963           glyphDataLength = (glyphDataLength + 3) & ~3;
1964         }
1965         glyphProfile.length = glyphDataLength;
1966         return glyphProfile;
1967       }
1968       if (glyf.length - glyphDataLength > 3) {
1969         // truncating and aligning to 4 bytes the long glyph data
1970         glyphDataLength = (glyphDataLength + 3) & ~3;
1971         dest.set(glyf.subarray(0, glyphDataLength), destStart);
1972         glyphProfile.length = glyphDataLength;
1973         return glyphProfile;
1974       }
1975       // glyph data is fine
1976       dest.set(glyf, destStart);
1977       glyphProfile.length = glyf.length;
1978       return glyphProfile;
1979     }
1980 
1981     function sanitizeHead(head, numGlyphs, locaLength) {
1982       const data = head.data;
1983 
1984       // Validate version:
1985       // Should always be 0x00010000
1986       const version = int32(data[0], data[1], data[2], data[3]);
1987       if (version >> 16 !== 1) {
1988         info("Attempting to fix invalid version in head table: " + version);
1989         data[0] = 0;
1990         data[1] = 1;
1991         data[2] = 0;
1992         data[3] = 0;
1993       }
1994 
1995       const indexToLocFormat = int16(data[50], data[51]);
1996       if (indexToLocFormat < 0 || indexToLocFormat > 1) {
1997         info(
1998           "Attempting to fix invalid indexToLocFormat in head table: " +
1999             indexToLocFormat
2000         );
2001 
2002         // The value of indexToLocFormat should be 0 if the loca table
2003         // consists of short offsets, and should be 1 if the loca table
2004         // consists of long offsets.
2005         //
2006         // The number of entries in the loca table should be numGlyphs + 1.
2007         //
2008         // Using this information, we can work backwards to deduce if the
2009         // size of each offset in the loca table, and thus figure out the
2010         // appropriate value for indexToLocFormat.
2011 
2012         const numGlyphsPlusOne = numGlyphs + 1;
2013         if (locaLength === numGlyphsPlusOne << 1) {
2014           // 0x0000 indicates the loca table consists of short offsets
2015           data[50] = 0;
2016           data[51] = 0;
2017         } else if (locaLength === numGlyphsPlusOne << 2) {
2018           // 0x0001 indicates the loca table consists of long offsets
2019           data[50] = 0;
2020           data[51] = 1;
2021         } else {
2022           throw new FormatError(
2023             "Could not fix indexToLocFormat: " + indexToLocFormat
2024           );
2025         }
2026       }
2027     }
2028 
2029     function sanitizeGlyphLocations(
2030       loca,
2031       glyf,
2032       numGlyphs,
2033       isGlyphLocationsLong,
2034       hintsValid,
2035       dupFirstEntry,
2036       maxSizeOfInstructions
2037     ) {
2038       let itemSize, itemDecode, itemEncode;
2039       if (isGlyphLocationsLong) {
2040         itemSize = 4;
2041         itemDecode = function fontItemDecodeLong(data, offset) {
2042           return (
2043             (data[offset] << 24) |
2044             (data[offset + 1] << 16) |
2045             (data[offset + 2] << 8) |
2046             data[offset + 3]
2047           );
2048         };
2049         itemEncode = function fontItemEncodeLong(data, offset, value) {
2050           data[offset] = (value >>> 24) & 0xff;
2051           data[offset + 1] = (value >> 16) & 0xff;
2052           data[offset + 2] = (value >> 8) & 0xff;
2053           data[offset + 3] = value & 0xff;
2054         };
2055       } else {
2056         itemSize = 2;
2057         itemDecode = function fontItemDecode(data, offset) {
2058           return (data[offset] << 9) | (data[offset + 1] << 1);
2059         };
2060         itemEncode = function fontItemEncode(data, offset, value) {
2061           data[offset] = (value >> 9) & 0xff;
2062           data[offset + 1] = (value >> 1) & 0xff;
2063         };
2064       }
2065       // The first glyph is duplicated.
2066       const numGlyphsOut = dupFirstEntry ? numGlyphs + 1 : numGlyphs;
2067       const locaDataSize = itemSize * (1 + numGlyphsOut);
2068       // Resize loca table to account for duplicated glyph.
2069       const locaData = new Uint8Array(locaDataSize);
2070       locaData.set(loca.data.subarray(0, locaDataSize));
2071       loca.data = locaData;
2072       // removing the invalid glyphs
2073       const oldGlyfData = glyf.data;
2074       const oldGlyfDataLength = oldGlyfData.length;
2075       const newGlyfData = new Uint8Array(oldGlyfDataLength);
2076 
2077       // The spec says the offsets should be in ascending order, however
2078       // this is not true for some fonts or they use the offset of 0 to mark a
2079       // glyph as missing. OTS requires the offsets to be in order and not to
2080       // be zero, so we must sort and rebuild the loca table and potentially
2081       // re-arrange the glyf data.
2082       let i, j;
2083       const locaEntries = [];
2084       // There are numGlyphs + 1 loca table entries.
2085       for (i = 0, j = 0; i < numGlyphs + 1; i++, j += itemSize) {
2086         let offset = itemDecode(locaData, j);
2087         if (offset > oldGlyfDataLength) {
2088           offset = oldGlyfDataLength;
2089         }
2090         locaEntries.push({
2091           index: i,
2092           offset,
2093           endOffset: 0,
2094         });
2095       }
2096       locaEntries.sort((a, b) => a.offset - b.offset);
2097       // Now the offsets are sorted, calculate the end offset of each glyph.
2098       // The last loca entry's endOffset is not calculated since it's the end
2099       // of the data and will be stored on the previous entry's endOffset.
2100       for (i = 0; i < numGlyphs; i++) {
2101         locaEntries[i].endOffset = locaEntries[i + 1].offset;
2102       }
2103       // Re-sort so glyphs aren't out of order.
2104       locaEntries.sort((a, b) => a.index - b.index);
2105       // Calculate the endOffset of the "first" glyph correctly when there are
2106       // *multiple* empty ones at the start of the data (fixes issue14618.pdf).
2107       for (i = 0; i < numGlyphs; i++) {
2108         const { offset, endOffset } = locaEntries[i];
2109         if (offset !== 0 || endOffset !== 0) {
2110           break;
2111         }
2112         const nextOffset = locaEntries[i + 1].offset;
2113         if (nextOffset === 0) {
2114           continue;
2115         }
2116         locaEntries[i].endOffset = nextOffset;
2117         break;
2118       }
2119 
2120       const missingGlyphs = Object.create(null);
2121       let writeOffset = 0;
2122       itemEncode(locaData, 0, writeOffset);
2123       for (i = 0, j = itemSize; i < numGlyphs; i++, j += itemSize) {
2124         const glyphProfile = sanitizeGlyph(
2125           oldGlyfData,
2126           locaEntries[i].offset,
2127           locaEntries[i].endOffset,
2128           newGlyfData,
2129           writeOffset,
2130           hintsValid
2131         );
2132         const newLength = glyphProfile.length;
2133         if (newLength === 0) {
2134           missingGlyphs[i] = true;
2135         }
2136         if (glyphProfile.sizeOfInstructions > maxSizeOfInstructions) {
2137           maxSizeOfInstructions = glyphProfile.sizeOfInstructions;
2138         }
2139         writeOffset += newLength;
2140         itemEncode(locaData, j, writeOffset);
2141       }
2142 
2143       if (writeOffset === 0) {
2144         // glyf table cannot be empty -- redoing the glyf and loca tables
2145         // to have single glyph with one point
2146         const simpleGlyph = new Uint8Array([
2147           0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 49, 0,
2148         ]);
2149         for (i = 0, j = itemSize; i < numGlyphsOut; i++, j += itemSize) {
2150           itemEncode(locaData, j, simpleGlyph.length);
2151         }
2152         glyf.data = simpleGlyph;
2153       } else if (dupFirstEntry) {
2154         // Browsers will not display a glyph at position 0. Typically glyph 0
2155         // is notdef, but a number of fonts put a valid glyph there so it must
2156         // be duplicated and appended.
2157         const firstEntryLength = itemDecode(locaData, itemSize);
2158         if (newGlyfData.length > firstEntryLength + writeOffset) {
2159           glyf.data = newGlyfData.subarray(0, firstEntryLength + writeOffset);
2160         } else {
2161           glyf.data = new Uint8Array(firstEntryLength + writeOffset);
2162           glyf.data.set(newGlyfData.subarray(0, writeOffset));
2163         }
2164         glyf.data.set(newGlyfData.subarray(0, firstEntryLength), writeOffset);
2165         itemEncode(
2166           loca.data,
2167           locaData.length - itemSize,
2168           writeOffset + firstEntryLength
2169         );
2170       } else {
2171         glyf.data = newGlyfData.subarray(0, writeOffset);
2172       }
2173       return {
2174         missingGlyphs,
2175         maxSizeOfInstructions,
2176       };
2177     }
2178 
2179     function readPostScriptTable(post, propertiesObj, maxpNumGlyphs) {
2180       const start = (font.start || 0) + post.offset;
2181       font.pos = start;
2182 
2183       const length = post.length,
2184         end = start + length;
2185       const version = font.getInt32();
2186       // skip rest to the tables
2187       font.skip(28);
2188 
2189       let glyphNames;
2190       let valid = true;
2191       let i;
2192 
2193       switch (version) {
2194         case 0x00010000:
2195           glyphNames = MacStandardGlyphOrdering;
2196           break;
2197         case 0x00020000:
2198           const numGlyphs = font.getUint16();
2199           if (numGlyphs !== maxpNumGlyphs) {
2200             valid = false;
2201             break;
2202           }
2203           const glyphNameIndexes = [];
2204           for (i = 0; i < numGlyphs; ++i) {
2205             const index = font.getUint16();
2206             if (index >= 32768) {
2207               valid = false;
2208               break;
2209             }
2210             glyphNameIndexes.push(index);
2211           }
2212           if (!valid) {
2213             break;
2214           }
2215           const customNames = [],
2216             strBuf = [];
2217           while (font.pos < end) {
2218             const stringLength = font.getByte();
2219             strBuf.length = stringLength;
2220             for (i = 0; i < stringLength; ++i) {
2221               strBuf[i] = String.fromCharCode(font.getByte());
2222             }
2223             customNames.push(strBuf.join(""));
2224           }
2225           glyphNames = [];
2226           for (i = 0; i < numGlyphs; ++i) {
2227             const j = glyphNameIndexes[i];
2228             if (j < 258) {
2229               glyphNames.push(MacStandardGlyphOrdering[j]);
2230               continue;
2231             }
2232             glyphNames.push(customNames[j - 258]);
2233           }
2234           break;
2235         case 0x00030000:
2236           break;
2237         default:
2238           warn("Unknown/unsupported post table version " + version);
2239           valid = false;
2240           if (propertiesObj.defaultEncoding) {
2241             glyphNames = propertiesObj.defaultEncoding;
2242           }
2243           break;
2244       }
2245       propertiesObj.glyphNames = glyphNames;
2246       return valid;
2247     }
2248 
2249     function readNameTable(nameTable) {
2250       const start = (font.start || 0) + nameTable.offset;
2251       font.pos = start;
2252 
2253       const names = [[], []],
2254         records = [];
2255       const length = nameTable.length,
2256         end = start + length;
2257       const format = font.getUint16();
2258       const FORMAT_0_HEADER_LENGTH = 6;
2259       if (format !== 0 || length < FORMAT_0_HEADER_LENGTH) {
2260         // unsupported name table format or table "too" small
2261         return [names, records];
2262       }
2263       const numRecords = font.getUint16();
2264       const stringsStart = font.getUint16();
2265       const NAME_RECORD_LENGTH = 12;
2266       let i, ii;
2267 
2268       for (i = 0; i < numRecords && font.pos + NAME_RECORD_LENGTH <= end; i++) {
2269         const r = {
2270           platform: font.getUint16(),
2271           encoding: font.getUint16(),
2272           language: font.getUint16(),
2273           name: font.getUint16(),
2274           length: font.getUint16(),
2275           offset: font.getUint16(),
2276         };
2277         // using only Macintosh and Windows platform/encoding names
2278         if (isMacNameRecord(r) || isWinNameRecord(r)) {
2279           records.push(r);
2280         }
2281       }
2282       for (i = 0, ii = records.length; i < ii; i++) {
2283         const record = records[i];
2284         if (record.length <= 0) {
2285           continue; // Nothing to process, ignoring.
2286         }
2287         const pos = start + stringsStart + record.offset;
2288         if (pos + record.length > end) {
2289           continue; // outside of name table, ignoring
2290         }
2291         font.pos = pos;
2292         const nameIndex = record.name;
2293         if (record.encoding) {
2294           // unicode
2295           let str = "";
2296           for (let j = 0, jj = record.length; j < jj; j += 2) {
2297             str += String.fromCharCode(font.getUint16());
2298           }
2299           names[1][nameIndex] = str;
2300         } else {
2301           names[0][nameIndex] = font.getString(record.length);
2302         }
2303       }
2304       return [names, records];
2305     }
2306 
2307     // prettier-ignore
2308     const TTOpsStackDeltas = [
2309       0, 0, 0, 0, 0, 0, 0, 0, -2, -2, -2, -2, 0, 0, -2, -5,
2310       -1, -1, -1, -1, -1, -1, -1, -1, 0, 0, -1, 0, -1, -1, -1, -1,
2311       1, -1, -999, 0, 1, 0, -1, -2, 0, -1, -2, -1, -1, 0, -1, -1,
2312       0, 0, -999, -999, -1, -1, -1, -1, -2, -999, -2, -2, -999, 0, -2, -2,
2313       0, 0, -2, 0, -2, 0, 0, 0, -2, -1, -1, 1, 1, 0, 0, -1,
2314       -1, -1, -1, -1, -1, -1, 0, 0, -1, 0, -1, -1, 0, -999, -1, -1,
2315       -1, -1, -1, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
2316       -2, -999, -999, -999, -999, -999, -1, -1, -2, -2, 0, 0, 0, 0, -1, -1,
2317       -999, -2, -2, 0, 0, -1, -2, -2, 0, 0, 0, -1, -1, -1, -2];
2318     // 0xC0-DF == -1 and 0xE0-FF == -2
2319 
2320     function sanitizeTTProgram(table, ttContext) {
2321       let data = table.data;
2322       let i = 0,
2323         j,
2324         n,
2325         b,
2326         funcId,
2327         pc,
2328         lastEndf = 0,
2329         lastDeff = 0;
2330       const stack = [];
2331       const callstack = [];
2332       const functionsCalled = [];
2333       let tooComplexToFollowFunctions = ttContext.tooComplexToFollowFunctions;
2334       let inFDEF = false,
2335         ifLevel = 0,
2336         inELSE = 0;
2337       for (let ii = data.length; i < ii; ) {
2338         const op = data[i++];
2339         // The TrueType instruction set docs can be found at
2340         // https://developer.apple.com/fonts/TTRefMan/RM05/Chap5.html
2341         if (op === 0x40) {
2342           // NPUSHB - pushes n bytes
2343           n = data[i++];
2344           if (inFDEF || inELSE) {
2345             i += n;
2346           } else {
2347             for (j = 0; j < n; j++) {
2348               stack.push(data[i++]);
2349             }
2350           }
2351         } else if (op === 0x41) {
2352           // NPUSHW - pushes n words
2353           n = data[i++];
2354           if (inFDEF || inELSE) {
2355             i += n * 2;
2356           } else {
2357             for (j = 0; j < n; j++) {
2358               b = data[i++];
2359               stack.push((b << 8) | data[i++]);
2360             }
2361           }
2362         } else if ((op & 0xf8) === 0xb0) {
2363           // PUSHB - pushes bytes
2364           n = op - 0xb0 + 1;
2365           if (inFDEF || inELSE) {
2366             i += n;
2367           } else {
2368             for (j = 0; j < n; j++) {
2369               stack.push(data[i++]);
2370             }
2371           }
2372         } else if ((op & 0xf8) === 0xb8) {
2373           // PUSHW - pushes words
2374           n = op - 0xb8 + 1;
2375           if (inFDEF || inELSE) {
2376             i += n * 2;
2377           } else {
2378             for (j = 0; j < n; j++) {
2379               b = data[i++];
2380               stack.push((b << 8) | data[i++]);
2381             }
2382           }
2383         } else if (op === 0x2b && !tooComplexToFollowFunctions) {
2384           // CALL
2385           if (!inFDEF && !inELSE) {
2386             // collecting information about which functions are used
2387             funcId = stack.at(-1);
2388             if (isNaN(funcId)) {
2389               info("TT: CALL empty stack (or invalid entry).");
2390             } else {
2391               ttContext.functionsUsed[funcId] = true;
2392               if (funcId in ttContext.functionsStackDeltas) {
2393                 const newStackLength =
2394                   stack.length + ttContext.functionsStackDeltas[funcId];
2395                 if (newStackLength < 0) {
2396                   warn("TT: CALL invalid functions stack delta.");
2397                   ttContext.hintsValid = false;
2398                   return;
2399                 }
2400                 stack.length = newStackLength;
2401               } else if (
2402                 funcId in ttContext.functionsDefined &&
2403                 !functionsCalled.includes(funcId)
2404               ) {
2405                 callstack.push({ data, i, stackTop: stack.length - 1 });
2406                 functionsCalled.push(funcId);
2407                 pc = ttContext.functionsDefined[funcId];
2408                 if (!pc) {
2409                   warn("TT: CALL non-existent function");
2410                   ttContext.hintsValid = false;
2411                   return;
2412                 }
2413                 data = pc.data;
2414                 i = pc.i;
2415               }
2416             }
2417           }
2418         } else if (op === 0x2c && !tooComplexToFollowFunctions) {
2419           // FDEF
2420           if (inFDEF || inELSE) {
2421             warn("TT: nested FDEFs not allowed");
2422             tooComplexToFollowFunctions = true;
2423           }
2424           inFDEF = true;
2425           // collecting information about which functions are defined
2426           lastDeff = i;
2427           funcId = stack.pop();
2428           ttContext.functionsDefined[funcId] = { data, i };
2429         } else if (op === 0x2d) {
2430           // ENDF - end of function
2431           if (inFDEF) {
2432             inFDEF = false;
2433             lastEndf = i;
2434           } else {
2435             pc = callstack.pop();
2436             if (!pc) {
2437               warn("TT: ENDF bad stack");
2438               ttContext.hintsValid = false;
2439               return;
2440             }
2441             funcId = functionsCalled.pop();
2442             data = pc.data;
2443             i = pc.i;
2444             ttContext.functionsStackDeltas[funcId] = stack.length - pc.stackTop;
2445           }
2446         } else if (op === 0x89) {
2447           // IDEF - instruction definition
2448           if (inFDEF || inELSE) {
2449             warn("TT: nested IDEFs not allowed");
2450             tooComplexToFollowFunctions = true;
2451           }
2452           inFDEF = true;
2453           // recording it as a function to track ENDF
2454           lastDeff = i;
2455         } else if (op === 0x58) {
2456           // IF
2457           ++ifLevel;
2458         } else if (op === 0x1b) {
2459           // ELSE
2460           inELSE = ifLevel;
2461         } else if (op === 0x59) {
2462           // EIF
2463           if (inELSE === ifLevel) {
2464             inELSE = 0;
2465           }
2466           --ifLevel;
2467         } else if (op === 0x1c) {
2468           // JMPR
2469           if (!inFDEF && !inELSE) {
2470             const offset = stack.at(-1);
2471             // only jumping forward to prevent infinite loop
2472             if (offset > 0) {
2473               i += offset - 1;
2474             }
2475           }
2476         }
2477         // Adjusting stack not extactly, but just enough to get function id
2478         if (!inFDEF && !inELSE) {
2479           let stackDelta = 0;
2480           if (op <= 0x8e) {
2481             stackDelta = TTOpsStackDeltas[op];
2482           } else if (op >= 0xc0 && op <= 0xdf) {
2483             stackDelta = -1;
2484           } else if (op >= 0xe0) {
2485             stackDelta = -2;
2486           }
2487           if (op >= 0x71 && op <= 0x75) {
2488             n = stack.pop();
2489             if (!isNaN(n)) {
2490               stackDelta = -n * 2;
2491             }
2492           }
2493           while (stackDelta < 0 && stack.length > 0) {
2494             stack.pop();
2495             stackDelta++;
2496           }
2497           while (stackDelta > 0) {
2498             stack.push(NaN); // pushing any number into stack
2499             stackDelta--;
2500           }
2501         }
2502       }
2503       ttContext.tooComplexToFollowFunctions = tooComplexToFollowFunctions;
2504       const content = [data];
2505       if (i > data.length) {
2506         content.push(new Uint8Array(i - data.length));
2507       }
2508       if (lastDeff > lastEndf) {
2509         warn("TT: complementing a missing function tail");
2510         // new function definition started, but not finished
2511         // complete function by [CLEAR, ENDF]
2512         content.push(new Uint8Array([0x22, 0x2d]));
2513       }
2514       foldTTTable(table, content);
2515     }
2516 
2517     function checkInvalidFunctions(ttContext, maxFunctionDefs) {
2518       if (ttContext.tooComplexToFollowFunctions) {
2519         return;
2520       }
2521       if (ttContext.functionsDefined.length > maxFunctionDefs) {
2522         warn("TT: more functions defined than expected");
2523         ttContext.hintsValid = false;
2524         return;
2525       }
2526       for (let j = 0, jj = ttContext.functionsUsed.length; j < jj; j++) {
2527         if (j > maxFunctionDefs) {
2528           warn("TT: invalid function id: " + j);
2529           ttContext.hintsValid = false;
2530           return;
2531         }
2532         if (ttContext.functionsUsed[j] && !ttContext.functionsDefined[j]) {
2533           warn("TT: undefined function: " + j);
2534           ttContext.hintsValid = false;
2535           return;
2536         }
2537       }
2538     }
2539 
2540     function foldTTTable(table, content) {
2541       if (content.length > 1) {
2542         // concatenating the content items
2543         let newLength = 0;
2544         let j, jj;
2545         for (j = 0, jj = content.length; j < jj; j++) {
2546           newLength += content[j].length;
2547         }
2548         newLength = (newLength + 3) & ~3;
2549         const result = new Uint8Array(newLength);
2550         let pos = 0;
2551         for (j = 0, jj = content.length; j < jj; j++) {
2552           result.set(content[j], pos);
2553           pos += content[j].length;
2554         }
2555         table.data = result;
2556         table.length = newLength;
2557       }
2558     }
2559 
2560     function sanitizeTTPrograms(fpgm, prep, cvt, maxFunctionDefs) {
2561       const ttContext = {
2562         functionsDefined: [],
2563         functionsUsed: [],
2564         functionsStackDeltas: [],
2565         tooComplexToFollowFunctions: false,
2566         hintsValid: true,
2567       };
2568       if (fpgm) {
2569         sanitizeTTProgram(fpgm, ttContext);
2570       }
2571       if (prep) {
2572         sanitizeTTProgram(prep, ttContext);
2573       }
2574       if (fpgm) {
2575         checkInvalidFunctions(ttContext, maxFunctionDefs);
2576       }
2577       if (cvt && cvt.length & 1) {
2578         const cvtData = new Uint8Array(cvt.length + 1);
2579         cvtData.set(cvt.data);
2580         cvt.data = cvtData;
2581       }
2582       return ttContext.hintsValid;
2583     }
2584 
2585     // The following steps modify the original font data, making copy
2586     font = new Stream(new Uint8Array(font.getBytes()));
2587 
2588     let header, tables;
2589     if (isTrueTypeCollectionFile(font)) {
2590       const ttcData = readTrueTypeCollectionData(font, this.name);
2591       header = ttcData.header;
2592       tables = ttcData.tables;
2593     } else {
2594       header = readOpenTypeHeader(font);
2595       tables = readTables(font, header.numTables);
2596     }
2597     let cff, cffFile;
2598 
2599     const isTrueType = !tables["CFF "];
2600     if (!isTrueType) {
2601       const isComposite =
2602         properties.composite &&
2603         (properties.cidToGidMap?.length > 0 ||
2604           !(properties.cMap instanceof IdentityCMap));
2605       // OpenType font (skip composite fonts with non-default glyph mapping).
2606       if (
2607         (header.version === "OTTO" && !isComposite) ||
2608         !tables.head ||
2609         !tables.hhea ||
2610         !tables.maxp ||
2611         !tables.post
2612       ) {
2613         // No major tables: throwing everything at `CFFFont`.
2614         cffFile = new Stream(tables["CFF "].data);
2615         cff = new CFFFont(cffFile, properties);
2616 
2617         adjustWidths(properties);
2618 
2619         return this.convert(name, cff, properties);
2620       }
2621 
2622       delete tables.glyf;
2623       delete tables.loca;
2624       delete tables.fpgm;
2625       delete tables.prep;
2626       delete tables["cvt "];
2627       this.isOpenType = true;
2628     } else {
2629       if (!tables.loca) {
2630         throw new FormatError('Required "loca" table is not found');
2631       }
2632       if (!tables.glyf) {
2633         warn('Required "glyf" table is not found -- trying to recover.');
2634         // Note: We use `sanitizeGlyphLocations` to add dummy glyf data below.
2635         tables.glyf = {
2636           tag: "glyf",
2637           data: new Uint8Array(0),
2638         };
2639       }
2640       this.isOpenType = false;
2641     }
2642 
2643     if (!tables.maxp) {
2644       throw new FormatError('Required "maxp" table is not found');
2645     }
2646 
2647     font.pos = (font.start || 0) + tables.maxp.offset;
2648     let version = font.getInt32();
2649     const numGlyphs = font.getUint16();
2650 
2651     if (version !== 0x00010000 && version !== 0x00005000) {
2652       // https://learn.microsoft.com/en-us/typography/opentype/spec/maxp
2653       if (tables.maxp.length === 6) {
2654         version = 0x0005000;
2655       } else if (tables.maxp.length >= 32) {
2656         version = 0x00010000;
2657       } else {
2658         throw new FormatError(`"maxp" table has a wrong version number`);
2659       }
2660       writeUint32(tables.maxp.data, 0, version);
2661     }
2662 
2663     if (properties.scaleFactors?.length === numGlyphs && isTrueType) {
2664       const { scaleFactors } = properties;
2665       const isGlyphLocationsLong = int16(
2666         tables.head.data[50],
2667         tables.head.data[51]
2668       );
2669 
2670       const glyphs = new GlyfTable({
2671         glyfTable: tables.glyf.data,
2672         isGlyphLocationsLong,
2673         locaTable: tables.loca.data,
2674         numGlyphs,
2675       });
2676       glyphs.scale(scaleFactors);
2677 
2678       const { glyf, loca, isLocationLong } = glyphs.write();
2679       tables.glyf.data = glyf;
2680       tables.loca.data = loca;
2681 
2682       if (isLocationLong !== !!isGlyphLocationsLong) {
2683         tables.head.data[50] = 0;
2684         tables.head.data[51] = isLocationLong ? 1 : 0;
2685       }
2686 
2687       const metrics = tables.hmtx.data;
2688 
2689       for (let i = 0; i < numGlyphs; i++) {
2690         const j = 4 * i;
2691         const advanceWidth = Math.round(
2692           scaleFactors[i] * int16(metrics[j], metrics[j + 1])
2693         );
2694         metrics[j] = (advanceWidth >> 8) & 0xff;
2695         metrics[j + 1] = advanceWidth & 0xff;
2696         const lsb = Math.round(
2697           scaleFactors[i] * signedInt16(metrics[j + 2], metrics[j + 3])
2698         );
2699         writeSignedInt16(metrics, j + 2, lsb);
2700       }
2701     }
2702 
2703     // Glyph 0 is duplicated and appended.
2704     let numGlyphsOut = numGlyphs + 1;
2705     let dupFirstEntry = true;
2706     if (numGlyphsOut > 0xffff) {
2707       dupFirstEntry = false;
2708       numGlyphsOut = numGlyphs;
2709       warn("Not enough space in glyfs to duplicate first glyph.");
2710     }
2711     let maxFunctionDefs = 0;
2712     let maxSizeOfInstructions = 0;
2713     if (version >= 0x00010000 && tables.maxp.length >= 32) {
2714       // maxZones can be invalid
2715       font.pos += 8;
2716       const maxZones = font.getUint16();
2717       if (maxZones > 2) {
2718         // reset to 2 if font has invalid maxZones
2719         tables.maxp.data[14] = 0;
2720         tables.maxp.data[15] = 2;
2721       }
2722       font.pos += 4;
2723       maxFunctionDefs = font.getUint16();
2724       font.pos += 4;
2725       maxSizeOfInstructions = font.getUint16();
2726     }
2727 
2728     tables.maxp.data[4] = numGlyphsOut >> 8;
2729     tables.maxp.data[5] = numGlyphsOut & 255;
2730 
2731     const hintsValid = sanitizeTTPrograms(
2732       tables.fpgm,
2733       tables.prep,
2734       tables["cvt "],
2735       maxFunctionDefs
2736     );
2737     if (!hintsValid) {
2738       delete tables.fpgm;
2739       delete tables.prep;
2740       delete tables["cvt "];
2741     }
2742 
2743     // Ensure the hmtx table contains the advance width and
2744     // sidebearings information for numGlyphs in the maxp table
2745     sanitizeMetrics(
2746       font,
2747       tables.hhea,
2748       tables.hmtx,
2749       tables.head,
2750       numGlyphsOut,
2751       dupFirstEntry
2752     );
2753 
2754     if (!tables.head) {
2755       throw new FormatError('Required "head" table is not found');
2756     }
2757 
2758     sanitizeHead(tables.head, numGlyphs, isTrueType ? tables.loca.length : 0);
2759 
2760     let missingGlyphs = Object.create(null);
2761     if (isTrueType) {
2762       const isGlyphLocationsLong = int16(
2763         tables.head.data[50],
2764         tables.head.data[51]
2765       );
2766       const glyphsInfo = sanitizeGlyphLocations(
2767         tables.loca,
2768         tables.glyf,
2769         numGlyphs,
2770         isGlyphLocationsLong,
2771         hintsValid,
2772         dupFirstEntry,
2773         maxSizeOfInstructions
2774       );
2775       missingGlyphs = glyphsInfo.missingGlyphs;
2776 
2777       // Some fonts have incorrect maxSizeOfInstructions values, so we use
2778       // the computed value instead.
2779       if (version >= 0x00010000 && tables.maxp.length >= 32) {
2780         tables.maxp.data[26] = glyphsInfo.maxSizeOfInstructions >> 8;
2781         tables.maxp.data[27] = glyphsInfo.maxSizeOfInstructions & 255;
2782       }
2783     }
2784     if (!tables.hhea) {
2785       throw new FormatError('Required "hhea" table is not found');
2786     }
2787 
2788     // Sanitizer reduces the glyph advanceWidth to the maxAdvanceWidth
2789     // Sometimes it's 0. That needs to be fixed
2790     if (tables.hhea.data[10] === 0 && tables.hhea.data[11] === 0) {
2791       tables.hhea.data[10] = 0xff;
2792       tables.hhea.data[11] = 0xff;
2793     }
2794 
2795     // Extract some more font properties from the OpenType head and
2796     // hhea tables; yMin and descent value are always negative.
2797     const metricsOverride = {
2798       unitsPerEm: int16(tables.head.data[18], tables.head.data[19]),
2799       yMax: signedInt16(tables.head.data[42], tables.head.data[43]),
2800       yMin: signedInt16(tables.head.data[38], tables.head.data[39]),
2801       ascent: signedInt16(tables.hhea.data[4], tables.hhea.data[5]),
2802       descent: signedInt16(tables.hhea.data[6], tables.hhea.data[7]),
2803       lineGap: signedInt16(tables.hhea.data[8], tables.hhea.data[9]),
2804     };
2805 
2806     // PDF FontDescriptor metrics lie -- using data from actual font.
2807     this.ascent = metricsOverride.ascent / metricsOverride.unitsPerEm;
2808     this.descent = metricsOverride.descent / metricsOverride.unitsPerEm;
2809     this.lineGap = metricsOverride.lineGap / metricsOverride.unitsPerEm;
2810 
2811     if (this.cssFontInfo?.lineHeight) {
2812       this.lineHeight = this.cssFontInfo.metrics.lineHeight;
2813       this.lineGap = this.cssFontInfo.metrics.lineGap;
2814     } else {
2815       this.lineHeight = this.ascent - this.descent + this.lineGap;
2816     }
2817 
2818     // The 'post' table has glyphs names.
2819     if (tables.post) {
2820       readPostScriptTable(tables.post, properties, numGlyphs);
2821     }
2822 
2823     // The original 'post' table is not needed, replace it.
2824     tables.post = {
2825       tag: "post",
2826       data: createPostTable(properties),
2827     };
2828 
2829     const charCodeToGlyphId = [];
2830 
2831     // Helper function to try to skip mapping of empty glyphs.
2832     function hasGlyph(glyphId) {
2833       return !missingGlyphs[glyphId];
2834     }
2835 
2836     if (properties.composite) {
2837       const cidToGidMap = properties.cidToGidMap || [];
2838       const isCidToGidMapEmpty = cidToGidMap.length === 0;
2839 
2840       properties.cMap.forEach(function (charCode, cid) {
2841         if (typeof cid === "string") {
2842           cid = convertCidString(charCode, cid, /* shouldThrow = */ true);
2843         }
2844         if (cid > 0xffff) {
2845           throw new FormatError("Max size of CID is 65,535");
2846         }
2847         let glyphId = -1;
2848         if (isCidToGidMapEmpty) {
2849           glyphId = cid;
2850         } else if (cidToGidMap[cid] !== undefined) {
2851           glyphId = cidToGidMap[cid];
2852         }
2853 
2854         if (glyphId >= 0 && glyphId < numGlyphs && hasGlyph(glyphId)) {
2855           charCodeToGlyphId[charCode] = glyphId;
2856         }
2857       });
2858     } else {
2859       // Most of the following logic in this code branch is based on the
2860       // 9.6.6.4 of the PDF spec.
2861       const cmapTable = readCmapTable(
2862         tables.cmap,
2863         font,
2864         this.isSymbolicFont,
2865         properties.hasEncoding
2866       );
2867       const cmapPlatformId = cmapTable.platformId;
2868       const cmapEncodingId = cmapTable.encodingId;
2869       const cmapMappings = cmapTable.mappings;
2870       let baseEncoding = [],
2871         forcePostTable = false;
2872       if (
2873         properties.hasEncoding &&
2874         (properties.baseEncodingName === "MacRomanEncoding" ||
2875           properties.baseEncodingName === "WinAnsiEncoding")
2876       ) {
2877         baseEncoding = getEncoding(properties.baseEncodingName);
2878       }
2879 
2880       // If the font has an encoding and is not symbolic then follow the rules
2881       // in section 9.6.6.4 of the spec on how to map 3,1 and 1,0 cmaps.
2882       if (
2883         properties.hasEncoding &&
2884         !this.isSymbolicFont &&
2885         ((cmapPlatformId === 3 && cmapEncodingId === 1) ||
2886           (cmapPlatformId === 1 && cmapEncodingId === 0))
2887       ) {
2888         const glyphsUnicodeMap = getGlyphsUnicode();
2889         for (let charCode = 0; charCode < 256; charCode++) {
2890           let glyphName;
2891           if (this.differences[charCode] !== undefined) {
2892             glyphName = this.differences[charCode];
2893           } else if (baseEncoding.length && baseEncoding[charCode] !== "") {
2894             glyphName = baseEncoding[charCode];
2895           } else {
2896             glyphName = StandardEncoding[charCode];
2897           }
2898           if (!glyphName) {
2899             continue;
2900           }
2901           // Ensure that non-standard glyph names are resolved to valid ones.
2902           const standardGlyphName = recoverGlyphName(
2903             glyphName,
2904             glyphsUnicodeMap
2905           );
2906 
2907           let unicodeOrCharCode;
2908           if (cmapPlatformId === 3 && cmapEncodingId === 1) {
2909             unicodeOrCharCode = glyphsUnicodeMap[standardGlyphName];
2910           } else if (cmapPlatformId === 1 && cmapEncodingId === 0) {
2911             // TODO: the encoding needs to be updated with mac os table.
2912             unicodeOrCharCode = MacRomanEncoding.indexOf(standardGlyphName);
2913           }
2914 
2915           if (unicodeOrCharCode === undefined) {
2916             // Not a valid glyph name, fallback to using the /ToUnicode map
2917             // when no post-table exists (fixes issue13316_reduced.pdf).
2918             if (
2919               !properties.glyphNames &&
2920               properties.hasIncludedToUnicodeMap &&
2921               !(this.toUnicode instanceof IdentityToUnicodeMap)
2922             ) {
2923               const unicode = this.toUnicode.get(charCode);
2924               if (unicode) {
2925                 unicodeOrCharCode = unicode.codePointAt(0);
2926               }
2927             }
2928 
2929             if (unicodeOrCharCode === undefined) {
2930               continue; // No valid glyph mapping found.
2931             }
2932           }
2933 
2934           for (const mapping of cmapMappings) {
2935             if (mapping.charCode !== unicodeOrCharCode) {
2936               continue;
2937             }
2938             charCodeToGlyphId[charCode] = mapping.glyphId;
2939             break;
2940           }
2941         }
2942       } else if (cmapPlatformId === 0) {
2943         // Default Unicode semantics, use the charcodes as is.
2944         for (const mapping of cmapMappings) {
2945           charCodeToGlyphId[mapping.charCode] = mapping.glyphId;
2946         }
2947         // Always prefer the BaseEncoding/Differences arrays, when they exist
2948         // (fixes issue13433.pdf).
2949         forcePostTable = true;
2950       } else {
2951         // When there is only a (1, 0) cmap table, the char code is a single
2952         // byte and it is used directly as the char code.
2953 
2954         // When a (3, 0) cmap table is present, it is used instead but the
2955         // spec has special rules for char codes in the range of 0xF000 to
2956         // 0xF0FF and it says the (3, 0) table should map the values from
2957         // the (1, 0) table by prepending 0xF0 to the char codes. To reverse
2958         // this, the upper bits of the char code are cleared, but only for the
2959         // special range since some PDFs have char codes outside of this range
2960         // (e.g. 0x2013) which when masked would overwrite other values in the
2961         // cmap.
2962         for (const mapping of cmapMappings) {
2963           let charCode = mapping.charCode;
2964           if (
2965             cmapPlatformId === 3 &&
2966             charCode >= 0xf000 &&
2967             charCode <= 0xf0ff
2968           ) {
2969             charCode &= 0xff;
2970           }
2971           charCodeToGlyphId[charCode] = mapping.glyphId;
2972         }
2973       }
2974 
2975       // Last, try to map any missing charcodes using the post table.
2976       if (
2977         properties.glyphNames &&
2978         (baseEncoding.length || this.differences.length)
2979       ) {
2980         for (let i = 0; i < 256; ++i) {
2981           if (!forcePostTable && charCodeToGlyphId[i] !== undefined) {
2982             continue;
2983           }
2984           const glyphName = this.differences[i] || baseEncoding[i];
2985           if (!glyphName) {
2986             continue;
2987           }
2988           const glyphId = properties.glyphNames.indexOf(glyphName);
2989           if (glyphId > 0 && hasGlyph(glyphId)) {
2990             charCodeToGlyphId[i] = glyphId;
2991           }
2992         }
2993       }
2994     }
2995 
2996     if (charCodeToGlyphId.length === 0) {
2997       // defines at least one glyph
2998       charCodeToGlyphId[0] = 0;
2999     }
3000 
3001     // Typically glyph 0 is duplicated and the mapping must be updated, but if
3002     // there isn't enough room to duplicate, the glyph id is left the same. In
3003     // this case, glyph 0 may not work correctly, but that is better than
3004     // having the whole font fail.
3005     let glyphZeroId = numGlyphsOut - 1;
3006     if (!dupFirstEntry) {
3007       glyphZeroId = 0;
3008     }
3009 
3010     // When `cssFontInfo` is set, the font is used to render text in the HTML
3011     // view (e.g. with Xfa) so nothing must be moved in the private use area.
3012     if (!properties.cssFontInfo) {
3013       // Converting glyphs and ids into font's cmap table
3014       const newMapping = adjustMapping(
3015         charCodeToGlyphId,
3016         hasGlyph,
3017         glyphZeroId,
3018         this.toUnicode
3019       );
3020       this.toFontChar = newMapping.toFontChar;
3021       tables.cmap = {
3022         tag: "cmap",
3023         data: createCmapTable(
3024           newMapping.charCodeToGlyphId,
3025           newMapping.toUnicodeExtraMap,
3026           numGlyphsOut
3027         ),
3028       };
3029 
3030       if (!tables["OS/2"] || !validateOS2Table(tables["OS/2"], font)) {
3031         tables["OS/2"] = {
3032           tag: "OS/2",
3033           data: createOS2Table(
3034             properties,
3035             newMapping.charCodeToGlyphId,
3036             metricsOverride
3037           ),
3038         };
3039       }
3040     }
3041 
3042     if (!isTrueType) {
3043       try {
3044         // Trying to repair CFF file
3045         cffFile = new Stream(tables["CFF "].data);
3046         const parser = new CFFParser(
3047           cffFile,
3048           properties,
3049           SEAC_ANALYSIS_ENABLED
3050         );
3051         cff = parser.parse();
3052         cff.duplicateFirstGlyph();
3053         const compiler = new CFFCompiler(cff);
3054         tables["CFF "].data = compiler.compile();
3055       } catch {
3056         warn("Failed to compile font " + properties.loadedName);
3057       }
3058     }
3059 
3060     // Re-creating 'name' table
3061     if (!tables.name) {
3062       tables.name = {
3063         tag: "name",
3064         data: createNameTable(this.name),
3065       };
3066     } else {
3067       // ... using existing 'name' table as prototype
3068       const [namePrototype, nameRecords] = readNameTable(tables.name);
3069 
3070       tables.name.data = createNameTable(name, namePrototype);
3071       this.psName = namePrototype[0][6] || null;
3072 
3073       if (!properties.composite) {
3074         // For TrueType fonts that do not include `ToUnicode` or `Encoding`
3075         // data, attempt to use the name-table to improve text selection.
3076         adjustTrueTypeToUnicode(properties, this.isSymbolicFont, nameRecords);
3077       }
3078     }
3079 
3080     const builder = new OpenTypeFileBuilder(header.version);
3081     for (const tableTag in tables) {
3082       builder.addTable(tableTag, tables[tableTag].data);
3083     }
3084     return builder.toArray();
3085   }
3086 
3087   convert(fontName, font, properties) {
3088     // TODO: Check the charstring widths to determine this.
3089     properties.fixedPitch = false;
3090 
3091     if (properties.builtInEncoding) {
3092       // For Type1 fonts that do not include either `ToUnicode` or `Encoding`
3093       // data, attempt to use the `builtInEncoding` to improve text selection.
3094       adjustType1ToUnicode(properties, properties.builtInEncoding);
3095     }
3096 
3097     // Type 1 fonts have a notdef inserted at the beginning, so glyph 0
3098     // becomes glyph 1. In a CFF font glyph 0 is appended to the end of the
3099     // char strings.
3100     let glyphZeroId = 1;
3101     if (font instanceof CFFFont) {
3102       glyphZeroId = font.numGlyphs - 1;
3103     }
3104     const mapping = font.getGlyphMapping(properties);
3105     let newMapping = null;
3106     let newCharCodeToGlyphId = mapping;
3107     let toUnicodeExtraMap = null;
3108 
3109     // When `cssFontInfo` is set, the font is used to render text in the HTML
3110     // view (e.g. with Xfa) so nothing must be moved in the private use area.
3111     if (!properties.cssFontInfo) {
3112       newMapping = adjustMapping(
3113         mapping,
3114         font.hasGlyphId.bind(font),
3115         glyphZeroId,
3116         this.toUnicode
3117       );
3118       this.toFontChar = newMapping.toFontChar;
3119       newCharCodeToGlyphId = newMapping.charCodeToGlyphId;
3120       toUnicodeExtraMap = newMapping.toUnicodeExtraMap;
3121     }
3122     const numGlyphs = font.numGlyphs;
3123 
3124     function getCharCodes(charCodeToGlyphId, glyphId) {
3125       let charCodes = null;
3126       for (const charCode in charCodeToGlyphId) {
3127         if (glyphId === charCodeToGlyphId[charCode]) {
3128           (charCodes ||= []).push(charCode | 0);
3129         }
3130       }
3131       return charCodes;
3132     }
3133 
3134     function createCharCode(charCodeToGlyphId, glyphId) {
3135       for (const charCode in charCodeToGlyphId) {
3136         if (glyphId === charCodeToGlyphId[charCode]) {
3137           return charCode | 0;
3138         }
3139       }
3140       newMapping.charCodeToGlyphId[newMapping.nextAvailableFontCharCode] =
3141         glyphId;
3142       return newMapping.nextAvailableFontCharCode++;
3143     }
3144 
3145     const seacs = font.seacs;
3146     if (newMapping && SEAC_ANALYSIS_ENABLED && seacs?.length) {
3147       const matrix = properties.fontMatrix || FONT_IDENTITY_MATRIX;
3148       const charset = font.getCharset();
3149       const seacMap = Object.create(null);
3150       for (let glyphId in seacs) {
3151         glyphId |= 0;
3152         const seac = seacs[glyphId];
3153         const baseGlyphName = StandardEncoding[seac[2]];
3154         const accentGlyphName = StandardEncoding[seac[3]];
3155         const baseGlyphId = charset.indexOf(baseGlyphName);
3156         const accentGlyphId = charset.indexOf(accentGlyphName);
3157         if (baseGlyphId < 0 || accentGlyphId < 0) {
3158           continue;
3159         }
3160         const accentOffset = {
3161           x: seac[0] * matrix[0] + seac[1] * matrix[2] + matrix[4],
3162           y: seac[0] * matrix[1] + seac[1] * matrix[3] + matrix[5],
3163         };
3164 
3165         const charCodes = getCharCodes(mapping, glyphId);
3166         if (!charCodes) {
3167           // There's no point in mapping it if the char code was never mapped
3168           // to begin with.
3169           continue;
3170         }
3171         for (const charCode of charCodes) {
3172           // Find a fontCharCode that maps to the base and accent glyphs.
3173           // If one doesn't exists, create it.
3174           const charCodeToGlyphId = newMapping.charCodeToGlyphId;
3175           const baseFontCharCode = createCharCode(
3176             charCodeToGlyphId,
3177             baseGlyphId
3178           );
3179           const accentFontCharCode = createCharCode(
3180             charCodeToGlyphId,
3181             accentGlyphId
3182           );
3183           seacMap[charCode] = {
3184             baseFontCharCode,
3185             accentFontCharCode,
3186             accentOffset,
3187           };
3188         }
3189       }
3190       properties.seacMap = seacMap;
3191     }
3192 
3193     const unitsPerEm = 1 / (properties.fontMatrix || FONT_IDENTITY_MATRIX)[0];
3194 
3195     const builder = new OpenTypeFileBuilder("\x4F\x54\x54\x4F");
3196     // PostScript Font Program
3197     builder.addTable("CFF ", font.data);
3198     // OS/2 and Windows Specific metrics
3199     builder.addTable("OS/2", createOS2Table(properties, newCharCodeToGlyphId));
3200     // Character to glyphs mapping
3201     builder.addTable(
3202       "cmap",
3203       createCmapTable(newCharCodeToGlyphId, toUnicodeExtraMap, numGlyphs)
3204     );
3205     // Font header
3206     builder.addTable(
3207       "head",
3208       "\x00\x01\x00\x00" + // Version number
3209         "\x00\x00\x10\x00" + // fontRevision
3210         "\x00\x00\x00\x00" + // checksumAdjustement
3211         "\x5F\x0F\x3C\xF5" + // magicNumber
3212         "\x00\x00" + // Flags
3213         safeString16(unitsPerEm) + // unitsPerEM
3214         "\x00\x00\x00\x00\x9e\x0b\x7e\x27" + // creation date
3215         "\x00\x00\x00\x00\x9e\x0b\x7e\x27" + // modifification date
3216         "\x00\x00" + // xMin
3217         safeString16(properties.descent) + // yMin
3218         "\x0F\xFF" + // xMax
3219         safeString16(properties.ascent) + // yMax
3220         string16(properties.italicAngle ? 2 : 0) + // macStyle
3221         "\x00\x11" + // lowestRecPPEM
3222         "\x00\x00" + // fontDirectionHint
3223         "\x00\x00" + // indexToLocFormat
3224         "\x00\x00"
3225     ); // glyphDataFormat
3226 
3227     // Horizontal header
3228     builder.addTable(
3229       "hhea",
3230       "\x00\x01\x00\x00" + // Version number
3231         safeString16(properties.ascent) + // Typographic Ascent
3232         safeString16(properties.descent) + // Typographic Descent
3233         "\x00\x00" + // Line Gap
3234         "\xFF\xFF" + // advanceWidthMax
3235         "\x00\x00" + // minLeftSidebearing
3236         "\x00\x00" + // minRightSidebearing
3237         "\x00\x00" + // xMaxExtent
3238         safeString16(properties.capHeight) + // caretSlopeRise
3239         safeString16(Math.tan(properties.italicAngle) * properties.xHeight) + // caretSlopeRun
3240         "\x00\x00" + // caretOffset
3241         "\x00\x00" + // -reserved-
3242         "\x00\x00" + // -reserved-
3243         "\x00\x00" + // -reserved-
3244         "\x00\x00" + // -reserved-
3245         "\x00\x00" + // metricDataFormat
3246         string16(numGlyphs)
3247     ); // Number of HMetrics
3248 
3249     // Horizontal metrics
3250     builder.addTable(
3251       "hmtx",
3252       (function fontFieldsHmtx() {
3253         const charstrings = font.charstrings;
3254         const cffWidths = font.cff ? font.cff.widths : null;
3255         let hmtx = "\x00\x00\x00\x00"; // Fake .notdef
3256         for (let i = 1, ii = numGlyphs; i < ii; i++) {
3257           let width = 0;
3258           if (charstrings) {
3259             const charstring = charstrings[i - 1];
3260             width = "width" in charstring ? charstring.width : 0;
3261           } else if (cffWidths) {
3262             width = Math.ceil(cffWidths[i] || 0);
3263           }
3264           hmtx += string16(width) + string16(0);
3265         }
3266         return hmtx;
3267       })()
3268     );
3269 
3270     // Maximum profile
3271     builder.addTable(
3272       "maxp",
3273       "\x00\x00\x50\x00" + string16(numGlyphs) // Version number
3274     ); // Num of glyphs
3275 
3276     // Naming tables
3277     builder.addTable("name", createNameTable(fontName));
3278 
3279     // PostScript information
3280     builder.addTable("post", createPostTable(properties));
3281 
3282     return builder.toArray();
3283   }
3284 
3285   get spaceWidth() {
3286     // trying to estimate space character width
3287     const possibleSpaceReplacements = ["space", "minus", "one", "i", "I"];
3288     let width;
3289     for (const glyphName of possibleSpaceReplacements) {
3290       // if possible, getting width by glyph name
3291       if (glyphName in this.widths) {
3292         width = this.widths[glyphName];
3293         break;
3294       }
3295       const glyphsUnicodeMap = getGlyphsUnicode();
3296       const glyphUnicode = glyphsUnicodeMap[glyphName];
3297       // finding the charcode via unicodeToCID map
3298       let charcode = 0;
3299       if (this.composite && this.cMap.contains(glyphUnicode)) {
3300         charcode = this.cMap.lookup(glyphUnicode);
3301 
3302         if (typeof charcode === "string") {
3303           charcode = convertCidString(glyphUnicode, charcode);
3304         }
3305       }
3306       // ... via toUnicode map
3307       if (!charcode && this.toUnicode) {
3308         charcode = this.toUnicode.charCodeOf(glyphUnicode);
3309       }
3310       // setting it to unicode if negative or undefined
3311       if (charcode <= 0) {
3312         charcode = glyphUnicode;
3313       }
3314       // trying to get width via charcode
3315       width = this.widths[charcode];
3316       if (width) {
3317         break; // the non-zero width found
3318       }
3319     }
3320     return shadow(this, "spaceWidth", width || this.defaultWidth);
3321   }
3322 
3323   /**
3324    * @private
3325    */
3326   _charToGlyph(charcode, isSpace = false) {
3327     let glyph = this._glyphCache[charcode];
3328     // All `Glyph`-properties, except `isSpace` in multi-byte strings,
3329     // depend indirectly on the `charcode`.
3330     if (glyph?.isSpace === isSpace) {
3331       return glyph;
3332     }
3333     let fontCharCode, width, operatorListId;
3334 
3335     let widthCode = charcode;
3336     if (this.cMap?.contains(charcode)) {
3337       widthCode = this.cMap.lookup(charcode);
3338 
3339       if (typeof widthCode === "string") {
3340         widthCode = convertCidString(charcode, widthCode);
3341       }
3342     }
3343     width = this.widths[widthCode];
3344     if (typeof width !== "number") {
3345       width = this.defaultWidth;
3346     }
3347     const vmetric = this.vmetrics?.[widthCode];
3348 
3349     let unicode = this.toUnicode.get(charcode) || charcode;
3350     if (typeof unicode === "number") {
3351       unicode = String.fromCharCode(unicode);
3352     }
3353 
3354     let isInFont = this.toFontChar[charcode] !== undefined;
3355     // First try the toFontChar map, if it's not there then try falling
3356     // back to the char code.
3357     fontCharCode = this.toFontChar[charcode] || charcode;
3358     if (this.missingFile) {
3359       const glyphName =
3360         this.differences[charcode] || this.defaultEncoding[charcode];
3361       if (
3362         (glyphName === ".notdef" || glyphName === "") &&
3363         this.type === "Type1"
3364       ) {
3365         // .notdef glyphs should be invisible in non-embedded Type1 fonts, so
3366         // replace them with spaces.
3367         fontCharCode = 0x20;
3368       }
3369       fontCharCode = mapSpecialUnicodeValues(fontCharCode);
3370     }
3371 
3372     if (this.isType3Font) {
3373       // Font char code in this case is actually a glyph name.
3374       operatorListId = fontCharCode;
3375     }
3376 
3377     let accent = null;
3378     if (this.seacMap?.[charcode]) {
3379       isInFont = true;
3380       const seac = this.seacMap[charcode];
3381       fontCharCode = seac.baseFontCharCode;
3382       accent = {
3383         fontChar: String.fromCodePoint(seac.accentFontCharCode),
3384         offset: seac.accentOffset,
3385       };
3386     }
3387 
3388     let fontChar = "";
3389     if (typeof fontCharCode === "number") {
3390       if (fontCharCode <= 0x10ffff) {
3391         fontChar = String.fromCodePoint(fontCharCode);
3392       } else {
3393         warn(`charToGlyph - invalid fontCharCode: ${fontCharCode}`);
3394       }
3395     }
3396 
3397     glyph = new Glyph(
3398       charcode,
3399       fontChar,
3400       unicode,
3401       accent,
3402       width,
3403       vmetric,
3404       operatorListId,
3405       isSpace,
3406       isInFont
3407     );
3408     return (this._glyphCache[charcode] = glyph);
3409   }
3410 
3411   charsToGlyphs(chars) {
3412     // If we translated this string before, just grab it from the cache.
3413     let glyphs = this._charsCache[chars];
3414     if (glyphs) {
3415       return glyphs;
3416     }
3417     glyphs = [];
3418 
3419     if (this.cMap) {
3420       // Composite fonts have multi-byte strings, convert the string from
3421       // single-byte to multi-byte.
3422       const c = Object.create(null),
3423         ii = chars.length;
3424       let i = 0;
3425       while (i < ii) {
3426         this.cMap.readCharCode(chars, i, c);
3427         const { charcode, length } = c;
3428         i += length;
3429         // Space is char with code 0x20 and length 1 in multiple-byte codes.
3430         const glyph = this._charToGlyph(
3431           charcode,
3432           length === 1 && chars.charCodeAt(i - 1) === 0x20
3433         );
3434         glyphs.push(glyph);
3435       }
3436     } else {
3437       for (let i = 0, ii = chars.length; i < ii; ++i) {
3438         const charcode = chars.charCodeAt(i);
3439         const glyph = this._charToGlyph(charcode, charcode === 0x20);
3440         glyphs.push(glyph);
3441       }
3442     }
3443 
3444     // Enter the translated string into the cache.
3445     return (this._charsCache[chars] = glyphs);
3446   }
3447 
3448   /**
3449    * Chars can have different sizes (depends on the encoding).
3450    * @param {String} a string encoded with font encoding.
3451    * @returns {Array<Array<number>>} the positions of each char in the string.
3452    */
3453   getCharPositions(chars) {
3454     // This function doesn't use a cache because
3455     // it's called only when saving or printing.
3456     const positions = [];
3457 
3458     if (this.cMap) {
3459       const c = Object.create(null);
3460       let i = 0;
3461       while (i < chars.length) {
3462         this.cMap.readCharCode(chars, i, c);
3463         const length = c.length;
3464         positions.push([i, i + length]);
3465         i += length;
3466       }
3467     } else {
3468       for (let i = 0, ii = chars.length; i < ii; ++i) {
3469         positions.push([i, i + 1]);
3470       }
3471     }
3472 
3473     return positions;
3474   }
3475 
3476   get glyphCacheValues() {
3477     return Object.values(this._glyphCache);
3478   }
3479 
3480   /**
3481    * Encode a js string using font encoding.
3482    * The resulting array contains an encoded string at even positions
3483    * (can be empty) and a non-encoded one at odd positions.
3484    * @param {String} a js string.
3485    * @returns {Array<String>} an array of encoded strings or non-encoded ones.
3486    */
3487   encodeString(str) {
3488     const buffers = [];
3489     const currentBuf = [];
3490 
3491     // buffers will contain: encoded, non-encoded, encoded, ...
3492     // currentBuf is pushed in buffers each time there is a change.
3493     // So when buffers.length is odd then the last string is an encoded one
3494     // and currentBuf contains non-encoded chars.
3495     const hasCurrentBufErrors = () => buffers.length % 2 === 1;
3496 
3497     const getCharCode =
3498       this.toUnicode instanceof IdentityToUnicodeMap
3499         ? unicode => this.toUnicode.charCodeOf(unicode)
3500         : unicode => this.toUnicode.charCodeOf(String.fromCodePoint(unicode));
3501 
3502     for (let i = 0, ii = str.length; i < ii; i++) {
3503       const unicode = str.codePointAt(i);
3504       if (unicode > 0xd7ff && (unicode < 0xe000 || unicode > 0xfffd)) {
3505         // unicode is represented by two uint16
3506         i++;
3507       }
3508       if (this.toUnicode) {
3509         const charCode = getCharCode(unicode);
3510         if (charCode !== -1) {
3511           if (hasCurrentBufErrors()) {
3512             buffers.push(currentBuf.join(""));
3513             currentBuf.length = 0;
3514           }
3515           const charCodeLength = this.cMap
3516             ? this.cMap.getCharCodeLength(charCode)
3517             : 1;
3518           for (let j = charCodeLength - 1; j >= 0; j--) {
3519             currentBuf.push(String.fromCharCode((charCode >> (8 * j)) & 0xff));
3520           }
3521           continue;
3522         }
3523       }
3524 
3525       // unicode can't be encoded
3526       if (!hasCurrentBufErrors()) {
3527         buffers.push(currentBuf.join(""));
3528         currentBuf.length = 0;
3529       }
3530       currentBuf.push(String.fromCodePoint(unicode));
3531     }
3532 
3533     buffers.push(currentBuf.join(""));
3534 
3535     return buffers;
3536   }
3537 }
3538 
3539 class ErrorFont {
3540   constructor(error) {
3541     this.error = error;
3542     this.loadedName = "g_font_error";
3543     this.missingFile = true;
3544   }
3545 
3546   charsToGlyphs() {
3547     return [];
3548   }
3549 
3550   encodeString(chars) {
3551     return [chars];
3552   }
3553 
3554   exportData(extraProperties = false) {
3555     return { error: this.error };
3556   }
3557 }
3558 
3559 export { ErrorFont, Font };
</code>

Your task:
You are a software tester at pdf.js.
1. Write exactly one javascript test `it("...", async () => {...})` block.
2. Your test must fail on the code before the patch, and pass after, hence the test will verify that the patch resolves the issue.
3. The test must be self-contained and to-the-point.
4. Use only the provided imports (respect the paths exactly how they are given) by importing dynamically for compatibility with Node.js — no new dependencies. You can use the PDF file for testing as follows:
const { getDocument } = await import('../../src/display/api.js');
const { buildGetDocumentParams } = await import('./test_utils.js');
const loadingTask = getDocument(buildGetDocumentParams('issue17671.pdf'))
5. Return only the javascript code (no comments or explanations).

Example structure:
it("should <describe behavior>", async () => {
  const { example } = await import("../../src/core/example.js");
  <initialize required variables>;
  <define expected variable>;
  <generate actual variables>;
  <compare expected with actual>;
});

