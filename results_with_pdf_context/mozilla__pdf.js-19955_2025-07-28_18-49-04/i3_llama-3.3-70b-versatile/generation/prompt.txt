Before you begin:
- Keep going until the job is completely solved — don’t stop halfway.
- If you’re unsure about the behavior, reread the provided patch carefully; do not hallucinate.
- Plan your approach before writing code by reflecting on whether the test truly fails before and passes after.

Issue:
<issue>
[Bug]: Missing text later in PDF with probably broken font
### Attach (recommended) or Link to PDF file

[Capital Bancorp Inc Corporate Responsibility 2025509 SD000000003063823863-1-2.pdf](https://github.com/user-attachments/files/20281525/Capital.Bancorp.Inc.Corporate.Responsibility.2025509.SD000000003063823863-1-2.pdf)

### Web browser and its version

Firefox 140 (also tested in Chrome, I don't know which version)

### Operating system and its version

Ubuntu 25.04 with x11

### PDF.js version

5.2.133

### Is the bug present in the latest PDF.js version?

Yes

### Is a browser extension

No

### Steps to reproduce the problem

Open the PDF and try to select some text

### What is the expected behavior?

It should generate a text layer, because this PDF contains actual text and it's not just an image

### What went wrong?

It does not generate a text layer. This is probably because there are some problems with the font used by the PDF:
```
Warning: loadFont - translateFont failed: "FormatError: invalid font name". [pdf.worker.mjs:323:13](resource://pdf.js/build/pdf.worker.mjs)
Warning: Error during font loading: invalid font name [pdf.mjs:323:13](resource://pdf.js/build/pdf.mjs)
Warning: loadFont - translateFont failed: "FormatError: invalid font name". [pdf.worker.mjs:323:13](resource://pdf.js/build/pdf.worker.mjs)
Warning: Error during font loading: invalid font name [pdf.mjs:323:13](resource://pdf.js/build/pdf.mjs)
Warning: loadFont - translateFont failed: "FormatError: invalid font name". [pdf.worker.mjs:323:13](resource://pdf.js/build/pdf.worker.mjs)
Warning: Error during font loading: invalid font name [pdf.mjs:323:13](resource://pdf.js/build/pdf.mjs)
```

### Link to a viewer

_No response_

### Additional context

Even though it seems like it's a problem with the PDF, both Chrome and the built-in PDF viewer in Ubuntu allow  me to select the text.
</issue>

PDF File:
<pdf>
issue19954.pdf
</pdf>

Patch:
<patch>
diff --git a/src/core/evaluator.js b/src/core/evaluator.js
--- a/src/core/evaluator.js
+++ b/src/core/evaluator.js
@@ -4313,12 +4313,9 @@ class PartialEvaluator {
 
     if (!descriptor) {
       if (isType3Font) {
-        const bbox = lookupNormalRect(dict.getArray("FontBBox"), [0, 0, 0, 0]);
         // FontDescriptor is only required for Type3 fonts when the document
-        // is a tagged pdf. Create a barbebones one to get by.
-        descriptor = new Dict(null);
-        descriptor.set("FontName", Name.get(type));
-        descriptor.set("FontBBox", bbox);
+        // is a tagged pdf.
+        descriptor = Dict.empty;
       } else {
         // Before PDF 1.5 if the font was one of the base 14 fonts, having a
         // FontDescriptor was not required.
@@ -4420,7 +4417,13 @@ class PartialEvaluator {
 
     const fontNameStr = fontName?.name;
     const baseFontStr = baseFont?.name;
-    if (!isType3Font && fontNameStr !== baseFontStr) {
+    if (isType3Font) {
+      if (!fontNameStr) {
+        // Since the /FontDescriptor is optional in Type3 fonts, ensure that we
+        // always have a "valid" /FontName (fixes issue19954.pdf).
+        fontName = Name.get(type);
+      }
+    } else if (fontNameStr !== baseFontStr) {
       info(
         `The FontDescriptor's FontName is "${fontNameStr}" but ` +
           `should be the same as the Font's BaseFont "${baseFontStr}".`
@@ -4438,8 +4441,8 @@ class PartialEvaluator {
       ) {
         fontName = null;
       }
+      fontName ||= baseFont;
     }
-    fontName ||= baseFont;
 
     if (!(fontName instanceof Name)) {
       throw new FormatError("invalid font name");
@@ -4517,7 +4520,7 @@ class PartialEvaluator {
     );
     const bbox = lookupNormalRect(
       descriptor.getArray("FontBBox") || dict.getArray("FontBBox"),
-      undefined
+      isType3Font ? [0, 0, 0, 0] : undefined
     );
     let ascent = descriptor.get("Ascent");
     if (typeof ascent !== "number") {
@@ -4705,9 +4708,9 @@ class TranslatedFont {
     const fontResources = this.dict.get("Resources") || resources;
     const charProcOperatorList = Object.create(null);
 
-    const fontBBox = Util.normalizeRect(font.bbox || [0, 0, 0, 0]),
-      width = fontBBox[2] - fontBBox[0],
-      height = fontBBox[3] - fontBBox[1];
+    const [x0, y0, x1, y1] = font.bbox,
+      width = x1 - x0,
+      height = y1 - y0;
     const fontBBoxSize = Math.hypot(width, height);
 
     for (const key of charProcs.getKeys()) {


</patch>

Imports:
<imports>
Available Packages
Dev Dependencies:
- @babel/core: ^7.27.1
- @babel/preset-env: ^7.27.2
- @babel/runtime: ^7.27.1
- @csstools/postcss-light-dark-function: ^2.0.8
- @fluent/bundle: ^0.19.1
- @fluent/dom: ^0.10.1
- @metalsmith/layouts: ^3.0.0
- @metalsmith/markdown: ^1.10.0
- @napi-rs/canvas: ^0.1.70
- @types/node: ^22.15.18
- autoprefixer: ^10.4.21
- babel-loader: ^10.0.0
- caniuse-lite: ^1.0.30001718
- core-js: ^3.42.0
- eslint: ^9.27.0
- eslint-plugin-import: ^2.31.0
- eslint-plugin-jasmine: ^4.2.2
- eslint-plugin-json: ^4.0.1
- eslint-plugin-no-unsanitized: ^4.1.2
- eslint-plugin-perfectionist: ^4.13.0
- eslint-plugin-prettier: ^5.4.0
- eslint-plugin-unicorn: ^59.0.1
- globals: ^16.1.0
- gulp: ^5.0.0
- gulp-cli: ^3.0.0
- gulp-postcss: ^10.0.0
- gulp-rename: ^2.0.0
- gulp-replace: ^1.1.4
- gulp-zip: ^6.1.0
- highlight.js: ^11.11.1
- jasmine: ^5.7.1
- jsdoc: ^4.0.4
- jstransformer-nunjucks: ^1.2.0
- metalsmith: ^2.6.3
- metalsmith-html-relative: ^2.0.6
- ordered-read-streams: ^2.0.0
- pngjs: ^7.0.0
- postcss: ^8.5.3
- postcss-dir-pseudo-class: ^9.0.1
- postcss-discard-comments: ^7.0.4
- postcss-nesting: ^13.0.1
- prettier: ^3.5.3
- puppeteer: ^24.8.2
- stylelint: ^16.19.1
- stylelint-prettier: ^5.0.3
- svglint: ^3.1.0
- terser-webpack-plugin: ^5.3.14
- tsc-alias: ^1.8.16
- ttest: ^4.0.0
- typescript: ^5.8.3
- vinyl: ^3.0.0
- webpack: ^5.99.8
- webpack-stream: ^7.0.0
- yargs: ^17.7.2

Engines:
- node: >=20.16.0 || >=22.3.0

Available Relative Imports:
- `../../src/core/annotation.js`: Annotation, AnnotationBorderStyle, AnnotationFactory, MarkupAnnotation, getQuadPoints
- `../../src/core/bidi.js`: bidi
- `../../src/core/calculate_md5.js`: calculateMD5
- `../../src/core/calculate_sha256.js`: calculateSHA256
- `../../src/core/calculate_sha_other.js`: calculateSHA384, calculateSHA512
- `../../src/core/cff_parser.js`: CFFCharset, CFFCompiler, CFFFDSelect, CFFParser, CFFStrings
- `../../src/core/cmap.js`: CMap, CMapFactory, IdentityCMap
- `../../src/core/colorspace.js`: ColorSpace
- `../../src/core/colorspace_utils.js`: ColorSpaceUtils
- `../../src/core/core_utils.js`: arrayBuffersToBytes, encodeToXmlString, escapePDFName, escapeString, getInheritableProperty, getSizeInBytes, isAscii, isWhiteSpace, log2, numberToString, parseXFAPath, recoverJsURL, stringToUTF16HexString, stringToUTF16String, toRomanNumerals, validateCSSFont
- `../../src/core/crypto.js`: AES128Cipher, AES256Cipher, ARCFourCipher, CipherTransformFactory, PDF17, PDF20
- `../../src/core/default_appearance.js`: createDefaultAppearance, parseAppearanceStream, parseDefaultAppearance
- `../../src/core/document.js`: PDFDocument, Page
- `../../src/core/encodings.js`: getEncoding
- `../../src/core/evaluator.js`: PartialEvaluator
- `../../src/core/flate_stream.js`: FlateStream
- `../../src/core/font_substitutions.js`: getFontSubstitution
- `../../src/core/fonts_utils.js`: SEAC_ANALYSIS_ENABLED
- `../../src/core/function.js`: PDFFunctionFactory, PostScriptCompiler, PostScriptEvaluator
- `../../src/core/glyphlist.js`: getDingbatsGlyphsUnicode, getGlyphsUnicode
- `../../src/core/image_utils.js`: GlobalColorSpaceCache, GlobalImageCache, LocalColorSpaceCache
- `../../src/core/jbig2.js`: Jbig2Error, Jbig2Image
- `../../src/core/jpg.js`: JpegError, JpegImage
- `../../src/core/jpx.js`: JpxError, JpxImage
- `../../src/core/metadata_parser.js`: MetadataParser
- `../../src/core/operator_list.js`: OperatorList
- `../../src/core/parser.js`: Lexer, Linearization, Parser
- `../../src/core/predictor_stream.js`: PredictorStream
- `../../src/core/primitives.js`: Cmd, Dict, EOF, Name, Ref, RefSet, RefSetCache, isCmd, isDict, isName, isRefsEqual
- `../../src/core/ps_parser.js`: PostScriptLexer, PostScriptParser
- `../../src/core/stream.js`: NullStream, Stream, StringStream
- `../../src/core/type1_parser.js`: Type1Parser
- `../../src/core/unicode.js`: getCharUnicodeCategory, getUnicodeForGlyph, getUnicodeRangeFor, mapSpecialUnicodeValues
- `../../src/core/worker.js`: WorkerMessageHandler, WorkerTask
- `../../src/core/writer.js`: incrementalUpdate, writeChanges, writeDict
- `../../src/core/xfa/bind.js`: Binder
- `../../src/core/xfa/data.js`: DataHandler
- `../../src/core/xfa/factory.js`: XFAFactory
- `../../src/core/xfa/formcalc_lexer.js`: Lexer, TOKEN, Token
- `../../src/core/xfa/formcalc_parser.js`: Errors, Parser
- `../../src/core/xfa/parser.js`: XFAParser
- `../../src/core/xfa/som.js`: searchNode
- `../../src/core/xfa/symbol_utils.js`: $dump, $getChildren, $getChildrenByClass, $getChildrenByName, $text, $uid
- `../../src/core/xml_parser.js`: SimpleXMLParser, XMLParserBase
- `../../src/display/annotation_layer.js`: AnnotationLayer
- `../../src/display/annotation_storage.js`: AnnotationStorage
- `../../src/display/api.js`: LoopbackPort, PDFDataRangeTransport, PDFDocumentLoadingTask, PDFDocumentProxy, PDFPageProxy, PDFWorker, RenderTask, build, getDocument, isValidExplicitDest, version
- `../../src/display/canvas_factory.js`: DOMCanvasFactory
- `../../src/display/cmap_reader_factory.js`: DOMCMapReaderFactory
- `../../src/display/display_utils.js`: OutputScale, PDFDateString, PageViewport, PixelsPerInch, RenderingCancelledException, StatTimer, SupportedImageMimeTypes, fetchData, getFilenameFromUrl, getPdfFilenameFromUrl, getXfaPageViewport, isDataScheme, isPdfFile, isValidFetchUrl, noContextMenu, setLayerDimensions, stopEvent
- `../../src/display/draw_layer.js`: DrawLayer
- `../../src/display/editor/annotation_editor_layer.js`: AnnotationEditorLayer
- `../../src/display/editor/color_picker.js`: ColorPicker
- `../../src/display/editor/drawers/signaturedraw.js`: SignatureExtractor
- `../../src/display/editor/tools.js`: AnnotationEditorUIManager, CommandManager
- `../../src/display/fetch_stream.js`: PDFFetchStream
- `../../src/display/metadata.js`: Metadata
- `../../src/display/network.js`: PDFNetworkStream
- `../../src/display/network_utils.js`: createHeaders, createResponseError, extractFilenameFromHeader, validateRangeRequestCapabilities, validateResponseStatus
- `../../src/display/node_stream.js`: PDFNodeStream
- `../../src/display/node_utils.js`: NodeCMapReaderFactory, NodeStandardFontDataFactory, fetchData
- `../../src/display/standard_fontdata_factory.js`: DOMStandardFontDataFactory
- `../../src/display/svg_factory.js`: DOMSVGFactory
- `../../src/display/text_layer.js`: TextLayer
- `../../src/display/touch_manager.js`: TouchManager
- `../../src/display/worker_options.js`: GlobalWorkerOptions
- `../../src/display/xfa_layer.js`: XfaLayer
- `../../src/shared/message_handler.js`: MessageHandler
- `../../src/shared/murmurhash3.js`: MurmurHash3_64
- `../../src/shared/util.js`: AbortException, AnnotationBorderStyleType, AnnotationEditorParamsType, AnnotationEditorType, AnnotationFieldFlag, AnnotationFlag, AnnotationMode, AnnotationType, BaseException, DrawOPS, FeatureTest, FormatError, ImageKind, InvalidPDFException, MathClamp, OPS, PasswordException, PasswordResponses, PermissionFlag, RenderingIntentFlag, ResponseException, UnknownErrorException, Util, VerbosityLevel, assert, bytesToString, createValidAbsoluteUrl, getModificationDate, getUuid, getVerbosityLevel, isNodeJS, normalizeUnicode, objectSize, setVerbosityLevel, shadow, string32, stringToBytes, stringToPDFString, stringToUTF8String, toBase64Util, updateUrlHash
- `../../web/annotation_layer_builder.js`: AnnotationLayerBuilder
- `../../web/app_options.js`: AppOptions, OptionKind
- `../../web/autolinker.js`: Autolinker
- `../../web/download_manager.js`: DownloadManager
- `../../web/event_utils.js`: EventBus, WaitOnType, waitOnEventOrTimeout
- `../../web/genericl10n.js`: GenericL10n
- `../../web/pdf_find_controller.js`: FindState, PDFFindController
- `../../web/pdf_find_utils.js`: CharacterType, getCharacterType
- `../../web/pdf_history.js`: PDFHistory, isDestArraysEqual, isDestHashesEqual
- `../../web/pdf_link_service.js`: LinkTarget, PDFLinkService, SimpleLinkService
- `../../web/pdf_page_view.js`: PDFPageView
- `../../web/pdf_scripting_manager.component.js`: PDFScriptingManager
- `../../web/pdf_single_page_viewer.js`: PDFSinglePageViewer
- `../../web/pdf_viewer.js`: PDFPageViewBuffer, PDFViewer
- `../../web/struct_tree_layer_builder.js`: StructTreeLayerBuilder
- `../../web/text_layer_builder.js`: TextLayerBuilder
- `../../web/ui_utils.js`: AutoPrintRegExp, ProgressBar, RenderingStates, ScrollMode, SpreadMode, backtrackBeforeAllVisibleElements, binarySearchFirstItem, calcRound, getPageSizeInches, getVisibleElements, isPortraitOrientation, isValidRotation, parseQueryString, removeNullCharacters
- `../../web/xfa_layer_builder.js`: XfaLayerBuilder
- `../reporter.js`: TestReporter
- `./common_pdfstream_tests.js`: testCrossOriginRedirects
- `./test_utils.js`: CMAP_URL, DefaultCMapReaderFactory, DefaultFileReaderFactory, DefaultStandardFontDataFactory, STANDARD_FONT_DATA_URL, TEST_PDFS_PATH, TestPdfsServer, XRefMock, buildGetDocumentParams, createIdFactory, getCrossOriginHostname
</imports>

Code:
<code>
File:
src/core/evaluator.js
1 /* Copyright 2012 Mozilla Foundation
2  *
3  * Licensed under the Apache License, Version 2.0 (the "License");
4  * you may not use this file except in compliance with the License.
5  * You may obtain a copy of the License at
6  *
7  *     http://www.apache.org/licenses/LICENSE-2.0
8  *
9  * Unless required by applicable law or agreed to in writing, software
10  * distributed under the License is distributed on an "AS IS" BASIS,
11  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
12  * See the License for the specific language governing permissions and
13  * limitations under the License.
14  */
15 
16 import {
17   AbortException,
18   assert,
19   DrawOPS,
20   FONT_IDENTITY_MATRIX,
21   FormatError,
22   info,
23   isArrayEqual,
24   normalizeUnicode,
25   OPS,
26   shadow,
27   stringToPDFString,
28   TextRenderingMode,
29   Util,
30   warn,
31 } from "../shared/util.js";
32 import { CMapFactory, IdentityCMap } from "./cmap.js";
33 import { Cmd, Dict, EOF, isName, Name, Ref, RefSet } from "./primitives.js";
34 import { compileType3Glyph, FontFlags } from "./fonts_utils.js";
35 import { ErrorFont, Font } from "./fonts.js";
36 import {
37   fetchBinaryData,
38   IDENTITY_MATRIX,
39   isNumberArray,
40   lookupMatrix,
41   lookupNormalRect,
42 } from "./core_utils.js";
43 import {
44   getEncoding,
45   MacRomanEncoding,
46   StandardEncoding,
47   SymbolSetEncoding,
48   WinAnsiEncoding,
49   ZapfDingbatsEncoding,
50 } from "./encodings.js";
51 import {
52   getFontNameToFileMap,
53   getSerifFonts,
54   getStandardFontName,
55   getStdFontMap,
56   getSymbolsFonts,
57   isKnownFontName,
58 } from "./standard_fonts.js";
59 import { getTilingPatternIR, Pattern } from "./pattern.js";
60 import { getXfaFontDict, getXfaFontName } from "./xfa_fonts.js";
61 import { IdentityToUnicodeMap, ToUnicodeMap } from "./to_unicode_map.js";
62 import { isPDFFunction, PDFFunctionFactory } from "./function.js";
63 import { Lexer, Parser } from "./parser.js";
64 import {
65   LocalColorSpaceCache,
66   LocalGStateCache,
67   LocalImageCache,
68   LocalTilingPatternCache,
69   RegionalImageCache,
70 } from "./image_utils.js";
71 import { BaseStream } from "./base_stream.js";
72 import { bidi } from "./bidi.js";
73 import { ColorSpace } from "./colorspace.js";
74 import { ColorSpaceUtils } from "./colorspace_utils.js";
75 import { getFontSubstitution } from "./font_substitutions.js";
76 import { getGlyphsUnicode } from "./glyphlist.js";
77 import { getMetrics } from "./metrics.js";
78 import { getUnicodeForGlyph } from "./unicode.js";
79 import { MurmurHash3_64 } from "../shared/murmurhash3.js";
80 import { OperatorList } from "./operator_list.js";
81 import { PDFImage } from "./image.js";
82 import { Stream } from "./stream.js";
83 
84 const DefaultPartialEvaluatorOptions = Object.freeze({
85   maxImageSize: -1,
86   disableFontFace: false,
87   ignoreErrors: false,
88   isEvalSupported: true,
89   isOffscreenCanvasSupported: false,
90   isImageDecoderSupported: false,
91   canvasMaxAreaInBytes: -1,
92   fontExtraProperties: false,
93   useSystemFonts: true,
94   useWasm: true,
95   useWorkerFetch: true,
96   cMapUrl: null,
97   iccUrl: null,
98   standardFontDataUrl: null,
99   wasmUrl: null,
100 });
101 
102 const PatternType = {
103   TILING: 1,
104   SHADING: 2,
105 };
106 
107 // Optionally avoid sending individual, or very few, text chunks to reduce
108 // `postMessage` overhead with ReadableStream (see issue 13962).
109 //
110 // PLEASE NOTE: This value should *not* be too large (it's used as a lower limit
111 // in `enqueueChunk`), since that would cause streaming of textContent to become
112 // essentially useless in practice by sending all (or most) chunks at once.
113 // Also, a too large value would (indirectly) affect the main-thread `textLayer`
114 // building negatively by forcing all textContent to be handled at once, which
115 // could easily end up hurting *overall* performance (e.g. rendering as well).
116 const TEXT_CHUNK_BATCH_SIZE = 10;
117 
118 const deferred = Promise.resolve();
119 
120 // Convert PDF blend mode names to HTML5 blend mode names.
121 function normalizeBlendMode(value, parsingArray = false) {
122   if (Array.isArray(value)) {
123     // Use the first *supported* BM value in the Array (fixes issue11279.pdf).
124     for (const val of value) {
125       const maybeBM = normalizeBlendMode(val, /* parsingArray = */ true);
126       if (maybeBM) {
127         return maybeBM;
128       }
129     }
130     warn(`Unsupported blend mode Array: ${value}`);
131     return "source-over";
132   }
133 
134   if (!(value instanceof Name)) {
135     if (parsingArray) {
136       return null;
137     }
138     return "source-over";
139   }
140   switch (value.name) {
141     case "Normal":
142     case "Compatible":
143       return "source-over";
144     case "Multiply":
145       return "multiply";
146     case "Screen":
147       return "screen";
148     case "Overlay":
149       return "overlay";
150     case "Darken":
151       return "darken";
152     case "Lighten":
153       return "lighten";
154     case "ColorDodge":
155       return "color-dodge";
156     case "ColorBurn":
157       return "color-burn";
158     case "HardLight":
159       return "hard-light";
160     case "SoftLight":
161       return "soft-light";
162     case "Difference":
163       return "difference";
164     case "Exclusion":
165       return "exclusion";
166     case "Hue":
167       return "hue";
168     case "Saturation":
169       return "saturation";
170     case "Color":
171       return "color";
172     case "Luminosity":
173       return "luminosity";
174   }
175   if (parsingArray) {
176     return null;
177   }
178   warn(`Unsupported blend mode: ${value.name}`);
179   return "source-over";
180 }
181 
182 function addCachedImageOps(
183   opList,
184   { objId, fn, args, optionalContent, hasMask }
185 ) {
186   if (objId) {
187     opList.addDependency(objId);
188   }
189   opList.addImageOps(fn, args, optionalContent, hasMask);
190 
191   if (fn === OPS.paintImageMaskXObject && args[0]?.count > 0) {
192     args[0].count++;
193   }
194 }
195 
196 // Trying to minimize Date.now() usage and check every 100 time.
197 class TimeSlotManager {
198   static TIME_SLOT_DURATION_MS = 20;
199 
200   static CHECK_TIME_EVERY = 100;
201 
202   constructor() {
203     this.reset();
204   }
205 
206   check() {
207     if (++this.checked < TimeSlotManager.CHECK_TIME_EVERY) {
208       return false;
209     }
210     this.checked = 0;
211     return this.endTime <= Date.now();
212   }
213 
214   reset() {
215     this.endTime = Date.now() + TimeSlotManager.TIME_SLOT_DURATION_MS;
216     this.checked = 0;
217   }
218 }
219 
220 class PartialEvaluator {
221   constructor({
222     xref,
223     handler,
224     pageIndex,
225     idFactory,
226     fontCache,
227     builtInCMapCache,
228     standardFontDataCache,
229     globalColorSpaceCache,
230     globalImageCache,
231     systemFontCache,
232     options = null,
233   }) {
234     this.xref = xref;
235     this.handler = handler;
236     this.pageIndex = pageIndex;
237     this.idFactory = idFactory;
238     this.fontCache = fontCache;
239     this.builtInCMapCache = builtInCMapCache;
240     this.standardFontDataCache = standardFontDataCache;
241     this.globalColorSpaceCache = globalColorSpaceCache;
242     this.globalImageCache = globalImageCache;
243     this.systemFontCache = systemFontCache;
244     this.options = options || DefaultPartialEvaluatorOptions;
245     this.type3FontRefs = null;
246 
247     this._regionalImageCache = new RegionalImageCache();
248     this._fetchBuiltInCMapBound = this.fetchBuiltInCMap.bind(this);
249   }
250 
251   /**
252    * Since Functions are only cached (locally) by reference, we can share one
253    * `PDFFunctionFactory` instance within this `PartialEvaluator` instance.
254    */
255   get _pdfFunctionFactory() {
256     const pdfFunctionFactory = new PDFFunctionFactory({
257       xref: this.xref,
258       isEvalSupported: this.options.isEvalSupported,
259     });
260     return shadow(this, "_pdfFunctionFactory", pdfFunctionFactory);
261   }
262 
263   get parsingType3Font() {
264     return !!this.type3FontRefs;
265   }
266 
267   clone(newOptions = null) {
268     const newEvaluator = Object.create(this);
269     newEvaluator.options = Object.assign(
270       Object.create(null),
271       this.options,
272       newOptions
273     );
274     return newEvaluator;
275   }
276 
277   hasBlendModes(resources, nonBlendModesSet) {
278     if (!(resources instanceof Dict)) {
279       return false;
280     }
281     if (resources.objId && nonBlendModesSet.has(resources.objId)) {
282       return false;
283     }
284 
285     const processed = new RefSet(nonBlendModesSet);
286     if (resources.objId) {
287       processed.put(resources.objId);
288     }
289 
290     const nodes = [resources],
291       xref = this.xref;
292     while (nodes.length) {
293       const node = nodes.shift();
294       // First check the current resources for blend modes.
295       const graphicStates = node.get("ExtGState");
296       if (graphicStates instanceof Dict) {
297         for (let graphicState of graphicStates.getRawValues()) {
298           if (graphicState instanceof Ref) {
299             if (processed.has(graphicState)) {
300               continue; // The ExtGState has already been processed.
301             }
302             try {
303               graphicState = xref.fetch(graphicState);
304             } catch (ex) {
305               // Avoid parsing a corrupt ExtGState more than once.
306               processed.put(graphicState);
307 
308               info(`hasBlendModes - ignoring ExtGState: "${ex}".`);
309               continue;
310             }
311           }
312           if (!(graphicState instanceof Dict)) {
313             continue;
314           }
315           if (graphicState.objId) {
316             processed.put(graphicState.objId);
317           }
318 
319           const bm = graphicState.get("BM");
320           if (bm instanceof Name) {
321             if (bm.name !== "Normal") {
322               return true;
323             }
324             continue;
325           }
326           if (bm !== undefined && Array.isArray(bm)) {
327             for (const element of bm) {
328               if (element instanceof Name && element.name !== "Normal") {
329                 return true;
330               }
331             }
332           }
333         }
334       }
335       // Descend into the XObjects to look for more resources and blend modes.
336       const xObjects = node.get("XObject");
337       if (!(xObjects instanceof Dict)) {
338         continue;
339       }
340       for (let xObject of xObjects.getRawValues()) {
341         if (xObject instanceof Ref) {
342           if (processed.has(xObject)) {
343             // The XObject has already been processed, and by avoiding a
344             // redundant `xref.fetch` we can *significantly* reduce the load
345             // time for badly generated PDF files (fixes issue6961.pdf).
346             continue;
347           }
348           try {
349             xObject = xref.fetch(xObject);
350           } catch (ex) {
351             // Avoid parsing a corrupt XObject more than once.
352             processed.put(xObject);
353 
354             info(`hasBlendModes - ignoring XObject: "${ex}".`);
355             continue;
356           }
357         }
358         if (!(xObject instanceof BaseStream)) {
359           continue;
360         }
361         if (xObject.dict.objId) {
362           processed.put(xObject.dict.objId);
363         }
364         const xResources = xObject.dict.get("Resources");
365         if (!(xResources instanceof Dict)) {
366           continue;
367         }
368         // Checking objId to detect an infinite loop.
369         if (xResources.objId && processed.has(xResources.objId)) {
370           continue;
371         }
372 
373         nodes.push(xResources);
374         if (xResources.objId) {
375           processed.put(xResources.objId);
376         }
377       }
378     }
379 
380     // When no blend modes exist, there's no need re-fetch/re-parse any of the
381     // processed `Ref`s again for subsequent pages. This helps reduce redundant
382     // `XRef.fetch` calls for some documents (e.g. issue6961.pdf).
383     for (const ref of processed) {
384       nonBlendModesSet.put(ref);
385     }
386     return false;
387   }
388 
389   async fetchBuiltInCMap(name) {
390     const cachedData = this.builtInCMapCache.get(name);
391     if (cachedData) {
392       return cachedData;
393     }
394     let data;
395 
396     if (this.options.useWorkerFetch) {
397       // Only compressed CMaps are (currently) supported here.
398       data = {
399         cMapData: await fetchBinaryData(`${this.options.cMapUrl}${name}.bcmap`),
400         isCompressed: true,
401       };
402     } else {
403       // Get the data on the main-thread instead.
404       data = await this.handler.sendWithPromise("FetchBinaryData", {
405         type: "cMapReaderFactory",
406         name,
407       });
408     }
409     // Cache the CMap data, to avoid fetching it repeatedly.
410     this.builtInCMapCache.set(name, data);
411 
412     return data;
413   }
414 
415   async fetchStandardFontData(name) {
416     const cachedData = this.standardFontDataCache.get(name);
417     if (cachedData) {
418       return new Stream(cachedData);
419     }
420 
421     // The symbol fonts are not consistent across platforms, always load the
422     // standard font data for them.
423     if (
424       this.options.useSystemFonts &&
425       name !== "Symbol" &&
426       name !== "ZapfDingbats"
427     ) {
428       return null;
429     }
430 
431     const standardFontNameToFileName = getFontNameToFileMap(),
432       filename = standardFontNameToFileName[name];
433     let data;
434 
435     try {
436       if (this.options.useWorkerFetch) {
437         data = await fetchBinaryData(
438           `${this.options.standardFontDataUrl}${filename}`
439         );
440       } else {
441         // Get the data on the main-thread instead.
442         data = await this.handler.sendWithPromise("FetchBinaryData", {
443           type: "standardFontDataFactory",
444           filename,
445         });
446       }
447     } catch (ex) {
448       warn(ex);
449       return null;
450     }
451     // Cache the "raw" standard font data, to avoid fetching it repeatedly
452     // (see e.g. issue 11399).
453     this.standardFontDataCache.set(name, data);
454 
455     return new Stream(data);
456   }
457 
458   async buildFormXObject(
459     resources,
460     xobj,
461     smask,
462     operatorList,
463     task,
464     initialState,
465     localColorSpaceCache,
466     seenRefs
467   ) {
468     const { dict } = xobj;
469     const matrix = lookupMatrix(dict.getArray("Matrix"), null);
470     const bbox = lookupNormalRect(dict.getArray("BBox"), null);
471 
472     let optionalContent, groupOptions;
473     if (dict.has("OC")) {
474       optionalContent = await this.parseMarkedContentProps(
475         dict.get("OC"),
476         resources
477       );
478     }
479     if (optionalContent !== undefined) {
480       operatorList.addOp(OPS.beginMarkedContentProps, ["OC", optionalContent]);
481     }
482     const group = dict.get("Group");
483     if (group) {
484       groupOptions = {
485         matrix,
486         bbox,
487         smask,
488         isolated: false,
489         knockout: false,
490       };
491 
492       const groupSubtype = group.get("S");
493       let colorSpace = null;
494       if (isName(groupSubtype, "Transparency")) {
495         groupOptions.isolated = group.get("I") || false;
496         groupOptions.knockout = group.get("K") || false;
497         if (group.has("CS")) {
498           const cs = this._getColorSpace(
499             group.getRaw("CS"),
500             resources,
501             localColorSpaceCache
502           );
503           colorSpace =
504             cs instanceof ColorSpace ? cs : await this._handleColorSpace(cs);
505         }
506       }
507 
508       if (smask?.backdrop) {
509         colorSpace ||= ColorSpaceUtils.rgb;
510         smask.backdrop = colorSpace.getRgb(smask.backdrop, 0);
511       }
512 
513       operatorList.addOp(OPS.beginGroup, [groupOptions]);
514     }
515 
516     // If it's a group, a new canvas will be created that is the size of the
517     // bounding box and translated to the correct position so we don't need to
518     // apply the bounding box to it.
519     const f32matrix = matrix && new Float32Array(matrix);
520     const f32bbox = (!group && bbox && new Float32Array(bbox)) || null;
521     const args = [f32matrix, f32bbox];
522     operatorList.addOp(OPS.paintFormXObjectBegin, args);
523 
524     const localResources = dict.get("Resources");
525 
526     await this.getOperatorList({
527       stream: xobj,
528       task,
529       resources: localResources instanceof Dict ? localResources : resources,
530       operatorList,
531       initialState,
532       prevRefs: seenRefs,
533     });
534     operatorList.addOp(OPS.paintFormXObjectEnd, []);
535 
536     if (group) {
537       operatorList.addOp(OPS.endGroup, [groupOptions]);
538     }
539 
540     if (optionalContent !== undefined) {
541       operatorList.addOp(OPS.endMarkedContent, []);
542     }
543   }
544 
545   _sendImgData(objId, imgData, cacheGlobally = false) {
546     if (
547       (typeof PDFJSDev === "undefined" || PDFJSDev.test("TESTING")) &&
548       imgData
549     ) {
550       assert(Number.isInteger(imgData.dataLen), "Expected dataLen to be set.");
551     }
552     const transfers = imgData ? [imgData.bitmap || imgData.data.buffer] : null;
553 
554     if (this.parsingType3Font || cacheGlobally) {
555       return this.handler.send(
556         "commonobj",
557         [objId, "Image", imgData],
558         transfers
559       );
560     }
561     return this.handler.send(
562       "obj",
563       [objId, this.pageIndex, "Image", imgData],
564       transfers
565     );
566   }
567 
568   async buildPaintImageXObject({
569     resources,
570     image,
571     isInline = false,
572     operatorList,
573     cacheKey,
574     localImageCache,
575     localColorSpaceCache,
576   }) {
577     const { maxImageSize, ignoreErrors, isOffscreenCanvasSupported } =
578       this.options;
579 
580     const { dict } = image;
581     const imageRef = dict.objId;
582     const w = dict.get("W", "Width");
583     const h = dict.get("H", "Height");
584 
585     if (!(w && typeof w === "number") || !(h && typeof h === "number")) {
586       warn("Image dimensions are missing, or not numbers.");
587       return;
588     }
589     if (maxImageSize !== -1 && w * h > maxImageSize) {
590       const msg = "Image exceeded maximum allowed size and was removed.";
591 
592       if (!ignoreErrors) {
593         throw new Error(msg);
594       }
595       warn(msg);
596       return;
597     }
598 
599     let optionalContent;
600     if (dict.has("OC")) {
601       optionalContent = await this.parseMarkedContentProps(
602         dict.get("OC"),
603         resources
604       );
605     }
606 
607     const imageMask = dict.get("IM", "ImageMask") || false;
608     let imgData, fn, args;
609     if (imageMask) {
610       // This depends on a tmpCanvas being filled with the
611       // current fillStyle, such that processing the pixel
612       // data can't be done here. Instead of creating a
613       // complete PDFImage, only read the information needed
614       // for later.
615       imgData = await PDFImage.createMask({
616         image,
617         isOffscreenCanvasSupported:
618           isOffscreenCanvasSupported && !this.parsingType3Font,
619       });
620 
621       if (imgData.isSingleOpaquePixel) {
622         // Handles special case of mainly LaTeX documents which use image
623         // masks to draw lines with the current fill style.
624         fn = OPS.paintSolidColorImageMask;
625         args = [];
626         operatorList.addImageOps(fn, args, optionalContent);
627 
628         if (cacheKey) {
629           const cacheData = { fn, args, optionalContent };
630           localImageCache.set(cacheKey, imageRef, cacheData);
631 
632           if (imageRef) {
633             this._regionalImageCache.set(
634               /* name = */ null,
635               imageRef,
636               cacheData
637             );
638           }
639         }
640         return;
641       }
642 
643       if (this.parsingType3Font) {
644         // NOTE: Compared to other image resources we don't bother caching
645         // Type3-glyph image masks, since we've not come across any cases
646         // where that actually helps.
647         // In Type3-glyphs image masks are "always" inline resources,
648         // they're usually fairly small and aren't being re-used either.
649         if (typeof PDFJSDev === "undefined" || PDFJSDev.test("TESTING")) {
650           assert(
651             imgData.data instanceof Uint8Array,
652             "Type3 glyph image mask must be a TypedArray."
653           );
654         }
655         args = compileType3Glyph(imgData);
656 
657         if (args) {
658           operatorList.addImageOps(OPS.constructPath, args, optionalContent);
659           return;
660         }
661         warn("Cannot compile Type3 glyph.");
662 
663         // If compilation failed, or was disabled, fallback to using an inline
664         // image mask; this case should be extremely rare.
665         operatorList.addImageOps(
666           OPS.paintImageMaskXObject,
667           [imgData],
668           optionalContent
669         );
670         return;
671       }
672 
673       const objId = `mask_${this.idFactory.createObjId()}`;
674       operatorList.addDependency(objId);
675 
676       imgData.dataLen = imgData.bitmap
677         ? imgData.width * imgData.height * 4
678         : imgData.data.length;
679       this._sendImgData(objId, imgData);
680 
681       fn = OPS.paintImageMaskXObject;
682       args = [
683         {
684           data: objId,
685           width: imgData.width,
686           height: imgData.height,
687           interpolate: imgData.interpolate,
688           count: 1,
689         },
690       ];
691       operatorList.addImageOps(fn, args, optionalContent);
692 
693       if (cacheKey) {
694         const cacheData = { objId, fn, args, optionalContent };
695         localImageCache.set(cacheKey, imageRef, cacheData);
696 
697         if (imageRef) {
698           this._regionalImageCache.set(/* name = */ null, imageRef, cacheData);
699         }
700       }
701       return;
702     }
703 
704     const SMALL_IMAGE_DIMENSIONS = 200;
705     const hasMask = dict.has("SMask") || dict.has("Mask");
706     // Inlining small images into the queue as RGB data
707     if (isInline && w + h < SMALL_IMAGE_DIMENSIONS && !hasMask) {
708       try {
709         const imageObj = new PDFImage({
710           xref: this.xref,
711           res: resources,
712           image,
713           isInline,
714           pdfFunctionFactory: this._pdfFunctionFactory,
715           globalColorSpaceCache: this.globalColorSpaceCache,
716           localColorSpaceCache,
717         });
718         // We force the use of RGBA_32BPP images here, because we can't handle
719         // any other kind.
720         imgData = await imageObj.createImageData(
721           /* forceRGBA = */ true,
722           /* isOffscreenCanvasSupported = */ false
723         );
724         operatorList.addImageOps(
725           OPS.paintInlineImageXObject,
726           [imgData],
727           optionalContent
728         );
729       } catch (reason) {
730         const msg = `Unable to decode inline image: "${reason}".`;
731 
732         if (!ignoreErrors) {
733           throw new Error(msg);
734         }
735         warn(msg);
736       }
737       return;
738     }
739 
740     // If there is no imageMask, create the PDFImage and a lot
741     // of image processing can be done here.
742     let objId = `img_${this.idFactory.createObjId()}`,
743       cacheGlobally = false,
744       globalCacheData = null;
745 
746     if (this.parsingType3Font) {
747       objId = `${this.idFactory.getDocId()}_type3_${objId}`;
748     } else if (cacheKey && imageRef) {
749       cacheGlobally = this.globalImageCache.shouldCache(
750         imageRef,
751         this.pageIndex
752       );
753 
754       if (cacheGlobally) {
755         assert(!isInline, "Cannot cache an inline image globally.");
756 
757         objId = `${this.idFactory.getDocId()}_${objId}`;
758       }
759     }
760 
761     // Ensure that the dependency is added before the image is decoded.
762     operatorList.addDependency(objId);
763 
764     fn = OPS.paintImageXObject;
765     args = [objId, w, h];
766     operatorList.addImageOps(fn, args, optionalContent, hasMask);
767 
768     if (cacheGlobally) {
769       globalCacheData = {
770         objId,
771         fn,
772         args,
773         optionalContent,
774         hasMask,
775         byteSize: 0, // Temporary entry, to avoid `setData` returning early.
776       };
777 
778       if (this.globalImageCache.hasDecodeFailed(imageRef)) {
779         this.globalImageCache.setData(imageRef, globalCacheData);
780 
781         this._sendImgData(objId, /* imgData = */ null, cacheGlobally);
782         return;
783       }
784 
785       // For large (at least 500x500) or more complex images that we'll cache
786       // globally, check if the image is still cached locally on the main-thread
787       // to avoid having to re-parse the image (since that can be slow).
788       if (w * h > 250000 || hasMask) {
789         const localLength = await this.handler.sendWithPromise("commonobj", [
790           objId,
791           "CopyLocalImage",
792           { imageRef },
793         ]);
794 
795         if (localLength) {
796           this.globalImageCache.setData(imageRef, globalCacheData);
797           this.globalImageCache.addByteSize(imageRef, localLength);
798           return;
799         }
800       }
801     }
802 
803     PDFImage.buildImage({
804       xref: this.xref,
805       res: resources,
806       image,
807       isInline,
808       pdfFunctionFactory: this._pdfFunctionFactory,
809       globalColorSpaceCache: this.globalColorSpaceCache,
810       localColorSpaceCache,
811     })
812       .then(async imageObj => {
813         imgData = await imageObj.createImageData(
814           /* forceRGBA = */ false,
815           isOffscreenCanvasSupported
816         );
817         imgData.dataLen = imgData.bitmap
818           ? imgData.width * imgData.height * 4
819           : imgData.data.length;
820         imgData.ref = imageRef;
821 
822         if (cacheGlobally) {
823           this.globalImageCache.addByteSize(imageRef, imgData.dataLen);
824         }
825         return this._sendImgData(objId, imgData, cacheGlobally);
826       })
827       .catch(reason => {
828         warn(`Unable to decode image "${objId}": "${reason}".`);
829 
830         if (imageRef) {
831           this.globalImageCache.addDecodeFailed(imageRef);
832         }
833         return this._sendImgData(objId, /* imgData = */ null, cacheGlobally);
834       });
835 
836     if (cacheKey) {
837       const cacheData = { objId, fn, args, optionalContent, hasMask };
838       localImageCache.set(cacheKey, imageRef, cacheData);
839 
840       if (imageRef) {
841         this._regionalImageCache.set(/* name = */ null, imageRef, cacheData);
842 
843         if (cacheGlobally) {
844           assert(globalCacheData, "The global cache-data must be available.");
845           this.globalImageCache.setData(imageRef, globalCacheData);
846         }
847       }
848     }
849   }
850 
851   handleSMask(
852     smask,
853     resources,
854     operatorList,
855     task,
856     stateManager,
857     localColorSpaceCache,
858     seenRefs
859   ) {
860     const smaskContent = smask.get("G");
861     const smaskOptions = {
862       subtype: smask.get("S").name,
863       backdrop: smask.get("BC"),
864     };
865 
866     // The SMask might have a alpha/luminosity value transfer function --
867     // we will build a map of integer values in range 0..255 to be fast.
868     const transferObj = smask.get("TR");
869     if (isPDFFunction(transferObj)) {
870       const transferFn = this._pdfFunctionFactory.create(transferObj);
871       const transferMap = new Uint8Array(256);
872       const tmp = new Float32Array(1);
873       for (let i = 0; i < 256; i++) {
874         tmp[0] = i / 255;
875         transferFn(tmp, 0, tmp, 0);
876         transferMap[i] = (tmp[0] * 255) | 0;
877       }
878       smaskOptions.transferMap = transferMap;
879     }
880 
881     return this.buildFormXObject(
882       resources,
883       smaskContent,
884       smaskOptions,
885       operatorList,
886       task,
887       stateManager.state.clone({ newPath: true }),
888       localColorSpaceCache,
889       seenRefs
890     );
891   }
892 
893   handleTransferFunction(tr) {
894     let transferArray;
895     if (Array.isArray(tr)) {
896       transferArray = tr;
897     } else if (isPDFFunction(tr)) {
898       transferArray = [tr];
899     } else {
900       return null; // Not a valid transfer function entry.
901     }
902 
903     const transferMaps = [];
904     let numFns = 0,
905       numEffectfulFns = 0;
906     for (const entry of transferArray) {
907       const transferObj = this.xref.fetchIfRef(entry);
908       numFns++;
909 
910       if (isName(transferObj, "Identity")) {
911         transferMaps.push(null);
912         continue;
913       } else if (!isPDFFunction(transferObj)) {
914         return null; // Not a valid transfer function object.
915       }
916 
917       const transferFn = this._pdfFunctionFactory.create(transferObj);
918       const transferMap = new Uint8Array(256),
919         tmp = new Float32Array(1);
920       for (let j = 0; j < 256; j++) {
921         tmp[0] = j / 255;
922         transferFn(tmp, 0, tmp, 0);
923         transferMap[j] = (tmp[0] * 255) | 0;
924       }
925       transferMaps.push(transferMap);
926       numEffectfulFns++;
927     }
928 
929     if (!(numFns === 1 || numFns === 4)) {
930       return null; // Only 1 or 4 functions are supported, by the specification.
931     }
932     if (numEffectfulFns === 0) {
933       return null; // Only /Identity transfer functions found, which are no-ops.
934     }
935     return transferMaps;
936   }
937 
938   handleTilingType(
939     fn,
940     color,
941     resources,
942     pattern,
943     patternDict,
944     operatorList,
945     task,
946     localTilingPatternCache
947   ) {
948     // Create an IR of the pattern code.
949     const tilingOpList = new OperatorList();
950     // Merge the available resources, to prevent issues when the patternDict
951     // is missing some /Resources entries (fixes issue6541.pdf).
952     const patternResources = Dict.merge({
953       xref: this.xref,
954       dictArray: [patternDict.get("Resources"), resources],
955     });
956 
957     return this.getOperatorList({
958       stream: pattern,
959       task,
960       resources: patternResources,
961       operatorList: tilingOpList,
962     })
963       .then(function () {
964         const operatorListIR = tilingOpList.getIR();
965         const tilingPatternIR = getTilingPatternIR(
966           operatorListIR,
967           patternDict,
968           color
969         );
970         // Add the dependencies to the parent operator list so they are
971         // resolved before the sub operator list is executed synchronously.
972         operatorList.addDependencies(tilingOpList.dependencies);
973         operatorList.addOp(fn, tilingPatternIR);
974 
975         if (patternDict.objId) {
976           localTilingPatternCache.set(/* name = */ null, patternDict.objId, {
977             operatorListIR,
978             dict: patternDict,
979           });
980         }
981       })
982       .catch(reason => {
983         if (reason instanceof AbortException) {
984           return;
985         }
986         if (this.options.ignoreErrors) {
987           warn(`handleTilingType - ignoring pattern: "${reason}".`);
988           return;
989         }
990         throw reason;
991       });
992   }
993 
994   async handleSetFont(
995     resources,
996     fontArgs,
997     fontRef,
998     operatorList,
999     task,
1000     state,
1001     fallbackFontDict = null,
1002     cssFontInfo = null
1003   ) {
1004     const fontName = fontArgs?.[0] instanceof Name ? fontArgs[0].name : null;
1005 
1006     const translated = await this.loadFont(
1007       fontName,
1008       fontRef,
1009       resources,
1010       task,
1011       fallbackFontDict,
1012       cssFontInfo
1013     );
1014 
1015     if (translated.font.isType3Font) {
1016       // Add the dependencies to the parent operatorList so they are
1017       // resolved before Type3 operatorLists are executed synchronously.
1018       operatorList.addDependencies(translated.type3Dependencies);
1019     }
1020 
1021     state.font = translated.font;
1022     translated.send(this.handler);
1023     return translated.loadedName;
1024   }
1025 
1026   handleText(chars, state) {
1027     const font = state.font;
1028     const glyphs = font.charsToGlyphs(chars);
1029 
1030     if (font.data) {
1031       const isAddToPathSet = !!(
1032         state.textRenderingMode & TextRenderingMode.ADD_TO_PATH_FLAG
1033       );
1034       if (
1035         isAddToPathSet ||
1036         state.fillColorSpace.name === "Pattern" ||
1037         font.disableFontFace
1038       ) {
1039         PartialEvaluator.buildFontPaths(
1040           font,
1041           glyphs,
1042           this.handler,
1043           this.options
1044         );
1045       }
1046     }
1047     return glyphs;
1048   }
1049 
1050   ensureStateFont(state) {
1051     if (state.font) {
1052       return;
1053     }
1054     const reason = new FormatError(
1055       "Missing setFont (Tf) operator before text rendering operator."
1056     );
1057 
1058     if (this.options.ignoreErrors) {
1059       warn(`ensureStateFont: "${reason}".`);
1060       return;
1061     }
1062     throw reason;
1063   }
1064 
1065   async setGState({
1066     resources,
1067     gState,
1068     operatorList,
1069     cacheKey,
1070     task,
1071     stateManager,
1072     localGStateCache,
1073     localColorSpaceCache,
1074     seenRefs,
1075   }) {
1076     const gStateRef = gState.objId;
1077     let isSimpleGState = true;
1078     // This array holds the converted/processed state data.
1079     const gStateObj = [];
1080     let promise = Promise.resolve();
1081     for (const [key, value] of gState) {
1082       switch (key) {
1083         case "Type":
1084           break;
1085         case "LW":
1086           if (typeof value !== "number") {
1087             warn(`Invalid LW (line width): ${value}`);
1088             break;
1089           }
1090           gStateObj.push([key, Math.abs(value)]);
1091           break;
1092         case "LC":
1093         case "LJ":
1094         case "ML":
1095         case "D":
1096         case "RI":
1097         case "FL":
1098         case "CA":
1099         case "ca":
1100           gStateObj.push([key, value]);
1101           break;
1102         case "Font":
1103           isSimpleGState = false;
1104 
1105           promise = promise.then(() =>
1106             this.handleSetFont(
1107               resources,
1108               null,
1109               value[0],
1110               operatorList,
1111               task,
1112               stateManager.state
1113             ).then(function (loadedName) {
1114               operatorList.addDependency(loadedName);
1115               gStateObj.push([key, [loadedName, value[1]]]);
1116             })
1117           );
1118           break;
1119         case "BM":
1120           gStateObj.push([key, normalizeBlendMode(value)]);
1121           break;
1122         case "SMask":
1123           if (isName(value, "None")) {
1124             gStateObj.push([key, false]);
1125             break;
1126           }
1127           if (value instanceof Dict) {
1128             isSimpleGState = false;
1129 
1130             promise = promise.then(() =>
1131               this.handleSMask(
1132                 value,
1133                 resources,
1134                 operatorList,
1135                 task,
1136                 stateManager,
1137                 localColorSpaceCache,
1138                 seenRefs
1139               )
1140             );
1141             gStateObj.push([key, true]);
1142           } else {
1143             warn("Unsupported SMask type");
1144           }
1145           break;
1146         case "TR":
1147           const transferMaps = this.handleTransferFunction(value);
1148           gStateObj.push([key, transferMaps]);
1149           break;
1150         // Only generate info log messages for the following since
1151         // they are unlikely to have a big impact on the rendering.
1152         case "OP":
1153         case "op":
1154         case "OPM":
1155         case "BG":
1156         case "BG2":
1157         case "UCR":
1158         case "UCR2":
1159         case "TR2":
1160         case "HT":
1161         case "SM":
1162         case "SA":
1163         case "AIS":
1164         case "TK":
1165           // TODO implement these operators.
1166           info("graphic state operator " + key);
1167           break;
1168         default:
1169           info("Unknown graphic state operator " + key);
1170           break;
1171       }
1172     }
1173     await promise;
1174 
1175     if (gStateObj.length > 0) {
1176       operatorList.addOp(OPS.setGState, [gStateObj]);
1177     }
1178 
1179     if (isSimpleGState) {
1180       localGStateCache.set(cacheKey, gStateRef, gStateObj);
1181     }
1182   }
1183 
1184   loadFont(
1185     fontName,
1186     font,
1187     resources,
1188     task,
1189     fallbackFontDict = null,
1190     cssFontInfo = null
1191   ) {
1192     const errorFont = async () =>
1193       new TranslatedFont({
1194         loadedName: "g_font_error",
1195         font: new ErrorFont(`Font "${fontName}" is not available.`),
1196         dict: font,
1197       });
1198 
1199     let fontRef;
1200     if (font) {
1201       // Loading by ref.
1202       if (font instanceof Ref) {
1203         fontRef = font;
1204       }
1205     } else {
1206       // Loading by name.
1207       const fontRes = resources.get("Font");
1208       if (fontRes) {
1209         fontRef = fontRes.getRaw(fontName);
1210       }
1211     }
1212     if (fontRef) {
1213       if (this.type3FontRefs?.has(fontRef)) {
1214         return errorFont();
1215       }
1216 
1217       if (this.fontCache.has(fontRef)) {
1218         return this.fontCache.get(fontRef);
1219       }
1220 
1221       try {
1222         font = this.xref.fetchIfRef(fontRef);
1223       } catch (ex) {
1224         warn(`loadFont - lookup failed: "${ex}".`);
1225       }
1226     }
1227 
1228     if (!(font instanceof Dict)) {
1229       if (!this.options.ignoreErrors && !this.parsingType3Font) {
1230         warn(`Font "${fontName}" is not available.`);
1231         return errorFont();
1232       }
1233       warn(
1234         `Font "${fontName}" is not available -- attempting to fallback to a default font.`
1235       );
1236 
1237       // Falling back to a default font to avoid completely broken rendering,
1238       // but note that there're no guarantees that things will look "correct".
1239       font = fallbackFontDict || PartialEvaluator.fallbackFontDict;
1240     }
1241 
1242     // We are holding `font.cacheKey` references only for `fontRef`s that
1243     // are not actually `Ref`s, but rather `Dict`s. See explanation below.
1244     if (font.cacheKey && this.fontCache.has(font.cacheKey)) {
1245       return this.fontCache.get(font.cacheKey);
1246     }
1247 
1248     const { promise, resolve } = Promise.withResolvers();
1249 
1250     let preEvaluatedFont;
1251     try {
1252       preEvaluatedFont = this.preEvaluateFont(font);
1253       preEvaluatedFont.cssFontInfo = cssFontInfo;
1254     } catch (reason) {
1255       warn(`loadFont - preEvaluateFont failed: "${reason}".`);
1256       return errorFont();
1257     }
1258     const { descriptor, hash } = preEvaluatedFont;
1259 
1260     const fontRefIsRef = fontRef instanceof Ref;
1261     let fontID;
1262 
1263     if (hash && descriptor instanceof Dict) {
1264       const fontAliases = (descriptor.fontAliases ||= Object.create(null));
1265 
1266       if (fontAliases[hash]) {
1267         const aliasFontRef = fontAliases[hash].aliasRef;
1268         if (fontRefIsRef && aliasFontRef && this.fontCache.has(aliasFontRef)) {
1269           this.fontCache.putAlias(fontRef, aliasFontRef);
1270           return this.fontCache.get(fontRef);
1271         }
1272       } else {
1273         fontAliases[hash] = {
1274           fontID: this.idFactory.createFontId(),
1275         };
1276       }
1277 
1278       if (fontRefIsRef) {
1279         fontAliases[hash].aliasRef = fontRef;
1280       }
1281       fontID = fontAliases[hash].fontID;
1282     } else {
1283       fontID = this.idFactory.createFontId();
1284     }
1285     assert(
1286       fontID?.startsWith("f"),
1287       'The "fontID" must be (correctly) defined.'
1288     );
1289 
1290     // Workaround for bad PDF generators that reference fonts incorrectly,
1291     // where `fontRef` is a `Dict` rather than a `Ref` (fixes bug946506.pdf).
1292     // In this case we cannot put the font into `this.fontCache` (which is
1293     // a `RefSetCache`), since it's not possible to use a `Dict` as a key.
1294     //
1295     // However, if we don't cache the font it's not possible to remove it
1296     // when `cleanup` is triggered from the API, which causes issues on
1297     // subsequent rendering operations (see issue7403.pdf) and would force us
1298     // to unnecessarily load the same fonts over and over.
1299     //
1300     // Instead, we cheat a bit by using a modified `fontID` as a key in
1301     // `this.fontCache`, to allow the font to be cached.
1302     // NOTE: This works because `RefSetCache` calls `toString()` on provided
1303     //       keys. Also, since `fontRef` is used when getting cached fonts,
1304     //       we'll not accidentally match fonts cached with the `fontID`.
1305     if (fontRefIsRef) {
1306       this.fontCache.put(fontRef, promise);
1307     } else {
1308       font.cacheKey = `cacheKey_${fontID}`;
1309       this.fontCache.put(font.cacheKey, promise);
1310     }
1311 
1312     // Keep track of each font we translated so the caller can
1313     // load them asynchronously before calling display on a page.
1314     font.loadedName = `${this.idFactory.getDocId()}_${fontID}`;
1315 
1316     this.translateFont(preEvaluatedFont)
1317       .then(async translatedFont => {
1318         const translated = new TranslatedFont({
1319           loadedName: font.loadedName,
1320           font: translatedFont,
1321           dict: font,
1322         });
1323 
1324         if (translatedFont.isType3Font) {
1325           try {
1326             await translated.loadType3Data(this, resources, task);
1327           } catch (reason) {
1328             throw new Error(`Type3 font load error: ${reason}`);
1329           }
1330         }
1331         resolve(translated);
1332       })
1333       .catch(reason => {
1334         // TODO reject?
1335         warn(`loadFont - translateFont failed: "${reason}".`);
1336 
1337         resolve(
1338           new TranslatedFont({
1339             loadedName: font.loadedName,
1340             font: new ErrorFont(reason?.message),
1341             dict: font,
1342           })
1343         );
1344       });
1345     return promise;
1346   }
1347 
1348   buildPath(fn, args, state) {
1349     const { pathMinMax: minMax, pathBuffer } = state;
1350     switch (fn | 0) {
1351       case OPS.rectangle: {
1352         const x = (state.currentPointX = args[0]);
1353         const y = (state.currentPointY = args[1]);
1354         const width = args[2];
1355         const height = args[3];
1356         const xw = x + width;
1357         const yh = y + height;
1358         if (width === 0 || height === 0) {
1359           pathBuffer.push(
1360             DrawOPS.moveTo,
1361             x,
1362             y,
1363             DrawOPS.lineTo,
1364             xw,
1365             yh,
1366             DrawOPS.closePath
1367           );
1368         } else {
1369           pathBuffer.push(
1370             DrawOPS.moveTo,
1371             x,
1372             y,
1373             DrawOPS.lineTo,
1374             xw,
1375             y,
1376             DrawOPS.lineTo,
1377             xw,
1378             yh,
1379             DrawOPS.lineTo,
1380             x,
1381             yh,
1382             DrawOPS.closePath
1383           );
1384         }
1385         Util.rectBoundingBox(x, y, xw, yh, minMax);
1386         break;
1387       }
1388       case OPS.moveTo: {
1389         const x = (state.currentPointX = args[0]);
1390         const y = (state.currentPointY = args[1]);
1391         pathBuffer.push(DrawOPS.moveTo, x, y);
1392         Util.pointBoundingBox(x, y, minMax);
1393         break;
1394       }
1395       case OPS.lineTo: {
1396         const x = (state.currentPointX = args[0]);
1397         const y = (state.currentPointY = args[1]);
1398         pathBuffer.push(DrawOPS.lineTo, x, y);
1399         Util.pointBoundingBox(x, y, minMax);
1400         break;
1401       }
1402       case OPS.curveTo: {
1403         const startX = state.currentPointX;
1404         const startY = state.currentPointY;
1405         const [x1, y1, x2, y2, x, y] = args;
1406         state.currentPointX = x;
1407         state.currentPointY = y;
1408         pathBuffer.push(DrawOPS.curveTo, x1, y1, x2, y2, x, y);
1409         Util.bezierBoundingBox(startX, startY, x1, y1, x2, y2, x, y, minMax);
1410         break;
1411       }
1412       case OPS.curveTo2: {
1413         const startX = state.currentPointX;
1414         const startY = state.currentPointY;
1415         const [x1, y1, x, y] = args;
1416         state.currentPointX = x;
1417         state.currentPointY = y;
1418         pathBuffer.push(DrawOPS.curveTo, startX, startY, x1, y1, x, y);
1419         Util.bezierBoundingBox(
1420           startX,
1421           startY,
1422           startX,
1423           startY,
1424           x1,
1425           y1,
1426           x,
1427           y,
1428           minMax
1429         );
1430         break;
1431       }
1432       case OPS.curveTo3: {
1433         const startX = state.currentPointX;
1434         const startY = state.currentPointY;
1435         const [x1, y1, x, y] = args;
1436         state.currentPointX = x;
1437         state.currentPointY = y;
1438         pathBuffer.push(DrawOPS.curveTo, x1, y1, x, y, x, y);
1439         Util.bezierBoundingBox(startX, startY, x1, y1, x, y, x, y, minMax);
1440         break;
1441       }
1442       case OPS.closePath:
1443         pathBuffer.push(DrawOPS.closePath);
1444         break;
1445     }
1446   }
1447 
1448   _getColorSpace(cs, resources, localColorSpaceCache) {
1449     return ColorSpaceUtils.parse({
1450       cs,
1451       xref: this.xref,
1452       resources,
1453       pdfFunctionFactory: this._pdfFunctionFactory,
1454       globalColorSpaceCache: this.globalColorSpaceCache,
1455       localColorSpaceCache,
1456       asyncIfNotCached: true,
1457     });
1458   }
1459 
1460   async _handleColorSpace(csPromise) {
1461     try {
1462       return await csPromise;
1463     } catch (ex) {
1464       if (ex instanceof AbortException) {
1465         return null;
1466       }
1467       if (this.options.ignoreErrors) {
1468         warn(`_handleColorSpace - ignoring ColorSpace: "${ex}".`);
1469         return null;
1470       }
1471       throw ex;
1472     }
1473   }
1474 
1475   parseShading({
1476     shading,
1477     resources,
1478     localColorSpaceCache,
1479     localShadingPatternCache,
1480   }) {
1481     // Shadings and patterns may be referenced by the same name but the resource
1482     // dictionary could be different so we can't use the name for the cache key.
1483     let id = localShadingPatternCache.get(shading);
1484     if (id) {
1485       return id;
1486     }
1487     let patternIR;
1488 
1489     try {
1490       const shadingFill = Pattern.parseShading(
1491         shading,
1492         this.xref,
1493         resources,
1494         this._pdfFunctionFactory,
1495         this.globalColorSpaceCache,
1496         localColorSpaceCache
1497       );
1498       patternIR = shadingFill.getIR();
1499     } catch (reason) {
1500       if (reason instanceof AbortException) {
1501         return null;
1502       }
1503       if (this.options.ignoreErrors) {
1504         warn(`parseShading - ignoring shading: "${reason}".`);
1505 
1506         localShadingPatternCache.set(shading, null);
1507         return null;
1508       }
1509       throw reason;
1510     }
1511 
1512     id = `pattern_${this.idFactory.createObjId()}`;
1513     if (this.parsingType3Font) {
1514       id = `${this.idFactory.getDocId()}_type3_${id}`;
1515     }
1516     localShadingPatternCache.set(shading, id);
1517 
1518     if (this.parsingType3Font) {
1519       this.handler.send("commonobj", [id, "Pattern", patternIR]);
1520     } else {
1521       this.handler.send("obj", [id, this.pageIndex, "Pattern", patternIR]);
1522     }
1523     return id;
1524   }
1525 
1526   handleColorN(
1527     operatorList,
1528     fn,
1529     args,
1530     cs,
1531     patterns,
1532     resources,
1533     task,
1534     localColorSpaceCache,
1535     localTilingPatternCache,
1536     localShadingPatternCache
1537   ) {
1538     // compile tiling patterns
1539     const patternName = args.pop();
1540     // SCN/scn applies patterns along with normal colors
1541     if (patternName instanceof Name) {
1542       const rawPattern = patterns.getRaw(patternName.name);
1543 
1544       const localTilingPattern =
1545         rawPattern instanceof Ref &&
1546         localTilingPatternCache.getByRef(rawPattern);
1547       if (localTilingPattern) {
1548         try {
1549           const color = cs.base ? cs.base.getRgb(args, 0) : null;
1550           const tilingPatternIR = getTilingPatternIR(
1551             localTilingPattern.operatorListIR,
1552             localTilingPattern.dict,
1553             color
1554           );
1555           operatorList.addOp(fn, tilingPatternIR);
1556           return undefined;
1557         } catch {
1558           // Handle any errors during normal TilingPattern parsing.
1559         }
1560       }
1561 
1562       const pattern = this.xref.fetchIfRef(rawPattern);
1563       if (pattern) {
1564         const dict = pattern instanceof BaseStream ? pattern.dict : pattern;
1565         const typeNum = dict.get("PatternType");
1566 
1567         if (typeNum === PatternType.TILING) {
1568           const color = cs.base ? cs.base.getRgb(args, 0) : null;
1569           return this.handleTilingType(
1570             fn,
1571             color,
1572             resources,
1573             pattern,
1574             dict,
1575             operatorList,
1576             task,
1577             localTilingPatternCache
1578           );
1579         } else if (typeNum === PatternType.SHADING) {
1580           const shading = dict.get("Shading");
1581           const objId = this.parseShading({
1582             shading,
1583             resources,
1584             localColorSpaceCache,
1585             localShadingPatternCache,
1586           });
1587           if (objId) {
1588             const matrix = lookupMatrix(dict.getArray("Matrix"), null);
1589             operatorList.addOp(fn, ["Shading", objId, matrix]);
1590           }
1591           return undefined;
1592         }
1593         throw new FormatError(`Unknown PatternType: ${typeNum}`);
1594       }
1595     }
1596     throw new FormatError(`Unknown PatternName: ${patternName}`);
1597   }
1598 
1599   _parseVisibilityExpression(array, nestingCounter, currentResult) {
1600     const MAX_NESTING = 10;
1601     if (++nestingCounter > MAX_NESTING) {
1602       warn("Visibility expression is too deeply nested");
1603       return;
1604     }
1605     const length = array.length;
1606     const operator = this.xref.fetchIfRef(array[0]);
1607     if (length < 2 || !(operator instanceof Name)) {
1608       warn("Invalid visibility expression");
1609       return;
1610     }
1611     switch (operator.name) {
1612       case "And":
1613       case "Or":
1614       case "Not":
1615         currentResult.push(operator.name);
1616         break;
1617       default:
1618         warn(`Invalid operator ${operator.name} in visibility expression`);
1619         return;
1620     }
1621     for (let i = 1; i < length; i++) {
1622       const raw = array[i];
1623       const object = this.xref.fetchIfRef(raw);
1624       if (Array.isArray(object)) {
1625         const nestedResult = [];
1626         currentResult.push(nestedResult);
1627         // Recursively parse a subarray.
1628         this._parseVisibilityExpression(object, nestingCounter, nestedResult);
1629       } else if (raw instanceof Ref) {
1630         // Reference to an OCG dictionary.
1631         currentResult.push(raw.toString());
1632       }
1633     }
1634   }
1635 
1636   async parseMarkedContentProps(contentProperties, resources) {
1637     let optionalContent;
1638     if (contentProperties instanceof Name) {
1639       const properties = resources.get("Properties");
1640       optionalContent = properties.get(contentProperties.name);
1641     } else if (contentProperties instanceof Dict) {
1642       optionalContent = contentProperties;
1643     } else {
1644       throw new FormatError("Optional content properties malformed.");
1645     }
1646 
1647     const optionalContentType = optionalContent.get("Type")?.name;
1648     if (optionalContentType === "OCG") {
1649       return {
1650         type: optionalContentType,
1651         id: optionalContent.objId,
1652       };
1653     } else if (optionalContentType === "OCMD") {
1654       const expression = optionalContent.get("VE");
1655       if (Array.isArray(expression)) {
1656         const result = [];
1657         this._parseVisibilityExpression(expression, 0, result);
1658         if (result.length > 0) {
1659           return {
1660             type: "OCMD",
1661             expression: result,
1662           };
1663         }
1664       }
1665 
1666       const optionalContentGroups = optionalContent.get("OCGs");
1667       if (
1668         Array.isArray(optionalContentGroups) ||
1669         optionalContentGroups instanceof Dict
1670       ) {
1671         const groupIds = [];
1672         if (Array.isArray(optionalContentGroups)) {
1673           for (const ocg of optionalContentGroups) {
1674             groupIds.push(ocg.toString());
1675           }
1676         } else {
1677           // Dictionary, just use the obj id.
1678           groupIds.push(optionalContentGroups.objId);
1679         }
1680 
1681         return {
1682           type: optionalContentType,
1683           ids: groupIds,
1684           policy:
1685             optionalContent.get("P") instanceof Name
1686               ? optionalContent.get("P").name
1687               : null,
1688           expression: null,
1689         };
1690       } else if (optionalContentGroups instanceof Ref) {
1691         return {
1692           type: optionalContentType,
1693           id: optionalContentGroups.toString(),
1694         };
1695       }
1696     }
1697     return null;
1698   }
1699 
1700   getOperatorList({
1701     stream,
1702     task,
1703     resources,
1704     operatorList,
1705     initialState = null,
1706     fallbackFontDict = null,
1707     prevRefs = null,
1708   }) {
1709     const objId = stream.dict?.objId;
1710     const seenRefs = new RefSet(prevRefs);
1711 
1712     if (objId) {
1713       if (prevRefs?.has(objId)) {
1714         throw new Error(
1715           `getOperatorList - ignoring circular reference: ${objId}`
1716         );
1717       }
1718       seenRefs.put(objId);
1719     }
1720     // Ensure that `resources`/`initialState` is correctly initialized,
1721     // even if the provided parameter is e.g. `null`.
1722     resources ||= Dict.empty;
1723     initialState ||= new EvalState();
1724 
1725     if (!operatorList) {
1726       throw new Error('getOperatorList: missing "operatorList" parameter');
1727     }
1728 
1729     const self = this;
1730     const xref = this.xref;
1731     const localImageCache = new LocalImageCache();
1732     const localColorSpaceCache = new LocalColorSpaceCache();
1733     const localGStateCache = new LocalGStateCache();
1734     const localTilingPatternCache = new LocalTilingPatternCache();
1735     const localShadingPatternCache = new Map();
1736 
1737     const xobjs = resources.get("XObject") || Dict.empty;
1738     const patterns = resources.get("Pattern") || Dict.empty;
1739     const stateManager = new StateManager(initialState);
1740     const preprocessor = new EvaluatorPreprocessor(stream, xref, stateManager);
1741     const timeSlotManager = new TimeSlotManager();
1742 
1743     function closePendingRestoreOPS(argument) {
1744       for (let i = 0, ii = preprocessor.savedStatesDepth; i < ii; i++) {
1745         operatorList.addOp(OPS.restore, []);
1746       }
1747     }
1748 
1749     return new Promise(function promiseBody(resolve, reject) {
1750       const next = function (promise) {
1751         Promise.all([promise, operatorList.ready]).then(function () {
1752           try {
1753             promiseBody(resolve, reject);
1754           } catch (ex) {
1755             reject(ex);
1756           }
1757         }, reject);
1758       };
1759       task.ensureNotTerminated();
1760       timeSlotManager.reset();
1761 
1762       const operation = {};
1763       let stop, i, ii, cs, name, isValidName;
1764       while (!(stop = timeSlotManager.check())) {
1765         // The arguments parsed by read() are used beyond this loop, so we
1766         // cannot reuse the same array on each iteration. Therefore we pass
1767         // in |null| as the initial value (see the comment on
1768         // EvaluatorPreprocessor_read() for why).
1769         operation.args = null;
1770         if (!preprocessor.read(operation)) {
1771           break;
1772         }
1773         let args = operation.args;
1774         let fn = operation.fn;
1775 
1776         switch (fn | 0) {
1777           case OPS.paintXObject:
1778             // eagerly compile XForm objects
1779             isValidName = args[0] instanceof Name;
1780             name = args[0].name;
1781 
1782             if (isValidName) {
1783               const localImage = localImageCache.getByName(name);
1784               if (localImage) {
1785                 addCachedImageOps(operatorList, localImage);
1786                 args = null;
1787                 continue;
1788               }
1789             }
1790 
1791             next(
1792               new Promise(function (resolveXObject, rejectXObject) {
1793                 if (!isValidName) {
1794                   throw new FormatError("XObject must be referred to by name.");
1795                 }
1796 
1797                 let xobj = xobjs.getRaw(name);
1798                 if (xobj instanceof Ref) {
1799                   const cachedImage =
1800                     localImageCache.getByRef(xobj) ||
1801                     self._regionalImageCache.getByRef(xobj) ||
1802                     self.globalImageCache.getData(xobj, self.pageIndex);
1803                   if (cachedImage) {
1804                     addCachedImageOps(operatorList, cachedImage);
1805                     resolveXObject();
1806                     return;
1807                   }
1808 
1809                   xobj = xref.fetch(xobj);
1810                 }
1811 
1812                 if (!(xobj instanceof BaseStream)) {
1813                   throw new FormatError("XObject should be a stream");
1814                 }
1815 
1816                 const type = xobj.dict.get("Subtype");
1817                 if (!(type instanceof Name)) {
1818                   throw new FormatError("XObject should have a Name subtype");
1819                 }
1820 
1821                 if (type.name === "Form") {
1822                   stateManager.save();
1823                   self
1824                     .buildFormXObject(
1825                       resources,
1826                       xobj,
1827                       null,
1828                       operatorList,
1829                       task,
1830                       stateManager.state.clone({ newPath: true }),
1831                       localColorSpaceCache,
1832                       seenRefs
1833                     )
1834                     .then(function () {
1835                       stateManager.restore();
1836                       resolveXObject();
1837                     }, rejectXObject);
1838                   return;
1839                 } else if (type.name === "Image") {
1840                   self
1841                     .buildPaintImageXObject({
1842                       resources,
1843                       image: xobj,
1844                       operatorList,
1845                       cacheKey: name,
1846                       localImageCache,
1847                       localColorSpaceCache,
1848                     })
1849                     .then(resolveXObject, rejectXObject);
1850                   return;
1851                 } else if (type.name === "PS") {
1852                   // PostScript XObjects are unused when viewing documents.
1853                   // See section 4.7.1 of Adobe's PDF reference.
1854                   info("Ignored XObject subtype PS");
1855                 } else {
1856                   throw new FormatError(
1857                     `Unhandled XObject subtype ${type.name}`
1858                   );
1859                 }
1860                 resolveXObject();
1861               }).catch(function (reason) {
1862                 if (reason instanceof AbortException) {
1863                   return;
1864                 }
1865                 if (self.options.ignoreErrors) {
1866                   warn(`getOperatorList - ignoring XObject: "${reason}".`);
1867                   return;
1868                 }
1869                 throw reason;
1870               })
1871             );
1872             return;
1873           case OPS.setFont:
1874             const fontSize = args[1];
1875             // eagerly collect all fonts
1876             next(
1877               self
1878                 .handleSetFont(
1879                   resources,
1880                   args,
1881                   null,
1882                   operatorList,
1883                   task,
1884                   stateManager.state,
1885                   fallbackFontDict
1886                 )
1887                 .then(function (loadedName) {
1888                   operatorList.addDependency(loadedName);
1889                   operatorList.addOp(OPS.setFont, [loadedName, fontSize]);
1890                 })
1891             );
1892             return;
1893           case OPS.endInlineImage:
1894             const cacheKey = args[0].cacheKey;
1895             if (cacheKey) {
1896               const localImage = localImageCache.getByName(cacheKey);
1897               if (localImage) {
1898                 addCachedImageOps(operatorList, localImage);
1899                 args = null;
1900                 continue;
1901               }
1902             }
1903             next(
1904               self.buildPaintImageXObject({
1905                 resources,
1906                 image: args[0],
1907                 isInline: true,
1908                 operatorList,
1909                 cacheKey,
1910                 localImageCache,
1911                 localColorSpaceCache,
1912               })
1913             );
1914             return;
1915           case OPS.showText:
1916             if (!stateManager.state.font) {
1917               self.ensureStateFont(stateManager.state);
1918               continue;
1919             }
1920             args[0] = self.handleText(args[0], stateManager.state);
1921             break;
1922           case OPS.showSpacedText:
1923             if (!stateManager.state.font) {
1924               self.ensureStateFont(stateManager.state);
1925               continue;
1926             }
1927             const combinedGlyphs = [],
1928               state = stateManager.state;
1929             for (const arrItem of args[0]) {
1930               if (typeof arrItem === "string") {
1931                 combinedGlyphs.push(...self.handleText(arrItem, state));
1932               } else if (typeof arrItem === "number") {
1933                 combinedGlyphs.push(arrItem);
1934               }
1935             }
1936             args[0] = combinedGlyphs;
1937             fn = OPS.showText;
1938             break;
1939           case OPS.nextLineShowText:
1940             if (!stateManager.state.font) {
1941               self.ensureStateFont(stateManager.state);
1942               continue;
1943             }
1944             operatorList.addOp(OPS.nextLine);
1945             args[0] = self.handleText(args[0], stateManager.state);
1946             fn = OPS.showText;
1947             break;
1948           case OPS.nextLineSetSpacingShowText:
1949             if (!stateManager.state.font) {
1950               self.ensureStateFont(stateManager.state);
1951               continue;
1952             }
1953             operatorList.addOp(OPS.nextLine);
1954             operatorList.addOp(OPS.setWordSpacing, [args.shift()]);
1955             operatorList.addOp(OPS.setCharSpacing, [args.shift()]);
1956             args[0] = self.handleText(args[0], stateManager.state);
1957             fn = OPS.showText;
1958             break;
1959           case OPS.setTextRenderingMode:
1960             stateManager.state.textRenderingMode = args[0];
1961             break;
1962 
1963           case OPS.setFillColorSpace: {
1964             const fillCS = self._getColorSpace(
1965               args[0],
1966               resources,
1967               localColorSpaceCache
1968             );
1969             if (fillCS instanceof ColorSpace) {
1970               stateManager.state.fillColorSpace = fillCS;
1971               continue;
1972             }
1973 
1974             next(
1975               self._handleColorSpace(fillCS).then(colorSpace => {
1976                 stateManager.state.fillColorSpace =
1977                   colorSpace || ColorSpaceUtils.gray;
1978               })
1979             );
1980             return;
1981           }
1982           case OPS.setStrokeColorSpace: {
1983             const strokeCS = self._getColorSpace(
1984               args[0],
1985               resources,
1986               localColorSpaceCache
1987             );
1988             if (strokeCS instanceof ColorSpace) {
1989               stateManager.state.strokeColorSpace = strokeCS;
1990               continue;
1991             }
1992 
1993             next(
1994               self._handleColorSpace(strokeCS).then(colorSpace => {
1995                 stateManager.state.strokeColorSpace =
1996                   colorSpace || ColorSpaceUtils.gray;
1997               })
1998             );
1999             return;
2000           }
2001           case OPS.setFillColor:
2002             cs = stateManager.state.fillColorSpace;
2003             args = cs.getRgb(args, 0);
2004             fn = OPS.setFillRGBColor;
2005             break;
2006           case OPS.setStrokeColor:
2007             cs = stateManager.state.strokeColorSpace;
2008             args = cs.getRgb(args, 0);
2009             fn = OPS.setStrokeRGBColor;
2010             break;
2011           case OPS.setFillGray:
2012             stateManager.state.fillColorSpace = ColorSpaceUtils.gray;
2013             args = ColorSpaceUtils.gray.getRgb(args, 0);
2014             fn = OPS.setFillRGBColor;
2015             break;
2016           case OPS.setStrokeGray:
2017             stateManager.state.strokeColorSpace = ColorSpaceUtils.gray;
2018             args = ColorSpaceUtils.gray.getRgb(args, 0);
2019             fn = OPS.setStrokeRGBColor;
2020             break;
2021           case OPS.setFillCMYKColor:
2022             stateManager.state.fillColorSpace = ColorSpaceUtils.cmyk;
2023             args = ColorSpaceUtils.cmyk.getRgb(args, 0);
2024             fn = OPS.setFillRGBColor;
2025             break;
2026           case OPS.setStrokeCMYKColor:
2027             stateManager.state.strokeColorSpace = ColorSpaceUtils.cmyk;
2028             args = ColorSpaceUtils.cmyk.getRgb(args, 0);
2029             fn = OPS.setStrokeRGBColor;
2030             break;
2031           case OPS.setFillRGBColor:
2032             stateManager.state.fillColorSpace = ColorSpaceUtils.rgb;
2033             args = ColorSpaceUtils.rgb.getRgb(args, 0);
2034             break;
2035           case OPS.setStrokeRGBColor:
2036             stateManager.state.strokeColorSpace = ColorSpaceUtils.rgb;
2037             args = ColorSpaceUtils.rgb.getRgb(args, 0);
2038             break;
2039           case OPS.setFillColorN:
2040             cs = stateManager.state.patternFillColorSpace;
2041             if (!cs) {
2042               if (isNumberArray(args, null)) {
2043                 args = ColorSpaceUtils.gray.getRgb(args, 0);
2044                 fn = OPS.setFillRGBColor;
2045                 break;
2046               }
2047               args = [];
2048               fn = OPS.setFillTransparent;
2049               break;
2050             }
2051             if (cs.name === "Pattern") {
2052               next(
2053                 self.handleColorN(
2054                   operatorList,
2055                   OPS.setFillColorN,
2056                   args,
2057                   cs,
2058                   patterns,
2059                   resources,
2060                   task,
2061                   localColorSpaceCache,
2062                   localTilingPatternCache,
2063                   localShadingPatternCache
2064                 )
2065               );
2066               return;
2067             }
2068             args = cs.getRgb(args, 0);
2069             fn = OPS.setFillRGBColor;
2070             break;
2071           case OPS.setStrokeColorN:
2072             cs = stateManager.state.patternStrokeColorSpace;
2073             if (!cs) {
2074               if (isNumberArray(args, null)) {
2075                 args = ColorSpaceUtils.gray.getRgb(args, 0);
2076                 fn = OPS.setStrokeRGBColor;
2077                 break;
2078               }
2079               args = [];
2080               fn = OPS.setStrokeTransparent;
2081               break;
2082             }
2083             if (cs.name === "Pattern") {
2084               next(
2085                 self.handleColorN(
2086                   operatorList,
2087                   OPS.setStrokeColorN,
2088                   args,
2089                   cs,
2090                   patterns,
2091                   resources,
2092                   task,
2093                   localColorSpaceCache,
2094                   localTilingPatternCache,
2095                   localShadingPatternCache
2096                 )
2097               );
2098               return;
2099             }
2100             args = cs.getRgb(args, 0);
2101             fn = OPS.setStrokeRGBColor;
2102             break;
2103 
2104           case OPS.shadingFill:
2105             let shading;
2106             try {
2107               const shadingRes = resources.get("Shading");
2108               if (!shadingRes) {
2109                 throw new FormatError("No shading resource found");
2110               }
2111 
2112               shading = shadingRes.get(args[0].name);
2113               if (!shading) {
2114                 throw new FormatError("No shading object found");
2115               }
2116             } catch (reason) {
2117               if (reason instanceof AbortException) {
2118                 continue;
2119               }
2120               if (self.options.ignoreErrors) {
2121                 warn(`getOperatorList - ignoring Shading: "${reason}".`);
2122                 continue;
2123               }
2124               throw reason;
2125             }
2126             const patternId = self.parseShading({
2127               shading,
2128               resources,
2129               localColorSpaceCache,
2130               localShadingPatternCache,
2131             });
2132             if (!patternId) {
2133               continue;
2134             }
2135             args = [patternId];
2136             fn = OPS.shadingFill;
2137             break;
2138           case OPS.setGState:
2139             isValidName = args[0] instanceof Name;
2140             name = args[0].name;
2141 
2142             if (isValidName) {
2143               const localGStateObj = localGStateCache.getByName(name);
2144               if (localGStateObj) {
2145                 if (localGStateObj.length > 0) {
2146                   operatorList.addOp(OPS.setGState, [localGStateObj]);
2147                 }
2148                 args = null;
2149                 continue;
2150               }
2151             }
2152 
2153             next(
2154               new Promise(function (resolveGState, rejectGState) {
2155                 if (!isValidName) {
2156                   throw new FormatError("GState must be referred to by name.");
2157                 }
2158 
2159                 const extGState = resources.get("ExtGState");
2160                 if (!(extGState instanceof Dict)) {
2161                   throw new FormatError("ExtGState should be a dictionary.");
2162                 }
2163 
2164                 const gState = extGState.get(name);
2165                 // TODO: Attempt to lookup cached GStates by reference as well,
2166                 //       if and only if there are PDF documents where doing so
2167                 //       would significantly improve performance.
2168                 if (!(gState instanceof Dict)) {
2169                   throw new FormatError("GState should be a dictionary.");
2170                 }
2171 
2172                 self
2173                   .setGState({
2174                     resources,
2175                     gState,
2176                     operatorList,
2177                     cacheKey: name,
2178                     task,
2179                     stateManager,
2180                     localGStateCache,
2181                     localColorSpaceCache,
2182                     seenRefs,
2183                   })
2184                   .then(resolveGState, rejectGState);
2185               }).catch(function (reason) {
2186                 if (reason instanceof AbortException) {
2187                   return;
2188                 }
2189                 if (self.options.ignoreErrors) {
2190                   warn(`getOperatorList - ignoring ExtGState: "${reason}".`);
2191                   return;
2192                 }
2193                 throw reason;
2194               })
2195             );
2196             return;
2197           case OPS.setLineWidth: {
2198             // The thickness should be a non-negative number, as per spec.
2199             // When the value is negative, Acrobat and Poppler take the absolute
2200             // value while PDFium takes the max of 0 and the value.
2201             const [thickness] = args;
2202             if (typeof thickness !== "number") {
2203               warn(`Invalid setLineWidth: ${thickness}`);
2204               continue;
2205             }
2206             args[0] = Math.abs(thickness);
2207             break;
2208           }
2209           case OPS.moveTo:
2210           case OPS.lineTo:
2211           case OPS.curveTo:
2212           case OPS.curveTo2:
2213           case OPS.curveTo3:
2214           case OPS.closePath:
2215           case OPS.rectangle:
2216             self.buildPath(fn, args, stateManager.state);
2217             continue;
2218           case OPS.stroke:
2219           case OPS.closeStroke:
2220           case OPS.fill:
2221           case OPS.eoFill:
2222           case OPS.fillStroke:
2223           case OPS.eoFillStroke:
2224           case OPS.closeFillStroke:
2225           case OPS.closeEOFillStroke:
2226           case OPS.endPath: {
2227             const {
2228               state: { pathBuffer, pathMinMax },
2229             } = stateManager;
2230             if (
2231               fn === OPS.closeStroke ||
2232               fn === OPS.closeFillStroke ||
2233               fn === OPS.closeEOFillStroke
2234             ) {
2235               pathBuffer.push(DrawOPS.closePath);
2236             }
2237             if (pathBuffer.length === 0) {
2238               operatorList.addOp(OPS.constructPath, [fn, [null], null]);
2239             } else {
2240               operatorList.addOp(OPS.constructPath, [
2241                 fn,
2242                 [new Float32Array(pathBuffer)],
2243                 pathMinMax.slice(),
2244               ]);
2245               pathBuffer.length = 0;
2246               pathMinMax.set([Infinity, Infinity, -Infinity, -Infinity], 0);
2247             }
2248             continue;
2249           }
2250           case OPS.setTextMatrix:
2251             operatorList.addOp(fn, [new Float32Array(args)]);
2252             continue;
2253           case OPS.markPoint:
2254           case OPS.markPointProps:
2255           case OPS.beginCompat:
2256           case OPS.endCompat:
2257             // Ignore operators where the corresponding handlers are known to
2258             // be no-op in CanvasGraphics (display/canvas.js). This prevents
2259             // serialization errors and is also a bit more efficient.
2260             // We could also try to serialize all objects in a general way,
2261             // e.g. as done in https://github.com/mozilla/pdf.js/pull/6266,
2262             // but doing so is meaningless without knowing the semantics.
2263             continue;
2264           case OPS.beginMarkedContentProps:
2265             if (!(args[0] instanceof Name)) {
2266               warn(`Expected name for beginMarkedContentProps arg0=${args[0]}`);
2267               operatorList.addOp(OPS.beginMarkedContentProps, ["OC", null]);
2268               continue;
2269             }
2270             if (args[0].name === "OC") {
2271               next(
2272                 self
2273                   .parseMarkedContentProps(args[1], resources)
2274                   .then(data => {
2275                     operatorList.addOp(OPS.beginMarkedContentProps, [
2276                       "OC",
2277                       data,
2278                     ]);
2279                   })
2280                   .catch(reason => {
2281                     if (reason instanceof AbortException) {
2282                       return;
2283                     }
2284                     if (self.options.ignoreErrors) {
2285                       warn(
2286                         `getOperatorList - ignoring beginMarkedContentProps: "${reason}".`
2287                       );
2288                       operatorList.addOp(OPS.beginMarkedContentProps, [
2289                         "OC",
2290                         null,
2291                       ]);
2292                       return;
2293                     }
2294                     throw reason;
2295                   })
2296               );
2297               return;
2298             }
2299             // Other marked content types aren't supported yet.
2300             args = [
2301               args[0].name,
2302               args[1] instanceof Dict ? args[1].get("MCID") : null,
2303             ];
2304 
2305             break;
2306           case OPS.beginMarkedContent:
2307           case OPS.endMarkedContent:
2308           default:
2309             // Note: Ignore the operator if it has `Dict` arguments, since
2310             // those are non-serializable, otherwise postMessage will throw
2311             // "An object could not be cloned.".
2312             if (args !== null) {
2313               for (i = 0, ii = args.length; i < ii; i++) {
2314                 if (args[i] instanceof Dict) {
2315                   break;
2316                 }
2317               }
2318               if (i < ii) {
2319                 warn("getOperatorList - ignoring operator: " + fn);
2320                 continue;
2321               }
2322             }
2323         }
2324         operatorList.addOp(fn, args);
2325       }
2326       if (stop) {
2327         next(deferred);
2328         return;
2329       }
2330       // Some PDFs don't close all restores inside object/form.
2331       // Closing those for them.
2332       closePendingRestoreOPS();
2333       resolve();
2334     }).catch(reason => {
2335       if (reason instanceof AbortException) {
2336         return;
2337       }
2338       if (this.options.ignoreErrors) {
2339         warn(
2340           `getOperatorList - ignoring errors during "${task.name}" ` +
2341             `task: "${reason}".`
2342         );
2343 
2344         closePendingRestoreOPS();
2345         return;
2346       }
2347       throw reason;
2348     });
2349   }
2350 
2351   getTextContent({
2352     stream,
2353     task,
2354     resources,
2355     stateManager = null,
2356     includeMarkedContent = false,
2357     sink,
2358     seenStyles = new Set(),
2359     viewBox,
2360     lang = null,
2361     markedContentData = null,
2362     disableNormalization = false,
2363     keepWhiteSpace = false,
2364     prevRefs = null,
2365   }) {
2366     const objId = stream.dict?.objId;
2367     const seenRefs = new RefSet(prevRefs);
2368 
2369     if (objId) {
2370       if (prevRefs?.has(objId)) {
2371         throw new Error(
2372           `getTextContent - ignoring circular reference: ${objId}`
2373         );
2374       }
2375       seenRefs.put(objId);
2376     }
2377     // Ensure that `resources`/`stateManager` is correctly initialized,
2378     // even if the provided parameter is e.g. `null`.
2379     resources ||= Dict.empty;
2380     stateManager ||= new StateManager(new TextState());
2381 
2382     if (includeMarkedContent) {
2383       markedContentData ||= { level: 0 };
2384     }
2385 
2386     const textContent = {
2387       items: [],
2388       styles: Object.create(null),
2389       lang,
2390     };
2391     const textContentItem = {
2392       initialized: false,
2393       str: [],
2394       totalWidth: 0,
2395       totalHeight: 0,
2396       width: 0,
2397       height: 0,
2398       vertical: false,
2399       prevTransform: null,
2400       textAdvanceScale: 0,
2401       spaceInFlowMin: 0,
2402       spaceInFlowMax: 0,
2403       trackingSpaceMin: Infinity,
2404       negativeSpaceMax: -Infinity,
2405       notASpace: -Infinity,
2406       transform: null,
2407       fontName: null,
2408       hasEOL: false,
2409     };
2410 
2411     // Use a circular buffer (length === 2) to save the last chars in the
2412     // text stream.
2413     // This implementation of the circular buffer is using a fixed array
2414     // and the position of the next element:
2415     // function addElement(x) {
2416     //   buffer[pos] = x;
2417     //   pos = (pos + 1) % buffer.length;
2418     // }
2419     // It's a way faster than:
2420     // function addElement(x) {
2421     //   buffer.push(x);
2422     //   buffer.shift();
2423     // }
2424     //
2425     // It's useful to know when we need to add a whitespace in the
2426     // text chunk.
2427     const twoLastChars = [" ", " "];
2428     let twoLastCharsPos = 0;
2429 
2430     /**
2431      * Save the last char.
2432      * @param {string} char
2433      * @returns {boolean} true when the two last chars before adding the new one
2434      * are a non-whitespace followed by a whitespace.
2435      */
2436     function saveLastChar(char) {
2437       const nextPos = (twoLastCharsPos + 1) % 2;
2438       const ret =
2439         twoLastChars[twoLastCharsPos] !== " " && twoLastChars[nextPos] === " ";
2440       twoLastChars[twoLastCharsPos] = char;
2441       twoLastCharsPos = nextPos;
2442 
2443       return !keepWhiteSpace && ret;
2444     }
2445 
2446     function shouldAddWhitepsace() {
2447       return (
2448         !keepWhiteSpace &&
2449         twoLastChars[twoLastCharsPos] !== " " &&
2450         twoLastChars[(twoLastCharsPos + 1) % 2] === " "
2451       );
2452     }
2453 
2454     function resetLastChars() {
2455       twoLastChars[0] = twoLastChars[1] = " ";
2456       twoLastCharsPos = 0;
2457     }
2458 
2459     // Used in addFakeSpaces.
2460 
2461     // A white <= fontSize * TRACKING_SPACE_FACTOR is a tracking space
2462     // so it doesn't count as a space.
2463     const TRACKING_SPACE_FACTOR = 0.102;
2464 
2465     // When a white <= fontSize * NOT_A_SPACE_FACTOR, there is no space
2466     // even if one is present in the text stream.
2467     const NOT_A_SPACE_FACTOR = 0.03;
2468 
2469     // A negative white < fontSize * NEGATIVE_SPACE_FACTOR induces
2470     // a break (a new chunk of text is created).
2471     // It doesn't change anything when the text is copied but
2472     // it improves potential mismatch between text layer and canvas.
2473     const NEGATIVE_SPACE_FACTOR = -0.2;
2474 
2475     // A white with a width in [fontSize * MIN_FACTOR; fontSize * MAX_FACTOR]
2476     // is a space which will be inserted in the current flow of words.
2477     // If the width is outside of this range then the flow is broken
2478     // (which means a new span in the text layer).
2479     // It's useful to adjust the best as possible the span in the layer
2480     // to what is displayed in the canvas.
2481     const SPACE_IN_FLOW_MIN_FACTOR = 0.102;
2482     const SPACE_IN_FLOW_MAX_FACTOR = 0.6;
2483 
2484     // If a char is too high/too low compared to the previous we just create
2485     // a new chunk.
2486     // If the advance isn't in the +/-VERTICAL_SHIFT_RATIO * height range then
2487     // a new chunk is created.
2488     const VERTICAL_SHIFT_RATIO = 0.25;
2489 
2490     const self = this;
2491     const xref = this.xref;
2492     const showSpacedTextBuffer = [];
2493 
2494     // The xobj is parsed iff it's needed, e.g. if there is a `DO` cmd.
2495     let xobjs = null;
2496     const emptyXObjectCache = new LocalImageCache();
2497     const emptyGStateCache = new LocalGStateCache();
2498 
2499     const preprocessor = new EvaluatorPreprocessor(stream, xref, stateManager);
2500 
2501     let textState;
2502 
2503     function pushWhitespace({
2504       width = 0,
2505       height = 0,
2506       transform = textContentItem.prevTransform,
2507       fontName = textContentItem.fontName,
2508     }) {
2509       textContent.items.push({
2510         str: " ",
2511         dir: "ltr",
2512         width,
2513         height,
2514         transform,
2515         fontName,
2516         hasEOL: false,
2517       });
2518     }
2519 
2520     function getCurrentTextTransform() {
2521       // 9.4.4 Text Space Details
2522       const font = textState.font;
2523       const tsm = [
2524         textState.fontSize * textState.textHScale,
2525         0,
2526         0,
2527         textState.fontSize,
2528         0,
2529         textState.textRise,
2530       ];
2531 
2532       if (
2533         font.isType3Font &&
2534         (textState.fontSize <= 1 || font.isCharBBox) &&
2535         !isArrayEqual(textState.fontMatrix, FONT_IDENTITY_MATRIX)
2536       ) {
2537         const glyphHeight = font.bbox[3] - font.bbox[1];
2538         if (glyphHeight > 0) {
2539           tsm[3] *= glyphHeight * textState.fontMatrix[3];
2540         }
2541       }
2542 
2543       return Util.transform(
2544         textState.ctm,
2545         Util.transform(textState.textMatrix, tsm)
2546       );
2547     }
2548 
2549     function ensureTextContentItem() {
2550       if (textContentItem.initialized) {
2551         return textContentItem;
2552       }
2553       const { font, loadedName } = textState;
2554       if (!seenStyles.has(loadedName)) {
2555         seenStyles.add(loadedName);
2556         textContent.styles[loadedName] = {
2557           fontFamily: font.fallbackName,
2558           ascent: font.ascent,
2559           descent: font.descent,
2560           vertical: font.vertical,
2561         };
2562         if (self.options.fontExtraProperties && font.systemFontInfo) {
2563           const style = textContent.styles[loadedName];
2564           style.fontSubstitution = font.systemFontInfo.css;
2565           style.fontSubstitutionLoadedName = font.systemFontInfo.loadedName;
2566         }
2567       }
2568       textContentItem.fontName = loadedName;
2569 
2570       const trm = (textContentItem.transform = getCurrentTextTransform());
2571       if (!font.vertical) {
2572         textContentItem.width = textContentItem.totalWidth = 0;
2573         textContentItem.height = textContentItem.totalHeight = Math.hypot(
2574           trm[2],
2575           trm[3]
2576         );
2577         textContentItem.vertical = false;
2578       } else {
2579         textContentItem.width = textContentItem.totalWidth = Math.hypot(
2580           trm[0],
2581           trm[1]
2582         );
2583         textContentItem.height = textContentItem.totalHeight = 0;
2584         textContentItem.vertical = true;
2585       }
2586 
2587       const scaleLineX = Math.hypot(
2588         textState.textLineMatrix[0],
2589         textState.textLineMatrix[1]
2590       );
2591       const scaleCtmX = Math.hypot(textState.ctm[0], textState.ctm[1]);
2592       textContentItem.textAdvanceScale = scaleCtmX * scaleLineX;
2593 
2594       const { fontSize } = textState;
2595       textContentItem.trackingSpaceMin = fontSize * TRACKING_SPACE_FACTOR;
2596       textContentItem.notASpace = fontSize * NOT_A_SPACE_FACTOR;
2597       textContentItem.negativeSpaceMax = fontSize * NEGATIVE_SPACE_FACTOR;
2598       textContentItem.spaceInFlowMin = fontSize * SPACE_IN_FLOW_MIN_FACTOR;
2599       textContentItem.spaceInFlowMax = fontSize * SPACE_IN_FLOW_MAX_FACTOR;
2600       textContentItem.hasEOL = false;
2601 
2602       textContentItem.initialized = true;
2603       return textContentItem;
2604     }
2605 
2606     function updateAdvanceScale() {
2607       if (!textContentItem.initialized) {
2608         return;
2609       }
2610 
2611       const scaleLineX = Math.hypot(
2612         textState.textLineMatrix[0],
2613         textState.textLineMatrix[1]
2614       );
2615       const scaleCtmX = Math.hypot(textState.ctm[0], textState.ctm[1]);
2616       const scaleFactor = scaleCtmX * scaleLineX;
2617       if (scaleFactor === textContentItem.textAdvanceScale) {
2618         return;
2619       }
2620 
2621       if (!textContentItem.vertical) {
2622         textContentItem.totalWidth +=
2623           textContentItem.width * textContentItem.textAdvanceScale;
2624         textContentItem.width = 0;
2625       } else {
2626         textContentItem.totalHeight +=
2627           textContentItem.height * textContentItem.textAdvanceScale;
2628         textContentItem.height = 0;
2629       }
2630 
2631       textContentItem.textAdvanceScale = scaleFactor;
2632     }
2633 
2634     function runBidiTransform(textChunk) {
2635       let text = textChunk.str.join("");
2636       if (!disableNormalization) {
2637         text = normalizeUnicode(text);
2638       }
2639       const bidiResult = bidi(text, -1, textChunk.vertical);
2640       return {
2641         str: bidiResult.str,
2642         dir: bidiResult.dir,
2643         width: Math.abs(textChunk.totalWidth),
2644         height: Math.abs(textChunk.totalHeight),
2645         transform: textChunk.transform,
2646         fontName: textChunk.fontName,
2647         hasEOL: textChunk.hasEOL,
2648       };
2649     }
2650 
2651     async function handleSetFont(fontName, fontRef) {
2652       const translated = await self.loadFont(
2653         fontName,
2654         fontRef,
2655         resources,
2656         task
2657       );
2658 
2659       textState.loadedName = translated.loadedName;
2660       textState.font = translated.font;
2661       textState.fontMatrix = translated.font.fontMatrix || FONT_IDENTITY_MATRIX;
2662     }
2663 
2664     function applyInverseRotation(x, y, matrix) {
2665       const scale = Math.hypot(matrix[0], matrix[1]);
2666       return [
2667         (matrix[0] * x + matrix[1] * y) / scale,
2668         (matrix[2] * x + matrix[3] * y) / scale,
2669       ];
2670     }
2671 
2672     function compareWithLastPosition(glyphWidth) {
2673       const currentTransform = getCurrentTextTransform();
2674       let posX = currentTransform[4];
2675       let posY = currentTransform[5];
2676 
2677       // Check if the glyph is in the viewbox.
2678       if (textState.font?.vertical) {
2679         if (
2680           posX < viewBox[0] ||
2681           posX > viewBox[2] ||
2682           posY + glyphWidth < viewBox[1] ||
2683           posY > viewBox[3]
2684         ) {
2685           return false;
2686         }
2687       } else if (
2688         posX + glyphWidth < viewBox[0] ||
2689         posX > viewBox[2] ||
2690         posY < viewBox[1] ||
2691         posY > viewBox[3]
2692       ) {
2693         return false;
2694       }
2695 
2696       if (!textState.font || !textContentItem.prevTransform) {
2697         return true;
2698       }
2699 
2700       let lastPosX = textContentItem.prevTransform[4];
2701       let lastPosY = textContentItem.prevTransform[5];
2702 
2703       if (lastPosX === posX && lastPosY === posY) {
2704         return true;
2705       }
2706 
2707       let rotate = -1;
2708       // Take into account the rotation is the current transform.
2709       if (
2710         currentTransform[0] &&
2711         currentTransform[1] === 0 &&
2712         currentTransform[2] === 0
2713       ) {
2714         rotate = currentTransform[0] > 0 ? 0 : 180;
2715       } else if (
2716         currentTransform[1] &&
2717         currentTransform[0] === 0 &&
2718         currentTransform[3] === 0
2719       ) {
2720         rotate = currentTransform[1] > 0 ? 90 : 270;
2721       }
2722 
2723       switch (rotate) {
2724         case 0:
2725           break;
2726         case 90:
2727           [posX, posY] = [posY, posX];
2728           [lastPosX, lastPosY] = [lastPosY, lastPosX];
2729           break;
2730         case 180:
2731           [posX, posY, lastPosX, lastPosY] = [
2732             -posX,
2733             -posY,
2734             -lastPosX,
2735             -lastPosY,
2736           ];
2737           break;
2738         case 270:
2739           [posX, posY] = [-posY, -posX];
2740           [lastPosX, lastPosY] = [-lastPosY, -lastPosX];
2741           break;
2742         default:
2743           // This is not a 0, 90, 180, 270 rotation so:
2744           //  - remove the scale factor from the matrix to get a rotation matrix
2745           //  - apply the inverse (which is the transposed) to the positions
2746           // and we can then compare positions of the glyphes to detect
2747           // a whitespace.
2748           [posX, posY] = applyInverseRotation(posX, posY, currentTransform);
2749           [lastPosX, lastPosY] = applyInverseRotation(
2750             lastPosX,
2751             lastPosY,
2752             textContentItem.prevTransform
2753           );
2754       }
2755 
2756       if (textState.font.vertical) {
2757         const advanceY = (lastPosY - posY) / textContentItem.textAdvanceScale;
2758         const advanceX = posX - lastPosX;
2759 
2760         // When the total height of the current chunk is negative
2761         // then we're writing from bottom to top.
2762         const textOrientation = Math.sign(textContentItem.height);
2763         if (advanceY < textOrientation * textContentItem.negativeSpaceMax) {
2764           if (
2765             Math.abs(advanceX) >
2766             0.5 * textContentItem.width /* not the same column */
2767           ) {
2768             appendEOL();
2769             return true;
2770           }
2771 
2772           resetLastChars();
2773           flushTextContentItem();
2774           return true;
2775         }
2776 
2777         if (Math.abs(advanceX) > textContentItem.width) {
2778           appendEOL();
2779           return true;
2780         }
2781 
2782         if (advanceY <= textOrientation * textContentItem.notASpace) {
2783           // The real spacing between 2 consecutive chars is thin enough to be
2784           // considered a non-space.
2785           resetLastChars();
2786         }
2787 
2788         if (advanceY <= textOrientation * textContentItem.trackingSpaceMin) {
2789           if (shouldAddWhitepsace()) {
2790             // The space is very thin, hence it deserves to have its own span in
2791             // order to avoid too much shift between the canvas and the text
2792             // layer.
2793             resetLastChars();
2794             flushTextContentItem();
2795             pushWhitespace({ height: Math.abs(advanceY) });
2796           } else {
2797             textContentItem.height += advanceY;
2798           }
2799         } else if (
2800           !addFakeSpaces(
2801             advanceY,
2802             textContentItem.prevTransform,
2803             textOrientation
2804           )
2805         ) {
2806           if (textContentItem.str.length === 0) {
2807             resetLastChars();
2808             pushWhitespace({ height: Math.abs(advanceY) });
2809           } else {
2810             textContentItem.height += advanceY;
2811           }
2812         }
2813 
2814         if (Math.abs(advanceX) > textContentItem.width * VERTICAL_SHIFT_RATIO) {
2815           flushTextContentItem();
2816         }
2817 
2818         return true;
2819       }
2820 
2821       const advanceX = (posX - lastPosX) / textContentItem.textAdvanceScale;
2822       const advanceY = posY - lastPosY;
2823 
2824       // When the total width of the current chunk is negative
2825       // then we're writing from right to left.
2826       const textOrientation = Math.sign(textContentItem.width);
2827       if (advanceX < textOrientation * textContentItem.negativeSpaceMax) {
2828         if (
2829           Math.abs(advanceY) >
2830           0.5 * textContentItem.height /* not the same line */
2831         ) {
2832           appendEOL();
2833           return true;
2834         }
2835 
2836         // We're moving back so in case the last char was a whitespace
2837         // we cancel it: it doesn't make sense to insert it.
2838         resetLastChars();
2839         flushTextContentItem();
2840         return true;
2841       }
2842 
2843       if (Math.abs(advanceY) > textContentItem.height) {
2844         appendEOL();
2845         return true;
2846       }
2847 
2848       if (advanceX <= textOrientation * textContentItem.notASpace) {
2849         // The real spacing between 2 consecutive chars is thin enough to be
2850         // considered a non-space.
2851         resetLastChars();
2852       }
2853 
2854       if (advanceX <= textOrientation * textContentItem.trackingSpaceMin) {
2855         if (shouldAddWhitepsace()) {
2856           // The space is very thin, hence it deserves to have its own span in
2857           // order to avoid too much shift between the canvas and the text
2858           // layer.
2859           resetLastChars();
2860           flushTextContentItem();
2861           pushWhitespace({ width: Math.abs(advanceX) });
2862         } else {
2863           textContentItem.width += advanceX;
2864         }
2865       } else if (
2866         !addFakeSpaces(advanceX, textContentItem.prevTransform, textOrientation)
2867       ) {
2868         if (textContentItem.str.length === 0) {
2869           resetLastChars();
2870           pushWhitespace({ width: Math.abs(advanceX) });
2871         } else {
2872           textContentItem.width += advanceX;
2873         }
2874       }
2875 
2876       if (Math.abs(advanceY) > textContentItem.height * VERTICAL_SHIFT_RATIO) {
2877         flushTextContentItem();
2878       }
2879 
2880       return true;
2881     }
2882 
2883     function buildTextContentItem({ chars, extraSpacing }) {
2884       const font = textState.font;
2885       if (!chars) {
2886         // Just move according to the space we have.
2887         const charSpacing = textState.charSpacing + extraSpacing;
2888         if (charSpacing) {
2889           if (!font.vertical) {
2890             textState.translateTextMatrix(
2891               charSpacing * textState.textHScale,
2892               0
2893             );
2894           } else {
2895             textState.translateTextMatrix(0, -charSpacing);
2896           }
2897         }
2898 
2899         if (keepWhiteSpace) {
2900           compareWithLastPosition(0);
2901         }
2902 
2903         return;
2904       }
2905 
2906       const glyphs = font.charsToGlyphs(chars);
2907       const scale = textState.fontMatrix[0] * textState.fontSize;
2908 
2909       for (let i = 0, ii = glyphs.length; i < ii; i++) {
2910         const glyph = glyphs[i];
2911         const { category } = glyph;
2912 
2913         if (category.isInvisibleFormatMark) {
2914           continue;
2915         }
2916         let charSpacing =
2917           textState.charSpacing + (i + 1 === ii ? extraSpacing : 0);
2918 
2919         let glyphWidth = glyph.width;
2920         if (font.vertical) {
2921           glyphWidth = glyph.vmetric ? glyph.vmetric[0] : -glyphWidth;
2922         }
2923         let scaledDim = glyphWidth * scale;
2924 
2925         if (!keepWhiteSpace && category.isWhitespace) {
2926           // Don't push a " " in the textContentItem
2927           // (except when it's between two non-spaces chars),
2928           // it will be done (if required) in next call to
2929           // compareWithLastPosition.
2930           // This way we can merge real spaces and spaces due to cursor moves.
2931           if (!font.vertical) {
2932             charSpacing += scaledDim + textState.wordSpacing;
2933             textState.translateTextMatrix(
2934               charSpacing * textState.textHScale,
2935               0
2936             );
2937           } else {
2938             charSpacing += -scaledDim + textState.wordSpacing;
2939             textState.translateTextMatrix(0, -charSpacing);
2940           }
2941           saveLastChar(" ");
2942           continue;
2943         }
2944 
2945         if (
2946           !category.isZeroWidthDiacritic &&
2947           !compareWithLastPosition(scaledDim)
2948         ) {
2949           // The glyph is not in page so just skip it but move the cursor.
2950           if (!font.vertical) {
2951             textState.translateTextMatrix(scaledDim * textState.textHScale, 0);
2952           } else {
2953             textState.translateTextMatrix(0, scaledDim);
2954           }
2955           continue;
2956         }
2957 
2958         // Must be called after compareWithLastPosition because
2959         // the textContentItem could have been flushed.
2960         const textChunk = ensureTextContentItem();
2961         if (category.isZeroWidthDiacritic) {
2962           scaledDim = 0;
2963         }
2964 
2965         if (!font.vertical) {
2966           scaledDim *= textState.textHScale;
2967           textState.translateTextMatrix(scaledDim, 0);
2968           textChunk.width += scaledDim;
2969         } else {
2970           textState.translateTextMatrix(0, scaledDim);
2971           scaledDim = Math.abs(scaledDim);
2972           textChunk.height += scaledDim;
2973         }
2974 
2975         if (scaledDim) {
2976           // Save the position of the last visible character.
2977           textChunk.prevTransform = getCurrentTextTransform();
2978         }
2979 
2980         const glyphUnicode = glyph.unicode;
2981         if (saveLastChar(glyphUnicode)) {
2982           // The two last chars are a non-whitespace followed by a whitespace
2983           // and then this non-whitespace, so we insert a whitespace here.
2984           // Replaces all whitespaces with standard spaces (0x20), to avoid
2985           // alignment issues between the textLayer and the canvas if the text
2986           // contains e.g. tabs (fixes issue6612.pdf).
2987           textChunk.str.push(" ");
2988         }
2989         textChunk.str.push(glyphUnicode);
2990 
2991         if (charSpacing) {
2992           if (!font.vertical) {
2993             textState.translateTextMatrix(
2994               charSpacing * textState.textHScale,
2995               0
2996             );
2997           } else {
2998             textState.translateTextMatrix(0, -charSpacing);
2999           }
3000         }
3001       }
3002     }
3003 
3004     function appendEOL() {
3005       resetLastChars();
3006       if (textContentItem.initialized) {
3007         textContentItem.hasEOL = true;
3008         flushTextContentItem();
3009       } else {
3010         textContent.items.push({
3011           str: "",
3012           dir: "ltr",
3013           width: 0,
3014           height: 0,
3015           transform: getCurrentTextTransform(),
3016           fontName: textState.loadedName,
3017           hasEOL: true,
3018         });
3019       }
3020     }
3021 
3022     function addFakeSpaces(width, transf, textOrientation) {
3023       if (
3024         textOrientation * textContentItem.spaceInFlowMin <= width &&
3025         width <= textOrientation * textContentItem.spaceInFlowMax
3026       ) {
3027         if (textContentItem.initialized) {
3028           resetLastChars();
3029           textContentItem.str.push(" ");
3030         }
3031         return false;
3032       }
3033 
3034       const fontName = textContentItem.fontName;
3035 
3036       let height = 0;
3037       if (textContentItem.vertical) {
3038         height = width;
3039         width = 0;
3040       }
3041 
3042       flushTextContentItem();
3043       resetLastChars();
3044       pushWhitespace({
3045         width: Math.abs(width),
3046         height: Math.abs(height),
3047         transform: transf || getCurrentTextTransform(),
3048         fontName,
3049       });
3050 
3051       return true;
3052     }
3053 
3054     function flushTextContentItem() {
3055       if (!textContentItem.initialized || !textContentItem.str) {
3056         return;
3057       }
3058 
3059       // Do final text scaling.
3060       if (!textContentItem.vertical) {
3061         textContentItem.totalWidth +=
3062           textContentItem.width * textContentItem.textAdvanceScale;
3063       } else {
3064         textContentItem.totalHeight +=
3065           textContentItem.height * textContentItem.textAdvanceScale;
3066       }
3067 
3068       textContent.items.push(runBidiTransform(textContentItem));
3069       textContentItem.initialized = false;
3070       textContentItem.str.length = 0;
3071     }
3072 
3073     function enqueueChunk(batch = false) {
3074       const length = textContent.items.length;
3075       if (length === 0) {
3076         return;
3077       }
3078       if (batch && length < TEXT_CHUNK_BATCH_SIZE) {
3079         return;
3080       }
3081       sink.enqueue(textContent, length);
3082       textContent.items = [];
3083       textContent.styles = Object.create(null);
3084     }
3085 
3086     const timeSlotManager = new TimeSlotManager();
3087 
3088     return new Promise(function promiseBody(resolve, reject) {
3089       const next = function (promise) {
3090         enqueueChunk(/* batch = */ true);
3091         Promise.all([promise, sink.ready]).then(function () {
3092           try {
3093             promiseBody(resolve, reject);
3094           } catch (ex) {
3095             reject(ex);
3096           }
3097         }, reject);
3098       };
3099       task.ensureNotTerminated();
3100       timeSlotManager.reset();
3101 
3102       const operation = {};
3103       let stop,
3104         name,
3105         isValidName,
3106         args = [];
3107       while (!(stop = timeSlotManager.check())) {
3108         // The arguments parsed by read() are not used beyond this loop, so
3109         // we can reuse the same array on every iteration, thus avoiding
3110         // unnecessary allocations.
3111         args.length = 0;
3112         operation.args = args;
3113         if (!preprocessor.read(operation)) {
3114           break;
3115         }
3116 
3117         const previousState = textState;
3118         textState = stateManager.state;
3119         const fn = operation.fn;
3120         args = operation.args;
3121 
3122         switch (fn | 0) {
3123           case OPS.setFont:
3124             // Optimization to ignore multiple identical Tf commands.
3125             const fontNameArg = args[0].name,
3126               fontSizeArg = args[1];
3127             if (
3128               textState.font &&
3129               fontNameArg === textState.fontName &&
3130               fontSizeArg === textState.fontSize
3131             ) {
3132               break;
3133             }
3134 
3135             flushTextContentItem();
3136             textState.fontName = fontNameArg;
3137             textState.fontSize = fontSizeArg;
3138             next(handleSetFont(fontNameArg, null));
3139             return;
3140           case OPS.setTextRise:
3141             textState.textRise = args[0];
3142             break;
3143           case OPS.setHScale:
3144             textState.textHScale = args[0] / 100;
3145             break;
3146           case OPS.setLeading:
3147             textState.leading = args[0];
3148             break;
3149           case OPS.moveText:
3150             textState.translateTextLineMatrix(args[0], args[1]);
3151             textState.textMatrix = textState.textLineMatrix.slice();
3152             break;
3153           case OPS.setLeadingMoveText:
3154             textState.leading = -args[1];
3155             textState.translateTextLineMatrix(args[0], args[1]);
3156             textState.textMatrix = textState.textLineMatrix.slice();
3157             break;
3158           case OPS.nextLine:
3159             textState.carriageReturn();
3160             break;
3161           case OPS.setTextMatrix:
3162             textState.setTextMatrix(
3163               args[0],
3164               args[1],
3165               args[2],
3166               args[3],
3167               args[4],
3168               args[5]
3169             );
3170             textState.setTextLineMatrix(
3171               args[0],
3172               args[1],
3173               args[2],
3174               args[3],
3175               args[4],
3176               args[5]
3177             );
3178             updateAdvanceScale();
3179             break;
3180           case OPS.setCharSpacing:
3181             textState.charSpacing = args[0];
3182             break;
3183           case OPS.setWordSpacing:
3184             textState.wordSpacing = args[0];
3185             break;
3186           case OPS.beginText:
3187             textState.textMatrix = IDENTITY_MATRIX.slice();
3188             textState.textLineMatrix = IDENTITY_MATRIX.slice();
3189             break;
3190           case OPS.showSpacedText:
3191             if (!stateManager.state.font) {
3192               self.ensureStateFont(stateManager.state);
3193               continue;
3194             }
3195 
3196             const spaceFactor =
3197               ((textState.font.vertical ? 1 : -1) * textState.fontSize) / 1000;
3198             const elements = args[0];
3199             for (let i = 0, ii = elements.length; i < ii; i++) {
3200               const item = elements[i];
3201               if (typeof item === "string") {
3202                 showSpacedTextBuffer.push(item);
3203               } else if (typeof item === "number" && item !== 0) {
3204                 // PDF Specification 5.3.2 states:
3205                 // The number is expressed in thousandths of a unit of text
3206                 // space.
3207                 // This amount is subtracted from the current horizontal or
3208                 // vertical coordinate, depending on the writing mode.
3209                 // In the default coordinate system, a positive adjustment
3210                 // has the effect of moving the next glyph painted either to
3211                 // the left or down by the given amount.
3212                 const str = showSpacedTextBuffer.join("");
3213                 showSpacedTextBuffer.length = 0;
3214                 buildTextContentItem({
3215                   chars: str,
3216                   extraSpacing: item * spaceFactor,
3217                 });
3218               }
3219             }
3220 
3221             if (showSpacedTextBuffer.length > 0) {
3222               const str = showSpacedTextBuffer.join("");
3223               showSpacedTextBuffer.length = 0;
3224               buildTextContentItem({
3225                 chars: str,
3226                 extraSpacing: 0,
3227               });
3228             }
3229             break;
3230           case OPS.showText:
3231             if (!stateManager.state.font) {
3232               self.ensureStateFont(stateManager.state);
3233               continue;
3234             }
3235             buildTextContentItem({
3236               chars: args[0],
3237               extraSpacing: 0,
3238             });
3239             break;
3240           case OPS.nextLineShowText:
3241             if (!stateManager.state.font) {
3242               self.ensureStateFont(stateManager.state);
3243               continue;
3244             }
3245             textState.carriageReturn();
3246             buildTextContentItem({
3247               chars: args[0],
3248               extraSpacing: 0,
3249             });
3250             break;
3251           case OPS.nextLineSetSpacingShowText:
3252             if (!stateManager.state.font) {
3253               self.ensureStateFont(stateManager.state);
3254               continue;
3255             }
3256             textState.wordSpacing = args[0];
3257             textState.charSpacing = args[1];
3258             textState.carriageReturn();
3259             buildTextContentItem({
3260               chars: args[2],
3261               extraSpacing: 0,
3262             });
3263             break;
3264           case OPS.paintXObject:
3265             flushTextContentItem();
3266             xobjs ??= resources.get("XObject") || Dict.empty;
3267 
3268             isValidName = args[0] instanceof Name;
3269             name = args[0].name;
3270 
3271             if (isValidName && emptyXObjectCache.getByName(name)) {
3272               break;
3273             }
3274 
3275             next(
3276               new Promise(function (resolveXObject, rejectXObject) {
3277                 if (!isValidName) {
3278                   throw new FormatError("XObject must be referred to by name.");
3279                 }
3280 
3281                 let xobj = xobjs.getRaw(name);
3282                 if (xobj instanceof Ref) {
3283                   if (emptyXObjectCache.getByRef(xobj)) {
3284                     resolveXObject();
3285                     return;
3286                   }
3287 
3288                   const globalImage = self.globalImageCache.getData(
3289                     xobj,
3290                     self.pageIndex
3291                   );
3292                   if (globalImage) {
3293                     resolveXObject();
3294                     return;
3295                   }
3296 
3297                   xobj = xref.fetch(xobj);
3298                 }
3299 
3300                 if (!(xobj instanceof BaseStream)) {
3301                   throw new FormatError("XObject should be a stream");
3302                 }
3303                 const { dict } = xobj;
3304 
3305                 const type = dict.get("Subtype");
3306                 if (!(type instanceof Name)) {
3307                   throw new FormatError("XObject should have a Name subtype");
3308                 }
3309 
3310                 if (type.name !== "Form") {
3311                   emptyXObjectCache.set(name, dict.objId, true);
3312 
3313                   resolveXObject();
3314                   return;
3315                 }
3316 
3317                 // Use a new `StateManager` to prevent incorrect positioning
3318                 // of textItems *after* the Form XObject, since errors in the
3319                 // data can otherwise prevent `restore` operators from
3320                 // executing.
3321                 // NOTE: Only an issue when `options.ignoreErrors === true`.
3322                 const currentState = stateManager.state.clone();
3323                 const xObjStateManager = new StateManager(currentState);
3324 
3325                 const matrix = lookupMatrix(dict.getArray("Matrix"), null);
3326                 if (matrix) {
3327                   xObjStateManager.transform(matrix);
3328                 }
3329 
3330                 const localResources = dict.get("Resources");
3331 
3332                 // Enqueue the `textContent` chunk before parsing the /Form
3333                 // XObject.
3334                 enqueueChunk();
3335                 const sinkWrapper = {
3336                   enqueueInvoked: false,
3337 
3338                   enqueue(chunk, size) {
3339                     this.enqueueInvoked = true;
3340                     sink.enqueue(chunk, size);
3341                   },
3342 
3343                   get desiredSize() {
3344                     return sink.desiredSize;
3345                   },
3346 
3347                   get ready() {
3348                     return sink.ready;
3349                   },
3350                 };
3351 
3352                 self
3353                   .getTextContent({
3354                     stream: xobj,
3355                     task,
3356                     resources:
3357                       localResources instanceof Dict
3358                         ? localResources
3359                         : resources,
3360                     stateManager: xObjStateManager,
3361                     includeMarkedContent,
3362                     sink: sinkWrapper,
3363                     seenStyles,
3364                     viewBox,
3365                     lang,
3366                     markedContentData,
3367                     disableNormalization,
3368                     keepWhiteSpace,
3369                     prevRefs: seenRefs,
3370                   })
3371                   .then(function () {
3372                     if (!sinkWrapper.enqueueInvoked) {
3373                       emptyXObjectCache.set(name, dict.objId, true);
3374                     }
3375                     resolveXObject();
3376                   }, rejectXObject);
3377               }).catch(function (reason) {
3378                 if (reason instanceof AbortException) {
3379                   return;
3380                 }
3381                 if (self.options.ignoreErrors) {
3382                   // Error(s) in the XObject -- allow text-extraction to
3383                   // continue.
3384                   warn(`getTextContent - ignoring XObject: "${reason}".`);
3385                   return;
3386                 }
3387                 throw reason;
3388               })
3389             );
3390             return;
3391           case OPS.setGState:
3392             isValidName = args[0] instanceof Name;
3393             name = args[0].name;
3394 
3395             if (isValidName && emptyGStateCache.getByName(name)) {
3396               break;
3397             }
3398 
3399             next(
3400               new Promise(function (resolveGState, rejectGState) {
3401                 if (!isValidName) {
3402                   throw new FormatError("GState must be referred to by name.");
3403                 }
3404 
3405                 const extGState = resources.get("ExtGState");
3406                 if (!(extGState instanceof Dict)) {
3407                   throw new FormatError("ExtGState should be a dictionary.");
3408                 }
3409 
3410                 const gState = extGState.get(name);
3411                 // TODO: Attempt to lookup cached GStates by reference as well,
3412                 //       if and only if there are PDF documents where doing so
3413                 //       would significantly improve performance.
3414                 if (!(gState instanceof Dict)) {
3415                   throw new FormatError("GState should be a dictionary.");
3416                 }
3417 
3418                 const gStateFont = gState.get("Font");
3419                 if (!gStateFont) {
3420                   emptyGStateCache.set(name, gState.objId, true);
3421 
3422                   resolveGState();
3423                   return;
3424                 }
3425                 flushTextContentItem();
3426 
3427                 textState.fontName = null;
3428                 textState.fontSize = gStateFont[1];
3429                 handleSetFont(null, gStateFont[0]).then(
3430                   resolveGState,
3431                   rejectGState
3432                 );
3433               }).catch(function (reason) {
3434                 if (reason instanceof AbortException) {
3435                   return;
3436                 }
3437                 if (self.options.ignoreErrors) {
3438                   // Error(s) in the ExtGState -- allow text-extraction to
3439                   // continue.
3440                   warn(`getTextContent - ignoring ExtGState: "${reason}".`);
3441                   return;
3442                 }
3443                 throw reason;
3444               })
3445             );
3446             return;
3447           case OPS.beginMarkedContent:
3448             flushTextContentItem();
3449             if (includeMarkedContent) {
3450               markedContentData.level++;
3451 
3452               textContent.items.push({
3453                 type: "beginMarkedContent",
3454                 tag: args[0] instanceof Name ? args[0].name : null,
3455               });
3456             }
3457             break;
3458           case OPS.beginMarkedContentProps:
3459             flushTextContentItem();
3460             if (includeMarkedContent) {
3461               markedContentData.level++;
3462 
3463               let mcid = null;
3464               if (args[1] instanceof Dict) {
3465                 mcid = args[1].get("MCID");
3466               }
3467               textContent.items.push({
3468                 type: "beginMarkedContentProps",
3469                 id: Number.isInteger(mcid)
3470                   ? `${self.idFactory.getPageObjId()}_mc${mcid}`
3471                   : null,
3472                 tag: args[0] instanceof Name ? args[0].name : null,
3473               });
3474             }
3475             break;
3476           case OPS.endMarkedContent:
3477             flushTextContentItem();
3478             if (includeMarkedContent) {
3479               if (markedContentData.level === 0) {
3480                 // Handle unbalanced beginMarkedContent/endMarkedContent
3481                 // operators (fixes issue15629.pdf).
3482                 break;
3483               }
3484               markedContentData.level--;
3485 
3486               textContent.items.push({
3487                 type: "endMarkedContent",
3488               });
3489             }
3490             break;
3491           case OPS.restore:
3492             if (
3493               previousState &&
3494               (previousState.font !== textState.font ||
3495                 previousState.fontSize !== textState.fontSize ||
3496                 previousState.fontName !== textState.fontName)
3497             ) {
3498               flushTextContentItem();
3499             }
3500             break;
3501         } // switch
3502         if (textContent.items.length >= sink.desiredSize) {
3503           // Wait for ready, if we reach highWaterMark.
3504           stop = true;
3505           break;
3506         }
3507       } // while
3508       if (stop) {
3509         next(deferred);
3510         return;
3511       }
3512       flushTextContentItem();
3513       enqueueChunk();
3514       resolve();
3515     }).catch(reason => {
3516       if (reason instanceof AbortException) {
3517         return;
3518       }
3519       if (this.options.ignoreErrors) {
3520         // Error(s) in the TextContent -- allow text-extraction to continue.
3521         warn(
3522           `getTextContent - ignoring errors during "${task.name}" ` +
3523             `task: "${reason}".`
3524         );
3525 
3526         flushTextContentItem();
3527         enqueueChunk();
3528         return;
3529       }
3530       throw reason;
3531     });
3532   }
3533 
3534   async extractDataStructures(dict, properties) {
3535     const xref = this.xref;
3536     let cidToGidBytes;
3537     // 9.10.2
3538     const toUnicodePromise = this.readToUnicode(properties.toUnicode);
3539 
3540     if (properties.composite) {
3541       // CIDSystemInfo helps to match CID to glyphs
3542       const cidSystemInfo = dict.get("CIDSystemInfo");
3543       if (cidSystemInfo instanceof Dict) {
3544         properties.cidSystemInfo = {
3545           registry: stringToPDFString(cidSystemInfo.get("Registry")),
3546           ordering: stringToPDFString(cidSystemInfo.get("Ordering")),
3547           supplement: cidSystemInfo.get("Supplement"),
3548         };
3549       }
3550 
3551       try {
3552         const cidToGidMap = dict.get("CIDToGIDMap");
3553         if (cidToGidMap instanceof BaseStream) {
3554           cidToGidBytes = cidToGidMap.getBytes();
3555         }
3556       } catch (ex) {
3557         if (!this.options.ignoreErrors) {
3558           throw ex;
3559         }
3560         warn(`extractDataStructures - ignoring CIDToGIDMap data: "${ex}".`);
3561       }
3562     }
3563 
3564     // Based on 9.6.6 of the spec the encoding can come from multiple places
3565     // and depends on the font type. The base encoding and differences are
3566     // read here, but the encoding that is actually used is chosen during
3567     // glyph mapping in the font.
3568     // TODO: Loading the built in encoding in the font would allow the
3569     // differences to be merged in here not require us to hold on to it.
3570     const differences = [];
3571     let baseEncodingName = null;
3572     let encoding;
3573     if (dict.has("Encoding")) {
3574       encoding = dict.get("Encoding");
3575       if (encoding instanceof Dict) {
3576         baseEncodingName = encoding.get("BaseEncoding");
3577         baseEncodingName =
3578           baseEncodingName instanceof Name ? baseEncodingName.name : null;
3579         // Load the differences between the base and original
3580         if (encoding.has("Differences")) {
3581           const diffEncoding = encoding.get("Differences");
3582           let index = 0;
3583           for (const entry of diffEncoding) {
3584             const data = xref.fetchIfRef(entry);
3585             if (typeof data === "number") {
3586               index = data;
3587             } else if (data instanceof Name) {
3588               differences[index++] = data.name;
3589             } else {
3590               throw new FormatError(
3591                 `Invalid entry in 'Differences' array: ${data}`
3592               );
3593             }
3594           }
3595         }
3596       } else if (encoding instanceof Name) {
3597         baseEncodingName = encoding.name;
3598       } else {
3599         const msg = "Encoding is not a Name nor a Dict";
3600 
3601         if (!this.options.ignoreErrors) {
3602           throw new FormatError(msg);
3603         }
3604         warn(msg);
3605       }
3606       // According to table 114 if the encoding is a named encoding it must be
3607       // one of these predefined encodings.
3608       if (
3609         baseEncodingName !== "MacRomanEncoding" &&
3610         baseEncodingName !== "MacExpertEncoding" &&
3611         baseEncodingName !== "WinAnsiEncoding"
3612       ) {
3613         baseEncodingName = null;
3614       }
3615     }
3616 
3617     const nonEmbeddedFont = !properties.file || properties.isInternalFont,
3618       isSymbolsFontName = getSymbolsFonts()[properties.name];
3619     // Ignore an incorrectly specified named encoding for non-embedded
3620     // symbol fonts (fixes issue16464.pdf).
3621     if (baseEncodingName && nonEmbeddedFont && isSymbolsFontName) {
3622       baseEncodingName = null;
3623     }
3624 
3625     if (baseEncodingName) {
3626       properties.defaultEncoding = getEncoding(baseEncodingName);
3627     } else {
3628       const isSymbolicFont = !!(properties.flags & FontFlags.Symbolic);
3629       const isNonsymbolicFont = !!(properties.flags & FontFlags.Nonsymbolic);
3630       // According to "Table 114" in section "9.6.6.1 General" (under
3631       // "9.6.6 Character Encoding") of the PDF specification, a Nonsymbolic
3632       // font should use the `StandardEncoding` if no encoding is specified.
3633       encoding = StandardEncoding;
3634       if (properties.type === "TrueType" && !isNonsymbolicFont) {
3635         encoding = WinAnsiEncoding;
3636       }
3637       // The Symbolic attribute can be misused for regular fonts
3638       // Heuristic: we have to check if the font is a standard one also
3639       if (isSymbolicFont || isSymbolsFontName) {
3640         encoding = MacRomanEncoding;
3641         if (nonEmbeddedFont) {
3642           if (/Symbol/i.test(properties.name)) {
3643             encoding = SymbolSetEncoding;
3644           } else if (/Dingbats/i.test(properties.name)) {
3645             encoding = ZapfDingbatsEncoding;
3646           } else if (/Wingdings/i.test(properties.name)) {
3647             encoding = WinAnsiEncoding;
3648           }
3649         }
3650       }
3651       properties.defaultEncoding = encoding;
3652     }
3653 
3654     properties.differences = differences;
3655     properties.baseEncodingName = baseEncodingName;
3656     properties.hasEncoding = !!baseEncodingName || differences.length > 0;
3657     properties.dict = dict;
3658 
3659     properties.toUnicode = await toUnicodePromise;
3660 
3661     const builtToUnicode = await this.buildToUnicode(properties);
3662     properties.toUnicode = builtToUnicode;
3663 
3664     if (cidToGidBytes) {
3665       properties.cidToGidMap = this.readCidToGidMap(
3666         cidToGidBytes,
3667         builtToUnicode
3668       );
3669     }
3670     return properties;
3671   }
3672 
3673   /**
3674    * @returns {Array}
3675    * @private
3676    */
3677   _simpleFontToUnicode(properties, forceGlyphs = false) {
3678     assert(!properties.composite, "Must be a simple font.");
3679 
3680     const toUnicode = [];
3681     const encoding = properties.defaultEncoding.slice();
3682     const baseEncodingName = properties.baseEncodingName;
3683     // Merge in the differences array.
3684     const differences = properties.differences;
3685     for (const charcode in differences) {
3686       const glyphName = differences[charcode];
3687       if (glyphName === ".notdef") {
3688         // Skip .notdef to prevent rendering errors, e.g. boxes appearing
3689         // where there should be spaces (fixes issue5256.pdf).
3690         continue;
3691       }
3692       encoding[charcode] = glyphName;
3693     }
3694     const glyphsUnicodeMap = getGlyphsUnicode();
3695     for (const charcode in encoding) {
3696       // a) Map the character code to a character name.
3697       let glyphName = encoding[charcode];
3698       if (glyphName === "") {
3699         continue;
3700       }
3701       // b) Look up the character name in the Adobe Glyph List (see the
3702       //    Bibliography) to obtain the corresponding Unicode value.
3703       let unicode = glyphsUnicodeMap[glyphName];
3704       if (unicode !== undefined) {
3705         toUnicode[charcode] = String.fromCharCode(unicode);
3706         continue;
3707       }
3708       // (undocumented) c) Few heuristics to recognize unknown glyphs
3709       // NOTE: Adobe Reader does not do this step, but OSX Preview does
3710       let code = 0;
3711       switch (glyphName[0]) {
3712         case "G": // Gxx glyph
3713           if (glyphName.length === 3) {
3714             code = parseInt(glyphName.substring(1), 16);
3715           }
3716           break;
3717         case "g": // g00xx glyph
3718           if (glyphName.length === 5) {
3719             code = parseInt(glyphName.substring(1), 16);
3720           }
3721           break;
3722         case "C": // Cdd{d} glyph
3723         case "c": // cdd{d} glyph
3724           if (glyphName.length >= 3 && glyphName.length <= 4) {
3725             const codeStr = glyphName.substring(1);
3726 
3727             if (forceGlyphs) {
3728               code = parseInt(codeStr, 16);
3729               break;
3730             }
3731             // Normally the Cdd{d}/cdd{d} glyphName format will contain
3732             // regular, i.e. base 10, charCodes (see issue4550.pdf)...
3733             code = +codeStr;
3734 
3735             // ... however some PDF generators violate that assumption by
3736             // containing glyph, i.e. base 16, codes instead.
3737             // In that case we need to re-parse the *entire* encoding to
3738             // prevent broken text-selection (fixes issue9655_reduced.pdf).
3739             if (Number.isNaN(code) && Number.isInteger(parseInt(codeStr, 16))) {
3740               return this._simpleFontToUnicode(
3741                 properties,
3742                 /* forceGlyphs */ true
3743               );
3744             }
3745           }
3746           break;
3747         case "u": // 'uniXXXX'/'uXXXX{XX}' glyphs
3748           unicode = getUnicodeForGlyph(glyphName, glyphsUnicodeMap);
3749           if (unicode !== -1) {
3750             code = unicode;
3751           }
3752           break;
3753         default:
3754           // Support (some) non-standard ligatures.
3755           switch (glyphName) {
3756             case "f_h":
3757             case "f_t":
3758             case "T_h":
3759               toUnicode[charcode] = glyphName.replaceAll("_", "");
3760               continue;
3761           }
3762           break;
3763       }
3764       if (code > 0 && code <= 0x10ffff && Number.isInteger(code)) {
3765         // If `baseEncodingName` is one the predefined encodings, and `code`
3766         // equals `charcode`, using the glyph defined in the baseEncoding
3767         // seems to yield a better `toUnicode` mapping (fixes issue 5070).
3768         if (baseEncodingName && code === +charcode) {
3769           const baseEncoding = getEncoding(baseEncodingName);
3770           if (baseEncoding && (glyphName = baseEncoding[charcode])) {
3771             toUnicode[charcode] = String.fromCharCode(
3772               glyphsUnicodeMap[glyphName]
3773             );
3774             continue;
3775           }
3776         }
3777         toUnicode[charcode] = String.fromCodePoint(code);
3778       }
3779     }
3780     return toUnicode;
3781   }
3782 
3783   /**
3784    * Builds a char code to unicode map based on section 9.10 of the spec.
3785    * @param {Object} properties Font properties object.
3786    * @returns {Promise} A Promise that is resolved with a
3787    *   {ToUnicodeMap|IdentityToUnicodeMap} object.
3788    */
3789   async buildToUnicode(properties) {
3790     properties.hasIncludedToUnicodeMap = properties.toUnicode?.length > 0;
3791 
3792     // Section 9.10.2 Mapping Character Codes to Unicode Values
3793     if (properties.hasIncludedToUnicodeMap) {
3794       // Some fonts contain incomplete ToUnicode data, causing issues with
3795       // text-extraction. For simple fonts, containing encoding information,
3796       // use a fallback ToUnicode map to improve this (fixes issue8229.pdf).
3797       if (!properties.composite && properties.hasEncoding) {
3798         properties.fallbackToUnicode = this._simpleFontToUnicode(properties);
3799       }
3800       return properties.toUnicode;
3801     }
3802 
3803     // According to the spec if the font is a simple font we should only map
3804     // to unicode if the base encoding is MacRoman, MacExpert, or WinAnsi or
3805     // the differences array only contains adobe standard or symbol set names,
3806     // in pratice it seems better to always try to create a toUnicode map
3807     // based of the default encoding.
3808     if (!properties.composite /* is simple font */) {
3809       return new ToUnicodeMap(this._simpleFontToUnicode(properties));
3810     }
3811 
3812     // If the font is a composite font that uses one of the predefined CMaps
3813     // listed in Table 118 (except Identity–H and Identity–V) or whose
3814     // descendant CIDFont uses the Adobe-GB1, Adobe-CNS1, Adobe-Japan1, or
3815     // Adobe-Korea1 character collection:
3816     if (
3817       properties.composite &&
3818       ((properties.cMap.builtInCMap &&
3819         !(properties.cMap instanceof IdentityCMap)) ||
3820         // The font is supposed to have a CIDSystemInfo dictionary, but some
3821         // PDFs don't include it (fixes issue 17689), hence the `?'.
3822         (properties.cidSystemInfo?.registry === "Adobe" &&
3823           (properties.cidSystemInfo.ordering === "GB1" ||
3824             properties.cidSystemInfo.ordering === "CNS1" ||
3825             properties.cidSystemInfo.ordering === "Japan1" ||
3826             properties.cidSystemInfo.ordering === "Korea1")))
3827     ) {
3828       // Then:
3829       // a) Map the character code to a character identifier (CID) according
3830       // to the font’s CMap.
3831       // b) Obtain the registry and ordering of the character collection used
3832       // by the font’s CMap (for example, Adobe and Japan1) from its
3833       // CIDSystemInfo dictionary.
3834       const { registry, ordering } = properties.cidSystemInfo;
3835       // c) Construct a second CMap name by concatenating the registry and
3836       // ordering obtained in step (b) in the format registry–ordering–UCS2
3837       // (for example, Adobe–Japan1–UCS2).
3838       const ucs2CMapName = Name.get(`${registry}-${ordering}-UCS2`);
3839       // d) Obtain the CMap with the name constructed in step (c) (available
3840       // from the ASN Web site; see the Bibliography).
3841       const ucs2CMap = await CMapFactory.create({
3842         encoding: ucs2CMapName,
3843         fetchBuiltInCMap: this._fetchBuiltInCMapBound,
3844         useCMap: null,
3845       });
3846       const toUnicode = [],
3847         buf = [];
3848       properties.cMap.forEach(function (charcode, cid) {
3849         if (cid > 0xffff) {
3850           throw new FormatError("Max size of CID is 65,535");
3851         }
3852         // e) Map the CID obtained in step (a) according to the CMap
3853         // obtained in step (d), producing a Unicode value.
3854         const ucs2 = ucs2CMap.lookup(cid);
3855         if (ucs2) {
3856           buf.length = 0;
3857           // Support multi-byte entries (fixes issue16176.pdf).
3858           for (let i = 0, ii = ucs2.length; i < ii; i += 2) {
3859             buf.push((ucs2.charCodeAt(i) << 8) + ucs2.charCodeAt(i + 1));
3860           }
3861           toUnicode[charcode] = String.fromCharCode(...buf);
3862         }
3863       });
3864       return new ToUnicodeMap(toUnicode);
3865     }
3866 
3867     // The viewer's choice, just use an identity map.
3868     return new IdentityToUnicodeMap(properties.firstChar, properties.lastChar);
3869   }
3870 
3871   async readToUnicode(cmapObj) {
3872     if (!cmapObj) {
3873       return null;
3874     }
3875     if (cmapObj instanceof Name) {
3876       const cmap = await CMapFactory.create({
3877         encoding: cmapObj,
3878         fetchBuiltInCMap: this._fetchBuiltInCMapBound,
3879         useCMap: null,
3880       });
3881 
3882       if (cmap instanceof IdentityCMap) {
3883         return new IdentityToUnicodeMap(0, 0xffff);
3884       }
3885       return new ToUnicodeMap(cmap.getMap());
3886     }
3887     if (cmapObj instanceof BaseStream) {
3888       try {
3889         const cmap = await CMapFactory.create({
3890           encoding: cmapObj,
3891           fetchBuiltInCMap: this._fetchBuiltInCMapBound,
3892           useCMap: null,
3893         });
3894 
3895         if (cmap instanceof IdentityCMap) {
3896           return new IdentityToUnicodeMap(0, 0xffff);
3897         }
3898         const map = new Array(cmap.length);
3899         // Convert UTF-16BE
3900         // NOTE: cmap can be a sparse array, so use forEach instead of
3901         // `for(;;)` to iterate over all keys.
3902         cmap.forEach(function (charCode, token) {
3903           // Some cmaps contain *only* CID characters (fixes issue9367.pdf).
3904           if (typeof token === "number") {
3905             map[charCode] = String.fromCodePoint(token);
3906             return;
3907           }
3908           // Add back omitted leading zeros on odd length tokens
3909           // (fixes issue #18099)
3910           if (token.length % 2 !== 0) {
3911             token = "\u0000" + token;
3912           }
3913           const str = [];
3914           for (let k = 0; k < token.length; k += 2) {
3915             const w1 = (token.charCodeAt(k) << 8) | token.charCodeAt(k + 1);
3916             if ((w1 & 0xf800) !== 0xd800) {
3917               // w1 < 0xD800 || w1 > 0xDFFF
3918               str.push(w1);
3919               continue;
3920             }
3921             k += 2;
3922             const w2 = (token.charCodeAt(k) << 8) | token.charCodeAt(k + 1);
3923             str.push(((w1 & 0x3ff) << 10) + (w2 & 0x3ff) + 0x10000);
3924           }
3925           map[charCode] = String.fromCodePoint(...str);
3926         });
3927         return new ToUnicodeMap(map);
3928       } catch (reason) {
3929         if (reason instanceof AbortException) {
3930           return null;
3931         }
3932         if (this.options.ignoreErrors) {
3933           warn(`readToUnicode - ignoring ToUnicode data: "${reason}".`);
3934           return null;
3935         }
3936         throw reason;
3937       }
3938     }
3939     return null;
3940   }
3941 
3942   readCidToGidMap(glyphsData, toUnicode) {
3943     // Extract the encoding from the CIDToGIDMap
3944 
3945     // Set encoding 0 to later verify the font has an encoding
3946     const result = [];
3947     for (let j = 0, jj = glyphsData.length; j < jj; j++) {
3948       const glyphID = (glyphsData[j++] << 8) | glyphsData[j];
3949       const code = j >> 1;
3950       if (glyphID === 0 && !toUnicode.has(code)) {
3951         continue;
3952       }
3953       result[code] = glyphID;
3954     }
3955     return result;
3956   }
3957 
3958   extractWidths(dict, descriptor, properties) {
3959     const xref = this.xref;
3960     let glyphsWidths = [];
3961     let defaultWidth = 0;
3962     const glyphsVMetrics = [];
3963     let defaultVMetrics;
3964     if (properties.composite) {
3965       const dw = dict.get("DW");
3966       defaultWidth = typeof dw === "number" ? Math.ceil(dw) : 1000;
3967 
3968       const widths = dict.get("W");
3969       if (Array.isArray(widths)) {
3970         for (let i = 0, ii = widths.length; i < ii; i++) {
3971           let start = xref.fetchIfRef(widths[i++]);
3972           if (!Number.isInteger(start)) {
3973             break; // Invalid /W data.
3974           }
3975           const code = xref.fetchIfRef(widths[i]);
3976 
3977           if (Array.isArray(code)) {
3978             for (const c of code) {
3979               const width = xref.fetchIfRef(c);
3980               if (typeof width === "number") {
3981                 glyphsWidths[start] = width;
3982               }
3983               start++;
3984             }
3985           } else if (Number.isInteger(code)) {
3986             const width = xref.fetchIfRef(widths[++i]);
3987             if (typeof width !== "number") {
3988               continue;
3989             }
3990             for (let j = start; j <= code; j++) {
3991               glyphsWidths[j] = width;
3992             }
3993           } else {
3994             break; // Invalid /W data.
3995           }
3996         }
3997       }
3998 
3999       if (properties.vertical) {
4000         const dw2 = dict.getArray("DW2");
4001         let vmetrics = isNumberArray(dw2, 2) ? dw2 : [880, -1000];
4002         defaultVMetrics = [vmetrics[1], defaultWidth * 0.5, vmetrics[0]];
4003         vmetrics = dict.get("W2");
4004         if (Array.isArray(vmetrics)) {
4005           for (let i = 0, ii = vmetrics.length; i < ii; i++) {
4006             let start = xref.fetchIfRef(vmetrics[i++]);
4007             if (!Number.isInteger(start)) {
4008               break; // Invalid /W2 data.
4009             }
4010             const code = xref.fetchIfRef(vmetrics[i]);
4011 
4012             if (Array.isArray(code)) {
4013               for (let j = 0, jj = code.length; j < jj; j++) {
4014                 const vmetric = [
4015                   xref.fetchIfRef(code[j++]),
4016                   xref.fetchIfRef(code[j++]),
4017                   xref.fetchIfRef(code[j]),
4018                 ];
4019                 if (isNumberArray(vmetric, null)) {
4020                   glyphsVMetrics[start] = vmetric;
4021                 }
4022                 start++;
4023               }
4024             } else if (Number.isInteger(code)) {
4025               const vmetric = [
4026                 xref.fetchIfRef(vmetrics[++i]),
4027                 xref.fetchIfRef(vmetrics[++i]),
4028                 xref.fetchIfRef(vmetrics[++i]),
4029               ];
4030               if (!isNumberArray(vmetric, null)) {
4031                 continue;
4032               }
4033               for (let j = start; j <= code; j++) {
4034                 glyphsVMetrics[j] = vmetric;
4035               }
4036             } else {
4037               break; // Invalid /W2 data.
4038             }
4039           }
4040         }
4041       }
4042     } else {
4043       const widths = dict.get("Widths");
4044       if (Array.isArray(widths)) {
4045         let j = properties.firstChar;
4046         for (const w of widths) {
4047           const width = xref.fetchIfRef(w);
4048           if (typeof width === "number") {
4049             glyphsWidths[j] = width;
4050           }
4051           j++;
4052         }
4053         const missingWidth = descriptor.get("MissingWidth");
4054         defaultWidth = typeof missingWidth === "number" ? missingWidth : 0;
4055       } else {
4056         // Trying get the BaseFont metrics (see comment above).
4057         const baseFontName = dict.get("BaseFont");
4058         if (baseFontName instanceof Name) {
4059           const metrics = this.getBaseFontMetrics(baseFontName.name);
4060 
4061           glyphsWidths = this.buildCharCodeToWidth(metrics.widths, properties);
4062           defaultWidth = metrics.defaultWidth;
4063         }
4064       }
4065     }
4066 
4067     // Heuristic: detection of monospace font by checking all non-zero widths
4068     let isMonospace = true;
4069     let firstWidth = defaultWidth;
4070     for (const glyph in glyphsWidths) {
4071       const glyphWidth = glyphsWidths[glyph];
4072       if (!glyphWidth) {
4073         continue;
4074       }
4075       if (!firstWidth) {
4076         firstWidth = glyphWidth;
4077         continue;
4078       }
4079       if (firstWidth !== glyphWidth) {
4080         isMonospace = false;
4081         break;
4082       }
4083     }
4084     if (isMonospace) {
4085       properties.flags |= FontFlags.FixedPitch;
4086     } else {
4087       // Clear the flag.
4088       properties.flags &= ~FontFlags.FixedPitch;
4089     }
4090 
4091     properties.defaultWidth = defaultWidth;
4092     properties.widths = glyphsWidths;
4093     properties.defaultVMetrics = defaultVMetrics;
4094     properties.vmetrics = glyphsVMetrics;
4095   }
4096 
4097   isSerifFont(baseFontName) {
4098     // Simulating descriptor flags attribute
4099     const fontNameWoStyle = baseFontName.split("-", 1)[0];
4100     return (
4101       fontNameWoStyle in getSerifFonts() || /serif/gi.test(fontNameWoStyle)
4102     );
4103   }
4104 
4105   getBaseFontMetrics(name) {
4106     let defaultWidth = 0;
4107     let widths = Object.create(null);
4108     let monospace = false;
4109     const stdFontMap = getStdFontMap();
4110     let lookupName = stdFontMap[name] || name;
4111     const Metrics = getMetrics();
4112 
4113     if (!(lookupName in Metrics)) {
4114       // Use default fonts for looking up font metrics if the passed
4115       // font is not a base font
4116       lookupName = this.isSerifFont(name) ? "Times-Roman" : "Helvetica";
4117     }
4118     const glyphWidths = Metrics[lookupName];
4119 
4120     if (typeof glyphWidths === "number") {
4121       defaultWidth = glyphWidths;
4122       monospace = true;
4123     } else {
4124       widths = glyphWidths(); // expand lazy widths array
4125     }
4126 
4127     return {
4128       defaultWidth,
4129       monospace,
4130       widths,
4131     };
4132   }
4133 
4134   buildCharCodeToWidth(widthsByGlyphName, properties) {
4135     const widths = Object.create(null);
4136     const differences = properties.differences;
4137     const encoding = properties.defaultEncoding;
4138     for (let charCode = 0; charCode < 256; charCode++) {
4139       if (charCode in differences && widthsByGlyphName[differences[charCode]]) {
4140         widths[charCode] = widthsByGlyphName[differences[charCode]];
4141         continue;
4142       }
4143       if (charCode in encoding && widthsByGlyphName[encoding[charCode]]) {
4144         widths[charCode] = widthsByGlyphName[encoding[charCode]];
4145         continue;
4146       }
4147     }
4148     return widths;
4149   }
4150 
4151   preEvaluateFont(dict) {
4152     const baseDict = dict;
4153     let type = dict.get("Subtype");
4154     if (!(type instanceof Name)) {
4155       throw new FormatError("invalid font Subtype");
4156     }
4157 
4158     let composite = false;
4159     let hash;
4160     if (type.name === "Type0") {
4161       // If font is a composite
4162       //  - get the descendant font
4163       //  - set the type according to the descendant font
4164       //  - get the FontDescriptor from the descendant font
4165       const df = dict.get("DescendantFonts");
4166       if (!df) {
4167         throw new FormatError("Descendant fonts are not specified");
4168       }
4169       dict = Array.isArray(df) ? this.xref.fetchIfRef(df[0]) : df;
4170 
4171       if (!(dict instanceof Dict)) {
4172         throw new FormatError("Descendant font is not a dictionary.");
4173       }
4174       type = dict.get("Subtype");
4175       if (!(type instanceof Name)) {
4176         throw new FormatError("invalid font Subtype");
4177       }
4178       composite = true;
4179     }
4180 
4181     let firstChar = dict.get("FirstChar");
4182     if (!Number.isInteger(firstChar)) {
4183       firstChar = 0;
4184     }
4185     let lastChar = dict.get("LastChar");
4186     if (!Number.isInteger(lastChar)) {
4187       lastChar = composite ? 0xffff : 0xff;
4188     }
4189     const descriptor = dict.get("FontDescriptor");
4190     const toUnicode = dict.get("ToUnicode") || baseDict.get("ToUnicode");
4191 
4192     if (descriptor) {
4193       hash = new MurmurHash3_64();
4194 
4195       const encoding = baseDict.getRaw("Encoding");
4196       if (encoding instanceof Name) {
4197         hash.update(encoding.name);
4198       } else if (encoding instanceof Ref) {
4199         hash.update(encoding.toString());
4200       } else if (encoding instanceof Dict) {
4201         for (const entry of encoding.getRawValues()) {
4202           if (entry instanceof Name) {
4203             hash.update(entry.name);
4204           } else if (entry instanceof Ref) {
4205             hash.update(entry.toString());
4206           } else if (Array.isArray(entry)) {
4207             // 'Differences' array (fixes bug1157493.pdf).
4208             const diffLength = entry.length,
4209               diffBuf = new Array(diffLength);
4210 
4211             for (let j = 0; j < diffLength; j++) {
4212               const diffEntry = entry[j];
4213               if (diffEntry instanceof Name) {
4214                 diffBuf[j] = diffEntry.name;
4215               } else if (
4216                 typeof diffEntry === "number" ||
4217                 diffEntry instanceof Ref
4218               ) {
4219                 diffBuf[j] = diffEntry.toString();
4220               }
4221             }
4222             hash.update(diffBuf.join());
4223           }
4224         }
4225       }
4226 
4227       hash.update(`${firstChar}-${lastChar}`); // Fixes issue10665_reduced.pdf
4228 
4229       if (toUnicode instanceof BaseStream) {
4230         const stream = toUnicode.str || toUnicode;
4231         const uint8array = stream.buffer
4232           ? new Uint8Array(stream.buffer.buffer, 0, stream.bufferLength)
4233           : new Uint8Array(
4234               stream.bytes.buffer,
4235               stream.start,
4236               stream.end - stream.start
4237             );
4238         hash.update(uint8array);
4239       } else if (toUnicode instanceof Name) {
4240         hash.update(toUnicode.name);
4241       }
4242 
4243       const widths = dict.get("Widths") || baseDict.get("Widths");
4244       if (Array.isArray(widths)) {
4245         const widthsBuf = [];
4246         for (const entry of widths) {
4247           if (typeof entry === "number" || entry instanceof Ref) {
4248             widthsBuf.push(entry.toString());
4249           }
4250         }
4251         hash.update(widthsBuf.join());
4252       }
4253 
4254       if (composite) {
4255         hash.update("compositeFont");
4256 
4257         const compositeWidths = dict.get("W") || baseDict.get("W");
4258         if (Array.isArray(compositeWidths)) {
4259           const widthsBuf = [];
4260           for (const entry of compositeWidths) {
4261             if (typeof entry === "number" || entry instanceof Ref) {
4262               widthsBuf.push(entry.toString());
4263             } else if (Array.isArray(entry)) {
4264               const subWidthsBuf = [];
4265               for (const element of entry) {
4266                 if (typeof element === "number" || element instanceof Ref) {
4267                   subWidthsBuf.push(element.toString());
4268                 }
4269               }
4270               widthsBuf.push(`[${subWidthsBuf.join()}]`);
4271             }
4272           }
4273           hash.update(widthsBuf.join());
4274         }
4275 
4276         const cidToGidMap =
4277           dict.getRaw("CIDToGIDMap") || baseDict.getRaw("CIDToGIDMap");
4278         if (cidToGidMap instanceof Name) {
4279           hash.update(cidToGidMap.name);
4280         } else if (cidToGidMap instanceof Ref) {
4281           hash.update(cidToGidMap.toString());
4282         } else if (cidToGidMap instanceof BaseStream) {
4283           hash.update(cidToGidMap.peekBytes());
4284         }
4285       }
4286     }
4287 
4288     return {
4289       descriptor,
4290       dict,
4291       baseDict,
4292       composite,
4293       type: type.name,
4294       firstChar,
4295       lastChar,
4296       toUnicode,
4297       hash: hash ? hash.hexdigest() : "",
4298     };
4299   }
4300 
4301   async translateFont({
4302     descriptor,
4303     dict,
4304     baseDict,
4305     composite,
4306     type,
4307     firstChar,
4308     lastChar,
4309     toUnicode,
4310     cssFontInfo,
4311   }) {
4312     const isType3Font = type === "Type3";
4313 
4314     if (!descriptor) {
4315       if (isType3Font) {
4316         const bbox = lookupNormalRect(dict.getArray("FontBBox"), [0, 0, 0, 0]);
4317         // FontDescriptor is only required for Type3 fonts when the document
4318         // is a tagged pdf. Create a barbebones one to get by.
4319         descriptor = new Dict(null);
4320         descriptor.set("FontName", Name.get(type));
4321         descriptor.set("FontBBox", bbox);
4322       } else {
4323         // Before PDF 1.5 if the font was one of the base 14 fonts, having a
4324         // FontDescriptor was not required.
4325         // This case is here for compatibility.
4326         let baseFontName = dict.get("BaseFont");
4327         if (!(baseFontName instanceof Name)) {
4328           throw new FormatError("Base font is not specified");
4329         }
4330 
4331         // Using base font name as a font name.
4332         baseFontName = baseFontName.name.replaceAll(/[,_]/g, "-");
4333         const metrics = this.getBaseFontMetrics(baseFontName);
4334 
4335         // Simulating descriptor flags attribute
4336         const fontNameWoStyle = baseFontName.split("-", 1)[0];
4337         const flags =
4338           (this.isSerifFont(fontNameWoStyle) ? FontFlags.Serif : 0) |
4339           (metrics.monospace ? FontFlags.FixedPitch : 0) |
4340           (getSymbolsFonts()[fontNameWoStyle]
4341             ? FontFlags.Symbolic
4342             : FontFlags.Nonsymbolic);
4343 
4344         const properties = {
4345           type,
4346           name: baseFontName,
4347           loadedName: baseDict.loadedName,
4348           systemFontInfo: null,
4349           widths: metrics.widths,
4350           defaultWidth: metrics.defaultWidth,
4351           isSimulatedFlags: true,
4352           flags,
4353           firstChar,
4354           lastChar,
4355           toUnicode,
4356           xHeight: 0,
4357           capHeight: 0,
4358           italicAngle: 0,
4359           isType3Font,
4360         };
4361         const widths = dict.get("Widths");
4362 
4363         const standardFontName = getStandardFontName(baseFontName);
4364         let file = null;
4365         if (standardFontName) {
4366           file = await this.fetchStandardFontData(standardFontName);
4367           properties.isInternalFont = !!file;
4368         }
4369         if (!properties.isInternalFont && this.options.useSystemFonts) {
4370           properties.systemFontInfo = getFontSubstitution(
4371             this.systemFontCache,
4372             this.idFactory,
4373             this.options.standardFontDataUrl,
4374             baseFontName,
4375             standardFontName,
4376             type
4377           );
4378         }
4379 
4380         const newProperties = await this.extractDataStructures(
4381           dict,
4382           properties
4383         );
4384         if (Array.isArray(widths)) {
4385           const glyphWidths = [];
4386           let j = firstChar;
4387           for (const w of widths) {
4388             const width = this.xref.fetchIfRef(w);
4389             if (typeof width === "number") {
4390               glyphWidths[j] = width;
4391             }
4392             j++;
4393           }
4394           newProperties.widths = glyphWidths;
4395         } else {
4396           newProperties.widths = this.buildCharCodeToWidth(
4397             metrics.widths,
4398             newProperties
4399           );
4400         }
4401         return new Font(baseFontName, file, newProperties, this.options);
4402       }
4403     }
4404 
4405     // According to the spec if 'FontDescriptor' is declared, 'FirstChar',
4406     // 'LastChar' and 'Widths' should exist too, but some PDF encoders seem
4407     // to ignore this rule when a variant of a standard font is used.
4408     // TODO Fill the width array depending on which of the base font this is
4409     // a variant.
4410 
4411     let fontName = descriptor.get("FontName");
4412     let baseFont = dict.get("BaseFont");
4413     // Some bad PDFs have a string as the font name.
4414     if (typeof fontName === "string") {
4415       fontName = Name.get(fontName);
4416     }
4417     if (typeof baseFont === "string") {
4418       baseFont = Name.get(baseFont);
4419     }
4420 
4421     const fontNameStr = fontName?.name;
4422     const baseFontStr = baseFont?.name;
4423     if (!isType3Font && fontNameStr !== baseFontStr) {
4424       info(
4425         `The FontDescriptor's FontName is "${fontNameStr}" but ` +
4426           `should be the same as the Font's BaseFont "${baseFontStr}".`
4427       );
4428       // - Workaround for cases where e.g. fontNameStr = 'Arial' and
4429       //   baseFontStr = 'Arial,Bold' (needed when no font file is embedded).
4430       //
4431       // - Workaround for cases where e.g. fontNameStr = 'wg09np' and
4432       //   baseFontStr = 'Wingdings-Regular' (fixes issue7454.pdf).
4433       if (
4434         fontNameStr &&
4435         baseFontStr &&
4436         (baseFontStr.startsWith(fontNameStr) ||
4437           (!isKnownFontName(fontNameStr) && isKnownFontName(baseFontStr)))
4438       ) {
4439         fontName = null;
4440       }
4441     }
4442     fontName ||= baseFont;
4443 
4444     if (!(fontName instanceof Name)) {
4445       throw new FormatError("invalid font name");
4446     }
4447 
4448     let fontFile, subtype, length1, length2, length3;
4449     try {
4450       fontFile = descriptor.get("FontFile", "FontFile2", "FontFile3");
4451 
4452       if (fontFile) {
4453         if (!(fontFile instanceof BaseStream)) {
4454           throw new FormatError("FontFile should be a stream");
4455         } else if (fontFile.isEmpty) {
4456           throw new FormatError("FontFile is empty");
4457         }
4458       }
4459     } catch (ex) {
4460       if (!this.options.ignoreErrors) {
4461         throw ex;
4462       }
4463       warn(`translateFont - fetching "${fontName.name}" font file: "${ex}".`);
4464       fontFile = null;
4465     }
4466     let isInternalFont = false;
4467     let glyphScaleFactors = null;
4468     let systemFontInfo = null;
4469     if (fontFile) {
4470       if (fontFile.dict) {
4471         const subtypeEntry = fontFile.dict.get("Subtype");
4472         if (subtypeEntry instanceof Name) {
4473           subtype = subtypeEntry.name;
4474         }
4475         length1 = fontFile.dict.get("Length1");
4476         length2 = fontFile.dict.get("Length2");
4477         length3 = fontFile.dict.get("Length3");
4478       }
4479     } else if (cssFontInfo) {
4480       // We've a missing XFA font.
4481       const standardFontName = getXfaFontName(fontName.name);
4482       if (standardFontName) {
4483         cssFontInfo.fontFamily = `${cssFontInfo.fontFamily}-PdfJS-XFA`;
4484         cssFontInfo.metrics = standardFontName.metrics || null;
4485         glyphScaleFactors = standardFontName.factors || null;
4486         fontFile = await this.fetchStandardFontData(standardFontName.name);
4487         isInternalFont = !!fontFile;
4488 
4489         // We're using a substitution font but for example widths (if any)
4490         // are related to the glyph positions in the font.
4491         // So we overwrite everything here to be sure that widths are
4492         // correct.
4493         baseDict = dict = getXfaFontDict(fontName.name);
4494         composite = true;
4495       }
4496     } else if (!isType3Font) {
4497       const standardFontName = getStandardFontName(fontName.name);
4498       if (standardFontName) {
4499         fontFile = await this.fetchStandardFontData(standardFontName);
4500         isInternalFont = !!fontFile;
4501       }
4502       if (!isInternalFont && this.options.useSystemFonts) {
4503         systemFontInfo = getFontSubstitution(
4504           this.systemFontCache,
4505           this.idFactory,
4506           this.options.standardFontDataUrl,
4507           fontName.name,
4508           standardFontName,
4509           type
4510         );
4511       }
4512     }
4513 
4514     const fontMatrix = lookupMatrix(
4515       dict.getArray("FontMatrix"),
4516       FONT_IDENTITY_MATRIX
4517     );
4518     const bbox = lookupNormalRect(
4519       descriptor.getArray("FontBBox") || dict.getArray("FontBBox"),
4520       undefined
4521     );
4522     let ascent = descriptor.get("Ascent");
4523     if (typeof ascent !== "number") {
4524       ascent = undefined;
4525     }
4526     let descent = descriptor.get("Descent");
4527     if (typeof descent !== "number") {
4528       descent = undefined;
4529     }
4530     let xHeight = descriptor.get("XHeight");
4531     if (typeof xHeight !== "number") {
4532       xHeight = 0;
4533     }
4534     let capHeight = descriptor.get("CapHeight");
4535     if (typeof capHeight !== "number") {
4536       capHeight = 0;
4537     }
4538     let flags = descriptor.get("Flags");
4539     if (!Number.isInteger(flags)) {
4540       flags = 0;
4541     }
4542     let italicAngle = descriptor.get("ItalicAngle");
4543     if (typeof italicAngle !== "number") {
4544       italicAngle = 0;
4545     }
4546 
4547     const properties = {
4548       type,
4549       name: fontName.name,
4550       subtype,
4551       file: fontFile,
4552       length1,
4553       length2,
4554       length3,
4555       isInternalFont,
4556       loadedName: baseDict.loadedName,
4557       composite,
4558       fixedPitch: false,
4559       fontMatrix,
4560       firstChar,
4561       lastChar,
4562       toUnicode,
4563       bbox,
4564       ascent,
4565       descent,
4566       xHeight,
4567       capHeight,
4568       flags,
4569       italicAngle,
4570       isType3Font,
4571       cssFontInfo,
4572       scaleFactors: glyphScaleFactors,
4573       systemFontInfo,
4574     };
4575 
4576     if (composite) {
4577       const cidEncoding = baseDict.get("Encoding");
4578       if (cidEncoding instanceof Name) {
4579         properties.cidEncoding = cidEncoding.name;
4580       }
4581       const cMap = await CMapFactory.create({
4582         encoding: cidEncoding,
4583         fetchBuiltInCMap: this._fetchBuiltInCMapBound,
4584         useCMap: null,
4585       });
4586       properties.cMap = cMap;
4587       properties.vertical = properties.cMap.vertical;
4588     }
4589 
4590     const newProperties = await this.extractDataStructures(dict, properties);
4591     this.extractWidths(dict, descriptor, newProperties);
4592 
4593     return new Font(fontName.name, fontFile, newProperties, this.options);
4594   }
4595 
4596   static buildFontPaths(font, glyphs, handler, evaluatorOptions) {
4597     function buildPath(fontChar) {
4598       const glyphName = `${font.loadedName}_path_${fontChar}`;
4599       try {
4600         if (font.renderer.hasBuiltPath(fontChar)) {
4601           return;
4602         }
4603         handler.send("commonobj", [
4604           glyphName,
4605           "FontPath",
4606           font.renderer.getPathJs(fontChar),
4607         ]);
4608       } catch (reason) {
4609         if (evaluatorOptions.ignoreErrors) {
4610           warn(`buildFontPaths - ignoring ${glyphName} glyph: "${reason}".`);
4611           return;
4612         }
4613         throw reason;
4614       }
4615     }
4616 
4617     for (const glyph of glyphs) {
4618       buildPath(glyph.fontChar);
4619 
4620       // If the glyph has an accent we need to build a path for its
4621       // fontChar too, otherwise CanvasGraphics_paintChar will fail.
4622       const accent = glyph.accent;
4623       if (accent?.fontChar) {
4624         buildPath(accent.fontChar);
4625       }
4626     }
4627   }
4628 
4629   static get fallbackFontDict() {
4630     const dict = new Dict();
4631     dict.set("BaseFont", Name.get("Helvetica"));
4632     dict.set("Type", Name.get("FallbackType"));
4633     dict.set("Subtype", Name.get("FallbackType"));
4634     dict.set("Encoding", Name.get("WinAnsiEncoding"));
4635 
4636     return shadow(this, "fallbackFontDict", dict);
4637   }
4638 }
4639 
4640 class TranslatedFont {
4641   #sent = false;
4642 
4643   #type3Loaded = null;
4644 
4645   constructor({ loadedName, font, dict }) {
4646     this.loadedName = loadedName;
4647     this.font = font;
4648     this.dict = dict;
4649     this.type3Dependencies = font.isType3Font ? new Set() : null;
4650   }
4651 
4652   send(handler) {
4653     if (this.#sent) {
4654       return;
4655     }
4656     this.#sent = true;
4657 
4658     handler.send("commonobj", [
4659       this.loadedName,
4660       "Font",
4661       this.font.exportData(),
4662     ]);
4663   }
4664 
4665   fallback(handler, evaluatorOptions) {
4666     if (!this.font.data) {
4667       return;
4668     }
4669     // When font loading failed, fall back to the built-in font renderer.
4670     this.font.disableFontFace = true;
4671     // An arbitrary number of text rendering operators could have been
4672     // encountered between the point in time when the 'Font' message was sent
4673     // to the main-thread, and the point in time when the 'FontFallback'
4674     // message was received on the worker-thread.
4675     // To ensure that all 'FontPath's are available on the main-thread, when
4676     // font loading failed, attempt to resend *all* previously parsed glyphs.
4677     PartialEvaluator.buildFontPaths(
4678       this.font,
4679       /* glyphs = */ this.font.glyphCacheValues,
4680       handler,
4681       evaluatorOptions
4682     );
4683   }
4684 
4685   loadType3Data(evaluator, resources, task) {
4686     if (this.#type3Loaded) {
4687       return this.#type3Loaded;
4688     }
4689     const { font, type3Dependencies } = this;
4690     assert(font.isType3Font, "Must be a Type3 font.");
4691 
4692     // When parsing Type3 glyphs, always ignore them if there are errors.
4693     // Compared to the parsing of e.g. an entire page, it doesn't really
4694     // make sense to only be able to render a Type3 glyph partially.
4695     const type3Evaluator = evaluator.clone({ ignoreErrors: false });
4696     // Prevent circular references in Type3 fonts.
4697     const type3FontRefs = new RefSet(evaluator.type3FontRefs);
4698     if (this.dict.objId && !type3FontRefs.has(this.dict.objId)) {
4699       type3FontRefs.put(this.dict.objId);
4700     }
4701     type3Evaluator.type3FontRefs = type3FontRefs;
4702 
4703     let loadCharProcsPromise = Promise.resolve();
4704     const charProcs = this.dict.get("CharProcs");
4705     const fontResources = this.dict.get("Resources") || resources;
4706     const charProcOperatorList = Object.create(null);
4707 
4708     const fontBBox = Util.normalizeRect(font.bbox || [0, 0, 0, 0]),
4709       width = fontBBox[2] - fontBBox[0],
4710       height = fontBBox[3] - fontBBox[1];
4711     const fontBBoxSize = Math.hypot(width, height);
4712 
4713     for (const key of charProcs.getKeys()) {
4714       loadCharProcsPromise = loadCharProcsPromise.then(() => {
4715         const glyphStream = charProcs.get(key);
4716         const operatorList = new OperatorList();
4717         return type3Evaluator
4718           .getOperatorList({
4719             stream: glyphStream,
4720             task,
4721             resources: fontResources,
4722             operatorList,
4723           })
4724           .then(() => {
4725             // According to the PDF specification, section "9.6.5 Type 3 Fonts"
4726             // and "Table 113":
4727             //  "A glyph description that begins with the d1 operator should
4728             //   not execute any operators that set the colour (or other
4729             //   colour-related parameters) in the graphics state;
4730             //   any use of such operators shall be ignored."
4731             switch (operatorList.fnArray[0]) {
4732               case OPS.setCharWidthAndBounds:
4733                 this.#removeType3ColorOperators(operatorList, fontBBoxSize);
4734                 break;
4735               case OPS.setCharWidth:
4736                 if (!fontBBoxSize) {
4737                   this.#guessType3FontBBox(operatorList);
4738                 }
4739                 break;
4740             }
4741             charProcOperatorList[key] = operatorList.getIR();
4742 
4743             for (const dependency of operatorList.dependencies) {
4744               type3Dependencies.add(dependency);
4745             }
4746           })
4747           .catch(function (reason) {
4748             warn(`Type3 font resource "${key}" is not available.`);
4749             const dummyOperatorList = new OperatorList();
4750             charProcOperatorList[key] = dummyOperatorList.getIR();
4751           });
4752       });
4753     }
4754     this.#type3Loaded = loadCharProcsPromise.then(() => {
4755       font.charProcOperatorList = charProcOperatorList;
4756       if (this._bbox) {
4757         font.isCharBBox = true;
4758         font.bbox = this._bbox;
4759       }
4760     });
4761     return this.#type3Loaded;
4762   }
4763 
4764   #removeType3ColorOperators(operatorList, fontBBoxSize = NaN) {
4765     if (typeof PDFJSDev === "undefined" || PDFJSDev.test("TESTING")) {
4766       assert(
4767         operatorList.fnArray[0] === OPS.setCharWidthAndBounds,
4768         "Type3 glyph shall start with the d1 operator."
4769       );
4770     }
4771     const charBBox = Util.normalizeRect(operatorList.argsArray[0].slice(2)),
4772       width = charBBox[2] - charBBox[0],
4773       height = charBBox[3] - charBBox[1];
4774     const charBBoxSize = Math.hypot(width, height);
4775 
4776     if (width === 0 || height === 0) {
4777       // Skip the d1 operator when its bounds are bogus (fixes issue14953.pdf).
4778       operatorList.fnArray.splice(0, 1);
4779       operatorList.argsArray.splice(0, 1);
4780     } else if (
4781       fontBBoxSize === 0 ||
4782       Math.round(charBBoxSize / fontBBoxSize) >= 10
4783     ) {
4784       // Override the fontBBox when it's undefined/empty, or when it's at least
4785       // (approximately) one order of magnitude smaller than the charBBox
4786       // (fixes issue14999_reduced.pdf).
4787       this._bbox ??= [Infinity, Infinity, -Infinity, -Infinity];
4788       Util.rectBoundingBox(...charBBox, this._bbox);
4789     }
4790 
4791     let i = 0,
4792       ii = operatorList.length;
4793     while (i < ii) {
4794       switch (operatorList.fnArray[i]) {
4795         case OPS.setCharWidthAndBounds:
4796           break; // Handled above.
4797         case OPS.setStrokeColorSpace:
4798         case OPS.setFillColorSpace:
4799         case OPS.setStrokeColor:
4800         case OPS.setStrokeColorN:
4801         case OPS.setFillColor:
4802         case OPS.setFillColorN:
4803         case OPS.setStrokeGray:
4804         case OPS.setFillGray:
4805         case OPS.setStrokeRGBColor:
4806         case OPS.setFillRGBColor:
4807         case OPS.setStrokeCMYKColor:
4808         case OPS.setFillCMYKColor:
4809         case OPS.shadingFill:
4810         case OPS.setRenderingIntent:
4811           operatorList.fnArray.splice(i, 1);
4812           operatorList.argsArray.splice(i, 1);
4813           ii--;
4814           continue;
4815 
4816         case OPS.setGState:
4817           const [gStateObj] = operatorList.argsArray[i];
4818           let j = 0,
4819             jj = gStateObj.length;
4820           while (j < jj) {
4821             const [gStateKey] = gStateObj[j];
4822             switch (gStateKey) {
4823               case "TR":
4824               case "TR2":
4825               case "HT":
4826               case "BG":
4827               case "BG2":
4828               case "UCR":
4829               case "UCR2":
4830                 gStateObj.splice(j, 1);
4831                 jj--;
4832                 continue;
4833             }
4834             j++;
4835           }
4836           break;
4837       }
4838       i++;
4839     }
4840   }
4841 
4842   #guessType3FontBBox(operatorList) {
4843     if (typeof PDFJSDev === "undefined" || PDFJSDev.test("TESTING")) {
4844       assert(
4845         operatorList.fnArray[0] === OPS.setCharWidth,
4846         "Type3 glyph shall start with the d0 operator."
4847       );
4848     }
4849 
4850     let i = 1;
4851     const ii = operatorList.length;
4852     while (i < ii) {
4853       switch (operatorList.fnArray[i]) {
4854         case OPS.constructPath:
4855           const minMax = operatorList.argsArray[i][2];
4856           // Override the fontBBox when it's undefined/empty (fixes 19624.pdf).
4857           this._bbox ??= [Infinity, Infinity, -Infinity, -Infinity];
4858           Util.rectBoundingBox(...minMax, this._bbox);
4859           break;
4860       }
4861       i++;
4862     }
4863   }
4864 }
4865 
4866 class StateManager {
4867   constructor(initialState = new EvalState()) {
4868     this.state = initialState;
4869     this.stateStack = [];
4870   }
4871 
4872   save() {
4873     const old = this.state;
4874     this.stateStack.push(this.state);
4875     this.state = old.clone();
4876   }
4877 
4878   restore() {
4879     const prev = this.stateStack.pop();
4880     if (prev) {
4881       this.state = prev;
4882     }
4883   }
4884 
4885   transform(args) {
4886     this.state.ctm = Util.transform(this.state.ctm, args);
4887   }
4888 }
4889 
4890 class TextState {
4891   constructor() {
4892     this.ctm = new Float32Array(IDENTITY_MATRIX);
4893     this.fontName = null;
4894     this.fontSize = 0;
4895     this.loadedName = null;
4896     this.font = null;
4897     this.fontMatrix = FONT_IDENTITY_MATRIX;
4898     this.textMatrix = IDENTITY_MATRIX.slice();
4899     this.textLineMatrix = IDENTITY_MATRIX.slice();
4900     this.charSpacing = 0;
4901     this.wordSpacing = 0;
4902     this.leading = 0;
4903     this.textHScale = 1;
4904     this.textRise = 0;
4905   }
4906 
4907   setTextMatrix(a, b, c, d, e, f) {
4908     const m = this.textMatrix;
4909     m[0] = a;
4910     m[1] = b;
4911     m[2] = c;
4912     m[3] = d;
4913     m[4] = e;
4914     m[5] = f;
4915   }
4916 
4917   setTextLineMatrix(a, b, c, d, e, f) {
4918     const m = this.textLineMatrix;
4919     m[0] = a;
4920     m[1] = b;
4921     m[2] = c;
4922     m[3] = d;
4923     m[4] = e;
4924     m[5] = f;
4925   }
4926 
4927   translateTextMatrix(x, y) {
4928     const m = this.textMatrix;
4929     m[4] = m[0] * x + m[2] * y + m[4];
4930     m[5] = m[1] * x + m[3] * y + m[5];
4931   }
4932 
4933   translateTextLineMatrix(x, y) {
4934     const m = this.textLineMatrix;
4935     m[4] = m[0] * x + m[2] * y + m[4];
4936     m[5] = m[1] * x + m[3] * y + m[5];
4937   }
4938 
4939   carriageReturn() {
4940     this.translateTextLineMatrix(0, -this.leading);
4941     this.textMatrix = this.textLineMatrix.slice();
4942   }
4943 
4944   clone() {
4945     const clone = Object.create(this);
4946     clone.textMatrix = this.textMatrix.slice();
4947     clone.textLineMatrix = this.textLineMatrix.slice();
4948     clone.fontMatrix = this.fontMatrix.slice();
4949     return clone;
4950   }
4951 }
4952 
4953 class EvalState {
4954   constructor() {
4955     this.ctm = new Float32Array(IDENTITY_MATRIX);
4956     this.font = null;
4957     this.textRenderingMode = TextRenderingMode.FILL;
4958     this._fillColorSpace = this._strokeColorSpace = ColorSpaceUtils.gray;
4959     this.patternFillColorSpace = null;
4960     this.patternStrokeColorSpace = null;
4961 
4962     // Path stuff.
4963     this.currentPointX = this.currentPointY = 0;
4964     this.pathMinMax = new Float32Array([
4965       Infinity,
4966       Infinity,
4967       -Infinity,
4968       -Infinity,
4969     ]);
4970     this.pathBuffer = [];
4971   }
4972 
4973   get fillColorSpace() {
4974     return this._fillColorSpace;
4975   }
4976 
4977   set fillColorSpace(colorSpace) {
4978     this._fillColorSpace = this.patternFillColorSpace = colorSpace;
4979   }
4980 
4981   get strokeColorSpace() {
4982     return this._strokeColorSpace;
4983   }
4984 
4985   set strokeColorSpace(colorSpace) {
4986     this._strokeColorSpace = this.patternStrokeColorSpace = colorSpace;
4987   }
4988 
4989   clone({ newPath = false } = {}) {
4990     const clone = Object.create(this);
4991     if (newPath) {
4992       clone.pathBuffer = [];
4993       clone.pathMinMax = new Float32Array([
4994         Infinity,
4995         Infinity,
4996         -Infinity,
4997         -Infinity,
4998       ]);
4999     }
5000     return clone;
5001   }
5002 }
5003 
5004 class EvaluatorPreprocessor {
5005   static get opMap() {
5006     // Specifies properties for each command
5007     //
5008     // If variableArgs === true: [0, `numArgs`] expected
5009     // If variableArgs === false: exactly `numArgs` expected
5010     return shadow(
5011       this,
5012       "opMap",
5013       Object.assign(Object.create(null), {
5014         // Graphic state
5015         w: { id: OPS.setLineWidth, numArgs: 1, variableArgs: false },
5016         J: { id: OPS.setLineCap, numArgs: 1, variableArgs: false },
5017         j: { id: OPS.setLineJoin, numArgs: 1, variableArgs: false },
5018         M: { id: OPS.setMiterLimit, numArgs: 1, variableArgs: false },
5019         d: { id: OPS.setDash, numArgs: 2, variableArgs: false },
5020         ri: { id: OPS.setRenderingIntent, numArgs: 1, variableArgs: false },
5021         i: { id: OPS.setFlatness, numArgs: 1, variableArgs: false },
5022         gs: { id: OPS.setGState, numArgs: 1, variableArgs: false },
5023         q: { id: OPS.save, numArgs: 0, variableArgs: false },
5024         Q: { id: OPS.restore, numArgs: 0, variableArgs: false },
5025         cm: { id: OPS.transform, numArgs: 6, variableArgs: false },
5026 
5027         // Path
5028         m: { id: OPS.moveTo, numArgs: 2, variableArgs: false },
5029         l: { id: OPS.lineTo, numArgs: 2, variableArgs: false },
5030         c: { id: OPS.curveTo, numArgs: 6, variableArgs: false },
5031         v: { id: OPS.curveTo2, numArgs: 4, variableArgs: false },
5032         y: { id: OPS.curveTo3, numArgs: 4, variableArgs: false },
5033         h: { id: OPS.closePath, numArgs: 0, variableArgs: false },
5034         re: { id: OPS.rectangle, numArgs: 4, variableArgs: false },
5035         S: { id: OPS.stroke, numArgs: 0, variableArgs: false },
5036         s: { id: OPS.closeStroke, numArgs: 0, variableArgs: false },
5037         f: { id: OPS.fill, numArgs: 0, variableArgs: false },
5038         F: { id: OPS.fill, numArgs: 0, variableArgs: false },
5039         "f*": { id: OPS.eoFill, numArgs: 0, variableArgs: false },
5040         B: { id: OPS.fillStroke, numArgs: 0, variableArgs: false },
5041         "B*": { id: OPS.eoFillStroke, numArgs: 0, variableArgs: false },
5042         b: { id: OPS.closeFillStroke, numArgs: 0, variableArgs: false },
5043         "b*": { id: OPS.closeEOFillStroke, numArgs: 0, variableArgs: false },
5044         n: { id: OPS.endPath, numArgs: 0, variableArgs: false },
5045 
5046         // Clipping
5047         W: { id: OPS.clip, numArgs: 0, variableArgs: false },
5048         "W*": { id: OPS.eoClip, numArgs: 0, variableArgs: false },
5049 
5050         // Text
5051         BT: { id: OPS.beginText, numArgs: 0, variableArgs: false },
5052         ET: { id: OPS.endText, numArgs: 0, variableArgs: false },
5053         Tc: { id: OPS.setCharSpacing, numArgs: 1, variableArgs: false },
5054         Tw: { id: OPS.setWordSpacing, numArgs: 1, variableArgs: false },
5055         Tz: { id: OPS.setHScale, numArgs: 1, variableArgs: false },
5056         TL: { id: OPS.setLeading, numArgs: 1, variableArgs: false },
5057         Tf: { id: OPS.setFont, numArgs: 2, variableArgs: false },
5058         Tr: { id: OPS.setTextRenderingMode, numArgs: 1, variableArgs: false },
5059         Ts: { id: OPS.setTextRise, numArgs: 1, variableArgs: false },
5060         Td: { id: OPS.moveText, numArgs: 2, variableArgs: false },
5061         TD: { id: OPS.setLeadingMoveText, numArgs: 2, variableArgs: false },
5062         Tm: { id: OPS.setTextMatrix, numArgs: 6, variableArgs: false },
5063         "T*": { id: OPS.nextLine, numArgs: 0, variableArgs: false },
5064         Tj: { id: OPS.showText, numArgs: 1, variableArgs: false },
5065         TJ: { id: OPS.showSpacedText, numArgs: 1, variableArgs: false },
5066         "'": { id: OPS.nextLineShowText, numArgs: 1, variableArgs: false },
5067         '"': {
5068           id: OPS.nextLineSetSpacingShowText,
5069           numArgs: 3,
5070           variableArgs: false,
5071         },
5072 
5073         // Type3 fonts
5074         d0: { id: OPS.setCharWidth, numArgs: 2, variableArgs: false },
5075         d1: {
5076           id: OPS.setCharWidthAndBounds,
5077           numArgs: 6,
5078           variableArgs: false,
5079         },
5080 
5081         // Color
5082         CS: { id: OPS.setStrokeColorSpace, numArgs: 1, variableArgs: false },
5083         cs: { id: OPS.setFillColorSpace, numArgs: 1, variableArgs: false },
5084         SC: { id: OPS.setStrokeColor, numArgs: 4, variableArgs: true },
5085         SCN: { id: OPS.setStrokeColorN, numArgs: 33, variableArgs: true },
5086         sc: { id: OPS.setFillColor, numArgs: 4, variableArgs: true },
5087         scn: { id: OPS.setFillColorN, numArgs: 33, variableArgs: true },
5088         G: { id: OPS.setStrokeGray, numArgs: 1, variableArgs: false },
5089         g: { id: OPS.setFillGray, numArgs: 1, variableArgs: false },
5090         RG: { id: OPS.setStrokeRGBColor, numArgs: 3, variableArgs: false },
5091         rg: { id: OPS.setFillRGBColor, numArgs: 3, variableArgs: false },
5092         K: { id: OPS.setStrokeCMYKColor, numArgs: 4, variableArgs: false },
5093         k: { id: OPS.setFillCMYKColor, numArgs: 4, variableArgs: false },
5094 
5095         // Shading
5096         sh: { id: OPS.shadingFill, numArgs: 1, variableArgs: false },
5097 
5098         // Images
5099         BI: { id: OPS.beginInlineImage, numArgs: 0, variableArgs: false },
5100         ID: { id: OPS.beginImageData, numArgs: 0, variableArgs: false },
5101         EI: { id: OPS.endInlineImage, numArgs: 1, variableArgs: false },
5102 
5103         // XObjects
5104         Do: { id: OPS.paintXObject, numArgs: 1, variableArgs: false },
5105         MP: { id: OPS.markPoint, numArgs: 1, variableArgs: false },
5106         DP: { id: OPS.markPointProps, numArgs: 2, variableArgs: false },
5107         BMC: { id: OPS.beginMarkedContent, numArgs: 1, variableArgs: false },
5108         BDC: {
5109           id: OPS.beginMarkedContentProps,
5110           numArgs: 2,
5111           variableArgs: false,
5112         },
5113         EMC: { id: OPS.endMarkedContent, numArgs: 0, variableArgs: false },
5114 
5115         // Compatibility
5116         BX: { id: OPS.beginCompat, numArgs: 0, variableArgs: false },
5117         EX: { id: OPS.endCompat, numArgs: 0, variableArgs: false },
5118 
5119         // (reserved partial commands for the lexer)
5120         BM: null,
5121         BD: null,
5122         true: null,
5123         fa: null,
5124         fal: null,
5125         fals: null,
5126         false: null,
5127         nu: null,
5128         nul: null,
5129         null: null,
5130       })
5131     );
5132   }
5133 
5134   static MAX_INVALID_PATH_OPS = 10;
5135 
5136   constructor(stream, xref, stateManager = new StateManager()) {
5137     // TODO(mduan): pass array of knownCommands rather than this.opMap
5138     // dictionary
5139     this.parser = new Parser({
5140       lexer: new Lexer(stream, EvaluatorPreprocessor.opMap),
5141       xref,
5142     });
5143     this.stateManager = stateManager;
5144     this.nonProcessedArgs = [];
5145     this._isPathOp = false;
5146     this._numInvalidPathOPS = 0;
5147   }
5148 
5149   get savedStatesDepth() {
5150     return this.stateManager.stateStack.length;
5151   }
5152 
5153   // |operation| is an object with two fields:
5154   //
5155   // - |fn| is an out param.
5156   //
5157   // - |args| is an inout param. On entry, it should have one of two values.
5158   //
5159   //   - An empty array. This indicates that the caller is providing the
5160   //     array in which the args will be stored in. The caller should use
5161   //     this value if it can reuse a single array for each call to read().
5162   //
5163   //   - |null|. This indicates that the caller needs this function to create
5164   //     the array in which any args are stored in. If there are zero args,
5165   //     this function will leave |operation.args| as |null| (thus avoiding
5166   //     allocations that would occur if we used an empty array to represent
5167   //     zero arguments). Otherwise, it will replace |null| with a new array
5168   //     containing the arguments. The caller should use this value if it
5169   //     cannot reuse an array for each call to read().
5170   //
5171   // These two modes are present because this function is very hot and so
5172   // avoiding allocations where possible is worthwhile.
5173   //
5174   read(operation) {
5175     let args = operation.args;
5176     while (true) {
5177       const obj = this.parser.getObj();
5178       if (obj instanceof Cmd) {
5179         const cmd = obj.cmd;
5180         // Check that the command is valid
5181         const opSpec = EvaluatorPreprocessor.opMap[cmd];
5182         if (!opSpec) {
5183           warn(`Unknown command "${cmd}".`);
5184           continue;
5185         }
5186 
5187         const fn = opSpec.id;
5188         const numArgs = opSpec.numArgs;
5189         let argsLength = args !== null ? args.length : 0;
5190 
5191         // If the *previous* command wasn't a path operator, reset the heuristic
5192         // used with incomplete path operators below (fixes issue14917.pdf).
5193         if (!this._isPathOp) {
5194           this._numInvalidPathOPS = 0;
5195         }
5196         this._isPathOp = fn >= OPS.moveTo && fn <= OPS.endPath;
5197 
5198         if (!opSpec.variableArgs) {
5199           // Postscript commands can be nested, e.g. /F2 /GS2 gs 5.711 Tf
5200           if (argsLength !== numArgs) {
5201             const nonProcessedArgs = this.nonProcessedArgs;
5202             while (argsLength > numArgs) {
5203               nonProcessedArgs.push(args.shift());
5204               argsLength--;
5205             }
5206             while (argsLength < numArgs && nonProcessedArgs.length !== 0) {
5207               if (args === null) {
5208                 args = [];
5209               }
5210               args.unshift(nonProcessedArgs.pop());
5211               argsLength++;
5212             }
5213           }
5214 
5215           if (argsLength < numArgs) {
5216             const partialMsg =
5217               `command ${cmd}: expected ${numArgs} args, ` +
5218               `but received ${argsLength} args.`;
5219 
5220             // Incomplete path operators, in particular, can result in fairly
5221             // chaotic rendering artifacts. Hence the following heuristics is
5222             // used to error, rather than just warn, once a number of invalid
5223             // path operators have been encountered (fixes bug1443140.pdf).
5224             if (
5225               this._isPathOp &&
5226               ++this._numInvalidPathOPS >
5227                 EvaluatorPreprocessor.MAX_INVALID_PATH_OPS
5228             ) {
5229               throw new FormatError(`Invalid ${partialMsg}`);
5230             }
5231             // If we receive too few arguments, it's not possible to execute
5232             // the command, hence we skip the command.
5233             warn(`Skipping ${partialMsg}`);
5234             if (args !== null) {
5235               args.length = 0;
5236             }
5237             continue;
5238           }
5239         } else if (argsLength > numArgs) {
5240           info(
5241             `Command ${cmd}: expected [0, ${numArgs}] args, ` +
5242               `but received ${argsLength} args.`
5243           );
5244         }
5245 
5246         // TODO figure out how to type-check vararg functions
5247         this.preprocessCommand(fn, args);
5248 
5249         operation.fn = fn;
5250         operation.args = args;
5251         return true;
5252       }
5253       if (obj === EOF) {
5254         return false; // no more commands
5255       }
5256       // argument
5257       if (obj !== null) {
5258         if (args === null) {
5259           args = [];
5260         }
5261         args.push(obj);
5262         if (args.length > 33) {
5263           throw new FormatError("Too many arguments");
5264         }
5265       }
5266     }
5267   }
5268 
5269   preprocessCommand(fn, args) {
5270     switch (fn | 0) {
5271       case OPS.save:
5272         this.stateManager.save();
5273         break;
5274       case OPS.restore:
5275         this.stateManager.restore();
5276         break;
5277       case OPS.transform:
5278         this.stateManager.transform(args);
5279         break;
5280     }
5281   }
5282 }
5283 
5284 export { EvaluatorPreprocessor, PartialEvaluator };
</code>

Test file:
<test_file>
File:
test/unit/evaluator_spec.js
/* Copyright 2017 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import { createIdFactory, XRefMock } from "./test_utils.js";
import { Dict, Name } from "../../src/core/primitives.js";
import { FormatError, OPS } from "../../src/shared/util.js";
import { Stream, StringStream } from "../../src/core/stream.js";
import { OperatorList } from "../../src/core/operator_list.js";
import { PartialEvaluator } from "../../src/core/evaluator.js";
import { WorkerTask } from "../../src/core/worker.js";
</test_file>

Your task:
You are a software tester at pdf.js.
1. Examine the existing test file. You may reuse any imports, helpers or setup blocks it already has.
2. Write exactly one javascript test `it("...", async () => {...})` block.
3. Your test must fail on the code before the patch, and pass after, hence the test will verify that the patch resolves the issue.
4. The test must be self-contained and to-the-point.
5. If you need something new use only the provided imports (respect the paths exactly how they are given) by importing dynamically for compatibility with Node.js — no new dependencies. You can use the PDF file for testing as follows:
const { getDocument } = await import('../../src/display/api.js');
const { buildGetDocumentParams } = await import('./test_utils.js');
const loadingTask = getDocument(buildGetDocumentParams('issue19954.pdf'))
6. Return only the javascript code for the new `it(...)` block (no comments or explanations).

Example structure:
it("should <describe behavior>", async () => {
  const { example } = await import("../../src/core/example.js");
  <initialize required variables>;
  <define expected variable>;
  <generate actual variables>;
  <compare expected with actual>;
});

