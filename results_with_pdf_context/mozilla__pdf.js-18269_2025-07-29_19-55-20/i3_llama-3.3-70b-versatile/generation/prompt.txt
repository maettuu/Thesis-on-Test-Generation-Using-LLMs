Before you begin:
- Keep going until the job is completely solved — don’t stop halfway.
- If you’re unsure about the behavior, reread the provided patch carefully; do not hallucinate.
- Plan your approach before writing code by reflecting on whether the test truly fails before and passes after.

Issue:
<issue>
Fix reference test "pr12564"
In PR #18257 we have seen the following intermittent failure in the reference tests:

```
TEST-UNEXPECTED-FAIL | test failed pr12564 | in chrome | page1 round 1 | render : Error: Requesting object that isn't resolved yet img_p0_15.
```

It looks like this happened only once before, in PR #18167, which may or may not be where this problem started. We should try to reproduce the issue locally. One idea is to repeatedly open/close the file until it happens so we can hopefully extract some debugging information to find out what goes wrong here.
</issue>

Patch:
<patch>
diff --git a/src/core/evaluator.js b/src/core/evaluator.js
--- a/src/core/evaluator.js
+++ b/src/core/evaluator.js
@@ -718,6 +718,7 @@ class PartialEvaluator {
 
       if (cacheKey) {
         const cacheData = {
+          objId,
           fn: OPS.paintImageMaskXObject,
           args,
           optionalContent,
@@ -870,6 +871,7 @@ class PartialEvaluator {
 
     if (cacheKey) {
       const cacheData = {
+        objId,
         fn: OPS.paintImageXObject,
         args,
         optionalContent,
@@ -1783,6 +1785,9 @@ class PartialEvaluator {
             if (isValidName) {
               const localImage = localImageCache.getByName(name);
               if (localImage) {
+                if (localImage.objId) {
+                  operatorList.addDependency(localImage.objId);
+                }
                 operatorList.addImageOps(
                   localImage.fn,
                   localImage.args,
@@ -1807,6 +1812,9 @@ class PartialEvaluator {
                     localImageCache.getByRef(xobj) ||
                     self._regionalImageCache.getByRef(xobj);
                   if (localImage) {
+                    if (localImage.objId) {
+                      operatorList.addDependency(localImage.objId);
+                    }
                     operatorList.addImageOps(
                       localImage.fn,
                       localImage.args,
@@ -1928,6 +1936,9 @@ class PartialEvaluator {
             if (cacheKey) {
               const localImage = localImageCache.getByName(cacheKey);
               if (localImage) {
+                if (localImage.objId) {
+                  operatorList.addDependency(localImage.objId);
+                }
                 operatorList.addImageOps(
                   localImage.fn,
                   localImage.args,


</patch>

Imports:
<imports>
Available Packages
Dev Dependencies:
- @babel/core: ^7.24.7
- @babel/preset-env: ^7.24.7
- @babel/runtime: ^7.24.7
- @fluent/bundle: ^0.18.0
- @fluent/dom: ^0.9.0
- @jazzer.js/core: ^2.1.0
- @metalsmith/layouts: ^2.7.0
- @metalsmith/markdown: ^1.3.0
- autoprefixer: ^10.4.19
- babel-loader: ^9.1.3
- caniuse-lite: ^1.0.30001632
- canvas: ^2.11.2
- core-js: ^3.37.1
- cross-env: ^7.0.3
- eslint: ^8.57.0
- eslint-config-prettier: ^9.1.0
- eslint-plugin-fetch-options: ^0.0.5
- eslint-plugin-html: ^8.1.1
- eslint-plugin-import: ^2.29.1
- eslint-plugin-jasmine: ^4.1.3
- eslint-plugin-json: ^3.1.0
- eslint-plugin-mozilla: ^3.7.4
- eslint-plugin-no-unsanitized: ^4.0.2
- eslint-plugin-prettier: ^5.1.3
- eslint-plugin-sort-exports: ^0.9.1
- eslint-plugin-unicorn: ^53.0.0
- globals: ^15.4.0
- gulp: ^5.0.0
- gulp-cli: ^3.0.0
- gulp-postcss: ^10.0.0
- gulp-rename: ^2.0.0
- gulp-replace: ^1.1.4
- gulp-zip: ^6.0.0
- highlight.js: ^11.9.0
- jasmine: ^5.1.0
- jsdoc: ^4.0.3
- jstransformer-nunjucks: ^1.2.0
- metalsmith: ^2.6.3
- metalsmith-html-relative: ^2.0.1
- ordered-read-streams: ^2.0.0
- path2d: ^0.2.0
- pngjs: ^7.0.0
- postcss: ^8.4.38
- postcss-dark-theme-class: ^1.3.0
- postcss-dir-pseudo-class: ^8.0.1
- postcss-discard-comments: ^7.0.0
- postcss-nesting: ^12.1.5
- prettier: ^3.3.2
- puppeteer: ^22.10.1
- streamqueue: ^1.1.2
- stylelint: ^16.6.1
- stylelint-prettier: ^5.0.0
- terser-webpack-plugin: ^5.3.10
- tsc-alias: ^1.8.10
- ttest: ^4.0.0
- typescript: ^5.4.5
- vinyl: ^3.0.0
- webpack: ^5.91.0
- webpack-stream: ^7.0.0
- yargs: ^17.7.2

Engines:
- node: >=18

Available Relative Imports:
- `../../src/core/annotation.js`: Annotation, AnnotationBorderStyle, AnnotationFactory, MarkupAnnotation, getQuadPoints
- `../../src/core/bidi.js`: bidi
- `../../src/core/cff_parser.js`: CFFCharset, CFFCompiler, CFFFDSelect, CFFParser, CFFStrings
- `../../src/core/cmap.js`: CMap, CMapFactory, IdentityCMap
- `../../src/core/colorspace.js`: ColorSpace
- `../../src/core/core_utils.js`: arrayBuffersToBytes, encodeToXmlString, escapePDFName, escapeString, getInheritableProperty, getSizeInBytes, isAscii, isWhiteSpace, log2, numberToString, parseXFAPath, recoverJsURL, stringToUTF16HexString, stringToUTF16String, toRomanNumerals, validateCSSFont
- `../../src/core/crypto.js`: AES128Cipher, AES256Cipher, ARCFourCipher, CipherTransformFactory, PDF17, PDF20, calculateMD5, calculateSHA256, calculateSHA384, calculateSHA512
- `../../src/core/default_appearance.js`: createDefaultAppearance, parseAppearanceStream, parseDefaultAppearance
- `../../src/core/document.js`: PDFDocument, Page
- `../../src/core/encodings.js`: getEncoding
- `../../src/core/evaluator.js`: PartialEvaluator
- `../../src/core/flate_stream.js`: FlateStream
- `../../src/core/font_substitutions.js`: getFontSubstitution
- `../../src/core/fonts_utils.js`: SEAC_ANALYSIS_ENABLED
- `../../src/core/function.js`: PDFFunctionFactory, PostScriptCompiler, PostScriptEvaluator
- `../../src/core/glyphlist.js`: getDingbatsGlyphsUnicode, getGlyphsUnicode
- `../../src/core/image_utils.js`: GlobalImageCache, LocalColorSpaceCache
- `../../src/core/jbig2.js`: Jbig2Error, Jbig2Image
- `../../src/core/jpg.js`: JpegError, JpegImage
- `../../src/core/jpx.js`: JpxError, JpxImage
- `../../src/core/metadata_parser.js`: MetadataParser
- `../../src/core/operator_list.js`: OperatorList
- `../../src/core/parser.js`: Lexer, Linearization, Parser
- `../../src/core/predictor_stream.js`: PredictorStream
- `../../src/core/primitives.js`: Cmd, Dict, EOF, Name, Ref, RefSet, RefSetCache, isCmd, isDict, isName, isRefsEqual
- `../../src/core/ps_parser.js`: PostScriptLexer, PostScriptParser
- `../../src/core/stream.js`: NullStream, Stream, StringStream
- `../../src/core/type1_parser.js`: Type1Parser
- `../../src/core/unicode.js`: getCharUnicodeCategory, getUnicodeForGlyph, getUnicodeRangeFor, mapSpecialUnicodeValues
- `../../src/core/worker.js`: WorkerMessageHandler, WorkerTask
- `../../src/core/writer.js`: incrementalUpdate, writeDict
- `../../src/core/xfa/bind.js`: Binder
- `../../src/core/xfa/data.js`: DataHandler
- `../../src/core/xfa/factory.js`: XFAFactory
- `../../src/core/xfa/formcalc_lexer.js`: Lexer, TOKEN, Token
- `../../src/core/xfa/formcalc_parser.js`: Errors, Parser
- `../../src/core/xfa/parser.js`: XFAParser
- `../../src/core/xfa/som.js`: searchNode
- `../../src/core/xfa/symbol_utils.js`: $dump, $getChildren, $getChildrenByClass, $getChildrenByName, $text, $uid
- `../../src/core/xml_parser.js`: SimpleXMLParser, XMLParserBase
- `../../src/display/annotation_layer.js`: AnnotationLayer
- `../../src/display/annotation_storage.js`: AnnotationStorage
- `../../src/display/api.js`: DefaultCMapReaderFactory, DefaultCanvasFactory, DefaultStandardFontDataFactory, LoopbackPort, PDFDataRangeTransport, PDFDocumentLoadingTask, PDFDocumentProxy, PDFPageProxy, PDFWorker, PDFWorkerUtil, RenderTask, build, getDocument, version
- `../../src/display/display_utils.js`: DOMCanvasFactory, DOMSVGFactory, PDFDateString, PageViewport, PixelsPerInch, RenderingCancelledException, StatTimer, fetchData, getFilenameFromUrl, getPdfFilenameFromUrl, getXfaPageViewport, isDataScheme, isPdfFile, isValidFetchUrl, noContextMenu, setLayerDimensions
- `../../src/display/draw_layer.js`: DrawLayer
- `../../src/display/editor/annotation_editor_layer.js`: AnnotationEditorLayer
- `../../src/display/editor/color_picker.js`: ColorPicker
- `../../src/display/editor/outliner.js`: Outliner
- `../../src/display/editor/tools.js`: AnnotationEditorUIManager, CommandManager
- `../../src/display/fetch_stream.js`: PDFFetchStream
- `../../src/display/metadata.js`: Metadata
- `../../src/display/network.js`: PDFNetworkStream
- `../../src/display/network_utils.js`: createResponseStatusError, extractFilenameFromHeader, validateRangeRequestCapabilities, validateResponseStatus
- `../../src/display/node_stream.js`: PDFNodeStream
- `../../src/display/node_utils.js`: NodePackages
- `../../src/display/text_layer.js`: TextLayer, renderTextLayer, updateTextLayer
- `../../src/display/worker_options.js`: GlobalWorkerOptions
- `../../src/display/xfa_layer.js`: XfaLayer
- `../../src/shared/message_handler.js`: MessageHandler
- `../../src/shared/murmurhash3.js`: MurmurHash3_64
- `../../src/shared/util.js`: AbortException, AnnotationBorderStyleType, AnnotationEditorParamsType, AnnotationEditorType, AnnotationFieldFlag, AnnotationFlag, AnnotationMode, AnnotationType, BaseException, CMapCompressionType, FeatureTest, FormatError, ImageKind, InvalidPDFException, MissingPDFException, OPS, PasswordException, PasswordResponses, PermissionFlag, RenderingIntentFlag, UnexpectedResponseException, UnknownErrorException, Util, VerbosityLevel, assert, bytesToString, createValidAbsoluteUrl, getModificationDate, getVerbosityLevel, isNodeJS, normalizeUnicode, objectSize, setVerbosityLevel, shadow, string32, stringToBytes, stringToPDFString, stringToUTF8String
- `../../web/annotation_layer_builder.js`: AnnotationLayerBuilder
- `../../web/app_options.js`: AppOptions, OptionKind
- `../../web/download_manager.js`: DownloadManager
- `../../web/event_utils.js`: EventBus, WaitOnType, waitOnEventOrTimeout
- `../../web/genericl10n.js`: GenericL10n
- `../../web/pdf_find_controller.js`: FindState, PDFFindController
- `../../web/pdf_find_utils.js`: CharacterType, getCharacterType
- `../../web/pdf_history.js`: PDFHistory, isDestArraysEqual, isDestHashesEqual
- `../../web/pdf_link_service.js`: LinkTarget, PDFLinkService, SimpleLinkService
- `../../web/pdf_page_view.js`: PDFPageView
- `../../web/pdf_scripting_manager.component.js`: PDFScriptingManager
- `../../web/pdf_single_page_viewer.js`: PDFSinglePageViewer
- `../../web/pdf_viewer.js`: PDFPageViewBuffer, PDFViewer
- `../../web/struct_tree_layer_builder.js`: StructTreeLayerBuilder
- `../../web/text_layer_builder.js`: TextLayerBuilder
- `../../web/ui_utils.js`: AutoPrintRegExp, ProgressBar, RenderingStates, ScrollMode, SpreadMode, backtrackBeforeAllVisibleElements, binarySearchFirstItem, getPageSizeInches, getVisibleElements, isPortraitOrientation, isValidRotation, parseQueryString, removeNullCharacters
- `../../web/xfa_layer_builder.js`: XfaLayerBuilder
- `./test_utils.js`: CMAP_URL, DefaultFileReaderFactory, STANDARD_FONT_DATA_URL, TEST_PDFS_PATH, XRefMock, buildGetDocumentParams, createIdFactory, createTemporaryNodeServer
- `./testreporter.js`: TestReporter
</imports>

Code:
<code>
File:
src/core/evaluator.js
1 /* Copyright 2012 Mozilla Foundation
2  *
3  * Licensed under the Apache License, Version 2.0 (the "License");
4  * you may not use this file except in compliance with the License.
5  * You may obtain a copy of the License at
6  *
7  *     http://www.apache.org/licenses/LICENSE-2.0
8  *
9  * Unless required by applicable law or agreed to in writing, software
10  * distributed under the License is distributed on an "AS IS" BASIS,
11  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
12  * See the License for the specific language governing permissions and
13  * limitations under the License.
14  */
15 /* eslint-disable no-var */
16 
17 import {
18   AbortException,
19   assert,
20   CMapCompressionType,
21   FONT_IDENTITY_MATRIX,
22   FormatError,
23   IDENTITY_MATRIX,
24   info,
25   isArrayEqual,
26   normalizeUnicode,
27   OPS,
28   shadow,
29   stringToPDFString,
30   TextRenderingMode,
31   Util,
32   warn,
33 } from "../shared/util.js";
34 import { CMapFactory, IdentityCMap } from "./cmap.js";
35 import { Cmd, Dict, EOF, isName, Name, Ref, RefSet } from "./primitives.js";
36 import { ErrorFont, Font } from "./fonts.js";
37 import {
38   getEncoding,
39   MacRomanEncoding,
40   StandardEncoding,
41   SymbolSetEncoding,
42   WinAnsiEncoding,
43   ZapfDingbatsEncoding,
44 } from "./encodings.js";
45 import {
46   getFontNameToFileMap,
47   getSerifFonts,
48   getStandardFontName,
49   getStdFontMap,
50   getSymbolsFonts,
51   isKnownFontName,
52 } from "./standard_fonts.js";
53 import { getTilingPatternIR, Pattern } from "./pattern.js";
54 import { getXfaFontDict, getXfaFontName } from "./xfa_fonts.js";
55 import { IdentityToUnicodeMap, ToUnicodeMap } from "./to_unicode_map.js";
56 import { isNumberArray, lookupMatrix, lookupNormalRect } from "./core_utils.js";
57 import { isPDFFunction, PDFFunctionFactory } from "./function.js";
58 import { Lexer, Parser } from "./parser.js";
59 import {
60   LocalColorSpaceCache,
61   LocalGStateCache,
62   LocalImageCache,
63   LocalTilingPatternCache,
64   RegionalImageCache,
65 } from "./image_utils.js";
66 import { NullStream, Stream } from "./stream.js";
67 import { BaseStream } from "./base_stream.js";
68 import { bidi } from "./bidi.js";
69 import { ColorSpace } from "./colorspace.js";
70 import { DecodeStream } from "./decode_stream.js";
71 import { FontFlags } from "./fonts_utils.js";
72 import { getFontSubstitution } from "./font_substitutions.js";
73 import { getGlyphsUnicode } from "./glyphlist.js";
74 import { getMetrics } from "./metrics.js";
75 import { getUnicodeForGlyph } from "./unicode.js";
76 import { ImageResizer } from "./image_resizer.js";
77 import { MurmurHash3_64 } from "../shared/murmurhash3.js";
78 import { OperatorList } from "./operator_list.js";
79 import { PDFImage } from "./image.js";
80 
81 const DefaultPartialEvaluatorOptions = Object.freeze({
82   maxImageSize: -1,
83   disableFontFace: false,
84   ignoreErrors: false,
85   isEvalSupported: true,
86   isOffscreenCanvasSupported: false,
87   canvasMaxAreaInBytes: -1,
88   fontExtraProperties: false,
89   useSystemFonts: true,
90   cMapUrl: null,
91   standardFontDataUrl: null,
92 });
93 
94 const PatternType = {
95   TILING: 1,
96   SHADING: 2,
97 };
98 
99 // Optionally avoid sending individual, or very few, text chunks to reduce
100 // `postMessage` overhead with ReadableStream (see issue 13962).
101 //
102 // PLEASE NOTE: This value should *not* be too large (it's used as a lower limit
103 // in `enqueueChunk`), since that would cause streaming of textContent to become
104 // essentially useless in practice by sending all (or most) chunks at once.
105 // Also, a too large value would (indirectly) affect the main-thread `textLayer`
106 // building negatively by forcing all textContent to be handled at once, which
107 // could easily end up hurting *overall* performance (e.g. rendering as well).
108 const TEXT_CHUNK_BATCH_SIZE = 10;
109 
110 const deferred = Promise.resolve();
111 
112 // Convert PDF blend mode names to HTML5 blend mode names.
113 function normalizeBlendMode(value, parsingArray = false) {
114   if (Array.isArray(value)) {
115     // Use the first *supported* BM value in the Array (fixes issue11279.pdf).
116     for (const val of value) {
117       const maybeBM = normalizeBlendMode(val, /* parsingArray = */ true);
118       if (maybeBM) {
119         return maybeBM;
120       }
121     }
122     warn(`Unsupported blend mode Array: ${value}`);
123     return "source-over";
124   }
125 
126   if (!(value instanceof Name)) {
127     if (parsingArray) {
128       return null;
129     }
130     return "source-over";
131   }
132   switch (value.name) {
133     case "Normal":
134     case "Compatible":
135       return "source-over";
136     case "Multiply":
137       return "multiply";
138     case "Screen":
139       return "screen";
140     case "Overlay":
141       return "overlay";
142     case "Darken":
143       return "darken";
144     case "Lighten":
145       return "lighten";
146     case "ColorDodge":
147       return "color-dodge";
148     case "ColorBurn":
149       return "color-burn";
150     case "HardLight":
151       return "hard-light";
152     case "SoftLight":
153       return "soft-light";
154     case "Difference":
155       return "difference";
156     case "Exclusion":
157       return "exclusion";
158     case "Hue":
159       return "hue";
160     case "Saturation":
161       return "saturation";
162     case "Color":
163       return "color";
164     case "Luminosity":
165       return "luminosity";
166   }
167   if (parsingArray) {
168     return null;
169   }
170   warn(`Unsupported blend mode: ${value.name}`);
171   return "source-over";
172 }
173 
174 function incrementCachedImageMaskCount(data) {
175   if (data.fn === OPS.paintImageMaskXObject && data.args[0]?.count > 0) {
176     data.args[0].count++;
177   }
178 }
179 
180 // Trying to minimize Date.now() usage and check every 100 time.
181 class TimeSlotManager {
182   static TIME_SLOT_DURATION_MS = 20;
183 
184   static CHECK_TIME_EVERY = 100;
185 
186   constructor() {
187     this.reset();
188   }
189 
190   check() {
191     if (++this.checked < TimeSlotManager.CHECK_TIME_EVERY) {
192       return false;
193     }
194     this.checked = 0;
195     return this.endTime <= Date.now();
196   }
197 
198   reset() {
199     this.endTime = Date.now() + TimeSlotManager.TIME_SLOT_DURATION_MS;
200     this.checked = 0;
201   }
202 }
203 
204 class PartialEvaluator {
205   constructor({
206     xref,
207     handler,
208     pageIndex,
209     idFactory,
210     fontCache,
211     builtInCMapCache,
212     standardFontDataCache,
213     globalImageCache,
214     systemFontCache,
215     options = null,
216   }) {
217     this.xref = xref;
218     this.handler = handler;
219     this.pageIndex = pageIndex;
220     this.idFactory = idFactory;
221     this.fontCache = fontCache;
222     this.builtInCMapCache = builtInCMapCache;
223     this.standardFontDataCache = standardFontDataCache;
224     this.globalImageCache = globalImageCache;
225     this.systemFontCache = systemFontCache;
226     this.options = options || DefaultPartialEvaluatorOptions;
227     this.type3FontRefs = null;
228 
229     this._regionalImageCache = new RegionalImageCache();
230     this._fetchBuiltInCMapBound = this.fetchBuiltInCMap.bind(this);
231     ImageResizer.setMaxArea(this.options.canvasMaxAreaInBytes);
232   }
233 
234   /**
235    * Since Functions are only cached (locally) by reference, we can share one
236    * `PDFFunctionFactory` instance within this `PartialEvaluator` instance.
237    */
238   get _pdfFunctionFactory() {
239     const pdfFunctionFactory = new PDFFunctionFactory({
240       xref: this.xref,
241       isEvalSupported: this.options.isEvalSupported,
242     });
243     return shadow(this, "_pdfFunctionFactory", pdfFunctionFactory);
244   }
245 
246   get parsingType3Font() {
247     return !!this.type3FontRefs;
248   }
249 
250   clone(newOptions = null) {
251     const newEvaluator = Object.create(this);
252     newEvaluator.options = Object.assign(
253       Object.create(null),
254       this.options,
255       newOptions
256     );
257     return newEvaluator;
258   }
259 
260   hasBlendModes(resources, nonBlendModesSet) {
261     if (!(resources instanceof Dict)) {
262       return false;
263     }
264     if (resources.objId && nonBlendModesSet.has(resources.objId)) {
265       return false;
266     }
267 
268     const processed = new RefSet(nonBlendModesSet);
269     if (resources.objId) {
270       processed.put(resources.objId);
271     }
272 
273     const nodes = [resources],
274       xref = this.xref;
275     while (nodes.length) {
276       const node = nodes.shift();
277       // First check the current resources for blend modes.
278       const graphicStates = node.get("ExtGState");
279       if (graphicStates instanceof Dict) {
280         for (let graphicState of graphicStates.getRawValues()) {
281           if (graphicState instanceof Ref) {
282             if (processed.has(graphicState)) {
283               continue; // The ExtGState has already been processed.
284             }
285             try {
286               graphicState = xref.fetch(graphicState);
287             } catch (ex) {
288               // Avoid parsing a corrupt ExtGState more than once.
289               processed.put(graphicState);
290 
291               info(`hasBlendModes - ignoring ExtGState: "${ex}".`);
292               continue;
293             }
294           }
295           if (!(graphicState instanceof Dict)) {
296             continue;
297           }
298           if (graphicState.objId) {
299             processed.put(graphicState.objId);
300           }
301 
302           const bm = graphicState.get("BM");
303           if (bm instanceof Name) {
304             if (bm.name !== "Normal") {
305               return true;
306             }
307             continue;
308           }
309           if (bm !== undefined && Array.isArray(bm)) {
310             for (const element of bm) {
311               if (element instanceof Name && element.name !== "Normal") {
312                 return true;
313               }
314             }
315           }
316         }
317       }
318       // Descend into the XObjects to look for more resources and blend modes.
319       const xObjects = node.get("XObject");
320       if (!(xObjects instanceof Dict)) {
321         continue;
322       }
323       for (let xObject of xObjects.getRawValues()) {
324         if (xObject instanceof Ref) {
325           if (processed.has(xObject)) {
326             // The XObject has already been processed, and by avoiding a
327             // redundant `xref.fetch` we can *significantly* reduce the load
328             // time for badly generated PDF files (fixes issue6961.pdf).
329             continue;
330           }
331           try {
332             xObject = xref.fetch(xObject);
333           } catch (ex) {
334             // Avoid parsing a corrupt XObject more than once.
335             processed.put(xObject);
336 
337             info(`hasBlendModes - ignoring XObject: "${ex}".`);
338             continue;
339           }
340         }
341         if (!(xObject instanceof BaseStream)) {
342           continue;
343         }
344         if (xObject.dict.objId) {
345           processed.put(xObject.dict.objId);
346         }
347         const xResources = xObject.dict.get("Resources");
348         if (!(xResources instanceof Dict)) {
349           continue;
350         }
351         // Checking objId to detect an infinite loop.
352         if (xResources.objId && processed.has(xResources.objId)) {
353           continue;
354         }
355 
356         nodes.push(xResources);
357         if (xResources.objId) {
358           processed.put(xResources.objId);
359         }
360       }
361     }
362 
363     // When no blend modes exist, there's no need re-fetch/re-parse any of the
364     // processed `Ref`s again for subsequent pages. This helps reduce redundant
365     // `XRef.fetch` calls for some documents (e.g. issue6961.pdf).
366     for (const ref of processed) {
367       nonBlendModesSet.put(ref);
368     }
369     return false;
370   }
371 
372   async fetchBuiltInCMap(name) {
373     const cachedData = this.builtInCMapCache.get(name);
374     if (cachedData) {
375       return cachedData;
376     }
377     let data;
378 
379     if (this.options.cMapUrl !== null) {
380       // Only compressed CMaps are (currently) supported here.
381       const url = `${this.options.cMapUrl}${name}.bcmap`;
382       const response = await fetch(url);
383       if (!response.ok) {
384         throw new Error(
385           `fetchBuiltInCMap: failed to fetch file "${url}" with "${response.statusText}".`
386         );
387       }
388       data = {
389         cMapData: new Uint8Array(await response.arrayBuffer()),
390         compressionType: CMapCompressionType.BINARY,
391       };
392     } else {
393       // Get the data on the main-thread instead.
394       data = await this.handler.sendWithPromise("FetchBuiltInCMap", { name });
395     }
396 
397     if (data.compressionType !== CMapCompressionType.NONE) {
398       // Given the size of uncompressed CMaps, only cache compressed ones.
399       this.builtInCMapCache.set(name, data);
400     }
401     return data;
402   }
403 
404   async fetchStandardFontData(name) {
405     const cachedData = this.standardFontDataCache.get(name);
406     if (cachedData) {
407       return new Stream(cachedData);
408     }
409 
410     // The symbol fonts are not consistent across platforms, always load the
411     // standard font data for them.
412     if (
413       this.options.useSystemFonts &&
414       name !== "Symbol" &&
415       name !== "ZapfDingbats"
416     ) {
417       return null;
418     }
419 
420     const standardFontNameToFileName = getFontNameToFileMap(),
421       filename = standardFontNameToFileName[name];
422     let data;
423 
424     if (this.options.standardFontDataUrl !== null) {
425       const url = `${this.options.standardFontDataUrl}${filename}`;
426       const response = await fetch(url);
427       if (!response.ok) {
428         warn(
429           `fetchStandardFontData: failed to fetch file "${url}" with "${response.statusText}".`
430         );
431       } else {
432         data = new Uint8Array(await response.arrayBuffer());
433       }
434     } else {
435       // Get the data on the main-thread instead.
436       try {
437         data = await this.handler.sendWithPromise("FetchStandardFontData", {
438           filename,
439         });
440       } catch (e) {
441         warn(
442           `fetchStandardFontData: failed to fetch file "${filename}" with "${e}".`
443         );
444       }
445     }
446 
447     if (!data) {
448       return null;
449     }
450     // Cache the "raw" standard font data, to avoid fetching it repeatedly
451     // (see e.g. issue 11399).
452     this.standardFontDataCache.set(name, data);
453 
454     return new Stream(data);
455   }
456 
457   async buildFormXObject(
458     resources,
459     xobj,
460     smask,
461     operatorList,
462     task,
463     initialState,
464     localColorSpaceCache
465   ) {
466     const dict = xobj.dict;
467     const matrix = lookupMatrix(dict.getArray("Matrix"), null);
468     const bbox = lookupNormalRect(dict.getArray("BBox"), null);
469 
470     let optionalContent, groupOptions;
471     if (dict.has("OC")) {
472       optionalContent = await this.parseMarkedContentProps(
473         dict.get("OC"),
474         resources
475       );
476     }
477     if (optionalContent !== undefined) {
478       operatorList.addOp(OPS.beginMarkedContentProps, ["OC", optionalContent]);
479     }
480     const group = dict.get("Group");
481     if (group) {
482       groupOptions = {
483         matrix,
484         bbox,
485         smask,
486         isolated: false,
487         knockout: false,
488       };
489 
490       const groupSubtype = group.get("S");
491       let colorSpace = null;
492       if (isName(groupSubtype, "Transparency")) {
493         groupOptions.isolated = group.get("I") || false;
494         groupOptions.knockout = group.get("K") || false;
495         if (group.has("CS")) {
496           const cs = group.getRaw("CS");
497 
498           const cachedColorSpace = ColorSpace.getCached(
499             cs,
500             this.xref,
501             localColorSpaceCache
502           );
503           if (cachedColorSpace) {
504             colorSpace = cachedColorSpace;
505           } else {
506             colorSpace = await this.parseColorSpace({
507               cs,
508               resources,
509               localColorSpaceCache,
510             });
511           }
512         }
513       }
514 
515       if (smask?.backdrop) {
516         colorSpace ||= ColorSpace.singletons.rgb;
517         smask.backdrop = colorSpace.getRgb(smask.backdrop, 0);
518       }
519 
520       operatorList.addOp(OPS.beginGroup, [groupOptions]);
521     }
522 
523     // If it's a group, a new canvas will be created that is the size of the
524     // bounding box and translated to the correct position so we don't need to
525     // apply the bounding box to it.
526     const args = group ? [matrix, null] : [matrix, bbox];
527     operatorList.addOp(OPS.paintFormXObjectBegin, args);
528 
529     await this.getOperatorList({
530       stream: xobj,
531       task,
532       resources: dict.get("Resources") || resources,
533       operatorList,
534       initialState,
535     });
536     operatorList.addOp(OPS.paintFormXObjectEnd, []);
537 
538     if (group) {
539       operatorList.addOp(OPS.endGroup, [groupOptions]);
540     }
541 
542     if (optionalContent !== undefined) {
543       operatorList.addOp(OPS.endMarkedContent, []);
544     }
545   }
546 
547   _sendImgData(objId, imgData, cacheGlobally = false) {
548     if (
549       (typeof PDFJSDev === "undefined" || PDFJSDev.test("TESTING")) &&
550       imgData
551     ) {
552       assert(Number.isInteger(imgData.dataLen), "Expected dataLen to be set.");
553     }
554     const transfers = imgData ? [imgData.bitmap || imgData.data.buffer] : null;
555 
556     if (this.parsingType3Font || cacheGlobally) {
557       return this.handler.send(
558         "commonobj",
559         [objId, "Image", imgData],
560         transfers
561       );
562     }
563     return this.handler.send(
564       "obj",
565       [objId, this.pageIndex, "Image", imgData],
566       transfers
567     );
568   }
569 
570   async buildPaintImageXObject({
571     resources,
572     image,
573     isInline = false,
574     operatorList,
575     cacheKey,
576     localImageCache,
577     localColorSpaceCache,
578   }) {
579     const dict = image.dict;
580     const imageRef = dict.objId;
581     const w = dict.get("W", "Width");
582     const h = dict.get("H", "Height");
583 
584     if (!(w && typeof w === "number") || !(h && typeof h === "number")) {
585       warn("Image dimensions are missing, or not numbers.");
586       return;
587     }
588     const maxImageSize = this.options.maxImageSize;
589     if (maxImageSize !== -1 && w * h > maxImageSize) {
590       const msg = "Image exceeded maximum allowed size and was removed.";
591 
592       if (this.options.ignoreErrors) {
593         warn(msg);
594         return;
595       }
596       throw new Error(msg);
597     }
598 
599     let optionalContent;
600     if (dict.has("OC")) {
601       optionalContent = await this.parseMarkedContentProps(
602         dict.get("OC"),
603         resources
604       );
605     }
606 
607     const imageMask = dict.get("IM", "ImageMask") || false;
608     let imgData, args;
609     if (imageMask) {
610       // This depends on a tmpCanvas being filled with the
611       // current fillStyle, such that processing the pixel
612       // data can't be done here. Instead of creating a
613       // complete PDFImage, only read the information needed
614       // for later.
615       const interpolate = dict.get("I", "Interpolate");
616       const bitStrideLength = (w + 7) >> 3;
617       const imgArray = image.getBytes(bitStrideLength * h);
618       const decode = dict.getArray("D", "Decode");
619 
620       if (this.parsingType3Font) {
621         imgData = PDFImage.createRawMask({
622           imgArray,
623           width: w,
624           height: h,
625           imageIsFromDecodeStream: image instanceof DecodeStream,
626           inverseDecode: decode?.[0] > 0,
627           interpolate,
628         });
629 
630         imgData.cached = !!cacheKey;
631         args = [imgData];
632 
633         operatorList.addImageOps(
634           OPS.paintImageMaskXObject,
635           args,
636           optionalContent
637         );
638 
639         if (cacheKey) {
640           const cacheData = {
641             fn: OPS.paintImageMaskXObject,
642             args,
643             optionalContent,
644           };
645           localImageCache.set(cacheKey, imageRef, cacheData);
646 
647           if (imageRef) {
648             this._regionalImageCache.set(
649               /* name = */ null,
650               imageRef,
651               cacheData
652             );
653           }
654         }
655         return;
656       }
657 
658       imgData = await PDFImage.createMask({
659         imgArray,
660         width: w,
661         height: h,
662         imageIsFromDecodeStream: image instanceof DecodeStream,
663         inverseDecode: decode?.[0] > 0,
664         interpolate,
665         isOffscreenCanvasSupported: this.options.isOffscreenCanvasSupported,
666       });
667 
668       if (imgData.isSingleOpaquePixel) {
669         // Handles special case of mainly LaTeX documents which use image
670         // masks to draw lines with the current fill style.
671         operatorList.addImageOps(
672           OPS.paintSolidColorImageMask,
673           [],
674           optionalContent
675         );
676 
677         if (cacheKey) {
678           const cacheData = {
679             fn: OPS.paintSolidColorImageMask,
680             args: [],
681             optionalContent,
682           };
683           localImageCache.set(cacheKey, imageRef, cacheData);
684 
685           if (imageRef) {
686             this._regionalImageCache.set(
687               /* name = */ null,
688               imageRef,
689               cacheData
690             );
691           }
692         }
693         return;
694       }
695 
696       const objId = `mask_${this.idFactory.createObjId()}`;
697       operatorList.addDependency(objId);
698 
699       imgData.dataLen = imgData.bitmap
700         ? imgData.width * imgData.height * 4
701         : imgData.data.length;
702       this._sendImgData(objId, imgData);
703 
704       args = [
705         {
706           data: objId,
707           width: imgData.width,
708           height: imgData.height,
709           interpolate: imgData.interpolate,
710           count: 1,
711         },
712       ];
713       operatorList.addImageOps(
714         OPS.paintImageMaskXObject,
715         args,
716         optionalContent
717       );
718 
719       if (cacheKey) {
720         const cacheData = {
721           fn: OPS.paintImageMaskXObject,
722           args,
723           optionalContent,
724         };
725         localImageCache.set(cacheKey, imageRef, cacheData);
726 
727         if (imageRef) {
728           this._regionalImageCache.set(/* name = */ null, imageRef, cacheData);
729         }
730       }
731       return;
732     }
733 
734     const SMALL_IMAGE_DIMENSIONS = 200;
735     // Inlining small images into the queue as RGB data
736     if (
737       isInline &&
738       w + h < SMALL_IMAGE_DIMENSIONS &&
739       !dict.has("SMask") &&
740       !dict.has("Mask")
741     ) {
742       try {
743         const imageObj = new PDFImage({
744           xref: this.xref,
745           res: resources,
746           image,
747           isInline,
748           pdfFunctionFactory: this._pdfFunctionFactory,
749           localColorSpaceCache,
750         });
751         // We force the use of RGBA_32BPP images here, because we can't handle
752         // any other kind.
753         imgData = await imageObj.createImageData(
754           /* forceRGBA = */ true,
755           /* isOffscreenCanvasSupported = */ false
756         );
757         operatorList.isOffscreenCanvasSupported =
758           this.options.isOffscreenCanvasSupported;
759         operatorList.addImageOps(
760           OPS.paintInlineImageXObject,
761           [imgData],
762           optionalContent
763         );
764       } catch (reason) {
765         const msg = `Unable to decode inline image: "${reason}".`;
766 
767         if (!this.options.ignoreErrors) {
768           throw new Error(msg);
769         }
770         warn(msg);
771       }
772       return;
773     }
774 
775     // If there is no imageMask, create the PDFImage and a lot
776     // of image processing can be done here.
777     let objId = `img_${this.idFactory.createObjId()}`,
778       cacheGlobally = false;
779 
780     if (this.parsingType3Font) {
781       objId = `${this.idFactory.getDocId()}_type3_${objId}`;
782     } else if (cacheKey && imageRef) {
783       cacheGlobally = this.globalImageCache.shouldCache(
784         imageRef,
785         this.pageIndex
786       );
787 
788       if (cacheGlobally) {
789         assert(!isInline, "Cannot cache an inline image globally.");
790 
791         objId = `${this.idFactory.getDocId()}_${objId}`;
792       }
793     }
794 
795     // Ensure that the dependency is added before the image is decoded.
796     operatorList.addDependency(objId);
797     args = [objId, w, h];
798     operatorList.addImageOps(OPS.paintImageXObject, args, optionalContent);
799 
800     if (cacheGlobally) {
801       if (this.globalImageCache.hasDecodeFailed(imageRef)) {
802         this.globalImageCache.setData(imageRef, {
803           objId,
804           fn: OPS.paintImageXObject,
805           args,
806           optionalContent,
807           byteSize: 0, // Data is `null`, since decoding failed previously.
808         });
809 
810         this._sendImgData(objId, /* imgData = */ null, cacheGlobally);
811         return;
812       }
813 
814       // For large (at least 500x500) or more complex images that we'll cache
815       // globally, check if the image is still cached locally on the main-thread
816       // to avoid having to re-parse the image (since that can be slow).
817       if (w * h > 250000 || dict.has("SMask") || dict.has("Mask")) {
818         const localLength = await this.handler.sendWithPromise("commonobj", [
819           objId,
820           "CopyLocalImage",
821           { imageRef },
822         ]);
823 
824         if (localLength) {
825           this.globalImageCache.setData(imageRef, {
826             objId,
827             fn: OPS.paintImageXObject,
828             args,
829             optionalContent,
830             byteSize: 0, // Temporary entry, to avoid `setData` returning early.
831           });
832           this.globalImageCache.addByteSize(imageRef, localLength);
833           return;
834         }
835       }
836     }
837 
838     PDFImage.buildImage({
839       xref: this.xref,
840       res: resources,
841       image,
842       isInline,
843       pdfFunctionFactory: this._pdfFunctionFactory,
844       localColorSpaceCache,
845     })
846       .then(async imageObj => {
847         imgData = await imageObj.createImageData(
848           /* forceRGBA = */ false,
849           /* isOffscreenCanvasSupported = */ this.options
850             .isOffscreenCanvasSupported
851         );
852         imgData.dataLen = imgData.bitmap
853           ? imgData.width * imgData.height * 4
854           : imgData.data.length;
855         imgData.ref = imageRef;
856 
857         if (cacheGlobally) {
858           this.globalImageCache.addByteSize(imageRef, imgData.dataLen);
859         }
860         return this._sendImgData(objId, imgData, cacheGlobally);
861       })
862       .catch(reason => {
863         warn(`Unable to decode image "${objId}": "${reason}".`);
864 
865         if (imageRef) {
866           this.globalImageCache.addDecodeFailed(imageRef);
867         }
868         return this._sendImgData(objId, /* imgData = */ null, cacheGlobally);
869       });
870 
871     if (cacheKey) {
872       const cacheData = {
873         fn: OPS.paintImageXObject,
874         args,
875         optionalContent,
876       };
877       localImageCache.set(cacheKey, imageRef, cacheData);
878 
879       if (imageRef) {
880         this._regionalImageCache.set(/* name = */ null, imageRef, cacheData);
881 
882         if (cacheGlobally) {
883           this.globalImageCache.setData(imageRef, {
884             objId,
885             fn: OPS.paintImageXObject,
886             args,
887             optionalContent,
888             byteSize: 0, // Temporary entry, note `addByteSize` above.
889           });
890         }
891       }
892     }
893   }
894 
895   handleSMask(
896     smask,
897     resources,
898     operatorList,
899     task,
900     stateManager,
901     localColorSpaceCache
902   ) {
903     const smaskContent = smask.get("G");
904     const smaskOptions = {
905       subtype: smask.get("S").name,
906       backdrop: smask.get("BC"),
907     };
908 
909     // The SMask might have a alpha/luminosity value transfer function --
910     // we will build a map of integer values in range 0..255 to be fast.
911     const transferObj = smask.get("TR");
912     if (isPDFFunction(transferObj)) {
913       const transferFn = this._pdfFunctionFactory.create(transferObj);
914       const transferMap = new Uint8Array(256);
915       const tmp = new Float32Array(1);
916       for (let i = 0; i < 256; i++) {
917         tmp[0] = i / 255;
918         transferFn(tmp, 0, tmp, 0);
919         transferMap[i] = (tmp[0] * 255) | 0;
920       }
921       smaskOptions.transferMap = transferMap;
922     }
923 
924     return this.buildFormXObject(
925       resources,
926       smaskContent,
927       smaskOptions,
928       operatorList,
929       task,
930       stateManager.state.clone(),
931       localColorSpaceCache
932     );
933   }
934 
935   handleTransferFunction(tr) {
936     let transferArray;
937     if (Array.isArray(tr)) {
938       transferArray = tr;
939     } else if (isPDFFunction(tr)) {
940       transferArray = [tr];
941     } else {
942       return null; // Not a valid transfer function entry.
943     }
944 
945     const transferMaps = [];
946     let numFns = 0,
947       numEffectfulFns = 0;
948     for (const entry of transferArray) {
949       const transferObj = this.xref.fetchIfRef(entry);
950       numFns++;
951 
952       if (isName(transferObj, "Identity")) {
953         transferMaps.push(null);
954         continue;
955       } else if (!isPDFFunction(transferObj)) {
956         return null; // Not a valid transfer function object.
957       }
958 
959       const transferFn = this._pdfFunctionFactory.create(transferObj);
960       const transferMap = new Uint8Array(256),
961         tmp = new Float32Array(1);
962       for (let j = 0; j < 256; j++) {
963         tmp[0] = j / 255;
964         transferFn(tmp, 0, tmp, 0);
965         transferMap[j] = (tmp[0] * 255) | 0;
966       }
967       transferMaps.push(transferMap);
968       numEffectfulFns++;
969     }
970 
971     if (!(numFns === 1 || numFns === 4)) {
972       return null; // Only 1 or 4 functions are supported, by the specification.
973     }
974     if (numEffectfulFns === 0) {
975       return null; // Only /Identity transfer functions found, which are no-ops.
976     }
977     return transferMaps;
978   }
979 
980   handleTilingType(
981     fn,
982     color,
983     resources,
984     pattern,
985     patternDict,
986     operatorList,
987     task,
988     localTilingPatternCache
989   ) {
990     // Create an IR of the pattern code.
991     const tilingOpList = new OperatorList();
992     // Merge the available resources, to prevent issues when the patternDict
993     // is missing some /Resources entries (fixes issue6541.pdf).
994     const patternResources = Dict.merge({
995       xref: this.xref,
996       dictArray: [patternDict.get("Resources"), resources],
997     });
998 
999     return this.getOperatorList({
1000       stream: pattern,
1001       task,
1002       resources: patternResources,
1003       operatorList: tilingOpList,
1004     })
1005       .then(function () {
1006         const operatorListIR = tilingOpList.getIR();
1007         const tilingPatternIR = getTilingPatternIR(
1008           operatorListIR,
1009           patternDict,
1010           color
1011         );
1012         // Add the dependencies to the parent operator list so they are
1013         // resolved before the sub operator list is executed synchronously.
1014         operatorList.addDependencies(tilingOpList.dependencies);
1015         operatorList.addOp(fn, tilingPatternIR);
1016 
1017         if (patternDict.objId) {
1018           localTilingPatternCache.set(/* name = */ null, patternDict.objId, {
1019             operatorListIR,
1020             dict: patternDict,
1021           });
1022         }
1023       })
1024       .catch(reason => {
1025         if (reason instanceof AbortException) {
1026           return;
1027         }
1028         if (this.options.ignoreErrors) {
1029           warn(`handleTilingType - ignoring pattern: "${reason}".`);
1030           return;
1031         }
1032         throw reason;
1033       });
1034   }
1035 
1036   async handleSetFont(
1037     resources,
1038     fontArgs,
1039     fontRef,
1040     operatorList,
1041     task,
1042     state,
1043     fallbackFontDict = null,
1044     cssFontInfo = null
1045   ) {
1046     const fontName = fontArgs?.[0] instanceof Name ? fontArgs[0].name : null;
1047 
1048     let translated = await this.loadFont(
1049       fontName,
1050       fontRef,
1051       resources,
1052       fallbackFontDict,
1053       cssFontInfo
1054     );
1055 
1056     if (translated.font.isType3Font) {
1057       try {
1058         await translated.loadType3Data(this, resources, task);
1059         // Add the dependencies to the parent operatorList so they are
1060         // resolved before Type3 operatorLists are executed synchronously.
1061         operatorList.addDependencies(translated.type3Dependencies);
1062       } catch (reason) {
1063         translated = new TranslatedFont({
1064           loadedName: "g_font_error",
1065           font: new ErrorFont(`Type3 font load error: ${reason}`),
1066           dict: translated.font,
1067           evaluatorOptions: this.options,
1068         });
1069       }
1070     }
1071 
1072     state.font = translated.font;
1073     translated.send(this.handler);
1074     return translated.loadedName;
1075   }
1076 
1077   handleText(chars, state) {
1078     const font = state.font;
1079     const glyphs = font.charsToGlyphs(chars);
1080 
1081     if (font.data) {
1082       const isAddToPathSet = !!(
1083         state.textRenderingMode & TextRenderingMode.ADD_TO_PATH_FLAG
1084       );
1085       if (
1086         isAddToPathSet ||
1087         state.fillColorSpace.name === "Pattern" ||
1088         font.disableFontFace ||
1089         this.options.disableFontFace
1090       ) {
1091         PartialEvaluator.buildFontPaths(
1092           font,
1093           glyphs,
1094           this.handler,
1095           this.options
1096         );
1097       }
1098     }
1099     return glyphs;
1100   }
1101 
1102   ensureStateFont(state) {
1103     if (state.font) {
1104       return;
1105     }
1106     const reason = new FormatError(
1107       "Missing setFont (Tf) operator before text rendering operator."
1108     );
1109 
1110     if (this.options.ignoreErrors) {
1111       warn(`ensureStateFont: "${reason}".`);
1112       return;
1113     }
1114     throw reason;
1115   }
1116 
1117   async setGState({
1118     resources,
1119     gState,
1120     operatorList,
1121     cacheKey,
1122     task,
1123     stateManager,
1124     localGStateCache,
1125     localColorSpaceCache,
1126   }) {
1127     const gStateRef = gState.objId;
1128     let isSimpleGState = true;
1129     // This array holds the converted/processed state data.
1130     const gStateObj = [];
1131     let promise = Promise.resolve();
1132     for (const key of gState.getKeys()) {
1133       const value = gState.get(key);
1134       switch (key) {
1135         case "Type":
1136           break;
1137         case "LW":
1138         case "LC":
1139         case "LJ":
1140         case "ML":
1141         case "D":
1142         case "RI":
1143         case "FL":
1144         case "CA":
1145         case "ca":
1146           gStateObj.push([key, value]);
1147           break;
1148         case "Font":
1149           isSimpleGState = false;
1150 
1151           promise = promise.then(() =>
1152             this.handleSetFont(
1153               resources,
1154               null,
1155               value[0],
1156               operatorList,
1157               task,
1158               stateManager.state
1159             ).then(function (loadedName) {
1160               operatorList.addDependency(loadedName);
1161               gStateObj.push([key, [loadedName, value[1]]]);
1162             })
1163           );
1164           break;
1165         case "BM":
1166           gStateObj.push([key, normalizeBlendMode(value)]);
1167           break;
1168         case "SMask":
1169           if (isName(value, "None")) {
1170             gStateObj.push([key, false]);
1171             break;
1172           }
1173           if (value instanceof Dict) {
1174             isSimpleGState = false;
1175 
1176             promise = promise.then(() =>
1177               this.handleSMask(
1178                 value,
1179                 resources,
1180                 operatorList,
1181                 task,
1182                 stateManager,
1183                 localColorSpaceCache
1184               )
1185             );
1186             gStateObj.push([key, true]);
1187           } else {
1188             warn("Unsupported SMask type");
1189           }
1190           break;
1191         case "TR":
1192           const transferMaps = this.handleTransferFunction(value);
1193           gStateObj.push([key, transferMaps]);
1194           break;
1195         // Only generate info log messages for the following since
1196         // they are unlikely to have a big impact on the rendering.
1197         case "OP":
1198         case "op":
1199         case "OPM":
1200         case "BG":
1201         case "BG2":
1202         case "UCR":
1203         case "UCR2":
1204         case "TR2":
1205         case "HT":
1206         case "SM":
1207         case "SA":
1208         case "AIS":
1209         case "TK":
1210           // TODO implement these operators.
1211           info("graphic state operator " + key);
1212           break;
1213         default:
1214           info("Unknown graphic state operator " + key);
1215           break;
1216       }
1217     }
1218     await promise;
1219 
1220     if (gStateObj.length > 0) {
1221       operatorList.addOp(OPS.setGState, [gStateObj]);
1222     }
1223 
1224     if (isSimpleGState) {
1225       localGStateCache.set(cacheKey, gStateRef, gStateObj);
1226     }
1227   }
1228 
1229   loadFont(
1230     fontName,
1231     font,
1232     resources,
1233     fallbackFontDict = null,
1234     cssFontInfo = null
1235   ) {
1236     // eslint-disable-next-line arrow-body-style
1237     const errorFont = async () => {
1238       return new TranslatedFont({
1239         loadedName: "g_font_error",
1240         font: new ErrorFont(`Font "${fontName}" is not available.`),
1241         dict: font,
1242         evaluatorOptions: this.options,
1243       });
1244     };
1245 
1246     let fontRef;
1247     if (font) {
1248       // Loading by ref.
1249       if (font instanceof Ref) {
1250         fontRef = font;
1251       }
1252     } else {
1253       // Loading by name.
1254       const fontRes = resources.get("Font");
1255       if (fontRes) {
1256         fontRef = fontRes.getRaw(fontName);
1257       }
1258     }
1259     if (fontRef) {
1260       if (this.type3FontRefs?.has(fontRef)) {
1261         return errorFont();
1262       }
1263 
1264       if (this.fontCache.has(fontRef)) {
1265         return this.fontCache.get(fontRef);
1266       }
1267 
1268       try {
1269         font = this.xref.fetchIfRef(fontRef);
1270       } catch (ex) {
1271         warn(`loadFont - lookup failed: "${ex}".`);
1272       }
1273     }
1274 
1275     if (!(font instanceof Dict)) {
1276       if (!this.options.ignoreErrors && !this.parsingType3Font) {
1277         warn(`Font "${fontName}" is not available.`);
1278         return errorFont();
1279       }
1280       warn(
1281         `Font "${fontName}" is not available -- attempting to fallback to a default font.`
1282       );
1283 
1284       // Falling back to a default font to avoid completely broken rendering,
1285       // but note that there're no guarantees that things will look "correct".
1286       font = fallbackFontDict || PartialEvaluator.fallbackFontDict;
1287     }
1288 
1289     // We are holding `font.cacheKey` references only for `fontRef`s that
1290     // are not actually `Ref`s, but rather `Dict`s. See explanation below.
1291     if (font.cacheKey && this.fontCache.has(font.cacheKey)) {
1292       return this.fontCache.get(font.cacheKey);
1293     }
1294 
1295     const { promise, resolve } = Promise.withResolvers();
1296 
1297     let preEvaluatedFont;
1298     try {
1299       preEvaluatedFont = this.preEvaluateFont(font);
1300       preEvaluatedFont.cssFontInfo = cssFontInfo;
1301     } catch (reason) {
1302       warn(`loadFont - preEvaluateFont failed: "${reason}".`);
1303       return errorFont();
1304     }
1305     const { descriptor, hash } = preEvaluatedFont;
1306 
1307     const fontRefIsRef = fontRef instanceof Ref;
1308     let fontID;
1309 
1310     if (hash && descriptor instanceof Dict) {
1311       const fontAliases = (descriptor.fontAliases ||= Object.create(null));
1312 
1313       if (fontAliases[hash]) {
1314         const aliasFontRef = fontAliases[hash].aliasRef;
1315         if (fontRefIsRef && aliasFontRef && this.fontCache.has(aliasFontRef)) {
1316           this.fontCache.putAlias(fontRef, aliasFontRef);
1317           return this.fontCache.get(fontRef);
1318         }
1319       } else {
1320         fontAliases[hash] = {
1321           fontID: this.idFactory.createFontId(),
1322         };
1323       }
1324 
1325       if (fontRefIsRef) {
1326         fontAliases[hash].aliasRef = fontRef;
1327       }
1328       fontID = fontAliases[hash].fontID;
1329     } else {
1330       fontID = this.idFactory.createFontId();
1331     }
1332     assert(
1333       fontID?.startsWith("f"),
1334       'The "fontID" must be (correctly) defined.'
1335     );
1336 
1337     // Workaround for bad PDF generators that reference fonts incorrectly,
1338     // where `fontRef` is a `Dict` rather than a `Ref` (fixes bug946506.pdf).
1339     // In this case we cannot put the font into `this.fontCache` (which is
1340     // a `RefSetCache`), since it's not possible to use a `Dict` as a key.
1341     //
1342     // However, if we don't cache the font it's not possible to remove it
1343     // when `cleanup` is triggered from the API, which causes issues on
1344     // subsequent rendering operations (see issue7403.pdf) and would force us
1345     // to unnecessarily load the same fonts over and over.
1346     //
1347     // Instead, we cheat a bit by using a modified `fontID` as a key in
1348     // `this.fontCache`, to allow the font to be cached.
1349     // NOTE: This works because `RefSetCache` calls `toString()` on provided
1350     //       keys. Also, since `fontRef` is used when getting cached fonts,
1351     //       we'll not accidentally match fonts cached with the `fontID`.
1352     if (fontRefIsRef) {
1353       this.fontCache.put(fontRef, promise);
1354     } else {
1355       font.cacheKey = `cacheKey_${fontID}`;
1356       this.fontCache.put(font.cacheKey, promise);
1357     }
1358 
1359     // Keep track of each font we translated so the caller can
1360     // load them asynchronously before calling display on a page.
1361     font.loadedName = `${this.idFactory.getDocId()}_${fontID}`;
1362 
1363     this.translateFont(preEvaluatedFont)
1364       .then(translatedFont => {
1365         resolve(
1366           new TranslatedFont({
1367             loadedName: font.loadedName,
1368             font: translatedFont,
1369             dict: font,
1370             evaluatorOptions: this.options,
1371           })
1372         );
1373       })
1374       .catch(reason => {
1375         // TODO reject?
1376         warn(`loadFont - translateFont failed: "${reason}".`);
1377 
1378         resolve(
1379           new TranslatedFont({
1380             loadedName: font.loadedName,
1381             font: new ErrorFont(
1382               reason instanceof Error ? reason.message : reason
1383             ),
1384             dict: font,
1385             evaluatorOptions: this.options,
1386           })
1387         );
1388       });
1389     return promise;
1390   }
1391 
1392   buildPath(operatorList, fn, args, parsingText = false) {
1393     const lastIndex = operatorList.length - 1;
1394     if (!args) {
1395       args = [];
1396     }
1397     if (
1398       lastIndex < 0 ||
1399       operatorList.fnArray[lastIndex] !== OPS.constructPath
1400     ) {
1401       // Handle corrupt PDF documents that contains path operators inside of
1402       // text objects, which may shift subsequent text, by enclosing the path
1403       // operator in save/restore operators (fixes issue10542_reduced.pdf).
1404       //
1405       // Note that this will effectively disable the optimization in the
1406       // `else` branch below, but given that this type of corruption is
1407       // *extremely* rare that shouldn't really matter much in practice.
1408       if (parsingText) {
1409         warn(`Encountered path operator "${fn}" inside of a text object.`);
1410         operatorList.addOp(OPS.save, null);
1411       }
1412 
1413       let minMax;
1414       switch (fn) {
1415         case OPS.rectangle:
1416           const x = args[0] + args[2];
1417           const y = args[1] + args[3];
1418           minMax = [
1419             Math.min(args[0], x),
1420             Math.min(args[1], y),
1421             Math.max(args[0], x),
1422             Math.max(args[1], y),
1423           ];
1424           break;
1425         case OPS.moveTo:
1426         case OPS.lineTo:
1427           minMax = [args[0], args[1], args[0], args[1]];
1428           break;
1429         default:
1430           minMax = [Infinity, Infinity, -Infinity, -Infinity];
1431           break;
1432       }
1433       operatorList.addOp(OPS.constructPath, [[fn], args, minMax]);
1434 
1435       if (parsingText) {
1436         operatorList.addOp(OPS.restore, null);
1437       }
1438     } else {
1439       const opArgs = operatorList.argsArray[lastIndex];
1440       opArgs[0].push(fn);
1441       opArgs[1].push(...args);
1442       const minMax = opArgs[2];
1443 
1444       // Compute min/max in the worker instead of the main thread.
1445       // If the current matrix (when drawing) is a scaling one
1446       // then min/max can be easily computed in using those values.
1447       // Only rectangle, lineTo and moveTo are handled here since
1448       // Bezier stuff requires to have the starting point.
1449       switch (fn) {
1450         case OPS.rectangle:
1451           const x = args[0] + args[2];
1452           const y = args[1] + args[3];
1453           minMax[0] = Math.min(minMax[0], args[0], x);
1454           minMax[1] = Math.min(minMax[1], args[1], y);
1455           minMax[2] = Math.max(minMax[2], args[0], x);
1456           minMax[3] = Math.max(minMax[3], args[1], y);
1457           break;
1458         case OPS.moveTo:
1459         case OPS.lineTo:
1460           minMax[0] = Math.min(minMax[0], args[0]);
1461           minMax[1] = Math.min(minMax[1], args[1]);
1462           minMax[2] = Math.max(minMax[2], args[0]);
1463           minMax[3] = Math.max(minMax[3], args[1]);
1464           break;
1465       }
1466     }
1467   }
1468 
1469   parseColorSpace({ cs, resources, localColorSpaceCache }) {
1470     return ColorSpace.parseAsync({
1471       cs,
1472       xref: this.xref,
1473       resources,
1474       pdfFunctionFactory: this._pdfFunctionFactory,
1475       localColorSpaceCache,
1476     }).catch(reason => {
1477       if (reason instanceof AbortException) {
1478         return null;
1479       }
1480       if (this.options.ignoreErrors) {
1481         warn(`parseColorSpace - ignoring ColorSpace: "${reason}".`);
1482         return null;
1483       }
1484       throw reason;
1485     });
1486   }
1487 
1488   parseShading({
1489     shading,
1490     resources,
1491     localColorSpaceCache,
1492     localShadingPatternCache,
1493   }) {
1494     // Shadings and patterns may be referenced by the same name but the resource
1495     // dictionary could be different so we can't use the name for the cache key.
1496     let id = localShadingPatternCache.get(shading);
1497     if (id) {
1498       return id;
1499     }
1500     let patternIR;
1501 
1502     try {
1503       const shadingFill = Pattern.parseShading(
1504         shading,
1505         this.xref,
1506         resources,
1507         this._pdfFunctionFactory,
1508         localColorSpaceCache
1509       );
1510       patternIR = shadingFill.getIR();
1511     } catch (reason) {
1512       if (reason instanceof AbortException) {
1513         return null;
1514       }
1515       if (this.options.ignoreErrors) {
1516         warn(`parseShading - ignoring shading: "${reason}".`);
1517 
1518         localShadingPatternCache.set(shading, null);
1519         return null;
1520       }
1521       throw reason;
1522     }
1523 
1524     id = `pattern_${this.idFactory.createObjId()}`;
1525     if (this.parsingType3Font) {
1526       id = `${this.idFactory.getDocId()}_type3_${id}`;
1527     }
1528     localShadingPatternCache.set(shading, id);
1529 
1530     if (this.parsingType3Font) {
1531       this.handler.send("commonobj", [id, "Pattern", patternIR]);
1532     } else {
1533       this.handler.send("obj", [id, this.pageIndex, "Pattern", patternIR]);
1534     }
1535     return id;
1536   }
1537 
1538   handleColorN(
1539     operatorList,
1540     fn,
1541     args,
1542     cs,
1543     patterns,
1544     resources,
1545     task,
1546     localColorSpaceCache,
1547     localTilingPatternCache,
1548     localShadingPatternCache
1549   ) {
1550     // compile tiling patterns
1551     const patternName = args.pop();
1552     // SCN/scn applies patterns along with normal colors
1553     if (patternName instanceof Name) {
1554       const rawPattern = patterns.getRaw(patternName.name);
1555 
1556       const localTilingPattern =
1557         rawPattern instanceof Ref &&
1558         localTilingPatternCache.getByRef(rawPattern);
1559       if (localTilingPattern) {
1560         try {
1561           const color = cs.base ? cs.base.getRgb(args, 0) : null;
1562           const tilingPatternIR = getTilingPatternIR(
1563             localTilingPattern.operatorListIR,
1564             localTilingPattern.dict,
1565             color
1566           );
1567           operatorList.addOp(fn, tilingPatternIR);
1568           return undefined;
1569         } catch {
1570           // Handle any errors during normal TilingPattern parsing.
1571         }
1572       }
1573 
1574       const pattern = this.xref.fetchIfRef(rawPattern);
1575       if (pattern) {
1576         const dict = pattern instanceof BaseStream ? pattern.dict : pattern;
1577         const typeNum = dict.get("PatternType");
1578 
1579         if (typeNum === PatternType.TILING) {
1580           const color = cs.base ? cs.base.getRgb(args, 0) : null;
1581           return this.handleTilingType(
1582             fn,
1583             color,
1584             resources,
1585             pattern,
1586             dict,
1587             operatorList,
1588             task,
1589             localTilingPatternCache
1590           );
1591         } else if (typeNum === PatternType.SHADING) {
1592           const shading = dict.get("Shading");
1593           const objId = this.parseShading({
1594             shading,
1595             resources,
1596             localColorSpaceCache,
1597             localShadingPatternCache,
1598           });
1599           if (objId) {
1600             const matrix = lookupMatrix(dict.getArray("Matrix"), null);
1601             operatorList.addOp(fn, ["Shading", objId, matrix]);
1602           }
1603           return undefined;
1604         }
1605         throw new FormatError(`Unknown PatternType: ${typeNum}`);
1606       }
1607     }
1608     throw new FormatError(`Unknown PatternName: ${patternName}`);
1609   }
1610 
1611   _parseVisibilityExpression(array, nestingCounter, currentResult) {
1612     const MAX_NESTING = 10;
1613     if (++nestingCounter > MAX_NESTING) {
1614       warn("Visibility expression is too deeply nested");
1615       return;
1616     }
1617     const length = array.length;
1618     const operator = this.xref.fetchIfRef(array[0]);
1619     if (length < 2 || !(operator instanceof Name)) {
1620       warn("Invalid visibility expression");
1621       return;
1622     }
1623     switch (operator.name) {
1624       case "And":
1625       case "Or":
1626       case "Not":
1627         currentResult.push(operator.name);
1628         break;
1629       default:
1630         warn(`Invalid operator ${operator.name} in visibility expression`);
1631         return;
1632     }
1633     for (let i = 1; i < length; i++) {
1634       const raw = array[i];
1635       const object = this.xref.fetchIfRef(raw);
1636       if (Array.isArray(object)) {
1637         const nestedResult = [];
1638         currentResult.push(nestedResult);
1639         // Recursively parse a subarray.
1640         this._parseVisibilityExpression(object, nestingCounter, nestedResult);
1641       } else if (raw instanceof Ref) {
1642         // Reference to an OCG dictionary.
1643         currentResult.push(raw.toString());
1644       }
1645     }
1646   }
1647 
1648   async parseMarkedContentProps(contentProperties, resources) {
1649     let optionalContent;
1650     if (contentProperties instanceof Name) {
1651       const properties = resources.get("Properties");
1652       optionalContent = properties.get(contentProperties.name);
1653     } else if (contentProperties instanceof Dict) {
1654       optionalContent = contentProperties;
1655     } else {
1656       throw new FormatError("Optional content properties malformed.");
1657     }
1658 
1659     const optionalContentType = optionalContent.get("Type")?.name;
1660     if (optionalContentType === "OCG") {
1661       return {
1662         type: optionalContentType,
1663         id: optionalContent.objId,
1664       };
1665     } else if (optionalContentType === "OCMD") {
1666       const expression = optionalContent.get("VE");
1667       if (Array.isArray(expression)) {
1668         const result = [];
1669         this._parseVisibilityExpression(expression, 0, result);
1670         if (result.length > 0) {
1671           return {
1672             type: "OCMD",
1673             expression: result,
1674           };
1675         }
1676       }
1677 
1678       const optionalContentGroups = optionalContent.get("OCGs");
1679       if (
1680         Array.isArray(optionalContentGroups) ||
1681         optionalContentGroups instanceof Dict
1682       ) {
1683         const groupIds = [];
1684         if (Array.isArray(optionalContentGroups)) {
1685           for (const ocg of optionalContentGroups) {
1686             groupIds.push(ocg.toString());
1687           }
1688         } else {
1689           // Dictionary, just use the obj id.
1690           groupIds.push(optionalContentGroups.objId);
1691         }
1692 
1693         return {
1694           type: optionalContentType,
1695           ids: groupIds,
1696           policy:
1697             optionalContent.get("P") instanceof Name
1698               ? optionalContent.get("P").name
1699               : null,
1700           expression: null,
1701         };
1702       } else if (optionalContentGroups instanceof Ref) {
1703         return {
1704           type: optionalContentType,
1705           id: optionalContentGroups.toString(),
1706         };
1707       }
1708     }
1709     return null;
1710   }
1711 
1712   getOperatorList({
1713     stream,
1714     task,
1715     resources,
1716     operatorList,
1717     initialState = null,
1718     fallbackFontDict = null,
1719   }) {
1720     // Ensure that `resources`/`initialState` is correctly initialized,
1721     // even if the provided parameter is e.g. `null`.
1722     resources ||= Dict.empty;
1723     initialState ||= new EvalState();
1724 
1725     if (!operatorList) {
1726       throw new Error('getOperatorList: missing "operatorList" parameter');
1727     }
1728 
1729     const self = this;
1730     const xref = this.xref;
1731     let parsingText = false;
1732     const localImageCache = new LocalImageCache();
1733     const localColorSpaceCache = new LocalColorSpaceCache();
1734     const localGStateCache = new LocalGStateCache();
1735     const localTilingPatternCache = new LocalTilingPatternCache();
1736     const localShadingPatternCache = new Map();
1737 
1738     const xobjs = resources.get("XObject") || Dict.empty;
1739     const patterns = resources.get("Pattern") || Dict.empty;
1740     const stateManager = new StateManager(initialState);
1741     const preprocessor = new EvaluatorPreprocessor(stream, xref, stateManager);
1742     const timeSlotManager = new TimeSlotManager();
1743 
1744     function closePendingRestoreOPS(argument) {
1745       for (let i = 0, ii = preprocessor.savedStatesDepth; i < ii; i++) {
1746         operatorList.addOp(OPS.restore, []);
1747       }
1748     }
1749 
1750     return new Promise(function promiseBody(resolve, reject) {
1751       const next = function (promise) {
1752         Promise.all([promise, operatorList.ready]).then(function () {
1753           try {
1754             promiseBody(resolve, reject);
1755           } catch (ex) {
1756             reject(ex);
1757           }
1758         }, reject);
1759       };
1760       task.ensureNotTerminated();
1761       timeSlotManager.reset();
1762 
1763       const operation = {};
1764       let stop, i, ii, cs, name, isValidName;
1765       while (!(stop = timeSlotManager.check())) {
1766         // The arguments parsed by read() are used beyond this loop, so we
1767         // cannot reuse the same array on each iteration. Therefore we pass
1768         // in |null| as the initial value (see the comment on
1769         // EvaluatorPreprocessor_read() for why).
1770         operation.args = null;
1771         if (!preprocessor.read(operation)) {
1772           break;
1773         }
1774         let args = operation.args;
1775         let fn = operation.fn;
1776 
1777         switch (fn | 0) {
1778           case OPS.paintXObject:
1779             // eagerly compile XForm objects
1780             isValidName = args[0] instanceof Name;
1781             name = args[0].name;
1782 
1783             if (isValidName) {
1784               const localImage = localImageCache.getByName(name);
1785               if (localImage) {
1786                 operatorList.addImageOps(
1787                   localImage.fn,
1788                   localImage.args,
1789                   localImage.optionalContent
1790                 );
1791 
1792                 incrementCachedImageMaskCount(localImage);
1793                 args = null;
1794                 continue;
1795               }
1796             }
1797 
1798             next(
1799               new Promise(function (resolveXObject, rejectXObject) {
1800                 if (!isValidName) {
1801                   throw new FormatError("XObject must be referred to by name.");
1802                 }
1803 
1804                 let xobj = xobjs.getRaw(name);
1805                 if (xobj instanceof Ref) {
1806                   const localImage =
1807                     localImageCache.getByRef(xobj) ||
1808                     self._regionalImageCache.getByRef(xobj);
1809                   if (localImage) {
1810                     operatorList.addImageOps(
1811                       localImage.fn,
1812                       localImage.args,
1813                       localImage.optionalContent
1814                     );
1815 
1816                     incrementCachedImageMaskCount(localImage);
1817                     resolveXObject();
1818                     return;
1819                   }
1820 
1821                   const globalImage = self.globalImageCache.getData(
1822                     xobj,
1823                     self.pageIndex
1824                   );
1825                   if (globalImage) {
1826                     operatorList.addDependency(globalImage.objId);
1827                     operatorList.addImageOps(
1828                       globalImage.fn,
1829                       globalImage.args,
1830                       globalImage.optionalContent
1831                     );
1832 
1833                     resolveXObject();
1834                     return;
1835                   }
1836 
1837                   xobj = xref.fetch(xobj);
1838                 }
1839 
1840                 if (!(xobj instanceof BaseStream)) {
1841                   throw new FormatError("XObject should be a stream");
1842                 }
1843 
1844                 const type = xobj.dict.get("Subtype");
1845                 if (!(type instanceof Name)) {
1846                   throw new FormatError("XObject should have a Name subtype");
1847                 }
1848 
1849                 if (type.name === "Form") {
1850                   stateManager.save();
1851                   self
1852                     .buildFormXObject(
1853                       resources,
1854                       xobj,
1855                       null,
1856                       operatorList,
1857                       task,
1858                       stateManager.state.clone(),
1859                       localColorSpaceCache
1860                     )
1861                     .then(function () {
1862                       stateManager.restore();
1863                       resolveXObject();
1864                     }, rejectXObject);
1865                   return;
1866                 } else if (type.name === "Image") {
1867                   self
1868                     .buildPaintImageXObject({
1869                       resources,
1870                       image: xobj,
1871                       operatorList,
1872                       cacheKey: name,
1873                       localImageCache,
1874                       localColorSpaceCache,
1875                     })
1876                     .then(resolveXObject, rejectXObject);
1877                   return;
1878                 } else if (type.name === "PS") {
1879                   // PostScript XObjects are unused when viewing documents.
1880                   // See section 4.7.1 of Adobe's PDF reference.
1881                   info("Ignored XObject subtype PS");
1882                 } else {
1883                   throw new FormatError(
1884                     `Unhandled XObject subtype ${type.name}`
1885                   );
1886                 }
1887                 resolveXObject();
1888               }).catch(function (reason) {
1889                 if (reason instanceof AbortException) {
1890                   return;
1891                 }
1892                 if (self.options.ignoreErrors) {
1893                   warn(`getOperatorList - ignoring XObject: "${reason}".`);
1894                   return;
1895                 }
1896                 throw reason;
1897               })
1898             );
1899             return;
1900           case OPS.setFont:
1901             var fontSize = args[1];
1902             // eagerly collect all fonts
1903             next(
1904               self
1905                 .handleSetFont(
1906                   resources,
1907                   args,
1908                   null,
1909                   operatorList,
1910                   task,
1911                   stateManager.state,
1912                   fallbackFontDict
1913                 )
1914                 .then(function (loadedName) {
1915                   operatorList.addDependency(loadedName);
1916                   operatorList.addOp(OPS.setFont, [loadedName, fontSize]);
1917                 })
1918             );
1919             return;
1920           case OPS.beginText:
1921             parsingText = true;
1922             break;
1923           case OPS.endText:
1924             parsingText = false;
1925             break;
1926           case OPS.endInlineImage:
1927             var cacheKey = args[0].cacheKey;
1928             if (cacheKey) {
1929               const localImage = localImageCache.getByName(cacheKey);
1930               if (localImage) {
1931                 operatorList.addImageOps(
1932                   localImage.fn,
1933                   localImage.args,
1934                   localImage.optionalContent
1935                 );
1936 
1937                 incrementCachedImageMaskCount(localImage);
1938                 args = null;
1939                 continue;
1940               }
1941             }
1942             next(
1943               self.buildPaintImageXObject({
1944                 resources,
1945                 image: args[0],
1946                 isInline: true,
1947                 operatorList,
1948                 cacheKey,
1949                 localImageCache,
1950                 localColorSpaceCache,
1951               })
1952             );
1953             return;
1954           case OPS.showText:
1955             if (!stateManager.state.font) {
1956               self.ensureStateFont(stateManager.state);
1957               continue;
1958             }
1959             args[0] = self.handleText(args[0], stateManager.state);
1960             break;
1961           case OPS.showSpacedText:
1962             if (!stateManager.state.font) {
1963               self.ensureStateFont(stateManager.state);
1964               continue;
1965             }
1966             var combinedGlyphs = [];
1967             var state = stateManager.state;
1968             for (const arrItem of args[0]) {
1969               if (typeof arrItem === "string") {
1970                 combinedGlyphs.push(...self.handleText(arrItem, state));
1971               } else if (typeof arrItem === "number") {
1972                 combinedGlyphs.push(arrItem);
1973               }
1974             }
1975             args[0] = combinedGlyphs;
1976             fn = OPS.showText;
1977             break;
1978           case OPS.nextLineShowText:
1979             if (!stateManager.state.font) {
1980               self.ensureStateFont(stateManager.state);
1981               continue;
1982             }
1983             operatorList.addOp(OPS.nextLine);
1984             args[0] = self.handleText(args[0], stateManager.state);
1985             fn = OPS.showText;
1986             break;
1987           case OPS.nextLineSetSpacingShowText:
1988             if (!stateManager.state.font) {
1989               self.ensureStateFont(stateManager.state);
1990               continue;
1991             }
1992             operatorList.addOp(OPS.nextLine);
1993             operatorList.addOp(OPS.setWordSpacing, [args.shift()]);
1994             operatorList.addOp(OPS.setCharSpacing, [args.shift()]);
1995             args[0] = self.handleText(args[0], stateManager.state);
1996             fn = OPS.showText;
1997             break;
1998           case OPS.setTextRenderingMode:
1999             stateManager.state.textRenderingMode = args[0];
2000             break;
2001 
2002           case OPS.setFillColorSpace: {
2003             const cachedColorSpace = ColorSpace.getCached(
2004               args[0],
2005               xref,
2006               localColorSpaceCache
2007             );
2008             if (cachedColorSpace) {
2009               stateManager.state.fillColorSpace = cachedColorSpace;
2010               continue;
2011             }
2012 
2013             next(
2014               self
2015                 .parseColorSpace({
2016                   cs: args[0],
2017                   resources,
2018                   localColorSpaceCache,
2019                 })
2020                 .then(function (colorSpace) {
2021                   if (colorSpace) {
2022                     stateManager.state.fillColorSpace = colorSpace;
2023                   }
2024                 })
2025             );
2026             return;
2027           }
2028           case OPS.setStrokeColorSpace: {
2029             const cachedColorSpace = ColorSpace.getCached(
2030               args[0],
2031               xref,
2032               localColorSpaceCache
2033             );
2034             if (cachedColorSpace) {
2035               stateManager.state.strokeColorSpace = cachedColorSpace;
2036               continue;
2037             }
2038 
2039             next(
2040               self
2041                 .parseColorSpace({
2042                   cs: args[0],
2043                   resources,
2044                   localColorSpaceCache,
2045                 })
2046                 .then(function (colorSpace) {
2047                   if (colorSpace) {
2048                     stateManager.state.strokeColorSpace = colorSpace;
2049                   }
2050                 })
2051             );
2052             return;
2053           }
2054           case OPS.setFillColor:
2055             cs = stateManager.state.fillColorSpace;
2056             args = cs.getRgb(args, 0);
2057             fn = OPS.setFillRGBColor;
2058             break;
2059           case OPS.setStrokeColor:
2060             cs = stateManager.state.strokeColorSpace;
2061             args = cs.getRgb(args, 0);
2062             fn = OPS.setStrokeRGBColor;
2063             break;
2064           case OPS.setFillGray:
2065             stateManager.state.fillColorSpace = ColorSpace.singletons.gray;
2066             args = ColorSpace.singletons.gray.getRgb(args, 0);
2067             fn = OPS.setFillRGBColor;
2068             break;
2069           case OPS.setStrokeGray:
2070             stateManager.state.strokeColorSpace = ColorSpace.singletons.gray;
2071             args = ColorSpace.singletons.gray.getRgb(args, 0);
2072             fn = OPS.setStrokeRGBColor;
2073             break;
2074           case OPS.setFillCMYKColor:
2075             stateManager.state.fillColorSpace = ColorSpace.singletons.cmyk;
2076             args = ColorSpace.singletons.cmyk.getRgb(args, 0);
2077             fn = OPS.setFillRGBColor;
2078             break;
2079           case OPS.setStrokeCMYKColor:
2080             stateManager.state.strokeColorSpace = ColorSpace.singletons.cmyk;
2081             args = ColorSpace.singletons.cmyk.getRgb(args, 0);
2082             fn = OPS.setStrokeRGBColor;
2083             break;
2084           case OPS.setFillRGBColor:
2085             stateManager.state.fillColorSpace = ColorSpace.singletons.rgb;
2086             args = ColorSpace.singletons.rgb.getRgb(args, 0);
2087             break;
2088           case OPS.setStrokeRGBColor:
2089             stateManager.state.strokeColorSpace = ColorSpace.singletons.rgb;
2090             args = ColorSpace.singletons.rgb.getRgb(args, 0);
2091             break;
2092           case OPS.setFillColorN:
2093             cs = stateManager.state.fillColorSpace;
2094             if (cs.name === "Pattern") {
2095               next(
2096                 self.handleColorN(
2097                   operatorList,
2098                   OPS.setFillColorN,
2099                   args,
2100                   cs,
2101                   patterns,
2102                   resources,
2103                   task,
2104                   localColorSpaceCache,
2105                   localTilingPatternCache,
2106                   localShadingPatternCache
2107                 )
2108               );
2109               return;
2110             }
2111             args = cs.getRgb(args, 0);
2112             fn = OPS.setFillRGBColor;
2113             break;
2114           case OPS.setStrokeColorN:
2115             cs = stateManager.state.strokeColorSpace;
2116             if (cs.name === "Pattern") {
2117               next(
2118                 self.handleColorN(
2119                   operatorList,
2120                   OPS.setStrokeColorN,
2121                   args,
2122                   cs,
2123                   patterns,
2124                   resources,
2125                   task,
2126                   localColorSpaceCache,
2127                   localTilingPatternCache,
2128                   localShadingPatternCache
2129                 )
2130               );
2131               return;
2132             }
2133             args = cs.getRgb(args, 0);
2134             fn = OPS.setStrokeRGBColor;
2135             break;
2136 
2137           case OPS.shadingFill:
2138             var shadingRes = resources.get("Shading");
2139             if (!shadingRes) {
2140               throw new FormatError("No shading resource found");
2141             }
2142 
2143             var shading = shadingRes.get(args[0].name);
2144             if (!shading) {
2145               throw new FormatError("No shading object found");
2146             }
2147             const patternId = self.parseShading({
2148               shading,
2149               resources,
2150               localColorSpaceCache,
2151               localShadingPatternCache,
2152             });
2153             if (!patternId) {
2154               continue;
2155             }
2156             args = [patternId];
2157             fn = OPS.shadingFill;
2158             break;
2159           case OPS.setGState:
2160             isValidName = args[0] instanceof Name;
2161             name = args[0].name;
2162 
2163             if (isValidName) {
2164               const localGStateObj = localGStateCache.getByName(name);
2165               if (localGStateObj) {
2166                 if (localGStateObj.length > 0) {
2167                   operatorList.addOp(OPS.setGState, [localGStateObj]);
2168                 }
2169                 args = null;
2170                 continue;
2171               }
2172             }
2173 
2174             next(
2175               new Promise(function (resolveGState, rejectGState) {
2176                 if (!isValidName) {
2177                   throw new FormatError("GState must be referred to by name.");
2178                 }
2179 
2180                 const extGState = resources.get("ExtGState");
2181                 if (!(extGState instanceof Dict)) {
2182                   throw new FormatError("ExtGState should be a dictionary.");
2183                 }
2184 
2185                 const gState = extGState.get(name);
2186                 // TODO: Attempt to lookup cached GStates by reference as well,
2187                 //       if and only if there are PDF documents where doing so
2188                 //       would significantly improve performance.
2189                 if (!(gState instanceof Dict)) {
2190                   throw new FormatError("GState should be a dictionary.");
2191                 }
2192 
2193                 self
2194                   .setGState({
2195                     resources,
2196                     gState,
2197                     operatorList,
2198                     cacheKey: name,
2199                     task,
2200                     stateManager,
2201                     localGStateCache,
2202                     localColorSpaceCache,
2203                   })
2204                   .then(resolveGState, rejectGState);
2205               }).catch(function (reason) {
2206                 if (reason instanceof AbortException) {
2207                   return;
2208                 }
2209                 if (self.options.ignoreErrors) {
2210                   warn(`getOperatorList - ignoring ExtGState: "${reason}".`);
2211                   return;
2212                 }
2213                 throw reason;
2214               })
2215             );
2216             return;
2217           case OPS.moveTo:
2218           case OPS.lineTo:
2219           case OPS.curveTo:
2220           case OPS.curveTo2:
2221           case OPS.curveTo3:
2222           case OPS.closePath:
2223           case OPS.rectangle:
2224             self.buildPath(operatorList, fn, args, parsingText);
2225             continue;
2226           case OPS.markPoint:
2227           case OPS.markPointProps:
2228           case OPS.beginCompat:
2229           case OPS.endCompat:
2230             // Ignore operators where the corresponding handlers are known to
2231             // be no-op in CanvasGraphics (display/canvas.js). This prevents
2232             // serialization errors and is also a bit more efficient.
2233             // We could also try to serialize all objects in a general way,
2234             // e.g. as done in https://github.com/mozilla/pdf.js/pull/6266,
2235             // but doing so is meaningless without knowing the semantics.
2236             continue;
2237           case OPS.beginMarkedContentProps:
2238             if (!(args[0] instanceof Name)) {
2239               warn(`Expected name for beginMarkedContentProps arg0=${args[0]}`);
2240               operatorList.addOp(OPS.beginMarkedContentProps, ["OC", null]);
2241               continue;
2242             }
2243             if (args[0].name === "OC") {
2244               next(
2245                 self
2246                   .parseMarkedContentProps(args[1], resources)
2247                   .then(data => {
2248                     operatorList.addOp(OPS.beginMarkedContentProps, [
2249                       "OC",
2250                       data,
2251                     ]);
2252                   })
2253                   .catch(reason => {
2254                     if (reason instanceof AbortException) {
2255                       return;
2256                     }
2257                     if (self.options.ignoreErrors) {
2258                       warn(
2259                         `getOperatorList - ignoring beginMarkedContentProps: "${reason}".`
2260                       );
2261                       operatorList.addOp(OPS.beginMarkedContentProps, [
2262                         "OC",
2263                         null,
2264                       ]);
2265                       return;
2266                     }
2267                     throw reason;
2268                   })
2269               );
2270               return;
2271             }
2272             // Other marked content types aren't supported yet.
2273             args = [
2274               args[0].name,
2275               args[1] instanceof Dict ? args[1].get("MCID") : null,
2276             ];
2277 
2278             break;
2279           case OPS.beginMarkedContent:
2280           case OPS.endMarkedContent:
2281           default:
2282             // Note: Ignore the operator if it has `Dict` arguments, since
2283             // those are non-serializable, otherwise postMessage will throw
2284             // "An object could not be cloned.".
2285             if (args !== null) {
2286               for (i = 0, ii = args.length; i < ii; i++) {
2287                 if (args[i] instanceof Dict) {
2288                   break;
2289                 }
2290               }
2291               if (i < ii) {
2292                 warn("getOperatorList - ignoring operator: " + fn);
2293                 continue;
2294               }
2295             }
2296         }
2297         operatorList.addOp(fn, args);
2298       }
2299       if (stop) {
2300         next(deferred);
2301         return;
2302       }
2303       // Some PDFs don't close all restores inside object/form.
2304       // Closing those for them.
2305       closePendingRestoreOPS();
2306       resolve();
2307     }).catch(reason => {
2308       if (reason instanceof AbortException) {
2309         return;
2310       }
2311       if (this.options.ignoreErrors) {
2312         warn(
2313           `getOperatorList - ignoring errors during "${task.name}" ` +
2314             `task: "${reason}".`
2315         );
2316 
2317         closePendingRestoreOPS();
2318         return;
2319       }
2320       throw reason;
2321     });
2322   }
2323 
2324   getTextContent({
2325     stream,
2326     task,
2327     resources,
2328     stateManager = null,
2329     includeMarkedContent = false,
2330     sink,
2331     seenStyles = new Set(),
2332     viewBox,
2333     lang = null,
2334     markedContentData = null,
2335     disableNormalization = false,
2336     keepWhiteSpace = false,
2337   }) {
2338     // Ensure that `resources`/`stateManager` is correctly initialized,
2339     // even if the provided parameter is e.g. `null`.
2340     resources ||= Dict.empty;
2341     stateManager ||= new StateManager(new TextState());
2342 
2343     if (includeMarkedContent) {
2344       markedContentData ||= { level: 0 };
2345     }
2346 
2347     const textContent = {
2348       items: [],
2349       styles: Object.create(null),
2350       lang,
2351     };
2352     const textContentItem = {
2353       initialized: false,
2354       str: [],
2355       totalWidth: 0,
2356       totalHeight: 0,
2357       width: 0,
2358       height: 0,
2359       vertical: false,
2360       prevTransform: null,
2361       textAdvanceScale: 0,
2362       spaceInFlowMin: 0,
2363       spaceInFlowMax: 0,
2364       trackingSpaceMin: Infinity,
2365       negativeSpaceMax: -Infinity,
2366       notASpace: -Infinity,
2367       transform: null,
2368       fontName: null,
2369       hasEOL: false,
2370     };
2371 
2372     // Use a circular buffer (length === 2) to save the last chars in the
2373     // text stream.
2374     // This implementation of the circular buffer is using a fixed array
2375     // and the position of the next element:
2376     // function addElement(x) {
2377     //   buffer[pos] = x;
2378     //   pos = (pos + 1) % buffer.length;
2379     // }
2380     // It's a way faster than:
2381     // function addElement(x) {
2382     //   buffer.push(x);
2383     //   buffer.shift();
2384     // }
2385     //
2386     // It's useful to know when we need to add a whitespace in the
2387     // text chunk.
2388     const twoLastChars = [" ", " "];
2389     let twoLastCharsPos = 0;
2390 
2391     /**
2392      * Save the last char.
2393      * @param {string} char
2394      * @returns {boolean} true when the two last chars before adding the new one
2395      * are a non-whitespace followed by a whitespace.
2396      */
2397     function saveLastChar(char) {
2398       const nextPos = (twoLastCharsPos + 1) % 2;
2399       const ret =
2400         twoLastChars[twoLastCharsPos] !== " " && twoLastChars[nextPos] === " ";
2401       twoLastChars[twoLastCharsPos] = char;
2402       twoLastCharsPos = nextPos;
2403 
2404       return !keepWhiteSpace && ret;
2405     }
2406 
2407     function shouldAddWhitepsace() {
2408       return (
2409         !keepWhiteSpace &&
2410         twoLastChars[twoLastCharsPos] !== " " &&
2411         twoLastChars[(twoLastCharsPos + 1) % 2] === " "
2412       );
2413     }
2414 
2415     function resetLastChars() {
2416       twoLastChars[0] = twoLastChars[1] = " ";
2417       twoLastCharsPos = 0;
2418     }
2419 
2420     // Used in addFakeSpaces.
2421 
2422     // A white <= fontSize * TRACKING_SPACE_FACTOR is a tracking space
2423     // so it doesn't count as a space.
2424     const TRACKING_SPACE_FACTOR = 0.102;
2425 
2426     // When a white <= fontSize * NOT_A_SPACE_FACTOR, there is no space
2427     // even if one is present in the text stream.
2428     const NOT_A_SPACE_FACTOR = 0.03;
2429 
2430     // A negative white < fontSize * NEGATIVE_SPACE_FACTOR induces
2431     // a break (a new chunk of text is created).
2432     // It doesn't change anything when the text is copied but
2433     // it improves potential mismatch between text layer and canvas.
2434     const NEGATIVE_SPACE_FACTOR = -0.2;
2435 
2436     // A white with a width in [fontSize * MIN_FACTOR; fontSize * MAX_FACTOR]
2437     // is a space which will be inserted in the current flow of words.
2438     // If the width is outside of this range then the flow is broken
2439     // (which means a new span in the text layer).
2440     // It's useful to adjust the best as possible the span in the layer
2441     // to what is displayed in the canvas.
2442     const SPACE_IN_FLOW_MIN_FACTOR = 0.102;
2443     const SPACE_IN_FLOW_MAX_FACTOR = 0.6;
2444 
2445     // If a char is too high/too low compared to the previous we just create
2446     // a new chunk.
2447     // If the advance isn't in the +/-VERTICAL_SHIFT_RATIO * height range then
2448     // a new chunk is created.
2449     const VERTICAL_SHIFT_RATIO = 0.25;
2450 
2451     const self = this;
2452     const xref = this.xref;
2453     const showSpacedTextBuffer = [];
2454 
2455     // The xobj is parsed iff it's needed, e.g. if there is a `DO` cmd.
2456     let xobjs = null;
2457     const emptyXObjectCache = new LocalImageCache();
2458     const emptyGStateCache = new LocalGStateCache();
2459 
2460     const preprocessor = new EvaluatorPreprocessor(stream, xref, stateManager);
2461 
2462     let textState;
2463 
2464     function pushWhitespace({
2465       width = 0,
2466       height = 0,
2467       transform = textContentItem.prevTransform,
2468       fontName = textContentItem.fontName,
2469     }) {
2470       textContent.items.push({
2471         str: " ",
2472         dir: "ltr",
2473         width,
2474         height,
2475         transform,
2476         fontName,
2477         hasEOL: false,
2478       });
2479     }
2480 
2481     function getCurrentTextTransform() {
2482       // 9.4.4 Text Space Details
2483       const font = textState.font;
2484       const tsm = [
2485         textState.fontSize * textState.textHScale,
2486         0,
2487         0,
2488         textState.fontSize,
2489         0,
2490         textState.textRise,
2491       ];
2492 
2493       if (
2494         font.isType3Font &&
2495         (textState.fontSize <= 1 || font.isCharBBox) &&
2496         !isArrayEqual(textState.fontMatrix, FONT_IDENTITY_MATRIX)
2497       ) {
2498         const glyphHeight = font.bbox[3] - font.bbox[1];
2499         if (glyphHeight > 0) {
2500           tsm[3] *= glyphHeight * textState.fontMatrix[3];
2501         }
2502       }
2503 
2504       return Util.transform(
2505         textState.ctm,
2506         Util.transform(textState.textMatrix, tsm)
2507       );
2508     }
2509 
2510     function ensureTextContentItem() {
2511       if (textContentItem.initialized) {
2512         return textContentItem;
2513       }
2514       const { font, loadedName } = textState;
2515       if (!seenStyles.has(loadedName)) {
2516         seenStyles.add(loadedName);
2517         textContent.styles[loadedName] = {
2518           fontFamily: font.fallbackName,
2519           ascent: font.ascent,
2520           descent: font.descent,
2521           vertical: font.vertical,
2522         };
2523         if (self.options.fontExtraProperties && font.systemFontInfo) {
2524           const style = textContent.styles[loadedName];
2525           style.fontSubstitution = font.systemFontInfo.css;
2526           style.fontSubstitutionLoadedName = font.systemFontInfo.loadedName;
2527         }
2528       }
2529       textContentItem.fontName = loadedName;
2530 
2531       const trm = (textContentItem.transform = getCurrentTextTransform());
2532       if (!font.vertical) {
2533         textContentItem.width = textContentItem.totalWidth = 0;
2534         textContentItem.height = textContentItem.totalHeight = Math.hypot(
2535           trm[2],
2536           trm[3]
2537         );
2538         textContentItem.vertical = false;
2539       } else {
2540         textContentItem.width = textContentItem.totalWidth = Math.hypot(
2541           trm[0],
2542           trm[1]
2543         );
2544         textContentItem.height = textContentItem.totalHeight = 0;
2545         textContentItem.vertical = true;
2546       }
2547 
2548       const scaleLineX = Math.hypot(
2549         textState.textLineMatrix[0],
2550         textState.textLineMatrix[1]
2551       );
2552       const scaleCtmX = Math.hypot(textState.ctm[0], textState.ctm[1]);
2553       textContentItem.textAdvanceScale = scaleCtmX * scaleLineX;
2554 
2555       const { fontSize } = textState;
2556       textContentItem.trackingSpaceMin = fontSize * TRACKING_SPACE_FACTOR;
2557       textContentItem.notASpace = fontSize * NOT_A_SPACE_FACTOR;
2558       textContentItem.negativeSpaceMax = fontSize * NEGATIVE_SPACE_FACTOR;
2559       textContentItem.spaceInFlowMin = fontSize * SPACE_IN_FLOW_MIN_FACTOR;
2560       textContentItem.spaceInFlowMax = fontSize * SPACE_IN_FLOW_MAX_FACTOR;
2561       textContentItem.hasEOL = false;
2562 
2563       textContentItem.initialized = true;
2564       return textContentItem;
2565     }
2566 
2567     function updateAdvanceScale() {
2568       if (!textContentItem.initialized) {
2569         return;
2570       }
2571 
2572       const scaleLineX = Math.hypot(
2573         textState.textLineMatrix[0],
2574         textState.textLineMatrix[1]
2575       );
2576       const scaleCtmX = Math.hypot(textState.ctm[0], textState.ctm[1]);
2577       const scaleFactor = scaleCtmX * scaleLineX;
2578       if (scaleFactor === textContentItem.textAdvanceScale) {
2579         return;
2580       }
2581 
2582       if (!textContentItem.vertical) {
2583         textContentItem.totalWidth +=
2584           textContentItem.width * textContentItem.textAdvanceScale;
2585         textContentItem.width = 0;
2586       } else {
2587         textContentItem.totalHeight +=
2588           textContentItem.height * textContentItem.textAdvanceScale;
2589         textContentItem.height = 0;
2590       }
2591 
2592       textContentItem.textAdvanceScale = scaleFactor;
2593     }
2594 
2595     function runBidiTransform(textChunk) {
2596       let text = textChunk.str.join("");
2597       if (!disableNormalization) {
2598         text = normalizeUnicode(text);
2599       }
2600       const bidiResult = bidi(text, -1, textChunk.vertical);
2601       return {
2602         str: bidiResult.str,
2603         dir: bidiResult.dir,
2604         width: Math.abs(textChunk.totalWidth),
2605         height: Math.abs(textChunk.totalHeight),
2606         transform: textChunk.transform,
2607         fontName: textChunk.fontName,
2608         hasEOL: textChunk.hasEOL,
2609       };
2610     }
2611 
2612     async function handleSetFont(fontName, fontRef) {
2613       const translated = await self.loadFont(fontName, fontRef, resources);
2614 
2615       if (translated.font.isType3Font) {
2616         try {
2617           await translated.loadType3Data(self, resources, task);
2618         } catch {
2619           // Ignore Type3-parsing errors, since we only use `loadType3Data`
2620           // here to ensure that we'll always obtain a useful /FontBBox.
2621         }
2622       }
2623 
2624       textState.loadedName = translated.loadedName;
2625       textState.font = translated.font;
2626       textState.fontMatrix = translated.font.fontMatrix || FONT_IDENTITY_MATRIX;
2627     }
2628 
2629     function applyInverseRotation(x, y, matrix) {
2630       const scale = Math.hypot(matrix[0], matrix[1]);
2631       return [
2632         (matrix[0] * x + matrix[1] * y) / scale,
2633         (matrix[2] * x + matrix[3] * y) / scale,
2634       ];
2635     }
2636 
2637     function compareWithLastPosition(glyphWidth) {
2638       const currentTransform = getCurrentTextTransform();
2639       let posX = currentTransform[4];
2640       let posY = currentTransform[5];
2641 
2642       // Check if the glyph is in the viewbox.
2643       if (textState.font?.vertical) {
2644         if (
2645           posX < viewBox[0] ||
2646           posX > viewBox[2] ||
2647           posY + glyphWidth < viewBox[1] ||
2648           posY > viewBox[3]
2649         ) {
2650           return false;
2651         }
2652       } else if (
2653         posX + glyphWidth < viewBox[0] ||
2654         posX > viewBox[2] ||
2655         posY < viewBox[1] ||
2656         posY > viewBox[3]
2657       ) {
2658         return false;
2659       }
2660 
2661       if (!textState.font || !textContentItem.prevTransform) {
2662         return true;
2663       }
2664 
2665       let lastPosX = textContentItem.prevTransform[4];
2666       let lastPosY = textContentItem.prevTransform[5];
2667 
2668       if (lastPosX === posX && lastPosY === posY) {
2669         return true;
2670       }
2671 
2672       let rotate = -1;
2673       // Take into account the rotation is the current transform.
2674       if (
2675         currentTransform[0] &&
2676         currentTransform[1] === 0 &&
2677         currentTransform[2] === 0
2678       ) {
2679         rotate = currentTransform[0] > 0 ? 0 : 180;
2680       } else if (
2681         currentTransform[1] &&
2682         currentTransform[0] === 0 &&
2683         currentTransform[3] === 0
2684       ) {
2685         rotate = currentTransform[1] > 0 ? 90 : 270;
2686       }
2687 
2688       switch (rotate) {
2689         case 0:
2690           break;
2691         case 90:
2692           [posX, posY] = [posY, posX];
2693           [lastPosX, lastPosY] = [lastPosY, lastPosX];
2694           break;
2695         case 180:
2696           [posX, posY, lastPosX, lastPosY] = [
2697             -posX,
2698             -posY,
2699             -lastPosX,
2700             -lastPosY,
2701           ];
2702           break;
2703         case 270:
2704           [posX, posY] = [-posY, -posX];
2705           [lastPosX, lastPosY] = [-lastPosY, -lastPosX];
2706           break;
2707         default:
2708           // This is not a 0, 90, 180, 270 rotation so:
2709           //  - remove the scale factor from the matrix to get a rotation matrix
2710           //  - apply the inverse (which is the transposed) to the positions
2711           // and we can then compare positions of the glyphes to detect
2712           // a whitespace.
2713           [posX, posY] = applyInverseRotation(posX, posY, currentTransform);
2714           [lastPosX, lastPosY] = applyInverseRotation(
2715             lastPosX,
2716             lastPosY,
2717             textContentItem.prevTransform
2718           );
2719       }
2720 
2721       if (textState.font.vertical) {
2722         const advanceY = (lastPosY - posY) / textContentItem.textAdvanceScale;
2723         const advanceX = posX - lastPosX;
2724 
2725         // When the total height of the current chunk is negative
2726         // then we're writing from bottom to top.
2727         const textOrientation = Math.sign(textContentItem.height);
2728         if (advanceY < textOrientation * textContentItem.negativeSpaceMax) {
2729           if (
2730             Math.abs(advanceX) >
2731             0.5 * textContentItem.width /* not the same column */
2732           ) {
2733             appendEOL();
2734             return true;
2735           }
2736 
2737           resetLastChars();
2738           flushTextContentItem();
2739           return true;
2740         }
2741 
2742         if (Math.abs(advanceX) > textContentItem.width) {
2743           appendEOL();
2744           return true;
2745         }
2746 
2747         if (advanceY <= textOrientation * textContentItem.notASpace) {
2748           // The real spacing between 2 consecutive chars is thin enough to be
2749           // considered a non-space.
2750           resetLastChars();
2751         }
2752 
2753         if (advanceY <= textOrientation * textContentItem.trackingSpaceMin) {
2754           if (shouldAddWhitepsace()) {
2755             // The space is very thin, hence it deserves to have its own span in
2756             // order to avoid too much shift between the canvas and the text
2757             // layer.
2758             resetLastChars();
2759             flushTextContentItem();
2760             pushWhitespace({ height: Math.abs(advanceY) });
2761           } else {
2762             textContentItem.height += advanceY;
2763           }
2764         } else if (
2765           !addFakeSpaces(
2766             advanceY,
2767             textContentItem.prevTransform,
2768             textOrientation
2769           )
2770         ) {
2771           if (textContentItem.str.length === 0) {
2772             resetLastChars();
2773             pushWhitespace({ height: Math.abs(advanceY) });
2774           } else {
2775             textContentItem.height += advanceY;
2776           }
2777         }
2778 
2779         if (Math.abs(advanceX) > textContentItem.width * VERTICAL_SHIFT_RATIO) {
2780           flushTextContentItem();
2781         }
2782 
2783         return true;
2784       }
2785 
2786       const advanceX = (posX - lastPosX) / textContentItem.textAdvanceScale;
2787       const advanceY = posY - lastPosY;
2788 
2789       // When the total width of the current chunk is negative
2790       // then we're writing from right to left.
2791       const textOrientation = Math.sign(textContentItem.width);
2792       if (advanceX < textOrientation * textContentItem.negativeSpaceMax) {
2793         if (
2794           Math.abs(advanceY) >
2795           0.5 * textContentItem.height /* not the same line */
2796         ) {
2797           appendEOL();
2798           return true;
2799         }
2800 
2801         // We're moving back so in case the last char was a whitespace
2802         // we cancel it: it doesn't make sense to insert it.
2803         resetLastChars();
2804         flushTextContentItem();
2805         return true;
2806       }
2807 
2808       if (Math.abs(advanceY) > textContentItem.height) {
2809         appendEOL();
2810         return true;
2811       }
2812 
2813       if (advanceX <= textOrientation * textContentItem.notASpace) {
2814         // The real spacing between 2 consecutive chars is thin enough to be
2815         // considered a non-space.
2816         resetLastChars();
2817       }
2818 
2819       if (advanceX <= textOrientation * textContentItem.trackingSpaceMin) {
2820         if (shouldAddWhitepsace()) {
2821           // The space is very thin, hence it deserves to have its own span in
2822           // order to avoid too much shift between the canvas and the text
2823           // layer.
2824           resetLastChars();
2825           flushTextContentItem();
2826           pushWhitespace({ width: Math.abs(advanceX) });
2827         } else {
2828           textContentItem.width += advanceX;
2829         }
2830       } else if (
2831         !addFakeSpaces(advanceX, textContentItem.prevTransform, textOrientation)
2832       ) {
2833         if (textContentItem.str.length === 0) {
2834           resetLastChars();
2835           pushWhitespace({ width: Math.abs(advanceX) });
2836         } else {
2837           textContentItem.width += advanceX;
2838         }
2839       }
2840 
2841       if (Math.abs(advanceY) > textContentItem.height * VERTICAL_SHIFT_RATIO) {
2842         flushTextContentItem();
2843       }
2844 
2845       return true;
2846     }
2847 
2848     function buildTextContentItem({ chars, extraSpacing }) {
2849       const font = textState.font;
2850       if (!chars) {
2851         // Just move according to the space we have.
2852         const charSpacing = textState.charSpacing + extraSpacing;
2853         if (charSpacing) {
2854           if (!font.vertical) {
2855             textState.translateTextMatrix(
2856               charSpacing * textState.textHScale,
2857               0
2858             );
2859           } else {
2860             textState.translateTextMatrix(0, -charSpacing);
2861           }
2862         }
2863 
2864         if (keepWhiteSpace) {
2865           compareWithLastPosition(0);
2866         }
2867 
2868         return;
2869       }
2870 
2871       const glyphs = font.charsToGlyphs(chars);
2872       const scale = textState.fontMatrix[0] * textState.fontSize;
2873 
2874       for (let i = 0, ii = glyphs.length; i < ii; i++) {
2875         const glyph = glyphs[i];
2876         const { category } = glyph;
2877 
2878         if (category.isInvisibleFormatMark) {
2879           continue;
2880         }
2881         let charSpacing =
2882           textState.charSpacing + (i + 1 === ii ? extraSpacing : 0);
2883 
2884         let glyphWidth = glyph.width;
2885         if (font.vertical) {
2886           glyphWidth = glyph.vmetric ? glyph.vmetric[0] : -glyphWidth;
2887         }
2888         let scaledDim = glyphWidth * scale;
2889 
2890         if (!keepWhiteSpace && category.isWhitespace) {
2891           // Don't push a " " in the textContentItem
2892           // (except when it's between two non-spaces chars),
2893           // it will be done (if required) in next call to
2894           // compareWithLastPosition.
2895           // This way we can merge real spaces and spaces due to cursor moves.
2896           if (!font.vertical) {
2897             charSpacing += scaledDim + textState.wordSpacing;
2898             textState.translateTextMatrix(
2899               charSpacing * textState.textHScale,
2900               0
2901             );
2902           } else {
2903             charSpacing += -scaledDim + textState.wordSpacing;
2904             textState.translateTextMatrix(0, -charSpacing);
2905           }
2906           saveLastChar(" ");
2907           continue;
2908         }
2909 
2910         if (
2911           !category.isZeroWidthDiacritic &&
2912           !compareWithLastPosition(scaledDim)
2913         ) {
2914           // The glyph is not in page so just skip it but move the cursor.
2915           if (!font.vertical) {
2916             textState.translateTextMatrix(scaledDim * textState.textHScale, 0);
2917           } else {
2918             textState.translateTextMatrix(0, scaledDim);
2919           }
2920           continue;
2921         }
2922 
2923         // Must be called after compareWithLastPosition because
2924         // the textContentItem could have been flushed.
2925         const textChunk = ensureTextContentItem();
2926         if (category.isZeroWidthDiacritic) {
2927           scaledDim = 0;
2928         }
2929 
2930         if (!font.vertical) {
2931           scaledDim *= textState.textHScale;
2932           textState.translateTextMatrix(scaledDim, 0);
2933           textChunk.width += scaledDim;
2934         } else {
2935           textState.translateTextMatrix(0, scaledDim);
2936           scaledDim = Math.abs(scaledDim);
2937           textChunk.height += scaledDim;
2938         }
2939 
2940         if (scaledDim) {
2941           // Save the position of the last visible character.
2942           textChunk.prevTransform = getCurrentTextTransform();
2943         }
2944 
2945         const glyphUnicode = glyph.unicode;
2946         if (saveLastChar(glyphUnicode)) {
2947           // The two last chars are a non-whitespace followed by a whitespace
2948           // and then this non-whitespace, so we insert a whitespace here.
2949           // Replaces all whitespaces with standard spaces (0x20), to avoid
2950           // alignment issues between the textLayer and the canvas if the text
2951           // contains e.g. tabs (fixes issue6612.pdf).
2952           textChunk.str.push(" ");
2953         }
2954         textChunk.str.push(glyphUnicode);
2955 
2956         if (charSpacing) {
2957           if (!font.vertical) {
2958             textState.translateTextMatrix(
2959               charSpacing * textState.textHScale,
2960               0
2961             );
2962           } else {
2963             textState.translateTextMatrix(0, -charSpacing);
2964           }
2965         }
2966       }
2967     }
2968 
2969     function appendEOL() {
2970       resetLastChars();
2971       if (textContentItem.initialized) {
2972         textContentItem.hasEOL = true;
2973         flushTextContentItem();
2974       } else {
2975         textContent.items.push({
2976           str: "",
2977           dir: "ltr",
2978           width: 0,
2979           height: 0,
2980           transform: getCurrentTextTransform(),
2981           fontName: textState.loadedName,
2982           hasEOL: true,
2983         });
2984       }
2985     }
2986 
2987     function addFakeSpaces(width, transf, textOrientation) {
2988       if (
2989         textOrientation * textContentItem.spaceInFlowMin <= width &&
2990         width <= textOrientation * textContentItem.spaceInFlowMax
2991       ) {
2992         if (textContentItem.initialized) {
2993           resetLastChars();
2994           textContentItem.str.push(" ");
2995         }
2996         return false;
2997       }
2998 
2999       const fontName = textContentItem.fontName;
3000 
3001       let height = 0;
3002       if (textContentItem.vertical) {
3003         height = width;
3004         width = 0;
3005       }
3006 
3007       flushTextContentItem();
3008       resetLastChars();
3009       pushWhitespace({
3010         width: Math.abs(width),
3011         height: Math.abs(height),
3012         transform: transf || getCurrentTextTransform(),
3013         fontName,
3014       });
3015 
3016       return true;
3017     }
3018 
3019     function flushTextContentItem() {
3020       if (!textContentItem.initialized || !textContentItem.str) {
3021         return;
3022       }
3023 
3024       // Do final text scaling.
3025       if (!textContentItem.vertical) {
3026         textContentItem.totalWidth +=
3027           textContentItem.width * textContentItem.textAdvanceScale;
3028       } else {
3029         textContentItem.totalHeight +=
3030           textContentItem.height * textContentItem.textAdvanceScale;
3031       }
3032 
3033       textContent.items.push(runBidiTransform(textContentItem));
3034       textContentItem.initialized = false;
3035       textContentItem.str.length = 0;
3036     }
3037 
3038     function enqueueChunk(batch = false) {
3039       const length = textContent.items.length;
3040       if (length === 0) {
3041         return;
3042       }
3043       if (batch && length < TEXT_CHUNK_BATCH_SIZE) {
3044         return;
3045       }
3046       sink.enqueue(textContent, length);
3047       textContent.items = [];
3048       textContent.styles = Object.create(null);
3049     }
3050 
3051     const timeSlotManager = new TimeSlotManager();
3052 
3053     return new Promise(function promiseBody(resolve, reject) {
3054       const next = function (promise) {
3055         enqueueChunk(/* batch = */ true);
3056         Promise.all([promise, sink.ready]).then(function () {
3057           try {
3058             promiseBody(resolve, reject);
3059           } catch (ex) {
3060             reject(ex);
3061           }
3062         }, reject);
3063       };
3064       task.ensureNotTerminated();
3065       timeSlotManager.reset();
3066 
3067       const operation = {};
3068       let stop,
3069         args = [];
3070       while (!(stop = timeSlotManager.check())) {
3071         // The arguments parsed by read() are not used beyond this loop, so
3072         // we can reuse the same array on every iteration, thus avoiding
3073         // unnecessary allocations.
3074         args.length = 0;
3075         operation.args = args;
3076         if (!preprocessor.read(operation)) {
3077           break;
3078         }
3079 
3080         const previousState = textState;
3081         textState = stateManager.state;
3082         const fn = operation.fn;
3083         args = operation.args;
3084 
3085         switch (fn | 0) {
3086           case OPS.setFont:
3087             // Optimization to ignore multiple identical Tf commands.
3088             var fontNameArg = args[0].name,
3089               fontSizeArg = args[1];
3090             if (
3091               textState.font &&
3092               fontNameArg === textState.fontName &&
3093               fontSizeArg === textState.fontSize
3094             ) {
3095               break;
3096             }
3097 
3098             flushTextContentItem();
3099             textState.fontName = fontNameArg;
3100             textState.fontSize = fontSizeArg;
3101             next(handleSetFont(fontNameArg, null));
3102             return;
3103           case OPS.setTextRise:
3104             textState.textRise = args[0];
3105             break;
3106           case OPS.setHScale:
3107             textState.textHScale = args[0] / 100;
3108             break;
3109           case OPS.setLeading:
3110             textState.leading = args[0];
3111             break;
3112           case OPS.moveText:
3113             textState.translateTextLineMatrix(args[0], args[1]);
3114             textState.textMatrix = textState.textLineMatrix.slice();
3115             break;
3116           case OPS.setLeadingMoveText:
3117             textState.leading = -args[1];
3118             textState.translateTextLineMatrix(args[0], args[1]);
3119             textState.textMatrix = textState.textLineMatrix.slice();
3120             break;
3121           case OPS.nextLine:
3122             textState.carriageReturn();
3123             break;
3124           case OPS.setTextMatrix:
3125             textState.setTextMatrix(
3126               args[0],
3127               args[1],
3128               args[2],
3129               args[3],
3130               args[4],
3131               args[5]
3132             );
3133             textState.setTextLineMatrix(
3134               args[0],
3135               args[1],
3136               args[2],
3137               args[3],
3138               args[4],
3139               args[5]
3140             );
3141             updateAdvanceScale();
3142             break;
3143           case OPS.setCharSpacing:
3144             textState.charSpacing = args[0];
3145             break;
3146           case OPS.setWordSpacing:
3147             textState.wordSpacing = args[0];
3148             break;
3149           case OPS.beginText:
3150             textState.textMatrix = IDENTITY_MATRIX.slice();
3151             textState.textLineMatrix = IDENTITY_MATRIX.slice();
3152             break;
3153           case OPS.showSpacedText:
3154             if (!stateManager.state.font) {
3155               self.ensureStateFont(stateManager.state);
3156               continue;
3157             }
3158 
3159             const spaceFactor =
3160               ((textState.font.vertical ? 1 : -1) * textState.fontSize) / 1000;
3161             const elements = args[0];
3162             for (let i = 0, ii = elements.length; i < ii; i++) {
3163               const item = elements[i];
3164               if (typeof item === "string") {
3165                 showSpacedTextBuffer.push(item);
3166               } else if (typeof item === "number" && item !== 0) {
3167                 // PDF Specification 5.3.2 states:
3168                 // The number is expressed in thousandths of a unit of text
3169                 // space.
3170                 // This amount is subtracted from the current horizontal or
3171                 // vertical coordinate, depending on the writing mode.
3172                 // In the default coordinate system, a positive adjustment
3173                 // has the effect of moving the next glyph painted either to
3174                 // the left or down by the given amount.
3175                 const str = showSpacedTextBuffer.join("");
3176                 showSpacedTextBuffer.length = 0;
3177                 buildTextContentItem({
3178                   chars: str,
3179                   extraSpacing: item * spaceFactor,
3180                 });
3181               }
3182             }
3183 
3184             if (showSpacedTextBuffer.length > 0) {
3185               const str = showSpacedTextBuffer.join("");
3186               showSpacedTextBuffer.length = 0;
3187               buildTextContentItem({
3188                 chars: str,
3189                 extraSpacing: 0,
3190               });
3191             }
3192             break;
3193           case OPS.showText:
3194             if (!stateManager.state.font) {
3195               self.ensureStateFont(stateManager.state);
3196               continue;
3197             }
3198             buildTextContentItem({
3199               chars: args[0],
3200               extraSpacing: 0,
3201             });
3202             break;
3203           case OPS.nextLineShowText:
3204             if (!stateManager.state.font) {
3205               self.ensureStateFont(stateManager.state);
3206               continue;
3207             }
3208             textState.carriageReturn();
3209             buildTextContentItem({
3210               chars: args[0],
3211               extraSpacing: 0,
3212             });
3213             break;
3214           case OPS.nextLineSetSpacingShowText:
3215             if (!stateManager.state.font) {
3216               self.ensureStateFont(stateManager.state);
3217               continue;
3218             }
3219             textState.wordSpacing = args[0];
3220             textState.charSpacing = args[1];
3221             textState.carriageReturn();
3222             buildTextContentItem({
3223               chars: args[2],
3224               extraSpacing: 0,
3225             });
3226             break;
3227           case OPS.paintXObject:
3228             flushTextContentItem();
3229             if (!xobjs) {
3230               xobjs = resources.get("XObject") || Dict.empty;
3231             }
3232 
3233             var isValidName = args[0] instanceof Name;
3234             var name = args[0].name;
3235 
3236             if (isValidName && emptyXObjectCache.getByName(name)) {
3237               break;
3238             }
3239 
3240             next(
3241               new Promise(function (resolveXObject, rejectXObject) {
3242                 if (!isValidName) {
3243                   throw new FormatError("XObject must be referred to by name.");
3244                 }
3245 
3246                 let xobj = xobjs.getRaw(name);
3247                 if (xobj instanceof Ref) {
3248                   if (emptyXObjectCache.getByRef(xobj)) {
3249                     resolveXObject();
3250                     return;
3251                   }
3252 
3253                   const globalImage = self.globalImageCache.getData(
3254                     xobj,
3255                     self.pageIndex
3256                   );
3257                   if (globalImage) {
3258                     resolveXObject();
3259                     return;
3260                   }
3261 
3262                   xobj = xref.fetch(xobj);
3263                 }
3264 
3265                 if (!(xobj instanceof BaseStream)) {
3266                   throw new FormatError("XObject should be a stream");
3267                 }
3268 
3269                 const type = xobj.dict.get("Subtype");
3270                 if (!(type instanceof Name)) {
3271                   throw new FormatError("XObject should have a Name subtype");
3272                 }
3273 
3274                 if (type.name !== "Form") {
3275                   emptyXObjectCache.set(name, xobj.dict.objId, true);
3276 
3277                   resolveXObject();
3278                   return;
3279                 }
3280 
3281                 // Use a new `StateManager` to prevent incorrect positioning
3282                 // of textItems *after* the Form XObject, since errors in the
3283                 // data can otherwise prevent `restore` operators from
3284                 // executing.
3285                 // NOTE: Only an issue when `options.ignoreErrors === true`.
3286                 const currentState = stateManager.state.clone();
3287                 const xObjStateManager = new StateManager(currentState);
3288 
3289                 const matrix = lookupMatrix(xobj.dict.getArray("Matrix"), null);
3290                 if (matrix) {
3291                   xObjStateManager.transform(matrix);
3292                 }
3293 
3294                 // Enqueue the `textContent` chunk before parsing the /Form
3295                 // XObject.
3296                 enqueueChunk();
3297                 const sinkWrapper = {
3298                   enqueueInvoked: false,
3299 
3300                   enqueue(chunk, size) {
3301                     this.enqueueInvoked = true;
3302                     sink.enqueue(chunk, size);
3303                   },
3304 
3305                   get desiredSize() {
3306                     return sink.desiredSize;
3307                   },
3308 
3309                   get ready() {
3310                     return sink.ready;
3311                   },
3312                 };
3313 
3314                 self
3315                   .getTextContent({
3316                     stream: xobj,
3317                     task,
3318                     resources: xobj.dict.get("Resources") || resources,
3319                     stateManager: xObjStateManager,
3320                     includeMarkedContent,
3321                     sink: sinkWrapper,
3322                     seenStyles,
3323                     viewBox,
3324                     lang,
3325                     markedContentData,
3326                     disableNormalization,
3327                     keepWhiteSpace,
3328                   })
3329                   .then(function () {
3330                     if (!sinkWrapper.enqueueInvoked) {
3331                       emptyXObjectCache.set(name, xobj.dict.objId, true);
3332                     }
3333                     resolveXObject();
3334                   }, rejectXObject);
3335               }).catch(function (reason) {
3336                 if (reason instanceof AbortException) {
3337                   return;
3338                 }
3339                 if (self.options.ignoreErrors) {
3340                   // Error(s) in the XObject -- allow text-extraction to
3341                   // continue.
3342                   warn(`getTextContent - ignoring XObject: "${reason}".`);
3343                   return;
3344                 }
3345                 throw reason;
3346               })
3347             );
3348             return;
3349           case OPS.setGState:
3350             isValidName = args[0] instanceof Name;
3351             name = args[0].name;
3352 
3353             if (isValidName && emptyGStateCache.getByName(name)) {
3354               break;
3355             }
3356 
3357             next(
3358               new Promise(function (resolveGState, rejectGState) {
3359                 if (!isValidName) {
3360                   throw new FormatError("GState must be referred to by name.");
3361                 }
3362 
3363                 const extGState = resources.get("ExtGState");
3364                 if (!(extGState instanceof Dict)) {
3365                   throw new FormatError("ExtGState should be a dictionary.");
3366                 }
3367 
3368                 const gState = extGState.get(name);
3369                 // TODO: Attempt to lookup cached GStates by reference as well,
3370                 //       if and only if there are PDF documents where doing so
3371                 //       would significantly improve performance.
3372                 if (!(gState instanceof Dict)) {
3373                   throw new FormatError("GState should be a dictionary.");
3374                 }
3375 
3376                 const gStateFont = gState.get("Font");
3377                 if (!gStateFont) {
3378                   emptyGStateCache.set(name, gState.objId, true);
3379 
3380                   resolveGState();
3381                   return;
3382                 }
3383                 flushTextContentItem();
3384 
3385                 textState.fontName = null;
3386                 textState.fontSize = gStateFont[1];
3387                 handleSetFont(null, gStateFont[0]).then(
3388                   resolveGState,
3389                   rejectGState
3390                 );
3391               }).catch(function (reason) {
3392                 if (reason instanceof AbortException) {
3393                   return;
3394                 }
3395                 if (self.options.ignoreErrors) {
3396                   // Error(s) in the ExtGState -- allow text-extraction to
3397                   // continue.
3398                   warn(`getTextContent - ignoring ExtGState: "${reason}".`);
3399                   return;
3400                 }
3401                 throw reason;
3402               })
3403             );
3404             return;
3405           case OPS.beginMarkedContent:
3406             flushTextContentItem();
3407             if (includeMarkedContent) {
3408               markedContentData.level++;
3409 
3410               textContent.items.push({
3411                 type: "beginMarkedContent",
3412                 tag: args[0] instanceof Name ? args[0].name : null,
3413               });
3414             }
3415             break;
3416           case OPS.beginMarkedContentProps:
3417             flushTextContentItem();
3418             if (includeMarkedContent) {
3419               markedContentData.level++;
3420 
3421               let mcid = null;
3422               if (args[1] instanceof Dict) {
3423                 mcid = args[1].get("MCID");
3424               }
3425               textContent.items.push({
3426                 type: "beginMarkedContentProps",
3427                 id: Number.isInteger(mcid)
3428                   ? `${self.idFactory.getPageObjId()}_mc${mcid}`
3429                   : null,
3430                 tag: args[0] instanceof Name ? args[0].name : null,
3431               });
3432             }
3433             break;
3434           case OPS.endMarkedContent:
3435             flushTextContentItem();
3436             if (includeMarkedContent) {
3437               if (markedContentData.level === 0) {
3438                 // Handle unbalanced beginMarkedContent/endMarkedContent
3439                 // operators (fixes issue15629.pdf).
3440                 break;
3441               }
3442               markedContentData.level--;
3443 
3444               textContent.items.push({
3445                 type: "endMarkedContent",
3446               });
3447             }
3448             break;
3449           case OPS.restore:
3450             if (
3451               previousState &&
3452               (previousState.font !== textState.font ||
3453                 previousState.fontSize !== textState.fontSize ||
3454                 previousState.fontName !== textState.fontName)
3455             ) {
3456               flushTextContentItem();
3457             }
3458             break;
3459         } // switch
3460         if (textContent.items.length >= sink.desiredSize) {
3461           // Wait for ready, if we reach highWaterMark.
3462           stop = true;
3463           break;
3464         }
3465       } // while
3466       if (stop) {
3467         next(deferred);
3468         return;
3469       }
3470       flushTextContentItem();
3471       enqueueChunk();
3472       resolve();
3473     }).catch(reason => {
3474       if (reason instanceof AbortException) {
3475         return;
3476       }
3477       if (this.options.ignoreErrors) {
3478         // Error(s) in the TextContent -- allow text-extraction to continue.
3479         warn(
3480           `getTextContent - ignoring errors during "${task.name}" ` +
3481             `task: "${reason}".`
3482         );
3483 
3484         flushTextContentItem();
3485         enqueueChunk();
3486         return;
3487       }
3488       throw reason;
3489     });
3490   }
3491 
3492   async extractDataStructures(dict, properties) {
3493     const xref = this.xref;
3494     let cidToGidBytes;
3495     // 9.10.2
3496     const toUnicodePromise = this.readToUnicode(properties.toUnicode);
3497 
3498     if (properties.composite) {
3499       // CIDSystemInfo helps to match CID to glyphs
3500       const cidSystemInfo = dict.get("CIDSystemInfo");
3501       if (cidSystemInfo instanceof Dict) {
3502         properties.cidSystemInfo = {
3503           registry: stringToPDFString(cidSystemInfo.get("Registry")),
3504           ordering: stringToPDFString(cidSystemInfo.get("Ordering")),
3505           supplement: cidSystemInfo.get("Supplement"),
3506         };
3507       }
3508 
3509       try {
3510         const cidToGidMap = dict.get("CIDToGIDMap");
3511         if (cidToGidMap instanceof BaseStream) {
3512           cidToGidBytes = cidToGidMap.getBytes();
3513         }
3514       } catch (ex) {
3515         if (!this.options.ignoreErrors) {
3516           throw ex;
3517         }
3518         warn(`extractDataStructures - ignoring CIDToGIDMap data: "${ex}".`);
3519       }
3520     }
3521 
3522     // Based on 9.6.6 of the spec the encoding can come from multiple places
3523     // and depends on the font type. The base encoding and differences are
3524     // read here, but the encoding that is actually used is chosen during
3525     // glyph mapping in the font.
3526     // TODO: Loading the built in encoding in the font would allow the
3527     // differences to be merged in here not require us to hold on to it.
3528     const differences = [];
3529     let baseEncodingName = null;
3530     let encoding;
3531     if (dict.has("Encoding")) {
3532       encoding = dict.get("Encoding");
3533       if (encoding instanceof Dict) {
3534         baseEncodingName = encoding.get("BaseEncoding");
3535         baseEncodingName =
3536           baseEncodingName instanceof Name ? baseEncodingName.name : null;
3537         // Load the differences between the base and original
3538         if (encoding.has("Differences")) {
3539           const diffEncoding = encoding.get("Differences");
3540           let index = 0;
3541           for (const entry of diffEncoding) {
3542             const data = xref.fetchIfRef(entry);
3543             if (typeof data === "number") {
3544               index = data;
3545             } else if (data instanceof Name) {
3546               differences[index++] = data.name;
3547             } else {
3548               throw new FormatError(
3549                 `Invalid entry in 'Differences' array: ${data}`
3550               );
3551             }
3552           }
3553         }
3554       } else if (encoding instanceof Name) {
3555         baseEncodingName = encoding.name;
3556       } else {
3557         const msg = "Encoding is not a Name nor a Dict";
3558 
3559         if (!this.options.ignoreErrors) {
3560           throw new FormatError(msg);
3561         }
3562         warn(msg);
3563       }
3564       // According to table 114 if the encoding is a named encoding it must be
3565       // one of these predefined encodings.
3566       if (
3567         baseEncodingName !== "MacRomanEncoding" &&
3568         baseEncodingName !== "MacExpertEncoding" &&
3569         baseEncodingName !== "WinAnsiEncoding"
3570       ) {
3571         baseEncodingName = null;
3572       }
3573     }
3574 
3575     const nonEmbeddedFont = !properties.file || properties.isInternalFont,
3576       isSymbolsFontName = getSymbolsFonts()[properties.name];
3577     // Ignore an incorrectly specified named encoding for non-embedded
3578     // symbol fonts (fixes issue16464.pdf).
3579     if (baseEncodingName && nonEmbeddedFont && isSymbolsFontName) {
3580       baseEncodingName = null;
3581     }
3582 
3583     if (baseEncodingName) {
3584       properties.defaultEncoding = getEncoding(baseEncodingName);
3585     } else {
3586       const isSymbolicFont = !!(properties.flags & FontFlags.Symbolic);
3587       const isNonsymbolicFont = !!(properties.flags & FontFlags.Nonsymbolic);
3588       // According to "Table 114" in section "9.6.6.1 General" (under
3589       // "9.6.6 Character Encoding") of the PDF specification, a Nonsymbolic
3590       // font should use the `StandardEncoding` if no encoding is specified.
3591       encoding = StandardEncoding;
3592       if (properties.type === "TrueType" && !isNonsymbolicFont) {
3593         encoding = WinAnsiEncoding;
3594       }
3595       // The Symbolic attribute can be misused for regular fonts
3596       // Heuristic: we have to check if the font is a standard one also
3597       if (isSymbolicFont || isSymbolsFontName) {
3598         encoding = MacRomanEncoding;
3599         if (nonEmbeddedFont) {
3600           if (/Symbol/i.test(properties.name)) {
3601             encoding = SymbolSetEncoding;
3602           } else if (/Dingbats/i.test(properties.name)) {
3603             encoding = ZapfDingbatsEncoding;
3604           } else if (/Wingdings/i.test(properties.name)) {
3605             encoding = WinAnsiEncoding;
3606           }
3607         }
3608       }
3609       properties.defaultEncoding = encoding;
3610     }
3611 
3612     properties.differences = differences;
3613     properties.baseEncodingName = baseEncodingName;
3614     properties.hasEncoding = !!baseEncodingName || differences.length > 0;
3615     properties.dict = dict;
3616 
3617     properties.toUnicode = await toUnicodePromise;
3618 
3619     const builtToUnicode = await this.buildToUnicode(properties);
3620     properties.toUnicode = builtToUnicode;
3621 
3622     if (cidToGidBytes) {
3623       properties.cidToGidMap = this.readCidToGidMap(
3624         cidToGidBytes,
3625         builtToUnicode
3626       );
3627     }
3628     return properties;
3629   }
3630 
3631   /**
3632    * @returns {Array}
3633    * @private
3634    */
3635   _simpleFontToUnicode(properties, forceGlyphs = false) {
3636     assert(!properties.composite, "Must be a simple font.");
3637 
3638     const toUnicode = [];
3639     const encoding = properties.defaultEncoding.slice();
3640     const baseEncodingName = properties.baseEncodingName;
3641     // Merge in the differences array.
3642     const differences = properties.differences;
3643     for (const charcode in differences) {
3644       const glyphName = differences[charcode];
3645       if (glyphName === ".notdef") {
3646         // Skip .notdef to prevent rendering errors, e.g. boxes appearing
3647         // where there should be spaces (fixes issue5256.pdf).
3648         continue;
3649       }
3650       encoding[charcode] = glyphName;
3651     }
3652     const glyphsUnicodeMap = getGlyphsUnicode();
3653     for (const charcode in encoding) {
3654       // a) Map the character code to a character name.
3655       let glyphName = encoding[charcode];
3656       if (glyphName === "") {
3657         continue;
3658       }
3659       // b) Look up the character name in the Adobe Glyph List (see the
3660       //    Bibliography) to obtain the corresponding Unicode value.
3661       let unicode = glyphsUnicodeMap[glyphName];
3662       if (unicode !== undefined) {
3663         toUnicode[charcode] = String.fromCharCode(unicode);
3664         continue;
3665       }
3666       // (undocumented) c) Few heuristics to recognize unknown glyphs
3667       // NOTE: Adobe Reader does not do this step, but OSX Preview does
3668       let code = 0;
3669       switch (glyphName[0]) {
3670         case "G": // Gxx glyph
3671           if (glyphName.length === 3) {
3672             code = parseInt(glyphName.substring(1), 16);
3673           }
3674           break;
3675         case "g": // g00xx glyph
3676           if (glyphName.length === 5) {
3677             code = parseInt(glyphName.substring(1), 16);
3678           }
3679           break;
3680         case "C": // Cdd{d} glyph
3681         case "c": // cdd{d} glyph
3682           if (glyphName.length >= 3 && glyphName.length <= 4) {
3683             const codeStr = glyphName.substring(1);
3684 
3685             if (forceGlyphs) {
3686               code = parseInt(codeStr, 16);
3687               break;
3688             }
3689             // Normally the Cdd{d}/cdd{d} glyphName format will contain
3690             // regular, i.e. base 10, charCodes (see issue4550.pdf)...
3691             code = +codeStr;
3692 
3693             // ... however some PDF generators violate that assumption by
3694             // containing glyph, i.e. base 16, codes instead.
3695             // In that case we need to re-parse the *entire* encoding to
3696             // prevent broken text-selection (fixes issue9655_reduced.pdf).
3697             if (Number.isNaN(code) && Number.isInteger(parseInt(codeStr, 16))) {
3698               return this._simpleFontToUnicode(
3699                 properties,
3700                 /* forceGlyphs */ true
3701               );
3702             }
3703           }
3704           break;
3705         case "u": // 'uniXXXX'/'uXXXX{XX}' glyphs
3706           unicode = getUnicodeForGlyph(glyphName, glyphsUnicodeMap);
3707           if (unicode !== -1) {
3708             code = unicode;
3709           }
3710           break;
3711         default:
3712           // Support (some) non-standard ligatures.
3713           switch (glyphName) {
3714             case "f_h":
3715             case "f_t":
3716             case "T_h":
3717               toUnicode[charcode] = glyphName.replaceAll("_", "");
3718               continue;
3719           }
3720           break;
3721       }
3722       if (code > 0 && code <= 0x10ffff && Number.isInteger(code)) {
3723         // If `baseEncodingName` is one the predefined encodings, and `code`
3724         // equals `charcode`, using the glyph defined in the baseEncoding
3725         // seems to yield a better `toUnicode` mapping (fixes issue 5070).
3726         if (baseEncodingName && code === +charcode) {
3727           const baseEncoding = getEncoding(baseEncodingName);
3728           if (baseEncoding && (glyphName = baseEncoding[charcode])) {
3729             toUnicode[charcode] = String.fromCharCode(
3730               glyphsUnicodeMap[glyphName]
3731             );
3732             continue;
3733           }
3734         }
3735         toUnicode[charcode] = String.fromCodePoint(code);
3736       }
3737     }
3738     return toUnicode;
3739   }
3740 
3741   /**
3742    * Builds a char code to unicode map based on section 9.10 of the spec.
3743    * @param {Object} properties Font properties object.
3744    * @returns {Promise} A Promise that is resolved with a
3745    *   {ToUnicodeMap|IdentityToUnicodeMap} object.
3746    */
3747   async buildToUnicode(properties) {
3748     properties.hasIncludedToUnicodeMap = properties.toUnicode?.length > 0;
3749 
3750     // Section 9.10.2 Mapping Character Codes to Unicode Values
3751     if (properties.hasIncludedToUnicodeMap) {
3752       // Some fonts contain incomplete ToUnicode data, causing issues with
3753       // text-extraction. For simple fonts, containing encoding information,
3754       // use a fallback ToUnicode map to improve this (fixes issue8229.pdf).
3755       if (!properties.composite && properties.hasEncoding) {
3756         properties.fallbackToUnicode = this._simpleFontToUnicode(properties);
3757       }
3758       return properties.toUnicode;
3759     }
3760 
3761     // According to the spec if the font is a simple font we should only map
3762     // to unicode if the base encoding is MacRoman, MacExpert, or WinAnsi or
3763     // the differences array only contains adobe standard or symbol set names,
3764     // in pratice it seems better to always try to create a toUnicode map
3765     // based of the default encoding.
3766     if (!properties.composite /* is simple font */) {
3767       return new ToUnicodeMap(this._simpleFontToUnicode(properties));
3768     }
3769 
3770     // If the font is a composite font that uses one of the predefined CMaps
3771     // listed in Table 118 (except Identity–H and Identity–V) or whose
3772     // descendant CIDFont uses the Adobe-GB1, Adobe-CNS1, Adobe-Japan1, or
3773     // Adobe-Korea1 character collection:
3774     if (
3775       properties.composite &&
3776       ((properties.cMap.builtInCMap &&
3777         !(properties.cMap instanceof IdentityCMap)) ||
3778         // The font is supposed to have a CIDSystemInfo dictionary, but some
3779         // PDFs don't include it (fixes issue 17689), hence the `?'.
3780         (properties.cidSystemInfo?.registry === "Adobe" &&
3781           (properties.cidSystemInfo.ordering === "GB1" ||
3782             properties.cidSystemInfo.ordering === "CNS1" ||
3783             properties.cidSystemInfo.ordering === "Japan1" ||
3784             properties.cidSystemInfo.ordering === "Korea1")))
3785     ) {
3786       // Then:
3787       // a) Map the character code to a character identifier (CID) according
3788       // to the font’s CMap.
3789       // b) Obtain the registry and ordering of the character collection used
3790       // by the font’s CMap (for example, Adobe and Japan1) from its
3791       // CIDSystemInfo dictionary.
3792       const { registry, ordering } = properties.cidSystemInfo;
3793       // c) Construct a second CMap name by concatenating the registry and
3794       // ordering obtained in step (b) in the format registry–ordering–UCS2
3795       // (for example, Adobe–Japan1–UCS2).
3796       const ucs2CMapName = Name.get(`${registry}-${ordering}-UCS2`);
3797       // d) Obtain the CMap with the name constructed in step (c) (available
3798       // from the ASN Web site; see the Bibliography).
3799       const ucs2CMap = await CMapFactory.create({
3800         encoding: ucs2CMapName,
3801         fetchBuiltInCMap: this._fetchBuiltInCMapBound,
3802         useCMap: null,
3803       });
3804       const toUnicode = [],
3805         buf = [];
3806       properties.cMap.forEach(function (charcode, cid) {
3807         if (cid > 0xffff) {
3808           throw new FormatError("Max size of CID is 65,535");
3809         }
3810         // e) Map the CID obtained in step (a) according to the CMap
3811         // obtained in step (d), producing a Unicode value.
3812         const ucs2 = ucs2CMap.lookup(cid);
3813         if (ucs2) {
3814           buf.length = 0;
3815           // Support multi-byte entries (fixes issue16176.pdf).
3816           for (let i = 0, ii = ucs2.length; i < ii; i += 2) {
3817             buf.push((ucs2.charCodeAt(i) << 8) + ucs2.charCodeAt(i + 1));
3818           }
3819           toUnicode[charcode] = String.fromCharCode(...buf);
3820         }
3821       });
3822       return new ToUnicodeMap(toUnicode);
3823     }
3824 
3825     // The viewer's choice, just use an identity map.
3826     return new IdentityToUnicodeMap(properties.firstChar, properties.lastChar);
3827   }
3828 
3829   async readToUnicode(cmapObj) {
3830     if (!cmapObj) {
3831       return null;
3832     }
3833     if (cmapObj instanceof Name) {
3834       const cmap = await CMapFactory.create({
3835         encoding: cmapObj,
3836         fetchBuiltInCMap: this._fetchBuiltInCMapBound,
3837         useCMap: null,
3838       });
3839 
3840       if (cmap instanceof IdentityCMap) {
3841         return new IdentityToUnicodeMap(0, 0xffff);
3842       }
3843       return new ToUnicodeMap(cmap.getMap());
3844     }
3845     if (cmapObj instanceof BaseStream) {
3846       try {
3847         const cmap = await CMapFactory.create({
3848           encoding: cmapObj,
3849           fetchBuiltInCMap: this._fetchBuiltInCMapBound,
3850           useCMap: null,
3851         });
3852 
3853         if (cmap instanceof IdentityCMap) {
3854           return new IdentityToUnicodeMap(0, 0xffff);
3855         }
3856         const map = new Array(cmap.length);
3857         // Convert UTF-16BE
3858         // NOTE: cmap can be a sparse array, so use forEach instead of
3859         // `for(;;)` to iterate over all keys.
3860         cmap.forEach(function (charCode, token) {
3861           // Some cmaps contain *only* CID characters (fixes issue9367.pdf).
3862           if (typeof token === "number") {
3863             map[charCode] = String.fromCodePoint(token);
3864             return;
3865           }
3866           const str = [];
3867           for (let k = 0; k < token.length; k += 2) {
3868             const w1 = (token.charCodeAt(k) << 8) | token.charCodeAt(k + 1);
3869             if ((w1 & 0xf800) !== 0xd800) {
3870               // w1 < 0xD800 || w1 > 0xDFFF
3871               str.push(w1);
3872               continue;
3873             }
3874             k += 2;
3875             const w2 = (token.charCodeAt(k) << 8) | token.charCodeAt(k + 1);
3876             str.push(((w1 & 0x3ff) << 10) + (w2 & 0x3ff) + 0x10000);
3877           }
3878           map[charCode] = String.fromCodePoint(...str);
3879         });
3880         return new ToUnicodeMap(map);
3881       } catch (reason) {
3882         if (reason instanceof AbortException) {
3883           return null;
3884         }
3885         if (this.options.ignoreErrors) {
3886           warn(`readToUnicode - ignoring ToUnicode data: "${reason}".`);
3887           return null;
3888         }
3889         throw reason;
3890       }
3891     }
3892     return null;
3893   }
3894 
3895   readCidToGidMap(glyphsData, toUnicode) {
3896     // Extract the encoding from the CIDToGIDMap
3897 
3898     // Set encoding 0 to later verify the font has an encoding
3899     const result = [];
3900     for (let j = 0, jj = glyphsData.length; j < jj; j++) {
3901       const glyphID = (glyphsData[j++] << 8) | glyphsData[j];
3902       const code = j >> 1;
3903       if (glyphID === 0 && !toUnicode.has(code)) {
3904         continue;
3905       }
3906       result[code] = glyphID;
3907     }
3908     return result;
3909   }
3910 
3911   extractWidths(dict, descriptor, properties) {
3912     const xref = this.xref;
3913     let glyphsWidths = [];
3914     let defaultWidth = 0;
3915     const glyphsVMetrics = [];
3916     let defaultVMetrics;
3917     if (properties.composite) {
3918       const dw = dict.get("DW");
3919       defaultWidth = Number.isInteger(dw) ? dw : 1000;
3920 
3921       const widths = dict.get("W");
3922       if (Array.isArray(widths)) {
3923         for (let i = 0, ii = widths.length; i < ii; i++) {
3924           let start = xref.fetchIfRef(widths[i++]);
3925           if (!Number.isInteger(start)) {
3926             break; // Invalid /W data.
3927           }
3928           const code = xref.fetchIfRef(widths[i]);
3929 
3930           if (Array.isArray(code)) {
3931             for (const c of code) {
3932               const width = xref.fetchIfRef(c);
3933               if (typeof width === "number") {
3934                 glyphsWidths[start] = width;
3935               }
3936               start++;
3937             }
3938           } else if (Number.isInteger(code)) {
3939             const width = xref.fetchIfRef(widths[++i]);
3940             if (typeof width !== "number") {
3941               continue;
3942             }
3943             for (let j = start; j <= code; j++) {
3944               glyphsWidths[j] = width;
3945             }
3946           } else {
3947             break; // Invalid /W data.
3948           }
3949         }
3950       }
3951 
3952       if (properties.vertical) {
3953         const dw2 = dict.getArray("DW2");
3954         let vmetrics = isNumberArray(dw2, 2) ? dw2 : [880, -1000];
3955         defaultVMetrics = [vmetrics[1], defaultWidth * 0.5, vmetrics[0]];
3956         vmetrics = dict.get("W2");
3957         if (Array.isArray(vmetrics)) {
3958           for (let i = 0, ii = vmetrics.length; i < ii; i++) {
3959             let start = xref.fetchIfRef(vmetrics[i++]);
3960             if (!Number.isInteger(start)) {
3961               break; // Invalid /W2 data.
3962             }
3963             const code = xref.fetchIfRef(vmetrics[i]);
3964 
3965             if (Array.isArray(code)) {
3966               for (let j = 0, jj = code.length; j < jj; j++) {
3967                 const vmetric = [
3968                   xref.fetchIfRef(code[j++]),
3969                   xref.fetchIfRef(code[j++]),
3970                   xref.fetchIfRef(code[j]),
3971                 ];
3972                 if (isNumberArray(vmetric, null)) {
3973                   glyphsVMetrics[start] = vmetric;
3974                 }
3975                 start++;
3976               }
3977             } else if (Number.isInteger(code)) {
3978               const vmetric = [
3979                 xref.fetchIfRef(vmetrics[++i]),
3980                 xref.fetchIfRef(vmetrics[++i]),
3981                 xref.fetchIfRef(vmetrics[++i]),
3982               ];
3983               if (!isNumberArray(vmetric, null)) {
3984                 continue;
3985               }
3986               for (let j = start; j <= code; j++) {
3987                 glyphsVMetrics[j] = vmetric;
3988               }
3989             } else {
3990               break; // Invalid /W2 data.
3991             }
3992           }
3993         }
3994       }
3995     } else {
3996       const widths = dict.get("Widths");
3997       if (Array.isArray(widths)) {
3998         let j = properties.firstChar;
3999         for (const w of widths) {
4000           const width = xref.fetchIfRef(w);
4001           if (typeof width === "number") {
4002             glyphsWidths[j] = width;
4003           }
4004           j++;
4005         }
4006         const missingWidth = descriptor.get("MissingWidth");
4007         defaultWidth = typeof missingWidth === "number" ? missingWidth : 0;
4008       } else {
4009         // Trying get the BaseFont metrics (see comment above).
4010         const baseFontName = dict.get("BaseFont");
4011         if (baseFontName instanceof Name) {
4012           const metrics = this.getBaseFontMetrics(baseFontName.name);
4013 
4014           glyphsWidths = this.buildCharCodeToWidth(metrics.widths, properties);
4015           defaultWidth = metrics.defaultWidth;
4016         }
4017       }
4018     }
4019 
4020     // Heuristic: detection of monospace font by checking all non-zero widths
4021     let isMonospace = true;
4022     let firstWidth = defaultWidth;
4023     for (const glyph in glyphsWidths) {
4024       const glyphWidth = glyphsWidths[glyph];
4025       if (!glyphWidth) {
4026         continue;
4027       }
4028       if (!firstWidth) {
4029         firstWidth = glyphWidth;
4030         continue;
4031       }
4032       if (firstWidth !== glyphWidth) {
4033         isMonospace = false;
4034         break;
4035       }
4036     }
4037     if (isMonospace) {
4038       properties.flags |= FontFlags.FixedPitch;
4039     } else {
4040       // Clear the flag.
4041       properties.flags &= ~FontFlags.FixedPitch;
4042     }
4043 
4044     properties.defaultWidth = defaultWidth;
4045     properties.widths = glyphsWidths;
4046     properties.defaultVMetrics = defaultVMetrics;
4047     properties.vmetrics = glyphsVMetrics;
4048   }
4049 
4050   isSerifFont(baseFontName) {
4051     // Simulating descriptor flags attribute
4052     const fontNameWoStyle = baseFontName.split("-", 1)[0];
4053     return (
4054       fontNameWoStyle in getSerifFonts() || /serif/gi.test(fontNameWoStyle)
4055     );
4056   }
4057 
4058   getBaseFontMetrics(name) {
4059     let defaultWidth = 0;
4060     let widths = Object.create(null);
4061     let monospace = false;
4062     const stdFontMap = getStdFontMap();
4063     let lookupName = stdFontMap[name] || name;
4064     const Metrics = getMetrics();
4065 
4066     if (!(lookupName in Metrics)) {
4067       // Use default fonts for looking up font metrics if the passed
4068       // font is not a base font
4069       lookupName = this.isSerifFont(name) ? "Times-Roman" : "Helvetica";
4070     }
4071     const glyphWidths = Metrics[lookupName];
4072 
4073     if (typeof glyphWidths === "number") {
4074       defaultWidth = glyphWidths;
4075       monospace = true;
4076     } else {
4077       widths = glyphWidths(); // expand lazy widths array
4078     }
4079 
4080     return {
4081       defaultWidth,
4082       monospace,
4083       widths,
4084     };
4085   }
4086 
4087   buildCharCodeToWidth(widthsByGlyphName, properties) {
4088     const widths = Object.create(null);
4089     const differences = properties.differences;
4090     const encoding = properties.defaultEncoding;
4091     for (let charCode = 0; charCode < 256; charCode++) {
4092       if (charCode in differences && widthsByGlyphName[differences[charCode]]) {
4093         widths[charCode] = widthsByGlyphName[differences[charCode]];
4094         continue;
4095       }
4096       if (charCode in encoding && widthsByGlyphName[encoding[charCode]]) {
4097         widths[charCode] = widthsByGlyphName[encoding[charCode]];
4098         continue;
4099       }
4100     }
4101     return widths;
4102   }
4103 
4104   preEvaluateFont(dict) {
4105     const baseDict = dict;
4106     let type = dict.get("Subtype");
4107     if (!(type instanceof Name)) {
4108       throw new FormatError("invalid font Subtype");
4109     }
4110 
4111     let composite = false;
4112     let hash;
4113     if (type.name === "Type0") {
4114       // If font is a composite
4115       //  - get the descendant font
4116       //  - set the type according to the descendant font
4117       //  - get the FontDescriptor from the descendant font
4118       const df = dict.get("DescendantFonts");
4119       if (!df) {
4120         throw new FormatError("Descendant fonts are not specified");
4121       }
4122       dict = Array.isArray(df) ? this.xref.fetchIfRef(df[0]) : df;
4123 
4124       if (!(dict instanceof Dict)) {
4125         throw new FormatError("Descendant font is not a dictionary.");
4126       }
4127       type = dict.get("Subtype");
4128       if (!(type instanceof Name)) {
4129         throw new FormatError("invalid font Subtype");
4130       }
4131       composite = true;
4132     }
4133 
4134     let firstChar = dict.get("FirstChar");
4135     if (!Number.isInteger(firstChar)) {
4136       firstChar = 0;
4137     }
4138     let lastChar = dict.get("LastChar");
4139     if (!Number.isInteger(lastChar)) {
4140       lastChar = composite ? 0xffff : 0xff;
4141     }
4142     const descriptor = dict.get("FontDescriptor");
4143     const toUnicode = dict.get("ToUnicode") || baseDict.get("ToUnicode");
4144 
4145     if (descriptor) {
4146       hash = new MurmurHash3_64();
4147 
4148       const encoding = baseDict.getRaw("Encoding");
4149       if (encoding instanceof Name) {
4150         hash.update(encoding.name);
4151       } else if (encoding instanceof Ref) {
4152         hash.update(encoding.toString());
4153       } else if (encoding instanceof Dict) {
4154         for (const entry of encoding.getRawValues()) {
4155           if (entry instanceof Name) {
4156             hash.update(entry.name);
4157           } else if (entry instanceof Ref) {
4158             hash.update(entry.toString());
4159           } else if (Array.isArray(entry)) {
4160             // 'Differences' array (fixes bug1157493.pdf).
4161             const diffLength = entry.length,
4162               diffBuf = new Array(diffLength);
4163 
4164             for (let j = 0; j < diffLength; j++) {
4165               const diffEntry = entry[j];
4166               if (diffEntry instanceof Name) {
4167                 diffBuf[j] = diffEntry.name;
4168               } else if (
4169                 typeof diffEntry === "number" ||
4170                 diffEntry instanceof Ref
4171               ) {
4172                 diffBuf[j] = diffEntry.toString();
4173               }
4174             }
4175             hash.update(diffBuf.join());
4176           }
4177         }
4178       }
4179 
4180       hash.update(`${firstChar}-${lastChar}`); // Fixes issue10665_reduced.pdf
4181 
4182       if (toUnicode instanceof BaseStream) {
4183         const stream = toUnicode.str || toUnicode;
4184         const uint8array = stream.buffer
4185           ? new Uint8Array(stream.buffer.buffer, 0, stream.bufferLength)
4186           : new Uint8Array(
4187               stream.bytes.buffer,
4188               stream.start,
4189               stream.end - stream.start
4190             );
4191         hash.update(uint8array);
4192       } else if (toUnicode instanceof Name) {
4193         hash.update(toUnicode.name);
4194       }
4195 
4196       const widths = dict.get("Widths") || baseDict.get("Widths");
4197       if (Array.isArray(widths)) {
4198         const widthsBuf = [];
4199         for (const entry of widths) {
4200           if (typeof entry === "number" || entry instanceof Ref) {
4201             widthsBuf.push(entry.toString());
4202           }
4203         }
4204         hash.update(widthsBuf.join());
4205       }
4206 
4207       if (composite) {
4208         hash.update("compositeFont");
4209 
4210         const compositeWidths = dict.get("W") || baseDict.get("W");
4211         if (Array.isArray(compositeWidths)) {
4212           const widthsBuf = [];
4213           for (const entry of compositeWidths) {
4214             if (typeof entry === "number" || entry instanceof Ref) {
4215               widthsBuf.push(entry.toString());
4216             } else if (Array.isArray(entry)) {
4217               const subWidthsBuf = [];
4218               for (const element of entry) {
4219                 if (typeof element === "number" || element instanceof Ref) {
4220                   subWidthsBuf.push(element.toString());
4221                 }
4222               }
4223               widthsBuf.push(`[${subWidthsBuf.join()}]`);
4224             }
4225           }
4226           hash.update(widthsBuf.join());
4227         }
4228 
4229         const cidToGidMap =
4230           dict.getRaw("CIDToGIDMap") || baseDict.getRaw("CIDToGIDMap");
4231         if (cidToGidMap instanceof Name) {
4232           hash.update(cidToGidMap.name);
4233         } else if (cidToGidMap instanceof Ref) {
4234           hash.update(cidToGidMap.toString());
4235         } else if (cidToGidMap instanceof BaseStream) {
4236           hash.update(cidToGidMap.peekBytes());
4237         }
4238       }
4239     }
4240 
4241     return {
4242       descriptor,
4243       dict,
4244       baseDict,
4245       composite,
4246       type: type.name,
4247       firstChar,
4248       lastChar,
4249       toUnicode,
4250       hash: hash ? hash.hexdigest() : "",
4251     };
4252   }
4253 
4254   async translateFont({
4255     descriptor,
4256     dict,
4257     baseDict,
4258     composite,
4259     type,
4260     firstChar,
4261     lastChar,
4262     toUnicode,
4263     cssFontInfo,
4264   }) {
4265     const isType3Font = type === "Type3";
4266 
4267     if (!descriptor) {
4268       if (isType3Font) {
4269         const bbox = lookupNormalRect(dict.getArray("FontBBox"), [0, 0, 0, 0]);
4270         // FontDescriptor is only required for Type3 fonts when the document
4271         // is a tagged pdf. Create a barbebones one to get by.
4272         descriptor = new Dict(null);
4273         descriptor.set("FontName", Name.get(type));
4274         descriptor.set("FontBBox", bbox);
4275       } else {
4276         // Before PDF 1.5 if the font was one of the base 14 fonts, having a
4277         // FontDescriptor was not required.
4278         // This case is here for compatibility.
4279         let baseFontName = dict.get("BaseFont");
4280         if (!(baseFontName instanceof Name)) {
4281           throw new FormatError("Base font is not specified");
4282         }
4283 
4284         // Using base font name as a font name.
4285         baseFontName = baseFontName.name.replaceAll(/[,_]/g, "-");
4286         const metrics = this.getBaseFontMetrics(baseFontName);
4287 
4288         // Simulating descriptor flags attribute
4289         const fontNameWoStyle = baseFontName.split("-", 1)[0];
4290         const flags =
4291           (this.isSerifFont(fontNameWoStyle) ? FontFlags.Serif : 0) |
4292           (metrics.monospace ? FontFlags.FixedPitch : 0) |
4293           (getSymbolsFonts()[fontNameWoStyle]
4294             ? FontFlags.Symbolic
4295             : FontFlags.Nonsymbolic);
4296 
4297         const properties = {
4298           type,
4299           name: baseFontName,
4300           loadedName: baseDict.loadedName,
4301           systemFontInfo: null,
4302           widths: metrics.widths,
4303           defaultWidth: metrics.defaultWidth,
4304           isSimulatedFlags: true,
4305           flags,
4306           firstChar,
4307           lastChar,
4308           toUnicode,
4309           xHeight: 0,
4310           capHeight: 0,
4311           italicAngle: 0,
4312           isType3Font,
4313         };
4314         const widths = dict.get("Widths");
4315 
4316         const standardFontName = getStandardFontName(baseFontName);
4317         let file = null;
4318         if (standardFontName) {
4319           file = await this.fetchStandardFontData(standardFontName);
4320           properties.isInternalFont = !!file;
4321         }
4322         if (!properties.isInternalFont && this.options.useSystemFonts) {
4323           properties.systemFontInfo = getFontSubstitution(
4324             this.systemFontCache,
4325             this.idFactory,
4326             this.options.standardFontDataUrl,
4327             baseFontName,
4328             standardFontName,
4329             type
4330           );
4331         }
4332 
4333         const newProperties = await this.extractDataStructures(
4334           dict,
4335           properties
4336         );
4337         if (Array.isArray(widths)) {
4338           const glyphWidths = [];
4339           let j = firstChar;
4340           for (const w of widths) {
4341             const width = this.xref.fetchIfRef(w);
4342             if (typeof width === "number") {
4343               glyphWidths[j] = width;
4344             }
4345             j++;
4346           }
4347           newProperties.widths = glyphWidths;
4348         } else {
4349           newProperties.widths = this.buildCharCodeToWidth(
4350             metrics.widths,
4351             newProperties
4352           );
4353         }
4354         return new Font(baseFontName, file, newProperties);
4355       }
4356     }
4357 
4358     // According to the spec if 'FontDescriptor' is declared, 'FirstChar',
4359     // 'LastChar' and 'Widths' should exist too, but some PDF encoders seem
4360     // to ignore this rule when a variant of a standard font is used.
4361     // TODO Fill the width array depending on which of the base font this is
4362     // a variant.
4363 
4364     let fontName = descriptor.get("FontName");
4365     let baseFont = dict.get("BaseFont");
4366     // Some bad PDFs have a string as the font name.
4367     if (typeof fontName === "string") {
4368       fontName = Name.get(fontName);
4369     }
4370     if (typeof baseFont === "string") {
4371       baseFont = Name.get(baseFont);
4372     }
4373 
4374     const fontNameStr = fontName?.name;
4375     const baseFontStr = baseFont?.name;
4376     if (!isType3Font && fontNameStr !== baseFontStr) {
4377       info(
4378         `The FontDescriptor's FontName is "${fontNameStr}" but ` +
4379           `should be the same as the Font's BaseFont "${baseFontStr}".`
4380       );
4381       // - Workaround for cases where e.g. fontNameStr = 'Arial' and
4382       //   baseFontStr = 'Arial,Bold' (needed when no font file is embedded).
4383       //
4384       // - Workaround for cases where e.g. fontNameStr = 'wg09np' and
4385       //   baseFontStr = 'Wingdings-Regular' (fixes issue7454.pdf).
4386       if (
4387         fontNameStr &&
4388         baseFontStr &&
4389         (baseFontStr.startsWith(fontNameStr) ||
4390           (!isKnownFontName(fontNameStr) && isKnownFontName(baseFontStr)))
4391       ) {
4392         fontName = null;
4393       }
4394     }
4395     fontName ||= baseFont;
4396 
4397     if (!(fontName instanceof Name)) {
4398       throw new FormatError("invalid font name");
4399     }
4400 
4401     let fontFile, subtype, length1, length2, length3;
4402     try {
4403       fontFile = descriptor.get("FontFile", "FontFile2", "FontFile3");
4404     } catch (ex) {
4405       if (!this.options.ignoreErrors) {
4406         throw ex;
4407       }
4408       warn(`translateFont - fetching "${fontName.name}" font file: "${ex}".`);
4409       fontFile = new NullStream();
4410     }
4411     let isInternalFont = false;
4412     let glyphScaleFactors = null;
4413     let systemFontInfo = null;
4414     if (fontFile) {
4415       if (fontFile.dict) {
4416         const subtypeEntry = fontFile.dict.get("Subtype");
4417         if (subtypeEntry instanceof Name) {
4418           subtype = subtypeEntry.name;
4419         }
4420         length1 = fontFile.dict.get("Length1");
4421         length2 = fontFile.dict.get("Length2");
4422         length3 = fontFile.dict.get("Length3");
4423       }
4424     } else if (cssFontInfo) {
4425       // We've a missing XFA font.
4426       const standardFontName = getXfaFontName(fontName.name);
4427       if (standardFontName) {
4428         cssFontInfo.fontFamily = `${cssFontInfo.fontFamily}-PdfJS-XFA`;
4429         cssFontInfo.metrics = standardFontName.metrics || null;
4430         glyphScaleFactors = standardFontName.factors || null;
4431         fontFile = await this.fetchStandardFontData(standardFontName.name);
4432         isInternalFont = !!fontFile;
4433 
4434         // We're using a substitution font but for example widths (if any)
4435         // are related to the glyph positions in the font.
4436         // So we overwrite everything here to be sure that widths are
4437         // correct.
4438         baseDict = dict = getXfaFontDict(fontName.name);
4439         composite = true;
4440       }
4441     } else if (!isType3Font) {
4442       const standardFontName = getStandardFontName(fontName.name);
4443       if (standardFontName) {
4444         fontFile = await this.fetchStandardFontData(standardFontName);
4445         isInternalFont = !!fontFile;
4446       }
4447       if (!isInternalFont && this.options.useSystemFonts) {
4448         systemFontInfo = getFontSubstitution(
4449           this.systemFontCache,
4450           this.idFactory,
4451           this.options.standardFontDataUrl,
4452           fontName.name,
4453           standardFontName,
4454           type
4455         );
4456       }
4457     }
4458 
4459     const fontMatrix = lookupMatrix(
4460       dict.getArray("FontMatrix"),
4461       FONT_IDENTITY_MATRIX
4462     );
4463     const bbox = lookupNormalRect(
4464       descriptor.getArray("FontBBox") || dict.getArray("FontBBox"),
4465       undefined
4466     );
4467     let ascent = descriptor.get("Ascent");
4468     if (typeof ascent !== "number") {
4469       ascent = undefined;
4470     }
4471     let descent = descriptor.get("Descent");
4472     if (typeof descent !== "number") {
4473       descent = undefined;
4474     }
4475     let xHeight = descriptor.get("XHeight");
4476     if (typeof xHeight !== "number") {
4477       xHeight = 0;
4478     }
4479     let capHeight = descriptor.get("CapHeight");
4480     if (typeof capHeight !== "number") {
4481       capHeight = 0;
4482     }
4483     let flags = descriptor.get("Flags");
4484     if (!Number.isInteger(flags)) {
4485       flags = 0;
4486     }
4487     let italicAngle = descriptor.get("ItalicAngle");
4488     if (typeof italicAngle !== "number") {
4489       italicAngle = 0;
4490     }
4491 
4492     const properties = {
4493       type,
4494       name: fontName.name,
4495       subtype,
4496       file: fontFile,
4497       length1,
4498       length2,
4499       length3,
4500       isInternalFont,
4501       loadedName: baseDict.loadedName,
4502       composite,
4503       fixedPitch: false,
4504       fontMatrix,
4505       firstChar,
4506       lastChar,
4507       toUnicode,
4508       bbox,
4509       ascent,
4510       descent,
4511       xHeight,
4512       capHeight,
4513       flags,
4514       italicAngle,
4515       isType3Font,
4516       cssFontInfo,
4517       scaleFactors: glyphScaleFactors,
4518       systemFontInfo,
4519     };
4520 
4521     if (composite) {
4522       const cidEncoding = baseDict.get("Encoding");
4523       if (cidEncoding instanceof Name) {
4524         properties.cidEncoding = cidEncoding.name;
4525       }
4526       const cMap = await CMapFactory.create({
4527         encoding: cidEncoding,
4528         fetchBuiltInCMap: this._fetchBuiltInCMapBound,
4529         useCMap: null,
4530       });
4531       properties.cMap = cMap;
4532       properties.vertical = properties.cMap.vertical;
4533     }
4534 
4535     const newProperties = await this.extractDataStructures(dict, properties);
4536     this.extractWidths(dict, descriptor, newProperties);
4537 
4538     return new Font(fontName.name, fontFile, newProperties);
4539   }
4540 
4541   static buildFontPaths(font, glyphs, handler, evaluatorOptions) {
4542     function buildPath(fontChar) {
4543       const glyphName = `${font.loadedName}_path_${fontChar}`;
4544       try {
4545         if (font.renderer.hasBuiltPath(fontChar)) {
4546           return;
4547         }
4548         handler.send("commonobj", [
4549           glyphName,
4550           "FontPath",
4551           font.renderer.getPathJs(fontChar),
4552         ]);
4553       } catch (reason) {
4554         if (evaluatorOptions.ignoreErrors) {
4555           warn(`buildFontPaths - ignoring ${glyphName} glyph: "${reason}".`);
4556           return;
4557         }
4558         throw reason;
4559       }
4560     }
4561 
4562     for (const glyph of glyphs) {
4563       buildPath(glyph.fontChar);
4564 
4565       // If the glyph has an accent we need to build a path for its
4566       // fontChar too, otherwise CanvasGraphics_paintChar will fail.
4567       const accent = glyph.accent;
4568       if (accent?.fontChar) {
4569         buildPath(accent.fontChar);
4570       }
4571     }
4572   }
4573 
4574   static get fallbackFontDict() {
4575     const dict = new Dict();
4576     dict.set("BaseFont", Name.get("Helvetica"));
4577     dict.set("Type", Name.get("FallbackType"));
4578     dict.set("Subtype", Name.get("FallbackType"));
4579     dict.set("Encoding", Name.get("WinAnsiEncoding"));
4580 
4581     return shadow(this, "fallbackFontDict", dict);
4582   }
4583 }
4584 
4585 class TranslatedFont {
4586   constructor({ loadedName, font, dict, evaluatorOptions }) {
4587     this.loadedName = loadedName;
4588     this.font = font;
4589     this.dict = dict;
4590     this._evaluatorOptions = evaluatorOptions || DefaultPartialEvaluatorOptions;
4591     this.type3Loaded = null;
4592     this.type3Dependencies = font.isType3Font ? new Set() : null;
4593     this.sent = false;
4594   }
4595 
4596   send(handler) {
4597     if (this.sent) {
4598       return;
4599     }
4600     this.sent = true;
4601 
4602     handler.send("commonobj", [
4603       this.loadedName,
4604       "Font",
4605       this.font.exportData(this._evaluatorOptions.fontExtraProperties),
4606     ]);
4607   }
4608 
4609   fallback(handler) {
4610     if (!this.font.data) {
4611       return;
4612     }
4613     // When font loading failed, fall back to the built-in font renderer.
4614     this.font.disableFontFace = true;
4615     // An arbitrary number of text rendering operators could have been
4616     // encountered between the point in time when the 'Font' message was sent
4617     // to the main-thread, and the point in time when the 'FontFallback'
4618     // message was received on the worker-thread.
4619     // To ensure that all 'FontPath's are available on the main-thread, when
4620     // font loading failed, attempt to resend *all* previously parsed glyphs.
4621     PartialEvaluator.buildFontPaths(
4622       this.font,
4623       /* glyphs = */ this.font.glyphCacheValues,
4624       handler,
4625       this._evaluatorOptions
4626     );
4627   }
4628 
4629   loadType3Data(evaluator, resources, task) {
4630     if (this.type3Loaded) {
4631       return this.type3Loaded;
4632     }
4633     if (!this.font.isType3Font) {
4634       throw new Error("Must be a Type3 font.");
4635     }
4636     // When parsing Type3 glyphs, always ignore them if there are errors.
4637     // Compared to the parsing of e.g. an entire page, it doesn't really
4638     // make sense to only be able to render a Type3 glyph partially.
4639     const type3Evaluator = evaluator.clone({ ignoreErrors: false });
4640     // Prevent circular references in Type3 fonts.
4641     const type3FontRefs = new RefSet(evaluator.type3FontRefs);
4642     if (this.dict.objId && !type3FontRefs.has(this.dict.objId)) {
4643       type3FontRefs.put(this.dict.objId);
4644     }
4645     type3Evaluator.type3FontRefs = type3FontRefs;
4646 
4647     const translatedFont = this.font,
4648       type3Dependencies = this.type3Dependencies;
4649     let loadCharProcsPromise = Promise.resolve();
4650     const charProcs = this.dict.get("CharProcs");
4651     const fontResources = this.dict.get("Resources") || resources;
4652     const charProcOperatorList = Object.create(null);
4653 
4654     const fontBBox = Util.normalizeRect(translatedFont.bbox || [0, 0, 0, 0]),
4655       width = fontBBox[2] - fontBBox[0],
4656       height = fontBBox[3] - fontBBox[1];
4657     const fontBBoxSize = Math.hypot(width, height);
4658 
4659     for (const key of charProcs.getKeys()) {
4660       loadCharProcsPromise = loadCharProcsPromise.then(() => {
4661         const glyphStream = charProcs.get(key);
4662         const operatorList = new OperatorList();
4663         return type3Evaluator
4664           .getOperatorList({
4665             stream: glyphStream,
4666             task,
4667             resources: fontResources,
4668             operatorList,
4669           })
4670           .then(() => {
4671             // According to the PDF specification, section "9.6.5 Type 3 Fonts"
4672             // and "Table 113":
4673             //  "A glyph description that begins with the d1 operator should
4674             //   not execute any operators that set the colour (or other
4675             //   colour-related parameters) in the graphics state;
4676             //   any use of such operators shall be ignored."
4677             if (operatorList.fnArray[0] === OPS.setCharWidthAndBounds) {
4678               this._removeType3ColorOperators(operatorList, fontBBoxSize);
4679             }
4680             charProcOperatorList[key] = operatorList.getIR();
4681 
4682             for (const dependency of operatorList.dependencies) {
4683               type3Dependencies.add(dependency);
4684             }
4685           })
4686           .catch(function (reason) {
4687             warn(`Type3 font resource "${key}" is not available.`);
4688             const dummyOperatorList = new OperatorList();
4689             charProcOperatorList[key] = dummyOperatorList.getIR();
4690           });
4691       });
4692     }
4693     this.type3Loaded = loadCharProcsPromise.then(() => {
4694       translatedFont.charProcOperatorList = charProcOperatorList;
4695       if (this._bbox) {
4696         translatedFont.isCharBBox = true;
4697         translatedFont.bbox = this._bbox;
4698       }
4699     });
4700     return this.type3Loaded;
4701   }
4702 
4703   /**
4704    * @private
4705    */
4706   _removeType3ColorOperators(operatorList, fontBBoxSize = NaN) {
4707     if (typeof PDFJSDev === "undefined" || PDFJSDev.test("TESTING")) {
4708       assert(
4709         operatorList.fnArray[0] === OPS.setCharWidthAndBounds,
4710         "Type3 glyph shall start with the d1 operator."
4711       );
4712     }
4713     const charBBox = Util.normalizeRect(operatorList.argsArray[0].slice(2)),
4714       width = charBBox[2] - charBBox[0],
4715       height = charBBox[3] - charBBox[1];
4716     const charBBoxSize = Math.hypot(width, height);
4717 
4718     if (width === 0 || height === 0) {
4719       // Skip the d1 operator when its bounds are bogus (fixes issue14953.pdf).
4720       operatorList.fnArray.splice(0, 1);
4721       operatorList.argsArray.splice(0, 1);
4722     } else if (
4723       fontBBoxSize === 0 ||
4724       Math.round(charBBoxSize / fontBBoxSize) >= 10
4725     ) {
4726       // Override the fontBBox when it's undefined/empty, or when it's at least
4727       // (approximately) one order of magnitude smaller than the charBBox
4728       // (fixes issue14999_reduced.pdf).
4729       if (!this._bbox) {
4730         this._bbox = [Infinity, Infinity, -Infinity, -Infinity];
4731       }
4732       this._bbox[0] = Math.min(this._bbox[0], charBBox[0]);
4733       this._bbox[1] = Math.min(this._bbox[1], charBBox[1]);
4734       this._bbox[2] = Math.max(this._bbox[2], charBBox[2]);
4735       this._bbox[3] = Math.max(this._bbox[3], charBBox[3]);
4736     }
4737 
4738     let i = 0,
4739       ii = operatorList.length;
4740     while (i < ii) {
4741       switch (operatorList.fnArray[i]) {
4742         case OPS.setCharWidthAndBounds:
4743           break; // Handled above.
4744         case OPS.setStrokeColorSpace:
4745         case OPS.setFillColorSpace:
4746         case OPS.setStrokeColor:
4747         case OPS.setStrokeColorN:
4748         case OPS.setFillColor:
4749         case OPS.setFillColorN:
4750         case OPS.setStrokeGray:
4751         case OPS.setFillGray:
4752         case OPS.setStrokeRGBColor:
4753         case OPS.setFillRGBColor:
4754         case OPS.setStrokeCMYKColor:
4755         case OPS.setFillCMYKColor:
4756         case OPS.shadingFill:
4757         case OPS.setRenderingIntent:
4758           operatorList.fnArray.splice(i, 1);
4759           operatorList.argsArray.splice(i, 1);
4760           ii--;
4761           continue;
4762 
4763         case OPS.setGState:
4764           const [gStateObj] = operatorList.argsArray[i];
4765           let j = 0,
4766             jj = gStateObj.length;
4767           while (j < jj) {
4768             const [gStateKey] = gStateObj[j];
4769             switch (gStateKey) {
4770               case "TR":
4771               case "TR2":
4772               case "HT":
4773               case "BG":
4774               case "BG2":
4775               case "UCR":
4776               case "UCR2":
4777                 gStateObj.splice(j, 1);
4778                 jj--;
4779                 continue;
4780             }
4781             j++;
4782           }
4783           break;
4784       }
4785       i++;
4786     }
4787   }
4788 }
4789 
4790 class StateManager {
4791   constructor(initialState = new EvalState()) {
4792     this.state = initialState;
4793     this.stateStack = [];
4794   }
4795 
4796   save() {
4797     const old = this.state;
4798     this.stateStack.push(this.state);
4799     this.state = old.clone();
4800   }
4801 
4802   restore() {
4803     const prev = this.stateStack.pop();
4804     if (prev) {
4805       this.state = prev;
4806     }
4807   }
4808 
4809   transform(args) {
4810     this.state.ctm = Util.transform(this.state.ctm, args);
4811   }
4812 }
4813 
4814 class TextState {
4815   constructor() {
4816     this.ctm = new Float32Array(IDENTITY_MATRIX);
4817     this.fontName = null;
4818     this.fontSize = 0;
4819     this.loadedName = null;
4820     this.font = null;
4821     this.fontMatrix = FONT_IDENTITY_MATRIX;
4822     this.textMatrix = IDENTITY_MATRIX.slice();
4823     this.textLineMatrix = IDENTITY_MATRIX.slice();
4824     this.charSpacing = 0;
4825     this.wordSpacing = 0;
4826     this.leading = 0;
4827     this.textHScale = 1;
4828     this.textRise = 0;
4829   }
4830 
4831   setTextMatrix(a, b, c, d, e, f) {
4832     const m = this.textMatrix;
4833     m[0] = a;
4834     m[1] = b;
4835     m[2] = c;
4836     m[3] = d;
4837     m[4] = e;
4838     m[5] = f;
4839   }
4840 
4841   setTextLineMatrix(a, b, c, d, e, f) {
4842     const m = this.textLineMatrix;
4843     m[0] = a;
4844     m[1] = b;
4845     m[2] = c;
4846     m[3] = d;
4847     m[4] = e;
4848     m[5] = f;
4849   }
4850 
4851   translateTextMatrix(x, y) {
4852     const m = this.textMatrix;
4853     m[4] = m[0] * x + m[2] * y + m[4];
4854     m[5] = m[1] * x + m[3] * y + m[5];
4855   }
4856 
4857   translateTextLineMatrix(x, y) {
4858     const m = this.textLineMatrix;
4859     m[4] = m[0] * x + m[2] * y + m[4];
4860     m[5] = m[1] * x + m[3] * y + m[5];
4861   }
4862 
4863   carriageReturn() {
4864     this.translateTextLineMatrix(0, -this.leading);
4865     this.textMatrix = this.textLineMatrix.slice();
4866   }
4867 
4868   clone() {
4869     const clone = Object.create(this);
4870     clone.textMatrix = this.textMatrix.slice();
4871     clone.textLineMatrix = this.textLineMatrix.slice();
4872     clone.fontMatrix = this.fontMatrix.slice();
4873     return clone;
4874   }
4875 }
4876 
4877 class EvalState {
4878   constructor() {
4879     this.ctm = new Float32Array(IDENTITY_MATRIX);
4880     this.font = null;
4881     this.textRenderingMode = TextRenderingMode.FILL;
4882     this.fillColorSpace = ColorSpace.singletons.gray;
4883     this.strokeColorSpace = ColorSpace.singletons.gray;
4884   }
4885 
4886   clone() {
4887     return Object.create(this);
4888   }
4889 }
4890 
4891 class EvaluatorPreprocessor {
4892   static get opMap() {
4893     // Specifies properties for each command
4894     //
4895     // If variableArgs === true: [0, `numArgs`] expected
4896     // If variableArgs === false: exactly `numArgs` expected
4897     return shadow(
4898       this,
4899       "opMap",
4900       Object.assign(Object.create(null), {
4901         // Graphic state
4902         w: { id: OPS.setLineWidth, numArgs: 1, variableArgs: false },
4903         J: { id: OPS.setLineCap, numArgs: 1, variableArgs: false },
4904         j: { id: OPS.setLineJoin, numArgs: 1, variableArgs: false },
4905         M: { id: OPS.setMiterLimit, numArgs: 1, variableArgs: false },
4906         d: { id: OPS.setDash, numArgs: 2, variableArgs: false },
4907         ri: { id: OPS.setRenderingIntent, numArgs: 1, variableArgs: false },
4908         i: { id: OPS.setFlatness, numArgs: 1, variableArgs: false },
4909         gs: { id: OPS.setGState, numArgs: 1, variableArgs: false },
4910         q: { id: OPS.save, numArgs: 0, variableArgs: false },
4911         Q: { id: OPS.restore, numArgs: 0, variableArgs: false },
4912         cm: { id: OPS.transform, numArgs: 6, variableArgs: false },
4913 
4914         // Path
4915         m: { id: OPS.moveTo, numArgs: 2, variableArgs: false },
4916         l: { id: OPS.lineTo, numArgs: 2, variableArgs: false },
4917         c: { id: OPS.curveTo, numArgs: 6, variableArgs: false },
4918         v: { id: OPS.curveTo2, numArgs: 4, variableArgs: false },
4919         y: { id: OPS.curveTo3, numArgs: 4, variableArgs: false },
4920         h: { id: OPS.closePath, numArgs: 0, variableArgs: false },
4921         re: { id: OPS.rectangle, numArgs: 4, variableArgs: false },
4922         S: { id: OPS.stroke, numArgs: 0, variableArgs: false },
4923         s: { id: OPS.closeStroke, numArgs: 0, variableArgs: false },
4924         f: { id: OPS.fill, numArgs: 0, variableArgs: false },
4925         F: { id: OPS.fill, numArgs: 0, variableArgs: false },
4926         "f*": { id: OPS.eoFill, numArgs: 0, variableArgs: false },
4927         B: { id: OPS.fillStroke, numArgs: 0, variableArgs: false },
4928         "B*": { id: OPS.eoFillStroke, numArgs: 0, variableArgs: false },
4929         b: { id: OPS.closeFillStroke, numArgs: 0, variableArgs: false },
4930         "b*": { id: OPS.closeEOFillStroke, numArgs: 0, variableArgs: false },
4931         n: { id: OPS.endPath, numArgs: 0, variableArgs: false },
4932 
4933         // Clipping
4934         W: { id: OPS.clip, numArgs: 0, variableArgs: false },
4935         "W*": { id: OPS.eoClip, numArgs: 0, variableArgs: false },
4936 
4937         // Text
4938         BT: { id: OPS.beginText, numArgs: 0, variableArgs: false },
4939         ET: { id: OPS.endText, numArgs: 0, variableArgs: false },
4940         Tc: { id: OPS.setCharSpacing, numArgs: 1, variableArgs: false },
4941         Tw: { id: OPS.setWordSpacing, numArgs: 1, variableArgs: false },
4942         Tz: { id: OPS.setHScale, numArgs: 1, variableArgs: false },
4943         TL: { id: OPS.setLeading, numArgs: 1, variableArgs: false },
4944         Tf: { id: OPS.setFont, numArgs: 2, variableArgs: false },
4945         Tr: { id: OPS.setTextRenderingMode, numArgs: 1, variableArgs: false },
4946         Ts: { id: OPS.setTextRise, numArgs: 1, variableArgs: false },
4947         Td: { id: OPS.moveText, numArgs: 2, variableArgs: false },
4948         TD: { id: OPS.setLeadingMoveText, numArgs: 2, variableArgs: false },
4949         Tm: { id: OPS.setTextMatrix, numArgs: 6, variableArgs: false },
4950         "T*": { id: OPS.nextLine, numArgs: 0, variableArgs: false },
4951         Tj: { id: OPS.showText, numArgs: 1, variableArgs: false },
4952         TJ: { id: OPS.showSpacedText, numArgs: 1, variableArgs: false },
4953         "'": { id: OPS.nextLineShowText, numArgs: 1, variableArgs: false },
4954         '"': {
4955           id: OPS.nextLineSetSpacingShowText,
4956           numArgs: 3,
4957           variableArgs: false,
4958         },
4959 
4960         // Type3 fonts
4961         d0: { id: OPS.setCharWidth, numArgs: 2, variableArgs: false },
4962         d1: {
4963           id: OPS.setCharWidthAndBounds,
4964           numArgs: 6,
4965           variableArgs: false,
4966         },
4967 
4968         // Color
4969         CS: { id: OPS.setStrokeColorSpace, numArgs: 1, variableArgs: false },
4970         cs: { id: OPS.setFillColorSpace, numArgs: 1, variableArgs: false },
4971         SC: { id: OPS.setStrokeColor, numArgs: 4, variableArgs: true },
4972         SCN: { id: OPS.setStrokeColorN, numArgs: 33, variableArgs: true },
4973         sc: { id: OPS.setFillColor, numArgs: 4, variableArgs: true },
4974         scn: { id: OPS.setFillColorN, numArgs: 33, variableArgs: true },
4975         G: { id: OPS.setStrokeGray, numArgs: 1, variableArgs: false },
4976         g: { id: OPS.setFillGray, numArgs: 1, variableArgs: false },
4977         RG: { id: OPS.setStrokeRGBColor, numArgs: 3, variableArgs: false },
4978         rg: { id: OPS.setFillRGBColor, numArgs: 3, variableArgs: false },
4979         K: { id: OPS.setStrokeCMYKColor, numArgs: 4, variableArgs: false },
4980         k: { id: OPS.setFillCMYKColor, numArgs: 4, variableArgs: false },
4981 
4982         // Shading
4983         sh: { id: OPS.shadingFill, numArgs: 1, variableArgs: false },
4984 
4985         // Images
4986         BI: { id: OPS.beginInlineImage, numArgs: 0, variableArgs: false },
4987         ID: { id: OPS.beginImageData, numArgs: 0, variableArgs: false },
4988         EI: { id: OPS.endInlineImage, numArgs: 1, variableArgs: false },
4989 
4990         // XObjects
4991         Do: { id: OPS.paintXObject, numArgs: 1, variableArgs: false },
4992         MP: { id: OPS.markPoint, numArgs: 1, variableArgs: false },
4993         DP: { id: OPS.markPointProps, numArgs: 2, variableArgs: false },
4994         BMC: { id: OPS.beginMarkedContent, numArgs: 1, variableArgs: false },
4995         BDC: {
4996           id: OPS.beginMarkedContentProps,
4997           numArgs: 2,
4998           variableArgs: false,
4999         },
5000         EMC: { id: OPS.endMarkedContent, numArgs: 0, variableArgs: false },
5001 
5002         // Compatibility
5003         BX: { id: OPS.beginCompat, numArgs: 0, variableArgs: false },
5004         EX: { id: OPS.endCompat, numArgs: 0, variableArgs: false },
5005 
5006         // (reserved partial commands for the lexer)
5007         BM: null,
5008         BD: null,
5009         true: null,
5010         fa: null,
5011         fal: null,
5012         fals: null,
5013         false: null,
5014         nu: null,
5015         nul: null,
5016         null: null,
5017       })
5018     );
5019   }
5020 
5021   static MAX_INVALID_PATH_OPS = 10;
5022 
5023   constructor(stream, xref, stateManager = new StateManager()) {
5024     // TODO(mduan): pass array of knownCommands rather than this.opMap
5025     // dictionary
5026     this.parser = new Parser({
5027       lexer: new Lexer(stream, EvaluatorPreprocessor.opMap),
5028       xref,
5029     });
5030     this.stateManager = stateManager;
5031     this.nonProcessedArgs = [];
5032     this._isPathOp = false;
5033     this._numInvalidPathOPS = 0;
5034   }
5035 
5036   get savedStatesDepth() {
5037     return this.stateManager.stateStack.length;
5038   }
5039 
5040   // |operation| is an object with two fields:
5041   //
5042   // - |fn| is an out param.
5043   //
5044   // - |args| is an inout param. On entry, it should have one of two values.
5045   //
5046   //   - An empty array. This indicates that the caller is providing the
5047   //     array in which the args will be stored in. The caller should use
5048   //     this value if it can reuse a single array for each call to read().
5049   //
5050   //   - |null|. This indicates that the caller needs this function to create
5051   //     the array in which any args are stored in. If there are zero args,
5052   //     this function will leave |operation.args| as |null| (thus avoiding
5053   //     allocations that would occur if we used an empty array to represent
5054   //     zero arguments). Otherwise, it will replace |null| with a new array
5055   //     containing the arguments. The caller should use this value if it
5056   //     cannot reuse an array for each call to read().
5057   //
5058   // These two modes are present because this function is very hot and so
5059   // avoiding allocations where possible is worthwhile.
5060   //
5061   read(operation) {
5062     let args = operation.args;
5063     while (true) {
5064       const obj = this.parser.getObj();
5065       if (obj instanceof Cmd) {
5066         const cmd = obj.cmd;
5067         // Check that the command is valid
5068         const opSpec = EvaluatorPreprocessor.opMap[cmd];
5069         if (!opSpec) {
5070           warn(`Unknown command "${cmd}".`);
5071           continue;
5072         }
5073 
5074         const fn = opSpec.id;
5075         const numArgs = opSpec.numArgs;
5076         let argsLength = args !== null ? args.length : 0;
5077 
5078         // If the *previous* command wasn't a path operator, reset the heuristic
5079         // used with incomplete path operators below (fixes issue14917.pdf).
5080         if (!this._isPathOp) {
5081           this._numInvalidPathOPS = 0;
5082         }
5083         this._isPathOp = fn >= OPS.moveTo && fn <= OPS.endPath;
5084 
5085         if (!opSpec.variableArgs) {
5086           // Postscript commands can be nested, e.g. /F2 /GS2 gs 5.711 Tf
5087           if (argsLength !== numArgs) {
5088             const nonProcessedArgs = this.nonProcessedArgs;
5089             while (argsLength > numArgs) {
5090               nonProcessedArgs.push(args.shift());
5091               argsLength--;
5092             }
5093             while (argsLength < numArgs && nonProcessedArgs.length !== 0) {
5094               if (args === null) {
5095                 args = [];
5096               }
5097               args.unshift(nonProcessedArgs.pop());
5098               argsLength++;
5099             }
5100           }
5101 
5102           if (argsLength < numArgs) {
5103             const partialMsg =
5104               `command ${cmd}: expected ${numArgs} args, ` +
5105               `but received ${argsLength} args.`;
5106 
5107             // Incomplete path operators, in particular, can result in fairly
5108             // chaotic rendering artifacts. Hence the following heuristics is
5109             // used to error, rather than just warn, once a number of invalid
5110             // path operators have been encountered (fixes bug1443140.pdf).
5111             if (
5112               this._isPathOp &&
5113               ++this._numInvalidPathOPS >
5114                 EvaluatorPreprocessor.MAX_INVALID_PATH_OPS
5115             ) {
5116               throw new FormatError(`Invalid ${partialMsg}`);
5117             }
5118             // If we receive too few arguments, it's not possible to execute
5119             // the command, hence we skip the command.
5120             warn(`Skipping ${partialMsg}`);
5121             if (args !== null) {
5122               args.length = 0;
5123             }
5124             continue;
5125           }
5126         } else if (argsLength > numArgs) {
5127           info(
5128             `Command ${cmd}: expected [0, ${numArgs}] args, ` +
5129               `but received ${argsLength} args.`
5130           );
5131         }
5132 
5133         // TODO figure out how to type-check vararg functions
5134         this.preprocessCommand(fn, args);
5135 
5136         operation.fn = fn;
5137         operation.args = args;
5138         return true;
5139       }
5140       if (obj === EOF) {
5141         return false; // no more commands
5142       }
5143       // argument
5144       if (obj !== null) {
5145         if (args === null) {
5146           args = [];
5147         }
5148         args.push(obj);
5149         if (args.length > 33) {
5150           throw new FormatError("Too many arguments");
5151         }
5152       }
5153     }
5154   }
5155 
5156   preprocessCommand(fn, args) {
5157     switch (fn | 0) {
5158       case OPS.save:
5159         this.stateManager.save();
5160         break;
5161       case OPS.restore:
5162         this.stateManager.restore();
5163         break;
5164       case OPS.transform:
5165         this.stateManager.transform(args);
5166         break;
5167     }
5168   }
5169 }
5170 
5171 export { EvaluatorPreprocessor, PartialEvaluator };
</code>

Test file:
<test_file>
File:
test/unit/evaluator_spec.js
/* Copyright 2017 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import { createIdFactory, XRefMock } from "./test_utils.js";
import { Dict, Name } from "../../src/core/primitives.js";
import { FormatError, OPS } from "../../src/shared/util.js";
import { Stream, StringStream } from "../../src/core/stream.js";
import { OperatorList } from "../../src/core/operator_list.js";
import { PartialEvaluator } from "../../src/core/evaluator.js";
import { WorkerTask } from "../../src/core/worker.js";
</test_file>

Your task:
You are a software tester at pdf.js.
1. Examine the existing test file. You may reuse any imports, helpers or setup blocks it already has.
2. Write exactly one javascript test `it("...", async () => {...})` block.
3. Your test must fail on the code before the patch, and pass after, hence the test will verify that the patch resolves the issue.
4. The test must be self-contained and to-the-point.
5. If you need something new use only the provided imports (respect the paths exactly how they are given) by importing dynamically for compatibility with Node.js — no new dependencies. 
6. Return only the javascript code for the new `it(...)` block (no comments or explanations).

Example structure:
it("should <describe behavior>", async () => {
  const { example } = await import("../../src/core/example.js");
  <initialize required variables>;
  <define expected variable>;
  <generate actual variables>;
  <compare expected with actual>;
});

