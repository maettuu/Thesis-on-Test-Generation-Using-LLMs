Before you begin:
- Keep going until the job is completely solved — don’t stop halfway.
- If you’re unsure about the behavior, reread the provided patch carefully; do not hallucinate.
- Plan your approach before writing code by reflecting on whether the test truly fails before and passes after.

Issue:
<issue>
Javascript object default properties like `toString` are considered "valid" PDF operators
Test case: [hello.pdf](https://github.com/mozilla/pdf.js/files/14002259/hello.pdf)

Configuration:
- Web browser and its version: **Firefox 122.0b5 (Ubuntu snap)**
- Operating system and its version: **Ubuntu 23.04**
- PDF.js version: **PDF.js: 4.0.347 [76e3e5202]**
- Is a browser extension: **no**

Steps to reproduce the problem:

1. Construct a PDF with a stream containing the token `toString` (see example linked above, line 35)

What is the expected behavior?

- Being an invalid operator, it should be ignored.

What went wrong?

![screenshot](https://github.com/mozilla/pdf.js/assets/3109710/dc075c73-1a16-4dd1-99ff-8fa29cb84356)

Potential operator tokens are used as an index into a map (i.e. a standard Javascript object), where certain properties like `id` and `numArgs` are stored. The presence of an element in this map is checked as follows:

https://github.com/mozilla/pdf.js/blob/fce822cde0fb6bab1d976ffcad5623482e18d446/src/core/parser.js#L1289-L1292

(maybe also in other places, I am not super familiar with the codebase)

The problem is that `possibleCommands` (which seems to equal the result of [`opMap`](https://github.com/mozilla/pdf.js/blob/fce822cde0fb6bab1d976ffcad5623482e18d446/src/core/evaluator.js#L4778)) is a regular Javascript object with the `Object` prototype. This means that it has properties like `toString` and `__proto__`. Hence, in these cases `knownCommands[possibleCommand]` will not equal `undefined`, and the operator is assumed to be valid. This then results in an exception later on when further logic attempts to access this operator's properties.

Variants of such a bug could lead to security problems, but this specific one is pretty harmless. Nevertheless it is good to make use of null-prototype objects for cases like this, and/or use a different way of checking operator validity.

</issue>

PDF File:
<pdf>
issue17554.pdf
</pdf>

Patch:
<patch>
diff --git a/src/core/evaluator.js b/src/core/evaluator.js
--- a/src/core/evaluator.js
+++ b/src/core/evaluator.js
@@ -4780,124 +4780,128 @@ class EvaluatorPreprocessor {
     //
     // If variableArgs === true: [0, `numArgs`] expected
     // If variableArgs === false: exactly `numArgs` expected
-    return shadow(this, "opMap", {
-      // Graphic state
-      w: { id: OPS.setLineWidth, numArgs: 1, variableArgs: false },
-      J: { id: OPS.setLineCap, numArgs: 1, variableArgs: false },
-      j: { id: OPS.setLineJoin, numArgs: 1, variableArgs: false },
-      M: { id: OPS.setMiterLimit, numArgs: 1, variableArgs: false },
-      d: { id: OPS.setDash, numArgs: 2, variableArgs: false },
-      ri: { id: OPS.setRenderingIntent, numArgs: 1, variableArgs: false },
-      i: { id: OPS.setFlatness, numArgs: 1, variableArgs: false },
-      gs: { id: OPS.setGState, numArgs: 1, variableArgs: false },
-      q: { id: OPS.save, numArgs: 0, variableArgs: false },
-      Q: { id: OPS.restore, numArgs: 0, variableArgs: false },
-      cm: { id: OPS.transform, numArgs: 6, variableArgs: false },
-
-      // Path
-      m: { id: OPS.moveTo, numArgs: 2, variableArgs: false },
-      l: { id: OPS.lineTo, numArgs: 2, variableArgs: false },
-      c: { id: OPS.curveTo, numArgs: 6, variableArgs: false },
-      v: { id: OPS.curveTo2, numArgs: 4, variableArgs: false },
-      y: { id: OPS.curveTo3, numArgs: 4, variableArgs: false },
-      h: { id: OPS.closePath, numArgs: 0, variableArgs: false },
-      re: { id: OPS.rectangle, numArgs: 4, variableArgs: false },
-      S: { id: OPS.stroke, numArgs: 0, variableArgs: false },
-      s: { id: OPS.closeStroke, numArgs: 0, variableArgs: false },
-      f: { id: OPS.fill, numArgs: 0, variableArgs: false },
-      F: { id: OPS.fill, numArgs: 0, variableArgs: false },
-      "f*": { id: OPS.eoFill, numArgs: 0, variableArgs: false },
-      B: { id: OPS.fillStroke, numArgs: 0, variableArgs: false },
-      "B*": { id: OPS.eoFillStroke, numArgs: 0, variableArgs: false },
-      b: { id: OPS.closeFillStroke, numArgs: 0, variableArgs: false },
-      "b*": { id: OPS.closeEOFillStroke, numArgs: 0, variableArgs: false },
-      n: { id: OPS.endPath, numArgs: 0, variableArgs: false },
-
-      // Clipping
-      W: { id: OPS.clip, numArgs: 0, variableArgs: false },
-      "W*": { id: OPS.eoClip, numArgs: 0, variableArgs: false },
-
-      // Text
-      BT: { id: OPS.beginText, numArgs: 0, variableArgs: false },
-      ET: { id: OPS.endText, numArgs: 0, variableArgs: false },
-      Tc: { id: OPS.setCharSpacing, numArgs: 1, variableArgs: false },
-      Tw: { id: OPS.setWordSpacing, numArgs: 1, variableArgs: false },
-      Tz: { id: OPS.setHScale, numArgs: 1, variableArgs: false },
-      TL: { id: OPS.setLeading, numArgs: 1, variableArgs: false },
-      Tf: { id: OPS.setFont, numArgs: 2, variableArgs: false },
-      Tr: { id: OPS.setTextRenderingMode, numArgs: 1, variableArgs: false },
-      Ts: { id: OPS.setTextRise, numArgs: 1, variableArgs: false },
-      Td: { id: OPS.moveText, numArgs: 2, variableArgs: false },
-      TD: { id: OPS.setLeadingMoveText, numArgs: 2, variableArgs: false },
-      Tm: { id: OPS.setTextMatrix, numArgs: 6, variableArgs: false },
-      "T*": { id: OPS.nextLine, numArgs: 0, variableArgs: false },
-      Tj: { id: OPS.showText, numArgs: 1, variableArgs: false },
-      TJ: { id: OPS.showSpacedText, numArgs: 1, variableArgs: false },
-      "'": { id: OPS.nextLineShowText, numArgs: 1, variableArgs: false },
-      '"': {
-        id: OPS.nextLineSetSpacingShowText,
-        numArgs: 3,
-        variableArgs: false,
-      },
-
-      // Type3 fonts
-      d0: { id: OPS.setCharWidth, numArgs: 2, variableArgs: false },
-      d1: {
-        id: OPS.setCharWidthAndBounds,
-        numArgs: 6,
-        variableArgs: false,
-      },
-
-      // Color
-      CS: { id: OPS.setStrokeColorSpace, numArgs: 1, variableArgs: false },
-      cs: { id: OPS.setFillColorSpace, numArgs: 1, variableArgs: false },
-      SC: { id: OPS.setStrokeColor, numArgs: 4, variableArgs: true },
-      SCN: { id: OPS.setStrokeColorN, numArgs: 33, variableArgs: true },
-      sc: { id: OPS.setFillColor, numArgs: 4, variableArgs: true },
-      scn: { id: OPS.setFillColorN, numArgs: 33, variableArgs: true },
-      G: { id: OPS.setStrokeGray, numArgs: 1, variableArgs: false },
-      g: { id: OPS.setFillGray, numArgs: 1, variableArgs: false },
-      RG: { id: OPS.setStrokeRGBColor, numArgs: 3, variableArgs: false },
-      rg: { id: OPS.setFillRGBColor, numArgs: 3, variableArgs: false },
-      K: { id: OPS.setStrokeCMYKColor, numArgs: 4, variableArgs: false },
-      k: { id: OPS.setFillCMYKColor, numArgs: 4, variableArgs: false },
-
-      // Shading
-      sh: { id: OPS.shadingFill, numArgs: 1, variableArgs: false },
-
-      // Images
-      BI: { id: OPS.beginInlineImage, numArgs: 0, variableArgs: false },
-      ID: { id: OPS.beginImageData, numArgs: 0, variableArgs: false },
-      EI: { id: OPS.endInlineImage, numArgs: 1, variableArgs: false },
-
-      // XObjects
-      Do: { id: OPS.paintXObject, numArgs: 1, variableArgs: false },
-      MP: { id: OPS.markPoint, numArgs: 1, variableArgs: false },
-      DP: { id: OPS.markPointProps, numArgs: 2, variableArgs: false },
-      BMC: { id: OPS.beginMarkedContent, numArgs: 1, variableArgs: false },
-      BDC: {
-        id: OPS.beginMarkedContentProps,
-        numArgs: 2,
-        variableArgs: false,
-      },
-      EMC: { id: OPS.endMarkedContent, numArgs: 0, variableArgs: false },
-
-      // Compatibility
-      BX: { id: OPS.beginCompat, numArgs: 0, variableArgs: false },
-      EX: { id: OPS.endCompat, numArgs: 0, variableArgs: false },
-
-      // (reserved partial commands for the lexer)
-      BM: null,
-      BD: null,
-      true: null,
-      fa: null,
-      fal: null,
-      fals: null,
-      false: null,
-      nu: null,
-      nul: null,
-      null: null,
-    });
+    return shadow(
+      this,
+      "opMap",
+      Object.assign(Object.create(null), {
+        // Graphic state
+        w: { id: OPS.setLineWidth, numArgs: 1, variableArgs: false },
+        J: { id: OPS.setLineCap, numArgs: 1, variableArgs: false },
+        j: { id: OPS.setLineJoin, numArgs: 1, variableArgs: false },
+        M: { id: OPS.setMiterLimit, numArgs: 1, variableArgs: false },
+        d: { id: OPS.setDash, numArgs: 2, variableArgs: false },
+        ri: { id: OPS.setRenderingIntent, numArgs: 1, variableArgs: false },
+        i: { id: OPS.setFlatness, numArgs: 1, variableArgs: false },
+        gs: { id: OPS.setGState, numArgs: 1, variableArgs: false },
+        q: { id: OPS.save, numArgs: 0, variableArgs: false },
+        Q: { id: OPS.restore, numArgs: 0, variableArgs: false },
+        cm: { id: OPS.transform, numArgs: 6, variableArgs: false },
+
+        // Path
+        m: { id: OPS.moveTo, numArgs: 2, variableArgs: false },
+        l: { id: OPS.lineTo, numArgs: 2, variableArgs: false },
+        c: { id: OPS.curveTo, numArgs: 6, variableArgs: false },
+        v: { id: OPS.curveTo2, numArgs: 4, variableArgs: false },
+        y: { id: OPS.curveTo3, numArgs: 4, variableArgs: false },
+        h: { id: OPS.closePath, numArgs: 0, variableArgs: false },
+        re: { id: OPS.rectangle, numArgs: 4, variableArgs: false },
+        S: { id: OPS.stroke, numArgs: 0, variableArgs: false },
+        s: { id: OPS.closeStroke, numArgs: 0, variableArgs: false },
+        f: { id: OPS.fill, numArgs: 0, variableArgs: false },
+        F: { id: OPS.fill, numArgs: 0, variableArgs: false },
+        "f*": { id: OPS.eoFill, numArgs: 0, variableArgs: false },
+        B: { id: OPS.fillStroke, numArgs: 0, variableArgs: false },
+        "B*": { id: OPS.eoFillStroke, numArgs: 0, variableArgs: false },
+        b: { id: OPS.closeFillStroke, numArgs: 0, variableArgs: false },
+        "b*": { id: OPS.closeEOFillStroke, numArgs: 0, variableArgs: false },
+        n: { id: OPS.endPath, numArgs: 0, variableArgs: false },
+
+        // Clipping
+        W: { id: OPS.clip, numArgs: 0, variableArgs: false },
+        "W*": { id: OPS.eoClip, numArgs: 0, variableArgs: false },
+
+        // Text
+        BT: { id: OPS.beginText, numArgs: 0, variableArgs: false },
+        ET: { id: OPS.endText, numArgs: 0, variableArgs: false },
+        Tc: { id: OPS.setCharSpacing, numArgs: 1, variableArgs: false },
+        Tw: { id: OPS.setWordSpacing, numArgs: 1, variableArgs: false },
+        Tz: { id: OPS.setHScale, numArgs: 1, variableArgs: false },
+        TL: { id: OPS.setLeading, numArgs: 1, variableArgs: false },
+        Tf: { id: OPS.setFont, numArgs: 2, variableArgs: false },
+        Tr: { id: OPS.setTextRenderingMode, numArgs: 1, variableArgs: false },
+        Ts: { id: OPS.setTextRise, numArgs: 1, variableArgs: false },
+        Td: { id: OPS.moveText, numArgs: 2, variableArgs: false },
+        TD: { id: OPS.setLeadingMoveText, numArgs: 2, variableArgs: false },
+        Tm: { id: OPS.setTextMatrix, numArgs: 6, variableArgs: false },
+        "T*": { id: OPS.nextLine, numArgs: 0, variableArgs: false },
+        Tj: { id: OPS.showText, numArgs: 1, variableArgs: false },
+        TJ: { id: OPS.showSpacedText, numArgs: 1, variableArgs: false },
+        "'": { id: OPS.nextLineShowText, numArgs: 1, variableArgs: false },
+        '"': {
+          id: OPS.nextLineSetSpacingShowText,
+          numArgs: 3,
+          variableArgs: false,
+        },
+
+        // Type3 fonts
+        d0: { id: OPS.setCharWidth, numArgs: 2, variableArgs: false },
+        d1: {
+          id: OPS.setCharWidthAndBounds,
+          numArgs: 6,
+          variableArgs: false,
+        },
+
+        // Color
+        CS: { id: OPS.setStrokeColorSpace, numArgs: 1, variableArgs: false },
+        cs: { id: OPS.setFillColorSpace, numArgs: 1, variableArgs: false },
+        SC: { id: OPS.setStrokeColor, numArgs: 4, variableArgs: true },
+        SCN: { id: OPS.setStrokeColorN, numArgs: 33, variableArgs: true },
+        sc: { id: OPS.setFillColor, numArgs: 4, variableArgs: true },
+        scn: { id: OPS.setFillColorN, numArgs: 33, variableArgs: true },
+        G: { id: OPS.setStrokeGray, numArgs: 1, variableArgs: false },
+        g: { id: OPS.setFillGray, numArgs: 1, variableArgs: false },
+        RG: { id: OPS.setStrokeRGBColor, numArgs: 3, variableArgs: false },
+        rg: { id: OPS.setFillRGBColor, numArgs: 3, variableArgs: false },
+        K: { id: OPS.setStrokeCMYKColor, numArgs: 4, variableArgs: false },
+        k: { id: OPS.setFillCMYKColor, numArgs: 4, variableArgs: false },
+
+        // Shading
+        sh: { id: OPS.shadingFill, numArgs: 1, variableArgs: false },
+
+        // Images
+        BI: { id: OPS.beginInlineImage, numArgs: 0, variableArgs: false },
+        ID: { id: OPS.beginImageData, numArgs: 0, variableArgs: false },
+        EI: { id: OPS.endInlineImage, numArgs: 1, variableArgs: false },
+
+        // XObjects
+        Do: { id: OPS.paintXObject, numArgs: 1, variableArgs: false },
+        MP: { id: OPS.markPoint, numArgs: 1, variableArgs: false },
+        DP: { id: OPS.markPointProps, numArgs: 2, variableArgs: false },
+        BMC: { id: OPS.beginMarkedContent, numArgs: 1, variableArgs: false },
+        BDC: {
+          id: OPS.beginMarkedContentProps,
+          numArgs: 2,
+          variableArgs: false,
+        },
+        EMC: { id: OPS.endMarkedContent, numArgs: 0, variableArgs: false },
+
+        // Compatibility
+        BX: { id: OPS.beginCompat, numArgs: 0, variableArgs: false },
+        EX: { id: OPS.endCompat, numArgs: 0, variableArgs: false },
+
+        // (reserved partial commands for the lexer)
+        BM: null,
+        BD: null,
+        true: null,
+        fa: null,
+        fal: null,
+        fals: null,
+        false: null,
+        nu: null,
+        nul: null,
+        null: null,
+      })
+    );
   }
 
   static MAX_INVALID_PATH_OPS = 10;


</patch>

Imports:
<imports>
Available Packages
Dev Dependencies:
- @babel/core: ^7.23.7
- @babel/preset-env: ^7.23.8
- @babel/runtime: ^7.23.8
- @fluent/bundle: ^0.18.0
- @fluent/dom: ^0.9.0
- @javascript-obfuscator/escodegen: 2.3.0
- @jazzer.js/core: ^2.1.0
- acorn: ^8.11.3
- autoprefixer: ^10.4.17
- babel-loader: ^9.1.3
- caniuse-lite: ^1.0.30001579
- canvas: ^2.11.2
- core-js: ^3.35.0
- cross-env: ^7.0.3
- eslint: ^8.56.0
- eslint-config-prettier: ^8.10.0
- eslint-plugin-fetch-options: ^0.0.5
- eslint-plugin-html: ^7.1.0
- eslint-plugin-import: ^2.29.1
- eslint-plugin-jasmine: ^4.1.3
- eslint-plugin-json: ^3.1.0
- eslint-plugin-mozilla: ^3.3.2
- eslint-plugin-no-unsanitized: ^4.0.2
- eslint-plugin-prettier: ^5.1.3
- eslint-plugin-sort-exports: ^0.8.0
- eslint-plugin-unicorn: ^50.0.1
- globals: ^13.24.0
- gulp: ^4.0.2
- gulp-cli: ^2.3.0
- gulp-postcss: ^9.1.0
- gulp-rename: ^2.0.0
- gulp-replace: ^1.1.4
- gulp-zip: ^6.0.0
- jasmine: ^5.1.0
- jsdoc: ^4.0.2
- jstransformer-markdown-it: ^3.0.0
- merge-stream: ^2.0.0
- mkdirp: ^3.0.1
- needle: ^3.3.1
- path2d-polyfill: ^2.0.1
- pngjs: ^7.0.0
- postcss: ^8.4.33
- postcss-dark-theme-class: ^1.1.0
- postcss-dir-pseudo-class: ^8.0.1
- postcss-discard-comments: ^6.0.1
- postcss-nesting: ^12.0.2
- prettier: ^3.2.4
- puppeteer: ^21.7.0
- rimraf: ^3.0.2
- streamqueue: ^1.1.2
- stylelint: ^16.2.0
- stylelint-prettier: ^5.0.0
- terser: ^5.27.0
- through2: ^4.0.2
- tsc-alias: ^1.8.8
- ttest: ^4.0.0
- typescript: ^5.3.3
- typogr: ^0.6.8
- vinyl: ^3.0.0
- webpack: ^5.89.0
- webpack-stream: ^7.0.0
- wintersmith: ^2.5.0
- yargs: ^17.7.2

Engines:
- node: >=18

Available Relative Imports:
- `../../src/core/annotation.js`: Annotation, AnnotationBorderStyle, AnnotationFactory, MarkupAnnotation, getQuadPoints
- `../../src/core/bidi.js`: bidi
- `../../src/core/cff_parser.js`: CFFCharset, CFFCompiler, CFFFDSelect, CFFParser, CFFStrings
- `../../src/core/cmap.js`: CMap, CMapFactory, IdentityCMap
- `../../src/core/colorspace.js`: ColorSpace
- `../../src/core/core_utils.js`: arrayBuffersToBytes, encodeToXmlString, escapePDFName, escapeString, getInheritableProperty, isAscii, isWhiteSpace, log2, numberToString, parseXFAPath, recoverJsURL, stringToUTF16HexString, stringToUTF16String, toRomanNumerals, validateCSSFont
- `../../src/core/crypto.js`: AES128Cipher, AES256Cipher, ARCFourCipher, CipherTransformFactory, PDF17, PDF20, calculateMD5, calculateSHA256, calculateSHA384, calculateSHA512
- `../../src/core/default_appearance.js`: createDefaultAppearance, parseAppearanceStream, parseDefaultAppearance
- `../../src/core/document.js`: PDFDocument, Page
- `../../src/core/encodings.js`: getEncoding
- `../../src/core/evaluator.js`: PartialEvaluator
- `../../src/core/font_substitutions.js`: getFontSubstitution
- `../../src/core/fonts_utils.js`: SEAC_ANALYSIS_ENABLED
- `../../src/core/function.js`: PDFFunctionFactory, PostScriptCompiler, PostScriptEvaluator
- `../../src/core/glyphlist.js`: getDingbatsGlyphsUnicode, getGlyphsUnicode
- `../../src/core/image_utils.js`: GlobalImageCache, LocalColorSpaceCache
- `../../src/core/jbig2.js`: Jbig2Image
- `../../src/core/jpg.js`: JpegImage
- `../../src/core/jpx.js`: JpxImage
- `../../src/core/metadata_parser.js`: MetadataParser
- `../../src/core/operator_list.js`: OperatorList
- `../../src/core/parser.js`: Lexer, Linearization, Parser
- `../../src/core/predictor_stream.js`: PredictorStream
- `../../src/core/primitives.js`: Cmd, Dict, EOF, Name, Ref, RefSet, RefSetCache, isCmd, isDict, isName, isRefsEqual
- `../../src/core/ps_parser.js`: PostScriptLexer, PostScriptParser
- `../../src/core/stream.js`: NullStream, Stream, StringStream
- `../../src/core/type1_parser.js`: Type1Parser
- `../../src/core/unicode.js`: getCharUnicodeCategory, getUnicodeForGlyph, getUnicodeRangeFor, mapSpecialUnicodeValues
- `../../src/core/worker.js`: WorkerMessageHandler, WorkerTask
- `../../src/core/writer.js`: incrementalUpdate, writeDict
- `../../src/core/xfa/bind.js`: Binder
- `../../src/core/xfa/data.js`: DataHandler
- `../../src/core/xfa/factory.js`: XFAFactory
- `../../src/core/xfa/formcalc_lexer.js`: Lexer, TOKEN, Token
- `../../src/core/xfa/formcalc_parser.js`: Errors, Parser
- `../../src/core/xfa/parser.js`: XFAParser
- `../../src/core/xfa/som.js`: searchNode
- `../../src/core/xfa/symbol_utils.js`: $dump, $getChildren, $getChildrenByClass, $getChildrenByName, $text, $uid
- `../../src/core/xml_parser.js`: SimpleXMLParser, XMLParserBase
- `../../src/display/annotation_layer.js`: AnnotationLayer
- `../../src/display/annotation_storage.js`: AnnotationStorage
- `../../src/display/api.js`: DefaultCMapReaderFactory, DefaultCanvasFactory, DefaultStandardFontDataFactory, LoopbackPort, PDFDataRangeTransport, PDFDocumentLoadingTask, PDFDocumentProxy, PDFPageProxy, PDFWorker, PDFWorkerUtil, RenderTask, build, getDocument, version
- `../../src/display/display_utils.js`: DOMCanvasFactory, DOMSVGFactory, PDFDateString, PageViewport, PixelsPerInch, RenderingCancelledException, StatTimer, fetchData, getFilenameFromUrl, getPdfFilenameFromUrl, getXfaPageViewport, isDataScheme, isPdfFile, isValidFetchUrl, noContextMenu, setLayerDimensions
- `../../src/display/draw_layer.js`: DrawLayer
- `../../src/display/editor/annotation_editor_layer.js`: AnnotationEditorLayer
- `../../src/display/editor/color_picker.js`: ColorPicker
- `../../src/display/editor/outliner.js`: Outliner
- `../../src/display/editor/tools.js`: AnnotationEditorUIManager, CommandManager
- `../../src/display/fetch_stream.js`: PDFFetchStream
- `../../src/display/metadata.js`: Metadata
- `../../src/display/network.js`: PDFNetworkStream
- `../../src/display/network_utils.js`: createResponseStatusError, extractFilenameFromHeader, validateRangeRequestCapabilities, validateResponseStatus
- `../../src/display/node_stream.js`: PDFNodeStream
- `../../src/display/text_layer.js`: TextLayerRenderTask, renderTextLayer, updateTextLayer
- `../../src/display/worker_options.js`: GlobalWorkerOptions
- `../../src/display/xfa_layer.js`: XfaLayer
- `../../src/shared/message_handler.js`: MessageHandler
- `../../src/shared/murmurhash3.js`: MurmurHash3_64
- `../../src/shared/util.js`: AbortException, AnnotationBorderStyleType, AnnotationEditorParamsType, AnnotationEditorType, AnnotationFieldFlag, AnnotationFlag, AnnotationMode, AnnotationType, CMapCompressionType, FeatureTest, FormatError, ImageKind, InvalidPDFException, MissingPDFException, OPS, PasswordException, PasswordResponses, PermissionFlag, PromiseCapability, RenderingIntentFlag, UnexpectedResponseException, UnknownErrorException, Util, VerbosityLevel, bytesToString, createValidAbsoluteUrl, getModificationDate, getVerbosityLevel, isNodeJS, normalizeUnicode, objectSize, setVerbosityLevel, shadow, string32, stringToBytes, stringToPDFString, stringToUTF8String
- `../../web/annotation_layer_builder.js`: AnnotationLayerBuilder
- `../../web/download_manager.js`: DownloadManager
- `../../web/event_utils.js`: EventBus, WaitOnType, waitOnEventOrTimeout
- `../../web/genericl10n.js`: GenericL10n
- `../../web/l10n.js`: L10n
- `../../web/l10n_utils.js`: NullL10n
- `../../web/pdf_find_controller.js`: FindState, PDFFindController
- `../../web/pdf_find_utils.js`: CharacterType, getCharacterType
- `../../web/pdf_history.js`: PDFHistory, isDestArraysEqual, isDestHashesEqual
- `../../web/pdf_link_service.js`: LinkTarget, PDFLinkService, SimpleLinkService
- `../../web/pdf_page_view.js`: PDFPageView
- `../../web/pdf_scripting_manager.component.js`: PDFScriptingManager
- `../../web/pdf_single_page_viewer.js`: PDFSinglePageViewer
- `../../web/pdf_viewer.js`: PDFPageViewBuffer, PDFViewer
- `../../web/struct_tree_layer_builder.js`: StructTreeLayerBuilder
- `../../web/text_layer_builder.js`: TextLayerBuilder
- `../../web/ui_utils.js`: AutoPrintRegExp, ProgressBar, RenderingStates, ScrollMode, SpreadMode, backtrackBeforeAllVisibleElements, binarySearchFirstItem, getPageSizeInches, getVisibleElements, isPortraitOrientation, isValidRotation, parseQueryString, removeNullCharacters
- `../../web/xfa_layer_builder.js`: XfaLayerBuilder
- `./test_utils.js`: CMAP_URL, DefaultFileReaderFactory, STANDARD_FONT_DATA_URL, TEST_PDFS_PATH, XRefMock, buildGetDocumentParams, createIdFactory
- `./testreporter.js`: TestReporter
</imports>

Code:
<code>
File:
src/core/evaluator.js
1 /* Copyright 2012 Mozilla Foundation
2  *
3  * Licensed under the Apache License, Version 2.0 (the "License");
4  * you may not use this file except in compliance with the License.
5  * You may obtain a copy of the License at
6  *
7  *     http://www.apache.org/licenses/LICENSE-2.0
8  *
9  * Unless required by applicable law or agreed to in writing, software
10  * distributed under the License is distributed on an "AS IS" BASIS,
11  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
12  * See the License for the specific language governing permissions and
13  * limitations under the License.
14  */
15 /* eslint-disable no-var */
16 
17 import {
18   AbortException,
19   assert,
20   CMapCompressionType,
21   FONT_IDENTITY_MATRIX,
22   FormatError,
23   IDENTITY_MATRIX,
24   info,
25   isArrayEqual,
26   normalizeUnicode,
27   OPS,
28   PromiseCapability,
29   shadow,
30   stringToPDFString,
31   TextRenderingMode,
32   Util,
33   warn,
34 } from "../shared/util.js";
35 import { CMapFactory, IdentityCMap } from "./cmap.js";
36 import { Cmd, Dict, EOF, isName, Name, Ref, RefSet } from "./primitives.js";
37 import { ErrorFont, Font } from "./fonts.js";
38 import {
39   getEncoding,
40   MacRomanEncoding,
41   StandardEncoding,
42   SymbolSetEncoding,
43   WinAnsiEncoding,
44   ZapfDingbatsEncoding,
45 } from "./encodings.js";
46 import {
47   getFontNameToFileMap,
48   getSerifFonts,
49   getStandardFontName,
50   getStdFontMap,
51   getSymbolsFonts,
52   isKnownFontName,
53 } from "./standard_fonts.js";
54 import { getTilingPatternIR, Pattern } from "./pattern.js";
55 import { getXfaFontDict, getXfaFontName } from "./xfa_fonts.js";
56 import { IdentityToUnicodeMap, ToUnicodeMap } from "./to_unicode_map.js";
57 import { isPDFFunction, PDFFunctionFactory } from "./function.js";
58 import { Lexer, Parser } from "./parser.js";
59 import {
60   LocalColorSpaceCache,
61   LocalGStateCache,
62   LocalImageCache,
63   LocalTilingPatternCache,
64   RegionalImageCache,
65 } from "./image_utils.js";
66 import { NullStream, Stream } from "./stream.js";
67 import { BaseStream } from "./base_stream.js";
68 import { bidi } from "./bidi.js";
69 import { ColorSpace } from "./colorspace.js";
70 import { DecodeStream } from "./decode_stream.js";
71 import { FontFlags } from "./fonts_utils.js";
72 import { getFontSubstitution } from "./font_substitutions.js";
73 import { getGlyphsUnicode } from "./glyphlist.js";
74 import { getMetrics } from "./metrics.js";
75 import { getUnicodeForGlyph } from "./unicode.js";
76 import { ImageResizer } from "./image_resizer.js";
77 import { MurmurHash3_64 } from "../shared/murmurhash3.js";
78 import { OperatorList } from "./operator_list.js";
79 import { PDFImage } from "./image.js";
80 
81 const DefaultPartialEvaluatorOptions = Object.freeze({
82   maxImageSize: -1,
83   disableFontFace: false,
84   ignoreErrors: false,
85   isEvalSupported: true,
86   isOffscreenCanvasSupported: false,
87   canvasMaxAreaInBytes: -1,
88   fontExtraProperties: false,
89   useSystemFonts: true,
90   cMapUrl: null,
91   standardFontDataUrl: null,
92 });
93 
94 const PatternType = {
95   TILING: 1,
96   SHADING: 2,
97 };
98 
99 // Optionally avoid sending individual, or very few, text chunks to reduce
100 // `postMessage` overhead with ReadableStream (see issue 13962).
101 //
102 // PLEASE NOTE: This value should *not* be too large (it's used as a lower limit
103 // in `enqueueChunk`), since that would cause streaming of textContent to become
104 // essentially useless in practice by sending all (or most) chunks at once.
105 // Also, a too large value would (indirectly) affect the main-thread `textLayer`
106 // building negatively by forcing all textContent to be handled at once, which
107 // could easily end up hurting *overall* performance (e.g. rendering as well).
108 const TEXT_CHUNK_BATCH_SIZE = 10;
109 
110 const deferred = Promise.resolve();
111 
112 // Convert PDF blend mode names to HTML5 blend mode names.
113 function normalizeBlendMode(value, parsingArray = false) {
114   if (Array.isArray(value)) {
115     // Use the first *supported* BM value in the Array (fixes issue11279.pdf).
116     for (const val of value) {
117       const maybeBM = normalizeBlendMode(val, /* parsingArray = */ true);
118       if (maybeBM) {
119         return maybeBM;
120       }
121     }
122     warn(`Unsupported blend mode Array: ${value}`);
123     return "source-over";
124   }
125 
126   if (!(value instanceof Name)) {
127     if (parsingArray) {
128       return null;
129     }
130     return "source-over";
131   }
132   switch (value.name) {
133     case "Normal":
134     case "Compatible":
135       return "source-over";
136     case "Multiply":
137       return "multiply";
138     case "Screen":
139       return "screen";
140     case "Overlay":
141       return "overlay";
142     case "Darken":
143       return "darken";
144     case "Lighten":
145       return "lighten";
146     case "ColorDodge":
147       return "color-dodge";
148     case "ColorBurn":
149       return "color-burn";
150     case "HardLight":
151       return "hard-light";
152     case "SoftLight":
153       return "soft-light";
154     case "Difference":
155       return "difference";
156     case "Exclusion":
157       return "exclusion";
158     case "Hue":
159       return "hue";
160     case "Saturation":
161       return "saturation";
162     case "Color":
163       return "color";
164     case "Luminosity":
165       return "luminosity";
166   }
167   if (parsingArray) {
168     return null;
169   }
170   warn(`Unsupported blend mode: ${value.name}`);
171   return "source-over";
172 }
173 
174 function incrementCachedImageMaskCount(data) {
175   if (data.fn === OPS.paintImageMaskXObject && data.args[0]?.count > 0) {
176     data.args[0].count++;
177   }
178 }
179 
180 // Trying to minimize Date.now() usage and check every 100 time.
181 class TimeSlotManager {
182   static TIME_SLOT_DURATION_MS = 20;
183 
184   static CHECK_TIME_EVERY = 100;
185 
186   constructor() {
187     this.reset();
188   }
189 
190   check() {
191     if (++this.checked < TimeSlotManager.CHECK_TIME_EVERY) {
192       return false;
193     }
194     this.checked = 0;
195     return this.endTime <= Date.now();
196   }
197 
198   reset() {
199     this.endTime = Date.now() + TimeSlotManager.TIME_SLOT_DURATION_MS;
200     this.checked = 0;
201   }
202 }
203 
204 class PartialEvaluator {
205   constructor({
206     xref,
207     handler,
208     pageIndex,
209     idFactory,
210     fontCache,
211     builtInCMapCache,
212     standardFontDataCache,
213     globalImageCache,
214     systemFontCache,
215     options = null,
216   }) {
217     this.xref = xref;
218     this.handler = handler;
219     this.pageIndex = pageIndex;
220     this.idFactory = idFactory;
221     this.fontCache = fontCache;
222     this.builtInCMapCache = builtInCMapCache;
223     this.standardFontDataCache = standardFontDataCache;
224     this.globalImageCache = globalImageCache;
225     this.systemFontCache = systemFontCache;
226     this.options = options || DefaultPartialEvaluatorOptions;
227     this.parsingType3Font = false;
228 
229     this._regionalImageCache = new RegionalImageCache();
230     this._fetchBuiltInCMapBound = this.fetchBuiltInCMap.bind(this);
231     ImageResizer.setMaxArea(this.options.canvasMaxAreaInBytes);
232   }
233 
234   /**
235    * Since Functions are only cached (locally) by reference, we can share one
236    * `PDFFunctionFactory` instance within this `PartialEvaluator` instance.
237    */
238   get _pdfFunctionFactory() {
239     const pdfFunctionFactory = new PDFFunctionFactory({
240       xref: this.xref,
241       isEvalSupported: this.options.isEvalSupported,
242     });
243     return shadow(this, "_pdfFunctionFactory", pdfFunctionFactory);
244   }
245 
246   clone(newOptions = null) {
247     const newEvaluator = Object.create(this);
248     newEvaluator.options = Object.assign(
249       Object.create(null),
250       this.options,
251       newOptions
252     );
253     return newEvaluator;
254   }
255 
256   hasBlendModes(resources, nonBlendModesSet) {
257     if (!(resources instanceof Dict)) {
258       return false;
259     }
260     if (resources.objId && nonBlendModesSet.has(resources.objId)) {
261       return false;
262     }
263 
264     const processed = new RefSet(nonBlendModesSet);
265     if (resources.objId) {
266       processed.put(resources.objId);
267     }
268 
269     const nodes = [resources],
270       xref = this.xref;
271     while (nodes.length) {
272       const node = nodes.shift();
273       // First check the current resources for blend modes.
274       const graphicStates = node.get("ExtGState");
275       if (graphicStates instanceof Dict) {
276         for (let graphicState of graphicStates.getRawValues()) {
277           if (graphicState instanceof Ref) {
278             if (processed.has(graphicState)) {
279               continue; // The ExtGState has already been processed.
280             }
281             try {
282               graphicState = xref.fetch(graphicState);
283             } catch (ex) {
284               // Avoid parsing a corrupt ExtGState more than once.
285               processed.put(graphicState);
286 
287               info(`hasBlendModes - ignoring ExtGState: "${ex}".`);
288               continue;
289             }
290           }
291           if (!(graphicState instanceof Dict)) {
292             continue;
293           }
294           if (graphicState.objId) {
295             processed.put(graphicState.objId);
296           }
297 
298           const bm = graphicState.get("BM");
299           if (bm instanceof Name) {
300             if (bm.name !== "Normal") {
301               return true;
302             }
303             continue;
304           }
305           if (bm !== undefined && Array.isArray(bm)) {
306             for (const element of bm) {
307               if (element instanceof Name && element.name !== "Normal") {
308                 return true;
309               }
310             }
311           }
312         }
313       }
314       // Descend into the XObjects to look for more resources and blend modes.
315       const xObjects = node.get("XObject");
316       if (!(xObjects instanceof Dict)) {
317         continue;
318       }
319       for (let xObject of xObjects.getRawValues()) {
320         if (xObject instanceof Ref) {
321           if (processed.has(xObject)) {
322             // The XObject has already been processed, and by avoiding a
323             // redundant `xref.fetch` we can *significantly* reduce the load
324             // time for badly generated PDF files (fixes issue6961.pdf).
325             continue;
326           }
327           try {
328             xObject = xref.fetch(xObject);
329           } catch (ex) {
330             // Avoid parsing a corrupt XObject more than once.
331             processed.put(xObject);
332 
333             info(`hasBlendModes - ignoring XObject: "${ex}".`);
334             continue;
335           }
336         }
337         if (!(xObject instanceof BaseStream)) {
338           continue;
339         }
340         if (xObject.dict.objId) {
341           processed.put(xObject.dict.objId);
342         }
343         const xResources = xObject.dict.get("Resources");
344         if (!(xResources instanceof Dict)) {
345           continue;
346         }
347         // Checking objId to detect an infinite loop.
348         if (xResources.objId && processed.has(xResources.objId)) {
349           continue;
350         }
351 
352         nodes.push(xResources);
353         if (xResources.objId) {
354           processed.put(xResources.objId);
355         }
356       }
357     }
358 
359     // When no blend modes exist, there's no need re-fetch/re-parse any of the
360     // processed `Ref`s again for subsequent pages. This helps reduce redundant
361     // `XRef.fetch` calls for some documents (e.g. issue6961.pdf).
362     for (const ref of processed) {
363       nonBlendModesSet.put(ref);
364     }
365     return false;
366   }
367 
368   async fetchBuiltInCMap(name) {
369     const cachedData = this.builtInCMapCache.get(name);
370     if (cachedData) {
371       return cachedData;
372     }
373     let data;
374 
375     if (this.options.cMapUrl !== null) {
376       // Only compressed CMaps are (currently) supported here.
377       const url = `${this.options.cMapUrl}${name}.bcmap`;
378       const response = await fetch(url);
379       if (!response.ok) {
380         throw new Error(
381           `fetchBuiltInCMap: failed to fetch file "${url}" with "${response.statusText}".`
382         );
383       }
384       data = {
385         cMapData: new Uint8Array(await response.arrayBuffer()),
386         compressionType: CMapCompressionType.BINARY,
387       };
388     } else {
389       // Get the data on the main-thread instead.
390       data = await this.handler.sendWithPromise("FetchBuiltInCMap", { name });
391     }
392 
393     if (data.compressionType !== CMapCompressionType.NONE) {
394       // Given the size of uncompressed CMaps, only cache compressed ones.
395       this.builtInCMapCache.set(name, data);
396     }
397     return data;
398   }
399 
400   async fetchStandardFontData(name) {
401     const cachedData = this.standardFontDataCache.get(name);
402     if (cachedData) {
403       return new Stream(cachedData);
404     }
405 
406     // The symbol fonts are not consistent across platforms, always load the
407     // standard font data for them.
408     if (
409       this.options.useSystemFonts &&
410       name !== "Symbol" &&
411       name !== "ZapfDingbats"
412     ) {
413       return null;
414     }
415 
416     const standardFontNameToFileName = getFontNameToFileMap(),
417       filename = standardFontNameToFileName[name];
418     let data;
419 
420     if (this.options.standardFontDataUrl !== null) {
421       const url = `${this.options.standardFontDataUrl}${filename}`;
422       const response = await fetch(url);
423       if (!response.ok) {
424         warn(
425           `fetchStandardFontData: failed to fetch file "${url}" with "${response.statusText}".`
426         );
427       } else {
428         data = new Uint8Array(await response.arrayBuffer());
429       }
430     } else {
431       // Get the data on the main-thread instead.
432       try {
433         data = await this.handler.sendWithPromise("FetchStandardFontData", {
434           filename,
435         });
436       } catch (e) {
437         warn(
438           `fetchStandardFontData: failed to fetch file "${filename}" with "${e}".`
439         );
440       }
441     }
442 
443     if (!data) {
444       return null;
445     }
446     // Cache the "raw" standard font data, to avoid fetching it repeatedly
447     // (see e.g. issue 11399).
448     this.standardFontDataCache.set(name, data);
449 
450     return new Stream(data);
451   }
452 
453   async buildFormXObject(
454     resources,
455     xobj,
456     smask,
457     operatorList,
458     task,
459     initialState,
460     localColorSpaceCache
461   ) {
462     const dict = xobj.dict;
463     const matrix = dict.getArray("Matrix");
464     let bbox = dict.getArray("BBox");
465     bbox =
466       Array.isArray(bbox) && bbox.length === 4
467         ? Util.normalizeRect(bbox)
468         : null;
469 
470     let optionalContent, groupOptions;
471     if (dict.has("OC")) {
472       optionalContent = await this.parseMarkedContentProps(
473         dict.get("OC"),
474         resources
475       );
476     }
477     if (optionalContent !== undefined) {
478       operatorList.addOp(OPS.beginMarkedContentProps, ["OC", optionalContent]);
479     }
480     const group = dict.get("Group");
481     if (group) {
482       groupOptions = {
483         matrix,
484         bbox,
485         smask,
486         isolated: false,
487         knockout: false,
488       };
489 
490       const groupSubtype = group.get("S");
491       let colorSpace = null;
492       if (isName(groupSubtype, "Transparency")) {
493         groupOptions.isolated = group.get("I") || false;
494         groupOptions.knockout = group.get("K") || false;
495         if (group.has("CS")) {
496           const cs = group.getRaw("CS");
497 
498           const cachedColorSpace = ColorSpace.getCached(
499             cs,
500             this.xref,
501             localColorSpaceCache
502           );
503           if (cachedColorSpace) {
504             colorSpace = cachedColorSpace;
505           } else {
506             colorSpace = await this.parseColorSpace({
507               cs,
508               resources,
509               localColorSpaceCache,
510             });
511           }
512         }
513       }
514 
515       if (smask?.backdrop) {
516         colorSpace ||= ColorSpace.singletons.rgb;
517         smask.backdrop = colorSpace.getRgb(smask.backdrop, 0);
518       }
519 
520       operatorList.addOp(OPS.beginGroup, [groupOptions]);
521     }
522 
523     // If it's a group, a new canvas will be created that is the size of the
524     // bounding box and translated to the correct position so we don't need to
525     // apply the bounding box to it.
526     const args = group ? [matrix, null] : [matrix, bbox];
527     operatorList.addOp(OPS.paintFormXObjectBegin, args);
528 
529     return this.getOperatorList({
530       stream: xobj,
531       task,
532       resources: dict.get("Resources") || resources,
533       operatorList,
534       initialState,
535     }).then(function () {
536       operatorList.addOp(OPS.paintFormXObjectEnd, []);
537 
538       if (group) {
539         operatorList.addOp(OPS.endGroup, [groupOptions]);
540       }
541 
542       if (optionalContent !== undefined) {
543         operatorList.addOp(OPS.endMarkedContent, []);
544       }
545     });
546   }
547 
548   _sendImgData(objId, imgData, cacheGlobally = false) {
549     if (
550       (typeof PDFJSDev === "undefined" || PDFJSDev.test("TESTING")) &&
551       imgData
552     ) {
553       assert(Number.isInteger(imgData.dataLen), "Expected dataLen to be set.");
554     }
555     const transfers = imgData ? [imgData.bitmap || imgData.data.buffer] : null;
556 
557     if (this.parsingType3Font || cacheGlobally) {
558       return this.handler.send(
559         "commonobj",
560         [objId, "Image", imgData],
561         transfers
562       );
563     }
564     return this.handler.send(
565       "obj",
566       [objId, this.pageIndex, "Image", imgData],
567       transfers
568     );
569   }
570 
571   async buildPaintImageXObject({
572     resources,
573     image,
574     isInline = false,
575     operatorList,
576     cacheKey,
577     localImageCache,
578     localColorSpaceCache,
579   }) {
580     const dict = image.dict;
581     const imageRef = dict.objId;
582     const w = dict.get("W", "Width");
583     const h = dict.get("H", "Height");
584 
585     if (!(w && typeof w === "number") || !(h && typeof h === "number")) {
586       warn("Image dimensions are missing, or not numbers.");
587       return;
588     }
589     const maxImageSize = this.options.maxImageSize;
590     if (maxImageSize !== -1 && w * h > maxImageSize) {
591       const msg = "Image exceeded maximum allowed size and was removed.";
592 
593       if (this.options.ignoreErrors) {
594         warn(msg);
595         return;
596       }
597       throw new Error(msg);
598     }
599 
600     let optionalContent;
601     if (dict.has("OC")) {
602       optionalContent = await this.parseMarkedContentProps(
603         dict.get("OC"),
604         resources
605       );
606     }
607 
608     const imageMask = dict.get("IM", "ImageMask") || false;
609     let imgData, args;
610     if (imageMask) {
611       // This depends on a tmpCanvas being filled with the
612       // current fillStyle, such that processing the pixel
613       // data can't be done here. Instead of creating a
614       // complete PDFImage, only read the information needed
615       // for later.
616       const interpolate = dict.get("I", "Interpolate");
617       const bitStrideLength = (w + 7) >> 3;
618       const imgArray = image.getBytes(bitStrideLength * h);
619       const decode = dict.getArray("D", "Decode");
620 
621       if (this.parsingType3Font) {
622         imgData = PDFImage.createRawMask({
623           imgArray,
624           width: w,
625           height: h,
626           imageIsFromDecodeStream: image instanceof DecodeStream,
627           inverseDecode: decode?.[0] > 0,
628           interpolate,
629         });
630 
631         imgData.cached = !!cacheKey;
632         args = [imgData];
633 
634         operatorList.addImageOps(
635           OPS.paintImageMaskXObject,
636           args,
637           optionalContent
638         );
639 
640         if (cacheKey) {
641           const cacheData = {
642             fn: OPS.paintImageMaskXObject,
643             args,
644             optionalContent,
645           };
646           localImageCache.set(cacheKey, imageRef, cacheData);
647 
648           if (imageRef) {
649             this._regionalImageCache.set(
650               /* name = */ null,
651               imageRef,
652               cacheData
653             );
654           }
655         }
656         return;
657       }
658 
659       imgData = await PDFImage.createMask({
660         imgArray,
661         width: w,
662         height: h,
663         imageIsFromDecodeStream: image instanceof DecodeStream,
664         inverseDecode: decode?.[0] > 0,
665         interpolate,
666         isOffscreenCanvasSupported: this.options.isOffscreenCanvasSupported,
667       });
668 
669       if (imgData.isSingleOpaquePixel) {
670         // Handles special case of mainly LaTeX documents which use image
671         // masks to draw lines with the current fill style.
672         operatorList.addImageOps(
673           OPS.paintSolidColorImageMask,
674           [],
675           optionalContent
676         );
677 
678         if (cacheKey) {
679           const cacheData = {
680             fn: OPS.paintSolidColorImageMask,
681             args: [],
682             optionalContent,
683           };
684           localImageCache.set(cacheKey, imageRef, cacheData);
685 
686           if (imageRef) {
687             this._regionalImageCache.set(
688               /* name = */ null,
689               imageRef,
690               cacheData
691             );
692           }
693         }
694         return;
695       }
696 
697       const objId = `mask_${this.idFactory.createObjId()}`;
698       operatorList.addDependency(objId);
699 
700       imgData.dataLen = imgData.bitmap
701         ? imgData.width * imgData.height * 4
702         : imgData.data.length;
703       this._sendImgData(objId, imgData);
704 
705       args = [
706         {
707           data: objId,
708           width: imgData.width,
709           height: imgData.height,
710           interpolate: imgData.interpolate,
711           count: 1,
712         },
713       ];
714       operatorList.addImageOps(
715         OPS.paintImageMaskXObject,
716         args,
717         optionalContent
718       );
719 
720       if (cacheKey) {
721         const cacheData = {
722           fn: OPS.paintImageMaskXObject,
723           args,
724           optionalContent,
725         };
726         localImageCache.set(cacheKey, imageRef, cacheData);
727 
728         if (imageRef) {
729           this._regionalImageCache.set(/* name = */ null, imageRef, cacheData);
730         }
731       }
732       return;
733     }
734 
735     const SMALL_IMAGE_DIMENSIONS = 200;
736     // Inlining small images into the queue as RGB data
737     if (
738       isInline &&
739       !dict.has("SMask") &&
740       !dict.has("Mask") &&
741       w + h < SMALL_IMAGE_DIMENSIONS
742     ) {
743       const imageObj = new PDFImage({
744         xref: this.xref,
745         res: resources,
746         image,
747         isInline,
748         pdfFunctionFactory: this._pdfFunctionFactory,
749         localColorSpaceCache,
750       });
751       // We force the use of RGBA_32BPP images here, because we can't handle
752       // any other kind.
753       imgData = await imageObj.createImageData(
754         /* forceRGBA = */ true,
755         /* isOffscreenCanvasSupported = */ false
756       );
757       operatorList.isOffscreenCanvasSupported =
758         this.options.isOffscreenCanvasSupported;
759       operatorList.addImageOps(
760         OPS.paintInlineImageXObject,
761         [imgData],
762         optionalContent
763       );
764       return;
765     }
766 
767     // If there is no imageMask, create the PDFImage and a lot
768     // of image processing can be done here.
769     let objId = `img_${this.idFactory.createObjId()}`,
770       cacheGlobally = false;
771 
772     if (this.parsingType3Font) {
773       objId = `${this.idFactory.getDocId()}_type3_${objId}`;
774     } else if (cacheKey && imageRef) {
775       cacheGlobally = this.globalImageCache.shouldCache(
776         imageRef,
777         this.pageIndex
778       );
779 
780       if (cacheGlobally) {
781         assert(!isInline, "Cannot cache an inline image globally.");
782 
783         objId = `${this.idFactory.getDocId()}_${objId}`;
784       }
785     }
786 
787     // Ensure that the dependency is added before the image is decoded.
788     operatorList.addDependency(objId);
789     args = [objId, w, h];
790     operatorList.addImageOps(OPS.paintImageXObject, args, optionalContent);
791 
792     // For large images, at least 500x500 in size, that we'll cache globally
793     // check if the image is still cached locally on the main-thread to avoid
794     // having to re-parse the image (since that can be slow).
795     if (cacheGlobally && w * h > 250000) {
796       const localLength = await this.handler.sendWithPromise("commonobj", [
797         objId,
798         "CopyLocalImage",
799         { imageRef },
800       ]);
801 
802       if (localLength) {
803         this.globalImageCache.setData(imageRef, {
804           objId,
805           fn: OPS.paintImageXObject,
806           args,
807           optionalContent,
808           byteSize: 0, // Temporary entry, to avoid `setData` returning early.
809         });
810         this.globalImageCache.addByteSize(imageRef, localLength);
811         return;
812       }
813     }
814 
815     PDFImage.buildImage({
816       xref: this.xref,
817       res: resources,
818       image,
819       isInline,
820       pdfFunctionFactory: this._pdfFunctionFactory,
821       localColorSpaceCache,
822     })
823       .then(async imageObj => {
824         imgData = await imageObj.createImageData(
825           /* forceRGBA = */ false,
826           /* isOffscreenCanvasSupported = */ this.options
827             .isOffscreenCanvasSupported
828         );
829         imgData.dataLen = imgData.bitmap
830           ? imgData.width * imgData.height * 4
831           : imgData.data.length;
832         imgData.ref = imageRef;
833 
834         if (cacheGlobally) {
835           this.globalImageCache.addByteSize(imageRef, imgData.dataLen);
836         }
837         return this._sendImgData(objId, imgData, cacheGlobally);
838       })
839       .catch(reason => {
840         warn(`Unable to decode image "${objId}": "${reason}".`);
841 
842         return this._sendImgData(objId, /* imgData = */ null, cacheGlobally);
843       });
844 
845     if (cacheKey) {
846       const cacheData = {
847         fn: OPS.paintImageXObject,
848         args,
849         optionalContent,
850       };
851       localImageCache.set(cacheKey, imageRef, cacheData);
852 
853       if (imageRef) {
854         this._regionalImageCache.set(/* name = */ null, imageRef, cacheData);
855 
856         if (cacheGlobally) {
857           this.globalImageCache.setData(imageRef, {
858             objId,
859             fn: OPS.paintImageXObject,
860             args,
861             optionalContent,
862             byteSize: 0, // Temporary entry, note `addByteSize` above.
863           });
864         }
865       }
866     }
867   }
868 
869   handleSMask(
870     smask,
871     resources,
872     operatorList,
873     task,
874     stateManager,
875     localColorSpaceCache
876   ) {
877     const smaskContent = smask.get("G");
878     const smaskOptions = {
879       subtype: smask.get("S").name,
880       backdrop: smask.get("BC"),
881     };
882 
883     // The SMask might have a alpha/luminosity value transfer function --
884     // we will build a map of integer values in range 0..255 to be fast.
885     const transferObj = smask.get("TR");
886     if (isPDFFunction(transferObj)) {
887       const transferFn = this._pdfFunctionFactory.create(transferObj);
888       const transferMap = new Uint8Array(256);
889       const tmp = new Float32Array(1);
890       for (let i = 0; i < 256; i++) {
891         tmp[0] = i / 255;
892         transferFn(tmp, 0, tmp, 0);
893         transferMap[i] = (tmp[0] * 255) | 0;
894       }
895       smaskOptions.transferMap = transferMap;
896     }
897 
898     return this.buildFormXObject(
899       resources,
900       smaskContent,
901       smaskOptions,
902       operatorList,
903       task,
904       stateManager.state.clone(),
905       localColorSpaceCache
906     );
907   }
908 
909   handleTransferFunction(tr) {
910     let transferArray;
911     if (Array.isArray(tr)) {
912       transferArray = tr;
913     } else if (isPDFFunction(tr)) {
914       transferArray = [tr];
915     } else {
916       return null; // Not a valid transfer function entry.
917     }
918 
919     const transferMaps = [];
920     let numFns = 0,
921       numEffectfulFns = 0;
922     for (const entry of transferArray) {
923       const transferObj = this.xref.fetchIfRef(entry);
924       numFns++;
925 
926       if (isName(transferObj, "Identity")) {
927         transferMaps.push(null);
928         continue;
929       } else if (!isPDFFunction(transferObj)) {
930         return null; // Not a valid transfer function object.
931       }
932 
933       const transferFn = this._pdfFunctionFactory.create(transferObj);
934       const transferMap = new Uint8Array(256),
935         tmp = new Float32Array(1);
936       for (let j = 0; j < 256; j++) {
937         tmp[0] = j / 255;
938         transferFn(tmp, 0, tmp, 0);
939         transferMap[j] = (tmp[0] * 255) | 0;
940       }
941       transferMaps.push(transferMap);
942       numEffectfulFns++;
943     }
944 
945     if (!(numFns === 1 || numFns === 4)) {
946       return null; // Only 1 or 4 functions are supported, by the specification.
947     }
948     if (numEffectfulFns === 0) {
949       return null; // Only /Identity transfer functions found, which are no-ops.
950     }
951     return transferMaps;
952   }
953 
954   handleTilingType(
955     fn,
956     color,
957     resources,
958     pattern,
959     patternDict,
960     operatorList,
961     task,
962     localTilingPatternCache
963   ) {
964     // Create an IR of the pattern code.
965     const tilingOpList = new OperatorList();
966     // Merge the available resources, to prevent issues when the patternDict
967     // is missing some /Resources entries (fixes issue6541.pdf).
968     const patternResources = Dict.merge({
969       xref: this.xref,
970       dictArray: [patternDict.get("Resources"), resources],
971     });
972 
973     return this.getOperatorList({
974       stream: pattern,
975       task,
976       resources: patternResources,
977       operatorList: tilingOpList,
978     })
979       .then(function () {
980         const operatorListIR = tilingOpList.getIR();
981         const tilingPatternIR = getTilingPatternIR(
982           operatorListIR,
983           patternDict,
984           color
985         );
986         // Add the dependencies to the parent operator list so they are
987         // resolved before the sub operator list is executed synchronously.
988         operatorList.addDependencies(tilingOpList.dependencies);
989         operatorList.addOp(fn, tilingPatternIR);
990 
991         if (patternDict.objId) {
992           localTilingPatternCache.set(/* name = */ null, patternDict.objId, {
993             operatorListIR,
994             dict: patternDict,
995           });
996         }
997       })
998       .catch(reason => {
999         if (reason instanceof AbortException) {
1000           return;
1001         }
1002         if (this.options.ignoreErrors) {
1003           warn(`handleTilingType - ignoring pattern: "${reason}".`);
1004           return;
1005         }
1006         throw reason;
1007       });
1008   }
1009 
1010   handleSetFont(
1011     resources,
1012     fontArgs,
1013     fontRef,
1014     operatorList,
1015     task,
1016     state,
1017     fallbackFontDict = null,
1018     cssFontInfo = null
1019   ) {
1020     const fontName = fontArgs?.[0] instanceof Name ? fontArgs[0].name : null;
1021 
1022     return this.loadFont(
1023       fontName,
1024       fontRef,
1025       resources,
1026       fallbackFontDict,
1027       cssFontInfo
1028     )
1029       .then(translated => {
1030         if (!translated.font.isType3Font) {
1031           return translated;
1032         }
1033         return translated
1034           .loadType3Data(this, resources, task)
1035           .then(function () {
1036             // Add the dependencies to the parent operatorList so they are
1037             // resolved before Type3 operatorLists are executed synchronously.
1038             operatorList.addDependencies(translated.type3Dependencies);
1039 
1040             return translated;
1041           })
1042           .catch(
1043             reason =>
1044               new TranslatedFont({
1045                 loadedName: "g_font_error",
1046                 font: new ErrorFont(`Type3 font load error: ${reason}`),
1047                 dict: translated.font,
1048                 evaluatorOptions: this.options,
1049               })
1050           );
1051       })
1052       .then(translated => {
1053         state.font = translated.font;
1054         translated.send(this.handler);
1055         return translated.loadedName;
1056       });
1057   }
1058 
1059   handleText(chars, state) {
1060     const font = state.font;
1061     const glyphs = font.charsToGlyphs(chars);
1062 
1063     if (font.data) {
1064       const isAddToPathSet = !!(
1065         state.textRenderingMode & TextRenderingMode.ADD_TO_PATH_FLAG
1066       );
1067       if (
1068         isAddToPathSet ||
1069         state.fillColorSpace.name === "Pattern" ||
1070         font.disableFontFace ||
1071         this.options.disableFontFace
1072       ) {
1073         PartialEvaluator.buildFontPaths(
1074           font,
1075           glyphs,
1076           this.handler,
1077           this.options
1078         );
1079       }
1080     }
1081     return glyphs;
1082   }
1083 
1084   ensureStateFont(state) {
1085     if (state.font) {
1086       return;
1087     }
1088     const reason = new FormatError(
1089       "Missing setFont (Tf) operator before text rendering operator."
1090     );
1091 
1092     if (this.options.ignoreErrors) {
1093       warn(`ensureStateFont: "${reason}".`);
1094       return;
1095     }
1096     throw reason;
1097   }
1098 
1099   async setGState({
1100     resources,
1101     gState,
1102     operatorList,
1103     cacheKey,
1104     task,
1105     stateManager,
1106     localGStateCache,
1107     localColorSpaceCache,
1108   }) {
1109     const gStateRef = gState.objId;
1110     let isSimpleGState = true;
1111     // This array holds the converted/processed state data.
1112     const gStateObj = [];
1113     let promise = Promise.resolve();
1114     for (const key of gState.getKeys()) {
1115       const value = gState.get(key);
1116       switch (key) {
1117         case "Type":
1118           break;
1119         case "LW":
1120         case "LC":
1121         case "LJ":
1122         case "ML":
1123         case "D":
1124         case "RI":
1125         case "FL":
1126         case "CA":
1127         case "ca":
1128           gStateObj.push([key, value]);
1129           break;
1130         case "Font":
1131           isSimpleGState = false;
1132 
1133           // eslint-disable-next-line arrow-body-style
1134           promise = promise.then(() => {
1135             return this.handleSetFont(
1136               resources,
1137               null,
1138               value[0],
1139               operatorList,
1140               task,
1141               stateManager.state
1142             ).then(function (loadedName) {
1143               operatorList.addDependency(loadedName);
1144               gStateObj.push([key, [loadedName, value[1]]]);
1145             });
1146           });
1147           break;
1148         case "BM":
1149           gStateObj.push([key, normalizeBlendMode(value)]);
1150           break;
1151         case "SMask":
1152           if (isName(value, "None")) {
1153             gStateObj.push([key, false]);
1154             break;
1155           }
1156           if (value instanceof Dict) {
1157             isSimpleGState = false;
1158 
1159             // eslint-disable-next-line arrow-body-style
1160             promise = promise.then(() => {
1161               return this.handleSMask(
1162                 value,
1163                 resources,
1164                 operatorList,
1165                 task,
1166                 stateManager,
1167                 localColorSpaceCache
1168               );
1169             });
1170             gStateObj.push([key, true]);
1171           } else {
1172             warn("Unsupported SMask type");
1173           }
1174           break;
1175         case "TR":
1176           const transferMaps = this.handleTransferFunction(value);
1177           gStateObj.push([key, transferMaps]);
1178           break;
1179         // Only generate info log messages for the following since
1180         // they are unlikely to have a big impact on the rendering.
1181         case "OP":
1182         case "op":
1183         case "OPM":
1184         case "BG":
1185         case "BG2":
1186         case "UCR":
1187         case "UCR2":
1188         case "TR2":
1189         case "HT":
1190         case "SM":
1191         case "SA":
1192         case "AIS":
1193         case "TK":
1194           // TODO implement these operators.
1195           info("graphic state operator " + key);
1196           break;
1197         default:
1198           info("Unknown graphic state operator " + key);
1199           break;
1200       }
1201     }
1202     return promise.then(function () {
1203       if (gStateObj.length > 0) {
1204         operatorList.addOp(OPS.setGState, [gStateObj]);
1205       }
1206 
1207       if (isSimpleGState) {
1208         localGStateCache.set(cacheKey, gStateRef, gStateObj);
1209       }
1210     });
1211   }
1212 
1213   loadFont(
1214     fontName,
1215     font,
1216     resources,
1217     fallbackFontDict = null,
1218     cssFontInfo = null
1219   ) {
1220     // eslint-disable-next-line arrow-body-style
1221     const errorFont = async () => {
1222       return new TranslatedFont({
1223         loadedName: "g_font_error",
1224         font: new ErrorFont(`Font "${fontName}" is not available.`),
1225         dict: font,
1226         evaluatorOptions: this.options,
1227       });
1228     };
1229 
1230     let fontRef;
1231     if (font) {
1232       // Loading by ref.
1233       if (font instanceof Ref) {
1234         fontRef = font;
1235       }
1236     } else {
1237       // Loading by name.
1238       const fontRes = resources.get("Font");
1239       if (fontRes) {
1240         fontRef = fontRes.getRaw(fontName);
1241       }
1242     }
1243     if (fontRef) {
1244       if (this.parsingType3Font && this.type3FontRefs.has(fontRef)) {
1245         return errorFont();
1246       }
1247 
1248       if (this.fontCache.has(fontRef)) {
1249         return this.fontCache.get(fontRef);
1250       }
1251 
1252       font = this.xref.fetchIfRef(fontRef);
1253     }
1254 
1255     if (!(font instanceof Dict)) {
1256       if (!this.options.ignoreErrors && !this.parsingType3Font) {
1257         warn(`Font "${fontName}" is not available.`);
1258         return errorFont();
1259       }
1260       warn(
1261         `Font "${fontName}" is not available -- attempting to fallback to a default font.`
1262       );
1263 
1264       // Falling back to a default font to avoid completely broken rendering,
1265       // but note that there're no guarantees that things will look "correct".
1266       font = fallbackFontDict || PartialEvaluator.fallbackFontDict;
1267     }
1268 
1269     // We are holding `font.cacheKey` references only for `fontRef`s that
1270     // are not actually `Ref`s, but rather `Dict`s. See explanation below.
1271     if (font.cacheKey && this.fontCache.has(font.cacheKey)) {
1272       return this.fontCache.get(font.cacheKey);
1273     }
1274 
1275     const fontCapability = new PromiseCapability();
1276 
1277     let preEvaluatedFont;
1278     try {
1279       preEvaluatedFont = this.preEvaluateFont(font);
1280       preEvaluatedFont.cssFontInfo = cssFontInfo;
1281     } catch (reason) {
1282       warn(`loadFont - preEvaluateFont failed: "${reason}".`);
1283       return errorFont();
1284     }
1285     const { descriptor, hash } = preEvaluatedFont;
1286 
1287     const fontRefIsRef = fontRef instanceof Ref;
1288     let fontID;
1289 
1290     if (hash && descriptor instanceof Dict) {
1291       const fontAliases = (descriptor.fontAliases ||= Object.create(null));
1292 
1293       if (fontAliases[hash]) {
1294         const aliasFontRef = fontAliases[hash].aliasRef;
1295         if (fontRefIsRef && aliasFontRef && this.fontCache.has(aliasFontRef)) {
1296           this.fontCache.putAlias(fontRef, aliasFontRef);
1297           return this.fontCache.get(fontRef);
1298         }
1299       } else {
1300         fontAliases[hash] = {
1301           fontID: this.idFactory.createFontId(),
1302         };
1303       }
1304 
1305       if (fontRefIsRef) {
1306         fontAliases[hash].aliasRef = fontRef;
1307       }
1308       fontID = fontAliases[hash].fontID;
1309     } else {
1310       fontID = this.idFactory.createFontId();
1311     }
1312     assert(
1313       fontID?.startsWith("f"),
1314       'The "fontID" must be (correctly) defined.'
1315     );
1316 
1317     // Workaround for bad PDF generators that reference fonts incorrectly,
1318     // where `fontRef` is a `Dict` rather than a `Ref` (fixes bug946506.pdf).
1319     // In this case we cannot put the font into `this.fontCache` (which is
1320     // a `RefSetCache`), since it's not possible to use a `Dict` as a key.
1321     //
1322     // However, if we don't cache the font it's not possible to remove it
1323     // when `cleanup` is triggered from the API, which causes issues on
1324     // subsequent rendering operations (see issue7403.pdf) and would force us
1325     // to unnecessarily load the same fonts over and over.
1326     //
1327     // Instead, we cheat a bit by using a modified `fontID` as a key in
1328     // `this.fontCache`, to allow the font to be cached.
1329     // NOTE: This works because `RefSetCache` calls `toString()` on provided
1330     //       keys. Also, since `fontRef` is used when getting cached fonts,
1331     //       we'll not accidentally match fonts cached with the `fontID`.
1332     if (fontRefIsRef) {
1333       this.fontCache.put(fontRef, fontCapability.promise);
1334     } else {
1335       font.cacheKey = `cacheKey_${fontID}`;
1336       this.fontCache.put(font.cacheKey, fontCapability.promise);
1337     }
1338 
1339     // Keep track of each font we translated so the caller can
1340     // load them asynchronously before calling display on a page.
1341     font.loadedName = `${this.idFactory.getDocId()}_${fontID}`;
1342 
1343     this.translateFont(preEvaluatedFont)
1344       .then(translatedFont => {
1345         fontCapability.resolve(
1346           new TranslatedFont({
1347             loadedName: font.loadedName,
1348             font: translatedFont,
1349             dict: font,
1350             evaluatorOptions: this.options,
1351           })
1352         );
1353       })
1354       .catch(reason => {
1355         // TODO fontCapability.reject?
1356         warn(`loadFont - translateFont failed: "${reason}".`);
1357 
1358         fontCapability.resolve(
1359           new TranslatedFont({
1360             loadedName: font.loadedName,
1361             font: new ErrorFont(
1362               reason instanceof Error ? reason.message : reason
1363             ),
1364             dict: font,
1365             evaluatorOptions: this.options,
1366           })
1367         );
1368       });
1369     return fontCapability.promise;
1370   }
1371 
1372   buildPath(operatorList, fn, args, parsingText = false) {
1373     const lastIndex = operatorList.length - 1;
1374     if (!args) {
1375       args = [];
1376     }
1377     if (
1378       lastIndex < 0 ||
1379       operatorList.fnArray[lastIndex] !== OPS.constructPath
1380     ) {
1381       // Handle corrupt PDF documents that contains path operators inside of
1382       // text objects, which may shift subsequent text, by enclosing the path
1383       // operator in save/restore operators (fixes issue10542_reduced.pdf).
1384       //
1385       // Note that this will effectively disable the optimization in the
1386       // `else` branch below, but given that this type of corruption is
1387       // *extremely* rare that shouldn't really matter much in practice.
1388       if (parsingText) {
1389         warn(`Encountered path operator "${fn}" inside of a text object.`);
1390         operatorList.addOp(OPS.save, null);
1391       }
1392 
1393       let minMax;
1394       switch (fn) {
1395         case OPS.rectangle:
1396           const x = args[0] + args[2];
1397           const y = args[1] + args[3];
1398           minMax = [
1399             Math.min(args[0], x),
1400             Math.max(args[0], x),
1401             Math.min(args[1], y),
1402             Math.max(args[1], y),
1403           ];
1404           break;
1405         case OPS.moveTo:
1406         case OPS.lineTo:
1407           minMax = [args[0], args[0], args[1], args[1]];
1408           break;
1409         default:
1410           minMax = [Infinity, -Infinity, Infinity, -Infinity];
1411           break;
1412       }
1413       operatorList.addOp(OPS.constructPath, [[fn], args, minMax]);
1414 
1415       if (parsingText) {
1416         operatorList.addOp(OPS.restore, null);
1417       }
1418     } else {
1419       const opArgs = operatorList.argsArray[lastIndex];
1420       opArgs[0].push(fn);
1421       opArgs[1].push(...args);
1422       const minMax = opArgs[2];
1423 
1424       // Compute min/max in the worker instead of the main thread.
1425       // If the current matrix (when drawing) is a scaling one
1426       // then min/max can be easily computed in using those values.
1427       // Only rectangle, lineTo and moveTo are handled here since
1428       // Bezier stuff requires to have the starting point.
1429       switch (fn) {
1430         case OPS.rectangle:
1431           const x = args[0] + args[2];
1432           const y = args[1] + args[3];
1433           minMax[0] = Math.min(minMax[0], args[0], x);
1434           minMax[1] = Math.max(minMax[1], args[0], x);
1435           minMax[2] = Math.min(minMax[2], args[1], y);
1436           minMax[3] = Math.max(minMax[3], args[1], y);
1437           break;
1438         case OPS.moveTo:
1439         case OPS.lineTo:
1440           minMax[0] = Math.min(minMax[0], args[0]);
1441           minMax[1] = Math.max(minMax[1], args[0]);
1442           minMax[2] = Math.min(minMax[2], args[1]);
1443           minMax[3] = Math.max(minMax[3], args[1]);
1444           break;
1445       }
1446     }
1447   }
1448 
1449   parseColorSpace({ cs, resources, localColorSpaceCache }) {
1450     return ColorSpace.parseAsync({
1451       cs,
1452       xref: this.xref,
1453       resources,
1454       pdfFunctionFactory: this._pdfFunctionFactory,
1455       localColorSpaceCache,
1456     }).catch(reason => {
1457       if (reason instanceof AbortException) {
1458         return null;
1459       }
1460       if (this.options.ignoreErrors) {
1461         warn(`parseColorSpace - ignoring ColorSpace: "${reason}".`);
1462         return null;
1463       }
1464       throw reason;
1465     });
1466   }
1467 
1468   parseShading({
1469     shading,
1470     resources,
1471     localColorSpaceCache,
1472     localShadingPatternCache,
1473   }) {
1474     // Shadings and patterns may be referenced by the same name but the resource
1475     // dictionary could be different so we can't use the name for the cache key.
1476     let id = localShadingPatternCache.get(shading);
1477     if (!id) {
1478       var shadingFill = Pattern.parseShading(
1479         shading,
1480         this.xref,
1481         resources,
1482         this._pdfFunctionFactory,
1483         localColorSpaceCache
1484       );
1485       const patternIR = shadingFill.getIR();
1486       id = `pattern_${this.idFactory.createObjId()}`;
1487       if (this.parsingType3Font) {
1488         id = `${this.idFactory.getDocId()}_type3_${id}`;
1489       }
1490       localShadingPatternCache.set(shading, id);
1491 
1492       if (this.parsingType3Font) {
1493         this.handler.send("commonobj", [id, "Pattern", patternIR]);
1494       } else {
1495         this.handler.send("obj", [id, this.pageIndex, "Pattern", patternIR]);
1496       }
1497     }
1498     return id;
1499   }
1500 
1501   handleColorN(
1502     operatorList,
1503     fn,
1504     args,
1505     cs,
1506     patterns,
1507     resources,
1508     task,
1509     localColorSpaceCache,
1510     localTilingPatternCache,
1511     localShadingPatternCache
1512   ) {
1513     // compile tiling patterns
1514     const patternName = args.pop();
1515     // SCN/scn applies patterns along with normal colors
1516     if (patternName instanceof Name) {
1517       const rawPattern = patterns.getRaw(patternName.name);
1518 
1519       const localTilingPattern =
1520         rawPattern instanceof Ref &&
1521         localTilingPatternCache.getByRef(rawPattern);
1522       if (localTilingPattern) {
1523         try {
1524           const color = cs.base ? cs.base.getRgb(args, 0) : null;
1525           const tilingPatternIR = getTilingPatternIR(
1526             localTilingPattern.operatorListIR,
1527             localTilingPattern.dict,
1528             color
1529           );
1530           operatorList.addOp(fn, tilingPatternIR);
1531           return undefined;
1532         } catch {
1533           // Handle any errors during normal TilingPattern parsing.
1534         }
1535       }
1536 
1537       const pattern = this.xref.fetchIfRef(rawPattern);
1538       if (pattern) {
1539         const dict = pattern instanceof BaseStream ? pattern.dict : pattern;
1540         const typeNum = dict.get("PatternType");
1541 
1542         if (typeNum === PatternType.TILING) {
1543           const color = cs.base ? cs.base.getRgb(args, 0) : null;
1544           return this.handleTilingType(
1545             fn,
1546             color,
1547             resources,
1548             pattern,
1549             dict,
1550             operatorList,
1551             task,
1552             localTilingPatternCache
1553           );
1554         } else if (typeNum === PatternType.SHADING) {
1555           const shading = dict.get("Shading");
1556           const matrix = dict.getArray("Matrix");
1557           const objId = this.parseShading({
1558             shading,
1559             resources,
1560             localColorSpaceCache,
1561             localShadingPatternCache,
1562           });
1563           operatorList.addOp(fn, ["Shading", objId, matrix]);
1564           return undefined;
1565         }
1566         throw new FormatError(`Unknown PatternType: ${typeNum}`);
1567       }
1568     }
1569     throw new FormatError(`Unknown PatternName: ${patternName}`);
1570   }
1571 
1572   _parseVisibilityExpression(array, nestingCounter, currentResult) {
1573     const MAX_NESTING = 10;
1574     if (++nestingCounter > MAX_NESTING) {
1575       warn("Visibility expression is too deeply nested");
1576       return;
1577     }
1578     const length = array.length;
1579     const operator = this.xref.fetchIfRef(array[0]);
1580     if (length < 2 || !(operator instanceof Name)) {
1581       warn("Invalid visibility expression");
1582       return;
1583     }
1584     switch (operator.name) {
1585       case "And":
1586       case "Or":
1587       case "Not":
1588         currentResult.push(operator.name);
1589         break;
1590       default:
1591         warn(`Invalid operator ${operator.name} in visibility expression`);
1592         return;
1593     }
1594     for (let i = 1; i < length; i++) {
1595       const raw = array[i];
1596       const object = this.xref.fetchIfRef(raw);
1597       if (Array.isArray(object)) {
1598         const nestedResult = [];
1599         currentResult.push(nestedResult);
1600         // Recursively parse a subarray.
1601         this._parseVisibilityExpression(object, nestingCounter, nestedResult);
1602       } else if (raw instanceof Ref) {
1603         // Reference to an OCG dictionary.
1604         currentResult.push(raw.toString());
1605       }
1606     }
1607   }
1608 
1609   async parseMarkedContentProps(contentProperties, resources) {
1610     let optionalContent;
1611     if (contentProperties instanceof Name) {
1612       const properties = resources.get("Properties");
1613       optionalContent = properties.get(contentProperties.name);
1614     } else if (contentProperties instanceof Dict) {
1615       optionalContent = contentProperties;
1616     } else {
1617       throw new FormatError("Optional content properties malformed.");
1618     }
1619 
1620     const optionalContentType = optionalContent.get("Type")?.name;
1621     if (optionalContentType === "OCG") {
1622       return {
1623         type: optionalContentType,
1624         id: optionalContent.objId,
1625       };
1626     } else if (optionalContentType === "OCMD") {
1627       const expression = optionalContent.get("VE");
1628       if (Array.isArray(expression)) {
1629         const result = [];
1630         this._parseVisibilityExpression(expression, 0, result);
1631         if (result.length > 0) {
1632           return {
1633             type: "OCMD",
1634             expression: result,
1635           };
1636         }
1637       }
1638 
1639       const optionalContentGroups = optionalContent.get("OCGs");
1640       if (
1641         Array.isArray(optionalContentGroups) ||
1642         optionalContentGroups instanceof Dict
1643       ) {
1644         const groupIds = [];
1645         if (Array.isArray(optionalContentGroups)) {
1646           for (const ocg of optionalContentGroups) {
1647             groupIds.push(ocg.toString());
1648           }
1649         } else {
1650           // Dictionary, just use the obj id.
1651           groupIds.push(optionalContentGroups.objId);
1652         }
1653 
1654         return {
1655           type: optionalContentType,
1656           ids: groupIds,
1657           policy:
1658             optionalContent.get("P") instanceof Name
1659               ? optionalContent.get("P").name
1660               : null,
1661           expression: null,
1662         };
1663       } else if (optionalContentGroups instanceof Ref) {
1664         return {
1665           type: optionalContentType,
1666           id: optionalContentGroups.toString(),
1667         };
1668       }
1669     }
1670     return null;
1671   }
1672 
1673   getOperatorList({
1674     stream,
1675     task,
1676     resources,
1677     operatorList,
1678     initialState = null,
1679     fallbackFontDict = null,
1680   }) {
1681     // Ensure that `resources`/`initialState` is correctly initialized,
1682     // even if the provided parameter is e.g. `null`.
1683     resources ||= Dict.empty;
1684     initialState ||= new EvalState();
1685 
1686     if (!operatorList) {
1687       throw new Error('getOperatorList: missing "operatorList" parameter');
1688     }
1689 
1690     const self = this;
1691     const xref = this.xref;
1692     let parsingText = false;
1693     const localImageCache = new LocalImageCache();
1694     const localColorSpaceCache = new LocalColorSpaceCache();
1695     const localGStateCache = new LocalGStateCache();
1696     const localTilingPatternCache = new LocalTilingPatternCache();
1697     const localShadingPatternCache = new Map();
1698 
1699     const xobjs = resources.get("XObject") || Dict.empty;
1700     const patterns = resources.get("Pattern") || Dict.empty;
1701     const stateManager = new StateManager(initialState);
1702     const preprocessor = new EvaluatorPreprocessor(stream, xref, stateManager);
1703     const timeSlotManager = new TimeSlotManager();
1704 
1705     function closePendingRestoreOPS(argument) {
1706       for (let i = 0, ii = preprocessor.savedStatesDepth; i < ii; i++) {
1707         operatorList.addOp(OPS.restore, []);
1708       }
1709     }
1710 
1711     return new Promise(function promiseBody(resolve, reject) {
1712       const next = function (promise) {
1713         Promise.all([promise, operatorList.ready]).then(function () {
1714           try {
1715             promiseBody(resolve, reject);
1716           } catch (ex) {
1717             reject(ex);
1718           }
1719         }, reject);
1720       };
1721       task.ensureNotTerminated();
1722       timeSlotManager.reset();
1723 
1724       const operation = {};
1725       let stop, i, ii, cs, name, isValidName;
1726       while (!(stop = timeSlotManager.check())) {
1727         // The arguments parsed by read() are used beyond this loop, so we
1728         // cannot reuse the same array on each iteration. Therefore we pass
1729         // in |null| as the initial value (see the comment on
1730         // EvaluatorPreprocessor_read() for why).
1731         operation.args = null;
1732         if (!preprocessor.read(operation)) {
1733           break;
1734         }
1735         let args = operation.args;
1736         let fn = operation.fn;
1737 
1738         switch (fn | 0) {
1739           case OPS.paintXObject:
1740             // eagerly compile XForm objects
1741             isValidName = args[0] instanceof Name;
1742             name = args[0].name;
1743 
1744             if (isValidName) {
1745               const localImage = localImageCache.getByName(name);
1746               if (localImage) {
1747                 operatorList.addImageOps(
1748                   localImage.fn,
1749                   localImage.args,
1750                   localImage.optionalContent
1751                 );
1752 
1753                 incrementCachedImageMaskCount(localImage);
1754                 args = null;
1755                 continue;
1756               }
1757             }
1758 
1759             next(
1760               new Promise(function (resolveXObject, rejectXObject) {
1761                 if (!isValidName) {
1762                   throw new FormatError("XObject must be referred to by name.");
1763                 }
1764 
1765                 let xobj = xobjs.getRaw(name);
1766                 if (xobj instanceof Ref) {
1767                   const localImage =
1768                     localImageCache.getByRef(xobj) ||
1769                     self._regionalImageCache.getByRef(xobj);
1770                   if (localImage) {
1771                     operatorList.addImageOps(
1772                       localImage.fn,
1773                       localImage.args,
1774                       localImage.optionalContent
1775                     );
1776 
1777                     incrementCachedImageMaskCount(localImage);
1778                     resolveXObject();
1779                     return;
1780                   }
1781 
1782                   const globalImage = self.globalImageCache.getData(
1783                     xobj,
1784                     self.pageIndex
1785                   );
1786                   if (globalImage) {
1787                     operatorList.addDependency(globalImage.objId);
1788                     operatorList.addImageOps(
1789                       globalImage.fn,
1790                       globalImage.args,
1791                       globalImage.optionalContent
1792                     );
1793 
1794                     resolveXObject();
1795                     return;
1796                   }
1797 
1798                   xobj = xref.fetch(xobj);
1799                 }
1800 
1801                 if (!(xobj instanceof BaseStream)) {
1802                   throw new FormatError("XObject should be a stream");
1803                 }
1804 
1805                 const type = xobj.dict.get("Subtype");
1806                 if (!(type instanceof Name)) {
1807                   throw new FormatError("XObject should have a Name subtype");
1808                 }
1809 
1810                 if (type.name === "Form") {
1811                   stateManager.save();
1812                   self
1813                     .buildFormXObject(
1814                       resources,
1815                       xobj,
1816                       null,
1817                       operatorList,
1818                       task,
1819                       stateManager.state.clone(),
1820                       localColorSpaceCache
1821                     )
1822                     .then(function () {
1823                       stateManager.restore();
1824                       resolveXObject();
1825                     }, rejectXObject);
1826                   return;
1827                 } else if (type.name === "Image") {
1828                   self
1829                     .buildPaintImageXObject({
1830                       resources,
1831                       image: xobj,
1832                       operatorList,
1833                       cacheKey: name,
1834                       localImageCache,
1835                       localColorSpaceCache,
1836                     })
1837                     .then(resolveXObject, rejectXObject);
1838                   return;
1839                 } else if (type.name === "PS") {
1840                   // PostScript XObjects are unused when viewing documents.
1841                   // See section 4.7.1 of Adobe's PDF reference.
1842                   info("Ignored XObject subtype PS");
1843                 } else {
1844                   throw new FormatError(
1845                     `Unhandled XObject subtype ${type.name}`
1846                   );
1847                 }
1848                 resolveXObject();
1849               }).catch(function (reason) {
1850                 if (reason instanceof AbortException) {
1851                   return;
1852                 }
1853                 if (self.options.ignoreErrors) {
1854                   warn(`getOperatorList - ignoring XObject: "${reason}".`);
1855                   return;
1856                 }
1857                 throw reason;
1858               })
1859             );
1860             return;
1861           case OPS.setFont:
1862             var fontSize = args[1];
1863             // eagerly collect all fonts
1864             next(
1865               self
1866                 .handleSetFont(
1867                   resources,
1868                   args,
1869                   null,
1870                   operatorList,
1871                   task,
1872                   stateManager.state,
1873                   fallbackFontDict
1874                 )
1875                 .then(function (loadedName) {
1876                   operatorList.addDependency(loadedName);
1877                   operatorList.addOp(OPS.setFont, [loadedName, fontSize]);
1878                 })
1879             );
1880             return;
1881           case OPS.beginText:
1882             parsingText = true;
1883             break;
1884           case OPS.endText:
1885             parsingText = false;
1886             break;
1887           case OPS.endInlineImage:
1888             var cacheKey = args[0].cacheKey;
1889             if (cacheKey) {
1890               const localImage = localImageCache.getByName(cacheKey);
1891               if (localImage) {
1892                 operatorList.addImageOps(
1893                   localImage.fn,
1894                   localImage.args,
1895                   localImage.optionalContent
1896                 );
1897 
1898                 incrementCachedImageMaskCount(localImage);
1899                 args = null;
1900                 continue;
1901               }
1902             }
1903             next(
1904               self.buildPaintImageXObject({
1905                 resources,
1906                 image: args[0],
1907                 isInline: true,
1908                 operatorList,
1909                 cacheKey,
1910                 localImageCache,
1911                 localColorSpaceCache,
1912               })
1913             );
1914             return;
1915           case OPS.showText:
1916             if (!stateManager.state.font) {
1917               self.ensureStateFont(stateManager.state);
1918               continue;
1919             }
1920             args[0] = self.handleText(args[0], stateManager.state);
1921             break;
1922           case OPS.showSpacedText:
1923             if (!stateManager.state.font) {
1924               self.ensureStateFont(stateManager.state);
1925               continue;
1926             }
1927             var combinedGlyphs = [];
1928             var state = stateManager.state;
1929             for (const arrItem of args[0]) {
1930               if (typeof arrItem === "string") {
1931                 combinedGlyphs.push(...self.handleText(arrItem, state));
1932               } else if (typeof arrItem === "number") {
1933                 combinedGlyphs.push(arrItem);
1934               }
1935             }
1936             args[0] = combinedGlyphs;
1937             fn = OPS.showText;
1938             break;
1939           case OPS.nextLineShowText:
1940             if (!stateManager.state.font) {
1941               self.ensureStateFont(stateManager.state);
1942               continue;
1943             }
1944             operatorList.addOp(OPS.nextLine);
1945             args[0] = self.handleText(args[0], stateManager.state);
1946             fn = OPS.showText;
1947             break;
1948           case OPS.nextLineSetSpacingShowText:
1949             if (!stateManager.state.font) {
1950               self.ensureStateFont(stateManager.state);
1951               continue;
1952             }
1953             operatorList.addOp(OPS.nextLine);
1954             operatorList.addOp(OPS.setWordSpacing, [args.shift()]);
1955             operatorList.addOp(OPS.setCharSpacing, [args.shift()]);
1956             args[0] = self.handleText(args[0], stateManager.state);
1957             fn = OPS.showText;
1958             break;
1959           case OPS.setTextRenderingMode:
1960             stateManager.state.textRenderingMode = args[0];
1961             break;
1962 
1963           case OPS.setFillColorSpace: {
1964             const cachedColorSpace = ColorSpace.getCached(
1965               args[0],
1966               xref,
1967               localColorSpaceCache
1968             );
1969             if (cachedColorSpace) {
1970               stateManager.state.fillColorSpace = cachedColorSpace;
1971               continue;
1972             }
1973 
1974             next(
1975               self
1976                 .parseColorSpace({
1977                   cs: args[0],
1978                   resources,
1979                   localColorSpaceCache,
1980                 })
1981                 .then(function (colorSpace) {
1982                   if (colorSpace) {
1983                     stateManager.state.fillColorSpace = colorSpace;
1984                   }
1985                 })
1986             );
1987             return;
1988           }
1989           case OPS.setStrokeColorSpace: {
1990             const cachedColorSpace = ColorSpace.getCached(
1991               args[0],
1992               xref,
1993               localColorSpaceCache
1994             );
1995             if (cachedColorSpace) {
1996               stateManager.state.strokeColorSpace = cachedColorSpace;
1997               continue;
1998             }
1999 
2000             next(
2001               self
2002                 .parseColorSpace({
2003                   cs: args[0],
2004                   resources,
2005                   localColorSpaceCache,
2006                 })
2007                 .then(function (colorSpace) {
2008                   if (colorSpace) {
2009                     stateManager.state.strokeColorSpace = colorSpace;
2010                   }
2011                 })
2012             );
2013             return;
2014           }
2015           case OPS.setFillColor:
2016             cs = stateManager.state.fillColorSpace;
2017             args = cs.getRgb(args, 0);
2018             fn = OPS.setFillRGBColor;
2019             break;
2020           case OPS.setStrokeColor:
2021             cs = stateManager.state.strokeColorSpace;
2022             args = cs.getRgb(args, 0);
2023             fn = OPS.setStrokeRGBColor;
2024             break;
2025           case OPS.setFillGray:
2026             stateManager.state.fillColorSpace = ColorSpace.singletons.gray;
2027             args = ColorSpace.singletons.gray.getRgb(args, 0);
2028             fn = OPS.setFillRGBColor;
2029             break;
2030           case OPS.setStrokeGray:
2031             stateManager.state.strokeColorSpace = ColorSpace.singletons.gray;
2032             args = ColorSpace.singletons.gray.getRgb(args, 0);
2033             fn = OPS.setStrokeRGBColor;
2034             break;
2035           case OPS.setFillCMYKColor:
2036             stateManager.state.fillColorSpace = ColorSpace.singletons.cmyk;
2037             args = ColorSpace.singletons.cmyk.getRgb(args, 0);
2038             fn = OPS.setFillRGBColor;
2039             break;
2040           case OPS.setStrokeCMYKColor:
2041             stateManager.state.strokeColorSpace = ColorSpace.singletons.cmyk;
2042             args = ColorSpace.singletons.cmyk.getRgb(args, 0);
2043             fn = OPS.setStrokeRGBColor;
2044             break;
2045           case OPS.setFillRGBColor:
2046             stateManager.state.fillColorSpace = ColorSpace.singletons.rgb;
2047             args = ColorSpace.singletons.rgb.getRgb(args, 0);
2048             break;
2049           case OPS.setStrokeRGBColor:
2050             stateManager.state.strokeColorSpace = ColorSpace.singletons.rgb;
2051             args = ColorSpace.singletons.rgb.getRgb(args, 0);
2052             break;
2053           case OPS.setFillColorN:
2054             cs = stateManager.state.fillColorSpace;
2055             if (cs.name === "Pattern") {
2056               next(
2057                 self.handleColorN(
2058                   operatorList,
2059                   OPS.setFillColorN,
2060                   args,
2061                   cs,
2062                   patterns,
2063                   resources,
2064                   task,
2065                   localColorSpaceCache,
2066                   localTilingPatternCache,
2067                   localShadingPatternCache
2068                 )
2069               );
2070               return;
2071             }
2072             args = cs.getRgb(args, 0);
2073             fn = OPS.setFillRGBColor;
2074             break;
2075           case OPS.setStrokeColorN:
2076             cs = stateManager.state.strokeColorSpace;
2077             if (cs.name === "Pattern") {
2078               next(
2079                 self.handleColorN(
2080                   operatorList,
2081                   OPS.setStrokeColorN,
2082                   args,
2083                   cs,
2084                   patterns,
2085                   resources,
2086                   task,
2087                   localColorSpaceCache,
2088                   localTilingPatternCache,
2089                   localShadingPatternCache
2090                 )
2091               );
2092               return;
2093             }
2094             args = cs.getRgb(args, 0);
2095             fn = OPS.setStrokeRGBColor;
2096             break;
2097 
2098           case OPS.shadingFill:
2099             var shadingRes = resources.get("Shading");
2100             if (!shadingRes) {
2101               throw new FormatError("No shading resource found");
2102             }
2103 
2104             var shading = shadingRes.get(args[0].name);
2105             if (!shading) {
2106               throw new FormatError("No shading object found");
2107             }
2108             const patternId = self.parseShading({
2109               shading,
2110               resources,
2111               localColorSpaceCache,
2112               localShadingPatternCache,
2113             });
2114             args = [patternId];
2115             fn = OPS.shadingFill;
2116             break;
2117           case OPS.setGState:
2118             isValidName = args[0] instanceof Name;
2119             name = args[0].name;
2120 
2121             if (isValidName) {
2122               const localGStateObj = localGStateCache.getByName(name);
2123               if (localGStateObj) {
2124                 if (localGStateObj.length > 0) {
2125                   operatorList.addOp(OPS.setGState, [localGStateObj]);
2126                 }
2127                 args = null;
2128                 continue;
2129               }
2130             }
2131 
2132             next(
2133               new Promise(function (resolveGState, rejectGState) {
2134                 if (!isValidName) {
2135                   throw new FormatError("GState must be referred to by name.");
2136                 }
2137 
2138                 const extGState = resources.get("ExtGState");
2139                 if (!(extGState instanceof Dict)) {
2140                   throw new FormatError("ExtGState should be a dictionary.");
2141                 }
2142 
2143                 const gState = extGState.get(name);
2144                 // TODO: Attempt to lookup cached GStates by reference as well,
2145                 //       if and only if there are PDF documents where doing so
2146                 //       would significantly improve performance.
2147                 if (!(gState instanceof Dict)) {
2148                   throw new FormatError("GState should be a dictionary.");
2149                 }
2150 
2151                 self
2152                   .setGState({
2153                     resources,
2154                     gState,
2155                     operatorList,
2156                     cacheKey: name,
2157                     task,
2158                     stateManager,
2159                     localGStateCache,
2160                     localColorSpaceCache,
2161                   })
2162                   .then(resolveGState, rejectGState);
2163               }).catch(function (reason) {
2164                 if (reason instanceof AbortException) {
2165                   return;
2166                 }
2167                 if (self.options.ignoreErrors) {
2168                   warn(`getOperatorList - ignoring ExtGState: "${reason}".`);
2169                   return;
2170                 }
2171                 throw reason;
2172               })
2173             );
2174             return;
2175           case OPS.moveTo:
2176           case OPS.lineTo:
2177           case OPS.curveTo:
2178           case OPS.curveTo2:
2179           case OPS.curveTo3:
2180           case OPS.closePath:
2181           case OPS.rectangle:
2182             self.buildPath(operatorList, fn, args, parsingText);
2183             continue;
2184           case OPS.markPoint:
2185           case OPS.markPointProps:
2186           case OPS.beginCompat:
2187           case OPS.endCompat:
2188             // Ignore operators where the corresponding handlers are known to
2189             // be no-op in CanvasGraphics (display/canvas.js). This prevents
2190             // serialization errors and is also a bit more efficient.
2191             // We could also try to serialize all objects in a general way,
2192             // e.g. as done in https://github.com/mozilla/pdf.js/pull/6266,
2193             // but doing so is meaningless without knowing the semantics.
2194             continue;
2195           case OPS.beginMarkedContentProps:
2196             if (!(args[0] instanceof Name)) {
2197               warn(`Expected name for beginMarkedContentProps arg0=${args[0]}`);
2198               continue;
2199             }
2200             if (args[0].name === "OC") {
2201               next(
2202                 self
2203                   .parseMarkedContentProps(args[1], resources)
2204                   .then(data => {
2205                     operatorList.addOp(OPS.beginMarkedContentProps, [
2206                       "OC",
2207                       data,
2208                     ]);
2209                   })
2210                   .catch(reason => {
2211                     if (reason instanceof AbortException) {
2212                       return;
2213                     }
2214                     if (self.options.ignoreErrors) {
2215                       warn(
2216                         `getOperatorList - ignoring beginMarkedContentProps: "${reason}".`
2217                       );
2218                       return;
2219                     }
2220                     throw reason;
2221                   })
2222               );
2223               return;
2224             }
2225             // Other marked content types aren't supported yet.
2226             args = [
2227               args[0].name,
2228               args[1] instanceof Dict ? args[1].get("MCID") : null,
2229             ];
2230 
2231             break;
2232           case OPS.beginMarkedContent:
2233           case OPS.endMarkedContent:
2234           default:
2235             // Note: Ignore the operator if it has `Dict` arguments, since
2236             // those are non-serializable, otherwise postMessage will throw
2237             // "An object could not be cloned.".
2238             if (args !== null) {
2239               for (i = 0, ii = args.length; i < ii; i++) {
2240                 if (args[i] instanceof Dict) {
2241                   break;
2242                 }
2243               }
2244               if (i < ii) {
2245                 warn("getOperatorList - ignoring operator: " + fn);
2246                 continue;
2247               }
2248             }
2249         }
2250         operatorList.addOp(fn, args);
2251       }
2252       if (stop) {
2253         next(deferred);
2254         return;
2255       }
2256       // Some PDFs don't close all restores inside object/form.
2257       // Closing those for them.
2258       closePendingRestoreOPS();
2259       resolve();
2260     }).catch(reason => {
2261       if (reason instanceof AbortException) {
2262         return;
2263       }
2264       if (this.options.ignoreErrors) {
2265         warn(
2266           `getOperatorList - ignoring errors during "${task.name}" ` +
2267             `task: "${reason}".`
2268         );
2269 
2270         closePendingRestoreOPS();
2271         return;
2272       }
2273       throw reason;
2274     });
2275   }
2276 
2277   getTextContent({
2278     stream,
2279     task,
2280     resources,
2281     stateManager = null,
2282     includeMarkedContent = false,
2283     sink,
2284     seenStyles = new Set(),
2285     viewBox,
2286     markedContentData = null,
2287     disableNormalization = false,
2288     keepWhiteSpace = false,
2289   }) {
2290     // Ensure that `resources`/`stateManager` is correctly initialized,
2291     // even if the provided parameter is e.g. `null`.
2292     resources ||= Dict.empty;
2293     stateManager ||= new StateManager(new TextState());
2294 
2295     if (includeMarkedContent) {
2296       markedContentData ||= { level: 0 };
2297     }
2298 
2299     const textContent = {
2300       items: [],
2301       styles: Object.create(null),
2302     };
2303     const textContentItem = {
2304       initialized: false,
2305       str: [],
2306       totalWidth: 0,
2307       totalHeight: 0,
2308       width: 0,
2309       height: 0,
2310       vertical: false,
2311       prevTransform: null,
2312       textAdvanceScale: 0,
2313       spaceInFlowMin: 0,
2314       spaceInFlowMax: 0,
2315       trackingSpaceMin: Infinity,
2316       negativeSpaceMax: -Infinity,
2317       notASpace: -Infinity,
2318       transform: null,
2319       fontName: null,
2320       hasEOL: false,
2321     };
2322 
2323     // Use a circular buffer (length === 2) to save the last chars in the
2324     // text stream.
2325     // This implementation of the circular buffer is using a fixed array
2326     // and the position of the next element:
2327     // function addElement(x) {
2328     //   buffer[pos] = x;
2329     //   pos = (pos + 1) % buffer.length;
2330     // }
2331     // It's a way faster than:
2332     // function addElement(x) {
2333     //   buffer.push(x);
2334     //   buffer.shift();
2335     // }
2336     //
2337     // It's useful to know when we need to add a whitespace in the
2338     // text chunk.
2339     const twoLastChars = [" ", " "];
2340     let twoLastCharsPos = 0;
2341 
2342     /**
2343      * Save the last char.
2344      * @param {string} char
2345      * @returns {boolean} true when the two last chars before adding the new one
2346      * are a non-whitespace followed by a whitespace.
2347      */
2348     function saveLastChar(char) {
2349       const nextPos = (twoLastCharsPos + 1) % 2;
2350       const ret =
2351         twoLastChars[twoLastCharsPos] !== " " && twoLastChars[nextPos] === " ";
2352       twoLastChars[twoLastCharsPos] = char;
2353       twoLastCharsPos = nextPos;
2354 
2355       return !keepWhiteSpace && ret;
2356     }
2357 
2358     function shouldAddWhitepsace() {
2359       return (
2360         !keepWhiteSpace &&
2361         twoLastChars[twoLastCharsPos] !== " " &&
2362         twoLastChars[(twoLastCharsPos + 1) % 2] === " "
2363       );
2364     }
2365 
2366     function resetLastChars() {
2367       twoLastChars[0] = twoLastChars[1] = " ";
2368       twoLastCharsPos = 0;
2369     }
2370 
2371     // Used in addFakeSpaces.
2372 
2373     // A white <= fontSize * TRACKING_SPACE_FACTOR is a tracking space
2374     // so it doesn't count as a space.
2375     const TRACKING_SPACE_FACTOR = 0.102;
2376 
2377     // When a white <= fontSize * NOT_A_SPACE_FACTOR, there is no space
2378     // even if one is present in the text stream.
2379     const NOT_A_SPACE_FACTOR = 0.03;
2380 
2381     // A negative white < fontSize * NEGATIVE_SPACE_FACTOR induces
2382     // a break (a new chunk of text is created).
2383     // It doesn't change anything when the text is copied but
2384     // it improves potential mismatch between text layer and canvas.
2385     const NEGATIVE_SPACE_FACTOR = -0.2;
2386 
2387     // A white with a width in [fontSize * MIN_FACTOR; fontSize * MAX_FACTOR]
2388     // is a space which will be inserted in the current flow of words.
2389     // If the width is outside of this range then the flow is broken
2390     // (which means a new span in the text layer).
2391     // It's useful to adjust the best as possible the span in the layer
2392     // to what is displayed in the canvas.
2393     const SPACE_IN_FLOW_MIN_FACTOR = 0.102;
2394     const SPACE_IN_FLOW_MAX_FACTOR = 0.6;
2395 
2396     // If a char is too high/too low compared to the previous we just create
2397     // a new chunk.
2398     // If the advance isn't in the +/-VERTICAL_SHIFT_RATIO * height range then
2399     // a new chunk is created.
2400     const VERTICAL_SHIFT_RATIO = 0.25;
2401 
2402     const self = this;
2403     const xref = this.xref;
2404     const showSpacedTextBuffer = [];
2405 
2406     // The xobj is parsed iff it's needed, e.g. if there is a `DO` cmd.
2407     let xobjs = null;
2408     const emptyXObjectCache = new LocalImageCache();
2409     const emptyGStateCache = new LocalGStateCache();
2410 
2411     const preprocessor = new EvaluatorPreprocessor(stream, xref, stateManager);
2412 
2413     let textState;
2414 
2415     function pushWhitespace({
2416       width = 0,
2417       height = 0,
2418       transform = textContentItem.prevTransform,
2419       fontName = textContentItem.fontName,
2420     }) {
2421       textContent.items.push({
2422         str: " ",
2423         dir: "ltr",
2424         width,
2425         height,
2426         transform,
2427         fontName,
2428         hasEOL: false,
2429       });
2430     }
2431 
2432     function getCurrentTextTransform() {
2433       // 9.4.4 Text Space Details
2434       const font = textState.font;
2435       const tsm = [
2436         textState.fontSize * textState.textHScale,
2437         0,
2438         0,
2439         textState.fontSize,
2440         0,
2441         textState.textRise,
2442       ];
2443 
2444       if (
2445         font.isType3Font &&
2446         (textState.fontSize <= 1 || font.isCharBBox) &&
2447         !isArrayEqual(textState.fontMatrix, FONT_IDENTITY_MATRIX)
2448       ) {
2449         const glyphHeight = font.bbox[3] - font.bbox[1];
2450         if (glyphHeight > 0) {
2451           tsm[3] *= glyphHeight * textState.fontMatrix[3];
2452         }
2453       }
2454 
2455       return Util.transform(
2456         textState.ctm,
2457         Util.transform(textState.textMatrix, tsm)
2458       );
2459     }
2460 
2461     function ensureTextContentItem() {
2462       if (textContentItem.initialized) {
2463         return textContentItem;
2464       }
2465       const { font, loadedName } = textState;
2466       if (!seenStyles.has(loadedName)) {
2467         seenStyles.add(loadedName);
2468         textContent.styles[loadedName] = {
2469           fontFamily: font.fallbackName,
2470           ascent: font.ascent,
2471           descent: font.descent,
2472           vertical: font.vertical,
2473         };
2474         if (self.options.fontExtraProperties && font.systemFontInfo) {
2475           const style = textContent.styles[loadedName];
2476           style.fontSubstitution = font.systemFontInfo.css;
2477           style.fontSubstitutionLoadedName = font.systemFontInfo.loadedName;
2478         }
2479       }
2480       textContentItem.fontName = loadedName;
2481 
2482       const trm = (textContentItem.transform = getCurrentTextTransform());
2483       if (!font.vertical) {
2484         textContentItem.width = textContentItem.totalWidth = 0;
2485         textContentItem.height = textContentItem.totalHeight = Math.hypot(
2486           trm[2],
2487           trm[3]
2488         );
2489         textContentItem.vertical = false;
2490       } else {
2491         textContentItem.width = textContentItem.totalWidth = Math.hypot(
2492           trm[0],
2493           trm[1]
2494         );
2495         textContentItem.height = textContentItem.totalHeight = 0;
2496         textContentItem.vertical = true;
2497       }
2498 
2499       const scaleLineX = Math.hypot(
2500         textState.textLineMatrix[0],
2501         textState.textLineMatrix[1]
2502       );
2503       const scaleCtmX = Math.hypot(textState.ctm[0], textState.ctm[1]);
2504       textContentItem.textAdvanceScale = scaleCtmX * scaleLineX;
2505 
2506       const { fontSize } = textState;
2507       textContentItem.trackingSpaceMin = fontSize * TRACKING_SPACE_FACTOR;
2508       textContentItem.notASpace = fontSize * NOT_A_SPACE_FACTOR;
2509       textContentItem.negativeSpaceMax = fontSize * NEGATIVE_SPACE_FACTOR;
2510       textContentItem.spaceInFlowMin = fontSize * SPACE_IN_FLOW_MIN_FACTOR;
2511       textContentItem.spaceInFlowMax = fontSize * SPACE_IN_FLOW_MAX_FACTOR;
2512       textContentItem.hasEOL = false;
2513 
2514       textContentItem.initialized = true;
2515       return textContentItem;
2516     }
2517 
2518     function updateAdvanceScale() {
2519       if (!textContentItem.initialized) {
2520         return;
2521       }
2522 
2523       const scaleLineX = Math.hypot(
2524         textState.textLineMatrix[0],
2525         textState.textLineMatrix[1]
2526       );
2527       const scaleCtmX = Math.hypot(textState.ctm[0], textState.ctm[1]);
2528       const scaleFactor = scaleCtmX * scaleLineX;
2529       if (scaleFactor === textContentItem.textAdvanceScale) {
2530         return;
2531       }
2532 
2533       if (!textContentItem.vertical) {
2534         textContentItem.totalWidth +=
2535           textContentItem.width * textContentItem.textAdvanceScale;
2536         textContentItem.width = 0;
2537       } else {
2538         textContentItem.totalHeight +=
2539           textContentItem.height * textContentItem.textAdvanceScale;
2540         textContentItem.height = 0;
2541       }
2542 
2543       textContentItem.textAdvanceScale = scaleFactor;
2544     }
2545 
2546     function runBidiTransform(textChunk) {
2547       let text = textChunk.str.join("");
2548       if (!disableNormalization) {
2549         text = normalizeUnicode(text);
2550       }
2551       const bidiResult = bidi(text, -1, textChunk.vertical);
2552       return {
2553         str: bidiResult.str,
2554         dir: bidiResult.dir,
2555         width: Math.abs(textChunk.totalWidth),
2556         height: Math.abs(textChunk.totalHeight),
2557         transform: textChunk.transform,
2558         fontName: textChunk.fontName,
2559         hasEOL: textChunk.hasEOL,
2560       };
2561     }
2562 
2563     function handleSetFont(fontName, fontRef) {
2564       return self
2565         .loadFont(fontName, fontRef, resources)
2566         .then(function (translated) {
2567           if (!translated.font.isType3Font) {
2568             return translated;
2569           }
2570           return translated
2571             .loadType3Data(self, resources, task)
2572             .catch(function () {
2573               // Ignore Type3-parsing errors, since we only use `loadType3Data`
2574               // here to ensure that we'll always obtain a useful /FontBBox.
2575             })
2576             .then(function () {
2577               return translated;
2578             });
2579         })
2580         .then(function (translated) {
2581           textState.loadedName = translated.loadedName;
2582           textState.font = translated.font;
2583           textState.fontMatrix =
2584             translated.font.fontMatrix || FONT_IDENTITY_MATRIX;
2585         });
2586     }
2587 
2588     function applyInverseRotation(x, y, matrix) {
2589       const scale = Math.hypot(matrix[0], matrix[1]);
2590       return [
2591         (matrix[0] * x + matrix[1] * y) / scale,
2592         (matrix[2] * x + matrix[3] * y) / scale,
2593       ];
2594     }
2595 
2596     function compareWithLastPosition(glyphWidth) {
2597       const currentTransform = getCurrentTextTransform();
2598       let posX = currentTransform[4];
2599       let posY = currentTransform[5];
2600 
2601       // Check if the glyph is in the viewbox.
2602       if (textState.font?.vertical) {
2603         if (
2604           posX < viewBox[0] ||
2605           posX > viewBox[2] ||
2606           posY + glyphWidth < viewBox[1] ||
2607           posY > viewBox[3]
2608         ) {
2609           return false;
2610         }
2611       } else if (
2612         posX + glyphWidth < viewBox[0] ||
2613         posX > viewBox[2] ||
2614         posY < viewBox[1] ||
2615         posY > viewBox[3]
2616       ) {
2617         return false;
2618       }
2619 
2620       if (!textState.font || !textContentItem.prevTransform) {
2621         return true;
2622       }
2623 
2624       let lastPosX = textContentItem.prevTransform[4];
2625       let lastPosY = textContentItem.prevTransform[5];
2626 
2627       if (lastPosX === posX && lastPosY === posY) {
2628         return true;
2629       }
2630 
2631       let rotate = -1;
2632       // Take into account the rotation is the current transform.
2633       if (
2634         currentTransform[0] &&
2635         currentTransform[1] === 0 &&
2636         currentTransform[2] === 0
2637       ) {
2638         rotate = currentTransform[0] > 0 ? 0 : 180;
2639       } else if (
2640         currentTransform[1] &&
2641         currentTransform[0] === 0 &&
2642         currentTransform[3] === 0
2643       ) {
2644         rotate = currentTransform[1] > 0 ? 90 : 270;
2645       }
2646 
2647       switch (rotate) {
2648         case 0:
2649           break;
2650         case 90:
2651           [posX, posY] = [posY, posX];
2652           [lastPosX, lastPosY] = [lastPosY, lastPosX];
2653           break;
2654         case 180:
2655           [posX, posY, lastPosX, lastPosY] = [
2656             -posX,
2657             -posY,
2658             -lastPosX,
2659             -lastPosY,
2660           ];
2661           break;
2662         case 270:
2663           [posX, posY] = [-posY, -posX];
2664           [lastPosX, lastPosY] = [-lastPosY, -lastPosX];
2665           break;
2666         default:
2667           // This is not a 0, 90, 180, 270 rotation so:
2668           //  - remove the scale factor from the matrix to get a rotation matrix
2669           //  - apply the inverse (which is the transposed) to the positions
2670           // and we can then compare positions of the glyphes to detect
2671           // a whitespace.
2672           [posX, posY] = applyInverseRotation(posX, posY, currentTransform);
2673           [lastPosX, lastPosY] = applyInverseRotation(
2674             lastPosX,
2675             lastPosY,
2676             textContentItem.prevTransform
2677           );
2678       }
2679 
2680       if (textState.font.vertical) {
2681         const advanceY = (lastPosY - posY) / textContentItem.textAdvanceScale;
2682         const advanceX = posX - lastPosX;
2683 
2684         // When the total height of the current chunk is negative
2685         // then we're writing from bottom to top.
2686         const textOrientation = Math.sign(textContentItem.height);
2687         if (advanceY < textOrientation * textContentItem.negativeSpaceMax) {
2688           if (
2689             Math.abs(advanceX) >
2690             0.5 * textContentItem.width /* not the same column */
2691           ) {
2692             appendEOL();
2693             return true;
2694           }
2695 
2696           resetLastChars();
2697           flushTextContentItem();
2698           return true;
2699         }
2700 
2701         if (Math.abs(advanceX) > textContentItem.width) {
2702           appendEOL();
2703           return true;
2704         }
2705 
2706         if (advanceY <= textOrientation * textContentItem.notASpace) {
2707           // The real spacing between 2 consecutive chars is thin enough to be
2708           // considered a non-space.
2709           resetLastChars();
2710         }
2711 
2712         if (advanceY <= textOrientation * textContentItem.trackingSpaceMin) {
2713           if (shouldAddWhitepsace()) {
2714             // The space is very thin, hence it deserves to have its own span in
2715             // order to avoid too much shift between the canvas and the text
2716             // layer.
2717             resetLastChars();
2718             flushTextContentItem();
2719             pushWhitespace({ height: Math.abs(advanceY) });
2720           } else {
2721             textContentItem.height += advanceY;
2722           }
2723         } else if (
2724           !addFakeSpaces(
2725             advanceY,
2726             textContentItem.prevTransform,
2727             textOrientation
2728           )
2729         ) {
2730           if (textContentItem.str.length === 0) {
2731             resetLastChars();
2732             pushWhitespace({ height: Math.abs(advanceY) });
2733           } else {
2734             textContentItem.height += advanceY;
2735           }
2736         }
2737 
2738         if (Math.abs(advanceX) > textContentItem.width * VERTICAL_SHIFT_RATIO) {
2739           flushTextContentItem();
2740         }
2741 
2742         return true;
2743       }
2744 
2745       const advanceX = (posX - lastPosX) / textContentItem.textAdvanceScale;
2746       const advanceY = posY - lastPosY;
2747 
2748       // When the total width of the current chunk is negative
2749       // then we're writing from right to left.
2750       const textOrientation = Math.sign(textContentItem.width);
2751       if (advanceX < textOrientation * textContentItem.negativeSpaceMax) {
2752         if (
2753           Math.abs(advanceY) >
2754           0.5 * textContentItem.height /* not the same line */
2755         ) {
2756           appendEOL();
2757           return true;
2758         }
2759 
2760         // We're moving back so in case the last char was a whitespace
2761         // we cancel it: it doesn't make sense to insert it.
2762         resetLastChars();
2763         flushTextContentItem();
2764         return true;
2765       }
2766 
2767       if (Math.abs(advanceY) > textContentItem.height) {
2768         appendEOL();
2769         return true;
2770       }
2771 
2772       if (advanceX <= textOrientation * textContentItem.notASpace) {
2773         // The real spacing between 2 consecutive chars is thin enough to be
2774         // considered a non-space.
2775         resetLastChars();
2776       }
2777 
2778       if (advanceX <= textOrientation * textContentItem.trackingSpaceMin) {
2779         if (shouldAddWhitepsace()) {
2780           // The space is very thin, hence it deserves to have its own span in
2781           // order to avoid too much shift between the canvas and the text
2782           // layer.
2783           resetLastChars();
2784           flushTextContentItem();
2785           pushWhitespace({ width: Math.abs(advanceX) });
2786         } else {
2787           textContentItem.width += advanceX;
2788         }
2789       } else if (
2790         !addFakeSpaces(advanceX, textContentItem.prevTransform, textOrientation)
2791       ) {
2792         if (textContentItem.str.length === 0) {
2793           resetLastChars();
2794           pushWhitespace({ width: Math.abs(advanceX) });
2795         } else {
2796           textContentItem.width += advanceX;
2797         }
2798       }
2799 
2800       if (Math.abs(advanceY) > textContentItem.height * VERTICAL_SHIFT_RATIO) {
2801         flushTextContentItem();
2802       }
2803 
2804       return true;
2805     }
2806 
2807     function buildTextContentItem({ chars, extraSpacing }) {
2808       const font = textState.font;
2809       if (!chars) {
2810         // Just move according to the space we have.
2811         const charSpacing = textState.charSpacing + extraSpacing;
2812         if (charSpacing) {
2813           if (!font.vertical) {
2814             textState.translateTextMatrix(
2815               charSpacing * textState.textHScale,
2816               0
2817             );
2818           } else {
2819             textState.translateTextMatrix(0, -charSpacing);
2820           }
2821         }
2822 
2823         if (keepWhiteSpace) {
2824           compareWithLastPosition(0);
2825         }
2826 
2827         return;
2828       }
2829 
2830       const glyphs = font.charsToGlyphs(chars);
2831       const scale = textState.fontMatrix[0] * textState.fontSize;
2832 
2833       for (let i = 0, ii = glyphs.length; i < ii; i++) {
2834         const glyph = glyphs[i];
2835         const { category } = glyph;
2836 
2837         if (category.isInvisibleFormatMark) {
2838           continue;
2839         }
2840         let charSpacing =
2841           textState.charSpacing + (i + 1 === ii ? extraSpacing : 0);
2842 
2843         let glyphWidth = glyph.width;
2844         if (font.vertical) {
2845           glyphWidth = glyph.vmetric ? glyph.vmetric[0] : -glyphWidth;
2846         }
2847         let scaledDim = glyphWidth * scale;
2848 
2849         if (!keepWhiteSpace && category.isWhitespace) {
2850           // Don't push a " " in the textContentItem
2851           // (except when it's between two non-spaces chars),
2852           // it will be done (if required) in next call to
2853           // compareWithLastPosition.
2854           // This way we can merge real spaces and spaces due to cursor moves.
2855           if (!font.vertical) {
2856             charSpacing += scaledDim + textState.wordSpacing;
2857             textState.translateTextMatrix(
2858               charSpacing * textState.textHScale,
2859               0
2860             );
2861           } else {
2862             charSpacing += -scaledDim + textState.wordSpacing;
2863             textState.translateTextMatrix(0, -charSpacing);
2864           }
2865           saveLastChar(" ");
2866           continue;
2867         }
2868 
2869         if (
2870           !category.isZeroWidthDiacritic &&
2871           !compareWithLastPosition(scaledDim)
2872         ) {
2873           // The glyph is not in page so just skip it but move the cursor.
2874           if (!font.vertical) {
2875             textState.translateTextMatrix(scaledDim * textState.textHScale, 0);
2876           } else {
2877             textState.translateTextMatrix(0, scaledDim);
2878           }
2879           continue;
2880         }
2881 
2882         // Must be called after compareWithLastPosition because
2883         // the textContentItem could have been flushed.
2884         const textChunk = ensureTextContentItem();
2885         if (category.isZeroWidthDiacritic) {
2886           scaledDim = 0;
2887         }
2888 
2889         if (!font.vertical) {
2890           scaledDim *= textState.textHScale;
2891           textState.translateTextMatrix(scaledDim, 0);
2892           textChunk.width += scaledDim;
2893         } else {
2894           textState.translateTextMatrix(0, scaledDim);
2895           scaledDim = Math.abs(scaledDim);
2896           textChunk.height += scaledDim;
2897         }
2898 
2899         if (scaledDim) {
2900           // Save the position of the last visible character.
2901           textChunk.prevTransform = getCurrentTextTransform();
2902         }
2903 
2904         const glyphUnicode = glyph.unicode;
2905         if (saveLastChar(glyphUnicode)) {
2906           // The two last chars are a non-whitespace followed by a whitespace
2907           // and then this non-whitespace, so we insert a whitespace here.
2908           // Replaces all whitespaces with standard spaces (0x20), to avoid
2909           // alignment issues between the textLayer and the canvas if the text
2910           // contains e.g. tabs (fixes issue6612.pdf).
2911           textChunk.str.push(" ");
2912         }
2913         textChunk.str.push(glyphUnicode);
2914 
2915         if (charSpacing) {
2916           if (!font.vertical) {
2917             textState.translateTextMatrix(
2918               charSpacing * textState.textHScale,
2919               0
2920             );
2921           } else {
2922             textState.translateTextMatrix(0, -charSpacing);
2923           }
2924         }
2925       }
2926     }
2927 
2928     function appendEOL() {
2929       resetLastChars();
2930       if (textContentItem.initialized) {
2931         textContentItem.hasEOL = true;
2932         flushTextContentItem();
2933       } else {
2934         textContent.items.push({
2935           str: "",
2936           dir: "ltr",
2937           width: 0,
2938           height: 0,
2939           transform: getCurrentTextTransform(),
2940           fontName: textState.loadedName,
2941           hasEOL: true,
2942         });
2943       }
2944     }
2945 
2946     function addFakeSpaces(width, transf, textOrientation) {
2947       if (
2948         textOrientation * textContentItem.spaceInFlowMin <= width &&
2949         width <= textOrientation * textContentItem.spaceInFlowMax
2950       ) {
2951         if (textContentItem.initialized) {
2952           resetLastChars();
2953           textContentItem.str.push(" ");
2954         }
2955         return false;
2956       }
2957 
2958       const fontName = textContentItem.fontName;
2959 
2960       let height = 0;
2961       if (textContentItem.vertical) {
2962         height = width;
2963         width = 0;
2964       }
2965 
2966       flushTextContentItem();
2967       resetLastChars();
2968       pushWhitespace({
2969         width: Math.abs(width),
2970         height: Math.abs(height),
2971         transform: transf || getCurrentTextTransform(),
2972         fontName,
2973       });
2974 
2975       return true;
2976     }
2977 
2978     function flushTextContentItem() {
2979       if (!textContentItem.initialized || !textContentItem.str) {
2980         return;
2981       }
2982 
2983       // Do final text scaling.
2984       if (!textContentItem.vertical) {
2985         textContentItem.totalWidth +=
2986           textContentItem.width * textContentItem.textAdvanceScale;
2987       } else {
2988         textContentItem.totalHeight +=
2989           textContentItem.height * textContentItem.textAdvanceScale;
2990       }
2991 
2992       textContent.items.push(runBidiTransform(textContentItem));
2993       textContentItem.initialized = false;
2994       textContentItem.str.length = 0;
2995     }
2996 
2997     function enqueueChunk(batch = false) {
2998       const length = textContent.items.length;
2999       if (length === 0) {
3000         return;
3001       }
3002       if (batch && length < TEXT_CHUNK_BATCH_SIZE) {
3003         return;
3004       }
3005       sink.enqueue(textContent, length);
3006       textContent.items = [];
3007       textContent.styles = Object.create(null);
3008     }
3009 
3010     const timeSlotManager = new TimeSlotManager();
3011 
3012     return new Promise(function promiseBody(resolve, reject) {
3013       const next = function (promise) {
3014         enqueueChunk(/* batch = */ true);
3015         Promise.all([promise, sink.ready]).then(function () {
3016           try {
3017             promiseBody(resolve, reject);
3018           } catch (ex) {
3019             reject(ex);
3020           }
3021         }, reject);
3022       };
3023       task.ensureNotTerminated();
3024       timeSlotManager.reset();
3025 
3026       const operation = {};
3027       let stop,
3028         args = [];
3029       while (!(stop = timeSlotManager.check())) {
3030         // The arguments parsed by read() are not used beyond this loop, so
3031         // we can reuse the same array on every iteration, thus avoiding
3032         // unnecessary allocations.
3033         args.length = 0;
3034         operation.args = args;
3035         if (!preprocessor.read(operation)) {
3036           break;
3037         }
3038 
3039         const previousState = textState;
3040         textState = stateManager.state;
3041         const fn = operation.fn;
3042         args = operation.args;
3043 
3044         switch (fn | 0) {
3045           case OPS.setFont:
3046             // Optimization to ignore multiple identical Tf commands.
3047             var fontNameArg = args[0].name,
3048               fontSizeArg = args[1];
3049             if (
3050               textState.font &&
3051               fontNameArg === textState.fontName &&
3052               fontSizeArg === textState.fontSize
3053             ) {
3054               break;
3055             }
3056 
3057             flushTextContentItem();
3058             textState.fontName = fontNameArg;
3059             textState.fontSize = fontSizeArg;
3060             next(handleSetFont(fontNameArg, null));
3061             return;
3062           case OPS.setTextRise:
3063             textState.textRise = args[0];
3064             break;
3065           case OPS.setHScale:
3066             textState.textHScale = args[0] / 100;
3067             break;
3068           case OPS.setLeading:
3069             textState.leading = args[0];
3070             break;
3071           case OPS.moveText:
3072             textState.translateTextLineMatrix(args[0], args[1]);
3073             textState.textMatrix = textState.textLineMatrix.slice();
3074             break;
3075           case OPS.setLeadingMoveText:
3076             textState.leading = -args[1];
3077             textState.translateTextLineMatrix(args[0], args[1]);
3078             textState.textMatrix = textState.textLineMatrix.slice();
3079             break;
3080           case OPS.nextLine:
3081             textState.carriageReturn();
3082             break;
3083           case OPS.setTextMatrix:
3084             textState.setTextMatrix(
3085               args[0],
3086               args[1],
3087               args[2],
3088               args[3],
3089               args[4],
3090               args[5]
3091             );
3092             textState.setTextLineMatrix(
3093               args[0],
3094               args[1],
3095               args[2],
3096               args[3],
3097               args[4],
3098               args[5]
3099             );
3100             updateAdvanceScale();
3101             break;
3102           case OPS.setCharSpacing:
3103             textState.charSpacing = args[0];
3104             break;
3105           case OPS.setWordSpacing:
3106             textState.wordSpacing = args[0];
3107             break;
3108           case OPS.beginText:
3109             textState.textMatrix = IDENTITY_MATRIX.slice();
3110             textState.textLineMatrix = IDENTITY_MATRIX.slice();
3111             break;
3112           case OPS.showSpacedText:
3113             if (!stateManager.state.font) {
3114               self.ensureStateFont(stateManager.state);
3115               continue;
3116             }
3117 
3118             const spaceFactor =
3119               ((textState.font.vertical ? 1 : -1) * textState.fontSize) / 1000;
3120             const elements = args[0];
3121             for (let i = 0, ii = elements.length; i < ii; i++) {
3122               const item = elements[i];
3123               if (typeof item === "string") {
3124                 showSpacedTextBuffer.push(item);
3125               } else if (typeof item === "number" && item !== 0) {
3126                 // PDF Specification 5.3.2 states:
3127                 // The number is expressed in thousandths of a unit of text
3128                 // space.
3129                 // This amount is subtracted from the current horizontal or
3130                 // vertical coordinate, depending on the writing mode.
3131                 // In the default coordinate system, a positive adjustment
3132                 // has the effect of moving the next glyph painted either to
3133                 // the left or down by the given amount.
3134                 const str = showSpacedTextBuffer.join("");
3135                 showSpacedTextBuffer.length = 0;
3136                 buildTextContentItem({
3137                   chars: str,
3138                   extraSpacing: item * spaceFactor,
3139                 });
3140               }
3141             }
3142 
3143             if (showSpacedTextBuffer.length > 0) {
3144               const str = showSpacedTextBuffer.join("");
3145               showSpacedTextBuffer.length = 0;
3146               buildTextContentItem({
3147                 chars: str,
3148                 extraSpacing: 0,
3149               });
3150             }
3151             break;
3152           case OPS.showText:
3153             if (!stateManager.state.font) {
3154               self.ensureStateFont(stateManager.state);
3155               continue;
3156             }
3157             buildTextContentItem({
3158               chars: args[0],
3159               extraSpacing: 0,
3160             });
3161             break;
3162           case OPS.nextLineShowText:
3163             if (!stateManager.state.font) {
3164               self.ensureStateFont(stateManager.state);
3165               continue;
3166             }
3167             textState.carriageReturn();
3168             buildTextContentItem({
3169               chars: args[0],
3170               extraSpacing: 0,
3171             });
3172             break;
3173           case OPS.nextLineSetSpacingShowText:
3174             if (!stateManager.state.font) {
3175               self.ensureStateFont(stateManager.state);
3176               continue;
3177             }
3178             textState.wordSpacing = args[0];
3179             textState.charSpacing = args[1];
3180             textState.carriageReturn();
3181             buildTextContentItem({
3182               chars: args[2],
3183               extraSpacing: 0,
3184             });
3185             break;
3186           case OPS.paintXObject:
3187             flushTextContentItem();
3188             if (!xobjs) {
3189               xobjs = resources.get("XObject") || Dict.empty;
3190             }
3191 
3192             var isValidName = args[0] instanceof Name;
3193             var name = args[0].name;
3194 
3195             if (isValidName && emptyXObjectCache.getByName(name)) {
3196               break;
3197             }
3198 
3199             next(
3200               new Promise(function (resolveXObject, rejectXObject) {
3201                 if (!isValidName) {
3202                   throw new FormatError("XObject must be referred to by name.");
3203                 }
3204 
3205                 let xobj = xobjs.getRaw(name);
3206                 if (xobj instanceof Ref) {
3207                   if (emptyXObjectCache.getByRef(xobj)) {
3208                     resolveXObject();
3209                     return;
3210                   }
3211 
3212                   const globalImage = self.globalImageCache.getData(
3213                     xobj,
3214                     self.pageIndex
3215                   );
3216                   if (globalImage) {
3217                     resolveXObject();
3218                     return;
3219                   }
3220 
3221                   xobj = xref.fetch(xobj);
3222                 }
3223 
3224                 if (!(xobj instanceof BaseStream)) {
3225                   throw new FormatError("XObject should be a stream");
3226                 }
3227 
3228                 const type = xobj.dict.get("Subtype");
3229                 if (!(type instanceof Name)) {
3230                   throw new FormatError("XObject should have a Name subtype");
3231                 }
3232 
3233                 if (type.name !== "Form") {
3234                   emptyXObjectCache.set(name, xobj.dict.objId, true);
3235 
3236                   resolveXObject();
3237                   return;
3238                 }
3239 
3240                 // Use a new `StateManager` to prevent incorrect positioning
3241                 // of textItems *after* the Form XObject, since errors in the
3242                 // data can otherwise prevent `restore` operators from
3243                 // executing.
3244                 // NOTE: Only an issue when `options.ignoreErrors === true`.
3245                 const currentState = stateManager.state.clone();
3246                 const xObjStateManager = new StateManager(currentState);
3247 
3248                 const matrix = xobj.dict.getArray("Matrix");
3249                 if (Array.isArray(matrix) && matrix.length === 6) {
3250                   xObjStateManager.transform(matrix);
3251                 }
3252 
3253                 // Enqueue the `textContent` chunk before parsing the /Form
3254                 // XObject.
3255                 enqueueChunk();
3256                 const sinkWrapper = {
3257                   enqueueInvoked: false,
3258 
3259                   enqueue(chunk, size) {
3260                     this.enqueueInvoked = true;
3261                     sink.enqueue(chunk, size);
3262                   },
3263 
3264                   get desiredSize() {
3265                     return sink.desiredSize;
3266                   },
3267 
3268                   get ready() {
3269                     return sink.ready;
3270                   },
3271                 };
3272 
3273                 self
3274                   .getTextContent({
3275                     stream: xobj,
3276                     task,
3277                     resources: xobj.dict.get("Resources") || resources,
3278                     stateManager: xObjStateManager,
3279                     includeMarkedContent,
3280                     sink: sinkWrapper,
3281                     seenStyles,
3282                     viewBox,
3283                     markedContentData,
3284                     disableNormalization,
3285                     keepWhiteSpace,
3286                   })
3287                   .then(function () {
3288                     if (!sinkWrapper.enqueueInvoked) {
3289                       emptyXObjectCache.set(name, xobj.dict.objId, true);
3290                     }
3291                     resolveXObject();
3292                   }, rejectXObject);
3293               }).catch(function (reason) {
3294                 if (reason instanceof AbortException) {
3295                   return;
3296                 }
3297                 if (self.options.ignoreErrors) {
3298                   // Error(s) in the XObject -- allow text-extraction to
3299                   // continue.
3300                   warn(`getTextContent - ignoring XObject: "${reason}".`);
3301                   return;
3302                 }
3303                 throw reason;
3304               })
3305             );
3306             return;
3307           case OPS.setGState:
3308             isValidName = args[0] instanceof Name;
3309             name = args[0].name;
3310 
3311             if (isValidName && emptyGStateCache.getByName(name)) {
3312               break;
3313             }
3314 
3315             next(
3316               new Promise(function (resolveGState, rejectGState) {
3317                 if (!isValidName) {
3318                   throw new FormatError("GState must be referred to by name.");
3319                 }
3320 
3321                 const extGState = resources.get("ExtGState");
3322                 if (!(extGState instanceof Dict)) {
3323                   throw new FormatError("ExtGState should be a dictionary.");
3324                 }
3325 
3326                 const gState = extGState.get(name);
3327                 // TODO: Attempt to lookup cached GStates by reference as well,
3328                 //       if and only if there are PDF documents where doing so
3329                 //       would significantly improve performance.
3330                 if (!(gState instanceof Dict)) {
3331                   throw new FormatError("GState should be a dictionary.");
3332                 }
3333 
3334                 const gStateFont = gState.get("Font");
3335                 if (!gStateFont) {
3336                   emptyGStateCache.set(name, gState.objId, true);
3337 
3338                   resolveGState();
3339                   return;
3340                 }
3341                 flushTextContentItem();
3342 
3343                 textState.fontName = null;
3344                 textState.fontSize = gStateFont[1];
3345                 handleSetFont(null, gStateFont[0]).then(
3346                   resolveGState,
3347                   rejectGState
3348                 );
3349               }).catch(function (reason) {
3350                 if (reason instanceof AbortException) {
3351                   return;
3352                 }
3353                 if (self.options.ignoreErrors) {
3354                   // Error(s) in the ExtGState -- allow text-extraction to
3355                   // continue.
3356                   warn(`getTextContent - ignoring ExtGState: "${reason}".`);
3357                   return;
3358                 }
3359                 throw reason;
3360               })
3361             );
3362             return;
3363           case OPS.beginMarkedContent:
3364             flushTextContentItem();
3365             if (includeMarkedContent) {
3366               markedContentData.level++;
3367 
3368               textContent.items.push({
3369                 type: "beginMarkedContent",
3370                 tag: args[0] instanceof Name ? args[0].name : null,
3371               });
3372             }
3373             break;
3374           case OPS.beginMarkedContentProps:
3375             flushTextContentItem();
3376             if (includeMarkedContent) {
3377               markedContentData.level++;
3378 
3379               let mcid = null;
3380               if (args[1] instanceof Dict) {
3381                 mcid = args[1].get("MCID");
3382               }
3383               textContent.items.push({
3384                 type: "beginMarkedContentProps",
3385                 id: Number.isInteger(mcid)
3386                   ? `${self.idFactory.getPageObjId()}_mc${mcid}`
3387                   : null,
3388                 tag: args[0] instanceof Name ? args[0].name : null,
3389               });
3390             }
3391             break;
3392           case OPS.endMarkedContent:
3393             flushTextContentItem();
3394             if (includeMarkedContent) {
3395               if (markedContentData.level === 0) {
3396                 // Handle unbalanced beginMarkedContent/endMarkedContent
3397                 // operators (fixes issue15629.pdf).
3398                 break;
3399               }
3400               markedContentData.level--;
3401 
3402               textContent.items.push({
3403                 type: "endMarkedContent",
3404               });
3405             }
3406             break;
3407           case OPS.restore:
3408             if (
3409               previousState &&
3410               (previousState.font !== textState.font ||
3411                 previousState.fontSize !== textState.fontSize ||
3412                 previousState.fontName !== textState.fontName)
3413             ) {
3414               flushTextContentItem();
3415             }
3416             break;
3417         } // switch
3418         if (textContent.items.length >= sink.desiredSize) {
3419           // Wait for ready, if we reach highWaterMark.
3420           stop = true;
3421           break;
3422         }
3423       } // while
3424       if (stop) {
3425         next(deferred);
3426         return;
3427       }
3428       flushTextContentItem();
3429       enqueueChunk();
3430       resolve();
3431     }).catch(reason => {
3432       if (reason instanceof AbortException) {
3433         return;
3434       }
3435       if (this.options.ignoreErrors) {
3436         // Error(s) in the TextContent -- allow text-extraction to continue.
3437         warn(
3438           `getTextContent - ignoring errors during "${task.name}" ` +
3439             `task: "${reason}".`
3440         );
3441 
3442         flushTextContentItem();
3443         enqueueChunk();
3444         return;
3445       }
3446       throw reason;
3447     });
3448   }
3449 
3450   extractDataStructures(dict, baseDict, properties) {
3451     const xref = this.xref;
3452     let cidToGidBytes;
3453     // 9.10.2
3454     const toUnicodePromise = this.readToUnicode(
3455       properties.toUnicode || dict.get("ToUnicode") || baseDict.get("ToUnicode")
3456     );
3457 
3458     if (properties.composite) {
3459       // CIDSystemInfo helps to match CID to glyphs
3460       const cidSystemInfo = dict.get("CIDSystemInfo");
3461       if (cidSystemInfo instanceof Dict) {
3462         properties.cidSystemInfo = {
3463           registry: stringToPDFString(cidSystemInfo.get("Registry")),
3464           ordering: stringToPDFString(cidSystemInfo.get("Ordering")),
3465           supplement: cidSystemInfo.get("Supplement"),
3466         };
3467       }
3468 
3469       try {
3470         const cidToGidMap = dict.get("CIDToGIDMap");
3471         if (cidToGidMap instanceof BaseStream) {
3472           cidToGidBytes = cidToGidMap.getBytes();
3473         }
3474       } catch (ex) {
3475         if (!this.options.ignoreErrors) {
3476           throw ex;
3477         }
3478         warn(`extractDataStructures - ignoring CIDToGIDMap data: "${ex}".`);
3479       }
3480     }
3481 
3482     // Based on 9.6.6 of the spec the encoding can come from multiple places
3483     // and depends on the font type. The base encoding and differences are
3484     // read here, but the encoding that is actually used is chosen during
3485     // glyph mapping in the font.
3486     // TODO: Loading the built in encoding in the font would allow the
3487     // differences to be merged in here not require us to hold on to it.
3488     const differences = [];
3489     let baseEncodingName = null;
3490     let encoding;
3491     if (dict.has("Encoding")) {
3492       encoding = dict.get("Encoding");
3493       if (encoding instanceof Dict) {
3494         baseEncodingName = encoding.get("BaseEncoding");
3495         baseEncodingName =
3496           baseEncodingName instanceof Name ? baseEncodingName.name : null;
3497         // Load the differences between the base and original
3498         if (encoding.has("Differences")) {
3499           const diffEncoding = encoding.get("Differences");
3500           let index = 0;
3501           for (const entry of diffEncoding) {
3502             const data = xref.fetchIfRef(entry);
3503             if (typeof data === "number") {
3504               index = data;
3505             } else if (data instanceof Name) {
3506               differences[index++] = data.name;
3507             } else {
3508               throw new FormatError(
3509                 `Invalid entry in 'Differences' array: ${data}`
3510               );
3511             }
3512           }
3513         }
3514       } else if (encoding instanceof Name) {
3515         baseEncodingName = encoding.name;
3516       } else {
3517         const msg = "Encoding is not a Name nor a Dict";
3518 
3519         if (!this.options.ignoreErrors) {
3520           throw new FormatError(msg);
3521         }
3522         warn(msg);
3523       }
3524       // According to table 114 if the encoding is a named encoding it must be
3525       // one of these predefined encodings.
3526       if (
3527         baseEncodingName !== "MacRomanEncoding" &&
3528         baseEncodingName !== "MacExpertEncoding" &&
3529         baseEncodingName !== "WinAnsiEncoding"
3530       ) {
3531         baseEncodingName = null;
3532       }
3533     }
3534 
3535     const nonEmbeddedFont = !properties.file || properties.isInternalFont,
3536       isSymbolsFontName = getSymbolsFonts()[properties.name];
3537     // Ignore an incorrectly specified named encoding for non-embedded
3538     // symbol fonts (fixes issue16464.pdf).
3539     if (baseEncodingName && nonEmbeddedFont && isSymbolsFontName) {
3540       baseEncodingName = null;
3541     }
3542 
3543     if (baseEncodingName) {
3544       properties.defaultEncoding = getEncoding(baseEncodingName);
3545     } else {
3546       const isSymbolicFont = !!(properties.flags & FontFlags.Symbolic);
3547       const isNonsymbolicFont = !!(properties.flags & FontFlags.Nonsymbolic);
3548       // According to "Table 114" in section "9.6.6.1 General" (under
3549       // "9.6.6 Character Encoding") of the PDF specification, a Nonsymbolic
3550       // font should use the `StandardEncoding` if no encoding is specified.
3551       encoding = StandardEncoding;
3552       if (properties.type === "TrueType" && !isNonsymbolicFont) {
3553         encoding = WinAnsiEncoding;
3554       }
3555       // The Symbolic attribute can be misused for regular fonts
3556       // Heuristic: we have to check if the font is a standard one also
3557       if (isSymbolicFont || isSymbolsFontName) {
3558         encoding = MacRomanEncoding;
3559         if (nonEmbeddedFont) {
3560           if (/Symbol/i.test(properties.name)) {
3561             encoding = SymbolSetEncoding;
3562           } else if (/Dingbats/i.test(properties.name)) {
3563             encoding = ZapfDingbatsEncoding;
3564           } else if (/Wingdings/i.test(properties.name)) {
3565             encoding = WinAnsiEncoding;
3566           }
3567         }
3568       }
3569       properties.defaultEncoding = encoding;
3570     }
3571 
3572     properties.differences = differences;
3573     properties.baseEncodingName = baseEncodingName;
3574     properties.hasEncoding = !!baseEncodingName || differences.length > 0;
3575     properties.dict = dict;
3576     return toUnicodePromise
3577       .then(readToUnicode => {
3578         properties.toUnicode = readToUnicode;
3579         return this.buildToUnicode(properties);
3580       })
3581       .then(builtToUnicode => {
3582         properties.toUnicode = builtToUnicode;
3583         if (cidToGidBytes) {
3584           properties.cidToGidMap = this.readCidToGidMap(
3585             cidToGidBytes,
3586             builtToUnicode
3587           );
3588         }
3589         return properties;
3590       });
3591   }
3592 
3593   /**
3594    * @returns {Array}
3595    * @private
3596    */
3597   _simpleFontToUnicode(properties, forceGlyphs = false) {
3598     assert(!properties.composite, "Must be a simple font.");
3599 
3600     const toUnicode = [];
3601     const encoding = properties.defaultEncoding.slice();
3602     const baseEncodingName = properties.baseEncodingName;
3603     // Merge in the differences array.
3604     const differences = properties.differences;
3605     for (const charcode in differences) {
3606       const glyphName = differences[charcode];
3607       if (glyphName === ".notdef") {
3608         // Skip .notdef to prevent rendering errors, e.g. boxes appearing
3609         // where there should be spaces (fixes issue5256.pdf).
3610         continue;
3611       }
3612       encoding[charcode] = glyphName;
3613     }
3614     const glyphsUnicodeMap = getGlyphsUnicode();
3615     for (const charcode in encoding) {
3616       // a) Map the character code to a character name.
3617       let glyphName = encoding[charcode];
3618       if (glyphName === "") {
3619         continue;
3620       }
3621       // b) Look up the character name in the Adobe Glyph List (see the
3622       //    Bibliography) to obtain the corresponding Unicode value.
3623       let unicode = glyphsUnicodeMap[glyphName];
3624       if (unicode !== undefined) {
3625         toUnicode[charcode] = String.fromCharCode(unicode);
3626         continue;
3627       }
3628       // (undocumented) c) Few heuristics to recognize unknown glyphs
3629       // NOTE: Adobe Reader does not do this step, but OSX Preview does
3630       let code = 0;
3631       switch (glyphName[0]) {
3632         case "G": // Gxx glyph
3633           if (glyphName.length === 3) {
3634             code = parseInt(glyphName.substring(1), 16);
3635           }
3636           break;
3637         case "g": // g00xx glyph
3638           if (glyphName.length === 5) {
3639             code = parseInt(glyphName.substring(1), 16);
3640           }
3641           break;
3642         case "C": // Cdd{d} glyph
3643         case "c": // cdd{d} glyph
3644           if (glyphName.length >= 3 && glyphName.length <= 4) {
3645             const codeStr = glyphName.substring(1);
3646 
3647             if (forceGlyphs) {
3648               code = parseInt(codeStr, 16);
3649               break;
3650             }
3651             // Normally the Cdd{d}/cdd{d} glyphName format will contain
3652             // regular, i.e. base 10, charCodes (see issue4550.pdf)...
3653             code = +codeStr;
3654 
3655             // ... however some PDF generators violate that assumption by
3656             // containing glyph, i.e. base 16, codes instead.
3657             // In that case we need to re-parse the *entire* encoding to
3658             // prevent broken text-selection (fixes issue9655_reduced.pdf).
3659             if (Number.isNaN(code) && Number.isInteger(parseInt(codeStr, 16))) {
3660               return this._simpleFontToUnicode(
3661                 properties,
3662                 /* forceGlyphs */ true
3663               );
3664             }
3665           }
3666           break;
3667         case "u": // 'uniXXXX'/'uXXXX{XX}' glyphs
3668           unicode = getUnicodeForGlyph(glyphName, glyphsUnicodeMap);
3669           if (unicode !== -1) {
3670             code = unicode;
3671           }
3672           break;
3673         default:
3674           // Support (some) non-standard ligatures.
3675           switch (glyphName) {
3676             case "f_h":
3677             case "f_t":
3678             case "T_h":
3679               toUnicode[charcode] = glyphName.replaceAll("_", "");
3680               continue;
3681           }
3682           break;
3683       }
3684       if (code > 0 && code <= 0x10ffff && Number.isInteger(code)) {
3685         // If `baseEncodingName` is one the predefined encodings, and `code`
3686         // equals `charcode`, using the glyph defined in the baseEncoding
3687         // seems to yield a better `toUnicode` mapping (fixes issue 5070).
3688         if (baseEncodingName && code === +charcode) {
3689           const baseEncoding = getEncoding(baseEncodingName);
3690           if (baseEncoding && (glyphName = baseEncoding[charcode])) {
3691             toUnicode[charcode] = String.fromCharCode(
3692               glyphsUnicodeMap[glyphName]
3693             );
3694             continue;
3695           }
3696         }
3697         toUnicode[charcode] = String.fromCodePoint(code);
3698       }
3699     }
3700     return toUnicode;
3701   }
3702 
3703   /**
3704    * Builds a char code to unicode map based on section 9.10 of the spec.
3705    * @param {Object} properties Font properties object.
3706    * @returns {Promise} A Promise that is resolved with a
3707    *   {ToUnicodeMap|IdentityToUnicodeMap} object.
3708    */
3709   async buildToUnicode(properties) {
3710     properties.hasIncludedToUnicodeMap = properties.toUnicode?.length > 0;
3711 
3712     // Section 9.10.2 Mapping Character Codes to Unicode Values
3713     if (properties.hasIncludedToUnicodeMap) {
3714       // Some fonts contain incomplete ToUnicode data, causing issues with
3715       // text-extraction. For simple fonts, containing encoding information,
3716       // use a fallback ToUnicode map to improve this (fixes issue8229.pdf).
3717       if (!properties.composite && properties.hasEncoding) {
3718         properties.fallbackToUnicode = this._simpleFontToUnicode(properties);
3719       }
3720       return properties.toUnicode;
3721     }
3722 
3723     // According to the spec if the font is a simple font we should only map
3724     // to unicode if the base encoding is MacRoman, MacExpert, or WinAnsi or
3725     // the differences array only contains adobe standard or symbol set names,
3726     // in pratice it seems better to always try to create a toUnicode map
3727     // based of the default encoding.
3728     if (!properties.composite /* is simple font */) {
3729       return new ToUnicodeMap(this._simpleFontToUnicode(properties));
3730     }
3731 
3732     // If the font is a composite font that uses one of the predefined CMaps
3733     // listed in Table 118 (except Identity–H and Identity–V) or whose
3734     // descendant CIDFont uses the Adobe-GB1, Adobe-CNS1, Adobe-Japan1, or
3735     // Adobe-Korea1 character collection:
3736     if (
3737       properties.composite &&
3738       ((properties.cMap.builtInCMap &&
3739         !(properties.cMap instanceof IdentityCMap)) ||
3740         (properties.cidSystemInfo.registry === "Adobe" &&
3741           (properties.cidSystemInfo.ordering === "GB1" ||
3742             properties.cidSystemInfo.ordering === "CNS1" ||
3743             properties.cidSystemInfo.ordering === "Japan1" ||
3744             properties.cidSystemInfo.ordering === "Korea1")))
3745     ) {
3746       // Then:
3747       // a) Map the character code to a character identifier (CID) according
3748       // to the font’s CMap.
3749       // b) Obtain the registry and ordering of the character collection used
3750       // by the font’s CMap (for example, Adobe and Japan1) from its
3751       // CIDSystemInfo dictionary.
3752       const { registry, ordering } = properties.cidSystemInfo;
3753       // c) Construct a second CMap name by concatenating the registry and
3754       // ordering obtained in step (b) in the format registry–ordering–UCS2
3755       // (for example, Adobe–Japan1–UCS2).
3756       const ucs2CMapName = Name.get(`${registry}-${ordering}-UCS2`);
3757       // d) Obtain the CMap with the name constructed in step (c) (available
3758       // from the ASN Web site; see the Bibliography).
3759       const ucs2CMap = await CMapFactory.create({
3760         encoding: ucs2CMapName,
3761         fetchBuiltInCMap: this._fetchBuiltInCMapBound,
3762         useCMap: null,
3763       });
3764       const toUnicode = [],
3765         buf = [];
3766       properties.cMap.forEach(function (charcode, cid) {
3767         if (cid > 0xffff) {
3768           throw new FormatError("Max size of CID is 65,535");
3769         }
3770         // e) Map the CID obtained in step (a) according to the CMap
3771         // obtained in step (d), producing a Unicode value.
3772         const ucs2 = ucs2CMap.lookup(cid);
3773         if (ucs2) {
3774           buf.length = 0;
3775           // Support multi-byte entries (fixes issue16176.pdf).
3776           for (let i = 0, ii = ucs2.length; i < ii; i += 2) {
3777             buf.push((ucs2.charCodeAt(i) << 8) + ucs2.charCodeAt(i + 1));
3778           }
3779           toUnicode[charcode] = String.fromCharCode(...buf);
3780         }
3781       });
3782       return new ToUnicodeMap(toUnicode);
3783     }
3784 
3785     // The viewer's choice, just use an identity map.
3786     return new IdentityToUnicodeMap(properties.firstChar, properties.lastChar);
3787   }
3788 
3789   readToUnicode(cmapObj) {
3790     if (!cmapObj) {
3791       return Promise.resolve(null);
3792     }
3793     if (cmapObj instanceof Name) {
3794       return CMapFactory.create({
3795         encoding: cmapObj,
3796         fetchBuiltInCMap: this._fetchBuiltInCMapBound,
3797         useCMap: null,
3798       }).then(function (cmap) {
3799         if (cmap instanceof IdentityCMap) {
3800           return new IdentityToUnicodeMap(0, 0xffff);
3801         }
3802         return new ToUnicodeMap(cmap.getMap());
3803       });
3804     } else if (cmapObj instanceof BaseStream) {
3805       return CMapFactory.create({
3806         encoding: cmapObj,
3807         fetchBuiltInCMap: this._fetchBuiltInCMapBound,
3808         useCMap: null,
3809       }).then(
3810         function (cmap) {
3811           if (cmap instanceof IdentityCMap) {
3812             return new IdentityToUnicodeMap(0, 0xffff);
3813           }
3814           const map = new Array(cmap.length);
3815           // Convert UTF-16BE
3816           // NOTE: cmap can be a sparse array, so use forEach instead of
3817           // `for(;;)` to iterate over all keys.
3818           cmap.forEach(function (charCode, token) {
3819             // Some cmaps contain *only* CID characters (fixes issue9367.pdf).
3820             if (typeof token === "number") {
3821               map[charCode] = String.fromCodePoint(token);
3822               return;
3823             }
3824             const str = [];
3825             for (let k = 0; k < token.length; k += 2) {
3826               const w1 = (token.charCodeAt(k) << 8) | token.charCodeAt(k + 1);
3827               if ((w1 & 0xf800) !== 0xd800) {
3828                 // w1 < 0xD800 || w1 > 0xDFFF
3829                 str.push(w1);
3830                 continue;
3831               }
3832               k += 2;
3833               const w2 = (token.charCodeAt(k) << 8) | token.charCodeAt(k + 1);
3834               str.push(((w1 & 0x3ff) << 10) + (w2 & 0x3ff) + 0x10000);
3835             }
3836             map[charCode] = String.fromCodePoint(...str);
3837           });
3838           return new ToUnicodeMap(map);
3839         },
3840         reason => {
3841           if (reason instanceof AbortException) {
3842             return null;
3843           }
3844           if (this.options.ignoreErrors) {
3845             warn(`readToUnicode - ignoring ToUnicode data: "${reason}".`);
3846             return null;
3847           }
3848           throw reason;
3849         }
3850       );
3851     }
3852     return Promise.resolve(null);
3853   }
3854 
3855   readCidToGidMap(glyphsData, toUnicode) {
3856     // Extract the encoding from the CIDToGIDMap
3857 
3858     // Set encoding 0 to later verify the font has an encoding
3859     const result = [];
3860     for (let j = 0, jj = glyphsData.length; j < jj; j++) {
3861       const glyphID = (glyphsData[j++] << 8) | glyphsData[j];
3862       const code = j >> 1;
3863       if (glyphID === 0 && !toUnicode.has(code)) {
3864         continue;
3865       }
3866       result[code] = glyphID;
3867     }
3868     return result;
3869   }
3870 
3871   extractWidths(dict, descriptor, properties) {
3872     const xref = this.xref;
3873     let glyphsWidths = [];
3874     let defaultWidth = 0;
3875     const glyphsVMetrics = [];
3876     let defaultVMetrics;
3877     let i, ii, j, jj, start, code, widths;
3878     if (properties.composite) {
3879       defaultWidth = dict.has("DW") ? dict.get("DW") : 1000;
3880 
3881       widths = dict.get("W");
3882       if (widths) {
3883         for (i = 0, ii = widths.length; i < ii; i++) {
3884           start = xref.fetchIfRef(widths[i++]);
3885           code = xref.fetchIfRef(widths[i]);
3886           if (Array.isArray(code)) {
3887             for (j = 0, jj = code.length; j < jj; j++) {
3888               glyphsWidths[start++] = xref.fetchIfRef(code[j]);
3889             }
3890           } else {
3891             const width = xref.fetchIfRef(widths[++i]);
3892             for (j = start; j <= code; j++) {
3893               glyphsWidths[j] = width;
3894             }
3895           }
3896         }
3897       }
3898 
3899       if (properties.vertical) {
3900         let vmetrics = dict.getArray("DW2") || [880, -1000];
3901         defaultVMetrics = [vmetrics[1], defaultWidth * 0.5, vmetrics[0]];
3902         vmetrics = dict.get("W2");
3903         if (vmetrics) {
3904           for (i = 0, ii = vmetrics.length; i < ii; i++) {
3905             start = xref.fetchIfRef(vmetrics[i++]);
3906             code = xref.fetchIfRef(vmetrics[i]);
3907             if (Array.isArray(code)) {
3908               for (j = 0, jj = code.length; j < jj; j++) {
3909                 glyphsVMetrics[start++] = [
3910                   xref.fetchIfRef(code[j++]),
3911                   xref.fetchIfRef(code[j++]),
3912                   xref.fetchIfRef(code[j]),
3913                 ];
3914               }
3915             } else {
3916               const vmetric = [
3917                 xref.fetchIfRef(vmetrics[++i]),
3918                 xref.fetchIfRef(vmetrics[++i]),
3919                 xref.fetchIfRef(vmetrics[++i]),
3920               ];
3921               for (j = start; j <= code; j++) {
3922                 glyphsVMetrics[j] = vmetric;
3923               }
3924             }
3925           }
3926         }
3927       }
3928     } else {
3929       const firstChar = properties.firstChar;
3930       widths = dict.get("Widths");
3931       if (widths) {
3932         j = firstChar;
3933         for (i = 0, ii = widths.length; i < ii; i++) {
3934           glyphsWidths[j++] = xref.fetchIfRef(widths[i]);
3935         }
3936         defaultWidth = parseFloat(descriptor.get("MissingWidth")) || 0;
3937       } else {
3938         // Trying get the BaseFont metrics (see comment above).
3939         const baseFontName = dict.get("BaseFont");
3940         if (baseFontName instanceof Name) {
3941           const metrics = this.getBaseFontMetrics(baseFontName.name);
3942 
3943           glyphsWidths = this.buildCharCodeToWidth(metrics.widths, properties);
3944           defaultWidth = metrics.defaultWidth;
3945         }
3946       }
3947     }
3948 
3949     // Heuristic: detection of monospace font by checking all non-zero widths
3950     let isMonospace = true;
3951     let firstWidth = defaultWidth;
3952     for (const glyph in glyphsWidths) {
3953       const glyphWidth = glyphsWidths[glyph];
3954       if (!glyphWidth) {
3955         continue;
3956       }
3957       if (!firstWidth) {
3958         firstWidth = glyphWidth;
3959         continue;
3960       }
3961       if (firstWidth !== glyphWidth) {
3962         isMonospace = false;
3963         break;
3964       }
3965     }
3966     if (isMonospace) {
3967       properties.flags |= FontFlags.FixedPitch;
3968     } else {
3969       // Clear the flag.
3970       properties.flags &= ~FontFlags.FixedPitch;
3971     }
3972 
3973     properties.defaultWidth = defaultWidth;
3974     properties.widths = glyphsWidths;
3975     properties.defaultVMetrics = defaultVMetrics;
3976     properties.vmetrics = glyphsVMetrics;
3977   }
3978 
3979   isSerifFont(baseFontName) {
3980     // Simulating descriptor flags attribute
3981     const fontNameWoStyle = baseFontName.split("-")[0];
3982     return (
3983       fontNameWoStyle in getSerifFonts() || /serif/gi.test(fontNameWoStyle)
3984     );
3985   }
3986 
3987   getBaseFontMetrics(name) {
3988     let defaultWidth = 0;
3989     let widths = Object.create(null);
3990     let monospace = false;
3991     const stdFontMap = getStdFontMap();
3992     let lookupName = stdFontMap[name] || name;
3993     const Metrics = getMetrics();
3994 
3995     if (!(lookupName in Metrics)) {
3996       // Use default fonts for looking up font metrics if the passed
3997       // font is not a base font
3998       lookupName = this.isSerifFont(name) ? "Times-Roman" : "Helvetica";
3999     }
4000     const glyphWidths = Metrics[lookupName];
4001 
4002     if (typeof glyphWidths === "number") {
4003       defaultWidth = glyphWidths;
4004       monospace = true;
4005     } else {
4006       widths = glyphWidths(); // expand lazy widths array
4007     }
4008 
4009     return {
4010       defaultWidth,
4011       monospace,
4012       widths,
4013     };
4014   }
4015 
4016   buildCharCodeToWidth(widthsByGlyphName, properties) {
4017     const widths = Object.create(null);
4018     const differences = properties.differences;
4019     const encoding = properties.defaultEncoding;
4020     for (let charCode = 0; charCode < 256; charCode++) {
4021       if (charCode in differences && widthsByGlyphName[differences[charCode]]) {
4022         widths[charCode] = widthsByGlyphName[differences[charCode]];
4023         continue;
4024       }
4025       if (charCode in encoding && widthsByGlyphName[encoding[charCode]]) {
4026         widths[charCode] = widthsByGlyphName[encoding[charCode]];
4027         continue;
4028       }
4029     }
4030     return widths;
4031   }
4032 
4033   preEvaluateFont(dict) {
4034     const baseDict = dict;
4035     let type = dict.get("Subtype");
4036     if (!(type instanceof Name)) {
4037       throw new FormatError("invalid font Subtype");
4038     }
4039 
4040     let composite = false;
4041     let hash, toUnicode;
4042     if (type.name === "Type0") {
4043       // If font is a composite
4044       //  - get the descendant font
4045       //  - set the type according to the descendant font
4046       //  - get the FontDescriptor from the descendant font
4047       const df = dict.get("DescendantFonts");
4048       if (!df) {
4049         throw new FormatError("Descendant fonts are not specified");
4050       }
4051       dict = Array.isArray(df) ? this.xref.fetchIfRef(df[0]) : df;
4052 
4053       if (!(dict instanceof Dict)) {
4054         throw new FormatError("Descendant font is not a dictionary.");
4055       }
4056       type = dict.get("Subtype");
4057       if (!(type instanceof Name)) {
4058         throw new FormatError("invalid font Subtype");
4059       }
4060       composite = true;
4061     }
4062 
4063     const firstChar = dict.get("FirstChar") || 0,
4064       lastChar = dict.get("LastChar") || (composite ? 0xffff : 0xff);
4065     const descriptor = dict.get("FontDescriptor");
4066     if (descriptor) {
4067       hash = new MurmurHash3_64();
4068 
4069       const encoding = baseDict.getRaw("Encoding");
4070       if (encoding instanceof Name) {
4071         hash.update(encoding.name);
4072       } else if (encoding instanceof Ref) {
4073         hash.update(encoding.toString());
4074       } else if (encoding instanceof Dict) {
4075         for (const entry of encoding.getRawValues()) {
4076           if (entry instanceof Name) {
4077             hash.update(entry.name);
4078           } else if (entry instanceof Ref) {
4079             hash.update(entry.toString());
4080           } else if (Array.isArray(entry)) {
4081             // 'Differences' array (fixes bug1157493.pdf).
4082             const diffLength = entry.length,
4083               diffBuf = new Array(diffLength);
4084 
4085             for (let j = 0; j < diffLength; j++) {
4086               const diffEntry = entry[j];
4087               if (diffEntry instanceof Name) {
4088                 diffBuf[j] = diffEntry.name;
4089               } else if (
4090                 typeof diffEntry === "number" ||
4091                 diffEntry instanceof Ref
4092               ) {
4093                 diffBuf[j] = diffEntry.toString();
4094               }
4095             }
4096             hash.update(diffBuf.join());
4097           }
4098         }
4099       }
4100 
4101       hash.update(`${firstChar}-${lastChar}`); // Fixes issue10665_reduced.pdf
4102 
4103       toUnicode = dict.get("ToUnicode") || baseDict.get("ToUnicode");
4104       if (toUnicode instanceof BaseStream) {
4105         const stream = toUnicode.str || toUnicode;
4106         const uint8array = stream.buffer
4107           ? new Uint8Array(stream.buffer.buffer, 0, stream.bufferLength)
4108           : new Uint8Array(
4109               stream.bytes.buffer,
4110               stream.start,
4111               stream.end - stream.start
4112             );
4113         hash.update(uint8array);
4114       } else if (toUnicode instanceof Name) {
4115         hash.update(toUnicode.name);
4116       }
4117 
4118       const widths = dict.get("Widths") || baseDict.get("Widths");
4119       if (Array.isArray(widths)) {
4120         const widthsBuf = [];
4121         for (const entry of widths) {
4122           if (typeof entry === "number" || entry instanceof Ref) {
4123             widthsBuf.push(entry.toString());
4124           }
4125         }
4126         hash.update(widthsBuf.join());
4127       }
4128 
4129       if (composite) {
4130         hash.update("compositeFont");
4131 
4132         const compositeWidths = dict.get("W") || baseDict.get("W");
4133         if (Array.isArray(compositeWidths)) {
4134           const widthsBuf = [];
4135           for (const entry of compositeWidths) {
4136             if (typeof entry === "number" || entry instanceof Ref) {
4137               widthsBuf.push(entry.toString());
4138             } else if (Array.isArray(entry)) {
4139               const subWidthsBuf = [];
4140               for (const element of entry) {
4141                 if (typeof element === "number" || element instanceof Ref) {
4142                   subWidthsBuf.push(element.toString());
4143                 }
4144               }
4145               widthsBuf.push(`[${subWidthsBuf.join()}]`);
4146             }
4147           }
4148           hash.update(widthsBuf.join());
4149         }
4150 
4151         const cidToGidMap =
4152           dict.getRaw("CIDToGIDMap") || baseDict.getRaw("CIDToGIDMap");
4153         if (cidToGidMap instanceof Name) {
4154           hash.update(cidToGidMap.name);
4155         } else if (cidToGidMap instanceof Ref) {
4156           hash.update(cidToGidMap.toString());
4157         } else if (cidToGidMap instanceof BaseStream) {
4158           hash.update(cidToGidMap.peekBytes());
4159         }
4160       }
4161     }
4162 
4163     return {
4164       descriptor,
4165       dict,
4166       baseDict,
4167       composite,
4168       type: type.name,
4169       firstChar,
4170       lastChar,
4171       toUnicode,
4172       hash: hash ? hash.hexdigest() : "",
4173     };
4174   }
4175 
4176   async translateFont({
4177     descriptor,
4178     dict,
4179     baseDict,
4180     composite,
4181     type,
4182     firstChar,
4183     lastChar,
4184     toUnicode,
4185     cssFontInfo,
4186   }) {
4187     const isType3Font = type === "Type3";
4188     let properties;
4189 
4190     if (!descriptor) {
4191       if (isType3Font) {
4192         // FontDescriptor is only required for Type3 fonts when the document
4193         // is a tagged pdf. Create a barbebones one to get by.
4194         descriptor = new Dict(null);
4195         descriptor.set("FontName", Name.get(type));
4196         descriptor.set("FontBBox", dict.getArray("FontBBox") || [0, 0, 0, 0]);
4197       } else {
4198         // Before PDF 1.5 if the font was one of the base 14 fonts, having a
4199         // FontDescriptor was not required.
4200         // This case is here for compatibility.
4201         let baseFontName = dict.get("BaseFont");
4202         if (!(baseFontName instanceof Name)) {
4203           throw new FormatError("Base font is not specified");
4204         }
4205 
4206         // Using base font name as a font name.
4207         baseFontName = baseFontName.name.replaceAll(/[,_]/g, "-");
4208         const metrics = this.getBaseFontMetrics(baseFontName);
4209 
4210         // Simulating descriptor flags attribute
4211         const fontNameWoStyle = baseFontName.split("-")[0];
4212         const flags =
4213           (this.isSerifFont(fontNameWoStyle) ? FontFlags.Serif : 0) |
4214           (metrics.monospace ? FontFlags.FixedPitch : 0) |
4215           (getSymbolsFonts()[fontNameWoStyle]
4216             ? FontFlags.Symbolic
4217             : FontFlags.Nonsymbolic);
4218 
4219         properties = {
4220           type,
4221           name: baseFontName,
4222           loadedName: baseDict.loadedName,
4223           systemFontInfo: null,
4224           widths: metrics.widths,
4225           defaultWidth: metrics.defaultWidth,
4226           isSimulatedFlags: true,
4227           flags,
4228           firstChar,
4229           lastChar,
4230           toUnicode,
4231           xHeight: 0,
4232           capHeight: 0,
4233           italicAngle: 0,
4234           isType3Font,
4235         };
4236         const widths = dict.get("Widths");
4237 
4238         const standardFontName = getStandardFontName(baseFontName);
4239         let file = null;
4240         if (standardFontName) {
4241           file = await this.fetchStandardFontData(standardFontName);
4242           properties.isInternalFont = !!file;
4243         }
4244         if (!properties.isInternalFont && this.options.useSystemFonts) {
4245           properties.systemFontInfo = getFontSubstitution(
4246             this.systemFontCache,
4247             this.idFactory,
4248             this.options.standardFontDataUrl,
4249             baseFontName,
4250             standardFontName
4251           );
4252         }
4253         return this.extractDataStructures(dict, dict, properties).then(
4254           newProperties => {
4255             if (widths) {
4256               const glyphWidths = [];
4257               let j = firstChar;
4258               for (const width of widths) {
4259                 glyphWidths[j++] = this.xref.fetchIfRef(width);
4260               }
4261               newProperties.widths = glyphWidths;
4262             } else {
4263               newProperties.widths = this.buildCharCodeToWidth(
4264                 metrics.widths,
4265                 newProperties
4266               );
4267             }
4268             return new Font(baseFontName, file, newProperties);
4269           }
4270         );
4271       }
4272     }
4273 
4274     // According to the spec if 'FontDescriptor' is declared, 'FirstChar',
4275     // 'LastChar' and 'Widths' should exist too, but some PDF encoders seem
4276     // to ignore this rule when a variant of a standard font is used.
4277     // TODO Fill the width array depending on which of the base font this is
4278     // a variant.
4279 
4280     let fontName = descriptor.get("FontName");
4281     let baseFont = dict.get("BaseFont");
4282     // Some bad PDFs have a string as the font name.
4283     if (typeof fontName === "string") {
4284       fontName = Name.get(fontName);
4285     }
4286     if (typeof baseFont === "string") {
4287       baseFont = Name.get(baseFont);
4288     }
4289 
4290     const fontNameStr = fontName?.name;
4291     const baseFontStr = baseFont?.name;
4292     if (!isType3Font && fontNameStr !== baseFontStr) {
4293       info(
4294         `The FontDescriptor's FontName is "${fontNameStr}" but ` +
4295           `should be the same as the Font's BaseFont "${baseFontStr}".`
4296       );
4297       // - Workaround for cases where e.g. fontNameStr = 'Arial' and
4298       //   baseFontStr = 'Arial,Bold' (needed when no font file is embedded).
4299       //
4300       // - Workaround for cases where e.g. fontNameStr = 'wg09np' and
4301       //   baseFontStr = 'Wingdings-Regular' (fixes issue7454.pdf).
4302       if (
4303         fontNameStr &&
4304         baseFontStr &&
4305         (baseFontStr.startsWith(fontNameStr) ||
4306           (!isKnownFontName(fontNameStr) && isKnownFontName(baseFontStr)))
4307       ) {
4308         fontName = null;
4309       }
4310     }
4311     fontName ||= baseFont;
4312 
4313     if (!(fontName instanceof Name)) {
4314       throw new FormatError("invalid font name");
4315     }
4316 
4317     let fontFile, subtype, length1, length2, length3;
4318     try {
4319       fontFile = descriptor.get("FontFile", "FontFile2", "FontFile3");
4320     } catch (ex) {
4321       if (!this.options.ignoreErrors) {
4322         throw ex;
4323       }
4324       warn(`translateFont - fetching "${fontName.name}" font file: "${ex}".`);
4325       fontFile = new NullStream();
4326     }
4327     let isInternalFont = false;
4328     let glyphScaleFactors = null;
4329     let systemFontInfo = null;
4330     if (fontFile) {
4331       if (fontFile.dict) {
4332         const subtypeEntry = fontFile.dict.get("Subtype");
4333         if (subtypeEntry instanceof Name) {
4334           subtype = subtypeEntry.name;
4335         }
4336         length1 = fontFile.dict.get("Length1");
4337         length2 = fontFile.dict.get("Length2");
4338         length3 = fontFile.dict.get("Length3");
4339       }
4340     } else if (cssFontInfo) {
4341       // We've a missing XFA font.
4342       const standardFontName = getXfaFontName(fontName.name);
4343       if (standardFontName) {
4344         cssFontInfo.fontFamily = `${cssFontInfo.fontFamily}-PdfJS-XFA`;
4345         cssFontInfo.metrics = standardFontName.metrics || null;
4346         glyphScaleFactors = standardFontName.factors || null;
4347         fontFile = await this.fetchStandardFontData(standardFontName.name);
4348         isInternalFont = !!fontFile;
4349 
4350         // We're using a substitution font but for example widths (if any)
4351         // are related to the glyph positions in the font.
4352         // So we overwrite everything here to be sure that widths are
4353         // correct.
4354         baseDict = dict = getXfaFontDict(fontName.name);
4355         composite = true;
4356       }
4357     } else if (!isType3Font) {
4358       const standardFontName = getStandardFontName(fontName.name);
4359       if (standardFontName) {
4360         fontFile = await this.fetchStandardFontData(standardFontName);
4361         isInternalFont = !!fontFile;
4362       }
4363       if (!isInternalFont && this.options.useSystemFonts) {
4364         systemFontInfo = getFontSubstitution(
4365           this.systemFontCache,
4366           this.idFactory,
4367           this.options.standardFontDataUrl,
4368           fontName.name,
4369           standardFontName
4370         );
4371       }
4372     }
4373 
4374     properties = {
4375       type,
4376       name: fontName.name,
4377       subtype,
4378       file: fontFile,
4379       length1,
4380       length2,
4381       length3,
4382       isInternalFont,
4383       loadedName: baseDict.loadedName,
4384       composite,
4385       fixedPitch: false,
4386       fontMatrix: dict.getArray("FontMatrix") || FONT_IDENTITY_MATRIX,
4387       firstChar,
4388       lastChar,
4389       toUnicode,
4390       bbox: descriptor.getArray("FontBBox") || dict.getArray("FontBBox"),
4391       ascent: descriptor.get("Ascent"),
4392       descent: descriptor.get("Descent"),
4393       xHeight: descriptor.get("XHeight") || 0,
4394       capHeight: descriptor.get("CapHeight") || 0,
4395       flags: descriptor.get("Flags"),
4396       italicAngle: descriptor.get("ItalicAngle") || 0,
4397       isType3Font,
4398       cssFontInfo,
4399       scaleFactors: glyphScaleFactors,
4400       systemFontInfo,
4401     };
4402 
4403     if (composite) {
4404       const cidEncoding = baseDict.get("Encoding");
4405       if (cidEncoding instanceof Name) {
4406         properties.cidEncoding = cidEncoding.name;
4407       }
4408       const cMap = await CMapFactory.create({
4409         encoding: cidEncoding,
4410         fetchBuiltInCMap: this._fetchBuiltInCMapBound,
4411         useCMap: null,
4412       });
4413       properties.cMap = cMap;
4414       properties.vertical = properties.cMap.vertical;
4415     }
4416 
4417     return this.extractDataStructures(dict, baseDict, properties).then(
4418       newProperties => {
4419         this.extractWidths(dict, descriptor, newProperties);
4420 
4421         return new Font(fontName.name, fontFile, newProperties);
4422       }
4423     );
4424   }
4425 
4426   static buildFontPaths(font, glyphs, handler, evaluatorOptions) {
4427     function buildPath(fontChar) {
4428       const glyphName = `${font.loadedName}_path_${fontChar}`;
4429       try {
4430         if (font.renderer.hasBuiltPath(fontChar)) {
4431           return;
4432         }
4433         handler.send("commonobj", [
4434           glyphName,
4435           "FontPath",
4436           font.renderer.getPathJs(fontChar),
4437         ]);
4438       } catch (reason) {
4439         if (evaluatorOptions.ignoreErrors) {
4440           warn(`buildFontPaths - ignoring ${glyphName} glyph: "${reason}".`);
4441           return;
4442         }
4443         throw reason;
4444       }
4445     }
4446 
4447     for (const glyph of glyphs) {
4448       buildPath(glyph.fontChar);
4449 
4450       // If the glyph has an accent we need to build a path for its
4451       // fontChar too, otherwise CanvasGraphics_paintChar will fail.
4452       const accent = glyph.accent;
4453       if (accent?.fontChar) {
4454         buildPath(accent.fontChar);
4455       }
4456     }
4457   }
4458 
4459   static get fallbackFontDict() {
4460     const dict = new Dict();
4461     dict.set("BaseFont", Name.get("Helvetica"));
4462     dict.set("Type", Name.get("FallbackType"));
4463     dict.set("Subtype", Name.get("FallbackType"));
4464     dict.set("Encoding", Name.get("WinAnsiEncoding"));
4465 
4466     return shadow(this, "fallbackFontDict", dict);
4467   }
4468 }
4469 
4470 class TranslatedFont {
4471   constructor({ loadedName, font, dict, evaluatorOptions }) {
4472     this.loadedName = loadedName;
4473     this.font = font;
4474     this.dict = dict;
4475     this._evaluatorOptions = evaluatorOptions || DefaultPartialEvaluatorOptions;
4476     this.type3Loaded = null;
4477     this.type3Dependencies = font.isType3Font ? new Set() : null;
4478     this.sent = false;
4479   }
4480 
4481   send(handler) {
4482     if (this.sent) {
4483       return;
4484     }
4485     this.sent = true;
4486 
4487     handler.send("commonobj", [
4488       this.loadedName,
4489       "Font",
4490       this.font.exportData(this._evaluatorOptions.fontExtraProperties),
4491     ]);
4492   }
4493 
4494   fallback(handler) {
4495     if (!this.font.data) {
4496       return;
4497     }
4498     // When font loading failed, fall back to the built-in font renderer.
4499     this.font.disableFontFace = true;
4500     // An arbitrary number of text rendering operators could have been
4501     // encountered between the point in time when the 'Font' message was sent
4502     // to the main-thread, and the point in time when the 'FontFallback'
4503     // message was received on the worker-thread.
4504     // To ensure that all 'FontPath's are available on the main-thread, when
4505     // font loading failed, attempt to resend *all* previously parsed glyphs.
4506     PartialEvaluator.buildFontPaths(
4507       this.font,
4508       /* glyphs = */ this.font.glyphCacheValues,
4509       handler,
4510       this._evaluatorOptions
4511     );
4512   }
4513 
4514   loadType3Data(evaluator, resources, task) {
4515     if (this.type3Loaded) {
4516       return this.type3Loaded;
4517     }
4518     if (!this.font.isType3Font) {
4519       throw new Error("Must be a Type3 font.");
4520     }
4521     // When parsing Type3 glyphs, always ignore them if there are errors.
4522     // Compared to the parsing of e.g. an entire page, it doesn't really
4523     // make sense to only be able to render a Type3 glyph partially.
4524     const type3Evaluator = evaluator.clone({ ignoreErrors: false });
4525     type3Evaluator.parsingType3Font = true;
4526     // Prevent circular references in Type3 fonts.
4527     const type3FontRefs = new RefSet(evaluator.type3FontRefs);
4528     if (this.dict.objId && !type3FontRefs.has(this.dict.objId)) {
4529       type3FontRefs.put(this.dict.objId);
4530     }
4531     type3Evaluator.type3FontRefs = type3FontRefs;
4532 
4533     const translatedFont = this.font,
4534       type3Dependencies = this.type3Dependencies;
4535     let loadCharProcsPromise = Promise.resolve();
4536     const charProcs = this.dict.get("CharProcs");
4537     const fontResources = this.dict.get("Resources") || resources;
4538     const charProcOperatorList = Object.create(null);
4539 
4540     const fontBBox = Util.normalizeRect(translatedFont.bbox || [0, 0, 0, 0]),
4541       width = fontBBox[2] - fontBBox[0],
4542       height = fontBBox[3] - fontBBox[1];
4543     const fontBBoxSize = Math.hypot(width, height);
4544 
4545     for (const key of charProcs.getKeys()) {
4546       loadCharProcsPromise = loadCharProcsPromise.then(() => {
4547         const glyphStream = charProcs.get(key);
4548         const operatorList = new OperatorList();
4549         return type3Evaluator
4550           .getOperatorList({
4551             stream: glyphStream,
4552             task,
4553             resources: fontResources,
4554             operatorList,
4555           })
4556           .then(() => {
4557             // According to the PDF specification, section "9.6.5 Type 3 Fonts"
4558             // and "Table 113":
4559             //  "A glyph description that begins with the d1 operator should
4560             //   not execute any operators that set the colour (or other
4561             //   colour-related parameters) in the graphics state;
4562             //   any use of such operators shall be ignored."
4563             if (operatorList.fnArray[0] === OPS.setCharWidthAndBounds) {
4564               this._removeType3ColorOperators(operatorList, fontBBoxSize);
4565             }
4566             charProcOperatorList[key] = operatorList.getIR();
4567 
4568             for (const dependency of operatorList.dependencies) {
4569               type3Dependencies.add(dependency);
4570             }
4571           })
4572           .catch(function (reason) {
4573             warn(`Type3 font resource "${key}" is not available.`);
4574             const dummyOperatorList = new OperatorList();
4575             charProcOperatorList[key] = dummyOperatorList.getIR();
4576           });
4577       });
4578     }
4579     this.type3Loaded = loadCharProcsPromise.then(() => {
4580       translatedFont.charProcOperatorList = charProcOperatorList;
4581       if (this._bbox) {
4582         translatedFont.isCharBBox = true;
4583         translatedFont.bbox = this._bbox;
4584       }
4585     });
4586     return this.type3Loaded;
4587   }
4588 
4589   /**
4590    * @private
4591    */
4592   _removeType3ColorOperators(operatorList, fontBBoxSize = NaN) {
4593     if (typeof PDFJSDev === "undefined" || PDFJSDev.test("TESTING")) {
4594       assert(
4595         operatorList.fnArray[0] === OPS.setCharWidthAndBounds,
4596         "Type3 glyph shall start with the d1 operator."
4597       );
4598     }
4599     const charBBox = Util.normalizeRect(operatorList.argsArray[0].slice(2)),
4600       width = charBBox[2] - charBBox[0],
4601       height = charBBox[3] - charBBox[1];
4602     const charBBoxSize = Math.hypot(width, height);
4603 
4604     if (width === 0 || height === 0) {
4605       // Skip the d1 operator when its bounds are bogus (fixes issue14953.pdf).
4606       operatorList.fnArray.splice(0, 1);
4607       operatorList.argsArray.splice(0, 1);
4608     } else if (
4609       fontBBoxSize === 0 ||
4610       Math.round(charBBoxSize / fontBBoxSize) >= 10
4611     ) {
4612       // Override the fontBBox when it's undefined/empty, or when it's at least
4613       // (approximately) one order of magnitude smaller than the charBBox
4614       // (fixes issue14999_reduced.pdf).
4615       if (!this._bbox) {
4616         this._bbox = [Infinity, Infinity, -Infinity, -Infinity];
4617       }
4618       this._bbox[0] = Math.min(this._bbox[0], charBBox[0]);
4619       this._bbox[1] = Math.min(this._bbox[1], charBBox[1]);
4620       this._bbox[2] = Math.max(this._bbox[2], charBBox[2]);
4621       this._bbox[3] = Math.max(this._bbox[3], charBBox[3]);
4622     }
4623 
4624     let i = 0,
4625       ii = operatorList.length;
4626     while (i < ii) {
4627       switch (operatorList.fnArray[i]) {
4628         case OPS.setCharWidthAndBounds:
4629           break; // Handled above.
4630         case OPS.setStrokeColorSpace:
4631         case OPS.setFillColorSpace:
4632         case OPS.setStrokeColor:
4633         case OPS.setStrokeColorN:
4634         case OPS.setFillColor:
4635         case OPS.setFillColorN:
4636         case OPS.setStrokeGray:
4637         case OPS.setFillGray:
4638         case OPS.setStrokeRGBColor:
4639         case OPS.setFillRGBColor:
4640         case OPS.setStrokeCMYKColor:
4641         case OPS.setFillCMYKColor:
4642         case OPS.shadingFill:
4643         case OPS.setRenderingIntent:
4644           operatorList.fnArray.splice(i, 1);
4645           operatorList.argsArray.splice(i, 1);
4646           ii--;
4647           continue;
4648 
4649         case OPS.setGState:
4650           const [gStateObj] = operatorList.argsArray[i];
4651           let j = 0,
4652             jj = gStateObj.length;
4653           while (j < jj) {
4654             const [gStateKey] = gStateObj[j];
4655             switch (gStateKey) {
4656               case "TR":
4657               case "TR2":
4658               case "HT":
4659               case "BG":
4660               case "BG2":
4661               case "UCR":
4662               case "UCR2":
4663                 gStateObj.splice(j, 1);
4664                 jj--;
4665                 continue;
4666             }
4667             j++;
4668           }
4669           break;
4670       }
4671       i++;
4672     }
4673   }
4674 }
4675 
4676 class StateManager {
4677   constructor(initialState = new EvalState()) {
4678     this.state = initialState;
4679     this.stateStack = [];
4680   }
4681 
4682   save() {
4683     const old = this.state;
4684     this.stateStack.push(this.state);
4685     this.state = old.clone();
4686   }
4687 
4688   restore() {
4689     const prev = this.stateStack.pop();
4690     if (prev) {
4691       this.state = prev;
4692     }
4693   }
4694 
4695   transform(args) {
4696     this.state.ctm = Util.transform(this.state.ctm, args);
4697   }
4698 }
4699 
4700 class TextState {
4701   constructor() {
4702     this.ctm = new Float32Array(IDENTITY_MATRIX);
4703     this.fontName = null;
4704     this.fontSize = 0;
4705     this.loadedName = null;
4706     this.font = null;
4707     this.fontMatrix = FONT_IDENTITY_MATRIX;
4708     this.textMatrix = IDENTITY_MATRIX.slice();
4709     this.textLineMatrix = IDENTITY_MATRIX.slice();
4710     this.charSpacing = 0;
4711     this.wordSpacing = 0;
4712     this.leading = 0;
4713     this.textHScale = 1;
4714     this.textRise = 0;
4715   }
4716 
4717   setTextMatrix(a, b, c, d, e, f) {
4718     const m = this.textMatrix;
4719     m[0] = a;
4720     m[1] = b;
4721     m[2] = c;
4722     m[3] = d;
4723     m[4] = e;
4724     m[5] = f;
4725   }
4726 
4727   setTextLineMatrix(a, b, c, d, e, f) {
4728     const m = this.textLineMatrix;
4729     m[0] = a;
4730     m[1] = b;
4731     m[2] = c;
4732     m[3] = d;
4733     m[4] = e;
4734     m[5] = f;
4735   }
4736 
4737   translateTextMatrix(x, y) {
4738     const m = this.textMatrix;
4739     m[4] = m[0] * x + m[2] * y + m[4];
4740     m[5] = m[1] * x + m[3] * y + m[5];
4741   }
4742 
4743   translateTextLineMatrix(x, y) {
4744     const m = this.textLineMatrix;
4745     m[4] = m[0] * x + m[2] * y + m[4];
4746     m[5] = m[1] * x + m[3] * y + m[5];
4747   }
4748 
4749   carriageReturn() {
4750     this.translateTextLineMatrix(0, -this.leading);
4751     this.textMatrix = this.textLineMatrix.slice();
4752   }
4753 
4754   clone() {
4755     const clone = Object.create(this);
4756     clone.textMatrix = this.textMatrix.slice();
4757     clone.textLineMatrix = this.textLineMatrix.slice();
4758     clone.fontMatrix = this.fontMatrix.slice();
4759     return clone;
4760   }
4761 }
4762 
4763 class EvalState {
4764   constructor() {
4765     this.ctm = new Float32Array(IDENTITY_MATRIX);
4766     this.font = null;
4767     this.textRenderingMode = TextRenderingMode.FILL;
4768     this.fillColorSpace = ColorSpace.singletons.gray;
4769     this.strokeColorSpace = ColorSpace.singletons.gray;
4770   }
4771 
4772   clone() {
4773     return Object.create(this);
4774   }
4775 }
4776 
4777 class EvaluatorPreprocessor {
4778   static get opMap() {
4779     // Specifies properties for each command
4780     //
4781     // If variableArgs === true: [0, `numArgs`] expected
4782     // If variableArgs === false: exactly `numArgs` expected
4783     return shadow(this, "opMap", {
4784       // Graphic state
4785       w: { id: OPS.setLineWidth, numArgs: 1, variableArgs: false },
4786       J: { id: OPS.setLineCap, numArgs: 1, variableArgs: false },
4787       j: { id: OPS.setLineJoin, numArgs: 1, variableArgs: false },
4788       M: { id: OPS.setMiterLimit, numArgs: 1, variableArgs: false },
4789       d: { id: OPS.setDash, numArgs: 2, variableArgs: false },
4790       ri: { id: OPS.setRenderingIntent, numArgs: 1, variableArgs: false },
4791       i: { id: OPS.setFlatness, numArgs: 1, variableArgs: false },
4792       gs: { id: OPS.setGState, numArgs: 1, variableArgs: false },
4793       q: { id: OPS.save, numArgs: 0, variableArgs: false },
4794       Q: { id: OPS.restore, numArgs: 0, variableArgs: false },
4795       cm: { id: OPS.transform, numArgs: 6, variableArgs: false },
4796 
4797       // Path
4798       m: { id: OPS.moveTo, numArgs: 2, variableArgs: false },
4799       l: { id: OPS.lineTo, numArgs: 2, variableArgs: false },
4800       c: { id: OPS.curveTo, numArgs: 6, variableArgs: false },
4801       v: { id: OPS.curveTo2, numArgs: 4, variableArgs: false },
4802       y: { id: OPS.curveTo3, numArgs: 4, variableArgs: false },
4803       h: { id: OPS.closePath, numArgs: 0, variableArgs: false },
4804       re: { id: OPS.rectangle, numArgs: 4, variableArgs: false },
4805       S: { id: OPS.stroke, numArgs: 0, variableArgs: false },
4806       s: { id: OPS.closeStroke, numArgs: 0, variableArgs: false },
4807       f: { id: OPS.fill, numArgs: 0, variableArgs: false },
4808       F: { id: OPS.fill, numArgs: 0, variableArgs: false },
4809       "f*": { id: OPS.eoFill, numArgs: 0, variableArgs: false },
4810       B: { id: OPS.fillStroke, numArgs: 0, variableArgs: false },
4811       "B*": { id: OPS.eoFillStroke, numArgs: 0, variableArgs: false },
4812       b: { id: OPS.closeFillStroke, numArgs: 0, variableArgs: false },
4813       "b*": { id: OPS.closeEOFillStroke, numArgs: 0, variableArgs: false },
4814       n: { id: OPS.endPath, numArgs: 0, variableArgs: false },
4815 
4816       // Clipping
4817       W: { id: OPS.clip, numArgs: 0, variableArgs: false },
4818       "W*": { id: OPS.eoClip, numArgs: 0, variableArgs: false },
4819 
4820       // Text
4821       BT: { id: OPS.beginText, numArgs: 0, variableArgs: false },
4822       ET: { id: OPS.endText, numArgs: 0, variableArgs: false },
4823       Tc: { id: OPS.setCharSpacing, numArgs: 1, variableArgs: false },
4824       Tw: { id: OPS.setWordSpacing, numArgs: 1, variableArgs: false },
4825       Tz: { id: OPS.setHScale, numArgs: 1, variableArgs: false },
4826       TL: { id: OPS.setLeading, numArgs: 1, variableArgs: false },
4827       Tf: { id: OPS.setFont, numArgs: 2, variableArgs: false },
4828       Tr: { id: OPS.setTextRenderingMode, numArgs: 1, variableArgs: false },
4829       Ts: { id: OPS.setTextRise, numArgs: 1, variableArgs: false },
4830       Td: { id: OPS.moveText, numArgs: 2, variableArgs: false },
4831       TD: { id: OPS.setLeadingMoveText, numArgs: 2, variableArgs: false },
4832       Tm: { id: OPS.setTextMatrix, numArgs: 6, variableArgs: false },
4833       "T*": { id: OPS.nextLine, numArgs: 0, variableArgs: false },
4834       Tj: { id: OPS.showText, numArgs: 1, variableArgs: false },
4835       TJ: { id: OPS.showSpacedText, numArgs: 1, variableArgs: false },
4836       "'": { id: OPS.nextLineShowText, numArgs: 1, variableArgs: false },
4837       '"': {
4838         id: OPS.nextLineSetSpacingShowText,
4839         numArgs: 3,
4840         variableArgs: false,
4841       },
4842 
4843       // Type3 fonts
4844       d0: { id: OPS.setCharWidth, numArgs: 2, variableArgs: false },
4845       d1: {
4846         id: OPS.setCharWidthAndBounds,
4847         numArgs: 6,
4848         variableArgs: false,
4849       },
4850 
4851       // Color
4852       CS: { id: OPS.setStrokeColorSpace, numArgs: 1, variableArgs: false },
4853       cs: { id: OPS.setFillColorSpace, numArgs: 1, variableArgs: false },
4854       SC: { id: OPS.setStrokeColor, numArgs: 4, variableArgs: true },
4855       SCN: { id: OPS.setStrokeColorN, numArgs: 33, variableArgs: true },
4856       sc: { id: OPS.setFillColor, numArgs: 4, variableArgs: true },
4857       scn: { id: OPS.setFillColorN, numArgs: 33, variableArgs: true },
4858       G: { id: OPS.setStrokeGray, numArgs: 1, variableArgs: false },
4859       g: { id: OPS.setFillGray, numArgs: 1, variableArgs: false },
4860       RG: { id: OPS.setStrokeRGBColor, numArgs: 3, variableArgs: false },
4861       rg: { id: OPS.setFillRGBColor, numArgs: 3, variableArgs: false },
4862       K: { id: OPS.setStrokeCMYKColor, numArgs: 4, variableArgs: false },
4863       k: { id: OPS.setFillCMYKColor, numArgs: 4, variableArgs: false },
4864 
4865       // Shading
4866       sh: { id: OPS.shadingFill, numArgs: 1, variableArgs: false },
4867 
4868       // Images
4869       BI: { id: OPS.beginInlineImage, numArgs: 0, variableArgs: false },
4870       ID: { id: OPS.beginImageData, numArgs: 0, variableArgs: false },
4871       EI: { id: OPS.endInlineImage, numArgs: 1, variableArgs: false },
4872 
4873       // XObjects
4874       Do: { id: OPS.paintXObject, numArgs: 1, variableArgs: false },
4875       MP: { id: OPS.markPoint, numArgs: 1, variableArgs: false },
4876       DP: { id: OPS.markPointProps, numArgs: 2, variableArgs: false },
4877       BMC: { id: OPS.beginMarkedContent, numArgs: 1, variableArgs: false },
4878       BDC: {
4879         id: OPS.beginMarkedContentProps,
4880         numArgs: 2,
4881         variableArgs: false,
4882       },
4883       EMC: { id: OPS.endMarkedContent, numArgs: 0, variableArgs: false },
4884 
4885       // Compatibility
4886       BX: { id: OPS.beginCompat, numArgs: 0, variableArgs: false },
4887       EX: { id: OPS.endCompat, numArgs: 0, variableArgs: false },
4888 
4889       // (reserved partial commands for the lexer)
4890       BM: null,
4891       BD: null,
4892       true: null,
4893       fa: null,
4894       fal: null,
4895       fals: null,
4896       false: null,
4897       nu: null,
4898       nul: null,
4899       null: null,
4900     });
4901   }
4902 
4903   static MAX_INVALID_PATH_OPS = 10;
4904 
4905   constructor(stream, xref, stateManager = new StateManager()) {
4906     // TODO(mduan): pass array of knownCommands rather than this.opMap
4907     // dictionary
4908     this.parser = new Parser({
4909       lexer: new Lexer(stream, EvaluatorPreprocessor.opMap),
4910       xref,
4911     });
4912     this.stateManager = stateManager;
4913     this.nonProcessedArgs = [];
4914     this._isPathOp = false;
4915     this._numInvalidPathOPS = 0;
4916   }
4917 
4918   get savedStatesDepth() {
4919     return this.stateManager.stateStack.length;
4920   }
4921 
4922   // |operation| is an object with two fields:
4923   //
4924   // - |fn| is an out param.
4925   //
4926   // - |args| is an inout param. On entry, it should have one of two values.
4927   //
4928   //   - An empty array. This indicates that the caller is providing the
4929   //     array in which the args will be stored in. The caller should use
4930   //     this value if it can reuse a single array for each call to read().
4931   //
4932   //   - |null|. This indicates that the caller needs this function to create
4933   //     the array in which any args are stored in. If there are zero args,
4934   //     this function will leave |operation.args| as |null| (thus avoiding
4935   //     allocations that would occur if we used an empty array to represent
4936   //     zero arguments). Otherwise, it will replace |null| with a new array
4937   //     containing the arguments. The caller should use this value if it
4938   //     cannot reuse an array for each call to read().
4939   //
4940   // These two modes are present because this function is very hot and so
4941   // avoiding allocations where possible is worthwhile.
4942   //
4943   read(operation) {
4944     let args = operation.args;
4945     while (true) {
4946       const obj = this.parser.getObj();
4947       if (obj instanceof Cmd) {
4948         const cmd = obj.cmd;
4949         // Check that the command is valid
4950         const opSpec = EvaluatorPreprocessor.opMap[cmd];
4951         if (!opSpec) {
4952           warn(`Unknown command "${cmd}".`);
4953           continue;
4954         }
4955 
4956         const fn = opSpec.id;
4957         const numArgs = opSpec.numArgs;
4958         let argsLength = args !== null ? args.length : 0;
4959 
4960         // If the *previous* command wasn't a path operator, reset the heuristic
4961         // used with incomplete path operators below (fixes issue14917.pdf).
4962         if (!this._isPathOp) {
4963           this._numInvalidPathOPS = 0;
4964         }
4965         this._isPathOp = fn >= OPS.moveTo && fn <= OPS.endPath;
4966 
4967         if (!opSpec.variableArgs) {
4968           // Postscript commands can be nested, e.g. /F2 /GS2 gs 5.711 Tf
4969           if (argsLength !== numArgs) {
4970             const nonProcessedArgs = this.nonProcessedArgs;
4971             while (argsLength > numArgs) {
4972               nonProcessedArgs.push(args.shift());
4973               argsLength--;
4974             }
4975             while (argsLength < numArgs && nonProcessedArgs.length !== 0) {
4976               if (args === null) {
4977                 args = [];
4978               }
4979               args.unshift(nonProcessedArgs.pop());
4980               argsLength++;
4981             }
4982           }
4983 
4984           if (argsLength < numArgs) {
4985             const partialMsg =
4986               `command ${cmd}: expected ${numArgs} args, ` +
4987               `but received ${argsLength} args.`;
4988 
4989             // Incomplete path operators, in particular, can result in fairly
4990             // chaotic rendering artifacts. Hence the following heuristics is
4991             // used to error, rather than just warn, once a number of invalid
4992             // path operators have been encountered (fixes bug1443140.pdf).
4993             if (
4994               this._isPathOp &&
4995               ++this._numInvalidPathOPS >
4996                 EvaluatorPreprocessor.MAX_INVALID_PATH_OPS
4997             ) {
4998               throw new FormatError(`Invalid ${partialMsg}`);
4999             }
5000             // If we receive too few arguments, it's not possible to execute
5001             // the command, hence we skip the command.
5002             warn(`Skipping ${partialMsg}`);
5003             if (args !== null) {
5004               args.length = 0;
5005             }
5006             continue;
5007           }
5008         } else if (argsLength > numArgs) {
5009           info(
5010             `Command ${cmd}: expected [0, ${numArgs}] args, ` +
5011               `but received ${argsLength} args.`
5012           );
5013         }
5014 
5015         // TODO figure out how to type-check vararg functions
5016         this.preprocessCommand(fn, args);
5017 
5018         operation.fn = fn;
5019         operation.args = args;
5020         return true;
5021       }
5022       if (obj === EOF) {
5023         return false; // no more commands
5024       }
5025       // argument
5026       if (obj !== null) {
5027         if (args === null) {
5028           args = [];
5029         }
5030         args.push(obj);
5031         if (args.length > 33) {
5032           throw new FormatError("Too many arguments");
5033         }
5034       }
5035     }
5036   }
5037 
5038   preprocessCommand(fn, args) {
5039     switch (fn | 0) {
5040       case OPS.save:
5041         this.stateManager.save();
5042         break;
5043       case OPS.restore:
5044         this.stateManager.restore();
5045         break;
5046       case OPS.transform:
5047         this.stateManager.transform(args);
5048         break;
5049     }
5050   }
5051 }
5052 
5053 export { EvaluatorPreprocessor, PartialEvaluator };
</code>

Test file:
<test_file>
File:
test/unit/evaluator_spec.js
/* Copyright 2017 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import { createIdFactory, XRefMock } from "./test_utils.js";
import { Dict, Name } from "../../src/core/primitives.js";
import { FormatError, OPS } from "../../src/shared/util.js";
import { Stream, StringStream } from "../../src/core/stream.js";
import { OperatorList } from "../../src/core/operator_list.js";
import { PartialEvaluator } from "../../src/core/evaluator.js";
import { WorkerTask } from "../../src/core/worker.js";
</test_file>

Your task:
You are a software tester at pdf.js.
1. Examine the existing test file. You may reuse any imports, helpers or setup blocks it already has.
2. Write exactly one javascript test `it("...", async () => {...})` block.
3. Your test must fail on the code before the patch, and pass after, hence the test will verify that the patch resolves the issue.
4. The test must be self-contained and to-the-point.
5. If you need something new use only the provided imports (respect the paths exactly how they are given) by importing dynamically for compatibility with Node.js — no new dependencies. You can use the PDF file for testing as follows:
const { getDocument } = await import('../../src/display/api.js');
const { buildGetDocumentParams } = await import('./test_utils.js');
const loadingTask = getDocument(buildGetDocumentParams('issue17554.pdf'))
6. Return only the javascript code for the new `it(...)` block (no comments or explanations).

Example structure:
it("should <describe behavior>", async () => {
  const { example } = await import("../../src/core/example.js");
  <initialize required variables>;
  <define expected variable>;
  <generate actual variables>;
  <compare expected with actual>;
});

