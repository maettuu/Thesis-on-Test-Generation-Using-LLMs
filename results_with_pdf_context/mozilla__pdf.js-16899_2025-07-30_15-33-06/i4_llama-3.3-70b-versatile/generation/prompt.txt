Before you begin:
- Keep going until the job is completely solved — don’t stop halfway.
- If you’re unsure about the behavior, reread the provided patch carefully; do not hallucinate.
- Plan your approach before writing code by reflecting on whether the test truly fails before and passes after.

Issue:
<issue>
FreeText annotation isn't displayed
</issue>

PDF File:
<pdf>
bug1851498.pdf
</pdf>

Patch:
<patch>
diff --git a/src/display/annotation_layer.js b/src/display/annotation_layer.js
--- a/src/display/annotation_layer.js
+++ b/src/display/annotation_layer.js
@@ -190,6 +190,14 @@ class AnnotationElement {
     }
   }
 
+  static _hasPopupData({ titleObj, contentsObj, richText }) {
+    return !!(titleObj?.str || contentsObj?.str || richText?.str);
+  }
+
+  get hasPopupData() {
+    return AnnotationElement._hasPopupData(this.data);
+  }
+
   /**
    * Create an empty container for the annotation's HTML element.
    *
@@ -956,13 +964,7 @@ class LinkAnnotationElement extends AnnotationElement {
 
 class TextAnnotationElement extends AnnotationElement {
   constructor(parameters) {
-    const isRenderable = !!(
-      parameters.data.popupRef ||
-      parameters.data.titleObj?.str ||
-      parameters.data.contentsObj?.str ||
-      parameters.data.richText?.str
-    );
-    super(parameters, { isRenderable });
+    super(parameters, { isRenderable: true });
   }
 
   render() {
@@ -978,7 +980,7 @@ class TextAnnotationElement extends AnnotationElement {
     image.dataset.l10nId = "text_annotation_type";
     image.dataset.l10nArgs = JSON.stringify({ type: this.data.name });
 
-    if (!this.data.popupRef) {
+    if (!this.data.popupRef && this.hasPopupData) {
       this._createPopup();
     }
 
@@ -1927,12 +1929,7 @@ class ChoiceWidgetAnnotationElement extends WidgetAnnotationElement {
 class PopupAnnotationElement extends AnnotationElement {
   constructor(parameters) {
     const { data, elements } = parameters;
-    const isRenderable = !!(
-      data.titleObj?.str ||
-      data.contentsObj?.str ||
-      data.richText?.str
-    );
-    super(parameters, { isRenderable });
+    super(parameters, { isRenderable: AnnotationElement._hasPopupData(data) });
     this.elements = elements;
   }
 
@@ -2044,9 +2041,7 @@ class PopupElement {
       element.addEventListener("click", this.#boundToggle);
       element.addEventListener("mouseenter", this.#boundShow);
       element.addEventListener("mouseleave", this.#boundHide);
-      if (typeof PDFJSDev !== "undefined" && PDFJSDev.test("TESTING")) {
-        element.classList.add("popupTriggerArea");
-      }
+      element.classList.add("popupTriggerArea");
     }
 
     // Attach the event listener to toggle the popup with the keyboard.
@@ -2275,13 +2270,7 @@ class PopupElement {
 
 class FreeTextAnnotationElement extends AnnotationElement {
   constructor(parameters) {
-    const isRenderable = !!(
-      parameters.data.popupRef ||
-      parameters.data.titleObj?.str ||
-      parameters.data.contentsObj?.str ||
-      parameters.data.richText?.str
-    );
-    super(parameters, { isRenderable, ignoreBorder: true });
+    super(parameters, { isRenderable: true, ignoreBorder: true });
     this.textContent = parameters.data.textContent;
     this.textPosition = parameters.data.textPosition;
     this.annotationEditorType = AnnotationEditorType.FREETEXT;
@@ -2302,7 +2291,7 @@ class FreeTextAnnotationElement extends AnnotationElement {
       this.container.append(content);
     }
 
-    if (!this.data.popupRef) {
+    if (!this.data.popupRef && this.hasPopupData) {
       this._createPopup();
     }
 
@@ -2316,13 +2305,7 @@ class LineAnnotationElement extends AnnotationElement {
   #line = null;
 
   constructor(parameters) {
-    const isRenderable = !!(
-      parameters.data.popupRef ||
-      parameters.data.titleObj?.str ||
-      parameters.data.contentsObj?.str ||
-      parameters.data.richText?.str
-    );
-    super(parameters, { isRenderable, ignoreBorder: true });
+    super(parameters, { isRenderable: true, ignoreBorder: true });
   }
 
   render() {
@@ -2357,7 +2340,7 @@ class LineAnnotationElement extends AnnotationElement {
 
     // Create the popup ourselves so that we can bind it to the line instead
     // of to the entire container (which is the default).
-    if (!data.popupRef) {
+    if (!data.popupRef && this.hasPopupData) {
       this._createPopup();
     }
 
@@ -2377,13 +2360,7 @@ class SquareAnnotationElement extends AnnotationElement {
   #square = null;
 
   constructor(parameters) {
-    const isRenderable = !!(
-      parameters.data.popupRef ||
-      parameters.data.titleObj?.str ||
-      parameters.data.contentsObj?.str ||
-      parameters.data.richText?.str
-    );
-    super(parameters, { isRenderable, ignoreBorder: true });
+    super(parameters, { isRenderable: true, ignoreBorder: true });
   }
 
   render() {
@@ -2420,7 +2397,7 @@ class SquareAnnotationElement extends AnnotationElement {
 
     // Create the popup ourselves so that we can bind it to the square instead
     // of to the entire container (which is the default).
-    if (!data.popupRef) {
+    if (!data.popupRef && this.hasPopupData) {
       this._createPopup();
     }
 
@@ -2440,13 +2417,7 @@ class CircleAnnotationElement extends AnnotationElement {
   #circle = null;
 
   constructor(parameters) {
-    const isRenderable = !!(
-      parameters.data.popupRef ||
-      parameters.data.titleObj?.str ||
-      parameters.data.contentsObj?.str ||
-      parameters.data.richText?.str
-    );
-    super(parameters, { isRenderable, ignoreBorder: true });
+    super(parameters, { isRenderable: true, ignoreBorder: true });
   }
 
   render() {
@@ -2484,7 +2455,7 @@ class CircleAnnotationElement extends AnnotationElement {
 
     // Create the popup ourselves so that we can bind it to the circle instead
     // of to the entire container (which is the default).
-    if (!data.popupRef) {
+    if (!data.popupRef && this.hasPopupData) {
       this._createPopup();
     }
 
@@ -2504,13 +2475,7 @@ class PolylineAnnotationElement extends AnnotationElement {
   #polyline = null;
 
   constructor(parameters) {
-    const isRenderable = !!(
-      parameters.data.popupRef ||
-      parameters.data.titleObj?.str ||
-      parameters.data.contentsObj?.str ||
-      parameters.data.richText?.str
-    );
-    super(parameters, { isRenderable, ignoreBorder: true });
+    super(parameters, { isRenderable: true, ignoreBorder: true });
 
     this.containerClassName = "polylineAnnotation";
     this.svgElementName = "svg:polyline";
@@ -2557,8 +2522,8 @@ class PolylineAnnotationElement extends AnnotationElement {
 
     // Create the popup ourselves so that we can bind it to the polyline
     // instead of to the entire container (which is the default).
-    if (!data.popupRef) {
-      this._createPopup(polyline, data);
+    if (!data.popupRef && this.hasPopupData) {
+      this._createPopup();
     }
 
     return this.container;
@@ -2585,19 +2550,13 @@ class PolygonAnnotationElement extends PolylineAnnotationElement {
 
 class CaretAnnotationElement extends AnnotationElement {
   constructor(parameters) {
-    const isRenderable = !!(
-      parameters.data.popupRef ||
-      parameters.data.titleObj?.str ||
-      parameters.data.contentsObj?.str ||
-      parameters.data.richText?.str
-    );
-    super(parameters, { isRenderable, ignoreBorder: true });
+    super(parameters, { isRenderable: true, ignoreBorder: true });
   }
 
   render() {
     this.container.classList.add("caretAnnotation");
 
-    if (!this.data.popupRef) {
+    if (!this.data.popupRef && this.hasPopupData) {
       this._createPopup();
     }
     return this.container;
@@ -2608,13 +2567,7 @@ class InkAnnotationElement extends AnnotationElement {
   #polylines = [];
 
   constructor(parameters) {
-    const isRenderable = !!(
-      parameters.data.popupRef ||
-      parameters.data.titleObj?.str ||
-      parameters.data.contentsObj?.str ||
-      parameters.data.richText?.str
-    );
-    super(parameters, { isRenderable, ignoreBorder: true });
+    super(parameters, { isRenderable: true, ignoreBorder: true });
 
     this.containerClassName = "inkAnnotation";
 
@@ -2661,8 +2614,8 @@ class InkAnnotationElement extends AnnotationElement {
 
       // Create the popup ourselves so that we can bind it to the polyline
       // instead of to the entire container (which is the default).
-      if (!data.popupRef) {
-        this._createPopup(polyline, data);
+      if (!data.popupRef && this.hasPopupData) {
+        this._createPopup();
       }
 
       svg.append(polyline);
@@ -2683,21 +2636,15 @@ class InkAnnotationElement extends AnnotationElement {
 
 class HighlightAnnotationElement extends AnnotationElement {
   constructor(parameters) {
-    const isRenderable = !!(
-      parameters.data.popupRef ||
-      parameters.data.titleObj?.str ||
-      parameters.data.contentsObj?.str ||
-      parameters.data.richText?.str
-    );
     super(parameters, {
-      isRenderable,
+      isRenderable: true,
       ignoreBorder: true,
       createQuadrilaterals: true,
     });
   }
 
   render() {
-    if (!this.data.popupRef) {
+    if (!this.data.popupRef && this.hasPopupData) {
       this._createPopup();
     }
 
@@ -2708,21 +2655,15 @@ class HighlightAnnotationElement extends AnnotationElement {
 
 class UnderlineAnnotationElement extends AnnotationElement {
   constructor(parameters) {
-    const isRenderable = !!(
-      parameters.data.popupRef ||
-      parameters.data.titleObj?.str ||
-      parameters.data.contentsObj?.str ||
-      parameters.data.richText?.str
-    );
     super(parameters, {
-      isRenderable,
+      isRenderable: true,
       ignoreBorder: true,
       createQuadrilaterals: true,
     });
   }
 
   render() {
-    if (!this.data.popupRef) {
+    if (!this.data.popupRef && this.hasPopupData) {
       this._createPopup();
     }
 
@@ -2733,21 +2674,15 @@ class UnderlineAnnotationElement extends AnnotationElement {
 
 class SquigglyAnnotationElement extends AnnotationElement {
   constructor(parameters) {
-    const isRenderable = !!(
-      parameters.data.popupRef ||
-      parameters.data.titleObj?.str ||
-      parameters.data.contentsObj?.str ||
-      parameters.data.richText?.str
-    );
     super(parameters, {
-      isRenderable,
+      isRenderable: true,
       ignoreBorder: true,
       createQuadrilaterals: true,
     });
   }
 
   render() {
-    if (!this.data.popupRef) {
+    if (!this.data.popupRef && this.hasPopupData) {
       this._createPopup();
     }
 
@@ -2758,21 +2693,15 @@ class SquigglyAnnotationElement extends AnnotationElement {
 
 class StrikeOutAnnotationElement extends AnnotationElement {
   constructor(parameters) {
-    const isRenderable = !!(
-      parameters.data.popupRef ||
-      parameters.data.titleObj?.str ||
-      parameters.data.contentsObj?.str ||
-      parameters.data.richText?.str
-    );
     super(parameters, {
-      isRenderable,
+      isRenderable: true,
       ignoreBorder: true,
       createQuadrilaterals: true,
     });
   }
 
   render() {
-    if (!this.data.popupRef) {
+    if (!this.data.popupRef && this.hasPopupData) {
       this._createPopup();
     }
 
@@ -2783,19 +2712,13 @@ class StrikeOutAnnotationElement extends AnnotationElement {
 
 class StampAnnotationElement extends AnnotationElement {
   constructor(parameters) {
-    const isRenderable = !!(
-      parameters.data.popupRef ||
-      parameters.data.titleObj?.str ||
-      parameters.data.contentsObj?.str ||
-      parameters.data.richText?.str
-    );
-    super(parameters, { isRenderable, ignoreBorder: true });
+    super(parameters, { isRenderable: true, ignoreBorder: true });
   }
 
   render() {
     this.container.classList.add("stampAnnotation");
 
-    if (!this.data.popupRef) {
+    if (!this.data.popupRef && this.hasPopupData) {
       this._createPopup();
     }
     return this.container;
@@ -2847,15 +2770,13 @@ class FileAttachmentAnnotationElement extends AnnotationElement {
         }
       }
     }
-    trigger.classList.add("popupTriggerArea");
     trigger.addEventListener("dblclick", this._download.bind(this));
     this.#trigger = trigger;
 
-    if (
-      !data.popupRef &&
-      (data.titleObj?.str || data.contentsObj?.str || data.richText)
-    ) {
+    if (!data.popupRef && this.hasPopupData) {
       this._createPopup();
+    } else {
+      trigger.classList.add("popupTriggerArea");
     }
 
     this.container.append(trigger);


</patch>

Imports:
<imports>
Available Packages
Dev Dependencies:
- @babel/core: ^7.22.11
- @babel/plugin-transform-modules-commonjs: ^7.22.11
- @babel/preset-env: ^7.22.14
- @babel/runtime: ^7.22.11
- @javascript-obfuscator/escodegen: 2.3.0
- acorn: ^8.10.0
- autoprefixer: ^10.4.15
- babel-loader: ^9.1.3
- caniuse-lite: ^1.0.30001525
- canvas: ^2.11.2
- core-js: ^3.32.1
- cross-env: ^7.0.3
- es-module-shims: 1.4.7
- eslint: ^8.48.0
- eslint-config-prettier: ^8.10.0
- eslint-plugin-fetch-options: ^0.0.5
- eslint-plugin-html: ^7.1.0
- eslint-plugin-import: ^2.28.1
- eslint-plugin-json: ^3.1.0
- eslint-plugin-mozilla: ^3.1.0
- eslint-plugin-no-unsanitized: ^4.0.2
- eslint-plugin-prettier: ^5.0.0
- eslint-plugin-sort-exports: ^0.8.0
- eslint-plugin-unicorn: ^48.0.1
- globals: ^13.21.0
- gulp: ^4.0.2
- gulp-postcss: ^9.0.1
- gulp-rename: ^2.0.0
- gulp-replace: ^1.1.4
- gulp-zip: ^5.1.0
- jasmine: ^5.1.0
- jsdoc: ^4.0.2
- jstransformer-markdown-it: ^3.0.0
- merge-stream: ^2.0.0
- mkdirp: ^3.0.1
- needle: ^3.2.0
- path2d-polyfill: ^2.0.1
- pngjs: ^7.0.0
- postcss: ^8.4.29
- postcss-dir-pseudo-class: ^8.0.0
- postcss-nesting: ^12.0.1
- prettier: ^3.0.3
- puppeteer: ^21.1.1
- rimraf: ^3.0.2
- streamqueue: ^1.1.2
- stylelint: ^15.10.3
- stylelint-prettier: ^4.0.2
- terser: ^5.19.3
- through2: ^4.0.2
- tsc-alias: ^1.8.7
- ttest: ^4.0.0
- typescript: ^5.2.2
- typogr: ^0.6.8
- vinyl: ^3.0.0
- webpack: ^5.88.2
- webpack-stream: ^7.0.0
- wintersmith: ^2.5.0
- yargs: ^17.7.2

Engines:
- node: >=18

Available Relative Imports:
- `../../src/core/annotation.js`: Annotation, AnnotationBorderStyle, AnnotationFactory, MarkupAnnotation, getQuadPoints
- `../../src/core/bidi.js`: bidi
- `../../src/core/cff_parser.js`: CFFCharset, CFFCompiler, CFFFDSelect, CFFParser, CFFStrings
- `../../src/core/cmap.js`: CMap, CMapFactory, IdentityCMap
- `../../src/core/colorspace.js`: ColorSpace
- `../../src/core/core_utils.js`: arrayBuffersToBytes, encodeToXmlString, escapePDFName, escapeString, getInheritableProperty, isAscii, isWhiteSpace, log2, numberToString, parseXFAPath, recoverJsURL, stringToUTF16HexString, stringToUTF16String, toRomanNumerals, validateCSSFont
- `../../src/core/crypto.js`: AES128Cipher, AES256Cipher, ARCFourCipher, CipherTransformFactory, PDF17, PDF20, calculateMD5, calculateSHA256, calculateSHA384, calculateSHA512
- `../../src/core/default_appearance.js`: createDefaultAppearance, parseAppearanceStream, parseDefaultAppearance
- `../../src/core/document.js`: PDFDocument, Page
- `../../src/core/encodings.js`: getEncoding
- `../../src/core/evaluator.js`: PartialEvaluator
- `../../src/core/font_substitutions.js`: getFontSubstitution
- `../../src/core/fonts_utils.js`: SEAC_ANALYSIS_ENABLED
- `../../src/core/function.js`: PDFFunctionFactory, PostScriptCompiler, PostScriptEvaluator
- `../../src/core/glyphlist.js`: getDingbatsGlyphsUnicode, getGlyphsUnicode
- `../../src/core/image_utils.js`: GlobalImageCache, LocalColorSpaceCache
- `../../src/core/jbig2.js`: Jbig2Image
- `../../src/core/jpg.js`: JpegImage
- `../../src/core/jpx.js`: JpxImage
- `../../src/core/metadata_parser.js`: MetadataParser
- `../../src/core/operator_list.js`: OperatorList
- `../../src/core/parser.js`: Lexer, Linearization, Parser
- `../../src/core/predictor_stream.js`: PredictorStream
- `../../src/core/primitives.js`: Cmd, Dict, EOF, Name, Ref, RefSet, RefSetCache, isCmd, isDict, isName, isRefsEqual
- `../../src/core/ps_parser.js`: PostScriptLexer, PostScriptParser
- `../../src/core/stream.js`: NullStream, Stream, StringStream
- `../../src/core/type1_parser.js`: Type1Parser
- `../../src/core/unicode.js`: getCharUnicodeCategory, getUnicodeForGlyph, getUnicodeRangeFor, mapSpecialUnicodeValues
- `../../src/core/worker.js`: WorkerMessageHandler, WorkerTask
- `../../src/core/writer.js`: incrementalUpdate, writeDict
- `../../src/core/xfa/bind.js`: Binder
- `../../src/core/xfa/data.js`: DataHandler
- `../../src/core/xfa/factory.js`: XFAFactory
- `../../src/core/xfa/formcalc_lexer.js`: Lexer, TOKEN, Token
- `../../src/core/xfa/formcalc_parser.js`: Errors, Parser
- `../../src/core/xfa/parser.js`: XFAParser
- `../../src/core/xfa/som.js`: searchNode
- `../../src/core/xfa/symbol_utils.js`: $dump, $getChildren, $getChildrenByClass, $getChildrenByName, $text, $uid
- `../../src/core/xml_parser.js`: SimpleXMLParser, XMLParserBase
- `../../src/display/annotation_layer.js`: AnnotationLayer
- `../../src/display/annotation_storage.js`: AnnotationStorage
- `../../src/display/api.js`: DefaultCMapReaderFactory, DefaultCanvasFactory, DefaultStandardFontDataFactory, LoopbackPort, PDFDataRangeTransport, PDFDocumentLoadingTask, PDFDocumentProxy, PDFPageProxy, PDFWorker, PDFWorkerUtil, RenderTask, SVGGraphics, build, getDocument, version
- `../../src/display/display_utils.js`: DOMCanvasFactory, DOMSVGFactory, PDFDateString, PageViewport, PixelsPerInch, RenderingCancelledException, StatTimer, getFilenameFromUrl, getPdfFilenameFromUrl, getXfaPageViewport, isDataScheme, isPdfFile, isValidFetchUrl, loadScript, setLayerDimensions
- `../../src/display/editor/annotation_editor_layer.js`: AnnotationEditorLayer
- `../../src/display/editor/tools.js`: AnnotationEditorUIManager, CommandManager
- `../../src/display/fetch_stream.js`: PDFFetchStream
- `../../src/display/metadata.js`: Metadata
- `../../src/display/network.js`: PDFNetworkStream
- `../../src/display/network_utils.js`: createResponseStatusError, extractFilenameFromHeader, validateRangeRequestCapabilities, validateResponseStatus
- `../../src/display/node_stream.js`: PDFNodeStream
- `../../src/display/svg.js`: SVGGraphics
- `../../src/display/text_layer.js`: TextLayerRenderTask, renderTextLayer, updateTextLayer
- `../../src/display/worker_options.js`: GlobalWorkerOptions
- `../../src/display/xfa_layer.js`: XfaLayer
- `../../src/shared/message_handler.js`: MessageHandler
- `../../src/shared/murmurhash3.js`: MurmurHash3_64
- `../../src/shared/util.js`: AbortException, AnnotationBorderStyleType, AnnotationEditorParamsType, AnnotationEditorType, AnnotationFieldFlag, AnnotationFlag, AnnotationMode, AnnotationType, CMapCompressionType, FeatureTest, FormatError, ImageKind, InvalidPDFException, MissingPDFException, OPS, PasswordException, PasswordResponses, PermissionFlag, PromiseCapability, RenderingIntentFlag, UnexpectedResponseException, UnknownErrorException, Util, VerbosityLevel, bytesToString, createValidAbsoluteUrl, getModificationDate, getVerbosityLevel, isArrayBuffer, isNodeJS, normalizeUnicode, objectSize, setVerbosityLevel, shadow, string32, stringToBytes, stringToPDFString, stringToUTF8String
- `../../web/annotation_layer_builder.js`: AnnotationLayerBuilder
- `../../web/download_manager.js`: DownloadManager
- `../../web/event_utils.js`: EventBus, WaitOnType, waitOnEventOrTimeout
- `../../web/genericl10n.js`: GenericL10n
- `../../web/l10n_utils.js`: NullL10n
- `../../web/pdf_find_controller.js`: FindState, PDFFindController
- `../../web/pdf_find_utils.js`: CharacterType, getCharacterType
- `../../web/pdf_history.js`: PDFHistory, isDestArraysEqual, isDestHashesEqual
- `../../web/pdf_link_service.js`: LinkTarget, PDFLinkService, SimpleLinkService
- `../../web/pdf_page_view.js`: PDFPageView
- `../../web/pdf_scripting_manager.component.js`: PDFScriptingManager
- `../../web/pdf_single_page_viewer.js`: PDFSinglePageViewer
- `../../web/pdf_viewer.js`: PDFPageViewBuffer, PDFViewer
- `../../web/struct_tree_layer_builder.js`: StructTreeLayerBuilder
- `../../web/text_layer_builder.js`: TextLayerBuilder
- `../../web/ui_utils.js`: AutoPrintRegExp, ProgressBar, RenderingStates, ScrollMode, SpreadMode, backtrackBeforeAllVisibleElements, binarySearchFirstItem, getPageSizeInches, getVisibleElements, isPortraitOrientation, isValidRotation, parseQueryString, removeNullCharacters
- `../../web/xfa_layer_builder.js`: XfaLayerBuilder
- `./test_utils.js`: CMAP_URL, DefaultFileReaderFactory, STANDARD_FONT_DATA_URL, TEST_PDFS_PATH, XRefMock, buildGetDocumentParams, createIdFactory
- `./testreporter.js`: TestReporter
</imports>

Code:
<code>
File:
src/display/annotation_layer.js
1 /* Copyright 2014 Mozilla Foundation
2  *
3  * Licensed under the Apache License, Version 2.0 (the "License");
4  * you may not use this file except in compliance with the License.
5  * You may obtain a copy of the License at
6  *
7  *     http://www.apache.org/licenses/LICENSE-2.0
8  *
9  * Unless required by applicable law or agreed to in writing, software
10  * distributed under the License is distributed on an "AS IS" BASIS,
11  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
12  * See the License for the specific language governing permissions and
13  * limitations under the License.
14  */
15 
16 /** @typedef {import("./api").PDFPageProxy} PDFPageProxy */
17 /** @typedef {import("./display_utils").PageViewport} PageViewport */
18 // eslint-disable-next-line max-len
19 /** @typedef {import("../../web/text_accessibility.js").TextAccessibilityManager} TextAccessibilityManager */
20 // eslint-disable-next-line max-len
21 /** @typedef {import("../../web/interfaces").IDownloadManager} IDownloadManager */
22 /** @typedef {import("../../web/interfaces").IPDFLinkService} IPDFLinkService */
23 
24 import {
25   AnnotationBorderStyleType,
26   AnnotationEditorType,
27   AnnotationPrefix,
28   AnnotationType,
29   FeatureTest,
30   LINE_FACTOR,
31   shadow,
32   unreachable,
33   Util,
34   warn,
35 } from "../shared/util.js";
36 import {
37   DOMSVGFactory,
38   getFilenameFromUrl,
39   PDFDateString,
40   setLayerDimensions,
41 } from "./display_utils.js";
42 import { AnnotationStorage } from "./annotation_storage.js";
43 import { ColorConverters } from "../shared/scripting_utils.js";
44 import { NullL10n } from "display-l10n_utils";
45 import { XfaLayer } from "./xfa_layer.js";
46 
47 const DEFAULT_TAB_INDEX = 1000;
48 const DEFAULT_FONT_SIZE = 9;
49 const GetElementsByNameSet = new WeakSet();
50 
51 function getRectDims(rect) {
52   return {
53     width: rect[2] - rect[0],
54     height: rect[3] - rect[1],
55   };
56 }
57 
58 /**
59  * @typedef {Object} AnnotationElementParameters
60  * @property {Object} data
61  * @property {HTMLDivElement} layer
62  * @property {IPDFLinkService} linkService
63  * @property {IDownloadManager} downloadManager
64  * @property {AnnotationStorage} [annotationStorage]
65  * @property {string} [imageResourcesPath] - Path for image resources, mainly
66  *   for annotation icons. Include trailing slash.
67  * @property {boolean} renderForms
68  * @property {Object} svgFactory
69  * @property {boolean} [enableScripting]
70  * @property {boolean} [hasJSActions]
71  * @property {Object} [fieldObjects]
72  */
73 
74 class AnnotationElementFactory {
75   /**
76    * @param {AnnotationElementParameters} parameters
77    * @returns {AnnotationElement}
78    */
79   static create(parameters) {
80     const subtype = parameters.data.annotationType;
81 
82     switch (subtype) {
83       case AnnotationType.LINK:
84         return new LinkAnnotationElement(parameters);
85 
86       case AnnotationType.TEXT:
87         return new TextAnnotationElement(parameters);
88 
89       case AnnotationType.WIDGET:
90         const fieldType = parameters.data.fieldType;
91 
92         switch (fieldType) {
93           case "Tx":
94             return new TextWidgetAnnotationElement(parameters);
95           case "Btn":
96             if (parameters.data.radioButton) {
97               return new RadioButtonWidgetAnnotationElement(parameters);
98             } else if (parameters.data.checkBox) {
99               return new CheckboxWidgetAnnotationElement(parameters);
100             }
101             return new PushButtonWidgetAnnotationElement(parameters);
102           case "Ch":
103             return new ChoiceWidgetAnnotationElement(parameters);
104           case "Sig":
105             return new SignatureWidgetAnnotationElement(parameters);
106         }
107         return new WidgetAnnotationElement(parameters);
108 
109       case AnnotationType.POPUP:
110         return new PopupAnnotationElement(parameters);
111 
112       case AnnotationType.FREETEXT:
113         return new FreeTextAnnotationElement(parameters);
114 
115       case AnnotationType.LINE:
116         return new LineAnnotationElement(parameters);
117 
118       case AnnotationType.SQUARE:
119         return new SquareAnnotationElement(parameters);
120 
121       case AnnotationType.CIRCLE:
122         return new CircleAnnotationElement(parameters);
123 
124       case AnnotationType.POLYLINE:
125         return new PolylineAnnotationElement(parameters);
126 
127       case AnnotationType.CARET:
128         return new CaretAnnotationElement(parameters);
129 
130       case AnnotationType.INK:
131         return new InkAnnotationElement(parameters);
132 
133       case AnnotationType.POLYGON:
134         return new PolygonAnnotationElement(parameters);
135 
136       case AnnotationType.HIGHLIGHT:
137         return new HighlightAnnotationElement(parameters);
138 
139       case AnnotationType.UNDERLINE:
140         return new UnderlineAnnotationElement(parameters);
141 
142       case AnnotationType.SQUIGGLY:
143         return new SquigglyAnnotationElement(parameters);
144 
145       case AnnotationType.STRIKEOUT:
146         return new StrikeOutAnnotationElement(parameters);
147 
148       case AnnotationType.STAMP:
149         return new StampAnnotationElement(parameters);
150 
151       case AnnotationType.FILEATTACHMENT:
152         return new FileAttachmentAnnotationElement(parameters);
153 
154       default:
155         return new AnnotationElement(parameters);
156     }
157   }
158 }
159 
160 class AnnotationElement {
161   #hasBorder = false;
162 
163   constructor(
164     parameters,
165     {
166       isRenderable = false,
167       ignoreBorder = false,
168       createQuadrilaterals = false,
169     } = {}
170   ) {
171     this.isRenderable = isRenderable;
172     this.data = parameters.data;
173     this.layer = parameters.layer;
174     this.linkService = parameters.linkService;
175     this.downloadManager = parameters.downloadManager;
176     this.imageResourcesPath = parameters.imageResourcesPath;
177     this.renderForms = parameters.renderForms;
178     this.svgFactory = parameters.svgFactory;
179     this.annotationStorage = parameters.annotationStorage;
180     this.enableScripting = parameters.enableScripting;
181     this.hasJSActions = parameters.hasJSActions;
182     this._fieldObjects = parameters.fieldObjects;
183     this.parent = parameters.parent;
184 
185     if (isRenderable) {
186       this.container = this._createContainer(ignoreBorder);
187     }
188     if (createQuadrilaterals) {
189       this._createQuadrilaterals();
190     }
191   }
192 
193   /**
194    * Create an empty container for the annotation's HTML element.
195    *
196    * @private
197    * @param {boolean} ignoreBorder
198    * @memberof AnnotationElement
199    * @returns {HTMLElement} A section element.
200    */
201   _createContainer(ignoreBorder) {
202     const {
203       data,
204       parent: { page, viewport },
205     } = this;
206 
207     const container = document.createElement("section");
208     container.setAttribute("data-annotation-id", data.id);
209     if (!(this instanceof WidgetAnnotationElement)) {
210       container.tabIndex = DEFAULT_TAB_INDEX;
211     }
212 
213     // The accessibility manager will move the annotation in the DOM in
214     // order to match the visual ordering.
215     // But if an annotation is above an other one, then we must draw it
216     // after the other one whatever the order is in the DOM, hence the
217     // use of the z-index.
218     container.style.zIndex = this.parent.zIndex++;
219 
220     if (this.data.popupRef) {
221       container.setAttribute("aria-haspopup", "dialog");
222     }
223 
224     if (data.noRotate) {
225       container.classList.add("norotate");
226     }
227 
228     const { pageWidth, pageHeight, pageX, pageY } = viewport.rawDims;
229 
230     if (!data.rect || this instanceof PopupAnnotationElement) {
231       const { rotation } = data;
232       if (!data.hasOwnCanvas && rotation !== 0) {
233         this.setRotation(rotation, container);
234       }
235       return container;
236     }
237 
238     const { width, height } = getRectDims(data.rect);
239 
240     // Do *not* modify `data.rect`, since that will corrupt the annotation
241     // position on subsequent calls to `_createContainer` (see issue 6804).
242     const rect = Util.normalizeRect([
243       data.rect[0],
244       page.view[3] - data.rect[1] + page.view[1],
245       data.rect[2],
246       page.view[3] - data.rect[3] + page.view[1],
247     ]);
248 
249     if (!ignoreBorder && data.borderStyle.width > 0) {
250       container.style.borderWidth = `${data.borderStyle.width}px`;
251 
252       const horizontalRadius = data.borderStyle.horizontalCornerRadius;
253       const verticalRadius = data.borderStyle.verticalCornerRadius;
254       if (horizontalRadius > 0 || verticalRadius > 0) {
255         const radius = `calc(${horizontalRadius}px * var(--scale-factor)) / calc(${verticalRadius}px * var(--scale-factor))`;
256         container.style.borderRadius = radius;
257       } else if (this instanceof RadioButtonWidgetAnnotationElement) {
258         const radius = `calc(${width}px * var(--scale-factor)) / calc(${height}px * var(--scale-factor))`;
259         container.style.borderRadius = radius;
260       }
261 
262       switch (data.borderStyle.style) {
263         case AnnotationBorderStyleType.SOLID:
264           container.style.borderStyle = "solid";
265           break;
266 
267         case AnnotationBorderStyleType.DASHED:
268           container.style.borderStyle = "dashed";
269           break;
270 
271         case AnnotationBorderStyleType.BEVELED:
272           warn("Unimplemented border style: beveled");
273           break;
274 
275         case AnnotationBorderStyleType.INSET:
276           warn("Unimplemented border style: inset");
277           break;
278 
279         case AnnotationBorderStyleType.UNDERLINE:
280           container.style.borderBottomStyle = "solid";
281           break;
282 
283         default:
284           break;
285       }
286 
287       const borderColor = data.borderColor || null;
288       if (borderColor) {
289         this.#hasBorder = true;
290         container.style.borderColor = Util.makeHexColor(
291           borderColor[0] | 0,
292           borderColor[1] | 0,
293           borderColor[2] | 0
294         );
295       } else {
296         // Transparent (invisible) border, so do not draw it at all.
297         container.style.borderWidth = 0;
298       }
299     }
300 
301     container.style.left = `${(100 * (rect[0] - pageX)) / pageWidth}%`;
302     container.style.top = `${(100 * (rect[1] - pageY)) / pageHeight}%`;
303 
304     const { rotation } = data;
305     if (data.hasOwnCanvas || rotation === 0) {
306       container.style.width = `${(100 * width) / pageWidth}%`;
307       container.style.height = `${(100 * height) / pageHeight}%`;
308     } else {
309       this.setRotation(rotation, container);
310     }
311 
312     return container;
313   }
314 
315   setRotation(angle, container = this.container) {
316     if (!this.data.rect) {
317       return;
318     }
319     const { pageWidth, pageHeight } = this.parent.viewport.rawDims;
320     const { width, height } = getRectDims(this.data.rect);
321 
322     let elementWidth, elementHeight;
323     if (angle % 180 === 0) {
324       elementWidth = (100 * width) / pageWidth;
325       elementHeight = (100 * height) / pageHeight;
326     } else {
327       elementWidth = (100 * height) / pageWidth;
328       elementHeight = (100 * width) / pageHeight;
329     }
330 
331     container.style.width = `${elementWidth}%`;
332     container.style.height = `${elementHeight}%`;
333 
334     container.setAttribute("data-main-rotation", (360 - angle) % 360);
335   }
336 
337   get _commonActions() {
338     const setColor = (jsName, styleName, event) => {
339       const color = event.detail[jsName];
340       const colorType = color[0];
341       const colorArray = color.slice(1);
342       event.target.style[styleName] =
343         ColorConverters[`${colorType}_HTML`](colorArray);
344       this.annotationStorage.setValue(this.data.id, {
345         [styleName]: ColorConverters[`${colorType}_rgb`](colorArray),
346       });
347     };
348 
349     return shadow(this, "_commonActions", {
350       display: event => {
351         const { display } = event.detail;
352         // See scripting/constants.js for the values of `Display`.
353         // 0 = visible, 1 = hidden, 2 = noPrint and 3 = noView.
354         const hidden = display % 2 === 1;
355         this.container.style.visibility = hidden ? "hidden" : "visible";
356         this.annotationStorage.setValue(this.data.id, {
357           noView: hidden,
358           noPrint: display === 1 || display === 2,
359         });
360       },
361       print: event => {
362         this.annotationStorage.setValue(this.data.id, {
363           noPrint: !event.detail.print,
364         });
365       },
366       hidden: event => {
367         const { hidden } = event.detail;
368         this.container.style.visibility = hidden ? "hidden" : "visible";
369         this.annotationStorage.setValue(this.data.id, {
370           noPrint: hidden,
371           noView: hidden,
372         });
373       },
374       focus: event => {
375         setTimeout(() => event.target.focus({ preventScroll: false }), 0);
376       },
377       userName: event => {
378         // tooltip
379         event.target.title = event.detail.userName;
380       },
381       readonly: event => {
382         event.target.disabled = event.detail.readonly;
383       },
384       required: event => {
385         this._setRequired(event.target, event.detail.required);
386       },
387       bgColor: event => {
388         setColor("bgColor", "backgroundColor", event);
389       },
390       fillColor: event => {
391         setColor("fillColor", "backgroundColor", event);
392       },
393       fgColor: event => {
394         setColor("fgColor", "color", event);
395       },
396       textColor: event => {
397         setColor("textColor", "color", event);
398       },
399       borderColor: event => {
400         setColor("borderColor", "borderColor", event);
401       },
402       strokeColor: event => {
403         setColor("strokeColor", "borderColor", event);
404       },
405       rotation: event => {
406         const angle = event.detail.rotation;
407         this.setRotation(angle);
408         this.annotationStorage.setValue(this.data.id, {
409           rotation: angle,
410         });
411       },
412     });
413   }
414 
415   _dispatchEventFromSandbox(actions, jsEvent) {
416     const commonActions = this._commonActions;
417     for (const name of Object.keys(jsEvent.detail)) {
418       const action = actions[name] || commonActions[name];
419       action?.(jsEvent);
420     }
421   }
422 
423   _setDefaultPropertiesFromJS(element) {
424     if (!this.enableScripting) {
425       return;
426     }
427 
428     // Some properties may have been updated thanks to JS.
429     const storedData = this.annotationStorage.getRawValue(this.data.id);
430     if (!storedData) {
431       return;
432     }
433 
434     const commonActions = this._commonActions;
435     for (const [actionName, detail] of Object.entries(storedData)) {
436       const action = commonActions[actionName];
437       if (action) {
438         const eventProxy = {
439           detail: {
440             [actionName]: detail,
441           },
442           target: element,
443         };
444         action(eventProxy);
445         // The action has been consumed: no need to keep it.
446         delete storedData[actionName];
447       }
448     }
449   }
450 
451   /**
452    * Create quadrilaterals from the annotation's quadpoints.
453    *
454    * @private
455    * @memberof AnnotationElement
456    */
457   _createQuadrilaterals() {
458     if (!this.container) {
459       return;
460     }
461     const { quadPoints } = this.data;
462     if (!quadPoints) {
463       return;
464     }
465 
466     const [rectBlX, rectBlY, rectTrX, rectTrY] = this.data.rect;
467 
468     if (quadPoints.length === 1) {
469       const [, { x: trX, y: trY }, { x: blX, y: blY }] = quadPoints[0];
470       if (
471         rectTrX === trX &&
472         rectTrY === trY &&
473         rectBlX === blX &&
474         rectBlY === blY
475       ) {
476         // The quadpoints cover the whole annotation rectangle, so no need to
477         // create a quadrilateral.
478         return;
479       }
480     }
481 
482     const { style } = this.container;
483     let svgBuffer;
484     if (this.#hasBorder) {
485       const { borderColor, borderWidth } = style;
486       style.borderWidth = 0;
487       svgBuffer = [
488         "url('data:image/svg+xml;utf8,",
489         `<svg xmlns="http://www.w3.org/2000/svg"`,
490         ` preserveAspectRatio="none" viewBox="0 0 1 1">`,
491         `<g fill="transparent" stroke="${borderColor}" stroke-width="${borderWidth}">`,
492       ];
493       this.container.classList.add("hasBorder");
494     }
495 
496     if (typeof PDFJSDev !== "undefined" && PDFJSDev.test("TESTING")) {
497       this.container.classList.add("hasClipPath");
498     }
499 
500     const width = rectTrX - rectBlX;
501     const height = rectTrY - rectBlY;
502 
503     const { svgFactory } = this;
504     const svg = svgFactory.createElement("svg");
505     svg.classList.add("quadrilateralsContainer");
506     svg.setAttribute("width", 0);
507     svg.setAttribute("height", 0);
508     const defs = svgFactory.createElement("defs");
509     svg.append(defs);
510     const clipPath = svgFactory.createElement("clipPath");
511     const id = `clippath_${this.data.id}`;
512     clipPath.setAttribute("id", id);
513     clipPath.setAttribute("clipPathUnits", "objectBoundingBox");
514     defs.append(clipPath);
515 
516     for (const [, { x: trX, y: trY }, { x: blX, y: blY }] of quadPoints) {
517       const rect = svgFactory.createElement("rect");
518       const x = (blX - rectBlX) / width;
519       const y = (rectTrY - trY) / height;
520       const rectWidth = (trX - blX) / width;
521       const rectHeight = (trY - blY) / height;
522       rect.setAttribute("x", x);
523       rect.setAttribute("y", y);
524       rect.setAttribute("width", rectWidth);
525       rect.setAttribute("height", rectHeight);
526       clipPath.append(rect);
527       svgBuffer?.push(
528         `<rect vector-effect="non-scaling-stroke" x="${x}" y="${y}" width="${rectWidth}" height="${rectHeight}"/>`
529       );
530     }
531 
532     if (this.#hasBorder) {
533       svgBuffer.push(`</g></svg>')`);
534       style.backgroundImage = svgBuffer.join("");
535     }
536 
537     this.container.append(svg);
538     this.container.style.clipPath = `url(#${id})`;
539   }
540 
541   /**
542    * Create a popup for the annotation's HTML element. This is used for
543    * annotations that do not have a Popup entry in the dictionary, but
544    * are of a type that works with popups (such as Highlight annotations).
545    *
546    * @private
547    * @memberof AnnotationElement
548    */
549   _createPopup() {
550     const { container, data } = this;
551     container.setAttribute("aria-haspopup", "dialog");
552 
553     const popup = new PopupAnnotationElement({
554       data: {
555         color: data.color,
556         titleObj: data.titleObj,
557         modificationDate: data.modificationDate,
558         contentsObj: data.contentsObj,
559         richText: data.richText,
560         parentRect: data.rect,
561         borderStyle: 0,
562         id: `popup_${data.id}`,
563         rotation: data.rotation,
564       },
565       parent: this.parent,
566       elements: [this],
567     });
568     this.parent.div.append(popup.render());
569   }
570 
571   /**
572    * Render the annotation's HTML element(s).
573    *
574    * @public
575    * @memberof AnnotationElement
576    */
577   render() {
578     unreachable("Abstract method `AnnotationElement.render` called");
579   }
580 
581   /**
582    * @private
583    * @returns {Array}
584    */
585   _getElementsByName(name, skipId = null) {
586     const fields = [];
587 
588     if (this._fieldObjects) {
589       const fieldObj = this._fieldObjects[name];
590       if (fieldObj) {
591         for (const { page, id, exportValues } of fieldObj) {
592           if (page === -1) {
593             continue;
594           }
595           if (id === skipId) {
596             continue;
597           }
598           const exportValue =
599             typeof exportValues === "string" ? exportValues : null;
600 
601           const domElement = document.querySelector(
602             `[data-element-id="${id}"]`
603           );
604           if (domElement && !GetElementsByNameSet.has(domElement)) {
605             warn(`_getElementsByName - element not allowed: ${id}`);
606             continue;
607           }
608           fields.push({ id, exportValue, domElement });
609         }
610       }
611       return fields;
612     }
613     // Fallback to a regular DOM lookup, to ensure that the standalone
614     // viewer components won't break.
615     for (const domElement of document.getElementsByName(name)) {
616       const { exportValue } = domElement;
617       const id = domElement.getAttribute("data-element-id");
618       if (id === skipId) {
619         continue;
620       }
621       if (!GetElementsByNameSet.has(domElement)) {
622         continue;
623       }
624       fields.push({ id, exportValue, domElement });
625     }
626     return fields;
627   }
628 
629   show() {
630     if (this.container) {
631       this.container.hidden = false;
632     }
633     this.popup?.maybeShow();
634   }
635 
636   hide() {
637     if (this.container) {
638       this.container.hidden = true;
639     }
640     this.popup?.forceHide();
641   }
642 
643   /**
644    * Get the HTML element(s) which can trigger a popup when clicked or hovered.
645    *
646    * @public
647    * @memberof AnnotationElement
648    * @returns {Array<HTMLElement>|HTMLElement} An array of elements or an
649    *          element.
650    */
651   getElementsToTriggerPopup() {
652     return this.container;
653   }
654 
655   addHighlightArea() {
656     const triggers = this.getElementsToTriggerPopup();
657     if (Array.isArray(triggers)) {
658       for (const element of triggers) {
659         element.classList.add("highlightArea");
660       }
661     } else {
662       triggers.classList.add("highlightArea");
663     }
664   }
665 
666   _editOnDoubleClick() {
667     const {
668       annotationEditorType: mode,
669       data: { id: editId },
670     } = this;
671     this.container.addEventListener("dblclick", () => {
672       this.linkService.eventBus?.dispatch("switchannotationeditormode", {
673         source: this,
674         mode,
675         editId,
676       });
677     });
678   }
679 }
680 
681 class LinkAnnotationElement extends AnnotationElement {
682   constructor(parameters, options = null) {
683     super(parameters, {
684       isRenderable: true,
685       ignoreBorder: !!options?.ignoreBorder,
686       createQuadrilaterals: true,
687     });
688     this.isTooltipOnly = parameters.data.isTooltipOnly;
689   }
690 
691   render() {
692     const { data, linkService } = this;
693     const link = document.createElement("a");
694     link.setAttribute("data-element-id", data.id);
695     let isBound = false;
696 
697     if (data.url) {
698       linkService.addLinkAttributes(link, data.url, data.newWindow);
699       isBound = true;
700     } else if (data.action) {
701       this._bindNamedAction(link, data.action);
702       isBound = true;
703     } else if (data.attachment) {
704       this._bindAttachment(link, data.attachment);
705       isBound = true;
706     } else if (data.setOCGState) {
707       this.#bindSetOCGState(link, data.setOCGState);
708       isBound = true;
709     } else if (data.dest) {
710       this._bindLink(link, data.dest);
711       isBound = true;
712     } else {
713       if (
714         data.actions &&
715         (data.actions.Action ||
716           data.actions["Mouse Up"] ||
717           data.actions["Mouse Down"]) &&
718         this.enableScripting &&
719         this.hasJSActions
720       ) {
721         this._bindJSAction(link, data);
722         isBound = true;
723       }
724 
725       if (data.resetForm) {
726         this._bindResetFormAction(link, data.resetForm);
727         isBound = true;
728       } else if (this.isTooltipOnly && !isBound) {
729         this._bindLink(link, "");
730         isBound = true;
731       }
732     }
733 
734     this.container.classList.add("linkAnnotation");
735     if (isBound) {
736       this.container.append(link);
737     }
738 
739     return this.container;
740   }
741 
742   #setInternalLink() {
743     this.container.setAttribute("data-internal-link", "");
744   }
745 
746   /**
747    * Bind internal links to the link element.
748    *
749    * @private
750    * @param {Object} link
751    * @param {Object} destination
752    * @memberof LinkAnnotationElement
753    */
754   _bindLink(link, destination) {
755     link.href = this.linkService.getDestinationHash(destination);
756     link.onclick = () => {
757       if (destination) {
758         this.linkService.goToDestination(destination);
759       }
760       return false;
761     };
762     if (destination || destination === /* isTooltipOnly = */ "") {
763       this.#setInternalLink();
764     }
765   }
766 
767   /**
768    * Bind named actions to the link element.
769    *
770    * @private
771    * @param {Object} link
772    * @param {Object} action
773    * @memberof LinkAnnotationElement
774    */
775   _bindNamedAction(link, action) {
776     link.href = this.linkService.getAnchorUrl("");
777     link.onclick = () => {
778       this.linkService.executeNamedAction(action);
779       return false;
780     };
781     this.#setInternalLink();
782   }
783 
784   /**
785    * Bind attachments to the link element.
786    * @param {Object} link
787    * @param {Object} attachment
788    */
789   _bindAttachment(link, attachment) {
790     link.href = this.linkService.getAnchorUrl("");
791     link.onclick = () => {
792       this.downloadManager?.openOrDownloadData(
793         this.container,
794         attachment.content,
795         attachment.filename
796       );
797       return false;
798     };
799     this.#setInternalLink();
800   }
801 
802   /**
803    * Bind SetOCGState actions to the link element.
804    * @param {Object} link
805    * @param {Object} action
806    */
807   #bindSetOCGState(link, action) {
808     link.href = this.linkService.getAnchorUrl("");
809     link.onclick = () => {
810       this.linkService.executeSetOCGState(action);
811       return false;
812     };
813     this.#setInternalLink();
814   }
815 
816   /**
817    * Bind JS actions to the link element.
818    *
819    * @private
820    * @param {Object} link
821    * @param {Object} data
822    * @memberof LinkAnnotationElement
823    */
824   _bindJSAction(link, data) {
825     link.href = this.linkService.getAnchorUrl("");
826     const map = new Map([
827       ["Action", "onclick"],
828       ["Mouse Up", "onmouseup"],
829       ["Mouse Down", "onmousedown"],
830     ]);
831     for (const name of Object.keys(data.actions)) {
832       const jsName = map.get(name);
833       if (!jsName) {
834         continue;
835       }
836       link[jsName] = () => {
837         this.linkService.eventBus?.dispatch("dispatcheventinsandbox", {
838           source: this,
839           detail: {
840             id: data.id,
841             name,
842           },
843         });
844         return false;
845       };
846     }
847 
848     if (!link.onclick) {
849       link.onclick = () => false;
850     }
851     this.#setInternalLink();
852   }
853 
854   _bindResetFormAction(link, resetForm) {
855     const otherClickAction = link.onclick;
856     if (!otherClickAction) {
857       link.href = this.linkService.getAnchorUrl("");
858     }
859     this.#setInternalLink();
860 
861     if (!this._fieldObjects) {
862       warn(
863         `_bindResetFormAction - "resetForm" action not supported, ` +
864           "ensure that the `fieldObjects` parameter is provided."
865       );
866       if (!otherClickAction) {
867         link.onclick = () => false;
868       }
869       return;
870     }
871 
872     link.onclick = () => {
873       otherClickAction?.();
874 
875       const {
876         fields: resetFormFields,
877         refs: resetFormRefs,
878         include,
879       } = resetForm;
880 
881       const allFields = [];
882       if (resetFormFields.length !== 0 || resetFormRefs.length !== 0) {
883         const fieldIds = new Set(resetFormRefs);
884         for (const fieldName of resetFormFields) {
885           const fields = this._fieldObjects[fieldName] || [];
886           for (const { id } of fields) {
887             fieldIds.add(id);
888           }
889         }
890         for (const fields of Object.values(this._fieldObjects)) {
891           for (const field of fields) {
892             if (fieldIds.has(field.id) === include) {
893               allFields.push(field);
894             }
895           }
896         }
897       } else {
898         for (const fields of Object.values(this._fieldObjects)) {
899           allFields.push(...fields);
900         }
901       }
902 
903       const storage = this.annotationStorage;
904       const allIds = [];
905       for (const field of allFields) {
906         const { id } = field;
907         allIds.push(id);
908         switch (field.type) {
909           case "text": {
910             const value = field.defaultValue || "";
911             storage.setValue(id, { value });
912             break;
913           }
914           case "checkbox":
915           case "radiobutton": {
916             const value = field.defaultValue === field.exportValues;
917             storage.setValue(id, { value });
918             break;
919           }
920           case "combobox":
921           case "listbox": {
922             const value = field.defaultValue || "";
923             storage.setValue(id, { value });
924             break;
925           }
926           default:
927             continue;
928         }
929 
930         const domElement = document.querySelector(`[data-element-id="${id}"]`);
931         if (!domElement) {
932           continue;
933         } else if (!GetElementsByNameSet.has(domElement)) {
934           warn(`_bindResetFormAction - element not allowed: ${id}`);
935           continue;
936         }
937         domElement.dispatchEvent(new Event("resetform"));
938       }
939 
940       if (this.enableScripting) {
941         // Update the values in the sandbox.
942         this.linkService.eventBus?.dispatch("dispatcheventinsandbox", {
943           source: this,
944           detail: {
945             id: "app",
946             ids: allIds,
947             name: "ResetForm",
948           },
949         });
950       }
951 
952       return false;
953     };
954   }
955 }
956 
957 class TextAnnotationElement extends AnnotationElement {
958   constructor(parameters) {
959     const isRenderable = !!(
960       parameters.data.popupRef ||
961       parameters.data.titleObj?.str ||
962       parameters.data.contentsObj?.str ||
963       parameters.data.richText?.str
964     );
965     super(parameters, { isRenderable });
966   }
967 
968   render() {
969     this.container.classList.add("textAnnotation");
970 
971     const image = document.createElement("img");
972     image.src =
973       this.imageResourcesPath +
974       "annotation-" +
975       this.data.name.toLowerCase() +
976       ".svg";
977     image.alt = "[{{type}} Annotation]";
978     image.dataset.l10nId = "text_annotation_type";
979     image.dataset.l10nArgs = JSON.stringify({ type: this.data.name });
980 
981     if (!this.data.popupRef) {
982       this._createPopup();
983     }
984 
985     this.container.append(image);
986     return this.container;
987   }
988 }
989 
990 class WidgetAnnotationElement extends AnnotationElement {
991   render() {
992     // Show only the container for unsupported field types.
993     if (this.data.alternativeText) {
994       this.container.title = this.data.alternativeText;
995     }
996 
997     return this.container;
998   }
999 
1000   showElementAndHideCanvas(element) {
1001     if (this.data.hasOwnCanvas) {
1002       if (element.previousSibling?.nodeName === "CANVAS") {
1003         element.previousSibling.hidden = true;
1004       }
1005       element.hidden = false;
1006     }
1007   }
1008 
1009   _getKeyModifier(event) {
1010     const { isWin, isMac } = FeatureTest.platform;
1011     return (isWin && event.ctrlKey) || (isMac && event.metaKey);
1012   }
1013 
1014   _setEventListener(element, baseName, eventName, valueGetter) {
1015     if (baseName.includes("mouse")) {
1016       // Mouse events
1017       element.addEventListener(baseName, event => {
1018         this.linkService.eventBus?.dispatch("dispatcheventinsandbox", {
1019           source: this,
1020           detail: {
1021             id: this.data.id,
1022             name: eventName,
1023             value: valueGetter(event),
1024             shift: event.shiftKey,
1025             modifier: this._getKeyModifier(event),
1026           },
1027         });
1028       });
1029     } else {
1030       // Non mouse event
1031       element.addEventListener(baseName, event => {
1032         this.linkService.eventBus?.dispatch("dispatcheventinsandbox", {
1033           source: this,
1034           detail: {
1035             id: this.data.id,
1036             name: eventName,
1037             value: valueGetter(event),
1038           },
1039         });
1040       });
1041     }
1042   }
1043 
1044   _setEventListeners(element, names, getter) {
1045     for (const [baseName, eventName] of names) {
1046       if (eventName === "Action" || this.data.actions?.[eventName]) {
1047         this._setEventListener(element, baseName, eventName, getter);
1048       }
1049     }
1050   }
1051 
1052   _setBackgroundColor(element) {
1053     const color = this.data.backgroundColor || null;
1054     element.style.backgroundColor =
1055       color === null
1056         ? "transparent"
1057         : Util.makeHexColor(color[0], color[1], color[2]);
1058   }
1059 
1060   /**
1061    * Apply text styles to the text in the element.
1062    *
1063    * @private
1064    * @param {HTMLDivElement} element
1065    * @memberof TextWidgetAnnotationElement
1066    */
1067   _setTextStyle(element) {
1068     const TEXT_ALIGNMENT = ["left", "center", "right"];
1069     const { fontColor } = this.data.defaultAppearanceData;
1070     const fontSize =
1071       this.data.defaultAppearanceData.fontSize || DEFAULT_FONT_SIZE;
1072 
1073     const style = element.style;
1074 
1075     // TODO: If the font-size is zero, calculate it based on the height and
1076     //       width of the element.
1077     // Not setting `style.fontSize` will use the default font-size for now.
1078 
1079     // We don't use the font, as specified in the PDF document, for the <input>
1080     // element. Hence using the original `fontSize` could look bad, which is why
1081     // it's instead based on the field height.
1082     // If the height is "big" then it could lead to a too big font size
1083     // so in this case use the one we've in the pdf (hence the min).
1084     let computedFontSize;
1085     const BORDER_SIZE = 2;
1086     const roundToOneDecimal = x => Math.round(10 * x) / 10;
1087     if (this.data.multiLine) {
1088       const height = Math.abs(
1089         this.data.rect[3] - this.data.rect[1] - BORDER_SIZE
1090       );
1091       const numberOfLines = Math.round(height / (LINE_FACTOR * fontSize)) || 1;
1092       const lineHeight = height / numberOfLines;
1093       computedFontSize = Math.min(
1094         fontSize,
1095         roundToOneDecimal(lineHeight / LINE_FACTOR)
1096       );
1097     } else {
1098       const height = Math.abs(
1099         this.data.rect[3] - this.data.rect[1] - BORDER_SIZE
1100       );
1101       computedFontSize = Math.min(
1102         fontSize,
1103         roundToOneDecimal(height / LINE_FACTOR)
1104       );
1105     }
1106     style.fontSize = `calc(${computedFontSize}px * var(--scale-factor))`;
1107 
1108     style.color = Util.makeHexColor(fontColor[0], fontColor[1], fontColor[2]);
1109 
1110     if (this.data.textAlignment !== null) {
1111       style.textAlign = TEXT_ALIGNMENT[this.data.textAlignment];
1112     }
1113   }
1114 
1115   _setRequired(element, isRequired) {
1116     if (isRequired) {
1117       element.setAttribute("required", true);
1118     } else {
1119       element.removeAttribute("required");
1120     }
1121     element.setAttribute("aria-required", isRequired);
1122   }
1123 }
1124 
1125 class TextWidgetAnnotationElement extends WidgetAnnotationElement {
1126   constructor(parameters) {
1127     const isRenderable =
1128       parameters.renderForms ||
1129       (!parameters.data.hasAppearance && !!parameters.data.fieldValue);
1130     super(parameters, { isRenderable });
1131   }
1132 
1133   setPropertyOnSiblings(base, key, value, keyInStorage) {
1134     const storage = this.annotationStorage;
1135     for (const element of this._getElementsByName(
1136       base.name,
1137       /* skipId = */ base.id
1138     )) {
1139       if (element.domElement) {
1140         element.domElement[key] = value;
1141       }
1142       storage.setValue(element.id, { [keyInStorage]: value });
1143     }
1144   }
1145 
1146   render() {
1147     const storage = this.annotationStorage;
1148     const id = this.data.id;
1149 
1150     this.container.classList.add("textWidgetAnnotation");
1151 
1152     let element = null;
1153     if (this.renderForms) {
1154       // NOTE: We cannot set the values using `element.value` below, since it
1155       //       prevents the AnnotationLayer rasterizer in `test/driver.js`
1156       //       from parsing the elements correctly for the reference tests.
1157       const storedData = storage.getValue(id, {
1158         value: this.data.fieldValue,
1159       });
1160       let textContent = storedData.value || "";
1161       const maxLen = storage.getValue(id, {
1162         charLimit: this.data.maxLen,
1163       }).charLimit;
1164       if (maxLen && textContent.length > maxLen) {
1165         textContent = textContent.slice(0, maxLen);
1166       }
1167 
1168       let fieldFormattedValues =
1169         storedData.formattedValue || this.data.textContent?.join("\n") || null;
1170       if (fieldFormattedValues && this.data.comb) {
1171         fieldFormattedValues = fieldFormattedValues.replaceAll(/\s+/g, "");
1172       }
1173 
1174       const elementData = {
1175         userValue: textContent,
1176         formattedValue: fieldFormattedValues,
1177         lastCommittedValue: null,
1178         commitKey: 1,
1179       };
1180 
1181       if (this.data.multiLine) {
1182         element = document.createElement("textarea");
1183         element.textContent = fieldFormattedValues ?? textContent;
1184         if (this.data.doNotScroll) {
1185           element.style.overflowY = "hidden";
1186         }
1187       } else {
1188         element = document.createElement("input");
1189         element.type = "text";
1190         element.setAttribute("value", fieldFormattedValues ?? textContent);
1191         if (this.data.doNotScroll) {
1192           element.style.overflowX = "hidden";
1193         }
1194       }
1195       if (this.data.hasOwnCanvas) {
1196         element.hidden = true;
1197       }
1198       GetElementsByNameSet.add(element);
1199       element.setAttribute("data-element-id", id);
1200 
1201       element.disabled = this.data.readOnly;
1202       element.name = this.data.fieldName;
1203       element.tabIndex = DEFAULT_TAB_INDEX;
1204 
1205       this._setRequired(element, this.data.required);
1206 
1207       if (maxLen) {
1208         element.maxLength = maxLen;
1209       }
1210 
1211       element.addEventListener("input", event => {
1212         storage.setValue(id, { value: event.target.value });
1213         this.setPropertyOnSiblings(
1214           element,
1215           "value",
1216           event.target.value,
1217           "value"
1218         );
1219         elementData.formattedValue = null;
1220       });
1221 
1222       element.addEventListener("resetform", event => {
1223         const defaultValue = this.data.defaultFieldValue ?? "";
1224         element.value = elementData.userValue = defaultValue;
1225         elementData.formattedValue = null;
1226       });
1227 
1228       let blurListener = event => {
1229         const { formattedValue } = elementData;
1230         if (formattedValue !== null && formattedValue !== undefined) {
1231           event.target.value = formattedValue;
1232         }
1233         // Reset the cursor position to the start of the field (issue 12359).
1234         event.target.scrollLeft = 0;
1235       };
1236 
1237       if (this.enableScripting && this.hasJSActions) {
1238         element.addEventListener("focus", event => {
1239           const { target } = event;
1240           if (elementData.userValue) {
1241             target.value = elementData.userValue;
1242           }
1243           elementData.lastCommittedValue = target.value;
1244           elementData.commitKey = 1;
1245         });
1246 
1247         element.addEventListener("updatefromsandbox", jsEvent => {
1248           this.showElementAndHideCanvas(jsEvent.target);
1249           const actions = {
1250             value(event) {
1251               elementData.userValue = event.detail.value ?? "";
1252               storage.setValue(id, { value: elementData.userValue.toString() });
1253               event.target.value = elementData.userValue;
1254             },
1255             formattedValue(event) {
1256               const { formattedValue } = event.detail;
1257               elementData.formattedValue = formattedValue;
1258               if (
1259                 formattedValue !== null &&
1260                 formattedValue !== undefined &&
1261                 event.target !== document.activeElement
1262               ) {
1263                 // Input hasn't the focus so display formatted string
1264                 event.target.value = formattedValue;
1265               }
1266               storage.setValue(id, {
1267                 formattedValue,
1268               });
1269             },
1270             selRange(event) {
1271               event.target.setSelectionRange(...event.detail.selRange);
1272             },
1273             charLimit: event => {
1274               const { charLimit } = event.detail;
1275               const { target } = event;
1276               if (charLimit === 0) {
1277                 target.removeAttribute("maxLength");
1278                 return;
1279               }
1280 
1281               target.setAttribute("maxLength", charLimit);
1282               let value = elementData.userValue;
1283               if (!value || value.length <= charLimit) {
1284                 return;
1285               }
1286               value = value.slice(0, charLimit);
1287               target.value = elementData.userValue = value;
1288               storage.setValue(id, { value });
1289 
1290               this.linkService.eventBus?.dispatch("dispatcheventinsandbox", {
1291                 source: this,
1292                 detail: {
1293                   id,
1294                   name: "Keystroke",
1295                   value,
1296                   willCommit: true,
1297                   commitKey: 1,
1298                   selStart: target.selectionStart,
1299                   selEnd: target.selectionEnd,
1300                 },
1301               });
1302             },
1303           };
1304           this._dispatchEventFromSandbox(actions, jsEvent);
1305         });
1306 
1307         // Even if the field hasn't any actions
1308         // leaving it can still trigger some actions with Calculate
1309         element.addEventListener("keydown", event => {
1310           elementData.commitKey = 1;
1311           // If the key is one of Escape, Enter then the data are committed.
1312           // If we've a Tab then data will be committed on blur.
1313           let commitKey = -1;
1314           if (event.key === "Escape") {
1315             commitKey = 0;
1316           } else if (event.key === "Enter" && !this.data.multiLine) {
1317             // When we've a multiline field, "Enter" key is a key as the other
1318             // hence we don't commit the data (Acrobat behaves the same way)
1319             // (see issue #15627).
1320             commitKey = 2;
1321           } else if (event.key === "Tab") {
1322             elementData.commitKey = 3;
1323           }
1324           if (commitKey === -1) {
1325             return;
1326           }
1327           const { value } = event.target;
1328           if (elementData.lastCommittedValue === value) {
1329             return;
1330           }
1331           elementData.lastCommittedValue = value;
1332           // Save the entered value
1333           elementData.userValue = value;
1334           this.linkService.eventBus?.dispatch("dispatcheventinsandbox", {
1335             source: this,
1336             detail: {
1337               id,
1338               name: "Keystroke",
1339               value,
1340               willCommit: true,
1341               commitKey,
1342               selStart: event.target.selectionStart,
1343               selEnd: event.target.selectionEnd,
1344             },
1345           });
1346         });
1347         const _blurListener = blurListener;
1348         blurListener = null;
1349         element.addEventListener("blur", event => {
1350           if (!event.relatedTarget) {
1351             return;
1352           }
1353           const { value } = event.target;
1354           elementData.userValue = value;
1355           if (elementData.lastCommittedValue !== value) {
1356             this.linkService.eventBus?.dispatch("dispatcheventinsandbox", {
1357               source: this,
1358               detail: {
1359                 id,
1360                 name: "Keystroke",
1361                 value,
1362                 willCommit: true,
1363                 commitKey: elementData.commitKey,
1364                 selStart: event.target.selectionStart,
1365                 selEnd: event.target.selectionEnd,
1366               },
1367             });
1368           }
1369           _blurListener(event);
1370         });
1371 
1372         if (this.data.actions?.Keystroke) {
1373           element.addEventListener("beforeinput", event => {
1374             elementData.lastCommittedValue = null;
1375             const { data, target } = event;
1376             const { value, selectionStart, selectionEnd } = target;
1377 
1378             let selStart = selectionStart,
1379               selEnd = selectionEnd;
1380 
1381             switch (event.inputType) {
1382               // https://rawgit.com/w3c/input-events/v1/index.html#interface-InputEvent-Attributes
1383               case "deleteWordBackward": {
1384                 const match = value
1385                   .substring(0, selectionStart)
1386                   .match(/\w*[^\w]*$/);
1387                 if (match) {
1388                   selStart -= match[0].length;
1389                 }
1390                 break;
1391               }
1392               case "deleteWordForward": {
1393                 const match = value
1394                   .substring(selectionStart)
1395                   .match(/^[^\w]*\w*/);
1396                 if (match) {
1397                   selEnd += match[0].length;
1398                 }
1399                 break;
1400               }
1401               case "deleteContentBackward":
1402                 if (selectionStart === selectionEnd) {
1403                   selStart -= 1;
1404                 }
1405                 break;
1406               case "deleteContentForward":
1407                 if (selectionStart === selectionEnd) {
1408                   selEnd += 1;
1409                 }
1410                 break;
1411             }
1412 
1413             // We handle the event ourselves.
1414             event.preventDefault();
1415             this.linkService.eventBus?.dispatch("dispatcheventinsandbox", {
1416               source: this,
1417               detail: {
1418                 id,
1419                 name: "Keystroke",
1420                 value,
1421                 change: data || "",
1422                 willCommit: false,
1423                 selStart,
1424                 selEnd,
1425               },
1426             });
1427           });
1428         }
1429 
1430         this._setEventListeners(
1431           element,
1432           [
1433             ["focus", "Focus"],
1434             ["blur", "Blur"],
1435             ["mousedown", "Mouse Down"],
1436             ["mouseenter", "Mouse Enter"],
1437             ["mouseleave", "Mouse Exit"],
1438             ["mouseup", "Mouse Up"],
1439           ],
1440           event => event.target.value
1441         );
1442       }
1443 
1444       if (blurListener) {
1445         element.addEventListener("blur", blurListener);
1446       }
1447 
1448       if (this.data.comb) {
1449         const fieldWidth = this.data.rect[2] - this.data.rect[0];
1450         const combWidth = fieldWidth / maxLen;
1451 
1452         element.classList.add("comb");
1453         element.style.letterSpacing = `calc(${combWidth}px * var(--scale-factor) - 1ch)`;
1454       }
1455     } else {
1456       element = document.createElement("div");
1457       element.textContent = this.data.fieldValue;
1458       element.style.verticalAlign = "middle";
1459       element.style.display = "table-cell";
1460     }
1461 
1462     this._setTextStyle(element);
1463     this._setBackgroundColor(element);
1464     this._setDefaultPropertiesFromJS(element);
1465 
1466     this.container.append(element);
1467     return this.container;
1468   }
1469 }
1470 
1471 class SignatureWidgetAnnotationElement extends WidgetAnnotationElement {
1472   constructor(parameters) {
1473     super(parameters, { isRenderable: !!parameters.data.hasOwnCanvas });
1474   }
1475 }
1476 
1477 class CheckboxWidgetAnnotationElement extends WidgetAnnotationElement {
1478   constructor(parameters) {
1479     super(parameters, { isRenderable: parameters.renderForms });
1480   }
1481 
1482   render() {
1483     const storage = this.annotationStorage;
1484     const data = this.data;
1485     const id = data.id;
1486     let value = storage.getValue(id, {
1487       value: data.exportValue === data.fieldValue,
1488     }).value;
1489     if (typeof value === "string") {
1490       // The value has been changed through js and set in annotationStorage.
1491       value = value !== "Off";
1492       storage.setValue(id, { value });
1493     }
1494 
1495     this.container.classList.add("buttonWidgetAnnotation", "checkBox");
1496 
1497     const element = document.createElement("input");
1498     GetElementsByNameSet.add(element);
1499     element.setAttribute("data-element-id", id);
1500 
1501     element.disabled = data.readOnly;
1502     this._setRequired(element, this.data.required);
1503     element.type = "checkbox";
1504     element.name = data.fieldName;
1505     if (value) {
1506       element.setAttribute("checked", true);
1507     }
1508     element.setAttribute("exportValue", data.exportValue);
1509     element.tabIndex = DEFAULT_TAB_INDEX;
1510 
1511     element.addEventListener("change", event => {
1512       const { name, checked } = event.target;
1513       for (const checkbox of this._getElementsByName(name, /* skipId = */ id)) {
1514         const curChecked = checked && checkbox.exportValue === data.exportValue;
1515         if (checkbox.domElement) {
1516           checkbox.domElement.checked = curChecked;
1517         }
1518         storage.setValue(checkbox.id, { value: curChecked });
1519       }
1520       storage.setValue(id, { value: checked });
1521     });
1522 
1523     element.addEventListener("resetform", event => {
1524       const defaultValue = data.defaultFieldValue || "Off";
1525       event.target.checked = defaultValue === data.exportValue;
1526     });
1527 
1528     if (this.enableScripting && this.hasJSActions) {
1529       element.addEventListener("updatefromsandbox", jsEvent => {
1530         const actions = {
1531           value(event) {
1532             event.target.checked = event.detail.value !== "Off";
1533             storage.setValue(id, { value: event.target.checked });
1534           },
1535         };
1536         this._dispatchEventFromSandbox(actions, jsEvent);
1537       });
1538 
1539       this._setEventListeners(
1540         element,
1541         [
1542           ["change", "Validate"],
1543           ["change", "Action"],
1544           ["focus", "Focus"],
1545           ["blur", "Blur"],
1546           ["mousedown", "Mouse Down"],
1547           ["mouseenter", "Mouse Enter"],
1548           ["mouseleave", "Mouse Exit"],
1549           ["mouseup", "Mouse Up"],
1550         ],
1551         event => event.target.checked
1552       );
1553     }
1554 
1555     this._setBackgroundColor(element);
1556     this._setDefaultPropertiesFromJS(element);
1557 
1558     this.container.append(element);
1559     return this.container;
1560   }
1561 }
1562 
1563 class RadioButtonWidgetAnnotationElement extends WidgetAnnotationElement {
1564   constructor(parameters) {
1565     super(parameters, { isRenderable: parameters.renderForms });
1566   }
1567 
1568   render() {
1569     this.container.classList.add("buttonWidgetAnnotation", "radioButton");
1570     const storage = this.annotationStorage;
1571     const data = this.data;
1572     const id = data.id;
1573     let value = storage.getValue(id, {
1574       value: data.fieldValue === data.buttonValue,
1575     }).value;
1576     if (typeof value === "string") {
1577       // The value has been changed through js and set in annotationStorage.
1578       value = value !== data.buttonValue;
1579       storage.setValue(id, { value });
1580     }
1581 
1582     const element = document.createElement("input");
1583     GetElementsByNameSet.add(element);
1584     element.setAttribute("data-element-id", id);
1585 
1586     element.disabled = data.readOnly;
1587     this._setRequired(element, this.data.required);
1588     element.type = "radio";
1589     element.name = data.fieldName;
1590     if (value) {
1591       element.setAttribute("checked", true);
1592     }
1593     element.tabIndex = DEFAULT_TAB_INDEX;
1594 
1595     element.addEventListener("change", event => {
1596       const { name, checked } = event.target;
1597       for (const radio of this._getElementsByName(name, /* skipId = */ id)) {
1598         storage.setValue(radio.id, { value: false });
1599       }
1600       storage.setValue(id, { value: checked });
1601     });
1602 
1603     element.addEventListener("resetform", event => {
1604       const defaultValue = data.defaultFieldValue;
1605       event.target.checked =
1606         defaultValue !== null &&
1607         defaultValue !== undefined &&
1608         defaultValue === data.buttonValue;
1609     });
1610 
1611     if (this.enableScripting && this.hasJSActions) {
1612       const pdfButtonValue = data.buttonValue;
1613       element.addEventListener("updatefromsandbox", jsEvent => {
1614         const actions = {
1615           value: event => {
1616             const checked = pdfButtonValue === event.detail.value;
1617             for (const radio of this._getElementsByName(event.target.name)) {
1618               const curChecked = checked && radio.id === id;
1619               if (radio.domElement) {
1620                 radio.domElement.checked = curChecked;
1621               }
1622               storage.setValue(radio.id, { value: curChecked });
1623             }
1624           },
1625         };
1626         this._dispatchEventFromSandbox(actions, jsEvent);
1627       });
1628 
1629       this._setEventListeners(
1630         element,
1631         [
1632           ["change", "Validate"],
1633           ["change", "Action"],
1634           ["focus", "Focus"],
1635           ["blur", "Blur"],
1636           ["mousedown", "Mouse Down"],
1637           ["mouseenter", "Mouse Enter"],
1638           ["mouseleave", "Mouse Exit"],
1639           ["mouseup", "Mouse Up"],
1640         ],
1641         event => event.target.checked
1642       );
1643     }
1644 
1645     this._setBackgroundColor(element);
1646     this._setDefaultPropertiesFromJS(element);
1647 
1648     this.container.append(element);
1649     return this.container;
1650   }
1651 }
1652 
1653 class PushButtonWidgetAnnotationElement extends LinkAnnotationElement {
1654   constructor(parameters) {
1655     super(parameters, { ignoreBorder: parameters.data.hasAppearance });
1656   }
1657 
1658   render() {
1659     // The rendering and functionality of a push button widget annotation is
1660     // equal to that of a link annotation, but may have more functionality, such
1661     // as performing actions on form fields (resetting, submitting, et cetera).
1662     const container = super.render();
1663     container.classList.add("buttonWidgetAnnotation", "pushButton");
1664 
1665     if (this.data.alternativeText) {
1666       container.title = this.data.alternativeText;
1667     }
1668 
1669     const linkElement = container.lastChild;
1670     if (this.enableScripting && this.hasJSActions && linkElement) {
1671       this._setDefaultPropertiesFromJS(linkElement);
1672 
1673       linkElement.addEventListener("updatefromsandbox", jsEvent => {
1674         this._dispatchEventFromSandbox({}, jsEvent);
1675       });
1676     }
1677 
1678     return container;
1679   }
1680 }
1681 
1682 class ChoiceWidgetAnnotationElement extends WidgetAnnotationElement {
1683   constructor(parameters) {
1684     super(parameters, { isRenderable: parameters.renderForms });
1685   }
1686 
1687   render() {
1688     this.container.classList.add("choiceWidgetAnnotation");
1689     const storage = this.annotationStorage;
1690     const id = this.data.id;
1691 
1692     const storedData = storage.getValue(id, {
1693       value: this.data.fieldValue,
1694     });
1695 
1696     const selectElement = document.createElement("select");
1697     GetElementsByNameSet.add(selectElement);
1698     selectElement.setAttribute("data-element-id", id);
1699 
1700     selectElement.disabled = this.data.readOnly;
1701     this._setRequired(selectElement, this.data.required);
1702     selectElement.name = this.data.fieldName;
1703     selectElement.tabIndex = DEFAULT_TAB_INDEX;
1704 
1705     let addAnEmptyEntry = this.data.combo && this.data.options.length > 0;
1706 
1707     if (!this.data.combo) {
1708       // List boxes have a size and (optionally) multiple selection.
1709       selectElement.size = this.data.options.length;
1710       if (this.data.multiSelect) {
1711         selectElement.multiple = true;
1712       }
1713     }
1714 
1715     selectElement.addEventListener("resetform", event => {
1716       const defaultValue = this.data.defaultFieldValue;
1717       for (const option of selectElement.options) {
1718         option.selected = option.value === defaultValue;
1719       }
1720     });
1721 
1722     // Insert the options into the choice field.
1723     for (const option of this.data.options) {
1724       const optionElement = document.createElement("option");
1725       optionElement.textContent = option.displayValue;
1726       optionElement.value = option.exportValue;
1727       if (storedData.value.includes(option.exportValue)) {
1728         optionElement.setAttribute("selected", true);
1729         addAnEmptyEntry = false;
1730       }
1731       selectElement.append(optionElement);
1732     }
1733 
1734     let removeEmptyEntry = null;
1735     if (addAnEmptyEntry) {
1736       const noneOptionElement = document.createElement("option");
1737       noneOptionElement.value = " ";
1738       noneOptionElement.setAttribute("hidden", true);
1739       noneOptionElement.setAttribute("selected", true);
1740       selectElement.prepend(noneOptionElement);
1741 
1742       removeEmptyEntry = () => {
1743         noneOptionElement.remove();
1744         selectElement.removeEventListener("input", removeEmptyEntry);
1745         removeEmptyEntry = null;
1746       };
1747       selectElement.addEventListener("input", removeEmptyEntry);
1748     }
1749 
1750     const getValue = isExport => {
1751       const name = isExport ? "value" : "textContent";
1752       const { options, multiple } = selectElement;
1753       if (!multiple) {
1754         return options.selectedIndex === -1
1755           ? null
1756           : options[options.selectedIndex][name];
1757       }
1758       return Array.prototype.filter
1759         .call(options, option => option.selected)
1760         .map(option => option[name]);
1761     };
1762 
1763     let selectedValues = getValue(/* isExport */ false);
1764 
1765     const getItems = event => {
1766       const options = event.target.options;
1767       return Array.prototype.map.call(options, option => {
1768         return { displayValue: option.textContent, exportValue: option.value };
1769       });
1770     };
1771 
1772     if (this.enableScripting && this.hasJSActions) {
1773       selectElement.addEventListener("updatefromsandbox", jsEvent => {
1774         const actions = {
1775           value(event) {
1776             removeEmptyEntry?.();
1777             const value = event.detail.value;
1778             const values = new Set(Array.isArray(value) ? value : [value]);
1779             for (const option of selectElement.options) {
1780               option.selected = values.has(option.value);
1781             }
1782             storage.setValue(id, {
1783               value: getValue(/* isExport */ true),
1784             });
1785             selectedValues = getValue(/* isExport */ false);
1786           },
1787           multipleSelection(event) {
1788             selectElement.multiple = true;
1789           },
1790           remove(event) {
1791             const options = selectElement.options;
1792             const index = event.detail.remove;
1793             options[index].selected = false;
1794             selectElement.remove(index);
1795             if (options.length > 0) {
1796               const i = Array.prototype.findIndex.call(
1797                 options,
1798                 option => option.selected
1799               );
1800               if (i === -1) {
1801                 options[0].selected = true;
1802               }
1803             }
1804             storage.setValue(id, {
1805               value: getValue(/* isExport */ true),
1806               items: getItems(event),
1807             });
1808             selectedValues = getValue(/* isExport */ false);
1809           },
1810           clear(event) {
1811             while (selectElement.length !== 0) {
1812               selectElement.remove(0);
1813             }
1814             storage.setValue(id, { value: null, items: [] });
1815             selectedValues = getValue(/* isExport */ false);
1816           },
1817           insert(event) {
1818             const { index, displayValue, exportValue } = event.detail.insert;
1819             const selectChild = selectElement.children[index];
1820             const optionElement = document.createElement("option");
1821             optionElement.textContent = displayValue;
1822             optionElement.value = exportValue;
1823 
1824             if (selectChild) {
1825               selectChild.before(optionElement);
1826             } else {
1827               selectElement.append(optionElement);
1828             }
1829             storage.setValue(id, {
1830               value: getValue(/* isExport */ true),
1831               items: getItems(event),
1832             });
1833             selectedValues = getValue(/* isExport */ false);
1834           },
1835           items(event) {
1836             const { items } = event.detail;
1837             while (selectElement.length !== 0) {
1838               selectElement.remove(0);
1839             }
1840             for (const item of items) {
1841               const { displayValue, exportValue } = item;
1842               const optionElement = document.createElement("option");
1843               optionElement.textContent = displayValue;
1844               optionElement.value = exportValue;
1845               selectElement.append(optionElement);
1846             }
1847             if (selectElement.options.length > 0) {
1848               selectElement.options[0].selected = true;
1849             }
1850             storage.setValue(id, {
1851               value: getValue(/* isExport */ true),
1852               items: getItems(event),
1853             });
1854             selectedValues = getValue(/* isExport */ false);
1855           },
1856           indices(event) {
1857             const indices = new Set(event.detail.indices);
1858             for (const option of event.target.options) {
1859               option.selected = indices.has(option.index);
1860             }
1861             storage.setValue(id, {
1862               value: getValue(/* isExport */ true),
1863             });
1864             selectedValues = getValue(/* isExport */ false);
1865           },
1866           editable(event) {
1867             event.target.disabled = !event.detail.editable;
1868           },
1869         };
1870         this._dispatchEventFromSandbox(actions, jsEvent);
1871       });
1872 
1873       selectElement.addEventListener("input", event => {
1874         const exportValue = getValue(/* isExport */ true);
1875         storage.setValue(id, { value: exportValue });
1876 
1877         event.preventDefault();
1878 
1879         this.linkService.eventBus?.dispatch("dispatcheventinsandbox", {
1880           source: this,
1881           detail: {
1882             id,
1883             name: "Keystroke",
1884             value: selectedValues,
1885             changeEx: exportValue,
1886             willCommit: false,
1887             commitKey: 1,
1888             keyDown: false,
1889           },
1890         });
1891       });
1892 
1893       this._setEventListeners(
1894         selectElement,
1895         [
1896           ["focus", "Focus"],
1897           ["blur", "Blur"],
1898           ["mousedown", "Mouse Down"],
1899           ["mouseenter", "Mouse Enter"],
1900           ["mouseleave", "Mouse Exit"],
1901           ["mouseup", "Mouse Up"],
1902           ["input", "Action"],
1903           ["input", "Validate"],
1904         ],
1905         event => event.target.value
1906       );
1907     } else {
1908       selectElement.addEventListener("input", function (event) {
1909         storage.setValue(id, { value: getValue(/* isExport */ true) });
1910       });
1911     }
1912 
1913     if (this.data.combo) {
1914       this._setTextStyle(selectElement);
1915     } else {
1916       // Just use the default font size...
1917       // it's a bit hard to guess what is a good size.
1918     }
1919     this._setBackgroundColor(selectElement);
1920     this._setDefaultPropertiesFromJS(selectElement);
1921 
1922     this.container.append(selectElement);
1923     return this.container;
1924   }
1925 }
1926 
1927 class PopupAnnotationElement extends AnnotationElement {
1928   constructor(parameters) {
1929     const { data, elements } = parameters;
1930     const isRenderable = !!(
1931       data.titleObj?.str ||
1932       data.contentsObj?.str ||
1933       data.richText?.str
1934     );
1935     super(parameters, { isRenderable });
1936     this.elements = elements;
1937   }
1938 
1939   render() {
1940     this.container.classList.add("popupAnnotation");
1941 
1942     const popup = new PopupElement({
1943       container: this.container,
1944       color: this.data.color,
1945       titleObj: this.data.titleObj,
1946       modificationDate: this.data.modificationDate,
1947       contentsObj: this.data.contentsObj,
1948       richText: this.data.richText,
1949       rect: this.data.rect,
1950       parentRect: this.data.parentRect || null,
1951       parent: this.parent,
1952       elements: this.elements,
1953       open: this.data.open,
1954     });
1955 
1956     const elementIds = [];
1957     for (const element of this.elements) {
1958       element.popup = popup;
1959       elementIds.push(element.data.id);
1960       element.addHighlightArea();
1961     }
1962 
1963     this.container.setAttribute(
1964       "aria-controls",
1965       elementIds.map(id => `${AnnotationPrefix}${id}`).join(",")
1966     );
1967 
1968     return this.container;
1969   }
1970 }
1971 
1972 class PopupElement {
1973   #dateTimePromise = null;
1974 
1975   #boundKeyDown = this.#keyDown.bind(this);
1976 
1977   #boundHide = this.#hide.bind(this);
1978 
1979   #boundShow = this.#show.bind(this);
1980 
1981   #boundToggle = this.#toggle.bind(this);
1982 
1983   #color = null;
1984 
1985   #container = null;
1986 
1987   #contentsObj = null;
1988 
1989   #elements = null;
1990 
1991   #parent = null;
1992 
1993   #parentRect = null;
1994 
1995   #pinned = false;
1996 
1997   #popup = null;
1998 
1999   #rect = null;
2000 
2001   #richText = null;
2002 
2003   #titleObj = null;
2004 
2005   #wasVisible = false;
2006 
2007   constructor({
2008     container,
2009     color,
2010     elements,
2011     titleObj,
2012     modificationDate,
2013     contentsObj,
2014     richText,
2015     parent,
2016     rect,
2017     parentRect,
2018     open,
2019   }) {
2020     this.#container = container;
2021     this.#titleObj = titleObj;
2022     this.#contentsObj = contentsObj;
2023     this.#richText = richText;
2024     this.#parent = parent;
2025     this.#color = color;
2026     this.#rect = rect;
2027     this.#parentRect = parentRect;
2028     this.#elements = elements;
2029 
2030     const dateObject = PDFDateString.toDateObject(modificationDate);
2031     if (dateObject) {
2032       // The modification date is shown in the popup instead of the creation
2033       // date if it is available and can be parsed correctly, which is
2034       // consistent with other viewers such as Adobe Acrobat.
2035       this.#dateTimePromise = parent.l10n.get("annotation_date_string", {
2036         date: dateObject.toLocaleDateString(),
2037         time: dateObject.toLocaleTimeString(),
2038       });
2039     }
2040 
2041     this.trigger = elements.flatMap(e => e.getElementsToTriggerPopup());
2042     // Attach the event listeners to the trigger element.
2043     for (const element of this.trigger) {
2044       element.addEventListener("click", this.#boundToggle);
2045       element.addEventListener("mouseenter", this.#boundShow);
2046       element.addEventListener("mouseleave", this.#boundHide);
2047       if (typeof PDFJSDev !== "undefined" && PDFJSDev.test("TESTING")) {
2048         element.classList.add("popupTriggerArea");
2049       }
2050     }
2051 
2052     // Attach the event listener to toggle the popup with the keyboard.
2053     for (const element of elements) {
2054       element.container?.addEventListener("keydown", this.#boundKeyDown);
2055     }
2056 
2057     this.#container.hidden = true;
2058     if (open) {
2059       this.#toggle();
2060     }
2061 
2062     if (typeof PDFJSDev !== "undefined" && PDFJSDev.test("TESTING")) {
2063       // Since the popup is lazily created, we need to ensure that it'll be
2064       // created and displayed during reference tests.
2065       this.#parent.popupShow.push(async () => {
2066         if (this.#container.hidden) {
2067           this.#show();
2068         }
2069         if (this.#dateTimePromise) {
2070           await this.#dateTimePromise;
2071         }
2072       });
2073     }
2074   }
2075 
2076   render() {
2077     if (this.#popup) {
2078       return;
2079     }
2080 
2081     const {
2082       page: { view },
2083       viewport: {
2084         rawDims: { pageWidth, pageHeight, pageX, pageY },
2085       },
2086     } = this.#parent;
2087     const popup = (this.#popup = document.createElement("div"));
2088     popup.className = "popup";
2089 
2090     if (this.#color) {
2091       const baseColor = (popup.style.outlineColor = Util.makeHexColor(
2092         ...this.#color
2093       ));
2094       if (
2095         (typeof PDFJSDev !== "undefined" && PDFJSDev.test("MOZCENTRAL")) ||
2096         CSS.supports("background-color", "color-mix(in srgb, red 30%, white)")
2097       ) {
2098         popup.style.backgroundColor = `color-mix(in srgb, ${baseColor} 30%, white)`;
2099       } else {
2100         // color-mix isn't supported in some browsers hence this version.
2101         // See https://developer.mozilla.org/en-US/docs/Web/CSS/color_value/color-mix#browser_compatibility
2102         // TODO: Use color-mix when it's supported everywhere.
2103         // Enlighten the color.
2104         const BACKGROUND_ENLIGHT = 0.7;
2105         popup.style.backgroundColor = Util.makeHexColor(
2106           ...this.#color.map(c =>
2107             Math.floor(BACKGROUND_ENLIGHT * (255 - c) + c)
2108           )
2109         );
2110       }
2111     }
2112 
2113     const header = document.createElement("span");
2114     header.className = "header";
2115     const title = document.createElement("h1");
2116     header.append(title);
2117     ({ dir: title.dir, str: title.textContent } = this.#titleObj);
2118     popup.append(header);
2119 
2120     if (this.#dateTimePromise) {
2121       const modificationDate = document.createElement("span");
2122       modificationDate.classList.add("popupDate");
2123       this.#dateTimePromise.then(localized => {
2124         modificationDate.textContent = localized;
2125       });
2126       header.append(modificationDate);
2127     }
2128 
2129     const contentsObj = this.#contentsObj;
2130     const richText = this.#richText;
2131     if (
2132       richText?.str &&
2133       (!contentsObj?.str || contentsObj.str === richText.str)
2134     ) {
2135       XfaLayer.render({
2136         xfaHtml: richText.html,
2137         intent: "richText",
2138         div: popup,
2139       });
2140       popup.lastChild.classList.add("richText", "popupContent");
2141     } else {
2142       const contents = this._formatContents(contentsObj);
2143       popup.append(contents);
2144     }
2145 
2146     let useParentRect = !!this.#parentRect;
2147     let rect = useParentRect ? this.#parentRect : this.#rect;
2148     for (const element of this.#elements) {
2149       if (!rect || Util.intersect(element.data.rect, rect) !== null) {
2150         rect = element.data.rect;
2151         useParentRect = true;
2152         break;
2153       }
2154     }
2155 
2156     const normalizedRect = Util.normalizeRect([
2157       rect[0],
2158       view[3] - rect[1] + view[1],
2159       rect[2],
2160       view[3] - rect[3] + view[1],
2161     ]);
2162 
2163     const HORIZONTAL_SPACE_AFTER_ANNOTATION = 5;
2164     const parentWidth = useParentRect
2165       ? rect[2] - rect[0] + HORIZONTAL_SPACE_AFTER_ANNOTATION
2166       : 0;
2167     const popupLeft = normalizedRect[0] + parentWidth;
2168     const popupTop = normalizedRect[1];
2169 
2170     const { style } = this.#container;
2171     style.left = `${(100 * (popupLeft - pageX)) / pageWidth}%`;
2172     style.top = `${(100 * (popupTop - pageY)) / pageHeight}%`;
2173 
2174     this.#container.append(popup);
2175   }
2176 
2177   /**
2178    * Format the contents of the popup by adding newlines where necessary.
2179    *
2180    * @private
2181    * @param {Object<string, string>} contentsObj
2182    * @memberof PopupElement
2183    * @returns {HTMLParagraphElement}
2184    */
2185   _formatContents({ str, dir }) {
2186     const p = document.createElement("p");
2187     p.classList.add("popupContent");
2188     p.dir = dir;
2189     const lines = str.split(/(?:\r\n?|\n)/);
2190     for (let i = 0, ii = lines.length; i < ii; ++i) {
2191       const line = lines[i];
2192       p.append(document.createTextNode(line));
2193       if (i < ii - 1) {
2194         p.append(document.createElement("br"));
2195       }
2196     }
2197     return p;
2198   }
2199 
2200   #keyDown(event) {
2201     if (event.altKey || event.shiftKey || event.ctrlKey || event.metaKey) {
2202       return;
2203     }
2204 
2205     if (event.key === "Enter" || (event.key === "Escape" && this.#pinned)) {
2206       this.#toggle();
2207     }
2208   }
2209 
2210   /**
2211    * Toggle the visibility of the popup.
2212    */
2213   #toggle() {
2214     this.#pinned = !this.#pinned;
2215     if (this.#pinned) {
2216       this.#show();
2217       this.#container.addEventListener("click", this.#boundToggle);
2218       this.#container.addEventListener("keydown", this.#boundKeyDown);
2219     } else {
2220       this.#hide();
2221       this.#container.removeEventListener("click", this.#boundToggle);
2222       this.#container.removeEventListener("keydown", this.#boundKeyDown);
2223     }
2224   }
2225 
2226   /**
2227    * Show the popup.
2228    */
2229   #show() {
2230     if (!this.#popup) {
2231       this.render();
2232     }
2233     if (!this.isVisible) {
2234       this.#container.hidden = false;
2235       this.#container.style.zIndex =
2236         parseInt(this.#container.style.zIndex) + 1000;
2237     } else if (this.#pinned) {
2238       this.#container.classList.add("focused");
2239     }
2240   }
2241 
2242   /**
2243    * Hide the popup.
2244    */
2245   #hide() {
2246     this.#container.classList.remove("focused");
2247     if (this.#pinned || !this.isVisible) {
2248       return;
2249     }
2250     this.#container.hidden = true;
2251     this.#container.style.zIndex =
2252       parseInt(this.#container.style.zIndex) - 1000;
2253   }
2254 
2255   forceHide() {
2256     this.#wasVisible = this.isVisible;
2257     if (!this.#wasVisible) {
2258       return;
2259     }
2260     this.#container.hidden = true;
2261   }
2262 
2263   maybeShow() {
2264     if (!this.#wasVisible) {
2265       return;
2266     }
2267     this.#wasVisible = false;
2268     this.#container.hidden = false;
2269   }
2270 
2271   get isVisible() {
2272     return this.#container.hidden === false;
2273   }
2274 }
2275 
2276 class FreeTextAnnotationElement extends AnnotationElement {
2277   constructor(parameters) {
2278     const isRenderable = !!(
2279       parameters.data.popupRef ||
2280       parameters.data.titleObj?.str ||
2281       parameters.data.contentsObj?.str ||
2282       parameters.data.richText?.str
2283     );
2284     super(parameters, { isRenderable, ignoreBorder: true });
2285     this.textContent = parameters.data.textContent;
2286     this.textPosition = parameters.data.textPosition;
2287     this.annotationEditorType = AnnotationEditorType.FREETEXT;
2288   }
2289 
2290   render() {
2291     this.container.classList.add("freeTextAnnotation");
2292 
2293     if (this.textContent) {
2294       const content = document.createElement("div");
2295       content.classList.add("annotationTextContent");
2296       content.setAttribute("role", "comment");
2297       for (const line of this.textContent) {
2298         const lineSpan = document.createElement("span");
2299         lineSpan.textContent = line;
2300         content.append(lineSpan);
2301       }
2302       this.container.append(content);
2303     }
2304 
2305     if (!this.data.popupRef) {
2306       this._createPopup();
2307     }
2308 
2309     this._editOnDoubleClick();
2310 
2311     return this.container;
2312   }
2313 }
2314 
2315 class LineAnnotationElement extends AnnotationElement {
2316   #line = null;
2317 
2318   constructor(parameters) {
2319     const isRenderable = !!(
2320       parameters.data.popupRef ||
2321       parameters.data.titleObj?.str ||
2322       parameters.data.contentsObj?.str ||
2323       parameters.data.richText?.str
2324     );
2325     super(parameters, { isRenderable, ignoreBorder: true });
2326   }
2327 
2328   render() {
2329     this.container.classList.add("lineAnnotation");
2330 
2331     // Create an invisible line with the same starting and ending coordinates
2332     // that acts as the trigger for the popup. Only the line itself should
2333     // trigger the popup, not the entire container.
2334     const data = this.data;
2335     const { width, height } = getRectDims(data.rect);
2336     const svg = this.svgFactory.create(
2337       width,
2338       height,
2339       /* skipDimensions = */ true
2340     );
2341 
2342     // PDF coordinates are calculated from a bottom left origin, so transform
2343     // the line coordinates to a top left origin for the SVG element.
2344     const line = (this.#line = this.svgFactory.createElement("svg:line"));
2345     line.setAttribute("x1", data.rect[2] - data.lineCoordinates[0]);
2346     line.setAttribute("y1", data.rect[3] - data.lineCoordinates[1]);
2347     line.setAttribute("x2", data.rect[2] - data.lineCoordinates[2]);
2348     line.setAttribute("y2", data.rect[3] - data.lineCoordinates[3]);
2349     // Ensure that the 'stroke-width' is always non-zero, since otherwise it
2350     // won't be possible to open/close the popup (note e.g. issue 11122).
2351     line.setAttribute("stroke-width", data.borderStyle.width || 1);
2352     line.setAttribute("stroke", "transparent");
2353     line.setAttribute("fill", "transparent");
2354 
2355     svg.append(line);
2356     this.container.append(svg);
2357 
2358     // Create the popup ourselves so that we can bind it to the line instead
2359     // of to the entire container (which is the default).
2360     if (!data.popupRef) {
2361       this._createPopup();
2362     }
2363 
2364     return this.container;
2365   }
2366 
2367   getElementsToTriggerPopup() {
2368     return this.#line;
2369   }
2370 
2371   addHighlightArea() {
2372     this.container.classList.add("highlightArea");
2373   }
2374 }
2375 
2376 class SquareAnnotationElement extends AnnotationElement {
2377   #square = null;
2378 
2379   constructor(parameters) {
2380     const isRenderable = !!(
2381       parameters.data.popupRef ||
2382       parameters.data.titleObj?.str ||
2383       parameters.data.contentsObj?.str ||
2384       parameters.data.richText?.str
2385     );
2386     super(parameters, { isRenderable, ignoreBorder: true });
2387   }
2388 
2389   render() {
2390     this.container.classList.add("squareAnnotation");
2391 
2392     // Create an invisible square with the same rectangle that acts as the
2393     // trigger for the popup. Only the square itself should trigger the
2394     // popup, not the entire container.
2395     const data = this.data;
2396     const { width, height } = getRectDims(data.rect);
2397     const svg = this.svgFactory.create(
2398       width,
2399       height,
2400       /* skipDimensions = */ true
2401     );
2402 
2403     // The browser draws half of the borders inside the square and half of
2404     // the borders outside the square by default. This behavior cannot be
2405     // changed programmatically, so correct for that here.
2406     const borderWidth = data.borderStyle.width;
2407     const square = (this.#square = this.svgFactory.createElement("svg:rect"));
2408     square.setAttribute("x", borderWidth / 2);
2409     square.setAttribute("y", borderWidth / 2);
2410     square.setAttribute("width", width - borderWidth);
2411     square.setAttribute("height", height - borderWidth);
2412     // Ensure that the 'stroke-width' is always non-zero, since otherwise it
2413     // won't be possible to open/close the popup (note e.g. issue 11122).
2414     square.setAttribute("stroke-width", borderWidth || 1);
2415     square.setAttribute("stroke", "transparent");
2416     square.setAttribute("fill", "transparent");
2417 
2418     svg.append(square);
2419     this.container.append(svg);
2420 
2421     // Create the popup ourselves so that we can bind it to the square instead
2422     // of to the entire container (which is the default).
2423     if (!data.popupRef) {
2424       this._createPopup();
2425     }
2426 
2427     return this.container;
2428   }
2429 
2430   getElementsToTriggerPopup() {
2431     return this.#square;
2432   }
2433 
2434   addHighlightArea() {
2435     this.container.classList.add("highlightArea");
2436   }
2437 }
2438 
2439 class CircleAnnotationElement extends AnnotationElement {
2440   #circle = null;
2441 
2442   constructor(parameters) {
2443     const isRenderable = !!(
2444       parameters.data.popupRef ||
2445       parameters.data.titleObj?.str ||
2446       parameters.data.contentsObj?.str ||
2447       parameters.data.richText?.str
2448     );
2449     super(parameters, { isRenderable, ignoreBorder: true });
2450   }
2451 
2452   render() {
2453     this.container.classList.add("circleAnnotation");
2454 
2455     // Create an invisible circle with the same ellipse that acts as the
2456     // trigger for the popup. Only the circle itself should trigger the
2457     // popup, not the entire container.
2458     const data = this.data;
2459     const { width, height } = getRectDims(data.rect);
2460     const svg = this.svgFactory.create(
2461       width,
2462       height,
2463       /* skipDimensions = */ true
2464     );
2465 
2466     // The browser draws half of the borders inside the circle and half of
2467     // the borders outside the circle by default. This behavior cannot be
2468     // changed programmatically, so correct for that here.
2469     const borderWidth = data.borderStyle.width;
2470     const circle = (this.#circle =
2471       this.svgFactory.createElement("svg:ellipse"));
2472     circle.setAttribute("cx", width / 2);
2473     circle.setAttribute("cy", height / 2);
2474     circle.setAttribute("rx", width / 2 - borderWidth / 2);
2475     circle.setAttribute("ry", height / 2 - borderWidth / 2);
2476     // Ensure that the 'stroke-width' is always non-zero, since otherwise it
2477     // won't be possible to open/close the popup (note e.g. issue 11122).
2478     circle.setAttribute("stroke-width", borderWidth || 1);
2479     circle.setAttribute("stroke", "transparent");
2480     circle.setAttribute("fill", "transparent");
2481 
2482     svg.append(circle);
2483     this.container.append(svg);
2484 
2485     // Create the popup ourselves so that we can bind it to the circle instead
2486     // of to the entire container (which is the default).
2487     if (!data.popupRef) {
2488       this._createPopup();
2489     }
2490 
2491     return this.container;
2492   }
2493 
2494   getElementsToTriggerPopup() {
2495     return this.#circle;
2496   }
2497 
2498   addHighlightArea() {
2499     this.container.classList.add("highlightArea");
2500   }
2501 }
2502 
2503 class PolylineAnnotationElement extends AnnotationElement {
2504   #polyline = null;
2505 
2506   constructor(parameters) {
2507     const isRenderable = !!(
2508       parameters.data.popupRef ||
2509       parameters.data.titleObj?.str ||
2510       parameters.data.contentsObj?.str ||
2511       parameters.data.richText?.str
2512     );
2513     super(parameters, { isRenderable, ignoreBorder: true });
2514 
2515     this.containerClassName = "polylineAnnotation";
2516     this.svgElementName = "svg:polyline";
2517   }
2518 
2519   render() {
2520     this.container.classList.add(this.containerClassName);
2521 
2522     // Create an invisible polyline with the same points that acts as the
2523     // trigger for the popup. Only the polyline itself should trigger the
2524     // popup, not the entire container.
2525     const data = this.data;
2526     const { width, height } = getRectDims(data.rect);
2527     const svg = this.svgFactory.create(
2528       width,
2529       height,
2530       /* skipDimensions = */ true
2531     );
2532 
2533     // Convert the vertices array to a single points string that the SVG
2534     // polyline element expects ("x1,y1 x2,y2 ..."). PDF coordinates are
2535     // calculated from a bottom left origin, so transform the polyline
2536     // coordinates to a top left origin for the SVG element.
2537     let points = [];
2538     for (const coordinate of data.vertices) {
2539       const x = coordinate.x - data.rect[0];
2540       const y = data.rect[3] - coordinate.y;
2541       points.push(x + "," + y);
2542     }
2543     points = points.join(" ");
2544 
2545     const polyline = (this.#polyline = this.svgFactory.createElement(
2546       this.svgElementName
2547     ));
2548     polyline.setAttribute("points", points);
2549     // Ensure that the 'stroke-width' is always non-zero, since otherwise it
2550     // won't be possible to open/close the popup (note e.g. issue 11122).
2551     polyline.setAttribute("stroke-width", data.borderStyle.width || 1);
2552     polyline.setAttribute("stroke", "transparent");
2553     polyline.setAttribute("fill", "transparent");
2554 
2555     svg.append(polyline);
2556     this.container.append(svg);
2557 
2558     // Create the popup ourselves so that we can bind it to the polyline
2559     // instead of to the entire container (which is the default).
2560     if (!data.popupRef) {
2561       this._createPopup(polyline, data);
2562     }
2563 
2564     return this.container;
2565   }
2566 
2567   getElementsToTriggerPopup() {
2568     return this.#polyline;
2569   }
2570 
2571   addHighlightArea() {
2572     this.container.classList.add("highlightArea");
2573   }
2574 }
2575 
2576 class PolygonAnnotationElement extends PolylineAnnotationElement {
2577   constructor(parameters) {
2578     // Polygons are specific forms of polylines, so reuse their logic.
2579     super(parameters);
2580 
2581     this.containerClassName = "polygonAnnotation";
2582     this.svgElementName = "svg:polygon";
2583   }
2584 }
2585 
2586 class CaretAnnotationElement extends AnnotationElement {
2587   constructor(parameters) {
2588     const isRenderable = !!(
2589       parameters.data.popupRef ||
2590       parameters.data.titleObj?.str ||
2591       parameters.data.contentsObj?.str ||
2592       parameters.data.richText?.str
2593     );
2594     super(parameters, { isRenderable, ignoreBorder: true });
2595   }
2596 
2597   render() {
2598     this.container.classList.add("caretAnnotation");
2599 
2600     if (!this.data.popupRef) {
2601       this._createPopup();
2602     }
2603     return this.container;
2604   }
2605 }
2606 
2607 class InkAnnotationElement extends AnnotationElement {
2608   #polylines = [];
2609 
2610   constructor(parameters) {
2611     const isRenderable = !!(
2612       parameters.data.popupRef ||
2613       parameters.data.titleObj?.str ||
2614       parameters.data.contentsObj?.str ||
2615       parameters.data.richText?.str
2616     );
2617     super(parameters, { isRenderable, ignoreBorder: true });
2618 
2619     this.containerClassName = "inkAnnotation";
2620 
2621     // Use the polyline SVG element since it allows us to use coordinates
2622     // directly and to draw both straight lines and curves.
2623     this.svgElementName = "svg:polyline";
2624     this.annotationEditorType = AnnotationEditorType.INK;
2625   }
2626 
2627   render() {
2628     this.container.classList.add(this.containerClassName);
2629 
2630     // Create an invisible polyline with the same points that acts as the
2631     // trigger for the popup.
2632     const data = this.data;
2633     const { width, height } = getRectDims(data.rect);
2634     const svg = this.svgFactory.create(
2635       width,
2636       height,
2637       /* skipDimensions = */ true
2638     );
2639 
2640     for (const inkList of data.inkLists) {
2641       // Convert the ink list to a single points string that the SVG
2642       // polyline element expects ("x1,y1 x2,y2 ..."). PDF coordinates are
2643       // calculated from a bottom left origin, so transform the polyline
2644       // coordinates to a top left origin for the SVG element.
2645       let points = [];
2646       for (const coordinate of inkList) {
2647         const x = coordinate.x - data.rect[0];
2648         const y = data.rect[3] - coordinate.y;
2649         points.push(`${x},${y}`);
2650       }
2651       points = points.join(" ");
2652 
2653       const polyline = this.svgFactory.createElement(this.svgElementName);
2654       this.#polylines.push(polyline);
2655       polyline.setAttribute("points", points);
2656       // Ensure that the 'stroke-width' is always non-zero, since otherwise it
2657       // won't be possible to open/close the popup (note e.g. issue 11122).
2658       polyline.setAttribute("stroke-width", data.borderStyle.width || 1);
2659       polyline.setAttribute("stroke", "transparent");
2660       polyline.setAttribute("fill", "transparent");
2661 
2662       // Create the popup ourselves so that we can bind it to the polyline
2663       // instead of to the entire container (which is the default).
2664       if (!data.popupRef) {
2665         this._createPopup(polyline, data);
2666       }
2667 
2668       svg.append(polyline);
2669     }
2670 
2671     this.container.append(svg);
2672     return this.container;
2673   }
2674 
2675   getElementsToTriggerPopup() {
2676     return this.#polylines;
2677   }
2678 
2679   addHighlightArea() {
2680     this.container.classList.add("highlightArea");
2681   }
2682 }
2683 
2684 class HighlightAnnotationElement extends AnnotationElement {
2685   constructor(parameters) {
2686     const isRenderable = !!(
2687       parameters.data.popupRef ||
2688       parameters.data.titleObj?.str ||
2689       parameters.data.contentsObj?.str ||
2690       parameters.data.richText?.str
2691     );
2692     super(parameters, {
2693       isRenderable,
2694       ignoreBorder: true,
2695       createQuadrilaterals: true,
2696     });
2697   }
2698 
2699   render() {
2700     if (!this.data.popupRef) {
2701       this._createPopup();
2702     }
2703 
2704     this.container.classList.add("highlightAnnotation");
2705     return this.container;
2706   }
2707 }
2708 
2709 class UnderlineAnnotationElement extends AnnotationElement {
2710   constructor(parameters) {
2711     const isRenderable = !!(
2712       parameters.data.popupRef ||
2713       parameters.data.titleObj?.str ||
2714       parameters.data.contentsObj?.str ||
2715       parameters.data.richText?.str
2716     );
2717     super(parameters, {
2718       isRenderable,
2719       ignoreBorder: true,
2720       createQuadrilaterals: true,
2721     });
2722   }
2723 
2724   render() {
2725     if (!this.data.popupRef) {
2726       this._createPopup();
2727     }
2728 
2729     this.container.classList.add("underlineAnnotation");
2730     return this.container;
2731   }
2732 }
2733 
2734 class SquigglyAnnotationElement extends AnnotationElement {
2735   constructor(parameters) {
2736     const isRenderable = !!(
2737       parameters.data.popupRef ||
2738       parameters.data.titleObj?.str ||
2739       parameters.data.contentsObj?.str ||
2740       parameters.data.richText?.str
2741     );
2742     super(parameters, {
2743       isRenderable,
2744       ignoreBorder: true,
2745       createQuadrilaterals: true,
2746     });
2747   }
2748 
2749   render() {
2750     if (!this.data.popupRef) {
2751       this._createPopup();
2752     }
2753 
2754     this.container.classList.add("squigglyAnnotation");
2755     return this.container;
2756   }
2757 }
2758 
2759 class StrikeOutAnnotationElement extends AnnotationElement {
2760   constructor(parameters) {
2761     const isRenderable = !!(
2762       parameters.data.popupRef ||
2763       parameters.data.titleObj?.str ||
2764       parameters.data.contentsObj?.str ||
2765       parameters.data.richText?.str
2766     );
2767     super(parameters, {
2768       isRenderable,
2769       ignoreBorder: true,
2770       createQuadrilaterals: true,
2771     });
2772   }
2773 
2774   render() {
2775     if (!this.data.popupRef) {
2776       this._createPopup();
2777     }
2778 
2779     this.container.classList.add("strikeoutAnnotation");
2780     return this.container;
2781   }
2782 }
2783 
2784 class StampAnnotationElement extends AnnotationElement {
2785   constructor(parameters) {
2786     const isRenderable = !!(
2787       parameters.data.popupRef ||
2788       parameters.data.titleObj?.str ||
2789       parameters.data.contentsObj?.str ||
2790       parameters.data.richText?.str
2791     );
2792     super(parameters, { isRenderable, ignoreBorder: true });
2793   }
2794 
2795   render() {
2796     this.container.classList.add("stampAnnotation");
2797 
2798     if (!this.data.popupRef) {
2799       this._createPopup();
2800     }
2801     return this.container;
2802   }
2803 }
2804 
2805 class FileAttachmentAnnotationElement extends AnnotationElement {
2806   #trigger = null;
2807 
2808   constructor(parameters) {
2809     super(parameters, { isRenderable: true });
2810 
2811     const { filename, content } = this.data.file;
2812     this.filename = getFilenameFromUrl(filename, /* onlyStripPath = */ true);
2813     this.content = content;
2814 
2815     this.linkService.eventBus?.dispatch("fileattachmentannotation", {
2816       source: this,
2817       filename,
2818       content,
2819     });
2820   }
2821 
2822   render() {
2823     this.container.classList.add("fileAttachmentAnnotation");
2824 
2825     const { data } = this;
2826     let trigger;
2827     if (data.hasAppearance || data.fillAlpha === 0) {
2828       trigger = document.createElement("div");
2829     } else {
2830       // Unfortunately it seems that it's not clearly specified exactly what
2831       // names are actually valid, since Table 184 contains:
2832       //   Conforming readers shall provide predefined icon appearances for at
2833       //   least the following standard names: GraphPushPin, PaperclipTag.
2834       //   Additional names may be supported as well. Default value: PushPin.
2835       trigger = document.createElement("img");
2836       trigger.src = `${this.imageResourcesPath}annotation-${
2837         /paperclip/i.test(data.name) ? "paperclip" : "pushpin"
2838       }.svg`;
2839 
2840       if (data.fillAlpha && data.fillAlpha < 1) {
2841         trigger.style = `filter: opacity(${Math.round(
2842           data.fillAlpha * 100
2843         )}%);`;
2844 
2845         if (typeof PDFJSDev !== "undefined" && PDFJSDev.test("TESTING")) {
2846           this.container.classList.add("hasFillAlpha");
2847         }
2848       }
2849     }
2850     trigger.classList.add("popupTriggerArea");
2851     trigger.addEventListener("dblclick", this._download.bind(this));
2852     this.#trigger = trigger;
2853 
2854     if (
2855       !data.popupRef &&
2856       (data.titleObj?.str || data.contentsObj?.str || data.richText)
2857     ) {
2858       this._createPopup();
2859     }
2860 
2861     this.container.append(trigger);
2862     return this.container;
2863   }
2864 
2865   getElementsToTriggerPopup() {
2866     return this.#trigger;
2867   }
2868 
2869   addHighlightArea() {
2870     this.container.classList.add("highlightArea");
2871   }
2872 
2873   /**
2874    * Download the file attachment associated with this annotation.
2875    *
2876    * @private
2877    * @memberof FileAttachmentAnnotationElement
2878    */
2879   _download() {
2880     this.downloadManager?.openOrDownloadData(
2881       this.container,
2882       this.content,
2883       this.filename
2884     );
2885   }
2886 }
2887 
2888 /**
2889  * @typedef {Object} AnnotationLayerParameters
2890  * @property {PageViewport} viewport
2891  * @property {HTMLDivElement} div
2892  * @property {Array} annotations
2893  * @property {PDFPageProxy} page
2894  * @property {IPDFLinkService} linkService
2895  * @property {IDownloadManager} downloadManager
2896  * @property {AnnotationStorage} [annotationStorage]
2897  * @property {string} [imageResourcesPath] - Path for image resources, mainly
2898  *   for annotation icons. Include trailing slash.
2899  * @property {boolean} renderForms
2900  * @property {boolean} [enableScripting] - Enable embedded script execution.
2901  * @property {boolean} [hasJSActions] - Some fields have JS actions.
2902  *   The default value is `false`.
2903  * @property {Object<string, Array<Object>> | null} [fieldObjects]
2904  * @property {Map<string, HTMLCanvasElement>} [annotationCanvasMap]
2905  * @property {TextAccessibilityManager} [accessibilityManager]
2906  */
2907 
2908 /**
2909  * Manage the layer containing all the annotations.
2910  */
2911 class AnnotationLayer {
2912   #accessibilityManager = null;
2913 
2914   #annotationCanvasMap = null;
2915 
2916   #editableAnnotations = new Map();
2917 
2918   constructor({
2919     div,
2920     accessibilityManager,
2921     annotationCanvasMap,
2922     l10n,
2923     page,
2924     viewport,
2925   }) {
2926     this.div = div;
2927     this.#accessibilityManager = accessibilityManager;
2928     this.#annotationCanvasMap = annotationCanvasMap;
2929     this.l10n = l10n;
2930     this.page = page;
2931     this.viewport = viewport;
2932     this.zIndex = 0;
2933 
2934     if (
2935       typeof PDFJSDev !== "undefined" &&
2936       PDFJSDev.test("GENERIC && !TESTING")
2937     ) {
2938       this.l10n ||= NullL10n;
2939     }
2940     if (typeof PDFJSDev !== "undefined" && PDFJSDev.test("TESTING")) {
2941       // For testing purposes.
2942       Object.defineProperty(this, "showPopups", {
2943         value: async () => {
2944           for (const show of this.popupShow) {
2945             await show();
2946           }
2947         },
2948       });
2949       this.popupShow = [];
2950     }
2951   }
2952 
2953   #appendElement(element, id) {
2954     const contentElement = element.firstChild || element;
2955     contentElement.id = `${AnnotationPrefix}${id}`;
2956 
2957     this.div.append(element);
2958     this.#accessibilityManager?.moveElementInDOM(
2959       this.div,
2960       element,
2961       contentElement,
2962       /* isRemovable = */ false
2963     );
2964   }
2965 
2966   /**
2967    * Render a new annotation layer with all annotation elements.
2968    *
2969    * @param {AnnotationLayerParameters} params
2970    * @memberof AnnotationLayer
2971    */
2972   async render(params) {
2973     const { annotations } = params;
2974     const layer = this.div;
2975     setLayerDimensions(layer, this.viewport);
2976 
2977     const popupToElements = new Map();
2978     const elementParams = {
2979       data: null,
2980       layer,
2981       linkService: params.linkService,
2982       downloadManager: params.downloadManager,
2983       imageResourcesPath: params.imageResourcesPath || "",
2984       renderForms: params.renderForms !== false,
2985       svgFactory: new DOMSVGFactory(),
2986       annotationStorage: params.annotationStorage || new AnnotationStorage(),
2987       enableScripting: params.enableScripting === true,
2988       hasJSActions: params.hasJSActions,
2989       fieldObjects: params.fieldObjects,
2990       parent: this,
2991       elements: null,
2992     };
2993 
2994     for (const data of annotations) {
2995       if (data.noHTML) {
2996         continue;
2997       }
2998       const isPopupAnnotation = data.annotationType === AnnotationType.POPUP;
2999       if (!isPopupAnnotation) {
3000         const { width, height } = getRectDims(data.rect);
3001         if (width <= 0 || height <= 0) {
3002           continue; // Ignore empty annotations.
3003         }
3004       } else {
3005         const elements = popupToElements.get(data.id);
3006         if (!elements) {
3007           // Ignore popup annotations without a corresponding annotation.
3008           continue;
3009         }
3010         elementParams.elements = elements;
3011       }
3012       elementParams.data = data;
3013       const element = AnnotationElementFactory.create(elementParams);
3014 
3015       if (!element.isRenderable) {
3016         continue;
3017       }
3018 
3019       if (!isPopupAnnotation && data.popupRef) {
3020         const elements = popupToElements.get(data.popupRef);
3021         if (!elements) {
3022           popupToElements.set(data.popupRef, [element]);
3023         } else {
3024           elements.push(element);
3025         }
3026       }
3027 
3028       if (element.annotationEditorType > 0) {
3029         this.#editableAnnotations.set(element.data.id, element);
3030       }
3031 
3032       const rendered = element.render();
3033       if (data.hidden) {
3034         rendered.style.visibility = "hidden";
3035       }
3036       this.#appendElement(rendered, data.id);
3037     }
3038 
3039     this.#setAnnotationCanvasMap();
3040 
3041     await this.l10n.translate(layer);
3042   }
3043 
3044   /**
3045    * Update the annotation elements on existing annotation layer.
3046    *
3047    * @param {AnnotationLayerParameters} viewport
3048    * @memberof AnnotationLayer
3049    */
3050   update({ viewport }) {
3051     const layer = this.div;
3052     this.viewport = viewport;
3053     setLayerDimensions(layer, { rotation: viewport.rotation });
3054 
3055     this.#setAnnotationCanvasMap();
3056     layer.hidden = false;
3057   }
3058 
3059   #setAnnotationCanvasMap() {
3060     if (!this.#annotationCanvasMap) {
3061       return;
3062     }
3063     const layer = this.div;
3064     for (const [id, canvas] of this.#annotationCanvasMap) {
3065       const element = layer.querySelector(`[data-annotation-id="${id}"]`);
3066       if (!element) {
3067         continue;
3068       }
3069 
3070       const { firstChild } = element;
3071       if (!firstChild) {
3072         element.append(canvas);
3073       } else if (firstChild.nodeName === "CANVAS") {
3074         firstChild.replaceWith(canvas);
3075       } else {
3076         firstChild.before(canvas);
3077       }
3078     }
3079     this.#annotationCanvasMap.clear();
3080   }
3081 
3082   getEditableAnnotations() {
3083     return Array.from(this.#editableAnnotations.values());
3084   }
3085 
3086   getEditableAnnotation(id) {
3087     return this.#editableAnnotations.get(id);
3088   }
3089 }
3090 
3091 export {
3092   AnnotationLayer,
3093   FreeTextAnnotationElement,
3094   InkAnnotationElement,
3095   StampAnnotationElement,
3096 };
</code>

Your task:
You are a software tester at pdf.js.
1. Write exactly one javascript test `it("...", async () => {...})` block.
2. Your test must fail on the code before the patch, and pass after, hence the test will verify that the patch resolves the issue.
3. The test must be self-contained and to-the-point.
4. Use only the provided imports (respect the paths exactly how they are given) by importing dynamically for compatibility with Node.js — no new dependencies. You can use the PDF file for testing as follows:
const { getDocument } = await import('../../src/display/api.js');
const { buildGetDocumentParams } = await import('./test_utils.js');
const loadingTask = getDocument(buildGetDocumentParams('bug1851498.pdf'))
5. Return only the javascript code (no comments or explanations).

Example structure:
it("should <describe behavior>", async () => {
  const { example } = await import("../../src/core/example.js");
  <initialize required variables>;
  <define expected variable>;
  <generate actual variables>;
  <compare expected with actual>;
});

