Before you begin:
- Keep going until the job is completely solved — don’t stop halfway.
- If you’re unsure about the behavior, reread the provided patch carefully; do not hallucinate.
- Plan your approach before writing code by reflecting on whether the test truly fails before and passes after.

Issue:
<issue>
FreeText annotation isn't displayed
</issue>

PDF File:
<pdf>
bug1851498.pdf
</pdf>

Patch:
<patch>
diff --git a/src/display/annotation_layer.js b/src/display/annotation_layer.js
--- a/src/display/annotation_layer.js
+++ b/src/display/annotation_layer.js
@@ -190,6 +190,14 @@ class AnnotationElement {
     }
   }
 
+  static _hasPopupData({ titleObj, contentsObj, richText }) {
+    return !!(titleObj?.str || contentsObj?.str || richText?.str);
+  }
+
+  get hasPopupData() {
+    return AnnotationElement._hasPopupData(this.data);
+  }
+
   /**
    * Create an empty container for the annotation's HTML element.
    *
@@ -956,13 +964,7 @@ class LinkAnnotationElement extends AnnotationElement {
 
 class TextAnnotationElement extends AnnotationElement {
   constructor(parameters) {
-    const isRenderable = !!(
-      parameters.data.popupRef ||
-      parameters.data.titleObj?.str ||
-      parameters.data.contentsObj?.str ||
-      parameters.data.richText?.str
-    );
-    super(parameters, { isRenderable });
+    super(parameters, { isRenderable: true });
   }
 
   render() {
@@ -978,7 +980,7 @@ class TextAnnotationElement extends AnnotationElement {
     image.dataset.l10nId = "text_annotation_type";
     image.dataset.l10nArgs = JSON.stringify({ type: this.data.name });
 
-    if (!this.data.popupRef) {
+    if (!this.data.popupRef && this.hasPopupData) {
       this._createPopup();
     }
 
@@ -1927,12 +1929,7 @@ class ChoiceWidgetAnnotationElement extends WidgetAnnotationElement {
 class PopupAnnotationElement extends AnnotationElement {
   constructor(parameters) {
     const { data, elements } = parameters;
-    const isRenderable = !!(
-      data.titleObj?.str ||
-      data.contentsObj?.str ||
-      data.richText?.str
-    );
-    super(parameters, { isRenderable });
+    super(parameters, { isRenderable: AnnotationElement._hasPopupData(data) });
     this.elements = elements;
   }
 
@@ -2044,9 +2041,7 @@ class PopupElement {
       element.addEventListener("click", this.#boundToggle);
       element.addEventListener("mouseenter", this.#boundShow);
       element.addEventListener("mouseleave", this.#boundHide);
-      if (typeof PDFJSDev !== "undefined" && PDFJSDev.test("TESTING")) {
-        element.classList.add("popupTriggerArea");
-      }
+      element.classList.add("popupTriggerArea");
     }
 
     // Attach the event listener to toggle the popup with the keyboard.
@@ -2275,13 +2270,7 @@ class PopupElement {
 
 class FreeTextAnnotationElement extends AnnotationElement {
   constructor(parameters) {
-    const isRenderable = !!(
-      parameters.data.popupRef ||
-      parameters.data.titleObj?.str ||
-      parameters.data.contentsObj?.str ||
-      parameters.data.richText?.str
-    );
-    super(parameters, { isRenderable, ignoreBorder: true });
+    super(parameters, { isRenderable: true, ignoreBorder: true });
     this.textContent = parameters.data.textContent;
     this.textPosition = parameters.data.textPosition;
     this.annotationEditorType = AnnotationEditorType.FREETEXT;
@@ -2302,7 +2291,7 @@ class FreeTextAnnotationElement extends AnnotationElement {
       this.container.append(content);
     }
 
-    if (!this.data.popupRef) {
+    if (!this.data.popupRef && this.hasPopupData) {
       this._createPopup();
     }
 
@@ -2316,13 +2305,7 @@ class LineAnnotationElement extends AnnotationElement {
   #line = null;
 
   constructor(parameters) {
-    const isRenderable = !!(
-      parameters.data.popupRef ||
-      parameters.data.titleObj?.str ||
-      parameters.data.contentsObj?.str ||
-      parameters.data.richText?.str
-    );
-    super(parameters, { isRenderable, ignoreBorder: true });
+    super(parameters, { isRenderable: true, ignoreBorder: true });
   }
 
   render() {
@@ -2357,7 +2340,7 @@ class LineAnnotationElement extends AnnotationElement {
 
     // Create the popup ourselves so that we can bind it to the line instead
     // of to the entire container (which is the default).
-    if (!data.popupRef) {
+    if (!data.popupRef && this.hasPopupData) {
       this._createPopup();
     }
 
@@ -2377,13 +2360,7 @@ class SquareAnnotationElement extends AnnotationElement {
   #square = null;
 
   constructor(parameters) {
-    const isRenderable = !!(
-      parameters.data.popupRef ||
-      parameters.data.titleObj?.str ||
-      parameters.data.contentsObj?.str ||
-      parameters.data.richText?.str
-    );
-    super(parameters, { isRenderable, ignoreBorder: true });
+    super(parameters, { isRenderable: true, ignoreBorder: true });
   }
 
   render() {
@@ -2420,7 +2397,7 @@ class SquareAnnotationElement extends AnnotationElement {
 
     // Create the popup ourselves so that we can bind it to the square instead
     // of to the entire container (which is the default).
-    if (!data.popupRef) {
+    if (!data.popupRef && this.hasPopupData) {
       this._createPopup();
     }
 
@@ -2440,13 +2417,7 @@ class CircleAnnotationElement extends AnnotationElement {
   #circle = null;
 
   constructor(parameters) {
-    const isRenderable = !!(
-      parameters.data.popupRef ||
-      parameters.data.titleObj?.str ||
-      parameters.data.contentsObj?.str ||
-      parameters.data.richText?.str
-    );
-    super(parameters, { isRenderable, ignoreBorder: true });
+    super(parameters, { isRenderable: true, ignoreBorder: true });
   }
 
   render() {
@@ -2484,7 +2455,7 @@ class CircleAnnotationElement extends AnnotationElement {
 
     // Create the popup ourselves so that we can bind it to the circle instead
     // of to the entire container (which is the default).
-    if (!data.popupRef) {
+    if (!data.popupRef && this.hasPopupData) {
       this._createPopup();
     }
 
@@ -2504,13 +2475,7 @@ class PolylineAnnotationElement extends AnnotationElement {
   #polyline = null;
 
   constructor(parameters) {
-    const isRenderable = !!(
-      parameters.data.popupRef ||
-      parameters.data.titleObj?.str ||
-      parameters.data.contentsObj?.str ||
-      parameters.data.richText?.str
-    );
-    super(parameters, { isRenderable, ignoreBorder: true });
+    super(parameters, { isRenderable: true, ignoreBorder: true });
 
     this.containerClassName = "polylineAnnotation";
     this.svgElementName = "svg:polyline";
@@ -2557,8 +2522,8 @@ class PolylineAnnotationElement extends AnnotationElement {
 
     // Create the popup ourselves so that we can bind it to the polyline
     // instead of to the entire container (which is the default).
-    if (!data.popupRef) {
-      this._createPopup(polyline, data);
+    if (!data.popupRef && this.hasPopupData) {
+      this._createPopup();
     }
 
     return this.container;
@@ -2585,19 +2550,13 @@ class PolygonAnnotationElement extends PolylineAnnotationElement {
 
 class CaretAnnotationElement extends AnnotationElement {
   constructor(parameters) {
-    const isRenderable = !!(
-      parameters.data.popupRef ||
-      parameters.data.titleObj?.str ||
-      parameters.data.contentsObj?.str ||
-      parameters.data.richText?.str
-    );
-    super(parameters, { isRenderable, ignoreBorder: true });
+    super(parameters, { isRenderable: true, ignoreBorder: true });
   }
 
   render() {
     this.container.classList.add("caretAnnotation");
 
-    if (!this.data.popupRef) {
+    if (!this.data.popupRef && this.hasPopupData) {
       this._createPopup();
     }
     return this.container;
@@ -2608,13 +2567,7 @@ class InkAnnotationElement extends AnnotationElement {
   #polylines = [];
 
   constructor(parameters) {
-    const isRenderable = !!(
-      parameters.data.popupRef ||
-      parameters.data.titleObj?.str ||
-      parameters.data.contentsObj?.str ||
-      parameters.data.richText?.str
-    );
-    super(parameters, { isRenderable, ignoreBorder: true });
+    super(parameters, { isRenderable: true, ignoreBorder: true });
 
     this.containerClassName = "inkAnnotation";
 
@@ -2661,8 +2614,8 @@ class InkAnnotationElement extends AnnotationElement {
 
       // Create the popup ourselves so that we can bind it to the polyline
       // instead of to the entire container (which is the default).
-      if (!data.popupRef) {
-        this._createPopup(polyline, data);
+      if (!data.popupRef && this.hasPopupData) {
+        this._createPopup();
       }
 
       svg.append(polyline);
@@ -2683,21 +2636,15 @@ class InkAnnotationElement extends AnnotationElement {
 
 class HighlightAnnotationElement extends AnnotationElement {
   constructor(parameters) {
-    const isRenderable = !!(
-      parameters.data.popupRef ||
-      parameters.data.titleObj?.str ||
-      parameters.data.contentsObj?.str ||
-      parameters.data.richText?.str
-    );
     super(parameters, {
-      isRenderable,
+      isRenderable: true,
       ignoreBorder: true,
       createQuadrilaterals: true,
     });
   }
 
   render() {
-    if (!this.data.popupRef) {
+    if (!this.data.popupRef && this.hasPopupData) {
       this._createPopup();
     }
 
@@ -2708,21 +2655,15 @@ class HighlightAnnotationElement extends AnnotationElement {
 
 class UnderlineAnnotationElement extends AnnotationElement {
   constructor(parameters) {
-    const isRenderable = !!(
-      parameters.data.popupRef ||
-      parameters.data.titleObj?.str ||
-      parameters.data.contentsObj?.str ||
-      parameters.data.richText?.str
-    );
     super(parameters, {
-      isRenderable,
+      isRenderable: true,
       ignoreBorder: true,
       createQuadrilaterals: true,
     });
   }
 
   render() {
-    if (!this.data.popupRef) {
+    if (!this.data.popupRef && this.hasPopupData) {
       this._createPopup();
     }
 
@@ -2733,21 +2674,15 @@ class UnderlineAnnotationElement extends AnnotationElement {
 
 class SquigglyAnnotationElement extends AnnotationElement {
   constructor(parameters) {
-    const isRenderable = !!(
-      parameters.data.popupRef ||
-      parameters.data.titleObj?.str ||
-      parameters.data.contentsObj?.str ||
-      parameters.data.richText?.str
-    );
     super(parameters, {
-      isRenderable,
+      isRenderable: true,
       ignoreBorder: true,
       createQuadrilaterals: true,
     });
   }
 
   render() {
-    if (!this.data.popupRef) {
+    if (!this.data.popupRef && this.hasPopupData) {
       this._createPopup();
     }
 
@@ -2758,21 +2693,15 @@ class SquigglyAnnotationElement extends AnnotationElement {
 
 class StrikeOutAnnotationElement extends AnnotationElement {
   constructor(parameters) {
-    const isRenderable = !!(
-      parameters.data.popupRef ||
-      parameters.data.titleObj?.str ||
-      parameters.data.contentsObj?.str ||
-      parameters.data.richText?.str
-    );
     super(parameters, {
-      isRenderable,
+      isRenderable: true,
       ignoreBorder: true,
       createQuadrilaterals: true,
     });
   }
 
   render() {
-    if (!this.data.popupRef) {
+    if (!this.data.popupRef && this.hasPopupData) {
       this._createPopup();
     }
 
@@ -2783,19 +2712,13 @@ class StrikeOutAnnotationElement extends AnnotationElement {
 
 class StampAnnotationElement extends AnnotationElement {
   constructor(parameters) {
-    const isRenderable = !!(
-      parameters.data.popupRef ||
-      parameters.data.titleObj?.str ||
-      parameters.data.contentsObj?.str ||
-      parameters.data.richText?.str
-    );
-    super(parameters, { isRenderable, ignoreBorder: true });
+    super(parameters, { isRenderable: true, ignoreBorder: true });
   }
 
   render() {
     this.container.classList.add("stampAnnotation");
 
-    if (!this.data.popupRef) {
+    if (!this.data.popupRef && this.hasPopupData) {
       this._createPopup();
     }
     return this.container;
@@ -2847,15 +2770,13 @@ class FileAttachmentAnnotationElement extends AnnotationElement {
         }
       }
     }
-    trigger.classList.add("popupTriggerArea");
     trigger.addEventListener("dblclick", this._download.bind(this));
     this.#trigger = trigger;
 
-    if (
-      !data.popupRef &&
-      (data.titleObj?.str || data.contentsObj?.str || data.richText)
-    ) {
+    if (!data.popupRef && this.hasPopupData) {
       this._createPopup();
+    } else {
+      trigger.classList.add("popupTriggerArea");
     }
 
     this.container.append(trigger);


</patch>

Imports:
<imports>
Available Packages
Dev Dependencies:
- @babel/core: ^7.22.11
- @babel/plugin-transform-modules-commonjs: ^7.22.11
- @babel/preset-env: ^7.22.14
- @babel/runtime: ^7.22.11
- @javascript-obfuscator/escodegen: 2.3.0
- acorn: ^8.10.0
- autoprefixer: ^10.4.15
- babel-loader: ^9.1.3
- caniuse-lite: ^1.0.30001525
- canvas: ^2.11.2
- core-js: ^3.32.1
- cross-env: ^7.0.3
- es-module-shims: 1.4.7
- eslint: ^8.48.0
- eslint-config-prettier: ^8.10.0
- eslint-plugin-fetch-options: ^0.0.5
- eslint-plugin-html: ^7.1.0
- eslint-plugin-import: ^2.28.1
- eslint-plugin-json: ^3.1.0
- eslint-plugin-mozilla: ^3.1.0
- eslint-plugin-no-unsanitized: ^4.0.2
- eslint-plugin-prettier: ^5.0.0
- eslint-plugin-sort-exports: ^0.8.0
- eslint-plugin-unicorn: ^48.0.1
- globals: ^13.21.0
- gulp: ^4.0.2
- gulp-postcss: ^9.0.1
- gulp-rename: ^2.0.0
- gulp-replace: ^1.1.4
- gulp-zip: ^5.1.0
- jasmine: ^5.1.0
- jsdoc: ^4.0.2
- jstransformer-markdown-it: ^3.0.0
- merge-stream: ^2.0.0
- mkdirp: ^3.0.1
- needle: ^3.2.0
- path2d-polyfill: ^2.0.1
- pngjs: ^7.0.0
- postcss: ^8.4.29
- postcss-dir-pseudo-class: ^8.0.0
- postcss-nesting: ^12.0.1
- prettier: ^3.0.3
- puppeteer: ^21.1.1
- rimraf: ^3.0.2
- streamqueue: ^1.1.2
- stylelint: ^15.10.3
- stylelint-prettier: ^4.0.2
- terser: ^5.19.3
- through2: ^4.0.2
- tsc-alias: ^1.8.7
- ttest: ^4.0.0
- typescript: ^5.2.2
- typogr: ^0.6.8
- vinyl: ^3.0.0
- webpack: ^5.88.2
- webpack-stream: ^7.0.0
- wintersmith: ^2.5.0
- yargs: ^17.7.2

Engines:
- node: >=18

Available Relative Imports:
- `../../src/core/annotation.js`: Annotation, AnnotationBorderStyle, AnnotationFactory, MarkupAnnotation, getQuadPoints
- `../../src/core/bidi.js`: bidi
- `../../src/core/cff_parser.js`: CFFCharset, CFFCompiler, CFFFDSelect, CFFParser, CFFStrings
- `../../src/core/cmap.js`: CMap, CMapFactory, IdentityCMap
- `../../src/core/colorspace.js`: ColorSpace
- `../../src/core/core_utils.js`: arrayBuffersToBytes, encodeToXmlString, escapePDFName, escapeString, getInheritableProperty, isAscii, isWhiteSpace, log2, numberToString, parseXFAPath, recoverJsURL, stringToUTF16HexString, stringToUTF16String, toRomanNumerals, validateCSSFont
- `../../src/core/crypto.js`: AES128Cipher, AES256Cipher, ARCFourCipher, CipherTransformFactory, PDF17, PDF20, calculateMD5, calculateSHA256, calculateSHA384, calculateSHA512
- `../../src/core/default_appearance.js`: createDefaultAppearance, parseAppearanceStream, parseDefaultAppearance
- `../../src/core/document.js`: PDFDocument, Page
- `../../src/core/encodings.js`: getEncoding
- `../../src/core/evaluator.js`: PartialEvaluator
- `../../src/core/font_substitutions.js`: getFontSubstitution
- `../../src/core/fonts_utils.js`: SEAC_ANALYSIS_ENABLED
- `../../src/core/function.js`: PDFFunctionFactory, PostScriptCompiler, PostScriptEvaluator
- `../../src/core/glyphlist.js`: getDingbatsGlyphsUnicode, getGlyphsUnicode
- `../../src/core/image_utils.js`: GlobalImageCache, LocalColorSpaceCache
- `../../src/core/jbig2.js`: Jbig2Image
- `../../src/core/jpg.js`: JpegImage
- `../../src/core/jpx.js`: JpxImage
- `../../src/core/metadata_parser.js`: MetadataParser
- `../../src/core/operator_list.js`: OperatorList
- `../../src/core/parser.js`: Lexer, Linearization, Parser
- `../../src/core/predictor_stream.js`: PredictorStream
- `../../src/core/primitives.js`: Cmd, Dict, EOF, Name, Ref, RefSet, RefSetCache, isCmd, isDict, isName, isRefsEqual
- `../../src/core/ps_parser.js`: PostScriptLexer, PostScriptParser
- `../../src/core/stream.js`: NullStream, Stream, StringStream
- `../../src/core/type1_parser.js`: Type1Parser
- `../../src/core/unicode.js`: getCharUnicodeCategory, getUnicodeForGlyph, getUnicodeRangeFor, mapSpecialUnicodeValues
- `../../src/core/worker.js`: WorkerMessageHandler, WorkerTask
- `../../src/core/writer.js`: incrementalUpdate, writeDict
- `../../src/core/xfa/bind.js`: Binder
- `../../src/core/xfa/data.js`: DataHandler
- `../../src/core/xfa/factory.js`: XFAFactory
- `../../src/core/xfa/formcalc_lexer.js`: Lexer, TOKEN, Token
- `../../src/core/xfa/formcalc_parser.js`: Errors, Parser
- `../../src/core/xfa/parser.js`: XFAParser
- `../../src/core/xfa/som.js`: searchNode
- `../../src/core/xfa/symbol_utils.js`: $dump, $getChildren, $getChildrenByClass, $getChildrenByName, $text, $uid
- `../../src/core/xml_parser.js`: SimpleXMLParser, XMLParserBase
- `../../src/display/annotation_layer.js`: AnnotationLayer
- `../../src/display/annotation_storage.js`: AnnotationStorage
- `../../src/display/api.js`: DefaultCMapReaderFactory, DefaultCanvasFactory, DefaultStandardFontDataFactory, LoopbackPort, PDFDataRangeTransport, PDFDocumentLoadingTask, PDFDocumentProxy, PDFPageProxy, PDFWorker, PDFWorkerUtil, RenderTask, SVGGraphics, build, getDocument, version
- `../../src/display/display_utils.js`: DOMCanvasFactory, DOMSVGFactory, PDFDateString, PageViewport, PixelsPerInch, RenderingCancelledException, StatTimer, getFilenameFromUrl, getPdfFilenameFromUrl, getXfaPageViewport, isDataScheme, isPdfFile, isValidFetchUrl, loadScript, setLayerDimensions
- `../../src/display/editor/annotation_editor_layer.js`: AnnotationEditorLayer
- `../../src/display/editor/tools.js`: AnnotationEditorUIManager, CommandManager
- `../../src/display/fetch_stream.js`: PDFFetchStream
- `../../src/display/metadata.js`: Metadata
- `../../src/display/network.js`: PDFNetworkStream
- `../../src/display/network_utils.js`: createResponseStatusError, extractFilenameFromHeader, validateRangeRequestCapabilities, validateResponseStatus
- `../../src/display/node_stream.js`: PDFNodeStream
- `../../src/display/svg.js`: SVGGraphics
- `../../src/display/text_layer.js`: TextLayerRenderTask, renderTextLayer, updateTextLayer
- `../../src/display/worker_options.js`: GlobalWorkerOptions
- `../../src/display/xfa_layer.js`: XfaLayer
- `../../src/shared/message_handler.js`: MessageHandler
- `../../src/shared/murmurhash3.js`: MurmurHash3_64
- `../../src/shared/util.js`: AbortException, AnnotationBorderStyleType, AnnotationEditorParamsType, AnnotationEditorType, AnnotationFieldFlag, AnnotationFlag, AnnotationMode, AnnotationType, CMapCompressionType, FeatureTest, FormatError, ImageKind, InvalidPDFException, MissingPDFException, OPS, PasswordException, PasswordResponses, PermissionFlag, PromiseCapability, RenderingIntentFlag, UnexpectedResponseException, UnknownErrorException, Util, VerbosityLevel, bytesToString, createValidAbsoluteUrl, getModificationDate, getVerbosityLevel, isArrayBuffer, isNodeJS, normalizeUnicode, objectSize, setVerbosityLevel, shadow, string32, stringToBytes, stringToPDFString, stringToUTF8String
- `../../web/annotation_layer_builder.js`: AnnotationLayerBuilder
- `../../web/download_manager.js`: DownloadManager
- `../../web/event_utils.js`: EventBus, WaitOnType, waitOnEventOrTimeout
- `../../web/genericl10n.js`: GenericL10n
- `../../web/l10n_utils.js`: NullL10n
- `../../web/pdf_find_controller.js`: FindState, PDFFindController
- `../../web/pdf_find_utils.js`: CharacterType, getCharacterType
- `../../web/pdf_history.js`: PDFHistory, isDestArraysEqual, isDestHashesEqual
- `../../web/pdf_link_service.js`: LinkTarget, PDFLinkService, SimpleLinkService
- `../../web/pdf_page_view.js`: PDFPageView
- `../../web/pdf_scripting_manager.component.js`: PDFScriptingManager
- `../../web/pdf_single_page_viewer.js`: PDFSinglePageViewer
- `../../web/pdf_viewer.js`: PDFPageViewBuffer, PDFViewer
- `../../web/struct_tree_layer_builder.js`: StructTreeLayerBuilder
- `../../web/text_layer_builder.js`: TextLayerBuilder
- `../../web/ui_utils.js`: AutoPrintRegExp, ProgressBar, RenderingStates, ScrollMode, SpreadMode, backtrackBeforeAllVisibleElements, binarySearchFirstItem, getPageSizeInches, getVisibleElements, isPortraitOrientation, isValidRotation, parseQueryString, removeNullCharacters
- `../../web/xfa_layer_builder.js`: XfaLayerBuilder
- `./test_utils.js`: CMAP_URL, DefaultFileReaderFactory, STANDARD_FONT_DATA_URL, TEST_PDFS_PATH, XRefMock, buildGetDocumentParams, createIdFactory
- `./testreporter.js`: TestReporter
</imports>

Code:
<code>
File:
src/display/annotation_layer.js
1 /* Copyright 2014 Mozilla Foundation
2  *
3  * Licensed under the Apache License, Version 2.0 (the "License");
4  * you may not use this file except in compliance with the License.
5  * You may obtain a copy of the License at
6  *
7  *     http://www.apache.org/licenses/LICENSE-2.0
8  *
9  * Unless required by applicable law or agreed to in writing, software
10  * distributed under the License is distributed on an "AS IS" BASIS,
11  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
12  * See the License for the specific language governing permissions and
13  * limitations under the License.
14  */
15 
18 // eslint-disable-next-line max-len
20 // eslint-disable-next-line max-len
23 
24 import {
25   AnnotationBorderStyleType,
26   AnnotationEditorType,
27   AnnotationPrefix,
28   AnnotationType,
29   FeatureTest,
30   LINE_FACTOR,
31   shadow,
32   unreachable,
33   Util,
34   warn,
35 } from "../shared/util.js";
36 import {
37   DOMSVGFactory,
38   getFilenameFromUrl,
39   PDFDateString,
40   setLayerDimensions,
41 } from "./display_utils.js";
42 import { AnnotationStorage } from "./annotation_storage.js";
43 import { ColorConverters } from "../shared/scripting_utils.js";
44 import { NullL10n } from "display-l10n_utils";
45 import { XfaLayer } from "./xfa_layer.js";
46 
47 const DEFAULT_TAB_INDEX = 1000;
48 const DEFAULT_FONT_SIZE = 9;
49 const GetElementsByNameSet = new WeakSet();
50 
160 class AnnotationElement {
161   #hasBorder = false;
162 
163   constructor(
164     parameters,
165     {
166       isRenderable = false,
167       ignoreBorder = false,
168       createQuadrilaterals = false,
169     } = {}
170   ) {
171     this.isRenderable = isRenderable;
172     this.data = parameters.data;
173     this.layer = parameters.layer;
174     this.linkService = parameters.linkService;
175     this.downloadManager = parameters.downloadManager;
176     this.imageResourcesPath = parameters.imageResourcesPath;
177     this.renderForms = parameters.renderForms;
178     this.svgFactory = parameters.svgFactory;
179     this.annotationStorage = parameters.annotationStorage;
180     this.enableScripting = parameters.enableScripting;
181     this.hasJSActions = parameters.hasJSActions;
182     this._fieldObjects = parameters.fieldObjects;
183     this.parent = parameters.parent;
184 
185     if (isRenderable) {
186       this.container = this._createContainer(ignoreBorder);
187     }
188     if (createQuadrilaterals) {
189       this._createQuadrilaterals();
190     }
191   }
192 
679 }
680 
957 class TextAnnotationElement extends AnnotationElement {
958   constructor(parameters) {
959     const isRenderable = !!(
960       parameters.data.popupRef ||
961       parameters.data.titleObj?.str ||
962       parameters.data.contentsObj?.str ||
963       parameters.data.richText?.str
964     );
965     super(parameters, { isRenderable });
966   }
967 
968   render() {
969     this.container.classList.add("textAnnotation");
970 
971     const image = document.createElement("img");
972     image.src =
973       this.imageResourcesPath +
974       "annotation-" +
975       this.data.name.toLowerCase() +
976       ".svg";
977     image.alt = "[{{type}} Annotation]";
978     image.dataset.l10nId = "text_annotation_type";
979     image.dataset.l10nArgs = JSON.stringify({ type: this.data.name });
980 
981     if (!this.data.popupRef) {
982       this._createPopup();
983     }
984 
985     this.container.append(image);
986     return this.container;
987   }
988 }
989 
1927 class PopupAnnotationElement extends AnnotationElement {
1928   constructor(parameters) {
1929     const { data, elements } = parameters;
1930     const isRenderable = !!(
1931       data.titleObj?.str ||
1932       data.contentsObj?.str ||
1933       data.richText?.str
1934     );
1935     super(parameters, { isRenderable });
1936     this.elements = elements;
1937   }
1938 
1970 }
1971 
1972 class PopupElement {
1973   #dateTimePromise = null;
1974 
1975   #boundKeyDown = this.#keyDown.bind(this);
1976 
1977   #boundHide = this.#hide.bind(this);
1978 
1979   #boundShow = this.#show.bind(this);
1980 
1981   #boundToggle = this.#toggle.bind(this);
1982 
1983   #color = null;
1984 
1985   #container = null;
1986 
1987   #contentsObj = null;
1988 
1989   #elements = null;
1990 
1991   #parent = null;
1992 
1993   #parentRect = null;
1994 
1995   #pinned = false;
1996 
1997   #popup = null;
1998 
1999   #rect = null;
2000 
2001   #richText = null;
2002 
2003   #titleObj = null;
2004 
2005   #wasVisible = false;
2006 
2007   constructor({
2008     container,
2009     color,
2010     elements,
2011     titleObj,
2012     modificationDate,
2013     contentsObj,
2014     richText,
2015     parent,
2016     rect,
2017     parentRect,
2018     open,
2019   }) {
2020     this.#container = container;
2021     this.#titleObj = titleObj;
2022     this.#contentsObj = contentsObj;
2023     this.#richText = richText;
2024     this.#parent = parent;
2025     this.#color = color;
2026     this.#rect = rect;
2027     this.#parentRect = parentRect;
2028     this.#elements = elements;
2029 
2030     const dateObject = PDFDateString.toDateObject(modificationDate);
2031     if (dateObject) {
2032       // The modification date is shown in the popup instead of the creation
2033       // date if it is available and can be parsed correctly, which is
2034       // consistent with other viewers such as Adobe Acrobat.
2035       this.#dateTimePromise = parent.l10n.get("annotation_date_string", {
2036         date: dateObject.toLocaleDateString(),
2037         time: dateObject.toLocaleTimeString(),
2038       });
2039     }
2040 
2041     this.trigger = elements.flatMap(e => e.getElementsToTriggerPopup());
2042     // Attach the event listeners to the trigger element.
2043     for (const element of this.trigger) {
2044       element.addEventListener("click", this.#boundToggle);
2045       element.addEventListener("mouseenter", this.#boundShow);
2046       element.addEventListener("mouseleave", this.#boundHide);
2047       if (typeof PDFJSDev !== "undefined" && PDFJSDev.test("TESTING")) {
2048         element.classList.add("popupTriggerArea");
2049       }
2050     }
2051 
2052     // Attach the event listener to toggle the popup with the keyboard.
2053     for (const element of elements) {
2054       element.container?.addEventListener("keydown", this.#boundKeyDown);
2055     }
2056 
2057     this.#container.hidden = true;
2058     if (open) {
2059       this.#toggle();
2060     }
2061 
2062     if (typeof PDFJSDev !== "undefined" && PDFJSDev.test("TESTING")) {
2063       // Since the popup is lazily created, we need to ensure that it'll be
2064       // created and displayed during reference tests.
2065       this.#parent.popupShow.push(async () => {
2066         if (this.#container.hidden) {
2067           this.#show();
2068         }
2069         if (this.#dateTimePromise) {
2070           await this.#dateTimePromise;
2071         }
2072       });
2073     }
2074   }
2075 
2274 }
2275 
2276 class FreeTextAnnotationElement extends AnnotationElement {
2277   constructor(parameters) {
2278     const isRenderable = !!(
2279       parameters.data.popupRef ||
2280       parameters.data.titleObj?.str ||
2281       parameters.data.contentsObj?.str ||
2282       parameters.data.richText?.str
2283     );
2284     super(parameters, { isRenderable, ignoreBorder: true });
2285     this.textContent = parameters.data.textContent;
2286     this.textPosition = parameters.data.textPosition;
2287     this.annotationEditorType = AnnotationEditorType.FREETEXT;
2288   }
2289 
2290   render() {
2291     this.container.classList.add("freeTextAnnotation");
2292 
2293     if (this.textContent) {
2294       const content = document.createElement("div");
2295       content.classList.add("annotationTextContent");
2296       content.setAttribute("role", "comment");
2297       for (const line of this.textContent) {
2298         const lineSpan = document.createElement("span");
2299         lineSpan.textContent = line;
2300         content.append(lineSpan);
2301       }
2302       this.container.append(content);
2303     }
2304 
2305     if (!this.data.popupRef) {
2306       this._createPopup();
2307     }
2308 
2309     this._editOnDoubleClick();
2310 
2311     return this.container;
2312   }
2313 }
2314 
2315 class LineAnnotationElement extends AnnotationElement {
2316   #line = null;
2317 
2318   constructor(parameters) {
2319     const isRenderable = !!(
2320       parameters.data.popupRef ||
2321       parameters.data.titleObj?.str ||
2322       parameters.data.contentsObj?.str ||
2323       parameters.data.richText?.str
2324     );
2325     super(parameters, { isRenderable, ignoreBorder: true });
2326   }
2327 
2328   render() {
2329     this.container.classList.add("lineAnnotation");
2330 
2331     // Create an invisible line with the same starting and ending coordinates
2332     // that acts as the trigger for the popup. Only the line itself should
2333     // trigger the popup, not the entire container.
2334     const data = this.data;
2335     const { width, height } = getRectDims(data.rect);
2336     const svg = this.svgFactory.create(
2337       width,
2338       height,
2339       /* skipDimensions = */ true
2340     );
2341 
2342     // PDF coordinates are calculated from a bottom left origin, so transform
2343     // the line coordinates to a top left origin for the SVG element.
2344     const line = (this.#line = this.svgFactory.createElement("svg:line"));
2345     line.setAttribute("x1", data.rect[2] - data.lineCoordinates[0]);
2346     line.setAttribute("y1", data.rect[3] - data.lineCoordinates[1]);
2347     line.setAttribute("x2", data.rect[2] - data.lineCoordinates[2]);
2348     line.setAttribute("y2", data.rect[3] - data.lineCoordinates[3]);
2349     // Ensure that the 'stroke-width' is always non-zero, since otherwise it
2350     // won't be possible to open/close the popup (note e.g. issue 11122).
2351     line.setAttribute("stroke-width", data.borderStyle.width || 1);
2352     line.setAttribute("stroke", "transparent");
2353     line.setAttribute("fill", "transparent");
2354 
2355     svg.append(line);
2356     this.container.append(svg);
2357 
2358     // Create the popup ourselves so that we can bind it to the line instead
2359     // of to the entire container (which is the default).
2360     if (!data.popupRef) {
2361       this._createPopup();
2362     }
2363 
2364     return this.container;
2365   }
2366 
2374 }
2375 
2376 class SquareAnnotationElement extends AnnotationElement {
2377   #square = null;
2378 
2379   constructor(parameters) {
2380     const isRenderable = !!(
2381       parameters.data.popupRef ||
2382       parameters.data.titleObj?.str ||
2383       parameters.data.contentsObj?.str ||
2384       parameters.data.richText?.str
2385     );
2386     super(parameters, { isRenderable, ignoreBorder: true });
2387   }
2388 
2389   render() {
2390     this.container.classList.add("squareAnnotation");
2391 
2392     // Create an invisible square with the same rectangle that acts as the
2393     // trigger for the popup. Only the square itself should trigger the
2394     // popup, not the entire container.
2395     const data = this.data;
2396     const { width, height } = getRectDims(data.rect);
2397     const svg = this.svgFactory.create(
2398       width,
2399       height,
2400       /* skipDimensions = */ true
2401     );
2402 
2403     // The browser draws half of the borders inside the square and half of
2404     // the borders outside the square by default. This behavior cannot be
2405     // changed programmatically, so correct for that here.
2406     const borderWidth = data.borderStyle.width;
2407     const square = (this.#square = this.svgFactory.createElement("svg:rect"));
2408     square.setAttribute("x", borderWidth / 2);
2409     square.setAttribute("y", borderWidth / 2);
2410     square.setAttribute("width", width - borderWidth);
2411     square.setAttribute("height", height - borderWidth);
2412     // Ensure that the 'stroke-width' is always non-zero, since otherwise it
2413     // won't be possible to open/close the popup (note e.g. issue 11122).
2414     square.setAttribute("stroke-width", borderWidth || 1);
2415     square.setAttribute("stroke", "transparent");
2416     square.setAttribute("fill", "transparent");
2417 
2418     svg.append(square);
2419     this.container.append(svg);
2420 
2421     // Create the popup ourselves so that we can bind it to the square instead
2422     // of to the entire container (which is the default).
2423     if (!data.popupRef) {
2424       this._createPopup();
2425     }
2426 
2427     return this.container;
2428   }
2429 
2437 }
2438 
2439 class CircleAnnotationElement extends AnnotationElement {
2440   #circle = null;
2441 
2442   constructor(parameters) {
2443     const isRenderable = !!(
2444       parameters.data.popupRef ||
2445       parameters.data.titleObj?.str ||
2446       parameters.data.contentsObj?.str ||
2447       parameters.data.richText?.str
2448     );
2449     super(parameters, { isRenderable, ignoreBorder: true });
2450   }
2451 
2452   render() {
2453     this.container.classList.add("circleAnnotation");
2454 
2455     // Create an invisible circle with the same ellipse that acts as the
2456     // trigger for the popup. Only the circle itself should trigger the
2457     // popup, not the entire container.
2458     const data = this.data;
2459     const { width, height } = getRectDims(data.rect);
2460     const svg = this.svgFactory.create(
2461       width,
2462       height,
2463       /* skipDimensions = */ true
2464     );
2465 
2466     // The browser draws half of the borders inside the circle and half of
2467     // the borders outside the circle by default. This behavior cannot be
2468     // changed programmatically, so correct for that here.
2469     const borderWidth = data.borderStyle.width;
2470     const circle = (this.#circle =
2471       this.svgFactory.createElement("svg:ellipse"));
2472     circle.setAttribute("cx", width / 2);
2473     circle.setAttribute("cy", height / 2);
2474     circle.setAttribute("rx", width / 2 - borderWidth / 2);
2475     circle.setAttribute("ry", height / 2 - borderWidth / 2);
2476     // Ensure that the 'stroke-width' is always non-zero, since otherwise it
2477     // won't be possible to open/close the popup (note e.g. issue 11122).
2478     circle.setAttribute("stroke-width", borderWidth || 1);
2479     circle.setAttribute("stroke", "transparent");
2480     circle.setAttribute("fill", "transparent");
2481 
2482     svg.append(circle);
2483     this.container.append(svg);
2484 
2485     // Create the popup ourselves so that we can bind it to the circle instead
2486     // of to the entire container (which is the default).
2487     if (!data.popupRef) {
2488       this._createPopup();
2489     }
2490 
2491     return this.container;
2492   }
2493 
2501 }
2502 
2503 class PolylineAnnotationElement extends AnnotationElement {
2504   #polyline = null;
2505 
2506   constructor(parameters) {
2507     const isRenderable = !!(
2508       parameters.data.popupRef ||
2509       parameters.data.titleObj?.str ||
2510       parameters.data.contentsObj?.str ||
2511       parameters.data.richText?.str
2512     );
2513     super(parameters, { isRenderable, ignoreBorder: true });
2514 
2515     this.containerClassName = "polylineAnnotation";
2516     this.svgElementName = "svg:polyline";
2517   }
2518 
2519   render() {
2520     this.container.classList.add(this.containerClassName);
2521 
2522     // Create an invisible polyline with the same points that acts as the
2523     // trigger for the popup. Only the polyline itself should trigger the
2524     // popup, not the entire container.
2525     const data = this.data;
2526     const { width, height } = getRectDims(data.rect);
2527     const svg = this.svgFactory.create(
2528       width,
2529       height,
2530       /* skipDimensions = */ true
2531     );
2532 
2533     // Convert the vertices array to a single points string that the SVG
2534     // polyline element expects ("x1,y1 x2,y2 ..."). PDF coordinates are
2535     // calculated from a bottom left origin, so transform the polyline
2536     // coordinates to a top left origin for the SVG element.
2537     let points = [];
2538     for (const coordinate of data.vertices) {
2539       const x = coordinate.x - data.rect[0];
2540       const y = data.rect[3] - coordinate.y;
2541       points.push(x + "," + y);
2542     }
2543     points = points.join(" ");
2544 
2545     const polyline = (this.#polyline = this.svgFactory.createElement(
2546       this.svgElementName
2547     ));
2548     polyline.setAttribute("points", points);
2549     // Ensure that the 'stroke-width' is always non-zero, since otherwise it
2550     // won't be possible to open/close the popup (note e.g. issue 11122).
2551     polyline.setAttribute("stroke-width", data.borderStyle.width || 1);
2552     polyline.setAttribute("stroke", "transparent");
2553     polyline.setAttribute("fill", "transparent");
2554 
2555     svg.append(polyline);
2556     this.container.append(svg);
2557 
2558     // Create the popup ourselves so that we can bind it to the polyline
2559     // instead of to the entire container (which is the default).
2560     if (!data.popupRef) {
2561       this._createPopup(polyline, data);
2562     }
2563 
2564     return this.container;
2565   }
2566 
2574 }
2575 
2586 class CaretAnnotationElement extends AnnotationElement {
2587   constructor(parameters) {
2588     const isRenderable = !!(
2589       parameters.data.popupRef ||
2590       parameters.data.titleObj?.str ||
2591       parameters.data.contentsObj?.str ||
2592       parameters.data.richText?.str
2593     );
2594     super(parameters, { isRenderable, ignoreBorder: true });
2595   }
2596 
2597   render() {
2598     this.container.classList.add("caretAnnotation");
2599 
2600     if (!this.data.popupRef) {
2601       this._createPopup();
2602     }
2603     return this.container;
2604   }
2605 }
2606 
2607 class InkAnnotationElement extends AnnotationElement {
2608   #polylines = [];
2609 
2610   constructor(parameters) {
2611     const isRenderable = !!(
2612       parameters.data.popupRef ||
2613       parameters.data.titleObj?.str ||
2614       parameters.data.contentsObj?.str ||
2615       parameters.data.richText?.str
2616     );
2617     super(parameters, { isRenderable, ignoreBorder: true });
2618 
2619     this.containerClassName = "inkAnnotation";
2620 
2621     // Use the polyline SVG element since it allows us to use coordinates
2622     // directly and to draw both straight lines and curves.
2623     this.svgElementName = "svg:polyline";
2624     this.annotationEditorType = AnnotationEditorType.INK;
2625   }
2626 
2627   render() {
2628     this.container.classList.add(this.containerClassName);
2629 
2630     // Create an invisible polyline with the same points that acts as the
2631     // trigger for the popup.
2632     const data = this.data;
2633     const { width, height } = getRectDims(data.rect);
2634     const svg = this.svgFactory.create(
2635       width,
2636       height,
2637       /* skipDimensions = */ true
2638     );
2639 
2640     for (const inkList of data.inkLists) {
2641       // Convert the ink list to a single points string that the SVG
2642       // polyline element expects ("x1,y1 x2,y2 ..."). PDF coordinates are
2643       // calculated from a bottom left origin, so transform the polyline
2644       // coordinates to a top left origin for the SVG element.
2645       let points = [];
2646       for (const coordinate of inkList) {
2647         const x = coordinate.x - data.rect[0];
2648         const y = data.rect[3] - coordinate.y;
2649         points.push(`${x},${y}`);
2650       }
2651       points = points.join(" ");
2652 
2653       const polyline = this.svgFactory.createElement(this.svgElementName);
2654       this.#polylines.push(polyline);
2655       polyline.setAttribute("points", points);
2656       // Ensure that the 'stroke-width' is always non-zero, since otherwise it
2657       // won't be possible to open/close the popup (note e.g. issue 11122).
2658       polyline.setAttribute("stroke-width", data.borderStyle.width || 1);
2659       polyline.setAttribute("stroke", "transparent");
2660       polyline.setAttribute("fill", "transparent");
2661 
2662       // Create the popup ourselves so that we can bind it to the polyline
2663       // instead of to the entire container (which is the default).
2664       if (!data.popupRef) {
2665         this._createPopup(polyline, data);
2666       }
2667 
2668       svg.append(polyline);
2669     }
2670 
2671     this.container.append(svg);
2672     return this.container;
2673   }
2674 
2682 }
2683 
2684 class HighlightAnnotationElement extends AnnotationElement {
2685   constructor(parameters) {
2686     const isRenderable = !!(
2687       parameters.data.popupRef ||
2688       parameters.data.titleObj?.str ||
2689       parameters.data.contentsObj?.str ||
2690       parameters.data.richText?.str
2691     );
2692     super(parameters, {
2693       isRenderable,
2694       ignoreBorder: true,
2695       createQuadrilaterals: true,
2696     });
2697   }
2698 
2699   render() {
2700     if (!this.data.popupRef) {
2701       this._createPopup();
2702     }
2703 
2704     this.container.classList.add("highlightAnnotation");
2705     return this.container;
2706   }
2707 }
2708 
2709 class UnderlineAnnotationElement extends AnnotationElement {
2710   constructor(parameters) {
2711     const isRenderable = !!(
2712       parameters.data.popupRef ||
2713       parameters.data.titleObj?.str ||
2714       parameters.data.contentsObj?.str ||
2715       parameters.data.richText?.str
2716     );
2717     super(parameters, {
2718       isRenderable,
2719       ignoreBorder: true,
2720       createQuadrilaterals: true,
2721     });
2722   }
2723 
2724   render() {
2725     if (!this.data.popupRef) {
2726       this._createPopup();
2727     }
2728 
2729     this.container.classList.add("underlineAnnotation");
2730     return this.container;
2731   }
2732 }
2733 
2734 class SquigglyAnnotationElement extends AnnotationElement {
2735   constructor(parameters) {
2736     const isRenderable = !!(
2737       parameters.data.popupRef ||
2738       parameters.data.titleObj?.str ||
2739       parameters.data.contentsObj?.str ||
2740       parameters.data.richText?.str
2741     );
2742     super(parameters, {
2743       isRenderable,
2744       ignoreBorder: true,
2745       createQuadrilaterals: true,
2746     });
2747   }
2748 
2749   render() {
2750     if (!this.data.popupRef) {
2751       this._createPopup();
2752     }
2753 
2754     this.container.classList.add("squigglyAnnotation");
2755     return this.container;
2756   }
2757 }
2758 
2759 class StrikeOutAnnotationElement extends AnnotationElement {
2760   constructor(parameters) {
2761     const isRenderable = !!(
2762       parameters.data.popupRef ||
2763       parameters.data.titleObj?.str ||
2764       parameters.data.contentsObj?.str ||
2765       parameters.data.richText?.str
2766     );
2767     super(parameters, {
2768       isRenderable,
2769       ignoreBorder: true,
2770       createQuadrilaterals: true,
2771     });
2772   }
2773 
2774   render() {
2775     if (!this.data.popupRef) {
2776       this._createPopup();
2777     }
2778 
2779     this.container.classList.add("strikeoutAnnotation");
2780     return this.container;
2781   }
2782 }
2783 
2784 class StampAnnotationElement extends AnnotationElement {
2785   constructor(parameters) {
2786     const isRenderable = !!(
2787       parameters.data.popupRef ||
2788       parameters.data.titleObj?.str ||
2789       parameters.data.contentsObj?.str ||
2790       parameters.data.richText?.str
2791     );
2792     super(parameters, { isRenderable, ignoreBorder: true });
2793   }
2794 
2795   render() {
2796     this.container.classList.add("stampAnnotation");
2797 
2798     if (!this.data.popupRef) {
2799       this._createPopup();
2800     }
2801     return this.container;
2802   }
2803 }
2804 
2805 class FileAttachmentAnnotationElement extends AnnotationElement {
2806   #trigger = null;
2807 
2808   constructor(parameters) {
2809     super(parameters, { isRenderable: true });
2810 
2811     const { filename, content } = this.data.file;
2812     this.filename = getFilenameFromUrl(filename, /* onlyStripPath = */ true);
2813     this.content = content;
2814 
2815     this.linkService.eventBus?.dispatch("fileattachmentannotation", {
2816       source: this,
2817       filename,
2818       content,
2819     });
2820   }
2821 
2822   render() {
2823     this.container.classList.add("fileAttachmentAnnotation");
2824 
2825     const { data } = this;
2826     let trigger;
2827     if (data.hasAppearance || data.fillAlpha === 0) {
2828       trigger = document.createElement("div");
2829     } else {
2830       // Unfortunately it seems that it's not clearly specified exactly what
2831       // names are actually valid, since Table 184 contains:
2832       //   Conforming readers shall provide predefined icon appearances for at
2833       //   least the following standard names: GraphPushPin, PaperclipTag.
2834       //   Additional names may be supported as well. Default value: PushPin.
2835       trigger = document.createElement("img");
2836       trigger.src = `${this.imageResourcesPath}annotation-${
2837         /paperclip/i.test(data.name) ? "paperclip" : "pushpin"
2838       }.svg`;
2839 
2840       if (data.fillAlpha && data.fillAlpha < 1) {
2841         trigger.style = `filter: opacity(${Math.round(
2842           data.fillAlpha * 100
2843         )}%);`;
2844 
2845         if (typeof PDFJSDev !== "undefined" && PDFJSDev.test("TESTING")) {
2846           this.container.classList.add("hasFillAlpha");
2847         }
2848       }
2849     }
2850     trigger.classList.add("popupTriggerArea");
2851     trigger.addEventListener("dblclick", this._download.bind(this));
2852     this.#trigger = trigger;
2853 
2854     if (
2855       !data.popupRef &&
2856       (data.titleObj?.str || data.contentsObj?.str || data.richText)
2857     ) {
2858       this._createPopup();
2859     }
2860 
2861     this.container.append(trigger);
2862     return this.container;
2863   }
2864 
2886 }
2887 
3090 
</code>

PR summary:
<pr_summary>
Unconditionally render non-form annotations in the annotation layer (bug 1851498)
The goal is to always have something which is focusable to let the user select
it with the keyboard.
It fixes the mentioned bug because, the annotation layer will now have a container
to attach the canvas for annotations having their own canvas.
</pr_summary>

Your task:
You are a software tester at pdf.js.
1. Write exactly one javascript test `it("...", async () => {...})` block.
2. Your test must fail on the code before the patch, and pass after, hence the test will verify that the patch resolves the issue.
3. The test must be self-contained and to-the-point.
4. Use only the provided imports (respect the paths exactly how they are given) by importing dynamically for compatibility with Node.js — no new dependencies. You can use the PDF file for testing as follows:
const { getDocument } = await import('../../src/display/api.js');
const { buildGetDocumentParams } = await import('./test_utils.js');
const loadingTask = getDocument(buildGetDocumentParams('bug1851498.pdf'))
5. Return only the javascript code (no comments or explanations).

Example structure:
it("should <describe behavior>", async () => {
  const { example } = await import("../../src/core/example.js");
  <initialize required variables>;
  <define expected variable>;
  <generate actual variables>;
  <compare expected with actual>;
});

