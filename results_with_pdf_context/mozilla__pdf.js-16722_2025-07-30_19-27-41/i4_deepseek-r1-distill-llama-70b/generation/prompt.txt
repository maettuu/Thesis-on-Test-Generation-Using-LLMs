Before you begin:
- Keep going until the job is completely solved — don’t stop halfway.
- If you’re unsure about the behavior, reread the provided patch carefully; do not hallucinate.
- Plan your approach before writing code by reflecting on whether the test truly fails before and passes after.

Issue:
<issue>
Firefox is very slow to render poster PDF
</issue>

Patch:
<patch>
diff --git a/src/display/canvas.js b/src/display/canvas.js
--- a/src/display/canvas.js
+++ b/src/display/canvas.js
@@ -790,7 +790,10 @@ function resetCtxToDefault(ctx) {
     (typeof PDFJSDev !== "undefined" && PDFJSDev.test("MOZCENTRAL")) ||
     !isNodeJS
   ) {
-    ctx.filter = "none";
+    const { filter } = ctx;
+    if (filter !== "none" && filter !== "") {
+      ctx.filter = "none";
+    }
   }
 }
 
@@ -2961,7 +2964,10 @@ class CanvasGraphics {
       // It must be applied to the image before rescaling else some artifacts
       // could appear.
       // The final restore will reset it to its value.
-      ctx.filter = "none";
+      const { filter } = ctx;
+      if (filter !== "none" && filter !== "") {
+        ctx.filter = "none";
+      }
     }
 
     // scale the image to the unit square


</patch>

Imports:
<imports>
Available Packages
Dev Dependencies:
- @babel/core: ^7.22.9
- @babel/plugin-transform-modules-commonjs: ^7.22.5
- @babel/preset-env: ^7.22.9
- @babel/runtime: ^7.22.6
- @javascript-obfuscator/escodegen: 2.3.0
- acorn: ^8.10.0
- autoprefixer: ^10.4.14
- babel-loader: ^9.1.3
- caniuse-lite: ^1.0.30001516
- canvas: ^2.11.2
- core-js: ^3.31.1
- cross-env: ^7.0.3
- es-module-shims: 1.4.7
- eslint: ^8.45.0
- eslint-config-prettier: ^8.8.0
- eslint-plugin-fetch-options: ^0.0.5
- eslint-plugin-html: ^7.1.0
- eslint-plugin-import: ^2.27.5
- eslint-plugin-json: ^3.1.0
- eslint-plugin-mozilla: ^3.1.0
- eslint-plugin-no-unsanitized: ^4.0.2
- eslint-plugin-prettier: ^5.0.0
- eslint-plugin-sort-exports: ^0.8.0
- eslint-plugin-unicorn: ^48.0.0
- globals: ^13.20.0
- gulp: ^4.0.2
- gulp-postcss: ^9.0.1
- gulp-rename: ^2.0.0
- gulp-replace: ^1.1.4
- gulp-zip: ^5.1.0
- jasmine: ^5.0.2
- jsdoc: ^4.0.2
- jstransformer-markdown-it: ^3.0.0
- merge-stream: ^2.0.0
- mkdirp: ^3.0.1
- needle: ^3.2.0
- path2d-polyfill: ^2.0.1
- pngjs: ^7.0.0
- postcss: ^8.4.26
- postcss-dir-pseudo-class: ^8.0.0
- prettier: ^3.0.0
- puppeteer: ^20.8.2
- rimraf: ^3.0.2
- streamqueue: ^1.1.2
- stylelint: 15.10.0
- stylelint-prettier: ^4.0.0
- terser: ^5.19.0
- through2: ^4.0.2
- ttest: ^4.0.0
- typescript: ^5.1.6
- typogr: ^0.6.8
- vinyl: ^3.0.0
- vinyl-fs: ^3.0.3
- webpack: ^5.88.1
- webpack-stream: ^7.0.0
- wintersmith: ^2.5.0
- yargs: ^17.7.2

Engines:
- node: >=18

Available Relative Imports:
- `../../src/core/annotation.js`: Annotation, AnnotationBorderStyle, AnnotationFactory, MarkupAnnotation, getQuadPoints
- `../../src/core/bidi.js`: bidi
- `../../src/core/cff_parser.js`: CFFCharset, CFFCompiler, CFFFDSelect, CFFParser, CFFStrings
- `../../src/core/cmap.js`: CMap, CMapFactory, IdentityCMap
- `../../src/core/colorspace.js`: ColorSpace
- `../../src/core/core_utils.js`: arrayBuffersToBytes, encodeToXmlString, escapePDFName, escapeString, getInheritableProperty, isAscii, isWhiteSpace, log2, numberToString, parseXFAPath, recoverJsURL, stringToUTF16HexString, stringToUTF16String, toRomanNumerals, validateCSSFont
- `../../src/core/crypto.js`: AES128Cipher, AES256Cipher, ARCFourCipher, CipherTransformFactory, PDF17, PDF20, calculateMD5, calculateSHA256, calculateSHA384, calculateSHA512
- `../../src/core/default_appearance.js`: createDefaultAppearance, parseAppearanceStream, parseDefaultAppearance
- `../../src/core/document.js`: PDFDocument, Page
- `../../src/core/encodings.js`: getEncoding
- `../../src/core/evaluator.js`: PartialEvaluator
- `../../src/core/font_substitutions.js`: getFontSubstitution
- `../../src/core/fonts_utils.js`: SEAC_ANALYSIS_ENABLED
- `../../src/core/function.js`: PDFFunctionFactory, PostScriptCompiler, PostScriptEvaluator
- `../../src/core/glyphlist.js`: getDingbatsGlyphsUnicode, getGlyphsUnicode
- `../../src/core/image_utils.js`: GlobalImageCache, LocalColorSpaceCache
- `../../src/core/jbig2.js`: Jbig2Image
- `../../src/core/jpg.js`: JpegImage
- `../../src/core/jpx.js`: JpxImage
- `../../src/core/metadata_parser.js`: MetadataParser
- `../../src/core/operator_list.js`: OperatorList
- `../../src/core/parser.js`: Lexer, Linearization, Parser
- `../../src/core/predictor_stream.js`: PredictorStream
- `../../src/core/primitives.js`: Cmd, Dict, EOF, Name, Ref, RefSet, RefSetCache, isCmd, isDict, isName, isRefsEqual
- `../../src/core/ps_parser.js`: PostScriptLexer, PostScriptParser
- `../../src/core/stream.js`: NullStream, Stream, StringStream
- `../../src/core/type1_parser.js`: Type1Parser
- `../../src/core/unicode.js`: getCharUnicodeCategory, getUnicodeForGlyph, getUnicodeRangeFor, mapSpecialUnicodeValues
- `../../src/core/worker.js`: WorkerMessageHandler, WorkerTask
- `../../src/core/writer.js`: incrementalUpdate, writeDict
- `../../src/core/xfa/bind.js`: Binder
- `../../src/core/xfa/data.js`: DataHandler
- `../../src/core/xfa/factory.js`: XFAFactory
- `../../src/core/xfa/formcalc_lexer.js`: Lexer, TOKEN, Token
- `../../src/core/xfa/formcalc_parser.js`: Errors, Parser
- `../../src/core/xfa/parser.js`: XFAParser
- `../../src/core/xfa/som.js`: searchNode
- `../../src/core/xfa/symbol_utils.js`: $dump, $getChildren, $getChildrenByClass, $getChildrenByName, $text, $uid
- `../../src/core/xml_parser.js`: SimpleXMLParser, XMLParserBase
- `../../src/display/annotation_layer.js`: AnnotationLayer
- `../../src/display/annotation_storage.js`: AnnotationStorage
- `../../src/display/api.js`: DefaultCMapReaderFactory, DefaultCanvasFactory, DefaultStandardFontDataFactory, LoopbackPort, PDFDataRangeTransport, PDFDocumentLoadingTask, PDFDocumentProxy, PDFPageProxy, PDFWorker, PDFWorkerUtil, RenderTask, SVGGraphics, build, getDocument, version
- `../../src/display/display_utils.js`: DOMCanvasFactory, DOMSVGFactory, PDFDateString, PageViewport, PixelsPerInch, RenderingCancelledException, StatTimer, getFilenameFromUrl, getPdfFilenameFromUrl, getXfaPageViewport, isDataScheme, isPdfFile, isValidFetchUrl, loadScript, setLayerDimensions
- `../../src/display/editor/annotation_editor_layer.js`: AnnotationEditorLayer
- `../../src/display/editor/tools.js`: AnnotationEditorUIManager, CommandManager
- `../../src/display/fetch_stream.js`: PDFFetchStream
- `../../src/display/metadata.js`: Metadata
- `../../src/display/network.js`: PDFNetworkStream
- `../../src/display/network_utils.js`: createResponseStatusError, extractFilenameFromHeader, validateRangeRequestCapabilities, validateResponseStatus
- `../../src/display/node_stream.js`: PDFNodeStream
- `../../src/display/svg.js`: SVGGraphics
- `../../src/display/text_layer.js`: TextLayerRenderTask, renderTextLayer, updateTextLayer
- `../../src/display/worker_options.js`: GlobalWorkerOptions
- `../../src/display/xfa_layer.js`: XfaLayer
- `../../src/shared/message_handler.js`: MessageHandler
- `../../src/shared/murmurhash3.js`: MurmurHash3_64
- `../../src/shared/util.js`: AbortException, AnnotationBorderStyleType, AnnotationEditorParamsType, AnnotationEditorType, AnnotationFieldFlag, AnnotationFlag, AnnotationMode, AnnotationType, CMapCompressionType, FeatureTest, FormatError, ImageKind, InvalidPDFException, MissingPDFException, OPS, PasswordException, PasswordResponses, PermissionFlag, PromiseCapability, RenderingIntentFlag, UnexpectedResponseException, UnknownErrorException, Util, VerbosityLevel, bytesToString, createValidAbsoluteUrl, getModificationDate, getVerbosityLevel, isArrayBuffer, isNodeJS, normalizeUnicode, objectSize, setVerbosityLevel, shadow, string32, stringToBytes, stringToPDFString, stringToUTF8String
- `../../web/annotation_layer_builder.js`: AnnotationLayerBuilder
- `../../web/download_manager.js`: DownloadManager
- `../../web/event_utils.js`: EventBus, WaitOnType, waitOnEventOrTimeout
- `../../web/genericl10n.js`: GenericL10n
- `../../web/l10n_utils.js`: NullL10n
- `../../web/pdf_find_controller.js`: FindState, PDFFindController
- `../../web/pdf_find_utils.js`: CharacterType, getCharacterType
- `../../web/pdf_history.js`: PDFHistory, isDestArraysEqual, isDestHashesEqual
- `../../web/pdf_link_service.js`: LinkTarget, PDFLinkService, SimpleLinkService
- `../../web/pdf_page_view.js`: PDFPageView
- `../../web/pdf_scripting_manager.component.js`: PDFScriptingManager
- `../../web/pdf_single_page_viewer.js`: PDFSinglePageViewer
- `../../web/pdf_viewer.js`: PDFPageViewBuffer, PDFViewer
- `../../web/struct_tree_layer_builder.js`: StructTreeLayerBuilder
- `../../web/text_layer_builder.js`: TextLayerBuilder
- `../../web/ui_utils.js`: AutoPrintRegExp, ProgressBar, RenderingStates, ScrollMode, SpreadMode, backtrackBeforeAllVisibleElements, binarySearchFirstItem, getPageSizeInches, getVisibleElements, isPortraitOrientation, isValidRotation, parseQueryString, removeNullCharacters
- `../../web/xfa_layer_builder.js`: XfaLayerBuilder
- `./test_utils.js`: CMAP_URL, DefaultFileReaderFactory, STANDARD_FONT_DATA_URL, TEST_PDFS_PATH, XRefMock, buildGetDocumentParams, createIdFactory
- `./testreporter.js`: TestReporter
</imports>

Code:
<code>
File:
src/display/canvas.js
1 /* Copyright 2012 Mozilla Foundation
2  *
3  * Licensed under the Apache License, Version 2.0 (the "License");
4  * you may not use this file except in compliance with the License.
5  * You may obtain a copy of the License at
6  *
7  *     http://www.apache.org/licenses/LICENSE-2.0
8  *
9  * Unless required by applicable law or agreed to in writing, software
10  * distributed under the License is distributed on an "AS IS" BASIS,
11  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
12  * See the License for the specific language governing permissions and
13  * limitations under the License.
14  */
15 
16 import {
17   FeatureTest,
18   FONT_IDENTITY_MATRIX,
19   IDENTITY_MATRIX,
20   ImageKind,
21   info,
22   isNodeJS,
23   OPS,
24   shadow,
25   TextRenderingMode,
26   unreachable,
27   Util,
28   warn,
29 } from "../shared/util.js";
30 import {
31   getCurrentTransform,
32   getCurrentTransformInverse,
33   PixelsPerInch,
34 } from "./display_utils.js";
35 import {
36   getShadingPattern,
37   PathType,
38   TilingPattern,
39 } from "./pattern_helper.js";
40 import { convertBlackAndWhiteToRGBA } from "../shared/image_utils.js";
41 
42 // <canvas> contexts store most of the state we need natively.
43 // However, PDF needs a bit more state, which we store here.
44 // Minimal font size that would be used during canvas fillText operations.
45 const MIN_FONT_SIZE = 16;
46 // Maximum font size that would be used during canvas fillText operations.
47 const MAX_FONT_SIZE = 100;
48 const MAX_GROUP_SIZE = 4096;
49 
50 // Defines the time the `executeOperatorList`-method is going to be executing
51 // before it stops and schedules a continue of execution.
52 const EXECUTION_TIME = 15; // ms
53 // Defines the number of steps before checking the execution time.
54 const EXECUTION_STEPS = 10;
55 
56 // To disable Type3 compilation, set the value to `-1`.
57 const MAX_SIZE_TO_COMPILE = 1000;
58 
59 const FULL_CHUNK_HEIGHT = 16;
60 
61 /**
62  * Overrides certain methods on a 2d ctx so that when they are called they
63  * will also call the same method on the destCtx. The methods that are
64  * overridden are all the transformation state modifiers, path creation, and
65  * save/restore. We only forward these specific methods because they are the
66  * only state modifiers that we cannot copy over when we switch contexts.
67  *
68  * To remove mirroring call `ctx._removeMirroring()`.
69  *
70  * @param {Object} ctx - The 2d canvas context that will duplicate its calls on
71  *   the destCtx.
72  * @param {Object} destCtx - The 2d canvas context that will receive the
73  *   forwarded calls.
74  */
75 function mirrorContextOperations(ctx, destCtx) {
76   if (ctx._removeMirroring) {
77     throw new Error("Context is already forwarding operations.");
78   }
79   ctx.__originalSave = ctx.save;
80   ctx.__originalRestore = ctx.restore;
81   ctx.__originalRotate = ctx.rotate;
82   ctx.__originalScale = ctx.scale;
83   ctx.__originalTranslate = ctx.translate;
84   ctx.__originalTransform = ctx.transform;
85   ctx.__originalSetTransform = ctx.setTransform;
86   ctx.__originalResetTransform = ctx.resetTransform;
87   ctx.__originalClip = ctx.clip;
88   ctx.__originalMoveTo = ctx.moveTo;
89   ctx.__originalLineTo = ctx.lineTo;
90   ctx.__originalBezierCurveTo = ctx.bezierCurveTo;
91   ctx.__originalRect = ctx.rect;
92   ctx.__originalClosePath = ctx.closePath;
93   ctx.__originalBeginPath = ctx.beginPath;
94 
95   ctx._removeMirroring = () => {
96     ctx.save = ctx.__originalSave;
97     ctx.restore = ctx.__originalRestore;
98     ctx.rotate = ctx.__originalRotate;
99     ctx.scale = ctx.__originalScale;
100     ctx.translate = ctx.__originalTranslate;
101     ctx.transform = ctx.__originalTransform;
102     ctx.setTransform = ctx.__originalSetTransform;
103     ctx.resetTransform = ctx.__originalResetTransform;
104 
105     ctx.clip = ctx.__originalClip;
106     ctx.moveTo = ctx.__originalMoveTo;
107     ctx.lineTo = ctx.__originalLineTo;
108     ctx.bezierCurveTo = ctx.__originalBezierCurveTo;
109     ctx.rect = ctx.__originalRect;
110     ctx.closePath = ctx.__originalClosePath;
111     ctx.beginPath = ctx.__originalBeginPath;
112     delete ctx._removeMirroring;
113   };
114 
115   ctx.save = function ctxSave() {
116     destCtx.save();
117     this.__originalSave();
118   };
119 
120   ctx.restore = function ctxRestore() {
121     destCtx.restore();
122     this.__originalRestore();
123   };
124 
125   ctx.translate = function ctxTranslate(x, y) {
126     destCtx.translate(x, y);
127     this.__originalTranslate(x, y);
128   };
129 
130   ctx.scale = function ctxScale(x, y) {
131     destCtx.scale(x, y);
132     this.__originalScale(x, y);
133   };
134 
135   ctx.transform = function ctxTransform(a, b, c, d, e, f) {
136     destCtx.transform(a, b, c, d, e, f);
137     this.__originalTransform(a, b, c, d, e, f);
138   };
139 
140   ctx.setTransform = function ctxSetTransform(a, b, c, d, e, f) {
141     destCtx.setTransform(a, b, c, d, e, f);
142     this.__originalSetTransform(a, b, c, d, e, f);
143   };
144 
145   ctx.resetTransform = function ctxResetTransform() {
146     destCtx.resetTransform();
147     this.__originalResetTransform();
148   };
149 
150   ctx.rotate = function ctxRotate(angle) {
151     destCtx.rotate(angle);
152     this.__originalRotate(angle);
153   };
154 
155   ctx.clip = function ctxRotate(rule) {
156     destCtx.clip(rule);
157     this.__originalClip(rule);
158   };
159 
160   ctx.moveTo = function (x, y) {
161     destCtx.moveTo(x, y);
162     this.__originalMoveTo(x, y);
163   };
164 
165   ctx.lineTo = function (x, y) {
166     destCtx.lineTo(x, y);
167     this.__originalLineTo(x, y);
168   };
169 
170   ctx.bezierCurveTo = function (cp1x, cp1y, cp2x, cp2y, x, y) {
171     destCtx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y);
172     this.__originalBezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y);
173   };
174 
175   ctx.rect = function (x, y, width, height) {
176     destCtx.rect(x, y, width, height);
177     this.__originalRect(x, y, width, height);
178   };
179 
180   ctx.closePath = function () {
181     destCtx.closePath();
182     this.__originalClosePath();
183   };
184 
185   ctx.beginPath = function () {
186     destCtx.beginPath();
187     this.__originalBeginPath();
188   };
189 }
190 
191 class CachedCanvases {
192   constructor(canvasFactory) {
193     this.canvasFactory = canvasFactory;
194     this.cache = Object.create(null);
195   }
196 
197   getCanvas(id, width, height) {
198     let canvasEntry;
199     if (this.cache[id] !== undefined) {
200       canvasEntry = this.cache[id];
201       this.canvasFactory.reset(canvasEntry, width, height);
202     } else {
203       canvasEntry = this.canvasFactory.create(width, height);
204       this.cache[id] = canvasEntry;
205     }
206     return canvasEntry;
207   }
208 
209   delete(id) {
210     delete this.cache[id];
211   }
212 
213   clear() {
214     for (const id in this.cache) {
215       const canvasEntry = this.cache[id];
216       this.canvasFactory.destroy(canvasEntry);
217       delete this.cache[id];
218     }
219   }
220 }
221 
222 function drawImageAtIntegerCoords(
223   ctx,
224   srcImg,
225   srcX,
226   srcY,
227   srcW,
228   srcH,
229   destX,
230   destY,
231   destW,
232   destH
233 ) {
234   const [a, b, c, d, tx, ty] = getCurrentTransform(ctx);
235   if (b === 0 && c === 0) {
236     // top-left corner is at (X, Y) and
237     // bottom-right one is at (X + width, Y + height).
238 
239     // If leftX is 4.321 then it's rounded to 4.
240     // If width is 10.432 then it's rounded to 11 because
241     // rightX = leftX + width = 14.753 which is rounded to 15
242     // so after rounding the total width is 11 (15 - 4).
243     // It's why we can't just floor/ceil uniformly, it just depends
244     // on the values we've.
245 
246     const tlX = destX * a + tx;
247     const rTlX = Math.round(tlX);
248     const tlY = destY * d + ty;
249     const rTlY = Math.round(tlY);
250     const brX = (destX + destW) * a + tx;
251 
252     // Some pdf contains images with 1x1 images so in case of 0-width after
253     // scaling we must fallback on 1 to be sure there is something.
254     const rWidth = Math.abs(Math.round(brX) - rTlX) || 1;
255     const brY = (destY + destH) * d + ty;
256     const rHeight = Math.abs(Math.round(brY) - rTlY) || 1;
257 
258     // We must apply a transformation in order to apply it on the image itself.
259     // For example if a == 1 && d == -1, it means that the image itself is
260     // mirrored w.r.t. the x-axis.
261     ctx.setTransform(Math.sign(a), 0, 0, Math.sign(d), rTlX, rTlY);
262     ctx.drawImage(srcImg, srcX, srcY, srcW, srcH, 0, 0, rWidth, rHeight);
263     ctx.setTransform(a, b, c, d, tx, ty);
264 
265     return [rWidth, rHeight];
266   }
267 
268   if (a === 0 && d === 0) {
269     // This path is taken in issue9462.pdf (page 3).
270     const tlX = destY * c + tx;
271     const rTlX = Math.round(tlX);
272     const tlY = destX * b + ty;
273     const rTlY = Math.round(tlY);
274     const brX = (destY + destH) * c + tx;
275     const rWidth = Math.abs(Math.round(brX) - rTlX) || 1;
276     const brY = (destX + destW) * b + ty;
277     const rHeight = Math.abs(Math.round(brY) - rTlY) || 1;
278 
279     ctx.setTransform(0, Math.sign(b), Math.sign(c), 0, rTlX, rTlY);
280     ctx.drawImage(srcImg, srcX, srcY, srcW, srcH, 0, 0, rHeight, rWidth);
281     ctx.setTransform(a, b, c, d, tx, ty);
282 
283     return [rHeight, rWidth];
284   }
285 
286   // Not a scale matrix so let the render handle the case without rounding.
287   ctx.drawImage(srcImg, srcX, srcY, srcW, srcH, destX, destY, destW, destH);
288 
289   const scaleX = Math.hypot(a, b);
290   const scaleY = Math.hypot(c, d);
291   return [scaleX * destW, scaleY * destH];
292 }
293 
294 function compileType3Glyph(imgData) {
295   const { width, height } = imgData;
296   if (width > MAX_SIZE_TO_COMPILE || height > MAX_SIZE_TO_COMPILE) {
297     return null;
298   }
299 
300   const POINT_TO_PROCESS_LIMIT = 1000;
301   const POINT_TYPES = new Uint8Array([
302     0, 2, 4, 0, 1, 0, 5, 4, 8, 10, 0, 8, 0, 2, 1, 0,
303   ]);
304 
305   const width1 = width + 1;
306   let points = new Uint8Array(width1 * (height + 1));
307   let i, j, j0;
308 
309   // decodes bit-packed mask data
310   const lineSize = (width + 7) & ~7;
311   let data = new Uint8Array(lineSize * height),
312     pos = 0;
313   for (const elem of imgData.data) {
314     let mask = 128;
315     while (mask > 0) {
316       data[pos++] = elem & mask ? 0 : 255;
317       mask >>= 1;
318     }
319   }
320 
321   // finding interesting points: every point is located between mask pixels,
322   // so there will be points of the (width + 1)x(height + 1) grid. Every point
323   // will have flags assigned based on neighboring mask pixels:
324   //   4 | 8
325   //   --P--
326   //   2 | 1
327   // We are interested only in points with the flags:
328   //   - outside corners: 1, 2, 4, 8;
329   //   - inside corners: 7, 11, 13, 14;
330   //   - and, intersections: 5, 10.
331   let count = 0;
332   pos = 0;
333   if (data[pos] !== 0) {
334     points[0] = 1;
335     ++count;
336   }
337   for (j = 1; j < width; j++) {
338     if (data[pos] !== data[pos + 1]) {
339       points[j] = data[pos] ? 2 : 1;
340       ++count;
341     }
342     pos++;
343   }
344   if (data[pos] !== 0) {
345     points[j] = 2;
346     ++count;
347   }
348   for (i = 1; i < height; i++) {
349     pos = i * lineSize;
350     j0 = i * width1;
351     if (data[pos - lineSize] !== data[pos]) {
352       points[j0] = data[pos] ? 1 : 8;
353       ++count;
354     }
355     // 'sum' is the position of the current pixel configuration in the 'TYPES'
356     // array (in order 8-1-2-4, so we can use '>>2' to shift the column).
357     let sum = (data[pos] ? 4 : 0) + (data[pos - lineSize] ? 8 : 0);
358     for (j = 1; j < width; j++) {
359       sum =
360         (sum >> 2) +
361         (data[pos + 1] ? 4 : 0) +
362         (data[pos - lineSize + 1] ? 8 : 0);
363       if (POINT_TYPES[sum]) {
364         points[j0 + j] = POINT_TYPES[sum];
365         ++count;
366       }
367       pos++;
368     }
369     if (data[pos - lineSize] !== data[pos]) {
370       points[j0 + j] = data[pos] ? 2 : 4;
371       ++count;
372     }
373 
374     if (count > POINT_TO_PROCESS_LIMIT) {
375       return null;
376     }
377   }
378 
379   pos = lineSize * (height - 1);
380   j0 = i * width1;
381   if (data[pos] !== 0) {
382     points[j0] = 8;
383     ++count;
384   }
385   for (j = 1; j < width; j++) {
386     if (data[pos] !== data[pos + 1]) {
387       points[j0 + j] = data[pos] ? 4 : 8;
388       ++count;
389     }
390     pos++;
391   }
392   if (data[pos] !== 0) {
393     points[j0 + j] = 4;
394     ++count;
395   }
396   if (count > POINT_TO_PROCESS_LIMIT) {
397     return null;
398   }
399 
400   // building outlines
401   const steps = new Int32Array([0, width1, -1, 0, -width1, 0, 0, 0, 1]);
402   const path = new Path2D();
403 
404   for (i = 0; count && i <= height; i++) {
405     let p = i * width1;
406     const end = p + width;
407     while (p < end && !points[p]) {
408       p++;
409     }
410     if (p === end) {
411       continue;
412     }
413     path.moveTo(p % width1, i);
414 
415     const p0 = p;
416     let type = points[p];
417     do {
418       const step = steps[type];
419       do {
420         p += step;
421       } while (!points[p]);
422 
423       const pp = points[p];
424       if (pp !== 5 && pp !== 10) {
425         // set new direction
426         type = pp;
427         // delete mark
428         points[p] = 0;
429       } else {
430         // type is 5 or 10, ie, a crossing
431         // set new direction
432         type = pp & ((0x33 * type) >> 4);
433         // set new type for "future hit"
434         points[p] &= (type >> 2) | (type << 2);
435       }
436       path.lineTo(p % width1, (p / width1) | 0);
437 
438       if (!points[p]) {
439         --count;
440       }
441     } while (p0 !== p);
442     --i;
443   }
444 
445   // Immediately release the, potentially large, `Uint8Array`s after parsing.
446   data = null;
447   points = null;
448 
449   const drawOutline = function (c) {
450     c.save();
451     // the path shall be painted in [0..1]x[0..1] space
452     c.scale(1 / width, -1 / height);
453     c.translate(0, -height);
454     c.fill(path);
455     c.beginPath();
456     c.restore();
457   };
458 
459   return drawOutline;
460 }
461 
462 class CanvasExtraState {
463   constructor(width, height) {
464     // Are soft masks and alpha values shapes or opacities?
465     this.alphaIsShape = false;
466     this.fontSize = 0;
467     this.fontSizeScale = 1;
468     this.textMatrix = IDENTITY_MATRIX;
469     this.textMatrixScale = 1;
470     this.fontMatrix = FONT_IDENTITY_MATRIX;
471     this.leading = 0;
472     // Current point (in user coordinates)
473     this.x = 0;
474     this.y = 0;
475     // Start of text line (in text coordinates)
476     this.lineX = 0;
477     this.lineY = 0;
478     // Character and word spacing
479     this.charSpacing = 0;
480     this.wordSpacing = 0;
481     this.textHScale = 1;
482     this.textRenderingMode = TextRenderingMode.FILL;
483     this.textRise = 0;
484     // Default fore and background colors
485     this.fillColor = "#000000";
486     this.strokeColor = "#000000";
487     this.patternFill = false;
488     // Note: fill alpha applies to all non-stroking operations
489     this.fillAlpha = 1;
490     this.strokeAlpha = 1;
491     this.lineWidth = 1;
492     this.activeSMask = null;
493     this.transferMaps = "none";
494 
495     this.startNewPathAndClipBox([0, 0, width, height]);
496   }
497 
498   clone() {
499     const clone = Object.create(this);
500     clone.clipBox = this.clipBox.slice();
501     return clone;
502   }
503 
504   setCurrentPoint(x, y) {
505     this.x = x;
506     this.y = y;
507   }
508 
509   updatePathMinMax(transform, x, y) {
510     [x, y] = Util.applyTransform([x, y], transform);
511     this.minX = Math.min(this.minX, x);
512     this.minY = Math.min(this.minY, y);
513     this.maxX = Math.max(this.maxX, x);
514     this.maxY = Math.max(this.maxY, y);
515   }
516 
517   updateRectMinMax(transform, rect) {
518     const p1 = Util.applyTransform(rect, transform);
519     const p2 = Util.applyTransform(rect.slice(2), transform);
520     this.minX = Math.min(this.minX, p1[0], p2[0]);
521     this.minY = Math.min(this.minY, p1[1], p2[1]);
522     this.maxX = Math.max(this.maxX, p1[0], p2[0]);
523     this.maxY = Math.max(this.maxY, p1[1], p2[1]);
524   }
525 
526   updateScalingPathMinMax(transform, minMax) {
527     Util.scaleMinMax(transform, minMax);
528     this.minX = Math.min(this.minX, minMax[0]);
529     this.maxX = Math.max(this.maxX, minMax[1]);
530     this.minY = Math.min(this.minY, minMax[2]);
531     this.maxY = Math.max(this.maxY, minMax[3]);
532   }
533 
534   updateCurvePathMinMax(transform, x0, y0, x1, y1, x2, y2, x3, y3, minMax) {
535     const box = Util.bezierBoundingBox(x0, y0, x1, y1, x2, y2, x3, y3);
536     if (minMax) {
537       minMax[0] = Math.min(minMax[0], box[0], box[2]);
538       minMax[1] = Math.max(minMax[1], box[0], box[2]);
539       minMax[2] = Math.min(minMax[2], box[1], box[3]);
540       minMax[3] = Math.max(minMax[3], box[1], box[3]);
541       return;
542     }
543     this.updateRectMinMax(transform, box);
544   }
545 
546   getPathBoundingBox(pathType = PathType.FILL, transform = null) {
547     const box = [this.minX, this.minY, this.maxX, this.maxY];
548     if (pathType === PathType.STROKE) {
549       if (!transform) {
550         unreachable("Stroke bounding box must include transform.");
551       }
552       // Stroked paths can be outside of the path bounding box by 1/2 the line
553       // width.
554       const scale = Util.singularValueDecompose2dScale(transform);
555       const xStrokePad = (scale[0] * this.lineWidth) / 2;
556       const yStrokePad = (scale[1] * this.lineWidth) / 2;
557       box[0] -= xStrokePad;
558       box[1] -= yStrokePad;
559       box[2] += xStrokePad;
560       box[3] += yStrokePad;
561     }
562     return box;
563   }
564 
565   updateClipFromPath() {
566     const intersect = Util.intersect(this.clipBox, this.getPathBoundingBox());
567     this.startNewPathAndClipBox(intersect || [0, 0, 0, 0]);
568   }
569 
570   isEmptyClip() {
571     return this.minX === Infinity;
572   }
573 
574   startNewPathAndClipBox(box) {
575     this.clipBox = box;
576     this.minX = Infinity;
577     this.minY = Infinity;
578     this.maxX = 0;
579     this.maxY = 0;
580   }
581 
582   getClippedPathBoundingBox(pathType = PathType.FILL, transform = null) {
583     return Util.intersect(
584       this.clipBox,
585       this.getPathBoundingBox(pathType, transform)
586     );
587   }
588 }
589 
590 function putBinaryImageData(ctx, imgData) {
591   if (typeof ImageData !== "undefined" && imgData instanceof ImageData) {
592     ctx.putImageData(imgData, 0, 0);
593     return;
594   }
595 
596   // Put the image data to the canvas in chunks, rather than putting the
597   // whole image at once.  This saves JS memory, because the ImageData object
598   // is smaller. It also possibly saves C++ memory within the implementation
599   // of putImageData(). (E.g. in Firefox we make two short-lived copies of
600   // the data passed to putImageData()). |n| shouldn't be too small, however,
601   // because too many putImageData() calls will slow things down.
602   //
603   // Note: as written, if the last chunk is partial, the putImageData() call
604   // will (conceptually) put pixels past the bounds of the canvas.  But
605   // that's ok; any such pixels are ignored.
606 
607   const height = imgData.height,
608     width = imgData.width;
609   const partialChunkHeight = height % FULL_CHUNK_HEIGHT;
610   const fullChunks = (height - partialChunkHeight) / FULL_CHUNK_HEIGHT;
611   const totalChunks = partialChunkHeight === 0 ? fullChunks : fullChunks + 1;
612 
613   const chunkImgData = ctx.createImageData(width, FULL_CHUNK_HEIGHT);
614   let srcPos = 0,
615     destPos;
616   const src = imgData.data;
617   const dest = chunkImgData.data;
618   let i, j, thisChunkHeight, elemsInThisChunk;
619 
620   // There are multiple forms in which the pixel data can be passed, and
621   // imgData.kind tells us which one this is.
622   if (imgData.kind === ImageKind.GRAYSCALE_1BPP) {
623     // Grayscale, 1 bit per pixel (i.e. black-and-white).
624     const srcLength = src.byteLength;
625     const dest32 = new Uint32Array(dest.buffer, 0, dest.byteLength >> 2);
626     const dest32DataLength = dest32.length;
627     const fullSrcDiff = (width + 7) >> 3;
628     const white = 0xffffffff;
629     const black = FeatureTest.isLittleEndian ? 0xff000000 : 0x000000ff;
630 
631     for (i = 0; i < totalChunks; i++) {
632       thisChunkHeight = i < fullChunks ? FULL_CHUNK_HEIGHT : partialChunkHeight;
633       destPos = 0;
634       for (j = 0; j < thisChunkHeight; j++) {
635         const srcDiff = srcLength - srcPos;
636         let k = 0;
637         const kEnd = srcDiff > fullSrcDiff ? width : srcDiff * 8 - 7;
638         const kEndUnrolled = kEnd & ~7;
639         let mask = 0;
640         let srcByte = 0;
641         for (; k < kEndUnrolled; k += 8) {
642           srcByte = src[srcPos++];
643           dest32[destPos++] = srcByte & 128 ? white : black;
644           dest32[destPos++] = srcByte & 64 ? white : black;
645           dest32[destPos++] = srcByte & 32 ? white : black;
646           dest32[destPos++] = srcByte & 16 ? white : black;
647           dest32[destPos++] = srcByte & 8 ? white : black;
648           dest32[destPos++] = srcByte & 4 ? white : black;
649           dest32[destPos++] = srcByte & 2 ? white : black;
650           dest32[destPos++] = srcByte & 1 ? white : black;
651         }
652         for (; k < kEnd; k++) {
653           if (mask === 0) {
654             srcByte = src[srcPos++];
655             mask = 128;
656           }
657 
658           dest32[destPos++] = srcByte & mask ? white : black;
659           mask >>= 1;
660         }
661       }
662       // We ran out of input. Make all remaining pixels transparent.
663       while (destPos < dest32DataLength) {
664         dest32[destPos++] = 0;
665       }
666 
667       ctx.putImageData(chunkImgData, 0, i * FULL_CHUNK_HEIGHT);
668     }
669   } else if (imgData.kind === ImageKind.RGBA_32BPP) {
670     // RGBA, 32-bits per pixel.
671     j = 0;
672     elemsInThisChunk = width * FULL_CHUNK_HEIGHT * 4;
673     for (i = 0; i < fullChunks; i++) {
674       dest.set(src.subarray(srcPos, srcPos + elemsInThisChunk));
675       srcPos += elemsInThisChunk;
676 
677       ctx.putImageData(chunkImgData, 0, j);
678       j += FULL_CHUNK_HEIGHT;
679     }
680     if (i < totalChunks) {
681       elemsInThisChunk = width * partialChunkHeight * 4;
682       dest.set(src.subarray(srcPos, srcPos + elemsInThisChunk));
683 
684       ctx.putImageData(chunkImgData, 0, j);
685     }
686   } else if (imgData.kind === ImageKind.RGB_24BPP) {
687     // RGB, 24-bits per pixel.
688     thisChunkHeight = FULL_CHUNK_HEIGHT;
689     elemsInThisChunk = width * thisChunkHeight;
690     for (i = 0; i < totalChunks; i++) {
691       if (i >= fullChunks) {
692         thisChunkHeight = partialChunkHeight;
693         elemsInThisChunk = width * thisChunkHeight;
694       }
695 
696       destPos = 0;
697       for (j = elemsInThisChunk; j--; ) {
698         dest[destPos++] = src[srcPos++];
699         dest[destPos++] = src[srcPos++];
700         dest[destPos++] = src[srcPos++];
701         dest[destPos++] = 255;
702       }
703 
704       ctx.putImageData(chunkImgData, 0, i * FULL_CHUNK_HEIGHT);
705     }
706   } else {
707     throw new Error(`bad image kind: ${imgData.kind}`);
708   }
709 }
710 
711 function putBinaryImageMask(ctx, imgData) {
712   if (imgData.bitmap) {
713     // The bitmap has been created in the worker.
714     ctx.drawImage(imgData.bitmap, 0, 0);
715     return;
716   }
717 
718   // Slow path: OffscreenCanvas isn't available in the worker.
719   const height = imgData.height,
720     width = imgData.width;
721   const partialChunkHeight = height % FULL_CHUNK_HEIGHT;
722   const fullChunks = (height - partialChunkHeight) / FULL_CHUNK_HEIGHT;
723   const totalChunks = partialChunkHeight === 0 ? fullChunks : fullChunks + 1;
724 
725   const chunkImgData = ctx.createImageData(width, FULL_CHUNK_HEIGHT);
726   let srcPos = 0;
727   const src = imgData.data;
728   const dest = chunkImgData.data;
729 
730   for (let i = 0; i < totalChunks; i++) {
731     const thisChunkHeight =
732       i < fullChunks ? FULL_CHUNK_HEIGHT : partialChunkHeight;
733 
734     // Expand the mask so it can be used by the canvas.  Any required
735     // inversion has already been handled.
736 
737     ({ srcPos } = convertBlackAndWhiteToRGBA({
738       src,
739       srcPos,
740       dest,
741       width,
742       height: thisChunkHeight,
743       nonBlackColor: 0,
744     }));
745 
746     ctx.putImageData(chunkImgData, 0, i * FULL_CHUNK_HEIGHT);
747   }
748 }
749 
750 function copyCtxState(sourceCtx, destCtx) {
751   const properties = [
752     "strokeStyle",
753     "fillStyle",
754     "fillRule",
755     "globalAlpha",
756     "lineWidth",
757     "lineCap",
758     "lineJoin",
759     "miterLimit",
760     "globalCompositeOperation",
761     "font",
762     "filter",
763   ];
764   for (const property of properties) {
765     if (sourceCtx[property] !== undefined) {
766       destCtx[property] = sourceCtx[property];
767     }
768   }
769   if (sourceCtx.setLineDash !== undefined) {
770     destCtx.setLineDash(sourceCtx.getLineDash());
771     destCtx.lineDashOffset = sourceCtx.lineDashOffset;
772   }
773 }
774 
775 function resetCtxToDefault(ctx) {
776   ctx.strokeStyle = ctx.fillStyle = "#000000";
777   ctx.fillRule = "nonzero";
778   ctx.globalAlpha = 1;
779   ctx.lineWidth = 1;
780   ctx.lineCap = "butt";
781   ctx.lineJoin = "miter";
782   ctx.miterLimit = 10;
783   ctx.globalCompositeOperation = "source-over";
784   ctx.font = "10px sans-serif";
785   if (ctx.setLineDash !== undefined) {
786     ctx.setLineDash([]);
787     ctx.lineDashOffset = 0;
788   }
789   if (
790     (typeof PDFJSDev !== "undefined" && PDFJSDev.test("MOZCENTRAL")) ||
791     !isNodeJS
792   ) {
793     ctx.filter = "none";
794   }
795 }
796 
797 function composeSMaskBackdrop(bytes, r0, g0, b0) {
798   const length = bytes.length;
799   for (let i = 3; i < length; i += 4) {
800     const alpha = bytes[i];
801     if (alpha === 0) {
802       bytes[i - 3] = r0;
803       bytes[i - 2] = g0;
804       bytes[i - 1] = b0;
805     } else if (alpha < 255) {
806       const alpha_ = 255 - alpha;
807       bytes[i - 3] = (bytes[i - 3] * alpha + r0 * alpha_) >> 8;
808       bytes[i - 2] = (bytes[i - 2] * alpha + g0 * alpha_) >> 8;
809       bytes[i - 1] = (bytes[i - 1] * alpha + b0 * alpha_) >> 8;
810     }
811   }
812 }
813 
814 function composeSMaskAlpha(maskData, layerData, transferMap) {
815   const length = maskData.length;
816   const scale = 1 / 255;
817   for (let i = 3; i < length; i += 4) {
818     const alpha = transferMap ? transferMap[maskData[i]] : maskData[i];
819     layerData[i] = (layerData[i] * alpha * scale) | 0;
820   }
821 }
822 
823 function composeSMaskLuminosity(maskData, layerData, transferMap) {
824   const length = maskData.length;
825   for (let i = 3; i < length; i += 4) {
826     const y =
827       maskData[i - 3] * 77 + // * 0.3 / 255 * 0x10000
828       maskData[i - 2] * 152 + // * 0.59 ....
829       maskData[i - 1] * 28; // * 0.11 ....
830     layerData[i] = transferMap
831       ? (layerData[i] * transferMap[y >> 8]) >> 8
832       : (layerData[i] * y) >> 16;
833   }
834 }
835 
836 function genericComposeSMask(
837   maskCtx,
838   layerCtx,
839   width,
840   height,
841   subtype,
842   backdrop,
843   transferMap,
844   layerOffsetX,
845   layerOffsetY,
846   maskOffsetX,
847   maskOffsetY
848 ) {
849   const hasBackdrop = !!backdrop;
850   const r0 = hasBackdrop ? backdrop[0] : 0;
851   const g0 = hasBackdrop ? backdrop[1] : 0;
852   const b0 = hasBackdrop ? backdrop[2] : 0;
853 
854   let composeFn;
855   if (subtype === "Luminosity") {
856     composeFn = composeSMaskLuminosity;
857   } else {
858     composeFn = composeSMaskAlpha;
859   }
860 
861   // processing image in chunks to save memory
862   const PIXELS_TO_PROCESS = 1048576;
863   const chunkSize = Math.min(height, Math.ceil(PIXELS_TO_PROCESS / width));
864   for (let row = 0; row < height; row += chunkSize) {
865     const chunkHeight = Math.min(chunkSize, height - row);
866     const maskData = maskCtx.getImageData(
867       layerOffsetX - maskOffsetX,
868       row + (layerOffsetY - maskOffsetY),
869       width,
870       chunkHeight
871     );
872     const layerData = layerCtx.getImageData(
873       layerOffsetX,
874       row + layerOffsetY,
875       width,
876       chunkHeight
877     );
878 
879     if (hasBackdrop) {
880       composeSMaskBackdrop(maskData.data, r0, g0, b0);
881     }
882     composeFn(maskData.data, layerData.data, transferMap);
883 
884     layerCtx.putImageData(layerData, layerOffsetX, row + layerOffsetY);
885   }
886 }
887 
888 function composeSMask(ctx, smask, layerCtx, layerBox) {
889   const layerOffsetX = layerBox[0];
890   const layerOffsetY = layerBox[1];
891   const layerWidth = layerBox[2] - layerOffsetX;
892   const layerHeight = layerBox[3] - layerOffsetY;
893   if (layerWidth === 0 || layerHeight === 0) {
894     return;
895   }
896   genericComposeSMask(
897     smask.context,
898     layerCtx,
899     layerWidth,
900     layerHeight,
901     smask.subtype,
902     smask.backdrop,
903     smask.transferMap,
904     layerOffsetX,
905     layerOffsetY,
906     smask.offsetX,
907     smask.offsetY
908   );
909   ctx.save();
910   ctx.globalAlpha = 1;
911   ctx.globalCompositeOperation = "source-over";
912   ctx.setTransform(1, 0, 0, 1, 0, 0);
913   ctx.drawImage(layerCtx.canvas, 0, 0);
914   ctx.restore();
915 }
916 
917 function getImageSmoothingEnabled(transform, interpolate) {
918   const scale = Util.singularValueDecompose2dScale(transform);
919   // Round to a 32bit float so that `<=` check below will pass for numbers that
920   // are very close, but not exactly the same 64bit floats.
921   scale[0] = Math.fround(scale[0]);
922   scale[1] = Math.fround(scale[1]);
923   const actualScale = Math.fround(
924     (globalThis.devicePixelRatio || 1) * PixelsPerInch.PDF_TO_CSS_UNITS
925   );
926   if (interpolate !== undefined) {
927     // If the value is explicitly set use it.
928     return interpolate;
929   } else if (scale[0] <= actualScale || scale[1] <= actualScale) {
930     // Smooth when downscaling.
931     return true;
932   }
933   // Don't smooth when upscaling.
934   return false;
935 }
936 
937 const LINE_CAP_STYLES = ["butt", "round", "square"];
938 const LINE_JOIN_STYLES = ["miter", "round", "bevel"];
939 const NORMAL_CLIP = {};
940 const EO_CLIP = {};
941 
942 class CanvasGraphics {
943   constructor(
944     canvasCtx,
945     commonObjs,
946     objs,
947     canvasFactory,
948     filterFactory,
949     { optionalContentConfig, markedContentStack = null },
950     annotationCanvasMap,
951     pageColors
952   ) {
953     this.ctx = canvasCtx;
954     this.current = new CanvasExtraState(
955       this.ctx.canvas.width,
956       this.ctx.canvas.height
957     );
958     this.stateStack = [];
959     this.pendingClip = null;
960     this.pendingEOFill = false;
961     this.res = null;
962     this.xobjs = null;
963     this.commonObjs = commonObjs;
964     this.objs = objs;
965     this.canvasFactory = canvasFactory;
966     this.filterFactory = filterFactory;
967     this.groupStack = [];
968     this.processingType3 = null;
969     // Patterns are painted relative to the initial page/form transform, see
970     // PDF spec 8.7.2 NOTE 1.
971     this.baseTransform = null;
972     this.baseTransformStack = [];
973     this.groupLevel = 0;
974     this.smaskStack = [];
975     this.smaskCounter = 0;
976     this.tempSMask = null;
977     this.suspendedCtx = null;
978     this.contentVisible = true;
979     this.markedContentStack = markedContentStack || [];
980     this.optionalContentConfig = optionalContentConfig;
981     this.cachedCanvases = new CachedCanvases(this.canvasFactory);
982     this.cachedPatterns = new Map();
983     this.annotationCanvasMap = annotationCanvasMap;
984     this.viewportScale = 1;
985     this.outputScaleX = 1;
986     this.outputScaleY = 1;
987     this.pageColors = pageColors;
988 
989     this._cachedScaleForStroking = [-1, 0];
990     this._cachedGetSinglePixelWidth = null;
991     this._cachedBitmapsMap = new Map();
992   }
993 
994   getObject(data, fallback = null) {
995     if (typeof data === "string") {
996       return data.startsWith("g_")
997         ? this.commonObjs.get(data)
998         : this.objs.get(data);
999     }
1000     return fallback;
1001   }
1002 
1003   beginDrawing({
1004     transform,
1005     viewport,
1006     transparency = false,
1007     background = null,
1008   }) {
1009     // For pdfs that use blend modes we have to clear the canvas else certain
1010     // blend modes can look wrong since we'd be blending with a white
1011     // backdrop. The problem with a transparent backdrop though is we then
1012     // don't get sub pixel anti aliasing on text, creating temporary
1013     // transparent canvas when we have blend modes.
1014     const width = this.ctx.canvas.width;
1015     const height = this.ctx.canvas.height;
1016 
1017     const savedFillStyle = this.ctx.fillStyle;
1018     this.ctx.fillStyle = background || "#ffffff";
1019     this.ctx.fillRect(0, 0, width, height);
1020     this.ctx.fillStyle = savedFillStyle;
1021 
1022     if (transparency) {
1023       const transparentCanvas = this.cachedCanvases.getCanvas(
1024         "transparent",
1025         width,
1026         height
1027       );
1028       this.compositeCtx = this.ctx;
1029       this.transparentCanvas = transparentCanvas.canvas;
1030       this.ctx = transparentCanvas.context;
1031       this.ctx.save();
1032       // The transform can be applied before rendering, transferring it to
1033       // the new canvas.
1034       this.ctx.transform(...getCurrentTransform(this.compositeCtx));
1035     }
1036 
1037     this.ctx.save();
1038     resetCtxToDefault(this.ctx);
1039     if (transform) {
1040       this.ctx.transform(...transform);
1041       this.outputScaleX = transform[0];
1042       this.outputScaleY = transform[0];
1043     }
1044     this.ctx.transform(...viewport.transform);
1045     this.viewportScale = viewport.scale;
1046 
1047     this.baseTransform = getCurrentTransform(this.ctx);
1048   }
1049 
1050   executeOperatorList(
1051     operatorList,
1052     executionStartIdx,
1053     continueCallback,
1054     stepper
1055   ) {
1056     const argsArray = operatorList.argsArray;
1057     const fnArray = operatorList.fnArray;
1058     let i = executionStartIdx || 0;
1059     const argsArrayLen = argsArray.length;
1060 
1061     // Sometimes the OperatorList to execute is empty.
1062     if (argsArrayLen === i) {
1063       return i;
1064     }
1065 
1066     const chunkOperations =
1067       argsArrayLen - i > EXECUTION_STEPS &&
1068       typeof continueCallback === "function";
1069     const endTime = chunkOperations ? Date.now() + EXECUTION_TIME : 0;
1070     let steps = 0;
1071 
1072     const commonObjs = this.commonObjs;
1073     const objs = this.objs;
1074     let fnId;
1075 
1076     while (true) {
1077       if (stepper !== undefined && i === stepper.nextBreakPoint) {
1078         stepper.breakIt(i, continueCallback);
1079         return i;
1080       }
1081 
1082       fnId = fnArray[i];
1083 
1084       if (fnId !== OPS.dependency) {
1085         // eslint-disable-next-line prefer-spread
1086         this[fnId].apply(this, argsArray[i]);
1087       } else {
1088         for (const depObjId of argsArray[i]) {
1089           const objsPool = depObjId.startsWith("g_") ? commonObjs : objs;
1090 
1091           // If the promise isn't resolved yet, add the continueCallback
1092           // to the promise and bail out.
1093           if (!objsPool.has(depObjId)) {
1094             objsPool.get(depObjId, continueCallback);
1095             return i;
1096           }
1097         }
1098       }
1099 
1100       i++;
1101 
1102       // If the entire operatorList was executed, stop as were done.
1103       if (i === argsArrayLen) {
1104         return i;
1105       }
1106 
1107       // If the execution took longer then a certain amount of time and
1108       // `continueCallback` is specified, interrupt the execution.
1109       if (chunkOperations && ++steps > EXECUTION_STEPS) {
1110         if (Date.now() > endTime) {
1111           continueCallback();
1112           return i;
1113         }
1114         steps = 0;
1115       }
1116 
1117       // If the operatorList isn't executed completely yet OR the execution
1118       // time was short enough, do another execution round.
1119     }
1120   }
1121 
1122   #restoreInitialState() {
1123     // Finishing all opened operations such as SMask group painting.
1124     while (this.stateStack.length || this.inSMaskMode) {
1125       this.restore();
1126     }
1127 
1128     this.ctx.restore();
1129 
1130     if (this.transparentCanvas) {
1131       this.ctx = this.compositeCtx;
1132       this.ctx.save();
1133       this.ctx.setTransform(1, 0, 0, 1, 0, 0); // Avoid apply transform twice
1134       this.ctx.drawImage(this.transparentCanvas, 0, 0);
1135       this.ctx.restore();
1136       this.transparentCanvas = null;
1137     }
1138   }
1139 
1140   endDrawing() {
1141     this.#restoreInitialState();
1142 
1143     this.cachedCanvases.clear();
1144     this.cachedPatterns.clear();
1145 
1146     for (const cache of this._cachedBitmapsMap.values()) {
1147       for (const canvas of cache.values()) {
1148         if (
1149           typeof HTMLCanvasElement !== "undefined" &&
1150           canvas instanceof HTMLCanvasElement
1151         ) {
1152           canvas.width = canvas.height = 0;
1153         }
1154       }
1155       cache.clear();
1156     }
1157     this._cachedBitmapsMap.clear();
1158     this.#drawFilter();
1159   }
1160 
1161   #drawFilter() {
1162     if (this.pageColors) {
1163       const hcmFilterId = this.filterFactory.addHCMFilter(
1164         this.pageColors.foreground,
1165         this.pageColors.background
1166       );
1167       if (hcmFilterId !== "none") {
1168         const savedFilter = this.ctx.filter;
1169         this.ctx.filter = hcmFilterId;
1170         this.ctx.drawImage(this.ctx.canvas, 0, 0);
1171         this.ctx.filter = savedFilter;
1172       }
1173     }
1174   }
1175 
1176   _scaleImage(img, inverseTransform) {
1177     // Vertical or horizontal scaling shall not be more than 2 to not lose the
1178     // pixels during drawImage operation, painting on the temporary canvas(es)
1179     // that are twice smaller in size.
1180     const width = img.width;
1181     const height = img.height;
1182     let widthScale = Math.max(
1183       Math.hypot(inverseTransform[0], inverseTransform[1]),
1184       1
1185     );
1186     let heightScale = Math.max(
1187       Math.hypot(inverseTransform[2], inverseTransform[3]),
1188       1
1189     );
1190 
1191     let paintWidth = width,
1192       paintHeight = height;
1193     let tmpCanvasId = "prescale1";
1194     let tmpCanvas, tmpCtx;
1195     while (
1196       (widthScale > 2 && paintWidth > 1) ||
1197       (heightScale > 2 && paintHeight > 1)
1198     ) {
1199       let newWidth = paintWidth,
1200         newHeight = paintHeight;
1201       if (widthScale > 2 && paintWidth > 1) {
1202         // See bug 1820511 (Windows specific bug).
1203         // TODO: once the above bug is fixed we could revert to:
1204         // newWidth = Math.ceil(paintWidth / 2);
1205         newWidth =
1206           paintWidth >= 16384
1207             ? Math.floor(paintWidth / 2) - 1 || 1
1208             : Math.ceil(paintWidth / 2);
1209         widthScale /= paintWidth / newWidth;
1210       }
1211       if (heightScale > 2 && paintHeight > 1) {
1212         // TODO: see the comment above.
1213         newHeight =
1214           paintHeight >= 16384
1215             ? Math.floor(paintHeight / 2) - 1 || 1
1216             : Math.ceil(paintHeight) / 2;
1217         heightScale /= paintHeight / newHeight;
1218       }
1219       tmpCanvas = this.cachedCanvases.getCanvas(
1220         tmpCanvasId,
1221         newWidth,
1222         newHeight
1223       );
1224       tmpCtx = tmpCanvas.context;
1225       tmpCtx.clearRect(0, 0, newWidth, newHeight);
1226       tmpCtx.drawImage(
1227         img,
1228         0,
1229         0,
1230         paintWidth,
1231         paintHeight,
1232         0,
1233         0,
1234         newWidth,
1235         newHeight
1236       );
1237       img = tmpCanvas.canvas;
1238       paintWidth = newWidth;
1239       paintHeight = newHeight;
1240       tmpCanvasId = tmpCanvasId === "prescale1" ? "prescale2" : "prescale1";
1241     }
1242     return {
1243       img,
1244       paintWidth,
1245       paintHeight,
1246     };
1247   }
1248 
1249   _createMaskCanvas(img) {
1250     const ctx = this.ctx;
1251     const { width, height } = img;
1252     const fillColor = this.current.fillColor;
1253     const isPatternFill = this.current.patternFill;
1254     const currentTransform = getCurrentTransform(ctx);
1255 
1256     let cache, cacheKey, scaled, maskCanvas;
1257     if ((img.bitmap || img.data) && img.count > 1) {
1258       const mainKey = img.bitmap || img.data.buffer;
1259       // We're reusing the same image several times, so we can cache it.
1260       // In case we've a pattern fill we just keep the scaled version of
1261       // the image.
1262       // Only the scaling part matters, the translation part is just used
1263       // to compute offsets (but not when filling patterns see #15573).
1264       // TODO: handle the case of a pattern fill if it's possible.
1265       cacheKey = JSON.stringify(
1266         isPatternFill
1267           ? currentTransform
1268           : [currentTransform.slice(0, 4), fillColor]
1269       );
1270 
1271       cache = this._cachedBitmapsMap.get(mainKey);
1272       if (!cache) {
1273         cache = new Map();
1274         this._cachedBitmapsMap.set(mainKey, cache);
1275       }
1276       const cachedImage = cache.get(cacheKey);
1277       if (cachedImage && !isPatternFill) {
1278         const offsetX = Math.round(
1279           Math.min(currentTransform[0], currentTransform[2]) +
1280             currentTransform[4]
1281         );
1282         const offsetY = Math.round(
1283           Math.min(currentTransform[1], currentTransform[3]) +
1284             currentTransform[5]
1285         );
1286         return {
1287           canvas: cachedImage,
1288           offsetX,
1289           offsetY,
1290         };
1291       }
1292       scaled = cachedImage;
1293     }
1294 
1295     if (!scaled) {
1296       maskCanvas = this.cachedCanvases.getCanvas("maskCanvas", width, height);
1297       putBinaryImageMask(maskCanvas.context, img);
1298     }
1299 
1300     // Create the mask canvas at the size it will be drawn at and also set
1301     // its transform to match the current transform so if there are any
1302     // patterns applied they will be applied relative to the correct
1303     // transform.
1304 
1305     let maskToCanvas = Util.transform(currentTransform, [
1306       1 / width,
1307       0,
1308       0,
1309       -1 / height,
1310       0,
1311       0,
1312     ]);
1313     maskToCanvas = Util.transform(maskToCanvas, [1, 0, 0, 1, 0, -height]);
1314     const cord1 = Util.applyTransform([0, 0], maskToCanvas);
1315     const cord2 = Util.applyTransform([width, height], maskToCanvas);
1316     const rect = Util.normalizeRect([cord1[0], cord1[1], cord2[0], cord2[1]]);
1317     const drawnWidth = Math.round(rect[2] - rect[0]) || 1;
1318     const drawnHeight = Math.round(rect[3] - rect[1]) || 1;
1319     const fillCanvas = this.cachedCanvases.getCanvas(
1320       "fillCanvas",
1321       drawnWidth,
1322       drawnHeight
1323     );
1324     const fillCtx = fillCanvas.context;
1325 
1326     // The offset will be the top-left cordinate mask.
1327     // If objToCanvas is [a,b,c,d,e,f] then:
1328     //   - offsetX = min(a, c) + e
1329     //   - offsetY = min(b, d) + f
1330     const offsetX = Math.min(cord1[0], cord2[0]);
1331     const offsetY = Math.min(cord1[1], cord2[1]);
1332     fillCtx.translate(-offsetX, -offsetY);
1333     fillCtx.transform(...maskToCanvas);
1334 
1335     if (!scaled) {
1336       // Pre-scale if needed to improve image smoothing.
1337       scaled = this._scaleImage(
1338         maskCanvas.canvas,
1339         getCurrentTransformInverse(fillCtx)
1340       );
1341       scaled = scaled.img;
1342       if (cache && isPatternFill) {
1343         cache.set(cacheKey, scaled);
1344       }
1345     }
1346 
1347     fillCtx.imageSmoothingEnabled = getImageSmoothingEnabled(
1348       getCurrentTransform(fillCtx),
1349       img.interpolate
1350     );
1351 
1352     drawImageAtIntegerCoords(
1353       fillCtx,
1354       scaled,
1355       0,
1356       0,
1357       scaled.width,
1358       scaled.height,
1359       0,
1360       0,
1361       width,
1362       height
1363     );
1364     fillCtx.globalCompositeOperation = "source-in";
1365 
1366     const inverse = Util.transform(getCurrentTransformInverse(fillCtx), [
1367       1,
1368       0,
1369       0,
1370       1,
1371       -offsetX,
1372       -offsetY,
1373     ]);
1374     fillCtx.fillStyle = isPatternFill
1375       ? fillColor.getPattern(ctx, this, inverse, PathType.FILL)
1376       : fillColor;
1377 
1378     fillCtx.fillRect(0, 0, width, height);
1379 
1380     if (cache && !isPatternFill) {
1381       // The fill canvas is put in the cache associated to the mask image
1382       // so we must remove from the cached canvas: it mustn't be used again.
1383       this.cachedCanvases.delete("fillCanvas");
1384       cache.set(cacheKey, fillCanvas.canvas);
1385     }
1386 
1387     // Round the offsets to avoid drawing fractional pixels.
1388     return {
1389       canvas: fillCanvas.canvas,
1390       offsetX: Math.round(offsetX),
1391       offsetY: Math.round(offsetY),
1392     };
1393   }
1394 
1395   // Graphics state
1396   setLineWidth(width) {
1397     if (width !== this.current.lineWidth) {
1398       this._cachedScaleForStroking[0] = -1;
1399     }
1400     this.current.lineWidth = width;
1401     this.ctx.lineWidth = width;
1402   }
1403 
1404   setLineCap(style) {
1405     this.ctx.lineCap = LINE_CAP_STYLES[style];
1406   }
1407 
1408   setLineJoin(style) {
1409     this.ctx.lineJoin = LINE_JOIN_STYLES[style];
1410   }
1411 
1412   setMiterLimit(limit) {
1413     this.ctx.miterLimit = limit;
1414   }
1415 
1416   setDash(dashArray, dashPhase) {
1417     const ctx = this.ctx;
1418     if (ctx.setLineDash !== undefined) {
1419       ctx.setLineDash(dashArray);
1420       ctx.lineDashOffset = dashPhase;
1421     }
1422   }
1423 
1424   setRenderingIntent(intent) {
1425     // This operation is ignored since we haven't found a use case for it yet.
1426   }
1427 
1428   setFlatness(flatness) {
1429     // This operation is ignored since we haven't found a use case for it yet.
1430   }
1431 
1432   setGState(states) {
1433     for (const [key, value] of states) {
1434       switch (key) {
1435         case "LW":
1436           this.setLineWidth(value);
1437           break;
1438         case "LC":
1439           this.setLineCap(value);
1440           break;
1441         case "LJ":
1442           this.setLineJoin(value);
1443           break;
1444         case "ML":
1445           this.setMiterLimit(value);
1446           break;
1447         case "D":
1448           this.setDash(value[0], value[1]);
1449           break;
1450         case "RI":
1451           this.setRenderingIntent(value);
1452           break;
1453         case "FL":
1454           this.setFlatness(value);
1455           break;
1456         case "Font":
1457           this.setFont(value[0], value[1]);
1458           break;
1459         case "CA":
1460           this.current.strokeAlpha = value;
1461           break;
1462         case "ca":
1463           this.current.fillAlpha = value;
1464           this.ctx.globalAlpha = value;
1465           break;
1466         case "BM":
1467           this.ctx.globalCompositeOperation = value;
1468           break;
1469         case "SMask":
1470           this.current.activeSMask = value ? this.tempSMask : null;
1471           this.tempSMask = null;
1472           this.checkSMaskState();
1473           break;
1474         case "TR":
1475           this.ctx.filter = this.current.transferMaps =
1476             this.filterFactory.addFilter(value);
1477           break;
1478       }
1479     }
1480   }
1481 
1482   get inSMaskMode() {
1483     return !!this.suspendedCtx;
1484   }
1485 
1486   checkSMaskState() {
1487     const inSMaskMode = this.inSMaskMode;
1488     if (this.current.activeSMask && !inSMaskMode) {
1489       this.beginSMaskMode();
1490     } else if (!this.current.activeSMask && inSMaskMode) {
1491       this.endSMaskMode();
1492     }
1493     // Else, the state is okay and nothing needs to be done.
1494   }
1495 
1496   /**
1497    * Soft mask mode takes the current main drawing canvas and replaces it with
1498    * a temporary canvas. Any drawing operations that happen on the temporary
1499    * canvas need to be composed with the main canvas that was suspended (see
1500    * `compose()`). The temporary canvas also duplicates many of its operations
1501    * on the suspended canvas to keep them in sync, so that when the soft mask
1502    * mode ends any clipping paths or transformations will still be active and in
1503    * the right order on the canvas' graphics state stack.
1504    */
1505   beginSMaskMode() {
1506     if (this.inSMaskMode) {
1507       throw new Error("beginSMaskMode called while already in smask mode");
1508     }
1509     const drawnWidth = this.ctx.canvas.width;
1510     const drawnHeight = this.ctx.canvas.height;
1511     const cacheId = "smaskGroupAt" + this.groupLevel;
1512     const scratchCanvas = this.cachedCanvases.getCanvas(
1513       cacheId,
1514       drawnWidth,
1515       drawnHeight
1516     );
1517     this.suspendedCtx = this.ctx;
1518     this.ctx = scratchCanvas.context;
1519     const ctx = this.ctx;
1520     ctx.setTransform(...getCurrentTransform(this.suspendedCtx));
1521     copyCtxState(this.suspendedCtx, ctx);
1522     mirrorContextOperations(ctx, this.suspendedCtx);
1523 
1524     this.setGState([
1525       ["BM", "source-over"],
1526       ["ca", 1],
1527       ["CA", 1],
1528     ]);
1529   }
1530 
1531   endSMaskMode() {
1532     if (!this.inSMaskMode) {
1533       throw new Error("endSMaskMode called while not in smask mode");
1534     }
1535     // The soft mask is done, now restore the suspended canvas as the main
1536     // drawing canvas.
1537     this.ctx._removeMirroring();
1538     copyCtxState(this.ctx, this.suspendedCtx);
1539     this.ctx = this.suspendedCtx;
1540 
1541     this.suspendedCtx = null;
1542   }
1543 
1544   compose(dirtyBox) {
1545     if (!this.current.activeSMask) {
1546       return;
1547     }
1548 
1549     if (!dirtyBox) {
1550       dirtyBox = [0, 0, this.ctx.canvas.width, this.ctx.canvas.height];
1551     } else {
1552       dirtyBox[0] = Math.floor(dirtyBox[0]);
1553       dirtyBox[1] = Math.floor(dirtyBox[1]);
1554       dirtyBox[2] = Math.ceil(dirtyBox[2]);
1555       dirtyBox[3] = Math.ceil(dirtyBox[3]);
1556     }
1557     const smask = this.current.activeSMask;
1558     const suspendedCtx = this.suspendedCtx;
1559 
1560     composeSMask(suspendedCtx, smask, this.ctx, dirtyBox);
1561     // Whatever was drawn has been moved to the suspended canvas, now clear it
1562     // out of the current canvas.
1563     this.ctx.save();
1564     this.ctx.setTransform(1, 0, 0, 1, 0, 0);
1565     this.ctx.clearRect(0, 0, this.ctx.canvas.width, this.ctx.canvas.height);
1566     this.ctx.restore();
1567   }
1568 
1569   save() {
1570     if (this.inSMaskMode) {
1571       // SMask mode may be turned on/off causing us to lose graphics state.
1572       // Copy the temporary canvas state to the main(suspended) canvas to keep
1573       // it in sync.
1574       copyCtxState(this.ctx, this.suspendedCtx);
1575       // Don't bother calling save on the temporary canvas since state is not
1576       // saved there.
1577       this.suspendedCtx.save();
1578     } else {
1579       this.ctx.save();
1580     }
1581     const old = this.current;
1582     this.stateStack.push(old);
1583     this.current = old.clone();
1584   }
1585 
1586   restore() {
1587     if (this.stateStack.length === 0 && this.inSMaskMode) {
1588       this.endSMaskMode();
1589     }
1590     if (this.stateStack.length !== 0) {
1591       this.current = this.stateStack.pop();
1592       if (this.inSMaskMode) {
1593         // Graphics state is stored on the main(suspended) canvas. Restore its
1594         // state then copy it over to the temporary canvas.
1595         this.suspendedCtx.restore();
1596         copyCtxState(this.suspendedCtx, this.ctx);
1597       } else {
1598         this.ctx.restore();
1599       }
1600       this.checkSMaskState();
1601 
1602       // Ensure that the clipping path is reset (fixes issue6413.pdf).
1603       this.pendingClip = null;
1604 
1605       this._cachedScaleForStroking[0] = -1;
1606       this._cachedGetSinglePixelWidth = null;
1607     }
1608   }
1609 
1610   transform(a, b, c, d, e, f) {
1611     this.ctx.transform(a, b, c, d, e, f);
1612 
1613     this._cachedScaleForStroking[0] = -1;
1614     this._cachedGetSinglePixelWidth = null;
1615   }
1616 
1617   // Path
1618   constructPath(ops, args, minMax) {
1619     const ctx = this.ctx;
1620     const current = this.current;
1621     let x = current.x,
1622       y = current.y;
1623     let startX, startY;
1624     const currentTransform = getCurrentTransform(ctx);
1625 
1626     // Most of the time the current transform is a scaling matrix
1627     // so we don't need to transform points before computing min/max:
1628     // we can compute min/max first and then smartly "apply" the
1629     // transform (see Util.scaleMinMax).
1630     // For rectangle, moveTo and lineTo, min/max are computed in the
1631     // worker (see evaluator.js).
1632     const isScalingMatrix =
1633       (currentTransform[0] === 0 && currentTransform[3] === 0) ||
1634       (currentTransform[1] === 0 && currentTransform[2] === 0);
1635     const minMaxForBezier = isScalingMatrix ? minMax.slice(0) : null;
1636 
1637     for (let i = 0, j = 0, ii = ops.length; i < ii; i++) {
1638       switch (ops[i] | 0) {
1639         case OPS.rectangle:
1640           x = args[j++];
1641           y = args[j++];
1642           const width = args[j++];
1643           const height = args[j++];
1644 
1645           const xw = x + width;
1646           const yh = y + height;
1647           ctx.moveTo(x, y);
1648           if (width === 0 || height === 0) {
1649             ctx.lineTo(xw, yh);
1650           } else {
1651             ctx.lineTo(xw, y);
1652             ctx.lineTo(xw, yh);
1653             ctx.lineTo(x, yh);
1654           }
1655           if (!isScalingMatrix) {
1656             current.updateRectMinMax(currentTransform, [x, y, xw, yh]);
1657           }
1658           ctx.closePath();
1659           break;
1660         case OPS.moveTo:
1661           x = args[j++];
1662           y = args[j++];
1663           ctx.moveTo(x, y);
1664           if (!isScalingMatrix) {
1665             current.updatePathMinMax(currentTransform, x, y);
1666           }
1667           break;
1668         case OPS.lineTo:
1669           x = args[j++];
1670           y = args[j++];
1671           ctx.lineTo(x, y);
1672           if (!isScalingMatrix) {
1673             current.updatePathMinMax(currentTransform, x, y);
1674           }
1675           break;
1676         case OPS.curveTo:
1677           startX = x;
1678           startY = y;
1679           x = args[j + 4];
1680           y = args[j + 5];
1681           ctx.bezierCurveTo(
1682             args[j],
1683             args[j + 1],
1684             args[j + 2],
1685             args[j + 3],
1686             x,
1687             y
1688           );
1689           current.updateCurvePathMinMax(
1690             currentTransform,
1691             startX,
1692             startY,
1693             args[j],
1694             args[j + 1],
1695             args[j + 2],
1696             args[j + 3],
1697             x,
1698             y,
1699             minMaxForBezier
1700           );
1701           j += 6;
1702           break;
1703         case OPS.curveTo2:
1704           startX = x;
1705           startY = y;
1706           ctx.bezierCurveTo(
1707             x,
1708             y,
1709             args[j],
1710             args[j + 1],
1711             args[j + 2],
1712             args[j + 3]
1713           );
1714           current.updateCurvePathMinMax(
1715             currentTransform,
1716             startX,
1717             startY,
1718             x,
1719             y,
1720             args[j],
1721             args[j + 1],
1722             args[j + 2],
1723             args[j + 3],
1724             minMaxForBezier
1725           );
1726           x = args[j + 2];
1727           y = args[j + 3];
1728           j += 4;
1729           break;
1730         case OPS.curveTo3:
1731           startX = x;
1732           startY = y;
1733           x = args[j + 2];
1734           y = args[j + 3];
1735           ctx.bezierCurveTo(args[j], args[j + 1], x, y, x, y);
1736           current.updateCurvePathMinMax(
1737             currentTransform,
1738             startX,
1739             startY,
1740             args[j],
1741             args[j + 1],
1742             x,
1743             y,
1744             x,
1745             y,
1746             minMaxForBezier
1747           );
1748           j += 4;
1749           break;
1750         case OPS.closePath:
1751           ctx.closePath();
1752           break;
1753       }
1754     }
1755 
1756     if (isScalingMatrix) {
1757       current.updateScalingPathMinMax(currentTransform, minMaxForBezier);
1758     }
1759 
1760     current.setCurrentPoint(x, y);
1761   }
1762 
1763   closePath() {
1764     this.ctx.closePath();
1765   }
1766 
1767   stroke(consumePath = true) {
1768     const ctx = this.ctx;
1769     const strokeColor = this.current.strokeColor;
1770     // For stroke we want to temporarily change the global alpha to the
1771     // stroking alpha.
1772     ctx.globalAlpha = this.current.strokeAlpha;
1773     if (this.contentVisible) {
1774       if (typeof strokeColor === "object" && strokeColor?.getPattern) {
1775         ctx.save();
1776         ctx.strokeStyle = strokeColor.getPattern(
1777           ctx,
1778           this,
1779           getCurrentTransformInverse(ctx),
1780           PathType.STROKE
1781         );
1782         this.rescaleAndStroke(/* saveRestore */ false);
1783         ctx.restore();
1784       } else {
1785         this.rescaleAndStroke(/* saveRestore */ true);
1786       }
1787     }
1788     if (consumePath) {
1789       this.consumePath(this.current.getClippedPathBoundingBox());
1790     }
1791     // Restore the global alpha to the fill alpha
1792     ctx.globalAlpha = this.current.fillAlpha;
1793   }
1794 
1795   closeStroke() {
1796     this.closePath();
1797     this.stroke();
1798   }
1799 
1800   fill(consumePath = true) {
1801     const ctx = this.ctx;
1802     const fillColor = this.current.fillColor;
1803     const isPatternFill = this.current.patternFill;
1804     let needRestore = false;
1805 
1806     if (isPatternFill) {
1807       ctx.save();
1808       ctx.fillStyle = fillColor.getPattern(
1809         ctx,
1810         this,
1811         getCurrentTransformInverse(ctx),
1812         PathType.FILL
1813       );
1814       needRestore = true;
1815     }
1816 
1817     const intersect = this.current.getClippedPathBoundingBox();
1818     if (this.contentVisible && intersect !== null) {
1819       if (this.pendingEOFill) {
1820         ctx.fill("evenodd");
1821         this.pendingEOFill = false;
1822       } else {
1823         ctx.fill();
1824       }
1825     }
1826 
1827     if (needRestore) {
1828       ctx.restore();
1829     }
1830     if (consumePath) {
1831       this.consumePath(intersect);
1832     }
1833   }
1834 
1835   eoFill() {
1836     this.pendingEOFill = true;
1837     this.fill();
1838   }
1839 
1840   fillStroke() {
1841     this.fill(false);
1842     this.stroke(false);
1843 
1844     this.consumePath();
1845   }
1846 
1847   eoFillStroke() {
1848     this.pendingEOFill = true;
1849     this.fillStroke();
1850   }
1851 
1852   closeFillStroke() {
1853     this.closePath();
1854     this.fillStroke();
1855   }
1856 
1857   closeEOFillStroke() {
1858     this.pendingEOFill = true;
1859     this.closePath();
1860     this.fillStroke();
1861   }
1862 
1863   endPath() {
1864     this.consumePath();
1865   }
1866 
1867   // Clipping
1868   clip() {
1869     this.pendingClip = NORMAL_CLIP;
1870   }
1871 
1872   eoClip() {
1873     this.pendingClip = EO_CLIP;
1874   }
1875 
1876   // Text
1877   beginText() {
1878     this.current.textMatrix = IDENTITY_MATRIX;
1879     this.current.textMatrixScale = 1;
1880     this.current.x = this.current.lineX = 0;
1881     this.current.y = this.current.lineY = 0;
1882   }
1883 
1884   endText() {
1885     const paths = this.pendingTextPaths;
1886     const ctx = this.ctx;
1887     if (paths === undefined) {
1888       ctx.beginPath();
1889       return;
1890     }
1891 
1892     ctx.save();
1893     ctx.beginPath();
1894     for (const path of paths) {
1895       ctx.setTransform(...path.transform);
1896       ctx.translate(path.x, path.y);
1897       path.addToPath(ctx, path.fontSize);
1898     }
1899     ctx.restore();
1900     ctx.clip();
1901     ctx.beginPath();
1902     delete this.pendingTextPaths;
1903   }
1904 
1905   setCharSpacing(spacing) {
1906     this.current.charSpacing = spacing;
1907   }
1908 
1909   setWordSpacing(spacing) {
1910     this.current.wordSpacing = spacing;
1911   }
1912 
1913   setHScale(scale) {
1914     this.current.textHScale = scale / 100;
1915   }
1916 
1917   setLeading(leading) {
1918     this.current.leading = -leading;
1919   }
1920 
1921   setFont(fontRefName, size) {
1922     const fontObj = this.commonObjs.get(fontRefName);
1923     const current = this.current;
1924 
1925     if (!fontObj) {
1926       throw new Error(`Can't find font for ${fontRefName}`);
1927     }
1928     current.fontMatrix = fontObj.fontMatrix || FONT_IDENTITY_MATRIX;
1929 
1930     // A valid matrix needs all main diagonal elements to be non-zero
1931     // This also ensures we bypass FF bugzilla bug #719844.
1932     if (current.fontMatrix[0] === 0 || current.fontMatrix[3] === 0) {
1933       warn("Invalid font matrix for font " + fontRefName);
1934     }
1935 
1936     // The spec for Tf (setFont) says that 'size' specifies the font 'scale',
1937     // and in some docs this can be negative (inverted x-y axes).
1938     if (size < 0) {
1939       size = -size;
1940       current.fontDirection = -1;
1941     } else {
1942       current.fontDirection = 1;
1943     }
1944 
1945     this.current.font = fontObj;
1946     this.current.fontSize = size;
1947 
1948     if (fontObj.isType3Font) {
1949       return; // we don't need ctx.font for Type3 fonts
1950     }
1951 
1952     const name = fontObj.loadedName || "sans-serif";
1953     const typeface =
1954       fontObj.systemFontInfo?.css || `"${name}", ${fontObj.fallbackName}`;
1955 
1956     let bold = "normal";
1957     if (fontObj.black) {
1958       bold = "900";
1959     } else if (fontObj.bold) {
1960       bold = "bold";
1961     }
1962     const italic = fontObj.italic ? "italic" : "normal";
1963 
1964     // Some font backends cannot handle fonts below certain size.
1965     // Keeping the font at minimal size and using the fontSizeScale to change
1966     // the current transformation matrix before the fillText/strokeText.
1967     // See https://bugzilla.mozilla.org/show_bug.cgi?id=726227
1968     let browserFontSize = size;
1969     if (size < MIN_FONT_SIZE) {
1970       browserFontSize = MIN_FONT_SIZE;
1971     } else if (size > MAX_FONT_SIZE) {
1972       browserFontSize = MAX_FONT_SIZE;
1973     }
1974     this.current.fontSizeScale = size / browserFontSize;
1975 
1976     this.ctx.font = `${italic} ${bold} ${browserFontSize}px ${typeface}`;
1977   }
1978 
1979   setTextRenderingMode(mode) {
1980     this.current.textRenderingMode = mode;
1981   }
1982 
1983   setTextRise(rise) {
1984     this.current.textRise = rise;
1985   }
1986 
1987   moveText(x, y) {
1988     this.current.x = this.current.lineX += x;
1989     this.current.y = this.current.lineY += y;
1990   }
1991 
1992   setLeadingMoveText(x, y) {
1993     this.setLeading(-y);
1994     this.moveText(x, y);
1995   }
1996 
1997   setTextMatrix(a, b, c, d, e, f) {
1998     this.current.textMatrix = [a, b, c, d, e, f];
1999     this.current.textMatrixScale = Math.hypot(a, b);
2000 
2001     this.current.x = this.current.lineX = 0;
2002     this.current.y = this.current.lineY = 0;
2003   }
2004 
2005   nextLine() {
2006     this.moveText(0, this.current.leading);
2007   }
2008 
2009   paintChar(character, x, y, patternTransform) {
2010     const ctx = this.ctx;
2011     const current = this.current;
2012     const font = current.font;
2013     const textRenderingMode = current.textRenderingMode;
2014     const fontSize = current.fontSize / current.fontSizeScale;
2015     const fillStrokeMode =
2016       textRenderingMode & TextRenderingMode.FILL_STROKE_MASK;
2017     const isAddToPathSet = !!(
2018       textRenderingMode & TextRenderingMode.ADD_TO_PATH_FLAG
2019     );
2020     const patternFill = current.patternFill && !font.missingFile;
2021 
2022     let addToPath;
2023     if (font.disableFontFace || isAddToPathSet || patternFill) {
2024       addToPath = font.getPathGenerator(this.commonObjs, character);
2025     }
2026 
2027     if (font.disableFontFace || patternFill) {
2028       ctx.save();
2029       ctx.translate(x, y);
2030       ctx.beginPath();
2031       addToPath(ctx, fontSize);
2032       if (patternTransform) {
2033         ctx.setTransform(...patternTransform);
2034       }
2035       if (
2036         fillStrokeMode === TextRenderingMode.FILL ||
2037         fillStrokeMode === TextRenderingMode.FILL_STROKE
2038       ) {
2039         ctx.fill();
2040       }
2041       if (
2042         fillStrokeMode === TextRenderingMode.STROKE ||
2043         fillStrokeMode === TextRenderingMode.FILL_STROKE
2044       ) {
2045         ctx.stroke();
2046       }
2047       ctx.restore();
2048     } else {
2049       if (
2050         fillStrokeMode === TextRenderingMode.FILL ||
2051         fillStrokeMode === TextRenderingMode.FILL_STROKE
2052       ) {
2053         ctx.fillText(character, x, y);
2054       }
2055       if (
2056         fillStrokeMode === TextRenderingMode.STROKE ||
2057         fillStrokeMode === TextRenderingMode.FILL_STROKE
2058       ) {
2059         ctx.strokeText(character, x, y);
2060       }
2061     }
2062 
2063     if (isAddToPathSet) {
2064       const paths = (this.pendingTextPaths ||= []);
2065       paths.push({
2066         transform: getCurrentTransform(ctx),
2067         x,
2068         y,
2069         fontSize,
2070         addToPath,
2071       });
2072     }
2073   }
2074 
2075   get isFontSubpixelAAEnabled() {
2076     // Checks if anti-aliasing is enabled when scaled text is painted.
2077     // On Windows GDI scaled fonts looks bad.
2078     const { context: ctx } = this.cachedCanvases.getCanvas(
2079       "isFontSubpixelAAEnabled",
2080       10,
2081       10
2082     );
2083     ctx.scale(1.5, 1);
2084     ctx.fillText("I", 0, 10);
2085     const data = ctx.getImageData(0, 0, 10, 10).data;
2086     let enabled = false;
2087     for (let i = 3; i < data.length; i += 4) {
2088       if (data[i] > 0 && data[i] < 255) {
2089         enabled = true;
2090         break;
2091       }
2092     }
2093     return shadow(this, "isFontSubpixelAAEnabled", enabled);
2094   }
2095 
2096   showText(glyphs) {
2097     const current = this.current;
2098     const font = current.font;
2099     if (font.isType3Font) {
2100       return this.showType3Text(glyphs);
2101     }
2102 
2103     const fontSize = current.fontSize;
2104     if (fontSize === 0) {
2105       return undefined;
2106     }
2107 
2108     const ctx = this.ctx;
2109     const fontSizeScale = current.fontSizeScale;
2110     const charSpacing = current.charSpacing;
2111     const wordSpacing = current.wordSpacing;
2112     const fontDirection = current.fontDirection;
2113     const textHScale = current.textHScale * fontDirection;
2114     const glyphsLength = glyphs.length;
2115     const vertical = font.vertical;
2116     const spacingDir = vertical ? 1 : -1;
2117     const defaultVMetrics = font.defaultVMetrics;
2118     const widthAdvanceScale = fontSize * current.fontMatrix[0];
2119 
2120     const simpleFillText =
2121       current.textRenderingMode === TextRenderingMode.FILL &&
2122       !font.disableFontFace &&
2123       !current.patternFill;
2124 
2125     ctx.save();
2126     ctx.transform(...current.textMatrix);
2127     ctx.translate(current.x, current.y + current.textRise);
2128 
2129     if (fontDirection > 0) {
2130       ctx.scale(textHScale, -1);
2131     } else {
2132       ctx.scale(textHScale, 1);
2133     }
2134 
2135     let patternTransform;
2136     if (current.patternFill) {
2137       ctx.save();
2138       const pattern = current.fillColor.getPattern(
2139         ctx,
2140         this,
2141         getCurrentTransformInverse(ctx),
2142         PathType.FILL
2143       );
2144       patternTransform = getCurrentTransform(ctx);
2145       ctx.restore();
2146       ctx.fillStyle = pattern;
2147     }
2148 
2149     let lineWidth = current.lineWidth;
2150     const scale = current.textMatrixScale;
2151     if (scale === 0 || lineWidth === 0) {
2152       const fillStrokeMode =
2153         current.textRenderingMode & TextRenderingMode.FILL_STROKE_MASK;
2154       if (
2155         fillStrokeMode === TextRenderingMode.STROKE ||
2156         fillStrokeMode === TextRenderingMode.FILL_STROKE
2157       ) {
2158         lineWidth = this.getSinglePixelWidth();
2159       }
2160     } else {
2161       lineWidth /= scale;
2162     }
2163 
2164     if (fontSizeScale !== 1.0) {
2165       ctx.scale(fontSizeScale, fontSizeScale);
2166       lineWidth /= fontSizeScale;
2167     }
2168 
2169     ctx.lineWidth = lineWidth;
2170 
2171     if (font.isInvalidPDFjsFont) {
2172       const chars = [];
2173       let width = 0;
2174       for (const glyph of glyphs) {
2175         chars.push(glyph.unicode);
2176         width += glyph.width;
2177       }
2178       ctx.fillText(chars.join(""), 0, 0);
2179       current.x += width * widthAdvanceScale * textHScale;
2180       ctx.restore();
2181       this.compose();
2182 
2183       return undefined;
2184     }
2185 
2186     let x = 0,
2187       i;
2188     for (i = 0; i < glyphsLength; ++i) {
2189       const glyph = glyphs[i];
2190       if (typeof glyph === "number") {
2191         x += (spacingDir * glyph * fontSize) / 1000;
2192         continue;
2193       }
2194 
2195       let restoreNeeded = false;
2196       const spacing = (glyph.isSpace ? wordSpacing : 0) + charSpacing;
2197       const character = glyph.fontChar;
2198       const accent = glyph.accent;
2199       let scaledX, scaledY;
2200       let width = glyph.width;
2201       if (vertical) {
2202         const vmetric = glyph.vmetric || defaultVMetrics;
2203         const vx =
2204           -(glyph.vmetric ? vmetric[1] : width * 0.5) * widthAdvanceScale;
2205         const vy = vmetric[2] * widthAdvanceScale;
2206 
2207         width = vmetric ? -vmetric[0] : width;
2208         scaledX = vx / fontSizeScale;
2209         scaledY = (x + vy) / fontSizeScale;
2210       } else {
2211         scaledX = x / fontSizeScale;
2212         scaledY = 0;
2213       }
2214 
2215       if (font.remeasure && width > 0) {
2216         // Some standard fonts may not have the exact width: rescale per
2217         // character if measured width is greater than expected glyph width
2218         // and subpixel-aa is enabled, otherwise just center the glyph.
2219         const measuredWidth =
2220           ((ctx.measureText(character).width * 1000) / fontSize) *
2221           fontSizeScale;
2222         if (width < measuredWidth && this.isFontSubpixelAAEnabled) {
2223           const characterScaleX = width / measuredWidth;
2224           restoreNeeded = true;
2225           ctx.save();
2226           ctx.scale(characterScaleX, 1);
2227           scaledX /= characterScaleX;
2228         } else if (width !== measuredWidth) {
2229           scaledX +=
2230             (((width - measuredWidth) / 2000) * fontSize) / fontSizeScale;
2231         }
2232       }
2233 
2234       // Only attempt to draw the glyph if it is actually in the embedded font
2235       // file or if there isn't a font file so the fallback font is shown.
2236       if (this.contentVisible && (glyph.isInFont || font.missingFile)) {
2237         if (simpleFillText && !accent) {
2238           // common case
2239           ctx.fillText(character, scaledX, scaledY);
2240         } else {
2241           this.paintChar(character, scaledX, scaledY, patternTransform);
2242           if (accent) {
2243             const scaledAccentX =
2244               scaledX + (fontSize * accent.offset.x) / fontSizeScale;
2245             const scaledAccentY =
2246               scaledY - (fontSize * accent.offset.y) / fontSizeScale;
2247             this.paintChar(
2248               accent.fontChar,
2249               scaledAccentX,
2250               scaledAccentY,
2251               patternTransform
2252             );
2253           }
2254         }
2255       }
2256 
2257       let charWidth;
2258       if (vertical) {
2259         charWidth = width * widthAdvanceScale - spacing * fontDirection;
2260       } else {
2261         charWidth = width * widthAdvanceScale + spacing * fontDirection;
2262       }
2263       x += charWidth;
2264 
2265       if (restoreNeeded) {
2266         ctx.restore();
2267       }
2268     }
2269     if (vertical) {
2270       current.y -= x;
2271     } else {
2272       current.x += x * textHScale;
2273     }
2274     ctx.restore();
2275     this.compose();
2276 
2277     return undefined;
2278   }
2279 
2280   showType3Text(glyphs) {
2281     // Type3 fonts - each glyph is a "mini-PDF"
2282     const ctx = this.ctx;
2283     const current = this.current;
2284     const font = current.font;
2285     const fontSize = current.fontSize;
2286     const fontDirection = current.fontDirection;
2287     const spacingDir = font.vertical ? 1 : -1;
2288     const charSpacing = current.charSpacing;
2289     const wordSpacing = current.wordSpacing;
2290     const textHScale = current.textHScale * fontDirection;
2291     const fontMatrix = current.fontMatrix || FONT_IDENTITY_MATRIX;
2292     const glyphsLength = glyphs.length;
2293     const isTextInvisible =
2294       current.textRenderingMode === TextRenderingMode.INVISIBLE;
2295     let i, glyph, width, spacingLength;
2296 
2297     if (isTextInvisible || fontSize === 0) {
2298       return;
2299     }
2300     this._cachedScaleForStroking[0] = -1;
2301     this._cachedGetSinglePixelWidth = null;
2302 
2303     ctx.save();
2304     ctx.transform(...current.textMatrix);
2305     ctx.translate(current.x, current.y);
2306 
2307     ctx.scale(textHScale, fontDirection);
2308 
2309     for (i = 0; i < glyphsLength; ++i) {
2310       glyph = glyphs[i];
2311       if (typeof glyph === "number") {
2312         spacingLength = (spacingDir * glyph * fontSize) / 1000;
2313         this.ctx.translate(spacingLength, 0);
2314         current.x += spacingLength * textHScale;
2315         continue;
2316       }
2317 
2318       const spacing = (glyph.isSpace ? wordSpacing : 0) + charSpacing;
2319       const operatorList = font.charProcOperatorList[glyph.operatorListId];
2320       if (!operatorList) {
2321         warn(`Type3 character "${glyph.operatorListId}" is not available.`);
2322         continue;
2323       }
2324       if (this.contentVisible) {
2325         this.processingType3 = glyph;
2326         this.save();
2327         ctx.scale(fontSize, fontSize);
2328         ctx.transform(...fontMatrix);
2329         this.executeOperatorList(operatorList);
2330         this.restore();
2331       }
2332 
2333       const transformed = Util.applyTransform([glyph.width, 0], fontMatrix);
2334       width = transformed[0] * fontSize + spacing;
2335 
2336       ctx.translate(width, 0);
2337       current.x += width * textHScale;
2338     }
2339     ctx.restore();
2340     this.processingType3 = null;
2341   }
2342 
2343   // Type3 fonts
2344   setCharWidth(xWidth, yWidth) {
2345     // We can safely ignore this since the width should be the same
2346     // as the width in the Widths array.
2347   }
2348 
2349   setCharWidthAndBounds(xWidth, yWidth, llx, lly, urx, ury) {
2350     this.ctx.rect(llx, lly, urx - llx, ury - lly);
2351     this.ctx.clip();
2352     this.endPath();
2353   }
2354 
2355   // Color
2356   getColorN_Pattern(IR) {
2357     let pattern;
2358     if (IR[0] === "TilingPattern") {
2359       const color = IR[1];
2360       const baseTransform = this.baseTransform || getCurrentTransform(this.ctx);
2361       const canvasGraphicsFactory = {
2362         createCanvasGraphics: ctx => {
2363           return new CanvasGraphics(
2364             ctx,
2365             this.commonObjs,
2366             this.objs,
2367             this.canvasFactory,
2368             this.filterFactory,
2369             {
2370               optionalContentConfig: this.optionalContentConfig,
2371               markedContentStack: this.markedContentStack,
2372             }
2373           );
2374         },
2375       };
2376       pattern = new TilingPattern(
2377         IR,
2378         color,
2379         this.ctx,
2380         canvasGraphicsFactory,
2381         baseTransform
2382       );
2383     } else {
2384       pattern = this._getPattern(IR[1], IR[2]);
2385     }
2386     return pattern;
2387   }
2388 
2389   setStrokeColorN() {
2390     this.current.strokeColor = this.getColorN_Pattern(arguments);
2391   }
2392 
2393   setFillColorN() {
2394     this.current.fillColor = this.getColorN_Pattern(arguments);
2395     this.current.patternFill = true;
2396   }
2397 
2398   setStrokeRGBColor(r, g, b) {
2399     const color = Util.makeHexColor(r, g, b);
2400     this.ctx.strokeStyle = color;
2401     this.current.strokeColor = color;
2402   }
2403 
2404   setFillRGBColor(r, g, b) {
2405     const color = Util.makeHexColor(r, g, b);
2406     this.ctx.fillStyle = color;
2407     this.current.fillColor = color;
2408     this.current.patternFill = false;
2409   }
2410 
2411   _getPattern(objId, matrix = null) {
2412     let pattern;
2413     if (this.cachedPatterns.has(objId)) {
2414       pattern = this.cachedPatterns.get(objId);
2415     } else {
2416       pattern = getShadingPattern(this.getObject(objId));
2417       this.cachedPatterns.set(objId, pattern);
2418     }
2419     if (matrix) {
2420       pattern.matrix = matrix;
2421     }
2422     return pattern;
2423   }
2424 
2425   shadingFill(objId) {
2426     if (!this.contentVisible) {
2427       return;
2428     }
2429     const ctx = this.ctx;
2430 
2431     this.save();
2432     const pattern = this._getPattern(objId);
2433     ctx.fillStyle = pattern.getPattern(
2434       ctx,
2435       this,
2436       getCurrentTransformInverse(ctx),
2437       PathType.SHADING
2438     );
2439 
2440     const inv = getCurrentTransformInverse(ctx);
2441     if (inv) {
2442       const { width, height } = ctx.canvas;
2443       const [x0, y0, x1, y1] = Util.getAxialAlignedBoundingBox(
2444         [0, 0, width, height],
2445         inv
2446       );
2447 
2448       this.ctx.fillRect(x0, y0, x1 - x0, y1 - y0);
2449     } else {
2450       // HACK to draw the gradient onto an infinite rectangle.
2451       // PDF gradients are drawn across the entire image while
2452       // Canvas only allows gradients to be drawn in a rectangle
2453       // The following bug should allow us to remove this.
2454       // https://bugzilla.mozilla.org/show_bug.cgi?id=664884
2455 
2456       this.ctx.fillRect(-1e10, -1e10, 2e10, 2e10);
2457     }
2458 
2459     this.compose(this.current.getClippedPathBoundingBox());
2460     this.restore();
2461   }
2462 
2463   // Images
2464   beginInlineImage() {
2465     unreachable("Should not call beginInlineImage");
2466   }
2467 
2468   beginImageData() {
2469     unreachable("Should not call beginImageData");
2470   }
2471 
2472   paintFormXObjectBegin(matrix, bbox) {
2473     if (!this.contentVisible) {
2474       return;
2475     }
2476     this.save();
2477     this.baseTransformStack.push(this.baseTransform);
2478 
2479     if (Array.isArray(matrix) && matrix.length === 6) {
2480       this.transform(...matrix);
2481     }
2482 
2483     this.baseTransform = getCurrentTransform(this.ctx);
2484 
2485     if (bbox) {
2486       const width = bbox[2] - bbox[0];
2487       const height = bbox[3] - bbox[1];
2488       this.ctx.rect(bbox[0], bbox[1], width, height);
2489       this.current.updateRectMinMax(getCurrentTransform(this.ctx), bbox);
2490       this.clip();
2491       this.endPath();
2492     }
2493   }
2494 
2495   paintFormXObjectEnd() {
2496     if (!this.contentVisible) {
2497       return;
2498     }
2499     this.restore();
2500     this.baseTransform = this.baseTransformStack.pop();
2501   }
2502 
2503   beginGroup(group) {
2504     if (!this.contentVisible) {
2505       return;
2506     }
2507 
2508     this.save();
2509     // If there's an active soft mask we don't want it enabled for the group, so
2510     // clear it out. The mask and suspended canvas will be restored in endGroup.
2511     if (this.inSMaskMode) {
2512       this.endSMaskMode();
2513       this.current.activeSMask = null;
2514     }
2515 
2516     const currentCtx = this.ctx;
2517     // TODO non-isolated groups - according to Rik at adobe non-isolated
2518     // group results aren't usually that different and they even have tools
2519     // that ignore this setting. Notes from Rik on implementing:
2520     // - When you encounter an transparency group, create a new canvas with
2521     // the dimensions of the bbox
2522     // - copy the content from the previous canvas to the new canvas
2523     // - draw as usual
2524     // - remove the backdrop alpha:
2525     // alphaNew = 1 - (1 - alpha)/(1 - alphaBackdrop) with 'alpha' the alpha
2526     // value of your transparency group and 'alphaBackdrop' the alpha of the
2527     // backdrop
2528     // - remove background color:
2529     // colorNew = color - alphaNew *colorBackdrop /(1 - alphaNew)
2530     if (!group.isolated) {
2531       info("TODO: Support non-isolated groups.");
2532     }
2533 
2534     // TODO knockout - supposedly possible with the clever use of compositing
2535     // modes.
2536     if (group.knockout) {
2537       warn("Knockout groups not supported.");
2538     }
2539 
2540     const currentTransform = getCurrentTransform(currentCtx);
2541     if (group.matrix) {
2542       currentCtx.transform(...group.matrix);
2543     }
2544     if (!group.bbox) {
2545       throw new Error("Bounding box is required.");
2546     }
2547 
2548     // Based on the current transform figure out how big the bounding box
2549     // will actually be.
2550     let bounds = Util.getAxialAlignedBoundingBox(
2551       group.bbox,
2552       getCurrentTransform(currentCtx)
2553     );
2554     // Clip the bounding box to the current canvas.
2555     const canvasBounds = [
2556       0,
2557       0,
2558       currentCtx.canvas.width,
2559       currentCtx.canvas.height,
2560     ];
2561     bounds = Util.intersect(bounds, canvasBounds) || [0, 0, 0, 0];
2562     // Use ceil in case we're between sizes so we don't create canvas that is
2563     // too small and make the canvas at least 1x1 pixels.
2564     const offsetX = Math.floor(bounds[0]);
2565     const offsetY = Math.floor(bounds[1]);
2566     let drawnWidth = Math.max(Math.ceil(bounds[2]) - offsetX, 1);
2567     let drawnHeight = Math.max(Math.ceil(bounds[3]) - offsetY, 1);
2568     let scaleX = 1,
2569       scaleY = 1;
2570     if (drawnWidth > MAX_GROUP_SIZE) {
2571       scaleX = drawnWidth / MAX_GROUP_SIZE;
2572       drawnWidth = MAX_GROUP_SIZE;
2573     }
2574     if (drawnHeight > MAX_GROUP_SIZE) {
2575       scaleY = drawnHeight / MAX_GROUP_SIZE;
2576       drawnHeight = MAX_GROUP_SIZE;
2577     }
2578 
2579     this.current.startNewPathAndClipBox([0, 0, drawnWidth, drawnHeight]);
2580 
2581     let cacheId = "groupAt" + this.groupLevel;
2582     if (group.smask) {
2583       // Using two cache entries is case if masks are used one after another.
2584       cacheId += "_smask_" + (this.smaskCounter++ % 2);
2585     }
2586     const scratchCanvas = this.cachedCanvases.getCanvas(
2587       cacheId,
2588       drawnWidth,
2589       drawnHeight
2590     );
2591     const groupCtx = scratchCanvas.context;
2592 
2593     // Since we created a new canvas that is just the size of the bounding box
2594     // we have to translate the group ctx.
2595     groupCtx.scale(1 / scaleX, 1 / scaleY);
2596     groupCtx.translate(-offsetX, -offsetY);
2597     groupCtx.transform(...currentTransform);
2598 
2599     if (group.smask) {
2600       // Saving state and cached mask to be used in setGState.
2601       this.smaskStack.push({
2602         canvas: scratchCanvas.canvas,
2603         context: groupCtx,
2604         offsetX,
2605         offsetY,
2606         scaleX,
2607         scaleY,
2608         subtype: group.smask.subtype,
2609         backdrop: group.smask.backdrop,
2610         transferMap: group.smask.transferMap || null,
2611         startTransformInverse: null, // used during suspend operation
2612       });
2613     } else {
2614       // Setup the current ctx so when the group is popped we draw it at the
2615       // right location.
2616       currentCtx.setTransform(1, 0, 0, 1, 0, 0);
2617       currentCtx.translate(offsetX, offsetY);
2618       currentCtx.scale(scaleX, scaleY);
2619       currentCtx.save();
2620     }
2621     // The transparency group inherits all off the current graphics state
2622     // except the blend mode, soft mask, and alpha constants.
2623     copyCtxState(currentCtx, groupCtx);
2624     this.ctx = groupCtx;
2625     this.setGState([
2626       ["BM", "source-over"],
2627       ["ca", 1],
2628       ["CA", 1],
2629     ]);
2630     this.groupStack.push(currentCtx);
2631     this.groupLevel++;
2632   }
2633 
2634   endGroup(group) {
2635     if (!this.contentVisible) {
2636       return;
2637     }
2638     this.groupLevel--;
2639     const groupCtx = this.ctx;
2640     const ctx = this.groupStack.pop();
2641     this.ctx = ctx;
2642     // Turn off image smoothing to avoid sub pixel interpolation which can
2643     // look kind of blurry for some pdfs.
2644     this.ctx.imageSmoothingEnabled = false;
2645 
2646     if (group.smask) {
2647       this.tempSMask = this.smaskStack.pop();
2648       this.restore();
2649     } else {
2650       this.ctx.restore();
2651       const currentMtx = getCurrentTransform(this.ctx);
2652       this.restore();
2653       this.ctx.save();
2654       this.ctx.setTransform(...currentMtx);
2655       const dirtyBox = Util.getAxialAlignedBoundingBox(
2656         [0, 0, groupCtx.canvas.width, groupCtx.canvas.height],
2657         currentMtx
2658       );
2659       this.ctx.drawImage(groupCtx.canvas, 0, 0);
2660       this.ctx.restore();
2661       this.compose(dirtyBox);
2662     }
2663   }
2664 
2665   beginAnnotation(id, rect, transform, matrix, hasOwnCanvas) {
2666     // The annotations are drawn just after the page content.
2667     // The page content drawing can potentially have set a transform,
2668     // a clipping path, whatever...
2669     // So in order to have something clean, we restore the initial state.
2670     this.#restoreInitialState();
2671     resetCtxToDefault(this.ctx);
2672 
2673     this.ctx.save();
2674     this.save();
2675 
2676     if (this.baseTransform) {
2677       this.ctx.setTransform(...this.baseTransform);
2678     }
2679 
2680     if (Array.isArray(rect) && rect.length === 4) {
2681       const width = rect[2] - rect[0];
2682       const height = rect[3] - rect[1];
2683 
2684       if (hasOwnCanvas && this.annotationCanvasMap) {
2685         transform = transform.slice();
2686         transform[4] -= rect[0];
2687         transform[5] -= rect[1];
2688 
2689         rect = rect.slice();
2690         rect[0] = rect[1] = 0;
2691         rect[2] = width;
2692         rect[3] = height;
2693 
2694         const [scaleX, scaleY] = Util.singularValueDecompose2dScale(
2695           getCurrentTransform(this.ctx)
2696         );
2697         const { viewportScale } = this;
2698         const canvasWidth = Math.ceil(
2699           width * this.outputScaleX * viewportScale
2700         );
2701         const canvasHeight = Math.ceil(
2702           height * this.outputScaleY * viewportScale
2703         );
2704 
2705         this.annotationCanvas = this.canvasFactory.create(
2706           canvasWidth,
2707           canvasHeight
2708         );
2709         const { canvas, context } = this.annotationCanvas;
2710         this.annotationCanvasMap.set(id, canvas);
2711         this.annotationCanvas.savedCtx = this.ctx;
2712         this.ctx = context;
2713         this.ctx.save();
2714         this.ctx.setTransform(scaleX, 0, 0, -scaleY, 0, height * scaleY);
2715 
2716         resetCtxToDefault(this.ctx);
2717       } else {
2718         resetCtxToDefault(this.ctx);
2719 
2720         this.ctx.rect(rect[0], rect[1], width, height);
2721         this.ctx.clip();
2722         this.endPath();
2723       }
2724     }
2725 
2726     this.current = new CanvasExtraState(
2727       this.ctx.canvas.width,
2728       this.ctx.canvas.height
2729     );
2730 
2731     this.transform(...transform);
2732     this.transform(...matrix);
2733   }
2734 
2735   endAnnotation() {
2736     if (this.annotationCanvas) {
2737       this.ctx.restore();
2738       this.#drawFilter();
2739 
2740       this.ctx = this.annotationCanvas.savedCtx;
2741       delete this.annotationCanvas.savedCtx;
2742       delete this.annotationCanvas;
2743     }
2744   }
2745 
2746   paintImageMaskXObject(img) {
2747     if (!this.contentVisible) {
2748       return;
2749     }
2750     const count = img.count;
2751     img = this.getObject(img.data, img);
2752     img.count = count;
2753 
2754     const ctx = this.ctx;
2755     const glyph = this.processingType3;
2756 
2757     if (glyph) {
2758       if (glyph.compiled === undefined) {
2759         glyph.compiled = compileType3Glyph(img);
2760       }
2761 
2762       if (glyph.compiled) {
2763         glyph.compiled(ctx);
2764         return;
2765       }
2766     }
2767     const mask = this._createMaskCanvas(img);
2768     const maskCanvas = mask.canvas;
2769 
2770     ctx.save();
2771     // The mask is drawn with the transform applied. Reset the current
2772     // transform to draw to the identity.
2773     ctx.setTransform(1, 0, 0, 1, 0, 0);
2774     ctx.drawImage(maskCanvas, mask.offsetX, mask.offsetY);
2775     ctx.restore();
2776     this.compose();
2777   }
2778 
2779   paintImageMaskXObjectRepeat(
2780     img,
2781     scaleX,
2782     skewX = 0,
2783     skewY = 0,
2784     scaleY,
2785     positions
2786   ) {
2787     if (!this.contentVisible) {
2788       return;
2789     }
2790 
2791     img = this.getObject(img.data, img);
2792 
2793     const ctx = this.ctx;
2794     ctx.save();
2795     const currentTransform = getCurrentTransform(ctx);
2796     ctx.transform(scaleX, skewX, skewY, scaleY, 0, 0);
2797     const mask = this._createMaskCanvas(img);
2798 
2799     ctx.setTransform(
2800       1,
2801       0,
2802       0,
2803       1,
2804       mask.offsetX - currentTransform[4],
2805       mask.offsetY - currentTransform[5]
2806     );
2807     for (let i = 0, ii = positions.length; i < ii; i += 2) {
2808       const trans = Util.transform(currentTransform, [
2809         scaleX,
2810         skewX,
2811         skewY,
2812         scaleY,
2813         positions[i],
2814         positions[i + 1],
2815       ]);
2816 
2817       const [x, y] = Util.applyTransform([0, 0], trans);
2818       ctx.drawImage(mask.canvas, x, y);
2819     }
2820     ctx.restore();
2821     this.compose();
2822   }
2823 
2824   paintImageMaskXObjectGroup(images) {
2825     if (!this.contentVisible) {
2826       return;
2827     }
2828     const ctx = this.ctx;
2829 
2830     const fillColor = this.current.fillColor;
2831     const isPatternFill = this.current.patternFill;
2832 
2833     for (const image of images) {
2834       const { data, width, height, transform } = image;
2835 
2836       const maskCanvas = this.cachedCanvases.getCanvas(
2837         "maskCanvas",
2838         width,
2839         height
2840       );
2841       const maskCtx = maskCanvas.context;
2842       maskCtx.save();
2843 
2844       const img = this.getObject(data, image);
2845       putBinaryImageMask(maskCtx, img);
2846 
2847       maskCtx.globalCompositeOperation = "source-in";
2848 
2849       maskCtx.fillStyle = isPatternFill
2850         ? fillColor.getPattern(
2851             maskCtx,
2852             this,
2853             getCurrentTransformInverse(ctx),
2854             PathType.FILL
2855           )
2856         : fillColor;
2857       maskCtx.fillRect(0, 0, width, height);
2858 
2859       maskCtx.restore();
2860 
2861       ctx.save();
2862       ctx.transform(...transform);
2863       ctx.scale(1, -1);
2864       drawImageAtIntegerCoords(
2865         ctx,
2866         maskCanvas.canvas,
2867         0,
2868         0,
2869         width,
2870         height,
2871         0,
2872         -1,
2873         1,
2874         1
2875       );
2876       ctx.restore();
2877     }
2878     this.compose();
2879   }
2880 
2881   paintImageXObject(objId) {
2882     if (!this.contentVisible) {
2883       return;
2884     }
2885     const imgData = this.getObject(objId);
2886     if (!imgData) {
2887       warn("Dependent image isn't ready yet");
2888       return;
2889     }
2890 
2891     this.paintInlineImageXObject(imgData);
2892   }
2893 
2894   paintImageXObjectRepeat(objId, scaleX, scaleY, positions) {
2895     if (!this.contentVisible) {
2896       return;
2897     }
2898     const imgData = this.getObject(objId);
2899     if (!imgData) {
2900       warn("Dependent image isn't ready yet");
2901       return;
2902     }
2903 
2904     const width = imgData.width;
2905     const height = imgData.height;
2906     const map = [];
2907     for (let i = 0, ii = positions.length; i < ii; i += 2) {
2908       map.push({
2909         transform: [scaleX, 0, 0, scaleY, positions[i], positions[i + 1]],
2910         x: 0,
2911         y: 0,
2912         w: width,
2913         h: height,
2914       });
2915     }
2916     this.paintInlineImageXObjectGroup(imgData, map);
2917   }
2918 
2919   applyTransferMapsToCanvas(ctx) {
2920     if (this.current.transferMaps !== "none") {
2921       ctx.filter = this.current.transferMaps;
2922       ctx.drawImage(ctx.canvas, 0, 0);
2923       ctx.filter = "none";
2924     }
2925     return ctx.canvas;
2926   }
2927 
2928   applyTransferMapsToBitmap(imgData) {
2929     if (this.current.transferMaps === "none") {
2930       return imgData.bitmap;
2931     }
2932     const { bitmap, width, height } = imgData;
2933     const tmpCanvas = this.cachedCanvases.getCanvas(
2934       "inlineImage",
2935       width,
2936       height
2937     );
2938     const tmpCtx = tmpCanvas.context;
2939     tmpCtx.filter = this.current.transferMaps;
2940     tmpCtx.drawImage(bitmap, 0, 0);
2941     tmpCtx.filter = "none";
2942 
2943     return tmpCanvas.canvas;
2944   }
2945 
2946   paintInlineImageXObject(imgData) {
2947     if (!this.contentVisible) {
2948       return;
2949     }
2950     const width = imgData.width;
2951     const height = imgData.height;
2952     const ctx = this.ctx;
2953 
2954     this.save();
2955 
2956     if (
2957       (typeof PDFJSDev !== "undefined" && PDFJSDev.test("MOZCENTRAL")) ||
2958       !isNodeJS
2959     ) {
2960       // The filter, if any, will be applied in applyTransferMapsToBitmap.
2961       // It must be applied to the image before rescaling else some artifacts
2962       // could appear.
2963       // The final restore will reset it to its value.
2964       ctx.filter = "none";
2965     }
2966 
2967     // scale the image to the unit square
2968     ctx.scale(1 / width, -1 / height);
2969 
2970     let imgToPaint;
2971     if (imgData.bitmap) {
2972       imgToPaint = this.applyTransferMapsToBitmap(imgData);
2973     } else if (
2974       (typeof HTMLElement === "function" && imgData instanceof HTMLElement) ||
2975       !imgData.data
2976     ) {
2977       // typeof check is needed due to node.js support, see issue #8489
2978       imgToPaint = imgData;
2979     } else {
2980       const tmpCanvas = this.cachedCanvases.getCanvas(
2981         "inlineImage",
2982         width,
2983         height
2984       );
2985       const tmpCtx = tmpCanvas.context;
2986       putBinaryImageData(tmpCtx, imgData);
2987       imgToPaint = this.applyTransferMapsToCanvas(tmpCtx);
2988     }
2989 
2990     const scaled = this._scaleImage(
2991       imgToPaint,
2992       getCurrentTransformInverse(ctx)
2993     );
2994     ctx.imageSmoothingEnabled = getImageSmoothingEnabled(
2995       getCurrentTransform(ctx),
2996       imgData.interpolate
2997     );
2998 
2999     drawImageAtIntegerCoords(
3000       ctx,
3001       scaled.img,
3002       0,
3003       0,
3004       scaled.paintWidth,
3005       scaled.paintHeight,
3006       0,
3007       -height,
3008       width,
3009       height
3010     );
3011     this.compose();
3012     this.restore();
3013   }
3014 
3015   paintInlineImageXObjectGroup(imgData, map) {
3016     if (!this.contentVisible) {
3017       return;
3018     }
3019     const ctx = this.ctx;
3020     let imgToPaint;
3021     if (imgData.bitmap) {
3022       imgToPaint = imgData.bitmap;
3023     } else {
3024       const w = imgData.width;
3025       const h = imgData.height;
3026 
3027       const tmpCanvas = this.cachedCanvases.getCanvas("inlineImage", w, h);
3028       const tmpCtx = tmpCanvas.context;
3029       putBinaryImageData(tmpCtx, imgData);
3030       imgToPaint = this.applyTransferMapsToCanvas(tmpCtx);
3031     }
3032 
3033     for (const entry of map) {
3034       ctx.save();
3035       ctx.transform(...entry.transform);
3036       ctx.scale(1, -1);
3037       drawImageAtIntegerCoords(
3038         ctx,
3039         imgToPaint,
3040         entry.x,
3041         entry.y,
3042         entry.w,
3043         entry.h,
3044         0,
3045         -1,
3046         1,
3047         1
3048       );
3049       ctx.restore();
3050     }
3051     this.compose();
3052   }
3053 
3054   paintSolidColorImageMask() {
3055     if (!this.contentVisible) {
3056       return;
3057     }
3058     this.ctx.fillRect(0, 0, 1, 1);
3059     this.compose();
3060   }
3061 
3062   // Marked content
3063 
3064   markPoint(tag) {
3065     // TODO Marked content.
3066   }
3067 
3068   markPointProps(tag, properties) {
3069     // TODO Marked content.
3070   }
3071 
3072   beginMarkedContent(tag) {
3073     this.markedContentStack.push({
3074       visible: true,
3075     });
3076   }
3077 
3078   beginMarkedContentProps(tag, properties) {
3079     if (tag === "OC") {
3080       this.markedContentStack.push({
3081         visible: this.optionalContentConfig.isVisible(properties),
3082       });
3083     } else {
3084       this.markedContentStack.push({
3085         visible: true,
3086       });
3087     }
3088     this.contentVisible = this.isContentVisible();
3089   }
3090 
3091   endMarkedContent() {
3092     this.markedContentStack.pop();
3093     this.contentVisible = this.isContentVisible();
3094   }
3095 
3096   // Compatibility
3097 
3098   beginCompat() {
3099     // TODO ignore undefined operators (should we do that anyway?)
3100   }
3101 
3102   endCompat() {
3103     // TODO stop ignoring undefined operators
3104   }
3105 
3106   // Helper functions
3107 
3108   consumePath(clipBox) {
3109     const isEmpty = this.current.isEmptyClip();
3110     if (this.pendingClip) {
3111       this.current.updateClipFromPath();
3112     }
3113     if (!this.pendingClip) {
3114       this.compose(clipBox);
3115     }
3116     const ctx = this.ctx;
3117     if (this.pendingClip) {
3118       if (!isEmpty) {
3119         if (this.pendingClip === EO_CLIP) {
3120           ctx.clip("evenodd");
3121         } else {
3122           ctx.clip();
3123         }
3124       }
3125       this.pendingClip = null;
3126     }
3127     this.current.startNewPathAndClipBox(this.current.clipBox);
3128     ctx.beginPath();
3129   }
3130 
3131   getSinglePixelWidth() {
3132     if (!this._cachedGetSinglePixelWidth) {
3133       const m = getCurrentTransform(this.ctx);
3134       if (m[1] === 0 && m[2] === 0) {
3135         // Fast path
3136         this._cachedGetSinglePixelWidth =
3137           1 / Math.min(Math.abs(m[0]), Math.abs(m[3]));
3138       } else {
3139         const absDet = Math.abs(m[0] * m[3] - m[2] * m[1]);
3140         const normX = Math.hypot(m[0], m[2]);
3141         const normY = Math.hypot(m[1], m[3]);
3142         this._cachedGetSinglePixelWidth = Math.max(normX, normY) / absDet;
3143       }
3144     }
3145     return this._cachedGetSinglePixelWidth;
3146   }
3147 
3148   getScaleForStroking() {
3149     // A pixel has thicknessX = thicknessY = 1;
3150     // A transformed pixel is a parallelogram and the thicknesses
3151     // corresponds to the heights.
3152     // The goal of this function is to rescale before setting the
3153     // lineWidth in order to have both thicknesses greater or equal
3154     // to 1 after transform.
3155     if (this._cachedScaleForStroking[0] === -1) {
3156       const { lineWidth } = this.current;
3157       const { a, b, c, d } = this.ctx.getTransform();
3158       let scaleX, scaleY;
3159 
3160       if (b === 0 && c === 0) {
3161         // Fast path
3162         const normX = Math.abs(a);
3163         const normY = Math.abs(d);
3164         if (normX === normY) {
3165           if (lineWidth === 0) {
3166             scaleX = scaleY = 1 / normX;
3167           } else {
3168             const scaledLineWidth = normX * lineWidth;
3169             scaleX = scaleY = scaledLineWidth < 1 ? 1 / scaledLineWidth : 1;
3170           }
3171         } else if (lineWidth === 0) {
3172           scaleX = 1 / normX;
3173           scaleY = 1 / normY;
3174         } else {
3175           const scaledXLineWidth = normX * lineWidth;
3176           const scaledYLineWidth = normY * lineWidth;
3177           scaleX = scaledXLineWidth < 1 ? 1 / scaledXLineWidth : 1;
3178           scaleY = scaledYLineWidth < 1 ? 1 / scaledYLineWidth : 1;
3179         }
3180       } else {
3181         // A pixel (base (x, y)) is transformed by M into a parallelogram:
3182         //  - its area is |det(M)|;
3183         //  - heightY (orthogonal to Mx) has a length: |det(M)| / norm(Mx);
3184         //  - heightX (orthogonal to My) has a length: |det(M)| / norm(My).
3185         // heightX and heightY are the thicknesses of the transformed pixel
3186         // and they must be both greater or equal to 1.
3187         const absDet = Math.abs(a * d - b * c);
3188         const normX = Math.hypot(a, b);
3189         const normY = Math.hypot(c, d);
3190         if (lineWidth === 0) {
3191           scaleX = normY / absDet;
3192           scaleY = normX / absDet;
3193         } else {
3194           const baseArea = lineWidth * absDet;
3195           scaleX = normY > baseArea ? normY / baseArea : 1;
3196           scaleY = normX > baseArea ? normX / baseArea : 1;
3197         }
3198       }
3199       this._cachedScaleForStroking[0] = scaleX;
3200       this._cachedScaleForStroking[1] = scaleY;
3201     }
3202     return this._cachedScaleForStroking;
3203   }
3204 
3205   // Rescale before stroking in order to have a final lineWidth
3206   // with both thicknesses greater or equal to 1.
3207   rescaleAndStroke(saveRestore) {
3208     const { ctx } = this;
3209     const { lineWidth } = this.current;
3210     const [scaleX, scaleY] = this.getScaleForStroking();
3211 
3212     ctx.lineWidth = lineWidth || 1;
3213 
3214     if (scaleX === 1 && scaleY === 1) {
3215       ctx.stroke();
3216       return;
3217     }
3218 
3219     const dashes = ctx.getLineDash();
3220     if (saveRestore) {
3221       ctx.save();
3222     }
3223 
3224     ctx.scale(scaleX, scaleY);
3225 
3226     // How the dashed line is rendered depends on the current transform...
3227     // so we added a rescale to handle too thin lines and consequently
3228     // the way the line is dashed will be modified.
3229     // If scaleX === scaleY, the dashed lines will be rendered correctly
3230     // else we'll have some bugs (but only with too thin lines).
3231     // Here we take the max... why not taking the min... or something else.
3232     // Anyway, as said it's buggy when scaleX !== scaleY.
3233     if (dashes.length > 0) {
3234       const scale = Math.max(scaleX, scaleY);
3235       ctx.setLineDash(dashes.map(x => x / scale));
3236       ctx.lineDashOffset /= scale;
3237     }
3238 
3239     ctx.stroke();
3240 
3241     if (saveRestore) {
3242       ctx.restore();
3243     }
3244   }
3245 
3246   isContentVisible() {
3247     for (let i = this.markedContentStack.length - 1; i >= 0; i--) {
3248       if (!this.markedContentStack[i].visible) {
3249         return false;
3250       }
3251     }
3252     return true;
3253   }
3254 }
3255 
3256 for (const op in OPS) {
3257   if (CanvasGraphics.prototype[op] !== undefined) {
3258     CanvasGraphics.prototype[OPS[op]] = CanvasGraphics.prototype[op];
3259   }
3260 }
3261 
3262 export { CanvasGraphics };
</code>

Your task:
You are a software tester at pdf.js.
1. Write exactly one javascript test `it("...", async () => {...})` block.
2. Your test must fail on the code before the patch, and pass after, hence the test will verify that the patch resolves the issue.
3. The test must be self-contained and to-the-point.
4. Use only the provided imports (respect the paths exactly how they are given) by importing dynamically for compatibility with Node.js — no new dependencies. 
5. Return only the javascript code (no comments or explanations).

Example structure:
it("should <describe behavior>", async () => {
  const { example } = await import("../../src/core/example.js");
  <initialize required variables>;
  <define expected variable>;
  <generate actual variables>;
  <compare expected with actual>;
});

