<think>
Okay, so I need to write a regression test for the issue where Firefox is slow to render poster PDFs. The patch provided modifies the canvas.js file, specifically in the resetCtxToDefault function and the CanvasGraphics class. The change adds a check before setting the context's filter to "none". 

First, I should understand what the patch does. It looks like before the patch, the code was unconditionally setting ctx.filter to "none". Now, it only does that if the current filter isn't "none" or an empty string. This probably prevents unnecessary changes to the filter, which might have been causing performance issues, especially in Firefox.

So, the test needs to verify that after the patch, the filter isn't set to "none" if it already was, which should improve rendering speed. 

I'll structure the test to create a canvas context and check the filter before and after calling resetCtxToDefault. 

I'll start by importing the necessary modules. Since the test is in Node.js, I'll use dynamic imports. I'll need canvas.js for resetCtxToDefault and perhaps some utilities.

I'll create a canvas element using the canvas package. Then, I'll get the 2D context. The test will set the filter to a non-default value, like "blur(5px)", call resetCtxToDefault, and then check if the filter remains as it was, not set to "none". 

Wait, no. The test should ensure that if the filter was already "none", it doesn't change. Or, more accurately, that the function doesn't set it to "none" if it's already that. But in the test, I want to simulate a scenario where the filter is set to something else, then after reset, it remains as it was. Hmm, maybe I should set the filter to something, then call reset, and check that it's still the same. Or, set it to "none", call reset, and it stays "none".

Wait, the function resetCtxToDefault is supposed to reset the context to default settings. But the patch changes it so that it only resets the filter if it's not already "none" or empty. So, if the filter was "none", it won't be changed. But if it was something else, it will be set to "none".

So, the test should check both cases. Maybe two tests, but the user asked for exactly one it block. Alternatively, within one test, I can test both scenarios.

But perhaps the main issue is when the filter is already "none", so the function doesn't change it, which might have been causing unnecessary work before. So, the test can focus on that case.

I'll proceed by setting the filter to "none", then calling resetCtxToDefault, and asserting that the filter remains "none". Wait, no, because the function is supposed to reset to default, which might include setting the filter to "none" if it wasn't. But the patch makes it so that if it's already "none", it doesn't change it. So, perhaps the test should check that when the filter is not "none", it gets set to "none", and when it's already "none", it stays.

But in the context of the issue, the problem was that resetting the filter when it was already "none" caused performance issues. So, the test should ensure that when the filter is "none", the function doesn't change it.

So, the test will:

1. Create a canvas context.
2. Set the filter to "none".
3. Call resetCtxToDefault on the context.
4. Check that the filter is still "none".

If the patch is correct, this should pass. Before the patch, the function would set it to "none" again, which might not cause a problem, but perhaps in some cases, it's better not to change it if not needed.

Wait, but how does that affect performance? Maybe the function was called frequently, and each time it set the filter, causing the browser to re-render unnecessarily. By avoiding setting it when it's already correct, it reduces the number of changes, thus improving performance.

So, the test should simulate that scenario. Let me structure the code.

I'll import the resetCtxToDefault function from the correct path. Then, create a canvas using the canvas package. Get the context, set the filter to "none", then call resetCtxToDefault. Then, assert that the filter is still "none".

Wait, but in the original code, resetCtxToDefault would set it to "none" regardless. So, after the patch, when the filter is already "none", it doesn't change. So, the test should pass because the filter remains "none".

But I think the test should also check the case where the filter is not "none" to ensure it's set correctly. But since the user asked for exactly one test, perhaps I can include both cases in one test.

Alternatively, perhaps the test can check that after calling resetCtxToDefault, the filter is "none" only if it wasn't before. But that might complicate the test.

Alternatively, the test can set the filter to a non-"none" value, call reset, and check it's "none". Then, set it to "none", call reset, and check it's still "none". But that would require multiple steps.

But perhaps for the purpose of this test, focusing on the case where the filter is already "none" is sufficient, as that's the scenario that was causing the performance issue.

So, the test will:

- Import resetCtxToDefault from the correct path.
- Create a canvas and get the context.
- Set the filter to "none".
- Call resetCtxToDefault on the context.
- Assert that the filter is still "none".

This should pass after the patch, and before the patch, it would also pass because the function would set it to "none" again. Wait, that's a problem. Because before the patch, the function would set it to "none" regardless, so the test would still pass. Hmm, that's not good because the test wouldn't fail before the patch.

Wait, perhaps I'm misunderstanding. Before the patch, the function sets ctx.filter to "none" every time. So, in the test, after setting it to "none", calling reset would set it again, which is redundant but doesn't change the value. So, the test would still pass. But that's not useful because the test wouldn't fail before the patch.

I need a test that fails before the patch and passes after. So, perhaps the test should check that when the filter is already "none", the function doesn't change it. But before the patch, the function would set it to "none" again, which might cause a performance hit, but the test's assertion would still pass because the value is the same.

Hmm, perhaps I'm approaching this wrong. The issue is about performance, so maybe the test should measure the time it takes to render, but that's not practical in a unit test. Alternatively, the test can check that the function doesn't modify the filter when it's already "none".

But how can I test that? Maybe by using a mock or checking if the context's filter was changed.

Alternatively, perhaps the test can check that the function doesn't set the filter to "none" when it's already that. So, in the test, after calling resetCtxToDefault, the filter remains as it was.

Wait, but the function is supposed to reset the context to default, which includes setting the filter to "none". So, if the filter was something else, it should be set to "none". But if it's already "none", it shouldn't be changed.

So, the test can have two parts:

1. Set filter to "blur(5px)", call reset, assert it becomes "none".
2. Set filter to "none", call reset, assert it remains "none".

But the user wants exactly one test, so perhaps I can do both in one test.

So, the test would:

- Create a context.
- Set filter to "blur(5px)".
- Call resetCtxToDefault.
- Assert filter is "none".
- Then, set filter to "none".
- Call resetCtxToDefault again.
- Assert filter is still "none".

This way, the test checks both cases. Before the patch, the first part would pass (filter set to "none"), but the second part would also pass because the function would set it to "none" again, which doesn't change anything. So, the test wouldn't fail before the patch, which is not helpful.

Hmm, perhaps I'm missing something. The issue is that the function was resetting the filter to "none" even when it was already "none", causing unnecessary work. So, the test should ensure that when the filter is "none", it's not changed.

But how to test that? Maybe by checking that the function doesn't call the setter when it's not needed. But that's hard to test.

Alternatively, perhaps the test can use a spy or mock to see if ctx.filter is set when it's already "none". But in Node.js, that might be tricky.

Wait, perhaps the test can be written using a canvas and checking the filter before and after. Let me think.

In the test, I'll create a canvas context, set the filter to "none", then call resetCtxToDefault, and then check that the filter is still "none". But before the patch, the function would set it to "none" again, which doesn't change the value, so the test would still pass. So, that's not helpful.

Alternatively, perhaps the test should check that the function doesn't change the filter when it's already "none". But how?

Maybe I can set the filter to "none", then call resetCtxToDefault, and then check that the filter is still "none". But before the patch, it would set it again, so the test would still pass. So, that's not sufficient.

Wait, perhaps the problem is that before the patch, the function was setting the filter to "none" even if it was already "none", which caused the context to be reset more times than necessary, leading to slower performance. So, the test should ensure that after the patch, when the filter is "none", it's not reset again.

But how to translate that into a test? Maybe the test can measure the number of times the filter is set, but that's not straightforward.

Alternatively, perhaps the test can create a scenario where the function is called multiple times and the filter remains "none" after each call. But again, the test would pass before the patch because the value remains "none".

I'm stuck. Maybe I should think differently. The patch changes the function to only set the filter if it's not "none" or empty. So, the test can check that when the filter is "none", the function doesn't set it again.

But how to observe that in a test? Perhaps by using a mock or a spy on the ctx.filter setter.

But in Node.js, using the canvas package, I can create a context and monitor the setter. Wait, perhaps I can override the setter to track if it's called.

So, the test can do something like:

- Create a context.
- Set the filter to "none".
- Spy on the ctx.filter setter.
- Call resetCtxToDefault.
- Assert that the setter was not called.

But in Node.js, with the canvas package, can I do that? I'm not sure. Alternatively, perhaps I can check the value before and after, but that won't tell me if the setter was called.

Alternatively, perhaps the test can be written in a way that the function is called, and then we check if the filter is still "none". But that won't capture whether the function attempted to set it or not.

Hmm, perhaps the test isn't about the function's behavior but about the performance improvement. But that's hard to measure in a unit test.

Alternatively, perhaps the test can create a large number of contexts and call resetCtxToDefault on them, measuring the time before and after the patch. But that's more of a benchmark than a unit test.

But the user wants a test that fails before the patch and passes after. So, perhaps the test can check that after the patch, the function doesn't set the filter to "none" when it's already "none".

Wait, perhaps I can set the filter to "none", then call resetCtxToDefault, and then check that the filter is still "none". But before the patch, the function would set it to "none" again, which doesn't change the value. So, the test would pass both before and after, which isn't helpful.

I'm going in circles. Maybe I should proceed with the test that checks both cases: when the filter is not "none" and when it is. So, the test will ensure that after the patch, the function correctly sets the filter to "none" only when necessary.

So, the test will:

1. Create a canvas context.
2. Set the filter to "blur(5px)".
3. Call resetCtxToDefault.
4. Assert the filter is "none".
5. Set the filter to "none".
6. Call resetCtxToDefault again.
7. Assert the filter is still "none".

This way, the test ensures that the function behaves correctly in both scenarios. Before the patch, step 7 would pass because the function would set it to "none" again, but it's redundant. However, the test would still pass, so it doesn't help in failing before the patch.

Wait, perhaps the issue is that the function was resetting the filter even when it was already "none", which caused the context to be updated more than necessary, leading to slower rendering. So, the test should ensure that after the patch, the function doesn't reset the filter when it's already "none".

But how to translate that into a test that would fail before the patch? Maybe the test can check that the function doesn't change the filter when it's already "none". But before the patch, the function would change it, which would cause the test to fail.

Wait, no. Before the patch, the function would set the filter to "none" regardless. So, if the test sets the filter to "none" and then calls reset, the filter remains "none", so the test would pass. So, the test wouldn't fail before the patch.

I'm stuck. Maybe I should proceed with the test that checks both cases, even though it wouldn't fail before the patch. Alternatively, perhaps the test should focus on the performance aspect, but that's not feasible in a unit test.

Alternatively, perhaps the test can check that the function doesn't set the filter to "none" when it's already "none". So, the test would set the filter to "none", call reset, and then check that the filter is still "none". But before the patch, it would still be "none", so the test would pass. So, that's not helpful.

Hmm, perhaps I'm overcomplicating. The patch adds a condition to only set the filter if it's not "none" or empty. So, the test can check that when the filter is "none", the function doesn't set it again.

But how to observe that in the test? Maybe by using a mock or spy. Let me think.

In Node.js, I can create a mock context object and spy on the filter setter. Then, call resetCtxToDefault and see if the setter was called when the filter was already "none".

So, the test would:

- Create a mock context with filter set to "none".
- Spy on the setter for filter.
- Call resetCtxToDefault on the context.
- Assert that the setter was not called.

This way, before the patch, the setter would be called, causing the test to fail. After the patch, the setter isn't called, so the test passes.

Yes, that makes sense. So, the test will use a mock context, set the filter to "none", and check that resetCtxToDefault doesn't attempt to set it again.

But how to create a mock context in Node.js? I can create an object that mocks the context, with a filter property and a setter that we can spy on.

So, in the test, I'll create a mock context:

const ctx = {
  filter: "none",
};

Then, use a spy on the setter for filter. But in JavaScript, setters can be spied using a proxy or by overriding the property.

Alternatively, I can use a Jest mock. But since the test is in Node.js and uses dynamic imports, perhaps I can use a simple object with a getter and setter.

Wait, perhaps I can define the context as an object with a getter and setter for filter, and track when the setter is called.

So, let's create a mock context:

let filterValue = "none";
const ctx = {
  get filter() {
    return filterValue;
  },
  set filter(value) {
    filterValue = value;
    // Track if the setter was called
    setterCalled = true;
  },
};

Then, in the test, set filterValue to "none", call resetCtxToDefault(ctx), and assert that setterCalled is false.

But wait, the function resetCtxToDefault is supposed to set the filter to "none" only if it's not already. So, in this case, since the filter is "none", the setter shouldn't be called.

So, the test would:

- Initialize filterValue to "none".
- Call resetCtxToDefault(ctx).
- Check that setterCalled is false.

Before the patch, the function would set the filter to "none", so setterCalled would be true, causing the test to fail. After the patch, setterCalled remains false, so the test passes.

Yes, that makes sense. So, the test will mock the context and check if the setter is called when it shouldn't be.

So, putting it all together, the test will:

1. Import resetCtxToDefault from the correct path.
2. Create a mock context with filter set to "none" and a setter that tracks if it's called.
3. Call resetCtxToDefault on the mock context.
4. Assert that the setter was not called.

This way, before the patch, the function would call the setter, causing the test to fail. After the patch, the setter isn't called, so the test passes.

I think that's a solid approach. Now, I'll write the code accordingly.
</think>

it("should not reset filter when it's already none", async () => {
  const { resetCtxToDefault } = await import("../../src/display/canvas.js");
  let setterCalled = false;
  const ctx = {
    filter: "none",
    get filter() {
      return this._filter;
    },
    set filter(value) {
      setterCalled = true;
      this._filter = value;
    },
  };
  ctx.filter = "none";
  resetCtxToDefault(ctx);
  expect(setterCalled).toBe(false);
});