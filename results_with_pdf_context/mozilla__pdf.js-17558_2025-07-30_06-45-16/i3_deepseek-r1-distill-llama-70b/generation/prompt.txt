Before you begin:
- Keep going until the job is completely solved — don’t stop halfway.
- If you’re unsure about the behavior, reread the provided patch carefully; do not hallucinate.
- Plan your approach before writing code by reflecting on whether the test truly fails before and passes after.

Issue:
<issue>
[Omnibus Experiment] Emojis not shown in PDFs
</issue>

PDF File:
<pdf>
bug1669097.pdf
</pdf>

Patch:
<patch>
diff --git a/src/core/annotation.js b/src/core/annotation.js
--- a/src/core/annotation.js
+++ b/src/core/annotation.js
@@ -3826,7 +3826,7 @@ class FreeTextAnnotation extends MarkupAnnotation {
           fontColor,
           strokeAlpha
         );
-        this._streams.push(this.appearance, FakeUnicodeFont.toUnicodeStream);
+        this._streams.push(this.appearance);
       } else {
         warn(
           "FreeTextAnnotation: OffscreenCanvas is not supported, annotation may not render correctly."

diff --git a/src/core/core_utils.js b/src/core/core_utils.js
--- a/src/core/core_utils.js
+++ b/src/core/core_utils.js
@@ -386,6 +386,17 @@ const XMLEntities = {
   /* ' */ 0x27: "&apos;",
 };
 
+function* codePointIter(str) {
+  for (let i = 0, ii = str.length; i < ii; i++) {
+    const char = str.codePointAt(i);
+    if (char > 0xd7ff && (char < 0xe000 || char > 0xfffd)) {
+      // char is represented by two u16
+      i++;
+    }
+    yield char;
+  }
+}
+
 function encodeToXmlString(str) {
   const buffer = [];
   let start = 0;
@@ -602,6 +613,7 @@ function getRotationMatrix(rotation, width, height) {
 
 export {
   arrayBuffersToBytes,
+  codePointIter,
   collectActions,
   encodeToXmlString,
   escapePDFName,

diff --git a/src/core/default_appearance.js b/src/core/default_appearance.js
--- a/src/core/default_appearance.js
+++ b/src/core/default_appearance.js
@@ -13,13 +13,14 @@
  * limitations under the License.
  */
 
-import { Dict, Name } from "./primitives.js";
 import {
+  codePointIter,
   escapePDFName,
   getRotationMatrix,
   numberToString,
   stringToUTF16HexString,
 } from "./core_utils.js";
+import { Dict, Name } from "./primitives.js";
 import {
   LINE_DESCENT_FACTOR,
   LINE_FACTOR,
@@ -251,35 +252,6 @@ class FakeUnicodeFont {
     );
   }
 
-  get toUnicodeRef() {
-    if (!FakeUnicodeFont._toUnicodeRef) {
-      const toUnicode = `/CIDInit /ProcSet findresource begin
-12 dict begin
-begincmap
-/CIDSystemInfo
-<< /Registry (Adobe)
-/Ordering (UCS) /Supplement 0 >> def
-/CMapName /Adobe-Identity-UCS def
-/CMapType 2 def
-1 begincodespacerange
-<0000> <FFFF>
-endcodespacerange
-1 beginbfrange
-<0000> <FFFF> <0000>
-endbfrange
-endcmap CMapName currentdict /CMap defineresource pop end end`;
-      const toUnicodeStream = (FakeUnicodeFont.toUnicodeStream =
-        new StringStream(toUnicode));
-      const toUnicodeDict = new Dict(this.xref);
-      toUnicodeStream.dict = toUnicodeDict;
-      toUnicodeDict.set("Length", toUnicode.length);
-      FakeUnicodeFont._toUnicodeRef =
-        this.xref.getNewPersistentRef(toUnicodeStream);
-    }
-
-    return FakeUnicodeFont._toUnicodeRef;
-  }
-
   get fontDescriptorRef() {
     if (!FakeUnicodeFont._fontDescriptorRef) {
       const fontDescriptor = new Dict(this.xref);
@@ -350,7 +322,7 @@ endcmap CMapName currentdict /CMap defineresource pop end end`;
     baseFont.set("Subtype", Name.get("Type0"));
     baseFont.set("Encoding", Name.get("Identity-H"));
     baseFont.set("DescendantFonts", [this.descendantFontRef]);
-    baseFont.set("ToUnicode", this.toUnicodeRef);
+    baseFont.set("ToUnicode", Name.get("Identity-H"));
 
     return this.xref.getNewPersistentRef(baseFont);
   }
@@ -420,8 +392,8 @@ endcmap CMapName currentdict /CMap defineresource pop end end`;
       // languages, like arabic, it'd be wrong because of ligatures.
       const lineWidth = ctx.measureText(line).width;
       maxWidth = Math.max(maxWidth, lineWidth);
-      for (const char of line.split("")) {
-        const code = char.charCodeAt(0);
+      for (const code of codePointIter(line)) {
+        const char = String.fromCodePoint(code);
         let width = this.widths.get(code);
         if (width === undefined) {
           const metrics = ctx.measureText(char);


</patch>

Imports:
<imports>
Available Packages
Dev Dependencies:
- @babel/core: ^7.23.7
- @babel/preset-env: ^7.23.8
- @babel/runtime: ^7.23.8
- @fluent/bundle: ^0.18.0
- @fluent/dom: ^0.9.0
- @javascript-obfuscator/escodegen: 2.3.0
- @jazzer.js/core: ^2.1.0
- acorn: ^8.11.3
- autoprefixer: ^10.4.17
- babel-loader: ^9.1.3
- caniuse-lite: ^1.0.30001579
- canvas: ^2.11.2
- core-js: ^3.35.0
- cross-env: ^7.0.3
- eslint: ^8.56.0
- eslint-config-prettier: ^8.10.0
- eslint-plugin-fetch-options: ^0.0.5
- eslint-plugin-html: ^7.1.0
- eslint-plugin-import: ^2.29.1
- eslint-plugin-jasmine: ^4.1.3
- eslint-plugin-json: ^3.1.0
- eslint-plugin-mozilla: ^3.3.2
- eslint-plugin-no-unsanitized: ^4.0.2
- eslint-plugin-prettier: ^5.1.3
- eslint-plugin-sort-exports: ^0.8.0
- eslint-plugin-unicorn: ^50.0.1
- globals: ^13.24.0
- gulp: ^4.0.2
- gulp-cli: ^2.3.0
- gulp-postcss: ^9.1.0
- gulp-rename: ^2.0.0
- gulp-replace: ^1.1.4
- gulp-zip: ^6.0.0
- jasmine: ^5.1.0
- jsdoc: ^4.0.2
- jstransformer-markdown-it: ^3.0.0
- merge-stream: ^2.0.0
- mkdirp: ^3.0.1
- needle: ^3.3.1
- path2d-polyfill: ^2.0.1
- pngjs: ^7.0.0
- postcss: ^8.4.33
- postcss-dark-theme-class: ^1.1.0
- postcss-dir-pseudo-class: ^8.0.1
- postcss-discard-comments: ^6.0.1
- postcss-nesting: ^12.0.2
- prettier: ^3.2.4
- puppeteer: ^21.7.0
- rimraf: ^3.0.2
- streamqueue: ^1.1.2
- stylelint: ^16.2.0
- stylelint-prettier: ^5.0.0
- terser: ^5.27.0
- through2: ^4.0.2
- tsc-alias: ^1.8.8
- ttest: ^4.0.0
- typescript: ^5.3.3
- typogr: ^0.6.8
- vinyl: ^3.0.0
- webpack: ^5.89.0
- webpack-stream: ^7.0.0
- wintersmith: ^2.5.0
- yargs: ^17.7.2

Engines:
- node: >=18

Available Relative Imports:
- `../../src/core/annotation.js`: Annotation, AnnotationBorderStyle, AnnotationFactory, MarkupAnnotation, getQuadPoints
- `../../src/core/bidi.js`: bidi
- `../../src/core/cff_parser.js`: CFFCharset, CFFCompiler, CFFFDSelect, CFFParser, CFFStrings
- `../../src/core/cmap.js`: CMap, CMapFactory, IdentityCMap
- `../../src/core/colorspace.js`: ColorSpace
- `../../src/core/core_utils.js`: arrayBuffersToBytes, encodeToXmlString, escapePDFName, escapeString, getInheritableProperty, isAscii, isWhiteSpace, log2, numberToString, parseXFAPath, recoverJsURL, stringToUTF16HexString, stringToUTF16String, toRomanNumerals, validateCSSFont
- `../../src/core/crypto.js`: AES128Cipher, AES256Cipher, ARCFourCipher, CipherTransformFactory, PDF17, PDF20, calculateMD5, calculateSHA256, calculateSHA384, calculateSHA512
- `../../src/core/default_appearance.js`: createDefaultAppearance, parseAppearanceStream, parseDefaultAppearance
- `../../src/core/document.js`: PDFDocument, Page
- `../../src/core/encodings.js`: getEncoding
- `../../src/core/evaluator.js`: PartialEvaluator
- `../../src/core/font_substitutions.js`: getFontSubstitution
- `../../src/core/fonts_utils.js`: SEAC_ANALYSIS_ENABLED
- `../../src/core/function.js`: PDFFunctionFactory, PostScriptCompiler, PostScriptEvaluator
- `../../src/core/glyphlist.js`: getDingbatsGlyphsUnicode, getGlyphsUnicode
- `../../src/core/image_utils.js`: GlobalImageCache, LocalColorSpaceCache
- `../../src/core/jbig2.js`: Jbig2Image
- `../../src/core/jpg.js`: JpegImage
- `../../src/core/jpx.js`: JpxImage
- `../../src/core/metadata_parser.js`: MetadataParser
- `../../src/core/operator_list.js`: OperatorList
- `../../src/core/parser.js`: Lexer, Linearization, Parser
- `../../src/core/predictor_stream.js`: PredictorStream
- `../../src/core/primitives.js`: Cmd, Dict, EOF, Name, Ref, RefSet, RefSetCache, isCmd, isDict, isName, isRefsEqual
- `../../src/core/ps_parser.js`: PostScriptLexer, PostScriptParser
- `../../src/core/stream.js`: NullStream, Stream, StringStream
- `../../src/core/type1_parser.js`: Type1Parser
- `../../src/core/unicode.js`: getCharUnicodeCategory, getUnicodeForGlyph, getUnicodeRangeFor, mapSpecialUnicodeValues
- `../../src/core/worker.js`: WorkerMessageHandler, WorkerTask
- `../../src/core/writer.js`: incrementalUpdate, writeDict
- `../../src/core/xfa/bind.js`: Binder
- `../../src/core/xfa/data.js`: DataHandler
- `../../src/core/xfa/factory.js`: XFAFactory
- `../../src/core/xfa/formcalc_lexer.js`: Lexer, TOKEN, Token
- `../../src/core/xfa/formcalc_parser.js`: Errors, Parser
- `../../src/core/xfa/parser.js`: XFAParser
- `../../src/core/xfa/som.js`: searchNode
- `../../src/core/xfa/symbol_utils.js`: $dump, $getChildren, $getChildrenByClass, $getChildrenByName, $text, $uid
- `../../src/core/xml_parser.js`: SimpleXMLParser, XMLParserBase
- `../../src/display/annotation_layer.js`: AnnotationLayer
- `../../src/display/annotation_storage.js`: AnnotationStorage
- `../../src/display/api.js`: DefaultCMapReaderFactory, DefaultCanvasFactory, DefaultStandardFontDataFactory, LoopbackPort, PDFDataRangeTransport, PDFDocumentLoadingTask, PDFDocumentProxy, PDFPageProxy, PDFWorker, PDFWorkerUtil, RenderTask, build, getDocument, version
- `../../src/display/display_utils.js`: DOMCanvasFactory, DOMSVGFactory, PDFDateString, PageViewport, PixelsPerInch, RenderingCancelledException, StatTimer, fetchData, getFilenameFromUrl, getPdfFilenameFromUrl, getXfaPageViewport, isDataScheme, isPdfFile, isValidFetchUrl, noContextMenu, setLayerDimensions
- `../../src/display/draw_layer.js`: DrawLayer
- `../../src/display/editor/annotation_editor_layer.js`: AnnotationEditorLayer
- `../../src/display/editor/color_picker.js`: ColorPicker
- `../../src/display/editor/outliner.js`: Outliner
- `../../src/display/editor/tools.js`: AnnotationEditorUIManager, CommandManager
- `../../src/display/fetch_stream.js`: PDFFetchStream
- `../../src/display/metadata.js`: Metadata
- `../../src/display/network.js`: PDFNetworkStream
- `../../src/display/network_utils.js`: createResponseStatusError, extractFilenameFromHeader, validateRangeRequestCapabilities, validateResponseStatus
- `../../src/display/node_stream.js`: PDFNodeStream
- `../../src/display/text_layer.js`: TextLayerRenderTask, renderTextLayer, updateTextLayer
- `../../src/display/worker_options.js`: GlobalWorkerOptions
- `../../src/display/xfa_layer.js`: XfaLayer
- `../../src/shared/message_handler.js`: MessageHandler
- `../../src/shared/murmurhash3.js`: MurmurHash3_64
- `../../src/shared/util.js`: AbortException, AnnotationBorderStyleType, AnnotationEditorParamsType, AnnotationEditorType, AnnotationFieldFlag, AnnotationFlag, AnnotationMode, AnnotationType, CMapCompressionType, FeatureTest, FormatError, ImageKind, InvalidPDFException, MissingPDFException, OPS, PasswordException, PasswordResponses, PermissionFlag, PromiseCapability, RenderingIntentFlag, UnexpectedResponseException, UnknownErrorException, Util, VerbosityLevel, bytesToString, createValidAbsoluteUrl, getModificationDate, getVerbosityLevel, isNodeJS, normalizeUnicode, objectSize, setVerbosityLevel, shadow, string32, stringToBytes, stringToPDFString, stringToUTF8String
- `../../web/annotation_layer_builder.js`: AnnotationLayerBuilder
- `../../web/download_manager.js`: DownloadManager
- `../../web/event_utils.js`: EventBus, WaitOnType, waitOnEventOrTimeout
- `../../web/genericl10n.js`: GenericL10n
- `../../web/l10n.js`: L10n
- `../../web/l10n_utils.js`: NullL10n
- `../../web/pdf_find_controller.js`: FindState, PDFFindController
- `../../web/pdf_find_utils.js`: CharacterType, getCharacterType
- `../../web/pdf_history.js`: PDFHistory, isDestArraysEqual, isDestHashesEqual
- `../../web/pdf_link_service.js`: LinkTarget, PDFLinkService, SimpleLinkService
- `../../web/pdf_page_view.js`: PDFPageView
- `../../web/pdf_scripting_manager.component.js`: PDFScriptingManager
- `../../web/pdf_single_page_viewer.js`: PDFSinglePageViewer
- `../../web/pdf_viewer.js`: PDFPageViewBuffer, PDFViewer
- `../../web/struct_tree_layer_builder.js`: StructTreeLayerBuilder
- `../../web/text_layer_builder.js`: TextLayerBuilder
- `../../web/ui_utils.js`: AutoPrintRegExp, ProgressBar, RenderingStates, ScrollMode, SpreadMode, backtrackBeforeAllVisibleElements, binarySearchFirstItem, getPageSizeInches, getVisibleElements, isPortraitOrientation, isValidRotation, parseQueryString, removeNullCharacters
- `../../web/xfa_layer_builder.js`: XfaLayerBuilder
- `./test_utils.js`: CMAP_URL, DefaultFileReaderFactory, STANDARD_FONT_DATA_URL, TEST_PDFS_PATH, XRefMock, buildGetDocumentParams, createIdFactory
- `./testreporter.js`: TestReporter
</imports>

Code:
<code>
File:
src/core/annotation.js
1 /* Copyright 2012 Mozilla Foundation
2  *
3  * Licensed under the Apache License, Version 2.0 (the "License");
4  * you may not use this file except in compliance with the License.
5  * You may obtain a copy of the License at
6  *
7  *     http://www.apache.org/licenses/LICENSE-2.0
8  *
9  * Unless required by applicable law or agreed to in writing, software
10  * distributed under the License is distributed on an "AS IS" BASIS,
11  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
12  * See the License for the specific language governing permissions and
13  * limitations under the License.
14  */
15 
16 import {
17   AnnotationActionEventType,
18   AnnotationBorderStyleType,
19   AnnotationEditorType,
20   AnnotationFieldFlag,
21   AnnotationFlag,
22   AnnotationReplyType,
23   AnnotationType,
24   assert,
25   BASELINE_FACTOR,
26   FeatureTest,
27   getModificationDate,
28   IDENTITY_MATRIX,
29   info,
30   LINE_DESCENT_FACTOR,
31   LINE_FACTOR,
32   OPS,
33   RenderingIntentFlag,
34   shadow,
35   stringToPDFString,
36   unreachable,
37   Util,
38   warn,
39 } from "../shared/util.js";
40 import {
41   collectActions,
42   escapeString,
43   getInheritableProperty,
44   getRotationMatrix,
45   isAscii,
46   numberToString,
47   stringToUTF16String,
48 } from "./core_utils.js";
49 import {
50   createDefaultAppearance,
51   FakeUnicodeFont,
52   getPdfColor,
53   parseAppearanceStream,
54   parseDefaultAppearance,
55 } from "./default_appearance.js";
56 import { Dict, isName, isRefsEqual, Name, Ref, RefSet } from "./primitives.js";
57 import { Stream, StringStream } from "./stream.js";
58 import { BaseStream } from "./base_stream.js";
59 import { bidi } from "./bidi.js";
60 import { Catalog } from "./catalog.js";
61 import { ColorSpace } from "./colorspace.js";
62 import { FileSpec } from "./file_spec.js";
63 import { JpegStream } from "./jpeg_stream.js";
64 import { ObjectLoader } from "./object_loader.js";
65 import { OperatorList } from "./operator_list.js";
66 import { writeObject } from "./writer.js";
67 import { XFAFactory } from "./xfa/factory.js";
68 
69 class AnnotationFactory {
70   static createGlobals(pdfManager) {
71     return Promise.all([
72       pdfManager.ensureCatalog("acroForm"),
73       pdfManager.ensureDoc("xfaDatasets"),
74       pdfManager.ensureCatalog("structTreeRoot"),
75       // Only necessary to prevent the `Catalog.baseUrl`-getter, used
76       // with some Annotations, from throwing and thus breaking parsing:
77       pdfManager.ensureCatalog("baseUrl"),
78       // Only necessary to prevent the `Catalog.attachments`-getter, used
79       // with "GoToE" actions, from throwing and thus breaking parsing:
80       pdfManager.ensureCatalog("attachments"),
81     ]).then(
82       // eslint-disable-next-line arrow-body-style
83       ([acroForm, xfaDatasets, structTreeRoot, baseUrl, attachments]) => {
84         return {
85           pdfManager,
86           acroForm: acroForm instanceof Dict ? acroForm : Dict.empty,
87           xfaDatasets,
88           structTreeRoot,
89           baseUrl,
90           attachments,
91         };
92       },
93       reason => {
94         warn(`createGlobals: "${reason}".`);
95         return null;
96       }
97     );
98   }
99 
100   /**
101    * Create an `Annotation` object of the correct type for the given reference
102    * to an annotation dictionary. This yields a promise that is resolved when
103    * the `Annotation` object is constructed.
104    *
105    * @param {XRef} xref
106    * @param {Object} ref
107    * @params {Object} annotationGlobals
108    * @param {Object} idFactory
109    * @param {boolean} [collectFields]
110    * @param {Object} [pageRef]
111    * @returns {Promise} A promise that is resolved with an {Annotation}
112    *   instance.
113    */
114   static async create(
115     xref,
116     ref,
117     annotationGlobals,
118     idFactory,
119     collectFields,
120     pageRef
121   ) {
122     const pageIndex = collectFields
123       ? await this._getPageIndex(xref, ref, annotationGlobals.pdfManager)
124       : null;
125 
126     return annotationGlobals.pdfManager.ensure(this, "_create", [
127       xref,
128       ref,
129       annotationGlobals,
130       idFactory,
131       collectFields,
132       pageIndex,
133       pageRef,
134     ]);
135   }
136 
137   /**
138    * @private
139    */
140   static _create(
141     xref,
142     ref,
143     annotationGlobals,
144     idFactory,
145     collectFields = false,
146     pageIndex = null,
147     pageRef = null
148   ) {
149     const dict = xref.fetchIfRef(ref);
150     if (!(dict instanceof Dict)) {
151       return undefined;
152     }
153 
154     const { acroForm, pdfManager } = annotationGlobals;
155     const id =
156       ref instanceof Ref ? ref.toString() : `annot_${idFactory.createObjId()}`;
157 
158     // Determine the annotation's subtype.
159     let subtype = dict.get("Subtype");
160     subtype = subtype instanceof Name ? subtype.name : null;
161 
162     // Return the right annotation object based on the subtype and field type.
163     const parameters = {
164       xref,
165       ref,
166       dict,
167       subtype,
168       id,
169       annotationGlobals,
170       collectFields,
171       needAppearances:
172         !collectFields && acroForm.get("NeedAppearances") === true,
173       pageIndex,
174       evaluatorOptions: pdfManager.evaluatorOptions,
175       pageRef,
176     };
177 
178     switch (subtype) {
179       case "Link":
180         return new LinkAnnotation(parameters);
181 
182       case "Text":
183         return new TextAnnotation(parameters);
184 
185       case "Widget":
186         let fieldType = getInheritableProperty({ dict, key: "FT" });
187         fieldType = fieldType instanceof Name ? fieldType.name : null;
188 
189         switch (fieldType) {
190           case "Tx":
191             return new TextWidgetAnnotation(parameters);
192           case "Btn":
193             return new ButtonWidgetAnnotation(parameters);
194           case "Ch":
195             return new ChoiceWidgetAnnotation(parameters);
196           case "Sig":
197             return new SignatureWidgetAnnotation(parameters);
198         }
199         warn(
200           `Unimplemented widget field type "${fieldType}", ` +
201             "falling back to base field type."
202         );
203         return new WidgetAnnotation(parameters);
204 
205       case "Popup":
206         return new PopupAnnotation(parameters);
207 
208       case "FreeText":
209         return new FreeTextAnnotation(parameters);
210 
211       case "Line":
212         return new LineAnnotation(parameters);
213 
214       case "Square":
215         return new SquareAnnotation(parameters);
216 
217       case "Circle":
218         return new CircleAnnotation(parameters);
219 
220       case "PolyLine":
221         return new PolylineAnnotation(parameters);
222 
223       case "Polygon":
224         return new PolygonAnnotation(parameters);
225 
226       case "Caret":
227         return new CaretAnnotation(parameters);
228 
229       case "Ink":
230         return new InkAnnotation(parameters);
231 
232       case "Highlight":
233         return new HighlightAnnotation(parameters);
234 
235       case "Underline":
236         return new UnderlineAnnotation(parameters);
237 
238       case "Squiggly":
239         return new SquigglyAnnotation(parameters);
240 
241       case "StrikeOut":
242         return new StrikeOutAnnotation(parameters);
243 
244       case "Stamp":
245         return new StampAnnotation(parameters);
246 
247       case "FileAttachment":
248         return new FileAttachmentAnnotation(parameters);
249 
250       default:
251         if (!collectFields) {
252           if (!subtype) {
253             warn("Annotation is missing the required /Subtype.");
254           } else {
255             warn(
256               `Unimplemented annotation type "${subtype}", ` +
257                 "falling back to base annotation."
258             );
259           }
260         }
261         return new Annotation(parameters);
262     }
263   }
264 
265   static async _getPageIndex(xref, ref, pdfManager) {
266     try {
267       const annotDict = await xref.fetchIfRefAsync(ref);
268       if (!(annotDict instanceof Dict)) {
269         return -1;
270       }
271       const pageRef = annotDict.getRaw("P");
272       if (pageRef instanceof Ref) {
273         try {
274           const pageIndex = await pdfManager.ensureCatalog("getPageIndex", [
275             pageRef,
276           ]);
277           return pageIndex;
278         } catch (ex) {
279           info(`_getPageIndex -- not a valid page reference: "${ex}".`);
280         }
281       }
282       if (annotDict.has("Kids")) {
283         return -1; // Not an annotation reference.
284       }
285       // Fallback to, potentially, checking the annotations of all pages.
286       // PLEASE NOTE: This could force the *entire* PDF document to load,
287       //              hence it absolutely cannot be done unconditionally.
288       const numPages = await pdfManager.ensureDoc("numPages");
289 
290       for (let pageIndex = 0; pageIndex < numPages; pageIndex++) {
291         const page = await pdfManager.getPage(pageIndex);
292         const annotations = await pdfManager.ensure(page, "annotations");
293 
294         for (const annotRef of annotations) {
295           if (annotRef instanceof Ref && isRefsEqual(annotRef, ref)) {
296             return pageIndex;
297           }
298         }
299       }
300     } catch (ex) {
301       warn(`_getPageIndex: "${ex}".`);
302     }
303     return -1;
304   }
305 
306   static generateImages(annotations, xref, isOffscreenCanvasSupported) {
307     if (!isOffscreenCanvasSupported) {
308       warn(
309         "generateImages: OffscreenCanvas is not supported, cannot save or print some annotations with images."
310       );
311       return null;
312     }
313     let imagePromises;
314     for (const { bitmapId, bitmap } of annotations) {
315       if (!bitmap) {
316         continue;
317       }
318       imagePromises ||= new Map();
319       imagePromises.set(bitmapId, StampAnnotation.createImage(bitmap, xref));
320     }
321 
322     return imagePromises;
323   }
324 
325   static async saveNewAnnotations(evaluator, task, annotations, imagePromises) {
326     const xref = evaluator.xref;
327     let baseFontRef;
328     const dependencies = [];
329     const promises = [];
330     const { isOffscreenCanvasSupported } = evaluator.options;
331 
332     for (const annotation of annotations) {
333       if (annotation.deleted) {
334         continue;
335       }
336       switch (annotation.annotationType) {
337         case AnnotationEditorType.FREETEXT:
338           if (!baseFontRef) {
339             const baseFont = new Dict(xref);
340             baseFont.set("BaseFont", Name.get("Helvetica"));
341             baseFont.set("Type", Name.get("Font"));
342             baseFont.set("Subtype", Name.get("Type1"));
343             baseFont.set("Encoding", Name.get("WinAnsiEncoding"));
344             const buffer = [];
345             baseFontRef = xref.getNewTemporaryRef();
346             await writeObject(baseFontRef, baseFont, buffer, xref);
347             dependencies.push({ ref: baseFontRef, data: buffer.join("") });
348           }
349           promises.push(
350             FreeTextAnnotation.createNewAnnotation(
351               xref,
352               annotation,
353               dependencies,
354               { evaluator, task, baseFontRef }
355             )
356           );
357           break;
358         case AnnotationEditorType.HIGHLIGHT:
359           if (annotation.quadPoints) {
360             promises.push(
361               HighlightAnnotation.createNewAnnotation(
362                 xref,
363                 annotation,
364                 dependencies
365               )
366             );
367           } else {
368             promises.push(
369               InkAnnotation.createNewAnnotation(xref, annotation, dependencies)
370             );
371           }
372           break;
373         case AnnotationEditorType.INK:
374           promises.push(
375             InkAnnotation.createNewAnnotation(xref, annotation, dependencies)
376           );
377           break;
378         case AnnotationEditorType.STAMP:
379           if (!isOffscreenCanvasSupported) {
380             break;
381           }
382           const image = await imagePromises.get(annotation.bitmapId);
383           if (image.imageStream) {
384             const { imageStream, smaskStream } = image;
385             const buffer = [];
386             if (smaskStream) {
387               const smaskRef = xref.getNewTemporaryRef();
388               await writeObject(smaskRef, smaskStream, buffer, xref);
389               dependencies.push({ ref: smaskRef, data: buffer.join("") });
390               imageStream.dict.set("SMask", smaskRef);
391               buffer.length = 0;
392             }
393             const imageRef = (image.imageRef = xref.getNewTemporaryRef());
394             await writeObject(imageRef, imageStream, buffer, xref);
395             dependencies.push({ ref: imageRef, data: buffer.join("") });
396             image.imageStream = image.smaskStream = null;
397           }
398           promises.push(
399             StampAnnotation.createNewAnnotation(
400               xref,
401               annotation,
402               dependencies,
403               { image }
404             )
405           );
406           break;
407       }
408     }
409 
410     return {
411       annotations: await Promise.all(promises),
412       dependencies,
413     };
414   }
415 
416   static async printNewAnnotations(
417     annotationGlobals,
418     evaluator,
419     task,
420     annotations,
421     imagePromises
422   ) {
423     if (!annotations) {
424       return null;
425     }
426 
427     const { options, xref } = evaluator;
428     const promises = [];
429     for (const annotation of annotations) {
430       if (annotation.deleted) {
431         continue;
432       }
433       switch (annotation.annotationType) {
434         case AnnotationEditorType.FREETEXT:
435           promises.push(
436             FreeTextAnnotation.createNewPrintAnnotation(
437               annotationGlobals,
438               xref,
439               annotation,
440               {
441                 evaluator,
442                 task,
443                 evaluatorOptions: options,
444               }
445             )
446           );
447           break;
448         case AnnotationEditorType.HIGHLIGHT:
449           if (annotation.quadPoints) {
450             promises.push(
451               HighlightAnnotation.createNewPrintAnnotation(
452                 annotationGlobals,
453                 xref,
454                 annotation,
455                 {
456                   evaluatorOptions: options,
457                 }
458               )
459             );
460           } else {
461             promises.push(
462               InkAnnotation.createNewPrintAnnotation(
463                 annotationGlobals,
464                 xref,
465                 annotation,
466                 {
467                   evaluatorOptions: options,
468                 }
469               )
470             );
471           }
472           break;
473         case AnnotationEditorType.INK:
474           promises.push(
475             InkAnnotation.createNewPrintAnnotation(
476               annotationGlobals,
477               xref,
478               annotation,
479               {
480                 evaluatorOptions: options,
481               }
482             )
483           );
484           break;
485         case AnnotationEditorType.STAMP:
486           if (!options.isOffscreenCanvasSupported) {
487             break;
488           }
489           const image = await imagePromises.get(annotation.bitmapId);
490           if (image.imageStream) {
491             const { imageStream, smaskStream } = image;
492             if (smaskStream) {
493               imageStream.dict.set("SMask", smaskStream);
494             }
495             image.imageRef = new JpegStream(imageStream, imageStream.length);
496             image.imageStream = image.smaskStream = null;
497           }
498           promises.push(
499             StampAnnotation.createNewPrintAnnotation(
500               annotationGlobals,
501               xref,
502               annotation,
503               {
504                 image,
505                 evaluatorOptions: options,
506               }
507             )
508           );
509           break;
510       }
511     }
512 
513     return Promise.all(promises);
514   }
515 }
516 
517 function getRgbColor(color, defaultColor = new Uint8ClampedArray(3)) {
518   if (!Array.isArray(color)) {
519     return defaultColor;
520   }
521 
522   const rgbColor = defaultColor || new Uint8ClampedArray(3);
523   switch (color.length) {
524     case 0: // Transparent, which we indicate with a null value
525       return null;
526 
527     case 1: // Convert grayscale to RGB
528       ColorSpace.singletons.gray.getRgbItem(color, 0, rgbColor, 0);
529       return rgbColor;
530 
531     case 3: // Convert RGB percentages to RGB
532       ColorSpace.singletons.rgb.getRgbItem(color, 0, rgbColor, 0);
533       return rgbColor;
534 
535     case 4: // Convert CMYK to RGB
536       ColorSpace.singletons.cmyk.getRgbItem(color, 0, rgbColor, 0);
537       return rgbColor;
538 
539     default:
540       return defaultColor;
541   }
542 }
543 
544 function getPdfColorArray(color) {
545   return Array.from(color, c => c / 255);
546 }
547 
548 function getQuadPoints(dict, rect) {
549   // The region is described as a number of quadrilaterals.
550   // Each quadrilateral must consist of eight coordinates.
551   const quadPoints = dict.getArray("QuadPoints");
552   if (
553     !Array.isArray(quadPoints) ||
554     quadPoints.length === 0 ||
555     quadPoints.length % 8 > 0
556   ) {
557     return null;
558   }
559 
560   const quadPointsLists = [];
561   for (let i = 0, ii = quadPoints.length / 8; i < ii; i++) {
562     // Each series of eight numbers represents the coordinates for one
563     // quadrilateral in the order [x1, y1, x2, y2, x3, y3, x4, y4].
564     // Convert this to an array of objects with x and y coordinates.
565     let minX = Infinity,
566       maxX = -Infinity,
567       minY = Infinity,
568       maxY = -Infinity;
569     for (let j = i * 8, jj = i * 8 + 8; j < jj; j += 2) {
570       const x = quadPoints[j];
571       const y = quadPoints[j + 1];
572 
573       minX = Math.min(x, minX);
574       maxX = Math.max(x, maxX);
575       minY = Math.min(y, minY);
576       maxY = Math.max(y, maxY);
577     }
578     // The quadpoints should be ignored if any coordinate in the array
579     // lies outside the region specified by the rectangle. The rectangle
580     // can be `null` for markup annotations since their rectangle may be
581     // incorrect (fixes bug 1538111).
582     if (
583       rect !== null &&
584       (minX < rect[0] || maxX > rect[2] || minY < rect[1] || maxY > rect[3])
585     ) {
586       return null;
587     }
588     // The PDF specification states in section 12.5.6.10 (figure 64) that the
589     // order of the quadpoints should be bottom left, bottom right, top right
590     // and top left. However, in practice PDF files use a different order,
591     // namely bottom left, bottom right, top left and top right (this is also
592     // mentioned on https://github.com/highkite/pdfAnnotate#QuadPoints), so
593     // this is the actual order we should work with. However, the situation is
594     // even worse since Adobe's own applications and other applications violate
595     // the specification and create annotations with other orders, namely top
596     // left, top right, bottom left and bottom right or even top left,
597     // top right, bottom right and bottom left. To avoid inconsistency and
598     // broken rendering, we normalize all lists to put the quadpoints in the
599     // same standard order (see https://stackoverflow.com/a/10729881).
600     quadPointsLists.push([
601       { x: minX, y: maxY },
602       { x: maxX, y: maxY },
603       { x: minX, y: minY },
604       { x: maxX, y: minY },
605     ]);
606   }
607   return quadPointsLists;
608 }
609 
610 function getTransformMatrix(rect, bbox, matrix) {
611   // 12.5.5: Algorithm: Appearance streams
612   const [minX, minY, maxX, maxY] = Util.getAxialAlignedBoundingBox(
613     bbox,
614     matrix
615   );
616   if (minX === maxX || minY === maxY) {
617     // From real-life file, bbox was [0, 0, 0, 0]. In this case,
618     // just apply the transform for rect
619     return [1, 0, 0, 1, rect[0], rect[1]];
620   }
621 
622   const xRatio = (rect[2] - rect[0]) / (maxX - minX);
623   const yRatio = (rect[3] - rect[1]) / (maxY - minY);
624   return [
625     xRatio,
626     0,
627     0,
628     yRatio,
629     rect[0] - minX * xRatio,
630     rect[1] - minY * yRatio,
631   ];
632 }
633 
634 class Annotation {
635   constructor(params) {
636     const { dict, xref, annotationGlobals } = params;
637 
638     this.setTitle(dict.get("T"));
639     this.setContents(dict.get("Contents"));
640     this.setModificationDate(dict.get("M"));
641     this.setFlags(dict.get("F"));
642     this.setRectangle(dict.getArray("Rect"));
643     this.setColor(dict.getArray("C"));
644     this.setBorderStyle(dict);
645     this.setAppearance(dict);
646     this.setOptionalContent(dict);
647 
648     const MK = dict.get("MK");
649     this.setBorderAndBackgroundColors(MK);
650     this.setRotation(MK, dict);
651     this.ref = params.ref instanceof Ref ? params.ref : null;
652 
653     this._streams = [];
654     if (this.appearance) {
655       this._streams.push(this.appearance);
656     }
657 
658     // The annotation cannot be changed (neither its position/visibility nor its
659     // contents), hence we can just display its appearance and don't generate
660     // a HTML element for it.
661     const isLocked = !!(this.flags & AnnotationFlag.LOCKED);
662     const isContentLocked = !!(this.flags & AnnotationFlag.LOCKEDCONTENTS);
663 
664     if (annotationGlobals.structTreeRoot) {
665       let structParent = dict.get("StructParent");
666       structParent =
667         Number.isInteger(structParent) && structParent >= 0 ? structParent : -1;
668 
669       annotationGlobals.structTreeRoot.addAnnotationIdToPage(
670         params.pageRef,
671         structParent
672       );
673     }
674 
675     // Expose public properties using a data object.
676     this.data = {
677       annotationFlags: this.flags,
678       borderStyle: this.borderStyle,
679       color: this.color,
680       backgroundColor: this.backgroundColor,
681       borderColor: this.borderColor,
682       rotation: this.rotation,
683       contentsObj: this._contents,
684       hasAppearance: !!this.appearance,
685       id: params.id,
686       modificationDate: this.modificationDate,
687       rect: this.rectangle,
688       subtype: params.subtype,
689       hasOwnCanvas: false,
690       noRotate: !!(this.flags & AnnotationFlag.NOROTATE),
691       noHTML: isLocked && isContentLocked,
692     };
693 
694     if (params.collectFields) {
695       // Fields can act as container for other fields and have
696       // some actions even if no Annotation inherit from them.
697       // Those fields can be referenced by CO (calculation order).
698       const kids = dict.get("Kids");
699       if (Array.isArray(kids)) {
700         const kidIds = [];
701         for (const kid of kids) {
702           if (kid instanceof Ref) {
703             kidIds.push(kid.toString());
704           }
705         }
706         if (kidIds.length !== 0) {
707           this.data.kidIds = kidIds;
708         }
709       }
710 
711       this.data.actions = collectActions(xref, dict, AnnotationActionEventType);
712       this.data.fieldName = this._constructFieldName(dict);
713       this.data.pageIndex = params.pageIndex;
714     }
715 
716     this._isOffscreenCanvasSupported =
717       params.evaluatorOptions.isOffscreenCanvasSupported;
718     this._fallbackFontDict = null;
719     this._needAppearances = false;
720   }
721 
722   /**
723    * @private
724    */
725   _hasFlag(flags, flag) {
726     return !!(flags & flag);
727   }
728 
729   /**
730    * @private
731    */
732   _isViewable(flags) {
733     return (
734       !this._hasFlag(flags, AnnotationFlag.INVISIBLE) &&
735       !this._hasFlag(flags, AnnotationFlag.NOVIEW)
736     );
737   }
738 
739   /**
740    * @private
741    */
742   _isPrintable(flags) {
743     // In Acrobat, hidden flag cancels the print one
744     // (see annotation_hidden_print.pdf).
745     return (
746       this._hasFlag(flags, AnnotationFlag.PRINT) &&
747       !this._hasFlag(flags, AnnotationFlag.HIDDEN) &&
748       !this._hasFlag(flags, AnnotationFlag.INVISIBLE)
749     );
750   }
751 
752   /**
753    * Check if the annotation must be displayed by taking into account
754    * the value found in the annotationStorage which may have been set
755    * through JS.
756    *
757    * @public
758    * @memberof Annotation
759    * @param {AnnotationStorage} [annotationStorage] - Storage for annotation
760    * @param {boolean} [_renderForms] - if true widgets are rendered thanks to
761    *                                   the annotation layer.
762    */
763   mustBeViewed(annotationStorage, _renderForms) {
764     const noView = annotationStorage?.get(this.data.id)?.noView;
765     if (noView !== undefined) {
766       return !noView;
767     }
768     return this.viewable && !this._hasFlag(this.flags, AnnotationFlag.HIDDEN);
769   }
770 
771   /**
772    * Check if the annotation must be printed by taking into account
773    * the value found in the annotationStorage which may have been set
774    * through JS.
775    *
776    * @public
777    * @memberof Annotation
778    * @param {AnnotationStorage} [annotationStorage] - Storage for annotation
779    */
780   mustBePrinted(annotationStorage) {
781     const noPrint = annotationStorage?.get(this.data.id)?.noPrint;
782     if (noPrint !== undefined) {
783       return !noPrint;
784     }
785     return this.printable;
786   }
787 
788   /**
789    * @type {boolean}
790    */
791   get viewable() {
792     if (this.data.quadPoints === null) {
793       return false;
794     }
795     if (this.flags === 0) {
796       return true;
797     }
798     return this._isViewable(this.flags);
799   }
800 
801   /**
802    * @type {boolean}
803    */
804   get printable() {
805     if (this.data.quadPoints === null) {
806       return false;
807     }
808     if (this.flags === 0) {
809       return false;
810     }
811     return this._isPrintable(this.flags);
812   }
813 
814   /**
815    * @private
816    */
817   _parseStringHelper(data) {
818     const str = typeof data === "string" ? stringToPDFString(data) : "";
819     const dir = str && bidi(str).dir === "rtl" ? "rtl" : "ltr";
820 
821     return { str, dir };
822   }
823 
824   setDefaultAppearance(params) {
825     const { dict, annotationGlobals } = params;
826 
827     const defaultAppearance =
828       getInheritableProperty({ dict, key: "DA" }) ||
829       annotationGlobals.acroForm.get("DA");
830     this._defaultAppearance =
831       typeof defaultAppearance === "string" ? defaultAppearance : "";
832     this.data.defaultAppearanceData = parseDefaultAppearance(
833       this._defaultAppearance
834     );
835   }
836 
837   /**
838    * Set the title.
839    *
840    * @param {string} title - The title of the annotation, used e.g. with
841    *   PopupAnnotations.
842    */
843   setTitle(title) {
844     this._title = this._parseStringHelper(title);
845   }
846 
847   /**
848    * Set the contents.
849    *
850    * @param {string} contents - Text to display for the annotation or, if the
851    *                            type of annotation does not display text, a
852    *                            description of the annotation's contents
853    */
854   setContents(contents) {
855     this._contents = this._parseStringHelper(contents);
856   }
857 
858   /**
859    * Set the modification date.
860    *
861    * @public
862    * @memberof Annotation
863    * @param {string} modificationDate - PDF date string that indicates when the
864    *                                    annotation was last modified
865    */
866   setModificationDate(modificationDate) {
867     this.modificationDate =
868       typeof modificationDate === "string" ? modificationDate : null;
869   }
870 
871   /**
872    * Set the flags.
873    *
874    * @public
875    * @memberof Annotation
876    * @param {number} flags - Unsigned 32-bit integer specifying annotation
877    *                         characteristics
878    * @see {@link shared/util.js}
879    */
880   setFlags(flags) {
881     this.flags = Number.isInteger(flags) && flags > 0 ? flags : 0;
882     if (
883       this.flags & AnnotationFlag.INVISIBLE &&
884       this.constructor.name !== "Annotation"
885     ) {
886       // From the pdf spec v1.7, section 12.5.3 (Annotation Flags):
887       //   If set, do not display the annotation if it does not belong to one of
888       //   the standard annotation types and no annotation handler is available.
889       //
890       // So we can remove the flag in case we have a known annotation type.
891       this.flags ^= AnnotationFlag.INVISIBLE;
892     }
893   }
894 
895   /**
896    * Check if a provided flag is set.
897    *
898    * @public
899    * @memberof Annotation
900    * @param {number} flag - Hexadecimal representation for an annotation
901    *                        characteristic
902    * @returns {boolean}
903    * @see {@link shared/util.js}
904    */
905   hasFlag(flag) {
906     return this._hasFlag(this.flags, flag);
907   }
908 
909   /**
910    * Set the rectangle.
911    *
912    * @public
913    * @memberof Annotation
914    * @param {Array} rectangle - The rectangle array with exactly four entries
915    */
916   setRectangle(rectangle) {
917     this.rectangle =
918       Array.isArray(rectangle) && rectangle.length === 4
919         ? Util.normalizeRect(rectangle)
920         : [0, 0, 0, 0];
921   }
922 
923   /**
924    * Set the color and take care of color space conversion.
925    * The default value is black, in RGB color space.
926    *
927    * @public
928    * @memberof Annotation
929    * @param {Array} color - The color array containing either 0
930    *                        (transparent), 1 (grayscale), 3 (RGB) or
931    *                        4 (CMYK) elements
932    */
933   setColor(color) {
934     this.color = getRgbColor(color);
935   }
936 
937   /**
938    * Set the line endings; should only be used with specific annotation types.
939    * @param {Array} lineEndings - The line endings array.
940    */
941   setLineEndings(lineEndings) {
942     if (typeof PDFJSDev !== "undefined" && PDFJSDev.test("MOZCENTRAL")) {
943       throw new Error("Not implemented: setLineEndings");
944     }
945     this.lineEndings = ["None", "None"]; // The default values.
946 
947     if (Array.isArray(lineEndings) && lineEndings.length === 2) {
948       for (let i = 0; i < 2; i++) {
949         const obj = lineEndings[i];
950 
951         if (obj instanceof Name) {
952           switch (obj.name) {
953             case "None":
954               continue;
955             case "Square":
956             case "Circle":
957             case "Diamond":
958             case "OpenArrow":
959             case "ClosedArrow":
960             case "Butt":
961             case "ROpenArrow":
962             case "RClosedArrow":
963             case "Slash":
964               this.lineEndings[i] = obj.name;
965               continue;
966           }
967         }
968         warn(`Ignoring invalid lineEnding: ${obj}`);
969       }
970     }
971   }
972 
973   setRotation(mk, dict) {
974     this.rotation = 0;
975     let angle = mk instanceof Dict ? mk.get("R") || 0 : dict.get("Rotate") || 0;
976     if (Number.isInteger(angle) && angle !== 0) {
977       angle %= 360;
978       if (angle < 0) {
979         angle += 360;
980       }
981       if (angle % 90 === 0) {
982         this.rotation = angle;
983       }
984     }
985   }
986 
987   /**
988    * Set the color for background and border if any.
989    * The default values are transparent.
990    *
991    * @public
992    * @memberof Annotation
993    * @param {Dict} mk - The MK dictionary
994    */
995   setBorderAndBackgroundColors(mk) {
996     if (mk instanceof Dict) {
997       this.borderColor = getRgbColor(mk.getArray("BC"), null);
998       this.backgroundColor = getRgbColor(mk.getArray("BG"), null);
999     } else {
1000       this.borderColor = this.backgroundColor = null;
1001     }
1002   }
1003 
1004   /**
1005    * Set the border style (as AnnotationBorderStyle object).
1006    *
1007    * @public
1008    * @memberof Annotation
1009    * @param {Dict} borderStyle - The border style dictionary
1010    */
1011   setBorderStyle(borderStyle) {
1012     if (typeof PDFJSDev === "undefined" || PDFJSDev.test("TESTING")) {
1013       assert(this.rectangle, "setRectangle must have been called previously.");
1014     }
1015 
1016     this.borderStyle = new AnnotationBorderStyle();
1017     if (!(borderStyle instanceof Dict)) {
1018       return;
1019     }
1020     if (borderStyle.has("BS")) {
1021       const dict = borderStyle.get("BS");
1022 
1023       if (dict instanceof Dict) {
1024         const dictType = dict.get("Type");
1025 
1026         if (!dictType || isName(dictType, "Border")) {
1027           this.borderStyle.setWidth(dict.get("W"), this.rectangle);
1028           this.borderStyle.setStyle(dict.get("S"));
1029           this.borderStyle.setDashArray(dict.getArray("D"));
1030         }
1031       }
1032     } else if (borderStyle.has("Border")) {
1033       const array = borderStyle.getArray("Border");
1034       if (Array.isArray(array) && array.length >= 3) {
1035         this.borderStyle.setHorizontalCornerRadius(array[0]);
1036         this.borderStyle.setVerticalCornerRadius(array[1]);
1037         this.borderStyle.setWidth(array[2], this.rectangle);
1038 
1039         if (array.length === 4) {
1040           // Dash array available
1041           this.borderStyle.setDashArray(array[3], /* forceStyle = */ true);
1042         }
1043       }
1044     } else {
1045       // There are no border entries in the dictionary. According to the
1046       // specification, we should draw a solid border of width 1 in that
1047       // case, but Adobe Reader did not implement that part of the
1048       // specification and instead draws no border at all, so we do the same.
1049       // See also https://github.com/mozilla/pdf.js/issues/6179.
1050       this.borderStyle.setWidth(0);
1051     }
1052   }
1053 
1054   /**
1055    * Set the (normal) appearance.
1056    *
1057    * @public
1058    * @memberof Annotation
1059    * @param {Dict} dict - The annotation's data dictionary
1060    */
1061   setAppearance(dict) {
1062     this.appearance = null;
1063 
1064     const appearanceStates = dict.get("AP");
1065     if (!(appearanceStates instanceof Dict)) {
1066       return;
1067     }
1068 
1069     // In case the normal appearance is a stream, then it is used directly.
1070     const normalAppearanceState = appearanceStates.get("N");
1071     if (normalAppearanceState instanceof BaseStream) {
1072       this.appearance = normalAppearanceState;
1073       return;
1074     }
1075     if (!(normalAppearanceState instanceof Dict)) {
1076       return;
1077     }
1078 
1079     // In case the normal appearance is a dictionary, the `AS` entry provides
1080     // the key of the stream in this dictionary.
1081     const as = dict.get("AS");
1082     if (!(as instanceof Name) || !normalAppearanceState.has(as.name)) {
1083       return;
1084     }
1085     const appearance = normalAppearanceState.get(as.name);
1086     if (appearance instanceof BaseStream) {
1087       this.appearance = appearance;
1088     }
1089   }
1090 
1091   setOptionalContent(dict) {
1092     this.oc = null;
1093 
1094     const oc = dict.get("OC");
1095     if (oc instanceof Name) {
1096       warn("setOptionalContent: Support for /Name-entry is not implemented.");
1097     } else if (oc instanceof Dict) {
1098       this.oc = oc;
1099     }
1100   }
1101 
1102   loadResources(keys, appearance) {
1103     return appearance.dict.getAsync("Resources").then(resources => {
1104       if (!resources) {
1105         return undefined;
1106       }
1107 
1108       const objectLoader = new ObjectLoader(resources, keys, resources.xref);
1109       return objectLoader.load().then(function () {
1110         return resources;
1111       });
1112     });
1113   }
1114 
1115   async getOperatorList(
1116     evaluator,
1117     task,
1118     intent,
1119     renderForms,
1120     annotationStorage
1121   ) {
1122     const data = this.data;
1123     let appearance = this.appearance;
1124     const isUsingOwnCanvas = !!(
1125       this.data.hasOwnCanvas && intent & RenderingIntentFlag.DISPLAY
1126     );
1127     if (!appearance) {
1128       if (!isUsingOwnCanvas) {
1129         return {
1130           opList: new OperatorList(),
1131           separateForm: false,
1132           separateCanvas: false,
1133         };
1134       }
1135       appearance = new StringStream("");
1136       appearance.dict = new Dict();
1137     }
1138 
1139     const appearanceDict = appearance.dict;
1140     const resources = await this.loadResources(
1141       ["ExtGState", "ColorSpace", "Pattern", "Shading", "XObject", "Font"],
1142       appearance
1143     );
1144     const bbox = appearanceDict.getArray("BBox") || [0, 0, 1, 1];
1145     const matrix = appearanceDict.getArray("Matrix") || [1, 0, 0, 1, 0, 0];
1146     const transform = getTransformMatrix(data.rect, bbox, matrix);
1147 
1148     const opList = new OperatorList();
1149 
1150     let optionalContent;
1151     if (this.oc) {
1152       optionalContent = await evaluator.parseMarkedContentProps(
1153         this.oc,
1154         /* resources = */ null
1155       );
1156     }
1157     if (optionalContent !== undefined) {
1158       opList.addOp(OPS.beginMarkedContentProps, ["OC", optionalContent]);
1159     }
1160 
1161     opList.addOp(OPS.beginAnnotation, [
1162       data.id,
1163       data.rect,
1164       transform,
1165       matrix,
1166       isUsingOwnCanvas,
1167     ]);
1168 
1169     await evaluator.getOperatorList({
1170       stream: appearance,
1171       task,
1172       resources,
1173       operatorList: opList,
1174       fallbackFontDict: this._fallbackFontDict,
1175     });
1176     opList.addOp(OPS.endAnnotation, []);
1177 
1178     if (optionalContent !== undefined) {
1179       opList.addOp(OPS.endMarkedContent, []);
1180     }
1181     this.reset();
1182     return { opList, separateForm: false, separateCanvas: isUsingOwnCanvas };
1183   }
1184 
1185   async save(evaluator, task, annotationStorage) {
1186     return null;
1187   }
1188 
1189   get hasTextContent() {
1190     return false;
1191   }
1192 
1193   async extractTextContent(evaluator, task, viewBox) {
1194     if (!this.appearance) {
1195       return;
1196     }
1197 
1198     const resources = await this.loadResources(
1199       ["ExtGState", "Font", "Properties", "XObject"],
1200       this.appearance
1201     );
1202 
1203     const text = [];
1204     const buffer = [];
1205     let firstPosition = null;
1206     const sink = {
1207       desiredSize: Math.Infinity,
1208       ready: true,
1209 
1210       enqueue(chunk, size) {
1211         for (const item of chunk.items) {
1212           if (item.str === undefined) {
1213             continue;
1214           }
1215           firstPosition ||= item.transform.slice(-2);
1216           buffer.push(item.str);
1217           if (item.hasEOL) {
1218             text.push(buffer.join("").trimEnd());
1219             buffer.length = 0;
1220           }
1221         }
1222       },
1223     };
1224 
1225     await evaluator.getTextContent({
1226       stream: this.appearance,
1227       task,
1228       resources,
1229       includeMarkedContent: true,
1230       keepWhiteSpace: true,
1231       sink,
1232       viewBox,
1233     });
1234     this.reset();
1235 
1236     if (buffer.length) {
1237       text.push(buffer.join("").trimEnd());
1238     }
1239 
1240     if (text.length > 1 || text[0]) {
1241       const appearanceDict = this.appearance.dict;
1242       this.data.textPosition = this._transformPoint(
1243         firstPosition,
1244         appearanceDict.getArray("BBox"),
1245         appearanceDict.getArray("Matrix")
1246       );
1247       this.data.textContent = text;
1248     }
1249   }
1250 
1251   _transformPoint(coords, bbox, matrix) {
1252     const { rect } = this.data;
1253     bbox ||= [0, 0, 1, 1];
1254     matrix ||= [1, 0, 0, 1, 0, 0];
1255     const transform = getTransformMatrix(rect, bbox, matrix);
1256     transform[4] -= rect[0];
1257     transform[5] -= rect[1];
1258     coords = Util.applyTransform(coords, transform);
1259     return Util.applyTransform(coords, matrix);
1260   }
1261 
1262   /**
1263    * Get field data for usage in JS sandbox.
1264    *
1265    * Field object is defined here:
1266    * https://www.adobe.com/content/dam/acom/en/devnet/acrobat/pdfs/js_api_reference.pdf#page=16
1267    *
1268    * @public
1269    * @memberof Annotation
1270    * @returns {Object | null}
1271    */
1272   getFieldObject() {
1273     if (this.data.kidIds) {
1274       return {
1275         id: this.data.id,
1276         actions: this.data.actions,
1277         name: this.data.fieldName,
1278         strokeColor: this.data.borderColor,
1279         fillColor: this.data.backgroundColor,
1280         type: "",
1281         kidIds: this.data.kidIds,
1282         page: this.data.pageIndex,
1283         rotation: this.rotation,
1284       };
1285     }
1286     return null;
1287   }
1288 
1289   /**
1290    * Reset the annotation.
1291    *
1292    * This involves resetting the various streams that are either cached on the
1293    * annotation instance or created during its construction.
1294    *
1295    * @public
1296    * @memberof Annotation
1297    */
1298   reset() {
1299     if (
1300       (typeof PDFJSDev === "undefined" || PDFJSDev.test("TESTING")) &&
1301       this.appearance &&
1302       !this._streams.includes(this.appearance)
1303     ) {
1304       unreachable("The appearance stream should always be reset.");
1305     }
1306 
1307     for (const stream of this._streams) {
1308       stream.reset();
1309     }
1310   }
1311 
1312   /**
1313    * Construct the (fully qualified) field name from the (partial) field
1314    * names of the field and its ancestors.
1315    *
1316    * @private
1317    * @memberof Annotation
1318    * @param {Dict} dict - Complete widget annotation dictionary
1319    * @returns {string}
1320    */
1321   _constructFieldName(dict) {
1322     // Both the `Parent` and `T` fields are optional. While at least one of
1323     // them should be provided, bad PDF generators may fail to do so.
1324     if (!dict.has("T") && !dict.has("Parent")) {
1325       warn("Unknown field name, falling back to empty field name.");
1326       return "";
1327     }
1328 
1329     // If no parent exists, the partial and fully qualified names are equal.
1330     if (!dict.has("Parent")) {
1331       return stringToPDFString(dict.get("T"));
1332     }
1333 
1334     // Form the fully qualified field name by appending the partial name to
1335     // the parent's fully qualified name, separated by a period.
1336     const fieldName = [];
1337     if (dict.has("T")) {
1338       fieldName.unshift(stringToPDFString(dict.get("T")));
1339     }
1340 
1341     let loopDict = dict;
1342     const visited = new RefSet();
1343     if (dict.objId) {
1344       visited.put(dict.objId);
1345     }
1346     while (loopDict.has("Parent")) {
1347       loopDict = loopDict.get("Parent");
1348       if (
1349         !(loopDict instanceof Dict) ||
1350         (loopDict.objId && visited.has(loopDict.objId))
1351       ) {
1352         // Even though it is not allowed according to the PDF specification,
1353         // bad PDF generators may provide a `Parent` entry that is not a
1354         // dictionary, but `null` for example (issue 8143).
1355         //
1356         // If parent has been already visited, it means that we're
1357         // in an infinite loop.
1358         break;
1359       }
1360       if (loopDict.objId) {
1361         visited.put(loopDict.objId);
1362       }
1363 
1364       if (loopDict.has("T")) {
1365         fieldName.unshift(stringToPDFString(loopDict.get("T")));
1366       }
1367     }
1368     return fieldName.join(".");
1369   }
1370 }
1371 
1372 /**
1373  * Contains all data regarding an annotation's border style.
1374  */
1375 class AnnotationBorderStyle {
1376   constructor() {
1377     this.width = 1;
1378     this.style = AnnotationBorderStyleType.SOLID;
1379     this.dashArray = [3];
1380     this.horizontalCornerRadius = 0;
1381     this.verticalCornerRadius = 0;
1382   }
1383 
1384   /**
1385    * Set the width.
1386    *
1387    * @public
1388    * @memberof AnnotationBorderStyle
1389    * @param {number} width - The width.
1390    * @param {Array} rect - The annotation `Rect` entry.
1391    */
1392   setWidth(width, rect = [0, 0, 0, 0]) {
1393     if (typeof PDFJSDev === "undefined" || PDFJSDev.test("TESTING")) {
1394       assert(
1395         Array.isArray(rect) && rect.length === 4,
1396         "A valid `rect` parameter must be provided."
1397       );
1398     }
1399 
1400     // Some corrupt PDF generators may provide the width as a `Name`,
1401     // rather than as a number (fixes issue 10385).
1402     if (width instanceof Name) {
1403       this.width = 0; // This is consistent with the behaviour in Adobe Reader.
1404       return;
1405     }
1406     if (typeof width === "number") {
1407       if (width > 0) {
1408         const maxWidth = (rect[2] - rect[0]) / 2;
1409         const maxHeight = (rect[3] - rect[1]) / 2;
1410 
1411         // Ignore large `width`s, since they lead to the Annotation overflowing
1412         // the size set by the `Rect` entry thus causing the `annotationLayer`
1413         // to render it over the surrounding document (fixes bug1552113.pdf).
1414         if (
1415           maxWidth > 0 &&
1416           maxHeight > 0 &&
1417           (width > maxWidth || width > maxHeight)
1418         ) {
1419           warn(`AnnotationBorderStyle.setWidth - ignoring width: ${width}`);
1420           width = 1;
1421         }
1422       }
1423       this.width = width;
1424     }
1425   }
1426 
1427   /**
1428    * Set the style.
1429    *
1430    * @public
1431    * @memberof AnnotationBorderStyle
1432    * @param {Name} style - The annotation style.
1433    * @see {@link shared/util.js}
1434    */
1435   setStyle(style) {
1436     if (!(style instanceof Name)) {
1437       return;
1438     }
1439     switch (style.name) {
1440       case "S":
1441         this.style = AnnotationBorderStyleType.SOLID;
1442         break;
1443 
1444       case "D":
1445         this.style = AnnotationBorderStyleType.DASHED;
1446         break;
1447 
1448       case "B":
1449         this.style = AnnotationBorderStyleType.BEVELED;
1450         break;
1451 
1452       case "I":
1453         this.style = AnnotationBorderStyleType.INSET;
1454         break;
1455 
1456       case "U":
1457         this.style = AnnotationBorderStyleType.UNDERLINE;
1458         break;
1459 
1460       default:
1461         break;
1462     }
1463   }
1464 
1465   /**
1466    * Set the dash array.
1467    *
1468    * @public
1469    * @memberof AnnotationBorderStyle
1470    * @param {Array} dashArray - The dash array with at least one element
1471    * @param {boolean} [forceStyle]
1472    */
1473   setDashArray(dashArray, forceStyle = false) {
1474     // We validate the dash array, but we do not use it because CSS does not
1475     // allow us to change spacing of dashes. For more information, visit
1476     // http://www.w3.org/TR/css3-background/#the-border-style.
1477     if (Array.isArray(dashArray) && dashArray.length > 0) {
1478       // According to the PDF specification: the elements in `dashArray`
1479       // shall be numbers that are nonnegative and not all equal to zero.
1480       let isValid = true;
1481       let allZeros = true;
1482       for (const element of dashArray) {
1483         const validNumber = +element >= 0;
1484         if (!validNumber) {
1485           isValid = false;
1486           break;
1487         } else if (element > 0) {
1488           allZeros = false;
1489         }
1490       }
1491       if (isValid && !allZeros) {
1492         this.dashArray = dashArray;
1493 
1494         if (forceStyle) {
1495           // Even though we cannot use the dash array in the display layer,
1496           // at least ensure that we use the correct border-style.
1497           this.setStyle(Name.get("D"));
1498         }
1499       } else {
1500         this.width = 0; // Adobe behavior when the array is invalid.
1501       }
1502     } else if (dashArray) {
1503       this.width = 0; // Adobe behavior when the array is invalid.
1504     }
1505   }
1506 
1507   /**
1508    * Set the horizontal corner radius (from a Border dictionary).
1509    *
1510    * @public
1511    * @memberof AnnotationBorderStyle
1512    * @param {number} radius - The horizontal corner radius.
1513    */
1514   setHorizontalCornerRadius(radius) {
1515     if (Number.isInteger(radius)) {
1516       this.horizontalCornerRadius = radius;
1517     }
1518   }
1519 
1520   /**
1521    * Set the vertical corner radius (from a Border dictionary).
1522    *
1523    * @public
1524    * @memberof AnnotationBorderStyle
1525    * @param {number} radius - The vertical corner radius.
1526    */
1527   setVerticalCornerRadius(radius) {
1528     if (Number.isInteger(radius)) {
1529       this.verticalCornerRadius = radius;
1530     }
1531   }
1532 }
1533 
1534 class MarkupAnnotation extends Annotation {
1535   constructor(params) {
1536     super(params);
1537 
1538     const { dict } = params;
1539 
1540     if (dict.has("IRT")) {
1541       const rawIRT = dict.getRaw("IRT");
1542       this.data.inReplyTo = rawIRT instanceof Ref ? rawIRT.toString() : null;
1543 
1544       const rt = dict.get("RT");
1545       this.data.replyType =
1546         rt instanceof Name ? rt.name : AnnotationReplyType.REPLY;
1547     }
1548     let popupRef = null;
1549 
1550     if (this.data.replyType === AnnotationReplyType.GROUP) {
1551       // Subordinate annotations in a group should inherit
1552       // the group attributes from the primary annotation.
1553       const parent = dict.get("IRT");
1554 
1555       this.setTitle(parent.get("T"));
1556       this.data.titleObj = this._title;
1557 
1558       this.setContents(parent.get("Contents"));
1559       this.data.contentsObj = this._contents;
1560 
1561       if (!parent.has("CreationDate")) {
1562         this.data.creationDate = null;
1563       } else {
1564         this.setCreationDate(parent.get("CreationDate"));
1565         this.data.creationDate = this.creationDate;
1566       }
1567 
1568       if (!parent.has("M")) {
1569         this.data.modificationDate = null;
1570       } else {
1571         this.setModificationDate(parent.get("M"));
1572         this.data.modificationDate = this.modificationDate;
1573       }
1574 
1575       popupRef = parent.getRaw("Popup");
1576 
1577       if (!parent.has("C")) {
1578         // Fall back to the default background color.
1579         this.data.color = null;
1580       } else {
1581         this.setColor(parent.getArray("C"));
1582         this.data.color = this.color;
1583       }
1584     } else {
1585       this.data.titleObj = this._title;
1586 
1587       this.setCreationDate(dict.get("CreationDate"));
1588       this.data.creationDate = this.creationDate;
1589 
1590       popupRef = dict.getRaw("Popup");
1591 
1592       if (!dict.has("C")) {
1593         // Fall back to the default background color.
1594         this.data.color = null;
1595       }
1596     }
1597 
1598     this.data.popupRef = popupRef instanceof Ref ? popupRef.toString() : null;
1599 
1600     if (dict.has("RC")) {
1601       this.data.richText = XFAFactory.getRichTextAsHtml(dict.get("RC"));
1602     }
1603   }
1604 
1605   /**
1606    * Set the creation date.
1607    *
1608    * @public
1609    * @memberof MarkupAnnotation
1610    * @param {string} creationDate - PDF date string that indicates when the
1611    *                                annotation was originally created
1612    */
1613   setCreationDate(creationDate) {
1614     this.creationDate = typeof creationDate === "string" ? creationDate : null;
1615   }
1616 
1617   _setDefaultAppearance({
1618     xref,
1619     extra,
1620     strokeColor,
1621     fillColor,
1622     blendMode,
1623     strokeAlpha,
1624     fillAlpha,
1625     pointsCallback,
1626   }) {
1627     let minX = Number.MAX_VALUE;
1628     let minY = Number.MAX_VALUE;
1629     let maxX = Number.MIN_VALUE;
1630     let maxY = Number.MIN_VALUE;
1631 
1632     const buffer = ["q"];
1633     if (extra) {
1634       buffer.push(extra);
1635     }
1636     if (strokeColor) {
1637       buffer.push(`${strokeColor[0]} ${strokeColor[1]} ${strokeColor[2]} RG`);
1638     }
1639     if (fillColor) {
1640       buffer.push(`${fillColor[0]} ${fillColor[1]} ${fillColor[2]} rg`);
1641     }
1642 
1643     let pointsArray = this.data.quadPoints;
1644     if (!pointsArray) {
1645       // If there are no quadpoints, the rectangle should be used instead.
1646       // Convert the rectangle definition to a points array similar to how the
1647       // quadpoints are defined.
1648       pointsArray = [
1649         [
1650           { x: this.rectangle[0], y: this.rectangle[3] },
1651           { x: this.rectangle[2], y: this.rectangle[3] },
1652           { x: this.rectangle[0], y: this.rectangle[1] },
1653           { x: this.rectangle[2], y: this.rectangle[1] },
1654         ],
1655       ];
1656     }
1657 
1658     for (const points of pointsArray) {
1659       const [mX, MX, mY, MY] = pointsCallback(buffer, points);
1660       minX = Math.min(minX, mX);
1661       maxX = Math.max(maxX, MX);
1662       minY = Math.min(minY, mY);
1663       maxY = Math.max(maxY, MY);
1664     }
1665     buffer.push("Q");
1666 
1667     const formDict = new Dict(xref);
1668     const appearanceStreamDict = new Dict(xref);
1669     appearanceStreamDict.set("Subtype", Name.get("Form"));
1670 
1671     const appearanceStream = new StringStream(buffer.join(" "));
1672     appearanceStream.dict = appearanceStreamDict;
1673     formDict.set("Fm0", appearanceStream);
1674 
1675     const gsDict = new Dict(xref);
1676     if (blendMode) {
1677       gsDict.set("BM", Name.get(blendMode));
1678     }
1679     if (typeof strokeAlpha === "number") {
1680       gsDict.set("CA", strokeAlpha);
1681     }
1682     if (typeof fillAlpha === "number") {
1683       gsDict.set("ca", fillAlpha);
1684     }
1685 
1686     const stateDict = new Dict(xref);
1687     stateDict.set("GS0", gsDict);
1688 
1689     const resources = new Dict(xref);
1690     resources.set("ExtGState", stateDict);
1691     resources.set("XObject", formDict);
1692 
1693     const appearanceDict = new Dict(xref);
1694     appearanceDict.set("Resources", resources);
1695     const bbox = (this.data.rect = [minX, minY, maxX, maxY]);
1696     appearanceDict.set("BBox", bbox);
1697 
1698     this.appearance = new StringStream("/GS0 gs /Fm0 Do");
1699     this.appearance.dict = appearanceDict;
1700 
1701     // This method is only called if there is no appearance for the annotation,
1702     // so `this.appearance` is not pushed yet in the `Annotation` constructor.
1703     this._streams.push(this.appearance, appearanceStream);
1704   }
1705 
1706   static async createNewAnnotation(xref, annotation, dependencies, params) {
1707     const annotationRef = (annotation.ref ||= xref.getNewTemporaryRef());
1708     const ap = await this.createNewAppearanceStream(annotation, xref, params);
1709     const buffer = [];
1710     let annotationDict;
1711 
1712     if (ap) {
1713       const apRef = xref.getNewTemporaryRef();
1714       annotationDict = this.createNewDict(annotation, xref, { apRef });
1715       await writeObject(apRef, ap, buffer, xref);
1716       dependencies.push({ ref: apRef, data: buffer.join("") });
1717     } else {
1718       annotationDict = this.createNewDict(annotation, xref, {});
1719     }
1720     if (Number.isInteger(annotation.parentTreeId)) {
1721       annotationDict.set("StructParent", annotation.parentTreeId);
1722     }
1723 
1724     buffer.length = 0;
1725     await writeObject(annotationRef, annotationDict, buffer, xref);
1726 
1727     return { ref: annotationRef, data: buffer.join("") };
1728   }
1729 
1730   static async createNewPrintAnnotation(
1731     annotationGlobals,
1732     xref,
1733     annotation,
1734     params
1735   ) {
1736     const ap = await this.createNewAppearanceStream(annotation, xref, params);
1737     const annotationDict = this.createNewDict(annotation, xref, { ap });
1738 
1739     const newAnnotation = new this.prototype.constructor({
1740       dict: annotationDict,
1741       xref,
1742       annotationGlobals,
1743       evaluatorOptions: params.evaluatorOptions,
1744     });
1745 
1746     if (annotation.ref) {
1747       newAnnotation.ref = newAnnotation.refToReplace = annotation.ref;
1748     }
1749 
1750     return newAnnotation;
1751   }
1752 }
1753 
1754 class WidgetAnnotation extends Annotation {
1755   constructor(params) {
1756     super(params);
1757 
1758     const { dict, xref, annotationGlobals } = params;
1759     const data = this.data;
1760     this._needAppearances = params.needAppearances;
1761 
1762     data.annotationType = AnnotationType.WIDGET;
1763     if (data.fieldName === undefined) {
1764       data.fieldName = this._constructFieldName(dict);
1765     }
1766 
1767     if (data.actions === undefined) {
1768       data.actions = collectActions(xref, dict, AnnotationActionEventType);
1769     }
1770 
1771     let fieldValue = getInheritableProperty({
1772       dict,
1773       key: "V",
1774       getArray: true,
1775     });
1776     data.fieldValue = this._decodeFormValue(fieldValue);
1777 
1778     const defaultFieldValue = getInheritableProperty({
1779       dict,
1780       key: "DV",
1781       getArray: true,
1782     });
1783     data.defaultFieldValue = this._decodeFormValue(defaultFieldValue);
1784 
1785     if (fieldValue === undefined && annotationGlobals.xfaDatasets) {
1786       // Try to figure out if we have something in the xfa dataset.
1787       const path = this._title.str;
1788       if (path) {
1789         this._hasValueFromXFA = true;
1790         data.fieldValue = fieldValue =
1791           annotationGlobals.xfaDatasets.getValue(path);
1792       }
1793     }
1794 
1795     // When no "V" entry exists, let the fieldValue fallback to the "DV" entry
1796     // (fixes issue13823.pdf).
1797     if (fieldValue === undefined && data.defaultFieldValue !== null) {
1798       data.fieldValue = data.defaultFieldValue;
1799     }
1800 
1801     data.alternativeText = stringToPDFString(dict.get("TU") || "");
1802 
1803     this.setDefaultAppearance(params);
1804 
1805     data.hasAppearance ||=
1806       this._needAppearances &&
1807       data.fieldValue !== undefined &&
1808       data.fieldValue !== null;
1809 
1810     const fieldType = getInheritableProperty({ dict, key: "FT" });
1811     data.fieldType = fieldType instanceof Name ? fieldType.name : null;
1812 
1813     const localResources = getInheritableProperty({ dict, key: "DR" });
1814     const acroFormResources = annotationGlobals.acroForm.get("DR");
1815     const appearanceResources = this.appearance?.dict.get("Resources");
1816 
1817     this._fieldResources = {
1818       localResources,
1819       acroFormResources,
1820       appearanceResources,
1821       mergedResources: Dict.merge({
1822         xref,
1823         dictArray: [localResources, appearanceResources, acroFormResources],
1824         mergeSubDicts: true,
1825       }),
1826     };
1827 
1828     data.fieldFlags = getInheritableProperty({ dict, key: "Ff" });
1829     if (!Number.isInteger(data.fieldFlags) || data.fieldFlags < 0) {
1830       data.fieldFlags = 0;
1831     }
1832 
1833     data.readOnly = this.hasFieldFlag(AnnotationFieldFlag.READONLY);
1834     data.required = this.hasFieldFlag(AnnotationFieldFlag.REQUIRED);
1835     data.hidden =
1836       this._hasFlag(data.annotationFlags, AnnotationFlag.HIDDEN) ||
1837       this._hasFlag(data.annotationFlags, AnnotationFlag.NOVIEW);
1838   }
1839 
1840   /**
1841    * Decode the given form value.
1842    *
1843    * @private
1844    * @memberof WidgetAnnotation
1845    * @param {Array<string>|Name|string} formValue - The (possibly encoded)
1846    *   form value.
1847    * @returns {Array<string>|string|null}
1848    */
1849   _decodeFormValue(formValue) {
1850     if (Array.isArray(formValue)) {
1851       return formValue
1852         .filter(item => typeof item === "string")
1853         .map(item => stringToPDFString(item));
1854     } else if (formValue instanceof Name) {
1855       return stringToPDFString(formValue.name);
1856     } else if (typeof formValue === "string") {
1857       return stringToPDFString(formValue);
1858     }
1859     return null;
1860   }
1861 
1862   /**
1863    * Check if a provided field flag is set.
1864    *
1865    * @public
1866    * @memberof WidgetAnnotation
1867    * @param {number} flag - Hexadecimal representation for an annotation
1868    *                        field characteristic
1869    * @returns {boolean}
1870    * @see {@link shared/util.js}
1871    */
1872   hasFieldFlag(flag) {
1873     return !!(this.data.fieldFlags & flag);
1874   }
1875 
1876   /** @inheritdoc */
1877   _isViewable(flags) {
1878     // We don't take into account the `NOVIEW` or `HIDDEN` flags here,
1879     // since the visibility can be changed by js code, hence in case
1880     // it's made viewable, we should render it (with visibility set to
1881     // hidden).
1882     // We don't take into account the `INVISIBLE` flag here, since we've a known
1883     // annotation type.
1884     return true;
1885   }
1886 
1887   /** @inheritdoc */
1888   mustBeViewed(annotationStorage, renderForms) {
1889     if (renderForms) {
1890       return this.viewable;
1891     }
1892     return (
1893       super.mustBeViewed(annotationStorage, renderForms) &&
1894       !this._hasFlag(this.flags, AnnotationFlag.NOVIEW)
1895     );
1896   }
1897 
1898   getRotationMatrix(annotationStorage) {
1899     let rotation = annotationStorage?.get(this.data.id)?.rotation;
1900     if (rotation === undefined) {
1901       rotation = this.rotation;
1902     }
1903 
1904     if (rotation === 0) {
1905       return IDENTITY_MATRIX;
1906     }
1907 
1908     const width = this.data.rect[2] - this.data.rect[0];
1909     const height = this.data.rect[3] - this.data.rect[1];
1910 
1911     return getRotationMatrix(rotation, width, height);
1912   }
1913 
1914   getBorderAndBackgroundAppearances(annotationStorage) {
1915     let rotation = annotationStorage?.get(this.data.id)?.rotation;
1916     if (rotation === undefined) {
1917       rotation = this.rotation;
1918     }
1919 
1920     if (!this.backgroundColor && !this.borderColor) {
1921       return "";
1922     }
1923     const width = this.data.rect[2] - this.data.rect[0];
1924     const height = this.data.rect[3] - this.data.rect[1];
1925     const rect =
1926       rotation === 0 || rotation === 180
1927         ? `0 0 ${width} ${height} re`
1928         : `0 0 ${height} ${width} re`;
1929 
1930     let str = "";
1931     if (this.backgroundColor) {
1932       str = `${getPdfColor(
1933         this.backgroundColor,
1934         /* isFill */ true
1935       )} ${rect} f `;
1936     }
1937 
1938     if (this.borderColor) {
1939       const borderWidth = this.borderStyle.width || 1;
1940       str += `${borderWidth} w ${getPdfColor(
1941         this.borderColor,
1942         /* isFill */ false
1943       )} ${rect} S `;
1944     }
1945 
1946     return str;
1947   }
1948 
1949   async getOperatorList(
1950     evaluator,
1951     task,
1952     intent,
1953     renderForms,
1954     annotationStorage
1955   ) {
1956     // Do not render form elements on the canvas when interactive forms are
1957     // enabled. The display layer is responsible for rendering them instead.
1958     if (
1959       renderForms &&
1960       !(this instanceof SignatureWidgetAnnotation) &&
1961       !this.data.noHTML &&
1962       !this.data.hasOwnCanvas
1963     ) {
1964       return {
1965         opList: new OperatorList(),
1966         separateForm: true,
1967         separateCanvas: false,
1968       };
1969     }
1970 
1971     if (!this._hasText) {
1972       return super.getOperatorList(
1973         evaluator,
1974         task,
1975         intent,
1976         renderForms,
1977         annotationStorage
1978       );
1979     }
1980 
1981     const content = await this._getAppearance(
1982       evaluator,
1983       task,
1984       intent,
1985       annotationStorage
1986     );
1987     if (this.appearance && content === null) {
1988       return super.getOperatorList(
1989         evaluator,
1990         task,
1991         intent,
1992         renderForms,
1993         annotationStorage
1994       );
1995     }
1996 
1997     const opList = new OperatorList();
1998 
1999     // Even if there is an appearance stream, ignore it. This is the
2000     // behaviour used by Adobe Reader.
2001     if (!this._defaultAppearance || content === null) {
2002       return { opList, separateForm: false, separateCanvas: false };
2003     }
2004 
2005     const isUsingOwnCanvas = !!(
2006       this.data.hasOwnCanvas && intent & RenderingIntentFlag.DISPLAY
2007     );
2008 
2009     const matrix = [1, 0, 0, 1, 0, 0];
2010     const bbox = [
2011       0,
2012       0,
2013       this.data.rect[2] - this.data.rect[0],
2014       this.data.rect[3] - this.data.rect[1],
2015     ];
2016     const transform = getTransformMatrix(this.data.rect, bbox, matrix);
2017 
2018     let optionalContent;
2019     if (this.oc) {
2020       optionalContent = await evaluator.parseMarkedContentProps(
2021         this.oc,
2022         /* resources = */ null
2023       );
2024     }
2025     if (optionalContent !== undefined) {
2026       opList.addOp(OPS.beginMarkedContentProps, ["OC", optionalContent]);
2027     }
2028 
2029     opList.addOp(OPS.beginAnnotation, [
2030       this.data.id,
2031       this.data.rect,
2032       transform,
2033       this.getRotationMatrix(annotationStorage),
2034       isUsingOwnCanvas,
2035     ]);
2036 
2037     const stream = new StringStream(content);
2038     await evaluator.getOperatorList({
2039       stream,
2040       task,
2041       resources: this._fieldResources.mergedResources,
2042       operatorList: opList,
2043     });
2044     opList.addOp(OPS.endAnnotation, []);
2045 
2046     if (optionalContent !== undefined) {
2047       opList.addOp(OPS.endMarkedContent, []);
2048     }
2049     return { opList, separateForm: false, separateCanvas: isUsingOwnCanvas };
2050   }
2051 
2052   _getMKDict(rotation) {
2053     const mk = new Dict(null);
2054     if (rotation) {
2055       mk.set("R", rotation);
2056     }
2057     if (this.borderColor) {
2058       mk.set("BC", getPdfColorArray(this.borderColor));
2059     }
2060     if (this.backgroundColor) {
2061       mk.set("BG", getPdfColorArray(this.backgroundColor));
2062     }
2063     return mk.size > 0 ? mk : null;
2064   }
2065 
2066   amendSavedDict(annotationStorage, dict) {}
2067 
2068   async save(evaluator, task, annotationStorage) {
2069     const storageEntry = annotationStorage?.get(this.data.id);
2070     let value = storageEntry?.value,
2071       rotation = storageEntry?.rotation;
2072     if (value === this.data.fieldValue || value === undefined) {
2073       if (!this._hasValueFromXFA && rotation === undefined) {
2074         return null;
2075       }
2076       value ||= this.data.fieldValue;
2077     }
2078 
2079     // Value can be an array (with choice list and multiple selections)
2080     if (
2081       rotation === undefined &&
2082       !this._hasValueFromXFA &&
2083       Array.isArray(value) &&
2084       Array.isArray(this.data.fieldValue) &&
2085       value.length === this.data.fieldValue.length &&
2086       value.every((x, i) => x === this.data.fieldValue[i])
2087     ) {
2088       return null;
2089     }
2090 
2091     if (rotation === undefined) {
2092       rotation = this.rotation;
2093     }
2094 
2095     let appearance = null;
2096     if (!this._needAppearances) {
2097       appearance = await this._getAppearance(
2098         evaluator,
2099         task,
2100         RenderingIntentFlag.SAVE,
2101         annotationStorage
2102       );
2103       if (appearance === null) {
2104         // Appearance didn't change.
2105         return null;
2106       }
2107     } else {
2108       // No need to create an appearance: the pdf has the flag /NeedAppearances
2109       // which means that it's up to the reader to produce an appearance.
2110     }
2111 
2112     let needAppearances = false;
2113     if (appearance?.needAppearances) {
2114       needAppearances = true;
2115       appearance = null;
2116     }
2117 
2118     const { xref } = evaluator;
2119 
2120     const originalDict = xref.fetchIfRef(this.ref);
2121     if (!(originalDict instanceof Dict)) {
2122       return null;
2123     }
2124 
2125     const dict = new Dict(xref);
2126     for (const key of originalDict.getKeys()) {
2127       if (key !== "AP") {
2128         dict.set(key, originalDict.getRaw(key));
2129       }
2130     }
2131 
2132     const xfa = {
2133       path: this.data.fieldName,
2134       value,
2135     };
2136 
2137     const encoder = val =>
2138       isAscii(val) ? val : stringToUTF16String(val, /* bigEndian = */ true);
2139     dict.set("V", Array.isArray(value) ? value.map(encoder) : encoder(value));
2140     this.amendSavedDict(annotationStorage, dict);
2141 
2142     const maybeMK = this._getMKDict(rotation);
2143     if (maybeMK) {
2144       dict.set("MK", maybeMK);
2145     }
2146 
2147     const buffer = [];
2148     const changes = [
2149       // data for the original object
2150       // V field changed + reference for new AP
2151       { ref: this.ref, data: "", xfa, needAppearances },
2152     ];
2153     if (appearance !== null) {
2154       const newRef = xref.getNewTemporaryRef();
2155       const AP = new Dict(xref);
2156       dict.set("AP", AP);
2157       AP.set("N", newRef);
2158 
2159       const resources = this._getSaveFieldResources(xref);
2160       const appearanceStream = new StringStream(appearance);
2161       const appearanceDict = (appearanceStream.dict = new Dict(xref));
2162       appearanceDict.set("Subtype", Name.get("Form"));
2163       appearanceDict.set("Resources", resources);
2164       appearanceDict.set("BBox", [
2165         0,
2166         0,
2167         this.data.rect[2] - this.data.rect[0],
2168         this.data.rect[3] - this.data.rect[1],
2169       ]);
2170 
2171       const rotationMatrix = this.getRotationMatrix(annotationStorage);
2172       if (rotationMatrix !== IDENTITY_MATRIX) {
2173         // The matrix isn't the identity one.
2174         appearanceDict.set("Matrix", rotationMatrix);
2175       }
2176 
2177       await writeObject(newRef, appearanceStream, buffer, xref);
2178 
2179       changes.push(
2180         // data for the new AP
2181         {
2182           ref: newRef,
2183           data: buffer.join(""),
2184           xfa: null,
2185           needAppearances: false,
2186         }
2187       );
2188       buffer.length = 0;
2189     }
2190 
2191     dict.set("M", `D:${getModificationDate()}`);
2192     await writeObject(this.ref, dict, buffer, xref);
2193 
2194     changes[0].data = buffer.join("");
2195 
2196     return changes;
2197   }
2198 
2199   async _getAppearance(evaluator, task, intent, annotationStorage) {
2200     const isPassword = this.hasFieldFlag(AnnotationFieldFlag.PASSWORD);
2201     if (isPassword) {
2202       return null;
2203     }
2204     const storageEntry = annotationStorage?.get(this.data.id);
2205     let value, rotation;
2206     if (storageEntry) {
2207       value = storageEntry.formattedValue || storageEntry.value;
2208       rotation = storageEntry.rotation;
2209     }
2210 
2211     if (
2212       rotation === undefined &&
2213       value === undefined &&
2214       !this._needAppearances
2215     ) {
2216       if (!this._hasValueFromXFA || this.appearance) {
2217         // The annotation hasn't been rendered so use the appearance.
2218         return null;
2219       }
2220     }
2221 
2222     // Empty or it has a trailing whitespace.
2223     const colors = this.getBorderAndBackgroundAppearances(annotationStorage);
2224 
2225     if (value === undefined) {
2226       // The annotation has its value in XFA datasets but not in the V field.
2227       value = this.data.fieldValue;
2228       if (!value) {
2229         return `/Tx BMC q ${colors}Q EMC`;
2230       }
2231     }
2232 
2233     if (Array.isArray(value) && value.length === 1) {
2234       value = value[0];
2235     }
2236 
2237     assert(typeof value === "string", "Expected `value` to be a string.");
2238     value = value.trim();
2239 
2240     if (this.data.combo) {
2241       // The value can be one of the exportValue or any other values.
2242       const option = this.data.options.find(
2243         ({ exportValue }) => value === exportValue
2244       );
2245       value = option?.displayValue || value;
2246     }
2247 
2248     if (value === "") {
2249       // the field is empty: nothing to render
2250       return `/Tx BMC q ${colors}Q EMC`;
2251     }
2252 
2253     if (rotation === undefined) {
2254       rotation = this.rotation;
2255     }
2256 
2257     let lineCount = -1;
2258     let lines;
2259 
2260     // We could have a text containing for example some sequences of chars and
2261     // their diacritics (e.g. "é".normalize("NFKD") shows 1 char when it's 2).
2262     // Positioning diacritics is really something we don't want to do here.
2263     // So if a font has a glyph for a acute accent and one for "e" then we won't
2264     // get any encoding issues but we'll render "e" and then "´".
2265     // It's why we normalize the string. We use NFC to preserve the initial
2266     // string, (e.g. "²".normalize("NFC") === "²"
2267     // but "²".normalize("NFKC") === "2").
2268     //
2269     // TODO: it isn't a perfect solution, some chars like "ẹ́" will be
2270     // decomposed into two chars ("ẹ" and "´"), so we should detect such
2271     // situations and then use either FakeUnicodeFont or set the
2272     // /NeedAppearances flag.
2273     if (this.data.multiLine) {
2274       lines = value.split(/\r\n?|\n/).map(line => line.normalize("NFC"));
2275       lineCount = lines.length;
2276     } else {
2277       lines = [value.replace(/\r\n?|\n/, "").normalize("NFC")];
2278     }
2279 
2280     const defaultPadding = 1;
2281     const defaultHPadding = 2;
2282     let totalHeight = this.data.rect[3] - this.data.rect[1];
2283     let totalWidth = this.data.rect[2] - this.data.rect[0];
2284 
2285     if (rotation === 90 || rotation === 270) {
2286       [totalWidth, totalHeight] = [totalHeight, totalWidth];
2287     }
2288 
2289     if (!this._defaultAppearance) {
2290       // The DA is required and must be a string.
2291       // If there is no font named Helvetica in the resource dictionary,
2292       // the evaluator will fall back to a default font.
2293       // Doing so prevents exceptions and allows saving/printing
2294       // the file as expected.
2295       this.data.defaultAppearanceData = parseDefaultAppearance(
2296         (this._defaultAppearance = "/Helvetica 0 Tf 0 g")
2297       );
2298     }
2299 
2300     let font = await WidgetAnnotation._getFontData(
2301       evaluator,
2302       task,
2303       this.data.defaultAppearanceData,
2304       this._fieldResources.mergedResources
2305     );
2306 
2307     let defaultAppearance, fontSize, lineHeight;
2308     const encodedLines = [];
2309     let encodingError = false;
2310     for (const line of lines) {
2311       const encodedString = font.encodeString(line);
2312       if (encodedString.length > 1) {
2313         encodingError = true;
2314       }
2315       encodedLines.push(encodedString.join(""));
2316     }
2317 
2318     if (encodingError && intent & RenderingIntentFlag.SAVE) {
2319       // We don't have a way to render the field, so we just rely on the
2320       // /NeedAppearances trick to let the different sofware correctly render
2321       // this pdf.
2322       return { needAppearances: true };
2323     }
2324 
2325     // We check that the font is able to encode the string.
2326     if (encodingError && this._isOffscreenCanvasSupported) {
2327       // If it can't then we fallback on fake unicode font (mapped to sans-serif
2328       // for the rendering).
2329       // It means that a printed form can be rendered differently (it depends on
2330       // the sans-serif font) but at least we've something to render.
2331       // In an ideal world the associated font should correctly handle the
2332       // possible chars but a user can add a smiley or whatever.
2333       // We could try to embed a font but it means that we must have access
2334       // to the raw font file.
2335       const fontFamily = this.data.comb ? "monospace" : "sans-serif";
2336       const fakeUnicodeFont = new FakeUnicodeFont(evaluator.xref, fontFamily);
2337       const resources = fakeUnicodeFont.createFontResources(lines.join(""));
2338       const newFont = resources.getRaw("Font");
2339 
2340       if (this._fieldResources.mergedResources.has("Font")) {
2341         const oldFont = this._fieldResources.mergedResources.get("Font");
2342         for (const key of newFont.getKeys()) {
2343           oldFont.set(key, newFont.getRaw(key));
2344         }
2345       } else {
2346         this._fieldResources.mergedResources.set("Font", newFont);
2347       }
2348 
2349       const fontName = fakeUnicodeFont.fontName.name;
2350       font = await WidgetAnnotation._getFontData(
2351         evaluator,
2352         task,
2353         { fontName, fontSize: 0 },
2354         resources
2355       );
2356 
2357       for (let i = 0, ii = encodedLines.length; i < ii; i++) {
2358         encodedLines[i] = stringToUTF16String(lines[i]);
2359       }
2360 
2361       const savedDefaultAppearance = Object.assign(
2362         Object.create(null),
2363         this.data.defaultAppearanceData
2364       );
2365       this.data.defaultAppearanceData.fontSize = 0;
2366       this.data.defaultAppearanceData.fontName = fontName;
2367 
2368       [defaultAppearance, fontSize, lineHeight] = this._computeFontSize(
2369         totalHeight - 2 * defaultPadding,
2370         totalWidth - 2 * defaultHPadding,
2371         value,
2372         font,
2373         lineCount
2374       );
2375 
2376       this.data.defaultAppearanceData = savedDefaultAppearance;
2377     } else {
2378       if (!this._isOffscreenCanvasSupported) {
2379         warn(
2380           "_getAppearance: OffscreenCanvas is not supported, annotation may not render correctly."
2381         );
2382       }
2383 
2384       [defaultAppearance, fontSize, lineHeight] = this._computeFontSize(
2385         totalHeight - 2 * defaultPadding,
2386         totalWidth - 2 * defaultHPadding,
2387         value,
2388         font,
2389         lineCount
2390       );
2391     }
2392 
2393     let descent = font.descent;
2394     if (isNaN(descent)) {
2395       descent = BASELINE_FACTOR * lineHeight;
2396     } else {
2397       descent = Math.max(
2398         BASELINE_FACTOR * lineHeight,
2399         Math.abs(descent) * fontSize
2400       );
2401     }
2402 
2403     // Take into account the space we have to compute the default vertical
2404     // padding.
2405     const defaultVPadding = Math.min(
2406       Math.floor((totalHeight - fontSize) / 2),
2407       defaultPadding
2408     );
2409     const alignment = this.data.textAlignment;
2410 
2411     if (this.data.multiLine) {
2412       return this._getMultilineAppearance(
2413         defaultAppearance,
2414         encodedLines,
2415         font,
2416         fontSize,
2417         totalWidth,
2418         totalHeight,
2419         alignment,
2420         defaultHPadding,
2421         defaultVPadding,
2422         descent,
2423         lineHeight,
2424         annotationStorage
2425       );
2426     }
2427 
2428     if (this.data.comb) {
2429       return this._getCombAppearance(
2430         defaultAppearance,
2431         font,
2432         encodedLines[0],
2433         fontSize,
2434         totalWidth,
2435         totalHeight,
2436         defaultHPadding,
2437         defaultVPadding,
2438         descent,
2439         lineHeight,
2440         annotationStorage
2441       );
2442     }
2443 
2444     const bottomPadding = defaultVPadding + descent;
2445     if (alignment === 0 || alignment > 2) {
2446       // Left alignment: nothing to do
2447       return (
2448         `/Tx BMC q ${colors}BT ` +
2449         defaultAppearance +
2450         ` 1 0 0 1 ${numberToString(defaultHPadding)} ${numberToString(
2451           bottomPadding
2452         )} Tm (${escapeString(encodedLines[0])}) Tj` +
2453         " ET Q EMC"
2454       );
2455     }
2456 
2457     const prevInfo = { shift: 0 };
2458     const renderedText = this._renderText(
2459       encodedLines[0],
2460       font,
2461       fontSize,
2462       totalWidth,
2463       alignment,
2464       prevInfo,
2465       defaultHPadding,
2466       bottomPadding
2467     );
2468     return (
2469       `/Tx BMC q ${colors}BT ` +
2470       defaultAppearance +
2471       ` 1 0 0 1 0 0 Tm ${renderedText}` +
2472       " ET Q EMC"
2473     );
2474   }
2475 
2476   static async _getFontData(evaluator, task, appearanceData, resources) {
2477     const operatorList = new OperatorList();
2478     const initialState = {
2479       font: null,
2480       clone() {
2481         return this;
2482       },
2483     };
2484 
2485     const { fontName, fontSize } = appearanceData;
2486     await evaluator.handleSetFont(
2487       resources,
2488       [fontName && Name.get(fontName), fontSize],
2489       /* fontRef = */ null,
2490       operatorList,
2491       task,
2492       initialState,
2493       /* fallbackFontDict = */ null
2494     );
2495 
2496     return initialState.font;
2497   }
2498 
2499   _getTextWidth(text, font) {
2500     return (
2501       font
2502         .charsToGlyphs(text)
2503         .reduce((width, glyph) => width + glyph.width, 0) / 1000
2504     );
2505   }
2506 
2507   _computeFontSize(height, width, text, font, lineCount) {
2508     let { fontSize } = this.data.defaultAppearanceData;
2509     let lineHeight = (fontSize || 12) * LINE_FACTOR,
2510       numberOfLines = Math.round(height / lineHeight);
2511 
2512     if (!fontSize) {
2513       // A zero value for size means that the font shall be auto-sized:
2514       // its size shall be computed as a function of the height of the
2515       // annotation rectangle (see 12.7.3.3).
2516 
2517       const roundWithTwoDigits = x => Math.floor(x * 100) / 100;
2518 
2519       if (lineCount === -1) {
2520         const textWidth = this._getTextWidth(text, font);
2521         fontSize = roundWithTwoDigits(
2522           Math.min(
2523             height / LINE_FACTOR,
2524             textWidth > width ? width / textWidth : Infinity
2525           )
2526         );
2527         numberOfLines = 1;
2528       } else {
2529         const lines = text.split(/\r\n?|\n/);
2530         const cachedLines = [];
2531         for (const line of lines) {
2532           const encoded = font.encodeString(line).join("");
2533           const glyphs = font.charsToGlyphs(encoded);
2534           const positions = font.getCharPositions(encoded);
2535           cachedLines.push({
2536             line: encoded,
2537             glyphs,
2538             positions,
2539           });
2540         }
2541 
2542         const isTooBig = fsize => {
2543           // Return true when the text doesn't fit the given height.
2544           let totalHeight = 0;
2545           for (const cache of cachedLines) {
2546             const chunks = this._splitLine(null, font, fsize, width, cache);
2547             totalHeight += chunks.length * fsize;
2548             if (totalHeight > height) {
2549               return true;
2550             }
2551           }
2552           return false;
2553         };
2554 
2555         // Hard to guess how many lines there are.
2556         // The field may have been sized to have 10 lines
2557         // and the user entered only 1 so if we get font size from
2558         // height and number of lines then we'll get something too big.
2559         // So we compute a fake number of lines based on height and
2560         // a font size equal to 12 (this is the default font size in
2561         // Acrobat).
2562         // Then we'll adjust font size to what we have really.
2563         numberOfLines = Math.max(numberOfLines, lineCount);
2564 
2565         while (true) {
2566           lineHeight = height / numberOfLines;
2567           fontSize = roundWithTwoDigits(lineHeight / LINE_FACTOR);
2568 
2569           if (isTooBig(fontSize)) {
2570             numberOfLines++;
2571             continue;
2572           }
2573 
2574           break;
2575         }
2576       }
2577 
2578       const { fontName, fontColor } = this.data.defaultAppearanceData;
2579       this._defaultAppearance = createDefaultAppearance({
2580         fontSize,
2581         fontName,
2582         fontColor,
2583       });
2584     }
2585 
2586     return [this._defaultAppearance, fontSize, height / numberOfLines];
2587   }
2588 
2589   _renderText(
2590     text,
2591     font,
2592     fontSize,
2593     totalWidth,
2594     alignment,
2595     prevInfo,
2596     hPadding,
2597     vPadding
2598   ) {
2599     // TODO: we need to take into account (if possible) how the text
2600     // is rendered. For example in arabic, the cumulated width of some
2601     // glyphs isn't equal to the width of the rendered glyphs because
2602     // of ligatures.
2603     let shift;
2604     if (alignment === 1) {
2605       // Center
2606       const width = this._getTextWidth(text, font) * fontSize;
2607       shift = (totalWidth - width) / 2;
2608     } else if (alignment === 2) {
2609       // Right
2610       const width = this._getTextWidth(text, font) * fontSize;
2611       shift = totalWidth - width - hPadding;
2612     } else {
2613       shift = hPadding;
2614     }
2615     const shiftStr = numberToString(shift - prevInfo.shift);
2616     prevInfo.shift = shift;
2617     vPadding = numberToString(vPadding);
2618 
2619     return `${shiftStr} ${vPadding} Td (${escapeString(text)}) Tj`;
2620   }
2621 
2622   /**
2623    * @private
2624    */
2625   _getSaveFieldResources(xref) {
2626     if (typeof PDFJSDev === "undefined" || PDFJSDev.test("TESTING")) {
2627       assert(
2628         this.data.defaultAppearanceData,
2629         "Expected `_defaultAppearanceData` to have been set."
2630       );
2631     }
2632     const { localResources, appearanceResources, acroFormResources } =
2633       this._fieldResources;
2634 
2635     const fontName = this.data.defaultAppearanceData?.fontName;
2636     if (!fontName) {
2637       return localResources || Dict.empty;
2638     }
2639 
2640     for (const resources of [localResources, appearanceResources]) {
2641       if (resources instanceof Dict) {
2642         const localFont = resources.get("Font");
2643         if (localFont instanceof Dict && localFont.has(fontName)) {
2644           return resources;
2645         }
2646       }
2647     }
2648     if (acroFormResources instanceof Dict) {
2649       const acroFormFont = acroFormResources.get("Font");
2650       if (acroFormFont instanceof Dict && acroFormFont.has(fontName)) {
2651         const subFontDict = new Dict(xref);
2652         subFontDict.set(fontName, acroFormFont.getRaw(fontName));
2653 
2654         const subResourcesDict = new Dict(xref);
2655         subResourcesDict.set("Font", subFontDict);
2656 
2657         return Dict.merge({
2658           xref,
2659           dictArray: [subResourcesDict, localResources],
2660           mergeSubDicts: true,
2661         });
2662       }
2663     }
2664     return localResources || Dict.empty;
2665   }
2666 
2667   getFieldObject() {
2668     return null;
2669   }
2670 }
2671 
2672 class TextWidgetAnnotation extends WidgetAnnotation {
2673   constructor(params) {
2674     super(params);
2675 
2676     this.data.hasOwnCanvas = this.data.readOnly && !this.data.noHTML;
2677     this._hasText = true;
2678 
2679     const dict = params.dict;
2680 
2681     // The field value is always a string.
2682     if (typeof this.data.fieldValue !== "string") {
2683       this.data.fieldValue = "";
2684     }
2685 
2686     // Determine the alignment of text in the field.
2687     let alignment = getInheritableProperty({ dict, key: "Q" });
2688     if (!Number.isInteger(alignment) || alignment < 0 || alignment > 2) {
2689       alignment = null;
2690     }
2691     this.data.textAlignment = alignment;
2692 
2693     // Determine the maximum length of text in the field.
2694     let maximumLength = getInheritableProperty({ dict, key: "MaxLen" });
2695     if (!Number.isInteger(maximumLength) || maximumLength < 0) {
2696       maximumLength = 0;
2697     }
2698     this.data.maxLen = maximumLength;
2699 
2700     // Process field flags for the display layer.
2701     this.data.multiLine = this.hasFieldFlag(AnnotationFieldFlag.MULTILINE);
2702     this.data.comb =
2703       this.hasFieldFlag(AnnotationFieldFlag.COMB) &&
2704       !this.hasFieldFlag(AnnotationFieldFlag.MULTILINE) &&
2705       !this.hasFieldFlag(AnnotationFieldFlag.PASSWORD) &&
2706       !this.hasFieldFlag(AnnotationFieldFlag.FILESELECT) &&
2707       this.data.maxLen !== 0;
2708     this.data.doNotScroll = this.hasFieldFlag(AnnotationFieldFlag.DONOTSCROLL);
2709   }
2710 
2711   get hasTextContent() {
2712     return !!this.appearance && !this._needAppearances;
2713   }
2714 
2715   _getCombAppearance(
2716     defaultAppearance,
2717     font,
2718     text,
2719     fontSize,
2720     width,
2721     height,
2722     hPadding,
2723     vPadding,
2724     descent,
2725     lineHeight,
2726     annotationStorage
2727   ) {
2728     const combWidth = width / this.data.maxLen;
2729     // Empty or it has a trailing whitespace.
2730     const colors = this.getBorderAndBackgroundAppearances(annotationStorage);
2731 
2732     const buf = [];
2733     const positions = font.getCharPositions(text);
2734     for (const [start, end] of positions) {
2735       buf.push(`(${escapeString(text.substring(start, end))}) Tj`);
2736     }
2737 
2738     const renderedComb = buf.join(` ${numberToString(combWidth)} 0 Td `);
2739     return (
2740       `/Tx BMC q ${colors}BT ` +
2741       defaultAppearance +
2742       ` 1 0 0 1 ${numberToString(hPadding)} ${numberToString(
2743         vPadding + descent
2744       )} Tm ${renderedComb}` +
2745       " ET Q EMC"
2746     );
2747   }
2748 
2749   _getMultilineAppearance(
2750     defaultAppearance,
2751     lines,
2752     font,
2753     fontSize,
2754     width,
2755     height,
2756     alignment,
2757     hPadding,
2758     vPadding,
2759     descent,
2760     lineHeight,
2761     annotationStorage
2762   ) {
2763     const buf = [];
2764     const totalWidth = width - 2 * hPadding;
2765     const prevInfo = { shift: 0 };
2766     for (let i = 0, ii = lines.length; i < ii; i++) {
2767       const line = lines[i];
2768       const chunks = this._splitLine(line, font, fontSize, totalWidth);
2769       for (let j = 0, jj = chunks.length; j < jj; j++) {
2770         const chunk = chunks[j];
2771         const vShift =
2772           i === 0 && j === 0 ? -vPadding - (lineHeight - descent) : -lineHeight;
2773         buf.push(
2774           this._renderText(
2775             chunk,
2776             font,
2777             fontSize,
2778             width,
2779             alignment,
2780             prevInfo,
2781             hPadding,
2782             vShift
2783           )
2784         );
2785       }
2786     }
2787 
2788     // Empty or it has a trailing whitespace.
2789     const colors = this.getBorderAndBackgroundAppearances(annotationStorage);
2790     const renderedText = buf.join("\n");
2791 
2792     return (
2793       `/Tx BMC q ${colors}BT ` +
2794       defaultAppearance +
2795       ` 1 0 0 1 0 ${numberToString(height)} Tm ${renderedText}` +
2796       " ET Q EMC"
2797     );
2798   }
2799 
2800   _splitLine(line, font, fontSize, width, cache = {}) {
2801     line = cache.line || line;
2802 
2803     const glyphs = cache.glyphs || font.charsToGlyphs(line);
2804 
2805     if (glyphs.length <= 1) {
2806       // Nothing to split
2807       return [line];
2808     }
2809 
2810     const positions = cache.positions || font.getCharPositions(line);
2811     const scale = fontSize / 1000;
2812     const chunks = [];
2813 
2814     let lastSpacePosInStringStart = -1,
2815       lastSpacePosInStringEnd = -1,
2816       lastSpacePos = -1,
2817       startChunk = 0,
2818       currentWidth = 0;
2819 
2820     for (let i = 0, ii = glyphs.length; i < ii; i++) {
2821       const [start, end] = positions[i];
2822       const glyph = glyphs[i];
2823       const glyphWidth = glyph.width * scale;
2824       if (glyph.unicode === " ") {
2825         if (currentWidth + glyphWidth > width) {
2826           // We can break here
2827           chunks.push(line.substring(startChunk, start));
2828           startChunk = start;
2829           currentWidth = glyphWidth;
2830           lastSpacePosInStringStart = -1;
2831           lastSpacePos = -1;
2832         } else {
2833           currentWidth += glyphWidth;
2834           lastSpacePosInStringStart = start;
2835           lastSpacePosInStringEnd = end;
2836           lastSpacePos = i;
2837         }
2838       } else if (currentWidth + glyphWidth > width) {
2839         // We must break to the last white position (if available)
2840         if (lastSpacePosInStringStart !== -1) {
2841           chunks.push(line.substring(startChunk, lastSpacePosInStringEnd));
2842           startChunk = lastSpacePosInStringEnd;
2843           i = lastSpacePos + 1;
2844           lastSpacePosInStringStart = -1;
2845           currentWidth = 0;
2846         } else {
2847           // Just break in the middle of the word
2848           chunks.push(line.substring(startChunk, start));
2849           startChunk = start;
2850           currentWidth = glyphWidth;
2851         }
2852       } else {
2853         currentWidth += glyphWidth;
2854       }
2855     }
2856 
2857     if (startChunk < line.length) {
2858       chunks.push(line.substring(startChunk, line.length));
2859     }
2860 
2861     return chunks;
2862   }
2863 
2864   getFieldObject() {
2865     return {
2866       id: this.data.id,
2867       value: this.data.fieldValue,
2868       defaultValue: this.data.defaultFieldValue || "",
2869       multiline: this.data.multiLine,
2870       password: this.hasFieldFlag(AnnotationFieldFlag.PASSWORD),
2871       charLimit: this.data.maxLen,
2872       comb: this.data.comb,
2873       editable: !this.data.readOnly,
2874       hidden: this.data.hidden,
2875       name: this.data.fieldName,
2876       rect: this.data.rect,
2877       actions: this.data.actions,
2878       page: this.data.pageIndex,
2879       strokeColor: this.data.borderColor,
2880       fillColor: this.data.backgroundColor,
2881       rotation: this.rotation,
2882       type: "text",
2883     };
2884   }
2885 }
2886 
2887 class ButtonWidgetAnnotation extends WidgetAnnotation {
2888   constructor(params) {
2889     super(params);
2890 
2891     this.checkedAppearance = null;
2892     this.uncheckedAppearance = null;
2893 
2894     this.data.checkBox =
2895       !this.hasFieldFlag(AnnotationFieldFlag.RADIO) &&
2896       !this.hasFieldFlag(AnnotationFieldFlag.PUSHBUTTON);
2897     this.data.radioButton =
2898       this.hasFieldFlag(AnnotationFieldFlag.RADIO) &&
2899       !this.hasFieldFlag(AnnotationFieldFlag.PUSHBUTTON);
2900     this.data.pushButton = this.hasFieldFlag(AnnotationFieldFlag.PUSHBUTTON);
2901     this.data.isTooltipOnly = false;
2902 
2903     if (this.data.checkBox) {
2904       this._processCheckBox(params);
2905     } else if (this.data.radioButton) {
2906       this._processRadioButton(params);
2907     } else if (this.data.pushButton) {
2908       this.data.hasOwnCanvas = true;
2909       this.data.noHTML = false;
2910       this._processPushButton(params);
2911     } else {
2912       warn("Invalid field flags for button widget annotation");
2913     }
2914   }
2915 
2916   async getOperatorList(
2917     evaluator,
2918     task,
2919     intent,
2920     renderForms,
2921     annotationStorage
2922   ) {
2923     if (this.data.pushButton) {
2924       return super.getOperatorList(
2925         evaluator,
2926         task,
2927         intent,
2928         false, // we use normalAppearance to render the button
2929         annotationStorage
2930       );
2931     }
2932 
2933     let value = null;
2934     let rotation = null;
2935     if (annotationStorage) {
2936       const storageEntry = annotationStorage.get(this.data.id);
2937       value = storageEntry ? storageEntry.value : null;
2938       rotation = storageEntry ? storageEntry.rotation : null;
2939     }
2940 
2941     if (value === null && this.appearance) {
2942       // Nothing in the annotationStorage.
2943       // But we've a default appearance so use it.
2944       return super.getOperatorList(
2945         evaluator,
2946         task,
2947         intent,
2948         renderForms,
2949         annotationStorage
2950       );
2951     }
2952 
2953     if (value === null || value === undefined) {
2954       // There is no default appearance so use the one derived
2955       // from the field value.
2956       value = this.data.checkBox
2957         ? this.data.fieldValue === this.data.exportValue
2958         : this.data.fieldValue === this.data.buttonValue;
2959     }
2960 
2961     const appearance = value
2962       ? this.checkedAppearance
2963       : this.uncheckedAppearance;
2964     if (appearance) {
2965       const savedAppearance = this.appearance;
2966       const savedMatrix = appearance.dict.getArray("Matrix") || IDENTITY_MATRIX;
2967 
2968       if (rotation) {
2969         appearance.dict.set(
2970           "Matrix",
2971           this.getRotationMatrix(annotationStorage)
2972         );
2973       }
2974 
2975       this.appearance = appearance;
2976       const operatorList = super.getOperatorList(
2977         evaluator,
2978         task,
2979         intent,
2980         renderForms,
2981         annotationStorage
2982       );
2983       this.appearance = savedAppearance;
2984       appearance.dict.set("Matrix", savedMatrix);
2985       return operatorList;
2986     }
2987 
2988     // No appearance
2989     return {
2990       opList: new OperatorList(),
2991       separateForm: false,
2992       separateCanvas: false,
2993     };
2994   }
2995 
2996   async save(evaluator, task, annotationStorage) {
2997     if (this.data.checkBox) {
2998       return this._saveCheckbox(evaluator, task, annotationStorage);
2999     }
3000 
3001     if (this.data.radioButton) {
3002       return this._saveRadioButton(evaluator, task, annotationStorage);
3003     }
3004 
3005     // Nothing to save
3006     return null;
3007   }
3008 
3009   async _saveCheckbox(evaluator, task, annotationStorage) {
3010     if (!annotationStorage) {
3011       return null;
3012     }
3013     const storageEntry = annotationStorage.get(this.data.id);
3014     let rotation = storageEntry?.rotation,
3015       value = storageEntry?.value;
3016 
3017     if (rotation === undefined) {
3018       if (value === undefined) {
3019         return null;
3020       }
3021 
3022       const defaultValue = this.data.fieldValue === this.data.exportValue;
3023       if (defaultValue === value) {
3024         return null;
3025       }
3026     }
3027 
3028     const dict = evaluator.xref.fetchIfRef(this.ref);
3029     if (!(dict instanceof Dict)) {
3030       return null;
3031     }
3032 
3033     if (rotation === undefined) {
3034       rotation = this.rotation;
3035     }
3036     if (value === undefined) {
3037       value = this.data.fieldValue === this.data.exportValue;
3038     }
3039 
3040     const xfa = {
3041       path: this.data.fieldName,
3042       value: value ? this.data.exportValue : "",
3043     };
3044 
3045     const name = Name.get(value ? this.data.exportValue : "Off");
3046     dict.set("V", name);
3047     dict.set("AS", name);
3048     dict.set("M", `D:${getModificationDate()}`);
3049 
3050     const maybeMK = this._getMKDict(rotation);
3051     if (maybeMK) {
3052       dict.set("MK", maybeMK);
3053     }
3054 
3055     const buffer = [];
3056     await writeObject(this.ref, dict, buffer, evaluator.xref);
3057 
3058     return [{ ref: this.ref, data: buffer.join(""), xfa }];
3059   }
3060 
3061   async _saveRadioButton(evaluator, task, annotationStorage) {
3062     if (!annotationStorage) {
3063       return null;
3064     }
3065     const storageEntry = annotationStorage.get(this.data.id);
3066     let rotation = storageEntry?.rotation,
3067       value = storageEntry?.value;
3068 
3069     if (rotation === undefined) {
3070       if (value === undefined) {
3071         return null;
3072       }
3073 
3074       const defaultValue = this.data.fieldValue === this.data.buttonValue;
3075       if (defaultValue === value) {
3076         return null;
3077       }
3078     }
3079 
3080     const dict = evaluator.xref.fetchIfRef(this.ref);
3081     if (!(dict instanceof Dict)) {
3082       return null;
3083     }
3084 
3085     if (value === undefined) {
3086       value = this.data.fieldValue === this.data.buttonValue;
3087     }
3088 
3089     if (rotation === undefined) {
3090       rotation = this.rotation;
3091     }
3092 
3093     const xfa = {
3094       path: this.data.fieldName,
3095       value: value ? this.data.buttonValue : "",
3096     };
3097 
3098     const name = Name.get(value ? this.data.buttonValue : "Off");
3099     const buffer = [];
3100     let parentData = null;
3101 
3102     if (value) {
3103       if (this.parent instanceof Ref) {
3104         const parent = evaluator.xref.fetch(this.parent);
3105         parent.set("V", name);
3106         await writeObject(this.parent, parent, buffer, evaluator.xref);
3107         parentData = buffer.join("");
3108         buffer.length = 0;
3109       } else if (this.parent instanceof Dict) {
3110         this.parent.set("V", name);
3111       }
3112     }
3113 
3114     dict.set("AS", name);
3115     dict.set("M", `D:${getModificationDate()}`);
3116 
3117     const maybeMK = this._getMKDict(rotation);
3118     if (maybeMK) {
3119       dict.set("MK", maybeMK);
3120     }
3121 
3122     await writeObject(this.ref, dict, buffer, evaluator.xref);
3123     const newRefs = [{ ref: this.ref, data: buffer.join(""), xfa }];
3124     if (parentData) {
3125       newRefs.push({ ref: this.parent, data: parentData, xfa: null });
3126     }
3127 
3128     return newRefs;
3129   }
3130 
3131   _getDefaultCheckedAppearance(params, type) {
3132     const width = this.data.rect[2] - this.data.rect[0];
3133     const height = this.data.rect[3] - this.data.rect[1];
3134     const bbox = [0, 0, width, height];
3135 
3136     // Ratio used to have a mark slightly smaller than the bbox.
3137     const FONT_RATIO = 0.8;
3138     const fontSize = Math.min(width, height) * FONT_RATIO;
3139 
3140     // Char Metrics
3141     // Widths came from widths for ZapfDingbats.
3142     // Heights are guessed with Fontforge and FoxitDingbats.pfb.
3143     let metrics, char;
3144     if (type === "check") {
3145       // Char 33 (2713 in unicode)
3146       metrics = {
3147         width: 0.755 * fontSize,
3148         height: 0.705 * fontSize,
3149       };
3150       char = "\x33";
3151     } else if (type === "disc") {
3152       // Char 6C (25CF in unicode)
3153       metrics = {
3154         width: 0.791 * fontSize,
3155         height: 0.705 * fontSize,
3156       };
3157       char = "\x6C";
3158     } else {
3159       unreachable(`_getDefaultCheckedAppearance - unsupported type: ${type}`);
3160     }
3161 
3162     // Values to center the glyph in the bbox.
3163     const xShift = numberToString((width - metrics.width) / 2);
3164     const yShift = numberToString((height - metrics.height) / 2);
3165 
3166     const appearance = `q BT /PdfJsZaDb ${fontSize} Tf 0 g ${xShift} ${yShift} Td (${char}) Tj ET Q`;
3167 
3168     const appearanceStreamDict = new Dict(params.xref);
3169     appearanceStreamDict.set("FormType", 1);
3170     appearanceStreamDict.set("Subtype", Name.get("Form"));
3171     appearanceStreamDict.set("Type", Name.get("XObject"));
3172     appearanceStreamDict.set("BBox", bbox);
3173     appearanceStreamDict.set("Matrix", [1, 0, 0, 1, 0, 0]);
3174     appearanceStreamDict.set("Length", appearance.length);
3175 
3176     const resources = new Dict(params.xref);
3177     const font = new Dict(params.xref);
3178     font.set("PdfJsZaDb", this.fallbackFontDict);
3179     resources.set("Font", font);
3180 
3181     appearanceStreamDict.set("Resources", resources);
3182 
3183     this.checkedAppearance = new StringStream(appearance);
3184     this.checkedAppearance.dict = appearanceStreamDict;
3185 
3186     this._streams.push(this.checkedAppearance);
3187   }
3188 
3189   _processCheckBox(params) {
3190     const customAppearance = params.dict.get("AP");
3191     if (!(customAppearance instanceof Dict)) {
3192       return;
3193     }
3194 
3195     const normalAppearance = customAppearance.get("N");
3196     if (!(normalAppearance instanceof Dict)) {
3197       return;
3198     }
3199 
3200     // See https://bugzilla.mozilla.org/show_bug.cgi?id=1722036.
3201     // If we've an AS and a V then take AS.
3202     const asValue = this._decodeFormValue(params.dict.get("AS"));
3203     if (typeof asValue === "string") {
3204       this.data.fieldValue = asValue;
3205     }
3206 
3207     const yes =
3208       this.data.fieldValue !== null && this.data.fieldValue !== "Off"
3209         ? this.data.fieldValue
3210         : "Yes";
3211 
3212     const exportValues = normalAppearance.getKeys();
3213     if (exportValues.length === 0) {
3214       exportValues.push("Off", yes);
3215     } else if (exportValues.length === 1) {
3216       if (exportValues[0] === "Off") {
3217         exportValues.push(yes);
3218       } else {
3219         exportValues.unshift("Off");
3220       }
3221     } else if (exportValues.includes(yes)) {
3222       exportValues.length = 0;
3223       exportValues.push("Off", yes);
3224     } else {
3225       const otherYes = exportValues.find(v => v !== "Off");
3226       exportValues.length = 0;
3227       exportValues.push("Off", otherYes);
3228     }
3229 
3230     // Don't use a "V" entry pointing to a non-existent appearance state,
3231     // see e.g. bug1720411.pdf where it's an *empty* Name-instance.
3232     if (!exportValues.includes(this.data.fieldValue)) {
3233       this.data.fieldValue = "Off";
3234     }
3235 
3236     this.data.exportValue = exportValues[1];
3237 
3238     const checkedAppearance = normalAppearance.get(this.data.exportValue);
3239     this.checkedAppearance =
3240       checkedAppearance instanceof BaseStream ? checkedAppearance : null;
3241     const uncheckedAppearance = normalAppearance.get("Off");
3242     this.uncheckedAppearance =
3243       uncheckedAppearance instanceof BaseStream ? uncheckedAppearance : null;
3244 
3245     if (this.checkedAppearance) {
3246       this._streams.push(this.checkedAppearance);
3247     } else {
3248       this._getDefaultCheckedAppearance(params, "check");
3249     }
3250     if (this.uncheckedAppearance) {
3251       this._streams.push(this.uncheckedAppearance);
3252     }
3253     this._fallbackFontDict = this.fallbackFontDict;
3254     if (this.data.defaultFieldValue === null) {
3255       this.data.defaultFieldValue = "Off";
3256     }
3257   }
3258 
3259   _processRadioButton(params) {
3260     this.data.buttonValue = null;
3261 
3262     // The parent field's `V` entry holds a `Name` object with the appearance
3263     // state of whichever child field is currently in the "on" state.
3264     const fieldParent = params.dict.get("Parent");
3265     if (fieldParent instanceof Dict) {
3266       this.parent = params.dict.getRaw("Parent");
3267       const fieldParentValue = fieldParent.get("V");
3268       if (fieldParentValue instanceof Name) {
3269         this.data.fieldValue = this._decodeFormValue(fieldParentValue);
3270       }
3271     }
3272 
3273     // The button's value corresponds to its appearance state.
3274     const appearanceStates = params.dict.get("AP");
3275     if (!(appearanceStates instanceof Dict)) {
3276       return;
3277     }
3278     const normalAppearance = appearanceStates.get("N");
3279     if (!(normalAppearance instanceof Dict)) {
3280       return;
3281     }
3282     for (const key of normalAppearance.getKeys()) {
3283       if (key !== "Off") {
3284         this.data.buttonValue = this._decodeFormValue(key);
3285         break;
3286       }
3287     }
3288 
3289     const checkedAppearance = normalAppearance.get(this.data.buttonValue);
3290     this.checkedAppearance =
3291       checkedAppearance instanceof BaseStream ? checkedAppearance : null;
3292     const uncheckedAppearance = normalAppearance.get("Off");
3293     this.uncheckedAppearance =
3294       uncheckedAppearance instanceof BaseStream ? uncheckedAppearance : null;
3295 
3296     if (this.checkedAppearance) {
3297       this._streams.push(this.checkedAppearance);
3298     } else {
3299       this._getDefaultCheckedAppearance(params, "disc");
3300     }
3301     if (this.uncheckedAppearance) {
3302       this._streams.push(this.uncheckedAppearance);
3303     }
3304     this._fallbackFontDict = this.fallbackFontDict;
3305     if (this.data.defaultFieldValue === null) {
3306       this.data.defaultFieldValue = "Off";
3307     }
3308   }
3309 
3310   _processPushButton(params) {
3311     const { dict, annotationGlobals } = params;
3312 
3313     if (!dict.has("A") && !dict.has("AA") && !this.data.alternativeText) {
3314       warn("Push buttons without action dictionaries are not supported");
3315       return;
3316     }
3317 
3318     this.data.isTooltipOnly = !dict.has("A") && !dict.has("AA");
3319 
3320     Catalog.parseDestDictionary({
3321       destDict: dict,
3322       resultObj: this.data,
3323       docBaseUrl: annotationGlobals.baseUrl,
3324       docAttachments: annotationGlobals.attachments,
3325     });
3326   }
3327 
3328   getFieldObject() {
3329     let type = "button";
3330     let exportValues;
3331     if (this.data.checkBox) {
3332       type = "checkbox";
3333       exportValues = this.data.exportValue;
3334     } else if (this.data.radioButton) {
3335       type = "radiobutton";
3336       exportValues = this.data.buttonValue;
3337     }
3338     return {
3339       id: this.data.id,
3340       value: this.data.fieldValue || "Off",
3341       defaultValue: this.data.defaultFieldValue,
3342       exportValues,
3343       editable: !this.data.readOnly,
3344       name: this.data.fieldName,
3345       rect: this.data.rect,
3346       hidden: this.data.hidden,
3347       actions: this.data.actions,
3348       page: this.data.pageIndex,
3349       strokeColor: this.data.borderColor,
3350       fillColor: this.data.backgroundColor,
3351       rotation: this.rotation,
3352       type,
3353     };
3354   }
3355 
3356   get fallbackFontDict() {
3357     const dict = new Dict();
3358     dict.set("BaseFont", Name.get("ZapfDingbats"));
3359     dict.set("Type", Name.get("FallbackType"));
3360     dict.set("Subtype", Name.get("FallbackType"));
3361     dict.set("Encoding", Name.get("ZapfDingbatsEncoding"));
3362 
3363     return shadow(this, "fallbackFontDict", dict);
3364   }
3365 }
3366 
3367 class ChoiceWidgetAnnotation extends WidgetAnnotation {
3368   constructor(params) {
3369     super(params);
3370 
3371     const { dict, xref } = params;
3372 
3373     this.indices = dict.getArray("I");
3374     this.hasIndices = Array.isArray(this.indices) && this.indices.length > 0;
3375 
3376     // Determine the options. The options array may consist of strings or
3377     // arrays. If the array consists of arrays, then the first element of
3378     // each array is the export value and the second element of each array is
3379     // the display value. If the array consists of strings, then these
3380     // represent both the export and display value. In this case, we convert
3381     // it to an array of arrays as well for convenience in the display layer.
3382     // Note that the specification does not state that the `Opt` field is
3383     // inheritable, but in practice PDF generators do make annotations
3384     // inherit the options from a parent annotation (issue 8094).
3385     this.data.options = [];
3386 
3387     const options = getInheritableProperty({ dict, key: "Opt" });
3388     if (Array.isArray(options)) {
3389       for (let i = 0, ii = options.length; i < ii; i++) {
3390         const option = xref.fetchIfRef(options[i]);
3391         const isOptionArray = Array.isArray(option);
3392 
3393         this.data.options[i] = {
3394           exportValue: this._decodeFormValue(
3395             isOptionArray ? xref.fetchIfRef(option[0]) : option
3396           ),
3397           displayValue: this._decodeFormValue(
3398             isOptionArray ? xref.fetchIfRef(option[1]) : option
3399           ),
3400         };
3401       }
3402     }
3403 
3404     if (!this.hasIndices) {
3405       // The field value can be `null` if no item is selected, a string if one
3406       // item is selected or an array of strings if multiple items are selected.
3407       // For consistency in the API and convenience in the display layer, we
3408       // always make the field value an array with zero, one or multiple items.
3409       if (typeof this.data.fieldValue === "string") {
3410         this.data.fieldValue = [this.data.fieldValue];
3411       } else if (!this.data.fieldValue) {
3412         this.data.fieldValue = [];
3413       }
3414     } else {
3415       // The specs say that we should have an indices array only with
3416       // multiselectable Choice and the "V" entry should have the
3417       // precedence, but Acrobat itself is using it whatever the
3418       // the "V" entry is (see bug 1770750).
3419       this.data.fieldValue = [];
3420       const ii = this.data.options.length;
3421       for (const i of this.indices) {
3422         if (Number.isInteger(i) && i >= 0 && i < ii) {
3423           this.data.fieldValue.push(this.data.options[i].exportValue);
3424         }
3425       }
3426     }
3427 
3428     // Process field flags for the display layer.
3429     this.data.combo = this.hasFieldFlag(AnnotationFieldFlag.COMBO);
3430     this.data.multiSelect = this.hasFieldFlag(AnnotationFieldFlag.MULTISELECT);
3431     this._hasText = true;
3432   }
3433 
3434   getFieldObject() {
3435     const type = this.data.combo ? "combobox" : "listbox";
3436     const value =
3437       this.data.fieldValue.length > 0 ? this.data.fieldValue[0] : null;
3438     return {
3439       id: this.data.id,
3440       value,
3441       defaultValue: this.data.defaultFieldValue,
3442       editable: !this.data.readOnly,
3443       name: this.data.fieldName,
3444       rect: this.data.rect,
3445       numItems: this.data.fieldValue.length,
3446       multipleSelection: this.data.multiSelect,
3447       hidden: this.data.hidden,
3448       actions: this.data.actions,
3449       items: this.data.options,
3450       page: this.data.pageIndex,
3451       strokeColor: this.data.borderColor,
3452       fillColor: this.data.backgroundColor,
3453       rotation: this.rotation,
3454       type,
3455     };
3456   }
3457 
3458   amendSavedDict(annotationStorage, dict) {
3459     if (!this.hasIndices) {
3460       return;
3461     }
3462     let values = annotationStorage?.get(this.data.id)?.value;
3463     if (!Array.isArray(values)) {
3464       values = [values];
3465     }
3466     const indices = [];
3467     const { options } = this.data;
3468     for (let i = 0, j = 0, ii = options.length; i < ii; i++) {
3469       if (options[i].exportValue === values[j]) {
3470         indices.push(i);
3471         j += 1;
3472       }
3473     }
3474     dict.set("I", indices);
3475   }
3476 
3477   async _getAppearance(evaluator, task, intent, annotationStorage) {
3478     if (this.data.combo) {
3479       return super._getAppearance(evaluator, task, intent, annotationStorage);
3480     }
3481 
3482     let exportedValue, rotation;
3483     const storageEntry = annotationStorage?.get(this.data.id);
3484     if (storageEntry) {
3485       rotation = storageEntry.rotation;
3486       exportedValue = storageEntry.value;
3487     }
3488 
3489     if (
3490       rotation === undefined &&
3491       exportedValue === undefined &&
3492       !this._needAppearances
3493     ) {
3494       // The annotation hasn't been rendered so use the appearance
3495       return null;
3496     }
3497 
3498     if (exportedValue === undefined) {
3499       exportedValue = this.data.fieldValue;
3500     } else if (!Array.isArray(exportedValue)) {
3501       exportedValue = [exportedValue];
3502     }
3503 
3504     const defaultPadding = 1;
3505     const defaultHPadding = 2;
3506     let totalHeight = this.data.rect[3] - this.data.rect[1];
3507     let totalWidth = this.data.rect[2] - this.data.rect[0];
3508 
3509     if (rotation === 90 || rotation === 270) {
3510       [totalWidth, totalHeight] = [totalHeight, totalWidth];
3511     }
3512 
3513     const lineCount = this.data.options.length;
3514     const valueIndices = [];
3515     for (let i = 0; i < lineCount; i++) {
3516       const { exportValue } = this.data.options[i];
3517       if (exportedValue.includes(exportValue)) {
3518         valueIndices.push(i);
3519       }
3520     }
3521 
3522     if (!this._defaultAppearance) {
3523       // The DA is required and must be a string.
3524       // If there is no font named Helvetica in the resource dictionary,
3525       // the evaluator will fall back to a default font.
3526       // Doing so prevents exceptions and allows saving/printing
3527       // the file as expected.
3528       this.data.defaultAppearanceData = parseDefaultAppearance(
3529         (this._defaultAppearance = "/Helvetica 0 Tf 0 g")
3530       );
3531     }
3532 
3533     const font = await WidgetAnnotation._getFontData(
3534       evaluator,
3535       task,
3536       this.data.defaultAppearanceData,
3537       this._fieldResources.mergedResources
3538     );
3539 
3540     let defaultAppearance;
3541     let { fontSize } = this.data.defaultAppearanceData;
3542     if (!fontSize) {
3543       const lineHeight = (totalHeight - defaultPadding) / lineCount;
3544       let lineWidth = -1;
3545       let value;
3546       for (const { displayValue } of this.data.options) {
3547         const width = this._getTextWidth(displayValue, font);
3548         if (width > lineWidth) {
3549           lineWidth = width;
3550           value = displayValue;
3551         }
3552       }
3553 
3554       [defaultAppearance, fontSize] = this._computeFontSize(
3555         lineHeight,
3556         totalWidth - 2 * defaultHPadding,
3557         value,
3558         font,
3559         -1
3560       );
3561     } else {
3562       defaultAppearance = this._defaultAppearance;
3563     }
3564 
3565     const lineHeight = fontSize * LINE_FACTOR;
3566     const vPadding = (lineHeight - fontSize) / 2;
3567     const numberOfVisibleLines = Math.floor(totalHeight / lineHeight);
3568 
3569     let firstIndex = 0;
3570     if (valueIndices.length > 0) {
3571       const minIndex = Math.min(...valueIndices);
3572       const maxIndex = Math.max(...valueIndices);
3573 
3574       firstIndex = Math.max(0, maxIndex - numberOfVisibleLines + 1);
3575       if (firstIndex > minIndex) {
3576         firstIndex = minIndex;
3577       }
3578     }
3579     const end = Math.min(firstIndex + numberOfVisibleLines + 1, lineCount);
3580 
3581     const buf = ["/Tx BMC q", `1 1 ${totalWidth} ${totalHeight} re W n`];
3582 
3583     if (valueIndices.length) {
3584       // This value has been copied/pasted from annotation-choice-widget.pdf.
3585       // It corresponds to rgb(153, 193, 218).
3586       buf.push("0.600006 0.756866 0.854904 rg");
3587 
3588       // Highlight the lines in filling a blue rectangle at the selected
3589       // positions.
3590       for (const index of valueIndices) {
3591         if (firstIndex <= index && index < end) {
3592           buf.push(
3593             `1 ${
3594               totalHeight - (index - firstIndex + 1) * lineHeight
3595             } ${totalWidth} ${lineHeight} re f`
3596           );
3597         }
3598       }
3599     }
3600     buf.push("BT", defaultAppearance, `1 0 0 1 0 ${totalHeight} Tm`);
3601 
3602     const prevInfo = { shift: 0 };
3603     for (let i = firstIndex; i < end; i++) {
3604       const { displayValue } = this.data.options[i];
3605       const vpadding = i === firstIndex ? vPadding : 0;
3606       buf.push(
3607         this._renderText(
3608           displayValue,
3609           font,
3610           fontSize,
3611           totalWidth,
3612           0,
3613           prevInfo,
3614           defaultHPadding,
3615           -lineHeight + vpadding
3616         )
3617       );
3618     }
3619 
3620     buf.push("ET Q EMC");
3621 
3622     return buf.join("\n");
3623   }
3624 }
3625 
3626 class SignatureWidgetAnnotation extends WidgetAnnotation {
3627   constructor(params) {
3628     super(params);
3629 
3630     // Unset the fieldValue since it's (most likely) a `Dict` which is
3631     // non-serializable and will thus cause errors when sending annotations
3632     // to the main-thread (issue 10347).
3633     this.data.fieldValue = null;
3634     this.data.hasOwnCanvas = this.data.noRotate;
3635     this.data.noHTML = !this.data.hasOwnCanvas;
3636   }
3637 
3638   getFieldObject() {
3639     return {
3640       id: this.data.id,
3641       value: null,
3642       page: this.data.pageIndex,
3643       type: "signature",
3644     };
3645   }
3646 }
3647 
3648 class TextAnnotation extends MarkupAnnotation {
3649   constructor(params) {
3650     const DEFAULT_ICON_SIZE = 22; // px
3651 
3652     super(params);
3653 
3654     // No rotation for Text (see 12.5.6.4).
3655     this.data.noRotate = true;
3656     this.data.hasOwnCanvas = this.data.noRotate;
3657     this.data.noHTML = false;
3658 
3659     const { dict } = params;
3660     this.data.annotationType = AnnotationType.TEXT;
3661 
3662     if (this.data.hasAppearance) {
3663       this.data.name = "NoIcon";
3664     } else {
3665       this.data.rect[1] = this.data.rect[3] - DEFAULT_ICON_SIZE;
3666       this.data.rect[2] = this.data.rect[0] + DEFAULT_ICON_SIZE;
3667       this.data.name = dict.has("Name") ? dict.get("Name").name : "Note";
3668     }
3669 
3670     if (dict.has("State")) {
3671       this.data.state = dict.get("State") || null;
3672       this.data.stateModel = dict.get("StateModel") || null;
3673     } else {
3674       this.data.state = null;
3675       this.data.stateModel = null;
3676     }
3677   }
3678 }
3679 
3680 class LinkAnnotation extends Annotation {
3681   constructor(params) {
3682     super(params);
3683 
3684     const { dict, annotationGlobals } = params;
3685     this.data.annotationType = AnnotationType.LINK;
3686 
3687     const quadPoints = getQuadPoints(dict, this.rectangle);
3688     if (quadPoints) {
3689       this.data.quadPoints = quadPoints;
3690     }
3691 
3692     // The color entry for a link annotation is the color of the border.
3693     this.data.borderColor ||= this.data.color;
3694 
3695     Catalog.parseDestDictionary({
3696       destDict: dict,
3697       resultObj: this.data,
3698       docBaseUrl: annotationGlobals.baseUrl,
3699       docAttachments: annotationGlobals.attachments,
3700     });
3701   }
3702 }
3703 
3704 class PopupAnnotation extends Annotation {
3705   constructor(params) {
3706     super(params);
3707 
3708     const { dict } = params;
3709     this.data.annotationType = AnnotationType.POPUP;
3710 
3711     // A pop-up is never rendered on the main canvas so we must render its HTML
3712     // version.
3713     this.data.noHTML = false;
3714 
3715     if (
3716       this.data.rect[0] === this.data.rect[2] ||
3717       this.data.rect[1] === this.data.rect[3]
3718     ) {
3719       this.data.rect = null;
3720     }
3721 
3722     let parentItem = dict.get("Parent");
3723     if (!parentItem) {
3724       warn("Popup annotation has a missing or invalid parent annotation.");
3725       return;
3726     }
3727 
3728     const parentRect = parentItem.getArray("Rect");
3729     this.data.parentRect =
3730       Array.isArray(parentRect) && parentRect.length === 4
3731         ? Util.normalizeRect(parentRect)
3732         : null;
3733 
3734     const rt = parentItem.get("RT");
3735     if (isName(rt, AnnotationReplyType.GROUP)) {
3736       // Subordinate annotations in a group should inherit
3737       // the group attributes from the primary annotation.
3738       parentItem = parentItem.get("IRT");
3739     }
3740 
3741     if (!parentItem.has("M")) {
3742       this.data.modificationDate = null;
3743     } else {
3744       this.setModificationDate(parentItem.get("M"));
3745       this.data.modificationDate = this.modificationDate;
3746     }
3747 
3748     if (!parentItem.has("C")) {
3749       // Fall back to the default background color.
3750       this.data.color = null;
3751     } else {
3752       this.setColor(parentItem.getArray("C"));
3753       this.data.color = this.color;
3754     }
3755 
3756     // If the Popup annotation is not viewable, but the parent annotation is,
3757     // that is most likely a bug. Fallback to inherit the flags from the parent
3758     // annotation (this is consistent with the behaviour in Adobe Reader).
3759     if (!this.viewable) {
3760       const parentFlags = parentItem.get("F");
3761       if (this._isViewable(parentFlags)) {
3762         this.setFlags(parentFlags);
3763       }
3764     }
3765 
3766     this.setTitle(parentItem.get("T"));
3767     this.data.titleObj = this._title;
3768 
3769     this.setContents(parentItem.get("Contents"));
3770     this.data.contentsObj = this._contents;
3771 
3772     if (parentItem.has("RC")) {
3773       this.data.richText = XFAFactory.getRichTextAsHtml(parentItem.get("RC"));
3774     }
3775 
3776     this.data.open = !!dict.get("Open");
3777   }
3778 }
3779 
3780 class FreeTextAnnotation extends MarkupAnnotation {
3781   constructor(params) {
3782     super(params);
3783 
3784     // It uses its own canvas in order to be hidden if edited.
3785     // But if it has the noHTML flag, it means that we don't want to be able
3786     // to modify it so we can just draw it on the main canvas.
3787     this.data.hasOwnCanvas = !this.data.noHTML;
3788     // We want to be able to add mouse listeners to the annotation.
3789     this.data.noHTML = false;
3790 
3791     const { evaluatorOptions, xref } = params;
3792     this.data.annotationType = AnnotationType.FREETEXT;
3793     this.setDefaultAppearance(params);
3794     this._hasAppearance = !!this.appearance;
3795 
3796     if (this._hasAppearance) {
3797       const { fontColor, fontSize } = parseAppearanceStream(
3798         this.appearance,
3799         evaluatorOptions,
3800         xref
3801       );
3802       this.data.defaultAppearanceData.fontColor = fontColor;
3803       this.data.defaultAppearanceData.fontSize = fontSize || 10;
3804     } else {
3805       this.data.defaultAppearanceData.fontSize ||= 10;
3806       const { fontColor, fontSize } = this.data.defaultAppearanceData;
3807       if (this._contents.str) {
3808         this.data.textContent = this._contents.str
3809           .split(/\r\n?|\n/)
3810           .map(line => line.trimEnd());
3811         const { coords, bbox, matrix } = FakeUnicodeFont.getFirstPositionInfo(
3812           this.rectangle,
3813           this.rotation,
3814           fontSize
3815         );
3816         this.data.textPosition = this._transformPoint(coords, bbox, matrix);
3817       }
3818       if (this._isOffscreenCanvasSupported) {
3819         const strokeAlpha = params.dict.get("CA");
3820         const fakeUnicodeFont = new FakeUnicodeFont(xref, "sans-serif");
3821         this.appearance = fakeUnicodeFont.createAppearance(
3822           this._contents.str,
3823           this.rectangle,
3824           this.rotation,
3825           fontSize,
3826           fontColor,
3827           strokeAlpha
3828         );
3829         this._streams.push(this.appearance, FakeUnicodeFont.toUnicodeStream);
3830       } else {
3831         warn(
3832           "FreeTextAnnotation: OffscreenCanvas is not supported, annotation may not render correctly."
3833         );
3834       }
3835     }
3836   }
3837 
3838   get hasTextContent() {
3839     return this._hasAppearance;
3840   }
3841 
3842   static createNewDict(annotation, xref, { apRef, ap }) {
3843     const { color, fontSize, rect, rotation, user, value } = annotation;
3844     const freetext = new Dict(xref);
3845     freetext.set("Type", Name.get("Annot"));
3846     freetext.set("Subtype", Name.get("FreeText"));
3847     freetext.set("CreationDate", `D:${getModificationDate()}`);
3848     freetext.set("Rect", rect);
3849     const da = `/Helv ${fontSize} Tf ${getPdfColor(color, /* isFill */ true)}`;
3850     freetext.set("DA", da);
3851     freetext.set(
3852       "Contents",
3853       isAscii(value)
3854         ? value
3855         : stringToUTF16String(value, /* bigEndian = */ true)
3856     );
3857     freetext.set("F", 4);
3858     freetext.set("Border", [0, 0, 0]);
3859     freetext.set("Rotate", rotation);
3860 
3861     if (user) {
3862       freetext.set(
3863         "T",
3864         isAscii(user) ? user : stringToUTF16String(user, /* bigEndian = */ true)
3865       );
3866     }
3867 
3868     if (apRef || ap) {
3869       const n = new Dict(xref);
3870       freetext.set("AP", n);
3871 
3872       if (apRef) {
3873         n.set("N", apRef);
3874       } else {
3875         n.set("N", ap);
3876       }
3877     }
3878 
3879     return freetext;
3880   }
3881 
3882   static async createNewAppearanceStream(annotation, xref, params) {
3883     const { baseFontRef, evaluator, task } = params;
3884     const { color, fontSize, rect, rotation, value } = annotation;
3885 
3886     const resources = new Dict(xref);
3887     const font = new Dict(xref);
3888 
3889     if (baseFontRef) {
3890       font.set("Helv", baseFontRef);
3891     } else {
3892       const baseFont = new Dict(xref);
3893       baseFont.set("BaseFont", Name.get("Helvetica"));
3894       baseFont.set("Type", Name.get("Font"));
3895       baseFont.set("Subtype", Name.get("Type1"));
3896       baseFont.set("Encoding", Name.get("WinAnsiEncoding"));
3897       font.set("Helv", baseFont);
3898     }
3899     resources.set("Font", font);
3900 
3901     const helv = await WidgetAnnotation._getFontData(
3902       evaluator,
3903       task,
3904       {
3905         fontName: "Helv",
3906         fontSize,
3907       },
3908       resources
3909     );
3910 
3911     const [x1, y1, x2, y2] = rect;
3912     let w = x2 - x1;
3913     let h = y2 - y1;
3914 
3915     if (rotation % 180 !== 0) {
3916       [w, h] = [h, w];
3917     }
3918 
3919     const lines = value.split("\n");
3920     const scale = fontSize / 1000;
3921     let totalWidth = -Infinity;
3922     const encodedLines = [];
3923     for (let line of lines) {
3924       const encoded = helv.encodeString(line);
3925       if (encoded.length > 1) {
3926         // The font doesn't contain all the chars.
3927         return null;
3928       }
3929       line = encoded.join("");
3930       encodedLines.push(line);
3931       let lineWidth = 0;
3932       const glyphs = helv.charsToGlyphs(line);
3933       for (const glyph of glyphs) {
3934         lineWidth += glyph.width * scale;
3935       }
3936       totalWidth = Math.max(totalWidth, lineWidth);
3937     }
3938 
3939     let hscale = 1;
3940     if (totalWidth > w) {
3941       hscale = w / totalWidth;
3942     }
3943     let vscale = 1;
3944     const lineHeight = LINE_FACTOR * fontSize;
3945     const lineAscent = (LINE_FACTOR - LINE_DESCENT_FACTOR) * fontSize;
3946     const totalHeight = lineHeight * lines.length;
3947     if (totalHeight > h) {
3948       vscale = h / totalHeight;
3949     }
3950     const fscale = Math.min(hscale, vscale);
3951     const newFontSize = fontSize * fscale;
3952     let firstPoint, clipBox, matrix;
3953     switch (rotation) {
3954       case 0:
3955         matrix = [1, 0, 0, 1];
3956         clipBox = [rect[0], rect[1], w, h];
3957         firstPoint = [rect[0], rect[3] - lineAscent];
3958         break;
3959       case 90:
3960         matrix = [0, 1, -1, 0];
3961         clipBox = [rect[1], -rect[2], w, h];
3962         firstPoint = [rect[1], -rect[0] - lineAscent];
3963         break;
3964       case 180:
3965         matrix = [-1, 0, 0, -1];
3966         clipBox = [-rect[2], -rect[3], w, h];
3967         firstPoint = [-rect[2], -rect[1] - lineAscent];
3968         break;
3969       case 270:
3970         matrix = [0, -1, 1, 0];
3971         clipBox = [-rect[3], rect[0], w, h];
3972         firstPoint = [-rect[3], rect[2] - lineAscent];
3973         break;
3974     }
3975 
3976     const buffer = [
3977       "q",
3978       `${matrix.join(" ")} 0 0 cm`,
3979       `${clipBox.join(" ")} re W n`,
3980       `BT`,
3981       `${getPdfColor(color, /* isFill */ true)}`,
3982       `0 Tc /Helv ${numberToString(newFontSize)} Tf`,
3983     ];
3984 
3985     buffer.push(
3986       `${firstPoint.join(" ")} Td (${escapeString(encodedLines[0])}) Tj`
3987     );
3988     const vShift = numberToString(lineHeight);
3989     for (let i = 1, ii = encodedLines.length; i < ii; i++) {
3990       const line = encodedLines[i];
3991       buffer.push(`0 -${vShift} Td (${escapeString(line)}) Tj`);
3992     }
3993     buffer.push("ET", "Q");
3994     const appearance = buffer.join("\n");
3995 
3996     const appearanceStreamDict = new Dict(xref);
3997     appearanceStreamDict.set("FormType", 1);
3998     appearanceStreamDict.set("Subtype", Name.get("Form"));
3999     appearanceStreamDict.set("Type", Name.get("XObject"));
4000     appearanceStreamDict.set("BBox", rect);
4001     appearanceStreamDict.set("Resources", resources);
4002     appearanceStreamDict.set("Matrix", [1, 0, 0, 1, -rect[0], -rect[1]]);
4003 
4004     const ap = new StringStream(appearance);
4005     ap.dict = appearanceStreamDict;
4006 
4007     return ap;
4008   }
4009 }
4010 
4011 class LineAnnotation extends MarkupAnnotation {
4012   constructor(params) {
4013     super(params);
4014 
4015     const { dict, xref } = params;
4016     this.data.annotationType = AnnotationType.LINE;
4017     this.data.hasOwnCanvas = this.data.noRotate;
4018     this.data.noHTML = false;
4019 
4020     const lineCoordinates = dict.getArray("L");
4021     this.data.lineCoordinates = Util.normalizeRect(lineCoordinates);
4022 
4023     if (typeof PDFJSDev === "undefined" || !PDFJSDev.test("MOZCENTRAL")) {
4024       this.setLineEndings(dict.getArray("LE"));
4025       this.data.lineEndings = this.lineEndings;
4026     }
4027 
4028     if (!this.appearance) {
4029       // The default stroke color is black.
4030       const strokeColor = this.color ? getPdfColorArray(this.color) : [0, 0, 0];
4031       const strokeAlpha = dict.get("CA");
4032 
4033       const interiorColor = getRgbColor(dict.getArray("IC"), null);
4034       // The default fill color is transparent. Setting the fill colour is
4035       // necessary if/when we want to add support for non-default line endings.
4036       const fillColor = interiorColor ? getPdfColorArray(interiorColor) : null;
4037       const fillAlpha = fillColor ? strokeAlpha : null;
4038 
4039       const borderWidth = this.borderStyle.width || 1,
4040         borderAdjust = 2 * borderWidth;
4041 
4042       // If the /Rect-entry is empty/wrong, create a fallback rectangle so that
4043       // we get similar rendering/highlighting behaviour as in Adobe Reader.
4044       const bbox = [
4045         this.data.lineCoordinates[0] - borderAdjust,
4046         this.data.lineCoordinates[1] - borderAdjust,
4047         this.data.lineCoordinates[2] + borderAdjust,
4048         this.data.lineCoordinates[3] + borderAdjust,
4049       ];
4050       if (!Util.intersect(this.rectangle, bbox)) {
4051         this.rectangle = bbox;
4052       }
4053 
4054       this._setDefaultAppearance({
4055         xref,
4056         extra: `${borderWidth} w`,
4057         strokeColor,
4058         fillColor,
4059         strokeAlpha,
4060         fillAlpha,
4061         pointsCallback: (buffer, points) => {
4062           buffer.push(
4063             `${lineCoordinates[0]} ${lineCoordinates[1]} m`,
4064             `${lineCoordinates[2]} ${lineCoordinates[3]} l`,
4065             "S"
4066           );
4067           return [
4068             points[0].x - borderWidth,
4069             points[1].x + borderWidth,
4070             points[3].y - borderWidth,
4071             points[1].y + borderWidth,
4072           ];
4073         },
4074       });
4075     }
4076   }
4077 }
4078 
4079 class SquareAnnotation extends MarkupAnnotation {
4080   constructor(params) {
4081     super(params);
4082 
4083     const { dict, xref } = params;
4084     this.data.annotationType = AnnotationType.SQUARE;
4085     this.data.hasOwnCanvas = this.data.noRotate;
4086     this.data.noHTML = false;
4087 
4088     if (!this.appearance) {
4089       // The default stroke color is black.
4090       const strokeColor = this.color ? getPdfColorArray(this.color) : [0, 0, 0];
4091       const strokeAlpha = dict.get("CA");
4092 
4093       const interiorColor = getRgbColor(dict.getArray("IC"), null);
4094       // The default fill color is transparent.
4095       const fillColor = interiorColor ? getPdfColorArray(interiorColor) : null;
4096       const fillAlpha = fillColor ? strokeAlpha : null;
4097 
4098       if (this.borderStyle.width === 0 && !fillColor) {
4099         // Prevent rendering a "hairline" border (fixes issue14164.pdf).
4100         return;
4101       }
4102 
4103       this._setDefaultAppearance({
4104         xref,
4105         extra: `${this.borderStyle.width} w`,
4106         strokeColor,
4107         fillColor,
4108         strokeAlpha,
4109         fillAlpha,
4110         pointsCallback: (buffer, points) => {
4111           const x = points[2].x + this.borderStyle.width / 2;
4112           const y = points[2].y + this.borderStyle.width / 2;
4113           const width = points[3].x - points[2].x - this.borderStyle.width;
4114           const height = points[1].y - points[3].y - this.borderStyle.width;
4115           buffer.push(`${x} ${y} ${width} ${height} re`);
4116           if (fillColor) {
4117             buffer.push("B");
4118           } else {
4119             buffer.push("S");
4120           }
4121           return [points[0].x, points[1].x, points[3].y, points[1].y];
4122         },
4123       });
4124     }
4125   }
4126 }
4127 
4128 class CircleAnnotation extends MarkupAnnotation {
4129   constructor(params) {
4130     super(params);
4131 
4132     const { dict, xref } = params;
4133     this.data.annotationType = AnnotationType.CIRCLE;
4134 
4135     if (!this.appearance) {
4136       // The default stroke color is black.
4137       const strokeColor = this.color ? getPdfColorArray(this.color) : [0, 0, 0];
4138       const strokeAlpha = dict.get("CA");
4139 
4140       const interiorColor = getRgbColor(dict.getArray("IC"), null);
4141       // The default fill color is transparent.
4142       const fillColor = interiorColor ? getPdfColorArray(interiorColor) : null;
4143       const fillAlpha = fillColor ? strokeAlpha : null;
4144 
4145       if (this.borderStyle.width === 0 && !fillColor) {
4146         // Prevent rendering a "hairline" border (fixes issue14164.pdf).
4147         return;
4148       }
4149 
4150       // Circles are approximated by Bézier curves with four segments since
4151       // there is no circle primitive in the PDF specification. For the control
4152       // points distance, see https://stackoverflow.com/a/27863181.
4153       const controlPointsDistance = (4 / 3) * Math.tan(Math.PI / (2 * 4));
4154 
4155       this._setDefaultAppearance({
4156         xref,
4157         extra: `${this.borderStyle.width} w`,
4158         strokeColor,
4159         fillColor,
4160         strokeAlpha,
4161         fillAlpha,
4162         pointsCallback: (buffer, points) => {
4163           const x0 = points[0].x + this.borderStyle.width / 2;
4164           const y0 = points[0].y - this.borderStyle.width / 2;
4165           const x1 = points[3].x - this.borderStyle.width / 2;
4166           const y1 = points[3].y + this.borderStyle.width / 2;
4167           const xMid = x0 + (x1 - x0) / 2;
4168           const yMid = y0 + (y1 - y0) / 2;
4169           const xOffset = ((x1 - x0) / 2) * controlPointsDistance;
4170           const yOffset = ((y1 - y0) / 2) * controlPointsDistance;
4171 
4172           buffer.push(
4173             `${xMid} ${y1} m`,
4174             `${xMid + xOffset} ${y1} ${x1} ${yMid + yOffset} ${x1} ${yMid} c`,
4175             `${x1} ${yMid - yOffset} ${xMid + xOffset} ${y0} ${xMid} ${y0} c`,
4176             `${xMid - xOffset} ${y0} ${x0} ${yMid - yOffset} ${x0} ${yMid} c`,
4177             `${x0} ${yMid + yOffset} ${xMid - xOffset} ${y1} ${xMid} ${y1} c`,
4178             "h"
4179           );
4180           if (fillColor) {
4181             buffer.push("B");
4182           } else {
4183             buffer.push("S");
4184           }
4185           return [points[0].x, points[1].x, points[3].y, points[1].y];
4186         },
4187       });
4188     }
4189   }
4190 }
4191 
4192 class PolylineAnnotation extends MarkupAnnotation {
4193   constructor(params) {
4194     super(params);
4195 
4196     const { dict, xref } = params;
4197     this.data.annotationType = AnnotationType.POLYLINE;
4198     this.data.hasOwnCanvas = this.data.noRotate;
4199     this.data.noHTML = false;
4200     this.data.vertices = [];
4201 
4202     if (
4203       (typeof PDFJSDev === "undefined" || !PDFJSDev.test("MOZCENTRAL")) &&
4204       !(this instanceof PolygonAnnotation)
4205     ) {
4206       // Only meaningful for polyline annotations.
4207       this.setLineEndings(dict.getArray("LE"));
4208       this.data.lineEndings = this.lineEndings;
4209     }
4210 
4211     // The vertices array is an array of numbers representing the alternating
4212     // horizontal and vertical coordinates, respectively, of each vertex.
4213     // Convert this to an array of objects with x and y coordinates.
4214     const rawVertices = dict.getArray("Vertices");
4215     if (!Array.isArray(rawVertices)) {
4216       return;
4217     }
4218     for (let i = 0, ii = rawVertices.length; i < ii; i += 2) {
4219       this.data.vertices.push({
4220         x: rawVertices[i],
4221         y: rawVertices[i + 1],
4222       });
4223     }
4224 
4225     if (!this.appearance) {
4226       // The default stroke color is black.
4227       const strokeColor = this.color ? getPdfColorArray(this.color) : [0, 0, 0];
4228       const strokeAlpha = dict.get("CA");
4229 
4230       const borderWidth = this.borderStyle.width || 1,
4231         borderAdjust = 2 * borderWidth;
4232 
4233       // If the /Rect-entry is empty/wrong, create a fallback rectangle so that
4234       // we get similar rendering/highlighting behaviour as in Adobe Reader.
4235       const bbox = [Infinity, Infinity, -Infinity, -Infinity];
4236       for (const vertex of this.data.vertices) {
4237         bbox[0] = Math.min(bbox[0], vertex.x - borderAdjust);
4238         bbox[1] = Math.min(bbox[1], vertex.y - borderAdjust);
4239         bbox[2] = Math.max(bbox[2], vertex.x + borderAdjust);
4240         bbox[3] = Math.max(bbox[3], vertex.y + borderAdjust);
4241       }
4242       if (!Util.intersect(this.rectangle, bbox)) {
4243         this.rectangle = bbox;
4244       }
4245 
4246       this._setDefaultAppearance({
4247         xref,
4248         extra: `${borderWidth} w`,
4249         strokeColor,
4250         strokeAlpha,
4251         pointsCallback: (buffer, points) => {
4252           const vertices = this.data.vertices;
4253           for (let i = 0, ii = vertices.length; i < ii; i++) {
4254             buffer.push(
4255               `${vertices[i].x} ${vertices[i].y} ${i === 0 ? "m" : "l"}`
4256             );
4257           }
4258           buffer.push("S");
4259           return [points[0].x, points[1].x, points[3].y, points[1].y];
4260         },
4261       });
4262     }
4263   }
4264 }
4265 
4266 class PolygonAnnotation extends PolylineAnnotation {
4267   constructor(params) {
4268     // Polygons are specific forms of polylines, so reuse their logic.
4269     super(params);
4270 
4271     this.data.annotationType = AnnotationType.POLYGON;
4272   }
4273 }
4274 
4275 class CaretAnnotation extends MarkupAnnotation {
4276   constructor(params) {
4277     super(params);
4278 
4279     this.data.annotationType = AnnotationType.CARET;
4280   }
4281 }
4282 
4283 class InkAnnotation extends MarkupAnnotation {
4284   constructor(params) {
4285     super(params);
4286 
4287     this.data.hasOwnCanvas = this.data.noRotate;
4288     this.data.noHTML = false;
4289 
4290     const { dict, xref } = params;
4291     this.data.annotationType = AnnotationType.INK;
4292     this.data.inkLists = [];
4293 
4294     const rawInkLists = dict.getArray("InkList");
4295     if (!Array.isArray(rawInkLists)) {
4296       return;
4297     }
4298     for (let i = 0, ii = rawInkLists.length; i < ii; ++i) {
4299       // The raw ink lists array contains arrays of numbers representing
4300       // the alternating horizontal and vertical coordinates, respectively,
4301       // of each vertex. Convert this to an array of objects with x and y
4302       // coordinates.
4303       this.data.inkLists.push([]);
4304       for (let j = 0, jj = rawInkLists[i].length; j < jj; j += 2) {
4305         this.data.inkLists[i].push({
4306           x: xref.fetchIfRef(rawInkLists[i][j]),
4307           y: xref.fetchIfRef(rawInkLists[i][j + 1]),
4308         });
4309       }
4310     }
4311 
4312     if (!this.appearance) {
4313       // The default stroke color is black.
4314       const strokeColor = this.color ? getPdfColorArray(this.color) : [0, 0, 0];
4315       const strokeAlpha = dict.get("CA");
4316 
4317       const borderWidth = this.borderStyle.width || 1,
4318         borderAdjust = 2 * borderWidth;
4319 
4320       // If the /Rect-entry is empty/wrong, create a fallback rectangle so that
4321       // we get similar rendering/highlighting behaviour as in Adobe Reader.
4322       const bbox = [Infinity, Infinity, -Infinity, -Infinity];
4323       for (const inkLists of this.data.inkLists) {
4324         for (const vertex of inkLists) {
4325           bbox[0] = Math.min(bbox[0], vertex.x - borderAdjust);
4326           bbox[1] = Math.min(bbox[1], vertex.y - borderAdjust);
4327           bbox[2] = Math.max(bbox[2], vertex.x + borderAdjust);
4328           bbox[3] = Math.max(bbox[3], vertex.y + borderAdjust);
4329         }
4330       }
4331       if (!Util.intersect(this.rectangle, bbox)) {
4332         this.rectangle = bbox;
4333       }
4334 
4335       this._setDefaultAppearance({
4336         xref,
4337         extra: `${borderWidth} w`,
4338         strokeColor,
4339         strokeAlpha,
4340         pointsCallback: (buffer, points) => {
4341           // According to the specification, see "12.5.6.13 Ink Annotations":
4342           //   When drawn, the points shall be connected by straight lines or
4343           //   curves in an implementation-dependent way.
4344           // In order to simplify things, we utilize straight lines for now.
4345           for (const inkList of this.data.inkLists) {
4346             for (let i = 0, ii = inkList.length; i < ii; i++) {
4347               buffer.push(
4348                 `${inkList[i].x} ${inkList[i].y} ${i === 0 ? "m" : "l"}`
4349               );
4350             }
4351             buffer.push("S");
4352           }
4353           return [points[0].x, points[1].x, points[3].y, points[1].y];
4354         },
4355       });
4356     }
4357   }
4358 
4359   static createNewDict(annotation, xref, { apRef, ap }) {
4360     const { color, opacity, paths, outlines, rect, rotation, thickness } =
4361       annotation;
4362     const ink = new Dict(xref);
4363     ink.set("Type", Name.get("Annot"));
4364     ink.set("Subtype", Name.get("Ink"));
4365     ink.set("CreationDate", `D:${getModificationDate()}`);
4366     ink.set("Rect", rect);
4367     ink.set("InkList", outlines?.points || paths.map(p => p.points));
4368     ink.set("F", 4);
4369     ink.set("Rotate", rotation);
4370 
4371     if (outlines) {
4372       // Free highlight.
4373       // There's nothing about this in the spec, but it's used when highlighting
4374       // in Edge's viewer. Acrobat takes into account this parameter to indicate
4375       // that the Ink is used for highlighting.
4376       ink.set("IT", Name.get("InkHighlight"));
4377     }
4378 
4379     // Line thickness.
4380     const bs = new Dict(xref);
4381     ink.set("BS", bs);
4382     bs.set("W", thickness);
4383 
4384     // Color.
4385     ink.set(
4386       "C",
4387       Array.from(color, c => c / 255)
4388     );
4389 
4390     // Opacity.
4391     ink.set("CA", opacity);
4392 
4393     const n = new Dict(xref);
4394     ink.set("AP", n);
4395 
4396     if (apRef) {
4397       n.set("N", apRef);
4398     } else {
4399       n.set("N", ap);
4400     }
4401 
4402     return ink;
4403   }
4404 
4405   static async createNewAppearanceStream(annotation, xref, params) {
4406     if (annotation.outlines) {
4407       return this.createNewAppearanceStreamForHighlight(
4408         annotation,
4409         xref,
4410         params
4411       );
4412     }
4413     const { color, rect, paths, thickness, opacity } = annotation;
4414 
4415     const appearanceBuffer = [
4416       `${thickness} w 1 J 1 j`,
4417       `${getPdfColor(color, /* isFill */ false)}`,
4418     ];
4419 
4420     if (opacity !== 1) {
4421       appearanceBuffer.push("/R0 gs");
4422     }
4423 
4424     const buffer = [];
4425     for (const { bezier } of paths) {
4426       buffer.length = 0;
4427       buffer.push(
4428         `${numberToString(bezier[0])} ${numberToString(bezier[1])} m`
4429       );
4430       if (bezier.length === 2) {
4431         buffer.push(
4432           `${numberToString(bezier[0])} ${numberToString(bezier[1])} l S`
4433         );
4434       } else {
4435         for (let i = 2, ii = bezier.length; i < ii; i += 6) {
4436           const curve = bezier
4437             .slice(i, i + 6)
4438             .map(numberToString)
4439             .join(" ");
4440           buffer.push(`${curve} c`);
4441         }
4442         buffer.push("S");
4443       }
4444       appearanceBuffer.push(buffer.join("\n"));
4445     }
4446     const appearance = appearanceBuffer.join("\n");
4447 
4448     const appearanceStreamDict = new Dict(xref);
4449     appearanceStreamDict.set("FormType", 1);
4450     appearanceStreamDict.set("Subtype", Name.get("Form"));
4451     appearanceStreamDict.set("Type", Name.get("XObject"));
4452     appearanceStreamDict.set("BBox", rect);
4453     appearanceStreamDict.set("Length", appearance.length);
4454 
4455     if (opacity !== 1) {
4456       const resources = new Dict(xref);
4457       const extGState = new Dict(xref);
4458       const r0 = new Dict(xref);
4459       r0.set("CA", opacity);
4460       r0.set("Type", Name.get("ExtGState"));
4461       extGState.set("R0", r0);
4462       resources.set("ExtGState", extGState);
4463       appearanceStreamDict.set("Resources", resources);
4464     }
4465 
4466     const ap = new StringStream(appearance);
4467     ap.dict = appearanceStreamDict;
4468 
4469     return ap;
4470   }
4471 
4472   static async createNewAppearanceStreamForHighlight(annotation, xref, params) {
4473     const {
4474       color,
4475       rect,
4476       outlines: { outline },
4477       opacity,
4478     } = annotation;
4479     const appearanceBuffer = [
4480       `${getPdfColor(color, /* isFill */ true)}`,
4481       "/R0 gs",
4482     ];
4483 
4484     appearanceBuffer.push(
4485       `${numberToString(outline[4])} ${numberToString(outline[5])} m`
4486     );
4487     for (let i = 6, ii = outline.length; i < ii; i += 6) {
4488       if (isNaN(outline[i]) || outline[i] === null) {
4489         appearanceBuffer.push(
4490           `${numberToString(outline[i + 4])} ${numberToString(
4491             outline[i + 5]
4492           )} l`
4493         );
4494       } else {
4495         const curve = outline
4496           .slice(i, i + 6)
4497           .map(numberToString)
4498           .join(" ");
4499         appearanceBuffer.push(`${curve} c`);
4500       }
4501     }
4502     appearanceBuffer.push("h f");
4503     const appearance = appearanceBuffer.join("\n");
4504 
4505     const appearanceStreamDict = new Dict(xref);
4506     appearanceStreamDict.set("FormType", 1);
4507     appearanceStreamDict.set("Subtype", Name.get("Form"));
4508     appearanceStreamDict.set("Type", Name.get("XObject"));
4509     appearanceStreamDict.set("BBox", rect);
4510     appearanceStreamDict.set("Length", appearance.length);
4511 
4512     const resources = new Dict(xref);
4513     const extGState = new Dict(xref);
4514     resources.set("ExtGState", extGState);
4515     appearanceStreamDict.set("Resources", resources);
4516     const r0 = new Dict(xref);
4517     extGState.set("R0", r0);
4518     r0.set("BM", Name.get("Multiply"));
4519 
4520     if (opacity !== 1) {
4521       r0.set("ca", opacity);
4522       r0.set("Type", Name.get("ExtGState"));
4523     }
4524 
4525     const ap = new StringStream(appearance);
4526     ap.dict = appearanceStreamDict;
4527 
4528     return ap;
4529   }
4530 }
4531 
4532 class HighlightAnnotation extends MarkupAnnotation {
4533   constructor(params) {
4534     super(params);
4535 
4536     const { dict, xref } = params;
4537     this.data.annotationType = AnnotationType.HIGHLIGHT;
4538 
4539     const quadPoints = (this.data.quadPoints = getQuadPoints(dict, null));
4540     if (quadPoints) {
4541       const resources = this.appearance?.dict.get("Resources");
4542 
4543       if (!this.appearance || !resources?.has("ExtGState")) {
4544         if (this.appearance) {
4545           // Workaround for cases where there's no /ExtGState-entry directly
4546           // available, e.g. when the appearance stream contains a /XObject of
4547           // the /Form-type, since that causes the highlighting to completely
4548           // obscure the PDF content below it (fixes issue13242.pdf).
4549           warn("HighlightAnnotation - ignoring built-in appearance stream.");
4550         }
4551         // Default color is yellow in Acrobat Reader
4552         const fillColor = this.color ? getPdfColorArray(this.color) : [1, 1, 0];
4553         const fillAlpha = dict.get("CA");
4554 
4555         this._setDefaultAppearance({
4556           xref,
4557           fillColor,
4558           blendMode: "Multiply",
4559           fillAlpha,
4560           pointsCallback: (buffer, points) => {
4561             buffer.push(
4562               `${points[0].x} ${points[0].y} m`,
4563               `${points[1].x} ${points[1].y} l`,
4564               `${points[3].x} ${points[3].y} l`,
4565               `${points[2].x} ${points[2].y} l`,
4566               "f"
4567             );
4568             return [points[0].x, points[1].x, points[3].y, points[1].y];
4569           },
4570         });
4571       }
4572     } else {
4573       this.data.popupRef = null;
4574     }
4575   }
4576 
4577   static createNewDict(annotation, xref, { apRef, ap }) {
4578     const { color, opacity, rect, rotation, user, quadPoints } = annotation;
4579     const highlight = new Dict(xref);
4580     highlight.set("Type", Name.get("Annot"));
4581     highlight.set("Subtype", Name.get("Highlight"));
4582     highlight.set("CreationDate", `D:${getModificationDate()}`);
4583     highlight.set("Rect", rect);
4584     highlight.set("F", 4);
4585     highlight.set("Border", [0, 0, 0]);
4586     highlight.set("Rotate", rotation);
4587     highlight.set("QuadPoints", quadPoints);
4588 
4589     // Color.
4590     highlight.set(
4591       "C",
4592       Array.from(color, c => c / 255)
4593     );
4594 
4595     // Opacity.
4596     highlight.set("CA", opacity);
4597 
4598     if (user) {
4599       highlight.set(
4600         "T",
4601         isAscii(user) ? user : stringToUTF16String(user, /* bigEndian = */ true)
4602       );
4603     }
4604 
4605     if (apRef || ap) {
4606       const n = new Dict(xref);
4607       highlight.set("AP", n);
4608       n.set("N", apRef || ap);
4609     }
4610 
4611     return highlight;
4612   }
4613 
4614   static async createNewAppearanceStream(annotation, xref, params) {
4615     const { color, rect, outlines, opacity } = annotation;
4616 
4617     const appearanceBuffer = [
4618       `${getPdfColor(color, /* isFill */ true)}`,
4619       "/R0 gs",
4620     ];
4621 
4622     const buffer = [];
4623     for (const outline of outlines) {
4624       buffer.length = 0;
4625       buffer.push(
4626         `${numberToString(outline[0])} ${numberToString(outline[1])} m`
4627       );
4628       for (let i = 2, ii = outline.length; i < ii; i += 2) {
4629         buffer.push(
4630           `${numberToString(outline[i])} ${numberToString(outline[i + 1])} l`
4631         );
4632       }
4633       buffer.push("h");
4634       appearanceBuffer.push(buffer.join("\n"));
4635     }
4636     appearanceBuffer.push("f*");
4637     const appearance = appearanceBuffer.join("\n");
4638 
4639     const appearanceStreamDict = new Dict(xref);
4640     appearanceStreamDict.set("FormType", 1);
4641     appearanceStreamDict.set("Subtype", Name.get("Form"));
4642     appearanceStreamDict.set("Type", Name.get("XObject"));
4643     appearanceStreamDict.set("BBox", rect);
4644     appearanceStreamDict.set("Length", appearance.length);
4645 
4646     const resources = new Dict(xref);
4647     const extGState = new Dict(xref);
4648     resources.set("ExtGState", extGState);
4649     appearanceStreamDict.set("Resources", resources);
4650     const r0 = new Dict(xref);
4651     extGState.set("R0", r0);
4652     r0.set("BM", Name.get("Multiply"));
4653 
4654     if (opacity !== 1) {
4655       r0.set("ca", opacity);
4656       r0.set("Type", Name.get("ExtGState"));
4657     }
4658 
4659     const ap = new StringStream(appearance);
4660     ap.dict = appearanceStreamDict;
4661 
4662     return ap;
4663   }
4664 }
4665 
4666 class UnderlineAnnotation extends MarkupAnnotation {
4667   constructor(params) {
4668     super(params);
4669 
4670     const { dict, xref } = params;
4671     this.data.annotationType = AnnotationType.UNDERLINE;
4672 
4673     const quadPoints = (this.data.quadPoints = getQuadPoints(dict, null));
4674     if (quadPoints) {
4675       if (!this.appearance) {
4676         // Default color is black
4677         const strokeColor = this.color
4678           ? getPdfColorArray(this.color)
4679           : [0, 0, 0];
4680         const strokeAlpha = dict.get("CA");
4681 
4682         // The values 0.571 and 1.3 below corresponds to what Acrobat is doing.
4683         this._setDefaultAppearance({
4684           xref,
4685           extra: "[] 0 d 0.571 w",
4686           strokeColor,
4687           strokeAlpha,
4688           pointsCallback: (buffer, points) => {
4689             buffer.push(
4690               `${points[2].x} ${points[2].y + 1.3} m`,
4691               `${points[3].x} ${points[3].y + 1.3} l`,
4692               "S"
4693             );
4694             return [points[0].x, points[1].x, points[3].y, points[1].y];
4695           },
4696         });
4697       }
4698     } else {
4699       this.data.popupRef = null;
4700     }
4701   }
4702 }
4703 
4704 class SquigglyAnnotation extends MarkupAnnotation {
4705   constructor(params) {
4706     super(params);
4707 
4708     const { dict, xref } = params;
4709     this.data.annotationType = AnnotationType.SQUIGGLY;
4710 
4711     const quadPoints = (this.data.quadPoints = getQuadPoints(dict, null));
4712     if (quadPoints) {
4713       if (!this.appearance) {
4714         // Default color is black
4715         const strokeColor = this.color
4716           ? getPdfColorArray(this.color)
4717           : [0, 0, 0];
4718         const strokeAlpha = dict.get("CA");
4719 
4720         this._setDefaultAppearance({
4721           xref,
4722           extra: "[] 0 d 1 w",
4723           strokeColor,
4724           strokeAlpha,
4725           pointsCallback: (buffer, points) => {
4726             const dy = (points[0].y - points[2].y) / 6;
4727             let shift = dy;
4728             let x = points[2].x;
4729             const y = points[2].y;
4730             const xEnd = points[3].x;
4731             buffer.push(`${x} ${y + shift} m`);
4732             do {
4733               x += 2;
4734               shift = shift === 0 ? dy : 0;
4735               buffer.push(`${x} ${y + shift} l`);
4736             } while (x < xEnd);
4737             buffer.push("S");
4738             return [points[2].x, xEnd, y - 2 * dy, y + 2 * dy];
4739           },
4740         });
4741       }
4742     } else {
4743       this.data.popupRef = null;
4744     }
4745   }
4746 }
4747 
4748 class StrikeOutAnnotation extends MarkupAnnotation {
4749   constructor(params) {
4750     super(params);
4751 
4752     const { dict, xref } = params;
4753     this.data.annotationType = AnnotationType.STRIKEOUT;
4754 
4755     const quadPoints = (this.data.quadPoints = getQuadPoints(dict, null));
4756     if (quadPoints) {
4757       if (!this.appearance) {
4758         // Default color is black
4759         const strokeColor = this.color
4760           ? getPdfColorArray(this.color)
4761           : [0, 0, 0];
4762         const strokeAlpha = dict.get("CA");
4763 
4764         this._setDefaultAppearance({
4765           xref,
4766           extra: "[] 0 d 1 w",
4767           strokeColor,
4768           strokeAlpha,
4769           pointsCallback: (buffer, points) => {
4770             buffer.push(
4771               `${(points[0].x + points[2].x) / 2} ` +
4772                 `${(points[0].y + points[2].y) / 2} m`,
4773               `${(points[1].x + points[3].x) / 2} ` +
4774                 `${(points[1].y + points[3].y) / 2} l`,
4775               "S"
4776             );
4777             return [points[0].x, points[1].x, points[3].y, points[1].y];
4778           },
4779         });
4780       }
4781     } else {
4782       this.data.popupRef = null;
4783     }
4784   }
4785 }
4786 
4787 class StampAnnotation extends MarkupAnnotation {
4788   constructor(params) {
4789     super(params);
4790 
4791     this.data.annotationType = AnnotationType.STAMP;
4792     this.data.hasOwnCanvas = this.data.noRotate;
4793     this.data.noHTML = false;
4794   }
4795 
4796   static async createImage(bitmap, xref) {
4797     // TODO: when printing, we could have a specific internal colorspace
4798     // (e.g. something like DeviceRGBA) in order avoid any conversion (i.e. no
4799     // jpeg, no rgba to rgb conversion, etc...)
4800 
4801     const { width, height } = bitmap;
4802     const canvas = new OffscreenCanvas(width, height);
4803     const ctx = canvas.getContext("2d", { alpha: true });
4804 
4805     // Draw the image and get the data in order to extract the transparency.
4806     ctx.drawImage(bitmap, 0, 0);
4807     const data = ctx.getImageData(0, 0, width, height).data;
4808     const buf32 = new Uint32Array(data.buffer);
4809     const hasAlpha = buf32.some(
4810       FeatureTest.isLittleEndian
4811         ? x => x >>> 24 !== 0xff
4812         : x => (x & 0xff) !== 0xff
4813     );
4814 
4815     if (hasAlpha) {
4816       // Redraw the image on a white background in order to remove the thin gray
4817       // line which can appear when exporting to jpeg.
4818       ctx.fillStyle = "white";
4819       ctx.fillRect(0, 0, width, height);
4820       ctx.drawImage(bitmap, 0, 0);
4821     }
4822 
4823     const jpegBufferPromise = canvas
4824       .convertToBlob({ type: "image/jpeg", quality: 1 })
4825       .then(blob => blob.arrayBuffer());
4826 
4827     const xobjectName = Name.get("XObject");
4828     const imageName = Name.get("Image");
4829     const image = new Dict(xref);
4830     image.set("Type", xobjectName);
4831     image.set("Subtype", imageName);
4832     image.set("BitsPerComponent", 8);
4833     image.set("ColorSpace", Name.get("DeviceRGB"));
4834     image.set("Filter", Name.get("DCTDecode"));
4835     image.set("BBox", [0, 0, width, height]);
4836     image.set("Width", width);
4837     image.set("Height", height);
4838 
4839     let smaskStream = null;
4840     if (hasAlpha) {
4841       const alphaBuffer = new Uint8Array(buf32.length);
4842       if (FeatureTest.isLittleEndian) {
4843         for (let i = 0, ii = buf32.length; i < ii; i++) {
4844           alphaBuffer[i] = buf32[i] >>> 24;
4845         }
4846       } else {
4847         for (let i = 0, ii = buf32.length; i < ii; i++) {
4848           alphaBuffer[i] = buf32[i] & 0xff;
4849         }
4850       }
4851 
4852       const smask = new Dict(xref);
4853       smask.set("Type", xobjectName);
4854       smask.set("Subtype", imageName);
4855       smask.set("BitsPerComponent", 8);
4856       smask.set("ColorSpace", Name.get("DeviceGray"));
4857       smask.set("Width", width);
4858       smask.set("Height", height);
4859 
4860       smaskStream = new Stream(alphaBuffer, 0, 0, smask);
4861     }
4862     const imageStream = new Stream(await jpegBufferPromise, 0, 0, image);
4863 
4864     return {
4865       imageStream,
4866       smaskStream,
4867       width,
4868       height,
4869     };
4870   }
4871 
4872   static createNewDict(annotation, xref, { apRef, ap }) {
4873     const { rect, rotation, user } = annotation;
4874     const stamp = new Dict(xref);
4875     stamp.set("Type", Name.get("Annot"));
4876     stamp.set("Subtype", Name.get("Stamp"));
4877     stamp.set("CreationDate", `D:${getModificationDate()}`);
4878     stamp.set("Rect", rect);
4879     stamp.set("F", 4);
4880     stamp.set("Border", [0, 0, 0]);
4881     stamp.set("Rotate", rotation);
4882 
4883     if (user) {
4884       stamp.set(
4885         "T",
4886         isAscii(user) ? user : stringToUTF16String(user, /* bigEndian = */ true)
4887       );
4888     }
4889 
4890     if (apRef || ap) {
4891       const n = new Dict(xref);
4892       stamp.set("AP", n);
4893 
4894       if (apRef) {
4895         n.set("N", apRef);
4896       } else {
4897         n.set("N", ap);
4898       }
4899     }
4900 
4901     return stamp;
4902   }
4903 
4904   static async createNewAppearanceStream(annotation, xref, params) {
4905     const { rotation } = annotation;
4906     const { imageRef, width, height } = params.image;
4907     const resources = new Dict(xref);
4908     const xobject = new Dict(xref);
4909     resources.set("XObject", xobject);
4910     xobject.set("Im0", imageRef);
4911     const appearance = `q ${width} 0 0 ${height} 0 0 cm /Im0 Do Q`;
4912 
4913     const appearanceStreamDict = new Dict(xref);
4914     appearanceStreamDict.set("FormType", 1);
4915     appearanceStreamDict.set("Subtype", Name.get("Form"));
4916     appearanceStreamDict.set("Type", Name.get("XObject"));
4917     appearanceStreamDict.set("BBox", [0, 0, width, height]);
4918     appearanceStreamDict.set("Resources", resources);
4919 
4920     if (rotation) {
4921       const matrix = getRotationMatrix(rotation, width, height);
4922       appearanceStreamDict.set("Matrix", matrix);
4923     }
4924 
4925     const ap = new StringStream(appearance);
4926     ap.dict = appearanceStreamDict;
4927 
4928     return ap;
4929   }
4930 }
4931 
4932 class FileAttachmentAnnotation extends MarkupAnnotation {
4933   constructor(params) {
4934     super(params);
4935 
4936     const { dict, xref } = params;
4937     const file = new FileSpec(dict.get("FS"), xref);
4938 
4939     this.data.annotationType = AnnotationType.FILEATTACHMENT;
4940     this.data.hasOwnCanvas = this.data.noRotate;
4941     this.data.noHTML = false;
4942     this.data.file = file.serializable;
4943 
4944     const name = dict.get("Name");
4945     this.data.name =
4946       name instanceof Name ? stringToPDFString(name.name) : "PushPin";
4947 
4948     const fillAlpha = dict.get("ca");
4949     this.data.fillAlpha =
4950       typeof fillAlpha === "number" && fillAlpha >= 0 && fillAlpha <= 1
4951         ? fillAlpha
4952         : null;
4953   }
4954 }
4955 
4956 export {
4957   Annotation,
4958   AnnotationBorderStyle,
4959   AnnotationFactory,
4960   getQuadPoints,
4961   MarkupAnnotation,
4962   PopupAnnotation,
4963 };
File:
src/core/core_utils.js
1 /* Copyright 2019 Mozilla Foundation
2  *
3  * Licensed under the Apache License, Version 2.0 (the "License");
4  * you may not use this file except in compliance with the License.
5  * You may obtain a copy of the License at
6  *
7  *     http://www.apache.org/licenses/LICENSE-2.0
8  *
9  * Unless required by applicable law or agreed to in writing, software
10  * distributed under the License is distributed on an "AS IS" BASIS,
11  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
12  * See the License for the specific language governing permissions and
13  * limitations under the License.
14  */
15 
16 import {
17   AnnotationEditorPrefix,
18   assert,
19   BaseException,
20   objectSize,
21   stringToPDFString,
22   warn,
23 } from "../shared/util.js";
24 import { Dict, isName, Ref, RefSet } from "./primitives.js";
25 import { BaseStream } from "./base_stream.js";
26 
27 const PDF_VERSION_REGEXP = /^[1-9]\.\d$/;
28 
29 function getLookupTableFactory(initializer) {
30   let lookup;
31   return function () {
32     if (initializer) {
33       lookup = Object.create(null);
34       initializer(lookup);
35       initializer = null;
36     }
37     return lookup;
38   };
39 }
40 
41 class MissingDataException extends BaseException {
42   constructor(begin, end) {
43     super(`Missing data [${begin}, ${end})`, "MissingDataException");
44     this.begin = begin;
45     this.end = end;
46   }
47 }
48 
49 class ParserEOFException extends BaseException {
50   constructor(msg) {
51     super(msg, "ParserEOFException");
52   }
53 }
54 
55 class XRefEntryException extends BaseException {
56   constructor(msg) {
57     super(msg, "XRefEntryException");
58   }
59 }
60 
61 class XRefParseException extends BaseException {
62   constructor(msg) {
63     super(msg, "XRefParseException");
64   }
65 }
66 
67 /**
68  * Combines multiple ArrayBuffers into a single Uint8Array.
69  * @param {Array<ArrayBuffer>} arr - An array of ArrayBuffers.
70  * @returns {Uint8Array}
71  */
72 function arrayBuffersToBytes(arr) {
73   if (typeof PDFJSDev === "undefined" || PDFJSDev.test("TESTING")) {
74     for (const item of arr) {
75       assert(
76         item instanceof ArrayBuffer,
77         "arrayBuffersToBytes - expected an ArrayBuffer."
78       );
79     }
80   }
81   const length = arr.length;
82   if (length === 0) {
83     return new Uint8Array(0);
84   }
85   if (length === 1) {
86     return new Uint8Array(arr[0]);
87   }
88   let dataLength = 0;
89   for (let i = 0; i < length; i++) {
90     dataLength += arr[i].byteLength;
91   }
92   const data = new Uint8Array(dataLength);
93   let pos = 0;
94   for (let i = 0; i < length; i++) {
95     const item = new Uint8Array(arr[i]);
96     data.set(item, pos);
97     pos += item.byteLength;
98   }
99   return data;
100 }
101 
102 /**
103  * Get the value of an inheritable property.
104  *
105  * If the PDF specification explicitly lists a property in a dictionary as
106  * inheritable, then the value of the property may be present in the dictionary
107  * itself or in one or more parents of the dictionary.
108  *
109  * If the key is not found in the tree, `undefined` is returned. Otherwise,
110  * the value for the key is returned or, if `stopWhenFound` is `false`, a list
111  * of values is returned.
112  *
113  * @param {Dict} dict - Dictionary from where to start the traversal.
114  * @param {string} key - The key of the property to find the value for.
115  * @param {boolean} getArray - Whether or not the value should be fetched as an
116  *   array. The default value is `false`.
117  * @param {boolean} stopWhenFound - Whether or not to stop the traversal when
118  *   the key is found. If set to `false`, we always walk up the entire parent
119  *   chain, for example to be able to find `\Resources` placed on multiple
120  *   levels of the tree. The default value is `true`.
121  */
122 function getInheritableProperty({
123   dict,
124   key,
125   getArray = false,
126   stopWhenFound = true,
127 }) {
128   let values;
129   const visited = new RefSet();
130 
131   while (dict instanceof Dict && !(dict.objId && visited.has(dict.objId))) {
132     if (dict.objId) {
133       visited.put(dict.objId);
134     }
135     const value = getArray ? dict.getArray(key) : dict.get(key);
136     if (value !== undefined) {
137       if (stopWhenFound) {
138         return value;
139       }
140       (values ||= []).push(value);
141     }
142     dict = dict.get("Parent");
143   }
144   return values;
145 }
146 
147 // prettier-ignore
148 const ROMAN_NUMBER_MAP = [
149   "", "C", "CC", "CCC", "CD", "D", "DC", "DCC", "DCCC", "CM",
150   "", "X", "XX", "XXX", "XL", "L", "LX", "LXX", "LXXX", "XC",
151   "", "I", "II", "III", "IV", "V", "VI", "VII", "VIII", "IX"
152 ];
153 
154 /**
155  * Converts positive integers to (upper case) Roman numerals.
156  * @param {number} number - The number that should be converted.
157  * @param {boolean} lowerCase - Indicates if the result should be converted
158  *   to lower case letters. The default value is `false`.
159  * @returns {string} The resulting Roman number.
160  */
161 function toRomanNumerals(number, lowerCase = false) {
162   assert(
163     Number.isInteger(number) && number > 0,
164     "The number should be a positive integer."
165   );
166   const romanBuf = [];
167   let pos;
168   // Thousands
169   while (number >= 1000) {
170     number -= 1000;
171     romanBuf.push("M");
172   }
173   // Hundreds
174   pos = (number / 100) | 0;
175   number %= 100;
176   romanBuf.push(ROMAN_NUMBER_MAP[pos]);
177   // Tens
178   pos = (number / 10) | 0;
179   number %= 10;
180   romanBuf.push(ROMAN_NUMBER_MAP[10 + pos]);
181   // Ones
182   romanBuf.push(ROMAN_NUMBER_MAP[20 + number]); // eslint-disable-line unicorn/no-array-push-push
183 
184   const romanStr = romanBuf.join("");
185   return lowerCase ? romanStr.toLowerCase() : romanStr;
186 }
187 
188 // Calculate the base 2 logarithm of the number `x`. This differs from the
189 // native function in the sense that it returns the ceiling value and that it
190 // returns 0 instead of `Infinity`/`NaN` for `x` values smaller than/equal to 0.
191 function log2(x) {
192   if (x <= 0) {
193     return 0;
194   }
195   return Math.ceil(Math.log2(x));
196 }
197 
198 function readInt8(data, offset) {
199   return (data[offset] << 24) >> 24;
200 }
201 
202 function readUint16(data, offset) {
203   return (data[offset] << 8) | data[offset + 1];
204 }
205 
206 function readUint32(data, offset) {
207   return (
208     ((data[offset] << 24) |
209       (data[offset + 1] << 16) |
210       (data[offset + 2] << 8) |
211       data[offset + 3]) >>>
212     0
213   );
214 }
215 
216 // Checks if ch is one of the following characters: SPACE, TAB, CR or LF.
217 function isWhiteSpace(ch) {
218   return ch === 0x20 || ch === 0x09 || ch === 0x0d || ch === 0x0a;
219 }
220 
221 /**
222  * AcroForm field names use an array like notation to refer to
223  * repeated XFA elements e.g. foo.bar[nnn].
224  * see: XFA Spec Chapter 3 - Repeated Elements
225  *
226  * @param {string} path - XFA path name.
227  * @returns {Array} - Array of Objects with the name and pos of
228  * each part of the path.
229  */
230 function parseXFAPath(path) {
231   const positionPattern = /(.+)\[(\d+)\]$/;
232   return path.split(".").map(component => {
233     const m = component.match(positionPattern);
234     if (m) {
235       return { name: m[1], pos: parseInt(m[2], 10) };
236     }
237     return { name: component, pos: 0 };
238   });
239 }
240 
241 function escapePDFName(str) {
242   const buffer = [];
243   let start = 0;
244   for (let i = 0, ii = str.length; i < ii; i++) {
245     const char = str.charCodeAt(i);
246     // Whitespace or delimiters aren't regular chars, so escape them.
247     if (
248       char < 0x21 ||
249       char > 0x7e ||
250       char === 0x23 /* # */ ||
251       char === 0x28 /* ( */ ||
252       char === 0x29 /* ) */ ||
253       char === 0x3c /* < */ ||
254       char === 0x3e /* > */ ||
255       char === 0x5b /* [ */ ||
256       char === 0x5d /* ] */ ||
257       char === 0x7b /* { */ ||
258       char === 0x7d /* } */ ||
259       char === 0x2f /* / */ ||
260       char === 0x25 /* % */
261     ) {
262       if (start < i) {
263         buffer.push(str.substring(start, i));
264       }
265       buffer.push(`#${char.toString(16)}`);
266       start = i + 1;
267     }
268   }
269 
270   if (buffer.length === 0) {
271     return str;
272   }
273 
274   if (start < str.length) {
275     buffer.push(str.substring(start, str.length));
276   }
277 
278   return buffer.join("");
279 }
280 
281 // Replace "(", ")", "\n", "\r" and "\" by "\(", "\)", "\\n", "\\r" and "\\"
282 // in order to write it in a PDF file.
283 function escapeString(str) {
284   return str.replaceAll(/([()\\\n\r])/g, match => {
285     if (match === "\n") {
286       return "\\n";
287     } else if (match === "\r") {
288       return "\\r";
289     }
290     return `\\${match}`;
291   });
292 }
293 
294 function _collectJS(entry, xref, list, parents) {
295   if (!entry) {
296     return;
297   }
298 
299   let parent = null;
300   if (entry instanceof Ref) {
301     if (parents.has(entry)) {
302       // If we've already found entry then we've a cycle.
303       return;
304     }
305     parent = entry;
306     parents.put(parent);
307     entry = xref.fetch(entry);
308   }
309   if (Array.isArray(entry)) {
310     for (const element of entry) {
311       _collectJS(element, xref, list, parents);
312     }
313   } else if (entry instanceof Dict) {
314     if (isName(entry.get("S"), "JavaScript")) {
315       const js = entry.get("JS");
316       let code;
317       if (js instanceof BaseStream) {
318         code = js.getString();
319       } else if (typeof js === "string") {
320         code = js;
321       }
322       code &&= stringToPDFString(code).replaceAll("\x00", "");
323       if (code) {
324         list.push(code);
325       }
326     }
327     _collectJS(entry.getRaw("Next"), xref, list, parents);
328   }
329 
330   if (parent) {
331     parents.remove(parent);
332   }
333 }
334 
335 function collectActions(xref, dict, eventType) {
336   const actions = Object.create(null);
337   const additionalActionsDicts = getInheritableProperty({
338     dict,
339     key: "AA",
340     stopWhenFound: false,
341   });
342   if (additionalActionsDicts) {
343     // additionalActionsDicts contains dicts from ancestors
344     // as they're found in the tree from bottom to top.
345     // So the dicts are visited in reverse order to guarantee
346     // that actions from elder ancestors will be overwritten
347     // by ones from younger ancestors.
348     for (let i = additionalActionsDicts.length - 1; i >= 0; i--) {
349       const additionalActions = additionalActionsDicts[i];
350       if (!(additionalActions instanceof Dict)) {
351         continue;
352       }
353       for (const key of additionalActions.getKeys()) {
354         const action = eventType[key];
355         if (!action) {
356           continue;
357         }
358         const actionDict = additionalActions.getRaw(key);
359         const parents = new RefSet();
360         const list = [];
361         _collectJS(actionDict, xref, list, parents);
362         if (list.length > 0) {
363           actions[action] = list;
364         }
365       }
366     }
367   }
368   // Collect the Action if any (we may have one on pushbutton).
369   if (dict.has("A")) {
370     const actionDict = dict.get("A");
371     const parents = new RefSet();
372     const list = [];
373     _collectJS(actionDict, xref, list, parents);
374     if (list.length > 0) {
375       actions.Action = list;
376     }
377   }
378   return objectSize(actions) > 0 ? actions : null;
379 }
380 
381 const XMLEntities = {
382   /* < */ 0x3c: "&lt;",
383   /* > */ 0x3e: "&gt;",
384   /* & */ 0x26: "&amp;",
385   /* " */ 0x22: "&quot;",
386   /* ' */ 0x27: "&apos;",
387 };
388 
389 function encodeToXmlString(str) {
390   const buffer = [];
391   let start = 0;
392   for (let i = 0, ii = str.length; i < ii; i++) {
393     const char = str.codePointAt(i);
394     if (0x20 <= char && char <= 0x7e) {
395       // ascii
396       const entity = XMLEntities[char];
397       if (entity) {
398         if (start < i) {
399           buffer.push(str.substring(start, i));
400         }
401         buffer.push(entity);
402         start = i + 1;
403       }
404     } else {
405       if (start < i) {
406         buffer.push(str.substring(start, i));
407       }
408       buffer.push(`&#x${char.toString(16).toUpperCase()};`);
409       if (char > 0xd7ff && (char < 0xe000 || char > 0xfffd)) {
410         // char is represented by two u16
411         i++;
412       }
413       start = i + 1;
414     }
415   }
416 
417   if (buffer.length === 0) {
418     return str;
419   }
420   if (start < str.length) {
421     buffer.push(str.substring(start, str.length));
422   }
423   return buffer.join("");
424 }
425 
426 function validateFontName(fontFamily, mustWarn = false) {
427   // See https://developer.mozilla.org/en-US/docs/Web/CSS/string.
428   const m = /^("|').*("|')$/.exec(fontFamily);
429   if (m && m[1] === m[2]) {
430     const re = new RegExp(`[^\\\\]${m[1]}`);
431     if (re.test(fontFamily.slice(1, -1))) {
432       if (mustWarn) {
433         warn(`FontFamily contains unescaped ${m[1]}: ${fontFamily}.`);
434       }
435       return false;
436     }
437   } else {
438     // See https://developer.mozilla.org/en-US/docs/Web/CSS/custom-ident.
439     for (const ident of fontFamily.split(/[ \t]+/)) {
440       if (/^(\d|(-(\d|-)))/.test(ident) || !/^[\w-\\]+$/.test(ident)) {
441         if (mustWarn) {
442           warn(`FontFamily contains invalid <custom-ident>: ${fontFamily}.`);
443         }
444         return false;
445       }
446     }
447   }
448   return true;
449 }
450 
451 function validateCSSFont(cssFontInfo) {
452   // See https://developer.mozilla.org/en-US/docs/Web/CSS/font-style.
453   const DEFAULT_CSS_FONT_OBLIQUE = "14";
454   // See https://developer.mozilla.org/en-US/docs/Web/CSS/font-weight.
455   const DEFAULT_CSS_FONT_WEIGHT = "400";
456   const CSS_FONT_WEIGHT_VALUES = new Set([
457     "100",
458     "200",
459     "300",
460     "400",
461     "500",
462     "600",
463     "700",
464     "800",
465     "900",
466     "1000",
467     "normal",
468     "bold",
469     "bolder",
470     "lighter",
471   ]);
472 
473   const { fontFamily, fontWeight, italicAngle } = cssFontInfo;
474 
475   if (!validateFontName(fontFamily, true)) {
476     return false;
477   }
478 
479   const weight = fontWeight ? fontWeight.toString() : "";
480   cssFontInfo.fontWeight = CSS_FONT_WEIGHT_VALUES.has(weight)
481     ? weight
482     : DEFAULT_CSS_FONT_WEIGHT;
483 
484   const angle = parseFloat(italicAngle);
485   cssFontInfo.italicAngle =
486     isNaN(angle) || angle < -90 || angle > 90
487       ? DEFAULT_CSS_FONT_OBLIQUE
488       : italicAngle.toString();
489 
490   return true;
491 }
492 
493 function recoverJsURL(str) {
494   // Attempt to recover valid URLs from `JS` entries with certain
495   // white-listed formats:
496   //  - window.open('http://example.com')
497   //  - app.launchURL('http://example.com', true)
498   //  - xfa.host.gotoURL('http://example.com')
499   const URL_OPEN_METHODS = ["app.launchURL", "window.open", "xfa.host.gotoURL"];
500   const regex = new RegExp(
501     "^\\s*(" +
502       URL_OPEN_METHODS.join("|").replaceAll(".", "\\.") +
503       ")\\((?:'|\")([^'\"]*)(?:'|\")(?:,\\s*(\\w+)\\)|\\))",
504     "i"
505   );
506 
507   const jsUrl = regex.exec(str);
508   if (jsUrl?.[2]) {
509     const url = jsUrl[2];
510     let newWindow = false;
511 
512     if (jsUrl[3] === "true" && jsUrl[1] === "app.launchURL") {
513       newWindow = true;
514     }
515     return { url, newWindow };
516   }
517 
518   return null;
519 }
520 
521 function numberToString(value) {
522   if (Number.isInteger(value)) {
523     return value.toString();
524   }
525 
526   const roundedValue = Math.round(value * 100);
527   if (roundedValue % 100 === 0) {
528     return (roundedValue / 100).toString();
529   }
530 
531   if (roundedValue % 10 === 0) {
532     return value.toFixed(1);
533   }
534 
535   return value.toFixed(2);
536 }
537 
538 function getNewAnnotationsMap(annotationStorage) {
539   if (!annotationStorage) {
540     return null;
541   }
542   const newAnnotationsByPage = new Map();
543   // The concept of page in a XFA is very different, so
544   // editing is just not implemented.
545   for (const [key, value] of annotationStorage) {
546     if (!key.startsWith(AnnotationEditorPrefix)) {
547       continue;
548     }
549     let annotations = newAnnotationsByPage.get(value.pageIndex);
550     if (!annotations) {
551       annotations = [];
552       newAnnotationsByPage.set(value.pageIndex, annotations);
553     }
554     annotations.push(value);
555   }
556   return newAnnotationsByPage.size > 0 ? newAnnotationsByPage : null;
557 }
558 
559 function isAscii(str) {
560   return /^[\x00-\x7F]*$/.test(str);
561 }
562 
563 function stringToUTF16HexString(str) {
564   const buf = [];
565   for (let i = 0, ii = str.length; i < ii; i++) {
566     const char = str.charCodeAt(i);
567     buf.push(
568       ((char >> 8) & 0xff).toString(16).padStart(2, "0"),
569       (char & 0xff).toString(16).padStart(2, "0")
570     );
571   }
572   return buf.join("");
573 }
574 
575 function stringToUTF16String(str, bigEndian = false) {
576   const buf = [];
577   if (bigEndian) {
578     buf.push("\xFE\xFF");
579   }
580   for (let i = 0, ii = str.length; i < ii; i++) {
581     const char = str.charCodeAt(i);
582     buf.push(
583       String.fromCharCode((char >> 8) & 0xff),
584       String.fromCharCode(char & 0xff)
585     );
586   }
587   return buf.join("");
588 }
589 
590 function getRotationMatrix(rotation, width, height) {
591   switch (rotation) {
592     case 90:
593       return [0, 1, -1, 0, width, 0];
594     case 180:
595       return [-1, 0, 0, -1, width, height];
596     case 270:
597       return [0, -1, 1, 0, 0, height];
598     default:
599       throw new Error("Invalid rotation");
600   }
601 }
602 
603 export {
604   arrayBuffersToBytes,
605   collectActions,
606   encodeToXmlString,
607   escapePDFName,
608   escapeString,
609   getInheritableProperty,
610   getLookupTableFactory,
611   getNewAnnotationsMap,
612   getRotationMatrix,
613   isAscii,
614   isWhiteSpace,
615   log2,
616   MissingDataException,
617   numberToString,
618   ParserEOFException,
619   parseXFAPath,
620   PDF_VERSION_REGEXP,
621   readInt8,
622   readUint16,
623   readUint32,
624   recoverJsURL,
625   stringToUTF16HexString,
626   stringToUTF16String,
627   toRomanNumerals,
628   validateCSSFont,
629   validateFontName,
630   XRefEntryException,
631   XRefParseException,
632 };
File:
src/core/default_appearance.js
1 /* Copyright 2020 Mozilla Foundation
2  *
3  * Licensed under the Apache License, Version 2.0 (the "License");
4  * you may not use this file except in compliance with the License.
5  * You may obtain a copy of the License at
6  *
7  *     http://www.apache.org/licenses/LICENSE-2.0
8  *
9  * Unless required by applicable law or agreed to in writing, software
10  * distributed under the License is distributed on an "AS IS" BASIS,
11  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
12  * See the License for the specific language governing permissions and
13  * limitations under the License.
14  */
15 
16 import { Dict, Name } from "./primitives.js";
17 import {
18   escapePDFName,
19   getRotationMatrix,
20   numberToString,
21   stringToUTF16HexString,
22 } from "./core_utils.js";
23 import {
24   LINE_DESCENT_FACTOR,
25   LINE_FACTOR,
26   OPS,
27   shadow,
28   warn,
29 } from "../shared/util.js";
30 import { ColorSpace } from "./colorspace.js";
31 import { EvaluatorPreprocessor } from "./evaluator.js";
32 import { LocalColorSpaceCache } from "./image_utils.js";
33 import { PDFFunctionFactory } from "./function.js";
34 import { StringStream } from "./stream.js";
35 
36 class DefaultAppearanceEvaluator extends EvaluatorPreprocessor {
37   constructor(str) {
38     super(new StringStream(str));
39   }
40 
41   parse() {
42     const operation = {
43       fn: 0,
44       args: [],
45     };
46     const result = {
47       fontSize: 0,
48       fontName: "",
49       fontColor: /* black = */ new Uint8ClampedArray(3),
50     };
51 
52     try {
53       while (true) {
54         operation.args.length = 0; // Ensure that `args` it's always reset.
55 
56         if (!this.read(operation)) {
57           break;
58         }
59         if (this.savedStatesDepth !== 0) {
60           continue; // Don't get info in save/restore sections.
61         }
62         const { fn, args } = operation;
63 
64         switch (fn | 0) {
65           case OPS.setFont:
66             const [fontName, fontSize] = args;
67             if (fontName instanceof Name) {
68               result.fontName = fontName.name;
69             }
70             if (typeof fontSize === "number" && fontSize > 0) {
71               result.fontSize = fontSize;
72             }
73             break;
74           case OPS.setFillRGBColor:
75             ColorSpace.singletons.rgb.getRgbItem(args, 0, result.fontColor, 0);
76             break;
77           case OPS.setFillGray:
78             ColorSpace.singletons.gray.getRgbItem(args, 0, result.fontColor, 0);
79             break;
80           case OPS.setFillCMYKColor:
81             ColorSpace.singletons.cmyk.getRgbItem(args, 0, result.fontColor, 0);
82             break;
83         }
84       }
85     } catch (reason) {
86       warn(`parseDefaultAppearance - ignoring errors: "${reason}".`);
87     }
88 
89     return result;
90   }
91 }
92 
93 // Parse DA to extract font and color information.
94 function parseDefaultAppearance(str) {
95   return new DefaultAppearanceEvaluator(str).parse();
96 }
97 
98 class AppearanceStreamEvaluator extends EvaluatorPreprocessor {
99   constructor(stream, evaluatorOptions, xref) {
100     super(stream);
101     this.stream = stream;
102     this.evaluatorOptions = evaluatorOptions;
103     this.xref = xref;
104 
105     this.resources = stream.dict?.get("Resources");
106   }
107 
108   parse() {
109     const operation = {
110       fn: 0,
111       args: [],
112     };
113     let result = {
114       scaleFactor: 1,
115       fontSize: 0,
116       fontName: "",
117       fontColor: /* black = */ new Uint8ClampedArray(3),
118       fillColorSpace: ColorSpace.singletons.gray,
119     };
120     let breakLoop = false;
121     const stack = [];
122 
123     try {
124       while (true) {
125         operation.args.length = 0; // Ensure that `args` it's always reset.
126 
127         if (breakLoop || !this.read(operation)) {
128           break;
129         }
130         const { fn, args } = operation;
131 
132         switch (fn | 0) {
133           case OPS.save:
134             stack.push({
135               scaleFactor: result.scaleFactor,
136               fontSize: result.fontSize,
137               fontName: result.fontName,
138               fontColor: result.fontColor.slice(),
139               fillColorSpace: result.fillColorSpace,
140             });
141             break;
142           case OPS.restore:
143             result = stack.pop() || result;
144             break;
145           case OPS.setTextMatrix:
146             result.scaleFactor *= Math.hypot(args[0], args[1]);
147             break;
148           case OPS.setFont:
149             const [fontName, fontSize] = args;
150             if (fontName instanceof Name) {
151               result.fontName = fontName.name;
152             }
153             if (typeof fontSize === "number" && fontSize > 0) {
154               result.fontSize = fontSize * result.scaleFactor;
155             }
156             break;
157           case OPS.setFillColorSpace:
158             result.fillColorSpace = ColorSpace.parse({
159               cs: args[0],
160               xref: this.xref,
161               resources: this.resources,
162               pdfFunctionFactory: this._pdfFunctionFactory,
163               localColorSpaceCache: this._localColorSpaceCache,
164             });
165             break;
166           case OPS.setFillColor:
167             const cs = result.fillColorSpace;
168             cs.getRgbItem(args, 0, result.fontColor, 0);
169             break;
170           case OPS.setFillRGBColor:
171             ColorSpace.singletons.rgb.getRgbItem(args, 0, result.fontColor, 0);
172             break;
173           case OPS.setFillGray:
174             ColorSpace.singletons.gray.getRgbItem(args, 0, result.fontColor, 0);
175             break;
176           case OPS.setFillCMYKColor:
177             ColorSpace.singletons.cmyk.getRgbItem(args, 0, result.fontColor, 0);
178             break;
179           case OPS.showText:
180           case OPS.showSpacedText:
181           case OPS.nextLineShowText:
182           case OPS.nextLineSetSpacingShowText:
183             breakLoop = true;
184             break;
185         }
186       }
187     } catch (reason) {
188       warn(`parseAppearanceStream - ignoring errors: "${reason}".`);
189     }
190     this.stream.reset();
191     delete result.scaleFactor;
192     delete result.fillColorSpace;
193 
194     return result;
195   }
196 
197   get _localColorSpaceCache() {
198     return shadow(this, "_localColorSpaceCache", new LocalColorSpaceCache());
199   }
200 
201   get _pdfFunctionFactory() {
202     const pdfFunctionFactory = new PDFFunctionFactory({
203       xref: this.xref,
204       isEvalSupported: this.evaluatorOptions.isEvalSupported,
205     });
206     return shadow(this, "_pdfFunctionFactory", pdfFunctionFactory);
207   }
208 }
209 
210 // Parse appearance stream to extract font and color information.
211 // It returns the font properties used to render the first text object.
212 function parseAppearanceStream(stream, evaluatorOptions, xref) {
213   return new AppearanceStreamEvaluator(stream, evaluatorOptions, xref).parse();
214 }
215 
216 function getPdfColor(color, isFill) {
217   if (color[0] === color[1] && color[1] === color[2]) {
218     const gray = color[0] / 255;
219     return `${numberToString(gray)} ${isFill ? "g" : "G"}`;
220   }
221   return (
222     Array.from(color, c => numberToString(c / 255)).join(" ") +
223     ` ${isFill ? "rg" : "RG"}`
224   );
225 }
226 
227 // Create default appearance string from some information.
228 function createDefaultAppearance({ fontSize, fontName, fontColor }) {
229   return `/${escapePDFName(fontName)} ${fontSize} Tf ${getPdfColor(
230     fontColor,
231     /* isFill */ true
232   )}`;
233 }
234 
235 class FakeUnicodeFont {
236   constructor(xref, fontFamily) {
237     this.xref = xref;
238     this.widths = null;
239     this.firstChar = Infinity;
240     this.lastChar = -Infinity;
241     this.fontFamily = fontFamily;
242 
243     const canvas = new OffscreenCanvas(1, 1);
244     this.ctxMeasure = canvas.getContext("2d");
245 
246     if (!FakeUnicodeFont._fontNameId) {
247       FakeUnicodeFont._fontNameId = 1;
248     }
249     this.fontName = Name.get(
250       `InvalidPDFjsFont_${fontFamily}_${FakeUnicodeFont._fontNameId++}`
251     );
252   }
253 
254   get toUnicodeRef() {
255     if (!FakeUnicodeFont._toUnicodeRef) {
256       const toUnicode = `/CIDInit /ProcSet findresource begin
257 12 dict begin
258 begincmap
259 /CIDSystemInfo
260 << /Registry (Adobe)
261 /Ordering (UCS) /Supplement 0 >> def
262 /CMapName /Adobe-Identity-UCS def
263 /CMapType 2 def
264 1 begincodespacerange
265 <0000> <FFFF>
266 endcodespacerange
267 1 beginbfrange
268 <0000> <FFFF> <0000>
269 endbfrange
270 endcmap CMapName currentdict /CMap defineresource pop end end`;
271       const toUnicodeStream = (FakeUnicodeFont.toUnicodeStream =
272         new StringStream(toUnicode));
273       const toUnicodeDict = new Dict(this.xref);
274       toUnicodeStream.dict = toUnicodeDict;
275       toUnicodeDict.set("Length", toUnicode.length);
276       FakeUnicodeFont._toUnicodeRef =
277         this.xref.getNewPersistentRef(toUnicodeStream);
278     }
279 
280     return FakeUnicodeFont._toUnicodeRef;
281   }
282 
283   get fontDescriptorRef() {
284     if (!FakeUnicodeFont._fontDescriptorRef) {
285       const fontDescriptor = new Dict(this.xref);
286       fontDescriptor.set("Type", Name.get("FontDescriptor"));
287       fontDescriptor.set("FontName", this.fontName);
288       fontDescriptor.set("FontFamily", "MyriadPro Regular");
289       fontDescriptor.set("FontBBox", [0, 0, 0, 0]);
290       fontDescriptor.set("FontStretch", Name.get("Normal"));
291       fontDescriptor.set("FontWeight", 400);
292       fontDescriptor.set("ItalicAngle", 0);
293 
294       FakeUnicodeFont._fontDescriptorRef =
295         this.xref.getNewPersistentRef(fontDescriptor);
296     }
297 
298     return FakeUnicodeFont._fontDescriptorRef;
299   }
300 
301   get descendantFontRef() {
302     const descendantFont = new Dict(this.xref);
303     descendantFont.set("BaseFont", this.fontName);
304     descendantFont.set("Type", Name.get("Font"));
305     descendantFont.set("Subtype", Name.get("CIDFontType0"));
306     descendantFont.set("CIDToGIDMap", Name.get("Identity"));
307     descendantFont.set("FirstChar", this.firstChar);
308     descendantFont.set("LastChar", this.lastChar);
309     descendantFont.set("FontDescriptor", this.fontDescriptorRef);
310     descendantFont.set("DW", 1000);
311 
312     const widths = [];
313     const chars = [...this.widths.entries()].sort();
314     let currentChar = null;
315     let currentWidths = null;
316     for (const [char, width] of chars) {
317       if (!currentChar) {
318         currentChar = char;
319         currentWidths = [width];
320         continue;
321       }
322       if (char === currentChar + currentWidths.length) {
323         currentWidths.push(width);
324       } else {
325         widths.push(currentChar, currentWidths);
326         currentChar = char;
327         currentWidths = [width];
328       }
329     }
330 
331     if (currentChar) {
332       widths.push(currentChar, currentWidths);
333     }
334 
335     descendantFont.set("W", widths);
336 
337     const cidSystemInfo = new Dict(this.xref);
338     cidSystemInfo.set("Ordering", "Identity");
339     cidSystemInfo.set("Registry", "Adobe");
340     cidSystemInfo.set("Supplement", 0);
341     descendantFont.set("CIDSystemInfo", cidSystemInfo);
342 
343     return this.xref.getNewPersistentRef(descendantFont);
344   }
345 
346   get baseFontRef() {
347     const baseFont = new Dict(this.xref);
348     baseFont.set("BaseFont", this.fontName);
349     baseFont.set("Type", Name.get("Font"));
350     baseFont.set("Subtype", Name.get("Type0"));
351     baseFont.set("Encoding", Name.get("Identity-H"));
352     baseFont.set("DescendantFonts", [this.descendantFontRef]);
353     baseFont.set("ToUnicode", this.toUnicodeRef);
354 
355     return this.xref.getNewPersistentRef(baseFont);
356   }
357 
358   get resources() {
359     const resources = new Dict(this.xref);
360     const font = new Dict(this.xref);
361     font.set(this.fontName.name, this.baseFontRef);
362     resources.set("Font", font);
363 
364     return resources;
365   }
366 
367   _createContext() {
368     this.widths = new Map();
369     this.ctxMeasure.font = `1000px ${this.fontFamily}`;
370 
371     return this.ctxMeasure;
372   }
373 
374   createFontResources(text) {
375     const ctx = this._createContext();
376     for (const line of text.split(/\r\n?|\n/)) {
377       for (const char of line.split("")) {
378         const code = char.charCodeAt(0);
379         if (this.widths.has(code)) {
380           continue;
381         }
382         const metrics = ctx.measureText(char);
383         const width = Math.ceil(metrics.width);
384         this.widths.set(code, width);
385         this.firstChar = Math.min(code, this.firstChar);
386         this.lastChar = Math.max(code, this.lastChar);
387       }
388     }
389 
390     return this.resources;
391   }
392 
393   static getFirstPositionInfo(rect, rotation, fontSize) {
394     // Get the position of the first char in the rect.
395     const [x1, y1, x2, y2] = rect;
396     let w = x2 - x1;
397     let h = y2 - y1;
398 
399     if (rotation % 180 !== 0) {
400       [w, h] = [h, w];
401     }
402     const lineHeight = LINE_FACTOR * fontSize;
403     const lineDescent = LINE_DESCENT_FACTOR * fontSize;
404 
405     return {
406       coords: [0, h + lineDescent - lineHeight],
407       bbox: [0, 0, w, h],
408       matrix:
409         rotation !== 0 ? getRotationMatrix(rotation, h, lineHeight) : undefined,
410     };
411   }
412 
413   createAppearance(text, rect, rotation, fontSize, bgColor, strokeAlpha) {
414     const ctx = this._createContext();
415     const lines = [];
416     let maxWidth = -Infinity;
417     for (const line of text.split(/\r\n?|\n/)) {
418       lines.push(line);
419       // The line width isn't the sum of the char widths, because in some
420       // languages, like arabic, it'd be wrong because of ligatures.
421       const lineWidth = ctx.measureText(line).width;
422       maxWidth = Math.max(maxWidth, lineWidth);
423       for (const char of line.split("")) {
424         const code = char.charCodeAt(0);
425         let width = this.widths.get(code);
426         if (width === undefined) {
427           const metrics = ctx.measureText(char);
428           width = Math.ceil(metrics.width);
429           this.widths.set(code, width);
430           this.firstChar = Math.min(code, this.firstChar);
431           this.lastChar = Math.max(code, this.lastChar);
432         }
433       }
434     }
435     maxWidth *= fontSize / 1000;
436 
437     const [x1, y1, x2, y2] = rect;
438     let w = x2 - x1;
439     let h = y2 - y1;
440 
441     if (rotation % 180 !== 0) {
442       [w, h] = [h, w];
443     }
444 
445     let hscale = 1;
446     if (maxWidth > w) {
447       hscale = w / maxWidth;
448     }
449     let vscale = 1;
450     const lineHeight = LINE_FACTOR * fontSize;
451     const lineDescent = LINE_DESCENT_FACTOR * fontSize;
452     const maxHeight = lineHeight * lines.length;
453     if (maxHeight > h) {
454       vscale = h / maxHeight;
455     }
456     const fscale = Math.min(hscale, vscale);
457     const newFontSize = fontSize * fscale;
458 
459     const buffer = [
460       "q",
461       `0 0 ${numberToString(w)} ${numberToString(h)} re W n`,
462       `BT`,
463       `1 0 0 1 0 ${numberToString(h + lineDescent)} Tm 0 Tc ${getPdfColor(
464         bgColor,
465         /* isFill */ true
466       )}`,
467       `/${this.fontName.name} ${numberToString(newFontSize)} Tf`,
468     ];
469 
470     const { resources } = this;
471     strokeAlpha =
472       typeof strokeAlpha === "number" && strokeAlpha >= 0 && strokeAlpha <= 1
473         ? strokeAlpha
474         : 1;
475 
476     if (strokeAlpha !== 1) {
477       buffer.push("/R0 gs");
478       const extGState = new Dict(this.xref);
479       const r0 = new Dict(this.xref);
480       r0.set("ca", strokeAlpha);
481       r0.set("CA", strokeAlpha);
482       r0.set("Type", Name.get("ExtGState"));
483       extGState.set("R0", r0);
484       resources.set("ExtGState", extGState);
485     }
486 
487     const vShift = numberToString(lineHeight);
488     for (const line of lines) {
489       buffer.push(`0 -${vShift} Td <${stringToUTF16HexString(line)}> Tj`);
490     }
491     buffer.push("ET", "Q");
492     const appearance = buffer.join("\n");
493 
494     const appearanceStreamDict = new Dict(this.xref);
495     appearanceStreamDict.set("Subtype", Name.get("Form"));
496     appearanceStreamDict.set("Type", Name.get("XObject"));
497     appearanceStreamDict.set("BBox", [0, 0, w, h]);
498     appearanceStreamDict.set("Length", appearance.length);
499     appearanceStreamDict.set("Resources", resources);
500 
501     if (rotation) {
502       const matrix = getRotationMatrix(rotation, w, h);
503       appearanceStreamDict.set("Matrix", matrix);
504     }
505 
506     const ap = new StringStream(appearance);
507     ap.dict = appearanceStreamDict;
508 
509     return ap;
510   }
511 }
512 
513 export {
514   createDefaultAppearance,
515   FakeUnicodeFont,
516   getPdfColor,
517   parseAppearanceStream,
518   parseDefaultAppearance,
519 };
</code>

Test file:
<test_file>
File:
test/unit/annotation_spec.js
/* Copyright 2017 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import {
  Annotation,
  AnnotationBorderStyle,
  AnnotationFactory,
  getQuadPoints,
  MarkupAnnotation,
} from "../../src/core/annotation.js";
import {
  AnnotationBorderStyleType,
  AnnotationEditorType,
  AnnotationFieldFlag,
  AnnotationFlag,
  AnnotationType,
  isNodeJS,
  OPS,
  RenderingIntentFlag,
  stringToBytes,
  stringToUTF8String,
} from "../../src/shared/util.js";
import {
  CMAP_URL,
  createIdFactory,
  STANDARD_FONT_DATA_URL,
  XRefMock,
} from "./test_utils.js";
import {
  DefaultCMapReaderFactory,
  DefaultStandardFontDataFactory,
} from "../../src/display/api.js";
import { Dict, Name, Ref, RefSetCache } from "../../src/core/primitives.js";
import { Lexer, Parser } from "../../src/core/parser.js";
import { PartialEvaluator } from "../../src/core/evaluator.js";
import { StringStream } from "../../src/core/stream.js";
import { WorkerTask } from "../../src/core/worker.js";
</test_file>

Your task:
You are a software tester at pdf.js.
1. Examine the existing test file. You may reuse any imports, helpers or setup blocks it already has.
2. Write exactly one javascript test `it("...", async () => {...})` block.
3. Your test must fail on the code before the patch, and pass after, hence the test will verify that the patch resolves the issue.
4. The test must be self-contained and to-the-point.
5. If you need something new use only the provided imports (respect the paths exactly how they are given) by importing dynamically for compatibility with Node.js — no new dependencies. You can use the PDF file for testing as follows:
const { getDocument } = await import('../../src/display/api.js');
const { buildGetDocumentParams } = await import('./test_utils.js');
const loadingTask = getDocument(buildGetDocumentParams('bug1669097.pdf'))
6. Return only the javascript code for the new `it(...)` block (no comments or explanations).

Example structure:
it("should <describe behavior>", async () => {
  const { example } = await import("../../src/core/example.js");
  <initialize required variables>;
  <define expected variable>;
  <generate actual variables>;
  <compare expected with actual>;
});

