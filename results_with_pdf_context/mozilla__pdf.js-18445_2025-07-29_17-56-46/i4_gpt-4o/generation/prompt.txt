Before you begin:
- Keep going until the job is completely solved — don’t stop halfway.
- If you’re unsure about the behavior, reread the provided patch carefully; do not hallucinate.
- Plan your approach before writing code by reflecting on whether the test truly fails before and passes after.

Issue:
<issue>
[Bug]: Cannot read properties of null (reading 'save')
### Attach (recommended) or Link to PDF file

[《武汉大学校友月报》9月号总第170期(1).pdf](https://github.com/user-attachments/files/16264442/9.170.1.pdf)


### Web browser and its version

edge

### Operating system and its version

mac

### PDF.js version

v4.5.84 

### Is the bug present in the latest PDF.js version?

Yes

### Is a browser extension

No

### Steps to reproduce the problem

1.Use the official online preview link to preview the uploaded file.

### What is the expected behavior?

![Uploading image.png…]()


### What went wrong?

![image](https://github.com/user-attachments/assets/7e8a9825-0a03-46a6-8768-184ec90608b3)


### Link to a viewer

_No response_

### Additional context

_No response_
</issue>

PDF File:
<pdf>
issue18444.pdf
</pdf>

Patch:
<patch>
diff --git a/src/display/canvas.js b/src/display/canvas.js
--- a/src/display/canvas.js
+++ b/src/display/canvas.js
@@ -1006,6 +1006,7 @@ class CanvasGraphics {
       this.restore();
     }
 
+    this.current.activeSMask = null;
     this.ctx.restore();
 
     if (this.transparentCanvas) {


</patch>

Imports:
<imports>
Available Packages
Dev Dependencies:
- @babel/core: ^7.24.8
- @babel/preset-env: ^7.24.8
- @babel/runtime: ^7.24.8
- @fluent/bundle: ^0.18.0
- @fluent/dom: ^0.10.0
- @jazzer.js/core: ^2.1.0
- @metalsmith/layouts: ^2.7.0
- @metalsmith/markdown: ^1.10.0
- autoprefixer: ^10.4.19
- babel-loader: ^9.1.3
- caniuse-lite: ^1.0.30001641
- canvas: ^2.11.2
- core-js: ^3.37.1
- cross-env: ^7.0.3
- eslint: ^8.57.0
- eslint-config-prettier: ^9.1.0
- eslint-plugin-fetch-options: ^0.0.5
- eslint-plugin-html: ^8.1.1
- eslint-plugin-import: ^2.29.1
- eslint-plugin-jasmine: ^4.2.0
- eslint-plugin-json: ^3.1.0
- eslint-plugin-mozilla: ^3.7.4
- eslint-plugin-no-unsanitized: ^4.0.2
- eslint-plugin-prettier: ^5.1.3
- eslint-plugin-sort-exports: ^0.9.1
- eslint-plugin-unicorn: ^54.0.0
- globals: ^15.8.0
- gulp: ^5.0.0
- gulp-cli: ^3.0.0
- gulp-postcss: ^10.0.0
- gulp-rename: ^2.0.0
- gulp-replace: ^1.1.4
- gulp-zip: ^6.0.0
- highlight.js: ^11.10.0
- jasmine: ^5.1.0
- jsdoc: ^4.0.3
- jstransformer-nunjucks: ^1.2.0
- metalsmith: ^2.6.3
- metalsmith-html-relative: ^2.0.1
- ordered-read-streams: ^2.0.0
- path2d: ^0.2.1
- pngjs: ^7.0.0
- postcss: ^8.4.39
- postcss-dark-theme-class: ^1.3.0
- postcss-dir-pseudo-class: ^8.0.1
- postcss-discard-comments: ^7.0.1
- postcss-nesting: ^12.1.5
- prettier: ^3.3.3
- puppeteer: ^22.13.0
- streamqueue: ^1.1.2
- stylelint: ^16.7.0
- stylelint-prettier: ^5.0.0
- terser-webpack-plugin: ^5.3.10
- tsc-alias: ^1.8.10
- ttest: ^4.0.0
- typescript: ^5.5.3
- vinyl: ^3.0.0
- webpack: ^5.93.0
- webpack-stream: ^7.0.0
- yargs: ^17.7.2

Engines:
- node: >=18

Available Relative Imports:
- `../../src/core/annotation.js`: Annotation, AnnotationBorderStyle, AnnotationFactory, MarkupAnnotation, getQuadPoints
- `../../src/core/bidi.js`: bidi
- `../../src/core/cff_parser.js`: CFFCharset, CFFCompiler, CFFFDSelect, CFFParser, CFFStrings
- `../../src/core/cmap.js`: CMap, CMapFactory, IdentityCMap
- `../../src/core/colorspace.js`: ColorSpace
- `../../src/core/core_utils.js`: arrayBuffersToBytes, encodeToXmlString, escapePDFName, escapeString, getInheritableProperty, getSizeInBytes, isAscii, isWhiteSpace, log2, numberToString, parseXFAPath, recoverJsURL, stringToUTF16HexString, stringToUTF16String, toRomanNumerals, validateCSSFont
- `../../src/core/crypto.js`: AES128Cipher, AES256Cipher, ARCFourCipher, CipherTransformFactory, PDF17, PDF20, calculateMD5, calculateSHA256, calculateSHA384, calculateSHA512
- `../../src/core/default_appearance.js`: createDefaultAppearance, parseAppearanceStream, parseDefaultAppearance
- `../../src/core/document.js`: PDFDocument, Page
- `../../src/core/encodings.js`: getEncoding
- `../../src/core/evaluator.js`: PartialEvaluator
- `../../src/core/flate_stream.js`: FlateStream
- `../../src/core/font_substitutions.js`: getFontSubstitution
- `../../src/core/fonts_utils.js`: SEAC_ANALYSIS_ENABLED
- `../../src/core/function.js`: PDFFunctionFactory, PostScriptCompiler, PostScriptEvaluator
- `../../src/core/glyphlist.js`: getDingbatsGlyphsUnicode, getGlyphsUnicode
- `../../src/core/image_utils.js`: GlobalImageCache, LocalColorSpaceCache
- `../../src/core/jbig2.js`: Jbig2Error, Jbig2Image
- `../../src/core/jpg.js`: JpegError, JpegImage
- `../../src/core/jpx.js`: JpxError, JpxImage
- `../../src/core/metadata_parser.js`: MetadataParser
- `../../src/core/operator_list.js`: OperatorList
- `../../src/core/parser.js`: Lexer, Linearization, Parser
- `../../src/core/predictor_stream.js`: PredictorStream
- `../../src/core/primitives.js`: Cmd, Dict, EOF, Name, Ref, RefSet, RefSetCache, isCmd, isDict, isName, isRefsEqual
- `../../src/core/ps_parser.js`: PostScriptLexer, PostScriptParser
- `../../src/core/stream.js`: NullStream, Stream, StringStream
- `../../src/core/type1_parser.js`: Type1Parser
- `../../src/core/unicode.js`: getCharUnicodeCategory, getUnicodeForGlyph, getUnicodeRangeFor, mapSpecialUnicodeValues
- `../../src/core/worker.js`: WorkerMessageHandler, WorkerTask
- `../../src/core/writer.js`: incrementalUpdate, writeDict
- `../../src/core/xfa/bind.js`: Binder
- `../../src/core/xfa/data.js`: DataHandler
- `../../src/core/xfa/factory.js`: XFAFactory
- `../../src/core/xfa/formcalc_lexer.js`: Lexer, TOKEN, Token
- `../../src/core/xfa/formcalc_parser.js`: Errors, Parser
- `../../src/core/xfa/parser.js`: XFAParser
- `../../src/core/xfa/som.js`: searchNode
- `../../src/core/xfa/symbol_utils.js`: $dump, $getChildren, $getChildrenByClass, $getChildrenByName, $text, $uid
- `../../src/core/xml_parser.js`: SimpleXMLParser, XMLParserBase
- `../../src/display/annotation_layer.js`: AnnotationLayer
- `../../src/display/annotation_storage.js`: AnnotationStorage
- `../../src/display/api.js`: DefaultCMapReaderFactory, DefaultCanvasFactory, DefaultStandardFontDataFactory, LoopbackPort, PDFDataRangeTransport, PDFDocumentLoadingTask, PDFDocumentProxy, PDFPageProxy, PDFWorker, PDFWorkerUtil, RenderTask, build, getDocument, version
- `../../src/display/display_utils.js`: DOMCanvasFactory, DOMSVGFactory, PDFDateString, PageViewport, PixelsPerInch, RenderingCancelledException, StatTimer, fetchData, getFilenameFromUrl, getPdfFilenameFromUrl, getXfaPageViewport, isDataScheme, isPdfFile, isValidFetchUrl, noContextMenu, setLayerDimensions
- `../../src/display/draw_layer.js`: DrawLayer
- `../../src/display/editor/annotation_editor_layer.js`: AnnotationEditorLayer
- `../../src/display/editor/color_picker.js`: ColorPicker
- `../../src/display/editor/tools.js`: AnnotationEditorUIManager, CommandManager
- `../../src/display/fetch_stream.js`: PDFFetchStream
- `../../src/display/metadata.js`: Metadata
- `../../src/display/network.js`: PDFNetworkStream
- `../../src/display/network_utils.js`: createResponseStatusError, extractFilenameFromHeader, validateRangeRequestCapabilities, validateResponseStatus
- `../../src/display/node_stream.js`: PDFNodeStream
- `../../src/display/node_utils.js`: NodePackages
- `../../src/display/text_layer.js`: TextLayer
- `../../src/display/worker_options.js`: GlobalWorkerOptions
- `../../src/display/xfa_layer.js`: XfaLayer
- `../../src/shared/message_handler.js`: MessageHandler
- `../../src/shared/murmurhash3.js`: MurmurHash3_64
- `../../src/shared/util.js`: AbortException, AnnotationBorderStyleType, AnnotationEditorParamsType, AnnotationEditorType, AnnotationFieldFlag, AnnotationFlag, AnnotationMode, AnnotationType, BaseException, CMapCompressionType, FeatureTest, FormatError, ImageKind, InvalidPDFException, MissingPDFException, OPS, PasswordException, PasswordResponses, PermissionFlag, RenderingIntentFlag, UnexpectedResponseException, UnknownErrorException, Util, VerbosityLevel, assert, bytesToString, createValidAbsoluteUrl, getModificationDate, getVerbosityLevel, isNodeJS, normalizeUnicode, objectSize, setVerbosityLevel, shadow, string32, stringToBytes, stringToPDFString, stringToUTF8String
- `../../web/annotation_layer_builder.js`: AnnotationLayerBuilder
- `../../web/app_options.js`: AppOptions, OptionKind
- `../../web/download_manager.js`: DownloadManager
- `../../web/event_utils.js`: EventBus, WaitOnType, waitOnEventOrTimeout
- `../../web/genericl10n.js`: GenericL10n
- `../../web/pdf_find_controller.js`: FindState, PDFFindController
- `../../web/pdf_find_utils.js`: CharacterType, getCharacterType
- `../../web/pdf_history.js`: PDFHistory, isDestArraysEqual, isDestHashesEqual
- `../../web/pdf_link_service.js`: LinkTarget, PDFLinkService, SimpleLinkService
- `../../web/pdf_page_view.js`: PDFPageView
- `../../web/pdf_scripting_manager.component.js`: PDFScriptingManager
- `../../web/pdf_single_page_viewer.js`: PDFSinglePageViewer
- `../../web/pdf_viewer.js`: PDFPageViewBuffer, PDFViewer
- `../../web/struct_tree_layer_builder.js`: StructTreeLayerBuilder
- `../../web/text_layer_builder.js`: TextLayerBuilder
- `../../web/ui_utils.js`: AutoPrintRegExp, ProgressBar, RenderingStates, ScrollMode, SpreadMode, backtrackBeforeAllVisibleElements, binarySearchFirstItem, getPageSizeInches, getVisibleElements, isPortraitOrientation, isValidRotation, parseQueryString, removeNullCharacters
- `../../web/xfa_layer_builder.js`: XfaLayerBuilder
- `./test_utils.js`: CMAP_URL, DefaultFileReaderFactory, STANDARD_FONT_DATA_URL, TEST_PDFS_PATH, XRefMock, buildGetDocumentParams, createIdFactory, createTemporaryNodeServer
- `./testreporter.js`: TestReporter
</imports>

Code:
<code>
File:
src/display/canvas.js
1 /* Copyright 2012 Mozilla Foundation
2  *
3  * Licensed under the Apache License, Version 2.0 (the "License");
4  * you may not use this file except in compliance with the License.
5  * You may obtain a copy of the License at
6  *
7  *     http://www.apache.org/licenses/LICENSE-2.0
8  *
9  * Unless required by applicable law or agreed to in writing, software
10  * distributed under the License is distributed on an "AS IS" BASIS,
11  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
12  * See the License for the specific language governing permissions and
13  * limitations under the License.
14  */
15 
16 import {
17   FeatureTest,
18   FONT_IDENTITY_MATRIX,
19   IDENTITY_MATRIX,
20   ImageKind,
21   info,
22   isNodeJS,
23   OPS,
24   shadow,
25   TextRenderingMode,
26   unreachable,
27   Util,
28   warn,
29 } from "../shared/util.js";
30 import {
31   getCurrentTransform,
32   getCurrentTransformInverse,
33   PixelsPerInch,
34 } from "./display_utils.js";
35 import {
36   getShadingPattern,
37   PathType,
38   TilingPattern,
39 } from "./pattern_helper.js";
40 import { convertBlackAndWhiteToRGBA } from "../shared/image_utils.js";
41 
42 // <canvas> contexts store most of the state we need natively.
43 // However, PDF needs a bit more state, which we store here.
44 // Minimal font size that would be used during canvas fillText operations.
45 const MIN_FONT_SIZE = 16;
46 // Maximum font size that would be used during canvas fillText operations.
47 const MAX_FONT_SIZE = 100;
48 
49 // Defines the time the `executeOperatorList`-method is going to be executing
50 // before it stops and schedules a continue of execution.
51 const EXECUTION_TIME = 15; // ms
52 // Defines the number of steps before checking the execution time.
53 const EXECUTION_STEPS = 10;
54 
55 // To disable Type3 compilation, set the value to `-1`.
56 const MAX_SIZE_TO_COMPILE = 1000;
57 
58 const FULL_CHUNK_HEIGHT = 16;
59 
60 /**
61  * Overrides certain methods on a 2d ctx so that when they are called they
62  * will also call the same method on the destCtx. The methods that are
63  * overridden are all the transformation state modifiers, path creation, and
64  * save/restore. We only forward these specific methods because they are the
65  * only state modifiers that we cannot copy over when we switch contexts.
66  *
67  * To remove mirroring call `ctx._removeMirroring()`.
68  *
69  * @param {Object} ctx - The 2d canvas context that will duplicate its calls on
70  *   the destCtx.
71  * @param {Object} destCtx - The 2d canvas context that will receive the
72  *   forwarded calls.
73  */
74 function mirrorContextOperations(ctx, destCtx) {
75   if (ctx._removeMirroring) {
76     throw new Error("Context is already forwarding operations.");
77   }
78   ctx.__originalSave = ctx.save;
79   ctx.__originalRestore = ctx.restore;
80   ctx.__originalRotate = ctx.rotate;
81   ctx.__originalScale = ctx.scale;
82   ctx.__originalTranslate = ctx.translate;
83   ctx.__originalTransform = ctx.transform;
84   ctx.__originalSetTransform = ctx.setTransform;
85   ctx.__originalResetTransform = ctx.resetTransform;
86   ctx.__originalClip = ctx.clip;
87   ctx.__originalMoveTo = ctx.moveTo;
88   ctx.__originalLineTo = ctx.lineTo;
89   ctx.__originalBezierCurveTo = ctx.bezierCurveTo;
90   ctx.__originalRect = ctx.rect;
91   ctx.__originalClosePath = ctx.closePath;
92   ctx.__originalBeginPath = ctx.beginPath;
93 
94   ctx._removeMirroring = () => {
95     ctx.save = ctx.__originalSave;
96     ctx.restore = ctx.__originalRestore;
97     ctx.rotate = ctx.__originalRotate;
98     ctx.scale = ctx.__originalScale;
99     ctx.translate = ctx.__originalTranslate;
100     ctx.transform = ctx.__originalTransform;
101     ctx.setTransform = ctx.__originalSetTransform;
102     ctx.resetTransform = ctx.__originalResetTransform;
103 
104     ctx.clip = ctx.__originalClip;
105     ctx.moveTo = ctx.__originalMoveTo;
106     ctx.lineTo = ctx.__originalLineTo;
107     ctx.bezierCurveTo = ctx.__originalBezierCurveTo;
108     ctx.rect = ctx.__originalRect;
109     ctx.closePath = ctx.__originalClosePath;
110     ctx.beginPath = ctx.__originalBeginPath;
111     delete ctx._removeMirroring;
112   };
113 
114   ctx.save = function ctxSave() {
115     destCtx.save();
116     this.__originalSave();
117   };
118 
119   ctx.restore = function ctxRestore() {
120     destCtx.restore();
121     this.__originalRestore();
122   };
123 
124   ctx.translate = function ctxTranslate(x, y) {
125     destCtx.translate(x, y);
126     this.__originalTranslate(x, y);
127   };
128 
129   ctx.scale = function ctxScale(x, y) {
130     destCtx.scale(x, y);
131     this.__originalScale(x, y);
132   };
133 
134   ctx.transform = function ctxTransform(a, b, c, d, e, f) {
135     destCtx.transform(a, b, c, d, e, f);
136     this.__originalTransform(a, b, c, d, e, f);
137   };
138 
139   ctx.setTransform = function ctxSetTransform(a, b, c, d, e, f) {
140     destCtx.setTransform(a, b, c, d, e, f);
141     this.__originalSetTransform(a, b, c, d, e, f);
142   };
143 
144   ctx.resetTransform = function ctxResetTransform() {
145     destCtx.resetTransform();
146     this.__originalResetTransform();
147   };
148 
149   ctx.rotate = function ctxRotate(angle) {
150     destCtx.rotate(angle);
151     this.__originalRotate(angle);
152   };
153 
154   ctx.clip = function ctxRotate(rule) {
155     destCtx.clip(rule);
156     this.__originalClip(rule);
157   };
158 
159   ctx.moveTo = function (x, y) {
160     destCtx.moveTo(x, y);
161     this.__originalMoveTo(x, y);
162   };
163 
164   ctx.lineTo = function (x, y) {
165     destCtx.lineTo(x, y);
166     this.__originalLineTo(x, y);
167   };
168 
169   ctx.bezierCurveTo = function (cp1x, cp1y, cp2x, cp2y, x, y) {
170     destCtx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y);
171     this.__originalBezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y);
172   };
173 
174   ctx.rect = function (x, y, width, height) {
175     destCtx.rect(x, y, width, height);
176     this.__originalRect(x, y, width, height);
177   };
178 
179   ctx.closePath = function () {
180     destCtx.closePath();
181     this.__originalClosePath();
182   };
183 
184   ctx.beginPath = function () {
185     destCtx.beginPath();
186     this.__originalBeginPath();
187   };
188 }
189 
190 class CachedCanvases {
191   constructor(canvasFactory) {
192     this.canvasFactory = canvasFactory;
193     this.cache = Object.create(null);
194   }
195 
196   getCanvas(id, width, height) {
197     let canvasEntry;
198     if (this.cache[id] !== undefined) {
199       canvasEntry = this.cache[id];
200       this.canvasFactory.reset(canvasEntry, width, height);
201     } else {
202       canvasEntry = this.canvasFactory.create(width, height);
203       this.cache[id] = canvasEntry;
204     }
205     return canvasEntry;
206   }
207 
208   delete(id) {
209     delete this.cache[id];
210   }
211 
212   clear() {
213     for (const id in this.cache) {
214       const canvasEntry = this.cache[id];
215       this.canvasFactory.destroy(canvasEntry);
216       delete this.cache[id];
217     }
218   }
219 }
220 
221 function drawImageAtIntegerCoords(
222   ctx,
223   srcImg,
224   srcX,
225   srcY,
226   srcW,
227   srcH,
228   destX,
229   destY,
230   destW,
231   destH
232 ) {
233   const [a, b, c, d, tx, ty] = getCurrentTransform(ctx);
234   if (b === 0 && c === 0) {
235     // top-left corner is at (X, Y) and
236     // bottom-right one is at (X + width, Y + height).
237 
238     // If leftX is 4.321 then it's rounded to 4.
239     // If width is 10.432 then it's rounded to 11 because
240     // rightX = leftX + width = 14.753 which is rounded to 15
241     // so after rounding the total width is 11 (15 - 4).
242     // It's why we can't just floor/ceil uniformly, it just depends
243     // on the values we've.
244 
245     const tlX = destX * a + tx;
246     const rTlX = Math.round(tlX);
247     const tlY = destY * d + ty;
248     const rTlY = Math.round(tlY);
249     const brX = (destX + destW) * a + tx;
250 
251     // Some pdf contains images with 1x1 images so in case of 0-width after
252     // scaling we must fallback on 1 to be sure there is something.
253     const rWidth = Math.abs(Math.round(brX) - rTlX) || 1;
254     const brY = (destY + destH) * d + ty;
255     const rHeight = Math.abs(Math.round(brY) - rTlY) || 1;
256 
257     // We must apply a transformation in order to apply it on the image itself.
258     // For example if a == 1 && d == -1, it means that the image itself is
259     // mirrored w.r.t. the x-axis.
260     ctx.setTransform(Math.sign(a), 0, 0, Math.sign(d), rTlX, rTlY);
261     ctx.drawImage(srcImg, srcX, srcY, srcW, srcH, 0, 0, rWidth, rHeight);
262     ctx.setTransform(a, b, c, d, tx, ty);
263 
264     return [rWidth, rHeight];
265   }
266 
267   if (a === 0 && d === 0) {
268     // This path is taken in issue9462.pdf (page 3).
269     const tlX = destY * c + tx;
270     const rTlX = Math.round(tlX);
271     const tlY = destX * b + ty;
272     const rTlY = Math.round(tlY);
273     const brX = (destY + destH) * c + tx;
274     const rWidth = Math.abs(Math.round(brX) - rTlX) || 1;
275     const brY = (destX + destW) * b + ty;
276     const rHeight = Math.abs(Math.round(brY) - rTlY) || 1;
277 
278     ctx.setTransform(0, Math.sign(b), Math.sign(c), 0, rTlX, rTlY);
279     ctx.drawImage(srcImg, srcX, srcY, srcW, srcH, 0, 0, rHeight, rWidth);
280     ctx.setTransform(a, b, c, d, tx, ty);
281 
282     return [rHeight, rWidth];
283   }
284 
285   // Not a scale matrix so let the render handle the case without rounding.
286   ctx.drawImage(srcImg, srcX, srcY, srcW, srcH, destX, destY, destW, destH);
287 
288   const scaleX = Math.hypot(a, b);
289   const scaleY = Math.hypot(c, d);
290   return [scaleX * destW, scaleY * destH];
291 }
292 
293 function compileType3Glyph(imgData) {
294   const { width, height } = imgData;
295   if (width > MAX_SIZE_TO_COMPILE || height > MAX_SIZE_TO_COMPILE) {
296     return null;
297   }
298 
299   const POINT_TO_PROCESS_LIMIT = 1000;
300   const POINT_TYPES = new Uint8Array([
301     0, 2, 4, 0, 1, 0, 5, 4, 8, 10, 0, 8, 0, 2, 1, 0,
302   ]);
303 
304   const width1 = width + 1;
305   let points = new Uint8Array(width1 * (height + 1));
306   let i, j, j0;
307 
308   // decodes bit-packed mask data
309   const lineSize = (width + 7) & ~7;
310   let data = new Uint8Array(lineSize * height),
311     pos = 0;
312   for (const elem of imgData.data) {
313     let mask = 128;
314     while (mask > 0) {
315       data[pos++] = elem & mask ? 0 : 255;
316       mask >>= 1;
317     }
318   }
319 
320   // finding interesting points: every point is located between mask pixels,
321   // so there will be points of the (width + 1)x(height + 1) grid. Every point
322   // will have flags assigned based on neighboring mask pixels:
323   //   4 | 8
324   //   --P--
325   //   2 | 1
326   // We are interested only in points with the flags:
327   //   - outside corners: 1, 2, 4, 8;
328   //   - inside corners: 7, 11, 13, 14;
329   //   - and, intersections: 5, 10.
330   let count = 0;
331   pos = 0;
332   if (data[pos] !== 0) {
333     points[0] = 1;
334     ++count;
335   }
336   for (j = 1; j < width; j++) {
337     if (data[pos] !== data[pos + 1]) {
338       points[j] = data[pos] ? 2 : 1;
339       ++count;
340     }
341     pos++;
342   }
343   if (data[pos] !== 0) {
344     points[j] = 2;
345     ++count;
346   }
347   for (i = 1; i < height; i++) {
348     pos = i * lineSize;
349     j0 = i * width1;
350     if (data[pos - lineSize] !== data[pos]) {
351       points[j0] = data[pos] ? 1 : 8;
352       ++count;
353     }
354     // 'sum' is the position of the current pixel configuration in the 'TYPES'
355     // array (in order 8-1-2-4, so we can use '>>2' to shift the column).
356     let sum = (data[pos] ? 4 : 0) + (data[pos - lineSize] ? 8 : 0);
357     for (j = 1; j < width; j++) {
358       sum =
359         (sum >> 2) +
360         (data[pos + 1] ? 4 : 0) +
361         (data[pos - lineSize + 1] ? 8 : 0);
362       if (POINT_TYPES[sum]) {
363         points[j0 + j] = POINT_TYPES[sum];
364         ++count;
365       }
366       pos++;
367     }
368     if (data[pos - lineSize] !== data[pos]) {
369       points[j0 + j] = data[pos] ? 2 : 4;
370       ++count;
371     }
372 
373     if (count > POINT_TO_PROCESS_LIMIT) {
374       return null;
375     }
376   }
377 
378   pos = lineSize * (height - 1);
379   j0 = i * width1;
380   if (data[pos] !== 0) {
381     points[j0] = 8;
382     ++count;
383   }
384   for (j = 1; j < width; j++) {
385     if (data[pos] !== data[pos + 1]) {
386       points[j0 + j] = data[pos] ? 4 : 8;
387       ++count;
388     }
389     pos++;
390   }
391   if (data[pos] !== 0) {
392     points[j0 + j] = 4;
393     ++count;
394   }
395   if (count > POINT_TO_PROCESS_LIMIT) {
396     return null;
397   }
398 
399   // building outlines
400   const steps = new Int32Array([0, width1, -1, 0, -width1, 0, 0, 0, 1]);
401   const path = new Path2D();
402 
403   for (i = 0; count && i <= height; i++) {
404     let p = i * width1;
405     const end = p + width;
406     while (p < end && !points[p]) {
407       p++;
408     }
409     if (p === end) {
410       continue;
411     }
412     path.moveTo(p % width1, i);
413 
414     const p0 = p;
415     let type = points[p];
416     do {
417       const step = steps[type];
418       do {
419         p += step;
420       } while (!points[p]);
421 
422       const pp = points[p];
423       if (pp !== 5 && pp !== 10) {
424         // set new direction
425         type = pp;
426         // delete mark
427         points[p] = 0;
428       } else {
429         // type is 5 or 10, ie, a crossing
430         // set new direction
431         type = pp & ((0x33 * type) >> 4);
432         // set new type for "future hit"
433         points[p] &= (type >> 2) | (type << 2);
434       }
435       path.lineTo(p % width1, (p / width1) | 0);
436 
437       if (!points[p]) {
438         --count;
439       }
440     } while (p0 !== p);
441     --i;
442   }
443 
444   // Immediately release the, potentially large, `Uint8Array`s after parsing.
445   data = null;
446   points = null;
447 
448   const drawOutline = function (c) {
449     c.save();
450     // the path shall be painted in [0..1]x[0..1] space
451     c.scale(1 / width, -1 / height);
452     c.translate(0, -height);
453     c.fill(path);
454     c.beginPath();
455     c.restore();
456   };
457 
458   return drawOutline;
459 }
460 
461 class CanvasExtraState {
462   constructor(width, height) {
463     // Are soft masks and alpha values shapes or opacities?
464     this.alphaIsShape = false;
465     this.fontSize = 0;
466     this.fontSizeScale = 1;
467     this.textMatrix = IDENTITY_MATRIX;
468     this.textMatrixScale = 1;
469     this.fontMatrix = FONT_IDENTITY_MATRIX;
470     this.leading = 0;
471     // Current point (in user coordinates)
472     this.x = 0;
473     this.y = 0;
474     // Start of text line (in text coordinates)
475     this.lineX = 0;
476     this.lineY = 0;
477     // Character and word spacing
478     this.charSpacing = 0;
479     this.wordSpacing = 0;
480     this.textHScale = 1;
481     this.textRenderingMode = TextRenderingMode.FILL;
482     this.textRise = 0;
483     // Default fore and background colors
484     this.fillColor = "#000000";
485     this.strokeColor = "#000000";
486     this.patternFill = false;
487     // Note: fill alpha applies to all non-stroking operations
488     this.fillAlpha = 1;
489     this.strokeAlpha = 1;
490     this.lineWidth = 1;
491     this.activeSMask = null;
492     this.transferMaps = "none";
493 
494     this.startNewPathAndClipBox([0, 0, width, height]);
495   }
496 
497   clone() {
498     const clone = Object.create(this);
499     clone.clipBox = this.clipBox.slice();
500     return clone;
501   }
502 
503   setCurrentPoint(x, y) {
504     this.x = x;
505     this.y = y;
506   }
507 
508   updatePathMinMax(transform, x, y) {
509     [x, y] = Util.applyTransform([x, y], transform);
510     this.minX = Math.min(this.minX, x);
511     this.minY = Math.min(this.minY, y);
512     this.maxX = Math.max(this.maxX, x);
513     this.maxY = Math.max(this.maxY, y);
514   }
515 
516   updateRectMinMax(transform, rect) {
517     const p1 = Util.applyTransform(rect, transform);
518     const p2 = Util.applyTransform(rect.slice(2), transform);
519     const p3 = Util.applyTransform([rect[0], rect[3]], transform);
520     const p4 = Util.applyTransform([rect[2], rect[1]], transform);
521 
522     this.minX = Math.min(this.minX, p1[0], p2[0], p3[0], p4[0]);
523     this.minY = Math.min(this.minY, p1[1], p2[1], p3[1], p4[1]);
524     this.maxX = Math.max(this.maxX, p1[0], p2[0], p3[0], p4[0]);
525     this.maxY = Math.max(this.maxY, p1[1], p2[1], p3[1], p4[1]);
526   }
527 
528   updateScalingPathMinMax(transform, minMax) {
529     Util.scaleMinMax(transform, minMax);
530     this.minX = Math.min(this.minX, minMax[0]);
531     this.minY = Math.min(this.minY, minMax[1]);
532     this.maxX = Math.max(this.maxX, minMax[2]);
533     this.maxY = Math.max(this.maxY, minMax[3]);
534   }
535 
536   updateCurvePathMinMax(transform, x0, y0, x1, y1, x2, y2, x3, y3, minMax) {
537     const box = Util.bezierBoundingBox(x0, y0, x1, y1, x2, y2, x3, y3, minMax);
538     if (minMax) {
539       return;
540     }
541     this.updateRectMinMax(transform, box);
542   }
543 
544   getPathBoundingBox(pathType = PathType.FILL, transform = null) {
545     const box = [this.minX, this.minY, this.maxX, this.maxY];
546     if (pathType === PathType.STROKE) {
547       if (!transform) {
548         unreachable("Stroke bounding box must include transform.");
549       }
550       // Stroked paths can be outside of the path bounding box by 1/2 the line
551       // width.
552       const scale = Util.singularValueDecompose2dScale(transform);
553       const xStrokePad = (scale[0] * this.lineWidth) / 2;
554       const yStrokePad = (scale[1] * this.lineWidth) / 2;
555       box[0] -= xStrokePad;
556       box[1] -= yStrokePad;
557       box[2] += xStrokePad;
558       box[3] += yStrokePad;
559     }
560     return box;
561   }
562 
563   updateClipFromPath() {
564     const intersect = Util.intersect(this.clipBox, this.getPathBoundingBox());
565     this.startNewPathAndClipBox(intersect || [0, 0, 0, 0]);
566   }
567 
568   isEmptyClip() {
569     return this.minX === Infinity;
570   }
571 
572   startNewPathAndClipBox(box) {
573     this.clipBox = box;
574     this.minX = Infinity;
575     this.minY = Infinity;
576     this.maxX = 0;
577     this.maxY = 0;
578   }
579 
580   getClippedPathBoundingBox(pathType = PathType.FILL, transform = null) {
581     return Util.intersect(
582       this.clipBox,
583       this.getPathBoundingBox(pathType, transform)
584     );
585   }
586 }
587 
588 function putBinaryImageData(ctx, imgData) {
589   if (typeof ImageData !== "undefined" && imgData instanceof ImageData) {
590     ctx.putImageData(imgData, 0, 0);
591     return;
592   }
593 
594   // Put the image data to the canvas in chunks, rather than putting the
595   // whole image at once.  This saves JS memory, because the ImageData object
596   // is smaller. It also possibly saves C++ memory within the implementation
597   // of putImageData(). (E.g. in Firefox we make two short-lived copies of
598   // the data passed to putImageData()). |n| shouldn't be too small, however,
599   // because too many putImageData() calls will slow things down.
600   //
601   // Note: as written, if the last chunk is partial, the putImageData() call
602   // will (conceptually) put pixels past the bounds of the canvas.  But
603   // that's ok; any such pixels are ignored.
604 
605   const height = imgData.height,
606     width = imgData.width;
607   const partialChunkHeight = height % FULL_CHUNK_HEIGHT;
608   const fullChunks = (height - partialChunkHeight) / FULL_CHUNK_HEIGHT;
609   const totalChunks = partialChunkHeight === 0 ? fullChunks : fullChunks + 1;
610 
611   const chunkImgData = ctx.createImageData(width, FULL_CHUNK_HEIGHT);
612   let srcPos = 0,
613     destPos;
614   const src = imgData.data;
615   const dest = chunkImgData.data;
616   let i, j, thisChunkHeight, elemsInThisChunk;
617 
618   // There are multiple forms in which the pixel data can be passed, and
619   // imgData.kind tells us which one this is.
620   if (imgData.kind === ImageKind.GRAYSCALE_1BPP) {
621     // Grayscale, 1 bit per pixel (i.e. black-and-white).
622     const srcLength = src.byteLength;
623     const dest32 = new Uint32Array(dest.buffer, 0, dest.byteLength >> 2);
624     const dest32DataLength = dest32.length;
625     const fullSrcDiff = (width + 7) >> 3;
626     const white = 0xffffffff;
627     const black = FeatureTest.isLittleEndian ? 0xff000000 : 0x000000ff;
628 
629     for (i = 0; i < totalChunks; i++) {
630       thisChunkHeight = i < fullChunks ? FULL_CHUNK_HEIGHT : partialChunkHeight;
631       destPos = 0;
632       for (j = 0; j < thisChunkHeight; j++) {
633         const srcDiff = srcLength - srcPos;
634         let k = 0;
635         const kEnd = srcDiff > fullSrcDiff ? width : srcDiff * 8 - 7;
636         const kEndUnrolled = kEnd & ~7;
637         let mask = 0;
638         let srcByte = 0;
639         for (; k < kEndUnrolled; k += 8) {
640           srcByte = src[srcPos++];
641           dest32[destPos++] = srcByte & 128 ? white : black;
642           dest32[destPos++] = srcByte & 64 ? white : black;
643           dest32[destPos++] = srcByte & 32 ? white : black;
644           dest32[destPos++] = srcByte & 16 ? white : black;
645           dest32[destPos++] = srcByte & 8 ? white : black;
646           dest32[destPos++] = srcByte & 4 ? white : black;
647           dest32[destPos++] = srcByte & 2 ? white : black;
648           dest32[destPos++] = srcByte & 1 ? white : black;
649         }
650         for (; k < kEnd; k++) {
651           if (mask === 0) {
652             srcByte = src[srcPos++];
653             mask = 128;
654           }
655 
656           dest32[destPos++] = srcByte & mask ? white : black;
657           mask >>= 1;
658         }
659       }
660       // We ran out of input. Make all remaining pixels transparent.
661       while (destPos < dest32DataLength) {
662         dest32[destPos++] = 0;
663       }
664 
665       ctx.putImageData(chunkImgData, 0, i * FULL_CHUNK_HEIGHT);
666     }
667   } else if (imgData.kind === ImageKind.RGBA_32BPP) {
668     // RGBA, 32-bits per pixel.
669     j = 0;
670     elemsInThisChunk = width * FULL_CHUNK_HEIGHT * 4;
671     for (i = 0; i < fullChunks; i++) {
672       dest.set(src.subarray(srcPos, srcPos + elemsInThisChunk));
673       srcPos += elemsInThisChunk;
674 
675       ctx.putImageData(chunkImgData, 0, j);
676       j += FULL_CHUNK_HEIGHT;
677     }
678     if (i < totalChunks) {
679       elemsInThisChunk = width * partialChunkHeight * 4;
680       dest.set(src.subarray(srcPos, srcPos + elemsInThisChunk));
681 
682       ctx.putImageData(chunkImgData, 0, j);
683     }
684   } else if (imgData.kind === ImageKind.RGB_24BPP) {
685     // RGB, 24-bits per pixel.
686     thisChunkHeight = FULL_CHUNK_HEIGHT;
687     elemsInThisChunk = width * thisChunkHeight;
688     for (i = 0; i < totalChunks; i++) {
689       if (i >= fullChunks) {
690         thisChunkHeight = partialChunkHeight;
691         elemsInThisChunk = width * thisChunkHeight;
692       }
693 
694       destPos = 0;
695       for (j = elemsInThisChunk; j--; ) {
696         dest[destPos++] = src[srcPos++];
697         dest[destPos++] = src[srcPos++];
698         dest[destPos++] = src[srcPos++];
699         dest[destPos++] = 255;
700       }
701 
702       ctx.putImageData(chunkImgData, 0, i * FULL_CHUNK_HEIGHT);
703     }
704   } else {
705     throw new Error(`bad image kind: ${imgData.kind}`);
706   }
707 }
708 
709 function putBinaryImageMask(ctx, imgData) {
710   if (imgData.bitmap) {
711     // The bitmap has been created in the worker.
712     ctx.drawImage(imgData.bitmap, 0, 0);
713     return;
714   }
715 
716   // Slow path: OffscreenCanvas isn't available in the worker.
717   const height = imgData.height,
718     width = imgData.width;
719   const partialChunkHeight = height % FULL_CHUNK_HEIGHT;
720   const fullChunks = (height - partialChunkHeight) / FULL_CHUNK_HEIGHT;
721   const totalChunks = partialChunkHeight === 0 ? fullChunks : fullChunks + 1;
722 
723   const chunkImgData = ctx.createImageData(width, FULL_CHUNK_HEIGHT);
724   let srcPos = 0;
725   const src = imgData.data;
726   const dest = chunkImgData.data;
727 
728   for (let i = 0; i < totalChunks; i++) {
729     const thisChunkHeight =
730       i < fullChunks ? FULL_CHUNK_HEIGHT : partialChunkHeight;
731 
732     // Expand the mask so it can be used by the canvas.  Any required
733     // inversion has already been handled.
734 
735     ({ srcPos } = convertBlackAndWhiteToRGBA({
736       src,
737       srcPos,
738       dest,
739       width,
740       height: thisChunkHeight,
741       nonBlackColor: 0,
742     }));
743 
744     ctx.putImageData(chunkImgData, 0, i * FULL_CHUNK_HEIGHT);
745   }
746 }
747 
748 function copyCtxState(sourceCtx, destCtx) {
749   const properties = [
750     "strokeStyle",
751     "fillStyle",
752     "fillRule",
753     "globalAlpha",
754     "lineWidth",
755     "lineCap",
756     "lineJoin",
757     "miterLimit",
758     "globalCompositeOperation",
759     "font",
760     "filter",
761   ];
762   for (const property of properties) {
763     if (sourceCtx[property] !== undefined) {
764       destCtx[property] = sourceCtx[property];
765     }
766   }
767   if (sourceCtx.setLineDash !== undefined) {
768     destCtx.setLineDash(sourceCtx.getLineDash());
769     destCtx.lineDashOffset = sourceCtx.lineDashOffset;
770   }
771 }
772 
773 function resetCtxToDefault(ctx) {
774   ctx.strokeStyle = ctx.fillStyle = "#000000";
775   ctx.fillRule = "nonzero";
776   ctx.globalAlpha = 1;
777   ctx.lineWidth = 1;
778   ctx.lineCap = "butt";
779   ctx.lineJoin = "miter";
780   ctx.miterLimit = 10;
781   ctx.globalCompositeOperation = "source-over";
782   ctx.font = "10px sans-serif";
783   if (ctx.setLineDash !== undefined) {
784     ctx.setLineDash([]);
785     ctx.lineDashOffset = 0;
786   }
787   if (
788     (typeof PDFJSDev !== "undefined" && PDFJSDev.test("MOZCENTRAL")) ||
789     !isNodeJS
790   ) {
791     const { filter } = ctx;
792     if (filter !== "none" && filter !== "") {
793       ctx.filter = "none";
794     }
795   }
796 }
797 
798 function getImageSmoothingEnabled(transform, interpolate) {
799   // In section 8.9.5.3 of the PDF spec, it's mentioned that the interpolate
800   // flag should be used when the image is upscaled.
801   // In Firefox, smoothing is always used when downscaling images (bug 1360415).
802 
803   if (interpolate) {
804     return true;
805   }
806 
807   const scale = Util.singularValueDecompose2dScale(transform);
808   // Round to a 32bit float so that `<=` check below will pass for numbers that
809   // are very close, but not exactly the same 64bit floats.
810   scale[0] = Math.fround(scale[0]);
811   scale[1] = Math.fround(scale[1]);
812   const actualScale = Math.fround(
813     (globalThis.devicePixelRatio || 1) * PixelsPerInch.PDF_TO_CSS_UNITS
814   );
815   return scale[0] <= actualScale && scale[1] <= actualScale;
816 }
817 
818 const LINE_CAP_STYLES = ["butt", "round", "square"];
819 const LINE_JOIN_STYLES = ["miter", "round", "bevel"];
820 const NORMAL_CLIP = {};
821 const EO_CLIP = {};
822 
823 class CanvasGraphics {
824   constructor(
825     canvasCtx,
826     commonObjs,
827     objs,
828     canvasFactory,
829     filterFactory,
830     { optionalContentConfig, markedContentStack = null },
831     annotationCanvasMap,
832     pageColors
833   ) {
834     this.ctx = canvasCtx;
835     this.current = new CanvasExtraState(
836       this.ctx.canvas.width,
837       this.ctx.canvas.height
838     );
839     this.stateStack = [];
840     this.pendingClip = null;
841     this.pendingEOFill = false;
842     this.res = null;
843     this.xobjs = null;
844     this.commonObjs = commonObjs;
845     this.objs = objs;
846     this.canvasFactory = canvasFactory;
847     this.filterFactory = filterFactory;
848     this.groupStack = [];
849     this.processingType3 = null;
850     // Patterns are painted relative to the initial page/form transform, see
851     // PDF spec 8.7.2 NOTE 1.
852     this.baseTransform = null;
853     this.baseTransformStack = [];
854     this.groupLevel = 0;
855     this.smaskStack = [];
856     this.smaskCounter = 0;
857     this.tempSMask = null;
858     this.suspendedCtx = null;
859     this.contentVisible = true;
860     this.markedContentStack = markedContentStack || [];
861     this.optionalContentConfig = optionalContentConfig;
862     this.cachedCanvases = new CachedCanvases(this.canvasFactory);
863     this.cachedPatterns = new Map();
864     this.annotationCanvasMap = annotationCanvasMap;
865     this.viewportScale = 1;
866     this.outputScaleX = 1;
867     this.outputScaleY = 1;
868     this.pageColors = pageColors;
869 
870     this._cachedScaleForStroking = [-1, 0];
871     this._cachedGetSinglePixelWidth = null;
872     this._cachedBitmapsMap = new Map();
873   }
874 
875   getObject(data, fallback = null) {
876     if (typeof data === "string") {
877       return data.startsWith("g_")
878         ? this.commonObjs.get(data)
879         : this.objs.get(data);
880     }
881     return fallback;
882   }
883 
884   beginDrawing({
885     transform,
886     viewport,
887     transparency = false,
888     background = null,
889   }) {
890     // For pdfs that use blend modes we have to clear the canvas else certain
891     // blend modes can look wrong since we'd be blending with a white
892     // backdrop. The problem with a transparent backdrop though is we then
893     // don't get sub pixel anti aliasing on text, creating temporary
894     // transparent canvas when we have blend modes.
895     const width = this.ctx.canvas.width;
896     const height = this.ctx.canvas.height;
897 
898     const savedFillStyle = this.ctx.fillStyle;
899     this.ctx.fillStyle = background || "#ffffff";
900     this.ctx.fillRect(0, 0, width, height);
901     this.ctx.fillStyle = savedFillStyle;
902 
903     if (transparency) {
904       const transparentCanvas = this.cachedCanvases.getCanvas(
905         "transparent",
906         width,
907         height
908       );
909       this.compositeCtx = this.ctx;
910       this.transparentCanvas = transparentCanvas.canvas;
911       this.ctx = transparentCanvas.context;
912       this.ctx.save();
913       // The transform can be applied before rendering, transferring it to
914       // the new canvas.
915       this.ctx.transform(...getCurrentTransform(this.compositeCtx));
916     }
917 
918     this.ctx.save();
919     resetCtxToDefault(this.ctx);
920     if (transform) {
921       this.ctx.transform(...transform);
922       this.outputScaleX = transform[0];
923       this.outputScaleY = transform[0];
924     }
925     this.ctx.transform(...viewport.transform);
926     this.viewportScale = viewport.scale;
927 
928     this.baseTransform = getCurrentTransform(this.ctx);
929   }
930 
931   executeOperatorList(
932     operatorList,
933     executionStartIdx,
934     continueCallback,
935     stepper
936   ) {
937     const argsArray = operatorList.argsArray;
938     const fnArray = operatorList.fnArray;
939     let i = executionStartIdx || 0;
940     const argsArrayLen = argsArray.length;
941 
942     // Sometimes the OperatorList to execute is empty.
943     if (argsArrayLen === i) {
944       return i;
945     }
946 
947     const chunkOperations =
948       argsArrayLen - i > EXECUTION_STEPS &&
949       typeof continueCallback === "function";
950     const endTime = chunkOperations ? Date.now() + EXECUTION_TIME : 0;
951     let steps = 0;
952 
953     const commonObjs = this.commonObjs;
954     const objs = this.objs;
955     let fnId;
956 
957     while (true) {
958       if (stepper !== undefined && i === stepper.nextBreakPoint) {
959         stepper.breakIt(i, continueCallback);
960         return i;
961       }
962 
963       fnId = fnArray[i];
964 
965       if (fnId !== OPS.dependency) {
966         // eslint-disable-next-line prefer-spread
967         this[fnId].apply(this, argsArray[i]);
968       } else {
969         for (const depObjId of argsArray[i]) {
970           const objsPool = depObjId.startsWith("g_") ? commonObjs : objs;
971 
972           // If the promise isn't resolved yet, add the continueCallback
973           // to the promise and bail out.
974           if (!objsPool.has(depObjId)) {
975             objsPool.get(depObjId, continueCallback);
976             return i;
977           }
978         }
979       }
980 
981       i++;
982 
983       // If the entire operatorList was executed, stop as were done.
984       if (i === argsArrayLen) {
985         return i;
986       }
987 
988       // If the execution took longer then a certain amount of time and
989       // `continueCallback` is specified, interrupt the execution.
990       if (chunkOperations && ++steps > EXECUTION_STEPS) {
991         if (Date.now() > endTime) {
992           continueCallback();
993           return i;
994         }
995         steps = 0;
996       }
997 
998       // If the operatorList isn't executed completely yet OR the execution
999       // time was short enough, do another execution round.
1000     }
1001   }
1002 
1003   #restoreInitialState() {
1004     // Finishing all opened operations such as SMask group painting.
1005     while (this.stateStack.length || this.inSMaskMode) {
1006       this.restore();
1007     }
1008 
1009     this.ctx.restore();
1010 
1011     if (this.transparentCanvas) {
1012       this.ctx = this.compositeCtx;
1013       this.ctx.save();
1014       this.ctx.setTransform(1, 0, 0, 1, 0, 0); // Avoid apply transform twice
1015       this.ctx.drawImage(this.transparentCanvas, 0, 0);
1016       this.ctx.restore();
1017       this.transparentCanvas = null;
1018     }
1019   }
1020 
1021   endDrawing() {
1022     this.#restoreInitialState();
1023 
1024     this.cachedCanvases.clear();
1025     this.cachedPatterns.clear();
1026 
1027     for (const cache of this._cachedBitmapsMap.values()) {
1028       for (const canvas of cache.values()) {
1029         if (
1030           typeof HTMLCanvasElement !== "undefined" &&
1031           canvas instanceof HTMLCanvasElement
1032         ) {
1033           canvas.width = canvas.height = 0;
1034         }
1035       }
1036       cache.clear();
1037     }
1038     this._cachedBitmapsMap.clear();
1039     this.#drawFilter();
1040   }
1041 
1042   #drawFilter() {
1043     if (this.pageColors) {
1044       const hcmFilterId = this.filterFactory.addHCMFilter(
1045         this.pageColors.foreground,
1046         this.pageColors.background
1047       );
1048       if (hcmFilterId !== "none") {
1049         const savedFilter = this.ctx.filter;
1050         this.ctx.filter = hcmFilterId;
1051         this.ctx.drawImage(this.ctx.canvas, 0, 0);
1052         this.ctx.filter = savedFilter;
1053       }
1054     }
1055   }
1056 
1057   _scaleImage(img, inverseTransform) {
1058     // Vertical or horizontal scaling shall not be more than 2 to not lose the
1059     // pixels during drawImage operation, painting on the temporary canvas(es)
1060     // that are twice smaller in size.
1061     const width = img.width;
1062     const height = img.height;
1063     let widthScale = Math.max(
1064       Math.hypot(inverseTransform[0], inverseTransform[1]),
1065       1
1066     );
1067     let heightScale = Math.max(
1068       Math.hypot(inverseTransform[2], inverseTransform[3]),
1069       1
1070     );
1071 
1072     let paintWidth = width,
1073       paintHeight = height;
1074     let tmpCanvasId = "prescale1";
1075     let tmpCanvas, tmpCtx;
1076     while (
1077       (widthScale > 2 && paintWidth > 1) ||
1078       (heightScale > 2 && paintHeight > 1)
1079     ) {
1080       let newWidth = paintWidth,
1081         newHeight = paintHeight;
1082       if (widthScale > 2 && paintWidth > 1) {
1083         // See bug 1820511 (Windows specific bug).
1084         // TODO: once the above bug is fixed we could revert to:
1085         // newWidth = Math.ceil(paintWidth / 2);
1086         newWidth =
1087           paintWidth >= 16384
1088             ? Math.floor(paintWidth / 2) - 1 || 1
1089             : Math.ceil(paintWidth / 2);
1090         widthScale /= paintWidth / newWidth;
1091       }
1092       if (heightScale > 2 && paintHeight > 1) {
1093         // TODO: see the comment above.
1094         newHeight =
1095           paintHeight >= 16384
1096             ? Math.floor(paintHeight / 2) - 1 || 1
1097             : Math.ceil(paintHeight) / 2;
1098         heightScale /= paintHeight / newHeight;
1099       }
1100       tmpCanvas = this.cachedCanvases.getCanvas(
1101         tmpCanvasId,
1102         newWidth,
1103         newHeight
1104       );
1105       tmpCtx = tmpCanvas.context;
1106       tmpCtx.clearRect(0, 0, newWidth, newHeight);
1107       tmpCtx.drawImage(
1108         img,
1109         0,
1110         0,
1111         paintWidth,
1112         paintHeight,
1113         0,
1114         0,
1115         newWidth,
1116         newHeight
1117       );
1118       img = tmpCanvas.canvas;
1119       paintWidth = newWidth;
1120       paintHeight = newHeight;
1121       tmpCanvasId = tmpCanvasId === "prescale1" ? "prescale2" : "prescale1";
1122     }
1123     return {
1124       img,
1125       paintWidth,
1126       paintHeight,
1127     };
1128   }
1129 
1130   _createMaskCanvas(img) {
1131     const ctx = this.ctx;
1132     const { width, height } = img;
1133     const fillColor = this.current.fillColor;
1134     const isPatternFill = this.current.patternFill;
1135     const currentTransform = getCurrentTransform(ctx);
1136 
1137     let cache, cacheKey, scaled, maskCanvas;
1138     if ((img.bitmap || img.data) && img.count > 1) {
1139       const mainKey = img.bitmap || img.data.buffer;
1140       // We're reusing the same image several times, so we can cache it.
1141       // In case we've a pattern fill we just keep the scaled version of
1142       // the image.
1143       // Only the scaling part matters, the translation part is just used
1144       // to compute offsets (but not when filling patterns see #15573).
1145       // TODO: handle the case of a pattern fill if it's possible.
1146       cacheKey = JSON.stringify(
1147         isPatternFill
1148           ? currentTransform
1149           : [currentTransform.slice(0, 4), fillColor]
1150       );
1151 
1152       cache = this._cachedBitmapsMap.get(mainKey);
1153       if (!cache) {
1154         cache = new Map();
1155         this._cachedBitmapsMap.set(mainKey, cache);
1156       }
1157       const cachedImage = cache.get(cacheKey);
1158       if (cachedImage && !isPatternFill) {
1159         const offsetX = Math.round(
1160           Math.min(currentTransform[0], currentTransform[2]) +
1161             currentTransform[4]
1162         );
1163         const offsetY = Math.round(
1164           Math.min(currentTransform[1], currentTransform[3]) +
1165             currentTransform[5]
1166         );
1167         return {
1168           canvas: cachedImage,
1169           offsetX,
1170           offsetY,
1171         };
1172       }
1173       scaled = cachedImage;
1174     }
1175 
1176     if (!scaled) {
1177       maskCanvas = this.cachedCanvases.getCanvas("maskCanvas", width, height);
1178       putBinaryImageMask(maskCanvas.context, img);
1179     }
1180 
1181     // Create the mask canvas at the size it will be drawn at and also set
1182     // its transform to match the current transform so if there are any
1183     // patterns applied they will be applied relative to the correct
1184     // transform.
1185 
1186     let maskToCanvas = Util.transform(currentTransform, [
1187       1 / width,
1188       0,
1189       0,
1190       -1 / height,
1191       0,
1192       0,
1193     ]);
1194     maskToCanvas = Util.transform(maskToCanvas, [1, 0, 0, 1, 0, -height]);
1195     const [minX, minY, maxX, maxY] = Util.getAxialAlignedBoundingBox(
1196       [0, 0, width, height],
1197       maskToCanvas
1198     );
1199     const drawnWidth = Math.round(maxX - minX) || 1;
1200     const drawnHeight = Math.round(maxY - minY) || 1;
1201     const fillCanvas = this.cachedCanvases.getCanvas(
1202       "fillCanvas",
1203       drawnWidth,
1204       drawnHeight
1205     );
1206     const fillCtx = fillCanvas.context;
1207 
1208     // The offset will be the top-left cordinate mask.
1209     // If objToCanvas is [a,b,c,d,e,f] then:
1210     //   - offsetX = min(a, c) + e
1211     //   - offsetY = min(b, d) + f
1212     const offsetX = minX;
1213     const offsetY = minY;
1214     fillCtx.translate(-offsetX, -offsetY);
1215     fillCtx.transform(...maskToCanvas);
1216 
1217     if (!scaled) {
1218       // Pre-scale if needed to improve image smoothing.
1219       scaled = this._scaleImage(
1220         maskCanvas.canvas,
1221         getCurrentTransformInverse(fillCtx)
1222       );
1223       scaled = scaled.img;
1224       if (cache && isPatternFill) {
1225         cache.set(cacheKey, scaled);
1226       }
1227     }
1228 
1229     fillCtx.imageSmoothingEnabled = getImageSmoothingEnabled(
1230       getCurrentTransform(fillCtx),
1231       img.interpolate
1232     );
1233 
1234     drawImageAtIntegerCoords(
1235       fillCtx,
1236       scaled,
1237       0,
1238       0,
1239       scaled.width,
1240       scaled.height,
1241       0,
1242       0,
1243       width,
1244       height
1245     );
1246     fillCtx.globalCompositeOperation = "source-in";
1247 
1248     const inverse = Util.transform(getCurrentTransformInverse(fillCtx), [
1249       1,
1250       0,
1251       0,
1252       1,
1253       -offsetX,
1254       -offsetY,
1255     ]);
1256     fillCtx.fillStyle = isPatternFill
1257       ? fillColor.getPattern(ctx, this, inverse, PathType.FILL)
1258       : fillColor;
1259 
1260     fillCtx.fillRect(0, 0, width, height);
1261 
1262     if (cache && !isPatternFill) {
1263       // The fill canvas is put in the cache associated to the mask image
1264       // so we must remove from the cached canvas: it mustn't be used again.
1265       this.cachedCanvases.delete("fillCanvas");
1266       cache.set(cacheKey, fillCanvas.canvas);
1267     }
1268 
1269     // Round the offsets to avoid drawing fractional pixels.
1270     return {
1271       canvas: fillCanvas.canvas,
1272       offsetX: Math.round(offsetX),
1273       offsetY: Math.round(offsetY),
1274     };
1275   }
1276 
1277   // Graphics state
1278   setLineWidth(width) {
1279     if (width !== this.current.lineWidth) {
1280       this._cachedScaleForStroking[0] = -1;
1281     }
1282     this.current.lineWidth = width;
1283     this.ctx.lineWidth = width;
1284   }
1285 
1286   setLineCap(style) {
1287     this.ctx.lineCap = LINE_CAP_STYLES[style];
1288   }
1289 
1290   setLineJoin(style) {
1291     this.ctx.lineJoin = LINE_JOIN_STYLES[style];
1292   }
1293 
1294   setMiterLimit(limit) {
1295     this.ctx.miterLimit = limit;
1296   }
1297 
1298   setDash(dashArray, dashPhase) {
1299     const ctx = this.ctx;
1300     if (ctx.setLineDash !== undefined) {
1301       ctx.setLineDash(dashArray);
1302       ctx.lineDashOffset = dashPhase;
1303     }
1304   }
1305 
1306   setRenderingIntent(intent) {
1307     // This operation is ignored since we haven't found a use case for it yet.
1308   }
1309 
1310   setFlatness(flatness) {
1311     // This operation is ignored since we haven't found a use case for it yet.
1312   }
1313 
1314   setGState(states) {
1315     for (const [key, value] of states) {
1316       switch (key) {
1317         case "LW":
1318           this.setLineWidth(value);
1319           break;
1320         case "LC":
1321           this.setLineCap(value);
1322           break;
1323         case "LJ":
1324           this.setLineJoin(value);
1325           break;
1326         case "ML":
1327           this.setMiterLimit(value);
1328           break;
1329         case "D":
1330           this.setDash(value[0], value[1]);
1331           break;
1332         case "RI":
1333           this.setRenderingIntent(value);
1334           break;
1335         case "FL":
1336           this.setFlatness(value);
1337           break;
1338         case "Font":
1339           this.setFont(value[0], value[1]);
1340           break;
1341         case "CA":
1342           this.current.strokeAlpha = value;
1343           break;
1344         case "ca":
1345           this.current.fillAlpha = value;
1346           this.ctx.globalAlpha = value;
1347           break;
1348         case "BM":
1349           this.ctx.globalCompositeOperation = value;
1350           break;
1351         case "SMask":
1352           this.current.activeSMask = value ? this.tempSMask : null;
1353           this.tempSMask = null;
1354           this.checkSMaskState();
1355           break;
1356         case "TR":
1357           this.ctx.filter = this.current.transferMaps =
1358             this.filterFactory.addFilter(value);
1359           break;
1360       }
1361     }
1362   }
1363 
1364   get inSMaskMode() {
1365     return !!this.suspendedCtx;
1366   }
1367 
1368   checkSMaskState() {
1369     const inSMaskMode = this.inSMaskMode;
1370     if (this.current.activeSMask && !inSMaskMode) {
1371       this.beginSMaskMode();
1372     } else if (!this.current.activeSMask && inSMaskMode) {
1373       this.endSMaskMode();
1374     }
1375     // Else, the state is okay and nothing needs to be done.
1376   }
1377 
1378   /**
1379    * Soft mask mode takes the current main drawing canvas and replaces it with
1380    * a temporary canvas. Any drawing operations that happen on the temporary
1381    * canvas need to be composed with the main canvas that was suspended (see
1382    * `compose()`). The temporary canvas also duplicates many of its operations
1383    * on the suspended canvas to keep them in sync, so that when the soft mask
1384    * mode ends any clipping paths or transformations will still be active and in
1385    * the right order on the canvas' graphics state stack.
1386    */
1387   beginSMaskMode() {
1388     if (this.inSMaskMode) {
1389       throw new Error("beginSMaskMode called while already in smask mode");
1390     }
1391     const drawnWidth = this.ctx.canvas.width;
1392     const drawnHeight = this.ctx.canvas.height;
1393     const cacheId = "smaskGroupAt" + this.groupLevel;
1394     const scratchCanvas = this.cachedCanvases.getCanvas(
1395       cacheId,
1396       drawnWidth,
1397       drawnHeight
1398     );
1399     this.suspendedCtx = this.ctx;
1400     this.ctx = scratchCanvas.context;
1401     const ctx = this.ctx;
1402     ctx.setTransform(...getCurrentTransform(this.suspendedCtx));
1403     copyCtxState(this.suspendedCtx, ctx);
1404     mirrorContextOperations(ctx, this.suspendedCtx);
1405 
1406     this.setGState([
1407       ["BM", "source-over"],
1408       ["ca", 1],
1409       ["CA", 1],
1410     ]);
1411   }
1412 
1413   endSMaskMode() {
1414     if (!this.inSMaskMode) {
1415       throw new Error("endSMaskMode called while not in smask mode");
1416     }
1417     // The soft mask is done, now restore the suspended canvas as the main
1418     // drawing canvas.
1419     this.ctx._removeMirroring();
1420     copyCtxState(this.ctx, this.suspendedCtx);
1421     this.ctx = this.suspendedCtx;
1422 
1423     this.suspendedCtx = null;
1424   }
1425 
1426   compose(dirtyBox) {
1427     if (!this.current.activeSMask) {
1428       return;
1429     }
1430 
1431     if (!dirtyBox) {
1432       dirtyBox = [0, 0, this.ctx.canvas.width, this.ctx.canvas.height];
1433     } else {
1434       dirtyBox[0] = Math.floor(dirtyBox[0]);
1435       dirtyBox[1] = Math.floor(dirtyBox[1]);
1436       dirtyBox[2] = Math.ceil(dirtyBox[2]);
1437       dirtyBox[3] = Math.ceil(dirtyBox[3]);
1438     }
1439     const smask = this.current.activeSMask;
1440     const suspendedCtx = this.suspendedCtx;
1441 
1442     this.composeSMask(suspendedCtx, smask, this.ctx, dirtyBox);
1443     // Whatever was drawn has been moved to the suspended canvas, now clear it
1444     // out of the current canvas.
1445     this.ctx.save();
1446     this.ctx.setTransform(1, 0, 0, 1, 0, 0);
1447     this.ctx.clearRect(0, 0, this.ctx.canvas.width, this.ctx.canvas.height);
1448     this.ctx.restore();
1449   }
1450 
1451   composeSMask(ctx, smask, layerCtx, layerBox) {
1452     const layerOffsetX = layerBox[0];
1453     const layerOffsetY = layerBox[1];
1454     const layerWidth = layerBox[2] - layerOffsetX;
1455     const layerHeight = layerBox[3] - layerOffsetY;
1456     if (layerWidth === 0 || layerHeight === 0) {
1457       return;
1458     }
1459     this.genericComposeSMask(
1460       smask.context,
1461       layerCtx,
1462       layerWidth,
1463       layerHeight,
1464       smask.subtype,
1465       smask.backdrop,
1466       smask.transferMap,
1467       layerOffsetX,
1468       layerOffsetY,
1469       smask.offsetX,
1470       smask.offsetY
1471     );
1472     ctx.save();
1473     ctx.globalAlpha = 1;
1474     ctx.globalCompositeOperation = "source-over";
1475     ctx.setTransform(1, 0, 0, 1, 0, 0);
1476     ctx.drawImage(layerCtx.canvas, 0, 0);
1477     ctx.restore();
1478   }
1479 
1480   genericComposeSMask(
1481     maskCtx,
1482     layerCtx,
1483     width,
1484     height,
1485     subtype,
1486     backdrop,
1487     transferMap,
1488     layerOffsetX,
1489     layerOffsetY,
1490     maskOffsetX,
1491     maskOffsetY
1492   ) {
1493     let maskCanvas = maskCtx.canvas;
1494     let maskX = layerOffsetX - maskOffsetX;
1495     let maskY = layerOffsetY - maskOffsetY;
1496 
1497     if (backdrop) {
1498       if (
1499         maskX < 0 ||
1500         maskY < 0 ||
1501         maskX + width > maskCanvas.width ||
1502         maskY + height > maskCanvas.height
1503       ) {
1504         const canvas = this.cachedCanvases.getCanvas(
1505           "maskExtension",
1506           width,
1507           height
1508         );
1509         const ctx = canvas.context;
1510         ctx.drawImage(maskCanvas, -maskX, -maskY);
1511         if (backdrop.some(c => c !== 0)) {
1512           ctx.globalCompositeOperation = "destination-atop";
1513           ctx.fillStyle = Util.makeHexColor(...backdrop);
1514           ctx.fillRect(0, 0, width, height);
1515           ctx.globalCompositeOperation = "source-over";
1516         }
1517 
1518         maskCanvas = canvas.canvas;
1519         maskX = maskY = 0;
1520       } else if (backdrop.some(c => c !== 0)) {
1521         maskCtx.save();
1522         maskCtx.globalAlpha = 1;
1523         maskCtx.setTransform(1, 0, 0, 1, 0, 0);
1524         const clip = new Path2D();
1525         clip.rect(maskX, maskY, width, height);
1526         maskCtx.clip(clip);
1527         maskCtx.globalCompositeOperation = "destination-atop";
1528         maskCtx.fillStyle = Util.makeHexColor(...backdrop);
1529         maskCtx.fillRect(maskX, maskY, width, height);
1530         maskCtx.restore();
1531       }
1532     }
1533 
1534     layerCtx.save();
1535     layerCtx.globalAlpha = 1;
1536     layerCtx.setTransform(1, 0, 0, 1, 0, 0);
1537 
1538     if (subtype === "Alpha" && transferMap) {
1539       layerCtx.filter = this.filterFactory.addAlphaFilter(transferMap);
1540     } else if (subtype === "Luminosity") {
1541       layerCtx.filter = this.filterFactory.addLuminosityFilter(transferMap);
1542     }
1543 
1544     const clip = new Path2D();
1545     clip.rect(layerOffsetX, layerOffsetY, width, height);
1546     layerCtx.clip(clip);
1547     layerCtx.globalCompositeOperation = "destination-in";
1548     layerCtx.drawImage(
1549       maskCanvas,
1550       maskX,
1551       maskY,
1552       width,
1553       height,
1554       layerOffsetX,
1555       layerOffsetY,
1556       width,
1557       height
1558     );
1559     layerCtx.restore();
1560   }
1561 
1562   save() {
1563     if (this.inSMaskMode) {
1564       // SMask mode may be turned on/off causing us to lose graphics state.
1565       // Copy the temporary canvas state to the main(suspended) canvas to keep
1566       // it in sync.
1567       copyCtxState(this.ctx, this.suspendedCtx);
1568       // Don't bother calling save on the temporary canvas since state is not
1569       // saved there.
1570       this.suspendedCtx.save();
1571     } else {
1572       this.ctx.save();
1573     }
1574     const old = this.current;
1575     this.stateStack.push(old);
1576     this.current = old.clone();
1577   }
1578 
1579   restore() {
1580     if (this.stateStack.length === 0 && this.inSMaskMode) {
1581       this.endSMaskMode();
1582     }
1583     if (this.stateStack.length !== 0) {
1584       this.current = this.stateStack.pop();
1585       if (this.inSMaskMode) {
1586         // Graphics state is stored on the main(suspended) canvas. Restore its
1587         // state then copy it over to the temporary canvas.
1588         this.suspendedCtx.restore();
1589         copyCtxState(this.suspendedCtx, this.ctx);
1590       } else {
1591         this.ctx.restore();
1592       }
1593       this.checkSMaskState();
1594 
1595       // Ensure that the clipping path is reset (fixes issue6413.pdf).
1596       this.pendingClip = null;
1597 
1598       this._cachedScaleForStroking[0] = -1;
1599       this._cachedGetSinglePixelWidth = null;
1600     }
1601   }
1602 
1603   transform(a, b, c, d, e, f) {
1604     this.ctx.transform(a, b, c, d, e, f);
1605 
1606     this._cachedScaleForStroking[0] = -1;
1607     this._cachedGetSinglePixelWidth = null;
1608   }
1609 
1610   // Path
1611   constructPath(ops, args, minMax) {
1612     const ctx = this.ctx;
1613     const current = this.current;
1614     let x = current.x,
1615       y = current.y;
1616     let startX, startY;
1617     const currentTransform = getCurrentTransform(ctx);
1618 
1619     // Most of the time the current transform is a scaling matrix
1620     // so we don't need to transform points before computing min/max:
1621     // we can compute min/max first and then smartly "apply" the
1622     // transform (see Util.scaleMinMax).
1623     // For rectangle, moveTo and lineTo, min/max are computed in the
1624     // worker (see evaluator.js).
1625     const isScalingMatrix =
1626       (currentTransform[0] === 0 && currentTransform[3] === 0) ||
1627       (currentTransform[1] === 0 && currentTransform[2] === 0);
1628     const minMaxForBezier = isScalingMatrix ? minMax.slice(0) : null;
1629 
1630     for (let i = 0, j = 0, ii = ops.length; i < ii; i++) {
1631       switch (ops[i] | 0) {
1632         case OPS.rectangle:
1633           x = args[j++];
1634           y = args[j++];
1635           const width = args[j++];
1636           const height = args[j++];
1637 
1638           const xw = x + width;
1639           const yh = y + height;
1640           ctx.moveTo(x, y);
1641           if (width === 0 || height === 0) {
1642             ctx.lineTo(xw, yh);
1643           } else {
1644             ctx.lineTo(xw, y);
1645             ctx.lineTo(xw, yh);
1646             ctx.lineTo(x, yh);
1647           }
1648           if (!isScalingMatrix) {
1649             current.updateRectMinMax(currentTransform, [x, y, xw, yh]);
1650           }
1651           ctx.closePath();
1652           break;
1653         case OPS.moveTo:
1654           x = args[j++];
1655           y = args[j++];
1656           ctx.moveTo(x, y);
1657           if (!isScalingMatrix) {
1658             current.updatePathMinMax(currentTransform, x, y);
1659           }
1660           break;
1661         case OPS.lineTo:
1662           x = args[j++];
1663           y = args[j++];
1664           ctx.lineTo(x, y);
1665           if (!isScalingMatrix) {
1666             current.updatePathMinMax(currentTransform, x, y);
1667           }
1668           break;
1669         case OPS.curveTo:
1670           startX = x;
1671           startY = y;
1672           x = args[j + 4];
1673           y = args[j + 5];
1674           ctx.bezierCurveTo(
1675             args[j],
1676             args[j + 1],
1677             args[j + 2],
1678             args[j + 3],
1679             x,
1680             y
1681           );
1682           current.updateCurvePathMinMax(
1683             currentTransform,
1684             startX,
1685             startY,
1686             args[j],
1687             args[j + 1],
1688             args[j + 2],
1689             args[j + 3],
1690             x,
1691             y,
1692             minMaxForBezier
1693           );
1694           j += 6;
1695           break;
1696         case OPS.curveTo2:
1697           startX = x;
1698           startY = y;
1699           ctx.bezierCurveTo(
1700             x,
1701             y,
1702             args[j],
1703             args[j + 1],
1704             args[j + 2],
1705             args[j + 3]
1706           );
1707           current.updateCurvePathMinMax(
1708             currentTransform,
1709             startX,
1710             startY,
1711             x,
1712             y,
1713             args[j],
1714             args[j + 1],
1715             args[j + 2],
1716             args[j + 3],
1717             minMaxForBezier
1718           );
1719           x = args[j + 2];
1720           y = args[j + 3];
1721           j += 4;
1722           break;
1723         case OPS.curveTo3:
1724           startX = x;
1725           startY = y;
1726           x = args[j + 2];
1727           y = args[j + 3];
1728           ctx.bezierCurveTo(args[j], args[j + 1], x, y, x, y);
1729           current.updateCurvePathMinMax(
1730             currentTransform,
1731             startX,
1732             startY,
1733             args[j],
1734             args[j + 1],
1735             x,
1736             y,
1737             x,
1738             y,
1739             minMaxForBezier
1740           );
1741           j += 4;
1742           break;
1743         case OPS.closePath:
1744           ctx.closePath();
1745           break;
1746       }
1747     }
1748 
1749     if (isScalingMatrix) {
1750       current.updateScalingPathMinMax(currentTransform, minMaxForBezier);
1751     }
1752 
1753     current.setCurrentPoint(x, y);
1754   }
1755 
1756   closePath() {
1757     this.ctx.closePath();
1758   }
1759 
1760   stroke(consumePath = true) {
1761     const ctx = this.ctx;
1762     const strokeColor = this.current.strokeColor;
1763     // For stroke we want to temporarily change the global alpha to the
1764     // stroking alpha.
1765     ctx.globalAlpha = this.current.strokeAlpha;
1766     if (this.contentVisible) {
1767       if (typeof strokeColor === "object" && strokeColor?.getPattern) {
1768         ctx.save();
1769         ctx.strokeStyle = strokeColor.getPattern(
1770           ctx,
1771           this,
1772           getCurrentTransformInverse(ctx),
1773           PathType.STROKE
1774         );
1775         this.rescaleAndStroke(/* saveRestore */ false);
1776         ctx.restore();
1777       } else {
1778         this.rescaleAndStroke(/* saveRestore */ true);
1779       }
1780     }
1781     if (consumePath) {
1782       this.consumePath(this.current.getClippedPathBoundingBox());
1783     }
1784     // Restore the global alpha to the fill alpha
1785     ctx.globalAlpha = this.current.fillAlpha;
1786   }
1787 
1788   closeStroke() {
1789     this.closePath();
1790     this.stroke();
1791   }
1792 
1793   fill(consumePath = true) {
1794     const ctx = this.ctx;
1795     const fillColor = this.current.fillColor;
1796     const isPatternFill = this.current.patternFill;
1797     let needRestore = false;
1798 
1799     if (isPatternFill) {
1800       ctx.save();
1801       ctx.fillStyle = fillColor.getPattern(
1802         ctx,
1803         this,
1804         getCurrentTransformInverse(ctx),
1805         PathType.FILL
1806       );
1807       needRestore = true;
1808     }
1809 
1810     const intersect = this.current.getClippedPathBoundingBox();
1811     if (this.contentVisible && intersect !== null) {
1812       if (this.pendingEOFill) {
1813         ctx.fill("evenodd");
1814         this.pendingEOFill = false;
1815       } else {
1816         ctx.fill();
1817       }
1818     }
1819 
1820     if (needRestore) {
1821       ctx.restore();
1822     }
1823     if (consumePath) {
1824       this.consumePath(intersect);
1825     }
1826   }
1827 
1828   eoFill() {
1829     this.pendingEOFill = true;
1830     this.fill();
1831   }
1832 
1833   fillStroke() {
1834     this.fill(false);
1835     this.stroke(false);
1836 
1837     this.consumePath();
1838   }
1839 
1840   eoFillStroke() {
1841     this.pendingEOFill = true;
1842     this.fillStroke();
1843   }
1844 
1845   closeFillStroke() {
1846     this.closePath();
1847     this.fillStroke();
1848   }
1849 
1850   closeEOFillStroke() {
1851     this.pendingEOFill = true;
1852     this.closePath();
1853     this.fillStroke();
1854   }
1855 
1856   endPath() {
1857     this.consumePath();
1858   }
1859 
1860   // Clipping
1861   clip() {
1862     this.pendingClip = NORMAL_CLIP;
1863   }
1864 
1865   eoClip() {
1866     this.pendingClip = EO_CLIP;
1867   }
1868 
1869   // Text
1870   beginText() {
1871     this.current.textMatrix = IDENTITY_MATRIX;
1872     this.current.textMatrixScale = 1;
1873     this.current.x = this.current.lineX = 0;
1874     this.current.y = this.current.lineY = 0;
1875   }
1876 
1877   endText() {
1878     const paths = this.pendingTextPaths;
1879     const ctx = this.ctx;
1880     if (paths === undefined) {
1881       ctx.beginPath();
1882       return;
1883     }
1884 
1885     ctx.save();
1886     ctx.beginPath();
1887     for (const path of paths) {
1888       ctx.setTransform(...path.transform);
1889       ctx.translate(path.x, path.y);
1890       path.addToPath(ctx, path.fontSize);
1891     }
1892     ctx.restore();
1893     ctx.clip();
1894     ctx.beginPath();
1895     delete this.pendingTextPaths;
1896   }
1897 
1898   setCharSpacing(spacing) {
1899     this.current.charSpacing = spacing;
1900   }
1901 
1902   setWordSpacing(spacing) {
1903     this.current.wordSpacing = spacing;
1904   }
1905 
1906   setHScale(scale) {
1907     this.current.textHScale = scale / 100;
1908   }
1909 
1910   setLeading(leading) {
1911     this.current.leading = -leading;
1912   }
1913 
1914   setFont(fontRefName, size) {
1915     const fontObj = this.commonObjs.get(fontRefName);
1916     const current = this.current;
1917 
1918     if (!fontObj) {
1919       throw new Error(`Can't find font for ${fontRefName}`);
1920     }
1921     current.fontMatrix = fontObj.fontMatrix || FONT_IDENTITY_MATRIX;
1922 
1923     // A valid matrix needs all main diagonal elements to be non-zero
1924     // This also ensures we bypass FF bugzilla bug #719844.
1925     if (current.fontMatrix[0] === 0 || current.fontMatrix[3] === 0) {
1926       warn("Invalid font matrix for font " + fontRefName);
1927     }
1928 
1929     // The spec for Tf (setFont) says that 'size' specifies the font 'scale',
1930     // and in some docs this can be negative (inverted x-y axes).
1931     if (size < 0) {
1932       size = -size;
1933       current.fontDirection = -1;
1934     } else {
1935       current.fontDirection = 1;
1936     }
1937 
1938     this.current.font = fontObj;
1939     this.current.fontSize = size;
1940 
1941     if (fontObj.isType3Font) {
1942       return; // we don't need ctx.font for Type3 fonts
1943     }
1944 
1945     const name = fontObj.loadedName || "sans-serif";
1946     const typeface =
1947       fontObj.systemFontInfo?.css || `"${name}", ${fontObj.fallbackName}`;
1948 
1949     let bold = "normal";
1950     if (fontObj.black) {
1951       bold = "900";
1952     } else if (fontObj.bold) {
1953       bold = "bold";
1954     }
1955     const italic = fontObj.italic ? "italic" : "normal";
1956 
1957     // Some font backends cannot handle fonts below certain size.
1958     // Keeping the font at minimal size and using the fontSizeScale to change
1959     // the current transformation matrix before the fillText/strokeText.
1960     // See https://bugzilla.mozilla.org/show_bug.cgi?id=726227
1961     let browserFontSize = size;
1962     if (size < MIN_FONT_SIZE) {
1963       browserFontSize = MIN_FONT_SIZE;
1964     } else if (size > MAX_FONT_SIZE) {
1965       browserFontSize = MAX_FONT_SIZE;
1966     }
1967     this.current.fontSizeScale = size / browserFontSize;
1968 
1969     this.ctx.font = `${italic} ${bold} ${browserFontSize}px ${typeface}`;
1970   }
1971 
1972   setTextRenderingMode(mode) {
1973     this.current.textRenderingMode = mode;
1974   }
1975 
1976   setTextRise(rise) {
1977     this.current.textRise = rise;
1978   }
1979 
1980   moveText(x, y) {
1981     this.current.x = this.current.lineX += x;
1982     this.current.y = this.current.lineY += y;
1983   }
1984 
1985   setLeadingMoveText(x, y) {
1986     this.setLeading(-y);
1987     this.moveText(x, y);
1988   }
1989 
1990   setTextMatrix(a, b, c, d, e, f) {
1991     this.current.textMatrix = [a, b, c, d, e, f];
1992     this.current.textMatrixScale = Math.hypot(a, b);
1993 
1994     this.current.x = this.current.lineX = 0;
1995     this.current.y = this.current.lineY = 0;
1996   }
1997 
1998   nextLine() {
1999     this.moveText(0, this.current.leading);
2000   }
2001 
2002   paintChar(character, x, y, patternTransform) {
2003     const ctx = this.ctx;
2004     const current = this.current;
2005     const font = current.font;
2006     const textRenderingMode = current.textRenderingMode;
2007     const fontSize = current.fontSize / current.fontSizeScale;
2008     const fillStrokeMode =
2009       textRenderingMode & TextRenderingMode.FILL_STROKE_MASK;
2010     const isAddToPathSet = !!(
2011       textRenderingMode & TextRenderingMode.ADD_TO_PATH_FLAG
2012     );
2013     const patternFill = current.patternFill && !font.missingFile;
2014 
2015     let addToPath;
2016     if (font.disableFontFace || isAddToPathSet || patternFill) {
2017       addToPath = font.getPathGenerator(this.commonObjs, character);
2018     }
2019 
2020     if (font.disableFontFace || patternFill) {
2021       ctx.save();
2022       ctx.translate(x, y);
2023       ctx.beginPath();
2024       addToPath(ctx, fontSize);
2025       if (patternTransform) {
2026         ctx.setTransform(...patternTransform);
2027       }
2028       if (
2029         fillStrokeMode === TextRenderingMode.FILL ||
2030         fillStrokeMode === TextRenderingMode.FILL_STROKE
2031       ) {
2032         ctx.fill();
2033       }
2034       if (
2035         fillStrokeMode === TextRenderingMode.STROKE ||
2036         fillStrokeMode === TextRenderingMode.FILL_STROKE
2037       ) {
2038         ctx.stroke();
2039       }
2040       ctx.restore();
2041     } else {
2042       if (
2043         fillStrokeMode === TextRenderingMode.FILL ||
2044         fillStrokeMode === TextRenderingMode.FILL_STROKE
2045       ) {
2046         ctx.fillText(character, x, y);
2047       }
2048       if (
2049         fillStrokeMode === TextRenderingMode.STROKE ||
2050         fillStrokeMode === TextRenderingMode.FILL_STROKE
2051       ) {
2052         ctx.strokeText(character, x, y);
2053       }
2054     }
2055 
2056     if (isAddToPathSet) {
2057       const paths = (this.pendingTextPaths ||= []);
2058       paths.push({
2059         transform: getCurrentTransform(ctx),
2060         x,
2061         y,
2062         fontSize,
2063         addToPath,
2064       });
2065     }
2066   }
2067 
2068   get isFontSubpixelAAEnabled() {
2069     // Checks if anti-aliasing is enabled when scaled text is painted.
2070     // On Windows GDI scaled fonts looks bad.
2071     const { context: ctx } = this.cachedCanvases.getCanvas(
2072       "isFontSubpixelAAEnabled",
2073       10,
2074       10
2075     );
2076     ctx.scale(1.5, 1);
2077     ctx.fillText("I", 0, 10);
2078     const data = ctx.getImageData(0, 0, 10, 10).data;
2079     let enabled = false;
2080     for (let i = 3; i < data.length; i += 4) {
2081       if (data[i] > 0 && data[i] < 255) {
2082         enabled = true;
2083         break;
2084       }
2085     }
2086     return shadow(this, "isFontSubpixelAAEnabled", enabled);
2087   }
2088 
2089   showText(glyphs) {
2090     const current = this.current;
2091     const font = current.font;
2092     if (font.isType3Font) {
2093       return this.showType3Text(glyphs);
2094     }
2095 
2096     const fontSize = current.fontSize;
2097     if (fontSize === 0) {
2098       return undefined;
2099     }
2100 
2101     const ctx = this.ctx;
2102     const fontSizeScale = current.fontSizeScale;
2103     const charSpacing = current.charSpacing;
2104     const wordSpacing = current.wordSpacing;
2105     const fontDirection = current.fontDirection;
2106     const textHScale = current.textHScale * fontDirection;
2107     const glyphsLength = glyphs.length;
2108     const vertical = font.vertical;
2109     const spacingDir = vertical ? 1 : -1;
2110     const defaultVMetrics = font.defaultVMetrics;
2111     const widthAdvanceScale = fontSize * current.fontMatrix[0];
2112 
2113     const simpleFillText =
2114       current.textRenderingMode === TextRenderingMode.FILL &&
2115       !font.disableFontFace &&
2116       !current.patternFill;
2117 
2118     ctx.save();
2119     ctx.transform(...current.textMatrix);
2120     ctx.translate(current.x, current.y + current.textRise);
2121 
2122     if (fontDirection > 0) {
2123       ctx.scale(textHScale, -1);
2124     } else {
2125       ctx.scale(textHScale, 1);
2126     }
2127 
2128     let patternTransform;
2129     if (current.patternFill) {
2130       ctx.save();
2131       const pattern = current.fillColor.getPattern(
2132         ctx,
2133         this,
2134         getCurrentTransformInverse(ctx),
2135         PathType.FILL
2136       );
2137       patternTransform = getCurrentTransform(ctx);
2138       ctx.restore();
2139       ctx.fillStyle = pattern;
2140     }
2141 
2142     let lineWidth = current.lineWidth;
2143     const scale = current.textMatrixScale;
2144     if (scale === 0 || lineWidth === 0) {
2145       const fillStrokeMode =
2146         current.textRenderingMode & TextRenderingMode.FILL_STROKE_MASK;
2147       if (
2148         fillStrokeMode === TextRenderingMode.STROKE ||
2149         fillStrokeMode === TextRenderingMode.FILL_STROKE
2150       ) {
2151         lineWidth = this.getSinglePixelWidth();
2152       }
2153     } else {
2154       lineWidth /= scale;
2155     }
2156 
2157     if (fontSizeScale !== 1.0) {
2158       ctx.scale(fontSizeScale, fontSizeScale);
2159       lineWidth /= fontSizeScale;
2160     }
2161 
2162     ctx.lineWidth = lineWidth;
2163 
2164     if (font.isInvalidPDFjsFont) {
2165       const chars = [];
2166       let width = 0;
2167       for (const glyph of glyphs) {
2168         chars.push(glyph.unicode);
2169         width += glyph.width;
2170       }
2171       ctx.fillText(chars.join(""), 0, 0);
2172       current.x += width * widthAdvanceScale * textHScale;
2173       ctx.restore();
2174       this.compose();
2175 
2176       return undefined;
2177     }
2178 
2179     let x = 0,
2180       i;
2181     for (i = 0; i < glyphsLength; ++i) {
2182       const glyph = glyphs[i];
2183       if (typeof glyph === "number") {
2184         x += (spacingDir * glyph * fontSize) / 1000;
2185         continue;
2186       }
2187 
2188       let restoreNeeded = false;
2189       const spacing = (glyph.isSpace ? wordSpacing : 0) + charSpacing;
2190       const character = glyph.fontChar;
2191       const accent = glyph.accent;
2192       let scaledX, scaledY;
2193       let width = glyph.width;
2194       if (vertical) {
2195         const vmetric = glyph.vmetric || defaultVMetrics;
2196         const vx =
2197           -(glyph.vmetric ? vmetric[1] : width * 0.5) * widthAdvanceScale;
2198         const vy = vmetric[2] * widthAdvanceScale;
2199 
2200         width = vmetric ? -vmetric[0] : width;
2201         scaledX = vx / fontSizeScale;
2202         scaledY = (x + vy) / fontSizeScale;
2203       } else {
2204         scaledX = x / fontSizeScale;
2205         scaledY = 0;
2206       }
2207 
2208       if (font.remeasure && width > 0) {
2209         // Some standard fonts may not have the exact width: rescale per
2210         // character if measured width is greater than expected glyph width
2211         // and subpixel-aa is enabled, otherwise just center the glyph.
2212         const measuredWidth =
2213           ((ctx.measureText(character).width * 1000) / fontSize) *
2214           fontSizeScale;
2215         if (width < measuredWidth && this.isFontSubpixelAAEnabled) {
2216           const characterScaleX = width / measuredWidth;
2217           restoreNeeded = true;
2218           ctx.save();
2219           ctx.scale(characterScaleX, 1);
2220           scaledX /= characterScaleX;
2221         } else if (width !== measuredWidth) {
2222           scaledX +=
2223             (((width - measuredWidth) / 2000) * fontSize) / fontSizeScale;
2224         }
2225       }
2226 
2227       // Only attempt to draw the glyph if it is actually in the embedded font
2228       // file or if there isn't a font file so the fallback font is shown.
2229       if (this.contentVisible && (glyph.isInFont || font.missingFile)) {
2230         if (simpleFillText && !accent) {
2231           // common case
2232           ctx.fillText(character, scaledX, scaledY);
2233         } else {
2234           this.paintChar(character, scaledX, scaledY, patternTransform);
2235           if (accent) {
2236             const scaledAccentX =
2237               scaledX + (fontSize * accent.offset.x) / fontSizeScale;
2238             const scaledAccentY =
2239               scaledY - (fontSize * accent.offset.y) / fontSizeScale;
2240             this.paintChar(
2241               accent.fontChar,
2242               scaledAccentX,
2243               scaledAccentY,
2244               patternTransform
2245             );
2246           }
2247         }
2248       }
2249 
2250       const charWidth = vertical
2251         ? width * widthAdvanceScale - spacing * fontDirection
2252         : width * widthAdvanceScale + spacing * fontDirection;
2253       x += charWidth;
2254 
2255       if (restoreNeeded) {
2256         ctx.restore();
2257       }
2258     }
2259     if (vertical) {
2260       current.y -= x;
2261     } else {
2262       current.x += x * textHScale;
2263     }
2264     ctx.restore();
2265     this.compose();
2266 
2267     return undefined;
2268   }
2269 
2270   showType3Text(glyphs) {
2271     // Type3 fonts - each glyph is a "mini-PDF"
2272     const ctx = this.ctx;
2273     const current = this.current;
2274     const font = current.font;
2275     const fontSize = current.fontSize;
2276     const fontDirection = current.fontDirection;
2277     const spacingDir = font.vertical ? 1 : -1;
2278     const charSpacing = current.charSpacing;
2279     const wordSpacing = current.wordSpacing;
2280     const textHScale = current.textHScale * fontDirection;
2281     const fontMatrix = current.fontMatrix || FONT_IDENTITY_MATRIX;
2282     const glyphsLength = glyphs.length;
2283     const isTextInvisible =
2284       current.textRenderingMode === TextRenderingMode.INVISIBLE;
2285     let i, glyph, width, spacingLength;
2286 
2287     if (isTextInvisible || fontSize === 0) {
2288       return;
2289     }
2290     this._cachedScaleForStroking[0] = -1;
2291     this._cachedGetSinglePixelWidth = null;
2292 
2293     ctx.save();
2294     ctx.transform(...current.textMatrix);
2295     ctx.translate(current.x, current.y);
2296 
2297     ctx.scale(textHScale, fontDirection);
2298 
2299     for (i = 0; i < glyphsLength; ++i) {
2300       glyph = glyphs[i];
2301       if (typeof glyph === "number") {
2302         spacingLength = (spacingDir * glyph * fontSize) / 1000;
2303         this.ctx.translate(spacingLength, 0);
2304         current.x += spacingLength * textHScale;
2305         continue;
2306       }
2307 
2308       const spacing = (glyph.isSpace ? wordSpacing : 0) + charSpacing;
2309       const operatorList = font.charProcOperatorList[glyph.operatorListId];
2310       if (!operatorList) {
2311         warn(`Type3 character "${glyph.operatorListId}" is not available.`);
2312         continue;
2313       }
2314       if (this.contentVisible) {
2315         this.processingType3 = glyph;
2316         this.save();
2317         ctx.scale(fontSize, fontSize);
2318         ctx.transform(...fontMatrix);
2319         this.executeOperatorList(operatorList);
2320         this.restore();
2321       }
2322 
2323       const transformed = Util.applyTransform([glyph.width, 0], fontMatrix);
2324       width = transformed[0] * fontSize + spacing;
2325 
2326       ctx.translate(width, 0);
2327       current.x += width * textHScale;
2328     }
2329     ctx.restore();
2330     this.processingType3 = null;
2331   }
2332 
2333   // Type3 fonts
2334   setCharWidth(xWidth, yWidth) {
2335     // We can safely ignore this since the width should be the same
2336     // as the width in the Widths array.
2337   }
2338 
2339   setCharWidthAndBounds(xWidth, yWidth, llx, lly, urx, ury) {
2340     this.ctx.rect(llx, lly, urx - llx, ury - lly);
2341     this.ctx.clip();
2342     this.endPath();
2343   }
2344 
2345   // Color
2346   getColorN_Pattern(IR) {
2347     let pattern;
2348     if (IR[0] === "TilingPattern") {
2349       const color = IR[1];
2350       const baseTransform = this.baseTransform || getCurrentTransform(this.ctx);
2351       const canvasGraphicsFactory = {
2352         createCanvasGraphics: ctx =>
2353           new CanvasGraphics(
2354             ctx,
2355             this.commonObjs,
2356             this.objs,
2357             this.canvasFactory,
2358             this.filterFactory,
2359             {
2360               optionalContentConfig: this.optionalContentConfig,
2361               markedContentStack: this.markedContentStack,
2362             }
2363           ),
2364       };
2365       pattern = new TilingPattern(
2366         IR,
2367         color,
2368         this.ctx,
2369         canvasGraphicsFactory,
2370         baseTransform
2371       );
2372     } else {
2373       pattern = this._getPattern(IR[1], IR[2]);
2374     }
2375     return pattern;
2376   }
2377 
2378   setStrokeColorN() {
2379     this.current.strokeColor = this.getColorN_Pattern(arguments);
2380   }
2381 
2382   setFillColorN() {
2383     this.current.fillColor = this.getColorN_Pattern(arguments);
2384     this.current.patternFill = true;
2385   }
2386 
2387   setStrokeRGBColor(r, g, b) {
2388     const color = Util.makeHexColor(r, g, b);
2389     this.ctx.strokeStyle = color;
2390     this.current.strokeColor = color;
2391   }
2392 
2393   setFillRGBColor(r, g, b) {
2394     const color = Util.makeHexColor(r, g, b);
2395     this.ctx.fillStyle = color;
2396     this.current.fillColor = color;
2397     this.current.patternFill = false;
2398   }
2399 
2400   _getPattern(objId, matrix = null) {
2401     let pattern;
2402     if (this.cachedPatterns.has(objId)) {
2403       pattern = this.cachedPatterns.get(objId);
2404     } else {
2405       pattern = getShadingPattern(this.getObject(objId));
2406       this.cachedPatterns.set(objId, pattern);
2407     }
2408     if (matrix) {
2409       pattern.matrix = matrix;
2410     }
2411     return pattern;
2412   }
2413 
2414   shadingFill(objId) {
2415     if (!this.contentVisible) {
2416       return;
2417     }
2418     const ctx = this.ctx;
2419 
2420     this.save();
2421     const pattern = this._getPattern(objId);
2422     ctx.fillStyle = pattern.getPattern(
2423       ctx,
2424       this,
2425       getCurrentTransformInverse(ctx),
2426       PathType.SHADING
2427     );
2428 
2429     const inv = getCurrentTransformInverse(ctx);
2430     if (inv) {
2431       const { width, height } = ctx.canvas;
2432       const [x0, y0, x1, y1] = Util.getAxialAlignedBoundingBox(
2433         [0, 0, width, height],
2434         inv
2435       );
2436 
2437       this.ctx.fillRect(x0, y0, x1 - x0, y1 - y0);
2438     } else {
2439       // HACK to draw the gradient onto an infinite rectangle.
2440       // PDF gradients are drawn across the entire image while
2441       // Canvas only allows gradients to be drawn in a rectangle
2442       // The following bug should allow us to remove this.
2443       // https://bugzilla.mozilla.org/show_bug.cgi?id=664884
2444 
2445       this.ctx.fillRect(-1e10, -1e10, 2e10, 2e10);
2446     }
2447 
2448     this.compose(this.current.getClippedPathBoundingBox());
2449     this.restore();
2450   }
2451 
2452   // Images
2453   beginInlineImage() {
2454     unreachable("Should not call beginInlineImage");
2455   }
2456 
2457   beginImageData() {
2458     unreachable("Should not call beginImageData");
2459   }
2460 
2461   paintFormXObjectBegin(matrix, bbox) {
2462     if (!this.contentVisible) {
2463       return;
2464     }
2465     this.save();
2466     this.baseTransformStack.push(this.baseTransform);
2467 
2468     if (matrix) {
2469       this.transform(...matrix);
2470     }
2471     this.baseTransform = getCurrentTransform(this.ctx);
2472 
2473     if (bbox) {
2474       const width = bbox[2] - bbox[0];
2475       const height = bbox[3] - bbox[1];
2476       this.ctx.rect(bbox[0], bbox[1], width, height);
2477       this.current.updateRectMinMax(getCurrentTransform(this.ctx), bbox);
2478       this.clip();
2479       this.endPath();
2480     }
2481   }
2482 
2483   paintFormXObjectEnd() {
2484     if (!this.contentVisible) {
2485       return;
2486     }
2487     this.restore();
2488     this.baseTransform = this.baseTransformStack.pop();
2489   }
2490 
2491   beginGroup(group) {
2492     if (!this.contentVisible) {
2493       return;
2494     }
2495 
2496     this.save();
2497     // If there's an active soft mask we don't want it enabled for the group, so
2498     // clear it out. The mask and suspended canvas will be restored in endGroup.
2499     if (this.inSMaskMode) {
2500       this.endSMaskMode();
2501       this.current.activeSMask = null;
2502     }
2503 
2504     const currentCtx = this.ctx;
2505     // TODO non-isolated groups - according to Rik at adobe non-isolated
2506     // group results aren't usually that different and they even have tools
2507     // that ignore this setting. Notes from Rik on implementing:
2508     // - When you encounter an transparency group, create a new canvas with
2509     // the dimensions of the bbox
2510     // - copy the content from the previous canvas to the new canvas
2511     // - draw as usual
2512     // - remove the backdrop alpha:
2513     // alphaNew = 1 - (1 - alpha)/(1 - alphaBackdrop) with 'alpha' the alpha
2514     // value of your transparency group and 'alphaBackdrop' the alpha of the
2515     // backdrop
2516     // - remove background color:
2517     // colorNew = color - alphaNew *colorBackdrop /(1 - alphaNew)
2518     if (!group.isolated) {
2519       info("TODO: Support non-isolated groups.");
2520     }
2521 
2522     // TODO knockout - supposedly possible with the clever use of compositing
2523     // modes.
2524     if (group.knockout) {
2525       warn("Knockout groups not supported.");
2526     }
2527 
2528     const currentTransform = getCurrentTransform(currentCtx);
2529     if (group.matrix) {
2530       currentCtx.transform(...group.matrix);
2531     }
2532     if (!group.bbox) {
2533       throw new Error("Bounding box is required.");
2534     }
2535 
2536     // Based on the current transform figure out how big the bounding box
2537     // will actually be.
2538     let bounds = Util.getAxialAlignedBoundingBox(
2539       group.bbox,
2540       getCurrentTransform(currentCtx)
2541     );
2542     // Clip the bounding box to the current canvas.
2543     const canvasBounds = [
2544       0,
2545       0,
2546       currentCtx.canvas.width,
2547       currentCtx.canvas.height,
2548     ];
2549     bounds = Util.intersect(bounds, canvasBounds) || [0, 0, 0, 0];
2550     // Use ceil in case we're between sizes so we don't create canvas that is
2551     // too small and make the canvas at least 1x1 pixels.
2552     const offsetX = Math.floor(bounds[0]);
2553     const offsetY = Math.floor(bounds[1]);
2554     const drawnWidth = Math.max(Math.ceil(bounds[2]) - offsetX, 1);
2555     const drawnHeight = Math.max(Math.ceil(bounds[3]) - offsetY, 1);
2556 
2557     this.current.startNewPathAndClipBox([0, 0, drawnWidth, drawnHeight]);
2558 
2559     let cacheId = "groupAt" + this.groupLevel;
2560     if (group.smask) {
2561       // Using two cache entries is case if masks are used one after another.
2562       cacheId += "_smask_" + (this.smaskCounter++ % 2);
2563     }
2564     const scratchCanvas = this.cachedCanvases.getCanvas(
2565       cacheId,
2566       drawnWidth,
2567       drawnHeight
2568     );
2569     const groupCtx = scratchCanvas.context;
2570 
2571     // Since we created a new canvas that is just the size of the bounding box
2572     // we have to translate the group ctx.
2573     groupCtx.translate(-offsetX, -offsetY);
2574     groupCtx.transform(...currentTransform);
2575 
2576     if (group.smask) {
2577       // Saving state and cached mask to be used in setGState.
2578       this.smaskStack.push({
2579         canvas: scratchCanvas.canvas,
2580         context: groupCtx,
2581         offsetX,
2582         offsetY,
2583         subtype: group.smask.subtype,
2584         backdrop: group.smask.backdrop,
2585         transferMap: group.smask.transferMap || null,
2586         startTransformInverse: null, // used during suspend operation
2587       });
2588     } else {
2589       // Setup the current ctx so when the group is popped we draw it at the
2590       // right location.
2591       currentCtx.setTransform(1, 0, 0, 1, 0, 0);
2592       currentCtx.translate(offsetX, offsetY);
2593       currentCtx.save();
2594     }
2595     // The transparency group inherits all off the current graphics state
2596     // except the blend mode, soft mask, and alpha constants.
2597     copyCtxState(currentCtx, groupCtx);
2598     this.ctx = groupCtx;
2599     this.setGState([
2600       ["BM", "source-over"],
2601       ["ca", 1],
2602       ["CA", 1],
2603     ]);
2604     this.groupStack.push(currentCtx);
2605     this.groupLevel++;
2606   }
2607 
2608   endGroup(group) {
2609     if (!this.contentVisible) {
2610       return;
2611     }
2612     this.groupLevel--;
2613     const groupCtx = this.ctx;
2614     const ctx = this.groupStack.pop();
2615     this.ctx = ctx;
2616     // Turn off image smoothing to avoid sub pixel interpolation which can
2617     // look kind of blurry for some pdfs.
2618     this.ctx.imageSmoothingEnabled = false;
2619 
2620     if (group.smask) {
2621       this.tempSMask = this.smaskStack.pop();
2622       this.restore();
2623     } else {
2624       this.ctx.restore();
2625       const currentMtx = getCurrentTransform(this.ctx);
2626       this.restore();
2627       this.ctx.save();
2628       this.ctx.setTransform(...currentMtx);
2629       const dirtyBox = Util.getAxialAlignedBoundingBox(
2630         [0, 0, groupCtx.canvas.width, groupCtx.canvas.height],
2631         currentMtx
2632       );
2633       this.ctx.drawImage(groupCtx.canvas, 0, 0);
2634       this.ctx.restore();
2635       this.compose(dirtyBox);
2636     }
2637   }
2638 
2639   beginAnnotation(id, rect, transform, matrix, hasOwnCanvas) {
2640     // The annotations are drawn just after the page content.
2641     // The page content drawing can potentially have set a transform,
2642     // a clipping path, whatever...
2643     // So in order to have something clean, we restore the initial state.
2644     this.#restoreInitialState();
2645     resetCtxToDefault(this.ctx);
2646 
2647     this.ctx.save();
2648     this.save();
2649 
2650     if (this.baseTransform) {
2651       this.ctx.setTransform(...this.baseTransform);
2652     }
2653 
2654     if (rect) {
2655       const width = rect[2] - rect[0];
2656       const height = rect[3] - rect[1];
2657 
2658       if (hasOwnCanvas && this.annotationCanvasMap) {
2659         transform = transform.slice();
2660         transform[4] -= rect[0];
2661         transform[5] -= rect[1];
2662 
2663         rect = rect.slice();
2664         rect[0] = rect[1] = 0;
2665         rect[2] = width;
2666         rect[3] = height;
2667 
2668         const [scaleX, scaleY] = Util.singularValueDecompose2dScale(
2669           getCurrentTransform(this.ctx)
2670         );
2671         const { viewportScale } = this;
2672         const canvasWidth = Math.ceil(
2673           width * this.outputScaleX * viewportScale
2674         );
2675         const canvasHeight = Math.ceil(
2676           height * this.outputScaleY * viewportScale
2677         );
2678 
2679         this.annotationCanvas = this.canvasFactory.create(
2680           canvasWidth,
2681           canvasHeight
2682         );
2683         const { canvas, context } = this.annotationCanvas;
2684         this.annotationCanvasMap.set(id, canvas);
2685         this.annotationCanvas.savedCtx = this.ctx;
2686         this.ctx = context;
2687         this.ctx.save();
2688         this.ctx.setTransform(scaleX, 0, 0, -scaleY, 0, height * scaleY);
2689 
2690         resetCtxToDefault(this.ctx);
2691       } else {
2692         resetCtxToDefault(this.ctx);
2693 
2694         this.ctx.rect(rect[0], rect[1], width, height);
2695         this.ctx.clip();
2696         this.endPath();
2697       }
2698     }
2699 
2700     this.current = new CanvasExtraState(
2701       this.ctx.canvas.width,
2702       this.ctx.canvas.height
2703     );
2704 
2705     this.transform(...transform);
2706     this.transform(...matrix);
2707   }
2708 
2709   endAnnotation() {
2710     if (this.annotationCanvas) {
2711       this.ctx.restore();
2712       this.#drawFilter();
2713 
2714       this.ctx = this.annotationCanvas.savedCtx;
2715       delete this.annotationCanvas.savedCtx;
2716       delete this.annotationCanvas;
2717     }
2718   }
2719 
2720   paintImageMaskXObject(img) {
2721     if (!this.contentVisible) {
2722       return;
2723     }
2724     const count = img.count;
2725     img = this.getObject(img.data, img);
2726     img.count = count;
2727 
2728     const ctx = this.ctx;
2729     const glyph = this.processingType3;
2730 
2731     if (glyph) {
2732       if (glyph.compiled === undefined) {
2733         glyph.compiled = compileType3Glyph(img);
2734       }
2735 
2736       if (glyph.compiled) {
2737         glyph.compiled(ctx);
2738         return;
2739       }
2740     }
2741     const mask = this._createMaskCanvas(img);
2742     const maskCanvas = mask.canvas;
2743 
2744     ctx.save();
2745     // The mask is drawn with the transform applied. Reset the current
2746     // transform to draw to the identity.
2747     ctx.setTransform(1, 0, 0, 1, 0, 0);
2748     ctx.drawImage(maskCanvas, mask.offsetX, mask.offsetY);
2749     ctx.restore();
2750     this.compose();
2751   }
2752 
2753   paintImageMaskXObjectRepeat(
2754     img,
2755     scaleX,
2756     skewX = 0,
2757     skewY = 0,
2758     scaleY,
2759     positions
2760   ) {
2761     if (!this.contentVisible) {
2762       return;
2763     }
2764 
2765     img = this.getObject(img.data, img);
2766 
2767     const ctx = this.ctx;
2768     ctx.save();
2769     const currentTransform = getCurrentTransform(ctx);
2770     ctx.transform(scaleX, skewX, skewY, scaleY, 0, 0);
2771     const mask = this._createMaskCanvas(img);
2772 
2773     ctx.setTransform(
2774       1,
2775       0,
2776       0,
2777       1,
2778       mask.offsetX - currentTransform[4],
2779       mask.offsetY - currentTransform[5]
2780     );
2781     for (let i = 0, ii = positions.length; i < ii; i += 2) {
2782       const trans = Util.transform(currentTransform, [
2783         scaleX,
2784         skewX,
2785         skewY,
2786         scaleY,
2787         positions[i],
2788         positions[i + 1],
2789       ]);
2790 
2791       const [x, y] = Util.applyTransform([0, 0], trans);
2792       ctx.drawImage(mask.canvas, x, y);
2793     }
2794     ctx.restore();
2795     this.compose();
2796   }
2797 
2798   paintImageMaskXObjectGroup(images) {
2799     if (!this.contentVisible) {
2800       return;
2801     }
2802     const ctx = this.ctx;
2803 
2804     const fillColor = this.current.fillColor;
2805     const isPatternFill = this.current.patternFill;
2806 
2807     for (const image of images) {
2808       const { data, width, height, transform } = image;
2809 
2810       const maskCanvas = this.cachedCanvases.getCanvas(
2811         "maskCanvas",
2812         width,
2813         height
2814       );
2815       const maskCtx = maskCanvas.context;
2816       maskCtx.save();
2817 
2818       const img = this.getObject(data, image);
2819       putBinaryImageMask(maskCtx, img);
2820 
2821       maskCtx.globalCompositeOperation = "source-in";
2822 
2823       maskCtx.fillStyle = isPatternFill
2824         ? fillColor.getPattern(
2825             maskCtx,
2826             this,
2827             getCurrentTransformInverse(ctx),
2828             PathType.FILL
2829           )
2830         : fillColor;
2831       maskCtx.fillRect(0, 0, width, height);
2832 
2833       maskCtx.restore();
2834 
2835       ctx.save();
2836       ctx.transform(...transform);
2837       ctx.scale(1, -1);
2838       drawImageAtIntegerCoords(
2839         ctx,
2840         maskCanvas.canvas,
2841         0,
2842         0,
2843         width,
2844         height,
2845         0,
2846         -1,
2847         1,
2848         1
2849       );
2850       ctx.restore();
2851     }
2852     this.compose();
2853   }
2854 
2855   paintImageXObject(objId) {
2856     if (!this.contentVisible) {
2857       return;
2858     }
2859     const imgData = this.getObject(objId);
2860     if (!imgData) {
2861       warn("Dependent image isn't ready yet");
2862       return;
2863     }
2864 
2865     this.paintInlineImageXObject(imgData);
2866   }
2867 
2868   paintImageXObjectRepeat(objId, scaleX, scaleY, positions) {
2869     if (!this.contentVisible) {
2870       return;
2871     }
2872     const imgData = this.getObject(objId);
2873     if (!imgData) {
2874       warn("Dependent image isn't ready yet");
2875       return;
2876     }
2877 
2878     const width = imgData.width;
2879     const height = imgData.height;
2880     const map = [];
2881     for (let i = 0, ii = positions.length; i < ii; i += 2) {
2882       map.push({
2883         transform: [scaleX, 0, 0, scaleY, positions[i], positions[i + 1]],
2884         x: 0,
2885         y: 0,
2886         w: width,
2887         h: height,
2888       });
2889     }
2890     this.paintInlineImageXObjectGroup(imgData, map);
2891   }
2892 
2893   applyTransferMapsToCanvas(ctx) {
2894     if (this.current.transferMaps !== "none") {
2895       ctx.filter = this.current.transferMaps;
2896       ctx.drawImage(ctx.canvas, 0, 0);
2897       ctx.filter = "none";
2898     }
2899     return ctx.canvas;
2900   }
2901 
2902   applyTransferMapsToBitmap(imgData) {
2903     if (this.current.transferMaps === "none") {
2904       return imgData.bitmap;
2905     }
2906     const { bitmap, width, height } = imgData;
2907     const tmpCanvas = this.cachedCanvases.getCanvas(
2908       "inlineImage",
2909       width,
2910       height
2911     );
2912     const tmpCtx = tmpCanvas.context;
2913     tmpCtx.filter = this.current.transferMaps;
2914     tmpCtx.drawImage(bitmap, 0, 0);
2915     tmpCtx.filter = "none";
2916 
2917     return tmpCanvas.canvas;
2918   }
2919 
2920   paintInlineImageXObject(imgData) {
2921     if (!this.contentVisible) {
2922       return;
2923     }
2924     const width = imgData.width;
2925     const height = imgData.height;
2926     const ctx = this.ctx;
2927 
2928     this.save();
2929 
2930     if (
2931       (typeof PDFJSDev !== "undefined" && PDFJSDev.test("MOZCENTRAL")) ||
2932       !isNodeJS
2933     ) {
2934       // The filter, if any, will be applied in applyTransferMapsToBitmap.
2935       // It must be applied to the image before rescaling else some artifacts
2936       // could appear.
2937       // The final restore will reset it to its value.
2938       const { filter } = ctx;
2939       if (filter !== "none" && filter !== "") {
2940         ctx.filter = "none";
2941       }
2942     }
2943 
2944     // scale the image to the unit square
2945     ctx.scale(1 / width, -1 / height);
2946 
2947     let imgToPaint;
2948     if (imgData.bitmap) {
2949       imgToPaint = this.applyTransferMapsToBitmap(imgData);
2950     } else if (
2951       (typeof HTMLElement === "function" && imgData instanceof HTMLElement) ||
2952       !imgData.data
2953     ) {
2954       // typeof check is needed due to node.js support, see issue #8489
2955       imgToPaint = imgData;
2956     } else {
2957       const tmpCanvas = this.cachedCanvases.getCanvas(
2958         "inlineImage",
2959         width,
2960         height
2961       );
2962       const tmpCtx = tmpCanvas.context;
2963       putBinaryImageData(tmpCtx, imgData);
2964       imgToPaint = this.applyTransferMapsToCanvas(tmpCtx);
2965     }
2966 
2967     const scaled = this._scaleImage(
2968       imgToPaint,
2969       getCurrentTransformInverse(ctx)
2970     );
2971     ctx.imageSmoothingEnabled = getImageSmoothingEnabled(
2972       getCurrentTransform(ctx),
2973       imgData.interpolate
2974     );
2975 
2976     drawImageAtIntegerCoords(
2977       ctx,
2978       scaled.img,
2979       0,
2980       0,
2981       scaled.paintWidth,
2982       scaled.paintHeight,
2983       0,
2984       -height,
2985       width,
2986       height
2987     );
2988     this.compose();
2989     this.restore();
2990   }
2991 
2992   paintInlineImageXObjectGroup(imgData, map) {
2993     if (!this.contentVisible) {
2994       return;
2995     }
2996     const ctx = this.ctx;
2997     let imgToPaint;
2998     if (imgData.bitmap) {
2999       imgToPaint = imgData.bitmap;
3000     } else {
3001       const w = imgData.width;
3002       const h = imgData.height;
3003 
3004       const tmpCanvas = this.cachedCanvases.getCanvas("inlineImage", w, h);
3005       const tmpCtx = tmpCanvas.context;
3006       putBinaryImageData(tmpCtx, imgData);
3007       imgToPaint = this.applyTransferMapsToCanvas(tmpCtx);
3008     }
3009 
3010     for (const entry of map) {
3011       ctx.save();
3012       ctx.transform(...entry.transform);
3013       ctx.scale(1, -1);
3014       drawImageAtIntegerCoords(
3015         ctx,
3016         imgToPaint,
3017         entry.x,
3018         entry.y,
3019         entry.w,
3020         entry.h,
3021         0,
3022         -1,
3023         1,
3024         1
3025       );
3026       ctx.restore();
3027     }
3028     this.compose();
3029   }
3030 
3031   paintSolidColorImageMask() {
3032     if (!this.contentVisible) {
3033       return;
3034     }
3035     this.ctx.fillRect(0, 0, 1, 1);
3036     this.compose();
3037   }
3038 
3039   // Marked content
3040 
3041   markPoint(tag) {
3042     // TODO Marked content.
3043   }
3044 
3045   markPointProps(tag, properties) {
3046     // TODO Marked content.
3047   }
3048 
3049   beginMarkedContent(tag) {
3050     this.markedContentStack.push({
3051       visible: true,
3052     });
3053   }
3054 
3055   beginMarkedContentProps(tag, properties) {
3056     if (tag === "OC") {
3057       this.markedContentStack.push({
3058         visible: this.optionalContentConfig.isVisible(properties),
3059       });
3060     } else {
3061       this.markedContentStack.push({
3062         visible: true,
3063       });
3064     }
3065     this.contentVisible = this.isContentVisible();
3066   }
3067 
3068   endMarkedContent() {
3069     this.markedContentStack.pop();
3070     this.contentVisible = this.isContentVisible();
3071   }
3072 
3073   // Compatibility
3074 
3075   beginCompat() {
3076     // TODO ignore undefined operators (should we do that anyway?)
3077   }
3078 
3079   endCompat() {
3080     // TODO stop ignoring undefined operators
3081   }
3082 
3083   // Helper functions
3084 
3085   consumePath(clipBox) {
3086     const isEmpty = this.current.isEmptyClip();
3087     if (this.pendingClip) {
3088       this.current.updateClipFromPath();
3089     }
3090     if (!this.pendingClip) {
3091       this.compose(clipBox);
3092     }
3093     const ctx = this.ctx;
3094     if (this.pendingClip) {
3095       if (!isEmpty) {
3096         if (this.pendingClip === EO_CLIP) {
3097           ctx.clip("evenodd");
3098         } else {
3099           ctx.clip();
3100         }
3101       }
3102       this.pendingClip = null;
3103     }
3104     this.current.startNewPathAndClipBox(this.current.clipBox);
3105     ctx.beginPath();
3106   }
3107 
3108   getSinglePixelWidth() {
3109     if (!this._cachedGetSinglePixelWidth) {
3110       const m = getCurrentTransform(this.ctx);
3111       if (m[1] === 0 && m[2] === 0) {
3112         // Fast path
3113         this._cachedGetSinglePixelWidth =
3114           1 / Math.min(Math.abs(m[0]), Math.abs(m[3]));
3115       } else {
3116         const absDet = Math.abs(m[0] * m[3] - m[2] * m[1]);
3117         const normX = Math.hypot(m[0], m[2]);
3118         const normY = Math.hypot(m[1], m[3]);
3119         this._cachedGetSinglePixelWidth = Math.max(normX, normY) / absDet;
3120       }
3121     }
3122     return this._cachedGetSinglePixelWidth;
3123   }
3124 
3125   getScaleForStroking() {
3126     // A pixel has thicknessX = thicknessY = 1;
3127     // A transformed pixel is a parallelogram and the thicknesses
3128     // corresponds to the heights.
3129     // The goal of this function is to rescale before setting the
3130     // lineWidth in order to have both thicknesses greater or equal
3131     // to 1 after transform.
3132     if (this._cachedScaleForStroking[0] === -1) {
3133       const { lineWidth } = this.current;
3134       const { a, b, c, d } = this.ctx.getTransform();
3135       let scaleX, scaleY;
3136 
3137       if (b === 0 && c === 0) {
3138         // Fast path
3139         const normX = Math.abs(a);
3140         const normY = Math.abs(d);
3141         if (normX === normY) {
3142           if (lineWidth === 0) {
3143             scaleX = scaleY = 1 / normX;
3144           } else {
3145             const scaledLineWidth = normX * lineWidth;
3146             scaleX = scaleY = scaledLineWidth < 1 ? 1 / scaledLineWidth : 1;
3147           }
3148         } else if (lineWidth === 0) {
3149           scaleX = 1 / normX;
3150           scaleY = 1 / normY;
3151         } else {
3152           const scaledXLineWidth = normX * lineWidth;
3153           const scaledYLineWidth = normY * lineWidth;
3154           scaleX = scaledXLineWidth < 1 ? 1 / scaledXLineWidth : 1;
3155           scaleY = scaledYLineWidth < 1 ? 1 / scaledYLineWidth : 1;
3156         }
3157       } else {
3158         // A pixel (base (x, y)) is transformed by M into a parallelogram:
3159         //  - its area is |det(M)|;
3160         //  - heightY (orthogonal to Mx) has a length: |det(M)| / norm(Mx);
3161         //  - heightX (orthogonal to My) has a length: |det(M)| / norm(My).
3162         // heightX and heightY are the thicknesses of the transformed pixel
3163         // and they must be both greater or equal to 1.
3164         const absDet = Math.abs(a * d - b * c);
3165         const normX = Math.hypot(a, b);
3166         const normY = Math.hypot(c, d);
3167         if (lineWidth === 0) {
3168           scaleX = normY / absDet;
3169           scaleY = normX / absDet;
3170         } else {
3171           const baseArea = lineWidth * absDet;
3172           scaleX = normY > baseArea ? normY / baseArea : 1;
3173           scaleY = normX > baseArea ? normX / baseArea : 1;
3174         }
3175       }
3176       this._cachedScaleForStroking[0] = scaleX;
3177       this._cachedScaleForStroking[1] = scaleY;
3178     }
3179     return this._cachedScaleForStroking;
3180   }
3181 
3182   // Rescale before stroking in order to have a final lineWidth
3183   // with both thicknesses greater or equal to 1.
3184   rescaleAndStroke(saveRestore) {
3185     const { ctx } = this;
3186     const { lineWidth } = this.current;
3187     const [scaleX, scaleY] = this.getScaleForStroking();
3188 
3189     ctx.lineWidth = lineWidth || 1;
3190 
3191     if (scaleX === 1 && scaleY === 1) {
3192       ctx.stroke();
3193       return;
3194     }
3195 
3196     const dashes = ctx.getLineDash();
3197     if (saveRestore) {
3198       ctx.save();
3199     }
3200 
3201     ctx.scale(scaleX, scaleY);
3202 
3203     // How the dashed line is rendered depends on the current transform...
3204     // so we added a rescale to handle too thin lines and consequently
3205     // the way the line is dashed will be modified.
3206     // If scaleX === scaleY, the dashed lines will be rendered correctly
3207     // else we'll have some bugs (but only with too thin lines).
3208     // Here we take the max... why not taking the min... or something else.
3209     // Anyway, as said it's buggy when scaleX !== scaleY.
3210     if (dashes.length > 0) {
3211       const scale = Math.max(scaleX, scaleY);
3212       ctx.setLineDash(dashes.map(x => x / scale));
3213       ctx.lineDashOffset /= scale;
3214     }
3215 
3216     ctx.stroke();
3217 
3218     if (saveRestore) {
3219       ctx.restore();
3220     }
3221   }
3222 
3223   isContentVisible() {
3224     for (let i = this.markedContentStack.length - 1; i >= 0; i--) {
3225       if (!this.markedContentStack[i].visible) {
3226         return false;
3227       }
3228     }
3229     return true;
3230   }
3231 }
3232 
3233 for (const op in OPS) {
3234   if (CanvasGraphics.prototype[op] !== undefined) {
3235     CanvasGraphics.prototype[OPS[op]] = CanvasGraphics.prototype[op];
3236   }
3237 }
3238 
3239 export { CanvasGraphics };
</code>

Your task:
You are a software tester at pdf.js.
1. Write exactly one javascript test `it("...", async () => {...})` block.
2. Your test must fail on the code before the patch, and pass after, hence the test will verify that the patch resolves the issue.
3. The test must be self-contained and to-the-point.
4. Use only the provided imports (respect the paths exactly how they are given) by importing dynamically for compatibility with Node.js — no new dependencies. You can use the PDF file for testing as follows:
const { getDocument } = await import('../../src/display/api.js');
const { buildGetDocumentParams } = await import('./test_utils.js');
const loadingTask = getDocument(buildGetDocumentParams('issue18444.pdf'))
5. Return only the javascript code (no comments or explanations).

Example structure:
it("should <describe behavior>", async () => {
  const { example } = await import("../../src/core/example.js");
  <initialize required variables>;
  <define expected variable>;
  <generate actual variables>;
  <compare expected with actual>;
});

