Before you begin:
- Keep going until the job is completely solved — don’t stop halfway.
- If you’re unsure about the behavior, reread the provided patch carefully; do not hallucinate.
- Plan your approach before writing code by reflecting on whether the test truly fails before and passes after.

Issue:
<issue>
Cannot easily change with the slider the font size in a text editor
</issue>

Patch:
<patch>
diff --git a/src/display/editor/editor.js b/src/display/editor/editor.js
--- a/src/display/editor/editor.js
+++ b/src/display/editor/editor.js
@@ -59,6 +59,8 @@ class AnnotationEditor {
 
   #isInEditMode = false;
 
+  #moveInDOMTimeout = null;
+
   _initialOptions = Object.create(null);
 
   _uiManager = null;
@@ -1046,7 +1048,16 @@ class AnnotationEditor {
   }
 
   moveInDOM() {
-    this.parent?.moveEditorInDOM(this);
+    // Moving the editor in the DOM can be expensive, so we wait a bit before.
+    // It's important to not block the UI (for example when changing the font
+    // size in a FreeText).
+    if (this.#moveInDOMTimeout) {
+      clearTimeout(this.#moveInDOMTimeout);
+    }
+    this.#moveInDOMTimeout = setTimeout(() => {
+      this.#moveInDOMTimeout = null;
+      this.parent?.moveEditorInDOM(this);
+    }, 0);
   }
 
   _setParentAndPosition(parent, x, y) {
@@ -1253,6 +1264,10 @@ class AnnotationEditor {
     this.#altTextButton?.remove();
     this.#altTextButton = null;
     this.#altTextTooltip = null;
+    if (this.#moveInDOMTimeout) {
+      clearTimeout(this.#moveInDOMTimeout);
+      this.#moveInDOMTimeout = null;
+    }
   }
 
   /**


</patch>

Imports:
<imports>
Available Packages
Dev Dependencies:
- @babel/core: ^7.22.20
- @babel/plugin-transform-modules-commonjs: ^7.22.15
- @babel/preset-env: ^7.22.20
- @babel/runtime: ^7.22.15
- @javascript-obfuscator/escodegen: 2.3.0
- acorn: ^8.10.0
- autoprefixer: ^10.4.16
- babel-loader: ^9.1.3
- caniuse-lite: ^1.0.30001538
- canvas: ^2.11.2
- core-js: ^3.32.2
- cross-env: ^7.0.3
- es-module-shims: 1.4.7
- eslint: ^8.50.0
- eslint-config-prettier: ^8.10.0
- eslint-plugin-fetch-options: ^0.0.5
- eslint-plugin-html: ^7.1.0
- eslint-plugin-import: ^2.28.1
- eslint-plugin-json: ^3.1.0
- eslint-plugin-mozilla: ^3.2.0
- eslint-plugin-no-unsanitized: ^4.0.2
- eslint-plugin-prettier: ^5.0.0
- eslint-plugin-sort-exports: ^0.8.0
- eslint-plugin-unicorn: ^48.0.1
- globals: ^13.22.0
- gulp: ^4.0.2
- gulp-postcss: ^9.0.1
- gulp-rename: ^2.0.0
- gulp-replace: ^1.1.4
- gulp-zip: ^5.1.0
- jasmine: ^5.1.0
- jsdoc: ^4.0.2
- jstransformer-markdown-it: ^3.0.0
- merge-stream: ^2.0.0
- mkdirp: ^3.0.1
- needle: ^3.2.0
- path2d-polyfill: ^2.0.1
- pngjs: ^7.0.0
- postcss: ^8.4.30
- postcss-dir-pseudo-class: ^8.0.0
- postcss-nesting: ^12.0.1
- prettier: ^3.0.3
- puppeteer: ^21.2.1
- rimraf: ^3.0.2
- streamqueue: ^1.1.2
- stylelint: ^15.10.3
- stylelint-prettier: ^4.0.2
- terser: ^5.20.0
- through2: ^4.0.2
- tsc-alias: ^1.8.8
- ttest: ^4.0.0
- typescript: ^5.2.2
- typogr: ^0.6.8
- vinyl: ^3.0.0
- webpack: ^5.88.2
- webpack-stream: ^7.0.0
- wintersmith: ^2.5.0
- yargs: ^17.7.2

Engines:
- node: >=18

Available Relative Imports:
- `../../src/core/annotation.js`: Annotation, AnnotationBorderStyle, AnnotationFactory, MarkupAnnotation, getQuadPoints
- `../../src/core/bidi.js`: bidi
- `../../src/core/cff_parser.js`: CFFCharset, CFFCompiler, CFFFDSelect, CFFParser, CFFStrings
- `../../src/core/cmap.js`: CMap, CMapFactory, IdentityCMap
- `../../src/core/colorspace.js`: ColorSpace
- `../../src/core/core_utils.js`: arrayBuffersToBytes, encodeToXmlString, escapePDFName, escapeString, getInheritableProperty, isAscii, isWhiteSpace, log2, numberToString, parseXFAPath, recoverJsURL, stringToUTF16HexString, stringToUTF16String, toRomanNumerals, validateCSSFont
- `../../src/core/crypto.js`: AES128Cipher, AES256Cipher, ARCFourCipher, CipherTransformFactory, PDF17, PDF20, calculateMD5, calculateSHA256, calculateSHA384, calculateSHA512
- `../../src/core/default_appearance.js`: createDefaultAppearance, parseAppearanceStream, parseDefaultAppearance
- `../../src/core/document.js`: PDFDocument, Page
- `../../src/core/encodings.js`: getEncoding
- `../../src/core/evaluator.js`: PartialEvaluator
- `../../src/core/font_substitutions.js`: getFontSubstitution
- `../../src/core/fonts_utils.js`: SEAC_ANALYSIS_ENABLED
- `../../src/core/function.js`: PDFFunctionFactory, PostScriptCompiler, PostScriptEvaluator
- `../../src/core/glyphlist.js`: getDingbatsGlyphsUnicode, getGlyphsUnicode
- `../../src/core/image_utils.js`: GlobalImageCache, LocalColorSpaceCache
- `../../src/core/jbig2.js`: Jbig2Image
- `../../src/core/jpg.js`: JpegImage
- `../../src/core/jpx.js`: JpxImage
- `../../src/core/metadata_parser.js`: MetadataParser
- `../../src/core/operator_list.js`: OperatorList
- `../../src/core/parser.js`: Lexer, Linearization, Parser
- `../../src/core/predictor_stream.js`: PredictorStream
- `../../src/core/primitives.js`: Cmd, Dict, EOF, Name, Ref, RefSet, RefSetCache, isCmd, isDict, isName, isRefsEqual
- `../../src/core/ps_parser.js`: PostScriptLexer, PostScriptParser
- `../../src/core/stream.js`: NullStream, Stream, StringStream
- `../../src/core/type1_parser.js`: Type1Parser
- `../../src/core/unicode.js`: getCharUnicodeCategory, getUnicodeForGlyph, getUnicodeRangeFor, mapSpecialUnicodeValues
- `../../src/core/worker.js`: WorkerMessageHandler, WorkerTask
- `../../src/core/writer.js`: incrementalUpdate, writeDict
- `../../src/core/xfa/bind.js`: Binder
- `../../src/core/xfa/data.js`: DataHandler
- `../../src/core/xfa/factory.js`: XFAFactory
- `../../src/core/xfa/formcalc_lexer.js`: Lexer, TOKEN, Token
- `../../src/core/xfa/formcalc_parser.js`: Errors, Parser
- `../../src/core/xfa/parser.js`: XFAParser
- `../../src/core/xfa/som.js`: searchNode
- `../../src/core/xfa/symbol_utils.js`: $dump, $getChildren, $getChildrenByClass, $getChildrenByName, $text, $uid
- `../../src/core/xml_parser.js`: SimpleXMLParser, XMLParserBase
- `../../src/display/annotation_layer.js`: AnnotationLayer
- `../../src/display/annotation_storage.js`: AnnotationStorage
- `../../src/display/api.js`: DefaultCMapReaderFactory, DefaultCanvasFactory, DefaultStandardFontDataFactory, LoopbackPort, PDFDataRangeTransport, PDFDocumentLoadingTask, PDFDocumentProxy, PDFPageProxy, PDFWorker, PDFWorkerUtil, RenderTask, SVGGraphics, build, getDocument, version
- `../../src/display/display_utils.js`: DOMCanvasFactory, DOMSVGFactory, PDFDateString, PageViewport, PixelsPerInch, RenderingCancelledException, StatTimer, getFilenameFromUrl, getPdfFilenameFromUrl, getXfaPageViewport, isDataScheme, isPdfFile, isValidFetchUrl, loadScript, noContextMenu, setLayerDimensions
- `../../src/display/editor/annotation_editor_layer.js`: AnnotationEditorLayer
- `../../src/display/editor/tools.js`: AnnotationEditorUIManager, CommandManager
- `../../src/display/fetch_stream.js`: PDFFetchStream
- `../../src/display/metadata.js`: Metadata
- `../../src/display/network.js`: PDFNetworkStream
- `../../src/display/network_utils.js`: createResponseStatusError, extractFilenameFromHeader, validateRangeRequestCapabilities, validateResponseStatus
- `../../src/display/node_stream.js`: PDFNodeStream
- `../../src/display/svg.js`: SVGGraphics
- `../../src/display/text_layer.js`: TextLayerRenderTask, renderTextLayer, updateTextLayer
- `../../src/display/worker_options.js`: GlobalWorkerOptions
- `../../src/display/xfa_layer.js`: XfaLayer
- `../../src/shared/message_handler.js`: MessageHandler
- `../../src/shared/murmurhash3.js`: MurmurHash3_64
- `../../src/shared/util.js`: AbortException, AnnotationBorderStyleType, AnnotationEditorParamsType, AnnotationEditorType, AnnotationFieldFlag, AnnotationFlag, AnnotationMode, AnnotationType, CMapCompressionType, FeatureTest, FormatError, ImageKind, InvalidPDFException, MissingPDFException, OPS, PasswordException, PasswordResponses, PermissionFlag, PromiseCapability, RenderingIntentFlag, UnexpectedResponseException, UnknownErrorException, Util, VerbosityLevel, bytesToString, createValidAbsoluteUrl, getModificationDate, getVerbosityLevel, isArrayBuffer, isNodeJS, normalizeUnicode, objectSize, setVerbosityLevel, shadow, string32, stringToBytes, stringToPDFString, stringToUTF8String
- `../../web/annotation_layer_builder.js`: AnnotationLayerBuilder
- `../../web/download_manager.js`: DownloadManager
- `../../web/event_utils.js`: EventBus, WaitOnType, waitOnEventOrTimeout
- `../../web/genericl10n.js`: GenericL10n
- `../../web/l10n_utils.js`: NullL10n
- `../../web/pdf_find_controller.js`: FindState, PDFFindController
- `../../web/pdf_find_utils.js`: CharacterType, getCharacterType
- `../../web/pdf_history.js`: PDFHistory, isDestArraysEqual, isDestHashesEqual
- `../../web/pdf_link_service.js`: LinkTarget, PDFLinkService, SimpleLinkService
- `../../web/pdf_page_view.js`: PDFPageView
- `../../web/pdf_scripting_manager.component.js`: PDFScriptingManager
- `../../web/pdf_single_page_viewer.js`: PDFSinglePageViewer
- `../../web/pdf_viewer.js`: PDFPageViewBuffer, PDFViewer
- `../../web/struct_tree_layer_builder.js`: StructTreeLayerBuilder
- `../../web/text_layer_builder.js`: TextLayerBuilder
- `../../web/ui_utils.js`: AutoPrintRegExp, ProgressBar, RenderingStates, ScrollMode, SpreadMode, backtrackBeforeAllVisibleElements, binarySearchFirstItem, getPageSizeInches, getVisibleElements, isPortraitOrientation, isValidRotation, parseQueryString, removeNullCharacters
- `../../web/xfa_layer_builder.js`: XfaLayerBuilder
- `./test_utils.js`: CMAP_URL, DefaultFileReaderFactory, STANDARD_FONT_DATA_URL, TEST_PDFS_PATH, XRefMock, buildGetDocumentParams, createIdFactory
- `./testreporter.js`: TestReporter
</imports>

Code:
<code>
File:
src/display/editor/editor.js
1 /* Copyright 2022 Mozilla Foundation
2  *
3  * Licensed under the Apache License, Version 2.0 (the "License");
4  * you may not use this file except in compliance with the License.
5  * You may obtain a copy of the License at
6  *
7  *     http://www.apache.org/licenses/LICENSE-2.0
8  *
9  * Unless required by applicable law or agreed to in writing, software
10  * distributed under the License is distributed on an "AS IS" BASIS,
11  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
12  * See the License for the specific language governing permissions and
13  * limitations under the License.
14  */
15 
16 // eslint-disable-next-line max-len
17 /** @typedef {import("./annotation_editor_layer.js").AnnotationEditorLayer} AnnotationEditorLayer */
18 // eslint-disable-next-line max-len
19 /** @typedef {import("./tools.js").AnnotationEditorUIManager} AnnotationEditorUIManager */
20 
21 import { bindEvents, ColorManager } from "./tools.js";
22 import { FeatureTest, shadow, unreachable } from "../../shared/util.js";
23 import { noContextMenu } from "../display_utils.js";
24 
25 /**
26  * @typedef {Object} AnnotationEditorParameters
27  * @property {AnnotationEditorUIManager} uiManager - the global manager
28  * @property {AnnotationEditorLayer} parent - the layer containing this editor
29  * @property {string} id - editor id
30  * @property {number} x - x-coordinate
31  * @property {number} y - y-coordinate
32  */
33 
34 /**
35  * Base class for editors.
36  */
37 class AnnotationEditor {
38   #altText = "";
39 
40   #altTextDecorative = false;
41 
42   #altTextButton = null;
43 
44   #altTextTooltip = null;
45 
46   #altTextTooltipTimeout = null;
47 
48   #keepAspectRatio = false;
49 
50   #resizersDiv = null;
51 
52   #boundFocusin = this.focusin.bind(this);
53 
54   #boundFocusout = this.focusout.bind(this);
55 
56   #hasBeenClicked = false;
57 
58   #isEditing = false;
59 
60   #isInEditMode = false;
61 
62   _initialOptions = Object.create(null);
63 
64   _uiManager = null;
65 
66   _focusEventsAllowed = true;
67 
68   _l10nPromise = null;
69 
70   #isDraggable = false;
71 
72   #zIndex = AnnotationEditor._zIndex++;
73 
74   static _borderLineWidth = -1;
75 
76   static _colorManager = new ColorManager();
77 
78   static _zIndex = 1;
79 
80   // When one of the dimensions of an editor is smaller than this value, the
81   // button to edit the alt text is visually moved outside of the editor.
82   static SMALL_EDITOR_SIZE = 0;
83 
84   /**
85    * @param {AnnotationEditorParameters} parameters
86    */
87   constructor(parameters) {
88     if (this.constructor === AnnotationEditor) {
89       unreachable("Cannot initialize AnnotationEditor.");
90     }
91 
92     this.parent = parameters.parent;
93     this.id = parameters.id;
94     this.width = this.height = null;
95     this.pageIndex = parameters.parent.pageIndex;
96     this.name = parameters.name;
97     this.div = null;
98     this._uiManager = parameters.uiManager;
99     this.annotationElementId = null;
100     this._willKeepAspectRatio = false;
101     this._initialOptions.isCentered = parameters.isCentered;
102     this._structTreeParentId = null;
103 
104     const {
105       rotation,
106       rawDims: { pageWidth, pageHeight, pageX, pageY },
107     } = this.parent.viewport;
108 
109     this.rotation = rotation;
110     this.pageRotation =
111       (360 + rotation - this._uiManager.viewParameters.rotation) % 360;
112     this.pageDimensions = [pageWidth, pageHeight];
113     this.pageTranslation = [pageX, pageY];
114 
115     const [width, height] = this.parentDimensions;
116     this.x = parameters.x / width;
117     this.y = parameters.y / height;
118 
119     this.isAttachedToDOM = false;
120     this.deleted = false;
121   }
122 
123   get editorType() {
124     return Object.getPrototypeOf(this).constructor._type;
125   }
126 
127   static get _defaultLineColor() {
128     return shadow(
129       this,
130       "_defaultLineColor",
131       this._colorManager.getHexCode("CanvasText")
132     );
133   }
134 
135   static deleteAnnotationElement(editor) {
136     const fakeEditor = new FakeEditor({
137       id: editor.parent.getNextId(),
138       parent: editor.parent,
139       uiManager: editor._uiManager,
140     });
141     fakeEditor.annotationElementId = editor.annotationElementId;
142     fakeEditor.deleted = true;
143     fakeEditor._uiManager.addToAnnotationStorage(fakeEditor);
144   }
145 
146   /**
147    * Initialize the l10n stuff for this type of editor.
148    * @param {Object} l10n
149    */
150   static initialize(l10n, options = null) {
151     AnnotationEditor._l10nPromise ||= new Map(
152       [
153         "editor_alt_text_button_label",
154         "editor_alt_text_edit_button_label",
155         "editor_alt_text_decorative_tooltip",
156       ].map(str => [str, l10n.get(str)])
157     );
158     if (options?.strings) {
159       for (const str of options.strings) {
160         AnnotationEditor._l10nPromise.set(str, l10n.get(str));
161       }
162     }
163     if (AnnotationEditor._borderLineWidth !== -1) {
164       return;
165     }
166     const style = getComputedStyle(document.documentElement);
167     AnnotationEditor._borderLineWidth =
168       parseFloat(style.getPropertyValue("--outline-width")) || 0;
169   }
170 
171   /**
172    * Update the default parameters for this type of editor.
173    * @param {number} _type
174    * @param {*} _value
175    */
176   static updateDefaultParams(_type, _value) {}
177 
178   /**
179    * Get the default properties to set in the UI for this type of editor.
180    * @returns {Array}
181    */
182   static get defaultPropertiesToUpdate() {
183     return [];
184   }
185 
186   /**
187    * Check if this kind of editor is able to handle the given mime type for
188    * pasting.
189    * @param {string} mime
190    * @returns {boolean}
191    */
192   static isHandlingMimeForPasting(mime) {
193     return false;
194   }
195 
196   /**
197    * Extract the data from the clipboard item and delegate the creation of the
198    * editor to the parent.
199    * @param {DataTransferItem} item
200    * @param {AnnotationEditorLayer} parent
201    */
202   static paste(item, parent) {
203     unreachable("Not implemented");
204   }
205 
206   /**
207    * Get the properties to update in the UI for this editor.
208    * @returns {Array}
209    */
210   get propertiesToUpdate() {
211     return [];
212   }
213 
214   get _isDraggable() {
215     return this.#isDraggable;
216   }
217 
218   set _isDraggable(value) {
219     this.#isDraggable = value;
220     this.div?.classList.toggle("draggable", value);
221   }
222 
223   center() {
224     const [pageWidth, pageHeight] = this.pageDimensions;
225     switch (this.parentRotation) {
226       case 90:
227         this.x -= (this.height * pageHeight) / (pageWidth * 2);
228         this.y += (this.width * pageWidth) / (pageHeight * 2);
229         break;
230       case 180:
231         this.x += this.width / 2;
232         this.y += this.height / 2;
233         break;
234       case 270:
235         this.x += (this.height * pageHeight) / (pageWidth * 2);
236         this.y -= (this.width * pageWidth) / (pageHeight * 2);
237         break;
238       default:
239         this.x -= this.width / 2;
240         this.y -= this.height / 2;
241         break;
242     }
243     this.fixAndSetPosition();
244   }
245 
246   /**
247    * Add some commands into the CommandManager (undo/redo stuff).
248    * @param {Object} params
249    */
250   addCommands(params) {
251     this._uiManager.addCommands(params);
252   }
253 
254   get currentLayer() {
255     return this._uiManager.currentLayer;
256   }
257 
258   /**
259    * This editor will be behind the others.
260    */
261   setInBackground() {
262     this.div.style.zIndex = 0;
263   }
264 
265   /**
266    * This editor will be in the foreground.
267    */
268   setInForeground() {
269     this.div.style.zIndex = this.#zIndex;
270   }
271 
272   setParent(parent) {
273     if (parent !== null) {
274       this.pageIndex = parent.pageIndex;
275       this.pageDimensions = parent.pageDimensions;
276     }
277     this.parent = parent;
278   }
279 
280   /**
281    * onfocus callback.
282    */
283   focusin(event) {
284     if (!this._focusEventsAllowed) {
285       return;
286     }
287     if (!this.#hasBeenClicked) {
288       this.parent.setSelected(this);
289     } else {
290       this.#hasBeenClicked = false;
291     }
292   }
293 
294   /**
295    * onblur callback.
296    * @param {FocusEvent} event
297    */
298   focusout(event) {
299     if (!this._focusEventsAllowed) {
300       return;
301     }
302 
303     if (!this.isAttachedToDOM) {
304       return;
305     }
306 
307     // In case of focusout, the relatedTarget is the element which
308     // is grabbing the focus.
309     // So if the related target is an element under the div for this
310     // editor, then the editor isn't unactive.
311     const target = event.relatedTarget;
312     if (target?.closest(`#${this.id}`)) {
313       return;
314     }
315 
316     event.preventDefault();
317 
318     if (!this.parent?.isMultipleSelection) {
319       this.commitOrRemove();
320     }
321   }
322 
323   commitOrRemove() {
324     if (this.isEmpty()) {
325       this.remove();
326     } else {
327       this.commit();
328     }
329   }
330 
331   /**
332    * Commit the data contained in this editor.
333    */
334   commit() {
335     this.addToAnnotationStorage();
336   }
337 
338   addToAnnotationStorage() {
339     this._uiManager.addToAnnotationStorage(this);
340   }
341 
342   /**
343    * Set the editor position within its parent.
344    * @param {number} x
345    * @param {number} y
346    * @param {number} tx - x-translation in screen coordinates.
347    * @param {number} ty - y-translation in screen coordinates.
348    */
349   setAt(x, y, tx, ty) {
350     const [width, height] = this.parentDimensions;
351     [tx, ty] = this.screenToPageTranslation(tx, ty);
352 
353     this.x = (x + tx) / width;
354     this.y = (y + ty) / height;
355 
356     this.fixAndSetPosition();
357   }
358 
359   #translate([width, height], x, y) {
360     [x, y] = this.screenToPageTranslation(x, y);
361 
362     this.x += x / width;
363     this.y += y / height;
364 
365     this.fixAndSetPosition();
366   }
367 
368   /**
369    * Translate the editor position within its parent.
370    * @param {number} x - x-translation in screen coordinates.
371    * @param {number} y - y-translation in screen coordinates.
372    */
373   translate(x, y) {
374     this.#translate(this.parentDimensions, x, y);
375   }
376 
377   /**
378    * Translate the editor position within its page and adjust the scroll
379    * in order to have the editor in the view.
380    * @param {number} x - x-translation in page coordinates.
381    * @param {number} y - y-translation in page coordinates.
382    */
383   translateInPage(x, y) {
384     this.#translate(this.pageDimensions, x, y);
385     this.div.scrollIntoView({ block: "nearest" });
386   }
387 
388   drag(tx, ty) {
389     const [parentWidth, parentHeight] = this.parentDimensions;
390     this.x += tx / parentWidth;
391     this.y += ty / parentHeight;
392     if (this.parent && (this.x < 0 || this.x > 1 || this.y < 0 || this.y > 1)) {
393       // It's possible to not have a parent: for example, when the user is
394       // dragging all the selected editors but this one on a page which has been
395       // destroyed.
396       // It's why we need to check for it. In such a situation, it isn't really
397       // a problem to not find a new parent: it's something which is related to
398       // what the user is seeing, hence it depends on how pages are layed out.
399 
400       // The element will be outside of its parent so change the parent.
401       const { x, y } = this.div.getBoundingClientRect();
402       if (this.parent.findNewParent(this, x, y)) {
403         this.x -= Math.floor(this.x);
404         this.y -= Math.floor(this.y);
405       }
406     }
407 
408     // The editor can be moved wherever the user wants, so we don't need to fix
409     // the position: it'll be done when the user will release the mouse button.
410 
411     let { x, y } = this;
412     const [bx, by] = this.#getBaseTranslation();
413     x += bx;
414     y += by;
415 
416     this.div.style.left = `${(100 * x).toFixed(2)}%`;
417     this.div.style.top = `${(100 * y).toFixed(2)}%`;
418     this.div.scrollIntoView({ block: "nearest" });
419   }
420 
421   #getBaseTranslation() {
422     const [parentWidth, parentHeight] = this.parentDimensions;
423     const { _borderLineWidth } = AnnotationEditor;
424     const x = _borderLineWidth / parentWidth;
425     const y = _borderLineWidth / parentHeight;
426     switch (this.rotation) {
427       case 90:
428         return [-x, y];
429       case 180:
430         return [x, y];
431       case 270:
432         return [x, -y];
433       default:
434         return [-x, -y];
435     }
436   }
437 
438   fixAndSetPosition() {
439     const [pageWidth, pageHeight] = this.pageDimensions;
440     let { x, y, width, height } = this;
441     width *= pageWidth;
442     height *= pageHeight;
443     x *= pageWidth;
444     y *= pageHeight;
445 
446     switch (this.rotation) {
447       case 0:
448         x = Math.max(0, Math.min(pageWidth - width, x));
449         y = Math.max(0, Math.min(pageHeight - height, y));
450         break;
451       case 90:
452         x = Math.max(0, Math.min(pageWidth - height, x));
453         y = Math.min(pageHeight, Math.max(width, y));
454         break;
455       case 180:
456         x = Math.min(pageWidth, Math.max(width, x));
457         y = Math.min(pageHeight, Math.max(height, y));
458         break;
459       case 270:
460         x = Math.min(pageWidth, Math.max(height, x));
461         y = Math.max(0, Math.min(pageHeight - width, y));
462         break;
463     }
464 
465     this.x = x /= pageWidth;
466     this.y = y /= pageHeight;
467 
468     const [bx, by] = this.#getBaseTranslation();
469     x += bx;
470     y += by;
471 
472     const { style } = this.div;
473     style.left = `${(100 * x).toFixed(2)}%`;
474     style.top = `${(100 * y).toFixed(2)}%`;
475 
476     this.moveInDOM();
477   }
478 
479   static #rotatePoint(x, y, angle) {
480     switch (angle) {
481       case 90:
482         return [y, -x];
483       case 180:
484         return [-x, -y];
485       case 270:
486         return [-y, x];
487       default:
488         return [x, y];
489     }
490   }
491 
492   /**
493    * Convert a screen translation into a page one.
494    * @param {number} x
495    * @param {number} y
496    */
497   screenToPageTranslation(x, y) {
498     return AnnotationEditor.#rotatePoint(x, y, this.parentRotation);
499   }
500 
501   /**
502    * Convert a page translation into a screen one.
503    * @param {number} x
504    * @param {number} y
505    */
506   pageTranslationToScreen(x, y) {
507     return AnnotationEditor.#rotatePoint(x, y, 360 - this.parentRotation);
508   }
509 
510   #getRotationMatrix(rotation) {
511     switch (rotation) {
512       case 90: {
513         const [pageWidth, pageHeight] = this.pageDimensions;
514         return [0, -pageWidth / pageHeight, pageHeight / pageWidth, 0];
515       }
516       case 180:
517         return [-1, 0, 0, -1];
518       case 270: {
519         const [pageWidth, pageHeight] = this.pageDimensions;
520         return [0, pageWidth / pageHeight, -pageHeight / pageWidth, 0];
521       }
522       default:
523         return [1, 0, 0, 1];
524     }
525   }
526 
527   get parentScale() {
528     return this._uiManager.viewParameters.realScale;
529   }
530 
531   get parentRotation() {
532     return (this._uiManager.viewParameters.rotation + this.pageRotation) % 360;
533   }
534 
535   get parentDimensions() {
536     const {
537       parentScale,
538       pageDimensions: [pageWidth, pageHeight],
539     } = this;
540     const scaledWidth = pageWidth * parentScale;
541     const scaledHeight = pageHeight * parentScale;
542     return FeatureTest.isCSSRoundSupported
543       ? [Math.round(scaledWidth), Math.round(scaledHeight)]
544       : [scaledWidth, scaledHeight];
545   }
546 
547   /**
548    * Set the dimensions of this editor.
549    * @param {number} width
550    * @param {number} height
551    */
552   setDims(width, height) {
553     const [parentWidth, parentHeight] = this.parentDimensions;
554     this.div.style.width = `${((100 * width) / parentWidth).toFixed(2)}%`;
555     if (!this.#keepAspectRatio) {
556       this.div.style.height = `${((100 * height) / parentHeight).toFixed(2)}%`;
557     }
558     this.#altTextButton?.classList.toggle(
559       "small",
560       width < AnnotationEditor.SMALL_EDITOR_SIZE ||
561         height < AnnotationEditor.SMALL_EDITOR_SIZE
562     );
563   }
564 
565   fixDims() {
566     const { style } = this.div;
567     const { height, width } = style;
568     const widthPercent = width.endsWith("%");
569     const heightPercent = !this.#keepAspectRatio && height.endsWith("%");
570     if (widthPercent && heightPercent) {
571       return;
572     }
573 
574     const [parentWidth, parentHeight] = this.parentDimensions;
575     if (!widthPercent) {
576       style.width = `${((100 * parseFloat(width)) / parentWidth).toFixed(2)}%`;
577     }
578     if (!this.#keepAspectRatio && !heightPercent) {
579       style.height = `${((100 * parseFloat(height)) / parentHeight).toFixed(
580         2
581       )}%`;
582     }
583   }
584 
585   /**
586    * Get the translation used to position this editor when it's created.
587    * @returns {Array<number>}
588    */
589   getInitialTranslation() {
590     return [0, 0];
591   }
592 
593   #createResizers() {
594     if (this.#resizersDiv) {
595       return;
596     }
597     this.#resizersDiv = document.createElement("div");
598     this.#resizersDiv.classList.add("resizers");
599     const classes = ["topLeft", "topRight", "bottomRight", "bottomLeft"];
600     if (!this._willKeepAspectRatio) {
601       classes.push("topMiddle", "middleRight", "bottomMiddle", "middleLeft");
602     }
603     for (const name of classes) {
604       const div = document.createElement("div");
605       this.#resizersDiv.append(div);
606       div.classList.add("resizer", name);
607       div.addEventListener(
608         "pointerdown",
609         this.#resizerPointerdown.bind(this, name)
610       );
611       div.addEventListener("contextmenu", noContextMenu);
612     }
613     this.div.prepend(this.#resizersDiv);
614   }
615 
616   #resizerPointerdown(name, event) {
617     event.preventDefault();
618     const { isMac } = FeatureTest.platform;
619     if (event.button !== 0 || (event.ctrlKey && isMac)) {
620       return;
621     }
622 
623     const boundResizerPointermove = this.#resizerPointermove.bind(this, name);
624     const savedDraggable = this._isDraggable;
625     this._isDraggable = false;
626     const pointerMoveOptions = { passive: true, capture: true };
627     window.addEventListener(
628       "pointermove",
629       boundResizerPointermove,
630       pointerMoveOptions
631     );
632     const savedX = this.x;
633     const savedY = this.y;
634     const savedWidth = this.width;
635     const savedHeight = this.height;
636     const savedParentCursor = this.parent.div.style.cursor;
637     const savedCursor = this.div.style.cursor;
638     this.div.style.cursor = this.parent.div.style.cursor =
639       window.getComputedStyle(event.target).cursor;
640 
641     const pointerUpCallback = () => {
642       this._isDraggable = savedDraggable;
643       window.removeEventListener("pointerup", pointerUpCallback);
644       window.removeEventListener("blur", pointerUpCallback);
645       window.removeEventListener(
646         "pointermove",
647         boundResizerPointermove,
648         pointerMoveOptions
649       );
650       this.parent.div.style.cursor = savedParentCursor;
651       this.div.style.cursor = savedCursor;
652 
653       const newX = this.x;
654       const newY = this.y;
655       const newWidth = this.width;
656       const newHeight = this.height;
657       if (
658         newX === savedX &&
659         newY === savedY &&
660         newWidth === savedWidth &&
661         newHeight === savedHeight
662       ) {
663         return;
664       }
665 
666       this.addCommands({
667         cmd: () => {
668           this.width = newWidth;
669           this.height = newHeight;
670           this.x = newX;
671           this.y = newY;
672           const [parentWidth, parentHeight] = this.parentDimensions;
673           this.setDims(parentWidth * newWidth, parentHeight * newHeight);
674           this.fixAndSetPosition();
675         },
676         undo: () => {
677           this.width = savedWidth;
678           this.height = savedHeight;
679           this.x = savedX;
680           this.y = savedY;
681           const [parentWidth, parentHeight] = this.parentDimensions;
682           this.setDims(parentWidth * savedWidth, parentHeight * savedHeight);
683           this.fixAndSetPosition();
684         },
685         mustExec: true,
686       });
687     };
688     window.addEventListener("pointerup", pointerUpCallback);
689     // If the user switches to another window (with alt+tab), then we end the
690     // resize session.
691     window.addEventListener("blur", pointerUpCallback);
692   }
693 
694   #resizerPointermove(name, event) {
695     const [parentWidth, parentHeight] = this.parentDimensions;
696     const savedX = this.x;
697     const savedY = this.y;
698     const savedWidth = this.width;
699     const savedHeight = this.height;
700     const minWidth = AnnotationEditor.MIN_SIZE / parentWidth;
701     const minHeight = AnnotationEditor.MIN_SIZE / parentHeight;
702 
703     // 10000 because we multiply by 100 and use toFixed(2) in fixAndSetPosition.
704     // Without rounding, the positions of the corners other than the top left
705     // one can be slightly wrong.
706     const round = x => Math.round(x * 10000) / 10000;
707     const rotationMatrix = this.#getRotationMatrix(this.rotation);
708     const transf = (x, y) => [
709       rotationMatrix[0] * x + rotationMatrix[2] * y,
710       rotationMatrix[1] * x + rotationMatrix[3] * y,
711     ];
712     const invRotationMatrix = this.#getRotationMatrix(360 - this.rotation);
713     const invTransf = (x, y) => [
714       invRotationMatrix[0] * x + invRotationMatrix[2] * y,
715       invRotationMatrix[1] * x + invRotationMatrix[3] * y,
716     ];
717     let getPoint;
718     let getOpposite;
719     let isDiagonal = false;
720     let isHorizontal = false;
721 
722     switch (name) {
723       case "topLeft":
724         isDiagonal = true;
725         getPoint = (w, h) => [0, 0];
726         getOpposite = (w, h) => [w, h];
727         break;
728       case "topMiddle":
729         getPoint = (w, h) => [w / 2, 0];
730         getOpposite = (w, h) => [w / 2, h];
731         break;
732       case "topRight":
733         isDiagonal = true;
734         getPoint = (w, h) => [w, 0];
735         getOpposite = (w, h) => [0, h];
736         break;
737       case "middleRight":
738         isHorizontal = true;
739         getPoint = (w, h) => [w, h / 2];
740         getOpposite = (w, h) => [0, h / 2];
741         break;
742       case "bottomRight":
743         isDiagonal = true;
744         getPoint = (w, h) => [w, h];
745         getOpposite = (w, h) => [0, 0];
746         break;
747       case "bottomMiddle":
748         getPoint = (w, h) => [w / 2, h];
749         getOpposite = (w, h) => [w / 2, 0];
750         break;
751       case "bottomLeft":
752         isDiagonal = true;
753         getPoint = (w, h) => [0, h];
754         getOpposite = (w, h) => [w, 0];
755         break;
756       case "middleLeft":
757         isHorizontal = true;
758         getPoint = (w, h) => [0, h / 2];
759         getOpposite = (w, h) => [w, h / 2];
760         break;
761     }
762 
763     const point = getPoint(savedWidth, savedHeight);
764     const oppositePoint = getOpposite(savedWidth, savedHeight);
765     let transfOppositePoint = transf(...oppositePoint);
766     const oppositeX = round(savedX + transfOppositePoint[0]);
767     const oppositeY = round(savedY + transfOppositePoint[1]);
768     let ratioX = 1;
769     let ratioY = 1;
770 
771     let [deltaX, deltaY] = this.screenToPageTranslation(
772       event.movementX,
773       event.movementY
774     );
775     [deltaX, deltaY] = invTransf(deltaX / parentWidth, deltaY / parentHeight);
776 
777     if (isDiagonal) {
778       const oldDiag = Math.hypot(savedWidth, savedHeight);
779       ratioX = ratioY = Math.max(
780         Math.min(
781           Math.hypot(
782             oppositePoint[0] - point[0] - deltaX,
783             oppositePoint[1] - point[1] - deltaY
784           ) / oldDiag,
785           // Avoid the editor to be larger than the page.
786           1 / savedWidth,
787           1 / savedHeight
788         ),
789         // Avoid the editor to be smaller than the minimum size.
790         minWidth / savedWidth,
791         minHeight / savedHeight
792       );
793     } else if (isHorizontal) {
794       ratioX =
795         Math.max(
796           minWidth,
797           Math.min(1, Math.abs(oppositePoint[0] - point[0] - deltaX))
798         ) / savedWidth;
799     } else {
800       ratioY =
801         Math.max(
802           minHeight,
803           Math.min(1, Math.abs(oppositePoint[1] - point[1] - deltaY))
804         ) / savedHeight;
805     }
806 
807     const newWidth = round(savedWidth * ratioX);
808     const newHeight = round(savedHeight * ratioY);
809     transfOppositePoint = transf(...getOpposite(newWidth, newHeight));
810     const newX = oppositeX - transfOppositePoint[0];
811     const newY = oppositeY - transfOppositePoint[1];
812 
813     this.width = newWidth;
814     this.height = newHeight;
815     this.x = newX;
816     this.y = newY;
817 
818     this.setDims(parentWidth * newWidth, parentHeight * newHeight);
819     this.fixAndSetPosition();
820   }
821 
822   async addAltTextButton() {
823     if (this.#altTextButton) {
824       return;
825     }
826     const altText = (this.#altTextButton = document.createElement("button"));
827     altText.className = "altText";
828     const msg = await AnnotationEditor._l10nPromise.get(
829       "editor_alt_text_button_label"
830     );
831     altText.textContent = msg;
832     altText.setAttribute("aria-label", msg);
833     altText.tabIndex = "0";
834     altText.addEventListener("contextmenu", noContextMenu);
835     altText.addEventListener("pointerdown", event => event.stopPropagation());
836     altText.addEventListener(
837       "click",
838       event => {
839         event.preventDefault();
840         this._uiManager.editAltText(this);
841       },
842       { capture: true }
843     );
844     altText.addEventListener("keydown", event => {
845       if (event.target === altText && event.key === "Enter") {
846         event.preventDefault();
847         this._uiManager.editAltText(this);
848       }
849     });
850     this.#setAltTextButtonState();
851     this.div.append(altText);
852     if (!AnnotationEditor.SMALL_EDITOR_SIZE) {
853       // We take the width of the alt text button and we add 40% to it to be
854       // sure to have enough space for it.
855       const PERCENT = 40;
856       AnnotationEditor.SMALL_EDITOR_SIZE = Math.min(
857         128,
858         Math.round(altText.getBoundingClientRect().width * (1 + PERCENT / 100))
859       );
860     }
861   }
862 
863   async #setAltTextButtonState() {
864     const button = this.#altTextButton;
865     if (!button) {
866       return;
867     }
868     if (!this.#altText && !this.#altTextDecorative) {
869       button.classList.remove("done");
870       this.#altTextTooltip?.remove();
871       return;
872     }
873     AnnotationEditor._l10nPromise
874       .get("editor_alt_text_edit_button_label")
875       .then(msg => {
876         button.setAttribute("aria-label", msg);
877       });
878 
879     let tooltip = this.#altTextTooltip;
880     if (!tooltip) {
881       this.#altTextTooltip = tooltip = document.createElement("span");
882       tooltip.className = "tooltip";
883       tooltip.setAttribute("role", "tooltip");
884       const id = (tooltip.id = `alt-text-tooltip-${this.id}`);
885       button.setAttribute("aria-describedby", id);
886 
887       const DELAY_TO_SHOW_TOOLTIP = 100;
888       button.addEventListener("mouseenter", () => {
889         this.#altTextTooltipTimeout = setTimeout(() => {
890           this.#altTextTooltipTimeout = null;
891           this.#altTextTooltip.classList.add("show");
892           this._uiManager._eventBus.dispatch("reporttelemetry", {
893             source: this,
894             details: {
895               type: "editing",
896               subtype: this.editorType,
897               data: {
898                 action: "alt_text_tooltip",
899               },
900             },
901           });
902         }, DELAY_TO_SHOW_TOOLTIP);
903       });
904       button.addEventListener("mouseleave", () => {
905         clearTimeout(this.#altTextTooltipTimeout);
906         this.#altTextTooltipTimeout = null;
907         this.#altTextTooltip?.classList.remove("show");
908       });
909     }
910     button.classList.add("done");
911     tooltip.innerText = this.#altTextDecorative
912       ? await AnnotationEditor._l10nPromise.get(
913           "editor_alt_text_decorative_tooltip"
914         )
915       : this.#altText;
916 
917     if (!tooltip.parentNode) {
918       button.append(tooltip);
919     }
920   }
921 
922   getClientDimensions() {
923     return this.div.getBoundingClientRect();
924   }
925 
926   get altTextData() {
927     return {
928       altText: this.#altText,
929       decorative: this.#altTextDecorative,
930     };
931   }
932 
933   set altTextData({ altText, decorative }) {
934     if (this.#altText === altText && this.#altTextDecorative === decorative) {
935       return;
936     }
937     this.#altText = altText;
938     this.#altTextDecorative = decorative;
939     this.#setAltTextButtonState();
940   }
941 
942   /**
943    * Render this editor in a div.
944    * @returns {HTMLDivElement}
945    */
946   render() {
947     this.div = document.createElement("div");
948     this.div.setAttribute("data-editor-rotation", (360 - this.rotation) % 360);
949     this.div.className = this.name;
950     this.div.setAttribute("id", this.id);
951     this.div.setAttribute("tabIndex", 0);
952 
953     this.setInForeground();
954 
955     this.div.addEventListener("focusin", this.#boundFocusin);
956     this.div.addEventListener("focusout", this.#boundFocusout);
957 
958     const [parentWidth, parentHeight] = this.parentDimensions;
959     if (this.parentRotation % 180 !== 0) {
960       this.div.style.maxWidth = `${((100 * parentHeight) / parentWidth).toFixed(
961         2
962       )}%`;
963       this.div.style.maxHeight = `${(
964         (100 * parentWidth) /
965         parentHeight
966       ).toFixed(2)}%`;
967     }
968 
969     const [tx, ty] = this.getInitialTranslation();
970     this.translate(tx, ty);
971 
972     bindEvents(this, this.div, ["pointerdown"]);
973 
974     return this.div;
975   }
976 
977   /**
978    * Onpointerdown callback.
979    * @param {PointerEvent} event
980    */
981   pointerdown(event) {
982     const { isMac } = FeatureTest.platform;
983     if (event.button !== 0 || (event.ctrlKey && isMac)) {
984       // Avoid to focus this editor because of a non-left click.
985       event.preventDefault();
986       return;
987     }
988 
989     this.#hasBeenClicked = true;
990 
991     this.#setUpDragSession(event);
992   }
993 
994   #setUpDragSession(event) {
995     if (!this._isDraggable) {
996       return;
997     }
998 
999     const isSelected = this._uiManager.isSelected(this);
1000     this._uiManager.setUpDragSession();
1001 
1002     let pointerMoveOptions, pointerMoveCallback;
1003     if (isSelected) {
1004       pointerMoveOptions = { passive: true, capture: true };
1005       pointerMoveCallback = e => {
1006         const [tx, ty] = this.screenToPageTranslation(e.movementX, e.movementY);
1007         this._uiManager.dragSelectedEditors(tx, ty);
1008       };
1009       window.addEventListener(
1010         "pointermove",
1011         pointerMoveCallback,
1012         pointerMoveOptions
1013       );
1014     }
1015 
1016     const pointerUpCallback = () => {
1017       window.removeEventListener("pointerup", pointerUpCallback);
1018       window.removeEventListener("blur", pointerUpCallback);
1019       if (isSelected) {
1020         window.removeEventListener(
1021           "pointermove",
1022           pointerMoveCallback,
1023           pointerMoveOptions
1024         );
1025       }
1026 
1027       this.#hasBeenClicked = false;
1028       if (!this._uiManager.endDragSession()) {
1029         const { isMac } = FeatureTest.platform;
1030         if (
1031           (event.ctrlKey && !isMac) ||
1032           event.shiftKey ||
1033           (event.metaKey && isMac)
1034         ) {
1035           this.parent.toggleSelected(this);
1036         } else {
1037           this.parent.setSelected(this);
1038         }
1039       }
1040     };
1041     window.addEventListener("pointerup", pointerUpCallback);
1042     // If the user is using alt+tab during the dragging session, the pointerup
1043     // event could be not fired, but a blur event is fired so we can use it in
1044     // order to interrupt the dragging session.
1045     window.addEventListener("blur", pointerUpCallback);
1046   }
1047 
1048   moveInDOM() {
1049     this.parent?.moveEditorInDOM(this);
1050   }
1051 
1052   _setParentAndPosition(parent, x, y) {
1053     parent.changeParent(this);
1054     this.x = x;
1055     this.y = y;
1056     this.fixAndSetPosition();
1057   }
1058 
1059   /**
1060    * Convert the current rect into a page one.
1061    */
1062   getRect(tx, ty) {
1063     const scale = this.parentScale;
1064     const [pageWidth, pageHeight] = this.pageDimensions;
1065     const [pageX, pageY] = this.pageTranslation;
1066     const shiftX = tx / scale;
1067     const shiftY = ty / scale;
1068     const x = this.x * pageWidth;
1069     const y = this.y * pageHeight;
1070     const width = this.width * pageWidth;
1071     const height = this.height * pageHeight;
1072 
1073     switch (this.rotation) {
1074       case 0:
1075         return [
1076           x + shiftX + pageX,
1077           pageHeight - y - shiftY - height + pageY,
1078           x + shiftX + width + pageX,
1079           pageHeight - y - shiftY + pageY,
1080         ];
1081       case 90:
1082         return [
1083           x + shiftY + pageX,
1084           pageHeight - y + shiftX + pageY,
1085           x + shiftY + height + pageX,
1086           pageHeight - y + shiftX + width + pageY,
1087         ];
1088       case 180:
1089         return [
1090           x - shiftX - width + pageX,
1091           pageHeight - y + shiftY + pageY,
1092           x - shiftX + pageX,
1093           pageHeight - y + shiftY + height + pageY,
1094         ];
1095       case 270:
1096         return [
1097           x - shiftY - height + pageX,
1098           pageHeight - y - shiftX - width + pageY,
1099           x - shiftY + pageX,
1100           pageHeight - y - shiftX + pageY,
1101         ];
1102       default:
1103         throw new Error("Invalid rotation");
1104     }
1105   }
1106 
1107   getRectInCurrentCoords(rect, pageHeight) {
1108     const [x1, y1, x2, y2] = rect;
1109 
1110     const width = x2 - x1;
1111     const height = y2 - y1;
1112 
1113     switch (this.rotation) {
1114       case 0:
1115         return [x1, pageHeight - y2, width, height];
1116       case 90:
1117         return [x1, pageHeight - y1, height, width];
1118       case 180:
1119         return [x2, pageHeight - y1, width, height];
1120       case 270:
1121         return [x2, pageHeight - y2, height, width];
1122       default:
1123         throw new Error("Invalid rotation");
1124     }
1125   }
1126 
1127   /**
1128    * Executed once this editor has been rendered.
1129    */
1130   onceAdded() {}
1131 
1132   /**
1133    * Check if the editor contains something.
1134    * @returns {boolean}
1135    */
1136   isEmpty() {
1137     return false;
1138   }
1139 
1140   /**
1141    * Enable edit mode.
1142    */
1143   enableEditMode() {
1144     this.#isInEditMode = true;
1145   }
1146 
1147   /**
1148    * Disable edit mode.
1149    */
1150   disableEditMode() {
1151     this.#isInEditMode = false;
1152   }
1153 
1154   /**
1155    * Check if the editor is edited.
1156    * @returns {boolean}
1157    */
1158   isInEditMode() {
1159     return this.#isInEditMode;
1160   }
1161 
1162   /**
1163    * If it returns true, then this editor handle the keyboard
1164    * events itself.
1165    * @returns {boolean}
1166    */
1167   shouldGetKeyboardEvents() {
1168     return false;
1169   }
1170 
1171   /**
1172    * Check if this editor needs to be rebuilt or not.
1173    * @returns {boolean}
1174    */
1175   needsToBeRebuilt() {
1176     return this.div && !this.isAttachedToDOM;
1177   }
1178 
1179   /**
1180    * Rebuild the editor in case it has been removed on undo.
1181    *
1182    * To implement in subclasses.
1183    */
1184   rebuild() {
1185     this.div?.addEventListener("focusin", this.#boundFocusin);
1186     this.div?.addEventListener("focusout", this.#boundFocusout);
1187   }
1188 
1189   /**
1190    * Serialize the editor.
1191    * The result of the serialization will be used to construct a
1192    * new annotation to add to the pdf document.
1193    *
1194    * To implement in subclasses.
1195    * @param {boolean} isForCopying
1196    * @param {Object} [context]
1197    */
1198   serialize(isForCopying = false, context = null) {
1199     unreachable("An editor must be serializable");
1200   }
1201 
1202   /**
1203    * Deserialize the editor.
1204    * The result of the deserialization is a new editor.
1205    *
1206    * @param {Object} data
1207    * @param {AnnotationEditorLayer} parent
1208    * @param {AnnotationEditorUIManager} uiManager
1209    * @returns {AnnotationEditor}
1210    */
1211   static deserialize(data, parent, uiManager) {
1212     const editor = new this.prototype.constructor({
1213       parent,
1214       id: parent.getNextId(),
1215       uiManager,
1216     });
1217     editor.rotation = data.rotation;
1218 
1219     const [pageWidth, pageHeight] = editor.pageDimensions;
1220     const [x, y, width, height] = editor.getRectInCurrentCoords(
1221       data.rect,
1222       pageHeight
1223     );
1224     editor.x = x / pageWidth;
1225     editor.y = y / pageHeight;
1226     editor.width = width / pageWidth;
1227     editor.height = height / pageHeight;
1228 
1229     return editor;
1230   }
1231 
1232   /**
1233    * Remove this editor.
1234    * It's used on ctrl+backspace action.
1235    */
1236   remove() {
1237     this.div.removeEventListener("focusin", this.#boundFocusin);
1238     this.div.removeEventListener("focusout", this.#boundFocusout);
1239 
1240     if (!this.isEmpty()) {
1241       // The editor is removed but it can be back at some point thanks to
1242       // undo/redo so we must commit it before.
1243       this.commit();
1244     }
1245     if (this.parent) {
1246       this.parent.remove(this);
1247     } else {
1248       this._uiManager.removeEditor(this);
1249     }
1250 
1251     // The editor is removed so we can remove the alt text button and if it's
1252     // restored then it's up to the subclass to add it back.
1253     this.#altTextButton?.remove();
1254     this.#altTextButton = null;
1255     this.#altTextTooltip = null;
1256   }
1257 
1258   /**
1259    * @returns {boolean} true if this editor can be resized.
1260    */
1261   get isResizable() {
1262     return false;
1263   }
1264 
1265   /**
1266    * Add the resizers to this editor.
1267    */
1268   makeResizable() {
1269     if (this.isResizable) {
1270       this.#createResizers();
1271       this.#resizersDiv.classList.remove("hidden");
1272     }
1273   }
1274 
1275   /**
1276    * Select this editor.
1277    */
1278   select() {
1279     this.makeResizable();
1280     this.div?.classList.add("selectedEditor");
1281   }
1282 
1283   /**
1284    * Unselect this editor.
1285    */
1286   unselect() {
1287     this.#resizersDiv?.classList.add("hidden");
1288     this.div?.classList.remove("selectedEditor");
1289     if (this.div?.contains(document.activeElement)) {
1290       // Don't use this.div.blur() because we don't know where the focus will
1291       // go.
1292       this._uiManager.currentLayer.div.focus();
1293     }
1294   }
1295 
1296   /**
1297    * Update some parameters which have been changed through the UI.
1298    * @param {number} type
1299    * @param {*} value
1300    */
1301   updateParams(type, value) {}
1302 
1303   /**
1304    * When the user disables the editing mode some editors can change some of
1305    * their properties.
1306    */
1307   disableEditing() {
1308     if (this.#altTextButton) {
1309       this.#altTextButton.hidden = true;
1310     }
1311   }
1312 
1313   /**
1314    * When the user enables the editing mode some editors can change some of
1315    * their properties.
1316    */
1317   enableEditing() {
1318     if (this.#altTextButton) {
1319       this.#altTextButton.hidden = false;
1320     }
1321   }
1322 
1323   /**
1324    * The editor is about to be edited.
1325    */
1326   enterInEditMode() {}
1327 
1328   /**
1329    * Get the div which really contains the displayed content.
1330    */
1331   get contentDiv() {
1332     return this.div;
1333   }
1334 
1335   /**
1336    * If true then the editor is currently edited.
1337    * @type {boolean}
1338    */
1339   get isEditing() {
1340     return this.#isEditing;
1341   }
1342 
1343   /**
1344    * When set to true, it means that this editor is currently edited.
1345    * @param {boolean} value
1346    */
1347   set isEditing(value) {
1348     this.#isEditing = value;
1349     if (!this.parent) {
1350       return;
1351     }
1352     if (value) {
1353       this.parent.setSelected(this);
1354       this.parent.setActiveEditor(this);
1355     } else {
1356       this.parent.setActiveEditor(null);
1357     }
1358   }
1359 
1360   /**
1361    * Set the aspect ratio to use when resizing.
1362    * @param {number} width
1363    * @param {number} height
1364    */
1365   setAspectRatio(width, height) {
1366     this.#keepAspectRatio = true;
1367     const aspectRatio = width / height;
1368     const { style } = this.div;
1369     style.aspectRatio = aspectRatio;
1370     style.height = "auto";
1371   }
1372 
1373   static get MIN_SIZE() {
1374     return 16;
1375   }
1376 }
1377 
1378 // This class is used to fake an editor which has been deleted.
1379 class FakeEditor extends AnnotationEditor {
1380   constructor(params) {
1381     super(params);
1382     this.annotationElementId = params.annotationElementId;
1383     this.deleted = true;
1384   }
1385 
1386   serialize() {
1387     return {
1388       id: this.annotationElementId,
1389       deleted: true,
1390       pageIndex: this.pageIndex,
1391     };
1392   }
1393 }
1394 
1395 export { AnnotationEditor };
</code>

Test file:
<test_file>
File:
test/unit/editor_spec.js
/* Copyright 2022 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import { CommandManager } from "../../src/display/editor/tools.js";
</test_file>

Your task:
You are a software tester at pdf.js.
1. Examine the existing test file. You may reuse any imports, helpers or setup blocks it already has.
2. Write exactly one javascript test `it("...", async () => {...})` block.
3. Your test must fail on the code before the patch, and pass after, hence the test will verify that the patch resolves the issue.
4. The test must be self-contained and to-the-point.
5. If you need something new use only the provided imports (respect the paths exactly how they are given) by importing dynamically for compatibility with Node.js — no new dependencies. 
6. Return only the javascript code for the new `it(...)` block (no comments or explanations).

Example structure:
it("should <describe behavior>", async () => {
  const { example } = await import("../../src/core/example.js");
  <initialize required variables>;
  <define expected variable>;
  <generate actual variables>;
  <compare expected with actual>;
});

