Before you begin:
- Keep going until the job is completely solved — don’t stop halfway.
- If you’re unsure about the behavior, reread the provided patch carefully; do not hallucinate.
- Plan your approach before writing code by reflecting on whether the test truly fails before and passes after.

Issue:
<issue>
[Bug]: Inline image not rendered
### Attach (recommended) or Link to PDF file

[VERAPDF-1335-InlineImage.pdf](https://github.com/user-attachments/files/18810079/VERAPDF-1335-InlineImage.pdf)

### Web browser and its version

Firefox 135.0

### Operating system and its version

Windows 10.0.19045.5487

### PDF.js version

https://mozilla.github.io/pdf.js/web/viewer.html

### Is the bug present in the latest PDF.js version?

Yes

### Is a browser extension

No

### Steps to reproduce the problem

open file

### What is the expected behavior?

blue ball top left

![Image](https://github.com/user-attachments/assets/fac4df89-886f-4668-ab49-e1e4bb14e2cc)

### What went wrong?

no blue ball top left

![Image](https://github.com/user-attachments/assets/e3b59533-e889-47c1-a080-f693426af340)

### Link to a viewer

_No response_

### Additional context

EI is followed by a number; file is from VeraPDF
https://github.com/veraPDF/veraPDF-library/issues/1335
</issue>

PDF File:
<pdf>
issue19494.pdf
</pdf>

Patch:
<patch>
diff --git a/src/core/parser.js b/src/core/parser.js
--- a/src/core/parser.js
+++ b/src/core/parser.js
@@ -248,8 +248,12 @@ class Parser {
           }
           // Check that the "EI" sequence isn't part of the image data, since
           // that would cause the image to be truncated (fixes issue11124.pdf).
+          //
+          // Check more than the `followingBytes` to be able to find operators
+          // with multiple arguments, e.g. transform (cm) with decimal arguments
+          // (fixes issue19494.pdf).
           const tmpLexer = new Lexer(
-            new Stream(followingBytes.slice()),
+            new Stream(stream.peekBytes(5 * n)),
             knownCommands
           );
           // Reduce the number of (potential) warning messages.


</patch>

Imports:
<imports>
Available Packages
Dev Dependencies:
- @babel/core: ^7.26.8
- @babel/preset-env: ^7.26.8
- @babel/runtime: ^7.26.7
- @fluent/bundle: ^0.18.0
- @fluent/dom: ^0.10.0
- @metalsmith/layouts: ^2.7.0
- @metalsmith/markdown: ^1.10.0
- @napi-rs/canvas: ^0.1.67
- @types/node: ^22.13.1
- autoprefixer: ^10.4.20
- babel-loader: ^9.2.1
- caniuse-lite: ^1.0.30001699
- core-js: ^3.40.0
- eslint: ^9.20.0
- eslint-plugin-import: ^2.31.0
- eslint-plugin-jasmine: ^4.2.2
- eslint-plugin-json: ^4.0.1
- eslint-plugin-no-unsanitized: ^4.1.2
- eslint-plugin-perfectionist: ^4.8.0
- eslint-plugin-prettier: ^5.2.3
- eslint-plugin-unicorn: ^56.0.1
- globals: ^15.14.0
- gulp: ^5.0.0
- gulp-cli: ^3.0.0
- gulp-postcss: ^10.0.0
- gulp-rename: ^2.0.0
- gulp-replace: ^1.1.4
- gulp-zip: ^6.1.0
- highlight.js: ^11.11.1
- jasmine: ^5.6.0
- jsdoc: ^4.0.4
- jstransformer-nunjucks: ^1.2.0
- metalsmith: ^2.6.3
- metalsmith-html-relative: ^2.0.6
- ordered-read-streams: ^2.0.0
- pngjs: ^7.0.0
- postcss: ^8.5.1
- postcss-dark-theme-class: ^1.3.0
- postcss-dir-pseudo-class: ^9.0.1
- postcss-discard-comments: ^7.0.3
- postcss-nesting: ^13.0.1
- prettier: ^3.5.0
- puppeteer: ^24.2.0
- stylelint: ^16.14.1
- stylelint-prettier: ^5.0.3
- svglint: ^3.1.0
- terser-webpack-plugin: ^5.3.11
- tsc-alias: ^1.8.10
- ttest: ^4.0.0
- typescript: ^5.7.3
- vinyl: ^3.0.0
- webpack: ^5.97.1
- webpack-stream: ^7.0.0
- yargs: ^17.7.2

Engines:
- node: >=20

Available Relative Imports:
- `../../src/core/annotation.js`: Annotation, AnnotationBorderStyle, AnnotationFactory, MarkupAnnotation, getQuadPoints
- `../../src/core/bidi.js`: bidi
- `../../src/core/cff_parser.js`: CFFCharset, CFFCompiler, CFFFDSelect, CFFParser, CFFStrings
- `../../src/core/cmap.js`: CMap, CMapFactory, IdentityCMap
- `../../src/core/colorspace.js`: ColorSpace
- `../../src/core/core_utils.js`: arrayBuffersToBytes, encodeToXmlString, escapePDFName, escapeString, getInheritableProperty, getSizeInBytes, isAscii, isWhiteSpace, log2, numberToString, parseXFAPath, recoverJsURL, stringToUTF16HexString, stringToUTF16String, toRomanNumerals, validateCSSFont
- `../../src/core/crypto.js`: AES128Cipher, AES256Cipher, ARCFourCipher, CipherTransformFactory, PDF17, PDF20, calculateMD5, calculateSHA256, calculateSHA384, calculateSHA512
- `../../src/core/default_appearance.js`: createDefaultAppearance, parseAppearanceStream, parseDefaultAppearance
- `../../src/core/document.js`: PDFDocument, Page
- `../../src/core/encodings.js`: getEncoding
- `../../src/core/evaluator.js`: PartialEvaluator
- `../../src/core/flate_stream.js`: FlateStream
- `../../src/core/font_substitutions.js`: getFontSubstitution
- `../../src/core/fonts_utils.js`: SEAC_ANALYSIS_ENABLED
- `../../src/core/function.js`: PDFFunctionFactory, PostScriptCompiler, PostScriptEvaluator
- `../../src/core/glyphlist.js`: getDingbatsGlyphsUnicode, getGlyphsUnicode
- `../../src/core/image_utils.js`: GlobalImageCache, LocalColorSpaceCache
- `../../src/core/jbig2.js`: Jbig2Error, Jbig2Image
- `../../src/core/jpg.js`: JpegError, JpegImage
- `../../src/core/jpx.js`: JpxError, JpxImage
- `../../src/core/metadata_parser.js`: MetadataParser
- `../../src/core/operator_list.js`: OperatorList
- `../../src/core/parser.js`: Lexer, Linearization, Parser
- `../../src/core/predictor_stream.js`: PredictorStream
- `../../src/core/primitives.js`: Cmd, Dict, EOF, Name, Ref, RefSet, RefSetCache, isCmd, isDict, isName, isRefsEqual
- `../../src/core/ps_parser.js`: PostScriptLexer, PostScriptParser
- `../../src/core/stream.js`: NullStream, Stream, StringStream
- `../../src/core/type1_parser.js`: Type1Parser
- `../../src/core/unicode.js`: getCharUnicodeCategory, getUnicodeForGlyph, getUnicodeRangeFor, mapSpecialUnicodeValues
- `../../src/core/worker.js`: WorkerMessageHandler, WorkerTask
- `../../src/core/writer.js`: incrementalUpdate, writeChanges, writeDict
- `../../src/core/xfa/bind.js`: Binder
- `../../src/core/xfa/data.js`: DataHandler
- `../../src/core/xfa/factory.js`: XFAFactory
- `../../src/core/xfa/formcalc_lexer.js`: Lexer, TOKEN, Token
- `../../src/core/xfa/formcalc_parser.js`: Errors, Parser
- `../../src/core/xfa/parser.js`: XFAParser
- `../../src/core/xfa/som.js`: searchNode
- `../../src/core/xfa/symbol_utils.js`: $dump, $getChildren, $getChildrenByClass, $getChildrenByName, $text, $uid
- `../../src/core/xml_parser.js`: SimpleXMLParser, XMLParserBase
- `../../src/display/annotation_layer.js`: AnnotationLayer
- `../../src/display/annotation_storage.js`: AnnotationStorage
- `../../src/display/api.js`: LoopbackPort, PDFDataRangeTransport, PDFDocumentLoadingTask, PDFDocumentProxy, PDFPageProxy, PDFWorker, RenderTask, build, getDocument, version
- `../../src/display/canvas_factory.js`: DOMCanvasFactory
- `../../src/display/cmap_reader_factory.js`: DOMCMapReaderFactory
- `../../src/display/display_utils.js`: OutputScale, PDFDateString, PageViewport, PixelsPerInch, RenderingCancelledException, StatTimer, SupportedImageMimeTypes, fetchData, getFilenameFromUrl, getPdfFilenameFromUrl, getXfaPageViewport, isDataScheme, isPdfFile, isValidFetchUrl, noContextMenu, setLayerDimensions, stopEvent
- `../../src/display/draw_layer.js`: DrawLayer
- `../../src/display/editor/annotation_editor_layer.js`: AnnotationEditorLayer
- `../../src/display/editor/color_picker.js`: ColorPicker
- `../../src/display/editor/drawers/signaturedraw.js`: SignatureExtractor
- `../../src/display/editor/tools.js`: AnnotationEditorUIManager, CommandManager
- `../../src/display/fetch_stream.js`: PDFFetchStream
- `../../src/display/metadata.js`: Metadata
- `../../src/display/network.js`: PDFNetworkStream
- `../../src/display/network_utils.js`: createHeaders, createResponseError, extractFilenameFromHeader, validateRangeRequestCapabilities, validateResponseStatus
- `../../src/display/node_stream.js`: PDFNodeStream
- `../../src/display/node_utils.js`: NodeCMapReaderFactory, NodeStandardFontDataFactory, fetchData
- `../../src/display/standard_fontdata_factory.js`: DOMStandardFontDataFactory
- `../../src/display/svg_factory.js`: DOMSVGFactory
- `../../src/display/text_layer.js`: TextLayer
- `../../src/display/touch_manager.js`: TouchManager
- `../../src/display/worker_options.js`: GlobalWorkerOptions
- `../../src/display/xfa_layer.js`: XfaLayer
- `../../src/shared/message_handler.js`: MessageHandler
- `../../src/shared/murmurhash3.js`: MurmurHash3_64
- `../../src/shared/util.js`: AbortException, AnnotationBorderStyleType, AnnotationEditorParamsType, AnnotationEditorType, AnnotationFieldFlag, AnnotationFlag, AnnotationMode, AnnotationType, BaseException, FeatureTest, FormatError, ImageKind, InvalidPDFException, OPS, PasswordException, PasswordResponses, PermissionFlag, RenderingIntentFlag, ResponseException, UnknownErrorException, Util, VerbosityLevel, assert, bytesToString, createValidAbsoluteUrl, getModificationDate, getUuid, getVerbosityLevel, isNodeJS, normalizeUnicode, objectSize, setVerbosityLevel, shadow, string32, stringToBytes, stringToPDFString, stringToUTF8String, toBase64Util
- `../../web/annotation_layer_builder.js`: AnnotationLayerBuilder
- `../../web/app_options.js`: AppOptions, OptionKind
- `../../web/autolinker.js`: Autolinker
- `../../web/download_manager.js`: DownloadManager
- `../../web/event_utils.js`: EventBus, WaitOnType, waitOnEventOrTimeout
- `../../web/genericl10n.js`: GenericL10n
- `../../web/pdf_find_controller.js`: FindState, PDFFindController
- `../../web/pdf_find_utils.js`: CharacterType, getCharacterType
- `../../web/pdf_history.js`: PDFHistory, isDestArraysEqual, isDestHashesEqual
- `../../web/pdf_link_service.js`: LinkTarget, PDFLinkService, SimpleLinkService
- `../../web/pdf_page_view.js`: PDFPageView
- `../../web/pdf_scripting_manager.component.js`: PDFScriptingManager
- `../../web/pdf_single_page_viewer.js`: PDFSinglePageViewer
- `../../web/pdf_viewer.js`: PDFPageViewBuffer, PDFViewer
- `../../web/struct_tree_layer_builder.js`: StructTreeLayerBuilder
- `../../web/text_layer_builder.js`: TextLayerBuilder
- `../../web/ui_utils.js`: AutoPrintRegExp, ProgressBar, RenderingStates, ScrollMode, SpreadMode, backtrackBeforeAllVisibleElements, binarySearchFirstItem, calcRound, getPageSizeInches, getVisibleElements, isPortraitOrientation, isValidRotation, parseQueryString, removeNullCharacters
- `../../web/xfa_layer_builder.js`: XfaLayerBuilder
- `../reporter.js`: TestReporter
- `./common_pdfstream_tests.js`: testCrossOriginRedirects
- `./test_utils.js`: CMAP_URL, DefaultCMapReaderFactory, DefaultFileReaderFactory, DefaultStandardFontDataFactory, STANDARD_FONT_DATA_URL, TEST_PDFS_PATH, TestPdfsServer, XRefMock, buildGetDocumentParams, createIdFactory, getCrossOriginHostname
</imports>

Code:
<code>
File:
src/core/parser.js
1 /* Copyright 2012 Mozilla Foundation
2  *
3  * Licensed under the Apache License, Version 2.0 (the "License");
4  * you may not use this file except in compliance with the License.
5  * You may obtain a copy of the License at
6  *
7  *     http://www.apache.org/licenses/LICENSE-2.0
8  *
9  * Unless required by applicable law or agreed to in writing, software
10  * distributed under the License is distributed on an "AS IS" BASIS,
11  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
12  * See the License for the specific language governing permissions and
13  * limitations under the License.
14  */
15 
16 import {
17   assert,
18   bytesToString,
19   FormatError,
20   info,
21   warn,
22 } from "../shared/util.js";
23 import { Cmd, Dict, EOF, isCmd, Name, Ref } from "./primitives.js";
24 import {
25   isWhiteSpace,
26   MissingDataException,
27   ParserEOFException,
28 } from "./core_utils.js";
29 import { NullStream, Stream } from "./stream.js";
30 import { Ascii85Stream } from "./ascii_85_stream.js";
31 import { AsciiHexStream } from "./ascii_hex_stream.js";
32 import { CCITTFaxStream } from "./ccitt_stream.js";
33 import { FlateStream } from "./flate_stream.js";
34 import { Jbig2Stream } from "./jbig2_stream.js";
35 import { JpegStream } from "./jpeg_stream.js";
36 import { JpxStream } from "./jpx_stream.js";
37 import { LZWStream } from "./lzw_stream.js";
38 import { PredictorStream } from "./predictor_stream.js";
39 import { RunLengthStream } from "./run_length_stream.js";
40 
41 const MAX_LENGTH_TO_CACHE = 1000;
42 
43 function getInlineImageCacheKey(bytes) {
44   const strBuf = [],
45     ii = bytes.length;
46   let i = 0;
47   while (i < ii - 1) {
48     strBuf.push((bytes[i++] << 8) | bytes[i++]);
49   }
50   // Handle an odd number of elements.
51   if (i < ii) {
52     strBuf.push(bytes[i]);
53   }
54   // We purposely include the "raw" length in the cacheKey, to prevent any
55   // possible issues with hash collisions in the inline image cache.
56   // Here we also assume that `strBuf` is never larger than 8192 elements,
57   // please refer to the `bytesToString` implementation.
58   return ii + "_" + String.fromCharCode.apply(null, strBuf);
59 }
60 
61 class Parser {
62   constructor({ lexer, xref, allowStreams = false, recoveryMode = false }) {
63     this.lexer = lexer;
64     this.xref = xref;
65     this.allowStreams = allowStreams;
66     this.recoveryMode = recoveryMode;
67 
68     this.imageCache = Object.create(null);
69     this._imageId = 0;
70     this.refill();
71   }
72 
73   refill() {
74     this.buf1 = this.lexer.getObj();
75     this.buf2 = this.lexer.getObj();
76   }
77 
78   shift() {
79     if (this.buf2 instanceof Cmd && this.buf2.cmd === "ID") {
80       this.buf1 = this.buf2;
81       this.buf2 = null;
82     } else {
83       this.buf1 = this.buf2;
84       this.buf2 = this.lexer.getObj();
85     }
86   }
87 
88   tryShift() {
89     try {
90       this.shift();
91       return true;
92     } catch (e) {
93       if (e instanceof MissingDataException) {
94         throw e;
95       }
96       // Upon failure, the caller should reset this.lexer.pos to a known good
97       // state and call this.shift() twice to reset the buffers.
98       return false;
99     }
100   }
101 
102   getObj(cipherTransform = null) {
103     const buf1 = this.buf1;
104     this.shift();
105 
106     if (buf1 instanceof Cmd) {
107       switch (buf1.cmd) {
108         case "BI": // inline image
109           return this.makeInlineImage(cipherTransform);
110         case "[": // array
111           const array = [];
112           while (!isCmd(this.buf1, "]") && this.buf1 !== EOF) {
113             array.push(this.getObj(cipherTransform));
114           }
115           if (this.buf1 === EOF) {
116             if (this.recoveryMode) {
117               return array;
118             }
119             throw new ParserEOFException("End of file inside array.");
120           }
121           this.shift();
122           return array;
123         case "<<": // dictionary or stream
124           const dict = new Dict(this.xref);
125           while (!isCmd(this.buf1, ">>") && this.buf1 !== EOF) {
126             if (!(this.buf1 instanceof Name)) {
127               info("Malformed dictionary: key must be a name object");
128               this.shift();
129               continue;
130             }
131 
132             const key = this.buf1.name;
133             this.shift();
134             if (this.buf1 === EOF) {
135               break;
136             }
137             dict.set(key, this.getObj(cipherTransform));
138           }
139           if (this.buf1 === EOF) {
140             if (this.recoveryMode) {
141               return dict;
142             }
143             throw new ParserEOFException("End of file inside dictionary.");
144           }
145 
146           // Stream objects are not allowed inside content streams or
147           // object streams.
148           if (isCmd(this.buf2, "stream")) {
149             return this.allowStreams
150               ? this.makeStream(dict, cipherTransform)
151               : dict;
152           }
153           this.shift();
154           return dict;
155         default: // simple object
156           return buf1;
157       }
158     }
159 
160     if (Number.isInteger(buf1)) {
161       // indirect reference or integer
162       if (Number.isInteger(this.buf1) && isCmd(this.buf2, "R")) {
163         const ref = Ref.get(buf1, this.buf1);
164         this.shift();
165         this.shift();
166         return ref;
167       }
168       return buf1;
169     }
170 
171     if (typeof buf1 === "string") {
172       if (cipherTransform) {
173         return cipherTransform.decryptString(buf1);
174       }
175       return buf1;
176     }
177 
178     // simple object
179     return buf1;
180   }
181 
182   /**
183    * Find the end of the stream by searching for the /EI\s/.
184    * @returns {number} The inline stream length.
185    */
186   findDefaultInlineStreamEnd(stream) {
187     const E = 0x45,
188       I = 0x49,
189       SPACE = 0x20,
190       LF = 0xa,
191       CR = 0xd,
192       NUL = 0x0;
193     const { knownCommands } = this.lexer,
194       startPos = stream.pos,
195       n = 15;
196     let state = 0,
197       ch,
198       maybeEIPos;
199     while ((ch = stream.getByte()) !== -1) {
200       if (state === 0) {
201         state = ch === E ? 1 : 0;
202       } else if (state === 1) {
203         state = ch === I ? 2 : 0;
204       } else {
205         if (typeof PDFJSDev === "undefined" || PDFJSDev.test("TESTING")) {
206           assert(state === 2, "findDefaultInlineStreamEnd - invalid state.");
207         }
208         if (ch === SPACE || ch === LF || ch === CR) {
209           maybeEIPos = stream.pos;
210           // Let's check that the next `n` bytes are ASCII... just to be sure.
211           const followingBytes = stream.peekBytes(n);
212 
213           const ii = followingBytes.length;
214           if (ii === 0) {
215             break; // The end of the stream was reached, nothing to check.
216           }
217           for (let i = 0; i < ii; i++) {
218             ch = followingBytes[i];
219             if (ch === NUL && followingBytes[i + 1] !== NUL) {
220               // NUL bytes are not supposed to occur *outside* of inline
221               // images, but some PDF generators violate that assumption,
222               // thus breaking the EI detection heuristics used below.
223               //
224               // However, we can't unconditionally treat NUL bytes as "ASCII",
225               // since that *could* result in inline images being truncated.
226               //
227               // To attempt to address this, we'll still treat any *sequence*
228               // of NUL bytes as non-ASCII, but for a *single* NUL byte we'll
229               // continue checking the `followingBytes` (fixes issue8823.pdf).
230               continue;
231             }
232             if (ch !== LF && ch !== CR && (ch < SPACE || ch > 0x7f)) {
233               // Not a LF, CR, SPACE or any visible ASCII character, i.e.
234               // it's binary stuff. Resetting the state.
235               state = 0;
236               break;
237             }
238           }
239 
240           if (state !== 2) {
241             continue;
242           }
243           if (!knownCommands) {
244             warn(
245               "findDefaultInlineStreamEnd - `lexer.knownCommands` is undefined."
246             );
247             continue;
248           }
249           // Check that the "EI" sequence isn't part of the image data, since
250           // that would cause the image to be truncated (fixes issue11124.pdf).
251           const tmpLexer = new Lexer(
252             new Stream(followingBytes.slice()),
253             knownCommands
254           );
255           // Reduce the number of (potential) warning messages.
256           tmpLexer._hexStringWarn = () => {};
257           let numArgs = 0;
258 
259           while (true) {
260             const nextObj = tmpLexer.getObj();
261 
262             if (nextObj === EOF) {
263               state = 0; // No valid command found, resetting the state.
264               break;
265             }
266             if (nextObj instanceof Cmd) {
267               const knownCommand = knownCommands[nextObj.cmd];
268               if (!knownCommand) {
269                 // Not a valid command, i.e. the inline image data *itself*
270                 // contains an "EI" sequence. Resetting the state.
271                 state = 0;
272                 break;
273               } else if (
274                 knownCommand.variableArgs
275                   ? numArgs <= knownCommand.numArgs
276                   : numArgs === knownCommand.numArgs
277               ) {
278                 break; // Valid command found.
279               }
280               numArgs = 0;
281               continue;
282             }
283             numArgs++;
284           }
285 
286           if (state === 2) {
287             break; // Finished!
288           }
289         } else {
290           state = 0;
291         }
292       }
293     }
294 
295     if (ch === -1) {
296       warn(
297         "findDefaultInlineStreamEnd: " +
298           "Reached the end of the stream without finding a valid EI marker"
299       );
300       if (maybeEIPos) {
301         warn('... trying to recover by using the last "EI" occurrence.');
302         stream.skip(-(stream.pos - maybeEIPos)); // Reset the stream position.
303       }
304     }
305 
306     let endOffset = 4;
307     stream.skip(-endOffset); // Set the stream position to just before "EI".
308     ch = stream.peekByte();
309     stream.skip(endOffset); // ... and remember to reset the stream position.
310 
311     // Ensure that we don't accidentally truncate the inline image, when the
312     // data is immediately followed by the "EI" marker (fixes issue10388.pdf).
313     if (!isWhiteSpace(ch)) {
314       endOffset--;
315     }
316     return stream.pos - endOffset - startPos;
317   }
318 
319   /**
320    * Find the EOI (end-of-image) marker 0xFFD9 of the stream.
321    * @returns {number} The inline stream length.
322    */
323   findDCTDecodeInlineStreamEnd(stream) {
324     const startPos = stream.pos;
325     let foundEOI = false,
326       b,
327       markerLength;
328     while ((b = stream.getByte()) !== -1) {
329       if (b !== 0xff) {
330         // Not a valid marker.
331         continue;
332       }
333       switch (stream.getByte()) {
334         case 0x00: // Byte stuffing.
335           // 0xFF00 appears to be a very common byte sequence in JPEG images.
336           break;
337 
338         case 0xff: // Fill byte.
339           // Avoid skipping a valid marker, resetting the stream position.
340           stream.skip(-1);
341           break;
342 
343         case 0xd9: // EOI
344           foundEOI = true;
345           break;
346 
347         case 0xc0: // SOF0
348         case 0xc1: // SOF1
349         case 0xc2: // SOF2
350         case 0xc3: // SOF3
351         /* falls through */
352         case 0xc5: // SOF5
353         case 0xc6: // SOF6
354         case 0xc7: // SOF7
355         /* falls through */
356         case 0xc9: // SOF9
357         case 0xca: // SOF10
358         case 0xcb: // SOF11
359         /* falls through */
360         case 0xcd: // SOF13
361         case 0xce: // SOF14
362         case 0xcf: // SOF15
363         /* falls through */
364         case 0xc4: // DHT
365         case 0xcc: // DAC
366         /* falls through */
367         case 0xda: // SOS
368         case 0xdb: // DQT
369         case 0xdc: // DNL
370         case 0xdd: // DRI
371         case 0xde: // DHP
372         case 0xdf: // EXP
373         /* falls through */
374         case 0xe0: // APP0
375         case 0xe1: // APP1
376         case 0xe2: // APP2
377         case 0xe3: // APP3
378         case 0xe4: // APP4
379         case 0xe5: // APP5
380         case 0xe6: // APP6
381         case 0xe7: // APP7
382         case 0xe8: // APP8
383         case 0xe9: // APP9
384         case 0xea: // APP10
385         case 0xeb: // APP11
386         case 0xec: // APP12
387         case 0xed: // APP13
388         case 0xee: // APP14
389         case 0xef: // APP15
390         /* falls through */
391         case 0xfe: // COM
392           // The marker should be followed by the length of the segment.
393           markerLength = stream.getUint16();
394           if (markerLength > 2) {
395             // |markerLength| contains the byte length of the marker segment,
396             // including its own length (2 bytes) and excluding the marker.
397             stream.skip(markerLength - 2); // Jump to the next marker.
398           } else {
399             // The marker length is invalid, resetting the stream position.
400             stream.skip(-2);
401           }
402           break;
403       }
404       if (foundEOI) {
405         break;
406       }
407     }
408     const length = stream.pos - startPos;
409     if (b === -1) {
410       warn(
411         "Inline DCTDecode image stream: " +
412           "EOI marker not found, searching for /EI/ instead."
413       );
414       stream.skip(-length); // Reset the stream position.
415       return this.findDefaultInlineStreamEnd(stream);
416     }
417     this.inlineStreamSkipEI(stream);
418     return length;
419   }
420 
421   /**
422    * Find the EOD (end-of-data) marker '~>' (i.e. TILDE + GT) of the stream.
423    * @returns {number} The inline stream length.
424    */
425   findASCII85DecodeInlineStreamEnd(stream) {
426     const TILDE = 0x7e,
427       GT = 0x3e;
428     const startPos = stream.pos;
429     let ch;
430     while ((ch = stream.getByte()) !== -1) {
431       if (ch === TILDE) {
432         const tildePos = stream.pos;
433 
434         ch = stream.peekByte();
435         // Handle corrupt PDF documents which contains whitespace "inside" of
436         // the EOD marker (fixes issue10614.pdf).
437         while (isWhiteSpace(ch)) {
438           stream.skip();
439           ch = stream.peekByte();
440         }
441         if (ch === GT) {
442           stream.skip();
443           break;
444         }
445         // Handle corrupt PDF documents which contains truncated EOD markers,
446         // where the '>' character is missing (fixes issue11385.pdf).
447         if (stream.pos > tildePos) {
448           const maybeEI = stream.peekBytes(2);
449           if (maybeEI[0] === /* E = */ 0x45 && maybeEI[1] === /* I = */ 0x49) {
450             break;
451           }
452         }
453       }
454     }
455     const length = stream.pos - startPos;
456     if (ch === -1) {
457       warn(
458         "Inline ASCII85Decode image stream: " +
459           "EOD marker not found, searching for /EI/ instead."
460       );
461       stream.skip(-length); // Reset the stream position.
462       return this.findDefaultInlineStreamEnd(stream);
463     }
464     this.inlineStreamSkipEI(stream);
465     return length;
466   }
467 
468   /**
469    * Find the EOD (end-of-data) marker '>' (i.e. GT) of the stream.
470    * @returns {number} The inline stream length.
471    */
472   findASCIIHexDecodeInlineStreamEnd(stream) {
473     const GT = 0x3e;
474     const startPos = stream.pos;
475     let ch;
476     while ((ch = stream.getByte()) !== -1) {
477       if (ch === GT) {
478         break;
479       }
480     }
481     const length = stream.pos - startPos;
482     if (ch === -1) {
483       warn(
484         "Inline ASCIIHexDecode image stream: " +
485           "EOD marker not found, searching for /EI/ instead."
486       );
487       stream.skip(-length); // Reset the stream position.
488       return this.findDefaultInlineStreamEnd(stream);
489     }
490     this.inlineStreamSkipEI(stream);
491     return length;
492   }
493 
494   /**
495    * Skip over the /EI/ for streams where we search for an EOD marker.
496    */
497   inlineStreamSkipEI(stream) {
498     const E = 0x45,
499       I = 0x49;
500     let state = 0,
501       ch;
502     while ((ch = stream.getByte()) !== -1) {
503       if (state === 0) {
504         state = ch === E ? 1 : 0;
505       } else if (state === 1) {
506         state = ch === I ? 2 : 0;
507       } else if (state === 2) {
508         break;
509       }
510     }
511   }
512 
513   makeInlineImage(cipherTransform) {
514     const lexer = this.lexer;
515     const stream = lexer.stream;
516 
517     // Parse dictionary, but initialize it lazily to improve performance with
518     // cached inline images (see issue 2618).
519     const dictMap = Object.create(null);
520     let dictLength;
521     while (!isCmd(this.buf1, "ID") && this.buf1 !== EOF) {
522       if (!(this.buf1 instanceof Name)) {
523         throw new FormatError("Dictionary key must be a name object");
524       }
525       const key = this.buf1.name;
526       this.shift();
527       if (this.buf1 === EOF) {
528         break;
529       }
530       dictMap[key] = this.getObj(cipherTransform);
531     }
532     if (lexer.beginInlineImagePos !== -1) {
533       dictLength = stream.pos - lexer.beginInlineImagePos;
534     }
535 
536     // Extract the name of the first (i.e. the current) image filter.
537     const filter = this.xref.fetchIfRef(dictMap.F || dictMap.Filter);
538     let filterName;
539     if (filter instanceof Name) {
540       filterName = filter.name;
541     } else if (Array.isArray(filter)) {
542       const filterZero = this.xref.fetchIfRef(filter[0]);
543       if (filterZero instanceof Name) {
544         filterName = filterZero.name;
545       }
546     }
547 
548     // Parse image stream.
549     const startPos = stream.pos;
550     let length;
551     switch (filterName) {
552       case "DCT":
553       case "DCTDecode":
554         length = this.findDCTDecodeInlineStreamEnd(stream);
555         break;
556       case "A85":
557       case "ASCII85Decode":
558         length = this.findASCII85DecodeInlineStreamEnd(stream);
559         break;
560       case "AHx":
561       case "ASCIIHexDecode":
562         length = this.findASCIIHexDecodeInlineStreamEnd(stream);
563         break;
564       default:
565         length = this.findDefaultInlineStreamEnd(stream);
566     }
567 
568     // Cache all images below the MAX_LENGTH_TO_CACHE threshold by their
569     // stringified content, to prevent possible hash collisions.
570     let cacheKey;
571     if (length < MAX_LENGTH_TO_CACHE && dictLength > 0) {
572       const initialStreamPos = stream.pos;
573       // Set the stream position to the beginning of the dictionary data...
574       stream.pos = lexer.beginInlineImagePos;
575       // ... and fetch the bytes of the dictionary *and* the inline image.
576       cacheKey = getInlineImageCacheKey(stream.getBytes(dictLength + length));
577       // Finally, don't forget to reset the stream position.
578       stream.pos = initialStreamPos;
579 
580       const cacheEntry = this.imageCache[cacheKey];
581       if (cacheEntry !== undefined) {
582         this.buf2 = Cmd.get("EI");
583         this.shift();
584 
585         cacheEntry.reset();
586         return cacheEntry;
587       }
588     }
589 
590     const dict = new Dict(this.xref);
591     for (const key in dictMap) {
592       dict.set(key, dictMap[key]);
593     }
594     let imageStream = stream.makeSubStream(startPos, length, dict);
595     if (cipherTransform) {
596       imageStream = cipherTransform.createStream(imageStream, length);
597     }
598 
599     imageStream = this.filter(imageStream, dict, length);
600     imageStream.dict = dict;
601     if (cacheKey !== undefined) {
602       imageStream.cacheKey = `inline_img_${++this._imageId}`;
603       this.imageCache[cacheKey] = imageStream;
604     }
605 
606     this.buf2 = Cmd.get("EI");
607     this.shift();
608 
609     return imageStream;
610   }
611 
612   #findStreamLength(startPos) {
613     const { stream } = this.lexer;
614     stream.pos = startPos;
615 
616     const SCAN_BLOCK_LENGTH = 2048;
617     const signatureLength = "endstream".length;
618 
619     const END_SIGNATURE = new Uint8Array([0x65, 0x6e, 0x64]);
620     const endLength = END_SIGNATURE.length;
621 
622     // Ideally we'd directly search for "endstream", however there are corrupt
623     // PDF documents where the command is incomplete; hence we search for:
624     //  1. The normal case.
625     //  2. The misspelled case (fixes issue18122.pdf).
626     //  3. The truncated case (fixes issue10004.pdf).
627     const PARTIAL_SIGNATURE = [
628       new Uint8Array([0x73, 0x74, 0x72, 0x65, 0x61, 0x6d]), // "stream"
629       new Uint8Array([0x73, 0x74, 0x65, 0x61, 0x6d]), // "steam",
630       new Uint8Array([0x73, 0x74, 0x72, 0x65, 0x61]), // "strea"
631     ];
632     const normalLength = signatureLength - endLength;
633 
634     while (stream.pos < stream.end) {
635       const scanBytes = stream.peekBytes(SCAN_BLOCK_LENGTH);
636       const scanLength = scanBytes.length - signatureLength;
637 
638       if (scanLength <= 0) {
639         break;
640       }
641       let pos = 0;
642       while (pos < scanLength) {
643         let j = 0;
644         while (j < endLength && scanBytes[pos + j] === END_SIGNATURE[j]) {
645           j++;
646         }
647         if (j >= endLength) {
648           // "end" found, find the complete command.
649           let found = false;
650           for (const part of PARTIAL_SIGNATURE) {
651             const partLen = part.length;
652             let k = 0;
653             while (k < partLen && scanBytes[pos + j + k] === part[k]) {
654               k++;
655             }
656             if (k >= normalLength) {
657               // Found "endstream" command.
658               found = true;
659               break;
660             }
661             if (k >= partLen) {
662               // Found "endsteam" or "endstea" command.
663               // Ensure that the byte immediately following the corrupt
664               // endstream command is a space, to prevent false positives.
665               const lastByte = scanBytes[pos + j + k];
666               if (isWhiteSpace(lastByte)) {
667                 info(
668                   `Found "${bytesToString([...END_SIGNATURE, ...part])}" when ` +
669                     "searching for endstream command."
670                 );
671                 found = true;
672               }
673               break;
674             }
675           }
676 
677           if (found) {
678             stream.pos += pos;
679             return stream.pos - startPos;
680           }
681         }
682         pos++;
683       }
684       stream.pos += scanLength;
685     }
686     return -1;
687   }
688 
689   makeStream(dict, cipherTransform) {
690     const lexer = this.lexer;
691     let stream = lexer.stream;
692 
693     // Get the stream's start position.
694     lexer.skipToNextLine();
695     const startPos = stream.pos - 1;
696 
697     // Get the length.
698     let length = dict.get("Length");
699     if (!Number.isInteger(length)) {
700       info(`Bad length "${length && length.toString()}" in stream.`);
701       length = 0;
702     }
703 
704     // Skip over the stream data.
705     stream.pos = startPos + length;
706     lexer.nextChar();
707 
708     // Shift '>>' and check whether the new object marks the end of the stream.
709     if (this.tryShift() && isCmd(this.buf2, "endstream")) {
710       this.shift(); // 'stream'
711     } else {
712       // Bad stream length, scanning for endstream command.
713       length = this.#findStreamLength(startPos);
714       if (length < 0) {
715         throw new FormatError("Missing endstream command.");
716       }
717 
718       lexer.nextChar();
719       this.shift();
720       this.shift();
721     }
722     this.shift(); // 'endstream'
723 
724     stream = stream.makeSubStream(startPos, length, dict);
725     if (cipherTransform) {
726       stream = cipherTransform.createStream(stream, length);
727     }
728     stream = this.filter(stream, dict, length);
729     stream.dict = dict;
730     return stream;
731   }
732 
733   filter(stream, dict, length) {
734     let filter = dict.get("F", "Filter");
735     let params = dict.get("DP", "DecodeParms");
736 
737     if (filter instanceof Name) {
738       if (Array.isArray(params)) {
739         warn("/DecodeParms should not be an Array, when /Filter is a Name.");
740       }
741       return this.makeFilter(stream, filter.name, length, params);
742     }
743 
744     let maybeLength = length;
745     if (Array.isArray(filter)) {
746       const filterArray = filter;
747       const paramsArray = params;
748       for (let i = 0, ii = filterArray.length; i < ii; ++i) {
749         filter = this.xref.fetchIfRef(filterArray[i]);
750         if (!(filter instanceof Name)) {
751           throw new FormatError(`Bad filter name "${filter}"`);
752         }
753 
754         params = null;
755         if (Array.isArray(paramsArray) && i in paramsArray) {
756           params = this.xref.fetchIfRef(paramsArray[i]);
757         }
758         stream = this.makeFilter(stream, filter.name, maybeLength, params);
759         // After the first stream the `length` variable is invalid.
760         maybeLength = null;
761       }
762     }
763     return stream;
764   }
765 
766   makeFilter(stream, name, maybeLength, params) {
767     // Since the 'Length' entry in the stream dictionary can be completely
768     // wrong, e.g. zero for non-empty streams, only skip parsing the stream
769     // when we can be absolutely certain that it actually is empty.
770     if (maybeLength === 0) {
771       warn(`Empty "${name}" stream.`);
772       return new NullStream();
773     }
774 
775     try {
776       switch (name) {
777         case "Fl":
778         case "FlateDecode":
779           if (params) {
780             return new PredictorStream(
781               new FlateStream(stream, maybeLength),
782               maybeLength,
783               params
784             );
785           }
786           return new FlateStream(stream, maybeLength);
787         case "LZW":
788         case "LZWDecode":
789           let earlyChange = 1;
790           if (params) {
791             if (params.has("EarlyChange")) {
792               earlyChange = params.get("EarlyChange");
793             }
794             return new PredictorStream(
795               new LZWStream(stream, maybeLength, earlyChange),
796               maybeLength,
797               params
798             );
799           }
800           return new LZWStream(stream, maybeLength, earlyChange);
801         case "DCT":
802         case "DCTDecode":
803           return new JpegStream(stream, maybeLength, params);
804         case "JPX":
805         case "JPXDecode":
806           return new JpxStream(stream, maybeLength, params);
807         case "A85":
808         case "ASCII85Decode":
809           return new Ascii85Stream(stream, maybeLength);
810         case "AHx":
811         case "ASCIIHexDecode":
812           return new AsciiHexStream(stream, maybeLength);
813         case "CCF":
814         case "CCITTFaxDecode":
815           return new CCITTFaxStream(stream, maybeLength, params);
816         case "RL":
817         case "RunLengthDecode":
818           return new RunLengthStream(stream, maybeLength);
819         case "JBIG2Decode":
820           return new Jbig2Stream(stream, maybeLength, params);
821       }
822       warn(`Filter "${name}" is not supported.`);
823       return stream;
824     } catch (ex) {
825       if (ex instanceof MissingDataException) {
826         throw ex;
827       }
828       warn(`Invalid stream: "${ex}"`);
829       return new NullStream();
830     }
831   }
832 }
833 
834 // A '1' in this array means the character is white space. A '1' or
835 // '2' means the character ends a name or command.
836 // prettier-ignore
837 const specialChars = [
838   1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0, // 0x
839   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 1x
840   1, 0, 0, 0, 0, 2, 0, 0, 2, 2, 0, 0, 0, 0, 0, 2, // 2x
841   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 2, 0, // 3x
842   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 4x
843   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 2, 0, 0, // 5x
844   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 6x
845   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 2, 0, 0, // 7x
846   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 8x
847   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 9x
848   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // ax
849   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // bx
850   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // cx
851   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // dx
852   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // ex
853   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0  // fx
854 ];
855 
856 function toHexDigit(ch) {
857   if (ch >= /* '0' = */ 0x30 && ch /* '9' = */ <= 0x39) {
858     return ch & 0x0f;
859   }
860   if (
861     (ch >= /* 'A' = */ 0x41 && ch <= /* 'F' = */ 0x46) ||
862     (ch >= /* 'a' = */ 0x61 && ch <= /* 'f' = */ 0x66)
863   ) {
864     return (ch & 0x0f) + 9;
865   }
866   return -1;
867 }
868 
869 class Lexer {
870   constructor(stream, knownCommands = null) {
871     this.stream = stream;
872     this.nextChar();
873 
874     // While lexing, we build up many strings one char at a time. Using += for
875     // this can result in lots of garbage strings. It's better to build an
876     // array of single-char strings and then join() them together at the end.
877     // And reusing a single array (i.e. |this.strBuf|) over and over for this
878     // purpose uses less memory than using a new array for each string.
879     this.strBuf = [];
880 
881     // The PDFs might have "glued" commands with other commands, operands or
882     // literals, e.g. "q1". The knownCommands is a dictionary of the valid
883     // commands and their prefixes. The prefixes are built the following way:
884     // if there a command that is a prefix of the other valid command or
885     // literal (e.g. 'f' and 'false') the following prefixes must be included,
886     // 'fa', 'fal', 'fals'. The prefixes are not needed, if the command has no
887     // other commands or literals as a prefix. The knowCommands is optional.
888     this.knownCommands = knownCommands;
889 
890     this._hexStringNumWarn = 0;
891     this.beginInlineImagePos = -1;
892   }
893 
894   nextChar() {
895     return (this.currentChar = this.stream.getByte());
896   }
897 
898   peekChar() {
899     return this.stream.peekByte();
900   }
901 
902   getNumber() {
903     let ch = this.currentChar;
904     let eNotation = false;
905     let divideBy = 0; // Different from 0 if it's a floating point value.
906     let sign = 1;
907 
908     if (ch === /* '-' = */ 0x2d) {
909       sign = -1;
910       ch = this.nextChar();
911 
912       if (ch === /* '-' = */ 0x2d) {
913         // Ignore double negative (this is consistent with Adobe Reader).
914         ch = this.nextChar();
915       }
916     } else if (ch === /* '+' = */ 0x2b) {
917       ch = this.nextChar();
918     }
919     if (ch === /* LF = */ 0x0a || ch === /* CR = */ 0x0d) {
920       // Ignore line-breaks (this is consistent with Adobe Reader).
921       do {
922         ch = this.nextChar();
923       } while (ch === 0x0a || ch === 0x0d);
924     }
925     if (ch === /* '.' = */ 0x2e) {
926       divideBy = 10;
927       ch = this.nextChar();
928     }
929     if (ch < /* '0' = */ 0x30 || ch > /* '9' = */ 0x39) {
930       const msg = `Invalid number: ${String.fromCharCode(ch)} (charCode ${ch})`;
931 
932       if (isWhiteSpace(ch) || ch === /* EOF = */ -1) {
933         // This is consistent with Adobe Reader (fixes issue9252.pdf,
934         // issue15604.pdf, bug1753983.pdf).
935         info(`Lexer.getNumber - "${msg}".`);
936         return 0;
937       }
938       throw new FormatError(msg);
939     }
940 
941     let baseValue = ch - 0x30; // '0'
942     let powerValue = 0;
943     let powerValueSign = 1;
944 
945     while ((ch = this.nextChar()) >= 0) {
946       if (ch >= /* '0' = */ 0x30 && ch <= /* '9' = */ 0x39) {
947         const currentDigit = ch - 0x30; // '0'
948         if (eNotation) {
949           // We are after an 'e' or 'E'.
950           powerValue = powerValue * 10 + currentDigit;
951         } else {
952           if (divideBy !== 0) {
953             // We are after a point.
954             divideBy *= 10;
955           }
956           baseValue = baseValue * 10 + currentDigit;
957         }
958       } else if (ch === /* '.' = */ 0x2e) {
959         if (divideBy === 0) {
960           divideBy = 1;
961         } else {
962           // A number can have only one dot.
963           break;
964         }
965       } else if (ch === /* '-' = */ 0x2d) {
966         // Ignore minus signs in the middle of numbers to match
967         // Adobe's behavior.
968         warn("Badly formatted number: minus sign in the middle");
969       } else if (ch === /* 'E' = */ 0x45 || ch === /* 'e' = */ 0x65) {
970         // 'E' can be either a scientific notation or the beginning of a new
971         // operator.
972         ch = this.peekChar();
973         if (ch === /* '+' = */ 0x2b || ch === /* '-' = */ 0x2d) {
974           powerValueSign = ch === 0x2d ? -1 : 1;
975           this.nextChar(); // Consume the sign character.
976         } else if (ch < /* '0' = */ 0x30 || ch > /* '9' = */ 0x39) {
977           // The 'E' must be the beginning of a new operator.
978           break;
979         }
980         eNotation = true;
981       } else {
982         // The last character doesn't belong to us.
983         break;
984       }
985     }
986 
987     if (divideBy !== 0) {
988       baseValue /= divideBy;
989     }
990     if (eNotation) {
991       baseValue *= 10 ** (powerValueSign * powerValue);
992     }
993     return sign * baseValue;
994   }
995 
996   getString() {
997     let numParen = 1;
998     let done = false;
999     const strBuf = this.strBuf;
1000     strBuf.length = 0;
1001 
1002     let ch = this.nextChar();
1003     while (true) {
1004       let charBuffered = false;
1005       switch (ch | 0) {
1006         case -1:
1007           warn("Unterminated string");
1008           done = true;
1009           break;
1010         case 0x28: // '('
1011           ++numParen;
1012           strBuf.push("(");
1013           break;
1014         case 0x29: // ')'
1015           if (--numParen === 0) {
1016             this.nextChar(); // consume strings ')'
1017             done = true;
1018           } else {
1019             strBuf.push(")");
1020           }
1021           break;
1022         case 0x5c: // '\\'
1023           ch = this.nextChar();
1024           switch (ch) {
1025             case -1:
1026               warn("Unterminated string");
1027               done = true;
1028               break;
1029             case 0x6e: // 'n'
1030               strBuf.push("\n");
1031               break;
1032             case 0x72: // 'r'
1033               strBuf.push("\r");
1034               break;
1035             case 0x74: // 't'
1036               strBuf.push("\t");
1037               break;
1038             case 0x62: // 'b'
1039               strBuf.push("\b");
1040               break;
1041             case 0x66: // 'f'
1042               strBuf.push("\f");
1043               break;
1044             case 0x5c: // '\'
1045             case 0x28: // '('
1046             case 0x29: // ')'
1047               strBuf.push(String.fromCharCode(ch));
1048               break;
1049             case 0x30: // '0'
1050             case 0x31: // '1'
1051             case 0x32: // '2'
1052             case 0x33: // '3'
1053             case 0x34: // '4'
1054             case 0x35: // '5'
1055             case 0x36: // '6'
1056             case 0x37: // '7'
1057               let x = ch & 0x0f;
1058               ch = this.nextChar();
1059               charBuffered = true;
1060               if (ch >= /* '0' = */ 0x30 && ch <= /* '7' = */ 0x37) {
1061                 x = (x << 3) + (ch & 0x0f);
1062                 ch = this.nextChar();
1063                 if (ch >= /* '0' = */ 0x30 && ch /* '7' = */ <= 0x37) {
1064                   charBuffered = false;
1065                   x = (x << 3) + (ch & 0x0f);
1066                 }
1067               }
1068               strBuf.push(String.fromCharCode(x));
1069               break;
1070             case 0x0d: // CR
1071               if (this.peekChar() === /* LF = */ 0x0a) {
1072                 this.nextChar();
1073               }
1074               break;
1075             case 0x0a: // LF
1076               break;
1077             default:
1078               strBuf.push(String.fromCharCode(ch));
1079               break;
1080           }
1081           break;
1082         default:
1083           strBuf.push(String.fromCharCode(ch));
1084           break;
1085       }
1086       if (done) {
1087         break;
1088       }
1089       if (!charBuffered) {
1090         ch = this.nextChar();
1091       }
1092     }
1093     return strBuf.join("");
1094   }
1095 
1096   getName() {
1097     let ch, previousCh;
1098     const strBuf = this.strBuf;
1099     strBuf.length = 0;
1100 
1101     while ((ch = this.nextChar()) >= 0 && !specialChars[ch]) {
1102       if (ch === /* '#' = */ 0x23) {
1103         ch = this.nextChar();
1104         if (specialChars[ch]) {
1105           warn(
1106             "Lexer_getName: " +
1107               "NUMBER SIGN (#) should be followed by a hexadecimal number."
1108           );
1109           strBuf.push("#");
1110           break;
1111         }
1112         const x = toHexDigit(ch);
1113         if (x !== -1) {
1114           previousCh = ch;
1115           ch = this.nextChar();
1116           const x2 = toHexDigit(ch);
1117           if (x2 === -1) {
1118             warn(
1119               `Lexer_getName: Illegal digit (${String.fromCharCode(ch)}) ` +
1120                 "in hexadecimal number."
1121             );
1122             strBuf.push("#", String.fromCharCode(previousCh));
1123             if (specialChars[ch]) {
1124               break;
1125             }
1126             strBuf.push(String.fromCharCode(ch));
1127             continue;
1128           }
1129           strBuf.push(String.fromCharCode((x << 4) | x2));
1130         } else {
1131           strBuf.push("#", String.fromCharCode(ch));
1132         }
1133       } else {
1134         strBuf.push(String.fromCharCode(ch));
1135       }
1136     }
1137     if (strBuf.length > 127) {
1138       warn(`Name token is longer than allowed by the spec: ${strBuf.length}`);
1139     }
1140     return Name.get(strBuf.join(""));
1141   }
1142 
1143   /**
1144    * @private
1145    */
1146   _hexStringWarn(ch) {
1147     const MAX_HEX_STRING_NUM_WARN = 5;
1148 
1149     if (this._hexStringNumWarn++ === MAX_HEX_STRING_NUM_WARN) {
1150       warn("getHexString - ignoring additional invalid characters.");
1151       return;
1152     }
1153     if (this._hexStringNumWarn > MAX_HEX_STRING_NUM_WARN) {
1154       // Limit the number of warning messages printed for a `this.getHexString`
1155       // invocation, since corrupt PDF documents may otherwise spam the console
1156       // enough to affect general performance negatively.
1157       return;
1158     }
1159     warn(`getHexString - ignoring invalid character: ${ch}`);
1160   }
1161 
1162   getHexString() {
1163     const strBuf = this.strBuf;
1164     strBuf.length = 0;
1165     let ch = this.currentChar;
1166     let firstDigit = -1,
1167       digit = -1;
1168     this._hexStringNumWarn = 0;
1169 
1170     while (true) {
1171       if (ch < 0) {
1172         warn("Unterminated hex string");
1173         break;
1174       } else if (ch === /* '>' = */ 0x3e) {
1175         this.nextChar();
1176         break;
1177       } else if (specialChars[ch] === 1) {
1178         ch = this.nextChar();
1179         continue;
1180       } else {
1181         digit = toHexDigit(ch);
1182         if (digit === -1) {
1183           this._hexStringWarn(ch);
1184         } else if (firstDigit === -1) {
1185           firstDigit = digit;
1186         } else {
1187           strBuf.push(String.fromCharCode((firstDigit << 4) | digit));
1188           firstDigit = -1;
1189         }
1190         ch = this.nextChar();
1191       }
1192     }
1193 
1194     // According to the PDF spec, section "7.3.4.3 Hexadecimal Strings":
1195     //  "If the final digit of a hexadecimal string is missing—that is, if there
1196     //   is an odd number of digits—the final digit shall be assumed to be 0."
1197     if (firstDigit !== -1) {
1198       strBuf.push(String.fromCharCode(firstDigit << 4));
1199     }
1200     return strBuf.join("");
1201   }
1202 
1203   getObj() {
1204     // Skip whitespace and comments.
1205     let comment = false;
1206     let ch = this.currentChar;
1207     while (true) {
1208       if (ch < 0) {
1209         return EOF;
1210       }
1211       if (comment) {
1212         if (ch === /* LF = */ 0x0a || ch === /* CR = */ 0x0d) {
1213           comment = false;
1214         }
1215       } else if (ch === /* '%' = */ 0x25) {
1216         comment = true;
1217       } else if (specialChars[ch] !== 1) {
1218         break;
1219       }
1220       ch = this.nextChar();
1221     }
1222 
1223     // Start reading a token.
1224     switch (ch | 0) {
1225       case 0x30: // '0'
1226       case 0x31: // '1'
1227       case 0x32: // '2'
1228       case 0x33: // '3'
1229       case 0x34: // '4'
1230       case 0x35: // '5'
1231       case 0x36: // '6'
1232       case 0x37: // '7'
1233       case 0x38: // '8'
1234       case 0x39: // '9'
1235       case 0x2b: // '+'
1236       case 0x2d: // '-'
1237       case 0x2e: // '.'
1238         return this.getNumber();
1239       case 0x28: // '('
1240         return this.getString();
1241       case 0x2f: // '/'
1242         return this.getName();
1243       // array punctuation
1244       case 0x5b: // '['
1245         this.nextChar();
1246         return Cmd.get("[");
1247       case 0x5d: // ']'
1248         this.nextChar();
1249         return Cmd.get("]");
1250       // hex string or dict punctuation
1251       case 0x3c: // '<'
1252         ch = this.nextChar();
1253         if (ch === 0x3c) {
1254           // dict punctuation
1255           this.nextChar();
1256           return Cmd.get("<<");
1257         }
1258         return this.getHexString();
1259       // dict punctuation
1260       case 0x3e: // '>'
1261         ch = this.nextChar();
1262         if (ch === 0x3e) {
1263           this.nextChar();
1264           return Cmd.get(">>");
1265         }
1266         return Cmd.get(">");
1267       case 0x7b: // '{'
1268         this.nextChar();
1269         return Cmd.get("{");
1270       case 0x7d: // '}'
1271         this.nextChar();
1272         return Cmd.get("}");
1273       case 0x29: // ')'
1274         // Consume the current character in order to avoid permanently hanging
1275         // the worker thread if `Lexer.getObj` is called from within a loop
1276         // containing try-catch statements, since we would otherwise attempt
1277         // to parse the *same* character over and over (fixes issue8061.pdf).
1278         this.nextChar();
1279         throw new FormatError(`Illegal character: ${ch}`);
1280     }
1281 
1282     // Start reading a command.
1283     let str = String.fromCharCode(ch);
1284     // A valid command cannot start with a non-visible ASCII character,
1285     // and the next character may be (the start of) a valid command.
1286     if (ch < 0x20 || ch > 0x7f) {
1287       const nextCh = this.peekChar();
1288       if (nextCh >= 0x20 && nextCh <= 0x7f) {
1289         this.nextChar();
1290         return Cmd.get(str);
1291       }
1292     }
1293     const knownCommands = this.knownCommands;
1294     let knownCommandFound = knownCommands?.[str] !== undefined;
1295     while ((ch = this.nextChar()) >= 0 && !specialChars[ch]) {
1296       // Stop if a known command is found and next character does not make
1297       // the string a command.
1298       const possibleCommand = str + String.fromCharCode(ch);
1299       if (knownCommandFound && knownCommands[possibleCommand] === undefined) {
1300         break;
1301       }
1302       if (str.length === 128) {
1303         throw new FormatError(`Command token too long: ${str.length}`);
1304       }
1305       str = possibleCommand;
1306       knownCommandFound = knownCommands?.[str] !== undefined;
1307     }
1308     if (str === "true") {
1309       return true;
1310     }
1311     if (str === "false") {
1312       return false;
1313     }
1314     if (str === "null") {
1315       return null;
1316     }
1317 
1318     if (str === "BI") {
1319       // Keep track of the current stream position, since it's needed in order
1320       // to correctly cache inline images; see `Parser.makeInlineImage`.
1321       this.beginInlineImagePos = this.stream.pos;
1322     }
1323 
1324     return Cmd.get(str);
1325   }
1326 
1327   skipToNextLine() {
1328     let ch = this.currentChar;
1329     while (ch >= 0) {
1330       if (ch === /* CR = */ 0x0d) {
1331         ch = this.nextChar();
1332         if (ch === /* LF = */ 0x0a) {
1333           this.nextChar();
1334         }
1335         break;
1336       } else if (ch === /* LF = */ 0x0a) {
1337         this.nextChar();
1338         break;
1339       }
1340       ch = this.nextChar();
1341     }
1342   }
1343 }
1344 
1345 class Linearization {
1346   static create(stream) {
1347     function getInt(linDict, name, allowZeroValue = false) {
1348       const obj = linDict.get(name);
1349       if (Number.isInteger(obj) && (allowZeroValue ? obj >= 0 : obj > 0)) {
1350         return obj;
1351       }
1352       throw new Error(
1353         `The "${name}" parameter in the linearization ` +
1354           "dictionary is invalid."
1355       );
1356     }
1357 
1358     function getHints(linDict) {
1359       const hints = linDict.get("H");
1360       let hintsLength;
1361 
1362       if (
1363         Array.isArray(hints) &&
1364         ((hintsLength = hints.length) === 2 || hintsLength === 4)
1365       ) {
1366         for (let index = 0; index < hintsLength; index++) {
1367           const hint = hints[index];
1368           if (!(Number.isInteger(hint) && hint > 0)) {
1369             throw new Error(
1370               `Hint (${index}) in the linearization dictionary is invalid.`
1371             );
1372           }
1373         }
1374         return hints;
1375       }
1376       throw new Error("Hint array in the linearization dictionary is invalid.");
1377     }
1378 
1379     const parser = new Parser({
1380       lexer: new Lexer(stream),
1381       xref: null,
1382     });
1383     const obj1 = parser.getObj();
1384     const obj2 = parser.getObj();
1385     const obj3 = parser.getObj();
1386     const linDict = parser.getObj();
1387     let obj, length;
1388     if (
1389       !(
1390         Number.isInteger(obj1) &&
1391         Number.isInteger(obj2) &&
1392         isCmd(obj3, "obj") &&
1393         linDict instanceof Dict &&
1394         typeof (obj = linDict.get("Linearized")) === "number" &&
1395         obj > 0
1396       )
1397     ) {
1398       return null; // No valid linearization dictionary found.
1399     } else if ((length = getInt(linDict, "L")) !== stream.length) {
1400       throw new Error(
1401         'The "L" parameter in the linearization dictionary ' +
1402           "does not equal the stream length."
1403       );
1404     }
1405     return {
1406       length,
1407       hints: getHints(linDict),
1408       objectNumberFirst: getInt(linDict, "O"),
1409       endFirst: getInt(linDict, "E"),
1410       numPages: getInt(linDict, "N"),
1411       mainXRefEntriesOffset: getInt(linDict, "T"),
1412       pageFirst: linDict.has("P")
1413         ? getInt(linDict, "P", /* allowZeroValue = */ true)
1414         : 0,
1415     };
1416   }
1417 }
1418 
1419 export { Lexer, Linearization, Parser };
</code>

Test file:
<test_file>
File:
test/unit/parser_spec.js
/* Copyright 2017 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import { Cmd, EOF, Name } from "../../src/core/primitives.js";
import { Lexer, Linearization, Parser } from "../../src/core/parser.js";
import { FormatError } from "../../src/shared/util.js";
import { StringStream } from "../../src/core/stream.js";
</test_file>

Your task:
You are a software tester at pdf.js.
1. Examine the existing test file. You may reuse any imports, helpers or setup blocks it already has.
2. Write exactly one javascript test `it("...", async () => {...})` block.
3. Your test must fail on the code before the patch, and pass after, hence the test will verify that the patch resolves the issue.
4. The test must be self-contained and to-the-point.
5. If you need something new use only the provided imports (respect the paths exactly how they are given) by importing dynamically for compatibility with Node.js — no new dependencies. You can use the PDF file for testing as follows:
const { getDocument } = await import('../../src/display/api.js');
const { buildGetDocumentParams } = await import('./test_utils.js');
const loadingTask = getDocument(buildGetDocumentParams('issue19494.pdf'))
6. Return only the javascript code for the new `it(...)` block (no comments or explanations).

Example structure:
it("should <describe behavior>", async () => {
  const { example } = await import("../../src/core/example.js");
  <initialize required variables>;
  <define expected variable>;
  <generate actual variables>;
  <compare expected with actual>;
});

