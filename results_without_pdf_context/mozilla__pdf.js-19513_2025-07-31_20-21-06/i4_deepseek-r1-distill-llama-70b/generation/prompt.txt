Before you begin:
- Keep going until the job is completely solved — don’t stop halfway.
- If you’re unsure about the behavior, reread the provided patch carefully; do not hallucinate.
- Plan your approach before writing code by reflecting on whether the test truly fails before and passes after.

Issue:
<issue>
[Bug]: PDF missing content
### Attach (recommended) or Link to PDF file

[geht_nicht_02.pdf](https://github.com/user-attachments/files/18841919/geht_nicht_02.pdf)

### Web browser and its version

Google Chrome 133.0.6943.99

### Operating system and its version

Windows 11 Pro 24H2

### PDF.js version

4.8.69

### Is the bug present in the latest PDF.js version?

Yes

### Is a browser extension

No

### Steps to reproduce the problem

1. Open the pdf

### What is the expected behavior?

![Image](https://github.com/user-attachments/assets/d0f9073d-cf2c-4b20-801f-5acb55cb3680)

### What went wrong?

![Image](https://github.com/user-attachments/assets/00ab0e7f-37af-46fc-a38a-610d44957d75)

### Link to a viewer

_No response_

### Additional context

_No response_
</issue>

Patch:
<patch>
diff --git a/src/core/xref.js b/src/core/xref.js
--- a/src/core/xref.js
+++ b/src/core/xref.js
@@ -842,7 +842,6 @@ class XRef {
 
     if (xrefEntry === null) {
       // The referenced entry can be free.
-      this._cacheMap.set(num, xrefEntry);
       return xrefEntry;
     }
     // Prevent circular references, in corrupt PDF documents, from hanging the


</patch>

Imports:
<imports>
Available Packages
Dev Dependencies:
- @babel/core: ^7.26.8
- @babel/preset-env: ^7.26.8
- @babel/runtime: ^7.26.7
- @fluent/bundle: ^0.18.0
- @fluent/dom: ^0.10.0
- @metalsmith/layouts: ^2.7.0
- @metalsmith/markdown: ^1.10.0
- @napi-rs/canvas: ^0.1.67
- @types/node: ^22.13.1
- autoprefixer: ^10.4.20
- babel-loader: ^9.2.1
- caniuse-lite: ^1.0.30001699
- core-js: ^3.40.0
- eslint: ^9.20.0
- eslint-plugin-import: ^2.31.0
- eslint-plugin-jasmine: ^4.2.2
- eslint-plugin-json: ^4.0.1
- eslint-plugin-no-unsanitized: ^4.1.2
- eslint-plugin-perfectionist: ^4.8.0
- eslint-plugin-prettier: ^5.2.3
- eslint-plugin-unicorn: ^56.0.1
- globals: ^15.14.0
- gulp: ^5.0.0
- gulp-cli: ^3.0.0
- gulp-postcss: ^10.0.0
- gulp-rename: ^2.0.0
- gulp-replace: ^1.1.4
- gulp-zip: ^6.1.0
- highlight.js: ^11.11.1
- jasmine: ^5.6.0
- jsdoc: ^4.0.4
- jstransformer-nunjucks: ^1.2.0
- metalsmith: ^2.6.3
- metalsmith-html-relative: ^2.0.6
- ordered-read-streams: ^2.0.0
- pngjs: ^7.0.0
- postcss: ^8.5.1
- postcss-dark-theme-class: ^1.3.0
- postcss-dir-pseudo-class: ^9.0.1
- postcss-discard-comments: ^7.0.3
- postcss-nesting: ^13.0.1
- prettier: ^3.5.0
- puppeteer: ^24.2.0
- stylelint: ^16.14.1
- stylelint-prettier: ^5.0.3
- svglint: ^3.1.0
- terser-webpack-plugin: ^5.3.11
- tsc-alias: ^1.8.10
- ttest: ^4.0.0
- typescript: ^5.7.3
- vinyl: ^3.0.0
- webpack: ^5.97.1
- webpack-stream: ^7.0.0
- yargs: ^17.7.2

Engines:
- node: >=20

Available Relative Imports:
- `../../src/core/annotation.js`: Annotation, AnnotationBorderStyle, AnnotationFactory, MarkupAnnotation, getQuadPoints
- `../../src/core/bidi.js`: bidi
- `../../src/core/cff_parser.js`: CFFCharset, CFFCompiler, CFFFDSelect, CFFParser, CFFStrings
- `../../src/core/cmap.js`: CMap, CMapFactory, IdentityCMap
- `../../src/core/colorspace.js`: ColorSpace
- `../../src/core/core_utils.js`: arrayBuffersToBytes, encodeToXmlString, escapePDFName, escapeString, getInheritableProperty, getSizeInBytes, isAscii, isWhiteSpace, log2, numberToString, parseXFAPath, recoverJsURL, stringToUTF16HexString, stringToUTF16String, toRomanNumerals, validateCSSFont
- `../../src/core/crypto.js`: AES128Cipher, AES256Cipher, ARCFourCipher, CipherTransformFactory, PDF17, PDF20, calculateMD5, calculateSHA256, calculateSHA384, calculateSHA512
- `../../src/core/default_appearance.js`: createDefaultAppearance, parseAppearanceStream, parseDefaultAppearance
- `../../src/core/document.js`: PDFDocument, Page
- `../../src/core/encodings.js`: getEncoding
- `../../src/core/evaluator.js`: PartialEvaluator
- `../../src/core/flate_stream.js`: FlateStream
- `../../src/core/font_substitutions.js`: getFontSubstitution
- `../../src/core/fonts_utils.js`: SEAC_ANALYSIS_ENABLED
- `../../src/core/function.js`: PDFFunctionFactory, PostScriptCompiler, PostScriptEvaluator
- `../../src/core/glyphlist.js`: getDingbatsGlyphsUnicode, getGlyphsUnicode
- `../../src/core/image_utils.js`: GlobalImageCache, LocalColorSpaceCache
- `../../src/core/jbig2.js`: Jbig2Error, Jbig2Image
- `../../src/core/jpg.js`: JpegError, JpegImage
- `../../src/core/jpx.js`: JpxError, JpxImage
- `../../src/core/metadata_parser.js`: MetadataParser
- `../../src/core/operator_list.js`: OperatorList
- `../../src/core/parser.js`: Lexer, Linearization, Parser
- `../../src/core/predictor_stream.js`: PredictorStream
- `../../src/core/primitives.js`: Cmd, Dict, EOF, Name, Ref, RefSet, RefSetCache, isCmd, isDict, isName, isRefsEqual
- `../../src/core/ps_parser.js`: PostScriptLexer, PostScriptParser
- `../../src/core/stream.js`: NullStream, Stream, StringStream
- `../../src/core/type1_parser.js`: Type1Parser
- `../../src/core/unicode.js`: getCharUnicodeCategory, getUnicodeForGlyph, getUnicodeRangeFor, mapSpecialUnicodeValues
- `../../src/core/worker.js`: WorkerMessageHandler, WorkerTask
- `../../src/core/writer.js`: incrementalUpdate, writeChanges, writeDict
- `../../src/core/xfa/bind.js`: Binder
- `../../src/core/xfa/data.js`: DataHandler
- `../../src/core/xfa/factory.js`: XFAFactory
- `../../src/core/xfa/formcalc_lexer.js`: Lexer, TOKEN, Token
- `../../src/core/xfa/formcalc_parser.js`: Errors, Parser
- `../../src/core/xfa/parser.js`: XFAParser
- `../../src/core/xfa/som.js`: searchNode
- `../../src/core/xfa/symbol_utils.js`: $dump, $getChildren, $getChildrenByClass, $getChildrenByName, $text, $uid
- `../../src/core/xml_parser.js`: SimpleXMLParser, XMLParserBase
- `../../src/display/annotation_layer.js`: AnnotationLayer
- `../../src/display/annotation_storage.js`: AnnotationStorage
- `../../src/display/api.js`: LoopbackPort, PDFDataRangeTransport, PDFDocumentLoadingTask, PDFDocumentProxy, PDFPageProxy, PDFWorker, RenderTask, build, getDocument, version
- `../../src/display/canvas_factory.js`: DOMCanvasFactory
- `../../src/display/cmap_reader_factory.js`: DOMCMapReaderFactory
- `../../src/display/display_utils.js`: OutputScale, PDFDateString, PageViewport, PixelsPerInch, RenderingCancelledException, StatTimer, SupportedImageMimeTypes, fetchData, getFilenameFromUrl, getPdfFilenameFromUrl, getXfaPageViewport, isDataScheme, isPdfFile, isValidFetchUrl, noContextMenu, setLayerDimensions, stopEvent
- `../../src/display/draw_layer.js`: DrawLayer
- `../../src/display/editor/annotation_editor_layer.js`: AnnotationEditorLayer
- `../../src/display/editor/color_picker.js`: ColorPicker
- `../../src/display/editor/drawers/signaturedraw.js`: SignatureExtractor
- `../../src/display/editor/tools.js`: AnnotationEditorUIManager, CommandManager
- `../../src/display/fetch_stream.js`: PDFFetchStream
- `../../src/display/metadata.js`: Metadata
- `../../src/display/network.js`: PDFNetworkStream
- `../../src/display/network_utils.js`: createHeaders, createResponseError, extractFilenameFromHeader, validateRangeRequestCapabilities, validateResponseStatus
- `../../src/display/node_stream.js`: PDFNodeStream
- `../../src/display/node_utils.js`: NodeCMapReaderFactory, NodeStandardFontDataFactory, fetchData
- `../../src/display/standard_fontdata_factory.js`: DOMStandardFontDataFactory
- `../../src/display/svg_factory.js`: DOMSVGFactory
- `../../src/display/text_layer.js`: TextLayer
- `../../src/display/touch_manager.js`: TouchManager
- `../../src/display/worker_options.js`: GlobalWorkerOptions
- `../../src/display/xfa_layer.js`: XfaLayer
- `../../src/shared/message_handler.js`: MessageHandler
- `../../src/shared/murmurhash3.js`: MurmurHash3_64
- `../../src/shared/util.js`: AbortException, AnnotationBorderStyleType, AnnotationEditorParamsType, AnnotationEditorType, AnnotationFieldFlag, AnnotationFlag, AnnotationMode, AnnotationType, BaseException, FeatureTest, FormatError, ImageKind, InvalidPDFException, OPS, PasswordException, PasswordResponses, PermissionFlag, RenderingIntentFlag, ResponseException, UnknownErrorException, Util, VerbosityLevel, assert, bytesToString, createValidAbsoluteUrl, getModificationDate, getUuid, getVerbosityLevel, isNodeJS, normalizeUnicode, objectSize, setVerbosityLevel, shadow, string32, stringToBytes, stringToPDFString, stringToUTF8String, toBase64Util
- `../../web/annotation_layer_builder.js`: AnnotationLayerBuilder
- `../../web/app_options.js`: AppOptions, OptionKind
- `../../web/autolinker.js`: Autolinker
- `../../web/download_manager.js`: DownloadManager
- `../../web/event_utils.js`: EventBus, WaitOnType, waitOnEventOrTimeout
- `../../web/genericl10n.js`: GenericL10n
- `../../web/pdf_find_controller.js`: FindState, PDFFindController
- `../../web/pdf_find_utils.js`: CharacterType, getCharacterType
- `../../web/pdf_history.js`: PDFHistory, isDestArraysEqual, isDestHashesEqual
- `../../web/pdf_link_service.js`: LinkTarget, PDFLinkService, SimpleLinkService
- `../../web/pdf_page_view.js`: PDFPageView
- `../../web/pdf_scripting_manager.component.js`: PDFScriptingManager
- `../../web/pdf_single_page_viewer.js`: PDFSinglePageViewer
- `../../web/pdf_viewer.js`: PDFPageViewBuffer, PDFViewer
- `../../web/struct_tree_layer_builder.js`: StructTreeLayerBuilder
- `../../web/text_layer_builder.js`: TextLayerBuilder
- `../../web/ui_utils.js`: AutoPrintRegExp, ProgressBar, RenderingStates, ScrollMode, SpreadMode, backtrackBeforeAllVisibleElements, binarySearchFirstItem, calcRound, getPageSizeInches, getVisibleElements, isPortraitOrientation, isValidRotation, parseQueryString, removeNullCharacters
- `../../web/xfa_layer_builder.js`: XfaLayerBuilder
- `../reporter.js`: TestReporter
- `./common_pdfstream_tests.js`: testCrossOriginRedirects
- `./test_utils.js`: CMAP_URL, DefaultCMapReaderFactory, DefaultFileReaderFactory, DefaultStandardFontDataFactory, STANDARD_FONT_DATA_URL, TEST_PDFS_PATH, TestPdfsServer, XRefMock, buildGetDocumentParams, createIdFactory, getCrossOriginHostname
</imports>

Code:
<code>
File:
src/core/xref.js
1 /* Copyright 2021 Mozilla Foundation
2  *
3  * Licensed under the Apache License, Version 2.0 (the "License");
4  * you may not use this file except in compliance with the License.
5  * You may obtain a copy of the License at
6  *
7  *     http://www.apache.org/licenses/LICENSE-2.0
8  *
9  * Unless required by applicable law or agreed to in writing, software
10  * distributed under the License is distributed on an "AS IS" BASIS,
11  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
12  * See the License for the specific language governing permissions and
13  * limitations under the License.
14  */
15 
16 import {
17   assert,
18   bytesToString,
19   FormatError,
20   info,
21   InvalidPDFException,
22   warn,
23 } from "../shared/util.js";
24 import { CIRCULAR_REF, Cmd, Dict, isCmd, Ref, RefSet } from "./primitives.js";
25 import { Lexer, Parser } from "./parser.js";
26 import {
27   MissingDataException,
28   ParserEOFException,
29   XRefEntryException,
30   XRefParseException,
31 } from "./core_utils.js";
32 import { BaseStream } from "./base_stream.js";
33 import { CipherTransformFactory } from "./crypto.js";
34 
35 class XRef {
36   #firstXRefStmPos = null;
37 
38   constructor(stream, pdfManager) {
39     this.stream = stream;
40     this.pdfManager = pdfManager;
41     this.entries = [];
42     this._xrefStms = new Set();
43     this._cacheMap = new Map(); // Prepare the XRef cache.
44     this._pendingRefs = new RefSet();
45     this._newPersistentRefNum = null;
46     this._newTemporaryRefNum = null;
47     this._persistentRefsCache = null;
48   }
49 
50   getNewPersistentRef(obj) {
51     // When printing we don't care that much about the ref number by itself, it
52     // can increase for ever and it allows to keep some re-usable refs.
53     if (this._newPersistentRefNum === null) {
54       this._newPersistentRefNum = this.entries.length || 1;
55     }
56     const num = this._newPersistentRefNum++;
57     this._cacheMap.set(num, obj);
58     return Ref.get(num, 0);
59   }
60 
61   getNewTemporaryRef() {
62     // When saving we want to have some minimal numbers.
63     // Those refs are only created in order to be written in the final pdf
64     // stream.
65     if (this._newTemporaryRefNum === null) {
66       this._newTemporaryRefNum = this.entries.length || 1;
67       if (this._newPersistentRefNum) {
68         this._persistentRefsCache = new Map();
69         for (
70           let i = this._newTemporaryRefNum;
71           i < this._newPersistentRefNum;
72           i++
73         ) {
74           // We *temporarily* clear the cache, see `resetNewTemporaryRef` below,
75           // to avoid any conflict with the refs created during saving.
76           this._persistentRefsCache.set(i, this._cacheMap.get(i));
77           this._cacheMap.delete(i);
78         }
79       }
80     }
81     return Ref.get(this._newTemporaryRefNum++, 0);
82   }
83 
84   resetNewTemporaryRef() {
85     // Called once saving is finished.
86     this._newTemporaryRefNum = null;
87     if (this._persistentRefsCache) {
88       for (const [num, obj] of this._persistentRefsCache) {
89         this._cacheMap.set(num, obj);
90       }
91     }
92     this._persistentRefsCache = null;
93   }
94 
95   setStartXRef(startXRef) {
96     // Store the starting positions of xref tables as we process them
97     // so we can recover from missing data errors
98     this.startXRefQueue = [startXRef];
99   }
100 
101   parse(recoveryMode = false) {
102     let trailerDict;
103     if (!recoveryMode) {
104       trailerDict = this.readXRef();
105     } else {
106       warn("Indexing all PDF objects");
107       trailerDict = this.indexObjects();
108     }
109     trailerDict.assignXref(this);
110     this.trailer = trailerDict;
111 
112     let encrypt;
113     try {
114       encrypt = trailerDict.get("Encrypt");
115     } catch (ex) {
116       if (ex instanceof MissingDataException) {
117         throw ex;
118       }
119       warn(`XRef.parse - Invalid "Encrypt" reference: "${ex}".`);
120     }
121     if (encrypt instanceof Dict) {
122       const ids = trailerDict.get("ID");
123       const fileId = ids?.length ? ids[0] : "";
124       // The 'Encrypt' dictionary itself should not be encrypted, and by
125       // setting `suppressEncryption` we can prevent an infinite loop inside
126       // of `XRef_fetchUncompressed` if the dictionary contains indirect
127       // objects (fixes issue7665.pdf).
128       encrypt.suppressEncryption = true;
129       this.encrypt = new CipherTransformFactory(
130         encrypt,
131         fileId,
132         this.pdfManager.password
133       );
134     }
135 
136     // Get the root dictionary (catalog) object, and do some basic validation.
137     let root;
138     try {
139       root = trailerDict.get("Root");
140     } catch (ex) {
141       if (ex instanceof MissingDataException) {
142         throw ex;
143       }
144       warn(`XRef.parse - Invalid "Root" reference: "${ex}".`);
145     }
146     if (root instanceof Dict) {
147       try {
148         const pages = root.get("Pages");
149         if (pages instanceof Dict) {
150           this.root = root;
151           return;
152         }
153       } catch (ex) {
154         if (ex instanceof MissingDataException) {
155           throw ex;
156         }
157         warn(`XRef.parse - Invalid "Pages" reference: "${ex}".`);
158       }
159     }
160 
161     if (!recoveryMode) {
162       throw new XRefParseException();
163     }
164     // Even recovery failed, there's nothing more we can do here.
165     throw new InvalidPDFException("Invalid Root reference.");
166   }
167 
168   processXRefTable(parser) {
169     if (!("tableState" in this)) {
170       // Stores state of the table as we process it so we can resume
171       // from middle of table in case of missing data error
172       this.tableState = {
173         entryNum: 0,
174         streamPos: parser.lexer.stream.pos,
175         parserBuf1: parser.buf1,
176         parserBuf2: parser.buf2,
177       };
178     }
179 
180     const obj = this.readXRefTable(parser);
181 
182     // Sanity check
183     if (!isCmd(obj, "trailer")) {
184       throw new FormatError(
185         "Invalid XRef table: could not find trailer dictionary"
186       );
187     }
188     // Read trailer dictionary, e.g.
189     // trailer
190     //    << /Size 22
191     //      /Root 20R
192     //      /Info 10R
193     //      /ID [ <81b14aafa313db63dbd6f981e49f94f4> ]
194     //    >>
195     // The parser goes through the entire stream << ... >> and provides
196     // a getter interface for the key-value table
197     let dict = parser.getObj();
198 
199     // The pdflib PDF generator can generate a nested trailer dictionary
200     if (!(dict instanceof Dict) && dict.dict) {
201       dict = dict.dict;
202     }
203     if (!(dict instanceof Dict)) {
204       throw new FormatError(
205         "Invalid XRef table: could not parse trailer dictionary"
206       );
207     }
208     delete this.tableState;
209 
210     return dict;
211   }
212 
213   readXRefTable(parser) {
214     // Example of cross-reference table:
215     // xref
216     // 0 1                    <-- subsection header (first obj #, obj count)
217     // 0000000000 65535 f     <-- actual object (offset, generation #, f/n)
218     // 23 2                   <-- subsection header ... and so on ...
219     // 0000025518 00002 n
220     // 0000025635 00000 n
221     // trailer
222     // ...
223 
224     const stream = parser.lexer.stream;
225     const tableState = this.tableState;
226     stream.pos = tableState.streamPos;
227     parser.buf1 = tableState.parserBuf1;
228     parser.buf2 = tableState.parserBuf2;
229 
230     // Outer loop is over subsection headers
231     let obj;
232 
233     while (true) {
234       if (!("firstEntryNum" in tableState) || !("entryCount" in tableState)) {
235         if (isCmd((obj = parser.getObj()), "trailer")) {
236           break;
237         }
238         tableState.firstEntryNum = obj;
239         tableState.entryCount = parser.getObj();
240       }
241 
242       let first = tableState.firstEntryNum;
243       const count = tableState.entryCount;
244       if (!Number.isInteger(first) || !Number.isInteger(count)) {
245         throw new FormatError(
246           "Invalid XRef table: wrong types in subsection header"
247         );
248       }
249       // Inner loop is over objects themselves
250       for (let i = tableState.entryNum; i < count; i++) {
251         tableState.streamPos = stream.pos;
252         tableState.entryNum = i;
253         tableState.parserBuf1 = parser.buf1;
254         tableState.parserBuf2 = parser.buf2;
255 
256         const entry = {};
257         entry.offset = parser.getObj();
258         entry.gen = parser.getObj();
259         const type = parser.getObj();
260 
261         if (type instanceof Cmd) {
262           switch (type.cmd) {
263             case "f":
264               entry.free = true;
265               break;
266             case "n":
267               entry.uncompressed = true;
268               break;
269           }
270         }
271 
272         // Validate entry obj
273         if (
274           !Number.isInteger(entry.offset) ||
275           !Number.isInteger(entry.gen) ||
276           !(entry.free || entry.uncompressed)
277         ) {
278           throw new FormatError(
279             `Invalid entry in XRef subsection: ${first}, ${count}`
280           );
281         }
282 
283         // The first xref table entry, i.e. obj 0, should be free. Attempting
284         // to adjust an incorrect first obj # (fixes issue 3248 and 7229).
285         if (i === 0 && entry.free && first === 1) {
286           first = 0;
287         }
288 
289         if (!this.entries[i + first]) {
290           this.entries[i + first] = entry;
291         }
292       }
293 
294       tableState.entryNum = 0;
295       tableState.streamPos = stream.pos;
296       tableState.parserBuf1 = parser.buf1;
297       tableState.parserBuf2 = parser.buf2;
298       delete tableState.firstEntryNum;
299       delete tableState.entryCount;
300     }
301 
302     // Sanity check: as per spec, first object must be free
303     if (this.entries[0] && !this.entries[0].free) {
304       throw new FormatError("Invalid XRef table: unexpected first object");
305     }
306     return obj;
307   }
308 
309   processXRefStream(stream) {
310     if (!("streamState" in this)) {
311       // Stores state of the stream as we process it so we can resume
312       // from middle of stream in case of missing data error
313       const { dict, pos } = stream;
314       const byteWidths = dict.get("W");
315       const range = dict.get("Index") || [0, dict.get("Size")];
316 
317       this.streamState = {
318         entryRanges: range,
319         byteWidths,
320         entryNum: 0,
321         streamPos: pos,
322       };
323     }
324     this.readXRefStream(stream);
325     delete this.streamState;
326 
327     return stream.dict;
328   }
329 
330   readXRefStream(stream) {
331     const streamState = this.streamState;
332     stream.pos = streamState.streamPos;
333 
334     const [typeFieldWidth, offsetFieldWidth, generationFieldWidth] =
335       streamState.byteWidths;
336 
337     const entryRanges = streamState.entryRanges;
338     while (entryRanges.length > 0) {
339       const [first, n] = entryRanges;
340 
341       if (!Number.isInteger(first) || !Number.isInteger(n)) {
342         throw new FormatError(`Invalid XRef range fields: ${first}, ${n}`);
343       }
344       if (
345         !Number.isInteger(typeFieldWidth) ||
346         !Number.isInteger(offsetFieldWidth) ||
347         !Number.isInteger(generationFieldWidth)
348       ) {
349         throw new FormatError(
350           `Invalid XRef entry fields length: ${first}, ${n}`
351         );
352       }
353       for (let i = streamState.entryNum; i < n; ++i) {
354         streamState.entryNum = i;
355         streamState.streamPos = stream.pos;
356 
357         let type = 0,
358           offset = 0,
359           generation = 0;
360         for (let j = 0; j < typeFieldWidth; ++j) {
361           const typeByte = stream.getByte();
362           if (typeByte === -1) {
363             throw new FormatError("Invalid XRef byteWidths 'type'.");
364           }
365           type = (type << 8) | typeByte;
366         }
367         // if type field is absent, its default value is 1
368         if (typeFieldWidth === 0) {
369           type = 1;
370         }
371         for (let j = 0; j < offsetFieldWidth; ++j) {
372           const offsetByte = stream.getByte();
373           if (offsetByte === -1) {
374             throw new FormatError("Invalid XRef byteWidths 'offset'.");
375           }
376           offset = (offset << 8) | offsetByte;
377         }
378         for (let j = 0; j < generationFieldWidth; ++j) {
379           const generationByte = stream.getByte();
380           if (generationByte === -1) {
381             throw new FormatError("Invalid XRef byteWidths 'generation'.");
382           }
383           generation = (generation << 8) | generationByte;
384         }
385         const entry = {};
386         entry.offset = offset;
387         entry.gen = generation;
388         switch (type) {
389           case 0:
390             entry.free = true;
391             break;
392           case 1:
393             entry.uncompressed = true;
394             break;
395           case 2:
396             break;
397           default:
398             throw new FormatError(`Invalid XRef entry type: ${type}`);
399         }
400         if (!this.entries[first + i]) {
401           this.entries[first + i] = entry;
402         }
403       }
404 
405       streamState.entryNum = 0;
406       streamState.streamPos = stream.pos;
407       entryRanges.splice(0, 2);
408     }
409   }
410 
411   indexObjects() {
412     // Simple scan through the PDF content to find objects,
413     // trailers and XRef streams.
414     const TAB = 0x9,
415       LF = 0xa,
416       CR = 0xd,
417       SPACE = 0x20;
418     const PERCENT = 0x25,
419       LT = 0x3c;
420 
421     function readToken(data, offset) {
422       let token = "",
423         ch = data[offset];
424       while (ch !== LF && ch !== CR && ch !== LT) {
425         if (++offset >= data.length) {
426           break;
427         }
428         token += String.fromCharCode(ch);
429         ch = data[offset];
430       }
431       return token;
432     }
433     function skipUntil(data, offset, what) {
434       const length = what.length,
435         dataLength = data.length;
436       let skipped = 0;
437       // finding byte sequence
438       while (offset < dataLength) {
439         let i = 0;
440         while (i < length && data[offset + i] === what[i]) {
441           ++i;
442         }
443         if (i >= length) {
444           break; // sequence found
445         }
446         offset++;
447         skipped++;
448       }
449       return skipped;
450     }
451     const gEndobjRegExp = /\b(endobj|\d+\s+\d+\s+obj|xref|trailer\s*<<)\b/g;
452     const gStartxrefRegExp = /\b(startxref|\d+\s+\d+\s+obj)\b/g;
453     const objRegExp = /^(\d+)\s+(\d+)\s+obj\b/;
454 
455     const trailerBytes = new Uint8Array([116, 114, 97, 105, 108, 101, 114]);
456     const startxrefBytes = new Uint8Array([
457       115, 116, 97, 114, 116, 120, 114, 101, 102,
458     ]);
459     const xrefBytes = new Uint8Array([47, 88, 82, 101, 102]);
460 
461     // Clear out any existing entries, since they may be bogus.
462     this.entries.length = 0;
463     this._cacheMap.clear();
464 
465     const stream = this.stream;
466     stream.pos = 0;
467     const buffer = stream.getBytes(),
468       bufferStr = bytesToString(buffer),
469       length = buffer.length;
470     let position = stream.start;
471     const trailers = [],
472       xrefStms = [];
473     while (position < length) {
474       let ch = buffer[position];
475       if (ch === TAB || ch === LF || ch === CR || ch === SPACE) {
476         ++position;
477         continue;
478       }
479       if (ch === PERCENT) {
480         // %-comment
481         do {
482           ++position;
483           if (position >= length) {
484             break;
485           }
486           ch = buffer[position];
487         } while (ch !== LF && ch !== CR);
488         continue;
489       }
490       const token = readToken(buffer, position);
491       let m;
492       if (
493         token.startsWith("xref") &&
494         (token.length === 4 || /\s/.test(token[4]))
495       ) {
496         position += skipUntil(buffer, position, trailerBytes);
497         trailers.push(position);
498         position += skipUntil(buffer, position, startxrefBytes);
499       } else if ((m = objRegExp.exec(token))) {
500         const num = m[1] | 0,
501           gen = m[2] | 0;
502 
503         const startPos = position + token.length;
504         let contentLength,
505           updateEntries = false;
506         if (!this.entries[num]) {
507           updateEntries = true;
508         } else if (this.entries[num].gen === gen) {
509           // Before overwriting an existing entry, ensure that the new one won't
510           // cause *immediate* errors when it's accessed (fixes issue13783.pdf).
511           try {
512             const parser = new Parser({
513               lexer: new Lexer(stream.makeSubStream(startPos)),
514             });
515             parser.getObj();
516             updateEntries = true;
517           } catch (ex) {
518             if (ex instanceof ParserEOFException) {
519               warn(`indexObjects -- checking object (${token}): "${ex}".`);
520             } else {
521               // The error may come from the `Parser`-instance being initialized
522               // without an `XRef`-instance (we don't have a usable one yet).
523               updateEntries = true;
524             }
525           }
526         }
527         if (updateEntries) {
528           this.entries[num] = {
529             offset: position - stream.start,
530             gen,
531             uncompressed: true,
532           };
533         }
534 
535         // Find the next "obj" string, rather than "endobj", to ensure that
536         // we won't skip over a new 'obj' operator in corrupt files where
537         // 'endobj' operators are missing (fixes issue9105_reduced.pdf).
538         gEndobjRegExp.lastIndex = startPos;
539         const match = gEndobjRegExp.exec(bufferStr);
540 
541         if (match) {
542           const endPos = gEndobjRegExp.lastIndex + 1;
543           contentLength = endPos - position;
544 
545           if (match[1] !== "endobj") {
546             warn(
547               `indexObjects: Found "${match[1]}" inside of another "obj", ` +
548                 'caused by missing "endobj" -- trying to recover.'
549             );
550             contentLength -= match[1].length + 1;
551           }
552         } else {
553           contentLength = length - position;
554         }
555         const content = buffer.subarray(position, position + contentLength);
556 
557         // checking XRef stream suspect
558         // (it shall have '/XRef' and next char is not a letter)
559         const xrefTagOffset = skipUntil(content, 0, xrefBytes);
560         if (xrefTagOffset < contentLength && content[xrefTagOffset + 5] < 64) {
561           xrefStms.push(position - stream.start);
562           this._xrefStms.add(position - stream.start); // Avoid recursion
563         }
564 
565         position += contentLength;
566       } else if (
567         token.startsWith("trailer") &&
568         (token.length === 7 || /\s/.test(token[7]))
569       ) {
570         trailers.push(position);
571 
572         const startPos = position + token.length;
573         let contentLength;
574         // Attempt to handle (some) corrupt documents, where no 'startxref'
575         // operators are present (fixes issue15590.pdf).
576         gStartxrefRegExp.lastIndex = startPos;
577         const match = gStartxrefRegExp.exec(bufferStr);
578 
579         if (match) {
580           const endPos = gStartxrefRegExp.lastIndex + 1;
581           contentLength = endPos - position;
582 
583           if (match[1] !== "startxref") {
584             warn(
585               `indexObjects: Found "${match[1]}" after "trailer", ` +
586                 'caused by missing "startxref" -- trying to recover.'
587             );
588             contentLength -= match[1].length + 1;
589           }
590         } else {
591           contentLength = length - position;
592         }
593         position += contentLength;
594       } else {
595         position += token.length + 1;
596       }
597     }
598     // reading XRef streams
599     for (const xrefStm of xrefStms) {
600       this.startXRefQueue.push(xrefStm);
601       this.readXRef(/* recoveryMode */ true);
602     }
603 
604     const trailerDicts = [];
605     // Pre-parsing the trailers to check if the document is possibly encrypted.
606     let isEncrypted = false;
607     for (const trailer of trailers) {
608       stream.pos = trailer;
609       const parser = new Parser({
610         lexer: new Lexer(stream),
611         xref: this,
612         allowStreams: true,
613         recoveryMode: true,
614       });
615       const obj = parser.getObj();
616       if (!isCmd(obj, "trailer")) {
617         continue;
618       }
619       // read the trailer dictionary
620       const dict = parser.getObj();
621       if (!(dict instanceof Dict)) {
622         continue;
623       }
624       trailerDicts.push(dict);
625 
626       if (dict.has("Encrypt")) {
627         isEncrypted = true;
628       }
629     }
630 
631     // finding main trailer
632     let trailerDict, trailerError;
633     for (const dict of [...trailerDicts, "genFallback", ...trailerDicts]) {
634       if (dict === "genFallback") {
635         if (!trailerError) {
636           break; // No need to fallback if there were no validation errors.
637         }
638         this._generationFallback = true;
639         continue;
640       }
641       // Do some basic validation of the trailer/root dictionary candidate.
642       let validPagesDict = false;
643       try {
644         const rootDict = dict.get("Root");
645         if (!(rootDict instanceof Dict)) {
646           continue;
647         }
648         const pagesDict = rootDict.get("Pages");
649         if (!(pagesDict instanceof Dict)) {
650           continue;
651         }
652         const pagesCount = pagesDict.get("Count");
653         if (Number.isInteger(pagesCount)) {
654           validPagesDict = true;
655         }
656         // The top-level /Pages dictionary isn't obviously corrupt.
657       } catch (ex) {
658         trailerError = ex;
659         continue;
660       }
661       // taking the first one with 'ID'
662       if (
663         validPagesDict &&
664         (!isEncrypted || dict.has("Encrypt")) &&
665         dict.has("ID")
666       ) {
667         return dict;
668       }
669       // The current dictionary is a candidate, but continue searching.
670       trailerDict = dict;
671     }
672     // No trailer with 'ID', taking last one (if exists).
673     if (trailerDict) {
674       return trailerDict;
675     }
676     // No trailer dictionary found, taking the "top"-dictionary (if exists).
677     if (this.topDict) {
678       return this.topDict;
679     }
680 
681     // When no trailer dictionary candidate exists, try picking the first
682     // dictionary that contains a /Root entry (fixes issue18986.pdf).
683     if (!trailerDicts.length) {
684       for (const [num, entry] of this.entries.entries()) {
685         if (!entry) {
686           continue;
687         }
688         const ref = Ref.get(num, entry.gen);
689         let obj;
690 
691         try {
692           obj = this.fetch(ref);
693         } catch {
694           continue;
695         }
696         if (obj instanceof BaseStream) {
697           obj = obj.dict;
698         }
699         if (obj instanceof Dict && obj.has("Root")) {
700           return obj;
701         }
702       }
703     }
704 
705     // nothing helps
706     throw new InvalidPDFException("Invalid PDF structure.");
707   }
708 
709   readXRef(recoveryMode = false) {
710     const stream = this.stream;
711     // Keep track of already parsed XRef tables, to prevent an infinite loop
712     // when parsing corrupt PDF files where e.g. the /Prev entries create a
713     // circular dependency between tables (fixes bug1393476.pdf).
714     const startXRefParsedCache = new Set();
715 
716     while (this.startXRefQueue.length) {
717       try {
718         const startXRef = this.startXRefQueue[0];
719 
720         if (startXRefParsedCache.has(startXRef)) {
721           warn("readXRef - skipping XRef table since it was already parsed.");
722           this.startXRefQueue.shift();
723           continue;
724         }
725         startXRefParsedCache.add(startXRef);
726 
727         stream.pos = startXRef + stream.start;
728 
729         const parser = new Parser({
730           lexer: new Lexer(stream),
731           xref: this,
732           allowStreams: true,
733         });
734         let obj = parser.getObj();
735         let dict;
736 
737         // Get dictionary
738         if (isCmd(obj, "xref")) {
739           // Parse end-of-file XRef
740           dict = this.processXRefTable(parser);
741           if (!this.topDict) {
742             this.topDict = dict;
743           }
744 
745           // Recursively get other XRefs 'XRefStm', if any
746           obj = dict.get("XRefStm");
747           if (Number.isInteger(obj) && !this._xrefStms.has(obj)) {
748             // ignore previously loaded xref streams
749             // (possible infinite recursion)
750             this._xrefStms.add(obj);
751             this.startXRefQueue.push(obj);
752             this.#firstXRefStmPos ??= obj;
753           }
754         } else if (Number.isInteger(obj)) {
755           // Parse in-stream XRef
756           if (
757             !Number.isInteger(parser.getObj()) ||
758             !isCmd(parser.getObj(), "obj") ||
759             !((obj = parser.getObj()) instanceof BaseStream)
760           ) {
761             throw new FormatError("Invalid XRef stream");
762           }
763           dict = this.processXRefStream(obj);
764           if (!this.topDict) {
765             this.topDict = dict;
766           }
767           if (!dict) {
768             throw new FormatError("Failed to read XRef stream");
769           }
770         } else {
771           throw new FormatError("Invalid XRef stream header");
772         }
773 
774         // Recursively get previous dictionary, if any
775         obj = dict.get("Prev");
776         if (Number.isInteger(obj)) {
777           this.startXRefQueue.push(obj);
778         } else if (obj instanceof Ref) {
779           // The spec says Prev must not be a reference, i.e. "/Prev NNN"
780           // This is a fallback for non-compliant PDFs, i.e. "/Prev NNN 0 R"
781           this.startXRefQueue.push(obj.num);
782         }
783       } catch (e) {
784         if (e instanceof MissingDataException) {
785           throw e;
786         }
787         info("(while reading XRef): " + e);
788       }
789       this.startXRefQueue.shift();
790     }
791 
792     if (this.topDict) {
793       return this.topDict;
794     }
795     if (recoveryMode) {
796       return undefined;
797     }
798     throw new XRefParseException();
799   }
800 
801   get lastXRefStreamPos() {
802     return (
803       this.#firstXRefStmPos ??
804       (this._xrefStms.size > 0 ? Math.max(...this._xrefStms) : null)
805     );
806   }
807 
808   getEntry(i) {
809     const xrefEntry = this.entries[i];
810     if (xrefEntry && !xrefEntry.free && xrefEntry.offset) {
811       return xrefEntry;
812     }
813     return null;
814   }
815 
816   fetchIfRef(obj, suppressEncryption = false) {
817     if (obj instanceof Ref) {
818       return this.fetch(obj, suppressEncryption);
819     }
820     return obj;
821   }
822 
823   fetch(ref, suppressEncryption = false) {
824     if (!(ref instanceof Ref)) {
825       throw new Error("ref object is not a reference");
826     }
827     const num = ref.num;
828 
829     // The XRef cache is populated with objects which are obtained through
830     // `Parser.getObj`, and indirectly via `Lexer.getObj`. Neither of these
831     // methods should ever return `undefined` (note the `assert` calls below).
832     const cacheEntry = this._cacheMap.get(num);
833     if (cacheEntry !== undefined) {
834       // In documents with Object Streams, it's possible that cached `Dict`s
835       // have not been assigned an `objId` yet (see e.g. issue3115r.pdf).
836       if (cacheEntry instanceof Dict && !cacheEntry.objId) {
837         cacheEntry.objId = ref.toString();
838       }
839       return cacheEntry;
840     }
841     let xrefEntry = this.getEntry(num);
842 
843     if (xrefEntry === null) {
844       // The referenced entry can be free.
845       this._cacheMap.set(num, xrefEntry);
846       return xrefEntry;
847     }
848     // Prevent circular references, in corrupt PDF documents, from hanging the
849     // worker-thread. This relies, implicitly, on the parsing being synchronous.
850     if (this._pendingRefs.has(ref)) {
851       this._pendingRefs.remove(ref);
852 
853       warn(`Ignoring circular reference: ${ref}.`);
854       return CIRCULAR_REF;
855     }
856     this._pendingRefs.put(ref);
857 
858     try {
859       xrefEntry = xrefEntry.uncompressed
860         ? this.fetchUncompressed(ref, xrefEntry, suppressEncryption)
861         : this.fetchCompressed(ref, xrefEntry, suppressEncryption);
862       this._pendingRefs.remove(ref);
863     } catch (ex) {
864       this._pendingRefs.remove(ref);
865       throw ex;
866     }
867     if (xrefEntry instanceof Dict) {
868       xrefEntry.objId = ref.toString();
869     } else if (xrefEntry instanceof BaseStream) {
870       xrefEntry.dict.objId = ref.toString();
871     }
872     return xrefEntry;
873   }
874 
875   fetchUncompressed(ref, xrefEntry, suppressEncryption = false) {
876     const gen = ref.gen;
877     let num = ref.num;
878     if (xrefEntry.gen !== gen) {
879       const msg = `Inconsistent generation in XRef: ${ref}`;
880       // Try falling back to a *previous* generation (fixes issue15577.pdf).
881       if (this._generationFallback && xrefEntry.gen < gen) {
882         warn(msg);
883         return this.fetchUncompressed(
884           Ref.get(num, xrefEntry.gen),
885           xrefEntry,
886           suppressEncryption
887         );
888       }
889       throw new XRefEntryException(msg);
890     }
891     const stream = this.stream.makeSubStream(
892       xrefEntry.offset + this.stream.start
893     );
894     const parser = new Parser({
895       lexer: new Lexer(stream),
896       xref: this,
897       allowStreams: true,
898     });
899     const obj1 = parser.getObj();
900     const obj2 = parser.getObj();
901     const obj3 = parser.getObj();
902 
903     if (obj1 !== num || obj2 !== gen || !(obj3 instanceof Cmd)) {
904       throw new XRefEntryException(`Bad (uncompressed) XRef entry: ${ref}`);
905     }
906     if (obj3.cmd !== "obj") {
907       // some bad PDFs use "obj1234" and really mean 1234
908       if (obj3.cmd.startsWith("obj")) {
909         num = parseInt(obj3.cmd.substring(3), 10);
910         if (!Number.isNaN(num)) {
911           return num;
912         }
913       }
914       throw new XRefEntryException(`Bad (uncompressed) XRef entry: ${ref}`);
915     }
916     xrefEntry =
917       this.encrypt && !suppressEncryption
918         ? parser.getObj(this.encrypt.createCipherTransform(num, gen))
919         : parser.getObj();
920     if (!(xrefEntry instanceof BaseStream)) {
921       if (typeof PDFJSDev === "undefined" || PDFJSDev.test("TESTING")) {
922         assert(
923           xrefEntry !== undefined,
924           'fetchUncompressed: The "xrefEntry" cannot be undefined.'
925         );
926       }
927       this._cacheMap.set(num, xrefEntry);
928     }
929     return xrefEntry;
930   }
931 
932   fetchCompressed(ref, xrefEntry, suppressEncryption = false) {
933     const tableOffset = xrefEntry.offset;
934     const stream = this.fetch(Ref.get(tableOffset, 0));
935     if (!(stream instanceof BaseStream)) {
936       throw new FormatError("bad ObjStm stream");
937     }
938     const first = stream.dict.get("First");
939     const n = stream.dict.get("N");
940     if (!Number.isInteger(first) || !Number.isInteger(n)) {
941       throw new FormatError("invalid first and n parameters for ObjStm stream");
942     }
943     let parser = new Parser({
944       lexer: new Lexer(stream),
945       xref: this,
946       allowStreams: true,
947     });
948     const nums = new Array(n);
949     const offsets = new Array(n);
950     // read the object numbers to populate cache
951     for (let i = 0; i < n; ++i) {
952       const num = parser.getObj();
953       if (!Number.isInteger(num)) {
954         throw new FormatError(
955           `invalid object number in the ObjStm stream: ${num}`
956         );
957       }
958       const offset = parser.getObj();
959       if (!Number.isInteger(offset)) {
960         throw new FormatError(
961           `invalid object offset in the ObjStm stream: ${offset}`
962         );
963       }
964       nums[i] = num;
965       offsets[i] = offset;
966     }
967 
968     const start = (stream.start || 0) + first;
969     const entries = new Array(n);
970     // read stream objects for cache
971     for (let i = 0; i < n; ++i) {
972       const length = i < n - 1 ? offsets[i + 1] - offsets[i] : undefined;
973       if (length < 0) {
974         throw new FormatError("Invalid offset in the ObjStm stream.");
975       }
976       parser = new Parser({
977         lexer: new Lexer(
978           stream.makeSubStream(start + offsets[i], length, stream.dict)
979         ),
980         xref: this,
981         allowStreams: true,
982       });
983 
984       const obj = parser.getObj();
985       entries[i] = obj;
986       if (obj instanceof BaseStream) {
987         continue;
988       }
989       const num = nums[i],
990         entry = this.entries[num];
991       if (entry && entry.offset === tableOffset && entry.gen === i) {
992         if (typeof PDFJSDev === "undefined" || PDFJSDev.test("TESTING")) {
993           assert(
994             obj !== undefined,
995             'fetchCompressed: The "obj" cannot be undefined.'
996           );
997         }
998         this._cacheMap.set(num, obj);
999       }
1000     }
1001     xrefEntry = entries[xrefEntry.gen];
1002     if (xrefEntry === undefined) {
1003       throw new XRefEntryException(`Bad (compressed) XRef entry: ${ref}`);
1004     }
1005     return xrefEntry;
1006   }
1007 
1008   async fetchIfRefAsync(obj, suppressEncryption) {
1009     if (obj instanceof Ref) {
1010       return this.fetchAsync(obj, suppressEncryption);
1011     }
1012     return obj;
1013   }
1014 
1015   async fetchAsync(ref, suppressEncryption) {
1016     try {
1017       return this.fetch(ref, suppressEncryption);
1018     } catch (ex) {
1019       if (!(ex instanceof MissingDataException)) {
1020         throw ex;
1021       }
1022       await this.pdfManager.requestRange(ex.begin, ex.end);
1023       return this.fetchAsync(ref, suppressEncryption);
1024     }
1025   }
1026 
1027   getCatalogObj() {
1028     return this.root;
1029   }
1030 }
1031 
1032 export { XRef };
</code>

Your task:
You are a software tester at pdf.js.
1. Write exactly one javascript test `it("...", async () => {...})` block.
2. Your test must fail on the code before the patch, and pass after, hence the test will verify that the patch resolves the issue.
3. The test must be self-contained and to-the-point.
4. Use only the provided imports (respect the paths exactly how they are given) by importing dynamically for compatibility with Node.js — no new dependencies. 
5. Return only the javascript code (no comments or explanations).

Example structure:
it("should <describe behavior>", async () => {
  const { example } = await import("../../src/core/example.js");
  <initialize required variables>;
  <define expected variable>;
  <generate actual variables>;
  <compare expected with actual>;
});

