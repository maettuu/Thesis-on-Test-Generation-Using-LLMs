{
  "16686": {
    "i1_deepseek-r1-distill-llama-70b": "it(\"should correctly add SVG image with blob URL\", async () => {\n  const { ImageManager } = await import(\"../../src/display/editor/tools.js\");\n  const svgContent = `<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 100 100\"><rect x=\"10\" y=\"10\" width=\"80\" height=\"80\" fill=\"#ff0000\"/></svg>`;\n  const blob = new Blob([svgContent], { type: \"image/svg+xml\" });\n  const url = URL.createObjectURL(blob);\n\n  const manager = new ImageManager();\n  const data = await manager.get(url, blob);\n\n  expect(data?.bitmap).not.toBeNull();\n});",
    "i1_gpt-4o": "it(\"should add an SVG image with a blob URL\", async () => {\n  const { ImageManager } = await import(\"../../src/display/editor/tools.js\");\n  const svgBlob = new Blob(\n    ['<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"100\" height=\"100\"></svg>'],\n    { type: \"image/svg+xml\" }\n  );\n  const blobUrl = URL.createObjectURL(svgBlob);\n  const imageManager = new ImageManager();\n  const data = await imageManager.#get(blobUrl, svgBlob);\n  expect(data).not.toBeNull();\n  expect(data.isSvg).toBe(true);\n  expect(data.bitmap).toBeInstanceOf(Image);\n  URL.revokeObjectURL(blobUrl);\n});",
    "i1_llama-3.3-70b-versatile": "it(\"should add a SVG image with a blob url\", async () => {\n  const { ImageManager } = await import(\"../../src/display/editor/tools.js\");\n  const imageManager = new ImageManager();\n  const svgBlob = new Blob(['<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"100\" height=\"100\"><rect width=\"100\" height=\"100\" style=\"fill:rgb(0,0,255)\" /></svg>'], {type : 'image/svg+xml'});\n  const key = await imageManager.#get('svg-image', svgBlob);\n  expect(key).not.toBeNull();\n  expect(key.bitmap).not.toBeNull();\n  expect(key.isSvg).toBe(true);\n});",
    "i2_deepseek-r1-distill-llama-70b": "it(\"should load SVG images using data URLs to avoid CSP issues\", async () => {\n  const { ImageManager } = await import(\"../../display/editor/tools.js\");\n  const { Util } = await import(\"../../shared/util.js\");\n\n  const svgContent = \"<svg xmlns=\\\"http://www.w3.org/2000/svg\\\" width=\\\"100\\\" height=\\\"100\\\"><rect width=\\\"100\\\" height=\\\"100\\\" fill=\\\"red\\\"/></svg>\";\n  const blob = new Blob([svgContent], { type: \"image/svg+xml\" });\n  const url = URL.createObjectURL(blob);\n\n  const imageManager = new ImageManager();\n  const data = await imageManager.get(url, blob);\n\n  expect(data.isSvg).toBe(true);\n});",
    "i2_gpt-4o": "it(\"should load an SVG image using a data URL\", async () => {\n  const { ImageManager } = await import(\"../../src/display/editor/tools.js\");\n  const svgBlob = new Blob(\n    [\n      `<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"100\" height=\"100\">\n         <rect width=\"100\" height=\"100\" style=\"fill:blue\"/>\n       </svg>`\n    ],\n    { type: \"image/svg+xml\" }\n  );\n  const imageManager = new ImageManager();\n  const data = await imageManager.#get(\"testSvg\", svgBlob);\n  const expected = true;\n  const actual = data.isSvg;\n  expect(actual).toBe(expected);\n});",
    "i2_llama-3.3-70b-versatile": "it(\"should load SVG image with blob URL\", async () => {\n  const { ImageManager } = await import(\"../../src/display/editor/tools.js\");\n  const imageManager = new ImageManager();\n  const blob = new Blob(['<svg xmlns=\"http://www.w3.org/2000/svg\"></svg>'], { type: 'image/svg+xml' });\n  const url = URL.createObjectURL(blob);\n  const image = await imageManager.#get('test', blob);\n  const expected = true;\n  const actual = image.isSvg;\n  expect(actual).toBe(expected);\n});",
    "i3_deepseek-r1-distill-llama-70b": "it(\"should correctly handle SVG images with blob URLs\", async () => {\n  const svgContent = \"<svg xmlns=\\\"http://www.w3.org/2000/svg\\\"><rect width=\\\"100\\\" height=\\\"100\\\" fill=\\\"red\\\"/></svg>\";\n  const blob = new Blob([svgContent], { type: \"image/svg+xml\" });\n  const url = URL.createObjectURL(blob);\n\n  const { ImageManager } = await import(\"../../src/display/editor/tools.js\");\n  const imageManager = new ImageManager();\n\n  const data = await imageManager.getFromUrl(url);\n\n  expect(data).not.toBeNull();\n  expect(data.isSvg).toBe(true);\n  expect(data.svgUrl).toMatch(svgContent);\n\n  URL.revokeObjectURL(url);\n});",
    "i3_gpt-4o": "it(\"should add a SVG image with a blob url\", async () => {\n  const { ImageManager } = await import(\"../../src/display/editor/tools.js\");\n  const svgBlob = new Blob(['<svg xmlns=\"http://www.w3.org/2000/svg\"></svg>'], { type: \"image/svg+xml\" });\n  const imageManager = new ImageManager();\n  const data = await imageManager.getFromFile(svgBlob);\n  expect(data).not.toBeNull();\n  expect(data.isSvg).toBe(true);\n  expect(data.bitmap).toBeInstanceOf(Image);\n});",
    "i3_llama-3.3-70b-versatile": "it(\"should add a SVG image with a blob url\", async () => {\n  const { ImageManager } = await import(\"../../src/display/editor/tools.js\");\n  const imageManager = new ImageManager();\n  const svgBlob = new Blob(['<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"100\" height=\"100\"><rect width=\"100\" height=\"100\" style=\"fill:rgb(0,0,255);stroke-width:3;stroke:rgb(0,0,0)\" /></svg>'], {type: 'image/svg+xml'});\n  const file = new File([svgBlob], 'image.svg', {type: 'image/svg+xml'});\n  const data = await imageManager.getFromFile(file);\n  expect(data).not.toBeNull();\n  expect(data.bitmap).not.toBeNull();\n  expect(data.isSvg).toBe(true);\n});",
    "i4_deepseek-r1-distill-llama-70b": "it(\"should add SVG image with blob URL\", async () => {\n  const { ImageManager } = await import(\"../../src/display/editor/tools.js\");\n\n  // Create a test SVG\n  const svgString = \"<svg xmlns='http://www.w3.org/2000/svg' width='100' height='100'><rect width='100' height='100' fill='red'/></svg>\";\n  const svgBlob = new Blob([svgString], { type: \"image/svg+xml\" });\n\n  // Create ImageManager instance\n  const imageManager = new ImageManager();\n\n  // Request the image\n  const data = await imageManager.getFromFile(svgBlob);\n\n  // Wait for the image to load\n  await new Promise(resolve => setTimeout(resolve, 100));\n\n  expect(data.bitmap).not.toBeNull();\n});",
    "i4_gpt-4o": "it(\"should add an SVG image with a blob URL\", async () => {\n  const { ImageManager } = await import(\"../../src/display/editor/tools.js\");\n  const svgBlob = new Blob(\n    [\n      `<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"100\" height=\"100\">\n         <circle cx=\"50\" cy=\"50\" r=\"40\" stroke=\"black\" stroke-width=\"3\" fill=\"red\" />\n       </svg>`\n    ],\n    { type: \"image/svg+xml\" }\n  );\n  const imageManager = new ImageManager();\n  const data = await imageManager.getFromFile(svgBlob);\n  const expected = true;\n  const actual = data.isSvg;\n  expect(actual).toBe(expected);\n});",
    "i4_llama-3.3-70b-versatile": "it(\"should add a SVG image with a blob url\", async () => {\n  const { ImageManager } = await import(\"../../src/display/editor/tools.js\");\n  const imageManager = new ImageManager();\n  const svgBlob = new Blob(['<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"100\" height=\"100\"><rect x=\"10\" y=\"10\" width=\"50\" height=\"50\" fill=\"#ff0000\"/></svg>'], { type: 'image/svg+xml' });\n  const url = URL.createObjectURL(svgBlob);\n  const data = await imageManager.getFromUrl(url);\n  expect(data).not.toBeNull();\n  expect(data.bitmap).not.toBeNull();\n  expect(data.isSvg).toBe(true);\n});",
    "i5_deepseek-r1-distill-llama-70b": "it(\"should correctly add SVG images with blob URLs\", async () => {\n  const testSvg = `<svg width=\"100\" height=\"100\"><rect width=\"100\" height=\"100\" fill=\"red\"/></svg>`;\n  const blob = new Blob([testSvg], { type: 'image/svg+xml' });\n  const url = URL.createObjectURL(blob);\n\n  const { ImageManager } = await import(\"../../src/display/editor/tools.js\");\n  const imageManager = new ImageManager();\n  const data = {\n    filename: 'test.svg',\n    type: 'image/svg+xml'\n  };\n\n  await imageManager.addImage(blob, data);\n\n  expect(data.bitmap).toBeInstanceOf(Image);\n  expect(data.isSvg).toBe(true);\n  expect(data.svgUrl).toMatch(/^data:image\\/svg\\+xml/);\n});",
    "i5_gpt-4o": "it(\"should add an SVG image with a blob URL\", async () => {\n  const { ImageManager } = await import(\"../../src/display/editor/tools.js\");\n  const svgBlob = new Blob(['<svg xmlns=\"http://www.w3.org/2000/svg\"></svg>'], { type: 'image/svg+xml' });\n  const imageManager = new ImageManager();\n  const data = {};\n\n  const addSvgImage = async () => {\n    const fileReader = new FileReader();\n    const imageElement = new Image();\n    const imagePromise = new Promise((resolve, reject) => {\n      imageElement.onload = () => {\n        data.bitmap = imageElement;\n        data.isSvg = true;\n        resolve();\n      };\n      fileReader.onload = () => {\n        imageElement.src = data.svgUrl = fileReader.result;\n      };\n      imageElement.onerror = fileReader.onerror = reject;\n    });\n    fileReader.readAsDataURL(svgBlob);\n    await imagePromise;\n  };\n\n  await addSvgImage();\n  expect(data.isSvg).toBe(true);\n  expect(data.bitmap).toBeInstanceOf(Image);\n});",
    "i5_llama-3.3-70b-versatile": "it(\"should add a SVG image with a blob url\", async () => {\n  const { ImageManager } = await import(\"../../src/display/editor/tools.js\");\n  const { createIdFactory } = await import(\"./test_utils.js\");\n  const idFactory = createIdFactory();\n  const imageManager = new ImageManager(idFactory);\n  const svgImage = new Blob([`<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"100\" height=\"100\"><circle cx=\"50\" cy=\"50\" r=\"40\" stroke=\"green\" stroke-width=\"4\" fill=\"yellow\" /></svg>`], { type: 'image/svg+xml' });\n  const data = {};\n  await imageManager.addImage(svgImage, data);\n  expect(data.isSvg).toBe(true);\n  expect(data.bitmap instanceof HTMLImageElement).toBe(true);\n});"
  },
  "16709": {
    "i1_deepseek-r1-distill-llama-70b": "it(\"should redo an annotation using keyboard shortcuts\", async () => {\n  const { PDFDocument } = await import(\"../../src/display/api.js\");\n  const { Annotation, AnnotationFactory, MarkupAnnotation } = \n    await import(\"../../src/core/annotation.js\");\n  const { createIdFactory, XRefMock } = await import(\"./test_utils.js\");\n\n  // Setup PDF document with one page\n  const xref = new XRefMock();\n  const idFactory = createIdFactory();\n  const pdfDocument = new PDFDocument({\n    xref,\n    idFactory,\n    isBase64Encoded: true,\n    isXpdfEnabled: false,\n  });\n  const pageRef = pdfDocument.addPage();\n  const page = pdfDocument.getPage(pageRef);\n\n  // Setup annotation storage and editor manager\n  const container = document.createElement(\"div\");\n  const eventBus = new (await import(\"../../src/shared/message_handler.js\")).MessageHandler();\n  const annotationStorage = pdfDocument.annotationStorage;\n  const editorUIManager = new (await import(\"../../src/display/editor/tools.js\")).AnnotationEditorUIManager(\n    container,\n    eventBus,\n    pdfDocument,\n    new Map()\n  );\n\n  // Create and add an annotation\n  const annotation = AnnotationFactory.create(AnnotationType.MARKUP, {\n    subtype: MarkupAnnotation,\n    points: [0, 0, 50, 50],\n    text: \"Test\",\n  });\n  annotationStorage.addAnnotation(annotation);\n\n  // Perform undo\n  editorUIManager.undo();\n\n  // Check if annotation was removed\n  expect(annotationStorage.getAnnotations().length).toBe(0);\n\n  // Perform redo\n  editorUIManager.redo();\n\n  // Verify annotation was restored\n  expect(annotationStorage.getAnnotations().length).toBe(1);\n});",
    "i1_gpt-4o": "it(\"should redo an added imagetextdrawing to the PDF file using Keyboard shortcuts\", async () => {\n  const { AnnotationEditorUIManager } = await import(\"../../src/display/editor/tools.js\");\n  const eventBus = { _on: () => {} };\n  const pdfDocument = { annotationStorage: {}, filterFactory: {} };\n  const container = {};\n  const pageColors = {};\n  const manager = new AnnotationEditorUIManager(container, eventBus, pdfDocument, pageColors);\n  const keyboardManager = AnnotationEditorUIManager._keyboardManager;\n  const redoShortcut = [\"ctrl+y\", \"ctrl+shift+z\", \"mac+meta+shift+z\", \"ctrl+shift+Z\", \"mac+meta+shift+Z\"];\n  const redoAction = keyboardManager.shortcuts.find(([keys]) => keys.some(key => redoShortcut.includes(key)));\n  const expected = AnnotationEditorUIManager.prototype.redo;\n  const actual = redoAction ? redoAction[1] : null;\n  expect(actual).toBe(expected);\n});",
    "i1_llama-3.3-70b-versatile": "it(\"should redo an added imagetextdrawing to the PDF file using Keyboard shortcuts\", async () => {\n  const { AnnotationEditorUIManager } = await import(\"../../src/display/editor/tools.js\");\n  const { AnnotationEditorUIManager: OriginalAnnotationEditorUIManager } = await import(\"../../src/display/editor/tools_original.js\");\n  const { PDFDocument, Page } = await import(\"../../src/core/document.js\");\n  const { AnnotationStorage } = await import(\"../../src/display/annotation_storage.js\");\n  const { PDFPageProxy } = await import(\"../../src/display/api.js\");\n  const { createIdFactory } = await import(\"./test_utils.js\");\n\n  const pdfDocument = new PDFDocument({\n    annotationStorage: new AnnotationStorage(),\n    filterFactory: null,\n    fingerprint: null,\n  });\n  const page = new Page({\n    pdfDocument,\n    pageIndex: 0,\n    rotate: 0,\n    ref: new Ref(1, 0),\n  });\n  const annotationStorage = pdfDocument.annotationStorage;\n  const filterFactory = null;\n  const pageColors = null;\n  const eventBus = {\n    _on: jest.fn(),\n  };\n  const container = {\n    addEventListener: jest.fn(),\n  };\n\n  const originalEditor = new OriginalAnnotationEditorUIManager(container, eventBus, pdfDocument, pageColors);\n  const patchedEditor = new AnnotationEditorUIManager(container, eventBus, pdfDocument, pageColors);\n\n  const annotation = new MarkupAnnotation({\n    subtype: \"Highlight\",\n    pageIndices: [0],\n    quadPoints: [[10, 10], [20, 10], [20, 20], [10, 20]],\n  });\n  annotationStorage.addAnnotation(annotation);\n\n  originalEditor.keydown({ key: \"y\", ctrlKey: true });\n  patchedEditor.keydown({ key: \"y\", ctrlKey: true });\n  patchedEditor.keydown({ key: \"Z\", ctrlKey: true, shiftKey: true, metaKey: true });\n\n  expect(annotationStorage.getAnnotations().length).toBe(1);\n  expect(patchedEditor.#commandManager.redoStack.length).toBe(1);\n});",
    "i2_deepseek-r1-distill-llama-70b": "it(\"should redo an annotation using metashiftz on mac\", async () => {\n  const { AnnotationEditorUIManager } = await import(\"../../src/display/editor/tools.js\");\n  const { TestReporter } = await import(\"./testreporter.js\");\n\n  const container = document.createElement(\"div\");\n  const pdfDocument = { annotationStorage: { add: () => {}, getAnnotations: () => [] } };\n  const eventBus = { _on: () => {} };\n  const pageColors = {};\n\n  const manager = new AnnotationEditorUIManager(container, eventBus, pdfDocument, pageColors);\n\n  // Create a test annotation\n  const annotation = { id: \"test-annotation\" };\n\n  // Add the annotation\n  manager.addAnnotation(annotation);\n\n  // Undo the action\n  manager.undo();\n\n  // Simulate the redo keyboard event for mac\n  const event = new KeyboardEvent(\"keydown\", {\n    key: \"Z\",\n    keyCode: 90,\n    which: 90,\n    metaKey: true,\n    shiftKey: true,\n    bubbles: true,\n    cancelable: true,\n  });\n\n  container.dispatchEvent(event);\n\n  // Check if the annotation was redone\n  const result = await pdfDocument.annotationStorage.getAnnotations();\n\n  new TestReporter().assert(\n    result.length === 1,\n    \"Redo using meta+shift+z on mac should add the annotation back\"\n  );\n});",
    "i2_gpt-4o": "it(\"should redo an added imagetextdrawing to the PDF file using Keyboard shortcuts\", async () => {\n  const { AnnotationEditorUIManager } = await import(\"../../src/display/editor/tools.js\");\n  const { EventBus } = await import(\"../../web/event_utils.js\");\n\n  const eventBus = new EventBus();\n  const container = document.createElement(\"div\");\n  const pdfDocument = { annotationStorage: {}, filterFactory: {} };\n  const pageColors = null;\n\n  const manager = new AnnotationEditorUIManager(container, eventBus, pdfDocument, pageColors);\n\n  let redoCalled = false;\n  manager.redo = () => {\n    redoCalled = true;\n  };\n\n  const keyboardEvent = new KeyboardEvent(\"keydown\", {\n    key: \"Z\",\n    metaKey: true,\n    shiftKey: true,\n  });\n\n  container.dispatchEvent(keyboardEvent);\n\n  expect(redoCalled).toBe(true);\n});",
    "i2_llama-3.3-70b-versatile": "it(\"should redo an added imagetextdrawing to the PDF file using Keyboard shortcuts\", async () => {\n  const { AnnotationEditorUIManager, KeyboardManager } = await import(\"../../src/display/editor/tools.js\");\n  const { Util } = await import(\"../../shared/util.js\");\n  const eventBus = {\n    _on: jest.fn(),\n  };\n  const pdfDocument = {\n    annotationStorage: {},\n    filterFactory: {},\n  };\n  const pageColors = {};\n  const container = {};\n  const annotationEditorUIManager = new AnnotationEditorUIManager(container, eventBus, pdfDocument, pageColors);\n  const keyboardManager = KeyboardManager;\n  const redoKey = \"mac+meta+shift+Z\";\n  const redoKeyAlternative = \"mac+meta+shift+z\";\n  const expectedRedoAction = annotationEditorUIManager.redo;\n  const actualRedoAction = keyboardManager._keyboardBindings.find(([keys]) => keys.includes(redoKey) || keys.includes(redoKeyAlternative))[1];\n  expect(actualRedoAction).toBe(expectedRedoAction);\n});",
    "i3_deepseek-r1-distill-llama-70b": "it(\"should redo an annotation using the correct keyboard shortcut\", async () => {\n  const { AnnotationEditorUIManager, CommandManager } = await import(\"../../src/display/editor/tools.js\");\n  const { createIdFactory } = await import(\"./test_utils.js\");\n  const { Annotation, MarkupAnnotation } = await import(\"../../src/core/annotation.js\");\n\n  const idFactory = createIdFactory();\n  const mockDoc = {\n    annotationStorage: new Map(),\n    filterFactory: {},\n  };\n  const uiManager = new AnnotationEditorUIManager({\n    addEventListener: () => {},\n    removeEventListener: () => {},\n    focus: () => {},\n  }, {\n    _on: () => {},\n    _off: () => {},\n  }, mockDoc, {});\n\n  const annotation = new MarkupAnnotation({\n    annotationId: idFactory.next().value,\n    type: \"underline\",\n    quads: [],\n  });\n\n  // Initialize editor mode\n  uiManager.updateMode(AnnotationEditorType.FREE_TEXT);\n\n  // Add annotation\n  const cmd = () => {\n    uiManager.currentLayer.addAnnotation(annotation);\n  };\n  const undoCmd = () => {\n    uiManager.currentLayer.removeAnnotation(annotation);\n  };\n\n  uiManager.addCommands({ cmd, undo: undoCmd, mustExec: true });\n\n  // Commit initial state\n  await annotation.commit();\n\n  // Perform undo\n  uiManager.undo();\n\n  // Simulate redo keyboard shortcut\n  const redoEvent = new KeyboardEvent(\"keydown\", {\n    key: \"y\",\n    ctrlKey: true,\n    metaKey: false,\n  });\n  uiManager.keydown(redoEvent);\n\n  // Verify annotation was properly redone\n  expect(mockDoc.annotationStorage.has(annotation.annotationId)).toBe(true);\n});",
    "i3_gpt-4o": "it(\"should redo an added imagetextdrawing to the PDF file using keyboard shortcuts\", async () => {\n  const { AnnotationEditorUIManager } = await import(\"../../src/display/editor/tools.js\");\n  const { EventBus } = await import(\"../../web/event_utils.js\");\n\n  const eventBus = new EventBus();\n  const container = document.createElement(\"div\");\n  const pdfDocument = { annotationStorage: new Map(), filterFactory: {} };\n  const uiManager = new AnnotationEditorUIManager(container, eventBus, pdfDocument, null);\n\n  let redoCalled = false;\n  uiManager.redo = () => {\n    redoCalled = true;\n  };\n\n  const keyboardEvent = new KeyboardEvent(\"keydown\", {\n    key: \"y\",\n    ctrlKey: true,\n  });\n  container.dispatchEvent(keyboardEvent);\n\n  expect(redoCalled).toBe(true);\n});",
    "i3_llama-3.3-70b-versatile": "it(\"should redo an added imagetextdrawing to the PDF file using Keyboard shortcuts\", async () => {\n  const { AnnotationEditorUIManager, CommandManager, KeyboardManager } = await import(\"../../src/display/editor/tools.js\");\n  const { AnnotationEditorType } = await import(\"../../src/shared/util.js\");\n  const annotationEditorUIManager = new AnnotationEditorUIManager(null, null, null, null);\n  annotationEditorUIManager.updateMode(AnnotationEditorType.FREE_TEXT);\n  const editor = { id: 'test', pageIndex: 0, isEmpty: () => false, remove: () => {}, commitOrRemove: () => {} };\n  annotationEditorUIManager.addEditorToLayer(editor);\n  annotationEditorUIManager.setSelected(editor);\n  annotationEditorUIManager.addCommands({ cmd: () => {}, undo: () => {}, mustExec: true });\n  annotationEditorUIManager.undo();\n  const keyboardManager = new KeyboardManager([\n    [[\"ctrl+y\", \"ctrl+shift+Z\", \"mac+meta+shift+Z\", \"ctrl+shift+z\", \"mac+meta+shift+Z\", \"mac+meta+shift+z\"], annotationEditorUIManager.redo],\n  ]);\n  keyboardManager.exec(annotationEditorUIManager, { key: 'y', ctrlKey: true });\n  expect(annotationEditorUIManager.getMode()).toBe(AnnotationEditorType.FREE_TEXT);\n});",
    "i4_deepseek-r1-distill-llama-70b": "it(\"should redo an annotation after undoing it\", async () => {\n  const { PDFDocument } = await import(\"../../src/core/document.js\");\n  const { AnnotationEditorUIManager } = await import(\"../../src/display/editor/tools.js\");\n  const { AnnotationEditorLayer } = await import(\"../../src/display/editor/annotation_editor_layer.js\");\n\n  // Setup\n  const pdfDocument = new PDFDocument(null, new Uint8Array());\n  const page = pdfDocument.addPage();\n  const container = { addEventListener: jest.fn(), focus: jest.fn() };\n  const eventBus = { _on: jest.fn(), _off: jest.fn(), dispatch: jest.fn() };\n\n  const uiManager = new AnnotationEditorUIManager(container, eventBus, pdfDocument, {});\n  const layer = new AnnotationEditorLayer(page, pdfDocument, null, null, null, null, null, null);\n  uiManager.addLayer(layer);\n\n  // Add an editor\n  const editor = layer.createEditor(\"text\");\n  uiManager.addEditor(editor);\n  expect(uiManager.#allEditors.size).toBe(1);\n\n  // Undo\n  const undoEvent = new KeyboardEvent(\"keydown\", {\n    bubbles: true,\n    cancelable: true,\n    keyCode: 90,\n    key: \"z\",\n    ctrlKey: true,\n  });\n  container.dispatchEvent(undoEvent);\n  expect(uiManager.#commandManager.hasSomethingToUndo()).toBe(false);\n  expect(uiManager.#allEditors.size).toBe(0);\n\n  // Redo\n  const redoEvent = new KeyboardEvent(\"keydown\", {\n    bubbles: true,\n    cancelable: true,\n    keyCode: 89,\n    key: \"y\",\n    ctrlKey: true,\n  });\n  container.dispatchEvent(redoEvent);\n\n  // Verify the editor was restored\n  expect(uiManager.#allEditors.size).toBe(1);\n});",
    "i4_gpt-4o": "it(\"should redo an added imagetextdrawing to the PDF file using Keyboard shortcuts\", async () => {\n  const { AnnotationEditorUIManager } = await import(\"../../src/display/editor/tools.js\");\n  const { EventBus } = await import(\"../../web/event_utils.js\");\n\n  const eventBus = new EventBus();\n  const container = document.createElement(\"div\");\n  const pdfDocument = { annotationStorage: new Map(), filterFactory: {} };\n  const uiManager = new AnnotationEditorUIManager(container, eventBus, pdfDocument, null);\n\n  let redoCalled = false;\n  uiManager.redo = () => {\n    redoCalled = true;\n  };\n\n  const keyboardEvent = new KeyboardEvent(\"keydown\", {\n    key: \"y\",\n    ctrlKey: true,\n  });\n\n  container.dispatchEvent(keyboardEvent);\n\n  expect(redoCalled).toBe(true);\n});",
    "i4_llama-3.3-70b-versatile": "it(\"should redo an added imagetextdrawing to the PDF file using Keyboard shortcuts\", async () => {\n  const { AnnotationEditorUIManager, CommandManager } = await import(\"../../src/display/editor/tools.js\");\n  const { AnnotationEditorLayer } = await import(\"../../src/display/editor/annotation_editor_layer.js\");\n  const { PDFDocument } = await import(\"../../src/core/document.js\");\n\n  const container = { addEventListener: () => {}, removeEventListener: () => {} };\n  const eventBus = { _on: () => {}, _off: () => {}, dispatch: () => {} };\n  const pdfDocument = new PDFDocument();\n  const pageColors = { foreground: null, background: null };\n\n  const annotationEditorUIManager = new AnnotationEditorUIManager(container, eventBus, pdfDocument, pageColors);\n  const annotationEditorLayer = new AnnotationEditorLayer();\n  annotationEditorUIManager.addLayer(annotationEditorLayer);\n\n  const commandManager = annotationEditorUIManager._commandManager;\n  const keyboardManager = AnnotationEditorUIManager._keyboardManager;\n\n  const editor = { id: 'test', pageIndex: 0, isEmpty: () => false, remove: () => {} };\n  annotationEditorUIManager.addEditor(editor);\n\n  const cmd = () => annotationEditorUIManager.addEditor(editor);\n  const undo = () => annotationEditorUIManager.removeEditor(editor);\n  commandManager.add({ cmd, undo, mustExec: true });\n\n  const event = { key: 'y', ctrlKey: true };\n  keyboardManager.exec(annotationEditorUIManager, event);\n\n  expect(annotationEditorUIManager.getEditor('test')).not.toBeNull();\n});",
    "i5_deepseek-r1-distill-llama-70b": "it(\"should redo annotations using keyboard shortcuts\", async () => {\n  const { AnnotationEditorUIManager } = await import(\"../../src/display/editor/tools.js\");\n  const { CommandManager } = await import(\"../../src/display/editor/tools.js\");\n  const { PDFDocument, PDFPageProxy } = await import(\"../../src/core/document.js\");\n\n  // Initialize test document and page\n  const pdfDocument = await PDFDocument.load(\n    await import(\"../../src/web/test_utils.js\").then(utils => utils.buildGetDocumentParams(\"simple.pdf\"))\n  );\n  const page = await pdfDocument.getPage(1);\n\n  // Setup annotation editor and command manager\n  const annotationEditor = new AnnotationEditorUIManager(page);\n  const commandManager = new CommandManager(annotationEditor);\n  const redoCalled = { value: false };\n\n  // Mock the redo command handler\n  commandManager.on(\"redo\", () => {\n    redoCalled.value = true;\n  });\n\n  // Add an annotation and undo it\n  const annotation = await annotationEditor.addAnnotation({\n    type: \"square\",\n    rectangle: [0, 0, 100, 100],\n  });\n  await annotationEditor.undo();\n\n  // Test the redo keyboard shortcut\n  await commandManager.execute({\n    type: \"keydown\",\n    key: \"z\",\n    ctrlKey: true,\n    shiftKey: true,\n  });\n\n  // Verify redo was called\n  expect(redoCalled.value).toBe(true);\n});",
    "i5_gpt-4o": "it(\"should redo an added imagetextdrawing to the PDF file using keyboard shortcuts\", async () => {\n  const { AnnotationEditorUIManager } = await import(\"../../src/display/editor/tools.js\");\n  const { PDFDocumentProxy } = await import(\"../../src/display/api.js\");\n\n  const pdfDocument = new PDFDocumentProxy();\n  const editorUIManager = new AnnotationEditorUIManager(pdfDocument);\n\n  editorUIManager.addAnnotation({ type: \"text\", content: \"Test\" });\n  editorUIManager.undo();\n\n  const redoShortcutEvent = new KeyboardEvent(\"keydown\", {\n    key: \"Z\",\n    ctrlKey: true,\n    shiftKey: true,\n  });\n\n  document.dispatchEvent(redoShortcutEvent);\n\n  const annotations = editorUIManager.getAnnotations();\n  const expected = [{ type: \"text\", content: \"Test\" }];\n  expect(annotations).toEqual(expected);\n});",
    "i5_llama-3.3-70b-versatile": "it(\"should redo an added imagetextdrawing to the PDF file using Keyboard shortcuts\", async () => {\n  const { AnnotationEditorUIManager } = await import(\"../../src/display/editor/tools.js\");\n  const { PDFDocument } = await import(\"../../src/core/document.js\");\n  const { PDFFetchStream } = await import(\"../../src/display/fetch_stream.js\");\n  const { PDFPageProxy } = await import(\"../../src/display/api.js\");\n\n  const pdfDoc = await PDFDocument.load(await PDFFetchStream.fetch(\"path_to_test_pdf\"));\n  const pageProxy = pdfDoc.getPage(1);\n  const annotationEditorUIManager = new AnnotationEditorUIManager(pageProxy);\n\n  annotationEditorUIManager.addEventListener(\"annotationAdded\", () => {\n    annotationEditorUIManager.undo();\n    annotationEditorUIManager.redo();\n  });\n\n  annotationEditorUIManager.addAnnotation(\"testAnnotation\");\n\n  const expectedAnnotations = 1;\n  const actualAnnotations = annotationEditorUIManager.annotations.length;\n\n  expect(actualAnnotations).toBe(expectedAnnotations);\n});"
  },
  "16718": {
    "i1_deepseek-r1-distill-llama-70b": "it(\"should correctly save annotations with linearization\", async () => {\n  const { Dict, Name, Ref } = await import(\"../../src/core/primitives.js\");\n  const { incrementalUpdate, writeDict } = await import(\"../../src/core/writer.js\");\n  const { bytesToString } = await import(\"../../src/shared/util.js\");\n  const { StringStream } = await import(\"../../src/core/stream.js\");\n\n  // Create a sample PDF with an annotation\n  const xref = {\n    trailer: new Dict(),\n    getNewTemporaryRef: () => new Ref(2, 0),\n    lastXRefStreamPos: 10,\n    encrypt: null,\n  };\n\n  // Set up the acroForm data\n  const acroForm = new Dict();\n  acroForm.set(\"NeedAppearances\", true);\n\n  // Set up the annotation data\n  const annotationRef = new Ref(1, 0);\n  const annotation = new Dict();\n  annotation.set(\"Type\", new Name(\"Annot\"));\n  annotation.set(\"Subtype\", new Name(\"Widget\"));\n  annotation.set(\"T\", new Name(\"Test\"));\n\n  const buffer = await incrementalUpdate({\n    originalData: new Uint8Array(),\n    xrefInfo: {\n      rootRef: new Ref(0, 0),\n      encryptRef: null,\n      newRef: new Ref(1, 0),\n      infoRef: null,\n      info: {},\n      fileIds: null,\n      startXRef: 0,\n      filename: \"test.pdf\",\n    },\n    newRefs: [{ ref: annotationRef, data: \"\" }],\n    xref,\n    hasXfa: false,\n    xfaDatasetsRef: null,\n    hasXfaDatasetsEntry: false,\n    needAppearances: true,\n    acroFormRef: new Ref(0, 0),\n    acroForm,\n    xfaData: null,\n  });\n\n  // Verify the annotation was saved correctly\n  const stream = new StringStream(bytesToString(buffer));\n  const parser = new Parser({\n    lexer: new Lexer(stream),\n    xref: {\n      getEntry: (num) => {\n        if (num === 1) return annotation;\n        return null;\n      },\n    },\n  });\n\n  const xrefEntries = await parser.getObj();\n  const annotationEntry = xrefEntries.get(1);\n  expect(annotationEntry.get(\"Type\")).toBe(\"Annot\");\n});",
    "i1_gpt-4o": "it(\"should save PDF annotations correctly\", async () => {\n  const { updateAcroform } = await import(\"../../src/core/writer.js\");\n  const { XRefMock } = await import(\"./test_utils.js\");\n\n  const xref = new XRefMock();\n  const acroForm = new Dict(xref);\n  const acroFormRef = Ref.get(1, 0);\n  const hasXfa = false;\n  const hasXfaDatasetsEntry = false;\n  const xfaDatasetsRef = null;\n  const needAppearances = true;\n  const newRefs = [];\n\n  await updateAcroform({\n    xref,\n    acroForm,\n    acroFormRef,\n    hasXfa,\n    hasXfaDatasetsEntry,\n    xfaDatasetsRef,\n    needAppearances,\n    newRefs,\n  });\n\n  const expected = true;\n  const actual = newRefs.some(ref => ref.data.includes(\"/NeedAppearances true\"));\n  expect(actual).toBe(expected);\n});",
    "i1_llama-3.3-70b-versatile": "it(\"should save PDF annotations correctly\", async () => {\n  const { Dict, Name, Ref } = await import(\"../../src/core/primitives.js\");\n  const { incrementalUpdate } = await import(\"../../src/core/writer.js\");\n  const { XRef } = await import(\"../../src/core/xref.js\");\n  const { LocalPdfManager } = await import(\"../../src/core/pdf_manager.js\");\n  const { AnnotationFactory } = await import(\"../../src/core/annotation.js\");\n  const { stringToBytes } = await import(\"../../src/shared/util.js\");\n\n  const pdfData = stringToBytes(\"%PDF-1.4\\n\" +\n    \"1 0 obj\\n\" +\n    \"<<\\n\" +\n    \"/Type /Catalog\\n\" +\n    \"/Pages 2 0 R\\n\" +\n    \">>\\n\" +\n    \"endobj\\n\" +\n    \"2 0 obj\\n\" +\n    \"<<\\n\" +\n    \"/Type /Pages\\n\" +\n    \"/Kids [3 0 R]\\n\" +\n    \"/Count 1\\n\" +\n    \">>\\n\" +\n    \"endobj\\n\" +\n    \"3 0 obj\\n\" +\n    \"<<\\n\" +\n    \"/Type /Page\\n\" +\n    \"/Parent 2 0 R\\n\" +\n    \"/MediaBox [0 0 100 100]\\n\" +\n    \"/Resources <<\\n\" +\n    \"/Font <<\\n\" +\n    \"/F1 4 0 R\\n\" +\n    \">>\\n\" +\n    \">>\\n\" +\n    \"/Contents 5 0 R\\n\" +\n    \">>\\n\" +\n    \"endobj\\n\" +\n    \"4 0 obj\\n\" +\n    \"<<\\n\" +\n    \"/Type /Font\\n\" +\n    \"/Subtype /Type1\\n\" +\n    \"/BaseFont /Helvetica\\n\" +\n    \">>\\n\" +\n    \"endobj\\n\" +\n    \"5 0 obj\\n\" +\n    \"<<\\n\" +\n    \"/Length 6 0 R\\n\" +\n    \">>\\n\" +\n    \"stream\\n\" +\n    \"BT\\n\" +\n    \"/F1 12 Tf\\n\" +\n    \"50 50 Td\\n\" +\n    \"(Hello World) Tj\\n\" +\n    \"ET\\n\" +\n    \"endstream\\n\" +\n    \"endobj\\n\" +\n    \"6 0 obj\\n\" +\n    \"123\\n\" +\n    \"endobj\\n\" +\n    \"xref\\n\" +\n    \"0 7\\n\" +\n    \"0000000000 65535 f \\n\" +\n    \"0000000017 00000 n \\n\" +\n    \"0000000074 00000 n \\n\" +\n    \"0000000120 00000 n \\n\" +\n    \"0000000173 00000 n \\n\" +\n    \"0000000212 00000 n \\n\" +\n    \"0000000251 00000 n \\n\" +\n    \"trailer\\n\" +\n    \"<<\\n\" +\n    \"/Size 7\\n\" +\n    \"/Root 1 0 R\\n\" +\n    \">>\\n\" +\n    \"startxref\\n\" +\n    \"341\\n\" +\n    \"%%EOF\");\n\n  const",
    "i2_deepseek-r1-distill-llama-70b": "it(\"should correctly save annotations when AcroForm needs appearances\", async () => {\n  const { PDFDocument } = await import(\"../../src/core/document.js\");\n  const { Annotation, AnnotationBorderStyle } = await import(\"../../src/core/annotation.js\");\n  const { writeDict } = await import(\"../../src/core/writer.js\");\n\n  // Create a simple PDF with one page\n  const pdf = new PDFDocument();\n  const page = pdf.addPage();\n\n  // Create a test annotation\n  const rect = [100, 100, 200, 200];\n  const annotation = new Annotation({\n    type: \"Highlight\",\n    rect,\n    page: 0,\n    color: \"#FF0000\",\n    border: new AnnotationBorderStyle({ width: 2 }),\n  });\n\n  // Save the document\n  const saveResult = await pdf.save({\n    annotations: [annotation],\n    flags: 3, // Save with annotations\n  });\n\n  // Reload the saved document\n  const loadedPdf = await PDFDocument.load(saveResult.bytes);\n\n  // Check if the annotation was correctly saved\n  const [firstPage] = await loadedPdf.getPages();\n  const annotations = await firstPage.getAnnotations();\n\n  expect(annotations.length).toBe(1);\n});",
    "i2_gpt-4o": "it(\"should save PDF annotations correctly\", async () => {\n  const { PDFDocumentProxy, getDocument } = await import(\"../../src/display/api.js\");\n  const { AnnotationStorage } = await import(\"../../src/display/annotation_storage.js\");\n  const { buildGetDocumentParams } = await import(\"./test_utils.js\");\n\n  const loadingTask = getDocument(buildGetDocumentParams(\"test.pdf\"));\n  const pdfDocument = await loadingTask.promise;\n  const annotationStorage = new AnnotationStorage();\n\n  const page = await pdfDocument.getPage(1);\n  const annotations = await page.getAnnotations();\n  annotations.forEach(annotation => {\n    annotationStorage.setValue(annotation.id, { value: \"Test\" });\n  });\n\n  const savedData = await pdfDocument.saveDocument({\n    isPureXfa: false,\n    numPages: pdfDocument.numPages,\n    annotationStorage,\n    filename: \"test.pdf\",\n  });\n\n  const newLoadingTask = getDocument({ data: savedData });\n  const newPdfDocument = await newLoadingTask.promise;\n  const newPage = await newPdfDocument.getPage(1);\n  const newAnnotations = await newPage.getAnnotations();\n\n  const expected = annotations.map(a => ({ ...a, value: \"Test\" }));\n  const actual = newAnnotations.map(a => ({ ...a, value: annotationStorage.getValue(a.id).value }));\n\n  expect(actual).toEqual(expected);\n});",
    "i2_llama-3.3-70b-versatile": "it(\"should save PDF annotations correctly\", async () => {\n  const { PDFWorkerStream, WorkerMessageHandler, LocalPdfManager, AnnotationFactory } = await import(\"../../src/core/worker.js\");\n  const { incrementalUpdate } = await import(\"../../src/core/writer.js\");\n  const { XRef } = await import(\"../../src/core/xref.js\");\n  const { arrayBuffersToBytes, getNewAnnotationsMap } = await import(\"../../src/core/core_utils.js\");\n  const { Dict, Ref } = await import(\"../../src/core/primitives.js\");\n\n  // Initialize required variables\n  let pdfManager;\n  let handler;\n  let annotationStorage = new Map();\n  let newAnnotationsByPage = new Map();\n  let xref;\n\n  // Define expected variable\n  let expectedAnnotations = [];\n\n  // Generate actual variables\n  handler = new WorkerMessageHandler();\n  pdfManager = new LocalPdfManager({\n    source: arrayBuffersToBytes([104, 101, 108, 108, 111]),\n    disableAutoFetch: true,\n    docBaseUrl: \"\",\n    docId: \"test\",\n    enableXfa: true,\n    evaluatorOptions: {},\n    handler: handler,\n    length: 5,\n    password: \"\",\n    rangeChunkSize: 1000000,\n  });\n\n  xref = new XRef(new PDFWorkerStream(handler), pdfManager);\n  xref.startXRefQueue.push(0);\n  xref.readXRef();\n\n  // Create a new annotation\n  const annotation = AnnotationFactory.createTextAnnotation({\n    page: 0,\n    rect: [10, 10, 20, 20],\n    text: \"Hello World\",\n  });\n  annotationStorage.set(0, [annotation]);\n\n  newAnnotationsByPage = getNewAnnotationsMap(annotationStorage);\n\n  // Save the PDF with the new annotation\n  const savedPdf = await incrementalUpdate({\n    originalData: arrayBuffersToBytes([104, 101, 108, 108, 111]),\n    xrefInfo: {\n      rootRef: new Ref(1, 0),\n      encryptRef: null,\n      newRef: new Ref(2, 0),\n      infoRef: null,\n      info: {},\n      fileIds: null,\n      startXRef: 0,\n      filename: \"test.pdf\",\n    },\n    newRefs: [],\n    xref: xref,\n    hasXfa: false,\n    xfaDatasetsRef: null,\n    hasXfaDatasetsEntry: false,\n    needAppearances: true,\n    acroFormRef: new Ref(1, 0),\n    acroForm: new Dict(xref),\n    xfaData: null,\n  });\n\n  // Check if the annotation was saved correctly\n  const savedAnnotations = await pdfManager.getPage(0).then(page => page.getAnnotationsData(handler));\n  expectedAnnotations = [{ page: 0, annotations: [annotation] }];\n\n  // Compare expected with actual\n  expect(savedAnnotations).toEqual(expectedAnnotations);\n});",
    "i3_deepseek-r1-distill-llama-70b": "it(\"should save annotations on linearized PDFs\", async () => {\n  const { incrementalUpdate } = await import(\"../../src/core/writer.js\");\n  const { Dict, Name, Ref } = await import(\"../../src/core/primitives.js\");\n  const { StringStream } = await import(\"../../src/core/stream.js\");\n  const { bytesToString } = await import(\"../../src/shared/util.js\");\n\n  // Create a sample XRef with linearization\n  const xref = {\n    trailer: new Dict(),\n    lastXRefStreamPos: 100,\n    startXRefQueue: [101],\n    _xrefStms: new Set([101]),\n  };\n\n  // Set up the data for incremental update\n  const originalData = new Uint8Array([0x25, 0x50, 0x44, 0x46]);\n  const newRefs = [];\n  const acroFormRef = Ref.get(1, 0);\n  const acroForm = new Dict();\n  const xrefInfo = {\n    rootRef: Ref.get(2, 0),\n    encryptRef: null,\n    newRef: Ref.get(3, 0),\n    infoRef: null,\n    info: {},\n    fileIds: null,\n    startXRef: 100,\n    filename: \"test.pdf\",\n  };\n\n  // Perform the incremental update\n  const result = await incrementalUpdate({\n    originalData,\n    xrefInfo,\n    newRefs,\n    xref,\n    hasXfa: false,\n    xfaDatasetsRef: null,\n    hasXfaDatasetsEntry: false,\n    needAppearances: true,\n    acroFormRef,\n    acroForm,\n    xfaData: null,\n  });\n\n  // Convert the result to a string for inspection\n  const resultStr = bytesToString(result);\n\n  // Verify that the annotation data is present\n  expect(resultStr).toContain(\"annotation\");\n});",
    "i3_llama-3.3-70b-versatile": "it(\"should save PDF annotations correctly\", async () => {\n  const { WorkerMessageHandler, LocalPdfManager, AnnotationFactory } = await import(\"../../src/core/worker.js\");\n  const { incrementalUpdate } = await import(\"../../src/core/writer.js\");\n  const { XRef } = await import(\"../../src/core/xref.js\");\n  const { Dict, Ref } = await import(\"../../src/core/primitives.js\");\n  const { stringToBytes } = await import(\"../../src/shared/util.js\");\n  const { StringStream } = await import(\"../../src/core/stream.js\");\n\n  const pdfManager = new LocalPdfManager({\n    source: stringToBytes(\"%PDF-1.4\\n\" + \"1 0 obj\\n\" + \"<<\\n\" + \"/Type /Catalog\\n\" + \"/Pages 2 0 R\\n\" + \">>\\n\" + \"endobj\\n\" + \"2 0 obj\\n\" + \"<<\\n\" + \"/Type /Pages\\n\" + \"/Kids [3 0 R]\\n\" + \"/Count 1\\n\" + \"/MediaBox [0 0 100 100]\\n\" + \">>\\n\" + \"endobj\\n\" + \"3 0 obj\\n\" + \"<<\\n\" + \"/Type /Page\\n\" + \"/Parent 2 0 R\\n\" + \"/Resources <<\\n\" + \"/Font <<\\n\" + \"/F1 4 0 R\\n\" + \">>\\n\" + \">>\\n\" + \"/Contents 5 0 R\\n\" + \">>\\n\" + \"endobj\\n\" + \"4 0 obj\\n\" + \"<<\\n\" + \"/Type /Font\\n\" + \"/Subtype /Type1\\n\" + \"/BaseFont /Helvetica\\n\" + \">>\\n\" + \"endobj\\n\" + \"5 0 obj\\n\" + \"<<\\n\" + \"/Length 6 0 R\\n\" + \">>\\n\" + \"stream\\n\" + \"BT\\n\" + \"/F1 12 Tf\\n\" + \"100 100 Td\\n\" + \"(Hello World) Tj\\n\" + \"ET\\n\" + \"endstream\\n\" + \"endobj\\n\" + \"6 0 obj\\n\" + \"23\\n\" + \"endobj\\n\" + \"xref\\n\" + \"0 7\\n\" + \"0000000000 65535 f \\n\" + \"0000000015 00000 n \\n\" + \"0000000074 00000 n \\n\" + \"0000000121 00000 n \\n\" + \"0000000170 00000 n \\n\" + \"0000000219 00000 n \\n\" + \"0000000238 00000 n \\n\" + \"trailer\\n\" + \"<<\\n\" + \"/Size 7\\n\" + \"/Root 1 0 R\\n\" + \">>\\n\" + \"startxref\\n\" + \"264\\n\" + \"%%EOF\"),\n    disableAutoFetch: true,\n  });\n\n  const xref = new XRef(new StringStream(pdfManager.source), pdfManager);\n  xref.parse();\n\n  const annotationStorage = new Map();\n  annotationStorage.set(0, [{ page: 0, annotation:",
    "i4_deepseek-r1-distill-llama-70b": "it(\"should save annotations in PDFs with certain structures\", async () => {\n  const { PDFDocument } = await import(\"../../src/display/pdf_document.js\");\n  const { PDFViewer } = await import(\"../../src/web/pdf_viewer.js\");\n  const { Annotation } = await import(\"../../src/core/annotation.js\");\n\n  // Load a PDF with known problematic structure\n  const pdfData = new Uint8Array([\n    0x25, 0x50, 0x44, 0x46, 0x2d, 0x31, 0x2e, 0x30, 0x0a, 0x25, 0xa5, 0x0c, 0x28, 0x0c, 0x29, 0x0c,\n    0x31, 0x30, 0x20, 0x72, 0x65, 0x66, 0x65, 0x72, 0x65, 0x6e, 0x63, 0x65, 0x73, 0x0c,\n    0x32, 0x30, 0x20, 0x6f, 0x62, 0x6a, 0x0c, 0x3c, 0x3c, 0x2f, 0x53, 0x74, 0x72, 0x65,\n    0x61, 0x6d, 0x3e, 0x0c, 0x64, 0x6a, 0x76, 0x6d, 0x50, 0x3e, 0x0c, 0x3c, 0x2f, 0x53,\n    0x75, 0x70, 0x70, 0x6c, 0x65, 0x72, 0x3e, 0x0c, 0x7b, 0x22, 0x73, 0x75, 0x62, 0x6a,\n    0x65, 0x63, 0x74, 0x22, 0x3a, 0x20, 0x22, 0x6f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x22,\n    0x7d, 0x0c, 0x74, 0x72, 0x61, 0x69, 0x6c, 0x65, 0x72, 0x3e, 0x0c, 0x7b, 0x22, 0x73,\n    0x69, 0x7a, 0x65, 0x22, 0x3a, 0x20, 0x31, 0x30, 0x30, 0x0c, 0x22, 0x73, 0x74, 0x61,\n    0x72, 0x74, 0x22, 0x3a, 0x20, 0x31, 0x30, 0x30, 0x30, 0x0c, 0x7d, 0x0c, 0x25, 0x50,\n    0x44, 0x46, 0x2d, 0x31, 0x2e, 0x30, 0x0a\n  ]);\n\n  const container = document.createElement(\"div\");\n  document.body.appendChild(container);\n\n  const pdfViewer = new PDFViewer({\n    container,\n    renderInteractiveForms: true,\n  });\n\n  const pdfDocument = await PDFDocument.load(pdfData, {\n    cMapUrl: \"../../src/core/cmaps/\",\n    standardFontDataUrl: \"../../src/core/standard_fonts.json\",\n  });\n\n  await pdfDocument.getMetadata();\n\n  const page = await pdfDocument.getPage(1);\n  const annotation = new Annotation({\n    type: \"text\",\n    page: page,\n    rect: [100, 100, 200, 200],\n    contents: [\"Test annotation\"],\n  });\n\n  page.addAnnotation(annotation);\n\n  const savedData = await pdfDocument.save();\n\n  const loadedDocument = await PDFDocument.load(savedData);\n  const loadedPage = await loadedDocument.getPage(1);\n  const annotations = await loadedPage.getAnnotations();\n\n  expect(annotations.length).toBe(1);\n  expect(annotations[0].contents).toBe(\"Test annotation\");\n});",
    "i4_gpt-4o": "it(\"should save PDF annotations correctly on certain PDFs\", async () => {\n  const { PDFDocument } = await import(\"../../src/core/document.js\");\n  const { LocalPdfManager } = await import(\"../../src/core/pdf_manager.js\");\n  const { Ref } = await import(\"../../src/core/primitives.js\");\n  const { incrementalUpdate } = await import(\"../../src/core/writer.js\");\n\n  const pdfData = new Uint8Array([/* PDF data bytes */]);\n  const pdfManager = new LocalPdfManager({\n    source: pdfData,\n    docId: \"test-doc\",\n    handler: null,\n  });\n\n  const pdfDocument = await PDFDocument.load(pdfManager);\n  const page = await pdfDocument.getPage(0);\n  const annotations = await page.getAnnotationsData();\n\n  const annotationStorage = new Map();\n  annotationStorage.set(\"1R\", { value: \"Test annotation\" });\n\n  const stream = await pdfManager.requestLoadedStream();\n  const xref = await pdfManager.ensureDoc(\"xref\");\n  const acroForm = await pdfManager.ensureCatalog(\"acroForm\");\n  const acroFormRef = new Ref(1, 0);\n\n  const newRefs = [];\n  const xrefInfo = {\n    rootRef: xref.trailer.getRaw(\"Root\"),\n    encryptRef: xref.trailer.getRaw(\"Encrypt\"),\n    newRef: xref.getNewTemporaryRef(),\n    infoRef: xref.trailer.getRaw(\"Info\"),\n    info: {},\n    fileIds: xref.trailer.get(\"ID\"),\n    startXRef: xref.lastXRefStreamPos,\n    filename: \"test.pdf\",\n  };\n\n  const updatedPdf = await incrementalUpdate({\n    originalData: stream.bytes,\n    xrefInfo,\n    newRefs,\n    xref,\n    hasXfa: false,\n    xfaDatasetsRef: null,\n    hasXfaDatasetsEntry: false,\n    needAppearances: true,\n    acroFormRef,\n    acroForm,\n    xfaData: null,\n  });\n\n  const expectedAnnotation = \"Test annotation\";\n  const actualAnnotation = annotations[0].value;\n\n  expect(actualAnnotation).toBe(expectedAnnotation);\n});",
    "i4_llama-3.3-70b-versatile": "it(\"should save PDF annotations correctly\", async () => {\n  const { PDFWorkerStream, WorkerMessageHandler, LocalPdfManager } = await import(\"../../src/core/worker.js\");\n  const { incrementalUpdate } = await import(\"../../src/core/writer.js\");\n  const { XRef } = await import(\"../../src/core/xref.js\");\n  const { AnnotationFactory } = await import(\"../../src/core/annotation.js\");\n\n  const pdfManager = new LocalPdfManager({\n    source: new Uint8Array([0x25, 0x50, 0x44, 0x46, 0x2d, 0x31, 0x2e, 0x34]),\n    disableAutoFetch: true,\n    docBaseUrl: \"\",\n    docId: \"test\",\n    enableXfa: false,\n    evaluatorOptions: {},\n    handler: {},\n    length: 8,\n    password: \"\",\n    rangeChunkSize: 0,\n  });\n\n  const xref = new XRef({\n    getBytes: () => new Uint8Array([0x25, 0x50, 0x44, 0x46, 0x2d, 0x31, 0x2e, 0x34]),\n  }, pdfManager);\n\n  const annotation = AnnotationFactory.createAnnotation({\n    subtype: \"Highlight\",\n    page: 1,\n    rect: [10, 10, 20, 20],\n  });\n\n  const newAnnotationsByPage = { 1: [annotation] };\n\n  const acroFormRef = { num: 1, gen: 0 };\n  const acroForm = {};\n  const xfaDatasetsRef = { num: 2, gen: 0 };\n  const xfaData = null;\n  const needAppearances = true;\n  const newRefs = [];\n\n  const result = await incrementalUpdate({\n    originalData: new Uint8Array([0x25, 0x50, 0x44, 0x46, 0x2d, 0x31, 0x2e, 0x34]),\n    xrefInfo: {\n      newRef: { num: 3, gen: 0 },\n      startXRef: 0,\n      rootRef: { num: 4, gen: 0 },\n      infoRef: { num: 5, gen: 0 },\n      encryptRef: { num: 6, gen: 0 },\n      info: {},\n      fileIds: [\"fileId1\", \"fileId2\"],\n      filename: \"test.pdf\",\n    },\n    newRefs,\n    xref,\n    hasXfa: false,\n    xfaDatasetsRef,\n    hasXfaDatasetsEntry: false,\n    needAppearances,\n    acroFormRef,\n    acroForm,\n    xfaData,\n  });\n\n  expect(result).not.toBeNull();\n});",
    "i5_deepseek-r1-distill-llama-70b": "it(\"should save annotations in linearized PDFs\", async () => {\n  const { PDFDocument, Annotation, Page } = await import(\"../../src/core/document.js\");\n  const { pdfManager } = await import(\"../../src/core/worker.js\");\n\n  // Create a new PDF document\n  const pdfDoc = new PDFDocument();\n  const page = pdfDoc.addPage();\n\n  // Create and add an annotation\n  const rect = new PDFRect(100, 100, 200, 200);\n  const annotation = new Annotation(rect, \"Test Annotation\");\n  page.addAnnotation(annotation);\n\n  // Save the PDF with linearization\n  const savedPdf = await pdfDoc.save();\n\n  // Load the saved PDF back\n  const loadedPdf = await PDFDocument.load(savedPdf);\n  const loadedPage = await loadedPdf.getPage(1);\n\n  // Verify the annotation exists in the loaded PDF\n  expect(loadedPage.getAnnotations().length).toBe(1);\n});",
    "i5_gpt-4o": "it(\"should save PDF annotations correctly on certain PDFs\", async () => {\n  const { PDFDocument } = await import(\"../../src/core/document.js\");\n  const { AnnotationStorage } = await import(\"../../src/display/annotation_storage.js\");\n  const { getDocument } = await import(\"../../src/display/api.js\");\n\n  const pdfUrl = \"path/to/test/pdf/with/annotations.pdf\";\n  const loadingTask = getDocument(pdfUrl);\n  const pdfDocument = await loadingTask.promise;\n  const annotationStorage = new AnnotationStorage();\n\n  const page = await pdfDocument.getPage(1);\n  const annotations = await page.getAnnotations();\n  annotations.forEach(annotation => {\n    annotationStorage.setValue(annotation.id, { value: \"Test annotation\" });\n  });\n\n  const savedPdf = await pdfDocument.save({ annotationStorage });\n  const savedDocument = await PDFDocument.load(savedPdf);\n  const savedPage = await savedDocument.getPage(1);\n  const savedAnnotations = await savedPage.getAnnotations();\n\n  const expectedAnnotations = annotations.map(annotation => ({\n    ...annotation,\n    value: \"Test annotation\"\n  }));\n\n  expect(savedAnnotations).toEqual(expectedAnnotations);\n});",
    "i5_llama-3.3-70b-versatile": "it(\"should save PDF annotations on certain PDFs\", async () => {\n  const { PDFDocument } = await import(\"../../src/core/document.js\");\n  const { PDFWorker } = await import(\"../../src/display/api.js\");\n  const { createIdFactory } = await import(\"./test_utils.js\");\n  const { TEST_PDFS_PATH } = await import(\"./test_utils.js\");\n\n  const pdfWorker = new PDFWorker();\n  const pdfDoc = await pdfWorker.loadPDF(TEST_PDFS_PATH + \"issue_pdf.pdf\");\n  const idFactory = createIdFactory();\n\n  const page = pdfDoc.getPage(1);\n  const annotations = await page.getAnnotations();\n\n  const newAnnotation = {\n    subtype: \"Widget\",\n    rect: [10, 10, 50, 50],\n    ap: {\n      normal: {\n        s: \"BG\",\n        g: \"1 0 0 1 rg\",\n        c: \"1 0 0 1 sc\",\n      },\n    },\n  };\n\n  annotations.push(newAnnotation);\n  await pdfDoc.saveAnnotations();\n\n  const updatedPdfDoc = await pdfWorker.loadPDF(TEST_PDFS_PATH + \"issue_pdf.pdf\");\n  const updatedPage = updatedPdfDoc.getPage(1);\n  const updatedAnnotations = await updatedPage.getAnnotations();\n\n  const expectedAnnotationsLength = annotations.length;\n  const actualAnnotationsLength = updatedAnnotations.length;\n\n  expect(actualAnnotationsLength).toBe(expectedAnnotationsLength);\n});"
  },
  "16719": {
    "i1_deepseek-r1-distill-llama-70b": "it(\"should delete selected annotation when Delete key is pressed on macOS\", async () => {\n  const { AnnotationFactory, AnnotationStorage, AnnotationEditorUIManager, EventBus } = await import(\"../../src/display/editor/tools.js\");\n  const annotation = AnnotationFactory.create(AnnotationType.MARKUP, {\n    subtype: \"Highlight\",\n    content: \"Test annotation\",\n  });\n  const storage = new AnnotationStorage();\n  storage.add(annotation);\n  const eventBus = new EventBus();\n  const pdfDocument = {\n    annotationStorage: storage,\n    filterFactory: {},\n  };\n  const container = {};\n  const pageColors = {};\n\n  const uiManager = new AnnotationEditorUIManager(container, eventBus, pdfDocument, pageColors);\n\n  const event = { key: \"Delete\", metaKey: true };\n  eventBus._on(\"keydown\", (e) => uiManager.keydown(e));\n\n  eventBus.dispatch(\"keydown\", event);\n\n  expect(storage.getAnnotations().length).toBe(0);\n});",
    "i1_gpt-4o": "it(\"should delete the selected element when pressing the Delete key on macOS\", async () => {\n  const { AnnotationEditorUIManager } = await import(\"../../src/display/editor/tools.js\");\n  const eventBus = { _on: () => {} };\n  const pdfDocument = { annotationStorage: {}, filterFactory: {} };\n  const container = {};\n  const pageColors = {};\n  const manager = new AnnotationEditorUIManager(container, eventBus, pdfDocument, pageColors);\n  const deleteSpy = jest.spyOn(manager, 'delete');\n  const keyboardEvent = new KeyboardEvent(\"keydown\", { key: \"Delete\", metaKey: true });\n  manager.keydown(keyboardEvent);\n  expect(deleteSpy).toHaveBeenCalled();\n});",
    "i1_llama-3.3-70b-versatile": "it(\"should delete the selected element when pressing the Delete key\", async () => {\n  const { AnnotationEditorUIManager, CommandManager } = await import(\"../../src/display/editor/tools.js\");\n  const { Annotation, MarkupAnnotation } = await import(\"../../src/core/annotation.js\");\n  const { getUuid } = await import(\"../../shared/util.js\");\n  const annotation = new MarkupAnnotation({\n    subtype: \"Highlight\",\n    rect: [10, 10, 20, 20],\n    page: 1,\n  });\n  const editor = new AnnotationEditorUIManager(null, null, null, null);\n  editor.#selectedEditors.add(annotation);\n  const deleteSpy = jest.spyOn(editor, \"delete\");\n  const event = {\n    key: \"Delete\",\n    preventDefault: jest.fn(),\n  };\n  editor.keydown(event);\n  expect(deleteSpy).toHaveBeenCalledTimes(1);\n});",
    "i2_deepseek-r1-distill-llama-70b": "it(\"should delete selected element when pressing Delete key on Mac\", async () => {\n  const { AnnotationEditorUIManager } = await import(\"../../src/display/editor/tools.js\");\n  const { CommandManager } = await import(\"../../src/display/editor/tools.js\");\n  const { KeyboardManager } = await import(\"../../src/display/editor/tools.js\");\n\n  const commandManager = {\n    delete: jest.fn(),\n  };\n\n  const eventBus = {\n    _on: jest.fn(),\n  };\n\n  const keyboardManager = new KeyboardManager([\n    [\n      [\"Backspace\", \"alt+Backspace\", \"ctrl+Backspace\", \"shift+Backspace\", \"mac+Backspace\", \"mac+alt+Backspace\", \"mac+ctrl+Backspace\", \"Delete\", \"ctrl+Delete\", \"shift+Delete\", \"mac+Delete\"],\n      AnnotationEditorUIManager.prototype.delete,\n    ],\n  ]);\n\n  const uiManager = new AnnotationEditorUIManager(null, eventBus, null, null);\n  uiManager.#commandManager = commandManager;\n  uiManager.#keyboardManager = keyboardManager;\n\n  const event = {\n    key: \"Delete\",\n    metaKey: true,\n    preventDefault: jest.fn(),\n  };\n\n  uiManager.keydown(event);\n\n  expect(commandManager.delete).toHaveBeenCalled();\n});",
    "i2_gpt-4o": "it(\"should delete the selected element when pressing the Delete key\", async () => {\n  const { AnnotationEditorUIManager } = await import(\"../../src/display/editor/tools.js\");\n  const { EventBus } = await import(\"../../web/event_utils.js\");\n\n  const container = document.createElement(\"div\");\n  const eventBus = new EventBus();\n  const pdfDocument = { annotationStorage: {}, filterFactory: {} };\n  const pageColors = null;\n\n  const manager = new AnnotationEditorUIManager(container, eventBus, pdfDocument, pageColors);\n  manager.#selectedEditors.add(\"editor1\");\n\n  const initialSelectedEditorsSize = manager.#selectedEditors.size;\n  const deleteEvent = new KeyboardEvent(\"keydown\", { key: \"Delete\" });\n\n  container.dispatchEvent(deleteEvent);\n\n  const finalSelectedEditorsSize = manager.#selectedEditors.size;\n  expect(finalSelectedEditorsSize).toBeLessThan(initialSelectedEditorsSize);\n});",
    "i2_llama-3.3-70b-versatile": "it(\"should delete the selected element when pressing the Delete key\", async () => {\n  const { AnnotationEditorUIManager, KeyboardManager } = await import(\"../../src/display/editor/tools.js\");\n  const { Util } = await import(\"../../shared/util.js\");\n  const { PDFDocument, PDFPage } = await import(\"../../src/core/document.js\");\n  const { AnnotationStorage } = await import(\"../../src/display/annotation_storage.js\");\n  const { PDFNetworkStream } = await import(\"../../src/display/network.js\");\n\n  const pdfDocument = await PDFDocument.load(await PDFNetworkStream.fetch(\"test.pdf\"));\n  const annotationStorage = new AnnotationStorage();\n  const eventBus = { _on: () => {} };\n  const container = {};\n  const pageColors = {};\n\n  const annotationEditorUIManager = new AnnotationEditorUIManager(container, eventBus, pdfDocument, pageColors);\n  annotationEditorUIManager.#mode = \"EDIT\";\n\n  const selectedEditor = { id: \"test-id\" };\n  annotationEditorUIManager.#selectedEditors.add(selectedEditor);\n\n  const keyboardEvent = { key: \"Delete\" };\n  annotationEditorUIManager.keydown(keyboardEvent);\n\n  const expectedDeletedElementId = selectedEditor.id;\n  const actualDeletedElementId = Array.from(annotationEditorUIManager.#deletedAnnotationsElementIds).pop();\n\n  expect(actualDeletedElementId).toBe(expectedDeletedElementId);\n});",
    "i3_deepseek-r1-distill-llama-70b": "it(\"should delete selected annotation when pressing Delete on Mac\", async () => {\n  const { AnnotationEditorUIManager, CommandManager } = await import(\"../../src/display/editor/tools.js\");\n  const { Annotation, MarkupAnnotation } = await import(\"../../src/core/annotation.js\");\n  const { AnnotationStorage } = await import(\"../../src/display/annotation_storage.js\");\n\n  // Setup platform as Mac\n  Object.defineProperty(FeatureTest, \"platform\", {\n    get: () => ({ isMac: true }),\n  });\n\n  const container = document.createElement(\"div\");\n  const eventBus = {\n    _on: () => {},\n    _off: () => {},\n    dispatch: () => {},\n  };\n  const pdfDocument = {\n    annotationStorage: new AnnotationStorage(),\n    filterFactory: {},\n  };\n  const pageColors = {\n    foreground: null,\n    background: null,\n  };\n\n  const uiManager = new AnnotationEditorUIManager(container, eventBus, pdfDocument, pageColors);\n  const commandManager = new CommandManager();\n\n  // Create test annotation\n  const annotation = new MarkupAnnotation({\n    id: \"test-annotation\",\n    flags: AnnotationFlag.NONE,\n    color: [0, 0, 0],\n    boundary: [0, 0, 100, 100],\n    content: \"Test\",\n  });\n\n  // Add annotation to storage\n  pdfDocument.annotationStorage.setValue(annotation.id, annotation);\n\n  // Simulate keydown event with Delete key on Mac\n  const event = new KeyboardEvent(\"keydown\", {\n    bubbles: true,\n    cancelable: true,\n    keyCode: 8, // Delete key code\n    key: \"Delete\",\n    metaKey: true,\n  });\n\n  container.dispatchEvent(event);\n\n  // Verify annotation was deleted\n  expect(pdfDocument.annotationStorage.size).toBe(0);\n});",
    "i3_gpt-4o": "it(\"should delete the selected element when pressing the Delete key on macOS\", async () => {\n  const { AnnotationEditorUIManager } = await import(\"../../src/display/editor/tools.js\");\n  const { EventBus } = await import(\"../../web/event_utils.js\");\n\n  const eventBus = new EventBus();\n  const container = document.createElement(\"div\");\n  const pdfDocument = { annotationStorage: new Map(), filterFactory: {} };\n  const uiManager = new AnnotationEditorUIManager(container, eventBus, pdfDocument, null);\n\n  const editor = { id: \"editor1\", remove: jest.fn(), isEmpty: () => false };\n  uiManager.addEditor(editor);\n  uiManager.setSelected(editor);\n\n  const deleteEvent = new KeyboardEvent(\"keydown\", { key: \"Delete\", metaKey: true });\n  container.dispatchEvent(deleteEvent);\n\n  expect(editor.remove).toHaveBeenCalled();\n});",
    "i3_llama-3.3-70b-versatile": "it(\"should delete the selected element when pressing the Delete key\", async () => {\n  const { AnnotationEditorUIManager, KeyboardManager } = await import(\"../../src/display/editor/tools.js\");\n  const { AnnotationEditorPrefix, AnnotationEditorType } = await import(\"../../shared/util.js\");\n  const annotationEditorUIManager = new AnnotationEditorUIManager({}, {}, {}, {});\n  const editor = { id: AnnotationEditorPrefix + \"1\", remove: jest.fn() };\n  annotationEditorUIManager.addEditor(editor);\n  annotationEditorUIManager.setSelected(editor);\n  const keyboardManager = AnnotationEditorUIManager._keyboardManager;\n  const event = new KeyboardEvent(\"keydown\", { key: \"Delete\" });\n  keyboardManager.exec(annotationEditorUIManager, event);\n  expect(editor.remove).toHaveBeenCalledTimes(1);\n});",
    "i4_deepseek-r1-distill-llama-70b": "it(\"should delete selected element when Delete key is pressed on macOS\", async () => {\n  const { AnnotationEditorUIManager } = await import(\"../../src/display/editor/tools.js\");\n  const { Util } = await import(\"../../shared/util.js\");\n\n  class MockEditor {\n    constructor() {\n      this.id = \"test-editor\";\n      this.isEmpty = jest.fn().mockReturnValue(false);\n      this.select = jest.fn();\n      this.unselect = jest.fn();\n      this.remove = jest.fn();\n    }\n  }\n\n  const uiManager = new AnnotationEditorUIManager({\n    addEventListener: jest.fn(),\n    removeEventListener: jest.fn(),\n  }, {}, {}, {});\n\n  const editor = new MockEditor();\n  uiManager.addEditor(editor);\n  uiManager.setSelected(editor);\n\n  const deleteSpy = jest.fn();\n  uiManager.delete = deleteSpy;\n\n  const event = {\n    key: \"Delete\",\n    preventDefault: jest.fn(),\n    stopPropagation: jest.fn(),\n  };\n\n  uiManager.keydown(event);\n\n  expect(deleteSpy).toHaveBeenCalled();\n});",
    "i4_gpt-4o": "it(\"should delete the selected element when pressing the Delete key on macOS\", async () => {\n  const { AnnotationEditorUIManager } = await import(\"../../src/display/editor/tools.js\");\n  const { EventBus } = await import(\"../../web/event_utils.js\");\n\n  const eventBus = new EventBus();\n  const container = document.createElement(\"div\");\n  const pdfDocument = { annotationStorage: new Map(), filterFactory: {} };\n  const uiManager = new AnnotationEditorUIManager(container, eventBus, pdfDocument, null);\n\n  const mockEditor = {\n    id: \"editor1\",\n    pageIndex: 0,\n    remove: jest.fn(),\n    isEmpty: () => false,\n    select: jest.fn(),\n    unselect: jest.fn(),\n    commitOrRemove: jest.fn(),\n    propertiesToUpdate: {},\n  };\n\n  uiManager.addEditor(mockEditor);\n  uiManager.setSelected(mockEditor);\n\n  const deleteEvent = new KeyboardEvent(\"keydown\", { key: \"Delete\", metaKey: true });\n  container.dispatchEvent(deleteEvent);\n\n  expect(mockEditor.remove).toHaveBeenCalled();\n});",
    "i4_llama-3.3-70b-versatile": "it(\"should delete the selected element when pressing the Delete key\", async () => {\n  const { AnnotationEditorUIManager, AnnotationEditorLayer } = await import(\"../../src/display/editor/tools.js\");\n  const { PDFDocument, Page } = await import(\"../../src/core/document.js\");\n  const { AnnotationStorage } = await import(\"../../src/display/annotation_storage.js\");\n  const { PDFPageProxy } = await import(\"../../src/display/api.js\");\n\n  const pdfDocument = new PDFDocument({\n    data: new Uint8Array(),\n    fingerprint: \"\",\n    length: 0,\n    password: \"\",\n    url: \"\",\n  });\n\n  const annotationStorage = new AnnotationStorage();\n  const page = new Page({\n    pdfDocument,\n    pageIndex: 0,\n    rotate: 0,\n  });\n\n  const annotationEditorLayer = new AnnotationEditorLayer({\n    annotationStorage,\n    page: new PDFPageProxy(page),\n  });\n\n  const annotationEditorUIManager = new AnnotationEditorUIManager({\n    container: {},\n    eventBus: {},\n    pdfDocument,\n    pageColors: {},\n  });\n\n  annotationEditorUIManager.addLayer(annotationEditorLayer);\n\n  const editor = {\n    id: \"editor\",\n    pageIndex: 0,\n    remove: jest.fn(),\n  };\n\n  annotationEditorUIManager.addEditor(editor);\n  annotationEditorUIManager.setSelected(editor);\n\n  annotationEditorUIManager.delete();\n\n  expect(editor.remove).toHaveBeenCalledTimes(1);\n});",
    "i5_deepseek-r1-distill-llama-70b": "it(\"should delete selected annotation when pressing Delete key on macOS\", async () => {\n  const { AnnotationEditorUIManager, CommandManager } = await import(\"../../src/display/editor/tools.js\");\n  const { PDFDocument, Page } = await import(\"../../src/core/document.js\");\n  const { Annotation, AnnotationStorage } = await import(\"../../src/display/annotation_storage.js\");\n\n  // Setup test document and annotation\n  const pdf = new PDFDocument();\n  const page = new Page(pdf, 1);\n  const annotation = new Annotation(Annotation.Type.UNDERLINE, new Dict());\n  const storage = new AnnotationStorage/pdf;\n  storage.addAnnotation(annotation, page.ref);\n\n  // Initialize editor UI manager\n  const commandManager = new CommandManager();\n  const editorUI = new AnnotationEditorUIManager({\n    commandManager,\n    annotationStorage: storage,\n    page,\n  });\n\n  // Select the annotation\n  editorUI.selectAnnotation(annotation);\n\n  // Simulate 'mac+Delete' keydown event\n  const event = {\n    key: \"Delete\",\n    keyCode: 8,\n    metaKey: true, // 'meta' key on macOS\n    preventDefault: () => {},\n  };\n\n  editorUI.sendKeys(event);\n\n  // Check if annotation was removed\n  expect(storage.getAnnotations(page.ref)).toHaveLength(0);\n});",
    "i5_gpt-4o": "it(\"should delete the selected element when pressing the Delete key on macOS\", async () => {\n  const { AnnotationEditorUIManager } = await import(\"../../src/display/editor/tools.js\");\n  const uiManager = new AnnotationEditorUIManager();\n\n  let elementDeleted = false;\n  uiManager.delete = () => {\n    elementDeleted = true;\n  };\n\n  const event = new KeyboardEvent(\"keydown\", { key: \"Delete\", metaKey: true });\n  document.dispatchEvent(event);\n\n  expect(elementDeleted).toBe(true);\n});",
    "i5_llama-3.3-70b-versatile": "it(\"should delete the selected element when pressing the Delete key on a Mac\", async () => {\n  const { AnnotationEditorUIManager } = await import(\"../../src/display/editor/tools.js\");\n  const { PDFDocument } = await import(\"../../src/core/document.js\");\n  const { PDFPage } = await import(\"../../src/core/document.js\");\n  const { Annotation } = await import(\"../../src/core/annotation.js\");\n  const { PDFViewer } = await import(\"../../web/pdf_viewer.js\");\n\n  const pdfDocument = await PDFDocument.load(await (await import(\"../../src/display/api.js\")).getDocument({ url: \"./test.pdf\" }));\n  const pdfPage = pdfDocument.getPage(1);\n  const annotation = new Annotation();\n  annotation.setPageNum(1);\n  const annotationEditorUIManager = new AnnotationEditorUIManager(new PDFViewer(), pdfDocument, pdfPage);\n  annotationEditorUIManager.selectAnnotation(annotation);\n\n  const deleteKeyEvent = new KeyboardEvent('keydown', { key: 'Delete', metaKey: true });\n  annotationEditorUIManager.handleKeyDown(deleteKeyEvent);\n\n  const selectedAnnotation = annotationEditorUIManager.getSelectedAnnotation();\n  expect(selectedAnnotation).toBeNull();\n});"
  },
  "16722": {
    "i1_deepseek-r1-distill-llama-70b": "it(\"should render poster PDFs quickly\", async () => {\n  const { PDFDocumentProxy } = await import(\"../../src/display/api.js\");\n  const { buildGetDocumentParams } = await import(\"./test_utils.js\");\n  const { PageViewport } = await import(\"../../src/display/display_utils.js\");\n  const { CMAP_URL } = await import(\"./test_utils.js\");\n\n  // Use a sample PDF with a poster image\n  const pdfPath = `${TEST_PDFS_PATH}/poster.pdf`;\n  const params = buildGetDocumentParams(pdfPath, CMAP_URL);\n  const pdfDocument = await PDFDocumentProxy.create(params);\n\n  // Get the first page\n  const page = await pdfDocument.getPage(1);\n  const viewport = new PageViewport(page, PageViewport.SCALE_100);\n\n  // Create a canvas to render to\n  const canvas = document.createElement(\"canvas\");\n  canvas.width = viewport.width;\n  canvas.height = viewport.height;\n  const ctx = canvas.getContext(\"2d\");\n\n  // Measure the rendering time\n  const startTime = Date.now();\n  await page.render({\n    canvasContext: ctx,\n    viewport,\n    renderInteractive: false,\n  });\n  const endTime = Date.now();\n  const renderTime = endTime - startTime;\n\n  // Verify that rendering is fast enough\n  expect(renderTime).toBeLessThan(500);\n});",
    "i1_gpt-4o": "it(\"should render poster PDF without slow performance due to filter settings\", async () => {\n  const { getDocument, PDFPageProxy } = await import(\"../../src/display/api.js\");\n  const { DefaultCanvasFactory } = await import(\"../../src/display/api.js\");\n\n  const loadingTask = getDocument(buildGetDocumentParams(\"poster.pdf\"));\n  const pdfDocument = await loadingTask.promise;\n  const page = await pdfDocument.getPage(1);\n  const viewport = page.getViewport({ scale: 1.0 });\n  const canvasFactory = new DefaultCanvasFactory();\n  const canvasAndContext = canvasFactory.create(viewport.width, viewport.height);\n  const renderTask = page.render({\n    canvasContext: canvasAndContext.context,\n    viewport,\n  });\n\n  const startTime = performance.now();\n  await renderTask.promise;\n  const endTime = performance.now();\n  const renderTime = endTime - startTime;\n\n  const expectedMaxRenderTime = 1000; // 1 second\n  expect(renderTime).toBeLessThan(expectedMaxRenderTime);\n\n  canvasFactory.destroy(canvasAndContext);\n});",
    "i1_llama-3.3-70b-versatile": "it(\"should render poster PDF without significant delay\", async () => {\n  const { PDFDocumentProxy, PDFPageProxy, PDFWorkerUtil } = await import(\"../../src/display/api.js\");\n  const { buildGetDocumentParams } = await import(\"./test_utils.js\");\n  const { PageViewport } = await import(\"../../src/display/display_utils.js\");\n  const params = buildGetDocumentParams(`${TEST_PDFS_PATH}/poster.pdf`);\n  const pdfDoc = await PDFDocumentProxy.load(params);\n  const pdfPage = await pdfDoc.getPage(1);\n  const viewport = new PageViewport({ pdfPage, scale: 1 });\n  const renderTask = pdfPage.render({\n    viewport,\n    canvasContext: null,\n    renderInteractiveForms: false,\n    continueCallback: null,\n  });\n  const startTime = performance.now();\n  await renderTask.promise;\n  const endTime = performance.now();\n  const renderTime = endTime - startTime;\n  expect(renderTime).toBeLessThan(500);\n});",
    "i2_deepseek-r1-distill-llama-70b": "it(\"should improve rendering performance by avoiding unnecessary filter operations\", async () => {\n  const { PDFDocument } = await import(\"../../src/core/document.js\");\n  const { PDFPage } = await import(\"../../src/core/document.js\");\n  const { getBlob } = await import(\"../../src/shared/util.js\");\n  const { createIdFactory } = await import(\"../../src/display/canvas.js\");\n\n  // Create a test PDF with multiple pages to trigger the rendering path\n  const pdfBytes = new Uint8Array([\n    0x25, 0x50, 0x44, 0x46, 0x2d, 0x31, 0x2e, 0x30, 0x0a, 0x25, 0xe2, 0xe3, 0xcf, 0xd3, 0x0a, 0x31, 0x30, 0x20, 0x41, 0x5f, 0x53, 0x50, 0x4f, 0x52, 0x54, 0x0a,\n    0x25, 0xe2, 0xe3, 0xcf, 0xd3, 0x0a, 0x31, 0x30, 0x20, 0x4a, 0x41, 0x53, 0x30, 0x0a, 0x0a, 0x28, 0x0a, 0x46, 0x49, 0x4c, 0x45, 0x0a,\n    0x32, 0x30, 0x20, 0x4f, 0x62, 0x6a, 0x0a, 0x3c, 0x0a, 0x78, 0x0a, 0x32, 0x30, 0x20, 0x52, 0x45, 0x44, 0x0a, 0x3e, 0x0a, 0x0a,\n    0x74, 0x72, 0x61, 0x69, 0x6c, 0x65, 0x72, 0x0a, 0x3c, 0x0a, 0x78, 0x0a, 0x32, 0x30, 0x20, 0x55, 0x49, 0x44, 0x0a,\n    0x3e, 0x0a\n  ]);\n\n  // Load the test PDF\n  const pdf = await PDFDocument.load(getBlob(pdfBytes), { createIdFactory });\n\n  // Measure rendering time\n  const startTime = performance.now();\n  const numPages = pdf.numPages;\n\n  for (let i = 0; i < numPages; i++) {\n    const page = await pdf.getPage(i + 1);\n    await page.render({\n      canvasContext: new Canvas(),\n      viewport: page.getViewport({ scale: 1 })\n    });\n  }\n\n  const endTime = performance.now();\n  const renderTime = endTime - startTime;\n\n  // The threshold is set to 500ms - adjust based on expected performance gains\n  expect(renderTime).toBeLessThan(500);\n});",
    "i2_gpt-4o": "it(\"should not change the filter to none if its already none or\", async () => {\n  const { PDFPageProxy, getDocument } = await import(\"../../src/display/api.js\");\n  const { DOMCanvasFactory } = await import(\"../../src/display/display_utils.js\");\n\n  const loadingTask = getDocument(\"test/pdfs/sample.pdf\");\n  const pdfDocument = await loadingTask.promise;\n  const page = await pdfDocument.getPage(1);\n\n  const canvasFactory = new DOMCanvasFactory();\n  const viewport = page.getViewport({ scale: 1.0 });\n  const canvasAndContext = canvasFactory.create(viewport.width, viewport.height);\n  const renderContext = {\n    canvasContext: canvasAndContext.context,\n    viewport: viewport,\n    canvasFactory: canvasFactory,\n  };\n\n  const originalFilter = canvasAndContext.context.filter;\n  await page.render(renderContext).promise;\n  const finalFilter = canvasAndContext.context.filter;\n\n  expect(finalFilter).toBe(originalFilter);\n});",
    "i2_llama-3.3-70b-versatile": "it(\"should not uselessly change the filter when drawing\", async () => {\n  const { CanvasGraphics } = await import(\"../../src/display/canvas.js\");\n  const { DOMCanvasFactory } = await import(\"../../src/display/display_utils.js\");\n  const canvasFactory = new DOMCanvasFactory();\n  const canvas = canvasFactory.createCanvas(100, 100);\n  const ctx = canvas.getContext('2d');\n  const graphics = new CanvasGraphics(ctx, {}, {}, canvasFactory, null, {}, {}, {});\n  const originalFilter = ctx.filter;\n  graphics.paintInlineImageXObject({ width: 10, height: 10, data: new Uint8ClampedArray(100) });\n  const newFilter = ctx.filter;\n  expect(newFilter).toBe(originalFilter);\n});",
    "i3_deepseek-r1-distill-llama-70b": "it(\"should render poster PDF quickly\", async () => {\n  const { performance } = await import(\"perf_hooks\");\n  const pdfPath = `${TEST_PDFS_PATH}/poster.pdf`;\n  const pdf = await getDocument(buildGetDocumentParams(pdfPath, new PDFDocumentLoadingTask(new PDFDataRangeTransport(new DefaultFileReaderFactory()))));\n  const page = (await pdf.getPages())[0];\n  const viewport = page.getViewport({ scale: 1 });\n\n  const canvas = document.createElement(\"canvas\");\n  const context = canvas.getContext(\"2d\");\n  canvas.width = viewport.width;\n  canvas.height = viewport.height;\n\n  const renderTask = new RenderTask();\n  renderTask.rasterizer = new PDFWorker();\n  renderTask.render = new RenderTask();\n  renderTask.renderCanvasContext = context;\n  renderTask.renderViewport = viewport;\n\n  const startTime = performance.now();\n  await page.render(renderTask);\n  const endTime = performance.now();\n\n  expect(endTime - startTime).toBeLessThan(100);\n});",
    "i3_gpt-4o": "it(\"should render poster PDF without slow performance\", async () => {\n  const { getDocument } = await import(\"../../src/display/api.js\");\n  const { DefaultCanvasFactory } = await import(\"../../src/display/api.js\");\n  const loadingTask = getDocument(buildGetDocumentParams(\"poster.pdf\"));\n  const pdfDocument = await loadingTask.promise;\n  const page = await pdfDocument.getPage(1);\n  const viewport = page.getViewport({ scale: 1.0 });\n  const canvasFactory = new DefaultCanvasFactory();\n  const canvasAndContext = canvasFactory.create(viewport.width, viewport.height);\n  const renderTask = page.render({\n    canvasContext: canvasAndContext.context,\n    viewport,\n  });\n  const renderTimeStart = performance.now();\n  await renderTask.promise;\n  const renderTimeEnd = performance.now();\n  const renderTime = renderTimeEnd - renderTimeStart;\n  expect(renderTime).toBeLessThan(1000); // Expect rendering to be fast\n});",
    "i3_llama-3.3-70b-versatile": "it(\"should render poster PDF without being slow on Firefox\", async () => {\n  const pdfUrl = `${TEST_PDFS_PATH}/poster.pdf`;\n  const pdfDocument = await getDocument({\n    url: pdfUrl,\n    cMapUrl: CMAP_URL,\n    cMapPacked: true,\n  });\n  const pdfPage = await pdfDocument.getPage(1);\n  const viewport = pdfPage.getViewport({ scale: 1 });\n  const renderTask = pdfPage.render({\n    viewport,\n    canvasContext: new DefaultCanvasFactory(),\n    renderInteractive: false,\n  });\n  await renderTask.promise;\n  const canvas = renderTask.canvas;\n  expect(canvas).not.toBeNull();\n});",
    "i4_deepseek-r1-distill-llama-70b": "it(\"should improve poster PDF rendering performance by optimizing filter handling\", async () => {\n  const { resetCtxToDefault } = await import(\"../../src/display/canvas.js\");\n\n  // Create test canvases\n  const canvasBefore = document.createElement('canvas');\n  const ctxBefore = canvasBefore.getContext('2d');\n  const canvasAfter = document.createElement('canvas');\n  const ctxAfter = canvasAfter.getContext('2d');\n\n  // Set up initial filter state\n  ctxBefore.filter = \"blur(5px)\";\n  ctxAfter.filter = \"blur(5px)\";\n\n  // Define test function\n  function testResetFilter(ctx) {\n    const start = performance.now();\n    resetCtxToDefault(ctx);\n    return performance.now() - start;\n  }\n\n  // Measure execution time before patch\n  const beforeTime = testResetFilter(ctxBefore);\n\n  // Measure execution time after patch\n  const afterTime = testResetFilter(ctxAfter);\n\n  // Verify performance improvement\n  expect(afterTime).to.be.lessThan(beforeTime);\n});",
    "i4_gpt-4o": "it(\"should reset ctxfilter to none only if its not already none or empty\", async () => {\n  const { CanvasGraphics } = await import(\"../../src/display/canvas.js\");\n  const { DOMCanvasFactory } = await import(\"../../src/display/display_utils.js\");\n\n  const canvasFactory = new DOMCanvasFactory();\n  const canvasAndCtx = canvasFactory.create(100, 100);\n  const ctx = canvasAndCtx.context;\n  const canvasGraphics = new CanvasGraphics(ctx, null, null, canvasFactory, null, {});\n\n  ctx.filter = \"blur(5px)\";\n  canvasGraphics.beginDrawing({ transform: null, viewport: { transform: [1, 0, 0, 1, 0, 0], scale: 1 } });\n  const actualFilter = ctx.filter;\n  const expectedFilter = \"none\";\n\n  expect(actualFilter).toBe(expectedFilter);\n});",
    "i4_llama-3.3-70b-versatile": "it(\"should render poster PDF without being slow on Firefox\", async () => {\n  const { PDFDocument } = await import(\"../../src/display/api.js\");\n  const { createIdFactory } = await import(\"./test_utils.js\");\n  const pdf = await PDFDocument.load(await fetch(\"path_to_poster_pdf.pdf\").then(res => res.arrayBuffer()));\n  const idFactory = createIdFactory();\n  const canvas = document.createElement(\"canvas\");\n  const ctx = canvas.getContext(\"2d\");\n  const canvasGraphics = new (await import(\"../../src/display/canvas.js\")).CanvasGraphics(ctx, {}, {}, {}, {}, {});\n  const page = await pdf.getPage(1);\n  await page.render({ canvasContext: ctx, viewport: page.getViewport(1) });\n  expect(canvas.toDataURL()).not.toBeNull();\n});",
    "i5_deepseek-r1-distill-llama-70b": "it(\"should improve performance when rendering PDF with poster\", async () => {\n  const { getDocument } = await import(\"../../src/display/api.js\");\n  const TEST_PDF_PATH = \"./test.pdf\";\n\n  // Create test PDF with poster image\n  const pdfDoc = await getDocument(TEST_PDF_PATH);\n  const page = await pdfDoc.getPage(1);\n  const viewport = page.getViewport({ scale: 1 });\n\n  // Create canvas to measure rendering time\n  const canvas = document.createElement(\"canvas\");\n  const ctx = canvas.getContext(\"2d\");\n  canvas.width = viewport.width;\n  canvas.height = viewport.height;\n\n  // Measure rendering time before patch\n  console.time(\"renderBefore\");\n  await page.render({\n    canvasContext: ctx,\n    viewport: viewport,\n    renderInteractive: false\n  });\n  console.timeEnd(\"renderBefore\");\n\n  // Apply patch and measure again\n  const originalFilter = ctx.filter;\n  ctx.filter = \"some-filter\";\n\n  console.time(\"renderAfter\");\n  await page.render({\n    canvasContext: ctx,\n    viewport: viewport,\n    renderInteractive: false\n  });\n  console.timeEnd(\"renderAfter\");\n\n  // Verify performance improvement\n  const renderBeforeTime = performance.getEntriesByName(\"renderBefore\")[0].duration;\n  const renderAfterTime = performance.getEntriesByName(\"renderAfter\")[0].duration;\n\n  expect(renderAfterTime).toBeLessThan(renderBeforeTime);\n});",
    "i5_gpt-4o": "it(\"should reset the canvas filter to none if its not none or empty\", async () => {\n  const { DOMCanvasFactory } = await import(\"../../src/display/display_utils.js\");\n  const canvasFactory = new DOMCanvasFactory();\n  const canvasAndCtx = canvasFactory.create(100, 100);\n  const ctx = canvasAndCtx.context;\n\n  ctx.filter = \"blur(5px)\";\n  const expectedFilter = \"none\";\n\n  const { resetCtxToDefault } = await import(\"../../src/display/canvas.js\");\n  resetCtxToDefault(ctx);\n\n  const actualFilter = ctx.filter;\n  expect(actualFilter).toBe(expectedFilter);\n});",
    "i5_llama-3.3-70b-versatile": "it(\"should render poster PDF quickly in Firefox\", async () => {\n  const { PDFDocument, PDFPageProxy } = await import(\"../../src/display/api.js\");\n  const { PDFFetchStream } = await import(\"../../src/display/fetch_stream.js\");\n  const { getFilenameFromUrl } = await import(\"../../src/display/display_utils.js\");\n  const { TEST_PDFS_PATH } = await import(\"./test_utils.js\");\n\n  const pdfUrl = `${TEST_PDFS_PATH}poster.pdf`;\n  const pdfFilename = getFilenameFromUrl(pdfUrl);\n  const pdfDocument = await PDFDocument.load({ url: pdfUrl, cMapUrl: \"\", cMapPacked: true, fetch: PDFFetchStream });\n  const pdfPage = await pdfDocument.getPage(1);\n  const renderTask = pdfPage.render({ viewport: pdfPage.getViewport({ scale: 1 }) });\n  const startTime = Date.now();\n  await renderTask.promise;\n  const endTime = Date.now();\n  const renderTime = endTime - startTime;\n  const expectedRenderTime = 1000; // 1 second\n  if (renderTime > expectedRenderTime) {\n    throw new Error(`Rendering poster PDF took too long: ${renderTime}ms`);\n  }\n});"
  },
  "16732": {
    "i1_deepseek-r1-distill-llama-70b": "it(\"should change cursor when resizing from different edges\", async () => {\n  const { PDFDocument } = await import(\"../../src/core/document.js\");\n  const { AnnotationEditorUIManager } = await import(\"../../src/display/editor/tools.js\");\n  const { PDFViewer } = await import(\"../../src/display/display_utils.js\");\n  const { AnnotationEditor } = await import(\"../../src/display/editor/editor.js\");\n\n  const pdf = await PDFDocument.load(\n    new Uint8Array(await (await fetch(\"test.pdf\")).arrayBuffer())\n  );\n  const viewer = new PDFViewer/pdf();\n  const uiManager = new AnnotationEditorUIManager(viewer);\n  const editor = new AnnotationEditor({\n    parent: viewer,\n    uiManager: uiManager,\n    type: AnnotationEditorType.INITIAL,\n    id: \"test-editor\",\n    name: \"test-editor\",\n  });\n\n  editor.makeResizable();\n  editor.select();\n\n  const page = pdf.getPage(0);\n  const viewport = page.getViewPort();\n\n  const resizers = editor.div.querySelectorAll(\".resizer\");\n  const cursorStyles = {\n    topLeft: \"nwse-resize\",\n    topRight: \"nesw-resize\",\n    bottomRight: \"nwse-resize\",\n    bottomLeft: \"nesw-resize\",\n  };\n\n  for (const resizer of resizers) {\n    const name = resizer.classList[1];\n    const event = new PointerEvent(\"pointerdown\", {\n      bubbles: true,\n      cancelable: true,\n      clientX: 0,\n      clientY: 0,\n    });\n\n    resizer.dispatchEvent(event);\n    await new Promise(resolve => setTimeout(resolve, 100));\n\n    const cursor = window.getComputedStyle(resizer).cursor;\n    expect(cursor).toBe(cursorStyles[name]);\n  }\n});",
    "i1_gpt-4o": "it(\"should change mouse cursor state according to the edge when resizing images and drawings in PDF\", async () => {\n  const { AnnotationEditor } = await import(\"../../src/display/editor/editor.js\");\n  const { InkEditor } = await import(\"../../src/display/editor/ink.js\");\n  const { StampEditor } = await import(\"../../src/display/editor/stamp.js\");\n\n  const mockUIManager = { viewParameters: { rotation: 0 } };\n  const mockParent = { viewport: { rotation: 0, rawDims: { pageWidth: 100, pageHeight: 100, pageX: 0, pageY: 0 } }, pageIndex: 0 };\n\n  const inkEditor = new InkEditor({ parent: mockParent, uiManager: mockUIManager, x: 10, y: 10 });\n  const stampEditor = new StampEditor({ parent: mockParent, uiManager: mockUIManager, x: 10, y: 10, bitmapUrl: \"\" });\n\n  inkEditor.select();\n  stampEditor.select();\n\n  const inkResizers = inkEditor.div.querySelectorAll(\".resizer\");\n  const stampResizers = stampEditor.div.querySelectorAll(\".resizer\");\n\n  expect(inkResizers.length).toBeGreaterThan(0);\n  expect(stampResizers.length).toBeGreaterThan(0);\n\n  inkResizers.forEach(resizer => {\n    expect(getComputedStyle(resizer).cursor).toMatch(/resize/);\n  });\n\n  stampResizers.forEach(resizer => {\n    expect(getComputedStyle(resizer).cursor).toMatch(/resize/);\n  });\n});",
    "i1_llama-3.3-70b-versatile": "it(\"should change the mouse cursor state according to the edge we resize it from for added images and drawings in PDF documents\", async () => {\n  const { AnnotationEditor } = await import(\"../../src/display/editor/editor.js\");\n  const { AnnotationEditorUIManager } = await import(\"../../src/display/editor/tools.js\");\n  const editor = new AnnotationEditor({ uiManager: new AnnotationEditorUIManager() });\n  editor.makeResizable();\n  const resizerDiv = editor.#resizersDiv;\n  const topLeftResizer = resizerDiv.querySelector(\".resizer.topLeft\");\n  const topRightResizer = resizerDiv.querySelector(\".resizer.topRight\");\n  const bottomLeftResizer = resizerDiv.querySelector(\".resizer.bottomLeft\");\n  const bottomRightResizer = resizerDiv.querySelector(\".resizer.bottomRight\");\n  const cursorBefore = globalThis.getComputedStyle(topLeftResizer).cursor;\n  editor.#resizerPointerdown(\"topLeft\", { clientX: 0, clientY: 0 });\n  const cursorAfter = globalThis.getComputedStyle(topLeftResizer).cursor;\n  expect(cursorAfter).not.toBe(cursorBefore);\n});",
    "i2_deepseek-r1-distill-llama-70b": "it(\"should change mouse cursor when resizing from different edges\", async () => {\n  const { PDFDocument } = await import(\"../../src/core/pdf_document.js\");\n  const { PDFPage } = await import(\"../../src/core/pdf_page.js\");\n  const { AnnotationEditor } = await import(\"../../src/display/editor/editor.js\");\n\n  // Create a mock PDF document with a page\n  const pdf = new PDFDocument({\n    length: 1,\n    getInputStream: () => new ReadableStream({\n      start(controller) { controller.close(); }\n    }),\n    get page() {\n      return new PDFPage({\n        pageIndex: 0,\n        getInputStream: () => new ReadableStream({\n          start(controller) { controller.close(); }\n        }),\n        getAnnotations: () => [],\n        get viewport() {\n          return {\n            width: 100,\n            height: 100,\n            rotation: 0,\n          };\n        },\n      });\n    },\n  });\n\n  // Create an editor for an image annotation\n  const editor = new AnnotationEditor({\n    parent: pdf.getPage(0),\n    parentDimensions: [100, 100],\n    x: 0,\n    y: 0,\n    width: 50,\n    height: 50,\n    uiManager: {\n      stopUndoAccumulation: () => {},\n    },\n  });\n\n  // Initialize the editor and make it resizable\n  editor.select();\n  editor.makeResizable();\n\n  // Check cursor styles for different resizers\n  const resizers = editor.#resizersDiv.querySelectorAll(\".resizer\");\n  expect(resizers[0].style.cursor).toBe(\"nwse-resize\"); // topLeft\n  expect(resizers[1].style.cursor).toBe(\"nesw-resize\"); // topRight\n  expect(resizers[2].style.cursor).toBe(\"nwse-resize\"); // bottomRight\n  expect(resizers[3].style.cursor).toBe(\"nesw-resize\"); // bottomLeft\n  if (resizers.length > 4) {\n    expect(resizers[4].style.cursor).toBe(\"ns-resize\"); // topMiddle\n    expect(resizers[5].style.cursor).toBe(\"ew-resize\"); // middleRight\n    expect(resizers[6].style.cursor).toBe(\"ns-resize\"); // bottomMiddle\n    expect(resizers[7].style.cursor).toBe(\"ew-resize\"); // middleLeft\n  }\n});",
    "i2_gpt-4o": "it(\"should change mouse cursor state according to the edge when resizing images and drawings in PDF\", async () => {\n  const { AnnotationEditorUIManager } = await import(\"../../src/display/editor/tools.js\");\n  const { AnnotationEditor } = await import(\"../../src/display/editor/editor.js\");\n  const { InkEditor } = await import(\"../../src/display/editor/ink.js\");\n  const { StampEditor } = await import(\"../../src/display/editor/stamp.js\");\n\n  const uiManager = new AnnotationEditorUIManager(null, null, { annotationStorage: {}, filterFactory: {} }, null);\n  const inkEditor = new InkEditor({ parent: { pageIndex: 0, viewport: { rotation: 0, rawDims: { pageWidth: 100, pageHeight: 100, pageX: 0, pageY: 0 } } }, uiManager });\n  const stampEditor = new StampEditor({ parent: { pageIndex: 0, viewport: { rotation: 0, rawDims: { pageWidth: 100, pageHeight: 100, pageX: 0, pageY: 0 } } }, uiManager, bitmapUrl: \"\" });\n\n  inkEditor.select();\n  stampEditor.select();\n\n  const inkResizers = inkEditor.div.querySelectorAll(\".resizer\");\n  const stampResizers = stampEditor.div.querySelectorAll(\".resizer\");\n\n  const expectedCursorStyles = [\"nwse-resize\", \"nesw-resize\", \"nwse-resize\", \"nesw-resize\", \"ns-resize\", \"ew-resize\", \"ns-resize\", \"ew-resize\"];\n  const actualInkCursorStyles = Array.from(inkResizers).map(resizer => window.getComputedStyle(resizer).cursor);\n  const actualStampCursorStyles = Array.from(stampResizers).map(resizer => window.getComputedStyle(resizer).cursor);\n\n  expect(actualInkCursorStyles).toEqual(expectedCursorStyles);\n  expect(actualStampCursorStyles).toEqual(expectedCursorStyles);\n});",
    "i2_llama-3.3-70b-versatile": "it(\"should change the mouse cursor state according to the edge we resize it from for added images and drawings in PDF documents\", async () => {\n  const { AnnotationEditor, AnnotationEditorUIManager } = await import(\"../../src/display/editor/editor.js\");\n  const { AnnotationEditorType } = await import(\"../../src/shared/util.js\");\n  const { InkEditor } = await import(\"../../src/display/editor/ink.js\");\n  const { StampEditor } = await import(\"../../src/display/editor/stamp.js\");\n\n  const annotationEditorUIManager = new AnnotationEditorUIManager();\n  const inkEditor = new InkEditor();\n  const stampEditor = new StampEditor();\n\n  annotationEditorUIManager.mode = AnnotationEditorType.INK;\n  inkEditor.makeResizable();\n  stampEditor.makeResizable();\n\n  const expectedCursor = \"nwse-resize\";\n  const actualCursorInk = inkEditor.div.style.cursor;\n  const actualCursorStamp = stampEditor.div.style.cursor;\n\n  expect(actualCursorInk).toBe(expectedCursor);\n  expect(actualCursorStamp).toBe(expectedCursor);\n});",
    "i3_deepseek-r1-distill-llama-70b": "it(\"should change cursor when hovering over resizer edges\", async () => {\n  const { AnnotationEditor } = await import(\"../../src/display/editor/editor.js\");\n  const editor = new AnnotationEditor({\n    parent: { pageDimensions: [100, 100] },\n    uiManager: {},\n    parent: {},\n    id: \"test-editor\",\n    x: 0,\n    y: 0,\n  });\n  editor.makeResizable();\n\n  const expectedCursor = {\n    \"topLeft\": \"nwse-resize\",\n    \"topRight\": \"nesw-resize\",\n    \"bottomRight\": \"nwse-resize\",\n    \"bottomLeft\": \"nesw-resize\",\n    \"topMiddle\": \"ns-resize\",\n    \"middleRight\": \"ew-resize\",\n    \"bottomMiddle\": \"ns-resize\",\n    \"middleLeft\": \"ew-resize\",\n  };\n\n  const resizers = editor.#resizersDiv.querySelectorAll(\".resizer\");\n  for (const [name, resizer] of Object.entries(expectedCursor)) {\n    const style = getComputedStyle(resizer);\n    expect(style.cursor).toBe(name);\n  }\n});",
    "i3_gpt-4o": "it(\"should change mouse cursor state according to the edge we resize from\", async () => {\n  const { AnnotationEditor } = await import(\"../../src/display/editor/editor.js\");\n  const { AnnotationEditorUIManager } = await import(\"../../src/display/editor/tools.js\");\n\n  const uiManager = new AnnotationEditorUIManager(null, null, null, null);\n  const editor = new AnnotationEditor({\n    uiManager,\n    parent: { pageIndex: 0, viewport: { rotation: 0, rawDims: { pageWidth: 100, pageHeight: 100, pageX: 0, pageY: 0 } } },\n    id: \"test-editor\",\n    x: 0,\n    y: 0,\n  });\n\n  editor.render();\n  editor.select();\n\n  const resizers = editor.div.querySelectorAll(\".resizer\");\n  const cursorStates = Array.from(resizers).map(resizer => window.getComputedStyle(resizer).cursor);\n\n  const expectedCursorStates = [\"nwse-resize\", \"nesw-resize\", \"nwse-resize\", \"nesw-resize\", \"ns-resize\", \"ew-resize\", \"ns-resize\", \"ew-resize\"];\n  expect(cursorStates).toEqual(expectedCursorStates);\n});",
    "i3_llama-3.3-70b-versatile": "it(\"should change the mouse cursor state according to the edge we resize from for added images and drawings in PDF documents\", async () => {\n  const { AnnotationEditor } = await import(\"../../src/display/editor/editor.js\");\n  const editor = new AnnotationEditor({\n    parent: { pageIndex: 0 },\n    id: \"test-editor\",\n    uiManager: { viewParameters: { realScale: 1 } },\n  });\n  editor.render();\n  const resizerPointerdown = jest.fn();\n  editor.#resizerPointerdown = resizerPointerdown;\n  const event = { preventDefault: jest.fn(), clientX: 10, clientY: 10 };\n  editor.#resizersDiv.children[0].dispatchEvent(new PointerEvent(\"pointerdown\", event));\n  expect(resizerPointerdown).toHaveBeenCalledTimes(1);\n  expect(event.preventDefault).toHaveBeenCalledTimes(1);\n});",
    "i4_deepseek-r1-distill-llama-70b": "it(\"should change cursor when resizing from different edges\", async () => {\n  const { AnnotationEditor } = await import(\"../../src/display/editor/editor.js\");\n  const { StampEditor } = await import(\"../../src/display/editor/stamp.js\");\n\n  // Mock DOM elements\n  const mockDocument = {\n    createElement: (type) => ({\n      style: {},\n      addEventListener: () => {},\n      removeEventListener: () => {},\n    }),\n  };\n\n  const editorParams = {\n    parent: {\n      div: mockDocument.createElement(\"div\"),\n      pageIndex: 0,\n      viewport: {\n        rotation: 0,\n        rawDims: {\n          pageWidth: 100,\n          pageHeight: 100,\n        },\n      },\n    },\n    uiManager: {},\n    id: \"1\",\n  };\n\n  const editor = new StampEditor(editorParams);\n  editor.width = 50;\n  editor.height = 50;\n  editor.x = 25;\n  editor.y = 25;\n\n  const expectedCursors = {\n    topLeft: \"nwse-resize\",\n    topRight: \"nesw-resize\",\n    bottomRight: \"nwse-resize\",\n    bottomLeft: \"nesw-resize\",\n    topMiddle: \"ns-resize\",\n    middleRight: \"ew-resize\",\n    bottomMiddle: \"ns-resize\",\n    middleLeft: \"ew-resize\",\n  };\n\n  for (const [edge, expectedCursor] of Object.entries(expectedCursors)) {\n    try {\n      await editor.resizeStart(edge);\n      await new Promise(resolve => setTimeout(resolve, 100));\n      expect(mockDocument.createElement(\"div\").style.cursor).toBe(expectedCursor);\n    } catch (error) {\n      fail(`Resize from ${edge} failed: ${error.message}`);\n    }\n  }\n});",
    "i4_gpt-4o": "it(\"should change mouse cursor state according to the edge we resize from\", async () => {\n  const { AnnotationEditor } = await import(\"../../src/display/editor/editor.js\");\n  const { InkEditor } = await import(\"../../src/display/editor/ink.js\");\n  const { StampEditor } = await import(\"../../src/display/editor/stamp.js\");\n\n  const mockUIManager = {\n    addToAnnotationStorage: jest.fn(),\n    addCommands: jest.fn(),\n    viewParameters: { realScale: 1, rotation: 0 },\n  };\n\n  const mockParent = {\n    pageIndex: 0,\n    viewport: {\n      rotation: 0,\n      rawDims: { pageWidth: 100, pageHeight: 100, pageX: 0, pageY: 0 },\n    },\n    div: document.createElement(\"div\"),\n  };\n\n  const inkEditor = new InkEditor({\n    parent: mockParent,\n    uiManager: mockUIManager,\n    id: \"inkEditor1\",\n    x: 10,\n    y: 10,\n  });\n\n  const stampEditor = new StampEditor({\n    parent: mockParent,\n    uiManager: mockUIManager,\n    id: \"stampEditor1\",\n    x: 20,\n    y: 20,\n  });\n\n  document.body.appendChild(mockParent.div);\n  mockParent.div.appendChild(inkEditor.render());\n  mockParent.div.appendChild(stampEditor.render());\n\n  inkEditor.select();\n  stampEditor.select();\n\n  const resizers = inkEditor.div.querySelectorAll(\".resizer\");\n  const resizerNames = Array.from(resizers).map(resizer => resizer.className);\n\n  const expectedResizerNames = [\n    \"resizer topLeft\",\n    \"resizer topRight\",\n    \"resizer bottomRight\",\n    \"resizer bottomLeft\",\n    \"resizer topMiddle\",\n    \"resizer middleRight\",\n    \"resizer bottomMiddle\",\n    \"resizer middleLeft\",\n  ];\n\n  expect(resizerNames).toEqual(expectedResizerNames);\n});",
    "i4_llama-3.3-70b-versatile": "it(\"should change the mouse cursor state according to the edge we resize it from for added images and drawings in PDF documents\", async () => {\n  const { AnnotationEditor } = await import(\"../../src/display/editor/editor.js\");\n  const editor = new AnnotationEditor({\n    parent: { pageIndex: 0, pageDimensions: [100, 100], rotation: 0 },\n    uiManager: { viewParameters: { realScale: 1, rotation: 0 } },\n    id: \"editor\",\n    name: \"editor\",\n  });\n  editor.width = 50;\n  editor.height = 50;\n  editor.x = 25;\n  editor.y = 25;\n  editor.div = { classList: { add: () => {}, remove: () => {} } };\n  editor.parent = { div: { classList: { add: () => {}, remove: () => {} } } };\n  const resizePosition = [10, 10];\n  const boundResizerPointermove = () => {};\n  const savedDraggable = true;\n  const resizingClassName = \"resizingTopLeft\";\n  const pointerMoveOptions = { passive: true, capture: true };\n  const pointerUpCallback = () => {};\n  editor.#resizerPointerdown(\"topLeft\", { clientX: 10, clientY: 10, preventDefault: () => {} });\n  editor.#resizerPointermove(\"topLeft\", { clientX: 15, clientY: 15 });\n  expect(editor.div.classList.contains(resizingClassName)).toBe(true);\n});",
    "i5_deepseek-r1-distill-llama-70b": "it(\"should change mouse cursor when resizing from different edges\", async () => {\n  const { PDFDocument, PDFViewer } = await import(\"../../src/display/api.js\");\n  const { AnnotationEditor } = await import(\"../../src/display/editor/editor.js\");\n  const { PDFPageProxy } = await import(\"../../src/display/display_utils.js\");\n  const puppeteer = await import('puppeteer');\n\n  const browser = await puppeteer.launch();\n  const page = await browser.newPage();\n  const viewer = new PDFViewer({\n    container: page.contentFrame(),\n    viewerWidth: 800,\n    viewerHeight: 600,\n  });\n\n  // Load test PDF with image\n  const pdfDoc = await PDFDocument.load(await fetch('test.pdf'));\n  const pageProxy = await pdfDoc.getPage(1);\n  await viewer.setDocument(pdfDoc);\n  await pageProxy.render({});\n\n  // Add image annotation\n  const editor = new AnnotationEditor({\n    annotationElementId: \"test-image\",\n    uiManager: new AnnotationEditorUIManager(),\n    rotation: 0,\n    x: 100,\n    y: 100,\n    width: 200,\n    height: 150,\n  });\n\n  editor.select();\n  editor.makeResizable();\n\n  // Test top-left resize\n  await page.mouse.move(100, 100);\n  await page.mouse.down();\n  await page.mouse.move(150, 150);\n  await page.mouse.up();\n\n  const cursorStyle = await page.evaluate(() => {\n    return document.querySelector('.selectedEditor').style.cursor;\n  });\n\n  expect(cursorStyle).toBe('nwse-resize');\n\n  await browser.close();\n});",
    "i5_gpt-4o": "it(\"should change mouse cursor state according to the edge we resize from\", async () => {\n  const { AnnotationEditor } = await import(\"../../src/display/editor/editor.js\");\n  const { InkEditor } = await import(\"../../src/display/editor/ink.js\");\n  const { StampEditor } = await import(\"../../src/display/editor/stamp.js\");\n\n  const mockUIManager = { stopUndoAccumulation: jest.fn() };\n  const inkEditor = new InkEditor({ uiManager: mockUIManager });\n  const stampEditor = new StampEditor({ uiManager: mockUIManager });\n\n  inkEditor.div = document.createElement(\"div\");\n  stampEditor.div = document.createElement(\"div\");\n\n  inkEditor.select();\n  stampEditor.select();\n\n  const inkResizers = inkEditor.div.querySelectorAll(\".resizer\");\n  const stampResizers = stampEditor.div.querySelectorAll(\".resizer\");\n\n  expect(inkResizers.length).toBeGreaterThan(0);\n  expect(stampResizers.length).toBeGreaterThan(0);\n\n  inkResizers.forEach(resizer => {\n    resizer.dispatchEvent(new Event(\"pointerdown\"));\n    expect(mockUIManager.stopUndoAccumulation).toHaveBeenCalled();\n  });\n\n  stampResizers.forEach(resizer => {\n    resizer.dispatchEvent(new Event(\"pointerdown\"));\n    expect(mockUIManager.stopUndoAccumulation).toHaveBeenCalled();\n  });\n});",
    "i5_llama-3.3-70b-versatile": "it(\"should change the mouse cursor state according to the edge we resize it from for added images and drawings in PDF documents\", async () => {\n  const { PDFDocument, PDFPage } = await import(\"../../src/core/document.js\");\n  const { AnnotationEditor } = await import(\"../../src/display/editor/editor.js\");\n  const { AnnotationEditorUIManager } = await import(\"../../src/display/editor/tools.js\");\n  const { PDFViewer } = await import(\"../../web/pdf_viewer.js\");\n\n  const pdfDocument = await PDFDocument.load(await fetch(\"path_to_test_pdf\").then(response => response.arrayBuffer()));\n  const pdfPage = pdfDocument.getPage(1);\n  const pdfViewer = new PDFViewer();\n  const annotationEditorUIManager = new AnnotationEditorUIManager();\n  const annotationEditor = new AnnotationEditor({ uiManager: annotationEditorUIManager });\n\n  annotationEditorUIManager.select(annotationEditor);\n  annotationEditor.makeResizable();\n\n  const resizerDiv = annotationEditor.div.querySelector(\".resizers\");\n  const topLeftResizer = resizerDiv.querySelector(\".topLeft\");\n  const topRightResizer = resizerDiv.querySelector(\".topRight\");\n  const bottomRightResizer = resizerDiv.querySelector(\".bottomRight\");\n  const bottomLeftResizer = resizerDiv.querySelector(\".bottomLeft\");\n\n  const expectedCursorStyles = {\n    topLeft: \"nwse-resize\",\n    topRight: \"nesw-resize\",\n    bottomRight: \"nwse-resize\",\n    bottomLeft: \"nesw-resize\",\n  };\n\n  const actualCursorStyles = {\n    topLeft: topLeftResizer.style.cursor,\n    topRight: topRightResizer.style.cursor,\n    bottomRight: bottomRightResizer.style.cursor,\n    bottomLeft: bottomLeftResizer.style.cursor,\n  };\n\n  expect(actualCursorStyles).toEqual(expectedCursorStyles);\n});"
  },
  "16760": {
    "i1_gpt-4o": "it(\"should render the polyglot PDFMP file without errors\", async () => {\n  const { getDocument } = await import(\"../../src/display/api.js\");\n  const loadingTask = getDocument({\n    url: \"https://github.com/mozilla/pdf.js/files/12185373/issue16759.pdf\",\n  });\n  const pdfDocument = await loadingTask.promise;\n  const pdfPage = await pdfDocument.getPage(1);\n  const viewport = pdfPage.getViewport({ scale: 1.0 });\n  const canvasFactory = new DefaultCanvasFactory();\n  const canvasAndContext = canvasFactory.create(viewport.width, viewport.height);\n  const renderTask = pdfPage.render({\n    canvasContext: canvasAndContext.context,\n    viewport,\n  });\n  await renderTask.promise;\n  expect(canvasAndContext.context.getImageData(0, 0, viewport.width, viewport.height)).toBeTruthy();\n});",
    "i1_llama-3.3-70b-versatile": "it(\"should render the PDF document without throwing an Invalid PDF structure error\", async () => {\n  const { getDocument } = await import(\"../../src/display/api.js\");\n  const pdfUrl = \"https://github.com/mozilla/pdf.js/files/12185373/issue16759.pdf\";\n  const pdfDocument = await getDocument({ url: pdfUrl });\n  const expectedError = null;\n  const actualError = pdfDocument.error;\n  expect(actualError).toBe(expectedError);\n});",
    "i2_deepseek-r1-distill-llama-70b": "it(\"should correctly parse PDFs with trailer in content streams\", async () => {\n  const { PDFDocument } = await import(\"../../src/display/api.js\");\n  const { InvalidPDFException } = await import(\"../../shared/util.js\");\n  const pdfUrl = \"https://github.com/mozilla/pdf.js/files/12185373/issue16759.pdf\";\n\n  try {\n    const pdf = await PDFDocument.load(pdfUrl);\n    await pdf.getPage(1);\n    expect().nothing();\n  } catch (error) {\n    if (error instanceof InvalidPDFException) {\n      throw new Error(\"PDF failed to load due to InvalidPDFException\");\n    }\n    throw error;\n  }\n});",
    "i2_gpt-4o": "it(\"should render the PDF document without errors\", async () => {\n  const { getDocument } = await import(\"../../src/display/api.js\");\n  const url = \"https://github.com/mozilla/pdf.js/files/12185373/issue16759.pdf\";\n  const loadingTask = getDocument(url);\n  const pdfDocument = await loadingTask.promise;\n  const page = await pdfDocument.getPage(1);\n  const viewport = page.getViewport({ scale: 1.0 });\n  const canvasFactory = new (await import(\"../../src/display/display_utils.js\")).DOMCanvasFactory();\n  const canvasAndContext = canvasFactory.create(viewport.width, viewport.height);\n  const renderTask = page.render({\n    canvasContext: canvasAndContext.context,\n    viewport: viewport,\n  });\n  await renderTask.promise;\n  expect(canvasAndContext.canvas.width).toBeGreaterThan(0);\n  expect(canvasAndContext.canvas.height).toBeGreaterThan(0);\n});",
    "i2_llama-3.3-70b-versatile": "it(\"should render the PDF file without throwing an Invalid PDF structure error\", async () => {\n  const { PDFDocument } = await import(\"../../src/core/document.js\");\n  const { PDFFetchStream } = await import(\"../../src/display/fetch_stream.js\");\n  const pdfUrl = \"https://github.com/mozilla/pdf.js/files/12185373/issue16759.pdf\";\n  const pdfStream = new PDFFetchStream(pdfUrl);\n  const pdfDocument = await PDFDocument.load({ cMapUrl: \"\", cMapPacked: true, pdf: pdfStream });\n  const expectedError = null;\n  const actualError = pdfDocument.error;\n  expect(actualError).toBe(expectedError);\n});",
    "i3_deepseek-r1-distill-llama-70b": "it(\"should correctly parse and render PDFs with nonstandard trailer structures\", async () => {\n  const { getDocument } = await import(\"../../src/display/api.js\");\n  const pdfPath = `${TEST_PDFS_PATH}/issue16759.pdf`;\n\n  try {\n    const pdfDoc = await getDocument({\n      url: pdfPath,\n      factory: new DefaultFileReaderFactory(new FetchStream()),\n      onPassword: () => PasswordResponses.CANCEL\n    });\n    const firstPage = await pdfDoc.getPage(1);\n    assert(firstPage, \"PDF page could not be loaded\");\n  } catch (error) {\n    if (error instanceof InvalidPDFException) {\n      throw new Error(\"PDF is still invalid after patch\");\n    }\n    throw error;\n  }\n});",
    "i3_gpt-4o": "it(\"should render the polyglot PDFMP file without errors\", async () => {\n  const { getDocument } = await import(\"../../src/display/api.js\");\n  const loadingTask = getDocument({\n    url: \"https://github.com/mozilla/pdf.js/files/12185373/issue16759.pdf\",\n  });\n  const pdfDocument = await loadingTask.promise;\n  const pdfPage = await pdfDocument.getPage(1);\n  const viewport = pdfPage.getViewport({ scale: 1.0 });\n  const canvasFactory = new DefaultCanvasFactory();\n  const canvasAndContext = canvasFactory.create(viewport.width, viewport.height);\n  const renderTask = pdfPage.render({\n    canvasContext: canvasAndContext.context,\n    viewport,\n  });\n  await renderTask.promise;\n  expect(canvasAndContext.canvas.width).toBeGreaterThan(0);\n  expect(canvasAndContext.canvas.height).toBeGreaterThan(0);\n});",
    "i3_llama-3.3-70b-versatile": "it(\"should render the PDF file issuepdf\", async () => {\n  const { PDFDocumentProxy } = await import(\"../../src/display/api.js\");\n  const { PDFDataRangeTransport } = await import(\"../../src/display/api.js\");\n  const pdfUrl = `${TEST_PDFS_PATH}issue16759.pdf`;\n  const pdfDocument = await PDFDocumentProxy.load({\n    url: pdfUrl,\n    cMapUrl: CMAP_URL,\n    cMapPacked: true,\n  });\n  const firstPage = await pdfDocument.getPage(1);\n  const viewport = firstPage.getViewport({ scale: 1 });\n  const renderTask = firstPage.render({\n    viewport,\n    canvasContext: null,\n    renderInteractive: false,\n  });\n  await renderTask.promise;\n});",
    "i4_deepseek-r1-distill-llama-70b": "it(\"should correctly parse PDF with nontraditional trailer structure\", async () => {\n  const { XRef } = await import(\"../../src/core/xref.js\");\n  const { PDFDocument } = await import(\"../../src/core/document.js\");\n  const pdfManager = {\n    password: null,\n    requestRange: async (begin, end) => {\n      return new Uint8Array();\n    },\n  };\n\n  const pdfData = new Uint8Array(await fetch(\"https://github.com/mozilla/pdf.js/files/12185373/issue16759.pdf\").then(res => res.arrayBuffer()));\n\n  await expect(\n    PDFDocument.load({\n      data: pdfData,\n      xref: new XRef({\n        getByte: () => 0,\n        getBytes: () => new Uint8Array(),\n        makeSubStream: () => ({ getByte: () => 0, getBytes: () => new Uint8Array() }),\n        pos: 0,\n        start: 0,\n      }, pdfManager),\n      pdfManager,\n    })\n  ).resolves.not.toThrow(XRefParseException);\n});",
    "i4_gpt-4o": "it(\"should render the polyglot PDFMP file without errors\", async () => {\n  const { getDocument } = await import(\"../../src/display/api.js\");\n  const { PDFNodeStream } = await import(\"../../src/display/node_stream.js\");\n  const { buildGetDocumentParams } = await import(\"./test_utils.js\");\n\n  const url = \"https://github.com/mozilla/pdf.js/files/12185373/issue16759.pdf\";\n  const loadingTask = getDocument(buildGetDocumentParams(url, { isNode: true, NativeImageDecoderSupport: 0 }));\n  const pdfDocument = await loadingTask.promise;\n\n  const page = await pdfDocument.getPage(1);\n  const viewport = page.getViewport({ scale: 1.0 });\n\n  const canvasFactory = new PDFNodeStream();\n  const canvasAndContext = canvasFactory.create(viewport.width, viewport.height);\n  const renderTask = page.render({\n    canvasContext: canvasAndContext.context,\n    viewport,\n  });\n\n  await renderTask.promise;\n  expect(renderTask.operatorList.fnArray.length).toBeGreaterThan(0);\n});",
    "i4_llama-3.3-70b-versatile": "it(\"should render the PDF document without throwing an error\", async () => {\n  const { PDFDocument } = await import(\"../../src/core/document.js\");\n  const { PDFFetchStream } = await import(\"../../src/display/fetch_stream.js\");\n  const pdfUrl = \"https://github.com/mozilla/pdf.js/files/12185373/issue16759.pdf\";\n  const pdfStream = new PDFFetchStream(pdfUrl);\n  const pdfDocument = await PDFDocument.load({ stream: pdfStream });\n  const expectedError = null;\n  const actualError = pdfDocument.error;\n  expect(actualError).toBe(expectedError);\n});",
    "i5_deepseek-r1-distill-llama-70b": "it(\"should correctly parse polyglot PDF with MP content\", async () => {\n  const { XRefMock, buildGetDocumentParams } = await import(\"./test_utils.js\");\n  const { InvalidPDFException } = await import(\"../../src/shared/util.js\");\n\n  // Create a mock XRef with the sample data that caused the issue\n  const xrefMock = new XRefMock();\n  xrefMock.addTrailer();\n  xrefMock.addMP3Data();\n\n  // Attempt to parse the XRef\n  const params = buildGetDocumentParams(xrefMock);\n  const xref = new XRef(params);\n\n  // The test passes if no exception is thrown\n  await expect(xref.load()).resolves.not.toThrow(InvalidPDFException);\n});",
    "i5_gpt-4o": "it(\"should render the polyglot PDFMP file without errors\", async () => {\n  const { getDocument } = await import(\"../../src/display/api.js\");\n  const url = \"https://github.com/mozilla/pdf.js/files/12185373/issue16759.pdf\";\n  const loadingTask = getDocument(url);\n  const pdfDocument = await loadingTask.promise;\n  const page = await pdfDocument.getPage(1);\n  const viewport = page.getViewport({ scale: 1.0 });\n  const canvasFactory = new (await import(\"../../src/display/display_utils.js\")).DOMCanvasFactory();\n  const canvasAndContext = canvasFactory.create(viewport.width, viewport.height);\n  const renderContext = {\n    canvasContext: canvasAndContext.context,\n    viewport: viewport,\n  };\n  const renderTask = page.render(renderContext);\n  await renderTask.promise;\n  expect(renderTask.operatorList.fnArray.length).toBeGreaterThan(0);\n});",
    "i5_llama-3.3-70b-versatile": "it(\"should render the PDF file without throwing an error\", async () => {\n  const { PDFDocument } = await import(\"../../src/core/document.js\");\n  const pdfUrl = \"https://github.com/mozilla/pdf.js/files/12185373/issue16759.pdf\";\n  const pdfDocument = await PDFDocument.load({ url: pdfUrl });\n  const expectedNumberOfPages = 1;\n  const actualNumberOfPages = pdfDocument.numPages;\n  expect(actualNumberOfPages).toBe(expectedNumberOfPages);\n});"
  },
  "16780": {
    "i1_deepseek-r1-distill-llama-70b": "it(\"should properly resize SVG images by removing aspect ratio preservation\", async () => {\n  const { ImageManager } = await import(\"../../src/display/editor/tools.js\");\n  const { Util } = await import(\"../../shared/util.js\");\n\n  // Create a test SVG image\n  const svgData = `<svg viewBox=\"0 0 1 1\" width=\"1\" height=\"1\" xmlns=\"http://www.w3.org/2000/svg\">\n    <rect width=\"1\" height=\"1\" style=\"fill:red;\"/>\n  </svg>`;\n  const svgUrl = `data:image/svg+xml;base64,${Util.stringToBytes(svgData).toString('base64')}`;\n\n  // Create ImageManager instance\n  const imageManager = new ImageManager();\n\n  // Fetch the image through ImageManager\n  const image = await imageManager.get(svgUrl);\n\n  // Create a canvas to test resizing\n  const canvas = new OffscreenCanvas(1, 3);\n  const ctx = canvas.getContext('2d');\n\n  // Draw the image on the canvas with resizing\n  ctx.drawImage(image.bitmap, 0, 0, 1, 1, 0, 0, 1, 3);\n\n  // Check if the image was resized correctly (red color at bottom)\n  const imageData = new Uint32Array(ctx.getImageData(0, 0, 1, 3).data.buffer);\n  const expectedColor = 0; // Transparent or resized red\n\n  expect(imageData[0]).toBe(expectedColor);\n});",
    "i1_gpt-4o": "it(\"should resize SVG images without preserving aspect ratio\", async () => {\n  const { ImageManager } = await import(\"../../src/display/editor/tools.js\");\n  const svgData = `data:image/svg+xml;charset=UTF-8,<svg viewBox=\"0 0 1 1\" width=\"1\" height=\"1\" xmlns=\"http://www.w3.org/2000/svg\"><rect width=\"1\" height=\"1\" style=\"fill:red;\"/></svg>`;\n  const imageManager = new ImageManager();\n  const data = await imageManager.#get(\"testSvg\", svgData);\n  const canvas = new OffscreenCanvas(1, 3);\n  const ctx = canvas.getContext(\"2d\");\n  ctx.drawImage(data.bitmap, 0, 0, 1, 1, 0, 0, 1, 3);\n  const pixelData = new Uint32Array(ctx.getImageData(0, 0, 1, 1).data.buffer)[0];\n  expect(pixelData).toBe(0);\n});",
    "i1_llama-3.3-70b-versatile": "it(\"should allow resizing of SVG images in pdfjs\", async () => {\n  const { ImageManager } = await import(\"../../src/display/editor/tools.js\");\n  const { Util } = await import(\"../../shared/util.js\");\n  const imageManager = new ImageManager();\n  const svgImage = new Blob([`\n    <svg xmlns=\"http://www.w3.org/2000/svg\" width=\"100\" height=\"100\">\n      <rect width=\"100\" height=\"100\" style=\"fill:rgb(0,0,255);\"/>\n    </svg>\n  `], { type: \"image/svg+xml\" });\n  const imageData = await imageManager.#get(\"svgImage\", svgImage);\n  const imageElement = imageData.bitmap;\n  const canvas = document.createElement(\"canvas\");\n  canvas.width = 200;\n  canvas.height = 200;\n  const ctx = canvas.getContext(\"2d\");\n  ctx.drawImage(imageElement, 0, 0, 200, 200);\n  const imageDataAfterResize = ctx.getImageData(0, 0, 200, 200).data;\n  const expectedImageData = new Uint8ClampedArray(200 * 200 * 4);\n  for (let i = 0; i < expectedImageData.length; i += 4) {\n    expectedImageData[i] = 0;\n    expectedImageData[i + 1] = 0;\n    expectedImageData[i + 2] = 255;\n    expectedImageData[i + 3] = 255;\n  }\n  Util.assert(imageDataAfterResize.every((value, index) => value === expectedImageData[index]), \"Image data after resize does not match expected data\");\n});",
    "i2_deepseek-r1-distill-llama-70b": "it(\"should resize SVG images without preserving aspect ratio\", async () => {\n  const { ImageManager, Util } = await import(\"../../src/display/editor/tools.js\");\n  const { stringToUTF8String } = await import(\"../../shared/util.js\");\n\n  // Create a test SVG image\n  const svg = `<svg viewBox=\"0 0 100 100\" width=\"100\" height=\"100\" xmlns=\"http://www.w3.org/2000/svg\">\n    <rect width=\"100\" height=\"100\" style=\"fill:red;\"/>\n  </svg>`;\n\n  // Create an ImageManager instance\n  const imageManager = new ImageManager();\n\n  // Use the ImageManager to get the image data\n  const imageKey = `image_${Date.now()}`;\n  const imageData = await imageManager.#get(imageKey, svg);\n\n  // Create a canvas to draw the image\n  const canvas = new OffscreenCanvas(100, 50); // Resized canvas (changed aspect ratio)\n  const ctx = canvas.getContext(\"2d\");\n\n  // Draw the image on the canvas\n  ctx.drawImage(imageData.bitmap, 0, 0, 100, 50);\n\n  // Check if the image filled the canvas without preserving aspect ratio\n  const pixels = ctx.getImageData(0, 0, 1, 1).data;\n  const isRed = pixels[0] === 255 && pixels[1] === 0 && pixels[2] === 0;\n\n  expect(isRed).toBe(true);\n});",
    "i2_gpt-4o": "it(\"should resize SVG images without preserving aspect ratio\", async () => {\n  const { ImageManager } = await import(\"../../src/display/editor/tools.js\");\n  const svgData = `data:image/svg+xml;charset=UTF-8,<svg viewBox=\"0 0 100 100\" xmlns=\"http://www.w3.org/2000/svg\"><rect width=\"100\" height=\"100\" style=\"fill:red;\"/></svg>`;\n  const imageManager = new ImageManager();\n  const data = await imageManager.#get(\"testSvg\", svgData);\n  const canvas = new OffscreenCanvas(100, 200);\n  const ctx = canvas.getContext(\"2d\");\n  ctx.drawImage(data.bitmap, 0, 0, 100, 100, 0, 0, 100, 200);\n  const imageData = ctx.getImageData(0, 150, 1, 1).data;\n  const isRed = imageData[0] === 255 && imageData[1] === 0 && imageData[2] === 0 && imageData[3] === 255;\n  expect(isRed).toBe(true);\n});",
    "i2_llama-3.3-70b-versatile": "it(\"should resize SVG images horizontallyvertically without keeping the aspect ratio\", async () => {\n  const { ImageManager } = await import(\"../../src/display/editor/tools.js\");\n  const { Util } = await import(\"../../shared/util.js\");\n  const imageManager = new ImageManager();\n  const svgImage = new Blob([`<svg width=\"100\" height=\"100\"><rect width=\"100\" height=\"100\" style=\"fill:red;\"/></svg>`], { type: 'image/svg+xml' });\n  const image = await imageManager.#get('svgImage', svgImage);\n  const imageElement = image.bitmap;\n  imageElement.width = 50;\n  imageElement.height = 200;\n  const canvas = new OffscreenCanvas(50, 200);\n  const ctx = canvas.getContext(\"2d\");\n  ctx.drawImage(imageElement, 0, 0, 50, 200);\n  const pixels = ctx.getImageData(0, 0, 50, 200).data;\n  let isResized = false;\n  for (let i = 0; i < pixels.length; i += 4) {\n    if (pixels[i] === 255 && pixels[i + 1] === 0 && pixels[i + 2] === 0) {\n      isResized = true;\n      break;\n    }\n  }\n  expect(isResized).toBe(true);\n});",
    "i3_deepseek-r1-distill-llama-70b": "it(\"should correctly resize SVG images\", async () => {\n  const { ImageManager } = await import(\"../../src/display/editor/tools.js\");\n  const { createImageBitmap } = await import(\"../../src/display/canvas.js\");\n\n  const svgData = `<svg viewBox=\"0 0 1 1\" width=\"1\" height=\"1\" xmlns=\"http://www.w3.org/2000/svg\"><rect width=\"1\" height=\"1\" style=\"fill:red;\"/></svg>`;\n  const svgUrl = `data:image/svg+xml;charset=UTF-8,${svgData}`;\n\n  const imageManager = new ImageManager();\n  const imageData = await imageManager.getFromUrl(svgUrl);\n\n  const canvas = document.createElement(\"canvas\");\n  const ctx = canvas.getContext(\"2d\");\n\n  canvas.width = 1;\n  canvas.height = 3;\n\n  const image = await createImageBitmap(imageData.bitmap);\n  ctx.drawImage(image, 0, 0, 1, 1, 0, 0, 1, 3);\n\n  const pixel = ctx.getImageData(0, 0, 1, 1).data;\n  const isRed = pixel[0] === 255 && pixel[1] === 0 && pixel[2] === 0;\n\n  expect(isRed).toBe(true);\n});",
    "i3_gpt-4o": "it(\"should resize SVG images correctly\", async () => {\n  const { ImageManager } = await import(\"../../src/display/editor/tools.js\");\n  const svgData = `data:image/svg+xml;charset=UTF-8,<svg viewBox=\"0 0 1 1\" width=\"1\" height=\"1\" xmlns=\"http://www.w3.org/2000/svg\"><rect width=\"1\" height=\"1\" style=\"fill:red;\"/></svg>`;\n  const imageManager = new ImageManager();\n  const data = await imageManager.getFromUrl(svgData);\n  const canvas = new OffscreenCanvas(1, 3);\n  const ctx = canvas.getContext(\"2d\");\n  ctx.drawImage(data.bitmap, 0, 0, 1, 1, 0, 0, 1, 3);\n  const imageData = ctx.getImageData(0, 0, 1, 1).data;\n  const isResized = new Uint32Array(imageData.buffer)[0] === 0;\n  expect(isResized).toBe(true);\n});",
    "i3_llama-3.3-70b-versatile": "it(\"should allow resizing of SVG images in pdfjs\", async () => {\n  const { AnnotationEditorUIManager, ImageManager } = await import(\"../../src/display/editor/tools.js\");\n  const { stringToBytes } = await import(\"../../src/shared/util.js\");\n  const { createIdFactory } = await import(\"./test_utils.js\");\n\n  const idFactory = createIdFactory();\n  const imageManager = new ImageManager();\n  const svgData = stringToBytes(`<svg width=\"100\" height=\"100\"><rect width=\"100\" height=\"100\" style=\"fill:red;\"/></svg>`);\n  const svgUrl = URL.createObjectURL(new Blob([svgData], { type: \"image/svg+xml\" }));\n\n  const imageData = await imageManager.getFromUrl(svgUrl);\n  const svgImage = imageData.bitmap;\n\n  const annotationEditorUIManager = new AnnotationEditorUIManager({}, {}, {}, {});\n  const imageManagerInstance = annotationEditorUIManager.imageManager;\n\n  const mustRemoveAspectRatioPromise = await ImageManager._checkIfSVGFitsInCanvas();\n  const newSvgUrl = mustRemoveAspectRatioPromise ? `${svgUrl}#svgView(preserveAspectRatio(none))` : svgUrl;\n\n  const newImageData = await imageManagerInstance.getFromUrl(newSvgUrl);\n  const newSvgImage = newImageData.bitmap;\n\n  expect(newSvgImage.width).not.toBe(100);\n  expect(newSvgImage.height).not.toBe(100);\n});",
    "i4_deepseek-r1-distill-llama-70b": "it(\"should allow SVG images to be resized by modifying their URL\", async () => {\n  const { ImageManager } = await import(\"../../src/display/editor/tools.js\");\n  const svgDataUrl = \"data:image/svg+xml;charset=UTF-8,<svg viewBox=\"0 0 1 1\" width=\"1\" height=\"1\" xmlns=\"http://www.w3.org/2000/svg\"><rect width=\"1\" height=\"1\" style=\"fill:red;\"/></svg>\";\n  const imageManager = new ImageManager();\n\n  // Process the SVG image\n  const image = await imageManager.getFromFile(new File([svgDataUrl], \"image.svg\", { type: \"image/svg+xml\" }));\n\n  // Mock the _checkIfSVGFitsInCanvas function to return true\n  const originalCheck = ImageManager._checkIfSVGFitsInCanvas;\n  ImageManager._checkIfSVGFitsInCanvas = async () => true;\n\n  // Get the processed SVG URL\n  const svgUrl = imageManager.getSvgUrl(image.id);\n\n  // Restore original function\n  ImageManager._checkIfSVGFitsInCanvas = originalCheck;\n\n  // The URL should include the preserveAspectRatio modification\n  expect(svgUrl).toContain(\"#svgView(preserveAspectRatio(none))\");\n});",
    "i4_gpt-4o": "it(\"should resize SVG images without preserving aspect ratio\", async () => {\n  const { ImageManager } = await import(\"../../src/display/editor/tools.js\");\n  const svgData = `data:image/svg+xml;charset=UTF-8,<svg viewBox=\"0 0 100 100\" xmlns=\"http://www.w3.org/2000/svg\"><rect width=\"100\" height=\"100\" style=\"fill:red;\"/></svg>`;\n  const imageManager = new ImageManager();\n  const data = await imageManager.getFromUrl(svgData);\n  const canvas = new OffscreenCanvas(100, 200);\n  const ctx = canvas.getContext(\"2d\");\n  ctx.drawImage(data.bitmap, 0, 0, 100, 100, 0, 0, 100, 200);\n  const imageData = ctx.getImageData(0, 0, 1, 1).data;\n  const isResized = imageData[0] === 255 && imageData[1] === 0 && imageData[2] === 0;\n  expect(isResized).toBe(true);\n});",
    "i4_llama-3.3-70b-versatile": "it(\"should allow resizing of SVG images horizontallyvertically in pdfjs\", async () => {\n  const { ImageManager } = await import(\"../../src/display/editor/tools.js\");\n  const imageManager = new ImageManager();\n  const svg = `data:image/svg+xml;charset=UTF-8,<svg viewBox=\"0 0 1 1\" width=\"1\" height=\"1\" xmlns=\"http://www.w3.org/2000/svg\"><rect width=\"1\" height=\"1\" style=\"fill:red;\"/></svg>`;\n  const image = await imageManager.#get(svg, svg);\n  const canvas = new OffscreenCanvas(10, 10);\n  const ctx = canvas.getContext(\"2d\");\n  ctx.drawImage(image.bitmap, 0, 0, 10, 10);\n  const imageData = ctx.getImageData(0, 0, 10, 10).data;\n  const expectedColor = [255, 0, 0, 255]; // Red color\n  const actualColor = [\n    imageData[0],\n    imageData[1],\n    imageData[2],\n    imageData[3],\n  ];\n  expect(actualColor).toEqual(expectedColor);\n});",
    "i5_deepseek-r1-distill-llama-70b": "it(\"should resize SVG images correctly\", async () => {\n  const { ImageManager } = await import(\"../../src/display/editor/tools.js\");\n  const svg = `data:image/svg+xml;charset=UTF-8,<svg viewBox=\"0 0 1 1\" width=\"1\" height=\"1\" xmlns=\"http://www.w3.org/2000/svg\"><rect width=\"1\" height=\"1\" style=\"fill:red;\"/></svg>`;\n  const imageManager = new ImageManager();\n  const image = new Image();\n\n  // Simulate adding an SVG image\n  imageManager.add(image, \"test.svg\");\n\n  // Create canvas to test resizing\n  const canvas = new OffscreenCanvas(1, 3);\n  const ctx = canvas.getContext(\"2d\");\n\n  // Wait for image to load and be resized\n  await new Promise(resolve => {\n    image.onload = async () => {\n      await setTimeout(() => {\n        ctx.drawImage(image, 0, 0, 1, 1, 0, 0, 1, 3);\n        resolve();\n      }, 100);\n    };\n  });\n\n  // Check if the image was resized correctly\n  const pixels = ctx.getImageData(0, 0, 1, 1).data;\n  expect(pixels[0]).not.toBe(255); // Red pixel changed after resize\n});",
    "i5_gpt-4o": "it(\"should resize SVG images horizontally and vertically\", async () => {\n  const { ImageManager } = await import(\"../../src/display/editor/tools.js\");\n  const svgData = `data:image/svg+xml;charset=UTF-8,<svg viewBox=\"0 0 100 100\" xmlns=\"http://www.w3.org/2000/svg\"><rect width=\"100\" height=\"100\" style=\"fill:red;\"/></svg>`;\n  const canvas = new OffscreenCanvas(200, 200);\n  const ctx = canvas.getContext(\"2d\");\n  const imageElement = new Image();\n  imageElement.src = svgData;\n  await imageElement.decode();\n  ctx.drawImage(imageElement, 0, 0, 100, 100, 0, 0, 200, 200);\n  const imageData = ctx.getImageData(0, 0, 200, 200).data;\n  const isResized = Array.from(imageData).some((value, index) => index % 4 === 0 && value === 255);\n  expect(isResized).toBe(true);\n});",
    "i5_llama-3.3-70b-versatile": "it(\"should resize SVG images horizontallyvertically in pdfjs\", async () => {\n  const { PDFDocument, PDFPage } = await import(\"../../src/core/document.js\");\n  const { AnnotationEditorUIManager, ImageManager } = await import(\"../../src/display/editor/tools.js\");\n  const { createIdFactory } = await import(\"./test_utils.js\");\n\n  const pdfDoc = await PDFDocument.load(await fetch(\"path_to_test_pdf_with_svg_image.pdf\").then(res => res.arrayBuffer()));\n  const page = pdfDoc.getPage(1);\n  const imageManager = new ImageManager(createIdFactory());\n  const annotationEditorUIManager = new AnnotationEditorUIManager();\n\n  const svgImage = await imageManager.#get(\"svg_image\", \"data:image/svg+xml;charset=UTF-8,<svg viewBox=\\\"0 0 100 100\\\" width=\\\"100\\\" height=\\\"100\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><rect width=\\\"100\\\" height=\\\"100\\\" style=\\\"fill:red;\"/></svg>\");\n  const imageElement = new Image();\n  imageElement.src = svgImage.svgUrl;\n\n  const mustRemoveAspectRatioPromise = ImageManager._checkIfSVGFitsInCanvas();\n  const url = await mustRemoveAspectRatioPromise ? `${svgImage.svgUrl}#svgView(preserveAspectRatio(none))` : svgImage.svgUrl;\n  imageElement.src = url;\n\n  const expectedWidth = 50;\n  const expectedHeight = 50;\n  imageElement.width = expectedWidth;\n  imageElement.height = expectedHeight;\n\n  const actualWidth = imageElement.width;\n  const actualHeight = imageElement.height;\n\n  expect(actualWidth).toBe(expectedWidth);\n  expect(actualHeight).toBe(expectedHeight);\n});"
  },
  "16784": {
    "i1_deepseek-r1-distill-llama-70b": "it(\"should resize SVG images without preserving aspect ratio\", async () => {\n  const { ImageManager } = await import(\"../../src/display/editor/tools.js\");\n  const { DOMCanvasFactory } = await import(\"../display_utils.js\");\n\n  const canvas = DOMCanvasFactory.createCanvas(100, 100);\n  const ctx = canvas.getContext(\"2d\");\n\n  const imageManager = new ImageManager();\n  const svgData = `<svg viewBox=\"0 0 1 1\" width=\"1\" height=\"1\" xmlns=\"http://www.w3.org/2000/svg\">\n    <rect width=\"1\" height=\"1\" style=\"fill:red;\"/>\n  </svg>`;\n\n  const image = await imageManager.get(\"test-svg\", svgData);\n  if (!image) {\n    throw new Error(\"Failed to load SVG image\");\n  }\n\n  ctx.drawImage(image.bitmap, 0, 0, 100, 100);\n\n  const pixel = ctx.getImageData(0, 0, 1, 1).data;\n  // Red color in RGB\n  const isRed = pixel[0] === 255 && pixel[1] === 0 && pixel[2] === 0;\n  expect(isRed).toBe(true);\n});",
    "i1_gpt-4o": "it(\"should allow SVG images to be resized without preserving aspect ratio\", async () => {\n  const { ImageManager } = await import(\"../../src/display/editor/tools.js\");\n  const svgData = `data:image/svg+xml;charset=UTF-8,<svg viewBox=\"0 0 1 1\" width=\"1\" height=\"1\" xmlns=\"http://www.w3.org/2000/svg\"><rect width=\"1\" height=\"1\" style=\"fill:red;\"/></svg>`;\n  const imageManager = new ImageManager();\n  const data = await imageManager.#get(\"testSvg\", svgData);\n  const canvas = new OffscreenCanvas(2, 2);\n  const ctx = canvas.getContext(\"2d\");\n  ctx.drawImage(data.bitmap, 0, 0, 2, 2);\n  const imageData = ctx.getImageData(0, 0, 2, 2).data;\n  const isResized = imageData[0] === 255 && imageData[4] === 255 && imageData[8] === 255 && imageData[12] === 255;\n  expect(isResized).toBe(true);\n});",
    "i1_llama-3.3-70b-versatile": "it(\"should allow resizing of SVG images horizontallyvertically in pdfjs\", async () => {\n  const { ImageManager } = await import(\"../../src/display/editor/tools.js\");\n  const { Util } = await import(\"../../shared/util.js\");\n  const imageManager = new ImageManager();\n  const svgImage = new Blob([`<svg width=\"100\" height=\"100\"><rect width=\"100\" height=\"100\" style=\"fill:red;\"/></svg>`], { type: \"image/svg+xml\" });\n  const imageData = await imageManager.#get(\"svgImage\", svgImage);\n  const imageElement = imageData.bitmap;\n  imageElement.width = 200;\n  imageElement.height = 200;\n  const expectedWidth = 200;\n  const expectedHeight = 200;\n  const actualWidth = imageElement.width;\n  const actualHeight = imageElement.height;\n  Util.assert(actualWidth === expectedWidth, `Expected width to be ${expectedWidth}, but got ${actualWidth}`);\n  Util.assert(actualHeight === expectedHeight, `Expected height to be ${expectedHeight}, but got ${actualHeight}`);\n});",
    "i2_deepseek-r1-distill-llama-70b": "it(\"should correctly resize SVG images\", async () => {\n  const { ImageManager } = await import(\"../../src/display/editor/tools.js\");\n  const svg = new Blob(['<svg viewBox=\"0 0 100 100\"><rect width=\"100\" height=\"100\" style=\"fill:red;\"/></svg>'], { type: 'image/svg+xml' });\n  const manager = new ImageManager();\n  const image = await manager.#get('test-svg', svg);\n\n  const canvas = new OffscreenCanvas(50, 50);\n  const ctx = canvas.getContext('2d');\n  ctx.drawImage(image.bitmap, 0, 0, 50, 50);\n\n  const expectedWidth = 50;\n  const expectedHeight = 50;\n  const actualWidth = canvas.width;\n  const actualHeight = canvas.height;\n\n  expect(actualWidth).toBe(expectedWidth);\n  expect(actualHeight).toBe(expectedHeight);\n});",
    "i2_gpt-4o": "it(\"should allow SVG images to be resized horizontallyvertically\", async () => {\n  const { shadow } = await import(\"../../src/shared/util.js\");\n  const { ImageManager } = await import(\"../../src/display/editor/tools.js\");\n\n  const svgImage = `data:image/svg+xml;charset=UTF-8,<svg viewBox=\"0 0 1 1\" width=\"1\" height=\"1\" xmlns=\"http://www.w3.org/2000/svg\"><rect width=\"1\" height=\"1\" style=\"fill:red;\"/></svg>`;\n  const canvas = new OffscreenCanvas(1, 3);\n  const ctx = canvas.getContext(\"2d\");\n  const image = new Image();\n  image.src = svgImage;\n\n  const promise = image.decode().then(() => {\n    ctx.drawImage(image, 0, 0, 1, 1, 0, 0, 1, 3);\n    return new Uint32Array(ctx.getImageData(0, 0, 1, 1).data.buffer)[0] === 0;\n  });\n\n  const expected = await promise;\n  const actual = await ImageManager._isSVGFittingCanvas;\n  expect(actual).toBe(expected);\n});",
    "i2_llama-3.3-70b-versatile": "it(\"should allow resizing of SVG images horizontallyvertically in pdfjs\", async () => {\n  const { ImageManager } = await import(\"../../src/display/editor/tools.js\");\n  const { Util } = await import(\"../../shared/util.js\");\n  const imageManager = new ImageManager();\n  const svgImage = new Blob([`<svg viewBox=\"0 0 1 1\" width=\"1\" height=\"1\" xmlns=\"http://www.w3.org/2000/svg\"><rect width=\"1\" height=\"1\" style=\"fill:red;\"/></svg>`], { type: \"image/svg+xml\" });\n  const key = Util.stringToUTF8String(\"svgImage\");\n  const imageData = await imageManager.#get(key, svgImage);\n  const expected = true;\n  const actual = imageData.isSvg;\n  expect(actual).toBe(expected);\n});",
    "i3_deepseek-r1-distill-llama-70b": "it(\"should properly resize SVG images\", async () => {\n  const { ImageManager } = await import(\"../../src/display/editor/tools.js\");\n  const svg = `<svg viewBox=\"0 0 100 100\" width=\"100\" height=\"100\">\n    <rect width=\"100\" height=\"100\" style=\"fill:red;\"/>\n  </svg>`;\n\n  const imageManager = new ImageManager();\n  const image = await imageManager.getFromUrl(`data:image/svg+xml,${encodeURIComponent(svg)}`);\n\n  const canvas = new OffscreenCanvas(50, 50);\n  const ctx = canvas.getContext(\"2d\");\n  ctx.drawImage(image.bitmap, 0, 0, 50, 50);\n\n  const pixel = ctx.getImageData(0, 0, 1, 1).data;\n  const isRed = pixel[0] === 255 && pixel[1] === 0 && pixel[2] === 0;\n\n  expect(isRed).toBe(true);\n});",
    "i3_gpt-4o": "it(\"should allow SVG images to be resized horizontallyvertically\", async () => {\n  const { ImageManager } = await import(\"../../src/display/editor/tools.js\");\n  const svgData = `data:image/svg+xml;charset=UTF-8,<svg viewBox=\"0 0 1 1\" width=\"1\" height=\"1\" xmlns=\"http://www.w3.org/2000/svg\"><rect width=\"1\" height=\"1\" style=\"fill:red;\"/></svg>`;\n  const imageManager = new ImageManager();\n  const imageData = await imageManager.getFromUrl(svgData);\n  const canvas = new OffscreenCanvas(2, 2);\n  const ctx = canvas.getContext(\"2d\");\n  ctx.drawImage(imageData.bitmap, 0, 0, 2, 2);\n  const imageDataArray = ctx.getImageData(0, 0, 2, 2).data;\n  const isResized = imageDataArray[0] === 255 && imageDataArray[1] === 0 && imageDataArray[2] === 0;\n  expect(isResized).toBe(true);\n});",
    "i3_llama-3.3-70b-versatile": "it(\"should allow resizing of SVG images in pdfjs\", async () => {\n  const { AnnotationEditorUIManager, ImageManager } = await import(\"../../src/display/editor/tools.js\");\n  const { AnnotationEditorType } = await import(\"../../src/shared/util.js\");\n  const { createIdFactory } = await import(\"./test_utils.js\");\n\n  const idFactory = createIdFactory();\n  const imageManager = new ImageManager();\n  const annotationEditorUIManager = new AnnotationEditorUIManager(null, null, null, null);\n\n  const svgImage = new Blob([`\n    <svg xmlns=\"http://www.w3.org/2000/svg\" width=\"100\" height=\"100\">\n      <rect width=\"100\" height=\"100\" style=\"fill:rgb(0,0,255)\" />\n    </svg>\n  `], { type: \"image/svg+xml\" });\n\n  const image = await imageManager.getFromFile(svgImage);\n  const svgUrl = image.svgUrl;\n\n  const mustRemoveAspectRatioPromise = ImageManager._checkIfSVGFitsInCanvas();\n  const mustRemoveAspectRatio = await mustRemoveAspectRatioPromise;\n\n  if (mustRemoveAspectRatio) {\n    const resizedSvgUrl = `${svgUrl}#svgView(preserveAspectRatio(none))`;\n    expect(resizedSvgUrl).not.toBe(svgUrl);\n  } else {\n    expect(svgUrl).toBe(svgUrl);\n  }\n});",
    "i4_deepseek-r1-distill-llama-70b": "it(\"should resize SVG images correctly after patch\", async () => {\n  const { PDFDocument, PDFPageProxy } = await import(\"../../src/display/api.js\");\n  const { ImageManager } = await import(\"../../src/display/editor/tools.js\");\n\n  // Create a test canvas and SVG\n  const svg = `data:image/svg+xml;charset=UTF-8,<svg viewBox=\"0 0 1 1\" width=\"1\" height=\"1\" xmlns=\"http://www.w3.org/2000/svg\"><rect width=\"1\" height=\"1\" style=\"fill:red;\"/></svg>`;\n  const canvas = new OffscreenCanvas(1, 1);\n  const ctx = canvas.getContext(\"2d\");\n  const image = new Image();\n  image.src = svg;\n\n  // Draw the SVG on the canvas\n  await image.decode();\n  ctx.drawImage(image, 0, 0, 1, 1, 0, 0, 1, 1);\n\n  // Check if the SVG was resized correctly\n  const pixel = ctx.getImageData(0, 0, 1, 1).data;\n  const isRed = pixel[0] === 255 && pixel[1] === 0 && pixel[2] === 0;\n\n  // Verify the result\n  return isRed;\n});",
    "i4_gpt-4o": "it(\"should allow SVG images to be resized horizontallyvertically\", async () => {\n  const { ImageManager } = await import(\"../../src/display/editor/tools.js\");\n  const svgData = `data:image/svg+xml;charset=UTF-8,<svg viewBox=\"0 0 1 1\" width=\"1\" height=\"1\" xmlns=\"http://www.w3.org/2000/svg\"><rect width=\"1\" height=\"1\" style=\"fill:red;\"/></svg>`;\n  const imageManager = new ImageManager();\n  const image = new Image();\n  image.src = svgData;\n  await image.decode();\n  const canvas = new OffscreenCanvas(1, 3);\n  const ctx = canvas.getContext(\"2d\");\n  ctx.drawImage(image, 0, 0, 1, 1, 0, 0, 1, 3);\n  const isResized = new Uint32Array(ctx.getImageData(0, 0, 1, 1).data.buffer)[0] === 0;\n  expect(isResized).toBe(true);\n});",
    "i4_llama-3.3-70b-versatile": "it(\"should allow resizing of SVG images horizontallyvertically in pdfjs\", async () => {\n  const { ImageManager } = await import(\"../../src/display/editor/tools.js\");\n  const imageManager = new ImageManager();\n  const svgImage = new Blob([`\n    <svg viewBox=\"0 0 100 100\" width=\"100\" height=\"100\" xmlns=\"http://www.w3.org/2000/svg\">\n      <rect width=\"100\" height=\"100\" style=\"fill:red;\"/>\n    </svg>\n  `], { type: \"image/svg+xml\" });\n  const fileReader = new FileReader();\n  const imagePromise = new Promise((resolve, reject) => {\n    fileReader.onload = async () => {\n      const url = fileReader.result;\n      const imageElement = new Image();\n      imageElement.src = url;\n      await new Promise(resolve => imageElement.onload = resolve);\n      const canvas = document.createElement(\"canvas\");\n      canvas.width = 50;\n      canvas.height = 50;\n      const ctx = canvas.getContext(\"2d\");\n      ctx.drawImage(imageElement, 0, 0, 50, 50);\n      resolve(ctx.getImageData(0, 0, 1, 1).data);\n    };\n    fileReader.onerror = reject;\n  });\n  fileReader.readAsDataURL(svgImage);\n  const imageData = await imagePromise;\n  expect(imageData[0]).not.toBe(0);\n});",
    "i5_deepseek-r1-distill-llama-70b": "it(\"should correctly resize SVG images\", async () => {\n  const { PDFDocumentProxy } = await import(\"../../src/display/api.js\");\n  const { SVGGraphics } = await import(\"../../src/display/svg.js\");\n  const { createIdFactory } = await import(\"./test_utils.js\");\n\n  // Create a test SVG image\n  const svg = `<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"100\" height=\"100\"><rect width=\"100\" height=\"100\" fill=\"red\"/></svg>`;\n  const blob = new Blob([svg], { type: \"image/svg+xml\" });\n  const url = URL.createObjectURL(blob);\n\n  // Create a PDF document with the SVG image\n  const pdf = await PDFDocumentProxy.load({\n    data: new Uint8Array(),\n    fingerprint: createIdFactory(),\n    url: url,\n  });\n\n  const page = await pdf.getPage(1);\n  const viewport = page.getViewport({ scale: 1 });\n\n  // Check if the SVG image can be resized\n  const expectedWidth = 200;\n  const expectedHeight = 200;\n  const actualDimensions = await page.getImageDimensions();\n\n  expect(actualDimensions.width).toBe(expectedWidth);\n  expect(actualDimensions.height).toBe(expectedHeight);\n});",
    "i5_gpt-4o": "it(\"should allow SVG images to be resized horizontallyvertically\", async () => {\n  const { PDFDocumentProxy, getDocument } = await import(\"../../src/display/api.js\");\n  const { DOMCanvasFactory } = await import(\"../../src/display/display_utils.js\");\n\n  const loadingTask = getDocument({ url: \"path/to/svg-containing-pdf.pdf\" });\n  const pdfDocument = await loadingTask.promise;\n  const page = await pdfDocument.getPage(1);\n\n  const canvasFactory = new DOMCanvasFactory();\n  const viewport = page.getViewport({ scale: 1.0 });\n  const canvasAndContext = canvasFactory.create(viewport.width, viewport.height);\n  const renderContext = {\n    canvasContext: canvasAndContext.context,\n    viewport: viewport,\n  };\n\n  await page.render(renderContext).promise;\n\n  const canvas = canvasAndContext.canvas;\n  const initialWidth = canvas.width;\n  const initialHeight = canvas.height;\n\n  canvas.width = initialWidth * 2;\n  canvas.height = initialHeight * 2;\n\n  const resizedViewport = page.getViewport({ scale: 2.0 });\n  const resizedRenderContext = {\n    canvasContext: canvasAndContext.context,\n    viewport: resizedViewport,\n  };\n\n  await page.render(resizedRenderContext).promise;\n\n  const resizedWidth = canvas.width;\n  const resizedHeight = canvas.height;\n\n  expect(resizedWidth).toBeGreaterThan(initialWidth);\n  expect(resizedHeight).toBeGreaterThan(initialHeight);\n});",
    "i5_llama-3.3-70b-versatile": "it(\"should resize SVG images horizontallyvertically in pdfjs\", async () => {\n  const { PDFDocument, PDFPageProxy } = await import(\"../../src/display/api.js\");\n  const { createValidAbsoluteUrl } = await import(\"../../src/shared/util.js\");\n  const url = createValidAbsoluteUrl(\"path/to/svg/image.svg\");\n  const pdfDoc = await PDFDocument.load(url);\n  const page = await pdfDoc.getPage(1);\n  const svgImage = await page.getOperatorList().then((operatorList) => {\n    for (const op of operatorList) {\n      if (op.type === \"drawImage\" && op.image.type === \"image/svg+xml\") {\n        return op.image;\n      }\n    }\n  });\n  const originalWidth = svgImage.width;\n  const originalHeight = svgImage.height;\n  const newWidth = originalWidth * 2;\n  const newHeight = originalHeight * 2;\n  const { ImageManager } = await import(\"../../src/display/editor/tools.js\");\n  const imageManager = new ImageManager();\n  await imageManager.resizeImage(svgImage, newWidth, newHeight);\n  const resizedWidth = svgImage.width;\n  const resizedHeight = svgImage.height;\n  expect(resizedWidth).toBe(newWidth);\n  expect(resizedHeight).toBe(newHeight);\n});"
  },
  "16804": {
    "i1_deepseek-r1-distill-llama-70b": "it(\"should remove embedded images when fillAlpha is\", async () => {\n  const { XRefMock, createIdFactory } = await import(\"./test_utils.js\");\n  const { Dict, Name, Ref } = await import(\"../../src/core/primitives.js\");\n  const { FileAttachmentAnnotation } = await import(\"../../src/core/annotation.js\");\n  const { FileAttachmentAnnotationElement } = await import(\"../../src/display/annotation_layer.js\");\n\n  // Create mock objects\n  const xref = new XRefMock();\n  const idFactory = createIdFactory();\n  const dict = new Dict();\n  dict.set(\"FS\", new Dict());\n  dict.set(\"Name\", new Name(\"PushPin\"));\n  dict.set(\"CA\", 0); // Set fillAlpha to 0\n\n  // Create annotation and element\n  const annotation = new FileAttachmentAnnotation({ dict, xref });\n  const element = new FileAttachmentAnnotationElement({\n    annotation,\n    page: { viewport: { width: 100, height: 100 } },\n    imageResourcesPath: \"../../web/images/\",\n    linkService: { eventBus: { dispatch: () => {} } }\n  });\n\n  // Render the element\n  const container = element.render();\n  const trigger = element.#trigger;\n\n  // After patch, trigger should be null when fillAlpha is 0\n  expect(trigger).toBeNull();\n});",
    "i1_gpt-4o": "it(\"should not display the pin when fillAlpha is\", async () => {\n  const { FileAttachmentAnnotation } = await import(\"../../src/core/annotation.js\");\n  const { Dict, Name } = await import(\"../../src/core/primitives.js\");\n  const { AnnotationType } = await import(\"../../src/shared/util.js\");\n\n  const dict = new Dict();\n  dict.set(\"Name\", Name.get(\"PushPin\"));\n  dict.set(\"ca\", 0);\n\n  const annotation = new FileAttachmentAnnotation({\n    dict,\n    xref: null,\n  });\n\n  const expected = {\n    annotationType: AnnotationType.FILEATTACHMENT,\n    name: \"PushPin\",\n    fillAlpha: 0,\n  };\n\n  expect(annotation.data).toMatchObject(expected);\n});",
    "i1_llama-3.3-70b-versatile": "it(\"should render file attachment annotation with transparent background\", async () => {\n  const { PDFDocument } = await import(\"../../src/display/api.js\");\n  const { AnnotationFactory } = await import(\"../../src/core/annotation.js\");\n  const { Dict, Name } = await import(\"../../src/core/primitives.js\");\n  const pdfData = await (await import(\"../../src/display/node_stream.js\")).PDFNodeStream.fromBuffer(new Uint8Array([137, 80, 68, 70, 45, 49, 46, 55, 10, 37, 94, 173, 237, 27, 28, 0, 1, 0, 0, 0, 4, 0, 0, 0, 4, 37, 0, 67, 97, 32, 48, 32, 52, 32, 111, 98, 106, 10, 60, 60, 47, 70, 49, 32, 52, 32, 48, 32, 82, 10, 47, 67, 97, 32, 48, 32, 52, 32, 111, 98, 106, 10, 60, 60, 47, 70, 49, 32, 52, 32, 48, 32, 82, 10, 47, 67, 97, 32, 48, 32, 52, 32, 111, 98, 106, 10, 60, 60, 47, 70, 49, 32, 52, 32, 48, 32, 82, 10, 47, 67, 97, 32, 48, 32, 52, 32, 111, 98, 106, 10, 60, 60, 47, 70, 49, 32, 52, 32, 48, 32, 82, 10, 47, 67, 97, 32, 48, 32, 52, 32, 111, 98, 106, 10, 60, 60, 47, 70, 49, 32, 52, 32, 48, 32, 82, 10, 47, 67, 97, 32, 48, 32, 52, 32, 111, 98, 106, 10, 60, 60, 47, 70, 49, 32, 52, 32, 48, 32, 82, 10, 47, 67, 97, 32, 48, 32, 52, 32, 111, 98, 106, 10, 60, 60, 47, 70, 49, 32, 52, 32, 48, 32, 82, 10, 47, 67, 97, 32, 48, 32, 52, 32, 111,",
    "i2_deepseek-r1-distill-llama-70b": "it(\"should apply fillalpha to file attachment annotation icons\", async () => {\n  const { FileAttachmentAnnotation } = await import(\"../../src/core/annotation.js\");\n  const { FileAttachmentAnnotationElement } = await import(\"../../src/display/annotation_layer.js\");\n  const { Util } = await import(\"../../shared/util.js\");\n\n  // Create a sample annotation with fillAlpha set to 0.5\n  const annotation = new FileAttachmentAnnotation({\n    dict: {\n      get: (key) => {\n        if (key === \"FS\") return new Name(\"PushPin\");\n        if (key === \"CA\") return 0.5;\n        return undefined;\n      }\n    },\n    xref: {}\n  });\n\n  // Render the annotation\n  const element = new FileAttachmentAnnotationElement({\n    annotation,\n    page: {},\n    imageResourcesPath: \"\",\n    linkService: {}\n  });\n  element.render();\n\n  // Check if the opacity is correctly applied\n  const expectedOpacity = 0.5;\n  const actualOpacity = Number(element.#trigger.style.opacity.match(/\\d+/)[0]) / 100;\n\n  expect(actualOpacity).toBe(expectedOpacity);\n});",
    "i2_gpt-4o": "it(\"should not display the pin icon when fillAlpha is\", async () => {\n  const { FileAttachmentAnnotation } = await import(\"../../src/core/annotation.js\");\n  const { FileAttachmentAnnotationElement } = await import(\"../../src/display/annotation_layer.js\");\n\n  const params = {\n    dict: {\n      get: (key) => {\n        if (key === \"Name\") return { name: \"PushPin\" };\n        if (key === \"ca\") return 0; // fillAlpha set to 0\n        return null;\n      },\n    },\n    xref: null,\n  };\n\n  const annotation = new FileAttachmentAnnotation(params);\n  const element = new FileAttachmentAnnotationElement({\n    data: annotation.data,\n    imageResourcesPath: \"\",\n    linkService: { eventBus: { dispatch: () => {} } },\n  });\n\n  const container = element.render();\n  const trigger = container.querySelector(\".popupTriggerArea\");\n\n  const expected = null;\n  const actual = trigger.querySelector(\"img\");\n\n  expect(actual).toBe(expected);\n});",
    "i2_llama-3.3-70b-versatile": "it(\"should render FileAttachmentAnnotation with transparent icon when fillAlpha is\", async () => {\n  const { PDFDocument, PDFPage } = await import(\"../../src/core/document.js\");\n  const { AnnotationLayer } = await import(\"../../src/display/annotation_layer.js\");\n  const { PDFDataRangeTransport } = await import(\"../../src/display/api.js\");\n\n  const pdfData = await fetch('https://github.com/mozilla/pdf.js/files/12287878/TS354.Week.2.slides.pdf').then(response => response.arrayBuffer());\n  const pdf = await PDFDocument.load(pdfData, { cMapUrl: 'https://cdn.jsdelivr.net/npm/pdfjs-dist@2.16.105/build/generic/web/cmaps/', cMapPacked: true });\n  const page = await pdf.getPage(2);\n  const annotationLayer = new AnnotationLayer({\n    page,\n    renderInteractiveForms: false,\n    linkService: null,\n    downloadManager: null,\n    annotationStorage: null,\n  });\n\n  const annotations = await page.getAnnotations();\n  const fileAttachmentAnnotation = annotations.find(annotation => annotation.subtype === 'FileAttachment');\n  const fillAlpha = 0;\n  fileAttachmentAnnotation.set('ca', fillAlpha);\n\n  const expectedStyle = `filter: opacity(0%)`;\n  const actualStyle = annotationLayer.render().querySelector('.popupTriggerArea').style;\n\n  expect(actualStyle).toBe(expectedStyle);\n});",
    "i3_deepseek-r1-distill-llama-70b": "it(\"should remove embedded images when fillAlpha is\", async () => {\n  const { annotation, annotation_layer } = await import(\"../../src/core/annotation.js\");\n  const { XRefMock } = await import(\"../../test_utils.js\");\n\n  // Setup mock PDF data\n  const xref = new XRefMock({\n    getFetchPromise: () => Promise.resolve(new Dict()),\n  });\n\n  // Create annotation data with fillAlpha set to 0\n  const annotationData = {\n    subtype: \"FileAttachment\",\n    dict: new Dict({\n      Name: new Name(\"PushPin\"),\n      FS: new Dict(),\n    }),\n    fillAlpha: 0,\n  };\n\n  // Create the annotation\n  const annotation = new FileAttachmentAnnotation({\n    data: annotationData,\n    xref,\n  });\n\n  // Render the annotation\n  const layer = {\n    div: document.createElement(\"div\"),\n    viewport: {\n      rawDims: {\n        pageWidth: 100,\n        pageHeight: 100,\n        pageX: 0,\n        pageY: 0,\n      },\n    },\n    linkService: {},\n    downloadManager: {},\n    imageResourcesPath: \"\",\n    renderForms: true,\n    enableScripting: false,\n    hasJSActions: false,\n    fieldObjects: null,\n    parent: {},\n  };\n\n  const params = {\n    ...layer,\n    annotations: [annotation],\n  };\n\n  const annotationLayer = new AnnotationLayer(params);\n  await annotationLayer.render(params);\n\n  // Check the trigger element\n  const trigger = annotationLayer.div.querySelector(\".fileAttachmentAnnotation > img\");\n  const opacity = parseFloat(trigger.style.opacity);\n\n  expect(opacity).toBe(0);\n});",
    "i3_gpt-4o": "it(\"should correctly handle FileAttachmentAnnotation with fillAlpha\", async () => {\n  const { FileAttachmentAnnotation } = await import(\"../../src/core/annotation.js\");\n  const dict = new Dict();\n  dict.set(\"Name\", Name.get(\"PushPin\"));\n  dict.set(\"ca\", 0.5);\n  const xref = new XRefMock([{ ref: Ref.get(1, 0), data: dict }]);\n  const annotation = new FileAttachmentAnnotation({\n    dict,\n    xref,\n    ref: Ref.get(1, 0),\n  });\n\n  const expected = 0.5;\n  const actual = annotation.data.fillAlpha;\n  expect(actual).toEqual(expected);\n});",
    "i3_llama-3.3-70b-versatile": "it(\"should remove embedded images from annotations\", async () => {\n  const xref = new XRefMock();\n  const annotation = new Annotation({\n    dict: new Dict(xref),\n    xref,\n    ref: new Ref(xref, 1),\n    id: \"test\",\n    subtype: \"FileAttachment\",\n    pdfManager: {\n      ensureCatalog: async () => {},\n      ensureDoc: async () => {},\n      xref,\n    },\n    evaluatorOptions: {},\n  });\n  annotation.data.fillAlpha = 0.5;\n  const appearance = new StringStream(\"q 1 0 0 1 0 0 cm /Im0 Do Q\");\n  const appearanceDict = new Dict(xref);\n  appearanceDict.set(\"Subtype\", Name.get(\"Form\"));\n  appearanceDict.set(\"Type\", Name.get(\"XObject\"));\n  appearanceDict.set(\"BBox\", [0, 0, 100, 100]);\n  appearanceDict.set(\"Matrix\", [1, 0, 0, 1, 0, 0]);\n  appearance.dict = appearanceDict;\n  annotation.appearance = appearance;\n  const trigger = document.createElement(\"div\");\n  trigger.classList.add(\"popupTriggerArea\");\n  const annotationElement = new AnnotationElement({\n    data: annotation.data,\n    layer: document.createElement(\"div\"),\n    linkService: {},\n    downloadManager: {},\n    imageResourcesPath: \"\",\n    renderForms: true,\n    svgFactory: {},\n    annotationStorage: {},\n  });\n  annotationElement.render();\n  const expectedStyle = `filter: opacity(50%);`;\n  const actualStyle = annotationElement.container.style.filter;\n  expect(actualStyle).toBe(expectedStyle);\n});",
    "i4_deepseek-r1-distill-llama-70b": "it(\"should hide embedded images when fillAlpha is set to\", async () => {\n  const { AnnotationFactory, Util } = await import(\"../../src/core/annotation.js\");\n  const { DOMSVGFactory } = await import(\"../../src/display_utils.js\");\n\n  // Create a sample annotation with fillAlpha set to 0\n  const annotation = {\n    subtype: \"FileAttachment\",\n    rect: [0, 0, 100, 100],\n    dict: {\n      get: (key) => {\n        if (key === \"ca\") return 0;\n        return null;\n      },\n    },\n  };\n\n  // Render the annotation\n  const svgFactory = new DOMSVGFactory();\n  const container = document.createElement(\"div\");\n  const layer = {\n    div: container,\n    viewport: {\n      rawDims: { pageWidth: 100, pageHeight: 100, pageX: 0, pageY: 0 },\n    },\n    linkService: {},\n    downloadManager: {},\n    imageResourcesPath: \"\",\n    renderForms: false,\n    annotationStorage: {},\n    parent: { zIndex: 0 },\n  };\n\n  const elementParams = {\n    data: annotation,\n    layer: layer,\n    linkService: {},\n    downloadManager: {},\n    imageResourcesPath: \"\",\n    renderForms: false,\n    svgFactory: svgFactory,\n    annotationStorage: {},\n    parent: layer,\n  };\n\n  const annotationElement = AnnotationElementFactory.create(elementParams);\n  const rendered = annotationElement.render();\n\n  // Check if the pin is hidden\n  const pin = rendered.querySelector(\"img\");\n  expect(pin).not.toBeNull();\n  expect(pin.style.opacity).toBe(\"0\");\n});",
    "i4_gpt-4o": "it(\"should not display the pin when fillAlpha is\", async () => {\n  const { FileAttachmentAnnotation } = await import(\"../../src/core/annotation.js\");\n  const { FileAttachmentAnnotationElement } = await import(\"../../src/display/annotation_layer.js\");\n\n  const dict = {\n    get: (key) => {\n      if (key === \"Name\") return { name: \"PushPin\" };\n      if (key === \"ca\") return 0;\n      return null;\n    },\n  };\n\n  const params = {\n    dict,\n    xref: null,\n    data: {\n      id: \"test-id\",\n      hasAppearance: false,\n      fillAlpha: 0,\n    },\n    layer: document.createElement(\"div\"),\n    linkService: {},\n    downloadManager: {},\n    imageResourcesPath: \"\",\n    renderForms: false,\n    svgFactory: {},\n    annotationStorage: {},\n    enableScripting: false,\n    hasJSActions: false,\n    fieldObjects: null,\n    parent: { page: { view: [0, 0, 100, 100] }, viewport: { rawDims: { pageWidth: 100, pageHeight: 100, pageX: 0, pageY: 0 } }, zIndex: 0 },\n  };\n\n  const annotation = new FileAttachmentAnnotation(params);\n  const element = new FileAttachmentAnnotationElement(params);\n  const rendered = element.render();\n\n  const expected = \"none\";\n  const actual = rendered.querySelector(\"img\").style.display;\n\n  expect(actual).toBe(expected);\n});",
    "i4_llama-3.3-70b-versatile": "it(\"should remove embedded images from annotations\", async () => {\n  const { AnnotationLayer, AnnotationElementFactory } = await import(\"../../src/display/annotation_layer.js\");\n  const { AnnotationFactory } = await import(\"../../src/core/annotation.js\");\n  const { PDFPageProxy } = await import(\"../../src/display/api.js\");\n  const { PageViewport } = await import(\"../../src/display_utils.js\");\n  const { NullL10n } = await import(\"../../web/l10n_utils.js\");\n\n  const page = new PDFPageProxy({\n    viewport: new PageViewport({ width: 100, height: 100 }),\n  });\n  const annotationStorage = new (await import(\"../../src/display/annotation_storage.js\")).AnnotationStorage();\n  const linkService = {\n    eventBus: {\n      dispatch: () => {},\n    },\n  };\n  const downloadManager = {};\n  const imageResourcesPath = \"\";\n  const renderForms = true;\n  const l10n = new NullL10n();\n\n  const annotationLayer = new AnnotationLayer({\n    div: document.createElement(\"div\"),\n    accessibilityManager: null,\n    annotationCanvasMap: new Map(),\n    l10n,\n    page,\n    viewport: page.viewport,\n  });\n\n  const annotation = await AnnotationFactory.create(\n    { xref: {}, ref: {}, pdfManager: {}, idFactory: {}, evaluatorOptions: {} },\n    { dict: { Subtype: \"FileAttachment\" } },\n    annotationStorage,\n    renderForms\n  );\n\n  const annotationElement = AnnotationElementFactory.create({\n    data: annotation.data,\n    layer: annotationLayer,\n    linkService,\n    downloadManager,\n    imageResourcesPath,\n    renderForms,\n    annotationStorage,\n  });\n\n  const trigger = annotationElement.render().getElementsToTriggerPopup();\n\n  expect(trigger[0].style.filter).not.toContain(\"opacity\");\n});",
    "i5_deepseek-r1-distill-llama-70b": "it(\"should not show the push pin when fillAlpha is zero\", async () => {\n  const { PDFDocument, PDFPage, Annotation } = await import(\"../../src/core/annotation.js\");\n  const { FileAttachmentAnnotationElement } = await import(\"../../src/display/annotation_layer.js\");\n\n  // Create a mock PDF document with a page\n  const pdf = new PDFDocument();\n  const page = new PDFPage(pdf, 1);\n\n  // Create a file attachment annotation with fillAlpha = 0\n  const annotation = new FileAttachmentAnnotation();\n  annotation.data.name = \"PushPin\";\n  annotation.data.fillAlpha = 0;\n  annotation.data.hasAppearance = false;\n\n  // Create annotation element and render it\n  const element = new FileAttachmentAnnotationElement({ annotation, page });\n  element.render();\n\n  // Check if the trigger element has opacity applied\n  const trigger = element.#trigger;\n  expect(trigger.style).toContain(\"opacity:\");\n});",
    "i5_gpt-4o": "it(\"should not display the pin when fillAlpha is\", async () => {\n  const { FileAttachmentAnnotation } = await import(\"../../src/core/annotation.js\");\n  const { FileAttachmentAnnotationElement } = await import(\"../../src/display/annotation_layer.js\");\n\n  const dict = {\n    get: (key) => {\n      if (key === \"Name\") return { name: \"PushPin\" };\n      if (key === \"ca\") return 0;\n      return null;\n    },\n  };\n\n  const annotation = new FileAttachmentAnnotation(dict);\n  const element = new FileAttachmentAnnotationElement({\n    data: annotation.data,\n    imageResourcesPath: \"\",\n  });\n\n  element.render();\n  const actual = element.container.querySelector(\"img\");\n  const expected = null;\n\n  expect(actual).toBe(expected);\n});",
    "i5_llama-3.3-70b-versatile": "it(\"should render embedded images with correct opacity\", async () => {\n  const { PDFDocument, PDFPage } = await import(\"../../src/core/document.js\");\n  const { AnnotationLayer } = await import(\"../../src/display/annotation_layer.js\");\n  const { PDFViewer } = await import(\"../../web/pdf_viewer.js\");\n  const { createIdFactory } = await import(\"./test_utils.js\");\n\n  const pdfUrl = `${TEST_PDFS_PATH}TS354_Week_2_slides.pdf`;\n  const pdf = await PDFDocument.load(pdfUrl);\n  const page = await pdf.getPage(2);\n  const pdfViewer = new PDFViewer();\n  const annotationLayer = new AnnotationLayer({\n    page,\n    viewport: page.getViewport({ scale: 1 }),\n    renderInteractiveForms: false,\n  });\n  const annotationStorage = annotationLayer.annotationStorage;\n  const annotations = await annotationStorage.getAnnotations();\n  const fileAttachmentAnnotation = annotations.find(\n    (annotation) => annotation instanceof FileAttachmentAnnotation\n  );\n  const trigger = annotationLayer.render();\n  const expectedOpacity = fileAttachmentAnnotation.data.fillAlpha;\n  const actualOpacity = trigger.style.filter.match(/opacity\\((\\d+)%\\)/)[1] / 100;\n  expect(actualOpacity).toBeCloseTo(expectedOpacity);\n});"
  },
  "16828": {
    "i1_deepseek-r1-distill-llama-70b": "it(\"should support pasting an image from clipboard in editing mode\", async () => {\n  const { AnnotationEditorUIManager } = await import(\"../../src/display/editor/tools.js\");\n  const { StampEditor } = await import(\"../../src/display/editor/stamp.js\");\n  const { AnnotationEditorLayer } = await import(\"../../src/display/editor/annotation_editor_layer.js\");\n\n  // Mock DOM elements and dependencies\n  const container = document.createElement(\"div\");\n  const viewer = { get pages() { return [{}]; } };\n  const eventBus = { _on: () => {}, _off: () => {} };\n  const pdfDocument = { annotationStorage: {} };\n  const pageColors = {};\n\n  // Initialize UI manager\n  const uiManager = new AnnotationEditorUIManager(container, viewer, eventBus, pdfDocument, pageColors);\n\n  // Create a mock layer with editors\n  const layer = new AnnotationEditorLayer({\n    uiManager: uiManager,\n    pageIndex: 0,\n    div: container,\n    accessibilityManager: {},\n    annotationLayer: {},\n    viewport: {},\n    l10n: {},\n  });\n\n  // Mock current layer and editor types\n  uiManager.currentLayer = layer;\n  uiManager.registerEditorTypes([StampEditor]);\n\n  // Mock clipboard event with image data\n  const clipboardData = {\n    items: [\n      new DataTransferItem(\n        \"image/png\",\n        new File([\"data:image/png;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxMDAgMTAwIj48cG9seWdvbiBwb2ludHM9IjUwLDAgMTAwLDUwIDUwLDEwMCAwLDUwIiBmaWxsPSIjZmZmIi8+PC9zdmc+\"], \"red-dot.png\")\n      )\n    ],\n    getData: () => \"image/png\"\n  };\n\n  // Simulate paste event\n  const event = { clipboardData, preventDefault: () => {} };\n  uiManager.paste(event);\n\n  // Verify that a new StampEditor was created and added to the layer\n  expect(layer.editors.size).toBeGreaterThan(0);\n  const editor = layer.editors.values().next().value;\n  expect(editor).toBeInstanceOf(StampEditor);\n});",
    "i1_gpt-4o": "it(\"should paste an image from the clipboard in editing mode\", async () => {\n  const { AnnotationEditorUIManager } = await import(\"../../src/display/editor/tools.js\");\n  const { AnnotationEditorLayer } = await import(\"../../src/display/editor/annotation_editor_layer.js\");\n  const { StampEditor } = await import(\"../../src/display/editor/stamp.js\");\n  const { AnnotationEditorType } = await import(\"../../src/shared/util.js\");\n\n  const uiManager = new AnnotationEditorUIManager(null, null, null, { annotationStorage: {} }, null);\n  const layer = new AnnotationEditorLayer({\n    uiManager,\n    pageIndex: 0,\n    div: document.createElement(\"div\"),\n    accessibilityManager: null,\n    annotationLayer: null,\n    viewport: { rotation: 0, rawDims: { pageWidth: 100, pageHeight: 100, pageX: 0, pageY: 0 } },\n    l10n: null,\n  });\n\n  uiManager.addLayer(layer);\n  uiManager.updateMode(AnnotationEditorType.STAMP);\n\n  const clipboardData = new DataTransfer();\n  const file = new File([\"\"], \"image.png\", { type: \"image/png\" });\n  clipboardData.items.add(file);\n\n  const pasteEvent = new ClipboardEvent(\"paste\", { clipboardData });\n  uiManager.paste(pasteEvent);\n\n  const editors = Array.from(layer.#editors.values());\n  const hasStampEditor = editors.some(editor => editor instanceof StampEditor);\n\n  expect(hasStampEditor).toBe(true);\n});",
    "i1_llama-3.3-70b-versatile": "it(\"should support pasting an image from the clipboard\", async () => {\n  const { AnnotationEditorUIManager, AnnotationEditorLayer, StampEditor } = await import(\"../../src/display/editor/tools.js\");\n  const { AnnotationEditorType } = await import(\"../../shared/util.js\");\n  const uiManager = new AnnotationEditorUIManager(null, null, null, null, null);\n  const layer = new AnnotationEditorLayer({\n    uiManager,\n    pageIndex: 0,\n    div: document.createElement(\"div\"),\n    accessibilityManager: null,\n    annotationLayer: null,\n    viewport: null,\n    l10n: null,\n  });\n  uiManager.registerEditorTypes([StampEditor]);\n  const clipboardData = new DataTransfer();\n  const file = new File([\"image data\"], \"image.png\", { type: \"image/png\" });\n  clipboardData.items.add(file);\n  const event = new ClipboardEvent(\"paste\", { clipboardData });\n  uiManager.paste(event);\n  expect(uiManager.currentLayer.editors.size).toBe(1);\n});",
    "i2_deepseek-r1-distill-llama-70b": "it(\"should create a stamp editor when pasting an image from clipboard\", async () => {\n  const { AnnotationEditorUIManager, AnnotationEditorLayer } = await import(\"../../src/display/editor/tools.js\");\n  const { StampEditor } = await import(\"../../src/display/editor/stamp.js\");\n\n  // Mock clipboard data with image\n  const clipboardData = {\n    items: [\n      {\n        type: \"image/png\",\n        getAsFile: () => new File([\"test\"], \"test.png\", { type: \"image/png\" })\n      }\n    ]\n  };\n\n  // Mock UI Manager and dependencies\n  const mockViewer = {};\n  const mockEventBus = {\n    _on: jest.fn(),\n    _off: jest.fn()\n  };\n  const uiManager = new AnnotationEditorUIManager(mockViewer, mockEventBus, {}, {});\n\n  // Mock layer and current layer setup\n  const mockDiv = {\n    getBoundingClientRect: () => ({ x: 0, y: 0, width: 100, height: 100 })\n  };\n  const layer = new AnnotationEditorLayer({\n    uiManager,\n    pageIndex: 0,\n    div: mockDiv,\n    accessibilityManager: {},\n    annotationLayer: {},\n    viewport: { getBoundingClientRect: () => ({}) },\n    l10n: {}\n  });\n\n  // Add layer to UI manager\n  uiManager.currentLayer = layer;\n\n  // Mock image manager to return valid data\n  uiManager.imageManager = {\n    getFromFile: jest.fn(() => ({\n      bitmap: {},\n      id: \"1\",\n      isSvg: false\n    }))\n  };\n\n  // Call paste method\n  const event = { clipboardData, preventDefault: jest.fn() };\n  uiManager.paste(event);\n\n  // Check if stamp editor was created and added\n  const editors = Array.from(layer.#editors.values());\n  const stampEditor = editors.find(editor => editor instanceof StampEditor);\n\n  expect(stampEditor).toBeTruthy();\n});",
    "i2_gpt-4o": "it(\"should paste an image from the clipboard in editing mode\", async () => {\n  const { AnnotationEditorUIManager } = await import(\"../../src/display/editor/tools.js\");\n  const { AnnotationEditorLayer } = await import(\"../../src/display/editor/annotation_editor_layer.js\");\n  const { StampEditor } = await import(\"../../src/display/editor/stamp.js\");\n  const { AnnotationEditorType } = await import(\"../../src/shared/util.js\");\n\n  const mockEvent = {\n    preventDefault: () => {},\n    clipboardData: {\n      items: [\n        {\n          type: \"image/png\",\n          getAsFile: () => new File([\"\"], \"test.png\", { type: \"image/png\" }),\n        },\n      ],\n    },\n  };\n\n  const uiManager = new AnnotationEditorUIManager(null, null, null, { annotationStorage: {} }, null);\n  const layer = new AnnotationEditorLayer({\n    uiManager,\n    pageIndex: 0,\n    div: document.createElement(\"div\"),\n    accessibilityManager: null,\n    annotationLayer: null,\n    viewport: { rotation: 0, rawDims: { pageWidth: 100, pageHeight: 100, pageX: 0, pageY: 0 } },\n    l10n: null,\n  });\n\n  uiManager.addLayer(layer);\n  uiManager.updateMode(AnnotationEditorType.STAMP);\n\n  uiManager.paste(mockEvent);\n\n  const editors = Array.from(layer.#editors.values());\n  const pastedEditor = editors.find(editor => editor instanceof StampEditor);\n\n  expect(pastedEditor).not.toBeUndefined();\n  expect(pastedEditor.#bitmapFile).toBeInstanceOf(File);\n  expect(pastedEditor.#bitmapFile.name).toBe(\"test.png\");\n});",
    "i2_llama-3.3-70b-versatile": "it(\"should create a new stamp editor when pasting an image from the clipboard\", async () => {\n  const { AnnotationEditorUIManager, AnnotationEditorLayer, StampEditor } = await import(\"../../src/display/editor/tools.js\");\n  const { AnnotationEditorType } = await import(\"../../shared/util.js\");\n  const { document } = globalThis;\n\n  const uiManager = new AnnotationEditorUIManager(null, null, null, null, null);\n  const layer = new AnnotationEditorLayer({\n    uiManager,\n    pageIndex: 0,\n    div: document.createElement(\"div\"),\n    accessibilityManager: null,\n    annotationLayer: null,\n    viewport: { rotation: 0, width: 100, height: 100 },\n    l10n: null,\n  });\n\n  const clipboardData = {\n    items: [\n      {\n        type: \"image/png\",\n        getAsFile: () => new File([\"image_data\"], \"image.png\", { type: \"image/png\" }),\n      },\n    ],\n  };\n\n  const event = { clipboardData, preventDefault: () => {} };\n\n  uiManager.paste(event);\n\n  const newEditor = layer.editors.get(Array.from(layer.editors.keys())[0]);\n\n  expect(newEditor).toBeInstanceOf(StampEditor);\n});",
    "i3_deepseek-r1-distill-llama-70b": "it(\"should allow pasting an image from clipboard\", async () => {\n  const { AnnotationEditorUIManager } = await import(\"../../src/display/editor/tools.js\");\n  const { AnnotationEditorLayer } = await import(\"../../src/display/editor/annotation_editor_layer.js\");\n  const { StampEditor } = await import(\"../../src/display/editor/stamp.js\");\n\n  const container = document.createElement(\"div\");\n  const uiManager = new AnnotationEditorUIManager(container, null, null, null, null);\n  const layer = new AnnotationEditorLayer({\n    uiManager: uiManager,\n    div: container,\n    pageIndex: 0,\n    l10n: {},\n    viewport: {},\n    annotationLayer: null,\n  });\n\n  const clipboardData = {\n    types: [\"image/png\"],\n    items: [\n      {\n        type: \"image/png\",\n        getAsFile: () => new File([\"test\"], \"test.png\", { type: \"image/png\" }),\n      },\n    ],\n  };\n\n  const event = { clipboardData };\n\n  uiManager.paste(event);\n\n  await new Promise(resolve => setTimeout(resolve, 100));\n\n  const allEditors = uiManager.getEditors(0);\n  expect(allEditors.length).toBe(1);\n  const editor = allEditors[0];\n  expect(editor).toBeInstanceOf(StampEditor);\n  expect(editor.isEmpty()).toBe(false);\n});",
    "i3_gpt-4o": "it(\"should support pasting an image from the clipboard in editing mode\", async () => {\n  const { AnnotationEditorUIManager } = await import(\"../../src/display/editor/tools.js\");\n  const { AnnotationEditorLayer } = await import(\"../../src/display/editor/annotation_editor_layer.js\");\n  const { StampEditor } = await import(\"../../src/display/editor/stamp.js\");\n  const { AnnotationEditorType } = await import(\"../../src/shared/util.js\");\n\n  const uiManager = new AnnotationEditorUIManager(null, null, { _on: () => {}, _off: () => {} }, { annotationStorage: new Map(), filterFactory: null }, null);\n  const layer = new AnnotationEditorLayer({\n    uiManager,\n    pageIndex: 0,\n    div: document.createElement(\"div\"),\n    accessibilityManager: null,\n    annotationLayer: null,\n    viewport: { rotation: 0, rawDims: { pageWidth: 100, pageHeight: 100, pageX: 0, pageY: 0 } },\n    l10n: null,\n  });\n\n  uiManager.addLayer(layer);\n  uiManager.updateMode(AnnotationEditorType.STAMP);\n\n  const clipboardData = {\n    items: [\n      {\n        type: \"image/png\",\n        getAsFile: () => new File([\"\"], \"test.png\", { type: \"image/png\" }),\n      },\n    ],\n  };\n\n  const pasteEvent = new ClipboardEvent(\"paste\", { clipboardData });\n  uiManager.paste(pasteEvent);\n\n  const editors = uiManager.getEditors(0);\n  const hasStampEditor = editors.some(editor => editor instanceof StampEditor);\n\n  expect(hasStampEditor).toBe(true);\n});",
    "i3_llama-3.3-70b-versatile": "it(\"should support pasting an image from the clipboard\", async () => {\n  const { AnnotationEditorUIManager, AnnotationEditorLayer, StampEditor } = await import(\"../../src/display/editor/tools.js\");\n  const { AnnotationEditor } = await import(\"../../src/display/editor/editor.js\");\n  const editorLayer = new AnnotationEditorLayer({\n    uiManager: new AnnotationEditorUIManager(),\n    pageIndex: 0,\n    div: document.createElement(\"div\"),\n    accessibilityManager: null,\n    annotationLayer: null,\n    viewport: { width: 100, height: 100 },\n    l10n: {},\n  });\n  const event = new ClipboardEvent(\"paste\", {\n    clipboardData: new DataTransfer(),\n  });\n  event.clipboardData.items.add(new File([\"image\"], \"image.png\", { type: \"image/png\" }));\n  const uiManager = editorLayer.#uiManager;\n  uiManager.paste(event);\n  expect(uiManager.getMode()).toBe(AnnotationEditor.Type.STAMP);\n});",
    "i4_deepseek-r1-distill-llama-70b": "it(\"should create a StampEditor when pasting an image from clipboard\", async () => {\n  const { AnnotationEditorUIManager } = await import(\"../../src/display/editor/tools.js\");\n  const { AnnotationEditorLayer } = await import(\"../../src/display/editor/annotation_editor_layer.js\");\n  const { StampEditor } = await import(\"../../src/display/editor/stamp.js\");\n\n  const container = {\n    focus: jest.fn(),\n    addEventListener: jest.fn(),\n    removeEventListener: jest.fn(),\n  };\n\n  const mockViewer = {};\n  const mockEventBus = {\n    _on: jest.fn(),\n    _off: jest.fn(),\n    dispatch: jest.fn(),\n  };\n  const mockPdfDocument = {};\n  const mockPageColors = {};\n\n  const uiManager = new AnnotationEditorUIManager(\n    container,\n    mockViewer,\n    mockEventBus,\n    mockPdfDocument,\n    mockPageColors\n  );\n\n  const mockClipboardEvent = {\n    clipboardData: {\n      getData: () => \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mNkYAAAAAYAAjCB0C8AAAAASUVORK5CYII=\",\n    },\n    preventDefault: jest.fn(),\n  };\n\n  // Before patch: should not create StampEditor\n  const beforePatchResult = await import(\"../../src/display/editor/tools.js\");\n  expect(beforePatchResult.AnnotationEditorUIManager.paste(mockClipboardEvent)).not.toCreate(StampEditor);\n\n  // After patch: should create StampEditor\n  const afterPatchResult = await import(\"../../src/display/editor/tools.js\");\n  await afterPatchResult.AnnotationEditorUIManager.paste(mockClipboardEvent);\n  expect(afterPatchResult.AnnotationEditorLayer.createEditor).toHaveBeenCalled();\n});",
    "i4_gpt-4o": "it(\"should support pasting an image from the clipboard in editing mode\", async () => {\n  const { AnnotationEditorUIManager } = await import(\"../../src/display/editor/tools.js\");\n  const { AnnotationEditorLayer } = await import(\"../../src/display/editor/annotation_editor_layer.js\");\n  const { StampEditor } = await import(\"../../src/display/editor/stamp.js\");\n  const { AnnotationEditorType } = await import(\"../../src/shared/util.js\");\n\n  const mockEventBus = { _on: () => {}, _off: () => {}, dispatch: () => {} };\n  const mockPdfDocument = { annotationStorage: new Map(), filterFactory: {} };\n  const mockContainer = document.createElement(\"div\");\n  const mockViewer = document.createElement(\"div\");\n  const uiManager = new AnnotationEditorUIManager(mockContainer, mockViewer, mockEventBus, mockPdfDocument, null);\n\n  const mockDiv = document.createElement(\"div\");\n  const layer = new AnnotationEditorLayer({\n    uiManager,\n    pageIndex: 0,\n    div: mockDiv,\n    accessibilityManager: null,\n    annotationLayer: null,\n    viewport: { rotation: 0, rawDims: { pageWidth: 100, pageHeight: 100, pageX: 0, pageY: 0 } },\n    l10n: null,\n  });\n\n  uiManager.addLayer(layer);\n  uiManager.updateMode(AnnotationEditorType.STAMP);\n\n  const clipboardData = new DataTransfer();\n  const file = new File([\"\"], \"image.png\", { type: \"image/png\" });\n  clipboardData.items.add(file);\n\n  const pasteEvent = new ClipboardEvent(\"paste\", { clipboardData });\n  uiManager.paste(pasteEvent);\n\n  const expected = 1;\n  const actual = layer.isEmpty ? 0 : 1;\n  expect(actual).toBe(expected);\n});",
    "i4_llama-3.3-70b-versatile": "it(\"should support pasting an image from the clipboard\", async () => {\n  const { AnnotationEditorUIManager, AnnotationEditorLayer, StampEditor } = await import(\"../../src/display/editor/tools.js\");\n  const { AnnotationEditor } = await import(\"../../src/display/editor/editor.js\");\n  const { getUuid } = await import(\"../../shared/util.js\");\n\n  const container = { addEventListener: () => {}, removeEventListener: () => {} };\n  const viewer = { addEventListener: () => {}, removeEventListener: () => {} };\n  const eventBus = { _on: () => {}, _off: () => {}, dispatch: () => {} };\n  const pdfDocument = { annotationStorage: {} };\n  const pageColors = {};\n\n  const uiManager = new AnnotationEditorUIManager(container, viewer, eventBus, pdfDocument, pageColors);\n  const layer = new AnnotationEditorLayer({ uiManager, pageIndex: 0, div: {}, accessibilityManager: null, annotationLayer: null, viewport: {} });\n\n  const editor = new StampEditor({ parent: layer, id: getUuid(), uiManager, name: \"stampEditor\" });\n  const dataTransfer = { items: [{ kind: \"file\", type: \"image/png\", getAsFile: () => ({}) }] };\n\n  const pasteSpy = jest.spyOn(StampEditor, \"paste\");\n  uiManager.paste({ clipboardData: dataTransfer });\n  expect(pasteSpy).toHaveBeenCalledTimes(1);\n});",
    "i5_deepseek-r1-distill-llama-70b": "it(\"should support pasting an image from clipboard\", async () => {\n  const { AnnotationEditorLayer } = await import(\"../../src/display/editor/annotation_editor_layer.js\");\n  const { StampEditor } = await import(\"../../src/display/editor/stamp.js\");\n\n  const uiManager = {\n    updateToolbar: jest.fn(),\n    updateMode: jest.fn(),\n    currentLayer: null,\n  };\n\n  const layer = new AnnotationEditorLayer(uiManager);\n  uiManager.currentLayer = layer;\n\n  const mockClipboardItem = new DataTransferItem(\n    \"image/png\",\n    new File([new Uint8Array([0x89, 0x50, 0x4E, 0x47, 0x0D, 0x0A, 0x1A, 0x0A]).buffer], \"test.png\")\n  );\n\n  const clipboardData = {\n    items: [mockClipboardItem],\n    getData: () => null,\n  };\n\n  const event = { clipboardData, preventDefault: jest.fn() };\n\n  await layer.uiManager.paste(event);\n\n  await new Promise(resolve => setTimeout(resolve, 100));\n\n  const editors = layer.editors;\n  const isStampEditorAdded = editors.some(editor => editor instanceof StampEditor);\n\n  expect(isStampEditorAdded).toBe(true);\n});",
    "i5_gpt-4o": "it(\"should support pasting an image from the clipboard in editing mode\", async () => {\n  const { AnnotationEditorUIManager } = await import(\"../../src/display/editor/tools.js\");\n  const { AnnotationEditorLayer } = await import(\"../../src/display/editor/annotation_editor_layer.js\");\n  const { StampEditor } = await import(\"../../src/display/editor/stamp.js\");\n  const { AnnotationEditorType } = await import(\"../../src/shared/util.js\");\n\n  const uiManager = new AnnotationEditorUIManager();\n  const layer = new AnnotationEditorLayer({ uiManager });\n  uiManager.currentLayer = layer;\n\n  const clipboardData = {\n    items: [\n      {\n        type: \"image/png\",\n        getAsFile: () => new Blob([\"image data\"], { type: \"image/png\" }),\n      },\n    ],\n  };\n\n  const pasteEvent = new Event(\"paste\");\n  pasteEvent.clipboardData = clipboardData;\n\n  uiManager.paste(pasteEvent);\n\n  const editors = layer.editors;\n  const hasStampEditor = editors.some(editor => editor instanceof StampEditor);\n\n  expect(hasStampEditor).toBe(true);\n});",
    "i5_llama-3.3-70b-versatile": "it(\"should support pasting an image from the clipboard\", async () => {\n  const { AnnotationEditorLayer, AnnotationEditorUIManager, AnnotationEditorType } = await import(\"../../src/display/editor/annotation_editor_layer.js\");\n  const { StampEditor } = await import(\"../../src/display/editor/stamp.js\");\n  const { Util } = await import(\"../../src/shared/util.js\");\n\n  const editorLayer = new AnnotationEditorLayer();\n  const uiManager = new AnnotationEditorUIManager();\n  uiManager.currentLayer = editorLayer;\n\n  const file = new File(['image data'], 'image.png', { type: 'image/png' });\n  const clipboardData = { items: [{ kind: 'file', type: 'image/png', getAsFile: () => file }] };\n  const event = { preventDefault: () => {}, clipboardData };\n\n  const initialEditors = editorLayer.editors;\n\n  uiManager.paste(event);\n\n  const newEditor = editorLayer.editors.find(editor => editor instanceof StampEditor);\n  const expectedType = AnnotationEditorType.STAMP;\n\n  expect(newEditor.constructor.name).toBe('StampEditor');\n  expect(editorLayer.editors.length).toBe(initialEditors.length + 1);\n});"
  },
  "16899": {
    "i1_deepseek-r1-distill-llama-70b": "it(\"should display FreeText annotation with popup data\", async () => {\n  const { AnnotationElement, FreeTextAnnotationElement } = await import(\"../../src/display/annotation_layer.js\");\n  const data = {\n    data: {\n      textContent: [\"Test content\"],\n      popupRef: null,\n      titleObj: { str: \"Test title\" },\n      contentsObj: { str: \"Test contents\" },\n      richText: { str: \"Test rich text\" }\n    },\n    layer: {},\n    linkService: {},\n    downloadManager: {},\n    imageResourcesPath: \"\",\n    renderForms: true,\n    svgFactory: {},\n    annotationStorage: {},\n    enableScripting: false,\n    hasJSActions: false,\n    fieldObjects: {},\n    parent: {}\n  };\n\n  const createPopupMock = jest.fn();\n  const element = new FreeTextAnnotationElement(data);\n  element._createPopup = createPopupMock;\n\n  const container = element.render();\n\n  expect(container).not.toBeNull();\n  expect(createPopupMock).toHaveBeenCalled();\n});",
    "i1_gpt-4o": "it(\"should display FreeText annotation with popup data\", async () => {\n  const { getDocument } = await import(\"../../src/display/api.js\");\n  const loadingTask = getDocument(buildGetDocumentParams(\"freetext-annotation.pdf\"));\n  const pdfDocument = await loadingTask.promise;\n  const page = await pdfDocument.getPage(1);\n  const annotations = await page.getAnnotations({ intent: \"display\" });\n\n  const freeTextAnnotation = annotations.find(\n    annotation => annotation.subtype === \"FreeText\"\n  );\n\n  expect(freeTextAnnotation).toBeDefined();\n  expect(freeTextAnnotation.hasPopupData).toBe(true);\n});",
    "i1_llama-3.3-70b-versatile": "it(\"should display FreeText annotation with popup data\", async () => {\n  const { PDFDocumentProxy } = await import(\"../../src/display/api.js\");\n  const { buildGetDocumentParams } = await import(\"./test_utils.js\");\n  const { AnnotationElement } = await import(\"../../src/display/annotation_layer.js\");\n\n  const pdfDoc = await getDocument(buildGetDocumentParams(\"annotation-test.pdf\"));\n  const page = await pdfDoc.getPage(1);\n  const annotationStorage = new (await import(\"../../src/display/annotation_storage.js\")).AnnotationStorage();\n  const annotationLayer = new (await import(\"../../src/display/annotation_layer.js\")).AnnotationLayer({\n    page,\n    annotationStorage,\n    linkService: null,\n    downloadManager: null,\n    imageResourcesPath: \"\",\n    renderForms: false,\n    svgFactory: new (await import(\"../../src/display/display_utils.js\")).DOMSVGFactory(),\n    enableScripting: false,\n    hasJSActions: false,\n  });\n\n  const annotations = await page.getAnnotations();\n  const freeTextAnnotation = annotations.find((annotation) => annotation.subtype === \"FreeText\");\n  const annotationElement = new AnnotationElement({\n    data: freeTextAnnotation,\n    layer: annotationLayer,\n    linkService: null,\n    downloadManager: null,\n    imageResourcesPath: \"\",\n    renderForms: false,\n    svgFactory: new (await import(\"../../src/display/display_utils.js\")).DOMSVGFactory(),\n    annotationStorage,\n    enableScripting: false,\n    hasJSActions: false,\n    parent: null,\n  });\n\n  freeTextAnnotation.titleObj = { str: \"Test Title\" };\n  freeTextAnnotation.contentsObj = { str: \"Test Contents\" };\n\n  annotationElement.render();\n\n  expect(annotationElement.container.querySelector(\".popupTriggerArea\")).not.toBeNull();\n});",
    "i2_deepseek-r1-distill-llama-70b": "it(\"should render FreeText annotation with missing popup data\", async () => {\n  const { PDFDocument } = await import(\"../../src/core/document.js\");\n  const { AnnotationLayer } = await import(\"../../src/display/annotation_layer.js\");\n  const { Annotation } = await import(\"../../src/core/annotation.js\");\n\n  // Create a mock PDF document\n  const pdfDocument = new PDFDocument({\n    url: \"example.pdf\",\n    fingerprint: \"example-fingerprint\",\n  });\n\n  // Create a mock annotation with missing popup data\n  const annotation = new Annotation({\n    type: \"FreeText\",\n    data: {\n      popupRef: null,\n      titleObj: { str: null },\n      contentsObj: { str: null },\n      richText: { str: null },\n    },\n  });\n\n  // Create the annotation layer\n  const layer = new AnnotationLayer({\n    pdfPage: pdfDocument.getPage(1),\n    annotationStorage: new (await import(\"../../src/display/annotation_storage.js\")).AnnotationStorage(),\n  });\n\n  // Add the annotation to the layer\n  layer.addAnnotation(annotation);\n\n  // Render the layer\n  const container = layer.render();\n\n  // The container should exist and have content\n  expect(container.length).toBeGreaterThan(0);\n});",
    "i2_gpt-4o": "it(\"should display FreeText annotation\", async () => {\n  const { AnnotationLayer } = await import(\"../../src/display/annotation_layer.js\");\n  const { PDFDocumentProxy } = await import(\"../../src/display/api.js\");\n  const { getDocument } = await import(\"../../src/display/api.js\");\n\n  const loadingTask = getDocument(\"path/to/pdf/with/freetext/annotation.pdf\");\n  const pdfDocument = await loadingTask.promise;\n  const page = await pdfDocument.getPage(1);\n\n  const annotationLayer = new AnnotationLayer();\n  const annotations = await page.getAnnotations();\n  const freeTextAnnotation = annotations.find(ann => ann.subtype === \"FreeText\");\n\n  const container = document.createElement(\"div\");\n  annotationLayer.render({\n    annotations: [freeTextAnnotation],\n    div: container,\n    page,\n    viewport: page.getViewport({ scale: 1.0 }),\n  });\n\n  const actual = container.querySelector(\".freeTextAnnotation\") !== null;\n  const expected = true;\n  expect(actual).toBe(expected);\n});",
    "i2_llama-3.3-70b-versatile": "it(\"should display FreeText annotation\", async () => {\n  const { AnnotationLayerBuilder } = await import(\"../../web/annotation_layer_builder.js\");\n  const { PDFDocumentFactory } = await import(\"../../src/display/api.js\");\n  const { NullL10n } = await import(\"../../web/l10n_utils.js\");\n\n  const pdfDocument = await PDFDocumentFactory.load(\"../web/test.pdf\");\n  const annotationLayerBuilder = new AnnotationLayerBuilder({\n    pdfDocument,\n    l10n: new NullL10n(),\n  });\n\n  const page = pdfDocument.getPage(1);\n  const annotations = await page.getAnnotations();\n  const freeTextAnnotation = annotations.find(\n    (annotation) => annotation.subtype === \"FreeText\"\n  );\n\n  const annotationLayer = annotationLayerBuilder.render(annotations);\n  const freeTextContainer = annotationLayer.querySelector(\".freeTextAnnotation\");\n\n  expect(freeTextContainer).not.toBeNull();\n});",
    "i3_deepseek-r1-distill-llama-70b": "it(\"should display FreeText annotation popup correctly\", async () => {\n  const { PDFDocument, PDFPageProxy } = await import(\"../../src/display/api.js\");\n  const { buildGetDocumentParams } = await import(\"./test_utils.js\");\n  const { TEST_PDFS_PATH } = await import(\"../../src/core/display/annotation_layer.js\");\n\n  const pdfPath = `${TEST_PDFS_PATH}/annotation/free_text.pdf`;\n  const params = buildGetDocumentParams(pdfPath, {});\n  const pdf = await PDFDocument.load(params);\n  const page = await pdf.getPage(1);\n\n  const annotations = await page.getAnnotations();\n  const freeTextAnnotation = annotations.find(\n    (annotation) => annotation.annotationType === \"FreeText\"\n  );\n\n  const { AnnotationLayer } = await import(\"../../src/display/annotation_layer.js\");\n  const layer = new AnnotationLayer({\n    div: document.createElement(\"div\"),\n    page,\n    viewport: page.viewport,\n    l10n: new (await import(\"../../web/l10n_utils.js\")).NullL10n(),\n    linkService: {},\n    downloadManager: {},\n  });\n\n  await layer.render({\n    annotations: [freeTextAnnotation],\n    viewport: page.viewport,\n    renderForms: true,\n  });\n\n  const popupTrigger = layer.div.querySelector(\".freeTextAnnotation\");\n  const popup = layer.div.querySelector(\".popup\");\n\n  expect(popupTrigger).toBeTruthy();\n  expect(popup).toBeTruthy();\n});",
    "i3_gpt-4o": "it(\"should display FreeText annotation\", async () => {\n  const { AnnotationLayer } = await import(\"../../src/display/annotation_layer.js\");\n  const { PDFPageProxy } = await import(\"../../src/display/api.js\");\n\n  const mockPage = new PDFPageProxy();\n  const mockViewport = { rotation: 0 };\n  const mockDiv = document.createElement(\"div\");\n  const mockAnnotation = {\n    annotationType: AnnotationType.FREETEXT,\n    rect: [0, 0, 100, 100],\n    titleObj: { str: \"Title\" },\n    contentsObj: { str: \"Contents\" },\n    richText: { str: \"Rich Text\" },\n    id: \"123\",\n  };\n\n  const annotationLayer = new AnnotationLayer({\n    div: mockDiv,\n    page: mockPage,\n    viewport: mockViewport,\n  });\n\n  await annotationLayer.render({\n    annotations: [mockAnnotation],\n    linkService: {},\n    downloadManager: {},\n    renderForms: false,\n  });\n\n  const annotationElement = mockDiv.querySelector(\"[data-annotation-id='123']\");\n  expect(annotationElement).not.toBeNull();\n  expect(annotationElement.classList.contains(\"freeTextAnnotation\")).toBe(true);\n});",
    "i3_llama-3.3-70b-versatile": "it(\"should display FreeText annotation with popup data\", async () => {\n  const pdfDocument = await getDocument({\n    url: `${TEST_PDFS_PATH}annotation-test.pdf`,\n    cMapUrl: CMAP_URL,\n    pdfWorker: new PDFWorker({\n      workerPort: new PDFWorkerUtil(),\n    }),\n    pdfDataRangeTransport: new PDFDataRangeTransport(),\n    pdfDocumentLoadingTask: new PDFDocumentLoadingTask(),\n    disableAutoFetch: true,\n    disableFontFace: true,\n  });\n  const pdfPage = await pdfDocument.getPage(1);\n  const viewport = new PageViewport({\n    pdfPage,\n    scale: 1,\n    rotation: 0,\n    clamp: true,\n  });\n  const annotationStorage = new AnnotationStorage();\n  const linkService = {\n    eventBus: {\n      dispatch: () => {},\n    },\n  };\n  const downloadManager = {};\n  const imageResourcesPath = \"\";\n  const renderForms = true;\n  const svgFactory = new DOMSVGFactory();\n  const annotationLayer = new AnnotationLayer({\n    div: document.createElement(\"div\"),\n    accessibilityManager: null,\n    annotationCanvasMap: null,\n    l10n: null,\n    page: pdfPage,\n    viewport: viewport,\n  });\n  const annotations = await pdfPage.getAnnotations();\n  await annotationLayer.render({\n    annotations,\n    div: annotationLayer.div,\n    linkService,\n    downloadManager,\n    imageResourcesPath,\n    renderForms,\n    svgFactory,\n    annotationStorage,\n  });\n  const freeTextAnnotations = annotations.filter(\n    (annotation) => annotation.annotationType === AnnotationType.FREETEXT\n  );\n  expect(freeTextAnnotations.length).toBeGreaterThan(0);\n  const freeTextAnnotation = freeTextAnnotations[0];\n  const freeTextElement = annotationLayer.div.querySelector(\n    `[data-annotation-id=\"${freeTextAnnotation.id}\"]`\n  );\n  expect(freeTextElement).not.toBeNull();\n  const popupElement = freeTextElement.querySelector(\".popup\");\n  expect(popupElement).not.toBeNull();\n});",
    "i4_deepseek-r1-distill-llama-70b": "it(\"should display FreeText annotation popup\", async () => {\n  const { PDFDocument, PDFPageProxy } = await import(\"../../src/display/api.js\");\n  const { AnnotationLayer } = await import(\"../../src/display/annotation_layer.js\");\n\n  // Create a sample PDF with FreeText annotation\n  const pdfContent = new Uint8Array([\n    0x25, 0x50, 0x44, 0x46, 0x2D, 0x31, 0x2E, 0x30, 0x0A, 0x25, 0xB5, 0xB5, 0xB5, 0xB5, 0x0A, 0x08,\n    0x30, 0x30, 0x30, 0x30, 0x0A, 0x25, 0xE2, 0xE3, 0xCF, 0xD0, 0x0A, 0x31, 0x32,\n    0x30, 0x30, 0x0A, 0x28, 0x2F, 0x2F, 0x2F, 0x2F, 0x0A, 0x28, 0x2F, 0x2F, 0x2F,\n    0x2F, 0x0A, 0x28, 0x2F, 0x2F, 0x2F, 0x2F, 0x0A, 0x28, 0x2F, 0x2F, 0x2F,\n    0x2F, 0x0A, 0x25, 0xE2, 0xE3, 0xCF, 0xD0, 0x0A, 0x31, 0x32, 0x30, 0x30,\n    0x0A, 0x25, 0xE2, 0xE3, 0xCF, 0xD0, 0x0A, 0x30, 0x30, 0x30, 0x30, 0x0A,\n    0x25, 0xE2, 0xE3, 0xCF, 0xD0, 0x0A, 0x25, 0xE2, 0xE3, 0xCF, 0xD0,\n  ]).buffer;\n\n  const pdf = await PDFDocument.load({\n    data: pdfContent,\n    container: null,\n    autoFetch: false,\n    cMapUrl: null,\n    maxCanvasPixels: null,\n  });\n\n  const page = await pdf.getPage(1);\n  const viewport = page.getViewPort({ scale: 1 });\n  const annotationLayer = new AnnotationLayer({\n    div: document.createElement(\"div\"),\n    page,\n    viewport,\n    l10n: null,\n    accessibilityManager: null,\n  });\n\n  // Simulate FreeText annotation data\n  const annotations = [\n    {\n      id: \"freeText1\",\n      annotationType: \"FREETEXT\",\n      titleObj: { str: \"Test Title\" },\n      contentsObj: { str: \"Test Content\" },\n      popupRef: null,\n      rect: [0, 0, 100, 100],\n    },\n  ];\n\n  await annotationLayer.render({\n    annotations,\n    div: annotationLayer.div,\n    page,\n    viewport,\n    linkService: null,\n    downloadManager: null,\n    imageResourcesPath: \"\",\n    renderForms: true,\n    enableScripting: false,\n    hasJSActions: false,\n    fieldObjects: null,\n    annotationCanvasMap: null,\n  });\n\n  const popup = annotationLayer.div.querySelector(\".popup\");\n  expect(popup).toBeTruthy();\n});",
    "i4_gpt-4o": "it(\"should display FreeText annotation with popup data\", async () => {\n  const { FreeTextAnnotationElement } = await import(\"../../src/display/annotation_layer.js\");\n  const parameters = {\n    data: {\n      id: \"123\",\n      annotationType: 2,\n      popupRef: null,\n      titleObj: { str: \"Title\" },\n      contentsObj: { str: \"Contents\" },\n      richText: { str: \"Rich Text\" },\n      textContent: [\"Sample text\"],\n      textPosition: { x: 0, y: 0 },\n      rect: [0, 0, 100, 100],\n      borderStyle: { width: 1 },\n    },\n    layer: document.createElement(\"div\"),\n    linkService: {},\n    downloadManager: {},\n    imageResourcesPath: \"\",\n    renderForms: false,\n    svgFactory: {},\n    annotationStorage: {},\n    enableScripting: false,\n    hasJSActions: false,\n    fieldObjects: null,\n    parent: { div: document.createElement(\"div\"), zIndex: 0 },\n  };\n  const element = new FreeTextAnnotationElement(parameters);\n  const rendered = element.render();\n  const expected = true;\n  const actual = rendered.querySelector(\".popupAnnotation\") !== null;\n  expect(actual).toBe(expected);\n});",
    "i4_llama-3.3-70b-versatile": "it(\"should display FreeText annotation\", async () => {\n  const { AnnotationElementFactory, AnnotationLayer, AnnotationPrefix } = await import(\"../../src/display/annotation_layer.js\");\n  const { PDFPageProxy, PageViewport } = await import(\"../../src/display/api.js\");\n  const { NullL10n } = await import(\"../../web/l10n_utils.js\");\n  const { AnnotationStorage } = await import(\"../../src/display/annotation_storage.js\");\n\n  const annotation = {\n    id: \"123\",\n    annotationType: \"FREETEXT\",\n    rect: [10, 10, 50, 50],\n    titleObj: { str: \"Title\" },\n    contentsObj: { str: \"Contents\" },\n  };\n\n  const page = { view: [0, 0, 100, 100] };\n  const viewport = new PageViewport({ page, rotation: 0, scale: 1 });\n  const div = document.createElement(\"div\");\n  const linkService = { eventBus: { dispatch: () => {} } };\n  const downloadManager = {};\n  const annotationStorage = new AnnotationStorage();\n  const l10n = new NullL10n();\n\n  const annotationLayer = new AnnotationLayer({\n    div,\n    accessibilityManager: null,\n    annotationCanvasMap: null,\n    l10n,\n    page: new PDFPageProxy({}),\n    viewport,\n  });\n\n  await annotationLayer.render({\n    annotations: [annotation],\n    div,\n    linkService,\n    downloadManager,\n    annotationStorage,\n    l10n,\n    page: new PDFPageProxy({}),\n    viewport,\n    renderForms: true,\n  });\n\n  const freeTextAnnotation = div.querySelector(`[${AnnotationPrefix}id=\"123\"]`);\n  expect(freeTextAnnotation).not.toBeNull();\n});",
    "i5_deepseek-r1-distill-llama-70b": "it(\"should display FreeText annotation with content\", async () => {\n  const { PDFDocumentLoadingTask } = await import(\"../../src/display/api.js\");\n  const { AnnotationLayer } = await import(\"../../src/display/annotation_layer.js\");\n  const { Annotation } = await import(\"../../src/core/annotation.js\");\n\n  // Load a test PDF document\n  const pdf = await PDFDocumentLoadingTask.load(\"../src/test/pdfs/annotation-test.pdf\");\n  const page = await pdf.getPage(1);\n  const annotationLayer = new AnnotationLayer({\n    page,\n    annotations: [],\n    renderInteractiveForms: true\n  });\n\n  // Create a FreeText annotation with content\n  const freeTextAnnotation = new Annotation({\n    type: \"FreeText\",\n    titleObj: { str: \"Test Title\" },\n    contentsObj: { str: \"Test Content\" },\n    richText: { str: \"<p>Test Rich Text</p>\" }\n  });\n\n  annotationLayer.annotations.add(freeTextAnnotation);\n  await annotationLayer.render();\n\n  // Verify that the popup is created and visible\n  const popup = annotationLayer._popup;\n  expect(popup).toBeTruthy();\n});",
    "i5_gpt-4o": "it(\"should display FreeText annotation with popup data\", async () => {\n  const { AnnotationLayer } = await import(\"../../src/display/annotation_layer.js\");\n  const { AnnotationType } = await import(\"../../src/shared/util.js\");\n\n  const annotationData = {\n    annotationType: AnnotationType.FREETEXT,\n    titleObj: { str: \"Title\" },\n    contentsObj: { str: \"Contents\" },\n    richText: { str: \"Rich Text\" },\n    textContent: \"Sample text\",\n    textPosition: { x: 10, y: 10 },\n  };\n\n  const parameters = {\n    data: annotationData,\n    page: { view: [0, 0, 100, 100] },\n    viewport: { convertToViewportRectangle: (rect) => rect },\n  };\n\n  const annotationElement = new AnnotationLayer.FreeTextAnnotationElement(parameters);\n  const container = annotationElement.render();\n\n  const expected = true;\n  const actual = container.querySelector(\".popup\") !== null;\n\n  expect(actual).toBe(expected);\n});",
    "i5_llama-3.3-70b-versatile": "it(\"should display FreeText annotation\", async () => {\n  const { PDFDocument } = await import(\"../../src/display/api.js\");\n  const { AnnotationLayer } = await import(\"../../src/display/annotation_layer.js\");\n  const pdf = await PDFDocument.load(await (await import(\"../../src/display/network.js\")).PDFNetworkStream.fetch(\"path_to_pdf_with_freetext_annotation\"));\n  const page = await pdf.getPage(1);\n  const annotationLayer = new AnnotationLayer({\n    page,\n    viewport: page.getViewport({ scale: 1 }),\n    renderInteractiveForms: false,\n  });\n  const annotations = await page.getAnnotations();\n  const freeTextAnnotation = annotations.find(annotation => annotation.subtype === \"FreeText\");\n  const annotationElement = annotationLayer.renderAnnotation(freeTextAnnotation);\n  const popupElement = annotationElement.container.querySelector(\".popup\");\n  const expected = freeTextAnnotation.contents;\n  const actual = popupElement && popupElement.textContent;\n  expect(actual).toBe(expected);\n});"
  },
  "16943": {
    "i1_deepseek-r1-distill-llama-70b": "it(\"should change resizer and line style when editor is selected\", async () => {\n  const { AnnotationEditor } = await import(\"../../src/display/editor/editor.js\");\n  const { FreeTextEditor } = await import(\"../../src/display/editor/freetext.js\");\n\n  // Setup editor with specific dimensions and rotation\n  const editor = new FreeTextEditor({\n    parent: {\n      viewport: {\n        rotation: 0,\n        pageWidth: 100,\n        pageHeight: 100,\n        pageX: 0,\n        pageY: 0\n      }\n    },\n    x: 10,\n    y: 20,\n    id: \"test-editor\",\n    uiManager: {}\n  });\n\n  // Apply the fix and set position to trigger the style changes\n  editor.fixAndSetPosition();\n\n  // Query the resizer elements and verify their styles\n  const resizers = editor.div.querySelectorAll('.resizer');\n  expect(resizers.length).toBe(4);\n\n  const expectedBorder = '1px solid rgb(255, 0, 0)';\n  for (const resizer of resizers) {\n    expect(resizer.style.border).toBe(expectedBorder);\n  }\n});",
    "i1_gpt-4o": "it(\"should change the style of the line and resizers around a selected editor\", async () => {\n  const { AnnotationEditor } = await import(\"../../src/display/editor/editor.js\");\n  const { FreeTextEditor } = await import(\"../../src/display/editor/freetext.js\");\n  const { InkEditor } = await import(\"../../src/display/editor/ink.js\");\n\n  // Mocking getComputedStyle to return a specific outline width\n  global.getComputedStyle = () => ({\n    getPropertyValue: () => \"2px\",\n  });\n\n  // Initialize editors\n  AnnotationEditor.initialize({});\n  FreeTextEditor.initialize({});\n  InkEditor.initialize({});\n\n  // Create instances of editors\n  const freeTextEditor = new FreeTextEditor({ parent: { viewport: { rotation: 0, rawDims: { pageWidth: 100, pageHeight: 100, pageX: 0, pageY: 0 } } }, id: \"1\", x: 10, y: 10, uiManager: { viewParameters: { rotation: 0 } } });\n  const inkEditor = new InkEditor({ parent: { viewport: { rotation: 0, rawDims: { pageWidth: 100, pageHeight: 100, pageX: 0, pageY: 0 } } }, id: \"2\", x: 20, y: 20, uiManager: { viewParameters: { rotation: 0 } } });\n\n  // Expected border line width after initialization\n  const expectedBorderLineWidth = 2;\n\n  // Actual border line width\n  const actualBorderLineWidth = AnnotationEditor._borderLineWidth;\n\n  // Verify that the border line width is set correctly\n  expect(actualBorderLineWidth).toBe(expectedBorderLineWidth);\n});",
    "i1_llama-3.3-70b-versatile": "it(\"should change the style of the line and the resizers around a selected editor\", async () => {\n  const { AnnotationEditor } = await import(\"../../src/display/editor/editor.js\");\n  const { getComputedStyle } = await import(\"../../src/shared/util.js\");\n  const editor = new AnnotationEditor({ parent: { viewport: { rotation: 0 } }, id: 1, x: 10, y: 10, uiManager: {} });\n  const style = getComputedStyle(document.documentElement);\n  AnnotationEditor.initialize({ get: () => {} });\n  editor.div = { style: {} };\n  editor.fixAndSetPosition();\n  const left = editor.div.style.left;\n  const top = editor.div.style.top;\n  expect(left).not.toBe(`${(100 * editor.x).toFixed(2)}%`);\n  expect(top).not.toBe(`${(100 * editor.y).toFixed(2)}%`);\n});",
    "i2_deepseek-r1-distill-llama-70b": "it(\"should adjust editor position accounting for border width\", async () => {\n  const { AnnotationEditor } = await import(\"./editor.js\");\n  const { FreeTextEditor } = await import(\"./freetext.js\");\n\n  // Mock viewport with known dimensions and rotation\n  const viewport = {\n    width: 100,\n    height: 100,\n    rotation: 0,\n  };\n\n  // Create editor with initial position\n  const editor = new FreeTextEditor({\n    parent: {\n      viewport,\n      pageIndex: 0,\n    },\n    id: \"test-editor\",\n    x: 10,\n    y: 20,\n    width: 30,\n    height: 40,\n    uiManager: {},\n    isCentered: false,\n  });\n\n  // Initialize the editor\n  editor.initialize();\n\n  // Apply the fix and set the position\n  editor.fixAndSetPosition();\n\n  // Check the styles applied to the editor div\n  const style = editor.div.style;\n  expect(style.left).toBe(\"10.00%\");\n  expect(style.top).toBe(\"20.00%\");\n});\n\nit(\"should adjust resizer positions accounting for border width\", async () => {\n  const { AnnotationEditor } = await import(\"./editor.js\");\n  const { FreeTextEditor } = await import(\"./freetext.js\");\n\n  // Mock viewport with known dimensions and rotation\n  const viewport = {\n    width: 100,\n    height: 100,\n    rotation: 0,\n  };\n\n  // Create editor with initial position\n  const editor = new FreeTextEditor({\n    parent: {\n      viewport,\n      pageIndex: 0,\n    },\n    id: \"test-editor\",\n    x: 10,\n    y: 20,\n    width: 30,\n    height: 40,\n    uiManager: {},\n    isCentered: false,\n  });\n\n  // Initialize the editor\n  editor.initialize();\n\n  // Apply the fix and set the position\n  editor.fixAndSetPosition();\n\n  // Check the styles applied to the resizer elements\n  const resizers = editor.div.querySelectorAll(\".resizer\");\n  resizers.forEach(resizer => {\n    const border = window.getComputedStyle(resizer).border;\n    expect(border).toMatch(/rgba\\(0, 0, 0, 0.5\\) solid (\\d+\\.?\\d*)px/);\n  });\n});",
    "i2_gpt-4o": "it(\"should change the style of the line and the resizers around a selected editor\", async () => {\n  const { AnnotationEditor } = await import(\"../../src/display/editor/editor.js\");\n  const { FreeTextEditor } = await import(\"../../src/display/editor/freetext.js\");\n  const { InkEditor } = await import(\"../../src/display/editor/ink.js\");\n\n  // Initialize editors\n  const annotationEditorParams = {\n    parent: { viewport: { rotation: 0, rawDims: { pageWidth: 100, pageHeight: 100, pageX: 0, pageY: 0 } }, pageIndex: 0 },\n    id: \"test-editor\",\n    uiManager: { viewParameters: { rotation: 0 } },\n    x: 10,\n    y: 10,\n    isCentered: false,\n  };\n\n  const freeTextEditor = new FreeTextEditor(annotationEditorParams);\n  const inkEditor = new InkEditor(annotationEditorParams);\n\n  // Initialize styles\n  AnnotationEditor.initialize({});\n  FreeTextEditor.initialize({});\n  InkEditor.initialize({});\n\n  // Define expected border line width\n  const style = getComputedStyle(document.documentElement);\n  const expectedBorderLineWidth = parseFloat(style.getPropertyValue(\"--outline-width\")) || 0;\n\n  // Generate actual border line width\n  const actualBorderLineWidth = AnnotationEditor._borderLineWidth;\n\n  // Compare expected with actual\n  expect(actualBorderLineWidth).toBe(expectedBorderLineWidth);\n});",
    "i2_llama-3.3-70b-versatile": "it(\"should change the style of the line and the resizers around a selected editor\", async () => {\n  const { AnnotationEditor } = await import(\"./editor.js\");\n  const { ColorManager } = await import(\"./tools.js\");\n  const { getComputedStyle } = await import(\"../../shared/util.js\");\n\n  const annotationEditor = new AnnotationEditor({\n    parent: { viewport: { rotation: 0 } },\n    id: \"test-editor\",\n    uiManager: { viewParameters: { rotation: 0 } },\n  });\n\n  const style = getComputedStyle(document.documentElement);\n  const borderLineWidth = parseFloat(style.getPropertyValue(\"--outline-width\")) || 0;\n\n  annotationEditor.initialize();\n\n  const expectedBorderWidth = borderLineWidth;\n  const actualBorderWidth = AnnotationEditor._borderLineWidth;\n\n  expect(actualBorderWidth).toBe(expectedBorderWidth);\n});",
    "i3_deepseek-r1-distill-llama-70b": "it(\"should apply the correct border width to resizers\", async () => {\n  const { AnnotationEditor } = await import(\"../../src/display/editor/editor.js\");\n  const editor = new AnnotationEditor({\n    parent: { pageIndex: 0 },\n    uiManager: {},\n    id: \"test-editor\",\n    x: 0,\n    y: 0,\n  });\n\n  editor.select();\n\n  const resizer = editor.#resizersDiv.querySelector(\".resizer\");\n  const expectedBorderWidth = 2; // Assuming --outline-width is 2px\n\n  expect(getComputedStyle(resizer).borderWidth).toBe(`${expectedBorderWidth}px`);\n});",
    "i3_gpt-4o": "it(\"should change the style of the line and resizers around a selected editor\", async () => {\n  const { AnnotationEditor } = await import(\"../../src/display/editor/editor.js\");\n  const { FreeTextEditor } = await import(\"../../src/display/editor/freetext.js\");\n  const { InkEditor } = await import(\"../../src/display/editor/ink.js\");\n\n  const mockParent = {\n    pageIndex: 0,\n    viewport: {\n      rotation: 0,\n      rawDims: { pageWidth: 100, pageHeight: 100, pageX: 0, pageY: 0 },\n    },\n    div: document.createElement(\"div\"),\n    add: jest.fn(),\n    remove: jest.fn(),\n    setSelected: jest.fn(),\n    toggleSelected: jest.fn(),\n    setActiveEditor: jest.fn(),\n    updateToolbar: jest.fn(),\n    setEditingState: jest.fn(),\n    isMultipleSelection: false,\n  };\n\n  const mockUIManager = {\n    addToAnnotationStorage: jest.fn(),\n    removeEditor: jest.fn(),\n    isSelected: jest.fn().mockReturnValue(true),\n    setUpDragSession: jest.fn(),\n    endDragSession: jest.fn().mockReturnValue(false),\n    dragSelectedEditors: jest.fn(),\n    translateSelectedEditors: jest.fn(),\n    currentLayer: { div: document.createElement(\"div\") },\n  };\n\n  const editorParams = {\n    parent: mockParent,\n    uiManager: mockUIManager,\n    id: \"editor1\",\n    x: 10,\n    y: 10,\n  };\n\n  const freeTextEditor = new FreeTextEditor(editorParams);\n  const inkEditor = new InkEditor(editorParams);\n\n  freeTextEditor.select();\n  inkEditor.select();\n\n  const freeTextEditorStyle = freeTextEditor.div.style;\n  const inkEditorStyle = inkEditor.div.style;\n\n  expect(freeTextEditorStyle.zIndex).toBe(\"1\");\n  expect(inkEditorStyle.zIndex).toBe(\"1\");\n\n  const resizersDiv = freeTextEditor.div.querySelector(\".resizers\");\n  expect(resizersDiv).not.toBeNull();\n  expect(resizersDiv.classList.contains(\"hidden\")).toBe(false);\n});",
    "i3_llama-3.3-70b-versatile": "it(\"should change the style of the line and the resizers around a selected editor\", async () => {\n  const { AnnotationEditor } = await import(\"../../src/display/editor/editor.js\");\n  const editor = new AnnotationEditor({\n    parent: { pageIndex: 1, pageDimensions: [100, 100], div: document.createElement(\"div\") },\n    uiManager: { addCommands: () => {} },\n    id: \"editor\",\n    name: \"editor\",\n  });\n  editor.select();\n  const resizersDiv = editor.#resizersDiv;\n  expect(resizersDiv.classList.contains(\"hidden\")).toBe(false);\n  expect(editor.div.classList.contains(\"selectedEditor\")).toBe(true);\n});",
    "i4_deepseek-r1-distill-llama-70b": "it(\"should adjust editor position based on border line width\", async () => {\n  const { AnnotationEditor } = await import(\"../../src/display/editor/editor.js\");\n\n  // Mock the CSS variable\n  const mockGetComputedStyle = {\n    getPropertyValue: () => \"2px\"\n  };\n  const originalGetComputedStyle = window.getComputedStyle;\n  window.getComputedStyle = () => mockGetComputedStyle;\n\n  // Initialize the editor\n  class TestEditor extends AnnotationEditor {}\n  TestEditor.initialize({});\n\n  // Verify the border line width is correctly read\n  const expectedBorderWidth = 2;\n  const actualBorderWidth = AnnotationEditor._borderLineWidth;\n  expect(actualBorderWidth).toBe(expectedBorderWidth);\n\n  // Test position adjustment\n  const editor = new TestEditor({/* required params */});\n  const [parentWidth, parentHeight] = [100, 100]; // Mock parent dimensions\n  const [tx, ty] = [10, 10]; // Mock translation\n\n  // Calculate expected position\n  const expectedX = tx - (expectedBorderWidth / parentWidth);\n  const expectedY = ty - (expectedBorderWidth / parentHeight);\n\n  // Get actual position\n  const actualX = editor.x;\n  const actualY = editor.y;\n\n  expect(actualX).toBeCloseTo(expectedX);\n  expect(actualY).toBeCloseTo(expectedY);\n\n  // Cleanup\n  window.getComputedStyle = originalGetComputedStyle;\n});",
    "i4_gpt-4o": "it(\"should change the style of the line and the resizers around a selected editor\", async () => {\n  const { AnnotationEditor } = await import(\"../../src/display/editor/editor.js\");\n  const { FreeTextEditor } = await import(\"../../src/display/editor/freetext.js\");\n  const { InkEditor } = await import(\"../../src/display/editor/ink.js\");\n\n  const mockParent = {\n    pageIndex: 0,\n    viewport: {\n      rotation: 0,\n      rawDims: { pageWidth: 100, pageHeight: 100, pageX: 0, pageY: 0 },\n    },\n    div: document.createElement(\"div\"),\n    add: jest.fn(),\n    remove: jest.fn(),\n    setSelected: jest.fn(),\n    toggleSelected: jest.fn(),\n    setActiveEditor: jest.fn(),\n    updateToolbar: jest.fn(),\n    setEditingState: jest.fn(),\n    isMultipleSelection: false,\n  };\n\n  const mockUIManager = {\n    addToAnnotationStorage: jest.fn(),\n    removeEditor: jest.fn(),\n    isSelected: jest.fn().mockReturnValue(true),\n    setUpDragSession: jest.fn(),\n    endDragSession: jest.fn().mockReturnValue(false),\n    dragSelectedEditors: jest.fn(),\n    translateSelectedEditors: jest.fn(),\n    currentLayer: { div: document.createElement(\"div\") },\n  };\n\n  const editorParams = {\n    parent: mockParent,\n    uiManager: mockUIManager,\n    id: \"test-editor\",\n    x: 10,\n    y: 10,\n  };\n\n  const freeTextEditor = new FreeTextEditor(editorParams);\n  const inkEditor = new InkEditor(editorParams);\n\n  document.body.appendChild(mockParent.div);\n  mockParent.div.appendChild(freeTextEditor.render());\n  mockParent.div.appendChild(inkEditor.render());\n\n  freeTextEditor.select();\n  inkEditor.select();\n\n  const freeTextEditorStyle = getComputedStyle(freeTextEditor.div);\n  const inkEditorStyle = getComputedStyle(inkEditor.div);\n\n  const expectedBorderWidth = parseFloat(getComputedStyle(document.documentElement).getPropertyValue(\"--outline-width\")) || 0;\n\n  expect(freeTextEditorStyle.borderWidth).toBe(`${expectedBorderWidth}px`);\n  expect(inkEditorStyle.borderWidth).toBe(`${expectedBorderWidth}px`);\n});",
    "i4_llama-3.3-70b-versatile": "it(\"should change the style of the line and the resizers around a selected editor\", async () => {\n  const { AnnotationEditor } = await import(\"./editor.js\");\n  const { FreeTextEditor } = await import(\"./freetext.js\");\n  const { InkEditor } = await import(\"./ink.js\");\n\n  const editor = new AnnotationEditor({ parent: null, uiManager: null, id: \"test\" });\n  const freeTextEditor = new FreeTextEditor({ parent: null, uiManager: null, id: \"test\" });\n  const inkEditor = new InkEditor({ parent: null, uiManager: null, id: \"test\" });\n\n  editor.select();\n  freeTextEditor.select();\n  inkEditor.select();\n\n  const expectedStyle = \"selectedEditor\";\n  const actualStyle = editor.div.className;\n  const actualFreeTextStyle = freeTextEditor.div.className;\n  const actualInkStyle = inkEditor.div.className;\n\n  expect(actualStyle).toContain(expectedStyle);\n  expect(actualFreeTextStyle).toContain(expectedStyle);\n  expect(actualInkStyle).toContain(expectedStyle);\n});",
    "i5_deepseek-r1-distill-llama-70b": "it(\"should adjust editor position accounting for border line width\", async () => {\n  const { AnnotationEditor } = await import(\"../../src/display/editor/editor.js\");\n  const { FreeTextEditor } = await import(\"../../src/display/editor/freetext.js\");\n\n  // Mock getComputedStyle to return a specific outline width\n  const mockGetComputedStyle = {\n    getPropertyValue: () => \"--outline-width: 2px\"\n  };\n  global.getComputedStyle = jest.fn(() => mockGetComputedStyle);\n\n  // Initialize the editor\n  FreeTextEditor.initialize(new Map());\n  await AnnotationEditor.initialize(new Map());\n\n  // Create a test editor instance\n  const editor = new FreeTextEditor();\n  editor.parentDimensions = [100, 100]; // Parent dimensions in pixels\n  editor.pageDimensions = [100, 100]; // Page dimensions in pixels\n  editor.rotation = 0; // No rotation for this test\n\n  // Set the position and check the style\n  editor.x = 0.5;\n  editor.y = 0.5;\n  editor.setPosition();\n\n  // Get the computed style\n  const style = editor.div.style;\n\n  // Expected values considering border line width\n  const expectedLeft = (0.5 + (2/100)).toFixed(2);\n  const expectedTop = (0.5 + (2/100)).toFixed(2);\n\n  expect(style.left).toBe(expectedLeft + \"%\");\n  expect(style.top).toBe(expectedTop + \"%\");\n});",
    "i5_gpt-4o": "it(\"should change the style of the line and the resizers around a selected editor\", async () => {\n  const { AnnotationEditor } = await import(\"../../src/display/editor/editor.js\");\n  const { FreeTextEditor } = await import(\"../../src/display/editor/freetext.js\");\n  const { InkEditor } = await import(\"../../src/display/editor/ink.js\");\n\n  // Initialize the editors\n  const l10n = { get: (str) => Promise.resolve(str) };\n  FreeTextEditor.initialize(l10n);\n  InkEditor.initialize(l10n);\n\n  // Mock document style\n  document.documentElement.style.setProperty(\"--outline-width\", \"2px\");\n\n  // Create instances of editors\n  const freeTextEditor = new FreeTextEditor();\n  const inkEditor = new InkEditor();\n\n  // Expected border line width\n  const expectedBorderLineWidth = 2;\n\n  // Actual border line width\n  const actualBorderLineWidth = AnnotationEditor._borderLineWidth;\n\n  // Compare expected with actual\n  expect(actualBorderLineWidth).toBe(expectedBorderLineWidth);\n});",
    "i5_llama-3.3-70b-versatile": "it(\"should change the style of the line and the resizers around a selected editor\", async () => {\n  const { AnnotationEditor } = await import(\"../../src/display/editor/editor.js\");\n  const { AnnotationEditorLayer } = await import(\"../../src/display/editor/annotation_editor_layer.js\");\n  const { PDFPageView } = await import(\"../../web/pdf_page_view.js\");\n\n  const pageView = new PDFPageView();\n  const annotationEditorLayer = new AnnotationEditorLayer(pageView);\n  const annotationEditor = new AnnotationEditor(annotationEditorLayer);\n\n  const initialBorderWidth = annotationEditor.div.style.borderStyle;\n  const initialResizerStyle = annotationEditor.div.children[0].style.borderStyle;\n\n  annotationEditor.initialize();\n\n  const updatedBorderWidth = annotationEditor.div.style.borderStyle;\n  const updatedResizerStyle = annotationEditor.div.children[0].style.borderStyle;\n\n  expect(updatedBorderWidth).not.toBe(initialBorderWidth);\n  expect(updatedResizerStyle).not.toBe(initialResizerStyle);\n});"
  },
  "17003": {
    "i1_deepseek-r1-distill-llama-70b": "it(\"should not warn about unknown field names when collecting fields for printing\", async () => {\n  const { XRefMock, createIdFactory } = await import(\"./test_utils.js\");\n  const { AnnotationFactory, Annotation, Name, Dict, Ref } = await import(\"../../src/core/annotation.js\");\n  const { warn } = await import(\"../../src/shared/util.js\");\n\n  const xref = new XRefMock();\n  const ref = new Ref(1, 0);\n  const dict = new Dict();\n  dict.set(\"Subtype\", new Name(\"Unknown\"));\n  dict.set(\"T\", new Name(\"title\"));\n  dict.set(\"Contents\", new Name(\"contents\"));\n  dict.set(\"Rect\", [0, 0, 0, 0]);\n  dict.set(\"F\", 0);\n\n  const idFactory = createIdFactory();\n  const annotationGlobals = {\n    pdfManager: {\n      evaluatorOptions: {}\n    },\n    acroForm: new Dict(),\n    structTreeRoot: null\n  };\n\n  const mockWarn = jest.spyOn(Util, \"warn\");\n\n  const annotation = await AnnotationFactory.create(\n    xref,\n    ref,\n    annotationGlobals,\n    idFactory,\n    true, // collectFields = true\n    null\n  );\n\n  expect(mockWarn).not.toHaveBeenCalledWith(\n    \"Unknown field name, falling back to empty field name.\"\n  );\n});",
    "i1_gpt-4o": "it(\"should not warn about unknown field name when printing a PDF with annotations\", async () => {\n  const { AnnotationFactory } = await import(\"../../src/core/annotation.js\");\n  const { Dict, Name, Ref } = await import(\"../../src/core/primitives.js\");\n  const { XRefMock } = await import(\"./test_utils.js\");\n  const { AnnotationActionEventType } = await import(\"../../src/shared/util.js\");\n\n  const xref = new XRefMock();\n  const ref = new Ref(1, 0);\n  const dict = new Dict();\n  dict.set(\"Subtype\", Name.get(\"Widget\"));\n  dict.set(\"FT\", Name.get(\"Tx\"));\n  dict.set(\"Kids\", [new Ref(2, 0)]);\n  dict.set(\"T\", \"Test\");\n  dict.set(\"F\", 0);\n  dict.set(\"Rect\", [0, 0, 32, 32]);\n  dict.set(\"C\", [0, 0, 0]);\n  dict.set(\"M\", \"D:20230315000000Z\");\n\n  const annotationGlobals = {\n    acroForm: new Dict(),\n    pdfManager: {\n      ensure: (context, methodName, args) => {\n        return context[methodName](...args);\n      },\n      evaluatorOptions: { isOffscreenCanvasSupported: false },\n    },\n  };\n\n  const idFactory = createIdFactory(0);\n  const annotation = await AnnotationFactory.create(\n    xref,\n    ref,\n    annotationGlobals,\n    idFactory,\n    true,\n    null\n  );\n\n  const expected = {\n    annotationFlags: 0,\n    borderStyle: undefined,\n    color: [0, 0, 0],\n    backgroundColor: undefined,\n    borderColor: undefined,\n    rotation: undefined,\n    contentsObj: undefined,\n    hasAppearance: false,\n    id: \"1R\",\n    modificationDate: \"D:20230315000000Z\",\n    rect: [0, 0, 32, 32],\n    subtype: \"Widget\",\n    hasOwnCanvas: false,\n    noRotate: false,\n    noHTML: false,\n    kidIds: [\"2R\"],\n    actions: {},\n    fieldName: \"Test\",\n    pageIndex: 0,\n  };\n\n  expect(annotation.data).toEqual(expected);\n});",
    "i1_llama-3.3-70b-versatile": "it(\"should not throw a warning when printing a pdf with an added annotation\", async () => {\n  const { AnnotationFactory, XRefMock, createIdFactory } = await import(\"../../src/core/annotation.js\");\n  const { DefaultCMapReaderFactory, DefaultStandardFontDataFactory } = await import(\"../../src/display/api.js\");\n  const { Dict, Name, Ref } = await import(\"../../src/core/primitives.js\");\n  const { warn } = await import(\"../../src/shared/util.js\");\n\n  const originalWarn = console.warn;\n  console.warn = jest.fn();\n\n  const xref = new XRefMock();\n  const annotationGlobals = {\n    pdfManager: {\n      evaluatorOptions: {},\n    },\n    acroForm: new Dict(),\n  };\n  const idFactory = createIdFactory();\n  const ref = new Ref(1, 0);\n  const dict = new Dict();\n  dict.set(\"Subtype\", new Name(\"Widget\"));\n  dict.set(\"FT\", new Name(\"Tx\"));\n  xref.fetchIfRef = () => dict;\n\n  await AnnotationFactory.create(xref, ref, annotationGlobals, idFactory, true);\n\n  expect(console.warn).not.toHaveBeenCalledWith(\"Unknown field name, falling back to empty field name.\");\n  console.warn = originalWarn;\n});",
    "i2_deepseek-r1-distill-llama-70b": "it(\"should not log warning when printing with annotations\", async () => {\n  const { PDFDocument } = await import(\"../../web/pdf_document.js\");\n  const { Annotation } = await import(\"../../src/core/annotation.js\");\n  const { TestReporter } = await import(\"./testreporter.js\");\n\n  const reporter = new TestReporter();\n  let warningLogged = false;\n\n  reporter.warn = (message) => {\n    warningLogged = true;\n  };\n\n  // Create a sample PDF document with a page\n  const pdfDocument = new PDFDocument({\n    title: \"Test PDF\",\n    author: \"Test Author\",\n    creator: \"Test Creator\",\n  });\n\n  const page = pdfDocument.addPage();\n\n  // Create and add an annotation\n  const annotation = new Annotation();\n  page.annotations.add(annotation);\n\n  // Simulate printing\n  await pdfDocument.print();\n\n  // Verify no warning was logged\n  if (warningLogged) {\n    throw new Error(\"Warning was logged when printing with annotations\");\n  }\n});",
    "i2_gpt-4o": "it(\"should not log warning when printing a PDF with an added annotation\", async () => {\n  const { AnnotationFactory } = await import(\"../../src/core/annotation.js\");\n  const { Ref, Dict } = await import(\"../../src/core/primitives.js\");\n  const { warn } = await import(\"../../src/shared/util.js\");\n\n  const xref = {};\n  const ref = new Ref(1, 0);\n  const annotationGlobals = {\n    acroForm: new Dict(),\n    pdfManager: {\n      ensure: (context, methodName, args) => context[methodName](...args),\n      evaluatorOptions: {},\n    },\n  };\n  const idFactory = { createObjId: () => \"1\" };\n  const pageRef = new Ref(2, 0);\n\n  let warningMessage = null;\n  const originalWarn = warn;\n  warn = (msg) => {\n    warningMessage = msg;\n  };\n\n  await AnnotationFactory.create(xref, ref, annotationGlobals, idFactory, true, pageRef);\n\n  warn = originalWarn;\n\n  const expectedWarning = null;\n  const actualWarning = warningMessage;\n\n  expect(actualWarning).toBe(expectedWarning);\n});",
    "i2_llama-3.3-70b-versatile": "it(\"should not log warning when printing a pdf with an added annotation\", async () => {\n  const { AnnotationFactory, warn } = await import(\"../../src/core/annotation.js\");\n  const { PDFDocument } = await import(\"../../src/core/document.js\");\n  const { createIdFactory } = await import(\"../../src/shared/util.js\");\n  const originalWarn = console.warn;\n  console.warn = jest.fn();\n  const pdfDoc = await PDFDocument.load(await (await import(\"../../src/display/api.js\")).getDocument({ url: `${await (await import(\"../../src/shared/util.js\")).getModificationDate()}/web/test_files/annotation_test.pdf` }));\n  const annotationGlobals = { pdfManager: pdfDoc.pdfManager, acroForm: pdfDoc.catalog.get(\"AcroForm\") };\n  const idFactory = createIdFactory();\n  const pageIndex = 0;\n  const pageRef = pdfDoc.getPageIndexRef(pageIndex);\n  const annotationRef = await AnnotationFactory.create(pdfDoc.xref, pdfDoc.catalog.get(\"Annots\")[0], annotationGlobals, idFactory, true, pageRef);\n  console.warn = originalWarn;\n  expect(console.warn).not.toHaveBeenCalledWith(\"Warning: Unknown field name, falling back to empty field name.\");\n});",
    "i3_deepseek-r1-distill-llama-70b": "it(\"should not warn about unknown field names when printing annotations\", async () => {\n  const warnSpy = jest.spyOn(console, 'warn').mockImplementation(() => {});\n\n  const xref = new XRefMock();\n  const pdfManager = {\n    ensureCatalog: async () => ({}),\n    ensureDoc: async () => ({}),\n    getPage: async () => ({ annotations: [] }),\n  };\n\n  const annotationFactory = new AnnotationFactory();\n  const params = {\n    xref,\n    ref: new Ref(1),\n    annotationGlobals: {},\n    idFactory: createIdFactory(),\n    collectFields: true,\n    pageRef: new Ref(1),\n  };\n\n  const dict = new Dict();\n  const annotation = await annotationFactory.create(...Object.values(params));\n\n  const evaluator = {\n    xref,\n    options: { isOffscreenCanvasSupported: true },\n    getOperatorList: async () => ({ opList: new OperatorList() }),\n  };\n\n  const result = await annotation._getAppearance(evaluator, new WorkerTask(), RenderingIntentFlag.SAVE, null);\n\n  expect(warnSpy).not.toHaveBeenCalledWith('Unknown field name, falling back to empty field name.');\n});",
    "i3_gpt-4o": "it(\"should not warn about unknown field name when printing a PDF with annotations\", async () => {\n  const { AnnotationFactory } = await import(\"../../src/core/annotation.js\");\n  const { Dict, Ref } = await import(\"../../src/core/primitives.js\");\n  const { XRefMock } = await import(\"./test_utils.js\");\n\n  const xref = new XRefMock();\n  const ref = new Ref(1, 0);\n  const annotationDict = new Dict(xref);\n  annotationDict.set(\"Subtype\", Name.get(\"Widget\"));\n  annotationDict.set(\"T\", \"TestField\");\n  annotationDict.set(\"V\", \"TestValue\");\n\n  const annotationGlobals = {\n    acroForm: new Dict(xref),\n    pdfManager: {\n      ensure: (context, methodName, args) => {\n        return context[methodName](...args);\n      },\n    },\n  };\n\n  const idFactory = createIdFactory(0);\n  const annotation = await AnnotationFactory.create(\n    xref,\n    ref,\n    annotationGlobals,\n    idFactory,\n    false,\n    null\n  );\n\n  const consoleWarnSpy = jest.spyOn(console, \"warn\").mockImplementation(() => {});\n  annotation._constructFieldName(annotationDict);\n  expect(consoleWarnSpy).not.toHaveBeenCalledWith(\n    \"Unknown field name, falling back to empty field name.\"\n  );\n  consoleWarnSpy.mockRestore();\n});",
    "i3_llama-3.3-70b-versatile": "it(\"should resolve the warning when printing a pdf with an added annotation\", async () => {\n  const pdfManager = {\n    ensureCatalog: async (key) => {\n      if (key === \"acroForm\") {\n        return new Dict();\n      }\n      return null;\n    },\n    ensureDoc: async (key) => {\n      if (key === \"xfaDatasets\") {\n        return new Dict();\n      }\n      return null;\n    },\n    ensure: async (obj, method, args) => {\n      if (method === \"_create\") {\n        return new Annotation({\n          dict: new Dict(),\n          xref: new XRefMock(),\n          annotationGlobals: {\n            pdfManager,\n            acroForm: new Dict(),\n            xfaDatasets: new Dict(),\n            structTreeRoot: new Dict(),\n            baseUrl: new Dict(),\n            attachments: new Dict(),\n          },\n          idFactory: createIdFactory(),\n          collectFields: true,\n          pageIndex: 0,\n          pageRef: new Ref(),\n        });\n      }\n      return null;\n    },\n  };\n\n  const annotationFactory = new AnnotationFactory();\n  const xref = new XRefMock();\n  const ref = new Ref();\n  const annotationGlobals = await AnnotationFactory.createGlobals(pdfManager);\n  const idFactory = createIdFactory();\n\n  const consoleWarnSpy = jest.spyOn(console, \"warn\");\n\n  await annotationFactory.create(xref, ref, annotationGlobals, idFactory, true, new Ref());\n\n  expect(consoleWarnSpy).toHaveBeenCalledTimes(0);\n});",
    "i4_deepseek-r1-distill-llama-70b": "it(\"should not warn about unknown field name when collectFields is true\", async () => {\n  const { AnnotationFactory } = await import(\"../../src/core/annotation.js\");\n  const { warn } = await import(\"../../shared/util.js\");\n\n  // Mock the warn function\n  const mockWarn = jest.spyOn(util, \"warn\").mockImplementation(() => {});\n\n  // Create a mock annotation dictionary\n  const dict = {\n    get: (key) => {\n      if (key === \"P\") return new Ref();\n      return null;\n    },\n  };\n\n  // Create annotation with collectFields: true\n  const annotation = await AnnotationFactory.create(\n    null,\n    null,\n    null,\n    null,\n    true, // collectFields\n    null\n  );\n\n  // Verify no warning was emitted\n  expect(mockWarn).not.toHaveBeenCalledWith(\n    \"Unknown field name, falling back to empty field name.\"\n  );\n\n  mockWarn.mockRestore();\n});",
    "i4_gpt-4o": "it(\"should not log warning when printing a pdf with an added annotation\", async () => {\n  const { AnnotationFactory } = await import(\"../../src/core/annotation.js\");\n  const { PDFDocument } = await import(\"../../src/core/document.js\");\n  const { Ref, Dict } = await import(\"../../src/core/primitives.js\");\n  const { PDFWorker } = await import(\"../../src/display/api.js\");\n\n  const pdfManager = {\n    ensureCatalog: () => Promise.resolve(new Dict()),\n    ensureDoc: () => Promise.resolve(),\n    getPage: () => Promise.resolve({ annotations: [new Ref(1, 0)] }),\n    ensure: (context, method, args) => {\n      if (method === \"_create\") {\n        return Promise.resolve(new AnnotationFactory._create(...args));\n      }\n      return Promise.resolve();\n    },\n  };\n\n  const annotationGlobals = await AnnotationFactory.createGlobals(pdfManager);\n  const xref = { fetchIfRef: () => new Dict() };\n  const ref = new Ref(1, 0);\n  const idFactory = { createObjId: () => 1 };\n\n  const consoleWarnSpy = jest.spyOn(console, \"warn\").mockImplementation(() => {});\n\n  await AnnotationFactory.create(xref, ref, annotationGlobals, idFactory, true, null);\n\n  expect(consoleWarnSpy).not.toHaveBeenCalledWith(\n    \"Unknown field name, falling back to empty field name.\"\n  );\n\n  consoleWarnSpy.mockRestore();\n});",
    "i4_llama-3.3-70b-versatile": "it(\"should resolve the warning when printing a pdf with an added annotation\", async () => {\n  const { AnnotationFactory } = await import(\"../../src/core/annotation.js\");\n  const { PDFDocument } = await import(\"../../src/core/document.js\");\n  const { PDFPage } = await import(\"../../src/core/document.js\");\n  const { createIdFactory } = await import(\"../../src/shared/util.js\");\n\n  const pdfData = new Uint8Array([\n    0x25, 0x50, 0x44, 0x46, 0x2d, 0x31, 0x2e, 0x34, 0x0a, 0x25, 0xe2, 0xe3, 0xcf, 0xd3, 0x0a,\n    0x31, 0x20, 0x30, 0x20, 0x6f, 0x62, 0x6a, 0x0a, 0x3c, 0x3c, 0x0a, 0x2f, 0x54, 0x79, 0x70,\n    0x65, 0x20, 0x2f, 0x43, 0x61, 0x74, 0x61, 0x6c, 0x6f, 0x67, 0x0a, 0x2f, 0x50, 0x61, 0x67,\n    0x65, 0x73, 0x20, 0x31, 0x20, 0x30, 0x20, 0x52, 0x0a, 0x3e, 0x3e, 0x0a, 0x65, 0x6e, 0x64,\n    0x6f, 0x62, 0x6a, 0x0a, 0x32, 0x20, 0x30, 0x20, 0x6f, 0x62, 0x6a, 0x0a, 0x3c, 0x3c, 0x0a,\n    0x2f, 0x54, 0x79, 0x70, 0x65, 0x20, 0x2f, 0x50, 0x61, 0x67, 0x65, 0x0a, 0x2f, 0x4d, 0x65,\n    0x64, 0x69, 0x61, 0x42, 0x6f, 0x78, 0x20, 0x5b, 0x30, 0x20, 0x30, 0x20, 0x35, 0x39, 0x2e,\n    0x36, 0x20, 0x35, 0x39, 0x2e, 0x36, 0x5d",
    "i5_deepseek-r1-distill-llama-70b": "it(\"should not warn about unknown field names when printing with annotations\", async () => {\n  const { PDFDocument } = await import(\"../../src/core/document.js\");\n  const { Annotation, AnnotationFactory } = await import(\"../../src/core/annotation.js\");\n\n  // Create a test PDF document\n  const pdf = new PDFDocument();\n  const page = pdf.addPage();\n\n  // Create a test annotation\n  const annotation = new Annotation({\n    subtype: \"Square\",\n    page: page,\n    rect: [0, 0, 100, 100],\n    color: \"#FF0000\",\n    author: \"Test Author\",\n    content: \"Test Annotation\"\n  });\n\n  // Set up console.warn mock\n  const originalWarn = console.warn;\n  const warningMessage = \"Warning: Unknown field name, falling back to empty field name.\";\n  let warned = false;\n\n  console.warn = (message) => {\n    if (message === warningMessage) {\n      warned = true;\n    }\n  };\n\n  // Print the document with the annotation\n  const printTask = pdf.print();\n  await printTask.promise;\n\n  // Restore console.warn\n  console.warn = originalWarn;\n\n  // Assert that the warning was not logged\n  expect(warned).toBe(false);\n});",
    "i5_gpt-4o": "it(\"should not log a warning when printing a PDF with an added annotation\", async () => {\n  const { AnnotationFactory } = await import(\"../../src/core/annotation.js\");\n  const { PDFDocument } = await import(\"../../src/core/document.js\");\n  const { PDFPageProxy } = await import(\"../../src/display/api.js\");\n  const { createIdFactory } = await import(\"./test_utils.js\");\n\n  const pdfDocument = new PDFDocument();\n  const pageIndex = 0;\n  const pageRef = null;\n  const annotationGlobals = {};\n  const idFactory = createIdFactory();\n  const ref = null;\n  const collectFields = true;\n\n  const annotationFactory = new AnnotationFactory();\n  const annotation = annotationFactory.create(\n    pdfDocument,\n    ref,\n    annotationGlobals,\n    idFactory,\n    collectFields,\n    pageIndex,\n    pageRef\n  );\n\n  const pdfPage = new PDFPageProxy();\n  pdfPage.annotations = [annotation];\n\n  const consoleWarnSpy = jest.spyOn(console, \"warn\").mockImplementation();\n\n  pdfPage.print();\n\n  expect(consoleWarnSpy).not.toHaveBeenCalledWith(\n    \"Warning: Unknown field name, falling back to empty field name.\"\n  );\n\n  consoleWarnSpy.mockRestore();\n});",
    "i5_llama-3.3-70b-versatile": "it(\"should not throw warning when printing a pdf with an added annotation\", async () => {\n  const { PDFDocument, PDFPage } = await import(\"../../src/core/document.js\");\n  const { AnnotationFactory } = await import(\"../../src/core/annotation.js\");\n  const { createIdFactory } = await import(\"./test_utils.js\");\n\n  const pdfDoc = await PDFDocument.load(await fetch(\"path_to_pdf_file\").then(response => response.arrayBuffer()));\n  const page = pdfDoc.getPage(0);\n  const annotationFactory = new AnnotationFactory({\n    doc: pdfDoc,\n    idFactory: createIdFactory(),\n  });\n  const annotation = annotationFactory.createAnnotation({\n    subtype: \"Widget\",\n    rect: [0, 0, 10, 10],\n    pageIndex: 0,\n  });\n  const printResolution = 300;\n  const printViewport = page.getViewport({ scale: printResolution / 72 });\n  const renderTask = page.render({\n    viewport: printViewport,\n    intent: \"print\",\n  });\n  const consoleWarnSpy = jest.spyOn(console, \"warn\");\n  await renderTask.promise;\n  expect(consoleWarnSpy).not.toHaveBeenCalledWith(\"Unknown field name, falling back to empty field name.\");\n});"
  },
  "17031": {
    "i1_deepseek-r1-distill-llama-70b": "it(\"should not block UI when changing font size in text editor\", async () => {\n  const { AnnotationEditor } = await import(\"../../src/display/editor/editor.js\");\n\n  const mockParent = {\n    moveEditorInDOM: jest.fn(),\n    pageIndex: 0,\n    viewport: {\n      rotation: 0,\n      rawDims: {\n        pageWidth: 100,\n        pageHeight: 100,\n        pageX: 0,\n        pageY: 0\n      }\n    }\n  };\n\n  const editor = new AnnotationEditor({\n    parent: mockParent,\n    id: \"test-editor\",\n    uiManager: new CommandManager(),\n    name: \"freeText\",\n    isCentered: false,\n    structTreeParentId: null,\n    x: 10,\n    y: 20\n  });\n\n  // Simulate font size change which triggers moveInDOM\n  editor.fontSize = 24;\n\n  // Use await to ensure the timeout in moveInDOM is processed\n  await new Promise(resolve => setTimeout(resolve, 10));\n\n  expect(mockParent.moveEditorInDOM).toHaveBeenCalled();\n});",
    "i1_gpt-4o": "it(\"should delay DOM movement when changing font size with slider\", async () => {\n  const { AnnotationEditor } = await import(\"../../src/display/editor/editor.js\");\n  const mockParent = {\n    moveEditorInDOM: jasmine.createSpy(\"moveEditorInDOM\"),\n    pageIndex: 0,\n    viewport: {\n      rotation: 0,\n      rawDims: { pageWidth: 100, pageHeight: 100, pageX: 0, pageY: 0 },\n    },\n  };\n  const editor = new AnnotationEditor({\n    parent: mockParent,\n    id: \"test-editor\",\n    name: \"Test Editor\",\n    uiManager: { viewParameters: { rotation: 0 } },\n    x: 0,\n    y: 0,\n    isCentered: false,\n  });\n\n  editor.moveInDOM();\n  expect(mockParent.moveEditorInDOM).not.toHaveBeenCalled();\n\n  await new Promise((resolve) => setTimeout(resolve, 10));\n  expect(mockParent.moveEditorInDOM).toHaveBeenCalledWith(editor);\n});",
    "i1_llama-3.3-70b-versatile": "it(\"should not block the UI when changing font size with the slider\", async () => {\n  const { AnnotationEditor } = await import(\"../../src/display/editor/editor.js\");\n  const { AnnotationEditorUIManager } = await import(\"../../src/display/editor/tools.js\");\n  const editor = new AnnotationEditor({\n    parent: { moveEditorInDOM: jest.fn() },\n    uiManager: new AnnotationEditorUIManager(),\n    id: \"test-editor\",\n    name: \"test-editor\",\n    x: 10,\n    y: 10,\n    isCentered: true,\n  });\n  const moveInDOMSpy = jest.spyOn(editor.parent, \"moveEditorInDOM\");\n  editor.moveInDOM();\n  editor.moveInDOM();\n  expect(moveInDOMSpy).toHaveBeenCalledTimes(1);\n});",
    "i2_deepseek-r1-distill-llama-70b": "it(\"should not block UI when changing font size in editor\", async () => {\n  const { AnnotationEditor } = await import(\"../../src/display/editor/editor.js\");\n  const editor = new AnnotationEditor({\n    parent: { moveEditorInDOM: jest.fn() },\n    uiManager: {},\n    id: \"test-editor\",\n    name: \"test-name\",\n    pageIndex: 0,\n    isCentered: false,\n  });\n\n  // Simulate font size change\n  editor.fontSize = 24;\n\n  // Verify that moveInDOM is called after a timeout without blocking\n  expect(editor.moveInDOM).toHaveBeenCalled();\n});",
    "i2_gpt-4o": "it(\"should not block the UI when changing font size with the slider\", async () => {\n  const { AnnotationEditor } = await import(\"../../src/display/editor/editor.js\");\n  const { AnnotationEditorUIManager } = await import(\"../../src/display/editor/tools.js\");\n\n  const mockParent = {\n    pageIndex: 0,\n    viewport: {\n      rotation: 0,\n      rawDims: { pageWidth: 100, pageHeight: 100, pageX: 0, pageY: 0 },\n    },\n    moveEditorInDOM: jest.fn(),\n  };\n\n  const mockUIManager = new AnnotationEditorUIManager();\n  const editor = new AnnotationEditor({\n    parent: mockParent,\n    id: \"test-editor\",\n    name: \"Test Editor\",\n    uiManager: mockUIManager,\n    x: 10,\n    y: 10,\n    isCentered: false,\n  });\n\n  editor.moveInDOM();\n  expect(mockParent.moveEditorInDOM).not.toHaveBeenCalled();\n\n  await new Promise((resolve) => setTimeout(resolve, 10));\n  expect(mockParent.moveEditorInDOM).toHaveBeenCalledWith(editor);\n});",
    "i2_llama-3.3-70b-versatile": "it(\"should not block the UI when changing font size\", async () => {\n  const { AnnotationEditor } = await import(\"./editor.js\");\n  const { AnnotationEditorUIManager } = await import(\"../../src/display/editor/tools.js\");\n  const { PDFPageView } = await import(\"../../web/pdf_page_view.js\");\n\n  const uiManager = new AnnotationEditorUIManager();\n  const pageView = new PDFPageView();\n  const editor = new (class extends AnnotationEditor {\n    constructor() {\n      super({ parent: pageView, id: 1, uiManager });\n    }\n  })();\n\n  const moveInDOMSpy = jest.spyOn(editor, \"moveInDOM\");\n  const setTimeoutSpy = jest.spyOn(global, \"setTimeout\");\n\n  editor.moveInDOM();\n  expect(setTimeoutSpy).toHaveBeenCalledTimes(1);\n  expect(moveInDOMSpy).not.toHaveBeenCalled();\n\n  jest.runOnlyPendingTimers();\n  expect(moveInDOMSpy).toHaveBeenCalledTimes(1);\n});",
    "i3_deepseek-r1-distill-llama-70b": "it(\"should handle frequent moveInDOM calls without blocking\", async () => {\n  const { AnnotationEditor } = await import(\"../../src/display/editor/editor.js\");\n  const editor = new AnnotationEditor({\n    parent: { moveEditorInDOM: jest.fn() },\n    uiManager: {},\n    id: \"test-editor\",\n    x: 0,\n    y: 0\n  });\n\n  const moveInDOMSpy = jest.spyOn(editor, \"moveInDOM\");\n\n  // Simulate multiple moves to test the debouncing\n  for (let i = 0; i < 10; i++) {\n    editor.moveInDOM();\n  }\n\n  // Since the moves are debounced with setTimeout, they should not block\n  await new Promise(resolve => setTimeout(resolve, 100));\n\n  expect(moveInDOMSpy).toHaveBeenCalled();\n});",
    "i3_gpt-4o": "it(\"should delay DOM movement when changing font size with slider\", async () => {\n  const { AnnotationEditor } = await import(\"../../src/display/editor/editor.js\");\n  const mockParent = {\n    moveEditorInDOM: jasmine.createSpy(\"moveEditorInDOM\"),\n  };\n  const editor = new AnnotationEditor({\n    parent: mockParent,\n    id: \"test-editor\",\n    x: 0,\n    y: 0,\n    uiManager: {},\n  });\n\n  editor.moveInDOM();\n  expect(mockParent.moveEditorInDOM).not.toHaveBeenCalled();\n\n  await new Promise(resolve => setTimeout(resolve, 10));\n  expect(mockParent.moveEditorInDOM).toHaveBeenCalledWith(editor);\n});",
    "i3_llama-3.3-70b-versatile": "it(\"should not block the UI when changing font size with the slider\", async () => {\n  const { AnnotationEditor } = await import(\"../../src/display/editor/editor.js\");\n  const { AnnotationEditorUIManager } = await import(\"../../src/display/editor/tools.js\");\n  const uiManager = new AnnotationEditorUIManager();\n  const editor = new AnnotationEditor({ uiManager, parent: null, id: 1, x: 0, y: 0 });\n  editor.moveInDOM = () => {};\n  const startTime = performance.now();\n  editor.moveInDOM();\n  const endTime = performance.now();\n  expect(endTime - startTime).toBeLessThan(10);\n});",
    "i4_deepseek-r1-distill-llama-70b": "it(\"should update editor position without blocking UI when changing font size\", async () => {\n  const { AnnotationEditor } = await import(\"../../src/display/editor/editor.js\");\n  const { TestReporter } = await import(\"./testreporter.js\");\n\n  // Mock DOM elements and environment\n  const mockDiv = {\n    style: {},\n    getBoundingClientRect: () => ({ left: 0, top: 0, right: 100, bottom: 100 }),\n    focus: () => {},\n  };\n\n  // Create editor instance\n  const editor = new AnnotationEditor({\n    parent: { moveEditorInDOM: jest.fn() },\n    uiManager: {},\n    id: \"test-editor\",\n    x: 10,\n    y: 20,\n  });\n\n  // Mock moveInDOM method\n  const mockMoveInDOM = jest.fn();\n  editor.moveInDOM = mockMoveInDOM;\n\n  // Simulate font size change triggering moveInDOM\n  const initialPosition = { left: \"10%\", top: \"20%\" };\n  const expectedPosition = { left: \"20%\", top: \"30%\" };\n\n  // Test asynchronous update\n  await new Promise(resolve => {\n    mockMoveInDOM.mockImplementationOnce(() => {\n      setTimeout(() => {\n        mockDiv.style.left = expectedPosition.left;\n        mockDiv.style.top = expectedPosition.top;\n        resolve();\n      }, 0);\n    });\n\n    editor.moveInDOM();\n  });\n\n  expect(mockDiv.style.left).toBe(expectedPosition.left);\n  expect(mockDiv.style.top).toBe(expectedPosition.top);\n});",
    "i4_gpt-4o": "it(\"should delay DOM movement when changing font size with slider\", async () => {\n  const { AnnotationEditor } = await import(\"../../src/display/editor/editor.js\");\n  const { AnnotationEditorUIManager } = await import(\"../../src/display/editor/tools.js\");\n\n  const mockParent = {\n    moveEditorInDOM: jest.fn(),\n    pageIndex: 0,\n    viewport: {\n      rotation: 0,\n      rawDims: { pageWidth: 100, pageHeight: 100, pageX: 0, pageY: 0 },\n    },\n  };\n\n  const mockUIManager = new AnnotationEditorUIManager();\n  const editor = new AnnotationEditor({\n    parent: mockParent,\n    id: \"test-editor\",\n    x: 0,\n    y: 0,\n    uiManager: mockUIManager,\n  });\n\n  editor.moveInDOM();\n  expect(mockParent.moveEditorInDOM).not.toHaveBeenCalled();\n\n  await new Promise(resolve => setTimeout(resolve, 10));\n  expect(mockParent.moveEditorInDOM).toHaveBeenCalledWith(editor);\n});",
    "i4_llama-3.3-70b-versatile": "it(\"should allow changing font size with the slider in a text editor\", async () => {\n  const { AnnotationEditor } = await import(\"./editor.js\");\n  const { AnnotationEditorLayer } = await import(\"./annotation_editor_layer.js\");\n  const { AnnotationEditorUIManager } = await import(\"./tools.js\");\n\n  const uiManager = new AnnotationEditorUIManager();\n  const parent = new AnnotationEditorLayer(uiManager);\n  const editor = new (class extends AnnotationEditor {\n    static _type = \"FreeText\";\n    isEmpty() {\n      return false;\n    }\n  })({ parent, uiManager, id: \"test\", x: 10, y: 10 });\n\n  editor.render();\n  editor.enableEditMode();\n  editor.makeResizable();\n\n  const moveInDOMSpy = jest.spyOn(editor, \"moveInDOM\");\n\n  editor.translate(1, 1);\n  expect(moveInDOMSpy).toHaveBeenCalledTimes(1);\n});",
    "i5_deepseek-r1-distill-llama-70b": "it(\"should allow smooth font size changes via slider\", async () => {\n  const { AnnotationEditor } = await import(\"../../src/display/editor/editor.js\");\n  const { XFAFactory } = await import(\"../../src/core/xfa/factory.js\");\n\n  class MockParent {\n    moveEditorInDOM = jest.fn();\n  }\n\n  const editor = new AnnotationEditor(new XFAFactory(), new MockParent());\n\n  // Simulate font size change using slider\n  editor.fontSize = 20;\n\n  // The patch introduces a timeout of 0ms, so we need to wait for it\n  await new Promise(resolve => setTimeout(resolve, 0));\n\n  expect(MockParent.prototype.moveEditorInDOM).toHaveBeenCalled();\n});",
    "i5_gpt-4o": "it(\"should change font size smoothly with slider\", async () => {\n  const { AnnotationEditor } = await import(\"../../src/display/editor/editor.js\");\n  const { AnnotationEditorUIManager } = await import(\"../../src/display/editor/tools.js\");\n\n  const editor = new AnnotationEditor();\n  const uiManager = new AnnotationEditorUIManager();\n  editor._uiManager = uiManager;\n\n  let fontSizeChanged = false;\n  editor.parent = {\n    moveEditorInDOM: () => {\n      fontSizeChanged = true;\n    }\n  };\n\n  editor.moveInDOM();\n  setTimeout(() => {\n    expect(fontSizeChanged).toBe(true);\n  }, 10);\n});",
    "i5_llama-3.3-70b-versatile": "it(\"should change font size smoothly with the slider in a text editor\", async () => {\n  const { PDFDocument, PDFPageProxy } = await import(\"../../src/display/api.js\");\n  const { AnnotationEditor } = await import(\"../../src/display/editor/editor.js\");\n  const { PDFViewer } = await import(\"../../web/pdf_viewer.js\");\n\n  const pdfDoc = await PDFDocument.load(await (await import(\"../../src/display/fetch_stream.js\")).PDFFetchStream.fetch(\"path_to_pdf_file\"));\n  const pdfPage = pdfDoc.getPage(1);\n  const pdfPageProxy = new PDFPageProxy(pdfDoc, pdfPage);\n  const annotationEditor = new AnnotationEditor(pdfPageProxy);\n  const pdfViewer = new PDFViewer({});\n\n  const fontSizeBefore = annotationEditor.fontSize;\n  annotationEditor.moveInDOM();\n  const fontSizeAfter = annotationEditor.fontSize;\n\n  annotationEditor.destroy();\n\n  const newAnnotationEditor = new AnnotationEditor(pdfPageProxy);\n  newAnnotationEditor.moveInDOM();\n  const newFontSizeAfter = newAnnotationEditor.fontSize;\n\n  expect(fontSizeBefore).not.toEqual(newFontSizeAfter);\n});"
  },
  "17066": {
    "i1_deepseek-r1-distill-llama-70b": "it(\"should render readonly form field when AnnotationMode is ENABLED\", async () => {\n  const { getDocument } = await import(\"../../src/display/api.js\");\n  const { PDFWorker } = await import(\"../../src/display/worker.js\");\n  const { TEST_PDFS_PATH } = await import(\"./test_utils.js\");\n\n  const pdfPath = `${TEST_PDFS_PATH}simple-form-readonly.pdf`;\n  const pdfDoc = await getDocument({\n    url: pdfPath,\n    worker: new PDFWorker(),\n    annotationMode: AnnotationMode.ENABLED,\n  });\n\n  const page = await pdfDoc.getPage(1);\n  const viewport = page.getViewport({ scale: 1 });\n  const renderTask = page.render({\n    viewport,\n    annotationMode: AnnotationMode.ENABLED,\n  });\n\n  let textElementRendered = false;\n\n  function checkTextElement() {\n    const textWidget = document.querySelector('.textWidgetAnnotation');\n    if (textWidget && textWidget.textContent === \"Foo\") {\n      textElementRendered = true;\n    }\n  }\n\n  // Give the rendering a chance to complete\n  await new Promise(resolve => {\n    const interval = setInterval(() => {\n      checkTextElement();\n      if (textElementRendered) {\n        clearInterval(interval);\n        resolve();\n      }\n    }, 100);\n  });\n\n  assert.ok(textElementRendered, \"Read-only form field is rendered correctly\");\n});",
    "i1_gpt-4o": "it(\"should render readonly form field when AnnotationMode is ENABLED\", async () => {\n  const { getDocument } = await import(\"../../src/display/api.js\");\n  const { AnnotationMode } = await import(\"../../src/shared/util.js\");\n\n  const loadingTask = getDocument({\n    url: `${TEST_PDFS_PATH}simple-form-readonly.pdf`,\n    annotationMode: AnnotationMode.ENABLED,\n  });\n  const pdfDocument = await loadingTask.promise;\n  const page = await pdfDocument.getPage(1);\n  const annotations = await page.getAnnotations();\n\n  const readOnlyField = annotations.find(\n    annotation => annotation.fieldName === \"readonlyField\"\n  );\n\n  expect(readOnlyField).toBeDefined();\n  expect(readOnlyField.fieldValue).toBe(\"Foo\");\n});",
    "i1_llama-3.3-70b-versatile": "it(\"should render readonly form fields when AnnotationMode is ENABLED\", async () => {\n  const { PDFDocumentProxy, PDFPageProxy, PDFWorkerUtil, RenderTask } = await import(\"../../src/display/api.js\");\n  const { buildGetDocumentParams, TEST_PDFS_PATH } = await import(\"./test_utils.js\");\n  const { PageViewport } = await import(\"../../src/display/display_utils.js\");\n\n  const pdfUrl = `${TEST_PDFS_PATH}/simple-form-readonly.pdf`;\n  const params = buildGetDocumentParams(pdfUrl, null, null, { annotationMode: 1 });\n  const pdfDocument = await getDocument(params);\n  const pdfPage = await pdfDocument.getPage(1);\n  const viewport = new PageViewport({ width: 100, height: 100 });\n  const renderTask = new RenderTask({\n    canvasContext: null,\n    viewport,\n    renderInteractiveForms: false,\n  });\n  const annotationStorage = new (await import(\"../../src/display/annotation_storage.js\")).AnnotationStorage();\n\n  const textWidgetAnnotations = pdfPage.getAnnotations().filter(annotation => annotation.subtype === \"Widget\");\n  const textWidgetAnnotation = textWidgetAnnotations.find(annotation => annotation.fieldName === \"ReadOnlyField\");\n\n  const isRenderableBeforePatch = textWidgetAnnotation.hasAppearance && !textWidgetAnnotation.fieldValue;\n  const isRenderableAfterPatch = await import(\"../../src/display/annotation_layer.js\").then(module => {\n    const TextWidgetAnnotationElement = module.TextWidgetAnnotationElement;\n    const parameters = {\n      data: textWidgetAnnotation,\n      renderForms: false,\n      annotationStorage,\n    };\n    const textWidgetAnnotationElement = new TextWidgetAnnotationElement(parameters);\n    return textWidgetAnnotationElement.isRenderable;\n  });\n\n  expect(isRenderableBeforePatch).toBe(false);\n  expect(isRenderableAfterPatch).toBe(true);\n});",
    "i2_deepseek-r1-distill-llama-70b": "it(\"should render readonly text widget annotations when forms are disabled\", async () => {\n  const { PDFDocument, getDocument, createIdFactory } = await import(\"../../src/core/core_utils.js\");\n  const idFactory = createIdFactory();\n  const pdfData = await fetch(\"../../web/test_simple-form-readonly.pdf\").then(res => res.arrayBuffer());\n  const pdf = await PDFDocument.load({\n    data: pdfData,\n    // Set AnnotationMode to 1 (ENABLED) to trigger the issue\n    annotationMode: 1,\n    idFactory,\n  });\n  const page = await pdf.getPage(1);\n  const textLayer = await page.getTextContent();\n  const textItems = await textLayer.items;\n\n  // The expected text from the read-only form field\n  const expectedText = \"Foo\";\n\n  // The actual text rendered in the text layer\n  const actualText = textItems.map(item => item.str).join(\"\");\n\n  expect(actualText).toContain(expectedText);\n});",
    "i2_gpt-4o": "it(\"should render readonly TextWidgetannotations when forms are disabled\", async () => {\n  const { AnnotationLayer } = await import(\"../../src/display/annotation_layer.js\");\n  const { AnnotationMode } = await import(\"../../src/shared/util.js\");\n  const parameters = {\n    renderForms: false,\n    data: {\n      hasAppearance: true,\n      fieldValue: \"Foo\",\n      hasOwnCanvas: true,\n    },\n  };\n  const annotationElement = new AnnotationLayer.TextWidgetAnnotationElement(parameters);\n  const container = annotationElement.render();\n  const element = container.querySelector(\".textWidgetAnnotation div\");\n  const expected = true;\n  const actual = element.hidden;\n  expect(actual).toBe(expected);\n});",
    "i2_llama-3.3-70b-versatile": "it(\"should render readonly TextWidgetannotations when forms are disabled\", async () => {\n  const { PDFDocument, PDFPage } = await import(\"../../src/core/document.js\");\n  const { AnnotationLayer } = await import(\"../../src/display/annotation_layer.js\");\n  const { PDFFetchStream } = await import(\"../../src/display/fetch_stream.js\");\n  const { PDFNetworkStream } = await import(\"../../src/display/network.js\");\n  const { createIdFactory } = await import(\"./test_utils.js\");\n\n  const pdfUrl = \"https://github.com/mozilla/pdf.js/files/12793820/simple-form-readonly.pdf\";\n  const pdf = await PDFDocument.load({ url: pdfUrl, fetch: PDFFetchStream.fetch, range: PDFNetworkStream.range });\n  const page = await pdf.getPage(1);\n  const annotationStorage = new (await import(\"../../src/display/annotation_storage.js\")).AnnotationStorage(createIdFactory());\n  const annotationLayer = new AnnotationLayer({\n    page,\n    annotationStorage,\n    renderForms: false,\n    enableScripting: false,\n    linkService: null,\n    imageResourcesPath: \"\",\n    cMapUrl: \"\",\n    fontUtils: null,\n    renderInteractiveForms: false,\n  });\n\n  const textWidgetAnnotations = page.annotations.filter(annotation => annotation.subtype === \"Widget\");\n  const readonlyTextWidgetAnnotation = textWidgetAnnotations.find(annotation => annotation.fieldFlags & 0x0001);\n\n  const container = await annotationLayer.render();\n  const textWidgetElements = container.querySelectorAll(\".textWidgetAnnotation\");\n\n  expect(textWidgetElements.length).toBe(1);\n  expect(textWidgetElements[0].textContent).toBe(\"Foo\");\n});",
    "i3_deepseek-r1-distill-llama-70b": "it(\"should render readonly form fields when AnnotationMode is ENABLED\", async () => {\n  const { PDFDocumentProxy } = await import(\"../../src/display/api.js\");\n  const pdfPath = `${TEST_PDFS_PATH}simple-form-readonly.pdf`;\n  const params = buildGetDocumentParams(pdfPath, {\n    cMapUrl: CMAP_URL,\n    rangeChunkSize: 1,\n  });\n\n  const pdf = await getDocument(params);\n  const page = await pdf.getPage(1);\n  const viewport = page.getViewPort({ scale: 1 });\n  const div = document.createElement(\"div\");\n  const annotationMode = AnnotationMode.ENABLED;\n\n  const renderForms = true;\n\n  await page.render({\n    ...viewport,\n    annotationMode,\n    div,\n    renderForms,\n  });\n\n  const textWidget = div.querySelector(\".textWidgetAnnotation\");\n  const textContent = textWidget.querySelector(\"div\");\n  expect(textWidget).toBeTruthy();\n  expect(textContent?.textContent).toBe(\"Foo\");\n});",
    "i3_gpt-4o": "it(\"should render readonly form field when AnnotationMode is ENABLED\", async () => {\n  const { getDocument } = await import(\"../../src/display/api.js\");\n  const loadingTask = getDocument(buildGetDocumentParams(\"simple-form-readonly.pdf\"));\n  const pdfDocument = await loadingTask.promise;\n  const page = await pdfDocument.getPage(1);\n  const viewport = page.getViewport({ scale: 1 });\n  const annotationLayer = await page.getAnnotations({ intent: \"display\" });\n\n  const renderTask = page.render({\n    canvasContext: new DefaultCanvasFactory().create(viewport.width, viewport.height).context,\n    viewport,\n    annotationMode: AnnotationMode.ENABLED,\n  });\n  await renderTask.promise;\n\n  const textWidget = annotationLayer.find(\n    annotation => annotation.annotationType === AnnotationType.WIDGET && annotation.fieldType === \"Tx\"\n  );\n\n  expect(textWidget).toBeDefined();\n  expect(textWidget.fieldValue).toBe(\"Foo\");\n});",
    "i3_llama-3.3-70b-versatile": "it(\"should render readonly form fields when AnnotationMode is ENABLED\", async () => {\n  const { PDFDocumentProxy } = await import(\"../../src/display/api.js\");\n  const { PDFDataRangeTransport } = await import(\"../../src/display/api.js\");\n  const pdfUrl = `${TEST_PDFS_PATH}simple-form-readonly.pdf`;\n  const params = buildGetDocumentParams(pdfUrl, null, null, DefaultFileReaderFactory);\n  const pdfDocument = await PDFDocumentProxy.load(params);\n  const pdfPage = await pdfDocument.getPage(1);\n  const viewport = new PageViewport({ width: 100 });\n  const annotationLayer = new (await import(\"../../src/display/annotation_layer.js\")).AnnotationLayer({\n    div: document.createElement(\"div\"),\n    page: pdfPage,\n    viewport: viewport,\n    linkService: null,\n    downloadManager: null,\n    imageResourcesPath: \"\",\n    renderForms: false,\n    annotationStorage: null,\n    enableScripting: false,\n    hasJSActions: false,\n    fieldObjects: null,\n  });\n  const annotations = await pdfPage.getAnnotations();\n  await annotationLayer.render({ annotations, viewport, page: pdfPage, linkService: null, downloadManager: null, renderForms: false });\n  const textWidgetAnnotations = annotationLayer.div.querySelectorAll(\".textWidgetAnnotation\");\n  expect(textWidgetAnnotations.length).toBe(1);\n  const textWidgetAnnotation = textWidgetAnnotations[0];\n  expect(textWidgetAnnotation.hidden).toBe(false);\n});",
    "i4_deepseek-r1-distill-llama-70b": "it(\"should render readonly text fields when AnnotationMode is ENABLED\", async () => {\n  const { PDFDocument, PDFPageProxy } = await import(\"../../src/core/document.js\");\n  const { AnnotationLayer } = await import(\"../../src/display/annotation_layer.js\");\n  const { getDocument } = await import(\"../../src/display/api.js\");\n  const { assert } = await import(\"../../src/shared/util.js\");\n\n  // Initialize the PDF document and page\n  const pdf = await getDocument({\n    url: \"../../src/core/test_files/simple-form-readonly.pdf\",\n  });\n  const page = await pdf.getPage(1);\n\n  // Set up the annotation layer with AnnotationMode = ENABLED (1)\n  const viewport = page.getViewPort({ scale: 1 });\n  const div = document.createElement(\"div\");\n  const annotationLayer = new AnnotationLayer({\n    div,\n    page,\n    viewport,\n    renderForms: true,\n    annotationStorage: new (await import(\"../../src/shared/util.js\")).AnnotationStorage,\n  });\n\n  // Render the annotations\n  await annotationLayer.render({\n    annotations: await page.getAnnotations({}),\n    viewport,\n    renderForms: true,\n  });\n\n  // Check if the read-only text field is rendered\n  const textWidget = div.querySelector(\".textWidgetAnnotation\");\n  assert.ok(textWidget, \"Read-only text field is rendered\");\n\n  // Cleanup\n  pdf.destroy();\n});",
    "i4_gpt-4o": "it(\"should render readonly form field when AnnotationMode is ENABLED\", async () => {\n  const { AnnotationLayer } = await import(\"../../src/display/annotation_layer.js\");\n  const { getDocument } = await import(\"../../src/display/api.js\");\n  const { AnnotationMode } = await import(\"../../src/shared/util.js\");\n\n  const pdfUrl = \"path/to/simple-form-readonly.pdf\";\n  const loadingTask = getDocument({ url: pdfUrl });\n  const pdfDocument = await loadingTask.promise;\n  const page = await pdfDocument.getPage(1);\n\n  const annotationLayer = new AnnotationLayer({\n    div: document.createElement(\"div\"),\n    page,\n    viewport: page.getViewport({ scale: 1 }),\n  });\n\n  const annotations = await page.getAnnotations({ intent: \"display\" });\n  await annotationLayer.render({\n    annotations,\n    viewport: page.getViewport({ scale: 1 }),\n    linkService: {},\n    downloadManager: {},\n    renderForms: false,\n    annotationMode: AnnotationMode.ENABLED,\n  });\n\n  const textWidget = annotationLayer.div.querySelector(\".textWidgetAnnotation\");\n  const isRenderable = textWidget && !textWidget.hidden;\n\n  expect(isRenderable).toBe(true);\n});",
    "i4_llama-3.3-70b-versatile": "it(\"should render readonly form fields when AnnotationMode is ENABLED\", async () => {\n  const { PDFPageProxy } = await import(\"./api.js\");\n  const { PageViewport } = await import(\"./display_utils.js\");\n  const { AnnotationLayer } = await import(\"./annotation_layer.js\");\n  const { AnnotationStorage } = await import(\"./annotation_storage.js\");\n  const { NullL10n } = await import(\"../../web/l10n_utils.js\");\n\n  const viewport = new PageViewport({ width: 100, height: 100, rotation: 0 });\n  const annotationLayer = new AnnotationLayer({\n    div: document.createElement(\"div\"),\n    accessibilityManager: null,\n    annotationCanvasMap: null,\n    l10n: new NullL10n(),\n    page: new PDFPageProxy({}),\n    viewport,\n  });\n\n  const annotations = [\n    {\n      annotationType: \"Widget\",\n      fieldType: \"Tx\",\n      rect: [0, 0, 100, 100],\n      id: \"test\",\n      fieldValue: \"Test\",\n      readOnly: true,\n    },\n  ];\n\n  const params = {\n    viewport,\n    div: annotationLayer.div,\n    annotations,\n    page: new PDFPageProxy({}),\n    linkService: {},\n    downloadManager: {},\n    annotationStorage: new AnnotationStorage(),\n    renderForms: false,\n    enableScripting: false,\n    hasJSActions: false,\n  };\n\n  await annotationLayer.render(params);\n\n  const renderedElement = annotationLayer.div.querySelector(`[data-annotation-id=\"test\"]`);\n  expect(renderedElement).not.toBeNull();\n});",
    "i5_deepseek-r1-distill-llama-70b": "it(\"should render readonly text form field when AnnotationMode is ENABLED\", async () => {\n  const { PDFDocument } = await import(\"../../src/core/document.js\");\n  const { PDFPage } = await import(\"../../src/core/document.js\");\n  const { AnnotationLayer } = await import(\"../../src/display/annotation_layer.js\");\n\n  // Load test PDF with read-only form field\n  const pdf = await PDFDocument.load await import(\"./simple-form-readonly.pdf\");\n  const page = await pdf.getPage(1);\n  const annotations = await page.getAnnotations();\n  const annotationLayer = new AnnotationLayer({\n    page,\n    annotations,\n    parameters: {\n      renderForms: false,\n      annotationMode: 1,\n      enableScripting: false\n    }\n  });\n\n  // Create the DOM elements\n  const div = document.createElement(\"div\");\n  annotationLayer.render(div);\n\n  // Get the text widget element\n  const textElement = annotationLayer._elements[0];\n\n  // The text field should be rendered and have the correct value\n  expect(textElement).toBeTruthy();\n  expect(textElement.textContent).toBe(\"Foo\");\n});",
    "i5_gpt-4o": "it(\"should render readonly form field when AnnotationMode is ENABLED\", async () => {\n  const { getDocument } = await import(\"../../src/display/api.js\");\n  const { AnnotationMode } = await import(\"../../src/shared/util.js\");\n  const { PDFNodeStream } = await import(\"../../src/display/node_stream.js\");\n  const fs = await import(\"fs\");\n  const path = await import(\"path\");\n\n  const pdfPath = path.resolve(__dirname, \"simple-form-readonly.pdf\");\n  const data = new Uint8Array(fs.readFileSync(pdfPath));\n  const loadingTask = getDocument({\n    data,\n    annotationMode: AnnotationMode.ENABLED,\n  });\n\n  const pdfDocument = await loadingTask.promise;\n  const page = await pdfDocument.getPage(1);\n  const annotations = await page.getAnnotations();\n\n  const readOnlyField = annotations.find(\n    (annotation) => annotation.fieldName === \"readonlyField\"\n  );\n\n  expect(readOnlyField).toBeDefined();\n  expect(readOnlyField.fieldValue).toBe(\"Foo\");\n});",
    "i5_llama-3.3-70b-versatile": "it(\"should render readonly form fields when AnnotationMode is ENABLED\", async () => {\n  const { PDFDocument, PDFPage } = await import(\"../../src/core/document.js\");\n  const { AnnotationMode } = await import(\"../../src/shared/util.js\");\n  const { PDFFetchStream } = await import(\"../../src/display/fetch_stream.js\");\n  const pdf = await PDFDocument.load(await new PDFFetchStream(\"simple-form-readonly.pdf\").getBuffer());\n  const page = await pdf.getPage(1);\n  const renderTask = await page.render({\n    annotationMode: AnnotationMode.ENABLED,\n  });\n  const textWidgetAnnotations = renderTask.annotationLayer.getAnnotations().filter(annotation => annotation instanceof TextWidgetAnnotationElement);\n  const isRenderable = textWidgetAnnotations.length > 0 && textWidgetAnnotations[0].isRenderable;\n  expect(isRenderable).toBe(true);\n});"
  },
  "17067": {
    "i1_deepseek-r1-distill-llama-70b": "it(\"should correctly render patterns after transform\", async () => {\n  const { PDFDocumentProxy } = await import(\"../../src/display/api.js\");\n  const { GlobalImageCache } = await import(\"../../src/core/image_utils.js\");\n  const { RenderingCancelledException } = await import(\"../../src/display/display_utils.js\");\n\n  const file = await fetch(`${TEST_PDFS_PATH}test.pdf`);\n  const pdf = await new PDFDocumentLoadingTask(file).load();\n  const page = await pdf.getPage(1);\n  const viewport = page.getViewport({ scale: 1 });\n\n  const canvas = document.createElement(\"canvas\");\n  const context = canvas.getContext(\"2d\");\n\n  const renderOptions = {\n    canvasContext: context,\n    viewport,\n    useWebGL: false,\n    enableWebGL: false,\n    dpi: 300,\n    renderInteractiveForms: false,\n  };\n\n  try {\n    await page.render(renderOptions);\n  } catch (error) {\n    if (error instanceof RenderingCancelledException) {\n      throw error;\n    }\n    // Swallow other errors if any\n  }\n\n  // Check if the pattern bounding box is correctly calculated\n  const expectedBoundingBox = {\n    width: 100,\n    height: 100,\n  };\n\n  const actualBoundingBox = {\n    width: viewport.width,\n    height: viewport.height,\n  };\n\n  assert.ok(actualBoundingBox.width > 0 && actualBoundingBox.height > 0,\n            \"Pattern bounding box should have valid dimensions\");\n});",
    "i1_gpt-4o": "it(\"should render skewed and rotated rectangles with correct color gradient\", async () => {\n  const { getDocument } = await import(\"../../src/display/api.js\");\n  const { DefaultCanvasFactory } = await import(\"../../src/display/display_utils.js\");\n\n  const loadingTask = getDocument(buildGetDocumentParams(\"test.pdf\"));\n  const pdfDocument = await loadingTask.promise;\n  const page = await pdfDocument.getPage(1);\n\n  const canvasFactory = new DefaultCanvasFactory();\n  const viewport = page.getViewport({ scale: 1.0 });\n  const canvasAndContext = canvasFactory.create(viewport.width, viewport.height);\n  const renderContext = {\n    canvasContext: canvasAndContext.context,\n    viewport,\n  };\n\n  await page.render(renderContext).promise;\n\n  const imageData = canvasAndContext.context.getImageData(0, 0, viewport.width, viewport.height).data;\n  const hasGradient = (data) => {\n    let hasRed = false, hasBlue = false, hasGreen = false, hasPurple = false;\n    for (let i = 0; i < data.length; i += 4) {\n      const [r, g, b] = [data[i], data[i + 1], data[i + 2]];\n      if (r > 200 && g < 50 && b < 50) hasRed = true;\n      if (r < 50 && g < 50 && b > 200) hasBlue = true;\n      if (r < 50 && g > 200 && b < 50) hasGreen = true;\n      if (r > 100 && g < 50 && b > 100) hasPurple = true;\n    }\n    return hasRed && hasBlue && hasGreen && hasPurple;\n  };\n\n  expect(hasGradient(imageData)).toBe(true);\n\n  canvasFactory.destroy(canvasAndContext);\n  await pdfDocument.destroy();\n});",
    "i1_llama-3.3-70b-versatile": "it(\"should render patterns correctly after applying a transform\", async () => {\n  const { PDFDocumentProxy } = await import(\"../../src/display/api.js\");\n  const { PDFPageProxy } = await import(\"../../src/display/api.js\");\n  const { Util } = await import(\"../../src/shared/util.js\");\n  const { getShadingPattern } = await import(\"./pattern_helper.js\");\n  const { PDFDataRangeTransport } = await import(\"../../src/display/api.js\");\n  const pdfUrl = 'https://github.com/mozilla/pdf.js/files/12795741/test.pdf';\n  const pdfDocument = await PDFDocumentProxy.load({ url: pdfUrl, cMapUrl: 'https://cdn.jsdelivr.net/npm/pdfjs-dist@2.16.105/build/generic/web/cmaps/', cMapPacked: true });\n  const pdfPage = await pdfDocument.getPage(1);\n  const viewport = pdfPage.getViewport({ scale: 1 });\n  const canvas = document.createElement('canvas');\n  canvas.width = viewport.width;\n  canvas.height = viewport.height;\n  const ctx = canvas.getContext('2d');\n  await pdfPage.render({ canvasContext: ctx, viewport: viewport });\n  const expectedImageData = ctx.getImageData(0, 0, canvas.width, canvas.height);\n  const patchApplied = () => {\n    const { CanvasExtraState } = require('../../src/display/canvas.js');\n    const state = new CanvasExtraState(canvas.width, canvas.height);\n    state.updateRectMinMax([1, 0, 0, 1, 0, 0], [0, 0, 100, 100]);\n  };\n  patchApplied();\n  const actualImageData = ctx.getImageData(0, 0, canvas.width, canvas.height);\n  let imagesAreEqual = true;\n  for (let i = 0; i < expectedImageData.data.length; i++) {\n    if (expectedImageData.data[i] !== actualImageData.data[i]) {\n      imagesAreEqual = false;\n      break;\n    }\n  }\n  expect(imagesAreEqual).toBe(true);\n});",
    "i2_deepseek-r1-distill-llama-70b": "it(\"should correctly compute the bounding box of a transformed rectangle\", async () => {\n  const { Util } = await import(\"../../src/shared/util.js\");\n  const canvasExtraState = {\n    minX: Infinity,\n    minY: Infinity,\n    maxX: -Infinity,\n    maxY: -Infinity,\n    updateRectMinMax: CanvasExtraState.prototype.updateRectMinMax\n  };\n\n  const transform = [1, 0.5, 0, 1, 0, 0]; // Skew and rotation example\n  const rect = [0, 0, 100, 100]; // Original rectangle\n\n  canvasExtraState.updateRectMinMax(transform, rect);\n\n  const p1 = Util.applyTransform(rect, transform);\n  const p2 = Util.applyTransform(rect.slice(2), transform);\n  const expectedMinX = Math.min(p1[0], p2[0], p1[0], p2[0]);\n  const expectedMinY = Math.min(p1[1], p2[1], p1[1], p2[1]);\n  const expectedMaxX = Math.max(p1[0], p2[0], p1[0], p2[0]);\n  const expectedMaxY = Math.max(p1[1], p2[1], p1[1], p2[1]);\n\n  expect(canvasExtraState.minX).toBe(expectedMinX);\n  expect(canvasExtraState.minY).toBe(expectedMinY);\n  expect(canvasExtraState.maxX).toBe(expectedMaxX);\n  expect(canvasExtraState.maxY).toBe(expectedMaxY);\n});",
    "i2_gpt-4o": "it(\"should render transformed rectangles with correct color gradients\", async () => {\n  const { getDocument } = await import(\"../../src/display/api.js\");\n  const { DOMCanvasFactory } = await import(\"../../src/display/display_utils.js\");\n\n  const loadingTask = getDocument(\"test.pdf\");\n  const pdfDocument = await loadingTask.promise;\n  const page = await pdfDocument.getPage(1);\n\n  const canvasFactory = new DOMCanvasFactory();\n  const viewport = page.getViewport({ scale: 1.0 });\n  const canvasAndContext = canvasFactory.create(viewport.width, viewport.height);\n  const renderContext = {\n    canvasContext: canvasAndContext.context,\n    viewport: viewport,\n    canvasFactory: canvasFactory,\n  };\n\n  await page.render(renderContext).promise;\n\n  const imageData = canvasAndContext.context.getImageData(0, 0, viewport.width, viewport.height).data;\n  const hasGradient = (data) => {\n    let hasRed = false, hasBlue = false, hasGreen = false, hasPurple = false;\n    for (let i = 0; i < data.length; i += 4) {\n      const [r, g, b] = [data[i], data[i + 1], data[i + 2]];\n      if (r > 200 && g < 50 && b < 50) hasRed = true;\n      if (r < 50 && g < 50 && b > 200) hasBlue = true;\n      if (r < 50 && g > 200 && b < 50) hasGreen = true;\n      if (r > 100 && g < 50 && b > 100) hasPurple = true;\n    }\n    return hasRed && hasBlue && hasGreen && hasPurple;\n  };\n\n  const result = hasGradient(imageData);\n  expect(result).toBe(true);\n});",
    "i2_llama-3.3-70b-versatile": "it(\"should correctly compute the bounding box of a transformed rectangle\", async () => {\n  const { Util } = await import(\"../../src/shared/util.js\");\n  const { CanvasExtraState } = await import(\"./canvas.js\");\n\n  const transform = [2, 0, 0, 2, 10, 20];\n  const rect = [0, 0, 100, 100];\n  const canvasExtraState = new CanvasExtraState(100, 100);\n  canvasExtraState.minX = Infinity;\n  canvasExtraState.minY = Infinity;\n  canvasExtraState.maxX = -Infinity;\n  canvasExtraState.maxY = -Infinity;\n\n  const expectedMinX = Math.min(\n    Util.applyTransform([rect[0], rect[1]], transform)[0],\n    Util.applyTransform([rect[2], rect[1]], transform)[0],\n    Util.applyTransform([rect[0], rect[3]], transform)[0],\n    Util.applyTransform([rect[2], rect[3]], transform)[0]\n  );\n  const expectedMinY = Math.min(\n    Util.applyTransform([rect[0], rect[1]], transform)[1],\n    Util.applyTransform([rect[2], rect[1]], transform)[1],\n    Util.applyTransform([rect[0], rect[3]], transform)[1],\n    Util.applyTransform([rect[2], rect[3]], transform)[1]\n  );\n  const expectedMaxX = Math.max(\n    Util.applyTransform([rect[0], rect[1]], transform)[0],\n    Util.applyTransform([rect[2], rect[1]], transform)[0],\n    Util.applyTransform([rect[0], rect[3]], transform)[0],\n    Util.applyTransform([rect[2], rect[3]], transform)[0]\n  );\n  const expectedMaxY = Math.max(\n    Util.applyTransform([rect[0], rect[1]], transform)[1],\n    Util.applyTransform([rect[2], rect[1]], transform)[1],\n    Util.applyTransform([rect[0], rect[3]], transform)[1],\n    Util.applyTransform([rect[2], rect[3]], transform)[1]\n  );\n\n  canvasExtraState.updateRectMinMax(transform, rect);\n\n  expect(canvasExtraState.minX).toBe(expectedMinX);\n  expect(canvasExtraState.minY).toBe(expectedMinY);\n  expect(canvasExtraState.maxX).toBe(expectedMaxX);\n  expect(canvasExtraState.maxY).toBe(expectedMaxY);\n});",
    "i3_deepseek-r1-distill-llama-70b": "it(\"should render patterns correctly after transform\", async () => {\n  const { getDocument } = await import(\"../../src/display/api.js\");\n  const { assert } = await import(\"./test_utils.js\");\n\n  // Load test PDF with pattern issue\n  const pdf = await getDocument({\n    url: `${TEST_PDFS_PATH}/test.pdf`,\n    rangeSize: 64,\n    cMapUrl: CMAP_URL,\n    extension: true,\n  });\n\n  try {\n    const page = await pdf.getPage(1);\n    const viewport = page.getViewport({ scale: 1 });\n\n    // Create canvas to render the page\n    const canvas = document.createElement(\"canvas\");\n    const renderTask = page.render({\n      canvasContext: canvas.getContext(\"2d\"),\n      viewport,\n    });\n\n    await renderTask.promise;\n\n    // Verify the pattern is rendered correctly\n    const ctx = canvas.getContext(\"2d\");\n    const expectedColor = [255, 0, 0, 255]; // Expected red color at specific position\n    const actualData = ctx.getImageData(100, 100, 1, 1).data;\n\n    assert.deepEqual(actualData, expectedColor, \"Pattern rendered correctly\");\n  } finally {\n    await pdf.close();\n  }\n});",
    "i3_gpt-4o": "it(\"should render skewed and rotated rectangles with correct color gradients\", async () => {\n  const { getDocument } = await import(\"../../src/display/api.js\");\n  const { DefaultCanvasFactory } = await import(\"../../src/display/api.js\");\n  const loadingTask = getDocument(buildGetDocumentParams(\"test.pdf\"));\n  const pdfDocument = await loadingTask.promise;\n  const page = await pdfDocument.getPage(1);\n  const viewport = page.getViewport({ scale: 1.0 });\n  const canvasFactory = new DefaultCanvasFactory();\n  const { canvas, context } = canvasFactory.create(viewport.width, viewport.height);\n  await page.render({ canvasContext: context, viewport }).promise;\n  const imageData = context.getImageData(0, 0, canvas.width, canvas.height);\n  const hasGradient = (data) => {\n    let hasRed = false, hasGreen = false, hasBlue = false, hasPurple = false;\n    for (let i = 0; i < data.length; i += 4) {\n      const [r, g, b] = [data[i], data[i + 1], data[i + 2]];\n      if (r > 200 && g < 50 && b < 50) hasRed = true;\n      if (r < 50 && g > 200 && b < 50) hasGreen = true;\n      if (r < 50 && g < 50 && b > 200) hasBlue = true;\n      if (r > 100 && g < 50 && b > 100) hasPurple = true;\n    }\n    return hasRed && hasGreen && hasBlue && hasPurple;\n  };\n  expect(hasGradient(imageData.data)).toBe(true);\n  canvasFactory.destroy(canvas);\n});",
    "i3_llama-3.3-70b-versatile": "it(\"should render the pattern correctly when applying a transform\", async () => {\n  const pdfUrl = `${TEST_PDFS_PATH}test.pdf`;\n  const { PDFDocumentProxy } = await import(\"../../src/display/api.js\");\n  const { PageViewport } = await import(\"../../src/display/display_utils.js\");\n  const pdfDocument = await getDocument({ url: pdfUrl });\n  const pdfPage = await pdfDocument.getPage(1);\n  const viewport = new PageViewport({ pdfPage, scale: 1 });\n  const renderTask = pdfPage.render({\n    viewport,\n    canvasContext: null,\n    renderInteractive: false,\n  });\n  await renderTask.promise;\n  const canvas = renderTask.canvas;\n  const ctx = canvas.getContext(\"2d\");\n  const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);\n  const expectedImageData = await new Promise((resolve) => {\n    const img = new Image();\n    img.crossOrigin = \"anonymous\";\n    img.onload = () => {\n      const expectedCanvas = document.createElement(\"canvas\");\n      expectedCanvas.width = img.width;\n      expectedCanvas.height = img.height;\n      const expectedCtx = expectedCanvas.getContext(\"2d\");\n      expectedCtx.drawImage(img, 0, 0);\n      const expectedImageData = expectedCtx.getImageData(0, 0, img.width, img.height);\n      resolve(expectedImageData);\n    };\n    img.src = `${TEST_PDFS_PATH}expected.png`;\n  });\n  for (let i = 0; i < imageData.data.length; i += 4) {\n    if (imageData.data[i] !== expectedImageData.data[i] ||\n        imageData.data[i + 1] !== expectedImageData.data[i + 1] ||\n        imageData.data[i + 2] !== expectedImageData.data[i + 2]) {\n      throw new Error(\"Rendered image does not match expected image\");\n    }\n  }\n});",
    "i4_deepseek-r1-distill-llama-70b": "const { createCanvas } = require('canvas');\nconst { PNG } = require('pngjs').PNG;\nconst { JSDOM } = require('jsdom');\nconst pdfjsLib = require('../../src/display/canvas.js');\n\nit(\"should fix pattern rendering with transform\", async () => {\n  const pdfPath = require.resolve(\"../../test.pdf\");\n  const expectedHash = \"4e5b0eab2c1a4c0fbef7d9c0f4d0e1f2\";\n\n  let container = new JSDOM().window.document.createElement(\"div\");\n  const canvas = createCanvas(400, 400);\n  const ctx = canvas.getContext('2d');\n\n  const pdfDoc = await pdfjsLib.PDFDocumentLoadingTask.load(pdfPath);\n  const pdfPage = await pdfDoc.getPage(1);\n  const viewport = pdfPage.getViewBox({ scale: 1 });\n\n  await pdfPage.render({\n    canvasContext: ctx,\n    viewport: viewport,\n    enableWebGL: false,\n    useCanvasBGRA: true\n  });\n\n  const actualCanvas = createCanvas(400, 400);\n  const actualCtx = actualCanvas.getContext('2d');\n  actualCtx.drawImage(canvas, 0, 0);\n\n  const img = new PNG({\n    width: actualCanvas.width,\n    height: actualCanvas.height\n  });\n\n  const stream = img.pack().pipe(require('crypto').createHash('sha256'));\n  const hash = await new Promise((resolve, reject) => {\n    stream.on('finish', () => resolve(stream.read().toString('hex')));\n    stream.on('error', reject);\n    actualCanvas.createPNGStream().pipe(stream);\n  });\n\n  expect(hash).toBe(expectedHash);\n});",
    "i4_gpt-4o": "it(\"should render skewed and rotated rectangles with correct color gradients\", async () => {\n  const { getDocument } = await import(\"../../src/display/api.js\");\n  const { PDFNodeStream } = await import(\"../../src/display/node_stream.js\");\n  const { DOMCanvasFactory } = await import(\"../../src/display/display_utils.js\");\n\n  const loadingTask = getDocument({\n    url: \"test.pdf\",\n    disableFontFace: true,\n    nativeImageDecoderSupport: \"none\",\n  });\n\n  const pdfDocument = await loadingTask.promise;\n  const page = await pdfDocument.getPage(1);\n\n  const canvasFactory = new DOMCanvasFactory();\n  const viewport = page.getViewport({ scale: 1.0 });\n  const canvasAndContext = canvasFactory.create(viewport.width, viewport.height);\n  const renderContext = {\n    canvasContext: canvasAndContext.context,\n    viewport: viewport,\n    canvasFactory: canvasFactory,\n  };\n\n  await page.render(renderContext).promise;\n\n  const imageData = canvasAndContext.context.getImageData(0, 0, viewport.width, viewport.height);\n  const data = imageData.data;\n\n  const hasGradient = (data) => {\n    let hasRed = false, hasBlue = false, hasGreen = false, hasPurple = false;\n    for (let i = 0; i < data.length; i += 4) {\n      const [r, g, b] = [data[i], data[i + 1], data[i + 2]];\n      if (r > 200 && g < 50 && b < 50) hasRed = true;\n      if (r < 50 && g < 50 && b > 200) hasBlue = true;\n      if (r < 50 && g > 200 && b < 50) hasGreen = true;\n      if (r > 100 && g < 50 && b > 100) hasPurple = true;\n    }\n    return hasRed && hasBlue && hasGreen && hasPurple;\n  };\n\n  const expected = true;\n  const actual = hasGradient(data);\n  expect(actual).toBe(expected);\n});",
    "i4_llama-3.3-70b-versatile": "it(\"should render the pattern correctly after applying a transform\", async () => {\n  const { PDFDocument } = await import(\"../../src/core/document.js\");\n  const { PDFPage } = await import(\"../../src/core/document.js\");\n  const { CanvasGraphics } = await import(\"./canvas.js\");\n  const { Util } = await import(\"../../shared/util.js\");\n\n  const pdfBytes = await (await import(\"./test_utils.js\")).loadPdfBytes(\"test.pdf\");\n  const pdfDoc = await PDFDocument.load(pdfBytes);\n  const pdfPage = await pdfDoc.getPage(1);\n  const canvas = document.createElement(\"canvas\");\n  const ctx = canvas.getContext(\"2d\");\n  const canvasGraphics = new CanvasGraphics(ctx, {}, {}, {}, {}, {});\n\n  await pdfPage.render({\n    canvasContext: ctx,\n    viewport: pdfPage.getViewport({ scale: 1 }),\n  });\n\n  const expectedImageData = ctx.getImageData(0, 0, canvas.width, canvas.height);\n  const actualImageData = ctx.getImageData(0, 0, canvas.width, canvas.height);\n\n  for (let i = 0; i < expectedImageData.data.length; i++) {\n    if (expectedImageData.data[i] !== actualImageData.data[i]) {\n      throw new Error(\"Pattern rendering is incorrect\");\n    }\n  }\n});",
    "i5_deepseek-r1-distill-llama-70b": "it(\"should correctly render patterns after transform\", async () => {\n  const { PDFDocumentProxy } = await import(\"../../src/display/api.js\");\n  const { PDFPageProxy } = await import(\"../../src/display/api.js\");\n\n  // Load the test PDF\n  const pdf = await PDFDocumentProxy.load({\n    data: await fetch('test.pdf').then(res => res.arrayBuffer()),\n    password: \"\"\n  });\n\n  // Get the first page\n  const page = await pdf.getPage(1);\n\n  // Create a canvas to render the page\n  const canvas = document.createElement('canvas');\n  const viewport = page.getViewport({ scale: 1 });\n  canvas.width = viewport.width;\n  canvas.height = viewport.height;\n\n  // Render the page\n  const renderTask = page.render({\n    canvasContext: canvas.getContext('2d'),\n    viewport: viewport\n  });\n  await renderTask.promise;\n\n  // Get the pixel data\n  const ctx = canvas.getContext('2d');\n  const pixelData = ctx.getImageData(0, 0, canvas.width, canvas.height).data;\n\n  // Expected pixel values (these should be obtained from a working version)\n  const expectedPixels = new Uint8ClampedArray([/* expected pixel values */]);\n\n  // Compare actual and expected pixel data\n  expect(pixelData).toEqual(expectedPixels);\n});",
    "i5_gpt-4o": "it(\"should render skewed and rotated rectangles with correct color gradient\", async () => {\n  const { getDocument } = await import(\"../../src/display/api.js\");\n  const { DOMCanvasFactory } = await import(\"../../src/display/display_utils.js\");\n\n  const loadingTask = getDocument(\"test.pdf\");\n  const pdfDocument = await loadingTask.promise;\n  const page = await pdfDocument.getPage(1);\n\n  const canvasFactory = new DOMCanvasFactory();\n  const viewport = page.getViewport({ scale: 1.0 });\n  const canvasAndContext = canvasFactory.create(viewport.width, viewport.height);\n  const renderContext = {\n    canvasContext: canvasAndContext.context,\n    viewport: viewport,\n    canvasFactory: canvasFactory,\n  };\n\n  await page.render(renderContext).promise;\n\n  const imageData = canvasAndContext.context.getImageData(0, 0, viewport.width, viewport.height).data;\n  const hasGradient = (data) => {\n    let hasRed = false, hasBlue = false, hasGreen = false, hasPurple = false;\n    for (let i = 0; i < data.length; i += 4) {\n      const [r, g, b] = [data[i], data[i + 1], data[i + 2]];\n      if (r > 200 && g < 50 && b < 50) hasRed = true;\n      if (r < 50 && g < 50 && b > 200) hasBlue = true;\n      if (r < 50 && g > 200 && b < 50) hasGreen = true;\n      if (r > 200 && g < 50 && b > 200) hasPurple = true;\n    }\n    return hasRed && hasBlue && hasGreen && hasPurple;\n  };\n\n  const expected = true;\n  const actual = hasGradient(imageData);\n  expect(actual).toBe(expected);\n});",
    "i5_llama-3.3-70b-versatile": "it(\"should render patterns correctly after applying a transform\", async () => {\n  const { PDFDocument } = await import(\"../../src/core/document.js\");\n  const { Util } = await import(\"../../src/shared/util.js\");\n  const pdf = await PDFDocument.load(await fetch(\"https://github.com/mozilla/pdf.js/files/12795741/test.pdf\").then(res => res.arrayBuffer()));\n  const page = await pdf.getPage(1);\n  const canvas = document.createElement(\"canvas\");\n  const ctx = canvas.getContext(\"2d\");\n  await page.render({ canvasContext: ctx, viewport: page.getViewport({ scale: 1 }) });\n  const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height).data;\n  const expectedColors = [\n    [255, 0, 0], // red\n    [0, 0, 255], // blue\n    [0, 128, 0], // green\n    [128, 0, 128] // purple\n  ];\n  let actualColors = [];\n  for (let i = 0; i < imageData.length; i += 4) {\n    const r = imageData[i];\n    const g = imageData[i + 1];\n    const b = imageData[i + 2];\n    actualColors.push([r, g, b]);\n  }\n  const rect = [0, 0, 100, 100];\n  const transform = Util.applyTransform(rect, [1, 0, 0, 1, 0, 0]);\n  const p1 = Util.applyTransform([rect[0], rect[1]], transform);\n  const p2 = Util.applyTransform([rect[2], rect[3]], transform);\n  const p3 = Util.applyTransform([rect[0], rect[3]], transform);\n  const p4 = Util.applyTransform([rect[2], rect[1]], transform);\n  const minX = Math.min(p1[0], p2[0], p3[0], p4[0]);\n  const minY = Math.min(p1[1], p2[1], p3[1], p4[1]);\n  const maxX = Math.max(p1[0], p2[0], p3[0], p4[0]);\n  const maxY = Math.max(p1[1], p2[1], p3[1], p4[1]);\n  const expectedRect = [minX, minY, maxX, maxY];\n  const actualRect = [0, 0, canvas.width, canvas.height];\n  expect(actualRect).toEqual(expectedRect);\n});"
  },
  "17070": {
    "i1_deepseek-r1-distill-llama-70b": "it(\"should render text annotations with HTML when noHTML is false\", async () => {\n  const { AnnotationFactory, MarkupAnnotation } = await import(\"../../src/core/annotation.js\");\n  const { AnnotationType } = await import(\"../../src/shared/util.js\");\n  const xref = new XRefMock();\n\n  // Create a sample text annotation\n  const dict = new Dict();\n  dict.set(\"Type\", Name.get(\"Annot\"));\n  dict.set(\"Subtype\", Name.get(\"Text\"));\n  dict.set(\"Contents\", new Dict());\n\n  const annotation = AnnotationFactory.create(dict, {}, xref, {}, {}) as MarkupAnnotation;\n\n  // Verify that the text annotation has HTML rendering enabled\n  expect(annotation.data.noHTML).toBe(false);\n});",
    "i1_gpt-4o": "it(\"should render comment and sticky note annotations\", async () => {\n  const { AnnotationFactory } = await import(\"../../src/core/annotation.js\");\n  const { Dict, Name } = await import(\"../../src/core/primitives.js\");\n  const { AnnotationType } = await import(\"../../src/shared/util.js\");\n\n  const dict = new Dict();\n  dict.set(\"Type\", Name.get(\"Annot\"));\n  dict.set(\"Subtype\", Name.get(\"Text\"));\n  dict.set(\"Name\", Name.get(\"Note\"));\n  dict.set(\"Contents\", \"This is a sticky note\");\n\n  const annotation = AnnotationFactory.create({\n    dict,\n    xref: null,\n    id: \"1\",\n    pageIndex: 0,\n  });\n\n  const expected = {\n    annotationType: AnnotationType.TEXT,\n    name: \"Note\",\n    contentsObj: \"This is a sticky note\",\n    noHTML: false,\n  };\n\n  expect(annotation.data.annotationType).toEqual(expected.annotationType);\n  expect(annotation.data.name).toEqual(expected.name);\n  expect(annotation.data.contentsObj).toEqual(expected.contentsObj);\n  expect(annotation.data.noHTML).toEqual(expected.noHTML);\n});",
    "i1_llama-3.3-70b-versatile": "it(\"should render comment and sticky note annotations in the viewer\", async () => {\n  const { AnnotationFactory } = await import(\"../../src/core/annotation.js\");\n  const { PDFDocument } = await import(\"../../src/core/document.js\");\n  const { PDFFetchStream } = await import(\"../../src/display/fetch_stream.js\");\n  const { createIdFactory } = await import(\"./test_utils.js\");\n  const pdfUrl = \"https://github.com/mozilla/pdf.js/files/12802422/Testdoc.pdf\";\n  const pdf = await PDFDocument.load({ url: pdfUrl, cMapUrl: CMAP_URL, cMapPacked: true, standardFontDataUrl: STANDARD_FONT_DATA_URL });\n  const annotationFactory = new AnnotationFactory();\n  const annotations = await pdf.getAnnotations();\n  const renderedAnnotations = annotations.map(annotation => annotationFactory.createAnnotation(annotation));\n  const commentAnnotation = renderedAnnotations.find(annotation => annotation.data.annotationType === AnnotationType.TEXT);\n  const stickyNoteAnnotation = renderedAnnotations.find(annotation => annotation.data.annotationType === AnnotationType.POPUP);\n  expect(commentAnnotation).not.toBeNull();\n  expect(stickyNoteAnnotation).not.toBeNull();\n});",
    "i2_deepseek-r1-distill-llama-70b": "it(\"should correctly set noHTML flag for annotations with hasOwnCanvas\", async () => {\n  const { Annotation, AnnotationFactory } = await import(\"../../src/core/annotation.js\");\n  const { XRef } = await import(\"../../src/core/primitives.js\");\n\n  // Setup fake PDF document with one page\n  const xref = new XRef();\n  const pdfDocument = {\n    getCatalog: () => ({\n      getPages: () => ({\n        getKids: () => [{}],\n        getLength: () => 1,\n      }),\n    }),\n  };\n\n  // Test each annotation type that should have noHTML: false\n  const annotations = [\n    { type: AnnotationFactory.Type.TEXT, hasOwnCanvas: true },\n    { type: AnnotationFactory.Type.POPUP, hasOwnCanvas: false },\n    { type: AnnotationFactory.Type.FREETEXT, hasOwnCanvas: true },\n    { type: AnnotationFactory.Type.LINE, hasOwnCanvas: true },\n    { type: AnnotationFactory.Type.SQUARE, hasOwnCanvas: true },\n    { type: AnnotationFactory.Type.POLYLINE, hasOwnCanvas: true },\n    { type: AnnotationFactory.Type.STAMP, hasOwnCanvas: true },\n    { type: AnnotationFactory.Type.FILEATTACHMENT, hasOwnCanvas: true },\n  ];\n\n  for (const { type, hasOwnCanvas } of annotations) {\n    const annotation = new AnnotationFactory({\n      type,\n      xref,\n      pdfDocument,\n      dict: {},\n      params: { hasOwnCanvas },\n    }).create();\n\n    expect(annotation.noHTML).toBe(false);\n  }\n});",
    "i2_gpt-4o": "it(\"should render comment and sticky note annotations\", async () => {\n  const { AnnotationFactory } = await import(\"../../src/core/annotation.js\");\n  const { Dict, Name } = await import(\"../../src/core/primitives.js\");\n  const { AnnotationType } = await import(\"../../src/shared/util.js\");\n\n  const dict = new Dict();\n  dict.set(\"Type\", Name.get(\"Annot\"));\n  dict.set(\"Subtype\", Name.get(\"Text\"));\n  dict.set(\"Name\", Name.get(\"Note\"));\n  dict.set(\"Rect\", [0, 0, 32, 32]);\n\n  const annotation = AnnotationFactory.create({\n    dict,\n    xref: null,\n    ref: null,\n    subtype: AnnotationType.TEXT,\n  });\n\n  const expected = false;\n  const actual = annotation.data.noHTML;\n  expect(actual).toBe(expected);\n});",
    "i2_llama-3.3-70b-versatile": "it(\"should render comment and sticky note annotations in the viewer\", async () => {\n  const { PDFDocument } = await import(\"../../src/core/document.js\");\n  const { AnnotationLayerBuilder } = await import(\"../../web/annotation_layer_builder.js\");\n  const { PDFPageView } = await import(\"../../web/pdf_page_view.js\");\n\n  const pdfData = await fetch(\"https://github.com/mozilla/pdf.js/files/12802422/Testdoc.pdf\").then(response => response.arrayBuffer());\n  const pdfDocument = await PDFDocument.load({ data: pdfData });\n  const pdfPage = await pdfDocument.getPage(1);\n  const pageView = new PDFPageView({ pdfPage });\n  const annotationLayerBuilder = new AnnotationLayerBuilder();\n  const annotationLayer = annotationLayerBuilder.createAnnotationLayer(pageView, pdfPage.getAnnotations());\n\n  const expectedAnnotations = 2;\n  const actualAnnotations = annotationLayer.annotations.length;\n\n  expect(actualAnnotations).toBe(expectedAnnotations);\n});",
    "i3_deepseek-r1-distill-llama-70b": "it(\"should correctly set noHTML to false for text annotations\", async () => {\n  const xref = new XRefMock();\n  const parser = new Parser(\n    new Lexer(new StringStream(CMAP_URL), { xref })\n  );\n  const evaluator = new PartialEvaluator({\n    xref,\n    parser,\n    onUnexpectedEnd: () => {},\n  });\n  const idFactory = createIdFactory();\n\n  const annotationFactory = new AnnotationFactory();\n  const dict = new Dict(xref);\n  dict.set(\"Subtype\", Name.get(\"Text\"));\n  dict.set(\"Contents\", \"comment1\");\n  dict.set(\"Rect\", [0, 0, 100, 100]);\n\n  const annotation = await AnnotationFactory.create(\n    xref,\n    new Ref(1),\n    {\n      pdfManager: {\n        ensureCatalog: async () => ({ acroForm: new Dict(xref) }),\n        ensureDoc: async () => ({}),\n      },\n      annotationGlobals: {},\n      idFactory,\n      collectFields: false,\n    },\n    false\n  );\n\n  expect(annotation.data.noHTML).toBe(false);\n});",
    "i3_gpt-4o": "it(\"should render comment and sticky note annotations\", async () => {\n  const { AnnotationFactory } = await import(\"../../src/core/annotation.js\");\n  const { Dict, Ref } = await import(\"../../src/core/primitives.js\");\n  const xref = new XRefMock([\n    {\n      ref: Ref.get(1, 0),\n      data: Dict.empty,\n    },\n  ]);\n  const annotationParams = {\n    xref,\n    ref: Ref.get(1, 0),\n    dict: new Dict(xref),\n    subtype: \"Text\",\n    id: \"1R\",\n    annotationGlobals: {\n      structTreeRoot: null,\n    },\n    collectFields: false,\n    needAppearances: false,\n    pageIndex: 0,\n    evaluatorOptions: {},\n    pageRef: null,\n  };\n  const annotation = AnnotationFactory._create(annotationParams);\n  const expected = {\n    annotationType: AnnotationType.TEXT,\n    noHTML: false,\n  };\n  expect(annotation.data.annotationType).toEqual(expected.annotationType);\n  expect(annotation.data.noHTML).toEqual(expected.noHTML);\n});",
    "i3_llama-3.3-70b-versatile": "it(\"should render comment and sticky note annotations\", async () => {\n  const xref = new XRefMock();\n  const idFactory = createIdFactory();\n  const annotationGlobals = await AnnotationFactory.createGlobals(xref);\n  const evaluator = new PartialEvaluator({\n    xref,\n    idFactory,\n    annotationGlobals,\n    cMapCache: new Map(),\n    cMapUrl: CMAP_URL,\n    standardFontDataFactory: new DefaultStandardFontDataFactory(STANDARD_FONT_DATA_URL),\n  });\n  const parser = new Parser(new Lexer(new StringStream(\"\")));\n  const task = new WorkerTask(evaluator, parser);\n  const annotation = await AnnotationFactory.create(\n    xref,\n    new Ref(1, 0),\n    annotationGlobals,\n    idFactory,\n    false,\n    null,\n    task\n  );\n  const annotationDict = annotation.dict;\n  annotationDict.set(\"Subtype\", Name.get(\"Text\"));\n  annotationDict.set(\"T\", \"Comment\");\n  annotationDict.set(\"Contents\", \"This is a comment\");\n  const operatorList = await annotation.getOperatorList(\n    evaluator,\n    task,\n    RenderingIntentFlag.DISPLAY\n  );\n  const expectedOperator = OPS.beginAnnotation;\n  const actualOperator = operatorList.opList.ops[0].op;\n  expect(actualOperator).toBe(expectedOperator);\n});",
    "i4_deepseek-r1-distill-llama-70b": "it(\"should render comment annotations in PDFs\", async () => {\n  const { PDFDocument } = await import(\"pdf-lib\");\n  const { createPDFViewer } = await import(\"../../web/pdf_viewer.js\");\n  const { TextLayerRenderTask } = await import(\"../../web/text_layer.js\");\n  const { TestReporter } = await import(\"./testreporter.js\");\n\n  // Create a test PDF with a text annotation\n  const pdfDoc = new PDFDocument();\n  const page = pdfDoc.addPage();\n  const annotation = new PDFAnnotation().setText(\"Test comment\");\n  page.addAnnotation(annotation);\n\n  // Load the PDF document\n  const pdfViewer = createPDFViewer({\n    container: document.createElement(\"div\"),\n    viewer: document.createElement(\"div\"),\n  });\n  const pdf = await PDFDocument.load(pdfDoc);\n  const pageView = pdfViewer.openPDF(pdf);\n\n  // Render the page\n  await pageView.render();\n  const textLayer = new TextLayerRenderTask(pageView);\n  const text = await textLayer.getText();\n\n  // Verify the annotation text is rendered\n  expect(text).toContain(\"Test comment\");\n});",
    "i4_gpt-4o": "it(\"should render comment and sticky note annotations\", async () => {\n  const { AnnotationFactory } = await import(\"../../src/core/annotation.js\");\n  const { PDFDocument } = await import(\"../../src/core/document.js\");\n  const { Ref } = await import(\"../../src/core/primitives.js\");\n  const { XRefMock } = await import(\"./test_utils.js\");\n\n  const pdfManager = {\n    ensureCatalog: async () => ({}),\n    ensureDoc: async () => ({}),\n    getPage: async () => ({\n      annotations: [new Ref(1, 0)],\n    }),\n  };\n\n  const xref = new XRefMock([\n    {\n      ref: new Ref(1, 0),\n      data: {\n        get: (key) => {\n          if (key === \"Subtype\") return { name: \"Text\" };\n          if (key === \"Rect\") return [0, 0, 10, 10];\n          if (key === \"Contents\") return \"Test comment\";\n          if (key === \"T\") return \"Author\";\n          return null;\n        },\n      },\n    },\n  ]);\n\n  const annotationGlobals = await AnnotationFactory.createGlobals(pdfManager);\n  const annotation = await AnnotationFactory.create(\n    xref,\n    new Ref(1, 0),\n    annotationGlobals,\n    { createObjId: () => 1 },\n    false,\n    null\n  );\n\n  const expected = {\n    annotationType: 1,\n    contentsObj: { str: \"Test comment\", dir: \"ltr\" },\n    titleObj: { str: \"Author\", dir: \"ltr\" },\n  };\n\n  expect(annotation.data.annotationType).toEqual(expected.annotationType);\n  expect(annotation.data.contentsObj).toEqual(expected.contentsObj);\n  expect(annotation.data.titleObj).toEqual(expected.titleObj);\n});",
    "i4_llama-3.3-70b-versatile": "it(\"should render comment and sticky note annotations in the viewer\", async () => {\n  const { PDFDocument } = await import(\"../../src/display/api.js\");\n  const { AnnotationFactory } = await import(\"../../src/core/annotation.js\");\n  const pdfBytes = await (await import(\"./test_utils.js\")).buildGetDocumentParams(\"Testdoc.pdf\");\n  const pdfDocument = await PDFDocument.load({ data: pdfBytes });\n  const annotations = await AnnotationFactory.create(pdfDocument.xref, pdfDocument.xref.getRawPdf(), await AnnotationFactory.createGlobals(pdfDocument.pdfManager), pdfDocument.pdfManager.idFactory, true);\n  const annotationLayer = await import(\"../../src/display/annotation_layer.js\");\n  const annotationLayerBuilder = new annotationLayer.AnnotationLayerBuilder();\n  const page = await pdfDocument.getPage(1);\n  const annotationStorage = new (await import(\"../../src/display/annotation_storage.js\")).AnnotationStorage();\n  const renderAnnotations = await annotationLayerBuilder.renderAnnotations({\n    page,\n    viewport: page.getViewport({ scale: 1 }),\n    annotationStorage,\n    renderForms: true,\n    enableScripting: false,\n  });\n  const annotationsRendered = renderAnnotations.annotations;\n  expect(annotationsRendered.length).toBeGreaterThan(0);\n});",
    "i5_deepseek-r1-distill-llama-70b": "it(\"should render comments and sticky notes in the viewer\", async () => {\n  const { PDFDocument } = await import(\"../../src/display/api.js\");\n  const { TestUtils } = await import(\"./test_utils.js\");\n\n  // Setup a fake server with the test PDF\n  const server = await TestUtils.startFakeServer({\n    'Testdoc.pdf': new ArrayBuffer(0)\n  });\n\n  // Open the PDF document\n  const loadingTask = PDFDocument.loadingTaskFromURL(\"Testdoc.pdf\");\n  const pdf = await loadingTask.promise;\n\n  // Get the first page\n  const page = await pdf.getPage(1);\n\n  // Create a viewer and render the page\n  const viewer = {\n    container: document.createElement('div'),\n    get pageDiv() {\n      return this.container;\n    },\n  };\n\n  await page.render({\n    viewport: page.getViewport({ scale: 1 }),\n    canvasContext: null,\n    annotationCanvasContext: null,\n    renderInteractiveForms: true,\n  });\n\n  // Check if the annotations are rendered\n  const expectedElements = [\n    'sticky-note',\n    'comment-annotation',\n    'popup',\n    'text'\n  ].some(element => viewer.container.querySelector(`.${element}`));\n\n  expect(expectedElements).toBeTruthy();\n});",
    "i5_gpt-4o": "it(\"should render comment and sticky note annotations\", async () => {\n  const { getDocument } = await import(\"../../src/display/api.js\");\n  const { AnnotationLayer } = await import(\"../../src/display/annotation_layer.js\");\n  const { PDFJS } = await import(\"../../src/shared/util.js\");\n\n  const loadingTask = getDocument({ url: \"https://github.com/mozilla/pdf.js/files/12802422/Testdoc.pdf\" });\n  const pdfDocument = await loadingTask.promise;\n  const page = await pdfDocument.getPage(1);\n\n  const annotations = await page.getAnnotations();\n  const annotationLayer = new AnnotationLayer();\n  const annotationLayerDiv = document.createElement(\"div\");\n\n  annotationLayer.render({\n    annotations,\n    div: annotationLayerDiv,\n    page,\n    viewport: page.getViewport({ scale: 1.0 }),\n    linkService: null,\n    downloadManager: null,\n  });\n\n  const stickyNote = annotationLayerDiv.querySelector(\".annotationLayer .popupAnnotation\");\n  const comment = annotationLayerDiv.querySelector(\".annotationLayer .textAnnotation\");\n\n  expect(stickyNote).not.toBeNull();\n  expect(comment).not.toBeNull();\n});",
    "i5_llama-3.3-70b-versatile": "it(\"should render comment and sticky note annotations in the viewer\", async () => {\n  const { PDFDocument } = await import(\"../../src/core/document.js\");\n  const { AnnotationLayer } = await import(\"../../src/display/annotation_layer.js\");\n  const { PDFPageView } = await import(\"../../src/web/pdf_page_view.js\");\n  const { PDFViewer } = await import(\"../../src/web/pdf_viewer.js\");\n  const { Util } = await import(\"../../src/shared/util.js\");\n\n  const pdfUrl = \"./Testdoc.pdf\";\n  const pdfDocument = await PDFDocument.load(pdfUrl);\n  const pdfPage = await pdfDocument.getPage(1);\n  const pdfPageView = new PDFPageView({ pdfPage });\n  const annotationLayer = new AnnotationLayer({\n    pdfPage,\n    viewport: pdfPageView.viewport,\n  });\n  const pdfViewer = new PDFViewer();\n  pdfViewer.setDocument(pdfDocument);\n  const annotations = await pdfPage.getAnnotations();\n  const commentAnnotation = annotations.find(\n    (annotation) => annotation.subtype === \"Comment\"\n  );\n  const stickyNoteAnnotation = annotations.find(\n    (annotation) => annotation.subtype === \"StickyNote\"\n  );\n  const expectedAnnotations = [commentAnnotation, stickyNoteAnnotation];\n  const actualAnnotations = annotationLayer.getAnnotations();\n  Util.assert(\n    expectedAnnotations.every((annotation) =>\n      actualAnnotations.includes(annotation)\n    ),\n    \"Comment and sticky note annotations are not rendered in the viewer\"\n  );\n});"
  },
  "17106": {
    "i1_deepseek-r1-distill-llama-70b": "it(\"should release ImageBitmaps after cleanup to prevent memory ballooning\", async () => {\n  const { PDFDocumentProxy } = await import(\"../../src/display/api.js\");\n  const { createIdFactory } = await import(\"./test_utils.js\");\n  const { GlobalImageCache } = await import(\"../../src/core/image_utils.js\");\n\n  // Setup a PDF document with many pages to test scrolling\n  const pdfPath = `${TEST_PDFS_PATH}/large-pdf.pdf`;\n  const params = buildGetDocumentParams(pdfPath, DefaultFileReaderFactory);\n  const pdfDoc = await getDocument(params);\n  const transport = pdfDoc._transport;\n  const pageProxy = await pdfDoc.getPage(0);\n\n  // Track the number of ImageBitmaps created\n  const bitmaps = new Set();\n  const originalCreateImageBitmap = pageProxy.createImageBitmap.bind(pageProxy);\n\n  pageProxy.createImageBitmap = async (imageData) => {\n    const bitmap = await originalCreateImageBitmap(imageData);\n    bitmaps.add(bitmap);\n    return bitmap;\n  };\n\n  // Simulate scrolling through all pages\n  for (let i = 0; i < 10; i++) {\n    const page = await pdfDoc.getPage(i);\n    await page.render({\n      viewport: page.getViewport({ scale: 1 }),\n      canvasContext: new CanvasGraphics(),\n      renderInteractive: false,\n    });\n  }\n\n  // Force cleanup and GC\n  transport._intentStates.clear();\n  await new Promise(resolve => setTimeout(resolve, 100));\n  if (globalThis.gc) {\n    globalThis.gc();\n  }\n\n  // Verify that all ImageBitmaps have been released\n  const releasedBitmaps = new Set();\n  transport.pageProxies.forEach(proxy => {\n    if (proxy._cleanupAfterRender) {\n      proxy._cleanupAfterRender();\n    }\n  });\n\n  await new Promise(resolve => setTimeout(resolve, 100));\n  if (globalThis.gc) {\n    globalThis.gc();\n  }\n\n  expect(bitmaps.size).toBe(0);\n});",
    "i1_gpt-4o": "it(\"should release ImageBitmap data after cleanup\", async () => {\n  const { getDocument } = await import(\"../../src/display/api.js\");\n  const loadingTask = getDocument(buildGetDocumentParams(\"tracemonkey.pdf\"));\n  const pdfDocument = await loadingTask.promise;\n  const page = await pdfDocument.getPage(1);\n  const viewport = page.getViewport({ scale: 1.0 });\n  const canvasFactory = new DefaultCanvasFactory();\n  const canvasAndContext = canvasFactory.create(viewport.width, viewport.height);\n  const renderTask = page.render({\n    canvasContext: canvasAndContext.context,\n    viewport,\n  });\n  await renderTask.promise;\n\n  const imageData = page.objs.get(\"img_p0_1\");\n  const bitmapClosedBefore = imageData.bitmap ? imageData.bitmap.closed : true;\n\n  page.cleanup();\n\n  const bitmapClosedAfter = imageData.bitmap ? imageData.bitmap.closed : true;\n\n  expect(bitmapClosedBefore).toBe(false);\n  expect(bitmapClosedAfter).toBe(true);\n});",
    "i1_llama-3.3-70b-versatile": "it(\"should release ImageBitmap data after cleanup\", async () => {\n  const { PDFWorker, PDFDocumentLoadingTask, PDFDocumentProxy, PDFPageProxy } = await import(\"../../src/display/api.js\");\n  const { DefaultFileReaderFactory, TEST_PDFS_PATH } = await import(\"./test_utils.js\");\n  const worker = new PDFWorker({\n    workerSrc: \"../../build/generic/build/pdf.worker.mjs\",\n  });\n  const loadingTask = new PDFDocumentLoadingTask({\n    cMapUrl: CMAP_URL,\n    cMapPacked: true,\n    worker,\n  });\n  const pdfDoc = await loadingTask.load(TEST_PDFS_PATH + \"/pdfs/tracemonkey.pdf\");\n  const pageProxy = await pdfDoc.getPage(1);\n  const page = new PDFPageProxy(pageProxy);\n  await page.render({\n    canvasContext: null,\n    viewport: new PageViewport({ width: 100, height: 100 }),\n  });\n  const intentStates = pageProxy._intentStates;\n  pageProxy._intentStates = new Map();\n  pageProxy.objs.forEach((value, key) => {\n    if (value.imageData?.bitmap) {\n      value.imageData.bitmap.close();\n    }\n  });\n  const memoryUsageBefore = process.memoryUsage().heapUsed;\n  pageProxy._intentStates = intentStates;\n  await new Promise(resolve => setTimeout(resolve, 100));\n  const memoryUsageAfter = process.memoryUsage().heapUsed;\n  expect(memoryUsageAfter).toBeLessThan(memoryUsageBefore + 1024 * 1024);\n});",
    "i2_deepseek-r1-distill-llama-70b": "it(\"should not cache large images after cleanup\", async () => {\n  const { PDFDocument } = await import(\"../../src/display/api.js\");\n  const { XRefMock } = await import(\"../../src/display/test_utils.js\");\n  const { createIdFactory } = await import(\"../../src/display/test_utils.js\");\n\n  const fakeWorker = {\n    sendWithPromise: jest.fn(),\n    on: jest.fn(),\n    off: jest.fn(),\n    postMessage: jest.fn(),\n  };\n\n  const xref = new XRefMock();\n  const idFactory = createIdFactory(0);\n  const largeImageId = idFactory.next().value;\n  const pageId = idFactory.next().value;\n\n  // Mock a large image\n  xref.mockData(largeImageId, {\n    type: \"Image\",\n    data: new Uint8Array(1024 * 1024 * 4), // 4MB array buffer\n  });\n\n  // Create a PDF document proxy\n  const pdfDocument = new PDFDocument({\n    numPages: 1,\n    pageIndices: [pageId],\n    commonObjs: new Map(),\n    worker: fakeWorker,\n    xref,\n  });\n\n  // Get the page proxy\n  const pageProxy = pdfDocument.getPage(pageId);\n\n  // Simulate loading the page with the large image\n  await pageProxy.startRender();\n\n  // Simulate scrolling away and cleanup\n  pageProxy.close();\n\n  // Check if the large image is still cached\n  expect(pageProxy.objs.has(largeImageId)).toBe(false);\n});",
    "i2_gpt-4o": "it(\"should not store image data after cleanup\", async () => {\n  const { WorkerTransport } = await import(\"../../src/display/api.js\");\n  const { PDFObjects } = await import(\"../../src/core/primitives.js\");\n\n  const mockMessageHandler = { on: jest.fn(), sendWithPromise: jest.fn() };\n  const mockLoadingTask = { onProgress: jest.fn() };\n  const mockNetworkStream = {};\n  const mockParams = { ownerDocument: null, styleElement: null };\n  const mockFactory = {\n    canvasFactory: null,\n    filterFactory: null,\n    cMapReaderFactory: null,\n    standardFontDataFactory: null,\n  };\n\n  const workerTransport = new WorkerTransport(\n    mockMessageHandler,\n    mockLoadingTask,\n    mockNetworkStream,\n    mockParams,\n    mockFactory\n  );\n\n  const pageIndex = 0;\n  const pageProxy = { objs: new PDFObjects(), _intentStates: new Map() };\n  workerTransport.#pageCache.set(pageIndex, pageProxy);\n\n  const id = \"testImageId\";\n  const type = \"Image\";\n  const imageData = { bitmap: { close: jest.fn() } };\n\n  pageProxy._intentStates.clear(); // Simulate cleanup\n\n  workerTransport.setupMessageHandler();\n  mockMessageHandler.on.mock.calls.find(call => call[0] === \"obj\")[1]([\n    id,\n    pageIndex,\n    type,\n    imageData,\n  ]);\n\n  expect(pageProxy.objs.has(id)).toBe(false);\n  expect(imageData.bitmap.close).toHaveBeenCalled();\n});",
    "i2_llama-3.3-70b-versatile": "it(\"should release ImageBitmap data after cleanup\", async () => {\n  const { WorkerTransport, PDFWorkerUtil, PDFDocumentProxy, MessageHandler } = await import(\"../../src/display/api.js\");\n  const { createIdFactory } = await import(\"./test_utils.js\");\n  const { PDFDataTransportStream } = await import(\"../../src/display/transport_stream.js\");\n  const { PDFFetchStream } = await import(\"../../src/display/fetch_stream.js\");\n\n  const messageHandler = new MessageHandler();\n  const transport = new PDFDataTransportStream(new PDFFetchStream());\n  const workerTransport = new WorkerTransport(messageHandler, null, transport, {}, {});\n  const pageProxy = { objs: new Map(), _intentStates: new Map(), _maybeCleanupAfterRender: true };\n\n  workerTransport.#pageCache.set(1, pageProxy);\n\n  const imageData = { bitmap: { close: jest.fn() } };\n\n  workerTransport.messageHandler.on(\"obj\", ([id, pageIndex, type, imageData]) => {\n    if (pageIndex === 1 && type === \"Image\") {\n      pageProxy.objs.set(id, imageData);\n    }\n  });\n\n  workerTransport.messageHandler.send(\"obj\", [1, 1, \"Image\", imageData]);\n\n  expect(imageData.bitmap.close).not.toHaveBeenCalled();\n\n  pageProxy._intentStates.clear();\n\n  workerTransport.messageHandler.send(\"obj\", [1, 1, \"Image\", imageData]);\n\n  expect(imageData.bitmap.close).toHaveBeenCalledTimes(1);\n});",
    "i3_deepseek-r1-distill-llama-70b": "it(\"should prevent memory ballooning when scrolling through PDF\", async () => {\n  const { getDocument } = await import(\"../../src/display/api.js\");\n  const { PDFDocumentProxy } = await import(\"../../src/display/api.js\");\n  const pdfBuffer = await (await import(\"fs/promises\")).readFile(`${TEST_PDFS_PATH}/large.pdf`);\n\n  async function getMemoryUsage() {\n    return process.memoryUsage().rss() / 1024 / 1024; // Convert to MB\n  }\n\n  const loadingTask = getDocument({\n    data: pdfBuffer,\n    cMapUrl: CMAP_URL,\n  });\n\n  let pdfDoc;\n  let page;\n\n  beforeEach(async () => {\n    pdfDoc = await loadingTask.promise;\n    page = await pdfDoc.getPage(1);\n  });\n\n  afterEach(async () => {\n    if (page) {\n      await page.cleanup();\n      page = null;\n    }\n    if (pdfDoc) {\n      await pdfDoc.cleanup();\n      pdfDoc = null;\n    }\n  });\n\n  const renderPage = async () => {\n    const viewport = page.getViewport({ scale: 1 });\n    const renderTask = page.render({\n      canvasContext: new (await import(\"canvas\")).Canvas(1, 1).getContext(\"2d\"),\n      viewport,\n    });\n    await renderTask.promise;\n    await page.cleanup();\n  };\n\n  const initialMemory = await getMemoryUsage();\n  const maxMemory = initialMemory * 1.2; // 20% increase tolerance\n\n  for (let i = 0; i < 10; i++) {\n    const memoryBefore = await getMemoryUsage();\n    await renderPage();\n    await new Promise(resolve => setTimeout(resolve, 100));\n    const memoryAfter = await getMemoryUsage();\n    expect(memoryAfter).toBeLessThan(maxMemory);\n  }\n});",
    "i3_gpt-4o": "it(\"should release ImageBitmap data after cleanup\", async () => {\n  const { getDocument } = await import(\"../../src/display/api.js\");\n  const loadingTask = getDocument(buildGetDocumentParams(\"tracemonkey.pdf\"));\n  const pdfDocument = await loadingTask.promise;\n  const page = await pdfDocument.getPage(1);\n\n  const renderTask = page.render({\n    canvasContext: new OffscreenCanvas(1, 1).getContext(\"2d\"),\n    viewport: page.getViewport({ scale: 1 }),\n  });\n  await renderTask.promise;\n\n  const imageData = { bitmap: new ImageBitmap() };\n  page.objs.resolve(\"testImage\", imageData);\n\n  await pdfDocument.cleanup();\n  expect(() => imageData.bitmap.close()).toThrow();\n});",
    "i3_llama-3.3-70b-versatile": "it(\"should prevent memory usage from ballooning when scrolling through a PDF\", async () => {\n  const pdfUrl = `${TEST_PDFS_PATH}/pdfissue.pdf`;\n  const loadingTask = await getDocument(pdfUrl);\n  const pdfDocument = await loadingTask.promise;\n  const pdfPage = await pdfDocument.getPage(1);\n  const viewport = pdfPage.getViewport({ scale: 1 });\n  const canvas = document.createElement('canvas');\n  const canvasContext = canvas.getContext('2d');\n  canvas.width = viewport.width;\n  canvas.height = viewport.height;\n  const renderTask = pdfPage.render({\n    canvasContext,\n    viewport,\n  });\n  await renderTask.promise;\n  const pageProxy = pdfPage;\n  const intentState = pageProxy._intentStates.values().next().value;\n  const objs = intentState.operatorList;\n  const imageData = objs.argsArray.find(arg => arg.type === 'Image');\n  pageProxy._intentStates.clear();\n  pageProxy.objs.clear();\n  const memoryUsageBefore = objectSize(imageData);\n  pageProxy._intentStates.clear();\n  pageProxy.objs.clear();\n  const memoryUsageAfter = objectSize(imageData);\n  expect(memoryUsageAfter).toBeLessThan(memoryUsageBefore);\n});",
    "i4_deepseek-r1-distill-llama-70b": "it(\"should release ImageBitmap data after cleanup\", async () => {\n  const { PDFDocument, PDFWorker } = await import(\"../../src/display/api.js\");\n  const pdfPath = `${TEST_PDFS_PATH}/large-image.pdf`;\n\n  // Create a new worker instance\n  const worker = new PDFWorker({ verbosity: 'error' });\n  const loadingTask = getDocument({ url: pdfPath, worker: worker });\n\n  // Load the document and get the page\n  const pdfDoc = await loadingTask.promise;\n  const page = await pdfDoc.getPage(1);\n\n  // Render the page to force image loading\n  const { canvasContext } = await import(\"../../src/display/display_utils.js\");\n  const canvas = new canvasContext();\n  const viewport = page.getViewport({ scale: 1 });\n\n  await page.render({\n    canvasContext: canvas.getContext('2d'),\n    viewport: viewport\n  });\n\n  // Verify memory before cleanup\n  const beforeMemory = process.memoryUsage().rss;\n\n  // Perform cleanup\n  await pdfDoc.cleanup();\n\n  // Verify memory after cleanup\n  const afterMemory = process.memoryUsage().rss;\n\n  // The memory should have decreased significantly after cleanup\n  expect(afterMemory).toBeLessThan(beforeMemory);\n});",
    "i4_gpt-4o": "it(\"should release ImageBitmap data after cleanup\", async () => {\n  const { PDFPageProxy } = await import(\"../../src/display/api.js\");\n  const { PDFObjects } = await import(\"../../src/display/api.js\");\n\n  const pageProxy = new PDFPageProxy(0, { rotate: 0, ref: null, userUnit: 1, view: [0, 0, 612, 792] }, null);\n  const objs = new PDFObjects();\n  const imageData = { bitmap: { close: jest.fn() } };\n  const id = \"testImage\";\n\n  pageProxy.objs = objs;\n  pageProxy.objs.resolve(id, imageData);\n\n  pageProxy.cleanup();\n\n  expect(imageData.bitmap.close).toHaveBeenCalled();\n});",
    "i4_llama-3.3-70b-versatile": "it(\"should release ImageBitmap data after cleanup\", async () => {\n  const { PDFDocumentLoadingTask, PDFWorker } = await import(\"../../src/display/api.js\");\n  const { createIdFactory } = await import(\"./test_utils.js\");\n  const idFactory = createIdFactory();\n\n  const worker = new PDFWorker();\n  const loadingTask = await PDFDocumentLoadingTask.fromBytes(\n    new Uint8Array([0x25, 0x50, 0x44, 0x46, 0x2d, 0x31, 0x2e, 0x34]),\n    { worker }\n  );\n\n  const pdfDocument = await loadingTask.promise;\n  const page = await pdfDocument.getPage(1);\n  const image = await new Promise(resolve => {\n    page.objs.on(\"Image\", resolve);\n  });\n\n  await pdfDocument.cleanup();\n  expect(image.bitmap?.close).toHaveBeenCalledTimes(1);\n});",
    "i5_deepseek-r1-distill-llama-70b": "it(\"should prevent memory ballooning when scrolling through PDF\", async () => {\n  const { PDFDocumentProxy } = await import(\"../../src/display/api.js\");\n  const { performance } = require(\"perf_hooks\");\n\n  // Create a new PDF document proxy\n  const pdfProxy = new PDFDocumentProxy({\n    fetch: () => {\n      // Mock fetch to return a 1x1 PDF\n      return Promise.resolve({\n        ok: true,\n        arrayBuffer: () => Promise.resolve(new ArrayBuffer(100))\n      });\n    }\n  });\n\n  // Load multiple pages to simulate scrolling\n  const pages = [];\n  for (let i = 0; i < 10; i++) {\n    const page = await pdfProxy.getPage(i);\n    pages.push(page);\n  }\n\n  // Measure memory usage\n  const usedHeap = performance.memory.usedHeapSize;\n\n  // Release references to pages\n  pages.length = 0;\n\n  // Force garbage collection (Node.js specific)\n  if (global.gc) {\n    global.gc();\n  }\n\n  // Verify memory has been freed\n  const finalHeap = performance.memory.usedHeapSize;\n  expect(finalHeap).toBeLessThan(usedHeap * 0.75);\n});",
    "i5_gpt-4o": "it(\"should release ImageBitmap data when intentStates size is zero\", async () => {\n  const { PDFPageProxy } = await import(\"../../src/display/api.js\");\n  const pageProxy = new PDFPageProxy();\n  pageProxy._intentStates = new Map();\n\n  const imageData = {\n    bitmap: {\n      close: jest.fn(),\n    },\n  };\n\n  const id = \"testId\";\n  const type = \"Image\";\n\n  pageProxy.objs = new Map();\n  pageProxy.objs.has = jest.fn().mockReturnValue(false);\n\n  pageProxy._onCommonObjImageData(id, type, imageData);\n\n  expect(imageData.bitmap.close).toHaveBeenCalled();\n});",
    "i5_llama-3.3-70b-versatile": "it(\"should release ImageBitmap data after cleanup\", async () => {\n  const { PDFDocumentProxy, PDFWorkerUtil } = await import(\"../../src/display/api.js\");\n  const { createValidAbsoluteUrl } = await import(\"../../src/shared/util.js\");\n  const { PDFPageProxy } = await import(\"../../src/display/api.js\");\n\n  const pdfUrl = createValidAbsoluteUrl(\"example.pdf\");\n  const pdfDocumentProxy = await PDFDocumentProxy.create(pdfUrl);\n  const pageProxy = await pdfDocumentProxy.getPage(1);\n  const imageData = { bitmap: { close: jest.fn() } };\n\n  PDFWorkerUtil.receiveMessage = jest.fn((message) => {\n    if (message.type === \"Image\") {\n      return imageData;\n    }\n  });\n\n  pageProxy._intentStates.size = 0;\n  PDFWorkerUtil.receiveMessage({ type: \"Image\" });\n  expect(imageData.bitmap.close).toHaveBeenCalledTimes(1);\n\n  pageProxy._intentStates.size = 1;\n  PDFWorkerUtil.receiveMessage({ type: \"Image\" });\n  expect(imageData.bitmap.close).toHaveBeenCalledTimes(1);\n});"
  },
  "17120": {
    "i1_deepseek-r1-distill-llama-70b": "it(\"should remove unused CFF debugging code\", async () => {\n  const { CFFEncodingMap } = await import(\"../../src/shared/cffStandardStrings.js\");\n  expect(CFFEncodingMap).toBeUndefined();\n});",
    "i1_llama-3.3-70b-versatile": "it(\"should not throw an error when the code scanning alerts are fixed\", async () => {\n  const { CFFEncodingMap, CFFDictDataMap, CFFDictPrivateDataMap } = await import(\"../../src/shared/cffStandardStrings.js\");\n  const { readCharset, readCharstringEncoding, readFontDictData, readFontIndexData, Type2Parser, writeToFile } = await import(\"../../src/shared/fonts_utils.js\");\n  const { Dict } = await import(\"../../src/core/primitives.js\");\n  const { Stream } = await import(\"../../src/core/stream.js\");\n\n  // Initialize required variables\n  const stream = new Stream(new Uint8Array());\n  const parser = new Type2Parser();\n\n  // Define expected variable\n  const expectedError = null;\n\n  // Generate actual variables\n  let actualError = null;\n  try {\n    parser.parse(stream);\n  } catch (error) {\n    actualError = error;\n  }\n\n  // Compare expected with actual\n  expect(actualError).toBe(expectedError);\n});",
    "i2_deepseek-r1-distill-llama-70b": "it(\"should not have unused debugging code\", async () => {\n  const fontsUtilsPath = \"../../src/shared/fonts_utils.js\";\n  const cffStandardStringsPath = \"../../src/shared/cffStandardStrings.js\";\n\n  // Try to import the removed files\n  const importFontsUtils = async () => {\n    await import(fontsUtilsPath);\n  };\n\n  const importCffStandardStrings = async () => {\n    await import(cffStandardStringsPath);\n  };\n\n  // After the patch, these imports should throw errors\n  await expect(importFontsUtils()).rejects.toThrow(Error);\n  await expect(importCffStandardStrings()).rejects.toThrow(Error);\n});",
    "i2_gpt-4o": "it(\"should not find obsolete files\", async () => {\n  const fs = await import(\"fs\");\n  const path = await import(\"path\");\n\n  const obsoleteFiles = [\n    path.resolve(__dirname, \"../../src/shared/cffStandardStrings.js\"),\n    path.resolve(__dirname, \"../../src/shared/fonts_utils.js\"),\n  ];\n\n  const filesExist = obsoleteFiles.some((file) => fs.existsSync(file));\n  const expected = false;\n\n  expect(filesExist).toBe(expected);\n});",
    "i3_deepseek-r1-distill-llama-70b": "it(\"should remove unused CFF debugging code\", async () => {\n  const { CFFEncodingMap } = await import(\"../../src/shared/cffStandardStrings.js\");\n  const { readCharset } = await import(\"../../src/shared/fonts_utils.js\");\n\n  // If we reach here, the files were not removed and the test should fail\n  expect(true).toBe(false);\n});",
    "i3_llama-3.3-70b-versatile": "it(\"should remove unused debugging code\", async () => {\n  const { Util } = await import(\"../../src/shared/util.js\");\n  const { CFFEncodingMap, CFFDictDataMap, CFFDictPrivateDataMap } = await import(\"../../src/shared/cffStandardStrings.js\");\n  const { readCharset, readCharstringEncoding, readFontDictData, readFontIndexData, Type2Parser, writeToFile } = await import(\"../../src/shared/fonts_utils.js\");\n  const fs = await import('fs');\n  const path = await import('path');\n\n  const filePath = path.join(__dirname, 'test.pdf');\n  const fileBuffer = await fs.promises.readFile(filePath);\n\n  const parser = new Type2Parser();\n  parser.parse(new Stream(fileBuffer));\n\n  expect(CFFEncodingMap).toBeDefined();\n  expect(CFFDictDataMap).toBeDefined();\n  expect(CFFDictPrivateDataMap).toBeDefined();\n  expect(readCharset).toBeDefined();\n  expect(readCharstringEncoding).toBeDefined();\n  expect(readFontDictData).toBeDefined();\n  expect(readFontIndexData).toBeDefined();\n  expect(Type2Parser).toBeDefined();\n  expect(writeToFile).toBeDefined();\n});",
    "i4_deepseek-r1-distill-llama-70b": "it(\"should remove unused CFF debugging code\", async () => {\n  const { CFFEncodingMap } = await import(\"../../src/shared/cffStandardStrings.js\");\n  const { readCharset } = await import(\"../../src/shared/fonts_utils.js\");\n\n  // Test passes when the above imports throw ModuleNotFoundError\n  expect(CFFEncodingMap).toBeUndefined();\n  expect(readCharset).toBeUndefined();\n});",
    "i4_gpt-4o": "it(\"should not find CFF related functions after patch\", async () => {\n  try {\n    const { readCharset, readCharstringEncoding, readFontDictData, readFontIndexData, Type2Parser, writeToFile } = await import(\"../../src/shared/fonts_utils.js\");\n    throw new Error(\"CFF related functions should not be present\");\n  } catch (error) {\n    expect(error.message).toBe(\"CFF related functions should not be present\");\n  }\n});",
    "i4_llama-3.3-70b-versatile": "it(\"should not throw an error when parsing a CFF file\", async () => {\n  const { Stream } = await import(\"../../src/core/stream.js\");\n  const { CFFDictDataMap, CFFDictPrivateDataMap, CFFEncodingMap } = await import(\"./cffStandardStrings.js\");\n  const { readFontIndexData, readFontDictData, readCharset, readCharstringEncoding } = await import(\"./fonts_utils.js\");\n\n  const cffFileArray = new Uint8Array([0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]);\n  const stream = new Stream(cffFileArray);\n\n  const topDict = readFontIndexData(stream, true);\n  const strings = readFontIndexData(stream);\n  CFFDictDataMap['12']['23'] = { name: 'random', operand: 'number' };\n\n  const privateDict = [12, 23];\n  const parsedPrivateDict = readFontDictData(privateDict, CFFDictPrivateDataMap);\n\n  expect(parsedPrivateDict).toEqual(['random']);\n});",
    "i5_deepseek-r1-distill-llama-70b": "it(\"should handle removal of unused CFF debugging code\", async () => {\n  const { CFFParser } = await import(\"../../src/core/cff_parser.js\");\n  const sampleCFFContent = new TextEncoder().encode(\"%!PS-Adobe-Font-1.0:0\\n\");\n\n  const parser = new CFFParser();\n  const initializePromise = parser.initialize(sampleCFFContent);\n\n  await expect(initializePromise).resolves.not.toThrow();\n});",
    "i5_llama-3.3-70b-versatile": "it(\"should remove unused debugging code\", async () => {\n  const { Util } = await import(\"../../src/shared/util.js\");\n  const { Stream } = await import(\"../../src/core/stream.js\");\n  const fontData = new Uint8Array();\n  const stream = new Stream(fontData);\n  let error = null;\n  try {\n    const CFFDictDataMap = {};\n    const CFFDictPrivateDataMap = {};\n    const CFFEncodingMap = {};\n    const CFFStrings = [];\n    const readFontDictData = (aString, aMap) => {\n      throw new Error(\"Function not implemented.\");\n    };\n    readFontDictData(stream, CFFDictDataMap);\n  } catch (e) {\n    error = e;\n  }\n  expect(error).toBeNull();\n});"
  },
  "17159": {
    "i1_deepseek-r1-distill-llama-70b": "it(\"should correctly reflect radio button state in print view\", async () => {\n  const xref = new XRefMock();\n  const annotationDict = new Dict();\n  annotationDict.set(\"FT\", new Name(\"Btn\"));\n  annotationDict.set(\"Type\", new Name(\"Annot\"));\n  annotationDict.set(\"Subtype\", new Name(\"Widget\"));\n  annotationDict.set(\"Parent\", new Ref(1));\n  annotationDict.set(\"AP\", new Dict());\n  annotationDict.set(\"V\", new Name(\"On\"));\n  annotationDict.set(\"T\", new Name(\"Test Radio Button\"));\n\n  const fieldParent = new Dict();\n  fieldParent.set(\"V\", new Name(\"On\"));\n\n  xref.mockRef(1, fieldParent);\n\n  const factory = new AnnotationFactory();\n  const annotation = await factory.createAnnotation(annotationDict, xref);\n\n  expect(annotation.data.fieldValue).toBe(\"On\");\n});",
    "i1_gpt-4o": "it(\"should reflect the correct state of radio buttons on the pdf form\", async () => {\n  const { ButtonWidgetAnnotation } = await import(\"../../src/core/annotation.js\");\n  const { Dict, Name } = await import(\"../../src/core/primitives.js\");\n\n  const params = {\n    dict: new Dict({\n      Parent: new Dict({\n        V: Name.get(\"Radio1\"),\n      }),\n      AP: new Dict({\n        N: new Dict({\n          Radio1: new StringStream(\"checked appearance\"),\n          Off: new StringStream(\"unchecked appearance\"),\n        }),\n      }),\n    }),\n  };\n\n  const radioButton = new ButtonWidgetAnnotation(params);\n  const expectedFieldValue = \"Radio1\";\n  const expectedButtonValue = \"Radio1\";\n\n  expect(radioButton.data.fieldValue).toEqual(expectedFieldValue);\n  expect(radioButton.data.buttonValue).toEqual(expectedButtonValue);\n});",
    "i1_llama-3.3-70b-versatile": "it(\"should correctly reflect radio button state in print view\", async () => {\n  const { ButtonWidgetAnnotation, Dict, Name, Ref } = await import(\"../../src/core/annotation.js\");\n  const { AnnotationFactory } = await import(\"../../src/core/annotation.js\");\n  const { createIdFactory } = await import(\"./test_utils.js\");\n  const idFactory = createIdFactory();\n  const annotationFactory = new AnnotationFactory(idFactory);\n  const params = {\n    dict: new Dict({\n      FT: new Name(\"Btn\"),\n      T: new Name(\"Radio Button\"),\n      Parent: new Ref(1),\n      AP: new Dict({\n        N: new Dict({\n          On: new StringStream(\"Checked Appearance\"),\n          Off: new StringStream(\"Unchecked Appearance\"),\n        }),\n      }),\n    }),\n  };\n  const annotation = annotationFactory.createAnnotation(params);\n  const buttonWidgetAnnotation = new ButtonWidgetAnnotation(params);\n  const fieldValue = buttonWidgetAnnotation.data.fieldValue;\n  const buttonValue = buttonWidgetAnnotation.data.buttonValue;\n  assert.strictEqual(fieldValue, null);\n  assert.strictEqual(buttonValue, null);\n});",
    "i2_deepseek-r1-distill-llama-70b": "it(\"should correctly reflect radio button state in print view\", async () => {\n  const { PDFDocument } = await import(\"../../src/display/api.js\");\n  const { Annotation } = await import(\"../../src/core/annotation.js\");\n  const { Name } = await import(\"../../src/core/primitives.js\");\n\n  // Create a sample PDF with radio buttons\n  const pdf = new PDFDocument();\n  const page = pdf.addPage();\n  const annotation = new ButtonWidgetAnnotation({\n    dict: {\n      get: (key) => {\n        if (key === \"Parent\") {\n          const parentDict = new Dict();\n          parentDict.set(\"V\", new Name(\"Radio1\"));\n          return parentDict;\n        }\n        return null;\n      }\n    },\n    page,\n    x: 0,\n    y: 0,\n    width: 10,\n    height: 10,\n  });\n\n  // Process the radio button annotation\n  await annotation._processRadioButton({\n    dict: annotation.dict,\n    page,\n  });\n\n  // Verify the button value is correctly set from the parent field's V entry\n  expect(annotation.data.buttonValue).toBe(\"Radio1\");\n\n  await pdf.close();\n});",
    "i2_gpt-4o": "it(\"should reflect the correct state of radio buttons on the pdf form\", async () => {\n  const { ButtonWidgetAnnotation } = await import(\"../../src/core/annotation.js\");\n  const { Dict, Name } = await import(\"../../src/core/primitives.js\");\n\n  const params = {\n    dict: new Dict(),\n  };\n\n  const parentDict = new Dict();\n  parentDict.set(\"V\", Name.get(\"RadioValue\"));\n  params.dict.set(\"Parent\", parentDict);\n\n  const appearanceDict = new Dict();\n  const normalAppearanceDict = new Dict();\n  normalAppearanceDict.set(\"RadioValue\", null);\n  normalAppearanceDict.set(\"Off\", null);\n  appearanceDict.set(\"N\", normalAppearanceDict);\n  params.dict.set(\"AP\", appearanceDict);\n\n  const radioButton = new ButtonWidgetAnnotation(params);\n  const expectedFieldValue = \"RadioValue\";\n  const expectedButtonValue = \"RadioValue\";\n\n  const actualFieldValue = radioButton.data.fieldValue;\n  const actualButtonValue = radioButton.data.buttonValue;\n\n  expect(actualFieldValue).toEqual(expectedFieldValue);\n  expect(actualButtonValue).toEqual(expectedButtonValue);\n});",
    "i2_llama-3.3-70b-versatile": "it(\"should reflect the real state of radio buttons in print view\", async () => {\n  const { PDFDocument } = await import(\"../../src/core/document.js\");\n  const { AnnotationFactory } = await import(\"../../src/core/annotation.js\");\n  const { createDefaultAppearance } = await import(\"../../src/core/default_appearance.js\");\n  const { Dict, Name, Ref } = await import(\"../../src/core/primitives.js\");\n\n  const pdfDoc = await PDFDocument.load(await fetch(\"path_to_pdf_with_radio_buttons.pdf\").then(res => res.arrayBuffer()));\n  const annotationFactory = new AnnotationFactory();\n  const page = pdfDoc.getPage(1);\n  const annotations = await page.getAnnotations();\n\n  const radioButtonAnnotation = annotations.find(annotation => annotation instanceof annotationFactory.constructor.ButtonWidgetAnnotation && annotation.data.radioButton);\n\n  const fieldValue = radioButtonAnnotation.data.fieldValue;\n  const buttonValue = radioButtonAnnotation.data.buttonValue;\n\n  expect(fieldValue).not.toBeNull();\n  expect(buttonValue).not.toBeNull();\n});",
    "i3_deepseek-r1-distill-llama-70b": "it(\"should correctly reflect radio button state in print view\", async () => {\n  const idFactory = createIdFactory();\n  const xref = new XRefMock(idFactory);\n  const fontData = await fetch(STANDARD_FONT_DATA_URL).then(res => res.arrayBuffer());\n\n  // Create a radio button annotation\n  const annotationRef = xref.createRef();\n  const dict = new Dict(xref);\n  dict.set(\"Type\", Name.get(\"Annot\"));\n  dict.set(\"Subtype\", Name.get(\"Widget\"));\n  dict.set(\"FT\", Name.get(\"Btn\"));\n  dict.set(\"F\", 0);\n  dict.set(\"Rect\", [0, 0, 100, 100]);\n  dict.set(\"T\", stringToPDFString(\"Test Radio Button\"));\n  dict.set(\"Parent\", new Ref(1));\n\n  // Create parent field\n  const parentRef = xref.createRef();\n  const parentDict = new Dict(xref);\n  parentDict.set(\"V\", Name.get(\"Yes\"));\n  parentDict.set(\"Opt\", [Name.get(\"Yes\"), Name.get(\"No\")]);\n\n  xref.put(parentRef, parentDict);\n  xref.put(annotationRef, dict);\n\n  const annotation = await AnnotationFactory.create(\n    xref,\n    annotationRef,\n    {\n      pdfManager: null,\n      acroForm: new Dict(),\n      xfaDatasets: null,\n      structTreeRoot: null,\n      baseUrl: null,\n      attachments: null\n    },\n    idFactory,\n    true\n  );\n\n  const buttonAnnotation = new ButtonWidgetAnnotation({\n    dict: annotation.dict,\n    xref: xref,\n    annotationGlobals: {\n      pdfManager: null,\n      acroForm: new Dict(),\n      xfaDatasets: null,\n      structTreeRoot: null,\n      baseUrl: null,\n      attachments: null\n    },\n    id: idFactory.createObjId(),\n    collectFields: true,\n    pageIndex: 0,\n    pageRef: null,\n    evaluatorOptions: {}\n  });\n\n  // The state should be correctly reflected\n  expect(buttonAnnotation.data.fieldValue).toBe(\"Yes\");\n});",
    "i3_gpt-4o": "it(\"should reflect the correct state of radio buttons on the pdf form\", async () => {\n  const { ButtonWidgetAnnotation } = await import(\"../../src/core/annotation.js\");\n  const { Dict, Name } = await import(\"../../src/core/primitives.js\");\n  const xref = new XRefMock();\n  const dict = new Dict(xref);\n  dict.set(\"Parent\", new Dict(xref));\n  dict.set(\"AP\", new Dict(xref));\n  dict.set(\"AS\", Name.get(\"On\"));\n  dict.set(\"V\", Name.get(\"On\"));\n  const params = {\n    dict,\n    xref,\n    annotationGlobals: { xfaDatasets: null, acroForm: new Dict(xref) },\n  };\n  const annotation = new ButtonWidgetAnnotation(params);\n  const expected = \"On\";\n  const actual = annotation.data.fieldValue;\n  expect(actual).toEqual(expected);\n});",
    "i3_llama-3.3-70b-versatile": "it(\"should correctly set the buttonValue in ButtonWidgetAnnotation for radio buttons\", async () => {\n  const xref = new XRefMock();\n  const annotationGlobals = await AnnotationFactory.createGlobals(xref);\n  const idFactory = createIdFactory();\n  const dict = new Dict(xref);\n  dict.set(\"FT\", Name.get(\"Btn\"));\n  dict.set(\"Ff\", AnnotationFieldFlag.RADIO);\n  dict.set(\"AP\", new Dict(xref));\n  const ap = dict.get(\"AP\");\n  ap.set(\"N\", new Dict(xref));\n  const normalAppearance = ap.get(\"N\");\n  normalAppearance.set(\"Yes\", new StringStream(\"\"));\n  normalAppearance.set(\"Off\", new StringStream(\"\"));\n  const params = {\n    xref,\n    ref: new Ref(xref, 1),\n    dict,\n    subtype: \"Widget\",\n    id: idFactory.createObjId(),\n    annotationGlobals,\n    collectFields: true,\n  };\n  const annotation = await AnnotationFactory._create(params);\n  expect(annotation.data.buttonValue).toBe(\"Yes\");\n});",
    "i4_deepseek-r1-distill-llama-70b": "it(\"should correctly reflect radio button state in print view\", async () => {\n  const { PDFDocument } = await import(\"../../src/display/pdf_document.js\");\n  const { AnnotationFactory } = await import(\"../../src/core/annotation.js\");\n\n  // Create a sample PDF with radio buttons\n  const pdf = new PDFDocument();\n  const page = pdf.addPage();\n  const radioGroup = pdf.annotation({\n    type: \"widget\",\n    subtype: \"Button\",\n    fieldFlags: AnnotationFieldFlag.RADIO,\n    rect: [100, 100, 150, 150],\n    buttonValue: \"Off\",\n    fieldValue: \"Off\"\n  });\n  const radio1 = pdf.annotation({\n    type: \"widget\",\n    subtype: \"Button\",\n    fieldFlags: AnnotationFieldFlag.RADIO,\n    rect: [100, 200, 150, 250],\n    buttonValue: \"Radio1\",\n    fieldValue: \"Radio1\"\n  });\n  const radio2 = pdf.annotation({\n    type: \"widget\",\n    subtype: \"Button\",\n    fieldFlags: AnnotationFieldFlag.RADIO,\n    rect: [100, 300, 150, 350],\n    buttonValue: \"Radio2\",\n    fieldValue: \"Radio2\"\n  });\n\n  // Load the PDF and create annotations\n  const pdfDoc = await PDFDocument.load(pdf);\n  const annotations = await pdfDoc.getAnnotations();\n  const radioAnnotation = annotations[0];\n\n  // Change the radio button state\n  radioAnnotation.data.fieldValue = \"Radio2\";\n\n  // Generate print view\n  const printAppearance = await radioAnnotation._getAppearance({\n    evaluator: { xref: pdfDoc.xref },\n    task: null,\n    intent: RenderingIntentFlag.SAVE,\n    annotationStorage: null\n  });\n\n  // Verify the print appearance reflects the correct state\n  expect(printAppearance).toContain(\"Radio2\");\n});",
    "i4_gpt-4o": "it(\"should reflect the correct state of radio buttons on the pdf form\", async () => {\n  const { ButtonWidgetAnnotation } = await import(\"../../src/core/annotation.js\");\n  const { Dict, Name } = await import(\"../../src/core/primitives.js\");\n\n  const params = {\n    dict: new Dict(null),\n    xref: null,\n    annotationGlobals: { xfaDatasets: null, acroForm: new Dict(null) },\n  };\n\n  params.dict.set(\"Parent\", new Dict(null));\n  params.dict.get(\"Parent\").set(\"V\", Name.get(\"On\"));\n  params.dict.set(\"AP\", new Dict(null));\n  params.dict.get(\"AP\").set(\"N\", new Dict(null));\n  params.dict.get(\"AP\").get(\"N\").set(\"On\", new Name(\"On\"));\n  params.dict.get(\"AP\").get(\"N\").set(\"Off\", new Name(\"Off\"));\n\n  const annotation = new ButtonWidgetAnnotation(params);\n  const expected = \"On\";\n  const actual = annotation.data.fieldValue;\n\n  expect(actual).toBe(expected);\n});",
    "i4_llama-3.3-70b-versatile": "it(\"should correctly set the buttonValue in ButtonWidgetAnnotation for radio buttons\", async () => {\n  const { ButtonWidgetAnnotation, AnnotationFactory } = await import(\"./src/core/annotation.js\");\n  const annotation = new ButtonWidgetAnnotation({\n    dict: {\n      FT: \"Btn\",\n      Ff: 0,\n      AP: {\n        N: {\n          Off: {},\n        },\n      },\n    },\n    xref: {},\n    annotationGlobals: {},\n    collectFields: true,\n    pageIndex: 0,\n    pageRef: {},\n  });\n  annotation._processRadioButton({\n    params: {\n      dict: {\n        FT: \"Btn\",\n        Ff: 0,\n        AP: {\n          N: {\n            Off: {},\n          },\n        },\n      },\n      xref: {},\n      annotationGlobals: {},\n      collectFields: true,\n      pageIndex: 0,\n      pageRef: {},\n    },\n  });\n  const expectedButtonValue = null;\n  const actualButtonValue = annotation.data.buttonValue;\n  expect(actualButtonValue).toBe(expectedButtonValue);\n});",
    "i5_deepseek-r1-distill-llama-70b": "it(\"should correctly reflect radio button state in print view\", async () => {\n  const { ButtonWidgetAnnotation, PDFDocument, Page } = await import(\"../../src/core/annotation.js\");\n  const { buildGetDocumentParams } = await import(\"./test_utils.js\");\n\n  // Create a PDF with a radio button field\n  const pdf = new PDFDocument();\n  const page = pdf.addPage();\n  const field = pdf.createRadioButton({\n    name: \"radiobutton1\",\n    value: \"A\",\n  });\n\n  // Create the annotation\n  const annotation = new ButtonWidgetAnnotation({\n    field: field,\n    page: page,\n  });\n\n  // Generate the print view content\n  const printView = await annotation.getPrintView();\n\n  // The expected state should include the selected value\n  const expectedValue = \"A\";\n  const actualValue = printView.textContent;\n\n  expect(actualValue).toContain(expectedValue);\n});",
    "i5_gpt-4o": "it(\"should reflect the correct state of radio buttons on the pdf form\", async () => {\n  const { AnnotationFactory } = await import(\"../../src/core/annotation.js\");\n  const { PDFDocument } = await import(\"../../src/core/document.js\");\n\n  const pdfDoc = await PDFDocument.load(/* PDF data with radio buttons */);\n  const page = await pdfDoc.getPage(0);\n  const annotations = await page.getAnnotations();\n\n  const radioButtonAnnotation = annotations.find(\n    (annotation) => annotation.fieldType === \"RadioButton\"\n  );\n\n  const expectedState = \"On\"; // Assuming \"On\" is the expected state for the test\n  const actualState = radioButtonAnnotation.data.fieldValue;\n\n  expect(actualState).toBe(expectedState);\n});",
    "i5_llama-3.3-70b-versatile": "it(\"should reflect radio button state in print view\", async () => {\n  const { PDFDocument } = await import(\"../../src/core/document.js\");\n  const { AnnotationLayer } = await import(\"../../src/display/annotation_layer.js\");\n  const { PDFPageProxy } = await import(\"../../src/display/api.js\");\n  const { PDFFetchStream } = await import(\"../../src/display/fetch_stream.js\");\n  const { createIdFactory } = await import(\"./test_utils.js\");\n\n  const pdf = await PDFDocument.load(await PDFFetchStream.fetch(\"path_to_pdf_with_radio_buttons\"));\n  const page = await pdf.getPage(1);\n  const annotationLayer = new AnnotationLayer({\n    page,\n    viewport: page.getViewport({ scale: 1 }),\n    renderInteractiveForms: true,\n  });\n  const annotations = await annotationLayer.getAnnotations();\n  const radioButtonAnnotation = annotations.find((annotation) => annotation.subtype === \"Widget\" && annotation.fieldType === \"Btn\");\n  const expectedState = true; // assuming the radio button is checked\n  const actualState = radioButtonAnnotation.data.buttonValue !== null;\n  expect(actualState).toBe(expectedState);\n});"
  },
  "17475": {
    "i1_deepseek-r1-distill-llama-70b": "it(\"should correctly position highlights on cropped PDFs\", async () => {\n  const { PDFDocumentProxy, PDFPageProxy } = await import(\"../../src/display/api.js\");\n  const pdfData = new Uint8Array([/* base64 encoded PDF data */]);\n  const pdf = await getDocument({\n    data: pdfData,\n    range: new PDFDataRangeTransport(),\n    password: \"\",\n  });\n  const page = await pdf.getPage(0);\n\n  // Simulate cropped PDF\n  const cropRect = [100, 100, 300, 300]; // [x, y, width, height]\n  const viewport = page.getViewport({ scale: 1 });\n  const [pageWidth, pageHeight] = [viewport.width, viewport.height];\n\n  const uiManager = new AnnotationEditorUIManager();\n  const drawLayer = new DrawLayer();\n  const highlightEditor = new HighlightEditor({\n    color: \"#fff066\",\n    opacity: 1,\n    boxes: [{ x: 0.5, y: 0.5, width: 0.2, height: 0.2 }],\n    pageIndex: 0,\n    page,\n  });\n\n  highlightEditor.rotate(0);\n  const serialized = highlightEditor.serialize();\n\n  const expectedQuadPoints = [\n    100 + (0.5 * pageWidth), 100 + (0.5 * pageHeight),\n    100 + (0.5 * pageWidth), 100 + (0.5 * pageHeight),\n    100 + (0.5 * pageWidth) + (0.2 * pageWidth), 100 + (0.5 * pageHeight),\n    100 + (0.5 * pageWidth) + (0.2 * pageWidth), 100 + (0.5 * pageHeight) + (0.2 * pageHeight),\n    100 + (0.5 * pageWidth), 100 + (0.5 * pageHeight) + (0.2 * pageHeight),\n    100 + (0.5 * pageWidth), 100 + (0.5 * pageHeight) + (0.2 * pageHeight)\n  ];\n\n  expect(serialized.quadPoints).toEqual(expectedQuadPoints);\n});",
    "i1_gpt-4o": "it(\"should correctly serialize and deserialize highlight annotations with visible highlights on cropped PDFs\", async () => {\n  const { HighlightEditor } = await import(\"../../src/display/editor/highlight.js\");\n  const { Util } = await import(\"../../src/shared/util.js\");\n\n  const pageDimensions = [600, 800];\n  const rect = [100, 100, 500, 700];\n  const color = [255, 255, 0];\n  const opacity = 0.5;\n  const quadPoints = [100, 700, 500, 700, 100, 100, 500, 100];\n\n  const data = {\n    rect,\n    color,\n    opacity,\n    quadPoints,\n  };\n\n  const parent = null;\n  const uiManager = null;\n\n  const editor = HighlightEditor.deserialize(data, parent, uiManager);\n  editor.pageDimensions = pageDimensions;\n\n  const serializedData = editor.serialize();\n  const expectedColor = Util.makeHexColor(...color);\n\n  expect(serializedData.color).toEqual(expectedColor);\n  expect(serializedData.opacity).toEqual(opacity);\n  expect(serializedData.quadPoints).toEqual(quadPoints);\n  expect(serializedData.rect).toEqual(rect);\n});",
    "i1_llama-3.3-70b-versatile": "it(\"should display highlight on cropped pdf when savingprinting\", async () => {\n  const { PDFDocument, PDFPageProxy } = await import(\"../../src/display/api.js\");\n  const { Util } = await import(\"../../shared/util.js\");\n  const { HighlightEditor } = await import(\"./highlight.js\");\n\n  const pdfDoc = await PDFDocument.load(await fetchData(\"path_to_cropped_pdf.pdf\"));\n  const page = await pdfDoc.getPage(1);\n  const viewport = page.getViewport({ scale: 1 });\n  const pdfPageProxy = new PDFPageProxy(page);\n\n  const highlightEditor = new HighlightEditor({\n    pageIndex: 0,\n    page: pdfPageProxy,\n    x: 0,\n    y: 0,\n    width: viewport.width,\n    height: viewport.height,\n    color: Util.makeHexColor(255, 240, 102),\n    opacity: 1,\n  });\n\n  const serializedData = highlightEditor.serialize();\n  const expectedQuadPoints = serializedData.quadPoints;\n\n  const actualQuadPoints = highlightEditor.#serializeBoxes([0, 0]);\n  expect(actualQuadPoints).toEqual(expectedQuadPoints);\n});",
    "i2_deepseek-r1-distill-llama-70b": "it(\"should correctly calculate highlight positions when PDF has a crop box\", async () => {\n  const { PDFDocument } = await import(\"../../src/core/pdf_document.js\");\n  const { PDFPage } = await import(\"../../src/core/pdf_page.js\");\n  const { AnnotationEditor } = await import(\"./editor.js\");\n\n  // Load a test PDF with crop box\n  const pdf = await PDFDocument.load(await fetch(\"test.pdf\").then(res => res.arrayBuffer()));\n  const page = pdf.getPage(0);\n\n  // Create highlight editor with test data\n  const highlightEditor = new AnnotationEditor({\n    pageIndex: 0,\n    color: \"#ff0000\",\n    opacity: 0.5,\n    boxes: [{x: 0.1, y: 0.1, width: 0.2, height: 0.2}],\n    pageDimensions: [page.getWidth(), page.getHeight()],\n    uiManager: null\n  });\n\n  // Serialize the highlight data\n  const serialized = highlightEditor.serialize();\n\n  // The expected quadPoints should include the crop box offset\n  const expectedQuadPoints = [100, 100, 200, 200, 150, 150, 250, 250];\n\n  // After the patch, the quadPoints should match the expected values\n  expect(serialized.quadPoints).toEqual(expectedQuadPoints);\n});",
    "i2_gpt-4o": "it(\"should correctly serialize highlight boxes with crop box adjustments\", async () => {\n  const { HighlightEditor } = await import(\"../../src/display/editor/highlight.js\");\n  const { Util } = await import(\"../../src/shared/util.js\");\n\n  const pageDimensions = [600, 800];\n  const rect = [50, 50, 550, 750];\n  const color = [255, 255, 102];\n  const quadPoints = [100, 700, 200, 700, 100, 600, 200, 600];\n  const opacity = 1;\n  const pageIndex = 0;\n\n  const data = {\n    rect,\n    color,\n    quadPoints,\n    opacity,\n    pageIndex,\n  };\n\n  const parent = null;\n  const uiManager = { highlightColors: new Map([[\"default\", \"#fff066\"]]) };\n\n  const editor = HighlightEditor.deserialize(data, parent, uiManager);\n  editor.pageDimensions = pageDimensions;\n\n  const expectedQuadPoints = [150, 700, 250, 700, 150, 600, 250, 600];\n  const actualQuadPoints = editor.serialize().quadPoints;\n\n  expect(actualQuadPoints).toEqual(expectedQuadPoints);\n});",
    "i2_llama-3.3-70b-versatile": "it(\"should include the crop box when savingprinting highlighted text\", async () => {\n  const { PDFDocument, PDFPage } = await import(\"../../src/core/document.js\");\n  const { AnnotationEditor, AnnotationEditorType } = await import(\"../../src/display/editor/editor.js\");\n  const { Util } = await import(\"../../shared/util.js\");\n\n  const pdfDoc = await PDFDocument.load(await (await import(\"../../src/display/api.js\")).build());\n  const page = pdfDoc.getPage(0);\n  const viewport = page.getViewport({ scale: 1 });\n  const annotationEditor = new (await import(\"../../src/display/editor/highlight.js\")).HighlightEditor({\n    pageIndex: 0,\n    page,\n    viewport,\n    color: [1, 0, 0],\n    opacity: 1,\n    boxes: [{ x: 0.1, y: 0.1, width: 0.1, height: 0.1 }],\n  });\n\n  const serializedData = annotationEditor.serialize();\n  const expectedQuadPoints = [10, 710, 20, 710, 20, 700, 10, 700];\n  const actualQuadPoints = serializedData.quadPoints;\n\n  expect(actualQuadPoints).toEqual(expectedQuadPoints);\n});",
    "i3_deepseek-r1-distill-llama-70b": "it(\"should correctly serialize highlight boxes with crop\", async () => {\n  const { HighlightEditor } = await import(\"../../src/display/editor/highlight.js\");\n\n  // Mock page dimensions to simulate a cropped page\n  const pageDimensions = [100, 100]; // pageWidth, pageHeight\n  const editor = new HighlightEditor({\n    boxes: [{x: 0.5, y: 0.5, width: 0.2, height: 0.2}],\n    pageDimensions: pageDimensions,\n    x: 0.1,\n    y: 0.1,\n    width: 0.8,\n    height: 0.8,\n  });\n\n  // Serialize boxes with crop\n  const quadPoints = editor.#serializeBoxes([20, 30]); // tx=20, ty=30\n\n  // Expected quadPoints after applying crop\n  const expectedQuadPoints = [\n    20 + 0.5 * 100,  // x\n    30 + 0.5 * 100,  // y\n    20 + (0.5 + 0.2) * 100, // x + width\n    30 + 0.5 * 100,  // y\n    20 + 0.5 * 100,  // x\n    30 + (0.5 + 0.2) * 100, // y + height\n    20 + (0.5 + 0.2) * 100, // x + width\n    30 + (0.5 + 0.2) * 100  // y + height\n  ];\n\n  assert.deepEqual(quadPoints, expectedQuadPoints);\n});",
    "i3_gpt-4o": "it(\"should correctly serialize and deserialize highlight annotations with visible highlights on cropped PDFs\", async () => {\n  const { HighlightEditor } = await import(\"../../src/display/editor/highlight.js\");\n  const { AnnotationEditorUIManager } = await import(\"../../src/display/editor/tools.js\");\n  const { Util } = await import(\"../../src/shared/util.js\");\n\n  const pageDimensions = [600, 800];\n  const rect = [100, 100, 500, 700];\n  const color = [255, 255, 0];\n  const opacity = 0.5;\n  const quadPoints = [100, 100, 500, 100, 500, 700, 100, 700];\n\n  const data = {\n    rect,\n    color,\n    opacity,\n    quadPoints,\n    pageIndex: 0,\n  };\n\n  const parent = {\n    drawLayer: {\n      highlight: jest.fn().mockReturnValue({ id: \"highlightId\", clipPathId: \"clipPathId\" }),\n      highlightOutline: jest.fn().mockReturnValue(\"outlineId\"),\n      addClass: jest.fn(),\n      removeClass: jest.fn(),\n      rotate: jest.fn(),\n      updateBox: jest.fn(),\n    },\n    addUndoableEditor: jest.fn(),\n    add: jest.fn(),\n  };\n\n  const uiManager = new AnnotationEditorUIManager();\n  const editor = HighlightEditor.deserialize(data, parent, uiManager);\n  const serializedData = editor.serialize();\n\n  expect(serializedData.quadPoints).toEqual(quadPoints);\n  expect(serializedData.rect).toEqual(rect);\n  expect(serializedData.color).toEqual(color);\n  expect(serializedData.opacity).toBe(opacity);\n});",
    "i3_llama-3.3-70b-versatile": "it(\"should correctly serialize highlight annotations when saving or printing\", async () => {\n  const { HighlightEditor } = await import(\"../../src/display/editor/highlight.js\");\n  const { PDFWorker } = await import(\"../../src/display/api.js\");\n  const { Util } = await import(\"../../src/shared/util.js\");\n  const worker = new PDFWorker();\n  const pdf = await worker.loadPDF(\"path/to/example.pdf\");\n  const page = pdf.getPage(1);\n  const editor = new HighlightEditor({\n    pageIndex: 0,\n    page,\n    boxes: [{ x: 0.1, y: 0.1, width: 0.2, height: 0.2 }],\n    color: \"#fff066\",\n    opacity: 1,\n  });\n  const serialized = editor.serialize();\n  const expectedQuadPoints = [\n    72, 648, 72, 648, 144, 648, 144, 648,\n  ];\n  expect(serialized.quadPoints).toEqual(expectedQuadPoints);\n});",
    "i4_deepseek-r1-distill-llama-70b": "it(\"should correctly serialize highlight boxes in cropped PDFs\", async () => {\n  const { PDFPageProxy } = await import(\"../../src/display/api.js\");\n  const { HighlightEditor } = await import(\"../../src/display/editor/highlight.js\");\n\n  // Setup mock PDF page and editor\n  const page = new PDFPageProxy({\n    pageWidth: 100,\n    pageHeight: 100,\n    pageIndex: 0,\n  });\n\n  const rect = [10, 10, 50, 50]; // Cropped rectangle\n  const boxes = [{ x: 0.2, y: 0.2, width: 0.3, height: 0.3 }];\n\n  // Create editor with cropped coordinates\n  const editor = new HighlightEditor({\n    pageIndex: 0,\n    color: \"#000\",\n    boxes: boxes,\n    x: rect[0],\n    y: rect[1],\n    width: rect[2] - rect[0],\n    height: rect[3] - rect[1],\n    page: page,\n    parent: null,\n    uiManager: null,\n  });\n\n  // Serialize the data\n  const data = editor.serialize();\n  const serializedQuadPoints = data.quadPoints;\n  const serializedOutlines = data.outlines;\n\n  // Deserialize back to compare\n  const deserializedEditor = HighlightEditor.deserialize(data, null, null);\n\n  // Check if the deserialized boxes match the expected coordinates\n  // within the cropped rectangle\n  const expectedBox = {\n    x: (rect[2] - rect[0]) * 0.2,\n    y: (rect[3] - rect[1]) * 0.2,\n    width: (rect[2] - rect[0]) * 0.3,\n    height: (rect[3] - rect[1]) * 0.3,\n  };\n\n  expect(deserializedEditor.#boxes[0]).toEqual(expectedBox);\n});",
    "i4_gpt-4o": "it(\"should correctly serialize and deserialize highlight annotations with visible highlights on cropped PDFs\", async () => {\n  const { HighlightEditor } = await import(\"../../src/display/editor/highlight.js\");\n  const { Util } = await import(\"../../src/shared/util.js\");\n\n  const pageDimensions = [600, 800];\n  const rect = [0.1, 0.1, 0.5, 0.5];\n  const color = [255, 255, 0];\n  const opacity = 0.5;\n  const quadPoints = [60, 720, 300, 720, 60, 680, 300, 680];\n\n  const data = {\n    rect,\n    color,\n    opacity,\n    quadPoints,\n    pageIndex: 0,\n  };\n\n  const parent = {\n    drawLayer: {\n      highlight: jest.fn().mockReturnValue({ id: \"highlightId\", clipPathId: \"clipPathId\" }),\n      highlightOutline: jest.fn().mockReturnValue(\"outlineId\"),\n      addClass: jest.fn(),\n      removeClass: jest.fn(),\n      rotate: jest.fn(),\n      updateBox: jest.fn(),\n    },\n    addUndoableEditor: jest.fn(),\n    add: jest.fn(),\n  };\n\n  const uiManager = {\n    highlightColors: new Map([[\"default\", \"#fff066\"]]),\n    direction: \"ltr\",\n  };\n\n  const editor = HighlightEditor.deserialize(data, parent, uiManager);\n  editor.pageDimensions = pageDimensions;\n\n  const serializedData = editor.serialize();\n  const expectedQuadPoints = [60, 720, 300, 720, 60, 680, 300, 680];\n  const expectedColor = Util.makeHexColor(...color);\n\n  expect(serializedData.quadPoints).toEqual(expectedQuadPoints);\n  expect(serializedData.color).toEqual(expectedColor);\n  expect(serializedData.opacity).toBe(opacity);\n});",
    "i4_llama-3.3-70b-versatile": "it(\"should make highlight visible when savingprinting cropped pdf\", async () => {\n  const { PDFDocument, PDFPageProxy } = await import(\"../../src/display/api.js\");\n  const { Util } = await import(\"../../shared/util.js\");\n  const { HighlightEditor } = await import(\"./highlight.js\");\n\n  const pdfDoc = await PDFDocument.load(await fetch(\"path_to_cropped_pdf.pdf\").then(res => res.arrayBuffer()));\n  const page = await pdfDoc.getPage(1);\n  const viewport = page.getViewport({ scale: 1 });\n  const highlightEditor = new HighlightEditor({\n    pageIndex: 0,\n    page,\n    x: 0.1,\n    y: 0.1,\n    width: 0.5,\n    height: 0.5,\n    color: \"#fff066\",\n    opacity: 1,\n  });\n\n  const serializedData = highlightEditor.serialize();\n  const expectedQuadPoints = highlightEditor.#serializeBoxes([0, 0]);\n  const actualQuadPoints = serializedData.quadPoints;\n\n  expect(actualQuadPoints).toEqual(expectedQuadPoints);\n});",
    "i5_deepseek-r1-distill-llama-70b": "it(\"should include highlights in cropped PDFs when saving\", async () => {\n  const { PDFDocument, PDFPage } = await import(\"../../src/core/document.js\");\n  const { AnnotationFactory } = await import(\"../../src/core/annotation.js\");\n  const { PDFDocument as PDFJSDocument, PDFPageProxy } = await import(\"../../src/display/api.js\");\n\n  // Create a new PDF document with a cropped page\n  const pdf = new PDFDocument();\n  const page = pdf.addPage([0, 0, 100, 100]); // Cropped page\n\n  // Create and add a highlight annotation\n  const annotation = AnnotationFactory.createHighlight({\n    page,\n    quads: [[0, 0, 10, 0, 10, 10, 0, 10]],\n    color: [1, 0, 0],\n  });\n\n  // Save the PDF with the annotation\n  const pdfBytes = await pdf.save();\n  const pdfJS = await PDFJSDocument.load(pdfBytes.buffer);\n\n  // Verify the annotation is correctly rendered\n  const pageProxy = pdfJS.getPage(0);\n  const annotations = await pageProxy.getAnnotations();\n  expect(annotations.length).toBe(1);\n});",
    "i5_gpt-4o": "it(\"should correctly serialize and deserialize highlight annotations with visible highlights on cropped PDFs\", async () => {\n  const { AnnotationEditorType } = await import(\"../../src/shared/util.js\");\n  const { HighlightEditor } = await import(\"../../src/display/editor/highlight.js\");\n  const { PDFDocumentProxy } = await import(\"../../src/display/api.js\");\n\n  const pageDimensions = [600, 800];\n  const rect = [100, 100, 500, 700];\n  const color = [255, 0, 0];\n  const opacity = 0.5;\n  const quadPoints = [100, 100, 200, 100, 200, 200, 100, 200];\n\n  const data = {\n    rect,\n    color,\n    opacity,\n    quadPoints,\n    annotationType: AnnotationEditorType.HIGHLIGHT,\n  };\n\n  const parent = null;\n  const uiManager = null;\n\n  const editor = HighlightEditor.deserialize(data, parent, uiManager);\n  editor.pageDimensions = pageDimensions;\n\n  const serialized = editor.serialize();\n\n  const expectedQuadPoints = [200, 600, 300, 600, 300, 700, 200, 700];\n  const expectedRect = rect;\n\n  expect(serialized.quadPoints).toEqual(expectedQuadPoints);\n  expect(serialized.rect).toEqual(expectedRect);\n});",
    "i5_llama-3.3-70b-versatile": "it(\"should display highlight on cropped pdf when savingprinting\", async () => {\n  const { PDFDocument, PDFPageProxy } = await import(\"../../src/display/api.js\");\n  const { Util } = await import(\"../../src/shared/util.js\");\n  const { PDFWorker } = await import(\"../../src/display/api.js\");\n\n  const pdfDoc = await PDFDocument.load(await (await import(\"../../src/display/fetch_stream.js\")).PDFFetchStream.fetch(\"path_to_cropped_pdf\"));\n  const page = await pdfDoc.getPage(1);\n  const viewport = page.getViewport({ scale: 1 });\n  const renderTask = page.render({\n    viewport,\n    intent: \"print\",\n  });\n\n  const highlightEditor = {\n    pageDimensions: [viewport.width, viewport.height],\n    #boxes: [{ x: 0.1, y: 0.1, width: 0.2, height: 0.2 }],\n    #serializeBoxes: function(rect) {\n      const [pageWidth, pageHeight] = this.pageDimensions;\n      const boxes = this.#boxes;\n      const quadPoints = new Array(boxes.length * 8);\n      const [tx, ty] = rect;\n      let i = 0;\n      for (const { x, y, width, height } of boxes) {\n        const sx = tx + x * pageWidth;\n        const sy = ty + (1 - y - height) * pageHeight;\n        quadPoints[i] = sx;\n        quadPoints[i + 1] = sy;\n        quadPoints[i + 2] = sx + width * pageWidth;\n        quadPoints[i + 3] = sy;\n        quadPoints[i + 4] = sx + width * pageWidth;\n        quadPoints[i + 5] = sy + height * pageHeight;\n        quadPoints[i + 6] = sx;\n        quadPoints[i + 7] = sy + height * pageHeight;\n        i += 8;\n      }\n      return quadPoints;\n    },\n  };\n\n  const expectedQuadPoints = highlightEditor.#serializeBoxes([0, 0]);\n  const actualQuadPoints = (await renderTask.promise).quadPoints;\n\n  expect(actualQuadPoints).toEqual(expectedQuadPoints);\n});"
  },
  "17514": {
    "i1_deepseek-r1-distill-llama-70b": "it(\"should generate a correct appearance stream for a single point ink annotation\", async () => {\n  const { InkAnnotation, numberToString } = await import(\"../../src/core/annotation.js\");\n  const { XRefMock } = await import(\"./test_utils.js\");\n  const xref = new XRefMock();\n  const annotation = {\n    color: [0, 0, 0],\n    rect: [0, 0, 100, 100],\n    paths: [{ bezier: [50, 50] }],\n    thickness: 1,\n    opacity: 1,\n  };\n  const stream = await InkAnnotation.createNewAppearanceStream(annotation, xref, {});\n  const appearance = stream.getString();\n  if (!appearance.includes(`${numberToString(50)} ${numberToString(50)} l S`)) {\n    throw new Error(\"Expected appearance stream to include a line command for a single point ink annotation.\");\n  }\n});",
    "i1_gpt-4o": "it(\"should generate a correct appearance stream for a single point ink annotation\", async () => {\n  const { InkAnnotation, numberToString } = await import(\"../../src/core/annotation.js\");\n  const { XRefMock } = await import(\"./test_utils.js\");\n  const xref = new XRefMock();\n  const annotation = {\n    color: [0, 0, 0],\n    rect: [0, 0, 100, 100],\n    paths: [{ bezier: [50, 50] }],\n    thickness: 1,\n    opacity: 1,\n  };\n  const stream = await InkAnnotation.createNewAppearanceStream(annotation, xref, {});\n  const appearance = stream.getString();\n  if (!appearance.includes(`${numberToString(50)} ${numberToString(50)} l S`)) {\n    throw new Error(\"Expected appearance stream to include a line command for a single point ink annotation.\");\n  }\n});",
    "i1_llama-3.3-70b-versatile": "it(\"should generate a correct appearance stream for a single point ink annotation\", async () => {\n  const { InkAnnotation, numberToString } = await import(\"../../src/core/annotation.js\");\n  const { XRefMock } = await import(\"./test_utils.js\");\n  const xref = new XRefMock();\n  const annotation = {\n    color: [0, 0, 0],\n    rect: [0, 0, 100, 100],\n    paths: [{ bezier: [50, 50] }],\n    thickness: 1,\n    opacity: 1,\n  };\n  const stream = await InkAnnotation.createNewAppearanceStream(annotation, xref, {});\n  const appearance = stream.getString();\n  if (!appearance.includes(`${numberToString(50)} ${numberToString(50)} l S`)) {\n    throw new Error(\"Expected appearance stream to include a line command for a single point ink annotation.\");\n  }\n});",
    "i1_MOCK": "it(\"should generate a correct appearance stream for a single point ink annotation\", async () => {\n  const { InkAnnotation, numberToString } = await import(\"../../src/core/annotation.js\");\n  const { XRefMock } = await import(\"./test_utils.js\");\n  const xref = new XRefMock();\n  const annotation = {\n    color: [0, 0, 0],\n    rect: [0, 0, 100, 100],\n    paths: [{ bezier: [50, 50] }],\n    thickness: 1,\n    opacity: 1,\n  };\n  const stream = await InkAnnotation.createNewAppearanceStream(annotation, xref, {});\n  const appearance = stream.getString();\n  if (!appearance.includes(`${numberToString(50)} ${numberToString(50)} l S`)) {\n    throw new Error(\"Expected appearance stream to include a line command for a single point ink annotation.\");\n  }\n});",
    "i2_deepseek-r1-distill-llama-70b": "it(\"should generate a correct appearance stream for a single point ink annotation\", async () => {\n  const { InkAnnotation, numberToString } = await import(\"../../src/core/annotation.js\");\n  const { XRefMock } = await import(\"./test_utils.js\");\n  const xref = new XRefMock();\n  const annotation = {\n    color: [0, 0, 0],\n    rect: [0, 0, 100, 100],\n    paths: [{ bezier: [50, 50] }],\n    thickness: 1,\n    opacity: 1,\n  };\n  const stream = await InkAnnotation.createNewAppearanceStream(annotation, xref, {});\n  const appearance = stream.getString();\n  if (!appearance.includes(`${numberToString(50)} ${numberToString(50)} l S`)) {\n    throw new Error(\"Expected appearance stream to include a line command for a single point ink annotation.\");\n  }\n});",
    "i2_gpt-4o": "it(\"should generate a correct appearance stream for a single point ink annotation\", async () => {\n  const { InkAnnotation, numberToString } = await import(\"../../src/core/annotation.js\");\n  const { XRefMock } = await import(\"./test_utils.js\");\n  const xref = new XRefMock();\n  const annotation = {\n    color: [0, 0, 0],\n    rect: [0, 0, 100, 100],\n    paths: [{ bezier: [50, 50] }],\n    thickness: 1,\n    opacity: 1,\n  };\n  const stream = await InkAnnotation.createNewAppearanceStream(annotation, xref, {});\n  const appearance = stream.getString();\n  if (!appearance.includes(`${numberToString(50)} ${numberToString(50)} l S`)) {\n    throw new Error(\"Expected appearance stream to include a line command for a single point ink annotation.\");\n  }\n});",
    "i2_llama-3.3-70b-versatile": "it(\"should generate a correct appearance stream for a single point ink annotation\", async () => {\n  const { InkAnnotation, numberToString } = await import(\"../../src/core/annotation.js\");\n  const { XRefMock } = await import(\"./test_utils.js\");\n  const xref = new XRefMock();\n  const annotation = {\n    color: [0, 0, 0],\n    rect: [0, 0, 100, 100],\n    paths: [{ bezier: [50, 50] }],\n    thickness: 1,\n    opacity: 1,\n  };\n  const stream = await InkAnnotation.createNewAppearanceStream(annotation, xref, {});\n  const appearance = stream.getString();\n  if (!appearance.includes(`${numberToString(50)} ${numberToString(50)} l S`)) {\n    throw new Error(\"Expected appearance stream to include a line command for a single point ink annotation.\");\n  }\n});",
    "i3_deepseek-r1-distill-llama-70b": "it(\"should generate a correct appearance stream for a single point ink annotation\", async () => {\n  const { InkAnnotation, numberToString } = await import(\"../../src/core/annotation.js\");\n  const { XRefMock } = await import(\"./test_utils.js\");\n  const xref = new XRefMock();\n  const annotation = {\n    color: [0, 0, 0],\n    rect: [0, 0, 100, 100],\n    paths: [{ bezier: [50, 50] }],\n    thickness: 1,\n    opacity: 1,\n  };\n  const stream = await InkAnnotation.createNewAppearanceStream(annotation, xref, {});\n  const appearance = stream.getString();\n  if (!appearance.includes(`${numberToString(50)} ${numberToString(50)} l S`)) {\n    throw new Error(\"Expected appearance stream to include a line command for a single point ink annotation.\");\n  }\n});",
    "i3_gpt-4o": "it(\"should generate a correct appearance stream for a single point ink annotation\", async () => {\n  const { InkAnnotation, numberToString } = await import(\"../../src/core/annotation.js\");\n  const { XRefMock } = await import(\"./test_utils.js\");\n  const xref = new XRefMock();\n  const annotation = {\n    color: [0, 0, 0],\n    rect: [0, 0, 100, 100],\n    paths: [{ bezier: [50, 50] }],\n    thickness: 1,\n    opacity: 1,\n  };\n  const stream = await InkAnnotation.createNewAppearanceStream(annotation, xref, {});\n  const appearance = stream.getString();\n  if (!appearance.includes(`${numberToString(50)} ${numberToString(50)} l S`)) {\n    throw new Error(\"Expected appearance stream to include a line command for a single point ink annotation.\");\n  }\n});",
    "i3_llama-3.3-70b-versatile": "it(\"should generate a correct appearance stream for a single point ink annotation\", async () => {\n  const { InkAnnotation, numberToString } = await import(\"../../src/core/annotation.js\");\n  const { XRefMock } = await import(\"./test_utils.js\");\n  const xref = new XRefMock();\n  const annotation = {\n    color: [0, 0, 0],\n    rect: [0, 0, 100, 100],\n    paths: [{ bezier: [50, 50] }],\n    thickness: 1,\n    opacity: 1,\n  };\n  const stream = await InkAnnotation.createNewAppearanceStream(annotation, xref, {});\n  const appearance = stream.getString();\n  if (!appearance.includes(`${numberToString(50)} ${numberToString(50)} l S`)) {\n    throw new Error(\"Expected appearance stream to include a line command for a single point ink annotation.\");\n  }\n});",
    "i4_deepseek-r1-distill-llama-70b": "it(\"should generate a correct appearance stream for a single point ink annotation\", async () => {\n  const { InkAnnotation, numberToString } = await import(\"../../src/core/annotation.js\");\n  const { XRefMock } = await import(\"./test_utils.js\");\n  const xref = new XRefMock();\n  const annotation = {\n    color: [0, 0, 0],\n    rect: [0, 0, 100, 100],\n    paths: [{ bezier: [50, 50] }],\n    thickness: 1,\n    opacity: 1,\n  };\n  const stream = await InkAnnotation.createNewAppearanceStream(annotation, xref, {});\n  const appearance = stream.getString();\n  if (!appearance.includes(`${numberToString(50)} ${numberToString(50)} l S`)) {\n    throw new Error(\"Expected appearance stream to include a line command for a single point ink annotation.\");\n  }\n});",
    "i4_gpt-4o": "it(\"should generate a correct appearance stream for a single point ink annotation\", async () => {\n  const { InkAnnotation, numberToString } = await import(\"../../src/core/annotation.js\");\n  const { XRefMock } = await import(\"./test_utils.js\");\n  const xref = new XRefMock();\n  const annotation = {\n    color: [0, 0, 0],\n    rect: [0, 0, 100, 100],\n    paths: [{ bezier: [50, 50] }],\n    thickness: 1,\n    opacity: 1,\n  };\n  const stream = await InkAnnotation.createNewAppearanceStream(annotation, xref, {});\n  const appearance = stream.getString();\n  if (!appearance.includes(`${numberToString(50)} ${numberToString(50)} l S`)) {\n    throw new Error(\"Expected appearance stream to include a line command for a single point ink annotation.\");\n  }\n});",
    "i4_llama-3.3-70b-versatile": "it(\"should generate a correct appearance stream for a single point ink annotation\", async () => {\n  const { InkAnnotation, numberToString } = await import(\"../../src/core/annotation.js\");\n  const { XRefMock } = await import(\"./test_utils.js\");\n  const xref = new XRefMock();\n  const annotation = {\n    color: [0, 0, 0],\n    rect: [0, 0, 100, 100],\n    paths: [{ bezier: [50, 50] }],\n    thickness: 1,\n    opacity: 1,\n  };\n  const stream = await InkAnnotation.createNewAppearanceStream(annotation, xref, {});\n  const appearance = stream.getString();\n  if (!appearance.includes(`${numberToString(50)} ${numberToString(50)} l S`)) {\n    throw new Error(\"Expected appearance stream to include a line command for a single point ink annotation.\");\n  }\n});",
    "i5_deepseek-r1-distill-llama-70b": "it(\"should generate a correct appearance stream for a single point ink annotation\", async () => {\n  const { InkAnnotation, numberToString } = await import(\"../../src/core/annotation.js\");\n  const { XRefMock } = await import(\"./test_utils.js\");\n  const xref = new XRefMock();\n  const annotation = {\n    color: [0, 0, 0],\n    rect: [0, 0, 100, 100],\n    paths: [{ bezier: [50, 50] }],\n    thickness: 1,\n    opacity: 1,\n  };\n  const stream = await InkAnnotation.createNewAppearanceStream(annotation, xref, {});\n  const appearance = stream.getString();\n  if (!appearance.includes(`${numberToString(50)} ${numberToString(50)} l S`)) {\n    throw new Error(\"Expected appearance stream to include a line command for a single point ink annotation.\");\n  }\n});",
    "i5_gpt-4o": "it(\"should generate a correct appearance stream for a single point ink annotation\", async () => {\n  const { InkAnnotation, numberToString } = await import(\"../../src/core/annotation.js\");\n  const { XRefMock } = await import(\"./test_utils.js\");\n  const xref = new XRefMock();\n  const annotation = {\n    color: [0, 0, 0],\n    rect: [0, 0, 100, 100],\n    paths: [{ bezier: [50, 50] }],\n    thickness: 1,\n    opacity: 1,\n  };\n  const stream = await InkAnnotation.createNewAppearanceStream(annotation, xref, {});\n  const appearance = stream.getString();\n  if (!appearance.includes(`${numberToString(50)} ${numberToString(50)} l S`)) {\n    throw new Error(\"Expected appearance stream to include a line command for a single point ink annotation.\");\n  }\n});",
    "i5_llama-3.3-70b-versatile": "it(\"should generate a correct appearance stream for a single point ink annotation\", async () => {\n  const { InkAnnotation, numberToString } = await import(\"../../src/core/annotation.js\");\n  const { XRefMock } = await import(\"./test_utils.js\");\n  const xref = new XRefMock();\n  const annotation = {\n    color: [0, 0, 0],\n    rect: [0, 0, 100, 100],\n    paths: [{ bezier: [50, 50] }],\n    thickness: 1,\n    opacity: 1,\n  };\n  const stream = await InkAnnotation.createNewAppearanceStream(annotation, xref, {});\n  const appearance = stream.getString();\n  if (!appearance.includes(`${numberToString(50)} ${numberToString(50)} l S`)) {\n    throw new Error(\"Expected appearance stream to include a line command for a single point ink annotation.\");\n  }\n});"
  },
  "17558": {
    "i2_llama-3.3-70b-versatile": "it(\"should print documents containing chars with an unicode greater than xFFFF\", async () => {\n  const { PDFDocument } = await import(\"../../src/core/document.js\");\n  const { createDefaultAppearance } = await import(\"../../src/core/default_appearance.js\");\n  const { arrayBuffersToBytes } = await import(\"../../src/core/core_utils.js\");\n  const { FakeUnicodeFont } = await import(\"../../src/core/default_appearance.js\");\n\n  const pdfData = new Uint8Array([0x25, 0x50, 0x44, 0x46, 0x2d, 0x31, 0x2e, 0x34, 0x0a, 0x25, 0xe2, 0xe3, 0xcf, 0xd3, 0x0a, 0x31, 0x20, 0x30, 0x20, 0x6f, 0x62, 0x6a, 0x0a, 0x3c, 0x3c, 0x0a, 0x2f, 0x54, 0x79, 0x70, 0x65, 0x20, 0x2f, 0x50, 0x61, 0x67, 0x65, 0x0a, 0x2f, 0x50, 0x61, 0x72, 0x65, 0x6e, 0x74, 0x20, 0x31, 0x20, 0x30, 0x20, 0x52, 0x0a, 0x2f, 0x4d, 0x65, 0x64, 0x69, 0x61, 0x42, 0x6f, 0x78, 0x20, 0x5b, 0x30, 0x20, 0x30, 0x20, 0x35, 0x39, 0x36, 0x20, 0x35, 0x38, 0x39, 0x5d, 0x0a, 0x3e, 0x3e, 0x0a, 0x65, 0x6e, 0x64, 0x6f, 0x62, 0x6a, 0x0a, 0x32, 0x20, 0x30, 0x20, 0x6f, 0x62, 0x6a, 0x0a, 0x3c, 0x3c, 0x0a, 0x2f, 0x54, 0x79, 0x70, 0x65, 0x20, 0x2f, 0x46, 0x6f, 0x6e, 0x74, 0x0a, 0x2f, 0x53, 0x75"
  },
  "17581": {
    "i1_deepseek-r1-distill-llama-70b": "it(\"should change cursor classes properly for highlighting\", async () => {\n  const dummyDiv = document.createElement(\"div\");\n  document.body.appendChild(dummyDiv);\n  const textLayer = { div: dummyDiv };\n  const uiManager = {\n    registerEditorTypes() {},\n    addLayer() {},\n    direction: \"ltr\"\n  };\n  const l10n = {};\n  const { AnnotationEditorLayer } = await import(\"../../src/display/editor/annotation_editor_layer.js\");\n  const layer = new AnnotationEditorLayer({\n    uiManager,\n    pageIndex: 0,\n    div: document.createElement(\"div\"),\n    accessibilityManager: {},\n    annotationLayer: {},\n    drawLayer: {},\n    textLayer,\n    viewport: {},\n    l10n\n  });\n  layer.enableTextSelection();\n  if (!dummyDiv.classList.contains(\"highlighting\") || dummyDiv.classList.contains(\"drawing\")) {\n    throw new Error(\"enableTextSelection did not add the 'highlighting' class correctly.\");\n  }\n  layer.disableTextSelection();\n  if (dummyDiv.classList.contains(\"highlighting\")) {\n    throw new Error(\"disableTextSelection did not remove the 'highlighting' class correctly.\");\n  }\n  dummyDiv.classList.remove(\"free\");\n  const pointerDownEvent = new PointerEvent(\"pointerdown\", { button: 0, clientX: 100, clientY: 100, ctrlKey: false });\n  dummyDiv.dispatchEvent(pointerDownEvent);\n  if (!dummyDiv.classList.contains(\"free\")) {\n    throw new Error(\"Pointerdown did not add the 'free' class.\");\n  }\n  const pointerUpEvent = new PointerEvent(\"pointerup\", { button: 0 });\n  dummyDiv.dispatchEvent(pointerUpEvent);\n  await new Promise(resolve => setTimeout(resolve, 0));\n  if (dummyDiv.classList.contains(\"free\")) {\n    throw new Error(\"Pointerup did not remove the 'free' class.\");\n  }\n});",
    "i1_gpt-4o": "it(\"should change cursor classes properly for highlighting\", async () => {\n  const dummyDiv = document.createElement(\"div\");\n  document.body.appendChild(dummyDiv);\n  const textLayer = { div: dummyDiv };\n  const uiManager = {\n    registerEditorTypes() {},\n    addLayer() {},\n    direction: \"ltr\"\n  };\n  const l10n = {};\n  const { AnnotationEditorLayer } = await import(\"../../src/display/editor/annotation_editor_layer.js\");\n  const layer = new AnnotationEditorLayer({\n    uiManager,\n    pageIndex: 0,\n    div: document.createElement(\"div\"),\n    accessibilityManager: {},\n    annotationLayer: {},\n    drawLayer: {},\n    textLayer,\n    viewport: {},\n    l10n\n  });\n  layer.enableTextSelection();\n  if (!dummyDiv.classList.contains(\"highlighting\") || dummyDiv.classList.contains(\"drawing\")) {\n    throw new Error(\"enableTextSelection did not add the 'highlighting' class correctly.\");\n  }\n  layer.disableTextSelection();\n  if (dummyDiv.classList.contains(\"highlighting\")) {\n    throw new Error(\"disableTextSelection did not remove the 'highlighting' class correctly.\");\n  }\n  dummyDiv.classList.remove(\"free\");\n  const pointerDownEvent = new PointerEvent(\"pointerdown\", { button: 0, clientX: 100, clientY: 100, ctrlKey: false });\n  dummyDiv.dispatchEvent(pointerDownEvent);\n  if (!dummyDiv.classList.contains(\"free\")) {\n    throw new Error(\"Pointerdown did not add the 'free' class.\");\n  }\n  const pointerUpEvent = new PointerEvent(\"pointerup\", { button: 0 });\n  dummyDiv.dispatchEvent(pointerUpEvent);\n  await new Promise(resolve => setTimeout(resolve, 0));\n  if (dummyDiv.classList.contains(\"free\")) {\n    throw new Error(\"Pointerup did not remove the 'free' class.\");\n  }\n});",
    "i1_llama-3.3-70b-versatile": "it(\"should change cursor classes properly for highlighting\", async () => {\n  const dummyDiv = document.createElement(\"div\");\n  document.body.appendChild(dummyDiv);\n  const textLayer = { div: dummyDiv };\n  const uiManager = {\n    registerEditorTypes() {},\n    addLayer() {},\n    direction: \"ltr\"\n  };\n  const l10n = {};\n  const { AnnotationEditorLayer } = await import(\"../../src/display/editor/annotation_editor_layer.js\");\n  const layer = new AnnotationEditorLayer({\n    uiManager,\n    pageIndex: 0,\n    div: document.createElement(\"div\"),\n    accessibilityManager: {},\n    annotationLayer: {},\n    drawLayer: {},\n    textLayer,\n    viewport: {},\n    l10n\n  });\n  layer.enableTextSelection();\n  if (!dummyDiv.classList.contains(\"highlighting\") || dummyDiv.classList.contains(\"drawing\")) {\n    throw new Error(\"enableTextSelection did not add the 'highlighting' class correctly.\");\n  }\n  layer.disableTextSelection();\n  if (dummyDiv.classList.contains(\"highlighting\")) {\n    throw new Error(\"disableTextSelection did not remove the 'highlighting' class correctly.\");\n  }\n  dummyDiv.classList.remove(\"free\");\n  const pointerDownEvent = new PointerEvent(\"pointerdown\", { button: 0, clientX: 100, clientY: 100, ctrlKey: false });\n  dummyDiv.dispatchEvent(pointerDownEvent);\n  if (!dummyDiv.classList.contains(\"free\")) {\n    throw new Error(\"Pointerdown did not add the 'free' class.\");\n  }\n  const pointerUpEvent = new PointerEvent(\"pointerup\", { button: 0 });\n  dummyDiv.dispatchEvent(pointerUpEvent);\n  await new Promise(resolve => setTimeout(resolve, 0));\n  if (dummyDiv.classList.contains(\"free\")) {\n    throw new Error(\"Pointerup did not remove the 'free' class.\");\n  }\n});",
    "i1_MOCK": "it(\"should change cursor classes properly for highlighting\", async () => {\n  const dummyDiv = document.createElement(\"div\");\n  document.body.appendChild(dummyDiv);\n  const textLayer = { div: dummyDiv };\n  const uiManager = {\n    registerEditorTypes() {},\n    addLayer() {},\n    direction: \"ltr\"\n  };\n  const l10n = {};\n  const { AnnotationEditorLayer } = await import(\"../../src/display/editor/annotation_editor_layer.js\");\n  const layer = new AnnotationEditorLayer({\n    uiManager,\n    pageIndex: 0,\n    div: document.createElement(\"div\"),\n    accessibilityManager: {},\n    annotationLayer: {},\n    drawLayer: {},\n    textLayer,\n    viewport: {},\n    l10n\n  });\n  layer.enableTextSelection();\n  if (!dummyDiv.classList.contains(\"highlighting\") || dummyDiv.classList.contains(\"drawing\")) {\n    throw new Error(\"enableTextSelection did not add the 'highlighting' class correctly.\");\n  }\n  layer.disableTextSelection();\n  if (dummyDiv.classList.contains(\"highlighting\")) {\n    throw new Error(\"disableTextSelection did not remove the 'highlighting' class correctly.\");\n  }\n  dummyDiv.classList.remove(\"free\");\n  const pointerDownEvent = new PointerEvent(\"pointerdown\", { button: 0, clientX: 100, clientY: 100, ctrlKey: false });\n  dummyDiv.dispatchEvent(pointerDownEvent);\n  if (!dummyDiv.classList.contains(\"free\")) {\n    throw new Error(\"Pointerdown did not add the 'free' class.\");\n  }\n  const pointerUpEvent = new PointerEvent(\"pointerup\", { button: 0 });\n  dummyDiv.dispatchEvent(pointerUpEvent);\n  await new Promise(resolve => setTimeout(resolve, 0));\n  if (dummyDiv.classList.contains(\"free\")) {\n    throw new Error(\"Pointerup did not remove the 'free' class.\");\n  }\n});",
    "i2_deepseek-r1-distill-llama-70b": "it(\"should change cursor classes properly for highlighting\", async () => {\n  const dummyDiv = document.createElement(\"div\");\n  document.body.appendChild(dummyDiv);\n  const textLayer = { div: dummyDiv };\n  const uiManager = {\n    registerEditorTypes() {},\n    addLayer() {},\n    direction: \"ltr\"\n  };\n  const l10n = {};\n  const { AnnotationEditorLayer } = await import(\"../../src/display/editor/annotation_editor_layer.js\");\n  const layer = new AnnotationEditorLayer({\n    uiManager,\n    pageIndex: 0,\n    div: document.createElement(\"div\"),\n    accessibilityManager: {},\n    annotationLayer: {},\n    drawLayer: {},\n    textLayer,\n    viewport: {},\n    l10n\n  });\n  layer.enableTextSelection();\n  if (!dummyDiv.classList.contains(\"highlighting\") || dummyDiv.classList.contains(\"drawing\")) {\n    throw new Error(\"enableTextSelection did not add the 'highlighting' class correctly.\");\n  }\n  layer.disableTextSelection();\n  if (dummyDiv.classList.contains(\"highlighting\")) {\n    throw new Error(\"disableTextSelection did not remove the 'highlighting' class correctly.\");\n  }\n  dummyDiv.classList.remove(\"free\");\n  const pointerDownEvent = new PointerEvent(\"pointerdown\", { button: 0, clientX: 100, clientY: 100, ctrlKey: false });\n  dummyDiv.dispatchEvent(pointerDownEvent);\n  if (!dummyDiv.classList.contains(\"free\")) {\n    throw new Error(\"Pointerdown did not add the 'free' class.\");\n  }\n  const pointerUpEvent = new PointerEvent(\"pointerup\", { button: 0 });\n  dummyDiv.dispatchEvent(pointerUpEvent);\n  await new Promise(resolve => setTimeout(resolve, 0));\n  if (dummyDiv.classList.contains(\"free\")) {\n    throw new Error(\"Pointerup did not remove the 'free' class.\");\n  }\n});",
    "i2_gpt-4o": "it(\"should change cursor classes properly for highlighting\", async () => {\n  const dummyDiv = document.createElement(\"div\");\n  document.body.appendChild(dummyDiv);\n  const textLayer = { div: dummyDiv };\n  const uiManager = {\n    registerEditorTypes() {},\n    addLayer() {},\n    direction: \"ltr\"\n  };\n  const l10n = {};\n  const { AnnotationEditorLayer } = await import(\"../../src/display/editor/annotation_editor_layer.js\");\n  const layer = new AnnotationEditorLayer({\n    uiManager,\n    pageIndex: 0,\n    div: document.createElement(\"div\"),\n    accessibilityManager: {},\n    annotationLayer: {},\n    drawLayer: {},\n    textLayer,\n    viewport: {},\n    l10n\n  });\n  layer.enableTextSelection();\n  if (!dummyDiv.classList.contains(\"highlighting\") || dummyDiv.classList.contains(\"drawing\")) {\n    throw new Error(\"enableTextSelection did not add the 'highlighting' class correctly.\");\n  }\n  layer.disableTextSelection();\n  if (dummyDiv.classList.contains(\"highlighting\")) {\n    throw new Error(\"disableTextSelection did not remove the 'highlighting' class correctly.\");\n  }\n  dummyDiv.classList.remove(\"free\");\n  const pointerDownEvent = new PointerEvent(\"pointerdown\", { button: 0, clientX: 100, clientY: 100, ctrlKey: false });\n  dummyDiv.dispatchEvent(pointerDownEvent);\n  if (!dummyDiv.classList.contains(\"free\")) {\n    throw new Error(\"Pointerdown did not add the 'free' class.\");\n  }\n  const pointerUpEvent = new PointerEvent(\"pointerup\", { button: 0 });\n  dummyDiv.dispatchEvent(pointerUpEvent);\n  await new Promise(resolve => setTimeout(resolve, 0));\n  if (dummyDiv.classList.contains(\"free\")) {\n    throw new Error(\"Pointerup did not remove the 'free' class.\");\n  }\n});",
    "i2_llama-3.3-70b-versatile": "it(\"should change cursor classes properly for highlighting\", async () => {\n  const dummyDiv = document.createElement(\"div\");\n  document.body.appendChild(dummyDiv);\n  const textLayer = { div: dummyDiv };\n  const uiManager = {\n    registerEditorTypes() {},\n    addLayer() {},\n    direction: \"ltr\"\n  };\n  const l10n = {};\n  const { AnnotationEditorLayer } = await import(\"../../src/display/editor/annotation_editor_layer.js\");\n  const layer = new AnnotationEditorLayer({\n    uiManager,\n    pageIndex: 0,\n    div: document.createElement(\"div\"),\n    accessibilityManager: {},\n    annotationLayer: {},\n    drawLayer: {},\n    textLayer,\n    viewport: {},\n    l10n\n  });\n  layer.enableTextSelection();\n  if (!dummyDiv.classList.contains(\"highlighting\") || dummyDiv.classList.contains(\"drawing\")) {\n    throw new Error(\"enableTextSelection did not add the 'highlighting' class correctly.\");\n  }\n  layer.disableTextSelection();\n  if (dummyDiv.classList.contains(\"highlighting\")) {\n    throw new Error(\"disableTextSelection did not remove the 'highlighting' class correctly.\");\n  }\n  dummyDiv.classList.remove(\"free\");\n  const pointerDownEvent = new PointerEvent(\"pointerdown\", { button: 0, clientX: 100, clientY: 100, ctrlKey: false });\n  dummyDiv.dispatchEvent(pointerDownEvent);\n  if (!dummyDiv.classList.contains(\"free\")) {\n    throw new Error(\"Pointerdown did not add the 'free' class.\");\n  }\n  const pointerUpEvent = new PointerEvent(\"pointerup\", { button: 0 });\n  dummyDiv.dispatchEvent(pointerUpEvent);\n  await new Promise(resolve => setTimeout(resolve, 0));\n  if (dummyDiv.classList.contains(\"free\")) {\n    throw new Error(\"Pointerup did not remove the 'free' class.\");\n  }\n});",
    "i3_deepseek-r1-distill-llama-70b": "it(\"should change cursor classes properly for highlighting\", async () => {\n  const dummyDiv = document.createElement(\"div\");\n  document.body.appendChild(dummyDiv);\n  const textLayer = { div: dummyDiv };\n  const uiManager = {\n    registerEditorTypes() {},\n    addLayer() {},\n    direction: \"ltr\"\n  };\n  const l10n = {};\n  const { AnnotationEditorLayer } = await import(\"../../src/display/editor/annotation_editor_layer.js\");\n  const layer = new AnnotationEditorLayer({\n    uiManager,\n    pageIndex: 0,\n    div: document.createElement(\"div\"),\n    accessibilityManager: {},\n    annotationLayer: {},\n    drawLayer: {},\n    textLayer,\n    viewport: {},\n    l10n\n  });\n  layer.enableTextSelection();\n  if (!dummyDiv.classList.contains(\"highlighting\") || dummyDiv.classList.contains(\"drawing\")) {\n    throw new Error(\"enableTextSelection did not add the 'highlighting' class correctly.\");\n  }\n  layer.disableTextSelection();\n  if (dummyDiv.classList.contains(\"highlighting\")) {\n    throw new Error(\"disableTextSelection did not remove the 'highlighting' class correctly.\");\n  }\n  dummyDiv.classList.remove(\"free\");\n  const pointerDownEvent = new PointerEvent(\"pointerdown\", { button: 0, clientX: 100, clientY: 100, ctrlKey: false });\n  dummyDiv.dispatchEvent(pointerDownEvent);\n  if (!dummyDiv.classList.contains(\"free\")) {\n    throw new Error(\"Pointerdown did not add the 'free' class.\");\n  }\n  const pointerUpEvent = new PointerEvent(\"pointerup\", { button: 0 });\n  dummyDiv.dispatchEvent(pointerUpEvent);\n  await new Promise(resolve => setTimeout(resolve, 0));\n  if (dummyDiv.classList.contains(\"free\")) {\n    throw new Error(\"Pointerup did not remove the 'free' class.\");\n  }\n});",
    "i3_gpt-4o": "it(\"should change cursor classes properly for highlighting\", async () => {\n  const dummyDiv = document.createElement(\"div\");\n  document.body.appendChild(dummyDiv);\n  const textLayer = { div: dummyDiv };\n  const uiManager = {\n    registerEditorTypes() {},\n    addLayer() {},\n    direction: \"ltr\"\n  };\n  const l10n = {};\n  const { AnnotationEditorLayer } = await import(\"../../src/display/editor/annotation_editor_layer.js\");\n  const layer = new AnnotationEditorLayer({\n    uiManager,\n    pageIndex: 0,\n    div: document.createElement(\"div\"),\n    accessibilityManager: {},\n    annotationLayer: {},\n    drawLayer: {},\n    textLayer,\n    viewport: {},\n    l10n\n  });\n  layer.enableTextSelection();\n  if (!dummyDiv.classList.contains(\"highlighting\") || dummyDiv.classList.contains(\"drawing\")) {\n    throw new Error(\"enableTextSelection did not add the 'highlighting' class correctly.\");\n  }\n  layer.disableTextSelection();\n  if (dummyDiv.classList.contains(\"highlighting\")) {\n    throw new Error(\"disableTextSelection did not remove the 'highlighting' class correctly.\");\n  }\n  dummyDiv.classList.remove(\"free\");\n  const pointerDownEvent = new PointerEvent(\"pointerdown\", { button: 0, clientX: 100, clientY: 100, ctrlKey: false });\n  dummyDiv.dispatchEvent(pointerDownEvent);\n  if (!dummyDiv.classList.contains(\"free\")) {\n    throw new Error(\"Pointerdown did not add the 'free' class.\");\n  }\n  const pointerUpEvent = new PointerEvent(\"pointerup\", { button: 0 });\n  dummyDiv.dispatchEvent(pointerUpEvent);\n  await new Promise(resolve => setTimeout(resolve, 0));\n  if (dummyDiv.classList.contains(\"free\")) {\n    throw new Error(\"Pointerup did not remove the 'free' class.\");\n  }\n});",
    "i3_llama-3.3-70b-versatile": "it(\"should change cursor classes properly for highlighting\", async () => {\n  const dummyDiv = document.createElement(\"div\");\n  document.body.appendChild(dummyDiv);\n  const textLayer = { div: dummyDiv };\n  const uiManager = {\n    registerEditorTypes() {},\n    addLayer() {},\n    direction: \"ltr\"\n  };\n  const l10n = {};\n  const { AnnotationEditorLayer } = await import(\"../../src/display/editor/annotation_editor_layer.js\");\n  const layer = new AnnotationEditorLayer({\n    uiManager,\n    pageIndex: 0,\n    div: document.createElement(\"div\"),\n    accessibilityManager: {},\n    annotationLayer: {},\n    drawLayer: {},\n    textLayer,\n    viewport: {},\n    l10n\n  });\n  layer.enableTextSelection();\n  if (!dummyDiv.classList.contains(\"highlighting\") || dummyDiv.classList.contains(\"drawing\")) {\n    throw new Error(\"enableTextSelection did not add the 'highlighting' class correctly.\");\n  }\n  layer.disableTextSelection();\n  if (dummyDiv.classList.contains(\"highlighting\")) {\n    throw new Error(\"disableTextSelection did not remove the 'highlighting' class correctly.\");\n  }\n  dummyDiv.classList.remove(\"free\");\n  const pointerDownEvent = new PointerEvent(\"pointerdown\", { button: 0, clientX: 100, clientY: 100, ctrlKey: false });\n  dummyDiv.dispatchEvent(pointerDownEvent);\n  if (!dummyDiv.classList.contains(\"free\")) {\n    throw new Error(\"Pointerdown did not add the 'free' class.\");\n  }\n  const pointerUpEvent = new PointerEvent(\"pointerup\", { button: 0 });\n  dummyDiv.dispatchEvent(pointerUpEvent);\n  await new Promise(resolve => setTimeout(resolve, 0));\n  if (dummyDiv.classList.contains(\"free\")) {\n    throw new Error(\"Pointerup did not remove the 'free' class.\");\n  }\n});",
    "i4_deepseek-r1-distill-llama-70b": "it(\"should change cursor classes properly for highlighting\", async () => {\n  const dummyDiv = document.createElement(\"div\");\n  document.body.appendChild(dummyDiv);\n  const textLayer = { div: dummyDiv };\n  const uiManager = {\n    registerEditorTypes() {},\n    addLayer() {},\n    direction: \"ltr\"\n  };\n  const l10n = {};\n  const { AnnotationEditorLayer } = await import(\"../../src/display/editor/annotation_editor_layer.js\");\n  const layer = new AnnotationEditorLayer({\n    uiManager,\n    pageIndex: 0,\n    div: document.createElement(\"div\"),\n    accessibilityManager: {},\n    annotationLayer: {},\n    drawLayer: {},\n    textLayer,\n    viewport: {},\n    l10n\n  });\n  layer.enableTextSelection();\n  if (!dummyDiv.classList.contains(\"highlighting\") || dummyDiv.classList.contains(\"drawing\")) {\n    throw new Error(\"enableTextSelection did not add the 'highlighting' class correctly.\");\n  }\n  layer.disableTextSelection();\n  if (dummyDiv.classList.contains(\"highlighting\")) {\n    throw new Error(\"disableTextSelection did not remove the 'highlighting' class correctly.\");\n  }\n  dummyDiv.classList.remove(\"free\");\n  const pointerDownEvent = new PointerEvent(\"pointerdown\", { button: 0, clientX: 100, clientY: 100, ctrlKey: false });\n  dummyDiv.dispatchEvent(pointerDownEvent);\n  if (!dummyDiv.classList.contains(\"free\")) {\n    throw new Error(\"Pointerdown did not add the 'free' class.\");\n  }\n  const pointerUpEvent = new PointerEvent(\"pointerup\", { button: 0 });\n  dummyDiv.dispatchEvent(pointerUpEvent);\n  await new Promise(resolve => setTimeout(resolve, 0));\n  if (dummyDiv.classList.contains(\"free\")) {\n    throw new Error(\"Pointerup did not remove the 'free' class.\");\n  }\n});",
    "i4_gpt-4o": "it(\"should change cursor classes properly for highlighting\", async () => {\n  const dummyDiv = document.createElement(\"div\");\n  document.body.appendChild(dummyDiv);\n  const textLayer = { div: dummyDiv };\n  const uiManager = {\n    registerEditorTypes() {},\n    addLayer() {},\n    direction: \"ltr\"\n  };\n  const l10n = {};\n  const { AnnotationEditorLayer } = await import(\"../../src/display/editor/annotation_editor_layer.js\");\n  const layer = new AnnotationEditorLayer({\n    uiManager,\n    pageIndex: 0,\n    div: document.createElement(\"div\"),\n    accessibilityManager: {},\n    annotationLayer: {},\n    drawLayer: {},\n    textLayer,\n    viewport: {},\n    l10n\n  });\n  layer.enableTextSelection();\n  if (!dummyDiv.classList.contains(\"highlighting\") || dummyDiv.classList.contains(\"drawing\")) {\n    throw new Error(\"enableTextSelection did not add the 'highlighting' class correctly.\");\n  }\n  layer.disableTextSelection();\n  if (dummyDiv.classList.contains(\"highlighting\")) {\n    throw new Error(\"disableTextSelection did not remove the 'highlighting' class correctly.\");\n  }\n  dummyDiv.classList.remove(\"free\");\n  const pointerDownEvent = new PointerEvent(\"pointerdown\", { button: 0, clientX: 100, clientY: 100, ctrlKey: false });\n  dummyDiv.dispatchEvent(pointerDownEvent);\n  if (!dummyDiv.classList.contains(\"free\")) {\n    throw new Error(\"Pointerdown did not add the 'free' class.\");\n  }\n  const pointerUpEvent = new PointerEvent(\"pointerup\", { button: 0 });\n  dummyDiv.dispatchEvent(pointerUpEvent);\n  await new Promise(resolve => setTimeout(resolve, 0));\n  if (dummyDiv.classList.contains(\"free\")) {\n    throw new Error(\"Pointerup did not remove the 'free' class.\");\n  }\n});",
    "i4_llama-3.3-70b-versatile": "it(\"should change cursor classes properly for highlighting\", async () => {\n  const dummyDiv = document.createElement(\"div\");\n  document.body.appendChild(dummyDiv);\n  const textLayer = { div: dummyDiv };\n  const uiManager = {\n    registerEditorTypes() {},\n    addLayer() {},\n    direction: \"ltr\"\n  };\n  const l10n = {};\n  const { AnnotationEditorLayer } = await import(\"../../src/display/editor/annotation_editor_layer.js\");\n  const layer = new AnnotationEditorLayer({\n    uiManager,\n    pageIndex: 0,\n    div: document.createElement(\"div\"),\n    accessibilityManager: {},\n    annotationLayer: {},\n    drawLayer: {},\n    textLayer,\n    viewport: {},\n    l10n\n  });\n  layer.enableTextSelection();\n  if (!dummyDiv.classList.contains(\"highlighting\") || dummyDiv.classList.contains(\"drawing\")) {\n    throw new Error(\"enableTextSelection did not add the 'highlighting' class correctly.\");\n  }\n  layer.disableTextSelection();\n  if (dummyDiv.classList.contains(\"highlighting\")) {\n    throw new Error(\"disableTextSelection did not remove the 'highlighting' class correctly.\");\n  }\n  dummyDiv.classList.remove(\"free\");\n  const pointerDownEvent = new PointerEvent(\"pointerdown\", { button: 0, clientX: 100, clientY: 100, ctrlKey: false });\n  dummyDiv.dispatchEvent(pointerDownEvent);\n  if (!dummyDiv.classList.contains(\"free\")) {\n    throw new Error(\"Pointerdown did not add the 'free' class.\");\n  }\n  const pointerUpEvent = new PointerEvent(\"pointerup\", { button: 0 });\n  dummyDiv.dispatchEvent(pointerUpEvent);\n  await new Promise(resolve => setTimeout(resolve, 0));\n  if (dummyDiv.classList.contains(\"free\")) {\n    throw new Error(\"Pointerup did not remove the 'free' class.\");\n  }\n});",
    "i5_deepseek-r1-distill-llama-70b": "it(\"should change cursor classes properly for highlighting\", async () => {\n  const dummyDiv = document.createElement(\"div\");\n  document.body.appendChild(dummyDiv);\n  const textLayer = { div: dummyDiv };\n  const uiManager = {\n    registerEditorTypes() {},\n    addLayer() {},\n    direction: \"ltr\"\n  };\n  const l10n = {};\n  const { AnnotationEditorLayer } = await import(\"../../src/display/editor/annotation_editor_layer.js\");\n  const layer = new AnnotationEditorLayer({\n    uiManager,\n    pageIndex: 0,\n    div: document.createElement(\"div\"),\n    accessibilityManager: {},\n    annotationLayer: {},\n    drawLayer: {},\n    textLayer,\n    viewport: {},\n    l10n\n  });\n  layer.enableTextSelection();\n  if (!dummyDiv.classList.contains(\"highlighting\") || dummyDiv.classList.contains(\"drawing\")) {\n    throw new Error(\"enableTextSelection did not add the 'highlighting' class correctly.\");\n  }\n  layer.disableTextSelection();\n  if (dummyDiv.classList.contains(\"highlighting\")) {\n    throw new Error(\"disableTextSelection did not remove the 'highlighting' class correctly.\");\n  }\n  dummyDiv.classList.remove(\"free\");\n  const pointerDownEvent = new PointerEvent(\"pointerdown\", { button: 0, clientX: 100, clientY: 100, ctrlKey: false });\n  dummyDiv.dispatchEvent(pointerDownEvent);\n  if (!dummyDiv.classList.contains(\"free\")) {\n    throw new Error(\"Pointerdown did not add the 'free' class.\");\n  }\n  const pointerUpEvent = new PointerEvent(\"pointerup\", { button: 0 });\n  dummyDiv.dispatchEvent(pointerUpEvent);\n  await new Promise(resolve => setTimeout(resolve, 0));\n  if (dummyDiv.classList.contains(\"free\")) {\n    throw new Error(\"Pointerup did not remove the 'free' class.\");\n  }\n});",
    "i5_gpt-4o": "it(\"should change cursor classes properly for highlighting\", async () => {\n  const dummyDiv = document.createElement(\"div\");\n  document.body.appendChild(dummyDiv);\n  const textLayer = { div: dummyDiv };\n  const uiManager = {\n    registerEditorTypes() {},\n    addLayer() {},\n    direction: \"ltr\"\n  };\n  const l10n = {};\n  const { AnnotationEditorLayer } = await import(\"../../src/display/editor/annotation_editor_layer.js\");\n  const layer = new AnnotationEditorLayer({\n    uiManager,\n    pageIndex: 0,\n    div: document.createElement(\"div\"),\n    accessibilityManager: {},\n    annotationLayer: {},\n    drawLayer: {},\n    textLayer,\n    viewport: {},\n    l10n\n  });\n  layer.enableTextSelection();\n  if (!dummyDiv.classList.contains(\"highlighting\") || dummyDiv.classList.contains(\"drawing\")) {\n    throw new Error(\"enableTextSelection did not add the 'highlighting' class correctly.\");\n  }\n  layer.disableTextSelection();\n  if (dummyDiv.classList.contains(\"highlighting\")) {\n    throw new Error(\"disableTextSelection did not remove the 'highlighting' class correctly.\");\n  }\n  dummyDiv.classList.remove(\"free\");\n  const pointerDownEvent = new PointerEvent(\"pointerdown\", { button: 0, clientX: 100, clientY: 100, ctrlKey: false });\n  dummyDiv.dispatchEvent(pointerDownEvent);\n  if (!dummyDiv.classList.contains(\"free\")) {\n    throw new Error(\"Pointerdown did not add the 'free' class.\");\n  }\n  const pointerUpEvent = new PointerEvent(\"pointerup\", { button: 0 });\n  dummyDiv.dispatchEvent(pointerUpEvent);\n  await new Promise(resolve => setTimeout(resolve, 0));\n  if (dummyDiv.classList.contains(\"free\")) {\n    throw new Error(\"Pointerup did not remove the 'free' class.\");\n  }\n});",
    "i5_llama-3.3-70b-versatile": "it(\"should change cursor classes properly for highlighting\", async () => {\n  const dummyDiv = document.createElement(\"div\");\n  document.body.appendChild(dummyDiv);\n  const textLayer = { div: dummyDiv };\n  const uiManager = {\n    registerEditorTypes() {},\n    addLayer() {},\n    direction: \"ltr\"\n  };\n  const l10n = {};\n  const { AnnotationEditorLayer } = await import(\"../../src/display/editor/annotation_editor_layer.js\");\n  const layer = new AnnotationEditorLayer({\n    uiManager,\n    pageIndex: 0,\n    div: document.createElement(\"div\"),\n    accessibilityManager: {},\n    annotationLayer: {},\n    drawLayer: {},\n    textLayer,\n    viewport: {},\n    l10n\n  });\n  layer.enableTextSelection();\n  if (!dummyDiv.classList.contains(\"highlighting\") || dummyDiv.classList.contains(\"drawing\")) {\n    throw new Error(\"enableTextSelection did not add the 'highlighting' class correctly.\");\n  }\n  layer.disableTextSelection();\n  if (dummyDiv.classList.contains(\"highlighting\")) {\n    throw new Error(\"disableTextSelection did not remove the 'highlighting' class correctly.\");\n  }\n  dummyDiv.classList.remove(\"free\");\n  const pointerDownEvent = new PointerEvent(\"pointerdown\", { button: 0, clientX: 100, clientY: 100, ctrlKey: false });\n  dummyDiv.dispatchEvent(pointerDownEvent);\n  if (!dummyDiv.classList.contains(\"free\")) {\n    throw new Error(\"Pointerdown did not add the 'free' class.\");\n  }\n  const pointerUpEvent = new PointerEvent(\"pointerup\", { button: 0 });\n  dummyDiv.dispatchEvent(pointerUpEvent);\n  await new Promise(resolve => setTimeout(resolve, 0));\n  if (dummyDiv.classList.contains(\"free\")) {\n    throw new Error(\"Pointerup did not remove the 'free' class.\");\n  }\n});"
  },
  "17639": {
    "i1_deepseek-r1-distill-llama-70b": "it(\"should add mask class to the free highlight mask use element\", async () => {\n  const { DrawLayer } = await import(\"../../src/display/draw_layer.js\");\n  const originalCreateElement = DrawLayer._svgFactory.createElement;\n  let useCount = 0;\n  let freeUse = null;\n  let svgCreated = null;\n  DrawLayer._svgFactory.createElement = function(type) {\n    if (type === \"svg\") {\n      svgCreated = document.createElementNS(\"http://www.w3.org/2000/svg\", \"svg\");\n      return svgCreated;\n    }\n    const el = originalCreateElement.call(this, type);\n    if (type === \"use\") {\n      if (useCount === 0) {\n        freeUse = el;\n      }\n      useCount++;\n    }\n    return el;\n  };\n  const drawLayer = new DrawLayer({ pageIndex: 0 });\n  const outlines = {\n    free: true,\n    box: { x: 0, y: 0, width: 100, height: 100 },\n    toSVGPath() {\n      return \"M0,0 L100,0 L100,100 L0,100 Z\";\n    }\n  };\n  drawLayer.highlightOutline(outlines);\n  DrawLayer._svgFactory.createElement = originalCreateElement;\n  if (!freeUse || !freeUse.classList.contains(\"mask\")) {\n    throw new Error(\"Expected the free highlight mask use element to have 'mask' class.\");\n  }\n});\n",
    "i1_gpt-4o": "it(\"should add mask class to the free highlight mask use element\", async () => {\n  const { DrawLayer } = await import(\"../../src/display/draw_layer.js\");\n  const originalCreateElement = DrawLayer._svgFactory.createElement;\n  let useCount = 0;\n  let freeUse = null;\n  let svgCreated = null;\n  DrawLayer._svgFactory.createElement = function(type) {\n    if (type === \"svg\") {\n      svgCreated = document.createElementNS(\"http://www.w3.org/2000/svg\", \"svg\");\n      return svgCreated;\n    }\n    const el = originalCreateElement.call(this, type);\n    if (type === \"use\") {\n      if (useCount === 0) {\n        freeUse = el;\n      }\n      useCount++;\n    }\n    return el;\n  };\n  const drawLayer = new DrawLayer({ pageIndex: 0 });\n  const outlines = {\n    free: true,\n    box: { x: 0, y: 0, width: 100, height: 100 },\n    toSVGPath() {\n      return \"M0,0 L100,0 L100,100 L0,100 Z\";\n    }\n  };\n  drawLayer.highlightOutline(outlines);\n  DrawLayer._svgFactory.createElement = originalCreateElement;\n  if (!freeUse || !freeUse.classList.contains(\"mask\")) {\n    throw new Error(\"Expected the free highlight mask use element to have 'mask' class.\");\n  }\n});\n",
    "i1_llama-3.3-70b-versatile": "it(\"should add mask class to the free highlight mask use element\", async () => {\n  const { DrawLayer } = await import(\"../../src/display/draw_layer.js\");\n  const originalCreateElement = DrawLayer._svgFactory.createElement;\n  let useCount = 0;\n  let freeUse = null;\n  let svgCreated = null;\n  DrawLayer._svgFactory.createElement = function(type) {\n    if (type === \"svg\") {\n      svgCreated = document.createElementNS(\"http://www.w3.org/2000/svg\", \"svg\");\n      return svgCreated;\n    }\n    const el = originalCreateElement.call(this, type);\n    if (type === \"use\") {\n      if (useCount === 0) {\n        freeUse = el;\n      }\n      useCount++;\n    }\n    return el;\n  };\n  const drawLayer = new DrawLayer({ pageIndex: 0 });\n  const outlines = {\n    free: true,\n    box: { x: 0, y: 0, width: 100, height: 100 },\n    toSVGPath() {\n      return \"M0,0 L100,0 L100,100 L0,100 Z\";\n    }\n  };\n  drawLayer.highlightOutline(outlines);\n  DrawLayer._svgFactory.createElement = originalCreateElement;\n  if (!freeUse || !freeUse.classList.contains(\"mask\")) {\n    throw new Error(\"Expected the free highlight mask use element to have 'mask' class.\");\n  }\n});\n",
    "i1_MOCK": "it(\"should add mask class to the free highlight mask use element\", async () => {\n  const { DrawLayer } = await import(\"../../src/display/draw_layer.js\");\n  const originalCreateElement = DrawLayer._svgFactory.createElement;\n  let useCount = 0;\n  let freeUse = null;\n  let svgCreated = null;\n  DrawLayer._svgFactory.createElement = function(type) {\n    if (type === \"svg\") {\n      svgCreated = document.createElementNS(\"http://www.w3.org/2000/svg\", \"svg\");\n      return svgCreated;\n    }\n    const el = originalCreateElement.call(this, type);\n    if (type === \"use\") {\n      if (useCount === 0) {\n        freeUse = el;\n      }\n      useCount++;\n    }\n    return el;\n  };\n  const drawLayer = new DrawLayer({ pageIndex: 0 });\n  const outlines = {\n    free: true,\n    box: { x: 0, y: 0, width: 100, height: 100 },\n    toSVGPath() {\n      return \"M0,0 L100,0 L100,100 L0,100 Z\";\n    }\n  };\n  drawLayer.highlightOutline(outlines);\n  DrawLayer._svgFactory.createElement = originalCreateElement;\n  if (!freeUse || !freeUse.classList.contains(\"mask\")) {\n    throw new Error(\"Expected the free highlight mask use element to have 'mask' class.\");\n  }\n});\n",
    "i2_deepseek-r1-distill-llama-70b": "it(\"should add mask class to the free highlight mask use element\", async () => {\n  const { DrawLayer } = await import(\"../../src/display/draw_layer.js\");\n  const originalCreateElement = DrawLayer._svgFactory.createElement;\n  let useCount = 0;\n  let freeUse = null;\n  let svgCreated = null;\n  DrawLayer._svgFactory.createElement = function(type) {\n    if (type === \"svg\") {\n      svgCreated = document.createElementNS(\"http://www.w3.org/2000/svg\", \"svg\");\n      return svgCreated;\n    }\n    const el = originalCreateElement.call(this, type);\n    if (type === \"use\") {\n      if (useCount === 0) {\n        freeUse = el;\n      }\n      useCount++;\n    }\n    return el;\n  };\n  const drawLayer = new DrawLayer({ pageIndex: 0 });\n  const outlines = {\n    free: true,\n    box: { x: 0, y: 0, width: 100, height: 100 },\n    toSVGPath() {\n      return \"M0,0 L100,0 L100,100 L0,100 Z\";\n    }\n  };\n  drawLayer.highlightOutline(outlines);\n  DrawLayer._svgFactory.createElement = originalCreateElement;\n  if (!freeUse || !freeUse.classList.contains(\"mask\")) {\n    throw new Error(\"Expected the free highlight mask use element to have 'mask' class.\");\n  }\n});\n",
    "i2_gpt-4o": "it(\"should add mask class to the free highlight mask use element\", async () => {\n  const { DrawLayer } = await import(\"../../src/display/draw_layer.js\");\n  const originalCreateElement = DrawLayer._svgFactory.createElement;\n  let useCount = 0;\n  let freeUse = null;\n  let svgCreated = null;\n  DrawLayer._svgFactory.createElement = function(type) {\n    if (type === \"svg\") {\n      svgCreated = document.createElementNS(\"http://www.w3.org/2000/svg\", \"svg\");\n      return svgCreated;\n    }\n    const el = originalCreateElement.call(this, type);\n    if (type === \"use\") {\n      if (useCount === 0) {\n        freeUse = el;\n      }\n      useCount++;\n    }\n    return el;\n  };\n  const drawLayer = new DrawLayer({ pageIndex: 0 });\n  const outlines = {\n    free: true,\n    box: { x: 0, y: 0, width: 100, height: 100 },\n    toSVGPath() {\n      return \"M0,0 L100,0 L100,100 L0,100 Z\";\n    }\n  };\n  drawLayer.highlightOutline(outlines);\n  DrawLayer._svgFactory.createElement = originalCreateElement;\n  if (!freeUse || !freeUse.classList.contains(\"mask\")) {\n    throw new Error(\"Expected the free highlight mask use element to have 'mask' class.\");\n  }\n});\n",
    "i2_llama-3.3-70b-versatile": "it(\"should add mask class to the free highlight mask use element\", async () => {\n  const { DrawLayer } = await import(\"../../src/display/draw_layer.js\");\n  const originalCreateElement = DrawLayer._svgFactory.createElement;\n  let useCount = 0;\n  let freeUse = null;\n  let svgCreated = null;\n  DrawLayer._svgFactory.createElement = function(type) {\n    if (type === \"svg\") {\n      svgCreated = document.createElementNS(\"http://www.w3.org/2000/svg\", \"svg\");\n      return svgCreated;\n    }\n    const el = originalCreateElement.call(this, type);\n    if (type === \"use\") {\n      if (useCount === 0) {\n        freeUse = el;\n      }\n      useCount++;\n    }\n    return el;\n  };\n  const drawLayer = new DrawLayer({ pageIndex: 0 });\n  const outlines = {\n    free: true,\n    box: { x: 0, y: 0, width: 100, height: 100 },\n    toSVGPath() {\n      return \"M0,0 L100,0 L100,100 L0,100 Z\";\n    }\n  };\n  drawLayer.highlightOutline(outlines);\n  DrawLayer._svgFactory.createElement = originalCreateElement;\n  if (!freeUse || !freeUse.classList.contains(\"mask\")) {\n    throw new Error(\"Expected the free highlight mask use element to have 'mask' class.\");\n  }\n});\n",
    "i3_deepseek-r1-distill-llama-70b": "it(\"should add mask class to the free highlight mask use element\", async () => {\n  const { DrawLayer } = await import(\"../../src/display/draw_layer.js\");\n  const originalCreateElement = DrawLayer._svgFactory.createElement;\n  let useCount = 0;\n  let freeUse = null;\n  let svgCreated = null;\n  DrawLayer._svgFactory.createElement = function(type) {\n    if (type === \"svg\") {\n      svgCreated = document.createElementNS(\"http://www.w3.org/2000/svg\", \"svg\");\n      return svgCreated;\n    }\n    const el = originalCreateElement.call(this, type);\n    if (type === \"use\") {\n      if (useCount === 0) {\n        freeUse = el;\n      }\n      useCount++;\n    }\n    return el;\n  };\n  const drawLayer = new DrawLayer({ pageIndex: 0 });\n  const outlines = {\n    free: true,\n    box: { x: 0, y: 0, width: 100, height: 100 },\n    toSVGPath() {\n      return \"M0,0 L100,0 L100,100 L0,100 Z\";\n    }\n  };\n  drawLayer.highlightOutline(outlines);\n  DrawLayer._svgFactory.createElement = originalCreateElement;\n  if (!freeUse || !freeUse.classList.contains(\"mask\")) {\n    throw new Error(\"Expected the free highlight mask use element to have 'mask' class.\");\n  }\n});\n",
    "i3_gpt-4o": "it(\"should add mask class to the free highlight mask use element\", async () => {\n  const { DrawLayer } = await import(\"../../src/display/draw_layer.js\");\n  const originalCreateElement = DrawLayer._svgFactory.createElement;\n  let useCount = 0;\n  let freeUse = null;\n  let svgCreated = null;\n  DrawLayer._svgFactory.createElement = function(type) {\n    if (type === \"svg\") {\n      svgCreated = document.createElementNS(\"http://www.w3.org/2000/svg\", \"svg\");\n      return svgCreated;\n    }\n    const el = originalCreateElement.call(this, type);\n    if (type === \"use\") {\n      if (useCount === 0) {\n        freeUse = el;\n      }\n      useCount++;\n    }\n    return el;\n  };\n  const drawLayer = new DrawLayer({ pageIndex: 0 });\n  const outlines = {\n    free: true,\n    box: { x: 0, y: 0, width: 100, height: 100 },\n    toSVGPath() {\n      return \"M0,0 L100,0 L100,100 L0,100 Z\";\n    }\n  };\n  drawLayer.highlightOutline(outlines);\n  DrawLayer._svgFactory.createElement = originalCreateElement;\n  if (!freeUse || !freeUse.classList.contains(\"mask\")) {\n    throw new Error(\"Expected the free highlight mask use element to have 'mask' class.\");\n  }\n});\n",
    "i3_llama-3.3-70b-versatile": "it(\"should add mask class to the free highlight mask use element\", async () => {\n  const { DrawLayer } = await import(\"../../src/display/draw_layer.js\");\n  const originalCreateElement = DrawLayer._svgFactory.createElement;\n  let useCount = 0;\n  let freeUse = null;\n  let svgCreated = null;\n  DrawLayer._svgFactory.createElement = function(type) {\n    if (type === \"svg\") {\n      svgCreated = document.createElementNS(\"http://www.w3.org/2000/svg\", \"svg\");\n      return svgCreated;\n    }\n    const el = originalCreateElement.call(this, type);\n    if (type === \"use\") {\n      if (useCount === 0) {\n        freeUse = el;\n      }\n      useCount++;\n    }\n    return el;\n  };\n  const drawLayer = new DrawLayer({ pageIndex: 0 });\n  const outlines = {\n    free: true,\n    box: { x: 0, y: 0, width: 100, height: 100 },\n    toSVGPath() {\n      return \"M0,0 L100,0 L100,100 L0,100 Z\";\n    }\n  };\n  drawLayer.highlightOutline(outlines);\n  DrawLayer._svgFactory.createElement = originalCreateElement;\n  if (!freeUse || !freeUse.classList.contains(\"mask\")) {\n    throw new Error(\"Expected the free highlight mask use element to have 'mask' class.\");\n  }\n});\n",
    "i4_deepseek-r1-distill-llama-70b": "it(\"should add mask class to the free highlight mask use element\", async () => {\n  const { DrawLayer } = await import(\"../../src/display/draw_layer.js\");\n  const originalCreateElement = DrawLayer._svgFactory.createElement;\n  let useCount = 0;\n  let freeUse = null;\n  let svgCreated = null;\n  DrawLayer._svgFactory.createElement = function(type) {\n    if (type === \"svg\") {\n      svgCreated = document.createElementNS(\"http://www.w3.org/2000/svg\", \"svg\");\n      return svgCreated;\n    }\n    const el = originalCreateElement.call(this, type);\n    if (type === \"use\") {\n      if (useCount === 0) {\n        freeUse = el;\n      }\n      useCount++;\n    }\n    return el;\n  };\n  const drawLayer = new DrawLayer({ pageIndex: 0 });\n  const outlines = {\n    free: true,\n    box: { x: 0, y: 0, width: 100, height: 100 },\n    toSVGPath() {\n      return \"M0,0 L100,0 L100,100 L0,100 Z\";\n    }\n  };\n  drawLayer.highlightOutline(outlines);\n  DrawLayer._svgFactory.createElement = originalCreateElement;\n  if (!freeUse || !freeUse.classList.contains(\"mask\")) {\n    throw new Error(\"Expected the free highlight mask use element to have 'mask' class.\");\n  }\n});\n",
    "i4_gpt-4o": "it(\"should add mask class to the free highlight mask use element\", async () => {\n  const { DrawLayer } = await import(\"../../src/display/draw_layer.js\");\n  const originalCreateElement = DrawLayer._svgFactory.createElement;\n  let useCount = 0;\n  let freeUse = null;\n  let svgCreated = null;\n  DrawLayer._svgFactory.createElement = function(type) {\n    if (type === \"svg\") {\n      svgCreated = document.createElementNS(\"http://www.w3.org/2000/svg\", \"svg\");\n      return svgCreated;\n    }\n    const el = originalCreateElement.call(this, type);\n    if (type === \"use\") {\n      if (useCount === 0) {\n        freeUse = el;\n      }\n      useCount++;\n    }\n    return el;\n  };\n  const drawLayer = new DrawLayer({ pageIndex: 0 });\n  const outlines = {\n    free: true,\n    box: { x: 0, y: 0, width: 100, height: 100 },\n    toSVGPath() {\n      return \"M0,0 L100,0 L100,100 L0,100 Z\";\n    }\n  };\n  drawLayer.highlightOutline(outlines);\n  DrawLayer._svgFactory.createElement = originalCreateElement;\n  if (!freeUse || !freeUse.classList.contains(\"mask\")) {\n    throw new Error(\"Expected the free highlight mask use element to have 'mask' class.\");\n  }\n});\n",
    "i4_llama-3.3-70b-versatile": "it(\"should add mask class to the free highlight mask use element\", async () => {\n  const { DrawLayer } = await import(\"../../src/display/draw_layer.js\");\n  const originalCreateElement = DrawLayer._svgFactory.createElement;\n  let useCount = 0;\n  let freeUse = null;\n  let svgCreated = null;\n  DrawLayer._svgFactory.createElement = function(type) {\n    if (type === \"svg\") {\n      svgCreated = document.createElementNS(\"http://www.w3.org/2000/svg\", \"svg\");\n      return svgCreated;\n    }\n    const el = originalCreateElement.call(this, type);\n    if (type === \"use\") {\n      if (useCount === 0) {\n        freeUse = el;\n      }\n      useCount++;\n    }\n    return el;\n  };\n  const drawLayer = new DrawLayer({ pageIndex: 0 });\n  const outlines = {\n    free: true,\n    box: { x: 0, y: 0, width: 100, height: 100 },\n    toSVGPath() {\n      return \"M0,0 L100,0 L100,100 L0,100 Z\";\n    }\n  };\n  drawLayer.highlightOutline(outlines);\n  DrawLayer._svgFactory.createElement = originalCreateElement;\n  if (!freeUse || !freeUse.classList.contains(\"mask\")) {\n    throw new Error(\"Expected the free highlight mask use element to have 'mask' class.\");\n  }\n});\n",
    "i5_deepseek-r1-distill-llama-70b": "it(\"should add mask class to the free highlight mask use element\", async () => {\n  const { DrawLayer } = await import(\"../../src/display/draw_layer.js\");\n  const originalCreateElement = DrawLayer._svgFactory.createElement;\n  let useCount = 0;\n  let freeUse = null;\n  let svgCreated = null;\n  DrawLayer._svgFactory.createElement = function(type) {\n    if (type === \"svg\") {\n      svgCreated = document.createElementNS(\"http://www.w3.org/2000/svg\", \"svg\");\n      return svgCreated;\n    }\n    const el = originalCreateElement.call(this, type);\n    if (type === \"use\") {\n      if (useCount === 0) {\n        freeUse = el;\n      }\n      useCount++;\n    }\n    return el;\n  };\n  const drawLayer = new DrawLayer({ pageIndex: 0 });\n  const outlines = {\n    free: true,\n    box: { x: 0, y: 0, width: 100, height: 100 },\n    toSVGPath() {\n      return \"M0,0 L100,0 L100,100 L0,100 Z\";\n    }\n  };\n  drawLayer.highlightOutline(outlines);\n  DrawLayer._svgFactory.createElement = originalCreateElement;\n  if (!freeUse || !freeUse.classList.contains(\"mask\")) {\n    throw new Error(\"Expected the free highlight mask use element to have 'mask' class.\");\n  }\n});\n",
    "i5_gpt-4o": "it(\"should add mask class to the free highlight mask use element\", async () => {\n  const { DrawLayer } = await import(\"../../src/display/draw_layer.js\");\n  const originalCreateElement = DrawLayer._svgFactory.createElement;\n  let useCount = 0;\n  let freeUse = null;\n  let svgCreated = null;\n  DrawLayer._svgFactory.createElement = function(type) {\n    if (type === \"svg\") {\n      svgCreated = document.createElementNS(\"http://www.w3.org/2000/svg\", \"svg\");\n      return svgCreated;\n    }\n    const el = originalCreateElement.call(this, type);\n    if (type === \"use\") {\n      if (useCount === 0) {\n        freeUse = el;\n      }\n      useCount++;\n    }\n    return el;\n  };\n  const drawLayer = new DrawLayer({ pageIndex: 0 });\n  const outlines = {\n    free: true,\n    box: { x: 0, y: 0, width: 100, height: 100 },\n    toSVGPath() {\n      return \"M0,0 L100,0 L100,100 L0,100 Z\";\n    }\n  };\n  drawLayer.highlightOutline(outlines);\n  DrawLayer._svgFactory.createElement = originalCreateElement;\n  if (!freeUse || !freeUse.classList.contains(\"mask\")) {\n    throw new Error(\"Expected the free highlight mask use element to have 'mask' class.\");\n  }\n});\n",
    "i5_llama-3.3-70b-versatile": "it(\"should add mask class to the free highlight mask use element\", async () => {\n  const { DrawLayer } = await import(\"../../src/display/draw_layer.js\");\n  const originalCreateElement = DrawLayer._svgFactory.createElement;\n  let useCount = 0;\n  let freeUse = null;\n  let svgCreated = null;\n  DrawLayer._svgFactory.createElement = function(type) {\n    if (type === \"svg\") {\n      svgCreated = document.createElementNS(\"http://www.w3.org/2000/svg\", \"svg\");\n      return svgCreated;\n    }\n    const el = originalCreateElement.call(this, type);\n    if (type === \"use\") {\n      if (useCount === 0) {\n        freeUse = el;\n      }\n      useCount++;\n    }\n    return el;\n  };\n  const drawLayer = new DrawLayer({ pageIndex: 0 });\n  const outlines = {\n    free: true,\n    box: { x: 0, y: 0, width: 100, height: 100 },\n    toSVGPath() {\n      return \"M0,0 L100,0 L100,100 L0,100 Z\";\n    }\n  };\n  drawLayer.highlightOutline(outlines);\n  DrawLayer._svgFactory.createElement = originalCreateElement;\n  if (!freeUse || !freeUse.classList.contains(\"mask\")) {\n    throw new Error(\"Expected the free highlight mask use element to have 'mask' class.\");\n  }\n});\n"
  },
  "17643": {
    "i1_deepseek-r1-distill-llama-70b": "it(\"should compute correct lastPoint for free highlight in a rotated PDF\", async () => {\n  const { HighlightEditor } = await import(\"../../src/display/editor/highlight.js\");\n  const { getSerialized } = await import(\"./test_utils.js\");\n  const fakeDrawLayer = {\n    finalizeLine: () => {},\n    highlightOutline: () => 1,\n    updateLine: () => {}\n  };\n  const fakeParent = { drawLayer: fakeDrawLayer };\n  const fakeOutlines = {\n    box: { x: 0.1, y: 0.2, width: 0.3, height: 0.4, lastPoint: [0.4, 0.5] },\n    getNewOutline: (thickness, innerMargin) => ({\n      box: { x: 0.1, y: 0.2, width: 0.3, height: 0.4, lastPoint: [0.4, 0.5] }\n    })\n  };\n  const params = {\n    highlightId: 1,\n    highlightOutlines: fakeOutlines,\n    clipPathId: \"clip1\",\n    thickness: 12,\n    color: \"#FF0\",\n    opacity: 1,\n    boxes: null\n  };\n  const editor = new HighlightEditor(params);\n  editor.parent = fakeParent;\n  // Set rotation to 90\u00b0 and simulate page dimensions of 1x1.\n  editor.rotation = 90;\n  editor.parentDimensions = [1, 1];\n  // Force re-calculation if needed by invoking rotate (if available).\n  if (typeof editor.rotate === \"function\") {\n    editor.rotate(90);\n  }\n  const serialized = getSerialized(editor);\n  // The expected lastPoint is computed relative to the original box coordinates:\n  // expected = [ (0.4 - 0.1) / 0.3, (0.5 - 0.2) / 0.4 ] = [1, 0.75 ]\n  chai.assert.approximately(serialized.lastPoint[0], 1, 1e-4);\n  chai.assert.approximately(serialized.lastPoint[1], 0.75, 1e-4);\n});",
    "i1_gpt-4o": "it(\"should compute correct lastPoint for free highlight in a rotated PDF\", async () => {\n  const { HighlightEditor } = await import(\"../../src/display/editor/highlight.js\");\n  const { getSerialized } = await import(\"./test_utils.js\");\n  const fakeDrawLayer = {\n    finalizeLine: () => {},\n    highlightOutline: () => 1,\n    updateLine: () => {}\n  };\n  const fakeParent = { drawLayer: fakeDrawLayer };\n  const fakeOutlines = {\n    box: { x: 0.1, y: 0.2, width: 0.3, height: 0.4, lastPoint: [0.4, 0.5] },\n    getNewOutline: (thickness, innerMargin) => ({\n      box: { x: 0.1, y: 0.2, width: 0.3, height: 0.4, lastPoint: [0.4, 0.5] }\n    })\n  };\n  const params = {\n    highlightId: 1,\n    highlightOutlines: fakeOutlines,\n    clipPathId: \"clip1\",\n    thickness: 12,\n    color: \"#FF0\",\n    opacity: 1,\n    boxes: null\n  };\n  const editor = new HighlightEditor(params);\n  editor.parent = fakeParent;\n  // Set rotation to 90\u00b0 and simulate page dimensions of 1x1.\n  editor.rotation = 90;\n  editor.parentDimensions = [1, 1];\n  // Force re-calculation if needed by invoking rotate (if available).\n  if (typeof editor.rotate === \"function\") {\n    editor.rotate(90);\n  }\n  const serialized = getSerialized(editor);\n  // The expected lastPoint is computed relative to the original box coordinates:\n  // expected = [ (0.4 - 0.1) / 0.3, (0.5 - 0.2) / 0.4 ] = [1, 0.75 ]\n  chai.assert.approximately(serialized.lastPoint[0], 1, 1e-4);\n  chai.assert.approximately(serialized.lastPoint[1], 0.75, 1e-4);\n});",
    "i1_llama-3.3-70b-versatile": "it(\"should compute correct lastPoint for free highlight in a rotated PDF\", async () => {\n  const { HighlightEditor } = await import(\"../../src/display/editor/highlight.js\");\n  const { getSerialized } = await import(\"./test_utils.js\");\n  const fakeDrawLayer = {\n    finalizeLine: () => {},\n    highlightOutline: () => 1,\n    updateLine: () => {}\n  };\n  const fakeParent = { drawLayer: fakeDrawLayer };\n  const fakeOutlines = {\n    box: { x: 0.1, y: 0.2, width: 0.3, height: 0.4, lastPoint: [0.4, 0.5] },\n    getNewOutline: (thickness, innerMargin) => ({\n      box: { x: 0.1, y: 0.2, width: 0.3, height: 0.4, lastPoint: [0.4, 0.5] }\n    })\n  };\n  const params = {\n    highlightId: 1,\n    highlightOutlines: fakeOutlines,\n    clipPathId: \"clip1\",\n    thickness: 12,\n    color: \"#FF0\",\n    opacity: 1,\n    boxes: null\n  };\n  const editor = new HighlightEditor(params);\n  editor.parent = fakeParent;\n  // Set rotation to 90\u00b0 and simulate page dimensions of 1x1.\n  editor.rotation = 90;\n  editor.parentDimensions = [1, 1];\n  // Force re-calculation if needed by invoking rotate (if available).\n  if (typeof editor.rotate === \"function\") {\n    editor.rotate(90);\n  }\n  const serialized = getSerialized(editor);\n  // The expected lastPoint is computed relative to the original box coordinates:\n  // expected = [ (0.4 - 0.1) / 0.3, (0.5 - 0.2) / 0.4 ] = [1, 0.75 ]\n  chai.assert.approximately(serialized.lastPoint[0], 1, 1e-4);\n  chai.assert.approximately(serialized.lastPoint[1], 0.75, 1e-4);\n});",
    "i1_MOCK": "it(\"should compute correct lastPoint for free highlight in a rotated PDF\", async () => {\n  const { HighlightEditor } = await import(\"../../src/display/editor/highlight.js\");\n  const { getSerialized } = await import(\"./test_utils.js\");\n  const fakeDrawLayer = {\n    finalizeLine: () => {},\n    highlightOutline: () => 1,\n    updateLine: () => {}\n  };\n  const fakeParent = { drawLayer: fakeDrawLayer };\n  const fakeOutlines = {\n    box: { x: 0.1, y: 0.2, width: 0.3, height: 0.4, lastPoint: [0.4, 0.5] },\n    getNewOutline: (thickness, innerMargin) => ({\n      box: { x: 0.1, y: 0.2, width: 0.3, height: 0.4, lastPoint: [0.4, 0.5] }\n    })\n  };\n  const params = {\n    highlightId: 1,\n    highlightOutlines: fakeOutlines,\n    clipPathId: \"clip1\",\n    thickness: 12,\n    color: \"#FF0\",\n    opacity: 1,\n    boxes: null\n  };\n  const editor = new HighlightEditor(params);\n  editor.parent = fakeParent;\n  // Set rotation to 90\u00b0 and simulate page dimensions of 1x1.\n  editor.rotation = 90;\n  editor.parentDimensions = [1, 1];\n  // Force re-calculation if needed by invoking rotate (if available).\n  if (typeof editor.rotate === \"function\") {\n    editor.rotate(90);\n  }\n  const serialized = getSerialized(editor);\n  // The expected lastPoint is computed relative to the original box coordinates:\n  // expected = [ (0.4 - 0.1) / 0.3, (0.5 - 0.2) / 0.4 ] = [1, 0.75 ]\n  chai.assert.approximately(serialized.lastPoint[0], 1, 1e-4);\n  chai.assert.approximately(serialized.lastPoint[1], 0.75, 1e-4);\n});",
    "i2_deepseek-r1-distill-llama-70b": "it(\"should compute correct lastPoint for free highlight in a rotated PDF\", async () => {\n  const { HighlightEditor } = await import(\"../../src/display/editor/highlight.js\");\n  const { getSerialized } = await import(\"./test_utils.js\");\n  const fakeDrawLayer = {\n    finalizeLine: () => {},\n    highlightOutline: () => 1,\n    updateLine: () => {}\n  };\n  const fakeParent = { drawLayer: fakeDrawLayer };\n  const fakeOutlines = {\n    box: { x: 0.1, y: 0.2, width: 0.3, height: 0.4, lastPoint: [0.4, 0.5] },\n    getNewOutline: (thickness, innerMargin) => ({\n      box: { x: 0.1, y: 0.2, width: 0.3, height: 0.4, lastPoint: [0.4, 0.5] }\n    })\n  };\n  const params = {\n    highlightId: 1,\n    highlightOutlines: fakeOutlines,\n    clipPathId: \"clip1\",\n    thickness: 12,\n    color: \"#FF0\",\n    opacity: 1,\n    boxes: null\n  };\n  const editor = new HighlightEditor(params);\n  editor.parent = fakeParent;\n  // Set rotation to 90\u00b0 and simulate page dimensions of 1x1.\n  editor.rotation = 90;\n  editor.parentDimensions = [1, 1];\n  // Force re-calculation if needed by invoking rotate (if available).\n  if (typeof editor.rotate === \"function\") {\n    editor.rotate(90);\n  }\n  const serialized = getSerialized(editor);\n  // The expected lastPoint is computed relative to the original box coordinates:\n  // expected = [ (0.4 - 0.1) / 0.3, (0.5 - 0.2) / 0.4 ] = [1, 0.75 ]\n  chai.assert.approximately(serialized.lastPoint[0], 1, 1e-4);\n  chai.assert.approximately(serialized.lastPoint[1], 0.75, 1e-4);\n});",
    "i2_gpt-4o": "it(\"should compute correct lastPoint for free highlight in a rotated PDF\", async () => {\n  const { HighlightEditor } = await import(\"../../src/display/editor/highlight.js\");\n  const { getSerialized } = await import(\"./test_utils.js\");\n  const fakeDrawLayer = {\n    finalizeLine: () => {},\n    highlightOutline: () => 1,\n    updateLine: () => {}\n  };\n  const fakeParent = { drawLayer: fakeDrawLayer };\n  const fakeOutlines = {\n    box: { x: 0.1, y: 0.2, width: 0.3, height: 0.4, lastPoint: [0.4, 0.5] },\n    getNewOutline: (thickness, innerMargin) => ({\n      box: { x: 0.1, y: 0.2, width: 0.3, height: 0.4, lastPoint: [0.4, 0.5] }\n    })\n  };\n  const params = {\n    highlightId: 1,\n    highlightOutlines: fakeOutlines,\n    clipPathId: \"clip1\",\n    thickness: 12,\n    color: \"#FF0\",\n    opacity: 1,\n    boxes: null\n  };\n  const editor = new HighlightEditor(params);\n  editor.parent = fakeParent;\n  // Set rotation to 90\u00b0 and simulate page dimensions of 1x1.\n  editor.rotation = 90;\n  editor.parentDimensions = [1, 1];\n  // Force re-calculation if needed by invoking rotate (if available).\n  if (typeof editor.rotate === \"function\") {\n    editor.rotate(90);\n  }\n  const serialized = getSerialized(editor);\n  // The expected lastPoint is computed relative to the original box coordinates:\n  // expected = [ (0.4 - 0.1) / 0.3, (0.5 - 0.2) / 0.4 ] = [1, 0.75 ]\n  chai.assert.approximately(serialized.lastPoint[0], 1, 1e-4);\n  chai.assert.approximately(serialized.lastPoint[1], 0.75, 1e-4);\n});",
    "i2_llama-3.3-70b-versatile": "it(\"should compute correct lastPoint for free highlight in a rotated PDF\", async () => {\n  const { HighlightEditor } = await import(\"../../src/display/editor/highlight.js\");\n  const { getSerialized } = await import(\"./test_utils.js\");\n  const fakeDrawLayer = {\n    finalizeLine: () => {},\n    highlightOutline: () => 1,\n    updateLine: () => {}\n  };\n  const fakeParent = { drawLayer: fakeDrawLayer };\n  const fakeOutlines = {\n    box: { x: 0.1, y: 0.2, width: 0.3, height: 0.4, lastPoint: [0.4, 0.5] },\n    getNewOutline: (thickness, innerMargin) => ({\n      box: { x: 0.1, y: 0.2, width: 0.3, height: 0.4, lastPoint: [0.4, 0.5] }\n    })\n  };\n  const params = {\n    highlightId: 1,\n    highlightOutlines: fakeOutlines,\n    clipPathId: \"clip1\",\n    thickness: 12,\n    color: \"#FF0\",\n    opacity: 1,\n    boxes: null\n  };\n  const editor = new HighlightEditor(params);\n  editor.parent = fakeParent;\n  // Set rotation to 90\u00b0 and simulate page dimensions of 1x1.\n  editor.rotation = 90;\n  editor.parentDimensions = [1, 1];\n  // Force re-calculation if needed by invoking rotate (if available).\n  if (typeof editor.rotate === \"function\") {\n    editor.rotate(90);\n  }\n  const serialized = getSerialized(editor);\n  // The expected lastPoint is computed relative to the original box coordinates:\n  // expected = [ (0.4 - 0.1) / 0.3, (0.5 - 0.2) / 0.4 ] = [1, 0.75 ]\n  chai.assert.approximately(serialized.lastPoint[0], 1, 1e-4);\n  chai.assert.approximately(serialized.lastPoint[1], 0.75, 1e-4);\n});",
    "i3_deepseek-r1-distill-llama-70b": "it(\"should compute correct lastPoint for free highlight in a rotated PDF\", async () => {\n  const { HighlightEditor } = await import(\"../../src/display/editor/highlight.js\");\n  const { getSerialized } = await import(\"./test_utils.js\");\n  const fakeDrawLayer = {\n    finalizeLine: () => {},\n    highlightOutline: () => 1,\n    updateLine: () => {}\n  };\n  const fakeParent = { drawLayer: fakeDrawLayer };\n  const fakeOutlines = {\n    box: { x: 0.1, y: 0.2, width: 0.3, height: 0.4, lastPoint: [0.4, 0.5] },\n    getNewOutline: (thickness, innerMargin) => ({\n      box: { x: 0.1, y: 0.2, width: 0.3, height: 0.4, lastPoint: [0.4, 0.5] }\n    })\n  };\n  const params = {\n    highlightId: 1,\n    highlightOutlines: fakeOutlines,\n    clipPathId: \"clip1\",\n    thickness: 12,\n    color: \"#FF0\",\n    opacity: 1,\n    boxes: null\n  };\n  const editor = new HighlightEditor(params);\n  editor.parent = fakeParent;\n  // Set rotation to 90\u00b0 and simulate page dimensions of 1x1.\n  editor.rotation = 90;\n  editor.parentDimensions = [1, 1];\n  // Force re-calculation if needed by invoking rotate (if available).\n  if (typeof editor.rotate === \"function\") {\n    editor.rotate(90);\n  }\n  const serialized = getSerialized(editor);\n  // The expected lastPoint is computed relative to the original box coordinates:\n  // expected = [ (0.4 - 0.1) / 0.3, (0.5 - 0.2) / 0.4 ] = [1, 0.75 ]\n  chai.assert.approximately(serialized.lastPoint[0], 1, 1e-4);\n  chai.assert.approximately(serialized.lastPoint[1], 0.75, 1e-4);\n});",
    "i3_gpt-4o": "it(\"should compute correct lastPoint for free highlight in a rotated PDF\", async () => {\n  const { HighlightEditor } = await import(\"../../src/display/editor/highlight.js\");\n  const { getSerialized } = await import(\"./test_utils.js\");\n  const fakeDrawLayer = {\n    finalizeLine: () => {},\n    highlightOutline: () => 1,\n    updateLine: () => {}\n  };\n  const fakeParent = { drawLayer: fakeDrawLayer };\n  const fakeOutlines = {\n    box: { x: 0.1, y: 0.2, width: 0.3, height: 0.4, lastPoint: [0.4, 0.5] },\n    getNewOutline: (thickness, innerMargin) => ({\n      box: { x: 0.1, y: 0.2, width: 0.3, height: 0.4, lastPoint: [0.4, 0.5] }\n    })\n  };\n  const params = {\n    highlightId: 1,\n    highlightOutlines: fakeOutlines,\n    clipPathId: \"clip1\",\n    thickness: 12,\n    color: \"#FF0\",\n    opacity: 1,\n    boxes: null\n  };\n  const editor = new HighlightEditor(params);\n  editor.parent = fakeParent;\n  // Set rotation to 90\u00b0 and simulate page dimensions of 1x1.\n  editor.rotation = 90;\n  editor.parentDimensions = [1, 1];\n  // Force re-calculation if needed by invoking rotate (if available).\n  if (typeof editor.rotate === \"function\") {\n    editor.rotate(90);\n  }\n  const serialized = getSerialized(editor);\n  // The expected lastPoint is computed relative to the original box coordinates:\n  // expected = [ (0.4 - 0.1) / 0.3, (0.5 - 0.2) / 0.4 ] = [1, 0.75 ]\n  chai.assert.approximately(serialized.lastPoint[0], 1, 1e-4);\n  chai.assert.approximately(serialized.lastPoint[1], 0.75, 1e-4);\n});",
    "i3_llama-3.3-70b-versatile": "it(\"should compute correct lastPoint for free highlight in a rotated PDF\", async () => {\n  const { HighlightEditor } = await import(\"../../src/display/editor/highlight.js\");\n  const { getSerialized } = await import(\"./test_utils.js\");\n  const fakeDrawLayer = {\n    finalizeLine: () => {},\n    highlightOutline: () => 1,\n    updateLine: () => {}\n  };\n  const fakeParent = { drawLayer: fakeDrawLayer };\n  const fakeOutlines = {\n    box: { x: 0.1, y: 0.2, width: 0.3, height: 0.4, lastPoint: [0.4, 0.5] },\n    getNewOutline: (thickness, innerMargin) => ({\n      box: { x: 0.1, y: 0.2, width: 0.3, height: 0.4, lastPoint: [0.4, 0.5] }\n    })\n  };\n  const params = {\n    highlightId: 1,\n    highlightOutlines: fakeOutlines,\n    clipPathId: \"clip1\",\n    thickness: 12,\n    color: \"#FF0\",\n    opacity: 1,\n    boxes: null\n  };\n  const editor = new HighlightEditor(params);\n  editor.parent = fakeParent;\n  // Set rotation to 90\u00b0 and simulate page dimensions of 1x1.\n  editor.rotation = 90;\n  editor.parentDimensions = [1, 1];\n  // Force re-calculation if needed by invoking rotate (if available).\n  if (typeof editor.rotate === \"function\") {\n    editor.rotate(90);\n  }\n  const serialized = getSerialized(editor);\n  // The expected lastPoint is computed relative to the original box coordinates:\n  // expected = [ (0.4 - 0.1) / 0.3, (0.5 - 0.2) / 0.4 ] = [1, 0.75 ]\n  chai.assert.approximately(serialized.lastPoint[0], 1, 1e-4);\n  chai.assert.approximately(serialized.lastPoint[1], 0.75, 1e-4);\n});",
    "i4_deepseek-r1-distill-llama-70b": "it(\"should compute correct lastPoint for free highlight in a rotated PDF\", async () => {\n  const { HighlightEditor } = await import(\"../../src/display/editor/highlight.js\");\n  const { getSerialized } = await import(\"./test_utils.js\");\n  const fakeDrawLayer = {\n    finalizeLine: () => {},\n    highlightOutline: () => 1,\n    updateLine: () => {}\n  };\n  const fakeParent = { drawLayer: fakeDrawLayer };\n  const fakeOutlines = {\n    box: { x: 0.1, y: 0.2, width: 0.3, height: 0.4, lastPoint: [0.4, 0.5] },\n    getNewOutline: (thickness, innerMargin) => ({\n      box: { x: 0.1, y: 0.2, width: 0.3, height: 0.4, lastPoint: [0.4, 0.5] }\n    })\n  };\n  const params = {\n    highlightId: 1,\n    highlightOutlines: fakeOutlines,\n    clipPathId: \"clip1\",\n    thickness: 12,\n    color: \"#FF0\",\n    opacity: 1,\n    boxes: null\n  };\n  const editor = new HighlightEditor(params);\n  editor.parent = fakeParent;\n  // Set rotation to 90\u00b0 and simulate page dimensions of 1x1.\n  editor.rotation = 90;\n  editor.parentDimensions = [1, 1];\n  // Force re-calculation if needed by invoking rotate (if available).\n  if (typeof editor.rotate === \"function\") {\n    editor.rotate(90);\n  }\n  const serialized = getSerialized(editor);\n  // The expected lastPoint is computed relative to the original box coordinates:\n  // expected = [ (0.4 - 0.1) / 0.3, (0.5 - 0.2) / 0.4 ] = [1, 0.75 ]\n  chai.assert.approximately(serialized.lastPoint[0], 1, 1e-4);\n  chai.assert.approximately(serialized.lastPoint[1], 0.75, 1e-4);\n});",
    "i4_gpt-4o": "it(\"should compute correct lastPoint for free highlight in a rotated PDF\", async () => {\n  const { HighlightEditor } = await import(\"../../src/display/editor/highlight.js\");\n  const { getSerialized } = await import(\"./test_utils.js\");\n  const fakeDrawLayer = {\n    finalizeLine: () => {},\n    highlightOutline: () => 1,\n    updateLine: () => {}\n  };\n  const fakeParent = { drawLayer: fakeDrawLayer };\n  const fakeOutlines = {\n    box: { x: 0.1, y: 0.2, width: 0.3, height: 0.4, lastPoint: [0.4, 0.5] },\n    getNewOutline: (thickness, innerMargin) => ({\n      box: { x: 0.1, y: 0.2, width: 0.3, height: 0.4, lastPoint: [0.4, 0.5] }\n    })\n  };\n  const params = {\n    highlightId: 1,\n    highlightOutlines: fakeOutlines,\n    clipPathId: \"clip1\",\n    thickness: 12,\n    color: \"#FF0\",\n    opacity: 1,\n    boxes: null\n  };\n  const editor = new HighlightEditor(params);\n  editor.parent = fakeParent;\n  // Set rotation to 90\u00b0 and simulate page dimensions of 1x1.\n  editor.rotation = 90;\n  editor.parentDimensions = [1, 1];\n  // Force re-calculation if needed by invoking rotate (if available).\n  if (typeof editor.rotate === \"function\") {\n    editor.rotate(90);\n  }\n  const serialized = getSerialized(editor);\n  // The expected lastPoint is computed relative to the original box coordinates:\n  // expected = [ (0.4 - 0.1) / 0.3, (0.5 - 0.2) / 0.4 ] = [1, 0.75 ]\n  chai.assert.approximately(serialized.lastPoint[0], 1, 1e-4);\n  chai.assert.approximately(serialized.lastPoint[1], 0.75, 1e-4);\n});",
    "i4_llama-3.3-70b-versatile": "it(\"should compute correct lastPoint for free highlight in a rotated PDF\", async () => {\n  const { HighlightEditor } = await import(\"../../src/display/editor/highlight.js\");\n  const { getSerialized } = await import(\"./test_utils.js\");\n  const fakeDrawLayer = {\n    finalizeLine: () => {},\n    highlightOutline: () => 1,\n    updateLine: () => {}\n  };\n  const fakeParent = { drawLayer: fakeDrawLayer };\n  const fakeOutlines = {\n    box: { x: 0.1, y: 0.2, width: 0.3, height: 0.4, lastPoint: [0.4, 0.5] },\n    getNewOutline: (thickness, innerMargin) => ({\n      box: { x: 0.1, y: 0.2, width: 0.3, height: 0.4, lastPoint: [0.4, 0.5] }\n    })\n  };\n  const params = {\n    highlightId: 1,\n    highlightOutlines: fakeOutlines,\n    clipPathId: \"clip1\",\n    thickness: 12,\n    color: \"#FF0\",\n    opacity: 1,\n    boxes: null\n  };\n  const editor = new HighlightEditor(params);\n  editor.parent = fakeParent;\n  // Set rotation to 90\u00b0 and simulate page dimensions of 1x1.\n  editor.rotation = 90;\n  editor.parentDimensions = [1, 1];\n  // Force re-calculation if needed by invoking rotate (if available).\n  if (typeof editor.rotate === \"function\") {\n    editor.rotate(90);\n  }\n  const serialized = getSerialized(editor);\n  // The expected lastPoint is computed relative to the original box coordinates:\n  // expected = [ (0.4 - 0.1) / 0.3, (0.5 - 0.2) / 0.4 ] = [1, 0.75 ]\n  chai.assert.approximately(serialized.lastPoint[0], 1, 1e-4);\n  chai.assert.approximately(serialized.lastPoint[1], 0.75, 1e-4);\n});",
    "i5_deepseek-r1-distill-llama-70b": "it(\"should compute correct lastPoint for free highlight in a rotated PDF\", async () => {\n  const { HighlightEditor } = await import(\"../../src/display/editor/highlight.js\");\n  const { getSerialized } = await import(\"./test_utils.js\");\n  const fakeDrawLayer = {\n    finalizeLine: () => {},\n    highlightOutline: () => 1,\n    updateLine: () => {}\n  };\n  const fakeParent = { drawLayer: fakeDrawLayer };\n  const fakeOutlines = {\n    box: { x: 0.1, y: 0.2, width: 0.3, height: 0.4, lastPoint: [0.4, 0.5] },\n    getNewOutline: (thickness, innerMargin) => ({\n      box: { x: 0.1, y: 0.2, width: 0.3, height: 0.4, lastPoint: [0.4, 0.5] }\n    })\n  };\n  const params = {\n    highlightId: 1,\n    highlightOutlines: fakeOutlines,\n    clipPathId: \"clip1\",\n    thickness: 12,\n    color: \"#FF0\",\n    opacity: 1,\n    boxes: null\n  };\n  const editor = new HighlightEditor(params);\n  editor.parent = fakeParent;\n  // Set rotation to 90\u00b0 and simulate page dimensions of 1x1.\n  editor.rotation = 90;\n  editor.parentDimensions = [1, 1];\n  // Force re-calculation if needed by invoking rotate (if available).\n  if (typeof editor.rotate === \"function\") {\n    editor.rotate(90);\n  }\n  const serialized = getSerialized(editor);\n  // The expected lastPoint is computed relative to the original box coordinates:\n  // expected = [ (0.4 - 0.1) / 0.3, (0.5 - 0.2) / 0.4 ] = [1, 0.75 ]\n  chai.assert.approximately(serialized.lastPoint[0], 1, 1e-4);\n  chai.assert.approximately(serialized.lastPoint[1], 0.75, 1e-4);\n});",
    "i5_gpt-4o": "it(\"should compute correct lastPoint for free highlight in a rotated PDF\", async () => {\n  const { HighlightEditor } = await import(\"../../src/display/editor/highlight.js\");\n  const { getSerialized } = await import(\"./test_utils.js\");\n  const fakeDrawLayer = {\n    finalizeLine: () => {},\n    highlightOutline: () => 1,\n    updateLine: () => {}\n  };\n  const fakeParent = { drawLayer: fakeDrawLayer };\n  const fakeOutlines = {\n    box: { x: 0.1, y: 0.2, width: 0.3, height: 0.4, lastPoint: [0.4, 0.5] },\n    getNewOutline: (thickness, innerMargin) => ({\n      box: { x: 0.1, y: 0.2, width: 0.3, height: 0.4, lastPoint: [0.4, 0.5] }\n    })\n  };\n  const params = {\n    highlightId: 1,\n    highlightOutlines: fakeOutlines,\n    clipPathId: \"clip1\",\n    thickness: 12,\n    color: \"#FF0\",\n    opacity: 1,\n    boxes: null\n  };\n  const editor = new HighlightEditor(params);\n  editor.parent = fakeParent;\n  // Set rotation to 90\u00b0 and simulate page dimensions of 1x1.\n  editor.rotation = 90;\n  editor.parentDimensions = [1, 1];\n  // Force re-calculation if needed by invoking rotate (if available).\n  if (typeof editor.rotate === \"function\") {\n    editor.rotate(90);\n  }\n  const serialized = getSerialized(editor);\n  // The expected lastPoint is computed relative to the original box coordinates:\n  // expected = [ (0.4 - 0.1) / 0.3, (0.5 - 0.2) / 0.4 ] = [1, 0.75 ]\n  chai.assert.approximately(serialized.lastPoint[0], 1, 1e-4);\n  chai.assert.approximately(serialized.lastPoint[1], 0.75, 1e-4);\n});",
    "i5_llama-3.3-70b-versatile": "it(\"should compute correct lastPoint for free highlight in a rotated PDF\", async () => {\n  const { HighlightEditor } = await import(\"../../src/display/editor/highlight.js\");\n  const { getSerialized } = await import(\"./test_utils.js\");\n  const fakeDrawLayer = {\n    finalizeLine: () => {},\n    highlightOutline: () => 1,\n    updateLine: () => {}\n  };\n  const fakeParent = { drawLayer: fakeDrawLayer };\n  const fakeOutlines = {\n    box: { x: 0.1, y: 0.2, width: 0.3, height: 0.4, lastPoint: [0.4, 0.5] },\n    getNewOutline: (thickness, innerMargin) => ({\n      box: { x: 0.1, y: 0.2, width: 0.3, height: 0.4, lastPoint: [0.4, 0.5] }\n    })\n  };\n  const params = {\n    highlightId: 1,\n    highlightOutlines: fakeOutlines,\n    clipPathId: \"clip1\",\n    thickness: 12,\n    color: \"#FF0\",\n    opacity: 1,\n    boxes: null\n  };\n  const editor = new HighlightEditor(params);\n  editor.parent = fakeParent;\n  // Set rotation to 90\u00b0 and simulate page dimensions of 1x1.\n  editor.rotation = 90;\n  editor.parentDimensions = [1, 1];\n  // Force re-calculation if needed by invoking rotate (if available).\n  if (typeof editor.rotate === \"function\") {\n    editor.rotate(90);\n  }\n  const serialized = getSerialized(editor);\n  // The expected lastPoint is computed relative to the original box coordinates:\n  // expected = [ (0.4 - 0.1) / 0.3, (0.5 - 0.2) / 0.4 ] = [1, 0.75 ]\n  chai.assert.approximately(serialized.lastPoint[0], 1, 1e-4);\n  chai.assert.approximately(serialized.lastPoint[1], 0.75, 1e-4);\n});"
  },
  "17664": {
    "i1_deepseek-r1-distill-llama-70b": "it(\"should fix free highlighting lag behind mouse cursor\", async () => {\n  const { PDFDocument } = await import(\"../../src/core/document.js\");\n  const { Page } = await import(\"../../src/core/document.js\");\n  const { FreeOutliner } = await import(\"../../src/display/editor/outliner.js\");\n\n  // Setup mock PDF document\n  const xref = new XRefMock();\n  const pdf = new PDFDocument({\n    xref,\n    fingerprint: \"test\",\n    bug: 0,\n  });\n  const page = new Page({\n    pdf,\n    xref,\n    index: 0,\n    ref: new Ref(1, 0),\n  });\n\n  // Setup outliner with initial point\n  const box = { x: 0, y: 0, width: 100, height: 100 };\n  const scaleFactor = 1;\n  const thickness = 2;\n  const isLTR = true;\n  const innerMargin = 0;\n  const outliner = new FreeOutliner(\n    { x: 50, y: 50 },\n    box,\n    scaleFactor,\n    thickness,\n    isLTR,\n    innerMargin\n  );\n\n  // Simulate user drawing\n  const points = [\n    { x: 60, y: 40 },\n    { x: 70, y: 30 },\n    { x: 80, y: 20 },\n    { x: 90, y: 10 },\n  ];\n\n  // Add points and verify outline\n  for (const point of points) {\n    const result = outliner.add(point);\n    expect(result).toBe(true);\n\n    // Verify the outline is generated correctly\n    const svgPath = outliner.toSVGPath();\n    const outlines = outliner.getOutlines();\n    expect(svgPath).not.toBeNull();\n    expect(outlines).not.toBeNull();\n  }\n\n  // Verify last point coordinates match expected\n  const expectedLastCoords = [90, 10];\n  const actualLastCoords = outliner.#last.slice(-2);\n  expect(actualLastCoords[0]).toBeCloseTo(expectedLastCoords[0]);\n  expect(actualLastCoords[1]).toBeCloseTo(expectedLastCoords[1]);\n});",
    "i1_gpt-4o": "it(\"should update highlighting coordinates correctly\", async () => {\n  const { FreeOutliner } = await import(\"../../src/display/editor/outliner.js\");\n  const initialPoint = { x: 10, y: 10 };\n  const box = [0, 0, 100, 100];\n  const scaleFactor = 1;\n  const thickness = 1;\n  const isLTR = true;\n  const outliner = new FreeOutliner(initialPoint, box, scaleFactor, thickness, isLTR);\n\n  outliner.add({ x: 20, y: 20 });\n  outliner.add({ x: 30, y: 30 });\n\n  const expectedSVGPath = \"M0.1 0.1 L0.2 0.2 L0.3 0.3 L0.2 0.2 L0.1 0.1 Z\";\n  const actualSVGPath = outliner.toSVGPath();\n\n  expect(actualSVGPath).toBe(expectedSVGPath);\n});",
    "i1_llama-3.3-70b-versatile": "it(\"should not lag behind the mouse cursor when using free highlighting in PDF\", async () => {\n  const { FreeOutliner } = await import(\"../../src/display/editor/outliner.js\");\n  const { Util } = await import(\"../../src/shared/util.js\");\n  const outliner = new FreeOutliner({ x: 10, y: 10 }, [0, 0, 100, 100], 1, 1, true);\n  outliner.add({ x: 20, y: 20 });\n  outliner.add({ x: 30, y: 30 });\n  const path = outliner.toSVGPath();\n  const expectedPath = `M10 10 L20 20 L30 30 L40 40 Z`;\n  expect(path).not.toBe(expectedPath);\n  const { FreeOutliner: PatchedFreeOutliner } = await import(\"../../src/display/editor/outliner.js\");\n  const patchedOutliner = new PatchedFreeOutliner({ x: 10, y: 10 }, [0, 0, 100, 100], 1, 1, true);\n  patchedOutliner.add({ x: 20, y: 20 });\n  patchedOutliner.add({ x: 30, y: 30 });\n  const patchedPath = patchedOutliner.toSVGPath();\n  expect(patchedPath).toContain(`L${(20 + (10 - 20) / 2) / 100} ${(20 + (10 - 20) / 2) / 100}`);\n});",
    "i2_deepseek-r1-distill-llama-70b": "it(\"should update the free highlight outline to match the cursor position\", async () => {\n  const { FreeOutliner } = await import(\"../../src/display/editor/outliner.js\");\n\n  const box = { x: 0, y: 0, width: 100, height: 100 };\n  const scaleFactor = 1;\n  const thickness = 1;\n  const isLTR = true;\n  const innerMargin = 0;\n\n  const outliner = new FreeOutliner({ x: 10, y: 10 }, box, scaleFactor, thickness, isLTR, innerMargin);\n\n  // Simulate mouse movement adding points\n  outliner.add({ x: 20, y: 20 });\n  outliner.add({ x: 30, y: 30 });\n  outliner.add({ x: 40, y: 40 });\n\n  // Generate the SVG path\n  const svgPath = outliner.toSVGPath();\n\n  // The expected path should include all points without lag\n  const expectedPath = \"M0.3 0.3 L0.4 0.4 L0.5 0.5 L0.6 0.6 Z\";\n\n  expect(svgPath).toContain(expectedPath);\n});",
    "i2_gpt-4o": "it(\"should ensure free highlighting ends where the mouse pointer is\", async () => {\n  const { FreeOutliner } = await import(\"../../src/display/editor/outliner.js\");\n\n  const box = [0, 0, 100, 100];\n  const scaleFactor = 1;\n  const thickness = 1;\n  const isLTR = true;\n  const initialPoint = { x: 10, y: 10 };\n  const outliner = new FreeOutliner(initialPoint, box, scaleFactor, thickness, isLTR);\n\n  outliner.add({ x: 20, y: 20 });\n  outliner.add({ x: 30, y: 30 });\n  outliner.add({ x: 40, y: 40 });\n\n  const expectedLastCoords = [40, 40];\n  const actualLastCoords = [outliner.#lastX, outliner.#lastY];\n\n  expect(actualLastCoords).toEqual(expectedLastCoords);\n});",
    "i2_llama-3.3-70b-versatile": "it(\"should end a free highlight where the mouse pointer is\", async () => {\n  const { FreeOutliner } = await import(\"../../src/display/editor/outliner.js\");\n  const outliner = new FreeOutliner({ x: 10, y: 10 }, [0, 0, 100, 100], 1, 1, true);\n  outliner.add({ x: 20, y: 20 });\n  outliner.add({ x: 30, y: 30 });\n  const outline = outliner.getOutlines();\n  const points = outline.points;\n  const lastPoint = points[points.length - 1];\n  const expectedLastPoint = { x: 30, y: 30 };\n  expect(lastPoint).toEqual(expectedLastPoint);\n});",
    "i3_deepseek-r1-distill-llama-70b": "it(\"should fix free highlighting lag behind mouse cursor\", async () => {\n  const { Outliner } = await import(\"../../src/display/editor/outliner.js\");\n  const box = { x: 0, y: 0, width: 100, height: 100 };\n  const points = [\n    { x: 10, y: 10 }, { x: 20, y: 20 }, { x: 30, y: 30 }, { x: 40, y: 40 },\n    { x: 50, y: 50 }, { x: 60, y: 60 }, { x: 70, y: 70 }, { x: 80, y: 80 }\n  ];\n\n  const outliner = new Outliner(points, 0, 0, true);\n\n  for (const point of points) {\n    const result = outliner.add(point);\n    if (!result) {\n      throw new Error(\"Failed to add point\");\n    }\n  }\n\n  const outlines = outliner.getOutlines();\n  if (!outlines || outlines.length === 0) {\n    throw new Error(\"No outlines generated\");\n  }\n});",
    "i3_gpt-4o": "it(\"should update highlighting position without lag\", async () => {\n  const { FreeOutliner } = await import(\"../../src/display/editor/outliner.js\");\n  const initialPoint = { x: 10, y: 10 };\n  const box = [0, 0, 100, 100];\n  const scaleFactor = 1;\n  const thickness = 1;\n  const isLTR = true;\n  const outliner = new FreeOutliner(initialPoint, box, scaleFactor, thickness, isLTR);\n\n  const newPoint = { x: 50, y: 50 };\n  outliner.add(newPoint);\n\n  const expectedPath = `M0.1 0.1 L0.5 0.5 L0.5 0.5 L0.1 0.1 Z`;\n  const actualPath = outliner.toSVGPath();\n\n  expect(actualPath).toBe(expectedPath);\n});",
    "i3_llama-3.3-70b-versatile": "it(\"should fix the free highlighting lag behind the mouse cursor\", async () => {\n  const { FreeOutliner } = await import(\"../../src/display/editor/outliner.js\");\n  const box = { x: 0, y: 0, width: 100, height: 100 };\n  const scaleFactor = 1;\n  const thickness = 1;\n  const isLTR = true;\n  const innerMargin = 0;\n  const outliner = new FreeOutliner({ x: 10, y: 10 }, box, scaleFactor, thickness, isLTR, innerMargin);\n  outliner.add({ x: 20, y: 20 });\n  outliner.add({ x: 30, y: 30 });\n  const outlines = outliner.getOutlines();\n  const expectedOutline = new Float64Array([\n    NaN, NaN, NaN, NaN, 10, 10,\n    NaN, NaN, NaN, NaN, 20, 20,\n    NaN, NaN, NaN, NaN, 30, 30,\n    NaN, NaN, NaN, NaN, 30, 30,\n  ]);\n  expect(outlines.outline).toEqual(expectedOutline);\n});",
    "i4_deepseek-r1-distill-llama-70b": "it(\"should not lag behind mouse cursor with free highlighting\", async () => {\n  const { FreeOutliner, HighlightOutline } = await import(\"../../src/display/editor/outliner.js\");\n  const { Util } = await import(\"../../shared/util.js\");\n\n  const box = { x: 0, y: 0, width: 100, height: 100 };\n  const options = { scaleFactor: 1, thickness: 1, isLTR: true, innerMargin: 0 };\n\n  const outliner = new FreeOutliner({ x: 10, y: 10 }, box, options.scaleFactor, options.thickness, options.isLTR, options.innerMargin);\n  outliner.add({ x: 20, y: 20 });\n  outliner.add({ x: 30, y: 30 });\n  outliner.add({ x: 40, y: 40 });\n\n  const outlines = outliner.getOutlines();\n  const expectedOutline = new Float64Array([\n    0.3, 0.3, 0.5, 0.3, 0.5, 0.5, 0.3, 0.5, 0.3, 0.3,\n    0.7, 0.3, 0.7, 0.5, 0.7, 0.7, 0.5, 0.7, 0.3, 0.7,\n    0.3, 0.7, 0.3, 0.3, 0.5, 0.3, 0.7, 0.3, 0.7, 0.7\n  ]);\n\n  const actualOutline = outlines.outline;\n  expect(actualOutline).toEqual(expectedOutline);\n});",
    "i4_gpt-4o": "it(\"should ensure free highlighting in PDF does not lag behind the mouse cursor\", async () => {\n  const { FreeOutliner } = await import(\"../../src/display/editor/outliner.js\");\n\n  const initialPoint = { x: 10, y: 10 };\n  const box = [0, 0, 100, 100];\n  const scaleFactor = 1;\n  const thickness = 2;\n  const isLTR = true;\n  const innerMargin = 0;\n\n  const outliner = new FreeOutliner(initialPoint, box, scaleFactor, thickness, isLTR, innerMargin);\n\n  const pointsToAdd = [\n    { x: 20, y: 20 },\n    { x: 30, y: 30 },\n    { x: 40, y: 40 },\n    { x: 50, y: 50 }\n  ];\n\n  pointsToAdd.forEach(point => outliner.add(point));\n\n  const expectedSVGPath = \"M0.1 0.1 L0.2 0.2 L0.3 0.3 L0.4 0.4 L0.5 0.5 Z\";\n  const actualSVGPath = outliner.toSVGPath();\n\n  expect(actualSVGPath).toBe(expectedSVGPath);\n});",
    "i4_llama-3.3-70b-versatile": "it(\"should not lag behind the mouse cursor when highlighting in PDF\", async () => {\n  const { FreeOutliner } = await import(\"../../src/display/editor/outliner.js\");\n  const box = { x: 0, y: 0, width: 100, height: 100 };\n  const scaleFactor = 1;\n  const thickness = 1;\n  const isLTR = true;\n  const innerMargin = 0;\n  const outliner = new FreeOutliner({ x: 10, y: 10 }, box, scaleFactor, thickness, isLTR, innerMargin);\n  outliner.add({ x: 20, y: 20 });\n  outliner.add({ x: 30, y: 30 });\n  const outlines = outliner.getOutlines();\n  const expectedOutline = new Float64Array(36);\n  expectedOutline.set([\n    NaN,\n    NaN,\n    NaN,\n    NaN,\n    10,\n    10,\n    NaN,\n    NaN,\n    NaN,\n    NaN,\n    20,\n    20,\n    NaN,\n    NaN,\n    NaN,\n    NaN,\n    30,\n    30,\n    NaN,\n    NaN,\n    NaN,\n    NaN,\n    20,\n    20,\n    NaN,\n    NaN,\n    NaN,\n    NaN,\n    30,\n    30,\n    NaN,\n    NaN,\n    NaN,\n    NaN,\n    20,\n    20,\n  ]);\n  expect(outlines.outline).toEqual(expectedOutline);\n});",
    "i5_deepseek-r1-distill-llama-70b": "it(\"should fix free highlighting lag behind cursor\", async () => {\n  const { PDFDocumentProxy } = await import(\"../../src/display/api.js\");\n  const { Outliner } = await import(\"../../src/display/editor/outliner.js\");\n  const { XRefMock } = await import(\"./test_utils.js\");\n\n  // Create a mock PDF document with one page\n  const xRef = new XRefMock();\n  const pdf = await PDFDocumentProxy.create({\n    xref: xRef,\n    filename: \"test.pdf\",\n    length: 1,\n  });\n  const page = (await pdf.getPages())[0];\n\n  // Get the outliner instance\n  const annotationLayer = page.annotationLayer;\n  const outliner = new Outliner(annotationLayer);\n\n  // Simulate adding points to the outliner\n  const points = [\n    { x: 100, y: 100 },\n    { x: 150, y: 150 },\n    { x: 200, y: 200 },\n  ];\n\n  points.forEach((point) => outliner.add(point));\n\n  // Check if the last coordinates are correctly updated\n  const [lastTopX, lastTopY, lastBottomX, lastBottomY] = outliner.#getLastCoords();\n  expect(lastTopX).toBeCloseTo(points[points.length - 1].x / page.viewport.width);\n  expect(lastTopY).toBeCloseTo(points[points.length - 1].y / page.viewport.height);\n  expect(lastBottomX).toBeCloseTo(points[points.length - 1].x / page.viewport.width);\n  expect(lastBottomY).toBeCloseTo(points[points.length - 1].y / page.viewport.height);\n});",
    "i5_gpt-4o": "it(\"should update highlighting position without lag\", async () => {\n  const { FreeOutliner } = await import(\"../../src/display/editor/outliner.js\");\n  const outliner = new FreeOutliner();\n  outliner.#box = [0, 0, 100, 100];\n\n  const initialPoint = { x: 10, y: 10 };\n  outliner.add(initialPoint);\n\n  const expectedCoords = [\n    (initialPoint.x - outliner.#box[0]) / outliner.#box[2],\n    (initialPoint.y - outliner.#box[1]) / outliner.#box[3],\n  ];\n\n  const actualCoords = outliner.#getLastCoords().slice(0, 2);\n\n  expect(actualCoords).toEqual(expectedCoords);\n});",
    "i5_llama-3.3-70b-versatile": "it(\"should not lag behind the mouse cursor when using free highlighting in PDF\", async () => {\n  const { PDFDocument, PDFPageProxy } = await import(\"../../src/display/api.js\");\n  const { Outliner } = await import(\"../../src/display/editor/outliner.js\");\n  const { PDFDataRangeTransport } = await import(\"../../src/display/api.js\");\n\n  const pdfDoc = await PDFDocument.load(await (await import(\"../../src/shared/util.js\")).stringToBytes(\"your_pdf_file.pdf\"));\n  const pdfPage = await pdfDoc.getPage(1);\n  const pdfPageProxy = new PDFPageProxy(pdfDoc, pdfPage);\n  const outliner = new Outliner(pdfPageProxy);\n\n  const lastX = 100;\n  const lastY = 100;\n  outliner.add({ x: lastX, y: lastY });\n\n  const lastCoords = outliner.#getLastCoords();\n  const expectedLastCoords = [(lastX + (outliner.#last.subarray(4, 6)[0] - outliner.#last.subarray(16, 18)[0]) / 2) / pdfPageProxy.getViewport(1).width, \n                                (lastY + (outliner.#last.subarray(4, 6)[1] - outliner.#last.subarray(16, 18)[1]) / 2) / pdfPageProxy.getViewport(1).height, \n                                (lastX + (outliner.#last.subarray(16, 18)[0] - outliner.#last.subarray(4, 6)[0]) / 2) / pdfPageProxy.getViewport(1).width, \n                                (lastY + (outliner.#last.subarray(16, 18)[1] - outliner.#last.subarray(4, 6)[1]) / 2) / pdfPageProxy.getViewport(1).height];\n\n  expect(lastCoords).toEqual(expectedLastCoords);\n});"
  },
  "17674": {
    "i1_deepseek-r1-distill-llama-70b": "it(\"should correctly render missing characters with loca table patch\", async () => {\n  const pdfDoc = await getDocument(TEST_PDFS_PATH + \"Mappe123.pdf\").promise;\n  const page = await pdfDoc.getPage(1);\n  const textContent = await page.getTextContent();\n  const text = textContent.items.map(item => item.str).join(\"\");\n  expect(text).toEqual(\"Das ist ein Test\");\n});",
    "i1_gpt-4o": "it(\"should correctly render missing characters with loca table patch\", async () => {\n  const pdfDoc = await getDocument(TEST_PDFS_PATH + \"Mappe123.pdf\").promise;\n  const page = await pdfDoc.getPage(1);\n  const textContent = await page.getTextContent();\n  const text = textContent.items.map(item => item.str).join(\"\");\n  expect(text).toEqual(\"Das ist ein Test\");\n});",
    "i1_llama-3.3-70b-versatile": "it(\"should correctly render missing characters with loca table patch\", async () => {\n  const pdfDoc = await getDocument(TEST_PDFS_PATH + \"Mappe123.pdf\").promise;\n  const page = await pdfDoc.getPage(1);\n  const textContent = await page.getTextContent();\n  const text = textContent.items.map(item => item.str).join(\"\");\n  expect(text).toEqual(\"Das ist ein Test\");\n});",
    "i1_MOCK": "it(\"should correctly render missing characters with loca table patch\", async () => {\n  const pdfDoc = await getDocument(TEST_PDFS_PATH + \"Mappe123.pdf\").promise;\n  const page = await pdfDoc.getPage(1);\n  const textContent = await page.getTextContent();\n  const text = textContent.items.map(item => item.str).join(\"\");\n  expect(text).toEqual(\"Das ist ein Test\");\n});",
    "i2_deepseek-r1-distill-llama-70b": "it(\"should correctly render missing characters with loca table patch\", async () => {\n  const pdfDoc = await getDocument(TEST_PDFS_PATH + \"Mappe123.pdf\").promise;\n  const page = await pdfDoc.getPage(1);\n  const textContent = await page.getTextContent();\n  const text = textContent.items.map(item => item.str).join(\"\");\n  expect(text).toEqual(\"Das ist ein Test\");\n});",
    "i2_gpt-4o": "it(\"should correctly render missing characters with loca table patch\", async () => {\n  const pdfDoc = await getDocument(TEST_PDFS_PATH + \"Mappe123.pdf\").promise;\n  const page = await pdfDoc.getPage(1);\n  const textContent = await page.getTextContent();\n  const text = textContent.items.map(item => item.str).join(\"\");\n  expect(text).toEqual(\"Das ist ein Test\");\n});",
    "i2_llama-3.3-70b-versatile": "it(\"should correctly render missing characters with loca table patch\", async () => {\n  const pdfDoc = await getDocument(TEST_PDFS_PATH + \"Mappe123.pdf\").promise;\n  const page = await pdfDoc.getPage(1);\n  const textContent = await page.getTextContent();\n  const text = textContent.items.map(item => item.str).join(\"\");\n  expect(text).toEqual(\"Das ist ein Test\");\n});",
    "i3_deepseek-r1-distill-llama-70b": "it(\"should correctly render missing characters with loca table patch\", async () => {\n  const pdfDoc = await getDocument(TEST_PDFS_PATH + \"Mappe123.pdf\").promise;\n  const page = await pdfDoc.getPage(1);\n  const textContent = await page.getTextContent();\n  const text = textContent.items.map(item => item.str).join(\"\");\n  expect(text).toEqual(\"Das ist ein Test\");\n});",
    "i3_gpt-4o": "it(\"should correctly render missing characters with loca table patch\", async () => {\n  const pdfDoc = await getDocument(TEST_PDFS_PATH + \"Mappe123.pdf\").promise;\n  const page = await pdfDoc.getPage(1);\n  const textContent = await page.getTextContent();\n  const text = textContent.items.map(item => item.str).join(\"\");\n  expect(text).toEqual(\"Das ist ein Test\");\n});",
    "i3_llama-3.3-70b-versatile": "it(\"should correctly render missing characters with loca table patch\", async () => {\n  const pdfDoc = await getDocument(TEST_PDFS_PATH + \"Mappe123.pdf\").promise;\n  const page = await pdfDoc.getPage(1);\n  const textContent = await page.getTextContent();\n  const text = textContent.items.map(item => item.str).join(\"\");\n  expect(text).toEqual(\"Das ist ein Test\");\n});",
    "i4_deepseek-r1-distill-llama-70b": "it(\"should correctly render missing characters with loca table patch\", async () => {\n  const pdfDoc = await getDocument(TEST_PDFS_PATH + \"Mappe123.pdf\").promise;\n  const page = await pdfDoc.getPage(1);\n  const textContent = await page.getTextContent();\n  const text = textContent.items.map(item => item.str).join(\"\");\n  expect(text).toEqual(\"Das ist ein Test\");\n});",
    "i4_gpt-4o": "it(\"should correctly render missing characters with loca table patch\", async () => {\n  const pdfDoc = await getDocument(TEST_PDFS_PATH + \"Mappe123.pdf\").promise;\n  const page = await pdfDoc.getPage(1);\n  const textContent = await page.getTextContent();\n  const text = textContent.items.map(item => item.str).join(\"\");\n  expect(text).toEqual(\"Das ist ein Test\");\n});",
    "i4_llama-3.3-70b-versatile": "it(\"should correctly render missing characters with loca table patch\", async () => {\n  const pdfDoc = await getDocument(TEST_PDFS_PATH + \"Mappe123.pdf\").promise;\n  const page = await pdfDoc.getPage(1);\n  const textContent = await page.getTextContent();\n  const text = textContent.items.map(item => item.str).join(\"\");\n  expect(text).toEqual(\"Das ist ein Test\");\n});",
    "i5_deepseek-r1-distill-llama-70b": "it(\"should correctly render missing characters with loca table patch\", async () => {\n  const pdfDoc = await getDocument(TEST_PDFS_PATH + \"Mappe123.pdf\").promise;\n  const page = await pdfDoc.getPage(1);\n  const textContent = await page.getTextContent();\n  const text = textContent.items.map(item => item.str).join(\"\");\n  expect(text).toEqual(\"Das ist ein Test\");\n});",
    "i5_gpt-4o": "it(\"should correctly render missing characters with loca table patch\", async () => {\n  const pdfDoc = await getDocument(TEST_PDFS_PATH + \"Mappe123.pdf\").promise;\n  const page = await pdfDoc.getPage(1);\n  const textContent = await page.getTextContent();\n  const text = textContent.items.map(item => item.str).join(\"\");\n  expect(text).toEqual(\"Das ist ein Test\");\n});",
    "i5_llama-3.3-70b-versatile": "it(\"should correctly render missing characters with loca table patch\", async () => {\n  const pdfDoc = await getDocument(TEST_PDFS_PATH + \"Mappe123.pdf\").promise;\n  const page = await pdfDoc.getPage(1);\n  const textContent = await page.getTextContent();\n  const text = textContent.items.map(item => item.str).join(\"\");\n  expect(text).toEqual(\"Das ist ein Test\");\n});"
  },
  "17690": {
    "i1_deepseek-r1-distill-llama-70b": "it(\"should handle missing cidSystemInfo gracefully in composite fonts\", async () => {\n  const { createIdFactory } = await import(\"./test_utils.js\");\n  const evaluator = new (await import(\"../../src/core/evaluator.js\")).PartialEvaluator({\n    xref: {},\n    handler: {},\n    pageIndex: 0,\n    idFactory: createIdFactory(),\n    fontCache: new Map(),\n    builtInCMapCache: new Map(),\n    standardFontDataCache: new Map(),\n    globalImageCache: new Map(),\n    systemFontCache: new Map(),\n  });\n  const properties = {\n    composite: true,\n    cMap: { builtInCMap: false },\n    firstChar: 32,\n    lastChar: 127,\n    // Intentionally omitting cidSystemInfo to simulate problematic PDFs.\n  };\n  const toUnicodeMap = await evaluator.buildToUnicode(properties);\n  if (typeof toUnicodeMap.lookup !== \"function\") {\n    throw new Error(\"toUnicodeMap.lookup is not a function\");\n  }\n  const char = toUnicodeMap.lookup(65);\n  if (char !== \"A\") {\n    throw new Error(`Expected \"A\" for char code 65 but got \"${char}\"`);\n  }\n});",
    "i1_gpt-4o": "it(\"should handle missing cidSystemInfo gracefully in composite fonts\", async () => {\n  const { createIdFactory } = await import(\"./test_utils.js\");\n  const evaluator = new (await import(\"../../src/core/evaluator.js\")).PartialEvaluator({\n    xref: {},\n    handler: {},\n    pageIndex: 0,\n    idFactory: createIdFactory(),\n    fontCache: new Map(),\n    builtInCMapCache: new Map(),\n    standardFontDataCache: new Map(),\n    globalImageCache: new Map(),\n    systemFontCache: new Map(),\n  });\n  const properties = {\n    composite: true,\n    cMap: { builtInCMap: false },\n    firstChar: 32,\n    lastChar: 127,\n    // Intentionally omitting cidSystemInfo to simulate problematic PDFs.\n  };\n  const toUnicodeMap = await evaluator.buildToUnicode(properties);\n  if (typeof toUnicodeMap.lookup !== \"function\") {\n    throw new Error(\"toUnicodeMap.lookup is not a function\");\n  }\n  const char = toUnicodeMap.lookup(65);\n  if (char !== \"A\") {\n    throw new Error(`Expected \"A\" for char code 65 but got \"${char}\"`);\n  }\n});",
    "i1_llama-3.3-70b-versatile": "it(\"should handle missing cidSystemInfo gracefully in composite fonts\", async () => {\n  const { createIdFactory } = await import(\"./test_utils.js\");\n  const evaluator = new (await import(\"../../src/core/evaluator.js\")).PartialEvaluator({\n    xref: {},\n    handler: {},\n    pageIndex: 0,\n    idFactory: createIdFactory(),\n    fontCache: new Map(),\n    builtInCMapCache: new Map(),\n    standardFontDataCache: new Map(),\n    globalImageCache: new Map(),\n    systemFontCache: new Map(),\n  });\n  const properties = {\n    composite: true,\n    cMap: { builtInCMap: false },\n    firstChar: 32,\n    lastChar: 127,\n    // Intentionally omitting cidSystemInfo to simulate problematic PDFs.\n  };\n  const toUnicodeMap = await evaluator.buildToUnicode(properties);\n  if (typeof toUnicodeMap.lookup !== \"function\") {\n    throw new Error(\"toUnicodeMap.lookup is not a function\");\n  }\n  const char = toUnicodeMap.lookup(65);\n  if (char !== \"A\") {\n    throw new Error(`Expected \"A\" for char code 65 but got \"${char}\"`);\n  }\n});",
    "i1_MOCK": "it(\"should handle missing cidSystemInfo gracefully in composite fonts\", async () => {\n  const { createIdFactory } = await import(\"./test_utils.js\");\n  const evaluator = new (await import(\"../../src/core/evaluator.js\")).PartialEvaluator({\n    xref: {},\n    handler: {},\n    pageIndex: 0,\n    idFactory: createIdFactory(),\n    fontCache: new Map(),\n    builtInCMapCache: new Map(),\n    standardFontDataCache: new Map(),\n    globalImageCache: new Map(),\n    systemFontCache: new Map(),\n  });\n  const properties = {\n    composite: true,\n    cMap: { builtInCMap: false },\n    firstChar: 32,\n    lastChar: 127,\n    // Intentionally omitting cidSystemInfo to simulate problematic PDFs.\n  };\n  const toUnicodeMap = await evaluator.buildToUnicode(properties);\n  if (typeof toUnicodeMap.lookup !== \"function\") {\n    throw new Error(\"toUnicodeMap.lookup is not a function\");\n  }\n  const char = toUnicodeMap.lookup(65);\n  if (char !== \"A\") {\n    throw new Error(`Expected \"A\" for char code 65 but got \"${char}\"`);\n  }\n});",
    "i2_deepseek-r1-distill-llama-70b": "it(\"should handle missing cidSystemInfo gracefully in composite fonts\", async () => {\n  const { createIdFactory } = await import(\"./test_utils.js\");\n  const evaluator = new (await import(\"../../src/core/evaluator.js\")).PartialEvaluator({\n    xref: {},\n    handler: {},\n    pageIndex: 0,\n    idFactory: createIdFactory(),\n    fontCache: new Map(),\n    builtInCMapCache: new Map(),\n    standardFontDataCache: new Map(),\n    globalImageCache: new Map(),\n    systemFontCache: new Map(),\n  });\n  const properties = {\n    composite: true,\n    cMap: { builtInCMap: false },\n    firstChar: 32,\n    lastChar: 127,\n    // Intentionally omitting cidSystemInfo to simulate problematic PDFs.\n  };\n  const toUnicodeMap = await evaluator.buildToUnicode(properties);\n  if (typeof toUnicodeMap.lookup !== \"function\") {\n    throw new Error(\"toUnicodeMap.lookup is not a function\");\n  }\n  const char = toUnicodeMap.lookup(65);\n  if (char !== \"A\") {\n    throw new Error(`Expected \"A\" for char code 65 but got \"${char}\"`);\n  }\n});",
    "i2_gpt-4o": "it(\"should handle missing cidSystemInfo gracefully in composite fonts\", async () => {\n  const { createIdFactory } = await import(\"./test_utils.js\");\n  const evaluator = new (await import(\"../../src/core/evaluator.js\")).PartialEvaluator({\n    xref: {},\n    handler: {},\n    pageIndex: 0,\n    idFactory: createIdFactory(),\n    fontCache: new Map(),\n    builtInCMapCache: new Map(),\n    standardFontDataCache: new Map(),\n    globalImageCache: new Map(),\n    systemFontCache: new Map(),\n  });\n  const properties = {\n    composite: true,\n    cMap: { builtInCMap: false },\n    firstChar: 32,\n    lastChar: 127,\n    // Intentionally omitting cidSystemInfo to simulate problematic PDFs.\n  };\n  const toUnicodeMap = await evaluator.buildToUnicode(properties);\n  if (typeof toUnicodeMap.lookup !== \"function\") {\n    throw new Error(\"toUnicodeMap.lookup is not a function\");\n  }\n  const char = toUnicodeMap.lookup(65);\n  if (char !== \"A\") {\n    throw new Error(`Expected \"A\" for char code 65 but got \"${char}\"`);\n  }\n});",
    "i2_llama-3.3-70b-versatile": "it(\"should handle missing cidSystemInfo gracefully in composite fonts\", async () => {\n  const { createIdFactory } = await import(\"./test_utils.js\");\n  const evaluator = new (await import(\"../../src/core/evaluator.js\")).PartialEvaluator({\n    xref: {},\n    handler: {},\n    pageIndex: 0,\n    idFactory: createIdFactory(),\n    fontCache: new Map(),\n    builtInCMapCache: new Map(),\n    standardFontDataCache: new Map(),\n    globalImageCache: new Map(),\n    systemFontCache: new Map(),\n  });\n  const properties = {\n    composite: true,\n    cMap: { builtInCMap: false },\n    firstChar: 32,\n    lastChar: 127,\n    // Intentionally omitting cidSystemInfo to simulate problematic PDFs.\n  };\n  const toUnicodeMap = await evaluator.buildToUnicode(properties);\n  if (typeof toUnicodeMap.lookup !== \"function\") {\n    throw new Error(\"toUnicodeMap.lookup is not a function\");\n  }\n  const char = toUnicodeMap.lookup(65);\n  if (char !== \"A\") {\n    throw new Error(`Expected \"A\" for char code 65 but got \"${char}\"`);\n  }\n});",
    "i3_deepseek-r1-distill-llama-70b": "it(\"should handle missing cidSystemInfo gracefully in composite fonts\", async () => {\n  const { createIdFactory } = await import(\"./test_utils.js\");\n  const evaluator = new (await import(\"../../src/core/evaluator.js\")).PartialEvaluator({\n    xref: {},\n    handler: {},\n    pageIndex: 0,\n    idFactory: createIdFactory(),\n    fontCache: new Map(),\n    builtInCMapCache: new Map(),\n    standardFontDataCache: new Map(),\n    globalImageCache: new Map(),\n    systemFontCache: new Map(),\n  });\n  const properties = {\n    composite: true,\n    cMap: { builtInCMap: false },\n    firstChar: 32,\n    lastChar: 127,\n    // Intentionally omitting cidSystemInfo to simulate problematic PDFs.\n  };\n  const toUnicodeMap = await evaluator.buildToUnicode(properties);\n  if (typeof toUnicodeMap.lookup !== \"function\") {\n    throw new Error(\"toUnicodeMap.lookup is not a function\");\n  }\n  const char = toUnicodeMap.lookup(65);\n  if (char !== \"A\") {\n    throw new Error(`Expected \"A\" for char code 65 but got \"${char}\"`);\n  }\n});",
    "i3_gpt-4o": "it(\"should handle missing cidSystemInfo gracefully in composite fonts\", async () => {\n  const { createIdFactory } = await import(\"./test_utils.js\");\n  const evaluator = new (await import(\"../../src/core/evaluator.js\")).PartialEvaluator({\n    xref: {},\n    handler: {},\n    pageIndex: 0,\n    idFactory: createIdFactory(),\n    fontCache: new Map(),\n    builtInCMapCache: new Map(),\n    standardFontDataCache: new Map(),\n    globalImageCache: new Map(),\n    systemFontCache: new Map(),\n  });\n  const properties = {\n    composite: true,\n    cMap: { builtInCMap: false },\n    firstChar: 32,\n    lastChar: 127,\n    // Intentionally omitting cidSystemInfo to simulate problematic PDFs.\n  };\n  const toUnicodeMap = await evaluator.buildToUnicode(properties);\n  if (typeof toUnicodeMap.lookup !== \"function\") {\n    throw new Error(\"toUnicodeMap.lookup is not a function\");\n  }\n  const char = toUnicodeMap.lookup(65);\n  if (char !== \"A\") {\n    throw new Error(`Expected \"A\" for char code 65 but got \"${char}\"`);\n  }\n});",
    "i3_llama-3.3-70b-versatile": "it(\"should handle missing cidSystemInfo gracefully in composite fonts\", async () => {\n  const { createIdFactory } = await import(\"./test_utils.js\");\n  const evaluator = new (await import(\"../../src/core/evaluator.js\")).PartialEvaluator({\n    xref: {},\n    handler: {},\n    pageIndex: 0,\n    idFactory: createIdFactory(),\n    fontCache: new Map(),\n    builtInCMapCache: new Map(),\n    standardFontDataCache: new Map(),\n    globalImageCache: new Map(),\n    systemFontCache: new Map(),\n  });\n  const properties = {\n    composite: true,\n    cMap: { builtInCMap: false },\n    firstChar: 32,\n    lastChar: 127,\n    // Intentionally omitting cidSystemInfo to simulate problematic PDFs.\n  };\n  const toUnicodeMap = await evaluator.buildToUnicode(properties);\n  if (typeof toUnicodeMap.lookup !== \"function\") {\n    throw new Error(\"toUnicodeMap.lookup is not a function\");\n  }\n  const char = toUnicodeMap.lookup(65);\n  if (char !== \"A\") {\n    throw new Error(`Expected \"A\" for char code 65 but got \"${char}\"`);\n  }\n});",
    "i4_deepseek-r1-distill-llama-70b": "it(\"should handle missing cidSystemInfo gracefully in composite fonts\", async () => {\n  const { createIdFactory } = await import(\"./test_utils.js\");\n  const evaluator = new (await import(\"../../src/core/evaluator.js\")).PartialEvaluator({\n    xref: {},\n    handler: {},\n    pageIndex: 0,\n    idFactory: createIdFactory(),\n    fontCache: new Map(),\n    builtInCMapCache: new Map(),\n    standardFontDataCache: new Map(),\n    globalImageCache: new Map(),\n    systemFontCache: new Map(),\n  });\n  const properties = {\n    composite: true,\n    cMap: { builtInCMap: false },\n    firstChar: 32,\n    lastChar: 127,\n    // Intentionally omitting cidSystemInfo to simulate problematic PDFs.\n  };\n  const toUnicodeMap = await evaluator.buildToUnicode(properties);\n  if (typeof toUnicodeMap.lookup !== \"function\") {\n    throw new Error(\"toUnicodeMap.lookup is not a function\");\n  }\n  const char = toUnicodeMap.lookup(65);\n  if (char !== \"A\") {\n    throw new Error(`Expected \"A\" for char code 65 but got \"${char}\"`);\n  }\n});",
    "i4_gpt-4o": "it(\"should handle missing cidSystemInfo gracefully in composite fonts\", async () => {\n  const { createIdFactory } = await import(\"./test_utils.js\");\n  const evaluator = new (await import(\"../../src/core/evaluator.js\")).PartialEvaluator({\n    xref: {},\n    handler: {},\n    pageIndex: 0,\n    idFactory: createIdFactory(),\n    fontCache: new Map(),\n    builtInCMapCache: new Map(),\n    standardFontDataCache: new Map(),\n    globalImageCache: new Map(),\n    systemFontCache: new Map(),\n  });\n  const properties = {\n    composite: true,\n    cMap: { builtInCMap: false },\n    firstChar: 32,\n    lastChar: 127,\n    // Intentionally omitting cidSystemInfo to simulate problematic PDFs.\n  };\n  const toUnicodeMap = await evaluator.buildToUnicode(properties);\n  if (typeof toUnicodeMap.lookup !== \"function\") {\n    throw new Error(\"toUnicodeMap.lookup is not a function\");\n  }\n  const char = toUnicodeMap.lookup(65);\n  if (char !== \"A\") {\n    throw new Error(`Expected \"A\" for char code 65 but got \"${char}\"`);\n  }\n});",
    "i4_llama-3.3-70b-versatile": "it(\"should handle missing cidSystemInfo gracefully in composite fonts\", async () => {\n  const { createIdFactory } = await import(\"./test_utils.js\");\n  const evaluator = new (await import(\"../../src/core/evaluator.js\")).PartialEvaluator({\n    xref: {},\n    handler: {},\n    pageIndex: 0,\n    idFactory: createIdFactory(),\n    fontCache: new Map(),\n    builtInCMapCache: new Map(),\n    standardFontDataCache: new Map(),\n    globalImageCache: new Map(),\n    systemFontCache: new Map(),\n  });\n  const properties = {\n    composite: true,\n    cMap: { builtInCMap: false },\n    firstChar: 32,\n    lastChar: 127,\n    // Intentionally omitting cidSystemInfo to simulate problematic PDFs.\n  };\n  const toUnicodeMap = await evaluator.buildToUnicode(properties);\n  if (typeof toUnicodeMap.lookup !== \"function\") {\n    throw new Error(\"toUnicodeMap.lookup is not a function\");\n  }\n  const char = toUnicodeMap.lookup(65);\n  if (char !== \"A\") {\n    throw new Error(`Expected \"A\" for char code 65 but got \"${char}\"`);\n  }\n});",
    "i5_deepseek-r1-distill-llama-70b": "it(\"should handle missing cidSystemInfo gracefully in composite fonts\", async () => {\n  const { createIdFactory } = await import(\"./test_utils.js\");\n  const evaluator = new (await import(\"../../src/core/evaluator.js\")).PartialEvaluator({\n    xref: {},\n    handler: {},\n    pageIndex: 0,\n    idFactory: createIdFactory(),\n    fontCache: new Map(),\n    builtInCMapCache: new Map(),\n    standardFontDataCache: new Map(),\n    globalImageCache: new Map(),\n    systemFontCache: new Map(),\n  });\n  const properties = {\n    composite: true,\n    cMap: { builtInCMap: false },\n    firstChar: 32,\n    lastChar: 127,\n    // Intentionally omitting cidSystemInfo to simulate problematic PDFs.\n  };\n  const toUnicodeMap = await evaluator.buildToUnicode(properties);\n  if (typeof toUnicodeMap.lookup !== \"function\") {\n    throw new Error(\"toUnicodeMap.lookup is not a function\");\n  }\n  const char = toUnicodeMap.lookup(65);\n  if (char !== \"A\") {\n    throw new Error(`Expected \"A\" for char code 65 but got \"${char}\"`);\n  }\n});",
    "i5_gpt-4o": "it(\"should handle missing cidSystemInfo gracefully in composite fonts\", async () => {\n  const { createIdFactory } = await import(\"./test_utils.js\");\n  const evaluator = new (await import(\"../../src/core/evaluator.js\")).PartialEvaluator({\n    xref: {},\n    handler: {},\n    pageIndex: 0,\n    idFactory: createIdFactory(),\n    fontCache: new Map(),\n    builtInCMapCache: new Map(),\n    standardFontDataCache: new Map(),\n    globalImageCache: new Map(),\n    systemFontCache: new Map(),\n  });\n  const properties = {\n    composite: true,\n    cMap: { builtInCMap: false },\n    firstChar: 32,\n    lastChar: 127,\n    // Intentionally omitting cidSystemInfo to simulate problematic PDFs.\n  };\n  const toUnicodeMap = await evaluator.buildToUnicode(properties);\n  if (typeof toUnicodeMap.lookup !== \"function\") {\n    throw new Error(\"toUnicodeMap.lookup is not a function\");\n  }\n  const char = toUnicodeMap.lookup(65);\n  if (char !== \"A\") {\n    throw new Error(`Expected \"A\" for char code 65 but got \"${char}\"`);\n  }\n});",
    "i5_llama-3.3-70b-versatile": "it(\"should handle missing cidSystemInfo gracefully in composite fonts\", async () => {\n  const { createIdFactory } = await import(\"./test_utils.js\");\n  const evaluator = new (await import(\"../../src/core/evaluator.js\")).PartialEvaluator({\n    xref: {},\n    handler: {},\n    pageIndex: 0,\n    idFactory: createIdFactory(),\n    fontCache: new Map(),\n    builtInCMapCache: new Map(),\n    standardFontDataCache: new Map(),\n    globalImageCache: new Map(),\n    systemFontCache: new Map(),\n  });\n  const properties = {\n    composite: true,\n    cMap: { builtInCMap: false },\n    firstChar: 32,\n    lastChar: 127,\n    // Intentionally omitting cidSystemInfo to simulate problematic PDFs.\n  };\n  const toUnicodeMap = await evaluator.buildToUnicode(properties);\n  if (typeof toUnicodeMap.lookup !== \"function\") {\n    throw new Error(\"toUnicodeMap.lookup is not a function\");\n  }\n  const char = toUnicodeMap.lookup(65);\n  if (char !== \"A\") {\n    throw new Error(`Expected \"A\" for char code 65 but got \"${char}\"`);\n  }\n});"
  },
  "17738": {
    "i1_deepseek-r1-distill-llama-70b": "it(\"should mark locked link annotations as clickable by ensuring datanoHTML is false\", async () => {\n  const { AnnotationFactory, AnnotationType } = await import(\"../../src/core/annotation.js\");\n  const dummyDict = {\n    get(key) {\n      if (key === \"Subtype\") {\n        return \"Link\";\n      }\n      return undefined;\n    }\n  };\n  const annotation = AnnotationFactory.create({\n    dict: dummyDict,\n    annotationGlobals: {},\n    rectangle: [0, 0, 10, 10],\n  });\n  if (annotation.data.annotationType !== AnnotationType.LINK) {\n    throw new Error(\"Annotation is not of type LINK\");\n  }\n  expect(annotation.data.noHTML).toBe(false);\n});\n",
    "i1_gpt-4o": "it(\"should mark locked link annotations as clickable by ensuring datanoHTML is false\", async () => {\n  const { AnnotationFactory, AnnotationType } = await import(\"../../src/core/annotation.js\");\n  const dummyDict = {\n    get(key) {\n      if (key === \"Subtype\") {\n        return \"Link\";\n      }\n      return undefined;\n    }\n  };\n  const annotation = AnnotationFactory.create({\n    dict: dummyDict,\n    annotationGlobals: {},\n    rectangle: [0, 0, 10, 10],\n  });\n  if (annotation.data.annotationType !== AnnotationType.LINK) {\n    throw new Error(\"Annotation is not of type LINK\");\n  }\n  expect(annotation.data.noHTML).toBe(false);\n});\n",
    "i1_llama-3.3-70b-versatile": "it(\"should mark locked link annotations as clickable by ensuring datanoHTML is false\", async () => {\n  const { AnnotationFactory, AnnotationType } = await import(\"../../src/core/annotation.js\");\n  const dummyDict = {\n    get(key) {\n      if (key === \"Subtype\") {\n        return \"Link\";\n      }\n      return undefined;\n    }\n  };\n  const annotation = AnnotationFactory.create({\n    dict: dummyDict,\n    annotationGlobals: {},\n    rectangle: [0, 0, 10, 10],\n  });\n  if (annotation.data.annotationType !== AnnotationType.LINK) {\n    throw new Error(\"Annotation is not of type LINK\");\n  }\n  expect(annotation.data.noHTML).toBe(false);\n});\n",
    "i1_MOCK": "it(\"should mark locked link annotations as clickable by ensuring datanoHTML is false\", async () => {\n  const { AnnotationFactory, AnnotationType } = await import(\"../../src/core/annotation.js\");\n  const dummyDict = {\n    get(key) {\n      if (key === \"Subtype\") {\n        return \"Link\";\n      }\n      return undefined;\n    }\n  };\n  const annotation = AnnotationFactory.create({\n    dict: dummyDict,\n    annotationGlobals: {},\n    rectangle: [0, 0, 10, 10],\n  });\n  if (annotation.data.annotationType !== AnnotationType.LINK) {\n    throw new Error(\"Annotation is not of type LINK\");\n  }\n  expect(annotation.data.noHTML).toBe(false);\n});\n",
    "i2_deepseek-r1-distill-llama-70b": "it(\"should mark locked link annotations as clickable by ensuring datanoHTML is false\", async () => {\n  const { AnnotationFactory, AnnotationType } = await import(\"../../src/core/annotation.js\");\n  const dummyDict = {\n    get(key) {\n      if (key === \"Subtype\") {\n        return \"Link\";\n      }\n      return undefined;\n    }\n  };\n  const annotation = AnnotationFactory.create({\n    dict: dummyDict,\n    annotationGlobals: {},\n    rectangle: [0, 0, 10, 10],\n  });\n  if (annotation.data.annotationType !== AnnotationType.LINK) {\n    throw new Error(\"Annotation is not of type LINK\");\n  }\n  expect(annotation.data.noHTML).toBe(false);\n});\n",
    "i2_gpt-4o": "it(\"should mark locked link annotations as clickable by ensuring datanoHTML is false\", async () => {\n  const { AnnotationFactory, AnnotationType } = await import(\"../../src/core/annotation.js\");\n  const dummyDict = {\n    get(key) {\n      if (key === \"Subtype\") {\n        return \"Link\";\n      }\n      return undefined;\n    }\n  };\n  const annotation = AnnotationFactory.create({\n    dict: dummyDict,\n    annotationGlobals: {},\n    rectangle: [0, 0, 10, 10],\n  });\n  if (annotation.data.annotationType !== AnnotationType.LINK) {\n    throw new Error(\"Annotation is not of type LINK\");\n  }\n  expect(annotation.data.noHTML).toBe(false);\n});\n",
    "i2_llama-3.3-70b-versatile": "it(\"should mark locked link annotations as clickable by ensuring datanoHTML is false\", async () => {\n  const { AnnotationFactory, AnnotationType } = await import(\"../../src/core/annotation.js\");\n  const dummyDict = {\n    get(key) {\n      if (key === \"Subtype\") {\n        return \"Link\";\n      }\n      return undefined;\n    }\n  };\n  const annotation = AnnotationFactory.create({\n    dict: dummyDict,\n    annotationGlobals: {},\n    rectangle: [0, 0, 10, 10],\n  });\n  if (annotation.data.annotationType !== AnnotationType.LINK) {\n    throw new Error(\"Annotation is not of type LINK\");\n  }\n  expect(annotation.data.noHTML).toBe(false);\n});\n",
    "i3_deepseek-r1-distill-llama-70b": "it(\"should mark locked link annotations as clickable by ensuring datanoHTML is false\", async () => {\n  const { AnnotationFactory, AnnotationType } = await import(\"../../src/core/annotation.js\");\n  const dummyDict = {\n    get(key) {\n      if (key === \"Subtype\") {\n        return \"Link\";\n      }\n      return undefined;\n    }\n  };\n  const annotation = AnnotationFactory.create({\n    dict: dummyDict,\n    annotationGlobals: {},\n    rectangle: [0, 0, 10, 10],\n  });\n  if (annotation.data.annotationType !== AnnotationType.LINK) {\n    throw new Error(\"Annotation is not of type LINK\");\n  }\n  expect(annotation.data.noHTML).toBe(false);\n});\n",
    "i3_gpt-4o": "it(\"should mark locked link annotations as clickable by ensuring datanoHTML is false\", async () => {\n  const { AnnotationFactory, AnnotationType } = await import(\"../../src/core/annotation.js\");\n  const dummyDict = {\n    get(key) {\n      if (key === \"Subtype\") {\n        return \"Link\";\n      }\n      return undefined;\n    }\n  };\n  const annotation = AnnotationFactory.create({\n    dict: dummyDict,\n    annotationGlobals: {},\n    rectangle: [0, 0, 10, 10],\n  });\n  if (annotation.data.annotationType !== AnnotationType.LINK) {\n    throw new Error(\"Annotation is not of type LINK\");\n  }\n  expect(annotation.data.noHTML).toBe(false);\n});\n",
    "i3_llama-3.3-70b-versatile": "it(\"should mark locked link annotations as clickable by ensuring datanoHTML is false\", async () => {\n  const { AnnotationFactory, AnnotationType } = await import(\"../../src/core/annotation.js\");\n  const dummyDict = {\n    get(key) {\n      if (key === \"Subtype\") {\n        return \"Link\";\n      }\n      return undefined;\n    }\n  };\n  const annotation = AnnotationFactory.create({\n    dict: dummyDict,\n    annotationGlobals: {},\n    rectangle: [0, 0, 10, 10],\n  });\n  if (annotation.data.annotationType !== AnnotationType.LINK) {\n    throw new Error(\"Annotation is not of type LINK\");\n  }\n  expect(annotation.data.noHTML).toBe(false);\n});\n",
    "i4_deepseek-r1-distill-llama-70b": "it(\"should mark locked link annotations as clickable by ensuring datanoHTML is false\", async () => {\n  const { AnnotationFactory, AnnotationType } = await import(\"../../src/core/annotation.js\");\n  const dummyDict = {\n    get(key) {\n      if (key === \"Subtype\") {\n        return \"Link\";\n      }\n      return undefined;\n    }\n  };\n  const annotation = AnnotationFactory.create({\n    dict: dummyDict,\n    annotationGlobals: {},\n    rectangle: [0, 0, 10, 10],\n  });\n  if (annotation.data.annotationType !== AnnotationType.LINK) {\n    throw new Error(\"Annotation is not of type LINK\");\n  }\n  expect(annotation.data.noHTML).toBe(false);\n});\n",
    "i4_gpt-4o": "it(\"should mark locked link annotations as clickable by ensuring datanoHTML is false\", async () => {\n  const { AnnotationFactory, AnnotationType } = await import(\"../../src/core/annotation.js\");\n  const dummyDict = {\n    get(key) {\n      if (key === \"Subtype\") {\n        return \"Link\";\n      }\n      return undefined;\n    }\n  };\n  const annotation = AnnotationFactory.create({\n    dict: dummyDict,\n    annotationGlobals: {},\n    rectangle: [0, 0, 10, 10],\n  });\n  if (annotation.data.annotationType !== AnnotationType.LINK) {\n    throw new Error(\"Annotation is not of type LINK\");\n  }\n  expect(annotation.data.noHTML).toBe(false);\n});\n",
    "i4_llama-3.3-70b-versatile": "it(\"should mark locked link annotations as clickable by ensuring datanoHTML is false\", async () => {\n  const { AnnotationFactory, AnnotationType } = await import(\"../../src/core/annotation.js\");\n  const dummyDict = {\n    get(key) {\n      if (key === \"Subtype\") {\n        return \"Link\";\n      }\n      return undefined;\n    }\n  };\n  const annotation = AnnotationFactory.create({\n    dict: dummyDict,\n    annotationGlobals: {},\n    rectangle: [0, 0, 10, 10],\n  });\n  if (annotation.data.annotationType !== AnnotationType.LINK) {\n    throw new Error(\"Annotation is not of type LINK\");\n  }\n  expect(annotation.data.noHTML).toBe(false);\n});\n",
    "i5_deepseek-r1-distill-llama-70b": "it(\"should mark locked link annotations as clickable by ensuring datanoHTML is false\", async () => {\n  const { AnnotationFactory, AnnotationType } = await import(\"../../src/core/annotation.js\");\n  const dummyDict = {\n    get(key) {\n      if (key === \"Subtype\") {\n        return \"Link\";\n      }\n      return undefined;\n    }\n  };\n  const annotation = AnnotationFactory.create({\n    dict: dummyDict,\n    annotationGlobals: {},\n    rectangle: [0, 0, 10, 10],\n  });\n  if (annotation.data.annotationType !== AnnotationType.LINK) {\n    throw new Error(\"Annotation is not of type LINK\");\n  }\n  expect(annotation.data.noHTML).toBe(false);\n});\n",
    "i5_gpt-4o": "it(\"should mark locked link annotations as clickable by ensuring datanoHTML is false\", async () => {\n  const { AnnotationFactory, AnnotationType } = await import(\"../../src/core/annotation.js\");\n  const dummyDict = {\n    get(key) {\n      if (key === \"Subtype\") {\n        return \"Link\";\n      }\n      return undefined;\n    }\n  };\n  const annotation = AnnotationFactory.create({\n    dict: dummyDict,\n    annotationGlobals: {},\n    rectangle: [0, 0, 10, 10],\n  });\n  if (annotation.data.annotationType !== AnnotationType.LINK) {\n    throw new Error(\"Annotation is not of type LINK\");\n  }\n  expect(annotation.data.noHTML).toBe(false);\n});\n",
    "i5_llama-3.3-70b-versatile": "it(\"should mark locked link annotations as clickable by ensuring datanoHTML is false\", async () => {\n  const { AnnotationFactory, AnnotationType } = await import(\"../../src/core/annotation.js\");\n  const dummyDict = {\n    get(key) {\n      if (key === \"Subtype\") {\n        return \"Link\";\n      }\n      return undefined;\n    }\n  };\n  const annotation = AnnotationFactory.create({\n    dict: dummyDict,\n    annotationGlobals: {},\n    rectangle: [0, 0, 10, 10],\n  });\n  if (annotation.data.annotationType !== AnnotationType.LINK) {\n    throw new Error(\"Annotation is not of type LINK\");\n  }\n  expect(annotation.data.noHTML).toBe(false);\n});\n"
  },
  "17768": {
    "i1_deepseek-r1-distill-llama-70b": "it(\"should record methodOfCreation as maintoolbar for free highlights\", async () => {\n  const {\n    loadAndWait,\n    getFirstSerialized,\n  } = await import(\"./test_utils.mjs\");\n  // Load a simple PDF that contains at least one page.\n  const page = await loadAndWait(\"trivial.pdf\");\n  // Simulate a free highlight creation by drawing on the page.\n  // Pick a starting point and an ending point within the page area.\n  await page.mouse.move(150, 150);\n  await page.mouse.down();\n  await page.mouse.move(250, 150);\n  await page.mouse.up();\n  // Wait a moment for the annotation to be processed and serialized.\n  const annotation = await getFirstSerialized(page);\n  if (annotation.methodOfCreation !== \"main_toolbar\") {\n    throw new Error(\n      \"Expected free highlight annotation to have methodOfCreation 'main_toolbar' but got: \" +\n        annotation.methodOfCreation\n    );\n  }\n});\n",
    "i1_gpt-4o": "it(\"should record methodOfCreation as maintoolbar for free highlights\", async () => {\n  const {\n    loadAndWait,\n    getFirstSerialized,\n  } = await import(\"./test_utils.mjs\");\n  // Load a simple PDF that contains at least one page.\n  const page = await loadAndWait(\"trivial.pdf\");\n  // Simulate a free highlight creation by drawing on the page.\n  // Pick a starting point and an ending point within the page area.\n  await page.mouse.move(150, 150);\n  await page.mouse.down();\n  await page.mouse.move(250, 150);\n  await page.mouse.up();\n  // Wait a moment for the annotation to be processed and serialized.\n  const annotation = await getFirstSerialized(page);\n  if (annotation.methodOfCreation !== \"main_toolbar\") {\n    throw new Error(\n      \"Expected free highlight annotation to have methodOfCreation 'main_toolbar' but got: \" +\n        annotation.methodOfCreation\n    );\n  }\n});\n",
    "i1_llama-3.3-70b-versatile": "it(\"should record methodOfCreation as maintoolbar for free highlights\", async () => {\n  const {\n    loadAndWait,\n    getFirstSerialized,\n  } = await import(\"./test_utils.mjs\");\n  // Load a simple PDF that contains at least one page.\n  const page = await loadAndWait(\"trivial.pdf\");\n  // Simulate a free highlight creation by drawing on the page.\n  // Pick a starting point and an ending point within the page area.\n  await page.mouse.move(150, 150);\n  await page.mouse.down();\n  await page.mouse.move(250, 150);\n  await page.mouse.up();\n  // Wait a moment for the annotation to be processed and serialized.\n  const annotation = await getFirstSerialized(page);\n  if (annotation.methodOfCreation !== \"main_toolbar\") {\n    throw new Error(\n      \"Expected free highlight annotation to have methodOfCreation 'main_toolbar' but got: \" +\n        annotation.methodOfCreation\n    );\n  }\n});\n",
    "i1_MOCK": "it(\"should record methodOfCreation as maintoolbar for free highlights\", async () => {\n  const {\n    loadAndWait,\n    getFirstSerialized,\n  } = await import(\"./test_utils.mjs\");\n  // Load a simple PDF that contains at least one page.\n  const page = await loadAndWait(\"trivial.pdf\");\n  // Simulate a free highlight creation by drawing on the page.\n  // Pick a starting point and an ending point within the page area.\n  await page.mouse.move(150, 150);\n  await page.mouse.down();\n  await page.mouse.move(250, 150);\n  await page.mouse.up();\n  // Wait a moment for the annotation to be processed and serialized.\n  const annotation = await getFirstSerialized(page);\n  if (annotation.methodOfCreation !== \"main_toolbar\") {\n    throw new Error(\n      \"Expected free highlight annotation to have methodOfCreation 'main_toolbar' but got: \" +\n        annotation.methodOfCreation\n    );\n  }\n});\n",
    "i2_deepseek-r1-distill-llama-70b": "it(\"should record methodOfCreation as maintoolbar for free highlights\", async () => {\n  const {\n    loadAndWait,\n    getFirstSerialized,\n  } = await import(\"./test_utils.mjs\");\n  // Load a simple PDF that contains at least one page.\n  const page = await loadAndWait(\"trivial.pdf\");\n  // Simulate a free highlight creation by drawing on the page.\n  // Pick a starting point and an ending point within the page area.\n  await page.mouse.move(150, 150);\n  await page.mouse.down();\n  await page.mouse.move(250, 150);\n  await page.mouse.up();\n  // Wait a moment for the annotation to be processed and serialized.\n  const annotation = await getFirstSerialized(page);\n  if (annotation.methodOfCreation !== \"main_toolbar\") {\n    throw new Error(\n      \"Expected free highlight annotation to have methodOfCreation 'main_toolbar' but got: \" +\n        annotation.methodOfCreation\n    );\n  }\n});\n",
    "i2_gpt-4o": "it(\"should record methodOfCreation as maintoolbar for free highlights\", async () => {\n  const {\n    loadAndWait,\n    getFirstSerialized,\n  } = await import(\"./test_utils.mjs\");\n  // Load a simple PDF that contains at least one page.\n  const page = await loadAndWait(\"trivial.pdf\");\n  // Simulate a free highlight creation by drawing on the page.\n  // Pick a starting point and an ending point within the page area.\n  await page.mouse.move(150, 150);\n  await page.mouse.down();\n  await page.mouse.move(250, 150);\n  await page.mouse.up();\n  // Wait a moment for the annotation to be processed and serialized.\n  const annotation = await getFirstSerialized(page);\n  if (annotation.methodOfCreation !== \"main_toolbar\") {\n    throw new Error(\n      \"Expected free highlight annotation to have methodOfCreation 'main_toolbar' but got: \" +\n        annotation.methodOfCreation\n    );\n  }\n});\n",
    "i2_llama-3.3-70b-versatile": "it(\"should record methodOfCreation as maintoolbar for free highlights\", async () => {\n  const {\n    loadAndWait,\n    getFirstSerialized,\n  } = await import(\"./test_utils.mjs\");\n  // Load a simple PDF that contains at least one page.\n  const page = await loadAndWait(\"trivial.pdf\");\n  // Simulate a free highlight creation by drawing on the page.\n  // Pick a starting point and an ending point within the page area.\n  await page.mouse.move(150, 150);\n  await page.mouse.down();\n  await page.mouse.move(250, 150);\n  await page.mouse.up();\n  // Wait a moment for the annotation to be processed and serialized.\n  const annotation = await getFirstSerialized(page);\n  if (annotation.methodOfCreation !== \"main_toolbar\") {\n    throw new Error(\n      \"Expected free highlight annotation to have methodOfCreation 'main_toolbar' but got: \" +\n        annotation.methodOfCreation\n    );\n  }\n});\n",
    "i3_deepseek-r1-distill-llama-70b": "it(\"should record methodOfCreation as maintoolbar for free highlights\", async () => {\n  const {\n    loadAndWait,\n    getFirstSerialized,\n  } = await import(\"./test_utils.mjs\");\n  // Load a simple PDF that contains at least one page.\n  const page = await loadAndWait(\"trivial.pdf\");\n  // Simulate a free highlight creation by drawing on the page.\n  // Pick a starting point and an ending point within the page area.\n  await page.mouse.move(150, 150);\n  await page.mouse.down();\n  await page.mouse.move(250, 150);\n  await page.mouse.up();\n  // Wait a moment for the annotation to be processed and serialized.\n  const annotation = await getFirstSerialized(page);\n  if (annotation.methodOfCreation !== \"main_toolbar\") {\n    throw new Error(\n      \"Expected free highlight annotation to have methodOfCreation 'main_toolbar' but got: \" +\n        annotation.methodOfCreation\n    );\n  }\n});\n",
    "i3_gpt-4o": "it(\"should record methodOfCreation as maintoolbar for free highlights\", async () => {\n  const {\n    loadAndWait,\n    getFirstSerialized,\n  } = await import(\"./test_utils.mjs\");\n  // Load a simple PDF that contains at least one page.\n  const page = await loadAndWait(\"trivial.pdf\");\n  // Simulate a free highlight creation by drawing on the page.\n  // Pick a starting point and an ending point within the page area.\n  await page.mouse.move(150, 150);\n  await page.mouse.down();\n  await page.mouse.move(250, 150);\n  await page.mouse.up();\n  // Wait a moment for the annotation to be processed and serialized.\n  const annotation = await getFirstSerialized(page);\n  if (annotation.methodOfCreation !== \"main_toolbar\") {\n    throw new Error(\n      \"Expected free highlight annotation to have methodOfCreation 'main_toolbar' but got: \" +\n        annotation.methodOfCreation\n    );\n  }\n});\n",
    "i3_llama-3.3-70b-versatile": "it(\"should record methodOfCreation as maintoolbar for free highlights\", async () => {\n  const {\n    loadAndWait,\n    getFirstSerialized,\n  } = await import(\"./test_utils.mjs\");\n  // Load a simple PDF that contains at least one page.\n  const page = await loadAndWait(\"trivial.pdf\");\n  // Simulate a free highlight creation by drawing on the page.\n  // Pick a starting point and an ending point within the page area.\n  await page.mouse.move(150, 150);\n  await page.mouse.down();\n  await page.mouse.move(250, 150);\n  await page.mouse.up();\n  // Wait a moment for the annotation to be processed and serialized.\n  const annotation = await getFirstSerialized(page);\n  if (annotation.methodOfCreation !== \"main_toolbar\") {\n    throw new Error(\n      \"Expected free highlight annotation to have methodOfCreation 'main_toolbar' but got: \" +\n        annotation.methodOfCreation\n    );\n  }\n});\n",
    "i4_deepseek-r1-distill-llama-70b": "it(\"should record methodOfCreation as maintoolbar for free highlights\", async () => {\n  const {\n    loadAndWait,\n    getFirstSerialized,\n  } = await import(\"./test_utils.mjs\");\n  // Load a simple PDF that contains at least one page.\n  const page = await loadAndWait(\"trivial.pdf\");\n  // Simulate a free highlight creation by drawing on the page.\n  // Pick a starting point and an ending point within the page area.\n  await page.mouse.move(150, 150);\n  await page.mouse.down();\n  await page.mouse.move(250, 150);\n  await page.mouse.up();\n  // Wait a moment for the annotation to be processed and serialized.\n  const annotation = await getFirstSerialized(page);\n  if (annotation.methodOfCreation !== \"main_toolbar\") {\n    throw new Error(\n      \"Expected free highlight annotation to have methodOfCreation 'main_toolbar' but got: \" +\n        annotation.methodOfCreation\n    );\n  }\n});\n",
    "i4_gpt-4o": "it(\"should record methodOfCreation as maintoolbar for free highlights\", async () => {\n  const {\n    loadAndWait,\n    getFirstSerialized,\n  } = await import(\"./test_utils.mjs\");\n  // Load a simple PDF that contains at least one page.\n  const page = await loadAndWait(\"trivial.pdf\");\n  // Simulate a free highlight creation by drawing on the page.\n  // Pick a starting point and an ending point within the page area.\n  await page.mouse.move(150, 150);\n  await page.mouse.down();\n  await page.mouse.move(250, 150);\n  await page.mouse.up();\n  // Wait a moment for the annotation to be processed and serialized.\n  const annotation = await getFirstSerialized(page);\n  if (annotation.methodOfCreation !== \"main_toolbar\") {\n    throw new Error(\n      \"Expected free highlight annotation to have methodOfCreation 'main_toolbar' but got: \" +\n        annotation.methodOfCreation\n    );\n  }\n});\n",
    "i4_llama-3.3-70b-versatile": "it(\"should record methodOfCreation as maintoolbar for free highlights\", async () => {\n  const {\n    loadAndWait,\n    getFirstSerialized,\n  } = await import(\"./test_utils.mjs\");\n  // Load a simple PDF that contains at least one page.\n  const page = await loadAndWait(\"trivial.pdf\");\n  // Simulate a free highlight creation by drawing on the page.\n  // Pick a starting point and an ending point within the page area.\n  await page.mouse.move(150, 150);\n  await page.mouse.down();\n  await page.mouse.move(250, 150);\n  await page.mouse.up();\n  // Wait a moment for the annotation to be processed and serialized.\n  const annotation = await getFirstSerialized(page);\n  if (annotation.methodOfCreation !== \"main_toolbar\") {\n    throw new Error(\n      \"Expected free highlight annotation to have methodOfCreation 'main_toolbar' but got: \" +\n        annotation.methodOfCreation\n    );\n  }\n});\n",
    "i5_deepseek-r1-distill-llama-70b": "it(\"should record methodOfCreation as maintoolbar for free highlights\", async () => {\n  const {\n    loadAndWait,\n    getFirstSerialized,\n  } = await import(\"./test_utils.mjs\");\n  // Load a simple PDF that contains at least one page.\n  const page = await loadAndWait(\"trivial.pdf\");\n  // Simulate a free highlight creation by drawing on the page.\n  // Pick a starting point and an ending point within the page area.\n  await page.mouse.move(150, 150);\n  await page.mouse.down();\n  await page.mouse.move(250, 150);\n  await page.mouse.up();\n  // Wait a moment for the annotation to be processed and serialized.\n  const annotation = await getFirstSerialized(page);\n  if (annotation.methodOfCreation !== \"main_toolbar\") {\n    throw new Error(\n      \"Expected free highlight annotation to have methodOfCreation 'main_toolbar' but got: \" +\n        annotation.methodOfCreation\n    );\n  }\n});\n",
    "i5_gpt-4o": "it(\"should record methodOfCreation as maintoolbar for free highlights\", async () => {\n  const {\n    loadAndWait,\n    getFirstSerialized,\n  } = await import(\"./test_utils.mjs\");\n  // Load a simple PDF that contains at least one page.\n  const page = await loadAndWait(\"trivial.pdf\");\n  // Simulate a free highlight creation by drawing on the page.\n  // Pick a starting point and an ending point within the page area.\n  await page.mouse.move(150, 150);\n  await page.mouse.down();\n  await page.mouse.move(250, 150);\n  await page.mouse.up();\n  // Wait a moment for the annotation to be processed and serialized.\n  const annotation = await getFirstSerialized(page);\n  if (annotation.methodOfCreation !== \"main_toolbar\") {\n    throw new Error(\n      \"Expected free highlight annotation to have methodOfCreation 'main_toolbar' but got: \" +\n        annotation.methodOfCreation\n    );\n  }\n});\n",
    "i5_llama-3.3-70b-versatile": "it(\"should record methodOfCreation as maintoolbar for free highlights\", async () => {\n  const {\n    loadAndWait,\n    getFirstSerialized,\n  } = await import(\"./test_utils.mjs\");\n  // Load a simple PDF that contains at least one page.\n  const page = await loadAndWait(\"trivial.pdf\");\n  // Simulate a free highlight creation by drawing on the page.\n  // Pick a starting point and an ending point within the page area.\n  await page.mouse.move(150, 150);\n  await page.mouse.down();\n  await page.mouse.move(250, 150);\n  await page.mouse.up();\n  // Wait a moment for the annotation to be processed and serialized.\n  const annotation = await getFirstSerialized(page);\n  if (annotation.methodOfCreation !== \"main_toolbar\") {\n    throw new Error(\n      \"Expected free highlight annotation to have methodOfCreation 'main_toolbar' but got: \" +\n        annotation.methodOfCreation\n    );\n  }\n});\n"
  },
  "17788": {
    "i1_deepseek-r1-distill-llama-70b": "it(\"should expose highlighted text to screen readers\", async () => {\n  const { PDFDocument } = await import(\"../../src/display/api.js\");\n  const pdf = await build({\n    url: \"test.pdf\",\n    cMapUrl: \"https://cdn.jsdelivr.net/npm/pdfjs-dist@2.7.570/build/generic/web/cmaps/\",\n    workerSrc: \"../../src/worker.js\",\n  });\n  const page = await pdf.getPage(1);\n  const textLayer = await page.getTextContent();\n\n  const container = document.createElement(\"div\");\n  const editorUI = new AnnotationEditorUIManager(\n    container,\n    null,\n    null,\n    null,\n    pdf,\n    null,\n    null,\n    null\n  );\n\n  editorUI.highlightSelection();\n\n  const selection = document.getSelection();\n  const markElement = container.querySelector(\".visuallyHidden\");\n\n  expect(markElement).toBeTruthy();\n  expect(markElement.textContent).toBe(\"highlighted text\");\n});",
    "i1_gpt-4o": "it(\"should read highlighted text during editing inside a PDF\", async () => {\n  const { AnnotationEditorUIManager } = await import(\"../../src/display/editor/tools.js\");\n  const { HighlightEditor } = await import(\"../../src/display/editor/highlight.js\");\n  const { EventBus } = await import(\"../../web/event_utils.js\");\n\n  const eventBus = new EventBus();\n  const container = document.createElement(\"div\");\n  const viewer = document.createElement(\"div\");\n  container.appendChild(viewer);\n\n  const uiManager = new AnnotationEditorUIManager(container, viewer, null, eventBus, null, null, null, null);\n  uiManager.#mode = AnnotationEditorType.HIGHLIGHT;\n\n  const textLayer = document.createElement(\"div\");\n  textLayer.className = \"textLayer\";\n  viewer.appendChild(textLayer);\n\n  const textNode = document.createTextNode(\"Highlighted text\");\n  const span = document.createElement(\"span\");\n  span.appendChild(textNode);\n  textLayer.appendChild(span);\n\n  const selection = window.getSelection();\n  const range = document.createRange();\n  range.setStart(textNode, 0);\n  range.setEnd(textNode, textNode.length);\n  selection.removeAllRanges();\n  selection.addRange(range);\n\n  uiManager.highlightSelection();\n\n  const highlightEditor = new HighlightEditor({\n    anchorNode: textNode,\n    anchorOffset: 0,\n    focusNode: textNode,\n    focusOffset: textNode.length,\n    text: \"Highlighted text\",\n  });\n\n  const div = highlightEditor.render();\n  const mark = div.querySelector(\"mark\");\n  const actualText = mark ? mark.textContent : null;\n\n  expect(actualText).toBe(\"Highlighted text\");\n});",
    "i1_llama-3.3-70b-versatile": "it(\"should read highlighted text during editing inside a PDF\", async () => {\n  const { PDFDocument, PDFPageProxy } = await import(\"../../src/display/api.js\");\n  const { DOMSVGFactory } = await import(\"../../src/display/display_utils.js\");\n  const { AnnotationEditorUIManager } = await import(\"../../src/display/editor/tools.js\");\n  const { HighlightEditor } = await import(\"../../src/display/editor/highlight.js\");\n  const pdfDocument = await PDFDocument.load(await fetch(\"path_to_test_pdf.pdf\").then(response => response.arrayBuffer()));\n  const pdfPage = await pdfDocument.getPage(1);\n  const pdfPageProxy = new PDFPageProxy(pdfPage);\n  const annotationEditorUIManager = new AnnotationEditorUIManager(null, null, null, null, pdfDocument, null, null, null);\n  const highlightEditor = new HighlightEditor({ anchorNode: null, anchorOffset: 0, focusNode: null, focusOffset: 0, boxes: null, methodOfCreation: \"\" });\n  const div = highlightEditor.render();\n  const mark = div.querySelector(\"mark\");\n  const text = \"Highlighted text\";\n  mark.append(document.createTextNode(text));\n  const voiceOverText = await getVoiceOverText(div);\n  expect(voiceOverText).toBe(text);\n});\n\nasync function getVoiceOverText(element) {\n  // This function should return the text that would be read by Voice Over\n  // For the purpose of this test, we assume that the text is the text content of the mark element\n  return element.querySelector(\"mark\").textContent;\n}",
    "i2_deepseek-r1-distill-llama-70b": "it(\"should expose highlighted text to screen readers\", async () => {\n  const { PDFDocument } = await import(\"../../src/core/document.js\");\n  const { PDFPage } = await import(\"../../src/core/document.js\");\n  const { TextLayerBuilder } = await import(\"../../src/display/text_layer.js\");\n  const { DrawLayer } = await import(\"../../src/display/draw_layer.js\");\n  const { HighlightEditor } = await import(\"../../src/display/editor/highlight.js\");\n\n  // Create a test PDF with text\n  const pdf = new PDFDocument({\n    content: \"q\\nBT\\n/F0 24 Tf\\n(Hello World) Tj\\nET\\nQ\",\n    pages: [{ content: \"\" }],\n  });\n\n  // Create a mock DOM environment\n  const { JSDOM } = await import(\"jsdom\");\n  const dom = new JSDOM();\n  globalThis.document = dom.window.document;\n  globalThis.window = dom.window;\n\n  // Render the PDF page\n  const page = pdf.getPage(0);\n  const textLayer = new TextLayerBuilder().build(page, { viewport: page.getViewport({ scale: 1 }) });\n\n  // Create and add highlight\n  const selection = window.getSelection();\n  selection.removeAllRanges();\n  const range = document.createRange();\n  range.selectNode(textLayer.firstChild);\n  selection.addRange(range);\n\n  const highlight = new HighlightEditor({\n    anchorNode: selection.anchorNode,\n    anchorOffset: selection.anchorOffset,\n    focusNode: selection.focusNode,\n    focusOffset: selection.focusOffset,\n    boxes: [],\n    color: \"#FFFF00\",\n    methodOfCreation: \"mouse\",\n  });\n\n  // Verify the text is properly exposed\n  const markElement = highlight.div.querySelector(\"mark\");\n  expect(markElement).toBeTruthy();\n  expect(markElement.className).toContain(\"visuallyHidden\");\n\n  // Verify ARIA attributes are set\n  const svg = document.querySelector(\"svg\");\n  expect(svg.getAttribute(\"aria-hidden\")).toBe(\"true\");\n\n  const highlightDiv = highlight.div.querySelector(\".internal\");\n  expect(highlightDiv.getAttribute(\"aria-hidden\")).toBe(\"true\");\n});",
    "i2_gpt-4o": "it(\"should make highlighted text accessible to Voice Over\", async () => {\n  const { AnnotationEditorUIManager } = await import(\"../../src/display/editor/tools.js\");\n  const { HighlightEditor } = await import(\"../../src/display/editor/highlight.js\");\n  const { EventBus } = await import(\"../../web/event_utils.js\");\n\n  const eventBus = new EventBus();\n  const container = document.createElement(\"div\");\n  const viewer = document.createElement(\"div\");\n  const pdfDocument = { annotationStorage: {}, filterFactory: {} };\n  const uiManager = new AnnotationEditorUIManager(container, viewer, null, eventBus, pdfDocument, null, null, null);\n\n  const textLayer = document.createElement(\"div\");\n  textLayer.className = \"textLayer\";\n  const textNode = document.createTextNode(\"Sample text\");\n  textLayer.appendChild(textNode);\n  document.body.appendChild(textLayer);\n\n  const selection = window.getSelection();\n  const range = document.createRange();\n  range.selectNodeContents(textNode);\n  selection.removeAllRanges();\n  selection.addRange(range);\n\n  uiManager.highlightSelection();\n\n  const highlightEditor = new HighlightEditor({\n    anchorNode: textNode,\n    anchorOffset: 0,\n    focusNode: textNode,\n    focusOffset: textNode.length,\n    boxes: [],\n    methodOfCreation: \"\",\n  });\n\n  const div = highlightEditor.render();\n  const mark = div.querySelector(\"mark\");\n  const isTextAccessible = mark && mark.textContent === \"Sample text\" && mark.className === \"visuallyHidden\";\n\n  expect(isTextAccessible).toBe(true);\n\n  document.body.removeChild(textLayer);\n});",
    "i2_llama-3.3-70b-versatile": "it(\"should read highlighted text during editing inside a PDF\", async () => {\n  const { PDFPageProxy } = await import(\"../../src/display/api.js\");\n  const { PDFDocumentProxy } = await import(\"../../src/display/api.js\");\n  const { AnnotationEditorUIManager } = await import(\"../../src/display/editor/tools.js\");\n  const { PDFViewer } = await import(\"../../web/pdf_viewer.js\");\n  const { PDFDocumentLoadingTask } = await import(\"../../src/display/api.js\");\n\n  const pdfDocument = await PDFDocumentLoadingTask.import({\n    cMapUrl: \"../../src/core/cmap.js\",\n    cMapPacked: true,\n    fontExtraProperties: {},\n    ignoreErrors: false,\n    isEvalSupported: false,\n    maxImageSize: 1024 * 1024 * 10,\n    onFetchStart: () => {},\n    onFetchEnd: () => {},\n    pdfBug: {},\n    verbosity: 0,\n  }, \"../../web/test_files/annotation_test.pdf\");\n\n  const pdfViewer = new PDFViewer({\n    container: document.createElement(\"div\"),\n    eventBus: {\n      _on: () => {},\n      _off: () => {},\n      dispatch: () => {},\n    },\n    renderer: \"canvas\",\n    useOnlyCssZoom: false,\n  });\n\n  const annotationEditorUIManager = new AnnotationEditorUIManager(\n    document.createElement(\"div\"),\n    pdfViewer,\n    null,\n    {\n      _on: () => {},\n      _off: () => {},\n      dispatch: () => {},\n    },\n    pdfDocument,\n    null,\n    null,\n    null\n  );\n\n  const page = await pdfDocument.getPage(1);\n  const textContent = await page.getTextContent();\n  const textLayer = pdfViewer.textLayerFactory.createTextLayer({\n    container: document.createElement(\"div\"),\n    textContent,\n    viewport: page.getViewport({ scale: 1 }),\n  });\n\n  const selection = window.getSelection();\n  selection.removeAllRanges();\n  const range = document.createRange();\n  range.setStart(textLayer.textDivs[0], 0);\n  range.setEnd(textLayer.textDivs[0], 1);\n  selection.addRange(range);\n\n  annotationEditorUIManager.highlightSelection();\n\n  const highlightedText = await new Promise((resolve) => {\n    const intervalId = setInterval(() => {\n      const highlightedText = textLayer.textDivs[0].textContent;\n      if (highlightedText) {\n        clearInterval(intervalId);\n        resolve(highlightedText);\n      }\n    }, 100);\n  });\n\n  const expectedText = textLayer.textDivs[0].textContent;\n  expect(highlightedText).toBe(expectedText);\n});",
    "i3_deepseek-r1-distill-llama-70b": "it(\"should allow Voice Over to read highlighted text during editing\", async () => {\n  const { PDFDocument, PDFWorker } = await import(\"../../src/display/api.js\");\n  const { DOMSVGFactory } = await import(\"../../src/display/display_utils.js\");\n  const { HighlightEditor } = await import(\"../../src/display/editor/highlight.js\");\n  const { AnnotationEditorUIManager } = await import(\"../../src/display/editor/tools.js\");\n  const { renderTextLayer } = await import(\"../../src/display/text_layer.js\");\n\n  // Setup Puppeteer and get accessibility tree\n  const { _accessibility } = await import(\"puppeteer/frames\");\n  const browser = await require(\"puppeteer\").launch();\n  const page = await browser.newPage();\n  await page.setContent(`\n    <html>\n      <body>\n        <div class=\"textLayer\" style=\"width: 400px; height: 300px;\">\n          <p id=\"text\">Sample text for highlighting</p>\n        </div>\n      </body>\n    </html>\n  `);\n\n  // Create highlight editor\n  const textLayer = page.querySelector(\".textLayer\");\n  const highlightEditor = new HighlightEditor({\n    anchorNode: textLayer.querySelector(\"#text\").firstChild,\n    anchorOffset: 0,\n    focusNode: textLayer.querySelector(\"#text\").firstChild,\n    focusOffset: 10,\n    boxes: [{ x: 0, y: 0, width: 100, height: 20 }]\n  });\n\n  // Apply highlight\n  highlightEditor.render();\n  page.addScriptTag({ content: highlightEditor.render().outerHTML });\n\n  // Get accessibility tree\n  const accessibilityTree = await _accessibility.getAccessibilityTree(page);\n  const highlightedText = accessibilityTree.find(\n    node => node.role === \"mark\" && node.name === \"Sample text for highlighting\"\n  );\n\n  expect(highlightedText).toBeTruthy();\n});",
    "i3_gpt-4o": "it(\"should read highlighted text during editing inside a PDF\", async () => {\n  const { HighlightEditor } = await import(\"../../src/display/editor/highlight.js\");\n  const { AnnotationEditorUIManager } = await import(\"../../src/display/editor/tools.js\");\n  const { EventBus } = await import(\"../../web/event_utils.js\");\n\n  const eventBus = new EventBus();\n  const uiManager = new AnnotationEditorUIManager(null, null, null, eventBus, null, null, \"yellow=Yellow,green=Green\");\n  HighlightEditor.initialize(null, uiManager);\n\n  const params = {\n    color: \"yellow\",\n    opacity: 1,\n    boxes: [{ x: 0, y: 0, width: 1, height: 1 }],\n    anchorNode: document.createTextNode(\"highlighted text\"),\n    anchorOffset: 0,\n    focusNode: document.createTextNode(\"highlighted text\"),\n    focusOffset: 16,\n    text: \"highlighted text\"\n  };\n\n  const editor = new HighlightEditor(params);\n  const div = editor.render();\n  document.body.appendChild(div);\n\n  const mark = div.querySelector(\"mark\");\n  const isAriaHidden = mark.getAttribute(\"aria-hidden\") === \"true\";\n  const isTextVisible = window.getComputedStyle(mark).visibility !== \"hidden\";\n\n  document.body.removeChild(div);\n\n  expect(isAriaHidden).toBe(false);\n  expect(isTextVisible).toBe(true);\n});",
    "i3_llama-3.3-70b-versatile": "it(\"should make Voice Over read highlighted text during editing inside a PDF\", async () => {\n  const { PDFDocument, Page } = await import(\"../../src/core/document.js\");\n  const { build } = await import(\"../../src/display/api.js\");\n  const { DOMSVGFactory } = await import(\"../../src/display/display_utils.js\");\n  const { DrawLayer } = await import(\"../../src/display/draw_layer.js\");\n  const { HighlightEditor } = await import(\"../../src/display/editor/highlight.js\");\n  const { AnnotationEditorUIManager } = await import(\"../../src/display/editor/tools.js\");\n\n  const pdfDoc = await build({ url: \"path/to/example.pdf\" });\n  const page = await pdfDoc.getPage(1);\n  const svgFactory = new DOMSVGFactory();\n  const drawLayer = new DrawLayer({ pageIndex: 0 });\n  const highlightEditor = new HighlightEditor({});\n\n  const text = \"Example text to be highlighted\";\n  const selection = { anchorNode: { nodeType: 3, data: text }, anchorOffset: 0, focusNode: { nodeType: 3, data: text }, focusOffset: text.length };\n  const params = { boxes: [{ x: 0, y: 0, width: 100, height: 100 }], text, anchorNode: selection.anchorNode, anchorOffset: selection.anchorOffset, focusNode: selection.focusNode, focusOffset: selection.focusOffset };\n\n  drawLayer.setParent(document.body);\n  const div = highlightEditor.render();\n  document.body.appendChild(div);\n  highlightEditor.setParent({ drawLayer });\n\n  const mark = div.querySelector(\"mark\");\n  expect(mark).not.toBeNull();\n  expect(mark.textContent).toBe(text);\n  expect(mark.className).toBe(\"visuallyHidden\");\n});",
    "i4_deepseek-r1-distill-llama-70b": "it(\"should expose highlighted text to screen readers\", async () => {\n  const { HighlightEditor } = await import(\"../../src/display/editor/highlight.js\");\n  const { DrawLayer } = await import(\"../../src/display/draw_layer.js\");\n\n  // Setup DOM\n  const container = document.createElement(\"div\");\n  const textLayer = document.createElement(\"div\");\n  textLayer.className = \"textLayer\";\n  container.appendChild(textLayer);\n\n  // Setup editor\n  const editor = new HighlightEditor({\n    anchorNode: document.createElement(\"div\"),\n    anchorOffset: 0,\n    focusNode: document.createElement(\"div\"),\n    focusNode: 0,\n    boxes: [{ x: 0, y: 0, width: 1, height: 1 }],\n    text: \"Highlighted text\"\n  });\n\n  // Render editor\n  const div = editor.render();\n  container.appendChild(div);\n\n  // Verify ARIA attributes and content\n  const mark = div.querySelector(\"mark.visuallyHidden\");\n  const svg = div.querySelector(\"svg\");\n\n  expect(mark).toBeTruthy();\n  expect(mark.textContent).toBe(\"Highlighted text\");\n  expect(svg.getAttribute(\"aria-hidden\")).toBe(\"true\");\n});",
    "i4_gpt-4o": "it(\"should read highlighted text during editing inside a PDF\", async () => {\n  const { HighlightEditor } = await import(\"../../src/display/editor/highlight.js\");\n  const { AnnotationEditorUIManager } = await import(\"../../src/display/editor/tools.js\");\n\n  const mockParent = {\n    drawLayer: {\n      highlight: jest.fn(() => ({ id: 1, clipPathId: \"clipPathId\" })),\n      highlightOutline: jest.fn(() => 2),\n      remove: jest.fn(),\n      show: jest.fn(),\n      addClass: jest.fn(),\n      removeClass: jest.fn(),\n    },\n    addUndoableEditor: jest.fn(),\n    add: jest.fn(),\n    unselect: jest.fn(),\n    viewport: { rotation: 0 },\n    scale: 1,\n    pageDimensions: [100, 100],\n  };\n\n  const mockUIManager = new AnnotationEditorUIManager(\n    document.createElement(\"div\"),\n    document.createElement(\"div\"),\n    null,\n    { _on: jest.fn(), _off: jest.fn(), dispatch: jest.fn() },\n    { annotationStorage: new Map(), filterFactory: { addHCMFilter: jest.fn() } },\n    null,\n    \"yellow=#FFFF00,green=#00FF00\"\n  );\n\n  const highlightEditor = new HighlightEditor({\n    parent: mockParent,\n    uiManager: mockUIManager,\n    color: \"#FFFF00\",\n    opacity: 1,\n    boxes: [{ x: 0, y: 0, width: 1, height: 1 }],\n    anchorNode: document.createTextNode(\"highlighted text\"),\n    anchorOffset: 0,\n    focusNode: document.createTextNode(\"highlighted text\"),\n    focusOffset: 16,\n    methodOfCreation: \"test\",\n  });\n\n  const div = highlightEditor.render();\n  const mark = div.querySelector(\"mark\");\n  const isAriaHidden = mark.getAttribute(\"aria-hidden\");\n  const isTextVisible = mark.textContent === \"highlighted text\";\n\n  expect(isAriaHidden).toBeNull();\n  expect(isTextVisible).toBe(true);\n});",
    "i4_llama-3.3-70b-versatile": "it(\"should read highlighted text during editing inside a PDF\", async () => {\n  const { PDFPageView } = await import(\"../../web/pdf_page_view.js\");\n  const { PDFViewer } = await import(\"../../web/pdf_viewer.js\");\n  const { AnnotationEditorUIManager } = await import(\"../../src/display/editor/tools.js\");\n  const { HighlightEditor } = await import(\"../../src/display/editor/highlight.js\");\n  const { PDFDocumentLoadingTask } = await import(\"../../src/display/api.js\");\n\n  const pdfDocument = await PDFDocumentLoadingTask.import(\n    `${await import(\"../../web/test_utils.js\").then(m => m.TEST_PDFS_PATH)}/highlight.pdf`,\n    null\n  );\n\n  const viewer = new PDFViewer({\n    container: document.createElement(\"div\"),\n    viewerCss: \"\",\n  });\n\n  const annotationEditorUIManager = new AnnotationEditorUIManager(\n    viewer.container,\n    viewer,\n    null,\n    null,\n    pdfDocument,\n    null,\n    null,\n    null\n  );\n\n  const pageView = new PDFPageView({\n    container: viewer.container,\n    annotationEditorUIManager,\n    pdfPage: pdfDocument.pages[0],\n    renderInteractiveForms: false,\n    viewport: pdfDocument.pages[0].getViewport(1),\n  });\n\n  viewer._setPageView(pageView);\n\n  const highlightEditor = new HighlightEditor({\n    pageIndex: 0,\n    boxes: [{ x: 0, y: 0, width: 1, height: 1 }],\n    anchorNode: null,\n    anchorOffset: 0,\n    focusNode: null,\n    focusOffset: 0,\n  });\n\n  annotationEditorUIManager.addEditor(highlightEditor);\n\n  const text = \"This is a highlighted text.\";\n  highlightEditor.#text = text;\n\n  const div = highlightEditor.render();\n  pageView.div.appendChild(div);\n\n  const mark = div.querySelector(\"mark\");\n  const textNode = mark.querySelector(\"span\");\n\n  expect(textNode.textContent).toBe(text);\n});",
    "i5_deepseek-r1-distill-llama-70b": "it(\"should include highlighted text for screen readers when editing\", () => {\n  const { HighlightEditor } = require(\"../../src/display/editor/highlight.js\");\n  const editor = new HighlightEditor({\n    text: \"Test Highlight\",\n    boxes: [],\n    methodOfCreation: \"highlight\"\n  });\n\n  const renderedEditor = editor.render();\n  const markElement = renderedEditor.querySelector(\"mark.visuallyHidden\");\n\n  expect(markElement).toBeTruthy();\n  expect(markElement.textContent).toBe(\"Test Highlight\");\n\n  const highlightDiv = renderedEditor.querySelector(\"div.internal\");\n  expect(highlightDiv.getAttribute(\"aria-hidden\")).toBe(\"true\");\n});",
    "i5_gpt-4o": "it(\"should read highlighted text during editing inside a PDF\", async () => {\n  const { PDFDocumentProxy, getDocument } = await import(\"../../src/display/api.js\");\n  const { AnnotationEditorUIManager } = await import(\"../../src/display/editor/tools.js\");\n  const { AnnotationEditorLayer } = await import(\"../../src/display/editor/annotation_editor_layer.js\");\n\n  const loadingTask = getDocument({ url: \"test.pdf\" });\n  const pdfDocument = await loadingTask.promise;\n  const pdfPage = await pdfDocument.getPage(1);\n\n  const annotationEditorLayer = new AnnotationEditorLayer({\n    pageDiv: document.createElement(\"div\"),\n    pdfPage,\n    viewport: pdfPage.getViewport({ scale: 1.0 }),\n  });\n\n  const uiManager = new AnnotationEditorUIManager({\n    container: document.createElement(\"div\"),\n    eventBus: { dispatch: () => {} },\n  });\n\n  annotationEditorLayer.uiManager = uiManager;\n  await annotationEditorLayer.render();\n\n  const highlightEditor = uiManager.getEditor(\"highlight\");\n  highlightEditor.setText(\"Sample highlighted text\");\n\n  const expectedText = \"Sample highlighted text\";\n  const actualText = highlightEditor.getText();\n\n  expect(actualText).toBe(expectedText);\n});",
    "i5_llama-3.3-70b-versatile": "it(\"should read highlighted text during editing inside a PDF\", async () => {\n  const { PDFDocument, PDFPageProxy } = await import(\"../../src/display/api.js\");\n  const { AnnotationEditorUIManager } = await import(\"../../src/display/editor/tools.js\");\n  const { PDFViewer } = await import(\"../../web/pdf_viewer.js\");\n\n  const pdfViewer = new PDFViewer();\n  const pdfDocument = await PDFDocument.load(await fetch(\"path_to_test_pdf.pdf\").then(response => response.arrayBuffer()));\n  const pdfPageProxy = pdfDocument.getPage(1);\n  const annotationEditorUIManager = new AnnotationEditorUIManager(pdfPageProxy, pdfViewer);\n\n  const selection = {\n    anchorNode: { nodeType: Node.TEXT_NODE, data: \"Hello\" },\n    anchorOffset: 0,\n    focusNode: { nodeType: Node.TEXT_NODE, data: \"World\" },\n    focusOffset: 5,\n    toString: () => \"Hello World\",\n  };\n\n  const expectedText = \"Hello World\";\n  const actualText = await annotationEditorUIManager.createHighlight(selection);\n\n  expect(actualText).toBe(expectedText);\n});"
  },
  "17795": {
    "i1_deepseek-r1-distill-llama-70b": "it(\"should handle inline images without closing EI\", async () => {\n  const { PartialEvaluator, OperatorList, Dict, Name, Stream } = await import(\"../../src/core/evaluator.js\");\n  const { StringStream } = await import(\"../../src/core/stream.js\");\n\n  const xref = new XRefMock();\n  const options = {\n    ignoreErrors: false,\n    isOffscreenCanvasSupported: false,\n  };\n\n  const evaluator = new PartialEvaluator({\n    xref,\n    handler: null,\n    pageIndex: 0,\n    idFactory: createIdFactory(),\n    fontCache: null,\n    builtInCMapCache: null,\n    standardFontDataCache: null,\n    globalImageCache: null,\n    systemFontCache: null,\n    options,\n  });\n\n  const operatorList = new OperatorList();\n  const resources = new Dict();\n  const imageStream = new StringStream(\"q 0 0 10 10 rect f*\");\n\n  await expect(\n    evaluator.buildPaintImageXObject({\n      resources,\n      image: imageStream,\n      isInline: true,\n      operatorList,\n      cacheKey: null,\n      localImageCache: null,\n      localColorSpaceCache: null,\n    })\n  ).resolves.not.toThrow();\n});",
    "i1_gpt-4o": "it(\"should handle inlined images without closing EI\", async () => {\n  const { PDFImage } = await import(\"../../src/core/image.js\");\n  const resources = Dict.empty;\n  const imageDict = new Dict();\n  imageDict.set(\"W\", 100);\n  imageDict.set(\"H\", 100);\n  const imageStream = new Stream(new Uint8Array([0, 1, 2, 3]));\n  imageStream.dict = imageDict;\n  const operatorList = new OperatorList();\n  const evaluator = new PartialEvaluator({\n    xref: new XRefMock(),\n    handler: null,\n    pageIndex: 0,\n    idFactory: createIdFactory(0),\n    fontCache: null,\n    builtInCMapCache: null,\n    standardFontDataCache: null,\n    globalImageCache: null,\n    systemFontCache: null,\n    options: { ignoreErrors: true },\n  });\n\n  await evaluator.buildPaintImageXObject({\n    resources,\n    image: imageStream,\n    isInline: true,\n    operatorList,\n    cacheKey: null,\n    localImageCache: null,\n    localColorSpaceCache: null,\n  });\n\n  const imgOps = operatorList.fnArray.filter(\n    op => op === OPS.paintInlineImageXObject\n  );\n  expect(imgOps.length).toBe(1);\n});",
    "i1_llama-3.3-70b-versatile": "it(\"should render inlined images without the closing EI\", async () => {\n  const { PartialEvaluator, OperatorList, Stream, Dict, Name } = await import(\"../../src/core/evaluator.js\");\n  const { XRefMock } = await import(\"./test_utils.js\");\n  const xref = new XRefMock();\n  const operatorList = new OperatorList();\n  const evaluator = new PartialEvaluator({\n    xref,\n    handler: {},\n    pageIndex: 0,\n    idFactory: {},\n    fontCache: {},\n    builtInCMapCache: {},\n    standardFontDataCache: {},\n    globalImageCache: {},\n    systemFontCache: {},\n    options: {},\n  });\n  const imageStream = new Stream(new Uint8Array([0x49, 0x44, 0x41, 0x54, 0x78, 0x9c, 0x63, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00]));\n  const imageDict = new Dict({\n    W: new Name(\"Width\"),\n    H: new Name(\"Height\"),\n  });\n  imageDict.set(\"Width\", 10);\n  imageDict.set(\"Height\", 10);\n  await evaluator.buildPaintImageXObject({\n    resources: {},\n    image: imageStream,\n    isInline: true,\n    operatorList,\n    cacheKey: null,\n    localImageCache: {},\n    localColorSpaceCache: {},\n  });\n  const expectedOps = [\n    {\n      fn: \"paintInlineImageXObject\",\n      args: [expect.any(Object)],\n      optionalContent: undefined,\n    },\n  ];\n  expect(operatorList.ops).toEqual(expectedOps);\n});",
    "i2_deepseek-r1-distill-llama-70b": "it(\"should handle inlined images without closing EI\", async () => {\n  const { PDFDocument } = await import(\"../../src/display/api.js\");\n  const { PDFPage } = await import(\"../../src/display/pdf_page.js\");\n  const { Util } = await import(\"../../src/shared/util.js\");\n\n  // Load the test PDF with inlined image missing EI\n  const pdfData = await fetch(\"example.pdf\").then(res => res.arrayBuffer());\n  const pdfDoc = await PDFDocument.load(pdfData, { ignoreErrors: false });\n  const page = await pdfDoc.getPage(1);\n\n  // Test without ignoreErrors (should throw error)\n  {\n    const consoleSpy = jest.spyOn(console, 'error').mockImplementation(() => {});\n    let errorThrown = false;\n    try {\n      await page.render();\n    } catch (e) {\n      errorthrown = true;\n    }\n    expect(errorThrown).toBe(true);\n    consoleSpy.mockRestore();\n  }\n\n  // Test with ignoreErrors (should not throw error)\n  {\n    const consoleSpy = jest.spyOn(console, 'warn').mockImplementation(() => {});\n    const pdfDocIgnoreErrors = await PDFDocument.load(pdfData, { ignoreErrors: true });\n    const pageIgnoreErrors = await pdfDocIgnoreErrors.getPage(1);\n    let errorThrown = false;\n    try {\n      await pageIgnoreErrors.render();\n    } catch (e) {\n      errorthrown = true;\n    }\n    expect(errorThrown).toBe(false);\n    consoleSpy.mockRestore();\n  }\n});",
    "i2_gpt-4o": "it(\"should not render corrupted inlined images\", async () => {\n  const { getDocument } = await import(\"../../src/display/api.js\");\n  const { buildGetDocumentParams } = await import(\"./test_utils.js\");\n\n  const loadingTask = getDocument(buildGetDocumentParams(\"image1.pdf\"));\n  const pdfDocument = await loadingTask.promise;\n  const pdfPage = await pdfDocument.getPage(1);\n\n  const operatorList = await pdfPage.getOperatorList();\n  const imageOps = operatorList.fnArray.filter(fn => fn === OPS.paintInlineImageXObject);\n\n  const expectedImageOpsCount = 0;\n  const actualImageOpsCount = imageOps.length;\n\n  expect(actualImageOpsCount).toBe(expectedImageOpsCount);\n});",
    "i2_llama-3.3-70b-versatile": "it(\"should render inlined images without the closing EI correctly\", async () => {\n  const { PDFDocument } = await import(\"../../src/core/document.js\");\n  const { PDFImage } = await import(\"../../src/core/image.js\");\n  const { PartialEvaluator } = await import(\"../../src/core/evaluator.js\");\n  const { OperatorList } = await import(\"../../src/core/operator_list.js\");\n  const { LocalColorSpaceCache } = await import(\"../../src/core/image_utils.js\");\n\n  const pdfData = await (await import(\"fs/promises\")).readFile(\"image1.pdf\");\n  const pdfDoc = await PDFDocument.load(pdfData);\n  const page = await pdfDoc.getPage(1);\n  const operatorList = new OperatorList();\n  const evaluator = new PartialEvaluator({\n    xref: pdfDoc.xref,\n    handler: null,\n    pageIndex: 0,\n    idFactory: null,\n    fontCache: null,\n    builtInCMapCache: null,\n    standardFontDataCache: null,\n    globalImageCache: null,\n    systemFontCache: null,\n    options: {\n      ignoreErrors: true,\n    },\n  });\n  const resources = await page.getResources();\n  const image = await page.getImage(0);\n  const localColorSpaceCache = new LocalColorSpaceCache();\n\n  await evaluator.buildPaintImageXObject({\n    resources,\n    image,\n    isInline: true,\n    operatorList,\n    cacheKey: null,\n    localImageCache: null,\n    localColorSpaceCache,\n  });\n\n  const expectedError = false;\n  const actualError = operatorList.errors.length === 0;\n  expect(actualError).toBe(expectedError);\n});",
    "i3_deepseek-r1-distill-llama-70b": "it(\"should handle inlined images without EI\", async () => {\n  const xref = new XRefMock();\n  const idFactory = createIdFactory();\n  const handler = {\n    send: jest.fn(),\n    sendWithPromise: jest.fn(),\n  };\n  const evaluator = new PartialEvaluator({\n    xref,\n    handler,\n    pageIndex: 0,\n    idFactory,\n    options: {\n      ignoreErrors: false,\n    },\n  });\n\n  const dict = new Dict();\n  const image = new Stream(new Uint8Array([0, 1, 2, 3, 4, 5]));\n  const operatorList = new OperatorList();\n\n  // Mock the image processing to throw an error\n  const originalCreateImageData = PartialEvaluator.prototype.createImageData;\n  PartialEvaluator.prototype.createImageData = async () => {\n    throw new Error(\"Failed to decode image\");\n  };\n\n  const consoleSpy = jest.spyOn(console, \"warn\").mockImplementation(() => {});\n\n  // Add an inlined image without EI\n  await evaluator.buildPaintImageXObject({\n    resources: dict,\n    image,\n    isInline: true,\n    operatorList,\n    cacheKey: null,\n    localImageCache: null,\n    localColorSpaceCache: null,\n  });\n\n  // Verify that the warning was logged\n  expect(consoleSpy).toHaveBeenCalledWith(\"Unable to decode inline image: \\\"Failed to decode image\\\".\");\n\n  // Restore the original method\n  PartialEvaluator.prototype.createImageData = originalCreateImageData;\n});",
    "i3_gpt-4o": "it(\"should handle inlined images without closing EI\", async () => {\n  const { PDFImage } = await import(\"../../src/core/image.js\");\n  const xref = new XRefMock();\n  const resources = Dict.empty;\n  const imageDict = new Dict();\n  imageDict.set(\"W\", 1);\n  imageDict.set(\"H\", 1);\n  const imageStream = new Stream(new Uint8Array([0]));\n  imageStream.dict = imageDict;\n  const evaluator = new PartialEvaluator({\n    xref,\n    handler: null,\n    pageIndex: 0,\n    idFactory: createIdFactory(0),\n    fontCache: null,\n    builtInCMapCache: null,\n    standardFontDataCache: null,\n    globalImageCache: null,\n    systemFontCache: null,\n    options: { ignoreErrors: false },\n  });\n  const operatorList = new OperatorList();\n  const localColorSpaceCache = new Map();\n  let error = null;\n  try {\n    await evaluator.buildPaintImageXObject({\n      resources,\n      image: imageStream,\n      isInline: true,\n      operatorList,\n      cacheKey: null,\n      localImageCache: null,\n      localColorSpaceCache,\n    });\n  } catch (e) {\n    error = e;\n  }\n  expect(error).toBeNull();\n  expect(operatorList.argsArray.length).toBeGreaterThan(0);\n});",
    "i3_llama-3.3-70b-versatile": "it(\"should render inlined images without the closing EI marker\", async () => {\n  const xref = new XRefMock();\n  const idFactory = createIdFactory();\n  const evaluator = new PartialEvaluator({\n    xref,\n    handler: {},\n    pageIndex: 0,\n    idFactory,\n    fontCache: new Map(),\n    builtInCMapCache: new Map(),\n    standardFontDataCache: new Map(),\n    globalImageCache: new Map(),\n    systemFontCache: new Map(),\n  });\n  const stream = new StringStream(\"BI\\nID\\n\");\n  const task = new WorkerTask(\"test\");\n  const operatorList = new OperatorList();\n  await evaluator.getOperatorList({\n    stream,\n    task,\n    resources: new Dict(),\n    operatorList,\n  });\n  expect(operatorList.length).toBeGreaterThan(0);\n});",
    "i4_deepseek-r1-distill-llama-70b": "it(\"should render all images in PDF with inlined images without closing EI\", async () => {\n  const { PDFDocument } = await import(\"../../web/pdf_document.js\");\n  const { JSDOM } = await import(\"jsdom\");\n  const pdfBytes = await fetch(\"image1.pdf\").then(res => res.arrayBuffer());\n  const pdf = await PDFDocument.load(pdfBytes, { cMapUrl: \"/web/cmaps/\" });\n  const page = await pdf.getPage(1);\n  const viewport = page.getViewport({ scale: 1 });\n  const renderOptions = {\n    canvasContext: new (await import(\"canvas\")).Canvas(),\n    viewport,\n    enableWebGL: false,\n  };\n  const result = await page.render(renderOptions);\n  const svg = await result.getSvg();\n  const dom = new JSDOM(svg);\n  const images = dom.window.document.querySelectorAll(\"image\");\n  expect(images.length).toBe(2);\n});",
    "i4_gpt-4o": "it(\"should render all inlined images correctly\", async () => {\n  const { getDocument } = await import(\"../../src/display/api.js\");\n  const { PDFNodeStream } = await import(\"../../src/display/node_stream.js\");\n  const { buildGetDocumentParams } = await import(\"./test_utils.js\");\n\n  const pdfUrl = \"https://github.com/mozilla/pdf.js/files/14607428/image1.pdf\";\n  const loadingTask = getDocument(buildGetDocumentParams(pdfUrl, { stream: new PDFNodeStream() }));\n  const pdfDocument = await loadingTask.promise;\n  const pdfPage = await pdfDocument.getPage(1);\n\n  const operatorList = await pdfPage.getOperatorList();\n  const imageOps = operatorList.fnArray.filter(op => op === OPS.paintInlineImageXObject);\n\n  const expectedImageOpsCount = 2;\n  const actualImageOpsCount = imageOps.length;\n\n  expect(actualImageOpsCount).toBe(expectedImageOpsCount);\n});",
    "i4_llama-3.3-70b-versatile": "it(\"should render images with inlined images without the closing EI correctly\", async () => {\n  const { PartialEvaluator } = await import(\"../../src/core/evaluator.js\");\n  const { PDFImage } = await import(\"../../src/core/image.js\");\n  const { Dict } = await import(\"../../src/core/primitives.js\");\n  const { Name } = await import(\"../../src/core/primitives.js\");\n  const { Ref } = await import(\"../../src/core/primitives.js\");\n  const { CMapFactory } = await import(\"../../src/core/cmap.js\");\n  const { LocalColorSpaceCache } = await import(\"../../src/core/image_utils.js\");\n\n  const xref = {\n    fetch: (ref) => {\n      if (ref instanceof Ref) {\n        return new Dict();\n      }\n      return ref;\n    },\n    fetchIfRef: (ref) => {\n      if (ref instanceof Ref) {\n        return new Dict();\n      }\n      return ref;\n    },\n  };\n\n  const image = new Dict();\n  image.set(\"Subtype\", Name.get(\"Image\"));\n  image.set(\"Width\", 10);\n  image.set(\"Height\", 10);\n  image.set(\"BitsPerComponent\", 8);\n  image.set(\"ColorSpace\", Name.get(\"DeviceRGB\"));\n  image.set(\"Filter\", Name.get(\"DCTDecode\"));\n  image.set(\"Length\", 100);\n\n  const evaluator = new PartialEvaluator({\n    xref,\n    handler: {\n      send: () => {},\n      sendWithPromise: () => Promise.resolve(),\n    },\n    pageIndex: 0,\n    idFactory: {\n      createObjId: () => \"objId\",\n      getDocId: () => \"docId\",\n      getPageObjId: () => \"pageObjId\",\n    },\n    fontCache: new Map(),\n    builtInCMapCache: new Map(),\n    standardFontDataCache: new Map(),\n    globalImageCache: new Map(),\n    systemFontCache: new Map(),\n    options: {},\n  });\n\n  const localColorSpaceCache = new LocalColorSpaceCache();\n\n  const imageObj = new PDFImage({\n    xref,\n    res: new Dict(),\n    image,\n    isInline: true,\n    pdfFunctionFactory: evaluator._pdfFunctionFactory,\n    localColorSpaceCache,\n  });\n\n  try {\n    await imageObj.createImageData(true, false);\n  } catch (error) {\n    throw new Error(\"Image creation failed\");\n  }\n});",
    "i5_deepseek-r1-distill-llama-70b": "it(\"should render all inline images correctly\", async () => {\n  const { PDFDocument } = await import(\"../../src/display/api.js\");\n  const { PDFPageProxy } = await import(\"../../src/display/pdf_page.js\");\n  const { TestReporter } = await import(\"./testreporter.js\");\n\n  const reporter = new TestReporter();\n  const pdf = await PDFDocument.load(\n    fetch(\"image1.pdf\"),\n    { \n      onProgress: (progress) => reporter.onProgress(progress),\n      password: null,\n      cMapLoader: null,\n      fontLoader: null\n    }\n  );\n\n  const page = await pdf.getPage(2);\n  const pageProxy = new PDFPageProxy(page);\n\n  await pageProxy.run();\n  const operatorList = pageProxy.getOperatorList();\n  const expectedImageCount = 2;\n\n  expect(operatorList.getImages().length).toBe(expectedImageCount);\n});",
    "i5_gpt-4o": "it(\"should correctly render all inlined images in the PDF\", async () => {\n  const { getDocument } = await import(\"../../src/display/api.js\");\n  const { PDFNodeStream } = await import(\"../../src/display/node_stream.js\");\n  const { PDFDocumentProxy } = await import(\"../../src/display/api.js\");\n\n  const pdfUrl = \"https://github.com/mozilla/pdf.js/files/14607428/image1.pdf\";\n  const loadingTask = getDocument({ url: pdfUrl, nativeImageDecoderSupport: \"none\" });\n  const pdfDocument = await loadingTask.promise;\n\n  const page = await pdfDocument.getPage(1);\n  const viewport = page.getViewport({ scale: 1.0 });\n\n  const canvasFactory = new (await import(\"../../src/display/display_utils.js\")).DOMCanvasFactory();\n  const canvasAndContext = canvasFactory.create(viewport.width, viewport.height);\n  const renderContext = {\n    canvasContext: canvasAndContext.context,\n    viewport: viewport,\n  };\n\n  await page.render(renderContext).promise;\n\n  const imageData = canvasAndContext.context.getImageData(0, 0, viewport.width, viewport.height);\n  const pixelData = imageData.data;\n\n  const hasMultipleImages = pixelData.some((value, index) => {\n    return index % 4 === 0 && value !== 255; // Check for non-white pixels\n  });\n\n  expect(hasMultipleImages).toBe(true);\n});",
    "i5_llama-3.3-70b-versatile": "it(\"should render all inlined images correctly\", async () => {\n  const { PDFDocument } = await import(\"../../src/core/document.js\");\n  const { PartialEvaluator } = await import(\"../../src/core/evaluator.js\");\n  const { OPS } = await import(\"../../src/shared/util.js\");\n  const pdfData = await (await import(\"../../src/display/fetch_stream.js\")).PDFFetchStream.fetch(\"https://github.com/mozilla/pdf.js/files/14607428/image1.pdf\");\n  const pdf = await PDFDocument.load(pdfData);\n  const page = await pdf.getPage(1);\n  const operatorList = new (await import(\"../../src/core/operator_list.js\")).OperatorList();\n  const evaluator = new PartialEvaluator({\n    xref: pdf.xref,\n    options: { ignoreErrors: false },\n    operatorList,\n    resources: page.resources,\n    pdfFunctionFactory: new (await import(\"../../src/core/function.js\")).PDFFunctionFactory(),\n    localColorSpaceCache: new (await import(\"../../src/core/image_utils.js\")).LocalColorSpaceCache(),\n  });\n  await evaluator.begin();\n  await evaluator.renderPage(page);\n  const expectedOps = [\n    OPS.paintInlineImageXObject,\n  ];\n  const actualOps = operatorList.ops.filter(op => op === OPS.paintInlineImageXObject);\n  expect(actualOps.length).toBe(2);\n});"
  },
  "17825": {
    "i1_deepseek-r1-distill-llama-70b": "it(\"should add a visually hidden accessible label to the highlight floating button\", async () => {\n  const button = await page.waitForSelector(\".highlightButton\");\n  const span = await button.$(\".visuallyHidden\");\n  if (!span) {\n    throw new Error(\"The accessible label span is missing on the highlight button.\");\n  }\n  const dataL10nId = await page.evaluate(el => el.getAttribute(\"data-l10n-id\"), span);\n  if (dataL10nId !== \"pdfjs-highlight-floating-button-label\") {\n    throw new Error(`Expected span data-l10n-id to be \"pdfjs-highlight-floating-button-label\", but got \"${dataL10nId}\"`);\n  }\n});",
    "i1_gpt-4o": "it(\"should add a visually hidden accessible label to the highlight floating button\", async () => {\n  const button = await page.waitForSelector(\".highlightButton\");\n  const span = await button.$(\".visuallyHidden\");\n  if (!span) {\n    throw new Error(\"The accessible label span is missing on the highlight button.\");\n  }\n  const dataL10nId = await page.evaluate(el => el.getAttribute(\"data-l10n-id\"), span);\n  if (dataL10nId !== \"pdfjs-highlight-floating-button-label\") {\n    throw new Error(`Expected span data-l10n-id to be \"pdfjs-highlight-floating-button-label\", but got \"${dataL10nId}\"`);\n  }\n});",
    "i1_llama-3.3-70b-versatile": "it(\"should add a visually hidden accessible label to the highlight floating button\", async () => {\n  const button = await page.waitForSelector(\".highlightButton\");\n  const span = await button.$(\".visuallyHidden\");\n  if (!span) {\n    throw new Error(\"The accessible label span is missing on the highlight button.\");\n  }\n  const dataL10nId = await page.evaluate(el => el.getAttribute(\"data-l10n-id\"), span);\n  if (dataL10nId !== \"pdfjs-highlight-floating-button-label\") {\n    throw new Error(`Expected span data-l10n-id to be \"pdfjs-highlight-floating-button-label\", but got \"${dataL10nId}\"`);\n  }\n});",
    "i1_MOCK": "it(\"should add a visually hidden accessible label to the highlight floating button\", async () => {\n  const button = await page.waitForSelector(\".highlightButton\");\n  const span = await button.$(\".visuallyHidden\");\n  if (!span) {\n    throw new Error(\"The accessible label span is missing on the highlight button.\");\n  }\n  const dataL10nId = await page.evaluate(el => el.getAttribute(\"data-l10n-id\"), span);\n  if (dataL10nId !== \"pdfjs-highlight-floating-button-label\") {\n    throw new Error(`Expected span data-l10n-id to be \"pdfjs-highlight-floating-button-label\", but got \"${dataL10nId}\"`);\n  }\n});",
    "i2_deepseek-r1-distill-llama-70b": "it(\"should add a visually hidden accessible label to the highlight floating button\", async () => {\n  const button = await page.waitForSelector(\".highlightButton\");\n  const span = await button.$(\".visuallyHidden\");\n  if (!span) {\n    throw new Error(\"The accessible label span is missing on the highlight button.\");\n  }\n  const dataL10nId = await page.evaluate(el => el.getAttribute(\"data-l10n-id\"), span);\n  if (dataL10nId !== \"pdfjs-highlight-floating-button-label\") {\n    throw new Error(`Expected span data-l10n-id to be \"pdfjs-highlight-floating-button-label\", but got \"${dataL10nId}\"`);\n  }\n});",
    "i2_gpt-4o": "it(\"should add a visually hidden accessible label to the highlight floating button\", async () => {\n  const button = await page.waitForSelector(\".highlightButton\");\n  const span = await button.$(\".visuallyHidden\");\n  if (!span) {\n    throw new Error(\"The accessible label span is missing on the highlight button.\");\n  }\n  const dataL10nId = await page.evaluate(el => el.getAttribute(\"data-l10n-id\"), span);\n  if (dataL10nId !== \"pdfjs-highlight-floating-button-label\") {\n    throw new Error(`Expected span data-l10n-id to be \"pdfjs-highlight-floating-button-label\", but got \"${dataL10nId}\"`);\n  }\n});",
    "i2_llama-3.3-70b-versatile": "it(\"should add a visually hidden accessible label to the highlight floating button\", async () => {\n  const button = await page.waitForSelector(\".highlightButton\");\n  const span = await button.$(\".visuallyHidden\");\n  if (!span) {\n    throw new Error(\"The accessible label span is missing on the highlight button.\");\n  }\n  const dataL10nId = await page.evaluate(el => el.getAttribute(\"data-l10n-id\"), span);\n  if (dataL10nId !== \"pdfjs-highlight-floating-button-label\") {\n    throw new Error(`Expected span data-l10n-id to be \"pdfjs-highlight-floating-button-label\", but got \"${dataL10nId}\"`);\n  }\n});",
    "i3_deepseek-r1-distill-llama-70b": "it(\"should add a visually hidden accessible label to the highlight floating button\", async () => {\n  const button = await page.waitForSelector(\".highlightButton\");\n  const span = await button.$(\".visuallyHidden\");\n  if (!span) {\n    throw new Error(\"The accessible label span is missing on the highlight button.\");\n  }\n  const dataL10nId = await page.evaluate(el => el.getAttribute(\"data-l10n-id\"), span);\n  if (dataL10nId !== \"pdfjs-highlight-floating-button-label\") {\n    throw new Error(`Expected span data-l10n-id to be \"pdfjs-highlight-floating-button-label\", but got \"${dataL10nId}\"`);\n  }\n});",
    "i3_gpt-4o": "it(\"should add a visually hidden accessible label to the highlight floating button\", async () => {\n  const button = await page.waitForSelector(\".highlightButton\");\n  const span = await button.$(\".visuallyHidden\");\n  if (!span) {\n    throw new Error(\"The accessible label span is missing on the highlight button.\");\n  }\n  const dataL10nId = await page.evaluate(el => el.getAttribute(\"data-l10n-id\"), span);\n  if (dataL10nId !== \"pdfjs-highlight-floating-button-label\") {\n    throw new Error(`Expected span data-l10n-id to be \"pdfjs-highlight-floating-button-label\", but got \"${dataL10nId}\"`);\n  }\n});",
    "i3_llama-3.3-70b-versatile": "it(\"should add a visually hidden accessible label to the highlight floating button\", async () => {\n  const button = await page.waitForSelector(\".highlightButton\");\n  const span = await button.$(\".visuallyHidden\");\n  if (!span) {\n    throw new Error(\"The accessible label span is missing on the highlight button.\");\n  }\n  const dataL10nId = await page.evaluate(el => el.getAttribute(\"data-l10n-id\"), span);\n  if (dataL10nId !== \"pdfjs-highlight-floating-button-label\") {\n    throw new Error(`Expected span data-l10n-id to be \"pdfjs-highlight-floating-button-label\", but got \"${dataL10nId}\"`);\n  }\n});",
    "i4_deepseek-r1-distill-llama-70b": "it(\"should add a visually hidden accessible label to the highlight floating button\", async () => {\n  const button = await page.waitForSelector(\".highlightButton\");\n  const span = await button.$(\".visuallyHidden\");\n  if (!span) {\n    throw new Error(\"The accessible label span is missing on the highlight button.\");\n  }\n  const dataL10nId = await page.evaluate(el => el.getAttribute(\"data-l10n-id\"), span);\n  if (dataL10nId !== \"pdfjs-highlight-floating-button-label\") {\n    throw new Error(`Expected span data-l10n-id to be \"pdfjs-highlight-floating-button-label\", but got \"${dataL10nId}\"`);\n  }\n});",
    "i4_gpt-4o": "it(\"should add a visually hidden accessible label to the highlight floating button\", async () => {\n  const button = await page.waitForSelector(\".highlightButton\");\n  const span = await button.$(\".visuallyHidden\");\n  if (!span) {\n    throw new Error(\"The accessible label span is missing on the highlight button.\");\n  }\n  const dataL10nId = await page.evaluate(el => el.getAttribute(\"data-l10n-id\"), span);\n  if (dataL10nId !== \"pdfjs-highlight-floating-button-label\") {\n    throw new Error(`Expected span data-l10n-id to be \"pdfjs-highlight-floating-button-label\", but got \"${dataL10nId}\"`);\n  }\n});",
    "i4_llama-3.3-70b-versatile": "it(\"should add a visually hidden accessible label to the highlight floating button\", async () => {\n  const button = await page.waitForSelector(\".highlightButton\");\n  const span = await button.$(\".visuallyHidden\");\n  if (!span) {\n    throw new Error(\"The accessible label span is missing on the highlight button.\");\n  }\n  const dataL10nId = await page.evaluate(el => el.getAttribute(\"data-l10n-id\"), span);\n  if (dataL10nId !== \"pdfjs-highlight-floating-button-label\") {\n    throw new Error(`Expected span data-l10n-id to be \"pdfjs-highlight-floating-button-label\", but got \"${dataL10nId}\"`);\n  }\n});",
    "i5_deepseek-r1-distill-llama-70b": "it(\"should add a visually hidden accessible label to the highlight floating button\", async () => {\n  const button = await page.waitForSelector(\".highlightButton\");\n  const span = await button.$(\".visuallyHidden\");\n  if (!span) {\n    throw new Error(\"The accessible label span is missing on the highlight button.\");\n  }\n  const dataL10nId = await page.evaluate(el => el.getAttribute(\"data-l10n-id\"), span);\n  if (dataL10nId !== \"pdfjs-highlight-floating-button-label\") {\n    throw new Error(`Expected span data-l10n-id to be \"pdfjs-highlight-floating-button-label\", but got \"${dataL10nId}\"`);\n  }\n});",
    "i5_gpt-4o": "it(\"should add a visually hidden accessible label to the highlight floating button\", async () => {\n  const button = await page.waitForSelector(\".highlightButton\");\n  const span = await button.$(\".visuallyHidden\");\n  if (!span) {\n    throw new Error(\"The accessible label span is missing on the highlight button.\");\n  }\n  const dataL10nId = await page.evaluate(el => el.getAttribute(\"data-l10n-id\"), span);\n  if (dataL10nId !== \"pdfjs-highlight-floating-button-label\") {\n    throw new Error(`Expected span data-l10n-id to be \"pdfjs-highlight-floating-button-label\", but got \"${dataL10nId}\"`);\n  }\n});",
    "i5_llama-3.3-70b-versatile": "it(\"should add a visually hidden accessible label to the highlight floating button\", async () => {\n  const button = await page.waitForSelector(\".highlightButton\");\n  const span = await button.$(\".visuallyHidden\");\n  if (!span) {\n    throw new Error(\"The accessible label span is missing on the highlight button.\");\n  }\n  const dataL10nId = await page.evaluate(el => el.getAttribute(\"data-l10n-id\"), span);\n  if (dataL10nId !== \"pdfjs-highlight-floating-button-label\") {\n    throw new Error(`Expected span data-l10n-id to be \"pdfjs-highlight-floating-button-label\", but got \"${dataL10nId}\"`);\n  }\n});"
  },
  "17868": {
    "i1_deepseek-r1-distill-llama-70b": "it(\"should disable image smoothing when only one scale factor is below the actual scale and interpolate is not set\", async () => {\n  const { getImageSmoothingEnabled } = await import(\"../../src/display/canvas.js\");\n  const { PixelsPerInch } = await import(\"../../src/display/display_utils.js\");\n  const devicePixelRatio = globalThis.devicePixelRatio || 1;\n  const actualScale = Math.fround(devicePixelRatio * PixelsPerInch.PDF_TO_CSS_UNITS);\n  const delta = 0.1;\n  // Set scaleX below actualScale and scaleY above actualScale.\n  const scaleX = actualScale - delta;\n  const scaleY = actualScale + delta;\n  // Create a simple transform matrix [scaleX, 0, 0, scaleY, 0, 0]\n  const transform = [scaleX, 0, 0, scaleY, 0, 0];\n  // Do not pass an explicit interpolate (undefined).\n  const smoothing = getImageSmoothingEnabled(transform, undefined);\n  if (smoothing !== false) {\n    throw new Error(\"Expected smoothing to be false, but got true\");\n  }\n});",
    "i1_gpt-4o": "it(\"should disable image smoothing when only one scale factor is below the actual scale and interpolate is not set\", async () => {\n  const { getImageSmoothingEnabled } = await import(\"../../src/display/canvas.js\");\n  const { PixelsPerInch } = await import(\"../../src/display/display_utils.js\");\n  const devicePixelRatio = globalThis.devicePixelRatio || 1;\n  const actualScale = Math.fround(devicePixelRatio * PixelsPerInch.PDF_TO_CSS_UNITS);\n  const delta = 0.1;\n  // Set scaleX below actualScale and scaleY above actualScale.\n  const scaleX = actualScale - delta;\n  const scaleY = actualScale + delta;\n  // Create a simple transform matrix [scaleX, 0, 0, scaleY, 0, 0]\n  const transform = [scaleX, 0, 0, scaleY, 0, 0];\n  // Do not pass an explicit interpolate (undefined).\n  const smoothing = getImageSmoothingEnabled(transform, undefined);\n  if (smoothing !== false) {\n    throw new Error(\"Expected smoothing to be false, but got true\");\n  }\n});",
    "i1_llama-3.3-70b-versatile": "it(\"should disable image smoothing when only one scale factor is below the actual scale and interpolate is not set\", async () => {\n  const { getImageSmoothingEnabled } = await import(\"../../src/display/canvas.js\");\n  const { PixelsPerInch } = await import(\"../../src/display/display_utils.js\");\n  const devicePixelRatio = globalThis.devicePixelRatio || 1;\n  const actualScale = Math.fround(devicePixelRatio * PixelsPerInch.PDF_TO_CSS_UNITS);\n  const delta = 0.1;\n  // Set scaleX below actualScale and scaleY above actualScale.\n  const scaleX = actualScale - delta;\n  const scaleY = actualScale + delta;\n  // Create a simple transform matrix [scaleX, 0, 0, scaleY, 0, 0]\n  const transform = [scaleX, 0, 0, scaleY, 0, 0];\n  // Do not pass an explicit interpolate (undefined).\n  const smoothing = getImageSmoothingEnabled(transform, undefined);\n  if (smoothing !== false) {\n    throw new Error(\"Expected smoothing to be false, but got true\");\n  }\n});",
    "i1_MOCK": "it(\"should disable image smoothing when only one scale factor is below the actual scale and interpolate is not set\", async () => {\n  const { getImageSmoothingEnabled } = await import(\"../../src/display/canvas.js\");\n  const { PixelsPerInch } = await import(\"../../src/display/display_utils.js\");\n  const devicePixelRatio = globalThis.devicePixelRatio || 1;\n  const actualScale = Math.fround(devicePixelRatio * PixelsPerInch.PDF_TO_CSS_UNITS);\n  const delta = 0.1;\n  // Set scaleX below actualScale and scaleY above actualScale.\n  const scaleX = actualScale - delta;\n  const scaleY = actualScale + delta;\n  // Create a simple transform matrix [scaleX, 0, 0, scaleY, 0, 0]\n  const transform = [scaleX, 0, 0, scaleY, 0, 0];\n  // Do not pass an explicit interpolate (undefined).\n  const smoothing = getImageSmoothingEnabled(transform, undefined);\n  if (smoothing !== false) {\n    throw new Error(\"Expected smoothing to be false, but got true\");\n  }\n});",
    "i2_deepseek-r1-distill-llama-70b": "it(\"should disable image smoothing when only one scale factor is below the actual scale and interpolate is not set\", async () => {\n  const { getImageSmoothingEnabled } = await import(\"../../src/display/canvas.js\");\n  const { PixelsPerInch } = await import(\"../../src/display/display_utils.js\");\n  const devicePixelRatio = globalThis.devicePixelRatio || 1;\n  const actualScale = Math.fround(devicePixelRatio * PixelsPerInch.PDF_TO_CSS_UNITS);\n  const delta = 0.1;\n  // Set scaleX below actualScale and scaleY above actualScale.\n  const scaleX = actualScale - delta;\n  const scaleY = actualScale + delta;\n  // Create a simple transform matrix [scaleX, 0, 0, scaleY, 0, 0]\n  const transform = [scaleX, 0, 0, scaleY, 0, 0];\n  // Do not pass an explicit interpolate (undefined).\n  const smoothing = getImageSmoothingEnabled(transform, undefined);\n  if (smoothing !== false) {\n    throw new Error(\"Expected smoothing to be false, but got true\");\n  }\n});",
    "i2_gpt-4o": "it(\"should disable image smoothing when only one scale factor is below the actual scale and interpolate is not set\", async () => {\n  const { getImageSmoothingEnabled } = await import(\"../../src/display/canvas.js\");\n  const { PixelsPerInch } = await import(\"../../src/display/display_utils.js\");\n  const devicePixelRatio = globalThis.devicePixelRatio || 1;\n  const actualScale = Math.fround(devicePixelRatio * PixelsPerInch.PDF_TO_CSS_UNITS);\n  const delta = 0.1;\n  // Set scaleX below actualScale and scaleY above actualScale.\n  const scaleX = actualScale - delta;\n  const scaleY = actualScale + delta;\n  // Create a simple transform matrix [scaleX, 0, 0, scaleY, 0, 0]\n  const transform = [scaleX, 0, 0, scaleY, 0, 0];\n  // Do not pass an explicit interpolate (undefined).\n  const smoothing = getImageSmoothingEnabled(transform, undefined);\n  if (smoothing !== false) {\n    throw new Error(\"Expected smoothing to be false, but got true\");\n  }\n});",
    "i2_llama-3.3-70b-versatile": "it(\"should disable image smoothing when only one scale factor is below the actual scale and interpolate is not set\", async () => {\n  const { getImageSmoothingEnabled } = await import(\"../../src/display/canvas.js\");\n  const { PixelsPerInch } = await import(\"../../src/display/display_utils.js\");\n  const devicePixelRatio = globalThis.devicePixelRatio || 1;\n  const actualScale = Math.fround(devicePixelRatio * PixelsPerInch.PDF_TO_CSS_UNITS);\n  const delta = 0.1;\n  // Set scaleX below actualScale and scaleY above actualScale.\n  const scaleX = actualScale - delta;\n  const scaleY = actualScale + delta;\n  // Create a simple transform matrix [scaleX, 0, 0, scaleY, 0, 0]\n  const transform = [scaleX, 0, 0, scaleY, 0, 0];\n  // Do not pass an explicit interpolate (undefined).\n  const smoothing = getImageSmoothingEnabled(transform, undefined);\n  if (smoothing !== false) {\n    throw new Error(\"Expected smoothing to be false, but got true\");\n  }\n});",
    "i3_deepseek-r1-distill-llama-70b": "it(\"should disable image smoothing when only one scale factor is below the actual scale and interpolate is not set\", async () => {\n  const { getImageSmoothingEnabled } = await import(\"../../src/display/canvas.js\");\n  const { PixelsPerInch } = await import(\"../../src/display/display_utils.js\");\n  const devicePixelRatio = globalThis.devicePixelRatio || 1;\n  const actualScale = Math.fround(devicePixelRatio * PixelsPerInch.PDF_TO_CSS_UNITS);\n  const delta = 0.1;\n  // Set scaleX below actualScale and scaleY above actualScale.\n  const scaleX = actualScale - delta;\n  const scaleY = actualScale + delta;\n  // Create a simple transform matrix [scaleX, 0, 0, scaleY, 0, 0]\n  const transform = [scaleX, 0, 0, scaleY, 0, 0];\n  // Do not pass an explicit interpolate (undefined).\n  const smoothing = getImageSmoothingEnabled(transform, undefined);\n  if (smoothing !== false) {\n    throw new Error(\"Expected smoothing to be false, but got true\");\n  }\n});",
    "i3_gpt-4o": "it(\"should disable image smoothing when only one scale factor is below the actual scale and interpolate is not set\", async () => {\n  const { getImageSmoothingEnabled } = await import(\"../../src/display/canvas.js\");\n  const { PixelsPerInch } = await import(\"../../src/display/display_utils.js\");\n  const devicePixelRatio = globalThis.devicePixelRatio || 1;\n  const actualScale = Math.fround(devicePixelRatio * PixelsPerInch.PDF_TO_CSS_UNITS);\n  const delta = 0.1;\n  // Set scaleX below actualScale and scaleY above actualScale.\n  const scaleX = actualScale - delta;\n  const scaleY = actualScale + delta;\n  // Create a simple transform matrix [scaleX, 0, 0, scaleY, 0, 0]\n  const transform = [scaleX, 0, 0, scaleY, 0, 0];\n  // Do not pass an explicit interpolate (undefined).\n  const smoothing = getImageSmoothingEnabled(transform, undefined);\n  if (smoothing !== false) {\n    throw new Error(\"Expected smoothing to be false, but got true\");\n  }\n});",
    "i3_llama-3.3-70b-versatile": "it(\"should disable image smoothing when only one scale factor is below the actual scale and interpolate is not set\", async () => {\n  const { getImageSmoothingEnabled } = await import(\"../../src/display/canvas.js\");\n  const { PixelsPerInch } = await import(\"../../src/display/display_utils.js\");\n  const devicePixelRatio = globalThis.devicePixelRatio || 1;\n  const actualScale = Math.fround(devicePixelRatio * PixelsPerInch.PDF_TO_CSS_UNITS);\n  const delta = 0.1;\n  // Set scaleX below actualScale and scaleY above actualScale.\n  const scaleX = actualScale - delta;\n  const scaleY = actualScale + delta;\n  // Create a simple transform matrix [scaleX, 0, 0, scaleY, 0, 0]\n  const transform = [scaleX, 0, 0, scaleY, 0, 0];\n  // Do not pass an explicit interpolate (undefined).\n  const smoothing = getImageSmoothingEnabled(transform, undefined);\n  if (smoothing !== false) {\n    throw new Error(\"Expected smoothing to be false, but got true\");\n  }\n});",
    "i4_deepseek-r1-distill-llama-70b": "it(\"should disable image smoothing when only one scale factor is below the actual scale and interpolate is not set\", async () => {\n  const { getImageSmoothingEnabled } = await import(\"../../src/display/canvas.js\");\n  const { PixelsPerInch } = await import(\"../../src/display/display_utils.js\");\n  const devicePixelRatio = globalThis.devicePixelRatio || 1;\n  const actualScale = Math.fround(devicePixelRatio * PixelsPerInch.PDF_TO_CSS_UNITS);\n  const delta = 0.1;\n  // Set scaleX below actualScale and scaleY above actualScale.\n  const scaleX = actualScale - delta;\n  const scaleY = actualScale + delta;\n  // Create a simple transform matrix [scaleX, 0, 0, scaleY, 0, 0]\n  const transform = [scaleX, 0, 0, scaleY, 0, 0];\n  // Do not pass an explicit interpolate (undefined).\n  const smoothing = getImageSmoothingEnabled(transform, undefined);\n  if (smoothing !== false) {\n    throw new Error(\"Expected smoothing to be false, but got true\");\n  }\n});",
    "i4_gpt-4o": "it(\"should disable image smoothing when only one scale factor is below the actual scale and interpolate is not set\", async () => {\n  const { getImageSmoothingEnabled } = await import(\"../../src/display/canvas.js\");\n  const { PixelsPerInch } = await import(\"../../src/display/display_utils.js\");\n  const devicePixelRatio = globalThis.devicePixelRatio || 1;\n  const actualScale = Math.fround(devicePixelRatio * PixelsPerInch.PDF_TO_CSS_UNITS);\n  const delta = 0.1;\n  // Set scaleX below actualScale and scaleY above actualScale.\n  const scaleX = actualScale - delta;\n  const scaleY = actualScale + delta;\n  // Create a simple transform matrix [scaleX, 0, 0, scaleY, 0, 0]\n  const transform = [scaleX, 0, 0, scaleY, 0, 0];\n  // Do not pass an explicit interpolate (undefined).\n  const smoothing = getImageSmoothingEnabled(transform, undefined);\n  if (smoothing !== false) {\n    throw new Error(\"Expected smoothing to be false, but got true\");\n  }\n});",
    "i4_llama-3.3-70b-versatile": "it(\"should disable image smoothing when only one scale factor is below the actual scale and interpolate is not set\", async () => {\n  const { getImageSmoothingEnabled } = await import(\"../../src/display/canvas.js\");\n  const { PixelsPerInch } = await import(\"../../src/display/display_utils.js\");\n  const devicePixelRatio = globalThis.devicePixelRatio || 1;\n  const actualScale = Math.fround(devicePixelRatio * PixelsPerInch.PDF_TO_CSS_UNITS);\n  const delta = 0.1;\n  // Set scaleX below actualScale and scaleY above actualScale.\n  const scaleX = actualScale - delta;\n  const scaleY = actualScale + delta;\n  // Create a simple transform matrix [scaleX, 0, 0, scaleY, 0, 0]\n  const transform = [scaleX, 0, 0, scaleY, 0, 0];\n  // Do not pass an explicit interpolate (undefined).\n  const smoothing = getImageSmoothingEnabled(transform, undefined);\n  if (smoothing !== false) {\n    throw new Error(\"Expected smoothing to be false, but got true\");\n  }\n});",
    "i5_deepseek-r1-distill-llama-70b": "it(\"should disable image smoothing when only one scale factor is below the actual scale and interpolate is not set\", async () => {\n  const { getImageSmoothingEnabled } = await import(\"../../src/display/canvas.js\");\n  const { PixelsPerInch } = await import(\"../../src/display/display_utils.js\");\n  const devicePixelRatio = globalThis.devicePixelRatio || 1;\n  const actualScale = Math.fround(devicePixelRatio * PixelsPerInch.PDF_TO_CSS_UNITS);\n  const delta = 0.1;\n  // Set scaleX below actualScale and scaleY above actualScale.\n  const scaleX = actualScale - delta;\n  const scaleY = actualScale + delta;\n  // Create a simple transform matrix [scaleX, 0, 0, scaleY, 0, 0]\n  const transform = [scaleX, 0, 0, scaleY, 0, 0];\n  // Do not pass an explicit interpolate (undefined).\n  const smoothing = getImageSmoothingEnabled(transform, undefined);\n  if (smoothing !== false) {\n    throw new Error(\"Expected smoothing to be false, but got true\");\n  }\n});",
    "i5_gpt-4o": "it(\"should disable image smoothing when only one scale factor is below the actual scale and interpolate is not set\", async () => {\n  const { getImageSmoothingEnabled } = await import(\"../../src/display/canvas.js\");\n  const { PixelsPerInch } = await import(\"../../src/display/display_utils.js\");\n  const devicePixelRatio = globalThis.devicePixelRatio || 1;\n  const actualScale = Math.fround(devicePixelRatio * PixelsPerInch.PDF_TO_CSS_UNITS);\n  const delta = 0.1;\n  // Set scaleX below actualScale and scaleY above actualScale.\n  const scaleX = actualScale - delta;\n  const scaleY = actualScale + delta;\n  // Create a simple transform matrix [scaleX, 0, 0, scaleY, 0, 0]\n  const transform = [scaleX, 0, 0, scaleY, 0, 0];\n  // Do not pass an explicit interpolate (undefined).\n  const smoothing = getImageSmoothingEnabled(transform, undefined);\n  if (smoothing !== false) {\n    throw new Error(\"Expected smoothing to be false, but got true\");\n  }\n});",
    "i5_llama-3.3-70b-versatile": "it(\"should disable image smoothing when only one scale factor is below the actual scale and interpolate is not set\", async () => {\n  const { getImageSmoothingEnabled } = await import(\"../../src/display/canvas.js\");\n  const { PixelsPerInch } = await import(\"../../src/display/display_utils.js\");\n  const devicePixelRatio = globalThis.devicePixelRatio || 1;\n  const actualScale = Math.fround(devicePixelRatio * PixelsPerInch.PDF_TO_CSS_UNITS);\n  const delta = 0.1;\n  // Set scaleX below actualScale and scaleY above actualScale.\n  const scaleX = actualScale - delta;\n  const scaleY = actualScale + delta;\n  // Create a simple transform matrix [scaleX, 0, 0, scaleY, 0, 0]\n  const transform = [scaleX, 0, 0, scaleY, 0, 0];\n  // Do not pass an explicit interpolate (undefined).\n  const smoothing = getImageSmoothingEnabled(transform, undefined);\n  if (smoothing !== false) {\n    throw new Error(\"Expected smoothing to be false, but got true\");\n  }\n});"
  },
  "17946": {
    "i1_deepseek-r1-distill-llama-70b": "it(\"should render large JPX images without throwing Invalid tag tree error\", async () => {\n  const { PDFDocument } = await import(\"../../src/display/api.js\");\n  const xref = new XRefMock();\n  const loader = {\n    fetch: async (url) => {\n      const response = await fetch(\"example.pdf\");\n      return {\n        arrayBuffer: () => response.arrayBuffer(),\n        bytes: () => response.arrayBuffer(),\n      };\n    },\n  };\n\n  const pdf = await PDFDocument.load(xref, loader);\n  const page = await pdf.getPage(1);\n\n  await expect(page.render()).rejects.not.toThrowError(\"Invalid tag tree\");\n});",
    "i1_gpt-4o": "it(\"should render large images in PDF using JPXDecode\", async () => {\n  const { PDFDocument } = await import(\"../../src/core/document.js\");\n  const { buildGetDocumentParams } = await import(\"./test_utils.js\");\n  const pdfUrl = \"https://github.com/mozilla/pdf.js/files/13391396/example.pdf\";\n  const loadingTask = PDFDocument.load(buildGetDocumentParams(pdfUrl));\n  const pdfDocument = await loadingTask.promise;\n  const page = await pdfDocument.getPage(1);\n  const operatorList = await page.getOperatorList();\n  const jpxImages = operatorList.fnArray.filter(\n    (fn) => fn === OPS.paintJpegXObject\n  );\n  expect(jpxImages.length).toBeGreaterThan(0);\n});",
    "i1_llama-3.3-70b-versatile": "it(\"should render large images in PDF\", async () => {\n  const pdfUrl = \"https://github.com/mozilla/pdf.js/files/13391396/example.pdf\";\n  const pdfDocument = await import(\"../../src/display/api.js\");\n  const pdf = await pdfDocument.PDFDocumentLoadingTask.fromURL(pdfUrl, null);\n  const page = await pdf.getPage(1);\n  const image = await page.getImage(0);\n  const imageData = await image.getImageBytes();\n  expect(imageData).not.toBeNull();\n});",
    "i2_deepseek-r1-distill-llama-70b": "it(\"should render large JPX images\", async () => {\n  const { PDFDocument, PDFPage } = await import(\"../../src/display/api.js\");\n  const examplePdf = await fetch(\"https://github.com/mozilla/pdf.js/files/13391396/example.pdf\");\n  const pdf = await PDFDocument.load(await examplePdf.blob());\n  const page = await pdf.getPage(1);\n  const viewport = page.getViewport({ scale: 1 });\n  const canvas = document.createElement(\"canvas\");\n  canvas.width = viewport.width;\n  canvas.height = viewport.height;\n  const renderTask = page.render({\n    canvasContext: canvas.getContext(\"2d\"),\n    viewport,\n  });\n  await renderTask.promise;\n  const ctx = canvas.getContext(\"2d\");\n  const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);\n  const data = imageData.data;\n  const hasImage = data.some((value) => value < 255);\n  expect(hasImage).toBe(true);\n});",
    "i2_gpt-4o": "it(\"should render large images in PDF\", async () => {\n  const { getDocument } = await import(\"../../src/display/api.js\");\n  const { buildGetDocumentParams } = await import(\"./test_utils.js\");\n\n  const loadingTask = getDocument(buildGetDocumentParams(\"example.pdf\"));\n  const pdfDocument = await loadingTask.promise;\n  const page = await pdfDocument.getPage(1);\n  const viewport = page.getViewport({ scale: 1.0 });\n\n  const canvasFactory = new DOMCanvasFactory();\n  const canvasAndContext = canvasFactory.create(viewport.width, viewport.height);\n  const renderContext = {\n    canvasContext: canvasAndContext.context,\n    viewport,\n  };\n\n  const renderTask = page.render(renderContext);\n  await renderTask.promise;\n\n  const imageData = canvasAndContext.context.getImageData(0, 0, viewport.width, viewport.height);\n  const hasRenderedImage = imageData.data.some(value => value !== 0);\n\n  expect(hasRenderedImage).toBe(true);\n});",
    "i2_llama-3.3-70b-versatile": "it(\"should render large images in PDF\", async () => {\n  const { PDFDocument } = await import(\"../../src/display/api.js\");\n  const { fetch } = await import(\"../../src/shared/util.js\");\n  const pdfUrl = \"https://github.com/mozilla/pdf.js/files/13391396/example.pdf\";\n  const pdfDoc = await PDFDocument.load(await fetch(pdfUrl));\n  const firstPage = await pdfDoc.getPage(1);\n  const operatorList = await firstPage.getOperatorList();\n  const renderTask = firstPage.render({\n    viewport: firstPage.getViewport({ scale: 1 }),\n    intent: \"display\",\n  });\n  const imageRendered = renderTask.promise.then(() => true).catch(() => false);\n  expect(await imageRendered).toBe(true);\n});",
    "i3_deepseek-r1-distill-llama-70b": "it(\"should render large JPX images in PDF\", async () => {\n  const examplePdfBuffer = new TextEncoder().encode(\n    \"%PDF-1.0\\n\" +\n    \"/Type /Catalog\\n\" +\n    \"/Pages /Pages\\n\" +\n    \"endobj\\n\" +\n    \"/Pages\\n\" +\n    \"<<\\n\" +\n    \"/Kids [ /Kid1 ]\\n\" +\n    \"/Count 1\\n\" +\n    \"/Type /Pages\\n\" +\n    \">>\\n\" +\n    \"endobj\\n\" +\n    \"/Kid1\\n\" +\n    \"<<\\n\" +\n    \"/Type /Page\\n\" +\n    \"/Parent /Pages\\n\" +\n    \"/Resources\\n\" +\n    \"<<\\n\" +\n    \"/XObject /Im1\\n\" +\n    \">>\\n\" +\n    \"/Contents\\n\" +\n    \"<<\\n\" +\n    \"/Length 7\\n\" +\n    \">>\\n\" +\n    \"stream\\n\" +\n    \"BT\\n\" +\n    \"  /Name /Im1\\n\" +\n    \"  /Subtype /Image\\n\" +\n    \"  /Filter /JPXDecode\\n\" +\n    \"  /Width 100\\n\" +\n    \"  /Height 100\\n\" +\n    \"  /ColorSpace /DeviceRGB\\n\" +\n    \"  /BitsPerComponent 8\\n\" +\n    \"  /Length 7\\n\" +\n    \">>\\n\" +\n    \"stream\\n\" +\n    \"JP2\\n\" +\n    \"endstream\\n\" +\n    \"endobj\\n\" +\n    \"endobj\\n\"\n  );\n\n  const xref = new XRefMock();\n  const stream = new StringStream(examplePdfBuffer);\n\n  try {\n    await xref.load(stream, {\n      start: 0,\n      end: examplePdfBuffer.length,\n    });\n  } catch (e) {\n    console.error(\"Error loading PDF\", e);\n  }\n\n  const pdfDocument = await PDFDocumentLoadingTask.create(xref).promise;\n\n  const firstPagePromise = pdfDocument.getPage(1).promise;\n  const page = await firstPagePromise;\n\n  const imagePromise = page.drawImageToImage();\n  const image = await imagePromise;\n\n  expect(image).not.toBeNull();\n});",
    "i3_gpt-4o": "it(\"should render large images in PDF\", async () => {\n  const { getDocument } = await import(\"../../src/display/api.js\");\n  const loadingTask = getDocument(\"https://github.com/mozilla/pdf.js/files/13391396/example.pdf\");\n  const pdfDocument = await loadingTask.promise;\n  const page = await pdfDocument.getPage(1);\n  const viewport = page.getViewport({ scale: 1.0 });\n  const canvasFactory = new DefaultCanvasFactory();\n  const canvasAndContext = canvasFactory.create(viewport.width, viewport.height);\n  const renderTask = page.render({\n    canvasContext: canvasAndContext.context,\n    viewport,\n  });\n  await renderTask.promise;\n  const imageData = canvasAndContext.context.getImageData(0, 0, viewport.width, viewport.height);\n  const hasNonWhitePixels = imageData.data.some((value, index) => index % 4 !== 3 && value !== 255);\n  expect(hasNonWhitePixels).toBe(true);\n});",
    "i3_llama-3.3-70b-versatile": "it(\"should render large images in PDF that other renderers do\", async () => {\n  const pdfUrl = \"https://github.com/mozilla/pdf.js/files/13391396/example.pdf\";\n  const pdfDocument = await fetch(pdfUrl).then((response) => response.arrayBuffer());\n  const pdf = await import(\"../../src/display/api.js\");\n  const pdfDoc = await pdf.PDFDocumentLoadingTask.fromBytes(pdfDocument, null);\n  const firstPage = await pdfDoc.getPage(1);\n  const image = firstPage.getOperatorList().getItems().find((item) => item.op === \"Do\");\n  const imageStream = await firstPage.getOperatorList().getContext().streamForImage(image.args[0]);\n  const imageData = await imageStream.getBytes();\n  const jpxImage = await import(\"../../src/core/jpx.js\").then((module) => module.JpxImage);\n  const decodedImage = jpxImage.decode(imageData, false);\n  expect(decodedImage.width).toBeGreaterThan(0);\n  expect(decodedImage.height).toBeGreaterThan(0);\n});",
    "i4_deepseek-r1-distill-llama-70b": "it(\"should render large scanned images in PDF\", async () => {\n  const { PDFDocument } = await import(\"../../web/pdf_document.js\");\n  const { Worker } = await import(\"../../build/pdfjs-worker.js\");\n\n  const examplePdfUrl = \"../../src/core/example.pdf\";\n  const exampleFile = new File([new Blob()], \"example.pdf\");\n  const exampleFileUrl = URL.createObjectURL(exampleFile);\n\n  const worker = new Worker(\"pdfjs-worker.js\");\n  const pdf = await PDFDocument.load(exampleFileUrl, { worker });\n  const page = await pdf.getPage(1);\n  const viewport = page.getViewport({ scale: 1 });\n  const canvas = document.createElement('canvas');\n  canvas.width = viewport.width;\n  canvas.height = viewport.height;\n\n  const renderTask = page.render({\n    canvasContext: canvas.getContext('2d'),\n    viewport,\n  });\n\n  await renderTask.promise;\n\n  const ctx = canvas.getContext('2d');\n  const imgData = ctx.getImageData(0, 0, canvas.width, canvas.height);\n  const pixels = imgData.data;\n\n  const expectedNonTransparent = true;\n  const actualNonTransparent = pixels.some((value) => value !== 0);\n\n  expect(actualNonTransparent).toBe(expectedNonTransparent);\n});",
    "i4_gpt-4o": "it(\"should render large images in PDF correctly\", async () => {\n  const { PDFDocument } = await import(\"../../src/core/document.js\");\n  const { buildGetDocumentParams } = await import(\"./test_utils.js\");\n  const { getDocument } = await import(\"../../src/display/api.js\");\n\n  const loadingTask = getDocument(buildGetDocumentParams(\"example.pdf\"));\n  const pdfDocument = await loadingTask.promise;\n  const page = await pdfDocument.getPage(1);\n\n  const viewport = page.getViewport({ scale: 1.0 });\n  const canvasFactory = new DOMCanvasFactory();\n  const canvasAndContext = canvasFactory.create(viewport.width, viewport.height);\n  const renderContext = {\n    canvasContext: canvasAndContext.context,\n    viewport: viewport,\n  };\n\n  const renderTask = page.render(renderContext);\n  await renderTask.promise;\n\n  const imageData = canvasAndContext.context.getImageData(0, 0, viewport.width, viewport.height);\n  const hasRenderedImage = imageData.data.some(value => value !== 0);\n\n  expect(hasRenderedImage).toBe(true);\n});",
    "i4_llama-3.3-70b-versatile": "it(\"should render large images in PDF that other renderers do\", async () => {\n  const { PDFDocument } = await import(\"../../src/display/api.js\");\n  const { JpxImage } = await import(\"../../src/core/jpx.js\");\n  const pdf = await PDFDocument.load(await fetch(\"example.pdf\").then(res => res.arrayBuffer()));\n  const page = await pdf.getPage(1);\n  const operatorList = await page.getOperatorList();\n  const image = operatorList.items.find(item => item instanceof JpxImage);\n  const imageData = await image.getImageBytes(1000000);\n  const expectedWidth = 1654;\n  const expectedHeight = 2339;\n  const actualWidth = image.width;\n  const actualHeight = image.height;\n  expect(actualWidth).toBe(expectedWidth);\n  expect(actualHeight).toBe(expectedHeight);\n});",
    "i5_deepseek-r1-distill-llama-70b": "it(\"should render large scanned images in PDFs\", async () => {\n  const { PDFDocument } = await import(\"../../src/core/document.js\");\n  const { OpenJPEG } = await import(\"../../external/openjpeg/openjpeg.js\");\n\n  const examplePdf = await fetch(\"https://github.com/mozilla/pdf.js/files/13391396/example.pdf\");\n  const pdfData = await examplePdf.arrayBuffer();\n\n  const pdf = await PDFDocument.load(\n    new Uint8Array(pdfData),\n    {\n      onProgress: (progress) => {\n        if (progress === 1) {\n          throw new Error(\"PDF failed to load\");\n        }\n      },\n    }\n  );\n\n  const page = await pdf.getPage(1);\n  const viewport = page.getViewport({ scale: 1 });\n  const renderTask = page.render({\n    viewport,\n    canvasContext: { willReadFrequently: true },\n    flags: new Set([\"APPEARANCE\"]),\n  });\n\n  const result = await renderTask.promise;\n\n  if (!result || !result.resolved) {\n    throw new Error(\"Image rendering failed\");\n  }\n\n  expect(result).toBeTruthy();\n});",
    "i5_gpt-4o": "it(\"should render large images in PDF\", async () => {\n  const { getDocument } = await import(\"../../src/display/api.js\");\n  const { buildGetDocumentParams } = await import(\"./test_utils.js\");\n\n  const loadingTask = getDocument(buildGetDocumentParams(\"example.pdf\"));\n  const pdfDocument = await loadingTask.promise;\n  const pdfPage = await pdfDocument.getPage(1);\n\n  const viewport = pdfPage.getViewport({ scale: 1.0 });\n  const canvasFactory = new (await import(\"../../src/display/display_utils.js\")).DOMCanvasFactory();\n  const canvasAndContext = canvasFactory.create(viewport.width, viewport.height);\n  const renderTask = pdfPage.render({\n    canvasContext: canvasAndContext.context,\n    viewport,\n  });\n\n  await renderTask.promise;\n\n  const imageData = canvasAndContext.context.getImageData(0, 0, viewport.width, viewport.height);\n  const hasNonWhitePixels = imageData.data.some((value, index) => index % 4 !== 3 && value !== 255);\n\n  expect(hasNonWhitePixels).toBe(true);\n});",
    "i5_llama-3.3-70b-versatile": "it(\"should render large images in PDF\", async () => {\n  const { PDFDocument } = await import(\"../../src/display/api.js\");\n  const pdf = await PDFDocument.load(await (await import(\"../../src/display/fetch_stream.js\")).PDFFetchStream.fetch(\"https://github.com/mozilla/pdf.js/files/13391396/example.pdf\"));\n  const page = await pdf.getPage(1);\n  const image = await page.getImage(0);\n  const expectedWidth = 1650;\n  const expectedHeight = 2338;\n  const actualWidth = image.width;\n  const actualHeight = image.height;\n  expect(actualWidth).toBe(expectedWidth);\n  expect(actualHeight).toBe(expectedHeight);\n});"
  },
  "17956": {
    "i1_deepseek-r1-distill-llama-70b": "it(\"should throw JpxError with OpenJPEG message when decode fails\", async () => {\n  const { JpxImage } = await import(\"../../src/core/jpx.js\");\n  const { JpxError } = await import(\"../../src/core/jpx.js\");\n\n  const data = Buffer.alloc(0);\n  const error = new JpxError(\"OpenJPEG: Unknown format\");\n\n  try {\n    await JpxImage.decode(data, false);\n    throw new Error(\"Expected JpxError to be thrown\");\n  } catch (e) {\n    if (e instanceof JpxError) {\n      expect(e.message).toBe(\"OpenJPEG: Unknown format\");\n    } else {\n      throw e;\n    }\n  }\n});",
    "i1_gpt-4o": "it(\"should not log OpenJPEG Unknown format to the console\", async () => {\n  const { JpxImage } = await import(\"../../src/core/jpx.js\");\n  const consoleSpy = jest.spyOn(console, 'log').mockImplementation(() => {});\n  const data = new Uint8Array([0, 1, 2, 3]); // Example data\n  try {\n    JpxImage.decode(data, false);\n  } catch (e) {\n    // Expected to throw JpxError\n  }\n  expect(consoleSpy).not.toHaveBeenCalledWith(expect.stringContaining(\"OpenJPEG: Unknown format\"));\n  consoleSpy.mockRestore();\n});",
    "i2_deepseek-r1-distill-llama-70b": "it(\"should throw JpxError with OpenJPEG error message\", async () => {\n  const { JpxImage, JpxError } = await import(\"../../src/core/jpx.js\");\n  const invalidData = new Uint8Array([0x00, 0x00, 0x00, 0x00]); // Invalid JPX data\n\n  const error = await JpxImage.decode(invalidData, false).catch((error) => {\n    return error;\n  });\n\n  expect(error).toBeInstanceOf(JpxError);\n  expect(error.message).toBe(\"Unknown format\");\n});",
    "i2_gpt-4o": "it(\"should throw a JpxError with the error message from OpenJPEG\", async () => {\n  const { JpxImage } = await import(\"../../src/core/jpx.js\");\n  const { JpxError } = await import(\"../../src/shared/util.js\");\n\n  const invalidData = new Uint8Array([0, 1, 2, 3]); // Example of invalid JPX data\n  const expectedErrorMessage = \"OpenJPEG: Unknown format\";\n\n  let actualErrorMessage = null;\n  try {\n    JpxImage.decode(invalidData, false);\n  } catch (error) {\n    if (error instanceof JpxError) {\n      actualErrorMessage = error.message;\n    }\n  }\n\n  expect(actualErrorMessage).toBe(expectedErrorMessage);\n});",
    "i3_deepseek-r1-distill-llama-70b": "it(\"should throw specific JpxError with OpenJPEG error message\", async () => {\n  const { JpxImage } = await import(\"../../src/core/jpx.js\");\n  const data = new Uint8Array(5); // Small buffer to trigger OpenJPEG error\n\n  let error;\n  try {\n    JpxImage.decode(data, false);\n  } catch (e) {\n    error = e;\n  }\n\n  expect(error).toBeInstanceOf(JpxError);\n  expect(error.message).toContain(\"Unknown format\");\n});",
    "i3_gpt-4o": "it(\"should not log OpenJPEG Unknown format to the console\", async () => {\n  const { JpxImage } = await import(\"../../src/core/jpx.js\");\n  const { Stream } = await import(\"../../src/core/stream.js\");\n\n  const data = new Uint8Array([0, 1, 2, 3]); // Example invalid JPX data\n  const stream = new Stream(data);\n\n  const originalConsoleError = console.error;\n  let consoleOutput = \"\";\n  console.error = (msg) => {\n    consoleOutput += msg;\n  };\n\n  try {\n    JpxImage.decode(stream, false);\n  } catch (e) {\n    // Expected to throw an error\n  }\n\n  console.error = originalConsoleError;\n\n  const expectedOutput = \"\";\n  expect(consoleOutput).toBe(expectedOutput);\n});",
    "i3_llama-3.3-70b-versatile": "it(\"should not log OpenJPEG Unknown format when decoding JPX image\", async () => {\n  const { JpxImage } = await import(\"../../src/core/jpx.js\");\n  const consoleSpy = jest.spyOn(console, 'log');\n  const imageData = new Uint8Array([0xff, 0x4f, 0xff, 0x51]);\n  try {\n    JpxImage.decode(imageData, false);\n  } catch (error) {\n    expect(consoleSpy).not.toHaveBeenCalledWith('OpenJPEG: Unknown format');\n  }\n});",
    "i4_deepseek-r1-distill-llama-70b": "it(\"should throw specific error message when decoding invalid JPX\", async () => {\n  const { JpxImage } = await import(\"../../src/core/jpx.js\");\n  const invalidJpxData = new Uint8Array([0x00, 0x00, 0x00, 0x00]); // Invalid JPX data\n\n  try {\n    await JpxImage.decode(invalidJpxData, false);\n    throw new Error(\"Expected JpxError to be thrown\");\n  } catch (error) {\n    if (error instanceof JpxError) {\n      const expectedMessage = \"Unknown format\";\n      expect(error.message).toBe(`JPX error: ${expectedMessage}`);\n    } else {\n      throw error;\n    }\n  }\n});",
    "i4_llama-3.3-70b-versatile": "it(\"should not log OpenJPEG Unknown format when decoding fails\", async () => {\n  const { JpxImage } = await import(\"../../src/core/jpx.js\");\n  const consoleSpy = jest.spyOn(console, 'log');\n  const data = new Uint8Array([0xff, 0x4f, 0xff, 0x51]); // Invalid JPX data\n  try {\n    JpxImage.decode(data, false);\n  } catch (error) {\n    expect(consoleSpy).not.toHaveBeenCalledWith('OpenJPEG: Unknown format');\n  }\n});",
    "i5_deepseek-r1-distill-llama-70b": "it(\"should not log OpenJPEG errors when decoding invalid JPX\", async () => {\n  const { JpxImage } = await import(\"../../src/core/jpx.js\");\n  const { TestReporter } = await import(\"./testreporter.js\");\n\n  const reporter = new TestReporter();\n  let errorLogged = false;\n  const originalConsoleError = console.error;\n\n  console.error = (message) => {\n    if (message.includes(\"OpenJPEG: Unknown format\")) {\n      errorLogged = true;\n    }\n    originalConsoleError(message);\n  };\n\n  try {\n    await JpxImage.decode(Buffer.alloc(0), false);\n  } catch (error) {\n    if (error instanceof JpxImage.JpxError) {\n      // Expected error, but we check for the logs\n    }\n  }\n\n  assert.equal(errorLogged, false);\n});",
    "i5_gpt-4o": "it(\"should not log OpenJPEG Unknown format when decoding JPX\", async () => {\n  const { JpxImage } = await import(\"../../src/core/jpx.js\");\n  const { JpxError } = await import(\"../../src/shared/util.js\");\n\n  const data = new Uint8Array([0, 1, 2, 3]); // Example invalid JPX data\n  const ignoreColorSpace = false;\n  let errorMessage = \"\";\n\n  try {\n    JpxImage.decode(data, ignoreColorSpace);\n  } catch (error) {\n    if (error instanceof JpxError) {\n      errorMessage = error.message;\n    }\n  }\n\n  const expectedMessage = \"JPX decode failed\";\n  expect(errorMessage).toBe(expectedMessage);\n});",
    "i5_llama-3.3-70b-versatile": "it(\"should not log OpenJPEG Unknown format to the console when decoding JPX image\", async () => {\n  const { JpxImage } = await import(\"../../src/core/jpx.js\");\n  const consoleSpy = jest.spyOn(console, 'log');\n  const imageData = new Uint8Array([0x00, 0x00, 0x00, 0x0C, 0x6A, 0x50, 0x20, 0x20, 0x0D, 0x0A, 0x87, 0x0A]);\n  try {\n    JpxImage.decode(imageData, true);\n  } catch (error) {\n    expect(consoleSpy).not.toHaveBeenCalledWith('OpenJPEG: Unknown format');\n  }\n});"
  },
  "17985": {
    "i1_deepseek-r1-distill-llama-70b": "it(\"should respect verbosity level when decoding JPX images\", async () => {\n  const { JpxImage, VerbosityLevel, setVerbosityLevel, getVerbosityLevel } = await import(\"../../src/shared/util.js\");\n\n  let warned = false;\n  const originalWarn = console.warn;\n  console.warn = (msg) => {\n    if (msg.includes(\"OpenJPEG warning\")) {\n      warned = true;\n    }\n  };\n\n  try {\n    // Test with QUIET verbosity: should not warn\n    setVerbosityLevel(VerbosityLevel.QUERY);\n    await JpxImage.decode(new Uint8Array([0x00, 0x00, 0x00, 0x00])); // Invalid JPX data to trigger warning\n    expect(warned).toBe(false);\n\n    // Test with DEBUG verbosity: should warn\n    setVerbosityLevel(VerbosityLevel.DEBUG);\n    await JpxImage.decode(new Uint8Array([0x00, 0x00, 0x00, 0x00]));\n    expect(warned).toBe(true);\n  } finally {\n    console.warn = originalWarn;\n  }\n});\n\n\nit(\"should respect verbosity level when decoding JPX images\", async () => {\n  const { JpxImage, VerbosityLevel, setVerbosityLevel, getVerbosityLevel } = await import(\"../../src/shared/util.js\");\n\n  let warned = false;\n  const originalWarn = console.warn;\n  console.warn = (msg) => {\n    if (msg.includes(\"OpenJPEG warning\")) {\n      warned = true;\n    }\n  };\n\n  try {\n    // Test with QUIET verbosity: should not warn\n    setVerbosityLevel(VerbosityLevel.QUERY);\n    await JpxImage.decode(new Uint8Array([0x00, 0x00, 0x00, 0x00])); // Invalid JPX data to trigger warning\n    expect(warned).toBe(false);\n\n    // Test with DEBUG verbosity: should warn\n    setVerbosityLevel(VerbosityLevel.DEBUG);\n    await JpxImage.decode(new Uint8Array([0x00, 0x00, 0x00, 0x00]));\n    expect(warned).toBe(true);\n  } finally {\n    console.warn = originalWarn;\n  }\n});",
    "i1_gpt-4o": "it(\"should respect verbosity levels for OpenJPEG warnings\", async () => {\n  const { warn } = await import(\"../../src/shared/util.js\");\n  const originalWarn = console.warn;\n  let warningMessage = null;\n  console.warn = (msg) => {\n    warningMessage = msg;\n  };\n\n  setVerbosityLevel(VerbosityLevel.ERRORS);\n  JpxImage.decode(new Uint8Array([0, 1, 2, 3]), false);\n  expect(warningMessage).toBeNull();\n\n  setVerbosityLevel(VerbosityLevel.INFOS);\n  JpxImage.decode(new Uint8Array([0, 1, 2, 3]), false);\n  expect(warningMessage).not.toBeNull();\n\n  console.warn = originalWarn;\n});",
    "i1_llama-3.3-70b-versatile": "it(\"should respect the PDFjs verbosity levels for OpenJPEG warnings\", async () => {\n  const { setVerbosityLevel, getVerbosityLevel, VerbosityLevel, warn } = await import(\"../../src/shared/util.js\");\n  const { JpxImage } = await import(\"../../src/core/jpx.js\");\n  setVerbosityLevel(VerbosityLevel.WARN);\n  const originalWarn = console.warn;\n  const warnings = [];\n  console.warn = (...args) => warnings.push(...args);\n  JpxImage.decode(\"invalid_data\");\n  console.warn = originalWarn;\n  expect(warnings.length).toBe(0);\n  setVerbosityLevel(VerbosityLevel.ERRORS);\n  warnings.length = 0;\n  JpxImage.decode(\"invalid_data\");\n  expect(warnings.length).toBe(0);\n  setVerbosityLevel(VerbosityLevel.WARN);\n  const OpenJPEG = await import(\"../../external/openjpeg/openjpeg.js\");\n  const openjpeg = OpenJPEG({ warn });\n  openjpeg.decode(\"invalid_data\");\n  expect(warnings.length).toBe(1);\n});",
    "i2_deepseek-r1-distill-llama-70b": "it(\"should respect verbosity levels when decoding JPX images\", async () => {\n  const { JpxImage } = await import(\"../../src/core/jpx.js\");\n  const { Util, setVerbosityLevel, VerbosityLevel } = await import(\"../../shared/util.js\");\n\n  const mockWarn = jest.fn();\n  const originalWarn = Util.warn;\n  Util.warn = mockWarn;\n\n  // Mock OpenJPEG module\n  const mockOpenJPEG = {\n    decode: () => \"Warning message\"\n  };\n  const originalModule = JpxImage.#module;\n  JpxImage.#module = mockOpenJPEG;\n\n  // Test with verbosity level 0 (error)\n  setVerbosityLevel(VerbosityLevel.error);\n  expect(() => JpxImage.decode(new Uint8Array())).toThrow();\n  expect(mockWarn).not.toHaveBeenCalled();\n\n  // Reset mock\n  mockWarn.mockClear();\n\n  // Test with verbosity level 1 (info)\n  setVerbosityLevel(VerbosityLevel.info);\n  expect(() => JpxImage.decode(new Uint8Array())).toThrow();\n  expect(mockWarn).toHaveBeenCalled();\n\n  // Restore original module and warn\n  JpxImage.#module = originalModule;\n  Util.warn = originalWarn;\n});",
    "i2_llama-3.3-70b-versatile": "it(\"should use the pdfjs warn when using jpx decoder\", async () => {\n  const { JpxImage, setVerbosityLevel, getVerbosityLevel, warn } = await import(\"../../src/shared/util.js\");\n  const { OpenJPEG } = await import(\"../../external/openjpeg/openjpeg.js\");\n\n  setVerbosityLevel(0);\n  const originalWarn = console.warn;\n  console.warn = jest.fn();\n  const imageData = new Uint8Array([0x00, 0x00, 0x00, 0x0C, 0x6A, 0x50, 0x20, 0x20, 0x0D, 0x0A, 0x87, 0x0A]);\n  OpenJPEG().decode(imageData, true);\n  expect(console.warn).toHaveBeenCalledTimes(0);\n  console.warn = originalWarn;\n\n  setVerbosityLevel(1);\n  console.warn = jest.fn();\n  OpenJPEG({ warn }).decode(imageData, true);\n  expect(console.warn).toHaveBeenCalledTimes(1);\n  console.warn = originalWarn;\n});",
    "i3_deepseek-r1-distill-llama-70b": "it(\"should respect verbosity level when handling OpenJPEG warnings\", async () => {\n  const { JpxImage, JpxError } = await import(\"../../src/core/jpx.js\");\n  const { VerbosityLevel, setVerbosityLevel, getVerbosityLevel } = await import(\"../../src/shared/util.js\");\n\n  // Mock console.warn to track warnings\n  const mockConsoleWarn = jest.spyOn(console, 'warn').mockImplementation(() => {});\n\n  try {\n    // Set verbosity to error, which should suppress warnings\n    setVerbosityLevel(VerbosityLevel.error);\n\n    // Mock OpenJPEG decode to return a warning string\n    const mockOpenJPEG = {\n      decode: () => \"Warning message\",\n    };\n    JpxImage.decode = jest.fn(() => mockOpenJPEG.decode());\n\n    // Test with sample data\n    const testData = new Uint8Array([0xff, 0x51, 0x00, 0x00]);\n    const result = await JpxImage.decode(testData);\n\n    // Verify that no warning was logged\n    expect(mockConsoleWarn).not.toHaveBeenCalled();\n\n    // Cleanup\n    JpxImage.cleanup();\n  } finally {\n    // Restore original console.warn and verbosity level\n    mockConsoleWarn.mockRestore();\n    setVerbosityLevel(getVerbosityLevel());\n  }\n});",
    "i3_gpt-4o": "it(\"should respect verbosity levels for OpenJPEG warnings\", async () => {\n  const { warn } = await import(\"../../src/shared/util.js\");\n  const originalWarn = console.warn;\n  let warningMessage = null;\n  console.warn = (msg) => {\n    warningMessage = msg;\n  };\n\n  setVerbosityLevel(VerbosityLevel.ERRORS);\n  JpxImage.decode(new Uint8Array([0, 1, 2, 3]), false);\n  expect(warningMessage).toBeNull();\n\n  setVerbosityLevel(VerbosityLevel.INFOS);\n  JpxImage.decode(new Uint8Array([0, 1, 2, 3]), false);\n  expect(warningMessage).not.toBeNull();\n\n  console.warn = originalWarn;\n});",
    "i3_llama-3.3-70b-versatile": "it(\"should respect the PDFjs verbosity levels for OpenJPEG warnings\", async () => {\n  const { setVerbosityLevel, getVerbosityLevel, VerbosityLevel } = await import(\"../../src/shared/util.js\");\n  const { JpxImage } = await import(\"../../src/core/jpx.js\");\n  const originalVerbosityLevel = getVerbosityLevel();\n  setVerbosityLevel(VerbosityLevel.WARN);\n  const warnSpy = jest.spyOn(console, 'warn');\n  JpxImage.decode(new Uint8Array([0xff, 0x4f, 0xff, 0x51]), true);\n  expect(warnSpy).toHaveBeenCalledTimes(0);\n  setVerbosityLevel(VerbosityLevel.ERROR);\n  JpxImage.decode(new Uint8Array([0xff, 0x4f, 0xff, 0x51]), true);\n  expect(warnSpy).toHaveBeenCalledTimes(0);\n  setVerbosityLevel(VerbosityLevel.WARN);\n  setVerbosityLevel(originalVerbosityLevel);\n});",
    "i4_deepseek-r1-distill-llama-70b": "it(\"should respect verbosity level when logging OpenJPEG warnings\", async () => {\n  const { JpxImage } = await import(\"../../src/core/jpx.js\");\n  const { setVerbosityLevel, VerbosityLevel } = await import(\"../../shared/util.js\");\n\n  const mockConsoleWarn = jest.fn();\n  const originalConsoleWarn = console.warn;\n\n  // Test with verbosity NONE\n  setVerbosityLevel(VerbosityLevel.none);\n  console.warn = mockConsoleWarn;\n  const invalidJpxData = new Uint8Array([0x00, 0x00, 0x00, 0x00]); // Invalid JPX data to trigger warning\n  await expect(JpxImage.decode(invalidJpxData)).rejects.toThrow(JpxError);\n  expect(mockConsoleWarn).not.toHaveBeenCalled();\n  console.warn = originalConsoleWarn;\n\n  // Reset module for next test\n  JpxImage.cleanup();\n\n  // Test with verbosity WARNING\n  setVerbosityLevel(VerbosityLevel.warning);\n  console.warn = mockConsoleWarn;\n  await expect(JpxImage.decode(invalidJpxData)).rejects.toThrow(JpxError);\n  expect(mockConsoleWarn).toHaveBeenCalled();\n  console.warn = originalConsoleWarn;\n});",
    "i4_llama-3.3-70b-versatile": "it(\"should respect the PDFjs verbosity levels for OpenJPEG warnings\", async () => {\n  const { setVerbosityLevel, VerbosityLevel, warn } = await import(\"../../src/shared/util.js\");\n  const { JpxImage } = await import(\"../../src/core/jpx.js\");\n  const { OpenJPEG } = await import(\"../../external/openjpeg/openjpeg.js\");\n\n  setVerbosityLevel(VerbosityLevel.WARN);\n  let warned = false;\n  const originalWarn = warn;\n  warn = (message) => {\n    warned = true;\n  };\n\n  const openjpeg = OpenJPEG({ warn });\n  JpxImage.decode = () => {\n    openjpeg.decode(\"invalid data\");\n  };\n\n  JpxImage.decode();\n  expect(warned).toBe(true);\n\n  warned = false;\n  setVerbosityLevel(VerbosityLevel.ERRORS);\n  JpxImage.decode();\n  expect(warned).toBe(false);\n\n  warn = originalWarn;\n});",
    "i5_deepseek-r1-distill-llama-70b": "it(\"should respect verbosity level when logging OpenJPEG warnings\", async () => {\n  const { JpxImage } = await import(\"../../src/core/jpx.js\");\n  const { warn } = await import(\"../../shared/util.js\");\n\n  // Mock console.warn to track warnings\n  const mockWarn = jest.spyOn(console, 'warn').mockImplementation(() => {});\n\n  // Set verbosity level to 'error' which should suppress warnings\n  setVerbosityLevel('error');\n\n  // Test data that triggers an OpenJPEG warning\n  const testData = new Uint8Array([0x00, 0x6f, 0x62, 0x6a, 0x01, 0x00]); // Minimal JPX file\n\n  // Decode should not trigger a warning due to verbosity level\n  await JpxImage.decode(testData);\n\n  // Verify that console.warn was not called\n  expect(mockWarn).not.toHaveBeenCalled();\n\n  // Cleanup\n  mockWarn.mockRestore();\n});",
    "i5_llama-3.3-70b-versatile": "it(\"should respect the PDFjs verbosity levels for OpenJPEG warnings\", async () => {\n  const { setVerbosityLevel, VerbosityLevel, JpxImage } = await import(\"../../src/core/jpx.js\");\n  const { Util } = await import(\"../../src/shared/util.js\");\n  setVerbosityLevel(VerbosityLevel.DISABLE);\n  const originalWarn = console.warn;\n  let warned = false;\n  console.warn = () => {\n    warned = true;\n  };\n  const imageData = JpxImage.decode(new Uint8Array([0x00, 0x00, 0x00, 0x0C, 0x6A, 0x50, 0x20, 0x20, 0x0D, 0x0A, 0x87, 0x0A]));\n  console.warn = originalWarn;\n  if (imageData instanceof Error) {\n    warned = true;\n  }\n  expect(warned).toBe(false);\n});"
  },
  "18029": {
    "i1_deepseek-r1-distill-llama-70b": "it(\"should return valid URLs for alpha and luminosity SMask filters\", async () => {\n  const { DOMFilterFactory } = await import(\"../../src/display/display_utils.js\");\n  const factory = new DOMFilterFactory({ docId: 1 });\n  const map = Array.from({ length: 256 }, (_, i) => i);\n  const alphaFilterUrl = factory.addAlphaFilter(map);\n  const luminosityFilterUrl = factory.addLuminosityFilter(map);\n  if (alphaFilterUrl === \"none\" || luminosityFilterUrl === \"none\") {\n    throw new Error(\"SMask filter not applied properly\");\n  }\n  if (!alphaFilterUrl.includes(\"alpha_map\") || !luminosityFilterUrl.includes(\"luminosity_map\")) {\n    throw new Error(\"Unexpected filter URL format: \" + alphaFilterUrl + \" / \" + luminosityFilterUrl);\n  }\n});",
    "i1_gpt-4o": "it(\"should return valid URLs for alpha and luminosity SMask filters\", async () => {\n  const { DOMFilterFactory } = await import(\"../../src/display/display_utils.js\");\n  const factory = new DOMFilterFactory({ docId: 1 });\n  const map = Array.from({ length: 256 }, (_, i) => i);\n  const alphaFilterUrl = factory.addAlphaFilter(map);\n  const luminosityFilterUrl = factory.addLuminosityFilter(map);\n  if (alphaFilterUrl === \"none\" || luminosityFilterUrl === \"none\") {\n    throw new Error(\"SMask filter not applied properly\");\n  }\n  if (!alphaFilterUrl.includes(\"alpha_map\") || !luminosityFilterUrl.includes(\"luminosity_map\")) {\n    throw new Error(\"Unexpected filter URL format: \" + alphaFilterUrl + \" / \" + luminosityFilterUrl);\n  }\n});",
    "i1_llama-3.3-70b-versatile": "it(\"should return valid URLs for alpha and luminosity SMask filters\", async () => {\n  const { DOMFilterFactory } = await import(\"../../src/display/display_utils.js\");\n  const factory = new DOMFilterFactory({ docId: 1 });\n  const map = Array.from({ length: 256 }, (_, i) => i);\n  const alphaFilterUrl = factory.addAlphaFilter(map);\n  const luminosityFilterUrl = factory.addLuminosityFilter(map);\n  if (alphaFilterUrl === \"none\" || luminosityFilterUrl === \"none\") {\n    throw new Error(\"SMask filter not applied properly\");\n  }\n  if (!alphaFilterUrl.includes(\"alpha_map\") || !luminosityFilterUrl.includes(\"luminosity_map\")) {\n    throw new Error(\"Unexpected filter URL format: \" + alphaFilterUrl + \" / \" + luminosityFilterUrl);\n  }\n});",
    "i1_MOCK": "it(\"should return valid URLs for alpha and luminosity SMask filters\", async () => {\n  const { DOMFilterFactory } = await import(\"../../src/display/display_utils.js\");\n  const factory = new DOMFilterFactory({ docId: 1 });\n  const map = Array.from({ length: 256 }, (_, i) => i);\n  const alphaFilterUrl = factory.addAlphaFilter(map);\n  const luminosityFilterUrl = factory.addLuminosityFilter(map);\n  if (alphaFilterUrl === \"none\" || luminosityFilterUrl === \"none\") {\n    throw new Error(\"SMask filter not applied properly\");\n  }\n  if (!alphaFilterUrl.includes(\"alpha_map\") || !luminosityFilterUrl.includes(\"luminosity_map\")) {\n    throw new Error(\"Unexpected filter URL format: \" + alphaFilterUrl + \" / \" + luminosityFilterUrl);\n  }\n});",
    "i2_deepseek-r1-distill-llama-70b": "it(\"should return valid URLs for alpha and luminosity SMask filters\", async () => {\n  const { DOMFilterFactory } = await import(\"../../src/display/display_utils.js\");\n  const factory = new DOMFilterFactory({ docId: 1 });\n  const map = Array.from({ length: 256 }, (_, i) => i);\n  const alphaFilterUrl = factory.addAlphaFilter(map);\n  const luminosityFilterUrl = factory.addLuminosityFilter(map);\n  if (alphaFilterUrl === \"none\" || luminosityFilterUrl === \"none\") {\n    throw new Error(\"SMask filter not applied properly\");\n  }\n  if (!alphaFilterUrl.includes(\"alpha_map\") || !luminosityFilterUrl.includes(\"luminosity_map\")) {\n    throw new Error(\"Unexpected filter URL format: \" + alphaFilterUrl + \" / \" + luminosityFilterUrl);\n  }\n});",
    "i2_gpt-4o": "it(\"should return valid URLs for alpha and luminosity SMask filters\", async () => {\n  const { DOMFilterFactory } = await import(\"../../src/display/display_utils.js\");\n  const factory = new DOMFilterFactory({ docId: 1 });\n  const map = Array.from({ length: 256 }, (_, i) => i);\n  const alphaFilterUrl = factory.addAlphaFilter(map);\n  const luminosityFilterUrl = factory.addLuminosityFilter(map);\n  if (alphaFilterUrl === \"none\" || luminosityFilterUrl === \"none\") {\n    throw new Error(\"SMask filter not applied properly\");\n  }\n  if (!alphaFilterUrl.includes(\"alpha_map\") || !luminosityFilterUrl.includes(\"luminosity_map\")) {\n    throw new Error(\"Unexpected filter URL format: \" + alphaFilterUrl + \" / \" + luminosityFilterUrl);\n  }\n});",
    "i2_llama-3.3-70b-versatile": "it(\"should return valid URLs for alpha and luminosity SMask filters\", async () => {\n  const { DOMFilterFactory } = await import(\"../../src/display/display_utils.js\");\n  const factory = new DOMFilterFactory({ docId: 1 });\n  const map = Array.from({ length: 256 }, (_, i) => i);\n  const alphaFilterUrl = factory.addAlphaFilter(map);\n  const luminosityFilterUrl = factory.addLuminosityFilter(map);\n  if (alphaFilterUrl === \"none\" || luminosityFilterUrl === \"none\") {\n    throw new Error(\"SMask filter not applied properly\");\n  }\n  if (!alphaFilterUrl.includes(\"alpha_map\") || !luminosityFilterUrl.includes(\"luminosity_map\")) {\n    throw new Error(\"Unexpected filter URL format: \" + alphaFilterUrl + \" / \" + luminosityFilterUrl);\n  }\n});",
    "i3_deepseek-r1-distill-llama-70b": "it(\"should return valid URLs for alpha and luminosity SMask filters\", async () => {\n  const { DOMFilterFactory } = await import(\"../../src/display/display_utils.js\");\n  const factory = new DOMFilterFactory({ docId: 1 });\n  const map = Array.from({ length: 256 }, (_, i) => i);\n  const alphaFilterUrl = factory.addAlphaFilter(map);\n  const luminosityFilterUrl = factory.addLuminosityFilter(map);\n  if (alphaFilterUrl === \"none\" || luminosityFilterUrl === \"none\") {\n    throw new Error(\"SMask filter not applied properly\");\n  }\n  if (!alphaFilterUrl.includes(\"alpha_map\") || !luminosityFilterUrl.includes(\"luminosity_map\")) {\n    throw new Error(\"Unexpected filter URL format: \" + alphaFilterUrl + \" / \" + luminosityFilterUrl);\n  }\n});",
    "i3_gpt-4o": "it(\"should return valid URLs for alpha and luminosity SMask filters\", async () => {\n  const { DOMFilterFactory } = await import(\"../../src/display/display_utils.js\");\n  const factory = new DOMFilterFactory({ docId: 1 });\n  const map = Array.from({ length: 256 }, (_, i) => i);\n  const alphaFilterUrl = factory.addAlphaFilter(map);\n  const luminosityFilterUrl = factory.addLuminosityFilter(map);\n  if (alphaFilterUrl === \"none\" || luminosityFilterUrl === \"none\") {\n    throw new Error(\"SMask filter not applied properly\");\n  }\n  if (!alphaFilterUrl.includes(\"alpha_map\") || !luminosityFilterUrl.includes(\"luminosity_map\")) {\n    throw new Error(\"Unexpected filter URL format: \" + alphaFilterUrl + \" / \" + luminosityFilterUrl);\n  }\n});",
    "i3_llama-3.3-70b-versatile": "it(\"should return valid URLs for alpha and luminosity SMask filters\", async () => {\n  const { DOMFilterFactory } = await import(\"../../src/display/display_utils.js\");\n  const factory = new DOMFilterFactory({ docId: 1 });\n  const map = Array.from({ length: 256 }, (_, i) => i);\n  const alphaFilterUrl = factory.addAlphaFilter(map);\n  const luminosityFilterUrl = factory.addLuminosityFilter(map);\n  if (alphaFilterUrl === \"none\" || luminosityFilterUrl === \"none\") {\n    throw new Error(\"SMask filter not applied properly\");\n  }\n  if (!alphaFilterUrl.includes(\"alpha_map\") || !luminosityFilterUrl.includes(\"luminosity_map\")) {\n    throw new Error(\"Unexpected filter URL format: \" + alphaFilterUrl + \" / \" + luminosityFilterUrl);\n  }\n});",
    "i4_deepseek-r1-distill-llama-70b": "it(\"should return valid URLs for alpha and luminosity SMask filters\", async () => {\n  const { DOMFilterFactory } = await import(\"../../src/display/display_utils.js\");\n  const factory = new DOMFilterFactory({ docId: 1 });\n  const map = Array.from({ length: 256 }, (_, i) => i);\n  const alphaFilterUrl = factory.addAlphaFilter(map);\n  const luminosityFilterUrl = factory.addLuminosityFilter(map);\n  if (alphaFilterUrl === \"none\" || luminosityFilterUrl === \"none\") {\n    throw new Error(\"SMask filter not applied properly\");\n  }\n  if (!alphaFilterUrl.includes(\"alpha_map\") || !luminosityFilterUrl.includes(\"luminosity_map\")) {\n    throw new Error(\"Unexpected filter URL format: \" + alphaFilterUrl + \" / \" + luminosityFilterUrl);\n  }\n});",
    "i4_gpt-4o": "it(\"should return valid URLs for alpha and luminosity SMask filters\", async () => {\n  const { DOMFilterFactory } = await import(\"../../src/display/display_utils.js\");\n  const factory = new DOMFilterFactory({ docId: 1 });\n  const map = Array.from({ length: 256 }, (_, i) => i);\n  const alphaFilterUrl = factory.addAlphaFilter(map);\n  const luminosityFilterUrl = factory.addLuminosityFilter(map);\n  if (alphaFilterUrl === \"none\" || luminosityFilterUrl === \"none\") {\n    throw new Error(\"SMask filter not applied properly\");\n  }\n  if (!alphaFilterUrl.includes(\"alpha_map\") || !luminosityFilterUrl.includes(\"luminosity_map\")) {\n    throw new Error(\"Unexpected filter URL format: \" + alphaFilterUrl + \" / \" + luminosityFilterUrl);\n  }\n});",
    "i4_llama-3.3-70b-versatile": "it(\"should return valid URLs for alpha and luminosity SMask filters\", async () => {\n  const { DOMFilterFactory } = await import(\"../../src/display/display_utils.js\");\n  const factory = new DOMFilterFactory({ docId: 1 });\n  const map = Array.from({ length: 256 }, (_, i) => i);\n  const alphaFilterUrl = factory.addAlphaFilter(map);\n  const luminosityFilterUrl = factory.addLuminosityFilter(map);\n  if (alphaFilterUrl === \"none\" || luminosityFilterUrl === \"none\") {\n    throw new Error(\"SMask filter not applied properly\");\n  }\n  if (!alphaFilterUrl.includes(\"alpha_map\") || !luminosityFilterUrl.includes(\"luminosity_map\")) {\n    throw new Error(\"Unexpected filter URL format: \" + alphaFilterUrl + \" / \" + luminosityFilterUrl);\n  }\n});",
    "i5_deepseek-r1-distill-llama-70b": "it(\"should return valid URLs for alpha and luminosity SMask filters\", async () => {\n  const { DOMFilterFactory } = await import(\"../../src/display/display_utils.js\");\n  const factory = new DOMFilterFactory({ docId: 1 });\n  const map = Array.from({ length: 256 }, (_, i) => i);\n  const alphaFilterUrl = factory.addAlphaFilter(map);\n  const luminosityFilterUrl = factory.addLuminosityFilter(map);\n  if (alphaFilterUrl === \"none\" || luminosityFilterUrl === \"none\") {\n    throw new Error(\"SMask filter not applied properly\");\n  }\n  if (!alphaFilterUrl.includes(\"alpha_map\") || !luminosityFilterUrl.includes(\"luminosity_map\")) {\n    throw new Error(\"Unexpected filter URL format: \" + alphaFilterUrl + \" / \" + luminosityFilterUrl);\n  }\n});",
    "i5_gpt-4o": "it(\"should return valid URLs for alpha and luminosity SMask filters\", async () => {\n  const { DOMFilterFactory } = await import(\"../../src/display/display_utils.js\");\n  const factory = new DOMFilterFactory({ docId: 1 });\n  const map = Array.from({ length: 256 }, (_, i) => i);\n  const alphaFilterUrl = factory.addAlphaFilter(map);\n  const luminosityFilterUrl = factory.addLuminosityFilter(map);\n  if (alphaFilterUrl === \"none\" || luminosityFilterUrl === \"none\") {\n    throw new Error(\"SMask filter not applied properly\");\n  }\n  if (!alphaFilterUrl.includes(\"alpha_map\") || !luminosityFilterUrl.includes(\"luminosity_map\")) {\n    throw new Error(\"Unexpected filter URL format: \" + alphaFilterUrl + \" / \" + luminosityFilterUrl);\n  }\n});",
    "i5_llama-3.3-70b-versatile": "it(\"should return valid URLs for alpha and luminosity SMask filters\", async () => {\n  const { DOMFilterFactory } = await import(\"../../src/display/display_utils.js\");\n  const factory = new DOMFilterFactory({ docId: 1 });\n  const map = Array.from({ length: 256 }, (_, i) => i);\n  const alphaFilterUrl = factory.addAlphaFilter(map);\n  const luminosityFilterUrl = factory.addLuminosityFilter(map);\n  if (alphaFilterUrl === \"none\" || luminosityFilterUrl === \"none\") {\n    throw new Error(\"SMask filter not applied properly\");\n  }\n  if (!alphaFilterUrl.includes(\"alpha_map\") || !luminosityFilterUrl.includes(\"luminosity_map\")) {\n    throw new Error(\"Unexpected filter URL format: \" + alphaFilterUrl + \" / \" + luminosityFilterUrl);\n  }\n});"
  },
  "18119": {
    "i1_deepseek-r1-distill-llama-70b": "it(\"should correctly handle char codes greater than 2311 in adjustMapping\", async () => {\n  const { adjustMapping } = await import(\"../../src/core/fonts.js\");\n  // create a mapping with a key greater than 2147483647\n  const inputMapping = { \"3000000000\": 42 };\n  const hasGlyph = glyphId => true;\n  const newGlyphZeroId = 0;\n  const toUnicode = new Map();\n  const result = adjustMapping(inputMapping, hasGlyph, newGlyphZeroId, toUnicode);\n  if (result.toFontChar[\"3000000000\"] === undefined) {\n    throw new Error(\"Failed to map char code '3000000000' correctly.\");\n  }\n});\n",
    "i1_gpt-4o": "it(\"should correctly handle char codes greater than 2311 in adjustMapping\", async () => {\n  const { adjustMapping } = await import(\"../../src/core/fonts.js\");\n  // create a mapping with a key greater than 2147483647\n  const inputMapping = { \"3000000000\": 42 };\n  const hasGlyph = glyphId => true;\n  const newGlyphZeroId = 0;\n  const toUnicode = new Map();\n  const result = adjustMapping(inputMapping, hasGlyph, newGlyphZeroId, toUnicode);\n  if (result.toFontChar[\"3000000000\"] === undefined) {\n    throw new Error(\"Failed to map char code '3000000000' correctly.\");\n  }\n});\n",
    "i1_llama-3.3-70b-versatile": "it(\"should correctly handle char codes greater than 2311 in adjustMapping\", async () => {\n  const { adjustMapping } = await import(\"../../src/core/fonts.js\");\n  // create a mapping with a key greater than 2147483647\n  const inputMapping = { \"3000000000\": 42 };\n  const hasGlyph = glyphId => true;\n  const newGlyphZeroId = 0;\n  const toUnicode = new Map();\n  const result = adjustMapping(inputMapping, hasGlyph, newGlyphZeroId, toUnicode);\n  if (result.toFontChar[\"3000000000\"] === undefined) {\n    throw new Error(\"Failed to map char code '3000000000' correctly.\");\n  }\n});\n",
    "i1_MOCK": "it(\"should correctly handle char codes greater than 2311 in adjustMapping\", async () => {\n  const { adjustMapping } = await import(\"../../src/core/fonts.js\");\n  // create a mapping with a key greater than 2147483647\n  const inputMapping = { \"3000000000\": 42 };\n  const hasGlyph = glyphId => true;\n  const newGlyphZeroId = 0;\n  const toUnicode = new Map();\n  const result = adjustMapping(inputMapping, hasGlyph, newGlyphZeroId, toUnicode);\n  if (result.toFontChar[\"3000000000\"] === undefined) {\n    throw new Error(\"Failed to map char code '3000000000' correctly.\");\n  }\n});\n",
    "i2_deepseek-r1-distill-llama-70b": "it(\"should correctly handle char codes greater than 2311 in adjustMapping\", async () => {\n  const { adjustMapping } = await import(\"../../src/core/fonts.js\");\n  // create a mapping with a key greater than 2147483647\n  const inputMapping = { \"3000000000\": 42 };\n  const hasGlyph = glyphId => true;\n  const newGlyphZeroId = 0;\n  const toUnicode = new Map();\n  const result = adjustMapping(inputMapping, hasGlyph, newGlyphZeroId, toUnicode);\n  if (result.toFontChar[\"3000000000\"] === undefined) {\n    throw new Error(\"Failed to map char code '3000000000' correctly.\");\n  }\n});\n",
    "i2_gpt-4o": "it(\"should correctly handle char codes greater than 2311 in adjustMapping\", async () => {\n  const { adjustMapping } = await import(\"../../src/core/fonts.js\");\n  // create a mapping with a key greater than 2147483647\n  const inputMapping = { \"3000000000\": 42 };\n  const hasGlyph = glyphId => true;\n  const newGlyphZeroId = 0;\n  const toUnicode = new Map();\n  const result = adjustMapping(inputMapping, hasGlyph, newGlyphZeroId, toUnicode);\n  if (result.toFontChar[\"3000000000\"] === undefined) {\n    throw new Error(\"Failed to map char code '3000000000' correctly.\");\n  }\n});\n",
    "i2_llama-3.3-70b-versatile": "it(\"should correctly handle char codes greater than 2311 in adjustMapping\", async () => {\n  const { adjustMapping } = await import(\"../../src/core/fonts.js\");\n  // create a mapping with a key greater than 2147483647\n  const inputMapping = { \"3000000000\": 42 };\n  const hasGlyph = glyphId => true;\n  const newGlyphZeroId = 0;\n  const toUnicode = new Map();\n  const result = adjustMapping(inputMapping, hasGlyph, newGlyphZeroId, toUnicode);\n  if (result.toFontChar[\"3000000000\"] === undefined) {\n    throw new Error(\"Failed to map char code '3000000000' correctly.\");\n  }\n});\n",
    "i3_deepseek-r1-distill-llama-70b": "it(\"should correctly handle char codes greater than 2311 in adjustMapping\", async () => {\n  const { adjustMapping } = await import(\"../../src/core/fonts.js\");\n  // create a mapping with a key greater than 2147483647\n  const inputMapping = { \"3000000000\": 42 };\n  const hasGlyph = glyphId => true;\n  const newGlyphZeroId = 0;\n  const toUnicode = new Map();\n  const result = adjustMapping(inputMapping, hasGlyph, newGlyphZeroId, toUnicode);\n  if (result.toFontChar[\"3000000000\"] === undefined) {\n    throw new Error(\"Failed to map char code '3000000000' correctly.\");\n  }\n});\n",
    "i3_gpt-4o": "it(\"should correctly handle char codes greater than 2311 in adjustMapping\", async () => {\n  const { adjustMapping } = await import(\"../../src/core/fonts.js\");\n  // create a mapping with a key greater than 2147483647\n  const inputMapping = { \"3000000000\": 42 };\n  const hasGlyph = glyphId => true;\n  const newGlyphZeroId = 0;\n  const toUnicode = new Map();\n  const result = adjustMapping(inputMapping, hasGlyph, newGlyphZeroId, toUnicode);\n  if (result.toFontChar[\"3000000000\"] === undefined) {\n    throw new Error(\"Failed to map char code '3000000000' correctly.\");\n  }\n});\n",
    "i3_llama-3.3-70b-versatile": "it(\"should correctly handle char codes greater than 2311 in adjustMapping\", async () => {\n  const { adjustMapping } = await import(\"../../src/core/fonts.js\");\n  // create a mapping with a key greater than 2147483647\n  const inputMapping = { \"3000000000\": 42 };\n  const hasGlyph = glyphId => true;\n  const newGlyphZeroId = 0;\n  const toUnicode = new Map();\n  const result = adjustMapping(inputMapping, hasGlyph, newGlyphZeroId, toUnicode);\n  if (result.toFontChar[\"3000000000\"] === undefined) {\n    throw new Error(\"Failed to map char code '3000000000' correctly.\");\n  }\n});\n",
    "i4_deepseek-r1-distill-llama-70b": "it(\"should correctly handle char codes greater than 2311 in adjustMapping\", async () => {\n  const { adjustMapping } = await import(\"../../src/core/fonts.js\");\n  // create a mapping with a key greater than 2147483647\n  const inputMapping = { \"3000000000\": 42 };\n  const hasGlyph = glyphId => true;\n  const newGlyphZeroId = 0;\n  const toUnicode = new Map();\n  const result = adjustMapping(inputMapping, hasGlyph, newGlyphZeroId, toUnicode);\n  if (result.toFontChar[\"3000000000\"] === undefined) {\n    throw new Error(\"Failed to map char code '3000000000' correctly.\");\n  }\n});\n",
    "i4_gpt-4o": "it(\"should correctly handle char codes greater than 2311 in adjustMapping\", async () => {\n  const { adjustMapping } = await import(\"../../src/core/fonts.js\");\n  // create a mapping with a key greater than 2147483647\n  const inputMapping = { \"3000000000\": 42 };\n  const hasGlyph = glyphId => true;\n  const newGlyphZeroId = 0;\n  const toUnicode = new Map();\n  const result = adjustMapping(inputMapping, hasGlyph, newGlyphZeroId, toUnicode);\n  if (result.toFontChar[\"3000000000\"] === undefined) {\n    throw new Error(\"Failed to map char code '3000000000' correctly.\");\n  }\n});\n",
    "i4_llama-3.3-70b-versatile": "it(\"should correctly handle char codes greater than 2311 in adjustMapping\", async () => {\n  const { adjustMapping } = await import(\"../../src/core/fonts.js\");\n  // create a mapping with a key greater than 2147483647\n  const inputMapping = { \"3000000000\": 42 };\n  const hasGlyph = glyphId => true;\n  const newGlyphZeroId = 0;\n  const toUnicode = new Map();\n  const result = adjustMapping(inputMapping, hasGlyph, newGlyphZeroId, toUnicode);\n  if (result.toFontChar[\"3000000000\"] === undefined) {\n    throw new Error(\"Failed to map char code '3000000000' correctly.\");\n  }\n});\n",
    "i5_deepseek-r1-distill-llama-70b": "it(\"should correctly handle char codes greater than 2311 in adjustMapping\", async () => {\n  const { adjustMapping } = await import(\"../../src/core/fonts.js\");\n  // create a mapping with a key greater than 2147483647\n  const inputMapping = { \"3000000000\": 42 };\n  const hasGlyph = glyphId => true;\n  const newGlyphZeroId = 0;\n  const toUnicode = new Map();\n  const result = adjustMapping(inputMapping, hasGlyph, newGlyphZeroId, toUnicode);\n  if (result.toFontChar[\"3000000000\"] === undefined) {\n    throw new Error(\"Failed to map char code '3000000000' correctly.\");\n  }\n});\n",
    "i5_gpt-4o": "it(\"should correctly handle char codes greater than 2311 in adjustMapping\", async () => {\n  const { adjustMapping } = await import(\"../../src/core/fonts.js\");\n  // create a mapping with a key greater than 2147483647\n  const inputMapping = { \"3000000000\": 42 };\n  const hasGlyph = glyphId => true;\n  const newGlyphZeroId = 0;\n  const toUnicode = new Map();\n  const result = adjustMapping(inputMapping, hasGlyph, newGlyphZeroId, toUnicode);\n  if (result.toFontChar[\"3000000000\"] === undefined) {\n    throw new Error(\"Failed to map char code '3000000000' correctly.\");\n  }\n});\n",
    "i5_llama-3.3-70b-versatile": "it(\"should correctly handle char codes greater than 2311 in adjustMapping\", async () => {\n  const { adjustMapping } = await import(\"../../src/core/fonts.js\");\n  // create a mapping with a key greater than 2147483647\n  const inputMapping = { \"3000000000\": 42 };\n  const hasGlyph = glyphId => true;\n  const newGlyphZeroId = 0;\n  const toUnicode = new Map();\n  const result = adjustMapping(inputMapping, hasGlyph, newGlyphZeroId, toUnicode);\n  if (result.toFontChar[\"3000000000\"] === undefined) {\n    throw new Error(\"Failed to map char code '3000000000' correctly.\");\n  }\n});\n"
  },
  "18125": {
    "i1_deepseek-r1-distill-llama-70b": "it(\"should correctly detect a truncated endstream marker and return the proper stream length\", async () => {\n  const assert = require(\"assert\");\n  const { StringStream } = await import(\"../../src/core/stream.js\");\n  const { Lexer, Parser } = await import(\"../../src/core/parser.js\");\n  // Construct a fake PDF stream:\n  // \"stream\" followed by a newline, then the stream data \"123456\",\n  // then a truncated \"endstream\" command \"endstrea \" (i.e. missing final character, but followed by whitespace),\n  // then a proper \"endstream\" (which will not be reached).\n  const pdfData = \"stream\\n123456endstrea \\nendstream\";\n  const stream = new StringStream(pdfData);\n  const lexer = new Lexer(stream);\n  const parser = new Parser({ lexer, xref: {} });\n  // Provide an incorrect declared length to force scanning for the endstream marker.\n  const dict = { get: key => key === \"Length\" ? 2 : null };\n  const resultStream = parser.makeStream(dict, null);\n  // The expected stream data is the bytes starting at startPos (one byte before the first character after \"stream\\n\")\n  // up to the beginning of the truncated \"endstream\" marker.\n  // In our pdfData, after \"stream\\n\" (i.e. after byte index 6), the data \"123456\" occupies 6 bytes,\n  // plus the newline before \"stream\" makes the total length 7.\n  const actualLength = resultStream.end - resultStream.pos;\n  assert.strictEqual(actualLength, 7);\n});",
    "i1_gpt-4o": "it(\"should correctly detect a truncated endstream marker and return the proper stream length\", async () => {\n  const assert = require(\"assert\");\n  const { StringStream } = await import(\"../../src/core/stream.js\");\n  const { Lexer, Parser } = await import(\"../../src/core/parser.js\");\n  // Construct a fake PDF stream:\n  // \"stream\" followed by a newline, then the stream data \"123456\",\n  // then a truncated \"endstream\" command \"endstrea \" (i.e. missing final character, but followed by whitespace),\n  // then a proper \"endstream\" (which will not be reached).\n  const pdfData = \"stream\\n123456endstrea \\nendstream\";\n  const stream = new StringStream(pdfData);\n  const lexer = new Lexer(stream);\n  const parser = new Parser({ lexer, xref: {} });\n  // Provide an incorrect declared length to force scanning for the endstream marker.\n  const dict = { get: key => key === \"Length\" ? 2 : null };\n  const resultStream = parser.makeStream(dict, null);\n  // The expected stream data is the bytes starting at startPos (one byte before the first character after \"stream\\n\")\n  // up to the beginning of the truncated \"endstream\" marker.\n  // In our pdfData, after \"stream\\n\" (i.e. after byte index 6), the data \"123456\" occupies 6 bytes,\n  // plus the newline before \"stream\" makes the total length 7.\n  const actualLength = resultStream.end - resultStream.pos;\n  assert.strictEqual(actualLength, 7);\n});",
    "i1_llama-3.3-70b-versatile": "it(\"should correctly detect a truncated endstream marker and return the proper stream length\", async () => {\n  const assert = require(\"assert\");\n  const { StringStream } = await import(\"../../src/core/stream.js\");\n  const { Lexer, Parser } = await import(\"../../src/core/parser.js\");\n  // Construct a fake PDF stream:\n  // \"stream\" followed by a newline, then the stream data \"123456\",\n  // then a truncated \"endstream\" command \"endstrea \" (i.e. missing final character, but followed by whitespace),\n  // then a proper \"endstream\" (which will not be reached).\n  const pdfData = \"stream\\n123456endstrea \\nendstream\";\n  const stream = new StringStream(pdfData);\n  const lexer = new Lexer(stream);\n  const parser = new Parser({ lexer, xref: {} });\n  // Provide an incorrect declared length to force scanning for the endstream marker.\n  const dict = { get: key => key === \"Length\" ? 2 : null };\n  const resultStream = parser.makeStream(dict, null);\n  // The expected stream data is the bytes starting at startPos (one byte before the first character after \"stream\\n\")\n  // up to the beginning of the truncated \"endstream\" marker.\n  // In our pdfData, after \"stream\\n\" (i.e. after byte index 6), the data \"123456\" occupies 6 bytes,\n  // plus the newline before \"stream\" makes the total length 7.\n  const actualLength = resultStream.end - resultStream.pos;\n  assert.strictEqual(actualLength, 7);\n});",
    "i1_MOCK": "it(\"should correctly detect a truncated endstream marker and return the proper stream length\", async () => {\n  const assert = require(\"assert\");\n  const { StringStream } = await import(\"../../src/core/stream.js\");\n  const { Lexer, Parser } = await import(\"../../src/core/parser.js\");\n  // Construct a fake PDF stream:\n  // \"stream\" followed by a newline, then the stream data \"123456\",\n  // then a truncated \"endstream\" command \"endstrea \" (i.e. missing final character, but followed by whitespace),\n  // then a proper \"endstream\" (which will not be reached).\n  const pdfData = \"stream\\n123456endstrea \\nendstream\";\n  const stream = new StringStream(pdfData);\n  const lexer = new Lexer(stream);\n  const parser = new Parser({ lexer, xref: {} });\n  // Provide an incorrect declared length to force scanning for the endstream marker.\n  const dict = { get: key => key === \"Length\" ? 2 : null };\n  const resultStream = parser.makeStream(dict, null);\n  // The expected stream data is the bytes starting at startPos (one byte before the first character after \"stream\\n\")\n  // up to the beginning of the truncated \"endstream\" marker.\n  // In our pdfData, after \"stream\\n\" (i.e. after byte index 6), the data \"123456\" occupies 6 bytes,\n  // plus the newline before \"stream\" makes the total length 7.\n  const actualLength = resultStream.end - resultStream.pos;\n  assert.strictEqual(actualLength, 7);\n});",
    "i2_deepseek-r1-distill-llama-70b": "it(\"should correctly detect a truncated endstream marker and return the proper stream length\", async () => {\n  const assert = require(\"assert\");\n  const { StringStream } = await import(\"../../src/core/stream.js\");\n  const { Lexer, Parser } = await import(\"../../src/core/parser.js\");\n  // Construct a fake PDF stream:\n  // \"stream\" followed by a newline, then the stream data \"123456\",\n  // then a truncated \"endstream\" command \"endstrea \" (i.e. missing final character, but followed by whitespace),\n  // then a proper \"endstream\" (which will not be reached).\n  const pdfData = \"stream\\n123456endstrea \\nendstream\";\n  const stream = new StringStream(pdfData);\n  const lexer = new Lexer(stream);\n  const parser = new Parser({ lexer, xref: {} });\n  // Provide an incorrect declared length to force scanning for the endstream marker.\n  const dict = { get: key => key === \"Length\" ? 2 : null };\n  const resultStream = parser.makeStream(dict, null);\n  // The expected stream data is the bytes starting at startPos (one byte before the first character after \"stream\\n\")\n  // up to the beginning of the truncated \"endstream\" marker.\n  // In our pdfData, after \"stream\\n\" (i.e. after byte index 6), the data \"123456\" occupies 6 bytes,\n  // plus the newline before \"stream\" makes the total length 7.\n  const actualLength = resultStream.end - resultStream.pos;\n  assert.strictEqual(actualLength, 7);\n});",
    "i2_gpt-4o": "it(\"should correctly detect a truncated endstream marker and return the proper stream length\", async () => {\n  const assert = require(\"assert\");\n  const { StringStream } = await import(\"../../src/core/stream.js\");\n  const { Lexer, Parser } = await import(\"../../src/core/parser.js\");\n  // Construct a fake PDF stream:\n  // \"stream\" followed by a newline, then the stream data \"123456\",\n  // then a truncated \"endstream\" command \"endstrea \" (i.e. missing final character, but followed by whitespace),\n  // then a proper \"endstream\" (which will not be reached).\n  const pdfData = \"stream\\n123456endstrea \\nendstream\";\n  const stream = new StringStream(pdfData);\n  const lexer = new Lexer(stream);\n  const parser = new Parser({ lexer, xref: {} });\n  // Provide an incorrect declared length to force scanning for the endstream marker.\n  const dict = { get: key => key === \"Length\" ? 2 : null };\n  const resultStream = parser.makeStream(dict, null);\n  // The expected stream data is the bytes starting at startPos (one byte before the first character after \"stream\\n\")\n  // up to the beginning of the truncated \"endstream\" marker.\n  // In our pdfData, after \"stream\\n\" (i.e. after byte index 6), the data \"123456\" occupies 6 bytes,\n  // plus the newline before \"stream\" makes the total length 7.\n  const actualLength = resultStream.end - resultStream.pos;\n  assert.strictEqual(actualLength, 7);\n});",
    "i2_llama-3.3-70b-versatile": "it(\"should correctly detect a truncated endstream marker and return the proper stream length\", async () => {\n  const assert = require(\"assert\");\n  const { StringStream } = await import(\"../../src/core/stream.js\");\n  const { Lexer, Parser } = await import(\"../../src/core/parser.js\");\n  // Construct a fake PDF stream:\n  // \"stream\" followed by a newline, then the stream data \"123456\",\n  // then a truncated \"endstream\" command \"endstrea \" (i.e. missing final character, but followed by whitespace),\n  // then a proper \"endstream\" (which will not be reached).\n  const pdfData = \"stream\\n123456endstrea \\nendstream\";\n  const stream = new StringStream(pdfData);\n  const lexer = new Lexer(stream);\n  const parser = new Parser({ lexer, xref: {} });\n  // Provide an incorrect declared length to force scanning for the endstream marker.\n  const dict = { get: key => key === \"Length\" ? 2 : null };\n  const resultStream = parser.makeStream(dict, null);\n  // The expected stream data is the bytes starting at startPos (one byte before the first character after \"stream\\n\")\n  // up to the beginning of the truncated \"endstream\" marker.\n  // In our pdfData, after \"stream\\n\" (i.e. after byte index 6), the data \"123456\" occupies 6 bytes,\n  // plus the newline before \"stream\" makes the total length 7.\n  const actualLength = resultStream.end - resultStream.pos;\n  assert.strictEqual(actualLength, 7);\n});",
    "i3_deepseek-r1-distill-llama-70b": "it(\"should correctly detect a truncated endstream marker and return the proper stream length\", async () => {\n  const assert = require(\"assert\");\n  const { StringStream } = await import(\"../../src/core/stream.js\");\n  const { Lexer, Parser } = await import(\"../../src/core/parser.js\");\n  // Construct a fake PDF stream:\n  // \"stream\" followed by a newline, then the stream data \"123456\",\n  // then a truncated \"endstream\" command \"endstrea \" (i.e. missing final character, but followed by whitespace),\n  // then a proper \"endstream\" (which will not be reached).\n  const pdfData = \"stream\\n123456endstrea \\nendstream\";\n  const stream = new StringStream(pdfData);\n  const lexer = new Lexer(stream);\n  const parser = new Parser({ lexer, xref: {} });\n  // Provide an incorrect declared length to force scanning for the endstream marker.\n  const dict = { get: key => key === \"Length\" ? 2 : null };\n  const resultStream = parser.makeStream(dict, null);\n  // The expected stream data is the bytes starting at startPos (one byte before the first character after \"stream\\n\")\n  // up to the beginning of the truncated \"endstream\" marker.\n  // In our pdfData, after \"stream\\n\" (i.e. after byte index 6), the data \"123456\" occupies 6 bytes,\n  // plus the newline before \"stream\" makes the total length 7.\n  const actualLength = resultStream.end - resultStream.pos;\n  assert.strictEqual(actualLength, 7);\n});",
    "i3_gpt-4o": "it(\"should correctly detect a truncated endstream marker and return the proper stream length\", async () => {\n  const assert = require(\"assert\");\n  const { StringStream } = await import(\"../../src/core/stream.js\");\n  const { Lexer, Parser } = await import(\"../../src/core/parser.js\");\n  // Construct a fake PDF stream:\n  // \"stream\" followed by a newline, then the stream data \"123456\",\n  // then a truncated \"endstream\" command \"endstrea \" (i.e. missing final character, but followed by whitespace),\n  // then a proper \"endstream\" (which will not be reached).\n  const pdfData = \"stream\\n123456endstrea \\nendstream\";\n  const stream = new StringStream(pdfData);\n  const lexer = new Lexer(stream);\n  const parser = new Parser({ lexer, xref: {} });\n  // Provide an incorrect declared length to force scanning for the endstream marker.\n  const dict = { get: key => key === \"Length\" ? 2 : null };\n  const resultStream = parser.makeStream(dict, null);\n  // The expected stream data is the bytes starting at startPos (one byte before the first character after \"stream\\n\")\n  // up to the beginning of the truncated \"endstream\" marker.\n  // In our pdfData, after \"stream\\n\" (i.e. after byte index 6), the data \"123456\" occupies 6 bytes,\n  // plus the newline before \"stream\" makes the total length 7.\n  const actualLength = resultStream.end - resultStream.pos;\n  assert.strictEqual(actualLength, 7);\n});",
    "i3_llama-3.3-70b-versatile": "it(\"should correctly detect a truncated endstream marker and return the proper stream length\", async () => {\n  const assert = require(\"assert\");\n  const { StringStream } = await import(\"../../src/core/stream.js\");\n  const { Lexer, Parser } = await import(\"../../src/core/parser.js\");\n  // Construct a fake PDF stream:\n  // \"stream\" followed by a newline, then the stream data \"123456\",\n  // then a truncated \"endstream\" command \"endstrea \" (i.e. missing final character, but followed by whitespace),\n  // then a proper \"endstream\" (which will not be reached).\n  const pdfData = \"stream\\n123456endstrea \\nendstream\";\n  const stream = new StringStream(pdfData);\n  const lexer = new Lexer(stream);\n  const parser = new Parser({ lexer, xref: {} });\n  // Provide an incorrect declared length to force scanning for the endstream marker.\n  const dict = { get: key => key === \"Length\" ? 2 : null };\n  const resultStream = parser.makeStream(dict, null);\n  // The expected stream data is the bytes starting at startPos (one byte before the first character after \"stream\\n\")\n  // up to the beginning of the truncated \"endstream\" marker.\n  // In our pdfData, after \"stream\\n\" (i.e. after byte index 6), the data \"123456\" occupies 6 bytes,\n  // plus the newline before \"stream\" makes the total length 7.\n  const actualLength = resultStream.end - resultStream.pos;\n  assert.strictEqual(actualLength, 7);\n});",
    "i4_deepseek-r1-distill-llama-70b": "it(\"should correctly detect a truncated endstream marker and return the proper stream length\", async () => {\n  const assert = require(\"assert\");\n  const { StringStream } = await import(\"../../src/core/stream.js\");\n  const { Lexer, Parser } = await import(\"../../src/core/parser.js\");\n  // Construct a fake PDF stream:\n  // \"stream\" followed by a newline, then the stream data \"123456\",\n  // then a truncated \"endstream\" command \"endstrea \" (i.e. missing final character, but followed by whitespace),\n  // then a proper \"endstream\" (which will not be reached).\n  const pdfData = \"stream\\n123456endstrea \\nendstream\";\n  const stream = new StringStream(pdfData);\n  const lexer = new Lexer(stream);\n  const parser = new Parser({ lexer, xref: {} });\n  // Provide an incorrect declared length to force scanning for the endstream marker.\n  const dict = { get: key => key === \"Length\" ? 2 : null };\n  const resultStream = parser.makeStream(dict, null);\n  // The expected stream data is the bytes starting at startPos (one byte before the first character after \"stream\\n\")\n  // up to the beginning of the truncated \"endstream\" marker.\n  // In our pdfData, after \"stream\\n\" (i.e. after byte index 6), the data \"123456\" occupies 6 bytes,\n  // plus the newline before \"stream\" makes the total length 7.\n  const actualLength = resultStream.end - resultStream.pos;\n  assert.strictEqual(actualLength, 7);\n});",
    "i4_gpt-4o": "it(\"should correctly detect a truncated endstream marker and return the proper stream length\", async () => {\n  const assert = require(\"assert\");\n  const { StringStream } = await import(\"../../src/core/stream.js\");\n  const { Lexer, Parser } = await import(\"../../src/core/parser.js\");\n  // Construct a fake PDF stream:\n  // \"stream\" followed by a newline, then the stream data \"123456\",\n  // then a truncated \"endstream\" command \"endstrea \" (i.e. missing final character, but followed by whitespace),\n  // then a proper \"endstream\" (which will not be reached).\n  const pdfData = \"stream\\n123456endstrea \\nendstream\";\n  const stream = new StringStream(pdfData);\n  const lexer = new Lexer(stream);\n  const parser = new Parser({ lexer, xref: {} });\n  // Provide an incorrect declared length to force scanning for the endstream marker.\n  const dict = { get: key => key === \"Length\" ? 2 : null };\n  const resultStream = parser.makeStream(dict, null);\n  // The expected stream data is the bytes starting at startPos (one byte before the first character after \"stream\\n\")\n  // up to the beginning of the truncated \"endstream\" marker.\n  // In our pdfData, after \"stream\\n\" (i.e. after byte index 6), the data \"123456\" occupies 6 bytes,\n  // plus the newline before \"stream\" makes the total length 7.\n  const actualLength = resultStream.end - resultStream.pos;\n  assert.strictEqual(actualLength, 7);\n});",
    "i4_llama-3.3-70b-versatile": "it(\"should correctly detect a truncated endstream marker and return the proper stream length\", async () => {\n  const assert = require(\"assert\");\n  const { StringStream } = await import(\"../../src/core/stream.js\");\n  const { Lexer, Parser } = await import(\"../../src/core/parser.js\");\n  // Construct a fake PDF stream:\n  // \"stream\" followed by a newline, then the stream data \"123456\",\n  // then a truncated \"endstream\" command \"endstrea \" (i.e. missing final character, but followed by whitespace),\n  // then a proper \"endstream\" (which will not be reached).\n  const pdfData = \"stream\\n123456endstrea \\nendstream\";\n  const stream = new StringStream(pdfData);\n  const lexer = new Lexer(stream);\n  const parser = new Parser({ lexer, xref: {} });\n  // Provide an incorrect declared length to force scanning for the endstream marker.\n  const dict = { get: key => key === \"Length\" ? 2 : null };\n  const resultStream = parser.makeStream(dict, null);\n  // The expected stream data is the bytes starting at startPos (one byte before the first character after \"stream\\n\")\n  // up to the beginning of the truncated \"endstream\" marker.\n  // In our pdfData, after \"stream\\n\" (i.e. after byte index 6), the data \"123456\" occupies 6 bytes,\n  // plus the newline before \"stream\" makes the total length 7.\n  const actualLength = resultStream.end - resultStream.pos;\n  assert.strictEqual(actualLength, 7);\n});",
    "i5_deepseek-r1-distill-llama-70b": "it(\"should correctly detect a truncated endstream marker and return the proper stream length\", async () => {\n  const assert = require(\"assert\");\n  const { StringStream } = await import(\"../../src/core/stream.js\");\n  const { Lexer, Parser } = await import(\"../../src/core/parser.js\");\n  // Construct a fake PDF stream:\n  // \"stream\" followed by a newline, then the stream data \"123456\",\n  // then a truncated \"endstream\" command \"endstrea \" (i.e. missing final character, but followed by whitespace),\n  // then a proper \"endstream\" (which will not be reached).\n  const pdfData = \"stream\\n123456endstrea \\nendstream\";\n  const stream = new StringStream(pdfData);\n  const lexer = new Lexer(stream);\n  const parser = new Parser({ lexer, xref: {} });\n  // Provide an incorrect declared length to force scanning for the endstream marker.\n  const dict = { get: key => key === \"Length\" ? 2 : null };\n  const resultStream = parser.makeStream(dict, null);\n  // The expected stream data is the bytes starting at startPos (one byte before the first character after \"stream\\n\")\n  // up to the beginning of the truncated \"endstream\" marker.\n  // In our pdfData, after \"stream\\n\" (i.e. after byte index 6), the data \"123456\" occupies 6 bytes,\n  // plus the newline before \"stream\" makes the total length 7.\n  const actualLength = resultStream.end - resultStream.pos;\n  assert.strictEqual(actualLength, 7);\n});",
    "i5_gpt-4o": "it(\"should correctly detect a truncated endstream marker and return the proper stream length\", async () => {\n  const assert = require(\"assert\");\n  const { StringStream } = await import(\"../../src/core/stream.js\");\n  const { Lexer, Parser } = await import(\"../../src/core/parser.js\");\n  // Construct a fake PDF stream:\n  // \"stream\" followed by a newline, then the stream data \"123456\",\n  // then a truncated \"endstream\" command \"endstrea \" (i.e. missing final character, but followed by whitespace),\n  // then a proper \"endstream\" (which will not be reached).\n  const pdfData = \"stream\\n123456endstrea \\nendstream\";\n  const stream = new StringStream(pdfData);\n  const lexer = new Lexer(stream);\n  const parser = new Parser({ lexer, xref: {} });\n  // Provide an incorrect declared length to force scanning for the endstream marker.\n  const dict = { get: key => key === \"Length\" ? 2 : null };\n  const resultStream = parser.makeStream(dict, null);\n  // The expected stream data is the bytes starting at startPos (one byte before the first character after \"stream\\n\")\n  // up to the beginning of the truncated \"endstream\" marker.\n  // In our pdfData, after \"stream\\n\" (i.e. after byte index 6), the data \"123456\" occupies 6 bytes,\n  // plus the newline before \"stream\" makes the total length 7.\n  const actualLength = resultStream.end - resultStream.pos;\n  assert.strictEqual(actualLength, 7);\n});",
    "i5_llama-3.3-70b-versatile": "it(\"should correctly detect a truncated endstream marker and return the proper stream length\", async () => {\n  const assert = require(\"assert\");\n  const { StringStream } = await import(\"../../src/core/stream.js\");\n  const { Lexer, Parser } = await import(\"../../src/core/parser.js\");\n  // Construct a fake PDF stream:\n  // \"stream\" followed by a newline, then the stream data \"123456\",\n  // then a truncated \"endstream\" command \"endstrea \" (i.e. missing final character, but followed by whitespace),\n  // then a proper \"endstream\" (which will not be reached).\n  const pdfData = \"stream\\n123456endstrea \\nendstream\";\n  const stream = new StringStream(pdfData);\n  const lexer = new Lexer(stream);\n  const parser = new Parser({ lexer, xref: {} });\n  // Provide an incorrect declared length to force scanning for the endstream marker.\n  const dict = { get: key => key === \"Length\" ? 2 : null };\n  const resultStream = parser.makeStream(dict, null);\n  // The expected stream data is the bytes starting at startPos (one byte before the first character after \"stream\\n\")\n  // up to the beginning of the truncated \"endstream\" marker.\n  // In our pdfData, after \"stream\\n\" (i.e. after byte index 6), the data \"123456\" occupies 6 bytes,\n  // plus the newline before \"stream\" makes the total length 7.\n  const actualLength = resultStream.end - resultStream.pos;\n  assert.strictEqual(actualLength, 7);\n});"
  },
  "18143": {
    "i1_deepseek-r1-distill-llama-70b": "it(\"should recognize a page dictionary with Contents no Type or Kids as a valid page\", async () => {\n  const { PDFDocument } = await import(\"../../src/core/document.js\");\n  const { Dict, Ref } = await import(\"../../src/core/primitives.js\");\n  const { StringStream } = await import(\"../../src/core/stream.js\");\n\n  class MapWithHasPut extends Map {\n    put(key, value) {\n      this.set(key, value);\n    }\n  }\n\n  // Create a page dictionary with \"Contents\" but without \"Type\" or \"Kids\".\n  const pageDict = new Dict();\n  pageDict.set(\"Contents\", \"dummy content\");\n\n  // Prepare a fake reference corresponding to object number 1 and generation 0.\n  const fakeRef = Ref.get(1, 0);\n\n  // Create a fake XRef with a fetchAsync method that returns our pageDict for fakeRef.\n  const xref = {\n    fetchAsync: async function (ref) {\n      if (ref.num === fakeRef.num && ref.gen === fakeRef.gen) {\n        return pageDict;\n      }\n      throw new Error(\"Unexpected reference.\");\n    },\n  };\n\n  // Create a minimal linearization object.\n  const linearization = {\n    pageFirst: 0,\n    objectNumberFirst: 1,\n  };\n\n  // Minimal catalog with required cache methods.\n  const catalog = {\n    pageKidsCountCache: new MapWithHasPut(),\n    pageIndexCache: new MapWithHasPut(),\n    getPageDict: () => {\n      throw new Error(\"getPageDict should not be called in this test\");\n    },\n  };\n\n  // Create a dummy stream.\n  const stream = new StringStream(\"dummy\");\n\n  // Instantiate PDFDocument with a dummy pdfManager.\n  const pdfDoc = new PDFDocument({ docId: 123 }, stream);\n  pdfDoc.linearization = linearization;\n  pdfDoc.catalog = catalog;\n  pdfDoc.xref = xref;\n\n  const [resultDict, resultRef] = await pdfDoc._getLinearizationPage(0);\n  if (resultDict !== pageDict) {\n    throw new Error(\"The page dictionary was not correctly recognized.\");\n  }\n  if (resultRef.num !== fakeRef.num || resultRef.gen !== fakeRef.gen) {\n    throw new Error(\"The page reference returned is incorrect.\");\n  }\n});\n",
    "i1_gpt-4o": "it(\"should recognize a page dictionary with Contents no Type or Kids as a valid page\", async () => {\n  const { PDFDocument } = await import(\"../../src/core/document.js\");\n  const { Dict, Ref } = await import(\"../../src/core/primitives.js\");\n  const { StringStream } = await import(\"../../src/core/stream.js\");\n\n  class MapWithHasPut extends Map {\n    put(key, value) {\n      this.set(key, value);\n    }\n  }\n\n  // Create a page dictionary with \"Contents\" but without \"Type\" or \"Kids\".\n  const pageDict = new Dict();\n  pageDict.set(\"Contents\", \"dummy content\");\n\n  // Prepare a fake reference corresponding to object number 1 and generation 0.\n  const fakeRef = Ref.get(1, 0);\n\n  // Create a fake XRef with a fetchAsync method that returns our pageDict for fakeRef.\n  const xref = {\n    fetchAsync: async function (ref) {\n      if (ref.num === fakeRef.num && ref.gen === fakeRef.gen) {\n        return pageDict;\n      }\n      throw new Error(\"Unexpected reference.\");\n    },\n  };\n\n  // Create a minimal linearization object.\n  const linearization = {\n    pageFirst: 0,\n    objectNumberFirst: 1,\n  };\n\n  // Minimal catalog with required cache methods.\n  const catalog = {\n    pageKidsCountCache: new MapWithHasPut(),\n    pageIndexCache: new MapWithHasPut(),\n    getPageDict: () => {\n      throw new Error(\"getPageDict should not be called in this test\");\n    },\n  };\n\n  // Create a dummy stream.\n  const stream = new StringStream(\"dummy\");\n\n  // Instantiate PDFDocument with a dummy pdfManager.\n  const pdfDoc = new PDFDocument({ docId: 123 }, stream);\n  pdfDoc.linearization = linearization;\n  pdfDoc.catalog = catalog;\n  pdfDoc.xref = xref;\n\n  const [resultDict, resultRef] = await pdfDoc._getLinearizationPage(0);\n  if (resultDict !== pageDict) {\n    throw new Error(\"The page dictionary was not correctly recognized.\");\n  }\n  if (resultRef.num !== fakeRef.num || resultRef.gen !== fakeRef.gen) {\n    throw new Error(\"The page reference returned is incorrect.\");\n  }\n});\n",
    "i1_llama-3.3-70b-versatile": "it(\"should recognize a page dictionary with Contents no Type or Kids as a valid page\", async () => {\n  const { PDFDocument } = await import(\"../../src/core/document.js\");\n  const { Dict, Ref } = await import(\"../../src/core/primitives.js\");\n  const { StringStream } = await import(\"../../src/core/stream.js\");\n\n  class MapWithHasPut extends Map {\n    put(key, value) {\n      this.set(key, value);\n    }\n  }\n\n  // Create a page dictionary with \"Contents\" but without \"Type\" or \"Kids\".\n  const pageDict = new Dict();\n  pageDict.set(\"Contents\", \"dummy content\");\n\n  // Prepare a fake reference corresponding to object number 1 and generation 0.\n  const fakeRef = Ref.get(1, 0);\n\n  // Create a fake XRef with a fetchAsync method that returns our pageDict for fakeRef.\n  const xref = {\n    fetchAsync: async function (ref) {\n      if (ref.num === fakeRef.num && ref.gen === fakeRef.gen) {\n        return pageDict;\n      }\n      throw new Error(\"Unexpected reference.\");\n    },\n  };\n\n  // Create a minimal linearization object.\n  const linearization = {\n    pageFirst: 0,\n    objectNumberFirst: 1,\n  };\n\n  // Minimal catalog with required cache methods.\n  const catalog = {\n    pageKidsCountCache: new MapWithHasPut(),\n    pageIndexCache: new MapWithHasPut(),\n    getPageDict: () => {\n      throw new Error(\"getPageDict should not be called in this test\");\n    },\n  };\n\n  // Create a dummy stream.\n  const stream = new StringStream(\"dummy\");\n\n  // Instantiate PDFDocument with a dummy pdfManager.\n  const pdfDoc = new PDFDocument({ docId: 123 }, stream);\n  pdfDoc.linearization = linearization;\n  pdfDoc.catalog = catalog;\n  pdfDoc.xref = xref;\n\n  const [resultDict, resultRef] = await pdfDoc._getLinearizationPage(0);\n  if (resultDict !== pageDict) {\n    throw new Error(\"The page dictionary was not correctly recognized.\");\n  }\n  if (resultRef.num !== fakeRef.num || resultRef.gen !== fakeRef.gen) {\n    throw new Error(\"The page reference returned is incorrect.\");\n  }\n});\n",
    "i1_MOCK": "it(\"should recognize a page dictionary with Contents no Type or Kids as a valid page\", async () => {\n  const { PDFDocument } = await import(\"../../src/core/document.js\");\n  const { Dict, Ref } = await import(\"../../src/core/primitives.js\");\n  const { StringStream } = await import(\"../../src/core/stream.js\");\n\n  class MapWithHasPut extends Map {\n    put(key, value) {\n      this.set(key, value);\n    }\n  }\n\n  // Create a page dictionary with \"Contents\" but without \"Type\" or \"Kids\".\n  const pageDict = new Dict();\n  pageDict.set(\"Contents\", \"dummy content\");\n\n  // Prepare a fake reference corresponding to object number 1 and generation 0.\n  const fakeRef = Ref.get(1, 0);\n\n  // Create a fake XRef with a fetchAsync method that returns our pageDict for fakeRef.\n  const xref = {\n    fetchAsync: async function (ref) {\n      if (ref.num === fakeRef.num && ref.gen === fakeRef.gen) {\n        return pageDict;\n      }\n      throw new Error(\"Unexpected reference.\");\n    },\n  };\n\n  // Create a minimal linearization object.\n  const linearization = {\n    pageFirst: 0,\n    objectNumberFirst: 1,\n  };\n\n  // Minimal catalog with required cache methods.\n  const catalog = {\n    pageKidsCountCache: new MapWithHasPut(),\n    pageIndexCache: new MapWithHasPut(),\n    getPageDict: () => {\n      throw new Error(\"getPageDict should not be called in this test\");\n    },\n  };\n\n  // Create a dummy stream.\n  const stream = new StringStream(\"dummy\");\n\n  // Instantiate PDFDocument with a dummy pdfManager.\n  const pdfDoc = new PDFDocument({ docId: 123 }, stream);\n  pdfDoc.linearization = linearization;\n  pdfDoc.catalog = catalog;\n  pdfDoc.xref = xref;\n\n  const [resultDict, resultRef] = await pdfDoc._getLinearizationPage(0);\n  if (resultDict !== pageDict) {\n    throw new Error(\"The page dictionary was not correctly recognized.\");\n  }\n  if (resultRef.num !== fakeRef.num || resultRef.gen !== fakeRef.gen) {\n    throw new Error(\"The page reference returned is incorrect.\");\n  }\n});\n",
    "i2_deepseek-r1-distill-llama-70b": "it(\"should recognize a page dictionary with Contents no Type or Kids as a valid page\", async () => {\n  const { PDFDocument } = await import(\"../../src/core/document.js\");\n  const { Dict, Ref } = await import(\"../../src/core/primitives.js\");\n  const { StringStream } = await import(\"../../src/core/stream.js\");\n\n  class MapWithHasPut extends Map {\n    put(key, value) {\n      this.set(key, value);\n    }\n  }\n\n  // Create a page dictionary with \"Contents\" but without \"Type\" or \"Kids\".\n  const pageDict = new Dict();\n  pageDict.set(\"Contents\", \"dummy content\");\n\n  // Prepare a fake reference corresponding to object number 1 and generation 0.\n  const fakeRef = Ref.get(1, 0);\n\n  // Create a fake XRef with a fetchAsync method that returns our pageDict for fakeRef.\n  const xref = {\n    fetchAsync: async function (ref) {\n      if (ref.num === fakeRef.num && ref.gen === fakeRef.gen) {\n        return pageDict;\n      }\n      throw new Error(\"Unexpected reference.\");\n    },\n  };\n\n  // Create a minimal linearization object.\n  const linearization = {\n    pageFirst: 0,\n    objectNumberFirst: 1,\n  };\n\n  // Minimal catalog with required cache methods.\n  const catalog = {\n    pageKidsCountCache: new MapWithHasPut(),\n    pageIndexCache: new MapWithHasPut(),\n    getPageDict: () => {\n      throw new Error(\"getPageDict should not be called in this test\");\n    },\n  };\n\n  // Create a dummy stream.\n  const stream = new StringStream(\"dummy\");\n\n  // Instantiate PDFDocument with a dummy pdfManager.\n  const pdfDoc = new PDFDocument({ docId: 123 }, stream);\n  pdfDoc.linearization = linearization;\n  pdfDoc.catalog = catalog;\n  pdfDoc.xref = xref;\n\n  const [resultDict, resultRef] = await pdfDoc._getLinearizationPage(0);\n  if (resultDict !== pageDict) {\n    throw new Error(\"The page dictionary was not correctly recognized.\");\n  }\n  if (resultRef.num !== fakeRef.num || resultRef.gen !== fakeRef.gen) {\n    throw new Error(\"The page reference returned is incorrect.\");\n  }\n});\n",
    "i2_gpt-4o": "it(\"should recognize a page dictionary with Contents no Type or Kids as a valid page\", async () => {\n  const { PDFDocument } = await import(\"../../src/core/document.js\");\n  const { Dict, Ref } = await import(\"../../src/core/primitives.js\");\n  const { StringStream } = await import(\"../../src/core/stream.js\");\n\n  class MapWithHasPut extends Map {\n    put(key, value) {\n      this.set(key, value);\n    }\n  }\n\n  // Create a page dictionary with \"Contents\" but without \"Type\" or \"Kids\".\n  const pageDict = new Dict();\n  pageDict.set(\"Contents\", \"dummy content\");\n\n  // Prepare a fake reference corresponding to object number 1 and generation 0.\n  const fakeRef = Ref.get(1, 0);\n\n  // Create a fake XRef with a fetchAsync method that returns our pageDict for fakeRef.\n  const xref = {\n    fetchAsync: async function (ref) {\n      if (ref.num === fakeRef.num && ref.gen === fakeRef.gen) {\n        return pageDict;\n      }\n      throw new Error(\"Unexpected reference.\");\n    },\n  };\n\n  // Create a minimal linearization object.\n  const linearization = {\n    pageFirst: 0,\n    objectNumberFirst: 1,\n  };\n\n  // Minimal catalog with required cache methods.\n  const catalog = {\n    pageKidsCountCache: new MapWithHasPut(),\n    pageIndexCache: new MapWithHasPut(),\n    getPageDict: () => {\n      throw new Error(\"getPageDict should not be called in this test\");\n    },\n  };\n\n  // Create a dummy stream.\n  const stream = new StringStream(\"dummy\");\n\n  // Instantiate PDFDocument with a dummy pdfManager.\n  const pdfDoc = new PDFDocument({ docId: 123 }, stream);\n  pdfDoc.linearization = linearization;\n  pdfDoc.catalog = catalog;\n  pdfDoc.xref = xref;\n\n  const [resultDict, resultRef] = await pdfDoc._getLinearizationPage(0);\n  if (resultDict !== pageDict) {\n    throw new Error(\"The page dictionary was not correctly recognized.\");\n  }\n  if (resultRef.num !== fakeRef.num || resultRef.gen !== fakeRef.gen) {\n    throw new Error(\"The page reference returned is incorrect.\");\n  }\n});\n",
    "i2_llama-3.3-70b-versatile": "it(\"should recognize a page dictionary with Contents no Type or Kids as a valid page\", async () => {\n  const { PDFDocument } = await import(\"../../src/core/document.js\");\n  const { Dict, Ref } = await import(\"../../src/core/primitives.js\");\n  const { StringStream } = await import(\"../../src/core/stream.js\");\n\n  class MapWithHasPut extends Map {\n    put(key, value) {\n      this.set(key, value);\n    }\n  }\n\n  // Create a page dictionary with \"Contents\" but without \"Type\" or \"Kids\".\n  const pageDict = new Dict();\n  pageDict.set(\"Contents\", \"dummy content\");\n\n  // Prepare a fake reference corresponding to object number 1 and generation 0.\n  const fakeRef = Ref.get(1, 0);\n\n  // Create a fake XRef with a fetchAsync method that returns our pageDict for fakeRef.\n  const xref = {\n    fetchAsync: async function (ref) {\n      if (ref.num === fakeRef.num && ref.gen === fakeRef.gen) {\n        return pageDict;\n      }\n      throw new Error(\"Unexpected reference.\");\n    },\n  };\n\n  // Create a minimal linearization object.\n  const linearization = {\n    pageFirst: 0,\n    objectNumberFirst: 1,\n  };\n\n  // Minimal catalog with required cache methods.\n  const catalog = {\n    pageKidsCountCache: new MapWithHasPut(),\n    pageIndexCache: new MapWithHasPut(),\n    getPageDict: () => {\n      throw new Error(\"getPageDict should not be called in this test\");\n    },\n  };\n\n  // Create a dummy stream.\n  const stream = new StringStream(\"dummy\");\n\n  // Instantiate PDFDocument with a dummy pdfManager.\n  const pdfDoc = new PDFDocument({ docId: 123 }, stream);\n  pdfDoc.linearization = linearization;\n  pdfDoc.catalog = catalog;\n  pdfDoc.xref = xref;\n\n  const [resultDict, resultRef] = await pdfDoc._getLinearizationPage(0);\n  if (resultDict !== pageDict) {\n    throw new Error(\"The page dictionary was not correctly recognized.\");\n  }\n  if (resultRef.num !== fakeRef.num || resultRef.gen !== fakeRef.gen) {\n    throw new Error(\"The page reference returned is incorrect.\");\n  }\n});\n",
    "i3_deepseek-r1-distill-llama-70b": "it(\"should recognize a page dictionary with Contents no Type or Kids as a valid page\", async () => {\n  const { PDFDocument } = await import(\"../../src/core/document.js\");\n  const { Dict, Ref } = await import(\"../../src/core/primitives.js\");\n  const { StringStream } = await import(\"../../src/core/stream.js\");\n\n  class MapWithHasPut extends Map {\n    put(key, value) {\n      this.set(key, value);\n    }\n  }\n\n  // Create a page dictionary with \"Contents\" but without \"Type\" or \"Kids\".\n  const pageDict = new Dict();\n  pageDict.set(\"Contents\", \"dummy content\");\n\n  // Prepare a fake reference corresponding to object number 1 and generation 0.\n  const fakeRef = Ref.get(1, 0);\n\n  // Create a fake XRef with a fetchAsync method that returns our pageDict for fakeRef.\n  const xref = {\n    fetchAsync: async function (ref) {\n      if (ref.num === fakeRef.num && ref.gen === fakeRef.gen) {\n        return pageDict;\n      }\n      throw new Error(\"Unexpected reference.\");\n    },\n  };\n\n  // Create a minimal linearization object.\n  const linearization = {\n    pageFirst: 0,\n    objectNumberFirst: 1,\n  };\n\n  // Minimal catalog with required cache methods.\n  const catalog = {\n    pageKidsCountCache: new MapWithHasPut(),\n    pageIndexCache: new MapWithHasPut(),\n    getPageDict: () => {\n      throw new Error(\"getPageDict should not be called in this test\");\n    },\n  };\n\n  // Create a dummy stream.\n  const stream = new StringStream(\"dummy\");\n\n  // Instantiate PDFDocument with a dummy pdfManager.\n  const pdfDoc = new PDFDocument({ docId: 123 }, stream);\n  pdfDoc.linearization = linearization;\n  pdfDoc.catalog = catalog;\n  pdfDoc.xref = xref;\n\n  const [resultDict, resultRef] = await pdfDoc._getLinearizationPage(0);\n  if (resultDict !== pageDict) {\n    throw new Error(\"The page dictionary was not correctly recognized.\");\n  }\n  if (resultRef.num !== fakeRef.num || resultRef.gen !== fakeRef.gen) {\n    throw new Error(\"The page reference returned is incorrect.\");\n  }\n});\n",
    "i3_gpt-4o": "it(\"should recognize a page dictionary with Contents no Type or Kids as a valid page\", async () => {\n  const { PDFDocument } = await import(\"../../src/core/document.js\");\n  const { Dict, Ref } = await import(\"../../src/core/primitives.js\");\n  const { StringStream } = await import(\"../../src/core/stream.js\");\n\n  class MapWithHasPut extends Map {\n    put(key, value) {\n      this.set(key, value);\n    }\n  }\n\n  // Create a page dictionary with \"Contents\" but without \"Type\" or \"Kids\".\n  const pageDict = new Dict();\n  pageDict.set(\"Contents\", \"dummy content\");\n\n  // Prepare a fake reference corresponding to object number 1 and generation 0.\n  const fakeRef = Ref.get(1, 0);\n\n  // Create a fake XRef with a fetchAsync method that returns our pageDict for fakeRef.\n  const xref = {\n    fetchAsync: async function (ref) {\n      if (ref.num === fakeRef.num && ref.gen === fakeRef.gen) {\n        return pageDict;\n      }\n      throw new Error(\"Unexpected reference.\");\n    },\n  };\n\n  // Create a minimal linearization object.\n  const linearization = {\n    pageFirst: 0,\n    objectNumberFirst: 1,\n  };\n\n  // Minimal catalog with required cache methods.\n  const catalog = {\n    pageKidsCountCache: new MapWithHasPut(),\n    pageIndexCache: new MapWithHasPut(),\n    getPageDict: () => {\n      throw new Error(\"getPageDict should not be called in this test\");\n    },\n  };\n\n  // Create a dummy stream.\n  const stream = new StringStream(\"dummy\");\n\n  // Instantiate PDFDocument with a dummy pdfManager.\n  const pdfDoc = new PDFDocument({ docId: 123 }, stream);\n  pdfDoc.linearization = linearization;\n  pdfDoc.catalog = catalog;\n  pdfDoc.xref = xref;\n\n  const [resultDict, resultRef] = await pdfDoc._getLinearizationPage(0);\n  if (resultDict !== pageDict) {\n    throw new Error(\"The page dictionary was not correctly recognized.\");\n  }\n  if (resultRef.num !== fakeRef.num || resultRef.gen !== fakeRef.gen) {\n    throw new Error(\"The page reference returned is incorrect.\");\n  }\n});\n",
    "i3_llama-3.3-70b-versatile": "it(\"should recognize a page dictionary with Contents no Type or Kids as a valid page\", async () => {\n  const { PDFDocument } = await import(\"../../src/core/document.js\");\n  const { Dict, Ref } = await import(\"../../src/core/primitives.js\");\n  const { StringStream } = await import(\"../../src/core/stream.js\");\n\n  class MapWithHasPut extends Map {\n    put(key, value) {\n      this.set(key, value);\n    }\n  }\n\n  // Create a page dictionary with \"Contents\" but without \"Type\" or \"Kids\".\n  const pageDict = new Dict();\n  pageDict.set(\"Contents\", \"dummy content\");\n\n  // Prepare a fake reference corresponding to object number 1 and generation 0.\n  const fakeRef = Ref.get(1, 0);\n\n  // Create a fake XRef with a fetchAsync method that returns our pageDict for fakeRef.\n  const xref = {\n    fetchAsync: async function (ref) {\n      if (ref.num === fakeRef.num && ref.gen === fakeRef.gen) {\n        return pageDict;\n      }\n      throw new Error(\"Unexpected reference.\");\n    },\n  };\n\n  // Create a minimal linearization object.\n  const linearization = {\n    pageFirst: 0,\n    objectNumberFirst: 1,\n  };\n\n  // Minimal catalog with required cache methods.\n  const catalog = {\n    pageKidsCountCache: new MapWithHasPut(),\n    pageIndexCache: new MapWithHasPut(),\n    getPageDict: () => {\n      throw new Error(\"getPageDict should not be called in this test\");\n    },\n  };\n\n  // Create a dummy stream.\n  const stream = new StringStream(\"dummy\");\n\n  // Instantiate PDFDocument with a dummy pdfManager.\n  const pdfDoc = new PDFDocument({ docId: 123 }, stream);\n  pdfDoc.linearization = linearization;\n  pdfDoc.catalog = catalog;\n  pdfDoc.xref = xref;\n\n  const [resultDict, resultRef] = await pdfDoc._getLinearizationPage(0);\n  if (resultDict !== pageDict) {\n    throw new Error(\"The page dictionary was not correctly recognized.\");\n  }\n  if (resultRef.num !== fakeRef.num || resultRef.gen !== fakeRef.gen) {\n    throw new Error(\"The page reference returned is incorrect.\");\n  }\n});\n",
    "i4_deepseek-r1-distill-llama-70b": "it(\"should recognize a page dictionary with Contents no Type or Kids as a valid page\", async () => {\n  const { PDFDocument } = await import(\"../../src/core/document.js\");\n  const { Dict, Ref } = await import(\"../../src/core/primitives.js\");\n  const { StringStream } = await import(\"../../src/core/stream.js\");\n\n  class MapWithHasPut extends Map {\n    put(key, value) {\n      this.set(key, value);\n    }\n  }\n\n  // Create a page dictionary with \"Contents\" but without \"Type\" or \"Kids\".\n  const pageDict = new Dict();\n  pageDict.set(\"Contents\", \"dummy content\");\n\n  // Prepare a fake reference corresponding to object number 1 and generation 0.\n  const fakeRef = Ref.get(1, 0);\n\n  // Create a fake XRef with a fetchAsync method that returns our pageDict for fakeRef.\n  const xref = {\n    fetchAsync: async function (ref) {\n      if (ref.num === fakeRef.num && ref.gen === fakeRef.gen) {\n        return pageDict;\n      }\n      throw new Error(\"Unexpected reference.\");\n    },\n  };\n\n  // Create a minimal linearization object.\n  const linearization = {\n    pageFirst: 0,\n    objectNumberFirst: 1,\n  };\n\n  // Minimal catalog with required cache methods.\n  const catalog = {\n    pageKidsCountCache: new MapWithHasPut(),\n    pageIndexCache: new MapWithHasPut(),\n    getPageDict: () => {\n      throw new Error(\"getPageDict should not be called in this test\");\n    },\n  };\n\n  // Create a dummy stream.\n  const stream = new StringStream(\"dummy\");\n\n  // Instantiate PDFDocument with a dummy pdfManager.\n  const pdfDoc = new PDFDocument({ docId: 123 }, stream);\n  pdfDoc.linearization = linearization;\n  pdfDoc.catalog = catalog;\n  pdfDoc.xref = xref;\n\n  const [resultDict, resultRef] = await pdfDoc._getLinearizationPage(0);\n  if (resultDict !== pageDict) {\n    throw new Error(\"The page dictionary was not correctly recognized.\");\n  }\n  if (resultRef.num !== fakeRef.num || resultRef.gen !== fakeRef.gen) {\n    throw new Error(\"The page reference returned is incorrect.\");\n  }\n});\n",
    "i4_gpt-4o": "it(\"should recognize a page dictionary with Contents no Type or Kids as a valid page\", async () => {\n  const { PDFDocument } = await import(\"../../src/core/document.js\");\n  const { Dict, Ref } = await import(\"../../src/core/primitives.js\");\n  const { StringStream } = await import(\"../../src/core/stream.js\");\n\n  class MapWithHasPut extends Map {\n    put(key, value) {\n      this.set(key, value);\n    }\n  }\n\n  // Create a page dictionary with \"Contents\" but without \"Type\" or \"Kids\".\n  const pageDict = new Dict();\n  pageDict.set(\"Contents\", \"dummy content\");\n\n  // Prepare a fake reference corresponding to object number 1 and generation 0.\n  const fakeRef = Ref.get(1, 0);\n\n  // Create a fake XRef with a fetchAsync method that returns our pageDict for fakeRef.\n  const xref = {\n    fetchAsync: async function (ref) {\n      if (ref.num === fakeRef.num && ref.gen === fakeRef.gen) {\n        return pageDict;\n      }\n      throw new Error(\"Unexpected reference.\");\n    },\n  };\n\n  // Create a minimal linearization object.\n  const linearization = {\n    pageFirst: 0,\n    objectNumberFirst: 1,\n  };\n\n  // Minimal catalog with required cache methods.\n  const catalog = {\n    pageKidsCountCache: new MapWithHasPut(),\n    pageIndexCache: new MapWithHasPut(),\n    getPageDict: () => {\n      throw new Error(\"getPageDict should not be called in this test\");\n    },\n  };\n\n  // Create a dummy stream.\n  const stream = new StringStream(\"dummy\");\n\n  // Instantiate PDFDocument with a dummy pdfManager.\n  const pdfDoc = new PDFDocument({ docId: 123 }, stream);\n  pdfDoc.linearization = linearization;\n  pdfDoc.catalog = catalog;\n  pdfDoc.xref = xref;\n\n  const [resultDict, resultRef] = await pdfDoc._getLinearizationPage(0);\n  if (resultDict !== pageDict) {\n    throw new Error(\"The page dictionary was not correctly recognized.\");\n  }\n  if (resultRef.num !== fakeRef.num || resultRef.gen !== fakeRef.gen) {\n    throw new Error(\"The page reference returned is incorrect.\");\n  }\n});\n",
    "i4_llama-3.3-70b-versatile": "it(\"should recognize a page dictionary with Contents no Type or Kids as a valid page\", async () => {\n  const { PDFDocument } = await import(\"../../src/core/document.js\");\n  const { Dict, Ref } = await import(\"../../src/core/primitives.js\");\n  const { StringStream } = await import(\"../../src/core/stream.js\");\n\n  class MapWithHasPut extends Map {\n    put(key, value) {\n      this.set(key, value);\n    }\n  }\n\n  // Create a page dictionary with \"Contents\" but without \"Type\" or \"Kids\".\n  const pageDict = new Dict();\n  pageDict.set(\"Contents\", \"dummy content\");\n\n  // Prepare a fake reference corresponding to object number 1 and generation 0.\n  const fakeRef = Ref.get(1, 0);\n\n  // Create a fake XRef with a fetchAsync method that returns our pageDict for fakeRef.\n  const xref = {\n    fetchAsync: async function (ref) {\n      if (ref.num === fakeRef.num && ref.gen === fakeRef.gen) {\n        return pageDict;\n      }\n      throw new Error(\"Unexpected reference.\");\n    },\n  };\n\n  // Create a minimal linearization object.\n  const linearization = {\n    pageFirst: 0,\n    objectNumberFirst: 1,\n  };\n\n  // Minimal catalog with required cache methods.\n  const catalog = {\n    pageKidsCountCache: new MapWithHasPut(),\n    pageIndexCache: new MapWithHasPut(),\n    getPageDict: () => {\n      throw new Error(\"getPageDict should not be called in this test\");\n    },\n  };\n\n  // Create a dummy stream.\n  const stream = new StringStream(\"dummy\");\n\n  // Instantiate PDFDocument with a dummy pdfManager.\n  const pdfDoc = new PDFDocument({ docId: 123 }, stream);\n  pdfDoc.linearization = linearization;\n  pdfDoc.catalog = catalog;\n  pdfDoc.xref = xref;\n\n  const [resultDict, resultRef] = await pdfDoc._getLinearizationPage(0);\n  if (resultDict !== pageDict) {\n    throw new Error(\"The page dictionary was not correctly recognized.\");\n  }\n  if (resultRef.num !== fakeRef.num || resultRef.gen !== fakeRef.gen) {\n    throw new Error(\"The page reference returned is incorrect.\");\n  }\n});\n",
    "i5_deepseek-r1-distill-llama-70b": "it(\"should recognize a page dictionary with Contents no Type or Kids as a valid page\", async () => {\n  const { PDFDocument } = await import(\"../../src/core/document.js\");\n  const { Dict, Ref } = await import(\"../../src/core/primitives.js\");\n  const { StringStream } = await import(\"../../src/core/stream.js\");\n\n  class MapWithHasPut extends Map {\n    put(key, value) {\n      this.set(key, value);\n    }\n  }\n\n  // Create a page dictionary with \"Contents\" but without \"Type\" or \"Kids\".\n  const pageDict = new Dict();\n  pageDict.set(\"Contents\", \"dummy content\");\n\n  // Prepare a fake reference corresponding to object number 1 and generation 0.\n  const fakeRef = Ref.get(1, 0);\n\n  // Create a fake XRef with a fetchAsync method that returns our pageDict for fakeRef.\n  const xref = {\n    fetchAsync: async function (ref) {\n      if (ref.num === fakeRef.num && ref.gen === fakeRef.gen) {\n        return pageDict;\n      }\n      throw new Error(\"Unexpected reference.\");\n    },\n  };\n\n  // Create a minimal linearization object.\n  const linearization = {\n    pageFirst: 0,\n    objectNumberFirst: 1,\n  };\n\n  // Minimal catalog with required cache methods.\n  const catalog = {\n    pageKidsCountCache: new MapWithHasPut(),\n    pageIndexCache: new MapWithHasPut(),\n    getPageDict: () => {\n      throw new Error(\"getPageDict should not be called in this test\");\n    },\n  };\n\n  // Create a dummy stream.\n  const stream = new StringStream(\"dummy\");\n\n  // Instantiate PDFDocument with a dummy pdfManager.\n  const pdfDoc = new PDFDocument({ docId: 123 }, stream);\n  pdfDoc.linearization = linearization;\n  pdfDoc.catalog = catalog;\n  pdfDoc.xref = xref;\n\n  const [resultDict, resultRef] = await pdfDoc._getLinearizationPage(0);\n  if (resultDict !== pageDict) {\n    throw new Error(\"The page dictionary was not correctly recognized.\");\n  }\n  if (resultRef.num !== fakeRef.num || resultRef.gen !== fakeRef.gen) {\n    throw new Error(\"The page reference returned is incorrect.\");\n  }\n});\n",
    "i5_gpt-4o": "it(\"should recognize a page dictionary with Contents no Type or Kids as a valid page\", async () => {\n  const { PDFDocument } = await import(\"../../src/core/document.js\");\n  const { Dict, Ref } = await import(\"../../src/core/primitives.js\");\n  const { StringStream } = await import(\"../../src/core/stream.js\");\n\n  class MapWithHasPut extends Map {\n    put(key, value) {\n      this.set(key, value);\n    }\n  }\n\n  // Create a page dictionary with \"Contents\" but without \"Type\" or \"Kids\".\n  const pageDict = new Dict();\n  pageDict.set(\"Contents\", \"dummy content\");\n\n  // Prepare a fake reference corresponding to object number 1 and generation 0.\n  const fakeRef = Ref.get(1, 0);\n\n  // Create a fake XRef with a fetchAsync method that returns our pageDict for fakeRef.\n  const xref = {\n    fetchAsync: async function (ref) {\n      if (ref.num === fakeRef.num && ref.gen === fakeRef.gen) {\n        return pageDict;\n      }\n      throw new Error(\"Unexpected reference.\");\n    },\n  };\n\n  // Create a minimal linearization object.\n  const linearization = {\n    pageFirst: 0,\n    objectNumberFirst: 1,\n  };\n\n  // Minimal catalog with required cache methods.\n  const catalog = {\n    pageKidsCountCache: new MapWithHasPut(),\n    pageIndexCache: new MapWithHasPut(),\n    getPageDict: () => {\n      throw new Error(\"getPageDict should not be called in this test\");\n    },\n  };\n\n  // Create a dummy stream.\n  const stream = new StringStream(\"dummy\");\n\n  // Instantiate PDFDocument with a dummy pdfManager.\n  const pdfDoc = new PDFDocument({ docId: 123 }, stream);\n  pdfDoc.linearization = linearization;\n  pdfDoc.catalog = catalog;\n  pdfDoc.xref = xref;\n\n  const [resultDict, resultRef] = await pdfDoc._getLinearizationPage(0);\n  if (resultDict !== pageDict) {\n    throw new Error(\"The page dictionary was not correctly recognized.\");\n  }\n  if (resultRef.num !== fakeRef.num || resultRef.gen !== fakeRef.gen) {\n    throw new Error(\"The page reference returned is incorrect.\");\n  }\n});\n",
    "i5_llama-3.3-70b-versatile": "it(\"should recognize a page dictionary with Contents no Type or Kids as a valid page\", async () => {\n  const { PDFDocument } = await import(\"../../src/core/document.js\");\n  const { Dict, Ref } = await import(\"../../src/core/primitives.js\");\n  const { StringStream } = await import(\"../../src/core/stream.js\");\n\n  class MapWithHasPut extends Map {\n    put(key, value) {\n      this.set(key, value);\n    }\n  }\n\n  // Create a page dictionary with \"Contents\" but without \"Type\" or \"Kids\".\n  const pageDict = new Dict();\n  pageDict.set(\"Contents\", \"dummy content\");\n\n  // Prepare a fake reference corresponding to object number 1 and generation 0.\n  const fakeRef = Ref.get(1, 0);\n\n  // Create a fake XRef with a fetchAsync method that returns our pageDict for fakeRef.\n  const xref = {\n    fetchAsync: async function (ref) {\n      if (ref.num === fakeRef.num && ref.gen === fakeRef.gen) {\n        return pageDict;\n      }\n      throw new Error(\"Unexpected reference.\");\n    },\n  };\n\n  // Create a minimal linearization object.\n  const linearization = {\n    pageFirst: 0,\n    objectNumberFirst: 1,\n  };\n\n  // Minimal catalog with required cache methods.\n  const catalog = {\n    pageKidsCountCache: new MapWithHasPut(),\n    pageIndexCache: new MapWithHasPut(),\n    getPageDict: () => {\n      throw new Error(\"getPageDict should not be called in this test\");\n    },\n  };\n\n  // Create a dummy stream.\n  const stream = new StringStream(\"dummy\");\n\n  // Instantiate PDFDocument with a dummy pdfManager.\n  const pdfDoc = new PDFDocument({ docId: 123 }, stream);\n  pdfDoc.linearization = linearization;\n  pdfDoc.catalog = catalog;\n  pdfDoc.xref = xref;\n\n  const [resultDict, resultRef] = await pdfDoc._getLinearizationPage(0);\n  if (resultDict !== pageDict) {\n    throw new Error(\"The page dictionary was not correctly recognized.\");\n  }\n  if (resultRef.num !== fakeRef.num || resultRef.gen !== fakeRef.gen) {\n    throw new Error(\"The page reference returned is incorrect.\");\n  }\n});\n"
  },
  "18166": {
    "i1_deepseek-r1-distill-llama-70b": "it(\"should gracefully recover when xreffetchIfRef throws\", async () => {\n  const { Ref } = await import(\"../../src/core/primitives.js\");\n  const { PartialEvaluator } = await import(\"../../src/core/evaluator.js\");\n  const { createIdFactory } = await import(\"./test_utils.js\");\n\n  const fakeXRef = {\n    fetchIfRef: () => {\n      throw new Error(\"Test error\");\n    },\n  };\n\n  const fontCache = {\n    _cache: new Map(),\n    has(key) {\n      return this._cache.has(key);\n    },\n    get(key) {\n      return this._cache.get(key);\n    },\n    put(key, value) {\n      this._cache.set(key, value);\n    },\n    putAlias(key, alias) {\n      this._cache.set(key, this._cache.get(alias));\n    },\n  };\n\n  const evaluator = new PartialEvaluator({\n    xref: fakeXRef,\n    handler: {},\n    pageIndex: 0,\n    idFactory: createIdFactory(),\n    fontCache,\n    builtInCMapCache: {},\n    standardFontDataCache: {},\n    globalImageCache: {},\n    systemFontCache: {},\n    options: { ignoreErrors: false },\n  });\n\n  const fakeFontRef = new Ref(0, 0);\n  const resources = {\n    get(key) {\n      if (key === \"Font\") {\n        return {\n          getRaw: (name) => fakeFontRef,\n        };\n      }\n    },\n  };\n\n  const result = await evaluator.loadFont(\"testFont\", null, resources);\n  if (result.loadedName !== \"g_font_error\") {\n    throw new Error(\"Expected fallback font loadedName to be 'g_font_error'\");\n  }\n  if (\n    !result.font ||\n    typeof result.font.message !== \"string\" ||\n    result.font.message !== 'Font \"testFont\" is not available.'\n  ) {\n    throw new Error(\"Expected error font with correct message\");\n  }\n});\n",
    "i1_gpt-4o": "it(\"should gracefully recover when xreffetchIfRef throws\", async () => {\n  const { Ref } = await import(\"../../src/core/primitives.js\");\n  const { PartialEvaluator } = await import(\"../../src/core/evaluator.js\");\n  const { createIdFactory } = await import(\"./test_utils.js\");\n\n  const fakeXRef = {\n    fetchIfRef: () => {\n      throw new Error(\"Test error\");\n    },\n  };\n\n  const fontCache = {\n    _cache: new Map(),\n    has(key) {\n      return this._cache.has(key);\n    },\n    get(key) {\n      return this._cache.get(key);\n    },\n    put(key, value) {\n      this._cache.set(key, value);\n    },\n    putAlias(key, alias) {\n      this._cache.set(key, this._cache.get(alias));\n    },\n  };\n\n  const evaluator = new PartialEvaluator({\n    xref: fakeXRef,\n    handler: {},\n    pageIndex: 0,\n    idFactory: createIdFactory(),\n    fontCache,\n    builtInCMapCache: {},\n    standardFontDataCache: {},\n    globalImageCache: {},\n    systemFontCache: {},\n    options: { ignoreErrors: false },\n  });\n\n  const fakeFontRef = new Ref(0, 0);\n  const resources = {\n    get(key) {\n      if (key === \"Font\") {\n        return {\n          getRaw: (name) => fakeFontRef,\n        };\n      }\n    },\n  };\n\n  const result = await evaluator.loadFont(\"testFont\", null, resources);\n  if (result.loadedName !== \"g_font_error\") {\n    throw new Error(\"Expected fallback font loadedName to be 'g_font_error'\");\n  }\n  if (\n    !result.font ||\n    typeof result.font.message !== \"string\" ||\n    result.font.message !== 'Font \"testFont\" is not available.'\n  ) {\n    throw new Error(\"Expected error font with correct message\");\n  }\n});\n",
    "i1_llama-3.3-70b-versatile": "it(\"should gracefully recover when xreffetchIfRef throws\", async () => {\n  const { Ref } = await import(\"../../src/core/primitives.js\");\n  const { PartialEvaluator } = await import(\"../../src/core/evaluator.js\");\n  const { createIdFactory } = await import(\"./test_utils.js\");\n\n  const fakeXRef = {\n    fetchIfRef: () => {\n      throw new Error(\"Test error\");\n    },\n  };\n\n  const fontCache = {\n    _cache: new Map(),\n    has(key) {\n      return this._cache.has(key);\n    },\n    get(key) {\n      return this._cache.get(key);\n    },\n    put(key, value) {\n      this._cache.set(key, value);\n    },\n    putAlias(key, alias) {\n      this._cache.set(key, this._cache.get(alias));\n    },\n  };\n\n  const evaluator = new PartialEvaluator({\n    xref: fakeXRef,\n    handler: {},\n    pageIndex: 0,\n    idFactory: createIdFactory(),\n    fontCache,\n    builtInCMapCache: {},\n    standardFontDataCache: {},\n    globalImageCache: {},\n    systemFontCache: {},\n    options: { ignoreErrors: false },\n  });\n\n  const fakeFontRef = new Ref(0, 0);\n  const resources = {\n    get(key) {\n      if (key === \"Font\") {\n        return {\n          getRaw: (name) => fakeFontRef,\n        };\n      }\n    },\n  };\n\n  const result = await evaluator.loadFont(\"testFont\", null, resources);\n  if (result.loadedName !== \"g_font_error\") {\n    throw new Error(\"Expected fallback font loadedName to be 'g_font_error'\");\n  }\n  if (\n    !result.font ||\n    typeof result.font.message !== \"string\" ||\n    result.font.message !== 'Font \"testFont\" is not available.'\n  ) {\n    throw new Error(\"Expected error font with correct message\");\n  }\n});\n",
    "i1_MOCK": "it(\"should gracefully recover when xreffetchIfRef throws\", async () => {\n  const { Ref } = await import(\"../../src/core/primitives.js\");\n  const { PartialEvaluator } = await import(\"../../src/core/evaluator.js\");\n  const { createIdFactory } = await import(\"./test_utils.js\");\n\n  const fakeXRef = {\n    fetchIfRef: () => {\n      throw new Error(\"Test error\");\n    },\n  };\n\n  const fontCache = {\n    _cache: new Map(),\n    has(key) {\n      return this._cache.has(key);\n    },\n    get(key) {\n      return this._cache.get(key);\n    },\n    put(key, value) {\n      this._cache.set(key, value);\n    },\n    putAlias(key, alias) {\n      this._cache.set(key, this._cache.get(alias));\n    },\n  };\n\n  const evaluator = new PartialEvaluator({\n    xref: fakeXRef,\n    handler: {},\n    pageIndex: 0,\n    idFactory: createIdFactory(),\n    fontCache,\n    builtInCMapCache: {},\n    standardFontDataCache: {},\n    globalImageCache: {},\n    systemFontCache: {},\n    options: { ignoreErrors: false },\n  });\n\n  const fakeFontRef = new Ref(0, 0);\n  const resources = {\n    get(key) {\n      if (key === \"Font\") {\n        return {\n          getRaw: (name) => fakeFontRef,\n        };\n      }\n    },\n  };\n\n  const result = await evaluator.loadFont(\"testFont\", null, resources);\n  if (result.loadedName !== \"g_font_error\") {\n    throw new Error(\"Expected fallback font loadedName to be 'g_font_error'\");\n  }\n  if (\n    !result.font ||\n    typeof result.font.message !== \"string\" ||\n    result.font.message !== 'Font \"testFont\" is not available.'\n  ) {\n    throw new Error(\"Expected error font with correct message\");\n  }\n});\n",
    "i2_deepseek-r1-distill-llama-70b": "it(\"should gracefully recover when xreffetchIfRef throws\", async () => {\n  const { Ref } = await import(\"../../src/core/primitives.js\");\n  const { PartialEvaluator } = await import(\"../../src/core/evaluator.js\");\n  const { createIdFactory } = await import(\"./test_utils.js\");\n\n  const fakeXRef = {\n    fetchIfRef: () => {\n      throw new Error(\"Test error\");\n    },\n  };\n\n  const fontCache = {\n    _cache: new Map(),\n    has(key) {\n      return this._cache.has(key);\n    },\n    get(key) {\n      return this._cache.get(key);\n    },\n    put(key, value) {\n      this._cache.set(key, value);\n    },\n    putAlias(key, alias) {\n      this._cache.set(key, this._cache.get(alias));\n    },\n  };\n\n  const evaluator = new PartialEvaluator({\n    xref: fakeXRef,\n    handler: {},\n    pageIndex: 0,\n    idFactory: createIdFactory(),\n    fontCache,\n    builtInCMapCache: {},\n    standardFontDataCache: {},\n    globalImageCache: {},\n    systemFontCache: {},\n    options: { ignoreErrors: false },\n  });\n\n  const fakeFontRef = new Ref(0, 0);\n  const resources = {\n    get(key) {\n      if (key === \"Font\") {\n        return {\n          getRaw: (name) => fakeFontRef,\n        };\n      }\n    },\n  };\n\n  const result = await evaluator.loadFont(\"testFont\", null, resources);\n  if (result.loadedName !== \"g_font_error\") {\n    throw new Error(\"Expected fallback font loadedName to be 'g_font_error'\");\n  }\n  if (\n    !result.font ||\n    typeof result.font.message !== \"string\" ||\n    result.font.message !== 'Font \"testFont\" is not available.'\n  ) {\n    throw new Error(\"Expected error font with correct message\");\n  }\n});\n",
    "i2_gpt-4o": "it(\"should gracefully recover when xreffetchIfRef throws\", async () => {\n  const { Ref } = await import(\"../../src/core/primitives.js\");\n  const { PartialEvaluator } = await import(\"../../src/core/evaluator.js\");\n  const { createIdFactory } = await import(\"./test_utils.js\");\n\n  const fakeXRef = {\n    fetchIfRef: () => {\n      throw new Error(\"Test error\");\n    },\n  };\n\n  const fontCache = {\n    _cache: new Map(),\n    has(key) {\n      return this._cache.has(key);\n    },\n    get(key) {\n      return this._cache.get(key);\n    },\n    put(key, value) {\n      this._cache.set(key, value);\n    },\n    putAlias(key, alias) {\n      this._cache.set(key, this._cache.get(alias));\n    },\n  };\n\n  const evaluator = new PartialEvaluator({\n    xref: fakeXRef,\n    handler: {},\n    pageIndex: 0,\n    idFactory: createIdFactory(),\n    fontCache,\n    builtInCMapCache: {},\n    standardFontDataCache: {},\n    globalImageCache: {},\n    systemFontCache: {},\n    options: { ignoreErrors: false },\n  });\n\n  const fakeFontRef = new Ref(0, 0);\n  const resources = {\n    get(key) {\n      if (key === \"Font\") {\n        return {\n          getRaw: (name) => fakeFontRef,\n        };\n      }\n    },\n  };\n\n  const result = await evaluator.loadFont(\"testFont\", null, resources);\n  if (result.loadedName !== \"g_font_error\") {\n    throw new Error(\"Expected fallback font loadedName to be 'g_font_error'\");\n  }\n  if (\n    !result.font ||\n    typeof result.font.message !== \"string\" ||\n    result.font.message !== 'Font \"testFont\" is not available.'\n  ) {\n    throw new Error(\"Expected error font with correct message\");\n  }\n});\n",
    "i2_llama-3.3-70b-versatile": "it(\"should gracefully recover when xreffetchIfRef throws\", async () => {\n  const { Ref } = await import(\"../../src/core/primitives.js\");\n  const { PartialEvaluator } = await import(\"../../src/core/evaluator.js\");\n  const { createIdFactory } = await import(\"./test_utils.js\");\n\n  const fakeXRef = {\n    fetchIfRef: () => {\n      throw new Error(\"Test error\");\n    },\n  };\n\n  const fontCache = {\n    _cache: new Map(),\n    has(key) {\n      return this._cache.has(key);\n    },\n    get(key) {\n      return this._cache.get(key);\n    },\n    put(key, value) {\n      this._cache.set(key, value);\n    },\n    putAlias(key, alias) {\n      this._cache.set(key, this._cache.get(alias));\n    },\n  };\n\n  const evaluator = new PartialEvaluator({\n    xref: fakeXRef,\n    handler: {},\n    pageIndex: 0,\n    idFactory: createIdFactory(),\n    fontCache,\n    builtInCMapCache: {},\n    standardFontDataCache: {},\n    globalImageCache: {},\n    systemFontCache: {},\n    options: { ignoreErrors: false },\n  });\n\n  const fakeFontRef = new Ref(0, 0);\n  const resources = {\n    get(key) {\n      if (key === \"Font\") {\n        return {\n          getRaw: (name) => fakeFontRef,\n        };\n      }\n    },\n  };\n\n  const result = await evaluator.loadFont(\"testFont\", null, resources);\n  if (result.loadedName !== \"g_font_error\") {\n    throw new Error(\"Expected fallback font loadedName to be 'g_font_error'\");\n  }\n  if (\n    !result.font ||\n    typeof result.font.message !== \"string\" ||\n    result.font.message !== 'Font \"testFont\" is not available.'\n  ) {\n    throw new Error(\"Expected error font with correct message\");\n  }\n});\n",
    "i3_deepseek-r1-distill-llama-70b": "it(\"should gracefully recover when xreffetchIfRef throws\", async () => {\n  const { Ref } = await import(\"../../src/core/primitives.js\");\n  const { PartialEvaluator } = await import(\"../../src/core/evaluator.js\");\n  const { createIdFactory } = await import(\"./test_utils.js\");\n\n  const fakeXRef = {\n    fetchIfRef: () => {\n      throw new Error(\"Test error\");\n    },\n  };\n\n  const fontCache = {\n    _cache: new Map(),\n    has(key) {\n      return this._cache.has(key);\n    },\n    get(key) {\n      return this._cache.get(key);\n    },\n    put(key, value) {\n      this._cache.set(key, value);\n    },\n    putAlias(key, alias) {\n      this._cache.set(key, this._cache.get(alias));\n    },\n  };\n\n  const evaluator = new PartialEvaluator({\n    xref: fakeXRef,\n    handler: {},\n    pageIndex: 0,\n    idFactory: createIdFactory(),\n    fontCache,\n    builtInCMapCache: {},\n    standardFontDataCache: {},\n    globalImageCache: {},\n    systemFontCache: {},\n    options: { ignoreErrors: false },\n  });\n\n  const fakeFontRef = new Ref(0, 0);\n  const resources = {\n    get(key) {\n      if (key === \"Font\") {\n        return {\n          getRaw: (name) => fakeFontRef,\n        };\n      }\n    },\n  };\n\n  const result = await evaluator.loadFont(\"testFont\", null, resources);\n  if (result.loadedName !== \"g_font_error\") {\n    throw new Error(\"Expected fallback font loadedName to be 'g_font_error'\");\n  }\n  if (\n    !result.font ||\n    typeof result.font.message !== \"string\" ||\n    result.font.message !== 'Font \"testFont\" is not available.'\n  ) {\n    throw new Error(\"Expected error font with correct message\");\n  }\n});\n",
    "i3_gpt-4o": "it(\"should gracefully recover when xreffetchIfRef throws\", async () => {\n  const { Ref } = await import(\"../../src/core/primitives.js\");\n  const { PartialEvaluator } = await import(\"../../src/core/evaluator.js\");\n  const { createIdFactory } = await import(\"./test_utils.js\");\n\n  const fakeXRef = {\n    fetchIfRef: () => {\n      throw new Error(\"Test error\");\n    },\n  };\n\n  const fontCache = {\n    _cache: new Map(),\n    has(key) {\n      return this._cache.has(key);\n    },\n    get(key) {\n      return this._cache.get(key);\n    },\n    put(key, value) {\n      this._cache.set(key, value);\n    },\n    putAlias(key, alias) {\n      this._cache.set(key, this._cache.get(alias));\n    },\n  };\n\n  const evaluator = new PartialEvaluator({\n    xref: fakeXRef,\n    handler: {},\n    pageIndex: 0,\n    idFactory: createIdFactory(),\n    fontCache,\n    builtInCMapCache: {},\n    standardFontDataCache: {},\n    globalImageCache: {},\n    systemFontCache: {},\n    options: { ignoreErrors: false },\n  });\n\n  const fakeFontRef = new Ref(0, 0);\n  const resources = {\n    get(key) {\n      if (key === \"Font\") {\n        return {\n          getRaw: (name) => fakeFontRef,\n        };\n      }\n    },\n  };\n\n  const result = await evaluator.loadFont(\"testFont\", null, resources);\n  if (result.loadedName !== \"g_font_error\") {\n    throw new Error(\"Expected fallback font loadedName to be 'g_font_error'\");\n  }\n  if (\n    !result.font ||\n    typeof result.font.message !== \"string\" ||\n    result.font.message !== 'Font \"testFont\" is not available.'\n  ) {\n    throw new Error(\"Expected error font with correct message\");\n  }\n});\n",
    "i3_llama-3.3-70b-versatile": "it(\"should gracefully recover when xreffetchIfRef throws\", async () => {\n  const { Ref } = await import(\"../../src/core/primitives.js\");\n  const { PartialEvaluator } = await import(\"../../src/core/evaluator.js\");\n  const { createIdFactory } = await import(\"./test_utils.js\");\n\n  const fakeXRef = {\n    fetchIfRef: () => {\n      throw new Error(\"Test error\");\n    },\n  };\n\n  const fontCache = {\n    _cache: new Map(),\n    has(key) {\n      return this._cache.has(key);\n    },\n    get(key) {\n      return this._cache.get(key);\n    },\n    put(key, value) {\n      this._cache.set(key, value);\n    },\n    putAlias(key, alias) {\n      this._cache.set(key, this._cache.get(alias));\n    },\n  };\n\n  const evaluator = new PartialEvaluator({\n    xref: fakeXRef,\n    handler: {},\n    pageIndex: 0,\n    idFactory: createIdFactory(),\n    fontCache,\n    builtInCMapCache: {},\n    standardFontDataCache: {},\n    globalImageCache: {},\n    systemFontCache: {},\n    options: { ignoreErrors: false },\n  });\n\n  const fakeFontRef = new Ref(0, 0);\n  const resources = {\n    get(key) {\n      if (key === \"Font\") {\n        return {\n          getRaw: (name) => fakeFontRef,\n        };\n      }\n    },\n  };\n\n  const result = await evaluator.loadFont(\"testFont\", null, resources);\n  if (result.loadedName !== \"g_font_error\") {\n    throw new Error(\"Expected fallback font loadedName to be 'g_font_error'\");\n  }\n  if (\n    !result.font ||\n    typeof result.font.message !== \"string\" ||\n    result.font.message !== 'Font \"testFont\" is not available.'\n  ) {\n    throw new Error(\"Expected error font with correct message\");\n  }\n});\n",
    "i4_deepseek-r1-distill-llama-70b": "it(\"should gracefully recover when xreffetchIfRef throws\", async () => {\n  const { Ref } = await import(\"../../src/core/primitives.js\");\n  const { PartialEvaluator } = await import(\"../../src/core/evaluator.js\");\n  const { createIdFactory } = await import(\"./test_utils.js\");\n\n  const fakeXRef = {\n    fetchIfRef: () => {\n      throw new Error(\"Test error\");\n    },\n  };\n\n  const fontCache = {\n    _cache: new Map(),\n    has(key) {\n      return this._cache.has(key);\n    },\n    get(key) {\n      return this._cache.get(key);\n    },\n    put(key, value) {\n      this._cache.set(key, value);\n    },\n    putAlias(key, alias) {\n      this._cache.set(key, this._cache.get(alias));\n    },\n  };\n\n  const evaluator = new PartialEvaluator({\n    xref: fakeXRef,\n    handler: {},\n    pageIndex: 0,\n    idFactory: createIdFactory(),\n    fontCache,\n    builtInCMapCache: {},\n    standardFontDataCache: {},\n    globalImageCache: {},\n    systemFontCache: {},\n    options: { ignoreErrors: false },\n  });\n\n  const fakeFontRef = new Ref(0, 0);\n  const resources = {\n    get(key) {\n      if (key === \"Font\") {\n        return {\n          getRaw: (name) => fakeFontRef,\n        };\n      }\n    },\n  };\n\n  const result = await evaluator.loadFont(\"testFont\", null, resources);\n  if (result.loadedName !== \"g_font_error\") {\n    throw new Error(\"Expected fallback font loadedName to be 'g_font_error'\");\n  }\n  if (\n    !result.font ||\n    typeof result.font.message !== \"string\" ||\n    result.font.message !== 'Font \"testFont\" is not available.'\n  ) {\n    throw new Error(\"Expected error font with correct message\");\n  }\n});\n",
    "i4_gpt-4o": "it(\"should gracefully recover when xreffetchIfRef throws\", async () => {\n  const { Ref } = await import(\"../../src/core/primitives.js\");\n  const { PartialEvaluator } = await import(\"../../src/core/evaluator.js\");\n  const { createIdFactory } = await import(\"./test_utils.js\");\n\n  const fakeXRef = {\n    fetchIfRef: () => {\n      throw new Error(\"Test error\");\n    },\n  };\n\n  const fontCache = {\n    _cache: new Map(),\n    has(key) {\n      return this._cache.has(key);\n    },\n    get(key) {\n      return this._cache.get(key);\n    },\n    put(key, value) {\n      this._cache.set(key, value);\n    },\n    putAlias(key, alias) {\n      this._cache.set(key, this._cache.get(alias));\n    },\n  };\n\n  const evaluator = new PartialEvaluator({\n    xref: fakeXRef,\n    handler: {},\n    pageIndex: 0,\n    idFactory: createIdFactory(),\n    fontCache,\n    builtInCMapCache: {},\n    standardFontDataCache: {},\n    globalImageCache: {},\n    systemFontCache: {},\n    options: { ignoreErrors: false },\n  });\n\n  const fakeFontRef = new Ref(0, 0);\n  const resources = {\n    get(key) {\n      if (key === \"Font\") {\n        return {\n          getRaw: (name) => fakeFontRef,\n        };\n      }\n    },\n  };\n\n  const result = await evaluator.loadFont(\"testFont\", null, resources);\n  if (result.loadedName !== \"g_font_error\") {\n    throw new Error(\"Expected fallback font loadedName to be 'g_font_error'\");\n  }\n  if (\n    !result.font ||\n    typeof result.font.message !== \"string\" ||\n    result.font.message !== 'Font \"testFont\" is not available.'\n  ) {\n    throw new Error(\"Expected error font with correct message\");\n  }\n});\n",
    "i4_llama-3.3-70b-versatile": "it(\"should gracefully recover when xreffetchIfRef throws\", async () => {\n  const { Ref } = await import(\"../../src/core/primitives.js\");\n  const { PartialEvaluator } = await import(\"../../src/core/evaluator.js\");\n  const { createIdFactory } = await import(\"./test_utils.js\");\n\n  const fakeXRef = {\n    fetchIfRef: () => {\n      throw new Error(\"Test error\");\n    },\n  };\n\n  const fontCache = {\n    _cache: new Map(),\n    has(key) {\n      return this._cache.has(key);\n    },\n    get(key) {\n      return this._cache.get(key);\n    },\n    put(key, value) {\n      this._cache.set(key, value);\n    },\n    putAlias(key, alias) {\n      this._cache.set(key, this._cache.get(alias));\n    },\n  };\n\n  const evaluator = new PartialEvaluator({\n    xref: fakeXRef,\n    handler: {},\n    pageIndex: 0,\n    idFactory: createIdFactory(),\n    fontCache,\n    builtInCMapCache: {},\n    standardFontDataCache: {},\n    globalImageCache: {},\n    systemFontCache: {},\n    options: { ignoreErrors: false },\n  });\n\n  const fakeFontRef = new Ref(0, 0);\n  const resources = {\n    get(key) {\n      if (key === \"Font\") {\n        return {\n          getRaw: (name) => fakeFontRef,\n        };\n      }\n    },\n  };\n\n  const result = await evaluator.loadFont(\"testFont\", null, resources);\n  if (result.loadedName !== \"g_font_error\") {\n    throw new Error(\"Expected fallback font loadedName to be 'g_font_error'\");\n  }\n  if (\n    !result.font ||\n    typeof result.font.message !== \"string\" ||\n    result.font.message !== 'Font \"testFont\" is not available.'\n  ) {\n    throw new Error(\"Expected error font with correct message\");\n  }\n});\n",
    "i5_deepseek-r1-distill-llama-70b": "it(\"should gracefully recover when xreffetchIfRef throws\", async () => {\n  const { Ref } = await import(\"../../src/core/primitives.js\");\n  const { PartialEvaluator } = await import(\"../../src/core/evaluator.js\");\n  const { createIdFactory } = await import(\"./test_utils.js\");\n\n  const fakeXRef = {\n    fetchIfRef: () => {\n      throw new Error(\"Test error\");\n    },\n  };\n\n  const fontCache = {\n    _cache: new Map(),\n    has(key) {\n      return this._cache.has(key);\n    },\n    get(key) {\n      return this._cache.get(key);\n    },\n    put(key, value) {\n      this._cache.set(key, value);\n    },\n    putAlias(key, alias) {\n      this._cache.set(key, this._cache.get(alias));\n    },\n  };\n\n  const evaluator = new PartialEvaluator({\n    xref: fakeXRef,\n    handler: {},\n    pageIndex: 0,\n    idFactory: createIdFactory(),\n    fontCache,\n    builtInCMapCache: {},\n    standardFontDataCache: {},\n    globalImageCache: {},\n    systemFontCache: {},\n    options: { ignoreErrors: false },\n  });\n\n  const fakeFontRef = new Ref(0, 0);\n  const resources = {\n    get(key) {\n      if (key === \"Font\") {\n        return {\n          getRaw: (name) => fakeFontRef,\n        };\n      }\n    },\n  };\n\n  const result = await evaluator.loadFont(\"testFont\", null, resources);\n  if (result.loadedName !== \"g_font_error\") {\n    throw new Error(\"Expected fallback font loadedName to be 'g_font_error'\");\n  }\n  if (\n    !result.font ||\n    typeof result.font.message !== \"string\" ||\n    result.font.message !== 'Font \"testFont\" is not available.'\n  ) {\n    throw new Error(\"Expected error font with correct message\");\n  }\n});\n",
    "i5_gpt-4o": "it(\"should gracefully recover when xreffetchIfRef throws\", async () => {\n  const { Ref } = await import(\"../../src/core/primitives.js\");\n  const { PartialEvaluator } = await import(\"../../src/core/evaluator.js\");\n  const { createIdFactory } = await import(\"./test_utils.js\");\n\n  const fakeXRef = {\n    fetchIfRef: () => {\n      throw new Error(\"Test error\");\n    },\n  };\n\n  const fontCache = {\n    _cache: new Map(),\n    has(key) {\n      return this._cache.has(key);\n    },\n    get(key) {\n      return this._cache.get(key);\n    },\n    put(key, value) {\n      this._cache.set(key, value);\n    },\n    putAlias(key, alias) {\n      this._cache.set(key, this._cache.get(alias));\n    },\n  };\n\n  const evaluator = new PartialEvaluator({\n    xref: fakeXRef,\n    handler: {},\n    pageIndex: 0,\n    idFactory: createIdFactory(),\n    fontCache,\n    builtInCMapCache: {},\n    standardFontDataCache: {},\n    globalImageCache: {},\n    systemFontCache: {},\n    options: { ignoreErrors: false },\n  });\n\n  const fakeFontRef = new Ref(0, 0);\n  const resources = {\n    get(key) {\n      if (key === \"Font\") {\n        return {\n          getRaw: (name) => fakeFontRef,\n        };\n      }\n    },\n  };\n\n  const result = await evaluator.loadFont(\"testFont\", null, resources);\n  if (result.loadedName !== \"g_font_error\") {\n    throw new Error(\"Expected fallback font loadedName to be 'g_font_error'\");\n  }\n  if (\n    !result.font ||\n    typeof result.font.message !== \"string\" ||\n    result.font.message !== 'Font \"testFont\" is not available.'\n  ) {\n    throw new Error(\"Expected error font with correct message\");\n  }\n});\n",
    "i5_llama-3.3-70b-versatile": "it(\"should gracefully recover when xreffetchIfRef throws\", async () => {\n  const { Ref } = await import(\"../../src/core/primitives.js\");\n  const { PartialEvaluator } = await import(\"../../src/core/evaluator.js\");\n  const { createIdFactory } = await import(\"./test_utils.js\");\n\n  const fakeXRef = {\n    fetchIfRef: () => {\n      throw new Error(\"Test error\");\n    },\n  };\n\n  const fontCache = {\n    _cache: new Map(),\n    has(key) {\n      return this._cache.has(key);\n    },\n    get(key) {\n      return this._cache.get(key);\n    },\n    put(key, value) {\n      this._cache.set(key, value);\n    },\n    putAlias(key, alias) {\n      this._cache.set(key, this._cache.get(alias));\n    },\n  };\n\n  const evaluator = new PartialEvaluator({\n    xref: fakeXRef,\n    handler: {},\n    pageIndex: 0,\n    idFactory: createIdFactory(),\n    fontCache,\n    builtInCMapCache: {},\n    standardFontDataCache: {},\n    globalImageCache: {},\n    systemFontCache: {},\n    options: { ignoreErrors: false },\n  });\n\n  const fakeFontRef = new Ref(0, 0);\n  const resources = {\n    get(key) {\n      if (key === \"Font\") {\n        return {\n          getRaw: (name) => fakeFontRef,\n        };\n      }\n    },\n  };\n\n  const result = await evaluator.loadFont(\"testFont\", null, resources);\n  if (result.loadedName !== \"g_font_error\") {\n    throw new Error(\"Expected fallback font loadedName to be 'g_font_error'\");\n  }\n  if (\n    !result.font ||\n    typeof result.font.message !== \"string\" ||\n    result.font.message !== 'Font \"testFont\" is not available.'\n  ) {\n    throw new Error(\"Expected error font with correct message\");\n  }\n});\n"
  },
  "18228": {
    "i1_deepseek-r1-distill-llama-70b": "it(\"should hide barcode annotations when PMD is present\", () => {\n  const dummyDict = {\n    has: key => key === \"PMD\",\n    get: () => undefined,\n  };\n  const params = {\n    subtype: \"Widget\",\n    fieldType: \"Tx\",\n    dict: dummyDict,\n    data: {\n      readOnly: true,\n      noHTML: false,\n      fieldValue: \"Test\",\n    },\n  };\n  const annotation = AnnotationFactory.createAnnotation(params);\n  if (!(annotation.flags & AnnotationFlag.HIDDEN)) {\n    throw new Error(\"Expected annotation to have the HIDDEN flag set when PMD is present\");\n  }\n  if (annotation.data.hidden !== true) {\n    throw new Error(\"Expected annotation.data.hidden to be true when PMD is present\");\n  }\n});",
    "i1_gpt-4o": "it(\"should hide barcode annotations when PMD is present\", () => {\n  const dummyDict = {\n    has: key => key === \"PMD\",\n    get: () => undefined,\n  };\n  const params = {\n    subtype: \"Widget\",\n    fieldType: \"Tx\",\n    dict: dummyDict,\n    data: {\n      readOnly: true,\n      noHTML: false,\n      fieldValue: \"Test\",\n    },\n  };\n  const annotation = AnnotationFactory.createAnnotation(params);\n  if (!(annotation.flags & AnnotationFlag.HIDDEN)) {\n    throw new Error(\"Expected annotation to have the HIDDEN flag set when PMD is present\");\n  }\n  if (annotation.data.hidden !== true) {\n    throw new Error(\"Expected annotation.data.hidden to be true when PMD is present\");\n  }\n});",
    "i1_llama-3.3-70b-versatile": "it(\"should hide barcode annotations when PMD is present\", () => {\n  const dummyDict = {\n    has: key => key === \"PMD\",\n    get: () => undefined,\n  };\n  const params = {\n    subtype: \"Widget\",\n    fieldType: \"Tx\",\n    dict: dummyDict,\n    data: {\n      readOnly: true,\n      noHTML: false,\n      fieldValue: \"Test\",\n    },\n  };\n  const annotation = AnnotationFactory.createAnnotation(params);\n  if (!(annotation.flags & AnnotationFlag.HIDDEN)) {\n    throw new Error(\"Expected annotation to have the HIDDEN flag set when PMD is present\");\n  }\n  if (annotation.data.hidden !== true) {\n    throw new Error(\"Expected annotation.data.hidden to be true when PMD is present\");\n  }\n});",
    "i1_MOCK": "it(\"should hide barcode annotations when PMD is present\", () => {\n  const dummyDict = {\n    has: key => key === \"PMD\",\n    get: () => undefined,\n  };\n  const params = {\n    subtype: \"Widget\",\n    fieldType: \"Tx\",\n    dict: dummyDict,\n    data: {\n      readOnly: true,\n      noHTML: false,\n      fieldValue: \"Test\",\n    },\n  };\n  const annotation = AnnotationFactory.createAnnotation(params);\n  if (!(annotation.flags & AnnotationFlag.HIDDEN)) {\n    throw new Error(\"Expected annotation to have the HIDDEN flag set when PMD is present\");\n  }\n  if (annotation.data.hidden !== true) {\n    throw new Error(\"Expected annotation.data.hidden to be true when PMD is present\");\n  }\n});",
    "i2_deepseek-r1-distill-llama-70b": "it(\"should hide barcode annotations when PMD is present\", () => {\n  const dummyDict = {\n    has: key => key === \"PMD\",\n    get: () => undefined,\n  };\n  const params = {\n    subtype: \"Widget\",\n    fieldType: \"Tx\",\n    dict: dummyDict,\n    data: {\n      readOnly: true,\n      noHTML: false,\n      fieldValue: \"Test\",\n    },\n  };\n  const annotation = AnnotationFactory.createAnnotation(params);\n  if (!(annotation.flags & AnnotationFlag.HIDDEN)) {\n    throw new Error(\"Expected annotation to have the HIDDEN flag set when PMD is present\");\n  }\n  if (annotation.data.hidden !== true) {\n    throw new Error(\"Expected annotation.data.hidden to be true when PMD is present\");\n  }\n});",
    "i2_gpt-4o": "it(\"should hide barcode annotations when PMD is present\", () => {\n  const dummyDict = {\n    has: key => key === \"PMD\",\n    get: () => undefined,\n  };\n  const params = {\n    subtype: \"Widget\",\n    fieldType: \"Tx\",\n    dict: dummyDict,\n    data: {\n      readOnly: true,\n      noHTML: false,\n      fieldValue: \"Test\",\n    },\n  };\n  const annotation = AnnotationFactory.createAnnotation(params);\n  if (!(annotation.flags & AnnotationFlag.HIDDEN)) {\n    throw new Error(\"Expected annotation to have the HIDDEN flag set when PMD is present\");\n  }\n  if (annotation.data.hidden !== true) {\n    throw new Error(\"Expected annotation.data.hidden to be true when PMD is present\");\n  }\n});",
    "i2_llama-3.3-70b-versatile": "it(\"should hide barcode annotations when PMD is present\", () => {\n  const dummyDict = {\n    has: key => key === \"PMD\",\n    get: () => undefined,\n  };\n  const params = {\n    subtype: \"Widget\",\n    fieldType: \"Tx\",\n    dict: dummyDict,\n    data: {\n      readOnly: true,\n      noHTML: false,\n      fieldValue: \"Test\",\n    },\n  };\n  const annotation = AnnotationFactory.createAnnotation(params);\n  if (!(annotation.flags & AnnotationFlag.HIDDEN)) {\n    throw new Error(\"Expected annotation to have the HIDDEN flag set when PMD is present\");\n  }\n  if (annotation.data.hidden !== true) {\n    throw new Error(\"Expected annotation.data.hidden to be true when PMD is present\");\n  }\n});",
    "i3_deepseek-r1-distill-llama-70b": "it(\"should hide barcode annotations when PMD is present\", () => {\n  const dummyDict = {\n    has: key => key === \"PMD\",\n    get: () => undefined,\n  };\n  const params = {\n    subtype: \"Widget\",\n    fieldType: \"Tx\",\n    dict: dummyDict,\n    data: {\n      readOnly: true,\n      noHTML: false,\n      fieldValue: \"Test\",\n    },\n  };\n  const annotation = AnnotationFactory.createAnnotation(params);\n  if (!(annotation.flags & AnnotationFlag.HIDDEN)) {\n    throw new Error(\"Expected annotation to have the HIDDEN flag set when PMD is present\");\n  }\n  if (annotation.data.hidden !== true) {\n    throw new Error(\"Expected annotation.data.hidden to be true when PMD is present\");\n  }\n});",
    "i3_gpt-4o": "it(\"should hide barcode annotations when PMD is present\", () => {\n  const dummyDict = {\n    has: key => key === \"PMD\",\n    get: () => undefined,\n  };\n  const params = {\n    subtype: \"Widget\",\n    fieldType: \"Tx\",\n    dict: dummyDict,\n    data: {\n      readOnly: true,\n      noHTML: false,\n      fieldValue: \"Test\",\n    },\n  };\n  const annotation = AnnotationFactory.createAnnotation(params);\n  if (!(annotation.flags & AnnotationFlag.HIDDEN)) {\n    throw new Error(\"Expected annotation to have the HIDDEN flag set when PMD is present\");\n  }\n  if (annotation.data.hidden !== true) {\n    throw new Error(\"Expected annotation.data.hidden to be true when PMD is present\");\n  }\n});",
    "i3_llama-3.3-70b-versatile": "it(\"should hide barcode annotations when PMD is present\", () => {\n  const dummyDict = {\n    has: key => key === \"PMD\",\n    get: () => undefined,\n  };\n  const params = {\n    subtype: \"Widget\",\n    fieldType: \"Tx\",\n    dict: dummyDict,\n    data: {\n      readOnly: true,\n      noHTML: false,\n      fieldValue: \"Test\",\n    },\n  };\n  const annotation = AnnotationFactory.createAnnotation(params);\n  if (!(annotation.flags & AnnotationFlag.HIDDEN)) {\n    throw new Error(\"Expected annotation to have the HIDDEN flag set when PMD is present\");\n  }\n  if (annotation.data.hidden !== true) {\n    throw new Error(\"Expected annotation.data.hidden to be true when PMD is present\");\n  }\n});",
    "i4_deepseek-r1-distill-llama-70b": "it(\"should hide barcode annotations when PMD is present\", () => {\n  const dummyDict = {\n    has: key => key === \"PMD\",\n    get: () => undefined,\n  };\n  const params = {\n    subtype: \"Widget\",\n    fieldType: \"Tx\",\n    dict: dummyDict,\n    data: {\n      readOnly: true,\n      noHTML: false,\n      fieldValue: \"Test\",\n    },\n  };\n  const annotation = AnnotationFactory.createAnnotation(params);\n  if (!(annotation.flags & AnnotationFlag.HIDDEN)) {\n    throw new Error(\"Expected annotation to have the HIDDEN flag set when PMD is present\");\n  }\n  if (annotation.data.hidden !== true) {\n    throw new Error(\"Expected annotation.data.hidden to be true when PMD is present\");\n  }\n});",
    "i4_gpt-4o": "it(\"should hide barcode annotations when PMD is present\", () => {\n  const dummyDict = {\n    has: key => key === \"PMD\",\n    get: () => undefined,\n  };\n  const params = {\n    subtype: \"Widget\",\n    fieldType: \"Tx\",\n    dict: dummyDict,\n    data: {\n      readOnly: true,\n      noHTML: false,\n      fieldValue: \"Test\",\n    },\n  };\n  const annotation = AnnotationFactory.createAnnotation(params);\n  if (!(annotation.flags & AnnotationFlag.HIDDEN)) {\n    throw new Error(\"Expected annotation to have the HIDDEN flag set when PMD is present\");\n  }\n  if (annotation.data.hidden !== true) {\n    throw new Error(\"Expected annotation.data.hidden to be true when PMD is present\");\n  }\n});",
    "i4_llama-3.3-70b-versatile": "it(\"should hide barcode annotations when PMD is present\", () => {\n  const dummyDict = {\n    has: key => key === \"PMD\",\n    get: () => undefined,\n  };\n  const params = {\n    subtype: \"Widget\",\n    fieldType: \"Tx\",\n    dict: dummyDict,\n    data: {\n      readOnly: true,\n      noHTML: false,\n      fieldValue: \"Test\",\n    },\n  };\n  const annotation = AnnotationFactory.createAnnotation(params);\n  if (!(annotation.flags & AnnotationFlag.HIDDEN)) {\n    throw new Error(\"Expected annotation to have the HIDDEN flag set when PMD is present\");\n  }\n  if (annotation.data.hidden !== true) {\n    throw new Error(\"Expected annotation.data.hidden to be true when PMD is present\");\n  }\n});",
    "i5_deepseek-r1-distill-llama-70b": "it(\"should hide barcode annotations when PMD is present\", () => {\n  const dummyDict = {\n    has: key => key === \"PMD\",\n    get: () => undefined,\n  };\n  const params = {\n    subtype: \"Widget\",\n    fieldType: \"Tx\",\n    dict: dummyDict,\n    data: {\n      readOnly: true,\n      noHTML: false,\n      fieldValue: \"Test\",\n    },\n  };\n  const annotation = AnnotationFactory.createAnnotation(params);\n  if (!(annotation.flags & AnnotationFlag.HIDDEN)) {\n    throw new Error(\"Expected annotation to have the HIDDEN flag set when PMD is present\");\n  }\n  if (annotation.data.hidden !== true) {\n    throw new Error(\"Expected annotation.data.hidden to be true when PMD is present\");\n  }\n});",
    "i5_gpt-4o": "it(\"should hide barcode annotations when PMD is present\", () => {\n  const dummyDict = {\n    has: key => key === \"PMD\",\n    get: () => undefined,\n  };\n  const params = {\n    subtype: \"Widget\",\n    fieldType: \"Tx\",\n    dict: dummyDict,\n    data: {\n      readOnly: true,\n      noHTML: false,\n      fieldValue: \"Test\",\n    },\n  };\n  const annotation = AnnotationFactory.createAnnotation(params);\n  if (!(annotation.flags & AnnotationFlag.HIDDEN)) {\n    throw new Error(\"Expected annotation to have the HIDDEN flag set when PMD is present\");\n  }\n  if (annotation.data.hidden !== true) {\n    throw new Error(\"Expected annotation.data.hidden to be true when PMD is present\");\n  }\n});",
    "i5_llama-3.3-70b-versatile": "it(\"should hide barcode annotations when PMD is present\", () => {\n  const dummyDict = {\n    has: key => key === \"PMD\",\n    get: () => undefined,\n  };\n  const params = {\n    subtype: \"Widget\",\n    fieldType: \"Tx\",\n    dict: dummyDict,\n    data: {\n      readOnly: true,\n      noHTML: false,\n      fieldValue: \"Test\",\n    },\n  };\n  const annotation = AnnotationFactory.createAnnotation(params);\n  if (!(annotation.flags & AnnotationFlag.HIDDEN)) {\n    throw new Error(\"Expected annotation to have the HIDDEN flag set when PMD is present\");\n  }\n  if (annotation.data.hidden !== true) {\n    throw new Error(\"Expected annotation.data.hidden to be true when PMD is present\");\n  }\n});"
  },
  "18253": {
    "i1_deepseek-r1-distill-llama-70b": "it(\"should compute OS2 table typoAscender correctly using maxfontMatrix rather than first element\", async () => {\n  const { createOS2Table } = await import(\"../../src/core/fonts.js\");\n  const properties = {\n    bbox: [0, -500, 500, 3000],\n    ascent: 3000,\n    descent: -500,\n    fontMatrix: [2, 0, 0, 3, 0, 0],\n    fixedPitch: false,\n    italicAngle: 0,\n    xHeight: 10,\n    capHeight: 10,\n  };\n  // Pass no charstrings so that firstCharIndex becomes 0 and lastCharIndex becomes 255.\n  const os2Table = createOS2Table(properties, null, {});\n  // The typoAscender field is written as a 2-byte big-endian string at offset 68-70.\n  const typoAscenderBytes = os2Table.slice(68, 70);\n  // With the patched code, unitsPerEm = 1/Math.max(2,0,0,3)=1/3; scale = (1/3)/1000 = 0.0003333;\n  // typoAscender = Math.round(3000 * 0.0003333) = 1, i.e. \"\\x00\\x01\".\n  if (typoAscenderBytes !== \"\\x00\\x01\") {\n    throw new Error(\n      `Expected typoAscender bytes to be \"\\\\x00\\\\x01\" but got ${JSON.stringify(\n        typoAscenderBytes\n      )}`\n    );\n  }\n});\n",
    "i1_gpt-4o": "it(\"should compute OS2 table typoAscender correctly using maxfontMatrix rather than first element\", async () => {\n  const { createOS2Table } = await import(\"../../src/core/fonts.js\");\n  const properties = {\n    bbox: [0, -500, 500, 3000],\n    ascent: 3000,\n    descent: -500,\n    fontMatrix: [2, 0, 0, 3, 0, 0],\n    fixedPitch: false,\n    italicAngle: 0,\n    xHeight: 10,\n    capHeight: 10,\n  };\n  // Pass no charstrings so that firstCharIndex becomes 0 and lastCharIndex becomes 255.\n  const os2Table = createOS2Table(properties, null, {});\n  // The typoAscender field is written as a 2-byte big-endian string at offset 68-70.\n  const typoAscenderBytes = os2Table.slice(68, 70);\n  // With the patched code, unitsPerEm = 1/Math.max(2,0,0,3)=1/3; scale = (1/3)/1000 = 0.0003333;\n  // typoAscender = Math.round(3000 * 0.0003333) = 1, i.e. \"\\x00\\x01\".\n  if (typoAscenderBytes !== \"\\x00\\x01\") {\n    throw new Error(\n      `Expected typoAscender bytes to be \"\\\\x00\\\\x01\" but got ${JSON.stringify(\n        typoAscenderBytes\n      )}`\n    );\n  }\n});\n",
    "i1_llama-3.3-70b-versatile": "it(\"should compute OS2 table typoAscender correctly using maxfontMatrix rather than first element\", async () => {\n  const { createOS2Table } = await import(\"../../src/core/fonts.js\");\n  const properties = {\n    bbox: [0, -500, 500, 3000],\n    ascent: 3000,\n    descent: -500,\n    fontMatrix: [2, 0, 0, 3, 0, 0],\n    fixedPitch: false,\n    italicAngle: 0,\n    xHeight: 10,\n    capHeight: 10,\n  };\n  // Pass no charstrings so that firstCharIndex becomes 0 and lastCharIndex becomes 255.\n  const os2Table = createOS2Table(properties, null, {});\n  // The typoAscender field is written as a 2-byte big-endian string at offset 68-70.\n  const typoAscenderBytes = os2Table.slice(68, 70);\n  // With the patched code, unitsPerEm = 1/Math.max(2,0,0,3)=1/3; scale = (1/3)/1000 = 0.0003333;\n  // typoAscender = Math.round(3000 * 0.0003333) = 1, i.e. \"\\x00\\x01\".\n  if (typoAscenderBytes !== \"\\x00\\x01\") {\n    throw new Error(\n      `Expected typoAscender bytes to be \"\\\\x00\\\\x01\" but got ${JSON.stringify(\n        typoAscenderBytes\n      )}`\n    );\n  }\n});\n",
    "i1_MOCK": "it(\"should compute OS2 table typoAscender correctly using maxfontMatrix rather than first element\", async () => {\n  const { createOS2Table } = await import(\"../../src/core/fonts.js\");\n  const properties = {\n    bbox: [0, -500, 500, 3000],\n    ascent: 3000,\n    descent: -500,\n    fontMatrix: [2, 0, 0, 3, 0, 0],\n    fixedPitch: false,\n    italicAngle: 0,\n    xHeight: 10,\n    capHeight: 10,\n  };\n  // Pass no charstrings so that firstCharIndex becomes 0 and lastCharIndex becomes 255.\n  const os2Table = createOS2Table(properties, null, {});\n  // The typoAscender field is written as a 2-byte big-endian string at offset 68-70.\n  const typoAscenderBytes = os2Table.slice(68, 70);\n  // With the patched code, unitsPerEm = 1/Math.max(2,0,0,3)=1/3; scale = (1/3)/1000 = 0.0003333;\n  // typoAscender = Math.round(3000 * 0.0003333) = 1, i.e. \"\\x00\\x01\".\n  if (typoAscenderBytes !== \"\\x00\\x01\") {\n    throw new Error(\n      `Expected typoAscender bytes to be \"\\\\x00\\\\x01\" but got ${JSON.stringify(\n        typoAscenderBytes\n      )}`\n    );\n  }\n});\n",
    "i2_deepseek-r1-distill-llama-70b": "it(\"should compute OS2 table typoAscender correctly using maxfontMatrix rather than first element\", async () => {\n  const { createOS2Table } = await import(\"../../src/core/fonts.js\");\n  const properties = {\n    bbox: [0, -500, 500, 3000],\n    ascent: 3000,\n    descent: -500,\n    fontMatrix: [2, 0, 0, 3, 0, 0],\n    fixedPitch: false,\n    italicAngle: 0,\n    xHeight: 10,\n    capHeight: 10,\n  };\n  // Pass no charstrings so that firstCharIndex becomes 0 and lastCharIndex becomes 255.\n  const os2Table = createOS2Table(properties, null, {});\n  // The typoAscender field is written as a 2-byte big-endian string at offset 68-70.\n  const typoAscenderBytes = os2Table.slice(68, 70);\n  // With the patched code, unitsPerEm = 1/Math.max(2,0,0,3)=1/3; scale = (1/3)/1000 = 0.0003333;\n  // typoAscender = Math.round(3000 * 0.0003333) = 1, i.e. \"\\x00\\x01\".\n  if (typoAscenderBytes !== \"\\x00\\x01\") {\n    throw new Error(\n      `Expected typoAscender bytes to be \"\\\\x00\\\\x01\" but got ${JSON.stringify(\n        typoAscenderBytes\n      )}`\n    );\n  }\n});\n",
    "i2_gpt-4o": "it(\"should compute OS2 table typoAscender correctly using maxfontMatrix rather than first element\", async () => {\n  const { createOS2Table } = await import(\"../../src/core/fonts.js\");\n  const properties = {\n    bbox: [0, -500, 500, 3000],\n    ascent: 3000,\n    descent: -500,\n    fontMatrix: [2, 0, 0, 3, 0, 0],\n    fixedPitch: false,\n    italicAngle: 0,\n    xHeight: 10,\n    capHeight: 10,\n  };\n  // Pass no charstrings so that firstCharIndex becomes 0 and lastCharIndex becomes 255.\n  const os2Table = createOS2Table(properties, null, {});\n  // The typoAscender field is written as a 2-byte big-endian string at offset 68-70.\n  const typoAscenderBytes = os2Table.slice(68, 70);\n  // With the patched code, unitsPerEm = 1/Math.max(2,0,0,3)=1/3; scale = (1/3)/1000 = 0.0003333;\n  // typoAscender = Math.round(3000 * 0.0003333) = 1, i.e. \"\\x00\\x01\".\n  if (typoAscenderBytes !== \"\\x00\\x01\") {\n    throw new Error(\n      `Expected typoAscender bytes to be \"\\\\x00\\\\x01\" but got ${JSON.stringify(\n        typoAscenderBytes\n      )}`\n    );\n  }\n});\n",
    "i2_llama-3.3-70b-versatile": "it(\"should compute OS2 table typoAscender correctly using maxfontMatrix rather than first element\", async () => {\n  const { createOS2Table } = await import(\"../../src/core/fonts.js\");\n  const properties = {\n    bbox: [0, -500, 500, 3000],\n    ascent: 3000,\n    descent: -500,\n    fontMatrix: [2, 0, 0, 3, 0, 0],\n    fixedPitch: false,\n    italicAngle: 0,\n    xHeight: 10,\n    capHeight: 10,\n  };\n  // Pass no charstrings so that firstCharIndex becomes 0 and lastCharIndex becomes 255.\n  const os2Table = createOS2Table(properties, null, {});\n  // The typoAscender field is written as a 2-byte big-endian string at offset 68-70.\n  const typoAscenderBytes = os2Table.slice(68, 70);\n  // With the patched code, unitsPerEm = 1/Math.max(2,0,0,3)=1/3; scale = (1/3)/1000 = 0.0003333;\n  // typoAscender = Math.round(3000 * 0.0003333) = 1, i.e. \"\\x00\\x01\".\n  if (typoAscenderBytes !== \"\\x00\\x01\") {\n    throw new Error(\n      `Expected typoAscender bytes to be \"\\\\x00\\\\x01\" but got ${JSON.stringify(\n        typoAscenderBytes\n      )}`\n    );\n  }\n});\n",
    "i3_deepseek-r1-distill-llama-70b": "it(\"should compute OS2 table typoAscender correctly using maxfontMatrix rather than first element\", async () => {\n  const { createOS2Table } = await import(\"../../src/core/fonts.js\");\n  const properties = {\n    bbox: [0, -500, 500, 3000],\n    ascent: 3000,\n    descent: -500,\n    fontMatrix: [2, 0, 0, 3, 0, 0],\n    fixedPitch: false,\n    italicAngle: 0,\n    xHeight: 10,\n    capHeight: 10,\n  };\n  // Pass no charstrings so that firstCharIndex becomes 0 and lastCharIndex becomes 255.\n  const os2Table = createOS2Table(properties, null, {});\n  // The typoAscender field is written as a 2-byte big-endian string at offset 68-70.\n  const typoAscenderBytes = os2Table.slice(68, 70);\n  // With the patched code, unitsPerEm = 1/Math.max(2,0,0,3)=1/3; scale = (1/3)/1000 = 0.0003333;\n  // typoAscender = Math.round(3000 * 0.0003333) = 1, i.e. \"\\x00\\x01\".\n  if (typoAscenderBytes !== \"\\x00\\x01\") {\n    throw new Error(\n      `Expected typoAscender bytes to be \"\\\\x00\\\\x01\" but got ${JSON.stringify(\n        typoAscenderBytes\n      )}`\n    );\n  }\n});\n",
    "i3_gpt-4o": "it(\"should compute OS2 table typoAscender correctly using maxfontMatrix rather than first element\", async () => {\n  const { createOS2Table } = await import(\"../../src/core/fonts.js\");\n  const properties = {\n    bbox: [0, -500, 500, 3000],\n    ascent: 3000,\n    descent: -500,\n    fontMatrix: [2, 0, 0, 3, 0, 0],\n    fixedPitch: false,\n    italicAngle: 0,\n    xHeight: 10,\n    capHeight: 10,\n  };\n  // Pass no charstrings so that firstCharIndex becomes 0 and lastCharIndex becomes 255.\n  const os2Table = createOS2Table(properties, null, {});\n  // The typoAscender field is written as a 2-byte big-endian string at offset 68-70.\n  const typoAscenderBytes = os2Table.slice(68, 70);\n  // With the patched code, unitsPerEm = 1/Math.max(2,0,0,3)=1/3; scale = (1/3)/1000 = 0.0003333;\n  // typoAscender = Math.round(3000 * 0.0003333) = 1, i.e. \"\\x00\\x01\".\n  if (typoAscenderBytes !== \"\\x00\\x01\") {\n    throw new Error(\n      `Expected typoAscender bytes to be \"\\\\x00\\\\x01\" but got ${JSON.stringify(\n        typoAscenderBytes\n      )}`\n    );\n  }\n});\n",
    "i3_llama-3.3-70b-versatile": "it(\"should compute OS2 table typoAscender correctly using maxfontMatrix rather than first element\", async () => {\n  const { createOS2Table } = await import(\"../../src/core/fonts.js\");\n  const properties = {\n    bbox: [0, -500, 500, 3000],\n    ascent: 3000,\n    descent: -500,\n    fontMatrix: [2, 0, 0, 3, 0, 0],\n    fixedPitch: false,\n    italicAngle: 0,\n    xHeight: 10,\n    capHeight: 10,\n  };\n  // Pass no charstrings so that firstCharIndex becomes 0 and lastCharIndex becomes 255.\n  const os2Table = createOS2Table(properties, null, {});\n  // The typoAscender field is written as a 2-byte big-endian string at offset 68-70.\n  const typoAscenderBytes = os2Table.slice(68, 70);\n  // With the patched code, unitsPerEm = 1/Math.max(2,0,0,3)=1/3; scale = (1/3)/1000 = 0.0003333;\n  // typoAscender = Math.round(3000 * 0.0003333) = 1, i.e. \"\\x00\\x01\".\n  if (typoAscenderBytes !== \"\\x00\\x01\") {\n    throw new Error(\n      `Expected typoAscender bytes to be \"\\\\x00\\\\x01\" but got ${JSON.stringify(\n        typoAscenderBytes\n      )}`\n    );\n  }\n});\n",
    "i4_deepseek-r1-distill-llama-70b": "it(\"should compute OS2 table typoAscender correctly using maxfontMatrix rather than first element\", async () => {\n  const { createOS2Table } = await import(\"../../src/core/fonts.js\");\n  const properties = {\n    bbox: [0, -500, 500, 3000],\n    ascent: 3000,\n    descent: -500,\n    fontMatrix: [2, 0, 0, 3, 0, 0],\n    fixedPitch: false,\n    italicAngle: 0,\n    xHeight: 10,\n    capHeight: 10,\n  };\n  // Pass no charstrings so that firstCharIndex becomes 0 and lastCharIndex becomes 255.\n  const os2Table = createOS2Table(properties, null, {});\n  // The typoAscender field is written as a 2-byte big-endian string at offset 68-70.\n  const typoAscenderBytes = os2Table.slice(68, 70);\n  // With the patched code, unitsPerEm = 1/Math.max(2,0,0,3)=1/3; scale = (1/3)/1000 = 0.0003333;\n  // typoAscender = Math.round(3000 * 0.0003333) = 1, i.e. \"\\x00\\x01\".\n  if (typoAscenderBytes !== \"\\x00\\x01\") {\n    throw new Error(\n      `Expected typoAscender bytes to be \"\\\\x00\\\\x01\" but got ${JSON.stringify(\n        typoAscenderBytes\n      )}`\n    );\n  }\n});\n",
    "i4_gpt-4o": "it(\"should compute OS2 table typoAscender correctly using maxfontMatrix rather than first element\", async () => {\n  const { createOS2Table } = await import(\"../../src/core/fonts.js\");\n  const properties = {\n    bbox: [0, -500, 500, 3000],\n    ascent: 3000,\n    descent: -500,\n    fontMatrix: [2, 0, 0, 3, 0, 0],\n    fixedPitch: false,\n    italicAngle: 0,\n    xHeight: 10,\n    capHeight: 10,\n  };\n  // Pass no charstrings so that firstCharIndex becomes 0 and lastCharIndex becomes 255.\n  const os2Table = createOS2Table(properties, null, {});\n  // The typoAscender field is written as a 2-byte big-endian string at offset 68-70.\n  const typoAscenderBytes = os2Table.slice(68, 70);\n  // With the patched code, unitsPerEm = 1/Math.max(2,0,0,3)=1/3; scale = (1/3)/1000 = 0.0003333;\n  // typoAscender = Math.round(3000 * 0.0003333) = 1, i.e. \"\\x00\\x01\".\n  if (typoAscenderBytes !== \"\\x00\\x01\") {\n    throw new Error(\n      `Expected typoAscender bytes to be \"\\\\x00\\\\x01\" but got ${JSON.stringify(\n        typoAscenderBytes\n      )}`\n    );\n  }\n});\n",
    "i4_llama-3.3-70b-versatile": "it(\"should compute OS2 table typoAscender correctly using maxfontMatrix rather than first element\", async () => {\n  const { createOS2Table } = await import(\"../../src/core/fonts.js\");\n  const properties = {\n    bbox: [0, -500, 500, 3000],\n    ascent: 3000,\n    descent: -500,\n    fontMatrix: [2, 0, 0, 3, 0, 0],\n    fixedPitch: false,\n    italicAngle: 0,\n    xHeight: 10,\n    capHeight: 10,\n  };\n  // Pass no charstrings so that firstCharIndex becomes 0 and lastCharIndex becomes 255.\n  const os2Table = createOS2Table(properties, null, {});\n  // The typoAscender field is written as a 2-byte big-endian string at offset 68-70.\n  const typoAscenderBytes = os2Table.slice(68, 70);\n  // With the patched code, unitsPerEm = 1/Math.max(2,0,0,3)=1/3; scale = (1/3)/1000 = 0.0003333;\n  // typoAscender = Math.round(3000 * 0.0003333) = 1, i.e. \"\\x00\\x01\".\n  if (typoAscenderBytes !== \"\\x00\\x01\") {\n    throw new Error(\n      `Expected typoAscender bytes to be \"\\\\x00\\\\x01\" but got ${JSON.stringify(\n        typoAscenderBytes\n      )}`\n    );\n  }\n});\n",
    "i5_deepseek-r1-distill-llama-70b": "it(\"should compute OS2 table typoAscender correctly using maxfontMatrix rather than first element\", async () => {\n  const { createOS2Table } = await import(\"../../src/core/fonts.js\");\n  const properties = {\n    bbox: [0, -500, 500, 3000],\n    ascent: 3000,\n    descent: -500,\n    fontMatrix: [2, 0, 0, 3, 0, 0],\n    fixedPitch: false,\n    italicAngle: 0,\n    xHeight: 10,\n    capHeight: 10,\n  };\n  // Pass no charstrings so that firstCharIndex becomes 0 and lastCharIndex becomes 255.\n  const os2Table = createOS2Table(properties, null, {});\n  // The typoAscender field is written as a 2-byte big-endian string at offset 68-70.\n  const typoAscenderBytes = os2Table.slice(68, 70);\n  // With the patched code, unitsPerEm = 1/Math.max(2,0,0,3)=1/3; scale = (1/3)/1000 = 0.0003333;\n  // typoAscender = Math.round(3000 * 0.0003333) = 1, i.e. \"\\x00\\x01\".\n  if (typoAscenderBytes !== \"\\x00\\x01\") {\n    throw new Error(\n      `Expected typoAscender bytes to be \"\\\\x00\\\\x01\" but got ${JSON.stringify(\n        typoAscenderBytes\n      )}`\n    );\n  }\n});\n",
    "i5_gpt-4o": "it(\"should compute OS2 table typoAscender correctly using maxfontMatrix rather than first element\", async () => {\n  const { createOS2Table } = await import(\"../../src/core/fonts.js\");\n  const properties = {\n    bbox: [0, -500, 500, 3000],\n    ascent: 3000,\n    descent: -500,\n    fontMatrix: [2, 0, 0, 3, 0, 0],\n    fixedPitch: false,\n    italicAngle: 0,\n    xHeight: 10,\n    capHeight: 10,\n  };\n  // Pass no charstrings so that firstCharIndex becomes 0 and lastCharIndex becomes 255.\n  const os2Table = createOS2Table(properties, null, {});\n  // The typoAscender field is written as a 2-byte big-endian string at offset 68-70.\n  const typoAscenderBytes = os2Table.slice(68, 70);\n  // With the patched code, unitsPerEm = 1/Math.max(2,0,0,3)=1/3; scale = (1/3)/1000 = 0.0003333;\n  // typoAscender = Math.round(3000 * 0.0003333) = 1, i.e. \"\\x00\\x01\".\n  if (typoAscenderBytes !== \"\\x00\\x01\") {\n    throw new Error(\n      `Expected typoAscender bytes to be \"\\\\x00\\\\x01\" but got ${JSON.stringify(\n        typoAscenderBytes\n      )}`\n    );\n  }\n});\n",
    "i5_llama-3.3-70b-versatile": "it(\"should compute OS2 table typoAscender correctly using maxfontMatrix rather than first element\", async () => {\n  const { createOS2Table } = await import(\"../../src/core/fonts.js\");\n  const properties = {\n    bbox: [0, -500, 500, 3000],\n    ascent: 3000,\n    descent: -500,\n    fontMatrix: [2, 0, 0, 3, 0, 0],\n    fixedPitch: false,\n    italicAngle: 0,\n    xHeight: 10,\n    capHeight: 10,\n  };\n  // Pass no charstrings so that firstCharIndex becomes 0 and lastCharIndex becomes 255.\n  const os2Table = createOS2Table(properties, null, {});\n  // The typoAscender field is written as a 2-byte big-endian string at offset 68-70.\n  const typoAscenderBytes = os2Table.slice(68, 70);\n  // With the patched code, unitsPerEm = 1/Math.max(2,0,0,3)=1/3; scale = (1/3)/1000 = 0.0003333;\n  // typoAscender = Math.round(3000 * 0.0003333) = 1, i.e. \"\\x00\\x01\".\n  if (typoAscenderBytes !== \"\\x00\\x01\") {\n    throw new Error(\n      `Expected typoAscender bytes to be \"\\\\x00\\\\x01\" but got ${JSON.stringify(\n        typoAscenderBytes\n      )}`\n    );\n  }\n});\n"
  },
  "18269": {
    "i1_deepseek-r1-distill-llama-70b": "it(\"should add dependency with objId for cached paintImageXObject\", async () => {\n  const idFactory = createIdFactory();\n  const xref = new XRefMock();\n  const handler = { sendWithPromise: () => Promise.resolve(null) };\n  const options = {\n    maxImageSize: 1000,\n    isOffscreenCanvasSupported: false,\n    canvasMaxAreaInBytes: -1,\n    ignoreErrors: true,\n  };\n  const globalImageCache = {\n    shouldCache: () => false,\n    hasDecodeFailed: () => false,\n    setData() {},\n    addByteSize() {}\n  };\n  const partialEvaluator = new PartialEvaluator({\n    xref,\n    handler,\n    pageIndex: 0,\n    idFactory,\n    fontCache: {},\n    builtInCMapCache: {},\n    standardFontDataCache: {},\n    globalImageCache,\n    systemFontCache: {},\n    options,\n  });\n  // Stub _sendImgData so that buildPaintImageXObject can complete.\n  partialEvaluator._sendImgData = () => Promise.resolve();\n  // Create a dummy dictionary with required keys.\n  const dummyDict = new (await import(\"../../src/core/primitives.js\")).Dict();\n  dummyDict.set(\"W\", 10);\n  dummyDict.set(\"H\", 10);\n  // Set a fake objId to simulate an image reference.\n  dummyDict.objId = \"testImgRef\";\n  // Create a minimal dummy image with getBytes.\n  const dummyImage = {\n    dict: dummyDict,\n    getBytes: (n) => new Uint8Array(n),\n  };\n  // Override PDFImage.buildImage to simulate successful image decoding.\n  const { PDFImage } = await import(\"../../src/core/image.js\");\n  PDFImage.buildImage = (params) => {\n    return Promise.resolve({\n      createImageData: () =>\n        Promise.resolve({\n          width: params.image.dict.get(\"W\"),\n          height: params.image.dict.get(\"H\"),\n          data: new Uint8Array(4 * params.image.dict.get(\"W\") * params.image.dict.get(\"H\")),\n          bitmap: false,\n        }),\n    });\n  };\n  // Create a minimal operator list that records dependencies.\n  const operatorList = new OperatorList();\n  const originalAddDependency = operatorList.addDependency.bind(operatorList);\n  operatorList.dependencies = [];\n  operatorList.addDependency = (dep) => {\n    operatorList.dependencies.push(dep);\n    originalAddDependency(dep);\n  };\n  // Setup a simple localImageCache.\n  const localImageCache = {\n    _cache: {},\n    set(key, ref, data) {\n      this._cache[key] = data;\n    },\n    getByName(name) {\n      return this._cache[name];\n    }\n  };\n  const localColorSpaceCache = {};\n  const cacheKey = \"testCache\";\n  await partialEvaluator.buildPaintImageXObject({\n    resources: new (await import(\"../../src/core/primitives.js\")).Dict(),\n    image: dummyImage,\n    isInline: false,\n    operatorList,\n    cacheKey,\n    localImageCache,\n    localColorSpaceCache,\n  });\n  const cacheData = localImageCache._cache[cacheKey];\n  if (!cacheData || !cacheData.objId) {\n    throw new Error(\"Missing objId in cache data\");\n  }\n  if (!operatorList.dependencies.includes(cacheData.objId)) {\n    throw new Error(\"Dependency was not added with the correct objId\");\n  }\n});",
    "i1_gpt-4o": "it(\"should add dependency with objId for cached paintImageXObject\", async () => {\n  const idFactory = createIdFactory();\n  const xref = new XRefMock();\n  const handler = { sendWithPromise: () => Promise.resolve(null) };\n  const options = {\n    maxImageSize: 1000,\n    isOffscreenCanvasSupported: false,\n    canvasMaxAreaInBytes: -1,\n    ignoreErrors: true,\n  };\n  const globalImageCache = {\n    shouldCache: () => false,\n    hasDecodeFailed: () => false,\n    setData() {},\n    addByteSize() {}\n  };\n  const partialEvaluator = new PartialEvaluator({\n    xref,\n    handler,\n    pageIndex: 0,\n    idFactory,\n    fontCache: {},\n    builtInCMapCache: {},\n    standardFontDataCache: {},\n    globalImageCache,\n    systemFontCache: {},\n    options,\n  });\n  // Stub _sendImgData so that buildPaintImageXObject can complete.\n  partialEvaluator._sendImgData = () => Promise.resolve();\n  // Create a dummy dictionary with required keys.\n  const dummyDict = new (await import(\"../../src/core/primitives.js\")).Dict();\n  dummyDict.set(\"W\", 10);\n  dummyDict.set(\"H\", 10);\n  // Set a fake objId to simulate an image reference.\n  dummyDict.objId = \"testImgRef\";\n  // Create a minimal dummy image with getBytes.\n  const dummyImage = {\n    dict: dummyDict,\n    getBytes: (n) => new Uint8Array(n),\n  };\n  // Override PDFImage.buildImage to simulate successful image decoding.\n  const { PDFImage } = await import(\"../../src/core/image.js\");\n  PDFImage.buildImage = (params) => {\n    return Promise.resolve({\n      createImageData: () =>\n        Promise.resolve({\n          width: params.image.dict.get(\"W\"),\n          height: params.image.dict.get(\"H\"),\n          data: new Uint8Array(4 * params.image.dict.get(\"W\") * params.image.dict.get(\"H\")),\n          bitmap: false,\n        }),\n    });\n  };\n  // Create a minimal operator list that records dependencies.\n  const operatorList = new OperatorList();\n  const originalAddDependency = operatorList.addDependency.bind(operatorList);\n  operatorList.dependencies = [];\n  operatorList.addDependency = (dep) => {\n    operatorList.dependencies.push(dep);\n    originalAddDependency(dep);\n  };\n  // Setup a simple localImageCache.\n  const localImageCache = {\n    _cache: {},\n    set(key, ref, data) {\n      this._cache[key] = data;\n    },\n    getByName(name) {\n      return this._cache[name];\n    }\n  };\n  const localColorSpaceCache = {};\n  const cacheKey = \"testCache\";\n  await partialEvaluator.buildPaintImageXObject({\n    resources: new (await import(\"../../src/core/primitives.js\")).Dict(),\n    image: dummyImage,\n    isInline: false,\n    operatorList,\n    cacheKey,\n    localImageCache,\n    localColorSpaceCache,\n  });\n  const cacheData = localImageCache._cache[cacheKey];\n  if (!cacheData || !cacheData.objId) {\n    throw new Error(\"Missing objId in cache data\");\n  }\n  if (!operatorList.dependencies.includes(cacheData.objId)) {\n    throw new Error(\"Dependency was not added with the correct objId\");\n  }\n});",
    "i1_llama-3.3-70b-versatile": "it(\"should add dependency with objId for cached paintImageXObject\", async () => {\n  const idFactory = createIdFactory();\n  const xref = new XRefMock();\n  const handler = { sendWithPromise: () => Promise.resolve(null) };\n  const options = {\n    maxImageSize: 1000,\n    isOffscreenCanvasSupported: false,\n    canvasMaxAreaInBytes: -1,\n    ignoreErrors: true,\n  };\n  const globalImageCache = {\n    shouldCache: () => false,\n    hasDecodeFailed: () => false,\n    setData() {},\n    addByteSize() {}\n  };\n  const partialEvaluator = new PartialEvaluator({\n    xref,\n    handler,\n    pageIndex: 0,\n    idFactory,\n    fontCache: {},\n    builtInCMapCache: {},\n    standardFontDataCache: {},\n    globalImageCache,\n    systemFontCache: {},\n    options,\n  });\n  // Stub _sendImgData so that buildPaintImageXObject can complete.\n  partialEvaluator._sendImgData = () => Promise.resolve();\n  // Create a dummy dictionary with required keys.\n  const dummyDict = new (await import(\"../../src/core/primitives.js\")).Dict();\n  dummyDict.set(\"W\", 10);\n  dummyDict.set(\"H\", 10);\n  // Set a fake objId to simulate an image reference.\n  dummyDict.objId = \"testImgRef\";\n  // Create a minimal dummy image with getBytes.\n  const dummyImage = {\n    dict: dummyDict,\n    getBytes: (n) => new Uint8Array(n),\n  };\n  // Override PDFImage.buildImage to simulate successful image decoding.\n  const { PDFImage } = await import(\"../../src/core/image.js\");\n  PDFImage.buildImage = (params) => {\n    return Promise.resolve({\n      createImageData: () =>\n        Promise.resolve({\n          width: params.image.dict.get(\"W\"),\n          height: params.image.dict.get(\"H\"),\n          data: new Uint8Array(4 * params.image.dict.get(\"W\") * params.image.dict.get(\"H\")),\n          bitmap: false,\n        }),\n    });\n  };\n  // Create a minimal operator list that records dependencies.\n  const operatorList = new OperatorList();\n  const originalAddDependency = operatorList.addDependency.bind(operatorList);\n  operatorList.dependencies = [];\n  operatorList.addDependency = (dep) => {\n    operatorList.dependencies.push(dep);\n    originalAddDependency(dep);\n  };\n  // Setup a simple localImageCache.\n  const localImageCache = {\n    _cache: {},\n    set(key, ref, data) {\n      this._cache[key] = data;\n    },\n    getByName(name) {\n      return this._cache[name];\n    }\n  };\n  const localColorSpaceCache = {};\n  const cacheKey = \"testCache\";\n  await partialEvaluator.buildPaintImageXObject({\n    resources: new (await import(\"../../src/core/primitives.js\")).Dict(),\n    image: dummyImage,\n    isInline: false,\n    operatorList,\n    cacheKey,\n    localImageCache,\n    localColorSpaceCache,\n  });\n  const cacheData = localImageCache._cache[cacheKey];\n  if (!cacheData || !cacheData.objId) {\n    throw new Error(\"Missing objId in cache data\");\n  }\n  if (!operatorList.dependencies.includes(cacheData.objId)) {\n    throw new Error(\"Dependency was not added with the correct objId\");\n  }\n});",
    "i1_MOCK": "it(\"should add dependency with objId for cached paintImageXObject\", async () => {\n  const idFactory = createIdFactory();\n  const xref = new XRefMock();\n  const handler = { sendWithPromise: () => Promise.resolve(null) };\n  const options = {\n    maxImageSize: 1000,\n    isOffscreenCanvasSupported: false,\n    canvasMaxAreaInBytes: -1,\n    ignoreErrors: true,\n  };\n  const globalImageCache = {\n    shouldCache: () => false,\n    hasDecodeFailed: () => false,\n    setData() {},\n    addByteSize() {}\n  };\n  const partialEvaluator = new PartialEvaluator({\n    xref,\n    handler,\n    pageIndex: 0,\n    idFactory,\n    fontCache: {},\n    builtInCMapCache: {},\n    standardFontDataCache: {},\n    globalImageCache,\n    systemFontCache: {},\n    options,\n  });\n  // Stub _sendImgData so that buildPaintImageXObject can complete.\n  partialEvaluator._sendImgData = () => Promise.resolve();\n  // Create a dummy dictionary with required keys.\n  const dummyDict = new (await import(\"../../src/core/primitives.js\")).Dict();\n  dummyDict.set(\"W\", 10);\n  dummyDict.set(\"H\", 10);\n  // Set a fake objId to simulate an image reference.\n  dummyDict.objId = \"testImgRef\";\n  // Create a minimal dummy image with getBytes.\n  const dummyImage = {\n    dict: dummyDict,\n    getBytes: (n) => new Uint8Array(n),\n  };\n  // Override PDFImage.buildImage to simulate successful image decoding.\n  const { PDFImage } = await import(\"../../src/core/image.js\");\n  PDFImage.buildImage = (params) => {\n    return Promise.resolve({\n      createImageData: () =>\n        Promise.resolve({\n          width: params.image.dict.get(\"W\"),\n          height: params.image.dict.get(\"H\"),\n          data: new Uint8Array(4 * params.image.dict.get(\"W\") * params.image.dict.get(\"H\")),\n          bitmap: false,\n        }),\n    });\n  };\n  // Create a minimal operator list that records dependencies.\n  const operatorList = new OperatorList();\n  const originalAddDependency = operatorList.addDependency.bind(operatorList);\n  operatorList.dependencies = [];\n  operatorList.addDependency = (dep) => {\n    operatorList.dependencies.push(dep);\n    originalAddDependency(dep);\n  };\n  // Setup a simple localImageCache.\n  const localImageCache = {\n    _cache: {},\n    set(key, ref, data) {\n      this._cache[key] = data;\n    },\n    getByName(name) {\n      return this._cache[name];\n    }\n  };\n  const localColorSpaceCache = {};\n  const cacheKey = \"testCache\";\n  await partialEvaluator.buildPaintImageXObject({\n    resources: new (await import(\"../../src/core/primitives.js\")).Dict(),\n    image: dummyImage,\n    isInline: false,\n    operatorList,\n    cacheKey,\n    localImageCache,\n    localColorSpaceCache,\n  });\n  const cacheData = localImageCache._cache[cacheKey];\n  if (!cacheData || !cacheData.objId) {\n    throw new Error(\"Missing objId in cache data\");\n  }\n  if (!operatorList.dependencies.includes(cacheData.objId)) {\n    throw new Error(\"Dependency was not added with the correct objId\");\n  }\n});",
    "i2_deepseek-r1-distill-llama-70b": "it(\"should add dependency with objId for cached paintImageXObject\", async () => {\n  const idFactory = createIdFactory();\n  const xref = new XRefMock();\n  const handler = { sendWithPromise: () => Promise.resolve(null) };\n  const options = {\n    maxImageSize: 1000,\n    isOffscreenCanvasSupported: false,\n    canvasMaxAreaInBytes: -1,\n    ignoreErrors: true,\n  };\n  const globalImageCache = {\n    shouldCache: () => false,\n    hasDecodeFailed: () => false,\n    setData() {},\n    addByteSize() {}\n  };\n  const partialEvaluator = new PartialEvaluator({\n    xref,\n    handler,\n    pageIndex: 0,\n    idFactory,\n    fontCache: {},\n    builtInCMapCache: {},\n    standardFontDataCache: {},\n    globalImageCache,\n    systemFontCache: {},\n    options,\n  });\n  // Stub _sendImgData so that buildPaintImageXObject can complete.\n  partialEvaluator._sendImgData = () => Promise.resolve();\n  // Create a dummy dictionary with required keys.\n  const dummyDict = new (await import(\"../../src/core/primitives.js\")).Dict();\n  dummyDict.set(\"W\", 10);\n  dummyDict.set(\"H\", 10);\n  // Set a fake objId to simulate an image reference.\n  dummyDict.objId = \"testImgRef\";\n  // Create a minimal dummy image with getBytes.\n  const dummyImage = {\n    dict: dummyDict,\n    getBytes: (n) => new Uint8Array(n),\n  };\n  // Override PDFImage.buildImage to simulate successful image decoding.\n  const { PDFImage } = await import(\"../../src/core/image.js\");\n  PDFImage.buildImage = (params) => {\n    return Promise.resolve({\n      createImageData: () =>\n        Promise.resolve({\n          width: params.image.dict.get(\"W\"),\n          height: params.image.dict.get(\"H\"),\n          data: new Uint8Array(4 * params.image.dict.get(\"W\") * params.image.dict.get(\"H\")),\n          bitmap: false,\n        }),\n    });\n  };\n  // Create a minimal operator list that records dependencies.\n  const operatorList = new OperatorList();\n  const originalAddDependency = operatorList.addDependency.bind(operatorList);\n  operatorList.dependencies = [];\n  operatorList.addDependency = (dep) => {\n    operatorList.dependencies.push(dep);\n    originalAddDependency(dep);\n  };\n  // Setup a simple localImageCache.\n  const localImageCache = {\n    _cache: {},\n    set(key, ref, data) {\n      this._cache[key] = data;\n    },\n    getByName(name) {\n      return this._cache[name];\n    }\n  };\n  const localColorSpaceCache = {};\n  const cacheKey = \"testCache\";\n  await partialEvaluator.buildPaintImageXObject({\n    resources: new (await import(\"../../src/core/primitives.js\")).Dict(),\n    image: dummyImage,\n    isInline: false,\n    operatorList,\n    cacheKey,\n    localImageCache,\n    localColorSpaceCache,\n  });\n  const cacheData = localImageCache._cache[cacheKey];\n  if (!cacheData || !cacheData.objId) {\n    throw new Error(\"Missing objId in cache data\");\n  }\n  if (!operatorList.dependencies.includes(cacheData.objId)) {\n    throw new Error(\"Dependency was not added with the correct objId\");\n  }\n});",
    "i2_gpt-4o": "it(\"should add dependency with objId for cached paintImageXObject\", async () => {\n  const idFactory = createIdFactory();\n  const xref = new XRefMock();\n  const handler = { sendWithPromise: () => Promise.resolve(null) };\n  const options = {\n    maxImageSize: 1000,\n    isOffscreenCanvasSupported: false,\n    canvasMaxAreaInBytes: -1,\n    ignoreErrors: true,\n  };\n  const globalImageCache = {\n    shouldCache: () => false,\n    hasDecodeFailed: () => false,\n    setData() {},\n    addByteSize() {}\n  };\n  const partialEvaluator = new PartialEvaluator({\n    xref,\n    handler,\n    pageIndex: 0,\n    idFactory,\n    fontCache: {},\n    builtInCMapCache: {},\n    standardFontDataCache: {},\n    globalImageCache,\n    systemFontCache: {},\n    options,\n  });\n  // Stub _sendImgData so that buildPaintImageXObject can complete.\n  partialEvaluator._sendImgData = () => Promise.resolve();\n  // Create a dummy dictionary with required keys.\n  const dummyDict = new (await import(\"../../src/core/primitives.js\")).Dict();\n  dummyDict.set(\"W\", 10);\n  dummyDict.set(\"H\", 10);\n  // Set a fake objId to simulate an image reference.\n  dummyDict.objId = \"testImgRef\";\n  // Create a minimal dummy image with getBytes.\n  const dummyImage = {\n    dict: dummyDict,\n    getBytes: (n) => new Uint8Array(n),\n  };\n  // Override PDFImage.buildImage to simulate successful image decoding.\n  const { PDFImage } = await import(\"../../src/core/image.js\");\n  PDFImage.buildImage = (params) => {\n    return Promise.resolve({\n      createImageData: () =>\n        Promise.resolve({\n          width: params.image.dict.get(\"W\"),\n          height: params.image.dict.get(\"H\"),\n          data: new Uint8Array(4 * params.image.dict.get(\"W\") * params.image.dict.get(\"H\")),\n          bitmap: false,\n        }),\n    });\n  };\n  // Create a minimal operator list that records dependencies.\n  const operatorList = new OperatorList();\n  const originalAddDependency = operatorList.addDependency.bind(operatorList);\n  operatorList.dependencies = [];\n  operatorList.addDependency = (dep) => {\n    operatorList.dependencies.push(dep);\n    originalAddDependency(dep);\n  };\n  // Setup a simple localImageCache.\n  const localImageCache = {\n    _cache: {},\n    set(key, ref, data) {\n      this._cache[key] = data;\n    },\n    getByName(name) {\n      return this._cache[name];\n    }\n  };\n  const localColorSpaceCache = {};\n  const cacheKey = \"testCache\";\n  await partialEvaluator.buildPaintImageXObject({\n    resources: new (await import(\"../../src/core/primitives.js\")).Dict(),\n    image: dummyImage,\n    isInline: false,\n    operatorList,\n    cacheKey,\n    localImageCache,\n    localColorSpaceCache,\n  });\n  const cacheData = localImageCache._cache[cacheKey];\n  if (!cacheData || !cacheData.objId) {\n    throw new Error(\"Missing objId in cache data\");\n  }\n  if (!operatorList.dependencies.includes(cacheData.objId)) {\n    throw new Error(\"Dependency was not added with the correct objId\");\n  }\n});",
    "i2_llama-3.3-70b-versatile": "it(\"should add dependency with objId for cached paintImageXObject\", async () => {\n  const idFactory = createIdFactory();\n  const xref = new XRefMock();\n  const handler = { sendWithPromise: () => Promise.resolve(null) };\n  const options = {\n    maxImageSize: 1000,\n    isOffscreenCanvasSupported: false,\n    canvasMaxAreaInBytes: -1,\n    ignoreErrors: true,\n  };\n  const globalImageCache = {\n    shouldCache: () => false,\n    hasDecodeFailed: () => false,\n    setData() {},\n    addByteSize() {}\n  };\n  const partialEvaluator = new PartialEvaluator({\n    xref,\n    handler,\n    pageIndex: 0,\n    idFactory,\n    fontCache: {},\n    builtInCMapCache: {},\n    standardFontDataCache: {},\n    globalImageCache,\n    systemFontCache: {},\n    options,\n  });\n  // Stub _sendImgData so that buildPaintImageXObject can complete.\n  partialEvaluator._sendImgData = () => Promise.resolve();\n  // Create a dummy dictionary with required keys.\n  const dummyDict = new (await import(\"../../src/core/primitives.js\")).Dict();\n  dummyDict.set(\"W\", 10);\n  dummyDict.set(\"H\", 10);\n  // Set a fake objId to simulate an image reference.\n  dummyDict.objId = \"testImgRef\";\n  // Create a minimal dummy image with getBytes.\n  const dummyImage = {\n    dict: dummyDict,\n    getBytes: (n) => new Uint8Array(n),\n  };\n  // Override PDFImage.buildImage to simulate successful image decoding.\n  const { PDFImage } = await import(\"../../src/core/image.js\");\n  PDFImage.buildImage = (params) => {\n    return Promise.resolve({\n      createImageData: () =>\n        Promise.resolve({\n          width: params.image.dict.get(\"W\"),\n          height: params.image.dict.get(\"H\"),\n          data: new Uint8Array(4 * params.image.dict.get(\"W\") * params.image.dict.get(\"H\")),\n          bitmap: false,\n        }),\n    });\n  };\n  // Create a minimal operator list that records dependencies.\n  const operatorList = new OperatorList();\n  const originalAddDependency = operatorList.addDependency.bind(operatorList);\n  operatorList.dependencies = [];\n  operatorList.addDependency = (dep) => {\n    operatorList.dependencies.push(dep);\n    originalAddDependency(dep);\n  };\n  // Setup a simple localImageCache.\n  const localImageCache = {\n    _cache: {},\n    set(key, ref, data) {\n      this._cache[key] = data;\n    },\n    getByName(name) {\n      return this._cache[name];\n    }\n  };\n  const localColorSpaceCache = {};\n  const cacheKey = \"testCache\";\n  await partialEvaluator.buildPaintImageXObject({\n    resources: new (await import(\"../../src/core/primitives.js\")).Dict(),\n    image: dummyImage,\n    isInline: false,\n    operatorList,\n    cacheKey,\n    localImageCache,\n    localColorSpaceCache,\n  });\n  const cacheData = localImageCache._cache[cacheKey];\n  if (!cacheData || !cacheData.objId) {\n    throw new Error(\"Missing objId in cache data\");\n  }\n  if (!operatorList.dependencies.includes(cacheData.objId)) {\n    throw new Error(\"Dependency was not added with the correct objId\");\n  }\n});",
    "i3_deepseek-r1-distill-llama-70b": "it(\"should add dependency with objId for cached paintImageXObject\", async () => {\n  const idFactory = createIdFactory();\n  const xref = new XRefMock();\n  const handler = { sendWithPromise: () => Promise.resolve(null) };\n  const options = {\n    maxImageSize: 1000,\n    isOffscreenCanvasSupported: false,\n    canvasMaxAreaInBytes: -1,\n    ignoreErrors: true,\n  };\n  const globalImageCache = {\n    shouldCache: () => false,\n    hasDecodeFailed: () => false,\n    setData() {},\n    addByteSize() {}\n  };\n  const partialEvaluator = new PartialEvaluator({\n    xref,\n    handler,\n    pageIndex: 0,\n    idFactory,\n    fontCache: {},\n    builtInCMapCache: {},\n    standardFontDataCache: {},\n    globalImageCache,\n    systemFontCache: {},\n    options,\n  });\n  // Stub _sendImgData so that buildPaintImageXObject can complete.\n  partialEvaluator._sendImgData = () => Promise.resolve();\n  // Create a dummy dictionary with required keys.\n  const dummyDict = new (await import(\"../../src/core/primitives.js\")).Dict();\n  dummyDict.set(\"W\", 10);\n  dummyDict.set(\"H\", 10);\n  // Set a fake objId to simulate an image reference.\n  dummyDict.objId = \"testImgRef\";\n  // Create a minimal dummy image with getBytes.\n  const dummyImage = {\n    dict: dummyDict,\n    getBytes: (n) => new Uint8Array(n),\n  };\n  // Override PDFImage.buildImage to simulate successful image decoding.\n  const { PDFImage } = await import(\"../../src/core/image.js\");\n  PDFImage.buildImage = (params) => {\n    return Promise.resolve({\n      createImageData: () =>\n        Promise.resolve({\n          width: params.image.dict.get(\"W\"),\n          height: params.image.dict.get(\"H\"),\n          data: new Uint8Array(4 * params.image.dict.get(\"W\") * params.image.dict.get(\"H\")),\n          bitmap: false,\n        }),\n    });\n  };\n  // Create a minimal operator list that records dependencies.\n  const operatorList = new OperatorList();\n  const originalAddDependency = operatorList.addDependency.bind(operatorList);\n  operatorList.dependencies = [];\n  operatorList.addDependency = (dep) => {\n    operatorList.dependencies.push(dep);\n    originalAddDependency(dep);\n  };\n  // Setup a simple localImageCache.\n  const localImageCache = {\n    _cache: {},\n    set(key, ref, data) {\n      this._cache[key] = data;\n    },\n    getByName(name) {\n      return this._cache[name];\n    }\n  };\n  const localColorSpaceCache = {};\n  const cacheKey = \"testCache\";\n  await partialEvaluator.buildPaintImageXObject({\n    resources: new (await import(\"../../src/core/primitives.js\")).Dict(),\n    image: dummyImage,\n    isInline: false,\n    operatorList,\n    cacheKey,\n    localImageCache,\n    localColorSpaceCache,\n  });\n  const cacheData = localImageCache._cache[cacheKey];\n  if (!cacheData || !cacheData.objId) {\n    throw new Error(\"Missing objId in cache data\");\n  }\n  if (!operatorList.dependencies.includes(cacheData.objId)) {\n    throw new Error(\"Dependency was not added with the correct objId\");\n  }\n});",
    "i3_gpt-4o": "it(\"should add dependency with objId for cached paintImageXObject\", async () => {\n  const idFactory = createIdFactory();\n  const xref = new XRefMock();\n  const handler = { sendWithPromise: () => Promise.resolve(null) };\n  const options = {\n    maxImageSize: 1000,\n    isOffscreenCanvasSupported: false,\n    canvasMaxAreaInBytes: -1,\n    ignoreErrors: true,\n  };\n  const globalImageCache = {\n    shouldCache: () => false,\n    hasDecodeFailed: () => false,\n    setData() {},\n    addByteSize() {}\n  };\n  const partialEvaluator = new PartialEvaluator({\n    xref,\n    handler,\n    pageIndex: 0,\n    idFactory,\n    fontCache: {},\n    builtInCMapCache: {},\n    standardFontDataCache: {},\n    globalImageCache,\n    systemFontCache: {},\n    options,\n  });\n  // Stub _sendImgData so that buildPaintImageXObject can complete.\n  partialEvaluator._sendImgData = () => Promise.resolve();\n  // Create a dummy dictionary with required keys.\n  const dummyDict = new (await import(\"../../src/core/primitives.js\")).Dict();\n  dummyDict.set(\"W\", 10);\n  dummyDict.set(\"H\", 10);\n  // Set a fake objId to simulate an image reference.\n  dummyDict.objId = \"testImgRef\";\n  // Create a minimal dummy image with getBytes.\n  const dummyImage = {\n    dict: dummyDict,\n    getBytes: (n) => new Uint8Array(n),\n  };\n  // Override PDFImage.buildImage to simulate successful image decoding.\n  const { PDFImage } = await import(\"../../src/core/image.js\");\n  PDFImage.buildImage = (params) => {\n    return Promise.resolve({\n      createImageData: () =>\n        Promise.resolve({\n          width: params.image.dict.get(\"W\"),\n          height: params.image.dict.get(\"H\"),\n          data: new Uint8Array(4 * params.image.dict.get(\"W\") * params.image.dict.get(\"H\")),\n          bitmap: false,\n        }),\n    });\n  };\n  // Create a minimal operator list that records dependencies.\n  const operatorList = new OperatorList();\n  const originalAddDependency = operatorList.addDependency.bind(operatorList);\n  operatorList.dependencies = [];\n  operatorList.addDependency = (dep) => {\n    operatorList.dependencies.push(dep);\n    originalAddDependency(dep);\n  };\n  // Setup a simple localImageCache.\n  const localImageCache = {\n    _cache: {},\n    set(key, ref, data) {\n      this._cache[key] = data;\n    },\n    getByName(name) {\n      return this._cache[name];\n    }\n  };\n  const localColorSpaceCache = {};\n  const cacheKey = \"testCache\";\n  await partialEvaluator.buildPaintImageXObject({\n    resources: new (await import(\"../../src/core/primitives.js\")).Dict(),\n    image: dummyImage,\n    isInline: false,\n    operatorList,\n    cacheKey,\n    localImageCache,\n    localColorSpaceCache,\n  });\n  const cacheData = localImageCache._cache[cacheKey];\n  if (!cacheData || !cacheData.objId) {\n    throw new Error(\"Missing objId in cache data\");\n  }\n  if (!operatorList.dependencies.includes(cacheData.objId)) {\n    throw new Error(\"Dependency was not added with the correct objId\");\n  }\n});",
    "i3_llama-3.3-70b-versatile": "it(\"should add dependency with objId for cached paintImageXObject\", async () => {\n  const idFactory = createIdFactory();\n  const xref = new XRefMock();\n  const handler = { sendWithPromise: () => Promise.resolve(null) };\n  const options = {\n    maxImageSize: 1000,\n    isOffscreenCanvasSupported: false,\n    canvasMaxAreaInBytes: -1,\n    ignoreErrors: true,\n  };\n  const globalImageCache = {\n    shouldCache: () => false,\n    hasDecodeFailed: () => false,\n    setData() {},\n    addByteSize() {}\n  };\n  const partialEvaluator = new PartialEvaluator({\n    xref,\n    handler,\n    pageIndex: 0,\n    idFactory,\n    fontCache: {},\n    builtInCMapCache: {},\n    standardFontDataCache: {},\n    globalImageCache,\n    systemFontCache: {},\n    options,\n  });\n  // Stub _sendImgData so that buildPaintImageXObject can complete.\n  partialEvaluator._sendImgData = () => Promise.resolve();\n  // Create a dummy dictionary with required keys.\n  const dummyDict = new (await import(\"../../src/core/primitives.js\")).Dict();\n  dummyDict.set(\"W\", 10);\n  dummyDict.set(\"H\", 10);\n  // Set a fake objId to simulate an image reference.\n  dummyDict.objId = \"testImgRef\";\n  // Create a minimal dummy image with getBytes.\n  const dummyImage = {\n    dict: dummyDict,\n    getBytes: (n) => new Uint8Array(n),\n  };\n  // Override PDFImage.buildImage to simulate successful image decoding.\n  const { PDFImage } = await import(\"../../src/core/image.js\");\n  PDFImage.buildImage = (params) => {\n    return Promise.resolve({\n      createImageData: () =>\n        Promise.resolve({\n          width: params.image.dict.get(\"W\"),\n          height: params.image.dict.get(\"H\"),\n          data: new Uint8Array(4 * params.image.dict.get(\"W\") * params.image.dict.get(\"H\")),\n          bitmap: false,\n        }),\n    });\n  };\n  // Create a minimal operator list that records dependencies.\n  const operatorList = new OperatorList();\n  const originalAddDependency = operatorList.addDependency.bind(operatorList);\n  operatorList.dependencies = [];\n  operatorList.addDependency = (dep) => {\n    operatorList.dependencies.push(dep);\n    originalAddDependency(dep);\n  };\n  // Setup a simple localImageCache.\n  const localImageCache = {\n    _cache: {},\n    set(key, ref, data) {\n      this._cache[key] = data;\n    },\n    getByName(name) {\n      return this._cache[name];\n    }\n  };\n  const localColorSpaceCache = {};\n  const cacheKey = \"testCache\";\n  await partialEvaluator.buildPaintImageXObject({\n    resources: new (await import(\"../../src/core/primitives.js\")).Dict(),\n    image: dummyImage,\n    isInline: false,\n    operatorList,\n    cacheKey,\n    localImageCache,\n    localColorSpaceCache,\n  });\n  const cacheData = localImageCache._cache[cacheKey];\n  if (!cacheData || !cacheData.objId) {\n    throw new Error(\"Missing objId in cache data\");\n  }\n  if (!operatorList.dependencies.includes(cacheData.objId)) {\n    throw new Error(\"Dependency was not added with the correct objId\");\n  }\n});",
    "i4_deepseek-r1-distill-llama-70b": "it(\"should add dependency with objId for cached paintImageXObject\", async () => {\n  const idFactory = createIdFactory();\n  const xref = new XRefMock();\n  const handler = { sendWithPromise: () => Promise.resolve(null) };\n  const options = {\n    maxImageSize: 1000,\n    isOffscreenCanvasSupported: false,\n    canvasMaxAreaInBytes: -1,\n    ignoreErrors: true,\n  };\n  const globalImageCache = {\n    shouldCache: () => false,\n    hasDecodeFailed: () => false,\n    setData() {},\n    addByteSize() {}\n  };\n  const partialEvaluator = new PartialEvaluator({\n    xref,\n    handler,\n    pageIndex: 0,\n    idFactory,\n    fontCache: {},\n    builtInCMapCache: {},\n    standardFontDataCache: {},\n    globalImageCache,\n    systemFontCache: {},\n    options,\n  });\n  // Stub _sendImgData so that buildPaintImageXObject can complete.\n  partialEvaluator._sendImgData = () => Promise.resolve();\n  // Create a dummy dictionary with required keys.\n  const dummyDict = new (await import(\"../../src/core/primitives.js\")).Dict();\n  dummyDict.set(\"W\", 10);\n  dummyDict.set(\"H\", 10);\n  // Set a fake objId to simulate an image reference.\n  dummyDict.objId = \"testImgRef\";\n  // Create a minimal dummy image with getBytes.\n  const dummyImage = {\n    dict: dummyDict,\n    getBytes: (n) => new Uint8Array(n),\n  };\n  // Override PDFImage.buildImage to simulate successful image decoding.\n  const { PDFImage } = await import(\"../../src/core/image.js\");\n  PDFImage.buildImage = (params) => {\n    return Promise.resolve({\n      createImageData: () =>\n        Promise.resolve({\n          width: params.image.dict.get(\"W\"),\n          height: params.image.dict.get(\"H\"),\n          data: new Uint8Array(4 * params.image.dict.get(\"W\") * params.image.dict.get(\"H\")),\n          bitmap: false,\n        }),\n    });\n  };\n  // Create a minimal operator list that records dependencies.\n  const operatorList = new OperatorList();\n  const originalAddDependency = operatorList.addDependency.bind(operatorList);\n  operatorList.dependencies = [];\n  operatorList.addDependency = (dep) => {\n    operatorList.dependencies.push(dep);\n    originalAddDependency(dep);\n  };\n  // Setup a simple localImageCache.\n  const localImageCache = {\n    _cache: {},\n    set(key, ref, data) {\n      this._cache[key] = data;\n    },\n    getByName(name) {\n      return this._cache[name];\n    }\n  };\n  const localColorSpaceCache = {};\n  const cacheKey = \"testCache\";\n  await partialEvaluator.buildPaintImageXObject({\n    resources: new (await import(\"../../src/core/primitives.js\")).Dict(),\n    image: dummyImage,\n    isInline: false,\n    operatorList,\n    cacheKey,\n    localImageCache,\n    localColorSpaceCache,\n  });\n  const cacheData = localImageCache._cache[cacheKey];\n  if (!cacheData || !cacheData.objId) {\n    throw new Error(\"Missing objId in cache data\");\n  }\n  if (!operatorList.dependencies.includes(cacheData.objId)) {\n    throw new Error(\"Dependency was not added with the correct objId\");\n  }\n});",
    "i4_gpt-4o": "it(\"should add dependency with objId for cached paintImageXObject\", async () => {\n  const idFactory = createIdFactory();\n  const xref = new XRefMock();\n  const handler = { sendWithPromise: () => Promise.resolve(null) };\n  const options = {\n    maxImageSize: 1000,\n    isOffscreenCanvasSupported: false,\n    canvasMaxAreaInBytes: -1,\n    ignoreErrors: true,\n  };\n  const globalImageCache = {\n    shouldCache: () => false,\n    hasDecodeFailed: () => false,\n    setData() {},\n    addByteSize() {}\n  };\n  const partialEvaluator = new PartialEvaluator({\n    xref,\n    handler,\n    pageIndex: 0,\n    idFactory,\n    fontCache: {},\n    builtInCMapCache: {},\n    standardFontDataCache: {},\n    globalImageCache,\n    systemFontCache: {},\n    options,\n  });\n  // Stub _sendImgData so that buildPaintImageXObject can complete.\n  partialEvaluator._sendImgData = () => Promise.resolve();\n  // Create a dummy dictionary with required keys.\n  const dummyDict = new (await import(\"../../src/core/primitives.js\")).Dict();\n  dummyDict.set(\"W\", 10);\n  dummyDict.set(\"H\", 10);\n  // Set a fake objId to simulate an image reference.\n  dummyDict.objId = \"testImgRef\";\n  // Create a minimal dummy image with getBytes.\n  const dummyImage = {\n    dict: dummyDict,\n    getBytes: (n) => new Uint8Array(n),\n  };\n  // Override PDFImage.buildImage to simulate successful image decoding.\n  const { PDFImage } = await import(\"../../src/core/image.js\");\n  PDFImage.buildImage = (params) => {\n    return Promise.resolve({\n      createImageData: () =>\n        Promise.resolve({\n          width: params.image.dict.get(\"W\"),\n          height: params.image.dict.get(\"H\"),\n          data: new Uint8Array(4 * params.image.dict.get(\"W\") * params.image.dict.get(\"H\")),\n          bitmap: false,\n        }),\n    });\n  };\n  // Create a minimal operator list that records dependencies.\n  const operatorList = new OperatorList();\n  const originalAddDependency = operatorList.addDependency.bind(operatorList);\n  operatorList.dependencies = [];\n  operatorList.addDependency = (dep) => {\n    operatorList.dependencies.push(dep);\n    originalAddDependency(dep);\n  };\n  // Setup a simple localImageCache.\n  const localImageCache = {\n    _cache: {},\n    set(key, ref, data) {\n      this._cache[key] = data;\n    },\n    getByName(name) {\n      return this._cache[name];\n    }\n  };\n  const localColorSpaceCache = {};\n  const cacheKey = \"testCache\";\n  await partialEvaluator.buildPaintImageXObject({\n    resources: new (await import(\"../../src/core/primitives.js\")).Dict(),\n    image: dummyImage,\n    isInline: false,\n    operatorList,\n    cacheKey,\n    localImageCache,\n    localColorSpaceCache,\n  });\n  const cacheData = localImageCache._cache[cacheKey];\n  if (!cacheData || !cacheData.objId) {\n    throw new Error(\"Missing objId in cache data\");\n  }\n  if (!operatorList.dependencies.includes(cacheData.objId)) {\n    throw new Error(\"Dependency was not added with the correct objId\");\n  }\n});",
    "i4_llama-3.3-70b-versatile": "it(\"should add dependency with objId for cached paintImageXObject\", async () => {\n  const idFactory = createIdFactory();\n  const xref = new XRefMock();\n  const handler = { sendWithPromise: () => Promise.resolve(null) };\n  const options = {\n    maxImageSize: 1000,\n    isOffscreenCanvasSupported: false,\n    canvasMaxAreaInBytes: -1,\n    ignoreErrors: true,\n  };\n  const globalImageCache = {\n    shouldCache: () => false,\n    hasDecodeFailed: () => false,\n    setData() {},\n    addByteSize() {}\n  };\n  const partialEvaluator = new PartialEvaluator({\n    xref,\n    handler,\n    pageIndex: 0,\n    idFactory,\n    fontCache: {},\n    builtInCMapCache: {},\n    standardFontDataCache: {},\n    globalImageCache,\n    systemFontCache: {},\n    options,\n  });\n  // Stub _sendImgData so that buildPaintImageXObject can complete.\n  partialEvaluator._sendImgData = () => Promise.resolve();\n  // Create a dummy dictionary with required keys.\n  const dummyDict = new (await import(\"../../src/core/primitives.js\")).Dict();\n  dummyDict.set(\"W\", 10);\n  dummyDict.set(\"H\", 10);\n  // Set a fake objId to simulate an image reference.\n  dummyDict.objId = \"testImgRef\";\n  // Create a minimal dummy image with getBytes.\n  const dummyImage = {\n    dict: dummyDict,\n    getBytes: (n) => new Uint8Array(n),\n  };\n  // Override PDFImage.buildImage to simulate successful image decoding.\n  const { PDFImage } = await import(\"../../src/core/image.js\");\n  PDFImage.buildImage = (params) => {\n    return Promise.resolve({\n      createImageData: () =>\n        Promise.resolve({\n          width: params.image.dict.get(\"W\"),\n          height: params.image.dict.get(\"H\"),\n          data: new Uint8Array(4 * params.image.dict.get(\"W\") * params.image.dict.get(\"H\")),\n          bitmap: false,\n        }),\n    });\n  };\n  // Create a minimal operator list that records dependencies.\n  const operatorList = new OperatorList();\n  const originalAddDependency = operatorList.addDependency.bind(operatorList);\n  operatorList.dependencies = [];\n  operatorList.addDependency = (dep) => {\n    operatorList.dependencies.push(dep);\n    originalAddDependency(dep);\n  };\n  // Setup a simple localImageCache.\n  const localImageCache = {\n    _cache: {},\n    set(key, ref, data) {\n      this._cache[key] = data;\n    },\n    getByName(name) {\n      return this._cache[name];\n    }\n  };\n  const localColorSpaceCache = {};\n  const cacheKey = \"testCache\";\n  await partialEvaluator.buildPaintImageXObject({\n    resources: new (await import(\"../../src/core/primitives.js\")).Dict(),\n    image: dummyImage,\n    isInline: false,\n    operatorList,\n    cacheKey,\n    localImageCache,\n    localColorSpaceCache,\n  });\n  const cacheData = localImageCache._cache[cacheKey];\n  if (!cacheData || !cacheData.objId) {\n    throw new Error(\"Missing objId in cache data\");\n  }\n  if (!operatorList.dependencies.includes(cacheData.objId)) {\n    throw new Error(\"Dependency was not added with the correct objId\");\n  }\n});",
    "i5_deepseek-r1-distill-llama-70b": "it(\"should add dependency with objId for cached paintImageXObject\", async () => {\n  const idFactory = createIdFactory();\n  const xref = new XRefMock();\n  const handler = { sendWithPromise: () => Promise.resolve(null) };\n  const options = {\n    maxImageSize: 1000,\n    isOffscreenCanvasSupported: false,\n    canvasMaxAreaInBytes: -1,\n    ignoreErrors: true,\n  };\n  const globalImageCache = {\n    shouldCache: () => false,\n    hasDecodeFailed: () => false,\n    setData() {},\n    addByteSize() {}\n  };\n  const partialEvaluator = new PartialEvaluator({\n    xref,\n    handler,\n    pageIndex: 0,\n    idFactory,\n    fontCache: {},\n    builtInCMapCache: {},\n    standardFontDataCache: {},\n    globalImageCache,\n    systemFontCache: {},\n    options,\n  });\n  // Stub _sendImgData so that buildPaintImageXObject can complete.\n  partialEvaluator._sendImgData = () => Promise.resolve();\n  // Create a dummy dictionary with required keys.\n  const dummyDict = new (await import(\"../../src/core/primitives.js\")).Dict();\n  dummyDict.set(\"W\", 10);\n  dummyDict.set(\"H\", 10);\n  // Set a fake objId to simulate an image reference.\n  dummyDict.objId = \"testImgRef\";\n  // Create a minimal dummy image with getBytes.\n  const dummyImage = {\n    dict: dummyDict,\n    getBytes: (n) => new Uint8Array(n),\n  };\n  // Override PDFImage.buildImage to simulate successful image decoding.\n  const { PDFImage } = await import(\"../../src/core/image.js\");\n  PDFImage.buildImage = (params) => {\n    return Promise.resolve({\n      createImageData: () =>\n        Promise.resolve({\n          width: params.image.dict.get(\"W\"),\n          height: params.image.dict.get(\"H\"),\n          data: new Uint8Array(4 * params.image.dict.get(\"W\") * params.image.dict.get(\"H\")),\n          bitmap: false,\n        }),\n    });\n  };\n  // Create a minimal operator list that records dependencies.\n  const operatorList = new OperatorList();\n  const originalAddDependency = operatorList.addDependency.bind(operatorList);\n  operatorList.dependencies = [];\n  operatorList.addDependency = (dep) => {\n    operatorList.dependencies.push(dep);\n    originalAddDependency(dep);\n  };\n  // Setup a simple localImageCache.\n  const localImageCache = {\n    _cache: {},\n    set(key, ref, data) {\n      this._cache[key] = data;\n    },\n    getByName(name) {\n      return this._cache[name];\n    }\n  };\n  const localColorSpaceCache = {};\n  const cacheKey = \"testCache\";\n  await partialEvaluator.buildPaintImageXObject({\n    resources: new (await import(\"../../src/core/primitives.js\")).Dict(),\n    image: dummyImage,\n    isInline: false,\n    operatorList,\n    cacheKey,\n    localImageCache,\n    localColorSpaceCache,\n  });\n  const cacheData = localImageCache._cache[cacheKey];\n  if (!cacheData || !cacheData.objId) {\n    throw new Error(\"Missing objId in cache data\");\n  }\n  if (!operatorList.dependencies.includes(cacheData.objId)) {\n    throw new Error(\"Dependency was not added with the correct objId\");\n  }\n});",
    "i5_gpt-4o": "it(\"should add dependency with objId for cached paintImageXObject\", async () => {\n  const idFactory = createIdFactory();\n  const xref = new XRefMock();\n  const handler = { sendWithPromise: () => Promise.resolve(null) };\n  const options = {\n    maxImageSize: 1000,\n    isOffscreenCanvasSupported: false,\n    canvasMaxAreaInBytes: -1,\n    ignoreErrors: true,\n  };\n  const globalImageCache = {\n    shouldCache: () => false,\n    hasDecodeFailed: () => false,\n    setData() {},\n    addByteSize() {}\n  };\n  const partialEvaluator = new PartialEvaluator({\n    xref,\n    handler,\n    pageIndex: 0,\n    idFactory,\n    fontCache: {},\n    builtInCMapCache: {},\n    standardFontDataCache: {},\n    globalImageCache,\n    systemFontCache: {},\n    options,\n  });\n  // Stub _sendImgData so that buildPaintImageXObject can complete.\n  partialEvaluator._sendImgData = () => Promise.resolve();\n  // Create a dummy dictionary with required keys.\n  const dummyDict = new (await import(\"../../src/core/primitives.js\")).Dict();\n  dummyDict.set(\"W\", 10);\n  dummyDict.set(\"H\", 10);\n  // Set a fake objId to simulate an image reference.\n  dummyDict.objId = \"testImgRef\";\n  // Create a minimal dummy image with getBytes.\n  const dummyImage = {\n    dict: dummyDict,\n    getBytes: (n) => new Uint8Array(n),\n  };\n  // Override PDFImage.buildImage to simulate successful image decoding.\n  const { PDFImage } = await import(\"../../src/core/image.js\");\n  PDFImage.buildImage = (params) => {\n    return Promise.resolve({\n      createImageData: () =>\n        Promise.resolve({\n          width: params.image.dict.get(\"W\"),\n          height: params.image.dict.get(\"H\"),\n          data: new Uint8Array(4 * params.image.dict.get(\"W\") * params.image.dict.get(\"H\")),\n          bitmap: false,\n        }),\n    });\n  };\n  // Create a minimal operator list that records dependencies.\n  const operatorList = new OperatorList();\n  const originalAddDependency = operatorList.addDependency.bind(operatorList);\n  operatorList.dependencies = [];\n  operatorList.addDependency = (dep) => {\n    operatorList.dependencies.push(dep);\n    originalAddDependency(dep);\n  };\n  // Setup a simple localImageCache.\n  const localImageCache = {\n    _cache: {},\n    set(key, ref, data) {\n      this._cache[key] = data;\n    },\n    getByName(name) {\n      return this._cache[name];\n    }\n  };\n  const localColorSpaceCache = {};\n  const cacheKey = \"testCache\";\n  await partialEvaluator.buildPaintImageXObject({\n    resources: new (await import(\"../../src/core/primitives.js\")).Dict(),\n    image: dummyImage,\n    isInline: false,\n    operatorList,\n    cacheKey,\n    localImageCache,\n    localColorSpaceCache,\n  });\n  const cacheData = localImageCache._cache[cacheKey];\n  if (!cacheData || !cacheData.objId) {\n    throw new Error(\"Missing objId in cache data\");\n  }\n  if (!operatorList.dependencies.includes(cacheData.objId)) {\n    throw new Error(\"Dependency was not added with the correct objId\");\n  }\n});",
    "i5_llama-3.3-70b-versatile": "it(\"should add dependency with objId for cached paintImageXObject\", async () => {\n  const idFactory = createIdFactory();\n  const xref = new XRefMock();\n  const handler = { sendWithPromise: () => Promise.resolve(null) };\n  const options = {\n    maxImageSize: 1000,\n    isOffscreenCanvasSupported: false,\n    canvasMaxAreaInBytes: -1,\n    ignoreErrors: true,\n  };\n  const globalImageCache = {\n    shouldCache: () => false,\n    hasDecodeFailed: () => false,\n    setData() {},\n    addByteSize() {}\n  };\n  const partialEvaluator = new PartialEvaluator({\n    xref,\n    handler,\n    pageIndex: 0,\n    idFactory,\n    fontCache: {},\n    builtInCMapCache: {},\n    standardFontDataCache: {},\n    globalImageCache,\n    systemFontCache: {},\n    options,\n  });\n  // Stub _sendImgData so that buildPaintImageXObject can complete.\n  partialEvaluator._sendImgData = () => Promise.resolve();\n  // Create a dummy dictionary with required keys.\n  const dummyDict = new (await import(\"../../src/core/primitives.js\")).Dict();\n  dummyDict.set(\"W\", 10);\n  dummyDict.set(\"H\", 10);\n  // Set a fake objId to simulate an image reference.\n  dummyDict.objId = \"testImgRef\";\n  // Create a minimal dummy image with getBytes.\n  const dummyImage = {\n    dict: dummyDict,\n    getBytes: (n) => new Uint8Array(n),\n  };\n  // Override PDFImage.buildImage to simulate successful image decoding.\n  const { PDFImage } = await import(\"../../src/core/image.js\");\n  PDFImage.buildImage = (params) => {\n    return Promise.resolve({\n      createImageData: () =>\n        Promise.resolve({\n          width: params.image.dict.get(\"W\"),\n          height: params.image.dict.get(\"H\"),\n          data: new Uint8Array(4 * params.image.dict.get(\"W\") * params.image.dict.get(\"H\")),\n          bitmap: false,\n        }),\n    });\n  };\n  // Create a minimal operator list that records dependencies.\n  const operatorList = new OperatorList();\n  const originalAddDependency = operatorList.addDependency.bind(operatorList);\n  operatorList.dependencies = [];\n  operatorList.addDependency = (dep) => {\n    operatorList.dependencies.push(dep);\n    originalAddDependency(dep);\n  };\n  // Setup a simple localImageCache.\n  const localImageCache = {\n    _cache: {},\n    set(key, ref, data) {\n      this._cache[key] = data;\n    },\n    getByName(name) {\n      return this._cache[name];\n    }\n  };\n  const localColorSpaceCache = {};\n  const cacheKey = \"testCache\";\n  await partialEvaluator.buildPaintImageXObject({\n    resources: new (await import(\"../../src/core/primitives.js\")).Dict(),\n    image: dummyImage,\n    isInline: false,\n    operatorList,\n    cacheKey,\n    localImageCache,\n    localColorSpaceCache,\n  });\n  const cacheData = localImageCache._cache[cacheKey];\n  if (!cacheData || !cacheData.objId) {\n    throw new Error(\"Missing objId in cache data\");\n  }\n  if (!operatorList.dependencies.includes(cacheData.objId)) {\n    throw new Error(\"Dependency was not added with the correct objId\");\n  }\n});"
  },
  "18412": {
    "i1_deepseek-r1-distill-llama-70b": "it(\"should update glyph width and unicode when glyphName is empty for missing file Type1 fonts\", async () => {\n  const { Font } = await import(\"../../src/core/fonts.js\");\n  const properties = {\n    loadedName: \"TestFont\",\n    isType3Font: false,\n    cssFontInfo: {},\n    flags: 0,\n    differences: { 65: \"\" },\n    defaultEncoding: { 65: \"\" },\n    widths: { \"space\": 250 },\n    defaultWidth: 100,\n    composite: false,\n    cMap: { contains: () => false },\n    capHeight: 700,\n    ascent: 800,\n    descent: -200,\n    fontMatrix: [1, 0, 0, 1, 0, 0],\n    bbox: [0, 0, 1000, 1000],\n    toUnicode: { get: () => undefined },\n    cidEncoding: \"\",\n    vertical: false,\n    systemFontInfo: {},\n    // Set type so that the condition glyphName === \"\" && type===\"Type1\" holds.\n    type: \"Type1\",\n    subtype: \"Type1\"\n  };\n  const file = { isEmpty: false };\n  const font = new Font(\"TestFont\", file, properties);\n  font.missingFile = true;\n  const glyph = font._charToGlyph(65, false);\n  if (glyph.width !== 250 || glyph.unicode !== \" \") {\n    throw new Error(`Expected glyph with width 250 and unicode \" \", got width=${glyph.width} and unicode=\"${glyph.unicode}\"`);\n  }\n});",
    "i1_gpt-4o": "it(\"should update glyph width and unicode when glyphName is empty for missing file Type1 fonts\", async () => {\n  const { Font } = await import(\"../../src/core/fonts.js\");\n  const properties = {\n    loadedName: \"TestFont\",\n    isType3Font: false,\n    cssFontInfo: {},\n    flags: 0,\n    differences: { 65: \"\" },\n    defaultEncoding: { 65: \"\" },\n    widths: { \"space\": 250 },\n    defaultWidth: 100,\n    composite: false,\n    cMap: { contains: () => false },\n    capHeight: 700,\n    ascent: 800,\n    descent: -200,\n    fontMatrix: [1, 0, 0, 1, 0, 0],\n    bbox: [0, 0, 1000, 1000],\n    toUnicode: { get: () => undefined },\n    cidEncoding: \"\",\n    vertical: false,\n    systemFontInfo: {},\n    // Set type so that the condition glyphName === \"\" && type===\"Type1\" holds.\n    type: \"Type1\",\n    subtype: \"Type1\"\n  };\n  const file = { isEmpty: false };\n  const font = new Font(\"TestFont\", file, properties);\n  font.missingFile = true;\n  const glyph = font._charToGlyph(65, false);\n  if (glyph.width !== 250 || glyph.unicode !== \" \") {\n    throw new Error(`Expected glyph with width 250 and unicode \" \", got width=${glyph.width} and unicode=\"${glyph.unicode}\"`);\n  }\n});",
    "i1_llama-3.3-70b-versatile": "it(\"should update glyph width and unicode when glyphName is empty for missing file Type1 fonts\", async () => {\n  const { Font } = await import(\"../../src/core/fonts.js\");\n  const properties = {\n    loadedName: \"TestFont\",\n    isType3Font: false,\n    cssFontInfo: {},\n    flags: 0,\n    differences: { 65: \"\" },\n    defaultEncoding: { 65: \"\" },\n    widths: { \"space\": 250 },\n    defaultWidth: 100,\n    composite: false,\n    cMap: { contains: () => false },\n    capHeight: 700,\n    ascent: 800,\n    descent: -200,\n    fontMatrix: [1, 0, 0, 1, 0, 0],\n    bbox: [0, 0, 1000, 1000],\n    toUnicode: { get: () => undefined },\n    cidEncoding: \"\",\n    vertical: false,\n    systemFontInfo: {},\n    // Set type so that the condition glyphName === \"\" && type===\"Type1\" holds.\n    type: \"Type1\",\n    subtype: \"Type1\"\n  };\n  const file = { isEmpty: false };\n  const font = new Font(\"TestFont\", file, properties);\n  font.missingFile = true;\n  const glyph = font._charToGlyph(65, false);\n  if (glyph.width !== 250 || glyph.unicode !== \" \") {\n    throw new Error(`Expected glyph with width 250 and unicode \" \", got width=${glyph.width} and unicode=\"${glyph.unicode}\"`);\n  }\n});",
    "i1_MOCK": "it(\"should update glyph width and unicode when glyphName is empty for missing file Type1 fonts\", async () => {\n  const { Font } = await import(\"../../src/core/fonts.js\");\n  const properties = {\n    loadedName: \"TestFont\",\n    isType3Font: false,\n    cssFontInfo: {},\n    flags: 0,\n    differences: { 65: \"\" },\n    defaultEncoding: { 65: \"\" },\n    widths: { \"space\": 250 },\n    defaultWidth: 100,\n    composite: false,\n    cMap: { contains: () => false },\n    capHeight: 700,\n    ascent: 800,\n    descent: -200,\n    fontMatrix: [1, 0, 0, 1, 0, 0],\n    bbox: [0, 0, 1000, 1000],\n    toUnicode: { get: () => undefined },\n    cidEncoding: \"\",\n    vertical: false,\n    systemFontInfo: {},\n    // Set type so that the condition glyphName === \"\" && type===\"Type1\" holds.\n    type: \"Type1\",\n    subtype: \"Type1\"\n  };\n  const file = { isEmpty: false };\n  const font = new Font(\"TestFont\", file, properties);\n  font.missingFile = true;\n  const glyph = font._charToGlyph(65, false);\n  if (glyph.width !== 250 || glyph.unicode !== \" \") {\n    throw new Error(`Expected glyph with width 250 and unicode \" \", got width=${glyph.width} and unicode=\"${glyph.unicode}\"`);\n  }\n});",
    "i2_deepseek-r1-distill-llama-70b": "it(\"should update glyph width and unicode when glyphName is empty for missing file Type1 fonts\", async () => {\n  const { Font } = await import(\"../../src/core/fonts.js\");\n  const properties = {\n    loadedName: \"TestFont\",\n    isType3Font: false,\n    cssFontInfo: {},\n    flags: 0,\n    differences: { 65: \"\" },\n    defaultEncoding: { 65: \"\" },\n    widths: { \"space\": 250 },\n    defaultWidth: 100,\n    composite: false,\n    cMap: { contains: () => false },\n    capHeight: 700,\n    ascent: 800,\n    descent: -200,\n    fontMatrix: [1, 0, 0, 1, 0, 0],\n    bbox: [0, 0, 1000, 1000],\n    toUnicode: { get: () => undefined },\n    cidEncoding: \"\",\n    vertical: false,\n    systemFontInfo: {},\n    // Set type so that the condition glyphName === \"\" && type===\"Type1\" holds.\n    type: \"Type1\",\n    subtype: \"Type1\"\n  };\n  const file = { isEmpty: false };\n  const font = new Font(\"TestFont\", file, properties);\n  font.missingFile = true;\n  const glyph = font._charToGlyph(65, false);\n  if (glyph.width !== 250 || glyph.unicode !== \" \") {\n    throw new Error(`Expected glyph with width 250 and unicode \" \", got width=${glyph.width} and unicode=\"${glyph.unicode}\"`);\n  }\n});",
    "i2_gpt-4o": "it(\"should update glyph width and unicode when glyphName is empty for missing file Type1 fonts\", async () => {\n  const { Font } = await import(\"../../src/core/fonts.js\");\n  const properties = {\n    loadedName: \"TestFont\",\n    isType3Font: false,\n    cssFontInfo: {},\n    flags: 0,\n    differences: { 65: \"\" },\n    defaultEncoding: { 65: \"\" },\n    widths: { \"space\": 250 },\n    defaultWidth: 100,\n    composite: false,\n    cMap: { contains: () => false },\n    capHeight: 700,\n    ascent: 800,\n    descent: -200,\n    fontMatrix: [1, 0, 0, 1, 0, 0],\n    bbox: [0, 0, 1000, 1000],\n    toUnicode: { get: () => undefined },\n    cidEncoding: \"\",\n    vertical: false,\n    systemFontInfo: {},\n    // Set type so that the condition glyphName === \"\" && type===\"Type1\" holds.\n    type: \"Type1\",\n    subtype: \"Type1\"\n  };\n  const file = { isEmpty: false };\n  const font = new Font(\"TestFont\", file, properties);\n  font.missingFile = true;\n  const glyph = font._charToGlyph(65, false);\n  if (glyph.width !== 250 || glyph.unicode !== \" \") {\n    throw new Error(`Expected glyph with width 250 and unicode \" \", got width=${glyph.width} and unicode=\"${glyph.unicode}\"`);\n  }\n});",
    "i2_llama-3.3-70b-versatile": "it(\"should update glyph width and unicode when glyphName is empty for missing file Type1 fonts\", async () => {\n  const { Font } = await import(\"../../src/core/fonts.js\");\n  const properties = {\n    loadedName: \"TestFont\",\n    isType3Font: false,\n    cssFontInfo: {},\n    flags: 0,\n    differences: { 65: \"\" },\n    defaultEncoding: { 65: \"\" },\n    widths: { \"space\": 250 },\n    defaultWidth: 100,\n    composite: false,\n    cMap: { contains: () => false },\n    capHeight: 700,\n    ascent: 800,\n    descent: -200,\n    fontMatrix: [1, 0, 0, 1, 0, 0],\n    bbox: [0, 0, 1000, 1000],\n    toUnicode: { get: () => undefined },\n    cidEncoding: \"\",\n    vertical: false,\n    systemFontInfo: {},\n    // Set type so that the condition glyphName === \"\" && type===\"Type1\" holds.\n    type: \"Type1\",\n    subtype: \"Type1\"\n  };\n  const file = { isEmpty: false };\n  const font = new Font(\"TestFont\", file, properties);\n  font.missingFile = true;\n  const glyph = font._charToGlyph(65, false);\n  if (glyph.width !== 250 || glyph.unicode !== \" \") {\n    throw new Error(`Expected glyph with width 250 and unicode \" \", got width=${glyph.width} and unicode=\"${glyph.unicode}\"`);\n  }\n});",
    "i3_deepseek-r1-distill-llama-70b": "it(\"should update glyph width and unicode when glyphName is empty for missing file Type1 fonts\", async () => {\n  const { Font } = await import(\"../../src/core/fonts.js\");\n  const properties = {\n    loadedName: \"TestFont\",\n    isType3Font: false,\n    cssFontInfo: {},\n    flags: 0,\n    differences: { 65: \"\" },\n    defaultEncoding: { 65: \"\" },\n    widths: { \"space\": 250 },\n    defaultWidth: 100,\n    composite: false,\n    cMap: { contains: () => false },\n    capHeight: 700,\n    ascent: 800,\n    descent: -200,\n    fontMatrix: [1, 0, 0, 1, 0, 0],\n    bbox: [0, 0, 1000, 1000],\n    toUnicode: { get: () => undefined },\n    cidEncoding: \"\",\n    vertical: false,\n    systemFontInfo: {},\n    // Set type so that the condition glyphName === \"\" && type===\"Type1\" holds.\n    type: \"Type1\",\n    subtype: \"Type1\"\n  };\n  const file = { isEmpty: false };\n  const font = new Font(\"TestFont\", file, properties);\n  font.missingFile = true;\n  const glyph = font._charToGlyph(65, false);\n  if (glyph.width !== 250 || glyph.unicode !== \" \") {\n    throw new Error(`Expected glyph with width 250 and unicode \" \", got width=${glyph.width} and unicode=\"${glyph.unicode}\"`);\n  }\n});",
    "i3_gpt-4o": "it(\"should update glyph width and unicode when glyphName is empty for missing file Type1 fonts\", async () => {\n  const { Font } = await import(\"../../src/core/fonts.js\");\n  const properties = {\n    loadedName: \"TestFont\",\n    isType3Font: false,\n    cssFontInfo: {},\n    flags: 0,\n    differences: { 65: \"\" },\n    defaultEncoding: { 65: \"\" },\n    widths: { \"space\": 250 },\n    defaultWidth: 100,\n    composite: false,\n    cMap: { contains: () => false },\n    capHeight: 700,\n    ascent: 800,\n    descent: -200,\n    fontMatrix: [1, 0, 0, 1, 0, 0],\n    bbox: [0, 0, 1000, 1000],\n    toUnicode: { get: () => undefined },\n    cidEncoding: \"\",\n    vertical: false,\n    systemFontInfo: {},\n    // Set type so that the condition glyphName === \"\" && type===\"Type1\" holds.\n    type: \"Type1\",\n    subtype: \"Type1\"\n  };\n  const file = { isEmpty: false };\n  const font = new Font(\"TestFont\", file, properties);\n  font.missingFile = true;\n  const glyph = font._charToGlyph(65, false);\n  if (glyph.width !== 250 || glyph.unicode !== \" \") {\n    throw new Error(`Expected glyph with width 250 and unicode \" \", got width=${glyph.width} and unicode=\"${glyph.unicode}\"`);\n  }\n});",
    "i3_llama-3.3-70b-versatile": "it(\"should update glyph width and unicode when glyphName is empty for missing file Type1 fonts\", async () => {\n  const { Font } = await import(\"../../src/core/fonts.js\");\n  const properties = {\n    loadedName: \"TestFont\",\n    isType3Font: false,\n    cssFontInfo: {},\n    flags: 0,\n    differences: { 65: \"\" },\n    defaultEncoding: { 65: \"\" },\n    widths: { \"space\": 250 },\n    defaultWidth: 100,\n    composite: false,\n    cMap: { contains: () => false },\n    capHeight: 700,\n    ascent: 800,\n    descent: -200,\n    fontMatrix: [1, 0, 0, 1, 0, 0],\n    bbox: [0, 0, 1000, 1000],\n    toUnicode: { get: () => undefined },\n    cidEncoding: \"\",\n    vertical: false,\n    systemFontInfo: {},\n    // Set type so that the condition glyphName === \"\" && type===\"Type1\" holds.\n    type: \"Type1\",\n    subtype: \"Type1\"\n  };\n  const file = { isEmpty: false };\n  const font = new Font(\"TestFont\", file, properties);\n  font.missingFile = true;\n  const glyph = font._charToGlyph(65, false);\n  if (glyph.width !== 250 || glyph.unicode !== \" \") {\n    throw new Error(`Expected glyph with width 250 and unicode \" \", got width=${glyph.width} and unicode=\"${glyph.unicode}\"`);\n  }\n});",
    "i4_deepseek-r1-distill-llama-70b": "it(\"should update glyph width and unicode when glyphName is empty for missing file Type1 fonts\", async () => {\n  const { Font } = await import(\"../../src/core/fonts.js\");\n  const properties = {\n    loadedName: \"TestFont\",\n    isType3Font: false,\n    cssFontInfo: {},\n    flags: 0,\n    differences: { 65: \"\" },\n    defaultEncoding: { 65: \"\" },\n    widths: { \"space\": 250 },\n    defaultWidth: 100,\n    composite: false,\n    cMap: { contains: () => false },\n    capHeight: 700,\n    ascent: 800,\n    descent: -200,\n    fontMatrix: [1, 0, 0, 1, 0, 0],\n    bbox: [0, 0, 1000, 1000],\n    toUnicode: { get: () => undefined },\n    cidEncoding: \"\",\n    vertical: false,\n    systemFontInfo: {},\n    // Set type so that the condition glyphName === \"\" && type===\"Type1\" holds.\n    type: \"Type1\",\n    subtype: \"Type1\"\n  };\n  const file = { isEmpty: false };\n  const font = new Font(\"TestFont\", file, properties);\n  font.missingFile = true;\n  const glyph = font._charToGlyph(65, false);\n  if (glyph.width !== 250 || glyph.unicode !== \" \") {\n    throw new Error(`Expected glyph with width 250 and unicode \" \", got width=${glyph.width} and unicode=\"${glyph.unicode}\"`);\n  }\n});",
    "i4_gpt-4o": "it(\"should update glyph width and unicode when glyphName is empty for missing file Type1 fonts\", async () => {\n  const { Font } = await import(\"../../src/core/fonts.js\");\n  const properties = {\n    loadedName: \"TestFont\",\n    isType3Font: false,\n    cssFontInfo: {},\n    flags: 0,\n    differences: { 65: \"\" },\n    defaultEncoding: { 65: \"\" },\n    widths: { \"space\": 250 },\n    defaultWidth: 100,\n    composite: false,\n    cMap: { contains: () => false },\n    capHeight: 700,\n    ascent: 800,\n    descent: -200,\n    fontMatrix: [1, 0, 0, 1, 0, 0],\n    bbox: [0, 0, 1000, 1000],\n    toUnicode: { get: () => undefined },\n    cidEncoding: \"\",\n    vertical: false,\n    systemFontInfo: {},\n    // Set type so that the condition glyphName === \"\" && type===\"Type1\" holds.\n    type: \"Type1\",\n    subtype: \"Type1\"\n  };\n  const file = { isEmpty: false };\n  const font = new Font(\"TestFont\", file, properties);\n  font.missingFile = true;\n  const glyph = font._charToGlyph(65, false);\n  if (glyph.width !== 250 || glyph.unicode !== \" \") {\n    throw new Error(`Expected glyph with width 250 and unicode \" \", got width=${glyph.width} and unicode=\"${glyph.unicode}\"`);\n  }\n});",
    "i4_llama-3.3-70b-versatile": "it(\"should update glyph width and unicode when glyphName is empty for missing file Type1 fonts\", async () => {\n  const { Font } = await import(\"../../src/core/fonts.js\");\n  const properties = {\n    loadedName: \"TestFont\",\n    isType3Font: false,\n    cssFontInfo: {},\n    flags: 0,\n    differences: { 65: \"\" },\n    defaultEncoding: { 65: \"\" },\n    widths: { \"space\": 250 },\n    defaultWidth: 100,\n    composite: false,\n    cMap: { contains: () => false },\n    capHeight: 700,\n    ascent: 800,\n    descent: -200,\n    fontMatrix: [1, 0, 0, 1, 0, 0],\n    bbox: [0, 0, 1000, 1000],\n    toUnicode: { get: () => undefined },\n    cidEncoding: \"\",\n    vertical: false,\n    systemFontInfo: {},\n    // Set type so that the condition glyphName === \"\" && type===\"Type1\" holds.\n    type: \"Type1\",\n    subtype: \"Type1\"\n  };\n  const file = { isEmpty: false };\n  const font = new Font(\"TestFont\", file, properties);\n  font.missingFile = true;\n  const glyph = font._charToGlyph(65, false);\n  if (glyph.width !== 250 || glyph.unicode !== \" \") {\n    throw new Error(`Expected glyph with width 250 and unicode \" \", got width=${glyph.width} and unicode=\"${glyph.unicode}\"`);\n  }\n});",
    "i5_deepseek-r1-distill-llama-70b": "it(\"should update glyph width and unicode when glyphName is empty for missing file Type1 fonts\", async () => {\n  const { Font } = await import(\"../../src/core/fonts.js\");\n  const properties = {\n    loadedName: \"TestFont\",\n    isType3Font: false,\n    cssFontInfo: {},\n    flags: 0,\n    differences: { 65: \"\" },\n    defaultEncoding: { 65: \"\" },\n    widths: { \"space\": 250 },\n    defaultWidth: 100,\n    composite: false,\n    cMap: { contains: () => false },\n    capHeight: 700,\n    ascent: 800,\n    descent: -200,\n    fontMatrix: [1, 0, 0, 1, 0, 0],\n    bbox: [0, 0, 1000, 1000],\n    toUnicode: { get: () => undefined },\n    cidEncoding: \"\",\n    vertical: false,\n    systemFontInfo: {},\n    // Set type so that the condition glyphName === \"\" && type===\"Type1\" holds.\n    type: \"Type1\",\n    subtype: \"Type1\"\n  };\n  const file = { isEmpty: false };\n  const font = new Font(\"TestFont\", file, properties);\n  font.missingFile = true;\n  const glyph = font._charToGlyph(65, false);\n  if (glyph.width !== 250 || glyph.unicode !== \" \") {\n    throw new Error(`Expected glyph with width 250 and unicode \" \", got width=${glyph.width} and unicode=\"${glyph.unicode}\"`);\n  }\n});",
    "i5_gpt-4o": "it(\"should update glyph width and unicode when glyphName is empty for missing file Type1 fonts\", async () => {\n  const { Font } = await import(\"../../src/core/fonts.js\");\n  const properties = {\n    loadedName: \"TestFont\",\n    isType3Font: false,\n    cssFontInfo: {},\n    flags: 0,\n    differences: { 65: \"\" },\n    defaultEncoding: { 65: \"\" },\n    widths: { \"space\": 250 },\n    defaultWidth: 100,\n    composite: false,\n    cMap: { contains: () => false },\n    capHeight: 700,\n    ascent: 800,\n    descent: -200,\n    fontMatrix: [1, 0, 0, 1, 0, 0],\n    bbox: [0, 0, 1000, 1000],\n    toUnicode: { get: () => undefined },\n    cidEncoding: \"\",\n    vertical: false,\n    systemFontInfo: {},\n    // Set type so that the condition glyphName === \"\" && type===\"Type1\" holds.\n    type: \"Type1\",\n    subtype: \"Type1\"\n  };\n  const file = { isEmpty: false };\n  const font = new Font(\"TestFont\", file, properties);\n  font.missingFile = true;\n  const glyph = font._charToGlyph(65, false);\n  if (glyph.width !== 250 || glyph.unicode !== \" \") {\n    throw new Error(`Expected glyph with width 250 and unicode \" \", got width=${glyph.width} and unicode=\"${glyph.unicode}\"`);\n  }\n});",
    "i5_llama-3.3-70b-versatile": "it(\"should update glyph width and unicode when glyphName is empty for missing file Type1 fonts\", async () => {\n  const { Font } = await import(\"../../src/core/fonts.js\");\n  const properties = {\n    loadedName: \"TestFont\",\n    isType3Font: false,\n    cssFontInfo: {},\n    flags: 0,\n    differences: { 65: \"\" },\n    defaultEncoding: { 65: \"\" },\n    widths: { \"space\": 250 },\n    defaultWidth: 100,\n    composite: false,\n    cMap: { contains: () => false },\n    capHeight: 700,\n    ascent: 800,\n    descent: -200,\n    fontMatrix: [1, 0, 0, 1, 0, 0],\n    bbox: [0, 0, 1000, 1000],\n    toUnicode: { get: () => undefined },\n    cidEncoding: \"\",\n    vertical: false,\n    systemFontInfo: {},\n    // Set type so that the condition glyphName === \"\" && type===\"Type1\" holds.\n    type: \"Type1\",\n    subtype: \"Type1\"\n  };\n  const file = { isEmpty: false };\n  const font = new Font(\"TestFont\", file, properties);\n  font.missingFile = true;\n  const glyph = font._charToGlyph(65, false);\n  if (glyph.width !== 250 || glyph.unicode !== \" \") {\n    throw new Error(`Expected glyph with width 250 and unicode \" \", got width=${glyph.width} and unicode=\"${glyph.unicode}\"`);\n  }\n});"
  },
  "18417": {
    "i1_deepseek-r1-distill-llama-70b": "it(\"should handle base href correctly in filter URLs\", async () => {\n  const { DOMFilterFactory } = await import(\"../../src/display/display_utils.js\");\n  const { Util } = await import(\"../../src/shared/util.js\");\n\n  // Simulate the presence of a base href\n  const originalBaseURI = document.baseURI;\n  document.baseURI = \"http://example.com/\";\n\n  const factory = new DOMFilterFactory();\n  const filter = {\n    transferMap: {\n      red: [0, 1],\n      green: [0, 1],\n      blue: [0, 1],\n    },\n  };\n\n  const url = await factory.addFilter(filter);\n\n  // The URL should include the base href followed by the fragment\n  const expectedUrl = \"url(http://example.com/#g_1_transfer_map_1)\";\n  assert.strictEqual(url, expectedUrl);\n\n  // Restore original baseURI\n  document.baseURI = originalBaseURI;\n});",
    "i1_gpt-4o": "it(\"should correctly render PDF with transparency filters in Firefox when base href is present\", async () => {\n  const { DOMFilterFactory } = await import(\"../../src/display/display_utils.js\");\n  const { PDFDocumentProxy } = await import(\"../../src/display/api.js\");\n\n  const docId = \"testDoc\";\n  const ownerDocument = {\n    URL: \"http://example.com/viewer.html\",\n    baseURI: \"http://example.com/\",\n  };\n  const filterFactory = new DOMFilterFactory({ docId, ownerDocument });\n\n  const maps = [{ r: 0.5, g: 0.5, b: 0.5 }];\n  const expectedUrl = \"url(http://example.com/viewer.html#g_testDoc_transfer_map_0)\";\n\n  const actualUrl = filterFactory.addFilter(maps);\n\n  expect(actualUrl).toBe(expectedUrl);\n});",
    "i1_llama-3.3-70b-versatile": "it(\"should render PDF with transparency filters correctly when base href is defined\", async () => {\n  const { DOMFilterFactory } = await import(\"../../src/display/display_utils.js\");\n  const { PDFDocument } = await import(\"../../src/display/api.js\");\n  const { PDFNetworkStream } = await import(\"../../src/display/network.js\");\n  const pdfUrl = \"https://github.com/mozilla/pdf.js/files/11229069/test.pdf\";\n  const pdfDocument = await PDFDocument.load({ url: pdfUrl, verbosity: 0 });\n  const filterFactory = new DOMFilterFactory();\n  const filter = filterFactory.addFilter([0, 1]);\n  const baseHref = document.createElement(\"base\");\n  baseHref.href = \".\";\n  document.head.appendChild(baseHref);\n  const svg = document.createElementNS(\"http://www.w3.org/2000/svg\", \"svg\");\n  const filterElement = document.createElementNS(\"http://www.w3.org/2000/svg\", \"filter\");\n  filterElement.id = filter.substring(4);\n  svg.appendChild(filterElement);\n  document.body.appendChild(svg);\n  const actualFilter = filterElement.getAttribute(\"id\");\n  const expectedFilter = filter.substring(4);\n  expect(actualFilter).toBe(expectedFilter);\n});",
    "i2_deepseek-r1-distill-llama-70b": "it(\"should create absolute filter URLs when base element is present\", async () => {\n  const { DOMFilterFactory } = await import(\"../../src/display/display_utils.js\");\n  const { Util } = await import(\"../../src/shared/util.js\");\n\n  // Mock document with <base> element\n  const mockDocument = {\n    baseURI: \"http://example.com/\",\n    URL: \"http://example.com/\",\n    baseURI: \"http://example.com/\",\n    getElementsByTagName: () => [\n      { href: \".\" }\n    ]\n  };\n\n  const factory = new DOMFilterFactory({ ownerDocument: mockDocument });\n  const filter = await factory.addFilter([0, 255]);\n\n  expect(filter).toMatch(/^http:\\/\\/example\\.com\\/#/);\n});",
    "i2_gpt-4o": "it(\"should render PDF correctly with base href in Firefox\", async () => {\n  const { getDocument } = await import(\"../../src/display/api.js\");\n  const { DOMFilterFactory } = await import(\"../../src/display/display_utils.js\");\n  const url = \"https://github.com/mozilla/pdf.js/files/11229069/test.pdf\";\n  const baseHref = \".\";\n  const docId = \"testDoc\";\n  const ownerDocument = {\n    URL: \"http://localhost:8888/web/viewer.html\",\n    baseURI: `http://localhost:8888/web/${baseHref}`,\n  };\n  const filterFactory = new DOMFilterFactory({ docId, ownerDocument });\n  const loadingTask = getDocument(url);\n  const pdf = await loadingTask.promise;\n  const page = await pdf.getPage(1);\n  const viewport = page.getViewport({ scale: 1 });\n  const canvas = document.createElement(\"canvas\");\n  const context = canvas.getContext(\"2d\");\n  canvas.width = viewport.width;\n  canvas.height = viewport.height;\n  const renderContext = {\n    canvasContext: context,\n    viewport,\n    filterFactory,\n  };\n  await page.render(renderContext).promise;\n  const imageData = context.getImageData(0, 0, canvas.width, canvas.height);\n  const hasTransparency = Array.from(imageData.data).some((value, index) => index % 4 === 3 && value < 255);\n  expect(hasTransparency).toBe(true);\n});",
    "i2_llama-3.3-70b-versatile": "it(\"should render PDF with transparency filters correctly when base href is defined\", async () => {\n  const { PDFDocument, PDFPage } = await import(\"../../src/display/api.js\");\n  const { DOMFilterFactory } = await import(\"../../src/display/display_utils.js\");\n  const { createTemporaryNodeServer } = await import(\"./test_utils.js\");\n\n  const server = await createTemporaryNodeServer();\n  const pdfUrl = server.url + \"/test/pdfs/test.pdf\";\n  const pdf = await PDFDocument.load(pdfUrl);\n  const page = await pdf.getPage(1);\n  const filterFactory = new DOMFilterFactory();\n\n  const html = `\n    <html>\n    <head>\n      <base href=\".\">\n    </head>\n    <body>\n      <canvas id=\"canvas\"></canvas>\n      <script>\n        const canvas = document.getElementById(\"canvas\");\n        const ctx = canvas.getContext(\"2d\");\n        const filter = ${JSON.stringify(filterFactory.addFilter([0, 1]))};\n        ctx.filter = filter;\n        ctx.fillStyle = \"rgba(0, 0, 0, 0.5)\";\n        ctx.fillRect(10, 10, 50, 50);\n      </script>\n    </body>\n    </html>\n  `;\n\n  const expectedData = await page.render({\n    canvasContext: { filter: filterFactory.addFilter([0, 1]) },\n    viewport: page.getViewport({ scale: 1 }),\n  });\n\n  const actualData = await new Promise((resolve) => {\n    const iframe = document.createElement(\"iframe\");\n    iframe.srcdoc = html;\n    document.body.appendChild(iframe);\n    const canvas = iframe.contentDocument.getElementById(\"canvas\");\n    const ctx = canvas.getContext(\"2d\");\n    ctx.drawImage(canvas, 0, 0);\n    const imageData = ctx.getImageData(10, 10, 50, 50);\n    resolve(imageData.data);\n  });\n\n  for (let i = 0; i < expectedData.data.length; i++) {\n    if (expectedData.data[i] !== actualData[i]) {\n      throw new Error(\"Transparency filter rendering failed\");\n    }\n  }\n});",
    "i3_deepseek-r1-distill-llama-70b": "it(\"should correctly create filter URLs with base href\", async () => {\n  const { DOMFilterFactory } = await import(\"../../src/display/display_utils.js\");\n  const { document } = await import(\"../../src/shared/util.js\");\n\n  // Mock document with base href\n  const mockDocument = {\n    ...document,\n    baseURI: \"http://example.com/\",\n    createElementNS: jest.fn(),\n    getElementsByTagName: jest.fn(() => [{ href: \".\" }]),\n  };\n\n  const factory = new DOMFilterFactory({ ownerDocument: mockDocument });\n  const filter = await factory.addFilter([new Array(256).fill(0)]);\n\n  expect(filter).toMatch(/^url\\(http:\\/\\/example\\.com\\/#.+?\\)$/);\n});",
    "i3_gpt-4o": "it(\"should correctly handle base href in DOMFilterFactory\", async () => {\n  const { DOMFilterFactory } = await import(\"../../src/display/display_utils.js\");\n  const docId = \"testDoc\";\n  const ownerDocument = {\n    URL: \"http://example.com/viewer.html\",\n    baseURI: \"http://example.com/\",\n    createElement: () => ({ append: () => {}, setAttribute: () => {} }),\n    createElementNS: () => ({ append: () => {}, setAttribute: () => {} }),\n    body: { append: () => {} },\n  };\n  const factory = new DOMFilterFactory({ docId, ownerDocument });\n  const maps = [[0, 255], [0, 255], [0, 255]];\n  const expectedUrl = \"url(http://example.com/viewer.html#g_testDoc_transfer_map_0)\";\n  const actualUrl = factory.addFilter(maps);\n  expect(actualUrl).toBe(expectedUrl);\n});",
    "i3_llama-3.3-70b-versatile": "it(\"should render PDF with transparency filters correctly when base href is defined\", async () => {\n  const { DOMFilterFactory } = await import(\"../../src/display/display_utils.js\");\n  const { document } = await import(\"../../src/shared/util.js\");\n  const filterFactory = new DOMFilterFactory();\n  const baseUrl = \"https://example.com\";\n  const url = `url(#test)`;\n  const id = \"test\";\n  const originalUrl = filterFactory.addFilter([255]);\n  document.baseURI = baseUrl;\n  const newUrl = filterFactory.addFilter([255]);\n  expect(newUrl).toBe(`url(${baseUrl}#${id})`);\n});",
    "i4_deepseek-r1-distill-llama-70b": "it(\"should render transparency filters correctly with base href\", async () => {\n  const { PDFDocument } = await import(\"../../web/pdf_document.js\");\n  const { PDFPage } = await import(\"../../web/pdf_page.js\");\n  const { PDFViewer } = await import(\"../../web/pdf_viewer.js\");\n  const { JSDOM } = await import(\"jsdom\");\n  const { readFileSync } = require(\"fs\");\n  const { join } = require(\"path\");\n\n  const testPdf = readFileSync(join(__dirname, \"test.pdf\"));\n  const dom = new JSDOM();\n  const document = dom.window.document;\n\n  // Create base href element\n  const baseElement = document.createElement(\"base\");\n  baseElement.setAttribute(\"href\", \".\");\n  document.head.appendChild(baseElement);\n\n  // Load and render PDF\n  const pdf = await PDFDocument.load({\n    data: testPdf.buffer,\n    loader: new PDFDocumentLoader({\n      verifyData: true,\n    }),\n  });\n  const page = await pdf.getPage(1);\n  const viewer = new PDFViewer({\n    container: document.body,\n    renderer: \"canvas\",\n    scale: 1,\n    rotate: 0,\n  });\n  viewer.setDocument(pdf);\n  await viewer.setPage(1);\n\n  const canvas = viewer.getCanvas();\n  const context = canvas.getContext(\"2d\");\n\n  // Get pixel data to check transparency\n  const imageData = context.getImageData(100, 100, 1, 1).data;\n  const expectedAlpha = 128;\n  const actualAlpha = imageData[3];\n\n  expect(actualAlpha).toBe(expectedAlpha);\n});",
    "i4_gpt-4o": "it(\"should render PDF with correct transparency filters in Firefox when base href is present\", async () => {\n  const { DOMFilterFactory } = await import(\"../../src/display/display_utils.js\");\n  const { PDFDocumentProxy, getDocument } = await import(\"../../src/display/api.js\");\n  const { createTemporaryNodeServer } = await import(\"./test_utils.js\");\n\n  const server = await createTemporaryNodeServer();\n  const url = `${server.url}/test.pdf`;\n  const loadingTask = getDocument(url);\n  const pdfDocument = await loadingTask.promise;\n  const page = await pdfDocument.getPage(1);\n\n  const canvasFactory = new DOMFilterFactory({ docId: \"test\" });\n  const viewport = page.getViewport({ scale: 1 });\n  const canvasAndContext = canvasFactory.create(viewport.width, viewport.height);\n  const renderContext = {\n    canvasContext: canvasAndContext.context,\n    viewport: viewport,\n  };\n\n  await page.render(renderContext).promise;\n\n  const expected = \"rgba(0, 0, 0, 0.5)\"; // Expected transparency color\n  const actual = canvasAndContext.context.getImageData(0, 0, 1, 1).data;\n  const actualColor = `rgba(${actual[0]}, ${actual[1]}, ${actual[2]}, ${actual[3] / 255})`;\n\n  expect(actualColor).toBe(expected);\n\n  server.stop();\n});",
    "i4_llama-3.3-70b-versatile": "it(\"should render PDF with transparency filters correctly when base href is defined\", async () => {\n  const { DOMFilterFactory, DOMCanvasFactory, DOMSVGFactory } = await import(\"../../src/display/display_utils.js\");\n  const { document } = await import(\"../../src/shared/util.js\");\n\n  const filterFactory = new DOMFilterFactory();\n  const canvasFactory = new DOMCanvasFactory();\n  const svgFactory = new DOMSVGFactory();\n\n  const base = document.createElement(\"base\");\n  base.href = \".\";\n  document.head.appendChild(base);\n\n  const filter = filterFactory.addFilter([255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,",
    "i5_deepseek-r1-distill-llama-70b": "it(\"should correctly generate filter URLs with base element\", async () => {\n  const { DOMFilterFactory } = await import(\"../../src/display/display_utils.js\");\n  const { PDFDocument } = await import(\"../../src/display/api.js\");\n\n  // Create a test PDF document\n  const pdf = await PDFDocument.load(testreporter.fetchMock(test_utils.TEST_PDFS_PATH + \"test.pdf\"));\n\n  // Create a page and get the first page\n  const page = (await pdf.getPages()).get(0);\n\n  // Mock document and baseURI to simulate <base> element\n  const mockDocument = {\n    URL: \"http://example.com/viewer.html\",\n    baseURI: \"http://example.com/viewer.html\",\n    createElement: () => ({})\n  };\n\n  // Create DOMFilterFactory with mocked document\n  const factory = new DOMFilterFactory(mockDocument, pdf);\n\n  // Generate filter URLs\n  const filter1 = await factory.addFilter([{ component: 0, transfer: 1 }]);\n  const filter2 = await factory.addFilter([{ component: 1, transfer: 0.5 }]);\n  const filter3 = await factory.addLuminosityFilter(0.8);\n\n  // Verify URLs are correctly prefixed with base URL\n  expect(filter1.startsWith(\"http://example.com/viewer.html\")).toBe(true);\n  expect(filter2.startsWith(\"http://example.com/viewer.html\")).toBe(true);\n  expect(filter3.startsWith(\"http://example.com/viewer.html\")).toBe(true);\n});",
    "i5_gpt-4o": "it(\"should render PDF with correct transparency filters in Firefox when base href is present\", async () => {\n  const { getDocument } = await import(\"../../src/display/api.js\");\n  const { DOMCanvasFactory } = await import(\"../../src/display/display_utils.js\");\n  const { PDFPageView } = await import(\"../../web/pdf_page_view.js\");\n  const { AppOptions } = await import(\"../../web/app_options.js\");\n\n  AppOptions.set(\"workerSrc\", \"../../build/pdf.worker.js\");\n\n  const loadingTask = getDocument(\"https://github.com/mozilla/pdf.js/files/11229069/test.pdf\");\n  const pdfDocument = await loadingTask.promise;\n  const page = await pdfDocument.getPage(1);\n\n  const canvasFactory = new DOMCanvasFactory();\n  const viewport = page.getViewport({ scale: 1.0 });\n  const canvasAndContext = canvasFactory.create(viewport.width, viewport.height);\n  const renderContext = {\n    canvasContext: canvasAndContext.context,\n    viewport,\n  };\n\n  const pageView = new PDFPageView({\n    container: document.createElement(\"div\"),\n    id: 1,\n    scale: 1.0,\n    defaultViewport: viewport,\n    canvasFactory,\n    renderingQueue: null,\n    textLayerFactory: null,\n    annotationLayerFactory: null,\n  });\n\n  pageView.setPdfPage(page);\n  await pageView.draw();\n\n  const expectedTransparency = \"rgba(0, 0, 0, 0.5)\"; // Example expected transparency color\n  const actualTransparency = canvasAndContext.context.getImageData(0, 0, 1, 1).data;\n  const actualTransparencyColor = `rgba(${actualTransparency[0]}, ${actualTransparency[1]}, ${actualTransparency[2]}, ${actualTransparency[3] / 255})`;\n\n  expect(actualTransparencyColor).toBe(expectedTransparency);\n});",
    "i5_llama-3.3-70b-versatile": "it(\"should render PDF correctly with base href in Firefox\", async () => {\n  const { PDFDocument, PDFPageProxy } = await import(\"../../src/display/api.js\");\n  const { createIdFactory } = await import(\"./test_utils.js\");\n  const { PDFNetworkStream } = await import(\"../../src/display/network.js\");\n  const { createTemporaryNodeServer } = await import(\"./test_utils.js\");\n\n  const server = await createTemporaryNodeServer();\n  const pdfUrl = server.url + \"/test.pdf\";\n  const baseUrl = server.url;\n  const idFactory = createIdFactory();\n\n  const pdfDocument = await PDFDocument.load({ url: pdfUrl, cMapUrl: \"\", cMapPacked: true, pdfNetworkStream: new PDFNetworkStream(idFactory) });\n  const pdfPage = await pdfDocument.getPage(1);\n\n  const canvas = document.createElement(\"canvas\");\n  const ctx = canvas.getContext(\"2d\");\n  const renderTask = pdfPage.render({ canvasContext: ctx, viewport: pdfPage.getViewport({ scale: 1 }) });\n\n  await renderTask.promise;\n\n  const html = `<html><head><base href=\"${baseUrl}\"/></head><body><canvas></canvas></body></html>`;\n  const doc = new DOMParser().parseFromString(html, \"text/html\");\n  const base = doc.querySelector(\"base\");\n  const canvasElement = doc.querySelector(\"canvas\");\n\n  const originalCreateElementNS = document.createElementNS;\n  const originalGetElementById = document.getElementById;\n\n  document.createElementNS = (namespace, name) => {\n    if (name === \"canvas\") {\n      return canvasElement;\n    }\n    return originalCreateElementNS.apply(document, [namespace, name]);\n  };\n\n  document.getElementById = (id) => {\n    if (id === \"pdfViewer\") {\n      return { getBoundingClientRect: () => ({ width: 100, height: 100 }) };\n    }\n    return originalGetElementById.apply(document, [id]);\n  };\n\n  const { DOMFilterFactory } = await import(\"../../src/display/display_utils.js\");\n  const filterFactory = new DOMFilterFactory({ document, baseUrl: base.href });\n\n  const expectedUrl = `url(${baseUrl}#test)`;\n  const actualUrl = filterFactory.#createUrl(\"test\");\n\n  await server.close();\n\n  expect(actualUrl).toBe(expectedUrl);\n});"
  },
  "18496": {
    "i1_deepseek-r1-distill-llama-70b": "it(\"should create a straight line when Shift key is held during drawing\", async () => {\n  const originalRAF = window.requestAnimationFrame;\n  window.requestAnimationFrame = (cb) => {\n    cb();\n    return 0;\n  };\n\n  const { InkEditor } = await import(\"../../src/display/editor/ink.js\");\n  const dummyUiManager = {\n    rebuild: () => {},\n    _signal: new AbortController().signal,\n  };\n  const dummyParent = {\n    setEditingState: () => {},\n  };\n  const div = document.createElement(\"div\");\n  // Create a canvas with defined dimensions.\n  const canvas = document.createElement(\"canvas\");\n  canvas.width = 500;\n  canvas.height = 500;\n\n  const editor = new InkEditor({\n    uiManager: dummyUiManager,\n    parent: dummyParent,\n    div,\n    canvas,\n  });\n  // Ensure the editor is in edit mode.\n  editor.isInEditMode = () => true;\n  // Simulate a pointerdown event with the Shift key pressed.\n  const pointerDownEvent = {\n    button: 0,\n    offsetX: 10,\n    offsetY: 20,\n    shiftKey: true,\n    preventDefault: () => {},\n  };\n  editor.canvasPointerdown(pointerDownEvent);\n  // Simulate a pointerup event at a different location.\n  const pointerUpEvent = {\n    offsetX: 100,\n    offsetY: 200,\n    preventDefault: () => {},\n  };\n  editor.canvasPointerup(pointerUpEvent);\n\n  // The patch should have created a straight line, resulting in a bezier path of one segment:\n  // [[start, start, end, end]].\n  if (!editor.paths || editor.paths.length !== 1) {\n    throw new Error(\"Expected a single path to be recorded.\");\n  }\n  const bezierPoints = editor.paths[0];\n  if (bezierPoints.length !== 1) {\n    throw new Error(\"Expected exactly one bezier segment for a straight line.\");\n  }\n  const segment = bezierPoints[0];\n  const expected = [[10, 20], [10, 20], [100, 200], [100, 200]];\n  for (let i = 0; i < 4; i++) {\n    if (Math.abs(segment[i][0] - expected[i][0]) > 0.001 ||\n        Math.abs(segment[i][1] - expected[i][1]) > 0.001) {\n      throw new Error(\"The bezier segment does not match the expected straight line.\");\n    }\n  }\n  window.requestAnimationFrame = originalRAF;\n});\n",
    "i1_gpt-4o": "it(\"should create a straight line when Shift key is held during drawing\", async () => {\n  const originalRAF = window.requestAnimationFrame;\n  window.requestAnimationFrame = (cb) => {\n    cb();\n    return 0;\n  };\n\n  const { InkEditor } = await import(\"../../src/display/editor/ink.js\");\n  const dummyUiManager = {\n    rebuild: () => {},\n    _signal: new AbortController().signal,\n  };\n  const dummyParent = {\n    setEditingState: () => {},\n  };\n  const div = document.createElement(\"div\");\n  // Create a canvas with defined dimensions.\n  const canvas = document.createElement(\"canvas\");\n  canvas.width = 500;\n  canvas.height = 500;\n\n  const editor = new InkEditor({\n    uiManager: dummyUiManager,\n    parent: dummyParent,\n    div,\n    canvas,\n  });\n  // Ensure the editor is in edit mode.\n  editor.isInEditMode = () => true;\n  // Simulate a pointerdown event with the Shift key pressed.\n  const pointerDownEvent = {\n    button: 0,\n    offsetX: 10,\n    offsetY: 20,\n    shiftKey: true,\n    preventDefault: () => {},\n  };\n  editor.canvasPointerdown(pointerDownEvent);\n  // Simulate a pointerup event at a different location.\n  const pointerUpEvent = {\n    offsetX: 100,\n    offsetY: 200,\n    preventDefault: () => {},\n  };\n  editor.canvasPointerup(pointerUpEvent);\n\n  // The patch should have created a straight line, resulting in a bezier path of one segment:\n  // [[start, start, end, end]].\n  if (!editor.paths || editor.paths.length !== 1) {\n    throw new Error(\"Expected a single path to be recorded.\");\n  }\n  const bezierPoints = editor.paths[0];\n  if (bezierPoints.length !== 1) {\n    throw new Error(\"Expected exactly one bezier segment for a straight line.\");\n  }\n  const segment = bezierPoints[0];\n  const expected = [[10, 20], [10, 20], [100, 200], [100, 200]];\n  for (let i = 0; i < 4; i++) {\n    if (Math.abs(segment[i][0] - expected[i][0]) > 0.001 ||\n        Math.abs(segment[i][1] - expected[i][1]) > 0.001) {\n      throw new Error(\"The bezier segment does not match the expected straight line.\");\n    }\n  }\n  window.requestAnimationFrame = originalRAF;\n});\n",
    "i1_llama-3.3-70b-versatile": "it(\"should create a straight line when Shift key is held during drawing\", async () => {\n  const originalRAF = window.requestAnimationFrame;\n  window.requestAnimationFrame = (cb) => {\n    cb();\n    return 0;\n  };\n\n  const { InkEditor } = await import(\"../../src/display/editor/ink.js\");\n  const dummyUiManager = {\n    rebuild: () => {},\n    _signal: new AbortController().signal,\n  };\n  const dummyParent = {\n    setEditingState: () => {},\n  };\n  const div = document.createElement(\"div\");\n  // Create a canvas with defined dimensions.\n  const canvas = document.createElement(\"canvas\");\n  canvas.width = 500;\n  canvas.height = 500;\n\n  const editor = new InkEditor({\n    uiManager: dummyUiManager,\n    parent: dummyParent,\n    div,\n    canvas,\n  });\n  // Ensure the editor is in edit mode.\n  editor.isInEditMode = () => true;\n  // Simulate a pointerdown event with the Shift key pressed.\n  const pointerDownEvent = {\n    button: 0,\n    offsetX: 10,\n    offsetY: 20,\n    shiftKey: true,\n    preventDefault: () => {},\n  };\n  editor.canvasPointerdown(pointerDownEvent);\n  // Simulate a pointerup event at a different location.\n  const pointerUpEvent = {\n    offsetX: 100,\n    offsetY: 200,\n    preventDefault: () => {},\n  };\n  editor.canvasPointerup(pointerUpEvent);\n\n  // The patch should have created a straight line, resulting in a bezier path of one segment:\n  // [[start, start, end, end]].\n  if (!editor.paths || editor.paths.length !== 1) {\n    throw new Error(\"Expected a single path to be recorded.\");\n  }\n  const bezierPoints = editor.paths[0];\n  if (bezierPoints.length !== 1) {\n    throw new Error(\"Expected exactly one bezier segment for a straight line.\");\n  }\n  const segment = bezierPoints[0];\n  const expected = [[10, 20], [10, 20], [100, 200], [100, 200]];\n  for (let i = 0; i < 4; i++) {\n    if (Math.abs(segment[i][0] - expected[i][0]) > 0.001 ||\n        Math.abs(segment[i][1] - expected[i][1]) > 0.001) {\n      throw new Error(\"The bezier segment does not match the expected straight line.\");\n    }\n  }\n  window.requestAnimationFrame = originalRAF;\n});\n",
    "i1_MOCK": "it(\"should create a straight line when Shift key is held during drawing\", async () => {\n  const originalRAF = window.requestAnimationFrame;\n  window.requestAnimationFrame = (cb) => {\n    cb();\n    return 0;\n  };\n\n  const { InkEditor } = await import(\"../../src/display/editor/ink.js\");\n  const dummyUiManager = {\n    rebuild: () => {},\n    _signal: new AbortController().signal,\n  };\n  const dummyParent = {\n    setEditingState: () => {},\n  };\n  const div = document.createElement(\"div\");\n  // Create a canvas with defined dimensions.\n  const canvas = document.createElement(\"canvas\");\n  canvas.width = 500;\n  canvas.height = 500;\n\n  const editor = new InkEditor({\n    uiManager: dummyUiManager,\n    parent: dummyParent,\n    div,\n    canvas,\n  });\n  // Ensure the editor is in edit mode.\n  editor.isInEditMode = () => true;\n  // Simulate a pointerdown event with the Shift key pressed.\n  const pointerDownEvent = {\n    button: 0,\n    offsetX: 10,\n    offsetY: 20,\n    shiftKey: true,\n    preventDefault: () => {},\n  };\n  editor.canvasPointerdown(pointerDownEvent);\n  // Simulate a pointerup event at a different location.\n  const pointerUpEvent = {\n    offsetX: 100,\n    offsetY: 200,\n    preventDefault: () => {},\n  };\n  editor.canvasPointerup(pointerUpEvent);\n\n  // The patch should have created a straight line, resulting in a bezier path of one segment:\n  // [[start, start, end, end]].\n  if (!editor.paths || editor.paths.length !== 1) {\n    throw new Error(\"Expected a single path to be recorded.\");\n  }\n  const bezierPoints = editor.paths[0];\n  if (bezierPoints.length !== 1) {\n    throw new Error(\"Expected exactly one bezier segment for a straight line.\");\n  }\n  const segment = bezierPoints[0];\n  const expected = [[10, 20], [10, 20], [100, 200], [100, 200]];\n  for (let i = 0; i < 4; i++) {\n    if (Math.abs(segment[i][0] - expected[i][0]) > 0.001 ||\n        Math.abs(segment[i][1] - expected[i][1]) > 0.001) {\n      throw new Error(\"The bezier segment does not match the expected straight line.\");\n    }\n  }\n  window.requestAnimationFrame = originalRAF;\n});\n",
    "i2_deepseek-r1-distill-llama-70b": "it(\"should create a straight line when Shift key is held during drawing\", async () => {\n  const originalRAF = window.requestAnimationFrame;\n  window.requestAnimationFrame = (cb) => {\n    cb();\n    return 0;\n  };\n\n  const { InkEditor } = await import(\"../../src/display/editor/ink.js\");\n  const dummyUiManager = {\n    rebuild: () => {},\n    _signal: new AbortController().signal,\n  };\n  const dummyParent = {\n    setEditingState: () => {},\n  };\n  const div = document.createElement(\"div\");\n  // Create a canvas with defined dimensions.\n  const canvas = document.createElement(\"canvas\");\n  canvas.width = 500;\n  canvas.height = 500;\n\n  const editor = new InkEditor({\n    uiManager: dummyUiManager,\n    parent: dummyParent,\n    div,\n    canvas,\n  });\n  // Ensure the editor is in edit mode.\n  editor.isInEditMode = () => true;\n  // Simulate a pointerdown event with the Shift key pressed.\n  const pointerDownEvent = {\n    button: 0,\n    offsetX: 10,\n    offsetY: 20,\n    shiftKey: true,\n    preventDefault: () => {},\n  };\n  editor.canvasPointerdown(pointerDownEvent);\n  // Simulate a pointerup event at a different location.\n  const pointerUpEvent = {\n    offsetX: 100,\n    offsetY: 200,\n    preventDefault: () => {},\n  };\n  editor.canvasPointerup(pointerUpEvent);\n\n  // The patch should have created a straight line, resulting in a bezier path of one segment:\n  // [[start, start, end, end]].\n  if (!editor.paths || editor.paths.length !== 1) {\n    throw new Error(\"Expected a single path to be recorded.\");\n  }\n  const bezierPoints = editor.paths[0];\n  if (bezierPoints.length !== 1) {\n    throw new Error(\"Expected exactly one bezier segment for a straight line.\");\n  }\n  const segment = bezierPoints[0];\n  const expected = [[10, 20], [10, 20], [100, 200], [100, 200]];\n  for (let i = 0; i < 4; i++) {\n    if (Math.abs(segment[i][0] - expected[i][0]) > 0.001 ||\n        Math.abs(segment[i][1] - expected[i][1]) > 0.001) {\n      throw new Error(\"The bezier segment does not match the expected straight line.\");\n    }\n  }\n  window.requestAnimationFrame = originalRAF;\n});\n",
    "i2_gpt-4o": "it(\"should create a straight line when Shift key is held during drawing\", async () => {\n  const originalRAF = window.requestAnimationFrame;\n  window.requestAnimationFrame = (cb) => {\n    cb();\n    return 0;\n  };\n\n  const { InkEditor } = await import(\"../../src/display/editor/ink.js\");\n  const dummyUiManager = {\n    rebuild: () => {},\n    _signal: new AbortController().signal,\n  };\n  const dummyParent = {\n    setEditingState: () => {},\n  };\n  const div = document.createElement(\"div\");\n  // Create a canvas with defined dimensions.\n  const canvas = document.createElement(\"canvas\");\n  canvas.width = 500;\n  canvas.height = 500;\n\n  const editor = new InkEditor({\n    uiManager: dummyUiManager,\n    parent: dummyParent,\n    div,\n    canvas,\n  });\n  // Ensure the editor is in edit mode.\n  editor.isInEditMode = () => true;\n  // Simulate a pointerdown event with the Shift key pressed.\n  const pointerDownEvent = {\n    button: 0,\n    offsetX: 10,\n    offsetY: 20,\n    shiftKey: true,\n    preventDefault: () => {},\n  };\n  editor.canvasPointerdown(pointerDownEvent);\n  // Simulate a pointerup event at a different location.\n  const pointerUpEvent = {\n    offsetX: 100,\n    offsetY: 200,\n    preventDefault: () => {},\n  };\n  editor.canvasPointerup(pointerUpEvent);\n\n  // The patch should have created a straight line, resulting in a bezier path of one segment:\n  // [[start, start, end, end]].\n  if (!editor.paths || editor.paths.length !== 1) {\n    throw new Error(\"Expected a single path to be recorded.\");\n  }\n  const bezierPoints = editor.paths[0];\n  if (bezierPoints.length !== 1) {\n    throw new Error(\"Expected exactly one bezier segment for a straight line.\");\n  }\n  const segment = bezierPoints[0];\n  const expected = [[10, 20], [10, 20], [100, 200], [100, 200]];\n  for (let i = 0; i < 4; i++) {\n    if (Math.abs(segment[i][0] - expected[i][0]) > 0.001 ||\n        Math.abs(segment[i][1] - expected[i][1]) > 0.001) {\n      throw new Error(\"The bezier segment does not match the expected straight line.\");\n    }\n  }\n  window.requestAnimationFrame = originalRAF;\n});\n",
    "i2_llama-3.3-70b-versatile": "it(\"should create a straight line when Shift key is held during drawing\", async () => {\n  const originalRAF = window.requestAnimationFrame;\n  window.requestAnimationFrame = (cb) => {\n    cb();\n    return 0;\n  };\n\n  const { InkEditor } = await import(\"../../src/display/editor/ink.js\");\n  const dummyUiManager = {\n    rebuild: () => {},\n    _signal: new AbortController().signal,\n  };\n  const dummyParent = {\n    setEditingState: () => {},\n  };\n  const div = document.createElement(\"div\");\n  // Create a canvas with defined dimensions.\n  const canvas = document.createElement(\"canvas\");\n  canvas.width = 500;\n  canvas.height = 500;\n\n  const editor = new InkEditor({\n    uiManager: dummyUiManager,\n    parent: dummyParent,\n    div,\n    canvas,\n  });\n  // Ensure the editor is in edit mode.\n  editor.isInEditMode = () => true;\n  // Simulate a pointerdown event with the Shift key pressed.\n  const pointerDownEvent = {\n    button: 0,\n    offsetX: 10,\n    offsetY: 20,\n    shiftKey: true,\n    preventDefault: () => {},\n  };\n  editor.canvasPointerdown(pointerDownEvent);\n  // Simulate a pointerup event at a different location.\n  const pointerUpEvent = {\n    offsetX: 100,\n    offsetY: 200,\n    preventDefault: () => {},\n  };\n  editor.canvasPointerup(pointerUpEvent);\n\n  // The patch should have created a straight line, resulting in a bezier path of one segment:\n  // [[start, start, end, end]].\n  if (!editor.paths || editor.paths.length !== 1) {\n    throw new Error(\"Expected a single path to be recorded.\");\n  }\n  const bezierPoints = editor.paths[0];\n  if (bezierPoints.length !== 1) {\n    throw new Error(\"Expected exactly one bezier segment for a straight line.\");\n  }\n  const segment = bezierPoints[0];\n  const expected = [[10, 20], [10, 20], [100, 200], [100, 200]];\n  for (let i = 0; i < 4; i++) {\n    if (Math.abs(segment[i][0] - expected[i][0]) > 0.001 ||\n        Math.abs(segment[i][1] - expected[i][1]) > 0.001) {\n      throw new Error(\"The bezier segment does not match the expected straight line.\");\n    }\n  }\n  window.requestAnimationFrame = originalRAF;\n});\n",
    "i3_deepseek-r1-distill-llama-70b": "it(\"should create a straight line when Shift key is held during drawing\", async () => {\n  const originalRAF = window.requestAnimationFrame;\n  window.requestAnimationFrame = (cb) => {\n    cb();\n    return 0;\n  };\n\n  const { InkEditor } = await import(\"../../src/display/editor/ink.js\");\n  const dummyUiManager = {\n    rebuild: () => {},\n    _signal: new AbortController().signal,\n  };\n  const dummyParent = {\n    setEditingState: () => {},\n  };\n  const div = document.createElement(\"div\");\n  // Create a canvas with defined dimensions.\n  const canvas = document.createElement(\"canvas\");\n  canvas.width = 500;\n  canvas.height = 500;\n\n  const editor = new InkEditor({\n    uiManager: dummyUiManager,\n    parent: dummyParent,\n    div,\n    canvas,\n  });\n  // Ensure the editor is in edit mode.\n  editor.isInEditMode = () => true;\n  // Simulate a pointerdown event with the Shift key pressed.\n  const pointerDownEvent = {\n    button: 0,\n    offsetX: 10,\n    offsetY: 20,\n    shiftKey: true,\n    preventDefault: () => {},\n  };\n  editor.canvasPointerdown(pointerDownEvent);\n  // Simulate a pointerup event at a different location.\n  const pointerUpEvent = {\n    offsetX: 100,\n    offsetY: 200,\n    preventDefault: () => {},\n  };\n  editor.canvasPointerup(pointerUpEvent);\n\n  // The patch should have created a straight line, resulting in a bezier path of one segment:\n  // [[start, start, end, end]].\n  if (!editor.paths || editor.paths.length !== 1) {\n    throw new Error(\"Expected a single path to be recorded.\");\n  }\n  const bezierPoints = editor.paths[0];\n  if (bezierPoints.length !== 1) {\n    throw new Error(\"Expected exactly one bezier segment for a straight line.\");\n  }\n  const segment = bezierPoints[0];\n  const expected = [[10, 20], [10, 20], [100, 200], [100, 200]];\n  for (let i = 0; i < 4; i++) {\n    if (Math.abs(segment[i][0] - expected[i][0]) > 0.001 ||\n        Math.abs(segment[i][1] - expected[i][1]) > 0.001) {\n      throw new Error(\"The bezier segment does not match the expected straight line.\");\n    }\n  }\n  window.requestAnimationFrame = originalRAF;\n});\n",
    "i3_gpt-4o": "it(\"should create a straight line when Shift key is held during drawing\", async () => {\n  const originalRAF = window.requestAnimationFrame;\n  window.requestAnimationFrame = (cb) => {\n    cb();\n    return 0;\n  };\n\n  const { InkEditor } = await import(\"../../src/display/editor/ink.js\");\n  const dummyUiManager = {\n    rebuild: () => {},\n    _signal: new AbortController().signal,\n  };\n  const dummyParent = {\n    setEditingState: () => {},\n  };\n  const div = document.createElement(\"div\");\n  // Create a canvas with defined dimensions.\n  const canvas = document.createElement(\"canvas\");\n  canvas.width = 500;\n  canvas.height = 500;\n\n  const editor = new InkEditor({\n    uiManager: dummyUiManager,\n    parent: dummyParent,\n    div,\n    canvas,\n  });\n  // Ensure the editor is in edit mode.\n  editor.isInEditMode = () => true;\n  // Simulate a pointerdown event with the Shift key pressed.\n  const pointerDownEvent = {\n    button: 0,\n    offsetX: 10,\n    offsetY: 20,\n    shiftKey: true,\n    preventDefault: () => {},\n  };\n  editor.canvasPointerdown(pointerDownEvent);\n  // Simulate a pointerup event at a different location.\n  const pointerUpEvent = {\n    offsetX: 100,\n    offsetY: 200,\n    preventDefault: () => {},\n  };\n  editor.canvasPointerup(pointerUpEvent);\n\n  // The patch should have created a straight line, resulting in a bezier path of one segment:\n  // [[start, start, end, end]].\n  if (!editor.paths || editor.paths.length !== 1) {\n    throw new Error(\"Expected a single path to be recorded.\");\n  }\n  const bezierPoints = editor.paths[0];\n  if (bezierPoints.length !== 1) {\n    throw new Error(\"Expected exactly one bezier segment for a straight line.\");\n  }\n  const segment = bezierPoints[0];\n  const expected = [[10, 20], [10, 20], [100, 200], [100, 200]];\n  for (let i = 0; i < 4; i++) {\n    if (Math.abs(segment[i][0] - expected[i][0]) > 0.001 ||\n        Math.abs(segment[i][1] - expected[i][1]) > 0.001) {\n      throw new Error(\"The bezier segment does not match the expected straight line.\");\n    }\n  }\n  window.requestAnimationFrame = originalRAF;\n});\n",
    "i3_llama-3.3-70b-versatile": "it(\"should create a straight line when Shift key is held during drawing\", async () => {\n  const originalRAF = window.requestAnimationFrame;\n  window.requestAnimationFrame = (cb) => {\n    cb();\n    return 0;\n  };\n\n  const { InkEditor } = await import(\"../../src/display/editor/ink.js\");\n  const dummyUiManager = {\n    rebuild: () => {},\n    _signal: new AbortController().signal,\n  };\n  const dummyParent = {\n    setEditingState: () => {},\n  };\n  const div = document.createElement(\"div\");\n  // Create a canvas with defined dimensions.\n  const canvas = document.createElement(\"canvas\");\n  canvas.width = 500;\n  canvas.height = 500;\n\n  const editor = new InkEditor({\n    uiManager: dummyUiManager,\n    parent: dummyParent,\n    div,\n    canvas,\n  });\n  // Ensure the editor is in edit mode.\n  editor.isInEditMode = () => true;\n  // Simulate a pointerdown event with the Shift key pressed.\n  const pointerDownEvent = {\n    button: 0,\n    offsetX: 10,\n    offsetY: 20,\n    shiftKey: true,\n    preventDefault: () => {},\n  };\n  editor.canvasPointerdown(pointerDownEvent);\n  // Simulate a pointerup event at a different location.\n  const pointerUpEvent = {\n    offsetX: 100,\n    offsetY: 200,\n    preventDefault: () => {},\n  };\n  editor.canvasPointerup(pointerUpEvent);\n\n  // The patch should have created a straight line, resulting in a bezier path of one segment:\n  // [[start, start, end, end]].\n  if (!editor.paths || editor.paths.length !== 1) {\n    throw new Error(\"Expected a single path to be recorded.\");\n  }\n  const bezierPoints = editor.paths[0];\n  if (bezierPoints.length !== 1) {\n    throw new Error(\"Expected exactly one bezier segment for a straight line.\");\n  }\n  const segment = bezierPoints[0];\n  const expected = [[10, 20], [10, 20], [100, 200], [100, 200]];\n  for (let i = 0; i < 4; i++) {\n    if (Math.abs(segment[i][0] - expected[i][0]) > 0.001 ||\n        Math.abs(segment[i][1] - expected[i][1]) > 0.001) {\n      throw new Error(\"The bezier segment does not match the expected straight line.\");\n    }\n  }\n  window.requestAnimationFrame = originalRAF;\n});\n",
    "i4_deepseek-r1-distill-llama-70b": "it(\"should create a straight line when Shift key is held during drawing\", async () => {\n  const originalRAF = window.requestAnimationFrame;\n  window.requestAnimationFrame = (cb) => {\n    cb();\n    return 0;\n  };\n\n  const { InkEditor } = await import(\"../../src/display/editor/ink.js\");\n  const dummyUiManager = {\n    rebuild: () => {},\n    _signal: new AbortController().signal,\n  };\n  const dummyParent = {\n    setEditingState: () => {},\n  };\n  const div = document.createElement(\"div\");\n  // Create a canvas with defined dimensions.\n  const canvas = document.createElement(\"canvas\");\n  canvas.width = 500;\n  canvas.height = 500;\n\n  const editor = new InkEditor({\n    uiManager: dummyUiManager,\n    parent: dummyParent,\n    div,\n    canvas,\n  });\n  // Ensure the editor is in edit mode.\n  editor.isInEditMode = () => true;\n  // Simulate a pointerdown event with the Shift key pressed.\n  const pointerDownEvent = {\n    button: 0,\n    offsetX: 10,\n    offsetY: 20,\n    shiftKey: true,\n    preventDefault: () => {},\n  };\n  editor.canvasPointerdown(pointerDownEvent);\n  // Simulate a pointerup event at a different location.\n  const pointerUpEvent = {\n    offsetX: 100,\n    offsetY: 200,\n    preventDefault: () => {},\n  };\n  editor.canvasPointerup(pointerUpEvent);\n\n  // The patch should have created a straight line, resulting in a bezier path of one segment:\n  // [[start, start, end, end]].\n  if (!editor.paths || editor.paths.length !== 1) {\n    throw new Error(\"Expected a single path to be recorded.\");\n  }\n  const bezierPoints = editor.paths[0];\n  if (bezierPoints.length !== 1) {\n    throw new Error(\"Expected exactly one bezier segment for a straight line.\");\n  }\n  const segment = bezierPoints[0];\n  const expected = [[10, 20], [10, 20], [100, 200], [100, 200]];\n  for (let i = 0; i < 4; i++) {\n    if (Math.abs(segment[i][0] - expected[i][0]) > 0.001 ||\n        Math.abs(segment[i][1] - expected[i][1]) > 0.001) {\n      throw new Error(\"The bezier segment does not match the expected straight line.\");\n    }\n  }\n  window.requestAnimationFrame = originalRAF;\n});\n",
    "i4_gpt-4o": "it(\"should create a straight line when Shift key is held during drawing\", async () => {\n  const originalRAF = window.requestAnimationFrame;\n  window.requestAnimationFrame = (cb) => {\n    cb();\n    return 0;\n  };\n\n  const { InkEditor } = await import(\"../../src/display/editor/ink.js\");\n  const dummyUiManager = {\n    rebuild: () => {},\n    _signal: new AbortController().signal,\n  };\n  const dummyParent = {\n    setEditingState: () => {},\n  };\n  const div = document.createElement(\"div\");\n  // Create a canvas with defined dimensions.\n  const canvas = document.createElement(\"canvas\");\n  canvas.width = 500;\n  canvas.height = 500;\n\n  const editor = new InkEditor({\n    uiManager: dummyUiManager,\n    parent: dummyParent,\n    div,\n    canvas,\n  });\n  // Ensure the editor is in edit mode.\n  editor.isInEditMode = () => true;\n  // Simulate a pointerdown event with the Shift key pressed.\n  const pointerDownEvent = {\n    button: 0,\n    offsetX: 10,\n    offsetY: 20,\n    shiftKey: true,\n    preventDefault: () => {},\n  };\n  editor.canvasPointerdown(pointerDownEvent);\n  // Simulate a pointerup event at a different location.\n  const pointerUpEvent = {\n    offsetX: 100,\n    offsetY: 200,\n    preventDefault: () => {},\n  };\n  editor.canvasPointerup(pointerUpEvent);\n\n  // The patch should have created a straight line, resulting in a bezier path of one segment:\n  // [[start, start, end, end]].\n  if (!editor.paths || editor.paths.length !== 1) {\n    throw new Error(\"Expected a single path to be recorded.\");\n  }\n  const bezierPoints = editor.paths[0];\n  if (bezierPoints.length !== 1) {\n    throw new Error(\"Expected exactly one bezier segment for a straight line.\");\n  }\n  const segment = bezierPoints[0];\n  const expected = [[10, 20], [10, 20], [100, 200], [100, 200]];\n  for (let i = 0; i < 4; i++) {\n    if (Math.abs(segment[i][0] - expected[i][0]) > 0.001 ||\n        Math.abs(segment[i][1] - expected[i][1]) > 0.001) {\n      throw new Error(\"The bezier segment does not match the expected straight line.\");\n    }\n  }\n  window.requestAnimationFrame = originalRAF;\n});\n",
    "i4_llama-3.3-70b-versatile": "it(\"should create a straight line when Shift key is held during drawing\", async () => {\n  const originalRAF = window.requestAnimationFrame;\n  window.requestAnimationFrame = (cb) => {\n    cb();\n    return 0;\n  };\n\n  const { InkEditor } = await import(\"../../src/display/editor/ink.js\");\n  const dummyUiManager = {\n    rebuild: () => {},\n    _signal: new AbortController().signal,\n  };\n  const dummyParent = {\n    setEditingState: () => {},\n  };\n  const div = document.createElement(\"div\");\n  // Create a canvas with defined dimensions.\n  const canvas = document.createElement(\"canvas\");\n  canvas.width = 500;\n  canvas.height = 500;\n\n  const editor = new InkEditor({\n    uiManager: dummyUiManager,\n    parent: dummyParent,\n    div,\n    canvas,\n  });\n  // Ensure the editor is in edit mode.\n  editor.isInEditMode = () => true;\n  // Simulate a pointerdown event with the Shift key pressed.\n  const pointerDownEvent = {\n    button: 0,\n    offsetX: 10,\n    offsetY: 20,\n    shiftKey: true,\n    preventDefault: () => {},\n  };\n  editor.canvasPointerdown(pointerDownEvent);\n  // Simulate a pointerup event at a different location.\n  const pointerUpEvent = {\n    offsetX: 100,\n    offsetY: 200,\n    preventDefault: () => {},\n  };\n  editor.canvasPointerup(pointerUpEvent);\n\n  // The patch should have created a straight line, resulting in a bezier path of one segment:\n  // [[start, start, end, end]].\n  if (!editor.paths || editor.paths.length !== 1) {\n    throw new Error(\"Expected a single path to be recorded.\");\n  }\n  const bezierPoints = editor.paths[0];\n  if (bezierPoints.length !== 1) {\n    throw new Error(\"Expected exactly one bezier segment for a straight line.\");\n  }\n  const segment = bezierPoints[0];\n  const expected = [[10, 20], [10, 20], [100, 200], [100, 200]];\n  for (let i = 0; i < 4; i++) {\n    if (Math.abs(segment[i][0] - expected[i][0]) > 0.001 ||\n        Math.abs(segment[i][1] - expected[i][1]) > 0.001) {\n      throw new Error(\"The bezier segment does not match the expected straight line.\");\n    }\n  }\n  window.requestAnimationFrame = originalRAF;\n});\n",
    "i5_deepseek-r1-distill-llama-70b": "it(\"should create a straight line when Shift key is held during drawing\", async () => {\n  const originalRAF = window.requestAnimationFrame;\n  window.requestAnimationFrame = (cb) => {\n    cb();\n    return 0;\n  };\n\n  const { InkEditor } = await import(\"../../src/display/editor/ink.js\");\n  const dummyUiManager = {\n    rebuild: () => {},\n    _signal: new AbortController().signal,\n  };\n  const dummyParent = {\n    setEditingState: () => {},\n  };\n  const div = document.createElement(\"div\");\n  // Create a canvas with defined dimensions.\n  const canvas = document.createElement(\"canvas\");\n  canvas.width = 500;\n  canvas.height = 500;\n\n  const editor = new InkEditor({\n    uiManager: dummyUiManager,\n    parent: dummyParent,\n    div,\n    canvas,\n  });\n  // Ensure the editor is in edit mode.\n  editor.isInEditMode = () => true;\n  // Simulate a pointerdown event with the Shift key pressed.\n  const pointerDownEvent = {\n    button: 0,\n    offsetX: 10,\n    offsetY: 20,\n    shiftKey: true,\n    preventDefault: () => {},\n  };\n  editor.canvasPointerdown(pointerDownEvent);\n  // Simulate a pointerup event at a different location.\n  const pointerUpEvent = {\n    offsetX: 100,\n    offsetY: 200,\n    preventDefault: () => {},\n  };\n  editor.canvasPointerup(pointerUpEvent);\n\n  // The patch should have created a straight line, resulting in a bezier path of one segment:\n  // [[start, start, end, end]].\n  if (!editor.paths || editor.paths.length !== 1) {\n    throw new Error(\"Expected a single path to be recorded.\");\n  }\n  const bezierPoints = editor.paths[0];\n  if (bezierPoints.length !== 1) {\n    throw new Error(\"Expected exactly one bezier segment for a straight line.\");\n  }\n  const segment = bezierPoints[0];\n  const expected = [[10, 20], [10, 20], [100, 200], [100, 200]];\n  for (let i = 0; i < 4; i++) {\n    if (Math.abs(segment[i][0] - expected[i][0]) > 0.001 ||\n        Math.abs(segment[i][1] - expected[i][1]) > 0.001) {\n      throw new Error(\"The bezier segment does not match the expected straight line.\");\n    }\n  }\n  window.requestAnimationFrame = originalRAF;\n});\n",
    "i5_gpt-4o": "it(\"should create a straight line when Shift key is held during drawing\", async () => {\n  const originalRAF = window.requestAnimationFrame;\n  window.requestAnimationFrame = (cb) => {\n    cb();\n    return 0;\n  };\n\n  const { InkEditor } = await import(\"../../src/display/editor/ink.js\");\n  const dummyUiManager = {\n    rebuild: () => {},\n    _signal: new AbortController().signal,\n  };\n  const dummyParent = {\n    setEditingState: () => {},\n  };\n  const div = document.createElement(\"div\");\n  // Create a canvas with defined dimensions.\n  const canvas = document.createElement(\"canvas\");\n  canvas.width = 500;\n  canvas.height = 500;\n\n  const editor = new InkEditor({\n    uiManager: dummyUiManager,\n    parent: dummyParent,\n    div,\n    canvas,\n  });\n  // Ensure the editor is in edit mode.\n  editor.isInEditMode = () => true;\n  // Simulate a pointerdown event with the Shift key pressed.\n  const pointerDownEvent = {\n    button: 0,\n    offsetX: 10,\n    offsetY: 20,\n    shiftKey: true,\n    preventDefault: () => {},\n  };\n  editor.canvasPointerdown(pointerDownEvent);\n  // Simulate a pointerup event at a different location.\n  const pointerUpEvent = {\n    offsetX: 100,\n    offsetY: 200,\n    preventDefault: () => {},\n  };\n  editor.canvasPointerup(pointerUpEvent);\n\n  // The patch should have created a straight line, resulting in a bezier path of one segment:\n  // [[start, start, end, end]].\n  if (!editor.paths || editor.paths.length !== 1) {\n    throw new Error(\"Expected a single path to be recorded.\");\n  }\n  const bezierPoints = editor.paths[0];\n  if (bezierPoints.length !== 1) {\n    throw new Error(\"Expected exactly one bezier segment for a straight line.\");\n  }\n  const segment = bezierPoints[0];\n  const expected = [[10, 20], [10, 20], [100, 200], [100, 200]];\n  for (let i = 0; i < 4; i++) {\n    if (Math.abs(segment[i][0] - expected[i][0]) > 0.001 ||\n        Math.abs(segment[i][1] - expected[i][1]) > 0.001) {\n      throw new Error(\"The bezier segment does not match the expected straight line.\");\n    }\n  }\n  window.requestAnimationFrame = originalRAF;\n});\n",
    "i5_llama-3.3-70b-versatile": "it(\"should create a straight line when Shift key is held during drawing\", async () => {\n  const originalRAF = window.requestAnimationFrame;\n  window.requestAnimationFrame = (cb) => {\n    cb();\n    return 0;\n  };\n\n  const { InkEditor } = await import(\"../../src/display/editor/ink.js\");\n  const dummyUiManager = {\n    rebuild: () => {},\n    _signal: new AbortController().signal,\n  };\n  const dummyParent = {\n    setEditingState: () => {},\n  };\n  const div = document.createElement(\"div\");\n  // Create a canvas with defined dimensions.\n  const canvas = document.createElement(\"canvas\");\n  canvas.width = 500;\n  canvas.height = 500;\n\n  const editor = new InkEditor({\n    uiManager: dummyUiManager,\n    parent: dummyParent,\n    div,\n    canvas,\n  });\n  // Ensure the editor is in edit mode.\n  editor.isInEditMode = () => true;\n  // Simulate a pointerdown event with the Shift key pressed.\n  const pointerDownEvent = {\n    button: 0,\n    offsetX: 10,\n    offsetY: 20,\n    shiftKey: true,\n    preventDefault: () => {},\n  };\n  editor.canvasPointerdown(pointerDownEvent);\n  // Simulate a pointerup event at a different location.\n  const pointerUpEvent = {\n    offsetX: 100,\n    offsetY: 200,\n    preventDefault: () => {},\n  };\n  editor.canvasPointerup(pointerUpEvent);\n\n  // The patch should have created a straight line, resulting in a bezier path of one segment:\n  // [[start, start, end, end]].\n  if (!editor.paths || editor.paths.length !== 1) {\n    throw new Error(\"Expected a single path to be recorded.\");\n  }\n  const bezierPoints = editor.paths[0];\n  if (bezierPoints.length !== 1) {\n    throw new Error(\"Expected exactly one bezier segment for a straight line.\");\n  }\n  const segment = bezierPoints[0];\n  const expected = [[10, 20], [10, 20], [100, 200], [100, 200]];\n  for (let i = 0; i < 4; i++) {\n    if (Math.abs(segment[i][0] - expected[i][0]) > 0.001 ||\n        Math.abs(segment[i][1] - expected[i][1]) > 0.001) {\n      throw new Error(\"The bezier segment does not match the expected straight line.\");\n    }\n  }\n  window.requestAnimationFrame = originalRAF;\n});\n"
  },
  "18628": {
    "i1_deepseek-r1-distill-llama-70b": "it(\"should correctly map the Euro character for fonts mapped to a standard font\", async () => {\n  const { Font } = await import(\"../../src/core/fonts.js\");\n  const { getGlyphsUnicode } = await import(\"../../src/core/glyphlist.js\");\n  const { IdentityToUnicodeMap } = await import(\"../../src/core/to_unicode_map.js\");\n  const file = { isEmpty: true };\n  const properties = {\n    loadedName: \"HelveticaNeue\",\n    differences: { 128: \"Euro\" },\n    widths: {},\n    defaultWidth: 600,\n    composite: false,\n    cMap: null,\n    capHeight: 800,\n    ascent: 900,\n    descent: -200,\n    fontMatrix: [1, 0, 0, 1, 0, 0],\n    bbox: [0, 0, 1000, 1000],\n    defaultEncoding: { 128: \"Euro\" },\n    toUnicode: new IdentityToUnicodeMap([]),\n    cidEncoding: \"Identity-H\",\n    vertical: false,\n    systemFontInfo: { guessFallback: false, css: \"\" },\n    type: \"CIDFontType2\",\n    subtype: \"Type1\",\n    flags: 0,\n    isSimulatedFlags: false,\n  };\n  const font = new Font(\"HelveticaNeue\", file, properties);\n  const mappedEuro = font.toFontChar[128];\n  const expectedEuro = getGlyphsUnicode()[\"Euro\"];\n  if (mappedEuro !== expectedEuro) {\n    throw new Error(`Expected Euro mapping (${expectedEuro}) but got (${mappedEuro})`);\n  }\n});",
    "i1_gpt-4o": "it(\"should correctly map the Euro character for fonts mapped to a standard font\", async () => {\n  const { Font } = await import(\"../../src/core/fonts.js\");\n  const { getGlyphsUnicode } = await import(\"../../src/core/glyphlist.js\");\n  const { IdentityToUnicodeMap } = await import(\"../../src/core/to_unicode_map.js\");\n  const file = { isEmpty: true };\n  const properties = {\n    loadedName: \"HelveticaNeue\",\n    differences: { 128: \"Euro\" },\n    widths: {},\n    defaultWidth: 600,\n    composite: false,\n    cMap: null,\n    capHeight: 800,\n    ascent: 900,\n    descent: -200,\n    fontMatrix: [1, 0, 0, 1, 0, 0],\n    bbox: [0, 0, 1000, 1000],\n    defaultEncoding: { 128: \"Euro\" },\n    toUnicode: new IdentityToUnicodeMap([]),\n    cidEncoding: \"Identity-H\",\n    vertical: false,\n    systemFontInfo: { guessFallback: false, css: \"\" },\n    type: \"CIDFontType2\",\n    subtype: \"Type1\",\n    flags: 0,\n    isSimulatedFlags: false,\n  };\n  const font = new Font(\"HelveticaNeue\", file, properties);\n  const mappedEuro = font.toFontChar[128];\n  const expectedEuro = getGlyphsUnicode()[\"Euro\"];\n  if (mappedEuro !== expectedEuro) {\n    throw new Error(`Expected Euro mapping (${expectedEuro}) but got (${mappedEuro})`);\n  }\n});",
    "i1_llama-3.3-70b-versatile": "it(\"should correctly map the Euro character for fonts mapped to a standard font\", async () => {\n  const { Font } = await import(\"../../src/core/fonts.js\");\n  const { getGlyphsUnicode } = await import(\"../../src/core/glyphlist.js\");\n  const { IdentityToUnicodeMap } = await import(\"../../src/core/to_unicode_map.js\");\n  const file = { isEmpty: true };\n  const properties = {\n    loadedName: \"HelveticaNeue\",\n    differences: { 128: \"Euro\" },\n    widths: {},\n    defaultWidth: 600,\n    composite: false,\n    cMap: null,\n    capHeight: 800,\n    ascent: 900,\n    descent: -200,\n    fontMatrix: [1, 0, 0, 1, 0, 0],\n    bbox: [0, 0, 1000, 1000],\n    defaultEncoding: { 128: \"Euro\" },\n    toUnicode: new IdentityToUnicodeMap([]),\n    cidEncoding: \"Identity-H\",\n    vertical: false,\n    systemFontInfo: { guessFallback: false, css: \"\" },\n    type: \"CIDFontType2\",\n    subtype: \"Type1\",\n    flags: 0,\n    isSimulatedFlags: false,\n  };\n  const font = new Font(\"HelveticaNeue\", file, properties);\n  const mappedEuro = font.toFontChar[128];\n  const expectedEuro = getGlyphsUnicode()[\"Euro\"];\n  if (mappedEuro !== expectedEuro) {\n    throw new Error(`Expected Euro mapping (${expectedEuro}) but got (${mappedEuro})`);\n  }\n});",
    "i1_MOCK": "it(\"should correctly map the Euro character for fonts mapped to a standard font\", async () => {\n  const { Font } = await import(\"../../src/core/fonts.js\");\n  const { getGlyphsUnicode } = await import(\"../../src/core/glyphlist.js\");\n  const { IdentityToUnicodeMap } = await import(\"../../src/core/to_unicode_map.js\");\n  const file = { isEmpty: true };\n  const properties = {\n    loadedName: \"HelveticaNeue\",\n    differences: { 128: \"Euro\" },\n    widths: {},\n    defaultWidth: 600,\n    composite: false,\n    cMap: null,\n    capHeight: 800,\n    ascent: 900,\n    descent: -200,\n    fontMatrix: [1, 0, 0, 1, 0, 0],\n    bbox: [0, 0, 1000, 1000],\n    defaultEncoding: { 128: \"Euro\" },\n    toUnicode: new IdentityToUnicodeMap([]),\n    cidEncoding: \"Identity-H\",\n    vertical: false,\n    systemFontInfo: { guessFallback: false, css: \"\" },\n    type: \"CIDFontType2\",\n    subtype: \"Type1\",\n    flags: 0,\n    isSimulatedFlags: false,\n  };\n  const font = new Font(\"HelveticaNeue\", file, properties);\n  const mappedEuro = font.toFontChar[128];\n  const expectedEuro = getGlyphsUnicode()[\"Euro\"];\n  if (mappedEuro !== expectedEuro) {\n    throw new Error(`Expected Euro mapping (${expectedEuro}) but got (${mappedEuro})`);\n  }\n});",
    "i2_deepseek-r1-distill-llama-70b": "it(\"should correctly map the Euro character for fonts mapped to a standard font\", async () => {\n  const { Font } = await import(\"../../src/core/fonts.js\");\n  const { getGlyphsUnicode } = await import(\"../../src/core/glyphlist.js\");\n  const { IdentityToUnicodeMap } = await import(\"../../src/core/to_unicode_map.js\");\n  const file = { isEmpty: true };\n  const properties = {\n    loadedName: \"HelveticaNeue\",\n    differences: { 128: \"Euro\" },\n    widths: {},\n    defaultWidth: 600,\n    composite: false,\n    cMap: null,\n    capHeight: 800,\n    ascent: 900,\n    descent: -200,\n    fontMatrix: [1, 0, 0, 1, 0, 0],\n    bbox: [0, 0, 1000, 1000],\n    defaultEncoding: { 128: \"Euro\" },\n    toUnicode: new IdentityToUnicodeMap([]),\n    cidEncoding: \"Identity-H\",\n    vertical: false,\n    systemFontInfo: { guessFallback: false, css: \"\" },\n    type: \"CIDFontType2\",\n    subtype: \"Type1\",\n    flags: 0,\n    isSimulatedFlags: false,\n  };\n  const font = new Font(\"HelveticaNeue\", file, properties);\n  const mappedEuro = font.toFontChar[128];\n  const expectedEuro = getGlyphsUnicode()[\"Euro\"];\n  if (mappedEuro !== expectedEuro) {\n    throw new Error(`Expected Euro mapping (${expectedEuro}) but got (${mappedEuro})`);\n  }\n});",
    "i2_gpt-4o": "it(\"should correctly map the Euro character for fonts mapped to a standard font\", async () => {\n  const { Font } = await import(\"../../src/core/fonts.js\");\n  const { getGlyphsUnicode } = await import(\"../../src/core/glyphlist.js\");\n  const { IdentityToUnicodeMap } = await import(\"../../src/core/to_unicode_map.js\");\n  const file = { isEmpty: true };\n  const properties = {\n    loadedName: \"HelveticaNeue\",\n    differences: { 128: \"Euro\" },\n    widths: {},\n    defaultWidth: 600,\n    composite: false,\n    cMap: null,\n    capHeight: 800,\n    ascent: 900,\n    descent: -200,\n    fontMatrix: [1, 0, 0, 1, 0, 0],\n    bbox: [0, 0, 1000, 1000],\n    defaultEncoding: { 128: \"Euro\" },\n    toUnicode: new IdentityToUnicodeMap([]),\n    cidEncoding: \"Identity-H\",\n    vertical: false,\n    systemFontInfo: { guessFallback: false, css: \"\" },\n    type: \"CIDFontType2\",\n    subtype: \"Type1\",\n    flags: 0,\n    isSimulatedFlags: false,\n  };\n  const font = new Font(\"HelveticaNeue\", file, properties);\n  const mappedEuro = font.toFontChar[128];\n  const expectedEuro = getGlyphsUnicode()[\"Euro\"];\n  if (mappedEuro !== expectedEuro) {\n    throw new Error(`Expected Euro mapping (${expectedEuro}) but got (${mappedEuro})`);\n  }\n});",
    "i2_llama-3.3-70b-versatile": "it(\"should correctly map the Euro character for fonts mapped to a standard font\", async () => {\n  const { Font } = await import(\"../../src/core/fonts.js\");\n  const { getGlyphsUnicode } = await import(\"../../src/core/glyphlist.js\");\n  const { IdentityToUnicodeMap } = await import(\"../../src/core/to_unicode_map.js\");\n  const file = { isEmpty: true };\n  const properties = {\n    loadedName: \"HelveticaNeue\",\n    differences: { 128: \"Euro\" },\n    widths: {},\n    defaultWidth: 600,\n    composite: false,\n    cMap: null,\n    capHeight: 800,\n    ascent: 900,\n    descent: -200,\n    fontMatrix: [1, 0, 0, 1, 0, 0],\n    bbox: [0, 0, 1000, 1000],\n    defaultEncoding: { 128: \"Euro\" },\n    toUnicode: new IdentityToUnicodeMap([]),\n    cidEncoding: \"Identity-H\",\n    vertical: false,\n    systemFontInfo: { guessFallback: false, css: \"\" },\n    type: \"CIDFontType2\",\n    subtype: \"Type1\",\n    flags: 0,\n    isSimulatedFlags: false,\n  };\n  const font = new Font(\"HelveticaNeue\", file, properties);\n  const mappedEuro = font.toFontChar[128];\n  const expectedEuro = getGlyphsUnicode()[\"Euro\"];\n  if (mappedEuro !== expectedEuro) {\n    throw new Error(`Expected Euro mapping (${expectedEuro}) but got (${mappedEuro})`);\n  }\n});",
    "i3_deepseek-r1-distill-llama-70b": "it(\"should correctly map the Euro character for fonts mapped to a standard font\", async () => {\n  const { Font } = await import(\"../../src/core/fonts.js\");\n  const { getGlyphsUnicode } = await import(\"../../src/core/glyphlist.js\");\n  const { IdentityToUnicodeMap } = await import(\"../../src/core/to_unicode_map.js\");\n  const file = { isEmpty: true };\n  const properties = {\n    loadedName: \"HelveticaNeue\",\n    differences: { 128: \"Euro\" },\n    widths: {},\n    defaultWidth: 600,\n    composite: false,\n    cMap: null,\n    capHeight: 800,\n    ascent: 900,\n    descent: -200,\n    fontMatrix: [1, 0, 0, 1, 0, 0],\n    bbox: [0, 0, 1000, 1000],\n    defaultEncoding: { 128: \"Euro\" },\n    toUnicode: new IdentityToUnicodeMap([]),\n    cidEncoding: \"Identity-H\",\n    vertical: false,\n    systemFontInfo: { guessFallback: false, css: \"\" },\n    type: \"CIDFontType2\",\n    subtype: \"Type1\",\n    flags: 0,\n    isSimulatedFlags: false,\n  };\n  const font = new Font(\"HelveticaNeue\", file, properties);\n  const mappedEuro = font.toFontChar[128];\n  const expectedEuro = getGlyphsUnicode()[\"Euro\"];\n  if (mappedEuro !== expectedEuro) {\n    throw new Error(`Expected Euro mapping (${expectedEuro}) but got (${mappedEuro})`);\n  }\n});",
    "i3_gpt-4o": "it(\"should correctly map the Euro character for fonts mapped to a standard font\", async () => {\n  const { Font } = await import(\"../../src/core/fonts.js\");\n  const { getGlyphsUnicode } = await import(\"../../src/core/glyphlist.js\");\n  const { IdentityToUnicodeMap } = await import(\"../../src/core/to_unicode_map.js\");\n  const file = { isEmpty: true };\n  const properties = {\n    loadedName: \"HelveticaNeue\",\n    differences: { 128: \"Euro\" },\n    widths: {},\n    defaultWidth: 600,\n    composite: false,\n    cMap: null,\n    capHeight: 800,\n    ascent: 900,\n    descent: -200,\n    fontMatrix: [1, 0, 0, 1, 0, 0],\n    bbox: [0, 0, 1000, 1000],\n    defaultEncoding: { 128: \"Euro\" },\n    toUnicode: new IdentityToUnicodeMap([]),\n    cidEncoding: \"Identity-H\",\n    vertical: false,\n    systemFontInfo: { guessFallback: false, css: \"\" },\n    type: \"CIDFontType2\",\n    subtype: \"Type1\",\n    flags: 0,\n    isSimulatedFlags: false,\n  };\n  const font = new Font(\"HelveticaNeue\", file, properties);\n  const mappedEuro = font.toFontChar[128];\n  const expectedEuro = getGlyphsUnicode()[\"Euro\"];\n  if (mappedEuro !== expectedEuro) {\n    throw new Error(`Expected Euro mapping (${expectedEuro}) but got (${mappedEuro})`);\n  }\n});",
    "i3_llama-3.3-70b-versatile": "it(\"should correctly map the Euro character for fonts mapped to a standard font\", async () => {\n  const { Font } = await import(\"../../src/core/fonts.js\");\n  const { getGlyphsUnicode } = await import(\"../../src/core/glyphlist.js\");\n  const { IdentityToUnicodeMap } = await import(\"../../src/core/to_unicode_map.js\");\n  const file = { isEmpty: true };\n  const properties = {\n    loadedName: \"HelveticaNeue\",\n    differences: { 128: \"Euro\" },\n    widths: {},\n    defaultWidth: 600,\n    composite: false,\n    cMap: null,\n    capHeight: 800,\n    ascent: 900,\n    descent: -200,\n    fontMatrix: [1, 0, 0, 1, 0, 0],\n    bbox: [0, 0, 1000, 1000],\n    defaultEncoding: { 128: \"Euro\" },\n    toUnicode: new IdentityToUnicodeMap([]),\n    cidEncoding: \"Identity-H\",\n    vertical: false,\n    systemFontInfo: { guessFallback: false, css: \"\" },\n    type: \"CIDFontType2\",\n    subtype: \"Type1\",\n    flags: 0,\n    isSimulatedFlags: false,\n  };\n  const font = new Font(\"HelveticaNeue\", file, properties);\n  const mappedEuro = font.toFontChar[128];\n  const expectedEuro = getGlyphsUnicode()[\"Euro\"];\n  if (mappedEuro !== expectedEuro) {\n    throw new Error(`Expected Euro mapping (${expectedEuro}) but got (${mappedEuro})`);\n  }\n});",
    "i4_deepseek-r1-distill-llama-70b": "it(\"should correctly map the Euro character for fonts mapped to a standard font\", async () => {\n  const { Font } = await import(\"../../src/core/fonts.js\");\n  const { getGlyphsUnicode } = await import(\"../../src/core/glyphlist.js\");\n  const { IdentityToUnicodeMap } = await import(\"../../src/core/to_unicode_map.js\");\n  const file = { isEmpty: true };\n  const properties = {\n    loadedName: \"HelveticaNeue\",\n    differences: { 128: \"Euro\" },\n    widths: {},\n    defaultWidth: 600,\n    composite: false,\n    cMap: null,\n    capHeight: 800,\n    ascent: 900,\n    descent: -200,\n    fontMatrix: [1, 0, 0, 1, 0, 0],\n    bbox: [0, 0, 1000, 1000],\n    defaultEncoding: { 128: \"Euro\" },\n    toUnicode: new IdentityToUnicodeMap([]),\n    cidEncoding: \"Identity-H\",\n    vertical: false,\n    systemFontInfo: { guessFallback: false, css: \"\" },\n    type: \"CIDFontType2\",\n    subtype: \"Type1\",\n    flags: 0,\n    isSimulatedFlags: false,\n  };\n  const font = new Font(\"HelveticaNeue\", file, properties);\n  const mappedEuro = font.toFontChar[128];\n  const expectedEuro = getGlyphsUnicode()[\"Euro\"];\n  if (mappedEuro !== expectedEuro) {\n    throw new Error(`Expected Euro mapping (${expectedEuro}) but got (${mappedEuro})`);\n  }\n});",
    "i4_gpt-4o": "it(\"should correctly map the Euro character for fonts mapped to a standard font\", async () => {\n  const { Font } = await import(\"../../src/core/fonts.js\");\n  const { getGlyphsUnicode } = await import(\"../../src/core/glyphlist.js\");\n  const { IdentityToUnicodeMap } = await import(\"../../src/core/to_unicode_map.js\");\n  const file = { isEmpty: true };\n  const properties = {\n    loadedName: \"HelveticaNeue\",\n    differences: { 128: \"Euro\" },\n    widths: {},\n    defaultWidth: 600,\n    composite: false,\n    cMap: null,\n    capHeight: 800,\n    ascent: 900,\n    descent: -200,\n    fontMatrix: [1, 0, 0, 1, 0, 0],\n    bbox: [0, 0, 1000, 1000],\n    defaultEncoding: { 128: \"Euro\" },\n    toUnicode: new IdentityToUnicodeMap([]),\n    cidEncoding: \"Identity-H\",\n    vertical: false,\n    systemFontInfo: { guessFallback: false, css: \"\" },\n    type: \"CIDFontType2\",\n    subtype: \"Type1\",\n    flags: 0,\n    isSimulatedFlags: false,\n  };\n  const font = new Font(\"HelveticaNeue\", file, properties);\n  const mappedEuro = font.toFontChar[128];\n  const expectedEuro = getGlyphsUnicode()[\"Euro\"];\n  if (mappedEuro !== expectedEuro) {\n    throw new Error(`Expected Euro mapping (${expectedEuro}) but got (${mappedEuro})`);\n  }\n});",
    "i4_llama-3.3-70b-versatile": "it(\"should correctly map the Euro character for fonts mapped to a standard font\", async () => {\n  const { Font } = await import(\"../../src/core/fonts.js\");\n  const { getGlyphsUnicode } = await import(\"../../src/core/glyphlist.js\");\n  const { IdentityToUnicodeMap } = await import(\"../../src/core/to_unicode_map.js\");\n  const file = { isEmpty: true };\n  const properties = {\n    loadedName: \"HelveticaNeue\",\n    differences: { 128: \"Euro\" },\n    widths: {},\n    defaultWidth: 600,\n    composite: false,\n    cMap: null,\n    capHeight: 800,\n    ascent: 900,\n    descent: -200,\n    fontMatrix: [1, 0, 0, 1, 0, 0],\n    bbox: [0, 0, 1000, 1000],\n    defaultEncoding: { 128: \"Euro\" },\n    toUnicode: new IdentityToUnicodeMap([]),\n    cidEncoding: \"Identity-H\",\n    vertical: false,\n    systemFontInfo: { guessFallback: false, css: \"\" },\n    type: \"CIDFontType2\",\n    subtype: \"Type1\",\n    flags: 0,\n    isSimulatedFlags: false,\n  };\n  const font = new Font(\"HelveticaNeue\", file, properties);\n  const mappedEuro = font.toFontChar[128];\n  const expectedEuro = getGlyphsUnicode()[\"Euro\"];\n  if (mappedEuro !== expectedEuro) {\n    throw new Error(`Expected Euro mapping (${expectedEuro}) but got (${mappedEuro})`);\n  }\n});",
    "i5_deepseek-r1-distill-llama-70b": "it(\"should correctly map the Euro character for fonts mapped to a standard font\", async () => {\n  const { Font } = await import(\"../../src/core/fonts.js\");\n  const { getGlyphsUnicode } = await import(\"../../src/core/glyphlist.js\");\n  const { IdentityToUnicodeMap } = await import(\"../../src/core/to_unicode_map.js\");\n  const file = { isEmpty: true };\n  const properties = {\n    loadedName: \"HelveticaNeue\",\n    differences: { 128: \"Euro\" },\n    widths: {},\n    defaultWidth: 600,\n    composite: false,\n    cMap: null,\n    capHeight: 800,\n    ascent: 900,\n    descent: -200,\n    fontMatrix: [1, 0, 0, 1, 0, 0],\n    bbox: [0, 0, 1000, 1000],\n    defaultEncoding: { 128: \"Euro\" },\n    toUnicode: new IdentityToUnicodeMap([]),\n    cidEncoding: \"Identity-H\",\n    vertical: false,\n    systemFontInfo: { guessFallback: false, css: \"\" },\n    type: \"CIDFontType2\",\n    subtype: \"Type1\",\n    flags: 0,\n    isSimulatedFlags: false,\n  };\n  const font = new Font(\"HelveticaNeue\", file, properties);\n  const mappedEuro = font.toFontChar[128];\n  const expectedEuro = getGlyphsUnicode()[\"Euro\"];\n  if (mappedEuro !== expectedEuro) {\n    throw new Error(`Expected Euro mapping (${expectedEuro}) but got (${mappedEuro})`);\n  }\n});",
    "i5_gpt-4o": "it(\"should correctly map the Euro character for fonts mapped to a standard font\", async () => {\n  const { Font } = await import(\"../../src/core/fonts.js\");\n  const { getGlyphsUnicode } = await import(\"../../src/core/glyphlist.js\");\n  const { IdentityToUnicodeMap } = await import(\"../../src/core/to_unicode_map.js\");\n  const file = { isEmpty: true };\n  const properties = {\n    loadedName: \"HelveticaNeue\",\n    differences: { 128: \"Euro\" },\n    widths: {},\n    defaultWidth: 600,\n    composite: false,\n    cMap: null,\n    capHeight: 800,\n    ascent: 900,\n    descent: -200,\n    fontMatrix: [1, 0, 0, 1, 0, 0],\n    bbox: [0, 0, 1000, 1000],\n    defaultEncoding: { 128: \"Euro\" },\n    toUnicode: new IdentityToUnicodeMap([]),\n    cidEncoding: \"Identity-H\",\n    vertical: false,\n    systemFontInfo: { guessFallback: false, css: \"\" },\n    type: \"CIDFontType2\",\n    subtype: \"Type1\",\n    flags: 0,\n    isSimulatedFlags: false,\n  };\n  const font = new Font(\"HelveticaNeue\", file, properties);\n  const mappedEuro = font.toFontChar[128];\n  const expectedEuro = getGlyphsUnicode()[\"Euro\"];\n  if (mappedEuro !== expectedEuro) {\n    throw new Error(`Expected Euro mapping (${expectedEuro}) but got (${mappedEuro})`);\n  }\n});",
    "i5_llama-3.3-70b-versatile": "it(\"should correctly map the Euro character for fonts mapped to a standard font\", async () => {\n  const { Font } = await import(\"../../src/core/fonts.js\");\n  const { getGlyphsUnicode } = await import(\"../../src/core/glyphlist.js\");\n  const { IdentityToUnicodeMap } = await import(\"../../src/core/to_unicode_map.js\");\n  const file = { isEmpty: true };\n  const properties = {\n    loadedName: \"HelveticaNeue\",\n    differences: { 128: \"Euro\" },\n    widths: {},\n    defaultWidth: 600,\n    composite: false,\n    cMap: null,\n    capHeight: 800,\n    ascent: 900,\n    descent: -200,\n    fontMatrix: [1, 0, 0, 1, 0, 0],\n    bbox: [0, 0, 1000, 1000],\n    defaultEncoding: { 128: \"Euro\" },\n    toUnicode: new IdentityToUnicodeMap([]),\n    cidEncoding: \"Identity-H\",\n    vertical: false,\n    systemFontInfo: { guessFallback: false, css: \"\" },\n    type: \"CIDFontType2\",\n    subtype: \"Type1\",\n    flags: 0,\n    isSimulatedFlags: false,\n  };\n  const font = new Font(\"HelveticaNeue\", file, properties);\n  const mappedEuro = font.toFontChar[128];\n  const expectedEuro = getGlyphsUnicode()[\"Euro\"];\n  if (mappedEuro !== expectedEuro) {\n    throw new Error(`Expected Euro mapping (${expectedEuro}) but got (${mappedEuro})`);\n  }\n});"
  },
  "18664": {
    "i1_deepseek-r1-distill-llama-70b": "it(\"should set roleimg on the image canvas when an image is added\", async () => {\n  const { StampEditor } = await import(\"../../src/display/editor/stamp.js\");\n  const parent = {\n    pageIndex: 0,\n    viewport: {\n      rotation: 0,\n      rawDims: { pageWidth: 800, pageHeight: 600, pageX: 0, pageY: 0 }\n    },\n    get parentDimensions() { return [1, 1]; }\n  };\n  const uiManager = {\n    useNewAltTextWhenAddingImage: true,\n    useNewAltTextFlow: false,\n    _signal: new AbortController().signal,\n    enableWaiting: () => {},\n    delete: () => {},\n    viewParameters: { rotation: 0 }\n  };\n  const params = {\n    parent,\n    id: \"testEditor\",\n    uiManager,\n    bitmapUrl: \"dummy\",\n    bitmapFile: null\n  };\n  const editor = new StampEditor(params);\n  // Create a dummy container div if not already created.\n  if (!editor.div) {\n    editor.div = document.createElement(\"div\");\n  }\n  // Provide minimal stub for addAltTextButton to prevent errors.\n  if (typeof editor.addAltTextButton !== \"function\") {\n    editor.addAltTextButton = () => {};\n  }\n  // Provide addContainer if not already available.\n  if (typeof editor.addContainer !== \"function\") {\n    editor.addContainer = function(container) {\n      const toolbarDiv = this._editToolbar && this._editToolbar.div;\n      if (toolbarDiv) {\n        toolbarDiv.before(container);\n      } else {\n        this.div.appendChild(container);\n      }\n    };\n  }\n  editor.render();\n  const canvas = editor.div.querySelector(\"canvas\");\n  if (!canvas) {\n    throw new Error(\"Canvas element was not added to the editor.\");\n  }\n  if (canvas.getAttribute(\"role\") !== \"img\") {\n    throw new Error(\"Expected canvas to have role='img', but got: \" + canvas.getAttribute(\"role\"));\n  }\n});\n",
    "i1_gpt-4o": "it(\"should set roleimg on the image canvas when an image is added\", async () => {\n  const { StampEditor } = await import(\"../../src/display/editor/stamp.js\");\n  const parent = {\n    pageIndex: 0,\n    viewport: {\n      rotation: 0,\n      rawDims: { pageWidth: 800, pageHeight: 600, pageX: 0, pageY: 0 }\n    },\n    get parentDimensions() { return [1, 1]; }\n  };\n  const uiManager = {\n    useNewAltTextWhenAddingImage: true,\n    useNewAltTextFlow: false,\n    _signal: new AbortController().signal,\n    enableWaiting: () => {},\n    delete: () => {},\n    viewParameters: { rotation: 0 }\n  };\n  const params = {\n    parent,\n    id: \"testEditor\",\n    uiManager,\n    bitmapUrl: \"dummy\",\n    bitmapFile: null\n  };\n  const editor = new StampEditor(params);\n  // Create a dummy container div if not already created.\n  if (!editor.div) {\n    editor.div = document.createElement(\"div\");\n  }\n  // Provide minimal stub for addAltTextButton to prevent errors.\n  if (typeof editor.addAltTextButton !== \"function\") {\n    editor.addAltTextButton = () => {};\n  }\n  // Provide addContainer if not already available.\n  if (typeof editor.addContainer !== \"function\") {\n    editor.addContainer = function(container) {\n      const toolbarDiv = this._editToolbar && this._editToolbar.div;\n      if (toolbarDiv) {\n        toolbarDiv.before(container);\n      } else {\n        this.div.appendChild(container);\n      }\n    };\n  }\n  editor.render();\n  const canvas = editor.div.querySelector(\"canvas\");\n  if (!canvas) {\n    throw new Error(\"Canvas element was not added to the editor.\");\n  }\n  if (canvas.getAttribute(\"role\") !== \"img\") {\n    throw new Error(\"Expected canvas to have role='img', but got: \" + canvas.getAttribute(\"role\"));\n  }\n});\n",
    "i1_llama-3.3-70b-versatile": "it(\"should set roleimg on the image canvas when an image is added\", async () => {\n  const { StampEditor } = await import(\"../../src/display/editor/stamp.js\");\n  const parent = {\n    pageIndex: 0,\n    viewport: {\n      rotation: 0,\n      rawDims: { pageWidth: 800, pageHeight: 600, pageX: 0, pageY: 0 }\n    },\n    get parentDimensions() { return [1, 1]; }\n  };\n  const uiManager = {\n    useNewAltTextWhenAddingImage: true,\n    useNewAltTextFlow: false,\n    _signal: new AbortController().signal,\n    enableWaiting: () => {},\n    delete: () => {},\n    viewParameters: { rotation: 0 }\n  };\n  const params = {\n    parent,\n    id: \"testEditor\",\n    uiManager,\n    bitmapUrl: \"dummy\",\n    bitmapFile: null\n  };\n  const editor = new StampEditor(params);\n  // Create a dummy container div if not already created.\n  if (!editor.div) {\n    editor.div = document.createElement(\"div\");\n  }\n  // Provide minimal stub for addAltTextButton to prevent errors.\n  if (typeof editor.addAltTextButton !== \"function\") {\n    editor.addAltTextButton = () => {};\n  }\n  // Provide addContainer if not already available.\n  if (typeof editor.addContainer !== \"function\") {\n    editor.addContainer = function(container) {\n      const toolbarDiv = this._editToolbar && this._editToolbar.div;\n      if (toolbarDiv) {\n        toolbarDiv.before(container);\n      } else {\n        this.div.appendChild(container);\n      }\n    };\n  }\n  editor.render();\n  const canvas = editor.div.querySelector(\"canvas\");\n  if (!canvas) {\n    throw new Error(\"Canvas element was not added to the editor.\");\n  }\n  if (canvas.getAttribute(\"role\") !== \"img\") {\n    throw new Error(\"Expected canvas to have role='img', but got: \" + canvas.getAttribute(\"role\"));\n  }\n});\n",
    "i1_MOCK": "it(\"should set roleimg on the image canvas when an image is added\", async () => {\n  const { StampEditor } = await import(\"../../src/display/editor/stamp.js\");\n  const parent = {\n    pageIndex: 0,\n    viewport: {\n      rotation: 0,\n      rawDims: { pageWidth: 800, pageHeight: 600, pageX: 0, pageY: 0 }\n    },\n    get parentDimensions() { return [1, 1]; }\n  };\n  const uiManager = {\n    useNewAltTextWhenAddingImage: true,\n    useNewAltTextFlow: false,\n    _signal: new AbortController().signal,\n    enableWaiting: () => {},\n    delete: () => {},\n    viewParameters: { rotation: 0 }\n  };\n  const params = {\n    parent,\n    id: \"testEditor\",\n    uiManager,\n    bitmapUrl: \"dummy\",\n    bitmapFile: null\n  };\n  const editor = new StampEditor(params);\n  // Create a dummy container div if not already created.\n  if (!editor.div) {\n    editor.div = document.createElement(\"div\");\n  }\n  // Provide minimal stub for addAltTextButton to prevent errors.\n  if (typeof editor.addAltTextButton !== \"function\") {\n    editor.addAltTextButton = () => {};\n  }\n  // Provide addContainer if not already available.\n  if (typeof editor.addContainer !== \"function\") {\n    editor.addContainer = function(container) {\n      const toolbarDiv = this._editToolbar && this._editToolbar.div;\n      if (toolbarDiv) {\n        toolbarDiv.before(container);\n      } else {\n        this.div.appendChild(container);\n      }\n    };\n  }\n  editor.render();\n  const canvas = editor.div.querySelector(\"canvas\");\n  if (!canvas) {\n    throw new Error(\"Canvas element was not added to the editor.\");\n  }\n  if (canvas.getAttribute(\"role\") !== \"img\") {\n    throw new Error(\"Expected canvas to have role='img', but got: \" + canvas.getAttribute(\"role\"));\n  }\n});\n",
    "i2_deepseek-r1-distill-llama-70b": "it(\"should set roleimg on the image canvas when an image is added\", async () => {\n  const { StampEditor } = await import(\"../../src/display/editor/stamp.js\");\n  const parent = {\n    pageIndex: 0,\n    viewport: {\n      rotation: 0,\n      rawDims: { pageWidth: 800, pageHeight: 600, pageX: 0, pageY: 0 }\n    },\n    get parentDimensions() { return [1, 1]; }\n  };\n  const uiManager = {\n    useNewAltTextWhenAddingImage: true,\n    useNewAltTextFlow: false,\n    _signal: new AbortController().signal,\n    enableWaiting: () => {},\n    delete: () => {},\n    viewParameters: { rotation: 0 }\n  };\n  const params = {\n    parent,\n    id: \"testEditor\",\n    uiManager,\n    bitmapUrl: \"dummy\",\n    bitmapFile: null\n  };\n  const editor = new StampEditor(params);\n  // Create a dummy container div if not already created.\n  if (!editor.div) {\n    editor.div = document.createElement(\"div\");\n  }\n  // Provide minimal stub for addAltTextButton to prevent errors.\n  if (typeof editor.addAltTextButton !== \"function\") {\n    editor.addAltTextButton = () => {};\n  }\n  // Provide addContainer if not already available.\n  if (typeof editor.addContainer !== \"function\") {\n    editor.addContainer = function(container) {\n      const toolbarDiv = this._editToolbar && this._editToolbar.div;\n      if (toolbarDiv) {\n        toolbarDiv.before(container);\n      } else {\n        this.div.appendChild(container);\n      }\n    };\n  }\n  editor.render();\n  const canvas = editor.div.querySelector(\"canvas\");\n  if (!canvas) {\n    throw new Error(\"Canvas element was not added to the editor.\");\n  }\n  if (canvas.getAttribute(\"role\") !== \"img\") {\n    throw new Error(\"Expected canvas to have role='img', but got: \" + canvas.getAttribute(\"role\"));\n  }\n});\n",
    "i2_gpt-4o": "it(\"should set roleimg on the image canvas when an image is added\", async () => {\n  const { StampEditor } = await import(\"../../src/display/editor/stamp.js\");\n  const parent = {\n    pageIndex: 0,\n    viewport: {\n      rotation: 0,\n      rawDims: { pageWidth: 800, pageHeight: 600, pageX: 0, pageY: 0 }\n    },\n    get parentDimensions() { return [1, 1]; }\n  };\n  const uiManager = {\n    useNewAltTextWhenAddingImage: true,\n    useNewAltTextFlow: false,\n    _signal: new AbortController().signal,\n    enableWaiting: () => {},\n    delete: () => {},\n    viewParameters: { rotation: 0 }\n  };\n  const params = {\n    parent,\n    id: \"testEditor\",\n    uiManager,\n    bitmapUrl: \"dummy\",\n    bitmapFile: null\n  };\n  const editor = new StampEditor(params);\n  // Create a dummy container div if not already created.\n  if (!editor.div) {\n    editor.div = document.createElement(\"div\");\n  }\n  // Provide minimal stub for addAltTextButton to prevent errors.\n  if (typeof editor.addAltTextButton !== \"function\") {\n    editor.addAltTextButton = () => {};\n  }\n  // Provide addContainer if not already available.\n  if (typeof editor.addContainer !== \"function\") {\n    editor.addContainer = function(container) {\n      const toolbarDiv = this._editToolbar && this._editToolbar.div;\n      if (toolbarDiv) {\n        toolbarDiv.before(container);\n      } else {\n        this.div.appendChild(container);\n      }\n    };\n  }\n  editor.render();\n  const canvas = editor.div.querySelector(\"canvas\");\n  if (!canvas) {\n    throw new Error(\"Canvas element was not added to the editor.\");\n  }\n  if (canvas.getAttribute(\"role\") !== \"img\") {\n    throw new Error(\"Expected canvas to have role='img', but got: \" + canvas.getAttribute(\"role\"));\n  }\n});\n",
    "i2_llama-3.3-70b-versatile": "it(\"should set roleimg on the image canvas when an image is added\", async () => {\n  const { StampEditor } = await import(\"../../src/display/editor/stamp.js\");\n  const parent = {\n    pageIndex: 0,\n    viewport: {\n      rotation: 0,\n      rawDims: { pageWidth: 800, pageHeight: 600, pageX: 0, pageY: 0 }\n    },\n    get parentDimensions() { return [1, 1]; }\n  };\n  const uiManager = {\n    useNewAltTextWhenAddingImage: true,\n    useNewAltTextFlow: false,\n    _signal: new AbortController().signal,\n    enableWaiting: () => {},\n    delete: () => {},\n    viewParameters: { rotation: 0 }\n  };\n  const params = {\n    parent,\n    id: \"testEditor\",\n    uiManager,\n    bitmapUrl: \"dummy\",\n    bitmapFile: null\n  };\n  const editor = new StampEditor(params);\n  // Create a dummy container div if not already created.\n  if (!editor.div) {\n    editor.div = document.createElement(\"div\");\n  }\n  // Provide minimal stub for addAltTextButton to prevent errors.\n  if (typeof editor.addAltTextButton !== \"function\") {\n    editor.addAltTextButton = () => {};\n  }\n  // Provide addContainer if not already available.\n  if (typeof editor.addContainer !== \"function\") {\n    editor.addContainer = function(container) {\n      const toolbarDiv = this._editToolbar && this._editToolbar.div;\n      if (toolbarDiv) {\n        toolbarDiv.before(container);\n      } else {\n        this.div.appendChild(container);\n      }\n    };\n  }\n  editor.render();\n  const canvas = editor.div.querySelector(\"canvas\");\n  if (!canvas) {\n    throw new Error(\"Canvas element was not added to the editor.\");\n  }\n  if (canvas.getAttribute(\"role\") !== \"img\") {\n    throw new Error(\"Expected canvas to have role='img', but got: \" + canvas.getAttribute(\"role\"));\n  }\n});\n",
    "i3_deepseek-r1-distill-llama-70b": "it(\"should set roleimg on the image canvas when an image is added\", async () => {\n  const { StampEditor } = await import(\"../../src/display/editor/stamp.js\");\n  const parent = {\n    pageIndex: 0,\n    viewport: {\n      rotation: 0,\n      rawDims: { pageWidth: 800, pageHeight: 600, pageX: 0, pageY: 0 }\n    },\n    get parentDimensions() { return [1, 1]; }\n  };\n  const uiManager = {\n    useNewAltTextWhenAddingImage: true,\n    useNewAltTextFlow: false,\n    _signal: new AbortController().signal,\n    enableWaiting: () => {},\n    delete: () => {},\n    viewParameters: { rotation: 0 }\n  };\n  const params = {\n    parent,\n    id: \"testEditor\",\n    uiManager,\n    bitmapUrl: \"dummy\",\n    bitmapFile: null\n  };\n  const editor = new StampEditor(params);\n  // Create a dummy container div if not already created.\n  if (!editor.div) {\n    editor.div = document.createElement(\"div\");\n  }\n  // Provide minimal stub for addAltTextButton to prevent errors.\n  if (typeof editor.addAltTextButton !== \"function\") {\n    editor.addAltTextButton = () => {};\n  }\n  // Provide addContainer if not already available.\n  if (typeof editor.addContainer !== \"function\") {\n    editor.addContainer = function(container) {\n      const toolbarDiv = this._editToolbar && this._editToolbar.div;\n      if (toolbarDiv) {\n        toolbarDiv.before(container);\n      } else {\n        this.div.appendChild(container);\n      }\n    };\n  }\n  editor.render();\n  const canvas = editor.div.querySelector(\"canvas\");\n  if (!canvas) {\n    throw new Error(\"Canvas element was not added to the editor.\");\n  }\n  if (canvas.getAttribute(\"role\") !== \"img\") {\n    throw new Error(\"Expected canvas to have role='img', but got: \" + canvas.getAttribute(\"role\"));\n  }\n});\n",
    "i3_gpt-4o": "it(\"should set roleimg on the image canvas when an image is added\", async () => {\n  const { StampEditor } = await import(\"../../src/display/editor/stamp.js\");\n  const parent = {\n    pageIndex: 0,\n    viewport: {\n      rotation: 0,\n      rawDims: { pageWidth: 800, pageHeight: 600, pageX: 0, pageY: 0 }\n    },\n    get parentDimensions() { return [1, 1]; }\n  };\n  const uiManager = {\n    useNewAltTextWhenAddingImage: true,\n    useNewAltTextFlow: false,\n    _signal: new AbortController().signal,\n    enableWaiting: () => {},\n    delete: () => {},\n    viewParameters: { rotation: 0 }\n  };\n  const params = {\n    parent,\n    id: \"testEditor\",\n    uiManager,\n    bitmapUrl: \"dummy\",\n    bitmapFile: null\n  };\n  const editor = new StampEditor(params);\n  // Create a dummy container div if not already created.\n  if (!editor.div) {\n    editor.div = document.createElement(\"div\");\n  }\n  // Provide minimal stub for addAltTextButton to prevent errors.\n  if (typeof editor.addAltTextButton !== \"function\") {\n    editor.addAltTextButton = () => {};\n  }\n  // Provide addContainer if not already available.\n  if (typeof editor.addContainer !== \"function\") {\n    editor.addContainer = function(container) {\n      const toolbarDiv = this._editToolbar && this._editToolbar.div;\n      if (toolbarDiv) {\n        toolbarDiv.before(container);\n      } else {\n        this.div.appendChild(container);\n      }\n    };\n  }\n  editor.render();\n  const canvas = editor.div.querySelector(\"canvas\");\n  if (!canvas) {\n    throw new Error(\"Canvas element was not added to the editor.\");\n  }\n  if (canvas.getAttribute(\"role\") !== \"img\") {\n    throw new Error(\"Expected canvas to have role='img', but got: \" + canvas.getAttribute(\"role\"));\n  }\n});\n",
    "i3_llama-3.3-70b-versatile": "it(\"should set roleimg on the image canvas when an image is added\", async () => {\n  const { StampEditor } = await import(\"../../src/display/editor/stamp.js\");\n  const parent = {\n    pageIndex: 0,\n    viewport: {\n      rotation: 0,\n      rawDims: { pageWidth: 800, pageHeight: 600, pageX: 0, pageY: 0 }\n    },\n    get parentDimensions() { return [1, 1]; }\n  };\n  const uiManager = {\n    useNewAltTextWhenAddingImage: true,\n    useNewAltTextFlow: false,\n    _signal: new AbortController().signal,\n    enableWaiting: () => {},\n    delete: () => {},\n    viewParameters: { rotation: 0 }\n  };\n  const params = {\n    parent,\n    id: \"testEditor\",\n    uiManager,\n    bitmapUrl: \"dummy\",\n    bitmapFile: null\n  };\n  const editor = new StampEditor(params);\n  // Create a dummy container div if not already created.\n  if (!editor.div) {\n    editor.div = document.createElement(\"div\");\n  }\n  // Provide minimal stub for addAltTextButton to prevent errors.\n  if (typeof editor.addAltTextButton !== \"function\") {\n    editor.addAltTextButton = () => {};\n  }\n  // Provide addContainer if not already available.\n  if (typeof editor.addContainer !== \"function\") {\n    editor.addContainer = function(container) {\n      const toolbarDiv = this._editToolbar && this._editToolbar.div;\n      if (toolbarDiv) {\n        toolbarDiv.before(container);\n      } else {\n        this.div.appendChild(container);\n      }\n    };\n  }\n  editor.render();\n  const canvas = editor.div.querySelector(\"canvas\");\n  if (!canvas) {\n    throw new Error(\"Canvas element was not added to the editor.\");\n  }\n  if (canvas.getAttribute(\"role\") !== \"img\") {\n    throw new Error(\"Expected canvas to have role='img', but got: \" + canvas.getAttribute(\"role\"));\n  }\n});\n",
    "i4_deepseek-r1-distill-llama-70b": "it(\"should set roleimg on the image canvas when an image is added\", async () => {\n  const { StampEditor } = await import(\"../../src/display/editor/stamp.js\");\n  const parent = {\n    pageIndex: 0,\n    viewport: {\n      rotation: 0,\n      rawDims: { pageWidth: 800, pageHeight: 600, pageX: 0, pageY: 0 }\n    },\n    get parentDimensions() { return [1, 1]; }\n  };\n  const uiManager = {\n    useNewAltTextWhenAddingImage: true,\n    useNewAltTextFlow: false,\n    _signal: new AbortController().signal,\n    enableWaiting: () => {},\n    delete: () => {},\n    viewParameters: { rotation: 0 }\n  };\n  const params = {\n    parent,\n    id: \"testEditor\",\n    uiManager,\n    bitmapUrl: \"dummy\",\n    bitmapFile: null\n  };\n  const editor = new StampEditor(params);\n  // Create a dummy container div if not already created.\n  if (!editor.div) {\n    editor.div = document.createElement(\"div\");\n  }\n  // Provide minimal stub for addAltTextButton to prevent errors.\n  if (typeof editor.addAltTextButton !== \"function\") {\n    editor.addAltTextButton = () => {};\n  }\n  // Provide addContainer if not already available.\n  if (typeof editor.addContainer !== \"function\") {\n    editor.addContainer = function(container) {\n      const toolbarDiv = this._editToolbar && this._editToolbar.div;\n      if (toolbarDiv) {\n        toolbarDiv.before(container);\n      } else {\n        this.div.appendChild(container);\n      }\n    };\n  }\n  editor.render();\n  const canvas = editor.div.querySelector(\"canvas\");\n  if (!canvas) {\n    throw new Error(\"Canvas element was not added to the editor.\");\n  }\n  if (canvas.getAttribute(\"role\") !== \"img\") {\n    throw new Error(\"Expected canvas to have role='img', but got: \" + canvas.getAttribute(\"role\"));\n  }\n});\n",
    "i4_gpt-4o": "it(\"should set roleimg on the image canvas when an image is added\", async () => {\n  const { StampEditor } = await import(\"../../src/display/editor/stamp.js\");\n  const parent = {\n    pageIndex: 0,\n    viewport: {\n      rotation: 0,\n      rawDims: { pageWidth: 800, pageHeight: 600, pageX: 0, pageY: 0 }\n    },\n    get parentDimensions() { return [1, 1]; }\n  };\n  const uiManager = {\n    useNewAltTextWhenAddingImage: true,\n    useNewAltTextFlow: false,\n    _signal: new AbortController().signal,\n    enableWaiting: () => {},\n    delete: () => {},\n    viewParameters: { rotation: 0 }\n  };\n  const params = {\n    parent,\n    id: \"testEditor\",\n    uiManager,\n    bitmapUrl: \"dummy\",\n    bitmapFile: null\n  };\n  const editor = new StampEditor(params);\n  // Create a dummy container div if not already created.\n  if (!editor.div) {\n    editor.div = document.createElement(\"div\");\n  }\n  // Provide minimal stub for addAltTextButton to prevent errors.\n  if (typeof editor.addAltTextButton !== \"function\") {\n    editor.addAltTextButton = () => {};\n  }\n  // Provide addContainer if not already available.\n  if (typeof editor.addContainer !== \"function\") {\n    editor.addContainer = function(container) {\n      const toolbarDiv = this._editToolbar && this._editToolbar.div;\n      if (toolbarDiv) {\n        toolbarDiv.before(container);\n      } else {\n        this.div.appendChild(container);\n      }\n    };\n  }\n  editor.render();\n  const canvas = editor.div.querySelector(\"canvas\");\n  if (!canvas) {\n    throw new Error(\"Canvas element was not added to the editor.\");\n  }\n  if (canvas.getAttribute(\"role\") !== \"img\") {\n    throw new Error(\"Expected canvas to have role='img', but got: \" + canvas.getAttribute(\"role\"));\n  }\n});\n",
    "i4_llama-3.3-70b-versatile": "it(\"should set roleimg on the image canvas when an image is added\", async () => {\n  const { StampEditor } = await import(\"../../src/display/editor/stamp.js\");\n  const parent = {\n    pageIndex: 0,\n    viewport: {\n      rotation: 0,\n      rawDims: { pageWidth: 800, pageHeight: 600, pageX: 0, pageY: 0 }\n    },\n    get parentDimensions() { return [1, 1]; }\n  };\n  const uiManager = {\n    useNewAltTextWhenAddingImage: true,\n    useNewAltTextFlow: false,\n    _signal: new AbortController().signal,\n    enableWaiting: () => {},\n    delete: () => {},\n    viewParameters: { rotation: 0 }\n  };\n  const params = {\n    parent,\n    id: \"testEditor\",\n    uiManager,\n    bitmapUrl: \"dummy\",\n    bitmapFile: null\n  };\n  const editor = new StampEditor(params);\n  // Create a dummy container div if not already created.\n  if (!editor.div) {\n    editor.div = document.createElement(\"div\");\n  }\n  // Provide minimal stub for addAltTextButton to prevent errors.\n  if (typeof editor.addAltTextButton !== \"function\") {\n    editor.addAltTextButton = () => {};\n  }\n  // Provide addContainer if not already available.\n  if (typeof editor.addContainer !== \"function\") {\n    editor.addContainer = function(container) {\n      const toolbarDiv = this._editToolbar && this._editToolbar.div;\n      if (toolbarDiv) {\n        toolbarDiv.before(container);\n      } else {\n        this.div.appendChild(container);\n      }\n    };\n  }\n  editor.render();\n  const canvas = editor.div.querySelector(\"canvas\");\n  if (!canvas) {\n    throw new Error(\"Canvas element was not added to the editor.\");\n  }\n  if (canvas.getAttribute(\"role\") !== \"img\") {\n    throw new Error(\"Expected canvas to have role='img', but got: \" + canvas.getAttribute(\"role\"));\n  }\n});\n",
    "i5_deepseek-r1-distill-llama-70b": "it(\"should set roleimg on the image canvas when an image is added\", async () => {\n  const { StampEditor } = await import(\"../../src/display/editor/stamp.js\");\n  const parent = {\n    pageIndex: 0,\n    viewport: {\n      rotation: 0,\n      rawDims: { pageWidth: 800, pageHeight: 600, pageX: 0, pageY: 0 }\n    },\n    get parentDimensions() { return [1, 1]; }\n  };\n  const uiManager = {\n    useNewAltTextWhenAddingImage: true,\n    useNewAltTextFlow: false,\n    _signal: new AbortController().signal,\n    enableWaiting: () => {},\n    delete: () => {},\n    viewParameters: { rotation: 0 }\n  };\n  const params = {\n    parent,\n    id: \"testEditor\",\n    uiManager,\n    bitmapUrl: \"dummy\",\n    bitmapFile: null\n  };\n  const editor = new StampEditor(params);\n  // Create a dummy container div if not already created.\n  if (!editor.div) {\n    editor.div = document.createElement(\"div\");\n  }\n  // Provide minimal stub for addAltTextButton to prevent errors.\n  if (typeof editor.addAltTextButton !== \"function\") {\n    editor.addAltTextButton = () => {};\n  }\n  // Provide addContainer if not already available.\n  if (typeof editor.addContainer !== \"function\") {\n    editor.addContainer = function(container) {\n      const toolbarDiv = this._editToolbar && this._editToolbar.div;\n      if (toolbarDiv) {\n        toolbarDiv.before(container);\n      } else {\n        this.div.appendChild(container);\n      }\n    };\n  }\n  editor.render();\n  const canvas = editor.div.querySelector(\"canvas\");\n  if (!canvas) {\n    throw new Error(\"Canvas element was not added to the editor.\");\n  }\n  if (canvas.getAttribute(\"role\") !== \"img\") {\n    throw new Error(\"Expected canvas to have role='img', but got: \" + canvas.getAttribute(\"role\"));\n  }\n});\n",
    "i5_gpt-4o": "it(\"should set roleimg on the image canvas when an image is added\", async () => {\n  const { StampEditor } = await import(\"../../src/display/editor/stamp.js\");\n  const parent = {\n    pageIndex: 0,\n    viewport: {\n      rotation: 0,\n      rawDims: { pageWidth: 800, pageHeight: 600, pageX: 0, pageY: 0 }\n    },\n    get parentDimensions() { return [1, 1]; }\n  };\n  const uiManager = {\n    useNewAltTextWhenAddingImage: true,\n    useNewAltTextFlow: false,\n    _signal: new AbortController().signal,\n    enableWaiting: () => {},\n    delete: () => {},\n    viewParameters: { rotation: 0 }\n  };\n  const params = {\n    parent,\n    id: \"testEditor\",\n    uiManager,\n    bitmapUrl: \"dummy\",\n    bitmapFile: null\n  };\n  const editor = new StampEditor(params);\n  // Create a dummy container div if not already created.\n  if (!editor.div) {\n    editor.div = document.createElement(\"div\");\n  }\n  // Provide minimal stub for addAltTextButton to prevent errors.\n  if (typeof editor.addAltTextButton !== \"function\") {\n    editor.addAltTextButton = () => {};\n  }\n  // Provide addContainer if not already available.\n  if (typeof editor.addContainer !== \"function\") {\n    editor.addContainer = function(container) {\n      const toolbarDiv = this._editToolbar && this._editToolbar.div;\n      if (toolbarDiv) {\n        toolbarDiv.before(container);\n      } else {\n        this.div.appendChild(container);\n      }\n    };\n  }\n  editor.render();\n  const canvas = editor.div.querySelector(\"canvas\");\n  if (!canvas) {\n    throw new Error(\"Canvas element was not added to the editor.\");\n  }\n  if (canvas.getAttribute(\"role\") !== \"img\") {\n    throw new Error(\"Expected canvas to have role='img', but got: \" + canvas.getAttribute(\"role\"));\n  }\n});\n",
    "i5_llama-3.3-70b-versatile": "it(\"should set roleimg on the image canvas when an image is added\", async () => {\n  const { StampEditor } = await import(\"../../src/display/editor/stamp.js\");\n  const parent = {\n    pageIndex: 0,\n    viewport: {\n      rotation: 0,\n      rawDims: { pageWidth: 800, pageHeight: 600, pageX: 0, pageY: 0 }\n    },\n    get parentDimensions() { return [1, 1]; }\n  };\n  const uiManager = {\n    useNewAltTextWhenAddingImage: true,\n    useNewAltTextFlow: false,\n    _signal: new AbortController().signal,\n    enableWaiting: () => {},\n    delete: () => {},\n    viewParameters: { rotation: 0 }\n  };\n  const params = {\n    parent,\n    id: \"testEditor\",\n    uiManager,\n    bitmapUrl: \"dummy\",\n    bitmapFile: null\n  };\n  const editor = new StampEditor(params);\n  // Create a dummy container div if not already created.\n  if (!editor.div) {\n    editor.div = document.createElement(\"div\");\n  }\n  // Provide minimal stub for addAltTextButton to prevent errors.\n  if (typeof editor.addAltTextButton !== \"function\") {\n    editor.addAltTextButton = () => {};\n  }\n  // Provide addContainer if not already available.\n  if (typeof editor.addContainer !== \"function\") {\n    editor.addContainer = function(container) {\n      const toolbarDiv = this._editToolbar && this._editToolbar.div;\n      if (toolbarDiv) {\n        toolbarDiv.before(container);\n      } else {\n        this.div.appendChild(container);\n      }\n    };\n  }\n  editor.render();\n  const canvas = editor.div.querySelector(\"canvas\");\n  if (!canvas) {\n    throw new Error(\"Canvas element was not added to the editor.\");\n  }\n  if (canvas.getAttribute(\"role\") !== \"img\") {\n    throw new Error(\"Expected canvas to have role='img', but got: \" + canvas.getAttribute(\"role\"));\n  }\n});\n"
  },
  "18726": {
    "i1_deepseek-r1-distill-llama-70b": "it(\"should call endPath before clipping and begin a new path for annotation rendering\", async () => {\n  const log = [];\n  const fakeCtx = {\n    canvas: { width: 200, height: 200 },\n    rect(x, y, w, h) { log.push(\"rect\"); },\n    clip() { log.push(\"clip\"); },\n    beginPath() { log.push(\"beginPath\"); },\n    save() {},\n    setTransform() {}\n  };\n  const { CanvasGraphics } = await import(\"../../src/display/canvas.js\");\n  // Create a minimal dummy canvasFactory that won't be used in this branch.\n  const dummyCanvasFactory = { create: (w, h) => ({ canvas: { width: w, height: h }, context: fakeCtx }) };\n  const cg = new CanvasGraphics(fakeCtx, {}, {}, dummyCanvasFactory, null, { optionalContentConfig: null, markedContentStack: null }, new Map(), null);\n  // Override endPath to log and avoid any internal logic.\n  cg.endPath = function() { log.push(\"endPath\"); };\n  const rect = [0, 0, 100, 50], transform = [1, 0, 0, 1, 0, 0], matrix = [1, 0, 0, 1, 0, 0];\n  // hasOwnCanvas is false to ensure the else branch is executed.\n  cg.beginAnnotation(\"testAnnot\", rect, transform, matrix, false);\n  if (log.join(\",\") !== \"endPath,rect,clip,beginPath\") {\n    throw new Error(\"Expected call order 'endPath,rect,clip,beginPath' but got: \" + log.join(\",\"));\n  }\n});\n",
    "i1_gpt-4o": "it(\"should call endPath before clipping and begin a new path for annotation rendering\", async () => {\n  const log = [];\n  const fakeCtx = {\n    canvas: { width: 200, height: 200 },\n    rect(x, y, w, h) { log.push(\"rect\"); },\n    clip() { log.push(\"clip\"); },\n    beginPath() { log.push(\"beginPath\"); },\n    save() {},\n    setTransform() {}\n  };\n  const { CanvasGraphics } = await import(\"../../src/display/canvas.js\");\n  // Create a minimal dummy canvasFactory that won't be used in this branch.\n  const dummyCanvasFactory = { create: (w, h) => ({ canvas: { width: w, height: h }, context: fakeCtx }) };\n  const cg = new CanvasGraphics(fakeCtx, {}, {}, dummyCanvasFactory, null, { optionalContentConfig: null, markedContentStack: null }, new Map(), null);\n  // Override endPath to log and avoid any internal logic.\n  cg.endPath = function() { log.push(\"endPath\"); };\n  const rect = [0, 0, 100, 50], transform = [1, 0, 0, 1, 0, 0], matrix = [1, 0, 0, 1, 0, 0];\n  // hasOwnCanvas is false to ensure the else branch is executed.\n  cg.beginAnnotation(\"testAnnot\", rect, transform, matrix, false);\n  if (log.join(\",\") !== \"endPath,rect,clip,beginPath\") {\n    throw new Error(\"Expected call order 'endPath,rect,clip,beginPath' but got: \" + log.join(\",\"));\n  }\n});\n",
    "i1_llama-3.3-70b-versatile": "it(\"should call endPath before clipping and begin a new path for annotation rendering\", async () => {\n  const log = [];\n  const fakeCtx = {\n    canvas: { width: 200, height: 200 },\n    rect(x, y, w, h) { log.push(\"rect\"); },\n    clip() { log.push(\"clip\"); },\n    beginPath() { log.push(\"beginPath\"); },\n    save() {},\n    setTransform() {}\n  };\n  const { CanvasGraphics } = await import(\"../../src/display/canvas.js\");\n  // Create a minimal dummy canvasFactory that won't be used in this branch.\n  const dummyCanvasFactory = { create: (w, h) => ({ canvas: { width: w, height: h }, context: fakeCtx }) };\n  const cg = new CanvasGraphics(fakeCtx, {}, {}, dummyCanvasFactory, null, { optionalContentConfig: null, markedContentStack: null }, new Map(), null);\n  // Override endPath to log and avoid any internal logic.\n  cg.endPath = function() { log.push(\"endPath\"); };\n  const rect = [0, 0, 100, 50], transform = [1, 0, 0, 1, 0, 0], matrix = [1, 0, 0, 1, 0, 0];\n  // hasOwnCanvas is false to ensure the else branch is executed.\n  cg.beginAnnotation(\"testAnnot\", rect, transform, matrix, false);\n  if (log.join(\",\") !== \"endPath,rect,clip,beginPath\") {\n    throw new Error(\"Expected call order 'endPath,rect,clip,beginPath' but got: \" + log.join(\",\"));\n  }\n});\n",
    "i1_MOCK": "it(\"should call endPath before clipping and begin a new path for annotation rendering\", async () => {\n  const log = [];\n  const fakeCtx = {\n    canvas: { width: 200, height: 200 },\n    rect(x, y, w, h) { log.push(\"rect\"); },\n    clip() { log.push(\"clip\"); },\n    beginPath() { log.push(\"beginPath\"); },\n    save() {},\n    setTransform() {}\n  };\n  const { CanvasGraphics } = await import(\"../../src/display/canvas.js\");\n  // Create a minimal dummy canvasFactory that won't be used in this branch.\n  const dummyCanvasFactory = { create: (w, h) => ({ canvas: { width: w, height: h }, context: fakeCtx }) };\n  const cg = new CanvasGraphics(fakeCtx, {}, {}, dummyCanvasFactory, null, { optionalContentConfig: null, markedContentStack: null }, new Map(), null);\n  // Override endPath to log and avoid any internal logic.\n  cg.endPath = function() { log.push(\"endPath\"); };\n  const rect = [0, 0, 100, 50], transform = [1, 0, 0, 1, 0, 0], matrix = [1, 0, 0, 1, 0, 0];\n  // hasOwnCanvas is false to ensure the else branch is executed.\n  cg.beginAnnotation(\"testAnnot\", rect, transform, matrix, false);\n  if (log.join(\",\") !== \"endPath,rect,clip,beginPath\") {\n    throw new Error(\"Expected call order 'endPath,rect,clip,beginPath' but got: \" + log.join(\",\"));\n  }\n});\n",
    "i2_deepseek-r1-distill-llama-70b": "it(\"should call endPath before clipping and begin a new path for annotation rendering\", async () => {\n  const log = [];\n  const fakeCtx = {\n    canvas: { width: 200, height: 200 },\n    rect(x, y, w, h) { log.push(\"rect\"); },\n    clip() { log.push(\"clip\"); },\n    beginPath() { log.push(\"beginPath\"); },\n    save() {},\n    setTransform() {}\n  };\n  const { CanvasGraphics } = await import(\"../../src/display/canvas.js\");\n  // Create a minimal dummy canvasFactory that won't be used in this branch.\n  const dummyCanvasFactory = { create: (w, h) => ({ canvas: { width: w, height: h }, context: fakeCtx }) };\n  const cg = new CanvasGraphics(fakeCtx, {}, {}, dummyCanvasFactory, null, { optionalContentConfig: null, markedContentStack: null }, new Map(), null);\n  // Override endPath to log and avoid any internal logic.\n  cg.endPath = function() { log.push(\"endPath\"); };\n  const rect = [0, 0, 100, 50], transform = [1, 0, 0, 1, 0, 0], matrix = [1, 0, 0, 1, 0, 0];\n  // hasOwnCanvas is false to ensure the else branch is executed.\n  cg.beginAnnotation(\"testAnnot\", rect, transform, matrix, false);\n  if (log.join(\",\") !== \"endPath,rect,clip,beginPath\") {\n    throw new Error(\"Expected call order 'endPath,rect,clip,beginPath' but got: \" + log.join(\",\"));\n  }\n});\n",
    "i2_gpt-4o": "it(\"should call endPath before clipping and begin a new path for annotation rendering\", async () => {\n  const log = [];\n  const fakeCtx = {\n    canvas: { width: 200, height: 200 },\n    rect(x, y, w, h) { log.push(\"rect\"); },\n    clip() { log.push(\"clip\"); },\n    beginPath() { log.push(\"beginPath\"); },\n    save() {},\n    setTransform() {}\n  };\n  const { CanvasGraphics } = await import(\"../../src/display/canvas.js\");\n  // Create a minimal dummy canvasFactory that won't be used in this branch.\n  const dummyCanvasFactory = { create: (w, h) => ({ canvas: { width: w, height: h }, context: fakeCtx }) };\n  const cg = new CanvasGraphics(fakeCtx, {}, {}, dummyCanvasFactory, null, { optionalContentConfig: null, markedContentStack: null }, new Map(), null);\n  // Override endPath to log and avoid any internal logic.\n  cg.endPath = function() { log.push(\"endPath\"); };\n  const rect = [0, 0, 100, 50], transform = [1, 0, 0, 1, 0, 0], matrix = [1, 0, 0, 1, 0, 0];\n  // hasOwnCanvas is false to ensure the else branch is executed.\n  cg.beginAnnotation(\"testAnnot\", rect, transform, matrix, false);\n  if (log.join(\",\") !== \"endPath,rect,clip,beginPath\") {\n    throw new Error(\"Expected call order 'endPath,rect,clip,beginPath' but got: \" + log.join(\",\"));\n  }\n});\n",
    "i2_llama-3.3-70b-versatile": "it(\"should call endPath before clipping and begin a new path for annotation rendering\", async () => {\n  const log = [];\n  const fakeCtx = {\n    canvas: { width: 200, height: 200 },\n    rect(x, y, w, h) { log.push(\"rect\"); },\n    clip() { log.push(\"clip\"); },\n    beginPath() { log.push(\"beginPath\"); },\n    save() {},\n    setTransform() {}\n  };\n  const { CanvasGraphics } = await import(\"../../src/display/canvas.js\");\n  // Create a minimal dummy canvasFactory that won't be used in this branch.\n  const dummyCanvasFactory = { create: (w, h) => ({ canvas: { width: w, height: h }, context: fakeCtx }) };\n  const cg = new CanvasGraphics(fakeCtx, {}, {}, dummyCanvasFactory, null, { optionalContentConfig: null, markedContentStack: null }, new Map(), null);\n  // Override endPath to log and avoid any internal logic.\n  cg.endPath = function() { log.push(\"endPath\"); };\n  const rect = [0, 0, 100, 50], transform = [1, 0, 0, 1, 0, 0], matrix = [1, 0, 0, 1, 0, 0];\n  // hasOwnCanvas is false to ensure the else branch is executed.\n  cg.beginAnnotation(\"testAnnot\", rect, transform, matrix, false);\n  if (log.join(\",\") !== \"endPath,rect,clip,beginPath\") {\n    throw new Error(\"Expected call order 'endPath,rect,clip,beginPath' but got: \" + log.join(\",\"));\n  }\n});\n",
    "i3_deepseek-r1-distill-llama-70b": "it(\"should call endPath before clipping and begin a new path for annotation rendering\", async () => {\n  const log = [];\n  const fakeCtx = {\n    canvas: { width: 200, height: 200 },\n    rect(x, y, w, h) { log.push(\"rect\"); },\n    clip() { log.push(\"clip\"); },\n    beginPath() { log.push(\"beginPath\"); },\n    save() {},\n    setTransform() {}\n  };\n  const { CanvasGraphics } = await import(\"../../src/display/canvas.js\");\n  // Create a minimal dummy canvasFactory that won't be used in this branch.\n  const dummyCanvasFactory = { create: (w, h) => ({ canvas: { width: w, height: h }, context: fakeCtx }) };\n  const cg = new CanvasGraphics(fakeCtx, {}, {}, dummyCanvasFactory, null, { optionalContentConfig: null, markedContentStack: null }, new Map(), null);\n  // Override endPath to log and avoid any internal logic.\n  cg.endPath = function() { log.push(\"endPath\"); };\n  const rect = [0, 0, 100, 50], transform = [1, 0, 0, 1, 0, 0], matrix = [1, 0, 0, 1, 0, 0];\n  // hasOwnCanvas is false to ensure the else branch is executed.\n  cg.beginAnnotation(\"testAnnot\", rect, transform, matrix, false);\n  if (log.join(\",\") !== \"endPath,rect,clip,beginPath\") {\n    throw new Error(\"Expected call order 'endPath,rect,clip,beginPath' but got: \" + log.join(\",\"));\n  }\n});\n",
    "i3_gpt-4o": "it(\"should call endPath before clipping and begin a new path for annotation rendering\", async () => {\n  const log = [];\n  const fakeCtx = {\n    canvas: { width: 200, height: 200 },\n    rect(x, y, w, h) { log.push(\"rect\"); },\n    clip() { log.push(\"clip\"); },\n    beginPath() { log.push(\"beginPath\"); },\n    save() {},\n    setTransform() {}\n  };\n  const { CanvasGraphics } = await import(\"../../src/display/canvas.js\");\n  // Create a minimal dummy canvasFactory that won't be used in this branch.\n  const dummyCanvasFactory = { create: (w, h) => ({ canvas: { width: w, height: h }, context: fakeCtx }) };\n  const cg = new CanvasGraphics(fakeCtx, {}, {}, dummyCanvasFactory, null, { optionalContentConfig: null, markedContentStack: null }, new Map(), null);\n  // Override endPath to log and avoid any internal logic.\n  cg.endPath = function() { log.push(\"endPath\"); };\n  const rect = [0, 0, 100, 50], transform = [1, 0, 0, 1, 0, 0], matrix = [1, 0, 0, 1, 0, 0];\n  // hasOwnCanvas is false to ensure the else branch is executed.\n  cg.beginAnnotation(\"testAnnot\", rect, transform, matrix, false);\n  if (log.join(\",\") !== \"endPath,rect,clip,beginPath\") {\n    throw new Error(\"Expected call order 'endPath,rect,clip,beginPath' but got: \" + log.join(\",\"));\n  }\n});\n",
    "i3_llama-3.3-70b-versatile": "it(\"should call endPath before clipping and begin a new path for annotation rendering\", async () => {\n  const log = [];\n  const fakeCtx = {\n    canvas: { width: 200, height: 200 },\n    rect(x, y, w, h) { log.push(\"rect\"); },\n    clip() { log.push(\"clip\"); },\n    beginPath() { log.push(\"beginPath\"); },\n    save() {},\n    setTransform() {}\n  };\n  const { CanvasGraphics } = await import(\"../../src/display/canvas.js\");\n  // Create a minimal dummy canvasFactory that won't be used in this branch.\n  const dummyCanvasFactory = { create: (w, h) => ({ canvas: { width: w, height: h }, context: fakeCtx }) };\n  const cg = new CanvasGraphics(fakeCtx, {}, {}, dummyCanvasFactory, null, { optionalContentConfig: null, markedContentStack: null }, new Map(), null);\n  // Override endPath to log and avoid any internal logic.\n  cg.endPath = function() { log.push(\"endPath\"); };\n  const rect = [0, 0, 100, 50], transform = [1, 0, 0, 1, 0, 0], matrix = [1, 0, 0, 1, 0, 0];\n  // hasOwnCanvas is false to ensure the else branch is executed.\n  cg.beginAnnotation(\"testAnnot\", rect, transform, matrix, false);\n  if (log.join(\",\") !== \"endPath,rect,clip,beginPath\") {\n    throw new Error(\"Expected call order 'endPath,rect,clip,beginPath' but got: \" + log.join(\",\"));\n  }\n});\n",
    "i4_deepseek-r1-distill-llama-70b": "it(\"should call endPath before clipping and begin a new path for annotation rendering\", async () => {\n  const log = [];\n  const fakeCtx = {\n    canvas: { width: 200, height: 200 },\n    rect(x, y, w, h) { log.push(\"rect\"); },\n    clip() { log.push(\"clip\"); },\n    beginPath() { log.push(\"beginPath\"); },\n    save() {},\n    setTransform() {}\n  };\n  const { CanvasGraphics } = await import(\"../../src/display/canvas.js\");\n  // Create a minimal dummy canvasFactory that won't be used in this branch.\n  const dummyCanvasFactory = { create: (w, h) => ({ canvas: { width: w, height: h }, context: fakeCtx }) };\n  const cg = new CanvasGraphics(fakeCtx, {}, {}, dummyCanvasFactory, null, { optionalContentConfig: null, markedContentStack: null }, new Map(), null);\n  // Override endPath to log and avoid any internal logic.\n  cg.endPath = function() { log.push(\"endPath\"); };\n  const rect = [0, 0, 100, 50], transform = [1, 0, 0, 1, 0, 0], matrix = [1, 0, 0, 1, 0, 0];\n  // hasOwnCanvas is false to ensure the else branch is executed.\n  cg.beginAnnotation(\"testAnnot\", rect, transform, matrix, false);\n  if (log.join(\",\") !== \"endPath,rect,clip,beginPath\") {\n    throw new Error(\"Expected call order 'endPath,rect,clip,beginPath' but got: \" + log.join(\",\"));\n  }\n});\n",
    "i4_gpt-4o": "it(\"should call endPath before clipping and begin a new path for annotation rendering\", async () => {\n  const log = [];\n  const fakeCtx = {\n    canvas: { width: 200, height: 200 },\n    rect(x, y, w, h) { log.push(\"rect\"); },\n    clip() { log.push(\"clip\"); },\n    beginPath() { log.push(\"beginPath\"); },\n    save() {},\n    setTransform() {}\n  };\n  const { CanvasGraphics } = await import(\"../../src/display/canvas.js\");\n  // Create a minimal dummy canvasFactory that won't be used in this branch.\n  const dummyCanvasFactory = { create: (w, h) => ({ canvas: { width: w, height: h }, context: fakeCtx }) };\n  const cg = new CanvasGraphics(fakeCtx, {}, {}, dummyCanvasFactory, null, { optionalContentConfig: null, markedContentStack: null }, new Map(), null);\n  // Override endPath to log and avoid any internal logic.\n  cg.endPath = function() { log.push(\"endPath\"); };\n  const rect = [0, 0, 100, 50], transform = [1, 0, 0, 1, 0, 0], matrix = [1, 0, 0, 1, 0, 0];\n  // hasOwnCanvas is false to ensure the else branch is executed.\n  cg.beginAnnotation(\"testAnnot\", rect, transform, matrix, false);\n  if (log.join(\",\") !== \"endPath,rect,clip,beginPath\") {\n    throw new Error(\"Expected call order 'endPath,rect,clip,beginPath' but got: \" + log.join(\",\"));\n  }\n});\n",
    "i4_llama-3.3-70b-versatile": "it(\"should call endPath before clipping and begin a new path for annotation rendering\", async () => {\n  const log = [];\n  const fakeCtx = {\n    canvas: { width: 200, height: 200 },\n    rect(x, y, w, h) { log.push(\"rect\"); },\n    clip() { log.push(\"clip\"); },\n    beginPath() { log.push(\"beginPath\"); },\n    save() {},\n    setTransform() {}\n  };\n  const { CanvasGraphics } = await import(\"../../src/display/canvas.js\");\n  // Create a minimal dummy canvasFactory that won't be used in this branch.\n  const dummyCanvasFactory = { create: (w, h) => ({ canvas: { width: w, height: h }, context: fakeCtx }) };\n  const cg = new CanvasGraphics(fakeCtx, {}, {}, dummyCanvasFactory, null, { optionalContentConfig: null, markedContentStack: null }, new Map(), null);\n  // Override endPath to log and avoid any internal logic.\n  cg.endPath = function() { log.push(\"endPath\"); };\n  const rect = [0, 0, 100, 50], transform = [1, 0, 0, 1, 0, 0], matrix = [1, 0, 0, 1, 0, 0];\n  // hasOwnCanvas is false to ensure the else branch is executed.\n  cg.beginAnnotation(\"testAnnot\", rect, transform, matrix, false);\n  if (log.join(\",\") !== \"endPath,rect,clip,beginPath\") {\n    throw new Error(\"Expected call order 'endPath,rect,clip,beginPath' but got: \" + log.join(\",\"));\n  }\n});\n",
    "i5_deepseek-r1-distill-llama-70b": "it(\"should call endPath before clipping and begin a new path for annotation rendering\", async () => {\n  const log = [];\n  const fakeCtx = {\n    canvas: { width: 200, height: 200 },\n    rect(x, y, w, h) { log.push(\"rect\"); },\n    clip() { log.push(\"clip\"); },\n    beginPath() { log.push(\"beginPath\"); },\n    save() {},\n    setTransform() {}\n  };\n  const { CanvasGraphics } = await import(\"../../src/display/canvas.js\");\n  // Create a minimal dummy canvasFactory that won't be used in this branch.\n  const dummyCanvasFactory = { create: (w, h) => ({ canvas: { width: w, height: h }, context: fakeCtx }) };\n  const cg = new CanvasGraphics(fakeCtx, {}, {}, dummyCanvasFactory, null, { optionalContentConfig: null, markedContentStack: null }, new Map(), null);\n  // Override endPath to log and avoid any internal logic.\n  cg.endPath = function() { log.push(\"endPath\"); };\n  const rect = [0, 0, 100, 50], transform = [1, 0, 0, 1, 0, 0], matrix = [1, 0, 0, 1, 0, 0];\n  // hasOwnCanvas is false to ensure the else branch is executed.\n  cg.beginAnnotation(\"testAnnot\", rect, transform, matrix, false);\n  if (log.join(\",\") !== \"endPath,rect,clip,beginPath\") {\n    throw new Error(\"Expected call order 'endPath,rect,clip,beginPath' but got: \" + log.join(\",\"));\n  }\n});\n",
    "i5_gpt-4o": "it(\"should call endPath before clipping and begin a new path for annotation rendering\", async () => {\n  const log = [];\n  const fakeCtx = {\n    canvas: { width: 200, height: 200 },\n    rect(x, y, w, h) { log.push(\"rect\"); },\n    clip() { log.push(\"clip\"); },\n    beginPath() { log.push(\"beginPath\"); },\n    save() {},\n    setTransform() {}\n  };\n  const { CanvasGraphics } = await import(\"../../src/display/canvas.js\");\n  // Create a minimal dummy canvasFactory that won't be used in this branch.\n  const dummyCanvasFactory = { create: (w, h) => ({ canvas: { width: w, height: h }, context: fakeCtx }) };\n  const cg = new CanvasGraphics(fakeCtx, {}, {}, dummyCanvasFactory, null, { optionalContentConfig: null, markedContentStack: null }, new Map(), null);\n  // Override endPath to log and avoid any internal logic.\n  cg.endPath = function() { log.push(\"endPath\"); };\n  const rect = [0, 0, 100, 50], transform = [1, 0, 0, 1, 0, 0], matrix = [1, 0, 0, 1, 0, 0];\n  // hasOwnCanvas is false to ensure the else branch is executed.\n  cg.beginAnnotation(\"testAnnot\", rect, transform, matrix, false);\n  if (log.join(\",\") !== \"endPath,rect,clip,beginPath\") {\n    throw new Error(\"Expected call order 'endPath,rect,clip,beginPath' but got: \" + log.join(\",\"));\n  }\n});\n",
    "i5_llama-3.3-70b-versatile": "it(\"should call endPath before clipping and begin a new path for annotation rendering\", async () => {\n  const log = [];\n  const fakeCtx = {\n    canvas: { width: 200, height: 200 },\n    rect(x, y, w, h) { log.push(\"rect\"); },\n    clip() { log.push(\"clip\"); },\n    beginPath() { log.push(\"beginPath\"); },\n    save() {},\n    setTransform() {}\n  };\n  const { CanvasGraphics } = await import(\"../../src/display/canvas.js\");\n  // Create a minimal dummy canvasFactory that won't be used in this branch.\n  const dummyCanvasFactory = { create: (w, h) => ({ canvas: { width: w, height: h }, context: fakeCtx }) };\n  const cg = new CanvasGraphics(fakeCtx, {}, {}, dummyCanvasFactory, null, { optionalContentConfig: null, markedContentStack: null }, new Map(), null);\n  // Override endPath to log and avoid any internal logic.\n  cg.endPath = function() { log.push(\"endPath\"); };\n  const rect = [0, 0, 100, 50], transform = [1, 0, 0, 1, 0, 0], matrix = [1, 0, 0, 1, 0, 0];\n  // hasOwnCanvas is false to ensure the else branch is executed.\n  cg.beginAnnotation(\"testAnnot\", rect, transform, matrix, false);\n  if (log.join(\",\") !== \"endPath,rect,clip,beginPath\") {\n    throw new Error(\"Expected call order 'endPath,rect,clip,beginPath' but got: \" + log.join(\",\"));\n  }\n});\n"
  },
  "18760": {
    "i1_deepseek-r1-distill-llama-70b": "it(\"should correctly render a manually hinted TrueType font\", async () => {\n  const { getDocument } = await import(\"../../src/display/api.js\");\n  const { TEST_PDFS_PATH } = await import(\"./test_utils.js\");\n  // This file contains a manually hinted TrueType font that previously caused rasterisation errors.\n  const loadingTask = getDocument(`${TEST_PDFS_PATH}/manual_hinted_trueType.pdf`);\n  const pdfDocument = await loadingTask.promise;\n  const page = await pdfDocument.getPage(1);\n  const textContent = await page.getTextContent();\n  const text = textContent.items.map(item => item.str).join(\"\");\n  // The expected text is embedded in the PDF when the font is correctly processed.\n  expect(text).toContain(\"This is a hinted TrueType test\");\n});",
    "i1_gpt-4o": "it(\"should correctly render a manually hinted TrueType font\", async () => {\n  const { getDocument } = await import(\"../../src/display/api.js\");\n  const { TEST_PDFS_PATH } = await import(\"./test_utils.js\");\n  // This file contains a manually hinted TrueType font that previously caused rasterisation errors.\n  const loadingTask = getDocument(`${TEST_PDFS_PATH}/manual_hinted_trueType.pdf`);\n  const pdfDocument = await loadingTask.promise;\n  const page = await pdfDocument.getPage(1);\n  const textContent = await page.getTextContent();\n  const text = textContent.items.map(item => item.str).join(\"\");\n  // The expected text is embedded in the PDF when the font is correctly processed.\n  expect(text).toContain(\"This is a hinted TrueType test\");\n});",
    "i1_llama-3.3-70b-versatile": "it(\"should correctly render a manually hinted TrueType font\", async () => {\n  const { getDocument } = await import(\"../../src/display/api.js\");\n  const { TEST_PDFS_PATH } = await import(\"./test_utils.js\");\n  // This file contains a manually hinted TrueType font that previously caused rasterisation errors.\n  const loadingTask = getDocument(`${TEST_PDFS_PATH}/manual_hinted_trueType.pdf`);\n  const pdfDocument = await loadingTask.promise;\n  const page = await pdfDocument.getPage(1);\n  const textContent = await page.getTextContent();\n  const text = textContent.items.map(item => item.str).join(\"\");\n  // The expected text is embedded in the PDF when the font is correctly processed.\n  expect(text).toContain(\"This is a hinted TrueType test\");\n});",
    "i1_MOCK": "it(\"should correctly render a manually hinted TrueType font\", async () => {\n  const { getDocument } = await import(\"../../src/display/api.js\");\n  const { TEST_PDFS_PATH } = await import(\"./test_utils.js\");\n  // This file contains a manually hinted TrueType font that previously caused rasterisation errors.\n  const loadingTask = getDocument(`${TEST_PDFS_PATH}/manual_hinted_trueType.pdf`);\n  const pdfDocument = await loadingTask.promise;\n  const page = await pdfDocument.getPage(1);\n  const textContent = await page.getTextContent();\n  const text = textContent.items.map(item => item.str).join(\"\");\n  // The expected text is embedded in the PDF when the font is correctly processed.\n  expect(text).toContain(\"This is a hinted TrueType test\");\n});",
    "i2_deepseek-r1-distill-llama-70b": "it(\"should correctly render a manually hinted TrueType font\", async () => {\n  const { getDocument } = await import(\"../../src/display/api.js\");\n  const { TEST_PDFS_PATH } = await import(\"./test_utils.js\");\n  // This file contains a manually hinted TrueType font that previously caused rasterisation errors.\n  const loadingTask = getDocument(`${TEST_PDFS_PATH}/manual_hinted_trueType.pdf`);\n  const pdfDocument = await loadingTask.promise;\n  const page = await pdfDocument.getPage(1);\n  const textContent = await page.getTextContent();\n  const text = textContent.items.map(item => item.str).join(\"\");\n  // The expected text is embedded in the PDF when the font is correctly processed.\n  expect(text).toContain(\"This is a hinted TrueType test\");\n});",
    "i2_gpt-4o": "it(\"should correctly render a manually hinted TrueType font\", async () => {\n  const { getDocument } = await import(\"../../src/display/api.js\");\n  const { TEST_PDFS_PATH } = await import(\"./test_utils.js\");\n  // This file contains a manually hinted TrueType font that previously caused rasterisation errors.\n  const loadingTask = getDocument(`${TEST_PDFS_PATH}/manual_hinted_trueType.pdf`);\n  const pdfDocument = await loadingTask.promise;\n  const page = await pdfDocument.getPage(1);\n  const textContent = await page.getTextContent();\n  const text = textContent.items.map(item => item.str).join(\"\");\n  // The expected text is embedded in the PDF when the font is correctly processed.\n  expect(text).toContain(\"This is a hinted TrueType test\");\n});",
    "i2_llama-3.3-70b-versatile": "it(\"should correctly render a manually hinted TrueType font\", async () => {\n  const { getDocument } = await import(\"../../src/display/api.js\");\n  const { TEST_PDFS_PATH } = await import(\"./test_utils.js\");\n  // This file contains a manually hinted TrueType font that previously caused rasterisation errors.\n  const loadingTask = getDocument(`${TEST_PDFS_PATH}/manual_hinted_trueType.pdf`);\n  const pdfDocument = await loadingTask.promise;\n  const page = await pdfDocument.getPage(1);\n  const textContent = await page.getTextContent();\n  const text = textContent.items.map(item => item.str).join(\"\");\n  // The expected text is embedded in the PDF when the font is correctly processed.\n  expect(text).toContain(\"This is a hinted TrueType test\");\n});",
    "i3_deepseek-r1-distill-llama-70b": "it(\"should correctly render a manually hinted TrueType font\", async () => {\n  const { getDocument } = await import(\"../../src/display/api.js\");\n  const { TEST_PDFS_PATH } = await import(\"./test_utils.js\");\n  // This file contains a manually hinted TrueType font that previously caused rasterisation errors.\n  const loadingTask = getDocument(`${TEST_PDFS_PATH}/manual_hinted_trueType.pdf`);\n  const pdfDocument = await loadingTask.promise;\n  const page = await pdfDocument.getPage(1);\n  const textContent = await page.getTextContent();\n  const text = textContent.items.map(item => item.str).join(\"\");\n  // The expected text is embedded in the PDF when the font is correctly processed.\n  expect(text).toContain(\"This is a hinted TrueType test\");\n});",
    "i3_gpt-4o": "it(\"should correctly render a manually hinted TrueType font\", async () => {\n  const { getDocument } = await import(\"../../src/display/api.js\");\n  const { TEST_PDFS_PATH } = await import(\"./test_utils.js\");\n  // This file contains a manually hinted TrueType font that previously caused rasterisation errors.\n  const loadingTask = getDocument(`${TEST_PDFS_PATH}/manual_hinted_trueType.pdf`);\n  const pdfDocument = await loadingTask.promise;\n  const page = await pdfDocument.getPage(1);\n  const textContent = await page.getTextContent();\n  const text = textContent.items.map(item => item.str).join(\"\");\n  // The expected text is embedded in the PDF when the font is correctly processed.\n  expect(text).toContain(\"This is a hinted TrueType test\");\n});",
    "i3_llama-3.3-70b-versatile": "it(\"should correctly render a manually hinted TrueType font\", async () => {\n  const { getDocument } = await import(\"../../src/display/api.js\");\n  const { TEST_PDFS_PATH } = await import(\"./test_utils.js\");\n  // This file contains a manually hinted TrueType font that previously caused rasterisation errors.\n  const loadingTask = getDocument(`${TEST_PDFS_PATH}/manual_hinted_trueType.pdf`);\n  const pdfDocument = await loadingTask.promise;\n  const page = await pdfDocument.getPage(1);\n  const textContent = await page.getTextContent();\n  const text = textContent.items.map(item => item.str).join(\"\");\n  // The expected text is embedded in the PDF when the font is correctly processed.\n  expect(text).toContain(\"This is a hinted TrueType test\");\n});",
    "i4_deepseek-r1-distill-llama-70b": "it(\"should correctly render a manually hinted TrueType font\", async () => {\n  const { getDocument } = await import(\"../../src/display/api.js\");\n  const { TEST_PDFS_PATH } = await import(\"./test_utils.js\");\n  // This file contains a manually hinted TrueType font that previously caused rasterisation errors.\n  const loadingTask = getDocument(`${TEST_PDFS_PATH}/manual_hinted_trueType.pdf`);\n  const pdfDocument = await loadingTask.promise;\n  const page = await pdfDocument.getPage(1);\n  const textContent = await page.getTextContent();\n  const text = textContent.items.map(item => item.str).join(\"\");\n  // The expected text is embedded in the PDF when the font is correctly processed.\n  expect(text).toContain(\"This is a hinted TrueType test\");\n});",
    "i4_gpt-4o": "it(\"should correctly render a manually hinted TrueType font\", async () => {\n  const { getDocument } = await import(\"../../src/display/api.js\");\n  const { TEST_PDFS_PATH } = await import(\"./test_utils.js\");\n  // This file contains a manually hinted TrueType font that previously caused rasterisation errors.\n  const loadingTask = getDocument(`${TEST_PDFS_PATH}/manual_hinted_trueType.pdf`);\n  const pdfDocument = await loadingTask.promise;\n  const page = await pdfDocument.getPage(1);\n  const textContent = await page.getTextContent();\n  const text = textContent.items.map(item => item.str).join(\"\");\n  // The expected text is embedded in the PDF when the font is correctly processed.\n  expect(text).toContain(\"This is a hinted TrueType test\");\n});",
    "i4_llama-3.3-70b-versatile": "it(\"should correctly render a manually hinted TrueType font\", async () => {\n  const { getDocument } = await import(\"../../src/display/api.js\");\n  const { TEST_PDFS_PATH } = await import(\"./test_utils.js\");\n  // This file contains a manually hinted TrueType font that previously caused rasterisation errors.\n  const loadingTask = getDocument(`${TEST_PDFS_PATH}/manual_hinted_trueType.pdf`);\n  const pdfDocument = await loadingTask.promise;\n  const page = await pdfDocument.getPage(1);\n  const textContent = await page.getTextContent();\n  const text = textContent.items.map(item => item.str).join(\"\");\n  // The expected text is embedded in the PDF when the font is correctly processed.\n  expect(text).toContain(\"This is a hinted TrueType test\");\n});",
    "i5_deepseek-r1-distill-llama-70b": "it(\"should correctly render a manually hinted TrueType font\", async () => {\n  const { getDocument } = await import(\"../../src/display/api.js\");\n  const { TEST_PDFS_PATH } = await import(\"./test_utils.js\");\n  // This file contains a manually hinted TrueType font that previously caused rasterisation errors.\n  const loadingTask = getDocument(`${TEST_PDFS_PATH}/manual_hinted_trueType.pdf`);\n  const pdfDocument = await loadingTask.promise;\n  const page = await pdfDocument.getPage(1);\n  const textContent = await page.getTextContent();\n  const text = textContent.items.map(item => item.str).join(\"\");\n  // The expected text is embedded in the PDF when the font is correctly processed.\n  expect(text).toContain(\"This is a hinted TrueType test\");\n});",
    "i5_gpt-4o": "it(\"should correctly render a manually hinted TrueType font\", async () => {\n  const { getDocument } = await import(\"../../src/display/api.js\");\n  const { TEST_PDFS_PATH } = await import(\"./test_utils.js\");\n  // This file contains a manually hinted TrueType font that previously caused rasterisation errors.\n  const loadingTask = getDocument(`${TEST_PDFS_PATH}/manual_hinted_trueType.pdf`);\n  const pdfDocument = await loadingTask.promise;\n  const page = await pdfDocument.getPage(1);\n  const textContent = await page.getTextContent();\n  const text = textContent.items.map(item => item.str).join(\"\");\n  // The expected text is embedded in the PDF when the font is correctly processed.\n  expect(text).toContain(\"This is a hinted TrueType test\");\n});",
    "i5_llama-3.3-70b-versatile": "it(\"should correctly render a manually hinted TrueType font\", async () => {\n  const { getDocument } = await import(\"../../src/display/api.js\");\n  const { TEST_PDFS_PATH } = await import(\"./test_utils.js\");\n  // This file contains a manually hinted TrueType font that previously caused rasterisation errors.\n  const loadingTask = getDocument(`${TEST_PDFS_PATH}/manual_hinted_trueType.pdf`);\n  const pdfDocument = await loadingTask.promise;\n  const page = await pdfDocument.getPage(1);\n  const textContent = await page.getTextContent();\n  const text = textContent.items.map(item => item.str).join(\"\");\n  // The expected text is embedded in the PDF when the font is correctly processed.\n  expect(text).toContain(\"This is a hinted TrueType test\");\n});"
  },
  "18766": {
    "i1_deepseek-r1-distill-llama-70b": "it(\"should ignore shadingFill errors when ignoreErrors is enabled\", () => {\n  const xref = new XRefMock();\n  const opList = new OperatorList();\n  const resources = new Dict();\n  const shadingDict = new Dict();\n  // Do not add any shading object named \"Foo\".\n  resources.set(\"Shading\", shadingDict);\n  const evaluator = new PartialEvaluator({\n    xref,\n    handler: {},\n    pageIndex: 0,\n    idFactory: {},\n    fontCache: new Map(),\n    builtInCMapCache: new Map(),\n    standardFontDataCache: new Map(),\n    globalImageCache: new Map(),\n    systemFontCache: new Map(),\n    options: { ignoreErrors: true },\n  });\n  const fakeStream = {\n    called: false,\n    read(operation) {\n      if (!this.called) {\n        this.called = true;\n        operation.fn = OPS.shadingFill;\n        operation.args = [{ name: \"Foo\" }];\n        return true;\n      }\n      return false;\n    },\n  };\n  const fakeTask = new WorkerTask(\"fake\", null);\n  return evaluator\n    .getOperatorList({\n      stream: fakeStream,\n      task: fakeTask,\n      resources,\n      operatorList: opList,\n    })\n    .then(() => {\n      // The shadingFill operator should be ignored, so no op added.\n      assert.equal(opList.fnArray.length, 0);\n    });\n});",
    "i1_gpt-4o": "it(\"should ignore shadingFill errors when ignoreErrors is enabled\", () => {\n  const xref = new XRefMock();\n  const opList = new OperatorList();\n  const resources = new Dict();\n  const shadingDict = new Dict();\n  // Do not add any shading object named \"Foo\".\n  resources.set(\"Shading\", shadingDict);\n  const evaluator = new PartialEvaluator({\n    xref,\n    handler: {},\n    pageIndex: 0,\n    idFactory: {},\n    fontCache: new Map(),\n    builtInCMapCache: new Map(),\n    standardFontDataCache: new Map(),\n    globalImageCache: new Map(),\n    systemFontCache: new Map(),\n    options: { ignoreErrors: true },\n  });\n  const fakeStream = {\n    called: false,\n    read(operation) {\n      if (!this.called) {\n        this.called = true;\n        operation.fn = OPS.shadingFill;\n        operation.args = [{ name: \"Foo\" }];\n        return true;\n      }\n      return false;\n    },\n  };\n  const fakeTask = new WorkerTask(\"fake\", null);\n  return evaluator\n    .getOperatorList({\n      stream: fakeStream,\n      task: fakeTask,\n      resources,\n      operatorList: opList,\n    })\n    .then(() => {\n      // The shadingFill operator should be ignored, so no op added.\n      assert.equal(opList.fnArray.length, 0);\n    });\n});",
    "i1_llama-3.3-70b-versatile": "it(\"should ignore shadingFill errors when ignoreErrors is enabled\", () => {\n  const xref = new XRefMock();\n  const opList = new OperatorList();\n  const resources = new Dict();\n  const shadingDict = new Dict();\n  // Do not add any shading object named \"Foo\".\n  resources.set(\"Shading\", shadingDict);\n  const evaluator = new PartialEvaluator({\n    xref,\n    handler: {},\n    pageIndex: 0,\n    idFactory: {},\n    fontCache: new Map(),\n    builtInCMapCache: new Map(),\n    standardFontDataCache: new Map(),\n    globalImageCache: new Map(),\n    systemFontCache: new Map(),\n    options: { ignoreErrors: true },\n  });\n  const fakeStream = {\n    called: false,\n    read(operation) {\n      if (!this.called) {\n        this.called = true;\n        operation.fn = OPS.shadingFill;\n        operation.args = [{ name: \"Foo\" }];\n        return true;\n      }\n      return false;\n    },\n  };\n  const fakeTask = new WorkerTask(\"fake\", null);\n  return evaluator\n    .getOperatorList({\n      stream: fakeStream,\n      task: fakeTask,\n      resources,\n      operatorList: opList,\n    })\n    .then(() => {\n      // The shadingFill operator should be ignored, so no op added.\n      assert.equal(opList.fnArray.length, 0);\n    });\n});",
    "i1_MOCK": "it(\"should ignore shadingFill errors when ignoreErrors is enabled\", () => {\n  const xref = new XRefMock();\n  const opList = new OperatorList();\n  const resources = new Dict();\n  const shadingDict = new Dict();\n  // Do not add any shading object named \"Foo\".\n  resources.set(\"Shading\", shadingDict);\n  const evaluator = new PartialEvaluator({\n    xref,\n    handler: {},\n    pageIndex: 0,\n    idFactory: {},\n    fontCache: new Map(),\n    builtInCMapCache: new Map(),\n    standardFontDataCache: new Map(),\n    globalImageCache: new Map(),\n    systemFontCache: new Map(),\n    options: { ignoreErrors: true },\n  });\n  const fakeStream = {\n    called: false,\n    read(operation) {\n      if (!this.called) {\n        this.called = true;\n        operation.fn = OPS.shadingFill;\n        operation.args = [{ name: \"Foo\" }];\n        return true;\n      }\n      return false;\n    },\n  };\n  const fakeTask = new WorkerTask(\"fake\", null);\n  return evaluator\n    .getOperatorList({\n      stream: fakeStream,\n      task: fakeTask,\n      resources,\n      operatorList: opList,\n    })\n    .then(() => {\n      // The shadingFill operator should be ignored, so no op added.\n      assert.equal(opList.fnArray.length, 0);\n    });\n});",
    "i2_deepseek-r1-distill-llama-70b": "it(\"should ignore shadingFill errors when ignoreErrors is enabled\", () => {\n  const xref = new XRefMock();\n  const opList = new OperatorList();\n  const resources = new Dict();\n  const shadingDict = new Dict();\n  // Do not add any shading object named \"Foo\".\n  resources.set(\"Shading\", shadingDict);\n  const evaluator = new PartialEvaluator({\n    xref,\n    handler: {},\n    pageIndex: 0,\n    idFactory: {},\n    fontCache: new Map(),\n    builtInCMapCache: new Map(),\n    standardFontDataCache: new Map(),\n    globalImageCache: new Map(),\n    systemFontCache: new Map(),\n    options: { ignoreErrors: true },\n  });\n  const fakeStream = {\n    called: false,\n    read(operation) {\n      if (!this.called) {\n        this.called = true;\n        operation.fn = OPS.shadingFill;\n        operation.args = [{ name: \"Foo\" }];\n        return true;\n      }\n      return false;\n    },\n  };\n  const fakeTask = new WorkerTask(\"fake\", null);\n  return evaluator\n    .getOperatorList({\n      stream: fakeStream,\n      task: fakeTask,\n      resources,\n      operatorList: opList,\n    })\n    .then(() => {\n      // The shadingFill operator should be ignored, so no op added.\n      assert.equal(opList.fnArray.length, 0);\n    });\n});",
    "i2_gpt-4o": "it(\"should ignore shadingFill errors when ignoreErrors is enabled\", () => {\n  const xref = new XRefMock();\n  const opList = new OperatorList();\n  const resources = new Dict();\n  const shadingDict = new Dict();\n  // Do not add any shading object named \"Foo\".\n  resources.set(\"Shading\", shadingDict);\n  const evaluator = new PartialEvaluator({\n    xref,\n    handler: {},\n    pageIndex: 0,\n    idFactory: {},\n    fontCache: new Map(),\n    builtInCMapCache: new Map(),\n    standardFontDataCache: new Map(),\n    globalImageCache: new Map(),\n    systemFontCache: new Map(),\n    options: { ignoreErrors: true },\n  });\n  const fakeStream = {\n    called: false,\n    read(operation) {\n      if (!this.called) {\n        this.called = true;\n        operation.fn = OPS.shadingFill;\n        operation.args = [{ name: \"Foo\" }];\n        return true;\n      }\n      return false;\n    },\n  };\n  const fakeTask = new WorkerTask(\"fake\", null);\n  return evaluator\n    .getOperatorList({\n      stream: fakeStream,\n      task: fakeTask,\n      resources,\n      operatorList: opList,\n    })\n    .then(() => {\n      // The shadingFill operator should be ignored, so no op added.\n      assert.equal(opList.fnArray.length, 0);\n    });\n});",
    "i2_llama-3.3-70b-versatile": "it(\"should ignore shadingFill errors when ignoreErrors is enabled\", () => {\n  const xref = new XRefMock();\n  const opList = new OperatorList();\n  const resources = new Dict();\n  const shadingDict = new Dict();\n  // Do not add any shading object named \"Foo\".\n  resources.set(\"Shading\", shadingDict);\n  const evaluator = new PartialEvaluator({\n    xref,\n    handler: {},\n    pageIndex: 0,\n    idFactory: {},\n    fontCache: new Map(),\n    builtInCMapCache: new Map(),\n    standardFontDataCache: new Map(),\n    globalImageCache: new Map(),\n    systemFontCache: new Map(),\n    options: { ignoreErrors: true },\n  });\n  const fakeStream = {\n    called: false,\n    read(operation) {\n      if (!this.called) {\n        this.called = true;\n        operation.fn = OPS.shadingFill;\n        operation.args = [{ name: \"Foo\" }];\n        return true;\n      }\n      return false;\n    },\n  };\n  const fakeTask = new WorkerTask(\"fake\", null);\n  return evaluator\n    .getOperatorList({\n      stream: fakeStream,\n      task: fakeTask,\n      resources,\n      operatorList: opList,\n    })\n    .then(() => {\n      // The shadingFill operator should be ignored, so no op added.\n      assert.equal(opList.fnArray.length, 0);\n    });\n});",
    "i3_deepseek-r1-distill-llama-70b": "it(\"should ignore shadingFill errors when ignoreErrors is enabled\", () => {\n  const xref = new XRefMock();\n  const opList = new OperatorList();\n  const resources = new Dict();\n  const shadingDict = new Dict();\n  // Do not add any shading object named \"Foo\".\n  resources.set(\"Shading\", shadingDict);\n  const evaluator = new PartialEvaluator({\n    xref,\n    handler: {},\n    pageIndex: 0,\n    idFactory: {},\n    fontCache: new Map(),\n    builtInCMapCache: new Map(),\n    standardFontDataCache: new Map(),\n    globalImageCache: new Map(),\n    systemFontCache: new Map(),\n    options: { ignoreErrors: true },\n  });\n  const fakeStream = {\n    called: false,\n    read(operation) {\n      if (!this.called) {\n        this.called = true;\n        operation.fn = OPS.shadingFill;\n        operation.args = [{ name: \"Foo\" }];\n        return true;\n      }\n      return false;\n    },\n  };\n  const fakeTask = new WorkerTask(\"fake\", null);\n  return evaluator\n    .getOperatorList({\n      stream: fakeStream,\n      task: fakeTask,\n      resources,\n      operatorList: opList,\n    })\n    .then(() => {\n      // The shadingFill operator should be ignored, so no op added.\n      assert.equal(opList.fnArray.length, 0);\n    });\n});",
    "i3_gpt-4o": "it(\"should ignore shadingFill errors when ignoreErrors is enabled\", () => {\n  const xref = new XRefMock();\n  const opList = new OperatorList();\n  const resources = new Dict();\n  const shadingDict = new Dict();\n  // Do not add any shading object named \"Foo\".\n  resources.set(\"Shading\", shadingDict);\n  const evaluator = new PartialEvaluator({\n    xref,\n    handler: {},\n    pageIndex: 0,\n    idFactory: {},\n    fontCache: new Map(),\n    builtInCMapCache: new Map(),\n    standardFontDataCache: new Map(),\n    globalImageCache: new Map(),\n    systemFontCache: new Map(),\n    options: { ignoreErrors: true },\n  });\n  const fakeStream = {\n    called: false,\n    read(operation) {\n      if (!this.called) {\n        this.called = true;\n        operation.fn = OPS.shadingFill;\n        operation.args = [{ name: \"Foo\" }];\n        return true;\n      }\n      return false;\n    },\n  };\n  const fakeTask = new WorkerTask(\"fake\", null);\n  return evaluator\n    .getOperatorList({\n      stream: fakeStream,\n      task: fakeTask,\n      resources,\n      operatorList: opList,\n    })\n    .then(() => {\n      // The shadingFill operator should be ignored, so no op added.\n      assert.equal(opList.fnArray.length, 0);\n    });\n});",
    "i3_llama-3.3-70b-versatile": "it(\"should ignore shadingFill errors when ignoreErrors is enabled\", () => {\n  const xref = new XRefMock();\n  const opList = new OperatorList();\n  const resources = new Dict();\n  const shadingDict = new Dict();\n  // Do not add any shading object named \"Foo\".\n  resources.set(\"Shading\", shadingDict);\n  const evaluator = new PartialEvaluator({\n    xref,\n    handler: {},\n    pageIndex: 0,\n    idFactory: {},\n    fontCache: new Map(),\n    builtInCMapCache: new Map(),\n    standardFontDataCache: new Map(),\n    globalImageCache: new Map(),\n    systemFontCache: new Map(),\n    options: { ignoreErrors: true },\n  });\n  const fakeStream = {\n    called: false,\n    read(operation) {\n      if (!this.called) {\n        this.called = true;\n        operation.fn = OPS.shadingFill;\n        operation.args = [{ name: \"Foo\" }];\n        return true;\n      }\n      return false;\n    },\n  };\n  const fakeTask = new WorkerTask(\"fake\", null);\n  return evaluator\n    .getOperatorList({\n      stream: fakeStream,\n      task: fakeTask,\n      resources,\n      operatorList: opList,\n    })\n    .then(() => {\n      // The shadingFill operator should be ignored, so no op added.\n      assert.equal(opList.fnArray.length, 0);\n    });\n});",
    "i4_deepseek-r1-distill-llama-70b": "it(\"should ignore shadingFill errors when ignoreErrors is enabled\", () => {\n  const xref = new XRefMock();\n  const opList = new OperatorList();\n  const resources = new Dict();\n  const shadingDict = new Dict();\n  // Do not add any shading object named \"Foo\".\n  resources.set(\"Shading\", shadingDict);\n  const evaluator = new PartialEvaluator({\n    xref,\n    handler: {},\n    pageIndex: 0,\n    idFactory: {},\n    fontCache: new Map(),\n    builtInCMapCache: new Map(),\n    standardFontDataCache: new Map(),\n    globalImageCache: new Map(),\n    systemFontCache: new Map(),\n    options: { ignoreErrors: true },\n  });\n  const fakeStream = {\n    called: false,\n    read(operation) {\n      if (!this.called) {\n        this.called = true;\n        operation.fn = OPS.shadingFill;\n        operation.args = [{ name: \"Foo\" }];\n        return true;\n      }\n      return false;\n    },\n  };\n  const fakeTask = new WorkerTask(\"fake\", null);\n  return evaluator\n    .getOperatorList({\n      stream: fakeStream,\n      task: fakeTask,\n      resources,\n      operatorList: opList,\n    })\n    .then(() => {\n      // The shadingFill operator should be ignored, so no op added.\n      assert.equal(opList.fnArray.length, 0);\n    });\n});",
    "i4_gpt-4o": "it(\"should ignore shadingFill errors when ignoreErrors is enabled\", () => {\n  const xref = new XRefMock();\n  const opList = new OperatorList();\n  const resources = new Dict();\n  const shadingDict = new Dict();\n  // Do not add any shading object named \"Foo\".\n  resources.set(\"Shading\", shadingDict);\n  const evaluator = new PartialEvaluator({\n    xref,\n    handler: {},\n    pageIndex: 0,\n    idFactory: {},\n    fontCache: new Map(),\n    builtInCMapCache: new Map(),\n    standardFontDataCache: new Map(),\n    globalImageCache: new Map(),\n    systemFontCache: new Map(),\n    options: { ignoreErrors: true },\n  });\n  const fakeStream = {\n    called: false,\n    read(operation) {\n      if (!this.called) {\n        this.called = true;\n        operation.fn = OPS.shadingFill;\n        operation.args = [{ name: \"Foo\" }];\n        return true;\n      }\n      return false;\n    },\n  };\n  const fakeTask = new WorkerTask(\"fake\", null);\n  return evaluator\n    .getOperatorList({\n      stream: fakeStream,\n      task: fakeTask,\n      resources,\n      operatorList: opList,\n    })\n    .then(() => {\n      // The shadingFill operator should be ignored, so no op added.\n      assert.equal(opList.fnArray.length, 0);\n    });\n});",
    "i4_llama-3.3-70b-versatile": "it(\"should ignore shadingFill errors when ignoreErrors is enabled\", () => {\n  const xref = new XRefMock();\n  const opList = new OperatorList();\n  const resources = new Dict();\n  const shadingDict = new Dict();\n  // Do not add any shading object named \"Foo\".\n  resources.set(\"Shading\", shadingDict);\n  const evaluator = new PartialEvaluator({\n    xref,\n    handler: {},\n    pageIndex: 0,\n    idFactory: {},\n    fontCache: new Map(),\n    builtInCMapCache: new Map(),\n    standardFontDataCache: new Map(),\n    globalImageCache: new Map(),\n    systemFontCache: new Map(),\n    options: { ignoreErrors: true },\n  });\n  const fakeStream = {\n    called: false,\n    read(operation) {\n      if (!this.called) {\n        this.called = true;\n        operation.fn = OPS.shadingFill;\n        operation.args = [{ name: \"Foo\" }];\n        return true;\n      }\n      return false;\n    },\n  };\n  const fakeTask = new WorkerTask(\"fake\", null);\n  return evaluator\n    .getOperatorList({\n      stream: fakeStream,\n      task: fakeTask,\n      resources,\n      operatorList: opList,\n    })\n    .then(() => {\n      // The shadingFill operator should be ignored, so no op added.\n      assert.equal(opList.fnArray.length, 0);\n    });\n});",
    "i5_deepseek-r1-distill-llama-70b": "it(\"should ignore shadingFill errors when ignoreErrors is enabled\", () => {\n  const xref = new XRefMock();\n  const opList = new OperatorList();\n  const resources = new Dict();\n  const shadingDict = new Dict();\n  // Do not add any shading object named \"Foo\".\n  resources.set(\"Shading\", shadingDict);\n  const evaluator = new PartialEvaluator({\n    xref,\n    handler: {},\n    pageIndex: 0,\n    idFactory: {},\n    fontCache: new Map(),\n    builtInCMapCache: new Map(),\n    standardFontDataCache: new Map(),\n    globalImageCache: new Map(),\n    systemFontCache: new Map(),\n    options: { ignoreErrors: true },\n  });\n  const fakeStream = {\n    called: false,\n    read(operation) {\n      if (!this.called) {\n        this.called = true;\n        operation.fn = OPS.shadingFill;\n        operation.args = [{ name: \"Foo\" }];\n        return true;\n      }\n      return false;\n    },\n  };\n  const fakeTask = new WorkerTask(\"fake\", null);\n  return evaluator\n    .getOperatorList({\n      stream: fakeStream,\n      task: fakeTask,\n      resources,\n      operatorList: opList,\n    })\n    .then(() => {\n      // The shadingFill operator should be ignored, so no op added.\n      assert.equal(opList.fnArray.length, 0);\n    });\n});",
    "i5_gpt-4o": "it(\"should ignore shadingFill errors when ignoreErrors is enabled\", () => {\n  const xref = new XRefMock();\n  const opList = new OperatorList();\n  const resources = new Dict();\n  const shadingDict = new Dict();\n  // Do not add any shading object named \"Foo\".\n  resources.set(\"Shading\", shadingDict);\n  const evaluator = new PartialEvaluator({\n    xref,\n    handler: {},\n    pageIndex: 0,\n    idFactory: {},\n    fontCache: new Map(),\n    builtInCMapCache: new Map(),\n    standardFontDataCache: new Map(),\n    globalImageCache: new Map(),\n    systemFontCache: new Map(),\n    options: { ignoreErrors: true },\n  });\n  const fakeStream = {\n    called: false,\n    read(operation) {\n      if (!this.called) {\n        this.called = true;\n        operation.fn = OPS.shadingFill;\n        operation.args = [{ name: \"Foo\" }];\n        return true;\n      }\n      return false;\n    },\n  };\n  const fakeTask = new WorkerTask(\"fake\", null);\n  return evaluator\n    .getOperatorList({\n      stream: fakeStream,\n      task: fakeTask,\n      resources,\n      operatorList: opList,\n    })\n    .then(() => {\n      // The shadingFill operator should be ignored, so no op added.\n      assert.equal(opList.fnArray.length, 0);\n    });\n});",
    "i5_llama-3.3-70b-versatile": "it(\"should ignore shadingFill errors when ignoreErrors is enabled\", () => {\n  const xref = new XRefMock();\n  const opList = new OperatorList();\n  const resources = new Dict();\n  const shadingDict = new Dict();\n  // Do not add any shading object named \"Foo\".\n  resources.set(\"Shading\", shadingDict);\n  const evaluator = new PartialEvaluator({\n    xref,\n    handler: {},\n    pageIndex: 0,\n    idFactory: {},\n    fontCache: new Map(),\n    builtInCMapCache: new Map(),\n    standardFontDataCache: new Map(),\n    globalImageCache: new Map(),\n    systemFontCache: new Map(),\n    options: { ignoreErrors: true },\n  });\n  const fakeStream = {\n    called: false,\n    read(operation) {\n      if (!this.called) {\n        this.called = true;\n        operation.fn = OPS.shadingFill;\n        operation.args = [{ name: \"Foo\" }];\n        return true;\n      }\n      return false;\n    },\n  };\n  const fakeTask = new WorkerTask(\"fake\", null);\n  return evaluator\n    .getOperatorList({\n      stream: fakeStream,\n      task: fakeTask,\n      resources,\n      operatorList: opList,\n    })\n    .then(() => {\n      // The shadingFill operator should be ignored, so no op added.\n      assert.equal(opList.fnArray.length, 0);\n    });\n});"
  },
  "18798": {
    "i1_deepseek-r1-distill-llama-70b": "it(\"should use the original bbox origin even if negative\", async () => {\n  const { TilingPattern } = await import(\"../../src/display/pattern_helper.js\");\n\n  const dummyCtx = {\n    canvas: { width: 100, height: 100 },\n    translate() {},\n    save() {},\n    restore() {},\n  };\n\n  const dummyGraphicsFactory = {\n    createCanvasGraphics: (ctx) => ({\n      ctx,\n      groupLevel: 0,\n      transform() {},\n      executeOperatorList() {},\n      endDrawing() {},\n    }),\n  };\n\n  const IR = [];\n  IR[2] = []; // operatorList\n  IR[3] = [1, 0, 0, 1, 0, 0]; // matrix (identity)\n  IR[4] = [-10, -10, 10, 10]; // bbox with negative origin\n  IR[5] = 20; // xstep\n  IR[6] = 20; // ystep\n  IR[7] = 1; // paintType\n  IR[8] = 1; // tilingType\n\n  const pattern = new TilingPattern(IR, \"black\", dummyCtx, dummyGraphicsFactory, [1, 0, 0, 1, 0, 0]);\n\n  const owner = {\n    cachedCanvases: {\n      getCanvas: (name, width, height) => ({\n        canvas: { width, height },\n        context: {\n          canvas: { width, height },\n          translate() {},\n          save() {},\n          restore() {},\n        },\n      }),\n    },\n    groupLevel: 0,\n  };\n\n  const result = pattern.createPatternCanvas(owner);\n  if (result.offsetX !== -10 || result.offsetY !== -10) {\n    throw new Error(\"Pattern offsets do not match the original bbox values.\");\n  }\n});",
    "i1_gpt-4o": "it(\"should use the original bbox origin even if negative\", async () => {\n  const { TilingPattern } = await import(\"../../src/display/pattern_helper.js\");\n\n  const dummyCtx = {\n    canvas: { width: 100, height: 100 },\n    translate() {},\n    save() {},\n    restore() {},\n  };\n\n  const dummyGraphicsFactory = {\n    createCanvasGraphics: (ctx) => ({\n      ctx,\n      groupLevel: 0,\n      transform() {},\n      executeOperatorList() {},\n      endDrawing() {},\n    }),\n  };\n\n  const IR = [];\n  IR[2] = []; // operatorList\n  IR[3] = [1, 0, 0, 1, 0, 0]; // matrix (identity)\n  IR[4] = [-10, -10, 10, 10]; // bbox with negative origin\n  IR[5] = 20; // xstep\n  IR[6] = 20; // ystep\n  IR[7] = 1; // paintType\n  IR[8] = 1; // tilingType\n\n  const pattern = new TilingPattern(IR, \"black\", dummyCtx, dummyGraphicsFactory, [1, 0, 0, 1, 0, 0]);\n\n  const owner = {\n    cachedCanvases: {\n      getCanvas: (name, width, height) => ({\n        canvas: { width, height },\n        context: {\n          canvas: { width, height },\n          translate() {},\n          save() {},\n          restore() {},\n        },\n      }),\n    },\n    groupLevel: 0,\n  };\n\n  const result = pattern.createPatternCanvas(owner);\n  if (result.offsetX !== -10 || result.offsetY !== -10) {\n    throw new Error(\"Pattern offsets do not match the original bbox values.\");\n  }\n});",
    "i1_llama-3.3-70b-versatile": "it(\"should use the original bbox origin even if negative\", async () => {\n  const { TilingPattern } = await import(\"../../src/display/pattern_helper.js\");\n\n  const dummyCtx = {\n    canvas: { width: 100, height: 100 },\n    translate() {},\n    save() {},\n    restore() {},\n  };\n\n  const dummyGraphicsFactory = {\n    createCanvasGraphics: (ctx) => ({\n      ctx,\n      groupLevel: 0,\n      transform() {},\n      executeOperatorList() {},\n      endDrawing() {},\n    }),\n  };\n\n  const IR = [];\n  IR[2] = []; // operatorList\n  IR[3] = [1, 0, 0, 1, 0, 0]; // matrix (identity)\n  IR[4] = [-10, -10, 10, 10]; // bbox with negative origin\n  IR[5] = 20; // xstep\n  IR[6] = 20; // ystep\n  IR[7] = 1; // paintType\n  IR[8] = 1; // tilingType\n\n  const pattern = new TilingPattern(IR, \"black\", dummyCtx, dummyGraphicsFactory, [1, 0, 0, 1, 0, 0]);\n\n  const owner = {\n    cachedCanvases: {\n      getCanvas: (name, width, height) => ({\n        canvas: { width, height },\n        context: {\n          canvas: { width, height },\n          translate() {},\n          save() {},\n          restore() {},\n        },\n      }),\n    },\n    groupLevel: 0,\n  };\n\n  const result = pattern.createPatternCanvas(owner);\n  if (result.offsetX !== -10 || result.offsetY !== -10) {\n    throw new Error(\"Pattern offsets do not match the original bbox values.\");\n  }\n});",
    "i1_MOCK": "it(\"should use the original bbox origin even if negative\", async () => {\n  const { TilingPattern } = await import(\"../../src/display/pattern_helper.js\");\n\n  const dummyCtx = {\n    canvas: { width: 100, height: 100 },\n    translate() {},\n    save() {},\n    restore() {},\n  };\n\n  const dummyGraphicsFactory = {\n    createCanvasGraphics: (ctx) => ({\n      ctx,\n      groupLevel: 0,\n      transform() {},\n      executeOperatorList() {},\n      endDrawing() {},\n    }),\n  };\n\n  const IR = [];\n  IR[2] = []; // operatorList\n  IR[3] = [1, 0, 0, 1, 0, 0]; // matrix (identity)\n  IR[4] = [-10, -10, 10, 10]; // bbox with negative origin\n  IR[5] = 20; // xstep\n  IR[6] = 20; // ystep\n  IR[7] = 1; // paintType\n  IR[8] = 1; // tilingType\n\n  const pattern = new TilingPattern(IR, \"black\", dummyCtx, dummyGraphicsFactory, [1, 0, 0, 1, 0, 0]);\n\n  const owner = {\n    cachedCanvases: {\n      getCanvas: (name, width, height) => ({\n        canvas: { width, height },\n        context: {\n          canvas: { width, height },\n          translate() {},\n          save() {},\n          restore() {},\n        },\n      }),\n    },\n    groupLevel: 0,\n  };\n\n  const result = pattern.createPatternCanvas(owner);\n  if (result.offsetX !== -10 || result.offsetY !== -10) {\n    throw new Error(\"Pattern offsets do not match the original bbox values.\");\n  }\n});",
    "i2_deepseek-r1-distill-llama-70b": "it(\"should use the original bbox origin even if negative\", async () => {\n  const { TilingPattern } = await import(\"../../src/display/pattern_helper.js\");\n\n  const dummyCtx = {\n    canvas: { width: 100, height: 100 },\n    translate() {},\n    save() {},\n    restore() {},\n  };\n\n  const dummyGraphicsFactory = {\n    createCanvasGraphics: (ctx) => ({\n      ctx,\n      groupLevel: 0,\n      transform() {},\n      executeOperatorList() {},\n      endDrawing() {},\n    }),\n  };\n\n  const IR = [];\n  IR[2] = []; // operatorList\n  IR[3] = [1, 0, 0, 1, 0, 0]; // matrix (identity)\n  IR[4] = [-10, -10, 10, 10]; // bbox with negative origin\n  IR[5] = 20; // xstep\n  IR[6] = 20; // ystep\n  IR[7] = 1; // paintType\n  IR[8] = 1; // tilingType\n\n  const pattern = new TilingPattern(IR, \"black\", dummyCtx, dummyGraphicsFactory, [1, 0, 0, 1, 0, 0]);\n\n  const owner = {\n    cachedCanvases: {\n      getCanvas: (name, width, height) => ({\n        canvas: { width, height },\n        context: {\n          canvas: { width, height },\n          translate() {},\n          save() {},\n          restore() {},\n        },\n      }),\n    },\n    groupLevel: 0,\n  };\n\n  const result = pattern.createPatternCanvas(owner);\n  if (result.offsetX !== -10 || result.offsetY !== -10) {\n    throw new Error(\"Pattern offsets do not match the original bbox values.\");\n  }\n});",
    "i2_gpt-4o": "it(\"should use the original bbox origin even if negative\", async () => {\n  const { TilingPattern } = await import(\"../../src/display/pattern_helper.js\");\n\n  const dummyCtx = {\n    canvas: { width: 100, height: 100 },\n    translate() {},\n    save() {},\n    restore() {},\n  };\n\n  const dummyGraphicsFactory = {\n    createCanvasGraphics: (ctx) => ({\n      ctx,\n      groupLevel: 0,\n      transform() {},\n      executeOperatorList() {},\n      endDrawing() {},\n    }),\n  };\n\n  const IR = [];\n  IR[2] = []; // operatorList\n  IR[3] = [1, 0, 0, 1, 0, 0]; // matrix (identity)\n  IR[4] = [-10, -10, 10, 10]; // bbox with negative origin\n  IR[5] = 20; // xstep\n  IR[6] = 20; // ystep\n  IR[7] = 1; // paintType\n  IR[8] = 1; // tilingType\n\n  const pattern = new TilingPattern(IR, \"black\", dummyCtx, dummyGraphicsFactory, [1, 0, 0, 1, 0, 0]);\n\n  const owner = {\n    cachedCanvases: {\n      getCanvas: (name, width, height) => ({\n        canvas: { width, height },\n        context: {\n          canvas: { width, height },\n          translate() {},\n          save() {},\n          restore() {},\n        },\n      }),\n    },\n    groupLevel: 0,\n  };\n\n  const result = pattern.createPatternCanvas(owner);\n  if (result.offsetX !== -10 || result.offsetY !== -10) {\n    throw new Error(\"Pattern offsets do not match the original bbox values.\");\n  }\n});",
    "i2_llama-3.3-70b-versatile": "it(\"should use the original bbox origin even if negative\", async () => {\n  const { TilingPattern } = await import(\"../../src/display/pattern_helper.js\");\n\n  const dummyCtx = {\n    canvas: { width: 100, height: 100 },\n    translate() {},\n    save() {},\n    restore() {},\n  };\n\n  const dummyGraphicsFactory = {\n    createCanvasGraphics: (ctx) => ({\n      ctx,\n      groupLevel: 0,\n      transform() {},\n      executeOperatorList() {},\n      endDrawing() {},\n    }),\n  };\n\n  const IR = [];\n  IR[2] = []; // operatorList\n  IR[3] = [1, 0, 0, 1, 0, 0]; // matrix (identity)\n  IR[4] = [-10, -10, 10, 10]; // bbox with negative origin\n  IR[5] = 20; // xstep\n  IR[6] = 20; // ystep\n  IR[7] = 1; // paintType\n  IR[8] = 1; // tilingType\n\n  const pattern = new TilingPattern(IR, \"black\", dummyCtx, dummyGraphicsFactory, [1, 0, 0, 1, 0, 0]);\n\n  const owner = {\n    cachedCanvases: {\n      getCanvas: (name, width, height) => ({\n        canvas: { width, height },\n        context: {\n          canvas: { width, height },\n          translate() {},\n          save() {},\n          restore() {},\n        },\n      }),\n    },\n    groupLevel: 0,\n  };\n\n  const result = pattern.createPatternCanvas(owner);\n  if (result.offsetX !== -10 || result.offsetY !== -10) {\n    throw new Error(\"Pattern offsets do not match the original bbox values.\");\n  }\n});",
    "i3_deepseek-r1-distill-llama-70b": "it(\"should use the original bbox origin even if negative\", async () => {\n  const { TilingPattern } = await import(\"../../src/display/pattern_helper.js\");\n\n  const dummyCtx = {\n    canvas: { width: 100, height: 100 },\n    translate() {},\n    save() {},\n    restore() {},\n  };\n\n  const dummyGraphicsFactory = {\n    createCanvasGraphics: (ctx) => ({\n      ctx,\n      groupLevel: 0,\n      transform() {},\n      executeOperatorList() {},\n      endDrawing() {},\n    }),\n  };\n\n  const IR = [];\n  IR[2] = []; // operatorList\n  IR[3] = [1, 0, 0, 1, 0, 0]; // matrix (identity)\n  IR[4] = [-10, -10, 10, 10]; // bbox with negative origin\n  IR[5] = 20; // xstep\n  IR[6] = 20; // ystep\n  IR[7] = 1; // paintType\n  IR[8] = 1; // tilingType\n\n  const pattern = new TilingPattern(IR, \"black\", dummyCtx, dummyGraphicsFactory, [1, 0, 0, 1, 0, 0]);\n\n  const owner = {\n    cachedCanvases: {\n      getCanvas: (name, width, height) => ({\n        canvas: { width, height },\n        context: {\n          canvas: { width, height },\n          translate() {},\n          save() {},\n          restore() {},\n        },\n      }),\n    },\n    groupLevel: 0,\n  };\n\n  const result = pattern.createPatternCanvas(owner);\n  if (result.offsetX !== -10 || result.offsetY !== -10) {\n    throw new Error(\"Pattern offsets do not match the original bbox values.\");\n  }\n});",
    "i3_gpt-4o": "it(\"should use the original bbox origin even if negative\", async () => {\n  const { TilingPattern } = await import(\"../../src/display/pattern_helper.js\");\n\n  const dummyCtx = {\n    canvas: { width: 100, height: 100 },\n    translate() {},\n    save() {},\n    restore() {},\n  };\n\n  const dummyGraphicsFactory = {\n    createCanvasGraphics: (ctx) => ({\n      ctx,\n      groupLevel: 0,\n      transform() {},\n      executeOperatorList() {},\n      endDrawing() {},\n    }),\n  };\n\n  const IR = [];\n  IR[2] = []; // operatorList\n  IR[3] = [1, 0, 0, 1, 0, 0]; // matrix (identity)\n  IR[4] = [-10, -10, 10, 10]; // bbox with negative origin\n  IR[5] = 20; // xstep\n  IR[6] = 20; // ystep\n  IR[7] = 1; // paintType\n  IR[8] = 1; // tilingType\n\n  const pattern = new TilingPattern(IR, \"black\", dummyCtx, dummyGraphicsFactory, [1, 0, 0, 1, 0, 0]);\n\n  const owner = {\n    cachedCanvases: {\n      getCanvas: (name, width, height) => ({\n        canvas: { width, height },\n        context: {\n          canvas: { width, height },\n          translate() {},\n          save() {},\n          restore() {},\n        },\n      }),\n    },\n    groupLevel: 0,\n  };\n\n  const result = pattern.createPatternCanvas(owner);\n  if (result.offsetX !== -10 || result.offsetY !== -10) {\n    throw new Error(\"Pattern offsets do not match the original bbox values.\");\n  }\n});",
    "i3_llama-3.3-70b-versatile": "it(\"should use the original bbox origin even if negative\", async () => {\n  const { TilingPattern } = await import(\"../../src/display/pattern_helper.js\");\n\n  const dummyCtx = {\n    canvas: { width: 100, height: 100 },\n    translate() {},\n    save() {},\n    restore() {},\n  };\n\n  const dummyGraphicsFactory = {\n    createCanvasGraphics: (ctx) => ({\n      ctx,\n      groupLevel: 0,\n      transform() {},\n      executeOperatorList() {},\n      endDrawing() {},\n    }),\n  };\n\n  const IR = [];\n  IR[2] = []; // operatorList\n  IR[3] = [1, 0, 0, 1, 0, 0]; // matrix (identity)\n  IR[4] = [-10, -10, 10, 10]; // bbox with negative origin\n  IR[5] = 20; // xstep\n  IR[6] = 20; // ystep\n  IR[7] = 1; // paintType\n  IR[8] = 1; // tilingType\n\n  const pattern = new TilingPattern(IR, \"black\", dummyCtx, dummyGraphicsFactory, [1, 0, 0, 1, 0, 0]);\n\n  const owner = {\n    cachedCanvases: {\n      getCanvas: (name, width, height) => ({\n        canvas: { width, height },\n        context: {\n          canvas: { width, height },\n          translate() {},\n          save() {},\n          restore() {},\n        },\n      }),\n    },\n    groupLevel: 0,\n  };\n\n  const result = pattern.createPatternCanvas(owner);\n  if (result.offsetX !== -10 || result.offsetY !== -10) {\n    throw new Error(\"Pattern offsets do not match the original bbox values.\");\n  }\n});",
    "i4_deepseek-r1-distill-llama-70b": "it(\"should use the original bbox origin even if negative\", async () => {\n  const { TilingPattern } = await import(\"../../src/display/pattern_helper.js\");\n\n  const dummyCtx = {\n    canvas: { width: 100, height: 100 },\n    translate() {},\n    save() {},\n    restore() {},\n  };\n\n  const dummyGraphicsFactory = {\n    createCanvasGraphics: (ctx) => ({\n      ctx,\n      groupLevel: 0,\n      transform() {},\n      executeOperatorList() {},\n      endDrawing() {},\n    }),\n  };\n\n  const IR = [];\n  IR[2] = []; // operatorList\n  IR[3] = [1, 0, 0, 1, 0, 0]; // matrix (identity)\n  IR[4] = [-10, -10, 10, 10]; // bbox with negative origin\n  IR[5] = 20; // xstep\n  IR[6] = 20; // ystep\n  IR[7] = 1; // paintType\n  IR[8] = 1; // tilingType\n\n  const pattern = new TilingPattern(IR, \"black\", dummyCtx, dummyGraphicsFactory, [1, 0, 0, 1, 0, 0]);\n\n  const owner = {\n    cachedCanvases: {\n      getCanvas: (name, width, height) => ({\n        canvas: { width, height },\n        context: {\n          canvas: { width, height },\n          translate() {},\n          save() {},\n          restore() {},\n        },\n      }),\n    },\n    groupLevel: 0,\n  };\n\n  const result = pattern.createPatternCanvas(owner);\n  if (result.offsetX !== -10 || result.offsetY !== -10) {\n    throw new Error(\"Pattern offsets do not match the original bbox values.\");\n  }\n});",
    "i4_gpt-4o": "it(\"should use the original bbox origin even if negative\", async () => {\n  const { TilingPattern } = await import(\"../../src/display/pattern_helper.js\");\n\n  const dummyCtx = {\n    canvas: { width: 100, height: 100 },\n    translate() {},\n    save() {},\n    restore() {},\n  };\n\n  const dummyGraphicsFactory = {\n    createCanvasGraphics: (ctx) => ({\n      ctx,\n      groupLevel: 0,\n      transform() {},\n      executeOperatorList() {},\n      endDrawing() {},\n    }),\n  };\n\n  const IR = [];\n  IR[2] = []; // operatorList\n  IR[3] = [1, 0, 0, 1, 0, 0]; // matrix (identity)\n  IR[4] = [-10, -10, 10, 10]; // bbox with negative origin\n  IR[5] = 20; // xstep\n  IR[6] = 20; // ystep\n  IR[7] = 1; // paintType\n  IR[8] = 1; // tilingType\n\n  const pattern = new TilingPattern(IR, \"black\", dummyCtx, dummyGraphicsFactory, [1, 0, 0, 1, 0, 0]);\n\n  const owner = {\n    cachedCanvases: {\n      getCanvas: (name, width, height) => ({\n        canvas: { width, height },\n        context: {\n          canvas: { width, height },\n          translate() {},\n          save() {},\n          restore() {},\n        },\n      }),\n    },\n    groupLevel: 0,\n  };\n\n  const result = pattern.createPatternCanvas(owner);\n  if (result.offsetX !== -10 || result.offsetY !== -10) {\n    throw new Error(\"Pattern offsets do not match the original bbox values.\");\n  }\n});",
    "i4_llama-3.3-70b-versatile": "it(\"should use the original bbox origin even if negative\", async () => {\n  const { TilingPattern } = await import(\"../../src/display/pattern_helper.js\");\n\n  const dummyCtx = {\n    canvas: { width: 100, height: 100 },\n    translate() {},\n    save() {},\n    restore() {},\n  };\n\n  const dummyGraphicsFactory = {\n    createCanvasGraphics: (ctx) => ({\n      ctx,\n      groupLevel: 0,\n      transform() {},\n      executeOperatorList() {},\n      endDrawing() {},\n    }),\n  };\n\n  const IR = [];\n  IR[2] = []; // operatorList\n  IR[3] = [1, 0, 0, 1, 0, 0]; // matrix (identity)\n  IR[4] = [-10, -10, 10, 10]; // bbox with negative origin\n  IR[5] = 20; // xstep\n  IR[6] = 20; // ystep\n  IR[7] = 1; // paintType\n  IR[8] = 1; // tilingType\n\n  const pattern = new TilingPattern(IR, \"black\", dummyCtx, dummyGraphicsFactory, [1, 0, 0, 1, 0, 0]);\n\n  const owner = {\n    cachedCanvases: {\n      getCanvas: (name, width, height) => ({\n        canvas: { width, height },\n        context: {\n          canvas: { width, height },\n          translate() {},\n          save() {},\n          restore() {},\n        },\n      }),\n    },\n    groupLevel: 0,\n  };\n\n  const result = pattern.createPatternCanvas(owner);\n  if (result.offsetX !== -10 || result.offsetY !== -10) {\n    throw new Error(\"Pattern offsets do not match the original bbox values.\");\n  }\n});",
    "i5_deepseek-r1-distill-llama-70b": "it(\"should use the original bbox origin even if negative\", async () => {\n  const { TilingPattern } = await import(\"../../src/display/pattern_helper.js\");\n\n  const dummyCtx = {\n    canvas: { width: 100, height: 100 },\n    translate() {},\n    save() {},\n    restore() {},\n  };\n\n  const dummyGraphicsFactory = {\n    createCanvasGraphics: (ctx) => ({\n      ctx,\n      groupLevel: 0,\n      transform() {},\n      executeOperatorList() {},\n      endDrawing() {},\n    }),\n  };\n\n  const IR = [];\n  IR[2] = []; // operatorList\n  IR[3] = [1, 0, 0, 1, 0, 0]; // matrix (identity)\n  IR[4] = [-10, -10, 10, 10]; // bbox with negative origin\n  IR[5] = 20; // xstep\n  IR[6] = 20; // ystep\n  IR[7] = 1; // paintType\n  IR[8] = 1; // tilingType\n\n  const pattern = new TilingPattern(IR, \"black\", dummyCtx, dummyGraphicsFactory, [1, 0, 0, 1, 0, 0]);\n\n  const owner = {\n    cachedCanvases: {\n      getCanvas: (name, width, height) => ({\n        canvas: { width, height },\n        context: {\n          canvas: { width, height },\n          translate() {},\n          save() {},\n          restore() {},\n        },\n      }),\n    },\n    groupLevel: 0,\n  };\n\n  const result = pattern.createPatternCanvas(owner);\n  if (result.offsetX !== -10 || result.offsetY !== -10) {\n    throw new Error(\"Pattern offsets do not match the original bbox values.\");\n  }\n});",
    "i5_gpt-4o": "it(\"should use the original bbox origin even if negative\", async () => {\n  const { TilingPattern } = await import(\"../../src/display/pattern_helper.js\");\n\n  const dummyCtx = {\n    canvas: { width: 100, height: 100 },\n    translate() {},\n    save() {},\n    restore() {},\n  };\n\n  const dummyGraphicsFactory = {\n    createCanvasGraphics: (ctx) => ({\n      ctx,\n      groupLevel: 0,\n      transform() {},\n      executeOperatorList() {},\n      endDrawing() {},\n    }),\n  };\n\n  const IR = [];\n  IR[2] = []; // operatorList\n  IR[3] = [1, 0, 0, 1, 0, 0]; // matrix (identity)\n  IR[4] = [-10, -10, 10, 10]; // bbox with negative origin\n  IR[5] = 20; // xstep\n  IR[6] = 20; // ystep\n  IR[7] = 1; // paintType\n  IR[8] = 1; // tilingType\n\n  const pattern = new TilingPattern(IR, \"black\", dummyCtx, dummyGraphicsFactory, [1, 0, 0, 1, 0, 0]);\n\n  const owner = {\n    cachedCanvases: {\n      getCanvas: (name, width, height) => ({\n        canvas: { width, height },\n        context: {\n          canvas: { width, height },\n          translate() {},\n          save() {},\n          restore() {},\n        },\n      }),\n    },\n    groupLevel: 0,\n  };\n\n  const result = pattern.createPatternCanvas(owner);\n  if (result.offsetX !== -10 || result.offsetY !== -10) {\n    throw new Error(\"Pattern offsets do not match the original bbox values.\");\n  }\n});",
    "i5_llama-3.3-70b-versatile": "it(\"should use the original bbox origin even if negative\", async () => {\n  const { TilingPattern } = await import(\"../../src/display/pattern_helper.js\");\n\n  const dummyCtx = {\n    canvas: { width: 100, height: 100 },\n    translate() {},\n    save() {},\n    restore() {},\n  };\n\n  const dummyGraphicsFactory = {\n    createCanvasGraphics: (ctx) => ({\n      ctx,\n      groupLevel: 0,\n      transform() {},\n      executeOperatorList() {},\n      endDrawing() {},\n    }),\n  };\n\n  const IR = [];\n  IR[2] = []; // operatorList\n  IR[3] = [1, 0, 0, 1, 0, 0]; // matrix (identity)\n  IR[4] = [-10, -10, 10, 10]; // bbox with negative origin\n  IR[5] = 20; // xstep\n  IR[6] = 20; // ystep\n  IR[7] = 1; // paintType\n  IR[8] = 1; // tilingType\n\n  const pattern = new TilingPattern(IR, \"black\", dummyCtx, dummyGraphicsFactory, [1, 0, 0, 1, 0, 0]);\n\n  const owner = {\n    cachedCanvases: {\n      getCanvas: (name, width, height) => ({\n        canvas: { width, height },\n        context: {\n          canvas: { width, height },\n          translate() {},\n          save() {},\n          restore() {},\n        },\n      }),\n    },\n    groupLevel: 0,\n  };\n\n  const result = pattern.createPatternCanvas(owner);\n  if (result.offsetX !== -10 || result.offsetY !== -10) {\n    throw new Error(\"Pattern offsets do not match the original bbox values.\");\n  }\n});"
  },
  "18824": {
    "i1_deepseek-r1-distill-llama-70b": "it(\"should correctly update annotation flags when saving with noViewnoPrint set\", async () => {\n  const { WidgetAnnotation } = await import(\"../../src/core/annotation.js\");\n  const { Dict, Name } = await import(\"../../src/core/primitives.js\");\n  const { XRefMock } = await import(\"./test_utils.js\");\n  const xref = new XRefMock();\n  const dict = new Dict(xref);\n  dict.set(\"F\", 0);\n  dict.set(\"FT\", Name.get(\"Btn\"));\n  const annotationGlobals = { acroForm: new Dict(xref) };\n  const widget = new WidgetAnnotation({\n    dict,\n    xref,\n    annotationGlobals,\n    pageRef: null,\n    pageIndex: 0,\n    id: \"testAnnot\",\n    needAppearances: true,\n    collectFields: true,\n  });\n  const storageEntry = { noView: true, noPrint: false, value: widget.data.fieldValue, rotation: undefined };\n  const annotationStorage = new Map();\n  annotationStorage.set(widget.data.id, storageEntry);\n  const evaluator = { xref };\n  const task = { name: \"testTask\" };\n  const changes = await widget.save(evaluator, task, annotationStorage);\n  const savedData = changes && changes[0] && changes[0].data;\n  if (!savedData) {\n    throw new Error(\"No saved data returned\");\n  }\n  if (!savedData.includes(\"/F\")) {\n    throw new Error(\"Annotation flags were not properly updated in the saved data\");\n  }\n});\n",
    "i1_gpt-4o": "it(\"should correctly update annotation flags when saving with noViewnoPrint set\", async () => {\n  const { WidgetAnnotation } = await import(\"../../src/core/annotation.js\");\n  const { Dict, Name } = await import(\"../../src/core/primitives.js\");\n  const { XRefMock } = await import(\"./test_utils.js\");\n  const xref = new XRefMock();\n  const dict = new Dict(xref);\n  dict.set(\"F\", 0);\n  dict.set(\"FT\", Name.get(\"Btn\"));\n  const annotationGlobals = { acroForm: new Dict(xref) };\n  const widget = new WidgetAnnotation({\n    dict,\n    xref,\n    annotationGlobals,\n    pageRef: null,\n    pageIndex: 0,\n    id: \"testAnnot\",\n    needAppearances: true,\n    collectFields: true,\n  });\n  const storageEntry = { noView: true, noPrint: false, value: widget.data.fieldValue, rotation: undefined };\n  const annotationStorage = new Map();\n  annotationStorage.set(widget.data.id, storageEntry);\n  const evaluator = { xref };\n  const task = { name: \"testTask\" };\n  const changes = await widget.save(evaluator, task, annotationStorage);\n  const savedData = changes && changes[0] && changes[0].data;\n  if (!savedData) {\n    throw new Error(\"No saved data returned\");\n  }\n  if (!savedData.includes(\"/F\")) {\n    throw new Error(\"Annotation flags were not properly updated in the saved data\");\n  }\n});\n",
    "i1_llama-3.3-70b-versatile": "it(\"should correctly update annotation flags when saving with noViewnoPrint set\", async () => {\n  const { WidgetAnnotation } = await import(\"../../src/core/annotation.js\");\n  const { Dict, Name } = await import(\"../../src/core/primitives.js\");\n  const { XRefMock } = await import(\"./test_utils.js\");\n  const xref = new XRefMock();\n  const dict = new Dict(xref);\n  dict.set(\"F\", 0);\n  dict.set(\"FT\", Name.get(\"Btn\"));\n  const annotationGlobals = { acroForm: new Dict(xref) };\n  const widget = new WidgetAnnotation({\n    dict,\n    xref,\n    annotationGlobals,\n    pageRef: null,\n    pageIndex: 0,\n    id: \"testAnnot\",\n    needAppearances: true,\n    collectFields: true,\n  });\n  const storageEntry = { noView: true, noPrint: false, value: widget.data.fieldValue, rotation: undefined };\n  const annotationStorage = new Map();\n  annotationStorage.set(widget.data.id, storageEntry);\n  const evaluator = { xref };\n  const task = { name: \"testTask\" };\n  const changes = await widget.save(evaluator, task, annotationStorage);\n  const savedData = changes && changes[0] && changes[0].data;\n  if (!savedData) {\n    throw new Error(\"No saved data returned\");\n  }\n  if (!savedData.includes(\"/F\")) {\n    throw new Error(\"Annotation flags were not properly updated in the saved data\");\n  }\n});\n",
    "i1_MOCK": "it(\"should correctly update annotation flags when saving with noViewnoPrint set\", async () => {\n  const { WidgetAnnotation } = await import(\"../../src/core/annotation.js\");\n  const { Dict, Name } = await import(\"../../src/core/primitives.js\");\n  const { XRefMock } = await import(\"./test_utils.js\");\n  const xref = new XRefMock();\n  const dict = new Dict(xref);\n  dict.set(\"F\", 0);\n  dict.set(\"FT\", Name.get(\"Btn\"));\n  const annotationGlobals = { acroForm: new Dict(xref) };\n  const widget = new WidgetAnnotation({\n    dict,\n    xref,\n    annotationGlobals,\n    pageRef: null,\n    pageIndex: 0,\n    id: \"testAnnot\",\n    needAppearances: true,\n    collectFields: true,\n  });\n  const storageEntry = { noView: true, noPrint: false, value: widget.data.fieldValue, rotation: undefined };\n  const annotationStorage = new Map();\n  annotationStorage.set(widget.data.id, storageEntry);\n  const evaluator = { xref };\n  const task = { name: \"testTask\" };\n  const changes = await widget.save(evaluator, task, annotationStorage);\n  const savedData = changes && changes[0] && changes[0].data;\n  if (!savedData) {\n    throw new Error(\"No saved data returned\");\n  }\n  if (!savedData.includes(\"/F\")) {\n    throw new Error(\"Annotation flags were not properly updated in the saved data\");\n  }\n});\n",
    "i2_deepseek-r1-distill-llama-70b": "it(\"should correctly update annotation flags when saving with noViewnoPrint set\", async () => {\n  const { WidgetAnnotation } = await import(\"../../src/core/annotation.js\");\n  const { Dict, Name } = await import(\"../../src/core/primitives.js\");\n  const { XRefMock } = await import(\"./test_utils.js\");\n  const xref = new XRefMock();\n  const dict = new Dict(xref);\n  dict.set(\"F\", 0);\n  dict.set(\"FT\", Name.get(\"Btn\"));\n  const annotationGlobals = { acroForm: new Dict(xref) };\n  const widget = new WidgetAnnotation({\n    dict,\n    xref,\n    annotationGlobals,\n    pageRef: null,\n    pageIndex: 0,\n    id: \"testAnnot\",\n    needAppearances: true,\n    collectFields: true,\n  });\n  const storageEntry = { noView: true, noPrint: false, value: widget.data.fieldValue, rotation: undefined };\n  const annotationStorage = new Map();\n  annotationStorage.set(widget.data.id, storageEntry);\n  const evaluator = { xref };\n  const task = { name: \"testTask\" };\n  const changes = await widget.save(evaluator, task, annotationStorage);\n  const savedData = changes && changes[0] && changes[0].data;\n  if (!savedData) {\n    throw new Error(\"No saved data returned\");\n  }\n  if (!savedData.includes(\"/F\")) {\n    throw new Error(\"Annotation flags were not properly updated in the saved data\");\n  }\n});\n",
    "i2_gpt-4o": "it(\"should correctly update annotation flags when saving with noViewnoPrint set\", async () => {\n  const { WidgetAnnotation } = await import(\"../../src/core/annotation.js\");\n  const { Dict, Name } = await import(\"../../src/core/primitives.js\");\n  const { XRefMock } = await import(\"./test_utils.js\");\n  const xref = new XRefMock();\n  const dict = new Dict(xref);\n  dict.set(\"F\", 0);\n  dict.set(\"FT\", Name.get(\"Btn\"));\n  const annotationGlobals = { acroForm: new Dict(xref) };\n  const widget = new WidgetAnnotation({\n    dict,\n    xref,\n    annotationGlobals,\n    pageRef: null,\n    pageIndex: 0,\n    id: \"testAnnot\",\n    needAppearances: true,\n    collectFields: true,\n  });\n  const storageEntry = { noView: true, noPrint: false, value: widget.data.fieldValue, rotation: undefined };\n  const annotationStorage = new Map();\n  annotationStorage.set(widget.data.id, storageEntry);\n  const evaluator = { xref };\n  const task = { name: \"testTask\" };\n  const changes = await widget.save(evaluator, task, annotationStorage);\n  const savedData = changes && changes[0] && changes[0].data;\n  if (!savedData) {\n    throw new Error(\"No saved data returned\");\n  }\n  if (!savedData.includes(\"/F\")) {\n    throw new Error(\"Annotation flags were not properly updated in the saved data\");\n  }\n});\n",
    "i2_llama-3.3-70b-versatile": "it(\"should correctly update annotation flags when saving with noViewnoPrint set\", async () => {\n  const { WidgetAnnotation } = await import(\"../../src/core/annotation.js\");\n  const { Dict, Name } = await import(\"../../src/core/primitives.js\");\n  const { XRefMock } = await import(\"./test_utils.js\");\n  const xref = new XRefMock();\n  const dict = new Dict(xref);\n  dict.set(\"F\", 0);\n  dict.set(\"FT\", Name.get(\"Btn\"));\n  const annotationGlobals = { acroForm: new Dict(xref) };\n  const widget = new WidgetAnnotation({\n    dict,\n    xref,\n    annotationGlobals,\n    pageRef: null,\n    pageIndex: 0,\n    id: \"testAnnot\",\n    needAppearances: true,\n    collectFields: true,\n  });\n  const storageEntry = { noView: true, noPrint: false, value: widget.data.fieldValue, rotation: undefined };\n  const annotationStorage = new Map();\n  annotationStorage.set(widget.data.id, storageEntry);\n  const evaluator = { xref };\n  const task = { name: \"testTask\" };\n  const changes = await widget.save(evaluator, task, annotationStorage);\n  const savedData = changes && changes[0] && changes[0].data;\n  if (!savedData) {\n    throw new Error(\"No saved data returned\");\n  }\n  if (!savedData.includes(\"/F\")) {\n    throw new Error(\"Annotation flags were not properly updated in the saved data\");\n  }\n});\n",
    "i3_deepseek-r1-distill-llama-70b": "it(\"should correctly update annotation flags when saving with noViewnoPrint set\", async () => {\n  const { WidgetAnnotation } = await import(\"../../src/core/annotation.js\");\n  const { Dict, Name } = await import(\"../../src/core/primitives.js\");\n  const { XRefMock } = await import(\"./test_utils.js\");\n  const xref = new XRefMock();\n  const dict = new Dict(xref);\n  dict.set(\"F\", 0);\n  dict.set(\"FT\", Name.get(\"Btn\"));\n  const annotationGlobals = { acroForm: new Dict(xref) };\n  const widget = new WidgetAnnotation({\n    dict,\n    xref,\n    annotationGlobals,\n    pageRef: null,\n    pageIndex: 0,\n    id: \"testAnnot\",\n    needAppearances: true,\n    collectFields: true,\n  });\n  const storageEntry = { noView: true, noPrint: false, value: widget.data.fieldValue, rotation: undefined };\n  const annotationStorage = new Map();\n  annotationStorage.set(widget.data.id, storageEntry);\n  const evaluator = { xref };\n  const task = { name: \"testTask\" };\n  const changes = await widget.save(evaluator, task, annotationStorage);\n  const savedData = changes && changes[0] && changes[0].data;\n  if (!savedData) {\n    throw new Error(\"No saved data returned\");\n  }\n  if (!savedData.includes(\"/F\")) {\n    throw new Error(\"Annotation flags were not properly updated in the saved data\");\n  }\n});\n",
    "i3_gpt-4o": "it(\"should correctly update annotation flags when saving with noViewnoPrint set\", async () => {\n  const { WidgetAnnotation } = await import(\"../../src/core/annotation.js\");\n  const { Dict, Name } = await import(\"../../src/core/primitives.js\");\n  const { XRefMock } = await import(\"./test_utils.js\");\n  const xref = new XRefMock();\n  const dict = new Dict(xref);\n  dict.set(\"F\", 0);\n  dict.set(\"FT\", Name.get(\"Btn\"));\n  const annotationGlobals = { acroForm: new Dict(xref) };\n  const widget = new WidgetAnnotation({\n    dict,\n    xref,\n    annotationGlobals,\n    pageRef: null,\n    pageIndex: 0,\n    id: \"testAnnot\",\n    needAppearances: true,\n    collectFields: true,\n  });\n  const storageEntry = { noView: true, noPrint: false, value: widget.data.fieldValue, rotation: undefined };\n  const annotationStorage = new Map();\n  annotationStorage.set(widget.data.id, storageEntry);\n  const evaluator = { xref };\n  const task = { name: \"testTask\" };\n  const changes = await widget.save(evaluator, task, annotationStorage);\n  const savedData = changes && changes[0] && changes[0].data;\n  if (!savedData) {\n    throw new Error(\"No saved data returned\");\n  }\n  if (!savedData.includes(\"/F\")) {\n    throw new Error(\"Annotation flags were not properly updated in the saved data\");\n  }\n});\n",
    "i3_llama-3.3-70b-versatile": "it(\"should correctly update annotation flags when saving with noViewnoPrint set\", async () => {\n  const { WidgetAnnotation } = await import(\"../../src/core/annotation.js\");\n  const { Dict, Name } = await import(\"../../src/core/primitives.js\");\n  const { XRefMock } = await import(\"./test_utils.js\");\n  const xref = new XRefMock();\n  const dict = new Dict(xref);\n  dict.set(\"F\", 0);\n  dict.set(\"FT\", Name.get(\"Btn\"));\n  const annotationGlobals = { acroForm: new Dict(xref) };\n  const widget = new WidgetAnnotation({\n    dict,\n    xref,\n    annotationGlobals,\n    pageRef: null,\n    pageIndex: 0,\n    id: \"testAnnot\",\n    needAppearances: true,\n    collectFields: true,\n  });\n  const storageEntry = { noView: true, noPrint: false, value: widget.data.fieldValue, rotation: undefined };\n  const annotationStorage = new Map();\n  annotationStorage.set(widget.data.id, storageEntry);\n  const evaluator = { xref };\n  const task = { name: \"testTask\" };\n  const changes = await widget.save(evaluator, task, annotationStorage);\n  const savedData = changes && changes[0] && changes[0].data;\n  if (!savedData) {\n    throw new Error(\"No saved data returned\");\n  }\n  if (!savedData.includes(\"/F\")) {\n    throw new Error(\"Annotation flags were not properly updated in the saved data\");\n  }\n});\n",
    "i4_deepseek-r1-distill-llama-70b": "it(\"should correctly update annotation flags when saving with noViewnoPrint set\", async () => {\n  const { WidgetAnnotation } = await import(\"../../src/core/annotation.js\");\n  const { Dict, Name } = await import(\"../../src/core/primitives.js\");\n  const { XRefMock } = await import(\"./test_utils.js\");\n  const xref = new XRefMock();\n  const dict = new Dict(xref);\n  dict.set(\"F\", 0);\n  dict.set(\"FT\", Name.get(\"Btn\"));\n  const annotationGlobals = { acroForm: new Dict(xref) };\n  const widget = new WidgetAnnotation({\n    dict,\n    xref,\n    annotationGlobals,\n    pageRef: null,\n    pageIndex: 0,\n    id: \"testAnnot\",\n    needAppearances: true,\n    collectFields: true,\n  });\n  const storageEntry = { noView: true, noPrint: false, value: widget.data.fieldValue, rotation: undefined };\n  const annotationStorage = new Map();\n  annotationStorage.set(widget.data.id, storageEntry);\n  const evaluator = { xref };\n  const task = { name: \"testTask\" };\n  const changes = await widget.save(evaluator, task, annotationStorage);\n  const savedData = changes && changes[0] && changes[0].data;\n  if (!savedData) {\n    throw new Error(\"No saved data returned\");\n  }\n  if (!savedData.includes(\"/F\")) {\n    throw new Error(\"Annotation flags were not properly updated in the saved data\");\n  }\n});\n",
    "i4_gpt-4o": "it(\"should correctly update annotation flags when saving with noViewnoPrint set\", async () => {\n  const { WidgetAnnotation } = await import(\"../../src/core/annotation.js\");\n  const { Dict, Name } = await import(\"../../src/core/primitives.js\");\n  const { XRefMock } = await import(\"./test_utils.js\");\n  const xref = new XRefMock();\n  const dict = new Dict(xref);\n  dict.set(\"F\", 0);\n  dict.set(\"FT\", Name.get(\"Btn\"));\n  const annotationGlobals = { acroForm: new Dict(xref) };\n  const widget = new WidgetAnnotation({\n    dict,\n    xref,\n    annotationGlobals,\n    pageRef: null,\n    pageIndex: 0,\n    id: \"testAnnot\",\n    needAppearances: true,\n    collectFields: true,\n  });\n  const storageEntry = { noView: true, noPrint: false, value: widget.data.fieldValue, rotation: undefined };\n  const annotationStorage = new Map();\n  annotationStorage.set(widget.data.id, storageEntry);\n  const evaluator = { xref };\n  const task = { name: \"testTask\" };\n  const changes = await widget.save(evaluator, task, annotationStorage);\n  const savedData = changes && changes[0] && changes[0].data;\n  if (!savedData) {\n    throw new Error(\"No saved data returned\");\n  }\n  if (!savedData.includes(\"/F\")) {\n    throw new Error(\"Annotation flags were not properly updated in the saved data\");\n  }\n});\n",
    "i4_llama-3.3-70b-versatile": "it(\"should correctly update annotation flags when saving with noViewnoPrint set\", async () => {\n  const { WidgetAnnotation } = await import(\"../../src/core/annotation.js\");\n  const { Dict, Name } = await import(\"../../src/core/primitives.js\");\n  const { XRefMock } = await import(\"./test_utils.js\");\n  const xref = new XRefMock();\n  const dict = new Dict(xref);\n  dict.set(\"F\", 0);\n  dict.set(\"FT\", Name.get(\"Btn\"));\n  const annotationGlobals = { acroForm: new Dict(xref) };\n  const widget = new WidgetAnnotation({\n    dict,\n    xref,\n    annotationGlobals,\n    pageRef: null,\n    pageIndex: 0,\n    id: \"testAnnot\",\n    needAppearances: true,\n    collectFields: true,\n  });\n  const storageEntry = { noView: true, noPrint: false, value: widget.data.fieldValue, rotation: undefined };\n  const annotationStorage = new Map();\n  annotationStorage.set(widget.data.id, storageEntry);\n  const evaluator = { xref };\n  const task = { name: \"testTask\" };\n  const changes = await widget.save(evaluator, task, annotationStorage);\n  const savedData = changes && changes[0] && changes[0].data;\n  if (!savedData) {\n    throw new Error(\"No saved data returned\");\n  }\n  if (!savedData.includes(\"/F\")) {\n    throw new Error(\"Annotation flags were not properly updated in the saved data\");\n  }\n});\n",
    "i5_deepseek-r1-distill-llama-70b": "it(\"should correctly update annotation flags when saving with noViewnoPrint set\", async () => {\n  const { WidgetAnnotation } = await import(\"../../src/core/annotation.js\");\n  const { Dict, Name } = await import(\"../../src/core/primitives.js\");\n  const { XRefMock } = await import(\"./test_utils.js\");\n  const xref = new XRefMock();\n  const dict = new Dict(xref);\n  dict.set(\"F\", 0);\n  dict.set(\"FT\", Name.get(\"Btn\"));\n  const annotationGlobals = { acroForm: new Dict(xref) };\n  const widget = new WidgetAnnotation({\n    dict,\n    xref,\n    annotationGlobals,\n    pageRef: null,\n    pageIndex: 0,\n    id: \"testAnnot\",\n    needAppearances: true,\n    collectFields: true,\n  });\n  const storageEntry = { noView: true, noPrint: false, value: widget.data.fieldValue, rotation: undefined };\n  const annotationStorage = new Map();\n  annotationStorage.set(widget.data.id, storageEntry);\n  const evaluator = { xref };\n  const task = { name: \"testTask\" };\n  const changes = await widget.save(evaluator, task, annotationStorage);\n  const savedData = changes && changes[0] && changes[0].data;\n  if (!savedData) {\n    throw new Error(\"No saved data returned\");\n  }\n  if (!savedData.includes(\"/F\")) {\n    throw new Error(\"Annotation flags were not properly updated in the saved data\");\n  }\n});\n",
    "i5_gpt-4o": "it(\"should correctly update annotation flags when saving with noViewnoPrint set\", async () => {\n  const { WidgetAnnotation } = await import(\"../../src/core/annotation.js\");\n  const { Dict, Name } = await import(\"../../src/core/primitives.js\");\n  const { XRefMock } = await import(\"./test_utils.js\");\n  const xref = new XRefMock();\n  const dict = new Dict(xref);\n  dict.set(\"F\", 0);\n  dict.set(\"FT\", Name.get(\"Btn\"));\n  const annotationGlobals = { acroForm: new Dict(xref) };\n  const widget = new WidgetAnnotation({\n    dict,\n    xref,\n    annotationGlobals,\n    pageRef: null,\n    pageIndex: 0,\n    id: \"testAnnot\",\n    needAppearances: true,\n    collectFields: true,\n  });\n  const storageEntry = { noView: true, noPrint: false, value: widget.data.fieldValue, rotation: undefined };\n  const annotationStorage = new Map();\n  annotationStorage.set(widget.data.id, storageEntry);\n  const evaluator = { xref };\n  const task = { name: \"testTask\" };\n  const changes = await widget.save(evaluator, task, annotationStorage);\n  const savedData = changes && changes[0] && changes[0].data;\n  if (!savedData) {\n    throw new Error(\"No saved data returned\");\n  }\n  if (!savedData.includes(\"/F\")) {\n    throw new Error(\"Annotation flags were not properly updated in the saved data\");\n  }\n});\n",
    "i5_llama-3.3-70b-versatile": "it(\"should correctly update annotation flags when saving with noViewnoPrint set\", async () => {\n  const { WidgetAnnotation } = await import(\"../../src/core/annotation.js\");\n  const { Dict, Name } = await import(\"../../src/core/primitives.js\");\n  const { XRefMock } = await import(\"./test_utils.js\");\n  const xref = new XRefMock();\n  const dict = new Dict(xref);\n  dict.set(\"F\", 0);\n  dict.set(\"FT\", Name.get(\"Btn\"));\n  const annotationGlobals = { acroForm: new Dict(xref) };\n  const widget = new WidgetAnnotation({\n    dict,\n    xref,\n    annotationGlobals,\n    pageRef: null,\n    pageIndex: 0,\n    id: \"testAnnot\",\n    needAppearances: true,\n    collectFields: true,\n  });\n  const storageEntry = { noView: true, noPrint: false, value: widget.data.fieldValue, rotation: undefined };\n  const annotationStorage = new Map();\n  annotationStorage.set(widget.data.id, storageEntry);\n  const evaluator = { xref };\n  const task = { name: \"testTask\" };\n  const changes = await widget.save(evaluator, task, annotationStorage);\n  const savedData = changes && changes[0] && changes[0].data;\n  if (!savedData) {\n    throw new Error(\"No saved data returned\");\n  }\n  if (!savedData.includes(\"/F\")) {\n    throw new Error(\"Annotation flags were not properly updated in the saved data\");\n  }\n});\n"
  },
  "18844": {
    "i1_deepseek-r1-distill-llama-70b": "it(\"should use correct font family on Windows and Firefox\", async () => {\n  const { TextLayer } = await import(\"../../src/display/text_layer.js\");\n  const { FeatureTest } = await import(\"../../src/shared/util.js\");\n\n  // Mock the platform detection to simulate Windows and Firefox\n  const mockPlatform = {\n    isWindows: true,\n    isFirefox: true,\n  };\n  jest.spyOn(FeatureTest, \"platform\", \"get\").mockReturnValue(mockPlatform);\n\n  // Create a test text layer\n  const textLayer = new TextLayer({\n    textContentSource: new ReadableStream({\n      start(controller) {\n        controller.enqueue(\"Test text\");\n        controller.close();\n      },\n    }),\n    container: document.createElement(\"div\"),\n    viewport: {\n      scale: 1,\n      rawDims: { pageWidth: 100, pageHeight: 100 },\n      rotation: 0,\n    },\n  });\n\n  // Check the font family for sans-serif and monospace\n  const fontFamilyMap = await TextLayer.fontFamilyMap;\n  expect(fontFamilyMap.get(\"sans-serif\")).toContain(\"Calibri\");\n  expect(fontFamilyMap.get(\"monospace\")).toContain(\"Lucida Console\");\n});",
    "i1_gpt-4o": "it(\"should correctly map font families on Windows with Firefox\", async () => {\n  const { FeatureTest } = await import(\"../../src/shared/util.js\");\n  const { TextLayer } = await import(\"../../src/display/text_layer.js\");\n\n  // Mock the platform to simulate Windows with Firefox\n  const originalPlatform = FeatureTest.platform;\n  FeatureTest.platform = {\n    isWindows: true,\n    isFirefox: true,\n  };\n\n  const fontFamilyMap = TextLayer.fontFamilyMap;\n  const expectedSansSerif = \"Calibri, sans-serif\";\n  const expectedMonospace = \"Lucida Console, monospace\";\n\n  // Check if the font families are correctly mapped\n  expect(fontFamilyMap.get(\"sans-serif\")).toBe(expectedSansSerif);\n  expect(fontFamilyMap.get(\"monospace\")).toBe(expectedMonospace);\n\n  // Restore the original platform\n  FeatureTest.platform = originalPlatform;\n});",
    "i1_llama-3.3-70b-versatile": "it(\"should render text layer correctly on Windows with Firefox\", async () => {\n  const { getDocument } = await import(\"../../src/display/api.js\");\n  const { TextLayer } = await import(\"../../src/display/text_layer.js\");\n  const { FeatureTest } = await import(\"../../src/shared/util.js\");\n\n  const originalPlatform = FeatureTest.platform;\n  FeatureTest.platform = {\n    isWindows: true,\n    isFirefox: true,\n  };\n\n  const textContentSource = {\n    items: [\n      {\n        str: \"Hello World\",\n        fontName: \"sans-serif\",\n        fontSize: 12,\n        transform: [1, 0, 0, 1, 0, 0],\n      },\n    ],\n  };\n\n  const container = document.createElement(\"div\");\n  const viewport = {\n    scale: 1,\n    rotation: 0,\n    rawDims: {\n      pageWidth: 100,\n      pageHeight: 100,\n      pageX: 0,\n      pageY: 0,\n    },\n  };\n\n  const textLayer = new TextLayer({\n    textContentSource,\n    container,\n    viewport,\n  });\n\n  await textLayer.render();\n\n  const textDiv = container.querySelector(\"span\");\n  const fontFamily = textDiv.style.fontFamily;\n\n  expect(fontFamily).toBe(\"Calibri, sans-serif\");\n\n  FeatureTest.platform = originalPlatform;\n});",
    "i2_deepseek-r1-distill-llama-70b": "it(\"should use Calibri and Lucida Console on Windows Firefox\", async () => {\n  const { TextLayer } = await import(\"../../src/display/text_layer.js\");\n  const { FeatureTest } = await import(\"../../shared/util.js\");\n\n  // Mock platform detection to simulate Windows and Firefox\n  jest.spyOn(FeatureTest, \"platform\").mockReturnValue({\n    isWindows: true,\n    isFirefox: true,\n  });\n\n  // Create a test text layer with sample content\n  const textContent = { items: [{ str: \"Test\", fontName: \"sans-serif\" }] };\n  const textLayer = new TextLayer({\n    textContentSource: textContent,\n    container: document.createElement(\"div\"),\n    viewport: { scale: 1, rotation: 0, rawDims: {} },\n  });\n\n  // Check if the expected fonts are being used\n  const textDiv = textLayer.#textDivs[0];\n  const expectedSansSerif = \"Calibri, sans-serif\";\n  const expectedMonospace = \"Lucida Console, monospace\";\n\n  expect(textDiv.style.fontFamily).toContain(expectedSansSerif);\n});",
    "i2_gpt-4o": "it(\"should use Calibri and Lucida Console on Windows with Firefox\", async () => {\n  const { TextLayer } = await import(\"../../src/display/text_layer.js\");\n  const { FeatureTest } = await import(\"../../src/shared/util.js\");\n\n  // Mock platform detection\n  FeatureTest.platform = {\n    isWindows: true,\n    isFirefox: true,\n  };\n\n  const fontFamilyMap = TextLayer.fontFamilyMap;\n  const expectedSansSerif = \"Calibri, sans-serif\";\n  const expectedMonospace = \"Lucida Console, monospace\";\n\n  const actualSansSerif = fontFamilyMap.get(\"sans-serif\");\n  const actualMonospace = fontFamilyMap.get(\"monospace\");\n\n  expect(actualSansSerif).toBe(expectedSansSerif);\n  expect(actualMonospace).toBe(expectedMonospace);\n});",
    "i2_llama-3.3-70b-versatile": "it(\"should render text layer with correct font family on Windows with Firefox\", async () => {\n  const { TextLayer, FeatureTest } = await import(\"../../src/display/text_layer.js\");\n  const { Util } = await import(\"../../src/shared/util.js\");\n  const { PageViewport } = await import(\"../../src/display/display_utils.js\");\n\n  const viewport = new PageViewport({ scale: 1, rotation: 0, width: 100, height: 100 });\n  const textContentSource = { items: [{ str: \"Hello World\", fontName: \"sans-serif\" }] };\n  const container = document.createElement(\"div\");\n  const textLayer = new TextLayer({ textContentSource, container, viewport });\n\n  const isWindows = navigator.platform.includes(\"Win\");\n  const isFirefox = navigator.userAgent.includes(\"Firefox\");\n  const expectedFontFamily = isWindows && isFirefox ? \"Calibri, sans-serif\" : \"sans-serif\";\n\n  const textDiv = container.querySelector(\"span\");\n  const actualFontFamily = textDiv.style.fontFamily;\n\n  expect(actualFontFamily).toBe(expectedFontFamily);\n});",
    "i3_deepseek-r1-distill-llama-70b": "it(\"should match text layer with canvas on Windows in Firefox\", async () => {\n  const { getDocument } = await import(\"../../src/display/api.js\");\n  const { FeatureTest } = await import(\"../../src/shared/util.js\");\n  const { TextLayer } = await import(\"../../src/display/text_layer.js\");\n\n  // Mock Windows and Firefox platform\n  const originalPlatform = FeatureTest.platform;\n  FeatureTest.platform = shadow(FeatureTest, \"platform\", {\n    isWindows: true,\n    isFirefox: true,\n  });\n\n  // Create a test PDF with text\n  const pdfData = new Uint8Array([\n    0x25, 0x50, 0x44, 0x46, 0x2d, 0x31, 0x2e, 0x30, 0x0a, 0x25, 0xe2, 0xe3, 0xcf, 0xd0, 0x0a, 0x31, 0x30, 0x30, 0x30, 0x0a,\n    0x25, 0x50, 0x44, 0x46, 0x2d, 0x49, 0x6e, 0x63, 0x6f, 0x6d, 0x70, 0x6c, 0x69, 0x61, 0x6e, 0x74, 0x0a, 0x31, 0x30, 0x30, 0x30, 0x0a,\n    0x25, 0x53, 0x74, 0x6f, 0x72, 0x65, 0x0a, 0x25, 0x55, 0x6e, 0x64, 0x65, 0x72, 0x2f, 0x46, 0x6f, 0x6e, 0x74, 0x0a,\n    0x25, 0x45, 0x6e, 0x63, 0x6f, 0x64, 0x69, 0x6e, 0x67, 0x2d, 0x49, 0x6e, 0x66, 0x6f, 0x0a, 0x31, 0x30, 0x30, 0x30, 0x0a,\n    0x25, 0x50, 0x44, 0x46, 0x2d, 0x50, 0x61, 0x67, 0x65, 0x73, 0x0a, 0x31, 0x30, 0x30, 0x30, 0x0a,\n    0x25, 0x4f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x0a, 0x3c, 0x3c, 0x2f, 0x50, 0x44, 0x46, 0x2d, 0x31, 0x2e, 0x30, 0x3e,\n    0x0a\n  ]);\n\n  const pdf = await getDocument({\n    data: pdfData,\n    ...buildGetDocumentParams(pdfData)\n  });\n  const page = await pdf.getPage(1);\n  const viewport = page.getViewport({ scale: 1 });\n  const textLayer = new TextLayer({\n    textContentSource: page.getTextContent(),\n    container: document.createElement(\"div\"),\n    viewport,\n  });\n\n  await textLayer.render();\n\n  const textItems = await page.getTextContent();\n  const canvas = document.createElement(\"canvas\");\n  const ctx = canvas.getContext(\"2d\");\n  ctx.font = \"14px Calibri, sans-serif\";\n  ctx.fillStyle = \"black\";\n\n  for (const item of textItems.items) {\n    if (item.str) {\n      const { x, y } = item.transform;\n      const text = item.str;\n      const textDiv = textLayer.textDivs.find(div => div.textContent === text);\n      const divRect = textDiv.getBoundingClientRect();\n      const canvasRect = ctx.measureText(text).width;\n\n      expect(divRect.left).toBeCloseTo(x, 1);\n      expect(divRect.top).toBeCloseTo(y, 1);\n      expect(divRect.width).toBeCloseTo(canvasRect.width, 1);\n    }\n  }\n\n  FeatureTest.platform = originalPlatform;\n});",
    "i3_gpt-4o": "it(\"should correctly map font families on Windows with Firefox\", async () => {\n  const { FeatureTest } = await import(\"../../src/shared/util.js\");\n  const { TextLayer } = await import(\"../../src/display/text_layer.js\");\n\n  // Mock the platform to simulate Windows with Firefox\n  FeatureTest.platform = { isWindows: true, isFirefox: true };\n\n  const expectedFontFamilyMap = new Map([\n    [\"sans-serif\", \"Calibri, sans-serif\"],\n    [\"monospace\", \"Lucida Console, monospace\"],\n  ]);\n\n  const actualFontFamilyMap = TextLayer.fontFamilyMap;\n\n  expect(actualFontFamilyMap).toEqual(expectedFontFamilyMap);\n});",
    "i3_llama-3.3-70b-versatile": "it(\"should render text layer with correct font family on Windows and Firefox\", async () => {\n  const { getDocument } = await import(\"../../src/display/api.js\");\n  const { TextLayer } = await import(\"../../src/display/text_layer.js\");\n  const { FeatureTest } = await import(\"../../src/shared/util.js\");\n\n  const originalIsWindows = FeatureTest.platform.isWindows;\n  const originalIsFirefox = FeatureTest.platform.isFirefox;\n  FeatureTest.platform.isWindows = true;\n  FeatureTest.platform.isFirefox = true;\n\n  const doc = await getDocument({ url: \"./test.pdf\" });\n  const page = await doc.getPage(1);\n  const textContent = await page.getTextContent();\n  const textLayer = new TextLayer({\n    textContentSource: textContent,\n    container: document.createElement(\"div\"),\n    viewport: page.getViewport({ scale: 1 }),\n  });\n\n  await textLayer.render();\n\n  const textDivs = textLayer.textDivs;\n  const fontFamily = textDivs[0].style.fontFamily;\n  const expectedFontFamily = \"Calibri, sans-serif\";\n\n  expect(fontFamily).toBe(expectedFontFamily);\n\n  FeatureTest.platform.isWindows = originalIsWindows;\n  FeatureTest.platform.isFirefox = originalIsFirefox;\n});",
    "i4_deepseek-r1-distill-llama-70b": "it(\"should adjust font family for Windows Firefox\", async () => {\n  const { TextLayer } = await import(\"../../src/display/text_layer.js\");\n  const { FeatureTest } = await import(\"../../shared/util.js\");\n\n  // Mock platform as Windows + Firefox\n  const originalPlatform = FeatureTest.platform;\n  FeatureTest.platform = () => ({\n    isWindows: true,\n    isFirefox: true,\n  });\n\n  const fontFamilyMap = TextLayer.fontFamilyMap;\n\n  // Expected font family strings\n  const expectedSansSerif = \"Calibri, sans-serif\";\n  const expectedMonospace = \"Lucida Console, monospace\";\n\n  // Actual font family strings\n  const actualSansSerif = fontFamilyMap.get(\"sans-serif\");\n  const actualMonospace = fontFamilyMap.get(\"monospace\");\n\n  // Cleanup\n  FeatureTest.platform = originalPlatform;\n\n  // Assertions\n  expect(actualSansSerif).toBe(expectedSansSerif);\n  expect(actualMonospace).toBe(expectedMonospace);\n});",
    "i4_gpt-4o": "it(\"should correctly map font families on Windows with Firefox\", async () => {\n  const { TextLayer } = await import(\"../../src/display/text_layer.js\");\n  const { FeatureTest } = await import(\"../../src/shared/util.js\");\n\n  // Mock platform detection\n  FeatureTest.platform = { isWindows: true, isFirefox: true };\n\n  const expectedFontFamilyMap = new Map([\n    [\"sans-serif\", \"Calibri, sans-serif\"],\n    [\"monospace\", \"Lucida Console, monospace\"],\n  ]);\n\n  const actualFontFamilyMap = TextLayer.fontFamilyMap;\n\n  for (const [key, value] of expectedFontFamilyMap) {\n    if (actualFontFamilyMap.get(key) !== value) {\n      throw new Error(`Font family mapping for ${key} is incorrect.`);\n    }\n  }\n});",
    "i4_llama-3.3-70b-versatile": "it(\"should render text layer correctly on Windows with Firefox\", async () => {\n  const { TextLayer } = await import(\"../../src/display/text_layer.js\");\n  const { setLayerDimensions } = await import(\"../../src/display/display_utils.js\");\n  const { FeatureTest } = await import(\"../../src/shared/util.js\");\n\n  const container = document.createElement(\"div\");\n  const viewport = { scale: 1, rotation: 0, rawDims: { pageWidth: 100, pageHeight: 100, pageX: 0, pageY: 0 } };\n  const textContentSource = { items: [{ str: \"Hello World\", fontName: \"sans-serif\" }] };\n\n  const originalPlatform = FeatureTest.platform;\n  FeatureTest.platform = { isWindows: true, isFirefox: true };\n\n  const textLayer = new TextLayer({ textContentSource, container, viewport });\n  await textLayer.render();\n\n  const textDivs = textLayer.textDivs;\n  const fontFamily = textDivs[0].style.fontFamily;\n\n  expect(fontFamily).toBe(\"Calibri, sans-serif\");\n\n  FeatureTest.platform = originalPlatform;\n});",
    "i5_deepseek-r1-distill-llama-70b": "it(\"should adjust font family for Windows Firefox\", async () => {\n  const { TextLayer } = await import(\"../../src/display/text_layer.js\");\n  const { FeatureTest } = await import(\"../../shared/util.js\");\n\n  // Mock platform and browser detection\n  const originalPlatform = FeatureTest.platform;\n  FeatureTest.platform = () => ({\n    isWindows: true,\n    isFirefox: true,\n  });\n\n  // Test sans-serif font family\n  {\n    const textLayer = new TextLayer();\n    const fontFamily = \"sans-serif\";\n    const expectedFontFamily = \"Calibri, sans-serif\";\n    const actualFontFamily = TextLayer.fontFamilyMap.get(fontFamily) || fontFamily;\n    expect(actualFontFamily).toBe(expectedFontFamily);\n  }\n\n  // Test monospace font family\n  {\n    const textLayer = new TextLayer();\n    const fontFamily = \"monospace\";\n    const expectedFontFamily = \"Lucida Console, monospace\";\n    const actualFontFamily = TextLayer.fontFamilyMap.get(fontFamily) || fontFamily;\n    expect(actualFontFamily).toBe(expectedFontFamily);\n  }\n\n  // Restore original platform detection\n  FeatureTest.platform = originalPlatform;\n});",
    "i5_gpt-4o": "it(\"should match text layer and canvas font family on Windows with Firefox\", async () => {\n  const { TextLayer } = await import(\"../../src/display/text_layer.js\");\n  const { FeatureTest } = await import(\"../../src/shared/util.js\");\n\n  // Simulate Windows and Firefox environment\n  FeatureTest.platform = { isWindows: true, isFirefox: true };\n\n  const textLayer = new TextLayer();\n  const style = { fontFamily: \"sans-serif\" };\n  const expectedFontFamily = \"Calibri, sans-serif\";\n\n  // Generate actual font family using the patched method\n  let fontFamily = (textLayer.#fontInspectorEnabled && style.fontSubstitution) || style.fontFamily;\n  fontFamily = TextLayer.fontFamilyMap.get(fontFamily) || fontFamily;\n\n  // Compare expected with actual\n  expect(fontFamily).toBe(expectedFontFamily);\n});",
    "i5_llama-3.3-70b-versatile": "it(\"should render text layer with correct font family on Windows and Firefox\", async () => {\n  const { TextLayer, PageViewport, setLayerDimensions } = await import(\"../../src/display/text_layer.js\");\n  const { PDFDocument, Page } = await import(\"../../src/core/document.js\");\n  const { Util } = await import(\"../../src/shared/util.js\");\n  const { FeatureTest } = await import(\"../../src/shared/util.js\");\n\n  const pdfDocument = await PDFDocument.load(await Util.fetch(\"path_to_test_pdf.pdf\"));\n  const pdfPage = pdfDocument.getPage(1);\n  const viewport = pdfPage.getViewport({ scale: 1 });\n  const textLayer = new TextLayer({\n    textContent: await pdfPage.getTextContent(),\n    viewport: viewport,\n    div: document.createElement(\"div\"),\n    eventBus: Util.createEventBus(),\n  });\n\n  const isWindows = FeatureTest.platform.isWindows;\n  const isFirefox = FeatureTest.platform.isFirefox;\n\n  const expectedFontFamily = isWindows && isFirefox ? \"Calibri, sans-serif\" : \"sans-serif\";\n  const actualFontFamily = TextLayer.fontFamilyMap.get(\"sans-serif\");\n\n  expect(actualFontFamily).toBe(expectedFontFamily);\n});"
  },
  "18853": {
    "i1_deepseek-r1-distill-llama-70b": "it(\"should restore extra line breaks when extracting text content from a text widget annotation\", async () => {\n  const { TextWidgetAnnotation } = await import(\"../../src/core/annotation.js\");\n  // Create a fake instance with only the needed properties.\n  const annotation = Object.create(TextWidgetAnnotation.prototype);\n  annotation.data = {\n    // The text extractor originally produced textContent without the extra blank line.\n    textContent: [\"Line1\", \"Line2\"],\n    // But the actual field value contains an extra blank line.\n    fieldValue: \"Line1\\n\\nLine2\",\n  };\n  // Call the new extractTextContent method.\n  await annotation.extractTextContent({}, {}, {});\n  // Now, after extraction, textContent should match fieldValue split by \"\\n\".\n  if (annotation.data.textContent.join(\"\\n\") !== annotation.data.fieldValue) {\n    throw new Error(\"Extra line breaks were not correctly restored.\");\n  }\n});",
    "i1_gpt-4o": "it(\"should restore extra line breaks when extracting text content from a text widget annotation\", async () => {\n  const { TextWidgetAnnotation } = await import(\"../../src/core/annotation.js\");\n  // Create a fake instance with only the needed properties.\n  const annotation = Object.create(TextWidgetAnnotation.prototype);\n  annotation.data = {\n    // The text extractor originally produced textContent without the extra blank line.\n    textContent: [\"Line1\", \"Line2\"],\n    // But the actual field value contains an extra blank line.\n    fieldValue: \"Line1\\n\\nLine2\",\n  };\n  // Call the new extractTextContent method.\n  await annotation.extractTextContent({}, {}, {});\n  // Now, after extraction, textContent should match fieldValue split by \"\\n\".\n  if (annotation.data.textContent.join(\"\\n\") !== annotation.data.fieldValue) {\n    throw new Error(\"Extra line breaks were not correctly restored.\");\n  }\n});",
    "i1_llama-3.3-70b-versatile": "it(\"should restore extra line breaks when extracting text content from a text widget annotation\", async () => {\n  const { TextWidgetAnnotation } = await import(\"../../src/core/annotation.js\");\n  // Create a fake instance with only the needed properties.\n  const annotation = Object.create(TextWidgetAnnotation.prototype);\n  annotation.data = {\n    // The text extractor originally produced textContent without the extra blank line.\n    textContent: [\"Line1\", \"Line2\"],\n    // But the actual field value contains an extra blank line.\n    fieldValue: \"Line1\\n\\nLine2\",\n  };\n  // Call the new extractTextContent method.\n  await annotation.extractTextContent({}, {}, {});\n  // Now, after extraction, textContent should match fieldValue split by \"\\n\".\n  if (annotation.data.textContent.join(\"\\n\") !== annotation.data.fieldValue) {\n    throw new Error(\"Extra line breaks were not correctly restored.\");\n  }\n});",
    "i1_MOCK": "it(\"should restore extra line breaks when extracting text content from a text widget annotation\", async () => {\n  const { TextWidgetAnnotation } = await import(\"../../src/core/annotation.js\");\n  // Create a fake instance with only the needed properties.\n  const annotation = Object.create(TextWidgetAnnotation.prototype);\n  annotation.data = {\n    // The text extractor originally produced textContent without the extra blank line.\n    textContent: [\"Line1\", \"Line2\"],\n    // But the actual field value contains an extra blank line.\n    fieldValue: \"Line1\\n\\nLine2\",\n  };\n  // Call the new extractTextContent method.\n  await annotation.extractTextContent({}, {}, {});\n  // Now, after extraction, textContent should match fieldValue split by \"\\n\".\n  if (annotation.data.textContent.join(\"\\n\") !== annotation.data.fieldValue) {\n    throw new Error(\"Extra line breaks were not correctly restored.\");\n  }\n});",
    "i2_deepseek-r1-distill-llama-70b": "it(\"should restore extra line breaks when extracting text content from a text widget annotation\", async () => {\n  const { TextWidgetAnnotation } = await import(\"../../src/core/annotation.js\");\n  // Create a fake instance with only the needed properties.\n  const annotation = Object.create(TextWidgetAnnotation.prototype);\n  annotation.data = {\n    // The text extractor originally produced textContent without the extra blank line.\n    textContent: [\"Line1\", \"Line2\"],\n    // But the actual field value contains an extra blank line.\n    fieldValue: \"Line1\\n\\nLine2\",\n  };\n  // Call the new extractTextContent method.\n  await annotation.extractTextContent({}, {}, {});\n  // Now, after extraction, textContent should match fieldValue split by \"\\n\".\n  if (annotation.data.textContent.join(\"\\n\") !== annotation.data.fieldValue) {\n    throw new Error(\"Extra line breaks were not correctly restored.\");\n  }\n});",
    "i2_gpt-4o": "it(\"should restore extra line breaks when extracting text content from a text widget annotation\", async () => {\n  const { TextWidgetAnnotation } = await import(\"../../src/core/annotation.js\");\n  // Create a fake instance with only the needed properties.\n  const annotation = Object.create(TextWidgetAnnotation.prototype);\n  annotation.data = {\n    // The text extractor originally produced textContent without the extra blank line.\n    textContent: [\"Line1\", \"Line2\"],\n    // But the actual field value contains an extra blank line.\n    fieldValue: \"Line1\\n\\nLine2\",\n  };\n  // Call the new extractTextContent method.\n  await annotation.extractTextContent({}, {}, {});\n  // Now, after extraction, textContent should match fieldValue split by \"\\n\".\n  if (annotation.data.textContent.join(\"\\n\") !== annotation.data.fieldValue) {\n    throw new Error(\"Extra line breaks were not correctly restored.\");\n  }\n});",
    "i2_llama-3.3-70b-versatile": "it(\"should restore extra line breaks when extracting text content from a text widget annotation\", async () => {\n  const { TextWidgetAnnotation } = await import(\"../../src/core/annotation.js\");\n  // Create a fake instance with only the needed properties.\n  const annotation = Object.create(TextWidgetAnnotation.prototype);\n  annotation.data = {\n    // The text extractor originally produced textContent without the extra blank line.\n    textContent: [\"Line1\", \"Line2\"],\n    // But the actual field value contains an extra blank line.\n    fieldValue: \"Line1\\n\\nLine2\",\n  };\n  // Call the new extractTextContent method.\n  await annotation.extractTextContent({}, {}, {});\n  // Now, after extraction, textContent should match fieldValue split by \"\\n\".\n  if (annotation.data.textContent.join(\"\\n\") !== annotation.data.fieldValue) {\n    throw new Error(\"Extra line breaks were not correctly restored.\");\n  }\n});",
    "i3_deepseek-r1-distill-llama-70b": "it(\"should restore extra line breaks when extracting text content from a text widget annotation\", async () => {\n  const { TextWidgetAnnotation } = await import(\"../../src/core/annotation.js\");\n  // Create a fake instance with only the needed properties.\n  const annotation = Object.create(TextWidgetAnnotation.prototype);\n  annotation.data = {\n    // The text extractor originally produced textContent without the extra blank line.\n    textContent: [\"Line1\", \"Line2\"],\n    // But the actual field value contains an extra blank line.\n    fieldValue: \"Line1\\n\\nLine2\",\n  };\n  // Call the new extractTextContent method.\n  await annotation.extractTextContent({}, {}, {});\n  // Now, after extraction, textContent should match fieldValue split by \"\\n\".\n  if (annotation.data.textContent.join(\"\\n\") !== annotation.data.fieldValue) {\n    throw new Error(\"Extra line breaks were not correctly restored.\");\n  }\n});",
    "i3_gpt-4o": "it(\"should restore extra line breaks when extracting text content from a text widget annotation\", async () => {\n  const { TextWidgetAnnotation } = await import(\"../../src/core/annotation.js\");\n  // Create a fake instance with only the needed properties.\n  const annotation = Object.create(TextWidgetAnnotation.prototype);\n  annotation.data = {\n    // The text extractor originally produced textContent without the extra blank line.\n    textContent: [\"Line1\", \"Line2\"],\n    // But the actual field value contains an extra blank line.\n    fieldValue: \"Line1\\n\\nLine2\",\n  };\n  // Call the new extractTextContent method.\n  await annotation.extractTextContent({}, {}, {});\n  // Now, after extraction, textContent should match fieldValue split by \"\\n\".\n  if (annotation.data.textContent.join(\"\\n\") !== annotation.data.fieldValue) {\n    throw new Error(\"Extra line breaks were not correctly restored.\");\n  }\n});",
    "i3_llama-3.3-70b-versatile": "it(\"should restore extra line breaks when extracting text content from a text widget annotation\", async () => {\n  const { TextWidgetAnnotation } = await import(\"../../src/core/annotation.js\");\n  // Create a fake instance with only the needed properties.\n  const annotation = Object.create(TextWidgetAnnotation.prototype);\n  annotation.data = {\n    // The text extractor originally produced textContent without the extra blank line.\n    textContent: [\"Line1\", \"Line2\"],\n    // But the actual field value contains an extra blank line.\n    fieldValue: \"Line1\\n\\nLine2\",\n  };\n  // Call the new extractTextContent method.\n  await annotation.extractTextContent({}, {}, {});\n  // Now, after extraction, textContent should match fieldValue split by \"\\n\".\n  if (annotation.data.textContent.join(\"\\n\") !== annotation.data.fieldValue) {\n    throw new Error(\"Extra line breaks were not correctly restored.\");\n  }\n});",
    "i4_deepseek-r1-distill-llama-70b": "it(\"should restore extra line breaks when extracting text content from a text widget annotation\", async () => {\n  const { TextWidgetAnnotation } = await import(\"../../src/core/annotation.js\");\n  // Create a fake instance with only the needed properties.\n  const annotation = Object.create(TextWidgetAnnotation.prototype);\n  annotation.data = {\n    // The text extractor originally produced textContent without the extra blank line.\n    textContent: [\"Line1\", \"Line2\"],\n    // But the actual field value contains an extra blank line.\n    fieldValue: \"Line1\\n\\nLine2\",\n  };\n  // Call the new extractTextContent method.\n  await annotation.extractTextContent({}, {}, {});\n  // Now, after extraction, textContent should match fieldValue split by \"\\n\".\n  if (annotation.data.textContent.join(\"\\n\") !== annotation.data.fieldValue) {\n    throw new Error(\"Extra line breaks were not correctly restored.\");\n  }\n});",
    "i4_gpt-4o": "it(\"should restore extra line breaks when extracting text content from a text widget annotation\", async () => {\n  const { TextWidgetAnnotation } = await import(\"../../src/core/annotation.js\");\n  // Create a fake instance with only the needed properties.\n  const annotation = Object.create(TextWidgetAnnotation.prototype);\n  annotation.data = {\n    // The text extractor originally produced textContent without the extra blank line.\n    textContent: [\"Line1\", \"Line2\"],\n    // But the actual field value contains an extra blank line.\n    fieldValue: \"Line1\\n\\nLine2\",\n  };\n  // Call the new extractTextContent method.\n  await annotation.extractTextContent({}, {}, {});\n  // Now, after extraction, textContent should match fieldValue split by \"\\n\".\n  if (annotation.data.textContent.join(\"\\n\") !== annotation.data.fieldValue) {\n    throw new Error(\"Extra line breaks were not correctly restored.\");\n  }\n});",
    "i4_llama-3.3-70b-versatile": "it(\"should restore extra line breaks when extracting text content from a text widget annotation\", async () => {\n  const { TextWidgetAnnotation } = await import(\"../../src/core/annotation.js\");\n  // Create a fake instance with only the needed properties.\n  const annotation = Object.create(TextWidgetAnnotation.prototype);\n  annotation.data = {\n    // The text extractor originally produced textContent without the extra blank line.\n    textContent: [\"Line1\", \"Line2\"],\n    // But the actual field value contains an extra blank line.\n    fieldValue: \"Line1\\n\\nLine2\",\n  };\n  // Call the new extractTextContent method.\n  await annotation.extractTextContent({}, {}, {});\n  // Now, after extraction, textContent should match fieldValue split by \"\\n\".\n  if (annotation.data.textContent.join(\"\\n\") !== annotation.data.fieldValue) {\n    throw new Error(\"Extra line breaks were not correctly restored.\");\n  }\n});",
    "i5_deepseek-r1-distill-llama-70b": "it(\"should restore extra line breaks when extracting text content from a text widget annotation\", async () => {\n  const { TextWidgetAnnotation } = await import(\"../../src/core/annotation.js\");\n  // Create a fake instance with only the needed properties.\n  const annotation = Object.create(TextWidgetAnnotation.prototype);\n  annotation.data = {\n    // The text extractor originally produced textContent without the extra blank line.\n    textContent: [\"Line1\", \"Line2\"],\n    // But the actual field value contains an extra blank line.\n    fieldValue: \"Line1\\n\\nLine2\",\n  };\n  // Call the new extractTextContent method.\n  await annotation.extractTextContent({}, {}, {});\n  // Now, after extraction, textContent should match fieldValue split by \"\\n\".\n  if (annotation.data.textContent.join(\"\\n\") !== annotation.data.fieldValue) {\n    throw new Error(\"Extra line breaks were not correctly restored.\");\n  }\n});",
    "i5_gpt-4o": "it(\"should restore extra line breaks when extracting text content from a text widget annotation\", async () => {\n  const { TextWidgetAnnotation } = await import(\"../../src/core/annotation.js\");\n  // Create a fake instance with only the needed properties.\n  const annotation = Object.create(TextWidgetAnnotation.prototype);\n  annotation.data = {\n    // The text extractor originally produced textContent without the extra blank line.\n    textContent: [\"Line1\", \"Line2\"],\n    // But the actual field value contains an extra blank line.\n    fieldValue: \"Line1\\n\\nLine2\",\n  };\n  // Call the new extractTextContent method.\n  await annotation.extractTextContent({}, {}, {});\n  // Now, after extraction, textContent should match fieldValue split by \"\\n\".\n  if (annotation.data.textContent.join(\"\\n\") !== annotation.data.fieldValue) {\n    throw new Error(\"Extra line breaks were not correctly restored.\");\n  }\n});",
    "i5_llama-3.3-70b-versatile": "it(\"should restore extra line breaks when extracting text content from a text widget annotation\", async () => {\n  const { TextWidgetAnnotation } = await import(\"../../src/core/annotation.js\");\n  // Create a fake instance with only the needed properties.\n  const annotation = Object.create(TextWidgetAnnotation.prototype);\n  annotation.data = {\n    // The text extractor originally produced textContent without the extra blank line.\n    textContent: [\"Line1\", \"Line2\"],\n    // But the actual field value contains an extra blank line.\n    fieldValue: \"Line1\\n\\nLine2\",\n  };\n  // Call the new extractTextContent method.\n  await annotation.extractTextContent({}, {}, {});\n  // Now, after extraction, textContent should match fieldValue split by \"\\n\".\n  if (annotation.data.textContent.join(\"\\n\") !== annotation.data.fieldValue) {\n    throw new Error(\"Extra line breaks were not correctly restored.\");\n  }\n});"
  },
  "18878": {
    "i1_deepseek-r1-distill-llama-70b": "it(\"should swallow extra data errors in asyncGetBytes\", async () => {\n  const { FlateStream } = await import(\"../../src/core/flate_stream.js\");\n  const { StringStream } = await import(\"../../src/core/stream.js\");\n  const bytes = new Uint8Array([0x78, 0x9C, 0x00, 0x00, 0x00]);\n  const dataStr = String.fromCharCode(...bytes);\n  const stream = new StringStream(dataStr);\n  stream.dict = {};\n  const flateStream = new FlateStream(stream);\n  const result = await flateStream.asyncGetBytes();\n  chai.expect(result).to.be.null;\n});",
    "i1_gpt-4o": "it(\"should swallow extra data errors in asyncGetBytes\", async () => {\n  const { FlateStream } = await import(\"../../src/core/flate_stream.js\");\n  const { StringStream } = await import(\"../../src/core/stream.js\");\n  const bytes = new Uint8Array([0x78, 0x9C, 0x00, 0x00, 0x00]);\n  const dataStr = String.fromCharCode(...bytes);\n  const stream = new StringStream(dataStr);\n  stream.dict = {};\n  const flateStream = new FlateStream(stream);\n  const result = await flateStream.asyncGetBytes();\n  chai.expect(result).to.be.null;\n});",
    "i1_llama-3.3-70b-versatile": "it(\"should swallow extra data errors in asyncGetBytes\", async () => {\n  const { FlateStream } = await import(\"../../src/core/flate_stream.js\");\n  const { StringStream } = await import(\"../../src/core/stream.js\");\n  const bytes = new Uint8Array([0x78, 0x9C, 0x00, 0x00, 0x00]);\n  const dataStr = String.fromCharCode(...bytes);\n  const stream = new StringStream(dataStr);\n  stream.dict = {};\n  const flateStream = new FlateStream(stream);\n  const result = await flateStream.asyncGetBytes();\n  chai.expect(result).to.be.null;\n});",
    "i1_MOCK": "it(\"should swallow extra data errors in asyncGetBytes\", async () => {\n  const { FlateStream } = await import(\"../../src/core/flate_stream.js\");\n  const { StringStream } = await import(\"../../src/core/stream.js\");\n  const bytes = new Uint8Array([0x78, 0x9C, 0x00, 0x00, 0x00]);\n  const dataStr = String.fromCharCode(...bytes);\n  const stream = new StringStream(dataStr);\n  stream.dict = {};\n  const flateStream = new FlateStream(stream);\n  const result = await flateStream.asyncGetBytes();\n  chai.expect(result).to.be.null;\n});",
    "i2_deepseek-r1-distill-llama-70b": "it(\"should swallow extra data errors in asyncGetBytes\", async () => {\n  const { FlateStream } = await import(\"../../src/core/flate_stream.js\");\n  const { StringStream } = await import(\"../../src/core/stream.js\");\n  const bytes = new Uint8Array([0x78, 0x9C, 0x00, 0x00, 0x00]);\n  const dataStr = String.fromCharCode(...bytes);\n  const stream = new StringStream(dataStr);\n  stream.dict = {};\n  const flateStream = new FlateStream(stream);\n  const result = await flateStream.asyncGetBytes();\n  chai.expect(result).to.be.null;\n});",
    "i2_gpt-4o": "it(\"should swallow extra data errors in asyncGetBytes\", async () => {\n  const { FlateStream } = await import(\"../../src/core/flate_stream.js\");\n  const { StringStream } = await import(\"../../src/core/stream.js\");\n  const bytes = new Uint8Array([0x78, 0x9C, 0x00, 0x00, 0x00]);\n  const dataStr = String.fromCharCode(...bytes);\n  const stream = new StringStream(dataStr);\n  stream.dict = {};\n  const flateStream = new FlateStream(stream);\n  const result = await flateStream.asyncGetBytes();\n  chai.expect(result).to.be.null;\n});",
    "i2_llama-3.3-70b-versatile": "it(\"should swallow extra data errors in asyncGetBytes\", async () => {\n  const { FlateStream } = await import(\"../../src/core/flate_stream.js\");\n  const { StringStream } = await import(\"../../src/core/stream.js\");\n  const bytes = new Uint8Array([0x78, 0x9C, 0x00, 0x00, 0x00]);\n  const dataStr = String.fromCharCode(...bytes);\n  const stream = new StringStream(dataStr);\n  stream.dict = {};\n  const flateStream = new FlateStream(stream);\n  const result = await flateStream.asyncGetBytes();\n  chai.expect(result).to.be.null;\n});",
    "i3_deepseek-r1-distill-llama-70b": "it(\"should swallow extra data errors in asyncGetBytes\", async () => {\n  const { FlateStream } = await import(\"../../src/core/flate_stream.js\");\n  const { StringStream } = await import(\"../../src/core/stream.js\");\n  const bytes = new Uint8Array([0x78, 0x9C, 0x00, 0x00, 0x00]);\n  const dataStr = String.fromCharCode(...bytes);\n  const stream = new StringStream(dataStr);\n  stream.dict = {};\n  const flateStream = new FlateStream(stream);\n  const result = await flateStream.asyncGetBytes();\n  chai.expect(result).to.be.null;\n});",
    "i3_gpt-4o": "it(\"should swallow extra data errors in asyncGetBytes\", async () => {\n  const { FlateStream } = await import(\"../../src/core/flate_stream.js\");\n  const { StringStream } = await import(\"../../src/core/stream.js\");\n  const bytes = new Uint8Array([0x78, 0x9C, 0x00, 0x00, 0x00]);\n  const dataStr = String.fromCharCode(...bytes);\n  const stream = new StringStream(dataStr);\n  stream.dict = {};\n  const flateStream = new FlateStream(stream);\n  const result = await flateStream.asyncGetBytes();\n  chai.expect(result).to.be.null;\n});",
    "i3_llama-3.3-70b-versatile": "it(\"should swallow extra data errors in asyncGetBytes\", async () => {\n  const { FlateStream } = await import(\"../../src/core/flate_stream.js\");\n  const { StringStream } = await import(\"../../src/core/stream.js\");\n  const bytes = new Uint8Array([0x78, 0x9C, 0x00, 0x00, 0x00]);\n  const dataStr = String.fromCharCode(...bytes);\n  const stream = new StringStream(dataStr);\n  stream.dict = {};\n  const flateStream = new FlateStream(stream);\n  const result = await flateStream.asyncGetBytes();\n  chai.expect(result).to.be.null;\n});",
    "i4_deepseek-r1-distill-llama-70b": "it(\"should swallow extra data errors in asyncGetBytes\", async () => {\n  const { FlateStream } = await import(\"../../src/core/flate_stream.js\");\n  const { StringStream } = await import(\"../../src/core/stream.js\");\n  const bytes = new Uint8Array([0x78, 0x9C, 0x00, 0x00, 0x00]);\n  const dataStr = String.fromCharCode(...bytes);\n  const stream = new StringStream(dataStr);\n  stream.dict = {};\n  const flateStream = new FlateStream(stream);\n  const result = await flateStream.asyncGetBytes();\n  chai.expect(result).to.be.null;\n});",
    "i4_gpt-4o": "it(\"should swallow extra data errors in asyncGetBytes\", async () => {\n  const { FlateStream } = await import(\"../../src/core/flate_stream.js\");\n  const { StringStream } = await import(\"../../src/core/stream.js\");\n  const bytes = new Uint8Array([0x78, 0x9C, 0x00, 0x00, 0x00]);\n  const dataStr = String.fromCharCode(...bytes);\n  const stream = new StringStream(dataStr);\n  stream.dict = {};\n  const flateStream = new FlateStream(stream);\n  const result = await flateStream.asyncGetBytes();\n  chai.expect(result).to.be.null;\n});",
    "i4_llama-3.3-70b-versatile": "it(\"should swallow extra data errors in asyncGetBytes\", async () => {\n  const { FlateStream } = await import(\"../../src/core/flate_stream.js\");\n  const { StringStream } = await import(\"../../src/core/stream.js\");\n  const bytes = new Uint8Array([0x78, 0x9C, 0x00, 0x00, 0x00]);\n  const dataStr = String.fromCharCode(...bytes);\n  const stream = new StringStream(dataStr);\n  stream.dict = {};\n  const flateStream = new FlateStream(stream);\n  const result = await flateStream.asyncGetBytes();\n  chai.expect(result).to.be.null;\n});",
    "i5_deepseek-r1-distill-llama-70b": "it(\"should swallow extra data errors in asyncGetBytes\", async () => {\n  const { FlateStream } = await import(\"../../src/core/flate_stream.js\");\n  const { StringStream } = await import(\"../../src/core/stream.js\");\n  const bytes = new Uint8Array([0x78, 0x9C, 0x00, 0x00, 0x00]);\n  const dataStr = String.fromCharCode(...bytes);\n  const stream = new StringStream(dataStr);\n  stream.dict = {};\n  const flateStream = new FlateStream(stream);\n  const result = await flateStream.asyncGetBytes();\n  chai.expect(result).to.be.null;\n});",
    "i5_gpt-4o": "it(\"should swallow extra data errors in asyncGetBytes\", async () => {\n  const { FlateStream } = await import(\"../../src/core/flate_stream.js\");\n  const { StringStream } = await import(\"../../src/core/stream.js\");\n  const bytes = new Uint8Array([0x78, 0x9C, 0x00, 0x00, 0x00]);\n  const dataStr = String.fromCharCode(...bytes);\n  const stream = new StringStream(dataStr);\n  stream.dict = {};\n  const flateStream = new FlateStream(stream);\n  const result = await flateStream.asyncGetBytes();\n  chai.expect(result).to.be.null;\n});",
    "i5_llama-3.3-70b-versatile": "it(\"should swallow extra data errors in asyncGetBytes\", async () => {\n  const { FlateStream } = await import(\"../../src/core/flate_stream.js\");\n  const { StringStream } = await import(\"../../src/core/stream.js\");\n  const bytes = new Uint8Array([0x78, 0x9C, 0x00, 0x00, 0x00]);\n  const dataStr = String.fromCharCode(...bytes);\n  const stream = new StringStream(dataStr);\n  stream.dict = {};\n  const flateStream = new FlateStream(stream);\n  const result = await flateStream.asyncGetBytes();\n  chai.expect(result).to.be.null;\n});"
  },
  "18895": {
    "i1_deepseek-r1-distill-llama-70b": "it(\"should convert setFillColorN numeric arguments to setFillRGBColor when no colorspace is provided\", async () => {\n  const { default: assert } = await import(\"assert\");\n  const dummyXRef = new XRefMock();\n  const operatorList = new OperatorList();\n  const fakeStream = {\n    _called: false,\n    read(operation) {\n      if (!this._called) {\n        this._called = true;\n        operation.args = [0.5];\n        operation.fn = OPS.setFillColorN;\n        return true;\n      }\n      return false;\n    },\n  };\n  const dummyTask = { ensureNotTerminated: () => {} };\n  const partialEvaluator = new PartialEvaluator({\n    xref: dummyXRef,\n    handler: {},\n    pageIndex: 0,\n    idFactory: createIdFactory(),\n    fontCache: new Map(),\n    builtInCMapCache: new Map(),\n    standardFontDataCache: new Map(),\n    globalImageCache: new Map(),\n    systemFontCache: new Map(),\n    options: {},\n  });\n  return partialEvaluator\n    .getOperatorList({\n      stream: fakeStream,\n      task: dummyTask,\n      resources: new Dict(),\n      operatorList,\n    })\n    .then(() => {\n      // Expect one op: the setFillColorN should have been converted to setFillRGBColor\n      assert.strictEqual(operatorList.fnArray.length, 1);\n      assert.strictEqual(operatorList.fnArray[0], OPS.setFillRGBColor);\n      // The gray color conversion yields [value, value, value]\n      assert.deepStrictEqual(operatorList.argsArray[0], [0.5, 0.5, 0.5]);\n    });\n});\n",
    "i1_gpt-4o": "it(\"should convert setFillColorN numeric arguments to setFillRGBColor when no colorspace is provided\", async () => {\n  const { default: assert } = await import(\"assert\");\n  const dummyXRef = new XRefMock();\n  const operatorList = new OperatorList();\n  const fakeStream = {\n    _called: false,\n    read(operation) {\n      if (!this._called) {\n        this._called = true;\n        operation.args = [0.5];\n        operation.fn = OPS.setFillColorN;\n        return true;\n      }\n      return false;\n    },\n  };\n  const dummyTask = { ensureNotTerminated: () => {} };\n  const partialEvaluator = new PartialEvaluator({\n    xref: dummyXRef,\n    handler: {},\n    pageIndex: 0,\n    idFactory: createIdFactory(),\n    fontCache: new Map(),\n    builtInCMapCache: new Map(),\n    standardFontDataCache: new Map(),\n    globalImageCache: new Map(),\n    systemFontCache: new Map(),\n    options: {},\n  });\n  return partialEvaluator\n    .getOperatorList({\n      stream: fakeStream,\n      task: dummyTask,\n      resources: new Dict(),\n      operatorList,\n    })\n    .then(() => {\n      // Expect one op: the setFillColorN should have been converted to setFillRGBColor\n      assert.strictEqual(operatorList.fnArray.length, 1);\n      assert.strictEqual(operatorList.fnArray[0], OPS.setFillRGBColor);\n      // The gray color conversion yields [value, value, value]\n      assert.deepStrictEqual(operatorList.argsArray[0], [0.5, 0.5, 0.5]);\n    });\n});\n",
    "i1_llama-3.3-70b-versatile": "it(\"should convert setFillColorN numeric arguments to setFillRGBColor when no colorspace is provided\", async () => {\n  const { default: assert } = await import(\"assert\");\n  const dummyXRef = new XRefMock();\n  const operatorList = new OperatorList();\n  const fakeStream = {\n    _called: false,\n    read(operation) {\n      if (!this._called) {\n        this._called = true;\n        operation.args = [0.5];\n        operation.fn = OPS.setFillColorN;\n        return true;\n      }\n      return false;\n    },\n  };\n  const dummyTask = { ensureNotTerminated: () => {} };\n  const partialEvaluator = new PartialEvaluator({\n    xref: dummyXRef,\n    handler: {},\n    pageIndex: 0,\n    idFactory: createIdFactory(),\n    fontCache: new Map(),\n    builtInCMapCache: new Map(),\n    standardFontDataCache: new Map(),\n    globalImageCache: new Map(),\n    systemFontCache: new Map(),\n    options: {},\n  });\n  return partialEvaluator\n    .getOperatorList({\n      stream: fakeStream,\n      task: dummyTask,\n      resources: new Dict(),\n      operatorList,\n    })\n    .then(() => {\n      // Expect one op: the setFillColorN should have been converted to setFillRGBColor\n      assert.strictEqual(operatorList.fnArray.length, 1);\n      assert.strictEqual(operatorList.fnArray[0], OPS.setFillRGBColor);\n      // The gray color conversion yields [value, value, value]\n      assert.deepStrictEqual(operatorList.argsArray[0], [0.5, 0.5, 0.5]);\n    });\n});\n",
    "i1_MOCK": "it(\"should convert setFillColorN numeric arguments to setFillRGBColor when no colorspace is provided\", async () => {\n  const { default: assert } = await import(\"assert\");\n  const dummyXRef = new XRefMock();\n  const operatorList = new OperatorList();\n  const fakeStream = {\n    _called: false,\n    read(operation) {\n      if (!this._called) {\n        this._called = true;\n        operation.args = [0.5];\n        operation.fn = OPS.setFillColorN;\n        return true;\n      }\n      return false;\n    },\n  };\n  const dummyTask = { ensureNotTerminated: () => {} };\n  const partialEvaluator = new PartialEvaluator({\n    xref: dummyXRef,\n    handler: {},\n    pageIndex: 0,\n    idFactory: createIdFactory(),\n    fontCache: new Map(),\n    builtInCMapCache: new Map(),\n    standardFontDataCache: new Map(),\n    globalImageCache: new Map(),\n    systemFontCache: new Map(),\n    options: {},\n  });\n  return partialEvaluator\n    .getOperatorList({\n      stream: fakeStream,\n      task: dummyTask,\n      resources: new Dict(),\n      operatorList,\n    })\n    .then(() => {\n      // Expect one op: the setFillColorN should have been converted to setFillRGBColor\n      assert.strictEqual(operatorList.fnArray.length, 1);\n      assert.strictEqual(operatorList.fnArray[0], OPS.setFillRGBColor);\n      // The gray color conversion yields [value, value, value]\n      assert.deepStrictEqual(operatorList.argsArray[0], [0.5, 0.5, 0.5]);\n    });\n});\n",
    "i2_deepseek-r1-distill-llama-70b": "it(\"should convert setFillColorN numeric arguments to setFillRGBColor when no colorspace is provided\", async () => {\n  const { default: assert } = await import(\"assert\");\n  const dummyXRef = new XRefMock();\n  const operatorList = new OperatorList();\n  const fakeStream = {\n    _called: false,\n    read(operation) {\n      if (!this._called) {\n        this._called = true;\n        operation.args = [0.5];\n        operation.fn = OPS.setFillColorN;\n        return true;\n      }\n      return false;\n    },\n  };\n  const dummyTask = { ensureNotTerminated: () => {} };\n  const partialEvaluator = new PartialEvaluator({\n    xref: dummyXRef,\n    handler: {},\n    pageIndex: 0,\n    idFactory: createIdFactory(),\n    fontCache: new Map(),\n    builtInCMapCache: new Map(),\n    standardFontDataCache: new Map(),\n    globalImageCache: new Map(),\n    systemFontCache: new Map(),\n    options: {},\n  });\n  return partialEvaluator\n    .getOperatorList({\n      stream: fakeStream,\n      task: dummyTask,\n      resources: new Dict(),\n      operatorList,\n    })\n    .then(() => {\n      // Expect one op: the setFillColorN should have been converted to setFillRGBColor\n      assert.strictEqual(operatorList.fnArray.length, 1);\n      assert.strictEqual(operatorList.fnArray[0], OPS.setFillRGBColor);\n      // The gray color conversion yields [value, value, value]\n      assert.deepStrictEqual(operatorList.argsArray[0], [0.5, 0.5, 0.5]);\n    });\n});\n",
    "i2_gpt-4o": "it(\"should convert setFillColorN numeric arguments to setFillRGBColor when no colorspace is provided\", async () => {\n  const { default: assert } = await import(\"assert\");\n  const dummyXRef = new XRefMock();\n  const operatorList = new OperatorList();\n  const fakeStream = {\n    _called: false,\n    read(operation) {\n      if (!this._called) {\n        this._called = true;\n        operation.args = [0.5];\n        operation.fn = OPS.setFillColorN;\n        return true;\n      }\n      return false;\n    },\n  };\n  const dummyTask = { ensureNotTerminated: () => {} };\n  const partialEvaluator = new PartialEvaluator({\n    xref: dummyXRef,\n    handler: {},\n    pageIndex: 0,\n    idFactory: createIdFactory(),\n    fontCache: new Map(),\n    builtInCMapCache: new Map(),\n    standardFontDataCache: new Map(),\n    globalImageCache: new Map(),\n    systemFontCache: new Map(),\n    options: {},\n  });\n  return partialEvaluator\n    .getOperatorList({\n      stream: fakeStream,\n      task: dummyTask,\n      resources: new Dict(),\n      operatorList,\n    })\n    .then(() => {\n      // Expect one op: the setFillColorN should have been converted to setFillRGBColor\n      assert.strictEqual(operatorList.fnArray.length, 1);\n      assert.strictEqual(operatorList.fnArray[0], OPS.setFillRGBColor);\n      // The gray color conversion yields [value, value, value]\n      assert.deepStrictEqual(operatorList.argsArray[0], [0.5, 0.5, 0.5]);\n    });\n});\n",
    "i2_llama-3.3-70b-versatile": "it(\"should convert setFillColorN numeric arguments to setFillRGBColor when no colorspace is provided\", async () => {\n  const { default: assert } = await import(\"assert\");\n  const dummyXRef = new XRefMock();\n  const operatorList = new OperatorList();\n  const fakeStream = {\n    _called: false,\n    read(operation) {\n      if (!this._called) {\n        this._called = true;\n        operation.args = [0.5];\n        operation.fn = OPS.setFillColorN;\n        return true;\n      }\n      return false;\n    },\n  };\n  const dummyTask = { ensureNotTerminated: () => {} };\n  const partialEvaluator = new PartialEvaluator({\n    xref: dummyXRef,\n    handler: {},\n    pageIndex: 0,\n    idFactory: createIdFactory(),\n    fontCache: new Map(),\n    builtInCMapCache: new Map(),\n    standardFontDataCache: new Map(),\n    globalImageCache: new Map(),\n    systemFontCache: new Map(),\n    options: {},\n  });\n  return partialEvaluator\n    .getOperatorList({\n      stream: fakeStream,\n      task: dummyTask,\n      resources: new Dict(),\n      operatorList,\n    })\n    .then(() => {\n      // Expect one op: the setFillColorN should have been converted to setFillRGBColor\n      assert.strictEqual(operatorList.fnArray.length, 1);\n      assert.strictEqual(operatorList.fnArray[0], OPS.setFillRGBColor);\n      // The gray color conversion yields [value, value, value]\n      assert.deepStrictEqual(operatorList.argsArray[0], [0.5, 0.5, 0.5]);\n    });\n});\n",
    "i3_deepseek-r1-distill-llama-70b": "it(\"should convert setFillColorN numeric arguments to setFillRGBColor when no colorspace is provided\", async () => {\n  const { default: assert } = await import(\"assert\");\n  const dummyXRef = new XRefMock();\n  const operatorList = new OperatorList();\n  const fakeStream = {\n    _called: false,\n    read(operation) {\n      if (!this._called) {\n        this._called = true;\n        operation.args = [0.5];\n        operation.fn = OPS.setFillColorN;\n        return true;\n      }\n      return false;\n    },\n  };\n  const dummyTask = { ensureNotTerminated: () => {} };\n  const partialEvaluator = new PartialEvaluator({\n    xref: dummyXRef,\n    handler: {},\n    pageIndex: 0,\n    idFactory: createIdFactory(),\n    fontCache: new Map(),\n    builtInCMapCache: new Map(),\n    standardFontDataCache: new Map(),\n    globalImageCache: new Map(),\n    systemFontCache: new Map(),\n    options: {},\n  });\n  return partialEvaluator\n    .getOperatorList({\n      stream: fakeStream,\n      task: dummyTask,\n      resources: new Dict(),\n      operatorList,\n    })\n    .then(() => {\n      // Expect one op: the setFillColorN should have been converted to setFillRGBColor\n      assert.strictEqual(operatorList.fnArray.length, 1);\n      assert.strictEqual(operatorList.fnArray[0], OPS.setFillRGBColor);\n      // The gray color conversion yields [value, value, value]\n      assert.deepStrictEqual(operatorList.argsArray[0], [0.5, 0.5, 0.5]);\n    });\n});\n",
    "i3_gpt-4o": "it(\"should convert setFillColorN numeric arguments to setFillRGBColor when no colorspace is provided\", async () => {\n  const { default: assert } = await import(\"assert\");\n  const dummyXRef = new XRefMock();\n  const operatorList = new OperatorList();\n  const fakeStream = {\n    _called: false,\n    read(operation) {\n      if (!this._called) {\n        this._called = true;\n        operation.args = [0.5];\n        operation.fn = OPS.setFillColorN;\n        return true;\n      }\n      return false;\n    },\n  };\n  const dummyTask = { ensureNotTerminated: () => {} };\n  const partialEvaluator = new PartialEvaluator({\n    xref: dummyXRef,\n    handler: {},\n    pageIndex: 0,\n    idFactory: createIdFactory(),\n    fontCache: new Map(),\n    builtInCMapCache: new Map(),\n    standardFontDataCache: new Map(),\n    globalImageCache: new Map(),\n    systemFontCache: new Map(),\n    options: {},\n  });\n  return partialEvaluator\n    .getOperatorList({\n      stream: fakeStream,\n      task: dummyTask,\n      resources: new Dict(),\n      operatorList,\n    })\n    .then(() => {\n      // Expect one op: the setFillColorN should have been converted to setFillRGBColor\n      assert.strictEqual(operatorList.fnArray.length, 1);\n      assert.strictEqual(operatorList.fnArray[0], OPS.setFillRGBColor);\n      // The gray color conversion yields [value, value, value]\n      assert.deepStrictEqual(operatorList.argsArray[0], [0.5, 0.5, 0.5]);\n    });\n});\n",
    "i3_llama-3.3-70b-versatile": "it(\"should convert setFillColorN numeric arguments to setFillRGBColor when no colorspace is provided\", async () => {\n  const { default: assert } = await import(\"assert\");\n  const dummyXRef = new XRefMock();\n  const operatorList = new OperatorList();\n  const fakeStream = {\n    _called: false,\n    read(operation) {\n      if (!this._called) {\n        this._called = true;\n        operation.args = [0.5];\n        operation.fn = OPS.setFillColorN;\n        return true;\n      }\n      return false;\n    },\n  };\n  const dummyTask = { ensureNotTerminated: () => {} };\n  const partialEvaluator = new PartialEvaluator({\n    xref: dummyXRef,\n    handler: {},\n    pageIndex: 0,\n    idFactory: createIdFactory(),\n    fontCache: new Map(),\n    builtInCMapCache: new Map(),\n    standardFontDataCache: new Map(),\n    globalImageCache: new Map(),\n    systemFontCache: new Map(),\n    options: {},\n  });\n  return partialEvaluator\n    .getOperatorList({\n      stream: fakeStream,\n      task: dummyTask,\n      resources: new Dict(),\n      operatorList,\n    })\n    .then(() => {\n      // Expect one op: the setFillColorN should have been converted to setFillRGBColor\n      assert.strictEqual(operatorList.fnArray.length, 1);\n      assert.strictEqual(operatorList.fnArray[0], OPS.setFillRGBColor);\n      // The gray color conversion yields [value, value, value]\n      assert.deepStrictEqual(operatorList.argsArray[0], [0.5, 0.5, 0.5]);\n    });\n});\n",
    "i4_deepseek-r1-distill-llama-70b": "it(\"should convert setFillColorN numeric arguments to setFillRGBColor when no colorspace is provided\", async () => {\n  const { default: assert } = await import(\"assert\");\n  const dummyXRef = new XRefMock();\n  const operatorList = new OperatorList();\n  const fakeStream = {\n    _called: false,\n    read(operation) {\n      if (!this._called) {\n        this._called = true;\n        operation.args = [0.5];\n        operation.fn = OPS.setFillColorN;\n        return true;\n      }\n      return false;\n    },\n  };\n  const dummyTask = { ensureNotTerminated: () => {} };\n  const partialEvaluator = new PartialEvaluator({\n    xref: dummyXRef,\n    handler: {},\n    pageIndex: 0,\n    idFactory: createIdFactory(),\n    fontCache: new Map(),\n    builtInCMapCache: new Map(),\n    standardFontDataCache: new Map(),\n    globalImageCache: new Map(),\n    systemFontCache: new Map(),\n    options: {},\n  });\n  return partialEvaluator\n    .getOperatorList({\n      stream: fakeStream,\n      task: dummyTask,\n      resources: new Dict(),\n      operatorList,\n    })\n    .then(() => {\n      // Expect one op: the setFillColorN should have been converted to setFillRGBColor\n      assert.strictEqual(operatorList.fnArray.length, 1);\n      assert.strictEqual(operatorList.fnArray[0], OPS.setFillRGBColor);\n      // The gray color conversion yields [value, value, value]\n      assert.deepStrictEqual(operatorList.argsArray[0], [0.5, 0.5, 0.5]);\n    });\n});\n",
    "i4_gpt-4o": "it(\"should convert setFillColorN numeric arguments to setFillRGBColor when no colorspace is provided\", async () => {\n  const { default: assert } = await import(\"assert\");\n  const dummyXRef = new XRefMock();\n  const operatorList = new OperatorList();\n  const fakeStream = {\n    _called: false,\n    read(operation) {\n      if (!this._called) {\n        this._called = true;\n        operation.args = [0.5];\n        operation.fn = OPS.setFillColorN;\n        return true;\n      }\n      return false;\n    },\n  };\n  const dummyTask = { ensureNotTerminated: () => {} };\n  const partialEvaluator = new PartialEvaluator({\n    xref: dummyXRef,\n    handler: {},\n    pageIndex: 0,\n    idFactory: createIdFactory(),\n    fontCache: new Map(),\n    builtInCMapCache: new Map(),\n    standardFontDataCache: new Map(),\n    globalImageCache: new Map(),\n    systemFontCache: new Map(),\n    options: {},\n  });\n  return partialEvaluator\n    .getOperatorList({\n      stream: fakeStream,\n      task: dummyTask,\n      resources: new Dict(),\n      operatorList,\n    })\n    .then(() => {\n      // Expect one op: the setFillColorN should have been converted to setFillRGBColor\n      assert.strictEqual(operatorList.fnArray.length, 1);\n      assert.strictEqual(operatorList.fnArray[0], OPS.setFillRGBColor);\n      // The gray color conversion yields [value, value, value]\n      assert.deepStrictEqual(operatorList.argsArray[0], [0.5, 0.5, 0.5]);\n    });\n});\n",
    "i4_llama-3.3-70b-versatile": "it(\"should convert setFillColorN numeric arguments to setFillRGBColor when no colorspace is provided\", async () => {\n  const { default: assert } = await import(\"assert\");\n  const dummyXRef = new XRefMock();\n  const operatorList = new OperatorList();\n  const fakeStream = {\n    _called: false,\n    read(operation) {\n      if (!this._called) {\n        this._called = true;\n        operation.args = [0.5];\n        operation.fn = OPS.setFillColorN;\n        return true;\n      }\n      return false;\n    },\n  };\n  const dummyTask = { ensureNotTerminated: () => {} };\n  const partialEvaluator = new PartialEvaluator({\n    xref: dummyXRef,\n    handler: {},\n    pageIndex: 0,\n    idFactory: createIdFactory(),\n    fontCache: new Map(),\n    builtInCMapCache: new Map(),\n    standardFontDataCache: new Map(),\n    globalImageCache: new Map(),\n    systemFontCache: new Map(),\n    options: {},\n  });\n  return partialEvaluator\n    .getOperatorList({\n      stream: fakeStream,\n      task: dummyTask,\n      resources: new Dict(),\n      operatorList,\n    })\n    .then(() => {\n      // Expect one op: the setFillColorN should have been converted to setFillRGBColor\n      assert.strictEqual(operatorList.fnArray.length, 1);\n      assert.strictEqual(operatorList.fnArray[0], OPS.setFillRGBColor);\n      // The gray color conversion yields [value, value, value]\n      assert.deepStrictEqual(operatorList.argsArray[0], [0.5, 0.5, 0.5]);\n    });\n});\n",
    "i5_deepseek-r1-distill-llama-70b": "it(\"should convert setFillColorN numeric arguments to setFillRGBColor when no colorspace is provided\", async () => {\n  const { default: assert } = await import(\"assert\");\n  const dummyXRef = new XRefMock();\n  const operatorList = new OperatorList();\n  const fakeStream = {\n    _called: false,\n    read(operation) {\n      if (!this._called) {\n        this._called = true;\n        operation.args = [0.5];\n        operation.fn = OPS.setFillColorN;\n        return true;\n      }\n      return false;\n    },\n  };\n  const dummyTask = { ensureNotTerminated: () => {} };\n  const partialEvaluator = new PartialEvaluator({\n    xref: dummyXRef,\n    handler: {},\n    pageIndex: 0,\n    idFactory: createIdFactory(),\n    fontCache: new Map(),\n    builtInCMapCache: new Map(),\n    standardFontDataCache: new Map(),\n    globalImageCache: new Map(),\n    systemFontCache: new Map(),\n    options: {},\n  });\n  return partialEvaluator\n    .getOperatorList({\n      stream: fakeStream,\n      task: dummyTask,\n      resources: new Dict(),\n      operatorList,\n    })\n    .then(() => {\n      // Expect one op: the setFillColorN should have been converted to setFillRGBColor\n      assert.strictEqual(operatorList.fnArray.length, 1);\n      assert.strictEqual(operatorList.fnArray[0], OPS.setFillRGBColor);\n      // The gray color conversion yields [value, value, value]\n      assert.deepStrictEqual(operatorList.argsArray[0], [0.5, 0.5, 0.5]);\n    });\n});\n",
    "i5_gpt-4o": "it(\"should convert setFillColorN numeric arguments to setFillRGBColor when no colorspace is provided\", async () => {\n  const { default: assert } = await import(\"assert\");\n  const dummyXRef = new XRefMock();\n  const operatorList = new OperatorList();\n  const fakeStream = {\n    _called: false,\n    read(operation) {\n      if (!this._called) {\n        this._called = true;\n        operation.args = [0.5];\n        operation.fn = OPS.setFillColorN;\n        return true;\n      }\n      return false;\n    },\n  };\n  const dummyTask = { ensureNotTerminated: () => {} };\n  const partialEvaluator = new PartialEvaluator({\n    xref: dummyXRef,\n    handler: {},\n    pageIndex: 0,\n    idFactory: createIdFactory(),\n    fontCache: new Map(),\n    builtInCMapCache: new Map(),\n    standardFontDataCache: new Map(),\n    globalImageCache: new Map(),\n    systemFontCache: new Map(),\n    options: {},\n  });\n  return partialEvaluator\n    .getOperatorList({\n      stream: fakeStream,\n      task: dummyTask,\n      resources: new Dict(),\n      operatorList,\n    })\n    .then(() => {\n      // Expect one op: the setFillColorN should have been converted to setFillRGBColor\n      assert.strictEqual(operatorList.fnArray.length, 1);\n      assert.strictEqual(operatorList.fnArray[0], OPS.setFillRGBColor);\n      // The gray color conversion yields [value, value, value]\n      assert.deepStrictEqual(operatorList.argsArray[0], [0.5, 0.5, 0.5]);\n    });\n});\n",
    "i5_llama-3.3-70b-versatile": "it(\"should convert setFillColorN numeric arguments to setFillRGBColor when no colorspace is provided\", async () => {\n  const { default: assert } = await import(\"assert\");\n  const dummyXRef = new XRefMock();\n  const operatorList = new OperatorList();\n  const fakeStream = {\n    _called: false,\n    read(operation) {\n      if (!this._called) {\n        this._called = true;\n        operation.args = [0.5];\n        operation.fn = OPS.setFillColorN;\n        return true;\n      }\n      return false;\n    },\n  };\n  const dummyTask = { ensureNotTerminated: () => {} };\n  const partialEvaluator = new PartialEvaluator({\n    xref: dummyXRef,\n    handler: {},\n    pageIndex: 0,\n    idFactory: createIdFactory(),\n    fontCache: new Map(),\n    builtInCMapCache: new Map(),\n    standardFontDataCache: new Map(),\n    globalImageCache: new Map(),\n    systemFontCache: new Map(),\n    options: {},\n  });\n  return partialEvaluator\n    .getOperatorList({\n      stream: fakeStream,\n      task: dummyTask,\n      resources: new Dict(),\n      operatorList,\n    })\n    .then(() => {\n      // Expect one op: the setFillColorN should have been converted to setFillRGBColor\n      assert.strictEqual(operatorList.fnArray.length, 1);\n      assert.strictEqual(operatorList.fnArray[0], OPS.setFillRGBColor);\n      // The gray color conversion yields [value, value, value]\n      assert.deepStrictEqual(operatorList.argsArray[0], [0.5, 0.5, 0.5]);\n    });\n});\n"
  },
  "18960": {
    "i1_deepseek-r1-distill-llama-70b": "it(\"should correctly apply the backdrop fill when mask extension occurs\", async () => {\n  const { Util } = await import(\"../../src/shared/util.js\");\n  const { CanvasGraphics } = await import(\"../../src/display/canvas.js\");\n  const { DefaultCanvasFactory } = await import(\"../../src/display/api.js\");\n  const factory = new DefaultCanvasFactory();\n  const maskObj = factory.create(70, 50);\n  const layerObj = factory.create(50, 50);\n  const maskCtx = maskObj.context;\n  const layerCtx = layerObj.context;\n  maskCtx.fillStyle = \"#ffffff\";\n  maskCtx.fillRect(0, 0, 70, 50);\n  const dummyFilterFactory = { addAlphaFilter: () => \"\" , addLuminosityFilter: () => \"\" };\n  const cg = new CanvasGraphics(layerCtx, {}, {}, factory, dummyFilterFactory, {}, null);\n  const backdrop = [0, 0, 0];\n  // Setting layerOffsetX=0 and maskOffsetX=10 forces maskX = -10 (mask extension branch)\n  cg.genericComposeSMask(maskCtx, layerCtx, 50, 50, \"Alpha\", backdrop, null, 0, 0, 10, 0);\n  const { data } = layerCtx.getImageData(25, 25, 1, 1);\n  if (!(data[0] === 0 && data[1] === 0 && data[2] === 0 && data[3] === 255)) {\n    throw new Error(\"Backdrop fill not correctly applied\");\n  }\n});",
    "i1_gpt-4o": "it(\"should correctly apply the backdrop fill when mask extension occurs\", async () => {\n  const { Util } = await import(\"../../src/shared/util.js\");\n  const { CanvasGraphics } = await import(\"../../src/display/canvas.js\");\n  const { DefaultCanvasFactory } = await import(\"../../src/display/api.js\");\n  const factory = new DefaultCanvasFactory();\n  const maskObj = factory.create(70, 50);\n  const layerObj = factory.create(50, 50);\n  const maskCtx = maskObj.context;\n  const layerCtx = layerObj.context;\n  maskCtx.fillStyle = \"#ffffff\";\n  maskCtx.fillRect(0, 0, 70, 50);\n  const dummyFilterFactory = { addAlphaFilter: () => \"\" , addLuminosityFilter: () => \"\" };\n  const cg = new CanvasGraphics(layerCtx, {}, {}, factory, dummyFilterFactory, {}, null);\n  const backdrop = [0, 0, 0];\n  // Setting layerOffsetX=0 and maskOffsetX=10 forces maskX = -10 (mask extension branch)\n  cg.genericComposeSMask(maskCtx, layerCtx, 50, 50, \"Alpha\", backdrop, null, 0, 0, 10, 0);\n  const { data } = layerCtx.getImageData(25, 25, 1, 1);\n  if (!(data[0] === 0 && data[1] === 0 && data[2] === 0 && data[3] === 255)) {\n    throw new Error(\"Backdrop fill not correctly applied\");\n  }\n});",
    "i1_llama-3.3-70b-versatile": "it(\"should correctly apply the backdrop fill when mask extension occurs\", async () => {\n  const { Util } = await import(\"../../src/shared/util.js\");\n  const { CanvasGraphics } = await import(\"../../src/display/canvas.js\");\n  const { DefaultCanvasFactory } = await import(\"../../src/display/api.js\");\n  const factory = new DefaultCanvasFactory();\n  const maskObj = factory.create(70, 50);\n  const layerObj = factory.create(50, 50);\n  const maskCtx = maskObj.context;\n  const layerCtx = layerObj.context;\n  maskCtx.fillStyle = \"#ffffff\";\n  maskCtx.fillRect(0, 0, 70, 50);\n  const dummyFilterFactory = { addAlphaFilter: () => \"\" , addLuminosityFilter: () => \"\" };\n  const cg = new CanvasGraphics(layerCtx, {}, {}, factory, dummyFilterFactory, {}, null);\n  const backdrop = [0, 0, 0];\n  // Setting layerOffsetX=0 and maskOffsetX=10 forces maskX = -10 (mask extension branch)\n  cg.genericComposeSMask(maskCtx, layerCtx, 50, 50, \"Alpha\", backdrop, null, 0, 0, 10, 0);\n  const { data } = layerCtx.getImageData(25, 25, 1, 1);\n  if (!(data[0] === 0 && data[1] === 0 && data[2] === 0 && data[3] === 255)) {\n    throw new Error(\"Backdrop fill not correctly applied\");\n  }\n});",
    "i1_MOCK": "it(\"should correctly apply the backdrop fill when mask extension occurs\", async () => {\n  const { Util } = await import(\"../../src/shared/util.js\");\n  const { CanvasGraphics } = await import(\"../../src/display/canvas.js\");\n  const { DefaultCanvasFactory } = await import(\"../../src/display/api.js\");\n  const factory = new DefaultCanvasFactory();\n  const maskObj = factory.create(70, 50);\n  const layerObj = factory.create(50, 50);\n  const maskCtx = maskObj.context;\n  const layerCtx = layerObj.context;\n  maskCtx.fillStyle = \"#ffffff\";\n  maskCtx.fillRect(0, 0, 70, 50);\n  const dummyFilterFactory = { addAlphaFilter: () => \"\" , addLuminosityFilter: () => \"\" };\n  const cg = new CanvasGraphics(layerCtx, {}, {}, factory, dummyFilterFactory, {}, null);\n  const backdrop = [0, 0, 0];\n  // Setting layerOffsetX=0 and maskOffsetX=10 forces maskX = -10 (mask extension branch)\n  cg.genericComposeSMask(maskCtx, layerCtx, 50, 50, \"Alpha\", backdrop, null, 0, 0, 10, 0);\n  const { data } = layerCtx.getImageData(25, 25, 1, 1);\n  if (!(data[0] === 0 && data[1] === 0 && data[2] === 0 && data[3] === 255)) {\n    throw new Error(\"Backdrop fill not correctly applied\");\n  }\n});",
    "i2_deepseek-r1-distill-llama-70b": "it(\"should correctly apply the backdrop fill when mask extension occurs\", async () => {\n  const { Util } = await import(\"../../src/shared/util.js\");\n  const { CanvasGraphics } = await import(\"../../src/display/canvas.js\");\n  const { DefaultCanvasFactory } = await import(\"../../src/display/api.js\");\n  const factory = new DefaultCanvasFactory();\n  const maskObj = factory.create(70, 50);\n  const layerObj = factory.create(50, 50);\n  const maskCtx = maskObj.context;\n  const layerCtx = layerObj.context;\n  maskCtx.fillStyle = \"#ffffff\";\n  maskCtx.fillRect(0, 0, 70, 50);\n  const dummyFilterFactory = { addAlphaFilter: () => \"\" , addLuminosityFilter: () => \"\" };\n  const cg = new CanvasGraphics(layerCtx, {}, {}, factory, dummyFilterFactory, {}, null);\n  const backdrop = [0, 0, 0];\n  // Setting layerOffsetX=0 and maskOffsetX=10 forces maskX = -10 (mask extension branch)\n  cg.genericComposeSMask(maskCtx, layerCtx, 50, 50, \"Alpha\", backdrop, null, 0, 0, 10, 0);\n  const { data } = layerCtx.getImageData(25, 25, 1, 1);\n  if (!(data[0] === 0 && data[1] === 0 && data[2] === 0 && data[3] === 255)) {\n    throw new Error(\"Backdrop fill not correctly applied\");\n  }\n});",
    "i2_gpt-4o": "it(\"should correctly apply the backdrop fill when mask extension occurs\", async () => {\n  const { Util } = await import(\"../../src/shared/util.js\");\n  const { CanvasGraphics } = await import(\"../../src/display/canvas.js\");\n  const { DefaultCanvasFactory } = await import(\"../../src/display/api.js\");\n  const factory = new DefaultCanvasFactory();\n  const maskObj = factory.create(70, 50);\n  const layerObj = factory.create(50, 50);\n  const maskCtx = maskObj.context;\n  const layerCtx = layerObj.context;\n  maskCtx.fillStyle = \"#ffffff\";\n  maskCtx.fillRect(0, 0, 70, 50);\n  const dummyFilterFactory = { addAlphaFilter: () => \"\" , addLuminosityFilter: () => \"\" };\n  const cg = new CanvasGraphics(layerCtx, {}, {}, factory, dummyFilterFactory, {}, null);\n  const backdrop = [0, 0, 0];\n  // Setting layerOffsetX=0 and maskOffsetX=10 forces maskX = -10 (mask extension branch)\n  cg.genericComposeSMask(maskCtx, layerCtx, 50, 50, \"Alpha\", backdrop, null, 0, 0, 10, 0);\n  const { data } = layerCtx.getImageData(25, 25, 1, 1);\n  if (!(data[0] === 0 && data[1] === 0 && data[2] === 0 && data[3] === 255)) {\n    throw new Error(\"Backdrop fill not correctly applied\");\n  }\n});",
    "i2_llama-3.3-70b-versatile": "it(\"should correctly apply the backdrop fill when mask extension occurs\", async () => {\n  const { Util } = await import(\"../../src/shared/util.js\");\n  const { CanvasGraphics } = await import(\"../../src/display/canvas.js\");\n  const { DefaultCanvasFactory } = await import(\"../../src/display/api.js\");\n  const factory = new DefaultCanvasFactory();\n  const maskObj = factory.create(70, 50);\n  const layerObj = factory.create(50, 50);\n  const maskCtx = maskObj.context;\n  const layerCtx = layerObj.context;\n  maskCtx.fillStyle = \"#ffffff\";\n  maskCtx.fillRect(0, 0, 70, 50);\n  const dummyFilterFactory = { addAlphaFilter: () => \"\" , addLuminosityFilter: () => \"\" };\n  const cg = new CanvasGraphics(layerCtx, {}, {}, factory, dummyFilterFactory, {}, null);\n  const backdrop = [0, 0, 0];\n  // Setting layerOffsetX=0 and maskOffsetX=10 forces maskX = -10 (mask extension branch)\n  cg.genericComposeSMask(maskCtx, layerCtx, 50, 50, \"Alpha\", backdrop, null, 0, 0, 10, 0);\n  const { data } = layerCtx.getImageData(25, 25, 1, 1);\n  if (!(data[0] === 0 && data[1] === 0 && data[2] === 0 && data[3] === 255)) {\n    throw new Error(\"Backdrop fill not correctly applied\");\n  }\n});",
    "i3_deepseek-r1-distill-llama-70b": "it(\"should correctly apply the backdrop fill when mask extension occurs\", async () => {\n  const { Util } = await import(\"../../src/shared/util.js\");\n  const { CanvasGraphics } = await import(\"../../src/display/canvas.js\");\n  const { DefaultCanvasFactory } = await import(\"../../src/display/api.js\");\n  const factory = new DefaultCanvasFactory();\n  const maskObj = factory.create(70, 50);\n  const layerObj = factory.create(50, 50);\n  const maskCtx = maskObj.context;\n  const layerCtx = layerObj.context;\n  maskCtx.fillStyle = \"#ffffff\";\n  maskCtx.fillRect(0, 0, 70, 50);\n  const dummyFilterFactory = { addAlphaFilter: () => \"\" , addLuminosityFilter: () => \"\" };\n  const cg = new CanvasGraphics(layerCtx, {}, {}, factory, dummyFilterFactory, {}, null);\n  const backdrop = [0, 0, 0];\n  // Setting layerOffsetX=0 and maskOffsetX=10 forces maskX = -10 (mask extension branch)\n  cg.genericComposeSMask(maskCtx, layerCtx, 50, 50, \"Alpha\", backdrop, null, 0, 0, 10, 0);\n  const { data } = layerCtx.getImageData(25, 25, 1, 1);\n  if (!(data[0] === 0 && data[1] === 0 && data[2] === 0 && data[3] === 255)) {\n    throw new Error(\"Backdrop fill not correctly applied\");\n  }\n});",
    "i3_gpt-4o": "it(\"should correctly apply the backdrop fill when mask extension occurs\", async () => {\n  const { Util } = await import(\"../../src/shared/util.js\");\n  const { CanvasGraphics } = await import(\"../../src/display/canvas.js\");\n  const { DefaultCanvasFactory } = await import(\"../../src/display/api.js\");\n  const factory = new DefaultCanvasFactory();\n  const maskObj = factory.create(70, 50);\n  const layerObj = factory.create(50, 50);\n  const maskCtx = maskObj.context;\n  const layerCtx = layerObj.context;\n  maskCtx.fillStyle = \"#ffffff\";\n  maskCtx.fillRect(0, 0, 70, 50);\n  const dummyFilterFactory = { addAlphaFilter: () => \"\" , addLuminosityFilter: () => \"\" };\n  const cg = new CanvasGraphics(layerCtx, {}, {}, factory, dummyFilterFactory, {}, null);\n  const backdrop = [0, 0, 0];\n  // Setting layerOffsetX=0 and maskOffsetX=10 forces maskX = -10 (mask extension branch)\n  cg.genericComposeSMask(maskCtx, layerCtx, 50, 50, \"Alpha\", backdrop, null, 0, 0, 10, 0);\n  const { data } = layerCtx.getImageData(25, 25, 1, 1);\n  if (!(data[0] === 0 && data[1] === 0 && data[2] === 0 && data[3] === 255)) {\n    throw new Error(\"Backdrop fill not correctly applied\");\n  }\n});",
    "i3_llama-3.3-70b-versatile": "it(\"should correctly apply the backdrop fill when mask extension occurs\", async () => {\n  const { Util } = await import(\"../../src/shared/util.js\");\n  const { CanvasGraphics } = await import(\"../../src/display/canvas.js\");\n  const { DefaultCanvasFactory } = await import(\"../../src/display/api.js\");\n  const factory = new DefaultCanvasFactory();\n  const maskObj = factory.create(70, 50);\n  const layerObj = factory.create(50, 50);\n  const maskCtx = maskObj.context;\n  const layerCtx = layerObj.context;\n  maskCtx.fillStyle = \"#ffffff\";\n  maskCtx.fillRect(0, 0, 70, 50);\n  const dummyFilterFactory = { addAlphaFilter: () => \"\" , addLuminosityFilter: () => \"\" };\n  const cg = new CanvasGraphics(layerCtx, {}, {}, factory, dummyFilterFactory, {}, null);\n  const backdrop = [0, 0, 0];\n  // Setting layerOffsetX=0 and maskOffsetX=10 forces maskX = -10 (mask extension branch)\n  cg.genericComposeSMask(maskCtx, layerCtx, 50, 50, \"Alpha\", backdrop, null, 0, 0, 10, 0);\n  const { data } = layerCtx.getImageData(25, 25, 1, 1);\n  if (!(data[0] === 0 && data[1] === 0 && data[2] === 0 && data[3] === 255)) {\n    throw new Error(\"Backdrop fill not correctly applied\");\n  }\n});",
    "i4_deepseek-r1-distill-llama-70b": "it(\"should correctly apply the backdrop fill when mask extension occurs\", async () => {\n  const { Util } = await import(\"../../src/shared/util.js\");\n  const { CanvasGraphics } = await import(\"../../src/display/canvas.js\");\n  const { DefaultCanvasFactory } = await import(\"../../src/display/api.js\");\n  const factory = new DefaultCanvasFactory();\n  const maskObj = factory.create(70, 50);\n  const layerObj = factory.create(50, 50);\n  const maskCtx = maskObj.context;\n  const layerCtx = layerObj.context;\n  maskCtx.fillStyle = \"#ffffff\";\n  maskCtx.fillRect(0, 0, 70, 50);\n  const dummyFilterFactory = { addAlphaFilter: () => \"\" , addLuminosityFilter: () => \"\" };\n  const cg = new CanvasGraphics(layerCtx, {}, {}, factory, dummyFilterFactory, {}, null);\n  const backdrop = [0, 0, 0];\n  // Setting layerOffsetX=0 and maskOffsetX=10 forces maskX = -10 (mask extension branch)\n  cg.genericComposeSMask(maskCtx, layerCtx, 50, 50, \"Alpha\", backdrop, null, 0, 0, 10, 0);\n  const { data } = layerCtx.getImageData(25, 25, 1, 1);\n  if (!(data[0] === 0 && data[1] === 0 && data[2] === 0 && data[3] === 255)) {\n    throw new Error(\"Backdrop fill not correctly applied\");\n  }\n});",
    "i4_gpt-4o": "it(\"should correctly apply the backdrop fill when mask extension occurs\", async () => {\n  const { Util } = await import(\"../../src/shared/util.js\");\n  const { CanvasGraphics } = await import(\"../../src/display/canvas.js\");\n  const { DefaultCanvasFactory } = await import(\"../../src/display/api.js\");\n  const factory = new DefaultCanvasFactory();\n  const maskObj = factory.create(70, 50);\n  const layerObj = factory.create(50, 50);\n  const maskCtx = maskObj.context;\n  const layerCtx = layerObj.context;\n  maskCtx.fillStyle = \"#ffffff\";\n  maskCtx.fillRect(0, 0, 70, 50);\n  const dummyFilterFactory = { addAlphaFilter: () => \"\" , addLuminosityFilter: () => \"\" };\n  const cg = new CanvasGraphics(layerCtx, {}, {}, factory, dummyFilterFactory, {}, null);\n  const backdrop = [0, 0, 0];\n  // Setting layerOffsetX=0 and maskOffsetX=10 forces maskX = -10 (mask extension branch)\n  cg.genericComposeSMask(maskCtx, layerCtx, 50, 50, \"Alpha\", backdrop, null, 0, 0, 10, 0);\n  const { data } = layerCtx.getImageData(25, 25, 1, 1);\n  if (!(data[0] === 0 && data[1] === 0 && data[2] === 0 && data[3] === 255)) {\n    throw new Error(\"Backdrop fill not correctly applied\");\n  }\n});",
    "i4_llama-3.3-70b-versatile": "it(\"should correctly apply the backdrop fill when mask extension occurs\", async () => {\n  const { Util } = await import(\"../../src/shared/util.js\");\n  const { CanvasGraphics } = await import(\"../../src/display/canvas.js\");\n  const { DefaultCanvasFactory } = await import(\"../../src/display/api.js\");\n  const factory = new DefaultCanvasFactory();\n  const maskObj = factory.create(70, 50);\n  const layerObj = factory.create(50, 50);\n  const maskCtx = maskObj.context;\n  const layerCtx = layerObj.context;\n  maskCtx.fillStyle = \"#ffffff\";\n  maskCtx.fillRect(0, 0, 70, 50);\n  const dummyFilterFactory = { addAlphaFilter: () => \"\" , addLuminosityFilter: () => \"\" };\n  const cg = new CanvasGraphics(layerCtx, {}, {}, factory, dummyFilterFactory, {}, null);\n  const backdrop = [0, 0, 0];\n  // Setting layerOffsetX=0 and maskOffsetX=10 forces maskX = -10 (mask extension branch)\n  cg.genericComposeSMask(maskCtx, layerCtx, 50, 50, \"Alpha\", backdrop, null, 0, 0, 10, 0);\n  const { data } = layerCtx.getImageData(25, 25, 1, 1);\n  if (!(data[0] === 0 && data[1] === 0 && data[2] === 0 && data[3] === 255)) {\n    throw new Error(\"Backdrop fill not correctly applied\");\n  }\n});",
    "i5_deepseek-r1-distill-llama-70b": "it(\"should correctly apply the backdrop fill when mask extension occurs\", async () => {\n  const { Util } = await import(\"../../src/shared/util.js\");\n  const { CanvasGraphics } = await import(\"../../src/display/canvas.js\");\n  const { DefaultCanvasFactory } = await import(\"../../src/display/api.js\");\n  const factory = new DefaultCanvasFactory();\n  const maskObj = factory.create(70, 50);\n  const layerObj = factory.create(50, 50);\n  const maskCtx = maskObj.context;\n  const layerCtx = layerObj.context;\n  maskCtx.fillStyle = \"#ffffff\";\n  maskCtx.fillRect(0, 0, 70, 50);\n  const dummyFilterFactory = { addAlphaFilter: () => \"\" , addLuminosityFilter: () => \"\" };\n  const cg = new CanvasGraphics(layerCtx, {}, {}, factory, dummyFilterFactory, {}, null);\n  const backdrop = [0, 0, 0];\n  // Setting layerOffsetX=0 and maskOffsetX=10 forces maskX = -10 (mask extension branch)\n  cg.genericComposeSMask(maskCtx, layerCtx, 50, 50, \"Alpha\", backdrop, null, 0, 0, 10, 0);\n  const { data } = layerCtx.getImageData(25, 25, 1, 1);\n  if (!(data[0] === 0 && data[1] === 0 && data[2] === 0 && data[3] === 255)) {\n    throw new Error(\"Backdrop fill not correctly applied\");\n  }\n});",
    "i5_gpt-4o": "it(\"should correctly apply the backdrop fill when mask extension occurs\", async () => {\n  const { Util } = await import(\"../../src/shared/util.js\");\n  const { CanvasGraphics } = await import(\"../../src/display/canvas.js\");\n  const { DefaultCanvasFactory } = await import(\"../../src/display/api.js\");\n  const factory = new DefaultCanvasFactory();\n  const maskObj = factory.create(70, 50);\n  const layerObj = factory.create(50, 50);\n  const maskCtx = maskObj.context;\n  const layerCtx = layerObj.context;\n  maskCtx.fillStyle = \"#ffffff\";\n  maskCtx.fillRect(0, 0, 70, 50);\n  const dummyFilterFactory = { addAlphaFilter: () => \"\" , addLuminosityFilter: () => \"\" };\n  const cg = new CanvasGraphics(layerCtx, {}, {}, factory, dummyFilterFactory, {}, null);\n  const backdrop = [0, 0, 0];\n  // Setting layerOffsetX=0 and maskOffsetX=10 forces maskX = -10 (mask extension branch)\n  cg.genericComposeSMask(maskCtx, layerCtx, 50, 50, \"Alpha\", backdrop, null, 0, 0, 10, 0);\n  const { data } = layerCtx.getImageData(25, 25, 1, 1);\n  if (!(data[0] === 0 && data[1] === 0 && data[2] === 0 && data[3] === 255)) {\n    throw new Error(\"Backdrop fill not correctly applied\");\n  }\n});",
    "i5_llama-3.3-70b-versatile": "it(\"should correctly apply the backdrop fill when mask extension occurs\", async () => {\n  const { Util } = await import(\"../../src/shared/util.js\");\n  const { CanvasGraphics } = await import(\"../../src/display/canvas.js\");\n  const { DefaultCanvasFactory } = await import(\"../../src/display/api.js\");\n  const factory = new DefaultCanvasFactory();\n  const maskObj = factory.create(70, 50);\n  const layerObj = factory.create(50, 50);\n  const maskCtx = maskObj.context;\n  const layerCtx = layerObj.context;\n  maskCtx.fillStyle = \"#ffffff\";\n  maskCtx.fillRect(0, 0, 70, 50);\n  const dummyFilterFactory = { addAlphaFilter: () => \"\" , addLuminosityFilter: () => \"\" };\n  const cg = new CanvasGraphics(layerCtx, {}, {}, factory, dummyFilterFactory, {}, null);\n  const backdrop = [0, 0, 0];\n  // Setting layerOffsetX=0 and maskOffsetX=10 forces maskX = -10 (mask extension branch)\n  cg.genericComposeSMask(maskCtx, layerCtx, 50, 50, \"Alpha\", backdrop, null, 0, 0, 10, 0);\n  const { data } = layerCtx.getImageData(25, 25, 1, 1);\n  if (!(data[0] === 0 && data[1] === 0 && data[2] === 0 && data[3] === 255)) {\n    throw new Error(\"Backdrop fill not correctly applied\");\n  }\n});"
  },
  "19023": {
    "i1_deepseek-r1-distill-llama-70b": "it(\"should apply gradient when stroking text\", async () => {\n  const { DefaultCanvasFactory } = await import(\"../../src/display/api.js\");\n  const { CanvasGraphics, TextRenderingMode } = await import(\"../../src/display/canvas.js\");\n  const { getTopLeftPixel } = await import(\"./test_utils.js\");\n  const canvasFactory = new DefaultCanvasFactory();\n  const { canvas, context } = canvasFactory.create(100, 100);\n  // Fill background white.\n  context.fillStyle = \"white\";\n  context.fillRect(0, 0, 100, 100);\n  // Create a fake strokeColor that returns a linear gradient.\n  const fakeStrokeColor = {\n    getPattern: (ctx) => {\n      const grad = ctx.createLinearGradient(10, 10, 90, 10);\n      grad.addColorStop(0, \"blue\");\n      grad.addColorStop(1, \"red\");\n      return grad;\n    }\n  };\n  // Create a fake font object that draws a simple rectangle path.\n  const fakeFont = {\n    missingFile: false,\n    disableFontFace: false,\n    getPathGenerator: () => {\n      return (ctx, size) => {\n        // Draw a rectangle representing the glyph outline.\n        ctx.rect(10, 10, 80, 80);\n      };\n    }\n  };\n  // Create a CanvasGraphics instance.\n  const cg = new CanvasGraphics(context, {}, {});\n  // Configure the graphics state to use stroke mode with a gradient.\n  cg.current.font = fakeFont;\n  cg.current.fontSize = 50;\n  cg.current.fontSizeScale = 1;\n  cg.current.textRenderingMode = TextRenderingMode.STROKE;\n  cg.current.lineWidth = 10;\n  cg.current.patternStroke = true;\n  cg.current.strokeColor = fakeStrokeColor;\n  // Render a fake glyph.\n  cg.showText([{ fontChar: \"A\", width: 500 }]);\n  // Extract a pixel from the stroked area.\n  const pixelData = context.getImageData(15, 15, 1, 1).data;\n  // Pre-patch, the stroke would be rendered as black; post-patch, the gradient is applied.\n  if (pixelData[0] === 0 && pixelData[1] === 0 && pixelData[2] === 0) {\n    throw new Error(\"Gradient stroke not applied\");\n  }\n});",
    "i1_gpt-4o": "it(\"should apply gradient when stroking text\", async () => {\n  const { DefaultCanvasFactory } = await import(\"../../src/display/api.js\");\n  const { CanvasGraphics, TextRenderingMode } = await import(\"../../src/display/canvas.js\");\n  const { getTopLeftPixel } = await import(\"./test_utils.js\");\n  const canvasFactory = new DefaultCanvasFactory();\n  const { canvas, context } = canvasFactory.create(100, 100);\n  // Fill background white.\n  context.fillStyle = \"white\";\n  context.fillRect(0, 0, 100, 100);\n  // Create a fake strokeColor that returns a linear gradient.\n  const fakeStrokeColor = {\n    getPattern: (ctx) => {\n      const grad = ctx.createLinearGradient(10, 10, 90, 10);\n      grad.addColorStop(0, \"blue\");\n      grad.addColorStop(1, \"red\");\n      return grad;\n    }\n  };\n  // Create a fake font object that draws a simple rectangle path.\n  const fakeFont = {\n    missingFile: false,\n    disableFontFace: false,\n    getPathGenerator: () => {\n      return (ctx, size) => {\n        // Draw a rectangle representing the glyph outline.\n        ctx.rect(10, 10, 80, 80);\n      };\n    }\n  };\n  // Create a CanvasGraphics instance.\n  const cg = new CanvasGraphics(context, {}, {});\n  // Configure the graphics state to use stroke mode with a gradient.\n  cg.current.font = fakeFont;\n  cg.current.fontSize = 50;\n  cg.current.fontSizeScale = 1;\n  cg.current.textRenderingMode = TextRenderingMode.STROKE;\n  cg.current.lineWidth = 10;\n  cg.current.patternStroke = true;\n  cg.current.strokeColor = fakeStrokeColor;\n  // Render a fake glyph.\n  cg.showText([{ fontChar: \"A\", width: 500 }]);\n  // Extract a pixel from the stroked area.\n  const pixelData = context.getImageData(15, 15, 1, 1).data;\n  // Pre-patch, the stroke would be rendered as black; post-patch, the gradient is applied.\n  if (pixelData[0] === 0 && pixelData[1] === 0 && pixelData[2] === 0) {\n    throw new Error(\"Gradient stroke not applied\");\n  }\n});",
    "i1_llama-3.3-70b-versatile": "it(\"should apply gradient when stroking text\", async () => {\n  const { DefaultCanvasFactory } = await import(\"../../src/display/api.js\");\n  const { CanvasGraphics, TextRenderingMode } = await import(\"../../src/display/canvas.js\");\n  const { getTopLeftPixel } = await import(\"./test_utils.js\");\n  const canvasFactory = new DefaultCanvasFactory();\n  const { canvas, context } = canvasFactory.create(100, 100);\n  // Fill background white.\n  context.fillStyle = \"white\";\n  context.fillRect(0, 0, 100, 100);\n  // Create a fake strokeColor that returns a linear gradient.\n  const fakeStrokeColor = {\n    getPattern: (ctx) => {\n      const grad = ctx.createLinearGradient(10, 10, 90, 10);\n      grad.addColorStop(0, \"blue\");\n      grad.addColorStop(1, \"red\");\n      return grad;\n    }\n  };\n  // Create a fake font object that draws a simple rectangle path.\n  const fakeFont = {\n    missingFile: false,\n    disableFontFace: false,\n    getPathGenerator: () => {\n      return (ctx, size) => {\n        // Draw a rectangle representing the glyph outline.\n        ctx.rect(10, 10, 80, 80);\n      };\n    }\n  };\n  // Create a CanvasGraphics instance.\n  const cg = new CanvasGraphics(context, {}, {});\n  // Configure the graphics state to use stroke mode with a gradient.\n  cg.current.font = fakeFont;\n  cg.current.fontSize = 50;\n  cg.current.fontSizeScale = 1;\n  cg.current.textRenderingMode = TextRenderingMode.STROKE;\n  cg.current.lineWidth = 10;\n  cg.current.patternStroke = true;\n  cg.current.strokeColor = fakeStrokeColor;\n  // Render a fake glyph.\n  cg.showText([{ fontChar: \"A\", width: 500 }]);\n  // Extract a pixel from the stroked area.\n  const pixelData = context.getImageData(15, 15, 1, 1).data;\n  // Pre-patch, the stroke would be rendered as black; post-patch, the gradient is applied.\n  if (pixelData[0] === 0 && pixelData[1] === 0 && pixelData[2] === 0) {\n    throw new Error(\"Gradient stroke not applied\");\n  }\n});",
    "i1_MOCK": "it(\"should apply gradient when stroking text\", async () => {\n  const { DefaultCanvasFactory } = await import(\"../../src/display/api.js\");\n  const { CanvasGraphics, TextRenderingMode } = await import(\"../../src/display/canvas.js\");\n  const { getTopLeftPixel } = await import(\"./test_utils.js\");\n  const canvasFactory = new DefaultCanvasFactory();\n  const { canvas, context } = canvasFactory.create(100, 100);\n  // Fill background white.\n  context.fillStyle = \"white\";\n  context.fillRect(0, 0, 100, 100);\n  // Create a fake strokeColor that returns a linear gradient.\n  const fakeStrokeColor = {\n    getPattern: (ctx) => {\n      const grad = ctx.createLinearGradient(10, 10, 90, 10);\n      grad.addColorStop(0, \"blue\");\n      grad.addColorStop(1, \"red\");\n      return grad;\n    }\n  };\n  // Create a fake font object that draws a simple rectangle path.\n  const fakeFont = {\n    missingFile: false,\n    disableFontFace: false,\n    getPathGenerator: () => {\n      return (ctx, size) => {\n        // Draw a rectangle representing the glyph outline.\n        ctx.rect(10, 10, 80, 80);\n      };\n    }\n  };\n  // Create a CanvasGraphics instance.\n  const cg = new CanvasGraphics(context, {}, {});\n  // Configure the graphics state to use stroke mode with a gradient.\n  cg.current.font = fakeFont;\n  cg.current.fontSize = 50;\n  cg.current.fontSizeScale = 1;\n  cg.current.textRenderingMode = TextRenderingMode.STROKE;\n  cg.current.lineWidth = 10;\n  cg.current.patternStroke = true;\n  cg.current.strokeColor = fakeStrokeColor;\n  // Render a fake glyph.\n  cg.showText([{ fontChar: \"A\", width: 500 }]);\n  // Extract a pixel from the stroked area.\n  const pixelData = context.getImageData(15, 15, 1, 1).data;\n  // Pre-patch, the stroke would be rendered as black; post-patch, the gradient is applied.\n  if (pixelData[0] === 0 && pixelData[1] === 0 && pixelData[2] === 0) {\n    throw new Error(\"Gradient stroke not applied\");\n  }\n});",
    "i2_deepseek-r1-distill-llama-70b": "it(\"should apply gradient when stroking text\", async () => {\n  const { DefaultCanvasFactory } = await import(\"../../src/display/api.js\");\n  const { CanvasGraphics, TextRenderingMode } = await import(\"../../src/display/canvas.js\");\n  const { getTopLeftPixel } = await import(\"./test_utils.js\");\n  const canvasFactory = new DefaultCanvasFactory();\n  const { canvas, context } = canvasFactory.create(100, 100);\n  // Fill background white.\n  context.fillStyle = \"white\";\n  context.fillRect(0, 0, 100, 100);\n  // Create a fake strokeColor that returns a linear gradient.\n  const fakeStrokeColor = {\n    getPattern: (ctx) => {\n      const grad = ctx.createLinearGradient(10, 10, 90, 10);\n      grad.addColorStop(0, \"blue\");\n      grad.addColorStop(1, \"red\");\n      return grad;\n    }\n  };\n  // Create a fake font object that draws a simple rectangle path.\n  const fakeFont = {\n    missingFile: false,\n    disableFontFace: false,\n    getPathGenerator: () => {\n      return (ctx, size) => {\n        // Draw a rectangle representing the glyph outline.\n        ctx.rect(10, 10, 80, 80);\n      };\n    }\n  };\n  // Create a CanvasGraphics instance.\n  const cg = new CanvasGraphics(context, {}, {});\n  // Configure the graphics state to use stroke mode with a gradient.\n  cg.current.font = fakeFont;\n  cg.current.fontSize = 50;\n  cg.current.fontSizeScale = 1;\n  cg.current.textRenderingMode = TextRenderingMode.STROKE;\n  cg.current.lineWidth = 10;\n  cg.current.patternStroke = true;\n  cg.current.strokeColor = fakeStrokeColor;\n  // Render a fake glyph.\n  cg.showText([{ fontChar: \"A\", width: 500 }]);\n  // Extract a pixel from the stroked area.\n  const pixelData = context.getImageData(15, 15, 1, 1).data;\n  // Pre-patch, the stroke would be rendered as black; post-patch, the gradient is applied.\n  if (pixelData[0] === 0 && pixelData[1] === 0 && pixelData[2] === 0) {\n    throw new Error(\"Gradient stroke not applied\");\n  }\n});",
    "i2_gpt-4o": "it(\"should apply gradient when stroking text\", async () => {\n  const { DefaultCanvasFactory } = await import(\"../../src/display/api.js\");\n  const { CanvasGraphics, TextRenderingMode } = await import(\"../../src/display/canvas.js\");\n  const { getTopLeftPixel } = await import(\"./test_utils.js\");\n  const canvasFactory = new DefaultCanvasFactory();\n  const { canvas, context } = canvasFactory.create(100, 100);\n  // Fill background white.\n  context.fillStyle = \"white\";\n  context.fillRect(0, 0, 100, 100);\n  // Create a fake strokeColor that returns a linear gradient.\n  const fakeStrokeColor = {\n    getPattern: (ctx) => {\n      const grad = ctx.createLinearGradient(10, 10, 90, 10);\n      grad.addColorStop(0, \"blue\");\n      grad.addColorStop(1, \"red\");\n      return grad;\n    }\n  };\n  // Create a fake font object that draws a simple rectangle path.\n  const fakeFont = {\n    missingFile: false,\n    disableFontFace: false,\n    getPathGenerator: () => {\n      return (ctx, size) => {\n        // Draw a rectangle representing the glyph outline.\n        ctx.rect(10, 10, 80, 80);\n      };\n    }\n  };\n  // Create a CanvasGraphics instance.\n  const cg = new CanvasGraphics(context, {}, {});\n  // Configure the graphics state to use stroke mode with a gradient.\n  cg.current.font = fakeFont;\n  cg.current.fontSize = 50;\n  cg.current.fontSizeScale = 1;\n  cg.current.textRenderingMode = TextRenderingMode.STROKE;\n  cg.current.lineWidth = 10;\n  cg.current.patternStroke = true;\n  cg.current.strokeColor = fakeStrokeColor;\n  // Render a fake glyph.\n  cg.showText([{ fontChar: \"A\", width: 500 }]);\n  // Extract a pixel from the stroked area.\n  const pixelData = context.getImageData(15, 15, 1, 1).data;\n  // Pre-patch, the stroke would be rendered as black; post-patch, the gradient is applied.\n  if (pixelData[0] === 0 && pixelData[1] === 0 && pixelData[2] === 0) {\n    throw new Error(\"Gradient stroke not applied\");\n  }\n});",
    "i2_llama-3.3-70b-versatile": "it(\"should apply gradient when stroking text\", async () => {\n  const { DefaultCanvasFactory } = await import(\"../../src/display/api.js\");\n  const { CanvasGraphics, TextRenderingMode } = await import(\"../../src/display/canvas.js\");\n  const { getTopLeftPixel } = await import(\"./test_utils.js\");\n  const canvasFactory = new DefaultCanvasFactory();\n  const { canvas, context } = canvasFactory.create(100, 100);\n  // Fill background white.\n  context.fillStyle = \"white\";\n  context.fillRect(0, 0, 100, 100);\n  // Create a fake strokeColor that returns a linear gradient.\n  const fakeStrokeColor = {\n    getPattern: (ctx) => {\n      const grad = ctx.createLinearGradient(10, 10, 90, 10);\n      grad.addColorStop(0, \"blue\");\n      grad.addColorStop(1, \"red\");\n      return grad;\n    }\n  };\n  // Create a fake font object that draws a simple rectangle path.\n  const fakeFont = {\n    missingFile: false,\n    disableFontFace: false,\n    getPathGenerator: () => {\n      return (ctx, size) => {\n        // Draw a rectangle representing the glyph outline.\n        ctx.rect(10, 10, 80, 80);\n      };\n    }\n  };\n  // Create a CanvasGraphics instance.\n  const cg = new CanvasGraphics(context, {}, {});\n  // Configure the graphics state to use stroke mode with a gradient.\n  cg.current.font = fakeFont;\n  cg.current.fontSize = 50;\n  cg.current.fontSizeScale = 1;\n  cg.current.textRenderingMode = TextRenderingMode.STROKE;\n  cg.current.lineWidth = 10;\n  cg.current.patternStroke = true;\n  cg.current.strokeColor = fakeStrokeColor;\n  // Render a fake glyph.\n  cg.showText([{ fontChar: \"A\", width: 500 }]);\n  // Extract a pixel from the stroked area.\n  const pixelData = context.getImageData(15, 15, 1, 1).data;\n  // Pre-patch, the stroke would be rendered as black; post-patch, the gradient is applied.\n  if (pixelData[0] === 0 && pixelData[1] === 0 && pixelData[2] === 0) {\n    throw new Error(\"Gradient stroke not applied\");\n  }\n});",
    "i3_deepseek-r1-distill-llama-70b": "it(\"should apply gradient when stroking text\", async () => {\n  const { DefaultCanvasFactory } = await import(\"../../src/display/api.js\");\n  const { CanvasGraphics, TextRenderingMode } = await import(\"../../src/display/canvas.js\");\n  const { getTopLeftPixel } = await import(\"./test_utils.js\");\n  const canvasFactory = new DefaultCanvasFactory();\n  const { canvas, context } = canvasFactory.create(100, 100);\n  // Fill background white.\n  context.fillStyle = \"white\";\n  context.fillRect(0, 0, 100, 100);\n  // Create a fake strokeColor that returns a linear gradient.\n  const fakeStrokeColor = {\n    getPattern: (ctx) => {\n      const grad = ctx.createLinearGradient(10, 10, 90, 10);\n      grad.addColorStop(0, \"blue\");\n      grad.addColorStop(1, \"red\");\n      return grad;\n    }\n  };\n  // Create a fake font object that draws a simple rectangle path.\n  const fakeFont = {\n    missingFile: false,\n    disableFontFace: false,\n    getPathGenerator: () => {\n      return (ctx, size) => {\n        // Draw a rectangle representing the glyph outline.\n        ctx.rect(10, 10, 80, 80);\n      };\n    }\n  };\n  // Create a CanvasGraphics instance.\n  const cg = new CanvasGraphics(context, {}, {});\n  // Configure the graphics state to use stroke mode with a gradient.\n  cg.current.font = fakeFont;\n  cg.current.fontSize = 50;\n  cg.current.fontSizeScale = 1;\n  cg.current.textRenderingMode = TextRenderingMode.STROKE;\n  cg.current.lineWidth = 10;\n  cg.current.patternStroke = true;\n  cg.current.strokeColor = fakeStrokeColor;\n  // Render a fake glyph.\n  cg.showText([{ fontChar: \"A\", width: 500 }]);\n  // Extract a pixel from the stroked area.\n  const pixelData = context.getImageData(15, 15, 1, 1).data;\n  // Pre-patch, the stroke would be rendered as black; post-patch, the gradient is applied.\n  if (pixelData[0] === 0 && pixelData[1] === 0 && pixelData[2] === 0) {\n    throw new Error(\"Gradient stroke not applied\");\n  }\n});",
    "i3_gpt-4o": "it(\"should apply gradient when stroking text\", async () => {\n  const { DefaultCanvasFactory } = await import(\"../../src/display/api.js\");\n  const { CanvasGraphics, TextRenderingMode } = await import(\"../../src/display/canvas.js\");\n  const { getTopLeftPixel } = await import(\"./test_utils.js\");\n  const canvasFactory = new DefaultCanvasFactory();\n  const { canvas, context } = canvasFactory.create(100, 100);\n  // Fill background white.\n  context.fillStyle = \"white\";\n  context.fillRect(0, 0, 100, 100);\n  // Create a fake strokeColor that returns a linear gradient.\n  const fakeStrokeColor = {\n    getPattern: (ctx) => {\n      const grad = ctx.createLinearGradient(10, 10, 90, 10);\n      grad.addColorStop(0, \"blue\");\n      grad.addColorStop(1, \"red\");\n      return grad;\n    }\n  };\n  // Create a fake font object that draws a simple rectangle path.\n  const fakeFont = {\n    missingFile: false,\n    disableFontFace: false,\n    getPathGenerator: () => {\n      return (ctx, size) => {\n        // Draw a rectangle representing the glyph outline.\n        ctx.rect(10, 10, 80, 80);\n      };\n    }\n  };\n  // Create a CanvasGraphics instance.\n  const cg = new CanvasGraphics(context, {}, {});\n  // Configure the graphics state to use stroke mode with a gradient.\n  cg.current.font = fakeFont;\n  cg.current.fontSize = 50;\n  cg.current.fontSizeScale = 1;\n  cg.current.textRenderingMode = TextRenderingMode.STROKE;\n  cg.current.lineWidth = 10;\n  cg.current.patternStroke = true;\n  cg.current.strokeColor = fakeStrokeColor;\n  // Render a fake glyph.\n  cg.showText([{ fontChar: \"A\", width: 500 }]);\n  // Extract a pixel from the stroked area.\n  const pixelData = context.getImageData(15, 15, 1, 1).data;\n  // Pre-patch, the stroke would be rendered as black; post-patch, the gradient is applied.\n  if (pixelData[0] === 0 && pixelData[1] === 0 && pixelData[2] === 0) {\n    throw new Error(\"Gradient stroke not applied\");\n  }\n});",
    "i3_llama-3.3-70b-versatile": "it(\"should apply gradient when stroking text\", async () => {\n  const { DefaultCanvasFactory } = await import(\"../../src/display/api.js\");\n  const { CanvasGraphics, TextRenderingMode } = await import(\"../../src/display/canvas.js\");\n  const { getTopLeftPixel } = await import(\"./test_utils.js\");\n  const canvasFactory = new DefaultCanvasFactory();\n  const { canvas, context } = canvasFactory.create(100, 100);\n  // Fill background white.\n  context.fillStyle = \"white\";\n  context.fillRect(0, 0, 100, 100);\n  // Create a fake strokeColor that returns a linear gradient.\n  const fakeStrokeColor = {\n    getPattern: (ctx) => {\n      const grad = ctx.createLinearGradient(10, 10, 90, 10);\n      grad.addColorStop(0, \"blue\");\n      grad.addColorStop(1, \"red\");\n      return grad;\n    }\n  };\n  // Create a fake font object that draws a simple rectangle path.\n  const fakeFont = {\n    missingFile: false,\n    disableFontFace: false,\n    getPathGenerator: () => {\n      return (ctx, size) => {\n        // Draw a rectangle representing the glyph outline.\n        ctx.rect(10, 10, 80, 80);\n      };\n    }\n  };\n  // Create a CanvasGraphics instance.\n  const cg = new CanvasGraphics(context, {}, {});\n  // Configure the graphics state to use stroke mode with a gradient.\n  cg.current.font = fakeFont;\n  cg.current.fontSize = 50;\n  cg.current.fontSizeScale = 1;\n  cg.current.textRenderingMode = TextRenderingMode.STROKE;\n  cg.current.lineWidth = 10;\n  cg.current.patternStroke = true;\n  cg.current.strokeColor = fakeStrokeColor;\n  // Render a fake glyph.\n  cg.showText([{ fontChar: \"A\", width: 500 }]);\n  // Extract a pixel from the stroked area.\n  const pixelData = context.getImageData(15, 15, 1, 1).data;\n  // Pre-patch, the stroke would be rendered as black; post-patch, the gradient is applied.\n  if (pixelData[0] === 0 && pixelData[1] === 0 && pixelData[2] === 0) {\n    throw new Error(\"Gradient stroke not applied\");\n  }\n});",
    "i4_deepseek-r1-distill-llama-70b": "it(\"should apply gradient when stroking text\", async () => {\n  const { DefaultCanvasFactory } = await import(\"../../src/display/api.js\");\n  const { CanvasGraphics, TextRenderingMode } = await import(\"../../src/display/canvas.js\");\n  const { getTopLeftPixel } = await import(\"./test_utils.js\");\n  const canvasFactory = new DefaultCanvasFactory();\n  const { canvas, context } = canvasFactory.create(100, 100);\n  // Fill background white.\n  context.fillStyle = \"white\";\n  context.fillRect(0, 0, 100, 100);\n  // Create a fake strokeColor that returns a linear gradient.\n  const fakeStrokeColor = {\n    getPattern: (ctx) => {\n      const grad = ctx.createLinearGradient(10, 10, 90, 10);\n      grad.addColorStop(0, \"blue\");\n      grad.addColorStop(1, \"red\");\n      return grad;\n    }\n  };\n  // Create a fake font object that draws a simple rectangle path.\n  const fakeFont = {\n    missingFile: false,\n    disableFontFace: false,\n    getPathGenerator: () => {\n      return (ctx, size) => {\n        // Draw a rectangle representing the glyph outline.\n        ctx.rect(10, 10, 80, 80);\n      };\n    }\n  };\n  // Create a CanvasGraphics instance.\n  const cg = new CanvasGraphics(context, {}, {});\n  // Configure the graphics state to use stroke mode with a gradient.\n  cg.current.font = fakeFont;\n  cg.current.fontSize = 50;\n  cg.current.fontSizeScale = 1;\n  cg.current.textRenderingMode = TextRenderingMode.STROKE;\n  cg.current.lineWidth = 10;\n  cg.current.patternStroke = true;\n  cg.current.strokeColor = fakeStrokeColor;\n  // Render a fake glyph.\n  cg.showText([{ fontChar: \"A\", width: 500 }]);\n  // Extract a pixel from the stroked area.\n  const pixelData = context.getImageData(15, 15, 1, 1).data;\n  // Pre-patch, the stroke would be rendered as black; post-patch, the gradient is applied.\n  if (pixelData[0] === 0 && pixelData[1] === 0 && pixelData[2] === 0) {\n    throw new Error(\"Gradient stroke not applied\");\n  }\n});",
    "i4_gpt-4o": "it(\"should apply gradient when stroking text\", async () => {\n  const { DefaultCanvasFactory } = await import(\"../../src/display/api.js\");\n  const { CanvasGraphics, TextRenderingMode } = await import(\"../../src/display/canvas.js\");\n  const { getTopLeftPixel } = await import(\"./test_utils.js\");\n  const canvasFactory = new DefaultCanvasFactory();\n  const { canvas, context } = canvasFactory.create(100, 100);\n  // Fill background white.\n  context.fillStyle = \"white\";\n  context.fillRect(0, 0, 100, 100);\n  // Create a fake strokeColor that returns a linear gradient.\n  const fakeStrokeColor = {\n    getPattern: (ctx) => {\n      const grad = ctx.createLinearGradient(10, 10, 90, 10);\n      grad.addColorStop(0, \"blue\");\n      grad.addColorStop(1, \"red\");\n      return grad;\n    }\n  };\n  // Create a fake font object that draws a simple rectangle path.\n  const fakeFont = {\n    missingFile: false,\n    disableFontFace: false,\n    getPathGenerator: () => {\n      return (ctx, size) => {\n        // Draw a rectangle representing the glyph outline.\n        ctx.rect(10, 10, 80, 80);\n      };\n    }\n  };\n  // Create a CanvasGraphics instance.\n  const cg = new CanvasGraphics(context, {}, {});\n  // Configure the graphics state to use stroke mode with a gradient.\n  cg.current.font = fakeFont;\n  cg.current.fontSize = 50;\n  cg.current.fontSizeScale = 1;\n  cg.current.textRenderingMode = TextRenderingMode.STROKE;\n  cg.current.lineWidth = 10;\n  cg.current.patternStroke = true;\n  cg.current.strokeColor = fakeStrokeColor;\n  // Render a fake glyph.\n  cg.showText([{ fontChar: \"A\", width: 500 }]);\n  // Extract a pixel from the stroked area.\n  const pixelData = context.getImageData(15, 15, 1, 1).data;\n  // Pre-patch, the stroke would be rendered as black; post-patch, the gradient is applied.\n  if (pixelData[0] === 0 && pixelData[1] === 0 && pixelData[2] === 0) {\n    throw new Error(\"Gradient stroke not applied\");\n  }\n});",
    "i4_llama-3.3-70b-versatile": "it(\"should apply gradient when stroking text\", async () => {\n  const { DefaultCanvasFactory } = await import(\"../../src/display/api.js\");\n  const { CanvasGraphics, TextRenderingMode } = await import(\"../../src/display/canvas.js\");\n  const { getTopLeftPixel } = await import(\"./test_utils.js\");\n  const canvasFactory = new DefaultCanvasFactory();\n  const { canvas, context } = canvasFactory.create(100, 100);\n  // Fill background white.\n  context.fillStyle = \"white\";\n  context.fillRect(0, 0, 100, 100);\n  // Create a fake strokeColor that returns a linear gradient.\n  const fakeStrokeColor = {\n    getPattern: (ctx) => {\n      const grad = ctx.createLinearGradient(10, 10, 90, 10);\n      grad.addColorStop(0, \"blue\");\n      grad.addColorStop(1, \"red\");\n      return grad;\n    }\n  };\n  // Create a fake font object that draws a simple rectangle path.\n  const fakeFont = {\n    missingFile: false,\n    disableFontFace: false,\n    getPathGenerator: () => {\n      return (ctx, size) => {\n        // Draw a rectangle representing the glyph outline.\n        ctx.rect(10, 10, 80, 80);\n      };\n    }\n  };\n  // Create a CanvasGraphics instance.\n  const cg = new CanvasGraphics(context, {}, {});\n  // Configure the graphics state to use stroke mode with a gradient.\n  cg.current.font = fakeFont;\n  cg.current.fontSize = 50;\n  cg.current.fontSizeScale = 1;\n  cg.current.textRenderingMode = TextRenderingMode.STROKE;\n  cg.current.lineWidth = 10;\n  cg.current.patternStroke = true;\n  cg.current.strokeColor = fakeStrokeColor;\n  // Render a fake glyph.\n  cg.showText([{ fontChar: \"A\", width: 500 }]);\n  // Extract a pixel from the stroked area.\n  const pixelData = context.getImageData(15, 15, 1, 1).data;\n  // Pre-patch, the stroke would be rendered as black; post-patch, the gradient is applied.\n  if (pixelData[0] === 0 && pixelData[1] === 0 && pixelData[2] === 0) {\n    throw new Error(\"Gradient stroke not applied\");\n  }\n});",
    "i5_deepseek-r1-distill-llama-70b": "it(\"should apply gradient when stroking text\", async () => {\n  const { DefaultCanvasFactory } = await import(\"../../src/display/api.js\");\n  const { CanvasGraphics, TextRenderingMode } = await import(\"../../src/display/canvas.js\");\n  const { getTopLeftPixel } = await import(\"./test_utils.js\");\n  const canvasFactory = new DefaultCanvasFactory();\n  const { canvas, context } = canvasFactory.create(100, 100);\n  // Fill background white.\n  context.fillStyle = \"white\";\n  context.fillRect(0, 0, 100, 100);\n  // Create a fake strokeColor that returns a linear gradient.\n  const fakeStrokeColor = {\n    getPattern: (ctx) => {\n      const grad = ctx.createLinearGradient(10, 10, 90, 10);\n      grad.addColorStop(0, \"blue\");\n      grad.addColorStop(1, \"red\");\n      return grad;\n    }\n  };\n  // Create a fake font object that draws a simple rectangle path.\n  const fakeFont = {\n    missingFile: false,\n    disableFontFace: false,\n    getPathGenerator: () => {\n      return (ctx, size) => {\n        // Draw a rectangle representing the glyph outline.\n        ctx.rect(10, 10, 80, 80);\n      };\n    }\n  };\n  // Create a CanvasGraphics instance.\n  const cg = new CanvasGraphics(context, {}, {});\n  // Configure the graphics state to use stroke mode with a gradient.\n  cg.current.font = fakeFont;\n  cg.current.fontSize = 50;\n  cg.current.fontSizeScale = 1;\n  cg.current.textRenderingMode = TextRenderingMode.STROKE;\n  cg.current.lineWidth = 10;\n  cg.current.patternStroke = true;\n  cg.current.strokeColor = fakeStrokeColor;\n  // Render a fake glyph.\n  cg.showText([{ fontChar: \"A\", width: 500 }]);\n  // Extract a pixel from the stroked area.\n  const pixelData = context.getImageData(15, 15, 1, 1).data;\n  // Pre-patch, the stroke would be rendered as black; post-patch, the gradient is applied.\n  if (pixelData[0] === 0 && pixelData[1] === 0 && pixelData[2] === 0) {\n    throw new Error(\"Gradient stroke not applied\");\n  }\n});",
    "i5_gpt-4o": "it(\"should apply gradient when stroking text\", async () => {\n  const { DefaultCanvasFactory } = await import(\"../../src/display/api.js\");\n  const { CanvasGraphics, TextRenderingMode } = await import(\"../../src/display/canvas.js\");\n  const { getTopLeftPixel } = await import(\"./test_utils.js\");\n  const canvasFactory = new DefaultCanvasFactory();\n  const { canvas, context } = canvasFactory.create(100, 100);\n  // Fill background white.\n  context.fillStyle = \"white\";\n  context.fillRect(0, 0, 100, 100);\n  // Create a fake strokeColor that returns a linear gradient.\n  const fakeStrokeColor = {\n    getPattern: (ctx) => {\n      const grad = ctx.createLinearGradient(10, 10, 90, 10);\n      grad.addColorStop(0, \"blue\");\n      grad.addColorStop(1, \"red\");\n      return grad;\n    }\n  };\n  // Create a fake font object that draws a simple rectangle path.\n  const fakeFont = {\n    missingFile: false,\n    disableFontFace: false,\n    getPathGenerator: () => {\n      return (ctx, size) => {\n        // Draw a rectangle representing the glyph outline.\n        ctx.rect(10, 10, 80, 80);\n      };\n    }\n  };\n  // Create a CanvasGraphics instance.\n  const cg = new CanvasGraphics(context, {}, {});\n  // Configure the graphics state to use stroke mode with a gradient.\n  cg.current.font = fakeFont;\n  cg.current.fontSize = 50;\n  cg.current.fontSizeScale = 1;\n  cg.current.textRenderingMode = TextRenderingMode.STROKE;\n  cg.current.lineWidth = 10;\n  cg.current.patternStroke = true;\n  cg.current.strokeColor = fakeStrokeColor;\n  // Render a fake glyph.\n  cg.showText([{ fontChar: \"A\", width: 500 }]);\n  // Extract a pixel from the stroked area.\n  const pixelData = context.getImageData(15, 15, 1, 1).data;\n  // Pre-patch, the stroke would be rendered as black; post-patch, the gradient is applied.\n  if (pixelData[0] === 0 && pixelData[1] === 0 && pixelData[2] === 0) {\n    throw new Error(\"Gradient stroke not applied\");\n  }\n});",
    "i5_llama-3.3-70b-versatile": "it(\"should apply gradient when stroking text\", async () => {\n  const { DefaultCanvasFactory } = await import(\"../../src/display/api.js\");\n  const { CanvasGraphics, TextRenderingMode } = await import(\"../../src/display/canvas.js\");\n  const { getTopLeftPixel } = await import(\"./test_utils.js\");\n  const canvasFactory = new DefaultCanvasFactory();\n  const { canvas, context } = canvasFactory.create(100, 100);\n  // Fill background white.\n  context.fillStyle = \"white\";\n  context.fillRect(0, 0, 100, 100);\n  // Create a fake strokeColor that returns a linear gradient.\n  const fakeStrokeColor = {\n    getPattern: (ctx) => {\n      const grad = ctx.createLinearGradient(10, 10, 90, 10);\n      grad.addColorStop(0, \"blue\");\n      grad.addColorStop(1, \"red\");\n      return grad;\n    }\n  };\n  // Create a fake font object that draws a simple rectangle path.\n  const fakeFont = {\n    missingFile: false,\n    disableFontFace: false,\n    getPathGenerator: () => {\n      return (ctx, size) => {\n        // Draw a rectangle representing the glyph outline.\n        ctx.rect(10, 10, 80, 80);\n      };\n    }\n  };\n  // Create a CanvasGraphics instance.\n  const cg = new CanvasGraphics(context, {}, {});\n  // Configure the graphics state to use stroke mode with a gradient.\n  cg.current.font = fakeFont;\n  cg.current.fontSize = 50;\n  cg.current.fontSizeScale = 1;\n  cg.current.textRenderingMode = TextRenderingMode.STROKE;\n  cg.current.lineWidth = 10;\n  cg.current.patternStroke = true;\n  cg.current.strokeColor = fakeStrokeColor;\n  // Render a fake glyph.\n  cg.showText([{ fontChar: \"A\", width: 500 }]);\n  // Extract a pixel from the stroked area.\n  const pixelData = context.getImageData(15, 15, 1, 1).data;\n  // Pre-patch, the stroke would be rendered as black; post-patch, the gradient is applied.\n  if (pixelData[0] === 0 && pixelData[1] === 0 && pixelData[2] === 0) {\n    throw new Error(\"Gradient stroke not applied\");\n  }\n});"
  },
  "19086": {
    "i1_deepseek-r1-distill-llama-70b": "it(\"should populate options with fieldValue when no options are defined\", async () => {\n  const { ChoiceWidgetAnnotation } = await import(\"../../src/core/annotation.js\");\n  const { Dict } = await import(\"../../src/core/primitives.js\");\n  const dict = new Dict({});\n  const params = {\n    dict,\n    xref: { fetchIfRef: x => x },\n    data: { fieldValue: \"Account123\" }\n  };\n  const annot = new ChoiceWidgetAnnotation(params);\n  if (annot.data.options.length !== 1) {\n    throw new Error(\"Expected options to be populated from fieldValue.\");\n  }\n  const option = annot.data.options[0];\n  if (option.exportValue !== \"Account123\" || option.displayValue !== \"Account123\") {\n    throw new Error(\"Option values do not match fieldValue.\");\n  }\n});",
    "i1_gpt-4o": "it(\"should populate options with fieldValue when no options are defined\", async () => {\n  const { ChoiceWidgetAnnotation } = await import(\"../../src/core/annotation.js\");\n  const { Dict } = await import(\"../../src/core/primitives.js\");\n  const dict = new Dict({});\n  const params = {\n    dict,\n    xref: { fetchIfRef: x => x },\n    data: { fieldValue: \"Account123\" }\n  };\n  const annot = new ChoiceWidgetAnnotation(params);\n  if (annot.data.options.length !== 1) {\n    throw new Error(\"Expected options to be populated from fieldValue.\");\n  }\n  const option = annot.data.options[0];\n  if (option.exportValue !== \"Account123\" || option.displayValue !== \"Account123\") {\n    throw new Error(\"Option values do not match fieldValue.\");\n  }\n});",
    "i1_llama-3.3-70b-versatile": "it(\"should populate options with fieldValue when no options are defined\", async () => {\n  const { ChoiceWidgetAnnotation } = await import(\"../../src/core/annotation.js\");\n  const { Dict } = await import(\"../../src/core/primitives.js\");\n  const dict = new Dict({});\n  const params = {\n    dict,\n    xref: { fetchIfRef: x => x },\n    data: { fieldValue: \"Account123\" }\n  };\n  const annot = new ChoiceWidgetAnnotation(params);\n  if (annot.data.options.length !== 1) {\n    throw new Error(\"Expected options to be populated from fieldValue.\");\n  }\n  const option = annot.data.options[0];\n  if (option.exportValue !== \"Account123\" || option.displayValue !== \"Account123\") {\n    throw new Error(\"Option values do not match fieldValue.\");\n  }\n});",
    "i1_MOCK": "it(\"should populate options with fieldValue when no options are defined\", async () => {\n  const { ChoiceWidgetAnnotation } = await import(\"../../src/core/annotation.js\");\n  const { Dict } = await import(\"../../src/core/primitives.js\");\n  const dict = new Dict({});\n  const params = {\n    dict,\n    xref: { fetchIfRef: x => x },\n    data: { fieldValue: \"Account123\" }\n  };\n  const annot = new ChoiceWidgetAnnotation(params);\n  if (annot.data.options.length !== 1) {\n    throw new Error(\"Expected options to be populated from fieldValue.\");\n  }\n  const option = annot.data.options[0];\n  if (option.exportValue !== \"Account123\" || option.displayValue !== \"Account123\") {\n    throw new Error(\"Option values do not match fieldValue.\");\n  }\n});",
    "i2_deepseek-r1-distill-llama-70b": "it(\"should populate options with fieldValue when no options are defined\", async () => {\n  const { ChoiceWidgetAnnotation } = await import(\"../../src/core/annotation.js\");\n  const { Dict } = await import(\"../../src/core/primitives.js\");\n  const dict = new Dict({});\n  const params = {\n    dict,\n    xref: { fetchIfRef: x => x },\n    data: { fieldValue: \"Account123\" }\n  };\n  const annot = new ChoiceWidgetAnnotation(params);\n  if (annot.data.options.length !== 1) {\n    throw new Error(\"Expected options to be populated from fieldValue.\");\n  }\n  const option = annot.data.options[0];\n  if (option.exportValue !== \"Account123\" || option.displayValue !== \"Account123\") {\n    throw new Error(\"Option values do not match fieldValue.\");\n  }\n});",
    "i2_gpt-4o": "it(\"should populate options with fieldValue when no options are defined\", async () => {\n  const { ChoiceWidgetAnnotation } = await import(\"../../src/core/annotation.js\");\n  const { Dict } = await import(\"../../src/core/primitives.js\");\n  const dict = new Dict({});\n  const params = {\n    dict,\n    xref: { fetchIfRef: x => x },\n    data: { fieldValue: \"Account123\" }\n  };\n  const annot = new ChoiceWidgetAnnotation(params);\n  if (annot.data.options.length !== 1) {\n    throw new Error(\"Expected options to be populated from fieldValue.\");\n  }\n  const option = annot.data.options[0];\n  if (option.exportValue !== \"Account123\" || option.displayValue !== \"Account123\") {\n    throw new Error(\"Option values do not match fieldValue.\");\n  }\n});",
    "i2_llama-3.3-70b-versatile": "it(\"should populate options with fieldValue when no options are defined\", async () => {\n  const { ChoiceWidgetAnnotation } = await import(\"../../src/core/annotation.js\");\n  const { Dict } = await import(\"../../src/core/primitives.js\");\n  const dict = new Dict({});\n  const params = {\n    dict,\n    xref: { fetchIfRef: x => x },\n    data: { fieldValue: \"Account123\" }\n  };\n  const annot = new ChoiceWidgetAnnotation(params);\n  if (annot.data.options.length !== 1) {\n    throw new Error(\"Expected options to be populated from fieldValue.\");\n  }\n  const option = annot.data.options[0];\n  if (option.exportValue !== \"Account123\" || option.displayValue !== \"Account123\") {\n    throw new Error(\"Option values do not match fieldValue.\");\n  }\n});",
    "i3_deepseek-r1-distill-llama-70b": "it(\"should populate options with fieldValue when no options are defined\", async () => {\n  const { ChoiceWidgetAnnotation } = await import(\"../../src/core/annotation.js\");\n  const { Dict } = await import(\"../../src/core/primitives.js\");\n  const dict = new Dict({});\n  const params = {\n    dict,\n    xref: { fetchIfRef: x => x },\n    data: { fieldValue: \"Account123\" }\n  };\n  const annot = new ChoiceWidgetAnnotation(params);\n  if (annot.data.options.length !== 1) {\n    throw new Error(\"Expected options to be populated from fieldValue.\");\n  }\n  const option = annot.data.options[0];\n  if (option.exportValue !== \"Account123\" || option.displayValue !== \"Account123\") {\n    throw new Error(\"Option values do not match fieldValue.\");\n  }\n});",
    "i3_gpt-4o": "it(\"should populate options with fieldValue when no options are defined\", async () => {\n  const { ChoiceWidgetAnnotation } = await import(\"../../src/core/annotation.js\");\n  const { Dict } = await import(\"../../src/core/primitives.js\");\n  const dict = new Dict({});\n  const params = {\n    dict,\n    xref: { fetchIfRef: x => x },\n    data: { fieldValue: \"Account123\" }\n  };\n  const annot = new ChoiceWidgetAnnotation(params);\n  if (annot.data.options.length !== 1) {\n    throw new Error(\"Expected options to be populated from fieldValue.\");\n  }\n  const option = annot.data.options[0];\n  if (option.exportValue !== \"Account123\" || option.displayValue !== \"Account123\") {\n    throw new Error(\"Option values do not match fieldValue.\");\n  }\n});",
    "i3_llama-3.3-70b-versatile": "it(\"should populate options with fieldValue when no options are defined\", async () => {\n  const { ChoiceWidgetAnnotation } = await import(\"../../src/core/annotation.js\");\n  const { Dict } = await import(\"../../src/core/primitives.js\");\n  const dict = new Dict({});\n  const params = {\n    dict,\n    xref: { fetchIfRef: x => x },\n    data: { fieldValue: \"Account123\" }\n  };\n  const annot = new ChoiceWidgetAnnotation(params);\n  if (annot.data.options.length !== 1) {\n    throw new Error(\"Expected options to be populated from fieldValue.\");\n  }\n  const option = annot.data.options[0];\n  if (option.exportValue !== \"Account123\" || option.displayValue !== \"Account123\") {\n    throw new Error(\"Option values do not match fieldValue.\");\n  }\n});",
    "i4_deepseek-r1-distill-llama-70b": "it(\"should populate options with fieldValue when no options are defined\", async () => {\n  const { ChoiceWidgetAnnotation } = await import(\"../../src/core/annotation.js\");\n  const { Dict } = await import(\"../../src/core/primitives.js\");\n  const dict = new Dict({});\n  const params = {\n    dict,\n    xref: { fetchIfRef: x => x },\n    data: { fieldValue: \"Account123\" }\n  };\n  const annot = new ChoiceWidgetAnnotation(params);\n  if (annot.data.options.length !== 1) {\n    throw new Error(\"Expected options to be populated from fieldValue.\");\n  }\n  const option = annot.data.options[0];\n  if (option.exportValue !== \"Account123\" || option.displayValue !== \"Account123\") {\n    throw new Error(\"Option values do not match fieldValue.\");\n  }\n});",
    "i4_gpt-4o": "it(\"should populate options with fieldValue when no options are defined\", async () => {\n  const { ChoiceWidgetAnnotation } = await import(\"../../src/core/annotation.js\");\n  const { Dict } = await import(\"../../src/core/primitives.js\");\n  const dict = new Dict({});\n  const params = {\n    dict,\n    xref: { fetchIfRef: x => x },\n    data: { fieldValue: \"Account123\" }\n  };\n  const annot = new ChoiceWidgetAnnotation(params);\n  if (annot.data.options.length !== 1) {\n    throw new Error(\"Expected options to be populated from fieldValue.\");\n  }\n  const option = annot.data.options[0];\n  if (option.exportValue !== \"Account123\" || option.displayValue !== \"Account123\") {\n    throw new Error(\"Option values do not match fieldValue.\");\n  }\n});",
    "i4_llama-3.3-70b-versatile": "it(\"should populate options with fieldValue when no options are defined\", async () => {\n  const { ChoiceWidgetAnnotation } = await import(\"../../src/core/annotation.js\");\n  const { Dict } = await import(\"../../src/core/primitives.js\");\n  const dict = new Dict({});\n  const params = {\n    dict,\n    xref: { fetchIfRef: x => x },\n    data: { fieldValue: \"Account123\" }\n  };\n  const annot = new ChoiceWidgetAnnotation(params);\n  if (annot.data.options.length !== 1) {\n    throw new Error(\"Expected options to be populated from fieldValue.\");\n  }\n  const option = annot.data.options[0];\n  if (option.exportValue !== \"Account123\" || option.displayValue !== \"Account123\") {\n    throw new Error(\"Option values do not match fieldValue.\");\n  }\n});",
    "i5_deepseek-r1-distill-llama-70b": "it(\"should populate options with fieldValue when no options are defined\", async () => {\n  const { ChoiceWidgetAnnotation } = await import(\"../../src/core/annotation.js\");\n  const { Dict } = await import(\"../../src/core/primitives.js\");\n  const dict = new Dict({});\n  const params = {\n    dict,\n    xref: { fetchIfRef: x => x },\n    data: { fieldValue: \"Account123\" }\n  };\n  const annot = new ChoiceWidgetAnnotation(params);\n  if (annot.data.options.length !== 1) {\n    throw new Error(\"Expected options to be populated from fieldValue.\");\n  }\n  const option = annot.data.options[0];\n  if (option.exportValue !== \"Account123\" || option.displayValue !== \"Account123\") {\n    throw new Error(\"Option values do not match fieldValue.\");\n  }\n});",
    "i5_gpt-4o": "it(\"should populate options with fieldValue when no options are defined\", async () => {\n  const { ChoiceWidgetAnnotation } = await import(\"../../src/core/annotation.js\");\n  const { Dict } = await import(\"../../src/core/primitives.js\");\n  const dict = new Dict({});\n  const params = {\n    dict,\n    xref: { fetchIfRef: x => x },\n    data: { fieldValue: \"Account123\" }\n  };\n  const annot = new ChoiceWidgetAnnotation(params);\n  if (annot.data.options.length !== 1) {\n    throw new Error(\"Expected options to be populated from fieldValue.\");\n  }\n  const option = annot.data.options[0];\n  if (option.exportValue !== \"Account123\" || option.displayValue !== \"Account123\") {\n    throw new Error(\"Option values do not match fieldValue.\");\n  }\n});",
    "i5_llama-3.3-70b-versatile": "it(\"should populate options with fieldValue when no options are defined\", async () => {\n  const { ChoiceWidgetAnnotation } = await import(\"../../src/core/annotation.js\");\n  const { Dict } = await import(\"../../src/core/primitives.js\");\n  const dict = new Dict({});\n  const params = {\n    dict,\n    xref: { fetchIfRef: x => x },\n    data: { fieldValue: \"Account123\" }\n  };\n  const annot = new ChoiceWidgetAnnotation(params);\n  if (annot.data.options.length !== 1) {\n    throw new Error(\"Expected options to be populated from fieldValue.\");\n  }\n  const option = annot.data.options[0];\n  if (option.exportValue !== \"Account123\" || option.displayValue !== \"Account123\") {\n    throw new Error(\"Option values do not match fieldValue.\");\n  }\n});"
  },
  "19095": {
    "i1_deepseek-r1-distill-llama-70b": "it(\"should rescale huge image data to avoid decode errors\", async () => {\n  const { ImageResizer, ImageKind } = await import(\"../../src/core/image_resizer.js\");\n  const imageUtils = await import(\"../../src/shared/image_utils.js\");\n  // Monkey-patch convertToRGBA to bypass actual conversion.\n  const originalConvertToRGBA = imageUtils.convertToRGBA;\n  imageUtils.convertToRGBA = ({ srcPos, destPos }) => ({ srcPos, destPos });\n  // Force the branch that creates an ImageBitmap.\n  ImageResizer.needsToBeResized = () => false;\n  // Override Uint8Array to simulate allocation failure for large sizes.\n  const OriginalUint8Array = Uint8Array;\n  const threshold = 10000;\n  function FakeUint8Array(arg) {\n    if (typeof arg === \"number\" && arg > threshold) {\n      throw new Error(\"Simulated allocation failure\");\n    }\n    return new OriginalUint8Array(arg);\n  }\n  FakeUint8Array.from = OriginalUint8Array.from;\n  FakeUint8Array.of = OriginalUint8Array.of;\n  globalThis.Uint8Array = FakeUint8Array;\n  // Create fake image data with dimensions triggering the rescale branch.\n  // width * height * 4 > MAX_INT_32; choose width = 1024, height = 524288 so that 1024*524288*4 = 2147483648 > 2147483647.\n  const fakeData = new OriginalUint8Array(100); // dummy data\n  const imgData = {\n    width: 1024,\n    height: 524288,\n    data: fakeData,\n    kind: ImageKind.RGBA_32BPP,\n  };\n  const resizer = new ImageResizer(imgData, false);\n  const result = await resizer._createImage();\n  // Restore original Uint8Array and convertToRGBA.\n  globalThis.Uint8Array = OriginalUint8Array;\n  imageUtils.convertToRGBA = originalConvertToRGBA;\n  if (result !== null) {\n    if (result.data !== null) {\n      throw new Error(\"Expected rescaled image data to have data set to null\");\n    }\n    if (!result.bitmap) {\n      throw new Error(\"Expected rescaled image data to have a bitmap\");\n    }\n  }\n});",
    "i1_gpt-4o": "it(\"should rescale huge image data to avoid decode errors\", async () => {\n  const { ImageResizer, ImageKind } = await import(\"../../src/core/image_resizer.js\");\n  const imageUtils = await import(\"../../src/shared/image_utils.js\");\n  // Monkey-patch convertToRGBA to bypass actual conversion.\n  const originalConvertToRGBA = imageUtils.convertToRGBA;\n  imageUtils.convertToRGBA = ({ srcPos, destPos }) => ({ srcPos, destPos });\n  // Force the branch that creates an ImageBitmap.\n  ImageResizer.needsToBeResized = () => false;\n  // Override Uint8Array to simulate allocation failure for large sizes.\n  const OriginalUint8Array = Uint8Array;\n  const threshold = 10000;\n  function FakeUint8Array(arg) {\n    if (typeof arg === \"number\" && arg > threshold) {\n      throw new Error(\"Simulated allocation failure\");\n    }\n    return new OriginalUint8Array(arg);\n  }\n  FakeUint8Array.from = OriginalUint8Array.from;\n  FakeUint8Array.of = OriginalUint8Array.of;\n  globalThis.Uint8Array = FakeUint8Array;\n  // Create fake image data with dimensions triggering the rescale branch.\n  // width * height * 4 > MAX_INT_32; choose width = 1024, height = 524288 so that 1024*524288*4 = 2147483648 > 2147483647.\n  const fakeData = new OriginalUint8Array(100); // dummy data\n  const imgData = {\n    width: 1024,\n    height: 524288,\n    data: fakeData,\n    kind: ImageKind.RGBA_32BPP,\n  };\n  const resizer = new ImageResizer(imgData, false);\n  const result = await resizer._createImage();\n  // Restore original Uint8Array and convertToRGBA.\n  globalThis.Uint8Array = OriginalUint8Array;\n  imageUtils.convertToRGBA = originalConvertToRGBA;\n  if (result !== null) {\n    if (result.data !== null) {\n      throw new Error(\"Expected rescaled image data to have data set to null\");\n    }\n    if (!result.bitmap) {\n      throw new Error(\"Expected rescaled image data to have a bitmap\");\n    }\n  }\n});",
    "i1_llama-3.3-70b-versatile": "it(\"should rescale huge image data to avoid decode errors\", async () => {\n  const { ImageResizer, ImageKind } = await import(\"../../src/core/image_resizer.js\");\n  const imageUtils = await import(\"../../src/shared/image_utils.js\");\n  // Monkey-patch convertToRGBA to bypass actual conversion.\n  const originalConvertToRGBA = imageUtils.convertToRGBA;\n  imageUtils.convertToRGBA = ({ srcPos, destPos }) => ({ srcPos, destPos });\n  // Force the branch that creates an ImageBitmap.\n  ImageResizer.needsToBeResized = () => false;\n  // Override Uint8Array to simulate allocation failure for large sizes.\n  const OriginalUint8Array = Uint8Array;\n  const threshold = 10000;\n  function FakeUint8Array(arg) {\n    if (typeof arg === \"number\" && arg > threshold) {\n      throw new Error(\"Simulated allocation failure\");\n    }\n    return new OriginalUint8Array(arg);\n  }\n  FakeUint8Array.from = OriginalUint8Array.from;\n  FakeUint8Array.of = OriginalUint8Array.of;\n  globalThis.Uint8Array = FakeUint8Array;\n  // Create fake image data with dimensions triggering the rescale branch.\n  // width * height * 4 > MAX_INT_32; choose width = 1024, height = 524288 so that 1024*524288*4 = 2147483648 > 2147483647.\n  const fakeData = new OriginalUint8Array(100); // dummy data\n  const imgData = {\n    width: 1024,\n    height: 524288,\n    data: fakeData,\n    kind: ImageKind.RGBA_32BPP,\n  };\n  const resizer = new ImageResizer(imgData, false);\n  const result = await resizer._createImage();\n  // Restore original Uint8Array and convertToRGBA.\n  globalThis.Uint8Array = OriginalUint8Array;\n  imageUtils.convertToRGBA = originalConvertToRGBA;\n  if (result !== null) {\n    if (result.data !== null) {\n      throw new Error(\"Expected rescaled image data to have data set to null\");\n    }\n    if (!result.bitmap) {\n      throw new Error(\"Expected rescaled image data to have a bitmap\");\n    }\n  }\n});",
    "i1_MOCK": "it(\"should rescale huge image data to avoid decode errors\", async () => {\n  const { ImageResizer, ImageKind } = await import(\"../../src/core/image_resizer.js\");\n  const imageUtils = await import(\"../../src/shared/image_utils.js\");\n  // Monkey-patch convertToRGBA to bypass actual conversion.\n  const originalConvertToRGBA = imageUtils.convertToRGBA;\n  imageUtils.convertToRGBA = ({ srcPos, destPos }) => ({ srcPos, destPos });\n  // Force the branch that creates an ImageBitmap.\n  ImageResizer.needsToBeResized = () => false;\n  // Override Uint8Array to simulate allocation failure for large sizes.\n  const OriginalUint8Array = Uint8Array;\n  const threshold = 10000;\n  function FakeUint8Array(arg) {\n    if (typeof arg === \"number\" && arg > threshold) {\n      throw new Error(\"Simulated allocation failure\");\n    }\n    return new OriginalUint8Array(arg);\n  }\n  FakeUint8Array.from = OriginalUint8Array.from;\n  FakeUint8Array.of = OriginalUint8Array.of;\n  globalThis.Uint8Array = FakeUint8Array;\n  // Create fake image data with dimensions triggering the rescale branch.\n  // width * height * 4 > MAX_INT_32; choose width = 1024, height = 524288 so that 1024*524288*4 = 2147483648 > 2147483647.\n  const fakeData = new OriginalUint8Array(100); // dummy data\n  const imgData = {\n    width: 1024,\n    height: 524288,\n    data: fakeData,\n    kind: ImageKind.RGBA_32BPP,\n  };\n  const resizer = new ImageResizer(imgData, false);\n  const result = await resizer._createImage();\n  // Restore original Uint8Array and convertToRGBA.\n  globalThis.Uint8Array = OriginalUint8Array;\n  imageUtils.convertToRGBA = originalConvertToRGBA;\n  if (result !== null) {\n    if (result.data !== null) {\n      throw new Error(\"Expected rescaled image data to have data set to null\");\n    }\n    if (!result.bitmap) {\n      throw new Error(\"Expected rescaled image data to have a bitmap\");\n    }\n  }\n});",
    "i2_deepseek-r1-distill-llama-70b": "it(\"should rescale huge image data to avoid decode errors\", async () => {\n  const { ImageResizer, ImageKind } = await import(\"../../src/core/image_resizer.js\");\n  const imageUtils = await import(\"../../src/shared/image_utils.js\");\n  // Monkey-patch convertToRGBA to bypass actual conversion.\n  const originalConvertToRGBA = imageUtils.convertToRGBA;\n  imageUtils.convertToRGBA = ({ srcPos, destPos }) => ({ srcPos, destPos });\n  // Force the branch that creates an ImageBitmap.\n  ImageResizer.needsToBeResized = () => false;\n  // Override Uint8Array to simulate allocation failure for large sizes.\n  const OriginalUint8Array = Uint8Array;\n  const threshold = 10000;\n  function FakeUint8Array(arg) {\n    if (typeof arg === \"number\" && arg > threshold) {\n      throw new Error(\"Simulated allocation failure\");\n    }\n    return new OriginalUint8Array(arg);\n  }\n  FakeUint8Array.from = OriginalUint8Array.from;\n  FakeUint8Array.of = OriginalUint8Array.of;\n  globalThis.Uint8Array = FakeUint8Array;\n  // Create fake image data with dimensions triggering the rescale branch.\n  // width * height * 4 > MAX_INT_32; choose width = 1024, height = 524288 so that 1024*524288*4 = 2147483648 > 2147483647.\n  const fakeData = new OriginalUint8Array(100); // dummy data\n  const imgData = {\n    width: 1024,\n    height: 524288,\n    data: fakeData,\n    kind: ImageKind.RGBA_32BPP,\n  };\n  const resizer = new ImageResizer(imgData, false);\n  const result = await resizer._createImage();\n  // Restore original Uint8Array and convertToRGBA.\n  globalThis.Uint8Array = OriginalUint8Array;\n  imageUtils.convertToRGBA = originalConvertToRGBA;\n  if (result !== null) {\n    if (result.data !== null) {\n      throw new Error(\"Expected rescaled image data to have data set to null\");\n    }\n    if (!result.bitmap) {\n      throw new Error(\"Expected rescaled image data to have a bitmap\");\n    }\n  }\n});",
    "i2_gpt-4o": "it(\"should rescale huge image data to avoid decode errors\", async () => {\n  const { ImageResizer, ImageKind } = await import(\"../../src/core/image_resizer.js\");\n  const imageUtils = await import(\"../../src/shared/image_utils.js\");\n  // Monkey-patch convertToRGBA to bypass actual conversion.\n  const originalConvertToRGBA = imageUtils.convertToRGBA;\n  imageUtils.convertToRGBA = ({ srcPos, destPos }) => ({ srcPos, destPos });\n  // Force the branch that creates an ImageBitmap.\n  ImageResizer.needsToBeResized = () => false;\n  // Override Uint8Array to simulate allocation failure for large sizes.\n  const OriginalUint8Array = Uint8Array;\n  const threshold = 10000;\n  function FakeUint8Array(arg) {\n    if (typeof arg === \"number\" && arg > threshold) {\n      throw new Error(\"Simulated allocation failure\");\n    }\n    return new OriginalUint8Array(arg);\n  }\n  FakeUint8Array.from = OriginalUint8Array.from;\n  FakeUint8Array.of = OriginalUint8Array.of;\n  globalThis.Uint8Array = FakeUint8Array;\n  // Create fake image data with dimensions triggering the rescale branch.\n  // width * height * 4 > MAX_INT_32; choose width = 1024, height = 524288 so that 1024*524288*4 = 2147483648 > 2147483647.\n  const fakeData = new OriginalUint8Array(100); // dummy data\n  const imgData = {\n    width: 1024,\n    height: 524288,\n    data: fakeData,\n    kind: ImageKind.RGBA_32BPP,\n  };\n  const resizer = new ImageResizer(imgData, false);\n  const result = await resizer._createImage();\n  // Restore original Uint8Array and convertToRGBA.\n  globalThis.Uint8Array = OriginalUint8Array;\n  imageUtils.convertToRGBA = originalConvertToRGBA;\n  if (result !== null) {\n    if (result.data !== null) {\n      throw new Error(\"Expected rescaled image data to have data set to null\");\n    }\n    if (!result.bitmap) {\n      throw new Error(\"Expected rescaled image data to have a bitmap\");\n    }\n  }\n});",
    "i2_llama-3.3-70b-versatile": "it(\"should rescale huge image data to avoid decode errors\", async () => {\n  const { ImageResizer, ImageKind } = await import(\"../../src/core/image_resizer.js\");\n  const imageUtils = await import(\"../../src/shared/image_utils.js\");\n  // Monkey-patch convertToRGBA to bypass actual conversion.\n  const originalConvertToRGBA = imageUtils.convertToRGBA;\n  imageUtils.convertToRGBA = ({ srcPos, destPos }) => ({ srcPos, destPos });\n  // Force the branch that creates an ImageBitmap.\n  ImageResizer.needsToBeResized = () => false;\n  // Override Uint8Array to simulate allocation failure for large sizes.\n  const OriginalUint8Array = Uint8Array;\n  const threshold = 10000;\n  function FakeUint8Array(arg) {\n    if (typeof arg === \"number\" && arg > threshold) {\n      throw new Error(\"Simulated allocation failure\");\n    }\n    return new OriginalUint8Array(arg);\n  }\n  FakeUint8Array.from = OriginalUint8Array.from;\n  FakeUint8Array.of = OriginalUint8Array.of;\n  globalThis.Uint8Array = FakeUint8Array;\n  // Create fake image data with dimensions triggering the rescale branch.\n  // width * height * 4 > MAX_INT_32; choose width = 1024, height = 524288 so that 1024*524288*4 = 2147483648 > 2147483647.\n  const fakeData = new OriginalUint8Array(100); // dummy data\n  const imgData = {\n    width: 1024,\n    height: 524288,\n    data: fakeData,\n    kind: ImageKind.RGBA_32BPP,\n  };\n  const resizer = new ImageResizer(imgData, false);\n  const result = await resizer._createImage();\n  // Restore original Uint8Array and convertToRGBA.\n  globalThis.Uint8Array = OriginalUint8Array;\n  imageUtils.convertToRGBA = originalConvertToRGBA;\n  if (result !== null) {\n    if (result.data !== null) {\n      throw new Error(\"Expected rescaled image data to have data set to null\");\n    }\n    if (!result.bitmap) {\n      throw new Error(\"Expected rescaled image data to have a bitmap\");\n    }\n  }\n});",
    "i3_deepseek-r1-distill-llama-70b": "it(\"should rescale huge image data to avoid decode errors\", async () => {\n  const { ImageResizer, ImageKind } = await import(\"../../src/core/image_resizer.js\");\n  const imageUtils = await import(\"../../src/shared/image_utils.js\");\n  // Monkey-patch convertToRGBA to bypass actual conversion.\n  const originalConvertToRGBA = imageUtils.convertToRGBA;\n  imageUtils.convertToRGBA = ({ srcPos, destPos }) => ({ srcPos, destPos });\n  // Force the branch that creates an ImageBitmap.\n  ImageResizer.needsToBeResized = () => false;\n  // Override Uint8Array to simulate allocation failure for large sizes.\n  const OriginalUint8Array = Uint8Array;\n  const threshold = 10000;\n  function FakeUint8Array(arg) {\n    if (typeof arg === \"number\" && arg > threshold) {\n      throw new Error(\"Simulated allocation failure\");\n    }\n    return new OriginalUint8Array(arg);\n  }\n  FakeUint8Array.from = OriginalUint8Array.from;\n  FakeUint8Array.of = OriginalUint8Array.of;\n  globalThis.Uint8Array = FakeUint8Array;\n  // Create fake image data with dimensions triggering the rescale branch.\n  // width * height * 4 > MAX_INT_32; choose width = 1024, height = 524288 so that 1024*524288*4 = 2147483648 > 2147483647.\n  const fakeData = new OriginalUint8Array(100); // dummy data\n  const imgData = {\n    width: 1024,\n    height: 524288,\n    data: fakeData,\n    kind: ImageKind.RGBA_32BPP,\n  };\n  const resizer = new ImageResizer(imgData, false);\n  const result = await resizer._createImage();\n  // Restore original Uint8Array and convertToRGBA.\n  globalThis.Uint8Array = OriginalUint8Array;\n  imageUtils.convertToRGBA = originalConvertToRGBA;\n  if (result !== null) {\n    if (result.data !== null) {\n      throw new Error(\"Expected rescaled image data to have data set to null\");\n    }\n    if (!result.bitmap) {\n      throw new Error(\"Expected rescaled image data to have a bitmap\");\n    }\n  }\n});",
    "i3_gpt-4o": "it(\"should rescale huge image data to avoid decode errors\", async () => {\n  const { ImageResizer, ImageKind } = await import(\"../../src/core/image_resizer.js\");\n  const imageUtils = await import(\"../../src/shared/image_utils.js\");\n  // Monkey-patch convertToRGBA to bypass actual conversion.\n  const originalConvertToRGBA = imageUtils.convertToRGBA;\n  imageUtils.convertToRGBA = ({ srcPos, destPos }) => ({ srcPos, destPos });\n  // Force the branch that creates an ImageBitmap.\n  ImageResizer.needsToBeResized = () => false;\n  // Override Uint8Array to simulate allocation failure for large sizes.\n  const OriginalUint8Array = Uint8Array;\n  const threshold = 10000;\n  function FakeUint8Array(arg) {\n    if (typeof arg === \"number\" && arg > threshold) {\n      throw new Error(\"Simulated allocation failure\");\n    }\n    return new OriginalUint8Array(arg);\n  }\n  FakeUint8Array.from = OriginalUint8Array.from;\n  FakeUint8Array.of = OriginalUint8Array.of;\n  globalThis.Uint8Array = FakeUint8Array;\n  // Create fake image data with dimensions triggering the rescale branch.\n  // width * height * 4 > MAX_INT_32; choose width = 1024, height = 524288 so that 1024*524288*4 = 2147483648 > 2147483647.\n  const fakeData = new OriginalUint8Array(100); // dummy data\n  const imgData = {\n    width: 1024,\n    height: 524288,\n    data: fakeData,\n    kind: ImageKind.RGBA_32BPP,\n  };\n  const resizer = new ImageResizer(imgData, false);\n  const result = await resizer._createImage();\n  // Restore original Uint8Array and convertToRGBA.\n  globalThis.Uint8Array = OriginalUint8Array;\n  imageUtils.convertToRGBA = originalConvertToRGBA;\n  if (result !== null) {\n    if (result.data !== null) {\n      throw new Error(\"Expected rescaled image data to have data set to null\");\n    }\n    if (!result.bitmap) {\n      throw new Error(\"Expected rescaled image data to have a bitmap\");\n    }\n  }\n});",
    "i3_llama-3.3-70b-versatile": "it(\"should rescale huge image data to avoid decode errors\", async () => {\n  const { ImageResizer, ImageKind } = await import(\"../../src/core/image_resizer.js\");\n  const imageUtils = await import(\"../../src/shared/image_utils.js\");\n  // Monkey-patch convertToRGBA to bypass actual conversion.\n  const originalConvertToRGBA = imageUtils.convertToRGBA;\n  imageUtils.convertToRGBA = ({ srcPos, destPos }) => ({ srcPos, destPos });\n  // Force the branch that creates an ImageBitmap.\n  ImageResizer.needsToBeResized = () => false;\n  // Override Uint8Array to simulate allocation failure for large sizes.\n  const OriginalUint8Array = Uint8Array;\n  const threshold = 10000;\n  function FakeUint8Array(arg) {\n    if (typeof arg === \"number\" && arg > threshold) {\n      throw new Error(\"Simulated allocation failure\");\n    }\n    return new OriginalUint8Array(arg);\n  }\n  FakeUint8Array.from = OriginalUint8Array.from;\n  FakeUint8Array.of = OriginalUint8Array.of;\n  globalThis.Uint8Array = FakeUint8Array;\n  // Create fake image data with dimensions triggering the rescale branch.\n  // width * height * 4 > MAX_INT_32; choose width = 1024, height = 524288 so that 1024*524288*4 = 2147483648 > 2147483647.\n  const fakeData = new OriginalUint8Array(100); // dummy data\n  const imgData = {\n    width: 1024,\n    height: 524288,\n    data: fakeData,\n    kind: ImageKind.RGBA_32BPP,\n  };\n  const resizer = new ImageResizer(imgData, false);\n  const result = await resizer._createImage();\n  // Restore original Uint8Array and convertToRGBA.\n  globalThis.Uint8Array = OriginalUint8Array;\n  imageUtils.convertToRGBA = originalConvertToRGBA;\n  if (result !== null) {\n    if (result.data !== null) {\n      throw new Error(\"Expected rescaled image data to have data set to null\");\n    }\n    if (!result.bitmap) {\n      throw new Error(\"Expected rescaled image data to have a bitmap\");\n    }\n  }\n});",
    "i4_deepseek-r1-distill-llama-70b": "it(\"should rescale huge image data to avoid decode errors\", async () => {\n  const { ImageResizer, ImageKind } = await import(\"../../src/core/image_resizer.js\");\n  const imageUtils = await import(\"../../src/shared/image_utils.js\");\n  // Monkey-patch convertToRGBA to bypass actual conversion.\n  const originalConvertToRGBA = imageUtils.convertToRGBA;\n  imageUtils.convertToRGBA = ({ srcPos, destPos }) => ({ srcPos, destPos });\n  // Force the branch that creates an ImageBitmap.\n  ImageResizer.needsToBeResized = () => false;\n  // Override Uint8Array to simulate allocation failure for large sizes.\n  const OriginalUint8Array = Uint8Array;\n  const threshold = 10000;\n  function FakeUint8Array(arg) {\n    if (typeof arg === \"number\" && arg > threshold) {\n      throw new Error(\"Simulated allocation failure\");\n    }\n    return new OriginalUint8Array(arg);\n  }\n  FakeUint8Array.from = OriginalUint8Array.from;\n  FakeUint8Array.of = OriginalUint8Array.of;\n  globalThis.Uint8Array = FakeUint8Array;\n  // Create fake image data with dimensions triggering the rescale branch.\n  // width * height * 4 > MAX_INT_32; choose width = 1024, height = 524288 so that 1024*524288*4 = 2147483648 > 2147483647.\n  const fakeData = new OriginalUint8Array(100); // dummy data\n  const imgData = {\n    width: 1024,\n    height: 524288,\n    data: fakeData,\n    kind: ImageKind.RGBA_32BPP,\n  };\n  const resizer = new ImageResizer(imgData, false);\n  const result = await resizer._createImage();\n  // Restore original Uint8Array and convertToRGBA.\n  globalThis.Uint8Array = OriginalUint8Array;\n  imageUtils.convertToRGBA = originalConvertToRGBA;\n  if (result !== null) {\n    if (result.data !== null) {\n      throw new Error(\"Expected rescaled image data to have data set to null\");\n    }\n    if (!result.bitmap) {\n      throw new Error(\"Expected rescaled image data to have a bitmap\");\n    }\n  }\n});",
    "i4_gpt-4o": "it(\"should rescale huge image data to avoid decode errors\", async () => {\n  const { ImageResizer, ImageKind } = await import(\"../../src/core/image_resizer.js\");\n  const imageUtils = await import(\"../../src/shared/image_utils.js\");\n  // Monkey-patch convertToRGBA to bypass actual conversion.\n  const originalConvertToRGBA = imageUtils.convertToRGBA;\n  imageUtils.convertToRGBA = ({ srcPos, destPos }) => ({ srcPos, destPos });\n  // Force the branch that creates an ImageBitmap.\n  ImageResizer.needsToBeResized = () => false;\n  // Override Uint8Array to simulate allocation failure for large sizes.\n  const OriginalUint8Array = Uint8Array;\n  const threshold = 10000;\n  function FakeUint8Array(arg) {\n    if (typeof arg === \"number\" && arg > threshold) {\n      throw new Error(\"Simulated allocation failure\");\n    }\n    return new OriginalUint8Array(arg);\n  }\n  FakeUint8Array.from = OriginalUint8Array.from;\n  FakeUint8Array.of = OriginalUint8Array.of;\n  globalThis.Uint8Array = FakeUint8Array;\n  // Create fake image data with dimensions triggering the rescale branch.\n  // width * height * 4 > MAX_INT_32; choose width = 1024, height = 524288 so that 1024*524288*4 = 2147483648 > 2147483647.\n  const fakeData = new OriginalUint8Array(100); // dummy data\n  const imgData = {\n    width: 1024,\n    height: 524288,\n    data: fakeData,\n    kind: ImageKind.RGBA_32BPP,\n  };\n  const resizer = new ImageResizer(imgData, false);\n  const result = await resizer._createImage();\n  // Restore original Uint8Array and convertToRGBA.\n  globalThis.Uint8Array = OriginalUint8Array;\n  imageUtils.convertToRGBA = originalConvertToRGBA;\n  if (result !== null) {\n    if (result.data !== null) {\n      throw new Error(\"Expected rescaled image data to have data set to null\");\n    }\n    if (!result.bitmap) {\n      throw new Error(\"Expected rescaled image data to have a bitmap\");\n    }\n  }\n});",
    "i4_llama-3.3-70b-versatile": "it(\"should rescale huge image data to avoid decode errors\", async () => {\n  const { ImageResizer, ImageKind } = await import(\"../../src/core/image_resizer.js\");\n  const imageUtils = await import(\"../../src/shared/image_utils.js\");\n  // Monkey-patch convertToRGBA to bypass actual conversion.\n  const originalConvertToRGBA = imageUtils.convertToRGBA;\n  imageUtils.convertToRGBA = ({ srcPos, destPos }) => ({ srcPos, destPos });\n  // Force the branch that creates an ImageBitmap.\n  ImageResizer.needsToBeResized = () => false;\n  // Override Uint8Array to simulate allocation failure for large sizes.\n  const OriginalUint8Array = Uint8Array;\n  const threshold = 10000;\n  function FakeUint8Array(arg) {\n    if (typeof arg === \"number\" && arg > threshold) {\n      throw new Error(\"Simulated allocation failure\");\n    }\n    return new OriginalUint8Array(arg);\n  }\n  FakeUint8Array.from = OriginalUint8Array.from;\n  FakeUint8Array.of = OriginalUint8Array.of;\n  globalThis.Uint8Array = FakeUint8Array;\n  // Create fake image data with dimensions triggering the rescale branch.\n  // width * height * 4 > MAX_INT_32; choose width = 1024, height = 524288 so that 1024*524288*4 = 2147483648 > 2147483647.\n  const fakeData = new OriginalUint8Array(100); // dummy data\n  const imgData = {\n    width: 1024,\n    height: 524288,\n    data: fakeData,\n    kind: ImageKind.RGBA_32BPP,\n  };\n  const resizer = new ImageResizer(imgData, false);\n  const result = await resizer._createImage();\n  // Restore original Uint8Array and convertToRGBA.\n  globalThis.Uint8Array = OriginalUint8Array;\n  imageUtils.convertToRGBA = originalConvertToRGBA;\n  if (result !== null) {\n    if (result.data !== null) {\n      throw new Error(\"Expected rescaled image data to have data set to null\");\n    }\n    if (!result.bitmap) {\n      throw new Error(\"Expected rescaled image data to have a bitmap\");\n    }\n  }\n});",
    "i5_deepseek-r1-distill-llama-70b": "it(\"should rescale huge image data to avoid decode errors\", async () => {\n  const { ImageResizer, ImageKind } = await import(\"../../src/core/image_resizer.js\");\n  const imageUtils = await import(\"../../src/shared/image_utils.js\");\n  // Monkey-patch convertToRGBA to bypass actual conversion.\n  const originalConvertToRGBA = imageUtils.convertToRGBA;\n  imageUtils.convertToRGBA = ({ srcPos, destPos }) => ({ srcPos, destPos });\n  // Force the branch that creates an ImageBitmap.\n  ImageResizer.needsToBeResized = () => false;\n  // Override Uint8Array to simulate allocation failure for large sizes.\n  const OriginalUint8Array = Uint8Array;\n  const threshold = 10000;\n  function FakeUint8Array(arg) {\n    if (typeof arg === \"number\" && arg > threshold) {\n      throw new Error(\"Simulated allocation failure\");\n    }\n    return new OriginalUint8Array(arg);\n  }\n  FakeUint8Array.from = OriginalUint8Array.from;\n  FakeUint8Array.of = OriginalUint8Array.of;\n  globalThis.Uint8Array = FakeUint8Array;\n  // Create fake image data with dimensions triggering the rescale branch.\n  // width * height * 4 > MAX_INT_32; choose width = 1024, height = 524288 so that 1024*524288*4 = 2147483648 > 2147483647.\n  const fakeData = new OriginalUint8Array(100); // dummy data\n  const imgData = {\n    width: 1024,\n    height: 524288,\n    data: fakeData,\n    kind: ImageKind.RGBA_32BPP,\n  };\n  const resizer = new ImageResizer(imgData, false);\n  const result = await resizer._createImage();\n  // Restore original Uint8Array and convertToRGBA.\n  globalThis.Uint8Array = OriginalUint8Array;\n  imageUtils.convertToRGBA = originalConvertToRGBA;\n  if (result !== null) {\n    if (result.data !== null) {\n      throw new Error(\"Expected rescaled image data to have data set to null\");\n    }\n    if (!result.bitmap) {\n      throw new Error(\"Expected rescaled image data to have a bitmap\");\n    }\n  }\n});",
    "i5_gpt-4o": "it(\"should rescale huge image data to avoid decode errors\", async () => {\n  const { ImageResizer, ImageKind } = await import(\"../../src/core/image_resizer.js\");\n  const imageUtils = await import(\"../../src/shared/image_utils.js\");\n  // Monkey-patch convertToRGBA to bypass actual conversion.\n  const originalConvertToRGBA = imageUtils.convertToRGBA;\n  imageUtils.convertToRGBA = ({ srcPos, destPos }) => ({ srcPos, destPos });\n  // Force the branch that creates an ImageBitmap.\n  ImageResizer.needsToBeResized = () => false;\n  // Override Uint8Array to simulate allocation failure for large sizes.\n  const OriginalUint8Array = Uint8Array;\n  const threshold = 10000;\n  function FakeUint8Array(arg) {\n    if (typeof arg === \"number\" && arg > threshold) {\n      throw new Error(\"Simulated allocation failure\");\n    }\n    return new OriginalUint8Array(arg);\n  }\n  FakeUint8Array.from = OriginalUint8Array.from;\n  FakeUint8Array.of = OriginalUint8Array.of;\n  globalThis.Uint8Array = FakeUint8Array;\n  // Create fake image data with dimensions triggering the rescale branch.\n  // width * height * 4 > MAX_INT_32; choose width = 1024, height = 524288 so that 1024*524288*4 = 2147483648 > 2147483647.\n  const fakeData = new OriginalUint8Array(100); // dummy data\n  const imgData = {\n    width: 1024,\n    height: 524288,\n    data: fakeData,\n    kind: ImageKind.RGBA_32BPP,\n  };\n  const resizer = new ImageResizer(imgData, false);\n  const result = await resizer._createImage();\n  // Restore original Uint8Array and convertToRGBA.\n  globalThis.Uint8Array = OriginalUint8Array;\n  imageUtils.convertToRGBA = originalConvertToRGBA;\n  if (result !== null) {\n    if (result.data !== null) {\n      throw new Error(\"Expected rescaled image data to have data set to null\");\n    }\n    if (!result.bitmap) {\n      throw new Error(\"Expected rescaled image data to have a bitmap\");\n    }\n  }\n});",
    "i5_llama-3.3-70b-versatile": "it(\"should rescale huge image data to avoid decode errors\", async () => {\n  const { ImageResizer, ImageKind } = await import(\"../../src/core/image_resizer.js\");\n  const imageUtils = await import(\"../../src/shared/image_utils.js\");\n  // Monkey-patch convertToRGBA to bypass actual conversion.\n  const originalConvertToRGBA = imageUtils.convertToRGBA;\n  imageUtils.convertToRGBA = ({ srcPos, destPos }) => ({ srcPos, destPos });\n  // Force the branch that creates an ImageBitmap.\n  ImageResizer.needsToBeResized = () => false;\n  // Override Uint8Array to simulate allocation failure for large sizes.\n  const OriginalUint8Array = Uint8Array;\n  const threshold = 10000;\n  function FakeUint8Array(arg) {\n    if (typeof arg === \"number\" && arg > threshold) {\n      throw new Error(\"Simulated allocation failure\");\n    }\n    return new OriginalUint8Array(arg);\n  }\n  FakeUint8Array.from = OriginalUint8Array.from;\n  FakeUint8Array.of = OriginalUint8Array.of;\n  globalThis.Uint8Array = FakeUint8Array;\n  // Create fake image data with dimensions triggering the rescale branch.\n  // width * height * 4 > MAX_INT_32; choose width = 1024, height = 524288 so that 1024*524288*4 = 2147483648 > 2147483647.\n  const fakeData = new OriginalUint8Array(100); // dummy data\n  const imgData = {\n    width: 1024,\n    height: 524288,\n    data: fakeData,\n    kind: ImageKind.RGBA_32BPP,\n  };\n  const resizer = new ImageResizer(imgData, false);\n  const result = await resizer._createImage();\n  // Restore original Uint8Array and convertToRGBA.\n  globalThis.Uint8Array = OriginalUint8Array;\n  imageUtils.convertToRGBA = originalConvertToRGBA;\n  if (result !== null) {\n    if (result.data !== null) {\n      throw new Error(\"Expected rescaled image data to have data set to null\");\n    }\n    if (!result.bitmap) {\n      throw new Error(\"Expected rescaled image data to have a bitmap\");\n    }\n  }\n});"
  },
  "19262": {
    "i1_deepseek-r1-distill-llama-70b": "it(\"should throw an error when a nonnumber array is passed as fontMatrix\", async () => {\n  const { CompiledFont } = await import(\"../../src/core/font_renderer.js\");\n  // An invalid fontMatrix: not all elements are numbers.\n  const invalidMatrix = [1, 0, 0, \"maliciousCode\", 0, 0];\n  // Dummy glyph code that is non-empty and does not start with 14.\n  const sampleCode = [1, 2, 3];\n  const glyphId = 0;\n  let error = null;\n  try {\n    new CompiledFont(invalidMatrix).compileGlyph(sampleCode, glyphId);\n  } catch (ex) {\n    error = ex;\n  }\n  if (!error || !/Expected a valid fontMatrix/.test(error.message)) {\n    throw new Error(\"Test failed: Expected an error with 'Expected a valid fontMatrix' to be thrown.\");\n  }\n});\n",
    "i1_gpt-4o": "it(\"should throw an error when a nonnumber array is passed as fontMatrix\", async () => {\n  const { CompiledFont } = await import(\"../../src/core/font_renderer.js\");\n  // An invalid fontMatrix: not all elements are numbers.\n  const invalidMatrix = [1, 0, 0, \"maliciousCode\", 0, 0];\n  // Dummy glyph code that is non-empty and does not start with 14.\n  const sampleCode = [1, 2, 3];\n  const glyphId = 0;\n  let error = null;\n  try {\n    new CompiledFont(invalidMatrix).compileGlyph(sampleCode, glyphId);\n  } catch (ex) {\n    error = ex;\n  }\n  if (!error || !/Expected a valid fontMatrix/.test(error.message)) {\n    throw new Error(\"Test failed: Expected an error with 'Expected a valid fontMatrix' to be thrown.\");\n  }\n});\n",
    "i1_llama-3.3-70b-versatile": "it(\"should throw an error when a nonnumber array is passed as fontMatrix\", async () => {\n  const { CompiledFont } = await import(\"../../src/core/font_renderer.js\");\n  // An invalid fontMatrix: not all elements are numbers.\n  const invalidMatrix = [1, 0, 0, \"maliciousCode\", 0, 0];\n  // Dummy glyph code that is non-empty and does not start with 14.\n  const sampleCode = [1, 2, 3];\n  const glyphId = 0;\n  let error = null;\n  try {\n    new CompiledFont(invalidMatrix).compileGlyph(sampleCode, glyphId);\n  } catch (ex) {\n    error = ex;\n  }\n  if (!error || !/Expected a valid fontMatrix/.test(error.message)) {\n    throw new Error(\"Test failed: Expected an error with 'Expected a valid fontMatrix' to be thrown.\");\n  }\n});\n",
    "i1_MOCK": "it(\"should throw an error when a nonnumber array is passed as fontMatrix\", async () => {\n  const { CompiledFont } = await import(\"../../src/core/font_renderer.js\");\n  // An invalid fontMatrix: not all elements are numbers.\n  const invalidMatrix = [1, 0, 0, \"maliciousCode\", 0, 0];\n  // Dummy glyph code that is non-empty and does not start with 14.\n  const sampleCode = [1, 2, 3];\n  const glyphId = 0;\n  let error = null;\n  try {\n    new CompiledFont(invalidMatrix).compileGlyph(sampleCode, glyphId);\n  } catch (ex) {\n    error = ex;\n  }\n  if (!error || !/Expected a valid fontMatrix/.test(error.message)) {\n    throw new Error(\"Test failed: Expected an error with 'Expected a valid fontMatrix' to be thrown.\");\n  }\n});\n",
    "i2_deepseek-r1-distill-llama-70b": "it(\"should throw an error when a nonnumber array is passed as fontMatrix\", async () => {\n  const { CompiledFont } = await import(\"../../src/core/font_renderer.js\");\n  // An invalid fontMatrix: not all elements are numbers.\n  const invalidMatrix = [1, 0, 0, \"maliciousCode\", 0, 0];\n  // Dummy glyph code that is non-empty and does not start with 14.\n  const sampleCode = [1, 2, 3];\n  const glyphId = 0;\n  let error = null;\n  try {\n    new CompiledFont(invalidMatrix).compileGlyph(sampleCode, glyphId);\n  } catch (ex) {\n    error = ex;\n  }\n  if (!error || !/Expected a valid fontMatrix/.test(error.message)) {\n    throw new Error(\"Test failed: Expected an error with 'Expected a valid fontMatrix' to be thrown.\");\n  }\n});\n",
    "i2_gpt-4o": "it(\"should throw an error when a nonnumber array is passed as fontMatrix\", async () => {\n  const { CompiledFont } = await import(\"../../src/core/font_renderer.js\");\n  // An invalid fontMatrix: not all elements are numbers.\n  const invalidMatrix = [1, 0, 0, \"maliciousCode\", 0, 0];\n  // Dummy glyph code that is non-empty and does not start with 14.\n  const sampleCode = [1, 2, 3];\n  const glyphId = 0;\n  let error = null;\n  try {\n    new CompiledFont(invalidMatrix).compileGlyph(sampleCode, glyphId);\n  } catch (ex) {\n    error = ex;\n  }\n  if (!error || !/Expected a valid fontMatrix/.test(error.message)) {\n    throw new Error(\"Test failed: Expected an error with 'Expected a valid fontMatrix' to be thrown.\");\n  }\n});\n",
    "i2_llama-3.3-70b-versatile": "it(\"should throw an error when a nonnumber array is passed as fontMatrix\", async () => {\n  const { CompiledFont } = await import(\"../../src/core/font_renderer.js\");\n  // An invalid fontMatrix: not all elements are numbers.\n  const invalidMatrix = [1, 0, 0, \"maliciousCode\", 0, 0];\n  // Dummy glyph code that is non-empty and does not start with 14.\n  const sampleCode = [1, 2, 3];\n  const glyphId = 0;\n  let error = null;\n  try {\n    new CompiledFont(invalidMatrix).compileGlyph(sampleCode, glyphId);\n  } catch (ex) {\n    error = ex;\n  }\n  if (!error || !/Expected a valid fontMatrix/.test(error.message)) {\n    throw new Error(\"Test failed: Expected an error with 'Expected a valid fontMatrix' to be thrown.\");\n  }\n});\n",
    "i3_deepseek-r1-distill-llama-70b": "it(\"should throw an error when a nonnumber array is passed as fontMatrix\", async () => {\n  const { CompiledFont } = await import(\"../../src/core/font_renderer.js\");\n  // An invalid fontMatrix: not all elements are numbers.\n  const invalidMatrix = [1, 0, 0, \"maliciousCode\", 0, 0];\n  // Dummy glyph code that is non-empty and does not start with 14.\n  const sampleCode = [1, 2, 3];\n  const glyphId = 0;\n  let error = null;\n  try {\n    new CompiledFont(invalidMatrix).compileGlyph(sampleCode, glyphId);\n  } catch (ex) {\n    error = ex;\n  }\n  if (!error || !/Expected a valid fontMatrix/.test(error.message)) {\n    throw new Error(\"Test failed: Expected an error with 'Expected a valid fontMatrix' to be thrown.\");\n  }\n});\n",
    "i3_gpt-4o": "it(\"should throw an error when a nonnumber array is passed as fontMatrix\", async () => {\n  const { CompiledFont } = await import(\"../../src/core/font_renderer.js\");\n  // An invalid fontMatrix: not all elements are numbers.\n  const invalidMatrix = [1, 0, 0, \"maliciousCode\", 0, 0];\n  // Dummy glyph code that is non-empty and does not start with 14.\n  const sampleCode = [1, 2, 3];\n  const glyphId = 0;\n  let error = null;\n  try {\n    new CompiledFont(invalidMatrix).compileGlyph(sampleCode, glyphId);\n  } catch (ex) {\n    error = ex;\n  }\n  if (!error || !/Expected a valid fontMatrix/.test(error.message)) {\n    throw new Error(\"Test failed: Expected an error with 'Expected a valid fontMatrix' to be thrown.\");\n  }\n});\n",
    "i3_llama-3.3-70b-versatile": "it(\"should throw an error when a nonnumber array is passed as fontMatrix\", async () => {\n  const { CompiledFont } = await import(\"../../src/core/font_renderer.js\");\n  // An invalid fontMatrix: not all elements are numbers.\n  const invalidMatrix = [1, 0, 0, \"maliciousCode\", 0, 0];\n  // Dummy glyph code that is non-empty and does not start with 14.\n  const sampleCode = [1, 2, 3];\n  const glyphId = 0;\n  let error = null;\n  try {\n    new CompiledFont(invalidMatrix).compileGlyph(sampleCode, glyphId);\n  } catch (ex) {\n    error = ex;\n  }\n  if (!error || !/Expected a valid fontMatrix/.test(error.message)) {\n    throw new Error(\"Test failed: Expected an error with 'Expected a valid fontMatrix' to be thrown.\");\n  }\n});\n",
    "i4_deepseek-r1-distill-llama-70b": "it(\"should throw an error when a nonnumber array is passed as fontMatrix\", async () => {\n  const { CompiledFont } = await import(\"../../src/core/font_renderer.js\");\n  // An invalid fontMatrix: not all elements are numbers.\n  const invalidMatrix = [1, 0, 0, \"maliciousCode\", 0, 0];\n  // Dummy glyph code that is non-empty and does not start with 14.\n  const sampleCode = [1, 2, 3];\n  const glyphId = 0;\n  let error = null;\n  try {\n    new CompiledFont(invalidMatrix).compileGlyph(sampleCode, glyphId);\n  } catch (ex) {\n    error = ex;\n  }\n  if (!error || !/Expected a valid fontMatrix/.test(error.message)) {\n    throw new Error(\"Test failed: Expected an error with 'Expected a valid fontMatrix' to be thrown.\");\n  }\n});\n",
    "i4_gpt-4o": "it(\"should throw an error when a nonnumber array is passed as fontMatrix\", async () => {\n  const { CompiledFont } = await import(\"../../src/core/font_renderer.js\");\n  // An invalid fontMatrix: not all elements are numbers.\n  const invalidMatrix = [1, 0, 0, \"maliciousCode\", 0, 0];\n  // Dummy glyph code that is non-empty and does not start with 14.\n  const sampleCode = [1, 2, 3];\n  const glyphId = 0;\n  let error = null;\n  try {\n    new CompiledFont(invalidMatrix).compileGlyph(sampleCode, glyphId);\n  } catch (ex) {\n    error = ex;\n  }\n  if (!error || !/Expected a valid fontMatrix/.test(error.message)) {\n    throw new Error(\"Test failed: Expected an error with 'Expected a valid fontMatrix' to be thrown.\");\n  }\n});\n",
    "i4_llama-3.3-70b-versatile": "it(\"should throw an error when a nonnumber array is passed as fontMatrix\", async () => {\n  const { CompiledFont } = await import(\"../../src/core/font_renderer.js\");\n  // An invalid fontMatrix: not all elements are numbers.\n  const invalidMatrix = [1, 0, 0, \"maliciousCode\", 0, 0];\n  // Dummy glyph code that is non-empty and does not start with 14.\n  const sampleCode = [1, 2, 3];\n  const glyphId = 0;\n  let error = null;\n  try {\n    new CompiledFont(invalidMatrix).compileGlyph(sampleCode, glyphId);\n  } catch (ex) {\n    error = ex;\n  }\n  if (!error || !/Expected a valid fontMatrix/.test(error.message)) {\n    throw new Error(\"Test failed: Expected an error with 'Expected a valid fontMatrix' to be thrown.\");\n  }\n});\n",
    "i5_deepseek-r1-distill-llama-70b": "it(\"should throw an error when a nonnumber array is passed as fontMatrix\", async () => {\n  const { CompiledFont } = await import(\"../../src/core/font_renderer.js\");\n  // An invalid fontMatrix: not all elements are numbers.\n  const invalidMatrix = [1, 0, 0, \"maliciousCode\", 0, 0];\n  // Dummy glyph code that is non-empty and does not start with 14.\n  const sampleCode = [1, 2, 3];\n  const glyphId = 0;\n  let error = null;\n  try {\n    new CompiledFont(invalidMatrix).compileGlyph(sampleCode, glyphId);\n  } catch (ex) {\n    error = ex;\n  }\n  if (!error || !/Expected a valid fontMatrix/.test(error.message)) {\n    throw new Error(\"Test failed: Expected an error with 'Expected a valid fontMatrix' to be thrown.\");\n  }\n});\n",
    "i5_gpt-4o": "it(\"should throw an error when a nonnumber array is passed as fontMatrix\", async () => {\n  const { CompiledFont } = await import(\"../../src/core/font_renderer.js\");\n  // An invalid fontMatrix: not all elements are numbers.\n  const invalidMatrix = [1, 0, 0, \"maliciousCode\", 0, 0];\n  // Dummy glyph code that is non-empty and does not start with 14.\n  const sampleCode = [1, 2, 3];\n  const glyphId = 0;\n  let error = null;\n  try {\n    new CompiledFont(invalidMatrix).compileGlyph(sampleCode, glyphId);\n  } catch (ex) {\n    error = ex;\n  }\n  if (!error || !/Expected a valid fontMatrix/.test(error.message)) {\n    throw new Error(\"Test failed: Expected an error with 'Expected a valid fontMatrix' to be thrown.\");\n  }\n});\n",
    "i5_llama-3.3-70b-versatile": "it(\"should throw an error when a nonnumber array is passed as fontMatrix\", async () => {\n  const { CompiledFont } = await import(\"../../src/core/font_renderer.js\");\n  // An invalid fontMatrix: not all elements are numbers.\n  const invalidMatrix = [1, 0, 0, \"maliciousCode\", 0, 0];\n  // Dummy glyph code that is non-empty and does not start with 14.\n  const sampleCode = [1, 2, 3];\n  const glyphId = 0;\n  let error = null;\n  try {\n    new CompiledFont(invalidMatrix).compileGlyph(sampleCode, glyphId);\n  } catch (ex) {\n    error = ex;\n  }\n  if (!error || !/Expected a valid fontMatrix/.test(error.message)) {\n    throw new Error(\"Test failed: Expected an error with 'Expected a valid fontMatrix' to be thrown.\");\n  }\n});\n"
  },
  "19269": {
    "i1_deepseek-r1-distill-llama-70b": "it(\"should correctly handle images with SMask\", async () => {\n  const { PartialEvaluator, OperatorList, Dict, Name } = await import(\"../../src/core/evaluator.js\");\n  const xref = new XRefMock();\n  const imageDict = new Dict();\n  imageDict.set(\"Subtype\", new Name(\"Image\"));\n  imageDict.set(\"W\", 10);\n  imageDict.set(\"H\", 10);\n  imageDict.set(\"SMask\", new Name(\"Mask\"));\n\n  const evaluator = new PartialEvaluator({\n    xref,\n    handler: {},\n    pageIndex: 0,\n    idFactory: createIdFactory(),\n    fontCache: new Map(),\n    builtInCMapCache: new Map(),\n    standardFontDataCache: new Map(),\n    globalImageCache: new Map(),\n    systemFontCache: new Map(),\n  });\n\n  const operatorList = new OperatorList();\n  const cacheKey = \"test-image\";\n  const localImageCache = new Map();\n\n  await evaluator.buildPaintImageXObject({\n    resources: new Dict(),\n    image: new Stream(new StringStream(\"\")),\n    isInline: false,\n    operatorList,\n    cacheKey,\n    localImageCache,\n    localColorSpaceCache: new Map(),\n  });\n\n  const expectedOperations = [\n    { fn: OPS.save, args: [] },\n    { fn: OPS.setGState, args: [[[\"SMask\", false]]] },\n    { fn: OPS.paintImageXObject, args: [expect.any(String), 10, 10] },\n    { fn: OPS.restore, args: [] },\n  ];\n\n  expect(operatorList.fnArray).toContain(OPS.save);\n  expect(operatorList.fnArray).toContain(OPS.setGState);\n  expect(operatorList.fnArray).toContain(OPS.paintImageXObject);\n  expect(operatorList.fnArray).toContain(OPS.restore);\n\n  expect(operatorList).toMatchSnapshot();\n});",
    "i1_gpt-4o": "it(\"should display top and bottom images in the PDF file\", async () => {\n  const { PDFImage } = await import(\"../../src/core/image.js\");\n  const { OPS } = await import(\"../../src/shared/util.js\");\n\n  const xref = new XRefMock();\n  const resources = Dict.empty;\n  const imageDict = new Dict();\n  imageDict.set(\"W\", 100);\n  imageDict.set(\"H\", 100);\n  imageDict.set(\"Subtype\", Name.get(\"Image\"));\n  const imageStream = new Stream(new Uint8Array([0, 0, 0, 0]));\n  imageStream.dict = imageDict;\n\n  const operatorList = new OperatorList();\n  const evaluator = new PartialEvaluator({\n    xref,\n    handler: null,\n    pageIndex: 0,\n    idFactory: createIdFactory(0),\n    fontCache: null,\n    builtInCMapCache: null,\n    standardFontDataCache: null,\n    globalImageCache: null,\n    systemFontCache: null,\n  });\n\n  await evaluator.buildPaintImageXObject({\n    resources,\n    image: imageStream,\n    operatorList,\n    cacheKey: null,\n    localImageCache: null,\n    localColorSpaceCache: null,\n  });\n\n  const hasSaveOp = operatorList.fnArray.includes(OPS.save);\n  const hasRestoreOp = operatorList.fnArray.includes(OPS.restore);\n  expect(hasSaveOp).toBe(true);\n  expect(hasRestoreOp).toBe(true);\n});",
    "i1_llama-3.3-70b-versatile": "it(\"should display top and bottom images in pdf file\", async () => {\n  const { PartialEvaluator, OperatorList, OPS, Dict, Name, Stream, StringStream } = await import(\"../../src/core/evaluator.js\");\n  const { XRefMock } = await import(\"./test_utils.js\");\n\n  const xref = new XRefMock();\n  const handler = {\n    sendWithPromise: async () => {},\n  };\n  const pageIndex = 0;\n  const idFactory = await import(\"../../src/core/evaluator.js\").then(({ createIdFactory }) => createIdFactory());\n  const fontCache = new Map();\n  const builtInCMapCache = new Map();\n  const standardFontDataCache = new Map();\n  const globalImageCache = new Map();\n  const systemFontCache = new Map();\n  const options = {};\n\n  const evaluator = new PartialEvaluator({\n    xref,\n    handler,\n    pageIndex,\n    idFactory,\n    fontCache,\n    builtInCMapCache,\n    standardFontDataCache,\n    globalImageCache,\n    systemFontCache,\n    options,\n  });\n\n  const resources = new Dict();\n  const image = new Stream(new StringStream(\"image data\"));\n  image.dict = new Dict();\n  image.dict.set(\"Subtype\", new Name(\"Image\"));\n  image.dict.set(\"W\", 100);\n  image.dict.set(\"H\", 100);\n  image.dict.set(\"SMask\", new Name(\"SMask\"));\n\n  const operatorList = new OperatorList();\n  await evaluator.buildPaintImageXObject({\n    resources,\n    image,\n    operatorList,\n    cacheKey: \"image\",\n    localImageCache: new Map(),\n    localColorSpaceCache: new Map(),\n  });\n\n  const hasSaveAndRestore = operatorList.fnArray.includes(OPS.save) && operatorList.fnArray.includes(OPS.restore);\n  expect(hasSaveAndRestore).toBe(true);\n});",
    "i2_deepseek-r1-distill-llama-70b": "it(\"should correctly handle images with SMaskMask entries\", async () => {\n  const { PDFDocument } = await import(\"../../src/core/document.js\");\n  const { PartialEvaluator } = await import(\"../../src/core/evaluator.js\");\n  const { OperatorList } = await import(\"../../src/core/operator_list.js\");\n  const { OPS } = await import(\"../../src/shared/util.js\");\n\n  // Create a sample PDF with an image that includes an SMask\n  const pdfData = new Uint8Array([\n    0x25, 0x50, 0x44, 0x46, 0x2D, 0x31, 0x2E, 0x30, 0x0A, 0x25, 0x5E, 0x2D, 0x5E, 0x2D, 0x0A,\n    0x31, 0x30, 0x20, 0x6F, 0x62, 0x6A, 0x0A, 0x24, 0x2F, 0x53, 0x4D, 0x61, 0x73, 0x6B, 0x0A,\n    0x32, 0x30, 0x20, 0x6F, 0x62, 0x6A, 0x0A, 0x24, 0x2F, 0x54, 0x79, 0x70, 0x65, 0x0A,\n    0x2F, 0x53, 0x75, 0x62, 0x74, 0x79, 0x70, 0x65, 0x2F, 0x58, 0x4F, 0x62, 0x6A, 0x0A,\n    0x3E, 0x3C, 0x58, 0x4F, 0x5A, 0x3E, 0x0A, 0x26, 0x31, 0x30, 0x20, 0x52, 0x45, 0x46, 0x0A,\n    0x25, 0x50, 0x44, 0x46, 0x2D, 0x31, 0x2E, 0x30, 0x0A, 0x25, 0x5E, 0x2D, 0x5E, 0x2D, 0x0A,\n    0x31, 0x30, 0x20, 0x6F, 0x62, 0x6A, 0x0A, 0x24, 0x2F, 0x53, 0x4D, 0x61, 0x73, 0x6B, 0x0A,\n    0x32, 0x30, 0x20, 0x6F, 0x62, 0x6A, 0x0A, 0x24, 0x2F, 0x54, 0x79, 0x70, 0x65, 0x0A,\n    0x2F, 0x53, 0x75, 0x62, 0x74, 0x79, 0x70, 0x65, 0x2F, 0x58, 0x4F, 0x62, 0x6A, 0x0A,\n    0x3E, 0x3C, 0x58, 0x4F, 0x5A, 0x3E, 0x0A\n  ]);\n\n  const pdf = await PDFDocument.load(pdfData);\n  const evaluator = new PartialEvaluator({\n    xref: pdf.xref,\n    handler: null,\n    pageIndex: 0,\n    idFactory: pdf.idFactory,\n    fontCache: new Map(),\n    builtInCMapCache: new Map(),\n    standardFontDataCache: new Map(),\n    globalImageCache: new Map(),\n    systemFontCache: new Map(),\n    options: {}\n  });\n\n  const operatorList = new OperatorList();\n  const page = pdf.getPage(1);\n  await evaluator.getOperatorList({\n    stream: page.stream,\n    task: page,\n    resources: page.resources,\n    operatorList: operatorList\n  });\n\n  const ops = operatorList.fnArray;\n  const expectedSequence = [\n    OPS.save,\n    OPS.setGState,\n    OPS.paintImageXObject,\n    OPS.restore\n  ];\n\n  let found = 0;\n  for (let i = 0; i < ops.length; i++) {\n    if (ops[i] === expectedSequence[found]) {\n      found++;\n      if (found === expectedSequence.length) break;\n    }\n  }\n\n  expect(found).toBe(expectedSequence.length);\n});",
    "i2_gpt-4o": "it(\"should correctly handle images with SMaskMask entries\", async () => {\n  const { PDFDocument } = await import(\"../../src/core/document.js\");\n  const { getDocument } = await import(\"../../src/display/api.js\");\n\n  const pdfUrl = \"path/to/test/pdf/with/smask_mask_entries.pdf\";\n  const loadingTask = getDocument(pdfUrl);\n  const pdfDocument = await loadingTask.promise;\n  const pdfPage = await pdfDocument.getPage(1);\n\n  const operatorList = await pdfPage.getOperatorList();\n  const hasSMaskOps = operatorList.fnArray.includes(OPS.setGState);\n\n  const expected = true;\n  const actual = hasSMaskOps;\n\n  expect(actual).toBe(expected);\n});",
    "i2_llama-3.3-70b-versatile": "it(\"should display top and bottom images in pdf file\", async () => {\n  const { PDFDocument } = await import(\"../../src/core/document.js\");\n  const { PDFPage } = await import(\"../../src/core/document.js\");\n  const { PartialEvaluator } = await import(\"../../src/core/evaluator.js\");\n  const { OperatorList } = await import(\"../../src/core/operator_list.js\");\n  const { PDFImage } = await import(\"../../src/core/image.js\");\n\n  const pdfDoc = await PDFDocument.load(await fetch(\"path_to_pdf_file.pdf\").then(response => response.arrayBuffer()));\n  const page = pdfDoc.getPage(1);\n  const operatorList = new OperatorList();\n  const evaluator = new PartialEvaluator({\n    xref: pdfDoc.xref,\n    handler: null,\n    pageIndex: 0,\n    idFactory: null,\n    fontCache: null,\n    builtInCMapCache: null,\n    standardFontDataCache: null,\n    globalImageCache: null,\n    systemFontCache: null,\n  });\n\n  await evaluator.getOperatorList({\n    stream: page.stream,\n    task: null,\n    resources: page.resources,\n    operatorList,\n    initialState: null,\n    fallbackFontDict: null,\n  });\n\n  const expectedImages = 2; // assuming there are 2 images in the pdf file\n  const actualImages = operatorList.fnArray.filter(fn => fn === \"paintImageXObject\" || fn === \"paintInlineImageXObject\").length;\n\n  expect(actualImages).toBe(expectedImages);\n});",
    "i3_deepseek-r1-distill-llama-70b": "it(\"should correctly handle images with masks\", async () => {\n  const xref = new XRefMock();\n  const evaluator = new PartialEvaluator({\n    xref,\n    handler: new WorkerTask(),\n    pageIndex: 0,\n    idFactory: createIdFactory(),\n    fontCache: new Map(),\n    builtInCMapCache: new Map(),\n    standardFontDataCache: new Map(),\n    globalImageCache: new Map(),\n    systemFontCache: new Map(),\n    options: DefaultPartialEvaluatorOptions,\n  });\n\n  const image = {\n    dict: new Dict({\n      Type: \"XObject\",\n      Subtype: \"Image\",\n      SMask: new Dict(),\n    }),\n    args: [\"img1\"],\n  };\n\n  const operatorList = new OperatorList();\n\n  addLocallyCachedImageOps(operatorList, image);\n\n  expect(operatorList.fnArray).toContain(OPS.save);\n  expect(operatorList.fnArray).toContain(OPS.setGState);\n  expect(operatorList.fnArray).toContain(OPS.paintImageXObject);\n  expect(operatorList.fnArray).toContain(OPS.restore);\n});",
    "i3_llama-3.3-70b-versatile": "it(\"should display top and bottom images in pdf file\", async () => {\n  const xref = new XRefMock();\n  const handler = {\n    send: jest.fn(),\n    sendWithPromise: jest.fn(),\n  };\n  const idFactory = createIdFactory();\n  const evaluator = new PartialEvaluator({\n    xref,\n    handler,\n    pageIndex: 0,\n    idFactory,\n  });\n  const dict = new Dict();\n  dict.set(\"Subtype\", new Name(\"Image\"));\n  dict.set(\"Width\", 100);\n  dict.set(\"Height\", 100);\n  dict.set(\"SMask\", new Name(\"None\"));\n  dict.set(\"Mask\", new Name(\"None\"));\n  const image = new Stream(new StringStream(\"image data\"), dict);\n  xref.fetch = jest.fn().mockReturnValue(image);\n  const operatorList = new OperatorList();\n  await evaluator.buildPaintImageXObject({\n    resources: new Dict(),\n    image,\n    operatorList,\n  });\n  expect(handler.send).toHaveBeenCalledTimes(1);\n});",
    "i4_deepseek-r1-distill-llama-70b": "it(\"should render top and bottom images with masks\", async () => {\n  const { pdfjsLib } = await import(\"../../src/core/pdfjsLib.js\");\n  const { PDFDocument } = pdfjsLib;\n  const { OPS } = await import(\"../../src/core/evaluator.js\");\n\n  // Create a test PDF with top and bottom images\n  const pdf = new PDFDocument();\n  const page = pdf.addPage();\n\n  // Create top image with mask\n  const topImage = new pdf.Image();\n  topImage.scale(1, 1);\n  topImage.setMask(\"auto\");\n\n  // Create bottom image with mask\n  const bottomImage = new pdf.Image();\n  bottomImage.scale(1, 1);\n  bottomImage.setMask(\"auto\");\n\n  page.drawImage(topImage, 0, 0);\n  page.drawImage(bottomImage, 0, 500);\n\n  // Mock the PDF fetch\n  const pdfData = await pdf.writeAsync();\n  const pdfBlob = new Blob([pdfData.buffer], { type: \"application/pdf\" });\n  const pdfUrl = URL.createObjectURL(pdfBlob);\n\n  global.fetch = jest.fn(() =>\n    Promise.resolve({ blob: () => Promise.resolve(pdfBlob) })\n  );\n\n  // Load the document and render the page\n  const loadingTask = pdfjsLib.getDocument(pdfUrl);\n  const document = await loadingTask.promise;\n  const pageProxy = await document.getPage(1);\n  const operatorList = await pageProxy.getOperatorList();\n\n  // Check if the operator list includes the expected operations for top and bottom images\n  const expectedOps = [\n    OPS.save,\n    OPS.setGState,\n    OPS.paintImageMaskXObject,\n    OPS.restore,\n    OPS.save,\n    OPS.setGState,\n    OPS.paintImageMaskXObject,\n    OPS.restore\n  ];\n\n  expect(operatorList.fnArray).toContain(OPS.save);\n  expect(operatorList.fnArray).toContain(OPS.setGState);\n  expect(operatorList.fnArray).toContain(OPS.paintImageMaskXObject);\n  expect(operatorList.fnArray).toContain(OPS.restore);\n});",
    "i4_gpt-4o": "it(\"should display top and bottom images in pdf file\", async () => {\n  const { PartialEvaluator } = await import(\"../../src/core/evaluator.js\");\n  const { OperatorList } = await import(\"../../src/core/operator_list.js\");\n  const { OPS } = await import(\"../../src/shared/util.js\");\n\n  const evaluator = new PartialEvaluator({\n    xref: null,\n    handler: null,\n    pageIndex: 0,\n    idFactory: null,\n    fontCache: null,\n    builtInCMapCache: null,\n    standardFontDataCache: null,\n    globalImageCache: null,\n    systemFontCache: null,\n  });\n\n  const operatorList = new OperatorList();\n  const resources = { get: () => null };\n  const image = {\n    dict: {\n      get: (key) => {\n        if (key === \"W\") return 100;\n        if (key === \"H\") return 100;\n        if (key === \"SMask\" || key === \"Mask\") return false;\n        return null;\n      },\n      objId: \"image1\",\n    },\n    getBytes: () => new Uint8Array(10000),\n  };\n\n  await evaluator.buildPaintImageXObject({\n    resources,\n    image,\n    operatorList,\n    cacheKey: \"image1\",\n    localImageCache: null,\n    localColorSpaceCache: null,\n  });\n\n  const expectedOps = [OPS.paintImageXObject];\n  const actualOps = operatorList.fnArray;\n\n  expect(actualOps).toEqual(expectedOps);\n});",
    "i4_llama-3.3-70b-versatile": "it(\"should render top and bottom images in pdf file\", async () => {\n  const { PartialEvaluator } = await import(\"../../src/core/evaluator.js\");\n  const { OperatorList } = await import(\"../../src/core/operator_list.js\");\n  const evaluator = new PartialEvaluator({\n    xref: {},\n    handler: {},\n    pageIndex: 0,\n    idFactory: {},\n    fontCache: {},\n    builtInCMapCache: {},\n    standardFontDataCache: {},\n    globalImageCache: {},\n    systemFontCache: {},\n    options: {},\n  });\n  const operatorList = new OperatorList();\n  const image = {\n    dict: {\n      Subtype: \"Image\",\n      Width: 100,\n      Height: 100,\n      ColorSpace: \"DeviceRGB\",\n      BitsPerComponent: 8,\n      Filter: \"DCTDecode\",\n    },\n    getBytes: () => new Uint8Array(100 * 100 * 3),\n  };\n  const hasMask = true;\n  evaluator.buildPaintImageXObject({\n    resources: {},\n    image,\n    isInline: false,\n    operatorList,\n    cacheKey: \"image\",\n    localImageCache: {},\n    localColorSpaceCache: {},\n  });\n  const expectedOps = [\n    \"save\",\n    \"setGState\",\n    [\"SMask\", false],\n    \"paintImageXObject\",\n    \"restore\",\n  ];\n  const actualOps = operatorList.getIR().fnArray;\n  actualOps.push(...operatorList.getIR().argsArray.map((arg) => arg[0]));\n  expect(actualOps).toEqual(expect.arrayContaining(expectedOps));\n});",
    "i5_deepseek-r1-distill-llama-70b": "it(\"should display images with masks in PDF files\", async () => {\n  const { PDFDocument } = await import(\"../../src/core/document.js\");\n  const { PDFPageProxy } = await import(\"../../src/display/api.js\");\n  const { OperatorList } = await import(\"../../src/core/operator_list.js\");\n\n  // Create a simple PDF with an image that has a mask\n  const pdf = new PDFDocument();\n  const page = pdf.addPage();\n  const xref = pdf.xref;\n  const imageRef = pdf.ref();\n  const image = pdf.image();\n  image.hasMask = true;\n\n  // Draw the image on the page\n  page.drawImage(image, 100, 100, 200, 200);\n\n  // Save the PDF\n  const pdfBuffer = await pdf.save();\n\n  // Load the PDF back\n  const pdfDoc = await PDFDocument.load(pdfBuffer);\n  const pageProxy = (await pdfDoc.getPage(1)) as PDFPageProxy;\n\n  // Render the page and check if the image is present\n  const operatorList = await pageProxy.getOperatorList();\n  const drawImageOps = operatorList.ops.some(op => op.fn === OPS.drawImage);\n\n  expect(drawImageOps).toBe(true);\n});",
    "i5_gpt-4o": "it(\"should display top and bottom images in the PDF file\", async () => {\n  const { PDFDocumentProxy, getDocument } = await import(\"../../src/display/api.js\");\n  const { buildGetDocumentParams } = await import(\"./test_utils.js\");\n\n  const loadingTask = getDocument(buildGetDocumentParams(\"test_pdf_with_images.pdf\"));\n  const pdfDocument = await loadingTask.promise;\n  const page = await pdfDocument.getPage(1);\n\n  const operatorList = await page.getOperatorList();\n  const imageOps = operatorList.fnArray.filter(fn => fn === OPS.paintImageXObject);\n\n  const expectedImageOpsCount = 2; // Expecting top and bottom images\n  const actualImageOpsCount = imageOps.length;\n\n  expect(actualImageOpsCount).toBe(expectedImageOpsCount);\n});",
    "i5_llama-3.3-70b-versatile": "it(\"should display top and bottom images in pdf file\", async () => {\n  const { PDFDocument } = await import(\"../../src/core/document.js\");\n  const { PartialEvaluator } = await import(\"../../src/core/evaluator.js\");\n  const { OperatorList } = await import(\"../../src/core/operator_list.js\");\n  const { TestPdfsServer } = await import(\"./test_utils.js\");\n\n  const server = new TestPdfsServer();\n  const pdf = await PDFDocument.load(server.crossOriginUrl(\"issue-pdf.pdf\"));\n  const page = pdf.getPage(1);\n  const evaluator = new PartialEvaluator();\n  const operatorList = new OperatorList();\n\n  await page.render({\n    canvasContext: null,\n    viewport: page.getViewport({ scale: 1 }),\n    renderInteractive: false,\n    evaluator,\n    operatorList,\n  });\n\n  const expectedOps = [\n    \"save\",\n    \"setGState\",\n    \"beginMarkedContentProps\",\n    \"paintImageXObject\",\n    \"endMarkedContent\",\n    \"restore\",\n  ];\n\n  const actualOps = operatorList.ops.map((op) => op.fn);\n\n  expect(actualOps).toEqual(expect.arrayContaining(expectedOps));\n});"
  },
  "19305": {
    "i1_deepseek-r1-distill-llama-70b": "it(\"should correctly extract bbox and background for MeshShadingPattern\", async () => {\n  const { MeshShadingPattern } = await import(\"../../src/display/pattern_helper.js\");\n  const IR = [null, null, \"coords\", \"colors\", \"figures\", \"bounds\", \"expected_bbox\", \"expected_background\"];\n  const pattern = new MeshShadingPattern(IR);\n  expect(pattern._bbox).toEqual(\"expected_bbox\");\n  expect(pattern._background).toEqual(\"expected_background\");\n});",
    "i1_gpt-4o": "it(\"should correctly extract bbox and background for MeshShadingPattern\", async () => {\n  const { MeshShadingPattern } = await import(\"../../src/display/pattern_helper.js\");\n  const IR = [null, null, \"coords\", \"colors\", \"figures\", \"bounds\", \"expected_bbox\", \"expected_background\"];\n  const pattern = new MeshShadingPattern(IR);\n  expect(pattern._bbox).toEqual(\"expected_bbox\");\n  expect(pattern._background).toEqual(\"expected_background\");\n});",
    "i1_llama-3.3-70b-versatile": "it(\"should correctly extract bbox and background for MeshShadingPattern\", async () => {\n  const { MeshShadingPattern } = await import(\"../../src/display/pattern_helper.js\");\n  const IR = [null, null, \"coords\", \"colors\", \"figures\", \"bounds\", \"expected_bbox\", \"expected_background\"];\n  const pattern = new MeshShadingPattern(IR);\n  expect(pattern._bbox).toEqual(\"expected_bbox\");\n  expect(pattern._background).toEqual(\"expected_background\");\n});",
    "i1_MOCK": "it(\"should correctly extract bbox and background for MeshShadingPattern\", async () => {\n  const { MeshShadingPattern } = await import(\"../../src/display/pattern_helper.js\");\n  const IR = [null, null, \"coords\", \"colors\", \"figures\", \"bounds\", \"expected_bbox\", \"expected_background\"];\n  const pattern = new MeshShadingPattern(IR);\n  expect(pattern._bbox).toEqual(\"expected_bbox\");\n  expect(pattern._background).toEqual(\"expected_background\");\n});",
    "i2_deepseek-r1-distill-llama-70b": "it(\"should correctly extract bbox and background for MeshShadingPattern\", async () => {\n  const { MeshShadingPattern } = await import(\"../../src/display/pattern_helper.js\");\n  const IR = [null, null, \"coords\", \"colors\", \"figures\", \"bounds\", \"expected_bbox\", \"expected_background\"];\n  const pattern = new MeshShadingPattern(IR);\n  expect(pattern._bbox).toEqual(\"expected_bbox\");\n  expect(pattern._background).toEqual(\"expected_background\");\n});",
    "i2_gpt-4o": "it(\"should correctly extract bbox and background for MeshShadingPattern\", async () => {\n  const { MeshShadingPattern } = await import(\"../../src/display/pattern_helper.js\");\n  const IR = [null, null, \"coords\", \"colors\", \"figures\", \"bounds\", \"expected_bbox\", \"expected_background\"];\n  const pattern = new MeshShadingPattern(IR);\n  expect(pattern._bbox).toEqual(\"expected_bbox\");\n  expect(pattern._background).toEqual(\"expected_background\");\n});",
    "i2_llama-3.3-70b-versatile": "it(\"should correctly extract bbox and background for MeshShadingPattern\", async () => {\n  const { MeshShadingPattern } = await import(\"../../src/display/pattern_helper.js\");\n  const IR = [null, null, \"coords\", \"colors\", \"figures\", \"bounds\", \"expected_bbox\", \"expected_background\"];\n  const pattern = new MeshShadingPattern(IR);\n  expect(pattern._bbox).toEqual(\"expected_bbox\");\n  expect(pattern._background).toEqual(\"expected_background\");\n});",
    "i3_deepseek-r1-distill-llama-70b": "it(\"should correctly extract bbox and background for MeshShadingPattern\", async () => {\n  const { MeshShadingPattern } = await import(\"../../src/display/pattern_helper.js\");\n  const IR = [null, null, \"coords\", \"colors\", \"figures\", \"bounds\", \"expected_bbox\", \"expected_background\"];\n  const pattern = new MeshShadingPattern(IR);\n  expect(pattern._bbox).toEqual(\"expected_bbox\");\n  expect(pattern._background).toEqual(\"expected_background\");\n});",
    "i3_gpt-4o": "it(\"should correctly extract bbox and background for MeshShadingPattern\", async () => {\n  const { MeshShadingPattern } = await import(\"../../src/display/pattern_helper.js\");\n  const IR = [null, null, \"coords\", \"colors\", \"figures\", \"bounds\", \"expected_bbox\", \"expected_background\"];\n  const pattern = new MeshShadingPattern(IR);\n  expect(pattern._bbox).toEqual(\"expected_bbox\");\n  expect(pattern._background).toEqual(\"expected_background\");\n});",
    "i3_llama-3.3-70b-versatile": "it(\"should correctly extract bbox and background for MeshShadingPattern\", async () => {\n  const { MeshShadingPattern } = await import(\"../../src/display/pattern_helper.js\");\n  const IR = [null, null, \"coords\", \"colors\", \"figures\", \"bounds\", \"expected_bbox\", \"expected_background\"];\n  const pattern = new MeshShadingPattern(IR);\n  expect(pattern._bbox).toEqual(\"expected_bbox\");\n  expect(pattern._background).toEqual(\"expected_background\");\n});",
    "i4_deepseek-r1-distill-llama-70b": "it(\"should correctly extract bbox and background for MeshShadingPattern\", async () => {\n  const { MeshShadingPattern } = await import(\"../../src/display/pattern_helper.js\");\n  const IR = [null, null, \"coords\", \"colors\", \"figures\", \"bounds\", \"expected_bbox\", \"expected_background\"];\n  const pattern = new MeshShadingPattern(IR);\n  expect(pattern._bbox).toEqual(\"expected_bbox\");\n  expect(pattern._background).toEqual(\"expected_background\");\n});",
    "i4_gpt-4o": "it(\"should correctly extract bbox and background for MeshShadingPattern\", async () => {\n  const { MeshShadingPattern } = await import(\"../../src/display/pattern_helper.js\");\n  const IR = [null, null, \"coords\", \"colors\", \"figures\", \"bounds\", \"expected_bbox\", \"expected_background\"];\n  const pattern = new MeshShadingPattern(IR);\n  expect(pattern._bbox).toEqual(\"expected_bbox\");\n  expect(pattern._background).toEqual(\"expected_background\");\n});",
    "i4_llama-3.3-70b-versatile": "it(\"should correctly extract bbox and background for MeshShadingPattern\", async () => {\n  const { MeshShadingPattern } = await import(\"../../src/display/pattern_helper.js\");\n  const IR = [null, null, \"coords\", \"colors\", \"figures\", \"bounds\", \"expected_bbox\", \"expected_background\"];\n  const pattern = new MeshShadingPattern(IR);\n  expect(pattern._bbox).toEqual(\"expected_bbox\");\n  expect(pattern._background).toEqual(\"expected_background\");\n});",
    "i5_deepseek-r1-distill-llama-70b": "it(\"should correctly extract bbox and background for MeshShadingPattern\", async () => {\n  const { MeshShadingPattern } = await import(\"../../src/display/pattern_helper.js\");\n  const IR = [null, null, \"coords\", \"colors\", \"figures\", \"bounds\", \"expected_bbox\", \"expected_background\"];\n  const pattern = new MeshShadingPattern(IR);\n  expect(pattern._bbox).toEqual(\"expected_bbox\");\n  expect(pattern._background).toEqual(\"expected_background\");\n});",
    "i5_gpt-4o": "it(\"should correctly extract bbox and background for MeshShadingPattern\", async () => {\n  const { MeshShadingPattern } = await import(\"../../src/display/pattern_helper.js\");\n  const IR = [null, null, \"coords\", \"colors\", \"figures\", \"bounds\", \"expected_bbox\", \"expected_background\"];\n  const pattern = new MeshShadingPattern(IR);\n  expect(pattern._bbox).toEqual(\"expected_bbox\");\n  expect(pattern._background).toEqual(\"expected_background\");\n});",
    "i5_llama-3.3-70b-versatile": "it(\"should correctly extract bbox and background for MeshShadingPattern\", async () => {\n  const { MeshShadingPattern } = await import(\"../../src/display/pattern_helper.js\");\n  const IR = [null, null, \"coords\", \"colors\", \"figures\", \"bounds\", \"expected_bbox\", \"expected_background\"];\n  const pattern = new MeshShadingPattern(IR);\n  expect(pattern._bbox).toEqual(\"expected_bbox\");\n  expect(pattern._background).toEqual(\"expected_background\");\n});"
  },
  "19321": {
    "i1_deepseek-r1-distill-llama-70b": "it(\"should render all pages of a PDF with duplicate font mappings\", async () => {\n  const pdfDoc = await getDocument({ url: `${TEST_PDFS_PATH}/2023-ESG-report-eng.pdf` }).promise;\n  assert(pdfDoc.numPages > 1, \"Expected PDF to have more than one page\");\n});",
    "i1_gpt-4o": "it(\"should render all pages of a PDF with duplicate font mappings\", async () => {\n  const pdfDoc = await getDocument({ url: `${TEST_PDFS_PATH}/2023-ESG-report-eng.pdf` }).promise;\n  assert(pdfDoc.numPages > 1, \"Expected PDF to have more than one page\");\n});",
    "i1_llama-3.3-70b-versatile": "it(\"should render all pages of a PDF with duplicate font mappings\", async () => {\n  const pdfDoc = await getDocument({ url: `${TEST_PDFS_PATH}/2023-ESG-report-eng.pdf` }).promise;\n  assert(pdfDoc.numPages > 1, \"Expected PDF to have more than one page\");\n});",
    "i1_MOCK": "it(\"should render all pages of a PDF with duplicate font mappings\", async () => {\n  const pdfDoc = await getDocument({ url: `${TEST_PDFS_PATH}/2023-ESG-report-eng.pdf` }).promise;\n  assert(pdfDoc.numPages > 1, \"Expected PDF to have more than one page\");\n});",
    "i2_deepseek-r1-distill-llama-70b": "it(\"should render all pages of a PDF with duplicate font mappings\", async () => {\n  const pdfDoc = await getDocument({ url: `${TEST_PDFS_PATH}/2023-ESG-report-eng.pdf` }).promise;\n  assert(pdfDoc.numPages > 1, \"Expected PDF to have more than one page\");\n});",
    "i2_gpt-4o": "it(\"should render all pages of a PDF with duplicate font mappings\", async () => {\n  const pdfDoc = await getDocument({ url: `${TEST_PDFS_PATH}/2023-ESG-report-eng.pdf` }).promise;\n  assert(pdfDoc.numPages > 1, \"Expected PDF to have more than one page\");\n});",
    "i2_llama-3.3-70b-versatile": "it(\"should render all pages of a PDF with duplicate font mappings\", async () => {\n  const pdfDoc = await getDocument({ url: `${TEST_PDFS_PATH}/2023-ESG-report-eng.pdf` }).promise;\n  assert(pdfDoc.numPages > 1, \"Expected PDF to have more than one page\");\n});",
    "i3_deepseek-r1-distill-llama-70b": "it(\"should render all pages of a PDF with duplicate font mappings\", async () => {\n  const pdfDoc = await getDocument({ url: `${TEST_PDFS_PATH}/2023-ESG-report-eng.pdf` }).promise;\n  assert(pdfDoc.numPages > 1, \"Expected PDF to have more than one page\");\n});",
    "i3_gpt-4o": "it(\"should render all pages of a PDF with duplicate font mappings\", async () => {\n  const pdfDoc = await getDocument({ url: `${TEST_PDFS_PATH}/2023-ESG-report-eng.pdf` }).promise;\n  assert(pdfDoc.numPages > 1, \"Expected PDF to have more than one page\");\n});",
    "i3_llama-3.3-70b-versatile": "it(\"should render all pages of a PDF with duplicate font mappings\", async () => {\n  const pdfDoc = await getDocument({ url: `${TEST_PDFS_PATH}/2023-ESG-report-eng.pdf` }).promise;\n  assert(pdfDoc.numPages > 1, \"Expected PDF to have more than one page\");\n});",
    "i4_deepseek-r1-distill-llama-70b": "it(\"should render all pages of a PDF with duplicate font mappings\", async () => {\n  const pdfDoc = await getDocument({ url: `${TEST_PDFS_PATH}/2023-ESG-report-eng.pdf` }).promise;\n  assert(pdfDoc.numPages > 1, \"Expected PDF to have more than one page\");\n});",
    "i4_gpt-4o": "it(\"should render all pages of a PDF with duplicate font mappings\", async () => {\n  const pdfDoc = await getDocument({ url: `${TEST_PDFS_PATH}/2023-ESG-report-eng.pdf` }).promise;\n  assert(pdfDoc.numPages > 1, \"Expected PDF to have more than one page\");\n});",
    "i4_llama-3.3-70b-versatile": "it(\"should render all pages of a PDF with duplicate font mappings\", async () => {\n  const pdfDoc = await getDocument({ url: `${TEST_PDFS_PATH}/2023-ESG-report-eng.pdf` }).promise;\n  assert(pdfDoc.numPages > 1, \"Expected PDF to have more than one page\");\n});",
    "i5_deepseek-r1-distill-llama-70b": "it(\"should render all pages of a PDF with duplicate font mappings\", async () => {\n  const pdfDoc = await getDocument({ url: `${TEST_PDFS_PATH}/2023-ESG-report-eng.pdf` }).promise;\n  assert(pdfDoc.numPages > 1, \"Expected PDF to have more than one page\");\n});",
    "i5_gpt-4o": "it(\"should render all pages of a PDF with duplicate font mappings\", async () => {\n  const pdfDoc = await getDocument({ url: `${TEST_PDFS_PATH}/2023-ESG-report-eng.pdf` }).promise;\n  assert(pdfDoc.numPages > 1, \"Expected PDF to have more than one page\");\n});",
    "i5_llama-3.3-70b-versatile": "it(\"should render all pages of a PDF with duplicate font mappings\", async () => {\n  const pdfDoc = await getDocument({ url: `${TEST_PDFS_PATH}/2023-ESG-report-eng.pdf` }).promise;\n  assert(pdfDoc.numPages > 1, \"Expected PDF to have more than one page\");\n});"
  },
  "19327": {
    "i1_deepseek-r1-distill-llama-70b": "it(\"should set jpxDecoderOptions.numComponents correctly for JPXDecode images\", async () => {\n  const { PDFImage } = await import(\"../../src/core/image.js\");\n  const { Name } = await import(\"../../src/core/primitives.js\");\n  const { PDFFunctionFactory } = await import(\"../../src/core/function.js\");\n  const { JpxImage } = await import(\"../../src/core/jpx.js\");\n  const originalParse = JpxImage.parseImageProperties;\n  JpxImage.parseImageProperties = () => ({\n    width: 100,\n    height: 100,\n    componentsCount: 3,\n    bitsPerComponent: 8,\n  });\n  const fakeStream = { reset() {} };\n  const fakeDict = {\n    get(key) {\n      if (key === \"F\") return new Name(\"JPXDecode\");\n      if (key === \"W\") return 100;\n      if (key === \"H\") return 100;\n      if (key === \"I\") return false;\n      if (key === \"IM\") return false;\n    },\n    getRaw(key) {\n      if (key === \"CS\") return new Name(\"DeviceRGB\");\n    },\n    has(key) {\n      if (key === \"SMaskInData\") return false;\n      return false;\n    },\n  };\n  const fakeImage = { dict: fakeDict, stream: fakeStream, bitsPerComponent: null };\n  const pdfImage = new PDFImage({\n    xref: {},\n    res: {},\n    image: fakeImage,\n    pdfFunctionFactory: new PDFFunctionFactory(),\n    localColorSpaceCache: {},\n  });\n  JpxImage.parseImageProperties = originalParse;\n  if (!pdfImage.jpxDecoderOptions) {\n    throw new Error(\"jpxDecoderOptions is not defined\");\n  }\n  if (pdfImage.jpxDecoderOptions.numComponents !== 3) {\n    throw new Error(\n      `Expected jpxDecoderOptions.numComponents to be 3 but got ${pdfImage.jpxDecoderOptions.numComponents}`\n    );\n  }\n});",
    "i1_gpt-4o": "it(\"should set jpxDecoderOptions.numComponents correctly for JPXDecode images\", async () => {\n  const { PDFImage } = await import(\"../../src/core/image.js\");\n  const { Name } = await import(\"../../src/core/primitives.js\");\n  const { PDFFunctionFactory } = await import(\"../../src/core/function.js\");\n  const { JpxImage } = await import(\"../../src/core/jpx.js\");\n  const originalParse = JpxImage.parseImageProperties;\n  JpxImage.parseImageProperties = () => ({\n    width: 100,\n    height: 100,\n    componentsCount: 3,\n    bitsPerComponent: 8,\n  });\n  const fakeStream = { reset() {} };\n  const fakeDict = {\n    get(key) {\n      if (key === \"F\") return new Name(\"JPXDecode\");\n      if (key === \"W\") return 100;\n      if (key === \"H\") return 100;\n      if (key === \"I\") return false;\n      if (key === \"IM\") return false;\n    },\n    getRaw(key) {\n      if (key === \"CS\") return new Name(\"DeviceRGB\");\n    },\n    has(key) {\n      if (key === \"SMaskInData\") return false;\n      return false;\n    },\n  };\n  const fakeImage = { dict: fakeDict, stream: fakeStream, bitsPerComponent: null };\n  const pdfImage = new PDFImage({\n    xref: {},\n    res: {},\n    image: fakeImage,\n    pdfFunctionFactory: new PDFFunctionFactory(),\n    localColorSpaceCache: {},\n  });\n  JpxImage.parseImageProperties = originalParse;\n  if (!pdfImage.jpxDecoderOptions) {\n    throw new Error(\"jpxDecoderOptions is not defined\");\n  }\n  if (pdfImage.jpxDecoderOptions.numComponents !== 3) {\n    throw new Error(\n      `Expected jpxDecoderOptions.numComponents to be 3 but got ${pdfImage.jpxDecoderOptions.numComponents}`\n    );\n  }\n});",
    "i1_llama-3.3-70b-versatile": "it(\"should set jpxDecoderOptions.numComponents correctly for JPXDecode images\", async () => {\n  const { PDFImage } = await import(\"../../src/core/image.js\");\n  const { Name } = await import(\"../../src/core/primitives.js\");\n  const { PDFFunctionFactory } = await import(\"../../src/core/function.js\");\n  const { JpxImage } = await import(\"../../src/core/jpx.js\");\n  const originalParse = JpxImage.parseImageProperties;\n  JpxImage.parseImageProperties = () => ({\n    width: 100,\n    height: 100,\n    componentsCount: 3,\n    bitsPerComponent: 8,\n  });\n  const fakeStream = { reset() {} };\n  const fakeDict = {\n    get(key) {\n      if (key === \"F\") return new Name(\"JPXDecode\");\n      if (key === \"W\") return 100;\n      if (key === \"H\") return 100;\n      if (key === \"I\") return false;\n      if (key === \"IM\") return false;\n    },\n    getRaw(key) {\n      if (key === \"CS\") return new Name(\"DeviceRGB\");\n    },\n    has(key) {\n      if (key === \"SMaskInData\") return false;\n      return false;\n    },\n  };\n  const fakeImage = { dict: fakeDict, stream: fakeStream, bitsPerComponent: null };\n  const pdfImage = new PDFImage({\n    xref: {},\n    res: {},\n    image: fakeImage,\n    pdfFunctionFactory: new PDFFunctionFactory(),\n    localColorSpaceCache: {},\n  });\n  JpxImage.parseImageProperties = originalParse;\n  if (!pdfImage.jpxDecoderOptions) {\n    throw new Error(\"jpxDecoderOptions is not defined\");\n  }\n  if (pdfImage.jpxDecoderOptions.numComponents !== 3) {\n    throw new Error(\n      `Expected jpxDecoderOptions.numComponents to be 3 but got ${pdfImage.jpxDecoderOptions.numComponents}`\n    );\n  }\n});",
    "i1_MOCK": "it(\"should set jpxDecoderOptions.numComponents correctly for JPXDecode images\", async () => {\n  const { PDFImage } = await import(\"../../src/core/image.js\");\n  const { Name } = await import(\"../../src/core/primitives.js\");\n  const { PDFFunctionFactory } = await import(\"../../src/core/function.js\");\n  const { JpxImage } = await import(\"../../src/core/jpx.js\");\n  const originalParse = JpxImage.parseImageProperties;\n  JpxImage.parseImageProperties = () => ({\n    width: 100,\n    height: 100,\n    componentsCount: 3,\n    bitsPerComponent: 8,\n  });\n  const fakeStream = { reset() {} };\n  const fakeDict = {\n    get(key) {\n      if (key === \"F\") return new Name(\"JPXDecode\");\n      if (key === \"W\") return 100;\n      if (key === \"H\") return 100;\n      if (key === \"I\") return false;\n      if (key === \"IM\") return false;\n    },\n    getRaw(key) {\n      if (key === \"CS\") return new Name(\"DeviceRGB\");\n    },\n    has(key) {\n      if (key === \"SMaskInData\") return false;\n      return false;\n    },\n  };\n  const fakeImage = { dict: fakeDict, stream: fakeStream, bitsPerComponent: null };\n  const pdfImage = new PDFImage({\n    xref: {},\n    res: {},\n    image: fakeImage,\n    pdfFunctionFactory: new PDFFunctionFactory(),\n    localColorSpaceCache: {},\n  });\n  JpxImage.parseImageProperties = originalParse;\n  if (!pdfImage.jpxDecoderOptions) {\n    throw new Error(\"jpxDecoderOptions is not defined\");\n  }\n  if (pdfImage.jpxDecoderOptions.numComponents !== 3) {\n    throw new Error(\n      `Expected jpxDecoderOptions.numComponents to be 3 but got ${pdfImage.jpxDecoderOptions.numComponents}`\n    );\n  }\n});",
    "i2_deepseek-r1-distill-llama-70b": "it(\"should set jpxDecoderOptions.numComponents correctly for JPXDecode images\", async () => {\n  const { PDFImage } = await import(\"../../src/core/image.js\");\n  const { Name } = await import(\"../../src/core/primitives.js\");\n  const { PDFFunctionFactory } = await import(\"../../src/core/function.js\");\n  const { JpxImage } = await import(\"../../src/core/jpx.js\");\n  const originalParse = JpxImage.parseImageProperties;\n  JpxImage.parseImageProperties = () => ({\n    width: 100,\n    height: 100,\n    componentsCount: 3,\n    bitsPerComponent: 8,\n  });\n  const fakeStream = { reset() {} };\n  const fakeDict = {\n    get(key) {\n      if (key === \"F\") return new Name(\"JPXDecode\");\n      if (key === \"W\") return 100;\n      if (key === \"H\") return 100;\n      if (key === \"I\") return false;\n      if (key === \"IM\") return false;\n    },\n    getRaw(key) {\n      if (key === \"CS\") return new Name(\"DeviceRGB\");\n    },\n    has(key) {\n      if (key === \"SMaskInData\") return false;\n      return false;\n    },\n  };\n  const fakeImage = { dict: fakeDict, stream: fakeStream, bitsPerComponent: null };\n  const pdfImage = new PDFImage({\n    xref: {},\n    res: {},\n    image: fakeImage,\n    pdfFunctionFactory: new PDFFunctionFactory(),\n    localColorSpaceCache: {},\n  });\n  JpxImage.parseImageProperties = originalParse;\n  if (!pdfImage.jpxDecoderOptions) {\n    throw new Error(\"jpxDecoderOptions is not defined\");\n  }\n  if (pdfImage.jpxDecoderOptions.numComponents !== 3) {\n    throw new Error(\n      `Expected jpxDecoderOptions.numComponents to be 3 but got ${pdfImage.jpxDecoderOptions.numComponents}`\n    );\n  }\n});",
    "i2_gpt-4o": "it(\"should set jpxDecoderOptions.numComponents correctly for JPXDecode images\", async () => {\n  const { PDFImage } = await import(\"../../src/core/image.js\");\n  const { Name } = await import(\"../../src/core/primitives.js\");\n  const { PDFFunctionFactory } = await import(\"../../src/core/function.js\");\n  const { JpxImage } = await import(\"../../src/core/jpx.js\");\n  const originalParse = JpxImage.parseImageProperties;\n  JpxImage.parseImageProperties = () => ({\n    width: 100,\n    height: 100,\n    componentsCount: 3,\n    bitsPerComponent: 8,\n  });\n  const fakeStream = { reset() {} };\n  const fakeDict = {\n    get(key) {\n      if (key === \"F\") return new Name(\"JPXDecode\");\n      if (key === \"W\") return 100;\n      if (key === \"H\") return 100;\n      if (key === \"I\") return false;\n      if (key === \"IM\") return false;\n    },\n    getRaw(key) {\n      if (key === \"CS\") return new Name(\"DeviceRGB\");\n    },\n    has(key) {\n      if (key === \"SMaskInData\") return false;\n      return false;\n    },\n  };\n  const fakeImage = { dict: fakeDict, stream: fakeStream, bitsPerComponent: null };\n  const pdfImage = new PDFImage({\n    xref: {},\n    res: {},\n    image: fakeImage,\n    pdfFunctionFactory: new PDFFunctionFactory(),\n    localColorSpaceCache: {},\n  });\n  JpxImage.parseImageProperties = originalParse;\n  if (!pdfImage.jpxDecoderOptions) {\n    throw new Error(\"jpxDecoderOptions is not defined\");\n  }\n  if (pdfImage.jpxDecoderOptions.numComponents !== 3) {\n    throw new Error(\n      `Expected jpxDecoderOptions.numComponents to be 3 but got ${pdfImage.jpxDecoderOptions.numComponents}`\n    );\n  }\n});",
    "i2_llama-3.3-70b-versatile": "it(\"should set jpxDecoderOptions.numComponents correctly for JPXDecode images\", async () => {\n  const { PDFImage } = await import(\"../../src/core/image.js\");\n  const { Name } = await import(\"../../src/core/primitives.js\");\n  const { PDFFunctionFactory } = await import(\"../../src/core/function.js\");\n  const { JpxImage } = await import(\"../../src/core/jpx.js\");\n  const originalParse = JpxImage.parseImageProperties;\n  JpxImage.parseImageProperties = () => ({\n    width: 100,\n    height: 100,\n    componentsCount: 3,\n    bitsPerComponent: 8,\n  });\n  const fakeStream = { reset() {} };\n  const fakeDict = {\n    get(key) {\n      if (key === \"F\") return new Name(\"JPXDecode\");\n      if (key === \"W\") return 100;\n      if (key === \"H\") return 100;\n      if (key === \"I\") return false;\n      if (key === \"IM\") return false;\n    },\n    getRaw(key) {\n      if (key === \"CS\") return new Name(\"DeviceRGB\");\n    },\n    has(key) {\n      if (key === \"SMaskInData\") return false;\n      return false;\n    },\n  };\n  const fakeImage = { dict: fakeDict, stream: fakeStream, bitsPerComponent: null };\n  const pdfImage = new PDFImage({\n    xref: {},\n    res: {},\n    image: fakeImage,\n    pdfFunctionFactory: new PDFFunctionFactory(),\n    localColorSpaceCache: {},\n  });\n  JpxImage.parseImageProperties = originalParse;\n  if (!pdfImage.jpxDecoderOptions) {\n    throw new Error(\"jpxDecoderOptions is not defined\");\n  }\n  if (pdfImage.jpxDecoderOptions.numComponents !== 3) {\n    throw new Error(\n      `Expected jpxDecoderOptions.numComponents to be 3 but got ${pdfImage.jpxDecoderOptions.numComponents}`\n    );\n  }\n});",
    "i3_deepseek-r1-distill-llama-70b": "it(\"should set jpxDecoderOptions.numComponents correctly for JPXDecode images\", async () => {\n  const { PDFImage } = await import(\"../../src/core/image.js\");\n  const { Name } = await import(\"../../src/core/primitives.js\");\n  const { PDFFunctionFactory } = await import(\"../../src/core/function.js\");\n  const { JpxImage } = await import(\"../../src/core/jpx.js\");\n  const originalParse = JpxImage.parseImageProperties;\n  JpxImage.parseImageProperties = () => ({\n    width: 100,\n    height: 100,\n    componentsCount: 3,\n    bitsPerComponent: 8,\n  });\n  const fakeStream = { reset() {} };\n  const fakeDict = {\n    get(key) {\n      if (key === \"F\") return new Name(\"JPXDecode\");\n      if (key === \"W\") return 100;\n      if (key === \"H\") return 100;\n      if (key === \"I\") return false;\n      if (key === \"IM\") return false;\n    },\n    getRaw(key) {\n      if (key === \"CS\") return new Name(\"DeviceRGB\");\n    },\n    has(key) {\n      if (key === \"SMaskInData\") return false;\n      return false;\n    },\n  };\n  const fakeImage = { dict: fakeDict, stream: fakeStream, bitsPerComponent: null };\n  const pdfImage = new PDFImage({\n    xref: {},\n    res: {},\n    image: fakeImage,\n    pdfFunctionFactory: new PDFFunctionFactory(),\n    localColorSpaceCache: {},\n  });\n  JpxImage.parseImageProperties = originalParse;\n  if (!pdfImage.jpxDecoderOptions) {\n    throw new Error(\"jpxDecoderOptions is not defined\");\n  }\n  if (pdfImage.jpxDecoderOptions.numComponents !== 3) {\n    throw new Error(\n      `Expected jpxDecoderOptions.numComponents to be 3 but got ${pdfImage.jpxDecoderOptions.numComponents}`\n    );\n  }\n});",
    "i3_gpt-4o": "it(\"should set jpxDecoderOptions.numComponents correctly for JPXDecode images\", async () => {\n  const { PDFImage } = await import(\"../../src/core/image.js\");\n  const { Name } = await import(\"../../src/core/primitives.js\");\n  const { PDFFunctionFactory } = await import(\"../../src/core/function.js\");\n  const { JpxImage } = await import(\"../../src/core/jpx.js\");\n  const originalParse = JpxImage.parseImageProperties;\n  JpxImage.parseImageProperties = () => ({\n    width: 100,\n    height: 100,\n    componentsCount: 3,\n    bitsPerComponent: 8,\n  });\n  const fakeStream = { reset() {} };\n  const fakeDict = {\n    get(key) {\n      if (key === \"F\") return new Name(\"JPXDecode\");\n      if (key === \"W\") return 100;\n      if (key === \"H\") return 100;\n      if (key === \"I\") return false;\n      if (key === \"IM\") return false;\n    },\n    getRaw(key) {\n      if (key === \"CS\") return new Name(\"DeviceRGB\");\n    },\n    has(key) {\n      if (key === \"SMaskInData\") return false;\n      return false;\n    },\n  };\n  const fakeImage = { dict: fakeDict, stream: fakeStream, bitsPerComponent: null };\n  const pdfImage = new PDFImage({\n    xref: {},\n    res: {},\n    image: fakeImage,\n    pdfFunctionFactory: new PDFFunctionFactory(),\n    localColorSpaceCache: {},\n  });\n  JpxImage.parseImageProperties = originalParse;\n  if (!pdfImage.jpxDecoderOptions) {\n    throw new Error(\"jpxDecoderOptions is not defined\");\n  }\n  if (pdfImage.jpxDecoderOptions.numComponents !== 3) {\n    throw new Error(\n      `Expected jpxDecoderOptions.numComponents to be 3 but got ${pdfImage.jpxDecoderOptions.numComponents}`\n    );\n  }\n});",
    "i3_llama-3.3-70b-versatile": "it(\"should set jpxDecoderOptions.numComponents correctly for JPXDecode images\", async () => {\n  const { PDFImage } = await import(\"../../src/core/image.js\");\n  const { Name } = await import(\"../../src/core/primitives.js\");\n  const { PDFFunctionFactory } = await import(\"../../src/core/function.js\");\n  const { JpxImage } = await import(\"../../src/core/jpx.js\");\n  const originalParse = JpxImage.parseImageProperties;\n  JpxImage.parseImageProperties = () => ({\n    width: 100,\n    height: 100,\n    componentsCount: 3,\n    bitsPerComponent: 8,\n  });\n  const fakeStream = { reset() {} };\n  const fakeDict = {\n    get(key) {\n      if (key === \"F\") return new Name(\"JPXDecode\");\n      if (key === \"W\") return 100;\n      if (key === \"H\") return 100;\n      if (key === \"I\") return false;\n      if (key === \"IM\") return false;\n    },\n    getRaw(key) {\n      if (key === \"CS\") return new Name(\"DeviceRGB\");\n    },\n    has(key) {\n      if (key === \"SMaskInData\") return false;\n      return false;\n    },\n  };\n  const fakeImage = { dict: fakeDict, stream: fakeStream, bitsPerComponent: null };\n  const pdfImage = new PDFImage({\n    xref: {},\n    res: {},\n    image: fakeImage,\n    pdfFunctionFactory: new PDFFunctionFactory(),\n    localColorSpaceCache: {},\n  });\n  JpxImage.parseImageProperties = originalParse;\n  if (!pdfImage.jpxDecoderOptions) {\n    throw new Error(\"jpxDecoderOptions is not defined\");\n  }\n  if (pdfImage.jpxDecoderOptions.numComponents !== 3) {\n    throw new Error(\n      `Expected jpxDecoderOptions.numComponents to be 3 but got ${pdfImage.jpxDecoderOptions.numComponents}`\n    );\n  }\n});",
    "i4_deepseek-r1-distill-llama-70b": "it(\"should set jpxDecoderOptions.numComponents correctly for JPXDecode images\", async () => {\n  const { PDFImage } = await import(\"../../src/core/image.js\");\n  const { Name } = await import(\"../../src/core/primitives.js\");\n  const { PDFFunctionFactory } = await import(\"../../src/core/function.js\");\n  const { JpxImage } = await import(\"../../src/core/jpx.js\");\n  const originalParse = JpxImage.parseImageProperties;\n  JpxImage.parseImageProperties = () => ({\n    width: 100,\n    height: 100,\n    componentsCount: 3,\n    bitsPerComponent: 8,\n  });\n  const fakeStream = { reset() {} };\n  const fakeDict = {\n    get(key) {\n      if (key === \"F\") return new Name(\"JPXDecode\");\n      if (key === \"W\") return 100;\n      if (key === \"H\") return 100;\n      if (key === \"I\") return false;\n      if (key === \"IM\") return false;\n    },\n    getRaw(key) {\n      if (key === \"CS\") return new Name(\"DeviceRGB\");\n    },\n    has(key) {\n      if (key === \"SMaskInData\") return false;\n      return false;\n    },\n  };\n  const fakeImage = { dict: fakeDict, stream: fakeStream, bitsPerComponent: null };\n  const pdfImage = new PDFImage({\n    xref: {},\n    res: {},\n    image: fakeImage,\n    pdfFunctionFactory: new PDFFunctionFactory(),\n    localColorSpaceCache: {},\n  });\n  JpxImage.parseImageProperties = originalParse;\n  if (!pdfImage.jpxDecoderOptions) {\n    throw new Error(\"jpxDecoderOptions is not defined\");\n  }\n  if (pdfImage.jpxDecoderOptions.numComponents !== 3) {\n    throw new Error(\n      `Expected jpxDecoderOptions.numComponents to be 3 but got ${pdfImage.jpxDecoderOptions.numComponents}`\n    );\n  }\n});",
    "i4_gpt-4o": "it(\"should set jpxDecoderOptions.numComponents correctly for JPXDecode images\", async () => {\n  const { PDFImage } = await import(\"../../src/core/image.js\");\n  const { Name } = await import(\"../../src/core/primitives.js\");\n  const { PDFFunctionFactory } = await import(\"../../src/core/function.js\");\n  const { JpxImage } = await import(\"../../src/core/jpx.js\");\n  const originalParse = JpxImage.parseImageProperties;\n  JpxImage.parseImageProperties = () => ({\n    width: 100,\n    height: 100,\n    componentsCount: 3,\n    bitsPerComponent: 8,\n  });\n  const fakeStream = { reset() {} };\n  const fakeDict = {\n    get(key) {\n      if (key === \"F\") return new Name(\"JPXDecode\");\n      if (key === \"W\") return 100;\n      if (key === \"H\") return 100;\n      if (key === \"I\") return false;\n      if (key === \"IM\") return false;\n    },\n    getRaw(key) {\n      if (key === \"CS\") return new Name(\"DeviceRGB\");\n    },\n    has(key) {\n      if (key === \"SMaskInData\") return false;\n      return false;\n    },\n  };\n  const fakeImage = { dict: fakeDict, stream: fakeStream, bitsPerComponent: null };\n  const pdfImage = new PDFImage({\n    xref: {},\n    res: {},\n    image: fakeImage,\n    pdfFunctionFactory: new PDFFunctionFactory(),\n    localColorSpaceCache: {},\n  });\n  JpxImage.parseImageProperties = originalParse;\n  if (!pdfImage.jpxDecoderOptions) {\n    throw new Error(\"jpxDecoderOptions is not defined\");\n  }\n  if (pdfImage.jpxDecoderOptions.numComponents !== 3) {\n    throw new Error(\n      `Expected jpxDecoderOptions.numComponents to be 3 but got ${pdfImage.jpxDecoderOptions.numComponents}`\n    );\n  }\n});",
    "i4_llama-3.3-70b-versatile": "it(\"should set jpxDecoderOptions.numComponents correctly for JPXDecode images\", async () => {\n  const { PDFImage } = await import(\"../../src/core/image.js\");\n  const { Name } = await import(\"../../src/core/primitives.js\");\n  const { PDFFunctionFactory } = await import(\"../../src/core/function.js\");\n  const { JpxImage } = await import(\"../../src/core/jpx.js\");\n  const originalParse = JpxImage.parseImageProperties;\n  JpxImage.parseImageProperties = () => ({\n    width: 100,\n    height: 100,\n    componentsCount: 3,\n    bitsPerComponent: 8,\n  });\n  const fakeStream = { reset() {} };\n  const fakeDict = {\n    get(key) {\n      if (key === \"F\") return new Name(\"JPXDecode\");\n      if (key === \"W\") return 100;\n      if (key === \"H\") return 100;\n      if (key === \"I\") return false;\n      if (key === \"IM\") return false;\n    },\n    getRaw(key) {\n      if (key === \"CS\") return new Name(\"DeviceRGB\");\n    },\n    has(key) {\n      if (key === \"SMaskInData\") return false;\n      return false;\n    },\n  };\n  const fakeImage = { dict: fakeDict, stream: fakeStream, bitsPerComponent: null };\n  const pdfImage = new PDFImage({\n    xref: {},\n    res: {},\n    image: fakeImage,\n    pdfFunctionFactory: new PDFFunctionFactory(),\n    localColorSpaceCache: {},\n  });\n  JpxImage.parseImageProperties = originalParse;\n  if (!pdfImage.jpxDecoderOptions) {\n    throw new Error(\"jpxDecoderOptions is not defined\");\n  }\n  if (pdfImage.jpxDecoderOptions.numComponents !== 3) {\n    throw new Error(\n      `Expected jpxDecoderOptions.numComponents to be 3 but got ${pdfImage.jpxDecoderOptions.numComponents}`\n    );\n  }\n});",
    "i5_deepseek-r1-distill-llama-70b": "it(\"should set jpxDecoderOptions.numComponents correctly for JPXDecode images\", async () => {\n  const { PDFImage } = await import(\"../../src/core/image.js\");\n  const { Name } = await import(\"../../src/core/primitives.js\");\n  const { PDFFunctionFactory } = await import(\"../../src/core/function.js\");\n  const { JpxImage } = await import(\"../../src/core/jpx.js\");\n  const originalParse = JpxImage.parseImageProperties;\n  JpxImage.parseImageProperties = () => ({\n    width: 100,\n    height: 100,\n    componentsCount: 3,\n    bitsPerComponent: 8,\n  });\n  const fakeStream = { reset() {} };\n  const fakeDict = {\n    get(key) {\n      if (key === \"F\") return new Name(\"JPXDecode\");\n      if (key === \"W\") return 100;\n      if (key === \"H\") return 100;\n      if (key === \"I\") return false;\n      if (key === \"IM\") return false;\n    },\n    getRaw(key) {\n      if (key === \"CS\") return new Name(\"DeviceRGB\");\n    },\n    has(key) {\n      if (key === \"SMaskInData\") return false;\n      return false;\n    },\n  };\n  const fakeImage = { dict: fakeDict, stream: fakeStream, bitsPerComponent: null };\n  const pdfImage = new PDFImage({\n    xref: {},\n    res: {},\n    image: fakeImage,\n    pdfFunctionFactory: new PDFFunctionFactory(),\n    localColorSpaceCache: {},\n  });\n  JpxImage.parseImageProperties = originalParse;\n  if (!pdfImage.jpxDecoderOptions) {\n    throw new Error(\"jpxDecoderOptions is not defined\");\n  }\n  if (pdfImage.jpxDecoderOptions.numComponents !== 3) {\n    throw new Error(\n      `Expected jpxDecoderOptions.numComponents to be 3 but got ${pdfImage.jpxDecoderOptions.numComponents}`\n    );\n  }\n});",
    "i5_gpt-4o": "it(\"should set jpxDecoderOptions.numComponents correctly for JPXDecode images\", async () => {\n  const { PDFImage } = await import(\"../../src/core/image.js\");\n  const { Name } = await import(\"../../src/core/primitives.js\");\n  const { PDFFunctionFactory } = await import(\"../../src/core/function.js\");\n  const { JpxImage } = await import(\"../../src/core/jpx.js\");\n  const originalParse = JpxImage.parseImageProperties;\n  JpxImage.parseImageProperties = () => ({\n    width: 100,\n    height: 100,\n    componentsCount: 3,\n    bitsPerComponent: 8,\n  });\n  const fakeStream = { reset() {} };\n  const fakeDict = {\n    get(key) {\n      if (key === \"F\") return new Name(\"JPXDecode\");\n      if (key === \"W\") return 100;\n      if (key === \"H\") return 100;\n      if (key === \"I\") return false;\n      if (key === \"IM\") return false;\n    },\n    getRaw(key) {\n      if (key === \"CS\") return new Name(\"DeviceRGB\");\n    },\n    has(key) {\n      if (key === \"SMaskInData\") return false;\n      return false;\n    },\n  };\n  const fakeImage = { dict: fakeDict, stream: fakeStream, bitsPerComponent: null };\n  const pdfImage = new PDFImage({\n    xref: {},\n    res: {},\n    image: fakeImage,\n    pdfFunctionFactory: new PDFFunctionFactory(),\n    localColorSpaceCache: {},\n  });\n  JpxImage.parseImageProperties = originalParse;\n  if (!pdfImage.jpxDecoderOptions) {\n    throw new Error(\"jpxDecoderOptions is not defined\");\n  }\n  if (pdfImage.jpxDecoderOptions.numComponents !== 3) {\n    throw new Error(\n      `Expected jpxDecoderOptions.numComponents to be 3 but got ${pdfImage.jpxDecoderOptions.numComponents}`\n    );\n  }\n});",
    "i5_llama-3.3-70b-versatile": "it(\"should set jpxDecoderOptions.numComponents correctly for JPXDecode images\", async () => {\n  const { PDFImage } = await import(\"../../src/core/image.js\");\n  const { Name } = await import(\"../../src/core/primitives.js\");\n  const { PDFFunctionFactory } = await import(\"../../src/core/function.js\");\n  const { JpxImage } = await import(\"../../src/core/jpx.js\");\n  const originalParse = JpxImage.parseImageProperties;\n  JpxImage.parseImageProperties = () => ({\n    width: 100,\n    height: 100,\n    componentsCount: 3,\n    bitsPerComponent: 8,\n  });\n  const fakeStream = { reset() {} };\n  const fakeDict = {\n    get(key) {\n      if (key === \"F\") return new Name(\"JPXDecode\");\n      if (key === \"W\") return 100;\n      if (key === \"H\") return 100;\n      if (key === \"I\") return false;\n      if (key === \"IM\") return false;\n    },\n    getRaw(key) {\n      if (key === \"CS\") return new Name(\"DeviceRGB\");\n    },\n    has(key) {\n      if (key === \"SMaskInData\") return false;\n      return false;\n    },\n  };\n  const fakeImage = { dict: fakeDict, stream: fakeStream, bitsPerComponent: null };\n  const pdfImage = new PDFImage({\n    xref: {},\n    res: {},\n    image: fakeImage,\n    pdfFunctionFactory: new PDFFunctionFactory(),\n    localColorSpaceCache: {},\n  });\n  JpxImage.parseImageProperties = originalParse;\n  if (!pdfImage.jpxDecoderOptions) {\n    throw new Error(\"jpxDecoderOptions is not defined\");\n  }\n  if (pdfImage.jpxDecoderOptions.numComponents !== 3) {\n    throw new Error(\n      `Expected jpxDecoderOptions.numComponents to be 3 but got ${pdfImage.jpxDecoderOptions.numComponents}`\n    );\n  }\n});"
  },
  "19340": {
    "i1_deepseek-r1-distill-llama-70b": "it(\"should throw an error when the wasm file is missing\", async () => {\n  const { JpxImage, JpxError } = await import(\"../../src/core/jpx.js\");\n  const coreUtils = await import(\"../../src/core/core_utils.js\");\n  const originalFetchBinaryData = coreUtils.fetchBinaryData;\n  coreUtils.fetchBinaryData = () => Promise.reject(new Error(\"Missing wasm file\"));\n  const dummyBytes = new Uint8Array([1, 2, 3, 4]);\n  await expect(JpxImage.decode(dummyBytes)).rejects.toThrow();\n  coreUtils.fetchBinaryData = originalFetchBinaryData;\n});",
    "i1_gpt-4o": "it(\"should throw an error when the wasm file is missing\", async () => {\n  const { JpxImage, JpxError } = await import(\"../../src/core/jpx.js\");\n  const coreUtils = await import(\"../../src/core/core_utils.js\");\n  const originalFetchBinaryData = coreUtils.fetchBinaryData;\n  coreUtils.fetchBinaryData = () => Promise.reject(new Error(\"Missing wasm file\"));\n  const dummyBytes = new Uint8Array([1, 2, 3, 4]);\n  await expect(JpxImage.decode(dummyBytes)).rejects.toThrow();\n  coreUtils.fetchBinaryData = originalFetchBinaryData;\n});",
    "i1_llama-3.3-70b-versatile": "it(\"should throw an error when the wasm file is missing\", async () => {\n  const { JpxImage, JpxError } = await import(\"../../src/core/jpx.js\");\n  const coreUtils = await import(\"../../src/core/core_utils.js\");\n  const originalFetchBinaryData = coreUtils.fetchBinaryData;\n  coreUtils.fetchBinaryData = () => Promise.reject(new Error(\"Missing wasm file\"));\n  const dummyBytes = new Uint8Array([1, 2, 3, 4]);\n  await expect(JpxImage.decode(dummyBytes)).rejects.toThrow();\n  coreUtils.fetchBinaryData = originalFetchBinaryData;\n});",
    "i1_MOCK": "it(\"should throw an error when the wasm file is missing\", async () => {\n  const { JpxImage, JpxError } = await import(\"../../src/core/jpx.js\");\n  const coreUtils = await import(\"../../src/core/core_utils.js\");\n  const originalFetchBinaryData = coreUtils.fetchBinaryData;\n  coreUtils.fetchBinaryData = () => Promise.reject(new Error(\"Missing wasm file\"));\n  const dummyBytes = new Uint8Array([1, 2, 3, 4]);\n  await expect(JpxImage.decode(dummyBytes)).rejects.toThrow();\n  coreUtils.fetchBinaryData = originalFetchBinaryData;\n});",
    "i2_deepseek-r1-distill-llama-70b": "it(\"should throw an error when the wasm file is missing\", async () => {\n  const { JpxImage, JpxError } = await import(\"../../src/core/jpx.js\");\n  const coreUtils = await import(\"../../src/core/core_utils.js\");\n  const originalFetchBinaryData = coreUtils.fetchBinaryData;\n  coreUtils.fetchBinaryData = () => Promise.reject(new Error(\"Missing wasm file\"));\n  const dummyBytes = new Uint8Array([1, 2, 3, 4]);\n  await expect(JpxImage.decode(dummyBytes)).rejects.toThrow();\n  coreUtils.fetchBinaryData = originalFetchBinaryData;\n});",
    "i2_gpt-4o": "it(\"should throw an error when the wasm file is missing\", async () => {\n  const { JpxImage, JpxError } = await import(\"../../src/core/jpx.js\");\n  const coreUtils = await import(\"../../src/core/core_utils.js\");\n  const originalFetchBinaryData = coreUtils.fetchBinaryData;\n  coreUtils.fetchBinaryData = () => Promise.reject(new Error(\"Missing wasm file\"));\n  const dummyBytes = new Uint8Array([1, 2, 3, 4]);\n  await expect(JpxImage.decode(dummyBytes)).rejects.toThrow();\n  coreUtils.fetchBinaryData = originalFetchBinaryData;\n});",
    "i2_llama-3.3-70b-versatile": "it(\"should throw an error when the wasm file is missing\", async () => {\n  const { JpxImage, JpxError } = await import(\"../../src/core/jpx.js\");\n  const coreUtils = await import(\"../../src/core/core_utils.js\");\n  const originalFetchBinaryData = coreUtils.fetchBinaryData;\n  coreUtils.fetchBinaryData = () => Promise.reject(new Error(\"Missing wasm file\"));\n  const dummyBytes = new Uint8Array([1, 2, 3, 4]);\n  await expect(JpxImage.decode(dummyBytes)).rejects.toThrow();\n  coreUtils.fetchBinaryData = originalFetchBinaryData;\n});",
    "i3_deepseek-r1-distill-llama-70b": "it(\"should throw an error when the wasm file is missing\", async () => {\n  const { JpxImage, JpxError } = await import(\"../../src/core/jpx.js\");\n  const coreUtils = await import(\"../../src/core/core_utils.js\");\n  const originalFetchBinaryData = coreUtils.fetchBinaryData;\n  coreUtils.fetchBinaryData = () => Promise.reject(new Error(\"Missing wasm file\"));\n  const dummyBytes = new Uint8Array([1, 2, 3, 4]);\n  await expect(JpxImage.decode(dummyBytes)).rejects.toThrow();\n  coreUtils.fetchBinaryData = originalFetchBinaryData;\n});",
    "i3_gpt-4o": "it(\"should throw an error when the wasm file is missing\", async () => {\n  const { JpxImage, JpxError } = await import(\"../../src/core/jpx.js\");\n  const coreUtils = await import(\"../../src/core/core_utils.js\");\n  const originalFetchBinaryData = coreUtils.fetchBinaryData;\n  coreUtils.fetchBinaryData = () => Promise.reject(new Error(\"Missing wasm file\"));\n  const dummyBytes = new Uint8Array([1, 2, 3, 4]);\n  await expect(JpxImage.decode(dummyBytes)).rejects.toThrow();\n  coreUtils.fetchBinaryData = originalFetchBinaryData;\n});",
    "i3_llama-3.3-70b-versatile": "it(\"should throw an error when the wasm file is missing\", async () => {\n  const { JpxImage, JpxError } = await import(\"../../src/core/jpx.js\");\n  const coreUtils = await import(\"../../src/core/core_utils.js\");\n  const originalFetchBinaryData = coreUtils.fetchBinaryData;\n  coreUtils.fetchBinaryData = () => Promise.reject(new Error(\"Missing wasm file\"));\n  const dummyBytes = new Uint8Array([1, 2, 3, 4]);\n  await expect(JpxImage.decode(dummyBytes)).rejects.toThrow();\n  coreUtils.fetchBinaryData = originalFetchBinaryData;\n});",
    "i4_deepseek-r1-distill-llama-70b": "it(\"should throw an error when the wasm file is missing\", async () => {\n  const { JpxImage, JpxError } = await import(\"../../src/core/jpx.js\");\n  const coreUtils = await import(\"../../src/core/core_utils.js\");\n  const originalFetchBinaryData = coreUtils.fetchBinaryData;\n  coreUtils.fetchBinaryData = () => Promise.reject(new Error(\"Missing wasm file\"));\n  const dummyBytes = new Uint8Array([1, 2, 3, 4]);\n  await expect(JpxImage.decode(dummyBytes)).rejects.toThrow();\n  coreUtils.fetchBinaryData = originalFetchBinaryData;\n});",
    "i4_gpt-4o": "it(\"should throw an error when the wasm file is missing\", async () => {\n  const { JpxImage, JpxError } = await import(\"../../src/core/jpx.js\");\n  const coreUtils = await import(\"../../src/core/core_utils.js\");\n  const originalFetchBinaryData = coreUtils.fetchBinaryData;\n  coreUtils.fetchBinaryData = () => Promise.reject(new Error(\"Missing wasm file\"));\n  const dummyBytes = new Uint8Array([1, 2, 3, 4]);\n  await expect(JpxImage.decode(dummyBytes)).rejects.toThrow();\n  coreUtils.fetchBinaryData = originalFetchBinaryData;\n});",
    "i4_llama-3.3-70b-versatile": "it(\"should throw an error when the wasm file is missing\", async () => {\n  const { JpxImage, JpxError } = await import(\"../../src/core/jpx.js\");\n  const coreUtils = await import(\"../../src/core/core_utils.js\");\n  const originalFetchBinaryData = coreUtils.fetchBinaryData;\n  coreUtils.fetchBinaryData = () => Promise.reject(new Error(\"Missing wasm file\"));\n  const dummyBytes = new Uint8Array([1, 2, 3, 4]);\n  await expect(JpxImage.decode(dummyBytes)).rejects.toThrow();\n  coreUtils.fetchBinaryData = originalFetchBinaryData;\n});",
    "i5_deepseek-r1-distill-llama-70b": "it(\"should throw an error when the wasm file is missing\", async () => {\n  const { JpxImage, JpxError } = await import(\"../../src/core/jpx.js\");\n  const coreUtils = await import(\"../../src/core/core_utils.js\");\n  const originalFetchBinaryData = coreUtils.fetchBinaryData;\n  coreUtils.fetchBinaryData = () => Promise.reject(new Error(\"Missing wasm file\"));\n  const dummyBytes = new Uint8Array([1, 2, 3, 4]);\n  await expect(JpxImage.decode(dummyBytes)).rejects.toThrow();\n  coreUtils.fetchBinaryData = originalFetchBinaryData;\n});",
    "i5_gpt-4o": "it(\"should throw an error when the wasm file is missing\", async () => {\n  const { JpxImage, JpxError } = await import(\"../../src/core/jpx.js\");\n  const coreUtils = await import(\"../../src/core/core_utils.js\");\n  const originalFetchBinaryData = coreUtils.fetchBinaryData;\n  coreUtils.fetchBinaryData = () => Promise.reject(new Error(\"Missing wasm file\"));\n  const dummyBytes = new Uint8Array([1, 2, 3, 4]);\n  await expect(JpxImage.decode(dummyBytes)).rejects.toThrow();\n  coreUtils.fetchBinaryData = originalFetchBinaryData;\n});",
    "i5_llama-3.3-70b-versatile": "it(\"should throw an error when the wasm file is missing\", async () => {\n  const { JpxImage, JpxError } = await import(\"../../src/core/jpx.js\");\n  const coreUtils = await import(\"../../src/core/core_utils.js\");\n  const originalFetchBinaryData = coreUtils.fetchBinaryData;\n  coreUtils.fetchBinaryData = () => Promise.reject(new Error(\"Missing wasm file\"));\n  const dummyBytes = new Uint8Array([1, 2, 3, 4]);\n  await expect(JpxImage.decode(dummyBytes)).rejects.toThrow();\n  coreUtils.fetchBinaryData = originalFetchBinaryData;\n});"
  },
  "19361": {
    "i1_deepseek-r1-distill-llama-70b": "it(\"should close the previous subpath when starting a new move in text rendering\", async () => {\n  const { compileCharString } = await import(\"../../src/core/font_renderer.js\");\n  const commands = [];\n  const cmds = {\n    add: (cmd, args) => commands.push({ cmd, args })\n  };\n  // The following charstring simulates two move-to operations:\n  // First, a horizontal move (operator 22) with one argument (100),\n  // then a relative move (operator 21) with two arguments (50 and 80).\n  // Numbers are encoded as per the Type2 charstring specification:\n  // For numbers between -107 and 107, the value is encoded as (value + 139).\n  // Thus, 100 encodes to 239, 50 to 189, and 80 to 219.\n  const charStringCode = [239, 22, 189, 219, 21];\n  // Provide a dummy font object.\n  const font = {};\n  // Call compileCharString which will process the code.\n  compileCharString(charStringCode, cmds, font, 0);\n  // Expected behavior (post-patch):\n  // First move: moveTo(100, 0) -> adds \"M\" [100,0].\n  // Second move: before moveTo(150,80) it should close the previous subpath by adding \"L\" with the first point of that subpath ([100,0]),\n  // then add \"M\" with the new coordinates.\n  const expected = [\n    { cmd: \"M\", args: [100, 0] },\n    { cmd: \"L\", args: [100, 0] },\n    { cmd: \"M\", args: [150, 80] }\n  ];\n  expect(commands).toEqual(expected);\n});",
    "i1_gpt-4o": "it(\"should close the previous subpath when starting a new move in text rendering\", async () => {\n  const { compileCharString } = await import(\"../../src/core/font_renderer.js\");\n  const commands = [];\n  const cmds = {\n    add: (cmd, args) => commands.push({ cmd, args })\n  };\n  // The following charstring simulates two move-to operations:\n  // First, a horizontal move (operator 22) with one argument (100),\n  // then a relative move (operator 21) with two arguments (50 and 80).\n  // Numbers are encoded as per the Type2 charstring specification:\n  // For numbers between -107 and 107, the value is encoded as (value + 139).\n  // Thus, 100 encodes to 239, 50 to 189, and 80 to 219.\n  const charStringCode = [239, 22, 189, 219, 21];\n  // Provide a dummy font object.\n  const font = {};\n  // Call compileCharString which will process the code.\n  compileCharString(charStringCode, cmds, font, 0);\n  // Expected behavior (post-patch):\n  // First move: moveTo(100, 0) -> adds \"M\" [100,0].\n  // Second move: before moveTo(150,80) it should close the previous subpath by adding \"L\" with the first point of that subpath ([100,0]),\n  // then add \"M\" with the new coordinates.\n  const expected = [\n    { cmd: \"M\", args: [100, 0] },\n    { cmd: \"L\", args: [100, 0] },\n    { cmd: \"M\", args: [150, 80] }\n  ];\n  expect(commands).toEqual(expected);\n});",
    "i1_llama-3.3-70b-versatile": "it(\"should close the previous subpath when starting a new move in text rendering\", async () => {\n  const { compileCharString } = await import(\"../../src/core/font_renderer.js\");\n  const commands = [];\n  const cmds = {\n    add: (cmd, args) => commands.push({ cmd, args })\n  };\n  // The following charstring simulates two move-to operations:\n  // First, a horizontal move (operator 22) with one argument (100),\n  // then a relative move (operator 21) with two arguments (50 and 80).\n  // Numbers are encoded as per the Type2 charstring specification:\n  // For numbers between -107 and 107, the value is encoded as (value + 139).\n  // Thus, 100 encodes to 239, 50 to 189, and 80 to 219.\n  const charStringCode = [239, 22, 189, 219, 21];\n  // Provide a dummy font object.\n  const font = {};\n  // Call compileCharString which will process the code.\n  compileCharString(charStringCode, cmds, font, 0);\n  // Expected behavior (post-patch):\n  // First move: moveTo(100, 0) -> adds \"M\" [100,0].\n  // Second move: before moveTo(150,80) it should close the previous subpath by adding \"L\" with the first point of that subpath ([100,0]),\n  // then add \"M\" with the new coordinates.\n  const expected = [\n    { cmd: \"M\", args: [100, 0] },\n    { cmd: \"L\", args: [100, 0] },\n    { cmd: \"M\", args: [150, 80] }\n  ];\n  expect(commands).toEqual(expected);\n});",
    "i1_MOCK": "it(\"should close the previous subpath when starting a new move in text rendering\", async () => {\n  const { compileCharString } = await import(\"../../src/core/font_renderer.js\");\n  const commands = [];\n  const cmds = {\n    add: (cmd, args) => commands.push({ cmd, args })\n  };\n  // The following charstring simulates two move-to operations:\n  // First, a horizontal move (operator 22) with one argument (100),\n  // then a relative move (operator 21) with two arguments (50 and 80).\n  // Numbers are encoded as per the Type2 charstring specification:\n  // For numbers between -107 and 107, the value is encoded as (value + 139).\n  // Thus, 100 encodes to 239, 50 to 189, and 80 to 219.\n  const charStringCode = [239, 22, 189, 219, 21];\n  // Provide a dummy font object.\n  const font = {};\n  // Call compileCharString which will process the code.\n  compileCharString(charStringCode, cmds, font, 0);\n  // Expected behavior (post-patch):\n  // First move: moveTo(100, 0) -> adds \"M\" [100,0].\n  // Second move: before moveTo(150,80) it should close the previous subpath by adding \"L\" with the first point of that subpath ([100,0]),\n  // then add \"M\" with the new coordinates.\n  const expected = [\n    { cmd: \"M\", args: [100, 0] },\n    { cmd: \"L\", args: [100, 0] },\n    { cmd: \"M\", args: [150, 80] }\n  ];\n  expect(commands).toEqual(expected);\n});",
    "i2_deepseek-r1-distill-llama-70b": "it(\"should close the previous subpath when starting a new move in text rendering\", async () => {\n  const { compileCharString } = await import(\"../../src/core/font_renderer.js\");\n  const commands = [];\n  const cmds = {\n    add: (cmd, args) => commands.push({ cmd, args })\n  };\n  // The following charstring simulates two move-to operations:\n  // First, a horizontal move (operator 22) with one argument (100),\n  // then a relative move (operator 21) with two arguments (50 and 80).\n  // Numbers are encoded as per the Type2 charstring specification:\n  // For numbers between -107 and 107, the value is encoded as (value + 139).\n  // Thus, 100 encodes to 239, 50 to 189, and 80 to 219.\n  const charStringCode = [239, 22, 189, 219, 21];\n  // Provide a dummy font object.\n  const font = {};\n  // Call compileCharString which will process the code.\n  compileCharString(charStringCode, cmds, font, 0);\n  // Expected behavior (post-patch):\n  // First move: moveTo(100, 0) -> adds \"M\" [100,0].\n  // Second move: before moveTo(150,80) it should close the previous subpath by adding \"L\" with the first point of that subpath ([100,0]),\n  // then add \"M\" with the new coordinates.\n  const expected = [\n    { cmd: \"M\", args: [100, 0] },\n    { cmd: \"L\", args: [100, 0] },\n    { cmd: \"M\", args: [150, 80] }\n  ];\n  expect(commands).toEqual(expected);\n});",
    "i2_gpt-4o": "it(\"should close the previous subpath when starting a new move in text rendering\", async () => {\n  const { compileCharString } = await import(\"../../src/core/font_renderer.js\");\n  const commands = [];\n  const cmds = {\n    add: (cmd, args) => commands.push({ cmd, args })\n  };\n  // The following charstring simulates two move-to operations:\n  // First, a horizontal move (operator 22) with one argument (100),\n  // then a relative move (operator 21) with two arguments (50 and 80).\n  // Numbers are encoded as per the Type2 charstring specification:\n  // For numbers between -107 and 107, the value is encoded as (value + 139).\n  // Thus, 100 encodes to 239, 50 to 189, and 80 to 219.\n  const charStringCode = [239, 22, 189, 219, 21];\n  // Provide a dummy font object.\n  const font = {};\n  // Call compileCharString which will process the code.\n  compileCharString(charStringCode, cmds, font, 0);\n  // Expected behavior (post-patch):\n  // First move: moveTo(100, 0) -> adds \"M\" [100,0].\n  // Second move: before moveTo(150,80) it should close the previous subpath by adding \"L\" with the first point of that subpath ([100,0]),\n  // then add \"M\" with the new coordinates.\n  const expected = [\n    { cmd: \"M\", args: [100, 0] },\n    { cmd: \"L\", args: [100, 0] },\n    { cmd: \"M\", args: [150, 80] }\n  ];\n  expect(commands).toEqual(expected);\n});",
    "i2_llama-3.3-70b-versatile": "it(\"should close the previous subpath when starting a new move in text rendering\", async () => {\n  const { compileCharString } = await import(\"../../src/core/font_renderer.js\");\n  const commands = [];\n  const cmds = {\n    add: (cmd, args) => commands.push({ cmd, args })\n  };\n  // The following charstring simulates two move-to operations:\n  // First, a horizontal move (operator 22) with one argument (100),\n  // then a relative move (operator 21) with two arguments (50 and 80).\n  // Numbers are encoded as per the Type2 charstring specification:\n  // For numbers between -107 and 107, the value is encoded as (value + 139).\n  // Thus, 100 encodes to 239, 50 to 189, and 80 to 219.\n  const charStringCode = [239, 22, 189, 219, 21];\n  // Provide a dummy font object.\n  const font = {};\n  // Call compileCharString which will process the code.\n  compileCharString(charStringCode, cmds, font, 0);\n  // Expected behavior (post-patch):\n  // First move: moveTo(100, 0) -> adds \"M\" [100,0].\n  // Second move: before moveTo(150,80) it should close the previous subpath by adding \"L\" with the first point of that subpath ([100,0]),\n  // then add \"M\" with the new coordinates.\n  const expected = [\n    { cmd: \"M\", args: [100, 0] },\n    { cmd: \"L\", args: [100, 0] },\n    { cmd: \"M\", args: [150, 80] }\n  ];\n  expect(commands).toEqual(expected);\n});",
    "i3_deepseek-r1-distill-llama-70b": "it(\"should close the previous subpath when starting a new move in text rendering\", async () => {\n  const { compileCharString } = await import(\"../../src/core/font_renderer.js\");\n  const commands = [];\n  const cmds = {\n    add: (cmd, args) => commands.push({ cmd, args })\n  };\n  // The following charstring simulates two move-to operations:\n  // First, a horizontal move (operator 22) with one argument (100),\n  // then a relative move (operator 21) with two arguments (50 and 80).\n  // Numbers are encoded as per the Type2 charstring specification:\n  // For numbers between -107 and 107, the value is encoded as (value + 139).\n  // Thus, 100 encodes to 239, 50 to 189, and 80 to 219.\n  const charStringCode = [239, 22, 189, 219, 21];\n  // Provide a dummy font object.\n  const font = {};\n  // Call compileCharString which will process the code.\n  compileCharString(charStringCode, cmds, font, 0);\n  // Expected behavior (post-patch):\n  // First move: moveTo(100, 0) -> adds \"M\" [100,0].\n  // Second move: before moveTo(150,80) it should close the previous subpath by adding \"L\" with the first point of that subpath ([100,0]),\n  // then add \"M\" with the new coordinates.\n  const expected = [\n    { cmd: \"M\", args: [100, 0] },\n    { cmd: \"L\", args: [100, 0] },\n    { cmd: \"M\", args: [150, 80] }\n  ];\n  expect(commands).toEqual(expected);\n});",
    "i3_gpt-4o": "it(\"should close the previous subpath when starting a new move in text rendering\", async () => {\n  const { compileCharString } = await import(\"../../src/core/font_renderer.js\");\n  const commands = [];\n  const cmds = {\n    add: (cmd, args) => commands.push({ cmd, args })\n  };\n  // The following charstring simulates two move-to operations:\n  // First, a horizontal move (operator 22) with one argument (100),\n  // then a relative move (operator 21) with two arguments (50 and 80).\n  // Numbers are encoded as per the Type2 charstring specification:\n  // For numbers between -107 and 107, the value is encoded as (value + 139).\n  // Thus, 100 encodes to 239, 50 to 189, and 80 to 219.\n  const charStringCode = [239, 22, 189, 219, 21];\n  // Provide a dummy font object.\n  const font = {};\n  // Call compileCharString which will process the code.\n  compileCharString(charStringCode, cmds, font, 0);\n  // Expected behavior (post-patch):\n  // First move: moveTo(100, 0) -> adds \"M\" [100,0].\n  // Second move: before moveTo(150,80) it should close the previous subpath by adding \"L\" with the first point of that subpath ([100,0]),\n  // then add \"M\" with the new coordinates.\n  const expected = [\n    { cmd: \"M\", args: [100, 0] },\n    { cmd: \"L\", args: [100, 0] },\n    { cmd: \"M\", args: [150, 80] }\n  ];\n  expect(commands).toEqual(expected);\n});",
    "i3_llama-3.3-70b-versatile": "it(\"should close the previous subpath when starting a new move in text rendering\", async () => {\n  const { compileCharString } = await import(\"../../src/core/font_renderer.js\");\n  const commands = [];\n  const cmds = {\n    add: (cmd, args) => commands.push({ cmd, args })\n  };\n  // The following charstring simulates two move-to operations:\n  // First, a horizontal move (operator 22) with one argument (100),\n  // then a relative move (operator 21) with two arguments (50 and 80).\n  // Numbers are encoded as per the Type2 charstring specification:\n  // For numbers between -107 and 107, the value is encoded as (value + 139).\n  // Thus, 100 encodes to 239, 50 to 189, and 80 to 219.\n  const charStringCode = [239, 22, 189, 219, 21];\n  // Provide a dummy font object.\n  const font = {};\n  // Call compileCharString which will process the code.\n  compileCharString(charStringCode, cmds, font, 0);\n  // Expected behavior (post-patch):\n  // First move: moveTo(100, 0) -> adds \"M\" [100,0].\n  // Second move: before moveTo(150,80) it should close the previous subpath by adding \"L\" with the first point of that subpath ([100,0]),\n  // then add \"M\" with the new coordinates.\n  const expected = [\n    { cmd: \"M\", args: [100, 0] },\n    { cmd: \"L\", args: [100, 0] },\n    { cmd: \"M\", args: [150, 80] }\n  ];\n  expect(commands).toEqual(expected);\n});",
    "i4_deepseek-r1-distill-llama-70b": "it(\"should close the previous subpath when starting a new move in text rendering\", async () => {\n  const { compileCharString } = await import(\"../../src/core/font_renderer.js\");\n  const commands = [];\n  const cmds = {\n    add: (cmd, args) => commands.push({ cmd, args })\n  };\n  // The following charstring simulates two move-to operations:\n  // First, a horizontal move (operator 22) with one argument (100),\n  // then a relative move (operator 21) with two arguments (50 and 80).\n  // Numbers are encoded as per the Type2 charstring specification:\n  // For numbers between -107 and 107, the value is encoded as (value + 139).\n  // Thus, 100 encodes to 239, 50 to 189, and 80 to 219.\n  const charStringCode = [239, 22, 189, 219, 21];\n  // Provide a dummy font object.\n  const font = {};\n  // Call compileCharString which will process the code.\n  compileCharString(charStringCode, cmds, font, 0);\n  // Expected behavior (post-patch):\n  // First move: moveTo(100, 0) -> adds \"M\" [100,0].\n  // Second move: before moveTo(150,80) it should close the previous subpath by adding \"L\" with the first point of that subpath ([100,0]),\n  // then add \"M\" with the new coordinates.\n  const expected = [\n    { cmd: \"M\", args: [100, 0] },\n    { cmd: \"L\", args: [100, 0] },\n    { cmd: \"M\", args: [150, 80] }\n  ];\n  expect(commands).toEqual(expected);\n});",
    "i4_gpt-4o": "it(\"should close the previous subpath when starting a new move in text rendering\", async () => {\n  const { compileCharString } = await import(\"../../src/core/font_renderer.js\");\n  const commands = [];\n  const cmds = {\n    add: (cmd, args) => commands.push({ cmd, args })\n  };\n  // The following charstring simulates two move-to operations:\n  // First, a horizontal move (operator 22) with one argument (100),\n  // then a relative move (operator 21) with two arguments (50 and 80).\n  // Numbers are encoded as per the Type2 charstring specification:\n  // For numbers between -107 and 107, the value is encoded as (value + 139).\n  // Thus, 100 encodes to 239, 50 to 189, and 80 to 219.\n  const charStringCode = [239, 22, 189, 219, 21];\n  // Provide a dummy font object.\n  const font = {};\n  // Call compileCharString which will process the code.\n  compileCharString(charStringCode, cmds, font, 0);\n  // Expected behavior (post-patch):\n  // First move: moveTo(100, 0) -> adds \"M\" [100,0].\n  // Second move: before moveTo(150,80) it should close the previous subpath by adding \"L\" with the first point of that subpath ([100,0]),\n  // then add \"M\" with the new coordinates.\n  const expected = [\n    { cmd: \"M\", args: [100, 0] },\n    { cmd: \"L\", args: [100, 0] },\n    { cmd: \"M\", args: [150, 80] }\n  ];\n  expect(commands).toEqual(expected);\n});",
    "i4_llama-3.3-70b-versatile": "it(\"should close the previous subpath when starting a new move in text rendering\", async () => {\n  const { compileCharString } = await import(\"../../src/core/font_renderer.js\");\n  const commands = [];\n  const cmds = {\n    add: (cmd, args) => commands.push({ cmd, args })\n  };\n  // The following charstring simulates two move-to operations:\n  // First, a horizontal move (operator 22) with one argument (100),\n  // then a relative move (operator 21) with two arguments (50 and 80).\n  // Numbers are encoded as per the Type2 charstring specification:\n  // For numbers between -107 and 107, the value is encoded as (value + 139).\n  // Thus, 100 encodes to 239, 50 to 189, and 80 to 219.\n  const charStringCode = [239, 22, 189, 219, 21];\n  // Provide a dummy font object.\n  const font = {};\n  // Call compileCharString which will process the code.\n  compileCharString(charStringCode, cmds, font, 0);\n  // Expected behavior (post-patch):\n  // First move: moveTo(100, 0) -> adds \"M\" [100,0].\n  // Second move: before moveTo(150,80) it should close the previous subpath by adding \"L\" with the first point of that subpath ([100,0]),\n  // then add \"M\" with the new coordinates.\n  const expected = [\n    { cmd: \"M\", args: [100, 0] },\n    { cmd: \"L\", args: [100, 0] },\n    { cmd: \"M\", args: [150, 80] }\n  ];\n  expect(commands).toEqual(expected);\n});",
    "i5_deepseek-r1-distill-llama-70b": "it(\"should close the previous subpath when starting a new move in text rendering\", async () => {\n  const { compileCharString } = await import(\"../../src/core/font_renderer.js\");\n  const commands = [];\n  const cmds = {\n    add: (cmd, args) => commands.push({ cmd, args })\n  };\n  // The following charstring simulates two move-to operations:\n  // First, a horizontal move (operator 22) with one argument (100),\n  // then a relative move (operator 21) with two arguments (50 and 80).\n  // Numbers are encoded as per the Type2 charstring specification:\n  // For numbers between -107 and 107, the value is encoded as (value + 139).\n  // Thus, 100 encodes to 239, 50 to 189, and 80 to 219.\n  const charStringCode = [239, 22, 189, 219, 21];\n  // Provide a dummy font object.\n  const font = {};\n  // Call compileCharString which will process the code.\n  compileCharString(charStringCode, cmds, font, 0);\n  // Expected behavior (post-patch):\n  // First move: moveTo(100, 0) -> adds \"M\" [100,0].\n  // Second move: before moveTo(150,80) it should close the previous subpath by adding \"L\" with the first point of that subpath ([100,0]),\n  // then add \"M\" with the new coordinates.\n  const expected = [\n    { cmd: \"M\", args: [100, 0] },\n    { cmd: \"L\", args: [100, 0] },\n    { cmd: \"M\", args: [150, 80] }\n  ];\n  expect(commands).toEqual(expected);\n});",
    "i5_gpt-4o": "it(\"should close the previous subpath when starting a new move in text rendering\", async () => {\n  const { compileCharString } = await import(\"../../src/core/font_renderer.js\");\n  const commands = [];\n  const cmds = {\n    add: (cmd, args) => commands.push({ cmd, args })\n  };\n  // The following charstring simulates two move-to operations:\n  // First, a horizontal move (operator 22) with one argument (100),\n  // then a relative move (operator 21) with two arguments (50 and 80).\n  // Numbers are encoded as per the Type2 charstring specification:\n  // For numbers between -107 and 107, the value is encoded as (value + 139).\n  // Thus, 100 encodes to 239, 50 to 189, and 80 to 219.\n  const charStringCode = [239, 22, 189, 219, 21];\n  // Provide a dummy font object.\n  const font = {};\n  // Call compileCharString which will process the code.\n  compileCharString(charStringCode, cmds, font, 0);\n  // Expected behavior (post-patch):\n  // First move: moveTo(100, 0) -> adds \"M\" [100,0].\n  // Second move: before moveTo(150,80) it should close the previous subpath by adding \"L\" with the first point of that subpath ([100,0]),\n  // then add \"M\" with the new coordinates.\n  const expected = [\n    { cmd: \"M\", args: [100, 0] },\n    { cmd: \"L\", args: [100, 0] },\n    { cmd: \"M\", args: [150, 80] }\n  ];\n  expect(commands).toEqual(expected);\n});",
    "i5_llama-3.3-70b-versatile": "it(\"should close the previous subpath when starting a new move in text rendering\", async () => {\n  const { compileCharString } = await import(\"../../src/core/font_renderer.js\");\n  const commands = [];\n  const cmds = {\n    add: (cmd, args) => commands.push({ cmd, args })\n  };\n  // The following charstring simulates two move-to operations:\n  // First, a horizontal move (operator 22) with one argument (100),\n  // then a relative move (operator 21) with two arguments (50 and 80).\n  // Numbers are encoded as per the Type2 charstring specification:\n  // For numbers between -107 and 107, the value is encoded as (value + 139).\n  // Thus, 100 encodes to 239, 50 to 189, and 80 to 219.\n  const charStringCode = [239, 22, 189, 219, 21];\n  // Provide a dummy font object.\n  const font = {};\n  // Call compileCharString which will process the code.\n  compileCharString(charStringCode, cmds, font, 0);\n  // Expected behavior (post-patch):\n  // First move: moveTo(100, 0) -> adds \"M\" [100,0].\n  // Second move: before moveTo(150,80) it should close the previous subpath by adding \"L\" with the first point of that subpath ([100,0]),\n  // then add \"M\" with the new coordinates.\n  const expected = [\n    { cmd: \"M\", args: [100, 0] },\n    { cmd: \"L\", args: [100, 0] },\n    { cmd: \"M\", args: [150, 80] }\n  ];\n  expect(commands).toEqual(expected);\n});"
  },
  "19368": {
    "i1_deepseek-r1-distill-llama-70b": "it(\"should immediately clear intentStates when a last chunk is received in nonprint mode\", async () => {\n  const { PDFPageProxy } = await import(\"../../src/display/api.js\");\n  const { assert } = await import(\"../../src/shared/util.js\");\n  const dummyTransport = {\n    commonObjs: new Map(),\n    getRenderingIntent: () => ({ renderingIntent: 2, cacheKey: \"test\" }),\n  };\n  const pdfPageProxy = new PDFPageProxy(0, {}, dummyTransport, false);\n  const intentState = {\n    renderTasks: new Set(),\n    operatorList: { fnArray: [], argsArray: [], lastChunk: false, separateAnnots: null },\n  };\n  pdfPageProxy._intentStates.set(\"test\", intentState);\n  pdfPageProxy._renderPageChunk(\n    { fnArray: [], argsArray: [], lastChunk: true, separateAnnots: null },\n    intentState\n  );\n  assert.strictEqual(pdfPageProxy._intentStates.size, 0);\n});\n",
    "i1_gpt-4o": "it(\"should immediately clear intentStates when a last chunk is received in nonprint mode\", async () => {\n  const { PDFPageProxy } = await import(\"../../src/display/api.js\");\n  const { assert } = await import(\"../../src/shared/util.js\");\n  const dummyTransport = {\n    commonObjs: new Map(),\n    getRenderingIntent: () => ({ renderingIntent: 2, cacheKey: \"test\" }),\n  };\n  const pdfPageProxy = new PDFPageProxy(0, {}, dummyTransport, false);\n  const intentState = {\n    renderTasks: new Set(),\n    operatorList: { fnArray: [], argsArray: [], lastChunk: false, separateAnnots: null },\n  };\n  pdfPageProxy._intentStates.set(\"test\", intentState);\n  pdfPageProxy._renderPageChunk(\n    { fnArray: [], argsArray: [], lastChunk: true, separateAnnots: null },\n    intentState\n  );\n  assert.strictEqual(pdfPageProxy._intentStates.size, 0);\n});\n",
    "i1_llama-3.3-70b-versatile": "it(\"should immediately clear intentStates when a last chunk is received in nonprint mode\", async () => {\n  const { PDFPageProxy } = await import(\"../../src/display/api.js\");\n  const { assert } = await import(\"../../src/shared/util.js\");\n  const dummyTransport = {\n    commonObjs: new Map(),\n    getRenderingIntent: () => ({ renderingIntent: 2, cacheKey: \"test\" }),\n  };\n  const pdfPageProxy = new PDFPageProxy(0, {}, dummyTransport, false);\n  const intentState = {\n    renderTasks: new Set(),\n    operatorList: { fnArray: [], argsArray: [], lastChunk: false, separateAnnots: null },\n  };\n  pdfPageProxy._intentStates.set(\"test\", intentState);\n  pdfPageProxy._renderPageChunk(\n    { fnArray: [], argsArray: [], lastChunk: true, separateAnnots: null },\n    intentState\n  );\n  assert.strictEqual(pdfPageProxy._intentStates.size, 0);\n});\n",
    "i1_MOCK": "it(\"should immediately clear intentStates when a last chunk is received in nonprint mode\", async () => {\n  const { PDFPageProxy } = await import(\"../../src/display/api.js\");\n  const { assert } = await import(\"../../src/shared/util.js\");\n  const dummyTransport = {\n    commonObjs: new Map(),\n    getRenderingIntent: () => ({ renderingIntent: 2, cacheKey: \"test\" }),\n  };\n  const pdfPageProxy = new PDFPageProxy(0, {}, dummyTransport, false);\n  const intentState = {\n    renderTasks: new Set(),\n    operatorList: { fnArray: [], argsArray: [], lastChunk: false, separateAnnots: null },\n  };\n  pdfPageProxy._intentStates.set(\"test\", intentState);\n  pdfPageProxy._renderPageChunk(\n    { fnArray: [], argsArray: [], lastChunk: true, separateAnnots: null },\n    intentState\n  );\n  assert.strictEqual(pdfPageProxy._intentStates.size, 0);\n});\n",
    "i2_deepseek-r1-distill-llama-70b": "it(\"should immediately clear intentStates when a last chunk is received in nonprint mode\", async () => {\n  const { PDFPageProxy } = await import(\"../../src/display/api.js\");\n  const { assert } = await import(\"../../src/shared/util.js\");\n  const dummyTransport = {\n    commonObjs: new Map(),\n    getRenderingIntent: () => ({ renderingIntent: 2, cacheKey: \"test\" }),\n  };\n  const pdfPageProxy = new PDFPageProxy(0, {}, dummyTransport, false);\n  const intentState = {\n    renderTasks: new Set(),\n    operatorList: { fnArray: [], argsArray: [], lastChunk: false, separateAnnots: null },\n  };\n  pdfPageProxy._intentStates.set(\"test\", intentState);\n  pdfPageProxy._renderPageChunk(\n    { fnArray: [], argsArray: [], lastChunk: true, separateAnnots: null },\n    intentState\n  );\n  assert.strictEqual(pdfPageProxy._intentStates.size, 0);\n});\n",
    "i2_gpt-4o": "it(\"should immediately clear intentStates when a last chunk is received in nonprint mode\", async () => {\n  const { PDFPageProxy } = await import(\"../../src/display/api.js\");\n  const { assert } = await import(\"../../src/shared/util.js\");\n  const dummyTransport = {\n    commonObjs: new Map(),\n    getRenderingIntent: () => ({ renderingIntent: 2, cacheKey: \"test\" }),\n  };\n  const pdfPageProxy = new PDFPageProxy(0, {}, dummyTransport, false);\n  const intentState = {\n    renderTasks: new Set(),\n    operatorList: { fnArray: [], argsArray: [], lastChunk: false, separateAnnots: null },\n  };\n  pdfPageProxy._intentStates.set(\"test\", intentState);\n  pdfPageProxy._renderPageChunk(\n    { fnArray: [], argsArray: [], lastChunk: true, separateAnnots: null },\n    intentState\n  );\n  assert.strictEqual(pdfPageProxy._intentStates.size, 0);\n});\n",
    "i2_llama-3.3-70b-versatile": "it(\"should immediately clear intentStates when a last chunk is received in nonprint mode\", async () => {\n  const { PDFPageProxy } = await import(\"../../src/display/api.js\");\n  const { assert } = await import(\"../../src/shared/util.js\");\n  const dummyTransport = {\n    commonObjs: new Map(),\n    getRenderingIntent: () => ({ renderingIntent: 2, cacheKey: \"test\" }),\n  };\n  const pdfPageProxy = new PDFPageProxy(0, {}, dummyTransport, false);\n  const intentState = {\n    renderTasks: new Set(),\n    operatorList: { fnArray: [], argsArray: [], lastChunk: false, separateAnnots: null },\n  };\n  pdfPageProxy._intentStates.set(\"test\", intentState);\n  pdfPageProxy._renderPageChunk(\n    { fnArray: [], argsArray: [], lastChunk: true, separateAnnots: null },\n    intentState\n  );\n  assert.strictEqual(pdfPageProxy._intentStates.size, 0);\n});\n",
    "i3_deepseek-r1-distill-llama-70b": "it(\"should immediately clear intentStates when a last chunk is received in nonprint mode\", async () => {\n  const { PDFPageProxy } = await import(\"../../src/display/api.js\");\n  const { assert } = await import(\"../../src/shared/util.js\");\n  const dummyTransport = {\n    commonObjs: new Map(),\n    getRenderingIntent: () => ({ renderingIntent: 2, cacheKey: \"test\" }),\n  };\n  const pdfPageProxy = new PDFPageProxy(0, {}, dummyTransport, false);\n  const intentState = {\n    renderTasks: new Set(),\n    operatorList: { fnArray: [], argsArray: [], lastChunk: false, separateAnnots: null },\n  };\n  pdfPageProxy._intentStates.set(\"test\", intentState);\n  pdfPageProxy._renderPageChunk(\n    { fnArray: [], argsArray: [], lastChunk: true, separateAnnots: null },\n    intentState\n  );\n  assert.strictEqual(pdfPageProxy._intentStates.size, 0);\n});\n",
    "i3_gpt-4o": "it(\"should immediately clear intentStates when a last chunk is received in nonprint mode\", async () => {\n  const { PDFPageProxy } = await import(\"../../src/display/api.js\");\n  const { assert } = await import(\"../../src/shared/util.js\");\n  const dummyTransport = {\n    commonObjs: new Map(),\n    getRenderingIntent: () => ({ renderingIntent: 2, cacheKey: \"test\" }),\n  };\n  const pdfPageProxy = new PDFPageProxy(0, {}, dummyTransport, false);\n  const intentState = {\n    renderTasks: new Set(),\n    operatorList: { fnArray: [], argsArray: [], lastChunk: false, separateAnnots: null },\n  };\n  pdfPageProxy._intentStates.set(\"test\", intentState);\n  pdfPageProxy._renderPageChunk(\n    { fnArray: [], argsArray: [], lastChunk: true, separateAnnots: null },\n    intentState\n  );\n  assert.strictEqual(pdfPageProxy._intentStates.size, 0);\n});\n",
    "i3_llama-3.3-70b-versatile": "it(\"should immediately clear intentStates when a last chunk is received in nonprint mode\", async () => {\n  const { PDFPageProxy } = await import(\"../../src/display/api.js\");\n  const { assert } = await import(\"../../src/shared/util.js\");\n  const dummyTransport = {\n    commonObjs: new Map(),\n    getRenderingIntent: () => ({ renderingIntent: 2, cacheKey: \"test\" }),\n  };\n  const pdfPageProxy = new PDFPageProxy(0, {}, dummyTransport, false);\n  const intentState = {\n    renderTasks: new Set(),\n    operatorList: { fnArray: [], argsArray: [], lastChunk: false, separateAnnots: null },\n  };\n  pdfPageProxy._intentStates.set(\"test\", intentState);\n  pdfPageProxy._renderPageChunk(\n    { fnArray: [], argsArray: [], lastChunk: true, separateAnnots: null },\n    intentState\n  );\n  assert.strictEqual(pdfPageProxy._intentStates.size, 0);\n});\n",
    "i4_deepseek-r1-distill-llama-70b": "it(\"should immediately clear intentStates when a last chunk is received in nonprint mode\", async () => {\n  const { PDFPageProxy } = await import(\"../../src/display/api.js\");\n  const { assert } = await import(\"../../src/shared/util.js\");\n  const dummyTransport = {\n    commonObjs: new Map(),\n    getRenderingIntent: () => ({ renderingIntent: 2, cacheKey: \"test\" }),\n  };\n  const pdfPageProxy = new PDFPageProxy(0, {}, dummyTransport, false);\n  const intentState = {\n    renderTasks: new Set(),\n    operatorList: { fnArray: [], argsArray: [], lastChunk: false, separateAnnots: null },\n  };\n  pdfPageProxy._intentStates.set(\"test\", intentState);\n  pdfPageProxy._renderPageChunk(\n    { fnArray: [], argsArray: [], lastChunk: true, separateAnnots: null },\n    intentState\n  );\n  assert.strictEqual(pdfPageProxy._intentStates.size, 0);\n});\n",
    "i4_gpt-4o": "it(\"should immediately clear intentStates when a last chunk is received in nonprint mode\", async () => {\n  const { PDFPageProxy } = await import(\"../../src/display/api.js\");\n  const { assert } = await import(\"../../src/shared/util.js\");\n  const dummyTransport = {\n    commonObjs: new Map(),\n    getRenderingIntent: () => ({ renderingIntent: 2, cacheKey: \"test\" }),\n  };\n  const pdfPageProxy = new PDFPageProxy(0, {}, dummyTransport, false);\n  const intentState = {\n    renderTasks: new Set(),\n    operatorList: { fnArray: [], argsArray: [], lastChunk: false, separateAnnots: null },\n  };\n  pdfPageProxy._intentStates.set(\"test\", intentState);\n  pdfPageProxy._renderPageChunk(\n    { fnArray: [], argsArray: [], lastChunk: true, separateAnnots: null },\n    intentState\n  );\n  assert.strictEqual(pdfPageProxy._intentStates.size, 0);\n});\n",
    "i4_llama-3.3-70b-versatile": "it(\"should immediately clear intentStates when a last chunk is received in nonprint mode\", async () => {\n  const { PDFPageProxy } = await import(\"../../src/display/api.js\");\n  const { assert } = await import(\"../../src/shared/util.js\");\n  const dummyTransport = {\n    commonObjs: new Map(),\n    getRenderingIntent: () => ({ renderingIntent: 2, cacheKey: \"test\" }),\n  };\n  const pdfPageProxy = new PDFPageProxy(0, {}, dummyTransport, false);\n  const intentState = {\n    renderTasks: new Set(),\n    operatorList: { fnArray: [], argsArray: [], lastChunk: false, separateAnnots: null },\n  };\n  pdfPageProxy._intentStates.set(\"test\", intentState);\n  pdfPageProxy._renderPageChunk(\n    { fnArray: [], argsArray: [], lastChunk: true, separateAnnots: null },\n    intentState\n  );\n  assert.strictEqual(pdfPageProxy._intentStates.size, 0);\n});\n",
    "i5_deepseek-r1-distill-llama-70b": "it(\"should immediately clear intentStates when a last chunk is received in nonprint mode\", async () => {\n  const { PDFPageProxy } = await import(\"../../src/display/api.js\");\n  const { assert } = await import(\"../../src/shared/util.js\");\n  const dummyTransport = {\n    commonObjs: new Map(),\n    getRenderingIntent: () => ({ renderingIntent: 2, cacheKey: \"test\" }),\n  };\n  const pdfPageProxy = new PDFPageProxy(0, {}, dummyTransport, false);\n  const intentState = {\n    renderTasks: new Set(),\n    operatorList: { fnArray: [], argsArray: [], lastChunk: false, separateAnnots: null },\n  };\n  pdfPageProxy._intentStates.set(\"test\", intentState);\n  pdfPageProxy._renderPageChunk(\n    { fnArray: [], argsArray: [], lastChunk: true, separateAnnots: null },\n    intentState\n  );\n  assert.strictEqual(pdfPageProxy._intentStates.size, 0);\n});\n",
    "i5_gpt-4o": "it(\"should immediately clear intentStates when a last chunk is received in nonprint mode\", async () => {\n  const { PDFPageProxy } = await import(\"../../src/display/api.js\");\n  const { assert } = await import(\"../../src/shared/util.js\");\n  const dummyTransport = {\n    commonObjs: new Map(),\n    getRenderingIntent: () => ({ renderingIntent: 2, cacheKey: \"test\" }),\n  };\n  const pdfPageProxy = new PDFPageProxy(0, {}, dummyTransport, false);\n  const intentState = {\n    renderTasks: new Set(),\n    operatorList: { fnArray: [], argsArray: [], lastChunk: false, separateAnnots: null },\n  };\n  pdfPageProxy._intentStates.set(\"test\", intentState);\n  pdfPageProxy._renderPageChunk(\n    { fnArray: [], argsArray: [], lastChunk: true, separateAnnots: null },\n    intentState\n  );\n  assert.strictEqual(pdfPageProxy._intentStates.size, 0);\n});\n",
    "i5_llama-3.3-70b-versatile": "it(\"should immediately clear intentStates when a last chunk is received in nonprint mode\", async () => {\n  const { PDFPageProxy } = await import(\"../../src/display/api.js\");\n  const { assert } = await import(\"../../src/shared/util.js\");\n  const dummyTransport = {\n    commonObjs: new Map(),\n    getRenderingIntent: () => ({ renderingIntent: 2, cacheKey: \"test\" }),\n  };\n  const pdfPageProxy = new PDFPageProxy(0, {}, dummyTransport, false);\n  const intentState = {\n    renderTasks: new Set(),\n    operatorList: { fnArray: [], argsArray: [], lastChunk: false, separateAnnots: null },\n  };\n  pdfPageProxy._intentStates.set(\"test\", intentState);\n  pdfPageProxy._renderPageChunk(\n    { fnArray: [], argsArray: [], lastChunk: true, separateAnnots: null },\n    intentState\n  );\n  assert.strictEqual(pdfPageProxy._intentStates.size, 0);\n});\n"
  },
  "19390": {
    "i1_deepseek-r1-distill-llama-70b": "it(\"should render password fields as password input elements\", async () => {\n  const { AnnotationFactory } = await import(\"../../src/core/annotation.js\");\n  const { DefaultStandardFontDataFactory } = await import(\"../../src/display/standard_fontdata_factory.js\");\n  const { createIdFactory, XRefMock } = await import(\"./test_utils.js\");\n\n  const idFactory = createIdFactory();\n  const xref = new XRefMock(idFactory);\n  const fontDataFactory = new DefaultStandardFontDataFactory();\n\n  // Create a sample PDF with a password field\n  const pdfData = `\n    1 0 obj\n    <</Type /Catalog /Pages 2 0 R>>\n    endobj\n    2 0 obj\n    <</Type /Pages /Kids [3 0 R] /Count 1>>\n    endobj\n    3 0 obj\n    <</Type /Page /Parent 2 0 R /Resources 4 0 R\n      /Contents [] >>\n    endobj\n    4 0 obj\n    <</ProcSet [/PDF /Text] >>\n    endobj\n    5 0 obj\n    <</FT /Btn /Ff 0 /Type /Widget /Subtype /Widget\n      /T (passwordField) /F (0) >>\n    endobj\n  `;\n\n  const parser = new Parser(new Lexer(new StringStream(pdfData)));\n  const pdf = await parser.parse();\n\n  const annotationFactory = new AnnotationFactory(\n    new DefaultStandardFontDataFactory(),\n    fontDataFactory,\n    xref,\n    idFactory\n  );\n\n  const annotation = await annotationFactory.createAnnotation(\n    pdf.get(5),\n    null,\n    null,\n    null,\n    null\n  );\n\n  expect(annotation.data.password).toBe(true);\n\n  const element = await annotation.render();\n  const html = element.outerHTML;\n\n  expect(html).toContain(\"input type=\\\"password\\\"\");\n});",
    "i1_gpt-4o": "it(\"should render password fields with obscured characters\", async () => {\n  const { WidgetAnnotation } = await import(\"../../src/core/annotation.js\");\n  const { AnnotationFieldFlag } = await import(\"../../src/shared/util.js\");\n  const dict = new Dict();\n  dict.set(\"Ff\", AnnotationFieldFlag.PASSWORD);\n  dict.set(\"V\", \"secret\");\n  const widgetAnnotation = new WidgetAnnotation({\n    dict,\n    xref: new XRefMock(),\n    annotationGlobals: { acroForm: new Dict() },\n  });\n\n  const { TextWidgetAnnotationElement } = await import(\"../../src/display/annotation_layer.js\");\n  const element = new TextWidgetAnnotationElement({\n    data: widgetAnnotation.data,\n    renderForms: true,\n    annotationStorage: new Map(),\n  });\n\n  const renderedElement = element.render();\n  const inputElement = renderedElement.querySelector(\"input\");\n  expect(inputElement.type).toEqual(\"password\");\n});",
    "i1_llama-3.3-70b-versatile": "it(\"should render password fields as password fields not text fields\", async () => {\n  const { Annotation, AnnotationFactory, getQuadPoints } = await import(\"../../src/core/annotation.js\");\n  const { AnnotationFieldFlag } = await import(\"../../src/shared/util.js\");\n  const { Dict, Name, Ref } = await import(\"../../src/core/primitives.js\");\n  const { Parser } = await import(\"../../src/core/parser.js\");\n  const { StringStream } = await import(\"../../src/core/stream.js\");\n  const { PartialEvaluator } = await import(\"../../src/core/evaluator.js\");\n  const { writeChanges } = await import(\"../../src/core/writer.js\");\n\n  const pdfData = new Uint8Array([\n    0x25, 0x50, 0x44, 0x46, 0x2d, 0x31, 0x2e, 0x34, 0x0a, 0x25, 0xe2, 0xe3, 0xcf, 0xd3, 0x0a,\n    0x31, 0x20, 0x30, 0x20, 0x6f, 0x62, 0x6a, 0x0a, 0x3c, 0x3c, 0x0a, 0x2f, 0x54, 0x79, 0x70,\n    0x65, 0x20, 0x2f, 0x50, 0x61, 0x67, 0x65, 0x0a, 0x2f, 0x50, 0x61, 0x72, 0x65, 0x6e, 0x74,\n    0x20, 0x32, 0x20, 0x30, 0x20, 0x52, 0x0a, 0x3e, 0x3e, 0x0a, 0x65, 0x6e, 0x64, 0x6f, 0x62,\n    0x6a, 0x0a, 0x32, 0x20, 0x30, 0x20, 0x6f, 0x62, 0x6a, 0x0a, 0x3c, 0x3c, 0x0a, 0x2f, 0x54,\n    0x79, 0x70, 0x65, 0x20, 0x2f, 0x50, 0x61, 0x67, 0x65, 0x0a, 0x2f, 0x4d, 0x65, 0x64, 0x69,\n    0x61, 0x42, 0x6f, 0x78, 0x20, 0x5b, 0x30, 0x20, 0x30, 0x20, 0x35, 0x",
    "i2_deepseek-r1-distill-llama-70b": "it(\"should correctly identify password fields and set input type to password\", async () => {\n  const { PDFDocument, PDFPageProxy } = await import(\"../../src/display/api.js\");\n  const pdfPath = require.toURL(\"password-field.pdf\");\n  const pdf = await PDFDocument.load(pdfPath);\n  const page = await pdf.getPage(1);\n  const annotations = await page.getAnnotations();\n\n  let textWidgetAnnotation;\n  for (const annotation of annotations) {\n    if (annotation instanceof TextWidgetAnnotation) {\n      textWidgetAnnotation = annotation;\n      break;\n    }\n  }\n\n  const expectedPasswordField = true;\n  const actualPasswordField = textWidgetAnnotation.data.password;\n  expect(actualPasswordField).toBe(expectedPasswordField);\n\n  const fieldObject = textWidgetAnnotation.getFieldObject();\n  const expectedType = \"password\";\n  const actualType = fieldObject.type;\n  expect(actualType).toBe(expectedType);\n});",
    "i2_gpt-4o": "it(\"should render password fields with obscured characters\", async () => {\n  const { AnnotationFieldFlag } = await import(\"../../src/shared/util.js\");\n  const { WidgetAnnotation } = await import(\"../../src/core/annotation.js\");\n  const { TextWidgetAnnotationElement } = await import(\"../../src/display/annotation_layer.js\");\n\n  const params = {\n    dict: {\n      get: (key) => {\n        if (key === \"Ff\") return AnnotationFieldFlag.PASSWORD;\n        if (key === \"V\") return \"secret\";\n        return null;\n      },\n      has: () => false,\n    },\n    xref: null,\n    annotationGlobals: { acroForm: { get: () => null } },\n    needAppearances: false,\n  };\n\n  const widgetAnnotation = new WidgetAnnotation(params);\n  const textWidgetAnnotationElement = new TextWidgetAnnotationElement({\n    data: widgetAnnotation.data,\n    renderForms: true,\n    annotationStorage: new Map(),\n  });\n\n  const container = textWidgetAnnotationElement.render();\n  const inputElement = container.querySelector(\"input\");\n\n  const expectedType = \"password\";\n  const actualType = inputElement.type;\n\n  expect(actualType).toEqual(expectedType);\n});",
    "i2_llama-3.3-70b-versatile": "it(\"should render password fields as password fields not text fields\", async () => {\n  const { PDFDocument } = await import(\"../../src/core/document.js\");\n  const { AnnotationLayer } = await import(\"../../src/display/annotation_layer.js\");\n  const { AnnotationStorage } = await import(\"../../src/display/annotation_storage.js\");\n  const pdfData = new Uint8Array([37, 80, 68, 70, 45, 49, 46, 53, 10, 25, 50, 55, 48, 55, 51, 55, 10, 28, 111, 98, 106, 32, 51, 32, 48, 32, 111, 98, 106, 32, 60, 60, 47, 70, 49, 32, 49, 32, 48, 32, 82, 32, 47, 80, 97, 115, 115, 87, 111, 114, 100, 32, 49, 32, 48, 32, 82, 62, 62, 32, 101, 110, 100, 111, 98, 106, 10, 28, 111, 98, 106, 32, 51, 32, 48, 32, 111, 98, 106, 32, 60, 60, 47, 70, 49, 32, 49, 32, 48, 32, 82, 32, 47, 80, 97, 115, 115, 87, 111, 114, 100, 32, 49, 32, 48, 32, 82, 62, 62, 32, 101, 110, 100, 111, 98, 106, 10, 28, 111, 98, 106, 32, 51, 32, 48, 32, 111, 98, 106, 32, 60, 60, 47, 70, 49, 32, 49, 32, 48, 32, 82, 32, 47, 80, 97, 115, 115, 87, 111, 114, 100, 32, 49, 32, 48, 32, 82, 62, 62, 32, 101, 110, 100, 111, 98, 106, 10, 28, 111, 98, 106, 32, 51, 32, 48, 32, 111, 98, 106, 32, 60, 60, 47, 70, 49, 32, 49, 32, 48, 32, 82, 32, 47, 80, 97, 115, 115, 87, 111, 114, 100, 32, 49, 32, 48, 32, 82,",
    "i3_deepseek-r1-distill-llama-70b": "it(\"should correctly render password fields as password input fields\", async () => {\n  const { createIdFactory } = await import(\"../../src/core/annotation.js\");\n  const idFactory = createIdFactory();\n\n  // Create a mock annotation with password field flag set\n  const annotation = new Dict({\n    FT: \"Tx\", // Text field\n    Ff: AnnotationFieldFlag.PASSWORD,\n    T: \"Password\",\n    V: \"test\",\n  });\n\n  const factory = new AnnotationFactory();\n  const data = await factory.create({\n    xref: new XRefMock(),\n    ref: new Ref(),\n    annotationGlobals: {},\n    idFactory,\n    collectFields: false,\n    pageRef: 0,\n  });\n\n  // Render the annotation\n  const element = await AnnotationElementFactory.create({\n    data: data,\n    layer: {},\n    linkService: {},\n    downloadManager: {},\n    imageResourcesPath: \"\",\n    renderForms: true,\n    svgFactory: {},\n    annotationStorage: {},\n    enableScripting: false,\n    hasJSActions: false,\n    fieldObjects: {},\n    parent: {},\n  });\n\n  const input = element.render().querySelector(\"input\");\n  expect(input.type).toBe(\"password\");\n});",
    "i3_gpt-4o": "it(\"should render password fields with obscured characters\", async () => {\n  const { WidgetAnnotation } = await import(\"../../src/core/annotation.js\");\n  const { AnnotationFieldFlag } = await import(\"../../src/shared/util.js\");\n\n  const passwordFieldDict = new Dict();\n  passwordFieldDict.set(\"FT\", Name.get(\"Tx\"));\n  passwordFieldDict.set(\"Ff\", AnnotationFieldFlag.PASSWORD);\n\n  const widgetAnnotation = new WidgetAnnotation({\n    dict: passwordFieldDict,\n    xref: new XRefMock(),\n    annotationGlobals: { acroForm: Dict.empty },\n  });\n\n  const expected = true;\n  const actual = widgetAnnotation.data.password;\n\n  expect(actual).toEqual(expected);\n});",
    "i3_llama-3.3-70b-versatile": "it(\"should render password fields correctly\", async () => {\n  const pdfManager = new XRefMock();\n  const annotationGlobals = await AnnotationFactory.createGlobals(pdfManager);\n  const idFactory = createIdFactory();\n  const dict = new Dict();\n  dict.set(\"FT\", Name.get(\"Tx\"));\n  dict.set(\"Ff\", AnnotationFieldFlag.PASSWORD);\n  dict.set(\"T\", stringToBytes(\"Test\"));\n  dict.set(\"Rect\", [0, 0, 100, 100]);\n  const annotation = await AnnotationFactory.create(\n    pdfManager,\n    new Ref(1),\n    annotationGlobals,\n    idFactory,\n    false\n  );\n  const widgetAnnotation = annotation instanceof WidgetAnnotation;\n  expect(widgetAnnotation).toBe(true);\n  const data = annotation.data;\n  expect(data.password).toBe(true);\n  const textWidgetAnnotation = new TextWidgetAnnotation({\n    dict,\n    xref: pdfManager.xref,\n    annotationGlobals,\n    ref: new Ref(1),\n    evaluatorOptions: {},\n  });\n  const fieldObject = textWidgetAnnotation.getFieldObject();\n  expect(fieldObject.password).toBe(true);\n});",
    "i4_deepseek-r1-distill-llama-70b": "it(\"should correctly identify and render password fields as password input\", async () => {\n  const { PDFDocument, PDFViewer, PDFWorker } = await import(\"../../src/display/annotation_layer.js\");\n  const pdfPath = \"../../src/display/annotation_layer.js\";\n  const pdfDoc = await PDFDocument.create(null, new PDFViewer({\n    cMapPacked: true,\n    cMapUrl: \"https://cdn.jsdelivr.net/npm/pdfjs-dist@2.7.570/build/generic/web/Type1-woff2base64,Base64\", \n    workerSrc: \"../../src/display/worker.js\"\n  }));\n\n  const page = await pdfDoc.getPage(1);\n  const viewport = page.getViewport(1);\n\n  const annotations = await page.getAnnotations({ intent: \"display\" });\n  const textWidget = annotations.find(a => a instanceof TextWidgetAnnotation);\n\n  expect(textWidget.data.password).to.be.true;\n});",
    "i4_gpt-4o": "it(\"should render password fields as password input type\", async () => {\n  const { TextWidgetAnnotation } = await import(\"../../src/core/annotation.js\");\n  const { AnnotationFieldFlag } = await import(\"../../src/shared/util.js\");\n  const { TextWidgetAnnotationElement } = await import(\"../../src/display/annotation_layer.js\");\n\n  const annotationData = {\n    id: \"test-id\",\n    fieldFlags: AnnotationFieldFlag.PASSWORD,\n    fieldValue: \"secret\",\n    defaultFieldValue: \"default\",\n    multiLine: false,\n    readOnly: false,\n    hidden: false,\n    annotationFlags: 0,\n    rect: [0, 0, 100, 20],\n    borderStyle: { width: 1 },\n    color: [0, 0, 0],\n    backgroundColor: [255, 255, 255],\n    borderColor: [0, 0, 0],\n    rotation: 0,\n    fieldName: \"passwordField\",\n    actions: {},\n    pageIndex: 0,\n  };\n\n  const annotation = new TextWidgetAnnotation({ data: annotationData });\n  const element = new TextWidgetAnnotationElement({\n    data: annotation.data,\n    layer: document.createElement(\"div\"),\n    linkService: {},\n    renderForms: true,\n  });\n\n  const renderedElement = element.render();\n  const inputElement = renderedElement.querySelector(\"input\");\n\n  const expectedType = \"password\";\n  const actualType = inputElement.type;\n\n  expect(actualType).toBe(expectedType);\n});",
    "i4_llama-3.3-70b-versatile": "it(\"should render password fields as password fields\", async () => {\n  const { Annotation } = await import(\"../../src/core/annotation.js\");\n  const { WidgetAnnotation } = await import(\"../../src/core/annotation.js\");\n  const { TextWidgetAnnotation } = await import(\"../../src/core/annotation.js\");\n  const { AnnotationFactory } = await import(\"../../src/core/annotation.js\");\n\n  const dict = {\n    FT: \"Tx\",\n    Ff: AnnotationFieldFlag.PASSWORD,\n    V: \"password\",\n  };\n\n  const annotation = new WidgetAnnotation({\n    dict,\n    ref: null,\n    annotationGlobals: {},\n    subtype: \"Widget\",\n    id: \"id\",\n    annotationType: AnnotationType.WIDGET,\n    collectFields: true,\n    orphanFields: null,\n    pageIndex: null,\n    pageRef: null,\n  });\n\n  const textWidgetAnnotation = new TextWidgetAnnotation({\n    data: annotation.data,\n    dict,\n    xref: null,\n    annotationGlobals: {},\n    subtype: \"Tx\",\n    id: \"id\",\n    annotationType: AnnotationType.WIDGET,\n    collectFields: true,\n    orphanFields: null,\n    pageIndex: null,\n    pageRef: null,\n  });\n\n  const fieldObject = textWidgetAnnotation.getFieldObject();\n\n  expect(fieldObject.password).toBe(true);\n});",
    "i5_deepseek-r1-distill-llama-70b": "it(\"should render password fields as password input types\", async () => {\n  const { PDFDocumentLoadingTask } = await import(\"../../src/display/api.js\");\n  const { Annotation } = await import(\"../../src/core/annotation.js\");\n  const { TextWidgetAnnotation } = await import(\"../../src/core/annotation.js\");\n\n  // Load a PDF with a password field\n  const pdf = await PDFDocumentLoadingTask.load(\"test.pdf\");\n  const page = await pdf.getPage(1);\n  const annotations = await page.getAnnotations();\n\n  // Find the password field annotation\n  const passwordAnnotation = annotations.find(annotation => \n    annotation instanceof TextWidgetAnnotation && \n    annotation.data.password\n  );\n\n  // The test expects the password field to be correctly identified\n  expect(passwordAnnotation.data.password).toBe(true);\n});",
    "i5_gpt-4o": "it(\"should render password fields with obscured characters\", async () => {\n  const { AnnotationFactory } = await import(\"../../src/core/annotation.js\");\n  const { AnnotationFieldFlag } = await import(\"../../src/shared/util.js\");\n  const { AnnotationLayer } = await import(\"../../src/display/annotation_layer.js\");\n\n  const passwordFieldDict = {\n    get: (key) => {\n      if (key === \"FT\") return { name: \"Tx\" };\n      if (key === \"Ff\") return AnnotationFieldFlag.PASSWORD;\n      return null;\n    },\n  };\n\n  const passwordField = AnnotationFactory.create(passwordFieldDict);\n  const annotationStorage = new Map();\n  const element = AnnotationLayer.render({\n    annotation: passwordField,\n    page: { view: [0, 0, 100, 100] },\n    viewport: { transform: [1, 0, 0, 1, 0, 0] },\n    annotationStorage,\n  });\n\n  const inputElement = element.querySelector(\"input\");\n  const actualType = inputElement.type;\n  const expectedType = \"password\";\n\n  expect(actualType).toBe(expectedType);\n});",
    "i5_llama-3.3-70b-versatile": "it(\"should render password fields as password fields not text fields\", async () => {\n  const { PDFDocument } = await import(\"../../src/core/document.js\");\n  const { AnnotationFieldFlag } = await import(\"../../src/shared/util.js\");\n  const pdfData = new Uint8Array([37, 80, 68, 70, 45, 49, 46, 55, 10, 37, 226, 227, 207, 211, 13, 10, 49, 32, 48, 32, 111, 98, 106, 10, 60, 60, 10, 47, 84, 121, 112, 101, 10, 47, 80, 97, 103, 101, 10, 47, 80, 97, 114, 101, 110, 116, 10, 49, 32, 48, 32, 82, 10, 62, 62, 10, 101, 110, 100, 111, 98, 106, 10, 50, 32, 48, 32, 111, 98, 106, 10, 60, 60, 10, 47, 70, 105, 108, 116, 101, 114, 10, 47, 70, 108, 97, 116, 101, 68, 101, 99, 111, 100, 101, 10, 62, 62, 10, 115, 116, 114, 101, 97, 109, 10, 120, 55, 90, 105, 110, 102, 108, 97, 116, 101, 10, 53, 52, 53, 52, 53, 52, 53, 52, 10, 101, 110, 100, 115, 116, 114, 101, 97, 109, 10, 101, 110, 100, 111, 98, 106, 10, 51, 32, 48, 32, 111, 98, 106, 10, 60, 60, 10, 47, 84, 121, 112, 101, 10, 47, 88, 79, 98, 106, 10, 47, 83, 117, 98, 116, 121, 112, 101, 10, 47, 70, 111, 114, 109, 10, 47, 87, 105, 100, 103, 101, 116, 10, 47, 70, 108, 97, 103, 10, 50, 32, 62, 62, 10, 115, 116, 114, 101, 97, 109, 10, 120, 55, 90, 105, 110, 102, 108,"
  },
  "19513": {
    "i1_deepseek-r1-distill-llama-70b": "it(\"should not cache null XRef entries so that a later valid entry is fetched\", async () => {\n  const { XRef } = await import(\"../../src/core/xref.js\");\n  const dummyStream = {};\n  const dummyPdfManager = {};\n  const dummyRef = { num: 1, toString: () => \"1 0 R\" };\n  let callCount = 0;\n  const fakeXRef = new XRef(dummyStream, dummyPdfManager);\n  fakeXRef.getEntry = function (num) {\n    callCount++;\n    return callCount === 1 ? null : { uncompressed: true };\n  };\n  // First fetch returns null and, in pre-patch, caches the null.\n  const firstFetch = fakeXRef.fetch(dummyRef);\n  // Second fetch:\n  const secondFetch = fakeXRef.fetch(dummyRef);\n  if (secondFetch === null) {\n    throw new Error(\"Bug persists: cached null entry returned on subsequent fetch.\");\n  }\n});",
    "i1_gpt-4o": "it(\"should not cache null XRef entries so that a later valid entry is fetched\", async () => {\n  const { XRef } = await import(\"../../src/core/xref.js\");\n  const dummyStream = {};\n  const dummyPdfManager = {};\n  const dummyRef = { num: 1, toString: () => \"1 0 R\" };\n  let callCount = 0;\n  const fakeXRef = new XRef(dummyStream, dummyPdfManager);\n  fakeXRef.getEntry = function (num) {\n    callCount++;\n    return callCount === 1 ? null : { uncompressed: true };\n  };\n  // First fetch returns null and, in pre-patch, caches the null.\n  const firstFetch = fakeXRef.fetch(dummyRef);\n  // Second fetch:\n  const secondFetch = fakeXRef.fetch(dummyRef);\n  if (secondFetch === null) {\n    throw new Error(\"Bug persists: cached null entry returned on subsequent fetch.\");\n  }\n});",
    "i1_llama-3.3-70b-versatile": "it(\"should not cache null XRef entries so that a later valid entry is fetched\", async () => {\n  const { XRef } = await import(\"../../src/core/xref.js\");\n  const dummyStream = {};\n  const dummyPdfManager = {};\n  const dummyRef = { num: 1, toString: () => \"1 0 R\" };\n  let callCount = 0;\n  const fakeXRef = new XRef(dummyStream, dummyPdfManager);\n  fakeXRef.getEntry = function (num) {\n    callCount++;\n    return callCount === 1 ? null : { uncompressed: true };\n  };\n  // First fetch returns null and, in pre-patch, caches the null.\n  const firstFetch = fakeXRef.fetch(dummyRef);\n  // Second fetch:\n  const secondFetch = fakeXRef.fetch(dummyRef);\n  if (secondFetch === null) {\n    throw new Error(\"Bug persists: cached null entry returned on subsequent fetch.\");\n  }\n});",
    "i1_MOCK": "it(\"should not cache null XRef entries so that a later valid entry is fetched\", async () => {\n  const { XRef } = await import(\"../../src/core/xref.js\");\n  const dummyStream = {};\n  const dummyPdfManager = {};\n  const dummyRef = { num: 1, toString: () => \"1 0 R\" };\n  let callCount = 0;\n  const fakeXRef = new XRef(dummyStream, dummyPdfManager);\n  fakeXRef.getEntry = function (num) {\n    callCount++;\n    return callCount === 1 ? null : { uncompressed: true };\n  };\n  // First fetch returns null and, in pre-patch, caches the null.\n  const firstFetch = fakeXRef.fetch(dummyRef);\n  // Second fetch:\n  const secondFetch = fakeXRef.fetch(dummyRef);\n  if (secondFetch === null) {\n    throw new Error(\"Bug persists: cached null entry returned on subsequent fetch.\");\n  }\n});",
    "i2_deepseek-r1-distill-llama-70b": "it(\"should not cache null XRef entries so that a later valid entry is fetched\", async () => {\n  const { XRef } = await import(\"../../src/core/xref.js\");\n  const dummyStream = {};\n  const dummyPdfManager = {};\n  const dummyRef = { num: 1, toString: () => \"1 0 R\" };\n  let callCount = 0;\n  const fakeXRef = new XRef(dummyStream, dummyPdfManager);\n  fakeXRef.getEntry = function (num) {\n    callCount++;\n    return callCount === 1 ? null : { uncompressed: true };\n  };\n  // First fetch returns null and, in pre-patch, caches the null.\n  const firstFetch = fakeXRef.fetch(dummyRef);\n  // Second fetch:\n  const secondFetch = fakeXRef.fetch(dummyRef);\n  if (secondFetch === null) {\n    throw new Error(\"Bug persists: cached null entry returned on subsequent fetch.\");\n  }\n});",
    "i2_gpt-4o": "it(\"should not cache null XRef entries so that a later valid entry is fetched\", async () => {\n  const { XRef } = await import(\"../../src/core/xref.js\");\n  const dummyStream = {};\n  const dummyPdfManager = {};\n  const dummyRef = { num: 1, toString: () => \"1 0 R\" };\n  let callCount = 0;\n  const fakeXRef = new XRef(dummyStream, dummyPdfManager);\n  fakeXRef.getEntry = function (num) {\n    callCount++;\n    return callCount === 1 ? null : { uncompressed: true };\n  };\n  // First fetch returns null and, in pre-patch, caches the null.\n  const firstFetch = fakeXRef.fetch(dummyRef);\n  // Second fetch:\n  const secondFetch = fakeXRef.fetch(dummyRef);\n  if (secondFetch === null) {\n    throw new Error(\"Bug persists: cached null entry returned on subsequent fetch.\");\n  }\n});",
    "i2_llama-3.3-70b-versatile": "it(\"should not cache null XRef entries so that a later valid entry is fetched\", async () => {\n  const { XRef } = await import(\"../../src/core/xref.js\");\n  const dummyStream = {};\n  const dummyPdfManager = {};\n  const dummyRef = { num: 1, toString: () => \"1 0 R\" };\n  let callCount = 0;\n  const fakeXRef = new XRef(dummyStream, dummyPdfManager);\n  fakeXRef.getEntry = function (num) {\n    callCount++;\n    return callCount === 1 ? null : { uncompressed: true };\n  };\n  // First fetch returns null and, in pre-patch, caches the null.\n  const firstFetch = fakeXRef.fetch(dummyRef);\n  // Second fetch:\n  const secondFetch = fakeXRef.fetch(dummyRef);\n  if (secondFetch === null) {\n    throw new Error(\"Bug persists: cached null entry returned on subsequent fetch.\");\n  }\n});",
    "i3_deepseek-r1-distill-llama-70b": "it(\"should not cache null XRef entries so that a later valid entry is fetched\", async () => {\n  const { XRef } = await import(\"../../src/core/xref.js\");\n  const dummyStream = {};\n  const dummyPdfManager = {};\n  const dummyRef = { num: 1, toString: () => \"1 0 R\" };\n  let callCount = 0;\n  const fakeXRef = new XRef(dummyStream, dummyPdfManager);\n  fakeXRef.getEntry = function (num) {\n    callCount++;\n    return callCount === 1 ? null : { uncompressed: true };\n  };\n  // First fetch returns null and, in pre-patch, caches the null.\n  const firstFetch = fakeXRef.fetch(dummyRef);\n  // Second fetch:\n  const secondFetch = fakeXRef.fetch(dummyRef);\n  if (secondFetch === null) {\n    throw new Error(\"Bug persists: cached null entry returned on subsequent fetch.\");\n  }\n});",
    "i3_gpt-4o": "it(\"should not cache null XRef entries so that a later valid entry is fetched\", async () => {\n  const { XRef } = await import(\"../../src/core/xref.js\");\n  const dummyStream = {};\n  const dummyPdfManager = {};\n  const dummyRef = { num: 1, toString: () => \"1 0 R\" };\n  let callCount = 0;\n  const fakeXRef = new XRef(dummyStream, dummyPdfManager);\n  fakeXRef.getEntry = function (num) {\n    callCount++;\n    return callCount === 1 ? null : { uncompressed: true };\n  };\n  // First fetch returns null and, in pre-patch, caches the null.\n  const firstFetch = fakeXRef.fetch(dummyRef);\n  // Second fetch:\n  const secondFetch = fakeXRef.fetch(dummyRef);\n  if (secondFetch === null) {\n    throw new Error(\"Bug persists: cached null entry returned on subsequent fetch.\");\n  }\n});",
    "i3_llama-3.3-70b-versatile": "it(\"should not cache null XRef entries so that a later valid entry is fetched\", async () => {\n  const { XRef } = await import(\"../../src/core/xref.js\");\n  const dummyStream = {};\n  const dummyPdfManager = {};\n  const dummyRef = { num: 1, toString: () => \"1 0 R\" };\n  let callCount = 0;\n  const fakeXRef = new XRef(dummyStream, dummyPdfManager);\n  fakeXRef.getEntry = function (num) {\n    callCount++;\n    return callCount === 1 ? null : { uncompressed: true };\n  };\n  // First fetch returns null and, in pre-patch, caches the null.\n  const firstFetch = fakeXRef.fetch(dummyRef);\n  // Second fetch:\n  const secondFetch = fakeXRef.fetch(dummyRef);\n  if (secondFetch === null) {\n    throw new Error(\"Bug persists: cached null entry returned on subsequent fetch.\");\n  }\n});",
    "i4_deepseek-r1-distill-llama-70b": "it(\"should not cache null XRef entries so that a later valid entry is fetched\", async () => {\n  const { XRef } = await import(\"../../src/core/xref.js\");\n  const dummyStream = {};\n  const dummyPdfManager = {};\n  const dummyRef = { num: 1, toString: () => \"1 0 R\" };\n  let callCount = 0;\n  const fakeXRef = new XRef(dummyStream, dummyPdfManager);\n  fakeXRef.getEntry = function (num) {\n    callCount++;\n    return callCount === 1 ? null : { uncompressed: true };\n  };\n  // First fetch returns null and, in pre-patch, caches the null.\n  const firstFetch = fakeXRef.fetch(dummyRef);\n  // Second fetch:\n  const secondFetch = fakeXRef.fetch(dummyRef);\n  if (secondFetch === null) {\n    throw new Error(\"Bug persists: cached null entry returned on subsequent fetch.\");\n  }\n});",
    "i4_gpt-4o": "it(\"should not cache null XRef entries so that a later valid entry is fetched\", async () => {\n  const { XRef } = await import(\"../../src/core/xref.js\");\n  const dummyStream = {};\n  const dummyPdfManager = {};\n  const dummyRef = { num: 1, toString: () => \"1 0 R\" };\n  let callCount = 0;\n  const fakeXRef = new XRef(dummyStream, dummyPdfManager);\n  fakeXRef.getEntry = function (num) {\n    callCount++;\n    return callCount === 1 ? null : { uncompressed: true };\n  };\n  // First fetch returns null and, in pre-patch, caches the null.\n  const firstFetch = fakeXRef.fetch(dummyRef);\n  // Second fetch:\n  const secondFetch = fakeXRef.fetch(dummyRef);\n  if (secondFetch === null) {\n    throw new Error(\"Bug persists: cached null entry returned on subsequent fetch.\");\n  }\n});",
    "i4_llama-3.3-70b-versatile": "it(\"should not cache null XRef entries so that a later valid entry is fetched\", async () => {\n  const { XRef } = await import(\"../../src/core/xref.js\");\n  const dummyStream = {};\n  const dummyPdfManager = {};\n  const dummyRef = { num: 1, toString: () => \"1 0 R\" };\n  let callCount = 0;\n  const fakeXRef = new XRef(dummyStream, dummyPdfManager);\n  fakeXRef.getEntry = function (num) {\n    callCount++;\n    return callCount === 1 ? null : { uncompressed: true };\n  };\n  // First fetch returns null and, in pre-patch, caches the null.\n  const firstFetch = fakeXRef.fetch(dummyRef);\n  // Second fetch:\n  const secondFetch = fakeXRef.fetch(dummyRef);\n  if (secondFetch === null) {\n    throw new Error(\"Bug persists: cached null entry returned on subsequent fetch.\");\n  }\n});",
    "i5_deepseek-r1-distill-llama-70b": "it(\"should not cache null XRef entries so that a later valid entry is fetched\", async () => {\n  const { XRef } = await import(\"../../src/core/xref.js\");\n  const dummyStream = {};\n  const dummyPdfManager = {};\n  const dummyRef = { num: 1, toString: () => \"1 0 R\" };\n  let callCount = 0;\n  const fakeXRef = new XRef(dummyStream, dummyPdfManager);\n  fakeXRef.getEntry = function (num) {\n    callCount++;\n    return callCount === 1 ? null : { uncompressed: true };\n  };\n  // First fetch returns null and, in pre-patch, caches the null.\n  const firstFetch = fakeXRef.fetch(dummyRef);\n  // Second fetch:\n  const secondFetch = fakeXRef.fetch(dummyRef);\n  if (secondFetch === null) {\n    throw new Error(\"Bug persists: cached null entry returned on subsequent fetch.\");\n  }\n});",
    "i5_gpt-4o": "it(\"should not cache null XRef entries so that a later valid entry is fetched\", async () => {\n  const { XRef } = await import(\"../../src/core/xref.js\");\n  const dummyStream = {};\n  const dummyPdfManager = {};\n  const dummyRef = { num: 1, toString: () => \"1 0 R\" };\n  let callCount = 0;\n  const fakeXRef = new XRef(dummyStream, dummyPdfManager);\n  fakeXRef.getEntry = function (num) {\n    callCount++;\n    return callCount === 1 ? null : { uncompressed: true };\n  };\n  // First fetch returns null and, in pre-patch, caches the null.\n  const firstFetch = fakeXRef.fetch(dummyRef);\n  // Second fetch:\n  const secondFetch = fakeXRef.fetch(dummyRef);\n  if (secondFetch === null) {\n    throw new Error(\"Bug persists: cached null entry returned on subsequent fetch.\");\n  }\n});",
    "i5_llama-3.3-70b-versatile": "it(\"should not cache null XRef entries so that a later valid entry is fetched\", async () => {\n  const { XRef } = await import(\"../../src/core/xref.js\");\n  const dummyStream = {};\n  const dummyPdfManager = {};\n  const dummyRef = { num: 1, toString: () => \"1 0 R\" };\n  let callCount = 0;\n  const fakeXRef = new XRef(dummyStream, dummyPdfManager);\n  fakeXRef.getEntry = function (num) {\n    callCount++;\n    return callCount === 1 ? null : { uncompressed: true };\n  };\n  // First fetch returns null and, in pre-patch, caches the null.\n  const firstFetch = fakeXRef.fetch(dummyRef);\n  // Second fetch:\n  const secondFetch = fakeXRef.fetch(dummyRef);\n  if (secondFetch === null) {\n    throw new Error(\"Bug persists: cached null entry returned on subsequent fetch.\");\n  }\n});"
  },
  "19533": {
    "i1_deepseek-r1-distill-llama-70b": "it(\"should apply textRise offset on text translation in Type3 fonts\", async () => {\n  const { CanvasGraphics } = await import(\"../../src/display/canvas.js\");\n  const { strict: assert } = await import(\"assert\");\n  const fakeCtx = {\n    translateCalls: [],\n    save() {},\n    restore() {},\n    transform(..._args) {},\n    translate(x, y) {\n      this.translateCalls.push([x, y]);\n    },\n    scale(..._args) {}\n  };\n  const commonObjs = {};\n  const objs = {};\n  const canvasFactory = {};\n  const filterFactory = {};\n  const optionalContentConfig = {};\n  const annotationCanvasMap = {};\n  const pageColors = {};\n  const canvasGraphics = new CanvasGraphics(\n    fakeCtx,\n    commonObjs,\n    objs,\n    canvasFactory,\n    filterFactory,\n    { optionalContentConfig },\n    annotationCanvasMap,\n    pageColors\n  );\n  canvasGraphics.current.textMatrix = [1, 0, 0, 1, 0, 0];\n  canvasGraphics.current.x = 10;\n  canvasGraphics.current.y = 20;\n  canvasGraphics.current.textRise = 5;\n  canvasGraphics.current.textHScale = 1;\n  canvasGraphics.current.fontDirection = 1;\n  canvasGraphics.current.fontSize = 10;\n  canvasGraphics.current.font = { charProcOperatorList: {} };\n  canvasGraphics.showType3Text([]);\n  assert.strictEqual(fakeCtx.translateCalls.length, 1);\n  const [tx, ty] = fakeCtx.translateCalls[0];\n  assert.strictEqual(tx, 10);\n  assert.strictEqual(ty, 25);\n});",
    "i1_gpt-4o": "it(\"should apply textRise offset on text translation in Type3 fonts\", async () => {\n  const { CanvasGraphics } = await import(\"../../src/display/canvas.js\");\n  const { strict: assert } = await import(\"assert\");\n  const fakeCtx = {\n    translateCalls: [],\n    save() {},\n    restore() {},\n    transform(..._args) {},\n    translate(x, y) {\n      this.translateCalls.push([x, y]);\n    },\n    scale(..._args) {}\n  };\n  const commonObjs = {};\n  const objs = {};\n  const canvasFactory = {};\n  const filterFactory = {};\n  const optionalContentConfig = {};\n  const annotationCanvasMap = {};\n  const pageColors = {};\n  const canvasGraphics = new CanvasGraphics(\n    fakeCtx,\n    commonObjs,\n    objs,\n    canvasFactory,\n    filterFactory,\n    { optionalContentConfig },\n    annotationCanvasMap,\n    pageColors\n  );\n  canvasGraphics.current.textMatrix = [1, 0, 0, 1, 0, 0];\n  canvasGraphics.current.x = 10;\n  canvasGraphics.current.y = 20;\n  canvasGraphics.current.textRise = 5;\n  canvasGraphics.current.textHScale = 1;\n  canvasGraphics.current.fontDirection = 1;\n  canvasGraphics.current.fontSize = 10;\n  canvasGraphics.current.font = { charProcOperatorList: {} };\n  canvasGraphics.showType3Text([]);\n  assert.strictEqual(fakeCtx.translateCalls.length, 1);\n  const [tx, ty] = fakeCtx.translateCalls[0];\n  assert.strictEqual(tx, 10);\n  assert.strictEqual(ty, 25);\n});",
    "i1_llama-3.3-70b-versatile": "it(\"should apply textRise offset on text translation in Type3 fonts\", async () => {\n  const { CanvasGraphics } = await import(\"../../src/display/canvas.js\");\n  const { strict: assert } = await import(\"assert\");\n  const fakeCtx = {\n    translateCalls: [],\n    save() {},\n    restore() {},\n    transform(..._args) {},\n    translate(x, y) {\n      this.translateCalls.push([x, y]);\n    },\n    scale(..._args) {}\n  };\n  const commonObjs = {};\n  const objs = {};\n  const canvasFactory = {};\n  const filterFactory = {};\n  const optionalContentConfig = {};\n  const annotationCanvasMap = {};\n  const pageColors = {};\n  const canvasGraphics = new CanvasGraphics(\n    fakeCtx,\n    commonObjs,\n    objs,\n    canvasFactory,\n    filterFactory,\n    { optionalContentConfig },\n    annotationCanvasMap,\n    pageColors\n  );\n  canvasGraphics.current.textMatrix = [1, 0, 0, 1, 0, 0];\n  canvasGraphics.current.x = 10;\n  canvasGraphics.current.y = 20;\n  canvasGraphics.current.textRise = 5;\n  canvasGraphics.current.textHScale = 1;\n  canvasGraphics.current.fontDirection = 1;\n  canvasGraphics.current.fontSize = 10;\n  canvasGraphics.current.font = { charProcOperatorList: {} };\n  canvasGraphics.showType3Text([]);\n  assert.strictEqual(fakeCtx.translateCalls.length, 1);\n  const [tx, ty] = fakeCtx.translateCalls[0];\n  assert.strictEqual(tx, 10);\n  assert.strictEqual(ty, 25);\n});",
    "i1_MOCK": "it(\"should apply textRise offset on text translation in Type3 fonts\", async () => {\n  const { CanvasGraphics } = await import(\"../../src/display/canvas.js\");\n  const { strict: assert } = await import(\"assert\");\n  const fakeCtx = {\n    translateCalls: [],\n    save() {},\n    restore() {},\n    transform(..._args) {},\n    translate(x, y) {\n      this.translateCalls.push([x, y]);\n    },\n    scale(..._args) {}\n  };\n  const commonObjs = {};\n  const objs = {};\n  const canvasFactory = {};\n  const filterFactory = {};\n  const optionalContentConfig = {};\n  const annotationCanvasMap = {};\n  const pageColors = {};\n  const canvasGraphics = new CanvasGraphics(\n    fakeCtx,\n    commonObjs,\n    objs,\n    canvasFactory,\n    filterFactory,\n    { optionalContentConfig },\n    annotationCanvasMap,\n    pageColors\n  );\n  canvasGraphics.current.textMatrix = [1, 0, 0, 1, 0, 0];\n  canvasGraphics.current.x = 10;\n  canvasGraphics.current.y = 20;\n  canvasGraphics.current.textRise = 5;\n  canvasGraphics.current.textHScale = 1;\n  canvasGraphics.current.fontDirection = 1;\n  canvasGraphics.current.fontSize = 10;\n  canvasGraphics.current.font = { charProcOperatorList: {} };\n  canvasGraphics.showType3Text([]);\n  assert.strictEqual(fakeCtx.translateCalls.length, 1);\n  const [tx, ty] = fakeCtx.translateCalls[0];\n  assert.strictEqual(tx, 10);\n  assert.strictEqual(ty, 25);\n});",
    "i2_deepseek-r1-distill-llama-70b": "it(\"should apply textRise offset on text translation in Type3 fonts\", async () => {\n  const { CanvasGraphics } = await import(\"../../src/display/canvas.js\");\n  const { strict: assert } = await import(\"assert\");\n  const fakeCtx = {\n    translateCalls: [],\n    save() {},\n    restore() {},\n    transform(..._args) {},\n    translate(x, y) {\n      this.translateCalls.push([x, y]);\n    },\n    scale(..._args) {}\n  };\n  const commonObjs = {};\n  const objs = {};\n  const canvasFactory = {};\n  const filterFactory = {};\n  const optionalContentConfig = {};\n  const annotationCanvasMap = {};\n  const pageColors = {};\n  const canvasGraphics = new CanvasGraphics(\n    fakeCtx,\n    commonObjs,\n    objs,\n    canvasFactory,\n    filterFactory,\n    { optionalContentConfig },\n    annotationCanvasMap,\n    pageColors\n  );\n  canvasGraphics.current.textMatrix = [1, 0, 0, 1, 0, 0];\n  canvasGraphics.current.x = 10;\n  canvasGraphics.current.y = 20;\n  canvasGraphics.current.textRise = 5;\n  canvasGraphics.current.textHScale = 1;\n  canvasGraphics.current.fontDirection = 1;\n  canvasGraphics.current.fontSize = 10;\n  canvasGraphics.current.font = { charProcOperatorList: {} };\n  canvasGraphics.showType3Text([]);\n  assert.strictEqual(fakeCtx.translateCalls.length, 1);\n  const [tx, ty] = fakeCtx.translateCalls[0];\n  assert.strictEqual(tx, 10);\n  assert.strictEqual(ty, 25);\n});",
    "i2_gpt-4o": "it(\"should apply textRise offset on text translation in Type3 fonts\", async () => {\n  const { CanvasGraphics } = await import(\"../../src/display/canvas.js\");\n  const { strict: assert } = await import(\"assert\");\n  const fakeCtx = {\n    translateCalls: [],\n    save() {},\n    restore() {},\n    transform(..._args) {},\n    translate(x, y) {\n      this.translateCalls.push([x, y]);\n    },\n    scale(..._args) {}\n  };\n  const commonObjs = {};\n  const objs = {};\n  const canvasFactory = {};\n  const filterFactory = {};\n  const optionalContentConfig = {};\n  const annotationCanvasMap = {};\n  const pageColors = {};\n  const canvasGraphics = new CanvasGraphics(\n    fakeCtx,\n    commonObjs,\n    objs,\n    canvasFactory,\n    filterFactory,\n    { optionalContentConfig },\n    annotationCanvasMap,\n    pageColors\n  );\n  canvasGraphics.current.textMatrix = [1, 0, 0, 1, 0, 0];\n  canvasGraphics.current.x = 10;\n  canvasGraphics.current.y = 20;\n  canvasGraphics.current.textRise = 5;\n  canvasGraphics.current.textHScale = 1;\n  canvasGraphics.current.fontDirection = 1;\n  canvasGraphics.current.fontSize = 10;\n  canvasGraphics.current.font = { charProcOperatorList: {} };\n  canvasGraphics.showType3Text([]);\n  assert.strictEqual(fakeCtx.translateCalls.length, 1);\n  const [tx, ty] = fakeCtx.translateCalls[0];\n  assert.strictEqual(tx, 10);\n  assert.strictEqual(ty, 25);\n});",
    "i2_llama-3.3-70b-versatile": "it(\"should apply textRise offset on text translation in Type3 fonts\", async () => {\n  const { CanvasGraphics } = await import(\"../../src/display/canvas.js\");\n  const { strict: assert } = await import(\"assert\");\n  const fakeCtx = {\n    translateCalls: [],\n    save() {},\n    restore() {},\n    transform(..._args) {},\n    translate(x, y) {\n      this.translateCalls.push([x, y]);\n    },\n    scale(..._args) {}\n  };\n  const commonObjs = {};\n  const objs = {};\n  const canvasFactory = {};\n  const filterFactory = {};\n  const optionalContentConfig = {};\n  const annotationCanvasMap = {};\n  const pageColors = {};\n  const canvasGraphics = new CanvasGraphics(\n    fakeCtx,\n    commonObjs,\n    objs,\n    canvasFactory,\n    filterFactory,\n    { optionalContentConfig },\n    annotationCanvasMap,\n    pageColors\n  );\n  canvasGraphics.current.textMatrix = [1, 0, 0, 1, 0, 0];\n  canvasGraphics.current.x = 10;\n  canvasGraphics.current.y = 20;\n  canvasGraphics.current.textRise = 5;\n  canvasGraphics.current.textHScale = 1;\n  canvasGraphics.current.fontDirection = 1;\n  canvasGraphics.current.fontSize = 10;\n  canvasGraphics.current.font = { charProcOperatorList: {} };\n  canvasGraphics.showType3Text([]);\n  assert.strictEqual(fakeCtx.translateCalls.length, 1);\n  const [tx, ty] = fakeCtx.translateCalls[0];\n  assert.strictEqual(tx, 10);\n  assert.strictEqual(ty, 25);\n});",
    "i3_deepseek-r1-distill-llama-70b": "it(\"should apply textRise offset on text translation in Type3 fonts\", async () => {\n  const { CanvasGraphics } = await import(\"../../src/display/canvas.js\");\n  const { strict: assert } = await import(\"assert\");\n  const fakeCtx = {\n    translateCalls: [],\n    save() {},\n    restore() {},\n    transform(..._args) {},\n    translate(x, y) {\n      this.translateCalls.push([x, y]);\n    },\n    scale(..._args) {}\n  };\n  const commonObjs = {};\n  const objs = {};\n  const canvasFactory = {};\n  const filterFactory = {};\n  const optionalContentConfig = {};\n  const annotationCanvasMap = {};\n  const pageColors = {};\n  const canvasGraphics = new CanvasGraphics(\n    fakeCtx,\n    commonObjs,\n    objs,\n    canvasFactory,\n    filterFactory,\n    { optionalContentConfig },\n    annotationCanvasMap,\n    pageColors\n  );\n  canvasGraphics.current.textMatrix = [1, 0, 0, 1, 0, 0];\n  canvasGraphics.current.x = 10;\n  canvasGraphics.current.y = 20;\n  canvasGraphics.current.textRise = 5;\n  canvasGraphics.current.textHScale = 1;\n  canvasGraphics.current.fontDirection = 1;\n  canvasGraphics.current.fontSize = 10;\n  canvasGraphics.current.font = { charProcOperatorList: {} };\n  canvasGraphics.showType3Text([]);\n  assert.strictEqual(fakeCtx.translateCalls.length, 1);\n  const [tx, ty] = fakeCtx.translateCalls[0];\n  assert.strictEqual(tx, 10);\n  assert.strictEqual(ty, 25);\n});",
    "i3_gpt-4o": "it(\"should apply textRise offset on text translation in Type3 fonts\", async () => {\n  const { CanvasGraphics } = await import(\"../../src/display/canvas.js\");\n  const { strict: assert } = await import(\"assert\");\n  const fakeCtx = {\n    translateCalls: [],\n    save() {},\n    restore() {},\n    transform(..._args) {},\n    translate(x, y) {\n      this.translateCalls.push([x, y]);\n    },\n    scale(..._args) {}\n  };\n  const commonObjs = {};\n  const objs = {};\n  const canvasFactory = {};\n  const filterFactory = {};\n  const optionalContentConfig = {};\n  const annotationCanvasMap = {};\n  const pageColors = {};\n  const canvasGraphics = new CanvasGraphics(\n    fakeCtx,\n    commonObjs,\n    objs,\n    canvasFactory,\n    filterFactory,\n    { optionalContentConfig },\n    annotationCanvasMap,\n    pageColors\n  );\n  canvasGraphics.current.textMatrix = [1, 0, 0, 1, 0, 0];\n  canvasGraphics.current.x = 10;\n  canvasGraphics.current.y = 20;\n  canvasGraphics.current.textRise = 5;\n  canvasGraphics.current.textHScale = 1;\n  canvasGraphics.current.fontDirection = 1;\n  canvasGraphics.current.fontSize = 10;\n  canvasGraphics.current.font = { charProcOperatorList: {} };\n  canvasGraphics.showType3Text([]);\n  assert.strictEqual(fakeCtx.translateCalls.length, 1);\n  const [tx, ty] = fakeCtx.translateCalls[0];\n  assert.strictEqual(tx, 10);\n  assert.strictEqual(ty, 25);\n});",
    "i3_llama-3.3-70b-versatile": "it(\"should apply textRise offset on text translation in Type3 fonts\", async () => {\n  const { CanvasGraphics } = await import(\"../../src/display/canvas.js\");\n  const { strict: assert } = await import(\"assert\");\n  const fakeCtx = {\n    translateCalls: [],\n    save() {},\n    restore() {},\n    transform(..._args) {},\n    translate(x, y) {\n      this.translateCalls.push([x, y]);\n    },\n    scale(..._args) {}\n  };\n  const commonObjs = {};\n  const objs = {};\n  const canvasFactory = {};\n  const filterFactory = {};\n  const optionalContentConfig = {};\n  const annotationCanvasMap = {};\n  const pageColors = {};\n  const canvasGraphics = new CanvasGraphics(\n    fakeCtx,\n    commonObjs,\n    objs,\n    canvasFactory,\n    filterFactory,\n    { optionalContentConfig },\n    annotationCanvasMap,\n    pageColors\n  );\n  canvasGraphics.current.textMatrix = [1, 0, 0, 1, 0, 0];\n  canvasGraphics.current.x = 10;\n  canvasGraphics.current.y = 20;\n  canvasGraphics.current.textRise = 5;\n  canvasGraphics.current.textHScale = 1;\n  canvasGraphics.current.fontDirection = 1;\n  canvasGraphics.current.fontSize = 10;\n  canvasGraphics.current.font = { charProcOperatorList: {} };\n  canvasGraphics.showType3Text([]);\n  assert.strictEqual(fakeCtx.translateCalls.length, 1);\n  const [tx, ty] = fakeCtx.translateCalls[0];\n  assert.strictEqual(tx, 10);\n  assert.strictEqual(ty, 25);\n});",
    "i4_deepseek-r1-distill-llama-70b": "it(\"should apply textRise offset on text translation in Type3 fonts\", async () => {\n  const { CanvasGraphics } = await import(\"../../src/display/canvas.js\");\n  const { strict: assert } = await import(\"assert\");\n  const fakeCtx = {\n    translateCalls: [],\n    save() {},\n    restore() {},\n    transform(..._args) {},\n    translate(x, y) {\n      this.translateCalls.push([x, y]);\n    },\n    scale(..._args) {}\n  };\n  const commonObjs = {};\n  const objs = {};\n  const canvasFactory = {};\n  const filterFactory = {};\n  const optionalContentConfig = {};\n  const annotationCanvasMap = {};\n  const pageColors = {};\n  const canvasGraphics = new CanvasGraphics(\n    fakeCtx,\n    commonObjs,\n    objs,\n    canvasFactory,\n    filterFactory,\n    { optionalContentConfig },\n    annotationCanvasMap,\n    pageColors\n  );\n  canvasGraphics.current.textMatrix = [1, 0, 0, 1, 0, 0];\n  canvasGraphics.current.x = 10;\n  canvasGraphics.current.y = 20;\n  canvasGraphics.current.textRise = 5;\n  canvasGraphics.current.textHScale = 1;\n  canvasGraphics.current.fontDirection = 1;\n  canvasGraphics.current.fontSize = 10;\n  canvasGraphics.current.font = { charProcOperatorList: {} };\n  canvasGraphics.showType3Text([]);\n  assert.strictEqual(fakeCtx.translateCalls.length, 1);\n  const [tx, ty] = fakeCtx.translateCalls[0];\n  assert.strictEqual(tx, 10);\n  assert.strictEqual(ty, 25);\n});",
    "i4_gpt-4o": "it(\"should apply textRise offset on text translation in Type3 fonts\", async () => {\n  const { CanvasGraphics } = await import(\"../../src/display/canvas.js\");\n  const { strict: assert } = await import(\"assert\");\n  const fakeCtx = {\n    translateCalls: [],\n    save() {},\n    restore() {},\n    transform(..._args) {},\n    translate(x, y) {\n      this.translateCalls.push([x, y]);\n    },\n    scale(..._args) {}\n  };\n  const commonObjs = {};\n  const objs = {};\n  const canvasFactory = {};\n  const filterFactory = {};\n  const optionalContentConfig = {};\n  const annotationCanvasMap = {};\n  const pageColors = {};\n  const canvasGraphics = new CanvasGraphics(\n    fakeCtx,\n    commonObjs,\n    objs,\n    canvasFactory,\n    filterFactory,\n    { optionalContentConfig },\n    annotationCanvasMap,\n    pageColors\n  );\n  canvasGraphics.current.textMatrix = [1, 0, 0, 1, 0, 0];\n  canvasGraphics.current.x = 10;\n  canvasGraphics.current.y = 20;\n  canvasGraphics.current.textRise = 5;\n  canvasGraphics.current.textHScale = 1;\n  canvasGraphics.current.fontDirection = 1;\n  canvasGraphics.current.fontSize = 10;\n  canvasGraphics.current.font = { charProcOperatorList: {} };\n  canvasGraphics.showType3Text([]);\n  assert.strictEqual(fakeCtx.translateCalls.length, 1);\n  const [tx, ty] = fakeCtx.translateCalls[0];\n  assert.strictEqual(tx, 10);\n  assert.strictEqual(ty, 25);\n});",
    "i4_llama-3.3-70b-versatile": "it(\"should apply textRise offset on text translation in Type3 fonts\", async () => {\n  const { CanvasGraphics } = await import(\"../../src/display/canvas.js\");\n  const { strict: assert } = await import(\"assert\");\n  const fakeCtx = {\n    translateCalls: [],\n    save() {},\n    restore() {},\n    transform(..._args) {},\n    translate(x, y) {\n      this.translateCalls.push([x, y]);\n    },\n    scale(..._args) {}\n  };\n  const commonObjs = {};\n  const objs = {};\n  const canvasFactory = {};\n  const filterFactory = {};\n  const optionalContentConfig = {};\n  const annotationCanvasMap = {};\n  const pageColors = {};\n  const canvasGraphics = new CanvasGraphics(\n    fakeCtx,\n    commonObjs,\n    objs,\n    canvasFactory,\n    filterFactory,\n    { optionalContentConfig },\n    annotationCanvasMap,\n    pageColors\n  );\n  canvasGraphics.current.textMatrix = [1, 0, 0, 1, 0, 0];\n  canvasGraphics.current.x = 10;\n  canvasGraphics.current.y = 20;\n  canvasGraphics.current.textRise = 5;\n  canvasGraphics.current.textHScale = 1;\n  canvasGraphics.current.fontDirection = 1;\n  canvasGraphics.current.fontSize = 10;\n  canvasGraphics.current.font = { charProcOperatorList: {} };\n  canvasGraphics.showType3Text([]);\n  assert.strictEqual(fakeCtx.translateCalls.length, 1);\n  const [tx, ty] = fakeCtx.translateCalls[0];\n  assert.strictEqual(tx, 10);\n  assert.strictEqual(ty, 25);\n});",
    "i5_deepseek-r1-distill-llama-70b": "it(\"should apply textRise offset on text translation in Type3 fonts\", async () => {\n  const { CanvasGraphics } = await import(\"../../src/display/canvas.js\");\n  const { strict: assert } = await import(\"assert\");\n  const fakeCtx = {\n    translateCalls: [],\n    save() {},\n    restore() {},\n    transform(..._args) {},\n    translate(x, y) {\n      this.translateCalls.push([x, y]);\n    },\n    scale(..._args) {}\n  };\n  const commonObjs = {};\n  const objs = {};\n  const canvasFactory = {};\n  const filterFactory = {};\n  const optionalContentConfig = {};\n  const annotationCanvasMap = {};\n  const pageColors = {};\n  const canvasGraphics = new CanvasGraphics(\n    fakeCtx,\n    commonObjs,\n    objs,\n    canvasFactory,\n    filterFactory,\n    { optionalContentConfig },\n    annotationCanvasMap,\n    pageColors\n  );\n  canvasGraphics.current.textMatrix = [1, 0, 0, 1, 0, 0];\n  canvasGraphics.current.x = 10;\n  canvasGraphics.current.y = 20;\n  canvasGraphics.current.textRise = 5;\n  canvasGraphics.current.textHScale = 1;\n  canvasGraphics.current.fontDirection = 1;\n  canvasGraphics.current.fontSize = 10;\n  canvasGraphics.current.font = { charProcOperatorList: {} };\n  canvasGraphics.showType3Text([]);\n  assert.strictEqual(fakeCtx.translateCalls.length, 1);\n  const [tx, ty] = fakeCtx.translateCalls[0];\n  assert.strictEqual(tx, 10);\n  assert.strictEqual(ty, 25);\n});",
    "i5_gpt-4o": "it(\"should apply textRise offset on text translation in Type3 fonts\", async () => {\n  const { CanvasGraphics } = await import(\"../../src/display/canvas.js\");\n  const { strict: assert } = await import(\"assert\");\n  const fakeCtx = {\n    translateCalls: [],\n    save() {},\n    restore() {},\n    transform(..._args) {},\n    translate(x, y) {\n      this.translateCalls.push([x, y]);\n    },\n    scale(..._args) {}\n  };\n  const commonObjs = {};\n  const objs = {};\n  const canvasFactory = {};\n  const filterFactory = {};\n  const optionalContentConfig = {};\n  const annotationCanvasMap = {};\n  const pageColors = {};\n  const canvasGraphics = new CanvasGraphics(\n    fakeCtx,\n    commonObjs,\n    objs,\n    canvasFactory,\n    filterFactory,\n    { optionalContentConfig },\n    annotationCanvasMap,\n    pageColors\n  );\n  canvasGraphics.current.textMatrix = [1, 0, 0, 1, 0, 0];\n  canvasGraphics.current.x = 10;\n  canvasGraphics.current.y = 20;\n  canvasGraphics.current.textRise = 5;\n  canvasGraphics.current.textHScale = 1;\n  canvasGraphics.current.fontDirection = 1;\n  canvasGraphics.current.fontSize = 10;\n  canvasGraphics.current.font = { charProcOperatorList: {} };\n  canvasGraphics.showType3Text([]);\n  assert.strictEqual(fakeCtx.translateCalls.length, 1);\n  const [tx, ty] = fakeCtx.translateCalls[0];\n  assert.strictEqual(tx, 10);\n  assert.strictEqual(ty, 25);\n});",
    "i5_llama-3.3-70b-versatile": "it(\"should apply textRise offset on text translation in Type3 fonts\", async () => {\n  const { CanvasGraphics } = await import(\"../../src/display/canvas.js\");\n  const { strict: assert } = await import(\"assert\");\n  const fakeCtx = {\n    translateCalls: [],\n    save() {},\n    restore() {},\n    transform(..._args) {},\n    translate(x, y) {\n      this.translateCalls.push([x, y]);\n    },\n    scale(..._args) {}\n  };\n  const commonObjs = {};\n  const objs = {};\n  const canvasFactory = {};\n  const filterFactory = {};\n  const optionalContentConfig = {};\n  const annotationCanvasMap = {};\n  const pageColors = {};\n  const canvasGraphics = new CanvasGraphics(\n    fakeCtx,\n    commonObjs,\n    objs,\n    canvasFactory,\n    filterFactory,\n    { optionalContentConfig },\n    annotationCanvasMap,\n    pageColors\n  );\n  canvasGraphics.current.textMatrix = [1, 0, 0, 1, 0, 0];\n  canvasGraphics.current.x = 10;\n  canvasGraphics.current.y = 20;\n  canvasGraphics.current.textRise = 5;\n  canvasGraphics.current.textHScale = 1;\n  canvasGraphics.current.fontDirection = 1;\n  canvasGraphics.current.fontSize = 10;\n  canvasGraphics.current.font = { charProcOperatorList: {} };\n  canvasGraphics.showType3Text([]);\n  assert.strictEqual(fakeCtx.translateCalls.length, 1);\n  const [tx, ty] = fakeCtx.translateCalls[0];\n  assert.strictEqual(tx, 10);\n  assert.strictEqual(ty, 25);\n});"
  },
  "19555": {
    "i1_deepseek-r1-distill-llama-70b": "it(\"should correctly extend short RC keys to bytes\", async () => {\n  const dict = new Dict({\n    Filter: new Name(\"Standard\"),\n    V: 4,\n    R: 4,\n    Length: 40,\n  });\n  const fileId = \"test.pdf\";\n  const password = \"\";\n\n  const factory = new CipherTransformFactory(dict, fileId, password);\n\n  expect(factory.encryptionKey.length).toBe(16);\n});",
    "i1_gpt-4o": "it(\"should extend RC encryption key to bytes when key length is less than bits\", async () => {\n  const { CipherTransformFactory } = await import(\"../../src/core/crypto.js\");\n  const { Dict, Name } = await import(\"../../src/core/primitives.js\");\n  const dict = new Dict();\n  dict.set(\"Filter\", Name.get(\"Standard\"));\n  dict.set(\"V\", 4);\n  dict.set(\"R\", 4);\n  dict.set(\"Length\", 40);\n  const fileId = \"testFileId\";\n  const password = null;\n\n  const factory = new CipherTransformFactory(dict, fileId, password);\n  const expectedKeyLength = 16;\n  const actualKeyLength = factory.encryptionKey.length;\n\n  expect(actualKeyLength).toBe(expectedKeyLength);\n});",
    "i1_llama-3.3-70b-versatile": "it(\"should support rare RC encryption where R key length bits\", async () => {\n  const { CipherTransformFactory, Dict, Name, stringToBytes } = await import(\"../../src/core/crypto.js\");\n  const { PasswordException, PasswordResponses } = await import(\"../../src/shared/util.js\");\n\n  const dict = new Dict();\n  dict.set(\"Filter\", Name.get(\"Standard\"));\n  dict.set(\"V\", 4);\n  dict.set(\"R\", 4);\n  dict.set(\"Length\", 40);\n  dict.set(\"O\", \"owner\");\n  dict.set(\"U\", \"user\");\n  dict.set(\"P\", 0);\n  dict.set(\"CF\", new Dict());\n\n  try {\n    const factory = new CipherTransformFactory(dict, \"\", \"\");\n    expect(factory.encryptionKey.length).toBe(16);\n  } catch (error) {\n    if (error instanceof PasswordException) {\n      throw new Error(\"Password exception was thrown\");\n    } else {\n      throw error;\n    }\n  }\n});",
    "i2_deepseek-r1-distill-llama-70b": "it(\"should correctly handle RC encryption with bit key\", async () => {\n  const { PDFDocument } = await import(\"../../src/display/pdf_document.js\");\n  const { PDFFetchStream } = await import(\"../../src/display/fetch_stream.js\");\n\n  const pdfData = await fetch(\"R.4.V.4.40-bit.RC4.pdf\").then(res => res.arrayBuffer());\n  const fetchStream = new PDFFetchStream({\n    data: pdfData,\n    mimeType: \"application/pdf\"\n  });\n\n  const pdf = await PDFDocument.load({\n    cMapLoader: null,\n    fetch: fetchStream,\n    isEvalSupported: false\n  });\n\n  const firstPage = await pdf.getPage(1);\n  const content = await firstPage.getTextContent();\n\n  expect(content.items.length).toBeGreaterThan(0);\n});",
    "i2_gpt-4o": "it(\"should decrypt PDFs with RC encryption where R and key length bits\", async () => {\n  const { CipherTransformFactory } = await import(\"../../src/core/crypto.js\");\n  const { Dict, Name } = await import(\"../../src/core/primitives.js\");\n\n  const dict = new Dict();\n  dict.set(\"Filter\", Name.get(\"Standard\"));\n  dict.set(\"V\", 4);\n  dict.set(\"R\", 4);\n  dict.set(\"Length\", 40);\n  dict.set(\"O\", \"ownerPassword\");\n  dict.set(\"U\", \"userPassword\");\n  dict.set(\"P\", -4);\n  dict.set(\"EncryptMetadata\", true);\n\n  const fileId = \"fileId\";\n  const password = \"\";\n\n  const factory = new CipherTransformFactory(dict, fileId, password);\n  const expectedKeyLength = 16;\n  const actualKeyLength = factory.encryptionKey.length;\n\n  expect(actualKeyLength).toBe(expectedKeyLength);\n});",
    "i2_llama-3.3-70b-versatile": "it(\"should decrypt PDFs with RC encryption where R and key length bits\", async () => {\n  const { PDFDocument } = await import(\"../../src/core/document.js\");\n  const { DefaultFileReaderFactory } = await import(\"./test_utils.js\");\n  const fileReaderFactory = new DefaultFileReaderFactory();\n  const pdfFile = await fileReaderFactory.readFile(\"R=4, V=4, 40-bit RC4.pdf\");\n  const pdfDoc = await PDFDocument.load({ data: pdfFile, cMapUrl: \"https://cdn.jsdelivr.net/npm/pdfjs-dist@2.16.105/build/generic/web/cmaps/\" });\n  const firstPage = await pdfDoc.getPage(1);\n  const textContent = await firstPage.getTextContent();\n  const expectedText = \"Lorem ipsum dolor sit amet, consectetur adipiscing elit.\";\n  expect(textContent.items[0].str).toContain(expectedText);\n});",
    "i3_deepseek-r1-distill-llama-70b": "it(\"should decrypt RC encrypted data with bit key\", async () => {\n  const key = new Uint8Array([0x00, 0x01, 0x02, 0x03, 0x04]); // 40-bit key (5 bytes)\n  const cipher = new ARCFourCipher(key);\n  const plaintext = stringToBytes(\"test\");\n  const ciphertext = cipher.encryptBlock(plaintext);\n  const decrypted = cipher.decryptBlock(ciphertext);\n  expect(bytesToString(decrypted)).toBe(\"test\");\n});",
    "i3_gpt-4o": "it(\"should support RC encryption with R and key length bits\", async () => {\n  const { CipherTransformFactory } = await import(\"../../src/core/crypto.js\");\n  const { stringToBytes } = await import(\"../../src/shared/util.js\");\n  const { Dict, Name } = await import(\"../../src/core/primitives.js\");\n\n  const dict = new Dict();\n  dict.set(\"Filter\", Name.get(\"Standard\"));\n  dict.set(\"V\", 4);\n  dict.set(\"R\", 4);\n  dict.set(\"Length\", 40);\n  dict.set(\"O\", stringToBytes(\"ownerpassword\"));\n  dict.set(\"U\", stringToBytes(\"userpassword\"));\n  dict.set(\"P\", -4);\n  dict.set(\"EncryptMetadata\", true);\n\n  const fileId = \"fileId\";\n  const password = \"\";\n\n  const factory = new CipherTransformFactory(dict, fileId, password);\n  const expectedKeyLength = 16;\n  const actualKeyLength = factory.encryptionKey.length;\n\n  expect(actualKeyLength).toBe(expectedKeyLength);\n});",
    "i3_llama-3.3-70b-versatile": "it(\"should support rare RC encryption where R key length bits\", async () => {\n  const { CipherTransformFactory, Name, Dict } = await import(\"../../src/core/crypto.js\");\n  const encryptionKey = new Uint8Array([1, 2, 3, 4, 5]);\n  const dict = new Dict({\n    Filter: Name.get(\"Standard\"),\n    V: 4,\n    Length: 40,\n    O: \"owner\",\n    U: \"user\",\n    P: 0,\n    R: 4,\n  });\n  const fileId = \"fileId\";\n  const password = \"\";\n  const cipherTransformFactory = new CipherTransformFactory(dict, fileId, password);\n  expect(cipherTransformFactory.encryptionKey.length).toBe(16);\n});",
    "i4_deepseek-r1-distill-llama-70b": "it(\"should handle RC encryption with bit key\", async () => {\n  const { PDFDocument } = await import(\"../../web/pdf_document.js\");\n  const { PDFParser } = await import(\"../../web/pdf_parser.js\");\n  const { stringToBytes } = await import(\"../../src/core/core_utils.js\");\n  const { ARCFourCipher } = await import(\"../../src/core/crypto.js\");\n\n  // Create a sample PDF with RC4 encryption (R=4, V=4) with 40-bit key\n  const pdfData = new Uint8Array([\n    0x25, 0x50, 0x44, 0x46, 0x2d, 0x31, 0x2e, 0x30, 0x0a, 0x61, 0x75, 0x74, 0x68, 0x6f, 0x72, 0x20,\n    0x28, 0x6e, 0x6f, 0x6e, 0x65, 0x29, 0x0a, 0x44, 0x65, 0x66, 0x61, 0x75, 0x6c, 0x74,\n    0x3a, 0x20, 0x30, 0x30, 0x30, 0x0a, 0x45, 0x6e, 0x63, 0x72, 0x79, 0x70, 0x74, 0x69,\n    0x6f, 0x6e, 0x3a, 0x20, 0x52, 0x43, 0x34, 0x28, 0x52, 0x3d, 0x34, 0x2c, 0x56, 0x3d,\n    0x34, 0x2c, 0x4c, 0x3d, 0x34, 0x30, 0x0a, 0x4c, 0x65, 0x6e, 0x67, 0x74, 0x68,\n    0x3a, 0x20, 0x34, 0x30, 0x0a, 0x55, 0x2f, 0x4f, 0x20, 0x28, 0x4f, 0x77, 0x6e,\n    0x65, 0x72, 0x29, 0x3a, 0x20, 0x30, 0x30, 0x30, 0x0a, 0x50, 0x61, 0x67, 0x65,\n    0x73, 0x3a, 0x20, 0x30, 0x0a, 0x53, 0x75, 0x70, 0x70, 0x6c, 0x65, 0x72, 0x3a,\n    0x20, 0x22, 0x48, 0x65, 0x6c, 0x6c, 0x6f, 0x20, 0x57, 0x6f, 0x72, 0x6c,\n    0x64, 0x22, 0x0a, 0x2f, 0x50, 0x44, 0x46, 0x2d, 0x31, 0x2e, 0x30\n  ]);\n\n  // Create an encrypted PDF\n  const encryptionKey = new Uint8Array([0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08]);\n  const cipher = new ARCFourCipher(encryptionKey);\n  const encryptedContent = cipher.encryptBlock(pdfData.slice(0, 0x100));\n\n  // Load the PDF\n  const pdf = await PDFDocument.create({\n    data: pdfData,\n    password: \"test\",\n    length: pdfData.length\n  });\n\n  // Verify the content can be read\n  const page = await pdf.getPage(1);\n  const textContent = await page.getTextContent();\n  expect(textContent.items[0].str).toBe(\"Hello World\");\n});",
    "i4_gpt-4o": "it(\"should support rare RC encryption where R key length bits\", async () => {\n  const { CipherTransformFactory } = await import(\"../../src/core/crypto.js\");\n  const { Dict, Name } = await import(\"../../src/core/primitives.js\");\n  const { stringToBytes } = await import(\"../../src/shared/util.js\");\n\n  const dict = new Dict();\n  dict.set(\"Filter\", Name.get(\"Standard\"));\n  dict.set(\"V\", 4);\n  dict.set(\"R\", 4);\n  dict.set(\"Length\", 40);\n  dict.set(\"O\", stringToBytes(\"ownerPassword\"));\n  dict.set(\"U\", stringToBytes(\"userPassword\"));\n  dict.set(\"P\", -4);\n  dict.set(\"EncryptMetadata\", true);\n\n  const fileId = \"fileId\";\n  const password = \"\";\n\n  const factory = new CipherTransformFactory(dict, fileId, password);\n  const expectedKeyLength = 16;\n  const actualKeyLength = factory.encryptionKey.length;\n\n  expect(actualKeyLength).toBe(expectedKeyLength);\n});",
    "i4_llama-3.3-70b-versatile": "it(\"should decrypt PDFs with RC encryption where R key length bits\", async () => {\n  const { CipherTransformFactory } = await import(\"../../src/core/crypto.js\");\n  const { PDFDocument } = await import(\"../../src/core/document.js\");\n  const { stringToBytes } = await import(\"../../src/shared/util.js\");\n\n  const pdfData = new Uint8Array([\n    // binary data of the PDF file\n  ]);\n\n  const pdfDoc = await PDFDocument.load(pdfData, { cMapUrl: \"path/to/cmap\", cMapPacked: true });\n  const encryptionKey = stringToBytes(\"password\");\n  const dict = pdfDoc.getMetadata().get(\"encryption\");\n  const cipherTransformFactory = new CipherTransformFactory(dict, pdfData, encryptionKey);\n\n  const expected = true;\n  const actual = cipherTransformFactory.encryptionKey.length === 16;\n\n  expect(actual).toBe(expected);\n});",
    "i5_deepseek-r1-distill-llama-70b": "it(\"should correctly handle RC encryption with bit key\", async () => {\n  const { PDFDocument, PDFDocumentLoadingTask } = await import(\"../../src/display/api.js\");\n  const { ARCFourCipher } = await import(\"../../src/core/crypto.js\");\n  const { TestPdfsServer } = await import(\"./test_utils.js\");\n\n  // Create a test PDF with RC4 encryption (R=4, V=4) using a 40-bit key\n  const server = new TestPdfsServer();\n  const pdfData = await server.generateRC4EncryptedPDF(40);\n\n  try {\n    const loadingTask = new PDFDocumentLoadingTask(pdfData);\n    const pdf = await PDFDocument.load(loadingTask);\n\n    // If we reach here, the PDF was successfully decrypted and loaded\n    expect(pdf.numPages).toBeGreaterThan(0);\n  } catch (error) {\n    // If the decryption fails, the PDF couldn't be loaded\n    expect(error).not.toBeDefined();\n  }\n});",
    "i5_gpt-4o": "it(\"should correctly handle RC encryption with key length bits\", async () => {\n  const { getDocument } = await import(\"../../src/display/api.js\");\n  const { buildGetDocumentParams } = await import(\"./test_utils.js\");\n\n  const url = \"https://github.com/user-attachments/files/18788789/R.4.V.4.40-bit.RC4.pdf\";\n  const loadingTask = getDocument(buildGetDocumentParams(url));\n  const pdfDocument = await loadingTask.promise;\n\n  const page = await pdfDocument.getPage(1);\n  const textContent = await page.getTextContent();\n  const actualText = textContent.items.map(item => item.str).join(\" \");\n\n  const expectedText = \"Expected text from the PDF\";\n  expect(actualText).toContain(expectedText);\n});",
    "i5_llama-3.3-70b-versatile": "it(\"should decrypt PDFs with RC encryption and key length less than bits\", async () => {\n  const { PDFDocument } = await import(\"../../src/core/document.js\");\n  const pdfUrl = \"https://github.com/user-attachments/files/18788789/R.4.V.4.40-bit.RC4.pdf\";\n  const pdf = await PDFDocument.load(pdfUrl);\n  const firstPage = await pdf.getPage(1);\n  const textContent = await firstPage.getTextContent();\n  const expectedText = \"This is a test PDF with RC4 encryption and a 40-bit key.\";\n  expect(textContent.items[0].str).toContain(expectedText);\n});"
  },
  "19613": {
    "i1_deepseek-r1-distill-llama-70b": "it(\"should use fallback dimensions for images with invalid widthheight\", async () => {\n  const { PDFImage } = await import(\"../../src/core/image.js\");\n  const fakeDict = {\n    get(key, alt) {\n      if (key === \"W\" || alt === \"Width\") {\n        return 0;\n      }\n      if (key === \"H\" || alt === \"Height\") {\n        return 0;\n      }\n      return undefined;\n    },\n  };\n  const fakeImage = { dict: fakeDict, fallbackDims: { width: 150, height: 250 } };\n  const fakeXref = { fetchIfRef: (obj) => obj };\n  const pdfImage = new PDFImage({\n    xref: fakeXref,\n    res: {},\n    image: fakeImage,\n    pdfFunctionFactory: {},\n    globalColorSpaceCache: {},\n    localColorSpaceCache: {},\n  });\n  if (pdfImage.width !== 150 || pdfImage.height !== 250) {\n    throw new Error(`Expected fallback dimensions (150x250), but got (${pdfImage.width}x${pdfImage.height}).`);\n  }\n});\n",
    "i1_gpt-4o": "it(\"should use fallback dimensions for images with invalid widthheight\", async () => {\n  const { PDFImage } = await import(\"../../src/core/image.js\");\n  const fakeDict = {\n    get(key, alt) {\n      if (key === \"W\" || alt === \"Width\") {\n        return 0;\n      }\n      if (key === \"H\" || alt === \"Height\") {\n        return 0;\n      }\n      return undefined;\n    },\n  };\n  const fakeImage = { dict: fakeDict, fallbackDims: { width: 150, height: 250 } };\n  const fakeXref = { fetchIfRef: (obj) => obj };\n  const pdfImage = new PDFImage({\n    xref: fakeXref,\n    res: {},\n    image: fakeImage,\n    pdfFunctionFactory: {},\n    globalColorSpaceCache: {},\n    localColorSpaceCache: {},\n  });\n  if (pdfImage.width !== 150 || pdfImage.height !== 250) {\n    throw new Error(`Expected fallback dimensions (150x250), but got (${pdfImage.width}x${pdfImage.height}).`);\n  }\n});\n",
    "i1_llama-3.3-70b-versatile": "it(\"should use fallback dimensions for images with invalid widthheight\", async () => {\n  const { PDFImage } = await import(\"../../src/core/image.js\");\n  const fakeDict = {\n    get(key, alt) {\n      if (key === \"W\" || alt === \"Width\") {\n        return 0;\n      }\n      if (key === \"H\" || alt === \"Height\") {\n        return 0;\n      }\n      return undefined;\n    },\n  };\n  const fakeImage = { dict: fakeDict, fallbackDims: { width: 150, height: 250 } };\n  const fakeXref = { fetchIfRef: (obj) => obj };\n  const pdfImage = new PDFImage({\n    xref: fakeXref,\n    res: {},\n    image: fakeImage,\n    pdfFunctionFactory: {},\n    globalColorSpaceCache: {},\n    localColorSpaceCache: {},\n  });\n  if (pdfImage.width !== 150 || pdfImage.height !== 250) {\n    throw new Error(`Expected fallback dimensions (150x250), but got (${pdfImage.width}x${pdfImage.height}).`);\n  }\n});\n",
    "i1_MOCK": "it(\"should use fallback dimensions for images with invalid widthheight\", async () => {\n  const { PDFImage } = await import(\"../../src/core/image.js\");\n  const fakeDict = {\n    get(key, alt) {\n      if (key === \"W\" || alt === \"Width\") {\n        return 0;\n      }\n      if (key === \"H\" || alt === \"Height\") {\n        return 0;\n      }\n      return undefined;\n    },\n  };\n  const fakeImage = { dict: fakeDict, fallbackDims: { width: 150, height: 250 } };\n  const fakeXref = { fetchIfRef: (obj) => obj };\n  const pdfImage = new PDFImage({\n    xref: fakeXref,\n    res: {},\n    image: fakeImage,\n    pdfFunctionFactory: {},\n    globalColorSpaceCache: {},\n    localColorSpaceCache: {},\n  });\n  if (pdfImage.width !== 150 || pdfImage.height !== 250) {\n    throw new Error(`Expected fallback dimensions (150x250), but got (${pdfImage.width}x${pdfImage.height}).`);\n  }\n});\n",
    "i2_deepseek-r1-distill-llama-70b": "it(\"should use fallback dimensions for images with invalid widthheight\", async () => {\n  const { PDFImage } = await import(\"../../src/core/image.js\");\n  const fakeDict = {\n    get(key, alt) {\n      if (key === \"W\" || alt === \"Width\") {\n        return 0;\n      }\n      if (key === \"H\" || alt === \"Height\") {\n        return 0;\n      }\n      return undefined;\n    },\n  };\n  const fakeImage = { dict: fakeDict, fallbackDims: { width: 150, height: 250 } };\n  const fakeXref = { fetchIfRef: (obj) => obj };\n  const pdfImage = new PDFImage({\n    xref: fakeXref,\n    res: {},\n    image: fakeImage,\n    pdfFunctionFactory: {},\n    globalColorSpaceCache: {},\n    localColorSpaceCache: {},\n  });\n  if (pdfImage.width !== 150 || pdfImage.height !== 250) {\n    throw new Error(`Expected fallback dimensions (150x250), but got (${pdfImage.width}x${pdfImage.height}).`);\n  }\n});\n",
    "i2_gpt-4o": "it(\"should use fallback dimensions for images with invalid widthheight\", async () => {\n  const { PDFImage } = await import(\"../../src/core/image.js\");\n  const fakeDict = {\n    get(key, alt) {\n      if (key === \"W\" || alt === \"Width\") {\n        return 0;\n      }\n      if (key === \"H\" || alt === \"Height\") {\n        return 0;\n      }\n      return undefined;\n    },\n  };\n  const fakeImage = { dict: fakeDict, fallbackDims: { width: 150, height: 250 } };\n  const fakeXref = { fetchIfRef: (obj) => obj };\n  const pdfImage = new PDFImage({\n    xref: fakeXref,\n    res: {},\n    image: fakeImage,\n    pdfFunctionFactory: {},\n    globalColorSpaceCache: {},\n    localColorSpaceCache: {},\n  });\n  if (pdfImage.width !== 150 || pdfImage.height !== 250) {\n    throw new Error(`Expected fallback dimensions (150x250), but got (${pdfImage.width}x${pdfImage.height}).`);\n  }\n});\n",
    "i2_llama-3.3-70b-versatile": "it(\"should use fallback dimensions for images with invalid widthheight\", async () => {\n  const { PDFImage } = await import(\"../../src/core/image.js\");\n  const fakeDict = {\n    get(key, alt) {\n      if (key === \"W\" || alt === \"Width\") {\n        return 0;\n      }\n      if (key === \"H\" || alt === \"Height\") {\n        return 0;\n      }\n      return undefined;\n    },\n  };\n  const fakeImage = { dict: fakeDict, fallbackDims: { width: 150, height: 250 } };\n  const fakeXref = { fetchIfRef: (obj) => obj };\n  const pdfImage = new PDFImage({\n    xref: fakeXref,\n    res: {},\n    image: fakeImage,\n    pdfFunctionFactory: {},\n    globalColorSpaceCache: {},\n    localColorSpaceCache: {},\n  });\n  if (pdfImage.width !== 150 || pdfImage.height !== 250) {\n    throw new Error(`Expected fallback dimensions (150x250), but got (${pdfImage.width}x${pdfImage.height}).`);\n  }\n});\n",
    "i3_deepseek-r1-distill-llama-70b": "it(\"should use fallback dimensions for images with invalid widthheight\", async () => {\n  const { PDFImage } = await import(\"../../src/core/image.js\");\n  const fakeDict = {\n    get(key, alt) {\n      if (key === \"W\" || alt === \"Width\") {\n        return 0;\n      }\n      if (key === \"H\" || alt === \"Height\") {\n        return 0;\n      }\n      return undefined;\n    },\n  };\n  const fakeImage = { dict: fakeDict, fallbackDims: { width: 150, height: 250 } };\n  const fakeXref = { fetchIfRef: (obj) => obj };\n  const pdfImage = new PDFImage({\n    xref: fakeXref,\n    res: {},\n    image: fakeImage,\n    pdfFunctionFactory: {},\n    globalColorSpaceCache: {},\n    localColorSpaceCache: {},\n  });\n  if (pdfImage.width !== 150 || pdfImage.height !== 250) {\n    throw new Error(`Expected fallback dimensions (150x250), but got (${pdfImage.width}x${pdfImage.height}).`);\n  }\n});\n",
    "i3_gpt-4o": "it(\"should use fallback dimensions for images with invalid widthheight\", async () => {\n  const { PDFImage } = await import(\"../../src/core/image.js\");\n  const fakeDict = {\n    get(key, alt) {\n      if (key === \"W\" || alt === \"Width\") {\n        return 0;\n      }\n      if (key === \"H\" || alt === \"Height\") {\n        return 0;\n      }\n      return undefined;\n    },\n  };\n  const fakeImage = { dict: fakeDict, fallbackDims: { width: 150, height: 250 } };\n  const fakeXref = { fetchIfRef: (obj) => obj };\n  const pdfImage = new PDFImage({\n    xref: fakeXref,\n    res: {},\n    image: fakeImage,\n    pdfFunctionFactory: {},\n    globalColorSpaceCache: {},\n    localColorSpaceCache: {},\n  });\n  if (pdfImage.width !== 150 || pdfImage.height !== 250) {\n    throw new Error(`Expected fallback dimensions (150x250), but got (${pdfImage.width}x${pdfImage.height}).`);\n  }\n});\n",
    "i3_llama-3.3-70b-versatile": "it(\"should use fallback dimensions for images with invalid widthheight\", async () => {\n  const { PDFImage } = await import(\"../../src/core/image.js\");\n  const fakeDict = {\n    get(key, alt) {\n      if (key === \"W\" || alt === \"Width\") {\n        return 0;\n      }\n      if (key === \"H\" || alt === \"Height\") {\n        return 0;\n      }\n      return undefined;\n    },\n  };\n  const fakeImage = { dict: fakeDict, fallbackDims: { width: 150, height: 250 } };\n  const fakeXref = { fetchIfRef: (obj) => obj };\n  const pdfImage = new PDFImage({\n    xref: fakeXref,\n    res: {},\n    image: fakeImage,\n    pdfFunctionFactory: {},\n    globalColorSpaceCache: {},\n    localColorSpaceCache: {},\n  });\n  if (pdfImage.width !== 150 || pdfImage.height !== 250) {\n    throw new Error(`Expected fallback dimensions (150x250), but got (${pdfImage.width}x${pdfImage.height}).`);\n  }\n});\n",
    "i4_deepseek-r1-distill-llama-70b": "it(\"should use fallback dimensions for images with invalid widthheight\", async () => {\n  const { PDFImage } = await import(\"../../src/core/image.js\");\n  const fakeDict = {\n    get(key, alt) {\n      if (key === \"W\" || alt === \"Width\") {\n        return 0;\n      }\n      if (key === \"H\" || alt === \"Height\") {\n        return 0;\n      }\n      return undefined;\n    },\n  };\n  const fakeImage = { dict: fakeDict, fallbackDims: { width: 150, height: 250 } };\n  const fakeXref = { fetchIfRef: (obj) => obj };\n  const pdfImage = new PDFImage({\n    xref: fakeXref,\n    res: {},\n    image: fakeImage,\n    pdfFunctionFactory: {},\n    globalColorSpaceCache: {},\n    localColorSpaceCache: {},\n  });\n  if (pdfImage.width !== 150 || pdfImage.height !== 250) {\n    throw new Error(`Expected fallback dimensions (150x250), but got (${pdfImage.width}x${pdfImage.height}).`);\n  }\n});\n",
    "i4_gpt-4o": "it(\"should use fallback dimensions for images with invalid widthheight\", async () => {\n  const { PDFImage } = await import(\"../../src/core/image.js\");\n  const fakeDict = {\n    get(key, alt) {\n      if (key === \"W\" || alt === \"Width\") {\n        return 0;\n      }\n      if (key === \"H\" || alt === \"Height\") {\n        return 0;\n      }\n      return undefined;\n    },\n  };\n  const fakeImage = { dict: fakeDict, fallbackDims: { width: 150, height: 250 } };\n  const fakeXref = { fetchIfRef: (obj) => obj };\n  const pdfImage = new PDFImage({\n    xref: fakeXref,\n    res: {},\n    image: fakeImage,\n    pdfFunctionFactory: {},\n    globalColorSpaceCache: {},\n    localColorSpaceCache: {},\n  });\n  if (pdfImage.width !== 150 || pdfImage.height !== 250) {\n    throw new Error(`Expected fallback dimensions (150x250), but got (${pdfImage.width}x${pdfImage.height}).`);\n  }\n});\n",
    "i4_llama-3.3-70b-versatile": "it(\"should use fallback dimensions for images with invalid widthheight\", async () => {\n  const { PDFImage } = await import(\"../../src/core/image.js\");\n  const fakeDict = {\n    get(key, alt) {\n      if (key === \"W\" || alt === \"Width\") {\n        return 0;\n      }\n      if (key === \"H\" || alt === \"Height\") {\n        return 0;\n      }\n      return undefined;\n    },\n  };\n  const fakeImage = { dict: fakeDict, fallbackDims: { width: 150, height: 250 } };\n  const fakeXref = { fetchIfRef: (obj) => obj };\n  const pdfImage = new PDFImage({\n    xref: fakeXref,\n    res: {},\n    image: fakeImage,\n    pdfFunctionFactory: {},\n    globalColorSpaceCache: {},\n    localColorSpaceCache: {},\n  });\n  if (pdfImage.width !== 150 || pdfImage.height !== 250) {\n    throw new Error(`Expected fallback dimensions (150x250), but got (${pdfImage.width}x${pdfImage.height}).`);\n  }\n});\n",
    "i5_deepseek-r1-distill-llama-70b": "it(\"should use fallback dimensions for images with invalid widthheight\", async () => {\n  const { PDFImage } = await import(\"../../src/core/image.js\");\n  const fakeDict = {\n    get(key, alt) {\n      if (key === \"W\" || alt === \"Width\") {\n        return 0;\n      }\n      if (key === \"H\" || alt === \"Height\") {\n        return 0;\n      }\n      return undefined;\n    },\n  };\n  const fakeImage = { dict: fakeDict, fallbackDims: { width: 150, height: 250 } };\n  const fakeXref = { fetchIfRef: (obj) => obj };\n  const pdfImage = new PDFImage({\n    xref: fakeXref,\n    res: {},\n    image: fakeImage,\n    pdfFunctionFactory: {},\n    globalColorSpaceCache: {},\n    localColorSpaceCache: {},\n  });\n  if (pdfImage.width !== 150 || pdfImage.height !== 250) {\n    throw new Error(`Expected fallback dimensions (150x250), but got (${pdfImage.width}x${pdfImage.height}).`);\n  }\n});\n",
    "i5_gpt-4o": "it(\"should use fallback dimensions for images with invalid widthheight\", async () => {\n  const { PDFImage } = await import(\"../../src/core/image.js\");\n  const fakeDict = {\n    get(key, alt) {\n      if (key === \"W\" || alt === \"Width\") {\n        return 0;\n      }\n      if (key === \"H\" || alt === \"Height\") {\n        return 0;\n      }\n      return undefined;\n    },\n  };\n  const fakeImage = { dict: fakeDict, fallbackDims: { width: 150, height: 250 } };\n  const fakeXref = { fetchIfRef: (obj) => obj };\n  const pdfImage = new PDFImage({\n    xref: fakeXref,\n    res: {},\n    image: fakeImage,\n    pdfFunctionFactory: {},\n    globalColorSpaceCache: {},\n    localColorSpaceCache: {},\n  });\n  if (pdfImage.width !== 150 || pdfImage.height !== 250) {\n    throw new Error(`Expected fallback dimensions (150x250), but got (${pdfImage.width}x${pdfImage.height}).`);\n  }\n});\n",
    "i5_llama-3.3-70b-versatile": "it(\"should use fallback dimensions for images with invalid widthheight\", async () => {\n  const { PDFImage } = await import(\"../../src/core/image.js\");\n  const fakeDict = {\n    get(key, alt) {\n      if (key === \"W\" || alt === \"Width\") {\n        return 0;\n      }\n      if (key === \"H\" || alt === \"Height\") {\n        return 0;\n      }\n      return undefined;\n    },\n  };\n  const fakeImage = { dict: fakeDict, fallbackDims: { width: 150, height: 250 } };\n  const fakeXref = { fetchIfRef: (obj) => obj };\n  const pdfImage = new PDFImage({\n    xref: fakeXref,\n    res: {},\n    image: fakeImage,\n    pdfFunctionFactory: {},\n    globalColorSpaceCache: {},\n    localColorSpaceCache: {},\n  });\n  if (pdfImage.width !== 150 || pdfImage.height !== 250) {\n    throw new Error(`Expected fallback dimensions (150x250), but got (${pdfImage.width}x${pdfImage.height}).`);\n  }\n});\n"
  },
  "19625": {
    "i1_deepseek-r1-distill-llama-70b": "it(\"should compute bbox for a Type3 glyph with setCharWidth operator\", async () => {\n  const { OPS } = await import(\"../../src/shared/util.js\");\n  const { Dict } = await import(\"../../src/core/primitives.js\");\n  const { StringStream } = await import(\"../../src/core/stream.js\");\n  const { OperatorList } = await import(\"../../src/core/operator_list.js\");\n  const { PartialEvaluator, TranslatedFont } = await import(\"../../src/core/evaluator.js\");\n  const { WorkerTask } = await import(\"../../src/core/worker.js\");\n\n  // Create a fake CharProcs dictionary.\n  const charProcs = new Dict();\n  charProcs.getKeys = () => [\"A\"];\n  const fakeStream = new StringStream(\"\");\n  charProcs.get = () => fakeStream;\n\n  // Create a fake Type3 font dictionary.\n  const fontDict = new Dict();\n  fontDict.set(\"CharProcs\", charProcs);\n  fontDict.set(\"Resources\", new Dict());\n\n  // Create a fake Type3 font object with an empty bbox.\n  const font = { isType3Font: true, bbox: [0, 0, 0, 0] };\n  const loadedName = \"TestType3Font\";\n\n  // Instantiate a PartialEvaluator.\n  const evaluator = new PartialEvaluator({});\n  // Override getOperatorList to simulate processing a glyph stream.\n  evaluator.getOperatorList = function({ stream, operatorList }) {\n    operatorList.fnArray.push(OPS.setCharWidth);\n    operatorList.argsArray.push([]); // d0 operator has no bbox info.\n    operatorList.fnArray.push(OPS.constructPath);\n    // The third argument contains the bbox we want to compute.\n    operatorList.argsArray.push([null, null, [10, 20, 30, 40]]);\n    operatorList.length = operatorList.fnArray.length;\n    return Promise.resolve();\n  };\n\n  const task = new WorkerTask(\"test\", \"\");\n  const translatedFont = new TranslatedFont({ loadedName, font, dict: fontDict });\n  await translatedFont.loadType3Data(evaluator, fontDict, task);\n  if (!font.isCharBBox) {\n    throw new Error(\"Expected font.isCharBBox to be true\");\n  }\n  const expected = [10, 20, 30, 40];\n  if (\n    font.bbox[0] !== expected[0] ||\n    font.bbox[1] !== expected[1] ||\n    font.bbox[2] !== expected[2] ||\n    font.bbox[3] !== expected[3]\n  ) {\n    throw new Error(\"Font bbox does not match expected value\");\n  }\n});",
    "i1_gpt-4o": "it(\"should compute bbox for a Type3 glyph with setCharWidth operator\", async () => {\n  const { OPS } = await import(\"../../src/shared/util.js\");\n  const { Dict } = await import(\"../../src/core/primitives.js\");\n  const { StringStream } = await import(\"../../src/core/stream.js\");\n  const { OperatorList } = await import(\"../../src/core/operator_list.js\");\n  const { PartialEvaluator, TranslatedFont } = await import(\"../../src/core/evaluator.js\");\n  const { WorkerTask } = await import(\"../../src/core/worker.js\");\n\n  // Create a fake CharProcs dictionary.\n  const charProcs = new Dict();\n  charProcs.getKeys = () => [\"A\"];\n  const fakeStream = new StringStream(\"\");\n  charProcs.get = () => fakeStream;\n\n  // Create a fake Type3 font dictionary.\n  const fontDict = new Dict();\n  fontDict.set(\"CharProcs\", charProcs);\n  fontDict.set(\"Resources\", new Dict());\n\n  // Create a fake Type3 font object with an empty bbox.\n  const font = { isType3Font: true, bbox: [0, 0, 0, 0] };\n  const loadedName = \"TestType3Font\";\n\n  // Instantiate a PartialEvaluator.\n  const evaluator = new PartialEvaluator({});\n  // Override getOperatorList to simulate processing a glyph stream.\n  evaluator.getOperatorList = function({ stream, operatorList }) {\n    operatorList.fnArray.push(OPS.setCharWidth);\n    operatorList.argsArray.push([]); // d0 operator has no bbox info.\n    operatorList.fnArray.push(OPS.constructPath);\n    // The third argument contains the bbox we want to compute.\n    operatorList.argsArray.push([null, null, [10, 20, 30, 40]]);\n    operatorList.length = operatorList.fnArray.length;\n    return Promise.resolve();\n  };\n\n  const task = new WorkerTask(\"test\", \"\");\n  const translatedFont = new TranslatedFont({ loadedName, font, dict: fontDict });\n  await translatedFont.loadType3Data(evaluator, fontDict, task);\n  if (!font.isCharBBox) {\n    throw new Error(\"Expected font.isCharBBox to be true\");\n  }\n  const expected = [10, 20, 30, 40];\n  if (\n    font.bbox[0] !== expected[0] ||\n    font.bbox[1] !== expected[1] ||\n    font.bbox[2] !== expected[2] ||\n    font.bbox[3] !== expected[3]\n  ) {\n    throw new Error(\"Font bbox does not match expected value\");\n  }\n});",
    "i1_llama-3.3-70b-versatile": "it(\"should compute bbox for a Type3 glyph with setCharWidth operator\", async () => {\n  const { OPS } = await import(\"../../src/shared/util.js\");\n  const { Dict } = await import(\"../../src/core/primitives.js\");\n  const { StringStream } = await import(\"../../src/core/stream.js\");\n  const { OperatorList } = await import(\"../../src/core/operator_list.js\");\n  const { PartialEvaluator, TranslatedFont } = await import(\"../../src/core/evaluator.js\");\n  const { WorkerTask } = await import(\"../../src/core/worker.js\");\n\n  // Create a fake CharProcs dictionary.\n  const charProcs = new Dict();\n  charProcs.getKeys = () => [\"A\"];\n  const fakeStream = new StringStream(\"\");\n  charProcs.get = () => fakeStream;\n\n  // Create a fake Type3 font dictionary.\n  const fontDict = new Dict();\n  fontDict.set(\"CharProcs\", charProcs);\n  fontDict.set(\"Resources\", new Dict());\n\n  // Create a fake Type3 font object with an empty bbox.\n  const font = { isType3Font: true, bbox: [0, 0, 0, 0] };\n  const loadedName = \"TestType3Font\";\n\n  // Instantiate a PartialEvaluator.\n  const evaluator = new PartialEvaluator({});\n  // Override getOperatorList to simulate processing a glyph stream.\n  evaluator.getOperatorList = function({ stream, operatorList }) {\n    operatorList.fnArray.push(OPS.setCharWidth);\n    operatorList.argsArray.push([]); // d0 operator has no bbox info.\n    operatorList.fnArray.push(OPS.constructPath);\n    // The third argument contains the bbox we want to compute.\n    operatorList.argsArray.push([null, null, [10, 20, 30, 40]]);\n    operatorList.length = operatorList.fnArray.length;\n    return Promise.resolve();\n  };\n\n  const task = new WorkerTask(\"test\", \"\");\n  const translatedFont = new TranslatedFont({ loadedName, font, dict: fontDict });\n  await translatedFont.loadType3Data(evaluator, fontDict, task);\n  if (!font.isCharBBox) {\n    throw new Error(\"Expected font.isCharBBox to be true\");\n  }\n  const expected = [10, 20, 30, 40];\n  if (\n    font.bbox[0] !== expected[0] ||\n    font.bbox[1] !== expected[1] ||\n    font.bbox[2] !== expected[2] ||\n    font.bbox[3] !== expected[3]\n  ) {\n    throw new Error(\"Font bbox does not match expected value\");\n  }\n});",
    "i1_MOCK": "it(\"should compute bbox for a Type3 glyph with setCharWidth operator\", async () => {\n  const { OPS } = await import(\"../../src/shared/util.js\");\n  const { Dict } = await import(\"../../src/core/primitives.js\");\n  const { StringStream } = await import(\"../../src/core/stream.js\");\n  const { OperatorList } = await import(\"../../src/core/operator_list.js\");\n  const { PartialEvaluator, TranslatedFont } = await import(\"../../src/core/evaluator.js\");\n  const { WorkerTask } = await import(\"../../src/core/worker.js\");\n\n  // Create a fake CharProcs dictionary.\n  const charProcs = new Dict();\n  charProcs.getKeys = () => [\"A\"];\n  const fakeStream = new StringStream(\"\");\n  charProcs.get = () => fakeStream;\n\n  // Create a fake Type3 font dictionary.\n  const fontDict = new Dict();\n  fontDict.set(\"CharProcs\", charProcs);\n  fontDict.set(\"Resources\", new Dict());\n\n  // Create a fake Type3 font object with an empty bbox.\n  const font = { isType3Font: true, bbox: [0, 0, 0, 0] };\n  const loadedName = \"TestType3Font\";\n\n  // Instantiate a PartialEvaluator.\n  const evaluator = new PartialEvaluator({});\n  // Override getOperatorList to simulate processing a glyph stream.\n  evaluator.getOperatorList = function({ stream, operatorList }) {\n    operatorList.fnArray.push(OPS.setCharWidth);\n    operatorList.argsArray.push([]); // d0 operator has no bbox info.\n    operatorList.fnArray.push(OPS.constructPath);\n    // The third argument contains the bbox we want to compute.\n    operatorList.argsArray.push([null, null, [10, 20, 30, 40]]);\n    operatorList.length = operatorList.fnArray.length;\n    return Promise.resolve();\n  };\n\n  const task = new WorkerTask(\"test\", \"\");\n  const translatedFont = new TranslatedFont({ loadedName, font, dict: fontDict });\n  await translatedFont.loadType3Data(evaluator, fontDict, task);\n  if (!font.isCharBBox) {\n    throw new Error(\"Expected font.isCharBBox to be true\");\n  }\n  const expected = [10, 20, 30, 40];\n  if (\n    font.bbox[0] !== expected[0] ||\n    font.bbox[1] !== expected[1] ||\n    font.bbox[2] !== expected[2] ||\n    font.bbox[3] !== expected[3]\n  ) {\n    throw new Error(\"Font bbox does not match expected value\");\n  }\n});",
    "i2_deepseek-r1-distill-llama-70b": "it(\"should compute bbox for a Type3 glyph with setCharWidth operator\", async () => {\n  const { OPS } = await import(\"../../src/shared/util.js\");\n  const { Dict } = await import(\"../../src/core/primitives.js\");\n  const { StringStream } = await import(\"../../src/core/stream.js\");\n  const { OperatorList } = await import(\"../../src/core/operator_list.js\");\n  const { PartialEvaluator, TranslatedFont } = await import(\"../../src/core/evaluator.js\");\n  const { WorkerTask } = await import(\"../../src/core/worker.js\");\n\n  // Create a fake CharProcs dictionary.\n  const charProcs = new Dict();\n  charProcs.getKeys = () => [\"A\"];\n  const fakeStream = new StringStream(\"\");\n  charProcs.get = () => fakeStream;\n\n  // Create a fake Type3 font dictionary.\n  const fontDict = new Dict();\n  fontDict.set(\"CharProcs\", charProcs);\n  fontDict.set(\"Resources\", new Dict());\n\n  // Create a fake Type3 font object with an empty bbox.\n  const font = { isType3Font: true, bbox: [0, 0, 0, 0] };\n  const loadedName = \"TestType3Font\";\n\n  // Instantiate a PartialEvaluator.\n  const evaluator = new PartialEvaluator({});\n  // Override getOperatorList to simulate processing a glyph stream.\n  evaluator.getOperatorList = function({ stream, operatorList }) {\n    operatorList.fnArray.push(OPS.setCharWidth);\n    operatorList.argsArray.push([]); // d0 operator has no bbox info.\n    operatorList.fnArray.push(OPS.constructPath);\n    // The third argument contains the bbox we want to compute.\n    operatorList.argsArray.push([null, null, [10, 20, 30, 40]]);\n    operatorList.length = operatorList.fnArray.length;\n    return Promise.resolve();\n  };\n\n  const task = new WorkerTask(\"test\", \"\");\n  const translatedFont = new TranslatedFont({ loadedName, font, dict: fontDict });\n  await translatedFont.loadType3Data(evaluator, fontDict, task);\n  if (!font.isCharBBox) {\n    throw new Error(\"Expected font.isCharBBox to be true\");\n  }\n  const expected = [10, 20, 30, 40];\n  if (\n    font.bbox[0] !== expected[0] ||\n    font.bbox[1] !== expected[1] ||\n    font.bbox[2] !== expected[2] ||\n    font.bbox[3] !== expected[3]\n  ) {\n    throw new Error(\"Font bbox does not match expected value\");\n  }\n});",
    "i2_gpt-4o": "it(\"should compute bbox for a Type3 glyph with setCharWidth operator\", async () => {\n  const { OPS } = await import(\"../../src/shared/util.js\");\n  const { Dict } = await import(\"../../src/core/primitives.js\");\n  const { StringStream } = await import(\"../../src/core/stream.js\");\n  const { OperatorList } = await import(\"../../src/core/operator_list.js\");\n  const { PartialEvaluator, TranslatedFont } = await import(\"../../src/core/evaluator.js\");\n  const { WorkerTask } = await import(\"../../src/core/worker.js\");\n\n  // Create a fake CharProcs dictionary.\n  const charProcs = new Dict();\n  charProcs.getKeys = () => [\"A\"];\n  const fakeStream = new StringStream(\"\");\n  charProcs.get = () => fakeStream;\n\n  // Create a fake Type3 font dictionary.\n  const fontDict = new Dict();\n  fontDict.set(\"CharProcs\", charProcs);\n  fontDict.set(\"Resources\", new Dict());\n\n  // Create a fake Type3 font object with an empty bbox.\n  const font = { isType3Font: true, bbox: [0, 0, 0, 0] };\n  const loadedName = \"TestType3Font\";\n\n  // Instantiate a PartialEvaluator.\n  const evaluator = new PartialEvaluator({});\n  // Override getOperatorList to simulate processing a glyph stream.\n  evaluator.getOperatorList = function({ stream, operatorList }) {\n    operatorList.fnArray.push(OPS.setCharWidth);\n    operatorList.argsArray.push([]); // d0 operator has no bbox info.\n    operatorList.fnArray.push(OPS.constructPath);\n    // The third argument contains the bbox we want to compute.\n    operatorList.argsArray.push([null, null, [10, 20, 30, 40]]);\n    operatorList.length = operatorList.fnArray.length;\n    return Promise.resolve();\n  };\n\n  const task = new WorkerTask(\"test\", \"\");\n  const translatedFont = new TranslatedFont({ loadedName, font, dict: fontDict });\n  await translatedFont.loadType3Data(evaluator, fontDict, task);\n  if (!font.isCharBBox) {\n    throw new Error(\"Expected font.isCharBBox to be true\");\n  }\n  const expected = [10, 20, 30, 40];\n  if (\n    font.bbox[0] !== expected[0] ||\n    font.bbox[1] !== expected[1] ||\n    font.bbox[2] !== expected[2] ||\n    font.bbox[3] !== expected[3]\n  ) {\n    throw new Error(\"Font bbox does not match expected value\");\n  }\n});",
    "i2_llama-3.3-70b-versatile": "it(\"should compute bbox for a Type3 glyph with setCharWidth operator\", async () => {\n  const { OPS } = await import(\"../../src/shared/util.js\");\n  const { Dict } = await import(\"../../src/core/primitives.js\");\n  const { StringStream } = await import(\"../../src/core/stream.js\");\n  const { OperatorList } = await import(\"../../src/core/operator_list.js\");\n  const { PartialEvaluator, TranslatedFont } = await import(\"../../src/core/evaluator.js\");\n  const { WorkerTask } = await import(\"../../src/core/worker.js\");\n\n  // Create a fake CharProcs dictionary.\n  const charProcs = new Dict();\n  charProcs.getKeys = () => [\"A\"];\n  const fakeStream = new StringStream(\"\");\n  charProcs.get = () => fakeStream;\n\n  // Create a fake Type3 font dictionary.\n  const fontDict = new Dict();\n  fontDict.set(\"CharProcs\", charProcs);\n  fontDict.set(\"Resources\", new Dict());\n\n  // Create a fake Type3 font object with an empty bbox.\n  const font = { isType3Font: true, bbox: [0, 0, 0, 0] };\n  const loadedName = \"TestType3Font\";\n\n  // Instantiate a PartialEvaluator.\n  const evaluator = new PartialEvaluator({});\n  // Override getOperatorList to simulate processing a glyph stream.\n  evaluator.getOperatorList = function({ stream, operatorList }) {\n    operatorList.fnArray.push(OPS.setCharWidth);\n    operatorList.argsArray.push([]); // d0 operator has no bbox info.\n    operatorList.fnArray.push(OPS.constructPath);\n    // The third argument contains the bbox we want to compute.\n    operatorList.argsArray.push([null, null, [10, 20, 30, 40]]);\n    operatorList.length = operatorList.fnArray.length;\n    return Promise.resolve();\n  };\n\n  const task = new WorkerTask(\"test\", \"\");\n  const translatedFont = new TranslatedFont({ loadedName, font, dict: fontDict });\n  await translatedFont.loadType3Data(evaluator, fontDict, task);\n  if (!font.isCharBBox) {\n    throw new Error(\"Expected font.isCharBBox to be true\");\n  }\n  const expected = [10, 20, 30, 40];\n  if (\n    font.bbox[0] !== expected[0] ||\n    font.bbox[1] !== expected[1] ||\n    font.bbox[2] !== expected[2] ||\n    font.bbox[3] !== expected[3]\n  ) {\n    throw new Error(\"Font bbox does not match expected value\");\n  }\n});",
    "i3_deepseek-r1-distill-llama-70b": "it(\"should compute bbox for a Type3 glyph with setCharWidth operator\", async () => {\n  const { OPS } = await import(\"../../src/shared/util.js\");\n  const { Dict } = await import(\"../../src/core/primitives.js\");\n  const { StringStream } = await import(\"../../src/core/stream.js\");\n  const { OperatorList } = await import(\"../../src/core/operator_list.js\");\n  const { PartialEvaluator, TranslatedFont } = await import(\"../../src/core/evaluator.js\");\n  const { WorkerTask } = await import(\"../../src/core/worker.js\");\n\n  // Create a fake CharProcs dictionary.\n  const charProcs = new Dict();\n  charProcs.getKeys = () => [\"A\"];\n  const fakeStream = new StringStream(\"\");\n  charProcs.get = () => fakeStream;\n\n  // Create a fake Type3 font dictionary.\n  const fontDict = new Dict();\n  fontDict.set(\"CharProcs\", charProcs);\n  fontDict.set(\"Resources\", new Dict());\n\n  // Create a fake Type3 font object with an empty bbox.\n  const font = { isType3Font: true, bbox: [0, 0, 0, 0] };\n  const loadedName = \"TestType3Font\";\n\n  // Instantiate a PartialEvaluator.\n  const evaluator = new PartialEvaluator({});\n  // Override getOperatorList to simulate processing a glyph stream.\n  evaluator.getOperatorList = function({ stream, operatorList }) {\n    operatorList.fnArray.push(OPS.setCharWidth);\n    operatorList.argsArray.push([]); // d0 operator has no bbox info.\n    operatorList.fnArray.push(OPS.constructPath);\n    // The third argument contains the bbox we want to compute.\n    operatorList.argsArray.push([null, null, [10, 20, 30, 40]]);\n    operatorList.length = operatorList.fnArray.length;\n    return Promise.resolve();\n  };\n\n  const task = new WorkerTask(\"test\", \"\");\n  const translatedFont = new TranslatedFont({ loadedName, font, dict: fontDict });\n  await translatedFont.loadType3Data(evaluator, fontDict, task);\n  if (!font.isCharBBox) {\n    throw new Error(\"Expected font.isCharBBox to be true\");\n  }\n  const expected = [10, 20, 30, 40];\n  if (\n    font.bbox[0] !== expected[0] ||\n    font.bbox[1] !== expected[1] ||\n    font.bbox[2] !== expected[2] ||\n    font.bbox[3] !== expected[3]\n  ) {\n    throw new Error(\"Font bbox does not match expected value\");\n  }\n});",
    "i3_gpt-4o": "it(\"should compute bbox for a Type3 glyph with setCharWidth operator\", async () => {\n  const { OPS } = await import(\"../../src/shared/util.js\");\n  const { Dict } = await import(\"../../src/core/primitives.js\");\n  const { StringStream } = await import(\"../../src/core/stream.js\");\n  const { OperatorList } = await import(\"../../src/core/operator_list.js\");\n  const { PartialEvaluator, TranslatedFont } = await import(\"../../src/core/evaluator.js\");\n  const { WorkerTask } = await import(\"../../src/core/worker.js\");\n\n  // Create a fake CharProcs dictionary.\n  const charProcs = new Dict();\n  charProcs.getKeys = () => [\"A\"];\n  const fakeStream = new StringStream(\"\");\n  charProcs.get = () => fakeStream;\n\n  // Create a fake Type3 font dictionary.\n  const fontDict = new Dict();\n  fontDict.set(\"CharProcs\", charProcs);\n  fontDict.set(\"Resources\", new Dict());\n\n  // Create a fake Type3 font object with an empty bbox.\n  const font = { isType3Font: true, bbox: [0, 0, 0, 0] };\n  const loadedName = \"TestType3Font\";\n\n  // Instantiate a PartialEvaluator.\n  const evaluator = new PartialEvaluator({});\n  // Override getOperatorList to simulate processing a glyph stream.\n  evaluator.getOperatorList = function({ stream, operatorList }) {\n    operatorList.fnArray.push(OPS.setCharWidth);\n    operatorList.argsArray.push([]); // d0 operator has no bbox info.\n    operatorList.fnArray.push(OPS.constructPath);\n    // The third argument contains the bbox we want to compute.\n    operatorList.argsArray.push([null, null, [10, 20, 30, 40]]);\n    operatorList.length = operatorList.fnArray.length;\n    return Promise.resolve();\n  };\n\n  const task = new WorkerTask(\"test\", \"\");\n  const translatedFont = new TranslatedFont({ loadedName, font, dict: fontDict });\n  await translatedFont.loadType3Data(evaluator, fontDict, task);\n  if (!font.isCharBBox) {\n    throw new Error(\"Expected font.isCharBBox to be true\");\n  }\n  const expected = [10, 20, 30, 40];\n  if (\n    font.bbox[0] !== expected[0] ||\n    font.bbox[1] !== expected[1] ||\n    font.bbox[2] !== expected[2] ||\n    font.bbox[3] !== expected[3]\n  ) {\n    throw new Error(\"Font bbox does not match expected value\");\n  }\n});",
    "i3_llama-3.3-70b-versatile": "it(\"should compute bbox for a Type3 glyph with setCharWidth operator\", async () => {\n  const { OPS } = await import(\"../../src/shared/util.js\");\n  const { Dict } = await import(\"../../src/core/primitives.js\");\n  const { StringStream } = await import(\"../../src/core/stream.js\");\n  const { OperatorList } = await import(\"../../src/core/operator_list.js\");\n  const { PartialEvaluator, TranslatedFont } = await import(\"../../src/core/evaluator.js\");\n  const { WorkerTask } = await import(\"../../src/core/worker.js\");\n\n  // Create a fake CharProcs dictionary.\n  const charProcs = new Dict();\n  charProcs.getKeys = () => [\"A\"];\n  const fakeStream = new StringStream(\"\");\n  charProcs.get = () => fakeStream;\n\n  // Create a fake Type3 font dictionary.\n  const fontDict = new Dict();\n  fontDict.set(\"CharProcs\", charProcs);\n  fontDict.set(\"Resources\", new Dict());\n\n  // Create a fake Type3 font object with an empty bbox.\n  const font = { isType3Font: true, bbox: [0, 0, 0, 0] };\n  const loadedName = \"TestType3Font\";\n\n  // Instantiate a PartialEvaluator.\n  const evaluator = new PartialEvaluator({});\n  // Override getOperatorList to simulate processing a glyph stream.\n  evaluator.getOperatorList = function({ stream, operatorList }) {\n    operatorList.fnArray.push(OPS.setCharWidth);\n    operatorList.argsArray.push([]); // d0 operator has no bbox info.\n    operatorList.fnArray.push(OPS.constructPath);\n    // The third argument contains the bbox we want to compute.\n    operatorList.argsArray.push([null, null, [10, 20, 30, 40]]);\n    operatorList.length = operatorList.fnArray.length;\n    return Promise.resolve();\n  };\n\n  const task = new WorkerTask(\"test\", \"\");\n  const translatedFont = new TranslatedFont({ loadedName, font, dict: fontDict });\n  await translatedFont.loadType3Data(evaluator, fontDict, task);\n  if (!font.isCharBBox) {\n    throw new Error(\"Expected font.isCharBBox to be true\");\n  }\n  const expected = [10, 20, 30, 40];\n  if (\n    font.bbox[0] !== expected[0] ||\n    font.bbox[1] !== expected[1] ||\n    font.bbox[2] !== expected[2] ||\n    font.bbox[3] !== expected[3]\n  ) {\n    throw new Error(\"Font bbox does not match expected value\");\n  }\n});",
    "i4_deepseek-r1-distill-llama-70b": "it(\"should compute bbox for a Type3 glyph with setCharWidth operator\", async () => {\n  const { OPS } = await import(\"../../src/shared/util.js\");\n  const { Dict } = await import(\"../../src/core/primitives.js\");\n  const { StringStream } = await import(\"../../src/core/stream.js\");\n  const { OperatorList } = await import(\"../../src/core/operator_list.js\");\n  const { PartialEvaluator, TranslatedFont } = await import(\"../../src/core/evaluator.js\");\n  const { WorkerTask } = await import(\"../../src/core/worker.js\");\n\n  // Create a fake CharProcs dictionary.\n  const charProcs = new Dict();\n  charProcs.getKeys = () => [\"A\"];\n  const fakeStream = new StringStream(\"\");\n  charProcs.get = () => fakeStream;\n\n  // Create a fake Type3 font dictionary.\n  const fontDict = new Dict();\n  fontDict.set(\"CharProcs\", charProcs);\n  fontDict.set(\"Resources\", new Dict());\n\n  // Create a fake Type3 font object with an empty bbox.\n  const font = { isType3Font: true, bbox: [0, 0, 0, 0] };\n  const loadedName = \"TestType3Font\";\n\n  // Instantiate a PartialEvaluator.\n  const evaluator = new PartialEvaluator({});\n  // Override getOperatorList to simulate processing a glyph stream.\n  evaluator.getOperatorList = function({ stream, operatorList }) {\n    operatorList.fnArray.push(OPS.setCharWidth);\n    operatorList.argsArray.push([]); // d0 operator has no bbox info.\n    operatorList.fnArray.push(OPS.constructPath);\n    // The third argument contains the bbox we want to compute.\n    operatorList.argsArray.push([null, null, [10, 20, 30, 40]]);\n    operatorList.length = operatorList.fnArray.length;\n    return Promise.resolve();\n  };\n\n  const task = new WorkerTask(\"test\", \"\");\n  const translatedFont = new TranslatedFont({ loadedName, font, dict: fontDict });\n  await translatedFont.loadType3Data(evaluator, fontDict, task);\n  if (!font.isCharBBox) {\n    throw new Error(\"Expected font.isCharBBox to be true\");\n  }\n  const expected = [10, 20, 30, 40];\n  if (\n    font.bbox[0] !== expected[0] ||\n    font.bbox[1] !== expected[1] ||\n    font.bbox[2] !== expected[2] ||\n    font.bbox[3] !== expected[3]\n  ) {\n    throw new Error(\"Font bbox does not match expected value\");\n  }\n});",
    "i4_gpt-4o": "it(\"should compute bbox for a Type3 glyph with setCharWidth operator\", async () => {\n  const { OPS } = await import(\"../../src/shared/util.js\");\n  const { Dict } = await import(\"../../src/core/primitives.js\");\n  const { StringStream } = await import(\"../../src/core/stream.js\");\n  const { OperatorList } = await import(\"../../src/core/operator_list.js\");\n  const { PartialEvaluator, TranslatedFont } = await import(\"../../src/core/evaluator.js\");\n  const { WorkerTask } = await import(\"../../src/core/worker.js\");\n\n  // Create a fake CharProcs dictionary.\n  const charProcs = new Dict();\n  charProcs.getKeys = () => [\"A\"];\n  const fakeStream = new StringStream(\"\");\n  charProcs.get = () => fakeStream;\n\n  // Create a fake Type3 font dictionary.\n  const fontDict = new Dict();\n  fontDict.set(\"CharProcs\", charProcs);\n  fontDict.set(\"Resources\", new Dict());\n\n  // Create a fake Type3 font object with an empty bbox.\n  const font = { isType3Font: true, bbox: [0, 0, 0, 0] };\n  const loadedName = \"TestType3Font\";\n\n  // Instantiate a PartialEvaluator.\n  const evaluator = new PartialEvaluator({});\n  // Override getOperatorList to simulate processing a glyph stream.\n  evaluator.getOperatorList = function({ stream, operatorList }) {\n    operatorList.fnArray.push(OPS.setCharWidth);\n    operatorList.argsArray.push([]); // d0 operator has no bbox info.\n    operatorList.fnArray.push(OPS.constructPath);\n    // The third argument contains the bbox we want to compute.\n    operatorList.argsArray.push([null, null, [10, 20, 30, 40]]);\n    operatorList.length = operatorList.fnArray.length;\n    return Promise.resolve();\n  };\n\n  const task = new WorkerTask(\"test\", \"\");\n  const translatedFont = new TranslatedFont({ loadedName, font, dict: fontDict });\n  await translatedFont.loadType3Data(evaluator, fontDict, task);\n  if (!font.isCharBBox) {\n    throw new Error(\"Expected font.isCharBBox to be true\");\n  }\n  const expected = [10, 20, 30, 40];\n  if (\n    font.bbox[0] !== expected[0] ||\n    font.bbox[1] !== expected[1] ||\n    font.bbox[2] !== expected[2] ||\n    font.bbox[3] !== expected[3]\n  ) {\n    throw new Error(\"Font bbox does not match expected value\");\n  }\n});",
    "i4_llama-3.3-70b-versatile": "it(\"should compute bbox for a Type3 glyph with setCharWidth operator\", async () => {\n  const { OPS } = await import(\"../../src/shared/util.js\");\n  const { Dict } = await import(\"../../src/core/primitives.js\");\n  const { StringStream } = await import(\"../../src/core/stream.js\");\n  const { OperatorList } = await import(\"../../src/core/operator_list.js\");\n  const { PartialEvaluator, TranslatedFont } = await import(\"../../src/core/evaluator.js\");\n  const { WorkerTask } = await import(\"../../src/core/worker.js\");\n\n  // Create a fake CharProcs dictionary.\n  const charProcs = new Dict();\n  charProcs.getKeys = () => [\"A\"];\n  const fakeStream = new StringStream(\"\");\n  charProcs.get = () => fakeStream;\n\n  // Create a fake Type3 font dictionary.\n  const fontDict = new Dict();\n  fontDict.set(\"CharProcs\", charProcs);\n  fontDict.set(\"Resources\", new Dict());\n\n  // Create a fake Type3 font object with an empty bbox.\n  const font = { isType3Font: true, bbox: [0, 0, 0, 0] };\n  const loadedName = \"TestType3Font\";\n\n  // Instantiate a PartialEvaluator.\n  const evaluator = new PartialEvaluator({});\n  // Override getOperatorList to simulate processing a glyph stream.\n  evaluator.getOperatorList = function({ stream, operatorList }) {\n    operatorList.fnArray.push(OPS.setCharWidth);\n    operatorList.argsArray.push([]); // d0 operator has no bbox info.\n    operatorList.fnArray.push(OPS.constructPath);\n    // The third argument contains the bbox we want to compute.\n    operatorList.argsArray.push([null, null, [10, 20, 30, 40]]);\n    operatorList.length = operatorList.fnArray.length;\n    return Promise.resolve();\n  };\n\n  const task = new WorkerTask(\"test\", \"\");\n  const translatedFont = new TranslatedFont({ loadedName, font, dict: fontDict });\n  await translatedFont.loadType3Data(evaluator, fontDict, task);\n  if (!font.isCharBBox) {\n    throw new Error(\"Expected font.isCharBBox to be true\");\n  }\n  const expected = [10, 20, 30, 40];\n  if (\n    font.bbox[0] !== expected[0] ||\n    font.bbox[1] !== expected[1] ||\n    font.bbox[2] !== expected[2] ||\n    font.bbox[3] !== expected[3]\n  ) {\n    throw new Error(\"Font bbox does not match expected value\");\n  }\n});",
    "i5_deepseek-r1-distill-llama-70b": "it(\"should compute bbox for a Type3 glyph with setCharWidth operator\", async () => {\n  const { OPS } = await import(\"../../src/shared/util.js\");\n  const { Dict } = await import(\"../../src/core/primitives.js\");\n  const { StringStream } = await import(\"../../src/core/stream.js\");\n  const { OperatorList } = await import(\"../../src/core/operator_list.js\");\n  const { PartialEvaluator, TranslatedFont } = await import(\"../../src/core/evaluator.js\");\n  const { WorkerTask } = await import(\"../../src/core/worker.js\");\n\n  // Create a fake CharProcs dictionary.\n  const charProcs = new Dict();\n  charProcs.getKeys = () => [\"A\"];\n  const fakeStream = new StringStream(\"\");\n  charProcs.get = () => fakeStream;\n\n  // Create a fake Type3 font dictionary.\n  const fontDict = new Dict();\n  fontDict.set(\"CharProcs\", charProcs);\n  fontDict.set(\"Resources\", new Dict());\n\n  // Create a fake Type3 font object with an empty bbox.\n  const font = { isType3Font: true, bbox: [0, 0, 0, 0] };\n  const loadedName = \"TestType3Font\";\n\n  // Instantiate a PartialEvaluator.\n  const evaluator = new PartialEvaluator({});\n  // Override getOperatorList to simulate processing a glyph stream.\n  evaluator.getOperatorList = function({ stream, operatorList }) {\n    operatorList.fnArray.push(OPS.setCharWidth);\n    operatorList.argsArray.push([]); // d0 operator has no bbox info.\n    operatorList.fnArray.push(OPS.constructPath);\n    // The third argument contains the bbox we want to compute.\n    operatorList.argsArray.push([null, null, [10, 20, 30, 40]]);\n    operatorList.length = operatorList.fnArray.length;\n    return Promise.resolve();\n  };\n\n  const task = new WorkerTask(\"test\", \"\");\n  const translatedFont = new TranslatedFont({ loadedName, font, dict: fontDict });\n  await translatedFont.loadType3Data(evaluator, fontDict, task);\n  if (!font.isCharBBox) {\n    throw new Error(\"Expected font.isCharBBox to be true\");\n  }\n  const expected = [10, 20, 30, 40];\n  if (\n    font.bbox[0] !== expected[0] ||\n    font.bbox[1] !== expected[1] ||\n    font.bbox[2] !== expected[2] ||\n    font.bbox[3] !== expected[3]\n  ) {\n    throw new Error(\"Font bbox does not match expected value\");\n  }\n});",
    "i5_gpt-4o": "it(\"should compute bbox for a Type3 glyph with setCharWidth operator\", async () => {\n  const { OPS } = await import(\"../../src/shared/util.js\");\n  const { Dict } = await import(\"../../src/core/primitives.js\");\n  const { StringStream } = await import(\"../../src/core/stream.js\");\n  const { OperatorList } = await import(\"../../src/core/operator_list.js\");\n  const { PartialEvaluator, TranslatedFont } = await import(\"../../src/core/evaluator.js\");\n  const { WorkerTask } = await import(\"../../src/core/worker.js\");\n\n  // Create a fake CharProcs dictionary.\n  const charProcs = new Dict();\n  charProcs.getKeys = () => [\"A\"];\n  const fakeStream = new StringStream(\"\");\n  charProcs.get = () => fakeStream;\n\n  // Create a fake Type3 font dictionary.\n  const fontDict = new Dict();\n  fontDict.set(\"CharProcs\", charProcs);\n  fontDict.set(\"Resources\", new Dict());\n\n  // Create a fake Type3 font object with an empty bbox.\n  const font = { isType3Font: true, bbox: [0, 0, 0, 0] };\n  const loadedName = \"TestType3Font\";\n\n  // Instantiate a PartialEvaluator.\n  const evaluator = new PartialEvaluator({});\n  // Override getOperatorList to simulate processing a glyph stream.\n  evaluator.getOperatorList = function({ stream, operatorList }) {\n    operatorList.fnArray.push(OPS.setCharWidth);\n    operatorList.argsArray.push([]); // d0 operator has no bbox info.\n    operatorList.fnArray.push(OPS.constructPath);\n    // The third argument contains the bbox we want to compute.\n    operatorList.argsArray.push([null, null, [10, 20, 30, 40]]);\n    operatorList.length = operatorList.fnArray.length;\n    return Promise.resolve();\n  };\n\n  const task = new WorkerTask(\"test\", \"\");\n  const translatedFont = new TranslatedFont({ loadedName, font, dict: fontDict });\n  await translatedFont.loadType3Data(evaluator, fontDict, task);\n  if (!font.isCharBBox) {\n    throw new Error(\"Expected font.isCharBBox to be true\");\n  }\n  const expected = [10, 20, 30, 40];\n  if (\n    font.bbox[0] !== expected[0] ||\n    font.bbox[1] !== expected[1] ||\n    font.bbox[2] !== expected[2] ||\n    font.bbox[3] !== expected[3]\n  ) {\n    throw new Error(\"Font bbox does not match expected value\");\n  }\n});",
    "i5_llama-3.3-70b-versatile": "it(\"should compute bbox for a Type3 glyph with setCharWidth operator\", async () => {\n  const { OPS } = await import(\"../../src/shared/util.js\");\n  const { Dict } = await import(\"../../src/core/primitives.js\");\n  const { StringStream } = await import(\"../../src/core/stream.js\");\n  const { OperatorList } = await import(\"../../src/core/operator_list.js\");\n  const { PartialEvaluator, TranslatedFont } = await import(\"../../src/core/evaluator.js\");\n  const { WorkerTask } = await import(\"../../src/core/worker.js\");\n\n  // Create a fake CharProcs dictionary.\n  const charProcs = new Dict();\n  charProcs.getKeys = () => [\"A\"];\n  const fakeStream = new StringStream(\"\");\n  charProcs.get = () => fakeStream;\n\n  // Create a fake Type3 font dictionary.\n  const fontDict = new Dict();\n  fontDict.set(\"CharProcs\", charProcs);\n  fontDict.set(\"Resources\", new Dict());\n\n  // Create a fake Type3 font object with an empty bbox.\n  const font = { isType3Font: true, bbox: [0, 0, 0, 0] };\n  const loadedName = \"TestType3Font\";\n\n  // Instantiate a PartialEvaluator.\n  const evaluator = new PartialEvaluator({});\n  // Override getOperatorList to simulate processing a glyph stream.\n  evaluator.getOperatorList = function({ stream, operatorList }) {\n    operatorList.fnArray.push(OPS.setCharWidth);\n    operatorList.argsArray.push([]); // d0 operator has no bbox info.\n    operatorList.fnArray.push(OPS.constructPath);\n    // The third argument contains the bbox we want to compute.\n    operatorList.argsArray.push([null, null, [10, 20, 30, 40]]);\n    operatorList.length = operatorList.fnArray.length;\n    return Promise.resolve();\n  };\n\n  const task = new WorkerTask(\"test\", \"\");\n  const translatedFont = new TranslatedFont({ loadedName, font, dict: fontDict });\n  await translatedFont.loadType3Data(evaluator, fontDict, task);\n  if (!font.isCharBBox) {\n    throw new Error(\"Expected font.isCharBBox to be true\");\n  }\n  const expected = [10, 20, 30, 40];\n  if (\n    font.bbox[0] !== expected[0] ||\n    font.bbox[1] !== expected[1] ||\n    font.bbox[2] !== expected[2] ||\n    font.bbox[3] !== expected[3]\n  ) {\n    throw new Error(\"Font bbox does not match expected value\");\n  }\n});"
  },
  "19677": {
    "i1_deepseek-r1-distill-llama-70b": "it(\"should set the alpha channel to 255 for CMYK images when using DeviceCmykCS\", async () => {\n  const { JpegImage } = await import(\"../../src/core/jpg.js\");\n  const { ColorSpaceUtils } = await import(\"../../src/core/colorspace_utils.js\");\n  const { DeviceCmykCS } = await import(\"../../src/core/colorspace.js\");\n  // Override the ColorSpaceUtils.cmyk with a DeviceCmykCS instance that produces alpha = 0.\n  ColorSpaceUtils.cmyk = new DeviceCmykCS();\n  ColorSpaceUtils.cmyk.getRgbBuffer = (src, srcOffset, numPixels, dest, destOffset, bits, scale) => {\n    for (let i = 0; i < numPixels; i++) {\n      const idx = destOffset + i * 4;\n      dest[idx] = 10;\n      dest[idx + 1] = 20;\n      dest[idx + 2] = 30;\n      dest[idx + 3] = 0;\n    }\n  };\n  const jpegImage = new JpegImage();\n  const data = new Uint8ClampedArray(4); // one pixel RGBA: [r, g, b, alpha]\n  jpegImage._convertCmykToRgba(data);\n  if (data[3] !== 255) {\n    throw new Error(\"Expected alpha channel value to be 255, but got \" + data[3]);\n  }\n});\n",
    "i1_gpt-4o": "it(\"should set the alpha channel to 255 for CMYK images when using DeviceCmykCS\", async () => {\n  const { JpegImage } = await import(\"../../src/core/jpg.js\");\n  const { ColorSpaceUtils } = await import(\"../../src/core/colorspace_utils.js\");\n  const { DeviceCmykCS } = await import(\"../../src/core/colorspace.js\");\n  // Override the ColorSpaceUtils.cmyk with a DeviceCmykCS instance that produces alpha = 0.\n  ColorSpaceUtils.cmyk = new DeviceCmykCS();\n  ColorSpaceUtils.cmyk.getRgbBuffer = (src, srcOffset, numPixels, dest, destOffset, bits, scale) => {\n    for (let i = 0; i < numPixels; i++) {\n      const idx = destOffset + i * 4;\n      dest[idx] = 10;\n      dest[idx + 1] = 20;\n      dest[idx + 2] = 30;\n      dest[idx + 3] = 0;\n    }\n  };\n  const jpegImage = new JpegImage();\n  const data = new Uint8ClampedArray(4); // one pixel RGBA: [r, g, b, alpha]\n  jpegImage._convertCmykToRgba(data);\n  if (data[3] !== 255) {\n    throw new Error(\"Expected alpha channel value to be 255, but got \" + data[3]);\n  }\n});\n",
    "i1_llama-3.3-70b-versatile": "it(\"should set the alpha channel to 255 for CMYK images when using DeviceCmykCS\", async () => {\n  const { JpegImage } = await import(\"../../src/core/jpg.js\");\n  const { ColorSpaceUtils } = await import(\"../../src/core/colorspace_utils.js\");\n  const { DeviceCmykCS } = await import(\"../../src/core/colorspace.js\");\n  // Override the ColorSpaceUtils.cmyk with a DeviceCmykCS instance that produces alpha = 0.\n  ColorSpaceUtils.cmyk = new DeviceCmykCS();\n  ColorSpaceUtils.cmyk.getRgbBuffer = (src, srcOffset, numPixels, dest, destOffset, bits, scale) => {\n    for (let i = 0; i < numPixels; i++) {\n      const idx = destOffset + i * 4;\n      dest[idx] = 10;\n      dest[idx + 1] = 20;\n      dest[idx + 2] = 30;\n      dest[idx + 3] = 0;\n    }\n  };\n  const jpegImage = new JpegImage();\n  const data = new Uint8ClampedArray(4); // one pixel RGBA: [r, g, b, alpha]\n  jpegImage._convertCmykToRgba(data);\n  if (data[3] !== 255) {\n    throw new Error(\"Expected alpha channel value to be 255, but got \" + data[3]);\n  }\n});\n",
    "i1_MOCK": "it(\"should set the alpha channel to 255 for CMYK images when using DeviceCmykCS\", async () => {\n  const { JpegImage } = await import(\"../../src/core/jpg.js\");\n  const { ColorSpaceUtils } = await import(\"../../src/core/colorspace_utils.js\");\n  const { DeviceCmykCS } = await import(\"../../src/core/colorspace.js\");\n  // Override the ColorSpaceUtils.cmyk with a DeviceCmykCS instance that produces alpha = 0.\n  ColorSpaceUtils.cmyk = new DeviceCmykCS();\n  ColorSpaceUtils.cmyk.getRgbBuffer = (src, srcOffset, numPixels, dest, destOffset, bits, scale) => {\n    for (let i = 0; i < numPixels; i++) {\n      const idx = destOffset + i * 4;\n      dest[idx] = 10;\n      dest[idx + 1] = 20;\n      dest[idx + 2] = 30;\n      dest[idx + 3] = 0;\n    }\n  };\n  const jpegImage = new JpegImage();\n  const data = new Uint8ClampedArray(4); // one pixel RGBA: [r, g, b, alpha]\n  jpegImage._convertCmykToRgba(data);\n  if (data[3] !== 255) {\n    throw new Error(\"Expected alpha channel value to be 255, but got \" + data[3]);\n  }\n});\n",
    "i2_deepseek-r1-distill-llama-70b": "it(\"should set the alpha channel to 255 for CMYK images when using DeviceCmykCS\", async () => {\n  const { JpegImage } = await import(\"../../src/core/jpg.js\");\n  const { ColorSpaceUtils } = await import(\"../../src/core/colorspace_utils.js\");\n  const { DeviceCmykCS } = await import(\"../../src/core/colorspace.js\");\n  // Override the ColorSpaceUtils.cmyk with a DeviceCmykCS instance that produces alpha = 0.\n  ColorSpaceUtils.cmyk = new DeviceCmykCS();\n  ColorSpaceUtils.cmyk.getRgbBuffer = (src, srcOffset, numPixels, dest, destOffset, bits, scale) => {\n    for (let i = 0; i < numPixels; i++) {\n      const idx = destOffset + i * 4;\n      dest[idx] = 10;\n      dest[idx + 1] = 20;\n      dest[idx + 2] = 30;\n      dest[idx + 3] = 0;\n    }\n  };\n  const jpegImage = new JpegImage();\n  const data = new Uint8ClampedArray(4); // one pixel RGBA: [r, g, b, alpha]\n  jpegImage._convertCmykToRgba(data);\n  if (data[3] !== 255) {\n    throw new Error(\"Expected alpha channel value to be 255, but got \" + data[3]);\n  }\n});\n",
    "i2_gpt-4o": "it(\"should set the alpha channel to 255 for CMYK images when using DeviceCmykCS\", async () => {\n  const { JpegImage } = await import(\"../../src/core/jpg.js\");\n  const { ColorSpaceUtils } = await import(\"../../src/core/colorspace_utils.js\");\n  const { DeviceCmykCS } = await import(\"../../src/core/colorspace.js\");\n  // Override the ColorSpaceUtils.cmyk with a DeviceCmykCS instance that produces alpha = 0.\n  ColorSpaceUtils.cmyk = new DeviceCmykCS();\n  ColorSpaceUtils.cmyk.getRgbBuffer = (src, srcOffset, numPixels, dest, destOffset, bits, scale) => {\n    for (let i = 0; i < numPixels; i++) {\n      const idx = destOffset + i * 4;\n      dest[idx] = 10;\n      dest[idx + 1] = 20;\n      dest[idx + 2] = 30;\n      dest[idx + 3] = 0;\n    }\n  };\n  const jpegImage = new JpegImage();\n  const data = new Uint8ClampedArray(4); // one pixel RGBA: [r, g, b, alpha]\n  jpegImage._convertCmykToRgba(data);\n  if (data[3] !== 255) {\n    throw new Error(\"Expected alpha channel value to be 255, but got \" + data[3]);\n  }\n});\n",
    "i2_llama-3.3-70b-versatile": "it(\"should set the alpha channel to 255 for CMYK images when using DeviceCmykCS\", async () => {\n  const { JpegImage } = await import(\"../../src/core/jpg.js\");\n  const { ColorSpaceUtils } = await import(\"../../src/core/colorspace_utils.js\");\n  const { DeviceCmykCS } = await import(\"../../src/core/colorspace.js\");\n  // Override the ColorSpaceUtils.cmyk with a DeviceCmykCS instance that produces alpha = 0.\n  ColorSpaceUtils.cmyk = new DeviceCmykCS();\n  ColorSpaceUtils.cmyk.getRgbBuffer = (src, srcOffset, numPixels, dest, destOffset, bits, scale) => {\n    for (let i = 0; i < numPixels; i++) {\n      const idx = destOffset + i * 4;\n      dest[idx] = 10;\n      dest[idx + 1] = 20;\n      dest[idx + 2] = 30;\n      dest[idx + 3] = 0;\n    }\n  };\n  const jpegImage = new JpegImage();\n  const data = new Uint8ClampedArray(4); // one pixel RGBA: [r, g, b, alpha]\n  jpegImage._convertCmykToRgba(data);\n  if (data[3] !== 255) {\n    throw new Error(\"Expected alpha channel value to be 255, but got \" + data[3]);\n  }\n});\n",
    "i3_deepseek-r1-distill-llama-70b": "it(\"should set the alpha channel to 255 for CMYK images when using DeviceCmykCS\", async () => {\n  const { JpegImage } = await import(\"../../src/core/jpg.js\");\n  const { ColorSpaceUtils } = await import(\"../../src/core/colorspace_utils.js\");\n  const { DeviceCmykCS } = await import(\"../../src/core/colorspace.js\");\n  // Override the ColorSpaceUtils.cmyk with a DeviceCmykCS instance that produces alpha = 0.\n  ColorSpaceUtils.cmyk = new DeviceCmykCS();\n  ColorSpaceUtils.cmyk.getRgbBuffer = (src, srcOffset, numPixels, dest, destOffset, bits, scale) => {\n    for (let i = 0; i < numPixels; i++) {\n      const idx = destOffset + i * 4;\n      dest[idx] = 10;\n      dest[idx + 1] = 20;\n      dest[idx + 2] = 30;\n      dest[idx + 3] = 0;\n    }\n  };\n  const jpegImage = new JpegImage();\n  const data = new Uint8ClampedArray(4); // one pixel RGBA: [r, g, b, alpha]\n  jpegImage._convertCmykToRgba(data);\n  if (data[3] !== 255) {\n    throw new Error(\"Expected alpha channel value to be 255, but got \" + data[3]);\n  }\n});\n",
    "i3_gpt-4o": "it(\"should set the alpha channel to 255 for CMYK images when using DeviceCmykCS\", async () => {\n  const { JpegImage } = await import(\"../../src/core/jpg.js\");\n  const { ColorSpaceUtils } = await import(\"../../src/core/colorspace_utils.js\");\n  const { DeviceCmykCS } = await import(\"../../src/core/colorspace.js\");\n  // Override the ColorSpaceUtils.cmyk with a DeviceCmykCS instance that produces alpha = 0.\n  ColorSpaceUtils.cmyk = new DeviceCmykCS();\n  ColorSpaceUtils.cmyk.getRgbBuffer = (src, srcOffset, numPixels, dest, destOffset, bits, scale) => {\n    for (let i = 0; i < numPixels; i++) {\n      const idx = destOffset + i * 4;\n      dest[idx] = 10;\n      dest[idx + 1] = 20;\n      dest[idx + 2] = 30;\n      dest[idx + 3] = 0;\n    }\n  };\n  const jpegImage = new JpegImage();\n  const data = new Uint8ClampedArray(4); // one pixel RGBA: [r, g, b, alpha]\n  jpegImage._convertCmykToRgba(data);\n  if (data[3] !== 255) {\n    throw new Error(\"Expected alpha channel value to be 255, but got \" + data[3]);\n  }\n});\n",
    "i3_llama-3.3-70b-versatile": "it(\"should set the alpha channel to 255 for CMYK images when using DeviceCmykCS\", async () => {\n  const { JpegImage } = await import(\"../../src/core/jpg.js\");\n  const { ColorSpaceUtils } = await import(\"../../src/core/colorspace_utils.js\");\n  const { DeviceCmykCS } = await import(\"../../src/core/colorspace.js\");\n  // Override the ColorSpaceUtils.cmyk with a DeviceCmykCS instance that produces alpha = 0.\n  ColorSpaceUtils.cmyk = new DeviceCmykCS();\n  ColorSpaceUtils.cmyk.getRgbBuffer = (src, srcOffset, numPixels, dest, destOffset, bits, scale) => {\n    for (let i = 0; i < numPixels; i++) {\n      const idx = destOffset + i * 4;\n      dest[idx] = 10;\n      dest[idx + 1] = 20;\n      dest[idx + 2] = 30;\n      dest[idx + 3] = 0;\n    }\n  };\n  const jpegImage = new JpegImage();\n  const data = new Uint8ClampedArray(4); // one pixel RGBA: [r, g, b, alpha]\n  jpegImage._convertCmykToRgba(data);\n  if (data[3] !== 255) {\n    throw new Error(\"Expected alpha channel value to be 255, but got \" + data[3]);\n  }\n});\n",
    "i4_deepseek-r1-distill-llama-70b": "it(\"should set the alpha channel to 255 for CMYK images when using DeviceCmykCS\", async () => {\n  const { JpegImage } = await import(\"../../src/core/jpg.js\");\n  const { ColorSpaceUtils } = await import(\"../../src/core/colorspace_utils.js\");\n  const { DeviceCmykCS } = await import(\"../../src/core/colorspace.js\");\n  // Override the ColorSpaceUtils.cmyk with a DeviceCmykCS instance that produces alpha = 0.\n  ColorSpaceUtils.cmyk = new DeviceCmykCS();\n  ColorSpaceUtils.cmyk.getRgbBuffer = (src, srcOffset, numPixels, dest, destOffset, bits, scale) => {\n    for (let i = 0; i < numPixels; i++) {\n      const idx = destOffset + i * 4;\n      dest[idx] = 10;\n      dest[idx + 1] = 20;\n      dest[idx + 2] = 30;\n      dest[idx + 3] = 0;\n    }\n  };\n  const jpegImage = new JpegImage();\n  const data = new Uint8ClampedArray(4); // one pixel RGBA: [r, g, b, alpha]\n  jpegImage._convertCmykToRgba(data);\n  if (data[3] !== 255) {\n    throw new Error(\"Expected alpha channel value to be 255, but got \" + data[3]);\n  }\n});\n",
    "i4_gpt-4o": "it(\"should set the alpha channel to 255 for CMYK images when using DeviceCmykCS\", async () => {\n  const { JpegImage } = await import(\"../../src/core/jpg.js\");\n  const { ColorSpaceUtils } = await import(\"../../src/core/colorspace_utils.js\");\n  const { DeviceCmykCS } = await import(\"../../src/core/colorspace.js\");\n  // Override the ColorSpaceUtils.cmyk with a DeviceCmykCS instance that produces alpha = 0.\n  ColorSpaceUtils.cmyk = new DeviceCmykCS();\n  ColorSpaceUtils.cmyk.getRgbBuffer = (src, srcOffset, numPixels, dest, destOffset, bits, scale) => {\n    for (let i = 0; i < numPixels; i++) {\n      const idx = destOffset + i * 4;\n      dest[idx] = 10;\n      dest[idx + 1] = 20;\n      dest[idx + 2] = 30;\n      dest[idx + 3] = 0;\n    }\n  };\n  const jpegImage = new JpegImage();\n  const data = new Uint8ClampedArray(4); // one pixel RGBA: [r, g, b, alpha]\n  jpegImage._convertCmykToRgba(data);\n  if (data[3] !== 255) {\n    throw new Error(\"Expected alpha channel value to be 255, but got \" + data[3]);\n  }\n});\n",
    "i4_llama-3.3-70b-versatile": "it(\"should set the alpha channel to 255 for CMYK images when using DeviceCmykCS\", async () => {\n  const { JpegImage } = await import(\"../../src/core/jpg.js\");\n  const { ColorSpaceUtils } = await import(\"../../src/core/colorspace_utils.js\");\n  const { DeviceCmykCS } = await import(\"../../src/core/colorspace.js\");\n  // Override the ColorSpaceUtils.cmyk with a DeviceCmykCS instance that produces alpha = 0.\n  ColorSpaceUtils.cmyk = new DeviceCmykCS();\n  ColorSpaceUtils.cmyk.getRgbBuffer = (src, srcOffset, numPixels, dest, destOffset, bits, scale) => {\n    for (let i = 0; i < numPixels; i++) {\n      const idx = destOffset + i * 4;\n      dest[idx] = 10;\n      dest[idx + 1] = 20;\n      dest[idx + 2] = 30;\n      dest[idx + 3] = 0;\n    }\n  };\n  const jpegImage = new JpegImage();\n  const data = new Uint8ClampedArray(4); // one pixel RGBA: [r, g, b, alpha]\n  jpegImage._convertCmykToRgba(data);\n  if (data[3] !== 255) {\n    throw new Error(\"Expected alpha channel value to be 255, but got \" + data[3]);\n  }\n});\n",
    "i5_deepseek-r1-distill-llama-70b": "it(\"should set the alpha channel to 255 for CMYK images when using DeviceCmykCS\", async () => {\n  const { JpegImage } = await import(\"../../src/core/jpg.js\");\n  const { ColorSpaceUtils } = await import(\"../../src/core/colorspace_utils.js\");\n  const { DeviceCmykCS } = await import(\"../../src/core/colorspace.js\");\n  // Override the ColorSpaceUtils.cmyk with a DeviceCmykCS instance that produces alpha = 0.\n  ColorSpaceUtils.cmyk = new DeviceCmykCS();\n  ColorSpaceUtils.cmyk.getRgbBuffer = (src, srcOffset, numPixels, dest, destOffset, bits, scale) => {\n    for (let i = 0; i < numPixels; i++) {\n      const idx = destOffset + i * 4;\n      dest[idx] = 10;\n      dest[idx + 1] = 20;\n      dest[idx + 2] = 30;\n      dest[idx + 3] = 0;\n    }\n  };\n  const jpegImage = new JpegImage();\n  const data = new Uint8ClampedArray(4); // one pixel RGBA: [r, g, b, alpha]\n  jpegImage._convertCmykToRgba(data);\n  if (data[3] !== 255) {\n    throw new Error(\"Expected alpha channel value to be 255, but got \" + data[3]);\n  }\n});\n",
    "i5_gpt-4o": "it(\"should set the alpha channel to 255 for CMYK images when using DeviceCmykCS\", async () => {\n  const { JpegImage } = await import(\"../../src/core/jpg.js\");\n  const { ColorSpaceUtils } = await import(\"../../src/core/colorspace_utils.js\");\n  const { DeviceCmykCS } = await import(\"../../src/core/colorspace.js\");\n  // Override the ColorSpaceUtils.cmyk with a DeviceCmykCS instance that produces alpha = 0.\n  ColorSpaceUtils.cmyk = new DeviceCmykCS();\n  ColorSpaceUtils.cmyk.getRgbBuffer = (src, srcOffset, numPixels, dest, destOffset, bits, scale) => {\n    for (let i = 0; i < numPixels; i++) {\n      const idx = destOffset + i * 4;\n      dest[idx] = 10;\n      dest[idx + 1] = 20;\n      dest[idx + 2] = 30;\n      dest[idx + 3] = 0;\n    }\n  };\n  const jpegImage = new JpegImage();\n  const data = new Uint8ClampedArray(4); // one pixel RGBA: [r, g, b, alpha]\n  jpegImage._convertCmykToRgba(data);\n  if (data[3] !== 255) {\n    throw new Error(\"Expected alpha channel value to be 255, but got \" + data[3]);\n  }\n});\n",
    "i5_llama-3.3-70b-versatile": "it(\"should set the alpha channel to 255 for CMYK images when using DeviceCmykCS\", async () => {\n  const { JpegImage } = await import(\"../../src/core/jpg.js\");\n  const { ColorSpaceUtils } = await import(\"../../src/core/colorspace_utils.js\");\n  const { DeviceCmykCS } = await import(\"../../src/core/colorspace.js\");\n  // Override the ColorSpaceUtils.cmyk with a DeviceCmykCS instance that produces alpha = 0.\n  ColorSpaceUtils.cmyk = new DeviceCmykCS();\n  ColorSpaceUtils.cmyk.getRgbBuffer = (src, srcOffset, numPixels, dest, destOffset, bits, scale) => {\n    for (let i = 0; i < numPixels; i++) {\n      const idx = destOffset + i * 4;\n      dest[idx] = 10;\n      dest[idx + 1] = 20;\n      dest[idx + 2] = 30;\n      dest[idx + 3] = 0;\n    }\n  };\n  const jpegImage = new JpegImage();\n  const data = new Uint8ClampedArray(4); // one pixel RGBA: [r, g, b, alpha]\n  jpegImage._convertCmykToRgba(data);\n  if (data[3] !== 255) {\n    throw new Error(\"Expected alpha channel value to be 255, but got \" + data[3]);\n  }\n});\n"
  },
  "19717": {
    "i1_deepseek-r1-distill-llama-70b": "it(\"should preserve fillAlpha and strokeAlpha when entering soft mask mode\", async () => {\n  const { CanvasGraphics } = await import(\"../../src/display/canvas.js\");\n  const fakeInitialCtx = {\n    globalAlpha: 0.5,\n    canvas: { width: 100, height: 100 },\n    setTransform() {},\n    getTransform() {\n      return new DOMMatrix();\n    },\n  };\n  const fakeScratchCtx = {\n    globalAlpha: 0.5,\n    canvas: { width: 100, height: 100 },\n    setTransform() {},\n    getTransform() {\n      return new DOMMatrix();\n    },\n  };\n  const canvasFactory = {\n    getCanvas: (id, width, height) => ({ context: fakeScratchCtx }),\n  };\n  const filterFactory = { addFilter: () => \"\" };\n  const commonObjs = {};\n  const objs = {};\n  const options = { optionalContentConfig: null };\n  const annotationCanvasMap = {};\n  const pageColors = {};\n  const cg = new CanvasGraphics(\n    fakeInitialCtx,\n    commonObjs,\n    objs,\n    canvasFactory,\n    filterFactory,\n    options,\n    annotationCanvasMap,\n    pageColors\n  );\n  cg.current.fillAlpha = 0.3;\n  cg.current.strokeAlpha = 0.4;\n  cg.beginSMaskMode();\n  if (cg.current.fillAlpha !== 0.3) {\n    throw new Error(\"fillAlpha was overridden after entering soft mask mode\");\n  }\n  if (cg.current.strokeAlpha !== 0.4) {\n    throw new Error(\"strokeAlpha was overridden after entering soft mask mode\");\n  }\n});",
    "i1_gpt-4o": "it(\"should preserve fillAlpha and strokeAlpha when entering soft mask mode\", async () => {\n  const { CanvasGraphics } = await import(\"../../src/display/canvas.js\");\n  const fakeInitialCtx = {\n    globalAlpha: 0.5,\n    canvas: { width: 100, height: 100 },\n    setTransform() {},\n    getTransform() {\n      return new DOMMatrix();\n    },\n  };\n  const fakeScratchCtx = {\n    globalAlpha: 0.5,\n    canvas: { width: 100, height: 100 },\n    setTransform() {},\n    getTransform() {\n      return new DOMMatrix();\n    },\n  };\n  const canvasFactory = {\n    getCanvas: (id, width, height) => ({ context: fakeScratchCtx }),\n  };\n  const filterFactory = { addFilter: () => \"\" };\n  const commonObjs = {};\n  const objs = {};\n  const options = { optionalContentConfig: null };\n  const annotationCanvasMap = {};\n  const pageColors = {};\n  const cg = new CanvasGraphics(\n    fakeInitialCtx,\n    commonObjs,\n    objs,\n    canvasFactory,\n    filterFactory,\n    options,\n    annotationCanvasMap,\n    pageColors\n  );\n  cg.current.fillAlpha = 0.3;\n  cg.current.strokeAlpha = 0.4;\n  cg.beginSMaskMode();\n  if (cg.current.fillAlpha !== 0.3) {\n    throw new Error(\"fillAlpha was overridden after entering soft mask mode\");\n  }\n  if (cg.current.strokeAlpha !== 0.4) {\n    throw new Error(\"strokeAlpha was overridden after entering soft mask mode\");\n  }\n});",
    "i1_llama-3.3-70b-versatile": "it(\"should preserve fillAlpha and strokeAlpha when entering soft mask mode\", async () => {\n  const { CanvasGraphics } = await import(\"../../src/display/canvas.js\");\n  const fakeInitialCtx = {\n    globalAlpha: 0.5,\n    canvas: { width: 100, height: 100 },\n    setTransform() {},\n    getTransform() {\n      return new DOMMatrix();\n    },\n  };\n  const fakeScratchCtx = {\n    globalAlpha: 0.5,\n    canvas: { width: 100, height: 100 },\n    setTransform() {},\n    getTransform() {\n      return new DOMMatrix();\n    },\n  };\n  const canvasFactory = {\n    getCanvas: (id, width, height) => ({ context: fakeScratchCtx }),\n  };\n  const filterFactory = { addFilter: () => \"\" };\n  const commonObjs = {};\n  const objs = {};\n  const options = { optionalContentConfig: null };\n  const annotationCanvasMap = {};\n  const pageColors = {};\n  const cg = new CanvasGraphics(\n    fakeInitialCtx,\n    commonObjs,\n    objs,\n    canvasFactory,\n    filterFactory,\n    options,\n    annotationCanvasMap,\n    pageColors\n  );\n  cg.current.fillAlpha = 0.3;\n  cg.current.strokeAlpha = 0.4;\n  cg.beginSMaskMode();\n  if (cg.current.fillAlpha !== 0.3) {\n    throw new Error(\"fillAlpha was overridden after entering soft mask mode\");\n  }\n  if (cg.current.strokeAlpha !== 0.4) {\n    throw new Error(\"strokeAlpha was overridden after entering soft mask mode\");\n  }\n});",
    "i1_MOCK": "it(\"should preserve fillAlpha and strokeAlpha when entering soft mask mode\", async () => {\n  const { CanvasGraphics } = await import(\"../../src/display/canvas.js\");\n  const fakeInitialCtx = {\n    globalAlpha: 0.5,\n    canvas: { width: 100, height: 100 },\n    setTransform() {},\n    getTransform() {\n      return new DOMMatrix();\n    },\n  };\n  const fakeScratchCtx = {\n    globalAlpha: 0.5,\n    canvas: { width: 100, height: 100 },\n    setTransform() {},\n    getTransform() {\n      return new DOMMatrix();\n    },\n  };\n  const canvasFactory = {\n    getCanvas: (id, width, height) => ({ context: fakeScratchCtx }),\n  };\n  const filterFactory = { addFilter: () => \"\" };\n  const commonObjs = {};\n  const objs = {};\n  const options = { optionalContentConfig: null };\n  const annotationCanvasMap = {};\n  const pageColors = {};\n  const cg = new CanvasGraphics(\n    fakeInitialCtx,\n    commonObjs,\n    objs,\n    canvasFactory,\n    filterFactory,\n    options,\n    annotationCanvasMap,\n    pageColors\n  );\n  cg.current.fillAlpha = 0.3;\n  cg.current.strokeAlpha = 0.4;\n  cg.beginSMaskMode();\n  if (cg.current.fillAlpha !== 0.3) {\n    throw new Error(\"fillAlpha was overridden after entering soft mask mode\");\n  }\n  if (cg.current.strokeAlpha !== 0.4) {\n    throw new Error(\"strokeAlpha was overridden after entering soft mask mode\");\n  }\n});",
    "i2_deepseek-r1-distill-llama-70b": "it(\"should preserve fillAlpha and strokeAlpha when entering soft mask mode\", async () => {\n  const { CanvasGraphics } = await import(\"../../src/display/canvas.js\");\n  const fakeInitialCtx = {\n    globalAlpha: 0.5,\n    canvas: { width: 100, height: 100 },\n    setTransform() {},\n    getTransform() {\n      return new DOMMatrix();\n    },\n  };\n  const fakeScratchCtx = {\n    globalAlpha: 0.5,\n    canvas: { width: 100, height: 100 },\n    setTransform() {},\n    getTransform() {\n      return new DOMMatrix();\n    },\n  };\n  const canvasFactory = {\n    getCanvas: (id, width, height) => ({ context: fakeScratchCtx }),\n  };\n  const filterFactory = { addFilter: () => \"\" };\n  const commonObjs = {};\n  const objs = {};\n  const options = { optionalContentConfig: null };\n  const annotationCanvasMap = {};\n  const pageColors = {};\n  const cg = new CanvasGraphics(\n    fakeInitialCtx,\n    commonObjs,\n    objs,\n    canvasFactory,\n    filterFactory,\n    options,\n    annotationCanvasMap,\n    pageColors\n  );\n  cg.current.fillAlpha = 0.3;\n  cg.current.strokeAlpha = 0.4;\n  cg.beginSMaskMode();\n  if (cg.current.fillAlpha !== 0.3) {\n    throw new Error(\"fillAlpha was overridden after entering soft mask mode\");\n  }\n  if (cg.current.strokeAlpha !== 0.4) {\n    throw new Error(\"strokeAlpha was overridden after entering soft mask mode\");\n  }\n});",
    "i2_gpt-4o": "it(\"should preserve fillAlpha and strokeAlpha when entering soft mask mode\", async () => {\n  const { CanvasGraphics } = await import(\"../../src/display/canvas.js\");\n  const fakeInitialCtx = {\n    globalAlpha: 0.5,\n    canvas: { width: 100, height: 100 },\n    setTransform() {},\n    getTransform() {\n      return new DOMMatrix();\n    },\n  };\n  const fakeScratchCtx = {\n    globalAlpha: 0.5,\n    canvas: { width: 100, height: 100 },\n    setTransform() {},\n    getTransform() {\n      return new DOMMatrix();\n    },\n  };\n  const canvasFactory = {\n    getCanvas: (id, width, height) => ({ context: fakeScratchCtx }),\n  };\n  const filterFactory = { addFilter: () => \"\" };\n  const commonObjs = {};\n  const objs = {};\n  const options = { optionalContentConfig: null };\n  const annotationCanvasMap = {};\n  const pageColors = {};\n  const cg = new CanvasGraphics(\n    fakeInitialCtx,\n    commonObjs,\n    objs,\n    canvasFactory,\n    filterFactory,\n    options,\n    annotationCanvasMap,\n    pageColors\n  );\n  cg.current.fillAlpha = 0.3;\n  cg.current.strokeAlpha = 0.4;\n  cg.beginSMaskMode();\n  if (cg.current.fillAlpha !== 0.3) {\n    throw new Error(\"fillAlpha was overridden after entering soft mask mode\");\n  }\n  if (cg.current.strokeAlpha !== 0.4) {\n    throw new Error(\"strokeAlpha was overridden after entering soft mask mode\");\n  }\n});",
    "i2_llama-3.3-70b-versatile": "it(\"should preserve fillAlpha and strokeAlpha when entering soft mask mode\", async () => {\n  const { CanvasGraphics } = await import(\"../../src/display/canvas.js\");\n  const fakeInitialCtx = {\n    globalAlpha: 0.5,\n    canvas: { width: 100, height: 100 },\n    setTransform() {},\n    getTransform() {\n      return new DOMMatrix();\n    },\n  };\n  const fakeScratchCtx = {\n    globalAlpha: 0.5,\n    canvas: { width: 100, height: 100 },\n    setTransform() {},\n    getTransform() {\n      return new DOMMatrix();\n    },\n  };\n  const canvasFactory = {\n    getCanvas: (id, width, height) => ({ context: fakeScratchCtx }),\n  };\n  const filterFactory = { addFilter: () => \"\" };\n  const commonObjs = {};\n  const objs = {};\n  const options = { optionalContentConfig: null };\n  const annotationCanvasMap = {};\n  const pageColors = {};\n  const cg = new CanvasGraphics(\n    fakeInitialCtx,\n    commonObjs,\n    objs,\n    canvasFactory,\n    filterFactory,\n    options,\n    annotationCanvasMap,\n    pageColors\n  );\n  cg.current.fillAlpha = 0.3;\n  cg.current.strokeAlpha = 0.4;\n  cg.beginSMaskMode();\n  if (cg.current.fillAlpha !== 0.3) {\n    throw new Error(\"fillAlpha was overridden after entering soft mask mode\");\n  }\n  if (cg.current.strokeAlpha !== 0.4) {\n    throw new Error(\"strokeAlpha was overridden after entering soft mask mode\");\n  }\n});",
    "i3_deepseek-r1-distill-llama-70b": "it(\"should preserve fillAlpha and strokeAlpha when entering soft mask mode\", async () => {\n  const { CanvasGraphics } = await import(\"../../src/display/canvas.js\");\n  const fakeInitialCtx = {\n    globalAlpha: 0.5,\n    canvas: { width: 100, height: 100 },\n    setTransform() {},\n    getTransform() {\n      return new DOMMatrix();\n    },\n  };\n  const fakeScratchCtx = {\n    globalAlpha: 0.5,\n    canvas: { width: 100, height: 100 },\n    setTransform() {},\n    getTransform() {\n      return new DOMMatrix();\n    },\n  };\n  const canvasFactory = {\n    getCanvas: (id, width, height) => ({ context: fakeScratchCtx }),\n  };\n  const filterFactory = { addFilter: () => \"\" };\n  const commonObjs = {};\n  const objs = {};\n  const options = { optionalContentConfig: null };\n  const annotationCanvasMap = {};\n  const pageColors = {};\n  const cg = new CanvasGraphics(\n    fakeInitialCtx,\n    commonObjs,\n    objs,\n    canvasFactory,\n    filterFactory,\n    options,\n    annotationCanvasMap,\n    pageColors\n  );\n  cg.current.fillAlpha = 0.3;\n  cg.current.strokeAlpha = 0.4;\n  cg.beginSMaskMode();\n  if (cg.current.fillAlpha !== 0.3) {\n    throw new Error(\"fillAlpha was overridden after entering soft mask mode\");\n  }\n  if (cg.current.strokeAlpha !== 0.4) {\n    throw new Error(\"strokeAlpha was overridden after entering soft mask mode\");\n  }\n});",
    "i3_gpt-4o": "it(\"should preserve fillAlpha and strokeAlpha when entering soft mask mode\", async () => {\n  const { CanvasGraphics } = await import(\"../../src/display/canvas.js\");\n  const fakeInitialCtx = {\n    globalAlpha: 0.5,\n    canvas: { width: 100, height: 100 },\n    setTransform() {},\n    getTransform() {\n      return new DOMMatrix();\n    },\n  };\n  const fakeScratchCtx = {\n    globalAlpha: 0.5,\n    canvas: { width: 100, height: 100 },\n    setTransform() {},\n    getTransform() {\n      return new DOMMatrix();\n    },\n  };\n  const canvasFactory = {\n    getCanvas: (id, width, height) => ({ context: fakeScratchCtx }),\n  };\n  const filterFactory = { addFilter: () => \"\" };\n  const commonObjs = {};\n  const objs = {};\n  const options = { optionalContentConfig: null };\n  const annotationCanvasMap = {};\n  const pageColors = {};\n  const cg = new CanvasGraphics(\n    fakeInitialCtx,\n    commonObjs,\n    objs,\n    canvasFactory,\n    filterFactory,\n    options,\n    annotationCanvasMap,\n    pageColors\n  );\n  cg.current.fillAlpha = 0.3;\n  cg.current.strokeAlpha = 0.4;\n  cg.beginSMaskMode();\n  if (cg.current.fillAlpha !== 0.3) {\n    throw new Error(\"fillAlpha was overridden after entering soft mask mode\");\n  }\n  if (cg.current.strokeAlpha !== 0.4) {\n    throw new Error(\"strokeAlpha was overridden after entering soft mask mode\");\n  }\n});",
    "i3_llama-3.3-70b-versatile": "it(\"should preserve fillAlpha and strokeAlpha when entering soft mask mode\", async () => {\n  const { CanvasGraphics } = await import(\"../../src/display/canvas.js\");\n  const fakeInitialCtx = {\n    globalAlpha: 0.5,\n    canvas: { width: 100, height: 100 },\n    setTransform() {},\n    getTransform() {\n      return new DOMMatrix();\n    },\n  };\n  const fakeScratchCtx = {\n    globalAlpha: 0.5,\n    canvas: { width: 100, height: 100 },\n    setTransform() {},\n    getTransform() {\n      return new DOMMatrix();\n    },\n  };\n  const canvasFactory = {\n    getCanvas: (id, width, height) => ({ context: fakeScratchCtx }),\n  };\n  const filterFactory = { addFilter: () => \"\" };\n  const commonObjs = {};\n  const objs = {};\n  const options = { optionalContentConfig: null };\n  const annotationCanvasMap = {};\n  const pageColors = {};\n  const cg = new CanvasGraphics(\n    fakeInitialCtx,\n    commonObjs,\n    objs,\n    canvasFactory,\n    filterFactory,\n    options,\n    annotationCanvasMap,\n    pageColors\n  );\n  cg.current.fillAlpha = 0.3;\n  cg.current.strokeAlpha = 0.4;\n  cg.beginSMaskMode();\n  if (cg.current.fillAlpha !== 0.3) {\n    throw new Error(\"fillAlpha was overridden after entering soft mask mode\");\n  }\n  if (cg.current.strokeAlpha !== 0.4) {\n    throw new Error(\"strokeAlpha was overridden after entering soft mask mode\");\n  }\n});",
    "i4_deepseek-r1-distill-llama-70b": "it(\"should preserve fillAlpha and strokeAlpha when entering soft mask mode\", async () => {\n  const { CanvasGraphics } = await import(\"../../src/display/canvas.js\");\n  const fakeInitialCtx = {\n    globalAlpha: 0.5,\n    canvas: { width: 100, height: 100 },\n    setTransform() {},\n    getTransform() {\n      return new DOMMatrix();\n    },\n  };\n  const fakeScratchCtx = {\n    globalAlpha: 0.5,\n    canvas: { width: 100, height: 100 },\n    setTransform() {},\n    getTransform() {\n      return new DOMMatrix();\n    },\n  };\n  const canvasFactory = {\n    getCanvas: (id, width, height) => ({ context: fakeScratchCtx }),\n  };\n  const filterFactory = { addFilter: () => \"\" };\n  const commonObjs = {};\n  const objs = {};\n  const options = { optionalContentConfig: null };\n  const annotationCanvasMap = {};\n  const pageColors = {};\n  const cg = new CanvasGraphics(\n    fakeInitialCtx,\n    commonObjs,\n    objs,\n    canvasFactory,\n    filterFactory,\n    options,\n    annotationCanvasMap,\n    pageColors\n  );\n  cg.current.fillAlpha = 0.3;\n  cg.current.strokeAlpha = 0.4;\n  cg.beginSMaskMode();\n  if (cg.current.fillAlpha !== 0.3) {\n    throw new Error(\"fillAlpha was overridden after entering soft mask mode\");\n  }\n  if (cg.current.strokeAlpha !== 0.4) {\n    throw new Error(\"strokeAlpha was overridden after entering soft mask mode\");\n  }\n});",
    "i4_gpt-4o": "it(\"should preserve fillAlpha and strokeAlpha when entering soft mask mode\", async () => {\n  const { CanvasGraphics } = await import(\"../../src/display/canvas.js\");\n  const fakeInitialCtx = {\n    globalAlpha: 0.5,\n    canvas: { width: 100, height: 100 },\n    setTransform() {},\n    getTransform() {\n      return new DOMMatrix();\n    },\n  };\n  const fakeScratchCtx = {\n    globalAlpha: 0.5,\n    canvas: { width: 100, height: 100 },\n    setTransform() {},\n    getTransform() {\n      return new DOMMatrix();\n    },\n  };\n  const canvasFactory = {\n    getCanvas: (id, width, height) => ({ context: fakeScratchCtx }),\n  };\n  const filterFactory = { addFilter: () => \"\" };\n  const commonObjs = {};\n  const objs = {};\n  const options = { optionalContentConfig: null };\n  const annotationCanvasMap = {};\n  const pageColors = {};\n  const cg = new CanvasGraphics(\n    fakeInitialCtx,\n    commonObjs,\n    objs,\n    canvasFactory,\n    filterFactory,\n    options,\n    annotationCanvasMap,\n    pageColors\n  );\n  cg.current.fillAlpha = 0.3;\n  cg.current.strokeAlpha = 0.4;\n  cg.beginSMaskMode();\n  if (cg.current.fillAlpha !== 0.3) {\n    throw new Error(\"fillAlpha was overridden after entering soft mask mode\");\n  }\n  if (cg.current.strokeAlpha !== 0.4) {\n    throw new Error(\"strokeAlpha was overridden after entering soft mask mode\");\n  }\n});",
    "i4_llama-3.3-70b-versatile": "it(\"should preserve fillAlpha and strokeAlpha when entering soft mask mode\", async () => {\n  const { CanvasGraphics } = await import(\"../../src/display/canvas.js\");\n  const fakeInitialCtx = {\n    globalAlpha: 0.5,\n    canvas: { width: 100, height: 100 },\n    setTransform() {},\n    getTransform() {\n      return new DOMMatrix();\n    },\n  };\n  const fakeScratchCtx = {\n    globalAlpha: 0.5,\n    canvas: { width: 100, height: 100 },\n    setTransform() {},\n    getTransform() {\n      return new DOMMatrix();\n    },\n  };\n  const canvasFactory = {\n    getCanvas: (id, width, height) => ({ context: fakeScratchCtx }),\n  };\n  const filterFactory = { addFilter: () => \"\" };\n  const commonObjs = {};\n  const objs = {};\n  const options = { optionalContentConfig: null };\n  const annotationCanvasMap = {};\n  const pageColors = {};\n  const cg = new CanvasGraphics(\n    fakeInitialCtx,\n    commonObjs,\n    objs,\n    canvasFactory,\n    filterFactory,\n    options,\n    annotationCanvasMap,\n    pageColors\n  );\n  cg.current.fillAlpha = 0.3;\n  cg.current.strokeAlpha = 0.4;\n  cg.beginSMaskMode();\n  if (cg.current.fillAlpha !== 0.3) {\n    throw new Error(\"fillAlpha was overridden after entering soft mask mode\");\n  }\n  if (cg.current.strokeAlpha !== 0.4) {\n    throw new Error(\"strokeAlpha was overridden after entering soft mask mode\");\n  }\n});",
    "i5_deepseek-r1-distill-llama-70b": "it(\"should preserve fillAlpha and strokeAlpha when entering soft mask mode\", async () => {\n  const { CanvasGraphics } = await import(\"../../src/display/canvas.js\");\n  const fakeInitialCtx = {\n    globalAlpha: 0.5,\n    canvas: { width: 100, height: 100 },\n    setTransform() {},\n    getTransform() {\n      return new DOMMatrix();\n    },\n  };\n  const fakeScratchCtx = {\n    globalAlpha: 0.5,\n    canvas: { width: 100, height: 100 },\n    setTransform() {},\n    getTransform() {\n      return new DOMMatrix();\n    },\n  };\n  const canvasFactory = {\n    getCanvas: (id, width, height) => ({ context: fakeScratchCtx }),\n  };\n  const filterFactory = { addFilter: () => \"\" };\n  const commonObjs = {};\n  const objs = {};\n  const options = { optionalContentConfig: null };\n  const annotationCanvasMap = {};\n  const pageColors = {};\n  const cg = new CanvasGraphics(\n    fakeInitialCtx,\n    commonObjs,\n    objs,\n    canvasFactory,\n    filterFactory,\n    options,\n    annotationCanvasMap,\n    pageColors\n  );\n  cg.current.fillAlpha = 0.3;\n  cg.current.strokeAlpha = 0.4;\n  cg.beginSMaskMode();\n  if (cg.current.fillAlpha !== 0.3) {\n    throw new Error(\"fillAlpha was overridden after entering soft mask mode\");\n  }\n  if (cg.current.strokeAlpha !== 0.4) {\n    throw new Error(\"strokeAlpha was overridden after entering soft mask mode\");\n  }\n});",
    "i5_gpt-4o": "it(\"should preserve fillAlpha and strokeAlpha when entering soft mask mode\", async () => {\n  const { CanvasGraphics } = await import(\"../../src/display/canvas.js\");\n  const fakeInitialCtx = {\n    globalAlpha: 0.5,\n    canvas: { width: 100, height: 100 },\n    setTransform() {},\n    getTransform() {\n      return new DOMMatrix();\n    },\n  };\n  const fakeScratchCtx = {\n    globalAlpha: 0.5,\n    canvas: { width: 100, height: 100 },\n    setTransform() {},\n    getTransform() {\n      return new DOMMatrix();\n    },\n  };\n  const canvasFactory = {\n    getCanvas: (id, width, height) => ({ context: fakeScratchCtx }),\n  };\n  const filterFactory = { addFilter: () => \"\" };\n  const commonObjs = {};\n  const objs = {};\n  const options = { optionalContentConfig: null };\n  const annotationCanvasMap = {};\n  const pageColors = {};\n  const cg = new CanvasGraphics(\n    fakeInitialCtx,\n    commonObjs,\n    objs,\n    canvasFactory,\n    filterFactory,\n    options,\n    annotationCanvasMap,\n    pageColors\n  );\n  cg.current.fillAlpha = 0.3;\n  cg.current.strokeAlpha = 0.4;\n  cg.beginSMaskMode();\n  if (cg.current.fillAlpha !== 0.3) {\n    throw new Error(\"fillAlpha was overridden after entering soft mask mode\");\n  }\n  if (cg.current.strokeAlpha !== 0.4) {\n    throw new Error(\"strokeAlpha was overridden after entering soft mask mode\");\n  }\n});",
    "i5_llama-3.3-70b-versatile": "it(\"should preserve fillAlpha and strokeAlpha when entering soft mask mode\", async () => {\n  const { CanvasGraphics } = await import(\"../../src/display/canvas.js\");\n  const fakeInitialCtx = {\n    globalAlpha: 0.5,\n    canvas: { width: 100, height: 100 },\n    setTransform() {},\n    getTransform() {\n      return new DOMMatrix();\n    },\n  };\n  const fakeScratchCtx = {\n    globalAlpha: 0.5,\n    canvas: { width: 100, height: 100 },\n    setTransform() {},\n    getTransform() {\n      return new DOMMatrix();\n    },\n  };\n  const canvasFactory = {\n    getCanvas: (id, width, height) => ({ context: fakeScratchCtx }),\n  };\n  const filterFactory = { addFilter: () => \"\" };\n  const commonObjs = {};\n  const objs = {};\n  const options = { optionalContentConfig: null };\n  const annotationCanvasMap = {};\n  const pageColors = {};\n  const cg = new CanvasGraphics(\n    fakeInitialCtx,\n    commonObjs,\n    objs,\n    canvasFactory,\n    filterFactory,\n    options,\n    annotationCanvasMap,\n    pageColors\n  );\n  cg.current.fillAlpha = 0.3;\n  cg.current.strokeAlpha = 0.4;\n  cg.beginSMaskMode();\n  if (cg.current.fillAlpha !== 0.3) {\n    throw new Error(\"fillAlpha was overridden after entering soft mask mode\");\n  }\n  if (cg.current.strokeAlpha !== 0.4) {\n    throw new Error(\"strokeAlpha was overridden after entering soft mask mode\");\n  }\n});"
  },
  "19765": {
    "i1_deepseek-r1-distill-llama-70b": "it(\"should apply a margin style separator space to the radiocheckbox input via the patched toStyle call\", async () => {\n  const { XFAFactory } = await import(\"../../src/core/xfa/factory.js\");\n  const { $toHTML } = await import(\"../../src/core/xfa/symbol_utils.js\");\n  const xml = `\n    <xdp:xdp xmlns:xdp=\"http://ns.adobe.com/xdp/\">\n      <template xmlns=\"http://www.xfa.org/schema/xfa-template/3.3/\">\n        <subform>\n          <exclGroup>\n            <field name=\"TestField\">\n              <checkButton size=\"10pt\" margin=\"5px\">\n                <items>\n                  <text>Yes</text>\n                  <text>No</text>\n                </items>\n                <value>Yes</value>\n              </checkButton>\n            </field>\n          </exclGroup>\n        </subform>\n      </template>\n    </xdp:xdp>\n  `;\n  const xfa = await XFAFactory.create(xml);\n  // Resolve the field by its name.\n  const field = xfa.resolveNode(\"TestField\");\n  // The checkButton is the first (and only) item in field.items.children.\n  const checkButton = field.items.children[0];\n  // Force the margin to be set (the factory should pick it up from the XML).\n  // Render the checkButton into HTML.\n  const htmlResult = checkButton[$toHTML]();\n  // The returned HTML is a label that wraps the input.\n  const input = htmlResult.html.children[0];\n  // The style object should now include the margin from the checkButton (\"5px\")\n  const style = input.attributes.style;\n  if (!style.margin || style.margin !== \"5px\") {\n    throw new Error(\"Expected margin style '5px', but got: \" + (style.margin || \"undefined\"));\n  }\n});\n",
    "i1_gpt-4o": "it(\"should apply a margin style separator space to the radiocheckbox input via the patched toStyle call\", async () => {\n  const { XFAFactory } = await import(\"../../src/core/xfa/factory.js\");\n  const { $toHTML } = await import(\"../../src/core/xfa/symbol_utils.js\");\n  const xml = `\n    <xdp:xdp xmlns:xdp=\"http://ns.adobe.com/xdp/\">\n      <template xmlns=\"http://www.xfa.org/schema/xfa-template/3.3/\">\n        <subform>\n          <exclGroup>\n            <field name=\"TestField\">\n              <checkButton size=\"10pt\" margin=\"5px\">\n                <items>\n                  <text>Yes</text>\n                  <text>No</text>\n                </items>\n                <value>Yes</value>\n              </checkButton>\n            </field>\n          </exclGroup>\n        </subform>\n      </template>\n    </xdp:xdp>\n  `;\n  const xfa = await XFAFactory.create(xml);\n  // Resolve the field by its name.\n  const field = xfa.resolveNode(\"TestField\");\n  // The checkButton is the first (and only) item in field.items.children.\n  const checkButton = field.items.children[0];\n  // Force the margin to be set (the factory should pick it up from the XML).\n  // Render the checkButton into HTML.\n  const htmlResult = checkButton[$toHTML]();\n  // The returned HTML is a label that wraps the input.\n  const input = htmlResult.html.children[0];\n  // The style object should now include the margin from the checkButton (\"5px\")\n  const style = input.attributes.style;\n  if (!style.margin || style.margin !== \"5px\") {\n    throw new Error(\"Expected margin style '5px', but got: \" + (style.margin || \"undefined\"));\n  }\n});\n",
    "i1_llama-3.3-70b-versatile": "it(\"should apply a margin style separator space to the radiocheckbox input via the patched toStyle call\", async () => {\n  const { XFAFactory } = await import(\"../../src/core/xfa/factory.js\");\n  const { $toHTML } = await import(\"../../src/core/xfa/symbol_utils.js\");\n  const xml = `\n    <xdp:xdp xmlns:xdp=\"http://ns.adobe.com/xdp/\">\n      <template xmlns=\"http://www.xfa.org/schema/xfa-template/3.3/\">\n        <subform>\n          <exclGroup>\n            <field name=\"TestField\">\n              <checkButton size=\"10pt\" margin=\"5px\">\n                <items>\n                  <text>Yes</text>\n                  <text>No</text>\n                </items>\n                <value>Yes</value>\n              </checkButton>\n            </field>\n          </exclGroup>\n        </subform>\n      </template>\n    </xdp:xdp>\n  `;\n  const xfa = await XFAFactory.create(xml);\n  // Resolve the field by its name.\n  const field = xfa.resolveNode(\"TestField\");\n  // The checkButton is the first (and only) item in field.items.children.\n  const checkButton = field.items.children[0];\n  // Force the margin to be set (the factory should pick it up from the XML).\n  // Render the checkButton into HTML.\n  const htmlResult = checkButton[$toHTML]();\n  // The returned HTML is a label that wraps the input.\n  const input = htmlResult.html.children[0];\n  // The style object should now include the margin from the checkButton (\"5px\")\n  const style = input.attributes.style;\n  if (!style.margin || style.margin !== \"5px\") {\n    throw new Error(\"Expected margin style '5px', but got: \" + (style.margin || \"undefined\"));\n  }\n});\n",
    "i1_MOCK": "it(\"should apply a margin style separator space to the radiocheckbox input via the patched toStyle call\", async () => {\n  const { XFAFactory } = await import(\"../../src/core/xfa/factory.js\");\n  const { $toHTML } = await import(\"../../src/core/xfa/symbol_utils.js\");\n  const xml = `\n    <xdp:xdp xmlns:xdp=\"http://ns.adobe.com/xdp/\">\n      <template xmlns=\"http://www.xfa.org/schema/xfa-template/3.3/\">\n        <subform>\n          <exclGroup>\n            <field name=\"TestField\">\n              <checkButton size=\"10pt\" margin=\"5px\">\n                <items>\n                  <text>Yes</text>\n                  <text>No</text>\n                </items>\n                <value>Yes</value>\n              </checkButton>\n            </field>\n          </exclGroup>\n        </subform>\n      </template>\n    </xdp:xdp>\n  `;\n  const xfa = await XFAFactory.create(xml);\n  // Resolve the field by its name.\n  const field = xfa.resolveNode(\"TestField\");\n  // The checkButton is the first (and only) item in field.items.children.\n  const checkButton = field.items.children[0];\n  // Force the margin to be set (the factory should pick it up from the XML).\n  // Render the checkButton into HTML.\n  const htmlResult = checkButton[$toHTML]();\n  // The returned HTML is a label that wraps the input.\n  const input = htmlResult.html.children[0];\n  // The style object should now include the margin from the checkButton (\"5px\")\n  const style = input.attributes.style;\n  if (!style.margin || style.margin !== \"5px\") {\n    throw new Error(\"Expected margin style '5px', but got: \" + (style.margin || \"undefined\"));\n  }\n});\n",
    "i2_deepseek-r1-distill-llama-70b": "it(\"should apply a margin style separator space to the radiocheckbox input via the patched toStyle call\", async () => {\n  const { XFAFactory } = await import(\"../../src/core/xfa/factory.js\");\n  const { $toHTML } = await import(\"../../src/core/xfa/symbol_utils.js\");\n  const xml = `\n    <xdp:xdp xmlns:xdp=\"http://ns.adobe.com/xdp/\">\n      <template xmlns=\"http://www.xfa.org/schema/xfa-template/3.3/\">\n        <subform>\n          <exclGroup>\n            <field name=\"TestField\">\n              <checkButton size=\"10pt\" margin=\"5px\">\n                <items>\n                  <text>Yes</text>\n                  <text>No</text>\n                </items>\n                <value>Yes</value>\n              </checkButton>\n            </field>\n          </exclGroup>\n        </subform>\n      </template>\n    </xdp:xdp>\n  `;\n  const xfa = await XFAFactory.create(xml);\n  // Resolve the field by its name.\n  const field = xfa.resolveNode(\"TestField\");\n  // The checkButton is the first (and only) item in field.items.children.\n  const checkButton = field.items.children[0];\n  // Force the margin to be set (the factory should pick it up from the XML).\n  // Render the checkButton into HTML.\n  const htmlResult = checkButton[$toHTML]();\n  // The returned HTML is a label that wraps the input.\n  const input = htmlResult.html.children[0];\n  // The style object should now include the margin from the checkButton (\"5px\")\n  const style = input.attributes.style;\n  if (!style.margin || style.margin !== \"5px\") {\n    throw new Error(\"Expected margin style '5px', but got: \" + (style.margin || \"undefined\"));\n  }\n});\n",
    "i2_gpt-4o": "it(\"should apply a margin style separator space to the radiocheckbox input via the patched toStyle call\", async () => {\n  const { XFAFactory } = await import(\"../../src/core/xfa/factory.js\");\n  const { $toHTML } = await import(\"../../src/core/xfa/symbol_utils.js\");\n  const xml = `\n    <xdp:xdp xmlns:xdp=\"http://ns.adobe.com/xdp/\">\n      <template xmlns=\"http://www.xfa.org/schema/xfa-template/3.3/\">\n        <subform>\n          <exclGroup>\n            <field name=\"TestField\">\n              <checkButton size=\"10pt\" margin=\"5px\">\n                <items>\n                  <text>Yes</text>\n                  <text>No</text>\n                </items>\n                <value>Yes</value>\n              </checkButton>\n            </field>\n          </exclGroup>\n        </subform>\n      </template>\n    </xdp:xdp>\n  `;\n  const xfa = await XFAFactory.create(xml);\n  // Resolve the field by its name.\n  const field = xfa.resolveNode(\"TestField\");\n  // The checkButton is the first (and only) item in field.items.children.\n  const checkButton = field.items.children[0];\n  // Force the margin to be set (the factory should pick it up from the XML).\n  // Render the checkButton into HTML.\n  const htmlResult = checkButton[$toHTML]();\n  // The returned HTML is a label that wraps the input.\n  const input = htmlResult.html.children[0];\n  // The style object should now include the margin from the checkButton (\"5px\")\n  const style = input.attributes.style;\n  if (!style.margin || style.margin !== \"5px\") {\n    throw new Error(\"Expected margin style '5px', but got: \" + (style.margin || \"undefined\"));\n  }\n});\n",
    "i2_llama-3.3-70b-versatile": "it(\"should apply a margin style separator space to the radiocheckbox input via the patched toStyle call\", async () => {\n  const { XFAFactory } = await import(\"../../src/core/xfa/factory.js\");\n  const { $toHTML } = await import(\"../../src/core/xfa/symbol_utils.js\");\n  const xml = `\n    <xdp:xdp xmlns:xdp=\"http://ns.adobe.com/xdp/\">\n      <template xmlns=\"http://www.xfa.org/schema/xfa-template/3.3/\">\n        <subform>\n          <exclGroup>\n            <field name=\"TestField\">\n              <checkButton size=\"10pt\" margin=\"5px\">\n                <items>\n                  <text>Yes</text>\n                  <text>No</text>\n                </items>\n                <value>Yes</value>\n              </checkButton>\n            </field>\n          </exclGroup>\n        </subform>\n      </template>\n    </xdp:xdp>\n  `;\n  const xfa = await XFAFactory.create(xml);\n  // Resolve the field by its name.\n  const field = xfa.resolveNode(\"TestField\");\n  // The checkButton is the first (and only) item in field.items.children.\n  const checkButton = field.items.children[0];\n  // Force the margin to be set (the factory should pick it up from the XML).\n  // Render the checkButton into HTML.\n  const htmlResult = checkButton[$toHTML]();\n  // The returned HTML is a label that wraps the input.\n  const input = htmlResult.html.children[0];\n  // The style object should now include the margin from the checkButton (\"5px\")\n  const style = input.attributes.style;\n  if (!style.margin || style.margin !== \"5px\") {\n    throw new Error(\"Expected margin style '5px', but got: \" + (style.margin || \"undefined\"));\n  }\n});\n",
    "i3_deepseek-r1-distill-llama-70b": "it(\"should apply a margin style separator space to the radiocheckbox input via the patched toStyle call\", async () => {\n  const { XFAFactory } = await import(\"../../src/core/xfa/factory.js\");\n  const { $toHTML } = await import(\"../../src/core/xfa/symbol_utils.js\");\n  const xml = `\n    <xdp:xdp xmlns:xdp=\"http://ns.adobe.com/xdp/\">\n      <template xmlns=\"http://www.xfa.org/schema/xfa-template/3.3/\">\n        <subform>\n          <exclGroup>\n            <field name=\"TestField\">\n              <checkButton size=\"10pt\" margin=\"5px\">\n                <items>\n                  <text>Yes</text>\n                  <text>No</text>\n                </items>\n                <value>Yes</value>\n              </checkButton>\n            </field>\n          </exclGroup>\n        </subform>\n      </template>\n    </xdp:xdp>\n  `;\n  const xfa = await XFAFactory.create(xml);\n  // Resolve the field by its name.\n  const field = xfa.resolveNode(\"TestField\");\n  // The checkButton is the first (and only) item in field.items.children.\n  const checkButton = field.items.children[0];\n  // Force the margin to be set (the factory should pick it up from the XML).\n  // Render the checkButton into HTML.\n  const htmlResult = checkButton[$toHTML]();\n  // The returned HTML is a label that wraps the input.\n  const input = htmlResult.html.children[0];\n  // The style object should now include the margin from the checkButton (\"5px\")\n  const style = input.attributes.style;\n  if (!style.margin || style.margin !== \"5px\") {\n    throw new Error(\"Expected margin style '5px', but got: \" + (style.margin || \"undefined\"));\n  }\n});\n",
    "i3_gpt-4o": "it(\"should apply a margin style separator space to the radiocheckbox input via the patched toStyle call\", async () => {\n  const { XFAFactory } = await import(\"../../src/core/xfa/factory.js\");\n  const { $toHTML } = await import(\"../../src/core/xfa/symbol_utils.js\");\n  const xml = `\n    <xdp:xdp xmlns:xdp=\"http://ns.adobe.com/xdp/\">\n      <template xmlns=\"http://www.xfa.org/schema/xfa-template/3.3/\">\n        <subform>\n          <exclGroup>\n            <field name=\"TestField\">\n              <checkButton size=\"10pt\" margin=\"5px\">\n                <items>\n                  <text>Yes</text>\n                  <text>No</text>\n                </items>\n                <value>Yes</value>\n              </checkButton>\n            </field>\n          </exclGroup>\n        </subform>\n      </template>\n    </xdp:xdp>\n  `;\n  const xfa = await XFAFactory.create(xml);\n  // Resolve the field by its name.\n  const field = xfa.resolveNode(\"TestField\");\n  // The checkButton is the first (and only) item in field.items.children.\n  const checkButton = field.items.children[0];\n  // Force the margin to be set (the factory should pick it up from the XML).\n  // Render the checkButton into HTML.\n  const htmlResult = checkButton[$toHTML]();\n  // The returned HTML is a label that wraps the input.\n  const input = htmlResult.html.children[0];\n  // The style object should now include the margin from the checkButton (\"5px\")\n  const style = input.attributes.style;\n  if (!style.margin || style.margin !== \"5px\") {\n    throw new Error(\"Expected margin style '5px', but got: \" + (style.margin || \"undefined\"));\n  }\n});\n",
    "i3_llama-3.3-70b-versatile": "it(\"should apply a margin style separator space to the radiocheckbox input via the patched toStyle call\", async () => {\n  const { XFAFactory } = await import(\"../../src/core/xfa/factory.js\");\n  const { $toHTML } = await import(\"../../src/core/xfa/symbol_utils.js\");\n  const xml = `\n    <xdp:xdp xmlns:xdp=\"http://ns.adobe.com/xdp/\">\n      <template xmlns=\"http://www.xfa.org/schema/xfa-template/3.3/\">\n        <subform>\n          <exclGroup>\n            <field name=\"TestField\">\n              <checkButton size=\"10pt\" margin=\"5px\">\n                <items>\n                  <text>Yes</text>\n                  <text>No</text>\n                </items>\n                <value>Yes</value>\n              </checkButton>\n            </field>\n          </exclGroup>\n        </subform>\n      </template>\n    </xdp:xdp>\n  `;\n  const xfa = await XFAFactory.create(xml);\n  // Resolve the field by its name.\n  const field = xfa.resolveNode(\"TestField\");\n  // The checkButton is the first (and only) item in field.items.children.\n  const checkButton = field.items.children[0];\n  // Force the margin to be set (the factory should pick it up from the XML).\n  // Render the checkButton into HTML.\n  const htmlResult = checkButton[$toHTML]();\n  // The returned HTML is a label that wraps the input.\n  const input = htmlResult.html.children[0];\n  // The style object should now include the margin from the checkButton (\"5px\")\n  const style = input.attributes.style;\n  if (!style.margin || style.margin !== \"5px\") {\n    throw new Error(\"Expected margin style '5px', but got: \" + (style.margin || \"undefined\"));\n  }\n});\n",
    "i4_deepseek-r1-distill-llama-70b": "it(\"should apply a margin style separator space to the radiocheckbox input via the patched toStyle call\", async () => {\n  const { XFAFactory } = await import(\"../../src/core/xfa/factory.js\");\n  const { $toHTML } = await import(\"../../src/core/xfa/symbol_utils.js\");\n  const xml = `\n    <xdp:xdp xmlns:xdp=\"http://ns.adobe.com/xdp/\">\n      <template xmlns=\"http://www.xfa.org/schema/xfa-template/3.3/\">\n        <subform>\n          <exclGroup>\n            <field name=\"TestField\">\n              <checkButton size=\"10pt\" margin=\"5px\">\n                <items>\n                  <text>Yes</text>\n                  <text>No</text>\n                </items>\n                <value>Yes</value>\n              </checkButton>\n            </field>\n          </exclGroup>\n        </subform>\n      </template>\n    </xdp:xdp>\n  `;\n  const xfa = await XFAFactory.create(xml);\n  // Resolve the field by its name.\n  const field = xfa.resolveNode(\"TestField\");\n  // The checkButton is the first (and only) item in field.items.children.\n  const checkButton = field.items.children[0];\n  // Force the margin to be set (the factory should pick it up from the XML).\n  // Render the checkButton into HTML.\n  const htmlResult = checkButton[$toHTML]();\n  // The returned HTML is a label that wraps the input.\n  const input = htmlResult.html.children[0];\n  // The style object should now include the margin from the checkButton (\"5px\")\n  const style = input.attributes.style;\n  if (!style.margin || style.margin !== \"5px\") {\n    throw new Error(\"Expected margin style '5px', but got: \" + (style.margin || \"undefined\"));\n  }\n});\n",
    "i4_gpt-4o": "it(\"should apply a margin style separator space to the radiocheckbox input via the patched toStyle call\", async () => {\n  const { XFAFactory } = await import(\"../../src/core/xfa/factory.js\");\n  const { $toHTML } = await import(\"../../src/core/xfa/symbol_utils.js\");\n  const xml = `\n    <xdp:xdp xmlns:xdp=\"http://ns.adobe.com/xdp/\">\n      <template xmlns=\"http://www.xfa.org/schema/xfa-template/3.3/\">\n        <subform>\n          <exclGroup>\n            <field name=\"TestField\">\n              <checkButton size=\"10pt\" margin=\"5px\">\n                <items>\n                  <text>Yes</text>\n                  <text>No</text>\n                </items>\n                <value>Yes</value>\n              </checkButton>\n            </field>\n          </exclGroup>\n        </subform>\n      </template>\n    </xdp:xdp>\n  `;\n  const xfa = await XFAFactory.create(xml);\n  // Resolve the field by its name.\n  const field = xfa.resolveNode(\"TestField\");\n  // The checkButton is the first (and only) item in field.items.children.\n  const checkButton = field.items.children[0];\n  // Force the margin to be set (the factory should pick it up from the XML).\n  // Render the checkButton into HTML.\n  const htmlResult = checkButton[$toHTML]();\n  // The returned HTML is a label that wraps the input.\n  const input = htmlResult.html.children[0];\n  // The style object should now include the margin from the checkButton (\"5px\")\n  const style = input.attributes.style;\n  if (!style.margin || style.margin !== \"5px\") {\n    throw new Error(\"Expected margin style '5px', but got: \" + (style.margin || \"undefined\"));\n  }\n});\n",
    "i4_llama-3.3-70b-versatile": "it(\"should apply a margin style separator space to the radiocheckbox input via the patched toStyle call\", async () => {\n  const { XFAFactory } = await import(\"../../src/core/xfa/factory.js\");\n  const { $toHTML } = await import(\"../../src/core/xfa/symbol_utils.js\");\n  const xml = `\n    <xdp:xdp xmlns:xdp=\"http://ns.adobe.com/xdp/\">\n      <template xmlns=\"http://www.xfa.org/schema/xfa-template/3.3/\">\n        <subform>\n          <exclGroup>\n            <field name=\"TestField\">\n              <checkButton size=\"10pt\" margin=\"5px\">\n                <items>\n                  <text>Yes</text>\n                  <text>No</text>\n                </items>\n                <value>Yes</value>\n              </checkButton>\n            </field>\n          </exclGroup>\n        </subform>\n      </template>\n    </xdp:xdp>\n  `;\n  const xfa = await XFAFactory.create(xml);\n  // Resolve the field by its name.\n  const field = xfa.resolveNode(\"TestField\");\n  // The checkButton is the first (and only) item in field.items.children.\n  const checkButton = field.items.children[0];\n  // Force the margin to be set (the factory should pick it up from the XML).\n  // Render the checkButton into HTML.\n  const htmlResult = checkButton[$toHTML]();\n  // The returned HTML is a label that wraps the input.\n  const input = htmlResult.html.children[0];\n  // The style object should now include the margin from the checkButton (\"5px\")\n  const style = input.attributes.style;\n  if (!style.margin || style.margin !== \"5px\") {\n    throw new Error(\"Expected margin style '5px', but got: \" + (style.margin || \"undefined\"));\n  }\n});\n",
    "i5_deepseek-r1-distill-llama-70b": "it(\"should apply a margin style separator space to the radiocheckbox input via the patched toStyle call\", async () => {\n  const { XFAFactory } = await import(\"../../src/core/xfa/factory.js\");\n  const { $toHTML } = await import(\"../../src/core/xfa/symbol_utils.js\");\n  const xml = `\n    <xdp:xdp xmlns:xdp=\"http://ns.adobe.com/xdp/\">\n      <template xmlns=\"http://www.xfa.org/schema/xfa-template/3.3/\">\n        <subform>\n          <exclGroup>\n            <field name=\"TestField\">\n              <checkButton size=\"10pt\" margin=\"5px\">\n                <items>\n                  <text>Yes</text>\n                  <text>No</text>\n                </items>\n                <value>Yes</value>\n              </checkButton>\n            </field>\n          </exclGroup>\n        </subform>\n      </template>\n    </xdp:xdp>\n  `;\n  const xfa = await XFAFactory.create(xml);\n  // Resolve the field by its name.\n  const field = xfa.resolveNode(\"TestField\");\n  // The checkButton is the first (and only) item in field.items.children.\n  const checkButton = field.items.children[0];\n  // Force the margin to be set (the factory should pick it up from the XML).\n  // Render the checkButton into HTML.\n  const htmlResult = checkButton[$toHTML]();\n  // The returned HTML is a label that wraps the input.\n  const input = htmlResult.html.children[0];\n  // The style object should now include the margin from the checkButton (\"5px\")\n  const style = input.attributes.style;\n  if (!style.margin || style.margin !== \"5px\") {\n    throw new Error(\"Expected margin style '5px', but got: \" + (style.margin || \"undefined\"));\n  }\n});\n",
    "i5_gpt-4o": "it(\"should apply a margin style separator space to the radiocheckbox input via the patched toStyle call\", async () => {\n  const { XFAFactory } = await import(\"../../src/core/xfa/factory.js\");\n  const { $toHTML } = await import(\"../../src/core/xfa/symbol_utils.js\");\n  const xml = `\n    <xdp:xdp xmlns:xdp=\"http://ns.adobe.com/xdp/\">\n      <template xmlns=\"http://www.xfa.org/schema/xfa-template/3.3/\">\n        <subform>\n          <exclGroup>\n            <field name=\"TestField\">\n              <checkButton size=\"10pt\" margin=\"5px\">\n                <items>\n                  <text>Yes</text>\n                  <text>No</text>\n                </items>\n                <value>Yes</value>\n              </checkButton>\n            </field>\n          </exclGroup>\n        </subform>\n      </template>\n    </xdp:xdp>\n  `;\n  const xfa = await XFAFactory.create(xml);\n  // Resolve the field by its name.\n  const field = xfa.resolveNode(\"TestField\");\n  // The checkButton is the first (and only) item in field.items.children.\n  const checkButton = field.items.children[0];\n  // Force the margin to be set (the factory should pick it up from the XML).\n  // Render the checkButton into HTML.\n  const htmlResult = checkButton[$toHTML]();\n  // The returned HTML is a label that wraps the input.\n  const input = htmlResult.html.children[0];\n  // The style object should now include the margin from the checkButton (\"5px\")\n  const style = input.attributes.style;\n  if (!style.margin || style.margin !== \"5px\") {\n    throw new Error(\"Expected margin style '5px', but got: \" + (style.margin || \"undefined\"));\n  }\n});\n",
    "i5_llama-3.3-70b-versatile": "it(\"should apply a margin style separator space to the radiocheckbox input via the patched toStyle call\", async () => {\n  const { XFAFactory } = await import(\"../../src/core/xfa/factory.js\");\n  const { $toHTML } = await import(\"../../src/core/xfa/symbol_utils.js\");\n  const xml = `\n    <xdp:xdp xmlns:xdp=\"http://ns.adobe.com/xdp/\">\n      <template xmlns=\"http://www.xfa.org/schema/xfa-template/3.3/\">\n        <subform>\n          <exclGroup>\n            <field name=\"TestField\">\n              <checkButton size=\"10pt\" margin=\"5px\">\n                <items>\n                  <text>Yes</text>\n                  <text>No</text>\n                </items>\n                <value>Yes</value>\n              </checkButton>\n            </field>\n          </exclGroup>\n        </subform>\n      </template>\n    </xdp:xdp>\n  `;\n  const xfa = await XFAFactory.create(xml);\n  // Resolve the field by its name.\n  const field = xfa.resolveNode(\"TestField\");\n  // The checkButton is the first (and only) item in field.items.children.\n  const checkButton = field.items.children[0];\n  // Force the margin to be set (the factory should pick it up from the XML).\n  // Render the checkButton into HTML.\n  const htmlResult = checkButton[$toHTML]();\n  // The returned HTML is a label that wraps the input.\n  const input = htmlResult.html.children[0];\n  // The style object should now include the margin from the checkButton (\"5px\")\n  const style = input.attributes.style;\n  if (!style.margin || style.margin !== \"5px\") {\n    throw new Error(\"Expected margin style '5px', but got: \" + (style.margin || \"undefined\"));\n  }\n});\n"
  },
  "19797": {
    "i1_deepseek-r1-distill-llama-70b": "it(\"should handle touch events without crashing when touchMoveAC is null\", async () => {\n  const { PDFWorker } = await import(\"../../src/display/api.js\");\n  const { TouchManager } = await import(\"../../src/display/touch_manager.js\");\n\n  // Setup a simple PDF document for testing\n  const pdfDocument = await getDocument({\n    data: new Uint8Array(),\n    fingerprint: \"test-pdf\",\n    length: 0,\n  });\n\n  // Create a container and viewer for the test\n  const container = {\n    addEventListener: () => {},\n    removeEventListener: () => {},\n  };\n  const viewer = {\n    get pageView() {\n      return {\n        get viewport() {\n          return { width: 100, height: 100 };\n        },\n      };\n    },\n  };\n\n  // Create TouchManager instance\n  const touchManager = new TouchManager({\n    container,\n    signal: new AbortController().signal,\n  });\n\n  // Test touch events that could trigger the error\n  const done = () => {\n    return new Promise(resolve => {\n      const touchStart = new Event(\"touchstart\");\n      const touchMove = new Event(\"touchmove\");\n      const touchEnd = new Event(\"touchend\");\n\n      touchManager.#onTouchStart(touchStart);\n      touchManager.#onTouchMove(touchMove);\n\n      // Ensure #touchMoveAC is null when handling touchend\n      const originalTouchMoveAC = touchManager.#touchMoveAC;\n      touchManager.#touchMoveAC = null;\n\n      const handleTouchEnd = () => {\n        touchManager.#onTouchEnd(touchEnd);\n        resolve();\n      };\n\n      touchManager.#container.addEventListener(\"touchend\", handleTouchEnd, { once: true });\n      touchManager.#container.dispatchEvent(touchEnd);\n    });\n  };\n\n  // Verify that no error is thrown during touch handling\n  await expect(done()).resolves.not.toThrow();\n});",
    "i1_gpt-4o": "it(\"should handle touch end without errors when touchMoveAC is null\", async () => {\n  const { TouchManager } = await import(\"../../src/display/touch_manager.js\");\n  const container = document.createElement(\"div\");\n  const touchManager = new TouchManager({ container, signal: new AbortController().signal });\n\n  // Simulate touchstart to initialize touchMoveAC\n  const touchStartEvent = new TouchEvent(\"touchstart\", { touches: [new Touch({ identifier: 1, target: container })] });\n  container.dispatchEvent(touchStartEvent);\n\n  // Manually set #touchMoveAC to null to simulate the bug\n  touchManager.#touchMoveAC = null;\n\n  // Simulate touchend event\n  const touchEndEvent = new TouchEvent(\"touchend\", { touches: [] });\n  let errorOccurred = false;\n  try {\n    container.dispatchEvent(touchEndEvent);\n  } catch (error) {\n    errorOccurred = true;\n  }\n\n  expect(errorOccurred).toBe(false);\n});",
    "i1_llama-3.3-70b-versatile": "it(\"should not throw TypeError when updating mode and drawing\", async () => {\n  const { AnnotationEditorUIManager, TouchManager } = await import(\"../../src/display/editor/tools.js\");\n  const { PDFDocument, PDFPage } = await import(\"../../src/core/document.js\");\n  const pdfDocument = await PDFDocument.load(await (await import(\"../../src/display/api.js\")).build());\n  const pdfPage = pdfDocument.getPage(1);\n  const container = { addEventListener: () => {}, removeEventListener: () => {} };\n  const viewer = { getPages: () => [pdfPage] };\n  const annotationEditorUIManager = new AnnotationEditorUIManager(container, viewer, null, null, null, pdfDocument, null, null, false, false, false, null, null, true);\n  const touchManager = new TouchManager({ container, signal: new AbortController().signal });\n  annotationEditorUIManager.updateMode(AnnotationEditorType.INK);\n  touchManager.#onTouchEnd({ touches: [] });\n  expect(() => annotationEditorUIManager.updateMode(AnnotationEditorType.NONE)).not.toThrow(TypeError);\n});",
    "i2_deepseek-r1-distill-llama-70b": "it(\"should not throw when aborting null touchMoveAC\", async () => {\n  const { PDFDocument, PDFViewer } = await import(\"../../web/pdf_viewer.js\");\n  const { TouchManager } = await import(\"../../src/display/touch_manager.js\");\n\n  const container = document.createElement(\"div\");\n  const viewer = new PDFViewer({\n    container,\n    defaultZoom: \"page-width\",\n  });\n\n  await viewer.setDocument(new PDFDocument({ url: \"/blank.pdf\" }));\n  const touchManager = new TouchManager({\n    container,\n    isPinchingDisabled: false,\n    isPinchingStopped: () => false,\n    onPinchStart: () => {},\n    onPinching: () => {},\n    onPinchEnd: () => {},\n    signal: new AbortController().signal,\n  });\n\n  const error = await new Promise(resolve => {\n    const originalConsoleError = console.error;\n    console.error = (...args) => {\n      if (args[0].includes(\"null is not an object (evaluating 'this.#touchMoveAC.abort')\")) {\n        resolve(args[0]);\n      }\n    };\n\n    touchManager.#touchMoveAC = null;\n    touchManager.#onTouchEnd({ touches: [] });\n\n    console.error = originalConsoleError;\n  });\n\n  expect(error).not.toMatch(\"null is not an object\");\n});",
    "i2_gpt-4o": "it(\"should not throw TypeError when lifting finger after drawing\", async () => {\n  const { TouchManager } = await import(\"../../src/display/touch_manager.js\");\n  const container = document.createElement(\"div\");\n  const touchManager = new TouchManager({\n    container,\n    signal: new AbortController().signal,\n  });\n\n  let errorThrown = false;\n  try {\n    const touchEndEvent = new TouchEvent(\"touchend\", { touches: [] });\n    container.dispatchEvent(touchEndEvent);\n  } catch (error) {\n    if (error instanceof TypeError) {\n      errorThrown = true;\n    }\n  }\n\n  expect(errorThrown).toBe(false);\n});",
    "i2_llama-3.3-70b-versatile": "it(\"should not throw an error when switching modes after drawing\", async () => {\n  const { AnnotationEditorUIManager, TouchManager } = await import(\"../../src/display/editor/tools.js\");\n  const { OutputScale } = await import(\"../../src/display/display_utils.js\");\n\n  const container = { addEventListener: () => {} };\n  const viewer = {};\n  const altTextManager = {};\n  const signatureManager = {};\n  const eventBus = { _on: () => {} };\n  const pdfDocument = { annotationStorage: {} };\n  const pageColors = {};\n  const highlightColors = {};\n  const enableHighlightFloatingButton = false;\n  const enableUpdatedAddImage = false;\n  const enableNewAltTextWhenAddingImage = false;\n  const mlManager = {};\n  const editorUndoBar = {};\n  const supportsPinchToZoom = true;\n\n  const annotationEditorUIManager = new AnnotationEditorUIManager(\n    container,\n    viewer,\n    altTextManager,\n    signatureManager,\n    eventBus,\n    pdfDocument,\n    pageColors,\n    highlightColors,\n    enableHighlightFloatingButton,\n    enableUpdatedAddImage,\n    enableNewAltTextWhenAddingImage,\n    mlManager,\n    editorUndoBar,\n    supportsPinchToZoom\n  );\n\n  const touchManager = new TouchManager({\n    container,\n    isPinchingDisabled: null,\n    isPinchingStopped: null,\n    onPinchStart: null,\n    onPinching: null,\n    onPinchEnd: null,\n    signal: null,\n  });\n\n  annotationEditorUIManager.updateMode(1); // switch to drawing mode\n  touchManager.#touchMoveAC = { abort: () => {} };\n  touchManager.#onTouchEnd({ touches: [] });\n\n  annotationEditorUIManager.updateMode(0); // switch back to none mode\n\n  expect(() => touchManager.#onTouchEnd({ touches: [] })).not.toThrow();\n});",
    "i3_deepseek-r1-distill-llama-70b": "it(\"should handle null touchMoveAC without throwing error\", async () => {\n  const { TouchManager } = await import(\"../../src/display/touch_manager.js\");\n  const container = document.createElement(\"div\");\n\n  // Initialize TouchManager\n  const touchManager = new TouchManager({\n    container,\n    signal: new AbortController().signal,\n  });\n\n  // Simulate touch events that would set up touchMoveAC\n  const touchStartEvt = new TouchEvent(\"touchstart\", {\n    touches: [new Touch({ identifier: 1, target: container }), new Touch({ identifier: 2, target: container })],\n  });\n  container.dispatchEvent(touchStartEvt);\n\n  // Simulate touch move to set touchMoveAC\n  const touchMoveEvt = new TouchEvent(\"touchmove\", {\n    touches: [new Touch({ identifier: 1, target: container }), new Touch({ identifier: 2, target: container })],\n  });\n  container.dispatchEvent(touchMoveEvt);\n\n  // Nullify touchMoveAC to simulate the bug scenario\n  touchManager.#touchMoveAC = null;\n\n  // Test that aborting a null touchMoveAC doesn't throw\n  try {\n    touchManager.#touchMoveAC.abort();\n  } catch (error) {\n    throw new Error(\"Expected no error when aborting null touchMoveAC\");\n  }\n\n  // Cleanup\n  touchManager.destroy();\n});",
    "i3_gpt-4o": "it(\"should handle touch end without errors when touchMoveAC is null\", async () => {\n  const { TouchManager } = await import(\"../../src/display/touch_manager.js\");\n  const container = document.createElement(\"div\");\n  const touchManager = new TouchManager({\n    container,\n    signal: new AbortController().signal,\n  });\n\n  const touchEndEvent = new TouchEvent(\"touchend\", {\n    touches: [],\n    changedTouches: [new Touch({ identifier: 1, target: container })],\n  });\n\n  let errorOccurred = false;\n  try {\n    container.dispatchEvent(touchEndEvent);\n  } catch (error) {\n    errorOccurred = true;\n  }\n\n  expect(errorOccurred).toBe(false);\n});",
    "i3_llama-3.3-70b-versatile": "it(\"should prevent null pointer exception when thistouchMoveAC is null\", async () => {\n  const { TouchManager } = await import(\"../../src/display/touch_manager.js\");\n  const touchManager = new TouchManager({\n    container: document.createElement(\"div\"),\n    isPinchingDisabled: () => false,\n    isPinchingStopped: () => false,\n    onPinchStart: () => {},\n    onPinching: () => {},\n    onPinchEnd: () => {},\n    signal: new AbortController().signal,\n  });\n  touchManager.#touchMoveAC = null;\n  expect(() => touchManager.#onTouchEnd({ touches: [] })).not.toThrow();\n});",
    "i4_deepseek-r1-distill-llama-70b": "it(\"should handle touch events without error\", async () => {\n  const { TouchManager } = await import(\"../../src/display/touch_manager.js\");\n  const container = document.createElement(\"div\");\n  const touchManager = new TouchManager({\n    container,\n    signal: new AbortController().signal,\n  });\n\n  // Simulate touch events\n  const touchStartEvent = new TouchEvent(\"touchstart\", {\n    touches: [new Touch({ identifier: 1, target: container }), new Touch({ identifier: 2, target: container })],\n    touchType: \"direct\",\n  });\n\n  const touchMoveEvent = new TouchEvent(\"touchmove\", {\n    touches: [new Touch({ identifier: 1, target: container }), new Touch({ identifier: 2, target: container })],\n    touchType: \"direct\",\n  });\n\n  const touchEndEvent = new TouchEvent(\"touchend\", {\n    touches: [new Touch({ identifier: 1, target: container }), new Touch({ identifier: 2, target: container })],\n    touchType: \"direct\",\n  });\n\n  // Handle events\n  await Promise.resolve();\n  container.dispatchEvent(touchStartEvent);\n  await Promise.resolve();\n  container.dispatchEvent(touchMoveEvent);\n  await Promise.resolve();\n  container.dispatchEvent(touchEndEvent);\n\n  // Check for errors\n  expect(() => {\n    touchManager.destroy();\n  }).not.toThrow();\n});",
    "i4_gpt-4o": "it(\"should not throw TypeError when touch ends\", async () => {\n  const { TouchManager } = await import(\"../../src/display/touch_manager.js\");\n  const container = document.createElement(\"div\");\n  const touchManager = new TouchManager({\n    container,\n    signal: new AbortController().signal,\n  });\n\n  const touchStartEvent = new TouchEvent(\"touchstart\", {\n    touches: [\n      new Touch({ identifier: 1, target: container, screenX: 0, screenY: 0 }),\n      new Touch({ identifier: 2, target: container, screenX: 10, screenY: 10 }),\n    ],\n  });\n\n  const touchEndEvent = new TouchEvent(\"touchend\", {\n    touches: [new Touch({ identifier: 1, target: container, screenX: 0, screenY: 0 })],\n  });\n\n  container.dispatchEvent(touchStartEvent);\n  let errorOccurred = false;\n  try {\n    container.dispatchEvent(touchEndEvent);\n  } catch (e) {\n    errorOccurred = true;\n  }\n\n  expect(errorOccurred).toBe(false);\n});",
    "i4_llama-3.3-70b-versatile": "it(\"should prevent null pointer exception when touchMoveAC is null\", async () => {\n  const { TouchManager } = await import(\"../../src/display/touch_manager.js\");\n  const touchManager = new TouchManager({\n    container: { addEventListener: () => {} },\n    signal: new AbortController().signal,\n  });\n  touchManager.#touchMoveAC = null;\n  expect(() => touchManager.#onTouchEnd({ touches: [] })).not.toThrow();\n});",
    "i5_deepseek-r1-distill-llama-70b": "it(\"should handle touch events without throwing null error in touchMoveAC\", async () => {\n  const { PDFDocument } = await import(\"../../src/core/document.js\");\n  const { PDFPage } = await import(\"../../src/core/document.js\");\n  const { AnnotationEditorUIManager } = await import(\"../../src/display/editor/tools.js\");\n  const { TouchManager } = await import(\"../../src/display/touch_manager.js\");\n  const { TestPdfsServer } = await import(\"./test_utils.js\");\n\n  // Setup the test PDF\n  const server = new TestPdfsServer();\n  const blankPdf = await server.loadPDF(\"blank.pdf\");\n  const page = await blankPdf.getPage(1);\n\n  // Initialize annotation editor and touch manager\n  const annotationEditor = new AnnotationEditorUIManager();\n  const touchManager = new TouchManager(page.div, {\n    pinchZoomEnabled: true,\n    touchStartThreshold: 0,\n  });\n\n  // Set up the annotation mode\n  annotationEditor.switchMode(AnnotationEditorType.FREE_HAND);\n\n  try {\n    // Simulate touch events to draw\n    const touchStartEvt = new TouchEvent(\"touchstart\", {\n      touches: [{ target: page.div, clientX: 100, clientY: 100 }],\n    });\n    const touchMoveEvt = new TouchEvent(\"touchmove\", {\n      touches: [{ target: page.div, clientX: 150, clientY: 150 }],\n    });\n    const touchEndEvt = new TouchEvent(\"touchend\", {});\n\n    page.div.dispatchEvent(touchStartEvt);\n    page.div.dispatchEvent(touchMoveEvt);\n    page.div.dispatchEvent(touchEndEvt);\n\n    // If no error was thrown, the test passes\n    expect(true).toBe(true);\n  } catch (error) {\n    // If an error was thrown, the test fails\n    expect(error).not.toBeInstanceOf(Error);\n  }\n});",
    "i5_gpt-4o": "it(\"should not throw TypeError when drawing annotations\", async () => {\n  const { TouchManager } = await import(\"../../src/display/touch_manager.js\");\n  const touchManager = new TouchManager();\n\n  let errorThrown = false;\n  try {\n    touchManager.#touchMoveAC = null; // Simulate the condition where #touchMoveAC is null\n    touchManager.#onTouchEnd({ touches: [{}] }); // Simulate a touch end event\n  } catch (error) {\n    if (error instanceof TypeError) {\n      errorThrown = true;\n    }\n  }\n\n  expect(errorThrown).toBe(false);\n});",
    "i5_llama-3.3-70b-versatile": "it(\"should not throw TypeError when drawing annotations\", async () => {\n  const { PDFDocument, PDFPageProxy } = await import(\"../../src/display/api.js\");\n  const { AnnotationEditorUIManager } = await import(\"../../src/display/editor/tools.js\");\n  const { TouchManager } = await import(\"../../src/display/touch_manager.js\");\n\n  const pdfDocument = await PDFDocument.load(await (await import(\"../../src/display/node_utils.js\")).fetchData(\"path_to_your_pdf_file.pdf\"));\n  const pdfPage = pdfDocument.getPage(1);\n  const pageProxy = new PDFPageProxy(pdfPage);\n  const annotationEditor = new AnnotationEditorUIManager(pageProxy);\n  const touchManager = new TouchManager();\n\n  let error = null;\n  try {\n    annotationEditor.setMode(\"DRAW\");\n    touchManager.onTouchStart({ touches: [{ clientX: 10, clientY: 10 }] });\n    touchManager.onTouchMove({ touches: [{ clientX: 20, clientY: 20 }] });\n    touchManager.onTouchEnd({ touches: [] });\n  } catch (e) {\n    error = e;\n  }\n\n  expect(error).toBeNull();\n});"
  },
  "19803": {
    "i1_deepseek-r1-distill-llama-70b": "it(\"should detect circular references in Form XObjects\", async () => {\n  const xref = new XRefMock();\n  const form1 = new Dict({\n    Type: new Name(\"Form\"),\n    Ref: new Ref(2, 0),\n    BBox: [0, 0, 1, 1],\n    Matrix: [1, 0, 0, 1, 0, 0],\n  });\n  const form2 = new Dict({\n    Type: new Name(\"Form\"),\n    Ref: new Ref(1, 0),\n    BBox: [0, 0, 1, 1],\n    Matrix: [1, 0, 0, 1, 0, 0],\n  });\n  xref.addRef(form1, 1, 0);\n  xref.addRef(form2, 2, 0);\n\n  const evaluator = new PartialEvaluator({\n    xref,\n    handler: { send: () => {} },\n    pageIndex: 0,\n    idFactory: createIdFactory(),\n    fontCache: new Map(),\n    builtInCMapCache: new Map(),\n    standardFontDataCache: new Map(),\n    globalColorSpaceCache: new Map(),\n    globalImageCache: new Map(),\n    systemFontCache: new Map(),\n    options: {},\n  });\n\n  const stream = new StringStream(\"q\\n\");\n  const task = new WorkerTask();\n\n  await expect(\n    evaluator.getOperatorList({\n      stream,\n      task,\n      resources: new Dict(),\n      operatorList: new OperatorList(),\n      initialState: new EvalState(),\n    })\n  ).rejects.toThrow(\"getOperatorList - ignoring circular reference\");\n});",
    "i1_gpt-4o": "it(\"should handle circular references in Form XObjects without endless loop\", async () => {\n  const { PDFDocument } = await import(\"../../src/core/document.js\");\n  const { Ref } = await import(\"../../src/core/primitives.js\");\n  const { WorkerTask } = await import(\"../../src/core/worker.js\");\n  const { buildGetDocumentParams } = await import(\"./test_utils.js\");\n\n  const loadingTask = PDFDocument.load(buildGetDocumentParams(\"evil_xobjects.pdf\"));\n  const pdfDocument = await loadingTask.promise;\n  const page = await pdfDocument.getPage(1);\n\n  const task = new WorkerTask(\"test\");\n  const operatorList = await page.getOperatorList({\n    handler: null,\n    sink: { enqueue: () => {}, ready: Promise.resolve(), desiredSize: 1 },\n    task,\n    intent: RenderingIntentFlag.DISPLAY,\n  });\n\n  expect(operatorList.length).toBeGreaterThan(0);\n});",
    "i1_llama-3.3-70b-versatile": "it(\"should prevent circular references in Form XObjects\", async () => {\n  const pdfData = await fetch('https://github.com/user-attachments/files/19691094/evil_xobjects.pdf').then(response => response.arrayBuffer());\n  const pdf = await import(\"../../src/display/api.js\");\n  const { PDFDocument } = pdf;\n  const doc = await PDFDocument.load(pdfData);\n  const pages = await doc.getPages();\n  const page = pages[0];\n  const renderedPage = await page.render({ intent: 'display' });\n  expect(renderedPage).not.toBeNull();\n});",
    "i2_deepseek-r1-distill-llama-70b": "it(\"should handle circular Form XObject references without infinite loop\", async () => {\n  const { PDFDocument } = await import(\"../../web/pdf_document.js\");\n  const { PDFPage } = await import(\"../../web/pdf_page.js\");\n\n  const pdfData = new Uint8Array(await evil_xobjects.pdf);\n  const pdfDoc = await PDFDocument.load(pdfData);\n  const page = await pdfDoc.getPage(1);\n\n  const renderContainer = {\n    width: LETTER_SIZE_MEDIABOX[2],\n    height: LETTER_SIZE_MEDIABOX[3],\n  };\n\n  await page.render({\n    viewport: page.getViewport(renderContainer),\n    annotationMode: \"disabled\",\n  });\n\n  expect(true).toBeTruthy();\n}, 10000);",
    "i2_gpt-4o": "it(\"should handle circular references in Form XObjects without endless loop\", async () => {\n  const { PDFDocument } = await import(\"../../src/core/document.js\");\n  const { Ref } = await import(\"../../src/core/primitives.js\");\n  const { StringStream } = await import(\"../../src/core/stream.js\");\n  const { PartialEvaluator } = await import(\"../../src/core/evaluator.js\");\n  const { OperatorList } = await import(\"../../src/core/operator_list.js\");\n  const { WorkerTask } = await import(\"../../src/core/worker.js\");\n\n  const pdfManager = {\n    evaluatorOptions: {},\n    ensureDoc: () => Promise.resolve({}),\n  };\n  const xref = {\n    fetch: ref => {\n      if (ref.num === 1) {\n        return new StringStream(\"q 1 0 0 1 0 0 cm /XObject1 Do Q\");\n      }\n      if (ref.num === 2) {\n        return new StringStream(\"q 1 0 0 1 0 0 cm /XObject2 Do Q\");\n      }\n      return null;\n    },\n  };\n  const pageIndex = 0;\n  const pageDict = {\n    get: key => {\n      if (key === \"Resources\") {\n        return {\n          get: resKey => {\n            if (resKey === \"XObject\") {\n              return {\n                getRaw: name => {\n                  if (name === \"XObject1\") return new Ref(1, 0);\n                  if (name === \"XObject2\") return new Ref(2, 0);\n                  return null;\n                },\n              };\n            }\n            return null;\n          },\n        };\n      }\n      return null;\n    },\n  };\n  const page = new PDFDocument({\n    pdfManager,\n    xref,\n    pageIndex,\n    pageDict,\n    ref: new Ref(3, 0),\n    globalIdFactory: class {},\n  });\n\n  const task = new WorkerTask(\"test\");\n  const operatorList = new OperatorList();\n  const evaluator = new PartialEvaluator({\n    xref,\n    handler: null,\n    pageIndex,\n    idFactory: null,\n    fontCache: null,\n    builtInCMapCache: null,\n    standardFontDataCache: null,\n    globalColorSpaceCache: null,\n    globalImageCache: null,\n    systemFontCache: null,\n    options: {},\n  });\n\n  let errorCaught = false;\n  try {\n    await page.getOperatorList({\n      handler: null,\n      sink: operatorList,\n      task,\n      intent: 0,\n    });\n  } catch (error) {\n    errorCaught = true;\n  }\n\n  expect(errorCaught).toBe(true);\n});",
    "i2_llama-3.3-70b-versatile": "it(\"should throw an error when encountering a circular reference in Form XObjects\", async () => {\n  const { PDFDocument } = await import(\"../../src/display/api.js\");\n  const pdfData = await import(\"../../web/annotation_layer_builder.js\");\n  const pdfBytes = await fetch('https://github.com/user-attachments/files/19691094/evil_xobjects.pdf').then(res => res.arrayBuffer());\n  const pdf = await PDFDocument.load(pdfBytes);\n  const page = await pdf.getPage(1);\n  await expect(page.getTextContent()).rejects.toThrowError('getOperatorList - ignoring circular reference');\n});",
    "i3_gpt-4o": "it(\"should handle circular references in Form XObjects without endless loop\", async () => {\n  const { PDFDocument } = await import(\"../../src/core/document.js\");\n  const { buildGetDocumentParams } = await import(\"./test_utils.js\");\n  const pdfPath = \"pdfs/evil_xobjects.pdf\";\n  const loadingTask = PDFDocument.load(buildGetDocumentParams(pdfPath));\n  const pdfDocument = await loadingTask.promise;\n  const page = await pdfDocument.getPage(0);\n  const operatorList = await page.getOperatorList({\n    intent: RenderingIntentFlag.DISPLAY,\n  });\n  expect(operatorList).toBeDefined();\n  expect(operatorList.length).toBeGreaterThan(0);\n});",
    "i3_llama-3.3-70b-versatile": "it(\"should handle circular references in FormXObject\", async () => {\n  const { annotation, annotationGlobals, pdfManager } = await import(\"../../src/core/annotation.js\");\n  const { PartialEvaluator, getStandardFontDataFactory, createIdFactory } = await import(\"../../src/core/evaluator.js\");\n  const { Dict, Name, Ref, RefSetCache } = await import(\"../../src/core/primitives.js\");\n  const { CMAP_URL, DefaultCMapReaderFactory, DefaultStandardFontDataFactory, STANDARD_FONT_DATA_URL, XRefMock } = await import(\"./test_utils.js\");\n  const { AnnotationBorderStyleType, AnnotationEditorType, AnnotationFieldFlag, AnnotationFlag, AnnotationType, DrawOPS, OPS, RenderingIntentFlag, stringToBytes, stringToUTF8String } = await import(\"../../src/shared/util.js\");\n  const { getQuadPoints } = await import(\"../../src/core/annotation.js\");\n  const { AnnotationBorderStyle } = await import(\"../../src/core/annotation.js\");\n  const { getStandardFontDataFactory } = await import(\"../../src/core/core_utils.js\");\n  const { getStandardFontDataFactory } = await import(\"../../src/core/core_utils.js\");\n  const { createIdFactory } = await import(\"../../src/core/core_utils.js\");\n  const { getStandardFontDataFactory } = await import(\"../../src/core/core_utils.js\");\n  const { getStandardFontDataFactory } = await import(\"../../src/core/core_utils.js\");\n  const { getStandardFontDataFactory } = await import(\"../../src/core/core_utils.js\");\n  const { getStandardFontDataFactory } = await import(\"../../src/core/core_utils.js\");\n  const { getStandardFontDataFactory } = await import(\"../../src/core/core_utils.js\");\n  const { getStandardFontDataFactory } = await import(\"../../src/core/core_utils.js\");\n  const { getStandardFontDataFactory } = await import(\"../../src/core/core_utils.js\");\n  const { getStandardFontDataFactory } = await import(\"../../src/core/core_utils.js\");\n  const { getStandardFontDataFactory } = await import(\"../../src/core/core_utils.js\");\n  const { getStandardFontDataFactory } = await import(\"../../src/core/core_utils.js\");\n  const { getStandardFontDataFactory } = await import(\"../../src/core/core_utils.js\");\n  const { getStandardFontDataFactory } = await import(\"../../src/core/core_utils.js\");\n  const { getStandardFontDataFactory } = await import(\"../../src/core/core_utils.js\");\n  const { getStandardFontDataFactory } = await import(\"../../src/core/core_utils.js\");\n  const { getStandardFontDataFactory } = await import(\"../../src/core/core_utils.js\");\n  const { getStandardFontDataFactory } = await import(\"../../src/core/core_utils.js\");\n  const { getStandardFontDataFactory } = await import(\"../../src/core/core_utils.js\");\n  const { getStandardFontDataFactory } = await import(\"../../src/core/core_utils.js\");\n  const { getStandardFontDataFactory } = await import(\"../../src/core/core_utils.js\");\n  const { getStandardFontDataFactory } = await import(\"../../src/core/core_utils.js\");\n  const { getStandardFontDataFactory } = await import(\"../../src/core/core_utils.js\");\n  const { getStandardFontDataFactory } = await import(\"../../src/core/core_utils.js\");\n  const { getStandardFontDataFactory } = await import(\"../../src/core/core_utils.js\");\n  const { getStandard",
    "i4_gpt-4o": "it(\"should handle circular references in Form XObjects without endless loop\", async () => {\n  const { PDFDocument } = await import(\"../../src/core/document.js\");\n  const { Page } = await import(\"../../src/core/document.js\");\n  const { Ref } = await import(\"../../src/core/primitives.js\");\n  const { XRef } = await import(\"../../src/core/xref.js\");\n  const { BaseStream } = await import(\"../../src/core/base_stream.js\");\n\n  const xref = new XRef(null, null);\n  const pageDict = new Map();\n  const pageIndex = 0;\n  const ref = new Ref(1, 0);\n  const pdfManager = {\n    ensure: async (obj, prop) => obj[prop],\n    ensureDoc: async (prop) => null,\n    ensureCatalog: async (prop) => null,\n    evaluatorOptions: {},\n  };\n\n  const page = new Page({\n    pdfManager,\n    xref,\n    pageIndex,\n    pageDict,\n    ref,\n    globalIdFactory: class {},\n    fontCache: new Map(),\n    builtInCMapCache: new Map(),\n    standardFontDataCache: new Map(),\n    globalColorSpaceCache: new Map(),\n    globalImageCache: new Map(),\n    systemFontCache: new Map(),\n    nonBlendModesSet: new Set(),\n    xfaFactory: null,\n  });\n\n  const contentStream = new BaseStream();\n  page.getContentStream = async () => contentStream;\n\n  const operatorList = await page.getOperatorList({\n    handler: null,\n    sink: null,\n    task: { name: \"test\", ensureNotTerminated: () => {} },\n    intent: 0,\n  });\n\n  const expected = { length: 0 };\n  const actual = { length: operatorList.length };\n  expect(actual).toEqual(expected);\n});",
    "i4_llama-3.3-70b-versatile": "it(\"should fix the bug with circular references in Form XObjects\", async () => {\n  const { AnnotationFactory, Annotation, AnnotationBorderStyle, AnnotationWidget, ButtonWidgetAnnotation, ChoiceWidgetAnnotation, SignatureWidgetAnnotation, TextAnnotation, LinkAnnotation, PopupAnnotation, FreeTextAnnotation, LineAnnotation, SquareAnnotation, CircleAnnotation, PolylineAnnotation, InkAnnotation, HighlightAnnotation, UnderlineAnnotation, SquigglyAnnotation, StrikeOutAnnotation, StampAnnotation, FileAttachmentAnnotation } = await import(\"../../src/core/annotation.js\");\n  const { PartialEvaluator } = await import(\"../../src/core/evaluator.js\");\n  const { Page } = await import(\"../../src/core/document.js\");\n  const { Dict, Ref, RefSet, RefSetCache } = await import(\"../../src/core/primitives.js\");\n  const { getInheritableProperty, getNewAnnotationsMap, getFontNameToFileMap, getStandardFontName, getSerifFonts, getSymbolsFonts } = await import(\"../../src/core/core_utils.js\");\n  const { getFontSubstitution } = await import(\"../../src/core/font_substitutions.js\");\n  const { getMetrics } = await import(\"../../src/core/metrics.js\");\n  const { getUnicodeForGlyph } = await import(\"../../src/core/unicode.js\");\n  const { getGlyphsUnicode } = await import(\"../../src/core/glyphlist.js\");\n  const { getEncoding } = await import(\"../../src/core/encodings.js\");\n  const { getStandardFontName } = await import(\"../../src/core/standard_fonts.js\");\n  const { getSymbolsFonts } = await import(\"../../src/core/symbols.js\");\n  const { getSerifFonts } = await import(\"../../src/core/symbols.js\");\n  const { getFontNameToFileMap } = await import(\"../../src/core/standard_fonts.js\");\n  const { getBaseFontMetrics } = await import(\"../../src/core/metrics.js\");\n  const { getMetrics } = await import(\"../../src/core/metrics.js\");\n  const { getUnicodeForGlyph } = await import(\"../../src/core/unicode.js\");\n  const { getGlyphsUnicode } = await import(\"../../src/core/glyphlist.js\");\n  const { getEncoding } = await import(\"../../src/core/encodings.js\");\n  const { getStandardFontName } = await import(\"../../src/core/standard_fonts.js\");\n  const { getSymbolsFonts } = await import(\"../../src/core/symbols.js\");\n  const { getSerifFonts } = await import(\"../../src/core/symbols.js\");\n  const { getFontNameToFileMap } = await import(\"../../src/core/standard_fonts.js\");\n  const { getBaseFontMetrics } = await import(\"../../src/core/metrics.js\");\n  const { getMetrics } = await import(\"../../src/core/metrics.js\");\n  const { getUnicodeForGlyph } = await import(\"../../src/core/unicode.js\");\n  const { getGlyphsUnicode } = await import(\"../../src/core/glyphlist.js\");\n  const { getEncoding } = await import(\"../../src/core/encodings.js\");\n  const { getStandardFontName } = await import(\"../../src/core/standard_fonts.js\");\n  const { getSymbolsFonts } = await import(\"../../src/core/symbols.js\");\n  const { getSerifFonts } = await import(\"../../src/core/symbols.js\");\n  const { getFontNameToFileMap } = await import(\"../../src/core/standard_fonts.js\");\n  const { getBaseFontMetrics }",
    "i5_deepseek-r1-distill-llama-70b": "it(\"should throw on circular Form XObjects\", async () => {\n  const { PDFDocument } = await import(\"../../web/pdf_document.js\");\n  const { fetch } = await import(\"node-fetch\");\n  const { TEST_PDFS_PATH } = await import(\"./test_utils.js\");\n\n  jest.setTimeout(10000);\n\n  const pdfPath = `${TEST_PDFS_PATH}/evil_xobjects.pdf`;\n  try {\n    await PDFDocument.load(await fetch(pdfPath).then(res => res.blob()));\n    throw new Error(\"Expected circular reference error\");\n  } catch (error) {\n    expect(error.message).toContain(\"ignoring circular reference\");\n  }\n});",
    "i5_gpt-4o": "it(\"should handle circular references in Form XObjects without endless loop\", async () => {\n  const { getDocument } = await import(\"../../src/display/api.js\");\n  const { PDFNodeStream } = await import(\"../../src/display/node_stream.js\");\n  const fs = await import(\"fs\");\n  const path = await import(\"path\");\n\n  const pdfPath = path.resolve(__dirname, \"evil_xobjects.pdf\");\n  const data = new Uint8Array(fs.readFileSync(pdfPath));\n  const loadingTask = getDocument({ data, disableAutoFetch: true, isEvalSupported: false, stream: new PDFNodeStream() });\n\n  const pdfDocument = await loadingTask.promise;\n  const page = await pdfDocument.getPage(1);\n  const operatorList = await page.getOperatorList();\n\n  const expectedOpsCount = 3; // Based on Ghostscript's behavior\n  const actualOpsCount = operatorList.argsArray.length;\n\n  expect(actualOpsCount).toBe(expectedOpsCount);\n});",
    "i5_llama-3.3-70b-versatile": "it(\"should prevent endless loop when loading PDF with circular Form XObject references\", async () => {\n  const { PDFDocument } = await import(\"../../src/core/document.js\");\n  const { fetch } = await import(\"../../src/display/network.js\");\n  const pdfUrl = \"https://github.com/user-attachments/files/19691094/evil_xobjects.pdf\";\n  const pdfResponse = await fetch(pdfUrl);\n  const pdfBuffer = await pdfResponse.arrayBuffer();\n  const pdfDocument = await PDFDocument.load(pdfBuffer);\n  const firstPage = await pdfDocument.getPage(1);\n  const operatorListPromise = firstPage.getOperatorList();\n  await expect(operatorListPromise).not.toThrow();\n});"
  },
  "19804": {
    "i1_deepseek-r1-distill-llama-70b": "it(\"should render text with correct spacing for embedded WinAnsiEncoding font\", async () => {\n  const { getDocument } = await import(\"../../src/display/api.js\");\n  const doc = await getDocument(TEST_PDFS_PATH + \"/PDFcustomFontTest.pdf\").promise;\n  const page = await doc.getPage(1);\n  const textContent = await page.getTextContent();\n  const items = textContent.items;\n  for (let i = 1; i < items.length; i++) {\n    if (items[i].transform[4] <= items[i - 1].transform[4]) {\n      throw new Error(\"Overlapping or non-increasing x-coordinate detected\");\n    }\n  }\n});",
    "i1_gpt-4o": "it(\"should render text with correct spacing for embedded WinAnsiEncoding font\", async () => {\n  const { getDocument } = await import(\"../../src/display/api.js\");\n  const doc = await getDocument(TEST_PDFS_PATH + \"/PDFcustomFontTest.pdf\").promise;\n  const page = await doc.getPage(1);\n  const textContent = await page.getTextContent();\n  const items = textContent.items;\n  for (let i = 1; i < items.length; i++) {\n    if (items[i].transform[4] <= items[i - 1].transform[4]) {\n      throw new Error(\"Overlapping or non-increasing x-coordinate detected\");\n    }\n  }\n});",
    "i1_llama-3.3-70b-versatile": "it(\"should render text with correct spacing for embedded WinAnsiEncoding font\", async () => {\n  const { getDocument } = await import(\"../../src/display/api.js\");\n  const doc = await getDocument(TEST_PDFS_PATH + \"/PDFcustomFontTest.pdf\").promise;\n  const page = await doc.getPage(1);\n  const textContent = await page.getTextContent();\n  const items = textContent.items;\n  for (let i = 1; i < items.length; i++) {\n    if (items[i].transform[4] <= items[i - 1].transform[4]) {\n      throw new Error(\"Overlapping or non-increasing x-coordinate detected\");\n    }\n  }\n});",
    "i1_MOCK": "it(\"should render text with correct spacing for embedded WinAnsiEncoding font\", async () => {\n  const { getDocument } = await import(\"../../src/display/api.js\");\n  const doc = await getDocument(TEST_PDFS_PATH + \"/PDFcustomFontTest.pdf\").promise;\n  const page = await doc.getPage(1);\n  const textContent = await page.getTextContent();\n  const items = textContent.items;\n  for (let i = 1; i < items.length; i++) {\n    if (items[i].transform[4] <= items[i - 1].transform[4]) {\n      throw new Error(\"Overlapping or non-increasing x-coordinate detected\");\n    }\n  }\n});",
    "i2_deepseek-r1-distill-llama-70b": "it(\"should render text with correct spacing for embedded WinAnsiEncoding font\", async () => {\n  const { getDocument } = await import(\"../../src/display/api.js\");\n  const doc = await getDocument(TEST_PDFS_PATH + \"/PDFcustomFontTest.pdf\").promise;\n  const page = await doc.getPage(1);\n  const textContent = await page.getTextContent();\n  const items = textContent.items;\n  for (let i = 1; i < items.length; i++) {\n    if (items[i].transform[4] <= items[i - 1].transform[4]) {\n      throw new Error(\"Overlapping or non-increasing x-coordinate detected\");\n    }\n  }\n});",
    "i2_gpt-4o": "it(\"should render text with correct spacing for embedded WinAnsiEncoding font\", async () => {\n  const { getDocument } = await import(\"../../src/display/api.js\");\n  const doc = await getDocument(TEST_PDFS_PATH + \"/PDFcustomFontTest.pdf\").promise;\n  const page = await doc.getPage(1);\n  const textContent = await page.getTextContent();\n  const items = textContent.items;\n  for (let i = 1; i < items.length; i++) {\n    if (items[i].transform[4] <= items[i - 1].transform[4]) {\n      throw new Error(\"Overlapping or non-increasing x-coordinate detected\");\n    }\n  }\n});",
    "i2_llama-3.3-70b-versatile": "it(\"should render text with correct spacing for embedded WinAnsiEncoding font\", async () => {\n  const { getDocument } = await import(\"../../src/display/api.js\");\n  const doc = await getDocument(TEST_PDFS_PATH + \"/PDFcustomFontTest.pdf\").promise;\n  const page = await doc.getPage(1);\n  const textContent = await page.getTextContent();\n  const items = textContent.items;\n  for (let i = 1; i < items.length; i++) {\n    if (items[i].transform[4] <= items[i - 1].transform[4]) {\n      throw new Error(\"Overlapping or non-increasing x-coordinate detected\");\n    }\n  }\n});",
    "i3_deepseek-r1-distill-llama-70b": "it(\"should render text with correct spacing for embedded WinAnsiEncoding font\", async () => {\n  const { getDocument } = await import(\"../../src/display/api.js\");\n  const doc = await getDocument(TEST_PDFS_PATH + \"/PDFcustomFontTest.pdf\").promise;\n  const page = await doc.getPage(1);\n  const textContent = await page.getTextContent();\n  const items = textContent.items;\n  for (let i = 1; i < items.length; i++) {\n    if (items[i].transform[4] <= items[i - 1].transform[4]) {\n      throw new Error(\"Overlapping or non-increasing x-coordinate detected\");\n    }\n  }\n});",
    "i3_gpt-4o": "it(\"should render text with correct spacing for embedded WinAnsiEncoding font\", async () => {\n  const { getDocument } = await import(\"../../src/display/api.js\");\n  const doc = await getDocument(TEST_PDFS_PATH + \"/PDFcustomFontTest.pdf\").promise;\n  const page = await doc.getPage(1);\n  const textContent = await page.getTextContent();\n  const items = textContent.items;\n  for (let i = 1; i < items.length; i++) {\n    if (items[i].transform[4] <= items[i - 1].transform[4]) {\n      throw new Error(\"Overlapping or non-increasing x-coordinate detected\");\n    }\n  }\n});",
    "i3_llama-3.3-70b-versatile": "it(\"should render text with correct spacing for embedded WinAnsiEncoding font\", async () => {\n  const { getDocument } = await import(\"../../src/display/api.js\");\n  const doc = await getDocument(TEST_PDFS_PATH + \"/PDFcustomFontTest.pdf\").promise;\n  const page = await doc.getPage(1);\n  const textContent = await page.getTextContent();\n  const items = textContent.items;\n  for (let i = 1; i < items.length; i++) {\n    if (items[i].transform[4] <= items[i - 1].transform[4]) {\n      throw new Error(\"Overlapping or non-increasing x-coordinate detected\");\n    }\n  }\n});",
    "i4_deepseek-r1-distill-llama-70b": "it(\"should render text with correct spacing for embedded WinAnsiEncoding font\", async () => {\n  const { getDocument } = await import(\"../../src/display/api.js\");\n  const doc = await getDocument(TEST_PDFS_PATH + \"/PDFcustomFontTest.pdf\").promise;\n  const page = await doc.getPage(1);\n  const textContent = await page.getTextContent();\n  const items = textContent.items;\n  for (let i = 1; i < items.length; i++) {\n    if (items[i].transform[4] <= items[i - 1].transform[4]) {\n      throw new Error(\"Overlapping or non-increasing x-coordinate detected\");\n    }\n  }\n});",
    "i4_gpt-4o": "it(\"should render text with correct spacing for embedded WinAnsiEncoding font\", async () => {\n  const { getDocument } = await import(\"../../src/display/api.js\");\n  const doc = await getDocument(TEST_PDFS_PATH + \"/PDFcustomFontTest.pdf\").promise;\n  const page = await doc.getPage(1);\n  const textContent = await page.getTextContent();\n  const items = textContent.items;\n  for (let i = 1; i < items.length; i++) {\n    if (items[i].transform[4] <= items[i - 1].transform[4]) {\n      throw new Error(\"Overlapping or non-increasing x-coordinate detected\");\n    }\n  }\n});",
    "i4_llama-3.3-70b-versatile": "it(\"should render text with correct spacing for embedded WinAnsiEncoding font\", async () => {\n  const { getDocument } = await import(\"../../src/display/api.js\");\n  const doc = await getDocument(TEST_PDFS_PATH + \"/PDFcustomFontTest.pdf\").promise;\n  const page = await doc.getPage(1);\n  const textContent = await page.getTextContent();\n  const items = textContent.items;\n  for (let i = 1; i < items.length; i++) {\n    if (items[i].transform[4] <= items[i - 1].transform[4]) {\n      throw new Error(\"Overlapping or non-increasing x-coordinate detected\");\n    }\n  }\n});",
    "i5_deepseek-r1-distill-llama-70b": "it(\"should render text with correct spacing for embedded WinAnsiEncoding font\", async () => {\n  const { getDocument } = await import(\"../../src/display/api.js\");\n  const doc = await getDocument(TEST_PDFS_PATH + \"/PDFcustomFontTest.pdf\").promise;\n  const page = await doc.getPage(1);\n  const textContent = await page.getTextContent();\n  const items = textContent.items;\n  for (let i = 1; i < items.length; i++) {\n    if (items[i].transform[4] <= items[i - 1].transform[4]) {\n      throw new Error(\"Overlapping or non-increasing x-coordinate detected\");\n    }\n  }\n});",
    "i5_gpt-4o": "it(\"should render text with correct spacing for embedded WinAnsiEncoding font\", async () => {\n  const { getDocument } = await import(\"../../src/display/api.js\");\n  const doc = await getDocument(TEST_PDFS_PATH + \"/PDFcustomFontTest.pdf\").promise;\n  const page = await doc.getPage(1);\n  const textContent = await page.getTextContent();\n  const items = textContent.items;\n  for (let i = 1; i < items.length; i++) {\n    if (items[i].transform[4] <= items[i - 1].transform[4]) {\n      throw new Error(\"Overlapping or non-increasing x-coordinate detected\");\n    }\n  }\n});",
    "i5_llama-3.3-70b-versatile": "it(\"should render text with correct spacing for embedded WinAnsiEncoding font\", async () => {\n  const { getDocument } = await import(\"../../src/display/api.js\");\n  const doc = await getDocument(TEST_PDFS_PATH + \"/PDFcustomFontTest.pdf\").promise;\n  const page = await doc.getPage(1);\n  const textContent = await page.getTextContent();\n  const items = textContent.items;\n  for (let i = 1; i < items.length; i++) {\n    if (items[i].transform[4] <= items[i - 1].transform[4]) {\n      throw new Error(\"Overlapping or non-increasing x-coordinate detected\");\n    }\n  }\n});"
  },
  "19849": {
    "i1_deepseek-r1-distill-llama-70b": "it(\"should render a correct form XObject even if a preceding form XObject has a faulty Resources entry\", async () => {\n  const evaluator = new PartialEvaluator({\n    xref: new XRefMock(),\n    handler: {},\n    pageIndex: 0,\n    idFactory: createIdFactory(),\n    fontCache: {},\n    builtInCMapCache: {},\n    standardFontDataCache: {},\n    globalColorSpaceCache: {},\n    globalImageCache: {},\n    systemFontCache: {},\n    options: { ignoreErrors: true }\n  });\n  const parentResources = new Dict();\n  const operatorList = new OperatorList();\n  const task = { ensureNotTerminated: () => {} };\n  const initialState = {};\n  const localColorSpaceCache = {};\n  const seenRefs = new Set();\n\n  // Faulty Form XObject: its Resources entry is not a Dict.\n  const faultyStream = new StringStream(\"\");\n  faultyStream.dict = new Dict();\n  faultyStream.dict.set(\"Subtype\", new Name(\"Form\"));\n  faultyStream.dict.set(\"Matrix\", [1, 0, 0, 1, 0, 0]);\n  faultyStream.dict.set(\"BBox\", [0, 0, 10, 10]);\n  faultyStream.dict.set(\"Resources\", new Name(\"Faulty\"));\n\n  // Correct Form XObject: its Resources entry is a proper Dict.\n  const correctStream = new StringStream(\"\");\n  correctStream.dict = new Dict();\n  correctStream.dict.set(\"Subtype\", new Name(\"Form\"));\n  correctStream.dict.set(\"Matrix\", [1, 0, 0, 1, 0, 0]);\n  correctStream.dict.set(\"BBox\", [0, 0, 10, 10]);\n  const validResources = new Dict();\n  correctStream.dict.set(\"Resources\", validResources);\n\n  await evaluator.buildFormXObject(parentResources, faultyStream, null, operatorList, task, initialState, localColorSpaceCache, seenRefs);\n  await evaluator.buildFormXObject(parentResources, correctStream, null, operatorList, task, initialState, localColorSpaceCache, seenRefs);\n\n  const beginOps = operatorList.fnArray.filter(op => op === OPS.paintFormXObjectBegin);\n  if (beginOps.length !== 2) {\n    throw new Error(`Expected 2 paintFormXObjectBegin operations, but got ${beginOps.length}`);\n  }\n});",
    "i1_gpt-4o": "it(\"should render a correct form XObject even if a preceding form XObject has a faulty Resources entry\", async () => {\n  const evaluator = new PartialEvaluator({\n    xref: new XRefMock(),\n    handler: {},\n    pageIndex: 0,\n    idFactory: createIdFactory(),\n    fontCache: {},\n    builtInCMapCache: {},\n    standardFontDataCache: {},\n    globalColorSpaceCache: {},\n    globalImageCache: {},\n    systemFontCache: {},\n    options: { ignoreErrors: true }\n  });\n  const parentResources = new Dict();\n  const operatorList = new OperatorList();\n  const task = { ensureNotTerminated: () => {} };\n  const initialState = {};\n  const localColorSpaceCache = {};\n  const seenRefs = new Set();\n\n  // Faulty Form XObject: its Resources entry is not a Dict.\n  const faultyStream = new StringStream(\"\");\n  faultyStream.dict = new Dict();\n  faultyStream.dict.set(\"Subtype\", new Name(\"Form\"));\n  faultyStream.dict.set(\"Matrix\", [1, 0, 0, 1, 0, 0]);\n  faultyStream.dict.set(\"BBox\", [0, 0, 10, 10]);\n  faultyStream.dict.set(\"Resources\", new Name(\"Faulty\"));\n\n  // Correct Form XObject: its Resources entry is a proper Dict.\n  const correctStream = new StringStream(\"\");\n  correctStream.dict = new Dict();\n  correctStream.dict.set(\"Subtype\", new Name(\"Form\"));\n  correctStream.dict.set(\"Matrix\", [1, 0, 0, 1, 0, 0]);\n  correctStream.dict.set(\"BBox\", [0, 0, 10, 10]);\n  const validResources = new Dict();\n  correctStream.dict.set(\"Resources\", validResources);\n\n  await evaluator.buildFormXObject(parentResources, faultyStream, null, operatorList, task, initialState, localColorSpaceCache, seenRefs);\n  await evaluator.buildFormXObject(parentResources, correctStream, null, operatorList, task, initialState, localColorSpaceCache, seenRefs);\n\n  const beginOps = operatorList.fnArray.filter(op => op === OPS.paintFormXObjectBegin);\n  if (beginOps.length !== 2) {\n    throw new Error(`Expected 2 paintFormXObjectBegin operations, but got ${beginOps.length}`);\n  }\n});",
    "i1_llama-3.3-70b-versatile": "it(\"should render a correct form XObject even if a preceding form XObject has a faulty Resources entry\", async () => {\n  const evaluator = new PartialEvaluator({\n    xref: new XRefMock(),\n    handler: {},\n    pageIndex: 0,\n    idFactory: createIdFactory(),\n    fontCache: {},\n    builtInCMapCache: {},\n    standardFontDataCache: {},\n    globalColorSpaceCache: {},\n    globalImageCache: {},\n    systemFontCache: {},\n    options: { ignoreErrors: true }\n  });\n  const parentResources = new Dict();\n  const operatorList = new OperatorList();\n  const task = { ensureNotTerminated: () => {} };\n  const initialState = {};\n  const localColorSpaceCache = {};\n  const seenRefs = new Set();\n\n  // Faulty Form XObject: its Resources entry is not a Dict.\n  const faultyStream = new StringStream(\"\");\n  faultyStream.dict = new Dict();\n  faultyStream.dict.set(\"Subtype\", new Name(\"Form\"));\n  faultyStream.dict.set(\"Matrix\", [1, 0, 0, 1, 0, 0]);\n  faultyStream.dict.set(\"BBox\", [0, 0, 10, 10]);\n  faultyStream.dict.set(\"Resources\", new Name(\"Faulty\"));\n\n  // Correct Form XObject: its Resources entry is a proper Dict.\n  const correctStream = new StringStream(\"\");\n  correctStream.dict = new Dict();\n  correctStream.dict.set(\"Subtype\", new Name(\"Form\"));\n  correctStream.dict.set(\"Matrix\", [1, 0, 0, 1, 0, 0]);\n  correctStream.dict.set(\"BBox\", [0, 0, 10, 10]);\n  const validResources = new Dict();\n  correctStream.dict.set(\"Resources\", validResources);\n\n  await evaluator.buildFormXObject(parentResources, faultyStream, null, operatorList, task, initialState, localColorSpaceCache, seenRefs);\n  await evaluator.buildFormXObject(parentResources, correctStream, null, operatorList, task, initialState, localColorSpaceCache, seenRefs);\n\n  const beginOps = operatorList.fnArray.filter(op => op === OPS.paintFormXObjectBegin);\n  if (beginOps.length !== 2) {\n    throw new Error(`Expected 2 paintFormXObjectBegin operations, but got ${beginOps.length}`);\n  }\n});",
    "i1_MOCK": "it(\"should render a correct form XObject even if a preceding form XObject has a faulty Resources entry\", async () => {\n  const evaluator = new PartialEvaluator({\n    xref: new XRefMock(),\n    handler: {},\n    pageIndex: 0,\n    idFactory: createIdFactory(),\n    fontCache: {},\n    builtInCMapCache: {},\n    standardFontDataCache: {},\n    globalColorSpaceCache: {},\n    globalImageCache: {},\n    systemFontCache: {},\n    options: { ignoreErrors: true }\n  });\n  const parentResources = new Dict();\n  const operatorList = new OperatorList();\n  const task = { ensureNotTerminated: () => {} };\n  const initialState = {};\n  const localColorSpaceCache = {};\n  const seenRefs = new Set();\n\n  // Faulty Form XObject: its Resources entry is not a Dict.\n  const faultyStream = new StringStream(\"\");\n  faultyStream.dict = new Dict();\n  faultyStream.dict.set(\"Subtype\", new Name(\"Form\"));\n  faultyStream.dict.set(\"Matrix\", [1, 0, 0, 1, 0, 0]);\n  faultyStream.dict.set(\"BBox\", [0, 0, 10, 10]);\n  faultyStream.dict.set(\"Resources\", new Name(\"Faulty\"));\n\n  // Correct Form XObject: its Resources entry is a proper Dict.\n  const correctStream = new StringStream(\"\");\n  correctStream.dict = new Dict();\n  correctStream.dict.set(\"Subtype\", new Name(\"Form\"));\n  correctStream.dict.set(\"Matrix\", [1, 0, 0, 1, 0, 0]);\n  correctStream.dict.set(\"BBox\", [0, 0, 10, 10]);\n  const validResources = new Dict();\n  correctStream.dict.set(\"Resources\", validResources);\n\n  await evaluator.buildFormXObject(parentResources, faultyStream, null, operatorList, task, initialState, localColorSpaceCache, seenRefs);\n  await evaluator.buildFormXObject(parentResources, correctStream, null, operatorList, task, initialState, localColorSpaceCache, seenRefs);\n\n  const beginOps = operatorList.fnArray.filter(op => op === OPS.paintFormXObjectBegin);\n  if (beginOps.length !== 2) {\n    throw new Error(`Expected 2 paintFormXObjectBegin operations, but got ${beginOps.length}`);\n  }\n});",
    "i2_deepseek-r1-distill-llama-70b": "it(\"should render a correct form XObject even if a preceding form XObject has a faulty Resources entry\", async () => {\n  const evaluator = new PartialEvaluator({\n    xref: new XRefMock(),\n    handler: {},\n    pageIndex: 0,\n    idFactory: createIdFactory(),\n    fontCache: {},\n    builtInCMapCache: {},\n    standardFontDataCache: {},\n    globalColorSpaceCache: {},\n    globalImageCache: {},\n    systemFontCache: {},\n    options: { ignoreErrors: true }\n  });\n  const parentResources = new Dict();\n  const operatorList = new OperatorList();\n  const task = { ensureNotTerminated: () => {} };\n  const initialState = {};\n  const localColorSpaceCache = {};\n  const seenRefs = new Set();\n\n  // Faulty Form XObject: its Resources entry is not a Dict.\n  const faultyStream = new StringStream(\"\");\n  faultyStream.dict = new Dict();\n  faultyStream.dict.set(\"Subtype\", new Name(\"Form\"));\n  faultyStream.dict.set(\"Matrix\", [1, 0, 0, 1, 0, 0]);\n  faultyStream.dict.set(\"BBox\", [0, 0, 10, 10]);\n  faultyStream.dict.set(\"Resources\", new Name(\"Faulty\"));\n\n  // Correct Form XObject: its Resources entry is a proper Dict.\n  const correctStream = new StringStream(\"\");\n  correctStream.dict = new Dict();\n  correctStream.dict.set(\"Subtype\", new Name(\"Form\"));\n  correctStream.dict.set(\"Matrix\", [1, 0, 0, 1, 0, 0]);\n  correctStream.dict.set(\"BBox\", [0, 0, 10, 10]);\n  const validResources = new Dict();\n  correctStream.dict.set(\"Resources\", validResources);\n\n  await evaluator.buildFormXObject(parentResources, faultyStream, null, operatorList, task, initialState, localColorSpaceCache, seenRefs);\n  await evaluator.buildFormXObject(parentResources, correctStream, null, operatorList, task, initialState, localColorSpaceCache, seenRefs);\n\n  const beginOps = operatorList.fnArray.filter(op => op === OPS.paintFormXObjectBegin);\n  if (beginOps.length !== 2) {\n    throw new Error(`Expected 2 paintFormXObjectBegin operations, but got ${beginOps.length}`);\n  }\n});",
    "i2_gpt-4o": "it(\"should render a correct form XObject even if a preceding form XObject has a faulty Resources entry\", async () => {\n  const evaluator = new PartialEvaluator({\n    xref: new XRefMock(),\n    handler: {},\n    pageIndex: 0,\n    idFactory: createIdFactory(),\n    fontCache: {},\n    builtInCMapCache: {},\n    standardFontDataCache: {},\n    globalColorSpaceCache: {},\n    globalImageCache: {},\n    systemFontCache: {},\n    options: { ignoreErrors: true }\n  });\n  const parentResources = new Dict();\n  const operatorList = new OperatorList();\n  const task = { ensureNotTerminated: () => {} };\n  const initialState = {};\n  const localColorSpaceCache = {};\n  const seenRefs = new Set();\n\n  // Faulty Form XObject: its Resources entry is not a Dict.\n  const faultyStream = new StringStream(\"\");\n  faultyStream.dict = new Dict();\n  faultyStream.dict.set(\"Subtype\", new Name(\"Form\"));\n  faultyStream.dict.set(\"Matrix\", [1, 0, 0, 1, 0, 0]);\n  faultyStream.dict.set(\"BBox\", [0, 0, 10, 10]);\n  faultyStream.dict.set(\"Resources\", new Name(\"Faulty\"));\n\n  // Correct Form XObject: its Resources entry is a proper Dict.\n  const correctStream = new StringStream(\"\");\n  correctStream.dict = new Dict();\n  correctStream.dict.set(\"Subtype\", new Name(\"Form\"));\n  correctStream.dict.set(\"Matrix\", [1, 0, 0, 1, 0, 0]);\n  correctStream.dict.set(\"BBox\", [0, 0, 10, 10]);\n  const validResources = new Dict();\n  correctStream.dict.set(\"Resources\", validResources);\n\n  await evaluator.buildFormXObject(parentResources, faultyStream, null, operatorList, task, initialState, localColorSpaceCache, seenRefs);\n  await evaluator.buildFormXObject(parentResources, correctStream, null, operatorList, task, initialState, localColorSpaceCache, seenRefs);\n\n  const beginOps = operatorList.fnArray.filter(op => op === OPS.paintFormXObjectBegin);\n  if (beginOps.length !== 2) {\n    throw new Error(`Expected 2 paintFormXObjectBegin operations, but got ${beginOps.length}`);\n  }\n});",
    "i2_llama-3.3-70b-versatile": "it(\"should render a correct form XObject even if a preceding form XObject has a faulty Resources entry\", async () => {\n  const evaluator = new PartialEvaluator({\n    xref: new XRefMock(),\n    handler: {},\n    pageIndex: 0,\n    idFactory: createIdFactory(),\n    fontCache: {},\n    builtInCMapCache: {},\n    standardFontDataCache: {},\n    globalColorSpaceCache: {},\n    globalImageCache: {},\n    systemFontCache: {},\n    options: { ignoreErrors: true }\n  });\n  const parentResources = new Dict();\n  const operatorList = new OperatorList();\n  const task = { ensureNotTerminated: () => {} };\n  const initialState = {};\n  const localColorSpaceCache = {};\n  const seenRefs = new Set();\n\n  // Faulty Form XObject: its Resources entry is not a Dict.\n  const faultyStream = new StringStream(\"\");\n  faultyStream.dict = new Dict();\n  faultyStream.dict.set(\"Subtype\", new Name(\"Form\"));\n  faultyStream.dict.set(\"Matrix\", [1, 0, 0, 1, 0, 0]);\n  faultyStream.dict.set(\"BBox\", [0, 0, 10, 10]);\n  faultyStream.dict.set(\"Resources\", new Name(\"Faulty\"));\n\n  // Correct Form XObject: its Resources entry is a proper Dict.\n  const correctStream = new StringStream(\"\");\n  correctStream.dict = new Dict();\n  correctStream.dict.set(\"Subtype\", new Name(\"Form\"));\n  correctStream.dict.set(\"Matrix\", [1, 0, 0, 1, 0, 0]);\n  correctStream.dict.set(\"BBox\", [0, 0, 10, 10]);\n  const validResources = new Dict();\n  correctStream.dict.set(\"Resources\", validResources);\n\n  await evaluator.buildFormXObject(parentResources, faultyStream, null, operatorList, task, initialState, localColorSpaceCache, seenRefs);\n  await evaluator.buildFormXObject(parentResources, correctStream, null, operatorList, task, initialState, localColorSpaceCache, seenRefs);\n\n  const beginOps = operatorList.fnArray.filter(op => op === OPS.paintFormXObjectBegin);\n  if (beginOps.length !== 2) {\n    throw new Error(`Expected 2 paintFormXObjectBegin operations, but got ${beginOps.length}`);\n  }\n});",
    "i3_deepseek-r1-distill-llama-70b": "it(\"should render a correct form XObject even if a preceding form XObject has a faulty Resources entry\", async () => {\n  const evaluator = new PartialEvaluator({\n    xref: new XRefMock(),\n    handler: {},\n    pageIndex: 0,\n    idFactory: createIdFactory(),\n    fontCache: {},\n    builtInCMapCache: {},\n    standardFontDataCache: {},\n    globalColorSpaceCache: {},\n    globalImageCache: {},\n    systemFontCache: {},\n    options: { ignoreErrors: true }\n  });\n  const parentResources = new Dict();\n  const operatorList = new OperatorList();\n  const task = { ensureNotTerminated: () => {} };\n  const initialState = {};\n  const localColorSpaceCache = {};\n  const seenRefs = new Set();\n\n  // Faulty Form XObject: its Resources entry is not a Dict.\n  const faultyStream = new StringStream(\"\");\n  faultyStream.dict = new Dict();\n  faultyStream.dict.set(\"Subtype\", new Name(\"Form\"));\n  faultyStream.dict.set(\"Matrix\", [1, 0, 0, 1, 0, 0]);\n  faultyStream.dict.set(\"BBox\", [0, 0, 10, 10]);\n  faultyStream.dict.set(\"Resources\", new Name(\"Faulty\"));\n\n  // Correct Form XObject: its Resources entry is a proper Dict.\n  const correctStream = new StringStream(\"\");\n  correctStream.dict = new Dict();\n  correctStream.dict.set(\"Subtype\", new Name(\"Form\"));\n  correctStream.dict.set(\"Matrix\", [1, 0, 0, 1, 0, 0]);\n  correctStream.dict.set(\"BBox\", [0, 0, 10, 10]);\n  const validResources = new Dict();\n  correctStream.dict.set(\"Resources\", validResources);\n\n  await evaluator.buildFormXObject(parentResources, faultyStream, null, operatorList, task, initialState, localColorSpaceCache, seenRefs);\n  await evaluator.buildFormXObject(parentResources, correctStream, null, operatorList, task, initialState, localColorSpaceCache, seenRefs);\n\n  const beginOps = operatorList.fnArray.filter(op => op === OPS.paintFormXObjectBegin);\n  if (beginOps.length !== 2) {\n    throw new Error(`Expected 2 paintFormXObjectBegin operations, but got ${beginOps.length}`);\n  }\n});",
    "i3_gpt-4o": "it(\"should render a correct form XObject even if a preceding form XObject has a faulty Resources entry\", async () => {\n  const evaluator = new PartialEvaluator({\n    xref: new XRefMock(),\n    handler: {},\n    pageIndex: 0,\n    idFactory: createIdFactory(),\n    fontCache: {},\n    builtInCMapCache: {},\n    standardFontDataCache: {},\n    globalColorSpaceCache: {},\n    globalImageCache: {},\n    systemFontCache: {},\n    options: { ignoreErrors: true }\n  });\n  const parentResources = new Dict();\n  const operatorList = new OperatorList();\n  const task = { ensureNotTerminated: () => {} };\n  const initialState = {};\n  const localColorSpaceCache = {};\n  const seenRefs = new Set();\n\n  // Faulty Form XObject: its Resources entry is not a Dict.\n  const faultyStream = new StringStream(\"\");\n  faultyStream.dict = new Dict();\n  faultyStream.dict.set(\"Subtype\", new Name(\"Form\"));\n  faultyStream.dict.set(\"Matrix\", [1, 0, 0, 1, 0, 0]);\n  faultyStream.dict.set(\"BBox\", [0, 0, 10, 10]);\n  faultyStream.dict.set(\"Resources\", new Name(\"Faulty\"));\n\n  // Correct Form XObject: its Resources entry is a proper Dict.\n  const correctStream = new StringStream(\"\");\n  correctStream.dict = new Dict();\n  correctStream.dict.set(\"Subtype\", new Name(\"Form\"));\n  correctStream.dict.set(\"Matrix\", [1, 0, 0, 1, 0, 0]);\n  correctStream.dict.set(\"BBox\", [0, 0, 10, 10]);\n  const validResources = new Dict();\n  correctStream.dict.set(\"Resources\", validResources);\n\n  await evaluator.buildFormXObject(parentResources, faultyStream, null, operatorList, task, initialState, localColorSpaceCache, seenRefs);\n  await evaluator.buildFormXObject(parentResources, correctStream, null, operatorList, task, initialState, localColorSpaceCache, seenRefs);\n\n  const beginOps = operatorList.fnArray.filter(op => op === OPS.paintFormXObjectBegin);\n  if (beginOps.length !== 2) {\n    throw new Error(`Expected 2 paintFormXObjectBegin operations, but got ${beginOps.length}`);\n  }\n});",
    "i3_llama-3.3-70b-versatile": "it(\"should render a correct form XObject even if a preceding form XObject has a faulty Resources entry\", async () => {\n  const evaluator = new PartialEvaluator({\n    xref: new XRefMock(),\n    handler: {},\n    pageIndex: 0,\n    idFactory: createIdFactory(),\n    fontCache: {},\n    builtInCMapCache: {},\n    standardFontDataCache: {},\n    globalColorSpaceCache: {},\n    globalImageCache: {},\n    systemFontCache: {},\n    options: { ignoreErrors: true }\n  });\n  const parentResources = new Dict();\n  const operatorList = new OperatorList();\n  const task = { ensureNotTerminated: () => {} };\n  const initialState = {};\n  const localColorSpaceCache = {};\n  const seenRefs = new Set();\n\n  // Faulty Form XObject: its Resources entry is not a Dict.\n  const faultyStream = new StringStream(\"\");\n  faultyStream.dict = new Dict();\n  faultyStream.dict.set(\"Subtype\", new Name(\"Form\"));\n  faultyStream.dict.set(\"Matrix\", [1, 0, 0, 1, 0, 0]);\n  faultyStream.dict.set(\"BBox\", [0, 0, 10, 10]);\n  faultyStream.dict.set(\"Resources\", new Name(\"Faulty\"));\n\n  // Correct Form XObject: its Resources entry is a proper Dict.\n  const correctStream = new StringStream(\"\");\n  correctStream.dict = new Dict();\n  correctStream.dict.set(\"Subtype\", new Name(\"Form\"));\n  correctStream.dict.set(\"Matrix\", [1, 0, 0, 1, 0, 0]);\n  correctStream.dict.set(\"BBox\", [0, 0, 10, 10]);\n  const validResources = new Dict();\n  correctStream.dict.set(\"Resources\", validResources);\n\n  await evaluator.buildFormXObject(parentResources, faultyStream, null, operatorList, task, initialState, localColorSpaceCache, seenRefs);\n  await evaluator.buildFormXObject(parentResources, correctStream, null, operatorList, task, initialState, localColorSpaceCache, seenRefs);\n\n  const beginOps = operatorList.fnArray.filter(op => op === OPS.paintFormXObjectBegin);\n  if (beginOps.length !== 2) {\n    throw new Error(`Expected 2 paintFormXObjectBegin operations, but got ${beginOps.length}`);\n  }\n});",
    "i4_deepseek-r1-distill-llama-70b": "it(\"should render a correct form XObject even if a preceding form XObject has a faulty Resources entry\", async () => {\n  const evaluator = new PartialEvaluator({\n    xref: new XRefMock(),\n    handler: {},\n    pageIndex: 0,\n    idFactory: createIdFactory(),\n    fontCache: {},\n    builtInCMapCache: {},\n    standardFontDataCache: {},\n    globalColorSpaceCache: {},\n    globalImageCache: {},\n    systemFontCache: {},\n    options: { ignoreErrors: true }\n  });\n  const parentResources = new Dict();\n  const operatorList = new OperatorList();\n  const task = { ensureNotTerminated: () => {} };\n  const initialState = {};\n  const localColorSpaceCache = {};\n  const seenRefs = new Set();\n\n  // Faulty Form XObject: its Resources entry is not a Dict.\n  const faultyStream = new StringStream(\"\");\n  faultyStream.dict = new Dict();\n  faultyStream.dict.set(\"Subtype\", new Name(\"Form\"));\n  faultyStream.dict.set(\"Matrix\", [1, 0, 0, 1, 0, 0]);\n  faultyStream.dict.set(\"BBox\", [0, 0, 10, 10]);\n  faultyStream.dict.set(\"Resources\", new Name(\"Faulty\"));\n\n  // Correct Form XObject: its Resources entry is a proper Dict.\n  const correctStream = new StringStream(\"\");\n  correctStream.dict = new Dict();\n  correctStream.dict.set(\"Subtype\", new Name(\"Form\"));\n  correctStream.dict.set(\"Matrix\", [1, 0, 0, 1, 0, 0]);\n  correctStream.dict.set(\"BBox\", [0, 0, 10, 10]);\n  const validResources = new Dict();\n  correctStream.dict.set(\"Resources\", validResources);\n\n  await evaluator.buildFormXObject(parentResources, faultyStream, null, operatorList, task, initialState, localColorSpaceCache, seenRefs);\n  await evaluator.buildFormXObject(parentResources, correctStream, null, operatorList, task, initialState, localColorSpaceCache, seenRefs);\n\n  const beginOps = operatorList.fnArray.filter(op => op === OPS.paintFormXObjectBegin);\n  if (beginOps.length !== 2) {\n    throw new Error(`Expected 2 paintFormXObjectBegin operations, but got ${beginOps.length}`);\n  }\n});",
    "i4_gpt-4o": "it(\"should render a correct form XObject even if a preceding form XObject has a faulty Resources entry\", async () => {\n  const evaluator = new PartialEvaluator({\n    xref: new XRefMock(),\n    handler: {},\n    pageIndex: 0,\n    idFactory: createIdFactory(),\n    fontCache: {},\n    builtInCMapCache: {},\n    standardFontDataCache: {},\n    globalColorSpaceCache: {},\n    globalImageCache: {},\n    systemFontCache: {},\n    options: { ignoreErrors: true }\n  });\n  const parentResources = new Dict();\n  const operatorList = new OperatorList();\n  const task = { ensureNotTerminated: () => {} };\n  const initialState = {};\n  const localColorSpaceCache = {};\n  const seenRefs = new Set();\n\n  // Faulty Form XObject: its Resources entry is not a Dict.\n  const faultyStream = new StringStream(\"\");\n  faultyStream.dict = new Dict();\n  faultyStream.dict.set(\"Subtype\", new Name(\"Form\"));\n  faultyStream.dict.set(\"Matrix\", [1, 0, 0, 1, 0, 0]);\n  faultyStream.dict.set(\"BBox\", [0, 0, 10, 10]);\n  faultyStream.dict.set(\"Resources\", new Name(\"Faulty\"));\n\n  // Correct Form XObject: its Resources entry is a proper Dict.\n  const correctStream = new StringStream(\"\");\n  correctStream.dict = new Dict();\n  correctStream.dict.set(\"Subtype\", new Name(\"Form\"));\n  correctStream.dict.set(\"Matrix\", [1, 0, 0, 1, 0, 0]);\n  correctStream.dict.set(\"BBox\", [0, 0, 10, 10]);\n  const validResources = new Dict();\n  correctStream.dict.set(\"Resources\", validResources);\n\n  await evaluator.buildFormXObject(parentResources, faultyStream, null, operatorList, task, initialState, localColorSpaceCache, seenRefs);\n  await evaluator.buildFormXObject(parentResources, correctStream, null, operatorList, task, initialState, localColorSpaceCache, seenRefs);\n\n  const beginOps = operatorList.fnArray.filter(op => op === OPS.paintFormXObjectBegin);\n  if (beginOps.length !== 2) {\n    throw new Error(`Expected 2 paintFormXObjectBegin operations, but got ${beginOps.length}`);\n  }\n});",
    "i4_llama-3.3-70b-versatile": "it(\"should render a correct form XObject even if a preceding form XObject has a faulty Resources entry\", async () => {\n  const evaluator = new PartialEvaluator({\n    xref: new XRefMock(),\n    handler: {},\n    pageIndex: 0,\n    idFactory: createIdFactory(),\n    fontCache: {},\n    builtInCMapCache: {},\n    standardFontDataCache: {},\n    globalColorSpaceCache: {},\n    globalImageCache: {},\n    systemFontCache: {},\n    options: { ignoreErrors: true }\n  });\n  const parentResources = new Dict();\n  const operatorList = new OperatorList();\n  const task = { ensureNotTerminated: () => {} };\n  const initialState = {};\n  const localColorSpaceCache = {};\n  const seenRefs = new Set();\n\n  // Faulty Form XObject: its Resources entry is not a Dict.\n  const faultyStream = new StringStream(\"\");\n  faultyStream.dict = new Dict();\n  faultyStream.dict.set(\"Subtype\", new Name(\"Form\"));\n  faultyStream.dict.set(\"Matrix\", [1, 0, 0, 1, 0, 0]);\n  faultyStream.dict.set(\"BBox\", [0, 0, 10, 10]);\n  faultyStream.dict.set(\"Resources\", new Name(\"Faulty\"));\n\n  // Correct Form XObject: its Resources entry is a proper Dict.\n  const correctStream = new StringStream(\"\");\n  correctStream.dict = new Dict();\n  correctStream.dict.set(\"Subtype\", new Name(\"Form\"));\n  correctStream.dict.set(\"Matrix\", [1, 0, 0, 1, 0, 0]);\n  correctStream.dict.set(\"BBox\", [0, 0, 10, 10]);\n  const validResources = new Dict();\n  correctStream.dict.set(\"Resources\", validResources);\n\n  await evaluator.buildFormXObject(parentResources, faultyStream, null, operatorList, task, initialState, localColorSpaceCache, seenRefs);\n  await evaluator.buildFormXObject(parentResources, correctStream, null, operatorList, task, initialState, localColorSpaceCache, seenRefs);\n\n  const beginOps = operatorList.fnArray.filter(op => op === OPS.paintFormXObjectBegin);\n  if (beginOps.length !== 2) {\n    throw new Error(`Expected 2 paintFormXObjectBegin operations, but got ${beginOps.length}`);\n  }\n});",
    "i5_deepseek-r1-distill-llama-70b": "it(\"should render a correct form XObject even if a preceding form XObject has a faulty Resources entry\", async () => {\n  const evaluator = new PartialEvaluator({\n    xref: new XRefMock(),\n    handler: {},\n    pageIndex: 0,\n    idFactory: createIdFactory(),\n    fontCache: {},\n    builtInCMapCache: {},\n    standardFontDataCache: {},\n    globalColorSpaceCache: {},\n    globalImageCache: {},\n    systemFontCache: {},\n    options: { ignoreErrors: true }\n  });\n  const parentResources = new Dict();\n  const operatorList = new OperatorList();\n  const task = { ensureNotTerminated: () => {} };\n  const initialState = {};\n  const localColorSpaceCache = {};\n  const seenRefs = new Set();\n\n  // Faulty Form XObject: its Resources entry is not a Dict.\n  const faultyStream = new StringStream(\"\");\n  faultyStream.dict = new Dict();\n  faultyStream.dict.set(\"Subtype\", new Name(\"Form\"));\n  faultyStream.dict.set(\"Matrix\", [1, 0, 0, 1, 0, 0]);\n  faultyStream.dict.set(\"BBox\", [0, 0, 10, 10]);\n  faultyStream.dict.set(\"Resources\", new Name(\"Faulty\"));\n\n  // Correct Form XObject: its Resources entry is a proper Dict.\n  const correctStream = new StringStream(\"\");\n  correctStream.dict = new Dict();\n  correctStream.dict.set(\"Subtype\", new Name(\"Form\"));\n  correctStream.dict.set(\"Matrix\", [1, 0, 0, 1, 0, 0]);\n  correctStream.dict.set(\"BBox\", [0, 0, 10, 10]);\n  const validResources = new Dict();\n  correctStream.dict.set(\"Resources\", validResources);\n\n  await evaluator.buildFormXObject(parentResources, faultyStream, null, operatorList, task, initialState, localColorSpaceCache, seenRefs);\n  await evaluator.buildFormXObject(parentResources, correctStream, null, operatorList, task, initialState, localColorSpaceCache, seenRefs);\n\n  const beginOps = operatorList.fnArray.filter(op => op === OPS.paintFormXObjectBegin);\n  if (beginOps.length !== 2) {\n    throw new Error(`Expected 2 paintFormXObjectBegin operations, but got ${beginOps.length}`);\n  }\n});",
    "i5_gpt-4o": "it(\"should render a correct form XObject even if a preceding form XObject has a faulty Resources entry\", async () => {\n  const evaluator = new PartialEvaluator({\n    xref: new XRefMock(),\n    handler: {},\n    pageIndex: 0,\n    idFactory: createIdFactory(),\n    fontCache: {},\n    builtInCMapCache: {},\n    standardFontDataCache: {},\n    globalColorSpaceCache: {},\n    globalImageCache: {},\n    systemFontCache: {},\n    options: { ignoreErrors: true }\n  });\n  const parentResources = new Dict();\n  const operatorList = new OperatorList();\n  const task = { ensureNotTerminated: () => {} };\n  const initialState = {};\n  const localColorSpaceCache = {};\n  const seenRefs = new Set();\n\n  // Faulty Form XObject: its Resources entry is not a Dict.\n  const faultyStream = new StringStream(\"\");\n  faultyStream.dict = new Dict();\n  faultyStream.dict.set(\"Subtype\", new Name(\"Form\"));\n  faultyStream.dict.set(\"Matrix\", [1, 0, 0, 1, 0, 0]);\n  faultyStream.dict.set(\"BBox\", [0, 0, 10, 10]);\n  faultyStream.dict.set(\"Resources\", new Name(\"Faulty\"));\n\n  // Correct Form XObject: its Resources entry is a proper Dict.\n  const correctStream = new StringStream(\"\");\n  correctStream.dict = new Dict();\n  correctStream.dict.set(\"Subtype\", new Name(\"Form\"));\n  correctStream.dict.set(\"Matrix\", [1, 0, 0, 1, 0, 0]);\n  correctStream.dict.set(\"BBox\", [0, 0, 10, 10]);\n  const validResources = new Dict();\n  correctStream.dict.set(\"Resources\", validResources);\n\n  await evaluator.buildFormXObject(parentResources, faultyStream, null, operatorList, task, initialState, localColorSpaceCache, seenRefs);\n  await evaluator.buildFormXObject(parentResources, correctStream, null, operatorList, task, initialState, localColorSpaceCache, seenRefs);\n\n  const beginOps = operatorList.fnArray.filter(op => op === OPS.paintFormXObjectBegin);\n  if (beginOps.length !== 2) {\n    throw new Error(`Expected 2 paintFormXObjectBegin operations, but got ${beginOps.length}`);\n  }\n});",
    "i5_llama-3.3-70b-versatile": "it(\"should render a correct form XObject even if a preceding form XObject has a faulty Resources entry\", async () => {\n  const evaluator = new PartialEvaluator({\n    xref: new XRefMock(),\n    handler: {},\n    pageIndex: 0,\n    idFactory: createIdFactory(),\n    fontCache: {},\n    builtInCMapCache: {},\n    standardFontDataCache: {},\n    globalColorSpaceCache: {},\n    globalImageCache: {},\n    systemFontCache: {},\n    options: { ignoreErrors: true }\n  });\n  const parentResources = new Dict();\n  const operatorList = new OperatorList();\n  const task = { ensureNotTerminated: () => {} };\n  const initialState = {};\n  const localColorSpaceCache = {};\n  const seenRefs = new Set();\n\n  // Faulty Form XObject: its Resources entry is not a Dict.\n  const faultyStream = new StringStream(\"\");\n  faultyStream.dict = new Dict();\n  faultyStream.dict.set(\"Subtype\", new Name(\"Form\"));\n  faultyStream.dict.set(\"Matrix\", [1, 0, 0, 1, 0, 0]);\n  faultyStream.dict.set(\"BBox\", [0, 0, 10, 10]);\n  faultyStream.dict.set(\"Resources\", new Name(\"Faulty\"));\n\n  // Correct Form XObject: its Resources entry is a proper Dict.\n  const correctStream = new StringStream(\"\");\n  correctStream.dict = new Dict();\n  correctStream.dict.set(\"Subtype\", new Name(\"Form\"));\n  correctStream.dict.set(\"Matrix\", [1, 0, 0, 1, 0, 0]);\n  correctStream.dict.set(\"BBox\", [0, 0, 10, 10]);\n  const validResources = new Dict();\n  correctStream.dict.set(\"Resources\", validResources);\n\n  await evaluator.buildFormXObject(parentResources, faultyStream, null, operatorList, task, initialState, localColorSpaceCache, seenRefs);\n  await evaluator.buildFormXObject(parentResources, correctStream, null, operatorList, task, initialState, localColorSpaceCache, seenRefs);\n\n  const beginOps = operatorList.fnArray.filter(op => op === OPS.paintFormXObjectBegin);\n  if (beginOps.length !== 2) {\n    throw new Error(`Expected 2 paintFormXObjectBegin operations, but got ${beginOps.length}`);\n  }\n});"
  },
  "19918": {
    "i1_deepseek-r1-distill-llama-70b": "it(\"should decode cmyk jpeg image using ImageDecoder\", async () => {\n  const { TestPdfsServer } = await import(\"./test_utils.js\");\n  const { PDFDocumentProxy, PDFPageProxy } = await import(\"../../src/display/api.js\");\n  const server = new TestPdfsServer();\n  try {\n    await server.start();\n    const cmykJpegUrl = server.url(\"cmyk.jpeg\");\n    const response = await fetch(cmykJpegUrl);\n    const arrayBuffer = await response.arrayBuffer();\n    const data = new Uint8Array(arrayBuffer);\n\n    const transport = new PDFDataRangeTransport(data);\n    const loadingTask = PDFDocumentLoadingTask.create(transport);\n    const pdf = await PDFDocumentProxy.create({\n      loadingTask,\n      isDataLoaded: () => true,\n      isDisposed: false,\n      getProxies: () => ({\n        pages: [PDFPageProxy.create({})],\n      }),\n    });\n\n    const page = pdf.getPages()[0];\n    const viewport = page.getViewport({ scale: 1 });\n\n    let exceptionThrown = false;\n    try {\n      await page.render({\n        viewport,\n        renderOption: {\n          renderAnnotations: false,\n          renderForm: false,\n          useImageDecoder: true,\n        },\n      });\n    } catch (e) {\n      exceptionThrown = true;\n    }\n\n    assert.notOk(exceptionThrown, \"Exception thrown when rendering CMYK JPEG\");\n  } finally {\n    await server.stop();\n  }\n});",
    "i1_gpt-4o": "it(\"should support decoding CMYK JPEG images using ImageDecoder\", async () => {\n  const { JpegStream } = await import(\"../../src/core/jpeg_stream.js\");\n  const { JpegImage } = await import(\"../../src/core/jpg.js\");\n  const { Stream } = await import(\"../../src/core/stream.js\");\n\n  const cmykJpegData = new Uint8Array([\n    0xff, 0xd8, 0xff, 0xc0, 0x00, 0x11, 0x08, 0x00, 0x01, 0x00, 0x01, 0x04, 0x01, 0x11, 0x00, 0xff, 0xd9\n  ]);\n  const stream = new Stream(cmykJpegData);\n  const jpegStream = new JpegStream(stream, cmykJpegData.length, {});\n\n  const useImageDecoder = JpegImage.canUseImageDecoder(cmykJpegData, -1);\n  const expected = { cmyk: true };\n  expect(useImageDecoder).toEqual(expected);\n\n  const transferableImage = await jpegStream.getTransferableImage();\n  expect(transferableImage).not.toBeNull();\n});",
    "i1_llama-3.3-70b-versatile": "it(\"should decode cmyk jpeg image using ImageDecoder\", async () => {\n  const { JpegStream, JpegImage } = await import(\"../../src/core/jpeg_stream.js\");\n  const { JpegImage as JpegImageClass } = await import(\"../../src/core/jpg.js\");\n  const data = new Uint8Array([0xff, 0xd8, 0xff, 0xe1, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]);\n  const useImageDecoder = JpegImageClass.canUseImageDecoder(data);\n  const stream = { dict: {}, asyncGetBytes: async () => data };\n  const jpegStream = new JpegStream(stream, null, { colorTransform: -1 });\n  const image = await jpegStream.getTransferableImage();\n  expect(image).not.toBeNull();\n});",
    "i2_deepseek-r1-distill-llama-70b": "it(\"should decode CMYK JPEG images using ImageDecoder\", async () => {\n  const { JpegImage } = await import(\"../../src/core/jpg.js\");\n  const { JpegStream } = await import(\"../../src/core/jpeg_stream.js\");\n\n  // Sample CMYK JPEG data (this is a minimal valid CMYK JPEG)\n  const cmykJpegData = new Uint8Array([\n    0xff, 0xd8, 0xff, 0xe0, 0x00, 0x10, 0x4a, 0x46, 0x49, 0x46, 0x00, 0x01,\n    0x01, 0x00, 0x00, 0x00, 0x00, 0xff, 0xc0, 0x00, 0x11, 0x08, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x11, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff,\n    0xc4, 0x00, 0x14, 0x10, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0xff, 0xc2, 0x00, 0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff,\n    0xd9\n  ]);\n\n  const result = await JpegImage.canUseImageDecoder(cmykJpegData);\n  expect(result).not.toBeNull();\n  expect(result.cmyk).toBe(true);\n});",
    "i2_gpt-4o": "it(\"should decode CMYK JPEG images using ImageDecoder\", async () => {\n  const { JpegStream } = await import(\"../../src/core/jpeg_stream.js\");\n  const { JpegImage } = await import(\"../../src/core/jpg.js\");\n  const { Stream } = await import(\"../../src/core/stream.js\");\n\n  const cmykJpegData = new Uint8Array([\n    0xff, 0xd8, 0xff, 0xc0, 0x00, 0x11, 0x08, 0x00, 0x01, 0x00, 0x01, 0x04, 0x01, 0x11, 0x00, 0xff, 0xd9\n  ]);\n  const stream = new Stream(cmykJpegData);\n  const jpegStream = new JpegStream(stream, cmykJpegData.length, {});\n\n  const expected = true;\n  const actual = await JpegStream.canUseImageDecoderCMYK;\n\n  expect(actual).toBe(expected);\n});",
    "i2_llama-3.3-70b-versatile": "it(\"should decode cmyk jpeg images using ImageDecoder\", async () => {\n  const { JpegStream, JpegImage } = await import(\"../../src/core/jpeg_stream.js\");\n  const { readUint16 } = await import(\"../../src/core/core_utils.js\");\n\n  // Create a sample cmyk jpeg image\n  const cmykJpegData = new Uint8Array([\n    0xff, 0xd8, 0xff, 0xe1, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00",
    "i3_deepseek-r1-distill-llama-70b": "it(\"should decode CMYK JPEG images using ImageDecoder\", async () => {\n  const { TestPdfsServer } = await import(\"./test_utils.js\");\n  const server = new TestPdfsServer();\n  try {\n    await server.start();\n    const pdfPath = `${TEST_PDFS_PATH}/cmyk_jpeg.pdf`;\n    const { pdfDocument } = await getDocument({\n      url: pdfPath,\n      transport: new PDFDataRangeTransport({\n        fetch: fetchDataDOM,\n        url: pdfPath,\n        httpHeaders: {\n          \"X-Pdf-Web-Api-BaseVersion\": \"1\",\n          \"X-Pdf-Web-Api-ViewerVersion\": \"1.10.100\",\n        },\n      }),\n    });\n    const pdfPage = await pdfDocument.getPage(1);\n    const viewport = PageViewport.fromDimensions(100, 100);\n    const renderTask = RenderTask.fromPDFPage({\n      pdfPage,\n      viewport,\n      renderInteractive: false,\n    });\n    await renderTask.run();\n    expect(renderTask.status).toBe(\"completed\");\n  } finally {\n    await server.stop();\n    server.close();\n  }\n});",
    "i3_gpt-4o": "it(\"should support decoding CMYK JPEG images using ImageDecoder\", async () => {\n  const { JpegStream } = await import(\"../../src/core/jpeg_stream.js\");\n  const { Stream } = await import(\"../../src/core/stream.js\");\n\n  const cmykJpegData = new Uint8Array([\n    0xff, 0xd8, 0xff, 0xe0, 0x00, 0x10, 0x4a, 0x46, 0x49, 0x46, 0x00, 0x01,\n    0x01, 0x01, 0x00, 0x60, 0x00, 0x60, 0x00, 0x00, 0xff, 0xee, 0x00, 0x0e,\n    0x41, 0x64, 0x6f, 0x62, 0x65, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0xff, 0xc0, 0x00, 0x11, 0x08, 0x00, 0x60, 0x00, 0x60, 0x04, 0x01, 0x11,\n    0x00, 0x02, 0x11, 0x01, 0x03, 0x11, 0x01, 0x04, 0x11, 0x01, 0xff, 0xda,\n    0x00, 0x0c, 0x03, 0x01, 0x00, 0x02, 0x11, 0x03, 0x11, 0x00, 0x3f, 0x00,\n    0xff, 0xd9\n  ]);\n  const stream = new Stream(cmykJpegData);\n  const jpegStream = new JpegStream(stream, cmykJpegData.length, null);\n\n  const canDecode = await JpegStream.canUseImageDecoderCMYK;\n  const transferableImage = await jpegStream.getTransferableImage();\n\n  expect(canDecode).toBe(true);\n  expect(transferableImage).not.toBeNull();\n});",
    "i3_llama-3.3-70b-versatile": "it(\"should support decoding cmyk jpeg image using ImageDecoder\", async () => {\n  const { PDFDocumentProxy, PDFPageProxy, PDFWorker } = await import(\"../../src/display/api.js\");\n  const { buildGetDocumentParams, TEST_PDFS_PATH } = await import(\"./test_utils.js\");\n  const { JpegImage } = await import(\"../../src/core/jpg.js\");\n  const pdfFile = `${TEST_PDFS_PATH}/cmyk-jpeg.pdf`;\n  const pdfDocument = await getDocument(buildGetDocumentParams(pdfFile));\n  const pdfPage = await pdfDocument.getPage(1);\n  const image = await pdfPage.getImage(0);\n  const jpegImage = new JpegImage();\n  const data = await image.getData();\n  jpegImage.parse(data);\n  const canUseImageDecoder = await JpegImage.canUseImageDecoder(data);\n  expect(canUseImageDecoder).not.toBeNull();\n});",
    "i4_deepseek-r1-distill-llama-70b": "it(\"should support decoding cmyk jpeg image in using ImageDecoder\", async () => {\n  const { JpegImage } = await import(\"../../src/core/jpg.js\");\n  const { JpegStream } = await import(\"../../src/core/jpeg_stream.js\");\n\n  // Create a minimal CMYK JPEG buffer\n  const cmykJpegBuffer = new Uint8Array([\n    0xFF, 0xD8, 0xFF, 0xEE, 0x00, 0x16, 0x43, 0x6D, 0x43, 0x6C, 0x00, 0x00,\n    0x80, 0x00, 0x02, 0x11, 0x0C, 0x6C, 0x6D, 0x42, 0x43, 0x00, 0x5F,\n    0x00, 0x04, 0x01, 0x00, 0x00, 0x7F, 0x00, 0xC2, 0x00, 0x02, 0x00,\n    0x11, 0x8C, 0x6C, 0x6C, 0x1A, 0x87, 0x6F, 0x02, 0x02, 0x02, 0x02,\n    0x02, 0x02, 0x02, 0x02, 0x02, 0xFF, 0xD9\n  ]);\n\n  const jpegImage = new JpegImage({ colorTransform: 1 });\n  const useImageDecoder = await JpegImage.canUseImageDecoder(cmykJpegBuffer);\n\n  const expected = { cmyk: true };\n  expect(useImageDecoder).toEqual(expected);\n});",
    "i4_gpt-4o": "it(\"should support decoding CMYK JPEG images using ImageDecoder\", async () => {\n  const { JpegStream } = await import(\"../../src/core/jpeg_stream.js\");\n  const { JpegImage } = await import(\"../../src/core/jpg.js\");\n\n  const mockStream = {\n    dict: {\n      getArray: () => null,\n      get: () => 8,\n    },\n    getBytes: () => new Uint8Array([0xff, 0xd8, 0xff, 0xc0, 0x00, 0x11, 0x08, 0x00, 0x01, 0x00, 0x01, 0x03, 0x01, 0x11, 0x00, 0x02, 0x11, 0x01, 0x03, 0x11, 0x01]),\n    isAsync: false,\n  };\n\n  const jpegStream = new JpegStream(mockStream, null, null);\n  const jpegOptions = jpegStream.jpegOptions;\n  const bytes = jpegStream.bytes;\n\n  const useImageDecoder = JpegImage.canUseImageDecoder(bytes, jpegOptions.colorTransform);\n  const expected = { cmyk: true };\n  const actual = useImageDecoder;\n\n  expect(actual).toEqual(expected);\n});",
    "i4_llama-3.3-70b-versatile": "it(\"should support decoding cmyk jpeg image using ImageDecoder\", async () => {\n  const { JpegStream } = await import(\"../../src/core/jpeg_stream.js\");\n  const { JpegImage } = await import(\"../../src/core/jpg.js\");\n  const data = new Uint8Array([0xff, 0xd8, 0xff, 0xe0, 0x00, 0x10, 0x4a, 0x46, 0x49, 0x46, 0x00, 0x01, 0x01, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00]);\n  const stream = { dict: {}, getBytes: () => data };\n  const jpegStream = new JpegStream(stream, null, {});\n  const useImageDecoder = await JpegImage.canUseImageDecoder(data);\n  const imageDecoderSupported = await JpegStream.canUseImageDecoderCMYK();\n  if (imageDecoderSupported && useImageDecoder) {\n    const decoder = new (await import(\"../../src/shared/util.js\")).ImageDecoder({\n      data: data,\n      type: \"image/x-jpeg-pdf\",\n      preferAnimation: false,\n    });\n    const image = await decoder.decode();\n    expect(image).not.toBeNull();\n  } else {\n    expect(useImageDecoder).toBeNull();\n  }\n});",
    "i5_deepseek-r1-distill-llama-70b": "it(\"should decode CMYK JPEG images using ImageDecoder\", async () => {\n  const { JpegImage } = await import(\"../../src/core/jpg.js\");\n\n  // Create a sample CMYK JPEG image data\n  const cmykImageData = new Uint8Array([\n    0xFF, 0xD8, 0xFF, 0xE0, 0x00, 0x10, 0x4A, 0x46, 0x49, 0x46, 0x00, 0x01,\n    0x00, 0x00, 0x00, 0x0C, 0x03, 0x00, 0x00, 0x00, 0x0C, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0xFF, 0xC0, 0x00, 0x11, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0xFF, 0xC4, 0x00, 0x14, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0xFF, 0xDA, 0x00, 0x0C, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0xFF, 0xD9\n  ]);\n\n  // Test before patch\n  const beforeResult = await JpegImage.canUseImageDecoder(cmykImageData);\n  const beforeComponents = beforeResult.numComponents || 0;\n\n  // Test after patch\n  const afterResult = await JpegImage.canUseImageDecoder(cmykImageData);\n  const afterComponents = afterResult.numComponents || 0;\n\n  // Verify that before patch, CMYK was not supported and after patch it is\n  expect(beforeComponents).toBe(3);\n  expect(afterComponents).toBe(4);\n});",
    "i5_gpt-4o": "it(\"should support decoding CMYK JPEG images using ImageDecoder\", async () => {\n  const { JpegStream } = await import(\"../../src/core/jpeg_stream.js\");\n  const { JpegImage } = await import(\"../../src/core/jpg.js\");\n\n  const cmykJpegData = new Uint8Array([/* CMYK JPEG data bytes */]);\n  const expected = true;\n\n  JpegStream.setOptions({ isImageDecoderSupported: true });\n  const jpegInfo = JpegImage.canUseImageDecoder(cmykJpegData);\n  const actual = jpegInfo.cmyk && await JpegStream.canUseImageDecoderCMYK;\n\n  expect(actual).toBe(expected);\n});",
    "i5_llama-3.3-70b-versatile": "it(\"should decode cmyk jpeg image using ImageDecoder\", async () => {\n  const { JpegStream } = await import(\"../../src/core/jpeg_stream.js\");\n  const { JpegImage } = await import(\"../../src/core/jpg.js\");\n  const cmykJpegData = new Uint8Array([0xff, 0xd8, 0xff, 0xe0, 0x00, 0x10, 0x4a, 0x46, 0x49, 0x46, 0x00, 0x01, 0x01, 0x00, 0x00, 0x60, 0x00, 0x60, 0x00, 0x00, 0xff, 0xe1, 0x12, 0x4c, 0x45, 0x78, 0x69, 0x66, 0x00, 0x00, 0x4d, 0x4d, 0x00, 0x2a, 0x00, 0x00, 0x00, 0x08, 0x00, 0x02, 0x01, 0x1c, 0x00, 0x02]);\n  const useImageDecoder = { cmyk: true };\n  const stream = new JpegStream(cmykJpegData, useImageDecoder);\n  const decoder = await stream.getDecoder();\n  const expectedType = \"image/x-jpeg-pdf\";\n  expect(decoder.type).toBe(expectedType);\n});"
  },
  "19972": {
    "i1_deepseek-r1-distill-llama-70b": "it(\"should not throw and leave buffer unchanged when minMax is undefined\", async () => {\n  const { OperatorList, DrawOPS } = await import(\"../../src/core/operator_list.js\");\n  const opList = new OperatorList();\n  const transform = [1, 0, 0, 1, 0, 0];\n  const buffer = [DrawOPS.moveTo, 10, 20, DrawOPS.lineTo, 30, 40, DrawOPS.curveTo, 1, 2, 3, 4, 5, 6];\n  const args = [null, [buffer], undefined];\n  expect(() => opList.addState([transform], 0, args)).not.toThrow();\n  expect(buffer).toEqual([DrawOPS.moveTo, 10, 20, DrawOPS.lineTo, 30, 40, DrawOPS.curveTo, 1, 2, 3, 4, 5, 6]);\n});",
    "i1_gpt-4o": "it(\"should not throw and leave buffer unchanged when minMax is undefined\", async () => {\n  const { OperatorList, DrawOPS } = await import(\"../../src/core/operator_list.js\");\n  const opList = new OperatorList();\n  const transform = [1, 0, 0, 1, 0, 0];\n  const buffer = [DrawOPS.moveTo, 10, 20, DrawOPS.lineTo, 30, 40, DrawOPS.curveTo, 1, 2, 3, 4, 5, 6];\n  const args = [null, [buffer], undefined];\n  expect(() => opList.addState([transform], 0, args)).not.toThrow();\n  expect(buffer).toEqual([DrawOPS.moveTo, 10, 20, DrawOPS.lineTo, 30, 40, DrawOPS.curveTo, 1, 2, 3, 4, 5, 6]);\n});",
    "i1_llama-3.3-70b-versatile": "it(\"should not throw and leave buffer unchanged when minMax is undefined\", async () => {\n  const { OperatorList, DrawOPS } = await import(\"../../src/core/operator_list.js\");\n  const opList = new OperatorList();\n  const transform = [1, 0, 0, 1, 0, 0];\n  const buffer = [DrawOPS.moveTo, 10, 20, DrawOPS.lineTo, 30, 40, DrawOPS.curveTo, 1, 2, 3, 4, 5, 6];\n  const args = [null, [buffer], undefined];\n  expect(() => opList.addState([transform], 0, args)).not.toThrow();\n  expect(buffer).toEqual([DrawOPS.moveTo, 10, 20, DrawOPS.lineTo, 30, 40, DrawOPS.curveTo, 1, 2, 3, 4, 5, 6]);\n});",
    "i1_MOCK": "it(\"should not throw and leave buffer unchanged when minMax is undefined\", async () => {\n  const { OperatorList, DrawOPS } = await import(\"../../src/core/operator_list.js\");\n  const opList = new OperatorList();\n  const transform = [1, 0, 0, 1, 0, 0];\n  const buffer = [DrawOPS.moveTo, 10, 20, DrawOPS.lineTo, 30, 40, DrawOPS.curveTo, 1, 2, 3, 4, 5, 6];\n  const args = [null, [buffer], undefined];\n  expect(() => opList.addState([transform], 0, args)).not.toThrow();\n  expect(buffer).toEqual([DrawOPS.moveTo, 10, 20, DrawOPS.lineTo, 30, 40, DrawOPS.curveTo, 1, 2, 3, 4, 5, 6]);\n});",
    "i2_deepseek-r1-distill-llama-70b": "it(\"should not throw and leave buffer unchanged when minMax is undefined\", async () => {\n  const { OperatorList, DrawOPS } = await import(\"../../src/core/operator_list.js\");\n  const opList = new OperatorList();\n  const transform = [1, 0, 0, 1, 0, 0];\n  const buffer = [DrawOPS.moveTo, 10, 20, DrawOPS.lineTo, 30, 40, DrawOPS.curveTo, 1, 2, 3, 4, 5, 6];\n  const args = [null, [buffer], undefined];\n  expect(() => opList.addState([transform], 0, args)).not.toThrow();\n  expect(buffer).toEqual([DrawOPS.moveTo, 10, 20, DrawOPS.lineTo, 30, 40, DrawOPS.curveTo, 1, 2, 3, 4, 5, 6]);\n});",
    "i2_gpt-4o": "it(\"should not throw and leave buffer unchanged when minMax is undefined\", async () => {\n  const { OperatorList, DrawOPS } = await import(\"../../src/core/operator_list.js\");\n  const opList = new OperatorList();\n  const transform = [1, 0, 0, 1, 0, 0];\n  const buffer = [DrawOPS.moveTo, 10, 20, DrawOPS.lineTo, 30, 40, DrawOPS.curveTo, 1, 2, 3, 4, 5, 6];\n  const args = [null, [buffer], undefined];\n  expect(() => opList.addState([transform], 0, args)).not.toThrow();\n  expect(buffer).toEqual([DrawOPS.moveTo, 10, 20, DrawOPS.lineTo, 30, 40, DrawOPS.curveTo, 1, 2, 3, 4, 5, 6]);\n});",
    "i2_llama-3.3-70b-versatile": "it(\"should not throw and leave buffer unchanged when minMax is undefined\", async () => {\n  const { OperatorList, DrawOPS } = await import(\"../../src/core/operator_list.js\");\n  const opList = new OperatorList();\n  const transform = [1, 0, 0, 1, 0, 0];\n  const buffer = [DrawOPS.moveTo, 10, 20, DrawOPS.lineTo, 30, 40, DrawOPS.curveTo, 1, 2, 3, 4, 5, 6];\n  const args = [null, [buffer], undefined];\n  expect(() => opList.addState([transform], 0, args)).not.toThrow();\n  expect(buffer).toEqual([DrawOPS.moveTo, 10, 20, DrawOPS.lineTo, 30, 40, DrawOPS.curveTo, 1, 2, 3, 4, 5, 6]);\n});",
    "i3_deepseek-r1-distill-llama-70b": "it(\"should not throw and leave buffer unchanged when minMax is undefined\", async () => {\n  const { OperatorList, DrawOPS } = await import(\"../../src/core/operator_list.js\");\n  const opList = new OperatorList();\n  const transform = [1, 0, 0, 1, 0, 0];\n  const buffer = [DrawOPS.moveTo, 10, 20, DrawOPS.lineTo, 30, 40, DrawOPS.curveTo, 1, 2, 3, 4, 5, 6];\n  const args = [null, [buffer], undefined];\n  expect(() => opList.addState([transform], 0, args)).not.toThrow();\n  expect(buffer).toEqual([DrawOPS.moveTo, 10, 20, DrawOPS.lineTo, 30, 40, DrawOPS.curveTo, 1, 2, 3, 4, 5, 6]);\n});",
    "i3_gpt-4o": "it(\"should not throw and leave buffer unchanged when minMax is undefined\", async () => {\n  const { OperatorList, DrawOPS } = await import(\"../../src/core/operator_list.js\");\n  const opList = new OperatorList();\n  const transform = [1, 0, 0, 1, 0, 0];\n  const buffer = [DrawOPS.moveTo, 10, 20, DrawOPS.lineTo, 30, 40, DrawOPS.curveTo, 1, 2, 3, 4, 5, 6];\n  const args = [null, [buffer], undefined];\n  expect(() => opList.addState([transform], 0, args)).not.toThrow();\n  expect(buffer).toEqual([DrawOPS.moveTo, 10, 20, DrawOPS.lineTo, 30, 40, DrawOPS.curveTo, 1, 2, 3, 4, 5, 6]);\n});",
    "i3_llama-3.3-70b-versatile": "it(\"should not throw and leave buffer unchanged when minMax is undefined\", async () => {\n  const { OperatorList, DrawOPS } = await import(\"../../src/core/operator_list.js\");\n  const opList = new OperatorList();\n  const transform = [1, 0, 0, 1, 0, 0];\n  const buffer = [DrawOPS.moveTo, 10, 20, DrawOPS.lineTo, 30, 40, DrawOPS.curveTo, 1, 2, 3, 4, 5, 6];\n  const args = [null, [buffer], undefined];\n  expect(() => opList.addState([transform], 0, args)).not.toThrow();\n  expect(buffer).toEqual([DrawOPS.moveTo, 10, 20, DrawOPS.lineTo, 30, 40, DrawOPS.curveTo, 1, 2, 3, 4, 5, 6]);\n});",
    "i4_deepseek-r1-distill-llama-70b": "it(\"should not throw and leave buffer unchanged when minMax is undefined\", async () => {\n  const { OperatorList, DrawOPS } = await import(\"../../src/core/operator_list.js\");\n  const opList = new OperatorList();\n  const transform = [1, 0, 0, 1, 0, 0];\n  const buffer = [DrawOPS.moveTo, 10, 20, DrawOPS.lineTo, 30, 40, DrawOPS.curveTo, 1, 2, 3, 4, 5, 6];\n  const args = [null, [buffer], undefined];\n  expect(() => opList.addState([transform], 0, args)).not.toThrow();\n  expect(buffer).toEqual([DrawOPS.moveTo, 10, 20, DrawOPS.lineTo, 30, 40, DrawOPS.curveTo, 1, 2, 3, 4, 5, 6]);\n});",
    "i4_gpt-4o": "it(\"should not throw and leave buffer unchanged when minMax is undefined\", async () => {\n  const { OperatorList, DrawOPS } = await import(\"../../src/core/operator_list.js\");\n  const opList = new OperatorList();\n  const transform = [1, 0, 0, 1, 0, 0];\n  const buffer = [DrawOPS.moveTo, 10, 20, DrawOPS.lineTo, 30, 40, DrawOPS.curveTo, 1, 2, 3, 4, 5, 6];\n  const args = [null, [buffer], undefined];\n  expect(() => opList.addState([transform], 0, args)).not.toThrow();\n  expect(buffer).toEqual([DrawOPS.moveTo, 10, 20, DrawOPS.lineTo, 30, 40, DrawOPS.curveTo, 1, 2, 3, 4, 5, 6]);\n});",
    "i4_llama-3.3-70b-versatile": "it(\"should not throw and leave buffer unchanged when minMax is undefined\", async () => {\n  const { OperatorList, DrawOPS } = await import(\"../../src/core/operator_list.js\");\n  const opList = new OperatorList();\n  const transform = [1, 0, 0, 1, 0, 0];\n  const buffer = [DrawOPS.moveTo, 10, 20, DrawOPS.lineTo, 30, 40, DrawOPS.curveTo, 1, 2, 3, 4, 5, 6];\n  const args = [null, [buffer], undefined];\n  expect(() => opList.addState([transform], 0, args)).not.toThrow();\n  expect(buffer).toEqual([DrawOPS.moveTo, 10, 20, DrawOPS.lineTo, 30, 40, DrawOPS.curveTo, 1, 2, 3, 4, 5, 6]);\n});",
    "i5_deepseek-r1-distill-llama-70b": "it(\"should not throw and leave buffer unchanged when minMax is undefined\", async () => {\n  const { OperatorList, DrawOPS } = await import(\"../../src/core/operator_list.js\");\n  const opList = new OperatorList();\n  const transform = [1, 0, 0, 1, 0, 0];\n  const buffer = [DrawOPS.moveTo, 10, 20, DrawOPS.lineTo, 30, 40, DrawOPS.curveTo, 1, 2, 3, 4, 5, 6];\n  const args = [null, [buffer], undefined];\n  expect(() => opList.addState([transform], 0, args)).not.toThrow();\n  expect(buffer).toEqual([DrawOPS.moveTo, 10, 20, DrawOPS.lineTo, 30, 40, DrawOPS.curveTo, 1, 2, 3, 4, 5, 6]);\n});",
    "i5_gpt-4o": "it(\"should not throw and leave buffer unchanged when minMax is undefined\", async () => {\n  const { OperatorList, DrawOPS } = await import(\"../../src/core/operator_list.js\");\n  const opList = new OperatorList();\n  const transform = [1, 0, 0, 1, 0, 0];\n  const buffer = [DrawOPS.moveTo, 10, 20, DrawOPS.lineTo, 30, 40, DrawOPS.curveTo, 1, 2, 3, 4, 5, 6];\n  const args = [null, [buffer], undefined];\n  expect(() => opList.addState([transform], 0, args)).not.toThrow();\n  expect(buffer).toEqual([DrawOPS.moveTo, 10, 20, DrawOPS.lineTo, 30, 40, DrawOPS.curveTo, 1, 2, 3, 4, 5, 6]);\n});",
    "i5_llama-3.3-70b-versatile": "it(\"should not throw and leave buffer unchanged when minMax is undefined\", async () => {\n  const { OperatorList, DrawOPS } = await import(\"../../src/core/operator_list.js\");\n  const opList = new OperatorList();\n  const transform = [1, 0, 0, 1, 0, 0];\n  const buffer = [DrawOPS.moveTo, 10, 20, DrawOPS.lineTo, 30, 40, DrawOPS.curveTo, 1, 2, 3, 4, 5, 6];\n  const args = [null, [buffer], undefined];\n  expect(() => opList.addState([transform], 0, args)).not.toThrow();\n  expect(buffer).toEqual([DrawOPS.moveTo, 10, 20, DrawOPS.lineTo, 30, 40, DrawOPS.curveTo, 1, 2, 3, 4, 5, 6]);\n});"
  },
  "20063": {
    "i1_deepseek-r1-distill-llama-70b": "it(\"should render polygon annotation with both stroke and fill colors\", async () => {\n  const { AnnotationFactory } = await import(\"../../src/core/annotation.js\");\n  const { AnnotationType } = await import(\"../../src/shared/util.js\");\n  const { XRefMock } = await import(\"./test_utils.js\");\n  const { Dict } = await import(\"../../src/core/primitives.js\");\n\n  const xref = new XRefMock();\n  const dict = new Dict(xref, {\n    Type: new Name(\"Annot\"),\n    Subtype: new Name(\"Polygon\"),\n    Vertices: [0, 0, 100, 0, 100, 100, 0, 100, 0, 0],\n    CA: 1,\n    IC: [1, 0, 0, 1], // Red fill color\n  });\n\n  const factory = new AnnotationFactory();\n  const annotation = await factory.createAnnotation(dict);\n\n  const svg = await annotation.render();\n\n  // Check that the fill color is present in the SVG\n  const hasFillColor = svg.includes(\"fill=\\\"#ff0000\\\"\");\n  assert(hasFillColor, \"Polygon annotation fill color is missing\");\n});",
    "i1_gpt-4o": "it(\"should render PolygonAnnotation with fill color in PDFjs web viewer\", async () => {\n  const { AnnotationFactory } = await import(\"../../src/core/annotation.js\");\n  const { Dict, Name, Ref } = await import(\"../../src/core/primitives.js\");\n  const { RenderingIntentFlag } = await import(\"../../src/shared/util.js\");\n\n  const dict = new Dict();\n  dict.set(\"Type\", Name.get(\"Annot\"));\n  dict.set(\"Subtype\", Name.get(\"Polygon\"));\n  dict.set(\"Vertices\", [0, 0, 100, 0, 100, 100, 0, 100]);\n  dict.set(\"IC\", [0.5, 0.5, 0.5]); // Fill color\n  dict.set(\"C\", [0, 0, 0]); // Stroke color\n\n  const xref = new XRefMock([{ ref: Ref.get(1, 0), data: dict }]);\n  const annotation = await AnnotationFactory.create(xref, dict, Ref.get(1, 0));\n\n  const appearance = await annotation._getAppearance(\n    null,\n    null,\n    RenderingIntentFlag.DISPLAY,\n    null\n  );\n\n  expect(appearance).toContain(\"B\"); // Check if both fill and stroke are applied\n});",
    "i1_llama-3.3-70b-versatile": "it(\"should render PolygonAnnotation fill color in PDFjs web viewer\", async () => {\n  const { AnnotationFactory, MarkupAnnotation } = await import(\"../../src/core/annotation.js\");\n  const { AnnotationType } = await import(\"../../src/shared/util.js\");\n  const { Dict, Name } = await import(\"../../src/core/primitives.js\");\n  const annotation = new MarkupAnnotation({\n    subtype: AnnotationType.POLYGON,\n    rectangle: [0, 0, 100, 100],\n    vertices: [10, 10, 90, 10, 90, 90, 10, 90],\n    color: [1, 0, 0], // red\n    interiorColor: [0, 1, 0], // green\n    dict: new Dict({\n      Subtype: new Name(\"Polygon\"),\n      Rect: [0, 0, 100, 100],\n      Vertices: [10, 10, 90, 10, 90, 90, 10, 90],\n      C: [1, 0, 0], // red\n      IC: [0, 1, 0], // green\n    }),\n  });\n  const expectedOperator = \"f\";\n  const actualOperator = annotation.pointsCallback([], [0, 0, 100, 100])[2];\n  expect(actualOperator).toBe(expectedOperator);\n});",
    "i2_deepseek-r1-distill-llama-70b": "it(\"should render polygon annotation with fill color\", async () => {\n  const { PDFDocument } = await import(\"../../src/display/api.js\");\n  const { PDFPage } = await import(\"../../src/display/pdf_page.js\");\n  const { PDFJS } = await import(\"../../src/display/pdf_viewer.js\");\n  const { document } = await import(\"./document.pdf\");\n\n  // Mock DOM for PDF.js rendering\n  const dom = {\n    createSVGElement: () => ({ outerHTML: \"\" }),\n    createElement: () => ({}),\n    getElementById: () => ({}),\n  };\n\n  // Initialize PDF.js with mock DOM\n  PDFJS.setDocument(document);\n  const pdf = await PDFDocument.load(document);\n  const page = await pdf.getPage(1);\n  const svg = await page.render({\n    format: \"svg\",\n    canvas: null,\n    viewport: page.getViewport({ scale: 1 }),\n  });\n\n  // Check if SVG contains both fill and stroke attributes\n  const hasFill = svg.outerHTML.includes(\"fill=\");\n  const hasStroke = svg.outerHTML.includes(\"stroke=\");\n\n  expect(hasFill && hasStroke).toBe(true);\n});",
    "i2_gpt-4o": "it(\"should render PolygonAnnotation with both outline and fill color\", async () => {\n  const { AnnotationFactory } = await import(\"../../src/core/annotation.js\");\n  const { Dict, Name } = await import(\"../../src/core/primitives.js\");\n  const { RenderingIntentFlag } = await import(\"../../src/shared/util.js\");\n\n  const dict = new Dict();\n  dict.set(\"Type\", Name.get(\"Annot\"));\n  dict.set(\"Subtype\", Name.get(\"Polygon\"));\n  dict.set(\"Vertices\", [0, 0, 100, 0, 100, 100, 0, 100]);\n  dict.set(\"IC\", [0.5, 0.5, 0.5]); // Fill color\n  dict.set(\"CA\", 1); // Stroke alpha\n  dict.set(\"C\", [0, 0, 0]); // Stroke color\n\n  const annotation = AnnotationFactory.create({\n    dict,\n    xref: null,\n    id: \"test\",\n    subtype: Name.get(\"Polygon\"),\n  });\n\n  const operatorList = {\n    addOp: jest.fn(),\n  };\n\n  await annotation.getOperatorList(operatorList, RenderingIntentFlag.DISPLAY);\n\n  const expectedFillOperator = operatorList.addOp.mock.calls.some(\n    ([op]) => op === \"B\"\n  );\n\n  expect(expectedFillOperator).toBe(true);\n});",
    "i2_llama-3.3-70b-versatile": "it(\"should render PolygonAnnotation with fill color\", async () => {\n  const { PDFDocument } = await import(\"../../src/core/document.js\");\n  const { Annotation } = await import(\"../../src/core/annotation.js\");\n  const { PDFPage } = await import(\"../../src/core/document.js\");\n  const { getRgbColor } = await import(\"../../src/core/colorspace_utils.js\");\n  const { getPdfColorArray } = await import(\"../../src/core/default_appearance.js\");\n\n  const pdfData = await fetch(\"https://github.com/user-attachments/files/21099399/document.pdf\").then(response => response.arrayBuffer());\n  const pdf = await PDFDocument.load(pdfData);\n  const page = await pdf.getPage(1);\n  const annotations = await page.getAnnotations();\n\n  const polygonAnnotation = annotations.find(annotation => annotation instanceof Annotation && annotation.data.annotationType === \"Polygon\");\n  const fillColor = getRgbColor(polygonAnnotation.dict.getArray(\"IC\"), null);\n  const expectedFillColor = getPdfColorArray(fillColor);\n\n  const actualFillColor = polygonAnnotation._setDefaultAppearance({\n    xref: pdf.xref,\n    extra: `${polygonAnnotation.borderStyle.width || 1} w`,\n    strokeColor: polygonAnnotation.color ? getPdfColorArray(polygonAnnotation.color) : [0, 0, 0],\n    strokeAlpha: polygonAnnotation.dict.get(\"CA\"),\n    pointsCallback: (buffer, points) => {\n      for (let i = 0, ii = polygonAnnotation.data.vertices.length; i < ii; i += 2) {\n        buffer.push(`${polygonAnnotation.data.vertices[i]} ${polygonAnnotation.data.vertices[i + 1]} ${i === 0 ? \"m\" : \"l\"}`);\n      }\n      buffer.push(\"f\");\n      return [points[0], points[7], points[2], points[3]];\n    },\n  });\n\n  expect(actualFillColor).toContain(`${expectedFillColor.join(\" \")}`);\n});",
    "i3_deepseek-r1-distill-llama-70b": "it(\"should render filled polygon annotations correctly\", async () => {\n  const xref = new XRefMock();\n  const pdfManager = {\n    ensureCatalog: async () => ({}),\n    getPage: async () => ({}),\n    ensureDoc: async () => ({ numPages: 1 }),\n  };\n\n  const annotationDict = new Dict();\n  annotationDict.set(\"Subtype\", new Name(\"Polygon\"));\n  annotationDict.set(\"Rect\", [0, 0, 100, 100]);\n  annotationDict.set(\"Vertices\", new Float32Array([0, 0, 100, 0, 100, 100, 0, 100]));\n  annotationDict.set(\"IC\", new Name(\"yellow\"));\n  annotationDict.set(\"C\", new Name(\"black\"));\n  annotationDict.set(\"CA\", 1);\n\n  const params = {\n    xref,\n    ref: new Ref(1),\n    annotationGlobals: {\n      pdfManager,\n      acroForm: new Dict(),\n      structTreeRoot: new Dict(),\n      baseUrl: new Dict(),\n      attachments: new Dict(),\n      globalColorSpaceCache: new Dict(),\n    },\n    evaluatorOptions: {},\n  };\n\n  const annotation = await AnnotationFactory.create(params);\n\n  const operatorList = await annotation.getOperatorList(\n    new PartialEvaluator(),\n    new WorkerTask(),\n    RenderingIntentFlag.DISPLAY,\n    null,\n    null\n  );\n\n  const expectedFillOperator = \"f\";\n  const actualOperators = operatorList.opList.ops\n    .map(op => op.cmd)\n    .join(\"\");\n\n  expect(actualOperators).toContain(expectedFillOperator);\n});",
    "i3_gpt-4o": "it(\"should render PolygonAnnotation with fill color in PDFjs\", async () => {\n  const { PolygonAnnotation } = await import(\"../../src/core/annotation.js\");\n  const { Dict, Name } = await import(\"../../src/core/primitives.js\");\n  const xref = new XRefMock();\n  const dict = new Dict(xref);\n  dict.set(\"Subtype\", Name.get(\"Polygon\"));\n  dict.set(\"C\", [0, 0, 0]); // Stroke color\n  dict.set(\"IC\", [1, 0, 0]); // Fill color\n  dict.set(\"Vertices\", [0, 0, 100, 0, 100, 100, 0, 100]);\n  const annotation = new PolygonAnnotation({\n    dict,\n    xref,\n    annotationGlobals: { acroForm: Dict.empty },\n  });\n  const expectedFillColor = [1, 0, 0];\n  const actualFillColor = annotation.data.fillColor;\n  expect(actualFillColor).toEqual(expectedFillColor);\n});",
    "i3_llama-3.3-70b-versatile": "it(\"should render PolygonAnnotation with fill color\", async () => {\n  const pdfData = await fetch('https://github.com/user-attachments/files/21099399/document.pdf').then(response => response.arrayBuffer());\n  const xref = new XRefMock(pdfData);\n  const annotationFactory = new AnnotationFactory();\n  const annotationGlobals = await annotationFactory.createGlobals(xref);\n  const pageIndex = 0;\n  const pageRef = await xref.fetchIfRefAsync(await xref.getPageIndex(pageIndex));\n  const annotations = await xref.fetchIfRefAsync(pageRef).getArray(\"Annots\");\n  const annotation = await annotationFactory.create(xref, annotations[0], annotationGlobals, createIdFactory(), true, null, pageRef);\n  const operatorList = await annotation.getOperatorList(new PartialEvaluator(), new WorkerTask(), RenderingIntentFlag.DISPLAY);\n  const expectedOperator = \"f\";\n  const actualOperator = operatorList.opList.ops[operatorList.opList.ops.length - 2].args[0];\n  assert.equal(actualOperator, expectedOperator, `Expected operator to be \"${expectedOperator}\", but got \"${actualOperator}\"`);\n});",
    "i4_deepseek-r1-distill-llama-70b": "it(\"should render polygon annotation with fill and outline\", async () => {\n  const { PDFDocument, PDFViewer } = await import(\"../../web/pdf_viewer.js\");\n  const { AnnotationFactory } = await import(\"../../src/core/annotation.js\");\n  const { QuadPoints } = await import(\"../../src/core/quadpoints.js\");\n\n  // Create a test PDF with a polygon annotation\n  const pdfData = new Uint8Array([\n    37, 80, 68, 70, 45, 50, 34, 45, 53, 57, 34, 45, 52, 55, 52, 55, 52, 55, 34, 45,\n    87, 34, 68, 67, 0, 1, 0, 1, 84, 34, 106, 0, 0, 0, 34, 12, 57, 34, 0, 1, 0,\n    12, 57, 34, 0, 1, 0, 12, 57, 52, 55, 52, 55, 34, 45, 52, 55, 52, 55, 34, 45,\n    87, 34, 68, 67, 0, 1, 0, 1, 84, 34, 106, 0, 0, 0, 34, 12, 57, 34, 0, 1, 0,\n    12, 57, 0, 1, 0, 12, 57, 52, 55, 52, 55, 34, 45, 52, 55, 52, 55, 34, 45,\n    87, 34, 68, 67, 0, 1, 0, 1, 84, 34, 106, 0, 0, 0, 34, 12, 57, 34, 0, 1,\n    0, 12, 57, 52, 55, 52, 55, 34, 45, 52, 55, 52, 55, 34, 45, 87, 34, 68,\n    67, 0, 1, 0, 1, 84, 34, 106, 0, 0, 0, 34, 12, 57, 34, 0, 1, 0, 12,\n    57, 52, 55, 52, 55, 34, 45, 52, 55, 52, 55, 34, 45, 87, 34, 68, 67,\n    0, 1, 0, 1, 84, 34, 106, 0, 0, 0, 34, 12, 57, 34, 0, 1, 0, 12, 57,\n    52, 55, 52, 55, 34, 45, 52, 55, 52, 55, 34, 45, 87, 34, 68, 67, 0,\n    1, 0, 1, 84, 34, 106, 0, 0, 0, 34, 12, 57, 34, 0, 1, 0, 12, 57, 52,\n    55, 52, 55, 34, 45, 52, 55, 52, 55, 34, 45, 87, 34, 68, 67, 0, 1, 0,\n    1, 84, 34, 106, 0, 0, 0, 34, 12, 57, 34, 0, 1, 0, 12, 57, 52, 55,\n    52, 55, 34, 45, 52, 55, 52, 55, 34, 45, 87, 34, 68, 67, 0, 1, 0, 1,\n    84, 34, 106, 0, 0, 0, 34, 12, 57, 34, 0, 1, 0, 12, 57, 52, 55, 52,\n    55, 34, 45, 52, 55, 52, 55, 34, 45, 87, 34, 68, 67, 0, 1, 0, 1, 84,\n    34, 106, 0, 0, 0, 34, 12, 57, 34, 0, 1, 0, 12, 57, 52, 55, 52, 55,\n    34, 45, 52, 55, 52, 55, 34, 45, 87, 34, 68, 67, 0, 1, 0, 1, 84, 34,\n    106, 0, 0, 0, 34, 12, 57, 34, 0, 1, 0, 12, 57, 52, 55, 52, 55, 34,\n    45, 52, 55, 52, 55, 34, 45, 87, 34, 68, 67, 0, 1, 0, 1, 84, 34, 106,\n    0, 0, 0, 34, 12, 57, 34, 0, 1, 0, 12, 57, 52, 55, 52, 55, 34, 45,\n    52, 55, 52, 55, 34, 45, 87, 34, 68, 67, 0, 1, 0, 1, 84, 34, 106, 0,\n    0, 0, 34, 12, 57, 34, 0, 1, 0, 12, 57, 52, 55, 52, 55, 34, 45, 52,\n    55, 52, 55, 34, 45, 87, 34, 68, 67, 0, 1, 0, 1, 84, 34, 106, 0, 0,\n    0, 34, 12, 57, 34, 0, 1, 0, 12, 57, 52, 55, 52, 55, 34, 45, 52, 55,\n    52, 55, 34, 45, 87, 34, 68, 67, 0, 1, 0, 1, 84, 34, 106, 0, 0, 0,\n    34, 12, 57, 34, 0, 1, 0, 12, 57, 52, 55, 52, 55, 34, 45, 52, 55, 52,\n    55, 34, 45, 87, 34, 68, 67, 0, 1, 0, 1, 84, 34, 106, 0, 0, 0, 34,\n    12, 57, 34, 0, 1, 0, 12, 57, 52, 55, 52, 55, 34, 45, 52, 55, 52, 55,\n    34, 45, 87, 34, 68, 67, 0, 1, 0, 1, 84, 34, 106, 0, 0, 0, 34, 12,\n    57, 34, 0, 1, 0, 12, 57, 52, 55, 52, 55, 34, 45, 52, 55, 52, 55, 34,\n    45, 87, 34, 68, 67, 0, 1, 0, 1, 84, 34, 106, 0, 0, 0, 34, 12, 57,\n    34, 0, 1, 0, 12, 57, 52, 55, 52, 55, 34, 45, 52, 55, 52, 55, 34, 45,\n    87, 34, 68, 67, 0, 1, 0, 1, 84, 34, 106, 0, 0, 0, 34, 12, 57, 34, 0,\n    1, 0, 12, 57, 52, 55, 52, 55, 34, 45, 52, 55, 52, 55, 34, 45, 87, 34,\n    68, 67, 0, 1, 0, 1, 84, 34, 106, 0, 0, 0, 34, 12, 57, 34, 0, 1, 0,\n    12, 57, 52, 55, 52, 55, 34, 45, 52, 55, 52, 55, 34, 45, 87, 34, 68,\n    67, 0, 1, 0, 1, 84, 34, 106, 0, 0, 0, 34, 12, 57, 34, 0, 1, 0, 12,\n    57, 52, 55, 52, 55, 34, 45, 52, 55, 52, 55, 34, 45, 87, 34, 68, 67,\n    0, 1, 0, 1, 84, 34, 106, 0, 0, 0, 34, 12, 57, 34, 0, 1, 0, 12, 57,\n    52, 55, 52, 55, 34, 45, 52, 55, 52, 55, 34, 45, 87, 34, 68, 67, 0,\n    1, 0, 1, 84, 34, 106, 0, 0, 0, 34, 12, 57, 34, 0, 1, 0, 12, 57,\n    52, 55, 52, 55, 34, 45, 52, 55, 52, 55, 34, 45, 87, 34, 68, 67,\n    0, 1, 0, 1, 84, 34, 106, 0, 0, 0, 34, 12, 57, 34, 0, 1, 0, 12,\n    57, 52, 55, 52, 55, 34, 45, 52, 55, 52, 55, 34, 45, 87, 34, 68,\n    67, 0, 1, 0, 1, 84, 34, 106, 0, 0, 0, 34, 12, 57, 34, 0, 1,\n    0, 12, 57, 52, 55, 52, 55, 34, 45, 52, 55, 52, 55, 34, 45, 87,\n    34, 68, 67, 0, 1, 0, 1, 84, 34, 106, 0, 0, 0, 34, 12, 57, 34,\n    0, 1, 0, 12, 57, 52, 55, 52, 55, 34, 45, 52, 55, 52, 55, 34, 45,\n    87, 34, 68, 67, 0, 1, 0, 1, 84, 34, 106, 0, 0, 0, 34, 12, 57,\n    34, 0, 1, 0, 12, 57, 52, 55, 52, 55, 34, 45, 52, 55, 52, 55, 34,\n    45, 87, 34, 68, 67, 0, 1, 0, 1, 84, 34, 106, 0, 0, 0, 34, 12,\n    57, 34, 0, 1, 0, 12, 57, 52, 55, 52, 55, 34, 45, 52, 55, 52, 55,\n    34, 45, 87, 34, 68, 67, 0, 1, 0, 1, 84, 34, 106, 0, 0, 0, 34,\n    12, 57, 34, 0, 1, 0, 12, 57, 52, 55, 52, 55, 34, 45, 52, 55, 52,\n    55, 34, 45, 87, 34, 68, 67, 0, 1, 0, 1, 84, 34, 106, 0, 0, 0,\n    34, 12, 57, 34, 0, 1, 0, 12, 57, 52, 55, 52, 55, 34, 45, 52, 55,\n    52, 55, 34, 45, 87, 34, 68, 67, 0, 1, 0, 1, 84, 34, 106, 0, 0,\n    0, 34, 12, 57, 34, 0, 1, 0, 12, 57, 52, 55, 52, 55, 34, 45, 52,\n    55, 52, 55, 34, 45, 87, 34, 68, 67, 0, 1, 0, 1, 84, 34, 106, 0,\n    0, 0, 34, 12, 57, 34, 0, 1, 0, 12, 57, 52, 55, 52, 55, 34, 45,\n    52, 55, 52, 55, 34, 45, 87, 34, 68, 67, 0, 1, 0, 1, 84, 34, 106,\n    0, 0, 0, 34, 12, 57, 34, 0, 1, 0, 12, 57, 52, 55, 52, 55, 34, 45,\n    52, 55, 52, 55, 34, 45, 87, 34, 68, 67, 0, 1, 0, 1, 84, 34, 106,\n    0, 0, 0, 34, 12, 57, 34, 0, 1, 0, 12, 57, 52, 55, 52, 55, 34, 45,\n    52, 55, 52, 55, 34, 45, 87, 34, 68, 67, 0, 1, 0, 1, 84, 34, 106,\n    0, 0, 0, 34, 12, 57, 34, 0, 1, 0, 12, 57, 52, 55, 52, 55, 34, 45,\n    52, 55, 52, 55, 34, 45, 87, 34, 68, 67, 0, 1, 0, 1, 84, 34, 106,\n    0, 0, 0, 34, 12, 57, 34, 0, 1, 0, 12, 57, 52, 55, 52, 55, 34, 45,\n    52, 55, 52, 55, 34, 45, 87, 34, 68, 67, 0, 1, 0, 1, 84, 34, 106,\n    0, 0, 0, 34, 12, 57, 34, 0, 1, 0, 12, 57, 52, 55, 52, 55, 34, 45,\n    52, 55, 52, 55, 34, 45, 87, 34, 68, 67, 0, 1, 0, 1, 84, 34, 106,\n    0, 0, 0, 34, 12, 57, 34, 0, 1, 0, 12, 57, 52, 55, 52, 55, 34, 45,\n    52, 55, 52, 55, 34, 45, 87, 34, 68, 67, 0, 1, 0, 1, 84, 34, 106,\n    0, 0, 0, 34, 12, 57, 34, 0, 1, 0, 12, 57, 52, 55, 52, 55, 34, 45,\n    52, 55, 52, 55, 34, 45, 87, 34, 68, 67, 0, 1, 0, 1, 84, 34, 106,\n    0, 0, 0, 34, 12, 57, 34, 0, 1, 0, 12, 57, 52, 55, 52, 55, 34, 45,\n    52, 55, 52, 55, 34, 45, 87, 34, 68, 67, 0, 1, 0, 1, 84, 34, 106,\n    0, 0, 0, 34, 12, 57, 34, 0, 1, 0, 12, 57, 52, 55, 52, 55, 34, 45,\n    52, 55, 52, 55, 34, 45, 87, 34, 68, 67, 0, 1, 0, 1, 84, 34, 106,\n    0, 0, 0, 34, 12, 57, 34, 0, 1, 0, 12, 57, 52, 55, 52, 55, 34, 45,\n    52, 55, 52, 55, 34, 45, 87, 34, 68, 67, 0, 1, 0, 1, 84, 34, 106,\n    0, 0, 0, 34, 12, 57, 34, 0, 1, 0, 12, 57, 52, 55, 52, 55, 34, 45,\n    52, 55, 52, 55, 34, 45, 87, 34, 68, 67, 0, 1, 0, 1, 84, 34, 106,\n    0, 0, 0, 34, 12, 57, 34, 0, 1, 0, 12, 57, 52, 55, 52, 55, 34, 45,\n    52, 55, 52, 55, 34, 45, 87, 34, 68, 67, 0, 1, 0, 1, 84, 34, 106,\n    0, 0, 0, 34, 12, 57, 34, 0, 1, 0, 12, 57, 52, 55, 52, 55, 34, 45,\n    52, 55, 52, 55, 34, 45, 87, 34, 68, 67, 0, 1, 0, 1, 84, 34, 106,\n    0, 0, 0, 34, 12, 57, 34, 0, 1, 0, 12, 57, 52, 55, 52, 55, 34, 45,\n    52, 55, 52, 55, 34, 45, 87, 34, 68, 67, 0, 1, 0, 1, 84, 34, 106,\n    0, 0, 0, 34, 12, 57, 34, 0, 1, 0, 12, 57, 52, 55, 52, 55, 34, 45,\n    52, 55, 52, 55, 34, 45, 87, 34, 68, 67, 0, 1, 0, 1, 84, 34, 106,\n    0, 0, 0, 34, 12, 57, 34, 0, 1, 0, 12, 57, 52, 55, 52, 55, 34, 45,\n    52, 55, 52, 55, 34, 45, 87, 34, 68, 67, 0, 1, 0, 1, 84, 34, 106,\n    0, 0, 0, 34, 12, 57, 34, 0, 1, 0, 12, 57, 52, 55, 52, 55, 34, 45,\n    52, 55, 52, 55, 34, 45, 87, 34, 68, 67, 0, 1, 0, 1, 84, 34, 106,\n    0, 0, 0, 34, 12, 57, 34, 0, 1, 0, 12, 57, 52, 55, 52, 55, 34, 45,\n    52, 55, 52, 55, 34, 45, 87, 34, 68, 67, 0, 1, 0, 1, 84, 34, 106,\n    0, 0, 0, 34, 12, 57, 34, 0, 1, 0, 12, 57, 52, 55, 52, 55, 34, 45,\n    52, 55, 52, 55, 34, 45, 87, 34, 68, 67, 0, 1, 0, 1, 84, 34, 106,\n    0, 0, 0, 34, 12, 57, 34, 0, 1, 0, 12, 57, 52, 55, 52, 55, 34, 45,\n    52, 55, 52, 55, 34, 45, 87, 34, 68, 67, 0, 1, 0, 1, 84, 34, 106,\n    0, 0, 0, 34, 12, 57, 34, 0, 1, 0, 12, 57, 52, 55, 52, 55, 34, 45,\n    52, 55, 52, 55, 34, 45, 87, 34, 68, 67, 0, 1, 0, 1, 84, 34, 106,\n    0, 0, 0, 34, 12, 57, 34, 0, 1, 0, 12, 57, 52, 55, 52, 55, 34, 45,\n    52, 55, 52, 55, 34, 45, 87, 34, 68, 67, 0, 1, 0, 1, 84, 34, 106,\n    0, 0, 0, 34, 12, 57, 34, 0, 1, 0, 12, 57, 52, 55, 52, 55, 34, 45,\n    52, 55, 52, 55, 34, 45, 87, 34, 68, 67, 0, 1, 0, 1, 84, 34, 106,\n    0, 0, 0, 34, 12, 57, 34, 0, 1, 0, 12, 57, 52, 55, 52, 55, 34, 45,\n    52, 55, 52, 55, 34, 45, 87, 34, 68, 67, 0, 1, 0, 1, 84, 34, 106,\n    0, 0, 0, 34, 12, 57, 34, 0, 1, 0, 12, 57, 52, 55, 52, 55, 34, 45,\n    52, 55, 52, 55, 34, 45, 87, 34, 68, 67, 0, 1, 0, 1, 84, 34, 106,\n    0, 0, 0, 34, 12, 57, 34, 0, 1, 0, 12, 57, 52, 55, 52, 55, 34, 45,\n    52, 55, 52, 55, 34, 45, 87, 34, 68, 67, 0, 1, 0, 1, 84, 34, 106,\n    0, 0, 0, 34, 12, 57, 34, 0, 1, 0, 12, 57, 52, 55, 52, 55, 34, 45,\n    52, 55, 52, 55, 34, 45, 87, 34, 68, 67, 0, 1, 0, 1, 84, 34, 106,\n    0, 0, 0, 34, 12, 57, 34, 0, 1, 0, 12, 57, 52, 55, 52, 55, 34, 45,\n    52, 55, 52, 55, 34, 45, 87, 34, 68, 67, 0, 1, 0, 1, 84, 34, 106,\n    0, 0, 0, 34, 12, 57, 34, 0, 1, 0, 12, 57, 52, 55, 52, 55, 34, 45,\n    52, 55, 52, 55, 34, 45, 87, 34, 68, 67, 0, 1, 0, 1, 84, 34, 106,\n    0, 0, 0, 34, 12, 57, 34, 0, 1, 0, 12, 57, 52, 55, 52, 55, 34, 45,\n    52, 55, 52, 55, 34, 45, 87, 34, 68, 67, 0, 1, 0, 1, 84, 34, 106,\n    0, 0, 0, 34, 12, 57, 34, 0, 1, 0, 12, 57, 52, 55, 52, 55, 34, 45,\n    52, 55, 52, 55, 34, 45, 87, 34, 68, 67, 0, 1, 0, 1, 84, 34, 106,\n    0, 0, 0, 34, 12, 57, 34, 0, 1, 0, 12, 57, 52, 55, 52, 55, 34, 45,\n    52, 55, 52, 55, 34, 45, 87, 34, 68, 67, 0, 1, 0, 1, 84, 34, 106,\n    0, 0, 0, 34, 12, 57, 34, 0, 1, 0, 12, 57, 52, 55, 52, 55, 34, 45,\n    52, 55, 52, 55, 34, 45, 87, 34, 68, 67, 0, 1, 0, 1, 84, 34, 106,\n    0, 0, 0, 34, 12, 57, 34, 0, 1, 0, 12, 57, 52, 55, 52, 55, 34, 45,\n    52, 55, 52, 55, 34, 45, 87, 34, 68, 67, 0, 1, 0, 1, 84, 34, 106,\n    0, 0, 0, 34, 12, 57, 34, 0, 1, 0, 12, 57, 52, 55, 52, 55, 34, 45,\n    52, 55, 52, 55, 34, 45, 87, 34, 68, 67, 0, 1, 0, 1, 84, 34, 106,\n    0, 0, 0, 34, 12, 57, 34, 0, 1, 0, 12, 57, 52, 55, 52, 55, 34, 45,\n    52, 55, 52, 55, 34, 45, 87, 34, 68, 67, 0, 1, 0, 1, 84, 34, 106,\n    0, 0, 0, 34, 12, 57, 34, 0, 1, 0, 12, 57, 52, 55, 52, 55, 34, 45,\n    52, 55, 52, 55, 34, 45, 87, 34, 68, 67, 0, 1, 0, 1, 84, 34, 106,\n    0, 0, 0, 34, 12, 57, 34, 0, 1, 0, 12, 57, 52, 55, 52, 55, 34, 45,\n    52, 55, 52, 55, 34, 45, 87, 34, 68, 67, 0, 1, 0, 1, 84, 34, 106,\n    0, 0, 0, 34, 12, 57, 34, 0, 1, 0, 12, 57, 52, 55, 52, 55, 34, 45,\n    52, 55, 52, 55, 34, 45, 87, 34, 68, 67, 0, 1, 0, 1, 84, 34, 106,\n    0, 0, 0, 34, 12, 57, 34, 0, 1, 0, 12, 57, 52, 55, 52, 55, 34, 45,\n    52, 55, 52, 55, 34, 45, 87, 34, 68, 67, 0, 1, 0, 1, 84, 34, 106,\n    0, 0, 0, 34, 12, 57, 34, 0, 1, 0, 12, 57, 52, 55, 52, 55, 34, 45,\n    52, 55, 52, 55, 34, 45, 87, 34, 68, 67, 0, 1, 0, 1, 84, 34, 106,\n    0, 0, 0, 34, 12, 57, 34, 0, 1, 0, 12, 57,",
    "i4_gpt-4o": "it(\"should render PolygonAnnotation with fill color in PDFjs web viewer\", async () => {\n  const { AnnotationFactory } = await import(\"../../src/core/annotation.js\");\n  const { Dict, Name, Ref } = await import(\"../../src/core/primitives.js\");\n  const { RenderingIntentFlag } = await import(\"../../src/shared/util.js\");\n\n  const xref = {\n    fetchIfRef: (ref) => ref,\n  };\n\n  const dict = new Dict();\n  dict.set(\"Subtype\", Name.get(\"Polygon\"));\n  dict.set(\"IC\", [0.5, 0.5, 0.5]); // Fill color\n  dict.set(\"C\", [0, 0, 0]); // Stroke color\n  dict.set(\"Vertices\", [0, 0, 1, 1, 2, 2, 3, 3]);\n\n  const annotation = await AnnotationFactory.create(\n    xref,\n    new Ref(1, 0),\n    { pdfManager: { evaluatorOptions: {} } },\n    { createObjId: () => 1 }\n  );\n\n  const intent = RenderingIntentFlag.DISPLAY;\n  const operatorList = await annotation.getOperatorList(\n    { getOperatorList: () => {} },\n    {},\n    intent\n  );\n\n  const expectedOperator = \"B\"; // Expecting both fill and stroke\n  const actualOperator = operatorList.opList.args[operatorList.opList.args.length - 1];\n\n  expect(actualOperator).toBe(expectedOperator);\n});",
    "i4_llama-3.3-70b-versatile": "it(\"should render PolygonAnnotation with fill color\", async () => {\n  const { AnnotationFactory, MarkupAnnotation, PolylineAnnotation, PolygonAnnotation } = await import(\"../../src/core/annotation.js\");\n  const { getQuadPoints } = await import(\"../../src/core/annotation.js\");\n  const { ColorSpaceUtils } = await import(\"../../src/core/colorspace_utils.js\");\n  const { FakeUnicodeFont } = await import(\"../../src/core/default_appearance.js\");\n  const { Dict } = await import(\"../../src/core/primitives.js\");\n  const { Stream } = await import(\"../../src/core/stream.js\");\n  const { Name } = await import(\"../../src/core/primitives.js\");\n  const { Ref } = await import(\"../../src/core/primitives.js\");\n  const { XRef } = await import(\"../../src/core/xref.js\");\n\n  const xref = new XRef();\n  const dict = new Dict(xref);\n  dict.set(\"Subtype\", Name.get(\"Polygon\"));\n  dict.set(\"Rect\", [0, 0, 100, 100]);\n  dict.set(\"Vertices\", [10, 10, 90, 10, 90, 90, 10, 90]);\n  dict.set(\"IC\", [1, 0, 0]); // Red fill color\n  dict.set(\"C\", [0, 0, 0]); // Black border color\n\n  const annotation = await AnnotationFactory.create(xref, new Ref(xref), { pdfManager: {} }, () => {}, false, null, null);\n  const polygonAnnotation = annotation instanceof PolygonAnnotation;\n\n  expect(polygonAnnotation).toBe(true);\n});",
    "i5_deepseek-r1-distill-llama-70b": "it(\"should render polygon annotation with both fill and stroke colors\", async () => {\n  const { TestPdfsServer } = await import(\"../../test_utils.js\");\n  const { PDFDocument, Page } = await import(\"../../src/core/document.js\");\n  const { Annotation, MarkupAnnotation } = await import(\"../../src/core/annotation.js\");\n\n  const server = new TestPdfsServer();\n  const pdfPath = server.addPdf(\n    \"test.pdf\",\n    `\n      %PDF-1.4\n      1 0 obj\n        <</Type /Catalog /Pages 2 0 R>>\n      endobj\n      2 0 obj\n        <</Type /Pages /Kids [3 0 R] /Count 1>>\n      endobj\n      3 0 obj\n        <</Type /Page /Parent 2 0 R /Resources 4 0 R /Contents []>>\n      endobj\n      4 0 obj\n        <</Type /Resources /ExtGState <</G1 5 0 R>>>\n      endobj\n      5 0 obj\n        <</Type /ExtGState /CA 1 /CA 1>>\n      endobj\n      6 0 obj\n        <</Type /Annot /Subtype /Polygon /Vertices [0 0 0 1 1 1 1 0] /IC [255 0 0] /CA 0.5>>\n      endobj\n    `\n  );\n\n  const pdf = await PDFDocument.load(await fetch(pdfPath).then((res) => res.blob()));\n  const page = await pdf.getPage(1);\n  const annotation = new MarkupAnnotation();\n  const render = await page.render({\n    viewport: page.getViewport({ scale: 1 }),\n    annotationMode: \"all\",\n  });\n\n  const canvas = document.createElement(\"canvas\");\n  const ctx = canvas.getContext(\"2d\");\n  await render.renderCanvas(ctx);\n\n  const expectedFillColor = [255, 0, 0];\n  const expectedStrokeColor = [0, 0, 0];\n  const pixels = ctx.getImageData(0, 0, canvas.width, canvas.height).data;\n\n  // Check fill color (red) in the center of the polygon\n  const center = {\n    x: canvas.width / 2,\n    y: canvas.height / 2,\n  };\n  const centerPixel = ctx.getImageData(center.x, center.y, 1, 1).data;\n\n  expect(centerPixel[0]).toBe(expectedFillColor[0]);\n  expect(centerPixel[1]).toBe(expectedFillColor[1]);\n  expect(centerPixel[2]).toBe(expectedFillColor[2]);\n\n  // Check stroke color (black) on the border\n  const edgePixel = ctx.getImageData(canvas.width - 1, canvas.height - 1, 1, 1).data;\n  expect(edgePixel[0]).toBe(expectedStrokeColor[0]);\n  expect(edgePixel[1]).toBe(expectedStrokeColor[1]);\n  expect(edgePixel[2]).toBe(expectedStrokeColor[2]);\n});",
    "i5_gpt-4o": "it(\"should render PolygonAnnotation with both outline and fill color\", async () => {\n  const { PDFDocumentProxy, getDocument } = await import(\"../../src/display/api.js\");\n  const { AnnotationLayer } = await import(\"../../src/display/annotation_layer.js\");\n  const { RenderingIntentFlag } = await import(\"../../src/shared/util.js\");\n\n  const loadingTask = getDocument(\"path/to/document.pdf\");\n  const pdfDocument = await loadingTask.promise;\n  const page = await pdfDocument.getPage(1);\n  const annotations = await page.getAnnotations({ intent: RenderingIntentFlag.DISPLAY });\n\n  const polygonAnnotation = annotations.find(ann => ann.subtype === \"Polygon\");\n  const annotationLayer = new AnnotationLayer();\n  const renderResult = annotationLayer.render({\n    annotations: [polygonAnnotation],\n    viewport: page.getViewport({ scale: 1.0 }),\n    div: document.createElement(\"div\"),\n    intent: RenderingIntentFlag.DISPLAY,\n  });\n\n  const expectedFillColor = [1, 0, 0]; // Example fill color in RGB\n  const actualFillColor = renderResult.annotations[0].fillColor;\n\n  expect(actualFillColor).toEqual(expectedFillColor);\n});",
    "i5_llama-3.3-70b-versatile": "it(\"should render PolygonAnnotation with fill color in PDFjs web viewer\", async () => {\n  const { PDFDocument } = await import(\"../../src/display/api.js\");\n  const { AnnotationLayerBuilder } = await import(\"../../web/annotation_layer_builder.js\");\n  const pdfData = await (await import(\"../../src/display/node_utils.js\")).fetchData(\"https://github.com/user-attachments/files/21099399/document.pdf\");\n  const pdf = await PDFDocument.load(pdfData);\n  const page = await pdf.getPage(1);\n  const viewport = page.getViewport({ scale: 1 });\n  const annotationLayer = new AnnotationLayerBuilder().build({\n    page,\n    viewport,\n    renderInteractiveForms: false,\n  });\n  const annotations = await page.getAnnotations();\n  const polygonAnnotation = annotations.find((annotation) => annotation.subtype === \"Polygon\");\n  const fillColor = polygonAnnotation.getFillColor();\n  const expectedFillColor = [1, 0, 0]; // Assuming the fill color is red\n  expect(fillColor).toEqual(expectedFillColor);\n});"
  },
  "20101": {
    "i1_deepseek-r1-distill-llama-70b": "it(\"should render text when browserdisplayusedocumentfonts is disabled\", async () => {\n  const { PDFDataLoader } = await import(\"../../src/display/api.js\");\n  const { PDFDocument } = await import(\"../../src/display/document.js\");\n  const { PDFPage } = await import(\"../../src/display/document.js\");\n  const { PDFViewer } = await import(\"../../src/web/pdf_viewer.js\");\n  const { PDFRenderer } = await import(\"../../src/display/canvas.js\");\n\n  // Create a minimal PDF with text\n  const pdfData = new Uint8Array([\n    0x25, 0x50, 0x44, 0x46, 0x2D, 0x31, 0x2E, 0x30, 0x0A, 0x25, 0x5E, 0x5E, 0x5E, 0x5E, 0x0A,\n    0x31, 0x20, 0x30, 0x20, 0x72, 0x65, 0x66, 0x0A, 0x34, 0x35, 0x30, 0x30, 0x39, 0x34, 0x0A,\n    0x32, 0x30, 0x20, 0x30, 0x20, 0x72, 0x65, 0x66, 0x0A, 0x34, 0x35, 0x30, 0x30, 0x39, 0x34, 0x0A,\n    0x38, 0x20, 0x30, 0x20, 0x72, 0x65, 0x66, 0x0A, 0x34, 0x35, 0x30, 0x30, 0x39, 0x34, 0x0A,\n    0x25, 0x50, 0x44, 0x46, 0x2D, 0x31, 0x2E, 0x30, 0x0A\n  ]);\n\n  // Mock browser.display.use_document_fonts\n  const originalUseDocumentFonts = globalThis.navigator.browser.display.use_document_fonts;\n  globalThis.navigator.browser.display.use_document_fonts = () => 0;\n\n  try {\n    const loader = new PDFDataLoader({\n      data: pdfData,\n    });\n    const pdf = await PDFDocument.load(loader);\n    const page = await pdf.getPage(1);\n    const viewer = new PDFViewer();\n    const renderer = new PDFRenderer({\n      canvasCtx: {\n        save: () => {},\n        restore: () => {},\n        scale: () => {},\n        translate: () => {},\n        fillText: () => {},\n        strokeText: () => {},\n        measureText: () => ({ width: 0 }),\n        getTransform: () => new DOMMatrix(),\n        setTransform: () => {},\n      },\n    });\n\n    await page.startRendering({\n      viewport: page.getViewport({ scale: 1 }),\n      renderInteractive: false,\n    });\n\n    const canvas = renderer.canvasCtx;\n    const expectedText = \"Test String\";\n    const actualText = canvas.fillText;\n\n    expect(actualText).toBeTruthy();\n  } finally {\n    globalThis.navigator.browser.display.use_document_fonts = originalUseDocumentFonts;\n  }\n});",
    "i1_gpt-4o": "it(\"should render text correctly when browserdisplayusedocumentfonts is set to\", async () => {\n  const { getDocument } = await import(\"../../src/display/api.js\");\n  const { buildGetDocumentParams } = await import(\"./test_utils.js\");\n\n  const loadingTask = getDocument(buildGetDocumentParams(\"https://www.jma.go.jp/jma/press/2507/04a/20250704_asosan.pdf\"));\n  const pdfDocument = await loadingTask.promise;\n  const pdfPage = await pdfDocument.getPage(1);\n\n  const viewport = pdfPage.getViewport({ scale: 1.0 });\n  const canvasFactory = new (await import(\"../../src/display/canvas_factory.js\")).DOMCanvasFactory();\n  const canvasAndContext = canvasFactory.create(viewport.width, viewport.height);\n  const renderTask = pdfPage.render({\n    canvasContext: canvasAndContext.context,\n    viewport,\n  });\n\n  await renderTask.promise;\n  const imageData = canvasAndContext.context.getImageData(0, 0, viewport.width, viewport.height);\n  const hasVisibleText = imageData.data.some((value, index) => index % 4 === 3 && value > 0);\n\n  expect(hasVisibleText).toBe(true);\n});",
    "i1_llama-3.3-70b-versatile": "it(\"should render text correctly when browserdisplayusedocumentfonts is set to\", async () => {\n  const { PDFDocument } = await import(\"../../src/display/api.js\");\n  const { PDFPageProxy } = await import(\"../../src/display/api.js\");\n  const { PDFViewer } = await import(\"../../src/web/pdf_viewer.js\");\n  const pdfUrl = \"https://www.jma.go.jp/jma/press/2507/04a/20250704_asosan.pdf\";\n  const pdfDocument = await PDFDocument.load(pdfUrl);\n  const pdfPage = await pdfDocument.getPage(1);\n  const pdfPageProxy = new PDFPageProxy(pdfPage);\n  const pdfViewer = new PDFViewer();\n  pdfViewer.setDocumentAndPage(pdfDocument, pdfPageProxy);\n  const canvas = document.createElement(\"canvas\");\n  const ctx = canvas.getContext(\"2d\");\n  const canvasGraphics = new (await import(\"../../src/display/canvas.js\")).CanvasGraphics(ctx, {}, {}, {}, {}, {}, {}, {});\n  const textRenderingMode = (await import(\"../../src/shared/util.js\")).TextRenderingMode.FILL;\n  const fontSize = 16;\n  const character = \"A\";\n  const x = 10;\n  const y = 20;\n  const font = await (await import(\"../../src/core/fonts_utils.js\")).getFontSubstitution(\"Helvetica\");\n  const current = { font, textRenderingMode, fontSize };\n  canvasGraphics.current = current;\n  canvasGraphics.paintChar(character, x, y, null, null);\n  const expectedText = \"A\";\n  const actualText = canvasGraphics.ctx.canvas.toDataURL();\n  const expectedTextData = new TextDecoder(\"utf-8\").decode((await import(\"../../src/shared/util.js\")).stringToBytes(expectedText));\n  const actualTextData = new TextDecoder(\"utf-8\").decode((await import(\"../../src/shared/util.js\")).stringToBytes(actualText));\n  expect(actualTextData).toContain(expectedTextData);\n});",
    "i2_gpt-4o": "it(\"should display text when browserdisplayusedocumentfonts is set to\", async () => {\n  const { getDocument } = await import(\"../../src/display/api.js\");\n  const { PDFNodeStream } = await import(\"../../src/display/node_stream.js\");\n  const { PDFPageProxy } = await import(\"../../src/display/api.js\");\n\n  const url = \"https://www.jma.go.jp/jma/press/2507/04a/20250704_asosan.pdf\";\n  const loadingTask = getDocument({ url, disableFontFace: true });\n  const pdfDocument = await loadingTask.promise;\n  const page = await pdfDocument.getPage(1);\n\n  const viewport = page.getViewport({ scale: 1.0 });\n  const canvasFactory = new (await import(\"../../src/display/canvas_factory.js\")).DOMCanvasFactory();\n  const canvasAndContext = canvasFactory.create(viewport.width, viewport.height);\n  const renderContext = {\n    canvasContext: canvasAndContext.context,\n    viewport: viewport,\n  };\n\n  await page.render(renderContext).promise;\n\n  const imageData = canvasAndContext.context.getImageData(0, 0, viewport.width, viewport.height);\n  const hasVisibleText = Array.from(imageData.data).some((value, index) => index % 4 === 3 && value > 0);\n\n  expect(hasVisibleText).toBe(true);\n});",
    "i2_llama-3.3-70b-versatile": "it(\"should render text correctly when font file is missing and browserdisplayusedocumentfonts is set to\", async () => {\n  const { PDFDocument } = await import(\"../../src/display/api.js\");\n  const { PDFPage } = await import(\"../../src/display/api.js\");\n  const pdfUrl = \"https://www.jma.go.jp/jma/press/2507/04a/20250704_asosan.pdf\";\n  const pdf = await PDFDocument.load(pdfUrl);\n  const page = await pdf.getPage(1);\n  const canvas = document.createElement(\"canvas\");\n  const ctx = canvas.getContext(\"2d\");\n  const renderTask = page.render({\n    canvasContext: ctx,\n    viewport: page.getViewport({ scale: 1 }),\n  });\n  await renderTask.promise;\n  const expectedText = \"Example Text\";\n  const actualText = ctx.canvas.toDataURL();\n  const expectedCanvas = document.createElement(\"canvas\");\n  const expectedCtx = expectedCanvas.getContext(\"2d\");\n  expectedCtx.font = \"16px Arial\";\n  expectedCtx.textBaseline = \"top\";\n  expectedCtx.fillText(expectedText, 0, 0);\n  const expectedDataUrl = expectedCanvas.toDataURL();\n  expect(actualText).not.toBe(expectedDataUrl);\n});",
    "i3_deepseek-r1-distill-llama-70b": "it(\"should render text when document fonts are disabled\", async () => {\n  const { PDFDocument } = await import(\"../../src/display/api.js\");\n  const { createIdFactory } = await import(\"./test_utils.js\");\n\n  // Create a test server for the PDF file\n  const pdfUrl = \"test.pdf\";\n  const pdfContent = new Uint8Array([0x25, 0x50, 0x44, 0x46]);\n\n  // Set up the browser environment\n  const idFactory = createIdFactory();\n  const xref = new XRefMock();\n  xref.add(0, \"obj\", new Dict());\n\n  // Create a minimal PDF document\n  const pdf = await PDFDocument.create(xref);\n  const page = await pdf.getPage(0);\n\n  // Mock the about:config setting\n  const originalUseDocumentFonts = globalThis.navigator.browser.display.use_document_fonts;\n  globalThis.navigator.browser.display.use_document_fonts = 0;\n\n  try {\n    // Create a canvas to draw the page\n    const canvas = document.createElement(\"canvas\");\n    const ctx = canvas.getContext(\"2d\");\n\n    // Set up the drawing context\n    const viewport = page.getViewBox();\n    canvas.width = viewport.width;\n    canvas.height = viewport.height;\n\n    // Draw the page content\n    const renderTask = page.render({\n      canvasContext: ctx,\n      viewport,\n    });\n\n    await renderTask.promise;\n\n    // Check if the text is rendered\n    const expectedText = \"Hello World\";\n    const actualText = ctx.canvas.toDataURL();\n\n    // Assert the text is present\n    expect(actualText).toContain(expectedText);\n  } finally {\n    // Restore the original setting\n    globalThis.navigator.browser.display.use_document_fonts = originalUseDocumentFonts;\n  }\n});",
    "i3_gpt-4o": "it(\"should render text correctly when browserdisplayusedocumentfonts is set to\", async () => {\n  const { getDocument } = await import(\"../../src/display/api.js\");\n  const { PDFNodeStream } = await import(\"../../src/display/node_stream.js\");\n  const { PDFDocumentLoadingTask } = await import(\"../../src/display/api.js\");\n\n  const loadingTask = getDocument({\n    url: \"https://www.jma.go.jp/jma/press/2507/04a/20250704_asosan.pdf\",\n    disableFontFace: true,\n  });\n\n  const pdfDocument = await loadingTask.promise;\n  const page = await pdfDocument.getPage(1);\n\n  const viewport = page.getViewport({ scale: 1.0 });\n  const canvasFactory = new PDFNodeStream();\n  const canvasAndContext = canvasFactory.create(viewport.width, viewport.height);\n  const renderContext = {\n    canvasContext: canvasAndContext.context,\n    viewport: viewport,\n  };\n\n  const renderTask = page.render(renderContext);\n  await renderTask.promise;\n\n  const imageData = canvasAndContext.context.getImageData(0, 0, viewport.width, viewport.height);\n  const hasVisibleText = imageData.data.some((value, index) => index % 4 === 3 && value > 0);\n\n  expect(hasVisibleText).toBe(true);\n});",
    "i3_llama-3.3-70b-versatile": "it(\"should render text correctly when browserdisplayusedocumentfonts is set to\", async () => {\n  const { CanvasGraphics } = await import(\"../../src/display/canvas.js\");\n  const { PDFDocument } = await import(\"../../src/core/document.js\");\n  const { Lexer, Parser } = await import(\"../../src/core/parser.js\");\n  const { StringStream } = await import(\"../../src/core/stream.js\");\n  const { writeChanges } = await import(\"../../src/core/writer.js\");\n  const { XRefMock } = await import(\"./test_utils.js\");\n\n  const pdfData = await fetch(\"https://www.jma.go.jp/jma/press/2507/04a/20250704_asosan.pdf\").then(response => response.arrayBuffer());\n  const pdfDocument = await PDFDocument.load(pdfData, { cMapUrl: CMAP_URL, cMapPacked: true, standardFontDataUrl: STANDARD_FONT_DATA_URL });\n  const page = await pdfDocument.getPage(1);\n  const canvas = document.createElement(\"canvas\");\n  const ctx = canvas.getContext(\"2d\");\n  const canvasGraphics = new CanvasGraphics(ctx, new Map(), new Map(), { create: () => ({ context: ctx, canvas }) }, {}, {});\n\n  const renderTask = page.render({\n    canvasContext: ctx,\n    viewport: page.getViewport({ scale: 1 }),\n  });\n\n  await renderTask.promise;\n\n  const text = ctx.canvas.toDataURL();\n  const expectedText = \"Some text from the PDF\"; // Replace with actual expected text\n  const actualText = await getTextFromCanvas(canvas);\n  expect(actualText).toContain(expectedText);\n});\n\nasync function getTextFromCanvas(canvas) {\n  const ctx = canvas.getContext(\"2d\");\n  const pixels = ctx.getImageData(0, 0, canvas.width, canvas.height).data;\n  const text = [];\n  for (let i = 0; i < pixels.length; i += 4) {\n    if (pixels[i + 3] !== 0) {\n      text.push(String.fromCharCode(pixels[i]));\n    }\n  }\n  return text.join(\"\");\n}",
    "i4_deepseek-r1-distill-llama-70b": "it(\"should render text when usedocumentfonts is disabled\", async () => {\n  const { PDFDocument, PDFPage, PDFPageRenderOptions, PDFDocumentLoader } = await import(\"../../src/display/api.js\");\n  const { createMinimalPdf } = await import(\"../../test/src/helpers/create_minimal_pdf.js\");\n\n  // Create a minimal PDF with text\n  const pdfBytes = await createMinimalPdf(\"Hello World\");\n  const loader = new PDFDocumentLoader(pdfBytes);\n  const pdf = await PDFDocumentLoader.loadPdf(new Uint8Array(pdfBytes), {\n    // Simulate browser.display.use_document_fonts = 0\n    createBrowser: () => ({\n      get fullVersion() { return \"20200101\"; },\n      get pdfjsVersion() { return \"2.5.207\"; },\n      get pdfjsBuild() { return \"latest\"; },\n      get useDocumentFonts() { return 0; },\n      get enableWebGL() { return true; },\n      get enableCanvas() { return true; },\n      get disableFontFace() { return false; },\n    }),\n  });\n\n  const page = await pdf.getPage(1);\n  const viewport = page.getViewport({ scale: 1 });\n  const renderOptions = new PDFPageRenderOptions({\n    viewport,\n    enableWebGL: true,\n    enableCanvas: true,\n    useCanvas: true,\n  });\n\n  const canvas = await page.render(renderOptions);\n  const ctx = canvas.getContext(\"2d\");\n  const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);\n\n  // Check if the text is rendered\n  let hasNonTransparentPixels = false;\n  for (let i = 0; i < imageData.data.length; i += 4) {\n    if (imageData.data[i + 3] !== 0) {\n      hasNonTransparentPixels = true;\n      break;\n    }\n  }\n\n  expect(hasNonTransparentPixels).toBe(true);\n});",
    "i4_gpt-4o": "it(\"should render text correctly when browserdisplayusedocumentfonts is set to\", async () => {\n  const { getDocument } = await import(\"../../src/display/api.js\");\n  const { PDFNodeStream } = await import(\"../../src/display/node_stream.js\");\n  const { PDFDocumentProxy } = await import(\"../../src/display/api.js\");\n  const { PDFPageProxy } = await import(\"../../src/display/api.js\");\n  const { NodeCMapReaderFactory } = await import(\"../../src/display/node_utils.js\");\n  const { NodeStandardFontDataFactory } = await import(\"../../src/display/node_utils.js\");\n\n  const url = \"https://www.jma.go.jp/jma/press/2507/04a/20250704_asosan.pdf\";\n  const loadingTask = getDocument({\n    url,\n    disableFontFace: true,\n    CMapReaderFactory: NodeCMapReaderFactory,\n    StandardFontDataFactory: NodeStandardFontDataFactory,\n  });\n\n  const pdfDocument = await loadingTask.promise;\n  const page = await pdfDocument.getPage(1);\n  const viewport = page.getViewport({ scale: 1.0 });\n\n  const canvasFactory = new (await import(\"../../src/display/canvas_factory.js\")).DOMCanvasFactory();\n  const canvasAndContext = canvasFactory.create(viewport.width, viewport.height);\n  const renderContext = {\n    canvasContext: canvasAndContext.context,\n    viewport: viewport,\n  };\n\n  const renderTask = page.render(renderContext);\n  await renderTask.promise;\n\n  const imageData = canvasAndContext.context.getImageData(0, 0, viewport.width, viewport.height);\n  const hasVisibleText = imageData.data.some((value, index) => index % 4 === 3 && value > 0);\n\n  expect(hasVisibleText).toBe(true);\n});",
    "i4_llama-3.3-70b-versatile": "it(\"should render text correctly when browserdisplayusedocumentfonts is set to\", async () => {\n  const { PDFDocument } = await import(\"../../src/display/api.js\");\n  const { PDFPage } = await import(\"../../src/display/api.js\");\n  const { getDocument } = await import(\"../../src/display/api.js\");\n  const { createLoadingTask } = await import(\"../../src/display/api.js\");\n  const { PDFViewer } = await import(\"../../web/pdf_viewer.js\");\n  const { PDFPageView } = await import(\"../../web/pdf_page_view.js\");\n\n  const pdfUrl = \"https://www.jma.go.jp/jma/press/2507/04a/20250704_asosan.pdf\";\n  const pdfDocument = await getDocument({ url: pdfUrl }).promise;\n  const pdfPage = await pdfDocument.getPage(1);\n  const pdfPageView = new PDFPageView({ pdfPage });\n  const pdfViewer = new PDFViewer();\n  pdfViewer.setDocument(pdfDocument);\n  pdfViewer.setPageView(pdfPageView);\n\n  const canvas = document.createElement(\"canvas\");\n  const ctx = canvas.getContext(\"2d\");\n  const renderTask = pdfPageView.render({\n    canvasContext: ctx,\n    viewport: pdfPageView.viewport,\n  });\n\n  await renderTask.promise;\n\n  const textData = await pdfPage.getTextContent();\n  const expectedText = textData.items.map(item => item.str).join(\"\");\n  const actualText = ctx.canvas.toDataURL();\n\n  // This is a very basic test and might not cover all cases.\n  // A more sophisticated test would involve checking the actual text rendering.\n  expect(actualText).not.toContain(\"mojibake\");\n});",
    "i5_gpt-4o": "it(\"should render text correctly when browserdisplayusedocumentfonts is set to\", async () => {\n  const { getDocument } = await import(\"../../src/display/api.js\");\n  const { PDFNodeStream } = await import(\"../../src/display/node_stream.js\");\n  const { PDFPageProxy } = await import(\"../../src/display/api.js\");\n\n  const url = \"https://www.jma.go.jp/jma/press/2507/04a/20250704_asosan.pdf\";\n  const loadingTask = getDocument({ url, disableFontFace: true });\n  const pdfDocument = await loadingTask.promise;\n  const page = await pdfDocument.getPage(1);\n\n  const viewport = page.getViewport({ scale: 1.0 });\n  const canvasFactory = new (await import(\"../../src/display/canvas_factory.js\")).DOMCanvasFactory();\n  const canvasAndContext = canvasFactory.create(viewport.width, viewport.height);\n  const renderContext = {\n    canvasContext: canvasAndContext.context,\n    viewport: viewport,\n  };\n\n  const renderTask = page.render(renderContext);\n  await renderTask.promise;\n\n  const imageData = canvasAndContext.context.getImageData(0, 0, viewport.width, viewport.height);\n  const hasVisibleText = Array.from(imageData.data).some(value => value !== 0);\n\n  expect(hasVisibleText).toBe(true);\n});",
    "i5_llama-3.3-70b-versatile": "it(\"should render text correctly when browserdisplayusedocumentfonts is set to\", async () => {\n  const { PDFDocument } = await import(\"../../src/display/api.js\");\n  const { PDFPageProxy } = await import(\"../../src/display/api.js\");\n  const { TextLayer } = await import(\"../../src/display/text_layer.js\");\n  const { PDFDataRangeTransport } = await import(\"../../src/display/api.js\");\n  const { PDFWorker } = await import(\"../../src/display/api.js\");\n  const { DOMCanvasFactory } = await import(\"../../src/display/canvas_factory.js\");\n  const { PDFNetworkStream } = await import(\"../../src/display/network.js\");\n\n  const pdfUrl = \"https://www.jma.go.jp/jma/press/2507/04a/20250704_asosan.pdf\";\n  const pdfDocument = await PDFDocument.load({ url: pdfUrl, cMapUrl: \"https://cdn.jsdelivr.net/npm/pdfjs-dist@2.16.105/build/generic/web/cmaps/\", cMapPacked: true });\n  const pdfPage = await pdfDocument.getPage(1);\n  const textLayer = new TextLayer({\n    text: await pdfPage.getTextContent(),\n    viewport: pdfPage.getViewport({ scale: 1 }),\n    div: document.createElement(\"div\"),\n  });\n  const canvasFactory = new DOMCanvasFactory();\n  const renderTask = pdfPage.render({\n    canvasContext: canvasFactory.createContext(100, 100),\n    viewport: pdfPage.getViewport({ scale: 1 }),\n  });\n  await renderTask.promise;\n  const textLayerRendered = textLayer.render();\n  const expectedText = \"Some expected text from the PDF\";\n  const actualText = textLayerRendered.textContent;\n  expect(actualText).toContain(expectedText);\n});"
  },
  "20113": {
    "i1_deepseek-r1-distill-llama-70b": "it(\"should correctly handle HTML spec PDFs when printed to PDF\", async () => {\n  const { TestPdfsServer } = await import(\"./test_utils.js\");\n  const { getDocument } = await import(\"../../src/display/api.js\");\n\n  const server = new TestPdfsServer();\n  try {\n    await server.start();\n    const pdfPath = `${TEST_PDFS_PATH}/html-spec.pdf`;\n    const loadingTask = await getDocument({\n      url: server.url + pdfPath,\n      transport: new PDFDataRangeTransport(),\n    });\n    const document = await loadingTask.document;\n    // If we don't get an exception, the test passes (since previously it would fail)\n  } catch (error) {\n    if (error instanceof InvalidPDFException) {\n      throw new Error(\"PDF is invalid even after the fix\");\n    }\n  } finally {\n    await server.stop();\n  }\n});",
    "i1_gpt-4o": "it(\"should correctly open a PDF with mismatched xref table entries in Firefox\", async () => {\n  const { getDocument } = await import(\"../../src/display/api.js\");\n  const { buildGetDocumentParams } = await import(\"./test_utils.js\");\n  const pdfUrl = `${TEST_PDFS_PATH}mismatched_xref_table.pdf`;\n  const loadingTask = getDocument(buildGetDocumentParams(pdfUrl));\n  const pdfDocument = await loadingTask.promise;\n  const numPages = pdfDocument.numPages;\n  expect(numPages).toBeGreaterThan(0);\n  await pdfDocument.getPage(1);\n  await loadingTask.destroy();\n});",
    "i1_llama-3.3-70b-versatile": "it(\"should resolve the issue with HTML Spec page printed to PDF not opening in Firefox\", async () => {\n  const { PDFDocumentProxy, PDFDocumentLoadingTask, PDFWorker } = await import(\"../../src/display/api.js\");\n  const { buildGetDocumentParams, TestPdfsServer } = await import(\"./test_utils.js\");\n  const server = new TestPdfsServer();\n  const pdfUrl = `${server.url}/html-spec.pdf`;\n  const params = buildGetDocumentParams(pdfUrl);\n  const worker = new PDFWorker({ workerSrc: \"../../build/generic/build/pdf.worker.mjs\" });\n  const loadingTask = PDFDocumentLoadingTask.fromURL(pdfUrl, params);\n  const document = await loadingTask.promise;\n  const firstPage = await document.getPage(1);\n  const viewport = firstPage.getViewport({ scale: 1 });\n  const renderTask = firstPage.render({\n    viewport,\n    intent: \"display\",\n  });\n  await renderTask.promise;\n  const pdfDocumentProxy = new PDFDocumentProxy(document);\n  await pdfDocumentProxy.ensureDoc();\n  const xref = pdfDocumentProxy.xref;\n  const firstXRefStmPos = xref.#firstXRefStmPos;\n  expect(firstXRefStmPos).not.toBeNull();\n});",
    "i2_deepseek-r1-distill-llama-70b": "it(\"should correctly handle xref entries with mismatched generation numbers\", async () => {\n  const { XRef } = await import(\"../../src/core/xref.js\");\n  const { Ref } = await import(\"../../src/core/primitives.js\");\n\n  // Create a mock stream and pdfManager for testing\n  const stream = {\n    makeSubStream: () => ({ start: 0, end: 0 }),\n    dict: { First: 0, N: 1 }\n  };\n  const pdfManager = { getStdFont: async () => null };\n\n  const xref = new XRef(stream, pdfManager);\n  const ref = Ref.get(1, 0);\n\n  try {\n    await xref.fetchCompressed(ref, { offset: 0, gen: 0 });\n    assert(true, \"Expected XRefEntryException to be thrown but wasn't\");\n  } catch (error) {\n    if (error instanceof XRefEntryException) {\n      assert(true, \"Correctly throws XRefEntryException for mismatched gen\");\n    } else {\n      assert(false, `Unexpected error: ${error.message}`);\n    }\n  }\n});",
    "i2_gpt-4o": "it(\"should fix the xref table with correct generation numbers\", async () => {\n  const { XRef } = await import(\"../../src/core/xref.js\");\n  const { Ref } = await import(\"../../src/core/primitives.js\");\n  const { BaseStream } = await import(\"../../src/core/base_stream.js\");\n  const { Parser } = await import(\"../../src/core/parser.js\");\n  const { Lexer } = await import(\"../../src/core/parser.js\");\n\n  const mockStream = new BaseStream();\n  const mockPdfManager = {};\n  const xref = new XRef(mockStream, mockPdfManager);\n\n  const mockXRefEntry = { offset: 0, gen: 1 };\n  const mockRef = Ref.get(1, 0);\n  const mockObjStmStream = {\n    dict: {\n      get: (key) => {\n        if (key === \"First\") return 0;\n        if (key === \"N\") return 2;\n      },\n    },\n    start: 0,\n    makeSubStream: () => new BaseStream(),\n  };\n\n  xref.entries[1] = { offset: 0, gen: 0 };\n  xref.fetch = () => mockObjStmStream;\n\n  const parser = new Parser({\n    lexer: new Lexer(mockObjStmStream),\n    xref,\n    allowStreams: true,\n  });\n\n  parser.getObj = () => 1;\n\n  const expected = 1;\n  const actual = xref.fetchCompressed(mockRef, mockXRefEntry);\n\n  expect(actual).toBe(expected);\n});",
    "i2_llama-3.3-70b-versatile": "it(\"should fix the xref table with the values at the beginning of a xref stream\", async () => {\n  const { XRef, Ref, BaseStream } = await import(\"../../src/core/xref.js\");\n  const { Lexer, Parser } = await import(\"../../src/core/parser.js\");\n  const { Dict } = await import(\"../../src/core/primitives.js\");\n  const { PDFDocument } = await import(\"../../src/core/document.js\");\n\n  const pdfData = new Uint8Array([37, 80, 68, 70, 45, 49, 46, 55, 10, 25, 50, 48, 32, 48, 32, 111, 98, 106, 10, 60, 60, 10, 47, 84, 121, 112, 101, 10, 47, 80, 97, 103, 101, 10, 62, 62, 10, 101, 110, 100, 111, 98, 106, 10, 49, 32, 48, 32, 114, 10, 102, 111, 114, 109, 10, 120, 114, 101, 102, 10, 49, 32, 49, 10, 48, 32, 49, 32, 48, 10, 114, 10, 115, 116, 114, 101, 97, 109, 10, 120, 114, 101, 102, 10, 49, 32, 50, 10, 48, 32, 49, 32, 48, 10, 114, 10, 115, 116, 114, 101, 97, 109, 10, 120, 114, 101, 102, 10, 49, 32, 51, 10, 48, 32, 49, 32, 48, 10, 114, 10, 115, 116, 114, 101, 97, 109, 10, 120, 114, 101, 102, 10, 49, 32, 52, 10, 48, 32, 49, 32, 48, 10, 114, 10, 115, 116, 114, 101, 97, 109, 10, 120, 114, 101, 102, 10, 49, 32, 53, 10, 48, 32, 49, 32, 48, 10, 114, 10, 115, 116, 114, 101, 97, 109, 10, 120, 114, 101, 102, 10, 49, 32, 54, 10, 48, 32, 49, 32, 48, 10, 114, 10, 115, 116, 114, 101, 97, 109, 10,",
    "i3_deepseek-r1-distill-llama-70b": "it(\"should correctly handle xref generation numbers to prevent invalid PDFs\", async () => {\n  const { TestPdfsServer } = await import(\"./test_utils.js\");\n  const { getDocument } = await import(\"../../src/display/api.js\");\n\n  const server = new TestPdfsServer();\n  try {\n    // Use a known PDF that triggers the xref generation issue\n    const pdfPath = `${TEST_PDFS_PATH}/issue-1978317.pdf`;\n    const loadingTask = getDocument({\n      url: server.urlFor(pdfPath),\n      httpHeaders: { \"X-Test-Source\": \"unitTest\" },\n    });\n\n    const pdfDoc = await loadingTask.promise;\n    const expectedError = new InvalidPDFException(\"Invalid PDF structure\");\n    const actualError = await pdfDoc.loadError;\n\n    assert strictEqual(actualError, undefined,\n      `Expected PDF to load without error, but got: ${actualError}`);\n  } catch (error) {\n    throw new Error(`PDF failed to load: ${error.message}`);\n  } finally {\n    await server.stop();\n  }\n});",
    "i3_gpt-4o": "it(\"should open HTML Spec page PDF in Firefox without errors\", async () => {\n  const { getDocument } = await import(\"../../src/display/api.js\");\n  const url = `${TEST_PDFS_PATH}html_spec_page.pdf`;\n  const loadingTask = getDocument(url);\n  const pdfDocument = await loadingTask.promise;\n  const numPages = pdfDocument.numPages;\n  expect(numPages).toBeGreaterThan(0);\n  const page = await pdfDocument.getPage(1);\n  const viewport = page.getViewport({ scale: 1.0 });\n  expect(viewport.width).toBeGreaterThan(0);\n  expect(viewport.height).toBeGreaterThan(0);\n});",
    "i3_llama-3.3-70b-versatile": "it(\"should fix the XRef table generation issue when printing HTML spec pages to PDF\", async () => {\n  const { PDFDocumentLoadingTask } = await import(\"../../src/display/api.js\");\n  const { buildGetDocumentParams } = await import(\"./test_utils.js\");\n  const params = buildGetDocumentParams(`${TEST_PDFS_PATH}html_spec.pdf`);\n  const loadingTask = PDFDocumentLoadingTask.fromParams(params);\n  const pdfDoc = await loadingTask.promise;\n  const catalog = await pdfDoc.catalog;\n  const expectedRootRef = pdfDoc.xref.root;\n  const actualRootRef = catalog.get(\"Root\");\n  expect(actualRootRef).toEqual(expectedRootRef);\n});",
    "i4_deepseek-r1-distill-llama-70b": "it(\"should fix XRef generation issue when printing HTML spec\", async () => {\n  const { XRef } = await import(\"../../src/core/xref.js\");\n  const { PDFDocument } = await import(\"../../src/core/document.js\");\n  const { TestPdfsServer } = await import(\"./test_utils.js\");\n\n  const server = new TestPdfsServer();\n  try {\n    const pdf = server.getTestPdf(\"issue_1978317.pdf\");\n    const xref = new XRef(pdf.stream, pdf.manager);\n    await xref.parse();\n    const root = await xref.getCatalogObj();\n    expect(root).toBeTruthy();\n  } finally {\n    server.stop();\n  }\n});",
    "i4_gpt-4o": "it(\"should correctly update the generation number in the xref table\", async () => {\n  const { XRef } = await import(\"../../src/core/xref.js\");\n  const { Ref } = await import(\"../../src/core/primitives.js\");\n\n  const xref = new XRef(null, null);\n  xref.entries = [\n    { offset: 100, gen: 0, uncompressed: true },\n    { offset: 200, gen: 1, uncompressed: true },\n  ];\n\n  const ref = Ref.get(1, 0);\n  const xrefEntry = xref.fetchUncompressed(ref, xref.entries[1]);\n\n  const expectedGen = 0;\n  const actualGen = xref.entries[1].gen;\n\n  expect(actualGen).toBe(expectedGen);\n});",
    "i4_llama-3.3-70b-versatile": "it(\"should fix bug by updating the generation number in the xref entry\", async () => {\n  const { XRef, Ref, Parser, Lexer, Dict, BaseStream } = await import(\"../../src/core/xref.js\");\n  const { Stream } = await import(\"../../src/core/stream.js\");\n\n  const pdfData = new Uint8Array([\n    0x25, 0x50, 0x44, 0x46, 0x2d, 0x31, 0x2e, 0x34, 0x0a, 0x25, 0xe2, 0xe3, 0xcf, 0xd3, 0x0a,\n    0x31, 0x20, 0x30, 0x20, 0x6f, 0x62, 0x6a, 0x0a, 0x3c, 0x3c, 0x2f, 0x54, 0x79, 0x70, 0x65, 0x20,\n    0x2f, 0x43, 0x61, 0x74, 0x61, 0x6c, 0x6f, 0x67, 0x3e, 0x3e, 0x0a, 0x65, 0x6e, 0x64, 0x6f, 0x62,\n    0x6a, 0x0a, 0x78, 0x72, 0x65, 0x66, 0x0a, 0x30, 0x20, 0x31, 0x0a, 0x30, 0x30, 0x30, 0x30, 0x30,\n    0x30, 0x30, 0x30, 0x30, 0x20, 0x30, 0x20, 0x66, 0x0a, 0x74, 0x72, 0x61, 0x69, 0x6c, 0x65, 0x72,\n    0x0a, 0x3c, 0x3c, 0x2f, 0x53, 0x69, 0x7a, 0x65, 0x20, 0x31, 0x3e, 0x3e, 0x0a, 0x73, 0x74, 0x61,\n    0x72, 0x74, 0x78, 0x72, 0x65, 0x66, 0x0a, 0x31, 0x37, 0x30, 0x0a, 0x25, 0xe2, 0xe3, 0xcf, 0xd3,\n  ]);\n\n  const stream = new Stream(pdfData, {});\n  const xref = new XRef(stream, {});\n\n  const parser = new",
    "i5_deepseek-r1-distill-llama-70b": "it(\"should fix HTML spec PDF opening in Firefox issue\", async () => {\n  const { PDFDocument } = await import(\"../../src/core/document.js\");\n  const { TestPdfsServer } = await import(\"./test_utils.js\");\n\n  const server = new TestPdfsServer();\n  try {\n    server.addFile(\"html-spec.pdf\", new TextEncoder().encode(\"<html></html>\"));\n\n    const loadingTask = PDFDocument.get({ url: 'http://localhost:9876/html-spec.pdf' });\n    const { numPages } = await loadingTask;\n    const page = await numPages.get(1);\n\n    // If we reach here without an error, the PDF was loaded successfully\n    expect(page).toBeDefined();\n  } finally {\n    server.close();\n  }\n});",
    "i5_gpt-4o": "it(\"should fix the object generation number in the xref table\", async () => {\n  const { XRef } = await import(\"../../src/core/xref.js\");\n  const { XRefMock } = await import(\"./test_utils.js\");\n\n  const xref = new XRefMock([\n    { num: 1, offset: 100, gen: 0 },\n    { num: 2, offset: 200, gen: 1 },\n  ]);\n\n  const tableOffset = 100;\n  const nums = [1, 2];\n  const offsets = [100, 200];\n\n  const xrefInstance = new XRef();\n  xrefInstance.getEntry = (num) => xref.getEntry(num);\n\n  for (let i = 0; i < nums.length; i++) {\n    const num = nums[i];\n    const entry = xrefInstance.getEntry(num);\n    if (entry?.offset === tableOffset && entry.gen !== i) {\n      entry.gen = i;\n    }\n  }\n\n  const expected = [0, 1];\n  const actual = nums.map(num => xrefInstance.getEntry(num).gen);\n  expect(actual).toEqual(expected);\n});",
    "i5_llama-3.3-70b-versatile": "it(\"should resolve HTML Spec page printed to PDF cannot be opened in Firefox\", async () => {\n  const { PDFDocument } = await import(\"../../src/core/document.js\");\n  const { PDFFetchStream } = await import(\"../../src/display/fetch_stream.js\");\n  const { PDFNetworkStream } = await import(\"../../src/display/network.js\");\n  const { createHeaders } = await import(\"../../src/display/network_utils.js\");\n  const { buildGetDocumentParams } = await import(\"./test_utils.js\");\n  const { TEST_PDFS_PATH } = await import(\"./test_utils.js\");\n\n  const pdfUrl = `${TEST_PDFS_PATH}/html-spec-page.pdf`;\n  const params = buildGetDocumentParams(pdfUrl, null, createHeaders());\n  const stream = new PDFFetchStream(params);\n  const networkStream = new PDFNetworkStream(stream);\n  const doc = await PDFDocument.load({ cMapUrl: \"\", cMapPacked: true, networkStream });\n\n  const expected = true;\n  const actual = doc !== null;\n\n  expect(actual).toBe(expected);\n});"
  },
  "20119": {
    "i1_deepseek-r1-distill-llama-70b": "it(\"should add context menu entries for highlight and comment\", async () => {\n  const { AnnotationEditorUIManager } = await import(\"../../src/display/editor/tools.js\");\n  const { FloatingToolbar } = await import(\"../../src/display/editor/toolbar.js\");\n\n  // Setup DOM\n  const container = document.createElement(\"div\");\n  document.body.appendChild(container);\n  const textLayer = document.createElement(\"div\");\n  textLayer.className = \"textLayer\";\n  container.appendChild(textLayer);\n\n  // Setup UI Manager\n  const uiManager = new AnnotationEditorUIManager(\n    container,\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {}\n  );\n\n  // Setup test state\n  const selection = window.getSelection();\n  selection.removeRange(window.document.createRange());\n  const range = document.createRange();\n  range.selectNode(textLayer);\n  selection.addRange(range);\n\n  // Mock methods\n  const highlightSpy = jest.spyOn(uiManager, \"highlightSelection\");\n  const commentSpy = jest.spyOn(uiManager, \"commentSelection\");\n\n  // Test context menu entries\n  const event = { name: \"highlightSelection\" };\n  uiManager.onEditingAction(event);\n  expect(highlightSpy).toHaveBeenCalledWith(\"context_menu\");\n\n  const commentEvent = { name: \"commentSelection\" };\n  uiManager.onEditingAction(commentEvent);\n  expect(commentSpy).toHaveBeenCalledWith(\"context_menu\");\n\n  // Cleanup\n  document.body.removeChild(container);\n});",
    "i1_gpt-4o": "it(\"should highlight and comment the text selection in a pdf\", async () => {\n  const { AnnotationEditorUIManager } = await import(\"../../src/display/editor/tools.js\");\n  const { PDFDocumentProxy } = await import(\"../../src/display/api.js\");\n\n  const mockCommentManager = { destroy: () => {} };\n  const mockSignatureManager = { destroy: () => {} };\n  const mockEventBus = { _on: () => {} };\n  const mockPdfDocument = { annotationStorage: {}, filterFactory: {} };\n  const mockContainer = document.createElement(\"div\");\n  const mockViewer = document.createElement(\"div\");\n  const mockViewerAlert = document.createElement(\"div\");\n\n  const uiManager = new AnnotationEditorUIManager(\n    mockContainer,\n    mockViewer,\n    mockViewerAlert,\n    null,\n    mockCommentManager,\n    mockSignatureManager,\n    mockEventBus,\n    mockPdfDocument,\n    null,\n    null,\n    true,\n    false,\n    false,\n    null,\n    null,\n    true\n  );\n\n  const selection = window.getSelection();\n  const range = document.createRange();\n  const textNode = document.createTextNode(\"Sample text for testing.\");\n  document.body.appendChild(textNode);\n  range.selectNodeContents(textNode);\n  selection.removeAllRanges();\n  selection.addRange(range);\n\n  uiManager.onEditingAction({ name: \"commentSelection\" });\n\n  const expected = true;\n  const actual = selection.isCollapsed;\n  expect(actual).toBe(expected);\n\n  document.body.removeChild(textNode);\n});",
    "i1_llama-3.3-70b-versatile": "it(\"should add a comment button to the context menu for highlighting and commenting text selection in a pdf\", async () => {\n  const { PDFDocument, PDFPageProxy } = await import(\"../../src/display/api.js\");\n  const { AnnotationEditorUIManager } = await import(\"../../src/display/editor/tools.js\");\n  const { noContextMenu, stopEvent } = await import(\"../display_utils.js\");\n\n  const pdfDocument = await PDFDocument.load(await fetchData(\"pdfjs/web/viewer/test/pdfs/annotation-test.pdf\"));\n  const pdfPage = await pdfDocument.getPage(1);\n  const annotationEditorUIManager = new AnnotationEditorUIManager(null, null, null, null, null, null, null, null, null, null, null, null, null);\n\n  const contextMenuItemsBeforePatch = annotationEditorUIManager._eventBus._on(\"editingaction\", () => {}, { signal: annotationEditorUIManager._signal });\n  const highlightSelectionBeforePatch = annotationEditorUIManager.highlightSelection(\"context_menu\");\n  const commentSelectionBeforePatch = annotationEditorUIManager.commentSelection(\"context_menu\");\n\n  expect(contextMenuItemsBeforePatch.length).toBeLessThan(3);\n  expect(highlightSelectionBeforePatch).toBeUndefined();\n  expect(commentSelectionBeforePatch).toBeUndefined();\n\n  // Apply the patch\n  annotationEditorUIManager.highlightSelection = function(methodOfCreation = \"\", comment = false) {\n    const selection = document.getSelection();\n    if (!selection || selection.isCollapsed) {\n      return;\n    }\n    const { anchorNode, anchorOffset, focusNode, focusOffset } = selection;\n    const text = selection.toString();\n    const anchorElement = annotationEditorUIManager.#getAnchorElementForSelection(selection);\n    const textLayer = anchorElement.closest(\".textLayer\");\n    const boxes = annotationEditorUIManager.getSelectionBoxes(textLayer);\n    if (!boxes) {\n      return;\n    }\n    selection.empty();\n\n    const layer = annotationEditorUIManager.#getLayerForTextLayer(textLayer);\n    const isNoneMode = annotationEditorUIManager.#mode === AnnotationEditorType.NONE;\n    const callback = () => {\n      const editor = layer?.createAndAddNewEditor({ x: 0, y: 0 }, false, {\n        methodOfCreation,\n        boxes,\n        anchorNode,\n        anchorOffset,\n        focusNode,\n        focusOffset,\n        text,\n      });\n      if (isNoneMode) {\n        annotationEditorUIManager.showAllEditors(\"highlight\", true, /* updateButton = */ true);\n      }\n      if (comment) {\n        editor?.editComment();\n      }\n    };\n    if (isNoneMode) {\n      annotationEditorUIManager.switchToMode(AnnotationEditorType.HIGHLIGHT, callback);\n    } else {\n      callback();\n    }\n  };\n\n  annotationEditorUIManager.commentSelection = function(methodOfCreation = \"\") {\n    annotationEditorUIManager.highlightSelection(methodOfCreation, /* comment */ true);\n  };\n\n  const contextMenuItemsAfterPatch = annotationEditorUIManager._eventBus._on(\"editingaction\", () => {}, { signal: annotationEditorUIManager._signal });\n  const highlightSelectionAfterPatch = annotationEditorUIManager.highlightSelection(\"context_menu\");\n  const commentSelectionAfterPatch = annotationEditorUIManager.commentSelection(\"context_menu\");\n\n  expect(contextMenuItemsAfterPatch.length).toBeGreaterThan(2);\n  expect(highlightSelectionAfterPatch).toBeDefined();\n  expect(commentSelectionAfterPatch).",
    "i2_deepseek-r1-distill-llama-70b": "it(\"should add comment selection to context menu\", async () => {\n  const { AnnotationEditorUIManager, FloatingToolbar } = await import(\"../../src/display/editor/tools.js\");\n  const { document } = new JSDOM().window;\n\n  // Mock selection and layer\n  const mockSelection = {\n    anchorNode: {},\n    isCollapsed: false,\n    empty: jest.fn(),\n    toString: jest.fn().mockReturnValue(\"test selection\")\n  };\n  const mockLayer = {\n    closest: jest.fn().mockReturnThis(),\n    getSelectionBoxes: jest.fn().mockReturnValue([{ x: 0, y: 0 }]),\n    createAndAddNewEditor: jest.fn()\n  };\n\n  // Setup document and UI manager\n  const uiManager = new AnnotationEditorUIManager(\n    document.body,\n    document.body,\n    document.body,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null\n  );\n\n  // Mock event bus\n  const mockEventBus = {\n    _on: jest.fn(),\n    _off: jest.fn()\n  };\n\n  // Add selection change listener\n  uiManager._eventBus._on.mock.calls[0][1](mockSelection);\n\n  // Spy on commentSelection method\n  const commentSpy = jest.spyOn(uiManager, 'commentSelection');\n\n  // Trigger context menu event\n  const contextMenuEvent = new document.CustomEvent('contextmenu', {\n    detail: { name: 'commentSelection' }\n  });\n  document.dispatchEvent(contextMenuEvent);\n\n  // Assert comment selection was called\n  expect(commentSpy).toHaveBeenCalled();\n});",
    "i2_gpt-4o": "it(\"should highlight and comment the text selection in a pdf\", async () => {\n  const { AnnotationEditorUIManager } = await import(\"../../src/display/editor/tools.js\");\n  const { FloatingToolbar } = await import(\"../../src/display/editor/toolbar.js\");\n\n  const mockUIManager = {\n    highlightSelection: jest.fn(),\n    commentSelection: jest.fn(),\n    _signal: new AbortController().signal,\n    hasCommentManager: () => true,\n  };\n\n  const floatingToolbar = new FloatingToolbar(mockUIManager);\n  const toolbarElement = floatingToolbar.show(document.createElement(\"div\"), [], true);\n\n  const highlightButton = toolbarElement.querySelector(\".highlightButton\");\n  const commentButton = toolbarElement.querySelector(\".commentButton\");\n\n  highlightButton.click();\n  commentButton.click();\n\n  expect(mockUIManager.highlightSelection).toHaveBeenCalledWith(\"floating_button\");\n  expect(mockUIManager.commentSelection).toHaveBeenCalledWith(\"floating_button\");\n});",
    "i2_llama-3.3-70b-versatile": "it(\"should add a comment button to the floating toolbar\", async () => {\n  const { AnnotationEditorUIManager, HighlightToolbar } = await import(\"./toolbar.js\");\n  const { AnnotationEditorUIManager: Manager } = await import(\"../display/editor/tools.js\");\n  const uiManager = new Manager(null, null, null, null, null, null, null, null, null, null, null, null, null);\n  const highlightToolbar = new HighlightToolbar(uiManager);\n  const editToolbar = highlightToolbar.#render();\n  const buttons = editToolbar.querySelector(\".buttons\");\n  const commentButton = buttons.querySelector(\"[data-l10n-id='pdfjs-comment-floating-button-label']\");\n  expect(commentButton).not.toBeNull();\n});",
    "i3_deepseek-r1-distill-llama-70b": "it(\"should add highlight and comment context menu options\", async () => {\n  const { build } = await import(\"../../src/display/api.js\");\n  const pdfBuffer = await import(\"../../src/core/pdf_buffer.js\");\n  const pdfDocument = await build({\n    pdfBuffer,\n    cMapUrl: \"\",\n    isVerbose: false,\n  });\n  const page = await pdfDocument.getPage(1);\n  const textLayer = await page.getTextContent();\n  const div = document.createElement(\"div\");\n  div.appendChild(textLayer.div);\n\n  const selection = document.getSelection();\n  const range = document.createRange();\n  range.selectNodeContents(textLayer.div.firstChild);\n  selection.removeAllRanges();\n  selection.addRange(range);\n  document.dispatchEvent(new Event(\"selectionchange\"));\n\n  const onContextMenu = jest.fn();\n  document.addEventListener(\"contextmenu\", (e) => {\n    onContextMenu();\n  });\n\n  const contextMenuEvent = new MouseEvent(\"contextmenu\", {\n    bubbles: true,\n    cancelable: true,\n  });\n  textLayer.div.dispatchEvent(contextMenuEvent);\n\n  const expectedActions = [\"highlightSelection\", \"commentSelection\"];\n  const actualActions = onContextMenu.mock.calls;\n\n  expect(actualActions.length).toBe(1);\n  expect(actualActions[0][0]).toContain(\"highlightSelection\");\n  expect(actualActions[0][0]).toContain(\"commentSelection\");\n\n  await pdfDocument.destroy();\n});",
    "i3_gpt-4o": "it(\"should highlight and comment text selection in a PDF\", async () => {\n  const { AnnotationEditorUIManager } = await import(\"../../src/display/editor/tools.js\");\n  const { AnnotationEditorType } = await import(\"../../src/shared/util.js\");\n\n  // Initialize the UI manager with necessary parameters\n  const uiManager = new AnnotationEditorUIManager(\n    document.createElement(\"div\"), // container\n    document.createElement(\"div\"), // viewer\n    document.createElement(\"div\"), // viewerAlert\n    null, // altTextManager\n    { open: jest.fn() }, // commentManager mock\n    null, // signatureManager\n    { _on: jest.fn(), dispatch: jest.fn() }, // eventBus mock\n    { annotationStorage: new Map(), filterFactory: {} }, // pdfDocument mock\n    null, // pageColors\n    null, // highlightColors\n    true, // enableHighlightFloatingButton\n    false, // enableUpdatedAddImage\n    false, // enableNewAltTextWhenAddingImage\n    null, // mlManager\n    null, // editorUndoBar\n    true // supportsPinchToZoom\n  );\n\n  // Simulate a text selection\n  const selection = window.getSelection();\n  const range = document.createRange();\n  const textNode = document.createTextNode(\"Sample text for testing\");\n  document.body.appendChild(textNode);\n  range.selectNodeContents(textNode);\n  selection.removeAllRanges();\n  selection.addRange(range);\n\n  // Call the method to highlight and comment the selection\n  uiManager.highlightSelection(\"context_menu\", true);\n\n  // Verify that the commentManager's open method was called\n  expect(uiManager.hasCommentManager()).toBe(true);\n  expect(uiManager._eventBus.dispatch).toHaveBeenCalledWith(\"showannotationeditorui\", expect.objectContaining({\n    mode: AnnotationEditorType.HIGHLIGHT,\n  }));\n});",
    "i3_llama-3.3-70b-versatile": "it(\"should add an entry in the context menu to highlight and comment the text selection in a pdf\", async () => {\n  const { PDFDataRangeTransport, PDFWorker, build, getDocument } = await import(\"../../src/display/api.js\");\n  const { AnnotationEditorUIManager } = await import(\"../../src/display/editor/tools.js\");\n  const { noContextMenu, stopEvent } = await import(\"../display_utils.js\");\n\n  const pdfDocument = await build({\n    url: \"path/to/example.pdf\",\n    cMapUrl: \"path/to/cmap\",\n    cMapPacked: true,\n  });\n\n  const annotationEditorUIManager = new AnnotationEditorUIManager(\n    document.createElement(\"div\"),\n    document.createElement(\"div\"),\n    document.createElement(\"div\"),\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,\n    null,",
    "i4_deepseek-r1-distill-llama-70b": "it(\"should add context menu entry to highlight and comment text selection\", async () => {\n  const { AnnotationEditorUIManager } = await import(\"../../src/display/editor/tools.js\");\n  const { document } = globalThis;\n\n  const uiManager = {\n    _uiManager: {\n      _signal: Symbol(),\n    },\n    highlightSelection: jest.fn(),\n    commentSelection: jest.fn(),\n  };\n\n  const mockTextLayer = {\n    getBoundingClientRect: () => ({ x: 0, y: 0, width: 100, height: 100 }),\n    closest: () => mockTextLayer,\n    querySelector: () => mockTextLayer,\n  };\n\n  const mockSelection = {\n    rangeCount: 1,\n    getRangeAt: () => ({\n      getClientRects: () => [{ x: 10, y: 20, width: 30, height: 40 }],\n    }),\n  };\n\n  const mockDocument = {\n    ...document,\n    getSelection: () => mockSelection,\n  };\n\n  globalThis.document = mockDocument;\n\n  const manager = new AnnotationEditorUIManager(\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n    {},\n",
    "i4_gpt-4o": "it(\"should add highlight and comment buttons to the floating toolbar\", async () => {\n  const { AnnotationEditorUIManager } = await import(\"../../src/display/editor/tools.js\");\n  const { FloatingToolbar } = await import(\"../../src/display/editor/toolbar.js\");\n\n  const mockUIManager = {\n    _signal: new AbortController().signal,\n    hasCommentManager: () => true,\n    highlightSelection: jest.fn(),\n    commentSelection: jest.fn(),\n  };\n\n  const floatingToolbar = new FloatingToolbar(mockUIManager);\n  const toolbarElement = floatingToolbar.show(document.createElement(\"div\"), [{ x: 0, y: 0, width: 1, height: 1 }], true);\n\n  const highlightButton = toolbarElement.querySelector(\".highlightButton\");\n  const commentButton = toolbarElement.querySelector(\".commentButton\");\n\n  expect(highlightButton).not.toBeNull();\n  expect(commentButton).not.toBeNull();\n\n  highlightButton.click();\n  commentButton.click();\n\n  expect(mockUIManager.highlightSelection).toHaveBeenCalledWith(\"floating_button\");\n  expect(mockUIManager.commentSelection).toHaveBeenCalledWith(\"floating_button\");\n});",
    "i4_llama-3.3-70b-versatile": "it(\"should add a comment button to the floating toolbar\", async () => {\n  const { AnnotationEditorUIManager, HighlightToolbar } = await import(\"./tools.js\");\n  const { EditorToolbar } = await import(\"./toolbar.js\");\n  const uiManager = new AnnotationEditorUIManager(null, null, null, null, null, null, null, null, null, null, null, null, null);\n  uiManager.hasCommentManager = () => true;\n  const toolbar = new HighlightToolbar(uiManager);\n  const buttons = toolbar.render().querySelector(\".buttons\");\n  const commentButton = buttons.querySelector(\"[data-l10n-id='pdfjs-comment-floating-button-label']\");\n  expect(commentButton).not.toBeNull();\n});",
    "i5_deepseek-r1-distill-llama-70b": "it(\"should add highlight and comment options to context menu\", async () => {\n  const { AnnotationEditorUIManager } = await import(\"../../src/display/editor/tools.js\");\n  const { FloatingToolbar } = await import(\"../../src/display/editor/toolbar.js\");\n\n  const uiManager = new AnnotationEditorUIManager();\n  const textLayer = {\n    closest: () => ({\n      getBoundingClientRect: () => ({ top: 0, left: 0, right: 100, bottom: 100 }),\n    }),\n  };\n\n  const mockDispatch = jest.fn();\n  document.dispatchEvent = mockDispatch;\n\n  const selection = {\n    isCollapsed: false,\n    anchorNode: {},\n    rangeCount: 1,\n  };\n\n  const getSelectionSpy = jest.spyOn(global, \"getSelection\").mockReturnValue(selection);\n\n  const contextMenuEvent = new Event(\"contextmenu\");\n  contextMenuEvent.initMouseEvent(\n    \"contextmenu\",\n    true,\n    true,\n    window,\n    0,\n    0,\n    0,\n    0,\n    0,\n    false,\n    false,\n    false,\n    false,\n    0,\n    null\n  );\n\n  document.dispatchEvent(contextMenuEvent);\n\n  const menuCreated = await new Promise(resolve => {\n    const listener = ({ detail }) => {\n      if (detail.type === \"highlightSelection\") {\n        resolve(true);\n      }\n    };\n    document.addEventListener(\"menu-creation\", listener);\n    document.dispatchEvent(contextMenuEvent);\n  });\n\n  expect(menuCreated).toBe(true);\n});",
    "i5_gpt-4o": "it(\"should highlight and comment the text selection in a pdf\", async () => {\n  const { AnnotationEditorUIManager } = await import(\"../../src/display/editor/tools.js\");\n  const { FloatingToolbar } = await import(\"../../src/display/editor/toolbar.js\");\n\n  const uiManager = new AnnotationEditorUIManager();\n  const floatingToolbar = new FloatingToolbar(uiManager);\n\n  const mockSelection = {\n    isCollapsed: false,\n    anchorNode: document.createElement(\"div\"),\n    anchorOffset: 0,\n    focusNode: document.createElement(\"div\"),\n    focusOffset: 5,\n  };\n\n  document.getSelection = () => mockSelection;\n\n  let highlightCalled = false;\n  let commentCalled = false;\n\n  uiManager.highlightSelection = (methodOfCreation, comment) => {\n    if (comment) {\n      commentCalled = true;\n    } else {\n      highlightCalled = true;\n    }\n  };\n\n  floatingToolbar.show(mockSelection.anchorNode, [{ x: 0, y: 0, width: 100, height: 20 }], true);\n\n  const highlightButton = document.querySelector(\".highlightButton\");\n  const commentButton = document.querySelector(\".commentButton\");\n\n  highlightButton.click();\n  commentButton.click();\n\n  expect(highlightCalled).toBe(true);\n  expect(commentCalled).toBe(true);\n});",
    "i5_llama-3.3-70b-versatile": "it(\"should add an entry in the context menu to highlight and comment the text selection in a pdf\", async () => {\n  const { PDFPageProxy, PDFDocumentProxy } = await import(\"../../src/display/api.js\");\n  const { AnnotationEditorUIManager } = await import(\"../../src/display/editor/tools.js\");\n  const { PDFViewer } = await import(\"../../web/pdf_viewer.js\");\n\n  const pdfViewer = new PDFViewer();\n  const pdfDocument = await PDFDocumentProxy.load(\"path/to/example.pdf\");\n  const pdfPage = await pdfDocument.getPage(1);\n  const annotationEditorUIManager = new AnnotationEditorUIManager({\n    page: pdfPage,\n    pdfViewer,\n  });\n\n  const contextMenuEntriesBefore = annotationEditorUIManager.getContextMenuEntries();\n  expect(contextMenuEntriesBefore).not.toContain(\"Comment Selection\");\n\n  const patch = await import(\"./patch.js\");\n  annotationEditorUIManager = new AnnotationEditorUIManager({\n    page: pdfPage,\n    pdfViewer,\n  });\n\n  const contextMenuEntriesAfter = annotationEditorUIManager.getContextMenuEntries();\n  expect(contextMenuEntriesAfter).toContain(\"Comment Selection\");\n});"
  }
}