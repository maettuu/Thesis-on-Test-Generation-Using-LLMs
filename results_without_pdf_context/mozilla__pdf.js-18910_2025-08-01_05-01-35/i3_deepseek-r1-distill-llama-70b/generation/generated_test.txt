it("should use ImageDecoder for faster JPEG decoding", async () => {
  const { JpegStream, PDFImage } = await import("../../src/core/jpeg_stream.js");
  const { BaseStream } = await import("../../src/core/base_stream.js");
  const xref = new XRefMock();

  // Mock JPEG data (simplified for testing)
  const jpegData = new Uint8Array([
    0xff, 0xd8, 0xff, 0xe0, 0x00, 0x10, 0x4a, 0x46, 0x49, 0x46, 0x00, 0x01,
    0x01, 0x00, 0x00, 0x00, 0x00, 0xff, 0xfe, 0x00, 0x1c, 0x49, 0x44, 0x41, 0x54,
    0x41, 0x54, 0x47, 0x41, 0x57, 0x45, 0x52, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xd9
  ]);

  const stream = new JpegStream({
    stream: new StringStream(jpegData),
    maybeLength: jpegData.length,
    params: {}
  });

  const image = new PDFImage({
    image: stream,
    xref: xref,
    res: null,
    isInline: false,
    pdfFunctionFactory: null,
    localColorSpaceCache: null
  });

  // Verify that getTransferableImage is available
  expect(stream.getTransferableImage).toBeDefined();

  // Check if ImageDecoder is used
  const useImageDecoder = await JpegStream.canUseImageDecoder;
  expect(useImageDecoder).toBe(true);

  // Verify image decoding works
  const decodedImage = await image.getImageData();
  expect(decodedImage).toBeDefined();

  // Verify the image data matches expected dimensions
  expect(decodedImage.width).toBe(1);
  expect(decodedImage.height).toBe(1);
});
