Before you begin:
- Keep going until the job is completely solved — don’t stop halfway.
- If you’re unsure about the behavior, reread the provided patch carefully; do not hallucinate.
- Plan your approach before writing code by reflecting on whether the test truly fails before and passes after.

Issue:
<issue>
[Bug]: Ts (textRise) text operator does not work with Type 3 fonts
### Attach (recommended) or Link to PDF file

[raise5.pdf](https://github.com/user-attachments/files/18914308/raise5.pdf)

### Web browser and its version

Firefox 128.7.0esr (64-Bit)

### Operating system and its version

Debian GNU/Linux 12 (bookworm) 64-bit

### PDF.js version

v4.10.38

### Is the bug present in the latest PDF.js version?

Yes

### Is a browser extension

No

### Steps to reproduce the problem

1. Open a PDF with a type 3 font that uses the `Ts` text operator with a non-zero value, e.g. on page 2 of the example doc
2. Observe that the text is still at the baseline for those charcters
## PDF.js (all versions)



### What is the expected behavior?

For the text to be displayed with characters rise above/below the baseline, like they do e.g. in evince:

![Image](https://github.com/user-attachments/assets/523f5911-39f5-472b-9ed2-86eb3645c27c)

### What went wrong?

The text is at the reference position instead, as if T<sub>rise</sub> wasn't set:
![Image](https://github.com/user-attachments/assets/e19f4d7a-eb10-4739-b9b1-d2193de01528)

You can ignore the trailing 'n', that's not using the `Ts` operator for unrelated reasons.

### Link to a viewer

_No response_

### Additional context

The example PDF is generated by my code, but it passes full verapdf PDFA-2B validation and shows up correctly in other viewers, so I'd surprised if that made a difference. I looked into what may cause this and found a cause that is consistent with observable behavior and a change that I think will fix this properly and will follow up with a pull request.
</issue>

Patch:
<patch>
diff --git a/src/display/canvas.js b/src/display/canvas.js
--- a/src/display/canvas.js
+++ b/src/display/canvas.js
@@ -2362,7 +2362,7 @@ class CanvasGraphics {
 
     ctx.save();
     ctx.transform(...current.textMatrix);
-    ctx.translate(current.x, current.y);
+    ctx.translate(current.x, current.y + current.textRise);
 
     ctx.scale(textHScale, fontDirection);


</patch>

Imports:
<imports>
Available Packages
Dev Dependencies:
- @babel/core: ^7.26.8
- @babel/preset-env: ^7.26.8
- @babel/runtime: ^7.26.7
- @fluent/bundle: ^0.18.0
- @fluent/dom: ^0.10.0
- @metalsmith/layouts: ^2.7.0
- @metalsmith/markdown: ^1.10.0
- @napi-rs/canvas: ^0.1.67
- @types/node: ^22.13.1
- autoprefixer: ^10.4.20
- babel-loader: ^9.2.1
- caniuse-lite: ^1.0.30001699
- core-js: ^3.40.0
- eslint: ^9.20.0
- eslint-plugin-import: ^2.31.0
- eslint-plugin-jasmine: ^4.2.2
- eslint-plugin-json: ^4.0.1
- eslint-plugin-no-unsanitized: ^4.1.2
- eslint-plugin-perfectionist: ^4.8.0
- eslint-plugin-prettier: ^5.2.3
- eslint-plugin-unicorn: ^56.0.1
- globals: ^15.14.0
- gulp: ^5.0.0
- gulp-cli: ^3.0.0
- gulp-postcss: ^10.0.0
- gulp-rename: ^2.0.0
- gulp-replace: ^1.1.4
- gulp-zip: ^6.1.0
- highlight.js: ^11.11.1
- jasmine: ^5.6.0
- jsdoc: ^4.0.4
- jstransformer-nunjucks: ^1.2.0
- metalsmith: ^2.6.3
- metalsmith-html-relative: ^2.0.6
- ordered-read-streams: ^2.0.0
- pngjs: ^7.0.0
- postcss: ^8.5.1
- postcss-dark-theme-class: ^1.3.0
- postcss-dir-pseudo-class: ^9.0.1
- postcss-discard-comments: ^7.0.3
- postcss-nesting: ^13.0.1
- prettier: ^3.5.0
- puppeteer: ^24.2.0
- stylelint: ^16.14.1
- stylelint-prettier: ^5.0.3
- svglint: ^3.1.0
- terser-webpack-plugin: ^5.3.11
- tsc-alias: ^1.8.10
- ttest: ^4.0.0
- typescript: ^5.7.3
- vinyl: ^3.0.0
- webpack: ^5.97.1
- webpack-stream: ^7.0.0
- yargs: ^17.7.2

Engines:
- node: >=20

Available Relative Imports:
- `../../src/core/annotation.js`: Annotation, AnnotationBorderStyle, AnnotationFactory, MarkupAnnotation, getQuadPoints
- `../../src/core/bidi.js`: bidi
- `../../src/core/cff_parser.js`: CFFCharset, CFFCompiler, CFFFDSelect, CFFParser, CFFStrings
- `../../src/core/cmap.js`: CMap, CMapFactory, IdentityCMap
- `../../src/core/colorspace.js`: ColorSpace
- `../../src/core/core_utils.js`: arrayBuffersToBytes, encodeToXmlString, escapePDFName, escapeString, getInheritableProperty, getSizeInBytes, isAscii, isWhiteSpace, log2, numberToString, parseXFAPath, recoverJsURL, stringToUTF16HexString, stringToUTF16String, toRomanNumerals, validateCSSFont
- `../../src/core/crypto.js`: AES128Cipher, AES256Cipher, ARCFourCipher, CipherTransformFactory, PDF17, PDF20, calculateMD5, calculateSHA256, calculateSHA384, calculateSHA512
- `../../src/core/default_appearance.js`: createDefaultAppearance, parseAppearanceStream, parseDefaultAppearance
- `../../src/core/document.js`: PDFDocument, Page
- `../../src/core/encodings.js`: getEncoding
- `../../src/core/evaluator.js`: PartialEvaluator
- `../../src/core/flate_stream.js`: FlateStream
- `../../src/core/font_substitutions.js`: getFontSubstitution
- `../../src/core/fonts_utils.js`: SEAC_ANALYSIS_ENABLED
- `../../src/core/function.js`: PDFFunctionFactory, PostScriptCompiler, PostScriptEvaluator
- `../../src/core/glyphlist.js`: getDingbatsGlyphsUnicode, getGlyphsUnicode
- `../../src/core/image_utils.js`: GlobalImageCache, LocalColorSpaceCache
- `../../src/core/jbig2.js`: Jbig2Error, Jbig2Image
- `../../src/core/jpg.js`: JpegError, JpegImage
- `../../src/core/jpx.js`: JpxError, JpxImage
- `../../src/core/metadata_parser.js`: MetadataParser
- `../../src/core/operator_list.js`: OperatorList
- `../../src/core/parser.js`: Lexer, Linearization, Parser
- `../../src/core/predictor_stream.js`: PredictorStream
- `../../src/core/primitives.js`: Cmd, Dict, EOF, Name, Ref, RefSet, RefSetCache, isCmd, isDict, isName, isRefsEqual
- `../../src/core/ps_parser.js`: PostScriptLexer, PostScriptParser
- `../../src/core/stream.js`: NullStream, Stream, StringStream
- `../../src/core/type1_parser.js`: Type1Parser
- `../../src/core/unicode.js`: getCharUnicodeCategory, getUnicodeForGlyph, getUnicodeRangeFor, mapSpecialUnicodeValues
- `../../src/core/worker.js`: WorkerMessageHandler, WorkerTask
- `../../src/core/writer.js`: incrementalUpdate, writeChanges, writeDict
- `../../src/core/xfa/bind.js`: Binder
- `../../src/core/xfa/data.js`: DataHandler
- `../../src/core/xfa/factory.js`: XFAFactory
- `../../src/core/xfa/formcalc_lexer.js`: Lexer, TOKEN, Token
- `../../src/core/xfa/formcalc_parser.js`: Errors, Parser
- `../../src/core/xfa/parser.js`: XFAParser
- `../../src/core/xfa/som.js`: searchNode
- `../../src/core/xfa/symbol_utils.js`: $dump, $getChildren, $getChildrenByClass, $getChildrenByName, $text, $uid
- `../../src/core/xml_parser.js`: SimpleXMLParser, XMLParserBase
- `../../src/display/annotation_layer.js`: AnnotationLayer
- `../../src/display/annotation_storage.js`: AnnotationStorage
- `../../src/display/api.js`: LoopbackPort, PDFDataRangeTransport, PDFDocumentLoadingTask, PDFDocumentProxy, PDFPageProxy, PDFWorker, RenderTask, build, getDocument, version
- `../../src/display/canvas_factory.js`: DOMCanvasFactory
- `../../src/display/cmap_reader_factory.js`: DOMCMapReaderFactory
- `../../src/display/display_utils.js`: OutputScale, PDFDateString, PageViewport, PixelsPerInch, RenderingCancelledException, StatTimer, SupportedImageMimeTypes, fetchData, getFilenameFromUrl, getPdfFilenameFromUrl, getXfaPageViewport, isDataScheme, isPdfFile, isValidFetchUrl, noContextMenu, setLayerDimensions, stopEvent
- `../../src/display/draw_layer.js`: DrawLayer
- `../../src/display/editor/annotation_editor_layer.js`: AnnotationEditorLayer
- `../../src/display/editor/color_picker.js`: ColorPicker
- `../../src/display/editor/drawers/signaturedraw.js`: SignatureExtractor
- `../../src/display/editor/tools.js`: AnnotationEditorUIManager, CommandManager
- `../../src/display/fetch_stream.js`: PDFFetchStream
- `../../src/display/metadata.js`: Metadata
- `../../src/display/network.js`: PDFNetworkStream
- `../../src/display/network_utils.js`: createHeaders, createResponseError, extractFilenameFromHeader, validateRangeRequestCapabilities, validateResponseStatus
- `../../src/display/node_stream.js`: PDFNodeStream
- `../../src/display/node_utils.js`: NodeCMapReaderFactory, NodeStandardFontDataFactory, fetchData
- `../../src/display/standard_fontdata_factory.js`: DOMStandardFontDataFactory
- `../../src/display/svg_factory.js`: DOMSVGFactory
- `../../src/display/text_layer.js`: TextLayer
- `../../src/display/touch_manager.js`: TouchManager
- `../../src/display/worker_options.js`: GlobalWorkerOptions
- `../../src/display/xfa_layer.js`: XfaLayer
- `../../src/shared/message_handler.js`: MessageHandler
- `../../src/shared/murmurhash3.js`: MurmurHash3_64
- `../../src/shared/util.js`: AbortException, AnnotationBorderStyleType, AnnotationEditorParamsType, AnnotationEditorType, AnnotationFieldFlag, AnnotationFlag, AnnotationMode, AnnotationType, BaseException, FeatureTest, FormatError, ImageKind, InvalidPDFException, OPS, PasswordException, PasswordResponses, PermissionFlag, RenderingIntentFlag, ResponseException, UnknownErrorException, Util, VerbosityLevel, assert, bytesToString, createValidAbsoluteUrl, getModificationDate, getUuid, getVerbosityLevel, isNodeJS, normalizeUnicode, objectSize, setVerbosityLevel, shadow, string32, stringToBytes, stringToPDFString, stringToUTF8String, toBase64Util
- `../../web/annotation_layer_builder.js`: AnnotationLayerBuilder
- `../../web/app_options.js`: AppOptions, OptionKind
- `../../web/autolinker.js`: Autolinker
- `../../web/download_manager.js`: DownloadManager
- `../../web/event_utils.js`: EventBus, WaitOnType, waitOnEventOrTimeout
- `../../web/genericl10n.js`: GenericL10n
- `../../web/pdf_find_controller.js`: FindState, PDFFindController
- `../../web/pdf_find_utils.js`: CharacterType, getCharacterType
- `../../web/pdf_history.js`: PDFHistory, isDestArraysEqual, isDestHashesEqual
- `../../web/pdf_link_service.js`: LinkTarget, PDFLinkService, SimpleLinkService
- `../../web/pdf_page_view.js`: PDFPageView
- `../../web/pdf_scripting_manager.component.js`: PDFScriptingManager
- `../../web/pdf_single_page_viewer.js`: PDFSinglePageViewer
- `../../web/pdf_viewer.js`: PDFPageViewBuffer, PDFViewer
- `../../web/struct_tree_layer_builder.js`: StructTreeLayerBuilder
- `../../web/text_layer_builder.js`: TextLayerBuilder
- `../../web/ui_utils.js`: AutoPrintRegExp, ProgressBar, RenderingStates, ScrollMode, SpreadMode, backtrackBeforeAllVisibleElements, binarySearchFirstItem, calcRound, getPageSizeInches, getVisibleElements, isPortraitOrientation, isValidRotation, parseQueryString, removeNullCharacters
- `../../web/xfa_layer_builder.js`: XfaLayerBuilder
- `../reporter.js`: TestReporter
- `./common_pdfstream_tests.js`: testCrossOriginRedirects
- `./test_utils.js`: CMAP_URL, DefaultCMapReaderFactory, DefaultFileReaderFactory, DefaultStandardFontDataFactory, STANDARD_FONT_DATA_URL, TEST_PDFS_PATH, TestPdfsServer, XRefMock, buildGetDocumentParams, createIdFactory, getCrossOriginHostname
</imports>

Code:
<code>
File:
src/display/canvas.js
1 /* Copyright 2012 Mozilla Foundation
2  *
3  * Licensed under the Apache License, Version 2.0 (the "License");
4  * you may not use this file except in compliance with the License.
5  * You may obtain a copy of the License at
6  *
7  *     http://www.apache.org/licenses/LICENSE-2.0
8  *
9  * Unless required by applicable law or agreed to in writing, software
10  * distributed under the License is distributed on an "AS IS" BASIS,
11  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
12  * See the License for the specific language governing permissions and
13  * limitations under the License.
14  */
15 
16 import {
17   FeatureTest,
18   FONT_IDENTITY_MATRIX,
19   IDENTITY_MATRIX,
20   ImageKind,
21   info,
22   isNodeJS,
23   OPS,
24   shadow,
25   TextRenderingMode,
26   unreachable,
27   Util,
28   warn,
29 } from "../shared/util.js";
30 import {
31   getCurrentTransform,
32   getCurrentTransformInverse,
33   PixelsPerInch,
34 } from "./display_utils.js";
35 import {
36   getShadingPattern,
37   PathType,
38   TilingPattern,
39 } from "./pattern_helper.js";
40 import { convertBlackAndWhiteToRGBA } from "../shared/image_utils.js";
41 
42 // <canvas> contexts store most of the state we need natively.
43 // However, PDF needs a bit more state, which we store here.
44 // Minimal font size that would be used during canvas fillText operations.
45 const MIN_FONT_SIZE = 16;
46 // Maximum font size that would be used during canvas fillText operations.
47 const MAX_FONT_SIZE = 100;
48 
49 // Defines the time the `executeOperatorList`-method is going to be executing
50 // before it stops and schedules a continue of execution.
51 const EXECUTION_TIME = 15; // ms
52 // Defines the number of steps before checking the execution time.
53 const EXECUTION_STEPS = 10;
54 
55 // To disable Type3 compilation, set the value to `-1`.
56 const MAX_SIZE_TO_COMPILE = 1000;
57 
58 const FULL_CHUNK_HEIGHT = 16;
59 
60 /**
61  * Overrides certain methods on a 2d ctx so that when they are called they
62  * will also call the same method on the destCtx. The methods that are
63  * overridden are all the transformation state modifiers, path creation, and
64  * save/restore. We only forward these specific methods because they are the
65  * only state modifiers that we cannot copy over when we switch contexts.
66  *
67  * To remove mirroring call `ctx._removeMirroring()`.
68  *
69  * @param {Object} ctx - The 2d canvas context that will duplicate its calls on
70  *   the destCtx.
71  * @param {Object} destCtx - The 2d canvas context that will receive the
72  *   forwarded calls.
73  */
74 function mirrorContextOperations(ctx, destCtx) {
75   if (ctx._removeMirroring) {
76     throw new Error("Context is already forwarding operations.");
77   }
78   ctx.__originalSave = ctx.save;
79   ctx.__originalRestore = ctx.restore;
80   ctx.__originalRotate = ctx.rotate;
81   ctx.__originalScale = ctx.scale;
82   ctx.__originalTranslate = ctx.translate;
83   ctx.__originalTransform = ctx.transform;
84   ctx.__originalSetTransform = ctx.setTransform;
85   ctx.__originalResetTransform = ctx.resetTransform;
86   ctx.__originalClip = ctx.clip;
87   ctx.__originalMoveTo = ctx.moveTo;
88   ctx.__originalLineTo = ctx.lineTo;
89   ctx.__originalBezierCurveTo = ctx.bezierCurveTo;
90   ctx.__originalRect = ctx.rect;
91   ctx.__originalClosePath = ctx.closePath;
92   ctx.__originalBeginPath = ctx.beginPath;
93 
94   ctx._removeMirroring = () => {
95     ctx.save = ctx.__originalSave;
96     ctx.restore = ctx.__originalRestore;
97     ctx.rotate = ctx.__originalRotate;
98     ctx.scale = ctx.__originalScale;
99     ctx.translate = ctx.__originalTranslate;
100     ctx.transform = ctx.__originalTransform;
101     ctx.setTransform = ctx.__originalSetTransform;
102     ctx.resetTransform = ctx.__originalResetTransform;
103 
104     ctx.clip = ctx.__originalClip;
105     ctx.moveTo = ctx.__originalMoveTo;
106     ctx.lineTo = ctx.__originalLineTo;
107     ctx.bezierCurveTo = ctx.__originalBezierCurveTo;
108     ctx.rect = ctx.__originalRect;
109     ctx.closePath = ctx.__originalClosePath;
110     ctx.beginPath = ctx.__originalBeginPath;
111     delete ctx._removeMirroring;
112   };
113 
114   ctx.save = function ctxSave() {
115     destCtx.save();
116     this.__originalSave();
117   };
118 
119   ctx.restore = function ctxRestore() {
120     destCtx.restore();
121     this.__originalRestore();
122   };
123 
124   ctx.translate = function ctxTranslate(x, y) {
125     destCtx.translate(x, y);
126     this.__originalTranslate(x, y);
127   };
128 
129   ctx.scale = function ctxScale(x, y) {
130     destCtx.scale(x, y);
131     this.__originalScale(x, y);
132   };
133 
134   ctx.transform = function ctxTransform(a, b, c, d, e, f) {
135     destCtx.transform(a, b, c, d, e, f);
136     this.__originalTransform(a, b, c, d, e, f);
137   };
138 
139   ctx.setTransform = function ctxSetTransform(a, b, c, d, e, f) {
140     destCtx.setTransform(a, b, c, d, e, f);
141     this.__originalSetTransform(a, b, c, d, e, f);
142   };
143 
144   ctx.resetTransform = function ctxResetTransform() {
145     destCtx.resetTransform();
146     this.__originalResetTransform();
147   };
148 
149   ctx.rotate = function ctxRotate(angle) {
150     destCtx.rotate(angle);
151     this.__originalRotate(angle);
152   };
153 
154   ctx.clip = function ctxRotate(rule) {
155     destCtx.clip(rule);
156     this.__originalClip(rule);
157   };
158 
159   ctx.moveTo = function (x, y) {
160     destCtx.moveTo(x, y);
161     this.__originalMoveTo(x, y);
162   };
163 
164   ctx.lineTo = function (x, y) {
165     destCtx.lineTo(x, y);
166     this.__originalLineTo(x, y);
167   };
168 
169   ctx.bezierCurveTo = function (cp1x, cp1y, cp2x, cp2y, x, y) {
170     destCtx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y);
171     this.__originalBezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y);
172   };
173 
174   ctx.rect = function (x, y, width, height) {
175     destCtx.rect(x, y, width, height);
176     this.__originalRect(x, y, width, height);
177   };
178 
179   ctx.closePath = function () {
180     destCtx.closePath();
181     this.__originalClosePath();
182   };
183 
184   ctx.beginPath = function () {
185     destCtx.beginPath();
186     this.__originalBeginPath();
187   };
188 }
189 
190 class CachedCanvases {
191   constructor(canvasFactory) {
192     this.canvasFactory = canvasFactory;
193     this.cache = Object.create(null);
194   }
195 
196   getCanvas(id, width, height) {
197     let canvasEntry;
198     if (this.cache[id] !== undefined) {
199       canvasEntry = this.cache[id];
200       this.canvasFactory.reset(canvasEntry, width, height);
201     } else {
202       canvasEntry = this.canvasFactory.create(width, height);
203       this.cache[id] = canvasEntry;
204     }
205     return canvasEntry;
206   }
207 
208   delete(id) {
209     delete this.cache[id];
210   }
211 
212   clear() {
213     for (const id in this.cache) {
214       const canvasEntry = this.cache[id];
215       this.canvasFactory.destroy(canvasEntry);
216       delete this.cache[id];
217     }
218   }
219 }
220 
221 function drawImageAtIntegerCoords(
222   ctx,
223   srcImg,
224   srcX,
225   srcY,
226   srcW,
227   srcH,
228   destX,
229   destY,
230   destW,
231   destH
232 ) {
233   const [a, b, c, d, tx, ty] = getCurrentTransform(ctx);
234   if (b === 0 && c === 0) {
235     // top-left corner is at (X, Y) and
236     // bottom-right one is at (X + width, Y + height).
237 
238     // If leftX is 4.321 then it's rounded to 4.
239     // If width is 10.432 then it's rounded to 11 because
240     // rightX = leftX + width = 14.753 which is rounded to 15
241     // so after rounding the total width is 11 (15 - 4).
242     // It's why we can't just floor/ceil uniformly, it just depends
243     // on the values we've.
244 
245     const tlX = destX * a + tx;
246     const rTlX = Math.round(tlX);
247     const tlY = destY * d + ty;
248     const rTlY = Math.round(tlY);
249     const brX = (destX + destW) * a + tx;
250 
251     // Some pdf contains images with 1x1 images so in case of 0-width after
252     // scaling we must fallback on 1 to be sure there is something.
253     const rWidth = Math.abs(Math.round(brX) - rTlX) || 1;
254     const brY = (destY + destH) * d + ty;
255     const rHeight = Math.abs(Math.round(brY) - rTlY) || 1;
256 
257     // We must apply a transformation in order to apply it on the image itself.
258     // For example if a == 1 && d == -1, it means that the image itself is
259     // mirrored w.r.t. the x-axis.
260     ctx.setTransform(Math.sign(a), 0, 0, Math.sign(d), rTlX, rTlY);
261     ctx.drawImage(srcImg, srcX, srcY, srcW, srcH, 0, 0, rWidth, rHeight);
262     ctx.setTransform(a, b, c, d, tx, ty);
263 
264     return [rWidth, rHeight];
265   }
266 
267   if (a === 0 && d === 0) {
268     // This path is taken in issue9462.pdf (page 3).
269     const tlX = destY * c + tx;
270     const rTlX = Math.round(tlX);
271     const tlY = destX * b + ty;
272     const rTlY = Math.round(tlY);
273     const brX = (destY + destH) * c + tx;
274     const rWidth = Math.abs(Math.round(brX) - rTlX) || 1;
275     const brY = (destX + destW) * b + ty;
276     const rHeight = Math.abs(Math.round(brY) - rTlY) || 1;
277 
278     ctx.setTransform(0, Math.sign(b), Math.sign(c), 0, rTlX, rTlY);
279     ctx.drawImage(srcImg, srcX, srcY, srcW, srcH, 0, 0, rHeight, rWidth);
280     ctx.setTransform(a, b, c, d, tx, ty);
281 
282     return [rHeight, rWidth];
283   }
284 
285   // Not a scale matrix so let the render handle the case without rounding.
286   ctx.drawImage(srcImg, srcX, srcY, srcW, srcH, destX, destY, destW, destH);
287 
288   const scaleX = Math.hypot(a, b);
289   const scaleY = Math.hypot(c, d);
290   return [scaleX * destW, scaleY * destH];
291 }
292 
293 function compileType3Glyph(imgData) {
294   const { width, height } = imgData;
295   if (width > MAX_SIZE_TO_COMPILE || height > MAX_SIZE_TO_COMPILE) {
296     return null;
297   }
298 
299   const POINT_TO_PROCESS_LIMIT = 1000;
300   const POINT_TYPES = new Uint8Array([
301     0, 2, 4, 0, 1, 0, 5, 4, 8, 10, 0, 8, 0, 2, 1, 0,
302   ]);
303 
304   const width1 = width + 1;
305   let points = new Uint8Array(width1 * (height + 1));
306   let i, j, j0;
307 
308   // decodes bit-packed mask data
309   const lineSize = (width + 7) & ~7;
310   let data = new Uint8Array(lineSize * height),
311     pos = 0;
312   for (const elem of imgData.data) {
313     let mask = 128;
314     while (mask > 0) {
315       data[pos++] = elem & mask ? 0 : 255;
316       mask >>= 1;
317     }
318   }
319 
320   // finding interesting points: every point is located between mask pixels,
321   // so there will be points of the (width + 1)x(height + 1) grid. Every point
322   // will have flags assigned based on neighboring mask pixels:
323   //   4 | 8
324   //   --P--
325   //   2 | 1
326   // We are interested only in points with the flags:
327   //   - outside corners: 1, 2, 4, 8;
328   //   - inside corners: 7, 11, 13, 14;
329   //   - and, intersections: 5, 10.
330   let count = 0;
331   pos = 0;
332   if (data[pos] !== 0) {
333     points[0] = 1;
334     ++count;
335   }
336   for (j = 1; j < width; j++) {
337     if (data[pos] !== data[pos + 1]) {
338       points[j] = data[pos] ? 2 : 1;
339       ++count;
340     }
341     pos++;
342   }
343   if (data[pos] !== 0) {
344     points[j] = 2;
345     ++count;
346   }
347   for (i = 1; i < height; i++) {
348     pos = i * lineSize;
349     j0 = i * width1;
350     if (data[pos - lineSize] !== data[pos]) {
351       points[j0] = data[pos] ? 1 : 8;
352       ++count;
353     }
354     // 'sum' is the position of the current pixel configuration in the 'TYPES'
355     // array (in order 8-1-2-4, so we can use '>>2' to shift the column).
356     let sum = (data[pos] ? 4 : 0) + (data[pos - lineSize] ? 8 : 0);
357     for (j = 1; j < width; j++) {
358       sum =
359         (sum >> 2) +
360         (data[pos + 1] ? 4 : 0) +
361         (data[pos - lineSize + 1] ? 8 : 0);
362       if (POINT_TYPES[sum]) {
363         points[j0 + j] = POINT_TYPES[sum];
364         ++count;
365       }
366       pos++;
367     }
368     if (data[pos - lineSize] !== data[pos]) {
369       points[j0 + j] = data[pos] ? 2 : 4;
370       ++count;
371     }
372 
373     if (count > POINT_TO_PROCESS_LIMIT) {
374       return null;
375     }
376   }
377 
378   pos = lineSize * (height - 1);
379   j0 = i * width1;
380   if (data[pos] !== 0) {
381     points[j0] = 8;
382     ++count;
383   }
384   for (j = 1; j < width; j++) {
385     if (data[pos] !== data[pos + 1]) {
386       points[j0 + j] = data[pos] ? 4 : 8;
387       ++count;
388     }
389     pos++;
390   }
391   if (data[pos] !== 0) {
392     points[j0 + j] = 4;
393     ++count;
394   }
395   if (count > POINT_TO_PROCESS_LIMIT) {
396     return null;
397   }
398 
399   // building outlines
400   const steps = new Int32Array([0, width1, -1, 0, -width1, 0, 0, 0, 1]);
401   const path = new Path2D();
402 
403   for (i = 0; count && i <= height; i++) {
404     let p = i * width1;
405     const end = p + width;
406     while (p < end && !points[p]) {
407       p++;
408     }
409     if (p === end) {
410       continue;
411     }
412     path.moveTo(p % width1, i);
413 
414     const p0 = p;
415     let type = points[p];
416     do {
417       const step = steps[type];
418       do {
419         p += step;
420       } while (!points[p]);
421 
422       const pp = points[p];
423       if (pp !== 5 && pp !== 10) {
424         // set new direction
425         type = pp;
426         // delete mark
427         points[p] = 0;
428       } else {
429         // type is 5 or 10, ie, a crossing
430         // set new direction
431         type = pp & ((0x33 * type) >> 4);
432         // set new type for "future hit"
433         points[p] &= (type >> 2) | (type << 2);
434       }
435       path.lineTo(p % width1, (p / width1) | 0);
436 
437       if (!points[p]) {
438         --count;
439       }
440     } while (p0 !== p);
441     --i;
442   }
443 
444   // Immediately release the, potentially large, `Uint8Array`s after parsing.
445   data = null;
446   points = null;
447 
448   const drawOutline = function (c) {
449     c.save();
450     // the path shall be painted in [0..1]x[0..1] space
451     c.scale(1 / width, -1 / height);
452     c.translate(0, -height);
453     c.fill(path);
454     c.beginPath();
455     c.restore();
456   };
457 
458   return drawOutline;
459 }
460 
461 class CanvasExtraState {
462   constructor(width, height) {
463     // Are soft masks and alpha values shapes or opacities?
464     this.alphaIsShape = false;
465     this.fontSize = 0;
466     this.fontSizeScale = 1;
467     this.textMatrix = IDENTITY_MATRIX;
468     this.textMatrixScale = 1;
469     this.fontMatrix = FONT_IDENTITY_MATRIX;
470     this.leading = 0;
471     // Current point (in user coordinates)
472     this.x = 0;
473     this.y = 0;
474     // Start of text line (in text coordinates)
475     this.lineX = 0;
476     this.lineY = 0;
477     // Character and word spacing
478     this.charSpacing = 0;
479     this.wordSpacing = 0;
480     this.textHScale = 1;
481     this.textRenderingMode = TextRenderingMode.FILL;
482     this.textRise = 0;
483     // Default fore and background colors
484     this.fillColor = "#000000";
485     this.strokeColor = "#000000";
486     this.patternFill = false;
487     this.patternStroke = false;
488     // Note: fill alpha applies to all non-stroking operations
489     this.fillAlpha = 1;
490     this.strokeAlpha = 1;
491     this.lineWidth = 1;
492     this.activeSMask = null;
493     this.transferMaps = "none";
494 
495     this.startNewPathAndClipBox([0, 0, width, height]);
496   }
497 
498   clone() {
499     const clone = Object.create(this);
500     clone.clipBox = this.clipBox.slice();
501     return clone;
502   }
503 
504   setCurrentPoint(x, y) {
505     this.x = x;
506     this.y = y;
507   }
508 
509   updatePathMinMax(transform, x, y) {
510     [x, y] = Util.applyTransform([x, y], transform);
511     this.minX = Math.min(this.minX, x);
512     this.minY = Math.min(this.minY, y);
513     this.maxX = Math.max(this.maxX, x);
514     this.maxY = Math.max(this.maxY, y);
515   }
516 
517   updateRectMinMax(transform, rect) {
518     const p1 = Util.applyTransform(rect, transform);
519     const p2 = Util.applyTransform(rect.slice(2), transform);
520     const p3 = Util.applyTransform([rect[0], rect[3]], transform);
521     const p4 = Util.applyTransform([rect[2], rect[1]], transform);
522 
523     this.minX = Math.min(this.minX, p1[0], p2[0], p3[0], p4[0]);
524     this.minY = Math.min(this.minY, p1[1], p2[1], p3[1], p4[1]);
525     this.maxX = Math.max(this.maxX, p1[0], p2[0], p3[0], p4[0]);
526     this.maxY = Math.max(this.maxY, p1[1], p2[1], p3[1], p4[1]);
527   }
528 
529   updateScalingPathMinMax(transform, minMax) {
530     Util.scaleMinMax(transform, minMax);
531     this.minX = Math.min(this.minX, minMax[0]);
532     this.minY = Math.min(this.minY, minMax[1]);
533     this.maxX = Math.max(this.maxX, minMax[2]);
534     this.maxY = Math.max(this.maxY, minMax[3]);
535   }
536 
537   updateCurvePathMinMax(transform, x0, y0, x1, y1, x2, y2, x3, y3, minMax) {
538     const box = Util.bezierBoundingBox(x0, y0, x1, y1, x2, y2, x3, y3, minMax);
539     if (minMax) {
540       return;
541     }
542     this.updateRectMinMax(transform, box);
543   }
544 
545   getPathBoundingBox(pathType = PathType.FILL, transform = null) {
546     const box = [this.minX, this.minY, this.maxX, this.maxY];
547     if (pathType === PathType.STROKE) {
548       if (!transform) {
549         unreachable("Stroke bounding box must include transform.");
550       }
551       // Stroked paths can be outside of the path bounding box by 1/2 the line
552       // width.
553       const scale = Util.singularValueDecompose2dScale(transform);
554       const xStrokePad = (scale[0] * this.lineWidth) / 2;
555       const yStrokePad = (scale[1] * this.lineWidth) / 2;
556       box[0] -= xStrokePad;
557       box[1] -= yStrokePad;
558       box[2] += xStrokePad;
559       box[3] += yStrokePad;
560     }
561     return box;
562   }
563 
564   updateClipFromPath() {
565     const intersect = Util.intersect(this.clipBox, this.getPathBoundingBox());
566     this.startNewPathAndClipBox(intersect || [0, 0, 0, 0]);
567   }
568 
569   isEmptyClip() {
570     return this.minX === Infinity;
571   }
572 
573   startNewPathAndClipBox(box) {
574     this.clipBox = box;
575     this.minX = Infinity;
576     this.minY = Infinity;
577     this.maxX = 0;
578     this.maxY = 0;
579   }
580 
581   getClippedPathBoundingBox(pathType = PathType.FILL, transform = null) {
582     return Util.intersect(
583       this.clipBox,
584       this.getPathBoundingBox(pathType, transform)
585     );
586   }
587 }
588 
589 function putBinaryImageData(ctx, imgData) {
590   if (imgData instanceof ImageData) {
591     ctx.putImageData(imgData, 0, 0);
592     return;
593   }
594 
595   // Put the image data to the canvas in chunks, rather than putting the
596   // whole image at once.  This saves JS memory, because the ImageData object
597   // is smaller. It also possibly saves C++ memory within the implementation
598   // of putImageData(). (E.g. in Firefox we make two short-lived copies of
599   // the data passed to putImageData()). |n| shouldn't be too small, however,
600   // because too many putImageData() calls will slow things down.
601   //
602   // Note: as written, if the last chunk is partial, the putImageData() call
603   // will (conceptually) put pixels past the bounds of the canvas.  But
604   // that's ok; any such pixels are ignored.
605 
606   const height = imgData.height,
607     width = imgData.width;
608   const partialChunkHeight = height % FULL_CHUNK_HEIGHT;
609   const fullChunks = (height - partialChunkHeight) / FULL_CHUNK_HEIGHT;
610   const totalChunks = partialChunkHeight === 0 ? fullChunks : fullChunks + 1;
611 
612   const chunkImgData = ctx.createImageData(width, FULL_CHUNK_HEIGHT);
613   let srcPos = 0,
614     destPos;
615   const src = imgData.data;
616   const dest = chunkImgData.data;
617   let i, j, thisChunkHeight, elemsInThisChunk;
618 
619   // There are multiple forms in which the pixel data can be passed, and
620   // imgData.kind tells us which one this is.
621   if (imgData.kind === ImageKind.GRAYSCALE_1BPP) {
622     // Grayscale, 1 bit per pixel (i.e. black-and-white).
623     const srcLength = src.byteLength;
624     const dest32 = new Uint32Array(dest.buffer, 0, dest.byteLength >> 2);
625     const dest32DataLength = dest32.length;
626     const fullSrcDiff = (width + 7) >> 3;
627     const white = 0xffffffff;
628     const black = FeatureTest.isLittleEndian ? 0xff000000 : 0x000000ff;
629 
630     for (i = 0; i < totalChunks; i++) {
631       thisChunkHeight = i < fullChunks ? FULL_CHUNK_HEIGHT : partialChunkHeight;
632       destPos = 0;
633       for (j = 0; j < thisChunkHeight; j++) {
634         const srcDiff = srcLength - srcPos;
635         let k = 0;
636         const kEnd = srcDiff > fullSrcDiff ? width : srcDiff * 8 - 7;
637         const kEndUnrolled = kEnd & ~7;
638         let mask = 0;
639         let srcByte = 0;
640         for (; k < kEndUnrolled; k += 8) {
641           srcByte = src[srcPos++];
642           dest32[destPos++] = srcByte & 128 ? white : black;
643           dest32[destPos++] = srcByte & 64 ? white : black;
644           dest32[destPos++] = srcByte & 32 ? white : black;
645           dest32[destPos++] = srcByte & 16 ? white : black;
646           dest32[destPos++] = srcByte & 8 ? white : black;
647           dest32[destPos++] = srcByte & 4 ? white : black;
648           dest32[destPos++] = srcByte & 2 ? white : black;
649           dest32[destPos++] = srcByte & 1 ? white : black;
650         }
651         for (; k < kEnd; k++) {
652           if (mask === 0) {
653             srcByte = src[srcPos++];
654             mask = 128;
655           }
656 
657           dest32[destPos++] = srcByte & mask ? white : black;
658           mask >>= 1;
659         }
660       }
661       // We ran out of input. Make all remaining pixels transparent.
662       while (destPos < dest32DataLength) {
663         dest32[destPos++] = 0;
664       }
665 
666       ctx.putImageData(chunkImgData, 0, i * FULL_CHUNK_HEIGHT);
667     }
668   } else if (imgData.kind === ImageKind.RGBA_32BPP) {
669     // RGBA, 32-bits per pixel.
670     j = 0;
671     elemsInThisChunk = width * FULL_CHUNK_HEIGHT * 4;
672     for (i = 0; i < fullChunks; i++) {
673       dest.set(src.subarray(srcPos, srcPos + elemsInThisChunk));
674       srcPos += elemsInThisChunk;
675 
676       ctx.putImageData(chunkImgData, 0, j);
677       j += FULL_CHUNK_HEIGHT;
678     }
679     if (i < totalChunks) {
680       elemsInThisChunk = width * partialChunkHeight * 4;
681       dest.set(src.subarray(srcPos, srcPos + elemsInThisChunk));
682 
683       ctx.putImageData(chunkImgData, 0, j);
684     }
685   } else if (imgData.kind === ImageKind.RGB_24BPP) {
686     // RGB, 24-bits per pixel.
687     thisChunkHeight = FULL_CHUNK_HEIGHT;
688     elemsInThisChunk = width * thisChunkHeight;
689     for (i = 0; i < totalChunks; i++) {
690       if (i >= fullChunks) {
691         thisChunkHeight = partialChunkHeight;
692         elemsInThisChunk = width * thisChunkHeight;
693       }
694 
695       destPos = 0;
696       for (j = elemsInThisChunk; j--; ) {
697         dest[destPos++] = src[srcPos++];
698         dest[destPos++] = src[srcPos++];
699         dest[destPos++] = src[srcPos++];
700         dest[destPos++] = 255;
701       }
702 
703       ctx.putImageData(chunkImgData, 0, i * FULL_CHUNK_HEIGHT);
704     }
705   } else {
706     throw new Error(`bad image kind: ${imgData.kind}`);
707   }
708 }
709 
710 function putBinaryImageMask(ctx, imgData) {
711   if (imgData.bitmap) {
712     // The bitmap has been created in the worker.
713     ctx.drawImage(imgData.bitmap, 0, 0);
714     return;
715   }
716 
717   // Slow path: OffscreenCanvas isn't available in the worker.
718   const height = imgData.height,
719     width = imgData.width;
720   const partialChunkHeight = height % FULL_CHUNK_HEIGHT;
721   const fullChunks = (height - partialChunkHeight) / FULL_CHUNK_HEIGHT;
722   const totalChunks = partialChunkHeight === 0 ? fullChunks : fullChunks + 1;
723 
724   const chunkImgData = ctx.createImageData(width, FULL_CHUNK_HEIGHT);
725   let srcPos = 0;
726   const src = imgData.data;
727   const dest = chunkImgData.data;
728 
729   for (let i = 0; i < totalChunks; i++) {
730     const thisChunkHeight =
731       i < fullChunks ? FULL_CHUNK_HEIGHT : partialChunkHeight;
732 
733     // Expand the mask so it can be used by the canvas.  Any required
734     // inversion has already been handled.
735 
736     ({ srcPos } = convertBlackAndWhiteToRGBA({
737       src,
738       srcPos,
739       dest,
740       width,
741       height: thisChunkHeight,
742       nonBlackColor: 0,
743     }));
744 
745     ctx.putImageData(chunkImgData, 0, i * FULL_CHUNK_HEIGHT);
746   }
747 }
748 
749 function copyCtxState(sourceCtx, destCtx) {
750   const properties = [
751     "strokeStyle",
752     "fillStyle",
753     "fillRule",
754     "globalAlpha",
755     "lineWidth",
756     "lineCap",
757     "lineJoin",
758     "miterLimit",
759     "globalCompositeOperation",
760     "font",
761     "filter",
762   ];
763   for (const property of properties) {
764     if (sourceCtx[property] !== undefined) {
765       destCtx[property] = sourceCtx[property];
766     }
767   }
768   if (sourceCtx.setLineDash !== undefined) {
769     destCtx.setLineDash(sourceCtx.getLineDash());
770     destCtx.lineDashOffset = sourceCtx.lineDashOffset;
771   }
772 }
773 
774 function resetCtxToDefault(ctx) {
775   ctx.strokeStyle = ctx.fillStyle = "#000000";
776   ctx.fillRule = "nonzero";
777   ctx.globalAlpha = 1;
778   ctx.lineWidth = 1;
779   ctx.lineCap = "butt";
780   ctx.lineJoin = "miter";
781   ctx.miterLimit = 10;
782   ctx.globalCompositeOperation = "source-over";
783   ctx.font = "10px sans-serif";
784   if (ctx.setLineDash !== undefined) {
785     ctx.setLineDash([]);
786     ctx.lineDashOffset = 0;
787   }
788   if (
789     (typeof PDFJSDev !== "undefined" && PDFJSDev.test("MOZCENTRAL")) ||
790     !isNodeJS
791   ) {
792     const { filter } = ctx;
793     if (filter !== "none" && filter !== "") {
794       ctx.filter = "none";
795     }
796   }
797 }
798 
799 function getImageSmoothingEnabled(transform, interpolate) {
800   // In section 8.9.5.3 of the PDF spec, it's mentioned that the interpolate
801   // flag should be used when the image is upscaled.
802   // In Firefox, smoothing is always used when downscaling images (bug 1360415).
803 
804   if (interpolate) {
805     return true;
806   }
807 
808   const scale = Util.singularValueDecompose2dScale(transform);
809   // Round to a 32bit float so that `<=` check below will pass for numbers that
810   // are very close, but not exactly the same 64bit floats.
811   scale[0] = Math.fround(scale[0]);
812   scale[1] = Math.fround(scale[1]);
813   const actualScale = Math.fround(
814     (globalThis.devicePixelRatio || 1) * PixelsPerInch.PDF_TO_CSS_UNITS
815   );
816   return scale[0] <= actualScale && scale[1] <= actualScale;
817 }
818 
819 const LINE_CAP_STYLES = ["butt", "round", "square"];
820 const LINE_JOIN_STYLES = ["miter", "round", "bevel"];
821 const NORMAL_CLIP = {};
822 const EO_CLIP = {};
823 
824 class CanvasGraphics {
825   constructor(
826     canvasCtx,
827     commonObjs,
828     objs,
829     canvasFactory,
830     filterFactory,
831     { optionalContentConfig, markedContentStack = null },
832     annotationCanvasMap,
833     pageColors
834   ) {
835     this.ctx = canvasCtx;
836     this.current = new CanvasExtraState(
837       this.ctx.canvas.width,
838       this.ctx.canvas.height
839     );
840     this.stateStack = [];
841     this.pendingClip = null;
842     this.pendingEOFill = false;
843     this.res = null;
844     this.xobjs = null;
845     this.commonObjs = commonObjs;
846     this.objs = objs;
847     this.canvasFactory = canvasFactory;
848     this.filterFactory = filterFactory;
849     this.groupStack = [];
850     this.processingType3 = null;
851     // Patterns are painted relative to the initial page/form transform, see
852     // PDF spec 8.7.2 NOTE 1.
853     this.baseTransform = null;
854     this.baseTransformStack = [];
855     this.groupLevel = 0;
856     this.smaskStack = [];
857     this.smaskCounter = 0;
858     this.tempSMask = null;
859     this.suspendedCtx = null;
860     this.contentVisible = true;
861     this.markedContentStack = markedContentStack || [];
862     this.optionalContentConfig = optionalContentConfig;
863     this.cachedCanvases = new CachedCanvases(this.canvasFactory);
864     this.cachedPatterns = new Map();
865     this.annotationCanvasMap = annotationCanvasMap;
866     this.viewportScale = 1;
867     this.outputScaleX = 1;
868     this.outputScaleY = 1;
869     this.pageColors = pageColors;
870 
871     this._cachedScaleForStroking = [-1, 0];
872     this._cachedGetSinglePixelWidth = null;
873     this._cachedBitmapsMap = new Map();
874   }
875 
876   getObject(data, fallback = null) {
877     if (typeof data === "string") {
878       return data.startsWith("g_")
879         ? this.commonObjs.get(data)
880         : this.objs.get(data);
881     }
882     return fallback;
883   }
884 
885   beginDrawing({
886     transform,
887     viewport,
888     transparency = false,
889     background = null,
890   }) {
891     // For pdfs that use blend modes we have to clear the canvas else certain
892     // blend modes can look wrong since we'd be blending with a white
893     // backdrop. The problem with a transparent backdrop though is we then
894     // don't get sub pixel anti aliasing on text, creating temporary
895     // transparent canvas when we have blend modes.
896     const width = this.ctx.canvas.width;
897     const height = this.ctx.canvas.height;
898 
899     const savedFillStyle = this.ctx.fillStyle;
900     this.ctx.fillStyle = background || "#ffffff";
901     this.ctx.fillRect(0, 0, width, height);
902     this.ctx.fillStyle = savedFillStyle;
903 
904     if (transparency) {
905       const transparentCanvas = this.cachedCanvases.getCanvas(
906         "transparent",
907         width,
908         height
909       );
910       this.compositeCtx = this.ctx;
911       this.transparentCanvas = transparentCanvas.canvas;
912       this.ctx = transparentCanvas.context;
913       this.ctx.save();
914       // The transform can be applied before rendering, transferring it to
915       // the new canvas.
916       this.ctx.transform(...getCurrentTransform(this.compositeCtx));
917     }
918 
919     this.ctx.save();
920     resetCtxToDefault(this.ctx);
921     if (transform) {
922       this.ctx.transform(...transform);
923       this.outputScaleX = transform[0];
924       this.outputScaleY = transform[0];
925     }
926     this.ctx.transform(...viewport.transform);
927     this.viewportScale = viewport.scale;
928 
929     this.baseTransform = getCurrentTransform(this.ctx);
930   }
931 
932   executeOperatorList(
933     operatorList,
934     executionStartIdx,
935     continueCallback,
936     stepper
937   ) {
938     const argsArray = operatorList.argsArray;
939     const fnArray = operatorList.fnArray;
940     let i = executionStartIdx || 0;
941     const argsArrayLen = argsArray.length;
942 
943     // Sometimes the OperatorList to execute is empty.
944     if (argsArrayLen === i) {
945       return i;
946     }
947 
948     const chunkOperations =
949       argsArrayLen - i > EXECUTION_STEPS &&
950       typeof continueCallback === "function";
951     const endTime = chunkOperations ? Date.now() + EXECUTION_TIME : 0;
952     let steps = 0;
953 
954     const commonObjs = this.commonObjs;
955     const objs = this.objs;
956     let fnId;
957 
958     while (true) {
959       if (stepper !== undefined && i === stepper.nextBreakPoint) {
960         stepper.breakIt(i, continueCallback);
961         return i;
962       }
963 
964       fnId = fnArray[i];
965 
966       if (fnId !== OPS.dependency) {
967         // eslint-disable-next-line prefer-spread
968         this[fnId].apply(this, argsArray[i]);
969       } else {
970         for (const depObjId of argsArray[i]) {
971           const objsPool = depObjId.startsWith("g_") ? commonObjs : objs;
972 
973           // If the promise isn't resolved yet, add the continueCallback
974           // to the promise and bail out.
975           if (!objsPool.has(depObjId)) {
976             objsPool.get(depObjId, continueCallback);
977             return i;
978           }
979         }
980       }
981 
982       i++;
983 
984       // If the entire operatorList was executed, stop as were done.
985       if (i === argsArrayLen) {
986         return i;
987       }
988 
989       // If the execution took longer then a certain amount of time and
990       // `continueCallback` is specified, interrupt the execution.
991       if (chunkOperations && ++steps > EXECUTION_STEPS) {
992         if (Date.now() > endTime) {
993           continueCallback();
994           return i;
995         }
996         steps = 0;
997       }
998 
999       // If the operatorList isn't executed completely yet OR the execution
1000       // time was short enough, do another execution round.
1001     }
1002   }
1003 
1004   #restoreInitialState() {
1005     // Finishing all opened operations such as SMask group painting.
1006     while (this.stateStack.length || this.inSMaskMode) {
1007       this.restore();
1008     }
1009 
1010     this.current.activeSMask = null;
1011     this.ctx.restore();
1012 
1013     if (this.transparentCanvas) {
1014       this.ctx = this.compositeCtx;
1015       this.ctx.save();
1016       this.ctx.setTransform(1, 0, 0, 1, 0, 0); // Avoid apply transform twice
1017       this.ctx.drawImage(this.transparentCanvas, 0, 0);
1018       this.ctx.restore();
1019       this.transparentCanvas = null;
1020     }
1021   }
1022 
1023   endDrawing() {
1024     this.#restoreInitialState();
1025 
1026     this.cachedCanvases.clear();
1027     this.cachedPatterns.clear();
1028 
1029     for (const cache of this._cachedBitmapsMap.values()) {
1030       for (const canvas of cache.values()) {
1031         if (
1032           typeof HTMLCanvasElement !== "undefined" &&
1033           canvas instanceof HTMLCanvasElement
1034         ) {
1035           canvas.width = canvas.height = 0;
1036         }
1037       }
1038       cache.clear();
1039     }
1040     this._cachedBitmapsMap.clear();
1041     this.#drawFilter();
1042   }
1043 
1044   #drawFilter() {
1045     if (this.pageColors) {
1046       const hcmFilterId = this.filterFactory.addHCMFilter(
1047         this.pageColors.foreground,
1048         this.pageColors.background
1049       );
1050       if (hcmFilterId !== "none") {
1051         const savedFilter = this.ctx.filter;
1052         this.ctx.filter = hcmFilterId;
1053         this.ctx.drawImage(this.ctx.canvas, 0, 0);
1054         this.ctx.filter = savedFilter;
1055       }
1056     }
1057   }
1058 
1059   _scaleImage(img, inverseTransform) {
1060     // Vertical or horizontal scaling shall not be more than 2 to not lose the
1061     // pixels during drawImage operation, painting on the temporary canvas(es)
1062     // that are twice smaller in size.
1063 
1064     // displayWidth and displayHeight are used for VideoFrame.
1065     const width = img.width ?? img.displayWidth;
1066     const height = img.height ?? img.displayHeight;
1067     let widthScale = Math.max(
1068       Math.hypot(inverseTransform[0], inverseTransform[1]),
1069       1
1070     );
1071     let heightScale = Math.max(
1072       Math.hypot(inverseTransform[2], inverseTransform[3]),
1073       1
1074     );
1075 
1076     let paintWidth = width,
1077       paintHeight = height;
1078     let tmpCanvasId = "prescale1";
1079     let tmpCanvas, tmpCtx;
1080     while (
1081       (widthScale > 2 && paintWidth > 1) ||
1082       (heightScale > 2 && paintHeight > 1)
1083     ) {
1084       let newWidth = paintWidth,
1085         newHeight = paintHeight;
1086       if (widthScale > 2 && paintWidth > 1) {
1087         // See bug 1820511 (Windows specific bug).
1088         // TODO: once the above bug is fixed we could revert to:
1089         // newWidth = Math.ceil(paintWidth / 2);
1090         newWidth =
1091           paintWidth >= 16384
1092             ? Math.floor(paintWidth / 2) - 1 || 1
1093             : Math.ceil(paintWidth / 2);
1094         widthScale /= paintWidth / newWidth;
1095       }
1096       if (heightScale > 2 && paintHeight > 1) {
1097         // TODO: see the comment above.
1098         newHeight =
1099           paintHeight >= 16384
1100             ? Math.floor(paintHeight / 2) - 1 || 1
1101             : Math.ceil(paintHeight) / 2;
1102         heightScale /= paintHeight / newHeight;
1103       }
1104       tmpCanvas = this.cachedCanvases.getCanvas(
1105         tmpCanvasId,
1106         newWidth,
1107         newHeight
1108       );
1109       tmpCtx = tmpCanvas.context;
1110       tmpCtx.clearRect(0, 0, newWidth, newHeight);
1111       tmpCtx.drawImage(
1112         img,
1113         0,
1114         0,
1115         paintWidth,
1116         paintHeight,
1117         0,
1118         0,
1119         newWidth,
1120         newHeight
1121       );
1122       img = tmpCanvas.canvas;
1123       paintWidth = newWidth;
1124       paintHeight = newHeight;
1125       tmpCanvasId = tmpCanvasId === "prescale1" ? "prescale2" : "prescale1";
1126     }
1127     return {
1128       img,
1129       paintWidth,
1130       paintHeight,
1131     };
1132   }
1133 
1134   _createMaskCanvas(img) {
1135     const ctx = this.ctx;
1136     const { width, height } = img;
1137     const fillColor = this.current.fillColor;
1138     const isPatternFill = this.current.patternFill;
1139     const currentTransform = getCurrentTransform(ctx);
1140 
1141     let cache, cacheKey, scaled, maskCanvas;
1142     if ((img.bitmap || img.data) && img.count > 1) {
1143       const mainKey = img.bitmap || img.data.buffer;
1144       // We're reusing the same image several times, so we can cache it.
1145       // In case we've a pattern fill we just keep the scaled version of
1146       // the image.
1147       // Only the scaling part matters, the translation part is just used
1148       // to compute offsets (but not when filling patterns see #15573).
1149       // TODO: handle the case of a pattern fill if it's possible.
1150       cacheKey = JSON.stringify(
1151         isPatternFill
1152           ? currentTransform
1153           : [currentTransform.slice(0, 4), fillColor]
1154       );
1155 
1156       cache = this._cachedBitmapsMap.get(mainKey);
1157       if (!cache) {
1158         cache = new Map();
1159         this._cachedBitmapsMap.set(mainKey, cache);
1160       }
1161       const cachedImage = cache.get(cacheKey);
1162       if (cachedImage && !isPatternFill) {
1163         const offsetX = Math.round(
1164           Math.min(currentTransform[0], currentTransform[2]) +
1165             currentTransform[4]
1166         );
1167         const offsetY = Math.round(
1168           Math.min(currentTransform[1], currentTransform[3]) +
1169             currentTransform[5]
1170         );
1171         return {
1172           canvas: cachedImage,
1173           offsetX,
1174           offsetY,
1175         };
1176       }
1177       scaled = cachedImage;
1178     }
1179 
1180     if (!scaled) {
1181       maskCanvas = this.cachedCanvases.getCanvas("maskCanvas", width, height);
1182       putBinaryImageMask(maskCanvas.context, img);
1183     }
1184 
1185     // Create the mask canvas at the size it will be drawn at and also set
1186     // its transform to match the current transform so if there are any
1187     // patterns applied they will be applied relative to the correct
1188     // transform.
1189 
1190     let maskToCanvas = Util.transform(currentTransform, [
1191       1 / width,
1192       0,
1193       0,
1194       -1 / height,
1195       0,
1196       0,
1197     ]);
1198     maskToCanvas = Util.transform(maskToCanvas, [1, 0, 0, 1, 0, -height]);
1199     const [minX, minY, maxX, maxY] = Util.getAxialAlignedBoundingBox(
1200       [0, 0, width, height],
1201       maskToCanvas
1202     );
1203     const drawnWidth = Math.round(maxX - minX) || 1;
1204     const drawnHeight = Math.round(maxY - minY) || 1;
1205     const fillCanvas = this.cachedCanvases.getCanvas(
1206       "fillCanvas",
1207       drawnWidth,
1208       drawnHeight
1209     );
1210     const fillCtx = fillCanvas.context;
1211 
1212     // The offset will be the top-left cordinate mask.
1213     // If objToCanvas is [a,b,c,d,e,f] then:
1214     //   - offsetX = min(a, c) + e
1215     //   - offsetY = min(b, d) + f
1216     const offsetX = minX;
1217     const offsetY = minY;
1218     fillCtx.translate(-offsetX, -offsetY);
1219     fillCtx.transform(...maskToCanvas);
1220 
1221     if (!scaled) {
1222       // Pre-scale if needed to improve image smoothing.
1223       scaled = this._scaleImage(
1224         maskCanvas.canvas,
1225         getCurrentTransformInverse(fillCtx)
1226       );
1227       scaled = scaled.img;
1228       if (cache && isPatternFill) {
1229         cache.set(cacheKey, scaled);
1230       }
1231     }
1232 
1233     fillCtx.imageSmoothingEnabled = getImageSmoothingEnabled(
1234       getCurrentTransform(fillCtx),
1235       img.interpolate
1236     );
1237 
1238     drawImageAtIntegerCoords(
1239       fillCtx,
1240       scaled,
1241       0,
1242       0,
1243       scaled.width,
1244       scaled.height,
1245       0,
1246       0,
1247       width,
1248       height
1249     );
1250     fillCtx.globalCompositeOperation = "source-in";
1251 
1252     const inverse = Util.transform(getCurrentTransformInverse(fillCtx), [
1253       1,
1254       0,
1255       0,
1256       1,
1257       -offsetX,
1258       -offsetY,
1259     ]);
1260     fillCtx.fillStyle = isPatternFill
1261       ? fillColor.getPattern(ctx, this, inverse, PathType.FILL)
1262       : fillColor;
1263 
1264     fillCtx.fillRect(0, 0, width, height);
1265 
1266     if (cache && !isPatternFill) {
1267       // The fill canvas is put in the cache associated to the mask image
1268       // so we must remove from the cached canvas: it mustn't be used again.
1269       this.cachedCanvases.delete("fillCanvas");
1270       cache.set(cacheKey, fillCanvas.canvas);
1271     }
1272 
1273     // Round the offsets to avoid drawing fractional pixels.
1274     return {
1275       canvas: fillCanvas.canvas,
1276       offsetX: Math.round(offsetX),
1277       offsetY: Math.round(offsetY),
1278     };
1279   }
1280 
1281   // Graphics state
1282   setLineWidth(width) {
1283     if (width !== this.current.lineWidth) {
1284       this._cachedScaleForStroking[0] = -1;
1285     }
1286     this.current.lineWidth = width;
1287     this.ctx.lineWidth = width;
1288   }
1289 
1290   setLineCap(style) {
1291     this.ctx.lineCap = LINE_CAP_STYLES[style];
1292   }
1293 
1294   setLineJoin(style) {
1295     this.ctx.lineJoin = LINE_JOIN_STYLES[style];
1296   }
1297 
1298   setMiterLimit(limit) {
1299     this.ctx.miterLimit = limit;
1300   }
1301 
1302   setDash(dashArray, dashPhase) {
1303     const ctx = this.ctx;
1304     if (ctx.setLineDash !== undefined) {
1305       ctx.setLineDash(dashArray);
1306       ctx.lineDashOffset = dashPhase;
1307     }
1308   }
1309 
1310   setRenderingIntent(intent) {
1311     // This operation is ignored since we haven't found a use case for it yet.
1312   }
1313 
1314   setFlatness(flatness) {
1315     // This operation is ignored since we haven't found a use case for it yet.
1316   }
1317 
1318   setGState(states) {
1319     for (const [key, value] of states) {
1320       switch (key) {
1321         case "LW":
1322           this.setLineWidth(value);
1323           break;
1324         case "LC":
1325           this.setLineCap(value);
1326           break;
1327         case "LJ":
1328           this.setLineJoin(value);
1329           break;
1330         case "ML":
1331           this.setMiterLimit(value);
1332           break;
1333         case "D":
1334           this.setDash(value[0], value[1]);
1335           break;
1336         case "RI":
1337           this.setRenderingIntent(value);
1338           break;
1339         case "FL":
1340           this.setFlatness(value);
1341           break;
1342         case "Font":
1343           this.setFont(value[0], value[1]);
1344           break;
1345         case "CA":
1346           this.current.strokeAlpha = value;
1347           break;
1348         case "ca":
1349           this.current.fillAlpha = value;
1350           this.ctx.globalAlpha = value;
1351           break;
1352         case "BM":
1353           this.ctx.globalCompositeOperation = value;
1354           break;
1355         case "SMask":
1356           this.current.activeSMask = value ? this.tempSMask : null;
1357           this.tempSMask = null;
1358           this.checkSMaskState();
1359           break;
1360         case "TR":
1361           this.ctx.filter = this.current.transferMaps =
1362             this.filterFactory.addFilter(value);
1363           break;
1364       }
1365     }
1366   }
1367 
1368   get inSMaskMode() {
1369     return !!this.suspendedCtx;
1370   }
1371 
1372   checkSMaskState() {
1373     const inSMaskMode = this.inSMaskMode;
1374     if (this.current.activeSMask && !inSMaskMode) {
1375       this.beginSMaskMode();
1376     } else if (!this.current.activeSMask && inSMaskMode) {
1377       this.endSMaskMode();
1378     }
1379     // Else, the state is okay and nothing needs to be done.
1380   }
1381 
1382   /**
1383    * Soft mask mode takes the current main drawing canvas and replaces it with
1384    * a temporary canvas. Any drawing operations that happen on the temporary
1385    * canvas need to be composed with the main canvas that was suspended (see
1386    * `compose()`). The temporary canvas also duplicates many of its operations
1387    * on the suspended canvas to keep them in sync, so that when the soft mask
1388    * mode ends any clipping paths or transformations will still be active and in
1389    * the right order on the canvas' graphics state stack.
1390    */
1391   beginSMaskMode() {
1392     if (this.inSMaskMode) {
1393       throw new Error("beginSMaskMode called while already in smask mode");
1394     }
1395     const drawnWidth = this.ctx.canvas.width;
1396     const drawnHeight = this.ctx.canvas.height;
1397     const cacheId = "smaskGroupAt" + this.groupLevel;
1398     const scratchCanvas = this.cachedCanvases.getCanvas(
1399       cacheId,
1400       drawnWidth,
1401       drawnHeight
1402     );
1403     this.suspendedCtx = this.ctx;
1404     this.ctx = scratchCanvas.context;
1405     const ctx = this.ctx;
1406     ctx.setTransform(...getCurrentTransform(this.suspendedCtx));
1407     copyCtxState(this.suspendedCtx, ctx);
1408     mirrorContextOperations(ctx, this.suspendedCtx);
1409 
1410     this.setGState([
1411       ["BM", "source-over"],
1412       ["ca", 1],
1413       ["CA", 1],
1414     ]);
1415   }
1416 
1417   endSMaskMode() {
1418     if (!this.inSMaskMode) {
1419       throw new Error("endSMaskMode called while not in smask mode");
1420     }
1421     // The soft mask is done, now restore the suspended canvas as the main
1422     // drawing canvas.
1423     this.ctx._removeMirroring();
1424     copyCtxState(this.ctx, this.suspendedCtx);
1425     this.ctx = this.suspendedCtx;
1426 
1427     this.suspendedCtx = null;
1428   }
1429 
1430   compose(dirtyBox) {
1431     if (!this.current.activeSMask) {
1432       return;
1433     }
1434 
1435     if (!dirtyBox) {
1436       dirtyBox = [0, 0, this.ctx.canvas.width, this.ctx.canvas.height];
1437     } else {
1438       dirtyBox[0] = Math.floor(dirtyBox[0]);
1439       dirtyBox[1] = Math.floor(dirtyBox[1]);
1440       dirtyBox[2] = Math.ceil(dirtyBox[2]);
1441       dirtyBox[3] = Math.ceil(dirtyBox[3]);
1442     }
1443     const smask = this.current.activeSMask;
1444     const suspendedCtx = this.suspendedCtx;
1445 
1446     this.composeSMask(suspendedCtx, smask, this.ctx, dirtyBox);
1447     // Whatever was drawn has been moved to the suspended canvas, now clear it
1448     // out of the current canvas.
1449     this.ctx.save();
1450     this.ctx.setTransform(1, 0, 0, 1, 0, 0);
1451     this.ctx.clearRect(0, 0, this.ctx.canvas.width, this.ctx.canvas.height);
1452     this.ctx.restore();
1453   }
1454 
1455   composeSMask(ctx, smask, layerCtx, layerBox) {
1456     const layerOffsetX = layerBox[0];
1457     const layerOffsetY = layerBox[1];
1458     const layerWidth = layerBox[2] - layerOffsetX;
1459     const layerHeight = layerBox[3] - layerOffsetY;
1460     if (layerWidth === 0 || layerHeight === 0) {
1461       return;
1462     }
1463     this.genericComposeSMask(
1464       smask.context,
1465       layerCtx,
1466       layerWidth,
1467       layerHeight,
1468       smask.subtype,
1469       smask.backdrop,
1470       smask.transferMap,
1471       layerOffsetX,
1472       layerOffsetY,
1473       smask.offsetX,
1474       smask.offsetY
1475     );
1476     ctx.save();
1477     ctx.globalAlpha = 1;
1478     ctx.globalCompositeOperation = "source-over";
1479     ctx.setTransform(1, 0, 0, 1, 0, 0);
1480     ctx.drawImage(layerCtx.canvas, 0, 0);
1481     ctx.restore();
1482   }
1483 
1484   genericComposeSMask(
1485     maskCtx,
1486     layerCtx,
1487     width,
1488     height,
1489     subtype,
1490     backdrop,
1491     transferMap,
1492     layerOffsetX,
1493     layerOffsetY,
1494     maskOffsetX,
1495     maskOffsetY
1496   ) {
1497     let maskCanvas = maskCtx.canvas;
1498     let maskX = layerOffsetX - maskOffsetX;
1499     let maskY = layerOffsetY - maskOffsetY;
1500 
1501     if (backdrop) {
1502       const backdropRGB = Util.makeHexColor(...backdrop);
1503       if (
1504         maskX < 0 ||
1505         maskY < 0 ||
1506         maskX + width > maskCanvas.width ||
1507         maskY + height > maskCanvas.height
1508       ) {
1509         const canvas = this.cachedCanvases.getCanvas(
1510           "maskExtension",
1511           width,
1512           height
1513         );
1514         const ctx = canvas.context;
1515         ctx.drawImage(maskCanvas, -maskX, -maskY);
1516         ctx.globalCompositeOperation = "destination-atop";
1517         ctx.fillStyle = backdropRGB;
1518         ctx.fillRect(0, 0, width, height);
1519         ctx.globalCompositeOperation = "source-over";
1520 
1521         maskCanvas = canvas.canvas;
1522         maskX = maskY = 0;
1523       } else {
1524         maskCtx.save();
1525         maskCtx.globalAlpha = 1;
1526         maskCtx.setTransform(1, 0, 0, 1, 0, 0);
1527         const clip = new Path2D();
1528         clip.rect(maskX, maskY, width, height);
1529         maskCtx.clip(clip);
1530         maskCtx.globalCompositeOperation = "destination-atop";
1531         maskCtx.fillStyle = backdropRGB;
1532         maskCtx.fillRect(maskX, maskY, width, height);
1533         maskCtx.restore();
1534       }
1535     }
1536 
1537     layerCtx.save();
1538     layerCtx.globalAlpha = 1;
1539     layerCtx.setTransform(1, 0, 0, 1, 0, 0);
1540 
1541     if (subtype === "Alpha" && transferMap) {
1542       layerCtx.filter = this.filterFactory.addAlphaFilter(transferMap);
1543     } else if (subtype === "Luminosity") {
1544       layerCtx.filter = this.filterFactory.addLuminosityFilter(transferMap);
1545     }
1546 
1547     const clip = new Path2D();
1548     clip.rect(layerOffsetX, layerOffsetY, width, height);
1549     layerCtx.clip(clip);
1550     layerCtx.globalCompositeOperation = "destination-in";
1551     layerCtx.drawImage(
1552       maskCanvas,
1553       maskX,
1554       maskY,
1555       width,
1556       height,
1557       layerOffsetX,
1558       layerOffsetY,
1559       width,
1560       height
1561     );
1562     layerCtx.restore();
1563   }
1564 
1565   save() {
1566     if (this.inSMaskMode) {
1567       // SMask mode may be turned on/off causing us to lose graphics state.
1568       // Copy the temporary canvas state to the main(suspended) canvas to keep
1569       // it in sync.
1570       copyCtxState(this.ctx, this.suspendedCtx);
1571       // Don't bother calling save on the temporary canvas since state is not
1572       // saved there.
1573       this.suspendedCtx.save();
1574     } else {
1575       this.ctx.save();
1576     }
1577     const old = this.current;
1578     this.stateStack.push(old);
1579     this.current = old.clone();
1580   }
1581 
1582   restore() {
1583     if (this.stateStack.length === 0 && this.inSMaskMode) {
1584       this.endSMaskMode();
1585     }
1586     if (this.stateStack.length !== 0) {
1587       this.current = this.stateStack.pop();
1588       if (this.inSMaskMode) {
1589         // Graphics state is stored on the main(suspended) canvas. Restore its
1590         // state then copy it over to the temporary canvas.
1591         this.suspendedCtx.restore();
1592         copyCtxState(this.suspendedCtx, this.ctx);
1593       } else {
1594         this.ctx.restore();
1595       }
1596       this.checkSMaskState();
1597 
1598       // Ensure that the clipping path is reset (fixes issue6413.pdf).
1599       this.pendingClip = null;
1600 
1601       this._cachedScaleForStroking[0] = -1;
1602       this._cachedGetSinglePixelWidth = null;
1603     }
1604   }
1605 
1606   transform(a, b, c, d, e, f) {
1607     this.ctx.transform(a, b, c, d, e, f);
1608 
1609     this._cachedScaleForStroking[0] = -1;
1610     this._cachedGetSinglePixelWidth = null;
1611   }
1612 
1613   // Path
1614   constructPath(ops, args, minMax) {
1615     const ctx = this.ctx;
1616     const current = this.current;
1617     let x = current.x,
1618       y = current.y;
1619     let startX, startY;
1620     const currentTransform = getCurrentTransform(ctx);
1621 
1622     // Most of the time the current transform is a scaling matrix
1623     // so we don't need to transform points before computing min/max:
1624     // we can compute min/max first and then smartly "apply" the
1625     // transform (see Util.scaleMinMax).
1626     // For rectangle, moveTo and lineTo, min/max are computed in the
1627     // worker (see evaluator.js).
1628     const isScalingMatrix =
1629       (currentTransform[0] === 0 && currentTransform[3] === 0) ||
1630       (currentTransform[1] === 0 && currentTransform[2] === 0);
1631     const minMaxForBezier = isScalingMatrix ? minMax.slice(0) : null;
1632 
1633     for (let i = 0, j = 0, ii = ops.length; i < ii; i++) {
1634       switch (ops[i] | 0) {
1635         case OPS.rectangle:
1636           x = args[j++];
1637           y = args[j++];
1638           const width = args[j++];
1639           const height = args[j++];
1640 
1641           const xw = x + width;
1642           const yh = y + height;
1643           ctx.moveTo(x, y);
1644           if (width === 0 || height === 0) {
1645             ctx.lineTo(xw, yh);
1646           } else {
1647             ctx.lineTo(xw, y);
1648             ctx.lineTo(xw, yh);
1649             ctx.lineTo(x, yh);
1650           }
1651           if (!isScalingMatrix) {
1652             current.updateRectMinMax(currentTransform, [x, y, xw, yh]);
1653           }
1654           ctx.closePath();
1655           break;
1656         case OPS.moveTo:
1657           x = args[j++];
1658           y = args[j++];
1659           ctx.moveTo(x, y);
1660           if (!isScalingMatrix) {
1661             current.updatePathMinMax(currentTransform, x, y);
1662           }
1663           break;
1664         case OPS.lineTo:
1665           x = args[j++];
1666           y = args[j++];
1667           ctx.lineTo(x, y);
1668           if (!isScalingMatrix) {
1669             current.updatePathMinMax(currentTransform, x, y);
1670           }
1671           break;
1672         case OPS.curveTo:
1673           startX = x;
1674           startY = y;
1675           x = args[j + 4];
1676           y = args[j + 5];
1677           ctx.bezierCurveTo(
1678             args[j],
1679             args[j + 1],
1680             args[j + 2],
1681             args[j + 3],
1682             x,
1683             y
1684           );
1685           current.updateCurvePathMinMax(
1686             currentTransform,
1687             startX,
1688             startY,
1689             args[j],
1690             args[j + 1],
1691             args[j + 2],
1692             args[j + 3],
1693             x,
1694             y,
1695             minMaxForBezier
1696           );
1697           j += 6;
1698           break;
1699         case OPS.curveTo2:
1700           startX = x;
1701           startY = y;
1702           ctx.bezierCurveTo(
1703             x,
1704             y,
1705             args[j],
1706             args[j + 1],
1707             args[j + 2],
1708             args[j + 3]
1709           );
1710           current.updateCurvePathMinMax(
1711             currentTransform,
1712             startX,
1713             startY,
1714             x,
1715             y,
1716             args[j],
1717             args[j + 1],
1718             args[j + 2],
1719             args[j + 3],
1720             minMaxForBezier
1721           );
1722           x = args[j + 2];
1723           y = args[j + 3];
1724           j += 4;
1725           break;
1726         case OPS.curveTo3:
1727           startX = x;
1728           startY = y;
1729           x = args[j + 2];
1730           y = args[j + 3];
1731           ctx.bezierCurveTo(args[j], args[j + 1], x, y, x, y);
1732           current.updateCurvePathMinMax(
1733             currentTransform,
1734             startX,
1735             startY,
1736             args[j],
1737             args[j + 1],
1738             x,
1739             y,
1740             x,
1741             y,
1742             minMaxForBezier
1743           );
1744           j += 4;
1745           break;
1746         case OPS.closePath:
1747           ctx.closePath();
1748           break;
1749       }
1750     }
1751 
1752     if (isScalingMatrix) {
1753       current.updateScalingPathMinMax(currentTransform, minMaxForBezier);
1754     }
1755 
1756     current.setCurrentPoint(x, y);
1757   }
1758 
1759   closePath() {
1760     this.ctx.closePath();
1761   }
1762 
1763   stroke(consumePath = true) {
1764     const ctx = this.ctx;
1765     const strokeColor = this.current.strokeColor;
1766     // For stroke we want to temporarily change the global alpha to the
1767     // stroking alpha.
1768     ctx.globalAlpha = this.current.strokeAlpha;
1769     if (this.contentVisible) {
1770       if (typeof strokeColor === "object" && strokeColor?.getPattern) {
1771         ctx.save();
1772         ctx.strokeStyle = strokeColor.getPattern(
1773           ctx,
1774           this,
1775           getCurrentTransformInverse(ctx),
1776           PathType.STROKE
1777         );
1778         this.rescaleAndStroke(/* saveRestore */ false);
1779         ctx.restore();
1780       } else {
1781         this.rescaleAndStroke(/* saveRestore */ true);
1782       }
1783     }
1784     if (consumePath) {
1785       this.consumePath(this.current.getClippedPathBoundingBox());
1786     }
1787     // Restore the global alpha to the fill alpha
1788     ctx.globalAlpha = this.current.fillAlpha;
1789   }
1790 
1791   closeStroke() {
1792     this.closePath();
1793     this.stroke();
1794   }
1795 
1796   fill(consumePath = true) {
1797     const ctx = this.ctx;
1798     const fillColor = this.current.fillColor;
1799     const isPatternFill = this.current.patternFill;
1800     let needRestore = false;
1801 
1802     if (isPatternFill) {
1803       ctx.save();
1804       ctx.fillStyle = fillColor.getPattern(
1805         ctx,
1806         this,
1807         getCurrentTransformInverse(ctx),
1808         PathType.FILL
1809       );
1810       needRestore = true;
1811     }
1812 
1813     const intersect = this.current.getClippedPathBoundingBox();
1814     if (this.contentVisible && intersect !== null) {
1815       if (this.pendingEOFill) {
1816         ctx.fill("evenodd");
1817         this.pendingEOFill = false;
1818       } else {
1819         ctx.fill();
1820       }
1821     }
1822 
1823     if (needRestore) {
1824       ctx.restore();
1825     }
1826     if (consumePath) {
1827       this.consumePath(intersect);
1828     }
1829   }
1830 
1831   eoFill() {
1832     this.pendingEOFill = true;
1833     this.fill();
1834   }
1835 
1836   fillStroke() {
1837     this.fill(false);
1838     this.stroke(false);
1839 
1840     this.consumePath();
1841   }
1842 
1843   eoFillStroke() {
1844     this.pendingEOFill = true;
1845     this.fillStroke();
1846   }
1847 
1848   closeFillStroke() {
1849     this.closePath();
1850     this.fillStroke();
1851   }
1852 
1853   closeEOFillStroke() {
1854     this.pendingEOFill = true;
1855     this.closePath();
1856     this.fillStroke();
1857   }
1858 
1859   endPath() {
1860     this.consumePath();
1861   }
1862 
1863   // Clipping
1864   clip() {
1865     this.pendingClip = NORMAL_CLIP;
1866   }
1867 
1868   eoClip() {
1869     this.pendingClip = EO_CLIP;
1870   }
1871 
1872   // Text
1873   beginText() {
1874     this.current.textMatrix = IDENTITY_MATRIX;
1875     this.current.textMatrixScale = 1;
1876     this.current.x = this.current.lineX = 0;
1877     this.current.y = this.current.lineY = 0;
1878   }
1879 
1880   endText() {
1881     const paths = this.pendingTextPaths;
1882     const ctx = this.ctx;
1883     if (paths === undefined) {
1884       ctx.beginPath();
1885       return;
1886     }
1887 
1888     const newPath = new Path2D();
1889     const invTransf = ctx.getTransform().invertSelf();
1890     for (const { transform, x, y, fontSize, path } of paths) {
1891       newPath.addPath(
1892         path,
1893         new DOMMatrix(transform)
1894           .preMultiplySelf(invTransf)
1895           .translate(x, y)
1896           .scale(fontSize, -fontSize)
1897       );
1898     }
1899 
1900     ctx.clip(newPath);
1901     ctx.beginPath();
1902     delete this.pendingTextPaths;
1903   }
1904 
1905   setCharSpacing(spacing) {
1906     this.current.charSpacing = spacing;
1907   }
1908 
1909   setWordSpacing(spacing) {
1910     this.current.wordSpacing = spacing;
1911   }
1912 
1913   setHScale(scale) {
1914     this.current.textHScale = scale / 100;
1915   }
1916 
1917   setLeading(leading) {
1918     this.current.leading = -leading;
1919   }
1920 
1921   setFont(fontRefName, size) {
1922     const fontObj = this.commonObjs.get(fontRefName);
1923     const current = this.current;
1924 
1925     if (!fontObj) {
1926       throw new Error(`Can't find font for ${fontRefName}`);
1927     }
1928     current.fontMatrix = fontObj.fontMatrix || FONT_IDENTITY_MATRIX;
1929 
1930     // A valid matrix needs all main diagonal elements to be non-zero
1931     // This also ensures we bypass FF bugzilla bug #719844.
1932     if (current.fontMatrix[0] === 0 || current.fontMatrix[3] === 0) {
1933       warn("Invalid font matrix for font " + fontRefName);
1934     }
1935 
1936     // The spec for Tf (setFont) says that 'size' specifies the font 'scale',
1937     // and in some docs this can be negative (inverted x-y axes).
1938     if (size < 0) {
1939       size = -size;
1940       current.fontDirection = -1;
1941     } else {
1942       current.fontDirection = 1;
1943     }
1944 
1945     this.current.font = fontObj;
1946     this.current.fontSize = size;
1947 
1948     if (fontObj.isType3Font) {
1949       return; // we don't need ctx.font for Type3 fonts
1950     }
1951 
1952     const name = fontObj.loadedName || "sans-serif";
1953     const typeface =
1954       fontObj.systemFontInfo?.css || `"${name}", ${fontObj.fallbackName}`;
1955 
1956     let bold = "normal";
1957     if (fontObj.black) {
1958       bold = "900";
1959     } else if (fontObj.bold) {
1960       bold = "bold";
1961     }
1962     const italic = fontObj.italic ? "italic" : "normal";
1963 
1964     // Some font backends cannot handle fonts below certain size.
1965     // Keeping the font at minimal size and using the fontSizeScale to change
1966     // the current transformation matrix before the fillText/strokeText.
1967     // See https://bugzilla.mozilla.org/show_bug.cgi?id=726227
1968     let browserFontSize = size;
1969     if (size < MIN_FONT_SIZE) {
1970       browserFontSize = MIN_FONT_SIZE;
1971     } else if (size > MAX_FONT_SIZE) {
1972       browserFontSize = MAX_FONT_SIZE;
1973     }
1974     this.current.fontSizeScale = size / browserFontSize;
1975 
1976     this.ctx.font = `${italic} ${bold} ${browserFontSize}px ${typeface}`;
1977   }
1978 
1979   setTextRenderingMode(mode) {
1980     this.current.textRenderingMode = mode;
1981   }
1982 
1983   setTextRise(rise) {
1984     this.current.textRise = rise;
1985   }
1986 
1987   moveText(x, y) {
1988     this.current.x = this.current.lineX += x;
1989     this.current.y = this.current.lineY += y;
1990   }
1991 
1992   setLeadingMoveText(x, y) {
1993     this.setLeading(-y);
1994     this.moveText(x, y);
1995   }
1996 
1997   setTextMatrix(a, b, c, d, e, f) {
1998     this.current.textMatrix = [a, b, c, d, e, f];
1999     this.current.textMatrixScale = Math.hypot(a, b);
2000 
2001     this.current.x = this.current.lineX = 0;
2002     this.current.y = this.current.lineY = 0;
2003   }
2004 
2005   nextLine() {
2006     this.moveText(0, this.current.leading);
2007   }
2008 
2009   #getScaledPath(path, currentTransform, transform) {
2010     const newPath = new Path2D();
2011     newPath.addPath(
2012       path,
2013       new DOMMatrix(transform).invertSelf().multiplySelf(currentTransform)
2014     );
2015     return newPath;
2016   }
2017 
2018   paintChar(character, x, y, patternFillTransform, patternStrokeTransform) {
2019     const ctx = this.ctx;
2020     const current = this.current;
2021     const font = current.font;
2022     const textRenderingMode = current.textRenderingMode;
2023     const fontSize = current.fontSize / current.fontSizeScale;
2024     const fillStrokeMode =
2025       textRenderingMode & TextRenderingMode.FILL_STROKE_MASK;
2026     const isAddToPathSet = !!(
2027       textRenderingMode & TextRenderingMode.ADD_TO_PATH_FLAG
2028     );
2029     const patternFill = current.patternFill && !font.missingFile;
2030     const patternStroke = current.patternStroke && !font.missingFile;
2031 
2032     let path;
2033     if (
2034       font.disableFontFace ||
2035       isAddToPathSet ||
2036       patternFill ||
2037       patternStroke
2038     ) {
2039       path = font.getPathGenerator(this.commonObjs, character);
2040     }
2041 
2042     if (font.disableFontFace || patternFill || patternStroke) {
2043       ctx.save();
2044       ctx.translate(x, y);
2045       ctx.scale(fontSize, -fontSize);
2046       let currentTransform;
2047       if (
2048         fillStrokeMode === TextRenderingMode.FILL ||
2049         fillStrokeMode === TextRenderingMode.FILL_STROKE
2050       ) {
2051         if (patternFillTransform) {
2052           currentTransform = ctx.getTransform();
2053           ctx.setTransform(...patternFillTransform);
2054           ctx.fill(
2055             this.#getScaledPath(path, currentTransform, patternFillTransform)
2056           );
2057         } else {
2058           ctx.fill(path);
2059         }
2060       }
2061       if (
2062         fillStrokeMode === TextRenderingMode.STROKE ||
2063         fillStrokeMode === TextRenderingMode.FILL_STROKE
2064       ) {
2065         if (patternStrokeTransform) {
2066           currentTransform ||= ctx.getTransform();
2067           ctx.setTransform(...patternStrokeTransform);
2068           const { a, b, c, d } = currentTransform;
2069           const invPatternTransform = Util.inverseTransform(
2070             patternStrokeTransform
2071           );
2072           const transf = Util.transform(
2073             [a, b, c, d, 0, 0],
2074             invPatternTransform
2075           );
2076           const [sx, sy] = Util.singularValueDecompose2dScale(transf);
2077 
2078           // Cancel the pattern scaling of the line width.
2079           // If sx and sy are different, unfortunately we can't do anything and
2080           // we'll have a rendering bug.
2081           ctx.lineWidth *= Math.max(sx, sy) / fontSize;
2082           ctx.stroke(
2083             this.#getScaledPath(path, currentTransform, patternStrokeTransform)
2084           );
2085         } else {
2086           ctx.lineWidth /= fontSize;
2087           ctx.stroke(path);
2088         }
2089       }
2090       ctx.restore();
2091     } else {
2092       if (
2093         fillStrokeMode === TextRenderingMode.FILL ||
2094         fillStrokeMode === TextRenderingMode.FILL_STROKE
2095       ) {
2096         ctx.fillText(character, x, y);
2097       }
2098       if (
2099         fillStrokeMode === TextRenderingMode.STROKE ||
2100         fillStrokeMode === TextRenderingMode.FILL_STROKE
2101       ) {
2102         ctx.strokeText(character, x, y);
2103       }
2104     }
2105 
2106     if (isAddToPathSet) {
2107       const paths = (this.pendingTextPaths ||= []);
2108       paths.push({
2109         transform: getCurrentTransform(ctx),
2110         x,
2111         y,
2112         fontSize,
2113         path,
2114       });
2115     }
2116   }
2117 
2118   get isFontSubpixelAAEnabled() {
2119     // Checks if anti-aliasing is enabled when scaled text is painted.
2120     // On Windows GDI scaled fonts looks bad.
2121     const { context: ctx } = this.cachedCanvases.getCanvas(
2122       "isFontSubpixelAAEnabled",
2123       10,
2124       10
2125     );
2126     ctx.scale(1.5, 1);
2127     ctx.fillText("I", 0, 10);
2128     const data = ctx.getImageData(0, 0, 10, 10).data;
2129     let enabled = false;
2130     for (let i = 3; i < data.length; i += 4) {
2131       if (data[i] > 0 && data[i] < 255) {
2132         enabled = true;
2133         break;
2134       }
2135     }
2136     return shadow(this, "isFontSubpixelAAEnabled", enabled);
2137   }
2138 
2139   showText(glyphs) {
2140     const current = this.current;
2141     const font = current.font;
2142     if (font.isType3Font) {
2143       return this.showType3Text(glyphs);
2144     }
2145 
2146     const fontSize = current.fontSize;
2147     if (fontSize === 0) {
2148       return undefined;
2149     }
2150 
2151     const ctx = this.ctx;
2152     const fontSizeScale = current.fontSizeScale;
2153     const charSpacing = current.charSpacing;
2154     const wordSpacing = current.wordSpacing;
2155     const fontDirection = current.fontDirection;
2156     const textHScale = current.textHScale * fontDirection;
2157     const glyphsLength = glyphs.length;
2158     const vertical = font.vertical;
2159     const spacingDir = vertical ? 1 : -1;
2160     const defaultVMetrics = font.defaultVMetrics;
2161     const widthAdvanceScale = fontSize * current.fontMatrix[0];
2162 
2163     const simpleFillText =
2164       current.textRenderingMode === TextRenderingMode.FILL &&
2165       !font.disableFontFace &&
2166       !current.patternFill;
2167 
2168     ctx.save();
2169     ctx.transform(...current.textMatrix);
2170     ctx.translate(current.x, current.y + current.textRise);
2171 
2172     if (fontDirection > 0) {
2173       ctx.scale(textHScale, -1);
2174     } else {
2175       ctx.scale(textHScale, 1);
2176     }
2177 
2178     let patternFillTransform, patternStrokeTransform;
2179     if (current.patternFill) {
2180       ctx.save();
2181       const pattern = current.fillColor.getPattern(
2182         ctx,
2183         this,
2184         getCurrentTransformInverse(ctx),
2185         PathType.FILL
2186       );
2187       patternFillTransform = getCurrentTransform(ctx);
2188       ctx.restore();
2189       ctx.fillStyle = pattern;
2190     }
2191 
2192     if (current.patternStroke) {
2193       ctx.save();
2194       const pattern = current.strokeColor.getPattern(
2195         ctx,
2196         this,
2197         getCurrentTransformInverse(ctx),
2198         PathType.STROKE
2199       );
2200       patternStrokeTransform = getCurrentTransform(ctx);
2201       ctx.restore();
2202       ctx.strokeStyle = pattern;
2203     }
2204 
2205     let lineWidth = current.lineWidth;
2206     const scale = current.textMatrixScale;
2207     if (scale === 0 || lineWidth === 0) {
2208       const fillStrokeMode =
2209         current.textRenderingMode & TextRenderingMode.FILL_STROKE_MASK;
2210       if (
2211         fillStrokeMode === TextRenderingMode.STROKE ||
2212         fillStrokeMode === TextRenderingMode.FILL_STROKE
2213       ) {
2214         lineWidth = this.getSinglePixelWidth();
2215       }
2216     } else {
2217       lineWidth /= scale;
2218     }
2219 
2220     if (fontSizeScale !== 1.0) {
2221       ctx.scale(fontSizeScale, fontSizeScale);
2222       lineWidth /= fontSizeScale;
2223     }
2224 
2225     ctx.lineWidth = lineWidth;
2226 
2227     if (font.isInvalidPDFjsFont) {
2228       const chars = [];
2229       let width = 0;
2230       for (const glyph of glyphs) {
2231         chars.push(glyph.unicode);
2232         width += glyph.width;
2233       }
2234       ctx.fillText(chars.join(""), 0, 0);
2235       current.x += width * widthAdvanceScale * textHScale;
2236       ctx.restore();
2237       this.compose();
2238 
2239       return undefined;
2240     }
2241 
2242     let x = 0,
2243       i;
2244     for (i = 0; i < glyphsLength; ++i) {
2245       const glyph = glyphs[i];
2246       if (typeof glyph === "number") {
2247         x += (spacingDir * glyph * fontSize) / 1000;
2248         continue;
2249       }
2250 
2251       let restoreNeeded = false;
2252       const spacing = (glyph.isSpace ? wordSpacing : 0) + charSpacing;
2253       const character = glyph.fontChar;
2254       const accent = glyph.accent;
2255       let scaledX, scaledY;
2256       let width = glyph.width;
2257       if (vertical) {
2258         const vmetric = glyph.vmetric || defaultVMetrics;
2259         const vx =
2260           -(glyph.vmetric ? vmetric[1] : width * 0.5) * widthAdvanceScale;
2261         const vy = vmetric[2] * widthAdvanceScale;
2262 
2263         width = vmetric ? -vmetric[0] : width;
2264         scaledX = vx / fontSizeScale;
2265         scaledY = (x + vy) / fontSizeScale;
2266       } else {
2267         scaledX = x / fontSizeScale;
2268         scaledY = 0;
2269       }
2270 
2271       if (font.remeasure && width > 0) {
2272         // Some standard fonts may not have the exact width: rescale per
2273         // character if measured width is greater than expected glyph width
2274         // and subpixel-aa is enabled, otherwise just center the glyph.
2275         const measuredWidth =
2276           ((ctx.measureText(character).width * 1000) / fontSize) *
2277           fontSizeScale;
2278         if (width < measuredWidth && this.isFontSubpixelAAEnabled) {
2279           const characterScaleX = width / measuredWidth;
2280           restoreNeeded = true;
2281           ctx.save();
2282           ctx.scale(characterScaleX, 1);
2283           scaledX /= characterScaleX;
2284         } else if (width !== measuredWidth) {
2285           scaledX +=
2286             (((width - measuredWidth) / 2000) * fontSize) / fontSizeScale;
2287         }
2288       }
2289 
2290       // Only attempt to draw the glyph if it is actually in the embedded font
2291       // file or if there isn't a font file so the fallback font is shown.
2292       if (this.contentVisible && (glyph.isInFont || font.missingFile)) {
2293         if (simpleFillText && !accent) {
2294           // common case
2295           ctx.fillText(character, scaledX, scaledY);
2296         } else {
2297           this.paintChar(
2298             character,
2299             scaledX,
2300             scaledY,
2301             patternFillTransform,
2302             patternStrokeTransform
2303           );
2304           if (accent) {
2305             const scaledAccentX =
2306               scaledX + (fontSize * accent.offset.x) / fontSizeScale;
2307             const scaledAccentY =
2308               scaledY - (fontSize * accent.offset.y) / fontSizeScale;
2309             this.paintChar(
2310               accent.fontChar,
2311               scaledAccentX,
2312               scaledAccentY,
2313               patternFillTransform,
2314               patternStrokeTransform
2315             );
2316           }
2317         }
2318       }
2319 
2320       const charWidth = vertical
2321         ? width * widthAdvanceScale - spacing * fontDirection
2322         : width * widthAdvanceScale + spacing * fontDirection;
2323       x += charWidth;
2324 
2325       if (restoreNeeded) {
2326         ctx.restore();
2327       }
2328     }
2329     if (vertical) {
2330       current.y -= x;
2331     } else {
2332       current.x += x * textHScale;
2333     }
2334     ctx.restore();
2335     this.compose();
2336 
2337     return undefined;
2338   }
2339 
2340   showType3Text(glyphs) {
2341     // Type3 fonts - each glyph is a "mini-PDF"
2342     const ctx = this.ctx;
2343     const current = this.current;
2344     const font = current.font;
2345     const fontSize = current.fontSize;
2346     const fontDirection = current.fontDirection;
2347     const spacingDir = font.vertical ? 1 : -1;
2348     const charSpacing = current.charSpacing;
2349     const wordSpacing = current.wordSpacing;
2350     const textHScale = current.textHScale * fontDirection;
2351     const fontMatrix = current.fontMatrix || FONT_IDENTITY_MATRIX;
2352     const glyphsLength = glyphs.length;
2353     const isTextInvisible =
2354       current.textRenderingMode === TextRenderingMode.INVISIBLE;
2355     let i, glyph, width, spacingLength;
2356 
2357     if (isTextInvisible || fontSize === 0) {
2358       return;
2359     }
2360     this._cachedScaleForStroking[0] = -1;
2361     this._cachedGetSinglePixelWidth = null;
2362 
2363     ctx.save();
2364     ctx.transform(...current.textMatrix);
2365     ctx.translate(current.x, current.y);
2366 
2367     ctx.scale(textHScale, fontDirection);
2368 
2369     for (i = 0; i < glyphsLength; ++i) {
2370       glyph = glyphs[i];
2371       if (typeof glyph === "number") {
2372         spacingLength = (spacingDir * glyph * fontSize) / 1000;
2373         this.ctx.translate(spacingLength, 0);
2374         current.x += spacingLength * textHScale;
2375         continue;
2376       }
2377 
2378       const spacing = (glyph.isSpace ? wordSpacing : 0) + charSpacing;
2379       const operatorList = font.charProcOperatorList[glyph.operatorListId];
2380       if (!operatorList) {
2381         warn(`Type3 character "${glyph.operatorListId}" is not available.`);
2382         continue;
2383       }
2384       if (this.contentVisible) {
2385         this.processingType3 = glyph;
2386         this.save();
2387         ctx.scale(fontSize, fontSize);
2388         ctx.transform(...fontMatrix);
2389         this.executeOperatorList(operatorList);
2390         this.restore();
2391       }
2392 
2393       const transformed = Util.applyTransform([glyph.width, 0], fontMatrix);
2394       width = transformed[0] * fontSize + spacing;
2395 
2396       ctx.translate(width, 0);
2397       current.x += width * textHScale;
2398     }
2399     ctx.restore();
2400     this.processingType3 = null;
2401   }
2402 
2403   // Type3 fonts
2404   setCharWidth(xWidth, yWidth) {
2405     // We can safely ignore this since the width should be the same
2406     // as the width in the Widths array.
2407   }
2408 
2409   setCharWidthAndBounds(xWidth, yWidth, llx, lly, urx, ury) {
2410     this.ctx.rect(llx, lly, urx - llx, ury - lly);
2411     this.ctx.clip();
2412     this.endPath();
2413   }
2414 
2415   // Color
2416   getColorN_Pattern(IR) {
2417     let pattern;
2418     if (IR[0] === "TilingPattern") {
2419       const color = IR[1];
2420       const baseTransform = this.baseTransform || getCurrentTransform(this.ctx);
2421       const canvasGraphicsFactory = {
2422         createCanvasGraphics: ctx =>
2423           new CanvasGraphics(
2424             ctx,
2425             this.commonObjs,
2426             this.objs,
2427             this.canvasFactory,
2428             this.filterFactory,
2429             {
2430               optionalContentConfig: this.optionalContentConfig,
2431               markedContentStack: this.markedContentStack,
2432             }
2433           ),
2434       };
2435       pattern = new TilingPattern(
2436         IR,
2437         color,
2438         this.ctx,
2439         canvasGraphicsFactory,
2440         baseTransform
2441       );
2442     } else {
2443       pattern = this._getPattern(IR[1], IR[2]);
2444     }
2445     return pattern;
2446   }
2447 
2448   setStrokeColorN() {
2449     this.current.strokeColor = this.getColorN_Pattern(arguments);
2450     this.current.patternStroke = true;
2451   }
2452 
2453   setFillColorN() {
2454     this.current.fillColor = this.getColorN_Pattern(arguments);
2455     this.current.patternFill = true;
2456   }
2457 
2458   setStrokeRGBColor(r, g, b) {
2459     this.ctx.strokeStyle = this.current.strokeColor = Util.makeHexColor(
2460       r,
2461       g,
2462       b
2463     );
2464     this.current.patternStroke = false;
2465   }
2466 
2467   setStrokeTransparent() {
2468     this.ctx.strokeStyle = this.current.strokeColor = "transparent";
2469     this.current.patternStroke = false;
2470   }
2471 
2472   setFillRGBColor(r, g, b) {
2473     this.ctx.fillStyle = this.current.fillColor = Util.makeHexColor(r, g, b);
2474     this.current.patternFill = false;
2475   }
2476 
2477   setFillTransparent() {
2478     this.ctx.fillStyle = this.current.fillColor = "transparent";
2479     this.current.patternFill = false;
2480   }
2481 
2482   _getPattern(objId, matrix = null) {
2483     let pattern;
2484     if (this.cachedPatterns.has(objId)) {
2485       pattern = this.cachedPatterns.get(objId);
2486     } else {
2487       pattern = getShadingPattern(this.getObject(objId));
2488       this.cachedPatterns.set(objId, pattern);
2489     }
2490     if (matrix) {
2491       pattern.matrix = matrix;
2492     }
2493     return pattern;
2494   }
2495 
2496   shadingFill(objId) {
2497     if (!this.contentVisible) {
2498       return;
2499     }
2500     const ctx = this.ctx;
2501 
2502     this.save();
2503     const pattern = this._getPattern(objId);
2504     ctx.fillStyle = pattern.getPattern(
2505       ctx,
2506       this,
2507       getCurrentTransformInverse(ctx),
2508       PathType.SHADING
2509     );
2510 
2511     const inv = getCurrentTransformInverse(ctx);
2512     if (inv) {
2513       const { width, height } = ctx.canvas;
2514       const [x0, y0, x1, y1] = Util.getAxialAlignedBoundingBox(
2515         [0, 0, width, height],
2516         inv
2517       );
2518 
2519       this.ctx.fillRect(x0, y0, x1 - x0, y1 - y0);
2520     } else {
2521       // HACK to draw the gradient onto an infinite rectangle.
2522       // PDF gradients are drawn across the entire image while
2523       // Canvas only allows gradients to be drawn in a rectangle
2524       // The following bug should allow us to remove this.
2525       // https://bugzilla.mozilla.org/show_bug.cgi?id=664884
2526 
2527       this.ctx.fillRect(-1e10, -1e10, 2e10, 2e10);
2528     }
2529 
2530     this.compose(this.current.getClippedPathBoundingBox());
2531     this.restore();
2532   }
2533 
2534   // Images
2535   beginInlineImage() {
2536     unreachable("Should not call beginInlineImage");
2537   }
2538 
2539   beginImageData() {
2540     unreachable("Should not call beginImageData");
2541   }
2542 
2543   paintFormXObjectBegin(matrix, bbox) {
2544     if (!this.contentVisible) {
2545       return;
2546     }
2547     this.save();
2548     this.baseTransformStack.push(this.baseTransform);
2549 
2550     if (matrix) {
2551       this.transform(...matrix);
2552     }
2553     this.baseTransform = getCurrentTransform(this.ctx);
2554 
2555     if (bbox) {
2556       const width = bbox[2] - bbox[0];
2557       const height = bbox[3] - bbox[1];
2558       this.ctx.rect(bbox[0], bbox[1], width, height);
2559       this.current.updateRectMinMax(getCurrentTransform(this.ctx), bbox);
2560       this.clip();
2561       this.endPath();
2562     }
2563   }
2564 
2565   paintFormXObjectEnd() {
2566     if (!this.contentVisible) {
2567       return;
2568     }
2569     this.restore();
2570     this.baseTransform = this.baseTransformStack.pop();
2571   }
2572 
2573   beginGroup(group) {
2574     if (!this.contentVisible) {
2575       return;
2576     }
2577 
2578     this.save();
2579     // If there's an active soft mask we don't want it enabled for the group, so
2580     // clear it out. The mask and suspended canvas will be restored in endGroup.
2581     if (this.inSMaskMode) {
2582       this.endSMaskMode();
2583       this.current.activeSMask = null;
2584     }
2585 
2586     const currentCtx = this.ctx;
2587     // TODO non-isolated groups - according to Rik at adobe non-isolated
2588     // group results aren't usually that different and they even have tools
2589     // that ignore this setting. Notes from Rik on implementing:
2590     // - When you encounter an transparency group, create a new canvas with
2591     // the dimensions of the bbox
2592     // - copy the content from the previous canvas to the new canvas
2593     // - draw as usual
2594     // - remove the backdrop alpha:
2595     // alphaNew = 1 - (1 - alpha)/(1 - alphaBackdrop) with 'alpha' the alpha
2596     // value of your transparency group and 'alphaBackdrop' the alpha of the
2597     // backdrop
2598     // - remove background color:
2599     // colorNew = color - alphaNew *colorBackdrop /(1 - alphaNew)
2600     if (!group.isolated) {
2601       info("TODO: Support non-isolated groups.");
2602     }
2603 
2604     // TODO knockout - supposedly possible with the clever use of compositing
2605     // modes.
2606     if (group.knockout) {
2607       warn("Knockout groups not supported.");
2608     }
2609 
2610     const currentTransform = getCurrentTransform(currentCtx);
2611     if (group.matrix) {
2612       currentCtx.transform(...group.matrix);
2613     }
2614     if (!group.bbox) {
2615       throw new Error("Bounding box is required.");
2616     }
2617 
2618     // Based on the current transform figure out how big the bounding box
2619     // will actually be.
2620     let bounds = Util.getAxialAlignedBoundingBox(
2621       group.bbox,
2622       getCurrentTransform(currentCtx)
2623     );
2624     // Clip the bounding box to the current canvas.
2625     const canvasBounds = [
2626       0,
2627       0,
2628       currentCtx.canvas.width,
2629       currentCtx.canvas.height,
2630     ];
2631     bounds = Util.intersect(bounds, canvasBounds) || [0, 0, 0, 0];
2632     // Use ceil in case we're between sizes so we don't create canvas that is
2633     // too small and make the canvas at least 1x1 pixels.
2634     const offsetX = Math.floor(bounds[0]);
2635     const offsetY = Math.floor(bounds[1]);
2636     const drawnWidth = Math.max(Math.ceil(bounds[2]) - offsetX, 1);
2637     const drawnHeight = Math.max(Math.ceil(bounds[3]) - offsetY, 1);
2638 
2639     this.current.startNewPathAndClipBox([0, 0, drawnWidth, drawnHeight]);
2640 
2641     let cacheId = "groupAt" + this.groupLevel;
2642     if (group.smask) {
2643       // Using two cache entries is case if masks are used one after another.
2644       cacheId += "_smask_" + (this.smaskCounter++ % 2);
2645     }
2646     const scratchCanvas = this.cachedCanvases.getCanvas(
2647       cacheId,
2648       drawnWidth,
2649       drawnHeight
2650     );
2651     const groupCtx = scratchCanvas.context;
2652 
2653     // Since we created a new canvas that is just the size of the bounding box
2654     // we have to translate the group ctx.
2655     groupCtx.translate(-offsetX, -offsetY);
2656     groupCtx.transform(...currentTransform);
2657 
2658     if (group.smask) {
2659       // Saving state and cached mask to be used in setGState.
2660       this.smaskStack.push({
2661         canvas: scratchCanvas.canvas,
2662         context: groupCtx,
2663         offsetX,
2664         offsetY,
2665         subtype: group.smask.subtype,
2666         backdrop: group.smask.backdrop,
2667         transferMap: group.smask.transferMap || null,
2668         startTransformInverse: null, // used during suspend operation
2669       });
2670     } else {
2671       // Setup the current ctx so when the group is popped we draw it at the
2672       // right location.
2673       currentCtx.setTransform(1, 0, 0, 1, 0, 0);
2674       currentCtx.translate(offsetX, offsetY);
2675       currentCtx.save();
2676     }
2677     // The transparency group inherits all off the current graphics state
2678     // except the blend mode, soft mask, and alpha constants.
2679     copyCtxState(currentCtx, groupCtx);
2680     this.ctx = groupCtx;
2681     this.setGState([
2682       ["BM", "source-over"],
2683       ["ca", 1],
2684       ["CA", 1],
2685     ]);
2686     this.groupStack.push(currentCtx);
2687     this.groupLevel++;
2688   }
2689 
2690   endGroup(group) {
2691     if (!this.contentVisible) {
2692       return;
2693     }
2694     this.groupLevel--;
2695     const groupCtx = this.ctx;
2696     const ctx = this.groupStack.pop();
2697     this.ctx = ctx;
2698     // Turn off image smoothing to avoid sub pixel interpolation which can
2699     // look kind of blurry for some pdfs.
2700     this.ctx.imageSmoothingEnabled = false;
2701 
2702     if (group.smask) {
2703       this.tempSMask = this.smaskStack.pop();
2704       this.restore();
2705     } else {
2706       this.ctx.restore();
2707       const currentMtx = getCurrentTransform(this.ctx);
2708       this.restore();
2709       this.ctx.save();
2710       this.ctx.setTransform(...currentMtx);
2711       const dirtyBox = Util.getAxialAlignedBoundingBox(
2712         [0, 0, groupCtx.canvas.width, groupCtx.canvas.height],
2713         currentMtx
2714       );
2715       this.ctx.drawImage(groupCtx.canvas, 0, 0);
2716       this.ctx.restore();
2717       this.compose(dirtyBox);
2718     }
2719   }
2720 
2721   beginAnnotation(id, rect, transform, matrix, hasOwnCanvas) {
2722     // The annotations are drawn just after the page content.
2723     // The page content drawing can potentially have set a transform,
2724     // a clipping path, whatever...
2725     // So in order to have something clean, we restore the initial state.
2726     this.#restoreInitialState();
2727     resetCtxToDefault(this.ctx);
2728 
2729     this.ctx.save();
2730     this.save();
2731 
2732     if (this.baseTransform) {
2733       this.ctx.setTransform(...this.baseTransform);
2734     }
2735 
2736     if (rect) {
2737       const width = rect[2] - rect[0];
2738       const height = rect[3] - rect[1];
2739 
2740       if (hasOwnCanvas && this.annotationCanvasMap) {
2741         transform = transform.slice();
2742         transform[4] -= rect[0];
2743         transform[5] -= rect[1];
2744 
2745         rect = rect.slice();
2746         rect[0] = rect[1] = 0;
2747         rect[2] = width;
2748         rect[3] = height;
2749 
2750         const [scaleX, scaleY] = Util.singularValueDecompose2dScale(
2751           getCurrentTransform(this.ctx)
2752         );
2753         const { viewportScale } = this;
2754         const canvasWidth = Math.ceil(
2755           width * this.outputScaleX * viewportScale
2756         );
2757         const canvasHeight = Math.ceil(
2758           height * this.outputScaleY * viewportScale
2759         );
2760 
2761         this.annotationCanvas = this.canvasFactory.create(
2762           canvasWidth,
2763           canvasHeight
2764         );
2765         const { canvas, context } = this.annotationCanvas;
2766         this.annotationCanvasMap.set(id, canvas);
2767         this.annotationCanvas.savedCtx = this.ctx;
2768         this.ctx = context;
2769         this.ctx.save();
2770         this.ctx.setTransform(scaleX, 0, 0, -scaleY, 0, height * scaleY);
2771 
2772         resetCtxToDefault(this.ctx);
2773       } else {
2774         resetCtxToDefault(this.ctx);
2775 
2776         // Consume a potential path before clipping.
2777         this.endPath();
2778 
2779         this.ctx.rect(rect[0], rect[1], width, height);
2780         this.ctx.clip();
2781         this.ctx.beginPath();
2782       }
2783     }
2784 
2785     this.current = new CanvasExtraState(
2786       this.ctx.canvas.width,
2787       this.ctx.canvas.height
2788     );
2789 
2790     this.transform(...transform);
2791     this.transform(...matrix);
2792   }
2793 
2794   endAnnotation() {
2795     if (this.annotationCanvas) {
2796       this.ctx.restore();
2797       this.#drawFilter();
2798 
2799       this.ctx = this.annotationCanvas.savedCtx;
2800       delete this.annotationCanvas.savedCtx;
2801       delete this.annotationCanvas;
2802     }
2803   }
2804 
2805   paintImageMaskXObject(img) {
2806     if (!this.contentVisible) {
2807       return;
2808     }
2809     const count = img.count;
2810     img = this.getObject(img.data, img);
2811     img.count = count;
2812 
2813     const ctx = this.ctx;
2814     const glyph = this.processingType3;
2815 
2816     if (glyph) {
2817       if (glyph.compiled === undefined) {
2818         glyph.compiled = compileType3Glyph(img);
2819       }
2820 
2821       if (glyph.compiled) {
2822         glyph.compiled(ctx);
2823         return;
2824       }
2825     }
2826     const mask = this._createMaskCanvas(img);
2827     const maskCanvas = mask.canvas;
2828 
2829     ctx.save();
2830     // The mask is drawn with the transform applied. Reset the current
2831     // transform to draw to the identity.
2832     ctx.setTransform(1, 0, 0, 1, 0, 0);
2833     ctx.drawImage(maskCanvas, mask.offsetX, mask.offsetY);
2834     ctx.restore();
2835     this.compose();
2836   }
2837 
2838   paintImageMaskXObjectRepeat(
2839     img,
2840     scaleX,
2841     skewX = 0,
2842     skewY = 0,
2843     scaleY,
2844     positions
2845   ) {
2846     if (!this.contentVisible) {
2847       return;
2848     }
2849 
2850     img = this.getObject(img.data, img);
2851 
2852     const ctx = this.ctx;
2853     ctx.save();
2854     const currentTransform = getCurrentTransform(ctx);
2855     ctx.transform(scaleX, skewX, skewY, scaleY, 0, 0);
2856     const mask = this._createMaskCanvas(img);
2857 
2858     ctx.setTransform(
2859       1,
2860       0,
2861       0,
2862       1,
2863       mask.offsetX - currentTransform[4],
2864       mask.offsetY - currentTransform[5]
2865     );
2866     for (let i = 0, ii = positions.length; i < ii; i += 2) {
2867       const trans = Util.transform(currentTransform, [
2868         scaleX,
2869         skewX,
2870         skewY,
2871         scaleY,
2872         positions[i],
2873         positions[i + 1],
2874       ]);
2875 
2876       const [x, y] = Util.applyTransform([0, 0], trans);
2877       ctx.drawImage(mask.canvas, x, y);
2878     }
2879     ctx.restore();
2880     this.compose();
2881   }
2882 
2883   paintImageMaskXObjectGroup(images) {
2884     if (!this.contentVisible) {
2885       return;
2886     }
2887     const ctx = this.ctx;
2888 
2889     const fillColor = this.current.fillColor;
2890     const isPatternFill = this.current.patternFill;
2891 
2892     for (const image of images) {
2893       const { data, width, height, transform } = image;
2894 
2895       const maskCanvas = this.cachedCanvases.getCanvas(
2896         "maskCanvas",
2897         width,
2898         height
2899       );
2900       const maskCtx = maskCanvas.context;
2901       maskCtx.save();
2902 
2903       const img = this.getObject(data, image);
2904       putBinaryImageMask(maskCtx, img);
2905 
2906       maskCtx.globalCompositeOperation = "source-in";
2907 
2908       maskCtx.fillStyle = isPatternFill
2909         ? fillColor.getPattern(
2910             maskCtx,
2911             this,
2912             getCurrentTransformInverse(ctx),
2913             PathType.FILL
2914           )
2915         : fillColor;
2916       maskCtx.fillRect(0, 0, width, height);
2917 
2918       maskCtx.restore();
2919 
2920       ctx.save();
2921       ctx.transform(...transform);
2922       ctx.scale(1, -1);
2923       drawImageAtIntegerCoords(
2924         ctx,
2925         maskCanvas.canvas,
2926         0,
2927         0,
2928         width,
2929         height,
2930         0,
2931         -1,
2932         1,
2933         1
2934       );
2935       ctx.restore();
2936     }
2937     this.compose();
2938   }
2939 
2940   paintImageXObject(objId) {
2941     if (!this.contentVisible) {
2942       return;
2943     }
2944     const imgData = this.getObject(objId);
2945     if (!imgData) {
2946       warn("Dependent image isn't ready yet");
2947       return;
2948     }
2949 
2950     this.paintInlineImageXObject(imgData);
2951   }
2952 
2953   paintImageXObjectRepeat(objId, scaleX, scaleY, positions) {
2954     if (!this.contentVisible) {
2955       return;
2956     }
2957     const imgData = this.getObject(objId);
2958     if (!imgData) {
2959       warn("Dependent image isn't ready yet");
2960       return;
2961     }
2962 
2963     const width = imgData.width;
2964     const height = imgData.height;
2965     const map = [];
2966     for (let i = 0, ii = positions.length; i < ii; i += 2) {
2967       map.push({
2968         transform: [scaleX, 0, 0, scaleY, positions[i], positions[i + 1]],
2969         x: 0,
2970         y: 0,
2971         w: width,
2972         h: height,
2973       });
2974     }
2975     this.paintInlineImageXObjectGroup(imgData, map);
2976   }
2977 
2978   applyTransferMapsToCanvas(ctx) {
2979     if (this.current.transferMaps !== "none") {
2980       ctx.filter = this.current.transferMaps;
2981       ctx.drawImage(ctx.canvas, 0, 0);
2982       ctx.filter = "none";
2983     }
2984     return ctx.canvas;
2985   }
2986 
2987   applyTransferMapsToBitmap(imgData) {
2988     if (this.current.transferMaps === "none") {
2989       return imgData.bitmap;
2990     }
2991     const { bitmap, width, height } = imgData;
2992     const tmpCanvas = this.cachedCanvases.getCanvas(
2993       "inlineImage",
2994       width,
2995       height
2996     );
2997     const tmpCtx = tmpCanvas.context;
2998     tmpCtx.filter = this.current.transferMaps;
2999     tmpCtx.drawImage(bitmap, 0, 0);
3000     tmpCtx.filter = "none";
3001 
3002     return tmpCanvas.canvas;
3003   }
3004 
3005   paintInlineImageXObject(imgData) {
3006     if (!this.contentVisible) {
3007       return;
3008     }
3009     const width = imgData.width;
3010     const height = imgData.height;
3011     const ctx = this.ctx;
3012 
3013     this.save();
3014 
3015     if (
3016       (typeof PDFJSDev !== "undefined" && PDFJSDev.test("MOZCENTRAL")) ||
3017       !isNodeJS
3018     ) {
3019       // The filter, if any, will be applied in applyTransferMapsToBitmap.
3020       // It must be applied to the image before rescaling else some artifacts
3021       // could appear.
3022       // The final restore will reset it to its value.
3023       const { filter } = ctx;
3024       if (filter !== "none" && filter !== "") {
3025         ctx.filter = "none";
3026       }
3027     }
3028 
3029     // scale the image to the unit square
3030     ctx.scale(1 / width, -1 / height);
3031 
3032     let imgToPaint;
3033     if (imgData.bitmap) {
3034       imgToPaint = this.applyTransferMapsToBitmap(imgData);
3035     } else if (
3036       (typeof HTMLElement === "function" && imgData instanceof HTMLElement) ||
3037       !imgData.data
3038     ) {
3039       // typeof check is needed due to node.js support, see issue #8489
3040       imgToPaint = imgData;
3041     } else {
3042       const tmpCanvas = this.cachedCanvases.getCanvas(
3043         "inlineImage",
3044         width,
3045         height
3046       );
3047       const tmpCtx = tmpCanvas.context;
3048       putBinaryImageData(tmpCtx, imgData);
3049       imgToPaint = this.applyTransferMapsToCanvas(tmpCtx);
3050     }
3051 
3052     const scaled = this._scaleImage(
3053       imgToPaint,
3054       getCurrentTransformInverse(ctx)
3055     );
3056     ctx.imageSmoothingEnabled = getImageSmoothingEnabled(
3057       getCurrentTransform(ctx),
3058       imgData.interpolate
3059     );
3060 
3061     drawImageAtIntegerCoords(
3062       ctx,
3063       scaled.img,
3064       0,
3065       0,
3066       scaled.paintWidth,
3067       scaled.paintHeight,
3068       0,
3069       -height,
3070       width,
3071       height
3072     );
3073     this.compose();
3074     this.restore();
3075   }
3076 
3077   paintInlineImageXObjectGroup(imgData, map) {
3078     if (!this.contentVisible) {
3079       return;
3080     }
3081     const ctx = this.ctx;
3082     let imgToPaint;
3083     if (imgData.bitmap) {
3084       imgToPaint = imgData.bitmap;
3085     } else {
3086       const w = imgData.width;
3087       const h = imgData.height;
3088 
3089       const tmpCanvas = this.cachedCanvases.getCanvas("inlineImage", w, h);
3090       const tmpCtx = tmpCanvas.context;
3091       putBinaryImageData(tmpCtx, imgData);
3092       imgToPaint = this.applyTransferMapsToCanvas(tmpCtx);
3093     }
3094 
3095     for (const entry of map) {
3096       ctx.save();
3097       ctx.transform(...entry.transform);
3098       ctx.scale(1, -1);
3099       drawImageAtIntegerCoords(
3100         ctx,
3101         imgToPaint,
3102         entry.x,
3103         entry.y,
3104         entry.w,
3105         entry.h,
3106         0,
3107         -1,
3108         1,
3109         1
3110       );
3111       ctx.restore();
3112     }
3113     this.compose();
3114   }
3115 
3116   paintSolidColorImageMask() {
3117     if (!this.contentVisible) {
3118       return;
3119     }
3120     this.ctx.fillRect(0, 0, 1, 1);
3121     this.compose();
3122   }
3123 
3124   // Marked content
3125 
3126   markPoint(tag) {
3127     // TODO Marked content.
3128   }
3129 
3130   markPointProps(tag, properties) {
3131     // TODO Marked content.
3132   }
3133 
3134   beginMarkedContent(tag) {
3135     this.markedContentStack.push({
3136       visible: true,
3137     });
3138   }
3139 
3140   beginMarkedContentProps(tag, properties) {
3141     if (tag === "OC") {
3142       this.markedContentStack.push({
3143         visible: this.optionalContentConfig.isVisible(properties),
3144       });
3145     } else {
3146       this.markedContentStack.push({
3147         visible: true,
3148       });
3149     }
3150     this.contentVisible = this.isContentVisible();
3151   }
3152 
3153   endMarkedContent() {
3154     this.markedContentStack.pop();
3155     this.contentVisible = this.isContentVisible();
3156   }
3157 
3158   // Compatibility
3159 
3160   beginCompat() {
3161     // TODO ignore undefined operators (should we do that anyway?)
3162   }
3163 
3164   endCompat() {
3165     // TODO stop ignoring undefined operators
3166   }
3167 
3168   // Helper functions
3169 
3170   consumePath(clipBox) {
3171     const isEmpty = this.current.isEmptyClip();
3172     if (this.pendingClip) {
3173       this.current.updateClipFromPath();
3174     }
3175     if (!this.pendingClip) {
3176       this.compose(clipBox);
3177     }
3178     const ctx = this.ctx;
3179     if (this.pendingClip) {
3180       if (!isEmpty) {
3181         if (this.pendingClip === EO_CLIP) {
3182           ctx.clip("evenodd");
3183         } else {
3184           ctx.clip();
3185         }
3186       }
3187       this.pendingClip = null;
3188     }
3189     this.current.startNewPathAndClipBox(this.current.clipBox);
3190     ctx.beginPath();
3191   }
3192 
3193   getSinglePixelWidth() {
3194     if (!this._cachedGetSinglePixelWidth) {
3195       const m = getCurrentTransform(this.ctx);
3196       if (m[1] === 0 && m[2] === 0) {
3197         // Fast path
3198         this._cachedGetSinglePixelWidth =
3199           1 / Math.min(Math.abs(m[0]), Math.abs(m[3]));
3200       } else {
3201         const absDet = Math.abs(m[0] * m[3] - m[2] * m[1]);
3202         const normX = Math.hypot(m[0], m[2]);
3203         const normY = Math.hypot(m[1], m[3]);
3204         this._cachedGetSinglePixelWidth = Math.max(normX, normY) / absDet;
3205       }
3206     }
3207     return this._cachedGetSinglePixelWidth;
3208   }
3209 
3210   getScaleForStroking() {
3211     // A pixel has thicknessX = thicknessY = 1;
3212     // A transformed pixel is a parallelogram and the thicknesses
3213     // corresponds to the heights.
3214     // The goal of this function is to rescale before setting the
3215     // lineWidth in order to have both thicknesses greater or equal
3216     // to 1 after transform.
3217     if (this._cachedScaleForStroking[0] === -1) {
3218       const { lineWidth } = this.current;
3219       const { a, b, c, d } = this.ctx.getTransform();
3220       let scaleX, scaleY;
3221 
3222       if (b === 0 && c === 0) {
3223         // Fast path
3224         const normX = Math.abs(a);
3225         const normY = Math.abs(d);
3226         if (normX === normY) {
3227           if (lineWidth === 0) {
3228             scaleX = scaleY = 1 / normX;
3229           } else {
3230             const scaledLineWidth = normX * lineWidth;
3231             scaleX = scaleY = scaledLineWidth < 1 ? 1 / scaledLineWidth : 1;
3232           }
3233         } else if (lineWidth === 0) {
3234           scaleX = 1 / normX;
3235           scaleY = 1 / normY;
3236         } else {
3237           const scaledXLineWidth = normX * lineWidth;
3238           const scaledYLineWidth = normY * lineWidth;
3239           scaleX = scaledXLineWidth < 1 ? 1 / scaledXLineWidth : 1;
3240           scaleY = scaledYLineWidth < 1 ? 1 / scaledYLineWidth : 1;
3241         }
3242       } else {
3243         // A pixel (base (x, y)) is transformed by M into a parallelogram:
3244         //  - its area is |det(M)|;
3245         //  - heightY (orthogonal to Mx) has a length: |det(M)| / norm(Mx);
3246         //  - heightX (orthogonal to My) has a length: |det(M)| / norm(My).
3247         // heightX and heightY are the thicknesses of the transformed pixel
3248         // and they must be both greater or equal to 1.
3249         const absDet = Math.abs(a * d - b * c);
3250         const normX = Math.hypot(a, b);
3251         const normY = Math.hypot(c, d);
3252         if (lineWidth === 0) {
3253           scaleX = normY / absDet;
3254           scaleY = normX / absDet;
3255         } else {
3256           const baseArea = lineWidth * absDet;
3257           scaleX = normY > baseArea ? normY / baseArea : 1;
3258           scaleY = normX > baseArea ? normX / baseArea : 1;
3259         }
3260       }
3261       this._cachedScaleForStroking[0] = scaleX;
3262       this._cachedScaleForStroking[1] = scaleY;
3263     }
3264     return this._cachedScaleForStroking;
3265   }
3266 
3267   // Rescale before stroking in order to have a final lineWidth
3268   // with both thicknesses greater or equal to 1.
3269   rescaleAndStroke(saveRestore) {
3270     const { ctx } = this;
3271     const { lineWidth } = this.current;
3272     const [scaleX, scaleY] = this.getScaleForStroking();
3273 
3274     ctx.lineWidth = lineWidth || 1;
3275 
3276     if (scaleX === 1 && scaleY === 1) {
3277       ctx.stroke();
3278       return;
3279     }
3280 
3281     const dashes = ctx.getLineDash();
3282     if (saveRestore) {
3283       ctx.save();
3284     }
3285 
3286     ctx.scale(scaleX, scaleY);
3287 
3288     // How the dashed line is rendered depends on the current transform...
3289     // so we added a rescale to handle too thin lines and consequently
3290     // the way the line is dashed will be modified.
3291     // If scaleX === scaleY, the dashed lines will be rendered correctly
3292     // else we'll have some bugs (but only with too thin lines).
3293     // Here we take the max... why not taking the min... or something else.
3294     // Anyway, as said it's buggy when scaleX !== scaleY.
3295     if (dashes.length > 0) {
3296       const scale = Math.max(scaleX, scaleY);
3297       ctx.setLineDash(dashes.map(x => x / scale));
3298       ctx.lineDashOffset /= scale;
3299     }
3300 
3301     ctx.stroke();
3302 
3303     if (saveRestore) {
3304       ctx.restore();
3305     }
3306   }
3307 
3308   isContentVisible() {
3309     for (let i = this.markedContentStack.length - 1; i >= 0; i--) {
3310       if (!this.markedContentStack[i].visible) {
3311         return false;
3312       }
3313     }
3314     return true;
3315   }
3316 }
3317 
3318 for (const op in OPS) {
3319   if (CanvasGraphics.prototype[op] !== undefined) {
3320     CanvasGraphics.prototype[OPS[op]] = CanvasGraphics.prototype[op];
3321   }
3322 }
3323 
3324 export { CanvasGraphics };
</code>

Test file:
<test_file>
File:
test/unit/api_spec.js
/* Copyright 2017 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import {
  AnnotationEditorType,
  AnnotationMode,
  AnnotationType,
  ImageKind,
  InvalidPDFException,
  isNodeJS,
  objectSize,
  OPS,
  PasswordException,
  PasswordResponses,
  PermissionFlag,
  ResponseException,
  UnknownErrorException,
} from "../../src/shared/util.js";
import {
  buildGetDocumentParams,
  CMAP_URL,
  DefaultFileReaderFactory,
  getCrossOriginHostname,
  TEST_PDFS_PATH,
  TestPdfsServer,
} from "./test_utils.js";
import {
  fetchData as fetchDataDOM,
  PageViewport,
  RenderingCancelledException,
  StatTimer,
} from "../../src/display/display_utils.js";
import {
  getDocument,
  PDFDataRangeTransport,
  PDFDocumentLoadingTask,
  PDFDocumentProxy,
  PDFPageProxy,
  PDFWorker,
  RenderTask,
} from "../../src/display/api.js";
import { AutoPrintRegExp } from "../../web/ui_utils.js";
import { GlobalImageCache } from "../../src/core/image_utils.js";
import { GlobalWorkerOptions } from "../../src/display/worker_options.js";
import { Metadata } from "../../src/display/metadata.js";
const WORKER_SRC = "../../build/generic/build/pdf.worker.mjs";
</test_file>

Your task:
You are a software tester at pdf.js.
1. Examine the existing test file. You may reuse any imports, helpers or setup blocks it already has.
2. Write exactly one javascript test `it("...", async () => {...})` block.
3. Your test must fail on the code before the patch, and pass after, hence the test will verify that the patch resolves the issue.
4. The test must be self-contained and to-the-point.
5. If you need something new use only the provided imports (respect the paths exactly how they are given) by importing dynamically for compatibility with Node.js — no new dependencies. 
6. Return only the javascript code for the new `it(...)` block (no comments or explanations).

Example structure:
it("should <describe behavior>", async () => {
  const { example } = await import("../../src/core/example.js");
  <initialize required variables>;
  <define expected variable>;
  <generate actual variables>;
  <compare expected with actual>;
});

