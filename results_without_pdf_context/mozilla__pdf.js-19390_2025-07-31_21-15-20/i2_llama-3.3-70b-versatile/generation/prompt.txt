Before you begin:
- Keep going until the job is completely solved — don’t stop halfway.
- If you’re unsure about the behavior, reread the provided patch carefully; do not hallucinate.
- Plan your approach before writing code by reflecting on whether the test truly fails before and passes after.

Issue:
<issue>
[Bug]: Password fields render as regular text fields
### Attach (recommended) or Link to PDF file

[password-bug.pdf](https://github.com/user-attachments/files/18586315/password-bug.pdf)

### Web browser and its version

Firefox 134.0.2 (64-bit)

### Operating system and its version

Windows 10 Pro 22H2 19045.5247

### PDF.js version

Whatever version is currently in the online demo

### Is the bug present in the latest PDF.js version?

Yes

### Is a browser extension

No

### Steps to reproduce the problem

1. Have a PDF that includes a password field.
2. Open it in Firefox, the online demo, or using the Chrome PDF Viewer extension.
https://chromewebstore.google.com/detail/pdf-viewer/oemmndcbldboiebfnladdacbdfmadadm
3. The PDF renders the password field as if it were a normal text field.
![Image](https://github.com/user-attachments/assets/35811a62-6752-49f3-8763-309db033963b)

Also, when interrogating the PDF with pdfjs-dist v3.11.174, the field is given the type "text" rather than "password".
(I know that's an outdated version, but I just can't figure out how to make a newer version work, and it illustrates that it's likely not a rendering problem, but an underlying problem when parsing the PDF)

### What is the expected behavior?

Password fields should be rendered as such, and the characters should be obscured (with asterisks or otherwise), like what happens in the following:

Adobe Acrobat:
![Image](https://github.com/user-attachments/assets/6af70310-7c60-49dc-b2dd-daf412b72cc0)
Chrome:
![Image](https://github.com/user-attachments/assets/69311e4e-48ae-4c34-84f9-fb72da0facad)
Edge (quite probably the same renderer as Chrome):
![Image](https://github.com/user-attachments/assets/0e3dc151-5c29-44ba-9c58-c897422c6b47)

### What went wrong?

As mentioned above, the PDF renders the password field as if it were a normal text field.

### Link to a viewer

_No response_

### Additional context

Admittedly, the usefulness of a password field in a PDF is somewhat lost on me, however it is a feature that should be supported because it's a bit of a problem if a value should be obscured and you completely expose it.
Yes the value would still be visible to anyone with basic JS knowledge that inspects the viewer, but at least it wouldn't be visible to someone looking over your shoulder when you open the PDF.
</issue>

Patch:
<patch>
diff --git a/src/core/annotation.js b/src/core/annotation.js
--- a/src/core/annotation.js
+++ b/src/core/annotation.js
@@ -1888,6 +1888,7 @@ class WidgetAnnotation extends Annotation {
       data.fieldFlags = 0;
     }
 
+    data.password = this.hasFieldFlag(AnnotationFieldFlag.PASSWORD);
     data.readOnly = this.hasFieldFlag(AnnotationFieldFlag.READONLY);
     data.required = this.hasFieldFlag(AnnotationFieldFlag.REQUIRED);
     data.hidden =
@@ -2261,8 +2262,7 @@ class WidgetAnnotation extends Annotation {
   }
 
   async _getAppearance(evaluator, task, intent, annotationStorage) {
-    const isPassword = this.hasFieldFlag(AnnotationFieldFlag.PASSWORD);
-    if (isPassword) {
+    if (this.data.password) {
       return null;
     }
     const storageEntry = annotationStorage?.get(this.data.id);
@@ -2962,7 +2962,7 @@ class TextWidgetAnnotation extends WidgetAnnotation {
       value: this.data.fieldValue,
       defaultValue: this.data.defaultFieldValue || "",
       multiline: this.data.multiLine,
-      password: this.hasFieldFlag(AnnotationFieldFlag.PASSWORD),
+      password: this.data.password,
       charLimit: this.data.maxLen,
       comb: this.data.comb,
       editable: !this.data.readOnly,

diff --git a/src/display/annotation_layer.js b/src/display/annotation_layer.js
--- a/src/display/annotation_layer.js
+++ b/src/display/annotation_layer.js
@@ -1286,7 +1286,7 @@ class TextWidgetAnnotationElement extends WidgetAnnotationElement {
         }
       } else {
         element = document.createElement("input");
-        element.type = "text";
+        element.type = this.data.password ? "password" : "text";
         element.setAttribute("value", fieldFormattedValues ?? textContent);
         if (this.data.doNotScroll) {
           element.style.overflowX = "hidden";


</patch>

Imports:
<imports>
Available Packages
Dev Dependencies:
- @babel/core: ^7.26.0
- @babel/preset-env: ^7.26.0
- @babel/runtime: ^7.26.0
- @fluent/bundle: ^0.18.0
- @fluent/dom: ^0.10.0
- @metalsmith/layouts: ^2.7.0
- @metalsmith/markdown: ^1.10.0
- @napi-rs/canvas: ^0.1.65
- @types/node: ^22.10.7
- autoprefixer: ^10.4.20
- babel-loader: ^9.2.1
- caniuse-lite: ^1.0.30001692
- core-js: ^3.40.0
- eslint: ^9.18.0
- eslint-plugin-import: ^2.31.0
- eslint-plugin-jasmine: ^4.2.2
- eslint-plugin-json: ^4.0.1
- eslint-plugin-no-unsanitized: ^4.1.2
- eslint-plugin-perfectionist: ^4.6.0
- eslint-plugin-prettier: ^5.2.2
- eslint-plugin-unicorn: ^56.0.1
- globals: ^15.14.0
- gulp: ^5.0.0
- gulp-cli: ^3.0.0
- gulp-postcss: ^10.0.0
- gulp-rename: ^2.0.0
- gulp-replace: ^1.1.4
- gulp-zip: ^6.1.0
- highlight.js: ^11.11.1
- jasmine: ^5.5.0
- jsdoc: ^4.0.4
- jstransformer-nunjucks: ^1.2.0
- metalsmith: ^2.6.3
- metalsmith-html-relative: ^2.0.6
- ordered-read-streams: ^2.0.0
- pngjs: ^7.0.0
- postcss: ^8.5.1
- postcss-dark-theme-class: ^1.3.0
- postcss-dir-pseudo-class: ^9.0.1
- postcss-discard-comments: ^7.0.3
- postcss-nesting: ^13.0.1
- prettier: ^3.4.2
- puppeteer: ^24.1.0
- stylelint: ^16.13.2
- stylelint-prettier: ^5.0.2
- svglint: ^3.1.0
- terser-webpack-plugin: ^5.3.11
- tsc-alias: ^1.8.10
- ttest: ^4.0.0
- typescript: ^5.7.3
- vinyl: ^3.0.0
- webpack: ^5.97.1
- webpack-stream: ^7.0.0
- yargs: ^17.7.2

Engines:
- node: >=20

Available Relative Imports:
- `../../src/core/annotation.js`: Annotation, AnnotationBorderStyle, AnnotationFactory, MarkupAnnotation, getQuadPoints
- `../../src/core/bidi.js`: bidi
- `../../src/core/cff_parser.js`: CFFCharset, CFFCompiler, CFFFDSelect, CFFParser, CFFStrings
- `../../src/core/cmap.js`: CMap, CMapFactory, IdentityCMap
- `../../src/core/colorspace.js`: ColorSpace
- `../../src/core/core_utils.js`: arrayBuffersToBytes, encodeToXmlString, escapePDFName, escapeString, getInheritableProperty, getSizeInBytes, isAscii, isWhiteSpace, log2, numberToString, parseXFAPath, recoverJsURL, stringToUTF16HexString, stringToUTF16String, toRomanNumerals, validateCSSFont
- `../../src/core/crypto.js`: AES128Cipher, AES256Cipher, ARCFourCipher, CipherTransformFactory, PDF17, PDF20, calculateMD5, calculateSHA256, calculateSHA384, calculateSHA512
- `../../src/core/default_appearance.js`: createDefaultAppearance, parseAppearanceStream, parseDefaultAppearance
- `../../src/core/document.js`: PDFDocument, Page
- `../../src/core/encodings.js`: getEncoding
- `../../src/core/evaluator.js`: PartialEvaluator
- `../../src/core/flate_stream.js`: FlateStream
- `../../src/core/font_substitutions.js`: getFontSubstitution
- `../../src/core/fonts_utils.js`: SEAC_ANALYSIS_ENABLED
- `../../src/core/function.js`: PDFFunctionFactory, PostScriptCompiler, PostScriptEvaluator
- `../../src/core/glyphlist.js`: getDingbatsGlyphsUnicode, getGlyphsUnicode
- `../../src/core/image_utils.js`: GlobalImageCache, LocalColorSpaceCache
- `../../src/core/jbig2.js`: Jbig2Error, Jbig2Image
- `../../src/core/jpg.js`: JpegError, JpegImage
- `../../src/core/jpx.js`: JpxError, JpxImage
- `../../src/core/metadata_parser.js`: MetadataParser
- `../../src/core/operator_list.js`: OperatorList
- `../../src/core/parser.js`: Lexer, Linearization, Parser
- `../../src/core/predictor_stream.js`: PredictorStream
- `../../src/core/primitives.js`: Cmd, Dict, EOF, Name, Ref, RefSet, RefSetCache, isCmd, isDict, isName, isRefsEqual
- `../../src/core/ps_parser.js`: PostScriptLexer, PostScriptParser
- `../../src/core/stream.js`: NullStream, Stream, StringStream
- `../../src/core/type1_parser.js`: Type1Parser
- `../../src/core/unicode.js`: getCharUnicodeCategory, getUnicodeForGlyph, getUnicodeRangeFor, mapSpecialUnicodeValues
- `../../src/core/worker.js`: WorkerMessageHandler, WorkerTask
- `../../src/core/writer.js`: incrementalUpdate, writeChanges, writeDict
- `../../src/core/xfa/bind.js`: Binder
- `../../src/core/xfa/data.js`: DataHandler
- `../../src/core/xfa/factory.js`: XFAFactory
- `../../src/core/xfa/formcalc_lexer.js`: Lexer, TOKEN, Token
- `../../src/core/xfa/formcalc_parser.js`: Errors, Parser
- `../../src/core/xfa/parser.js`: XFAParser
- `../../src/core/xfa/som.js`: searchNode
- `../../src/core/xfa/symbol_utils.js`: $dump, $getChildren, $getChildrenByClass, $getChildrenByName, $text, $uid
- `../../src/core/xml_parser.js`: SimpleXMLParser, XMLParserBase
- `../../src/display/annotation_layer.js`: AnnotationLayer
- `../../src/display/annotation_storage.js`: AnnotationStorage
- `../../src/display/api.js`: LoopbackPort, PDFDataRangeTransport, PDFDocumentLoadingTask, PDFDocumentProxy, PDFPageProxy, PDFWorker, RenderTask, build, getDocument, version
- `../../src/display/canvas_factory.js`: DOMCanvasFactory
- `../../src/display/cmap_reader_factory.js`: DOMCMapReaderFactory
- `../../src/display/display_utils.js`: OutputScale, PDFDateString, PageViewport, PixelsPerInch, RenderingCancelledException, StatTimer, fetchData, getFilenameFromUrl, getPdfFilenameFromUrl, getXfaPageViewport, isDataScheme, isPdfFile, isValidFetchUrl, noContextMenu, setLayerDimensions, stopEvent
- `../../src/display/draw_layer.js`: DrawLayer
- `../../src/display/editor/annotation_editor_layer.js`: AnnotationEditorLayer
- `../../src/display/editor/color_picker.js`: ColorPicker
- `../../src/display/editor/tools.js`: AnnotationEditorUIManager, CommandManager
- `../../src/display/fetch_stream.js`: PDFFetchStream
- `../../src/display/metadata.js`: Metadata
- `../../src/display/network.js`: PDFNetworkStream
- `../../src/display/network_utils.js`: createHeaders, createResponseError, extractFilenameFromHeader, validateRangeRequestCapabilities, validateResponseStatus
- `../../src/display/node_stream.js`: PDFNodeStream
- `../../src/display/node_utils.js`: NodeCMapReaderFactory, NodeStandardFontDataFactory, fetchData
- `../../src/display/standard_fontdata_factory.js`: DOMStandardFontDataFactory
- `../../src/display/svg_factory.js`: DOMSVGFactory
- `../../src/display/text_layer.js`: TextLayer
- `../../src/display/touch_manager.js`: TouchManager
- `../../src/display/worker_options.js`: GlobalWorkerOptions
- `../../src/display/xfa_layer.js`: XfaLayer
- `../../src/shared/message_handler.js`: MessageHandler
- `../../src/shared/murmurhash3.js`: MurmurHash3_64
- `../../src/shared/util.js`: AbortException, AnnotationBorderStyleType, AnnotationEditorParamsType, AnnotationEditorType, AnnotationFieldFlag, AnnotationFlag, AnnotationMode, AnnotationType, BaseException, FeatureTest, FormatError, ImageKind, InvalidPDFException, OPS, PasswordException, PasswordResponses, PermissionFlag, RenderingIntentFlag, ResponseException, UnknownErrorException, Util, VerbosityLevel, assert, bytesToString, createValidAbsoluteUrl, getModificationDate, getUuid, getVerbosityLevel, isNodeJS, normalizeUnicode, objectSize, setVerbosityLevel, shadow, string32, stringToBytes, stringToPDFString, stringToUTF8String, toBase64Util
- `../../web/annotation_layer_builder.js`: AnnotationLayerBuilder
- `../../web/app_options.js`: AppOptions, OptionKind
- `../../web/download_manager.js`: DownloadManager
- `../../web/event_utils.js`: EventBus, WaitOnType, waitOnEventOrTimeout
- `../../web/genericl10n.js`: GenericL10n
- `../../web/pdf_find_controller.js`: FindState, PDFFindController
- `../../web/pdf_find_utils.js`: CharacterType, getCharacterType
- `../../web/pdf_history.js`: PDFHistory, isDestArraysEqual, isDestHashesEqual
- `../../web/pdf_link_service.js`: LinkTarget, PDFLinkService, SimpleLinkService
- `../../web/pdf_page_view.js`: PDFPageView
- `../../web/pdf_scripting_manager.component.js`: PDFScriptingManager
- `../../web/pdf_single_page_viewer.js`: PDFSinglePageViewer
- `../../web/pdf_viewer.js`: PDFPageViewBuffer, PDFViewer
- `../../web/struct_tree_layer_builder.js`: StructTreeLayerBuilder
- `../../web/text_layer_builder.js`: TextLayerBuilder
- `../../web/ui_utils.js`: AutoPrintRegExp, ProgressBar, RenderingStates, ScrollMode, SpreadMode, backtrackBeforeAllVisibleElements, binarySearchFirstItem, calcRound, getPageSizeInches, getVisibleElements, isPortraitOrientation, isValidRotation, parseQueryString, removeNullCharacters
- `../../web/xfa_layer_builder.js`: XfaLayerBuilder
- `../reporter.js`: TestReporter
- `./common_pdfstream_tests.js`: testCrossOriginRedirects
- `./test_utils.js`: CMAP_URL, DefaultCMapReaderFactory, DefaultFileReaderFactory, DefaultStandardFontDataFactory, STANDARD_FONT_DATA_URL, TEST_PDFS_PATH, TestPdfsServer, XRefMock, buildGetDocumentParams, createIdFactory, getCrossOriginHostname
</imports>

Code:
<code>
File:
src/core/annotation.js
1 /* Copyright 2012 Mozilla Foundation
2  *
3  * Licensed under the Apache License, Version 2.0 (the "License");
4  * you may not use this file except in compliance with the License.
5  * You may obtain a copy of the License at
6  *
7  *     http://www.apache.org/licenses/LICENSE-2.0
8  *
9  * Unless required by applicable law or agreed to in writing, software
10  * distributed under the License is distributed on an "AS IS" BASIS,
11  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
12  * See the License for the specific language governing permissions and
13  * limitations under the License.
14  */
15 
16 import {
17   AnnotationActionEventType,
18   AnnotationBorderStyleType,
19   AnnotationEditorType,
20   AnnotationFieldFlag,
21   AnnotationFlag,
22   AnnotationReplyType,
23   AnnotationType,
24   assert,
25   BASELINE_FACTOR,
26   FeatureTest,
27   getModificationDate,
28   IDENTITY_MATRIX,
29   info,
30   isArrayEqual,
31   LINE_DESCENT_FACTOR,
32   LINE_FACTOR,
33   OPS,
34   RenderingIntentFlag,
35   shadow,
36   stringToPDFString,
37   unreachable,
38   Util,
39   warn,
40 } from "../shared/util.js";
41 import {
42   collectActions,
43   escapeString,
44   getInheritableProperty,
45   getParentToUpdate,
46   getRotationMatrix,
47   isNumberArray,
48   lookupMatrix,
49   lookupNormalRect,
50   lookupRect,
51   numberToString,
52   stringToAsciiOrUTF16BE,
53   stringToUTF16String,
54 } from "./core_utils.js";
55 import {
56   createDefaultAppearance,
57   FakeUnicodeFont,
58   getPdfColor,
59   parseAppearanceStream,
60   parseDefaultAppearance,
61 } from "./default_appearance.js";
62 import { Dict, isName, isRefsEqual, Name, Ref, RefSet } from "./primitives.js";
63 import { Stream, StringStream } from "./stream.js";
64 import { BaseStream } from "./base_stream.js";
65 import { bidi } from "./bidi.js";
66 import { Catalog } from "./catalog.js";
67 import { ColorSpace } from "./colorspace.js";
68 import { FileSpec } from "./file_spec.js";
69 import { JpegStream } from "./jpeg_stream.js";
70 import { ObjectLoader } from "./object_loader.js";
71 import { OperatorList } from "./operator_list.js";
72 import { XFAFactory } from "./xfa/factory.js";
73 
1812 class WidgetAnnotation extends Annotation {
1813   constructor(params) {
1814     super(params);
1815 
1816     const { dict, xref, annotationGlobals } = params;
1817     const data = this.data;
1818     this._needAppearances = params.needAppearances;
1819 
1820     data.annotationType = AnnotationType.WIDGET;
1821     if (data.fieldName === undefined) {
1822       data.fieldName = this._constructFieldName(dict);
1823     }
1824 
1825     if (data.actions === undefined) {
1826       data.actions = collectActions(xref, dict, AnnotationActionEventType);
1827     }
1828 
1829     let fieldValue = getInheritableProperty({
1830       dict,
1831       key: "V",
1832       getArray: true,
1833     });
1834     data.fieldValue = this._decodeFormValue(fieldValue);
1835 
1836     const defaultFieldValue = getInheritableProperty({
1837       dict,
1838       key: "DV",
1839       getArray: true,
1840     });
1841     data.defaultFieldValue = this._decodeFormValue(defaultFieldValue);
1842 
1843     if (fieldValue === undefined && annotationGlobals.xfaDatasets) {
1844       // Try to figure out if we have something in the xfa dataset.
1845       const path = this._title.str;
1846       if (path) {
1847         this._hasValueFromXFA = true;
1848         data.fieldValue = fieldValue =
1849           annotationGlobals.xfaDatasets.getValue(path);
1850       }
1851     }
1852 
1853     // When no "V" entry exists, let the fieldValue fallback to the "DV" entry
1854     // (fixes issue13823.pdf).
1855     if (fieldValue === undefined && data.defaultFieldValue !== null) {
1856       data.fieldValue = data.defaultFieldValue;
1857     }
1858 
1859     data.alternativeText = stringToPDFString(dict.get("TU") || "");
1860 
1861     this.setDefaultAppearance(params);
1862 
1863     data.hasAppearance ||=
1864       this._needAppearances &&
1865       data.fieldValue !== undefined &&
1866       data.fieldValue !== null;
1867 
1868     const fieldType = getInheritableProperty({ dict, key: "FT" });
1869     data.fieldType = fieldType instanceof Name ? fieldType.name : null;
1870 
1871     const localResources = getInheritableProperty({ dict, key: "DR" });
1872     const acroFormResources = annotationGlobals.acroForm.get("DR");
1873     const appearanceResources = this.appearance?.dict.get("Resources");
1874 
1875     this._fieldResources = {
1876       localResources,
1877       acroFormResources,
1878       appearanceResources,
1879       mergedResources: Dict.merge({
1880         xref,
1881         dictArray: [localResources, appearanceResources, acroFormResources],
1882         mergeSubDicts: true,
1883       }),
1884     };
1885 
1886     data.fieldFlags = getInheritableProperty({ dict, key: "Ff" });
1887     if (!Number.isInteger(data.fieldFlags) || data.fieldFlags < 0) {
1888       data.fieldFlags = 0;
1889     }
1890 
1891     data.readOnly = this.hasFieldFlag(AnnotationFieldFlag.READONLY);
1892     data.required = this.hasFieldFlag(AnnotationFieldFlag.REQUIRED);
1893     data.hidden =
1894       this._hasFlag(data.annotationFlags, AnnotationFlag.HIDDEN) ||
1895       this._hasFlag(data.annotationFlags, AnnotationFlag.NOVIEW);
1896   }
1897 
2263   async _getAppearance(evaluator, task, intent, annotationStorage) {
2264     const isPassword = this.hasFieldFlag(AnnotationFieldFlag.PASSWORD);
2265     if (isPassword) {
2266       return null;
2267     }
2268     const storageEntry = annotationStorage?.get(this.data.id);
2269     let value, rotation;
2270     if (storageEntry) {
2271       value = storageEntry.formattedValue || storageEntry.value;
2272       rotation = storageEntry.rotation;
2273     }
2274 
2275     if (
2276       rotation === undefined &&
2277       value === undefined &&
2278       !this._needAppearances
2279     ) {
2280       if (!this._hasValueFromXFA || this.appearance) {
2281         // The annotation hasn't been rendered so use the appearance.
2282         return null;
2283       }
2284     }
2285 
2286     // Empty or it has a trailing whitespace.
2287     const colors = this.getBorderAndBackgroundAppearances(annotationStorage);
2288 
2289     if (value === undefined) {
2290       // The annotation has its value in XFA datasets but not in the V field.
2291       value = this.data.fieldValue;
2292       if (!value) {
2293         return `/Tx BMC q ${colors}Q EMC`;
2294       }
2295     }
2296 
2297     if (Array.isArray(value) && value.length === 1) {
2298       value = value[0];
2299     }
2300 
2301     assert(typeof value === "string", "Expected `value` to be a string.");
2302     value = value.trimEnd();
2303 
2304     if (this.data.combo) {
2305       // The value can be one of the exportValue or any other values.
2306       const option = this.data.options.find(
2307         ({ exportValue }) => value === exportValue
2308       );
2309       value = option?.displayValue || value;
2310     }
2311 
2312     if (value === "") {
2313       // the field is empty: nothing to render
2314       return `/Tx BMC q ${colors}Q EMC`;
2315     }
2316 
2317     if (rotation === undefined) {
2318       rotation = this.rotation;
2319     }
2320 
2321     let lineCount = -1;
2322     let lines;
2323 
2324     // We could have a text containing for example some sequences of chars and
2325     // their diacritics (e.g. "é".normalize("NFKD") shows 1 char when it's 2).
2326     // Positioning diacritics is really something we don't want to do here.
2327     // So if a font has a glyph for a acute accent and one for "e" then we won't
2328     // get any encoding issues but we'll render "e" and then "´".
2329     // It's why we normalize the string. We use NFC to preserve the initial
2330     // string, (e.g. "²".normalize("NFC") === "²"
2331     // but "²".normalize("NFKC") === "2").
2332     //
2333     // TODO: it isn't a perfect solution, some chars like "ẹ́" will be
2334     // decomposed into two chars ("ẹ" and "´"), so we should detect such
2335     // situations and then use either FakeUnicodeFont or set the
2336     // /NeedAppearances flag.
2337     if (this.data.multiLine) {
2338       lines = value.split(/\r\n?|\n/).map(line => line.normalize("NFC"));
2339       lineCount = lines.length;
2340     } else {
2341       lines = [value.replace(/\r\n?|\n/, "").normalize("NFC")];
2342     }
2343 
2344     const defaultPadding = 1;
2345     const defaultHPadding = 2;
2346     let totalHeight = this.data.rect[3] - this.data.rect[1];
2347     let totalWidth = this.data.rect[2] - this.data.rect[0];
2348 
2349     if (rotation === 90 || rotation === 270) {
2350       [totalWidth, totalHeight] = [totalHeight, totalWidth];
2351     }
2352 
2353     if (!this._defaultAppearance) {
2354       // The DA is required and must be a string.
2355       // If there is no font named Helvetica in the resource dictionary,
2356       // the evaluator will fall back to a default font.
2357       // Doing so prevents exceptions and allows saving/printing
2358       // the file as expected.
2359       this.data.defaultAppearanceData = parseDefaultAppearance(
2360         (this._defaultAppearance = "/Helvetica 0 Tf 0 g")
2361       );
2362     }
2363 
2364     let font = await WidgetAnnotation._getFontData(
2365       evaluator,
2366       task,
2367       this.data.defaultAppearanceData,
2368       this._fieldResources.mergedResources
2369     );
2370 
2371     let defaultAppearance, fontSize, lineHeight;
2372     const encodedLines = [];
2373     let encodingError = false;
2374     for (const line of lines) {
2375       const encodedString = font.encodeString(line);
2376       if (encodedString.length > 1) {
2377         encodingError = true;
2378       }
2379       encodedLines.push(encodedString.join(""));
2380     }
2381 
2382     if (encodingError && intent & RenderingIntentFlag.SAVE) {
2383       // We don't have a way to render the field, so we just rely on the
2384       // /NeedAppearances trick to let the different sofware correctly render
2385       // this pdf.
2386       return { needAppearances: true };
2387     }
2388 
2389     // We check that the font is able to encode the string.
2390     if (encodingError && this._isOffscreenCanvasSupported) {
2391       // If it can't then we fallback on fake unicode font (mapped to sans-serif
2392       // for the rendering).
2393       // It means that a printed form can be rendered differently (it depends on
2394       // the sans-serif font) but at least we've something to render.
2395       // In an ideal world the associated font should correctly handle the
2396       // possible chars but a user can add a smiley or whatever.
2397       // We could try to embed a font but it means that we must have access
2398       // to the raw font file.
2399       const fontFamily = this.data.comb ? "monospace" : "sans-serif";
2400       const fakeUnicodeFont = new FakeUnicodeFont(evaluator.xref, fontFamily);
2401       const resources = fakeUnicodeFont.createFontResources(lines.join(""));
2402       const newFont = resources.getRaw("Font");
2403 
2404       if (this._fieldResources.mergedResources.has("Font")) {
2405         const oldFont = this._fieldResources.mergedResources.get("Font");
2406         for (const key of newFont.getKeys()) {
2407           oldFont.set(key, newFont.getRaw(key));
2408         }
2409       } else {
2410         this._fieldResources.mergedResources.set("Font", newFont);
2411       }
2412 
2413       const fontName = fakeUnicodeFont.fontName.name;
2414       font = await WidgetAnnotation._getFontData(
2415         evaluator,
2416         task,
2417         { fontName, fontSize: 0 },
2418         resources
2419       );
2420 
2421       for (let i = 0, ii = encodedLines.length; i < ii; i++) {
2422         encodedLines[i] = stringToUTF16String(lines[i]);
2423       }
2424 
2425       const savedDefaultAppearance = Object.assign(
2426         Object.create(null),
2427         this.data.defaultAppearanceData
2428       );
2429       this.data.defaultAppearanceData.fontSize = 0;
2430       this.data.defaultAppearanceData.fontName = fontName;
2431 
2432       [defaultAppearance, fontSize, lineHeight] = this._computeFontSize(
2433         totalHeight - 2 * defaultPadding,
2434         totalWidth - 2 * defaultHPadding,
2435         value,
2436         font,
2437         lineCount
2438       );
2439 
2440       this.data.defaultAppearanceData = savedDefaultAppearance;
2441     } else {
2442       if (!this._isOffscreenCanvasSupported) {
2443         warn(
2444           "_getAppearance: OffscreenCanvas is not supported, annotation may not render correctly."
2445         );
2446       }
2447 
2448       [defaultAppearance, fontSize, lineHeight] = this._computeFontSize(
2449         totalHeight - 2 * defaultPadding,
2450         totalWidth - 2 * defaultHPadding,
2451         value,
2452         font,
2453         lineCount
2454       );
2455     }
2456 
2457     let descent = font.descent;
2458     if (isNaN(descent)) {
2459       descent = BASELINE_FACTOR * lineHeight;
2460     } else {
2461       descent = Math.max(
2462         BASELINE_FACTOR * lineHeight,
2463         Math.abs(descent) * fontSize
2464       );
2465     }
2466 
2467     // Take into account the space we have to compute the default vertical
2468     // padding.
2469     const defaultVPadding = Math.min(
2470       Math.floor((totalHeight - fontSize) / 2),
2471       defaultPadding
2472     );
2473     const alignment = this.data.textAlignment;
2474 
2475     if (this.data.multiLine) {
2476       return this._getMultilineAppearance(
2477         defaultAppearance,
2478         encodedLines,
2479         font,
2480         fontSize,
2481         totalWidth,
2482         totalHeight,
2483         alignment,
2484         defaultHPadding,
2485         defaultVPadding,
2486         descent,
2487         lineHeight,
2488         annotationStorage
2489       );
2490     }
2491 
2492     if (this.data.comb) {
2493       return this._getCombAppearance(
2494         defaultAppearance,
2495         font,
2496         encodedLines[0],
2497         fontSize,
2498         totalWidth,
2499         totalHeight,
2500         defaultHPadding,
2501         defaultVPadding,
2502         descent,
2503         lineHeight,
2504         annotationStorage
2505       );
2506     }
2507 
2508     const bottomPadding = defaultVPadding + descent;
2509     if (alignment === 0 || alignment > 2) {
2510       // Left alignment: nothing to do
2511       return (
2512         `/Tx BMC q ${colors}BT ` +
2513         defaultAppearance +
2514         ` 1 0 0 1 ${numberToString(defaultHPadding)} ${numberToString(
2515           bottomPadding
2516         )} Tm (${escapeString(encodedLines[0])}) Tj` +
2517         " ET Q EMC"
2518       );
2519     }
2520 
2521     const prevInfo = { shift: 0 };
2522     const renderedText = this._renderText(
2523       encodedLines[0],
2524       font,
2525       fontSize,
2526       totalWidth,
2527       alignment,
2528       prevInfo,
2529       defaultHPadding,
2530       bottomPadding
2531     );
2532     return (
2533       `/Tx BMC q ${colors}BT ` +
2534       defaultAppearance +
2535       ` 1 0 0 1 0 0 Tm ${renderedText}` +
2536       " ET Q EMC"
2537     );
2538   }
2539 
2735 }
2736 
2737 class TextWidgetAnnotation extends WidgetAnnotation {
2738   constructor(params) {
2739     super(params);
2740 
2741     const { dict } = params;
2742 
2743     if (dict.has("PMD")) {
2744       // It's used to display a barcode but it isn't specified so we just hide
2745       // it to avoid any confusion.
2746       this.flags |= AnnotationFlag.HIDDEN;
2747       this.data.hidden = true;
2748       warn("Barcodes are not supported");
2749     }
2750 
2751     this.data.hasOwnCanvas = this.data.readOnly && !this.data.noHTML;
2752     this._hasText = true;
2753 
2754     // The field value is always a string.
2755     if (typeof this.data.fieldValue !== "string") {
2756       this.data.fieldValue = "";
2757     }
2758 
2759     // Determine the alignment of text in the field.
2760     let alignment = getInheritableProperty({ dict, key: "Q" });
2761     if (!Number.isInteger(alignment) || alignment < 0 || alignment > 2) {
2762       alignment = null;
2763     }
2764     this.data.textAlignment = alignment;
2765 
2766     // Determine the maximum length of text in the field.
2767     let maximumLength = getInheritableProperty({ dict, key: "MaxLen" });
2768     if (!Number.isInteger(maximumLength) || maximumLength < 0) {
2769       maximumLength = 0;
2770     }
2771     this.data.maxLen = maximumLength;
2772 
2773     // Process field flags for the display layer.
2774     this.data.multiLine = this.hasFieldFlag(AnnotationFieldFlag.MULTILINE);
2775     this.data.comb =
2776       this.hasFieldFlag(AnnotationFieldFlag.COMB) &&
2777       !this.hasFieldFlag(AnnotationFieldFlag.MULTILINE) &&
2778       !this.hasFieldFlag(AnnotationFieldFlag.PASSWORD) &&
2779       !this.hasFieldFlag(AnnotationFieldFlag.FILESELECT) &&
2780       this.data.maxLen !== 0;
2781     this.data.doNotScroll = this.hasFieldFlag(AnnotationFieldFlag.DONOTSCROLL);
2782   }
2783 
2959   getFieldObject() {
2960     return {
2961       id: this.data.id,
2962       value: this.data.fieldValue,
2963       defaultValue: this.data.defaultFieldValue || "",
2964       multiline: this.data.multiLine,
2965       password: this.hasFieldFlag(AnnotationFieldFlag.PASSWORD),
2966       charLimit: this.data.maxLen,
2967       comb: this.data.comb,
2968       editable: !this.data.readOnly,
2969       hidden: this.data.hidden,
2970       name: this.data.fieldName,
2971       rect: this.data.rect,
2972       actions: this.data.actions,
2973       page: this.data.pageIndex,
2974       strokeColor: this.data.borderColor,
2975       fillColor: this.data.backgroundColor,
2976       rotation: this.rotation,
2977       type: "text",
2978     };
2979   }
2980 }
2981 
5100 
File:
src/display/annotation_layer.js
1 /* Copyright 2014 Mozilla Foundation
2  *
3  * Licensed under the Apache License, Version 2.0 (the "License");
4  * you may not use this file except in compliance with the License.
5  * You may obtain a copy of the License at
6  *
7  *     http://www.apache.org/licenses/LICENSE-2.0
8  *
9  * Unless required by applicable law or agreed to in writing, software
10  * distributed under the License is distributed on an "AS IS" BASIS,
11  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
12  * See the License for the specific language governing permissions and
13  * limitations under the License.
14  */
15 
18 // eslint-disable-next-line max-len
20 // eslint-disable-next-line max-len
23 // eslint-disable-next-line max-len
25 // eslint-disable-next-line max-len
27 
28 import {
29   AnnotationBorderStyleType,
30   AnnotationEditorType,
31   AnnotationPrefix,
32   AnnotationType,
33   FeatureTest,
34   LINE_FACTOR,
35   shadow,
36   unreachable,
37   Util,
38   warn,
39 } from "../shared/util.js";
40 import { PDFDateString, setLayerDimensions } from "./display_utils.js";
41 import { AnnotationStorage } from "./annotation_storage.js";
42 import { ColorConverters } from "../shared/scripting_utils.js";
43 import { DOMSVGFactory } from "./svg_factory.js";
44 import { XfaLayer } from "./xfa_layer.js";
45 
46 const DEFAULT_TAB_INDEX = 1000;
47 const DEFAULT_FONT_SIZE = 9;
48 const GetElementsByNameSet = new WeakSet();
49 
1223 class TextWidgetAnnotationElement extends WidgetAnnotationElement {
1224   constructor(parameters) {
1225     const isRenderable =
1226       parameters.renderForms ||
1227       parameters.data.hasOwnCanvas ||
1228       (!parameters.data.hasAppearance && !!parameters.data.fieldValue);
1229     super(parameters, { isRenderable });
1230   }
1231 
1245   render() {
1246     const storage = this.annotationStorage;
1247     const id = this.data.id;
1248 
1249     this.container.classList.add("textWidgetAnnotation");
1250 
1251     let element = null;
1252     if (this.renderForms) {
1253       // NOTE: We cannot set the values using `element.value` below, since it
1254       //       prevents the AnnotationLayer rasterizer in `test/driver.js`
1255       //       from parsing the elements correctly for the reference tests.
1256       const storedData = storage.getValue(id, {
1257         value: this.data.fieldValue,
1258       });
1259       let textContent = storedData.value || "";
1260       const maxLen = storage.getValue(id, {
1261         charLimit: this.data.maxLen,
1262       }).charLimit;
1263       if (maxLen && textContent.length > maxLen) {
1264         textContent = textContent.slice(0, maxLen);
1265       }
1266 
1267       let fieldFormattedValues =
1268         storedData.formattedValue || this.data.textContent?.join("\n") || null;
1269       if (fieldFormattedValues && this.data.comb) {
1270         fieldFormattedValues = fieldFormattedValues.replaceAll(/\s+/g, "");
1271       }
1272 
1273       const elementData = {
1274         userValue: textContent,
1275         formattedValue: fieldFormattedValues,
1276         lastCommittedValue: null,
1277         commitKey: 1,
1278         focused: false,
1279       };
1280 
1281       if (this.data.multiLine) {
1282         element = document.createElement("textarea");
1283         element.textContent = fieldFormattedValues ?? textContent;
1284         if (this.data.doNotScroll) {
1285           element.style.overflowY = "hidden";
1286         }
1287       } else {
1288         element = document.createElement("input");
1289         element.type = "text";
1290         element.setAttribute("value", fieldFormattedValues ?? textContent);
1291         if (this.data.doNotScroll) {
1292           element.style.overflowX = "hidden";
1293         }
1294       }
1295       if (this.data.hasOwnCanvas) {
1296         element.hidden = true;
1297       }
1298       GetElementsByNameSet.add(element);
1299       element.setAttribute("data-element-id", id);
1300 
1301       element.disabled = this.data.readOnly;
1302       element.name = this.data.fieldName;
1303       element.tabIndex = DEFAULT_TAB_INDEX;
1304 
1305       this._setRequired(element, this.data.required);
1306 
1307       if (maxLen) {
1308         element.maxLength = maxLen;
1309       }
1310 
1311       element.addEventListener("input", event => {
1312         storage.setValue(id, { value: event.target.value });
1313         this.setPropertyOnSiblings(
1314           element,
1315           "value",
1316           event.target.value,
1317           "value"
1318         );
1319         elementData.formattedValue = null;
1320       });
1321 
1322       element.addEventListener("resetform", event => {
1323         const defaultValue = this.data.defaultFieldValue ?? "";
1324         element.value = elementData.userValue = defaultValue;
1325         elementData.formattedValue = null;
1326       });
1327 
1328       let blurListener = event => {
1329         const { formattedValue } = elementData;
1330         if (formattedValue !== null && formattedValue !== undefined) {
1331           event.target.value = formattedValue;
1332         }
1333         // Reset the cursor position to the start of the field (issue 12359).
1334         event.target.scrollLeft = 0;
1335       };
1336 
1337       if (this.enableScripting && this.hasJSActions) {
1338         element.addEventListener("focus", event => {
1339           if (elementData.focused) {
1340             return;
1341           }
1342           const { target } = event;
1343           if (elementData.userValue) {
1344             target.value = elementData.userValue;
1345           }
1346           elementData.lastCommittedValue = target.value;
1347           elementData.commitKey = 1;
1348           if (!this.data.actions?.Focus) {
1349             elementData.focused = true;
1350           }
1351         });
1352 
1353         element.addEventListener("updatefromsandbox", jsEvent => {
1354           this.showElementAndHideCanvas(jsEvent.target);
1355           const actions = {
1356             value(event) {
1357               elementData.userValue = event.detail.value ?? "";
1358               storage.setValue(id, { value: elementData.userValue.toString() });
1359               event.target.value = elementData.userValue;
1360             },
1361             formattedValue(event) {
1362               const { formattedValue } = event.detail;
1363               elementData.formattedValue = formattedValue;
1364               if (
1365                 formattedValue !== null &&
1366                 formattedValue !== undefined &&
1367                 event.target !== document.activeElement
1368               ) {
1369                 // Input hasn't the focus so display formatted string
1370                 event.target.value = formattedValue;
1371               }
1372               storage.setValue(id, {
1373                 formattedValue,
1374               });
1375             },
1376             selRange(event) {
1377               event.target.setSelectionRange(...event.detail.selRange);
1378             },
1379             charLimit: event => {
1380               const { charLimit } = event.detail;
1381               const { target } = event;
1382               if (charLimit === 0) {
1383                 target.removeAttribute("maxLength");
1384                 return;
1385               }
1386 
1387               target.setAttribute("maxLength", charLimit);
1388               let value = elementData.userValue;
1389               if (!value || value.length <= charLimit) {
1390                 return;
1391               }
1392               value = value.slice(0, charLimit);
1393               target.value = elementData.userValue = value;
1394               storage.setValue(id, { value });
1395 
1396               this.linkService.eventBus?.dispatch("dispatcheventinsandbox", {
1397                 source: this,
1398                 detail: {
1399                   id,
1400                   name: "Keystroke",
1401                   value,
1402                   willCommit: true,
1403                   commitKey: 1,
1404                   selStart: target.selectionStart,
1405                   selEnd: target.selectionEnd,
1406                 },
1407               });
1408             },
1409           };
1410           this._dispatchEventFromSandbox(actions, jsEvent);
1411         });
1412 
1413         // Even if the field hasn't any actions
1414         // leaving it can still trigger some actions with Calculate
1415         element.addEventListener("keydown", event => {
1416           elementData.commitKey = 1;
1417           // If the key is one of Escape, Enter then the data are committed.
1418           // If we've a Tab then data will be committed on blur.
1419           let commitKey = -1;
1420           if (event.key === "Escape") {
1421             commitKey = 0;
1422           } else if (event.key === "Enter" && !this.data.multiLine) {
1423             // When we've a multiline field, "Enter" key is a key as the other
1424             // hence we don't commit the data (Acrobat behaves the same way)
1425             // (see issue #15627).
1426             commitKey = 2;
1427           } else if (event.key === "Tab") {
1428             elementData.commitKey = 3;
1429           }
1430           if (commitKey === -1) {
1431             return;
1432           }
1433           const { value } = event.target;
1434           if (elementData.lastCommittedValue === value) {
1435             return;
1436           }
1437           elementData.lastCommittedValue = value;
1438           // Save the entered value
1439           elementData.userValue = value;
1440           this.linkService.eventBus?.dispatch("dispatcheventinsandbox", {
1441             source: this,
1442             detail: {
1443               id,
1444               name: "Keystroke",
1445               value,
1446               willCommit: true,
1447               commitKey,
1448               selStart: event.target.selectionStart,
1449               selEnd: event.target.selectionEnd,
1450             },
1451           });
1452         });
1453         const _blurListener = blurListener;
1454         blurListener = null;
1455         element.addEventListener("blur", event => {
1456           if (!elementData.focused || !event.relatedTarget) {
1457             return;
1458           }
1459           if (!this.data.actions?.Blur) {
1460             elementData.focused = false;
1461           }
1462           const { value } = event.target;
1463           elementData.userValue = value;
1464           if (elementData.lastCommittedValue !== value) {
1465             this.linkService.eventBus?.dispatch("dispatcheventinsandbox", {
1466               source: this,
1467               detail: {
1468                 id,
1469                 name: "Keystroke",
1470                 value,
1471                 willCommit: true,
1472                 commitKey: elementData.commitKey,
1473                 selStart: event.target.selectionStart,
1474                 selEnd: event.target.selectionEnd,
1475               },
1476             });
1477           }
1478           _blurListener(event);
1479         });
1480 
1481         if (this.data.actions?.Keystroke) {
1482           element.addEventListener("beforeinput", event => {
1483             elementData.lastCommittedValue = null;
1484             const { data, target } = event;
1485             const { value, selectionStart, selectionEnd } = target;
1486 
1487             let selStart = selectionStart,
1488               selEnd = selectionEnd;
1489 
1490             switch (event.inputType) {
1491               // https://rawgit.com/w3c/input-events/v1/index.html#interface-InputEvent-Attributes
1492               case "deleteWordBackward": {
1493                 const match = value
1494                   .substring(0, selectionStart)
1495                   .match(/\w*[^\w]*$/);
1496                 if (match) {
1497                   selStart -= match[0].length;
1498                 }
1499                 break;
1500               }
1501               case "deleteWordForward": {
1502                 const match = value
1503                   .substring(selectionStart)
1504                   .match(/^[^\w]*\w*/);
1505                 if (match) {
1506                   selEnd += match[0].length;
1507                 }
1508                 break;
1509               }
1510               case "deleteContentBackward":
1511                 if (selectionStart === selectionEnd) {
1512                   selStart -= 1;
1513                 }
1514                 break;
1515               case "deleteContentForward":
1516                 if (selectionStart === selectionEnd) {
1517                   selEnd += 1;
1518                 }
1519                 break;
1520             }
1521 
1522             // We handle the event ourselves.
1523             event.preventDefault();
1524             this.linkService.eventBus?.dispatch("dispatcheventinsandbox", {
1525               source: this,
1526               detail: {
1527                 id,
1528                 name: "Keystroke",
1529                 value,
1530                 change: data || "",
1531                 willCommit: false,
1532                 selStart,
1533                 selEnd,
1534               },
1535             });
1536           });
1537         }
1538 
1539         this._setEventListeners(
1540           element,
1541           elementData,
1542           [
1543             ["focus", "Focus"],
1544             ["blur", "Blur"],
1545             ["mousedown", "Mouse Down"],
1546             ["mouseenter", "Mouse Enter"],
1547             ["mouseleave", "Mouse Exit"],
1548             ["mouseup", "Mouse Up"],
1549           ],
1550           event => event.target.value
1551         );
1552       }
1553 
1554       if (blurListener) {
1555         element.addEventListener("blur", blurListener);
1556       }
1557 
1558       if (this.data.comb) {
1559         const fieldWidth = this.data.rect[2] - this.data.rect[0];
1560         const combWidth = fieldWidth / maxLen;
1561 
1562         element.classList.add("comb");
1563         element.style.letterSpacing = `calc(${combWidth}px * var(--scale-factor) - 1ch)`;
1564       }
1565     } else {
1566       element = document.createElement("div");
1567       element.textContent = this.data.fieldValue;
1568       element.style.verticalAlign = "middle";
1569       element.style.display = "table-cell";
1570 
1571       if (this.data.hasOwnCanvas) {
1572         element.hidden = true;
1573       }
1574     }
1575 
1576     this._setTextStyle(element);
1577     this._setBackgroundColor(element);
1578     this._setDefaultPropertiesFromJS(element);
1579 
1580     this.container.append(element);
1581     return this.container;
1582   }
1583 }
1584 
3332 
</code>

PR summary:
<pr_summary>
Support the password field-flag in TextWidgetAnnotation (issue 19389)

</pr_summary>

Your task:
You are a software tester at pdf.js.
1. Write exactly one javascript test `it("...", async () => {...})` block.
2. Your test must fail on the code before the patch, and pass after, hence the test will verify that the patch resolves the issue.
3. The test must be self-contained and to-the-point.
4. Use only the provided imports (respect the paths exactly how they are given) by importing dynamically for compatibility with Node.js — no new dependencies. 
5. Return only the javascript code (no comments or explanations).

Example structure:
it("should <describe behavior>", async () => {
  const { example } = await import("../../src/core/example.js");
  <initialize required variables>;
  <define expected variable>;
  <generate actual variables>;
  <compare expected with actual>;
});

