Before you begin:
- Keep going until the job is completely solved — don’t stop halfway.
- If you’re unsure about the behavior, reread the provided patch carefully; do not hallucinate.
- Plan your approach before writing code by reflecting on whether the test truly fails before and passes after.

Issue:
<issue>
[Bug]: Password fields render as regular text fields
### Attach (recommended) or Link to PDF file

[password-bug.pdf](https://github.com/user-attachments/files/18586315/password-bug.pdf)

### Web browser and its version

Firefox 134.0.2 (64-bit)

### Operating system and its version

Windows 10 Pro 22H2 19045.5247

### PDF.js version

Whatever version is currently in the online demo

### Is the bug present in the latest PDF.js version?

Yes

### Is a browser extension

No

### Steps to reproduce the problem

1. Have a PDF that includes a password field.
2. Open it in Firefox, the online demo, or using the Chrome PDF Viewer extension.
https://chromewebstore.google.com/detail/pdf-viewer/oemmndcbldboiebfnladdacbdfmadadm
3. The PDF renders the password field as if it were a normal text field.
![Image](https://github.com/user-attachments/assets/35811a62-6752-49f3-8763-309db033963b)

Also, when interrogating the PDF with pdfjs-dist v3.11.174, the field is given the type "text" rather than "password".
(I know that's an outdated version, but I just can't figure out how to make a newer version work, and it illustrates that it's likely not a rendering problem, but an underlying problem when parsing the PDF)

### What is the expected behavior?

Password fields should be rendered as such, and the characters should be obscured (with asterisks or otherwise), like what happens in the following:

Adobe Acrobat:
![Image](https://github.com/user-attachments/assets/6af70310-7c60-49dc-b2dd-daf412b72cc0)
Chrome:
![Image](https://github.com/user-attachments/assets/69311e4e-48ae-4c34-84f9-fb72da0facad)
Edge (quite probably the same renderer as Chrome):
![Image](https://github.com/user-attachments/assets/0e3dc151-5c29-44ba-9c58-c897422c6b47)

### What went wrong?

As mentioned above, the PDF renders the password field as if it were a normal text field.

### Link to a viewer

_No response_

### Additional context

Admittedly, the usefulness of a password field in a PDF is somewhat lost on me, however it is a feature that should be supported because it's a bit of a problem if a value should be obscured and you completely expose it.
Yes the value would still be visible to anyone with basic JS knowledge that inspects the viewer, but at least it wouldn't be visible to someone looking over your shoulder when you open the PDF.
</issue>

Patch:
<patch>
diff --git a/src/core/annotation.js b/src/core/annotation.js
--- a/src/core/annotation.js
+++ b/src/core/annotation.js
@@ -1888,6 +1888,7 @@ class WidgetAnnotation extends Annotation {
       data.fieldFlags = 0;
     }
 
+    data.password = this.hasFieldFlag(AnnotationFieldFlag.PASSWORD);
     data.readOnly = this.hasFieldFlag(AnnotationFieldFlag.READONLY);
     data.required = this.hasFieldFlag(AnnotationFieldFlag.REQUIRED);
     data.hidden =
@@ -2261,8 +2262,7 @@ class WidgetAnnotation extends Annotation {
   }
 
   async _getAppearance(evaluator, task, intent, annotationStorage) {
-    const isPassword = this.hasFieldFlag(AnnotationFieldFlag.PASSWORD);
-    if (isPassword) {
+    if (this.data.password) {
       return null;
     }
     const storageEntry = annotationStorage?.get(this.data.id);
@@ -2962,7 +2962,7 @@ class TextWidgetAnnotation extends WidgetAnnotation {
       value: this.data.fieldValue,
       defaultValue: this.data.defaultFieldValue || "",
       multiline: this.data.multiLine,
-      password: this.hasFieldFlag(AnnotationFieldFlag.PASSWORD),
+      password: this.data.password,
       charLimit: this.data.maxLen,
       comb: this.data.comb,
       editable: !this.data.readOnly,

diff --git a/src/display/annotation_layer.js b/src/display/annotation_layer.js
--- a/src/display/annotation_layer.js
+++ b/src/display/annotation_layer.js
@@ -1286,7 +1286,7 @@ class TextWidgetAnnotationElement extends WidgetAnnotationElement {
         }
       } else {
         element = document.createElement("input");
-        element.type = "text";
+        element.type = this.data.password ? "password" : "text";
         element.setAttribute("value", fieldFormattedValues ?? textContent);
         if (this.data.doNotScroll) {
           element.style.overflowX = "hidden";


</patch>

Imports:
<imports>
Available Packages
Dev Dependencies:
- @babel/core: ^7.26.0
- @babel/preset-env: ^7.26.0
- @babel/runtime: ^7.26.0
- @fluent/bundle: ^0.18.0
- @fluent/dom: ^0.10.0
- @metalsmith/layouts: ^2.7.0
- @metalsmith/markdown: ^1.10.0
- @napi-rs/canvas: ^0.1.65
- @types/node: ^22.10.7
- autoprefixer: ^10.4.20
- babel-loader: ^9.2.1
- caniuse-lite: ^1.0.30001692
- core-js: ^3.40.0
- eslint: ^9.18.0
- eslint-plugin-import: ^2.31.0
- eslint-plugin-jasmine: ^4.2.2
- eslint-plugin-json: ^4.0.1
- eslint-plugin-no-unsanitized: ^4.1.2
- eslint-plugin-perfectionist: ^4.6.0
- eslint-plugin-prettier: ^5.2.2
- eslint-plugin-unicorn: ^56.0.1
- globals: ^15.14.0
- gulp: ^5.0.0
- gulp-cli: ^3.0.0
- gulp-postcss: ^10.0.0
- gulp-rename: ^2.0.0
- gulp-replace: ^1.1.4
- gulp-zip: ^6.1.0
- highlight.js: ^11.11.1
- jasmine: ^5.5.0
- jsdoc: ^4.0.4
- jstransformer-nunjucks: ^1.2.0
- metalsmith: ^2.6.3
- metalsmith-html-relative: ^2.0.6
- ordered-read-streams: ^2.0.0
- pngjs: ^7.0.0
- postcss: ^8.5.1
- postcss-dark-theme-class: ^1.3.0
- postcss-dir-pseudo-class: ^9.0.1
- postcss-discard-comments: ^7.0.3
- postcss-nesting: ^13.0.1
- prettier: ^3.4.2
- puppeteer: ^24.1.0
- stylelint: ^16.13.2
- stylelint-prettier: ^5.0.2
- svglint: ^3.1.0
- terser-webpack-plugin: ^5.3.11
- tsc-alias: ^1.8.10
- ttest: ^4.0.0
- typescript: ^5.7.3
- vinyl: ^3.0.0
- webpack: ^5.97.1
- webpack-stream: ^7.0.0
- yargs: ^17.7.2

Engines:
- node: >=20

Available Relative Imports:
- `../../src/core/annotation.js`: Annotation, AnnotationBorderStyle, AnnotationFactory, MarkupAnnotation, getQuadPoints
- `../../src/core/bidi.js`: bidi
- `../../src/core/cff_parser.js`: CFFCharset, CFFCompiler, CFFFDSelect, CFFParser, CFFStrings
- `../../src/core/cmap.js`: CMap, CMapFactory, IdentityCMap
- `../../src/core/colorspace.js`: ColorSpace
- `../../src/core/core_utils.js`: arrayBuffersToBytes, encodeToXmlString, escapePDFName, escapeString, getInheritableProperty, getSizeInBytes, isAscii, isWhiteSpace, log2, numberToString, parseXFAPath, recoverJsURL, stringToUTF16HexString, stringToUTF16String, toRomanNumerals, validateCSSFont
- `../../src/core/crypto.js`: AES128Cipher, AES256Cipher, ARCFourCipher, CipherTransformFactory, PDF17, PDF20, calculateMD5, calculateSHA256, calculateSHA384, calculateSHA512
- `../../src/core/default_appearance.js`: createDefaultAppearance, parseAppearanceStream, parseDefaultAppearance
- `../../src/core/document.js`: PDFDocument, Page
- `../../src/core/encodings.js`: getEncoding
- `../../src/core/evaluator.js`: PartialEvaluator
- `../../src/core/flate_stream.js`: FlateStream
- `../../src/core/font_substitutions.js`: getFontSubstitution
- `../../src/core/fonts_utils.js`: SEAC_ANALYSIS_ENABLED
- `../../src/core/function.js`: PDFFunctionFactory, PostScriptCompiler, PostScriptEvaluator
- `../../src/core/glyphlist.js`: getDingbatsGlyphsUnicode, getGlyphsUnicode
- `../../src/core/image_utils.js`: GlobalImageCache, LocalColorSpaceCache
- `../../src/core/jbig2.js`: Jbig2Error, Jbig2Image
- `../../src/core/jpg.js`: JpegError, JpegImage
- `../../src/core/jpx.js`: JpxError, JpxImage
- `../../src/core/metadata_parser.js`: MetadataParser
- `../../src/core/operator_list.js`: OperatorList
- `../../src/core/parser.js`: Lexer, Linearization, Parser
- `../../src/core/predictor_stream.js`: PredictorStream
- `../../src/core/primitives.js`: Cmd, Dict, EOF, Name, Ref, RefSet, RefSetCache, isCmd, isDict, isName, isRefsEqual
- `../../src/core/ps_parser.js`: PostScriptLexer, PostScriptParser
- `../../src/core/stream.js`: NullStream, Stream, StringStream
- `../../src/core/type1_parser.js`: Type1Parser
- `../../src/core/unicode.js`: getCharUnicodeCategory, getUnicodeForGlyph, getUnicodeRangeFor, mapSpecialUnicodeValues
- `../../src/core/worker.js`: WorkerMessageHandler, WorkerTask
- `../../src/core/writer.js`: incrementalUpdate, writeChanges, writeDict
- `../../src/core/xfa/bind.js`: Binder
- `../../src/core/xfa/data.js`: DataHandler
- `../../src/core/xfa/factory.js`: XFAFactory
- `../../src/core/xfa/formcalc_lexer.js`: Lexer, TOKEN, Token
- `../../src/core/xfa/formcalc_parser.js`: Errors, Parser
- `../../src/core/xfa/parser.js`: XFAParser
- `../../src/core/xfa/som.js`: searchNode
- `../../src/core/xfa/symbol_utils.js`: $dump, $getChildren, $getChildrenByClass, $getChildrenByName, $text, $uid
- `../../src/core/xml_parser.js`: SimpleXMLParser, XMLParserBase
- `../../src/display/annotation_layer.js`: AnnotationLayer
- `../../src/display/annotation_storage.js`: AnnotationStorage
- `../../src/display/api.js`: LoopbackPort, PDFDataRangeTransport, PDFDocumentLoadingTask, PDFDocumentProxy, PDFPageProxy, PDFWorker, RenderTask, build, getDocument, version
- `../../src/display/canvas_factory.js`: DOMCanvasFactory
- `../../src/display/cmap_reader_factory.js`: DOMCMapReaderFactory
- `../../src/display/display_utils.js`: OutputScale, PDFDateString, PageViewport, PixelsPerInch, RenderingCancelledException, StatTimer, fetchData, getFilenameFromUrl, getPdfFilenameFromUrl, getXfaPageViewport, isDataScheme, isPdfFile, isValidFetchUrl, noContextMenu, setLayerDimensions, stopEvent
- `../../src/display/draw_layer.js`: DrawLayer
- `../../src/display/editor/annotation_editor_layer.js`: AnnotationEditorLayer
- `../../src/display/editor/color_picker.js`: ColorPicker
- `../../src/display/editor/tools.js`: AnnotationEditorUIManager, CommandManager
- `../../src/display/fetch_stream.js`: PDFFetchStream
- `../../src/display/metadata.js`: Metadata
- `../../src/display/network.js`: PDFNetworkStream
- `../../src/display/network_utils.js`: createHeaders, createResponseError, extractFilenameFromHeader, validateRangeRequestCapabilities, validateResponseStatus
- `../../src/display/node_stream.js`: PDFNodeStream
- `../../src/display/node_utils.js`: NodeCMapReaderFactory, NodeStandardFontDataFactory, fetchData
- `../../src/display/standard_fontdata_factory.js`: DOMStandardFontDataFactory
- `../../src/display/svg_factory.js`: DOMSVGFactory
- `../../src/display/text_layer.js`: TextLayer
- `../../src/display/touch_manager.js`: TouchManager
- `../../src/display/worker_options.js`: GlobalWorkerOptions
- `../../src/display/xfa_layer.js`: XfaLayer
- `../../src/shared/message_handler.js`: MessageHandler
- `../../src/shared/murmurhash3.js`: MurmurHash3_64
- `../../src/shared/util.js`: AbortException, AnnotationBorderStyleType, AnnotationEditorParamsType, AnnotationEditorType, AnnotationFieldFlag, AnnotationFlag, AnnotationMode, AnnotationType, BaseException, FeatureTest, FormatError, ImageKind, InvalidPDFException, OPS, PasswordException, PasswordResponses, PermissionFlag, RenderingIntentFlag, ResponseException, UnknownErrorException, Util, VerbosityLevel, assert, bytesToString, createValidAbsoluteUrl, getModificationDate, getUuid, getVerbosityLevel, isNodeJS, normalizeUnicode, objectSize, setVerbosityLevel, shadow, string32, stringToBytes, stringToPDFString, stringToUTF8String, toBase64Util
- `../../web/annotation_layer_builder.js`: AnnotationLayerBuilder
- `../../web/app_options.js`: AppOptions, OptionKind
- `../../web/download_manager.js`: DownloadManager
- `../../web/event_utils.js`: EventBus, WaitOnType, waitOnEventOrTimeout
- `../../web/genericl10n.js`: GenericL10n
- `../../web/pdf_find_controller.js`: FindState, PDFFindController
- `../../web/pdf_find_utils.js`: CharacterType, getCharacterType
- `../../web/pdf_history.js`: PDFHistory, isDestArraysEqual, isDestHashesEqual
- `../../web/pdf_link_service.js`: LinkTarget, PDFLinkService, SimpleLinkService
- `../../web/pdf_page_view.js`: PDFPageView
- `../../web/pdf_scripting_manager.component.js`: PDFScriptingManager
- `../../web/pdf_single_page_viewer.js`: PDFSinglePageViewer
- `../../web/pdf_viewer.js`: PDFPageViewBuffer, PDFViewer
- `../../web/struct_tree_layer_builder.js`: StructTreeLayerBuilder
- `../../web/text_layer_builder.js`: TextLayerBuilder
- `../../web/ui_utils.js`: AutoPrintRegExp, ProgressBar, RenderingStates, ScrollMode, SpreadMode, backtrackBeforeAllVisibleElements, binarySearchFirstItem, calcRound, getPageSizeInches, getVisibleElements, isPortraitOrientation, isValidRotation, parseQueryString, removeNullCharacters
- `../../web/xfa_layer_builder.js`: XfaLayerBuilder
- `../reporter.js`: TestReporter
- `./common_pdfstream_tests.js`: testCrossOriginRedirects
- `./test_utils.js`: CMAP_URL, DefaultCMapReaderFactory, DefaultFileReaderFactory, DefaultStandardFontDataFactory, STANDARD_FONT_DATA_URL, TEST_PDFS_PATH, TestPdfsServer, XRefMock, buildGetDocumentParams, createIdFactory, getCrossOriginHostname
</imports>

Code:
<code>
File:
src/core/annotation.js
1 /* Copyright 2012 Mozilla Foundation
2  *
3  * Licensed under the Apache License, Version 2.0 (the "License");
4  * you may not use this file except in compliance with the License.
5  * You may obtain a copy of the License at
6  *
7  *     http://www.apache.org/licenses/LICENSE-2.0
8  *
9  * Unless required by applicable law or agreed to in writing, software
10  * distributed under the License is distributed on an "AS IS" BASIS,
11  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
12  * See the License for the specific language governing permissions and
13  * limitations under the License.
14  */
15 
16 import {
17   AnnotationActionEventType,
18   AnnotationBorderStyleType,
19   AnnotationEditorType,
20   AnnotationFieldFlag,
21   AnnotationFlag,
22   AnnotationReplyType,
23   AnnotationType,
24   assert,
25   BASELINE_FACTOR,
26   FeatureTest,
27   getModificationDate,
28   IDENTITY_MATRIX,
29   info,
30   isArrayEqual,
31   LINE_DESCENT_FACTOR,
32   LINE_FACTOR,
33   OPS,
34   RenderingIntentFlag,
35   shadow,
36   stringToPDFString,
37   unreachable,
38   Util,
39   warn,
40 } from "../shared/util.js";
41 import {
42   collectActions,
43   escapeString,
44   getInheritableProperty,
45   getParentToUpdate,
46   getRotationMatrix,
47   isNumberArray,
48   lookupMatrix,
49   lookupNormalRect,
50   lookupRect,
51   numberToString,
52   stringToAsciiOrUTF16BE,
53   stringToUTF16String,
54 } from "./core_utils.js";
55 import {
56   createDefaultAppearance,
57   FakeUnicodeFont,
58   getPdfColor,
59   parseAppearanceStream,
60   parseDefaultAppearance,
61 } from "./default_appearance.js";
62 import { Dict, isName, isRefsEqual, Name, Ref, RefSet } from "./primitives.js";
63 import { Stream, StringStream } from "./stream.js";
64 import { BaseStream } from "./base_stream.js";
65 import { bidi } from "./bidi.js";
66 import { Catalog } from "./catalog.js";
67 import { ColorSpace } from "./colorspace.js";
68 import { FileSpec } from "./file_spec.js";
69 import { JpegStream } from "./jpeg_stream.js";
70 import { ObjectLoader } from "./object_loader.js";
71 import { OperatorList } from "./operator_list.js";
72 import { XFAFactory } from "./xfa/factory.js";
73 
74 class AnnotationFactory {
75   static createGlobals(pdfManager) {
76     return Promise.all([
77       pdfManager.ensureCatalog("acroForm"),
78       pdfManager.ensureDoc("xfaDatasets"),
79       pdfManager.ensureCatalog("structTreeRoot"),
80       // Only necessary to prevent the `Catalog.baseUrl`-getter, used
81       // with some Annotations, from throwing and thus breaking parsing:
82       pdfManager.ensureCatalog("baseUrl"),
83       // Only necessary to prevent the `Catalog.attachments`-getter, used
84       // with "GoToE" actions, from throwing and thus breaking parsing:
85       pdfManager.ensureCatalog("attachments"),
86     ]).then(
87       // eslint-disable-next-line arrow-body-style
88       ([acroForm, xfaDatasets, structTreeRoot, baseUrl, attachments]) => {
89         return {
90           pdfManager,
91           acroForm: acroForm instanceof Dict ? acroForm : Dict.empty,
92           xfaDatasets,
93           structTreeRoot,
94           baseUrl,
95           attachments,
96         };
97       },
98       reason => {
99         warn(`createGlobals: "${reason}".`);
100         return null;
101       }
102     );
103   }
104 
105   /**
106    * Create an `Annotation` object of the correct type for the given reference
107    * to an annotation dictionary. This yields a promise that is resolved when
108    * the `Annotation` object is constructed.
109    *
110    * @param {XRef} xref
111    * @param {Object} ref
112    * @params {Object} annotationGlobals
113    * @param {Object} idFactory
114    * @param {boolean} [collectFields]
115    * @param {Object} [orphanFields]
116    * @param {Object} [pageRef]
117    * @returns {Promise} A promise that is resolved with an {Annotation}
118    *   instance.
119    */
120   static async create(
121     xref,
122     ref,
123     annotationGlobals,
124     idFactory,
125     collectFields,
126     orphanFields,
127     pageRef
128   ) {
129     const pageIndex = collectFields
130       ? await this._getPageIndex(xref, ref, annotationGlobals.pdfManager)
131       : null;
132 
133     return annotationGlobals.pdfManager.ensure(this, "_create", [
134       xref,
135       ref,
136       annotationGlobals,
137       idFactory,
138       collectFields,
139       orphanFields,
140       pageIndex,
141       pageRef,
142     ]);
143   }
144 
145   /**
146    * @private
147    */
148   static _create(
149     xref,
150     ref,
151     annotationGlobals,
152     idFactory,
153     collectFields = false,
154     orphanFields = null,
155     pageIndex = null,
156     pageRef = null
157   ) {
158     const dict = xref.fetchIfRef(ref);
159     if (!(dict instanceof Dict)) {
160       return undefined;
161     }
162 
163     const { acroForm, pdfManager } = annotationGlobals;
164     const id =
165       ref instanceof Ref ? ref.toString() : `annot_${idFactory.createObjId()}`;
166 
167     // Determine the annotation's subtype.
168     let subtype = dict.get("Subtype");
169     subtype = subtype instanceof Name ? subtype.name : null;
170 
171     // Return the right annotation object based on the subtype and field type.
172     const parameters = {
173       xref,
174       ref,
175       dict,
176       subtype,
177       id,
178       annotationGlobals,
179       collectFields,
180       orphanFields,
181       needAppearances:
182         !collectFields && acroForm.get("NeedAppearances") === true,
183       pageIndex,
184       evaluatorOptions: pdfManager.evaluatorOptions,
185       pageRef,
186     };
187 
188     switch (subtype) {
189       case "Link":
190         return new LinkAnnotation(parameters);
191 
192       case "Text":
193         return new TextAnnotation(parameters);
194 
195       case "Widget":
196         let fieldType = getInheritableProperty({ dict, key: "FT" });
197         fieldType = fieldType instanceof Name ? fieldType.name : null;
198 
199         switch (fieldType) {
200           case "Tx":
201             return new TextWidgetAnnotation(parameters);
202           case "Btn":
203             return new ButtonWidgetAnnotation(parameters);
204           case "Ch":
205             return new ChoiceWidgetAnnotation(parameters);
206           case "Sig":
207             return new SignatureWidgetAnnotation(parameters);
208         }
209         warn(
210           `Unimplemented widget field type "${fieldType}", ` +
211             "falling back to base field type."
212         );
213         return new WidgetAnnotation(parameters);
214 
215       case "Popup":
216         return new PopupAnnotation(parameters);
217 
218       case "FreeText":
219         return new FreeTextAnnotation(parameters);
220 
221       case "Line":
222         return new LineAnnotation(parameters);
223 
224       case "Square":
225         return new SquareAnnotation(parameters);
226 
227       case "Circle":
228         return new CircleAnnotation(parameters);
229 
230       case "PolyLine":
231         return new PolylineAnnotation(parameters);
232 
233       case "Polygon":
234         return new PolygonAnnotation(parameters);
235 
236       case "Caret":
237         return new CaretAnnotation(parameters);
238 
239       case "Ink":
240         return new InkAnnotation(parameters);
241 
242       case "Highlight":
243         return new HighlightAnnotation(parameters);
244 
245       case "Underline":
246         return new UnderlineAnnotation(parameters);
247 
248       case "Squiggly":
249         return new SquigglyAnnotation(parameters);
250 
251       case "StrikeOut":
252         return new StrikeOutAnnotation(parameters);
253 
254       case "Stamp":
255         return new StampAnnotation(parameters);
256 
257       case "FileAttachment":
258         return new FileAttachmentAnnotation(parameters);
259 
260       default:
261         if (!collectFields) {
262           if (!subtype) {
263             warn("Annotation is missing the required /Subtype.");
264           } else {
265             warn(
266               `Unimplemented annotation type "${subtype}", ` +
267                 "falling back to base annotation."
268             );
269           }
270         }
271         return new Annotation(parameters);
272     }
273   }
274 
275   static async _getPageIndex(xref, ref, pdfManager) {
276     try {
277       const annotDict = await xref.fetchIfRefAsync(ref);
278       if (!(annotDict instanceof Dict)) {
279         return -1;
280       }
281       const pageRef = annotDict.getRaw("P");
282       if (pageRef instanceof Ref) {
283         try {
284           const pageIndex = await pdfManager.ensureCatalog("getPageIndex", [
285             pageRef,
286           ]);
287           return pageIndex;
288         } catch (ex) {
289           info(`_getPageIndex -- not a valid page reference: "${ex}".`);
290         }
291       }
292       if (annotDict.has("Kids")) {
293         return -1; // Not an annotation reference.
294       }
295       // Fallback to, potentially, checking the annotations of all pages.
296       // PLEASE NOTE: This could force the *entire* PDF document to load,
297       //              hence it absolutely cannot be done unconditionally.
298       const numPages = await pdfManager.ensureDoc("numPages");
299 
300       for (let pageIndex = 0; pageIndex < numPages; pageIndex++) {
301         const page = await pdfManager.getPage(pageIndex);
302         const annotations = await pdfManager.ensure(page, "annotations");
303 
304         for (const annotRef of annotations) {
305           if (annotRef instanceof Ref && isRefsEqual(annotRef, ref)) {
306             return pageIndex;
307           }
308         }
309       }
310     } catch (ex) {
311       warn(`_getPageIndex: "${ex}".`);
312     }
313     return -1;
314   }
315 
316   static generateImages(annotations, xref, isOffscreenCanvasSupported) {
317     if (!isOffscreenCanvasSupported) {
318       warn(
319         "generateImages: OffscreenCanvas is not supported, cannot save or print some annotations with images."
320       );
321       return null;
322     }
323     let imagePromises;
324     for (const { bitmapId, bitmap } of annotations) {
325       if (!bitmap) {
326         continue;
327       }
328       imagePromises ||= new Map();
329       imagePromises.set(bitmapId, StampAnnotation.createImage(bitmap, xref));
330     }
331 
332     return imagePromises;
333   }
334 
335   static async saveNewAnnotations(
336     evaluator,
337     task,
338     annotations,
339     imagePromises,
340     changes
341   ) {
342     const xref = evaluator.xref;
343     let baseFontRef;
344     const promises = [];
345     const { isOffscreenCanvasSupported } = evaluator.options;
346 
347     for (const annotation of annotations) {
348       if (annotation.deleted) {
349         continue;
350       }
351       switch (annotation.annotationType) {
352         case AnnotationEditorType.FREETEXT:
353           if (!baseFontRef) {
354             const baseFont = new Dict(xref);
355             baseFont.set("BaseFont", Name.get("Helvetica"));
356             baseFont.set("Type", Name.get("Font"));
357             baseFont.set("Subtype", Name.get("Type1"));
358             baseFont.set("Encoding", Name.get("WinAnsiEncoding"));
359             baseFontRef = xref.getNewTemporaryRef();
360             changes.put(baseFontRef, {
361               data: baseFont,
362             });
363           }
364           promises.push(
365             FreeTextAnnotation.createNewAnnotation(xref, annotation, changes, {
366               evaluator,
367               task,
368               baseFontRef,
369             })
370           );
371           break;
372         case AnnotationEditorType.HIGHLIGHT:
373           if (annotation.quadPoints) {
374             promises.push(
375               HighlightAnnotation.createNewAnnotation(xref, annotation, changes)
376             );
377           } else {
378             promises.push(
379               InkAnnotation.createNewAnnotation(xref, annotation, changes)
380             );
381           }
382           break;
383         case AnnotationEditorType.INK:
384           promises.push(
385             InkAnnotation.createNewAnnotation(xref, annotation, changes)
386           );
387           break;
388         case AnnotationEditorType.STAMP:
389           const image = isOffscreenCanvasSupported
390             ? await imagePromises?.get(annotation.bitmapId)
391             : null;
392           if (image?.imageStream) {
393             const { imageStream, smaskStream } = image;
394             if (smaskStream) {
395               const smaskRef = xref.getNewTemporaryRef();
396               changes.put(smaskRef, {
397                 data: smaskStream,
398               });
399               imageStream.dict.set("SMask", smaskRef);
400             }
401             const imageRef = (image.imageRef = xref.getNewTemporaryRef());
402             changes.put(imageRef, {
403               data: imageStream,
404             });
405             image.imageStream = image.smaskStream = null;
406           }
407           promises.push(
408             StampAnnotation.createNewAnnotation(xref, annotation, changes, {
409               image,
410             })
411           );
412           break;
413       }
414     }
415 
416     return {
417       annotations: await Promise.all(promises),
418     };
419   }
420 
421   static async printNewAnnotations(
422     annotationGlobals,
423     evaluator,
424     task,
425     annotations,
426     imagePromises
427   ) {
428     if (!annotations) {
429       return null;
430     }
431 
432     const { options, xref } = evaluator;
433     const promises = [];
434     for (const annotation of annotations) {
435       if (annotation.deleted) {
436         continue;
437       }
438       switch (annotation.annotationType) {
439         case AnnotationEditorType.FREETEXT:
440           promises.push(
441             FreeTextAnnotation.createNewPrintAnnotation(
442               annotationGlobals,
443               xref,
444               annotation,
445               {
446                 evaluator,
447                 task,
448                 evaluatorOptions: options,
449               }
450             )
451           );
452           break;
453         case AnnotationEditorType.HIGHLIGHT:
454           if (annotation.quadPoints) {
455             promises.push(
456               HighlightAnnotation.createNewPrintAnnotation(
457                 annotationGlobals,
458                 xref,
459                 annotation,
460                 {
461                   evaluatorOptions: options,
462                 }
463               )
464             );
465           } else {
466             promises.push(
467               InkAnnotation.createNewPrintAnnotation(
468                 annotationGlobals,
469                 xref,
470                 annotation,
471                 {
472                   evaluatorOptions: options,
473                 }
474               )
475             );
476           }
477           break;
478         case AnnotationEditorType.INK:
479           promises.push(
480             InkAnnotation.createNewPrintAnnotation(
481               annotationGlobals,
482               xref,
483               annotation,
484               {
485                 evaluatorOptions: options,
486               }
487             )
488           );
489           break;
490         case AnnotationEditorType.STAMP:
491           const image = options.isOffscreenCanvasSupported
492             ? await imagePromises?.get(annotation.bitmapId)
493             : null;
494           if (image?.imageStream) {
495             const { imageStream, smaskStream } = image;
496             if (smaskStream) {
497               imageStream.dict.set("SMask", smaskStream);
498             }
499             image.imageRef = new JpegStream(imageStream, imageStream.length);
500             image.imageStream = image.smaskStream = null;
501           }
502           promises.push(
503             StampAnnotation.createNewPrintAnnotation(
504               annotationGlobals,
505               xref,
506               annotation,
507               {
508                 image,
509                 evaluatorOptions: options,
510               }
511             )
512           );
513           break;
514       }
515     }
516 
517     return Promise.all(promises);
518   }
519 }
520 
521 function getRgbColor(color, defaultColor = new Uint8ClampedArray(3)) {
522   if (!Array.isArray(color)) {
523     return defaultColor;
524   }
525 
526   const rgbColor = defaultColor || new Uint8ClampedArray(3);
527   switch (color.length) {
528     case 0: // Transparent, which we indicate with a null value
529       return null;
530 
531     case 1: // Convert grayscale to RGB
532       ColorSpace.singletons.gray.getRgbItem(color, 0, rgbColor, 0);
533       return rgbColor;
534 
535     case 3: // Convert RGB percentages to RGB
536       ColorSpace.singletons.rgb.getRgbItem(color, 0, rgbColor, 0);
537       return rgbColor;
538 
539     case 4: // Convert CMYK to RGB
540       ColorSpace.singletons.cmyk.getRgbItem(color, 0, rgbColor, 0);
541       return rgbColor;
542 
543     default:
544       return defaultColor;
545   }
546 }
547 
548 function getPdfColorArray(color) {
549   return Array.from(color, c => c / 255);
550 }
551 
552 function getQuadPoints(dict, rect) {
553   // The region is described as a number of quadrilaterals.
554   // Each quadrilateral must consist of eight coordinates.
555   const quadPoints = dict.getArray("QuadPoints");
556   if (
557     !isNumberArray(quadPoints, null) ||
558     quadPoints.length === 0 ||
559     quadPoints.length % 8 > 0
560   ) {
561     return null;
562   }
563 
564   const newQuadPoints = new Float32Array(quadPoints.length);
565   for (let i = 0, ii = quadPoints.length; i < ii; i += 8) {
566     // Each series of eight numbers represents the coordinates for one
567     // quadrilateral in the order [x1, y1, x2, y2, x3, y3, x4, y4].
568     // Convert this to an array of objects with x and y coordinates.
569     const [x1, y1, x2, y2, x3, y3, x4, y4] = quadPoints.slice(i, i + 8);
570     const minX = Math.min(x1, x2, x3, x4);
571     const maxX = Math.max(x1, x2, x3, x4);
572     const minY = Math.min(y1, y2, y3, y4);
573     const maxY = Math.max(y1, y2, y3, y4);
574     // The quadpoints should be ignored if any coordinate in the array
575     // lies outside the region specified by the rectangle. The rectangle
576     // can be `null` for markup annotations since their rectangle may be
577     // incorrect (fixes bug 1538111).
578     if (
579       rect !== null &&
580       (minX < rect[0] || maxX > rect[2] || minY < rect[1] || maxY > rect[3])
581     ) {
582       return null;
583     }
584     // The PDF specification states in section 12.5.6.10 (figure 64) that the
585     // order of the quadpoints should be bottom left, bottom right, top right
586     // and top left. However, in practice PDF files use a different order,
587     // namely bottom left, bottom right, top left and top right (this is also
588     // mentioned on https://github.com/highkite/pdfAnnotate#QuadPoints), so
589     // this is the actual order we should work with. However, the situation is
590     // even worse since Adobe's own applications and other applications violate
591     // the specification and create annotations with other orders, namely top
592     // left, top right, bottom left and bottom right or even top left,
593     // top right, bottom right and bottom left. To avoid inconsistency and
594     // broken rendering, we normalize all lists to put the quadpoints in the
595     // same standard order (see https://stackoverflow.com/a/10729881).
596     newQuadPoints.set([minX, maxY, maxX, maxY, minX, minY, maxX, minY], i);
597   }
598   return newQuadPoints;
599 }
600 
601 function getTransformMatrix(rect, bbox, matrix) {
602   // 12.5.5: Algorithm: Appearance streams
603   const [minX, minY, maxX, maxY] = Util.getAxialAlignedBoundingBox(
604     bbox,
605     matrix
606   );
607   if (minX === maxX || minY === maxY) {
608     // From real-life file, bbox was [0, 0, 0, 0]. In this case,
609     // just apply the transform for rect
610     return [1, 0, 0, 1, rect[0], rect[1]];
611   }
612 
613   const xRatio = (rect[2] - rect[0]) / (maxX - minX);
614   const yRatio = (rect[3] - rect[1]) / (maxY - minY);
615   return [
616     xRatio,
617     0,
618     0,
619     yRatio,
620     rect[0] - minX * xRatio,
621     rect[1] - minY * yRatio,
622   ];
623 }
624 
625 class Annotation {
626   constructor(params) {
627     const { dict, xref, annotationGlobals, ref, orphanFields } = params;
628     const parentRef = orphanFields?.get(ref);
629     if (parentRef) {
630       dict.set("Parent", parentRef);
631     }
632 
633     this.setTitle(dict.get("T"));
634     this.setContents(dict.get("Contents"));
635     this.setModificationDate(dict.get("M"));
636     this.setFlags(dict.get("F"));
637     this.setRectangle(dict.getArray("Rect"));
638     this.setColor(dict.getArray("C"));
639     this.setBorderStyle(dict);
640     this.setAppearance(dict);
641     this.setOptionalContent(dict);
642 
643     const MK = dict.get("MK");
644     this.setBorderAndBackgroundColors(MK);
645     this.setRotation(MK, dict);
646     this.ref = params.ref instanceof Ref ? params.ref : null;
647 
648     this._streams = [];
649     if (this.appearance) {
650       this._streams.push(this.appearance);
651     }
652 
653     // The annotation cannot be changed (neither its position/visibility nor its
654     // contents), hence we can just display its appearance and don't generate
655     // a HTML element for it.
656     const isLocked = !!(this.flags & AnnotationFlag.LOCKED);
657     const isContentLocked = !!(this.flags & AnnotationFlag.LOCKEDCONTENTS);
658 
659     // Expose public properties using a data object.
660     this.data = {
661       annotationFlags: this.flags,
662       borderStyle: this.borderStyle,
663       color: this.color,
664       backgroundColor: this.backgroundColor,
665       borderColor: this.borderColor,
666       rotation: this.rotation,
667       contentsObj: this._contents,
668       hasAppearance: !!this.appearance,
669       id: params.id,
670       modificationDate: this.modificationDate,
671       rect: this.rectangle,
672       subtype: params.subtype,
673       hasOwnCanvas: false,
674       noRotate: !!(this.flags & AnnotationFlag.NOROTATE),
675       noHTML: isLocked && isContentLocked,
676       isEditable: false,
677       structParent: -1,
678     };
679 
680     if (annotationGlobals.structTreeRoot) {
681       let structParent = dict.get("StructParent");
682       this.data.structParent = structParent =
683         Number.isInteger(structParent) && structParent >= 0 ? structParent : -1;
684 
685       annotationGlobals.structTreeRoot.addAnnotationIdToPage(
686         params.pageRef,
687         structParent
688       );
689     }
690 
691     if (params.collectFields) {
692       // Fields can act as container for other fields and have
693       // some actions even if no Annotation inherit from them.
694       // Those fields can be referenced by CO (calculation order).
695       const kids = dict.get("Kids");
696       if (Array.isArray(kids)) {
697         const kidIds = [];
698         for (const kid of kids) {
699           if (kid instanceof Ref) {
700             kidIds.push(kid.toString());
701           }
702         }
703         if (kidIds.length !== 0) {
704           this.data.kidIds = kidIds;
705         }
706       }
707 
708       this.data.actions = collectActions(xref, dict, AnnotationActionEventType);
709       this.data.fieldName = this._constructFieldName(dict);
710       this.data.pageIndex = params.pageIndex;
711     }
712 
713     const it = dict.get("IT");
714     if (it instanceof Name) {
715       this.data.it = it.name;
716     }
717 
718     this._isOffscreenCanvasSupported =
719       params.evaluatorOptions.isOffscreenCanvasSupported;
720     this._fallbackFontDict = null;
721     this._needAppearances = false;
722   }
723 
724   /**
725    * @private
726    */
727   _hasFlag(flags, flag) {
728     return !!(flags & flag);
729   }
730 
731   _buildFlags(noView, noPrint) {
732     let { flags } = this;
733     if (noView === undefined) {
734       if (noPrint === undefined) {
735         return undefined;
736       }
737       if (noPrint) {
738         return flags & ~AnnotationFlag.PRINT;
739       }
740       return (flags & ~AnnotationFlag.HIDDEN) | AnnotationFlag.PRINT;
741     }
742 
743     if (noView) {
744       flags |= AnnotationFlag.PRINT;
745       if (noPrint) {
746         // display === 1.
747         return (flags & ~AnnotationFlag.NOVIEW) | AnnotationFlag.HIDDEN;
748       }
749       // display === 3.
750       return (flags & ~AnnotationFlag.HIDDEN) | AnnotationFlag.NOVIEW;
751     }
752 
753     flags &= ~(AnnotationFlag.HIDDEN | AnnotationFlag.NOVIEW);
754     if (noPrint) {
755       // display === 2.
756       return flags & ~AnnotationFlag.PRINT;
757     }
758 
759     // display === 0.
760     return flags | AnnotationFlag.PRINT;
761   }
762 
763   /**
764    * @private
765    */
766   _isViewable(flags) {
767     return (
768       !this._hasFlag(flags, AnnotationFlag.INVISIBLE) &&
769       !this._hasFlag(flags, AnnotationFlag.NOVIEW)
770     );
771   }
772 
773   /**
774    * @private
775    */
776   _isPrintable(flags) {
777     // In Acrobat, hidden flag cancels the print one
778     // (see annotation_hidden_print.pdf).
779     return (
780       this._hasFlag(flags, AnnotationFlag.PRINT) &&
781       !this._hasFlag(flags, AnnotationFlag.HIDDEN) &&
782       !this._hasFlag(flags, AnnotationFlag.INVISIBLE)
783     );
784   }
785 
786   /**
787    * Check if the annotation must be displayed by taking into account
788    * the value found in the annotationStorage which may have been set
789    * through JS.
790    *
791    * @public
792    * @memberof Annotation
793    * @param {AnnotationStorage} [annotationStorage] - Storage for annotation
794    * @param {boolean} [_renderForms] - if true widgets are rendered thanks to
795    *                                   the annotation layer.
796    */
797   mustBeViewed(annotationStorage, _renderForms) {
798     const noView = annotationStorage?.get(this.data.id)?.noView;
799     if (noView !== undefined) {
800       return !noView;
801     }
802     return this.viewable && !this._hasFlag(this.flags, AnnotationFlag.HIDDEN);
803   }
804 
805   /**
806    * Check if the annotation must be printed by taking into account
807    * the value found in the annotationStorage which may have been set
808    * through JS.
809    *
810    * @public
811    * @memberof Annotation
812    * @param {AnnotationStorage} [annotationStorage] - Storage for annotation
813    */
814   mustBePrinted(annotationStorage) {
815     const noPrint = annotationStorage?.get(this.data.id)?.noPrint;
816     if (noPrint !== undefined) {
817       return !noPrint;
818     }
819     return this.printable;
820   }
821 
822   mustBeViewedWhenEditing(isEditing, modifiedIds = null) {
823     return isEditing ? !this.data.isEditable : !modifiedIds?.has(this.data.id);
824   }
825 
826   /**
827    * @type {boolean}
828    */
829   get viewable() {
830     if (this.data.quadPoints === null) {
831       return false;
832     }
833     if (this.flags === 0) {
834       return true;
835     }
836     return this._isViewable(this.flags);
837   }
838 
839   /**
840    * @type {boolean}
841    */
842   get printable() {
843     if (this.data.quadPoints === null) {
844       return false;
845     }
846     if (this.flags === 0) {
847       return false;
848     }
849     return this._isPrintable(this.flags);
850   }
851 
852   /**
853    * @private
854    */
855   _parseStringHelper(data) {
856     const str = typeof data === "string" ? stringToPDFString(data) : "";
857     const dir = str && bidi(str).dir === "rtl" ? "rtl" : "ltr";
858 
859     return { str, dir };
860   }
861 
862   setDefaultAppearance(params) {
863     const { dict, annotationGlobals } = params;
864 
865     const defaultAppearance =
866       getInheritableProperty({ dict, key: "DA" }) ||
867       annotationGlobals.acroForm.get("DA");
868     this._defaultAppearance =
869       typeof defaultAppearance === "string" ? defaultAppearance : "";
870     this.data.defaultAppearanceData = parseDefaultAppearance(
871       this._defaultAppearance
872     );
873   }
874 
875   /**
876    * Set the title.
877    *
878    * @param {string} title - The title of the annotation, used e.g. with
879    *   PopupAnnotations.
880    */
881   setTitle(title) {
882     this._title = this._parseStringHelper(title);
883   }
884 
885   /**
886    * Set the contents.
887    *
888    * @param {string} contents - Text to display for the annotation or, if the
889    *                            type of annotation does not display text, a
890    *                            description of the annotation's contents
891    */
892   setContents(contents) {
893     this._contents = this._parseStringHelper(contents);
894   }
895 
896   /**
897    * Set the modification date.
898    *
899    * @public
900    * @memberof Annotation
901    * @param {string} modificationDate - PDF date string that indicates when the
902    *                                    annotation was last modified
903    */
904   setModificationDate(modificationDate) {
905     this.modificationDate =
906       typeof modificationDate === "string" ? modificationDate : null;
907   }
908 
909   /**
910    * Set the flags.
911    *
912    * @public
913    * @memberof Annotation
914    * @param {number} flags - Unsigned 32-bit integer specifying annotation
915    *                         characteristics
916    * @see {@link shared/util.js}
917    */
918   setFlags(flags) {
919     this.flags = Number.isInteger(flags) && flags > 0 ? flags : 0;
920     if (
921       this.flags & AnnotationFlag.INVISIBLE &&
922       this.constructor.name !== "Annotation"
923     ) {
924       // From the pdf spec v1.7, section 12.5.3 (Annotation Flags):
925       //   If set, do not display the annotation if it does not belong to one of
926       //   the standard annotation types and no annotation handler is available.
927       //
928       // So we can remove the flag in case we have a known annotation type.
929       this.flags ^= AnnotationFlag.INVISIBLE;
930     }
931   }
932 
933   /**
934    * Check if a provided flag is set.
935    *
936    * @public
937    * @memberof Annotation
938    * @param {number} flag - Hexadecimal representation for an annotation
939    *                        characteristic
940    * @returns {boolean}
941    * @see {@link shared/util.js}
942    */
943   hasFlag(flag) {
944     return this._hasFlag(this.flags, flag);
945   }
946 
947   /**
948    * Set the rectangle.
949    *
950    * @public
951    * @memberof Annotation
952    * @param {Array} rectangle - The rectangle array with exactly four entries
953    */
954   setRectangle(rectangle) {
955     this.rectangle = lookupNormalRect(rectangle, [0, 0, 0, 0]);
956   }
957 
958   /**
959    * Set the color and take care of color space conversion.
960    * The default value is black, in RGB color space.
961    *
962    * @public
963    * @memberof Annotation
964    * @param {Array} color - The color array containing either 0
965    *                        (transparent), 1 (grayscale), 3 (RGB) or
966    *                        4 (CMYK) elements
967    */
968   setColor(color) {
969     this.color = getRgbColor(color);
970   }
971 
972   /**
973    * Set the line endings; should only be used with specific annotation types.
974    * @param {Array} lineEndings - The line endings array.
975    */
976   setLineEndings(lineEndings) {
977     if (typeof PDFJSDev !== "undefined" && PDFJSDev.test("MOZCENTRAL")) {
978       throw new Error("Not implemented: setLineEndings");
979     }
980     this.lineEndings = ["None", "None"]; // The default values.
981 
982     if (Array.isArray(lineEndings) && lineEndings.length === 2) {
983       for (let i = 0; i < 2; i++) {
984         const obj = lineEndings[i];
985 
986         if (obj instanceof Name) {
987           switch (obj.name) {
988             case "None":
989               continue;
990             case "Square":
991             case "Circle":
992             case "Diamond":
993             case "OpenArrow":
994             case "ClosedArrow":
995             case "Butt":
996             case "ROpenArrow":
997             case "RClosedArrow":
998             case "Slash":
999               this.lineEndings[i] = obj.name;
1000               continue;
1001           }
1002         }
1003         warn(`Ignoring invalid lineEnding: ${obj}`);
1004       }
1005     }
1006   }
1007 
1008   setRotation(mk, dict) {
1009     this.rotation = 0;
1010     let angle = mk instanceof Dict ? mk.get("R") || 0 : dict.get("Rotate") || 0;
1011     if (Number.isInteger(angle) && angle !== 0) {
1012       angle %= 360;
1013       if (angle < 0) {
1014         angle += 360;
1015       }
1016       if (angle % 90 === 0) {
1017         this.rotation = angle;
1018       }
1019     }
1020   }
1021 
1022   /**
1023    * Set the color for background and border if any.
1024    * The default values are transparent.
1025    *
1026    * @public
1027    * @memberof Annotation
1028    * @param {Dict} mk - The MK dictionary
1029    */
1030   setBorderAndBackgroundColors(mk) {
1031     if (mk instanceof Dict) {
1032       this.borderColor = getRgbColor(mk.getArray("BC"), null);
1033       this.backgroundColor = getRgbColor(mk.getArray("BG"), null);
1034     } else {
1035       this.borderColor = this.backgroundColor = null;
1036     }
1037   }
1038 
1039   /**
1040    * Set the border style (as AnnotationBorderStyle object).
1041    *
1042    * @public
1043    * @memberof Annotation
1044    * @param {Dict} borderStyle - The border style dictionary
1045    */
1046   setBorderStyle(borderStyle) {
1047     if (typeof PDFJSDev === "undefined" || PDFJSDev.test("TESTING")) {
1048       assert(this.rectangle, "setRectangle must have been called previously.");
1049     }
1050 
1051     this.borderStyle = new AnnotationBorderStyle();
1052     if (!(borderStyle instanceof Dict)) {
1053       return;
1054     }
1055     if (borderStyle.has("BS")) {
1056       const dict = borderStyle.get("BS");
1057 
1058       if (dict instanceof Dict) {
1059         const dictType = dict.get("Type");
1060 
1061         if (!dictType || isName(dictType, "Border")) {
1062           this.borderStyle.setWidth(dict.get("W"), this.rectangle);
1063           this.borderStyle.setStyle(dict.get("S"));
1064           this.borderStyle.setDashArray(dict.getArray("D"));
1065         }
1066       }
1067     } else if (borderStyle.has("Border")) {
1068       const array = borderStyle.getArray("Border");
1069       if (Array.isArray(array) && array.length >= 3) {
1070         this.borderStyle.setHorizontalCornerRadius(array[0]);
1071         this.borderStyle.setVerticalCornerRadius(array[1]);
1072         this.borderStyle.setWidth(array[2], this.rectangle);
1073 
1074         if (array.length === 4) {
1075           // Dash array available
1076           this.borderStyle.setDashArray(array[3], /* forceStyle = */ true);
1077         }
1078       }
1079     } else {
1080       // There are no border entries in the dictionary. According to the
1081       // specification, we should draw a solid border of width 1 in that
1082       // case, but Adobe Reader did not implement that part of the
1083       // specification and instead draws no border at all, so we do the same.
1084       // See also https://github.com/mozilla/pdf.js/issues/6179.
1085       this.borderStyle.setWidth(0);
1086     }
1087   }
1088 
1089   /**
1090    * Set the (normal) appearance.
1091    *
1092    * @public
1093    * @memberof Annotation
1094    * @param {Dict} dict - The annotation's data dictionary
1095    */
1096   setAppearance(dict) {
1097     this.appearance = null;
1098 
1099     const appearanceStates = dict.get("AP");
1100     if (!(appearanceStates instanceof Dict)) {
1101       return;
1102     }
1103 
1104     // In case the normal appearance is a stream, then it is used directly.
1105     const normalAppearanceState = appearanceStates.get("N");
1106     if (normalAppearanceState instanceof BaseStream) {
1107       this.appearance = normalAppearanceState;
1108       return;
1109     }
1110     if (!(normalAppearanceState instanceof Dict)) {
1111       return;
1112     }
1113 
1114     // In case the normal appearance is a dictionary, the `AS` entry provides
1115     // the key of the stream in this dictionary.
1116     const as = dict.get("AS");
1117     if (!(as instanceof Name) || !normalAppearanceState.has(as.name)) {
1118       return;
1119     }
1120     const appearance = normalAppearanceState.get(as.name);
1121     if (appearance instanceof BaseStream) {
1122       this.appearance = appearance;
1123     }
1124   }
1125 
1126   setOptionalContent(dict) {
1127     this.oc = null;
1128 
1129     const oc = dict.get("OC");
1130     if (oc instanceof Name) {
1131       warn("setOptionalContent: Support for /Name-entry is not implemented.");
1132     } else if (oc instanceof Dict) {
1133       this.oc = oc;
1134     }
1135   }
1136 
1137   loadResources(keys, appearance) {
1138     return appearance.dict.getAsync("Resources").then(resources => {
1139       if (!resources) {
1140         return undefined;
1141       }
1142 
1143       const objectLoader = new ObjectLoader(resources, keys, resources.xref);
1144       return objectLoader.load().then(function () {
1145         return resources;
1146       });
1147     });
1148   }
1149 
1150   async getOperatorList(evaluator, task, intent, annotationStorage) {
1151     const { hasOwnCanvas, id, rect } = this.data;
1152     let appearance = this.appearance;
1153     const isUsingOwnCanvas = !!(
1154       hasOwnCanvas && intent & RenderingIntentFlag.DISPLAY
1155     );
1156     if (isUsingOwnCanvas && (rect[0] === rect[2] || rect[1] === rect[3])) {
1157       // Empty annotation, don't draw anything.
1158       this.data.hasOwnCanvas = false;
1159       return {
1160         opList: new OperatorList(),
1161         separateForm: false,
1162         separateCanvas: false,
1163       };
1164     }
1165     if (!appearance) {
1166       if (!isUsingOwnCanvas) {
1167         return {
1168           opList: new OperatorList(),
1169           separateForm: false,
1170           separateCanvas: false,
1171         };
1172       }
1173       appearance = new StringStream("");
1174       appearance.dict = new Dict();
1175     }
1176 
1177     const appearanceDict = appearance.dict;
1178     const resources = await this.loadResources(
1179       ["ExtGState", "ColorSpace", "Pattern", "Shading", "XObject", "Font"],
1180       appearance
1181     );
1182     const bbox = lookupRect(appearanceDict.getArray("BBox"), [0, 0, 1, 1]);
1183     const matrix = lookupMatrix(
1184       appearanceDict.getArray("Matrix"),
1185       IDENTITY_MATRIX
1186     );
1187     const transform = getTransformMatrix(rect, bbox, matrix);
1188 
1189     const opList = new OperatorList();
1190 
1191     let optionalContent;
1192     if (this.oc) {
1193       optionalContent = await evaluator.parseMarkedContentProps(
1194         this.oc,
1195         /* resources = */ null
1196       );
1197     }
1198     if (optionalContent !== undefined) {
1199       opList.addOp(OPS.beginMarkedContentProps, ["OC", optionalContent]);
1200     }
1201 
1202     opList.addOp(OPS.beginAnnotation, [
1203       id,
1204       rect,
1205       transform,
1206       matrix,
1207       isUsingOwnCanvas,
1208     ]);
1209 
1210     await evaluator.getOperatorList({
1211       stream: appearance,
1212       task,
1213       resources,
1214       operatorList: opList,
1215       fallbackFontDict: this._fallbackFontDict,
1216     });
1217     opList.addOp(OPS.endAnnotation, []);
1218 
1219     if (optionalContent !== undefined) {
1220       opList.addOp(OPS.endMarkedContent, []);
1221     }
1222     this.reset();
1223     return { opList, separateForm: false, separateCanvas: isUsingOwnCanvas };
1224   }
1225 
1226   async save(evaluator, task, annotationStorage, changes) {
1227     return null;
1228   }
1229 
1230   get hasTextContent() {
1231     return false;
1232   }
1233 
1234   async extractTextContent(evaluator, task, viewBox) {
1235     if (!this.appearance) {
1236       return;
1237     }
1238 
1239     const resources = await this.loadResources(
1240       ["ExtGState", "Font", "Properties", "XObject"],
1241       this.appearance
1242     );
1243 
1244     const text = [];
1245     const buffer = [];
1246     let firstPosition = null;
1247     const sink = {
1248       desiredSize: Math.Infinity,
1249       ready: true,
1250 
1251       enqueue(chunk, size) {
1252         for (const item of chunk.items) {
1253           if (item.str === undefined) {
1254             continue;
1255           }
1256           firstPosition ||= item.transform.slice(-2);
1257           buffer.push(item.str);
1258           if (item.hasEOL) {
1259             text.push(buffer.join("").trimEnd());
1260             buffer.length = 0;
1261           }
1262         }
1263       },
1264     };
1265 
1266     await evaluator.getTextContent({
1267       stream: this.appearance,
1268       task,
1269       resources,
1270       includeMarkedContent: true,
1271       keepWhiteSpace: true,
1272       sink,
1273       viewBox,
1274     });
1275     this.reset();
1276 
1277     if (buffer.length) {
1278       text.push(buffer.join("").trimEnd());
1279     }
1280 
1281     if (text.length > 1 || text[0]) {
1282       const appearanceDict = this.appearance.dict;
1283       const bbox = lookupRect(appearanceDict.getArray("BBox"), null);
1284       const matrix = lookupMatrix(appearanceDict.getArray("Matrix"), null);
1285 
1286       this.data.textPosition = this._transformPoint(
1287         firstPosition,
1288         bbox,
1289         matrix
1290       );
1291       this.data.textContent = text;
1292     }
1293   }
1294 
1295   _transformPoint(coords, bbox, matrix) {
1296     const { rect } = this.data;
1297     bbox ||= [0, 0, 1, 1];
1298     matrix ||= [1, 0, 0, 1, 0, 0];
1299     const transform = getTransformMatrix(rect, bbox, matrix);
1300     transform[4] -= rect[0];
1301     transform[5] -= rect[1];
1302     coords = Util.applyTransform(coords, transform);
1303     return Util.applyTransform(coords, matrix);
1304   }
1305 
1306   /**
1307    * Get field data for usage in JS sandbox.
1308    *
1309    * Field object is defined here:
1310    * https://www.adobe.com/content/dam/acom/en/devnet/acrobat/pdfs/js_api_reference.pdf#page=16
1311    *
1312    * @public
1313    * @memberof Annotation
1314    * @returns {Object | null}
1315    */
1316   getFieldObject() {
1317     if (this.data.kidIds) {
1318       return {
1319         id: this.data.id,
1320         actions: this.data.actions,
1321         name: this.data.fieldName,
1322         strokeColor: this.data.borderColor,
1323         fillColor: this.data.backgroundColor,
1324         type: "",
1325         kidIds: this.data.kidIds,
1326         page: this.data.pageIndex,
1327         rotation: this.rotation,
1328       };
1329     }
1330     return null;
1331   }
1332 
1333   /**
1334    * Reset the annotation.
1335    *
1336    * This involves resetting the various streams that are either cached on the
1337    * annotation instance or created during its construction.
1338    *
1339    * @public
1340    * @memberof Annotation
1341    */
1342   reset() {
1343     if (
1344       (typeof PDFJSDev === "undefined" || PDFJSDev.test("TESTING")) &&
1345       this.appearance &&
1346       !this._streams.includes(this.appearance)
1347     ) {
1348       unreachable("The appearance stream should always be reset.");
1349     }
1350 
1351     for (const stream of this._streams) {
1352       stream.reset();
1353     }
1354   }
1355 
1356   /**
1357    * Construct the (fully qualified) field name from the (partial) field
1358    * names of the field and its ancestors.
1359    *
1360    * @private
1361    * @memberof Annotation
1362    * @param {Dict} dict - Complete widget annotation dictionary
1363    * @returns {string}
1364    */
1365   _constructFieldName(dict) {
1366     // Both the `Parent` and `T` fields are optional. While at least one of
1367     // them should be provided, bad PDF generators may fail to do so.
1368     if (!dict.has("T") && !dict.has("Parent")) {
1369       warn("Unknown field name, falling back to empty field name.");
1370       return "";
1371     }
1372 
1373     // If no parent exists, the partial and fully qualified names are equal.
1374     if (!dict.has("Parent")) {
1375       return stringToPDFString(dict.get("T"));
1376     }
1377 
1378     // Form the fully qualified field name by appending the partial name to
1379     // the parent's fully qualified name, separated by a period.
1380     const fieldName = [];
1381     if (dict.has("T")) {
1382       fieldName.unshift(stringToPDFString(dict.get("T")));
1383     }
1384 
1385     let loopDict = dict;
1386     const visited = new RefSet();
1387     if (dict.objId) {
1388       visited.put(dict.objId);
1389     }
1390     while (loopDict.has("Parent")) {
1391       loopDict = loopDict.get("Parent");
1392       if (
1393         !(loopDict instanceof Dict) ||
1394         (loopDict.objId && visited.has(loopDict.objId))
1395       ) {
1396         // Even though it is not allowed according to the PDF specification,
1397         // bad PDF generators may provide a `Parent` entry that is not a
1398         // dictionary, but `null` for example (issue 8143).
1399         //
1400         // If parent has been already visited, it means that we're
1401         // in an infinite loop.
1402         break;
1403       }
1404       if (loopDict.objId) {
1405         visited.put(loopDict.objId);
1406       }
1407 
1408       if (loopDict.has("T")) {
1409         fieldName.unshift(stringToPDFString(loopDict.get("T")));
1410       }
1411     }
1412     return fieldName.join(".");
1413   }
1414 }
1415 
1416 /**
1417  * Contains all data regarding an annotation's border style.
1418  */
1419 class AnnotationBorderStyle {
1420   constructor() {
1421     this.width = 1;
1422     this.rawWidth = 1;
1423     this.style = AnnotationBorderStyleType.SOLID;
1424     this.dashArray = [3];
1425     this.horizontalCornerRadius = 0;
1426     this.verticalCornerRadius = 0;
1427   }
1428 
1429   /**
1430    * Set the width.
1431    *
1432    * @public
1433    * @memberof AnnotationBorderStyle
1434    * @param {number} width - The width.
1435    * @param {Array} rect - The annotation `Rect` entry.
1436    */
1437   setWidth(width, rect = [0, 0, 0, 0]) {
1438     if (typeof PDFJSDev === "undefined" || PDFJSDev.test("TESTING")) {
1439       assert(
1440         isNumberArray(rect, 4),
1441         "A valid `rect` parameter must be provided."
1442       );
1443     }
1444 
1445     // Some corrupt PDF generators may provide the width as a `Name`,
1446     // rather than as a number (fixes issue 10385).
1447     if (width instanceof Name) {
1448       this.width = 0; // This is consistent with the behaviour in Adobe Reader.
1449       return;
1450     }
1451     if (typeof width === "number") {
1452       if (width > 0) {
1453         this.rawWidth = width;
1454         const maxWidth = (rect[2] - rect[0]) / 2;
1455         const maxHeight = (rect[3] - rect[1]) / 2;
1456 
1457         // Ignore large `width`s, since they lead to the Annotation overflowing
1458         // the size set by the `Rect` entry thus causing the `annotationLayer`
1459         // to render it over the surrounding document (fixes bug1552113.pdf).
1460         if (
1461           maxWidth > 0 &&
1462           maxHeight > 0 &&
1463           (width > maxWidth || width > maxHeight)
1464         ) {
1465           warn(`AnnotationBorderStyle.setWidth - ignoring width: ${width}`);
1466           width = 1;
1467         }
1468       }
1469       this.width = width;
1470     }
1471   }
1472 
1473   /**
1474    * Set the style.
1475    *
1476    * @public
1477    * @memberof AnnotationBorderStyle
1478    * @param {Name} style - The annotation style.
1479    * @see {@link shared/util.js}
1480    */
1481   setStyle(style) {
1482     if (!(style instanceof Name)) {
1483       return;
1484     }
1485     switch (style.name) {
1486       case "S":
1487         this.style = AnnotationBorderStyleType.SOLID;
1488         break;
1489 
1490       case "D":
1491         this.style = AnnotationBorderStyleType.DASHED;
1492         break;
1493 
1494       case "B":
1495         this.style = AnnotationBorderStyleType.BEVELED;
1496         break;
1497 
1498       case "I":
1499         this.style = AnnotationBorderStyleType.INSET;
1500         break;
1501 
1502       case "U":
1503         this.style = AnnotationBorderStyleType.UNDERLINE;
1504         break;
1505 
1506       default:
1507         break;
1508     }
1509   }
1510 
1511   /**
1512    * Set the dash array.
1513    *
1514    * @public
1515    * @memberof AnnotationBorderStyle
1516    * @param {Array} dashArray - The dash array with at least one element
1517    * @param {boolean} [forceStyle]
1518    */
1519   setDashArray(dashArray, forceStyle = false) {
1520     // We validate the dash array, but we do not use it because CSS does not
1521     // allow us to change spacing of dashes. For more information, visit
1522     // http://www.w3.org/TR/css3-background/#the-border-style.
1523     if (Array.isArray(dashArray)) {
1524       // The PDF specification states that elements in the dash array, if
1525       // present, must be non-negative numbers and must not all equal zero.
1526       let isValid = true;
1527       let allZeros = true;
1528       for (const element of dashArray) {
1529         const validNumber = +element >= 0;
1530         if (!validNumber) {
1531           isValid = false;
1532           break;
1533         } else if (element > 0) {
1534           allZeros = false;
1535         }
1536       }
1537       if (dashArray.length === 0 || (isValid && !allZeros)) {
1538         this.dashArray = dashArray;
1539 
1540         if (forceStyle) {
1541           // Even though we cannot use the dash array in the display layer,
1542           // at least ensure that we use the correct border-style.
1543           this.setStyle(Name.get("D"));
1544         }
1545       } else {
1546         this.width = 0; // Adobe behavior when the array is invalid.
1547       }
1548     } else if (dashArray) {
1549       this.width = 0; // Adobe behavior when the array is invalid.
1550     }
1551   }
1552 
1553   /**
1554    * Set the horizontal corner radius (from a Border dictionary).
1555    *
1556    * @public
1557    * @memberof AnnotationBorderStyle
1558    * @param {number} radius - The horizontal corner radius.
1559    */
1560   setHorizontalCornerRadius(radius) {
1561     if (Number.isInteger(radius)) {
1562       this.horizontalCornerRadius = radius;
1563     }
1564   }
1565 
1566   /**
1567    * Set the vertical corner radius (from a Border dictionary).
1568    *
1569    * @public
1570    * @memberof AnnotationBorderStyle
1571    * @param {number} radius - The vertical corner radius.
1572    */
1573   setVerticalCornerRadius(radius) {
1574     if (Number.isInteger(radius)) {
1575       this.verticalCornerRadius = radius;
1576     }
1577   }
1578 }
1579 
1580 class MarkupAnnotation extends Annotation {
1581   constructor(params) {
1582     super(params);
1583 
1584     const { dict } = params;
1585 
1586     if (dict.has("IRT")) {
1587       const rawIRT = dict.getRaw("IRT");
1588       this.data.inReplyTo = rawIRT instanceof Ref ? rawIRT.toString() : null;
1589 
1590       const rt = dict.get("RT");
1591       this.data.replyType =
1592         rt instanceof Name ? rt.name : AnnotationReplyType.REPLY;
1593     }
1594     let popupRef = null;
1595 
1596     if (this.data.replyType === AnnotationReplyType.GROUP) {
1597       // Subordinate annotations in a group should inherit
1598       // the group attributes from the primary annotation.
1599       const parent = dict.get("IRT");
1600 
1601       this.setTitle(parent.get("T"));
1602       this.data.titleObj = this._title;
1603 
1604       this.setContents(parent.get("Contents"));
1605       this.data.contentsObj = this._contents;
1606 
1607       if (!parent.has("CreationDate")) {
1608         this.data.creationDate = null;
1609       } else {
1610         this.setCreationDate(parent.get("CreationDate"));
1611         this.data.creationDate = this.creationDate;
1612       }
1613 
1614       if (!parent.has("M")) {
1615         this.data.modificationDate = null;
1616       } else {
1617         this.setModificationDate(parent.get("M"));
1618         this.data.modificationDate = this.modificationDate;
1619       }
1620 
1621       popupRef = parent.getRaw("Popup");
1622 
1623       if (!parent.has("C")) {
1624         // Fall back to the default background color.
1625         this.data.color = null;
1626       } else {
1627         this.setColor(parent.getArray("C"));
1628         this.data.color = this.color;
1629       }
1630     } else {
1631       this.data.titleObj = this._title;
1632 
1633       this.setCreationDate(dict.get("CreationDate"));
1634       this.data.creationDate = this.creationDate;
1635 
1636       popupRef = dict.getRaw("Popup");
1637 
1638       if (!dict.has("C")) {
1639         // Fall back to the default background color.
1640         this.data.color = null;
1641       }
1642     }
1643 
1644     this.data.popupRef = popupRef instanceof Ref ? popupRef.toString() : null;
1645 
1646     if (dict.has("RC")) {
1647       this.data.richText = XFAFactory.getRichTextAsHtml(dict.get("RC"));
1648     }
1649   }
1650 
1651   /**
1652    * Set the creation date.
1653    *
1654    * @public
1655    * @memberof MarkupAnnotation
1656    * @param {string} creationDate - PDF date string that indicates when the
1657    *                                annotation was originally created
1658    */
1659   setCreationDate(creationDate) {
1660     this.creationDate = typeof creationDate === "string" ? creationDate : null;
1661   }
1662 
1663   _setDefaultAppearance({
1664     xref,
1665     extra,
1666     strokeColor,
1667     fillColor,
1668     blendMode,
1669     strokeAlpha,
1670     fillAlpha,
1671     pointsCallback,
1672   }) {
1673     let minX = Number.MAX_VALUE;
1674     let minY = Number.MAX_VALUE;
1675     let maxX = Number.MIN_VALUE;
1676     let maxY = Number.MIN_VALUE;
1677 
1678     const buffer = ["q"];
1679     if (extra) {
1680       buffer.push(extra);
1681     }
1682     if (strokeColor) {
1683       buffer.push(`${strokeColor[0]} ${strokeColor[1]} ${strokeColor[2]} RG`);
1684     }
1685     if (fillColor) {
1686       buffer.push(`${fillColor[0]} ${fillColor[1]} ${fillColor[2]} rg`);
1687     }
1688 
1689     // If there are no quadpoints, the rectangle should be used instead.
1690     // Convert the rectangle definition to a points array similar to how the
1691     // quadpoints are defined.
1692     const pointsArray =
1693       this.data.quadPoints ||
1694       Float32Array.from([
1695         this.rectangle[0],
1696         this.rectangle[3],
1697         this.rectangle[2],
1698         this.rectangle[3],
1699         this.rectangle[0],
1700         this.rectangle[1],
1701         this.rectangle[2],
1702         this.rectangle[1],
1703       ]);
1704 
1705     for (let i = 0, ii = pointsArray.length; i < ii; i += 8) {
1706       const [mX, MX, mY, MY] = pointsCallback(
1707         buffer,
1708         pointsArray.subarray(i, i + 8)
1709       );
1710       minX = Math.min(minX, mX);
1711       maxX = Math.max(maxX, MX);
1712       minY = Math.min(minY, mY);
1713       maxY = Math.max(maxY, MY);
1714     }
1715     buffer.push("Q");
1716 
1717     const formDict = new Dict(xref);
1718     const appearanceStreamDict = new Dict(xref);
1719     appearanceStreamDict.set("Subtype", Name.get("Form"));
1720 
1721     const appearanceStream = new StringStream(buffer.join(" "));
1722     appearanceStream.dict = appearanceStreamDict;
1723     formDict.set("Fm0", appearanceStream);
1724 
1725     const gsDict = new Dict(xref);
1726     if (blendMode) {
1727       gsDict.set("BM", Name.get(blendMode));
1728     }
1729     if (typeof strokeAlpha === "number") {
1730       gsDict.set("CA", strokeAlpha);
1731     }
1732     if (typeof fillAlpha === "number") {
1733       gsDict.set("ca", fillAlpha);
1734     }
1735 
1736     const stateDict = new Dict(xref);
1737     stateDict.set("GS0", gsDict);
1738 
1739     const resources = new Dict(xref);
1740     resources.set("ExtGState", stateDict);
1741     resources.set("XObject", formDict);
1742 
1743     const appearanceDict = new Dict(xref);
1744     appearanceDict.set("Resources", resources);
1745     const bbox = (this.data.rect = [minX, minY, maxX, maxY]);
1746     appearanceDict.set("BBox", bbox);
1747 
1748     this.appearance = new StringStream("/GS0 gs /Fm0 Do");
1749     this.appearance.dict = appearanceDict;
1750 
1751     // This method is only called if there is no appearance for the annotation,
1752     // so `this.appearance` is not pushed yet in the `Annotation` constructor.
1753     this._streams.push(this.appearance, appearanceStream);
1754   }
1755 
1756   static async createNewAnnotation(xref, annotation, changes, params) {
1757     const annotationRef = (annotation.ref ||= xref.getNewTemporaryRef());
1758 
1759     const ap = await this.createNewAppearanceStream(annotation, xref, params);
1760     let annotationDict;
1761 
1762     if (ap) {
1763       const apRef = xref.getNewTemporaryRef();
1764       annotationDict = this.createNewDict(annotation, xref, {
1765         apRef,
1766       });
1767       changes.put(apRef, {
1768         data: ap,
1769       });
1770     } else {
1771       annotationDict = this.createNewDict(annotation, xref, {});
1772     }
1773     if (Number.isInteger(annotation.parentTreeId)) {
1774       annotationDict.set("StructParent", annotation.parentTreeId);
1775     }
1776 
1777     changes.put(annotationRef, {
1778       data: annotationDict,
1779     });
1780 
1781     return { ref: annotationRef };
1782   }
1783 
1784   static async createNewPrintAnnotation(
1785     annotationGlobals,
1786     xref,
1787     annotation,
1788     params
1789   ) {
1790     const ap = await this.createNewAppearanceStream(annotation, xref, params);
1791     const annotationDict = this.createNewDict(
1792       annotation,
1793       xref,
1794       ap ? { ap } : {}
1795     );
1796 
1797     const newAnnotation = new this.prototype.constructor({
1798       dict: annotationDict,
1799       xref,
1800       annotationGlobals,
1801       evaluatorOptions: params.evaluatorOptions,
1802     });
1803 
1804     if (annotation.ref) {
1805       newAnnotation.ref = newAnnotation.refToReplace = annotation.ref;
1806     }
1807 
1808     return newAnnotation;
1809   }
1810 }
1811 
1812 class WidgetAnnotation extends Annotation {
1813   constructor(params) {
1814     super(params);
1815 
1816     const { dict, xref, annotationGlobals } = params;
1817     const data = this.data;
1818     this._needAppearances = params.needAppearances;
1819 
1820     data.annotationType = AnnotationType.WIDGET;
1821     if (data.fieldName === undefined) {
1822       data.fieldName = this._constructFieldName(dict);
1823     }
1824 
1825     if (data.actions === undefined) {
1826       data.actions = collectActions(xref, dict, AnnotationActionEventType);
1827     }
1828 
1829     let fieldValue = getInheritableProperty({
1830       dict,
1831       key: "V",
1832       getArray: true,
1833     });
1834     data.fieldValue = this._decodeFormValue(fieldValue);
1835 
1836     const defaultFieldValue = getInheritableProperty({
1837       dict,
1838       key: "DV",
1839       getArray: true,
1840     });
1841     data.defaultFieldValue = this._decodeFormValue(defaultFieldValue);
1842 
1843     if (fieldValue === undefined && annotationGlobals.xfaDatasets) {
1844       // Try to figure out if we have something in the xfa dataset.
1845       const path = this._title.str;
1846       if (path) {
1847         this._hasValueFromXFA = true;
1848         data.fieldValue = fieldValue =
1849           annotationGlobals.xfaDatasets.getValue(path);
1850       }
1851     }
1852 
1853     // When no "V" entry exists, let the fieldValue fallback to the "DV" entry
1854     // (fixes issue13823.pdf).
1855     if (fieldValue === undefined && data.defaultFieldValue !== null) {
1856       data.fieldValue = data.defaultFieldValue;
1857     }
1858 
1859     data.alternativeText = stringToPDFString(dict.get("TU") || "");
1860 
1861     this.setDefaultAppearance(params);
1862 
1863     data.hasAppearance ||=
1864       this._needAppearances &&
1865       data.fieldValue !== undefined &&
1866       data.fieldValue !== null;
1867 
1868     const fieldType = getInheritableProperty({ dict, key: "FT" });
1869     data.fieldType = fieldType instanceof Name ? fieldType.name : null;
1870 
1871     const localResources = getInheritableProperty({ dict, key: "DR" });
1872     const acroFormResources = annotationGlobals.acroForm.get("DR");
1873     const appearanceResources = this.appearance?.dict.get("Resources");
1874 
1875     this._fieldResources = {
1876       localResources,
1877       acroFormResources,
1878       appearanceResources,
1879       mergedResources: Dict.merge({
1880         xref,
1881         dictArray: [localResources, appearanceResources, acroFormResources],
1882         mergeSubDicts: true,
1883       }),
1884     };
1885 
1886     data.fieldFlags = getInheritableProperty({ dict, key: "Ff" });
1887     if (!Number.isInteger(data.fieldFlags) || data.fieldFlags < 0) {
1888       data.fieldFlags = 0;
1889     }
1890 
1891     data.readOnly = this.hasFieldFlag(AnnotationFieldFlag.READONLY);
1892     data.required = this.hasFieldFlag(AnnotationFieldFlag.REQUIRED);
1893     data.hidden =
1894       this._hasFlag(data.annotationFlags, AnnotationFlag.HIDDEN) ||
1895       this._hasFlag(data.annotationFlags, AnnotationFlag.NOVIEW);
1896   }
1897 
1898   /**
1899    * Decode the given form value.
1900    *
1901    * @private
1902    * @memberof WidgetAnnotation
1903    * @param {Array<string>|Name|string} formValue - The (possibly encoded)
1904    *   form value.
1905    * @returns {Array<string>|string|null}
1906    */
1907   _decodeFormValue(formValue) {
1908     if (Array.isArray(formValue)) {
1909       return formValue
1910         .filter(item => typeof item === "string")
1911         .map(item => stringToPDFString(item));
1912     } else if (formValue instanceof Name) {
1913       return stringToPDFString(formValue.name);
1914     } else if (typeof formValue === "string") {
1915       return stringToPDFString(formValue);
1916     }
1917     return null;
1918   }
1919 
1920   /**
1921    * Check if a provided field flag is set.
1922    *
1923    * @public
1924    * @memberof WidgetAnnotation
1925    * @param {number} flag - Hexadecimal representation for an annotation
1926    *                        field characteristic
1927    * @returns {boolean}
1928    * @see {@link shared/util.js}
1929    */
1930   hasFieldFlag(flag) {
1931     return !!(this.data.fieldFlags & flag);
1932   }
1933 
1934   /** @inheritdoc */
1935   _isViewable(flags) {
1936     // We don't take into account the `NOVIEW` or `HIDDEN` flags here,
1937     // since the visibility can be changed by js code, hence in case
1938     // it's made viewable, we should render it (with visibility set to
1939     // hidden).
1940     // We don't take into account the `INVISIBLE` flag here, since we've a known
1941     // annotation type.
1942     return true;
1943   }
1944 
1945   /** @inheritdoc */
1946   mustBeViewed(annotationStorage, renderForms) {
1947     if (renderForms) {
1948       return this.viewable;
1949     }
1950     return (
1951       super.mustBeViewed(annotationStorage, renderForms) &&
1952       !this._hasFlag(this.flags, AnnotationFlag.NOVIEW)
1953     );
1954   }
1955 
1956   getRotationMatrix(annotationStorage) {
1957     let rotation = annotationStorage?.get(this.data.id)?.rotation;
1958     if (rotation === undefined) {
1959       rotation = this.rotation;
1960     }
1961 
1962     if (rotation === 0) {
1963       return IDENTITY_MATRIX;
1964     }
1965 
1966     const width = this.data.rect[2] - this.data.rect[0];
1967     const height = this.data.rect[3] - this.data.rect[1];
1968 
1969     return getRotationMatrix(rotation, width, height);
1970   }
1971 
1972   getBorderAndBackgroundAppearances(annotationStorage) {
1973     let rotation = annotationStorage?.get(this.data.id)?.rotation;
1974     if (rotation === undefined) {
1975       rotation = this.rotation;
1976     }
1977 
1978     if (!this.backgroundColor && !this.borderColor) {
1979       return "";
1980     }
1981     const width = this.data.rect[2] - this.data.rect[0];
1982     const height = this.data.rect[3] - this.data.rect[1];
1983     const rect =
1984       rotation === 0 || rotation === 180
1985         ? `0 0 ${width} ${height} re`
1986         : `0 0 ${height} ${width} re`;
1987 
1988     let str = "";
1989     if (this.backgroundColor) {
1990       str = `${getPdfColor(
1991         this.backgroundColor,
1992         /* isFill */ true
1993       )} ${rect} f `;
1994     }
1995 
1996     if (this.borderColor) {
1997       const borderWidth = this.borderStyle.width || 1;
1998       str += `${borderWidth} w ${getPdfColor(
1999         this.borderColor,
2000         /* isFill */ false
2001       )} ${rect} S `;
2002     }
2003 
2004     return str;
2005   }
2006 
2007   async getOperatorList(evaluator, task, intent, annotationStorage) {
2008     // Do not render form elements on the canvas when interactive forms are
2009     // enabled. The display layer is responsible for rendering them instead.
2010     if (
2011       intent & RenderingIntentFlag.ANNOTATIONS_FORMS &&
2012       !(this instanceof SignatureWidgetAnnotation) &&
2013       !this.data.noHTML &&
2014       !this.data.hasOwnCanvas
2015     ) {
2016       return {
2017         opList: new OperatorList(),
2018         separateForm: true,
2019         separateCanvas: false,
2020       };
2021     }
2022 
2023     if (!this._hasText) {
2024       return super.getOperatorList(evaluator, task, intent, annotationStorage);
2025     }
2026 
2027     const content = await this._getAppearance(
2028       evaluator,
2029       task,
2030       intent,
2031       annotationStorage
2032     );
2033     if (this.appearance && content === null) {
2034       return super.getOperatorList(evaluator, task, intent, annotationStorage);
2035     }
2036 
2037     const opList = new OperatorList();
2038 
2039     // Even if there is an appearance stream, ignore it. This is the
2040     // behaviour used by Adobe Reader.
2041     if (!this._defaultAppearance || content === null) {
2042       return { opList, separateForm: false, separateCanvas: false };
2043     }
2044 
2045     const isUsingOwnCanvas = !!(
2046       this.data.hasOwnCanvas && intent & RenderingIntentFlag.DISPLAY
2047     );
2048 
2049     const matrix = [1, 0, 0, 1, 0, 0];
2050     const bbox = [
2051       0,
2052       0,
2053       this.data.rect[2] - this.data.rect[0],
2054       this.data.rect[3] - this.data.rect[1],
2055     ];
2056     const transform = getTransformMatrix(this.data.rect, bbox, matrix);
2057 
2058     let optionalContent;
2059     if (this.oc) {
2060       optionalContent = await evaluator.parseMarkedContentProps(
2061         this.oc,
2062         /* resources = */ null
2063       );
2064     }
2065     if (optionalContent !== undefined) {
2066       opList.addOp(OPS.beginMarkedContentProps, ["OC", optionalContent]);
2067     }
2068 
2069     opList.addOp(OPS.beginAnnotation, [
2070       this.data.id,
2071       this.data.rect,
2072       transform,
2073       this.getRotationMatrix(annotationStorage),
2074       isUsingOwnCanvas,
2075     ]);
2076 
2077     const stream = new StringStream(content);
2078     await evaluator.getOperatorList({
2079       stream,
2080       task,
2081       resources: this._fieldResources.mergedResources,
2082       operatorList: opList,
2083     });
2084     opList.addOp(OPS.endAnnotation, []);
2085 
2086     if (optionalContent !== undefined) {
2087       opList.addOp(OPS.endMarkedContent, []);
2088     }
2089     return { opList, separateForm: false, separateCanvas: isUsingOwnCanvas };
2090   }
2091 
2092   _getMKDict(rotation) {
2093     const mk = new Dict(null);
2094     if (rotation) {
2095       mk.set("R", rotation);
2096     }
2097     if (this.borderColor) {
2098       mk.set("BC", getPdfColorArray(this.borderColor));
2099     }
2100     if (this.backgroundColor) {
2101       mk.set("BG", getPdfColorArray(this.backgroundColor));
2102     }
2103     return mk.size > 0 ? mk : null;
2104   }
2105 
2106   amendSavedDict(annotationStorage, dict) {}
2107 
2108   setValue(dict, value, xref, changes) {
2109     const { dict: parentDict, ref: parentRef } = getParentToUpdate(
2110       dict,
2111       this.ref,
2112       xref
2113     );
2114     if (!parentDict) {
2115       dict.set("V", value);
2116     } else if (!changes.has(parentRef)) {
2117       const newParentDict = parentDict.clone();
2118       newParentDict.set("V", value);
2119       changes.put(parentRef, { data: newParentDict });
2120       return newParentDict;
2121     }
2122 
2123     return null;
2124   }
2125 
2126   async save(evaluator, task, annotationStorage, changes) {
2127     const storageEntry = annotationStorage?.get(this.data.id);
2128     const flags = this._buildFlags(storageEntry?.noView, storageEntry?.noPrint);
2129     let value = storageEntry?.value,
2130       rotation = storageEntry?.rotation;
2131     if (value === this.data.fieldValue || value === undefined) {
2132       if (
2133         !this._hasValueFromXFA &&
2134         rotation === undefined &&
2135         flags === undefined
2136       ) {
2137         return;
2138       }
2139       value ||= this.data.fieldValue;
2140     }
2141 
2142     // Value can be an array (with choice list and multiple selections)
2143     if (
2144       rotation === undefined &&
2145       !this._hasValueFromXFA &&
2146       Array.isArray(value) &&
2147       Array.isArray(this.data.fieldValue) &&
2148       isArrayEqual(value, this.data.fieldValue) &&
2149       flags === undefined
2150     ) {
2151       return;
2152     }
2153 
2154     if (rotation === undefined) {
2155       rotation = this.rotation;
2156     }
2157 
2158     let appearance = null;
2159     if (!this._needAppearances) {
2160       appearance = await this._getAppearance(
2161         evaluator,
2162         task,
2163         RenderingIntentFlag.SAVE,
2164         annotationStorage
2165       );
2166       if (appearance === null && flags === undefined) {
2167         // Appearance didn't change.
2168         return;
2169       }
2170     } else {
2171       // No need to create an appearance: the pdf has the flag /NeedAppearances
2172       // which means that it's up to the reader to produce an appearance.
2173     }
2174 
2175     let needAppearances = false;
2176     if (appearance?.needAppearances) {
2177       needAppearances = true;
2178       appearance = null;
2179     }
2180 
2181     const { xref } = evaluator;
2182 
2183     const originalDict = xref.fetchIfRef(this.ref);
2184     if (!(originalDict instanceof Dict)) {
2185       return;
2186     }
2187 
2188     const dict = new Dict(xref);
2189     for (const key of originalDict.getKeys()) {
2190       if (key !== "AP") {
2191         dict.set(key, originalDict.getRaw(key));
2192       }
2193     }
2194     if (flags !== undefined) {
2195       dict.set("F", flags);
2196       if (appearance === null && !needAppearances) {
2197         const ap = originalDict.getRaw("AP");
2198         if (ap) {
2199           dict.set("AP", ap);
2200         }
2201       }
2202     }
2203 
2204     const xfa = {
2205       path: this.data.fieldName,
2206       value,
2207     };
2208 
2209     const newParentDict = this.setValue(
2210       dict,
2211       Array.isArray(value)
2212         ? value.map(stringToAsciiOrUTF16BE)
2213         : stringToAsciiOrUTF16BE(value),
2214       xref,
2215       changes
2216     );
2217     this.amendSavedDict(annotationStorage, newParentDict || dict);
2218 
2219     const maybeMK = this._getMKDict(rotation);
2220     if (maybeMK) {
2221       dict.set("MK", maybeMK);
2222     }
2223 
2224     changes.put(this.ref, {
2225       data: dict,
2226       xfa,
2227       needAppearances,
2228     });
2229     if (appearance !== null) {
2230       const newRef = xref.getNewTemporaryRef();
2231       const AP = new Dict(xref);
2232       dict.set("AP", AP);
2233       AP.set("N", newRef);
2234 
2235       const resources = this._getSaveFieldResources(xref);
2236       const appearanceStream = new StringStream(appearance);
2237       const appearanceDict = (appearanceStream.dict = new Dict(xref));
2238       appearanceDict.set("Subtype", Name.get("Form"));
2239       appearanceDict.set("Resources", resources);
2240       appearanceDict.set("BBox", [
2241         0,
2242         0,
2243         this.data.rect[2] - this.data.rect[0],
2244         this.data.rect[3] - this.data.rect[1],
2245       ]);
2246 
2247       const rotationMatrix = this.getRotationMatrix(annotationStorage);
2248       if (rotationMatrix !== IDENTITY_MATRIX) {
2249         // The matrix isn't the identity one.
2250         appearanceDict.set("Matrix", rotationMatrix);
2251       }
2252 
2253       changes.put(newRef, {
2254         data: appearanceStream,
2255         xfa: null,
2256         needAppearances: false,
2257       });
2258     }
2259 
2260     dict.set("M", `D:${getModificationDate()}`);
2261   }
2262 
2263   async _getAppearance(evaluator, task, intent, annotationStorage) {
2264     const isPassword = this.hasFieldFlag(AnnotationFieldFlag.PASSWORD);
2265     if (isPassword) {
2266       return null;
2267     }
2268     const storageEntry = annotationStorage?.get(this.data.id);
2269     let value, rotation;
2270     if (storageEntry) {
2271       value = storageEntry.formattedValue || storageEntry.value;
2272       rotation = storageEntry.rotation;
2273     }
2274 
2275     if (
2276       rotation === undefined &&
2277       value === undefined &&
2278       !this._needAppearances
2279     ) {
2280       if (!this._hasValueFromXFA || this.appearance) {
2281         // The annotation hasn't been rendered so use the appearance.
2282         return null;
2283       }
2284     }
2285 
2286     // Empty or it has a trailing whitespace.
2287     const colors = this.getBorderAndBackgroundAppearances(annotationStorage);
2288 
2289     if (value === undefined) {
2290       // The annotation has its value in XFA datasets but not in the V field.
2291       value = this.data.fieldValue;
2292       if (!value) {
2293         return `/Tx BMC q ${colors}Q EMC`;
2294       }
2295     }
2296 
2297     if (Array.isArray(value) && value.length === 1) {
2298       value = value[0];
2299     }
2300 
2301     assert(typeof value === "string", "Expected `value` to be a string.");
2302     value = value.trimEnd();
2303 
2304     if (this.data.combo) {
2305       // The value can be one of the exportValue or any other values.
2306       const option = this.data.options.find(
2307         ({ exportValue }) => value === exportValue
2308       );
2309       value = option?.displayValue || value;
2310     }
2311 
2312     if (value === "") {
2313       // the field is empty: nothing to render
2314       return `/Tx BMC q ${colors}Q EMC`;
2315     }
2316 
2317     if (rotation === undefined) {
2318       rotation = this.rotation;
2319     }
2320 
2321     let lineCount = -1;
2322     let lines;
2323 
2324     // We could have a text containing for example some sequences of chars and
2325     // their diacritics (e.g. "é".normalize("NFKD") shows 1 char when it's 2).
2326     // Positioning diacritics is really something we don't want to do here.
2327     // So if a font has a glyph for a acute accent and one for "e" then we won't
2328     // get any encoding issues but we'll render "e" and then "´".
2329     // It's why we normalize the string. We use NFC to preserve the initial
2330     // string, (e.g. "²".normalize("NFC") === "²"
2331     // but "²".normalize("NFKC") === "2").
2332     //
2333     // TODO: it isn't a perfect solution, some chars like "ẹ́" will be
2334     // decomposed into two chars ("ẹ" and "´"), so we should detect such
2335     // situations and then use either FakeUnicodeFont or set the
2336     // /NeedAppearances flag.
2337     if (this.data.multiLine) {
2338       lines = value.split(/\r\n?|\n/).map(line => line.normalize("NFC"));
2339       lineCount = lines.length;
2340     } else {
2341       lines = [value.replace(/\r\n?|\n/, "").normalize("NFC")];
2342     }
2343 
2344     const defaultPadding = 1;
2345     const defaultHPadding = 2;
2346     let totalHeight = this.data.rect[3] - this.data.rect[1];
2347     let totalWidth = this.data.rect[2] - this.data.rect[0];
2348 
2349     if (rotation === 90 || rotation === 270) {
2350       [totalWidth, totalHeight] = [totalHeight, totalWidth];
2351     }
2352 
2353     if (!this._defaultAppearance) {
2354       // The DA is required and must be a string.
2355       // If there is no font named Helvetica in the resource dictionary,
2356       // the evaluator will fall back to a default font.
2357       // Doing so prevents exceptions and allows saving/printing
2358       // the file as expected.
2359       this.data.defaultAppearanceData = parseDefaultAppearance(
2360         (this._defaultAppearance = "/Helvetica 0 Tf 0 g")
2361       );
2362     }
2363 
2364     let font = await WidgetAnnotation._getFontData(
2365       evaluator,
2366       task,
2367       this.data.defaultAppearanceData,
2368       this._fieldResources.mergedResources
2369     );
2370 
2371     let defaultAppearance, fontSize, lineHeight;
2372     const encodedLines = [];
2373     let encodingError = false;
2374     for (const line of lines) {
2375       const encodedString = font.encodeString(line);
2376       if (encodedString.length > 1) {
2377         encodingError = true;
2378       }
2379       encodedLines.push(encodedString.join(""));
2380     }
2381 
2382     if (encodingError && intent & RenderingIntentFlag.SAVE) {
2383       // We don't have a way to render the field, so we just rely on the
2384       // /NeedAppearances trick to let the different sofware correctly render
2385       // this pdf.
2386       return { needAppearances: true };
2387     }
2388 
2389     // We check that the font is able to encode the string.
2390     if (encodingError && this._isOffscreenCanvasSupported) {
2391       // If it can't then we fallback on fake unicode font (mapped to sans-serif
2392       // for the rendering).
2393       // It means that a printed form can be rendered differently (it depends on
2394       // the sans-serif font) but at least we've something to render.
2395       // In an ideal world the associated font should correctly handle the
2396       // possible chars but a user can add a smiley or whatever.
2397       // We could try to embed a font but it means that we must have access
2398       // to the raw font file.
2399       const fontFamily = this.data.comb ? "monospace" : "sans-serif";
2400       const fakeUnicodeFont = new FakeUnicodeFont(evaluator.xref, fontFamily);
2401       const resources = fakeUnicodeFont.createFontResources(lines.join(""));
2402       const newFont = resources.getRaw("Font");
2403 
2404       if (this._fieldResources.mergedResources.has("Font")) {
2405         const oldFont = this._fieldResources.mergedResources.get("Font");
2406         for (const key of newFont.getKeys()) {
2407           oldFont.set(key, newFont.getRaw(key));
2408         }
2409       } else {
2410         this._fieldResources.mergedResources.set("Font", newFont);
2411       }
2412 
2413       const fontName = fakeUnicodeFont.fontName.name;
2414       font = await WidgetAnnotation._getFontData(
2415         evaluator,
2416         task,
2417         { fontName, fontSize: 0 },
2418         resources
2419       );
2420 
2421       for (let i = 0, ii = encodedLines.length; i < ii; i++) {
2422         encodedLines[i] = stringToUTF16String(lines[i]);
2423       }
2424 
2425       const savedDefaultAppearance = Object.assign(
2426         Object.create(null),
2427         this.data.defaultAppearanceData
2428       );
2429       this.data.defaultAppearanceData.fontSize = 0;
2430       this.data.defaultAppearanceData.fontName = fontName;
2431 
2432       [defaultAppearance, fontSize, lineHeight] = this._computeFontSize(
2433         totalHeight - 2 * defaultPadding,
2434         totalWidth - 2 * defaultHPadding,
2435         value,
2436         font,
2437         lineCount
2438       );
2439 
2440       this.data.defaultAppearanceData = savedDefaultAppearance;
2441     } else {
2442       if (!this._isOffscreenCanvasSupported) {
2443         warn(
2444           "_getAppearance: OffscreenCanvas is not supported, annotation may not render correctly."
2445         );
2446       }
2447 
2448       [defaultAppearance, fontSize, lineHeight] = this._computeFontSize(
2449         totalHeight - 2 * defaultPadding,
2450         totalWidth - 2 * defaultHPadding,
2451         value,
2452         font,
2453         lineCount
2454       );
2455     }
2456 
2457     let descent = font.descent;
2458     if (isNaN(descent)) {
2459       descent = BASELINE_FACTOR * lineHeight;
2460     } else {
2461       descent = Math.max(
2462         BASELINE_FACTOR * lineHeight,
2463         Math.abs(descent) * fontSize
2464       );
2465     }
2466 
2467     // Take into account the space we have to compute the default vertical
2468     // padding.
2469     const defaultVPadding = Math.min(
2470       Math.floor((totalHeight - fontSize) / 2),
2471       defaultPadding
2472     );
2473     const alignment = this.data.textAlignment;
2474 
2475     if (this.data.multiLine) {
2476       return this._getMultilineAppearance(
2477         defaultAppearance,
2478         encodedLines,
2479         font,
2480         fontSize,
2481         totalWidth,
2482         totalHeight,
2483         alignment,
2484         defaultHPadding,
2485         defaultVPadding,
2486         descent,
2487         lineHeight,
2488         annotationStorage
2489       );
2490     }
2491 
2492     if (this.data.comb) {
2493       return this._getCombAppearance(
2494         defaultAppearance,
2495         font,
2496         encodedLines[0],
2497         fontSize,
2498         totalWidth,
2499         totalHeight,
2500         defaultHPadding,
2501         defaultVPadding,
2502         descent,
2503         lineHeight,
2504         annotationStorage
2505       );
2506     }
2507 
2508     const bottomPadding = defaultVPadding + descent;
2509     if (alignment === 0 || alignment > 2) {
2510       // Left alignment: nothing to do
2511       return (
2512         `/Tx BMC q ${colors}BT ` +
2513         defaultAppearance +
2514         ` 1 0 0 1 ${numberToString(defaultHPadding)} ${numberToString(
2515           bottomPadding
2516         )} Tm (${escapeString(encodedLines[0])}) Tj` +
2517         " ET Q EMC"
2518       );
2519     }
2520 
2521     const prevInfo = { shift: 0 };
2522     const renderedText = this._renderText(
2523       encodedLines[0],
2524       font,
2525       fontSize,
2526       totalWidth,
2527       alignment,
2528       prevInfo,
2529       defaultHPadding,
2530       bottomPadding
2531     );
2532     return (
2533       `/Tx BMC q ${colors}BT ` +
2534       defaultAppearance +
2535       ` 1 0 0 1 0 0 Tm ${renderedText}` +
2536       " ET Q EMC"
2537     );
2538   }
2539 
2540   static async _getFontData(evaluator, task, appearanceData, resources) {
2541     const operatorList = new OperatorList();
2542     const initialState = {
2543       font: null,
2544       clone() {
2545         return this;
2546       },
2547     };
2548 
2549     const { fontName, fontSize } = appearanceData;
2550     await evaluator.handleSetFont(
2551       resources,
2552       [fontName && Name.get(fontName), fontSize],
2553       /* fontRef = */ null,
2554       operatorList,
2555       task,
2556       initialState,
2557       /* fallbackFontDict = */ null
2558     );
2559 
2560     return initialState.font;
2561   }
2562 
2563   _getTextWidth(text, font) {
2564     return (
2565       font
2566         .charsToGlyphs(text)
2567         .reduce((width, glyph) => width + glyph.width, 0) / 1000
2568     );
2569   }
2570 
2571   _computeFontSize(height, width, text, font, lineCount) {
2572     let { fontSize } = this.data.defaultAppearanceData;
2573     let lineHeight = (fontSize || 12) * LINE_FACTOR,
2574       numberOfLines = Math.round(height / lineHeight);
2575 
2576     if (!fontSize) {
2577       // A zero value for size means that the font shall be auto-sized:
2578       // its size shall be computed as a function of the height of the
2579       // annotation rectangle (see 12.7.3.3).
2580 
2581       const roundWithTwoDigits = x => Math.floor(x * 100) / 100;
2582 
2583       if (lineCount === -1) {
2584         // Get the text width for a font size of 1.
2585         const textWidth = this._getTextWidth(text, font);
2586 
2587         // width / textWidth is the max font size to fit the width.
2588         // height / LINE_FACTOR is the max font size to fit the height.
2589         fontSize = roundWithTwoDigits(
2590           Math.min(height / LINE_FACTOR, width / textWidth)
2591         );
2592         numberOfLines = 1;
2593       } else {
2594         const lines = text.split(/\r\n?|\n/);
2595         const cachedLines = [];
2596         for (const line of lines) {
2597           const encoded = font.encodeString(line).join("");
2598           const glyphs = font.charsToGlyphs(encoded);
2599           const positions = font.getCharPositions(encoded);
2600           cachedLines.push({
2601             line: encoded,
2602             glyphs,
2603             positions,
2604           });
2605         }
2606 
2607         const isTooBig = fsize => {
2608           // Return true when the text doesn't fit the given height.
2609           let totalHeight = 0;
2610           for (const cache of cachedLines) {
2611             const chunks = this._splitLine(null, font, fsize, width, cache);
2612             totalHeight += chunks.length * fsize;
2613             if (totalHeight > height) {
2614               return true;
2615             }
2616           }
2617           return false;
2618         };
2619 
2620         // Hard to guess how many lines there are.
2621         // The field may have been sized to have 10 lines
2622         // and the user entered only 1 so if we get font size from
2623         // height and number of lines then we'll get something too big.
2624         // So we compute a fake number of lines based on height and
2625         // a font size equal to 12 (this is the default font size in
2626         // Acrobat).
2627         // Then we'll adjust font size to what we have really.
2628         numberOfLines = Math.max(numberOfLines, lineCount);
2629 
2630         while (true) {
2631           lineHeight = height / numberOfLines;
2632           fontSize = roundWithTwoDigits(lineHeight / LINE_FACTOR);
2633 
2634           if (isTooBig(fontSize)) {
2635             numberOfLines++;
2636             continue;
2637           }
2638 
2639           break;
2640         }
2641       }
2642 
2643       const { fontName, fontColor } = this.data.defaultAppearanceData;
2644       this._defaultAppearance = createDefaultAppearance({
2645         fontSize,
2646         fontName,
2647         fontColor,
2648       });
2649     }
2650 
2651     return [this._defaultAppearance, fontSize, height / numberOfLines];
2652   }
2653 
2654   _renderText(
2655     text,
2656     font,
2657     fontSize,
2658     totalWidth,
2659     alignment,
2660     prevInfo,
2661     hPadding,
2662     vPadding
2663   ) {
2664     // TODO: we need to take into account (if possible) how the text
2665     // is rendered. For example in arabic, the cumulated width of some
2666     // glyphs isn't equal to the width of the rendered glyphs because
2667     // of ligatures.
2668     let shift;
2669     if (alignment === 1) {
2670       // Center
2671       const width = this._getTextWidth(text, font) * fontSize;
2672       shift = (totalWidth - width) / 2;
2673     } else if (alignment === 2) {
2674       // Right
2675       const width = this._getTextWidth(text, font) * fontSize;
2676       shift = totalWidth - width - hPadding;
2677     } else {
2678       shift = hPadding;
2679     }
2680     const shiftStr = numberToString(shift - prevInfo.shift);
2681     prevInfo.shift = shift;
2682     vPadding = numberToString(vPadding);
2683 
2684     return `${shiftStr} ${vPadding} Td (${escapeString(text)}) Tj`;
2685   }
2686 
2687   /**
2688    * @private
2689    */
2690   _getSaveFieldResources(xref) {
2691     if (typeof PDFJSDev === "undefined" || PDFJSDev.test("TESTING")) {
2692       assert(
2693         this.data.defaultAppearanceData,
2694         "Expected `_defaultAppearanceData` to have been set."
2695       );
2696     }
2697     const { localResources, appearanceResources, acroFormResources } =
2698       this._fieldResources;
2699 
2700     const fontName = this.data.defaultAppearanceData?.fontName;
2701     if (!fontName) {
2702       return localResources || Dict.empty;
2703     }
2704 
2705     for (const resources of [localResources, appearanceResources]) {
2706       if (resources instanceof Dict) {
2707         const localFont = resources.get("Font");
2708         if (localFont instanceof Dict && localFont.has(fontName)) {
2709           return resources;
2710         }
2711       }
2712     }
2713     if (acroFormResources instanceof Dict) {
2714       const acroFormFont = acroFormResources.get("Font");
2715       if (acroFormFont instanceof Dict && acroFormFont.has(fontName)) {
2716         const subFontDict = new Dict(xref);
2717         subFontDict.set(fontName, acroFormFont.getRaw(fontName));
2718 
2719         const subResourcesDict = new Dict(xref);
2720         subResourcesDict.set("Font", subFontDict);
2721 
2722         return Dict.merge({
2723           xref,
2724           dictArray: [subResourcesDict, localResources],
2725           mergeSubDicts: true,
2726         });
2727       }
2728     }
2729     return localResources || Dict.empty;
2730   }
2731 
2732   getFieldObject() {
2733     return null;
2734   }
2735 }
2736 
2737 class TextWidgetAnnotation extends WidgetAnnotation {
2738   constructor(params) {
2739     super(params);
2740 
2741     const { dict } = params;
2742 
2743     if (dict.has("PMD")) {
2744       // It's used to display a barcode but it isn't specified so we just hide
2745       // it to avoid any confusion.
2746       this.flags |= AnnotationFlag.HIDDEN;
2747       this.data.hidden = true;
2748       warn("Barcodes are not supported");
2749     }
2750 
2751     this.data.hasOwnCanvas = this.data.readOnly && !this.data.noHTML;
2752     this._hasText = true;
2753 
2754     // The field value is always a string.
2755     if (typeof this.data.fieldValue !== "string") {
2756       this.data.fieldValue = "";
2757     }
2758 
2759     // Determine the alignment of text in the field.
2760     let alignment = getInheritableProperty({ dict, key: "Q" });
2761     if (!Number.isInteger(alignment) || alignment < 0 || alignment > 2) {
2762       alignment = null;
2763     }
2764     this.data.textAlignment = alignment;
2765 
2766     // Determine the maximum length of text in the field.
2767     let maximumLength = getInheritableProperty({ dict, key: "MaxLen" });
2768     if (!Number.isInteger(maximumLength) || maximumLength < 0) {
2769       maximumLength = 0;
2770     }
2771     this.data.maxLen = maximumLength;
2772 
2773     // Process field flags for the display layer.
2774     this.data.multiLine = this.hasFieldFlag(AnnotationFieldFlag.MULTILINE);
2775     this.data.comb =
2776       this.hasFieldFlag(AnnotationFieldFlag.COMB) &&
2777       !this.hasFieldFlag(AnnotationFieldFlag.MULTILINE) &&
2778       !this.hasFieldFlag(AnnotationFieldFlag.PASSWORD) &&
2779       !this.hasFieldFlag(AnnotationFieldFlag.FILESELECT) &&
2780       this.data.maxLen !== 0;
2781     this.data.doNotScroll = this.hasFieldFlag(AnnotationFieldFlag.DONOTSCROLL);
2782   }
2783 
2784   get hasTextContent() {
2785     return !!this.appearance && !this._needAppearances;
2786   }
2787 
2788   _getCombAppearance(
2789     defaultAppearance,
2790     font,
2791     text,
2792     fontSize,
2793     width,
2794     height,
2795     hPadding,
2796     vPadding,
2797     descent,
2798     lineHeight,
2799     annotationStorage
2800   ) {
2801     const combWidth = width / this.data.maxLen;
2802     // Empty or it has a trailing whitespace.
2803     const colors = this.getBorderAndBackgroundAppearances(annotationStorage);
2804 
2805     const buf = [];
2806     const positions = font.getCharPositions(text);
2807     for (const [start, end] of positions) {
2808       buf.push(`(${escapeString(text.substring(start, end))}) Tj`);
2809     }
2810 
2811     const renderedComb = buf.join(` ${numberToString(combWidth)} 0 Td `);
2812     return (
2813       `/Tx BMC q ${colors}BT ` +
2814       defaultAppearance +
2815       ` 1 0 0 1 ${numberToString(hPadding)} ${numberToString(
2816         vPadding + descent
2817       )} Tm ${renderedComb}` +
2818       " ET Q EMC"
2819     );
2820   }
2821 
2822   _getMultilineAppearance(
2823     defaultAppearance,
2824     lines,
2825     font,
2826     fontSize,
2827     width,
2828     height,
2829     alignment,
2830     hPadding,
2831     vPadding,
2832     descent,
2833     lineHeight,
2834     annotationStorage
2835   ) {
2836     const buf = [];
2837     const totalWidth = width - 2 * hPadding;
2838     const prevInfo = { shift: 0 };
2839     for (let i = 0, ii = lines.length; i < ii; i++) {
2840       const line = lines[i];
2841       const chunks = this._splitLine(line, font, fontSize, totalWidth);
2842       for (let j = 0, jj = chunks.length; j < jj; j++) {
2843         const chunk = chunks[j];
2844         const vShift =
2845           i === 0 && j === 0 ? -vPadding - (lineHeight - descent) : -lineHeight;
2846         buf.push(
2847           this._renderText(
2848             chunk,
2849             font,
2850             fontSize,
2851             width,
2852             alignment,
2853             prevInfo,
2854             hPadding,
2855             vShift
2856           )
2857         );
2858       }
2859     }
2860 
2861     // Empty or it has a trailing whitespace.
2862     const colors = this.getBorderAndBackgroundAppearances(annotationStorage);
2863     const renderedText = buf.join("\n");
2864 
2865     return (
2866       `/Tx BMC q ${colors}BT ` +
2867       defaultAppearance +
2868       ` 1 0 0 1 0 ${numberToString(height)} Tm ${renderedText}` +
2869       " ET Q EMC"
2870     );
2871   }
2872 
2873   _splitLine(line, font, fontSize, width, cache = {}) {
2874     line = cache.line || line;
2875 
2876     const glyphs = cache.glyphs || font.charsToGlyphs(line);
2877 
2878     if (glyphs.length <= 1) {
2879       // Nothing to split
2880       return [line];
2881     }
2882 
2883     const positions = cache.positions || font.getCharPositions(line);
2884     const scale = fontSize / 1000;
2885     const chunks = [];
2886 
2887     let lastSpacePosInStringStart = -1,
2888       lastSpacePosInStringEnd = -1,
2889       lastSpacePos = -1,
2890       startChunk = 0,
2891       currentWidth = 0;
2892 
2893     for (let i = 0, ii = glyphs.length; i < ii; i++) {
2894       const [start, end] = positions[i];
2895       const glyph = glyphs[i];
2896       const glyphWidth = glyph.width * scale;
2897       if (glyph.unicode === " ") {
2898         if (currentWidth + glyphWidth > width) {
2899           // We can break here
2900           chunks.push(line.substring(startChunk, start));
2901           startChunk = start;
2902           currentWidth = glyphWidth;
2903           lastSpacePosInStringStart = -1;
2904           lastSpacePos = -1;
2905         } else {
2906           currentWidth += glyphWidth;
2907           lastSpacePosInStringStart = start;
2908           lastSpacePosInStringEnd = end;
2909           lastSpacePos = i;
2910         }
2911       } else if (currentWidth + glyphWidth > width) {
2912         // We must break to the last white position (if available)
2913         if (lastSpacePosInStringStart !== -1) {
2914           chunks.push(line.substring(startChunk, lastSpacePosInStringEnd));
2915           startChunk = lastSpacePosInStringEnd;
2916           i = lastSpacePos + 1;
2917           lastSpacePosInStringStart = -1;
2918           currentWidth = 0;
2919         } else {
2920           // Just break in the middle of the word
2921           chunks.push(line.substring(startChunk, start));
2922           startChunk = start;
2923           currentWidth = glyphWidth;
2924         }
2925       } else {
2926         currentWidth += glyphWidth;
2927       }
2928     }
2929 
2930     if (startChunk < line.length) {
2931       chunks.push(line.substring(startChunk, line.length));
2932     }
2933 
2934     return chunks;
2935   }
2936 
2937   async extractTextContent(evaluator, task, viewBox) {
2938     await super.extractTextContent(evaluator, task, viewBox);
2939     const text = this.data.textContent;
2940     if (!text) {
2941       return;
2942     }
2943 
2944     // The text extractor doesn't handle empty lines correctly, so if the
2945     // content we get is more or less (modulo whitespaces) the same as the
2946     // field value we just ignore it.
2947     const allText = text.join("\n");
2948     if (allText === this.data.fieldValue) {
2949       return;
2950     }
2951     const regex = allText.replaceAll(/([.*+?^${}()|[\]\\])|(\s+)/g, (_m, p1) =>
2952       p1 ? `\\${p1}` : "\\s+"
2953     );
2954     if (new RegExp(`^\\s*${regex}\\s*$`).test(this.data.fieldValue)) {
2955       this.data.textContent = this.data.fieldValue.split("\n");
2956     }
2957   }
2958 
2959   getFieldObject() {
2960     return {
2961       id: this.data.id,
2962       value: this.data.fieldValue,
2963       defaultValue: this.data.defaultFieldValue || "",
2964       multiline: this.data.multiLine,
2965       password: this.hasFieldFlag(AnnotationFieldFlag.PASSWORD),
2966       charLimit: this.data.maxLen,
2967       comb: this.data.comb,
2968       editable: !this.data.readOnly,
2969       hidden: this.data.hidden,
2970       name: this.data.fieldName,
2971       rect: this.data.rect,
2972       actions: this.data.actions,
2973       page: this.data.pageIndex,
2974       strokeColor: this.data.borderColor,
2975       fillColor: this.data.backgroundColor,
2976       rotation: this.rotation,
2977       type: "text",
2978     };
2979   }
2980 }
2981 
2982 class ButtonWidgetAnnotation extends WidgetAnnotation {
2983   constructor(params) {
2984     super(params);
2985 
2986     this.checkedAppearance = null;
2987     this.uncheckedAppearance = null;
2988 
2989     this.data.checkBox =
2990       !this.hasFieldFlag(AnnotationFieldFlag.RADIO) &&
2991       !this.hasFieldFlag(AnnotationFieldFlag.PUSHBUTTON);
2992     this.data.radioButton =
2993       this.hasFieldFlag(AnnotationFieldFlag.RADIO) &&
2994       !this.hasFieldFlag(AnnotationFieldFlag.PUSHBUTTON);
2995     this.data.pushButton = this.hasFieldFlag(AnnotationFieldFlag.PUSHBUTTON);
2996     this.data.isTooltipOnly = false;
2997 
2998     if (this.data.checkBox) {
2999       this._processCheckBox(params);
3000     } else if (this.data.radioButton) {
3001       this._processRadioButton(params);
3002     } else if (this.data.pushButton) {
3003       this.data.hasOwnCanvas = true;
3004       this.data.noHTML = false;
3005       this._processPushButton(params);
3006     } else {
3007       warn("Invalid field flags for button widget annotation");
3008     }
3009   }
3010 
3011   async getOperatorList(evaluator, task, intent, annotationStorage) {
3012     if (this.data.pushButton) {
3013       return super.getOperatorList(
3014         evaluator,
3015         task,
3016         intent,
3017         false, // we use normalAppearance to render the button
3018         annotationStorage
3019       );
3020     }
3021 
3022     let value = null;
3023     let rotation = null;
3024     if (annotationStorage) {
3025       const storageEntry = annotationStorage.get(this.data.id);
3026       value = storageEntry ? storageEntry.value : null;
3027       rotation = storageEntry ? storageEntry.rotation : null;
3028     }
3029 
3030     if (value === null && this.appearance) {
3031       // Nothing in the annotationStorage.
3032       // But we've a default appearance so use it.
3033       return super.getOperatorList(evaluator, task, intent, annotationStorage);
3034     }
3035 
3036     if (value === null || value === undefined) {
3037       // There is no default appearance so use the one derived
3038       // from the field value.
3039       value = this.data.checkBox
3040         ? this.data.fieldValue === this.data.exportValue
3041         : this.data.fieldValue === this.data.buttonValue;
3042     }
3043 
3044     const appearance = value
3045       ? this.checkedAppearance
3046       : this.uncheckedAppearance;
3047     if (appearance) {
3048       const savedAppearance = this.appearance;
3049       const savedMatrix = lookupMatrix(
3050         appearance.dict.getArray("Matrix"),
3051         IDENTITY_MATRIX
3052       );
3053 
3054       if (rotation) {
3055         appearance.dict.set(
3056           "Matrix",
3057           this.getRotationMatrix(annotationStorage)
3058         );
3059       }
3060 
3061       this.appearance = appearance;
3062       const operatorList = super.getOperatorList(
3063         evaluator,
3064         task,
3065         intent,
3066         annotationStorage
3067       );
3068       this.appearance = savedAppearance;
3069       appearance.dict.set("Matrix", savedMatrix);
3070       return operatorList;
3071     }
3072 
3073     // No appearance
3074     return {
3075       opList: new OperatorList(),
3076       separateForm: false,
3077       separateCanvas: false,
3078     };
3079   }
3080 
3081   async save(evaluator, task, annotationStorage, changes) {
3082     if (this.data.checkBox) {
3083       this._saveCheckbox(evaluator, task, annotationStorage, changes);
3084       return;
3085     }
3086 
3087     if (this.data.radioButton) {
3088       this._saveRadioButton(evaluator, task, annotationStorage, changes);
3089     }
3090   }
3091 
3092   async _saveCheckbox(evaluator, task, annotationStorage, changes) {
3093     if (!annotationStorage) {
3094       return;
3095     }
3096     const storageEntry = annotationStorage.get(this.data.id);
3097     const flags = this._buildFlags(storageEntry?.noView, storageEntry?.noPrint);
3098     let rotation = storageEntry?.rotation,
3099       value = storageEntry?.value;
3100 
3101     if (rotation === undefined && flags === undefined) {
3102       if (value === undefined) {
3103         return;
3104       }
3105 
3106       const defaultValue = this.data.fieldValue === this.data.exportValue;
3107       if (defaultValue === value) {
3108         return;
3109       }
3110     }
3111 
3112     let dict = evaluator.xref.fetchIfRef(this.ref);
3113     if (!(dict instanceof Dict)) {
3114       return;
3115     }
3116     dict = dict.clone();
3117 
3118     if (rotation === undefined) {
3119       rotation = this.rotation;
3120     }
3121     if (value === undefined) {
3122       value = this.data.fieldValue === this.data.exportValue;
3123     }
3124 
3125     const xfa = {
3126       path: this.data.fieldName,
3127       value: value ? this.data.exportValue : "",
3128     };
3129 
3130     const name = Name.get(value ? this.data.exportValue : "Off");
3131     this.setValue(dict, name, evaluator.xref, changes);
3132 
3133     dict.set("AS", name);
3134     dict.set("M", `D:${getModificationDate()}`);
3135     if (flags !== undefined) {
3136       dict.set("F", flags);
3137     }
3138 
3139     const maybeMK = this._getMKDict(rotation);
3140     if (maybeMK) {
3141       dict.set("MK", maybeMK);
3142     }
3143 
3144     changes.put(this.ref, {
3145       data: dict,
3146       xfa,
3147       needAppearances: false,
3148     });
3149   }
3150 
3151   async _saveRadioButton(evaluator, task, annotationStorage, changes) {
3152     if (!annotationStorage) {
3153       return;
3154     }
3155     const storageEntry = annotationStorage.get(this.data.id);
3156     const flags = this._buildFlags(storageEntry?.noView, storageEntry?.noPrint);
3157     let rotation = storageEntry?.rotation,
3158       value = storageEntry?.value;
3159 
3160     if (rotation === undefined && flags === undefined) {
3161       if (value === undefined) {
3162         return;
3163       }
3164 
3165       const defaultValue = this.data.fieldValue === this.data.buttonValue;
3166       if (defaultValue === value) {
3167         return;
3168       }
3169     }
3170 
3171     let dict = evaluator.xref.fetchIfRef(this.ref);
3172     if (!(dict instanceof Dict)) {
3173       return;
3174     }
3175     dict = dict.clone();
3176 
3177     if (value === undefined) {
3178       value = this.data.fieldValue === this.data.buttonValue;
3179     }
3180 
3181     if (rotation === undefined) {
3182       rotation = this.rotation;
3183     }
3184 
3185     const xfa = {
3186       path: this.data.fieldName,
3187       value: value ? this.data.buttonValue : "",
3188     };
3189 
3190     const name = Name.get(value ? this.data.buttonValue : "Off");
3191     if (value) {
3192       this.setValue(dict, name, evaluator.xref, changes);
3193     }
3194 
3195     dict.set("AS", name);
3196     dict.set("M", `D:${getModificationDate()}`);
3197     if (flags !== undefined) {
3198       dict.set("F", flags);
3199     }
3200 
3201     const maybeMK = this._getMKDict(rotation);
3202     if (maybeMK) {
3203       dict.set("MK", maybeMK);
3204     }
3205 
3206     changes.put(this.ref, {
3207       data: dict,
3208       xfa,
3209       needAppearances: false,
3210     });
3211   }
3212 
3213   _getDefaultCheckedAppearance(params, type) {
3214     const width = this.data.rect[2] - this.data.rect[0];
3215     const height = this.data.rect[3] - this.data.rect[1];
3216     const bbox = [0, 0, width, height];
3217 
3218     // Ratio used to have a mark slightly smaller than the bbox.
3219     const FONT_RATIO = 0.8;
3220     const fontSize = Math.min(width, height) * FONT_RATIO;
3221 
3222     // Char Metrics
3223     // Widths came from widths for ZapfDingbats.
3224     // Heights are guessed with Fontforge and FoxitDingbats.pfb.
3225     let metrics, char;
3226     if (type === "check") {
3227       // Char 33 (2713 in unicode)
3228       metrics = {
3229         width: 0.755 * fontSize,
3230         height: 0.705 * fontSize,
3231       };
3232       char = "\x33";
3233     } else if (type === "disc") {
3234       // Char 6C (25CF in unicode)
3235       metrics = {
3236         width: 0.791 * fontSize,
3237         height: 0.705 * fontSize,
3238       };
3239       char = "\x6C";
3240     } else {
3241       unreachable(`_getDefaultCheckedAppearance - unsupported type: ${type}`);
3242     }
3243 
3244     // Values to center the glyph in the bbox.
3245     const xShift = numberToString((width - metrics.width) / 2);
3246     const yShift = numberToString((height - metrics.height) / 2);
3247 
3248     const appearance = `q BT /PdfJsZaDb ${fontSize} Tf 0 g ${xShift} ${yShift} Td (${char}) Tj ET Q`;
3249 
3250     const appearanceStreamDict = new Dict(params.xref);
3251     appearanceStreamDict.set("FormType", 1);
3252     appearanceStreamDict.set("Subtype", Name.get("Form"));
3253     appearanceStreamDict.set("Type", Name.get("XObject"));
3254     appearanceStreamDict.set("BBox", bbox);
3255     appearanceStreamDict.set("Matrix", [1, 0, 0, 1, 0, 0]);
3256     appearanceStreamDict.set("Length", appearance.length);
3257 
3258     const resources = new Dict(params.xref);
3259     const font = new Dict(params.xref);
3260     font.set("PdfJsZaDb", this.fallbackFontDict);
3261     resources.set("Font", font);
3262 
3263     appearanceStreamDict.set("Resources", resources);
3264 
3265     this.checkedAppearance = new StringStream(appearance);
3266     this.checkedAppearance.dict = appearanceStreamDict;
3267 
3268     this._streams.push(this.checkedAppearance);
3269   }
3270 
3271   _processCheckBox(params) {
3272     const customAppearance = params.dict.get("AP");
3273     if (!(customAppearance instanceof Dict)) {
3274       return;
3275     }
3276 
3277     const normalAppearance = customAppearance.get("N");
3278     if (!(normalAppearance instanceof Dict)) {
3279       return;
3280     }
3281 
3282     // See https://bugzilla.mozilla.org/show_bug.cgi?id=1722036.
3283     // If we've an AS and a V then take AS.
3284     const asValue = this._decodeFormValue(params.dict.get("AS"));
3285     if (typeof asValue === "string") {
3286       this.data.fieldValue = asValue;
3287     }
3288 
3289     const yes =
3290       this.data.fieldValue !== null && this.data.fieldValue !== "Off"
3291         ? this.data.fieldValue
3292         : "Yes";
3293 
3294     const exportValues = normalAppearance.getKeys();
3295     if (exportValues.length === 0) {
3296       exportValues.push("Off", yes);
3297     } else if (exportValues.length === 1) {
3298       if (exportValues[0] === "Off") {
3299         exportValues.push(yes);
3300       } else {
3301         exportValues.unshift("Off");
3302       }
3303     } else if (exportValues.includes(yes)) {
3304       exportValues.length = 0;
3305       exportValues.push("Off", yes);
3306     } else {
3307       const otherYes = exportValues.find(v => v !== "Off");
3308       exportValues.length = 0;
3309       exportValues.push("Off", otherYes);
3310     }
3311 
3312     // Don't use a "V" entry pointing to a non-existent appearance state,
3313     // see e.g. bug1720411.pdf where it's an *empty* Name-instance.
3314     if (!exportValues.includes(this.data.fieldValue)) {
3315       this.data.fieldValue = "Off";
3316     }
3317 
3318     this.data.exportValue = exportValues[1];
3319 
3320     const checkedAppearance = normalAppearance.get(this.data.exportValue);
3321     this.checkedAppearance =
3322       checkedAppearance instanceof BaseStream ? checkedAppearance : null;
3323     const uncheckedAppearance = normalAppearance.get("Off");
3324     this.uncheckedAppearance =
3325       uncheckedAppearance instanceof BaseStream ? uncheckedAppearance : null;
3326 
3327     if (this.checkedAppearance) {
3328       this._streams.push(this.checkedAppearance);
3329     } else {
3330       this._getDefaultCheckedAppearance(params, "check");
3331     }
3332     if (this.uncheckedAppearance) {
3333       this._streams.push(this.uncheckedAppearance);
3334     }
3335     this._fallbackFontDict = this.fallbackFontDict;
3336     if (this.data.defaultFieldValue === null) {
3337       this.data.defaultFieldValue = "Off";
3338     }
3339   }
3340 
3341   _processRadioButton(params) {
3342     this.data.buttonValue = null;
3343 
3344     // The parent field's `V` entry holds a `Name` object with the appearance
3345     // state of whichever child field is currently in the "on" state.
3346     const fieldParent = params.dict.get("Parent");
3347     if (fieldParent instanceof Dict) {
3348       this.parent = params.dict.getRaw("Parent");
3349       const fieldParentValue = fieldParent.get("V");
3350       if (fieldParentValue instanceof Name) {
3351         this.data.fieldValue = this._decodeFormValue(fieldParentValue);
3352       }
3353     }
3354 
3355     // The button's value corresponds to its appearance state.
3356     const appearanceStates = params.dict.get("AP");
3357     if (!(appearanceStates instanceof Dict)) {
3358       return;
3359     }
3360     const normalAppearance = appearanceStates.get("N");
3361     if (!(normalAppearance instanceof Dict)) {
3362       return;
3363     }
3364     for (const key of normalAppearance.getKeys()) {
3365       if (key !== "Off") {
3366         this.data.buttonValue = this._decodeFormValue(key);
3367         break;
3368       }
3369     }
3370 
3371     const checkedAppearance = normalAppearance.get(this.data.buttonValue);
3372     this.checkedAppearance =
3373       checkedAppearance instanceof BaseStream ? checkedAppearance : null;
3374     const uncheckedAppearance = normalAppearance.get("Off");
3375     this.uncheckedAppearance =
3376       uncheckedAppearance instanceof BaseStream ? uncheckedAppearance : null;
3377 
3378     if (this.checkedAppearance) {
3379       this._streams.push(this.checkedAppearance);
3380     } else {
3381       this._getDefaultCheckedAppearance(params, "disc");
3382     }
3383     if (this.uncheckedAppearance) {
3384       this._streams.push(this.uncheckedAppearance);
3385     }
3386     this._fallbackFontDict = this.fallbackFontDict;
3387     if (this.data.defaultFieldValue === null) {
3388       this.data.defaultFieldValue = "Off";
3389     }
3390   }
3391 
3392   _processPushButton(params) {
3393     const { dict, annotationGlobals } = params;
3394 
3395     if (!dict.has("A") && !dict.has("AA") && !this.data.alternativeText) {
3396       warn("Push buttons without action dictionaries are not supported");
3397       return;
3398     }
3399 
3400     this.data.isTooltipOnly = !dict.has("A") && !dict.has("AA");
3401 
3402     Catalog.parseDestDictionary({
3403       destDict: dict,
3404       resultObj: this.data,
3405       docBaseUrl: annotationGlobals.baseUrl,
3406       docAttachments: annotationGlobals.attachments,
3407     });
3408   }
3409 
3410   getFieldObject() {
3411     let type = "button";
3412     let exportValues;
3413     if (this.data.checkBox) {
3414       type = "checkbox";
3415       exportValues = this.data.exportValue;
3416     } else if (this.data.radioButton) {
3417       type = "radiobutton";
3418       exportValues = this.data.buttonValue;
3419     }
3420     return {
3421       id: this.data.id,
3422       value: this.data.fieldValue || "Off",
3423       defaultValue: this.data.defaultFieldValue,
3424       exportValues,
3425       editable: !this.data.readOnly,
3426       name: this.data.fieldName,
3427       rect: this.data.rect,
3428       hidden: this.data.hidden,
3429       actions: this.data.actions,
3430       page: this.data.pageIndex,
3431       strokeColor: this.data.borderColor,
3432       fillColor: this.data.backgroundColor,
3433       rotation: this.rotation,
3434       type,
3435     };
3436   }
3437 
3438   get fallbackFontDict() {
3439     const dict = new Dict();
3440     dict.set("BaseFont", Name.get("ZapfDingbats"));
3441     dict.set("Type", Name.get("FallbackType"));
3442     dict.set("Subtype", Name.get("FallbackType"));
3443     dict.set("Encoding", Name.get("ZapfDingbatsEncoding"));
3444 
3445     return shadow(this, "fallbackFontDict", dict);
3446   }
3447 }
3448 
3449 class ChoiceWidgetAnnotation extends WidgetAnnotation {
3450   constructor(params) {
3451     super(params);
3452 
3453     const { dict, xref } = params;
3454 
3455     this.indices = dict.getArray("I");
3456     this.hasIndices = Array.isArray(this.indices) && this.indices.length > 0;
3457 
3458     // Determine the options. The options array may consist of strings or
3459     // arrays. If the array consists of arrays, then the first element of
3460     // each array is the export value and the second element of each array is
3461     // the display value. If the array consists of strings, then these
3462     // represent both the export and display value. In this case, we convert
3463     // it to an array of arrays as well for convenience in the display layer.
3464     // Note that the specification does not state that the `Opt` field is
3465     // inheritable, but in practice PDF generators do make annotations
3466     // inherit the options from a parent annotation (issue 8094).
3467     this.data.options = [];
3468 
3469     const options = getInheritableProperty({ dict, key: "Opt" });
3470     if (Array.isArray(options)) {
3471       for (let i = 0, ii = options.length; i < ii; i++) {
3472         const option = xref.fetchIfRef(options[i]);
3473         const isOptionArray = Array.isArray(option);
3474 
3475         this.data.options[i] = {
3476           exportValue: this._decodeFormValue(
3477             isOptionArray ? xref.fetchIfRef(option[0]) : option
3478           ),
3479           displayValue: this._decodeFormValue(
3480             isOptionArray ? xref.fetchIfRef(option[1]) : option
3481           ),
3482         };
3483       }
3484     }
3485 
3486     if (!this.hasIndices) {
3487       // The field value can be `null` if no item is selected, a string if one
3488       // item is selected or an array of strings if multiple items are selected.
3489       // For consistency in the API and convenience in the display layer, we
3490       // always make the field value an array with zero, one or multiple items.
3491       if (typeof this.data.fieldValue === "string") {
3492         this.data.fieldValue = [this.data.fieldValue];
3493       } else if (!this.data.fieldValue) {
3494         this.data.fieldValue = [];
3495       }
3496     } else {
3497       // The specs say that we should have an indices array only with
3498       // multiselectable Choice and the "V" entry should have the
3499       // precedence, but Acrobat itself is using it whatever the
3500       // the "V" entry is (see bug 1770750).
3501       this.data.fieldValue = [];
3502       const ii = this.data.options.length;
3503       for (const i of this.indices) {
3504         if (Number.isInteger(i) && i >= 0 && i < ii) {
3505           this.data.fieldValue.push(this.data.options[i].exportValue);
3506         }
3507       }
3508     }
3509 
3510     // It's a workaround for the issue #19083.
3511     // Normally a choice widget is a mix of a text field and a listbox,
3512     // So in the case where the V entry isn't an option we should just set it
3513     // as the text field value.
3514     if (this.data.options.length === 0 && this.data.fieldValue.length > 0) {
3515       // If there are no options, then the field value is the only option.
3516       this.data.options = this.data.fieldValue.map(value => ({
3517         exportValue: value,
3518         displayValue: value,
3519       }));
3520     }
3521 
3522     // Process field flags for the display layer.
3523     this.data.combo = this.hasFieldFlag(AnnotationFieldFlag.COMBO);
3524     this.data.multiSelect = this.hasFieldFlag(AnnotationFieldFlag.MULTISELECT);
3525     this._hasText = true;
3526   }
3527 
3528   getFieldObject() {
3529     const type = this.data.combo ? "combobox" : "listbox";
3530     const value =
3531       this.data.fieldValue.length > 0 ? this.data.fieldValue[0] : null;
3532     return {
3533       id: this.data.id,
3534       value,
3535       defaultValue: this.data.defaultFieldValue,
3536       editable: !this.data.readOnly,
3537       name: this.data.fieldName,
3538       rect: this.data.rect,
3539       numItems: this.data.fieldValue.length,
3540       multipleSelection: this.data.multiSelect,
3541       hidden: this.data.hidden,
3542       actions: this.data.actions,
3543       items: this.data.options,
3544       page: this.data.pageIndex,
3545       strokeColor: this.data.borderColor,
3546       fillColor: this.data.backgroundColor,
3547       rotation: this.rotation,
3548       type,
3549     };
3550   }
3551 
3552   amendSavedDict(annotationStorage, dict) {
3553     if (!this.hasIndices) {
3554       return;
3555     }
3556     let values = annotationStorage?.get(this.data.id)?.value;
3557     if (!Array.isArray(values)) {
3558       values = [values];
3559     }
3560     const indices = [];
3561     const { options } = this.data;
3562     for (let i = 0, j = 0, ii = options.length; i < ii; i++) {
3563       if (options[i].exportValue === values[j]) {
3564         indices.push(i);
3565         j += 1;
3566       }
3567     }
3568     dict.set("I", indices);
3569   }
3570 
3571   async _getAppearance(evaluator, task, intent, annotationStorage) {
3572     if (this.data.combo) {
3573       return super._getAppearance(evaluator, task, intent, annotationStorage);
3574     }
3575 
3576     let exportedValue, rotation;
3577     const storageEntry = annotationStorage?.get(this.data.id);
3578     if (storageEntry) {
3579       rotation = storageEntry.rotation;
3580       exportedValue = storageEntry.value;
3581     }
3582 
3583     if (
3584       rotation === undefined &&
3585       exportedValue === undefined &&
3586       !this._needAppearances
3587     ) {
3588       // The annotation hasn't been rendered so use the appearance
3589       return null;
3590     }
3591 
3592     if (exportedValue === undefined) {
3593       exportedValue = this.data.fieldValue;
3594     } else if (!Array.isArray(exportedValue)) {
3595       exportedValue = [exportedValue];
3596     }
3597 
3598     const defaultPadding = 1;
3599     const defaultHPadding = 2;
3600     let totalHeight = this.data.rect[3] - this.data.rect[1];
3601     let totalWidth = this.data.rect[2] - this.data.rect[0];
3602 
3603     if (rotation === 90 || rotation === 270) {
3604       [totalWidth, totalHeight] = [totalHeight, totalWidth];
3605     }
3606 
3607     const lineCount = this.data.options.length;
3608     const valueIndices = [];
3609     for (let i = 0; i < lineCount; i++) {
3610       const { exportValue } = this.data.options[i];
3611       if (exportedValue.includes(exportValue)) {
3612         valueIndices.push(i);
3613       }
3614     }
3615 
3616     if (!this._defaultAppearance) {
3617       // The DA is required and must be a string.
3618       // If there is no font named Helvetica in the resource dictionary,
3619       // the evaluator will fall back to a default font.
3620       // Doing so prevents exceptions and allows saving/printing
3621       // the file as expected.
3622       this.data.defaultAppearanceData = parseDefaultAppearance(
3623         (this._defaultAppearance = "/Helvetica 0 Tf 0 g")
3624       );
3625     }
3626 
3627     const font = await WidgetAnnotation._getFontData(
3628       evaluator,
3629       task,
3630       this.data.defaultAppearanceData,
3631       this._fieldResources.mergedResources
3632     );
3633 
3634     let defaultAppearance;
3635     let { fontSize } = this.data.defaultAppearanceData;
3636     if (!fontSize) {
3637       const lineHeight = (totalHeight - defaultPadding) / lineCount;
3638       let lineWidth = -1;
3639       let value;
3640       for (const { displayValue } of this.data.options) {
3641         const width = this._getTextWidth(displayValue, font);
3642         if (width > lineWidth) {
3643           lineWidth = width;
3644           value = displayValue;
3645         }
3646       }
3647 
3648       [defaultAppearance, fontSize] = this._computeFontSize(
3649         lineHeight,
3650         totalWidth - 2 * defaultHPadding,
3651         value,
3652         font,
3653         -1
3654       );
3655     } else {
3656       defaultAppearance = this._defaultAppearance;
3657     }
3658 
3659     const lineHeight = fontSize * LINE_FACTOR;
3660     const vPadding = (lineHeight - fontSize) / 2;
3661     const numberOfVisibleLines = Math.floor(totalHeight / lineHeight);
3662 
3663     let firstIndex = 0;
3664     if (valueIndices.length > 0) {
3665       const minIndex = Math.min(...valueIndices);
3666       const maxIndex = Math.max(...valueIndices);
3667 
3668       firstIndex = Math.max(0, maxIndex - numberOfVisibleLines + 1);
3669       if (firstIndex > minIndex) {
3670         firstIndex = minIndex;
3671       }
3672     }
3673     const end = Math.min(firstIndex + numberOfVisibleLines + 1, lineCount);
3674 
3675     const buf = ["/Tx BMC q", `1 1 ${totalWidth} ${totalHeight} re W n`];
3676 
3677     if (valueIndices.length) {
3678       // This value has been copied/pasted from annotation-choice-widget.pdf.
3679       // It corresponds to rgb(153, 193, 218).
3680       buf.push("0.600006 0.756866 0.854904 rg");
3681 
3682       // Highlight the lines in filling a blue rectangle at the selected
3683       // positions.
3684       for (const index of valueIndices) {
3685         if (firstIndex <= index && index < end) {
3686           buf.push(
3687             `1 ${
3688               totalHeight - (index - firstIndex + 1) * lineHeight
3689             } ${totalWidth} ${lineHeight} re f`
3690           );
3691         }
3692       }
3693     }
3694     buf.push("BT", defaultAppearance, `1 0 0 1 0 ${totalHeight} Tm`);
3695 
3696     const prevInfo = { shift: 0 };
3697     for (let i = firstIndex; i < end; i++) {
3698       const { displayValue } = this.data.options[i];
3699       const vpadding = i === firstIndex ? vPadding : 0;
3700       buf.push(
3701         this._renderText(
3702           displayValue,
3703           font,
3704           fontSize,
3705           totalWidth,
3706           0,
3707           prevInfo,
3708           defaultHPadding,
3709           -lineHeight + vpadding
3710         )
3711       );
3712     }
3713 
3714     buf.push("ET Q EMC");
3715 
3716     return buf.join("\n");
3717   }
3718 }
3719 
3720 class SignatureWidgetAnnotation extends WidgetAnnotation {
3721   constructor(params) {
3722     super(params);
3723 
3724     // Unset the fieldValue since it's (most likely) a `Dict` which is
3725     // non-serializable and will thus cause errors when sending annotations
3726     // to the main-thread (issue 10347).
3727     this.data.fieldValue = null;
3728     this.data.hasOwnCanvas = this.data.noRotate;
3729     this.data.noHTML = !this.data.hasOwnCanvas;
3730   }
3731 
3732   getFieldObject() {
3733     return {
3734       id: this.data.id,
3735       value: null,
3736       page: this.data.pageIndex,
3737       type: "signature",
3738     };
3739   }
3740 }
3741 
3742 class TextAnnotation extends MarkupAnnotation {
3743   constructor(params) {
3744     const DEFAULT_ICON_SIZE = 22; // px
3745 
3746     super(params);
3747 
3748     // No rotation for Text (see 12.5.6.4).
3749     this.data.noRotate = true;
3750     this.data.hasOwnCanvas = this.data.noRotate;
3751     this.data.noHTML = false;
3752 
3753     const { dict } = params;
3754     this.data.annotationType = AnnotationType.TEXT;
3755 
3756     if (this.data.hasAppearance) {
3757       this.data.name = "NoIcon";
3758     } else {
3759       this.data.rect[1] = this.data.rect[3] - DEFAULT_ICON_SIZE;
3760       this.data.rect[2] = this.data.rect[0] + DEFAULT_ICON_SIZE;
3761       this.data.name = dict.has("Name") ? dict.get("Name").name : "Note";
3762     }
3763 
3764     if (dict.has("State")) {
3765       this.data.state = dict.get("State") || null;
3766       this.data.stateModel = dict.get("StateModel") || null;
3767     } else {
3768       this.data.state = null;
3769       this.data.stateModel = null;
3770     }
3771   }
3772 }
3773 
3774 class LinkAnnotation extends Annotation {
3775   constructor(params) {
3776     super(params);
3777 
3778     const { dict, annotationGlobals } = params;
3779     this.data.annotationType = AnnotationType.LINK;
3780 
3781     // A link is never rendered on the main canvas so we must render its HTML
3782     // version.
3783     this.data.noHTML = false;
3784 
3785     const quadPoints = getQuadPoints(dict, this.rectangle);
3786     if (quadPoints) {
3787       this.data.quadPoints = quadPoints;
3788     }
3789 
3790     // The color entry for a link annotation is the color of the border.
3791     this.data.borderColor ||= this.data.color;
3792 
3793     Catalog.parseDestDictionary({
3794       destDict: dict,
3795       resultObj: this.data,
3796       docBaseUrl: annotationGlobals.baseUrl,
3797       docAttachments: annotationGlobals.attachments,
3798     });
3799   }
3800 }
3801 
3802 class PopupAnnotation extends Annotation {
3803   constructor(params) {
3804     super(params);
3805 
3806     const { dict } = params;
3807     this.data.annotationType = AnnotationType.POPUP;
3808 
3809     // A pop-up is never rendered on the main canvas so we must render its HTML
3810     // version.
3811     this.data.noHTML = false;
3812 
3813     if (
3814       this.data.rect[0] === this.data.rect[2] ||
3815       this.data.rect[1] === this.data.rect[3]
3816     ) {
3817       this.data.rect = null;
3818     }
3819 
3820     let parentItem = dict.get("Parent");
3821     if (!parentItem) {
3822       warn("Popup annotation has a missing or invalid parent annotation.");
3823       return;
3824     }
3825     this.data.parentRect = lookupNormalRect(parentItem.getArray("Rect"), null);
3826 
3827     const rt = parentItem.get("RT");
3828     if (isName(rt, AnnotationReplyType.GROUP)) {
3829       // Subordinate annotations in a group should inherit
3830       // the group attributes from the primary annotation.
3831       parentItem = parentItem.get("IRT");
3832     }
3833 
3834     if (!parentItem.has("M")) {
3835       this.data.modificationDate = null;
3836     } else {
3837       this.setModificationDate(parentItem.get("M"));
3838       this.data.modificationDate = this.modificationDate;
3839     }
3840 
3841     if (!parentItem.has("C")) {
3842       // Fall back to the default background color.
3843       this.data.color = null;
3844     } else {
3845       this.setColor(parentItem.getArray("C"));
3846       this.data.color = this.color;
3847     }
3848 
3849     // If the Popup annotation is not viewable, but the parent annotation is,
3850     // that is most likely a bug. Fallback to inherit the flags from the parent
3851     // annotation (this is consistent with the behaviour in Adobe Reader).
3852     if (!this.viewable) {
3853       const parentFlags = parentItem.get("F");
3854       if (this._isViewable(parentFlags)) {
3855         this.setFlags(parentFlags);
3856       }
3857     }
3858 
3859     this.setTitle(parentItem.get("T"));
3860     this.data.titleObj = this._title;
3861 
3862     this.setContents(parentItem.get("Contents"));
3863     this.data.contentsObj = this._contents;
3864 
3865     if (parentItem.has("RC")) {
3866       this.data.richText = XFAFactory.getRichTextAsHtml(parentItem.get("RC"));
3867     }
3868 
3869     this.data.open = !!dict.get("Open");
3870   }
3871 }
3872 
3873 class FreeTextAnnotation extends MarkupAnnotation {
3874   constructor(params) {
3875     super(params);
3876 
3877     // It uses its own canvas in order to be hidden if edited.
3878     // But if it has the noHTML flag, it means that we don't want to be able
3879     // to modify it so we can just draw it on the main canvas.
3880     this.data.hasOwnCanvas = this.data.noRotate;
3881     this.data.isEditable = !this.data.noHTML;
3882     // We want to be able to add mouse listeners to the annotation.
3883     this.data.noHTML = false;
3884 
3885     const { evaluatorOptions, xref } = params;
3886     this.data.annotationType = AnnotationType.FREETEXT;
3887     this.setDefaultAppearance(params);
3888     this._hasAppearance = !!this.appearance;
3889 
3890     if (this._hasAppearance) {
3891       const { fontColor, fontSize } = parseAppearanceStream(
3892         this.appearance,
3893         evaluatorOptions,
3894         xref
3895       );
3896       this.data.defaultAppearanceData.fontColor = fontColor;
3897       this.data.defaultAppearanceData.fontSize = fontSize || 10;
3898     } else {
3899       this.data.defaultAppearanceData.fontSize ||= 10;
3900       const { fontColor, fontSize } = this.data.defaultAppearanceData;
3901       if (this._contents.str) {
3902         this.data.textContent = this._contents.str
3903           .split(/\r\n?|\n/)
3904           .map(line => line.trimEnd());
3905         const { coords, bbox, matrix } = FakeUnicodeFont.getFirstPositionInfo(
3906           this.rectangle,
3907           this.rotation,
3908           fontSize
3909         );
3910         this.data.textPosition = this._transformPoint(coords, bbox, matrix);
3911       }
3912       if (this._isOffscreenCanvasSupported) {
3913         const strokeAlpha = params.dict.get("CA");
3914         const fakeUnicodeFont = new FakeUnicodeFont(xref, "sans-serif");
3915         this.appearance = fakeUnicodeFont.createAppearance(
3916           this._contents.str,
3917           this.rectangle,
3918           this.rotation,
3919           fontSize,
3920           fontColor,
3921           strokeAlpha
3922         );
3923         this._streams.push(this.appearance);
3924       } else {
3925         warn(
3926           "FreeTextAnnotation: OffscreenCanvas is not supported, annotation may not render correctly."
3927         );
3928       }
3929     }
3930   }
3931 
3932   get hasTextContent() {
3933     return this._hasAppearance;
3934   }
3935 
3936   static createNewDict(annotation, xref, { apRef, ap }) {
3937     const { color, fontSize, oldAnnotation, rect, rotation, user, value } =
3938       annotation;
3939     const freetext = oldAnnotation || new Dict(xref);
3940     freetext.set("Type", Name.get("Annot"));
3941     freetext.set("Subtype", Name.get("FreeText"));
3942     if (oldAnnotation) {
3943       freetext.set("M", `D:${getModificationDate()}`);
3944       // TODO: We should try to generate a new RC from the content we've.
3945       // For now we can just remove it to avoid any issues.
3946       freetext.delete("RC");
3947     } else {
3948       freetext.set("CreationDate", `D:${getModificationDate()}`);
3949     }
3950     freetext.set("Rect", rect);
3951     const da = `/Helv ${fontSize} Tf ${getPdfColor(color, /* isFill */ true)}`;
3952     freetext.set("DA", da);
3953     freetext.set("Contents", stringToAsciiOrUTF16BE(value));
3954     freetext.set("F", 4);
3955     freetext.set("Border", [0, 0, 0]);
3956     freetext.set("Rotate", rotation);
3957 
3958     if (user) {
3959       freetext.set("T", stringToAsciiOrUTF16BE(user));
3960     }
3961 
3962     if (apRef || ap) {
3963       const n = new Dict(xref);
3964       freetext.set("AP", n);
3965 
3966       if (apRef) {
3967         n.set("N", apRef);
3968       } else {
3969         n.set("N", ap);
3970       }
3971     }
3972 
3973     return freetext;
3974   }
3975 
3976   static async createNewAppearanceStream(annotation, xref, params) {
3977     const { baseFontRef, evaluator, task } = params;
3978     const { color, fontSize, rect, rotation, value } = annotation;
3979 
3980     const resources = new Dict(xref);
3981     const font = new Dict(xref);
3982 
3983     if (baseFontRef) {
3984       font.set("Helv", baseFontRef);
3985     } else {
3986       const baseFont = new Dict(xref);
3987       baseFont.set("BaseFont", Name.get("Helvetica"));
3988       baseFont.set("Type", Name.get("Font"));
3989       baseFont.set("Subtype", Name.get("Type1"));
3990       baseFont.set("Encoding", Name.get("WinAnsiEncoding"));
3991       font.set("Helv", baseFont);
3992     }
3993     resources.set("Font", font);
3994 
3995     const helv = await WidgetAnnotation._getFontData(
3996       evaluator,
3997       task,
3998       {
3999         fontName: "Helv",
4000         fontSize,
4001       },
4002       resources
4003     );
4004 
4005     const [x1, y1, x2, y2] = rect;
4006     let w = x2 - x1;
4007     let h = y2 - y1;
4008 
4009     if (rotation % 180 !== 0) {
4010       [w, h] = [h, w];
4011     }
4012 
4013     const lines = value.split("\n");
4014     const scale = fontSize / 1000;
4015     let totalWidth = -Infinity;
4016     const encodedLines = [];
4017     for (let line of lines) {
4018       const encoded = helv.encodeString(line);
4019       if (encoded.length > 1) {
4020         // The font doesn't contain all the chars.
4021         return null;
4022       }
4023       line = encoded.join("");
4024       encodedLines.push(line);
4025       let lineWidth = 0;
4026       const glyphs = helv.charsToGlyphs(line);
4027       for (const glyph of glyphs) {
4028         lineWidth += glyph.width * scale;
4029       }
4030       totalWidth = Math.max(totalWidth, lineWidth);
4031     }
4032 
4033     let hscale = 1;
4034     if (totalWidth > w) {
4035       hscale = w / totalWidth;
4036     }
4037     let vscale = 1;
4038     const lineHeight = LINE_FACTOR * fontSize;
4039     const lineAscent = (LINE_FACTOR - LINE_DESCENT_FACTOR) * fontSize;
4040     const totalHeight = lineHeight * lines.length;
4041     if (totalHeight > h) {
4042       vscale = h / totalHeight;
4043     }
4044     const fscale = Math.min(hscale, vscale);
4045     const newFontSize = fontSize * fscale;
4046     let firstPoint, clipBox, matrix;
4047     switch (rotation) {
4048       case 0:
4049         matrix = [1, 0, 0, 1];
4050         clipBox = [rect[0], rect[1], w, h];
4051         firstPoint = [rect[0], rect[3] - lineAscent];
4052         break;
4053       case 90:
4054         matrix = [0, 1, -1, 0];
4055         clipBox = [rect[1], -rect[2], w, h];
4056         firstPoint = [rect[1], -rect[0] - lineAscent];
4057         break;
4058       case 180:
4059         matrix = [-1, 0, 0, -1];
4060         clipBox = [-rect[2], -rect[3], w, h];
4061         firstPoint = [-rect[2], -rect[1] - lineAscent];
4062         break;
4063       case 270:
4064         matrix = [0, -1, 1, 0];
4065         clipBox = [-rect[3], rect[0], w, h];
4066         firstPoint = [-rect[3], rect[2] - lineAscent];
4067         break;
4068     }
4069 
4070     const buffer = [
4071       "q",
4072       `${matrix.join(" ")} 0 0 cm`,
4073       `${clipBox.join(" ")} re W n`,
4074       `BT`,
4075       `${getPdfColor(color, /* isFill */ true)}`,
4076       `0 Tc /Helv ${numberToString(newFontSize)} Tf`,
4077     ];
4078 
4079     buffer.push(
4080       `${firstPoint.join(" ")} Td (${escapeString(encodedLines[0])}) Tj`
4081     );
4082     const vShift = numberToString(lineHeight);
4083     for (let i = 1, ii = encodedLines.length; i < ii; i++) {
4084       const line = encodedLines[i];
4085       buffer.push(`0 -${vShift} Td (${escapeString(line)}) Tj`);
4086     }
4087     buffer.push("ET", "Q");
4088     const appearance = buffer.join("\n");
4089 
4090     const appearanceStreamDict = new Dict(xref);
4091     appearanceStreamDict.set("FormType", 1);
4092     appearanceStreamDict.set("Subtype", Name.get("Form"));
4093     appearanceStreamDict.set("Type", Name.get("XObject"));
4094     appearanceStreamDict.set("BBox", rect);
4095     appearanceStreamDict.set("Resources", resources);
4096     appearanceStreamDict.set("Matrix", [1, 0, 0, 1, -rect[0], -rect[1]]);
4097 
4098     const ap = new StringStream(appearance);
4099     ap.dict = appearanceStreamDict;
4100 
4101     return ap;
4102   }
4103 }
4104 
4105 class LineAnnotation extends MarkupAnnotation {
4106   constructor(params) {
4107     super(params);
4108 
4109     const { dict, xref } = params;
4110     this.data.annotationType = AnnotationType.LINE;
4111     this.data.hasOwnCanvas = this.data.noRotate;
4112     this.data.noHTML = false;
4113 
4114     const lineCoordinates = lookupRect(dict.getArray("L"), [0, 0, 0, 0]);
4115     this.data.lineCoordinates = Util.normalizeRect(lineCoordinates);
4116 
4117     if (typeof PDFJSDev === "undefined" || !PDFJSDev.test("MOZCENTRAL")) {
4118       this.setLineEndings(dict.getArray("LE"));
4119       this.data.lineEndings = this.lineEndings;
4120     }
4121 
4122     if (!this.appearance) {
4123       // The default stroke color is black.
4124       const strokeColor = this.color ? getPdfColorArray(this.color) : [0, 0, 0];
4125       const strokeAlpha = dict.get("CA");
4126 
4127       const interiorColor = getRgbColor(dict.getArray("IC"), null);
4128       // The default fill color is transparent. Setting the fill colour is
4129       // necessary if/when we want to add support for non-default line endings.
4130       const fillColor = interiorColor ? getPdfColorArray(interiorColor) : null;
4131       const fillAlpha = fillColor ? strokeAlpha : null;
4132 
4133       const borderWidth = this.borderStyle.width || 1,
4134         borderAdjust = 2 * borderWidth;
4135 
4136       // If the /Rect-entry is empty/wrong, create a fallback rectangle so that
4137       // we get similar rendering/highlighting behaviour as in Adobe Reader.
4138       const bbox = [
4139         this.data.lineCoordinates[0] - borderAdjust,
4140         this.data.lineCoordinates[1] - borderAdjust,
4141         this.data.lineCoordinates[2] + borderAdjust,
4142         this.data.lineCoordinates[3] + borderAdjust,
4143       ];
4144       if (!Util.intersect(this.rectangle, bbox)) {
4145         this.rectangle = bbox;
4146       }
4147 
4148       this._setDefaultAppearance({
4149         xref,
4150         extra: `${borderWidth} w`,
4151         strokeColor,
4152         fillColor,
4153         strokeAlpha,
4154         fillAlpha,
4155         pointsCallback: (buffer, points) => {
4156           buffer.push(
4157             `${lineCoordinates[0]} ${lineCoordinates[1]} m`,
4158             `${lineCoordinates[2]} ${lineCoordinates[3]} l`,
4159             "S"
4160           );
4161           return [
4162             points[0] - borderWidth,
4163             points[2] + borderWidth,
4164             points[7] - borderWidth,
4165             points[3] + borderWidth,
4166           ];
4167         },
4168       });
4169     }
4170   }
4171 }
4172 
4173 class SquareAnnotation extends MarkupAnnotation {
4174   constructor(params) {
4175     super(params);
4176 
4177     const { dict, xref } = params;
4178     this.data.annotationType = AnnotationType.SQUARE;
4179     this.data.hasOwnCanvas = this.data.noRotate;
4180     this.data.noHTML = false;
4181 
4182     if (!this.appearance) {
4183       // The default stroke color is black.
4184       const strokeColor = this.color ? getPdfColorArray(this.color) : [0, 0, 0];
4185       const strokeAlpha = dict.get("CA");
4186 
4187       const interiorColor = getRgbColor(dict.getArray("IC"), null);
4188       // The default fill color is transparent.
4189       const fillColor = interiorColor ? getPdfColorArray(interiorColor) : null;
4190       const fillAlpha = fillColor ? strokeAlpha : null;
4191 
4192       if (this.borderStyle.width === 0 && !fillColor) {
4193         // Prevent rendering a "hairline" border (fixes issue14164.pdf).
4194         return;
4195       }
4196 
4197       this._setDefaultAppearance({
4198         xref,
4199         extra: `${this.borderStyle.width} w`,
4200         strokeColor,
4201         fillColor,
4202         strokeAlpha,
4203         fillAlpha,
4204         pointsCallback: (buffer, points) => {
4205           const x = points[4] + this.borderStyle.width / 2;
4206           const y = points[5] + this.borderStyle.width / 2;
4207           const width = points[6] - points[4] - this.borderStyle.width;
4208           const height = points[3] - points[7] - this.borderStyle.width;
4209           buffer.push(`${x} ${y} ${width} ${height} re`);
4210           if (fillColor) {
4211             buffer.push("B");
4212           } else {
4213             buffer.push("S");
4214           }
4215           return [points[0], points[2], points[7], points[3]];
4216         },
4217       });
4218     }
4219   }
4220 }
4221 
4222 class CircleAnnotation extends MarkupAnnotation {
4223   constructor(params) {
4224     super(params);
4225 
4226     const { dict, xref } = params;
4227     this.data.annotationType = AnnotationType.CIRCLE;
4228 
4229     if (!this.appearance) {
4230       // The default stroke color is black.
4231       const strokeColor = this.color ? getPdfColorArray(this.color) : [0, 0, 0];
4232       const strokeAlpha = dict.get("CA");
4233 
4234       const interiorColor = getRgbColor(dict.getArray("IC"), null);
4235       // The default fill color is transparent.
4236       const fillColor = interiorColor ? getPdfColorArray(interiorColor) : null;
4237       const fillAlpha = fillColor ? strokeAlpha : null;
4238 
4239       if (this.borderStyle.width === 0 && !fillColor) {
4240         // Prevent rendering a "hairline" border (fixes issue14164.pdf).
4241         return;
4242       }
4243 
4244       // Circles are approximated by Bézier curves with four segments since
4245       // there is no circle primitive in the PDF specification. For the control
4246       // points distance, see https://stackoverflow.com/a/27863181.
4247       const controlPointsDistance = (4 / 3) * Math.tan(Math.PI / (2 * 4));
4248 
4249       this._setDefaultAppearance({
4250         xref,
4251         extra: `${this.borderStyle.width} w`,
4252         strokeColor,
4253         fillColor,
4254         strokeAlpha,
4255         fillAlpha,
4256         pointsCallback: (buffer, points) => {
4257           const x0 = points[0] + this.borderStyle.width / 2;
4258           const y0 = points[1] - this.borderStyle.width / 2;
4259           const x1 = points[6] - this.borderStyle.width / 2;
4260           const y1 = points[7] + this.borderStyle.width / 2;
4261           const xMid = x0 + (x1 - x0) / 2;
4262           const yMid = y0 + (y1 - y0) / 2;
4263           const xOffset = ((x1 - x0) / 2) * controlPointsDistance;
4264           const yOffset = ((y1 - y0) / 2) * controlPointsDistance;
4265 
4266           buffer.push(
4267             `${xMid} ${y1} m`,
4268             `${xMid + xOffset} ${y1} ${x1} ${yMid + yOffset} ${x1} ${yMid} c`,
4269             `${x1} ${yMid - yOffset} ${xMid + xOffset} ${y0} ${xMid} ${y0} c`,
4270             `${xMid - xOffset} ${y0} ${x0} ${yMid - yOffset} ${x0} ${yMid} c`,
4271             `${x0} ${yMid + yOffset} ${xMid - xOffset} ${y1} ${xMid} ${y1} c`,
4272             "h"
4273           );
4274           if (fillColor) {
4275             buffer.push("B");
4276           } else {
4277             buffer.push("S");
4278           }
4279           return [points[0], points[2], points[7], points[3]];
4280         },
4281       });
4282     }
4283   }
4284 }
4285 
4286 class PolylineAnnotation extends MarkupAnnotation {
4287   constructor(params) {
4288     super(params);
4289 
4290     const { dict, xref } = params;
4291     this.data.annotationType = AnnotationType.POLYLINE;
4292     this.data.hasOwnCanvas = this.data.noRotate;
4293     this.data.noHTML = false;
4294     this.data.vertices = null;
4295 
4296     if (
4297       (typeof PDFJSDev === "undefined" || !PDFJSDev.test("MOZCENTRAL")) &&
4298       !(this instanceof PolygonAnnotation)
4299     ) {
4300       // Only meaningful for polyline annotations.
4301       this.setLineEndings(dict.getArray("LE"));
4302       this.data.lineEndings = this.lineEndings;
4303     }
4304 
4305     // The vertices array is an array of numbers representing the alternating
4306     // horizontal and vertical coordinates, respectively, of each vertex.
4307     // Convert this to an array of objects with x and y coordinates.
4308     const rawVertices = dict.getArray("Vertices");
4309     if (!isNumberArray(rawVertices, null)) {
4310       return;
4311     }
4312     const vertices = (this.data.vertices = Float32Array.from(rawVertices));
4313 
4314     if (!this.appearance) {
4315       // The default stroke color is black.
4316       const strokeColor = this.color ? getPdfColorArray(this.color) : [0, 0, 0];
4317       const strokeAlpha = dict.get("CA");
4318 
4319       const borderWidth = this.borderStyle.width || 1,
4320         borderAdjust = 2 * borderWidth;
4321 
4322       // If the /Rect-entry is empty/wrong, create a fallback rectangle so that
4323       // we get similar rendering/highlighting behaviour as in Adobe Reader.
4324       const bbox = [Infinity, Infinity, -Infinity, -Infinity];
4325       for (let i = 0, ii = vertices.length; i < ii; i += 2) {
4326         bbox[0] = Math.min(bbox[0], vertices[i] - borderAdjust);
4327         bbox[1] = Math.min(bbox[1], vertices[i + 1] - borderAdjust);
4328         bbox[2] = Math.max(bbox[2], vertices[i] + borderAdjust);
4329         bbox[3] = Math.max(bbox[3], vertices[i + 1] + borderAdjust);
4330       }
4331       if (!Util.intersect(this.rectangle, bbox)) {
4332         this.rectangle = bbox;
4333       }
4334 
4335       this._setDefaultAppearance({
4336         xref,
4337         extra: `${borderWidth} w`,
4338         strokeColor,
4339         strokeAlpha,
4340         pointsCallback: (buffer, points) => {
4341           for (let i = 0, ii = vertices.length; i < ii; i += 2) {
4342             buffer.push(
4343               `${vertices[i]} ${vertices[i + 1]} ${i === 0 ? "m" : "l"}`
4344             );
4345           }
4346           buffer.push("S");
4347           return [points[0], points[2], points[7], points[3]];
4348         },
4349       });
4350     }
4351   }
4352 }
4353 
4354 class PolygonAnnotation extends PolylineAnnotation {
4355   constructor(params) {
4356     // Polygons are specific forms of polylines, so reuse their logic.
4357     super(params);
4358 
4359     this.data.annotationType = AnnotationType.POLYGON;
4360   }
4361 }
4362 
4363 class CaretAnnotation extends MarkupAnnotation {
4364   constructor(params) {
4365     super(params);
4366 
4367     this.data.annotationType = AnnotationType.CARET;
4368   }
4369 }
4370 
4371 class InkAnnotation extends MarkupAnnotation {
4372   constructor(params) {
4373     super(params);
4374 
4375     this.data.hasOwnCanvas = this.data.noRotate;
4376     this.data.noHTML = false;
4377 
4378     const { dict, xref } = params;
4379     this.data.annotationType = AnnotationType.INK;
4380     this.data.inkLists = [];
4381     this.data.isEditable = !this.data.noHTML;
4382     // We want to be able to add mouse listeners to the annotation.
4383     this.data.noHTML = false;
4384     this.data.opacity = dict.get("CA") || 1;
4385 
4386     const rawInkLists = dict.getArray("InkList");
4387     if (!Array.isArray(rawInkLists)) {
4388       return;
4389     }
4390     for (let i = 0, ii = rawInkLists.length; i < ii; ++i) {
4391       // The raw ink lists array contains arrays of numbers representing
4392       // the alternating horizontal and vertical coordinates, respectively,
4393       // of each vertex. Convert this to an array of objects with x and y
4394       // coordinates.
4395       if (!Array.isArray(rawInkLists[i])) {
4396         continue;
4397       }
4398       const inkList = new Float32Array(rawInkLists[i].length);
4399       this.data.inkLists.push(inkList);
4400       for (let j = 0, jj = rawInkLists[i].length; j < jj; j += 2) {
4401         const x = xref.fetchIfRef(rawInkLists[i][j]),
4402           y = xref.fetchIfRef(rawInkLists[i][j + 1]);
4403         if (typeof x === "number" && typeof y === "number") {
4404           inkList[j] = x;
4405           inkList[j + 1] = y;
4406         }
4407       }
4408     }
4409 
4410     if (!this.appearance) {
4411       // The default stroke color is black.
4412       const strokeColor = this.color ? getPdfColorArray(this.color) : [0, 0, 0];
4413       const strokeAlpha = dict.get("CA");
4414 
4415       const borderWidth = this.borderStyle.width || 1,
4416         borderAdjust = 2 * borderWidth;
4417 
4418       // If the /Rect-entry is empty/wrong, create a fallback rectangle so that
4419       // we get similar rendering/highlighting behaviour as in Adobe Reader.
4420       const bbox = [Infinity, Infinity, -Infinity, -Infinity];
4421       for (const inkList of this.data.inkLists) {
4422         for (let i = 0, ii = inkList.length; i < ii; i += 2) {
4423           bbox[0] = Math.min(bbox[0], inkList[i] - borderAdjust);
4424           bbox[1] = Math.min(bbox[1], inkList[i + 1] - borderAdjust);
4425           bbox[2] = Math.max(bbox[2], inkList[i] + borderAdjust);
4426           bbox[3] = Math.max(bbox[3], inkList[i + 1] + borderAdjust);
4427         }
4428       }
4429       if (!Util.intersect(this.rectangle, bbox)) {
4430         this.rectangle = bbox;
4431       }
4432 
4433       this._setDefaultAppearance({
4434         xref,
4435         extra: `${borderWidth} w`,
4436         strokeColor,
4437         strokeAlpha,
4438         pointsCallback: (buffer, points) => {
4439           // According to the specification, see "12.5.6.13 Ink Annotations":
4440           //   When drawn, the points shall be connected by straight lines or
4441           //   curves in an implementation-dependent way.
4442           // In order to simplify things, we utilize straight lines for now.
4443           for (const inkList of this.data.inkLists) {
4444             for (let i = 0, ii = inkList.length; i < ii; i += 2) {
4445               buffer.push(
4446                 `${inkList[i]} ${inkList[i + 1]} ${i === 0 ? "m" : "l"}`
4447               );
4448             }
4449             buffer.push("S");
4450           }
4451           return [points[0], points[2], points[7], points[3]];
4452         },
4453       });
4454     }
4455   }
4456 
4457   static createNewDict(annotation, xref, { apRef, ap }) {
4458     const {
4459       oldAnnotation,
4460       color,
4461       opacity,
4462       paths,
4463       outlines,
4464       rect,
4465       rotation,
4466       thickness,
4467       user,
4468     } = annotation;
4469     const ink = oldAnnotation || new Dict(xref);
4470     ink.set("Type", Name.get("Annot"));
4471     ink.set("Subtype", Name.get("Ink"));
4472     ink.set(oldAnnotation ? "M" : "CreationDate", `D:${getModificationDate()}`);
4473     ink.set("Rect", rect);
4474     ink.set("InkList", outlines?.points || paths.points);
4475     ink.set("F", 4);
4476     ink.set("Rotate", rotation);
4477 
4478     if (user) {
4479       ink.set("T", stringToAsciiOrUTF16BE(user));
4480     }
4481 
4482     if (outlines) {
4483       // Free highlight.
4484       // There's nothing about this in the spec, but it's used when highlighting
4485       // in Edge's viewer. Acrobat takes into account this parameter to indicate
4486       // that the Ink is used for highlighting.
4487       ink.set("IT", Name.get("InkHighlight"));
4488     }
4489 
4490     // Line thickness.
4491     const bs = new Dict(xref);
4492     ink.set("BS", bs);
4493     bs.set("W", thickness);
4494 
4495     // Color.
4496     ink.set(
4497       "C",
4498       Array.from(color, c => c / 255)
4499     );
4500 
4501     // Opacity.
4502     ink.set("CA", opacity);
4503 
4504     const n = new Dict(xref);
4505     ink.set("AP", n);
4506 
4507     if (apRef) {
4508       n.set("N", apRef);
4509     } else {
4510       n.set("N", ap);
4511     }
4512 
4513     return ink;
4514   }
4515 
4516   static async createNewAppearanceStream(annotation, xref, params) {
4517     if (annotation.outlines) {
4518       return this.createNewAppearanceStreamForHighlight(
4519         annotation,
4520         xref,
4521         params
4522       );
4523     }
4524     const { color, rect, paths, thickness, opacity } = annotation;
4525 
4526     const appearanceBuffer = [
4527       `${thickness} w 1 J 1 j`,
4528       `${getPdfColor(color, /* isFill */ false)}`,
4529     ];
4530 
4531     if (opacity !== 1) {
4532       appearanceBuffer.push("/R0 gs");
4533     }
4534 
4535     for (const outline of paths.lines) {
4536       appearanceBuffer.push(
4537         `${numberToString(outline[4])} ${numberToString(outline[5])} m`
4538       );
4539       for (let i = 6, ii = outline.length; i < ii; i += 6) {
4540         if (isNaN(outline[i])) {
4541           appearanceBuffer.push(
4542             `${numberToString(outline[i + 4])} ${numberToString(
4543               outline[i + 5]
4544             )} l`
4545           );
4546         } else {
4547           const [c1x, c1y, c2x, c2y, x, y] = outline.slice(i, i + 6);
4548           appearanceBuffer.push(
4549             [c1x, c1y, c2x, c2y, x, y].map(numberToString).join(" ") + " c"
4550           );
4551         }
4552       }
4553       if (outline.length === 6) {
4554         appearanceBuffer.push(
4555           `${numberToString(outline[4])} ${numberToString(outline[5])} l`
4556         );
4557       }
4558     }
4559     appearanceBuffer.push("S");
4560 
4561     const appearance = appearanceBuffer.join("\n");
4562 
4563     const appearanceStreamDict = new Dict(xref);
4564     appearanceStreamDict.set("FormType", 1);
4565     appearanceStreamDict.set("Subtype", Name.get("Form"));
4566     appearanceStreamDict.set("Type", Name.get("XObject"));
4567     appearanceStreamDict.set("BBox", rect);
4568     appearanceStreamDict.set("Length", appearance.length);
4569 
4570     if (opacity !== 1) {
4571       const resources = new Dict(xref);
4572       const extGState = new Dict(xref);
4573       const r0 = new Dict(xref);
4574       r0.set("CA", opacity);
4575       r0.set("Type", Name.get("ExtGState"));
4576       extGState.set("R0", r0);
4577       resources.set("ExtGState", extGState);
4578       appearanceStreamDict.set("Resources", resources);
4579     }
4580 
4581     const ap = new StringStream(appearance);
4582     ap.dict = appearanceStreamDict;
4583 
4584     return ap;
4585   }
4586 
4587   static async createNewAppearanceStreamForHighlight(annotation, xref, params) {
4588     const {
4589       color,
4590       rect,
4591       outlines: { outline },
4592       opacity,
4593     } = annotation;
4594     const appearanceBuffer = [
4595       `${getPdfColor(color, /* isFill */ true)}`,
4596       "/R0 gs",
4597     ];
4598 
4599     appearanceBuffer.push(
4600       `${numberToString(outline[4])} ${numberToString(outline[5])} m`
4601     );
4602     for (let i = 6, ii = outline.length; i < ii; i += 6) {
4603       if (isNaN(outline[i])) {
4604         appearanceBuffer.push(
4605           `${numberToString(outline[i + 4])} ${numberToString(
4606             outline[i + 5]
4607           )} l`
4608         );
4609       } else {
4610         const [c1x, c1y, c2x, c2y, x, y] = outline.slice(i, i + 6);
4611         appearanceBuffer.push(
4612           [c1x, c1y, c2x, c2y, x, y].map(numberToString).join(" ") + " c"
4613         );
4614       }
4615     }
4616     appearanceBuffer.push("h f");
4617     const appearance = appearanceBuffer.join("\n");
4618 
4619     const appearanceStreamDict = new Dict(xref);
4620     appearanceStreamDict.set("FormType", 1);
4621     appearanceStreamDict.set("Subtype", Name.get("Form"));
4622     appearanceStreamDict.set("Type", Name.get("XObject"));
4623     appearanceStreamDict.set("BBox", rect);
4624     appearanceStreamDict.set("Length", appearance.length);
4625 
4626     const resources = new Dict(xref);
4627     const extGState = new Dict(xref);
4628     resources.set("ExtGState", extGState);
4629     appearanceStreamDict.set("Resources", resources);
4630     const r0 = new Dict(xref);
4631     extGState.set("R0", r0);
4632     r0.set("BM", Name.get("Multiply"));
4633 
4634     if (opacity !== 1) {
4635       r0.set("ca", opacity);
4636       r0.set("Type", Name.get("ExtGState"));
4637     }
4638 
4639     const ap = new StringStream(appearance);
4640     ap.dict = appearanceStreamDict;
4641 
4642     return ap;
4643   }
4644 }
4645 
4646 class HighlightAnnotation extends MarkupAnnotation {
4647   constructor(params) {
4648     super(params);
4649 
4650     const { dict, xref } = params;
4651     this.data.annotationType = AnnotationType.HIGHLIGHT;
4652     this.data.isEditable = !this.data.noHTML;
4653     // We want to be able to add mouse listeners to the annotation.
4654     this.data.noHTML = false;
4655     this.data.opacity = dict.get("CA") || 1;
4656 
4657     const quadPoints = (this.data.quadPoints = getQuadPoints(dict, null));
4658     if (quadPoints) {
4659       const resources = this.appearance?.dict.get("Resources");
4660 
4661       if (!this.appearance || !resources?.has("ExtGState")) {
4662         if (this.appearance) {
4663           // Workaround for cases where there's no /ExtGState-entry directly
4664           // available, e.g. when the appearance stream contains a /XObject of
4665           // the /Form-type, since that causes the highlighting to completely
4666           // obscure the PDF content below it (fixes issue13242.pdf).
4667           warn("HighlightAnnotation - ignoring built-in appearance stream.");
4668         }
4669         // Default color is yellow in Acrobat Reader
4670         const fillColor = this.color ? getPdfColorArray(this.color) : [1, 1, 0];
4671         const fillAlpha = dict.get("CA");
4672 
4673         this._setDefaultAppearance({
4674           xref,
4675           fillColor,
4676           blendMode: "Multiply",
4677           fillAlpha,
4678           pointsCallback: (buffer, points) => {
4679             buffer.push(
4680               `${points[0]} ${points[1]} m`,
4681               `${points[2]} ${points[3]} l`,
4682               `${points[6]} ${points[7]} l`,
4683               `${points[4]} ${points[5]} l`,
4684               "f"
4685             );
4686             return [points[0], points[2], points[7], points[3]];
4687           },
4688         });
4689       }
4690     } else {
4691       this.data.popupRef = null;
4692     }
4693   }
4694 
4695   static createNewDict(annotation, xref, { apRef, ap }) {
4696     const { color, oldAnnotation, opacity, rect, rotation, user, quadPoints } =
4697       annotation;
4698     const highlight = oldAnnotation || new Dict(xref);
4699     highlight.set("Type", Name.get("Annot"));
4700     highlight.set("Subtype", Name.get("Highlight"));
4701     highlight.set(
4702       oldAnnotation ? "M" : "CreationDate",
4703       `D:${getModificationDate()}`
4704     );
4705     highlight.set("CreationDate", `D:${getModificationDate()}`);
4706     highlight.set("Rect", rect);
4707     highlight.set("F", 4);
4708     highlight.set("Border", [0, 0, 0]);
4709     highlight.set("Rotate", rotation);
4710     highlight.set("QuadPoints", quadPoints);
4711 
4712     // Color.
4713     highlight.set(
4714       "C",
4715       Array.from(color, c => c / 255)
4716     );
4717 
4718     // Opacity.
4719     highlight.set("CA", opacity);
4720 
4721     if (user) {
4722       highlight.set("T", stringToAsciiOrUTF16BE(user));
4723     }
4724 
4725     if (apRef || ap) {
4726       const n = new Dict(xref);
4727       highlight.set("AP", n);
4728       n.set("N", apRef || ap);
4729     }
4730 
4731     return highlight;
4732   }
4733 
4734   static async createNewAppearanceStream(annotation, xref, params) {
4735     const { color, rect, outlines, opacity } = annotation;
4736 
4737     const appearanceBuffer = [
4738       `${getPdfColor(color, /* isFill */ true)}`,
4739       "/R0 gs",
4740     ];
4741 
4742     const buffer = [];
4743     for (const outline of outlines) {
4744       buffer.length = 0;
4745       buffer.push(
4746         `${numberToString(outline[0])} ${numberToString(outline[1])} m`
4747       );
4748       for (let i = 2, ii = outline.length; i < ii; i += 2) {
4749         buffer.push(
4750           `${numberToString(outline[i])} ${numberToString(outline[i + 1])} l`
4751         );
4752       }
4753       buffer.push("h");
4754       appearanceBuffer.push(buffer.join("\n"));
4755     }
4756     appearanceBuffer.push("f*");
4757     const appearance = appearanceBuffer.join("\n");
4758 
4759     const appearanceStreamDict = new Dict(xref);
4760     appearanceStreamDict.set("FormType", 1);
4761     appearanceStreamDict.set("Subtype", Name.get("Form"));
4762     appearanceStreamDict.set("Type", Name.get("XObject"));
4763     appearanceStreamDict.set("BBox", rect);
4764     appearanceStreamDict.set("Length", appearance.length);
4765 
4766     const resources = new Dict(xref);
4767     const extGState = new Dict(xref);
4768     resources.set("ExtGState", extGState);
4769     appearanceStreamDict.set("Resources", resources);
4770     const r0 = new Dict(xref);
4771     extGState.set("R0", r0);
4772     r0.set("BM", Name.get("Multiply"));
4773 
4774     if (opacity !== 1) {
4775       r0.set("ca", opacity);
4776       r0.set("Type", Name.get("ExtGState"));
4777     }
4778 
4779     const ap = new StringStream(appearance);
4780     ap.dict = appearanceStreamDict;
4781 
4782     return ap;
4783   }
4784 }
4785 
4786 class UnderlineAnnotation extends MarkupAnnotation {
4787   constructor(params) {
4788     super(params);
4789 
4790     const { dict, xref } = params;
4791     this.data.annotationType = AnnotationType.UNDERLINE;
4792 
4793     const quadPoints = (this.data.quadPoints = getQuadPoints(dict, null));
4794     if (quadPoints) {
4795       if (!this.appearance) {
4796         // Default color is black
4797         const strokeColor = this.color
4798           ? getPdfColorArray(this.color)
4799           : [0, 0, 0];
4800         const strokeAlpha = dict.get("CA");
4801 
4802         // The values 0.571 and 1.3 below corresponds to what Acrobat is doing.
4803         this._setDefaultAppearance({
4804           xref,
4805           extra: "[] 0 d 0.571 w",
4806           strokeColor,
4807           strokeAlpha,
4808           pointsCallback: (buffer, points) => {
4809             buffer.push(
4810               `${points[4]} ${points[5] + 1.3} m`,
4811               `${points[6]} ${points[7] + 1.3} l`,
4812               "S"
4813             );
4814             return [points[0], points[2], points[7], points[3]];
4815           },
4816         });
4817       }
4818     } else {
4819       this.data.popupRef = null;
4820     }
4821   }
4822 }
4823 
4824 class SquigglyAnnotation extends MarkupAnnotation {
4825   constructor(params) {
4826     super(params);
4827 
4828     const { dict, xref } = params;
4829     this.data.annotationType = AnnotationType.SQUIGGLY;
4830 
4831     const quadPoints = (this.data.quadPoints = getQuadPoints(dict, null));
4832     if (quadPoints) {
4833       if (!this.appearance) {
4834         // Default color is black
4835         const strokeColor = this.color
4836           ? getPdfColorArray(this.color)
4837           : [0, 0, 0];
4838         const strokeAlpha = dict.get("CA");
4839 
4840         this._setDefaultAppearance({
4841           xref,
4842           extra: "[] 0 d 1 w",
4843           strokeColor,
4844           strokeAlpha,
4845           pointsCallback: (buffer, points) => {
4846             const dy = (points[1] - points[5]) / 6;
4847             let shift = dy;
4848             let x = points[4];
4849             const y = points[5];
4850             const xEnd = points[6];
4851             buffer.push(`${x} ${y + shift} m`);
4852             do {
4853               x += 2;
4854               shift = shift === 0 ? dy : 0;
4855               buffer.push(`${x} ${y + shift} l`);
4856             } while (x < xEnd);
4857             buffer.push("S");
4858             return [points[4], xEnd, y - 2 * dy, y + 2 * dy];
4859           },
4860         });
4861       }
4862     } else {
4863       this.data.popupRef = null;
4864     }
4865   }
4866 }
4867 
4868 class StrikeOutAnnotation extends MarkupAnnotation {
4869   constructor(params) {
4870     super(params);
4871 
4872     const { dict, xref } = params;
4873     this.data.annotationType = AnnotationType.STRIKEOUT;
4874 
4875     const quadPoints = (this.data.quadPoints = getQuadPoints(dict, null));
4876     if (quadPoints) {
4877       if (!this.appearance) {
4878         // Default color is black
4879         const strokeColor = this.color
4880           ? getPdfColorArray(this.color)
4881           : [0, 0, 0];
4882         const strokeAlpha = dict.get("CA");
4883 
4884         this._setDefaultAppearance({
4885           xref,
4886           extra: "[] 0 d 1 w",
4887           strokeColor,
4888           strokeAlpha,
4889           pointsCallback: (buffer, points) => {
4890             buffer.push(
4891               `${(points[0] + points[4]) / 2} ` +
4892                 `${(points[1] + points[5]) / 2} m`,
4893               `${(points[2] + points[6]) / 2} ` +
4894                 `${(points[3] + points[7]) / 2} l`,
4895               "S"
4896             );
4897             return [points[0], points[2], points[7], points[3]];
4898           },
4899         });
4900       }
4901     } else {
4902       this.data.popupRef = null;
4903     }
4904   }
4905 }
4906 
4907 class StampAnnotation extends MarkupAnnotation {
4908   #savedHasOwnCanvas;
4909 
4910   constructor(params) {
4911     super(params);
4912 
4913     this.data.annotationType = AnnotationType.STAMP;
4914     this.#savedHasOwnCanvas = this.data.hasOwnCanvas = this.data.noRotate;
4915     this.data.isEditable = !this.data.noHTML;
4916     // We want to be able to add mouse listeners to the annotation.
4917     this.data.noHTML = false;
4918   }
4919 
4920   mustBeViewedWhenEditing(isEditing, modifiedIds = null) {
4921     if (isEditing) {
4922       if (!this.data.isEditable) {
4923         return false;
4924       }
4925       // When we're editing, we want to ensure that the stamp annotation is
4926       // drawn on a canvas in order to use it in the annotation editor layer.
4927       this.#savedHasOwnCanvas = this.data.hasOwnCanvas;
4928       this.data.hasOwnCanvas = true;
4929       return true;
4930     }
4931     this.data.hasOwnCanvas = this.#savedHasOwnCanvas;
4932 
4933     return !modifiedIds?.has(this.data.id);
4934   }
4935 
4936   static async createImage(bitmap, xref) {
4937     // TODO: when printing, we could have a specific internal colorspace
4938     // (e.g. something like DeviceRGBA) in order avoid any conversion (i.e. no
4939     // jpeg, no rgba to rgb conversion, etc...)
4940 
4941     const { width, height } = bitmap;
4942     const canvas = new OffscreenCanvas(width, height);
4943     const ctx = canvas.getContext("2d", { alpha: true });
4944 
4945     // Draw the image and get the data in order to extract the transparency.
4946     ctx.drawImage(bitmap, 0, 0);
4947     const data = ctx.getImageData(0, 0, width, height).data;
4948     const buf32 = new Uint32Array(data.buffer);
4949     const hasAlpha = buf32.some(
4950       FeatureTest.isLittleEndian
4951         ? x => x >>> 24 !== 0xff
4952         : x => (x & 0xff) !== 0xff
4953     );
4954 
4955     if (hasAlpha) {
4956       // Redraw the image on a white background in order to remove the thin gray
4957       // line which can appear when exporting to jpeg.
4958       ctx.fillStyle = "white";
4959       ctx.fillRect(0, 0, width, height);
4960       ctx.drawImage(bitmap, 0, 0);
4961     }
4962 
4963     const jpegBufferPromise = canvas
4964       .convertToBlob({ type: "image/jpeg", quality: 1 })
4965       .then(blob => blob.arrayBuffer());
4966 
4967     const xobjectName = Name.get("XObject");
4968     const imageName = Name.get("Image");
4969     const image = new Dict(xref);
4970     image.set("Type", xobjectName);
4971     image.set("Subtype", imageName);
4972     image.set("BitsPerComponent", 8);
4973     image.set("ColorSpace", Name.get("DeviceRGB"));
4974     image.set("Filter", Name.get("DCTDecode"));
4975     image.set("BBox", [0, 0, width, height]);
4976     image.set("Width", width);
4977     image.set("Height", height);
4978 
4979     let smaskStream = null;
4980     if (hasAlpha) {
4981       const alphaBuffer = new Uint8Array(buf32.length);
4982       if (FeatureTest.isLittleEndian) {
4983         for (let i = 0, ii = buf32.length; i < ii; i++) {
4984           alphaBuffer[i] = buf32[i] >>> 24;
4985         }
4986       } else {
4987         for (let i = 0, ii = buf32.length; i < ii; i++) {
4988           alphaBuffer[i] = buf32[i] & 0xff;
4989         }
4990       }
4991 
4992       const smask = new Dict(xref);
4993       smask.set("Type", xobjectName);
4994       smask.set("Subtype", imageName);
4995       smask.set("BitsPerComponent", 8);
4996       smask.set("ColorSpace", Name.get("DeviceGray"));
4997       smask.set("Width", width);
4998       smask.set("Height", height);
4999 
5000       smaskStream = new Stream(alphaBuffer, 0, 0, smask);
5001     }
5002     const imageStream = new Stream(await jpegBufferPromise, 0, 0, image);
5003 
5004     return {
5005       imageStream,
5006       smaskStream,
5007       width,
5008       height,
5009     };
5010   }
5011 
5012   static createNewDict(annotation, xref, { apRef, ap }) {
5013     const { oldAnnotation, rect, rotation, user } = annotation;
5014     const stamp = oldAnnotation || new Dict(xref);
5015     stamp.set("Type", Name.get("Annot"));
5016     stamp.set("Subtype", Name.get("Stamp"));
5017     stamp.set(
5018       oldAnnotation ? "M" : "CreationDate",
5019       `D:${getModificationDate()}`
5020     );
5021     stamp.set("Rect", rect);
5022     stamp.set("F", 4);
5023     stamp.set("Border", [0, 0, 0]);
5024     stamp.set("Rotate", rotation);
5025 
5026     if (user) {
5027       stamp.set("T", stringToAsciiOrUTF16BE(user));
5028     }
5029 
5030     if (apRef || ap) {
5031       const n = new Dict(xref);
5032       stamp.set("AP", n);
5033 
5034       if (apRef) {
5035         n.set("N", apRef);
5036       } else {
5037         n.set("N", ap);
5038       }
5039     }
5040 
5041     return stamp;
5042   }
5043 
5044   static async createNewAppearanceStream(annotation, xref, params) {
5045     if (annotation.oldAnnotation) {
5046       // We'll use the AP we already have.
5047       return null;
5048     }
5049 
5050     const { rotation } = annotation;
5051     const { imageRef, width, height } = params.image;
5052     const resources = new Dict(xref);
5053     const xobject = new Dict(xref);
5054     resources.set("XObject", xobject);
5055     xobject.set("Im0", imageRef);
5056     const appearance = `q ${width} 0 0 ${height} 0 0 cm /Im0 Do Q`;
5057 
5058     const appearanceStreamDict = new Dict(xref);
5059     appearanceStreamDict.set("FormType", 1);
5060     appearanceStreamDict.set("Subtype", Name.get("Form"));
5061     appearanceStreamDict.set("Type", Name.get("XObject"));
5062     appearanceStreamDict.set("BBox", [0, 0, width, height]);
5063     appearanceStreamDict.set("Resources", resources);
5064 
5065     if (rotation) {
5066       const matrix = getRotationMatrix(rotation, width, height);
5067       appearanceStreamDict.set("Matrix", matrix);
5068     }
5069 
5070     const ap = new StringStream(appearance);
5071     ap.dict = appearanceStreamDict;
5072 
5073     return ap;
5074   }
5075 }
5076 
5077 class FileAttachmentAnnotation extends MarkupAnnotation {
5078   constructor(params) {
5079     super(params);
5080 
5081     const { dict, xref } = params;
5082     const file = new FileSpec(dict.get("FS"), xref);
5083 
5084     this.data.annotationType = AnnotationType.FILEATTACHMENT;
5085     this.data.hasOwnCanvas = this.data.noRotate;
5086     this.data.noHTML = false;
5087     this.data.file = file.serializable;
5088 
5089     const name = dict.get("Name");
5090     this.data.name =
5091       name instanceof Name ? stringToPDFString(name.name) : "PushPin";
5092 
5093     const fillAlpha = dict.get("ca");
5094     this.data.fillAlpha =
5095       typeof fillAlpha === "number" && fillAlpha >= 0 && fillAlpha <= 1
5096         ? fillAlpha
5097         : null;
5098   }
5099 }
5100 
5101 export {
5102   Annotation,
5103   AnnotationBorderStyle,
5104   AnnotationFactory,
5105   getQuadPoints,
5106   MarkupAnnotation,
5107   PopupAnnotation,
5108   WidgetAnnotation,
5109 };
File:
src/display/annotation_layer.js
1 /* Copyright 2014 Mozilla Foundation
2  *
3  * Licensed under the Apache License, Version 2.0 (the "License");
4  * you may not use this file except in compliance with the License.
5  * You may obtain a copy of the License at
6  *
7  *     http://www.apache.org/licenses/LICENSE-2.0
8  *
9  * Unless required by applicable law or agreed to in writing, software
10  * distributed under the License is distributed on an "AS IS" BASIS,
11  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
12  * See the License for the specific language governing permissions and
13  * limitations under the License.
14  */
15 
16 /** @typedef {import("./api").PDFPageProxy} PDFPageProxy */
17 /** @typedef {import("./display_utils").PageViewport} PageViewport */
18 // eslint-disable-next-line max-len
19 /** @typedef {import("../../web/text_accessibility.js").TextAccessibilityManager} TextAccessibilityManager */
20 // eslint-disable-next-line max-len
21 /** @typedef {import("../../web/interfaces").IDownloadManager} IDownloadManager */
22 /** @typedef {import("../../web/interfaces").IPDFLinkService} IPDFLinkService */
23 // eslint-disable-next-line max-len
24 /** @typedef {import("../src/display/editor/tools.js").AnnotationEditorUIManager} AnnotationEditorUIManager */
25 // eslint-disable-next-line max-len
26 /** @typedef {import("../../web/struct_tree_layer_builder.js").StructTreeLayerBuilder} StructTreeLayerBuilder */
27 
28 import {
29   AnnotationBorderStyleType,
30   AnnotationEditorType,
31   AnnotationPrefix,
32   AnnotationType,
33   FeatureTest,
34   LINE_FACTOR,
35   shadow,
36   unreachable,
37   Util,
38   warn,
39 } from "../shared/util.js";
40 import { PDFDateString, setLayerDimensions } from "./display_utils.js";
41 import { AnnotationStorage } from "./annotation_storage.js";
42 import { ColorConverters } from "../shared/scripting_utils.js";
43 import { DOMSVGFactory } from "./svg_factory.js";
44 import { XfaLayer } from "./xfa_layer.js";
45 
46 const DEFAULT_TAB_INDEX = 1000;
47 const DEFAULT_FONT_SIZE = 9;
48 const GetElementsByNameSet = new WeakSet();
49 
50 function getRectDims(rect) {
51   return {
52     width: rect[2] - rect[0],
53     height: rect[3] - rect[1],
54   };
55 }
56 
57 /**
58  * @typedef {Object} AnnotationElementParameters
59  * @property {Object} data
60  * @property {HTMLDivElement} layer
61  * @property {IPDFLinkService} linkService
62  * @property {IDownloadManager} [downloadManager]
63  * @property {AnnotationStorage} [annotationStorage]
64  * @property {string} [imageResourcesPath] - Path for image resources, mainly
65  *   for annotation icons. Include trailing slash.
66  * @property {boolean} renderForms
67  * @property {Object} svgFactory
68  * @property {boolean} [enableScripting]
69  * @property {boolean} [hasJSActions]
70  * @property {Object} [fieldObjects]
71  */
72 
73 class AnnotationElementFactory {
74   /**
75    * @param {AnnotationElementParameters} parameters
76    * @returns {AnnotationElement}
77    */
78   static create(parameters) {
79     const subtype = parameters.data.annotationType;
80 
81     switch (subtype) {
82       case AnnotationType.LINK:
83         return new LinkAnnotationElement(parameters);
84 
85       case AnnotationType.TEXT:
86         return new TextAnnotationElement(parameters);
87 
88       case AnnotationType.WIDGET:
89         const fieldType = parameters.data.fieldType;
90 
91         switch (fieldType) {
92           case "Tx":
93             return new TextWidgetAnnotationElement(parameters);
94           case "Btn":
95             if (parameters.data.radioButton) {
96               return new RadioButtonWidgetAnnotationElement(parameters);
97             } else if (parameters.data.checkBox) {
98               return new CheckboxWidgetAnnotationElement(parameters);
99             }
100             return new PushButtonWidgetAnnotationElement(parameters);
101           case "Ch":
102             return new ChoiceWidgetAnnotationElement(parameters);
103           case "Sig":
104             return new SignatureWidgetAnnotationElement(parameters);
105         }
106         return new WidgetAnnotationElement(parameters);
107 
108       case AnnotationType.POPUP:
109         return new PopupAnnotationElement(parameters);
110 
111       case AnnotationType.FREETEXT:
112         return new FreeTextAnnotationElement(parameters);
113 
114       case AnnotationType.LINE:
115         return new LineAnnotationElement(parameters);
116 
117       case AnnotationType.SQUARE:
118         return new SquareAnnotationElement(parameters);
119 
120       case AnnotationType.CIRCLE:
121         return new CircleAnnotationElement(parameters);
122 
123       case AnnotationType.POLYLINE:
124         return new PolylineAnnotationElement(parameters);
125 
126       case AnnotationType.CARET:
127         return new CaretAnnotationElement(parameters);
128 
129       case AnnotationType.INK:
130         return new InkAnnotationElement(parameters);
131 
132       case AnnotationType.POLYGON:
133         return new PolygonAnnotationElement(parameters);
134 
135       case AnnotationType.HIGHLIGHT:
136         return new HighlightAnnotationElement(parameters);
137 
138       case AnnotationType.UNDERLINE:
139         return new UnderlineAnnotationElement(parameters);
140 
141       case AnnotationType.SQUIGGLY:
142         return new SquigglyAnnotationElement(parameters);
143 
144       case AnnotationType.STRIKEOUT:
145         return new StrikeOutAnnotationElement(parameters);
146 
147       case AnnotationType.STAMP:
148         return new StampAnnotationElement(parameters);
149 
150       case AnnotationType.FILEATTACHMENT:
151         return new FileAttachmentAnnotationElement(parameters);
152 
153       default:
154         return new AnnotationElement(parameters);
155     }
156   }
157 }
158 
159 class AnnotationElement {
160   #updates = null;
161 
162   #hasBorder = false;
163 
164   #popupElement = null;
165 
166   constructor(
167     parameters,
168     {
169       isRenderable = false,
170       ignoreBorder = false,
171       createQuadrilaterals = false,
172     } = {}
173   ) {
174     this.isRenderable = isRenderable;
175     this.data = parameters.data;
176     this.layer = parameters.layer;
177     this.linkService = parameters.linkService;
178     this.downloadManager = parameters.downloadManager;
179     this.imageResourcesPath = parameters.imageResourcesPath;
180     this.renderForms = parameters.renderForms;
181     this.svgFactory = parameters.svgFactory;
182     this.annotationStorage = parameters.annotationStorage;
183     this.enableScripting = parameters.enableScripting;
184     this.hasJSActions = parameters.hasJSActions;
185     this._fieldObjects = parameters.fieldObjects;
186     this.parent = parameters.parent;
187 
188     if (isRenderable) {
189       this.container = this._createContainer(ignoreBorder);
190     }
191     if (createQuadrilaterals) {
192       this._createQuadrilaterals();
193     }
194   }
195 
196   static _hasPopupData({ titleObj, contentsObj, richText }) {
197     return !!(titleObj?.str || contentsObj?.str || richText?.str);
198   }
199 
200   get _isEditable() {
201     return this.data.isEditable;
202   }
203 
204   get hasPopupData() {
205     return AnnotationElement._hasPopupData(this.data);
206   }
207 
208   updateEdited(params) {
209     if (!this.container) {
210       return;
211     }
212 
213     this.#updates ||= {
214       rect: this.data.rect.slice(0),
215     };
216 
217     const { rect } = params;
218 
219     if (rect) {
220       this.#setRectEdited(rect);
221     }
222 
223     this.#popupElement?.popup.updateEdited(params);
224   }
225 
226   resetEdited() {
227     if (!this.#updates) {
228       return;
229     }
230     this.#setRectEdited(this.#updates.rect);
231     this.#popupElement?.popup.resetEdited();
232     this.#updates = null;
233   }
234 
235   #setRectEdited(rect) {
236     const {
237       container: { style },
238       data: { rect: currentRect, rotation },
239       parent: {
240         viewport: {
241           rawDims: { pageWidth, pageHeight, pageX, pageY },
242         },
243       },
244     } = this;
245     currentRect?.splice(0, 4, ...rect);
246     const { width, height } = getRectDims(rect);
247     style.left = `${(100 * (rect[0] - pageX)) / pageWidth}%`;
248     style.top = `${(100 * (pageHeight - rect[3] + pageY)) / pageHeight}%`;
249     if (rotation === 0) {
250       style.width = `${(100 * width) / pageWidth}%`;
251       style.height = `${(100 * height) / pageHeight}%`;
252     } else {
253       this.setRotation(rotation);
254     }
255   }
256 
257   /**
258    * Create an empty container for the annotation's HTML element.
259    *
260    * @private
261    * @param {boolean} ignoreBorder
262    * @memberof AnnotationElement
263    * @returns {HTMLElement} A section element.
264    */
265   _createContainer(ignoreBorder) {
266     const {
267       data,
268       parent: { page, viewport },
269     } = this;
270 
271     const container = document.createElement("section");
272     container.setAttribute("data-annotation-id", data.id);
273     if (!(this instanceof WidgetAnnotationElement)) {
274       container.tabIndex = DEFAULT_TAB_INDEX;
275     }
276     const { style } = container;
277 
278     // The accessibility manager will move the annotation in the DOM in
279     // order to match the visual ordering.
280     // But if an annotation is above an other one, then we must draw it
281     // after the other one whatever the order is in the DOM, hence the
282     // use of the z-index.
283     style.zIndex = this.parent.zIndex++;
284 
285     if (data.alternativeText) {
286       container.title = data.alternativeText;
287     }
288 
289     if (data.noRotate) {
290       container.classList.add("norotate");
291     }
292 
293     if (!data.rect || this instanceof PopupAnnotationElement) {
294       const { rotation } = data;
295       if (!data.hasOwnCanvas && rotation !== 0) {
296         this.setRotation(rotation, container);
297       }
298       return container;
299     }
300 
301     const { width, height } = getRectDims(data.rect);
302 
303     if (!ignoreBorder && data.borderStyle.width > 0) {
304       style.borderWidth = `${data.borderStyle.width}px`;
305 
306       const horizontalRadius = data.borderStyle.horizontalCornerRadius;
307       const verticalRadius = data.borderStyle.verticalCornerRadius;
308       if (horizontalRadius > 0 || verticalRadius > 0) {
309         const radius = `calc(${horizontalRadius}px * var(--scale-factor)) / calc(${verticalRadius}px * var(--scale-factor))`;
310         style.borderRadius = radius;
311       } else if (this instanceof RadioButtonWidgetAnnotationElement) {
312         const radius = `calc(${width}px * var(--scale-factor)) / calc(${height}px * var(--scale-factor))`;
313         style.borderRadius = radius;
314       }
315 
316       switch (data.borderStyle.style) {
317         case AnnotationBorderStyleType.SOLID:
318           style.borderStyle = "solid";
319           break;
320 
321         case AnnotationBorderStyleType.DASHED:
322           style.borderStyle = "dashed";
323           break;
324 
325         case AnnotationBorderStyleType.BEVELED:
326           warn("Unimplemented border style: beveled");
327           break;
328 
329         case AnnotationBorderStyleType.INSET:
330           warn("Unimplemented border style: inset");
331           break;
332 
333         case AnnotationBorderStyleType.UNDERLINE:
334           style.borderBottomStyle = "solid";
335           break;
336 
337         default:
338           break;
339       }
340 
341       const borderColor = data.borderColor || null;
342       if (borderColor) {
343         this.#hasBorder = true;
344         style.borderColor = Util.makeHexColor(
345           borderColor[0] | 0,
346           borderColor[1] | 0,
347           borderColor[2] | 0
348         );
349       } else {
350         // Transparent (invisible) border, so do not draw it at all.
351         style.borderWidth = 0;
352       }
353     }
354 
355     // Do *not* modify `data.rect`, since that will corrupt the annotation
356     // position on subsequent calls to `_createContainer` (see issue 6804).
357     const rect = Util.normalizeRect([
358       data.rect[0],
359       page.view[3] - data.rect[1] + page.view[1],
360       data.rect[2],
361       page.view[3] - data.rect[3] + page.view[1],
362     ]);
363     const { pageWidth, pageHeight, pageX, pageY } = viewport.rawDims;
364 
365     style.left = `${(100 * (rect[0] - pageX)) / pageWidth}%`;
366     style.top = `${(100 * (rect[1] - pageY)) / pageHeight}%`;
367 
368     const { rotation } = data;
369     if (data.hasOwnCanvas || rotation === 0) {
370       style.width = `${(100 * width) / pageWidth}%`;
371       style.height = `${(100 * height) / pageHeight}%`;
372     } else {
373       this.setRotation(rotation, container);
374     }
375 
376     return container;
377   }
378 
379   setRotation(angle, container = this.container) {
380     if (!this.data.rect) {
381       return;
382     }
383     const { pageWidth, pageHeight } = this.parent.viewport.rawDims;
384     const { width, height } = getRectDims(this.data.rect);
385 
386     let elementWidth, elementHeight;
387     if (angle % 180 === 0) {
388       elementWidth = (100 * width) / pageWidth;
389       elementHeight = (100 * height) / pageHeight;
390     } else {
391       elementWidth = (100 * height) / pageWidth;
392       elementHeight = (100 * width) / pageHeight;
393     }
394 
395     container.style.width = `${elementWidth}%`;
396     container.style.height = `${elementHeight}%`;
397 
398     container.setAttribute("data-main-rotation", (360 - angle) % 360);
399   }
400 
401   get _commonActions() {
402     const setColor = (jsName, styleName, event) => {
403       const color = event.detail[jsName];
404       const colorType = color[0];
405       const colorArray = color.slice(1);
406       event.target.style[styleName] =
407         ColorConverters[`${colorType}_HTML`](colorArray);
408       this.annotationStorage.setValue(this.data.id, {
409         [styleName]: ColorConverters[`${colorType}_rgb`](colorArray),
410       });
411     };
412 
413     return shadow(this, "_commonActions", {
414       display: event => {
415         const { display } = event.detail;
416         // See scripting/constants.js for the values of `Display`.
417         // 0 = visible, 1 = hidden, 2 = noPrint and 3 = noView.
418         const hidden = display % 2 === 1;
419         this.container.style.visibility = hidden ? "hidden" : "visible";
420         this.annotationStorage.setValue(this.data.id, {
421           noView: hidden,
422           noPrint: display === 1 || display === 2,
423         });
424       },
425       print: event => {
426         this.annotationStorage.setValue(this.data.id, {
427           noPrint: !event.detail.print,
428         });
429       },
430       hidden: event => {
431         const { hidden } = event.detail;
432         this.container.style.visibility = hidden ? "hidden" : "visible";
433         this.annotationStorage.setValue(this.data.id, {
434           noPrint: hidden,
435           noView: hidden,
436         });
437       },
438       focus: event => {
439         setTimeout(() => event.target.focus({ preventScroll: false }), 0);
440       },
441       userName: event => {
442         // tooltip
443         event.target.title = event.detail.userName;
444       },
445       readonly: event => {
446         event.target.disabled = event.detail.readonly;
447       },
448       required: event => {
449         this._setRequired(event.target, event.detail.required);
450       },
451       bgColor: event => {
452         setColor("bgColor", "backgroundColor", event);
453       },
454       fillColor: event => {
455         setColor("fillColor", "backgroundColor", event);
456       },
457       fgColor: event => {
458         setColor("fgColor", "color", event);
459       },
460       textColor: event => {
461         setColor("textColor", "color", event);
462       },
463       borderColor: event => {
464         setColor("borderColor", "borderColor", event);
465       },
466       strokeColor: event => {
467         setColor("strokeColor", "borderColor", event);
468       },
469       rotation: event => {
470         const angle = event.detail.rotation;
471         this.setRotation(angle);
472         this.annotationStorage.setValue(this.data.id, {
473           rotation: angle,
474         });
475       },
476     });
477   }
478 
479   _dispatchEventFromSandbox(actions, jsEvent) {
480     const commonActions = this._commonActions;
481     for (const name of Object.keys(jsEvent.detail)) {
482       const action = actions[name] || commonActions[name];
483       action?.(jsEvent);
484     }
485   }
486 
487   _setDefaultPropertiesFromJS(element) {
488     if (!this.enableScripting) {
489       return;
490     }
491 
492     // Some properties may have been updated thanks to JS.
493     const storedData = this.annotationStorage.getRawValue(this.data.id);
494     if (!storedData) {
495       return;
496     }
497 
498     const commonActions = this._commonActions;
499     for (const [actionName, detail] of Object.entries(storedData)) {
500       const action = commonActions[actionName];
501       if (action) {
502         const eventProxy = {
503           detail: {
504             [actionName]: detail,
505           },
506           target: element,
507         };
508         action(eventProxy);
509         // The action has been consumed: no need to keep it.
510         delete storedData[actionName];
511       }
512     }
513   }
514 
515   /**
516    * Create quadrilaterals from the annotation's quadpoints.
517    *
518    * @private
519    * @memberof AnnotationElement
520    */
521   _createQuadrilaterals() {
522     if (!this.container) {
523       return;
524     }
525     const { quadPoints } = this.data;
526     if (!quadPoints) {
527       return;
528     }
529 
530     const [rectBlX, rectBlY, rectTrX, rectTrY] = this.data.rect.map(x =>
531       Math.fround(x)
532     );
533 
534     if (quadPoints.length === 8) {
535       const [trX, trY, blX, blY] = quadPoints.subarray(2, 6);
536       if (
537         rectTrX === trX &&
538         rectTrY === trY &&
539         rectBlX === blX &&
540         rectBlY === blY
541       ) {
542         // The quadpoints cover the whole annotation rectangle, so no need to
543         // create a quadrilateral.
544         return;
545       }
546     }
547 
548     const { style } = this.container;
549     let svgBuffer;
550     if (this.#hasBorder) {
551       const { borderColor, borderWidth } = style;
552       style.borderWidth = 0;
553       svgBuffer = [
554         "url('data:image/svg+xml;utf8,",
555         `<svg xmlns="http://www.w3.org/2000/svg"`,
556         ` preserveAspectRatio="none" viewBox="0 0 1 1">`,
557         `<g fill="transparent" stroke="${borderColor}" stroke-width="${borderWidth}">`,
558       ];
559       this.container.classList.add("hasBorder");
560     }
561 
562     if (typeof PDFJSDev !== "undefined" && PDFJSDev.test("TESTING")) {
563       this.container.classList.add("hasClipPath");
564     }
565 
566     const width = rectTrX - rectBlX;
567     const height = rectTrY - rectBlY;
568 
569     const { svgFactory } = this;
570     const svg = svgFactory.createElement("svg");
571     svg.classList.add("quadrilateralsContainer");
572     svg.setAttribute("width", 0);
573     svg.setAttribute("height", 0);
574     const defs = svgFactory.createElement("defs");
575     svg.append(defs);
576     const clipPath = svgFactory.createElement("clipPath");
577     const id = `clippath_${this.data.id}`;
578     clipPath.setAttribute("id", id);
579     clipPath.setAttribute("clipPathUnits", "objectBoundingBox");
580     defs.append(clipPath);
581 
582     for (let i = 2, ii = quadPoints.length; i < ii; i += 8) {
583       const trX = quadPoints[i];
584       const trY = quadPoints[i + 1];
585       const blX = quadPoints[i + 2];
586       const blY = quadPoints[i + 3];
587       const rect = svgFactory.createElement("rect");
588       const x = (blX - rectBlX) / width;
589       const y = (rectTrY - trY) / height;
590       const rectWidth = (trX - blX) / width;
591       const rectHeight = (trY - blY) / height;
592       rect.setAttribute("x", x);
593       rect.setAttribute("y", y);
594       rect.setAttribute("width", rectWidth);
595       rect.setAttribute("height", rectHeight);
596       clipPath.append(rect);
597       svgBuffer?.push(
598         `<rect vector-effect="non-scaling-stroke" x="${x}" y="${y}" width="${rectWidth}" height="${rectHeight}"/>`
599       );
600     }
601 
602     if (this.#hasBorder) {
603       svgBuffer.push(`</g></svg>')`);
604       style.backgroundImage = svgBuffer.join("");
605     }
606 
607     this.container.append(svg);
608     this.container.style.clipPath = `url(#${id})`;
609   }
610 
611   /**
612    * Create a popup for the annotation's HTML element. This is used for
613    * annotations that do not have a Popup entry in the dictionary, but
614    * are of a type that works with popups (such as Highlight annotations).
615    *
616    * @private
617    * @memberof AnnotationElement
618    */
619   _createPopup() {
620     const { data } = this;
621 
622     const popup = (this.#popupElement = new PopupAnnotationElement({
623       data: {
624         color: data.color,
625         titleObj: data.titleObj,
626         modificationDate: data.modificationDate,
627         contentsObj: data.contentsObj,
628         richText: data.richText,
629         parentRect: data.rect,
630         borderStyle: 0,
631         id: `popup_${data.id}`,
632         rotation: data.rotation,
633       },
634       parent: this.parent,
635       elements: [this],
636     }));
637     this.parent.div.append(popup.render());
638   }
639 
640   /**
641    * Render the annotation's HTML element(s).
642    *
643    * @public
644    * @memberof AnnotationElement
645    */
646   render() {
647     unreachable("Abstract method `AnnotationElement.render` called");
648   }
649 
650   /**
651    * @private
652    * @returns {Array}
653    */
654   _getElementsByName(name, skipId = null) {
655     const fields = [];
656 
657     if (this._fieldObjects) {
658       const fieldObj = this._fieldObjects[name];
659       if (fieldObj) {
660         for (const { page, id, exportValues } of fieldObj) {
661           if (page === -1) {
662             continue;
663           }
664           if (id === skipId) {
665             continue;
666           }
667           const exportValue =
668             typeof exportValues === "string" ? exportValues : null;
669 
670           const domElement = document.querySelector(
671             `[data-element-id="${id}"]`
672           );
673           if (domElement && !GetElementsByNameSet.has(domElement)) {
674             warn(`_getElementsByName - element not allowed: ${id}`);
675             continue;
676           }
677           fields.push({ id, exportValue, domElement });
678         }
679       }
680       return fields;
681     }
682     // Fallback to a regular DOM lookup, to ensure that the standalone
683     // viewer components won't break.
684     for (const domElement of document.getElementsByName(name)) {
685       const { exportValue } = domElement;
686       const id = domElement.getAttribute("data-element-id");
687       if (id === skipId) {
688         continue;
689       }
690       if (!GetElementsByNameSet.has(domElement)) {
691         continue;
692       }
693       fields.push({ id, exportValue, domElement });
694     }
695     return fields;
696   }
697 
698   show() {
699     if (this.container) {
700       this.container.hidden = false;
701     }
702     this.popup?.maybeShow();
703   }
704 
705   hide() {
706     if (this.container) {
707       this.container.hidden = true;
708     }
709     this.popup?.forceHide();
710   }
711 
712   /**
713    * Get the HTML element(s) which can trigger a popup when clicked or hovered.
714    *
715    * @public
716    * @memberof AnnotationElement
717    * @returns {Array<HTMLElement>|HTMLElement} An array of elements or an
718    *          element.
719    */
720   getElementsToTriggerPopup() {
721     return this.container;
722   }
723 
724   addHighlightArea() {
725     const triggers = this.getElementsToTriggerPopup();
726     if (Array.isArray(triggers)) {
727       for (const element of triggers) {
728         element.classList.add("highlightArea");
729       }
730     } else {
731       triggers.classList.add("highlightArea");
732     }
733   }
734 
735   _editOnDoubleClick() {
736     if (!this._isEditable) {
737       return;
738     }
739     const {
740       annotationEditorType: mode,
741       data: { id: editId },
742     } = this;
743     this.container.addEventListener("dblclick", () => {
744       this.linkService.eventBus?.dispatch("switchannotationeditormode", {
745         source: this,
746         mode,
747         editId,
748       });
749     });
750   }
751 }
752 
753 class LinkAnnotationElement extends AnnotationElement {
754   constructor(parameters, options = null) {
755     super(parameters, {
756       isRenderable: true,
757       ignoreBorder: !!options?.ignoreBorder,
758       createQuadrilaterals: true,
759     });
760     this.isTooltipOnly = parameters.data.isTooltipOnly;
761   }
762 
763   render() {
764     const { data, linkService } = this;
765     const link = document.createElement("a");
766     link.setAttribute("data-element-id", data.id);
767     let isBound = false;
768 
769     if (data.url) {
770       linkService.addLinkAttributes(link, data.url, data.newWindow);
771       isBound = true;
772     } else if (data.action) {
773       this._bindNamedAction(link, data.action);
774       isBound = true;
775     } else if (data.attachment) {
776       this.#bindAttachment(link, data.attachment, data.attachmentDest);
777       isBound = true;
778     } else if (data.setOCGState) {
779       this.#bindSetOCGState(link, data.setOCGState);
780       isBound = true;
781     } else if (data.dest) {
782       this._bindLink(link, data.dest);
783       isBound = true;
784     } else {
785       if (
786         data.actions &&
787         (data.actions.Action ||
788           data.actions["Mouse Up"] ||
789           data.actions["Mouse Down"]) &&
790         this.enableScripting &&
791         this.hasJSActions
792       ) {
793         this._bindJSAction(link, data);
794         isBound = true;
795       }
796 
797       if (data.resetForm) {
798         this._bindResetFormAction(link, data.resetForm);
799         isBound = true;
800       } else if (this.isTooltipOnly && !isBound) {
801         this._bindLink(link, "");
802         isBound = true;
803       }
804     }
805 
806     this.container.classList.add("linkAnnotation");
807     if (isBound) {
808       this.container.append(link);
809     }
810 
811     return this.container;
812   }
813 
814   #setInternalLink() {
815     this.container.setAttribute("data-internal-link", "");
816   }
817 
818   /**
819    * Bind internal links to the link element.
820    *
821    * @private
822    * @param {Object} link
823    * @param {Object} destination
824    * @memberof LinkAnnotationElement
825    */
826   _bindLink(link, destination) {
827     link.href = this.linkService.getDestinationHash(destination);
828     link.onclick = () => {
829       if (destination) {
830         this.linkService.goToDestination(destination);
831       }
832       return false;
833     };
834     if (destination || destination === /* isTooltipOnly = */ "") {
835       this.#setInternalLink();
836     }
837   }
838 
839   /**
840    * Bind named actions to the link element.
841    *
842    * @private
843    * @param {Object} link
844    * @param {Object} action
845    * @memberof LinkAnnotationElement
846    */
847   _bindNamedAction(link, action) {
848     link.href = this.linkService.getAnchorUrl("");
849     link.onclick = () => {
850       this.linkService.executeNamedAction(action);
851       return false;
852     };
853     this.#setInternalLink();
854   }
855 
856   /**
857    * Bind attachments to the link element.
858    * @param {Object} link
859    * @param {Object} attachment
860    * @param {str} [dest]
861    */
862   #bindAttachment(link, attachment, dest = null) {
863     link.href = this.linkService.getAnchorUrl("");
864     if (attachment.description) {
865       link.title = attachment.description;
866     }
867     link.onclick = () => {
868       this.downloadManager?.openOrDownloadData(
869         attachment.content,
870         attachment.filename,
871         dest
872       );
873       return false;
874     };
875     this.#setInternalLink();
876   }
877 
878   /**
879    * Bind SetOCGState actions to the link element.
880    * @param {Object} link
881    * @param {Object} action
882    */
883   #bindSetOCGState(link, action) {
884     link.href = this.linkService.getAnchorUrl("");
885     link.onclick = () => {
886       this.linkService.executeSetOCGState(action);
887       return false;
888     };
889     this.#setInternalLink();
890   }
891 
892   /**
893    * Bind JS actions to the link element.
894    *
895    * @private
896    * @param {Object} link
897    * @param {Object} data
898    * @memberof LinkAnnotationElement
899    */
900   _bindJSAction(link, data) {
901     link.href = this.linkService.getAnchorUrl("");
902     const map = new Map([
903       ["Action", "onclick"],
904       ["Mouse Up", "onmouseup"],
905       ["Mouse Down", "onmousedown"],
906     ]);
907     for (const name of Object.keys(data.actions)) {
908       const jsName = map.get(name);
909       if (!jsName) {
910         continue;
911       }
912       link[jsName] = () => {
913         this.linkService.eventBus?.dispatch("dispatcheventinsandbox", {
914           source: this,
915           detail: {
916             id: data.id,
917             name,
918           },
919         });
920         return false;
921       };
922     }
923 
924     if (!link.onclick) {
925       link.onclick = () => false;
926     }
927     this.#setInternalLink();
928   }
929 
930   _bindResetFormAction(link, resetForm) {
931     const otherClickAction = link.onclick;
932     if (!otherClickAction) {
933       link.href = this.linkService.getAnchorUrl("");
934     }
935     this.#setInternalLink();
936 
937     if (!this._fieldObjects) {
938       warn(
939         `_bindResetFormAction - "resetForm" action not supported, ` +
940           "ensure that the `fieldObjects` parameter is provided."
941       );
942       if (!otherClickAction) {
943         link.onclick = () => false;
944       }
945       return;
946     }
947 
948     link.onclick = () => {
949       otherClickAction?.();
950 
951       const {
952         fields: resetFormFields,
953         refs: resetFormRefs,
954         include,
955       } = resetForm;
956 
957       const allFields = [];
958       if (resetFormFields.length !== 0 || resetFormRefs.length !== 0) {
959         const fieldIds = new Set(resetFormRefs);
960         for (const fieldName of resetFormFields) {
961           const fields = this._fieldObjects[fieldName] || [];
962           for (const { id } of fields) {
963             fieldIds.add(id);
964           }
965         }
966         for (const fields of Object.values(this._fieldObjects)) {
967           for (const field of fields) {
968             if (fieldIds.has(field.id) === include) {
969               allFields.push(field);
970             }
971           }
972         }
973       } else {
974         for (const fields of Object.values(this._fieldObjects)) {
975           allFields.push(...fields);
976         }
977       }
978 
979       const storage = this.annotationStorage;
980       const allIds = [];
981       for (const field of allFields) {
982         const { id } = field;
983         allIds.push(id);
984         switch (field.type) {
985           case "text": {
986             const value = field.defaultValue || "";
987             storage.setValue(id, { value });
988             break;
989           }
990           case "checkbox":
991           case "radiobutton": {
992             const value = field.defaultValue === field.exportValues;
993             storage.setValue(id, { value });
994             break;
995           }
996           case "combobox":
997           case "listbox": {
998             const value = field.defaultValue || "";
999             storage.setValue(id, { value });
1000             break;
1001           }
1002           default:
1003             continue;
1004         }
1005 
1006         const domElement = document.querySelector(`[data-element-id="${id}"]`);
1007         if (!domElement) {
1008           continue;
1009         } else if (!GetElementsByNameSet.has(domElement)) {
1010           warn(`_bindResetFormAction - element not allowed: ${id}`);
1011           continue;
1012         }
1013         domElement.dispatchEvent(new Event("resetform"));
1014       }
1015 
1016       if (this.enableScripting) {
1017         // Update the values in the sandbox.
1018         this.linkService.eventBus?.dispatch("dispatcheventinsandbox", {
1019           source: this,
1020           detail: {
1021             id: "app",
1022             ids: allIds,
1023             name: "ResetForm",
1024           },
1025         });
1026       }
1027 
1028       return false;
1029     };
1030   }
1031 }
1032 
1033 class TextAnnotationElement extends AnnotationElement {
1034   constructor(parameters) {
1035     super(parameters, { isRenderable: true });
1036   }
1037 
1038   render() {
1039     this.container.classList.add("textAnnotation");
1040 
1041     const image = document.createElement("img");
1042     image.src =
1043       this.imageResourcesPath +
1044       "annotation-" +
1045       this.data.name.toLowerCase() +
1046       ".svg";
1047     image.setAttribute("data-l10n-id", "pdfjs-text-annotation-type");
1048     image.setAttribute(
1049       "data-l10n-args",
1050       JSON.stringify({ type: this.data.name })
1051     );
1052 
1053     if (!this.data.popupRef && this.hasPopupData) {
1054       this._createPopup();
1055     }
1056 
1057     this.container.append(image);
1058     return this.container;
1059   }
1060 }
1061 
1062 class WidgetAnnotationElement extends AnnotationElement {
1063   render() {
1064     // Show only the container for unsupported field types.
1065     return this.container;
1066   }
1067 
1068   showElementAndHideCanvas(element) {
1069     if (this.data.hasOwnCanvas) {
1070       if (element.previousSibling?.nodeName === "CANVAS") {
1071         element.previousSibling.hidden = true;
1072       }
1073       element.hidden = false;
1074     }
1075   }
1076 
1077   _getKeyModifier(event) {
1078     return FeatureTest.platform.isMac ? event.metaKey : event.ctrlKey;
1079   }
1080 
1081   _setEventListener(element, elementData, baseName, eventName, valueGetter) {
1082     if (baseName.includes("mouse")) {
1083       // Mouse events
1084       element.addEventListener(baseName, event => {
1085         this.linkService.eventBus?.dispatch("dispatcheventinsandbox", {
1086           source: this,
1087           detail: {
1088             id: this.data.id,
1089             name: eventName,
1090             value: valueGetter(event),
1091             shift: event.shiftKey,
1092             modifier: this._getKeyModifier(event),
1093           },
1094         });
1095       });
1096     } else {
1097       // Non-mouse events
1098       element.addEventListener(baseName, event => {
1099         if (baseName === "blur") {
1100           if (!elementData.focused || !event.relatedTarget) {
1101             return;
1102           }
1103           elementData.focused = false;
1104         } else if (baseName === "focus") {
1105           if (elementData.focused) {
1106             return;
1107           }
1108           elementData.focused = true;
1109         }
1110 
1111         if (!valueGetter) {
1112           return;
1113         }
1114 
1115         this.linkService.eventBus?.dispatch("dispatcheventinsandbox", {
1116           source: this,
1117           detail: {
1118             id: this.data.id,
1119             name: eventName,
1120             value: valueGetter(event),
1121           },
1122         });
1123       });
1124     }
1125   }
1126 
1127   _setEventListeners(element, elementData, names, getter) {
1128     for (const [baseName, eventName] of names) {
1129       if (eventName === "Action" || this.data.actions?.[eventName]) {
1130         if (eventName === "Focus" || eventName === "Blur") {
1131           elementData ||= { focused: false };
1132         }
1133         this._setEventListener(
1134           element,
1135           elementData,
1136           baseName,
1137           eventName,
1138           getter
1139         );
1140         if (eventName === "Focus" && !this.data.actions?.Blur) {
1141           // Ensure that elementData will have the correct value.
1142           this._setEventListener(element, elementData, "blur", "Blur", null);
1143         } else if (eventName === "Blur" && !this.data.actions?.Focus) {
1144           this._setEventListener(element, elementData, "focus", "Focus", null);
1145         }
1146       }
1147     }
1148   }
1149 
1150   _setBackgroundColor(element) {
1151     const color = this.data.backgroundColor || null;
1152     element.style.backgroundColor =
1153       color === null
1154         ? "transparent"
1155         : Util.makeHexColor(color[0], color[1], color[2]);
1156   }
1157 
1158   /**
1159    * Apply text styles to the text in the element.
1160    *
1161    * @private
1162    * @param {HTMLDivElement} element
1163    * @memberof TextWidgetAnnotationElement
1164    */
1165   _setTextStyle(element) {
1166     const TEXT_ALIGNMENT = ["left", "center", "right"];
1167     const { fontColor } = this.data.defaultAppearanceData;
1168     const fontSize =
1169       this.data.defaultAppearanceData.fontSize || DEFAULT_FONT_SIZE;
1170 
1171     const style = element.style;
1172 
1173     // TODO: If the font-size is zero, calculate it based on the height and
1174     //       width of the element.
1175     // Not setting `style.fontSize` will use the default font-size for now.
1176 
1177     // We don't use the font, as specified in the PDF document, for the <input>
1178     // element. Hence using the original `fontSize` could look bad, which is why
1179     // it's instead based on the field height.
1180     // If the height is "big" then it could lead to a too big font size
1181     // so in this case use the one we've in the pdf (hence the min).
1182     let computedFontSize;
1183     const BORDER_SIZE = 2;
1184     const roundToOneDecimal = x => Math.round(10 * x) / 10;
1185     if (this.data.multiLine) {
1186       const height = Math.abs(
1187         this.data.rect[3] - this.data.rect[1] - BORDER_SIZE
1188       );
1189       const numberOfLines = Math.round(height / (LINE_FACTOR * fontSize)) || 1;
1190       const lineHeight = height / numberOfLines;
1191       computedFontSize = Math.min(
1192         fontSize,
1193         roundToOneDecimal(lineHeight / LINE_FACTOR)
1194       );
1195     } else {
1196       const height = Math.abs(
1197         this.data.rect[3] - this.data.rect[1] - BORDER_SIZE
1198       );
1199       computedFontSize = Math.min(
1200         fontSize,
1201         roundToOneDecimal(height / LINE_FACTOR)
1202       );
1203     }
1204     style.fontSize = `calc(${computedFontSize}px * var(--scale-factor))`;
1205 
1206     style.color = Util.makeHexColor(fontColor[0], fontColor[1], fontColor[2]);
1207 
1208     if (this.data.textAlignment !== null) {
1209       style.textAlign = TEXT_ALIGNMENT[this.data.textAlignment];
1210     }
1211   }
1212 
1213   _setRequired(element, isRequired) {
1214     if (isRequired) {
1215       element.setAttribute("required", true);
1216     } else {
1217       element.removeAttribute("required");
1218     }
1219     element.setAttribute("aria-required", isRequired);
1220   }
1221 }
1222 
1223 class TextWidgetAnnotationElement extends WidgetAnnotationElement {
1224   constructor(parameters) {
1225     const isRenderable =
1226       parameters.renderForms ||
1227       parameters.data.hasOwnCanvas ||
1228       (!parameters.data.hasAppearance && !!parameters.data.fieldValue);
1229     super(parameters, { isRenderable });
1230   }
1231 
1232   setPropertyOnSiblings(base, key, value, keyInStorage) {
1233     const storage = this.annotationStorage;
1234     for (const element of this._getElementsByName(
1235       base.name,
1236       /* skipId = */ base.id
1237     )) {
1238       if (element.domElement) {
1239         element.domElement[key] = value;
1240       }
1241       storage.setValue(element.id, { [keyInStorage]: value });
1242     }
1243   }
1244 
1245   render() {
1246     const storage = this.annotationStorage;
1247     const id = this.data.id;
1248 
1249     this.container.classList.add("textWidgetAnnotation");
1250 
1251     let element = null;
1252     if (this.renderForms) {
1253       // NOTE: We cannot set the values using `element.value` below, since it
1254       //       prevents the AnnotationLayer rasterizer in `test/driver.js`
1255       //       from parsing the elements correctly for the reference tests.
1256       const storedData = storage.getValue(id, {
1257         value: this.data.fieldValue,
1258       });
1259       let textContent = storedData.value || "";
1260       const maxLen = storage.getValue(id, {
1261         charLimit: this.data.maxLen,
1262       }).charLimit;
1263       if (maxLen && textContent.length > maxLen) {
1264         textContent = textContent.slice(0, maxLen);
1265       }
1266 
1267       let fieldFormattedValues =
1268         storedData.formattedValue || this.data.textContent?.join("\n") || null;
1269       if (fieldFormattedValues && this.data.comb) {
1270         fieldFormattedValues = fieldFormattedValues.replaceAll(/\s+/g, "");
1271       }
1272 
1273       const elementData = {
1274         userValue: textContent,
1275         formattedValue: fieldFormattedValues,
1276         lastCommittedValue: null,
1277         commitKey: 1,
1278         focused: false,
1279       };
1280 
1281       if (this.data.multiLine) {
1282         element = document.createElement("textarea");
1283         element.textContent = fieldFormattedValues ?? textContent;
1284         if (this.data.doNotScroll) {
1285           element.style.overflowY = "hidden";
1286         }
1287       } else {
1288         element = document.createElement("input");
1289         element.type = "text";
1290         element.setAttribute("value", fieldFormattedValues ?? textContent);
1291         if (this.data.doNotScroll) {
1292           element.style.overflowX = "hidden";
1293         }
1294       }
1295       if (this.data.hasOwnCanvas) {
1296         element.hidden = true;
1297       }
1298       GetElementsByNameSet.add(element);
1299       element.setAttribute("data-element-id", id);
1300 
1301       element.disabled = this.data.readOnly;
1302       element.name = this.data.fieldName;
1303       element.tabIndex = DEFAULT_TAB_INDEX;
1304 
1305       this._setRequired(element, this.data.required);
1306 
1307       if (maxLen) {
1308         element.maxLength = maxLen;
1309       }
1310 
1311       element.addEventListener("input", event => {
1312         storage.setValue(id, { value: event.target.value });
1313         this.setPropertyOnSiblings(
1314           element,
1315           "value",
1316           event.target.value,
1317           "value"
1318         );
1319         elementData.formattedValue = null;
1320       });
1321 
1322       element.addEventListener("resetform", event => {
1323         const defaultValue = this.data.defaultFieldValue ?? "";
1324         element.value = elementData.userValue = defaultValue;
1325         elementData.formattedValue = null;
1326       });
1327 
1328       let blurListener = event => {
1329         const { formattedValue } = elementData;
1330         if (formattedValue !== null && formattedValue !== undefined) {
1331           event.target.value = formattedValue;
1332         }
1333         // Reset the cursor position to the start of the field (issue 12359).
1334         event.target.scrollLeft = 0;
1335       };
1336 
1337       if (this.enableScripting && this.hasJSActions) {
1338         element.addEventListener("focus", event => {
1339           if (elementData.focused) {
1340             return;
1341           }
1342           const { target } = event;
1343           if (elementData.userValue) {
1344             target.value = elementData.userValue;
1345           }
1346           elementData.lastCommittedValue = target.value;
1347           elementData.commitKey = 1;
1348           if (!this.data.actions?.Focus) {
1349             elementData.focused = true;
1350           }
1351         });
1352 
1353         element.addEventListener("updatefromsandbox", jsEvent => {
1354           this.showElementAndHideCanvas(jsEvent.target);
1355           const actions = {
1356             value(event) {
1357               elementData.userValue = event.detail.value ?? "";
1358               storage.setValue(id, { value: elementData.userValue.toString() });
1359               event.target.value = elementData.userValue;
1360             },
1361             formattedValue(event) {
1362               const { formattedValue } = event.detail;
1363               elementData.formattedValue = formattedValue;
1364               if (
1365                 formattedValue !== null &&
1366                 formattedValue !== undefined &&
1367                 event.target !== document.activeElement
1368               ) {
1369                 // Input hasn't the focus so display formatted string
1370                 event.target.value = formattedValue;
1371               }
1372               storage.setValue(id, {
1373                 formattedValue,
1374               });
1375             },
1376             selRange(event) {
1377               event.target.setSelectionRange(...event.detail.selRange);
1378             },
1379             charLimit: event => {
1380               const { charLimit } = event.detail;
1381               const { target } = event;
1382               if (charLimit === 0) {
1383                 target.removeAttribute("maxLength");
1384                 return;
1385               }
1386 
1387               target.setAttribute("maxLength", charLimit);
1388               let value = elementData.userValue;
1389               if (!value || value.length <= charLimit) {
1390                 return;
1391               }
1392               value = value.slice(0, charLimit);
1393               target.value = elementData.userValue = value;
1394               storage.setValue(id, { value });
1395 
1396               this.linkService.eventBus?.dispatch("dispatcheventinsandbox", {
1397                 source: this,
1398                 detail: {
1399                   id,
1400                   name: "Keystroke",
1401                   value,
1402                   willCommit: true,
1403                   commitKey: 1,
1404                   selStart: target.selectionStart,
1405                   selEnd: target.selectionEnd,
1406                 },
1407               });
1408             },
1409           };
1410           this._dispatchEventFromSandbox(actions, jsEvent);
1411         });
1412 
1413         // Even if the field hasn't any actions
1414         // leaving it can still trigger some actions with Calculate
1415         element.addEventListener("keydown", event => {
1416           elementData.commitKey = 1;
1417           // If the key is one of Escape, Enter then the data are committed.
1418           // If we've a Tab then data will be committed on blur.
1419           let commitKey = -1;
1420           if (event.key === "Escape") {
1421             commitKey = 0;
1422           } else if (event.key === "Enter" && !this.data.multiLine) {
1423             // When we've a multiline field, "Enter" key is a key as the other
1424             // hence we don't commit the data (Acrobat behaves the same way)
1425             // (see issue #15627).
1426             commitKey = 2;
1427           } else if (event.key === "Tab") {
1428             elementData.commitKey = 3;
1429           }
1430           if (commitKey === -1) {
1431             return;
1432           }
1433           const { value } = event.target;
1434           if (elementData.lastCommittedValue === value) {
1435             return;
1436           }
1437           elementData.lastCommittedValue = value;
1438           // Save the entered value
1439           elementData.userValue = value;
1440           this.linkService.eventBus?.dispatch("dispatcheventinsandbox", {
1441             source: this,
1442             detail: {
1443               id,
1444               name: "Keystroke",
1445               value,
1446               willCommit: true,
1447               commitKey,
1448               selStart: event.target.selectionStart,
1449               selEnd: event.target.selectionEnd,
1450             },
1451           });
1452         });
1453         const _blurListener = blurListener;
1454         blurListener = null;
1455         element.addEventListener("blur", event => {
1456           if (!elementData.focused || !event.relatedTarget) {
1457             return;
1458           }
1459           if (!this.data.actions?.Blur) {
1460             elementData.focused = false;
1461           }
1462           const { value } = event.target;
1463           elementData.userValue = value;
1464           if (elementData.lastCommittedValue !== value) {
1465             this.linkService.eventBus?.dispatch("dispatcheventinsandbox", {
1466               source: this,
1467               detail: {
1468                 id,
1469                 name: "Keystroke",
1470                 value,
1471                 willCommit: true,
1472                 commitKey: elementData.commitKey,
1473                 selStart: event.target.selectionStart,
1474                 selEnd: event.target.selectionEnd,
1475               },
1476             });
1477           }
1478           _blurListener(event);
1479         });
1480 
1481         if (this.data.actions?.Keystroke) {
1482           element.addEventListener("beforeinput", event => {
1483             elementData.lastCommittedValue = null;
1484             const { data, target } = event;
1485             const { value, selectionStart, selectionEnd } = target;
1486 
1487             let selStart = selectionStart,
1488               selEnd = selectionEnd;
1489 
1490             switch (event.inputType) {
1491               // https://rawgit.com/w3c/input-events/v1/index.html#interface-InputEvent-Attributes
1492               case "deleteWordBackward": {
1493                 const match = value
1494                   .substring(0, selectionStart)
1495                   .match(/\w*[^\w]*$/);
1496                 if (match) {
1497                   selStart -= match[0].length;
1498                 }
1499                 break;
1500               }
1501               case "deleteWordForward": {
1502                 const match = value
1503                   .substring(selectionStart)
1504                   .match(/^[^\w]*\w*/);
1505                 if (match) {
1506                   selEnd += match[0].length;
1507                 }
1508                 break;
1509               }
1510               case "deleteContentBackward":
1511                 if (selectionStart === selectionEnd) {
1512                   selStart -= 1;
1513                 }
1514                 break;
1515               case "deleteContentForward":
1516                 if (selectionStart === selectionEnd) {
1517                   selEnd += 1;
1518                 }
1519                 break;
1520             }
1521 
1522             // We handle the event ourselves.
1523             event.preventDefault();
1524             this.linkService.eventBus?.dispatch("dispatcheventinsandbox", {
1525               source: this,
1526               detail: {
1527                 id,
1528                 name: "Keystroke",
1529                 value,
1530                 change: data || "",
1531                 willCommit: false,
1532                 selStart,
1533                 selEnd,
1534               },
1535             });
1536           });
1537         }
1538 
1539         this._setEventListeners(
1540           element,
1541           elementData,
1542           [
1543             ["focus", "Focus"],
1544             ["blur", "Blur"],
1545             ["mousedown", "Mouse Down"],
1546             ["mouseenter", "Mouse Enter"],
1547             ["mouseleave", "Mouse Exit"],
1548             ["mouseup", "Mouse Up"],
1549           ],
1550           event => event.target.value
1551         );
1552       }
1553 
1554       if (blurListener) {
1555         element.addEventListener("blur", blurListener);
1556       }
1557 
1558       if (this.data.comb) {
1559         const fieldWidth = this.data.rect[2] - this.data.rect[0];
1560         const combWidth = fieldWidth / maxLen;
1561 
1562         element.classList.add("comb");
1563         element.style.letterSpacing = `calc(${combWidth}px * var(--scale-factor) - 1ch)`;
1564       }
1565     } else {
1566       element = document.createElement("div");
1567       element.textContent = this.data.fieldValue;
1568       element.style.verticalAlign = "middle";
1569       element.style.display = "table-cell";
1570 
1571       if (this.data.hasOwnCanvas) {
1572         element.hidden = true;
1573       }
1574     }
1575 
1576     this._setTextStyle(element);
1577     this._setBackgroundColor(element);
1578     this._setDefaultPropertiesFromJS(element);
1579 
1580     this.container.append(element);
1581     return this.container;
1582   }
1583 }
1584 
1585 class SignatureWidgetAnnotationElement extends WidgetAnnotationElement {
1586   constructor(parameters) {
1587     super(parameters, { isRenderable: !!parameters.data.hasOwnCanvas });
1588   }
1589 }
1590 
1591 class CheckboxWidgetAnnotationElement extends WidgetAnnotationElement {
1592   constructor(parameters) {
1593     super(parameters, { isRenderable: parameters.renderForms });
1594   }
1595 
1596   render() {
1597     const storage = this.annotationStorage;
1598     const data = this.data;
1599     const id = data.id;
1600     let value = storage.getValue(id, {
1601       value: data.exportValue === data.fieldValue,
1602     }).value;
1603     if (typeof value === "string") {
1604       // The value has been changed through js and set in annotationStorage.
1605       value = value !== "Off";
1606       storage.setValue(id, { value });
1607     }
1608 
1609     this.container.classList.add("buttonWidgetAnnotation", "checkBox");
1610 
1611     const element = document.createElement("input");
1612     GetElementsByNameSet.add(element);
1613     element.setAttribute("data-element-id", id);
1614 
1615     element.disabled = data.readOnly;
1616     this._setRequired(element, this.data.required);
1617     element.type = "checkbox";
1618     element.name = data.fieldName;
1619     if (value) {
1620       element.setAttribute("checked", true);
1621     }
1622     element.setAttribute("exportValue", data.exportValue);
1623     element.tabIndex = DEFAULT_TAB_INDEX;
1624 
1625     element.addEventListener("change", event => {
1626       const { name, checked } = event.target;
1627       for (const checkbox of this._getElementsByName(name, /* skipId = */ id)) {
1628         const curChecked = checked && checkbox.exportValue === data.exportValue;
1629         if (checkbox.domElement) {
1630           checkbox.domElement.checked = curChecked;
1631         }
1632         storage.setValue(checkbox.id, { value: curChecked });
1633       }
1634       storage.setValue(id, { value: checked });
1635     });
1636 
1637     element.addEventListener("resetform", event => {
1638       const defaultValue = data.defaultFieldValue || "Off";
1639       event.target.checked = defaultValue === data.exportValue;
1640     });
1641 
1642     if (this.enableScripting && this.hasJSActions) {
1643       element.addEventListener("updatefromsandbox", jsEvent => {
1644         const actions = {
1645           value(event) {
1646             event.target.checked = event.detail.value !== "Off";
1647             storage.setValue(id, { value: event.target.checked });
1648           },
1649         };
1650         this._dispatchEventFromSandbox(actions, jsEvent);
1651       });
1652 
1653       this._setEventListeners(
1654         element,
1655         null,
1656         [
1657           ["change", "Validate"],
1658           ["change", "Action"],
1659           ["focus", "Focus"],
1660           ["blur", "Blur"],
1661           ["mousedown", "Mouse Down"],
1662           ["mouseenter", "Mouse Enter"],
1663           ["mouseleave", "Mouse Exit"],
1664           ["mouseup", "Mouse Up"],
1665         ],
1666         event => event.target.checked
1667       );
1668     }
1669 
1670     this._setBackgroundColor(element);
1671     this._setDefaultPropertiesFromJS(element);
1672 
1673     this.container.append(element);
1674     return this.container;
1675   }
1676 }
1677 
1678 class RadioButtonWidgetAnnotationElement extends WidgetAnnotationElement {
1679   constructor(parameters) {
1680     super(parameters, { isRenderable: parameters.renderForms });
1681   }
1682 
1683   render() {
1684     this.container.classList.add("buttonWidgetAnnotation", "radioButton");
1685     const storage = this.annotationStorage;
1686     const data = this.data;
1687     const id = data.id;
1688     let value = storage.getValue(id, {
1689       value: data.fieldValue === data.buttonValue,
1690     }).value;
1691     if (typeof value === "string") {
1692       // The value has been changed through js and set in annotationStorage.
1693       value = value !== data.buttonValue;
1694       storage.setValue(id, { value });
1695     }
1696 
1697     if (value) {
1698       // It's possible that multiple radio buttons are checked.
1699       // So if this one is checked we just reset the other ones.
1700       // (see bug 1864136). Then when the other ones will be rendered they will
1701       // unchecked (because of their value in the storage).
1702       // Consequently, the first checked radio button will be the only checked
1703       // one.
1704       for (const radio of this._getElementsByName(
1705         data.fieldName,
1706         /* skipId = */ id
1707       )) {
1708         storage.setValue(radio.id, { value: false });
1709       }
1710     }
1711 
1712     const element = document.createElement("input");
1713     GetElementsByNameSet.add(element);
1714     element.setAttribute("data-element-id", id);
1715 
1716     element.disabled = data.readOnly;
1717     this._setRequired(element, this.data.required);
1718     element.type = "radio";
1719     element.name = data.fieldName;
1720     if (value) {
1721       element.setAttribute("checked", true);
1722     }
1723     element.tabIndex = DEFAULT_TAB_INDEX;
1724 
1725     element.addEventListener("change", event => {
1726       const { name, checked } = event.target;
1727       for (const radio of this._getElementsByName(name, /* skipId = */ id)) {
1728         storage.setValue(radio.id, { value: false });
1729       }
1730       storage.setValue(id, { value: checked });
1731     });
1732 
1733     element.addEventListener("resetform", event => {
1734       const defaultValue = data.defaultFieldValue;
1735       event.target.checked =
1736         defaultValue !== null &&
1737         defaultValue !== undefined &&
1738         defaultValue === data.buttonValue;
1739     });
1740 
1741     if (this.enableScripting && this.hasJSActions) {
1742       const pdfButtonValue = data.buttonValue;
1743       element.addEventListener("updatefromsandbox", jsEvent => {
1744         const actions = {
1745           value: event => {
1746             const checked = pdfButtonValue === event.detail.value;
1747             for (const radio of this._getElementsByName(event.target.name)) {
1748               const curChecked = checked && radio.id === id;
1749               if (radio.domElement) {
1750                 radio.domElement.checked = curChecked;
1751               }
1752               storage.setValue(radio.id, { value: curChecked });
1753             }
1754           },
1755         };
1756         this._dispatchEventFromSandbox(actions, jsEvent);
1757       });
1758 
1759       this._setEventListeners(
1760         element,
1761         null,
1762         [
1763           ["change", "Validate"],
1764           ["change", "Action"],
1765           ["focus", "Focus"],
1766           ["blur", "Blur"],
1767           ["mousedown", "Mouse Down"],
1768           ["mouseenter", "Mouse Enter"],
1769           ["mouseleave", "Mouse Exit"],
1770           ["mouseup", "Mouse Up"],
1771         ],
1772         event => event.target.checked
1773       );
1774     }
1775 
1776     this._setBackgroundColor(element);
1777     this._setDefaultPropertiesFromJS(element);
1778 
1779     this.container.append(element);
1780     return this.container;
1781   }
1782 }
1783 
1784 class PushButtonWidgetAnnotationElement extends LinkAnnotationElement {
1785   constructor(parameters) {
1786     super(parameters, { ignoreBorder: parameters.data.hasAppearance });
1787   }
1788 
1789   render() {
1790     // The rendering and functionality of a push button widget annotation is
1791     // equal to that of a link annotation, but may have more functionality, such
1792     // as performing actions on form fields (resetting, submitting, et cetera).
1793     const container = super.render();
1794     container.classList.add("buttonWidgetAnnotation", "pushButton");
1795 
1796     const linkElement = container.lastChild;
1797     if (this.enableScripting && this.hasJSActions && linkElement) {
1798       this._setDefaultPropertiesFromJS(linkElement);
1799 
1800       linkElement.addEventListener("updatefromsandbox", jsEvent => {
1801         this._dispatchEventFromSandbox({}, jsEvent);
1802       });
1803     }
1804 
1805     return container;
1806   }
1807 }
1808 
1809 class ChoiceWidgetAnnotationElement extends WidgetAnnotationElement {
1810   constructor(parameters) {
1811     super(parameters, { isRenderable: parameters.renderForms });
1812   }
1813 
1814   render() {
1815     this.container.classList.add("choiceWidgetAnnotation");
1816     const storage = this.annotationStorage;
1817     const id = this.data.id;
1818 
1819     const storedData = storage.getValue(id, {
1820       value: this.data.fieldValue,
1821     });
1822 
1823     const selectElement = document.createElement("select");
1824     GetElementsByNameSet.add(selectElement);
1825     selectElement.setAttribute("data-element-id", id);
1826 
1827     selectElement.disabled = this.data.readOnly;
1828     this._setRequired(selectElement, this.data.required);
1829     selectElement.name = this.data.fieldName;
1830     selectElement.tabIndex = DEFAULT_TAB_INDEX;
1831 
1832     let addAnEmptyEntry = this.data.combo && this.data.options.length > 0;
1833 
1834     if (!this.data.combo) {
1835       // List boxes have a size and (optionally) multiple selection.
1836       selectElement.size = this.data.options.length;
1837       if (this.data.multiSelect) {
1838         selectElement.multiple = true;
1839       }
1840     }
1841 
1842     selectElement.addEventListener("resetform", event => {
1843       const defaultValue = this.data.defaultFieldValue;
1844       for (const option of selectElement.options) {
1845         option.selected = option.value === defaultValue;
1846       }
1847     });
1848 
1849     // Insert the options into the choice field.
1850     for (const option of this.data.options) {
1851       const optionElement = document.createElement("option");
1852       optionElement.textContent = option.displayValue;
1853       optionElement.value = option.exportValue;
1854       if (storedData.value.includes(option.exportValue)) {
1855         optionElement.setAttribute("selected", true);
1856         addAnEmptyEntry = false;
1857       }
1858       selectElement.append(optionElement);
1859     }
1860 
1861     let removeEmptyEntry = null;
1862     if (addAnEmptyEntry) {
1863       const noneOptionElement = document.createElement("option");
1864       noneOptionElement.value = " ";
1865       noneOptionElement.setAttribute("hidden", true);
1866       noneOptionElement.setAttribute("selected", true);
1867       selectElement.prepend(noneOptionElement);
1868 
1869       removeEmptyEntry = () => {
1870         noneOptionElement.remove();
1871         selectElement.removeEventListener("input", removeEmptyEntry);
1872         removeEmptyEntry = null;
1873       };
1874       selectElement.addEventListener("input", removeEmptyEntry);
1875     }
1876 
1877     const getValue = isExport => {
1878       const name = isExport ? "value" : "textContent";
1879       const { options, multiple } = selectElement;
1880       if (!multiple) {
1881         return options.selectedIndex === -1
1882           ? null
1883           : options[options.selectedIndex][name];
1884       }
1885       return Array.prototype.filter
1886         .call(options, option => option.selected)
1887         .map(option => option[name]);
1888     };
1889 
1890     let selectedValues = getValue(/* isExport */ false);
1891 
1892     const getItems = event => {
1893       const options = event.target.options;
1894       return Array.prototype.map.call(options, option => ({
1895         displayValue: option.textContent,
1896         exportValue: option.value,
1897       }));
1898     };
1899 
1900     if (this.enableScripting && this.hasJSActions) {
1901       selectElement.addEventListener("updatefromsandbox", jsEvent => {
1902         const actions = {
1903           value(event) {
1904             removeEmptyEntry?.();
1905             const value = event.detail.value;
1906             const values = new Set(Array.isArray(value) ? value : [value]);
1907             for (const option of selectElement.options) {
1908               option.selected = values.has(option.value);
1909             }
1910             storage.setValue(id, {
1911               value: getValue(/* isExport */ true),
1912             });
1913             selectedValues = getValue(/* isExport */ false);
1914           },
1915           multipleSelection(event) {
1916             selectElement.multiple = true;
1917           },
1918           remove(event) {
1919             const options = selectElement.options;
1920             const index = event.detail.remove;
1921             options[index].selected = false;
1922             selectElement.remove(index);
1923             if (options.length > 0) {
1924               const i = Array.prototype.findIndex.call(
1925                 options,
1926                 option => option.selected
1927               );
1928               if (i === -1) {
1929                 options[0].selected = true;
1930               }
1931             }
1932             storage.setValue(id, {
1933               value: getValue(/* isExport */ true),
1934               items: getItems(event),
1935             });
1936             selectedValues = getValue(/* isExport */ false);
1937           },
1938           clear(event) {
1939             while (selectElement.length !== 0) {
1940               selectElement.remove(0);
1941             }
1942             storage.setValue(id, { value: null, items: [] });
1943             selectedValues = getValue(/* isExport */ false);
1944           },
1945           insert(event) {
1946             const { index, displayValue, exportValue } = event.detail.insert;
1947             const selectChild = selectElement.children[index];
1948             const optionElement = document.createElement("option");
1949             optionElement.textContent = displayValue;
1950             optionElement.value = exportValue;
1951 
1952             if (selectChild) {
1953               selectChild.before(optionElement);
1954             } else {
1955               selectElement.append(optionElement);
1956             }
1957             storage.setValue(id, {
1958               value: getValue(/* isExport */ true),
1959               items: getItems(event),
1960             });
1961             selectedValues = getValue(/* isExport */ false);
1962           },
1963           items(event) {
1964             const { items } = event.detail;
1965             while (selectElement.length !== 0) {
1966               selectElement.remove(0);
1967             }
1968             for (const item of items) {
1969               const { displayValue, exportValue } = item;
1970               const optionElement = document.createElement("option");
1971               optionElement.textContent = displayValue;
1972               optionElement.value = exportValue;
1973               selectElement.append(optionElement);
1974             }
1975             if (selectElement.options.length > 0) {
1976               selectElement.options[0].selected = true;
1977             }
1978             storage.setValue(id, {
1979               value: getValue(/* isExport */ true),
1980               items: getItems(event),
1981             });
1982             selectedValues = getValue(/* isExport */ false);
1983           },
1984           indices(event) {
1985             const indices = new Set(event.detail.indices);
1986             for (const option of event.target.options) {
1987               option.selected = indices.has(option.index);
1988             }
1989             storage.setValue(id, {
1990               value: getValue(/* isExport */ true),
1991             });
1992             selectedValues = getValue(/* isExport */ false);
1993           },
1994           editable(event) {
1995             event.target.disabled = !event.detail.editable;
1996           },
1997         };
1998         this._dispatchEventFromSandbox(actions, jsEvent);
1999       });
2000 
2001       selectElement.addEventListener("input", event => {
2002         const exportValue = getValue(/* isExport */ true);
2003         const change = getValue(/* isExport */ false);
2004         storage.setValue(id, { value: exportValue });
2005 
2006         event.preventDefault();
2007 
2008         this.linkService.eventBus?.dispatch("dispatcheventinsandbox", {
2009           source: this,
2010           detail: {
2011             id,
2012             name: "Keystroke",
2013             value: selectedValues,
2014             change,
2015             changeEx: exportValue,
2016             willCommit: false,
2017             commitKey: 1,
2018             keyDown: false,
2019           },
2020         });
2021       });
2022 
2023       this._setEventListeners(
2024         selectElement,
2025         null,
2026         [
2027           ["focus", "Focus"],
2028           ["blur", "Blur"],
2029           ["mousedown", "Mouse Down"],
2030           ["mouseenter", "Mouse Enter"],
2031           ["mouseleave", "Mouse Exit"],
2032           ["mouseup", "Mouse Up"],
2033           ["input", "Action"],
2034           ["input", "Validate"],
2035         ],
2036         event => event.target.value
2037       );
2038     } else {
2039       selectElement.addEventListener("input", function (event) {
2040         storage.setValue(id, { value: getValue(/* isExport */ true) });
2041       });
2042     }
2043 
2044     if (this.data.combo) {
2045       this._setTextStyle(selectElement);
2046     } else {
2047       // Just use the default font size...
2048       // it's a bit hard to guess what is a good size.
2049     }
2050     this._setBackgroundColor(selectElement);
2051     this._setDefaultPropertiesFromJS(selectElement);
2052 
2053     this.container.append(selectElement);
2054     return this.container;
2055   }
2056 }
2057 
2058 class PopupAnnotationElement extends AnnotationElement {
2059   constructor(parameters) {
2060     const { data, elements } = parameters;
2061     super(parameters, { isRenderable: AnnotationElement._hasPopupData(data) });
2062     this.elements = elements;
2063     this.popup = null;
2064   }
2065 
2066   render() {
2067     this.container.classList.add("popupAnnotation");
2068 
2069     const popup = (this.popup = new PopupElement({
2070       container: this.container,
2071       color: this.data.color,
2072       titleObj: this.data.titleObj,
2073       modificationDate: this.data.modificationDate,
2074       contentsObj: this.data.contentsObj,
2075       richText: this.data.richText,
2076       rect: this.data.rect,
2077       parentRect: this.data.parentRect || null,
2078       parent: this.parent,
2079       elements: this.elements,
2080       open: this.data.open,
2081     }));
2082 
2083     const elementIds = [];
2084     for (const element of this.elements) {
2085       element.popup = popup;
2086       element.container.ariaHasPopup = "dialog";
2087       elementIds.push(element.data.id);
2088       element.addHighlightArea();
2089     }
2090 
2091     this.container.setAttribute(
2092       "aria-controls",
2093       elementIds.map(id => `${AnnotationPrefix}${id}`).join(",")
2094     );
2095 
2096     return this.container;
2097   }
2098 }
2099 
2100 class PopupElement {
2101   #boundKeyDown = this.#keyDown.bind(this);
2102 
2103   #boundHide = this.#hide.bind(this);
2104 
2105   #boundShow = this.#show.bind(this);
2106 
2107   #boundToggle = this.#toggle.bind(this);
2108 
2109   #color = null;
2110 
2111   #container = null;
2112 
2113   #contentsObj = null;
2114 
2115   #dateObj = null;
2116 
2117   #elements = null;
2118 
2119   #parent = null;
2120 
2121   #parentRect = null;
2122 
2123   #pinned = false;
2124 
2125   #popup = null;
2126 
2127   #position = null;
2128 
2129   #rect = null;
2130 
2131   #richText = null;
2132 
2133   #titleObj = null;
2134 
2135   #updates = null;
2136 
2137   #wasVisible = false;
2138 
2139   constructor({
2140     container,
2141     color,
2142     elements,
2143     titleObj,
2144     modificationDate,
2145     contentsObj,
2146     richText,
2147     parent,
2148     rect,
2149     parentRect,
2150     open,
2151   }) {
2152     this.#container = container;
2153     this.#titleObj = titleObj;
2154     this.#contentsObj = contentsObj;
2155     this.#richText = richText;
2156     this.#parent = parent;
2157     this.#color = color;
2158     this.#rect = rect;
2159     this.#parentRect = parentRect;
2160     this.#elements = elements;
2161 
2162     // The modification date is shown in the popup instead of the creation
2163     // date if it is available and can be parsed correctly, which is
2164     // consistent with other viewers such as Adobe Acrobat.
2165     this.#dateObj = PDFDateString.toDateObject(modificationDate);
2166 
2167     this.trigger = elements.flatMap(e => e.getElementsToTriggerPopup());
2168     // Attach the event listeners to the trigger element.
2169     for (const element of this.trigger) {
2170       element.addEventListener("click", this.#boundToggle);
2171       element.addEventListener("mouseenter", this.#boundShow);
2172       element.addEventListener("mouseleave", this.#boundHide);
2173       element.classList.add("popupTriggerArea");
2174     }
2175 
2176     // Attach the event listener to toggle the popup with the keyboard.
2177     for (const element of elements) {
2178       element.container?.addEventListener("keydown", this.#boundKeyDown);
2179     }
2180 
2181     this.#container.hidden = true;
2182     if (open) {
2183       this.#toggle();
2184     }
2185 
2186     if (typeof PDFJSDev !== "undefined" && PDFJSDev.test("TESTING")) {
2187       // Since the popup is lazily created, we need to ensure that it'll be
2188       // created and displayed during reference tests.
2189       this.#parent.popupShow.push(async () => {
2190         if (this.#container.hidden) {
2191           this.#show();
2192         }
2193       });
2194     }
2195   }
2196 
2197   render() {
2198     if (this.#popup) {
2199       return;
2200     }
2201 
2202     const popup = (this.#popup = document.createElement("div"));
2203     popup.className = "popup";
2204 
2205     if (this.#color) {
2206       const baseColor = (popup.style.outlineColor = Util.makeHexColor(
2207         ...this.#color
2208       ));
2209       if (
2210         (typeof PDFJSDev !== "undefined" && PDFJSDev.test("MOZCENTRAL")) ||
2211         CSS.supports("background-color", "color-mix(in srgb, red 30%, white)")
2212       ) {
2213         popup.style.backgroundColor = `color-mix(in srgb, ${baseColor} 30%, white)`;
2214       } else {
2215         // color-mix isn't supported in some browsers hence this version.
2216         // See https://developer.mozilla.org/en-US/docs/Web/CSS/color_value/color-mix#browser_compatibility
2217         // TODO: Use color-mix when it's supported everywhere.
2218         // Enlighten the color.
2219         const BACKGROUND_ENLIGHT = 0.7;
2220         popup.style.backgroundColor = Util.makeHexColor(
2221           ...this.#color.map(c =>
2222             Math.floor(BACKGROUND_ENLIGHT * (255 - c) + c)
2223           )
2224         );
2225       }
2226     }
2227 
2228     const header = document.createElement("span");
2229     header.className = "header";
2230     const title = document.createElement("h1");
2231     header.append(title);
2232     ({ dir: title.dir, str: title.textContent } = this.#titleObj);
2233     popup.append(header);
2234 
2235     if (this.#dateObj) {
2236       const modificationDate = document.createElement("span");
2237       modificationDate.classList.add("popupDate");
2238       modificationDate.setAttribute(
2239         "data-l10n-id",
2240         "pdfjs-annotation-date-time-string"
2241       );
2242       modificationDate.setAttribute(
2243         "data-l10n-args",
2244         JSON.stringify({ dateObj: this.#dateObj.valueOf() })
2245       );
2246       header.append(modificationDate);
2247     }
2248 
2249     const html = this.#html;
2250     if (html) {
2251       XfaLayer.render({
2252         xfaHtml: html,
2253         intent: "richText",
2254         div: popup,
2255       });
2256       popup.lastChild.classList.add("richText", "popupContent");
2257     } else {
2258       const contents = this._formatContents(this.#contentsObj);
2259       popup.append(contents);
2260     }
2261     this.#container.append(popup);
2262   }
2263 
2264   get #html() {
2265     const richText = this.#richText;
2266     const contentsObj = this.#contentsObj;
2267     if (
2268       richText?.str &&
2269       (!contentsObj?.str || contentsObj.str === richText.str)
2270     ) {
2271       return this.#richText.html || null;
2272     }
2273     return null;
2274   }
2275 
2276   get #fontSize() {
2277     return this.#html?.attributes?.style?.fontSize || 0;
2278   }
2279 
2280   get #fontColor() {
2281     return this.#html?.attributes?.style?.color || null;
2282   }
2283 
2284   #makePopupContent(text) {
2285     const popupLines = [];
2286     const popupContent = {
2287       str: text,
2288       html: {
2289         name: "div",
2290         attributes: {
2291           dir: "auto",
2292         },
2293         children: [
2294           {
2295             name: "p",
2296             children: popupLines,
2297           },
2298         ],
2299       },
2300     };
2301     const lineAttributes = {
2302       style: {
2303         color: this.#fontColor,
2304         fontSize: this.#fontSize
2305           ? `calc(${this.#fontSize}px * var(--scale-factor))`
2306           : "",
2307       },
2308     };
2309     for (const line of text.split("\n")) {
2310       popupLines.push({
2311         name: "span",
2312         value: line,
2313         attributes: lineAttributes,
2314       });
2315     }
2316     return popupContent;
2317   }
2318 
2319   /**
2320    * Format the contents of the popup by adding newlines where necessary.
2321    *
2322    * @private
2323    * @param {Object<string, string>} contentsObj
2324    * @memberof PopupElement
2325    * @returns {HTMLParagraphElement}
2326    */
2327   _formatContents({ str, dir }) {
2328     const p = document.createElement("p");
2329     p.classList.add("popupContent");
2330     p.dir = dir;
2331     const lines = str.split(/(?:\r\n?|\n)/);
2332     for (let i = 0, ii = lines.length; i < ii; ++i) {
2333       const line = lines[i];
2334       p.append(document.createTextNode(line));
2335       if (i < ii - 1) {
2336         p.append(document.createElement("br"));
2337       }
2338     }
2339     return p;
2340   }
2341 
2342   #keyDown(event) {
2343     if (event.altKey || event.shiftKey || event.ctrlKey || event.metaKey) {
2344       return;
2345     }
2346 
2347     if (event.key === "Enter" || (event.key === "Escape" && this.#pinned)) {
2348       this.#toggle();
2349     }
2350   }
2351 
2352   updateEdited({ rect, popupContent }) {
2353     this.#updates ||= {
2354       contentsObj: this.#contentsObj,
2355       richText: this.#richText,
2356     };
2357     if (rect) {
2358       this.#position = null;
2359     }
2360     if (popupContent) {
2361       this.#richText = this.#makePopupContent(popupContent);
2362       this.#contentsObj = null;
2363     }
2364     this.#popup?.remove();
2365     this.#popup = null;
2366   }
2367 
2368   resetEdited() {
2369     if (!this.#updates) {
2370       return;
2371     }
2372     ({ contentsObj: this.#contentsObj, richText: this.#richText } =
2373       this.#updates);
2374     this.#updates = null;
2375     this.#popup?.remove();
2376     this.#popup = null;
2377     this.#position = null;
2378   }
2379 
2380   #setPosition() {
2381     if (this.#position !== null) {
2382       return;
2383     }
2384     const {
2385       page: { view },
2386       viewport: {
2387         rawDims: { pageWidth, pageHeight, pageX, pageY },
2388       },
2389     } = this.#parent;
2390 
2391     let useParentRect = !!this.#parentRect;
2392     let rect = useParentRect ? this.#parentRect : this.#rect;
2393     for (const element of this.#elements) {
2394       if (!rect || Util.intersect(element.data.rect, rect) !== null) {
2395         rect = element.data.rect;
2396         useParentRect = true;
2397         break;
2398       }
2399     }
2400 
2401     const normalizedRect = Util.normalizeRect([
2402       rect[0],
2403       view[3] - rect[1] + view[1],
2404       rect[2],
2405       view[3] - rect[3] + view[1],
2406     ]);
2407 
2408     const HORIZONTAL_SPACE_AFTER_ANNOTATION = 5;
2409     const parentWidth = useParentRect
2410       ? rect[2] - rect[0] + HORIZONTAL_SPACE_AFTER_ANNOTATION
2411       : 0;
2412     const popupLeft = normalizedRect[0] + parentWidth;
2413     const popupTop = normalizedRect[1];
2414     this.#position = [
2415       (100 * (popupLeft - pageX)) / pageWidth,
2416       (100 * (popupTop - pageY)) / pageHeight,
2417     ];
2418 
2419     const { style } = this.#container;
2420     style.left = `${this.#position[0]}%`;
2421     style.top = `${this.#position[1]}%`;
2422   }
2423 
2424   /**
2425    * Toggle the visibility of the popup.
2426    */
2427   #toggle() {
2428     this.#pinned = !this.#pinned;
2429     if (this.#pinned) {
2430       this.#show();
2431       this.#container.addEventListener("click", this.#boundToggle);
2432       this.#container.addEventListener("keydown", this.#boundKeyDown);
2433     } else {
2434       this.#hide();
2435       this.#container.removeEventListener("click", this.#boundToggle);
2436       this.#container.removeEventListener("keydown", this.#boundKeyDown);
2437     }
2438   }
2439 
2440   /**
2441    * Show the popup.
2442    */
2443   #show() {
2444     if (!this.#popup) {
2445       this.render();
2446     }
2447     if (!this.isVisible) {
2448       this.#setPosition();
2449       this.#container.hidden = false;
2450       this.#container.style.zIndex =
2451         parseInt(this.#container.style.zIndex) + 1000;
2452     } else if (this.#pinned) {
2453       this.#container.classList.add("focused");
2454     }
2455   }
2456 
2457   /**
2458    * Hide the popup.
2459    */
2460   #hide() {
2461     this.#container.classList.remove("focused");
2462     if (this.#pinned || !this.isVisible) {
2463       return;
2464     }
2465     this.#container.hidden = true;
2466     this.#container.style.zIndex =
2467       parseInt(this.#container.style.zIndex) - 1000;
2468   }
2469 
2470   forceHide() {
2471     this.#wasVisible = this.isVisible;
2472     if (!this.#wasVisible) {
2473       return;
2474     }
2475     this.#container.hidden = true;
2476   }
2477 
2478   maybeShow() {
2479     if (!this.#wasVisible) {
2480       return;
2481     }
2482     if (!this.#popup) {
2483       this.#show();
2484     }
2485     this.#wasVisible = false;
2486     this.#container.hidden = false;
2487   }
2488 
2489   get isVisible() {
2490     return this.#container.hidden === false;
2491   }
2492 }
2493 
2494 class FreeTextAnnotationElement extends AnnotationElement {
2495   constructor(parameters) {
2496     super(parameters, { isRenderable: true, ignoreBorder: true });
2497     this.textContent = parameters.data.textContent;
2498     this.textPosition = parameters.data.textPosition;
2499     this.annotationEditorType = AnnotationEditorType.FREETEXT;
2500   }
2501 
2502   render() {
2503     this.container.classList.add("freeTextAnnotation");
2504 
2505     if (this.textContent) {
2506       const content = document.createElement("div");
2507       content.classList.add("annotationTextContent");
2508       content.setAttribute("role", "comment");
2509       for (const line of this.textContent) {
2510         const lineSpan = document.createElement("span");
2511         lineSpan.textContent = line;
2512         content.append(lineSpan);
2513       }
2514       this.container.append(content);
2515     }
2516 
2517     if (!this.data.popupRef && this.hasPopupData) {
2518       this._createPopup();
2519     }
2520 
2521     this._editOnDoubleClick();
2522 
2523     return this.container;
2524   }
2525 }
2526 
2527 class LineAnnotationElement extends AnnotationElement {
2528   #line = null;
2529 
2530   constructor(parameters) {
2531     super(parameters, { isRenderable: true, ignoreBorder: true });
2532   }
2533 
2534   render() {
2535     this.container.classList.add("lineAnnotation");
2536 
2537     // Create an invisible line with the same starting and ending coordinates
2538     // that acts as the trigger for the popup. Only the line itself should
2539     // trigger the popup, not the entire container.
2540     const data = this.data;
2541     const { width, height } = getRectDims(data.rect);
2542     const svg = this.svgFactory.create(
2543       width,
2544       height,
2545       /* skipDimensions = */ true
2546     );
2547 
2548     // PDF coordinates are calculated from a bottom left origin, so transform
2549     // the line coordinates to a top left origin for the SVG element.
2550     const line = (this.#line = this.svgFactory.createElement("svg:line"));
2551     line.setAttribute("x1", data.rect[2] - data.lineCoordinates[0]);
2552     line.setAttribute("y1", data.rect[3] - data.lineCoordinates[1]);
2553     line.setAttribute("x2", data.rect[2] - data.lineCoordinates[2]);
2554     line.setAttribute("y2", data.rect[3] - data.lineCoordinates[3]);
2555     // Ensure that the 'stroke-width' is always non-zero, since otherwise it
2556     // won't be possible to open/close the popup (note e.g. issue 11122).
2557     line.setAttribute("stroke-width", data.borderStyle.width || 1);
2558     line.setAttribute("stroke", "transparent");
2559     line.setAttribute("fill", "transparent");
2560 
2561     svg.append(line);
2562     this.container.append(svg);
2563 
2564     // Create the popup ourselves so that we can bind it to the line instead
2565     // of to the entire container (which is the default).
2566     if (!data.popupRef && this.hasPopupData) {
2567       this._createPopup();
2568     }
2569 
2570     return this.container;
2571   }
2572 
2573   getElementsToTriggerPopup() {
2574     return this.#line;
2575   }
2576 
2577   addHighlightArea() {
2578     this.container.classList.add("highlightArea");
2579   }
2580 }
2581 
2582 class SquareAnnotationElement extends AnnotationElement {
2583   #square = null;
2584 
2585   constructor(parameters) {
2586     super(parameters, { isRenderable: true, ignoreBorder: true });
2587   }
2588 
2589   render() {
2590     this.container.classList.add("squareAnnotation");
2591 
2592     // Create an invisible square with the same rectangle that acts as the
2593     // trigger for the popup. Only the square itself should trigger the
2594     // popup, not the entire container.
2595     const data = this.data;
2596     const { width, height } = getRectDims(data.rect);
2597     const svg = this.svgFactory.create(
2598       width,
2599       height,
2600       /* skipDimensions = */ true
2601     );
2602 
2603     // The browser draws half of the borders inside the square and half of
2604     // the borders outside the square by default. This behavior cannot be
2605     // changed programmatically, so correct for that here.
2606     const borderWidth = data.borderStyle.width;
2607     const square = (this.#square = this.svgFactory.createElement("svg:rect"));
2608     square.setAttribute("x", borderWidth / 2);
2609     square.setAttribute("y", borderWidth / 2);
2610     square.setAttribute("width", width - borderWidth);
2611     square.setAttribute("height", height - borderWidth);
2612     // Ensure that the 'stroke-width' is always non-zero, since otherwise it
2613     // won't be possible to open/close the popup (note e.g. issue 11122).
2614     square.setAttribute("stroke-width", borderWidth || 1);
2615     square.setAttribute("stroke", "transparent");
2616     square.setAttribute("fill", "transparent");
2617 
2618     svg.append(square);
2619     this.container.append(svg);
2620 
2621     // Create the popup ourselves so that we can bind it to the square instead
2622     // of to the entire container (which is the default).
2623     if (!data.popupRef && this.hasPopupData) {
2624       this._createPopup();
2625     }
2626 
2627     return this.container;
2628   }
2629 
2630   getElementsToTriggerPopup() {
2631     return this.#square;
2632   }
2633 
2634   addHighlightArea() {
2635     this.container.classList.add("highlightArea");
2636   }
2637 }
2638 
2639 class CircleAnnotationElement extends AnnotationElement {
2640   #circle = null;
2641 
2642   constructor(parameters) {
2643     super(parameters, { isRenderable: true, ignoreBorder: true });
2644   }
2645 
2646   render() {
2647     this.container.classList.add("circleAnnotation");
2648 
2649     // Create an invisible circle with the same ellipse that acts as the
2650     // trigger for the popup. Only the circle itself should trigger the
2651     // popup, not the entire container.
2652     const data = this.data;
2653     const { width, height } = getRectDims(data.rect);
2654     const svg = this.svgFactory.create(
2655       width,
2656       height,
2657       /* skipDimensions = */ true
2658     );
2659 
2660     // The browser draws half of the borders inside the circle and half of
2661     // the borders outside the circle by default. This behavior cannot be
2662     // changed programmatically, so correct for that here.
2663     const borderWidth = data.borderStyle.width;
2664     const circle = (this.#circle =
2665       this.svgFactory.createElement("svg:ellipse"));
2666     circle.setAttribute("cx", width / 2);
2667     circle.setAttribute("cy", height / 2);
2668     circle.setAttribute("rx", width / 2 - borderWidth / 2);
2669     circle.setAttribute("ry", height / 2 - borderWidth / 2);
2670     // Ensure that the 'stroke-width' is always non-zero, since otherwise it
2671     // won't be possible to open/close the popup (note e.g. issue 11122).
2672     circle.setAttribute("stroke-width", borderWidth || 1);
2673     circle.setAttribute("stroke", "transparent");
2674     circle.setAttribute("fill", "transparent");
2675 
2676     svg.append(circle);
2677     this.container.append(svg);
2678 
2679     // Create the popup ourselves so that we can bind it to the circle instead
2680     // of to the entire container (which is the default).
2681     if (!data.popupRef && this.hasPopupData) {
2682       this._createPopup();
2683     }
2684 
2685     return this.container;
2686   }
2687 
2688   getElementsToTriggerPopup() {
2689     return this.#circle;
2690   }
2691 
2692   addHighlightArea() {
2693     this.container.classList.add("highlightArea");
2694   }
2695 }
2696 
2697 class PolylineAnnotationElement extends AnnotationElement {
2698   #polyline = null;
2699 
2700   constructor(parameters) {
2701     super(parameters, { isRenderable: true, ignoreBorder: true });
2702 
2703     this.containerClassName = "polylineAnnotation";
2704     this.svgElementName = "svg:polyline";
2705   }
2706 
2707   render() {
2708     this.container.classList.add(this.containerClassName);
2709 
2710     // Create an invisible polyline with the same points that acts as the
2711     // trigger for the popup. Only the polyline itself should trigger the
2712     // popup, not the entire container.
2713     const {
2714       data: { rect, vertices, borderStyle, popupRef },
2715     } = this;
2716     if (!vertices) {
2717       return this.container;
2718     }
2719     const { width, height } = getRectDims(rect);
2720     const svg = this.svgFactory.create(
2721       width,
2722       height,
2723       /* skipDimensions = */ true
2724     );
2725 
2726     // Convert the vertices array to a single points string that the SVG
2727     // polyline element expects ("x1,y1 x2,y2 ..."). PDF coordinates are
2728     // calculated from a bottom left origin, so transform the polyline
2729     // coordinates to a top left origin for the SVG element.
2730     let points = [];
2731     for (let i = 0, ii = vertices.length; i < ii; i += 2) {
2732       const x = vertices[i] - rect[0];
2733       const y = rect[3] - vertices[i + 1];
2734       points.push(`${x},${y}`);
2735     }
2736     points = points.join(" ");
2737 
2738     const polyline = (this.#polyline = this.svgFactory.createElement(
2739       this.svgElementName
2740     ));
2741     polyline.setAttribute("points", points);
2742     // Ensure that the 'stroke-width' is always non-zero, since otherwise it
2743     // won't be possible to open/close the popup (note e.g. issue 11122).
2744     polyline.setAttribute("stroke-width", borderStyle.width || 1);
2745     polyline.setAttribute("stroke", "transparent");
2746     polyline.setAttribute("fill", "transparent");
2747 
2748     svg.append(polyline);
2749     this.container.append(svg);
2750 
2751     // Create the popup ourselves so that we can bind it to the polyline
2752     // instead of to the entire container (which is the default).
2753     if (!popupRef && this.hasPopupData) {
2754       this._createPopup();
2755     }
2756 
2757     return this.container;
2758   }
2759 
2760   getElementsToTriggerPopup() {
2761     return this.#polyline;
2762   }
2763 
2764   addHighlightArea() {
2765     this.container.classList.add("highlightArea");
2766   }
2767 }
2768 
2769 class PolygonAnnotationElement extends PolylineAnnotationElement {
2770   constructor(parameters) {
2771     // Polygons are specific forms of polylines, so reuse their logic.
2772     super(parameters);
2773 
2774     this.containerClassName = "polygonAnnotation";
2775     this.svgElementName = "svg:polygon";
2776   }
2777 }
2778 
2779 class CaretAnnotationElement extends AnnotationElement {
2780   constructor(parameters) {
2781     super(parameters, { isRenderable: true, ignoreBorder: true });
2782   }
2783 
2784   render() {
2785     this.container.classList.add("caretAnnotation");
2786 
2787     if (!this.data.popupRef && this.hasPopupData) {
2788       this._createPopup();
2789     }
2790     return this.container;
2791   }
2792 }
2793 
2794 class InkAnnotationElement extends AnnotationElement {
2795   #polylinesGroupElement = null;
2796 
2797   #polylines = [];
2798 
2799   constructor(parameters) {
2800     super(parameters, { isRenderable: true, ignoreBorder: true });
2801 
2802     this.containerClassName = "inkAnnotation";
2803 
2804     // Use the polyline SVG element since it allows us to use coordinates
2805     // directly and to draw both straight lines and curves.
2806     this.svgElementName = "svg:polyline";
2807 
2808     this.annotationEditorType =
2809       this.data.it === "InkHighlight"
2810         ? AnnotationEditorType.HIGHLIGHT
2811         : AnnotationEditorType.INK;
2812   }
2813 
2814   #getTransform(rotation, rect) {
2815     // PDF coordinates are calculated from a bottom left origin, so
2816     // transform the polyline coordinates to a top left origin for the
2817     // SVG element.
2818     switch (rotation) {
2819       case 90:
2820         return {
2821           transform: `rotate(90) translate(${-rect[0]},${rect[1]}) scale(1,-1)`,
2822           width: rect[3] - rect[1],
2823           height: rect[2] - rect[0],
2824         };
2825       case 180:
2826         return {
2827           transform: `rotate(180) translate(${-rect[2]},${rect[1]}) scale(1,-1)`,
2828           width: rect[2] - rect[0],
2829           height: rect[3] - rect[1],
2830         };
2831       case 270:
2832         return {
2833           transform: `rotate(270) translate(${-rect[2]},${rect[3]}) scale(1,-1)`,
2834           width: rect[3] - rect[1],
2835           height: rect[2] - rect[0],
2836         };
2837       default:
2838         return {
2839           transform: `translate(${-rect[0]},${rect[3]}) scale(1,-1)`,
2840           width: rect[2] - rect[0],
2841           height: rect[3] - rect[1],
2842         };
2843     }
2844   }
2845 
2846   render() {
2847     this.container.classList.add(this.containerClassName);
2848 
2849     // Create an invisible polyline with the same points that acts as the
2850     // trigger for the popup.
2851     const {
2852       data: { rect, rotation, inkLists, borderStyle, popupRef },
2853     } = this;
2854     const { transform, width, height } = this.#getTransform(rotation, rect);
2855 
2856     const svg = this.svgFactory.create(
2857       width,
2858       height,
2859       /* skipDimensions = */ true
2860     );
2861     const g = (this.#polylinesGroupElement =
2862       this.svgFactory.createElement("svg:g"));
2863     svg.append(g);
2864     // Ensure that the 'stroke-width' is always non-zero, since otherwise it
2865     // won't be possible to open/close the popup (note e.g. issue 11122).
2866     g.setAttribute("stroke-width", borderStyle.width || 1);
2867     g.setAttribute("stroke-linecap", "round");
2868     g.setAttribute("stroke-linejoin", "round");
2869     g.setAttribute("stroke-miterlimit", 10);
2870     g.setAttribute("stroke", "transparent");
2871     g.setAttribute("fill", "transparent");
2872     g.setAttribute("transform", transform);
2873 
2874     for (let i = 0, ii = inkLists.length; i < ii; i++) {
2875       const polyline = this.svgFactory.createElement(this.svgElementName);
2876       this.#polylines.push(polyline);
2877       polyline.setAttribute("points", inkLists[i].join(","));
2878       g.append(polyline);
2879     }
2880 
2881     if (!popupRef && this.hasPopupData) {
2882       this._createPopup();
2883     }
2884 
2885     this.container.append(svg);
2886     this._editOnDoubleClick();
2887 
2888     return this.container;
2889   }
2890 
2891   updateEdited(params) {
2892     super.updateEdited(params);
2893     const { thickness, points, rect } = params;
2894     const g = this.#polylinesGroupElement;
2895     if (thickness >= 0) {
2896       g.setAttribute("stroke-width", thickness || 1);
2897     }
2898     if (points) {
2899       for (let i = 0, ii = this.#polylines.length; i < ii; i++) {
2900         this.#polylines[i].setAttribute("points", points[i].join(","));
2901       }
2902     }
2903     if (rect) {
2904       const { transform, width, height } = this.#getTransform(
2905         this.data.rotation,
2906         rect
2907       );
2908       const root = g.parentElement;
2909       root.setAttribute("viewBox", `0 0 ${width} ${height}`);
2910       g.setAttribute("transform", transform);
2911     }
2912   }
2913 
2914   getElementsToTriggerPopup() {
2915     return this.#polylines;
2916   }
2917 
2918   addHighlightArea() {
2919     this.container.classList.add("highlightArea");
2920   }
2921 }
2922 
2923 class HighlightAnnotationElement extends AnnotationElement {
2924   constructor(parameters) {
2925     super(parameters, {
2926       isRenderable: true,
2927       ignoreBorder: true,
2928       createQuadrilaterals: true,
2929     });
2930     this.annotationEditorType = AnnotationEditorType.HIGHLIGHT;
2931   }
2932 
2933   render() {
2934     if (!this.data.popupRef && this.hasPopupData) {
2935       this._createPopup();
2936     }
2937 
2938     this.container.classList.add("highlightAnnotation");
2939     this._editOnDoubleClick();
2940 
2941     return this.container;
2942   }
2943 }
2944 
2945 class UnderlineAnnotationElement extends AnnotationElement {
2946   constructor(parameters) {
2947     super(parameters, {
2948       isRenderable: true,
2949       ignoreBorder: true,
2950       createQuadrilaterals: true,
2951     });
2952   }
2953 
2954   render() {
2955     if (!this.data.popupRef && this.hasPopupData) {
2956       this._createPopup();
2957     }
2958 
2959     this.container.classList.add("underlineAnnotation");
2960     return this.container;
2961   }
2962 }
2963 
2964 class SquigglyAnnotationElement extends AnnotationElement {
2965   constructor(parameters) {
2966     super(parameters, {
2967       isRenderable: true,
2968       ignoreBorder: true,
2969       createQuadrilaterals: true,
2970     });
2971   }
2972 
2973   render() {
2974     if (!this.data.popupRef && this.hasPopupData) {
2975       this._createPopup();
2976     }
2977 
2978     this.container.classList.add("squigglyAnnotation");
2979     return this.container;
2980   }
2981 }
2982 
2983 class StrikeOutAnnotationElement extends AnnotationElement {
2984   constructor(parameters) {
2985     super(parameters, {
2986       isRenderable: true,
2987       ignoreBorder: true,
2988       createQuadrilaterals: true,
2989     });
2990   }
2991 
2992   render() {
2993     if (!this.data.popupRef && this.hasPopupData) {
2994       this._createPopup();
2995     }
2996 
2997     this.container.classList.add("strikeoutAnnotation");
2998     return this.container;
2999   }
3000 }
3001 
3002 class StampAnnotationElement extends AnnotationElement {
3003   constructor(parameters) {
3004     super(parameters, { isRenderable: true, ignoreBorder: true });
3005     this.annotationEditorType = AnnotationEditorType.STAMP;
3006   }
3007 
3008   render() {
3009     this.container.classList.add("stampAnnotation");
3010     this.container.setAttribute("role", "img");
3011 
3012     if (!this.data.popupRef && this.hasPopupData) {
3013       this._createPopup();
3014     }
3015     this._editOnDoubleClick();
3016 
3017     return this.container;
3018   }
3019 }
3020 
3021 class FileAttachmentAnnotationElement extends AnnotationElement {
3022   #trigger = null;
3023 
3024   constructor(parameters) {
3025     super(parameters, { isRenderable: true });
3026 
3027     const { file } = this.data;
3028     this.filename = file.filename;
3029     this.content = file.content;
3030 
3031     this.linkService.eventBus?.dispatch("fileattachmentannotation", {
3032       source: this,
3033       ...file,
3034     });
3035   }
3036 
3037   render() {
3038     this.container.classList.add("fileAttachmentAnnotation");
3039 
3040     const { container, data } = this;
3041     let trigger;
3042     if (data.hasAppearance || data.fillAlpha === 0) {
3043       trigger = document.createElement("div");
3044     } else {
3045       // Unfortunately it seems that it's not clearly specified exactly what
3046       // names are actually valid, since Table 184 contains:
3047       //   Conforming readers shall provide predefined icon appearances for at
3048       //   least the following standard names: GraphPushPin, PaperclipTag.
3049       //   Additional names may be supported as well. Default value: PushPin.
3050       trigger = document.createElement("img");
3051       trigger.src = `${this.imageResourcesPath}annotation-${
3052         /paperclip/i.test(data.name) ? "paperclip" : "pushpin"
3053       }.svg`;
3054 
3055       if (data.fillAlpha && data.fillAlpha < 1) {
3056         trigger.style = `filter: opacity(${Math.round(
3057           data.fillAlpha * 100
3058         )}%);`;
3059 
3060         if (typeof PDFJSDev !== "undefined" && PDFJSDev.test("TESTING")) {
3061           this.container.classList.add("hasFillAlpha");
3062         }
3063       }
3064     }
3065     trigger.addEventListener("dblclick", this.#download.bind(this));
3066     this.#trigger = trigger;
3067 
3068     const { isMac } = FeatureTest.platform;
3069     container.addEventListener("keydown", evt => {
3070       if (evt.key === "Enter" && (isMac ? evt.metaKey : evt.ctrlKey)) {
3071         this.#download();
3072       }
3073     });
3074 
3075     if (!data.popupRef && this.hasPopupData) {
3076       this._createPopup();
3077     } else {
3078       trigger.classList.add("popupTriggerArea");
3079     }
3080 
3081     container.append(trigger);
3082     return container;
3083   }
3084 
3085   getElementsToTriggerPopup() {
3086     return this.#trigger;
3087   }
3088 
3089   addHighlightArea() {
3090     this.container.classList.add("highlightArea");
3091   }
3092 
3093   /**
3094    * Download the file attachment associated with this annotation.
3095    */
3096   #download() {
3097     this.downloadManager?.openOrDownloadData(this.content, this.filename);
3098   }
3099 }
3100 
3101 /**
3102  * @typedef {Object} AnnotationLayerParameters
3103  * @property {PageViewport} viewport
3104  * @property {HTMLDivElement} div
3105  * @property {Array} annotations
3106  * @property {PDFPageProxy} page
3107  * @property {IPDFLinkService} linkService
3108  * @property {IDownloadManager} [downloadManager]
3109  * @property {AnnotationStorage} [annotationStorage]
3110  * @property {string} [imageResourcesPath] - Path for image resources, mainly
3111  *   for annotation icons. Include trailing slash.
3112  * @property {boolean} renderForms
3113  * @property {boolean} [enableScripting] - Enable embedded script execution.
3114  * @property {boolean} [hasJSActions] - Some fields have JS actions.
3115  *   The default value is `false`.
3116  * @property {Object<string, Array<Object>> | null} [fieldObjects]
3117  * @property {Map<string, HTMLCanvasElement>} [annotationCanvasMap]
3118  * @property {TextAccessibilityManager} [accessibilityManager]
3119  * @property {AnnotationEditorUIManager} [annotationEditorUIManager]
3120  * @property {StructTreeLayerBuilder} [structTreeLayer]
3121  */
3122 
3123 /**
3124  * Manage the layer containing all the annotations.
3125  */
3126 class AnnotationLayer {
3127   #accessibilityManager = null;
3128 
3129   #annotationCanvasMap = null;
3130 
3131   #editableAnnotations = new Map();
3132 
3133   #structTreeLayer = null;
3134 
3135   constructor({
3136     div,
3137     accessibilityManager,
3138     annotationCanvasMap,
3139     annotationEditorUIManager,
3140     page,
3141     viewport,
3142     structTreeLayer,
3143   }) {
3144     this.div = div;
3145     this.#accessibilityManager = accessibilityManager;
3146     this.#annotationCanvasMap = annotationCanvasMap;
3147     this.#structTreeLayer = structTreeLayer || null;
3148     this.page = page;
3149     this.viewport = viewport;
3150     this.zIndex = 0;
3151     this._annotationEditorUIManager = annotationEditorUIManager;
3152 
3153     if (typeof PDFJSDev !== "undefined" && PDFJSDev.test("TESTING")) {
3154       // For testing purposes.
3155       Object.defineProperty(this, "showPopups", {
3156         value: async () => {
3157           for (const show of this.popupShow) {
3158             await show();
3159           }
3160         },
3161       });
3162       this.popupShow = [];
3163     }
3164   }
3165 
3166   hasEditableAnnotations() {
3167     return this.#editableAnnotations.size > 0;
3168   }
3169 
3170   async #appendElement(element, id) {
3171     const contentElement = element.firstChild || element;
3172     const annotationId = (contentElement.id = `${AnnotationPrefix}${id}`);
3173     const ariaAttributes =
3174       await this.#structTreeLayer?.getAriaAttributes(annotationId);
3175     if (ariaAttributes) {
3176       for (const [key, value] of ariaAttributes) {
3177         contentElement.setAttribute(key, value);
3178       }
3179     }
3180 
3181     this.div.append(element);
3182     this.#accessibilityManager?.moveElementInDOM(
3183       this.div,
3184       element,
3185       contentElement,
3186       /* isRemovable = */ false
3187     );
3188   }
3189 
3190   /**
3191    * Render a new annotation layer with all annotation elements.
3192    *
3193    * @param {AnnotationLayerParameters} params
3194    * @memberof AnnotationLayer
3195    */
3196   async render(params) {
3197     const { annotations } = params;
3198     const layer = this.div;
3199     setLayerDimensions(layer, this.viewport);
3200 
3201     const popupToElements = new Map();
3202     const elementParams = {
3203       data: null,
3204       layer,
3205       linkService: params.linkService,
3206       downloadManager: params.downloadManager,
3207       imageResourcesPath: params.imageResourcesPath || "",
3208       renderForms: params.renderForms !== false,
3209       svgFactory: new DOMSVGFactory(),
3210       annotationStorage: params.annotationStorage || new AnnotationStorage(),
3211       enableScripting: params.enableScripting === true,
3212       hasJSActions: params.hasJSActions,
3213       fieldObjects: params.fieldObjects,
3214       parent: this,
3215       elements: null,
3216     };
3217 
3218     for (const data of annotations) {
3219       if (data.noHTML) {
3220         continue;
3221       }
3222       const isPopupAnnotation = data.annotationType === AnnotationType.POPUP;
3223       if (!isPopupAnnotation) {
3224         const { width, height } = getRectDims(data.rect);
3225         if (width <= 0 || height <= 0) {
3226           continue; // Ignore empty annotations.
3227         }
3228       } else {
3229         const elements = popupToElements.get(data.id);
3230         if (!elements) {
3231           // Ignore popup annotations without a corresponding annotation.
3232           continue;
3233         }
3234         elementParams.elements = elements;
3235       }
3236       elementParams.data = data;
3237       const element = AnnotationElementFactory.create(elementParams);
3238 
3239       if (!element.isRenderable) {
3240         continue;
3241       }
3242 
3243       if (!isPopupAnnotation && data.popupRef) {
3244         const elements = popupToElements.get(data.popupRef);
3245         if (!elements) {
3246           popupToElements.set(data.popupRef, [element]);
3247         } else {
3248           elements.push(element);
3249         }
3250       }
3251 
3252       const rendered = element.render();
3253       if (data.hidden) {
3254         rendered.style.visibility = "hidden";
3255       }
3256       await this.#appendElement(rendered, data.id);
3257 
3258       if (element._isEditable) {
3259         this.#editableAnnotations.set(element.data.id, element);
3260         this._annotationEditorUIManager?.renderAnnotationElement(element);
3261       }
3262     }
3263 
3264     this.#setAnnotationCanvasMap();
3265   }
3266 
3267   /**
3268    * Update the annotation elements on existing annotation layer.
3269    *
3270    * @param {AnnotationLayerParameters} viewport
3271    * @memberof AnnotationLayer
3272    */
3273   update({ viewport }) {
3274     const layer = this.div;
3275     this.viewport = viewport;
3276     setLayerDimensions(layer, { rotation: viewport.rotation });
3277 
3278     this.#setAnnotationCanvasMap();
3279     layer.hidden = false;
3280   }
3281 
3282   #setAnnotationCanvasMap() {
3283     if (!this.#annotationCanvasMap) {
3284       return;
3285     }
3286     const layer = this.div;
3287     for (const [id, canvas] of this.#annotationCanvasMap) {
3288       const element = layer.querySelector(`[data-annotation-id="${id}"]`);
3289       if (!element) {
3290         continue;
3291       }
3292 
3293       canvas.className = "annotationContent";
3294       const { firstChild } = element;
3295       if (!firstChild) {
3296         element.append(canvas);
3297       } else if (firstChild.nodeName === "CANVAS") {
3298         firstChild.replaceWith(canvas);
3299       } else if (!firstChild.classList.contains("annotationContent")) {
3300         firstChild.before(canvas);
3301       } else {
3302         firstChild.after(canvas);
3303       }
3304 
3305       const editableAnnotation = this.#editableAnnotations.get(id);
3306       if (!editableAnnotation) {
3307         continue;
3308       }
3309       if (editableAnnotation._hasNoCanvas) {
3310         // The canvas wasn't available when the annotation was created.
3311         this._annotationEditorUIManager?.setMissingCanvas(
3312           id,
3313           element.id,
3314           canvas
3315         );
3316         editableAnnotation._hasNoCanvas = false;
3317       } else {
3318         editableAnnotation.canvas = canvas;
3319       }
3320     }
3321     this.#annotationCanvasMap.clear();
3322   }
3323 
3324   getEditableAnnotations() {
3325     return Array.from(this.#editableAnnotations.values());
3326   }
3327 
3328   getEditableAnnotation(id) {
3329     return this.#editableAnnotations.get(id);
3330   }
3331 }
3332 
3333 export {
3334   AnnotationLayer,
3335   FreeTextAnnotationElement,
3336   HighlightAnnotationElement,
3337   InkAnnotationElement,
3338   StampAnnotationElement,
3339 };
</code>

Test file:
<test_file>
File:
test/unit/annotation_spec.js
/* Copyright 2017 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import {
  Annotation,
  AnnotationBorderStyle,
  AnnotationFactory,
  getQuadPoints,
  MarkupAnnotation,
} from "../../src/core/annotation.js";
import {
  AnnotationBorderStyleType,
  AnnotationEditorType,
  AnnotationFieldFlag,
  AnnotationFlag,
  AnnotationType,
  OPS,
  RenderingIntentFlag,
  stringToBytes,
  stringToUTF8String,
} from "../../src/shared/util.js";
import {
  CMAP_URL,
  createIdFactory,
  DefaultCMapReaderFactory,
  DefaultStandardFontDataFactory,
  STANDARD_FONT_DATA_URL,
  XRefMock,
} from "./test_utils.js";
import { Dict, Name, Ref, RefSetCache } from "../../src/core/primitives.js";
import { Lexer, Parser } from "../../src/core/parser.js";
import { FlateStream } from "../../src/core/flate_stream.js";
import { PartialEvaluator } from "../../src/core/evaluator.js";
import { StringStream } from "../../src/core/stream.js";
import { WorkerTask } from "../../src/core/worker.js";
import { writeChanges } from "../../src/core/writer.js";
</test_file>

Your task:
You are a software tester at pdf.js.
1. Examine the existing test file. You may reuse any imports, helpers or setup blocks it already has.
2. Write exactly one javascript test `it("...", async () => {...})` block.
3. Your test must fail on the code before the patch, and pass after, hence the test will verify that the patch resolves the issue.
4. The test must be self-contained and to-the-point.
5. If you need something new use only the provided imports (respect the paths exactly how they are given) by importing dynamically for compatibility with Node.js — no new dependencies. 
6. Return only the javascript code for the new `it(...)` block (no comments or explanations).

Example structure:
it("should <describe behavior>", async () => {
  const { example } = await import("../../src/core/example.js");
  <initialize required variables>;
  <define expected variable>;
  <generate actual variables>;
  <compare expected with actual>;
});

