Before you begin:
- Keep going until the job is completely solved — don’t stop halfway.
- If you’re unsure about the behavior, reread the provided patch carefully; do not hallucinate.
- Plan your approach before writing code by reflecting on whether the test truly fails before and passes after.

Issue:
<issue>
PDF rendering regression due to smask changes
</issue>

Patch:
<patch>
diff --git a/src/display/canvas.js b/src/display/canvas.js
--- a/src/display/canvas.js
+++ b/src/display/canvas.js
@@ -1323,8 +1323,7 @@ class CanvasGraphics {
           this.current.strokeAlpha = value;
           break;
         case "ca":
-          this.current.fillAlpha = value;
-          this.ctx.globalAlpha = value;
+          this.ctx.globalAlpha = this.current.fillAlpha = value;
           break;
         case "BM":
           this.ctx.globalCompositeOperation = value;
@@ -1378,17 +1377,12 @@ class CanvasGraphics {
       drawnHeight
     );
     this.suspendedCtx = this.ctx;
-    this.ctx = scratchCanvas.context;
-    const ctx = this.ctx;
+    const ctx = (this.ctx = scratchCanvas.context);
     ctx.setTransform(this.suspendedCtx.getTransform());
     copyCtxState(this.suspendedCtx, ctx);
     mirrorContextOperations(ctx, this.suspendedCtx);
 
-    this.setGState([
-      ["BM", "source-over"],
-      ["ca", 1],
-      ["CA", 1],
-    ]);
+    this.setGState([["BM", "source-over"]]);
   }
 
   endSMaskMode() {


</patch>

Imports:
<imports>
Available Packages
Dev Dependencies:
- @babel/core: ^7.26.10
- @babel/preset-env: ^7.26.9
- @babel/runtime: ^7.26.10
- @fluent/bundle: ^0.18.0
- @fluent/dom: ^0.10.0
- @metalsmith/layouts: ^3.0.0
- @metalsmith/markdown: ^1.10.0
- @napi-rs/canvas: ^0.1.68
- @types/node: ^22.13.11
- autoprefixer: ^10.4.21
- babel-loader: ^10.0.0
- caniuse-lite: ^1.0.30001706
- core-js: ^3.41.0
- eslint: ^9.23.0
- eslint-plugin-import: ^2.31.0
- eslint-plugin-jasmine: ^4.2.2
- eslint-plugin-json: ^4.0.1
- eslint-plugin-no-unsanitized: ^4.1.2
- eslint-plugin-perfectionist: ^4.10.1
- eslint-plugin-prettier: ^5.2.3
- eslint-plugin-unicorn: ^57.0.0
- globals: ^16.0.0
- gulp: ^5.0.0
- gulp-cli: ^3.0.0
- gulp-postcss: ^10.0.0
- gulp-rename: ^2.0.0
- gulp-replace: ^1.1.4
- gulp-zip: ^6.1.0
- highlight.js: ^11.11.1
- jasmine: ^5.6.0
- jsdoc: ^4.0.4
- jstransformer-nunjucks: ^1.2.0
- metalsmith: ^2.6.3
- metalsmith-html-relative: ^2.0.6
- ordered-read-streams: ^2.0.0
- pngjs: ^7.0.0
- postcss: ^8.5.3
- postcss-dark-theme-class: ^1.3.0
- postcss-dir-pseudo-class: ^9.0.1
- postcss-discard-comments: ^7.0.3
- postcss-nesting: ^13.0.1
- prettier: ^3.5.3
- puppeteer: ^24.4.0
- stylelint: ^16.16.0
- stylelint-prettier: ^5.0.3
- svglint: ^3.1.0
- terser-webpack-plugin: ^5.3.14
- tsc-alias: ^1.8.11
- ttest: ^4.0.0
- typescript: ^5.8.2
- vinyl: ^3.0.0
- webpack: ^5.98.0
- webpack-stream: ^7.0.0
- yargs: ^17.7.2

Engines:
- node: >=20

Available Relative Imports:
- `../../src/core/annotation.js`: Annotation, AnnotationBorderStyle, AnnotationFactory, MarkupAnnotation, getQuadPoints
- `../../src/core/bidi.js`: bidi
- `../../src/core/calculate_md5.js`: calculateMD5
- `../../src/core/calculate_sha256.js`: calculateSHA256
- `../../src/core/calculate_sha_other.js`: calculateSHA384, calculateSHA512
- `../../src/core/cff_parser.js`: CFFCharset, CFFCompiler, CFFFDSelect, CFFParser, CFFStrings
- `../../src/core/cmap.js`: CMap, CMapFactory, IdentityCMap
- `../../src/core/colorspace.js`: ColorSpace
- `../../src/core/colorspace_utils.js`: ColorSpaceUtils
- `../../src/core/core_utils.js`: arrayBuffersToBytes, encodeToXmlString, escapePDFName, escapeString, getInheritableProperty, getSizeInBytes, isAscii, isWhiteSpace, log2, numberToString, parseXFAPath, recoverJsURL, stringToUTF16HexString, stringToUTF16String, toRomanNumerals, validateCSSFont
- `../../src/core/crypto.js`: AES128Cipher, AES256Cipher, ARCFourCipher, CipherTransformFactory, PDF17, PDF20
- `../../src/core/default_appearance.js`: createDefaultAppearance, parseAppearanceStream, parseDefaultAppearance
- `../../src/core/document.js`: PDFDocument, Page
- `../../src/core/encodings.js`: getEncoding
- `../../src/core/evaluator.js`: PartialEvaluator
- `../../src/core/flate_stream.js`: FlateStream
- `../../src/core/font_substitutions.js`: getFontSubstitution
- `../../src/core/fonts_utils.js`: SEAC_ANALYSIS_ENABLED
- `../../src/core/function.js`: PDFFunctionFactory, PostScriptCompiler, PostScriptEvaluator
- `../../src/core/glyphlist.js`: getDingbatsGlyphsUnicode, getGlyphsUnicode
- `../../src/core/image_utils.js`: GlobalColorSpaceCache, GlobalImageCache, LocalColorSpaceCache
- `../../src/core/jbig2.js`: Jbig2Error, Jbig2Image
- `../../src/core/jpg.js`: JpegError, JpegImage
- `../../src/core/jpx.js`: JpxError, JpxImage
- `../../src/core/metadata_parser.js`: MetadataParser
- `../../src/core/operator_list.js`: OperatorList
- `../../src/core/parser.js`: Lexer, Linearization, Parser
- `../../src/core/predictor_stream.js`: PredictorStream
- `../../src/core/primitives.js`: Cmd, Dict, EOF, Name, Ref, RefSet, RefSetCache, isCmd, isDict, isName, isRefsEqual
- `../../src/core/ps_parser.js`: PostScriptLexer, PostScriptParser
- `../../src/core/stream.js`: NullStream, Stream, StringStream
- `../../src/core/type1_parser.js`: Type1Parser
- `../../src/core/unicode.js`: getCharUnicodeCategory, getUnicodeForGlyph, getUnicodeRangeFor, mapSpecialUnicodeValues
- `../../src/core/worker.js`: WorkerMessageHandler, WorkerTask
- `../../src/core/writer.js`: incrementalUpdate, writeChanges, writeDict
- `../../src/core/xfa/bind.js`: Binder
- `../../src/core/xfa/data.js`: DataHandler
- `../../src/core/xfa/factory.js`: XFAFactory
- `../../src/core/xfa/formcalc_lexer.js`: Lexer, TOKEN, Token
- `../../src/core/xfa/formcalc_parser.js`: Errors, Parser
- `../../src/core/xfa/parser.js`: XFAParser
- `../../src/core/xfa/som.js`: searchNode
- `../../src/core/xfa/symbol_utils.js`: $dump, $getChildren, $getChildrenByClass, $getChildrenByName, $text, $uid
- `../../src/core/xml_parser.js`: SimpleXMLParser, XMLParserBase
- `../../src/display/annotation_layer.js`: AnnotationLayer
- `../../src/display/annotation_storage.js`: AnnotationStorage
- `../../src/display/api.js`: LoopbackPort, PDFDataRangeTransport, PDFDocumentLoadingTask, PDFDocumentProxy, PDFPageProxy, PDFWorker, RenderTask, build, getDocument, isValidExplicitDest, version
- `../../src/display/canvas_factory.js`: DOMCanvasFactory
- `../../src/display/cmap_reader_factory.js`: DOMCMapReaderFactory
- `../../src/display/display_utils.js`: OutputScale, PDFDateString, PageViewport, PixelsPerInch, RenderingCancelledException, StatTimer, SupportedImageMimeTypes, fetchData, getFilenameFromUrl, getPdfFilenameFromUrl, getXfaPageViewport, isDataScheme, isPdfFile, isValidFetchUrl, noContextMenu, setLayerDimensions, stopEvent
- `../../src/display/draw_layer.js`: DrawLayer
- `../../src/display/editor/annotation_editor_layer.js`: AnnotationEditorLayer
- `../../src/display/editor/color_picker.js`: ColorPicker
- `../../src/display/editor/drawers/signaturedraw.js`: SignatureExtractor
- `../../src/display/editor/tools.js`: AnnotationEditorUIManager, CommandManager
- `../../src/display/fetch_stream.js`: PDFFetchStream
- `../../src/display/metadata.js`: Metadata
- `../../src/display/network.js`: PDFNetworkStream
- `../../src/display/network_utils.js`: createHeaders, createResponseError, extractFilenameFromHeader, validateRangeRequestCapabilities, validateResponseStatus
- `../../src/display/node_stream.js`: PDFNodeStream
- `../../src/display/node_utils.js`: NodeCMapReaderFactory, NodeStandardFontDataFactory, fetchData
- `../../src/display/standard_fontdata_factory.js`: DOMStandardFontDataFactory
- `../../src/display/svg_factory.js`: DOMSVGFactory
- `../../src/display/text_layer.js`: TextLayer
- `../../src/display/touch_manager.js`: TouchManager
- `../../src/display/worker_options.js`: GlobalWorkerOptions
- `../../src/display/xfa_layer.js`: XfaLayer
- `../../src/shared/message_handler.js`: MessageHandler
- `../../src/shared/murmurhash3.js`: MurmurHash3_64
- `../../src/shared/util.js`: AbortException, AnnotationBorderStyleType, AnnotationEditorParamsType, AnnotationEditorType, AnnotationFieldFlag, AnnotationFlag, AnnotationMode, AnnotationType, BaseException, DrawOPS, FeatureTest, FormatError, ImageKind, InvalidPDFException, MathClamp, OPS, PasswordException, PasswordResponses, PermissionFlag, RenderingIntentFlag, ResponseException, UnknownErrorException, Util, VerbosityLevel, assert, bytesToString, createValidAbsoluteUrl, getModificationDate, getUuid, getVerbosityLevel, isNodeJS, normalizeUnicode, objectSize, setVerbosityLevel, shadow, string32, stringToBytes, stringToPDFString, stringToUTF8String, toBase64Util
- `../../web/annotation_layer_builder.js`: AnnotationLayerBuilder
- `../../web/app_options.js`: AppOptions, OptionKind
- `../../web/autolinker.js`: Autolinker
- `../../web/download_manager.js`: DownloadManager
- `../../web/event_utils.js`: EventBus, WaitOnType, waitOnEventOrTimeout
- `../../web/genericl10n.js`: GenericL10n
- `../../web/pdf_find_controller.js`: FindState, PDFFindController
- `../../web/pdf_find_utils.js`: CharacterType, getCharacterType
- `../../web/pdf_history.js`: PDFHistory, isDestArraysEqual, isDestHashesEqual
- `../../web/pdf_link_service.js`: LinkTarget, PDFLinkService, SimpleLinkService
- `../../web/pdf_page_view.js`: PDFPageView
- `../../web/pdf_scripting_manager.component.js`: PDFScriptingManager
- `../../web/pdf_single_page_viewer.js`: PDFSinglePageViewer
- `../../web/pdf_viewer.js`: PDFPageViewBuffer, PDFViewer
- `../../web/struct_tree_layer_builder.js`: StructTreeLayerBuilder
- `../../web/text_layer_builder.js`: TextLayerBuilder
- `../../web/ui_utils.js`: AutoPrintRegExp, ProgressBar, RenderingStates, ScrollMode, SpreadMode, backtrackBeforeAllVisibleElements, binarySearchFirstItem, calcRound, getPageSizeInches, getVisibleElements, isPortraitOrientation, isValidRotation, parseQueryString, removeNullCharacters
- `../../web/xfa_layer_builder.js`: XfaLayerBuilder
- `../reporter.js`: TestReporter
- `./common_pdfstream_tests.js`: testCrossOriginRedirects
- `./test_utils.js`: CMAP_URL, DefaultCMapReaderFactory, DefaultFileReaderFactory, DefaultStandardFontDataFactory, STANDARD_FONT_DATA_URL, TEST_PDFS_PATH, TestPdfsServer, XRefMock, buildGetDocumentParams, createIdFactory, getCrossOriginHostname
</imports>

Code:
<code>
File:
src/display/canvas.js
1 /* Copyright 2012 Mozilla Foundation
2  *
3  * Licensed under the Apache License, Version 2.0 (the "License");
4  * you may not use this file except in compliance with the License.
5  * You may obtain a copy of the License at
6  *
7  *     http://www.apache.org/licenses/LICENSE-2.0
8  *
9  * Unless required by applicable law or agreed to in writing, software
10  * distributed under the License is distributed on an "AS IS" BASIS,
11  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
12  * See the License for the specific language governing permissions and
13  * limitations under the License.
14  */
15 
16 import {
17   DrawOPS,
18   FeatureTest,
19   FONT_IDENTITY_MATRIX,
20   IDENTITY_MATRIX,
21   ImageKind,
22   info,
23   isNodeJS,
24   OPS,
25   shadow,
26   TextRenderingMode,
27   unreachable,
28   Util,
29   warn,
30 } from "../shared/util.js";
31 import {
32   getCurrentTransform,
33   getCurrentTransformInverse,
34   OutputScale,
35   PixelsPerInch,
36 } from "./display_utils.js";
37 import {
38   getShadingPattern,
39   PathType,
40   TilingPattern,
41 } from "./pattern_helper.js";
42 import { convertBlackAndWhiteToRGBA } from "../shared/image_utils.js";
43 
44 // <canvas> contexts store most of the state we need natively.
45 // However, PDF needs a bit more state, which we store here.
46 // Minimal font size that would be used during canvas fillText operations.
47 const MIN_FONT_SIZE = 16;
48 // Maximum font size that would be used during canvas fillText operations.
49 const MAX_FONT_SIZE = 100;
50 
51 // Defines the time the `executeOperatorList`-method is going to be executing
52 // before it stops and schedules a continue of execution.
53 const EXECUTION_TIME = 15; // ms
54 // Defines the number of steps before checking the execution time.
55 const EXECUTION_STEPS = 10;
56 
57 // To disable Type3 compilation, set the value to `-1`.
58 const MAX_SIZE_TO_COMPILE = 1000;
59 
60 const FULL_CHUNK_HEIGHT = 16;
61 
62 // Only used in rescaleAndStroke. The goal is to avoid
63 // creating a new DOMMatrix object each time we need it.
64 const SCALE_MATRIX = new DOMMatrix();
65 
66 /**
67  * Overrides certain methods on a 2d ctx so that when they are called they
68  * will also call the same method on the destCtx. The methods that are
69  * overridden are all the transformation state modifiers, path creation, and
70  * save/restore. We only forward these specific methods because they are the
71  * only state modifiers that we cannot copy over when we switch contexts.
72  *
73  * To remove mirroring call `ctx._removeMirroring()`.
74  *
75  * @param {Object} ctx - The 2d canvas context that will duplicate its calls on
76  *   the destCtx.
77  * @param {Object} destCtx - The 2d canvas context that will receive the
78  *   forwarded calls.
79  */
80 function mirrorContextOperations(ctx, destCtx) {
81   if (ctx._removeMirroring) {
82     throw new Error("Context is already forwarding operations.");
83   }
84   ctx.__originalSave = ctx.save;
85   ctx.__originalRestore = ctx.restore;
86   ctx.__originalRotate = ctx.rotate;
87   ctx.__originalScale = ctx.scale;
88   ctx.__originalTranslate = ctx.translate;
89   ctx.__originalTransform = ctx.transform;
90   ctx.__originalSetTransform = ctx.setTransform;
91   ctx.__originalResetTransform = ctx.resetTransform;
92   ctx.__originalClip = ctx.clip;
93   ctx.__originalMoveTo = ctx.moveTo;
94   ctx.__originalLineTo = ctx.lineTo;
95   ctx.__originalBezierCurveTo = ctx.bezierCurveTo;
96   ctx.__originalRect = ctx.rect;
97   ctx.__originalClosePath = ctx.closePath;
98   ctx.__originalBeginPath = ctx.beginPath;
99 
100   ctx._removeMirroring = () => {
101     ctx.save = ctx.__originalSave;
102     ctx.restore = ctx.__originalRestore;
103     ctx.rotate = ctx.__originalRotate;
104     ctx.scale = ctx.__originalScale;
105     ctx.translate = ctx.__originalTranslate;
106     ctx.transform = ctx.__originalTransform;
107     ctx.setTransform = ctx.__originalSetTransform;
108     ctx.resetTransform = ctx.__originalResetTransform;
109 
110     ctx.clip = ctx.__originalClip;
111     ctx.moveTo = ctx.__originalMoveTo;
112     ctx.lineTo = ctx.__originalLineTo;
113     ctx.bezierCurveTo = ctx.__originalBezierCurveTo;
114     ctx.rect = ctx.__originalRect;
115     ctx.closePath = ctx.__originalClosePath;
116     ctx.beginPath = ctx.__originalBeginPath;
117     delete ctx._removeMirroring;
118   };
119 
120   ctx.save = function ctxSave() {
121     destCtx.save();
122     this.__originalSave();
123   };
124 
125   ctx.restore = function ctxRestore() {
126     destCtx.restore();
127     this.__originalRestore();
128   };
129 
130   ctx.translate = function ctxTranslate(x, y) {
131     destCtx.translate(x, y);
132     this.__originalTranslate(x, y);
133   };
134 
135   ctx.scale = function ctxScale(x, y) {
136     destCtx.scale(x, y);
137     this.__originalScale(x, y);
138   };
139 
140   ctx.transform = function ctxTransform(a, b, c, d, e, f) {
141     destCtx.transform(a, b, c, d, e, f);
142     this.__originalTransform(a, b, c, d, e, f);
143   };
144 
145   ctx.setTransform = function ctxSetTransform(a, b, c, d, e, f) {
146     destCtx.setTransform(a, b, c, d, e, f);
147     this.__originalSetTransform(a, b, c, d, e, f);
148   };
149 
150   ctx.resetTransform = function ctxResetTransform() {
151     destCtx.resetTransform();
152     this.__originalResetTransform();
153   };
154 
155   ctx.rotate = function ctxRotate(angle) {
156     destCtx.rotate(angle);
157     this.__originalRotate(angle);
158   };
159 
160   ctx.clip = function ctxRotate(rule) {
161     destCtx.clip(rule);
162     this.__originalClip(rule);
163   };
164 
165   ctx.moveTo = function (x, y) {
166     destCtx.moveTo(x, y);
167     this.__originalMoveTo(x, y);
168   };
169 
170   ctx.lineTo = function (x, y) {
171     destCtx.lineTo(x, y);
172     this.__originalLineTo(x, y);
173   };
174 
175   ctx.bezierCurveTo = function (cp1x, cp1y, cp2x, cp2y, x, y) {
176     destCtx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y);
177     this.__originalBezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y);
178   };
179 
180   ctx.rect = function (x, y, width, height) {
181     destCtx.rect(x, y, width, height);
182     this.__originalRect(x, y, width, height);
183   };
184 
185   ctx.closePath = function () {
186     destCtx.closePath();
187     this.__originalClosePath();
188   };
189 
190   ctx.beginPath = function () {
191     destCtx.beginPath();
192     this.__originalBeginPath();
193   };
194 }
195 
196 class CachedCanvases {
197   constructor(canvasFactory) {
198     this.canvasFactory = canvasFactory;
199     this.cache = Object.create(null);
200   }
201 
202   getCanvas(id, width, height) {
203     let canvasEntry;
204     if (this.cache[id] !== undefined) {
205       canvasEntry = this.cache[id];
206       this.canvasFactory.reset(canvasEntry, width, height);
207     } else {
208       canvasEntry = this.canvasFactory.create(width, height);
209       this.cache[id] = canvasEntry;
210     }
211     return canvasEntry;
212   }
213 
214   delete(id) {
215     delete this.cache[id];
216   }
217 
218   clear() {
219     for (const id in this.cache) {
220       const canvasEntry = this.cache[id];
221       this.canvasFactory.destroy(canvasEntry);
222       delete this.cache[id];
223     }
224   }
225 }
226 
227 function drawImageAtIntegerCoords(
228   ctx,
229   srcImg,
230   srcX,
231   srcY,
232   srcW,
233   srcH,
234   destX,
235   destY,
236   destW,
237   destH
238 ) {
239   const [a, b, c, d, tx, ty] = getCurrentTransform(ctx);
240   if (b === 0 && c === 0) {
241     // top-left corner is at (X, Y) and
242     // bottom-right one is at (X + width, Y + height).
243 
244     // If leftX is 4.321 then it's rounded to 4.
245     // If width is 10.432 then it's rounded to 11 because
246     // rightX = leftX + width = 14.753 which is rounded to 15
247     // so after rounding the total width is 11 (15 - 4).
248     // It's why we can't just floor/ceil uniformly, it just depends
249     // on the values we've.
250 
251     const tlX = destX * a + tx;
252     const rTlX = Math.round(tlX);
253     const tlY = destY * d + ty;
254     const rTlY = Math.round(tlY);
255     const brX = (destX + destW) * a + tx;
256 
257     // Some pdf contains images with 1x1 images so in case of 0-width after
258     // scaling we must fallback on 1 to be sure there is something.
259     const rWidth = Math.abs(Math.round(brX) - rTlX) || 1;
260     const brY = (destY + destH) * d + ty;
261     const rHeight = Math.abs(Math.round(brY) - rTlY) || 1;
262 
263     // We must apply a transformation in order to apply it on the image itself.
264     // For example if a == 1 && d == -1, it means that the image itself is
265     // mirrored w.r.t. the x-axis.
266     ctx.setTransform(Math.sign(a), 0, 0, Math.sign(d), rTlX, rTlY);
267     ctx.drawImage(srcImg, srcX, srcY, srcW, srcH, 0, 0, rWidth, rHeight);
268     ctx.setTransform(a, b, c, d, tx, ty);
269 
270     return [rWidth, rHeight];
271   }
272 
273   if (a === 0 && d === 0) {
274     // This path is taken in issue9462.pdf (page 3).
275     const tlX = destY * c + tx;
276     const rTlX = Math.round(tlX);
277     const tlY = destX * b + ty;
278     const rTlY = Math.round(tlY);
279     const brX = (destY + destH) * c + tx;
280     const rWidth = Math.abs(Math.round(brX) - rTlX) || 1;
281     const brY = (destX + destW) * b + ty;
282     const rHeight = Math.abs(Math.round(brY) - rTlY) || 1;
283 
284     ctx.setTransform(0, Math.sign(b), Math.sign(c), 0, rTlX, rTlY);
285     ctx.drawImage(srcImg, srcX, srcY, srcW, srcH, 0, 0, rHeight, rWidth);
286     ctx.setTransform(a, b, c, d, tx, ty);
287 
288     return [rHeight, rWidth];
289   }
290 
291   // Not a scale matrix so let the render handle the case without rounding.
292   ctx.drawImage(srcImg, srcX, srcY, srcW, srcH, destX, destY, destW, destH);
293 
294   const scaleX = Math.hypot(a, b);
295   const scaleY = Math.hypot(c, d);
296   return [scaleX * destW, scaleY * destH];
297 }
298 
299 function compileType3Glyph(imgData) {
300   const { width, height } = imgData;
301   if (width > MAX_SIZE_TO_COMPILE || height > MAX_SIZE_TO_COMPILE) {
302     return null;
303   }
304 
305   const POINT_TO_PROCESS_LIMIT = 1000;
306   const POINT_TYPES = new Uint8Array([
307     0, 2, 4, 0, 1, 0, 5, 4, 8, 10, 0, 8, 0, 2, 1, 0,
308   ]);
309 
310   const width1 = width + 1;
311   let points = new Uint8Array(width1 * (height + 1));
312   let i, j, j0;
313 
314   // decodes bit-packed mask data
315   const lineSize = (width + 7) & ~7;
316   let data = new Uint8Array(lineSize * height),
317     pos = 0;
318   for (const elem of imgData.data) {
319     let mask = 128;
320     while (mask > 0) {
321       data[pos++] = elem & mask ? 0 : 255;
322       mask >>= 1;
323     }
324   }
325 
326   // finding interesting points: every point is located between mask pixels,
327   // so there will be points of the (width + 1)x(height + 1) grid. Every point
328   // will have flags assigned based on neighboring mask pixels:
329   //   4 | 8
330   //   --P--
331   //   2 | 1
332   // We are interested only in points with the flags:
333   //   - outside corners: 1, 2, 4, 8;
334   //   - inside corners: 7, 11, 13, 14;
335   //   - and, intersections: 5, 10.
336   let count = 0;
337   pos = 0;
338   if (data[pos] !== 0) {
339     points[0] = 1;
340     ++count;
341   }
342   for (j = 1; j < width; j++) {
343     if (data[pos] !== data[pos + 1]) {
344       points[j] = data[pos] ? 2 : 1;
345       ++count;
346     }
347     pos++;
348   }
349   if (data[pos] !== 0) {
350     points[j] = 2;
351     ++count;
352   }
353   for (i = 1; i < height; i++) {
354     pos = i * lineSize;
355     j0 = i * width1;
356     if (data[pos - lineSize] !== data[pos]) {
357       points[j0] = data[pos] ? 1 : 8;
358       ++count;
359     }
360     // 'sum' is the position of the current pixel configuration in the 'TYPES'
361     // array (in order 8-1-2-4, so we can use '>>2' to shift the column).
362     let sum = (data[pos] ? 4 : 0) + (data[pos - lineSize] ? 8 : 0);
363     for (j = 1; j < width; j++) {
364       sum =
365         (sum >> 2) +
366         (data[pos + 1] ? 4 : 0) +
367         (data[pos - lineSize + 1] ? 8 : 0);
368       if (POINT_TYPES[sum]) {
369         points[j0 + j] = POINT_TYPES[sum];
370         ++count;
371       }
372       pos++;
373     }
374     if (data[pos - lineSize] !== data[pos]) {
375       points[j0 + j] = data[pos] ? 2 : 4;
376       ++count;
377     }
378 
379     if (count > POINT_TO_PROCESS_LIMIT) {
380       return null;
381     }
382   }
383 
384   pos = lineSize * (height - 1);
385   j0 = i * width1;
386   if (data[pos] !== 0) {
387     points[j0] = 8;
388     ++count;
389   }
390   for (j = 1; j < width; j++) {
391     if (data[pos] !== data[pos + 1]) {
392       points[j0 + j] = data[pos] ? 4 : 8;
393       ++count;
394     }
395     pos++;
396   }
397   if (data[pos] !== 0) {
398     points[j0 + j] = 4;
399     ++count;
400   }
401   if (count > POINT_TO_PROCESS_LIMIT) {
402     return null;
403   }
404 
405   // building outlines
406   const steps = new Int32Array([0, width1, -1, 0, -width1, 0, 0, 0, 1]);
407   const path = new Path2D();
408 
409   for (i = 0; count && i <= height; i++) {
410     let p = i * width1;
411     const end = p + width;
412     while (p < end && !points[p]) {
413       p++;
414     }
415     if (p === end) {
416       continue;
417     }
418     path.moveTo(p % width1, i);
419 
420     const p0 = p;
421     let type = points[p];
422     do {
423       const step = steps[type];
424       do {
425         p += step;
426       } while (!points[p]);
427 
428       const pp = points[p];
429       if (pp !== 5 && pp !== 10) {
430         // set new direction
431         type = pp;
432         // delete mark
433         points[p] = 0;
434       } else {
435         // type is 5 or 10, ie, a crossing
436         // set new direction
437         type = pp & ((0x33 * type) >> 4);
438         // set new type for "future hit"
439         points[p] &= (type >> 2) | (type << 2);
440       }
441       path.lineTo(p % width1, (p / width1) | 0);
442 
443       if (!points[p]) {
444         --count;
445       }
446     } while (p0 !== p);
447     --i;
448   }
449 
450   // Immediately release the, potentially large, `Uint8Array`s after parsing.
451   data = null;
452   points = null;
453 
454   const drawOutline = function (c) {
455     c.save();
456     // the path shall be painted in [0..1]x[0..1] space
457     c.scale(1 / width, -1 / height);
458     c.translate(0, -height);
459     c.fill(path);
460     c.beginPath();
461     c.restore();
462   };
463 
464   return drawOutline;
465 }
466 
467 class CanvasExtraState {
468   constructor(width, height) {
469     // Are soft masks and alpha values shapes or opacities?
470     this.alphaIsShape = false;
471     this.fontSize = 0;
472     this.fontSizeScale = 1;
473     this.textMatrix = IDENTITY_MATRIX;
474     this.textMatrixScale = 1;
475     this.fontMatrix = FONT_IDENTITY_MATRIX;
476     this.leading = 0;
477     // Current point (in user coordinates)
478     this.x = 0;
479     this.y = 0;
480     // Start of text line (in text coordinates)
481     this.lineX = 0;
482     this.lineY = 0;
483     // Character and word spacing
484     this.charSpacing = 0;
485     this.wordSpacing = 0;
486     this.textHScale = 1;
487     this.textRenderingMode = TextRenderingMode.FILL;
488     this.textRise = 0;
489     // Default fore and background colors
490     this.fillColor = "#000000";
491     this.strokeColor = "#000000";
492     this.patternFill = false;
493     this.patternStroke = false;
494     // Note: fill alpha applies to all non-stroking operations
495     this.fillAlpha = 1;
496     this.strokeAlpha = 1;
497     this.lineWidth = 1;
498     this.activeSMask = null;
499     this.transferMaps = "none";
500 
501     this.startNewPathAndClipBox([0, 0, width, height]);
502   }
503 
504   clone() {
505     const clone = Object.create(this);
506     clone.clipBox = this.clipBox.slice();
507     return clone;
508   }
509 
510   updateRectMinMax(transform, rect) {
511     const p1 = Util.applyTransform(rect, transform);
512     const p2 = Util.applyTransform(rect.slice(2), transform);
513     const p3 = Util.applyTransform([rect[0], rect[3]], transform);
514     const p4 = Util.applyTransform([rect[2], rect[1]], transform);
515 
516     this.minX = Math.min(this.minX, p1[0], p2[0], p3[0], p4[0]);
517     this.minY = Math.min(this.minY, p1[1], p2[1], p3[1], p4[1]);
518     this.maxX = Math.max(this.maxX, p1[0], p2[0], p3[0], p4[0]);
519     this.maxY = Math.max(this.maxY, p1[1], p2[1], p3[1], p4[1]);
520   }
521 
522   getPathBoundingBox(pathType = PathType.FILL, transform = null) {
523     const box = [this.minX, this.minY, this.maxX, this.maxY];
524     if (pathType === PathType.STROKE) {
525       if (!transform) {
526         unreachable("Stroke bounding box must include transform.");
527       }
528       // Stroked paths can be outside of the path bounding box by 1/2 the line
529       // width.
530       const scale = Util.singularValueDecompose2dScale(transform);
531       const xStrokePad = (scale[0] * this.lineWidth) / 2;
532       const yStrokePad = (scale[1] * this.lineWidth) / 2;
533       box[0] -= xStrokePad;
534       box[1] -= yStrokePad;
535       box[2] += xStrokePad;
536       box[3] += yStrokePad;
537     }
538     return box;
539   }
540 
541   updateClipFromPath() {
542     const intersect = Util.intersect(this.clipBox, this.getPathBoundingBox());
543     this.startNewPathAndClipBox(intersect || [0, 0, 0, 0]);
544   }
545 
546   isEmptyClip() {
547     return this.minX === Infinity;
548   }
549 
550   startNewPathAndClipBox(box) {
551     this.clipBox = box;
552     this.minX = Infinity;
553     this.minY = Infinity;
554     this.maxX = 0;
555     this.maxY = 0;
556   }
557 
558   getClippedPathBoundingBox(pathType = PathType.FILL, transform = null) {
559     return Util.intersect(
560       this.clipBox,
561       this.getPathBoundingBox(pathType, transform)
562     );
563   }
564 }
565 
566 function putBinaryImageData(ctx, imgData) {
567   if (imgData instanceof ImageData) {
568     ctx.putImageData(imgData, 0, 0);
569     return;
570   }
571 
572   // Put the image data to the canvas in chunks, rather than putting the
573   // whole image at once.  This saves JS memory, because the ImageData object
574   // is smaller. It also possibly saves C++ memory within the implementation
575   // of putImageData(). (E.g. in Firefox we make two short-lived copies of
576   // the data passed to putImageData()). |n| shouldn't be too small, however,
577   // because too many putImageData() calls will slow things down.
578   //
579   // Note: as written, if the last chunk is partial, the putImageData() call
580   // will (conceptually) put pixels past the bounds of the canvas.  But
581   // that's ok; any such pixels are ignored.
582 
583   const height = imgData.height,
584     width = imgData.width;
585   const partialChunkHeight = height % FULL_CHUNK_HEIGHT;
586   const fullChunks = (height - partialChunkHeight) / FULL_CHUNK_HEIGHT;
587   const totalChunks = partialChunkHeight === 0 ? fullChunks : fullChunks + 1;
588 
589   const chunkImgData = ctx.createImageData(width, FULL_CHUNK_HEIGHT);
590   let srcPos = 0,
591     destPos;
592   const src = imgData.data;
593   const dest = chunkImgData.data;
594   let i, j, thisChunkHeight, elemsInThisChunk;
595 
596   // There are multiple forms in which the pixel data can be passed, and
597   // imgData.kind tells us which one this is.
598   if (imgData.kind === ImageKind.GRAYSCALE_1BPP) {
599     // Grayscale, 1 bit per pixel (i.e. black-and-white).
600     const srcLength = src.byteLength;
601     const dest32 = new Uint32Array(dest.buffer, 0, dest.byteLength >> 2);
602     const dest32DataLength = dest32.length;
603     const fullSrcDiff = (width + 7) >> 3;
604     const white = 0xffffffff;
605     const black = FeatureTest.isLittleEndian ? 0xff000000 : 0x000000ff;
606 
607     for (i = 0; i < totalChunks; i++) {
608       thisChunkHeight = i < fullChunks ? FULL_CHUNK_HEIGHT : partialChunkHeight;
609       destPos = 0;
610       for (j = 0; j < thisChunkHeight; j++) {
611         const srcDiff = srcLength - srcPos;
612         let k = 0;
613         const kEnd = srcDiff > fullSrcDiff ? width : srcDiff * 8 - 7;
614         const kEndUnrolled = kEnd & ~7;
615         let mask = 0;
616         let srcByte = 0;
617         for (; k < kEndUnrolled; k += 8) {
618           srcByte = src[srcPos++];
619           dest32[destPos++] = srcByte & 128 ? white : black;
620           dest32[destPos++] = srcByte & 64 ? white : black;
621           dest32[destPos++] = srcByte & 32 ? white : black;
622           dest32[destPos++] = srcByte & 16 ? white : black;
623           dest32[destPos++] = srcByte & 8 ? white : black;
624           dest32[destPos++] = srcByte & 4 ? white : black;
625           dest32[destPos++] = srcByte & 2 ? white : black;
626           dest32[destPos++] = srcByte & 1 ? white : black;
627         }
628         for (; k < kEnd; k++) {
629           if (mask === 0) {
630             srcByte = src[srcPos++];
631             mask = 128;
632           }
633 
634           dest32[destPos++] = srcByte & mask ? white : black;
635           mask >>= 1;
636         }
637       }
638       // We ran out of input. Make all remaining pixels transparent.
639       while (destPos < dest32DataLength) {
640         dest32[destPos++] = 0;
641       }
642 
643       ctx.putImageData(chunkImgData, 0, i * FULL_CHUNK_HEIGHT);
644     }
645   } else if (imgData.kind === ImageKind.RGBA_32BPP) {
646     // RGBA, 32-bits per pixel.
647     j = 0;
648     elemsInThisChunk = width * FULL_CHUNK_HEIGHT * 4;
649     for (i = 0; i < fullChunks; i++) {
650       dest.set(src.subarray(srcPos, srcPos + elemsInThisChunk));
651       srcPos += elemsInThisChunk;
652 
653       ctx.putImageData(chunkImgData, 0, j);
654       j += FULL_CHUNK_HEIGHT;
655     }
656     if (i < totalChunks) {
657       elemsInThisChunk = width * partialChunkHeight * 4;
658       dest.set(src.subarray(srcPos, srcPos + elemsInThisChunk));
659 
660       ctx.putImageData(chunkImgData, 0, j);
661     }
662   } else if (imgData.kind === ImageKind.RGB_24BPP) {
663     // RGB, 24-bits per pixel.
664     thisChunkHeight = FULL_CHUNK_HEIGHT;
665     elemsInThisChunk = width * thisChunkHeight;
666     for (i = 0; i < totalChunks; i++) {
667       if (i >= fullChunks) {
668         thisChunkHeight = partialChunkHeight;
669         elemsInThisChunk = width * thisChunkHeight;
670       }
671 
672       destPos = 0;
673       for (j = elemsInThisChunk; j--; ) {
674         dest[destPos++] = src[srcPos++];
675         dest[destPos++] = src[srcPos++];
676         dest[destPos++] = src[srcPos++];
677         dest[destPos++] = 255;
678       }
679 
680       ctx.putImageData(chunkImgData, 0, i * FULL_CHUNK_HEIGHT);
681     }
682   } else {
683     throw new Error(`bad image kind: ${imgData.kind}`);
684   }
685 }
686 
687 function putBinaryImageMask(ctx, imgData) {
688   if (imgData.bitmap) {
689     // The bitmap has been created in the worker.
690     ctx.drawImage(imgData.bitmap, 0, 0);
691     return;
692   }
693 
694   // Slow path: OffscreenCanvas isn't available in the worker.
695   const height = imgData.height,
696     width = imgData.width;
697   const partialChunkHeight = height % FULL_CHUNK_HEIGHT;
698   const fullChunks = (height - partialChunkHeight) / FULL_CHUNK_HEIGHT;
699   const totalChunks = partialChunkHeight === 0 ? fullChunks : fullChunks + 1;
700 
701   const chunkImgData = ctx.createImageData(width, FULL_CHUNK_HEIGHT);
702   let srcPos = 0;
703   const src = imgData.data;
704   const dest = chunkImgData.data;
705 
706   for (let i = 0; i < totalChunks; i++) {
707     const thisChunkHeight =
708       i < fullChunks ? FULL_CHUNK_HEIGHT : partialChunkHeight;
709 
710     // Expand the mask so it can be used by the canvas.  Any required
711     // inversion has already been handled.
712 
713     ({ srcPos } = convertBlackAndWhiteToRGBA({
714       src,
715       srcPos,
716       dest,
717       width,
718       height: thisChunkHeight,
719       nonBlackColor: 0,
720     }));
721 
722     ctx.putImageData(chunkImgData, 0, i * FULL_CHUNK_HEIGHT);
723   }
724 }
725 
726 function copyCtxState(sourceCtx, destCtx) {
727   const properties = [
728     "strokeStyle",
729     "fillStyle",
730     "fillRule",
731     "globalAlpha",
732     "lineWidth",
733     "lineCap",
734     "lineJoin",
735     "miterLimit",
736     "globalCompositeOperation",
737     "font",
738     "filter",
739   ];
740   for (const property of properties) {
741     if (sourceCtx[property] !== undefined) {
742       destCtx[property] = sourceCtx[property];
743     }
744   }
745   if (sourceCtx.setLineDash !== undefined) {
746     destCtx.setLineDash(sourceCtx.getLineDash());
747     destCtx.lineDashOffset = sourceCtx.lineDashOffset;
748   }
749 }
750 
751 function resetCtxToDefault(ctx) {
752   ctx.strokeStyle = ctx.fillStyle = "#000000";
753   ctx.fillRule = "nonzero";
754   ctx.globalAlpha = 1;
755   ctx.lineWidth = 1;
756   ctx.lineCap = "butt";
757   ctx.lineJoin = "miter";
758   ctx.miterLimit = 10;
759   ctx.globalCompositeOperation = "source-over";
760   ctx.font = "10px sans-serif";
761   if (ctx.setLineDash !== undefined) {
762     ctx.setLineDash([]);
763     ctx.lineDashOffset = 0;
764   }
765   if (
766     (typeof PDFJSDev !== "undefined" && PDFJSDev.test("MOZCENTRAL")) ||
767     !isNodeJS
768   ) {
769     const { filter } = ctx;
770     if (filter !== "none" && filter !== "") {
771       ctx.filter = "none";
772     }
773   }
774 }
775 
776 function getImageSmoothingEnabled(transform, interpolate) {
777   // In section 8.9.5.3 of the PDF spec, it's mentioned that the interpolate
778   // flag should be used when the image is upscaled.
779   // In Firefox, smoothing is always used when downscaling images (bug 1360415).
780 
781   if (interpolate) {
782     return true;
783   }
784 
785   const scale = Util.singularValueDecompose2dScale(transform);
786   // Round to a 32bit float so that `<=` check below will pass for numbers that
787   // are very close, but not exactly the same 64bit floats.
788   scale[0] = Math.fround(scale[0]);
789   scale[1] = Math.fround(scale[1]);
790   const actualScale = Math.fround(
791     OutputScale.pixelRatio * PixelsPerInch.PDF_TO_CSS_UNITS
792   );
793   return scale[0] <= actualScale && scale[1] <= actualScale;
794 }
795 
796 const LINE_CAP_STYLES = ["butt", "round", "square"];
797 const LINE_JOIN_STYLES = ["miter", "round", "bevel"];
798 const NORMAL_CLIP = {};
799 const EO_CLIP = {};
800 
801 class CanvasGraphics {
802   constructor(
803     canvasCtx,
804     commonObjs,
805     objs,
806     canvasFactory,
807     filterFactory,
808     { optionalContentConfig, markedContentStack = null },
809     annotationCanvasMap,
810     pageColors
811   ) {
812     this.ctx = canvasCtx;
813     this.current = new CanvasExtraState(
814       this.ctx.canvas.width,
815       this.ctx.canvas.height
816     );
817     this.stateStack = [];
818     this.pendingClip = null;
819     this.pendingEOFill = false;
820     this.res = null;
821     this.xobjs = null;
822     this.commonObjs = commonObjs;
823     this.objs = objs;
824     this.canvasFactory = canvasFactory;
825     this.filterFactory = filterFactory;
826     this.groupStack = [];
827     this.processingType3 = null;
828     // Patterns are painted relative to the initial page/form transform, see
829     // PDF spec 8.7.2 NOTE 1.
830     this.baseTransform = null;
831     this.baseTransformStack = [];
832     this.groupLevel = 0;
833     this.smaskStack = [];
834     this.smaskCounter = 0;
835     this.tempSMask = null;
836     this.suspendedCtx = null;
837     this.contentVisible = true;
838     this.markedContentStack = markedContentStack || [];
839     this.optionalContentConfig = optionalContentConfig;
840     this.cachedCanvases = new CachedCanvases(this.canvasFactory);
841     this.cachedPatterns = new Map();
842     this.annotationCanvasMap = annotationCanvasMap;
843     this.viewportScale = 1;
844     this.outputScaleX = 1;
845     this.outputScaleY = 1;
846     this.pageColors = pageColors;
847 
848     this._cachedScaleForStroking = [-1, 0];
849     this._cachedGetSinglePixelWidth = null;
850     this._cachedBitmapsMap = new Map();
851   }
852 
853   getObject(data, fallback = null) {
854     if (typeof data === "string") {
855       return data.startsWith("g_")
856         ? this.commonObjs.get(data)
857         : this.objs.get(data);
858     }
859     return fallback;
860   }
861 
862   beginDrawing({
863     transform,
864     viewport,
865     transparency = false,
866     background = null,
867   }) {
868     // For pdfs that use blend modes we have to clear the canvas else certain
869     // blend modes can look wrong since we'd be blending with a white
870     // backdrop. The problem with a transparent backdrop though is we then
871     // don't get sub pixel anti aliasing on text, creating temporary
872     // transparent canvas when we have blend modes.
873     const width = this.ctx.canvas.width;
874     const height = this.ctx.canvas.height;
875 
876     const savedFillStyle = this.ctx.fillStyle;
877     this.ctx.fillStyle = background || "#ffffff";
878     this.ctx.fillRect(0, 0, width, height);
879     this.ctx.fillStyle = savedFillStyle;
880 
881     if (transparency) {
882       const transparentCanvas = this.cachedCanvases.getCanvas(
883         "transparent",
884         width,
885         height
886       );
887       this.compositeCtx = this.ctx;
888       this.transparentCanvas = transparentCanvas.canvas;
889       this.ctx = transparentCanvas.context;
890       this.ctx.save();
891       // The transform can be applied before rendering, transferring it to
892       // the new canvas.
893       this.ctx.transform(...getCurrentTransform(this.compositeCtx));
894     }
895 
896     this.ctx.save();
897     resetCtxToDefault(this.ctx);
898     if (transform) {
899       this.ctx.transform(...transform);
900       this.outputScaleX = transform[0];
901       this.outputScaleY = transform[0];
902     }
903     this.ctx.transform(...viewport.transform);
904     this.viewportScale = viewport.scale;
905 
906     this.baseTransform = getCurrentTransform(this.ctx);
907   }
908 
909   executeOperatorList(
910     operatorList,
911     executionStartIdx,
912     continueCallback,
913     stepper
914   ) {
915     const argsArray = operatorList.argsArray;
916     const fnArray = operatorList.fnArray;
917     let i = executionStartIdx || 0;
918     const argsArrayLen = argsArray.length;
919 
920     // Sometimes the OperatorList to execute is empty.
921     if (argsArrayLen === i) {
922       return i;
923     }
924 
925     const chunkOperations =
926       argsArrayLen - i > EXECUTION_STEPS &&
927       typeof continueCallback === "function";
928     const endTime = chunkOperations ? Date.now() + EXECUTION_TIME : 0;
929     let steps = 0;
930 
931     const commonObjs = this.commonObjs;
932     const objs = this.objs;
933     let fnId;
934 
935     while (true) {
936       if (stepper !== undefined && i === stepper.nextBreakPoint) {
937         stepper.breakIt(i, continueCallback);
938         return i;
939       }
940 
941       fnId = fnArray[i];
942 
943       if (fnId !== OPS.dependency) {
944         // eslint-disable-next-line prefer-spread
945         this[fnId].apply(this, argsArray[i]);
946       } else {
947         for (const depObjId of argsArray[i]) {
948           const objsPool = depObjId.startsWith("g_") ? commonObjs : objs;
949 
950           // If the promise isn't resolved yet, add the continueCallback
951           // to the promise and bail out.
952           if (!objsPool.has(depObjId)) {
953             objsPool.get(depObjId, continueCallback);
954             return i;
955           }
956         }
957       }
958 
959       i++;
960 
961       // If the entire operatorList was executed, stop as were done.
962       if (i === argsArrayLen) {
963         return i;
964       }
965 
966       // If the execution took longer then a certain amount of time and
967       // `continueCallback` is specified, interrupt the execution.
968       if (chunkOperations && ++steps > EXECUTION_STEPS) {
969         if (Date.now() > endTime) {
970           continueCallback();
971           return i;
972         }
973         steps = 0;
974       }
975 
976       // If the operatorList isn't executed completely yet OR the execution
977       // time was short enough, do another execution round.
978     }
979   }
980 
981   #restoreInitialState() {
982     // Finishing all opened operations such as SMask group painting.
983     while (this.stateStack.length || this.inSMaskMode) {
984       this.restore();
985     }
986 
987     this.current.activeSMask = null;
988     this.ctx.restore();
989 
990     if (this.transparentCanvas) {
991       this.ctx = this.compositeCtx;
992       this.ctx.save();
993       this.ctx.setTransform(1, 0, 0, 1, 0, 0); // Avoid apply transform twice
994       this.ctx.drawImage(this.transparentCanvas, 0, 0);
995       this.ctx.restore();
996       this.transparentCanvas = null;
997     }
998   }
999 
1000   endDrawing() {
1001     this.#restoreInitialState();
1002 
1003     this.cachedCanvases.clear();
1004     this.cachedPatterns.clear();
1005 
1006     for (const cache of this._cachedBitmapsMap.values()) {
1007       for (const canvas of cache.values()) {
1008         if (
1009           typeof HTMLCanvasElement !== "undefined" &&
1010           canvas instanceof HTMLCanvasElement
1011         ) {
1012           canvas.width = canvas.height = 0;
1013         }
1014       }
1015       cache.clear();
1016     }
1017     this._cachedBitmapsMap.clear();
1018     this.#drawFilter();
1019   }
1020 
1021   #drawFilter() {
1022     if (this.pageColors) {
1023       const hcmFilterId = this.filterFactory.addHCMFilter(
1024         this.pageColors.foreground,
1025         this.pageColors.background
1026       );
1027       if (hcmFilterId !== "none") {
1028         const savedFilter = this.ctx.filter;
1029         this.ctx.filter = hcmFilterId;
1030         this.ctx.drawImage(this.ctx.canvas, 0, 0);
1031         this.ctx.filter = savedFilter;
1032       }
1033     }
1034   }
1035 
1036   _scaleImage(img, inverseTransform) {
1037     // Vertical or horizontal scaling shall not be more than 2 to not lose the
1038     // pixels during drawImage operation, painting on the temporary canvas(es)
1039     // that are twice smaller in size.
1040 
1041     // displayWidth and displayHeight are used for VideoFrame.
1042     const width = img.width ?? img.displayWidth;
1043     const height = img.height ?? img.displayHeight;
1044     let widthScale = Math.max(
1045       Math.hypot(inverseTransform[0], inverseTransform[1]),
1046       1
1047     );
1048     let heightScale = Math.max(
1049       Math.hypot(inverseTransform[2], inverseTransform[3]),
1050       1
1051     );
1052 
1053     let paintWidth = width,
1054       paintHeight = height;
1055     let tmpCanvasId = "prescale1";
1056     let tmpCanvas, tmpCtx;
1057     while (
1058       (widthScale > 2 && paintWidth > 1) ||
1059       (heightScale > 2 && paintHeight > 1)
1060     ) {
1061       let newWidth = paintWidth,
1062         newHeight = paintHeight;
1063       if (widthScale > 2 && paintWidth > 1) {
1064         // See bug 1820511 (Windows specific bug).
1065         // TODO: once the above bug is fixed we could revert to:
1066         // newWidth = Math.ceil(paintWidth / 2);
1067         newWidth =
1068           paintWidth >= 16384
1069             ? Math.floor(paintWidth / 2) - 1 || 1
1070             : Math.ceil(paintWidth / 2);
1071         widthScale /= paintWidth / newWidth;
1072       }
1073       if (heightScale > 2 && paintHeight > 1) {
1074         // TODO: see the comment above.
1075         newHeight =
1076           paintHeight >= 16384
1077             ? Math.floor(paintHeight / 2) - 1 || 1
1078             : Math.ceil(paintHeight) / 2;
1079         heightScale /= paintHeight / newHeight;
1080       }
1081       tmpCanvas = this.cachedCanvases.getCanvas(
1082         tmpCanvasId,
1083         newWidth,
1084         newHeight
1085       );
1086       tmpCtx = tmpCanvas.context;
1087       tmpCtx.clearRect(0, 0, newWidth, newHeight);
1088       tmpCtx.drawImage(
1089         img,
1090         0,
1091         0,
1092         paintWidth,
1093         paintHeight,
1094         0,
1095         0,
1096         newWidth,
1097         newHeight
1098       );
1099       img = tmpCanvas.canvas;
1100       paintWidth = newWidth;
1101       paintHeight = newHeight;
1102       tmpCanvasId = tmpCanvasId === "prescale1" ? "prescale2" : "prescale1";
1103     }
1104     return {
1105       img,
1106       paintWidth,
1107       paintHeight,
1108     };
1109   }
1110 
1111   _createMaskCanvas(img) {
1112     const ctx = this.ctx;
1113     const { width, height } = img;
1114     const fillColor = this.current.fillColor;
1115     const isPatternFill = this.current.patternFill;
1116     const currentTransform = getCurrentTransform(ctx);
1117 
1118     let cache, cacheKey, scaled, maskCanvas;
1119     if ((img.bitmap || img.data) && img.count > 1) {
1120       const mainKey = img.bitmap || img.data.buffer;
1121       // We're reusing the same image several times, so we can cache it.
1122       // In case we've a pattern fill we just keep the scaled version of
1123       // the image.
1124       // Only the scaling part matters, the translation part is just used
1125       // to compute offsets (but not when filling patterns see #15573).
1126       // TODO: handle the case of a pattern fill if it's possible.
1127       cacheKey = JSON.stringify(
1128         isPatternFill
1129           ? currentTransform
1130           : [currentTransform.slice(0, 4), fillColor]
1131       );
1132 
1133       cache = this._cachedBitmapsMap.get(mainKey);
1134       if (!cache) {
1135         cache = new Map();
1136         this._cachedBitmapsMap.set(mainKey, cache);
1137       }
1138       const cachedImage = cache.get(cacheKey);
1139       if (cachedImage && !isPatternFill) {
1140         const offsetX = Math.round(
1141           Math.min(currentTransform[0], currentTransform[2]) +
1142             currentTransform[4]
1143         );
1144         const offsetY = Math.round(
1145           Math.min(currentTransform[1], currentTransform[3]) +
1146             currentTransform[5]
1147         );
1148         return {
1149           canvas: cachedImage,
1150           offsetX,
1151           offsetY,
1152         };
1153       }
1154       scaled = cachedImage;
1155     }
1156 
1157     if (!scaled) {
1158       maskCanvas = this.cachedCanvases.getCanvas("maskCanvas", width, height);
1159       putBinaryImageMask(maskCanvas.context, img);
1160     }
1161 
1162     // Create the mask canvas at the size it will be drawn at and also set
1163     // its transform to match the current transform so if there are any
1164     // patterns applied they will be applied relative to the correct
1165     // transform.
1166 
1167     let maskToCanvas = Util.transform(currentTransform, [
1168       1 / width,
1169       0,
1170       0,
1171       -1 / height,
1172       0,
1173       0,
1174     ]);
1175     maskToCanvas = Util.transform(maskToCanvas, [1, 0, 0, 1, 0, -height]);
1176     const [minX, minY, maxX, maxY] = Util.getAxialAlignedBoundingBox(
1177       [0, 0, width, height],
1178       maskToCanvas
1179     );
1180     const drawnWidth = Math.round(maxX - minX) || 1;
1181     const drawnHeight = Math.round(maxY - minY) || 1;
1182     const fillCanvas = this.cachedCanvases.getCanvas(
1183       "fillCanvas",
1184       drawnWidth,
1185       drawnHeight
1186     );
1187     const fillCtx = fillCanvas.context;
1188 
1189     // The offset will be the top-left cordinate mask.
1190     // If objToCanvas is [a,b,c,d,e,f] then:
1191     //   - offsetX = min(a, c) + e
1192     //   - offsetY = min(b, d) + f
1193     const offsetX = minX;
1194     const offsetY = minY;
1195     fillCtx.translate(-offsetX, -offsetY);
1196     fillCtx.transform(...maskToCanvas);
1197 
1198     if (!scaled) {
1199       // Pre-scale if needed to improve image smoothing.
1200       scaled = this._scaleImage(
1201         maskCanvas.canvas,
1202         getCurrentTransformInverse(fillCtx)
1203       );
1204       scaled = scaled.img;
1205       if (cache && isPatternFill) {
1206         cache.set(cacheKey, scaled);
1207       }
1208     }
1209 
1210     fillCtx.imageSmoothingEnabled = getImageSmoothingEnabled(
1211       getCurrentTransform(fillCtx),
1212       img.interpolate
1213     );
1214 
1215     drawImageAtIntegerCoords(
1216       fillCtx,
1217       scaled,
1218       0,
1219       0,
1220       scaled.width,
1221       scaled.height,
1222       0,
1223       0,
1224       width,
1225       height
1226     );
1227     fillCtx.globalCompositeOperation = "source-in";
1228 
1229     const inverse = Util.transform(getCurrentTransformInverse(fillCtx), [
1230       1,
1231       0,
1232       0,
1233       1,
1234       -offsetX,
1235       -offsetY,
1236     ]);
1237     fillCtx.fillStyle = isPatternFill
1238       ? fillColor.getPattern(ctx, this, inverse, PathType.FILL)
1239       : fillColor;
1240 
1241     fillCtx.fillRect(0, 0, width, height);
1242 
1243     if (cache && !isPatternFill) {
1244       // The fill canvas is put in the cache associated to the mask image
1245       // so we must remove from the cached canvas: it mustn't be used again.
1246       this.cachedCanvases.delete("fillCanvas");
1247       cache.set(cacheKey, fillCanvas.canvas);
1248     }
1249 
1250     // Round the offsets to avoid drawing fractional pixels.
1251     return {
1252       canvas: fillCanvas.canvas,
1253       offsetX: Math.round(offsetX),
1254       offsetY: Math.round(offsetY),
1255     };
1256   }
1257 
1258   // Graphics state
1259   setLineWidth(width) {
1260     if (width !== this.current.lineWidth) {
1261       this._cachedScaleForStroking[0] = -1;
1262     }
1263     this.current.lineWidth = width;
1264     this.ctx.lineWidth = width;
1265   }
1266 
1267   setLineCap(style) {
1268     this.ctx.lineCap = LINE_CAP_STYLES[style];
1269   }
1270 
1271   setLineJoin(style) {
1272     this.ctx.lineJoin = LINE_JOIN_STYLES[style];
1273   }
1274 
1275   setMiterLimit(limit) {
1276     this.ctx.miterLimit = limit;
1277   }
1278 
1279   setDash(dashArray, dashPhase) {
1280     const ctx = this.ctx;
1281     if (ctx.setLineDash !== undefined) {
1282       ctx.setLineDash(dashArray);
1283       ctx.lineDashOffset = dashPhase;
1284     }
1285   }
1286 
1287   setRenderingIntent(intent) {
1288     // This operation is ignored since we haven't found a use case for it yet.
1289   }
1290 
1291   setFlatness(flatness) {
1292     // This operation is ignored since we haven't found a use case for it yet.
1293   }
1294 
1295   setGState(states) {
1296     for (const [key, value] of states) {
1297       switch (key) {
1298         case "LW":
1299           this.setLineWidth(value);
1300           break;
1301         case "LC":
1302           this.setLineCap(value);
1303           break;
1304         case "LJ":
1305           this.setLineJoin(value);
1306           break;
1307         case "ML":
1308           this.setMiterLimit(value);
1309           break;
1310         case "D":
1311           this.setDash(value[0], value[1]);
1312           break;
1313         case "RI":
1314           this.setRenderingIntent(value);
1315           break;
1316         case "FL":
1317           this.setFlatness(value);
1318           break;
1319         case "Font":
1320           this.setFont(value[0], value[1]);
1321           break;
1322         case "CA":
1323           this.current.strokeAlpha = value;
1324           break;
1325         case "ca":
1326           this.current.fillAlpha = value;
1327           this.ctx.globalAlpha = value;
1328           break;
1329         case "BM":
1330           this.ctx.globalCompositeOperation = value;
1331           break;
1332         case "SMask":
1333           this.current.activeSMask = value ? this.tempSMask : null;
1334           this.tempSMask = null;
1335           this.checkSMaskState();
1336           break;
1337         case "TR":
1338           this.ctx.filter = this.current.transferMaps =
1339             this.filterFactory.addFilter(value);
1340           break;
1341       }
1342     }
1343   }
1344 
1345   get inSMaskMode() {
1346     return !!this.suspendedCtx;
1347   }
1348 
1349   checkSMaskState() {
1350     const inSMaskMode = this.inSMaskMode;
1351     if (this.current.activeSMask && !inSMaskMode) {
1352       this.beginSMaskMode();
1353     } else if (!this.current.activeSMask && inSMaskMode) {
1354       this.endSMaskMode();
1355     }
1356     // Else, the state is okay and nothing needs to be done.
1357   }
1358 
1359   /**
1360    * Soft mask mode takes the current main drawing canvas and replaces it with
1361    * a temporary canvas. Any drawing operations that happen on the temporary
1362    * canvas need to be composed with the main canvas that was suspended (see
1363    * `compose()`). The temporary canvas also duplicates many of its operations
1364    * on the suspended canvas to keep them in sync, so that when the soft mask
1365    * mode ends any clipping paths or transformations will still be active and in
1366    * the right order on the canvas' graphics state stack.
1367    */
1368   beginSMaskMode() {
1369     if (this.inSMaskMode) {
1370       throw new Error("beginSMaskMode called while already in smask mode");
1371     }
1372     const drawnWidth = this.ctx.canvas.width;
1373     const drawnHeight = this.ctx.canvas.height;
1374     const cacheId = "smaskGroupAt" + this.groupLevel;
1375     const scratchCanvas = this.cachedCanvases.getCanvas(
1376       cacheId,
1377       drawnWidth,
1378       drawnHeight
1379     );
1380     this.suspendedCtx = this.ctx;
1381     this.ctx = scratchCanvas.context;
1382     const ctx = this.ctx;
1383     ctx.setTransform(this.suspendedCtx.getTransform());
1384     copyCtxState(this.suspendedCtx, ctx);
1385     mirrorContextOperations(ctx, this.suspendedCtx);
1386 
1387     this.setGState([
1388       ["BM", "source-over"],
1389       ["ca", 1],
1390       ["CA", 1],
1391     ]);
1392   }
1393 
1394   endSMaskMode() {
1395     if (!this.inSMaskMode) {
1396       throw new Error("endSMaskMode called while not in smask mode");
1397     }
1398     // The soft mask is done, now restore the suspended canvas as the main
1399     // drawing canvas.
1400     this.ctx._removeMirroring();
1401     copyCtxState(this.ctx, this.suspendedCtx);
1402     this.ctx = this.suspendedCtx;
1403 
1404     this.suspendedCtx = null;
1405   }
1406 
1407   compose(dirtyBox) {
1408     if (!this.current.activeSMask) {
1409       return;
1410     }
1411 
1412     if (!dirtyBox) {
1413       dirtyBox = [0, 0, this.ctx.canvas.width, this.ctx.canvas.height];
1414     } else {
1415       dirtyBox[0] = Math.floor(dirtyBox[0]);
1416       dirtyBox[1] = Math.floor(dirtyBox[1]);
1417       dirtyBox[2] = Math.ceil(dirtyBox[2]);
1418       dirtyBox[3] = Math.ceil(dirtyBox[3]);
1419     }
1420     const smask = this.current.activeSMask;
1421     const suspendedCtx = this.suspendedCtx;
1422 
1423     this.composeSMask(suspendedCtx, smask, this.ctx, dirtyBox);
1424     // Whatever was drawn has been moved to the suspended canvas, now clear it
1425     // out of the current canvas.
1426     this.ctx.save();
1427     this.ctx.setTransform(1, 0, 0, 1, 0, 0);
1428     this.ctx.clearRect(0, 0, this.ctx.canvas.width, this.ctx.canvas.height);
1429     this.ctx.restore();
1430   }
1431 
1432   composeSMask(ctx, smask, layerCtx, layerBox) {
1433     const layerOffsetX = layerBox[0];
1434     const layerOffsetY = layerBox[1];
1435     const layerWidth = layerBox[2] - layerOffsetX;
1436     const layerHeight = layerBox[3] - layerOffsetY;
1437     if (layerWidth === 0 || layerHeight === 0) {
1438       return;
1439     }
1440     this.genericComposeSMask(
1441       smask.context,
1442       layerCtx,
1443       layerWidth,
1444       layerHeight,
1445       smask.subtype,
1446       smask.backdrop,
1447       smask.transferMap,
1448       layerOffsetX,
1449       layerOffsetY,
1450       smask.offsetX,
1451       smask.offsetY
1452     );
1453     ctx.save();
1454     ctx.globalAlpha = 1;
1455     ctx.globalCompositeOperation = "source-over";
1456     ctx.setTransform(1, 0, 0, 1, 0, 0);
1457     ctx.drawImage(layerCtx.canvas, 0, 0);
1458     ctx.restore();
1459   }
1460 
1461   genericComposeSMask(
1462     maskCtx,
1463     layerCtx,
1464     width,
1465     height,
1466     subtype,
1467     backdrop,
1468     transferMap,
1469     layerOffsetX,
1470     layerOffsetY,
1471     maskOffsetX,
1472     maskOffsetY
1473   ) {
1474     let maskCanvas = maskCtx.canvas;
1475     let maskX = layerOffsetX - maskOffsetX;
1476     let maskY = layerOffsetY - maskOffsetY;
1477 
1478     if (backdrop) {
1479       const backdropRGB = Util.makeHexColor(...backdrop);
1480       if (
1481         maskX < 0 ||
1482         maskY < 0 ||
1483         maskX + width > maskCanvas.width ||
1484         maskY + height > maskCanvas.height
1485       ) {
1486         const canvas = this.cachedCanvases.getCanvas(
1487           "maskExtension",
1488           width,
1489           height
1490         );
1491         const ctx = canvas.context;
1492         ctx.drawImage(maskCanvas, -maskX, -maskY);
1493         ctx.globalCompositeOperation = "destination-atop";
1494         ctx.fillStyle = backdropRGB;
1495         ctx.fillRect(0, 0, width, height);
1496         ctx.globalCompositeOperation = "source-over";
1497 
1498         maskCanvas = canvas.canvas;
1499         maskX = maskY = 0;
1500       } else {
1501         maskCtx.save();
1502         maskCtx.globalAlpha = 1;
1503         maskCtx.setTransform(1, 0, 0, 1, 0, 0);
1504         const clip = new Path2D();
1505         clip.rect(maskX, maskY, width, height);
1506         maskCtx.clip(clip);
1507         maskCtx.globalCompositeOperation = "destination-atop";
1508         maskCtx.fillStyle = backdropRGB;
1509         maskCtx.fillRect(maskX, maskY, width, height);
1510         maskCtx.restore();
1511       }
1512     }
1513 
1514     layerCtx.save();
1515     layerCtx.globalAlpha = 1;
1516     layerCtx.setTransform(1, 0, 0, 1, 0, 0);
1517 
1518     if (subtype === "Alpha" && transferMap) {
1519       layerCtx.filter = this.filterFactory.addAlphaFilter(transferMap);
1520     } else if (subtype === "Luminosity") {
1521       layerCtx.filter = this.filterFactory.addLuminosityFilter(transferMap);
1522     }
1523 
1524     const clip = new Path2D();
1525     clip.rect(layerOffsetX, layerOffsetY, width, height);
1526     layerCtx.clip(clip);
1527     layerCtx.globalCompositeOperation = "destination-in";
1528     layerCtx.drawImage(
1529       maskCanvas,
1530       maskX,
1531       maskY,
1532       width,
1533       height,
1534       layerOffsetX,
1535       layerOffsetY,
1536       width,
1537       height
1538     );
1539     layerCtx.restore();
1540   }
1541 
1542   save() {
1543     if (this.inSMaskMode) {
1544       // SMask mode may be turned on/off causing us to lose graphics state.
1545       // Copy the temporary canvas state to the main(suspended) canvas to keep
1546       // it in sync.
1547       copyCtxState(this.ctx, this.suspendedCtx);
1548     }
1549     this.ctx.save();
1550     const old = this.current;
1551     this.stateStack.push(old);
1552     this.current = old.clone();
1553   }
1554 
1555   restore() {
1556     if (this.stateStack.length === 0) {
1557       if (this.inSMaskMode) {
1558         this.endSMaskMode();
1559       }
1560       return;
1561     }
1562 
1563     this.current = this.stateStack.pop();
1564     this.ctx.restore();
1565     if (this.inSMaskMode) {
1566       // Graphics state is stored on the main(suspended) canvas. Restore its
1567       // state then copy it over to the temporary canvas.
1568       copyCtxState(this.suspendedCtx, this.ctx);
1569     }
1570     this.checkSMaskState();
1571 
1572     // Ensure that the clipping path is reset (fixes issue6413.pdf).
1573     this.pendingClip = null;
1574 
1575     this._cachedScaleForStroking[0] = -1;
1576     this._cachedGetSinglePixelWidth = null;
1577   }
1578 
1579   transform(a, b, c, d, e, f) {
1580     this.ctx.transform(a, b, c, d, e, f);
1581 
1582     this._cachedScaleForStroking[0] = -1;
1583     this._cachedGetSinglePixelWidth = null;
1584   }
1585 
1586   // Path
1587   constructPath(op, data, minMax) {
1588     let [path] = data;
1589     if (!minMax) {
1590       // The path is empty, so no need to update the current minMax.
1591       path ||= data[0] = new Path2D();
1592       this[op](path);
1593       return;
1594     }
1595     if (!(path instanceof Path2D)) {
1596       // Using a SVG string is slightly slower than using the following loop.
1597       const path2d = (data[0] = new Path2D());
1598       for (let i = 0, ii = path.length; i < ii; ) {
1599         switch (path[i++]) {
1600           case DrawOPS.moveTo:
1601             path2d.moveTo(path[i++], path[i++]);
1602             break;
1603           case DrawOPS.lineTo:
1604             path2d.lineTo(path[i++], path[i++]);
1605             break;
1606           case DrawOPS.curveTo:
1607             path2d.bezierCurveTo(
1608               path[i++],
1609               path[i++],
1610               path[i++],
1611               path[i++],
1612               path[i++],
1613               path[i++]
1614             );
1615             break;
1616           case DrawOPS.closePath:
1617             path2d.closePath();
1618             break;
1619           default:
1620             warn(`Unrecognized drawing path operator: ${path[i - 1]}`);
1621             break;
1622         }
1623       }
1624       path = path2d;
1625     }
1626     this.current.updateRectMinMax(getCurrentTransform(this.ctx), minMax);
1627     this[op](path);
1628   }
1629 
1630   closePath() {
1631     this.ctx.closePath();
1632   }
1633 
1634   stroke(path, consumePath = true) {
1635     const ctx = this.ctx;
1636     const strokeColor = this.current.strokeColor;
1637     // For stroke we want to temporarily change the global alpha to the
1638     // stroking alpha.
1639     ctx.globalAlpha = this.current.strokeAlpha;
1640     if (this.contentVisible) {
1641       if (typeof strokeColor === "object" && strokeColor?.getPattern) {
1642         const baseTransform = strokeColor.isModifyingCurrentTransform()
1643           ? ctx.getTransform()
1644           : null;
1645         ctx.save();
1646         ctx.strokeStyle = strokeColor.getPattern(
1647           ctx,
1648           this,
1649           getCurrentTransformInverse(ctx),
1650           PathType.STROKE
1651         );
1652         if (baseTransform) {
1653           const newPath = new Path2D();
1654           newPath.addPath(
1655             path,
1656             ctx.getTransform().invertSelf().multiplySelf(baseTransform)
1657           );
1658           path = newPath;
1659         }
1660         this.rescaleAndStroke(path, /* saveRestore */ false);
1661         ctx.restore();
1662       } else {
1663         this.rescaleAndStroke(path, /* saveRestore */ true);
1664       }
1665     }
1666     if (consumePath) {
1667       this.consumePath(
1668         path,
1669         this.current.getClippedPathBoundingBox(
1670           PathType.STROKE,
1671           getCurrentTransform(this.ctx)
1672         )
1673       );
1674     }
1675     // Restore the global alpha to the fill alpha
1676     ctx.globalAlpha = this.current.fillAlpha;
1677   }
1678 
1679   closeStroke(path) {
1680     this.stroke(path);
1681   }
1682 
1683   fill(path, consumePath = true) {
1684     const ctx = this.ctx;
1685     const fillColor = this.current.fillColor;
1686     const isPatternFill = this.current.patternFill;
1687     let needRestore = false;
1688 
1689     if (isPatternFill) {
1690       const baseTransform = fillColor.isModifyingCurrentTransform()
1691         ? ctx.getTransform()
1692         : null;
1693       ctx.save();
1694       ctx.fillStyle = fillColor.getPattern(
1695         ctx,
1696         this,
1697         getCurrentTransformInverse(ctx),
1698         PathType.FILL
1699       );
1700       if (baseTransform) {
1701         const newPath = new Path2D();
1702         newPath.addPath(
1703           path,
1704           ctx.getTransform().invertSelf().multiplySelf(baseTransform)
1705         );
1706         path = newPath;
1707       }
1708       needRestore = true;
1709     }
1710 
1711     const intersect = this.current.getClippedPathBoundingBox();
1712     if (this.contentVisible && intersect !== null) {
1713       if (this.pendingEOFill) {
1714         ctx.fill(path, "evenodd");
1715         this.pendingEOFill = false;
1716       } else {
1717         ctx.fill(path);
1718       }
1719     }
1720 
1721     if (needRestore) {
1722       ctx.restore();
1723     }
1724     if (consumePath) {
1725       this.consumePath(path, intersect);
1726     }
1727   }
1728 
1729   eoFill(path) {
1730     this.pendingEOFill = true;
1731     this.fill(path);
1732   }
1733 
1734   fillStroke(path) {
1735     this.fill(path, false);
1736     this.stroke(path, false);
1737 
1738     this.consumePath(path);
1739   }
1740 
1741   eoFillStroke(path) {
1742     this.pendingEOFill = true;
1743     this.fillStroke(path);
1744   }
1745 
1746   closeFillStroke(path) {
1747     this.fillStroke(path);
1748   }
1749 
1750   closeEOFillStroke(path) {
1751     this.pendingEOFill = true;
1752     this.fillStroke(path);
1753   }
1754 
1755   endPath(path) {
1756     this.consumePath(path);
1757   }
1758 
1759   // Clipping
1760   clip() {
1761     this.pendingClip = NORMAL_CLIP;
1762   }
1763 
1764   eoClip() {
1765     this.pendingClip = EO_CLIP;
1766   }
1767 
1768   // Text
1769   beginText() {
1770     this.current.textMatrix = IDENTITY_MATRIX;
1771     this.current.textMatrixScale = 1;
1772     this.current.x = this.current.lineX = 0;
1773     this.current.y = this.current.lineY = 0;
1774   }
1775 
1776   endText() {
1777     const paths = this.pendingTextPaths;
1778     const ctx = this.ctx;
1779     if (paths === undefined) {
1780       ctx.beginPath();
1781       return;
1782     }
1783 
1784     const newPath = new Path2D();
1785     const invTransf = ctx.getTransform().invertSelf();
1786     for (const { transform, x, y, fontSize, path } of paths) {
1787       newPath.addPath(
1788         path,
1789         new DOMMatrix(transform)
1790           .preMultiplySelf(invTransf)
1791           .translate(x, y)
1792           .scale(fontSize, -fontSize)
1793       );
1794     }
1795 
1796     ctx.clip(newPath);
1797     ctx.beginPath();
1798     delete this.pendingTextPaths;
1799   }
1800 
1801   setCharSpacing(spacing) {
1802     this.current.charSpacing = spacing;
1803   }
1804 
1805   setWordSpacing(spacing) {
1806     this.current.wordSpacing = spacing;
1807   }
1808 
1809   setHScale(scale) {
1810     this.current.textHScale = scale / 100;
1811   }
1812 
1813   setLeading(leading) {
1814     this.current.leading = -leading;
1815   }
1816 
1817   setFont(fontRefName, size) {
1818     const fontObj = this.commonObjs.get(fontRefName);
1819     const current = this.current;
1820 
1821     if (!fontObj) {
1822       throw new Error(`Can't find font for ${fontRefName}`);
1823     }
1824     current.fontMatrix = fontObj.fontMatrix || FONT_IDENTITY_MATRIX;
1825 
1826     // A valid matrix needs all main diagonal elements to be non-zero
1827     // This also ensures we bypass FF bugzilla bug #719844.
1828     if (current.fontMatrix[0] === 0 || current.fontMatrix[3] === 0) {
1829       warn("Invalid font matrix for font " + fontRefName);
1830     }
1831 
1832     // The spec for Tf (setFont) says that 'size' specifies the font 'scale',
1833     // and in some docs this can be negative (inverted x-y axes).
1834     if (size < 0) {
1835       size = -size;
1836       current.fontDirection = -1;
1837     } else {
1838       current.fontDirection = 1;
1839     }
1840 
1841     this.current.font = fontObj;
1842     this.current.fontSize = size;
1843 
1844     if (fontObj.isType3Font) {
1845       return; // we don't need ctx.font for Type3 fonts
1846     }
1847 
1848     const name = fontObj.loadedName || "sans-serif";
1849     const typeface =
1850       fontObj.systemFontInfo?.css || `"${name}", ${fontObj.fallbackName}`;
1851 
1852     let bold = "normal";
1853     if (fontObj.black) {
1854       bold = "900";
1855     } else if (fontObj.bold) {
1856       bold = "bold";
1857     }
1858     const italic = fontObj.italic ? "italic" : "normal";
1859 
1860     // Some font backends cannot handle fonts below certain size.
1861     // Keeping the font at minimal size and using the fontSizeScale to change
1862     // the current transformation matrix before the fillText/strokeText.
1863     // See https://bugzilla.mozilla.org/show_bug.cgi?id=726227
1864     let browserFontSize = size;
1865     if (size < MIN_FONT_SIZE) {
1866       browserFontSize = MIN_FONT_SIZE;
1867     } else if (size > MAX_FONT_SIZE) {
1868       browserFontSize = MAX_FONT_SIZE;
1869     }
1870     this.current.fontSizeScale = size / browserFontSize;
1871 
1872     this.ctx.font = `${italic} ${bold} ${browserFontSize}px ${typeface}`;
1873   }
1874 
1875   setTextRenderingMode(mode) {
1876     this.current.textRenderingMode = mode;
1877   }
1878 
1879   setTextRise(rise) {
1880     this.current.textRise = rise;
1881   }
1882 
1883   moveText(x, y) {
1884     this.current.x = this.current.lineX += x;
1885     this.current.y = this.current.lineY += y;
1886   }
1887 
1888   setLeadingMoveText(x, y) {
1889     this.setLeading(-y);
1890     this.moveText(x, y);
1891   }
1892 
1893   setTextMatrix(a, b, c, d, e, f) {
1894     this.current.textMatrix = [a, b, c, d, e, f];
1895     this.current.textMatrixScale = Math.hypot(a, b);
1896 
1897     this.current.x = this.current.lineX = 0;
1898     this.current.y = this.current.lineY = 0;
1899   }
1900 
1901   nextLine() {
1902     this.moveText(0, this.current.leading);
1903   }
1904 
1905   #getScaledPath(path, currentTransform, transform) {
1906     const newPath = new Path2D();
1907     newPath.addPath(
1908       path,
1909       new DOMMatrix(transform).invertSelf().multiplySelf(currentTransform)
1910     );
1911     return newPath;
1912   }
1913 
1914   paintChar(character, x, y, patternFillTransform, patternStrokeTransform) {
1915     const ctx = this.ctx;
1916     const current = this.current;
1917     const font = current.font;
1918     const textRenderingMode = current.textRenderingMode;
1919     const fontSize = current.fontSize / current.fontSizeScale;
1920     const fillStrokeMode =
1921       textRenderingMode & TextRenderingMode.FILL_STROKE_MASK;
1922     const isAddToPathSet = !!(
1923       textRenderingMode & TextRenderingMode.ADD_TO_PATH_FLAG
1924     );
1925     const patternFill = current.patternFill && !font.missingFile;
1926     const patternStroke = current.patternStroke && !font.missingFile;
1927 
1928     let path;
1929     if (
1930       font.disableFontFace ||
1931       isAddToPathSet ||
1932       patternFill ||
1933       patternStroke
1934     ) {
1935       path = font.getPathGenerator(this.commonObjs, character);
1936     }
1937 
1938     if (font.disableFontFace || patternFill || patternStroke) {
1939       ctx.save();
1940       ctx.translate(x, y);
1941       ctx.scale(fontSize, -fontSize);
1942       let currentTransform;
1943       if (
1944         fillStrokeMode === TextRenderingMode.FILL ||
1945         fillStrokeMode === TextRenderingMode.FILL_STROKE
1946       ) {
1947         if (patternFillTransform) {
1948           currentTransform = ctx.getTransform();
1949           ctx.setTransform(...patternFillTransform);
1950           ctx.fill(
1951             this.#getScaledPath(path, currentTransform, patternFillTransform)
1952           );
1953         } else {
1954           ctx.fill(path);
1955         }
1956       }
1957       if (
1958         fillStrokeMode === TextRenderingMode.STROKE ||
1959         fillStrokeMode === TextRenderingMode.FILL_STROKE
1960       ) {
1961         if (patternStrokeTransform) {
1962           currentTransform ||= ctx.getTransform();
1963           ctx.setTransform(...patternStrokeTransform);
1964           const { a, b, c, d } = currentTransform;
1965           const invPatternTransform = Util.inverseTransform(
1966             patternStrokeTransform
1967           );
1968           const transf = Util.transform(
1969             [a, b, c, d, 0, 0],
1970             invPatternTransform
1971           );
1972           const [sx, sy] = Util.singularValueDecompose2dScale(transf);
1973 
1974           // Cancel the pattern scaling of the line width.
1975           // If sx and sy are different, unfortunately we can't do anything and
1976           // we'll have a rendering bug.
1977           ctx.lineWidth *= Math.max(sx, sy) / fontSize;
1978           ctx.stroke(
1979             this.#getScaledPath(path, currentTransform, patternStrokeTransform)
1980           );
1981         } else {
1982           ctx.lineWidth /= fontSize;
1983           ctx.stroke(path);
1984         }
1985       }
1986       ctx.restore();
1987     } else {
1988       if (
1989         fillStrokeMode === TextRenderingMode.FILL ||
1990         fillStrokeMode === TextRenderingMode.FILL_STROKE
1991       ) {
1992         ctx.fillText(character, x, y);
1993       }
1994       if (
1995         fillStrokeMode === TextRenderingMode.STROKE ||
1996         fillStrokeMode === TextRenderingMode.FILL_STROKE
1997       ) {
1998         ctx.strokeText(character, x, y);
1999       }
2000     }
2001 
2002     if (isAddToPathSet) {
2003       const paths = (this.pendingTextPaths ||= []);
2004       paths.push({
2005         transform: getCurrentTransform(ctx),
2006         x,
2007         y,
2008         fontSize,
2009         path,
2010       });
2011     }
2012   }
2013 
2014   get isFontSubpixelAAEnabled() {
2015     // Checks if anti-aliasing is enabled when scaled text is painted.
2016     // On Windows GDI scaled fonts looks bad.
2017     const { context: ctx } = this.cachedCanvases.getCanvas(
2018       "isFontSubpixelAAEnabled",
2019       10,
2020       10
2021     );
2022     ctx.scale(1.5, 1);
2023     ctx.fillText("I", 0, 10);
2024     const data = ctx.getImageData(0, 0, 10, 10).data;
2025     let enabled = false;
2026     for (let i = 3; i < data.length; i += 4) {
2027       if (data[i] > 0 && data[i] < 255) {
2028         enabled = true;
2029         break;
2030       }
2031     }
2032     return shadow(this, "isFontSubpixelAAEnabled", enabled);
2033   }
2034 
2035   showText(glyphs) {
2036     const current = this.current;
2037     const font = current.font;
2038     if (font.isType3Font) {
2039       return this.showType3Text(glyphs);
2040     }
2041 
2042     const fontSize = current.fontSize;
2043     if (fontSize === 0) {
2044       return undefined;
2045     }
2046 
2047     const ctx = this.ctx;
2048     const fontSizeScale = current.fontSizeScale;
2049     const charSpacing = current.charSpacing;
2050     const wordSpacing = current.wordSpacing;
2051     const fontDirection = current.fontDirection;
2052     const textHScale = current.textHScale * fontDirection;
2053     const glyphsLength = glyphs.length;
2054     const vertical = font.vertical;
2055     const spacingDir = vertical ? 1 : -1;
2056     const defaultVMetrics = font.defaultVMetrics;
2057     const widthAdvanceScale = fontSize * current.fontMatrix[0];
2058 
2059     const simpleFillText =
2060       current.textRenderingMode === TextRenderingMode.FILL &&
2061       !font.disableFontFace &&
2062       !current.patternFill;
2063 
2064     ctx.save();
2065     ctx.transform(...current.textMatrix);
2066     ctx.translate(current.x, current.y + current.textRise);
2067 
2068     if (fontDirection > 0) {
2069       ctx.scale(textHScale, -1);
2070     } else {
2071       ctx.scale(textHScale, 1);
2072     }
2073 
2074     let patternFillTransform, patternStrokeTransform;
2075     if (current.patternFill) {
2076       ctx.save();
2077       const pattern = current.fillColor.getPattern(
2078         ctx,
2079         this,
2080         getCurrentTransformInverse(ctx),
2081         PathType.FILL
2082       );
2083       patternFillTransform = getCurrentTransform(ctx);
2084       ctx.restore();
2085       ctx.fillStyle = pattern;
2086     }
2087 
2088     if (current.patternStroke) {
2089       ctx.save();
2090       const pattern = current.strokeColor.getPattern(
2091         ctx,
2092         this,
2093         getCurrentTransformInverse(ctx),
2094         PathType.STROKE
2095       );
2096       patternStrokeTransform = getCurrentTransform(ctx);
2097       ctx.restore();
2098       ctx.strokeStyle = pattern;
2099     }
2100 
2101     let lineWidth = current.lineWidth;
2102     const scale = current.textMatrixScale;
2103     if (scale === 0 || lineWidth === 0) {
2104       const fillStrokeMode =
2105         current.textRenderingMode & TextRenderingMode.FILL_STROKE_MASK;
2106       if (
2107         fillStrokeMode === TextRenderingMode.STROKE ||
2108         fillStrokeMode === TextRenderingMode.FILL_STROKE
2109       ) {
2110         lineWidth = this.getSinglePixelWidth();
2111       }
2112     } else {
2113       lineWidth /= scale;
2114     }
2115 
2116     if (fontSizeScale !== 1.0) {
2117       ctx.scale(fontSizeScale, fontSizeScale);
2118       lineWidth /= fontSizeScale;
2119     }
2120 
2121     ctx.lineWidth = lineWidth;
2122 
2123     if (font.isInvalidPDFjsFont) {
2124       const chars = [];
2125       let width = 0;
2126       for (const glyph of glyphs) {
2127         chars.push(glyph.unicode);
2128         width += glyph.width;
2129       }
2130       ctx.fillText(chars.join(""), 0, 0);
2131       current.x += width * widthAdvanceScale * textHScale;
2132       ctx.restore();
2133       this.compose();
2134 
2135       return undefined;
2136     }
2137 
2138     let x = 0,
2139       i;
2140     for (i = 0; i < glyphsLength; ++i) {
2141       const glyph = glyphs[i];
2142       if (typeof glyph === "number") {
2143         x += (spacingDir * glyph * fontSize) / 1000;
2144         continue;
2145       }
2146 
2147       let restoreNeeded = false;
2148       const spacing = (glyph.isSpace ? wordSpacing : 0) + charSpacing;
2149       const character = glyph.fontChar;
2150       const accent = glyph.accent;
2151       let scaledX, scaledY;
2152       let width = glyph.width;
2153       if (vertical) {
2154         const vmetric = glyph.vmetric || defaultVMetrics;
2155         const vx =
2156           -(glyph.vmetric ? vmetric[1] : width * 0.5) * widthAdvanceScale;
2157         const vy = vmetric[2] * widthAdvanceScale;
2158 
2159         width = vmetric ? -vmetric[0] : width;
2160         scaledX = vx / fontSizeScale;
2161         scaledY = (x + vy) / fontSizeScale;
2162       } else {
2163         scaledX = x / fontSizeScale;
2164         scaledY = 0;
2165       }
2166 
2167       if (font.remeasure && width > 0) {
2168         // Some standard fonts may not have the exact width: rescale per
2169         // character if measured width is greater than expected glyph width
2170         // and subpixel-aa is enabled, otherwise just center the glyph.
2171         const measuredWidth =
2172           ((ctx.measureText(character).width * 1000) / fontSize) *
2173           fontSizeScale;
2174         if (width < measuredWidth && this.isFontSubpixelAAEnabled) {
2175           const characterScaleX = width / measuredWidth;
2176           restoreNeeded = true;
2177           ctx.save();
2178           ctx.scale(characterScaleX, 1);
2179           scaledX /= characterScaleX;
2180         } else if (width !== measuredWidth) {
2181           scaledX +=
2182             (((width - measuredWidth) / 2000) * fontSize) / fontSizeScale;
2183         }
2184       }
2185 
2186       // Only attempt to draw the glyph if it is actually in the embedded font
2187       // file or if there isn't a font file so the fallback font is shown.
2188       if (this.contentVisible && (glyph.isInFont || font.missingFile)) {
2189         if (simpleFillText && !accent) {
2190           // common case
2191           ctx.fillText(character, scaledX, scaledY);
2192         } else {
2193           this.paintChar(
2194             character,
2195             scaledX,
2196             scaledY,
2197             patternFillTransform,
2198             patternStrokeTransform
2199           );
2200           if (accent) {
2201             const scaledAccentX =
2202               scaledX + (fontSize * accent.offset.x) / fontSizeScale;
2203             const scaledAccentY =
2204               scaledY - (fontSize * accent.offset.y) / fontSizeScale;
2205             this.paintChar(
2206               accent.fontChar,
2207               scaledAccentX,
2208               scaledAccentY,
2209               patternFillTransform,
2210               patternStrokeTransform
2211             );
2212           }
2213         }
2214       }
2215 
2216       const charWidth = vertical
2217         ? width * widthAdvanceScale - spacing * fontDirection
2218         : width * widthAdvanceScale + spacing * fontDirection;
2219       x += charWidth;
2220 
2221       if (restoreNeeded) {
2222         ctx.restore();
2223       }
2224     }
2225     if (vertical) {
2226       current.y -= x;
2227     } else {
2228       current.x += x * textHScale;
2229     }
2230     ctx.restore();
2231     this.compose();
2232 
2233     return undefined;
2234   }
2235 
2236   showType3Text(glyphs) {
2237     // Type3 fonts - each glyph is a "mini-PDF"
2238     const ctx = this.ctx;
2239     const current = this.current;
2240     const font = current.font;
2241     const fontSize = current.fontSize;
2242     const fontDirection = current.fontDirection;
2243     const spacingDir = font.vertical ? 1 : -1;
2244     const charSpacing = current.charSpacing;
2245     const wordSpacing = current.wordSpacing;
2246     const textHScale = current.textHScale * fontDirection;
2247     const fontMatrix = current.fontMatrix || FONT_IDENTITY_MATRIX;
2248     const glyphsLength = glyphs.length;
2249     const isTextInvisible =
2250       current.textRenderingMode === TextRenderingMode.INVISIBLE;
2251     let i, glyph, width, spacingLength;
2252 
2253     if (isTextInvisible || fontSize === 0) {
2254       return;
2255     }
2256     this._cachedScaleForStroking[0] = -1;
2257     this._cachedGetSinglePixelWidth = null;
2258 
2259     ctx.save();
2260     ctx.transform(...current.textMatrix);
2261     ctx.translate(current.x, current.y + current.textRise);
2262 
2263     ctx.scale(textHScale, fontDirection);
2264 
2265     for (i = 0; i < glyphsLength; ++i) {
2266       glyph = glyphs[i];
2267       if (typeof glyph === "number") {
2268         spacingLength = (spacingDir * glyph * fontSize) / 1000;
2269         this.ctx.translate(spacingLength, 0);
2270         current.x += spacingLength * textHScale;
2271         continue;
2272       }
2273 
2274       const spacing = (glyph.isSpace ? wordSpacing : 0) + charSpacing;
2275       const operatorList = font.charProcOperatorList[glyph.operatorListId];
2276       if (!operatorList) {
2277         warn(`Type3 character "${glyph.operatorListId}" is not available.`);
2278         continue;
2279       }
2280       if (this.contentVisible) {
2281         this.processingType3 = glyph;
2282         this.save();
2283         ctx.scale(fontSize, fontSize);
2284         ctx.transform(...fontMatrix);
2285         this.executeOperatorList(operatorList);
2286         this.restore();
2287       }
2288 
2289       const transformed = Util.applyTransform([glyph.width, 0], fontMatrix);
2290       width = transformed[0] * fontSize + spacing;
2291 
2292       ctx.translate(width, 0);
2293       current.x += width * textHScale;
2294     }
2295     ctx.restore();
2296     this.processingType3 = null;
2297   }
2298 
2299   // Type3 fonts
2300   setCharWidth(xWidth, yWidth) {
2301     // We can safely ignore this since the width should be the same
2302     // as the width in the Widths array.
2303   }
2304 
2305   setCharWidthAndBounds(xWidth, yWidth, llx, lly, urx, ury) {
2306     this.ctx.rect(llx, lly, urx - llx, ury - lly);
2307     this.ctx.clip();
2308     this.endPath();
2309   }
2310 
2311   // Color
2312   getColorN_Pattern(IR) {
2313     let pattern;
2314     if (IR[0] === "TilingPattern") {
2315       const color = IR[1];
2316       const baseTransform = this.baseTransform || getCurrentTransform(this.ctx);
2317       const canvasGraphicsFactory = {
2318         createCanvasGraphics: ctx =>
2319           new CanvasGraphics(
2320             ctx,
2321             this.commonObjs,
2322             this.objs,
2323             this.canvasFactory,
2324             this.filterFactory,
2325             {
2326               optionalContentConfig: this.optionalContentConfig,
2327               markedContentStack: this.markedContentStack,
2328             }
2329           ),
2330       };
2331       pattern = new TilingPattern(
2332         IR,
2333         color,
2334         this.ctx,
2335         canvasGraphicsFactory,
2336         baseTransform
2337       );
2338     } else {
2339       pattern = this._getPattern(IR[1], IR[2]);
2340     }
2341     return pattern;
2342   }
2343 
2344   setStrokeColorN() {
2345     this.current.strokeColor = this.getColorN_Pattern(arguments);
2346     this.current.patternStroke = true;
2347   }
2348 
2349   setFillColorN() {
2350     this.current.fillColor = this.getColorN_Pattern(arguments);
2351     this.current.patternFill = true;
2352   }
2353 
2354   setStrokeRGBColor(r, g, b) {
2355     this.ctx.strokeStyle = this.current.strokeColor = Util.makeHexColor(
2356       r,
2357       g,
2358       b
2359     );
2360     this.current.patternStroke = false;
2361   }
2362 
2363   setStrokeTransparent() {
2364     this.ctx.strokeStyle = this.current.strokeColor = "transparent";
2365     this.current.patternStroke = false;
2366   }
2367 
2368   setFillRGBColor(r, g, b) {
2369     this.ctx.fillStyle = this.current.fillColor = Util.makeHexColor(r, g, b);
2370     this.current.patternFill = false;
2371   }
2372 
2373   setFillTransparent() {
2374     this.ctx.fillStyle = this.current.fillColor = "transparent";
2375     this.current.patternFill = false;
2376   }
2377 
2378   _getPattern(objId, matrix = null) {
2379     let pattern;
2380     if (this.cachedPatterns.has(objId)) {
2381       pattern = this.cachedPatterns.get(objId);
2382     } else {
2383       pattern = getShadingPattern(this.getObject(objId));
2384       this.cachedPatterns.set(objId, pattern);
2385     }
2386     if (matrix) {
2387       pattern.matrix = matrix;
2388     }
2389     return pattern;
2390   }
2391 
2392   shadingFill(objId) {
2393     if (!this.contentVisible) {
2394       return;
2395     }
2396     const ctx = this.ctx;
2397 
2398     this.save();
2399     const pattern = this._getPattern(objId);
2400     ctx.fillStyle = pattern.getPattern(
2401       ctx,
2402       this,
2403       getCurrentTransformInverse(ctx),
2404       PathType.SHADING
2405     );
2406 
2407     const inv = getCurrentTransformInverse(ctx);
2408     if (inv) {
2409       const { width, height } = ctx.canvas;
2410       const [x0, y0, x1, y1] = Util.getAxialAlignedBoundingBox(
2411         [0, 0, width, height],
2412         inv
2413       );
2414 
2415       this.ctx.fillRect(x0, y0, x1 - x0, y1 - y0);
2416     } else {
2417       // HACK to draw the gradient onto an infinite rectangle.
2418       // PDF gradients are drawn across the entire image while
2419       // Canvas only allows gradients to be drawn in a rectangle
2420       // The following bug should allow us to remove this.
2421       // https://bugzilla.mozilla.org/show_bug.cgi?id=664884
2422 
2423       this.ctx.fillRect(-1e10, -1e10, 2e10, 2e10);
2424     }
2425 
2426     this.compose(this.current.getClippedPathBoundingBox());
2427     this.restore();
2428   }
2429 
2430   // Images
2431   beginInlineImage() {
2432     unreachable("Should not call beginInlineImage");
2433   }
2434 
2435   beginImageData() {
2436     unreachable("Should not call beginImageData");
2437   }
2438 
2439   paintFormXObjectBegin(matrix, bbox) {
2440     if (!this.contentVisible) {
2441       return;
2442     }
2443     this.save();
2444     this.baseTransformStack.push(this.baseTransform);
2445 
2446     if (matrix) {
2447       this.transform(...matrix);
2448     }
2449     this.baseTransform = getCurrentTransform(this.ctx);
2450 
2451     if (bbox) {
2452       const width = bbox[2] - bbox[0];
2453       const height = bbox[3] - bbox[1];
2454       this.ctx.rect(bbox[0], bbox[1], width, height);
2455       this.current.updateRectMinMax(getCurrentTransform(this.ctx), bbox);
2456       this.clip();
2457       this.endPath();
2458     }
2459   }
2460 
2461   paintFormXObjectEnd() {
2462     if (!this.contentVisible) {
2463       return;
2464     }
2465     this.restore();
2466     this.baseTransform = this.baseTransformStack.pop();
2467   }
2468 
2469   beginGroup(group) {
2470     if (!this.contentVisible) {
2471       return;
2472     }
2473 
2474     this.save();
2475     // If there's an active soft mask we don't want it enabled for the group, so
2476     // clear it out. The mask and suspended canvas will be restored in endGroup.
2477     if (this.inSMaskMode) {
2478       this.endSMaskMode();
2479       this.current.activeSMask = null;
2480     }
2481 
2482     const currentCtx = this.ctx;
2483     // TODO non-isolated groups - according to Rik at adobe non-isolated
2484     // group results aren't usually that different and they even have tools
2485     // that ignore this setting. Notes from Rik on implementing:
2486     // - When you encounter an transparency group, create a new canvas with
2487     // the dimensions of the bbox
2488     // - copy the content from the previous canvas to the new canvas
2489     // - draw as usual
2490     // - remove the backdrop alpha:
2491     // alphaNew = 1 - (1 - alpha)/(1 - alphaBackdrop) with 'alpha' the alpha
2492     // value of your transparency group and 'alphaBackdrop' the alpha of the
2493     // backdrop
2494     // - remove background color:
2495     // colorNew = color - alphaNew *colorBackdrop /(1 - alphaNew)
2496     if (!group.isolated) {
2497       info("TODO: Support non-isolated groups.");
2498     }
2499 
2500     // TODO knockout - supposedly possible with the clever use of compositing
2501     // modes.
2502     if (group.knockout) {
2503       warn("Knockout groups not supported.");
2504     }
2505 
2506     const currentTransform = getCurrentTransform(currentCtx);
2507     if (group.matrix) {
2508       currentCtx.transform(...group.matrix);
2509     }
2510     if (!group.bbox) {
2511       throw new Error("Bounding box is required.");
2512     }
2513 
2514     // Based on the current transform figure out how big the bounding box
2515     // will actually be.
2516     let bounds = Util.getAxialAlignedBoundingBox(
2517       group.bbox,
2518       getCurrentTransform(currentCtx)
2519     );
2520     // Clip the bounding box to the current canvas.
2521     const canvasBounds = [
2522       0,
2523       0,
2524       currentCtx.canvas.width,
2525       currentCtx.canvas.height,
2526     ];
2527     bounds = Util.intersect(bounds, canvasBounds) || [0, 0, 0, 0];
2528     // Use ceil in case we're between sizes so we don't create canvas that is
2529     // too small and make the canvas at least 1x1 pixels.
2530     const offsetX = Math.floor(bounds[0]);
2531     const offsetY = Math.floor(bounds[1]);
2532     const drawnWidth = Math.max(Math.ceil(bounds[2]) - offsetX, 1);
2533     const drawnHeight = Math.max(Math.ceil(bounds[3]) - offsetY, 1);
2534 
2535     this.current.startNewPathAndClipBox([0, 0, drawnWidth, drawnHeight]);
2536 
2537     let cacheId = "groupAt" + this.groupLevel;
2538     if (group.smask) {
2539       // Using two cache entries is case if masks are used one after another.
2540       cacheId += "_smask_" + (this.smaskCounter++ % 2);
2541     }
2542     const scratchCanvas = this.cachedCanvases.getCanvas(
2543       cacheId,
2544       drawnWidth,
2545       drawnHeight
2546     );
2547     const groupCtx = scratchCanvas.context;
2548 
2549     // Since we created a new canvas that is just the size of the bounding box
2550     // we have to translate the group ctx.
2551     groupCtx.translate(-offsetX, -offsetY);
2552     groupCtx.transform(...currentTransform);
2553 
2554     // Apply the bbox to the group context.
2555     let clip = new Path2D();
2556     const [x0, y0, x1, y1] = group.bbox;
2557     clip.rect(x0, y0, x1 - x0, y1 - y0);
2558     if (group.matrix) {
2559       const path = new Path2D();
2560       path.addPath(clip, new DOMMatrix(group.matrix));
2561       clip = path;
2562     }
2563     groupCtx.clip(clip);
2564 
2565     if (group.smask) {
2566       // Saving state and cached mask to be used in setGState.
2567       this.smaskStack.push({
2568         canvas: scratchCanvas.canvas,
2569         context: groupCtx,
2570         offsetX,
2571         offsetY,
2572         subtype: group.smask.subtype,
2573         backdrop: group.smask.backdrop,
2574         transferMap: group.smask.transferMap || null,
2575         startTransformInverse: null, // used during suspend operation
2576       });
2577     } else {
2578       // Setup the current ctx so when the group is popped we draw it at the
2579       // right location.
2580       currentCtx.setTransform(1, 0, 0, 1, 0, 0);
2581       currentCtx.translate(offsetX, offsetY);
2582       currentCtx.save();
2583     }
2584     // The transparency group inherits all off the current graphics state
2585     // except the blend mode, soft mask, and alpha constants.
2586     copyCtxState(currentCtx, groupCtx);
2587     this.ctx = groupCtx;
2588     this.setGState([
2589       ["BM", "source-over"],
2590       ["ca", 1],
2591       ["CA", 1],
2592     ]);
2593     this.groupStack.push(currentCtx);
2594     this.groupLevel++;
2595   }
2596 
2597   endGroup(group) {
2598     if (!this.contentVisible) {
2599       return;
2600     }
2601     this.groupLevel--;
2602     const groupCtx = this.ctx;
2603     const ctx = this.groupStack.pop();
2604     this.ctx = ctx;
2605     // Turn off image smoothing to avoid sub pixel interpolation which can
2606     // look kind of blurry for some pdfs.
2607     this.ctx.imageSmoothingEnabled = false;
2608 
2609     if (group.smask) {
2610       this.tempSMask = this.smaskStack.pop();
2611       this.restore();
2612     } else {
2613       this.ctx.restore();
2614       const currentMtx = getCurrentTransform(this.ctx);
2615       this.restore();
2616       this.ctx.save();
2617       this.ctx.setTransform(...currentMtx);
2618       const dirtyBox = Util.getAxialAlignedBoundingBox(
2619         [0, 0, groupCtx.canvas.width, groupCtx.canvas.height],
2620         currentMtx
2621       );
2622       this.ctx.drawImage(groupCtx.canvas, 0, 0);
2623       this.ctx.restore();
2624       this.compose(dirtyBox);
2625     }
2626   }
2627 
2628   beginAnnotation(id, rect, transform, matrix, hasOwnCanvas) {
2629     // The annotations are drawn just after the page content.
2630     // The page content drawing can potentially have set a transform,
2631     // a clipping path, whatever...
2632     // So in order to have something clean, we restore the initial state.
2633     this.#restoreInitialState();
2634     resetCtxToDefault(this.ctx);
2635 
2636     this.ctx.save();
2637     this.save();
2638 
2639     if (this.baseTransform) {
2640       this.ctx.setTransform(...this.baseTransform);
2641     }
2642 
2643     if (rect) {
2644       const width = rect[2] - rect[0];
2645       const height = rect[3] - rect[1];
2646 
2647       if (hasOwnCanvas && this.annotationCanvasMap) {
2648         transform = transform.slice();
2649         transform[4] -= rect[0];
2650         transform[5] -= rect[1];
2651 
2652         rect = rect.slice();
2653         rect[0] = rect[1] = 0;
2654         rect[2] = width;
2655         rect[3] = height;
2656 
2657         const [scaleX, scaleY] = Util.singularValueDecompose2dScale(
2658           getCurrentTransform(this.ctx)
2659         );
2660         const { viewportScale } = this;
2661         const canvasWidth = Math.ceil(
2662           width * this.outputScaleX * viewportScale
2663         );
2664         const canvasHeight = Math.ceil(
2665           height * this.outputScaleY * viewportScale
2666         );
2667 
2668         this.annotationCanvas = this.canvasFactory.create(
2669           canvasWidth,
2670           canvasHeight
2671         );
2672         const { canvas, context } = this.annotationCanvas;
2673         this.annotationCanvasMap.set(id, canvas);
2674         this.annotationCanvas.savedCtx = this.ctx;
2675         this.ctx = context;
2676         this.ctx.save();
2677         this.ctx.setTransform(scaleX, 0, 0, -scaleY, 0, height * scaleY);
2678 
2679         resetCtxToDefault(this.ctx);
2680       } else {
2681         resetCtxToDefault(this.ctx);
2682 
2683         // Consume a potential path before clipping.
2684         this.endPath();
2685 
2686         this.ctx.rect(rect[0], rect[1], width, height);
2687         this.ctx.clip();
2688         this.ctx.beginPath();
2689       }
2690     }
2691 
2692     this.current = new CanvasExtraState(
2693       this.ctx.canvas.width,
2694       this.ctx.canvas.height
2695     );
2696 
2697     this.transform(...transform);
2698     this.transform(...matrix);
2699   }
2700 
2701   endAnnotation() {
2702     if (this.annotationCanvas) {
2703       this.ctx.restore();
2704       this.#drawFilter();
2705 
2706       this.ctx = this.annotationCanvas.savedCtx;
2707       delete this.annotationCanvas.savedCtx;
2708       delete this.annotationCanvas;
2709     }
2710   }
2711 
2712   paintImageMaskXObject(img) {
2713     if (!this.contentVisible) {
2714       return;
2715     }
2716     const count = img.count;
2717     img = this.getObject(img.data, img);
2718     img.count = count;
2719 
2720     const ctx = this.ctx;
2721     const glyph = this.processingType3;
2722 
2723     if (glyph) {
2724       if (glyph.compiled === undefined) {
2725         glyph.compiled = compileType3Glyph(img);
2726       }
2727 
2728       if (glyph.compiled) {
2729         glyph.compiled(ctx);
2730         return;
2731       }
2732     }
2733     const mask = this._createMaskCanvas(img);
2734     const maskCanvas = mask.canvas;
2735 
2736     ctx.save();
2737     // The mask is drawn with the transform applied. Reset the current
2738     // transform to draw to the identity.
2739     ctx.setTransform(1, 0, 0, 1, 0, 0);
2740     ctx.drawImage(maskCanvas, mask.offsetX, mask.offsetY);
2741     ctx.restore();
2742     this.compose();
2743   }
2744 
2745   paintImageMaskXObjectRepeat(
2746     img,
2747     scaleX,
2748     skewX = 0,
2749     skewY = 0,
2750     scaleY,
2751     positions
2752   ) {
2753     if (!this.contentVisible) {
2754       return;
2755     }
2756 
2757     img = this.getObject(img.data, img);
2758 
2759     const ctx = this.ctx;
2760     ctx.save();
2761     const currentTransform = getCurrentTransform(ctx);
2762     ctx.transform(scaleX, skewX, skewY, scaleY, 0, 0);
2763     const mask = this._createMaskCanvas(img);
2764 
2765     ctx.setTransform(
2766       1,
2767       0,
2768       0,
2769       1,
2770       mask.offsetX - currentTransform[4],
2771       mask.offsetY - currentTransform[5]
2772     );
2773     for (let i = 0, ii = positions.length; i < ii; i += 2) {
2774       const trans = Util.transform(currentTransform, [
2775         scaleX,
2776         skewX,
2777         skewY,
2778         scaleY,
2779         positions[i],
2780         positions[i + 1],
2781       ]);
2782 
2783       const [x, y] = Util.applyTransform([0, 0], trans);
2784       ctx.drawImage(mask.canvas, x, y);
2785     }
2786     ctx.restore();
2787     this.compose();
2788   }
2789 
2790   paintImageMaskXObjectGroup(images) {
2791     if (!this.contentVisible) {
2792       return;
2793     }
2794     const ctx = this.ctx;
2795 
2796     const fillColor = this.current.fillColor;
2797     const isPatternFill = this.current.patternFill;
2798 
2799     for (const image of images) {
2800       const { data, width, height, transform } = image;
2801 
2802       const maskCanvas = this.cachedCanvases.getCanvas(
2803         "maskCanvas",
2804         width,
2805         height
2806       );
2807       const maskCtx = maskCanvas.context;
2808       maskCtx.save();
2809 
2810       const img = this.getObject(data, image);
2811       putBinaryImageMask(maskCtx, img);
2812 
2813       maskCtx.globalCompositeOperation = "source-in";
2814 
2815       maskCtx.fillStyle = isPatternFill
2816         ? fillColor.getPattern(
2817             maskCtx,
2818             this,
2819             getCurrentTransformInverse(ctx),
2820             PathType.FILL
2821           )
2822         : fillColor;
2823       maskCtx.fillRect(0, 0, width, height);
2824 
2825       maskCtx.restore();
2826 
2827       ctx.save();
2828       ctx.transform(...transform);
2829       ctx.scale(1, -1);
2830       drawImageAtIntegerCoords(
2831         ctx,
2832         maskCanvas.canvas,
2833         0,
2834         0,
2835         width,
2836         height,
2837         0,
2838         -1,
2839         1,
2840         1
2841       );
2842       ctx.restore();
2843     }
2844     this.compose();
2845   }
2846 
2847   paintImageXObject(objId) {
2848     if (!this.contentVisible) {
2849       return;
2850     }
2851     const imgData = this.getObject(objId);
2852     if (!imgData) {
2853       warn("Dependent image isn't ready yet");
2854       return;
2855     }
2856 
2857     this.paintInlineImageXObject(imgData);
2858   }
2859 
2860   paintImageXObjectRepeat(objId, scaleX, scaleY, positions) {
2861     if (!this.contentVisible) {
2862       return;
2863     }
2864     const imgData = this.getObject(objId);
2865     if (!imgData) {
2866       warn("Dependent image isn't ready yet");
2867       return;
2868     }
2869 
2870     const width = imgData.width;
2871     const height = imgData.height;
2872     const map = [];
2873     for (let i = 0, ii = positions.length; i < ii; i += 2) {
2874       map.push({
2875         transform: [scaleX, 0, 0, scaleY, positions[i], positions[i + 1]],
2876         x: 0,
2877         y: 0,
2878         w: width,
2879         h: height,
2880       });
2881     }
2882     this.paintInlineImageXObjectGroup(imgData, map);
2883   }
2884 
2885   applyTransferMapsToCanvas(ctx) {
2886     if (this.current.transferMaps !== "none") {
2887       ctx.filter = this.current.transferMaps;
2888       ctx.drawImage(ctx.canvas, 0, 0);
2889       ctx.filter = "none";
2890     }
2891     return ctx.canvas;
2892   }
2893 
2894   applyTransferMapsToBitmap(imgData) {
2895     if (this.current.transferMaps === "none") {
2896       return imgData.bitmap;
2897     }
2898     const { bitmap, width, height } = imgData;
2899     const tmpCanvas = this.cachedCanvases.getCanvas(
2900       "inlineImage",
2901       width,
2902       height
2903     );
2904     const tmpCtx = tmpCanvas.context;
2905     tmpCtx.filter = this.current.transferMaps;
2906     tmpCtx.drawImage(bitmap, 0, 0);
2907     tmpCtx.filter = "none";
2908 
2909     return tmpCanvas.canvas;
2910   }
2911 
2912   paintInlineImageXObject(imgData) {
2913     if (!this.contentVisible) {
2914       return;
2915     }
2916     const width = imgData.width;
2917     const height = imgData.height;
2918     const ctx = this.ctx;
2919 
2920     this.save();
2921 
2922     if (
2923       (typeof PDFJSDev !== "undefined" && PDFJSDev.test("MOZCENTRAL")) ||
2924       !isNodeJS
2925     ) {
2926       // The filter, if any, will be applied in applyTransferMapsToBitmap.
2927       // It must be applied to the image before rescaling else some artifacts
2928       // could appear.
2929       // The final restore will reset it to its value.
2930       const { filter } = ctx;
2931       if (filter !== "none" && filter !== "") {
2932         ctx.filter = "none";
2933       }
2934     }
2935 
2936     // scale the image to the unit square
2937     ctx.scale(1 / width, -1 / height);
2938 
2939     let imgToPaint;
2940     if (imgData.bitmap) {
2941       imgToPaint = this.applyTransferMapsToBitmap(imgData);
2942     } else if (
2943       (typeof HTMLElement === "function" && imgData instanceof HTMLElement) ||
2944       !imgData.data
2945     ) {
2946       // typeof check is needed due to node.js support, see issue #8489
2947       imgToPaint = imgData;
2948     } else {
2949       const tmpCanvas = this.cachedCanvases.getCanvas(
2950         "inlineImage",
2951         width,
2952         height
2953       );
2954       const tmpCtx = tmpCanvas.context;
2955       putBinaryImageData(tmpCtx, imgData);
2956       imgToPaint = this.applyTransferMapsToCanvas(tmpCtx);
2957     }
2958 
2959     const scaled = this._scaleImage(
2960       imgToPaint,
2961       getCurrentTransformInverse(ctx)
2962     );
2963     ctx.imageSmoothingEnabled = getImageSmoothingEnabled(
2964       getCurrentTransform(ctx),
2965       imgData.interpolate
2966     );
2967 
2968     drawImageAtIntegerCoords(
2969       ctx,
2970       scaled.img,
2971       0,
2972       0,
2973       scaled.paintWidth,
2974       scaled.paintHeight,
2975       0,
2976       -height,
2977       width,
2978       height
2979     );
2980     this.compose();
2981     this.restore();
2982   }
2983 
2984   paintInlineImageXObjectGroup(imgData, map) {
2985     if (!this.contentVisible) {
2986       return;
2987     }
2988     const ctx = this.ctx;
2989     let imgToPaint;
2990     if (imgData.bitmap) {
2991       imgToPaint = imgData.bitmap;
2992     } else {
2993       const w = imgData.width;
2994       const h = imgData.height;
2995 
2996       const tmpCanvas = this.cachedCanvases.getCanvas("inlineImage", w, h);
2997       const tmpCtx = tmpCanvas.context;
2998       putBinaryImageData(tmpCtx, imgData);
2999       imgToPaint = this.applyTransferMapsToCanvas(tmpCtx);
3000     }
3001 
3002     for (const entry of map) {
3003       ctx.save();
3004       ctx.transform(...entry.transform);
3005       ctx.scale(1, -1);
3006       drawImageAtIntegerCoords(
3007         ctx,
3008         imgToPaint,
3009         entry.x,
3010         entry.y,
3011         entry.w,
3012         entry.h,
3013         0,
3014         -1,
3015         1,
3016         1
3017       );
3018       ctx.restore();
3019     }
3020     this.compose();
3021   }
3022 
3023   paintSolidColorImageMask() {
3024     if (!this.contentVisible) {
3025       return;
3026     }
3027     this.ctx.fillRect(0, 0, 1, 1);
3028     this.compose();
3029   }
3030 
3031   // Marked content
3032 
3033   markPoint(tag) {
3034     // TODO Marked content.
3035   }
3036 
3037   markPointProps(tag, properties) {
3038     // TODO Marked content.
3039   }
3040 
3041   beginMarkedContent(tag) {
3042     this.markedContentStack.push({
3043       visible: true,
3044     });
3045   }
3046 
3047   beginMarkedContentProps(tag, properties) {
3048     if (tag === "OC") {
3049       this.markedContentStack.push({
3050         visible: this.optionalContentConfig.isVisible(properties),
3051       });
3052     } else {
3053       this.markedContentStack.push({
3054         visible: true,
3055       });
3056     }
3057     this.contentVisible = this.isContentVisible();
3058   }
3059 
3060   endMarkedContent() {
3061     this.markedContentStack.pop();
3062     this.contentVisible = this.isContentVisible();
3063   }
3064 
3065   // Compatibility
3066 
3067   beginCompat() {
3068     // TODO ignore undefined operators (should we do that anyway?)
3069   }
3070 
3071   endCompat() {
3072     // TODO stop ignoring undefined operators
3073   }
3074 
3075   // Helper functions
3076 
3077   consumePath(path, clipBox) {
3078     const isEmpty = this.current.isEmptyClip();
3079     if (this.pendingClip) {
3080       this.current.updateClipFromPath();
3081     }
3082     if (!this.pendingClip) {
3083       this.compose(clipBox);
3084     }
3085     const ctx = this.ctx;
3086     if (this.pendingClip) {
3087       if (!isEmpty) {
3088         if (this.pendingClip === EO_CLIP) {
3089           ctx.clip(path, "evenodd");
3090         } else {
3091           ctx.clip(path);
3092         }
3093       }
3094       this.pendingClip = null;
3095     }
3096     this.current.startNewPathAndClipBox(this.current.clipBox);
3097     ctx.beginPath();
3098   }
3099 
3100   getSinglePixelWidth() {
3101     if (!this._cachedGetSinglePixelWidth) {
3102       const m = getCurrentTransform(this.ctx);
3103       if (m[1] === 0 && m[2] === 0) {
3104         // Fast path
3105         this._cachedGetSinglePixelWidth =
3106           1 / Math.min(Math.abs(m[0]), Math.abs(m[3]));
3107       } else {
3108         const absDet = Math.abs(m[0] * m[3] - m[2] * m[1]);
3109         const normX = Math.hypot(m[0], m[2]);
3110         const normY = Math.hypot(m[1], m[3]);
3111         this._cachedGetSinglePixelWidth = Math.max(normX, normY) / absDet;
3112       }
3113     }
3114     return this._cachedGetSinglePixelWidth;
3115   }
3116 
3117   getScaleForStroking() {
3118     // A pixel has thicknessX = thicknessY = 1;
3119     // A transformed pixel is a parallelogram and the thicknesses
3120     // corresponds to the heights.
3121     // The goal of this function is to rescale before setting the
3122     // lineWidth in order to have both thicknesses greater or equal
3123     // to 1 after transform.
3124     if (this._cachedScaleForStroking[0] === -1) {
3125       const { lineWidth } = this.current;
3126       const { a, b, c, d } = this.ctx.getTransform();
3127       let scaleX, scaleY;
3128 
3129       if (b === 0 && c === 0) {
3130         // Fast path
3131         const normX = Math.abs(a);
3132         const normY = Math.abs(d);
3133         if (normX === normY) {
3134           if (lineWidth === 0) {
3135             scaleX = scaleY = 1 / normX;
3136           } else {
3137             const scaledLineWidth = normX * lineWidth;
3138             scaleX = scaleY = scaledLineWidth < 1 ? 1 / scaledLineWidth : 1;
3139           }
3140         } else if (lineWidth === 0) {
3141           scaleX = 1 / normX;
3142           scaleY = 1 / normY;
3143         } else {
3144           const scaledXLineWidth = normX * lineWidth;
3145           const scaledYLineWidth = normY * lineWidth;
3146           scaleX = scaledXLineWidth < 1 ? 1 / scaledXLineWidth : 1;
3147           scaleY = scaledYLineWidth < 1 ? 1 / scaledYLineWidth : 1;
3148         }
3149       } else {
3150         // A pixel (base (x, y)) is transformed by M into a parallelogram:
3151         //  - its area is |det(M)|;
3152         //  - heightY (orthogonal to Mx) has a length: |det(M)| / norm(Mx);
3153         //  - heightX (orthogonal to My) has a length: |det(M)| / norm(My).
3154         // heightX and heightY are the thicknesses of the transformed pixel
3155         // and they must be both greater or equal to 1.
3156         const absDet = Math.abs(a * d - b * c);
3157         const normX = Math.hypot(a, b);
3158         const normY = Math.hypot(c, d);
3159         if (lineWidth === 0) {
3160           scaleX = normY / absDet;
3161           scaleY = normX / absDet;
3162         } else {
3163           const baseArea = lineWidth * absDet;
3164           scaleX = normY > baseArea ? normY / baseArea : 1;
3165           scaleY = normX > baseArea ? normX / baseArea : 1;
3166         }
3167       }
3168       this._cachedScaleForStroking[0] = scaleX;
3169       this._cachedScaleForStroking[1] = scaleY;
3170     }
3171     return this._cachedScaleForStroking;
3172   }
3173 
3174   // Rescale before stroking in order to have a final lineWidth
3175   // with both thicknesses greater or equal to 1.
3176   rescaleAndStroke(path, saveRestore) {
3177     const {
3178       ctx,
3179       current: { lineWidth },
3180     } = this;
3181     const [scaleX, scaleY] = this.getScaleForStroking();
3182 
3183     if (scaleX === scaleY) {
3184       ctx.lineWidth = (lineWidth || 1) * scaleX;
3185       ctx.stroke(path);
3186       return;
3187     }
3188 
3189     const dashes = ctx.getLineDash();
3190     if (saveRestore) {
3191       ctx.save();
3192     }
3193 
3194     ctx.scale(scaleX, scaleY);
3195     SCALE_MATRIX.a = 1 / scaleX;
3196     SCALE_MATRIX.d = 1 / scaleY;
3197     const newPath = new Path2D();
3198     newPath.addPath(path, SCALE_MATRIX);
3199 
3200     // How the dashed line is rendered depends on the current transform...
3201     // so we added a rescale to handle too thin lines and consequently
3202     // the way the line is dashed will be modified.
3203     // If scaleX === scaleY, the dashed lines will be rendered correctly
3204     // else we'll have some bugs (but only with too thin lines).
3205     // Here we take the max... why not taking the min... or something else.
3206     // Anyway, as said it's buggy when scaleX !== scaleY.
3207     if (dashes.length > 0) {
3208       const scale = Math.max(scaleX, scaleY);
3209       ctx.setLineDash(dashes.map(x => x / scale));
3210       ctx.lineDashOffset /= scale;
3211     }
3212 
3213     ctx.lineWidth = lineWidth || 1;
3214     ctx.stroke(newPath);
3215 
3216     if (saveRestore) {
3217       ctx.restore();
3218     }
3219   }
3220 
3221   isContentVisible() {
3222     for (let i = this.markedContentStack.length - 1; i >= 0; i--) {
3223       if (!this.markedContentStack[i].visible) {
3224         return false;
3225       }
3226     }
3227     return true;
3228   }
3229 }
3230 
3231 for (const op in OPS) {
3232   if (CanvasGraphics.prototype[op] !== undefined) {
3233     CanvasGraphics.prototype[OPS[op]] = CanvasGraphics.prototype[op];
3234   }
3235 }
3236 
3237 export { CanvasGraphics };
</code>

Test file:
<test_file>
File:
test/unit/annotation_spec.js
/* Copyright 2017 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import {
  Annotation,
  AnnotationBorderStyle,
  AnnotationFactory,
  getQuadPoints,
  MarkupAnnotation,
} from "../../src/core/annotation.js";
import {
  AnnotationBorderStyleType,
  AnnotationEditorType,
  AnnotationFieldFlag,
  AnnotationFlag,
  AnnotationType,
  DrawOPS,
  OPS,
  RenderingIntentFlag,
  stringToBytes,
  stringToUTF8String,
} from "../../src/shared/util.js";
import {
  CMAP_URL,
  createIdFactory,
  DefaultCMapReaderFactory,
  DefaultStandardFontDataFactory,
  STANDARD_FONT_DATA_URL,
  XRefMock,
} from "./test_utils.js";
import { Dict, Name, Ref, RefSetCache } from "../../src/core/primitives.js";
import { Lexer, Parser } from "../../src/core/parser.js";
import { FlateStream } from "../../src/core/flate_stream.js";
import { PartialEvaluator } from "../../src/core/evaluator.js";
import { StringStream } from "../../src/core/stream.js";
import { WorkerTask } from "../../src/core/worker.js";
import { writeChanges } from "../../src/core/writer.js";
</test_file>

Your task:
You are a software tester at pdf.js.
1. Examine the existing test file. You may reuse any imports, helpers or setup blocks it already has.
2. Write exactly one javascript test `it("...", async () => {...})` block.
3. Your test must fail on the code before the patch, and pass after, hence the test will verify that the patch resolves the issue.
4. The test must be self-contained and to-the-point.
5. If you need something new use only the provided imports (respect the paths exactly how they are given) by importing dynamically for compatibility with Node.js — no new dependencies. 
6. Return only the javascript code for the new `it(...)` block (no comments or explanations).

Example structure:
it("should <describe behavior>", async () => {
  const { example } = await import("../../src/core/example.js");
  <initialize required variables>;
  <define expected variable>;
  <generate actual variables>;
  <compare expected with actual>;
});

