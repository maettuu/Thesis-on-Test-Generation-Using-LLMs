Before you begin:
- Keep going until the job is completely solved — don’t stop halfway.
- If you’re unsure about the behavior, reread the provided patch carefully; do not hallucinate.
- Plan your approach before writing code by reflecting on whether the test truly fails before and passes after.

Issue:
<issue>
[Bug]: Annotations issue. TypeError: null is not an object (evaluating 'this.#touchMoveAC.abort')
### Attach (recommended) or Link to PDF file

[blank.pdf](https://github.com/user-attachments/files/19669325/blank.pdf)

Im using a simple plain blank pdf file. I have this issue with all pdf's. Its not document specific.

### Web browser and its version

latest safari version on iPhone

### Operating system and its version

iOS latest

### PDF.js version

5.1.91 latest

### Is the bug present in the latest PDF.js version?

Yes

### Is a browser extension

No

### Steps to reproduce the problem

If i draw in my pdf document i can provoke an error that i can basically only fix by restarting pdf.js.
Unfortunately I didnt figure out a way to reliably reproduce it every time but it happens really often and regularly nearly every time I try to draw. I see it happen most often if i zoom a bit draw something move around and draw again. Sometimes it happens immediately but sometimes it takes me a few drawings but definitely way to often to ignore. The error is happening as soon as i lift the finger after a I tried to draw a line (makes sense bcs its ontouchend).

"TypeError: null is not an object (evaluating 'this.#touchMoveAC.abort')"

![Image](https://github.com/user-attachments/assets/cf515e02-af3b-4d8b-a7c5-d8561eb17688)

### What is the expected behavior?

If i start to use annotations / drawings i can't move the page and I can no longer draw.

### What went wrong?

Its hard to see but right at the beginning I zoom into the document and if i switch to annotation I cant draw bcs the console error appears. As written above sometimes like in this case right from the start sometimes it takes a few scribbles but defenetly in every session.

https://github.com/user-attachments/assets/b9996f13-f07a-4eb8-9c5f-2db842efd3e2

### Link to a viewer

_No response_

### Additional context


Bonus: If i debug and check the lines i can see this

![Image](https://github.com/user-attachments/assets/5a6cef1f-c2fd-40a5-88f8-3536b2519d2f)


This is the context where the error happens so as you can see this.#touchmoveac is null therefore the error is valid

![Image](https://github.com/user-attachments/assets/35f0a933-9ecf-473b-a673-e39e5c1514ad)

</issue>

Patch:
<patch>
diff --git a/src/display/editor/tools.js b/src/display/editor/tools.js
--- a/src/display/editor/tools.js
+++ b/src/display/editor/tools.js
@@ -1680,6 +1680,7 @@ class AnnotationEditorUIManager {
     }
 
     this.#updateModeCapability = Promise.withResolvers();
+    this.#currentDrawingSession?.commitOrRemove();
 
     this.#mode = mode;
     if (mode === AnnotationEditorType.NONE) {

diff --git a/src/display/touch_manager.js b/src/display/touch_manager.js
--- a/src/display/touch_manager.js
+++ b/src/display/touch_manager.js
@@ -215,9 +215,12 @@ class TouchManager {
     if (evt.touches.length >= 2) {
       return;
     }
-    this.#touchMoveAC.abort();
-    this.#touchMoveAC = null;
-    this.#onPinchEnd?.();
+    // #touchMoveAC shouldn't be null but it seems that irl it can (see #19793).
+    if (this.#touchMoveAC) {
+      this.#touchMoveAC.abort();
+      this.#touchMoveAC = null;
+      this.#onPinchEnd?.();
+    }
 
     if (!this.#touchInfo) {
       return;


</patch>

Imports:
<imports>
Available Packages
Dev Dependencies:
- @babel/core: ^7.26.10
- @babel/preset-env: ^7.26.9
- @babel/runtime: ^7.27.0
- @fluent/bundle: ^0.19.0
- @fluent/dom: ^0.10.1
- @metalsmith/layouts: ^3.0.0
- @metalsmith/markdown: ^1.10.0
- @napi-rs/canvas: ^0.1.68
- @types/node: ^22.13.14
- autoprefixer: ^10.4.21
- babel-loader: ^10.0.0
- caniuse-lite: ^1.0.30001707
- core-js: ^3.41.0
- eslint: ^9.23.0
- eslint-plugin-import: ^2.31.0
- eslint-plugin-jasmine: ^4.2.2
- eslint-plugin-json: ^4.0.1
- eslint-plugin-no-unsanitized: ^4.1.2
- eslint-plugin-perfectionist: ^4.10.1
- eslint-plugin-prettier: ^5.2.5
- eslint-plugin-unicorn: ^58.0.0
- globals: ^16.0.0
- gulp: ^5.0.0
- gulp-cli: ^3.0.0
- gulp-postcss: ^10.0.0
- gulp-rename: ^2.0.0
- gulp-replace: ^1.1.4
- gulp-zip: ^6.1.0
- highlight.js: ^11.11.1
- jasmine: ^5.6.0
- jsdoc: ^4.0.4
- jstransformer-nunjucks: ^1.2.0
- metalsmith: ^2.6.3
- metalsmith-html-relative: ^2.0.6
- ordered-read-streams: ^2.0.0
- pngjs: ^7.0.0
- postcss: ^8.5.3
- postcss-dark-theme-class: ^1.3.0
- postcss-dir-pseudo-class: ^9.0.1
- postcss-discard-comments: ^7.0.3
- postcss-nesting: ^13.0.1
- prettier: ^3.5.3
- puppeteer: ^24.4.0
- stylelint: ^16.17.0
- stylelint-prettier: ^5.0.3
- svglint: ^3.1.0
- terser-webpack-plugin: ^5.3.14
- tsc-alias: ^1.8.13
- ttest: ^4.0.0
- typescript: ^5.8.2
- vinyl: ^3.0.0
- webpack: ^5.98.0
- webpack-stream: ^7.0.0
- yargs: ^17.7.2

Engines:
- node: >=20.16.0

Available Relative Imports:
- `../../src/core/annotation.js`: Annotation, AnnotationBorderStyle, AnnotationFactory, MarkupAnnotation, getQuadPoints
- `../../src/core/bidi.js`: bidi
- `../../src/core/calculate_md5.js`: calculateMD5
- `../../src/core/calculate_sha256.js`: calculateSHA256
- `../../src/core/calculate_sha_other.js`: calculateSHA384, calculateSHA512
- `../../src/core/cff_parser.js`: CFFCharset, CFFCompiler, CFFFDSelect, CFFParser, CFFStrings
- `../../src/core/cmap.js`: CMap, CMapFactory, IdentityCMap
- `../../src/core/colorspace.js`: ColorSpace
- `../../src/core/colorspace_utils.js`: ColorSpaceUtils
- `../../src/core/core_utils.js`: arrayBuffersToBytes, encodeToXmlString, escapePDFName, escapeString, getInheritableProperty, getSizeInBytes, isAscii, isWhiteSpace, log2, numberToString, parseXFAPath, recoverJsURL, stringToUTF16HexString, stringToUTF16String, toRomanNumerals, validateCSSFont
- `../../src/core/crypto.js`: AES128Cipher, AES256Cipher, ARCFourCipher, CipherTransformFactory, PDF17, PDF20
- `../../src/core/default_appearance.js`: createDefaultAppearance, parseAppearanceStream, parseDefaultAppearance
- `../../src/core/document.js`: PDFDocument, Page
- `../../src/core/encodings.js`: getEncoding
- `../../src/core/evaluator.js`: PartialEvaluator
- `../../src/core/flate_stream.js`: FlateStream
- `../../src/core/font_substitutions.js`: getFontSubstitution
- `../../src/core/fonts_utils.js`: SEAC_ANALYSIS_ENABLED
- `../../src/core/function.js`: PDFFunctionFactory, PostScriptCompiler, PostScriptEvaluator
- `../../src/core/glyphlist.js`: getDingbatsGlyphsUnicode, getGlyphsUnicode
- `../../src/core/image_utils.js`: GlobalColorSpaceCache, GlobalImageCache, LocalColorSpaceCache
- `../../src/core/jbig2.js`: Jbig2Error, Jbig2Image
- `../../src/core/jpg.js`: JpegError, JpegImage
- `../../src/core/jpx.js`: JpxError, JpxImage
- `../../src/core/metadata_parser.js`: MetadataParser
- `../../src/core/operator_list.js`: OperatorList
- `../../src/core/parser.js`: Lexer, Linearization, Parser
- `../../src/core/predictor_stream.js`: PredictorStream
- `../../src/core/primitives.js`: Cmd, Dict, EOF, Name, Ref, RefSet, RefSetCache, isCmd, isDict, isName, isRefsEqual
- `../../src/core/ps_parser.js`: PostScriptLexer, PostScriptParser
- `../../src/core/stream.js`: NullStream, Stream, StringStream
- `../../src/core/type1_parser.js`: Type1Parser
- `../../src/core/unicode.js`: getCharUnicodeCategory, getUnicodeForGlyph, getUnicodeRangeFor, mapSpecialUnicodeValues
- `../../src/core/worker.js`: WorkerMessageHandler, WorkerTask
- `../../src/core/writer.js`: incrementalUpdate, writeChanges, writeDict
- `../../src/core/xfa/bind.js`: Binder
- `../../src/core/xfa/data.js`: DataHandler
- `../../src/core/xfa/factory.js`: XFAFactory
- `../../src/core/xfa/formcalc_lexer.js`: Lexer, TOKEN, Token
- `../../src/core/xfa/formcalc_parser.js`: Errors, Parser
- `../../src/core/xfa/parser.js`: XFAParser
- `../../src/core/xfa/som.js`: searchNode
- `../../src/core/xfa/symbol_utils.js`: $dump, $getChildren, $getChildrenByClass, $getChildrenByName, $text, $uid
- `../../src/core/xml_parser.js`: SimpleXMLParser, XMLParserBase
- `../../src/display/annotation_layer.js`: AnnotationLayer
- `../../src/display/annotation_storage.js`: AnnotationStorage
- `../../src/display/api.js`: LoopbackPort, PDFDataRangeTransport, PDFDocumentLoadingTask, PDFDocumentProxy, PDFPageProxy, PDFWorker, RenderTask, build, getDocument, isValidExplicitDest, version
- `../../src/display/canvas_factory.js`: DOMCanvasFactory
- `../../src/display/cmap_reader_factory.js`: DOMCMapReaderFactory
- `../../src/display/display_utils.js`: OutputScale, PDFDateString, PageViewport, PixelsPerInch, RenderingCancelledException, StatTimer, SupportedImageMimeTypes, fetchData, getFilenameFromUrl, getPdfFilenameFromUrl, getXfaPageViewport, isDataScheme, isPdfFile, isValidFetchUrl, noContextMenu, setLayerDimensions, stopEvent
- `../../src/display/draw_layer.js`: DrawLayer
- `../../src/display/editor/annotation_editor_layer.js`: AnnotationEditorLayer
- `../../src/display/editor/color_picker.js`: ColorPicker
- `../../src/display/editor/drawers/signaturedraw.js`: SignatureExtractor
- `../../src/display/editor/tools.js`: AnnotationEditorUIManager, CommandManager
- `../../src/display/fetch_stream.js`: PDFFetchStream
- `../../src/display/metadata.js`: Metadata
- `../../src/display/network.js`: PDFNetworkStream
- `../../src/display/network_utils.js`: createHeaders, createResponseError, extractFilenameFromHeader, validateRangeRequestCapabilities, validateResponseStatus
- `../../src/display/node_stream.js`: PDFNodeStream
- `../../src/display/node_utils.js`: NodeCMapReaderFactory, NodeStandardFontDataFactory, fetchData
- `../../src/display/standard_fontdata_factory.js`: DOMStandardFontDataFactory
- `../../src/display/svg_factory.js`: DOMSVGFactory
- `../../src/display/text_layer.js`: TextLayer
- `../../src/display/touch_manager.js`: TouchManager
- `../../src/display/worker_options.js`: GlobalWorkerOptions
- `../../src/display/xfa_layer.js`: XfaLayer
- `../../src/shared/message_handler.js`: MessageHandler
- `../../src/shared/murmurhash3.js`: MurmurHash3_64
- `../../src/shared/util.js`: AbortException, AnnotationBorderStyleType, AnnotationEditorParamsType, AnnotationEditorType, AnnotationFieldFlag, AnnotationFlag, AnnotationMode, AnnotationType, BaseException, DrawOPS, FeatureTest, FormatError, ImageKind, InvalidPDFException, MathClamp, OPS, PasswordException, PasswordResponses, PermissionFlag, RenderingIntentFlag, ResponseException, UnknownErrorException, Util, VerbosityLevel, assert, bytesToString, createValidAbsoluteUrl, getModificationDate, getUuid, getVerbosityLevel, isNodeJS, normalizeUnicode, objectSize, setVerbosityLevel, shadow, string32, stringToBytes, stringToPDFString, stringToUTF8String, toBase64Util
- `../../web/annotation_layer_builder.js`: AnnotationLayerBuilder
- `../../web/app_options.js`: AppOptions, OptionKind
- `../../web/autolinker.js`: Autolinker
- `../../web/download_manager.js`: DownloadManager
- `../../web/event_utils.js`: EventBus, WaitOnType, waitOnEventOrTimeout
- `../../web/genericl10n.js`: GenericL10n
- `../../web/pdf_find_controller.js`: FindState, PDFFindController
- `../../web/pdf_find_utils.js`: CharacterType, getCharacterType
- `../../web/pdf_history.js`: PDFHistory, isDestArraysEqual, isDestHashesEqual
- `../../web/pdf_link_service.js`: LinkTarget, PDFLinkService, SimpleLinkService
- `../../web/pdf_page_view.js`: PDFPageView
- `../../web/pdf_scripting_manager.component.js`: PDFScriptingManager
- `../../web/pdf_single_page_viewer.js`: PDFSinglePageViewer
- `../../web/pdf_viewer.js`: PDFPageViewBuffer, PDFViewer
- `../../web/struct_tree_layer_builder.js`: StructTreeLayerBuilder
- `../../web/text_layer_builder.js`: TextLayerBuilder
- `../../web/ui_utils.js`: AutoPrintRegExp, ProgressBar, RenderingStates, ScrollMode, SpreadMode, backtrackBeforeAllVisibleElements, binarySearchFirstItem, calcRound, getPageSizeInches, getVisibleElements, isPortraitOrientation, isValidRotation, parseQueryString, removeNullCharacters
- `../../web/xfa_layer_builder.js`: XfaLayerBuilder
- `../reporter.js`: TestReporter
- `./common_pdfstream_tests.js`: testCrossOriginRedirects
- `./test_utils.js`: CMAP_URL, DefaultCMapReaderFactory, DefaultFileReaderFactory, DefaultStandardFontDataFactory, STANDARD_FONT_DATA_URL, TEST_PDFS_PATH, TestPdfsServer, XRefMock, buildGetDocumentParams, createIdFactory, getCrossOriginHostname
</imports>

Code:
<code>
File:
src/display/editor/tools.js
1 /* Copyright 2022 Mozilla Foundation
2  *
3  * Licensed under the Apache License, Version 2.0 (the "License");
4  * you may not use this file except in compliance with the License.
5  * You may obtain a copy of the License at
6  *
7  *     http://www.apache.org/licenses/LICENSE-2.0
8  *
9  * Unless required by applicable law or agreed to in writing, software
10  * distributed under the License is distributed on an "AS IS" BASIS,
11  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
12  * See the License for the specific language governing permissions and
13  * limitations under the License.
14  */
15 
16 /** @typedef {import("./editor.js").AnnotationEditor} AnnotationEditor */
17 // eslint-disable-next-line max-len
18 /** @typedef {import("./annotation_editor_layer.js").AnnotationEditorLayer} AnnotationEditorLayer */
19 
20 import {
21   AnnotationEditorParamsType,
22   AnnotationEditorPrefix,
23   AnnotationEditorType,
24   FeatureTest,
25   getUuid,
26   shadow,
27   Util,
28   warn,
29 } from "../../shared/util.js";
30 import {
31   fetchData,
32   getColorValues,
33   getRGB,
34   PixelsPerInch,
35   stopEvent,
36 } from "../display_utils.js";
37 import { HighlightToolbar } from "./toolbar.js";
38 
39 function bindEvents(obj, element, names) {
40   for (const name of names) {
41     element.addEventListener(name, obj[name].bind(obj));
42   }
43 }
44 
45 /**
46  * Class to create some unique ids for the different editors.
47  */
48 class IdManager {
49   #id = 0;
50 
51   constructor() {
52     if (typeof PDFJSDev !== "undefined" && PDFJSDev.test("TESTING")) {
53       Object.defineProperty(this, "reset", {
54         value: () => (this.#id = 0),
55       });
56     }
57   }
58 
59   /**
60    * Get a unique id.
61    * @returns {string}
62    */
63   get id() {
64     return `${AnnotationEditorPrefix}${this.#id++}`;
65   }
66 }
67 
68 /**
69  * Class to manage the images used by the editors.
70  * The main idea is to try to minimize the memory used by the images.
71  * The images are cached and reused when possible
72  * We use a refCounter to know when an image is not used anymore but we need to
73  * be able to restore an image after a remove+undo, so we keep a file reference
74  * or an url one.
75  */
76 class ImageManager {
77   #baseId = getUuid();
78 
79   #id = 0;
80 
81   #cache = null;
82 
83   static get _isSVGFittingCanvas() {
84     // By default, Firefox doesn't rescale without preserving the aspect ratio
85     // when drawing an SVG image on a canvas, see https://bugzilla.mozilla.org/1547776.
86     // The "workaround" is to append "svgView(preserveAspectRatio(none))" to the
87     // url, but according to comment #15, it seems that it leads to unexpected
88     // behavior in Safari.
89     const svg = `data:image/svg+xml;charset=UTF-8,<svg viewBox="0 0 1 1" width="1" height="1" xmlns="http://www.w3.org/2000/svg"><rect width="1" height="1" style="fill:red;"/></svg>`;
90     const canvas = new OffscreenCanvas(1, 3);
91     const ctx = canvas.getContext("2d", { willReadFrequently: true });
92     const image = new Image();
93     image.src = svg;
94     const promise = image.decode().then(() => {
95       ctx.drawImage(image, 0, 0, 1, 1, 0, 0, 1, 3);
96       return new Uint32Array(ctx.getImageData(0, 0, 1, 1).data.buffer)[0] === 0;
97     });
98 
99     return shadow(this, "_isSVGFittingCanvas", promise);
100   }
101 
102   async #get(key, rawData) {
103     this.#cache ||= new Map();
104     let data = this.#cache.get(key);
105     if (data === null) {
106       // We already tried to load the image but it failed.
107       return null;
108     }
109     if (data?.bitmap) {
110       data.refCounter += 1;
111       return data;
112     }
113     try {
114       data ||= {
115         bitmap: null,
116         id: `image_${this.#baseId}_${this.#id++}`,
117         refCounter: 0,
118         isSvg: false,
119       };
120       let image;
121       if (typeof rawData === "string") {
122         data.url = rawData;
123         image = await fetchData(rawData, "blob");
124       } else if (rawData instanceof File) {
125         image = data.file = rawData;
126       } else if (rawData instanceof Blob) {
127         image = rawData;
128       }
129 
130       if (image.type === "image/svg+xml") {
131         // Unfortunately, createImageBitmap doesn't work with SVG images.
132         // (see https://bugzilla.mozilla.org/1841972).
133         const mustRemoveAspectRatioPromise = ImageManager._isSVGFittingCanvas;
134         const fileReader = new FileReader();
135         const imageElement = new Image();
136         const imagePromise = new Promise((resolve, reject) => {
137           imageElement.onload = () => {
138             data.bitmap = imageElement;
139             data.isSvg = true;
140             resolve();
141           };
142           fileReader.onload = async () => {
143             const url = (data.svgUrl = fileReader.result);
144             // We need to set the preserveAspectRatio to none in order to let
145             // the image fits the canvas when resizing.
146             imageElement.src = (await mustRemoveAspectRatioPromise)
147               ? `${url}#svgView(preserveAspectRatio(none))`
148               : url;
149           };
150           imageElement.onerror = fileReader.onerror = reject;
151         });
152         fileReader.readAsDataURL(image);
153         await imagePromise;
154       } else {
155         data.bitmap = await createImageBitmap(image);
156       }
157       data.refCounter = 1;
158     } catch (e) {
159       warn(e);
160       data = null;
161     }
162     this.#cache.set(key, data);
163     if (data) {
164       this.#cache.set(data.id, data);
165     }
166     return data;
167   }
168 
169   async getFromFile(file) {
170     const { lastModified, name, size, type } = file;
171     return this.#get(`${lastModified}_${name}_${size}_${type}`, file);
172   }
173 
174   async getFromUrl(url) {
175     return this.#get(url, url);
176   }
177 
178   async getFromBlob(id, blobPromise) {
179     const blob = await blobPromise;
180     return this.#get(id, blob);
181   }
182 
183   async getFromId(id) {
184     this.#cache ||= new Map();
185     const data = this.#cache.get(id);
186     if (!data) {
187       return null;
188     }
189     if (data.bitmap) {
190       data.refCounter += 1;
191       return data;
192     }
193 
194     if (data.file) {
195       return this.getFromFile(data.file);
196     }
197     if (data.blobPromise) {
198       const { blobPromise } = data;
199       delete data.blobPromise;
200       return this.getFromBlob(data.id, blobPromise);
201     }
202     return this.getFromUrl(data.url);
203   }
204 
205   getFromCanvas(id, canvas) {
206     this.#cache ||= new Map();
207     let data = this.#cache.get(id);
208     if (data?.bitmap) {
209       data.refCounter += 1;
210       return data;
211     }
212     const offscreen = new OffscreenCanvas(canvas.width, canvas.height);
213     const ctx = offscreen.getContext("2d");
214     ctx.drawImage(canvas, 0, 0);
215     data = {
216       bitmap: offscreen.transferToImageBitmap(),
217       id: `image_${this.#baseId}_${this.#id++}`,
218       refCounter: 1,
219       isSvg: false,
220     };
221     this.#cache.set(id, data);
222     this.#cache.set(data.id, data);
223     return data;
224   }
225 
226   getSvgUrl(id) {
227     const data = this.#cache.get(id);
228     if (!data?.isSvg) {
229       return null;
230     }
231     return data.svgUrl;
232   }
233 
234   deleteId(id) {
235     this.#cache ||= new Map();
236     const data = this.#cache.get(id);
237     if (!data) {
238       return;
239     }
240     data.refCounter -= 1;
241     if (data.refCounter !== 0) {
242       return;
243     }
244     const { bitmap } = data;
245     if (!data.url && !data.file) {
246       // The image has no way to be restored (ctrl+z) so we must fix that.
247       const canvas = new OffscreenCanvas(bitmap.width, bitmap.height);
248       const ctx = canvas.getContext("bitmaprenderer");
249       ctx.transferFromImageBitmap(bitmap);
250       data.blobPromise = canvas.convertToBlob();
251     }
252 
253     bitmap.close?.();
254     data.bitmap = null;
255   }
256 
257   // We can use the id only if it belongs this manager.
258   // We must take care of having the right manager because we can copy/paste
259   // some images from other documents, hence it'd be a pity to use an id from an
260   // other manager.
261   isValidId(id) {
262     return id.startsWith(`image_${this.#baseId}_`);
263   }
264 }
265 
266 /**
267  * Class to handle undo/redo.
268  * Commands are just saved in a buffer.
269  * If we hit some memory issues we could likely use a circular buffer.
270  * It has to be used as a singleton.
271  */
272 class CommandManager {
273   #commands = [];
274 
275   #locked = false;
276 
277   #maxSize;
278 
279   #position = -1;
280 
281   constructor(maxSize = 128) {
282     this.#maxSize = maxSize;
283   }
284 
285   /**
286    * @typedef {Object} addOptions
287    * @property {function} cmd
288    * @property {function} undo
289    * @property {function} [post]
290    * @property {boolean} mustExec
291    * @property {number} type
292    * @property {boolean} overwriteIfSameType
293    * @property {boolean} keepUndo
294    */
295 
296   /**
297    * Add a new couple of commands to be used in case of redo/undo.
298    * @param {addOptions} options
299    */
300   add({
301     cmd,
302     undo,
303     post,
304     mustExec,
305     type = NaN,
306     overwriteIfSameType = false,
307     keepUndo = false,
308   }) {
309     if (mustExec) {
310       cmd();
311     }
312 
313     if (this.#locked) {
314       return;
315     }
316 
317     const save = { cmd, undo, post, type };
318     if (this.#position === -1) {
319       if (this.#commands.length > 0) {
320         // All the commands have been undone and then a new one is added
321         // hence we clear the queue.
322         this.#commands.length = 0;
323       }
324       this.#position = 0;
325       this.#commands.push(save);
326       return;
327     }
328 
329     if (overwriteIfSameType && this.#commands[this.#position].type === type) {
330       // For example when we change a color we don't want to
331       // be able to undo all the steps, hence we only want to
332       // keep the last undoable action in this sequence of actions.
333       if (keepUndo) {
334         save.undo = this.#commands[this.#position].undo;
335       }
336       this.#commands[this.#position] = save;
337       return;
338     }
339 
340     const next = this.#position + 1;
341     if (next === this.#maxSize) {
342       this.#commands.splice(0, 1);
343     } else {
344       this.#position = next;
345       if (next < this.#commands.length) {
346         this.#commands.splice(next);
347       }
348     }
349 
350     this.#commands.push(save);
351   }
352 
353   /**
354    * Undo the last command.
355    */
356   undo() {
357     if (this.#position === -1) {
358       // Nothing to undo.
359       return;
360     }
361 
362     // Avoid to insert something during the undo execution.
363     this.#locked = true;
364     const { undo, post } = this.#commands[this.#position];
365     undo();
366     post?.();
367     this.#locked = false;
368 
369     this.#position -= 1;
370   }
371 
372   /**
373    * Redo the last command.
374    */
375   redo() {
376     if (this.#position < this.#commands.length - 1) {
377       this.#position += 1;
378 
379       // Avoid to insert something during the redo execution.
380       this.#locked = true;
381       const { cmd, post } = this.#commands[this.#position];
382       cmd();
383       post?.();
384       this.#locked = false;
385     }
386   }
387 
388   /**
389    * Check if there is something to undo.
390    * @returns {boolean}
391    */
392   hasSomethingToUndo() {
393     return this.#position !== -1;
394   }
395 
396   /**
397    * Check if there is something to redo.
398    * @returns {boolean}
399    */
400   hasSomethingToRedo() {
401     return this.#position < this.#commands.length - 1;
402   }
403 
404   cleanType(type) {
405     if (this.#position === -1) {
406       return;
407     }
408     for (let i = this.#position; i >= 0; i--) {
409       if (this.#commands[i].type !== type) {
410         this.#commands.splice(i + 1, this.#position - i);
411         this.#position = i;
412         return;
413       }
414     }
415     this.#commands.length = 0;
416     this.#position = -1;
417   }
418 
419   destroy() {
420     this.#commands = null;
421   }
422 }
423 
424 /**
425  * Class to handle the different keyboards shortcuts we can have on mac or
426  * non-mac OSes.
427  */
428 class KeyboardManager {
429   /**
430    * Create a new keyboard manager class.
431    * @param {Array<Array>} callbacks - an array containing an array of shortcuts
432    * and a callback to call.
433    * A shortcut is a string like `ctrl+c` or `mac+ctrl+c` for mac OS.
434    */
435   constructor(callbacks) {
436     this.buffer = [];
437     this.callbacks = new Map();
438     this.allKeys = new Set();
439 
440     const { isMac } = FeatureTest.platform;
441     for (const [keys, callback, options = {}] of callbacks) {
442       for (const key of keys) {
443         const isMacKey = key.startsWith("mac+");
444         if (isMac && isMacKey) {
445           this.callbacks.set(key.slice(4), { callback, options });
446           this.allKeys.add(key.split("+").at(-1));
447         } else if (!isMac && !isMacKey) {
448           this.callbacks.set(key, { callback, options });
449           this.allKeys.add(key.split("+").at(-1));
450         }
451       }
452     }
453   }
454 
455   /**
456    * Serialize an event into a string in order to match a
457    * potential key for a callback.
458    * @param {KeyboardEvent} event
459    * @returns {string}
460    */
461   #serialize(event) {
462     if (event.altKey) {
463       this.buffer.push("alt");
464     }
465     if (event.ctrlKey) {
466       this.buffer.push("ctrl");
467     }
468     if (event.metaKey) {
469       this.buffer.push("meta");
470     }
471     if (event.shiftKey) {
472       this.buffer.push("shift");
473     }
474     this.buffer.push(event.key);
475     const str = this.buffer.join("+");
476     this.buffer.length = 0;
477 
478     return str;
479   }
480 
481   /**
482    * Execute a callback, if any, for a given keyboard event.
483    * The self is used as `this` in the callback.
484    * @param {Object} self
485    * @param {KeyboardEvent} event
486    * @returns
487    */
488   exec(self, event) {
489     if (!this.allKeys.has(event.key)) {
490       return;
491     }
492     const info = this.callbacks.get(this.#serialize(event));
493     if (!info) {
494       return;
495     }
496     const {
497       callback,
498       options: { bubbles = false, args = [], checker = null },
499     } = info;
500 
501     if (checker && !checker(self, event)) {
502       return;
503     }
504     callback.bind(self, ...args, event)();
505 
506     // For example, ctrl+s in a FreeText must be handled by the viewer, hence
507     // the event must bubble.
508     if (!bubbles) {
509       stopEvent(event);
510     }
511   }
512 }
513 
514 class ColorManager {
515   static _colorsMapping = new Map([
516     ["CanvasText", [0, 0, 0]],
517     ["Canvas", [255, 255, 255]],
518   ]);
519 
520   get _colors() {
521     if (
522       typeof PDFJSDev !== "undefined" &&
523       PDFJSDev.test("LIB") &&
524       typeof document === "undefined"
525     ) {
526       return shadow(this, "_colors", ColorManager._colorsMapping);
527     }
528 
529     const colors = new Map([
530       ["CanvasText", null],
531       ["Canvas", null],
532     ]);
533     getColorValues(colors);
534     return shadow(this, "_colors", colors);
535   }
536 
537   /**
538    * In High Contrast Mode, the color on the screen is not always the
539    * real color used in the pdf.
540    * For example in some cases white can appear to be black but when saving
541    * we want to have white.
542    * @param {string} color
543    * @returns {Array<number>}
544    */
545   convert(color) {
546     const rgb = getRGB(color);
547     if (!window.matchMedia("(forced-colors: active)").matches) {
548       return rgb;
549     }
550 
551     for (const [name, RGB] of this._colors) {
552       if (RGB.every((x, i) => x === rgb[i])) {
553         return ColorManager._colorsMapping.get(name);
554       }
555     }
556     return rgb;
557   }
558 
559   /**
560    * An input element must have its color value as a hex string
561    * and not as color name.
562    * So this function converts a name into an hex string.
563    * @param {string} name
564    * @returns {string}
565    */
566   getHexCode(name) {
567     const rgb = this._colors.get(name);
568     if (!rgb) {
569       return name;
570     }
571     return Util.makeHexColor(...rgb);
572   }
573 }
574 
575 /**
576  * A pdf has several pages and each of them when it will rendered
577  * will have an AnnotationEditorLayer which will contain the some
578  * new Annotations associated to an editor in order to modify them.
579  *
580  * This class is used to manage all the different layers, editors and
581  * some action like copy/paste, undo/redo, ...
582  */
583 class AnnotationEditorUIManager {
584   #abortController = new AbortController();
585 
586   #activeEditor = null;
587 
588   #allEditors = new Map();
589 
590   #allLayers = new Map();
591 
592   #altTextManager = null;
593 
594   #annotationStorage = null;
595 
596   #changedExistingAnnotations = null;
597 
598   #commandManager = new CommandManager();
599 
600   #copyPasteAC = null;
601 
602   #currentDrawingSession = null;
603 
604   #currentPageIndex = 0;
605 
606   #deletedAnnotationsElementIds = new Set();
607 
608   #draggingEditors = null;
609 
610   #editorTypes = null;
611 
612   #editorsToRescale = new Set();
613 
614   _editorUndoBar = null;
615 
616   #enableHighlightFloatingButton = false;
617 
618   #enableUpdatedAddImage = false;
619 
620   #enableNewAltTextWhenAddingImage = false;
621 
622   #filterFactory = null;
623 
624   #focusMainContainerTimeoutId = null;
625 
626   #focusManagerAC = null;
627 
628   #highlightColors = null;
629 
630   #highlightWhenShiftUp = false;
631 
632   #highlightToolbar = null;
633 
634   #idManager = new IdManager();
635 
636   #isEnabled = false;
637 
638   #isWaiting = false;
639 
640   #keyboardManagerAC = null;
641 
642   #lastActiveElement = null;
643 
644   #mainHighlightColorPicker = null;
645 
646   #missingCanvases = null;
647 
648   #mlManager = null;
649 
650   #mode = AnnotationEditorType.NONE;
651 
652   #selectedEditors = new Set();
653 
654   #selectedTextNode = null;
655 
656   #signatureManager = null;
657 
658   #pageColors = null;
659 
660   #showAllStates = null;
661 
662   #previousStates = {
663     isEditing: false,
664     isEmpty: true,
665     hasSomethingToUndo: false,
666     hasSomethingToRedo: false,
667     hasSelectedEditor: false,
668     hasSelectedText: false,
669   };
670 
671   #translation = [0, 0];
672 
673   #translationTimeoutId = null;
674 
675   #container = null;
676 
677   #viewer = null;
678 
679   #updateModeCapability = null;
680 
681   static TRANSLATE_SMALL = 1; // page units.
682 
683   static TRANSLATE_BIG = 10; // page units.
684 
685   static get _keyboardManager() {
686     const proto = AnnotationEditorUIManager.prototype;
687 
688     /**
689      * If the focused element is an input, we don't want to handle the arrow.
690      * For example, sliders can be controlled with the arrow keys.
691      */
692     const arrowChecker = self =>
693       self.#container.contains(document.activeElement) &&
694       document.activeElement.tagName !== "BUTTON" &&
695       self.hasSomethingToControl();
696 
697     const textInputChecker = (_self, { target: el }) => {
698       if (el instanceof HTMLInputElement) {
699         const { type } = el;
700         return type !== "text" && type !== "number";
701       }
702       return true;
703     };
704 
705     const small = this.TRANSLATE_SMALL;
706     const big = this.TRANSLATE_BIG;
707 
708     return shadow(
709       this,
710       "_keyboardManager",
711       new KeyboardManager([
712         [
713           ["ctrl+a", "mac+meta+a"],
714           proto.selectAll,
715           { checker: textInputChecker },
716         ],
717         [["ctrl+z", "mac+meta+z"], proto.undo, { checker: textInputChecker }],
718         [
719           // On mac, depending of the OS version, the event.key is either "z" or
720           // "Z" when the user presses "meta+shift+z".
721           [
722             "ctrl+y",
723             "ctrl+shift+z",
724             "mac+meta+shift+z",
725             "ctrl+shift+Z",
726             "mac+meta+shift+Z",
727           ],
728           proto.redo,
729           { checker: textInputChecker },
730         ],
731         [
732           [
733             "Backspace",
734             "alt+Backspace",
735             "ctrl+Backspace",
736             "shift+Backspace",
737             "mac+Backspace",
738             "mac+alt+Backspace",
739             "mac+ctrl+Backspace",
740             "Delete",
741             "ctrl+Delete",
742             "shift+Delete",
743             "mac+Delete",
744           ],
745           proto.delete,
746           { checker: textInputChecker },
747         ],
748         [
749           ["Enter", "mac+Enter"],
750           proto.addNewEditorFromKeyboard,
751           {
752             // Those shortcuts can be used in the toolbar for some other actions
753             // like zooming, hence we need to check if the container has the
754             // focus.
755             checker: (self, { target: el }) =>
756               !(el instanceof HTMLButtonElement) &&
757               self.#container.contains(el) &&
758               !self.isEnterHandled,
759           },
760         ],
761         [
762           [" ", "mac+ "],
763           proto.addNewEditorFromKeyboard,
764           {
765             // Those shortcuts can be used in the toolbar for some other actions
766             // like zooming, hence we need to check if the container has the
767             // focus.
768             checker: (self, { target: el }) =>
769               !(el instanceof HTMLButtonElement) &&
770               self.#container.contains(document.activeElement),
771           },
772         ],
773         [["Escape", "mac+Escape"], proto.unselectAll],
774         [
775           ["ArrowLeft", "mac+ArrowLeft"],
776           proto.translateSelectedEditors,
777           { args: [-small, 0], checker: arrowChecker },
778         ],
779         [
780           ["ctrl+ArrowLeft", "mac+shift+ArrowLeft"],
781           proto.translateSelectedEditors,
782           { args: [-big, 0], checker: arrowChecker },
783         ],
784         [
785           ["ArrowRight", "mac+ArrowRight"],
786           proto.translateSelectedEditors,
787           { args: [small, 0], checker: arrowChecker },
788         ],
789         [
790           ["ctrl+ArrowRight", "mac+shift+ArrowRight"],
791           proto.translateSelectedEditors,
792           { args: [big, 0], checker: arrowChecker },
793         ],
794         [
795           ["ArrowUp", "mac+ArrowUp"],
796           proto.translateSelectedEditors,
797           { args: [0, -small], checker: arrowChecker },
798         ],
799         [
800           ["ctrl+ArrowUp", "mac+shift+ArrowUp"],
801           proto.translateSelectedEditors,
802           { args: [0, -big], checker: arrowChecker },
803         ],
804         [
805           ["ArrowDown", "mac+ArrowDown"],
806           proto.translateSelectedEditors,
807           { args: [0, small], checker: arrowChecker },
808         ],
809         [
810           ["ctrl+ArrowDown", "mac+shift+ArrowDown"],
811           proto.translateSelectedEditors,
812           { args: [0, big], checker: arrowChecker },
813         ],
814       ])
815     );
816   }
817 
818   constructor(
819     container,
820     viewer,
821     altTextManager,
822     signatureManager,
823     eventBus,
824     pdfDocument,
825     pageColors,
826     highlightColors,
827     enableHighlightFloatingButton,
828     enableUpdatedAddImage,
829     enableNewAltTextWhenAddingImage,
830     mlManager,
831     editorUndoBar,
832     supportsPinchToZoom
833   ) {
834     const signal = (this._signal = this.#abortController.signal);
835     this.#container = container;
836     this.#viewer = viewer;
837     this.#altTextManager = altTextManager;
838     this.#signatureManager = signatureManager;
839     this._eventBus = eventBus;
840     eventBus._on("editingaction", this.onEditingAction.bind(this), { signal });
841     eventBus._on("pagechanging", this.onPageChanging.bind(this), { signal });
842     eventBus._on("scalechanging", this.onScaleChanging.bind(this), { signal });
843     eventBus._on("rotationchanging", this.onRotationChanging.bind(this), {
844       signal,
845     });
846     eventBus._on("setpreference", this.onSetPreference.bind(this), { signal });
847     eventBus._on(
848       "switchannotationeditorparams",
849       evt => this.updateParams(evt.type, evt.value),
850       { signal }
851     );
852     this.#addSelectionListener();
853     this.#addDragAndDropListeners();
854     this.#addKeyboardManager();
855     this.#annotationStorage = pdfDocument.annotationStorage;
856     this.#filterFactory = pdfDocument.filterFactory;
857     this.#pageColors = pageColors;
858     this.#highlightColors = highlightColors || null;
859     this.#enableHighlightFloatingButton = enableHighlightFloatingButton;
860     this.#enableUpdatedAddImage = enableUpdatedAddImage;
861     this.#enableNewAltTextWhenAddingImage = enableNewAltTextWhenAddingImage;
862     this.#mlManager = mlManager || null;
863     this.viewParameters = {
864       realScale: PixelsPerInch.PDF_TO_CSS_UNITS,
865       rotation: 0,
866     };
867     this.isShiftKeyDown = false;
868     this._editorUndoBar = editorUndoBar || null;
869     this._supportsPinchToZoom = supportsPinchToZoom !== false;
870 
871     if (typeof PDFJSDev !== "undefined" && PDFJSDev.test("TESTING")) {
872       Object.defineProperty(this, "reset", {
873         value: () => {
874           this.selectAll();
875           this.delete();
876           this.#idManager.reset();
877         },
878       });
879     }
880   }
881 
882   destroy() {
883     this.#updateModeCapability?.resolve();
884     this.#updateModeCapability = null;
885 
886     this.#abortController?.abort();
887     this.#abortController = null;
888     this._signal = null;
889 
890     for (const layer of this.#allLayers.values()) {
891       layer.destroy();
892     }
893     this.#allLayers.clear();
894     this.#allEditors.clear();
895     this.#editorsToRescale.clear();
896     this.#missingCanvases?.clear();
897     this.#activeEditor = null;
898     this.#selectedEditors.clear();
899     this.#commandManager.destroy();
900     this.#altTextManager?.destroy();
901     this.#signatureManager?.destroy();
902     this.#highlightToolbar?.hide();
903     this.#highlightToolbar = null;
904     this.#mainHighlightColorPicker?.destroy();
905     this.#mainHighlightColorPicker = null;
906     if (this.#focusMainContainerTimeoutId) {
907       clearTimeout(this.#focusMainContainerTimeoutId);
908       this.#focusMainContainerTimeoutId = null;
909     }
910     if (this.#translationTimeoutId) {
911       clearTimeout(this.#translationTimeoutId);
912       this.#translationTimeoutId = null;
913     }
914     this._editorUndoBar?.destroy();
915   }
916 
917   combinedSignal(ac) {
918     return AbortSignal.any([this._signal, ac.signal]);
919   }
920 
921   get mlManager() {
922     return this.#mlManager;
923   }
924 
925   get useNewAltTextFlow() {
926     return this.#enableUpdatedAddImage;
927   }
928 
929   get useNewAltTextWhenAddingImage() {
930     return this.#enableNewAltTextWhenAddingImage;
931   }
932 
933   get hcmFilter() {
934     return shadow(
935       this,
936       "hcmFilter",
937       this.#pageColors
938         ? this.#filterFactory.addHCMFilter(
939             this.#pageColors.foreground,
940             this.#pageColors.background
941           )
942         : "none"
943     );
944   }
945 
946   get direction() {
947     return shadow(
948       this,
949       "direction",
950       getComputedStyle(this.#container).direction
951     );
952   }
953 
954   get highlightColors() {
955     return shadow(
956       this,
957       "highlightColors",
958       this.#highlightColors
959         ? new Map(
960             this.#highlightColors
961               .split(",")
962               .map(pair => pair.split("=").map(x => x.trim()))
963           )
964         : null
965     );
966   }
967 
968   get highlightColorNames() {
969     return shadow(
970       this,
971       "highlightColorNames",
972       this.highlightColors
973         ? new Map(Array.from(this.highlightColors, e => e.reverse()))
974         : null
975     );
976   }
977 
978   /**
979    * Set the current drawing session.
980    * @param {AnnotationEditorLayer} layer
981    */
982   setCurrentDrawingSession(layer) {
983     if (layer) {
984       this.unselectAll();
985       this.disableUserSelect(true);
986     } else {
987       this.disableUserSelect(false);
988     }
989     this.#currentDrawingSession = layer;
990   }
991 
992   setMainHighlightColorPicker(colorPicker) {
993     this.#mainHighlightColorPicker = colorPicker;
994   }
995 
996   editAltText(editor, firstTime = false) {
997     this.#altTextManager?.editAltText(this, editor, firstTime);
998   }
999 
1000   getSignature(editor) {
1001     this.#signatureManager?.getSignature({ uiManager: this, editor });
1002   }
1003 
1004   get signatureManager() {
1005     return this.#signatureManager;
1006   }
1007 
1008   switchToMode(mode, callback) {
1009     // Switching to a mode can be asynchronous.
1010     this._eventBus.on("annotationeditormodechanged", callback, {
1011       once: true,
1012       signal: this._signal,
1013     });
1014     this._eventBus.dispatch("showannotationeditorui", {
1015       source: this,
1016       mode,
1017     });
1018   }
1019 
1020   setPreference(name, value) {
1021     this._eventBus.dispatch("setpreference", {
1022       source: this,
1023       name,
1024       value,
1025     });
1026   }
1027 
1028   onSetPreference({ name, value }) {
1029     switch (name) {
1030       case "enableNewAltTextWhenAddingImage":
1031         this.#enableNewAltTextWhenAddingImage = value;
1032         break;
1033     }
1034   }
1035 
1036   onPageChanging({ pageNumber }) {
1037     this.#currentPageIndex = pageNumber - 1;
1038   }
1039 
1040   focusMainContainer() {
1041     this.#container.focus();
1042   }
1043 
1044   findParent(x, y) {
1045     for (const layer of this.#allLayers.values()) {
1046       const {
1047         x: layerX,
1048         y: layerY,
1049         width,
1050         height,
1051       } = layer.div.getBoundingClientRect();
1052       if (
1053         x >= layerX &&
1054         x <= layerX + width &&
1055         y >= layerY &&
1056         y <= layerY + height
1057       ) {
1058         return layer;
1059       }
1060     }
1061     return null;
1062   }
1063 
1064   disableUserSelect(value = false) {
1065     this.#viewer.classList.toggle("noUserSelect", value);
1066   }
1067 
1068   addShouldRescale(editor) {
1069     this.#editorsToRescale.add(editor);
1070   }
1071 
1072   removeShouldRescale(editor) {
1073     this.#editorsToRescale.delete(editor);
1074   }
1075 
1076   onScaleChanging({ scale }) {
1077     this.commitOrRemove();
1078     this.viewParameters.realScale = scale * PixelsPerInch.PDF_TO_CSS_UNITS;
1079     for (const editor of this.#editorsToRescale) {
1080       editor.onScaleChanging();
1081     }
1082     this.#currentDrawingSession?.onScaleChanging();
1083   }
1084 
1085   onRotationChanging({ pagesRotation }) {
1086     this.commitOrRemove();
1087     this.viewParameters.rotation = pagesRotation;
1088   }
1089 
1090   #getAnchorElementForSelection({ anchorNode }) {
1091     return anchorNode.nodeType === Node.TEXT_NODE
1092       ? anchorNode.parentElement
1093       : anchorNode;
1094   }
1095 
1096   #getLayerForTextLayer(textLayer) {
1097     const { currentLayer } = this;
1098     if (currentLayer.hasTextLayer(textLayer)) {
1099       return currentLayer;
1100     }
1101     for (const layer of this.#allLayers.values()) {
1102       if (layer.hasTextLayer(textLayer)) {
1103         return layer;
1104       }
1105     }
1106     return null;
1107   }
1108 
1109   highlightSelection(methodOfCreation = "") {
1110     const selection = document.getSelection();
1111     if (!selection || selection.isCollapsed) {
1112       return;
1113     }
1114     const { anchorNode, anchorOffset, focusNode, focusOffset } = selection;
1115     const text = selection.toString();
1116     const anchorElement = this.#getAnchorElementForSelection(selection);
1117     const textLayer = anchorElement.closest(".textLayer");
1118     const boxes = this.getSelectionBoxes(textLayer);
1119     if (!boxes) {
1120       return;
1121     }
1122     selection.empty();
1123 
1124     const layer = this.#getLayerForTextLayer(textLayer);
1125     const isNoneMode = this.#mode === AnnotationEditorType.NONE;
1126     const callback = () => {
1127       layer?.createAndAddNewEditor({ x: 0, y: 0 }, false, {
1128         methodOfCreation,
1129         boxes,
1130         anchorNode,
1131         anchorOffset,
1132         focusNode,
1133         focusOffset,
1134         text,
1135       });
1136       if (isNoneMode) {
1137         this.showAllEditors("highlight", true, /* updateButton = */ true);
1138       }
1139     };
1140     if (isNoneMode) {
1141       this.switchToMode(AnnotationEditorType.HIGHLIGHT, callback);
1142       return;
1143     }
1144     callback();
1145   }
1146 
1147   #displayHighlightToolbar() {
1148     const selection = document.getSelection();
1149     if (!selection || selection.isCollapsed) {
1150       return;
1151     }
1152     const anchorElement = this.#getAnchorElementForSelection(selection);
1153     const textLayer = anchorElement.closest(".textLayer");
1154     const boxes = this.getSelectionBoxes(textLayer);
1155     if (!boxes) {
1156       return;
1157     }
1158     this.#highlightToolbar ||= new HighlightToolbar(this);
1159     this.#highlightToolbar.show(textLayer, boxes, this.direction === "ltr");
1160   }
1161 
1162   /**
1163    * Add an editor in the annotation storage.
1164    * @param {AnnotationEditor} editor
1165    */
1166   addToAnnotationStorage(editor) {
1167     if (
1168       !editor.isEmpty() &&
1169       this.#annotationStorage &&
1170       !this.#annotationStorage.has(editor.id)
1171     ) {
1172       this.#annotationStorage.setValue(editor.id, editor);
1173     }
1174   }
1175 
1176   #selectionChange() {
1177     const selection = document.getSelection();
1178     if (!selection || selection.isCollapsed) {
1179       if (this.#selectedTextNode) {
1180         this.#highlightToolbar?.hide();
1181         this.#selectedTextNode = null;
1182         this.#dispatchUpdateStates({
1183           hasSelectedText: false,
1184         });
1185       }
1186       return;
1187     }
1188     const { anchorNode } = selection;
1189     if (anchorNode === this.#selectedTextNode) {
1190       return;
1191     }
1192 
1193     const anchorElement = this.#getAnchorElementForSelection(selection);
1194     const textLayer = anchorElement.closest(".textLayer");
1195     if (!textLayer) {
1196       if (this.#selectedTextNode) {
1197         this.#highlightToolbar?.hide();
1198         this.#selectedTextNode = null;
1199         this.#dispatchUpdateStates({
1200           hasSelectedText: false,
1201         });
1202       }
1203       return;
1204     }
1205 
1206     this.#highlightToolbar?.hide();
1207     this.#selectedTextNode = anchorNode;
1208     this.#dispatchUpdateStates({
1209       hasSelectedText: true,
1210     });
1211 
1212     if (
1213       this.#mode !== AnnotationEditorType.HIGHLIGHT &&
1214       this.#mode !== AnnotationEditorType.NONE
1215     ) {
1216       return;
1217     }
1218 
1219     if (this.#mode === AnnotationEditorType.HIGHLIGHT) {
1220       this.showAllEditors("highlight", true, /* updateButton = */ true);
1221     }
1222 
1223     this.#highlightWhenShiftUp = this.isShiftKeyDown;
1224     if (!this.isShiftKeyDown) {
1225       const activeLayer =
1226         this.#mode === AnnotationEditorType.HIGHLIGHT
1227           ? this.#getLayerForTextLayer(textLayer)
1228           : null;
1229       activeLayer?.toggleDrawing();
1230 
1231       const ac = new AbortController();
1232       const signal = this.combinedSignal(ac);
1233 
1234       const pointerup = e => {
1235         if (e.type === "pointerup" && e.button !== 0) {
1236           // Do nothing on right click.
1237           return;
1238         }
1239         ac.abort();
1240         activeLayer?.toggleDrawing(true);
1241         if (e.type === "pointerup") {
1242           this.#onSelectEnd("main_toolbar");
1243         }
1244       };
1245       window.addEventListener("pointerup", pointerup, { signal });
1246       window.addEventListener("blur", pointerup, { signal });
1247     }
1248   }
1249 
1250   #onSelectEnd(methodOfCreation = "") {
1251     if (this.#mode === AnnotationEditorType.HIGHLIGHT) {
1252       this.highlightSelection(methodOfCreation);
1253     } else if (this.#enableHighlightFloatingButton) {
1254       this.#displayHighlightToolbar();
1255     }
1256   }
1257 
1258   #addSelectionListener() {
1259     document.addEventListener(
1260       "selectionchange",
1261       this.#selectionChange.bind(this),
1262       { signal: this._signal }
1263     );
1264   }
1265 
1266   #addFocusManager() {
1267     if (this.#focusManagerAC) {
1268       return;
1269     }
1270     this.#focusManagerAC = new AbortController();
1271     const signal = this.combinedSignal(this.#focusManagerAC);
1272 
1273     window.addEventListener("focus", this.focus.bind(this), { signal });
1274     window.addEventListener("blur", this.blur.bind(this), { signal });
1275   }
1276 
1277   #removeFocusManager() {
1278     this.#focusManagerAC?.abort();
1279     this.#focusManagerAC = null;
1280   }
1281 
1282   blur() {
1283     this.isShiftKeyDown = false;
1284     if (this.#highlightWhenShiftUp) {
1285       this.#highlightWhenShiftUp = false;
1286       this.#onSelectEnd("main_toolbar");
1287     }
1288     if (!this.hasSelection) {
1289       return;
1290     }
1291     // When several editors are selected and the window loses focus, we want to
1292     // keep the last active element in order to be able to focus it again when
1293     // the window gets the focus back but we don't want to trigger any focus
1294     // callbacks else only one editor will be selected.
1295     const { activeElement } = document;
1296     for (const editor of this.#selectedEditors) {
1297       if (editor.div.contains(activeElement)) {
1298         this.#lastActiveElement = [editor, activeElement];
1299         editor._focusEventsAllowed = false;
1300         break;
1301       }
1302     }
1303   }
1304 
1305   focus() {
1306     if (!this.#lastActiveElement) {
1307       return;
1308     }
1309     const [lastEditor, lastActiveElement] = this.#lastActiveElement;
1310     this.#lastActiveElement = null;
1311     lastActiveElement.addEventListener(
1312       "focusin",
1313       () => {
1314         lastEditor._focusEventsAllowed = true;
1315       },
1316       { once: true, signal: this._signal }
1317     );
1318     lastActiveElement.focus();
1319   }
1320 
1321   #addKeyboardManager() {
1322     if (this.#keyboardManagerAC) {
1323       return;
1324     }
1325     this.#keyboardManagerAC = new AbortController();
1326     const signal = this.combinedSignal(this.#keyboardManagerAC);
1327 
1328     // The keyboard events are caught at the container level in order to be able
1329     // to execute some callbacks even if the current page doesn't have focus.
1330     window.addEventListener("keydown", this.keydown.bind(this), { signal });
1331     window.addEventListener("keyup", this.keyup.bind(this), { signal });
1332   }
1333 
1334   #removeKeyboardManager() {
1335     this.#keyboardManagerAC?.abort();
1336     this.#keyboardManagerAC = null;
1337   }
1338 
1339   #addCopyPasteListeners() {
1340     if (this.#copyPasteAC) {
1341       return;
1342     }
1343     this.#copyPasteAC = new AbortController();
1344     const signal = this.combinedSignal(this.#copyPasteAC);
1345 
1346     document.addEventListener("copy", this.copy.bind(this), { signal });
1347     document.addEventListener("cut", this.cut.bind(this), { signal });
1348     document.addEventListener("paste", this.paste.bind(this), { signal });
1349   }
1350 
1351   #removeCopyPasteListeners() {
1352     this.#copyPasteAC?.abort();
1353     this.#copyPasteAC = null;
1354   }
1355 
1356   #addDragAndDropListeners() {
1357     const signal = this._signal;
1358     document.addEventListener("dragover", this.dragOver.bind(this), { signal });
1359     document.addEventListener("drop", this.drop.bind(this), { signal });
1360   }
1361 
1362   addEditListeners() {
1363     this.#addKeyboardManager();
1364     this.#addCopyPasteListeners();
1365   }
1366 
1367   removeEditListeners() {
1368     this.#removeKeyboardManager();
1369     this.#removeCopyPasteListeners();
1370   }
1371 
1372   dragOver(event) {
1373     for (const { type } of event.dataTransfer.items) {
1374       for (const editorType of this.#editorTypes) {
1375         if (editorType.isHandlingMimeForPasting(type)) {
1376           event.dataTransfer.dropEffect = "copy";
1377           event.preventDefault();
1378           return;
1379         }
1380       }
1381     }
1382   }
1383 
1384   /**
1385    * Drop callback.
1386    * @param {DragEvent} event
1387    */
1388   drop(event) {
1389     for (const item of event.dataTransfer.items) {
1390       for (const editorType of this.#editorTypes) {
1391         if (editorType.isHandlingMimeForPasting(item.type)) {
1392           editorType.paste(item, this.currentLayer);
1393           event.preventDefault();
1394           return;
1395         }
1396       }
1397     }
1398   }
1399 
1400   /**
1401    * Copy callback.
1402    * @param {ClipboardEvent} event
1403    */
1404   copy(event) {
1405     event.preventDefault();
1406 
1407     // An editor is being edited so just commit it.
1408     this.#activeEditor?.commitOrRemove();
1409 
1410     if (!this.hasSelection) {
1411       return;
1412     }
1413 
1414     const editors = [];
1415     for (const editor of this.#selectedEditors) {
1416       const serialized = editor.serialize(/* isForCopying = */ true);
1417       if (serialized) {
1418         editors.push(serialized);
1419       }
1420     }
1421     if (editors.length === 0) {
1422       return;
1423     }
1424 
1425     event.clipboardData.setData("application/pdfjs", JSON.stringify(editors));
1426   }
1427 
1428   /**
1429    * Cut callback.
1430    * @param {ClipboardEvent} event
1431    */
1432   cut(event) {
1433     this.copy(event);
1434     this.delete();
1435   }
1436 
1437   /**
1438    * Paste callback.
1439    * @param {ClipboardEvent} event
1440    */
1441   async paste(event) {
1442     event.preventDefault();
1443     const { clipboardData } = event;
1444     for (const item of clipboardData.items) {
1445       for (const editorType of this.#editorTypes) {
1446         if (editorType.isHandlingMimeForPasting(item.type)) {
1447           editorType.paste(item, this.currentLayer);
1448           return;
1449         }
1450       }
1451     }
1452 
1453     let data = clipboardData.getData("application/pdfjs");
1454     if (!data) {
1455       return;
1456     }
1457 
1458     try {
1459       data = JSON.parse(data);
1460     } catch (ex) {
1461       warn(`paste: "${ex.message}".`);
1462       return;
1463     }
1464 
1465     if (!Array.isArray(data)) {
1466       return;
1467     }
1468 
1469     this.unselectAll();
1470     const layer = this.currentLayer;
1471 
1472     try {
1473       const newEditors = [];
1474       for (const editor of data) {
1475         const deserializedEditor = await layer.deserialize(editor);
1476         if (!deserializedEditor) {
1477           return;
1478         }
1479         newEditors.push(deserializedEditor);
1480       }
1481 
1482       const cmd = () => {
1483         for (const editor of newEditors) {
1484           this.#addEditorToLayer(editor);
1485         }
1486         this.#selectEditors(newEditors);
1487       };
1488       const undo = () => {
1489         for (const editor of newEditors) {
1490           editor.remove();
1491         }
1492       };
1493       this.addCommands({ cmd, undo, mustExec: true });
1494     } catch (ex) {
1495       warn(`paste: "${ex.message}".`);
1496     }
1497   }
1498 
1499   /**
1500    * Keydown callback.
1501    * @param {KeyboardEvent} event
1502    */
1503   keydown(event) {
1504     if (!this.isShiftKeyDown && event.key === "Shift") {
1505       this.isShiftKeyDown = true;
1506     }
1507     if (
1508       this.#mode !== AnnotationEditorType.NONE &&
1509       !this.isEditorHandlingKeyboard
1510     ) {
1511       AnnotationEditorUIManager._keyboardManager.exec(this, event);
1512     }
1513   }
1514 
1515   /**
1516    * Keyup callback.
1517    * @param {KeyboardEvent} event
1518    */
1519   keyup(event) {
1520     if (this.isShiftKeyDown && event.key === "Shift") {
1521       this.isShiftKeyDown = false;
1522       if (this.#highlightWhenShiftUp) {
1523         this.#highlightWhenShiftUp = false;
1524         this.#onSelectEnd("main_toolbar");
1525       }
1526     }
1527   }
1528 
1529   /**
1530    * Execute an action for a given name.
1531    * For example, the user can click on the "Undo" entry in the context menu
1532    * and it'll trigger the undo action.
1533    */
1534   onEditingAction({ name }) {
1535     switch (name) {
1536       case "undo":
1537       case "redo":
1538       case "delete":
1539       case "selectAll":
1540         this[name]();
1541         break;
1542       case "highlightSelection":
1543         this.highlightSelection("context_menu");
1544         break;
1545     }
1546   }
1547 
1548   /**
1549    * Update the different possible states of this manager, e.g. is there
1550    * something to undo, redo, ...
1551    * @param {Object} details
1552    */
1553   #dispatchUpdateStates(details) {
1554     const hasChanged = Object.entries(details).some(
1555       ([key, value]) => this.#previousStates[key] !== value
1556     );
1557 
1558     if (hasChanged) {
1559       this._eventBus.dispatch("annotationeditorstateschanged", {
1560         source: this,
1561         details: Object.assign(this.#previousStates, details),
1562       });
1563       // We could listen on our own event but it sounds like a bit weird and
1564       // it's a way to simpler to handle that stuff here instead of having to
1565       // add something in every place where an editor can be unselected.
1566       if (
1567         this.#mode === AnnotationEditorType.HIGHLIGHT &&
1568         details.hasSelectedEditor === false
1569       ) {
1570         this.#dispatchUpdateUI([
1571           [AnnotationEditorParamsType.HIGHLIGHT_FREE, true],
1572         ]);
1573       }
1574     }
1575   }
1576 
1577   #dispatchUpdateUI(details) {
1578     this._eventBus.dispatch("annotationeditorparamschanged", {
1579       source: this,
1580       details,
1581     });
1582   }
1583 
1584   /**
1585    * Set the editing state.
1586    * It can be useful to temporarily disable it when the user is editing a
1587    * FreeText annotation.
1588    * @param {boolean} isEditing
1589    */
1590   setEditingState(isEditing) {
1591     if (isEditing) {
1592       this.#addFocusManager();
1593       this.#addCopyPasteListeners();
1594       this.#dispatchUpdateStates({
1595         isEditing: this.#mode !== AnnotationEditorType.NONE,
1596         isEmpty: this.#isEmpty(),
1597         hasSomethingToUndo: this.#commandManager.hasSomethingToUndo(),
1598         hasSomethingToRedo: this.#commandManager.hasSomethingToRedo(),
1599         hasSelectedEditor: false,
1600       });
1601     } else {
1602       this.#removeFocusManager();
1603       this.#removeCopyPasteListeners();
1604       this.#dispatchUpdateStates({
1605         isEditing: false,
1606       });
1607       this.disableUserSelect(false);
1608     }
1609   }
1610 
1611   registerEditorTypes(types) {
1612     if (this.#editorTypes) {
1613       return;
1614     }
1615     this.#editorTypes = types;
1616     for (const editorType of this.#editorTypes) {
1617       this.#dispatchUpdateUI(editorType.defaultPropertiesToUpdate);
1618     }
1619   }
1620 
1621   /**
1622    * Get an id.
1623    * @returns {string}
1624    */
1625   getId() {
1626     return this.#idManager.id;
1627   }
1628 
1629   get currentLayer() {
1630     return this.#allLayers.get(this.#currentPageIndex);
1631   }
1632 
1633   getLayer(pageIndex) {
1634     return this.#allLayers.get(pageIndex);
1635   }
1636 
1637   get currentPageIndex() {
1638     return this.#currentPageIndex;
1639   }
1640 
1641   /**
1642    * Add a new layer for a page which will contains the editors.
1643    * @param {AnnotationEditorLayer} layer
1644    */
1645   addLayer(layer) {
1646     this.#allLayers.set(layer.pageIndex, layer);
1647     if (this.#isEnabled) {
1648       layer.enable();
1649     } else {
1650       layer.disable();
1651     }
1652   }
1653 
1654   /**
1655    * Remove a layer.
1656    * @param {AnnotationEditorLayer} layer
1657    */
1658   removeLayer(layer) {
1659     this.#allLayers.delete(layer.pageIndex);
1660   }
1661 
1662   /**
1663    * Change the editor mode (None, FreeText, Ink, ...)
1664    * @param {number} mode
1665    * @param {string|null} editId
1666    * @param {boolean} [isFromKeyboard] - true if the mode change is due to a
1667    *   keyboard action.
1668    */
1669   async updateMode(mode, editId = null, isFromKeyboard = false) {
1670     if (this.#mode === mode) {
1671       return;
1672     }
1673 
1674     if (this.#updateModeCapability) {
1675       await this.#updateModeCapability.promise;
1676       if (!this.#updateModeCapability) {
1677         // This ui manager has been destroyed.
1678         return;
1679       }
1680     }
1681 
1682     this.#updateModeCapability = Promise.withResolvers();
1683 
1684     this.#mode = mode;
1685     if (mode === AnnotationEditorType.NONE) {
1686       this.setEditingState(false);
1687       this.#disableAll();
1688 
1689       this._editorUndoBar?.hide();
1690 
1691       this.#updateModeCapability.resolve();
1692       return;
1693     }
1694     if (mode === AnnotationEditorType.SIGNATURE) {
1695       await this.#signatureManager?.loadSignatures();
1696     }
1697     this.setEditingState(true);
1698     await this.#enableAll();
1699     this.unselectAll();
1700     for (const layer of this.#allLayers.values()) {
1701       layer.updateMode(mode);
1702     }
1703     if (!editId) {
1704       if (isFromKeyboard) {
1705         this.addNewEditorFromKeyboard();
1706       }
1707 
1708       this.#updateModeCapability.resolve();
1709       return;
1710     }
1711 
1712     for (const editor of this.#allEditors.values()) {
1713       if (editor.annotationElementId === editId) {
1714         this.setSelected(editor);
1715         editor.enterInEditMode();
1716       } else {
1717         editor.unselect();
1718       }
1719     }
1720 
1721     this.#updateModeCapability.resolve();
1722   }
1723 
1724   addNewEditorFromKeyboard() {
1725     if (this.currentLayer.canCreateNewEmptyEditor()) {
1726       this.currentLayer.addNewEditor();
1727     }
1728   }
1729 
1730   /**
1731    * Update the toolbar if it's required to reflect the tool currently used.
1732    * @param {number} mode
1733    * @returns {undefined}
1734    */
1735   updateToolbar(mode) {
1736     if (mode === this.#mode) {
1737       return;
1738     }
1739     this._eventBus.dispatch("switchannotationeditormode", {
1740       source: this,
1741       mode,
1742     });
1743   }
1744 
1745   /**
1746    * Update a parameter in the current editor or globally.
1747    * @param {number} type
1748    * @param {*} value
1749    */
1750   updateParams(type, value) {
1751     if (!this.#editorTypes) {
1752       return;
1753     }
1754 
1755     switch (type) {
1756       case AnnotationEditorParamsType.CREATE:
1757         this.currentLayer.addNewEditor(value);
1758         return;
1759       case AnnotationEditorParamsType.HIGHLIGHT_DEFAULT_COLOR:
1760         this.#mainHighlightColorPicker?.updateColor(value);
1761         break;
1762       case AnnotationEditorParamsType.HIGHLIGHT_SHOW_ALL:
1763         this._eventBus.dispatch("reporttelemetry", {
1764           source: this,
1765           details: {
1766             type: "editing",
1767             data: {
1768               type: "highlight",
1769               action: "toggle_visibility",
1770             },
1771           },
1772         });
1773         (this.#showAllStates ||= new Map()).set(type, value);
1774         this.showAllEditors("highlight", value);
1775         break;
1776     }
1777 
1778     for (const editor of this.#selectedEditors) {
1779       editor.updateParams(type, value);
1780     }
1781 
1782     for (const editorType of this.#editorTypes) {
1783       editorType.updateDefaultParams(type, value);
1784     }
1785   }
1786 
1787   showAllEditors(type, visible, updateButton = false) {
1788     for (const editor of this.#allEditors.values()) {
1789       if (editor.editorType === type) {
1790         editor.show(visible);
1791       }
1792     }
1793     const state =
1794       this.#showAllStates?.get(AnnotationEditorParamsType.HIGHLIGHT_SHOW_ALL) ??
1795       true;
1796     if (state !== visible) {
1797       this.#dispatchUpdateUI([
1798         [AnnotationEditorParamsType.HIGHLIGHT_SHOW_ALL, visible],
1799       ]);
1800     }
1801   }
1802 
1803   enableWaiting(mustWait = false) {
1804     if (this.#isWaiting === mustWait) {
1805       return;
1806     }
1807     this.#isWaiting = mustWait;
1808     for (const layer of this.#allLayers.values()) {
1809       if (mustWait) {
1810         layer.disableClick();
1811       } else {
1812         layer.enableClick();
1813       }
1814       layer.div.classList.toggle("waiting", mustWait);
1815     }
1816   }
1817 
1818   /**
1819    * Enable all the layers.
1820    */
1821   async #enableAll() {
1822     if (!this.#isEnabled) {
1823       this.#isEnabled = true;
1824       const promises = [];
1825       for (const layer of this.#allLayers.values()) {
1826         promises.push(layer.enable());
1827       }
1828       await Promise.all(promises);
1829       for (const editor of this.#allEditors.values()) {
1830         editor.enable();
1831       }
1832     }
1833   }
1834 
1835   /**
1836    * Disable all the layers.
1837    */
1838   #disableAll() {
1839     this.unselectAll();
1840     if (this.#isEnabled) {
1841       this.#isEnabled = false;
1842       for (const layer of this.#allLayers.values()) {
1843         layer.disable();
1844       }
1845       for (const editor of this.#allEditors.values()) {
1846         editor.disable();
1847       }
1848     }
1849   }
1850 
1851   /**
1852    * Get all the editors belonging to a given page.
1853    * @param {number} pageIndex
1854    * @returns {Array<AnnotationEditor>}
1855    */
1856   getEditors(pageIndex) {
1857     const editors = [];
1858     for (const editor of this.#allEditors.values()) {
1859       if (editor.pageIndex === pageIndex) {
1860         editors.push(editor);
1861       }
1862     }
1863     return editors;
1864   }
1865 
1866   /**
1867    * Get an editor with the given id.
1868    * @param {string} id
1869    * @returns {AnnotationEditor}
1870    */
1871   getEditor(id) {
1872     return this.#allEditors.get(id);
1873   }
1874 
1875   /**
1876    * Add a new editor.
1877    * @param {AnnotationEditor} editor
1878    */
1879   addEditor(editor) {
1880     this.#allEditors.set(editor.id, editor);
1881   }
1882 
1883   /**
1884    * Remove an editor.
1885    * @param {AnnotationEditor} editor
1886    */
1887   removeEditor(editor) {
1888     if (editor.div.contains(document.activeElement)) {
1889       if (this.#focusMainContainerTimeoutId) {
1890         clearTimeout(this.#focusMainContainerTimeoutId);
1891       }
1892       this.#focusMainContainerTimeoutId = setTimeout(() => {
1893         // When the div is removed from DOM the focus can move on the
1894         // document.body, so we need to move it back to the main container.
1895         this.focusMainContainer();
1896         this.#focusMainContainerTimeoutId = null;
1897       }, 0);
1898     }
1899     this.#allEditors.delete(editor.id);
1900     if (editor.annotationElementId) {
1901       this.#missingCanvases?.delete(editor.annotationElementId);
1902     }
1903     this.unselect(editor);
1904     if (
1905       !editor.annotationElementId ||
1906       !this.#deletedAnnotationsElementIds.has(editor.annotationElementId)
1907     ) {
1908       this.#annotationStorage?.remove(editor.id);
1909     }
1910   }
1911 
1912   /**
1913    * The annotation element with the given id has been deleted.
1914    * @param {AnnotationEditor} editor
1915    */
1916   addDeletedAnnotationElement(editor) {
1917     this.#deletedAnnotationsElementIds.add(editor.annotationElementId);
1918     this.addChangedExistingAnnotation(editor);
1919     editor.deleted = true;
1920   }
1921 
1922   /**
1923    * Check if the annotation element with the given id has been deleted.
1924    * @param {string} annotationElementId
1925    * @returns {boolean}
1926    */
1927   isDeletedAnnotationElement(annotationElementId) {
1928     return this.#deletedAnnotationsElementIds.has(annotationElementId);
1929   }
1930 
1931   /**
1932    * The annotation element with the given id have been restored.
1933    * @param {AnnotationEditor} editor
1934    */
1935   removeDeletedAnnotationElement(editor) {
1936     this.#deletedAnnotationsElementIds.delete(editor.annotationElementId);
1937     this.removeChangedExistingAnnotation(editor);
1938     editor.deleted = false;
1939   }
1940 
1941   /**
1942    * Add an editor to the layer it belongs to or add it to the global map.
1943    * @param {AnnotationEditor} editor
1944    */
1945   #addEditorToLayer(editor) {
1946     const layer = this.#allLayers.get(editor.pageIndex);
1947     if (layer) {
1948       layer.addOrRebuild(editor);
1949     } else {
1950       this.addEditor(editor);
1951       this.addToAnnotationStorage(editor);
1952     }
1953   }
1954 
1955   /**
1956    * Set the given editor as the active one.
1957    * @param {AnnotationEditor} editor
1958    */
1959   setActiveEditor(editor) {
1960     if (this.#activeEditor === editor) {
1961       return;
1962     }
1963 
1964     this.#activeEditor = editor;
1965     if (editor) {
1966       this.#dispatchUpdateUI(editor.propertiesToUpdate);
1967     }
1968   }
1969 
1970   get #lastSelectedEditor() {
1971     let ed = null;
1972     for (ed of this.#selectedEditors) {
1973       // Iterate to get the last element.
1974     }
1975     return ed;
1976   }
1977 
1978   /**
1979    * Update the UI of the active editor.
1980    * @param {AnnotationEditor} editor
1981    */
1982   updateUI(editor) {
1983     if (this.#lastSelectedEditor === editor) {
1984       this.#dispatchUpdateUI(editor.propertiesToUpdate);
1985     }
1986   }
1987 
1988   updateUIForDefaultProperties(editorType) {
1989     this.#dispatchUpdateUI(editorType.defaultPropertiesToUpdate);
1990   }
1991 
1992   /**
1993    * Add or remove an editor the current selection.
1994    * @param {AnnotationEditor} editor
1995    */
1996   toggleSelected(editor) {
1997     if (this.#selectedEditors.has(editor)) {
1998       this.#selectedEditors.delete(editor);
1999       editor.unselect();
2000       this.#dispatchUpdateStates({
2001         hasSelectedEditor: this.hasSelection,
2002       });
2003       return;
2004     }
2005     this.#selectedEditors.add(editor);
2006     editor.select();
2007     this.#dispatchUpdateUI(editor.propertiesToUpdate);
2008     this.#dispatchUpdateStates({
2009       hasSelectedEditor: true,
2010     });
2011   }
2012 
2013   /**
2014    * Set the last selected editor.
2015    * @param {AnnotationEditor} editor
2016    */
2017   setSelected(editor) {
2018     this.#currentDrawingSession?.commitOrRemove();
2019     for (const ed of this.#selectedEditors) {
2020       if (ed !== editor) {
2021         ed.unselect();
2022       }
2023     }
2024     this.#selectedEditors.clear();
2025 
2026     this.#selectedEditors.add(editor);
2027     editor.select();
2028     this.#dispatchUpdateUI(editor.propertiesToUpdate);
2029     this.#dispatchUpdateStates({
2030       hasSelectedEditor: true,
2031     });
2032   }
2033 
2034   /**
2035    * Check if the editor is selected.
2036    * @param {AnnotationEditor} editor
2037    */
2038   isSelected(editor) {
2039     return this.#selectedEditors.has(editor);
2040   }
2041 
2042   get firstSelectedEditor() {
2043     return this.#selectedEditors.values().next().value;
2044   }
2045 
2046   /**
2047    * Unselect an editor.
2048    * @param {AnnotationEditor} editor
2049    */
2050   unselect(editor) {
2051     editor.unselect();
2052     this.#selectedEditors.delete(editor);
2053     this.#dispatchUpdateStates({
2054       hasSelectedEditor: this.hasSelection,
2055     });
2056   }
2057 
2058   get hasSelection() {
2059     return this.#selectedEditors.size !== 0;
2060   }
2061 
2062   get isEnterHandled() {
2063     return (
2064       this.#selectedEditors.size === 1 &&
2065       this.firstSelectedEditor.isEnterHandled
2066     );
2067   }
2068 
2069   /**
2070    * Undo the last command.
2071    */
2072   undo() {
2073     this.#commandManager.undo();
2074     this.#dispatchUpdateStates({
2075       hasSomethingToUndo: this.#commandManager.hasSomethingToUndo(),
2076       hasSomethingToRedo: true,
2077       isEmpty: this.#isEmpty(),
2078     });
2079     this._editorUndoBar?.hide();
2080   }
2081 
2082   /**
2083    * Redo the last undoed command.
2084    */
2085   redo() {
2086     this.#commandManager.redo();
2087     this.#dispatchUpdateStates({
2088       hasSomethingToUndo: true,
2089       hasSomethingToRedo: this.#commandManager.hasSomethingToRedo(),
2090       isEmpty: this.#isEmpty(),
2091     });
2092   }
2093 
2094   /**
2095    * Add a command to execute (cmd) and another one to undo it.
2096    * @param {Object} params
2097    */
2098   addCommands(params) {
2099     this.#commandManager.add(params);
2100     this.#dispatchUpdateStates({
2101       hasSomethingToUndo: true,
2102       hasSomethingToRedo: false,
2103       isEmpty: this.#isEmpty(),
2104     });
2105   }
2106 
2107   cleanUndoStack(type) {
2108     this.#commandManager.cleanType(type);
2109   }
2110 
2111   #isEmpty() {
2112     if (this.#allEditors.size === 0) {
2113       return true;
2114     }
2115 
2116     if (this.#allEditors.size === 1) {
2117       for (const editor of this.#allEditors.values()) {
2118         return editor.isEmpty();
2119       }
2120     }
2121 
2122     return false;
2123   }
2124 
2125   /**
2126    * Delete the current editor or all.
2127    */
2128   delete() {
2129     this.commitOrRemove();
2130     const drawingEditor = this.currentLayer?.endDrawingSession(
2131       /* isAborted = */ true
2132     );
2133     if (!this.hasSelection && !drawingEditor) {
2134       return;
2135     }
2136 
2137     const editors = drawingEditor
2138       ? [drawingEditor]
2139       : [...this.#selectedEditors];
2140     const cmd = () => {
2141       this._editorUndoBar?.show(
2142         undo,
2143         editors.length === 1 ? editors[0].editorType : editors.length
2144       );
2145       for (const editor of editors) {
2146         editor.remove();
2147       }
2148     };
2149     const undo = () => {
2150       for (const editor of editors) {
2151         this.#addEditorToLayer(editor);
2152       }
2153     };
2154 
2155     this.addCommands({ cmd, undo, mustExec: true });
2156   }
2157 
2158   commitOrRemove() {
2159     // An editor is being edited so just commit it.
2160     this.#activeEditor?.commitOrRemove();
2161   }
2162 
2163   hasSomethingToControl() {
2164     return this.#activeEditor || this.hasSelection;
2165   }
2166 
2167   /**
2168    * Select the editors.
2169    * @param {Array<AnnotationEditor>} editors
2170    */
2171   #selectEditors(editors) {
2172     for (const editor of this.#selectedEditors) {
2173       editor.unselect();
2174     }
2175     this.#selectedEditors.clear();
2176     for (const editor of editors) {
2177       if (editor.isEmpty()) {
2178         continue;
2179       }
2180       this.#selectedEditors.add(editor);
2181       editor.select();
2182     }
2183     this.#dispatchUpdateStates({ hasSelectedEditor: this.hasSelection });
2184   }
2185 
2186   /**
2187    * Select all the editors.
2188    */
2189   selectAll() {
2190     for (const editor of this.#selectedEditors) {
2191       editor.commit();
2192     }
2193     this.#selectEditors(this.#allEditors.values());
2194   }
2195 
2196   /**
2197    * Unselect all the selected editors.
2198    */
2199   unselectAll() {
2200     if (this.#activeEditor) {
2201       // An editor is being edited so just commit it.
2202       this.#activeEditor.commitOrRemove();
2203       if (this.#mode !== AnnotationEditorType.NONE) {
2204         // If the mode is NONE, we want to really unselect the editor, hence we
2205         // mustn't return here.
2206         return;
2207       }
2208     }
2209 
2210     if (this.#currentDrawingSession?.commitOrRemove()) {
2211       return;
2212     }
2213 
2214     if (!this.hasSelection) {
2215       return;
2216     }
2217     for (const editor of this.#selectedEditors) {
2218       editor.unselect();
2219     }
2220     this.#selectedEditors.clear();
2221     this.#dispatchUpdateStates({
2222       hasSelectedEditor: false,
2223     });
2224   }
2225 
2226   translateSelectedEditors(x, y, noCommit = false) {
2227     if (!noCommit) {
2228       this.commitOrRemove();
2229     }
2230     if (!this.hasSelection) {
2231       return;
2232     }
2233 
2234     this.#translation[0] += x;
2235     this.#translation[1] += y;
2236     const [totalX, totalY] = this.#translation;
2237     const editors = [...this.#selectedEditors];
2238 
2239     // We don't want to have an undo/redo for each translation so we wait a bit
2240     // before adding the command to the command manager.
2241     const TIME_TO_WAIT = 1000;
2242 
2243     if (this.#translationTimeoutId) {
2244       clearTimeout(this.#translationTimeoutId);
2245     }
2246 
2247     this.#translationTimeoutId = setTimeout(() => {
2248       this.#translationTimeoutId = null;
2249       this.#translation[0] = this.#translation[1] = 0;
2250 
2251       this.addCommands({
2252         cmd: () => {
2253           for (const editor of editors) {
2254             if (this.#allEditors.has(editor.id)) {
2255               editor.translateInPage(totalX, totalY);
2256               editor.translationDone();
2257             }
2258           }
2259         },
2260         undo: () => {
2261           for (const editor of editors) {
2262             if (this.#allEditors.has(editor.id)) {
2263               editor.translateInPage(-totalX, -totalY);
2264               editor.translationDone();
2265             }
2266           }
2267         },
2268         mustExec: false,
2269       });
2270     }, TIME_TO_WAIT);
2271 
2272     for (const editor of editors) {
2273       editor.translateInPage(x, y);
2274       editor.translationDone();
2275     }
2276   }
2277 
2278   /**
2279    * Set up the drag session for moving the selected editors.
2280    */
2281   setUpDragSession() {
2282     // Note: don't use any references to the editor's parent which can be null
2283     // if the editor belongs to a destroyed page.
2284     if (!this.hasSelection) {
2285       return;
2286     }
2287     // Avoid to have spurious text selection in the text layer when dragging.
2288     this.disableUserSelect(true);
2289     this.#draggingEditors = new Map();
2290     for (const editor of this.#selectedEditors) {
2291       this.#draggingEditors.set(editor, {
2292         savedX: editor.x,
2293         savedY: editor.y,
2294         savedPageIndex: editor.pageIndex,
2295         newX: 0,
2296         newY: 0,
2297         newPageIndex: -1,
2298       });
2299     }
2300   }
2301 
2302   /**
2303    * Ends the drag session.
2304    * @returns {boolean} true if at least one editor has been moved.
2305    */
2306   endDragSession() {
2307     if (!this.#draggingEditors) {
2308       return false;
2309     }
2310     this.disableUserSelect(false);
2311     const map = this.#draggingEditors;
2312     this.#draggingEditors = null;
2313     let mustBeAddedInUndoStack = false;
2314 
2315     for (const [{ x, y, pageIndex }, value] of map) {
2316       value.newX = x;
2317       value.newY = y;
2318       value.newPageIndex = pageIndex;
2319       mustBeAddedInUndoStack ||=
2320         x !== value.savedX ||
2321         y !== value.savedY ||
2322         pageIndex !== value.savedPageIndex;
2323     }
2324 
2325     if (!mustBeAddedInUndoStack) {
2326       return false;
2327     }
2328 
2329     const move = (editor, x, y, pageIndex) => {
2330       if (this.#allEditors.has(editor.id)) {
2331         // The editor can be undone/redone on a page which is not visible (and
2332         // which potentially has no annotation editor layer), hence we need to
2333         // use the pageIndex instead of the parent.
2334         const parent = this.#allLayers.get(pageIndex);
2335         if (parent) {
2336           editor._setParentAndPosition(parent, x, y);
2337         } else {
2338           editor.pageIndex = pageIndex;
2339           editor.x = x;
2340           editor.y = y;
2341         }
2342       }
2343     };
2344 
2345     this.addCommands({
2346       cmd: () => {
2347         for (const [editor, { newX, newY, newPageIndex }] of map) {
2348           move(editor, newX, newY, newPageIndex);
2349         }
2350       },
2351       undo: () => {
2352         for (const [editor, { savedX, savedY, savedPageIndex }] of map) {
2353           move(editor, savedX, savedY, savedPageIndex);
2354         }
2355       },
2356       mustExec: true,
2357     });
2358 
2359     return true;
2360   }
2361 
2362   /**
2363    * Drag the set of selected editors.
2364    * @param {number} tx
2365    * @param {number} ty
2366    */
2367   dragSelectedEditors(tx, ty) {
2368     if (!this.#draggingEditors) {
2369       return;
2370     }
2371     for (const editor of this.#draggingEditors.keys()) {
2372       editor.drag(tx, ty);
2373     }
2374   }
2375 
2376   /**
2377    * Rebuild the editor (usually on undo/redo actions) on a potentially
2378    * non-rendered page.
2379    * @param {AnnotationEditor} editor
2380    */
2381   rebuild(editor) {
2382     if (editor.parent === null) {
2383       const parent = this.getLayer(editor.pageIndex);
2384       if (parent) {
2385         parent.changeParent(editor);
2386         parent.addOrRebuild(editor);
2387       } else {
2388         this.addEditor(editor);
2389         this.addToAnnotationStorage(editor);
2390         editor.rebuild();
2391       }
2392     } else {
2393       editor.parent.addOrRebuild(editor);
2394     }
2395   }
2396 
2397   get isEditorHandlingKeyboard() {
2398     return (
2399       this.getActive()?.shouldGetKeyboardEvents() ||
2400       (this.#selectedEditors.size === 1 &&
2401         this.firstSelectedEditor.shouldGetKeyboardEvents())
2402     );
2403   }
2404 
2405   /**
2406    * Is the current editor the one passed as argument?
2407    * @param {AnnotationEditor} editor
2408    * @returns
2409    */
2410   isActive(editor) {
2411     return this.#activeEditor === editor;
2412   }
2413 
2414   /**
2415    * Get the current active editor.
2416    * @returns {AnnotationEditor|null}
2417    */
2418   getActive() {
2419     return this.#activeEditor;
2420   }
2421 
2422   /**
2423    * Get the current editor mode.
2424    * @returns {number}
2425    */
2426   getMode() {
2427     return this.#mode;
2428   }
2429 
2430   get imageManager() {
2431     return shadow(this, "imageManager", new ImageManager());
2432   }
2433 
2434   getSelectionBoxes(textLayer) {
2435     if (!textLayer) {
2436       return null;
2437     }
2438     const selection = document.getSelection();
2439     for (let i = 0, ii = selection.rangeCount; i < ii; i++) {
2440       if (
2441         !textLayer.contains(selection.getRangeAt(i).commonAncestorContainer)
2442       ) {
2443         return null;
2444       }
2445     }
2446 
2447     const {
2448       x: layerX,
2449       y: layerY,
2450       width: parentWidth,
2451       height: parentHeight,
2452     } = textLayer.getBoundingClientRect();
2453 
2454     // We must rotate the boxes because we want to have them in the non-rotated
2455     // page coordinates.
2456     let rotator;
2457     switch (textLayer.getAttribute("data-main-rotation")) {
2458       case "90":
2459         rotator = (x, y, w, h) => ({
2460           x: (y - layerY) / parentHeight,
2461           y: 1 - (x + w - layerX) / parentWidth,
2462           width: h / parentHeight,
2463           height: w / parentWidth,
2464         });
2465         break;
2466       case "180":
2467         rotator = (x, y, w, h) => ({
2468           x: 1 - (x + w - layerX) / parentWidth,
2469           y: 1 - (y + h - layerY) / parentHeight,
2470           width: w / parentWidth,
2471           height: h / parentHeight,
2472         });
2473         break;
2474       case "270":
2475         rotator = (x, y, w, h) => ({
2476           x: 1 - (y + h - layerY) / parentHeight,
2477           y: (x - layerX) / parentWidth,
2478           width: h / parentHeight,
2479           height: w / parentWidth,
2480         });
2481         break;
2482       default:
2483         rotator = (x, y, w, h) => ({
2484           x: (x - layerX) / parentWidth,
2485           y: (y - layerY) / parentHeight,
2486           width: w / parentWidth,
2487           height: h / parentHeight,
2488         });
2489         break;
2490     }
2491 
2492     const boxes = [];
2493     for (let i = 0, ii = selection.rangeCount; i < ii; i++) {
2494       const range = selection.getRangeAt(i);
2495       if (range.collapsed) {
2496         continue;
2497       }
2498       for (const { x, y, width, height } of range.getClientRects()) {
2499         if (width === 0 || height === 0) {
2500           continue;
2501         }
2502         boxes.push(rotator(x, y, width, height));
2503       }
2504     }
2505     return boxes.length === 0 ? null : boxes;
2506   }
2507 
2508   addChangedExistingAnnotation({ annotationElementId, id }) {
2509     (this.#changedExistingAnnotations ||= new Map()).set(
2510       annotationElementId,
2511       id
2512     );
2513   }
2514 
2515   removeChangedExistingAnnotation({ annotationElementId }) {
2516     this.#changedExistingAnnotations?.delete(annotationElementId);
2517   }
2518 
2519   renderAnnotationElement(annotation) {
2520     const editorId = this.#changedExistingAnnotations?.get(annotation.data.id);
2521     if (!editorId) {
2522       return;
2523     }
2524     const editor = this.#annotationStorage.getRawValue(editorId);
2525     if (!editor) {
2526       return;
2527     }
2528     if (this.#mode === AnnotationEditorType.NONE && !editor.hasBeenModified) {
2529       return;
2530     }
2531     editor.renderAnnotationElement(annotation);
2532   }
2533 
2534   setMissingCanvas(annotationId, annotationElementId, canvas) {
2535     const editor = this.#missingCanvases?.get(annotationId);
2536     if (!editor) {
2537       return;
2538     }
2539     editor.setCanvas(annotationElementId, canvas);
2540     this.#missingCanvases.delete(annotationId);
2541   }
2542 
2543   addMissingCanvas(annotationId, editor) {
2544     (this.#missingCanvases ||= new Map()).set(annotationId, editor);
2545   }
2546 }
2547 
2548 export {
2549   AnnotationEditorUIManager,
2550   bindEvents,
2551   ColorManager,
2552   CommandManager,
2553   KeyboardManager,
2554 };
File:
src/display/touch_manager.js
1 /* Copyright 2024 Mozilla Foundation
2  *
3  * Licensed under the Apache License, Version 2.0 (the "License");
4  * you may not use this file except in compliance with the License.
5  * You may obtain a copy of the License at
6  *
7  *     http://www.apache.org/licenses/LICENSE-2.0
8  *
9  * Unless required by applicable law or agreed to in writing, software
10  * distributed under the License is distributed on an "AS IS" BASIS,
11  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
12  * See the License for the specific language governing permissions and
13  * limitations under the License.
14  */
15 
16 import { OutputScale, stopEvent } from "./display_utils.js";
17 
18 class TouchManager {
19   #container;
20 
21   #isPinching = false;
22 
23   #isPinchingStopped = null;
24 
25   #isPinchingDisabled;
26 
27   #onPinchStart;
28 
29   #onPinching;
30 
31   #onPinchEnd;
32 
33   #pointerDownAC = null;
34 
35   #signal;
36 
37   #touchInfo = null;
38 
39   #touchManagerAC;
40 
41   #touchMoveAC = null;
42 
43   constructor({
44     container,
45     isPinchingDisabled = null,
46     isPinchingStopped = null,
47     onPinchStart = null,
48     onPinching = null,
49     onPinchEnd = null,
50     signal,
51   }) {
52     this.#container = container;
53     this.#isPinchingStopped = isPinchingStopped;
54     this.#isPinchingDisabled = isPinchingDisabled;
55     this.#onPinchStart = onPinchStart;
56     this.#onPinching = onPinching;
57     this.#onPinchEnd = onPinchEnd;
58     this.#touchManagerAC = new AbortController();
59     this.#signal = AbortSignal.any([signal, this.#touchManagerAC.signal]);
60 
61     container.addEventListener("touchstart", this.#onTouchStart.bind(this), {
62       passive: false,
63       signal: this.#signal,
64     });
65   }
66 
67   /**
68    * NOTE: Don't shadow this value since `devicePixelRatio` may change if the
69    * window resolution changes, e.g. if the viewer is moved to another monitor.
70    */
71   get MIN_TOUCH_DISTANCE_TO_PINCH() {
72     // The 35 is coming from:
73     //  https://searchfox.org/mozilla-central/source/gfx/layers/apz/src/GestureEventListener.cpp#36
74     //
75     // The properties TouchEvent::screenX/Y are in screen CSS pixels:
76     //  https://developer.mozilla.org/en-US/docs/Web/API/Touch/screenX#examples
77     // MIN_TOUCH_DISTANCE_TO_PINCH is in CSS pixels.
78     return 35 / OutputScale.pixelRatio;
79   }
80 
81   #onTouchStart(evt) {
82     if (this.#isPinchingDisabled?.()) {
83       return;
84     }
85 
86     if (evt.touches.length === 1) {
87       if (this.#pointerDownAC) {
88         return;
89       }
90       const pointerDownAC = (this.#pointerDownAC = new AbortController());
91       const signal = AbortSignal.any([this.#signal, pointerDownAC.signal]);
92       const container = this.#container;
93 
94       // We want to have the events at the capture phase to make sure we can
95       // cancel them.
96       const opts = { capture: true, signal, passive: false };
97       const cancelPointerDown = e => {
98         if (e.pointerType === "touch") {
99           this.#pointerDownAC?.abort();
100           this.#pointerDownAC = null;
101         }
102       };
103       container.addEventListener(
104         "pointerdown",
105         e => {
106           if (e.pointerType === "touch") {
107             // This is the second finger so we don't want it select something
108             // or whatever.
109             stopEvent(e);
110             cancelPointerDown(e);
111           }
112         },
113         opts
114       );
115       container.addEventListener("pointerup", cancelPointerDown, opts);
116       container.addEventListener("pointercancel", cancelPointerDown, opts);
117       return;
118     }
119 
120     if (!this.#touchMoveAC) {
121       this.#touchMoveAC = new AbortController();
122       const signal = AbortSignal.any([this.#signal, this.#touchMoveAC.signal]);
123       const container = this.#container;
124 
125       const opt = { signal, capture: false, passive: false };
126       container.addEventListener(
127         "touchmove",
128         this.#onTouchMove.bind(this),
129         opt
130       );
131       const onTouchEnd = this.#onTouchEnd.bind(this);
132       container.addEventListener("touchend", onTouchEnd, opt);
133       container.addEventListener("touchcancel", onTouchEnd, opt);
134 
135       opt.capture = true;
136       container.addEventListener("pointerdown", stopEvent, opt);
137       container.addEventListener("pointermove", stopEvent, opt);
138       container.addEventListener("pointercancel", stopEvent, opt);
139       container.addEventListener("pointerup", stopEvent, opt);
140       this.#onPinchStart?.();
141     }
142 
143     stopEvent(evt);
144 
145     if (evt.touches.length !== 2 || this.#isPinchingStopped?.()) {
146       this.#touchInfo = null;
147       return;
148     }
149 
150     let [touch0, touch1] = evt.touches;
151     if (touch0.identifier > touch1.identifier) {
152       [touch0, touch1] = [touch1, touch0];
153     }
154     this.#touchInfo = {
155       touch0X: touch0.screenX,
156       touch0Y: touch0.screenY,
157       touch1X: touch1.screenX,
158       touch1Y: touch1.screenY,
159     };
160   }
161 
162   #onTouchMove(evt) {
163     if (!this.#touchInfo || evt.touches.length !== 2) {
164       return;
165     }
166 
167     stopEvent(evt);
168 
169     let [touch0, touch1] = evt.touches;
170     if (touch0.identifier > touch1.identifier) {
171       [touch0, touch1] = [touch1, touch0];
172     }
173     const { screenX: screen0X, screenY: screen0Y } = touch0;
174     const { screenX: screen1X, screenY: screen1Y } = touch1;
175     const touchInfo = this.#touchInfo;
176     const {
177       touch0X: pTouch0X,
178       touch0Y: pTouch0Y,
179       touch1X: pTouch1X,
180       touch1Y: pTouch1Y,
181     } = touchInfo;
182 
183     const prevGapX = pTouch1X - pTouch0X;
184     const prevGapY = pTouch1Y - pTouch0Y;
185     const currGapX = screen1X - screen0X;
186     const currGapY = screen1Y - screen0Y;
187 
188     const distance = Math.hypot(currGapX, currGapY) || 1;
189     const pDistance = Math.hypot(prevGapX, prevGapY) || 1;
190     if (
191       !this.#isPinching &&
192       Math.abs(pDistance - distance) <= TouchManager.MIN_TOUCH_DISTANCE_TO_PINCH
193     ) {
194       return;
195     }
196 
197     touchInfo.touch0X = screen0X;
198     touchInfo.touch0Y = screen0Y;
199     touchInfo.touch1X = screen1X;
200     touchInfo.touch1Y = screen1Y;
201 
202     if (!this.#isPinching) {
203       // Start pinching.
204       this.#isPinching = true;
205 
206       // We return here else the first pinch is a bit too much
207       return;
208     }
209 
210     const origin = [(screen0X + screen1X) / 2, (screen0Y + screen1Y) / 2];
211     this.#onPinching?.(origin, pDistance, distance);
212   }
213 
214   #onTouchEnd(evt) {
215     if (evt.touches.length >= 2) {
216       return;
217     }
218     this.#touchMoveAC.abort();
219     this.#touchMoveAC = null;
220     this.#onPinchEnd?.();
221 
222     if (!this.#touchInfo) {
223       return;
224     }
225     stopEvent(evt);
226     this.#touchInfo = null;
227     this.#isPinching = false;
228   }
229 
230   destroy() {
231     this.#touchManagerAC?.abort();
232     this.#touchManagerAC = null;
233     this.#pointerDownAC?.abort();
234     this.#pointerDownAC = null;
235   }
236 }
237 
238 export { TouchManager };
</code>

Test file:
<test_file>
File:
test/unit/pdf_spec.js
/* Copyright 2023 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import {
  AbortException,
  AnnotationEditorParamsType,
  AnnotationEditorType,
  AnnotationMode,
  AnnotationType,
  createValidAbsoluteUrl,
  FeatureTest,
  getUuid,
  ImageKind,
  InvalidPDFException,
  MathClamp,
  normalizeUnicode,
  OPS,
  PasswordResponses,
  PermissionFlag,
  ResponseException,
  shadow,
  Util,
  VerbosityLevel,
} from "../../src/shared/util.js";
import {
  build,
  getDocument,
  isValidExplicitDest,
  PDFDataRangeTransport,
  PDFWorker,
  version,
} from "../../src/display/api.js";
import {
  fetchData,
  getFilenameFromUrl,
  getPdfFilenameFromUrl,
  getXfaPageViewport,
  isDataScheme,
  isPdfFile,
  noContextMenu,
  OutputScale,
  PDFDateString,
  PixelsPerInch,
  RenderingCancelledException,
  setLayerDimensions,
  stopEvent,
  SupportedImageMimeTypes,
} from "../../src/display/display_utils.js";
import { AnnotationEditorLayer } from "../../src/display/editor/annotation_editor_layer.js";
import { AnnotationEditorUIManager } from "../../src/display/editor/tools.js";
import { AnnotationLayer } from "../../src/display/annotation_layer.js";
import { ColorPicker } from "../../src/display/editor/color_picker.js";
import { DOMSVGFactory } from "../../src/display/svg_factory.js";
import { DrawLayer } from "../../src/display/draw_layer.js";
import { GlobalWorkerOptions } from "../../src/display/worker_options.js";
import { SignatureExtractor } from "../../src/display/editor/drawers/signaturedraw.js";
import { TextLayer } from "../../src/display/text_layer.js";
import { TouchManager } from "../../src/display/touch_manager.js";
import { XfaLayer } from "../../src/display/xfa_layer.js";
const expectedAPI = Object.freeze({
  AbortException,
  AnnotationEditorLayer,
  AnnotationEditorParamsType,
  AnnotationEditorType,
  AnnotationEditorUIManager,
  AnnotationLayer,
  AnnotationMode,
  AnnotationType,
  build,
  ColorPicker,
  createValidAbsoluteUrl,
  DOMSVGFactory,
  DrawLayer,
  FeatureTest,
  fetchData,
  getDocument,
  getFilenameFromUrl,
  getPdfFilenameFromUrl,
  getUuid,
  getXfaPageViewport,
  GlobalWorkerOptions,
  ImageKind,
  InvalidPDFException,
  isDataScheme,
  isPdfFile,
  isValidExplicitDest,
  MathClamp,
  noContextMenu,
  normalizeUnicode,
  OPS,
  OutputScale,
  PasswordResponses,
  PDFDataRangeTransport,
  PDFDateString,
  PDFWorker,
  PermissionFlag,
  PixelsPerInch,
  RenderingCancelledException,
  ResponseException,
  setLayerDimensions,
  shadow,
  SignatureExtractor,
  stopEvent,
  SupportedImageMimeTypes,
  TextLayer,
  TouchManager,
  Util,
  VerbosityLevel,
  version,
  XfaLayer,
});
</test_file>

Your task:
You are a software tester at pdf.js.
1. Examine the existing test file. You may reuse any imports, helpers or setup blocks it already has.
2. Write exactly one javascript test `it("...", async () => {...})` block.
3. Your test must fail on the code before the patch, and pass after, hence the test will verify that the patch resolves the issue.
4. The test must be self-contained and to-the-point.
5. If you need something new use only the provided imports (respect the paths exactly how they are given) by importing dynamically for compatibility with Node.js — no new dependencies. 
6. Return only the javascript code for the new `it(...)` block (no comments or explanations).

Example structure:
it("should <describe behavior>", async () => {
  const { example } = await import("../../src/core/example.js");
  <initialize required variables>;
  <define expected variable>;
  <generate actual variables>;
  <compare expected with actual>;
});

