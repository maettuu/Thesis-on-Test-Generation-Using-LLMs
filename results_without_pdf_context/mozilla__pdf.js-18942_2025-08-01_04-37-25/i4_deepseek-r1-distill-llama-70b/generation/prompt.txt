Before you begin:
- Keep going until the job is completely solved — don’t stop halfway.
- If you’re unsure about the behavior, reread the provided patch carefully; do not hallucinate.
- Plan your approach before writing code by reflecting on whether the test truly fails before and passes after.

Issue:
<issue>
[Bug]: Warning: loadFont - translateFont failed: "TypeError: e.peekBytes is not a function"
### Attach (recommended) or Link to PDF file

[21_10_2024_FAMI INVERSION SAS_901060703_inicial.pdf](https://github.com/user-attachments/files/17473385/21_10_2024_FAMI.INVERSION.SAS_901060703_inicial.pdf)


### Web browser and its version

Chrome v130.0.6723.58

### Operating system and its version

Windows 10

### PDF.js version

4.7.76

### Is the bug present in the latest PDF.js version?

Yes

### Is a browser extension

No

### Steps to reproduce the problem

Load the given file

### What is the expected behavior?

See the file text, as in the screenshot of chrome pdf viewer :
![image](https://github.com/user-attachments/assets/21a511f4-d143-41f0-a07a-ff9b6ae9fb15)


### What went wrong?

No text is visible, and I get this warning in the devtools console :
Warning: loadFont - translateFont failed: "TypeError: file.peekBytes is not a function".

What I see :
![image](https://github.com/user-attachments/assets/b3bedf50-2058-4193-a1c4-c2517707d68a)

### Link to a viewer

https://pdfupload.io/docs/5689abd7

### Additional context

I debugged the pdf.worker.min.mjs file, and I found that this is the getFontFileType function that is causing an issue :
```
function getFontFileType(e, {type: t, subtype: i, composite: a}) {
    let s, r;
    if (function isTrueTypeFile(e) {
        const t = e.peekBytes(4);
        return 65536 === readUint32(t, 0) || "true" === bytesToString(t)
    }(e) || isTrueTypeCollectionFile(e))
        s = a ? "CIDFontType2" : "TrueType";
    else if (function isOpenTypeFile(e) {
        return "OTTO" === bytesToString(e.peekBytes(4))
    }(e))
        s = a ? "CIDFontType2" : "OpenType";
    else if (function isType1File(e) {
        const t = e.peekBytes(2);
        return 37 === t[0] && 33 === t[1] || 128 === t[0] && 1 === t[1]
    }(e))
        s = a ? "CIDFontType0" : "MMType1" === t ? "MMType1" : "Type1";
    else if (function isCFFFile(e) {
        const t = e.peekBytes(4);
        return t[0] >= 1 && t[3] >= 1 && t[3] <= 4
    }(e))
        if (a) {
            s = "CIDFontType0";
            r = "CIDFontType0C"
        } else {
            s = "MMType1" === t ? "MMType1" : "Type1";
            r = "Type1C"
        }
    else {
        warn("getFontFileType: Unable to detect correct font file Type/Subtype.");
        s = t;
        r = i
    }
    return [s, r]
}
```

And here's the line causing the error : (3rd line of the function). The "e" variable should have a Stream type, but it is a "Dict" instead.

![image](https://github.com/user-attachments/assets/cfdeb094-962a-4f10-9de5-8485eed8cee4)

</issue>

Patch:
<patch>
diff --git a/src/core/evaluator.js b/src/core/evaluator.js
--- a/src/core/evaluator.js
+++ b/src/core/evaluator.js
@@ -63,7 +63,6 @@ import {
   LocalTilingPatternCache,
   RegionalImageCache,
 } from "./image_utils.js";
-import { NullStream, Stream } from "./stream.js";
 import { BaseStream } from "./base_stream.js";
 import { bidi } from "./bidi.js";
 import { ColorSpace } from "./colorspace.js";
@@ -77,6 +76,7 @@ import { ImageResizer } from "./image_resizer.js";
 import { MurmurHash3_64 } from "../shared/murmurhash3.js";
 import { OperatorList } from "./operator_list.js";
 import { PDFImage } from "./image.js";
+import { Stream } from "./stream.js";
 
 const DefaultPartialEvaluatorOptions = Object.freeze({
   maxImageSize: -1,
@@ -4425,12 +4425,20 @@ class PartialEvaluator {
     let fontFile, subtype, length1, length2, length3;
     try {
       fontFile = descriptor.get("FontFile", "FontFile2", "FontFile3");
+
+      if (fontFile) {
+        if (!(fontFile instanceof BaseStream)) {
+          throw new FormatError("FontFile should be a stream");
+        } else if (fontFile.isEmpty) {
+          throw new FormatError("FontFile is empty");
+        }
+      }
     } catch (ex) {
       if (!this.options.ignoreErrors) {
         throw ex;
       }
       warn(`translateFont - fetching "${fontName.name}" font file: "${ex}".`);
-      fontFile = new NullStream();
+      fontFile = null;
     }
     let isInternalFont = false;
     let glyphScaleFactors = null;


</patch>

Imports:
<imports>
Available Packages
Dev Dependencies:
- @babel/core: ^7.25.8
- @babel/preset-env: ^7.25.8
- @babel/runtime: ^7.25.7
- @fluent/bundle: ^0.18.0
- @fluent/dom: ^0.10.0
- @jazzer.js/core: ^2.1.0
- @metalsmith/layouts: ^2.7.0
- @metalsmith/markdown: ^1.10.0
- autoprefixer: ^10.4.20
- babel-loader: ^9.2.1
- caniuse-lite: ^1.0.30001669
- canvas: ^3.0.0-rc2
- core-js: ^3.38.1
- eslint: ^8.57.1
- eslint-plugin-import: ^2.31.0
- eslint-plugin-jasmine: ^4.2.2
- eslint-plugin-json: ^3.1.0
- eslint-plugin-no-unsanitized: ^4.1.2
- eslint-plugin-perfectionist: ^3.9.1
- eslint-plugin-prettier: ^5.2.1
- eslint-plugin-unicorn: ^56.0.0
- gulp: ^5.0.0
- gulp-cli: ^3.0.0
- gulp-postcss: ^10.0.0
- gulp-rename: ^2.0.0
- gulp-replace: ^1.1.4
- gulp-zip: ^6.0.0
- highlight.js: ^11.10.0
- jasmine: ^5.4.0
- jsdoc: ^4.0.4
- jstransformer-nunjucks: ^1.2.0
- metalsmith: ^2.6.3
- metalsmith-html-relative: ^2.0.5
- ordered-read-streams: ^2.0.0
- path2d: ^0.2.1
- pngjs: ^7.0.0
- postcss: ^8.4.47
- postcss-dark-theme-class: ^1.3.0
- postcss-dir-pseudo-class: ^9.0.0
- postcss-discard-comments: ^7.0.3
- postcss-nesting: ^13.0.0
- prettier: ^3.3.3
- puppeteer: 23.3.1
- stylelint: ^16.10.0
- stylelint-prettier: ^5.0.2
- svglint: ^3.0.0
- terser-webpack-plugin: ^5.3.10
- tsc-alias: ^1.8.10
- ttest: ^4.0.0
- typescript: ^5.6.3
- vinyl: ^3.0.0
- webpack: ^5.95.0
- webpack-stream: ^7.0.0
- yargs: ^17.7.2

Engines:
- node: >=18

Available Relative Imports:
- `../../src/core/annotation.js`: Annotation, AnnotationBorderStyle, AnnotationFactory, MarkupAnnotation, getQuadPoints
- `../../src/core/bidi.js`: bidi
- `../../src/core/cff_parser.js`: CFFCharset, CFFCompiler, CFFFDSelect, CFFParser, CFFStrings
- `../../src/core/cmap.js`: CMap, CMapFactory, IdentityCMap
- `../../src/core/colorspace.js`: ColorSpace
- `../../src/core/core_utils.js`: arrayBuffersToBytes, encodeToXmlString, escapePDFName, escapeString, getInheritableProperty, getSizeInBytes, isAscii, isWhiteSpace, log2, numberToString, parseXFAPath, recoverJsURL, stringToUTF16HexString, stringToUTF16String, toRomanNumerals, validateCSSFont
- `../../src/core/crypto.js`: AES128Cipher, AES256Cipher, ARCFourCipher, CipherTransformFactory, PDF17, PDF20, calculateMD5, calculateSHA256, calculateSHA384, calculateSHA512
- `../../src/core/default_appearance.js`: createDefaultAppearance, parseAppearanceStream, parseDefaultAppearance
- `../../src/core/document.js`: PDFDocument, Page
- `../../src/core/encodings.js`: getEncoding
- `../../src/core/evaluator.js`: PartialEvaluator
- `../../src/core/flate_stream.js`: FlateStream
- `../../src/core/font_substitutions.js`: getFontSubstitution
- `../../src/core/fonts_utils.js`: SEAC_ANALYSIS_ENABLED
- `../../src/core/function.js`: PDFFunctionFactory, PostScriptCompiler, PostScriptEvaluator
- `../../src/core/glyphlist.js`: getDingbatsGlyphsUnicode, getGlyphsUnicode
- `../../src/core/image_utils.js`: GlobalImageCache, LocalColorSpaceCache
- `../../src/core/jbig2.js`: Jbig2Error, Jbig2Image
- `../../src/core/jpg.js`: JpegError, JpegImage
- `../../src/core/jpx.js`: JpxError, JpxImage
- `../../src/core/metadata_parser.js`: MetadataParser
- `../../src/core/operator_list.js`: OperatorList
- `../../src/core/parser.js`: Lexer, Linearization, Parser
- `../../src/core/predictor_stream.js`: PredictorStream
- `../../src/core/primitives.js`: Cmd, Dict, EOF, Name, Ref, RefSet, RefSetCache, isCmd, isDict, isName, isRefsEqual
- `../../src/core/ps_parser.js`: PostScriptLexer, PostScriptParser
- `../../src/core/stream.js`: NullStream, Stream, StringStream
- `../../src/core/type1_parser.js`: Type1Parser
- `../../src/core/unicode.js`: getCharUnicodeCategory, getUnicodeForGlyph, getUnicodeRangeFor, mapSpecialUnicodeValues
- `../../src/core/worker.js`: WorkerMessageHandler, WorkerTask
- `../../src/core/writer.js`: incrementalUpdate, writeDict
- `../../src/core/xfa/bind.js`: Binder
- `../../src/core/xfa/data.js`: DataHandler
- `../../src/core/xfa/factory.js`: XFAFactory
- `../../src/core/xfa/formcalc_lexer.js`: Lexer, TOKEN, Token
- `../../src/core/xfa/formcalc_parser.js`: Errors, Parser
- `../../src/core/xfa/parser.js`: XFAParser
- `../../src/core/xfa/som.js`: searchNode
- `../../src/core/xfa/symbol_utils.js`: $dump, $getChildren, $getChildrenByClass, $getChildrenByName, $text, $uid
- `../../src/core/xml_parser.js`: SimpleXMLParser, XMLParserBase
- `../../src/display/annotation_layer.js`: AnnotationLayer
- `../../src/display/annotation_storage.js`: AnnotationStorage
- `../../src/display/api.js`: DefaultCMapReaderFactory, DefaultCanvasFactory, DefaultStandardFontDataFactory, LoopbackPort, PDFDataRangeTransport, PDFDocumentLoadingTask, PDFDocumentProxy, PDFPageProxy, PDFWorker, RenderTask, build, getDocument, version
- `../../src/display/display_utils.js`: DOMCanvasFactory, DOMSVGFactory, OutputScale, PDFDateString, PageViewport, PixelsPerInch, RenderingCancelledException, StatTimer, fetchData, getFilenameFromUrl, getPdfFilenameFromUrl, getXfaPageViewport, isDataScheme, isPdfFile, isValidFetchUrl, noContextMenu, setLayerDimensions
- `../../src/display/draw_layer.js`: DrawLayer
- `../../src/display/editor/annotation_editor_layer.js`: AnnotationEditorLayer
- `../../src/display/editor/color_picker.js`: ColorPicker
- `../../src/display/editor/tools.js`: AnnotationEditorUIManager, CommandManager
- `../../src/display/fetch_stream.js`: PDFFetchStream
- `../../src/display/metadata.js`: Metadata
- `../../src/display/network.js`: PDFNetworkStream
- `../../src/display/network_utils.js`: createHeaders, createResponseStatusError, extractFilenameFromHeader, validateRangeRequestCapabilities, validateResponseStatus
- `../../src/display/node_stream.js`: PDFNodeStream
- `../../src/display/node_utils.js`: NodePackages
- `../../src/display/text_layer.js`: TextLayer
- `../../src/display/worker_options.js`: GlobalWorkerOptions
- `../../src/display/xfa_layer.js`: XfaLayer
- `../../src/shared/message_handler.js`: MessageHandler
- `../../src/shared/murmurhash3.js`: MurmurHash3_64
- `../../src/shared/util.js`: AbortException, AnnotationBorderStyleType, AnnotationEditorParamsType, AnnotationEditorType, AnnotationFieldFlag, AnnotationFlag, AnnotationMode, AnnotationType, BaseException, CMapCompressionType, FeatureTest, FormatError, ImageKind, InvalidPDFException, MissingPDFException, OPS, PasswordException, PasswordResponses, PermissionFlag, RenderingIntentFlag, UnexpectedResponseException, UnknownErrorException, Util, VerbosityLevel, assert, bytesToString, createValidAbsoluteUrl, getModificationDate, getVerbosityLevel, isNodeJS, normalizeUnicode, objectSize, setVerbosityLevel, shadow, string32, stringToBytes, stringToPDFString, stringToUTF8String
- `../../web/annotation_layer_builder.js`: AnnotationLayerBuilder
- `../../web/app_options.js`: AppOptions, OptionKind
- `../../web/download_manager.js`: DownloadManager
- `../../web/event_utils.js`: EventBus, WaitOnType, waitOnEventOrTimeout
- `../../web/genericl10n.js`: GenericL10n
- `../../web/pdf_find_controller.js`: FindState, PDFFindController
- `../../web/pdf_find_utils.js`: CharacterType, getCharacterType
- `../../web/pdf_history.js`: PDFHistory, isDestArraysEqual, isDestHashesEqual
- `../../web/pdf_link_service.js`: LinkTarget, PDFLinkService, SimpleLinkService
- `../../web/pdf_page_view.js`: PDFPageView
- `../../web/pdf_scripting_manager.component.js`: PDFScriptingManager
- `../../web/pdf_single_page_viewer.js`: PDFSinglePageViewer
- `../../web/pdf_viewer.js`: PDFPageViewBuffer, PDFViewer
- `../../web/struct_tree_layer_builder.js`: StructTreeLayerBuilder
- `../../web/text_layer_builder.js`: TextLayerBuilder
- `../../web/ui_utils.js`: AutoPrintRegExp, ProgressBar, RenderingStates, ScrollMode, SpreadMode, backtrackBeforeAllVisibleElements, binarySearchFirstItem, calcRound, getPageSizeInches, getVisibleElements, isPortraitOrientation, isValidRotation, parseQueryString, removeNullCharacters
- `../../web/xfa_layer_builder.js`: XfaLayerBuilder
- `./test_utils.js`: CMAP_URL, DefaultFileReaderFactory, STANDARD_FONT_DATA_URL, TEST_PDFS_PATH, XRefMock, buildGetDocumentParams, createIdFactory, createTemporaryNodeServer
- `./testreporter.js`: TestReporter
</imports>

Code:
<code>
File:
src/core/evaluator.js
1 /* Copyright 2012 Mozilla Foundation
2  *
3  * Licensed under the Apache License, Version 2.0 (the "License");
4  * you may not use this file except in compliance with the License.
5  * You may obtain a copy of the License at
6  *
7  *     http://www.apache.org/licenses/LICENSE-2.0
8  *
9  * Unless required by applicable law or agreed to in writing, software
10  * distributed under the License is distributed on an "AS IS" BASIS,
11  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
12  * See the License for the specific language governing permissions and
13  * limitations under the License.
14  */
15 /* eslint-disable no-var */
16 
17 import {
18   AbortException,
19   assert,
20   CMapCompressionType,
21   FONT_IDENTITY_MATRIX,
22   FormatError,
23   IDENTITY_MATRIX,
24   info,
25   isArrayEqual,
26   normalizeUnicode,
27   OPS,
28   shadow,
29   stringToPDFString,
30   TextRenderingMode,
31   Util,
32   warn,
33 } from "../shared/util.js";
34 import { CMapFactory, IdentityCMap } from "./cmap.js";
35 import { Cmd, Dict, EOF, isName, Name, Ref, RefSet } from "./primitives.js";
36 import { ErrorFont, Font } from "./fonts.js";
37 import {
38   getEncoding,
39   MacRomanEncoding,
40   StandardEncoding,
41   SymbolSetEncoding,
42   WinAnsiEncoding,
43   ZapfDingbatsEncoding,
44 } from "./encodings.js";
45 import {
46   getFontNameToFileMap,
47   getSerifFonts,
48   getStandardFontName,
49   getStdFontMap,
50   getSymbolsFonts,
51   isKnownFontName,
52 } from "./standard_fonts.js";
53 import { getTilingPatternIR, Pattern } from "./pattern.js";
54 import { getXfaFontDict, getXfaFontName } from "./xfa_fonts.js";
55 import { IdentityToUnicodeMap, ToUnicodeMap } from "./to_unicode_map.js";
56 import { isNumberArray, lookupMatrix, lookupNormalRect } from "./core_utils.js";
57 import { isPDFFunction, PDFFunctionFactory } from "./function.js";
58 import { Lexer, Parser } from "./parser.js";
59 import {
60   LocalColorSpaceCache,
61   LocalGStateCache,
62   LocalImageCache,
63   LocalTilingPatternCache,
64   RegionalImageCache,
65 } from "./image_utils.js";
66 import { NullStream, Stream } from "./stream.js";
67 import { BaseStream } from "./base_stream.js";
68 import { bidi } from "./bidi.js";
69 import { ColorSpace } from "./colorspace.js";
70 import { DecodeStream } from "./decode_stream.js";
71 import { FontFlags } from "./fonts_utils.js";
72 import { getFontSubstitution } from "./font_substitutions.js";
73 import { getGlyphsUnicode } from "./glyphlist.js";
74 import { getMetrics } from "./metrics.js";
75 import { getUnicodeForGlyph } from "./unicode.js";
76 import { ImageResizer } from "./image_resizer.js";
77 import { MurmurHash3_64 } from "../shared/murmurhash3.js";
78 import { OperatorList } from "./operator_list.js";
79 import { PDFImage } from "./image.js";
80 
81 const DefaultPartialEvaluatorOptions = Object.freeze({
82   maxImageSize: -1,
83   disableFontFace: false,
84   ignoreErrors: false,
85   isEvalSupported: true,
86   isOffscreenCanvasSupported: false,
87   canvasMaxAreaInBytes: -1,
88   fontExtraProperties: false,
89   useSystemFonts: true,
90   cMapUrl: null,
91   standardFontDataUrl: null,
92 });
93 
94 const PatternType = {
95   TILING: 1,
96   SHADING: 2,
97 };
98 
99 // Optionally avoid sending individual, or very few, text chunks to reduce
100 // `postMessage` overhead with ReadableStream (see issue 13962).
101 //
102 // PLEASE NOTE: This value should *not* be too large (it's used as a lower limit
103 // in `enqueueChunk`), since that would cause streaming of textContent to become
104 // essentially useless in practice by sending all (or most) chunks at once.
105 // Also, a too large value would (indirectly) affect the main-thread `textLayer`
106 // building negatively by forcing all textContent to be handled at once, which
107 // could easily end up hurting *overall* performance (e.g. rendering as well).
108 const TEXT_CHUNK_BATCH_SIZE = 10;
109 
110 const deferred = Promise.resolve();
111 
112 // Convert PDF blend mode names to HTML5 blend mode names.
113 function normalizeBlendMode(value, parsingArray = false) {
114   if (Array.isArray(value)) {
115     // Use the first *supported* BM value in the Array (fixes issue11279.pdf).
116     for (const val of value) {
117       const maybeBM = normalizeBlendMode(val, /* parsingArray = */ true);
118       if (maybeBM) {
119         return maybeBM;
120       }
121     }
122     warn(`Unsupported blend mode Array: ${value}`);
123     return "source-over";
124   }
125 
126   if (!(value instanceof Name)) {
127     if (parsingArray) {
128       return null;
129     }
130     return "source-over";
131   }
132   switch (value.name) {
133     case "Normal":
134     case "Compatible":
135       return "source-over";
136     case "Multiply":
137       return "multiply";
138     case "Screen":
139       return "screen";
140     case "Overlay":
141       return "overlay";
142     case "Darken":
143       return "darken";
144     case "Lighten":
145       return "lighten";
146     case "ColorDodge":
147       return "color-dodge";
148     case "ColorBurn":
149       return "color-burn";
150     case "HardLight":
151       return "hard-light";
152     case "SoftLight":
153       return "soft-light";
154     case "Difference":
155       return "difference";
156     case "Exclusion":
157       return "exclusion";
158     case "Hue":
159       return "hue";
160     case "Saturation":
161       return "saturation";
162     case "Color":
163       return "color";
164     case "Luminosity":
165       return "luminosity";
166   }
167   if (parsingArray) {
168     return null;
169   }
170   warn(`Unsupported blend mode: ${value.name}`);
171   return "source-over";
172 }
173 
174 function addLocallyCachedImageOps(opList, data) {
175   if (data.objId) {
176     opList.addDependency(data.objId);
177   }
178   opList.addImageOps(data.fn, data.args, data.optionalContent);
179 
180   if (data.fn === OPS.paintImageMaskXObject && data.args[0]?.count > 0) {
181     data.args[0].count++;
182   }
183 }
184 
185 // Trying to minimize Date.now() usage and check every 100 time.
186 class TimeSlotManager {
187   static TIME_SLOT_DURATION_MS = 20;
188 
189   static CHECK_TIME_EVERY = 100;
190 
191   constructor() {
192     this.reset();
193   }
194 
195   check() {
196     if (++this.checked < TimeSlotManager.CHECK_TIME_EVERY) {
197       return false;
198     }
199     this.checked = 0;
200     return this.endTime <= Date.now();
201   }
202 
203   reset() {
204     this.endTime = Date.now() + TimeSlotManager.TIME_SLOT_DURATION_MS;
205     this.checked = 0;
206   }
207 }
208 
209 class PartialEvaluator {
210   constructor({
211     xref,
212     handler,
213     pageIndex,
214     idFactory,
215     fontCache,
216     builtInCMapCache,
217     standardFontDataCache,
218     globalImageCache,
219     systemFontCache,
220     options = null,
221   }) {
222     this.xref = xref;
223     this.handler = handler;
224     this.pageIndex = pageIndex;
225     this.idFactory = idFactory;
226     this.fontCache = fontCache;
227     this.builtInCMapCache = builtInCMapCache;
228     this.standardFontDataCache = standardFontDataCache;
229     this.globalImageCache = globalImageCache;
230     this.systemFontCache = systemFontCache;
231     this.options = options || DefaultPartialEvaluatorOptions;
232     this.type3FontRefs = null;
233 
234     this._regionalImageCache = new RegionalImageCache();
235     this._fetchBuiltInCMapBound = this.fetchBuiltInCMap.bind(this);
236     ImageResizer.setMaxArea(this.options.canvasMaxAreaInBytes);
237   }
238 
239   /**
240    * Since Functions are only cached (locally) by reference, we can share one
241    * `PDFFunctionFactory` instance within this `PartialEvaluator` instance.
242    */
243   get _pdfFunctionFactory() {
244     const pdfFunctionFactory = new PDFFunctionFactory({
245       xref: this.xref,
246       isEvalSupported: this.options.isEvalSupported,
247     });
248     return shadow(this, "_pdfFunctionFactory", pdfFunctionFactory);
249   }
250 
251   get parsingType3Font() {
252     return !!this.type3FontRefs;
253   }
254 
255   clone(newOptions = null) {
256     const newEvaluator = Object.create(this);
257     newEvaluator.options = Object.assign(
258       Object.create(null),
259       this.options,
260       newOptions
261     );
262     return newEvaluator;
263   }
264 
265   hasBlendModes(resources, nonBlendModesSet) {
266     if (!(resources instanceof Dict)) {
267       return false;
268     }
269     if (resources.objId && nonBlendModesSet.has(resources.objId)) {
270       return false;
271     }
272 
273     const processed = new RefSet(nonBlendModesSet);
274     if (resources.objId) {
275       processed.put(resources.objId);
276     }
277 
278     const nodes = [resources],
279       xref = this.xref;
280     while (nodes.length) {
281       const node = nodes.shift();
282       // First check the current resources for blend modes.
283       const graphicStates = node.get("ExtGState");
284       if (graphicStates instanceof Dict) {
285         for (let graphicState of graphicStates.getRawValues()) {
286           if (graphicState instanceof Ref) {
287             if (processed.has(graphicState)) {
288               continue; // The ExtGState has already been processed.
289             }
290             try {
291               graphicState = xref.fetch(graphicState);
292             } catch (ex) {
293               // Avoid parsing a corrupt ExtGState more than once.
294               processed.put(graphicState);
295 
296               info(`hasBlendModes - ignoring ExtGState: "${ex}".`);
297               continue;
298             }
299           }
300           if (!(graphicState instanceof Dict)) {
301             continue;
302           }
303           if (graphicState.objId) {
304             processed.put(graphicState.objId);
305           }
306 
307           const bm = graphicState.get("BM");
308           if (bm instanceof Name) {
309             if (bm.name !== "Normal") {
310               return true;
311             }
312             continue;
313           }
314           if (bm !== undefined && Array.isArray(bm)) {
315             for (const element of bm) {
316               if (element instanceof Name && element.name !== "Normal") {
317                 return true;
318               }
319             }
320           }
321         }
322       }
323       // Descend into the XObjects to look for more resources and blend modes.
324       const xObjects = node.get("XObject");
325       if (!(xObjects instanceof Dict)) {
326         continue;
327       }
328       for (let xObject of xObjects.getRawValues()) {
329         if (xObject instanceof Ref) {
330           if (processed.has(xObject)) {
331             // The XObject has already been processed, and by avoiding a
332             // redundant `xref.fetch` we can *significantly* reduce the load
333             // time for badly generated PDF files (fixes issue6961.pdf).
334             continue;
335           }
336           try {
337             xObject = xref.fetch(xObject);
338           } catch (ex) {
339             // Avoid parsing a corrupt XObject more than once.
340             processed.put(xObject);
341 
342             info(`hasBlendModes - ignoring XObject: "${ex}".`);
343             continue;
344           }
345         }
346         if (!(xObject instanceof BaseStream)) {
347           continue;
348         }
349         if (xObject.dict.objId) {
350           processed.put(xObject.dict.objId);
351         }
352         const xResources = xObject.dict.get("Resources");
353         if (!(xResources instanceof Dict)) {
354           continue;
355         }
356         // Checking objId to detect an infinite loop.
357         if (xResources.objId && processed.has(xResources.objId)) {
358           continue;
359         }
360 
361         nodes.push(xResources);
362         if (xResources.objId) {
363           processed.put(xResources.objId);
364         }
365       }
366     }
367 
368     // When no blend modes exist, there's no need re-fetch/re-parse any of the
369     // processed `Ref`s again for subsequent pages. This helps reduce redundant
370     // `XRef.fetch` calls for some documents (e.g. issue6961.pdf).
371     for (const ref of processed) {
372       nonBlendModesSet.put(ref);
373     }
374     return false;
375   }
376 
377   async fetchBuiltInCMap(name) {
378     const cachedData = this.builtInCMapCache.get(name);
379     if (cachedData) {
380       return cachedData;
381     }
382     let data;
383 
384     if (this.options.cMapUrl !== null) {
385       // Only compressed CMaps are (currently) supported here.
386       const url = `${this.options.cMapUrl}${name}.bcmap`;
387       const response = await fetch(url);
388       if (!response.ok) {
389         throw new Error(
390           `fetchBuiltInCMap: failed to fetch file "${url}" with "${response.statusText}".`
391         );
392       }
393       data = {
394         cMapData: new Uint8Array(await response.arrayBuffer()),
395         compressionType: CMapCompressionType.BINARY,
396       };
397     } else {
398       // Get the data on the main-thread instead.
399       data = await this.handler.sendWithPromise("FetchBuiltInCMap", { name });
400     }
401 
402     if (data.compressionType !== CMapCompressionType.NONE) {
403       // Given the size of uncompressed CMaps, only cache compressed ones.
404       this.builtInCMapCache.set(name, data);
405     }
406     return data;
407   }
408 
409   async fetchStandardFontData(name) {
410     const cachedData = this.standardFontDataCache.get(name);
411     if (cachedData) {
412       return new Stream(cachedData);
413     }
414 
415     // The symbol fonts are not consistent across platforms, always load the
416     // standard font data for them.
417     if (
418       this.options.useSystemFonts &&
419       name !== "Symbol" &&
420       name !== "ZapfDingbats"
421     ) {
422       return null;
423     }
424 
425     const standardFontNameToFileName = getFontNameToFileMap(),
426       filename = standardFontNameToFileName[name];
427     let data;
428 
429     if (this.options.standardFontDataUrl !== null) {
430       const url = `${this.options.standardFontDataUrl}${filename}`;
431       const response = await fetch(url);
432       if (!response.ok) {
433         warn(
434           `fetchStandardFontData: failed to fetch file "${url}" with "${response.statusText}".`
435         );
436       } else {
437         data = new Uint8Array(await response.arrayBuffer());
438       }
439     } else {
440       // Get the data on the main-thread instead.
441       try {
442         data = await this.handler.sendWithPromise("FetchStandardFontData", {
443           filename,
444         });
445       } catch (e) {
446         warn(
447           `fetchStandardFontData: failed to fetch file "${filename}" with "${e}".`
448         );
449       }
450     }
451 
452     if (!data) {
453       return null;
454     }
455     // Cache the "raw" standard font data, to avoid fetching it repeatedly
456     // (see e.g. issue 11399).
457     this.standardFontDataCache.set(name, data);
458 
459     return new Stream(data);
460   }
461 
462   async buildFormXObject(
463     resources,
464     xobj,
465     smask,
466     operatorList,
467     task,
468     initialState,
469     localColorSpaceCache
470   ) {
471     const dict = xobj.dict;
472     const matrix = lookupMatrix(dict.getArray("Matrix"), null);
473     const bbox = lookupNormalRect(dict.getArray("BBox"), null);
474 
475     let optionalContent, groupOptions;
476     if (dict.has("OC")) {
477       optionalContent = await this.parseMarkedContentProps(
478         dict.get("OC"),
479         resources
480       );
481     }
482     if (optionalContent !== undefined) {
483       operatorList.addOp(OPS.beginMarkedContentProps, ["OC", optionalContent]);
484     }
485     const group = dict.get("Group");
486     if (group) {
487       groupOptions = {
488         matrix,
489         bbox,
490         smask,
491         isolated: false,
492         knockout: false,
493       };
494 
495       const groupSubtype = group.get("S");
496       let colorSpace = null;
497       if (isName(groupSubtype, "Transparency")) {
498         groupOptions.isolated = group.get("I") || false;
499         groupOptions.knockout = group.get("K") || false;
500         if (group.has("CS")) {
501           const cs = group.getRaw("CS");
502 
503           const cachedColorSpace = ColorSpace.getCached(
504             cs,
505             this.xref,
506             localColorSpaceCache
507           );
508           if (cachedColorSpace) {
509             colorSpace = cachedColorSpace;
510           } else {
511             colorSpace = await this.parseColorSpace({
512               cs,
513               resources,
514               localColorSpaceCache,
515             });
516           }
517         }
518       }
519 
520       if (smask?.backdrop) {
521         colorSpace ||= ColorSpace.singletons.rgb;
522         smask.backdrop = colorSpace.getRgb(smask.backdrop, 0);
523       }
524 
525       operatorList.addOp(OPS.beginGroup, [groupOptions]);
526     }
527 
528     // If it's a group, a new canvas will be created that is the size of the
529     // bounding box and translated to the correct position so we don't need to
530     // apply the bounding box to it.
531     const args = group ? [matrix, null] : [matrix, bbox];
532     operatorList.addOp(OPS.paintFormXObjectBegin, args);
533 
534     await this.getOperatorList({
535       stream: xobj,
536       task,
537       resources: dict.get("Resources") || resources,
538       operatorList,
539       initialState,
540     });
541     operatorList.addOp(OPS.paintFormXObjectEnd, []);
542 
543     if (group) {
544       operatorList.addOp(OPS.endGroup, [groupOptions]);
545     }
546 
547     if (optionalContent !== undefined) {
548       operatorList.addOp(OPS.endMarkedContent, []);
549     }
550   }
551 
552   _sendImgData(objId, imgData, cacheGlobally = false) {
553     if (
554       (typeof PDFJSDev === "undefined" || PDFJSDev.test("TESTING")) &&
555       imgData
556     ) {
557       assert(Number.isInteger(imgData.dataLen), "Expected dataLen to be set.");
558     }
559     const transfers = imgData ? [imgData.bitmap || imgData.data.buffer] : null;
560 
561     if (this.parsingType3Font || cacheGlobally) {
562       return this.handler.send(
563         "commonobj",
564         [objId, "Image", imgData],
565         transfers
566       );
567     }
568     return this.handler.send(
569       "obj",
570       [objId, this.pageIndex, "Image", imgData],
571       transfers
572     );
573   }
574 
575   async buildPaintImageXObject({
576     resources,
577     image,
578     isInline = false,
579     operatorList,
580     cacheKey,
581     localImageCache,
582     localColorSpaceCache,
583   }) {
584     const dict = image.dict;
585     const imageRef = dict.objId;
586     const w = dict.get("W", "Width");
587     const h = dict.get("H", "Height");
588 
589     if (!(w && typeof w === "number") || !(h && typeof h === "number")) {
590       warn("Image dimensions are missing, or not numbers.");
591       return;
592     }
593     const maxImageSize = this.options.maxImageSize;
594     if (maxImageSize !== -1 && w * h > maxImageSize) {
595       const msg = "Image exceeded maximum allowed size and was removed.";
596 
597       if (this.options.ignoreErrors) {
598         warn(msg);
599         return;
600       }
601       throw new Error(msg);
602     }
603 
604     let optionalContent;
605     if (dict.has("OC")) {
606       optionalContent = await this.parseMarkedContentProps(
607         dict.get("OC"),
608         resources
609       );
610     }
611 
612     const imageMask = dict.get("IM", "ImageMask") || false;
613     let imgData, args;
614     if (imageMask) {
615       // This depends on a tmpCanvas being filled with the
616       // current fillStyle, such that processing the pixel
617       // data can't be done here. Instead of creating a
618       // complete PDFImage, only read the information needed
619       // for later.
620       const interpolate = dict.get("I", "Interpolate");
621       const bitStrideLength = (w + 7) >> 3;
622       const imgArray = image.getBytes(bitStrideLength * h);
623       const decode = dict.getArray("D", "Decode");
624 
625       if (this.parsingType3Font) {
626         imgData = PDFImage.createRawMask({
627           imgArray,
628           width: w,
629           height: h,
630           imageIsFromDecodeStream: image instanceof DecodeStream,
631           inverseDecode: decode?.[0] > 0,
632           interpolate,
633         });
634 
635         imgData.cached = !!cacheKey;
636         args = [imgData];
637 
638         operatorList.addImageOps(
639           OPS.paintImageMaskXObject,
640           args,
641           optionalContent
642         );
643 
644         if (cacheKey) {
645           const cacheData = {
646             fn: OPS.paintImageMaskXObject,
647             args,
648             optionalContent,
649           };
650           localImageCache.set(cacheKey, imageRef, cacheData);
651 
652           if (imageRef) {
653             this._regionalImageCache.set(
654               /* name = */ null,
655               imageRef,
656               cacheData
657             );
658           }
659         }
660         return;
661       }
662 
663       imgData = await PDFImage.createMask({
664         imgArray,
665         width: w,
666         height: h,
667         imageIsFromDecodeStream: image instanceof DecodeStream,
668         inverseDecode: decode?.[0] > 0,
669         interpolate,
670         isOffscreenCanvasSupported: this.options.isOffscreenCanvasSupported,
671       });
672 
673       if (imgData.isSingleOpaquePixel) {
674         // Handles special case of mainly LaTeX documents which use image
675         // masks to draw lines with the current fill style.
676         operatorList.addImageOps(
677           OPS.paintSolidColorImageMask,
678           [],
679           optionalContent
680         );
681 
682         if (cacheKey) {
683           const cacheData = {
684             fn: OPS.paintSolidColorImageMask,
685             args: [],
686             optionalContent,
687           };
688           localImageCache.set(cacheKey, imageRef, cacheData);
689 
690           if (imageRef) {
691             this._regionalImageCache.set(
692               /* name = */ null,
693               imageRef,
694               cacheData
695             );
696           }
697         }
698         return;
699       }
700 
701       const objId = `mask_${this.idFactory.createObjId()}`;
702       operatorList.addDependency(objId);
703 
704       imgData.dataLen = imgData.bitmap
705         ? imgData.width * imgData.height * 4
706         : imgData.data.length;
707       this._sendImgData(objId, imgData);
708 
709       args = [
710         {
711           data: objId,
712           width: imgData.width,
713           height: imgData.height,
714           interpolate: imgData.interpolate,
715           count: 1,
716         },
717       ];
718       operatorList.addImageOps(
719         OPS.paintImageMaskXObject,
720         args,
721         optionalContent
722       );
723 
724       if (cacheKey) {
725         const cacheData = {
726           objId,
727           fn: OPS.paintImageMaskXObject,
728           args,
729           optionalContent,
730         };
731         localImageCache.set(cacheKey, imageRef, cacheData);
732 
733         if (imageRef) {
734           this._regionalImageCache.set(/* name = */ null, imageRef, cacheData);
735         }
736       }
737       return;
738     }
739 
740     const SMALL_IMAGE_DIMENSIONS = 200;
741     // Inlining small images into the queue as RGB data
742     if (
743       isInline &&
744       w + h < SMALL_IMAGE_DIMENSIONS &&
745       !dict.has("SMask") &&
746       !dict.has("Mask")
747     ) {
748       try {
749         const imageObj = new PDFImage({
750           xref: this.xref,
751           res: resources,
752           image,
753           isInline,
754           pdfFunctionFactory: this._pdfFunctionFactory,
755           localColorSpaceCache,
756         });
757         // We force the use of RGBA_32BPP images here, because we can't handle
758         // any other kind.
759         imgData = await imageObj.createImageData(
760           /* forceRGBA = */ true,
761           /* isOffscreenCanvasSupported = */ false
762         );
763         operatorList.isOffscreenCanvasSupported =
764           this.options.isOffscreenCanvasSupported;
765         operatorList.addImageOps(
766           OPS.paintInlineImageXObject,
767           [imgData],
768           optionalContent
769         );
770       } catch (reason) {
771         const msg = `Unable to decode inline image: "${reason}".`;
772 
773         if (!this.options.ignoreErrors) {
774           throw new Error(msg);
775         }
776         warn(msg);
777       }
778       return;
779     }
780 
781     // If there is no imageMask, create the PDFImage and a lot
782     // of image processing can be done here.
783     let objId = `img_${this.idFactory.createObjId()}`,
784       cacheGlobally = false;
785 
786     if (this.parsingType3Font) {
787       objId = `${this.idFactory.getDocId()}_type3_${objId}`;
788     } else if (cacheKey && imageRef) {
789       cacheGlobally = this.globalImageCache.shouldCache(
790         imageRef,
791         this.pageIndex
792       );
793 
794       if (cacheGlobally) {
795         assert(!isInline, "Cannot cache an inline image globally.");
796 
797         objId = `${this.idFactory.getDocId()}_${objId}`;
798       }
799     }
800 
801     // Ensure that the dependency is added before the image is decoded.
802     operatorList.addDependency(objId);
803     args = [objId, w, h];
804     operatorList.addImageOps(OPS.paintImageXObject, args, optionalContent);
805 
806     if (cacheGlobally) {
807       if (this.globalImageCache.hasDecodeFailed(imageRef)) {
808         this.globalImageCache.setData(imageRef, {
809           objId,
810           fn: OPS.paintImageXObject,
811           args,
812           optionalContent,
813           byteSize: 0, // Data is `null`, since decoding failed previously.
814         });
815 
816         this._sendImgData(objId, /* imgData = */ null, cacheGlobally);
817         return;
818       }
819 
820       // For large (at least 500x500) or more complex images that we'll cache
821       // globally, check if the image is still cached locally on the main-thread
822       // to avoid having to re-parse the image (since that can be slow).
823       if (w * h > 250000 || dict.has("SMask") || dict.has("Mask")) {
824         const localLength = await this.handler.sendWithPromise("commonobj", [
825           objId,
826           "CopyLocalImage",
827           { imageRef },
828         ]);
829 
830         if (localLength) {
831           this.globalImageCache.setData(imageRef, {
832             objId,
833             fn: OPS.paintImageXObject,
834             args,
835             optionalContent,
836             byteSize: 0, // Temporary entry, to avoid `setData` returning early.
837           });
838           this.globalImageCache.addByteSize(imageRef, localLength);
839           return;
840         }
841       }
842     }
843 
844     PDFImage.buildImage({
845       xref: this.xref,
846       res: resources,
847       image,
848       isInline,
849       pdfFunctionFactory: this._pdfFunctionFactory,
850       localColorSpaceCache,
851     })
852       .then(async imageObj => {
853         imgData = await imageObj.createImageData(
854           /* forceRGBA = */ false,
855           /* isOffscreenCanvasSupported = */ this.options
856             .isOffscreenCanvasSupported
857         );
858         imgData.dataLen = imgData.bitmap
859           ? imgData.width * imgData.height * 4
860           : imgData.data.length;
861         imgData.ref = imageRef;
862 
863         if (cacheGlobally) {
864           this.globalImageCache.addByteSize(imageRef, imgData.dataLen);
865         }
866         return this._sendImgData(objId, imgData, cacheGlobally);
867       })
868       .catch(reason => {
869         warn(`Unable to decode image "${objId}": "${reason}".`);
870 
871         if (imageRef) {
872           this.globalImageCache.addDecodeFailed(imageRef);
873         }
874         return this._sendImgData(objId, /* imgData = */ null, cacheGlobally);
875       });
876 
877     if (cacheKey) {
878       const cacheData = {
879         objId,
880         fn: OPS.paintImageXObject,
881         args,
882         optionalContent,
883       };
884       localImageCache.set(cacheKey, imageRef, cacheData);
885 
886       if (imageRef) {
887         this._regionalImageCache.set(/* name = */ null, imageRef, cacheData);
888 
889         if (cacheGlobally) {
890           this.globalImageCache.setData(imageRef, {
891             objId,
892             fn: OPS.paintImageXObject,
893             args,
894             optionalContent,
895             byteSize: 0, // Temporary entry, note `addByteSize` above.
896           });
897         }
898       }
899     }
900   }
901 
902   handleSMask(
903     smask,
904     resources,
905     operatorList,
906     task,
907     stateManager,
908     localColorSpaceCache
909   ) {
910     const smaskContent = smask.get("G");
911     const smaskOptions = {
912       subtype: smask.get("S").name,
913       backdrop: smask.get("BC"),
914     };
915 
916     // The SMask might have a alpha/luminosity value transfer function --
917     // we will build a map of integer values in range 0..255 to be fast.
918     const transferObj = smask.get("TR");
919     if (isPDFFunction(transferObj)) {
920       const transferFn = this._pdfFunctionFactory.create(transferObj);
921       const transferMap = new Uint8Array(256);
922       const tmp = new Float32Array(1);
923       for (let i = 0; i < 256; i++) {
924         tmp[0] = i / 255;
925         transferFn(tmp, 0, tmp, 0);
926         transferMap[i] = (tmp[0] * 255) | 0;
927       }
928       smaskOptions.transferMap = transferMap;
929     }
930 
931     return this.buildFormXObject(
932       resources,
933       smaskContent,
934       smaskOptions,
935       operatorList,
936       task,
937       stateManager.state.clone(),
938       localColorSpaceCache
939     );
940   }
941 
942   handleTransferFunction(tr) {
943     let transferArray;
944     if (Array.isArray(tr)) {
945       transferArray = tr;
946     } else if (isPDFFunction(tr)) {
947       transferArray = [tr];
948     } else {
949       return null; // Not a valid transfer function entry.
950     }
951 
952     const transferMaps = [];
953     let numFns = 0,
954       numEffectfulFns = 0;
955     for (const entry of transferArray) {
956       const transferObj = this.xref.fetchIfRef(entry);
957       numFns++;
958 
959       if (isName(transferObj, "Identity")) {
960         transferMaps.push(null);
961         continue;
962       } else if (!isPDFFunction(transferObj)) {
963         return null; // Not a valid transfer function object.
964       }
965 
966       const transferFn = this._pdfFunctionFactory.create(transferObj);
967       const transferMap = new Uint8Array(256),
968         tmp = new Float32Array(1);
969       for (let j = 0; j < 256; j++) {
970         tmp[0] = j / 255;
971         transferFn(tmp, 0, tmp, 0);
972         transferMap[j] = (tmp[0] * 255) | 0;
973       }
974       transferMaps.push(transferMap);
975       numEffectfulFns++;
976     }
977 
978     if (!(numFns === 1 || numFns === 4)) {
979       return null; // Only 1 or 4 functions are supported, by the specification.
980     }
981     if (numEffectfulFns === 0) {
982       return null; // Only /Identity transfer functions found, which are no-ops.
983     }
984     return transferMaps;
985   }
986 
987   handleTilingType(
988     fn,
989     color,
990     resources,
991     pattern,
992     patternDict,
993     operatorList,
994     task,
995     localTilingPatternCache
996   ) {
997     // Create an IR of the pattern code.
998     const tilingOpList = new OperatorList();
999     // Merge the available resources, to prevent issues when the patternDict
1000     // is missing some /Resources entries (fixes issue6541.pdf).
1001     const patternResources = Dict.merge({
1002       xref: this.xref,
1003       dictArray: [patternDict.get("Resources"), resources],
1004     });
1005 
1006     return this.getOperatorList({
1007       stream: pattern,
1008       task,
1009       resources: patternResources,
1010       operatorList: tilingOpList,
1011     })
1012       .then(function () {
1013         const operatorListIR = tilingOpList.getIR();
1014         const tilingPatternIR = getTilingPatternIR(
1015           operatorListIR,
1016           patternDict,
1017           color
1018         );
1019         // Add the dependencies to the parent operator list so they are
1020         // resolved before the sub operator list is executed synchronously.
1021         operatorList.addDependencies(tilingOpList.dependencies);
1022         operatorList.addOp(fn, tilingPatternIR);
1023 
1024         if (patternDict.objId) {
1025           localTilingPatternCache.set(/* name = */ null, patternDict.objId, {
1026             operatorListIR,
1027             dict: patternDict,
1028           });
1029         }
1030       })
1031       .catch(reason => {
1032         if (reason instanceof AbortException) {
1033           return;
1034         }
1035         if (this.options.ignoreErrors) {
1036           warn(`handleTilingType - ignoring pattern: "${reason}".`);
1037           return;
1038         }
1039         throw reason;
1040       });
1041   }
1042 
1043   async handleSetFont(
1044     resources,
1045     fontArgs,
1046     fontRef,
1047     operatorList,
1048     task,
1049     state,
1050     fallbackFontDict = null,
1051     cssFontInfo = null
1052   ) {
1053     const fontName = fontArgs?.[0] instanceof Name ? fontArgs[0].name : null;
1054 
1055     let translated = await this.loadFont(
1056       fontName,
1057       fontRef,
1058       resources,
1059       fallbackFontDict,
1060       cssFontInfo
1061     );
1062 
1063     if (translated.font.isType3Font) {
1064       try {
1065         await translated.loadType3Data(this, resources, task);
1066         // Add the dependencies to the parent operatorList so they are
1067         // resolved before Type3 operatorLists are executed synchronously.
1068         operatorList.addDependencies(translated.type3Dependencies);
1069       } catch (reason) {
1070         translated = new TranslatedFont({
1071           loadedName: "g_font_error",
1072           font: new ErrorFont(`Type3 font load error: ${reason}`),
1073           dict: translated.font,
1074           evaluatorOptions: this.options,
1075         });
1076       }
1077     }
1078 
1079     state.font = translated.font;
1080     translated.send(this.handler);
1081     return translated.loadedName;
1082   }
1083 
1084   handleText(chars, state) {
1085     const font = state.font;
1086     const glyphs = font.charsToGlyphs(chars);
1087 
1088     if (font.data) {
1089       const isAddToPathSet = !!(
1090         state.textRenderingMode & TextRenderingMode.ADD_TO_PATH_FLAG
1091       );
1092       if (
1093         isAddToPathSet ||
1094         state.fillColorSpace.name === "Pattern" ||
1095         font.disableFontFace ||
1096         this.options.disableFontFace
1097       ) {
1098         PartialEvaluator.buildFontPaths(
1099           font,
1100           glyphs,
1101           this.handler,
1102           this.options
1103         );
1104       }
1105     }
1106     return glyphs;
1107   }
1108 
1109   ensureStateFont(state) {
1110     if (state.font) {
1111       return;
1112     }
1113     const reason = new FormatError(
1114       "Missing setFont (Tf) operator before text rendering operator."
1115     );
1116 
1117     if (this.options.ignoreErrors) {
1118       warn(`ensureStateFont: "${reason}".`);
1119       return;
1120     }
1121     throw reason;
1122   }
1123 
1124   async setGState({
1125     resources,
1126     gState,
1127     operatorList,
1128     cacheKey,
1129     task,
1130     stateManager,
1131     localGStateCache,
1132     localColorSpaceCache,
1133   }) {
1134     const gStateRef = gState.objId;
1135     let isSimpleGState = true;
1136     // This array holds the converted/processed state data.
1137     const gStateObj = [];
1138     let promise = Promise.resolve();
1139     for (const key of gState.getKeys()) {
1140       const value = gState.get(key);
1141       switch (key) {
1142         case "Type":
1143           break;
1144         case "LW":
1145         case "LC":
1146         case "LJ":
1147         case "ML":
1148         case "D":
1149         case "RI":
1150         case "FL":
1151         case "CA":
1152         case "ca":
1153           gStateObj.push([key, value]);
1154           break;
1155         case "Font":
1156           isSimpleGState = false;
1157 
1158           promise = promise.then(() =>
1159             this.handleSetFont(
1160               resources,
1161               null,
1162               value[0],
1163               operatorList,
1164               task,
1165               stateManager.state
1166             ).then(function (loadedName) {
1167               operatorList.addDependency(loadedName);
1168               gStateObj.push([key, [loadedName, value[1]]]);
1169             })
1170           );
1171           break;
1172         case "BM":
1173           gStateObj.push([key, normalizeBlendMode(value)]);
1174           break;
1175         case "SMask":
1176           if (isName(value, "None")) {
1177             gStateObj.push([key, false]);
1178             break;
1179           }
1180           if (value instanceof Dict) {
1181             isSimpleGState = false;
1182 
1183             promise = promise.then(() =>
1184               this.handleSMask(
1185                 value,
1186                 resources,
1187                 operatorList,
1188                 task,
1189                 stateManager,
1190                 localColorSpaceCache
1191               )
1192             );
1193             gStateObj.push([key, true]);
1194           } else {
1195             warn("Unsupported SMask type");
1196           }
1197           break;
1198         case "TR":
1199           const transferMaps = this.handleTransferFunction(value);
1200           gStateObj.push([key, transferMaps]);
1201           break;
1202         // Only generate info log messages for the following since
1203         // they are unlikely to have a big impact on the rendering.
1204         case "OP":
1205         case "op":
1206         case "OPM":
1207         case "BG":
1208         case "BG2":
1209         case "UCR":
1210         case "UCR2":
1211         case "TR2":
1212         case "HT":
1213         case "SM":
1214         case "SA":
1215         case "AIS":
1216         case "TK":
1217           // TODO implement these operators.
1218           info("graphic state operator " + key);
1219           break;
1220         default:
1221           info("Unknown graphic state operator " + key);
1222           break;
1223       }
1224     }
1225     await promise;
1226 
1227     if (gStateObj.length > 0) {
1228       operatorList.addOp(OPS.setGState, [gStateObj]);
1229     }
1230 
1231     if (isSimpleGState) {
1232       localGStateCache.set(cacheKey, gStateRef, gStateObj);
1233     }
1234   }
1235 
1236   loadFont(
1237     fontName,
1238     font,
1239     resources,
1240     fallbackFontDict = null,
1241     cssFontInfo = null
1242   ) {
1243     // eslint-disable-next-line arrow-body-style
1244     const errorFont = async () => {
1245       return new TranslatedFont({
1246         loadedName: "g_font_error",
1247         font: new ErrorFont(`Font "${fontName}" is not available.`),
1248         dict: font,
1249         evaluatorOptions: this.options,
1250       });
1251     };
1252 
1253     let fontRef;
1254     if (font) {
1255       // Loading by ref.
1256       if (font instanceof Ref) {
1257         fontRef = font;
1258       }
1259     } else {
1260       // Loading by name.
1261       const fontRes = resources.get("Font");
1262       if (fontRes) {
1263         fontRef = fontRes.getRaw(fontName);
1264       }
1265     }
1266     if (fontRef) {
1267       if (this.type3FontRefs?.has(fontRef)) {
1268         return errorFont();
1269       }
1270 
1271       if (this.fontCache.has(fontRef)) {
1272         return this.fontCache.get(fontRef);
1273       }
1274 
1275       try {
1276         font = this.xref.fetchIfRef(fontRef);
1277       } catch (ex) {
1278         warn(`loadFont - lookup failed: "${ex}".`);
1279       }
1280     }
1281 
1282     if (!(font instanceof Dict)) {
1283       if (!this.options.ignoreErrors && !this.parsingType3Font) {
1284         warn(`Font "${fontName}" is not available.`);
1285         return errorFont();
1286       }
1287       warn(
1288         `Font "${fontName}" is not available -- attempting to fallback to a default font.`
1289       );
1290 
1291       // Falling back to a default font to avoid completely broken rendering,
1292       // but note that there're no guarantees that things will look "correct".
1293       font = fallbackFontDict || PartialEvaluator.fallbackFontDict;
1294     }
1295 
1296     // We are holding `font.cacheKey` references only for `fontRef`s that
1297     // are not actually `Ref`s, but rather `Dict`s. See explanation below.
1298     if (font.cacheKey && this.fontCache.has(font.cacheKey)) {
1299       return this.fontCache.get(font.cacheKey);
1300     }
1301 
1302     const { promise, resolve } = Promise.withResolvers();
1303 
1304     let preEvaluatedFont;
1305     try {
1306       preEvaluatedFont = this.preEvaluateFont(font);
1307       preEvaluatedFont.cssFontInfo = cssFontInfo;
1308     } catch (reason) {
1309       warn(`loadFont - preEvaluateFont failed: "${reason}".`);
1310       return errorFont();
1311     }
1312     const { descriptor, hash } = preEvaluatedFont;
1313 
1314     const fontRefIsRef = fontRef instanceof Ref;
1315     let fontID;
1316 
1317     if (hash && descriptor instanceof Dict) {
1318       const fontAliases = (descriptor.fontAliases ||= Object.create(null));
1319 
1320       if (fontAliases[hash]) {
1321         const aliasFontRef = fontAliases[hash].aliasRef;
1322         if (fontRefIsRef && aliasFontRef && this.fontCache.has(aliasFontRef)) {
1323           this.fontCache.putAlias(fontRef, aliasFontRef);
1324           return this.fontCache.get(fontRef);
1325         }
1326       } else {
1327         fontAliases[hash] = {
1328           fontID: this.idFactory.createFontId(),
1329         };
1330       }
1331 
1332       if (fontRefIsRef) {
1333         fontAliases[hash].aliasRef = fontRef;
1334       }
1335       fontID = fontAliases[hash].fontID;
1336     } else {
1337       fontID = this.idFactory.createFontId();
1338     }
1339     assert(
1340       fontID?.startsWith("f"),
1341       'The "fontID" must be (correctly) defined.'
1342     );
1343 
1344     // Workaround for bad PDF generators that reference fonts incorrectly,
1345     // where `fontRef` is a `Dict` rather than a `Ref` (fixes bug946506.pdf).
1346     // In this case we cannot put the font into `this.fontCache` (which is
1347     // a `RefSetCache`), since it's not possible to use a `Dict` as a key.
1348     //
1349     // However, if we don't cache the font it's not possible to remove it
1350     // when `cleanup` is triggered from the API, which causes issues on
1351     // subsequent rendering operations (see issue7403.pdf) and would force us
1352     // to unnecessarily load the same fonts over and over.
1353     //
1354     // Instead, we cheat a bit by using a modified `fontID` as a key in
1355     // `this.fontCache`, to allow the font to be cached.
1356     // NOTE: This works because `RefSetCache` calls `toString()` on provided
1357     //       keys. Also, since `fontRef` is used when getting cached fonts,
1358     //       we'll not accidentally match fonts cached with the `fontID`.
1359     if (fontRefIsRef) {
1360       this.fontCache.put(fontRef, promise);
1361     } else {
1362       font.cacheKey = `cacheKey_${fontID}`;
1363       this.fontCache.put(font.cacheKey, promise);
1364     }
1365 
1366     // Keep track of each font we translated so the caller can
1367     // load them asynchronously before calling display on a page.
1368     font.loadedName = `${this.idFactory.getDocId()}_${fontID}`;
1369 
1370     this.translateFont(preEvaluatedFont)
1371       .then(translatedFont => {
1372         resolve(
1373           new TranslatedFont({
1374             loadedName: font.loadedName,
1375             font: translatedFont,
1376             dict: font,
1377             evaluatorOptions: this.options,
1378           })
1379         );
1380       })
1381       .catch(reason => {
1382         // TODO reject?
1383         warn(`loadFont - translateFont failed: "${reason}".`);
1384 
1385         resolve(
1386           new TranslatedFont({
1387             loadedName: font.loadedName,
1388             font: new ErrorFont(
1389               reason instanceof Error ? reason.message : reason
1390             ),
1391             dict: font,
1392             evaluatorOptions: this.options,
1393           })
1394         );
1395       });
1396     return promise;
1397   }
1398 
1399   buildPath(operatorList, fn, args, parsingText = false) {
1400     const lastIndex = operatorList.length - 1;
1401     if (!args) {
1402       args = [];
1403     }
1404     if (
1405       lastIndex < 0 ||
1406       operatorList.fnArray[lastIndex] !== OPS.constructPath
1407     ) {
1408       // Handle corrupt PDF documents that contains path operators inside of
1409       // text objects, which may shift subsequent text, by enclosing the path
1410       // operator in save/restore operators (fixes issue10542_reduced.pdf).
1411       //
1412       // Note that this will effectively disable the optimization in the
1413       // `else` branch below, but given that this type of corruption is
1414       // *extremely* rare that shouldn't really matter much in practice.
1415       if (parsingText) {
1416         warn(`Encountered path operator "${fn}" inside of a text object.`);
1417         operatorList.addOp(OPS.save, null);
1418       }
1419 
1420       let minMax;
1421       switch (fn) {
1422         case OPS.rectangle:
1423           const x = args[0] + args[2];
1424           const y = args[1] + args[3];
1425           minMax = [
1426             Math.min(args[0], x),
1427             Math.min(args[1], y),
1428             Math.max(args[0], x),
1429             Math.max(args[1], y),
1430           ];
1431           break;
1432         case OPS.moveTo:
1433         case OPS.lineTo:
1434           minMax = [args[0], args[1], args[0], args[1]];
1435           break;
1436         default:
1437           minMax = [Infinity, Infinity, -Infinity, -Infinity];
1438           break;
1439       }
1440       operatorList.addOp(OPS.constructPath, [[fn], args, minMax]);
1441 
1442       if (parsingText) {
1443         operatorList.addOp(OPS.restore, null);
1444       }
1445     } else {
1446       const opArgs = operatorList.argsArray[lastIndex];
1447       opArgs[0].push(fn);
1448       opArgs[1].push(...args);
1449       const minMax = opArgs[2];
1450 
1451       // Compute min/max in the worker instead of the main thread.
1452       // If the current matrix (when drawing) is a scaling one
1453       // then min/max can be easily computed in using those values.
1454       // Only rectangle, lineTo and moveTo are handled here since
1455       // Bezier stuff requires to have the starting point.
1456       switch (fn) {
1457         case OPS.rectangle:
1458           const x = args[0] + args[2];
1459           const y = args[1] + args[3];
1460           minMax[0] = Math.min(minMax[0], args[0], x);
1461           minMax[1] = Math.min(minMax[1], args[1], y);
1462           minMax[2] = Math.max(minMax[2], args[0], x);
1463           minMax[3] = Math.max(minMax[3], args[1], y);
1464           break;
1465         case OPS.moveTo:
1466         case OPS.lineTo:
1467           minMax[0] = Math.min(minMax[0], args[0]);
1468           minMax[1] = Math.min(minMax[1], args[1]);
1469           minMax[2] = Math.max(minMax[2], args[0]);
1470           minMax[3] = Math.max(minMax[3], args[1]);
1471           break;
1472       }
1473     }
1474   }
1475 
1476   parseColorSpace({ cs, resources, localColorSpaceCache }) {
1477     return ColorSpace.parseAsync({
1478       cs,
1479       xref: this.xref,
1480       resources,
1481       pdfFunctionFactory: this._pdfFunctionFactory,
1482       localColorSpaceCache,
1483     }).catch(reason => {
1484       if (reason instanceof AbortException) {
1485         return null;
1486       }
1487       if (this.options.ignoreErrors) {
1488         warn(`parseColorSpace - ignoring ColorSpace: "${reason}".`);
1489         return null;
1490       }
1491       throw reason;
1492     });
1493   }
1494 
1495   parseShading({
1496     shading,
1497     resources,
1498     localColorSpaceCache,
1499     localShadingPatternCache,
1500   }) {
1501     // Shadings and patterns may be referenced by the same name but the resource
1502     // dictionary could be different so we can't use the name for the cache key.
1503     let id = localShadingPatternCache.get(shading);
1504     if (id) {
1505       return id;
1506     }
1507     let patternIR;
1508 
1509     try {
1510       const shadingFill = Pattern.parseShading(
1511         shading,
1512         this.xref,
1513         resources,
1514         this._pdfFunctionFactory,
1515         localColorSpaceCache
1516       );
1517       patternIR = shadingFill.getIR();
1518     } catch (reason) {
1519       if (reason instanceof AbortException) {
1520         return null;
1521       }
1522       if (this.options.ignoreErrors) {
1523         warn(`parseShading - ignoring shading: "${reason}".`);
1524 
1525         localShadingPatternCache.set(shading, null);
1526         return null;
1527       }
1528       throw reason;
1529     }
1530 
1531     id = `pattern_${this.idFactory.createObjId()}`;
1532     if (this.parsingType3Font) {
1533       id = `${this.idFactory.getDocId()}_type3_${id}`;
1534     }
1535     localShadingPatternCache.set(shading, id);
1536 
1537     if (this.parsingType3Font) {
1538       this.handler.send("commonobj", [id, "Pattern", patternIR]);
1539     } else {
1540       this.handler.send("obj", [id, this.pageIndex, "Pattern", patternIR]);
1541     }
1542     return id;
1543   }
1544 
1545   handleColorN(
1546     operatorList,
1547     fn,
1548     args,
1549     cs,
1550     patterns,
1551     resources,
1552     task,
1553     localColorSpaceCache,
1554     localTilingPatternCache,
1555     localShadingPatternCache
1556   ) {
1557     // compile tiling patterns
1558     const patternName = args.pop();
1559     // SCN/scn applies patterns along with normal colors
1560     if (patternName instanceof Name) {
1561       const rawPattern = patterns.getRaw(patternName.name);
1562 
1563       const localTilingPattern =
1564         rawPattern instanceof Ref &&
1565         localTilingPatternCache.getByRef(rawPattern);
1566       if (localTilingPattern) {
1567         try {
1568           const color = cs.base ? cs.base.getRgb(args, 0) : null;
1569           const tilingPatternIR = getTilingPatternIR(
1570             localTilingPattern.operatorListIR,
1571             localTilingPattern.dict,
1572             color
1573           );
1574           operatorList.addOp(fn, tilingPatternIR);
1575           return undefined;
1576         } catch {
1577           // Handle any errors during normal TilingPattern parsing.
1578         }
1579       }
1580 
1581       const pattern = this.xref.fetchIfRef(rawPattern);
1582       if (pattern) {
1583         const dict = pattern instanceof BaseStream ? pattern.dict : pattern;
1584         const typeNum = dict.get("PatternType");
1585 
1586         if (typeNum === PatternType.TILING) {
1587           const color = cs.base ? cs.base.getRgb(args, 0) : null;
1588           return this.handleTilingType(
1589             fn,
1590             color,
1591             resources,
1592             pattern,
1593             dict,
1594             operatorList,
1595             task,
1596             localTilingPatternCache
1597           );
1598         } else if (typeNum === PatternType.SHADING) {
1599           const shading = dict.get("Shading");
1600           const objId = this.parseShading({
1601             shading,
1602             resources,
1603             localColorSpaceCache,
1604             localShadingPatternCache,
1605           });
1606           if (objId) {
1607             const matrix = lookupMatrix(dict.getArray("Matrix"), null);
1608             operatorList.addOp(fn, ["Shading", objId, matrix]);
1609           }
1610           return undefined;
1611         }
1612         throw new FormatError(`Unknown PatternType: ${typeNum}`);
1613       }
1614     }
1615     throw new FormatError(`Unknown PatternName: ${patternName}`);
1616   }
1617 
1618   _parseVisibilityExpression(array, nestingCounter, currentResult) {
1619     const MAX_NESTING = 10;
1620     if (++nestingCounter > MAX_NESTING) {
1621       warn("Visibility expression is too deeply nested");
1622       return;
1623     }
1624     const length = array.length;
1625     const operator = this.xref.fetchIfRef(array[0]);
1626     if (length < 2 || !(operator instanceof Name)) {
1627       warn("Invalid visibility expression");
1628       return;
1629     }
1630     switch (operator.name) {
1631       case "And":
1632       case "Or":
1633       case "Not":
1634         currentResult.push(operator.name);
1635         break;
1636       default:
1637         warn(`Invalid operator ${operator.name} in visibility expression`);
1638         return;
1639     }
1640     for (let i = 1; i < length; i++) {
1641       const raw = array[i];
1642       const object = this.xref.fetchIfRef(raw);
1643       if (Array.isArray(object)) {
1644         const nestedResult = [];
1645         currentResult.push(nestedResult);
1646         // Recursively parse a subarray.
1647         this._parseVisibilityExpression(object, nestingCounter, nestedResult);
1648       } else if (raw instanceof Ref) {
1649         // Reference to an OCG dictionary.
1650         currentResult.push(raw.toString());
1651       }
1652     }
1653   }
1654 
1655   async parseMarkedContentProps(contentProperties, resources) {
1656     let optionalContent;
1657     if (contentProperties instanceof Name) {
1658       const properties = resources.get("Properties");
1659       optionalContent = properties.get(contentProperties.name);
1660     } else if (contentProperties instanceof Dict) {
1661       optionalContent = contentProperties;
1662     } else {
1663       throw new FormatError("Optional content properties malformed.");
1664     }
1665 
1666     const optionalContentType = optionalContent.get("Type")?.name;
1667     if (optionalContentType === "OCG") {
1668       return {
1669         type: optionalContentType,
1670         id: optionalContent.objId,
1671       };
1672     } else if (optionalContentType === "OCMD") {
1673       const expression = optionalContent.get("VE");
1674       if (Array.isArray(expression)) {
1675         const result = [];
1676         this._parseVisibilityExpression(expression, 0, result);
1677         if (result.length > 0) {
1678           return {
1679             type: "OCMD",
1680             expression: result,
1681           };
1682         }
1683       }
1684 
1685       const optionalContentGroups = optionalContent.get("OCGs");
1686       if (
1687         Array.isArray(optionalContentGroups) ||
1688         optionalContentGroups instanceof Dict
1689       ) {
1690         const groupIds = [];
1691         if (Array.isArray(optionalContentGroups)) {
1692           for (const ocg of optionalContentGroups) {
1693             groupIds.push(ocg.toString());
1694           }
1695         } else {
1696           // Dictionary, just use the obj id.
1697           groupIds.push(optionalContentGroups.objId);
1698         }
1699 
1700         return {
1701           type: optionalContentType,
1702           ids: groupIds,
1703           policy:
1704             optionalContent.get("P") instanceof Name
1705               ? optionalContent.get("P").name
1706               : null,
1707           expression: null,
1708         };
1709       } else if (optionalContentGroups instanceof Ref) {
1710         return {
1711           type: optionalContentType,
1712           id: optionalContentGroups.toString(),
1713         };
1714       }
1715     }
1716     return null;
1717   }
1718 
1719   getOperatorList({
1720     stream,
1721     task,
1722     resources,
1723     operatorList,
1724     initialState = null,
1725     fallbackFontDict = null,
1726   }) {
1727     // Ensure that `resources`/`initialState` is correctly initialized,
1728     // even if the provided parameter is e.g. `null`.
1729     resources ||= Dict.empty;
1730     initialState ||= new EvalState();
1731 
1732     if (!operatorList) {
1733       throw new Error('getOperatorList: missing "operatorList" parameter');
1734     }
1735 
1736     const self = this;
1737     const xref = this.xref;
1738     let parsingText = false;
1739     const localImageCache = new LocalImageCache();
1740     const localColorSpaceCache = new LocalColorSpaceCache();
1741     const localGStateCache = new LocalGStateCache();
1742     const localTilingPatternCache = new LocalTilingPatternCache();
1743     const localShadingPatternCache = new Map();
1744 
1745     const xobjs = resources.get("XObject") || Dict.empty;
1746     const patterns = resources.get("Pattern") || Dict.empty;
1747     const stateManager = new StateManager(initialState);
1748     const preprocessor = new EvaluatorPreprocessor(stream, xref, stateManager);
1749     const timeSlotManager = new TimeSlotManager();
1750 
1751     function closePendingRestoreOPS(argument) {
1752       for (let i = 0, ii = preprocessor.savedStatesDepth; i < ii; i++) {
1753         operatorList.addOp(OPS.restore, []);
1754       }
1755     }
1756 
1757     return new Promise(function promiseBody(resolve, reject) {
1758       const next = function (promise) {
1759         Promise.all([promise, operatorList.ready]).then(function () {
1760           try {
1761             promiseBody(resolve, reject);
1762           } catch (ex) {
1763             reject(ex);
1764           }
1765         }, reject);
1766       };
1767       task.ensureNotTerminated();
1768       timeSlotManager.reset();
1769 
1770       const operation = {};
1771       let stop, i, ii, cs, name, isValidName;
1772       while (!(stop = timeSlotManager.check())) {
1773         // The arguments parsed by read() are used beyond this loop, so we
1774         // cannot reuse the same array on each iteration. Therefore we pass
1775         // in |null| as the initial value (see the comment on
1776         // EvaluatorPreprocessor_read() for why).
1777         operation.args = null;
1778         if (!preprocessor.read(operation)) {
1779           break;
1780         }
1781         let args = operation.args;
1782         let fn = operation.fn;
1783 
1784         switch (fn | 0) {
1785           case OPS.paintXObject:
1786             // eagerly compile XForm objects
1787             isValidName = args[0] instanceof Name;
1788             name = args[0].name;
1789 
1790             if (isValidName) {
1791               const localImage = localImageCache.getByName(name);
1792               if (localImage) {
1793                 addLocallyCachedImageOps(operatorList, localImage);
1794                 args = null;
1795                 continue;
1796               }
1797             }
1798 
1799             next(
1800               new Promise(function (resolveXObject, rejectXObject) {
1801                 if (!isValidName) {
1802                   throw new FormatError("XObject must be referred to by name.");
1803                 }
1804 
1805                 let xobj = xobjs.getRaw(name);
1806                 if (xobj instanceof Ref) {
1807                   const localImage =
1808                     localImageCache.getByRef(xobj) ||
1809                     self._regionalImageCache.getByRef(xobj);
1810                   if (localImage) {
1811                     addLocallyCachedImageOps(operatorList, localImage);
1812                     resolveXObject();
1813                     return;
1814                   }
1815 
1816                   const globalImage = self.globalImageCache.getData(
1817                     xobj,
1818                     self.pageIndex
1819                   );
1820                   if (globalImage) {
1821                     operatorList.addDependency(globalImage.objId);
1822                     operatorList.addImageOps(
1823                       globalImage.fn,
1824                       globalImage.args,
1825                       globalImage.optionalContent
1826                     );
1827 
1828                     resolveXObject();
1829                     return;
1830                   }
1831 
1832                   xobj = xref.fetch(xobj);
1833                 }
1834 
1835                 if (!(xobj instanceof BaseStream)) {
1836                   throw new FormatError("XObject should be a stream");
1837                 }
1838 
1839                 const type = xobj.dict.get("Subtype");
1840                 if (!(type instanceof Name)) {
1841                   throw new FormatError("XObject should have a Name subtype");
1842                 }
1843 
1844                 if (type.name === "Form") {
1845                   stateManager.save();
1846                   self
1847                     .buildFormXObject(
1848                       resources,
1849                       xobj,
1850                       null,
1851                       operatorList,
1852                       task,
1853                       stateManager.state.clone(),
1854                       localColorSpaceCache
1855                     )
1856                     .then(function () {
1857                       stateManager.restore();
1858                       resolveXObject();
1859                     }, rejectXObject);
1860                   return;
1861                 } else if (type.name === "Image") {
1862                   self
1863                     .buildPaintImageXObject({
1864                       resources,
1865                       image: xobj,
1866                       operatorList,
1867                       cacheKey: name,
1868                       localImageCache,
1869                       localColorSpaceCache,
1870                     })
1871                     .then(resolveXObject, rejectXObject);
1872                   return;
1873                 } else if (type.name === "PS") {
1874                   // PostScript XObjects are unused when viewing documents.
1875                   // See section 4.7.1 of Adobe's PDF reference.
1876                   info("Ignored XObject subtype PS");
1877                 } else {
1878                   throw new FormatError(
1879                     `Unhandled XObject subtype ${type.name}`
1880                   );
1881                 }
1882                 resolveXObject();
1883               }).catch(function (reason) {
1884                 if (reason instanceof AbortException) {
1885                   return;
1886                 }
1887                 if (self.options.ignoreErrors) {
1888                   warn(`getOperatorList - ignoring XObject: "${reason}".`);
1889                   return;
1890                 }
1891                 throw reason;
1892               })
1893             );
1894             return;
1895           case OPS.setFont:
1896             var fontSize = args[1];
1897             // eagerly collect all fonts
1898             next(
1899               self
1900                 .handleSetFont(
1901                   resources,
1902                   args,
1903                   null,
1904                   operatorList,
1905                   task,
1906                   stateManager.state,
1907                   fallbackFontDict
1908                 )
1909                 .then(function (loadedName) {
1910                   operatorList.addDependency(loadedName);
1911                   operatorList.addOp(OPS.setFont, [loadedName, fontSize]);
1912                 })
1913             );
1914             return;
1915           case OPS.beginText:
1916             parsingText = true;
1917             break;
1918           case OPS.endText:
1919             parsingText = false;
1920             break;
1921           case OPS.endInlineImage:
1922             var cacheKey = args[0].cacheKey;
1923             if (cacheKey) {
1924               const localImage = localImageCache.getByName(cacheKey);
1925               if (localImage) {
1926                 addLocallyCachedImageOps(operatorList, localImage);
1927                 args = null;
1928                 continue;
1929               }
1930             }
1931             next(
1932               self.buildPaintImageXObject({
1933                 resources,
1934                 image: args[0],
1935                 isInline: true,
1936                 operatorList,
1937                 cacheKey,
1938                 localImageCache,
1939                 localColorSpaceCache,
1940               })
1941             );
1942             return;
1943           case OPS.showText:
1944             if (!stateManager.state.font) {
1945               self.ensureStateFont(stateManager.state);
1946               continue;
1947             }
1948             args[0] = self.handleText(args[0], stateManager.state);
1949             break;
1950           case OPS.showSpacedText:
1951             if (!stateManager.state.font) {
1952               self.ensureStateFont(stateManager.state);
1953               continue;
1954             }
1955             var combinedGlyphs = [];
1956             var state = stateManager.state;
1957             for (const arrItem of args[0]) {
1958               if (typeof arrItem === "string") {
1959                 combinedGlyphs.push(...self.handleText(arrItem, state));
1960               } else if (typeof arrItem === "number") {
1961                 combinedGlyphs.push(arrItem);
1962               }
1963             }
1964             args[0] = combinedGlyphs;
1965             fn = OPS.showText;
1966             break;
1967           case OPS.nextLineShowText:
1968             if (!stateManager.state.font) {
1969               self.ensureStateFont(stateManager.state);
1970               continue;
1971             }
1972             operatorList.addOp(OPS.nextLine);
1973             args[0] = self.handleText(args[0], stateManager.state);
1974             fn = OPS.showText;
1975             break;
1976           case OPS.nextLineSetSpacingShowText:
1977             if (!stateManager.state.font) {
1978               self.ensureStateFont(stateManager.state);
1979               continue;
1980             }
1981             operatorList.addOp(OPS.nextLine);
1982             operatorList.addOp(OPS.setWordSpacing, [args.shift()]);
1983             operatorList.addOp(OPS.setCharSpacing, [args.shift()]);
1984             args[0] = self.handleText(args[0], stateManager.state);
1985             fn = OPS.showText;
1986             break;
1987           case OPS.setTextRenderingMode:
1988             stateManager.state.textRenderingMode = args[0];
1989             break;
1990 
1991           case OPS.setFillColorSpace: {
1992             const cachedColorSpace = ColorSpace.getCached(
1993               args[0],
1994               xref,
1995               localColorSpaceCache
1996             );
1997             if (cachedColorSpace) {
1998               stateManager.state.fillColorSpace = cachedColorSpace;
1999               continue;
2000             }
2001 
2002             next(
2003               self
2004                 .parseColorSpace({
2005                   cs: args[0],
2006                   resources,
2007                   localColorSpaceCache,
2008                 })
2009                 .then(function (colorSpace) {
2010                   stateManager.state.fillColorSpace =
2011                     colorSpace || ColorSpace.singletons.gray;
2012                 })
2013             );
2014             return;
2015           }
2016           case OPS.setStrokeColorSpace: {
2017             const cachedColorSpace = ColorSpace.getCached(
2018               args[0],
2019               xref,
2020               localColorSpaceCache
2021             );
2022             if (cachedColorSpace) {
2023               stateManager.state.strokeColorSpace = cachedColorSpace;
2024               continue;
2025             }
2026 
2027             next(
2028               self
2029                 .parseColorSpace({
2030                   cs: args[0],
2031                   resources,
2032                   localColorSpaceCache,
2033                 })
2034                 .then(function (colorSpace) {
2035                   stateManager.state.strokeColorSpace =
2036                     colorSpace || ColorSpace.singletons.gray;
2037                 })
2038             );
2039             return;
2040           }
2041           case OPS.setFillColor:
2042             cs = stateManager.state.fillColorSpace;
2043             args = cs.getRgb(args, 0);
2044             fn = OPS.setFillRGBColor;
2045             break;
2046           case OPS.setStrokeColor:
2047             cs = stateManager.state.strokeColorSpace;
2048             args = cs.getRgb(args, 0);
2049             fn = OPS.setStrokeRGBColor;
2050             break;
2051           case OPS.setFillGray:
2052             stateManager.state.fillColorSpace = ColorSpace.singletons.gray;
2053             args = ColorSpace.singletons.gray.getRgb(args, 0);
2054             fn = OPS.setFillRGBColor;
2055             break;
2056           case OPS.setStrokeGray:
2057             stateManager.state.strokeColorSpace = ColorSpace.singletons.gray;
2058             args = ColorSpace.singletons.gray.getRgb(args, 0);
2059             fn = OPS.setStrokeRGBColor;
2060             break;
2061           case OPS.setFillCMYKColor:
2062             stateManager.state.fillColorSpace = ColorSpace.singletons.cmyk;
2063             args = ColorSpace.singletons.cmyk.getRgb(args, 0);
2064             fn = OPS.setFillRGBColor;
2065             break;
2066           case OPS.setStrokeCMYKColor:
2067             stateManager.state.strokeColorSpace = ColorSpace.singletons.cmyk;
2068             args = ColorSpace.singletons.cmyk.getRgb(args, 0);
2069             fn = OPS.setStrokeRGBColor;
2070             break;
2071           case OPS.setFillRGBColor:
2072             stateManager.state.fillColorSpace = ColorSpace.singletons.rgb;
2073             args = ColorSpace.singletons.rgb.getRgb(args, 0);
2074             break;
2075           case OPS.setStrokeRGBColor:
2076             stateManager.state.strokeColorSpace = ColorSpace.singletons.rgb;
2077             args = ColorSpace.singletons.rgb.getRgb(args, 0);
2078             break;
2079           case OPS.setFillColorN:
2080             cs = stateManager.state.patternFillColorSpace;
2081             if (!cs) {
2082               if (isNumberArray(args, null)) {
2083                 args = ColorSpace.singletons.gray.getRgb(args, 0);
2084                 fn = OPS.setFillRGBColor;
2085                 break;
2086               }
2087               args = [];
2088               fn = OPS.setFillTransparent;
2089               break;
2090             }
2091             if (cs.name === "Pattern") {
2092               next(
2093                 self.handleColorN(
2094                   operatorList,
2095                   OPS.setFillColorN,
2096                   args,
2097                   cs,
2098                   patterns,
2099                   resources,
2100                   task,
2101                   localColorSpaceCache,
2102                   localTilingPatternCache,
2103                   localShadingPatternCache
2104                 )
2105               );
2106               return;
2107             }
2108             args = cs.getRgb(args, 0);
2109             fn = OPS.setFillRGBColor;
2110             break;
2111           case OPS.setStrokeColorN:
2112             cs = stateManager.state.patternStrokeColorSpace;
2113             if (!cs) {
2114               if (isNumberArray(args, null)) {
2115                 args = ColorSpace.singletons.gray.getRgb(args, 0);
2116                 fn = OPS.setStrokeRGBColor;
2117                 break;
2118               }
2119               args = [];
2120               fn = OPS.setStrokeTransparent;
2121               break;
2122             }
2123             if (cs.name === "Pattern") {
2124               next(
2125                 self.handleColorN(
2126                   operatorList,
2127                   OPS.setStrokeColorN,
2128                   args,
2129                   cs,
2130                   patterns,
2131                   resources,
2132                   task,
2133                   localColorSpaceCache,
2134                   localTilingPatternCache,
2135                   localShadingPatternCache
2136                 )
2137               );
2138               return;
2139             }
2140             args = cs.getRgb(args, 0);
2141             fn = OPS.setStrokeRGBColor;
2142             break;
2143 
2144           case OPS.shadingFill:
2145             let shading;
2146             try {
2147               const shadingRes = resources.get("Shading");
2148               if (!shadingRes) {
2149                 throw new FormatError("No shading resource found");
2150               }
2151 
2152               shading = shadingRes.get(args[0].name);
2153               if (!shading) {
2154                 throw new FormatError("No shading object found");
2155               }
2156             } catch (reason) {
2157               if (reason instanceof AbortException) {
2158                 continue;
2159               }
2160               if (self.options.ignoreErrors) {
2161                 warn(`getOperatorList - ignoring Shading: "${reason}".`);
2162                 continue;
2163               }
2164               throw reason;
2165             }
2166             const patternId = self.parseShading({
2167               shading,
2168               resources,
2169               localColorSpaceCache,
2170               localShadingPatternCache,
2171             });
2172             if (!patternId) {
2173               continue;
2174             }
2175             args = [patternId];
2176             fn = OPS.shadingFill;
2177             break;
2178           case OPS.setGState:
2179             isValidName = args[0] instanceof Name;
2180             name = args[0].name;
2181 
2182             if (isValidName) {
2183               const localGStateObj = localGStateCache.getByName(name);
2184               if (localGStateObj) {
2185                 if (localGStateObj.length > 0) {
2186                   operatorList.addOp(OPS.setGState, [localGStateObj]);
2187                 }
2188                 args = null;
2189                 continue;
2190               }
2191             }
2192 
2193             next(
2194               new Promise(function (resolveGState, rejectGState) {
2195                 if (!isValidName) {
2196                   throw new FormatError("GState must be referred to by name.");
2197                 }
2198 
2199                 const extGState = resources.get("ExtGState");
2200                 if (!(extGState instanceof Dict)) {
2201                   throw new FormatError("ExtGState should be a dictionary.");
2202                 }
2203 
2204                 const gState = extGState.get(name);
2205                 // TODO: Attempt to lookup cached GStates by reference as well,
2206                 //       if and only if there are PDF documents where doing so
2207                 //       would significantly improve performance.
2208                 if (!(gState instanceof Dict)) {
2209                   throw new FormatError("GState should be a dictionary.");
2210                 }
2211 
2212                 self
2213                   .setGState({
2214                     resources,
2215                     gState,
2216                     operatorList,
2217                     cacheKey: name,
2218                     task,
2219                     stateManager,
2220                     localGStateCache,
2221                     localColorSpaceCache,
2222                   })
2223                   .then(resolveGState, rejectGState);
2224               }).catch(function (reason) {
2225                 if (reason instanceof AbortException) {
2226                   return;
2227                 }
2228                 if (self.options.ignoreErrors) {
2229                   warn(`getOperatorList - ignoring ExtGState: "${reason}".`);
2230                   return;
2231                 }
2232                 throw reason;
2233               })
2234             );
2235             return;
2236           case OPS.moveTo:
2237           case OPS.lineTo:
2238           case OPS.curveTo:
2239           case OPS.curveTo2:
2240           case OPS.curveTo3:
2241           case OPS.closePath:
2242           case OPS.rectangle:
2243             self.buildPath(operatorList, fn, args, parsingText);
2244             continue;
2245           case OPS.markPoint:
2246           case OPS.markPointProps:
2247           case OPS.beginCompat:
2248           case OPS.endCompat:
2249             // Ignore operators where the corresponding handlers are known to
2250             // be no-op in CanvasGraphics (display/canvas.js). This prevents
2251             // serialization errors and is also a bit more efficient.
2252             // We could also try to serialize all objects in a general way,
2253             // e.g. as done in https://github.com/mozilla/pdf.js/pull/6266,
2254             // but doing so is meaningless without knowing the semantics.
2255             continue;
2256           case OPS.beginMarkedContentProps:
2257             if (!(args[0] instanceof Name)) {
2258               warn(`Expected name for beginMarkedContentProps arg0=${args[0]}`);
2259               operatorList.addOp(OPS.beginMarkedContentProps, ["OC", null]);
2260               continue;
2261             }
2262             if (args[0].name === "OC") {
2263               next(
2264                 self
2265                   .parseMarkedContentProps(args[1], resources)
2266                   .then(data => {
2267                     operatorList.addOp(OPS.beginMarkedContentProps, [
2268                       "OC",
2269                       data,
2270                     ]);
2271                   })
2272                   .catch(reason => {
2273                     if (reason instanceof AbortException) {
2274                       return;
2275                     }
2276                     if (self.options.ignoreErrors) {
2277                       warn(
2278                         `getOperatorList - ignoring beginMarkedContentProps: "${reason}".`
2279                       );
2280                       operatorList.addOp(OPS.beginMarkedContentProps, [
2281                         "OC",
2282                         null,
2283                       ]);
2284                       return;
2285                     }
2286                     throw reason;
2287                   })
2288               );
2289               return;
2290             }
2291             // Other marked content types aren't supported yet.
2292             args = [
2293               args[0].name,
2294               args[1] instanceof Dict ? args[1].get("MCID") : null,
2295             ];
2296 
2297             break;
2298           case OPS.beginMarkedContent:
2299           case OPS.endMarkedContent:
2300           default:
2301             // Note: Ignore the operator if it has `Dict` arguments, since
2302             // those are non-serializable, otherwise postMessage will throw
2303             // "An object could not be cloned.".
2304             if (args !== null) {
2305               for (i = 0, ii = args.length; i < ii; i++) {
2306                 if (args[i] instanceof Dict) {
2307                   break;
2308                 }
2309               }
2310               if (i < ii) {
2311                 warn("getOperatorList - ignoring operator: " + fn);
2312                 continue;
2313               }
2314             }
2315         }
2316         operatorList.addOp(fn, args);
2317       }
2318       if (stop) {
2319         next(deferred);
2320         return;
2321       }
2322       // Some PDFs don't close all restores inside object/form.
2323       // Closing those for them.
2324       closePendingRestoreOPS();
2325       resolve();
2326     }).catch(reason => {
2327       if (reason instanceof AbortException) {
2328         return;
2329       }
2330       if (this.options.ignoreErrors) {
2331         warn(
2332           `getOperatorList - ignoring errors during "${task.name}" ` +
2333             `task: "${reason}".`
2334         );
2335 
2336         closePendingRestoreOPS();
2337         return;
2338       }
2339       throw reason;
2340     });
2341   }
2342 
2343   getTextContent({
2344     stream,
2345     task,
2346     resources,
2347     stateManager = null,
2348     includeMarkedContent = false,
2349     sink,
2350     seenStyles = new Set(),
2351     viewBox,
2352     lang = null,
2353     markedContentData = null,
2354     disableNormalization = false,
2355     keepWhiteSpace = false,
2356   }) {
2357     // Ensure that `resources`/`stateManager` is correctly initialized,
2358     // even if the provided parameter is e.g. `null`.
2359     resources ||= Dict.empty;
2360     stateManager ||= new StateManager(new TextState());
2361 
2362     if (includeMarkedContent) {
2363       markedContentData ||= { level: 0 };
2364     }
2365 
2366     const textContent = {
2367       items: [],
2368       styles: Object.create(null),
2369       lang,
2370     };
2371     const textContentItem = {
2372       initialized: false,
2373       str: [],
2374       totalWidth: 0,
2375       totalHeight: 0,
2376       width: 0,
2377       height: 0,
2378       vertical: false,
2379       prevTransform: null,
2380       textAdvanceScale: 0,
2381       spaceInFlowMin: 0,
2382       spaceInFlowMax: 0,
2383       trackingSpaceMin: Infinity,
2384       negativeSpaceMax: -Infinity,
2385       notASpace: -Infinity,
2386       transform: null,
2387       fontName: null,
2388       hasEOL: false,
2389     };
2390 
2391     // Use a circular buffer (length === 2) to save the last chars in the
2392     // text stream.
2393     // This implementation of the circular buffer is using a fixed array
2394     // and the position of the next element:
2395     // function addElement(x) {
2396     //   buffer[pos] = x;
2397     //   pos = (pos + 1) % buffer.length;
2398     // }
2399     // It's a way faster than:
2400     // function addElement(x) {
2401     //   buffer.push(x);
2402     //   buffer.shift();
2403     // }
2404     //
2405     // It's useful to know when we need to add a whitespace in the
2406     // text chunk.
2407     const twoLastChars = [" ", " "];
2408     let twoLastCharsPos = 0;
2409 
2410     /**
2411      * Save the last char.
2412      * @param {string} char
2413      * @returns {boolean} true when the two last chars before adding the new one
2414      * are a non-whitespace followed by a whitespace.
2415      */
2416     function saveLastChar(char) {
2417       const nextPos = (twoLastCharsPos + 1) % 2;
2418       const ret =
2419         twoLastChars[twoLastCharsPos] !== " " && twoLastChars[nextPos] === " ";
2420       twoLastChars[twoLastCharsPos] = char;
2421       twoLastCharsPos = nextPos;
2422 
2423       return !keepWhiteSpace && ret;
2424     }
2425 
2426     function shouldAddWhitepsace() {
2427       return (
2428         !keepWhiteSpace &&
2429         twoLastChars[twoLastCharsPos] !== " " &&
2430         twoLastChars[(twoLastCharsPos + 1) % 2] === " "
2431       );
2432     }
2433 
2434     function resetLastChars() {
2435       twoLastChars[0] = twoLastChars[1] = " ";
2436       twoLastCharsPos = 0;
2437     }
2438 
2439     // Used in addFakeSpaces.
2440 
2441     // A white <= fontSize * TRACKING_SPACE_FACTOR is a tracking space
2442     // so it doesn't count as a space.
2443     const TRACKING_SPACE_FACTOR = 0.102;
2444 
2445     // When a white <= fontSize * NOT_A_SPACE_FACTOR, there is no space
2446     // even if one is present in the text stream.
2447     const NOT_A_SPACE_FACTOR = 0.03;
2448 
2449     // A negative white < fontSize * NEGATIVE_SPACE_FACTOR induces
2450     // a break (a new chunk of text is created).
2451     // It doesn't change anything when the text is copied but
2452     // it improves potential mismatch between text layer and canvas.
2453     const NEGATIVE_SPACE_FACTOR = -0.2;
2454 
2455     // A white with a width in [fontSize * MIN_FACTOR; fontSize * MAX_FACTOR]
2456     // is a space which will be inserted in the current flow of words.
2457     // If the width is outside of this range then the flow is broken
2458     // (which means a new span in the text layer).
2459     // It's useful to adjust the best as possible the span in the layer
2460     // to what is displayed in the canvas.
2461     const SPACE_IN_FLOW_MIN_FACTOR = 0.102;
2462     const SPACE_IN_FLOW_MAX_FACTOR = 0.6;
2463 
2464     // If a char is too high/too low compared to the previous we just create
2465     // a new chunk.
2466     // If the advance isn't in the +/-VERTICAL_SHIFT_RATIO * height range then
2467     // a new chunk is created.
2468     const VERTICAL_SHIFT_RATIO = 0.25;
2469 
2470     const self = this;
2471     const xref = this.xref;
2472     const showSpacedTextBuffer = [];
2473 
2474     // The xobj is parsed iff it's needed, e.g. if there is a `DO` cmd.
2475     let xobjs = null;
2476     const emptyXObjectCache = new LocalImageCache();
2477     const emptyGStateCache = new LocalGStateCache();
2478 
2479     const preprocessor = new EvaluatorPreprocessor(stream, xref, stateManager);
2480 
2481     let textState;
2482 
2483     function pushWhitespace({
2484       width = 0,
2485       height = 0,
2486       transform = textContentItem.prevTransform,
2487       fontName = textContentItem.fontName,
2488     }) {
2489       textContent.items.push({
2490         str: " ",
2491         dir: "ltr",
2492         width,
2493         height,
2494         transform,
2495         fontName,
2496         hasEOL: false,
2497       });
2498     }
2499 
2500     function getCurrentTextTransform() {
2501       // 9.4.4 Text Space Details
2502       const font = textState.font;
2503       const tsm = [
2504         textState.fontSize * textState.textHScale,
2505         0,
2506         0,
2507         textState.fontSize,
2508         0,
2509         textState.textRise,
2510       ];
2511 
2512       if (
2513         font.isType3Font &&
2514         (textState.fontSize <= 1 || font.isCharBBox) &&
2515         !isArrayEqual(textState.fontMatrix, FONT_IDENTITY_MATRIX)
2516       ) {
2517         const glyphHeight = font.bbox[3] - font.bbox[1];
2518         if (glyphHeight > 0) {
2519           tsm[3] *= glyphHeight * textState.fontMatrix[3];
2520         }
2521       }
2522 
2523       return Util.transform(
2524         textState.ctm,
2525         Util.transform(textState.textMatrix, tsm)
2526       );
2527     }
2528 
2529     function ensureTextContentItem() {
2530       if (textContentItem.initialized) {
2531         return textContentItem;
2532       }
2533       const { font, loadedName } = textState;
2534       if (!seenStyles.has(loadedName)) {
2535         seenStyles.add(loadedName);
2536         textContent.styles[loadedName] = {
2537           fontFamily: font.fallbackName,
2538           ascent: font.ascent,
2539           descent: font.descent,
2540           vertical: font.vertical,
2541         };
2542         if (self.options.fontExtraProperties && font.systemFontInfo) {
2543           const style = textContent.styles[loadedName];
2544           style.fontSubstitution = font.systemFontInfo.css;
2545           style.fontSubstitutionLoadedName = font.systemFontInfo.loadedName;
2546         }
2547       }
2548       textContentItem.fontName = loadedName;
2549 
2550       const trm = (textContentItem.transform = getCurrentTextTransform());
2551       if (!font.vertical) {
2552         textContentItem.width = textContentItem.totalWidth = 0;
2553         textContentItem.height = textContentItem.totalHeight = Math.hypot(
2554           trm[2],
2555           trm[3]
2556         );
2557         textContentItem.vertical = false;
2558       } else {
2559         textContentItem.width = textContentItem.totalWidth = Math.hypot(
2560           trm[0],
2561           trm[1]
2562         );
2563         textContentItem.height = textContentItem.totalHeight = 0;
2564         textContentItem.vertical = true;
2565       }
2566 
2567       const scaleLineX = Math.hypot(
2568         textState.textLineMatrix[0],
2569         textState.textLineMatrix[1]
2570       );
2571       const scaleCtmX = Math.hypot(textState.ctm[0], textState.ctm[1]);
2572       textContentItem.textAdvanceScale = scaleCtmX * scaleLineX;
2573 
2574       const { fontSize } = textState;
2575       textContentItem.trackingSpaceMin = fontSize * TRACKING_SPACE_FACTOR;
2576       textContentItem.notASpace = fontSize * NOT_A_SPACE_FACTOR;
2577       textContentItem.negativeSpaceMax = fontSize * NEGATIVE_SPACE_FACTOR;
2578       textContentItem.spaceInFlowMin = fontSize * SPACE_IN_FLOW_MIN_FACTOR;
2579       textContentItem.spaceInFlowMax = fontSize * SPACE_IN_FLOW_MAX_FACTOR;
2580       textContentItem.hasEOL = false;
2581 
2582       textContentItem.initialized = true;
2583       return textContentItem;
2584     }
2585 
2586     function updateAdvanceScale() {
2587       if (!textContentItem.initialized) {
2588         return;
2589       }
2590 
2591       const scaleLineX = Math.hypot(
2592         textState.textLineMatrix[0],
2593         textState.textLineMatrix[1]
2594       );
2595       const scaleCtmX = Math.hypot(textState.ctm[0], textState.ctm[1]);
2596       const scaleFactor = scaleCtmX * scaleLineX;
2597       if (scaleFactor === textContentItem.textAdvanceScale) {
2598         return;
2599       }
2600 
2601       if (!textContentItem.vertical) {
2602         textContentItem.totalWidth +=
2603           textContentItem.width * textContentItem.textAdvanceScale;
2604         textContentItem.width = 0;
2605       } else {
2606         textContentItem.totalHeight +=
2607           textContentItem.height * textContentItem.textAdvanceScale;
2608         textContentItem.height = 0;
2609       }
2610 
2611       textContentItem.textAdvanceScale = scaleFactor;
2612     }
2613 
2614     function runBidiTransform(textChunk) {
2615       let text = textChunk.str.join("");
2616       if (!disableNormalization) {
2617         text = normalizeUnicode(text);
2618       }
2619       const bidiResult = bidi(text, -1, textChunk.vertical);
2620       return {
2621         str: bidiResult.str,
2622         dir: bidiResult.dir,
2623         width: Math.abs(textChunk.totalWidth),
2624         height: Math.abs(textChunk.totalHeight),
2625         transform: textChunk.transform,
2626         fontName: textChunk.fontName,
2627         hasEOL: textChunk.hasEOL,
2628       };
2629     }
2630 
2631     async function handleSetFont(fontName, fontRef) {
2632       const translated = await self.loadFont(fontName, fontRef, resources);
2633 
2634       if (translated.font.isType3Font) {
2635         try {
2636           await translated.loadType3Data(self, resources, task);
2637         } catch {
2638           // Ignore Type3-parsing errors, since we only use `loadType3Data`
2639           // here to ensure that we'll always obtain a useful /FontBBox.
2640         }
2641       }
2642 
2643       textState.loadedName = translated.loadedName;
2644       textState.font = translated.font;
2645       textState.fontMatrix = translated.font.fontMatrix || FONT_IDENTITY_MATRIX;
2646     }
2647 
2648     function applyInverseRotation(x, y, matrix) {
2649       const scale = Math.hypot(matrix[0], matrix[1]);
2650       return [
2651         (matrix[0] * x + matrix[1] * y) / scale,
2652         (matrix[2] * x + matrix[3] * y) / scale,
2653       ];
2654     }
2655 
2656     function compareWithLastPosition(glyphWidth) {
2657       const currentTransform = getCurrentTextTransform();
2658       let posX = currentTransform[4];
2659       let posY = currentTransform[5];
2660 
2661       // Check if the glyph is in the viewbox.
2662       if (textState.font?.vertical) {
2663         if (
2664           posX < viewBox[0] ||
2665           posX > viewBox[2] ||
2666           posY + glyphWidth < viewBox[1] ||
2667           posY > viewBox[3]
2668         ) {
2669           return false;
2670         }
2671       } else if (
2672         posX + glyphWidth < viewBox[0] ||
2673         posX > viewBox[2] ||
2674         posY < viewBox[1] ||
2675         posY > viewBox[3]
2676       ) {
2677         return false;
2678       }
2679 
2680       if (!textState.font || !textContentItem.prevTransform) {
2681         return true;
2682       }
2683 
2684       let lastPosX = textContentItem.prevTransform[4];
2685       let lastPosY = textContentItem.prevTransform[5];
2686 
2687       if (lastPosX === posX && lastPosY === posY) {
2688         return true;
2689       }
2690 
2691       let rotate = -1;
2692       // Take into account the rotation is the current transform.
2693       if (
2694         currentTransform[0] &&
2695         currentTransform[1] === 0 &&
2696         currentTransform[2] === 0
2697       ) {
2698         rotate = currentTransform[0] > 0 ? 0 : 180;
2699       } else if (
2700         currentTransform[1] &&
2701         currentTransform[0] === 0 &&
2702         currentTransform[3] === 0
2703       ) {
2704         rotate = currentTransform[1] > 0 ? 90 : 270;
2705       }
2706 
2707       switch (rotate) {
2708         case 0:
2709           break;
2710         case 90:
2711           [posX, posY] = [posY, posX];
2712           [lastPosX, lastPosY] = [lastPosY, lastPosX];
2713           break;
2714         case 180:
2715           [posX, posY, lastPosX, lastPosY] = [
2716             -posX,
2717             -posY,
2718             -lastPosX,
2719             -lastPosY,
2720           ];
2721           break;
2722         case 270:
2723           [posX, posY] = [-posY, -posX];
2724           [lastPosX, lastPosY] = [-lastPosY, -lastPosX];
2725           break;
2726         default:
2727           // This is not a 0, 90, 180, 270 rotation so:
2728           //  - remove the scale factor from the matrix to get a rotation matrix
2729           //  - apply the inverse (which is the transposed) to the positions
2730           // and we can then compare positions of the glyphes to detect
2731           // a whitespace.
2732           [posX, posY] = applyInverseRotation(posX, posY, currentTransform);
2733           [lastPosX, lastPosY] = applyInverseRotation(
2734             lastPosX,
2735             lastPosY,
2736             textContentItem.prevTransform
2737           );
2738       }
2739 
2740       if (textState.font.vertical) {
2741         const advanceY = (lastPosY - posY) / textContentItem.textAdvanceScale;
2742         const advanceX = posX - lastPosX;
2743 
2744         // When the total height of the current chunk is negative
2745         // then we're writing from bottom to top.
2746         const textOrientation = Math.sign(textContentItem.height);
2747         if (advanceY < textOrientation * textContentItem.negativeSpaceMax) {
2748           if (
2749             Math.abs(advanceX) >
2750             0.5 * textContentItem.width /* not the same column */
2751           ) {
2752             appendEOL();
2753             return true;
2754           }
2755 
2756           resetLastChars();
2757           flushTextContentItem();
2758           return true;
2759         }
2760 
2761         if (Math.abs(advanceX) > textContentItem.width) {
2762           appendEOL();
2763           return true;
2764         }
2765 
2766         if (advanceY <= textOrientation * textContentItem.notASpace) {
2767           // The real spacing between 2 consecutive chars is thin enough to be
2768           // considered a non-space.
2769           resetLastChars();
2770         }
2771 
2772         if (advanceY <= textOrientation * textContentItem.trackingSpaceMin) {
2773           if (shouldAddWhitepsace()) {
2774             // The space is very thin, hence it deserves to have its own span in
2775             // order to avoid too much shift between the canvas and the text
2776             // layer.
2777             resetLastChars();
2778             flushTextContentItem();
2779             pushWhitespace({ height: Math.abs(advanceY) });
2780           } else {
2781             textContentItem.height += advanceY;
2782           }
2783         } else if (
2784           !addFakeSpaces(
2785             advanceY,
2786             textContentItem.prevTransform,
2787             textOrientation
2788           )
2789         ) {
2790           if (textContentItem.str.length === 0) {
2791             resetLastChars();
2792             pushWhitespace({ height: Math.abs(advanceY) });
2793           } else {
2794             textContentItem.height += advanceY;
2795           }
2796         }
2797 
2798         if (Math.abs(advanceX) > textContentItem.width * VERTICAL_SHIFT_RATIO) {
2799           flushTextContentItem();
2800         }
2801 
2802         return true;
2803       }
2804 
2805       const advanceX = (posX - lastPosX) / textContentItem.textAdvanceScale;
2806       const advanceY = posY - lastPosY;
2807 
2808       // When the total width of the current chunk is negative
2809       // then we're writing from right to left.
2810       const textOrientation = Math.sign(textContentItem.width);
2811       if (advanceX < textOrientation * textContentItem.negativeSpaceMax) {
2812         if (
2813           Math.abs(advanceY) >
2814           0.5 * textContentItem.height /* not the same line */
2815         ) {
2816           appendEOL();
2817           return true;
2818         }
2819 
2820         // We're moving back so in case the last char was a whitespace
2821         // we cancel it: it doesn't make sense to insert it.
2822         resetLastChars();
2823         flushTextContentItem();
2824         return true;
2825       }
2826 
2827       if (Math.abs(advanceY) > textContentItem.height) {
2828         appendEOL();
2829         return true;
2830       }
2831 
2832       if (advanceX <= textOrientation * textContentItem.notASpace) {
2833         // The real spacing between 2 consecutive chars is thin enough to be
2834         // considered a non-space.
2835         resetLastChars();
2836       }
2837 
2838       if (advanceX <= textOrientation * textContentItem.trackingSpaceMin) {
2839         if (shouldAddWhitepsace()) {
2840           // The space is very thin, hence it deserves to have its own span in
2841           // order to avoid too much shift between the canvas and the text
2842           // layer.
2843           resetLastChars();
2844           flushTextContentItem();
2845           pushWhitespace({ width: Math.abs(advanceX) });
2846         } else {
2847           textContentItem.width += advanceX;
2848         }
2849       } else if (
2850         !addFakeSpaces(advanceX, textContentItem.prevTransform, textOrientation)
2851       ) {
2852         if (textContentItem.str.length === 0) {
2853           resetLastChars();
2854           pushWhitespace({ width: Math.abs(advanceX) });
2855         } else {
2856           textContentItem.width += advanceX;
2857         }
2858       }
2859 
2860       if (Math.abs(advanceY) > textContentItem.height * VERTICAL_SHIFT_RATIO) {
2861         flushTextContentItem();
2862       }
2863 
2864       return true;
2865     }
2866 
2867     function buildTextContentItem({ chars, extraSpacing }) {
2868       const font = textState.font;
2869       if (!chars) {
2870         // Just move according to the space we have.
2871         const charSpacing = textState.charSpacing + extraSpacing;
2872         if (charSpacing) {
2873           if (!font.vertical) {
2874             textState.translateTextMatrix(
2875               charSpacing * textState.textHScale,
2876               0
2877             );
2878           } else {
2879             textState.translateTextMatrix(0, -charSpacing);
2880           }
2881         }
2882 
2883         if (keepWhiteSpace) {
2884           compareWithLastPosition(0);
2885         }
2886 
2887         return;
2888       }
2889 
2890       const glyphs = font.charsToGlyphs(chars);
2891       const scale = textState.fontMatrix[0] * textState.fontSize;
2892 
2893       for (let i = 0, ii = glyphs.length; i < ii; i++) {
2894         const glyph = glyphs[i];
2895         const { category } = glyph;
2896 
2897         if (category.isInvisibleFormatMark) {
2898           continue;
2899         }
2900         let charSpacing =
2901           textState.charSpacing + (i + 1 === ii ? extraSpacing : 0);
2902 
2903         let glyphWidth = glyph.width;
2904         if (font.vertical) {
2905           glyphWidth = glyph.vmetric ? glyph.vmetric[0] : -glyphWidth;
2906         }
2907         let scaledDim = glyphWidth * scale;
2908 
2909         if (!keepWhiteSpace && category.isWhitespace) {
2910           // Don't push a " " in the textContentItem
2911           // (except when it's between two non-spaces chars),
2912           // it will be done (if required) in next call to
2913           // compareWithLastPosition.
2914           // This way we can merge real spaces and spaces due to cursor moves.
2915           if (!font.vertical) {
2916             charSpacing += scaledDim + textState.wordSpacing;
2917             textState.translateTextMatrix(
2918               charSpacing * textState.textHScale,
2919               0
2920             );
2921           } else {
2922             charSpacing += -scaledDim + textState.wordSpacing;
2923             textState.translateTextMatrix(0, -charSpacing);
2924           }
2925           saveLastChar(" ");
2926           continue;
2927         }
2928 
2929         if (
2930           !category.isZeroWidthDiacritic &&
2931           !compareWithLastPosition(scaledDim)
2932         ) {
2933           // The glyph is not in page so just skip it but move the cursor.
2934           if (!font.vertical) {
2935             textState.translateTextMatrix(scaledDim * textState.textHScale, 0);
2936           } else {
2937             textState.translateTextMatrix(0, scaledDim);
2938           }
2939           continue;
2940         }
2941 
2942         // Must be called after compareWithLastPosition because
2943         // the textContentItem could have been flushed.
2944         const textChunk = ensureTextContentItem();
2945         if (category.isZeroWidthDiacritic) {
2946           scaledDim = 0;
2947         }
2948 
2949         if (!font.vertical) {
2950           scaledDim *= textState.textHScale;
2951           textState.translateTextMatrix(scaledDim, 0);
2952           textChunk.width += scaledDim;
2953         } else {
2954           textState.translateTextMatrix(0, scaledDim);
2955           scaledDim = Math.abs(scaledDim);
2956           textChunk.height += scaledDim;
2957         }
2958 
2959         if (scaledDim) {
2960           // Save the position of the last visible character.
2961           textChunk.prevTransform = getCurrentTextTransform();
2962         }
2963 
2964         const glyphUnicode = glyph.unicode;
2965         if (saveLastChar(glyphUnicode)) {
2966           // The two last chars are a non-whitespace followed by a whitespace
2967           // and then this non-whitespace, so we insert a whitespace here.
2968           // Replaces all whitespaces with standard spaces (0x20), to avoid
2969           // alignment issues between the textLayer and the canvas if the text
2970           // contains e.g. tabs (fixes issue6612.pdf).
2971           textChunk.str.push(" ");
2972         }
2973         textChunk.str.push(glyphUnicode);
2974 
2975         if (charSpacing) {
2976           if (!font.vertical) {
2977             textState.translateTextMatrix(
2978               charSpacing * textState.textHScale,
2979               0
2980             );
2981           } else {
2982             textState.translateTextMatrix(0, -charSpacing);
2983           }
2984         }
2985       }
2986     }
2987 
2988     function appendEOL() {
2989       resetLastChars();
2990       if (textContentItem.initialized) {
2991         textContentItem.hasEOL = true;
2992         flushTextContentItem();
2993       } else {
2994         textContent.items.push({
2995           str: "",
2996           dir: "ltr",
2997           width: 0,
2998           height: 0,
2999           transform: getCurrentTextTransform(),
3000           fontName: textState.loadedName,
3001           hasEOL: true,
3002         });
3003       }
3004     }
3005 
3006     function addFakeSpaces(width, transf, textOrientation) {
3007       if (
3008         textOrientation * textContentItem.spaceInFlowMin <= width &&
3009         width <= textOrientation * textContentItem.spaceInFlowMax
3010       ) {
3011         if (textContentItem.initialized) {
3012           resetLastChars();
3013           textContentItem.str.push(" ");
3014         }
3015         return false;
3016       }
3017 
3018       const fontName = textContentItem.fontName;
3019 
3020       let height = 0;
3021       if (textContentItem.vertical) {
3022         height = width;
3023         width = 0;
3024       }
3025 
3026       flushTextContentItem();
3027       resetLastChars();
3028       pushWhitespace({
3029         width: Math.abs(width),
3030         height: Math.abs(height),
3031         transform: transf || getCurrentTextTransform(),
3032         fontName,
3033       });
3034 
3035       return true;
3036     }
3037 
3038     function flushTextContentItem() {
3039       if (!textContentItem.initialized || !textContentItem.str) {
3040         return;
3041       }
3042 
3043       // Do final text scaling.
3044       if (!textContentItem.vertical) {
3045         textContentItem.totalWidth +=
3046           textContentItem.width * textContentItem.textAdvanceScale;
3047       } else {
3048         textContentItem.totalHeight +=
3049           textContentItem.height * textContentItem.textAdvanceScale;
3050       }
3051 
3052       textContent.items.push(runBidiTransform(textContentItem));
3053       textContentItem.initialized = false;
3054       textContentItem.str.length = 0;
3055     }
3056 
3057     function enqueueChunk(batch = false) {
3058       const length = textContent.items.length;
3059       if (length === 0) {
3060         return;
3061       }
3062       if (batch && length < TEXT_CHUNK_BATCH_SIZE) {
3063         return;
3064       }
3065       sink.enqueue(textContent, length);
3066       textContent.items = [];
3067       textContent.styles = Object.create(null);
3068     }
3069 
3070     const timeSlotManager = new TimeSlotManager();
3071 
3072     return new Promise(function promiseBody(resolve, reject) {
3073       const next = function (promise) {
3074         enqueueChunk(/* batch = */ true);
3075         Promise.all([promise, sink.ready]).then(function () {
3076           try {
3077             promiseBody(resolve, reject);
3078           } catch (ex) {
3079             reject(ex);
3080           }
3081         }, reject);
3082       };
3083       task.ensureNotTerminated();
3084       timeSlotManager.reset();
3085 
3086       const operation = {};
3087       let stop,
3088         args = [];
3089       while (!(stop = timeSlotManager.check())) {
3090         // The arguments parsed by read() are not used beyond this loop, so
3091         // we can reuse the same array on every iteration, thus avoiding
3092         // unnecessary allocations.
3093         args.length = 0;
3094         operation.args = args;
3095         if (!preprocessor.read(operation)) {
3096           break;
3097         }
3098 
3099         const previousState = textState;
3100         textState = stateManager.state;
3101         const fn = operation.fn;
3102         args = operation.args;
3103 
3104         switch (fn | 0) {
3105           case OPS.setFont:
3106             // Optimization to ignore multiple identical Tf commands.
3107             var fontNameArg = args[0].name,
3108               fontSizeArg = args[1];
3109             if (
3110               textState.font &&
3111               fontNameArg === textState.fontName &&
3112               fontSizeArg === textState.fontSize
3113             ) {
3114               break;
3115             }
3116 
3117             flushTextContentItem();
3118             textState.fontName = fontNameArg;
3119             textState.fontSize = fontSizeArg;
3120             next(handleSetFont(fontNameArg, null));
3121             return;
3122           case OPS.setTextRise:
3123             textState.textRise = args[0];
3124             break;
3125           case OPS.setHScale:
3126             textState.textHScale = args[0] / 100;
3127             break;
3128           case OPS.setLeading:
3129             textState.leading = args[0];
3130             break;
3131           case OPS.moveText:
3132             textState.translateTextLineMatrix(args[0], args[1]);
3133             textState.textMatrix = textState.textLineMatrix.slice();
3134             break;
3135           case OPS.setLeadingMoveText:
3136             textState.leading = -args[1];
3137             textState.translateTextLineMatrix(args[0], args[1]);
3138             textState.textMatrix = textState.textLineMatrix.slice();
3139             break;
3140           case OPS.nextLine:
3141             textState.carriageReturn();
3142             break;
3143           case OPS.setTextMatrix:
3144             textState.setTextMatrix(
3145               args[0],
3146               args[1],
3147               args[2],
3148               args[3],
3149               args[4],
3150               args[5]
3151             );
3152             textState.setTextLineMatrix(
3153               args[0],
3154               args[1],
3155               args[2],
3156               args[3],
3157               args[4],
3158               args[5]
3159             );
3160             updateAdvanceScale();
3161             break;
3162           case OPS.setCharSpacing:
3163             textState.charSpacing = args[0];
3164             break;
3165           case OPS.setWordSpacing:
3166             textState.wordSpacing = args[0];
3167             break;
3168           case OPS.beginText:
3169             textState.textMatrix = IDENTITY_MATRIX.slice();
3170             textState.textLineMatrix = IDENTITY_MATRIX.slice();
3171             break;
3172           case OPS.showSpacedText:
3173             if (!stateManager.state.font) {
3174               self.ensureStateFont(stateManager.state);
3175               continue;
3176             }
3177 
3178             const spaceFactor =
3179               ((textState.font.vertical ? 1 : -1) * textState.fontSize) / 1000;
3180             const elements = args[0];
3181             for (let i = 0, ii = elements.length; i < ii; i++) {
3182               const item = elements[i];
3183               if (typeof item === "string") {
3184                 showSpacedTextBuffer.push(item);
3185               } else if (typeof item === "number" && item !== 0) {
3186                 // PDF Specification 5.3.2 states:
3187                 // The number is expressed in thousandths of a unit of text
3188                 // space.
3189                 // This amount is subtracted from the current horizontal or
3190                 // vertical coordinate, depending on the writing mode.
3191                 // In the default coordinate system, a positive adjustment
3192                 // has the effect of moving the next glyph painted either to
3193                 // the left or down by the given amount.
3194                 const str = showSpacedTextBuffer.join("");
3195                 showSpacedTextBuffer.length = 0;
3196                 buildTextContentItem({
3197                   chars: str,
3198                   extraSpacing: item * spaceFactor,
3199                 });
3200               }
3201             }
3202 
3203             if (showSpacedTextBuffer.length > 0) {
3204               const str = showSpacedTextBuffer.join("");
3205               showSpacedTextBuffer.length = 0;
3206               buildTextContentItem({
3207                 chars: str,
3208                 extraSpacing: 0,
3209               });
3210             }
3211             break;
3212           case OPS.showText:
3213             if (!stateManager.state.font) {
3214               self.ensureStateFont(stateManager.state);
3215               continue;
3216             }
3217             buildTextContentItem({
3218               chars: args[0],
3219               extraSpacing: 0,
3220             });
3221             break;
3222           case OPS.nextLineShowText:
3223             if (!stateManager.state.font) {
3224               self.ensureStateFont(stateManager.state);
3225               continue;
3226             }
3227             textState.carriageReturn();
3228             buildTextContentItem({
3229               chars: args[0],
3230               extraSpacing: 0,
3231             });
3232             break;
3233           case OPS.nextLineSetSpacingShowText:
3234             if (!stateManager.state.font) {
3235               self.ensureStateFont(stateManager.state);
3236               continue;
3237             }
3238             textState.wordSpacing = args[0];
3239             textState.charSpacing = args[1];
3240             textState.carriageReturn();
3241             buildTextContentItem({
3242               chars: args[2],
3243               extraSpacing: 0,
3244             });
3245             break;
3246           case OPS.paintXObject:
3247             flushTextContentItem();
3248             if (!xobjs) {
3249               xobjs = resources.get("XObject") || Dict.empty;
3250             }
3251 
3252             var isValidName = args[0] instanceof Name;
3253             var name = args[0].name;
3254 
3255             if (isValidName && emptyXObjectCache.getByName(name)) {
3256               break;
3257             }
3258 
3259             next(
3260               new Promise(function (resolveXObject, rejectXObject) {
3261                 if (!isValidName) {
3262                   throw new FormatError("XObject must be referred to by name.");
3263                 }
3264 
3265                 let xobj = xobjs.getRaw(name);
3266                 if (xobj instanceof Ref) {
3267                   if (emptyXObjectCache.getByRef(xobj)) {
3268                     resolveXObject();
3269                     return;
3270                   }
3271 
3272                   const globalImage = self.globalImageCache.getData(
3273                     xobj,
3274                     self.pageIndex
3275                   );
3276                   if (globalImage) {
3277                     resolveXObject();
3278                     return;
3279                   }
3280 
3281                   xobj = xref.fetch(xobj);
3282                 }
3283 
3284                 if (!(xobj instanceof BaseStream)) {
3285                   throw new FormatError("XObject should be a stream");
3286                 }
3287 
3288                 const type = xobj.dict.get("Subtype");
3289                 if (!(type instanceof Name)) {
3290                   throw new FormatError("XObject should have a Name subtype");
3291                 }
3292 
3293                 if (type.name !== "Form") {
3294                   emptyXObjectCache.set(name, xobj.dict.objId, true);
3295 
3296                   resolveXObject();
3297                   return;
3298                 }
3299 
3300                 // Use a new `StateManager` to prevent incorrect positioning
3301                 // of textItems *after* the Form XObject, since errors in the
3302                 // data can otherwise prevent `restore` operators from
3303                 // executing.
3304                 // NOTE: Only an issue when `options.ignoreErrors === true`.
3305                 const currentState = stateManager.state.clone();
3306                 const xObjStateManager = new StateManager(currentState);
3307 
3308                 const matrix = lookupMatrix(xobj.dict.getArray("Matrix"), null);
3309                 if (matrix) {
3310                   xObjStateManager.transform(matrix);
3311                 }
3312 
3313                 // Enqueue the `textContent` chunk before parsing the /Form
3314                 // XObject.
3315                 enqueueChunk();
3316                 const sinkWrapper = {
3317                   enqueueInvoked: false,
3318 
3319                   enqueue(chunk, size) {
3320                     this.enqueueInvoked = true;
3321                     sink.enqueue(chunk, size);
3322                   },
3323 
3324                   get desiredSize() {
3325                     return sink.desiredSize;
3326                   },
3327 
3328                   get ready() {
3329                     return sink.ready;
3330                   },
3331                 };
3332 
3333                 self
3334                   .getTextContent({
3335                     stream: xobj,
3336                     task,
3337                     resources: xobj.dict.get("Resources") || resources,
3338                     stateManager: xObjStateManager,
3339                     includeMarkedContent,
3340                     sink: sinkWrapper,
3341                     seenStyles,
3342                     viewBox,
3343                     lang,
3344                     markedContentData,
3345                     disableNormalization,
3346                     keepWhiteSpace,
3347                   })
3348                   .then(function () {
3349                     if (!sinkWrapper.enqueueInvoked) {
3350                       emptyXObjectCache.set(name, xobj.dict.objId, true);
3351                     }
3352                     resolveXObject();
3353                   }, rejectXObject);
3354               }).catch(function (reason) {
3355                 if (reason instanceof AbortException) {
3356                   return;
3357                 }
3358                 if (self.options.ignoreErrors) {
3359                   // Error(s) in the XObject -- allow text-extraction to
3360                   // continue.
3361                   warn(`getTextContent - ignoring XObject: "${reason}".`);
3362                   return;
3363                 }
3364                 throw reason;
3365               })
3366             );
3367             return;
3368           case OPS.setGState:
3369             isValidName = args[0] instanceof Name;
3370             name = args[0].name;
3371 
3372             if (isValidName && emptyGStateCache.getByName(name)) {
3373               break;
3374             }
3375 
3376             next(
3377               new Promise(function (resolveGState, rejectGState) {
3378                 if (!isValidName) {
3379                   throw new FormatError("GState must be referred to by name.");
3380                 }
3381 
3382                 const extGState = resources.get("ExtGState");
3383                 if (!(extGState instanceof Dict)) {
3384                   throw new FormatError("ExtGState should be a dictionary.");
3385                 }
3386 
3387                 const gState = extGState.get(name);
3388                 // TODO: Attempt to lookup cached GStates by reference as well,
3389                 //       if and only if there are PDF documents where doing so
3390                 //       would significantly improve performance.
3391                 if (!(gState instanceof Dict)) {
3392                   throw new FormatError("GState should be a dictionary.");
3393                 }
3394 
3395                 const gStateFont = gState.get("Font");
3396                 if (!gStateFont) {
3397                   emptyGStateCache.set(name, gState.objId, true);
3398 
3399                   resolveGState();
3400                   return;
3401                 }
3402                 flushTextContentItem();
3403 
3404                 textState.fontName = null;
3405                 textState.fontSize = gStateFont[1];
3406                 handleSetFont(null, gStateFont[0]).then(
3407                   resolveGState,
3408                   rejectGState
3409                 );
3410               }).catch(function (reason) {
3411                 if (reason instanceof AbortException) {
3412                   return;
3413                 }
3414                 if (self.options.ignoreErrors) {
3415                   // Error(s) in the ExtGState -- allow text-extraction to
3416                   // continue.
3417                   warn(`getTextContent - ignoring ExtGState: "${reason}".`);
3418                   return;
3419                 }
3420                 throw reason;
3421               })
3422             );
3423             return;
3424           case OPS.beginMarkedContent:
3425             flushTextContentItem();
3426             if (includeMarkedContent) {
3427               markedContentData.level++;
3428 
3429               textContent.items.push({
3430                 type: "beginMarkedContent",
3431                 tag: args[0] instanceof Name ? args[0].name : null,
3432               });
3433             }
3434             break;
3435           case OPS.beginMarkedContentProps:
3436             flushTextContentItem();
3437             if (includeMarkedContent) {
3438               markedContentData.level++;
3439 
3440               let mcid = null;
3441               if (args[1] instanceof Dict) {
3442                 mcid = args[1].get("MCID");
3443               }
3444               textContent.items.push({
3445                 type: "beginMarkedContentProps",
3446                 id: Number.isInteger(mcid)
3447                   ? `${self.idFactory.getPageObjId()}_mc${mcid}`
3448                   : null,
3449                 tag: args[0] instanceof Name ? args[0].name : null,
3450               });
3451             }
3452             break;
3453           case OPS.endMarkedContent:
3454             flushTextContentItem();
3455             if (includeMarkedContent) {
3456               if (markedContentData.level === 0) {
3457                 // Handle unbalanced beginMarkedContent/endMarkedContent
3458                 // operators (fixes issue15629.pdf).
3459                 break;
3460               }
3461               markedContentData.level--;
3462 
3463               textContent.items.push({
3464                 type: "endMarkedContent",
3465               });
3466             }
3467             break;
3468           case OPS.restore:
3469             if (
3470               previousState &&
3471               (previousState.font !== textState.font ||
3472                 previousState.fontSize !== textState.fontSize ||
3473                 previousState.fontName !== textState.fontName)
3474             ) {
3475               flushTextContentItem();
3476             }
3477             break;
3478         } // switch
3479         if (textContent.items.length >= sink.desiredSize) {
3480           // Wait for ready, if we reach highWaterMark.
3481           stop = true;
3482           break;
3483         }
3484       } // while
3485       if (stop) {
3486         next(deferred);
3487         return;
3488       }
3489       flushTextContentItem();
3490       enqueueChunk();
3491       resolve();
3492     }).catch(reason => {
3493       if (reason instanceof AbortException) {
3494         return;
3495       }
3496       if (this.options.ignoreErrors) {
3497         // Error(s) in the TextContent -- allow text-extraction to continue.
3498         warn(
3499           `getTextContent - ignoring errors during "${task.name}" ` +
3500             `task: "${reason}".`
3501         );
3502 
3503         flushTextContentItem();
3504         enqueueChunk();
3505         return;
3506       }
3507       throw reason;
3508     });
3509   }
3510 
3511   async extractDataStructures(dict, properties) {
3512     const xref = this.xref;
3513     let cidToGidBytes;
3514     // 9.10.2
3515     const toUnicodePromise = this.readToUnicode(properties.toUnicode);
3516 
3517     if (properties.composite) {
3518       // CIDSystemInfo helps to match CID to glyphs
3519       const cidSystemInfo = dict.get("CIDSystemInfo");
3520       if (cidSystemInfo instanceof Dict) {
3521         properties.cidSystemInfo = {
3522           registry: stringToPDFString(cidSystemInfo.get("Registry")),
3523           ordering: stringToPDFString(cidSystemInfo.get("Ordering")),
3524           supplement: cidSystemInfo.get("Supplement"),
3525         };
3526       }
3527 
3528       try {
3529         const cidToGidMap = dict.get("CIDToGIDMap");
3530         if (cidToGidMap instanceof BaseStream) {
3531           cidToGidBytes = cidToGidMap.getBytes();
3532         }
3533       } catch (ex) {
3534         if (!this.options.ignoreErrors) {
3535           throw ex;
3536         }
3537         warn(`extractDataStructures - ignoring CIDToGIDMap data: "${ex}".`);
3538       }
3539     }
3540 
3541     // Based on 9.6.6 of the spec the encoding can come from multiple places
3542     // and depends on the font type. The base encoding and differences are
3543     // read here, but the encoding that is actually used is chosen during
3544     // glyph mapping in the font.
3545     // TODO: Loading the built in encoding in the font would allow the
3546     // differences to be merged in here not require us to hold on to it.
3547     const differences = [];
3548     let baseEncodingName = null;
3549     let encoding;
3550     if (dict.has("Encoding")) {
3551       encoding = dict.get("Encoding");
3552       if (encoding instanceof Dict) {
3553         baseEncodingName = encoding.get("BaseEncoding");
3554         baseEncodingName =
3555           baseEncodingName instanceof Name ? baseEncodingName.name : null;
3556         // Load the differences between the base and original
3557         if (encoding.has("Differences")) {
3558           const diffEncoding = encoding.get("Differences");
3559           let index = 0;
3560           for (const entry of diffEncoding) {
3561             const data = xref.fetchIfRef(entry);
3562             if (typeof data === "number") {
3563               index = data;
3564             } else if (data instanceof Name) {
3565               differences[index++] = data.name;
3566             } else {
3567               throw new FormatError(
3568                 `Invalid entry in 'Differences' array: ${data}`
3569               );
3570             }
3571           }
3572         }
3573       } else if (encoding instanceof Name) {
3574         baseEncodingName = encoding.name;
3575       } else {
3576         const msg = "Encoding is not a Name nor a Dict";
3577 
3578         if (!this.options.ignoreErrors) {
3579           throw new FormatError(msg);
3580         }
3581         warn(msg);
3582       }
3583       // According to table 114 if the encoding is a named encoding it must be
3584       // one of these predefined encodings.
3585       if (
3586         baseEncodingName !== "MacRomanEncoding" &&
3587         baseEncodingName !== "MacExpertEncoding" &&
3588         baseEncodingName !== "WinAnsiEncoding"
3589       ) {
3590         baseEncodingName = null;
3591       }
3592     }
3593 
3594     const nonEmbeddedFont = !properties.file || properties.isInternalFont,
3595       isSymbolsFontName = getSymbolsFonts()[properties.name];
3596     // Ignore an incorrectly specified named encoding for non-embedded
3597     // symbol fonts (fixes issue16464.pdf).
3598     if (baseEncodingName && nonEmbeddedFont && isSymbolsFontName) {
3599       baseEncodingName = null;
3600     }
3601 
3602     if (baseEncodingName) {
3603       properties.defaultEncoding = getEncoding(baseEncodingName);
3604     } else {
3605       const isSymbolicFont = !!(properties.flags & FontFlags.Symbolic);
3606       const isNonsymbolicFont = !!(properties.flags & FontFlags.Nonsymbolic);
3607       // According to "Table 114" in section "9.6.6.1 General" (under
3608       // "9.6.6 Character Encoding") of the PDF specification, a Nonsymbolic
3609       // font should use the `StandardEncoding` if no encoding is specified.
3610       encoding = StandardEncoding;
3611       if (properties.type === "TrueType" && !isNonsymbolicFont) {
3612         encoding = WinAnsiEncoding;
3613       }
3614       // The Symbolic attribute can be misused for regular fonts
3615       // Heuristic: we have to check if the font is a standard one also
3616       if (isSymbolicFont || isSymbolsFontName) {
3617         encoding = MacRomanEncoding;
3618         if (nonEmbeddedFont) {
3619           if (/Symbol/i.test(properties.name)) {
3620             encoding = SymbolSetEncoding;
3621           } else if (/Dingbats/i.test(properties.name)) {
3622             encoding = ZapfDingbatsEncoding;
3623           } else if (/Wingdings/i.test(properties.name)) {
3624             encoding = WinAnsiEncoding;
3625           }
3626         }
3627       }
3628       properties.defaultEncoding = encoding;
3629     }
3630 
3631     properties.differences = differences;
3632     properties.baseEncodingName = baseEncodingName;
3633     properties.hasEncoding = !!baseEncodingName || differences.length > 0;
3634     properties.dict = dict;
3635 
3636     properties.toUnicode = await toUnicodePromise;
3637 
3638     const builtToUnicode = await this.buildToUnicode(properties);
3639     properties.toUnicode = builtToUnicode;
3640 
3641     if (cidToGidBytes) {
3642       properties.cidToGidMap = this.readCidToGidMap(
3643         cidToGidBytes,
3644         builtToUnicode
3645       );
3646     }
3647     return properties;
3648   }
3649 
3650   /**
3651    * @returns {Array}
3652    * @private
3653    */
3654   _simpleFontToUnicode(properties, forceGlyphs = false) {
3655     assert(!properties.composite, "Must be a simple font.");
3656 
3657     const toUnicode = [];
3658     const encoding = properties.defaultEncoding.slice();
3659     const baseEncodingName = properties.baseEncodingName;
3660     // Merge in the differences array.
3661     const differences = properties.differences;
3662     for (const charcode in differences) {
3663       const glyphName = differences[charcode];
3664       if (glyphName === ".notdef") {
3665         // Skip .notdef to prevent rendering errors, e.g. boxes appearing
3666         // where there should be spaces (fixes issue5256.pdf).
3667         continue;
3668       }
3669       encoding[charcode] = glyphName;
3670     }
3671     const glyphsUnicodeMap = getGlyphsUnicode();
3672     for (const charcode in encoding) {
3673       // a) Map the character code to a character name.
3674       let glyphName = encoding[charcode];
3675       if (glyphName === "") {
3676         continue;
3677       }
3678       // b) Look up the character name in the Adobe Glyph List (see the
3679       //    Bibliography) to obtain the corresponding Unicode value.
3680       let unicode = glyphsUnicodeMap[glyphName];
3681       if (unicode !== undefined) {
3682         toUnicode[charcode] = String.fromCharCode(unicode);
3683         continue;
3684       }
3685       // (undocumented) c) Few heuristics to recognize unknown glyphs
3686       // NOTE: Adobe Reader does not do this step, but OSX Preview does
3687       let code = 0;
3688       switch (glyphName[0]) {
3689         case "G": // Gxx glyph
3690           if (glyphName.length === 3) {
3691             code = parseInt(glyphName.substring(1), 16);
3692           }
3693           break;
3694         case "g": // g00xx glyph
3695           if (glyphName.length === 5) {
3696             code = parseInt(glyphName.substring(1), 16);
3697           }
3698           break;
3699         case "C": // Cdd{d} glyph
3700         case "c": // cdd{d} glyph
3701           if (glyphName.length >= 3 && glyphName.length <= 4) {
3702             const codeStr = glyphName.substring(1);
3703 
3704             if (forceGlyphs) {
3705               code = parseInt(codeStr, 16);
3706               break;
3707             }
3708             // Normally the Cdd{d}/cdd{d} glyphName format will contain
3709             // regular, i.e. base 10, charCodes (see issue4550.pdf)...
3710             code = +codeStr;
3711 
3712             // ... however some PDF generators violate that assumption by
3713             // containing glyph, i.e. base 16, codes instead.
3714             // In that case we need to re-parse the *entire* encoding to
3715             // prevent broken text-selection (fixes issue9655_reduced.pdf).
3716             if (Number.isNaN(code) && Number.isInteger(parseInt(codeStr, 16))) {
3717               return this._simpleFontToUnicode(
3718                 properties,
3719                 /* forceGlyphs */ true
3720               );
3721             }
3722           }
3723           break;
3724         case "u": // 'uniXXXX'/'uXXXX{XX}' glyphs
3725           unicode = getUnicodeForGlyph(glyphName, glyphsUnicodeMap);
3726           if (unicode !== -1) {
3727             code = unicode;
3728           }
3729           break;
3730         default:
3731           // Support (some) non-standard ligatures.
3732           switch (glyphName) {
3733             case "f_h":
3734             case "f_t":
3735             case "T_h":
3736               toUnicode[charcode] = glyphName.replaceAll("_", "");
3737               continue;
3738           }
3739           break;
3740       }
3741       if (code > 0 && code <= 0x10ffff && Number.isInteger(code)) {
3742         // If `baseEncodingName` is one the predefined encodings, and `code`
3743         // equals `charcode`, using the glyph defined in the baseEncoding
3744         // seems to yield a better `toUnicode` mapping (fixes issue 5070).
3745         if (baseEncodingName && code === +charcode) {
3746           const baseEncoding = getEncoding(baseEncodingName);
3747           if (baseEncoding && (glyphName = baseEncoding[charcode])) {
3748             toUnicode[charcode] = String.fromCharCode(
3749               glyphsUnicodeMap[glyphName]
3750             );
3751             continue;
3752           }
3753         }
3754         toUnicode[charcode] = String.fromCodePoint(code);
3755       }
3756     }
3757     return toUnicode;
3758   }
3759 
3760   /**
3761    * Builds a char code to unicode map based on section 9.10 of the spec.
3762    * @param {Object} properties Font properties object.
3763    * @returns {Promise} A Promise that is resolved with a
3764    *   {ToUnicodeMap|IdentityToUnicodeMap} object.
3765    */
3766   async buildToUnicode(properties) {
3767     properties.hasIncludedToUnicodeMap = properties.toUnicode?.length > 0;
3768 
3769     // Section 9.10.2 Mapping Character Codes to Unicode Values
3770     if (properties.hasIncludedToUnicodeMap) {
3771       // Some fonts contain incomplete ToUnicode data, causing issues with
3772       // text-extraction. For simple fonts, containing encoding information,
3773       // use a fallback ToUnicode map to improve this (fixes issue8229.pdf).
3774       if (!properties.composite && properties.hasEncoding) {
3775         properties.fallbackToUnicode = this._simpleFontToUnicode(properties);
3776       }
3777       return properties.toUnicode;
3778     }
3779 
3780     // According to the spec if the font is a simple font we should only map
3781     // to unicode if the base encoding is MacRoman, MacExpert, or WinAnsi or
3782     // the differences array only contains adobe standard or symbol set names,
3783     // in pratice it seems better to always try to create a toUnicode map
3784     // based of the default encoding.
3785     if (!properties.composite /* is simple font */) {
3786       return new ToUnicodeMap(this._simpleFontToUnicode(properties));
3787     }
3788 
3789     // If the font is a composite font that uses one of the predefined CMaps
3790     // listed in Table 118 (except Identity–H and Identity–V) or whose
3791     // descendant CIDFont uses the Adobe-GB1, Adobe-CNS1, Adobe-Japan1, or
3792     // Adobe-Korea1 character collection:
3793     if (
3794       properties.composite &&
3795       ((properties.cMap.builtInCMap &&
3796         !(properties.cMap instanceof IdentityCMap)) ||
3797         // The font is supposed to have a CIDSystemInfo dictionary, but some
3798         // PDFs don't include it (fixes issue 17689), hence the `?'.
3799         (properties.cidSystemInfo?.registry === "Adobe" &&
3800           (properties.cidSystemInfo.ordering === "GB1" ||
3801             properties.cidSystemInfo.ordering === "CNS1" ||
3802             properties.cidSystemInfo.ordering === "Japan1" ||
3803             properties.cidSystemInfo.ordering === "Korea1")))
3804     ) {
3805       // Then:
3806       // a) Map the character code to a character identifier (CID) according
3807       // to the font’s CMap.
3808       // b) Obtain the registry and ordering of the character collection used
3809       // by the font’s CMap (for example, Adobe and Japan1) from its
3810       // CIDSystemInfo dictionary.
3811       const { registry, ordering } = properties.cidSystemInfo;
3812       // c) Construct a second CMap name by concatenating the registry and
3813       // ordering obtained in step (b) in the format registry–ordering–UCS2
3814       // (for example, Adobe–Japan1–UCS2).
3815       const ucs2CMapName = Name.get(`${registry}-${ordering}-UCS2`);
3816       // d) Obtain the CMap with the name constructed in step (c) (available
3817       // from the ASN Web site; see the Bibliography).
3818       const ucs2CMap = await CMapFactory.create({
3819         encoding: ucs2CMapName,
3820         fetchBuiltInCMap: this._fetchBuiltInCMapBound,
3821         useCMap: null,
3822       });
3823       const toUnicode = [],
3824         buf = [];
3825       properties.cMap.forEach(function (charcode, cid) {
3826         if (cid > 0xffff) {
3827           throw new FormatError("Max size of CID is 65,535");
3828         }
3829         // e) Map the CID obtained in step (a) according to the CMap
3830         // obtained in step (d), producing a Unicode value.
3831         const ucs2 = ucs2CMap.lookup(cid);
3832         if (ucs2) {
3833           buf.length = 0;
3834           // Support multi-byte entries (fixes issue16176.pdf).
3835           for (let i = 0, ii = ucs2.length; i < ii; i += 2) {
3836             buf.push((ucs2.charCodeAt(i) << 8) + ucs2.charCodeAt(i + 1));
3837           }
3838           toUnicode[charcode] = String.fromCharCode(...buf);
3839         }
3840       });
3841       return new ToUnicodeMap(toUnicode);
3842     }
3843 
3844     // The viewer's choice, just use an identity map.
3845     return new IdentityToUnicodeMap(properties.firstChar, properties.lastChar);
3846   }
3847 
3848   async readToUnicode(cmapObj) {
3849     if (!cmapObj) {
3850       return null;
3851     }
3852     if (cmapObj instanceof Name) {
3853       const cmap = await CMapFactory.create({
3854         encoding: cmapObj,
3855         fetchBuiltInCMap: this._fetchBuiltInCMapBound,
3856         useCMap: null,
3857       });
3858 
3859       if (cmap instanceof IdentityCMap) {
3860         return new IdentityToUnicodeMap(0, 0xffff);
3861       }
3862       return new ToUnicodeMap(cmap.getMap());
3863     }
3864     if (cmapObj instanceof BaseStream) {
3865       try {
3866         const cmap = await CMapFactory.create({
3867           encoding: cmapObj,
3868           fetchBuiltInCMap: this._fetchBuiltInCMapBound,
3869           useCMap: null,
3870         });
3871 
3872         if (cmap instanceof IdentityCMap) {
3873           return new IdentityToUnicodeMap(0, 0xffff);
3874         }
3875         const map = new Array(cmap.length);
3876         // Convert UTF-16BE
3877         // NOTE: cmap can be a sparse array, so use forEach instead of
3878         // `for(;;)` to iterate over all keys.
3879         cmap.forEach(function (charCode, token) {
3880           // Some cmaps contain *only* CID characters (fixes issue9367.pdf).
3881           if (typeof token === "number") {
3882             map[charCode] = String.fromCodePoint(token);
3883             return;
3884           }
3885           // Add back omitted leading zeros on odd length tokens
3886           // (fixes issue #18099)
3887           if (token.length % 2 !== 0) {
3888             token = "\u0000" + token;
3889           }
3890           const str = [];
3891           for (let k = 0; k < token.length; k += 2) {
3892             const w1 = (token.charCodeAt(k) << 8) | token.charCodeAt(k + 1);
3893             if ((w1 & 0xf800) !== 0xd800) {
3894               // w1 < 0xD800 || w1 > 0xDFFF
3895               str.push(w1);
3896               continue;
3897             }
3898             k += 2;
3899             const w2 = (token.charCodeAt(k) << 8) | token.charCodeAt(k + 1);
3900             str.push(((w1 & 0x3ff) << 10) + (w2 & 0x3ff) + 0x10000);
3901           }
3902           map[charCode] = String.fromCodePoint(...str);
3903         });
3904         return new ToUnicodeMap(map);
3905       } catch (reason) {
3906         if (reason instanceof AbortException) {
3907           return null;
3908         }
3909         if (this.options.ignoreErrors) {
3910           warn(`readToUnicode - ignoring ToUnicode data: "${reason}".`);
3911           return null;
3912         }
3913         throw reason;
3914       }
3915     }
3916     return null;
3917   }
3918 
3919   readCidToGidMap(glyphsData, toUnicode) {
3920     // Extract the encoding from the CIDToGIDMap
3921 
3922     // Set encoding 0 to later verify the font has an encoding
3923     const result = [];
3924     for (let j = 0, jj = glyphsData.length; j < jj; j++) {
3925       const glyphID = (glyphsData[j++] << 8) | glyphsData[j];
3926       const code = j >> 1;
3927       if (glyphID === 0 && !toUnicode.has(code)) {
3928         continue;
3929       }
3930       result[code] = glyphID;
3931     }
3932     return result;
3933   }
3934 
3935   extractWidths(dict, descriptor, properties) {
3936     const xref = this.xref;
3937     let glyphsWidths = [];
3938     let defaultWidth = 0;
3939     const glyphsVMetrics = [];
3940     let defaultVMetrics;
3941     if (properties.composite) {
3942       const dw = dict.get("DW");
3943       defaultWidth = typeof dw === "number" ? Math.ceil(dw) : 1000;
3944 
3945       const widths = dict.get("W");
3946       if (Array.isArray(widths)) {
3947         for (let i = 0, ii = widths.length; i < ii; i++) {
3948           let start = xref.fetchIfRef(widths[i++]);
3949           if (!Number.isInteger(start)) {
3950             break; // Invalid /W data.
3951           }
3952           const code = xref.fetchIfRef(widths[i]);
3953 
3954           if (Array.isArray(code)) {
3955             for (const c of code) {
3956               const width = xref.fetchIfRef(c);
3957               if (typeof width === "number") {
3958                 glyphsWidths[start] = width;
3959               }
3960               start++;
3961             }
3962           } else if (Number.isInteger(code)) {
3963             const width = xref.fetchIfRef(widths[++i]);
3964             if (typeof width !== "number") {
3965               continue;
3966             }
3967             for (let j = start; j <= code; j++) {
3968               glyphsWidths[j] = width;
3969             }
3970           } else {
3971             break; // Invalid /W data.
3972           }
3973         }
3974       }
3975 
3976       if (properties.vertical) {
3977         const dw2 = dict.getArray("DW2");
3978         let vmetrics = isNumberArray(dw2, 2) ? dw2 : [880, -1000];
3979         defaultVMetrics = [vmetrics[1], defaultWidth * 0.5, vmetrics[0]];
3980         vmetrics = dict.get("W2");
3981         if (Array.isArray(vmetrics)) {
3982           for (let i = 0, ii = vmetrics.length; i < ii; i++) {
3983             let start = xref.fetchIfRef(vmetrics[i++]);
3984             if (!Number.isInteger(start)) {
3985               break; // Invalid /W2 data.
3986             }
3987             const code = xref.fetchIfRef(vmetrics[i]);
3988 
3989             if (Array.isArray(code)) {
3990               for (let j = 0, jj = code.length; j < jj; j++) {
3991                 const vmetric = [
3992                   xref.fetchIfRef(code[j++]),
3993                   xref.fetchIfRef(code[j++]),
3994                   xref.fetchIfRef(code[j]),
3995                 ];
3996                 if (isNumberArray(vmetric, null)) {
3997                   glyphsVMetrics[start] = vmetric;
3998                 }
3999                 start++;
4000               }
4001             } else if (Number.isInteger(code)) {
4002               const vmetric = [
4003                 xref.fetchIfRef(vmetrics[++i]),
4004                 xref.fetchIfRef(vmetrics[++i]),
4005                 xref.fetchIfRef(vmetrics[++i]),
4006               ];
4007               if (!isNumberArray(vmetric, null)) {
4008                 continue;
4009               }
4010               for (let j = start; j <= code; j++) {
4011                 glyphsVMetrics[j] = vmetric;
4012               }
4013             } else {
4014               break; // Invalid /W2 data.
4015             }
4016           }
4017         }
4018       }
4019     } else {
4020       const widths = dict.get("Widths");
4021       if (Array.isArray(widths)) {
4022         let j = properties.firstChar;
4023         for (const w of widths) {
4024           const width = xref.fetchIfRef(w);
4025           if (typeof width === "number") {
4026             glyphsWidths[j] = width;
4027           }
4028           j++;
4029         }
4030         const missingWidth = descriptor.get("MissingWidth");
4031         defaultWidth = typeof missingWidth === "number" ? missingWidth : 0;
4032       } else {
4033         // Trying get the BaseFont metrics (see comment above).
4034         const baseFontName = dict.get("BaseFont");
4035         if (baseFontName instanceof Name) {
4036           const metrics = this.getBaseFontMetrics(baseFontName.name);
4037 
4038           glyphsWidths = this.buildCharCodeToWidth(metrics.widths, properties);
4039           defaultWidth = metrics.defaultWidth;
4040         }
4041       }
4042     }
4043 
4044     // Heuristic: detection of monospace font by checking all non-zero widths
4045     let isMonospace = true;
4046     let firstWidth = defaultWidth;
4047     for (const glyph in glyphsWidths) {
4048       const glyphWidth = glyphsWidths[glyph];
4049       if (!glyphWidth) {
4050         continue;
4051       }
4052       if (!firstWidth) {
4053         firstWidth = glyphWidth;
4054         continue;
4055       }
4056       if (firstWidth !== glyphWidth) {
4057         isMonospace = false;
4058         break;
4059       }
4060     }
4061     if (isMonospace) {
4062       properties.flags |= FontFlags.FixedPitch;
4063     } else {
4064       // Clear the flag.
4065       properties.flags &= ~FontFlags.FixedPitch;
4066     }
4067 
4068     properties.defaultWidth = defaultWidth;
4069     properties.widths = glyphsWidths;
4070     properties.defaultVMetrics = defaultVMetrics;
4071     properties.vmetrics = glyphsVMetrics;
4072   }
4073 
4074   isSerifFont(baseFontName) {
4075     // Simulating descriptor flags attribute
4076     const fontNameWoStyle = baseFontName.split("-", 1)[0];
4077     return (
4078       fontNameWoStyle in getSerifFonts() || /serif/gi.test(fontNameWoStyle)
4079     );
4080   }
4081 
4082   getBaseFontMetrics(name) {
4083     let defaultWidth = 0;
4084     let widths = Object.create(null);
4085     let monospace = false;
4086     const stdFontMap = getStdFontMap();
4087     let lookupName = stdFontMap[name] || name;
4088     const Metrics = getMetrics();
4089 
4090     if (!(lookupName in Metrics)) {
4091       // Use default fonts for looking up font metrics if the passed
4092       // font is not a base font
4093       lookupName = this.isSerifFont(name) ? "Times-Roman" : "Helvetica";
4094     }
4095     const glyphWidths = Metrics[lookupName];
4096 
4097     if (typeof glyphWidths === "number") {
4098       defaultWidth = glyphWidths;
4099       monospace = true;
4100     } else {
4101       widths = glyphWidths(); // expand lazy widths array
4102     }
4103 
4104     return {
4105       defaultWidth,
4106       monospace,
4107       widths,
4108     };
4109   }
4110 
4111   buildCharCodeToWidth(widthsByGlyphName, properties) {
4112     const widths = Object.create(null);
4113     const differences = properties.differences;
4114     const encoding = properties.defaultEncoding;
4115     for (let charCode = 0; charCode < 256; charCode++) {
4116       if (charCode in differences && widthsByGlyphName[differences[charCode]]) {
4117         widths[charCode] = widthsByGlyphName[differences[charCode]];
4118         continue;
4119       }
4120       if (charCode in encoding && widthsByGlyphName[encoding[charCode]]) {
4121         widths[charCode] = widthsByGlyphName[encoding[charCode]];
4122         continue;
4123       }
4124     }
4125     return widths;
4126   }
4127 
4128   preEvaluateFont(dict) {
4129     const baseDict = dict;
4130     let type = dict.get("Subtype");
4131     if (!(type instanceof Name)) {
4132       throw new FormatError("invalid font Subtype");
4133     }
4134 
4135     let composite = false;
4136     let hash;
4137     if (type.name === "Type0") {
4138       // If font is a composite
4139       //  - get the descendant font
4140       //  - set the type according to the descendant font
4141       //  - get the FontDescriptor from the descendant font
4142       const df = dict.get("DescendantFonts");
4143       if (!df) {
4144         throw new FormatError("Descendant fonts are not specified");
4145       }
4146       dict = Array.isArray(df) ? this.xref.fetchIfRef(df[0]) : df;
4147 
4148       if (!(dict instanceof Dict)) {
4149         throw new FormatError("Descendant font is not a dictionary.");
4150       }
4151       type = dict.get("Subtype");
4152       if (!(type instanceof Name)) {
4153         throw new FormatError("invalid font Subtype");
4154       }
4155       composite = true;
4156     }
4157 
4158     let firstChar = dict.get("FirstChar");
4159     if (!Number.isInteger(firstChar)) {
4160       firstChar = 0;
4161     }
4162     let lastChar = dict.get("LastChar");
4163     if (!Number.isInteger(lastChar)) {
4164       lastChar = composite ? 0xffff : 0xff;
4165     }
4166     const descriptor = dict.get("FontDescriptor");
4167     const toUnicode = dict.get("ToUnicode") || baseDict.get("ToUnicode");
4168 
4169     if (descriptor) {
4170       hash = new MurmurHash3_64();
4171 
4172       const encoding = baseDict.getRaw("Encoding");
4173       if (encoding instanceof Name) {
4174         hash.update(encoding.name);
4175       } else if (encoding instanceof Ref) {
4176         hash.update(encoding.toString());
4177       } else if (encoding instanceof Dict) {
4178         for (const entry of encoding.getRawValues()) {
4179           if (entry instanceof Name) {
4180             hash.update(entry.name);
4181           } else if (entry instanceof Ref) {
4182             hash.update(entry.toString());
4183           } else if (Array.isArray(entry)) {
4184             // 'Differences' array (fixes bug1157493.pdf).
4185             const diffLength = entry.length,
4186               diffBuf = new Array(diffLength);
4187 
4188             for (let j = 0; j < diffLength; j++) {
4189               const diffEntry = entry[j];
4190               if (diffEntry instanceof Name) {
4191                 diffBuf[j] = diffEntry.name;
4192               } else if (
4193                 typeof diffEntry === "number" ||
4194                 diffEntry instanceof Ref
4195               ) {
4196                 diffBuf[j] = diffEntry.toString();
4197               }
4198             }
4199             hash.update(diffBuf.join());
4200           }
4201         }
4202       }
4203 
4204       hash.update(`${firstChar}-${lastChar}`); // Fixes issue10665_reduced.pdf
4205 
4206       if (toUnicode instanceof BaseStream) {
4207         const stream = toUnicode.str || toUnicode;
4208         const uint8array = stream.buffer
4209           ? new Uint8Array(stream.buffer.buffer, 0, stream.bufferLength)
4210           : new Uint8Array(
4211               stream.bytes.buffer,
4212               stream.start,
4213               stream.end - stream.start
4214             );
4215         hash.update(uint8array);
4216       } else if (toUnicode instanceof Name) {
4217         hash.update(toUnicode.name);
4218       }
4219 
4220       const widths = dict.get("Widths") || baseDict.get("Widths");
4221       if (Array.isArray(widths)) {
4222         const widthsBuf = [];
4223         for (const entry of widths) {
4224           if (typeof entry === "number" || entry instanceof Ref) {
4225             widthsBuf.push(entry.toString());
4226           }
4227         }
4228         hash.update(widthsBuf.join());
4229       }
4230 
4231       if (composite) {
4232         hash.update("compositeFont");
4233 
4234         const compositeWidths = dict.get("W") || baseDict.get("W");
4235         if (Array.isArray(compositeWidths)) {
4236           const widthsBuf = [];
4237           for (const entry of compositeWidths) {
4238             if (typeof entry === "number" || entry instanceof Ref) {
4239               widthsBuf.push(entry.toString());
4240             } else if (Array.isArray(entry)) {
4241               const subWidthsBuf = [];
4242               for (const element of entry) {
4243                 if (typeof element === "number" || element instanceof Ref) {
4244                   subWidthsBuf.push(element.toString());
4245                 }
4246               }
4247               widthsBuf.push(`[${subWidthsBuf.join()}]`);
4248             }
4249           }
4250           hash.update(widthsBuf.join());
4251         }
4252 
4253         const cidToGidMap =
4254           dict.getRaw("CIDToGIDMap") || baseDict.getRaw("CIDToGIDMap");
4255         if (cidToGidMap instanceof Name) {
4256           hash.update(cidToGidMap.name);
4257         } else if (cidToGidMap instanceof Ref) {
4258           hash.update(cidToGidMap.toString());
4259         } else if (cidToGidMap instanceof BaseStream) {
4260           hash.update(cidToGidMap.peekBytes());
4261         }
4262       }
4263     }
4264 
4265     return {
4266       descriptor,
4267       dict,
4268       baseDict,
4269       composite,
4270       type: type.name,
4271       firstChar,
4272       lastChar,
4273       toUnicode,
4274       hash: hash ? hash.hexdigest() : "",
4275     };
4276   }
4277 
4278   async translateFont({
4279     descriptor,
4280     dict,
4281     baseDict,
4282     composite,
4283     type,
4284     firstChar,
4285     lastChar,
4286     toUnicode,
4287     cssFontInfo,
4288   }) {
4289     const isType3Font = type === "Type3";
4290 
4291     if (!descriptor) {
4292       if (isType3Font) {
4293         const bbox = lookupNormalRect(dict.getArray("FontBBox"), [0, 0, 0, 0]);
4294         // FontDescriptor is only required for Type3 fonts when the document
4295         // is a tagged pdf. Create a barbebones one to get by.
4296         descriptor = new Dict(null);
4297         descriptor.set("FontName", Name.get(type));
4298         descriptor.set("FontBBox", bbox);
4299       } else {
4300         // Before PDF 1.5 if the font was one of the base 14 fonts, having a
4301         // FontDescriptor was not required.
4302         // This case is here for compatibility.
4303         let baseFontName = dict.get("BaseFont");
4304         if (!(baseFontName instanceof Name)) {
4305           throw new FormatError("Base font is not specified");
4306         }
4307 
4308         // Using base font name as a font name.
4309         baseFontName = baseFontName.name.replaceAll(/[,_]/g, "-");
4310         const metrics = this.getBaseFontMetrics(baseFontName);
4311 
4312         // Simulating descriptor flags attribute
4313         const fontNameWoStyle = baseFontName.split("-", 1)[0];
4314         const flags =
4315           (this.isSerifFont(fontNameWoStyle) ? FontFlags.Serif : 0) |
4316           (metrics.monospace ? FontFlags.FixedPitch : 0) |
4317           (getSymbolsFonts()[fontNameWoStyle]
4318             ? FontFlags.Symbolic
4319             : FontFlags.Nonsymbolic);
4320 
4321         const properties = {
4322           type,
4323           name: baseFontName,
4324           loadedName: baseDict.loadedName,
4325           systemFontInfo: null,
4326           widths: metrics.widths,
4327           defaultWidth: metrics.defaultWidth,
4328           isSimulatedFlags: true,
4329           flags,
4330           firstChar,
4331           lastChar,
4332           toUnicode,
4333           xHeight: 0,
4334           capHeight: 0,
4335           italicAngle: 0,
4336           isType3Font,
4337         };
4338         const widths = dict.get("Widths");
4339 
4340         const standardFontName = getStandardFontName(baseFontName);
4341         let file = null;
4342         if (standardFontName) {
4343           file = await this.fetchStandardFontData(standardFontName);
4344           properties.isInternalFont = !!file;
4345         }
4346         if (!properties.isInternalFont && this.options.useSystemFonts) {
4347           properties.systemFontInfo = getFontSubstitution(
4348             this.systemFontCache,
4349             this.idFactory,
4350             this.options.standardFontDataUrl,
4351             baseFontName,
4352             standardFontName,
4353             type
4354           );
4355         }
4356 
4357         const newProperties = await this.extractDataStructures(
4358           dict,
4359           properties
4360         );
4361         if (Array.isArray(widths)) {
4362           const glyphWidths = [];
4363           let j = firstChar;
4364           for (const w of widths) {
4365             const width = this.xref.fetchIfRef(w);
4366             if (typeof width === "number") {
4367               glyphWidths[j] = width;
4368             }
4369             j++;
4370           }
4371           newProperties.widths = glyphWidths;
4372         } else {
4373           newProperties.widths = this.buildCharCodeToWidth(
4374             metrics.widths,
4375             newProperties
4376           );
4377         }
4378         return new Font(baseFontName, file, newProperties);
4379       }
4380     }
4381 
4382     // According to the spec if 'FontDescriptor' is declared, 'FirstChar',
4383     // 'LastChar' and 'Widths' should exist too, but some PDF encoders seem
4384     // to ignore this rule when a variant of a standard font is used.
4385     // TODO Fill the width array depending on which of the base font this is
4386     // a variant.
4387 
4388     let fontName = descriptor.get("FontName");
4389     let baseFont = dict.get("BaseFont");
4390     // Some bad PDFs have a string as the font name.
4391     if (typeof fontName === "string") {
4392       fontName = Name.get(fontName);
4393     }
4394     if (typeof baseFont === "string") {
4395       baseFont = Name.get(baseFont);
4396     }
4397 
4398     const fontNameStr = fontName?.name;
4399     const baseFontStr = baseFont?.name;
4400     if (!isType3Font && fontNameStr !== baseFontStr) {
4401       info(
4402         `The FontDescriptor's FontName is "${fontNameStr}" but ` +
4403           `should be the same as the Font's BaseFont "${baseFontStr}".`
4404       );
4405       // - Workaround for cases where e.g. fontNameStr = 'Arial' and
4406       //   baseFontStr = 'Arial,Bold' (needed when no font file is embedded).
4407       //
4408       // - Workaround for cases where e.g. fontNameStr = 'wg09np' and
4409       //   baseFontStr = 'Wingdings-Regular' (fixes issue7454.pdf).
4410       if (
4411         fontNameStr &&
4412         baseFontStr &&
4413         (baseFontStr.startsWith(fontNameStr) ||
4414           (!isKnownFontName(fontNameStr) && isKnownFontName(baseFontStr)))
4415       ) {
4416         fontName = null;
4417       }
4418     }
4419     fontName ||= baseFont;
4420 
4421     if (!(fontName instanceof Name)) {
4422       throw new FormatError("invalid font name");
4423     }
4424 
4425     let fontFile, subtype, length1, length2, length3;
4426     try {
4427       fontFile = descriptor.get("FontFile", "FontFile2", "FontFile3");
4428     } catch (ex) {
4429       if (!this.options.ignoreErrors) {
4430         throw ex;
4431       }
4432       warn(`translateFont - fetching "${fontName.name}" font file: "${ex}".`);
4433       fontFile = new NullStream();
4434     }
4435     let isInternalFont = false;
4436     let glyphScaleFactors = null;
4437     let systemFontInfo = null;
4438     if (fontFile) {
4439       if (fontFile.dict) {
4440         const subtypeEntry = fontFile.dict.get("Subtype");
4441         if (subtypeEntry instanceof Name) {
4442           subtype = subtypeEntry.name;
4443         }
4444         length1 = fontFile.dict.get("Length1");
4445         length2 = fontFile.dict.get("Length2");
4446         length3 = fontFile.dict.get("Length3");
4447       }
4448     } else if (cssFontInfo) {
4449       // We've a missing XFA font.
4450       const standardFontName = getXfaFontName(fontName.name);
4451       if (standardFontName) {
4452         cssFontInfo.fontFamily = `${cssFontInfo.fontFamily}-PdfJS-XFA`;
4453         cssFontInfo.metrics = standardFontName.metrics || null;
4454         glyphScaleFactors = standardFontName.factors || null;
4455         fontFile = await this.fetchStandardFontData(standardFontName.name);
4456         isInternalFont = !!fontFile;
4457 
4458         // We're using a substitution font but for example widths (if any)
4459         // are related to the glyph positions in the font.
4460         // So we overwrite everything here to be sure that widths are
4461         // correct.
4462         baseDict = dict = getXfaFontDict(fontName.name);
4463         composite = true;
4464       }
4465     } else if (!isType3Font) {
4466       const standardFontName = getStandardFontName(fontName.name);
4467       if (standardFontName) {
4468         fontFile = await this.fetchStandardFontData(standardFontName);
4469         isInternalFont = !!fontFile;
4470       }
4471       if (!isInternalFont && this.options.useSystemFonts) {
4472         systemFontInfo = getFontSubstitution(
4473           this.systemFontCache,
4474           this.idFactory,
4475           this.options.standardFontDataUrl,
4476           fontName.name,
4477           standardFontName,
4478           type
4479         );
4480       }
4481     }
4482 
4483     const fontMatrix = lookupMatrix(
4484       dict.getArray("FontMatrix"),
4485       FONT_IDENTITY_MATRIX
4486     );
4487     const bbox = lookupNormalRect(
4488       descriptor.getArray("FontBBox") || dict.getArray("FontBBox"),
4489       undefined
4490     );
4491     let ascent = descriptor.get("Ascent");
4492     if (typeof ascent !== "number") {
4493       ascent = undefined;
4494     }
4495     let descent = descriptor.get("Descent");
4496     if (typeof descent !== "number") {
4497       descent = undefined;
4498     }
4499     let xHeight = descriptor.get("XHeight");
4500     if (typeof xHeight !== "number") {
4501       xHeight = 0;
4502     }
4503     let capHeight = descriptor.get("CapHeight");
4504     if (typeof capHeight !== "number") {
4505       capHeight = 0;
4506     }
4507     let flags = descriptor.get("Flags");
4508     if (!Number.isInteger(flags)) {
4509       flags = 0;
4510     }
4511     let italicAngle = descriptor.get("ItalicAngle");
4512     if (typeof italicAngle !== "number") {
4513       italicAngle = 0;
4514     }
4515 
4516     const properties = {
4517       type,
4518       name: fontName.name,
4519       subtype,
4520       file: fontFile,
4521       length1,
4522       length2,
4523       length3,
4524       isInternalFont,
4525       loadedName: baseDict.loadedName,
4526       composite,
4527       fixedPitch: false,
4528       fontMatrix,
4529       firstChar,
4530       lastChar,
4531       toUnicode,
4532       bbox,
4533       ascent,
4534       descent,
4535       xHeight,
4536       capHeight,
4537       flags,
4538       italicAngle,
4539       isType3Font,
4540       cssFontInfo,
4541       scaleFactors: glyphScaleFactors,
4542       systemFontInfo,
4543     };
4544 
4545     if (composite) {
4546       const cidEncoding = baseDict.get("Encoding");
4547       if (cidEncoding instanceof Name) {
4548         properties.cidEncoding = cidEncoding.name;
4549       }
4550       const cMap = await CMapFactory.create({
4551         encoding: cidEncoding,
4552         fetchBuiltInCMap: this._fetchBuiltInCMapBound,
4553         useCMap: null,
4554       });
4555       properties.cMap = cMap;
4556       properties.vertical = properties.cMap.vertical;
4557     }
4558 
4559     const newProperties = await this.extractDataStructures(dict, properties);
4560     this.extractWidths(dict, descriptor, newProperties);
4561 
4562     return new Font(fontName.name, fontFile, newProperties);
4563   }
4564 
4565   static buildFontPaths(font, glyphs, handler, evaluatorOptions) {
4566     function buildPath(fontChar) {
4567       const glyphName = `${font.loadedName}_path_${fontChar}`;
4568       try {
4569         if (font.renderer.hasBuiltPath(fontChar)) {
4570           return;
4571         }
4572         handler.send("commonobj", [
4573           glyphName,
4574           "FontPath",
4575           font.renderer.getPathJs(fontChar),
4576         ]);
4577       } catch (reason) {
4578         if (evaluatorOptions.ignoreErrors) {
4579           warn(`buildFontPaths - ignoring ${glyphName} glyph: "${reason}".`);
4580           return;
4581         }
4582         throw reason;
4583       }
4584     }
4585 
4586     for (const glyph of glyphs) {
4587       buildPath(glyph.fontChar);
4588 
4589       // If the glyph has an accent we need to build a path for its
4590       // fontChar too, otherwise CanvasGraphics_paintChar will fail.
4591       const accent = glyph.accent;
4592       if (accent?.fontChar) {
4593         buildPath(accent.fontChar);
4594       }
4595     }
4596   }
4597 
4598   static get fallbackFontDict() {
4599     const dict = new Dict();
4600     dict.set("BaseFont", Name.get("Helvetica"));
4601     dict.set("Type", Name.get("FallbackType"));
4602     dict.set("Subtype", Name.get("FallbackType"));
4603     dict.set("Encoding", Name.get("WinAnsiEncoding"));
4604 
4605     return shadow(this, "fallbackFontDict", dict);
4606   }
4607 }
4608 
4609 class TranslatedFont {
4610   constructor({ loadedName, font, dict, evaluatorOptions }) {
4611     this.loadedName = loadedName;
4612     this.font = font;
4613     this.dict = dict;
4614     this._evaluatorOptions = evaluatorOptions || DefaultPartialEvaluatorOptions;
4615     this.type3Loaded = null;
4616     this.type3Dependencies = font.isType3Font ? new Set() : null;
4617     this.sent = false;
4618   }
4619 
4620   send(handler) {
4621     if (this.sent) {
4622       return;
4623     }
4624     this.sent = true;
4625 
4626     handler.send("commonobj", [
4627       this.loadedName,
4628       "Font",
4629       this.font.exportData(this._evaluatorOptions.fontExtraProperties),
4630     ]);
4631   }
4632 
4633   fallback(handler) {
4634     if (!this.font.data) {
4635       return;
4636     }
4637     // When font loading failed, fall back to the built-in font renderer.
4638     this.font.disableFontFace = true;
4639     // An arbitrary number of text rendering operators could have been
4640     // encountered between the point in time when the 'Font' message was sent
4641     // to the main-thread, and the point in time when the 'FontFallback'
4642     // message was received on the worker-thread.
4643     // To ensure that all 'FontPath's are available on the main-thread, when
4644     // font loading failed, attempt to resend *all* previously parsed glyphs.
4645     PartialEvaluator.buildFontPaths(
4646       this.font,
4647       /* glyphs = */ this.font.glyphCacheValues,
4648       handler,
4649       this._evaluatorOptions
4650     );
4651   }
4652 
4653   loadType3Data(evaluator, resources, task) {
4654     if (this.type3Loaded) {
4655       return this.type3Loaded;
4656     }
4657     if (!this.font.isType3Font) {
4658       throw new Error("Must be a Type3 font.");
4659     }
4660     // When parsing Type3 glyphs, always ignore them if there are errors.
4661     // Compared to the parsing of e.g. an entire page, it doesn't really
4662     // make sense to only be able to render a Type3 glyph partially.
4663     const type3Evaluator = evaluator.clone({ ignoreErrors: false });
4664     // Prevent circular references in Type3 fonts.
4665     const type3FontRefs = new RefSet(evaluator.type3FontRefs);
4666     if (this.dict.objId && !type3FontRefs.has(this.dict.objId)) {
4667       type3FontRefs.put(this.dict.objId);
4668     }
4669     type3Evaluator.type3FontRefs = type3FontRefs;
4670 
4671     const translatedFont = this.font,
4672       type3Dependencies = this.type3Dependencies;
4673     let loadCharProcsPromise = Promise.resolve();
4674     const charProcs = this.dict.get("CharProcs");
4675     const fontResources = this.dict.get("Resources") || resources;
4676     const charProcOperatorList = Object.create(null);
4677 
4678     const fontBBox = Util.normalizeRect(translatedFont.bbox || [0, 0, 0, 0]),
4679       width = fontBBox[2] - fontBBox[0],
4680       height = fontBBox[3] - fontBBox[1];
4681     const fontBBoxSize = Math.hypot(width, height);
4682 
4683     for (const key of charProcs.getKeys()) {
4684       loadCharProcsPromise = loadCharProcsPromise.then(() => {
4685         const glyphStream = charProcs.get(key);
4686         const operatorList = new OperatorList();
4687         return type3Evaluator
4688           .getOperatorList({
4689             stream: glyphStream,
4690             task,
4691             resources: fontResources,
4692             operatorList,
4693           })
4694           .then(() => {
4695             // According to the PDF specification, section "9.6.5 Type 3 Fonts"
4696             // and "Table 113":
4697             //  "A glyph description that begins with the d1 operator should
4698             //   not execute any operators that set the colour (or other
4699             //   colour-related parameters) in the graphics state;
4700             //   any use of such operators shall be ignored."
4701             if (operatorList.fnArray[0] === OPS.setCharWidthAndBounds) {
4702               this._removeType3ColorOperators(operatorList, fontBBoxSize);
4703             }
4704             charProcOperatorList[key] = operatorList.getIR();
4705 
4706             for (const dependency of operatorList.dependencies) {
4707               type3Dependencies.add(dependency);
4708             }
4709           })
4710           .catch(function (reason) {
4711             warn(`Type3 font resource "${key}" is not available.`);
4712             const dummyOperatorList = new OperatorList();
4713             charProcOperatorList[key] = dummyOperatorList.getIR();
4714           });
4715       });
4716     }
4717     this.type3Loaded = loadCharProcsPromise.then(() => {
4718       translatedFont.charProcOperatorList = charProcOperatorList;
4719       if (this._bbox) {
4720         translatedFont.isCharBBox = true;
4721         translatedFont.bbox = this._bbox;
4722       }
4723     });
4724     return this.type3Loaded;
4725   }
4726 
4727   /**
4728    * @private
4729    */
4730   _removeType3ColorOperators(operatorList, fontBBoxSize = NaN) {
4731     if (typeof PDFJSDev === "undefined" || PDFJSDev.test("TESTING")) {
4732       assert(
4733         operatorList.fnArray[0] === OPS.setCharWidthAndBounds,
4734         "Type3 glyph shall start with the d1 operator."
4735       );
4736     }
4737     const charBBox = Util.normalizeRect(operatorList.argsArray[0].slice(2)),
4738       width = charBBox[2] - charBBox[0],
4739       height = charBBox[3] - charBBox[1];
4740     const charBBoxSize = Math.hypot(width, height);
4741 
4742     if (width === 0 || height === 0) {
4743       // Skip the d1 operator when its bounds are bogus (fixes issue14953.pdf).
4744       operatorList.fnArray.splice(0, 1);
4745       operatorList.argsArray.splice(0, 1);
4746     } else if (
4747       fontBBoxSize === 0 ||
4748       Math.round(charBBoxSize / fontBBoxSize) >= 10
4749     ) {
4750       // Override the fontBBox when it's undefined/empty, or when it's at least
4751       // (approximately) one order of magnitude smaller than the charBBox
4752       // (fixes issue14999_reduced.pdf).
4753       if (!this._bbox) {
4754         this._bbox = [Infinity, Infinity, -Infinity, -Infinity];
4755       }
4756       this._bbox[0] = Math.min(this._bbox[0], charBBox[0]);
4757       this._bbox[1] = Math.min(this._bbox[1], charBBox[1]);
4758       this._bbox[2] = Math.max(this._bbox[2], charBBox[2]);
4759       this._bbox[3] = Math.max(this._bbox[3], charBBox[3]);
4760     }
4761 
4762     let i = 0,
4763       ii = operatorList.length;
4764     while (i < ii) {
4765       switch (operatorList.fnArray[i]) {
4766         case OPS.setCharWidthAndBounds:
4767           break; // Handled above.
4768         case OPS.setStrokeColorSpace:
4769         case OPS.setFillColorSpace:
4770         case OPS.setStrokeColor:
4771         case OPS.setStrokeColorN:
4772         case OPS.setFillColor:
4773         case OPS.setFillColorN:
4774         case OPS.setStrokeGray:
4775         case OPS.setFillGray:
4776         case OPS.setStrokeRGBColor:
4777         case OPS.setFillRGBColor:
4778         case OPS.setStrokeCMYKColor:
4779         case OPS.setFillCMYKColor:
4780         case OPS.shadingFill:
4781         case OPS.setRenderingIntent:
4782           operatorList.fnArray.splice(i, 1);
4783           operatorList.argsArray.splice(i, 1);
4784           ii--;
4785           continue;
4786 
4787         case OPS.setGState:
4788           const [gStateObj] = operatorList.argsArray[i];
4789           let j = 0,
4790             jj = gStateObj.length;
4791           while (j < jj) {
4792             const [gStateKey] = gStateObj[j];
4793             switch (gStateKey) {
4794               case "TR":
4795               case "TR2":
4796               case "HT":
4797               case "BG":
4798               case "BG2":
4799               case "UCR":
4800               case "UCR2":
4801                 gStateObj.splice(j, 1);
4802                 jj--;
4803                 continue;
4804             }
4805             j++;
4806           }
4807           break;
4808       }
4809       i++;
4810     }
4811   }
4812 }
4813 
4814 class StateManager {
4815   constructor(initialState = new EvalState()) {
4816     this.state = initialState;
4817     this.stateStack = [];
4818   }
4819 
4820   save() {
4821     const old = this.state;
4822     this.stateStack.push(this.state);
4823     this.state = old.clone();
4824   }
4825 
4826   restore() {
4827     const prev = this.stateStack.pop();
4828     if (prev) {
4829       this.state = prev;
4830     }
4831   }
4832 
4833   transform(args) {
4834     this.state.ctm = Util.transform(this.state.ctm, args);
4835   }
4836 }
4837 
4838 class TextState {
4839   constructor() {
4840     this.ctm = new Float32Array(IDENTITY_MATRIX);
4841     this.fontName = null;
4842     this.fontSize = 0;
4843     this.loadedName = null;
4844     this.font = null;
4845     this.fontMatrix = FONT_IDENTITY_MATRIX;
4846     this.textMatrix = IDENTITY_MATRIX.slice();
4847     this.textLineMatrix = IDENTITY_MATRIX.slice();
4848     this.charSpacing = 0;
4849     this.wordSpacing = 0;
4850     this.leading = 0;
4851     this.textHScale = 1;
4852     this.textRise = 0;
4853   }
4854 
4855   setTextMatrix(a, b, c, d, e, f) {
4856     const m = this.textMatrix;
4857     m[0] = a;
4858     m[1] = b;
4859     m[2] = c;
4860     m[3] = d;
4861     m[4] = e;
4862     m[5] = f;
4863   }
4864 
4865   setTextLineMatrix(a, b, c, d, e, f) {
4866     const m = this.textLineMatrix;
4867     m[0] = a;
4868     m[1] = b;
4869     m[2] = c;
4870     m[3] = d;
4871     m[4] = e;
4872     m[5] = f;
4873   }
4874 
4875   translateTextMatrix(x, y) {
4876     const m = this.textMatrix;
4877     m[4] = m[0] * x + m[2] * y + m[4];
4878     m[5] = m[1] * x + m[3] * y + m[5];
4879   }
4880 
4881   translateTextLineMatrix(x, y) {
4882     const m = this.textLineMatrix;
4883     m[4] = m[0] * x + m[2] * y + m[4];
4884     m[5] = m[1] * x + m[3] * y + m[5];
4885   }
4886 
4887   carriageReturn() {
4888     this.translateTextLineMatrix(0, -this.leading);
4889     this.textMatrix = this.textLineMatrix.slice();
4890   }
4891 
4892   clone() {
4893     const clone = Object.create(this);
4894     clone.textMatrix = this.textMatrix.slice();
4895     clone.textLineMatrix = this.textLineMatrix.slice();
4896     clone.fontMatrix = this.fontMatrix.slice();
4897     return clone;
4898   }
4899 }
4900 
4901 class EvalState {
4902   constructor() {
4903     this.ctm = new Float32Array(IDENTITY_MATRIX);
4904     this.font = null;
4905     this.textRenderingMode = TextRenderingMode.FILL;
4906     this._fillColorSpace = ColorSpace.singletons.gray;
4907     this._strokeColorSpace = ColorSpace.singletons.gray;
4908     this.patternFillColorSpace = null;
4909     this.patternStrokeColorSpace = null;
4910   }
4911 
4912   get fillColorSpace() {
4913     return this._fillColorSpace;
4914   }
4915 
4916   set fillColorSpace(colorSpace) {
4917     this._fillColorSpace = this.patternFillColorSpace = colorSpace;
4918   }
4919 
4920   get strokeColorSpace() {
4921     return this._strokeColorSpace;
4922   }
4923 
4924   set strokeColorSpace(colorSpace) {
4925     this._strokeColorSpace = this.patternStrokeColorSpace = colorSpace;
4926   }
4927 
4928   clone() {
4929     return Object.create(this);
4930   }
4931 }
4932 
4933 class EvaluatorPreprocessor {
4934   static get opMap() {
4935     // Specifies properties for each command
4936     //
4937     // If variableArgs === true: [0, `numArgs`] expected
4938     // If variableArgs === false: exactly `numArgs` expected
4939     return shadow(
4940       this,
4941       "opMap",
4942       Object.assign(Object.create(null), {
4943         // Graphic state
4944         w: { id: OPS.setLineWidth, numArgs: 1, variableArgs: false },
4945         J: { id: OPS.setLineCap, numArgs: 1, variableArgs: false },
4946         j: { id: OPS.setLineJoin, numArgs: 1, variableArgs: false },
4947         M: { id: OPS.setMiterLimit, numArgs: 1, variableArgs: false },
4948         d: { id: OPS.setDash, numArgs: 2, variableArgs: false },
4949         ri: { id: OPS.setRenderingIntent, numArgs: 1, variableArgs: false },
4950         i: { id: OPS.setFlatness, numArgs: 1, variableArgs: false },
4951         gs: { id: OPS.setGState, numArgs: 1, variableArgs: false },
4952         q: { id: OPS.save, numArgs: 0, variableArgs: false },
4953         Q: { id: OPS.restore, numArgs: 0, variableArgs: false },
4954         cm: { id: OPS.transform, numArgs: 6, variableArgs: false },
4955 
4956         // Path
4957         m: { id: OPS.moveTo, numArgs: 2, variableArgs: false },
4958         l: { id: OPS.lineTo, numArgs: 2, variableArgs: false },
4959         c: { id: OPS.curveTo, numArgs: 6, variableArgs: false },
4960         v: { id: OPS.curveTo2, numArgs: 4, variableArgs: false },
4961         y: { id: OPS.curveTo3, numArgs: 4, variableArgs: false },
4962         h: { id: OPS.closePath, numArgs: 0, variableArgs: false },
4963         re: { id: OPS.rectangle, numArgs: 4, variableArgs: false },
4964         S: { id: OPS.stroke, numArgs: 0, variableArgs: false },
4965         s: { id: OPS.closeStroke, numArgs: 0, variableArgs: false },
4966         f: { id: OPS.fill, numArgs: 0, variableArgs: false },
4967         F: { id: OPS.fill, numArgs: 0, variableArgs: false },
4968         "f*": { id: OPS.eoFill, numArgs: 0, variableArgs: false },
4969         B: { id: OPS.fillStroke, numArgs: 0, variableArgs: false },
4970         "B*": { id: OPS.eoFillStroke, numArgs: 0, variableArgs: false },
4971         b: { id: OPS.closeFillStroke, numArgs: 0, variableArgs: false },
4972         "b*": { id: OPS.closeEOFillStroke, numArgs: 0, variableArgs: false },
4973         n: { id: OPS.endPath, numArgs: 0, variableArgs: false },
4974 
4975         // Clipping
4976         W: { id: OPS.clip, numArgs: 0, variableArgs: false },
4977         "W*": { id: OPS.eoClip, numArgs: 0, variableArgs: false },
4978 
4979         // Text
4980         BT: { id: OPS.beginText, numArgs: 0, variableArgs: false },
4981         ET: { id: OPS.endText, numArgs: 0, variableArgs: false },
4982         Tc: { id: OPS.setCharSpacing, numArgs: 1, variableArgs: false },
4983         Tw: { id: OPS.setWordSpacing, numArgs: 1, variableArgs: false },
4984         Tz: { id: OPS.setHScale, numArgs: 1, variableArgs: false },
4985         TL: { id: OPS.setLeading, numArgs: 1, variableArgs: false },
4986         Tf: { id: OPS.setFont, numArgs: 2, variableArgs: false },
4987         Tr: { id: OPS.setTextRenderingMode, numArgs: 1, variableArgs: false },
4988         Ts: { id: OPS.setTextRise, numArgs: 1, variableArgs: false },
4989         Td: { id: OPS.moveText, numArgs: 2, variableArgs: false },
4990         TD: { id: OPS.setLeadingMoveText, numArgs: 2, variableArgs: false },
4991         Tm: { id: OPS.setTextMatrix, numArgs: 6, variableArgs: false },
4992         "T*": { id: OPS.nextLine, numArgs: 0, variableArgs: false },
4993         Tj: { id: OPS.showText, numArgs: 1, variableArgs: false },
4994         TJ: { id: OPS.showSpacedText, numArgs: 1, variableArgs: false },
4995         "'": { id: OPS.nextLineShowText, numArgs: 1, variableArgs: false },
4996         '"': {
4997           id: OPS.nextLineSetSpacingShowText,
4998           numArgs: 3,
4999           variableArgs: false,
5000         },
5001 
5002         // Type3 fonts
5003         d0: { id: OPS.setCharWidth, numArgs: 2, variableArgs: false },
5004         d1: {
5005           id: OPS.setCharWidthAndBounds,
5006           numArgs: 6,
5007           variableArgs: false,
5008         },
5009 
5010         // Color
5011         CS: { id: OPS.setStrokeColorSpace, numArgs: 1, variableArgs: false },
5012         cs: { id: OPS.setFillColorSpace, numArgs: 1, variableArgs: false },
5013         SC: { id: OPS.setStrokeColor, numArgs: 4, variableArgs: true },
5014         SCN: { id: OPS.setStrokeColorN, numArgs: 33, variableArgs: true },
5015         sc: { id: OPS.setFillColor, numArgs: 4, variableArgs: true },
5016         scn: { id: OPS.setFillColorN, numArgs: 33, variableArgs: true },
5017         G: { id: OPS.setStrokeGray, numArgs: 1, variableArgs: false },
5018         g: { id: OPS.setFillGray, numArgs: 1, variableArgs: false },
5019         RG: { id: OPS.setStrokeRGBColor, numArgs: 3, variableArgs: false },
5020         rg: { id: OPS.setFillRGBColor, numArgs: 3, variableArgs: false },
5021         K: { id: OPS.setStrokeCMYKColor, numArgs: 4, variableArgs: false },
5022         k: { id: OPS.setFillCMYKColor, numArgs: 4, variableArgs: false },
5023 
5024         // Shading
5025         sh: { id: OPS.shadingFill, numArgs: 1, variableArgs: false },
5026 
5027         // Images
5028         BI: { id: OPS.beginInlineImage, numArgs: 0, variableArgs: false },
5029         ID: { id: OPS.beginImageData, numArgs: 0, variableArgs: false },
5030         EI: { id: OPS.endInlineImage, numArgs: 1, variableArgs: false },
5031 
5032         // XObjects
5033         Do: { id: OPS.paintXObject, numArgs: 1, variableArgs: false },
5034         MP: { id: OPS.markPoint, numArgs: 1, variableArgs: false },
5035         DP: { id: OPS.markPointProps, numArgs: 2, variableArgs: false },
5036         BMC: { id: OPS.beginMarkedContent, numArgs: 1, variableArgs: false },
5037         BDC: {
5038           id: OPS.beginMarkedContentProps,
5039           numArgs: 2,
5040           variableArgs: false,
5041         },
5042         EMC: { id: OPS.endMarkedContent, numArgs: 0, variableArgs: false },
5043 
5044         // Compatibility
5045         BX: { id: OPS.beginCompat, numArgs: 0, variableArgs: false },
5046         EX: { id: OPS.endCompat, numArgs: 0, variableArgs: false },
5047 
5048         // (reserved partial commands for the lexer)
5049         BM: null,
5050         BD: null,
5051         true: null,
5052         fa: null,
5053         fal: null,
5054         fals: null,
5055         false: null,
5056         nu: null,
5057         nul: null,
5058         null: null,
5059       })
5060     );
5061   }
5062 
5063   static MAX_INVALID_PATH_OPS = 10;
5064 
5065   constructor(stream, xref, stateManager = new StateManager()) {
5066     // TODO(mduan): pass array of knownCommands rather than this.opMap
5067     // dictionary
5068     this.parser = new Parser({
5069       lexer: new Lexer(stream, EvaluatorPreprocessor.opMap),
5070       xref,
5071     });
5072     this.stateManager = stateManager;
5073     this.nonProcessedArgs = [];
5074     this._isPathOp = false;
5075     this._numInvalidPathOPS = 0;
5076   }
5077 
5078   get savedStatesDepth() {
5079     return this.stateManager.stateStack.length;
5080   }
5081 
5082   // |operation| is an object with two fields:
5083   //
5084   // - |fn| is an out param.
5085   //
5086   // - |args| is an inout param. On entry, it should have one of two values.
5087   //
5088   //   - An empty array. This indicates that the caller is providing the
5089   //     array in which the args will be stored in. The caller should use
5090   //     this value if it can reuse a single array for each call to read().
5091   //
5092   //   - |null|. This indicates that the caller needs this function to create
5093   //     the array in which any args are stored in. If there are zero args,
5094   //     this function will leave |operation.args| as |null| (thus avoiding
5095   //     allocations that would occur if we used an empty array to represent
5096   //     zero arguments). Otherwise, it will replace |null| with a new array
5097   //     containing the arguments. The caller should use this value if it
5098   //     cannot reuse an array for each call to read().
5099   //
5100   // These two modes are present because this function is very hot and so
5101   // avoiding allocations where possible is worthwhile.
5102   //
5103   read(operation) {
5104     let args = operation.args;
5105     while (true) {
5106       const obj = this.parser.getObj();
5107       if (obj instanceof Cmd) {
5108         const cmd = obj.cmd;
5109         // Check that the command is valid
5110         const opSpec = EvaluatorPreprocessor.opMap[cmd];
5111         if (!opSpec) {
5112           warn(`Unknown command "${cmd}".`);
5113           continue;
5114         }
5115 
5116         const fn = opSpec.id;
5117         const numArgs = opSpec.numArgs;
5118         let argsLength = args !== null ? args.length : 0;
5119 
5120         // If the *previous* command wasn't a path operator, reset the heuristic
5121         // used with incomplete path operators below (fixes issue14917.pdf).
5122         if (!this._isPathOp) {
5123           this._numInvalidPathOPS = 0;
5124         }
5125         this._isPathOp = fn >= OPS.moveTo && fn <= OPS.endPath;
5126 
5127         if (!opSpec.variableArgs) {
5128           // Postscript commands can be nested, e.g. /F2 /GS2 gs 5.711 Tf
5129           if (argsLength !== numArgs) {
5130             const nonProcessedArgs = this.nonProcessedArgs;
5131             while (argsLength > numArgs) {
5132               nonProcessedArgs.push(args.shift());
5133               argsLength--;
5134             }
5135             while (argsLength < numArgs && nonProcessedArgs.length !== 0) {
5136               if (args === null) {
5137                 args = [];
5138               }
5139               args.unshift(nonProcessedArgs.pop());
5140               argsLength++;
5141             }
5142           }
5143 
5144           if (argsLength < numArgs) {
5145             const partialMsg =
5146               `command ${cmd}: expected ${numArgs} args, ` +
5147               `but received ${argsLength} args.`;
5148 
5149             // Incomplete path operators, in particular, can result in fairly
5150             // chaotic rendering artifacts. Hence the following heuristics is
5151             // used to error, rather than just warn, once a number of invalid
5152             // path operators have been encountered (fixes bug1443140.pdf).
5153             if (
5154               this._isPathOp &&
5155               ++this._numInvalidPathOPS >
5156                 EvaluatorPreprocessor.MAX_INVALID_PATH_OPS
5157             ) {
5158               throw new FormatError(`Invalid ${partialMsg}`);
5159             }
5160             // If we receive too few arguments, it's not possible to execute
5161             // the command, hence we skip the command.
5162             warn(`Skipping ${partialMsg}`);
5163             if (args !== null) {
5164               args.length = 0;
5165             }
5166             continue;
5167           }
5168         } else if (argsLength > numArgs) {
5169           info(
5170             `Command ${cmd}: expected [0, ${numArgs}] args, ` +
5171               `but received ${argsLength} args.`
5172           );
5173         }
5174 
5175         // TODO figure out how to type-check vararg functions
5176         this.preprocessCommand(fn, args);
5177 
5178         operation.fn = fn;
5179         operation.args = args;
5180         return true;
5181       }
5182       if (obj === EOF) {
5183         return false; // no more commands
5184       }
5185       // argument
5186       if (obj !== null) {
5187         if (args === null) {
5188           args = [];
5189         }
5190         args.push(obj);
5191         if (args.length > 33) {
5192           throw new FormatError("Too many arguments");
5193         }
5194       }
5195     }
5196   }
5197 
5198   preprocessCommand(fn, args) {
5199     switch (fn | 0) {
5200       case OPS.save:
5201         this.stateManager.save();
5202         break;
5203       case OPS.restore:
5204         this.stateManager.restore();
5205         break;
5206       case OPS.transform:
5207         this.stateManager.transform(args);
5208         break;
5209     }
5210   }
5211 }
5212 
5213 export { EvaluatorPreprocessor, PartialEvaluator };
</code>

Your task:
You are a software tester at pdf.js.
1. Write exactly one javascript test `it("...", async () => {...})` block.
2. Your test must fail on the code before the patch, and pass after, hence the test will verify that the patch resolves the issue.
3. The test must be self-contained and to-the-point.
4. Use only the provided imports (respect the paths exactly how they are given) by importing dynamically for compatibility with Node.js — no new dependencies. 
5. Return only the javascript code (no comments or explanations).

Example structure:
it("should <describe behavior>", async () => {
  const { example } = await import("../../src/core/example.js");
  <initialize required variables>;
  <define expected variable>;
  <generate actual variables>;
  <compare expected with actual>;
});

