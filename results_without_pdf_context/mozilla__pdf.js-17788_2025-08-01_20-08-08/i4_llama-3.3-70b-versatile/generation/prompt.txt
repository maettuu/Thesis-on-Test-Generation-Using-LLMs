Before you begin:
- Keep going until the job is completely solved — don’t stop halfway.
- If you’re unsure about the behavior, reread the provided patch carefully; do not hallucinate.
- Plan your approach before writing code by reflecting on whether the test truly fails before and passes after.

Issue:
<issue>
Voice Over will not read highlighted text during editing inside a PDF
</issue>

Patch:
<patch>
diff --git a/src/display/draw_layer.js b/src/display/draw_layer.js
--- a/src/display/draw_layer.js
+++ b/src/display/draw_layer.js
@@ -66,6 +66,7 @@ class DrawLayer {
   #createSVG(box) {
     const svg = DrawLayer._svgFactory.create(1, 1, /* skipDimensions = */ true);
     this.#parent.append(svg);
+    svg.setAttribute("aria-hidden", true);
     DrawLayer.#setBox(svg, box);
 
     return svg;

diff --git a/src/display/editor/color_picker.js b/src/display/editor/color_picker.js
--- a/src/display/editor/color_picker.js
+++ b/src/display/editor/color_picker.js
@@ -93,6 +93,7 @@ class ColorPicker {
     button.addEventListener("keydown", this.#boundKeyDown);
     const swatch = (this.#buttonSwatch = document.createElement("span"));
     swatch.className = "swatch";
+    swatch.setAttribute("aria-hidden", true);
     swatch.style.backgroundColor = this.#defaultColor;
     button.append(swatch);
     return button;

diff --git a/src/display/editor/highlight.js b/src/display/editor/highlight.js
--- a/src/display/editor/highlight.js
+++ b/src/display/editor/highlight.js
@@ -61,6 +61,8 @@ class HighlightEditor extends AnnotationEditor {
 
   #outlineId = null;
 
+  #text = "";
+
   #thickness;
 
   #methodOfCreation = "";
@@ -104,6 +106,7 @@ class HighlightEditor extends AnnotationEditor {
     this.#opacity = params.opacity || HighlightEditor._defaultOpacity;
     this.#boxes = params.boxes || null;
     this.#methodOfCreation = params.methodOfCreation || "";
+    this.#text = params.text || "";
     this._isDraggable = false;
 
     if (params.highlightId > -1) {
@@ -558,6 +561,13 @@ class HighlightEditor extends AnnotationEditor {
     }
 
     const div = super.render();
+    if (this.#text) {
+      const mark = document.createElement("mark");
+      div.append(mark);
+      mark.append(document.createTextNode(this.#text));
+      // The text is invisible but it's still visible by a screen reader.
+      mark.className = "visuallyHidden";
+    }
     if (this.#isFreeHighlight) {
       div.classList.add("free");
     } else {
@@ -565,6 +575,7 @@ class HighlightEditor extends AnnotationEditor {
     }
     const highlightDiv = (this.#highlightDiv = document.createElement("div"));
     div.append(highlightDiv);
+    highlightDiv.setAttribute("aria-hidden", "true");
     highlightDiv.className = "internal";
     highlightDiv.style.clipPath = this.#clipPathId;
     const [parentWidth, parentHeight] = this.parentDimensions;

diff --git a/src/display/editor/toolbar.js b/src/display/editor/toolbar.js
--- a/src/display/editor/toolbar.js
+++ b/src/display/editor/toolbar.js
@@ -31,6 +31,7 @@ class EditorToolbar {
   render() {
     const editToolbar = (this.#toolbar = document.createElement("div"));
     editToolbar.className = "editToolbar";
+    editToolbar.setAttribute("role", "toolbar");
     editToolbar.addEventListener("contextmenu", noContextMenu);
     editToolbar.addEventListener("pointerdown", EditorToolbar.#pointerDown);

diff --git a/src/display/editor/tools.js b/src/display/editor/tools.js
--- a/src/display/editor/tools.js
+++ b/src/display/editor/tools.js
@@ -952,6 +952,7 @@ class AnnotationEditorUIManager {
       return;
     }
     const { anchorNode, anchorOffset, focusNode, focusOffset } = selection;
+    const text = selection.toString();
     const anchorElement =
       anchorNode.nodeType === Node.TEXT_NODE
         ? anchorNode.parentElement
@@ -974,6 +975,7 @@ class AnnotationEditorUIManager {
           anchorOffset,
           focusNode,
           focusOffset,
+          text,
         });
         break;
       }


</patch>

Imports:
<imports>
Available Packages
Dev Dependencies:
- @babel/core: ^7.23.9
- @babel/preset-env: ^7.23.9
- @babel/runtime: ^7.23.9
- @fluent/bundle: ^0.18.0
- @fluent/dom: ^0.9.0
- @jazzer.js/core: ^2.1.0
- autoprefixer: ^10.4.17
- babel-loader: ^9.1.3
- caniuse-lite: ^1.0.30001587
- canvas: ^2.11.2
- core-js: ^3.36.0
- cross-env: ^7.0.3
- eslint: ^8.56.0
- eslint-config-prettier: ^8.10.0
- eslint-plugin-fetch-options: ^0.0.5
- eslint-plugin-html: ^7.1.0
- eslint-plugin-import: ^2.29.1
- eslint-plugin-jasmine: ^4.1.3
- eslint-plugin-json: ^3.1.0
- eslint-plugin-mozilla: ^3.3.2
- eslint-plugin-no-unsanitized: ^4.0.2
- eslint-plugin-prettier: ^5.1.3
- eslint-plugin-sort-exports: ^0.9.1
- eslint-plugin-unicorn: ^51.0.1
- globals: ^14.0.0
- gulp: ^4.0.2
- gulp-cli: ^2.3.0
- gulp-postcss: ^10.0.0
- gulp-rename: ^2.0.0
- gulp-replace: ^1.1.4
- gulp-zip: ^6.0.0
- jasmine: ^5.1.0
- jsdoc: ^4.0.2
- jstransformer-markdown-it: ^3.0.0
- merge-stream: ^2.0.0
- mkdirp: ^3.0.1
- needle: ^3.3.1
- path2d-polyfill: ^2.0.1
- pngjs: ^7.0.0
- postcss: ^8.4.35
- postcss-dark-theme-class: ^1.2.1
- postcss-dir-pseudo-class: ^8.0.1
- postcss-discard-comments: ^6.0.1
- postcss-nesting: ^12.0.2
- prettier: ^3.2.5
- puppeteer: ^22.3.0
- rimraf: ^3.0.2
- streamqueue: ^1.1.2
- stylelint: ^16.2.1
- stylelint-prettier: ^5.0.0
- terser-webpack-plugin: ^5.3.10
- through2: ^4.0.2
- tsc-alias: ^1.8.8
- ttest: ^4.0.0
- typescript: ^5.3.3
- typogr: ^0.6.8
- vinyl: ^3.0.0
- webpack: ^5.90.2
- webpack-stream: ^7.0.0
- wintersmith: ^2.5.0
- yargs: ^17.7.2

Engines:
- node: >=18

Available Relative Imports:
- `../../src/core/annotation.js`: Annotation, AnnotationBorderStyle, AnnotationFactory, MarkupAnnotation, getQuadPoints
- `../../src/core/bidi.js`: bidi
- `../../src/core/cff_parser.js`: CFFCharset, CFFCompiler, CFFFDSelect, CFFParser, CFFStrings
- `../../src/core/cmap.js`: CMap, CMapFactory, IdentityCMap
- `../../src/core/colorspace.js`: ColorSpace
- `../../src/core/core_utils.js`: arrayBuffersToBytes, encodeToXmlString, escapePDFName, escapeString, getInheritableProperty, getSizeInBytes, isAscii, isWhiteSpace, log2, numberToString, parseXFAPath, recoverJsURL, stringToUTF16HexString, stringToUTF16String, toRomanNumerals, validateCSSFont
- `../../src/core/crypto.js`: AES128Cipher, AES256Cipher, ARCFourCipher, CipherTransformFactory, PDF17, PDF20, calculateMD5, calculateSHA256, calculateSHA384, calculateSHA512
- `../../src/core/default_appearance.js`: createDefaultAppearance, parseAppearanceStream, parseDefaultAppearance
- `../../src/core/document.js`: PDFDocument, Page
- `../../src/core/encodings.js`: getEncoding
- `../../src/core/evaluator.js`: PartialEvaluator
- `../../src/core/flate_stream.js`: FlateStream
- `../../src/core/font_substitutions.js`: getFontSubstitution
- `../../src/core/fonts_utils.js`: SEAC_ANALYSIS_ENABLED
- `../../src/core/function.js`: PDFFunctionFactory, PostScriptCompiler, PostScriptEvaluator
- `../../src/core/glyphlist.js`: getDingbatsGlyphsUnicode, getGlyphsUnicode
- `../../src/core/image_utils.js`: GlobalImageCache, LocalColorSpaceCache
- `../../src/core/jbig2.js`: Jbig2Image
- `../../src/core/jpg.js`: JpegImage
- `../../src/core/jpx.js`: JpxImage
- `../../src/core/metadata_parser.js`: MetadataParser
- `../../src/core/operator_list.js`: OperatorList
- `../../src/core/parser.js`: Lexer, Linearization, Parser
- `../../src/core/predictor_stream.js`: PredictorStream
- `../../src/core/primitives.js`: Cmd, Dict, EOF, Name, Ref, RefSet, RefSetCache, isCmd, isDict, isName, isRefsEqual
- `../../src/core/ps_parser.js`: PostScriptLexer, PostScriptParser
- `../../src/core/stream.js`: NullStream, Stream, StringStream
- `../../src/core/type1_parser.js`: Type1Parser
- `../../src/core/unicode.js`: getCharUnicodeCategory, getUnicodeForGlyph, getUnicodeRangeFor, mapSpecialUnicodeValues
- `../../src/core/worker.js`: WorkerMessageHandler, WorkerTask
- `../../src/core/writer.js`: incrementalUpdate, writeDict
- `../../src/core/xfa/bind.js`: Binder
- `../../src/core/xfa/data.js`: DataHandler
- `../../src/core/xfa/factory.js`: XFAFactory
- `../../src/core/xfa/formcalc_lexer.js`: Lexer, TOKEN, Token
- `../../src/core/xfa/formcalc_parser.js`: Errors, Parser
- `../../src/core/xfa/parser.js`: XFAParser
- `../../src/core/xfa/som.js`: searchNode
- `../../src/core/xfa/symbol_utils.js`: $dump, $getChildren, $getChildrenByClass, $getChildrenByName, $text, $uid
- `../../src/core/xml_parser.js`: SimpleXMLParser, XMLParserBase
- `../../src/display/annotation_layer.js`: AnnotationLayer
- `../../src/display/annotation_storage.js`: AnnotationStorage
- `../../src/display/api.js`: DefaultCMapReaderFactory, DefaultCanvasFactory, DefaultStandardFontDataFactory, LoopbackPort, PDFDataRangeTransport, PDFDocumentLoadingTask, PDFDocumentProxy, PDFPageProxy, PDFWorker, PDFWorkerUtil, RenderTask, build, getDocument, version
- `../../src/display/display_utils.js`: DOMCanvasFactory, DOMSVGFactory, PDFDateString, PageViewport, PixelsPerInch, RenderingCancelledException, StatTimer, fetchData, getFilenameFromUrl, getPdfFilenameFromUrl, getXfaPageViewport, isDataScheme, isPdfFile, isValidFetchUrl, noContextMenu, setLayerDimensions
- `../../src/display/draw_layer.js`: DrawLayer
- `../../src/display/editor/annotation_editor_layer.js`: AnnotationEditorLayer
- `../../src/display/editor/color_picker.js`: ColorPicker
- `../../src/display/editor/outliner.js`: Outliner
- `../../src/display/editor/tools.js`: AnnotationEditorUIManager, CommandManager
- `../../src/display/fetch_stream.js`: PDFFetchStream
- `../../src/display/metadata.js`: Metadata
- `../../src/display/network.js`: PDFNetworkStream
- `../../src/display/network_utils.js`: createResponseStatusError, extractFilenameFromHeader, validateRangeRequestCapabilities, validateResponseStatus
- `../../src/display/node_stream.js`: PDFNodeStream
- `../../src/display/text_layer.js`: TextLayerRenderTask, renderTextLayer, updateTextLayer
- `../../src/display/worker_options.js`: GlobalWorkerOptions
- `../../src/display/xfa_layer.js`: XfaLayer
- `../../src/shared/message_handler.js`: MessageHandler
- `../../src/shared/murmurhash3.js`: MurmurHash3_64
- `../../src/shared/util.js`: AbortException, AnnotationBorderStyleType, AnnotationEditorParamsType, AnnotationEditorType, AnnotationFieldFlag, AnnotationFlag, AnnotationMode, AnnotationType, CMapCompressionType, FeatureTest, FormatError, ImageKind, InvalidPDFException, MissingPDFException, OPS, PasswordException, PasswordResponses, PermissionFlag, PromiseCapability, RenderingIntentFlag, UnexpectedResponseException, UnknownErrorException, Util, VerbosityLevel, bytesToString, createValidAbsoluteUrl, getModificationDate, getVerbosityLevel, isNodeJS, normalizeUnicode, objectSize, setVerbosityLevel, shadow, string32, stringToBytes, stringToPDFString, stringToUTF8String
- `../../web/annotation_layer_builder.js`: AnnotationLayerBuilder
- `../../web/download_manager.js`: DownloadManager
- `../../web/event_utils.js`: EventBus, WaitOnType, waitOnEventOrTimeout
- `../../web/genericl10n.js`: GenericL10n
- `../../web/pdf_find_controller.js`: FindState, PDFFindController
- `../../web/pdf_find_utils.js`: CharacterType, getCharacterType
- `../../web/pdf_history.js`: PDFHistory, isDestArraysEqual, isDestHashesEqual
- `../../web/pdf_link_service.js`: LinkTarget, PDFLinkService, SimpleLinkService
- `../../web/pdf_page_view.js`: PDFPageView
- `../../web/pdf_scripting_manager.component.js`: PDFScriptingManager
- `../../web/pdf_single_page_viewer.js`: PDFSinglePageViewer
- `../../web/pdf_viewer.js`: PDFPageViewBuffer, PDFViewer
- `../../web/struct_tree_layer_builder.js`: StructTreeLayerBuilder
- `../../web/text_layer_builder.js`: TextLayerBuilder
- `../../web/ui_utils.js`: AutoPrintRegExp, ProgressBar, RenderingStates, ScrollMode, SpreadMode, backtrackBeforeAllVisibleElements, binarySearchFirstItem, getPageSizeInches, getVisibleElements, isPortraitOrientation, isValidRotation, parseQueryString, removeNullCharacters
- `../../web/xfa_layer_builder.js`: XfaLayerBuilder
- `./test_utils.js`: CMAP_URL, DefaultFileReaderFactory, STANDARD_FONT_DATA_URL, TEST_PDFS_PATH, XRefMock, buildGetDocumentParams, createIdFactory
- `./testreporter.js`: TestReporter
</imports>

Code:
<code>
File:
src/display/draw_layer.js
1 /* Copyright 2023 Mozilla Foundation
2  *
3  * Licensed under the Apache License, Version 2.0 (the "License");
4  * you may not use this file except in compliance with the License.
5  * You may obtain a copy of the License at
6  *
7  *     http://www.apache.org/licenses/LICENSE-2.0
8  *
9  * Unless required by applicable law or agreed to in writing, software
10  * distributed under the License is distributed on an "AS IS" BASIS,
11  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
12  * See the License for the specific language governing permissions and
13  * limitations under the License.
14  */
15 
16 import { DOMSVGFactory } from "./display_utils.js";
17 import { shadow } from "../shared/util.js";
18 
19 /**
20  * Manage the SVGs drawn on top of the page canvas.
21  * It's important to have them directly on top of the canvas because we want to
22  * be able to use mix-blend-mode for some of them.
23  */
24 class DrawLayer {
25   #parent = null;
26 
27   #id = 0;
28 
29   #mapping = new Map();
30 
31   #toUpdate = new Map();
32 
33   constructor({ pageIndex }) {
34     this.pageIndex = pageIndex;
35   }
36 
37   setParent(parent) {
38     if (!this.#parent) {
39       this.#parent = parent;
40       return;
41     }
42 
43     if (this.#parent !== parent) {
44       if (this.#mapping.size > 0) {
45         for (const root of this.#mapping.values()) {
46           root.remove();
47           parent.append(root);
48         }
49       }
50       this.#parent = parent;
51     }
52   }
53 
54   static get _svgFactory() {
55     return shadow(this, "_svgFactory", new DOMSVGFactory());
56   }
57 
58   static #setBox(element, { x = 0, y = 0, width = 1, height = 1 } = {}) {
59     const { style } = element;
60     style.top = `${100 * y}%`;
61     style.left = `${100 * x}%`;
62     style.width = `${100 * width}%`;
63     style.height = `${100 * height}%`;
64   }
65 
66   #createSVG(box) {
67     const svg = DrawLayer._svgFactory.create(1, 1, /* skipDimensions = */ true);
68     this.#parent.append(svg);
69     DrawLayer.#setBox(svg, box);
70 
71     return svg;
72   }
73 
74   #createClipPath(defs, pathId) {
75     const clipPath = DrawLayer._svgFactory.createElement("clipPath");
76     defs.append(clipPath);
77     const clipPathId = `clip_${pathId}`;
78     clipPath.setAttribute("id", clipPathId);
79     clipPath.setAttribute("clipPathUnits", "objectBoundingBox");
80     const clipPathUse = DrawLayer._svgFactory.createElement("use");
81     clipPath.append(clipPathUse);
82     clipPathUse.setAttribute("href", `#${pathId}`);
83     clipPathUse.classList.add("clip");
84 
85     return clipPathId;
86   }
87 
88   highlight(outlines, color, opacity, isPathUpdatable = false) {
89     const id = this.#id++;
90     const root = this.#createSVG(outlines.box);
91     root.classList.add("highlight");
92     if (outlines.free) {
93       root.classList.add("free");
94     }
95     const defs = DrawLayer._svgFactory.createElement("defs");
96     root.append(defs);
97     const path = DrawLayer._svgFactory.createElement("path");
98     defs.append(path);
99     const pathId = `path_p${this.pageIndex}_${id}`;
100     path.setAttribute("id", pathId);
101     path.setAttribute("d", outlines.toSVGPath());
102 
103     if (isPathUpdatable) {
104       this.#toUpdate.set(id, path);
105     }
106 
107     // Create the clipping path for the editor div.
108     const clipPathId = this.#createClipPath(defs, pathId);
109 
110     const use = DrawLayer._svgFactory.createElement("use");
111     root.append(use);
112     root.setAttribute("fill", color);
113     root.setAttribute("fill-opacity", opacity);
114     use.setAttribute("href", `#${pathId}`);
115 
116     this.#mapping.set(id, root);
117 
118     return { id, clipPathId: `url(#${clipPathId})` };
119   }
120 
121   highlightOutline(outlines) {
122     // We cannot draw the outline directly in the SVG for highlights because
123     // it composes with its parent with mix-blend-mode: multiply.
124     // But the outline has a different mix-blend-mode, so we need to draw it in
125     // its own SVG.
126     const id = this.#id++;
127     const root = this.#createSVG(outlines.box);
128     root.classList.add("highlightOutline");
129     const defs = DrawLayer._svgFactory.createElement("defs");
130     root.append(defs);
131     const path = DrawLayer._svgFactory.createElement("path");
132     defs.append(path);
133     const pathId = `path_p${this.pageIndex}_${id}`;
134     path.setAttribute("id", pathId);
135     path.setAttribute("d", outlines.toSVGPath());
136     path.setAttribute("vector-effect", "non-scaling-stroke");
137 
138     let maskId;
139     if (outlines.free) {
140       root.classList.add("free");
141       const mask = DrawLayer._svgFactory.createElement("mask");
142       defs.append(mask);
143       maskId = `mask_p${this.pageIndex}_${id}`;
144       mask.setAttribute("id", maskId);
145       mask.setAttribute("maskUnits", "objectBoundingBox");
146       const rect = DrawLayer._svgFactory.createElement("rect");
147       mask.append(rect);
148       rect.setAttribute("width", "1");
149       rect.setAttribute("height", "1");
150       rect.setAttribute("fill", "white");
151       const use = DrawLayer._svgFactory.createElement("use");
152       mask.append(use);
153       use.setAttribute("href", `#${pathId}`);
154       use.setAttribute("stroke", "none");
155       use.setAttribute("fill", "black");
156       use.setAttribute("fill-rule", "nonzero");
157       use.classList.add("mask");
158     }
159 
160     const use1 = DrawLayer._svgFactory.createElement("use");
161     root.append(use1);
162     use1.setAttribute("href", `#${pathId}`);
163     if (maskId) {
164       use1.setAttribute("mask", `url(#${maskId})`);
165     }
166     const use2 = use1.cloneNode();
167     root.append(use2);
168     use1.classList.add("mainOutline");
169     use2.classList.add("secondaryOutline");
170 
171     this.#mapping.set(id, root);
172 
173     return id;
174   }
175 
176   finalizeLine(id, line) {
177     const path = this.#toUpdate.get(id);
178     this.#toUpdate.delete(id);
179     this.updateBox(id, line.box);
180     path.setAttribute("d", line.toSVGPath());
181   }
182 
183   updateLine(id, line) {
184     const root = this.#mapping.get(id);
185     const defs = root.firstChild;
186     const path = defs.firstChild;
187     path.setAttribute("d", line.toSVGPath());
188   }
189 
190   removeFreeHighlight(id) {
191     this.remove(id);
192     this.#toUpdate.delete(id);
193   }
194 
195   updatePath(id, line) {
196     this.#toUpdate.get(id).setAttribute("d", line.toSVGPath());
197   }
198 
199   updateBox(id, box) {
200     DrawLayer.#setBox(this.#mapping.get(id), box);
201   }
202 
203   show(id, visible) {
204     this.#mapping.get(id).classList.toggle("hidden", !visible);
205   }
206 
207   rotate(id, angle) {
208     this.#mapping.get(id).setAttribute("data-main-rotation", angle);
209   }
210 
211   changeColor(id, color) {
212     this.#mapping.get(id).setAttribute("fill", color);
213   }
214 
215   changeOpacity(id, opacity) {
216     this.#mapping.get(id).setAttribute("fill-opacity", opacity);
217   }
218 
219   addClass(id, className) {
220     this.#mapping.get(id).classList.add(className);
221   }
222 
223   removeClass(id, className) {
224     this.#mapping.get(id).classList.remove(className);
225   }
226 
227   remove(id) {
228     if (this.#parent === null) {
229       return;
230     }
231     this.#mapping.get(id).remove();
232     this.#mapping.delete(id);
233   }
234 
235   destroy() {
236     this.#parent = null;
237     for (const root of this.#mapping.values()) {
238       root.remove();
239     }
240     this.#mapping.clear();
241   }
242 }
243 
244 export { DrawLayer };
File:
src/display/editor/color_picker.js
1 /* Copyright 2023 Mozilla Foundation
2  *
3  * Licensed under the Apache License, Version 2.0 (the "License");
4  * you may not use this file except in compliance with the License.
5  * You may obtain a copy of the License at
6  *
7  *     http://www.apache.org/licenses/LICENSE-2.0
8  *
9  * Unless required by applicable law or agreed to in writing, software
10  * distributed under the License is distributed on an "AS IS" BASIS,
11  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
12  * See the License for the specific language governing permissions and
13  * limitations under the License.
14  */
15 
16 import { AnnotationEditorParamsType, shadow } from "../../shared/util.js";
17 import { KeyboardManager } from "./tools.js";
18 import { noContextMenu } from "../display_utils.js";
19 
20 class ColorPicker {
21   #boundKeyDown = this.#keyDown.bind(this);
22 
23   #boundPointerDown = this.#pointerDown.bind(this);
24 
25   #button = null;
26 
27   #buttonSwatch = null;
28 
29   #defaultColor;
30 
31   #dropdown = null;
32 
33   #dropdownWasFromKeyboard = false;
34 
35   #isMainColorPicker = false;
36 
37   #editor = null;
38 
39   #eventBus;
40 
41   #uiManager = null;
42 
43   #type;
44 
45   static get _keyboardManager() {
46     return shadow(
47       this,
48       "_keyboardManager",
49       new KeyboardManager([
50         [
51           ["Escape", "mac+Escape"],
52           ColorPicker.prototype._hideDropdownFromKeyboard,
53         ],
54         [[" ", "mac+ "], ColorPicker.prototype._colorSelectFromKeyboard],
55         [
56           ["ArrowDown", "ArrowRight", "mac+ArrowDown", "mac+ArrowRight"],
57           ColorPicker.prototype._moveToNext,
58         ],
59         [
60           ["ArrowUp", "ArrowLeft", "mac+ArrowUp", "mac+ArrowLeft"],
61           ColorPicker.prototype._moveToPrevious,
62         ],
63         [["Home", "mac+Home"], ColorPicker.prototype._moveToBeginning],
64         [["End", "mac+End"], ColorPicker.prototype._moveToEnd],
65       ])
66     );
67   }
68 
69   constructor({ editor = null, uiManager = null }) {
70     if (editor) {
71       this.#isMainColorPicker = false;
72       this.#type = AnnotationEditorParamsType.HIGHLIGHT_COLOR;
73       this.#editor = editor;
74     } else {
75       this.#isMainColorPicker = true;
76       this.#type = AnnotationEditorParamsType.HIGHLIGHT_DEFAULT_COLOR;
77     }
78     this.#uiManager = editor?._uiManager || uiManager;
79     this.#eventBus = this.#uiManager._eventBus;
80     this.#defaultColor =
81       editor?.color ||
82       this.#uiManager?.highlightColors.values().next().value ||
83       "#FFFF98";
84   }
85 
86   renderButton() {
87     const button = (this.#button = document.createElement("button"));
88     button.className = "colorPicker";
89     button.tabIndex = "0";
90     button.setAttribute("data-l10n-id", "pdfjs-editor-colorpicker-button");
91     button.setAttribute("aria-haspopup", true);
92     button.addEventListener("click", this.#openDropdown.bind(this));
93     button.addEventListener("keydown", this.#boundKeyDown);
94     const swatch = (this.#buttonSwatch = document.createElement("span"));
95     swatch.className = "swatch";
96     swatch.style.backgroundColor = this.#defaultColor;
97     button.append(swatch);
98     return button;
99   }
100 
101   renderMainDropdown() {
102     const dropdown = (this.#dropdown = this.#getDropdownRoot());
103     dropdown.setAttribute("aria-orientation", "horizontal");
104     dropdown.setAttribute("aria-labelledby", "highlightColorPickerLabel");
105 
106     return dropdown;
107   }
108 
109   #getDropdownRoot() {
110     const div = document.createElement("div");
111     div.addEventListener("contextmenu", noContextMenu);
112     div.className = "dropdown";
113     div.role = "listbox";
114     div.setAttribute("aria-multiselectable", false);
115     div.setAttribute("aria-orientation", "vertical");
116     div.setAttribute("data-l10n-id", "pdfjs-editor-colorpicker-dropdown");
117     for (const [name, color] of this.#uiManager.highlightColors) {
118       const button = document.createElement("button");
119       button.tabIndex = "0";
120       button.role = "option";
121       button.setAttribute("data-color", color);
122       button.title = name;
123       button.setAttribute("data-l10n-id", `pdfjs-editor-colorpicker-${name}`);
124       const swatch = document.createElement("span");
125       button.append(swatch);
126       swatch.className = "swatch";
127       swatch.style.backgroundColor = color;
128       button.setAttribute("aria-selected", color === this.#defaultColor);
129       button.addEventListener("click", this.#colorSelect.bind(this, color));
130       div.append(button);
131     }
132 
133     div.addEventListener("keydown", this.#boundKeyDown);
134 
135     return div;
136   }
137 
138   #colorSelect(color, event) {
139     event.stopPropagation();
140     this.#eventBus.dispatch("switchannotationeditorparams", {
141       source: this,
142       type: this.#type,
143       value: color,
144     });
145   }
146 
147   _colorSelectFromKeyboard(event) {
148     if (event.target === this.#button) {
149       this.#openDropdown(event);
150       return;
151     }
152     const color = event.target.getAttribute("data-color");
153     if (!color) {
154       return;
155     }
156     this.#colorSelect(color, event);
157   }
158 
159   _moveToNext(event) {
160     if (!this.#isDropdownVisible) {
161       this.#openDropdown(event);
162       return;
163     }
164     if (event.target === this.#button) {
165       this.#dropdown.firstChild?.focus();
166       return;
167     }
168     event.target.nextSibling?.focus();
169   }
170 
171   _moveToPrevious(event) {
172     if (
173       event.target === this.#dropdown?.firstChild ||
174       event.target === this.#button
175     ) {
176       if (this.#isDropdownVisible) {
177         this._hideDropdownFromKeyboard();
178       }
179       return;
180     }
181     if (!this.#isDropdownVisible) {
182       this.#openDropdown(event);
183     }
184     event.target.previousSibling?.focus();
185   }
186 
187   _moveToBeginning(event) {
188     if (!this.#isDropdownVisible) {
189       this.#openDropdown(event);
190       return;
191     }
192     this.#dropdown.firstChild?.focus();
193   }
194 
195   _moveToEnd(event) {
196     if (!this.#isDropdownVisible) {
197       this.#openDropdown(event);
198       return;
199     }
200     this.#dropdown.lastChild?.focus();
201   }
202 
203   #keyDown(event) {
204     ColorPicker._keyboardManager.exec(this, event);
205   }
206 
207   #openDropdown(event) {
208     if (this.#isDropdownVisible) {
209       this.hideDropdown();
210       return;
211     }
212     this.#dropdownWasFromKeyboard = event.detail === 0;
213     window.addEventListener("pointerdown", this.#boundPointerDown);
214     if (this.#dropdown) {
215       this.#dropdown.classList.remove("hidden");
216       return;
217     }
218     const root = (this.#dropdown = this.#getDropdownRoot());
219     this.#button.append(root);
220   }
221 
222   #pointerDown(event) {
223     if (this.#dropdown?.contains(event.target)) {
224       return;
225     }
226     this.hideDropdown();
227   }
228 
229   hideDropdown() {
230     this.#dropdown?.classList.add("hidden");
231     window.removeEventListener("pointerdown", this.#boundPointerDown);
232   }
233 
234   get #isDropdownVisible() {
235     return this.#dropdown && !this.#dropdown.classList.contains("hidden");
236   }
237 
238   _hideDropdownFromKeyboard() {
239     if (this.#isMainColorPicker) {
240       return;
241     }
242     if (!this.#isDropdownVisible) {
243       // The user pressed Escape with no dropdown visible, so we must
244       // unselect it.
245       this.#editor?.unselect();
246       return;
247     }
248     this.hideDropdown();
249     this.#button.focus({
250       preventScroll: true,
251       focusVisible: this.#dropdownWasFromKeyboard,
252     });
253   }
254 
255   updateColor(color) {
256     if (this.#buttonSwatch) {
257       this.#buttonSwatch.style.backgroundColor = color;
258     }
259     if (!this.#dropdown) {
260       return;
261     }
262 
263     const i = this.#uiManager.highlightColors.values();
264     for (const child of this.#dropdown.children) {
265       child.setAttribute("aria-selected", i.next().value === color);
266     }
267   }
268 
269   destroy() {
270     this.#button?.remove();
271     this.#button = null;
272     this.#buttonSwatch = null;
273     this.#dropdown?.remove();
274     this.#dropdown = null;
275   }
276 }
277 
278 export { ColorPicker };
File:
src/display/editor/highlight.js
1 /* Copyright 2022 Mozilla Foundation
2  *
3  * Licensed under the Apache License, Version 2.0 (the "License");
4  * you may not use this file except in compliance with the License.
5  * You may obtain a copy of the License at
6  *
7  *     http://www.apache.org/licenses/LICENSE-2.0
8  *
9  * Unless required by applicable law or agreed to in writing, software
10  * distributed under the License is distributed on an "AS IS" BASIS,
11  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
12  * See the License for the specific language governing permissions and
13  * limitations under the License.
14  */
15 
16 import {
17   AnnotationEditorParamsType,
18   AnnotationEditorType,
19   shadow,
20   Util,
21 } from "../../shared/util.js";
22 import { bindEvents, KeyboardManager } from "./tools.js";
23 import { FreeOutliner, Outliner } from "./outliner.js";
24 import { AnnotationEditor } from "./editor.js";
25 import { ColorPicker } from "./color_picker.js";
26 import { noContextMenu } from "../display_utils.js";
27 
28 /**
29  * Basic draw editor in order to generate an Highlight annotation.
30  */
31 class HighlightEditor extends AnnotationEditor {
32   #anchorNode = null;
33 
34   #anchorOffset = 0;
35 
36   #boxes;
37 
38   #clipPathId = null;
39 
40   #colorPicker = null;
41 
42   #focusOutlines = null;
43 
44   #focusNode = null;
45 
46   #focusOffset = 0;
47 
48   #highlightDiv = null;
49 
50   #highlightOutlines = null;
51 
52   #id = null;
53 
54   #isFreeHighlight = false;
55 
56   #boundKeydown = this.#keydown.bind(this);
57 
58   #lastPoint = null;
59 
60   #opacity;
61 
62   #outlineId = null;
63 
64   #thickness;
65 
66   #methodOfCreation = "";
67 
68   static _defaultColor = null;
69 
70   static _defaultOpacity = 1;
71 
72   static _defaultThickness = 12;
73 
74   static _l10nPromise;
75 
76   static _type = "highlight";
77 
78   static _editorType = AnnotationEditorType.HIGHLIGHT;
79 
80   static _freeHighlightId = -1;
81 
82   static _freeHighlight = null;
83 
84   static _freeHighlightClipId = "";
85 
86   static get _keyboardManager() {
87     const proto = HighlightEditor.prototype;
88     return shadow(
89       this,
90       "_keyboardManager",
91       new KeyboardManager([
92         [["ArrowLeft", "mac+ArrowLeft"], proto._moveCaret, { args: [0] }],
93         [["ArrowRight", "mac+ArrowRight"], proto._moveCaret, { args: [1] }],
94         [["ArrowUp", "mac+ArrowUp"], proto._moveCaret, { args: [2] }],
95         [["ArrowDown", "mac+ArrowDown"], proto._moveCaret, { args: [3] }],
96       ])
97     );
98   }
99 
100   constructor(params) {
101     super({ ...params, name: "highlightEditor" });
102     this.color = params.color || HighlightEditor._defaultColor;
103     this.#thickness = params.thickness || HighlightEditor._defaultThickness;
104     this.#opacity = params.opacity || HighlightEditor._defaultOpacity;
105     this.#boxes = params.boxes || null;
106     this.#methodOfCreation = params.methodOfCreation || "";
107     this._isDraggable = false;
108 
109     if (params.highlightId > -1) {
110       this.#isFreeHighlight = true;
111       this.#createFreeOutlines(params);
112       this.#addToDrawLayer();
113     } else {
114       this.#anchorNode = params.anchorNode;
115       this.#anchorOffset = params.anchorOffset;
116       this.#focusNode = params.focusNode;
117       this.#focusOffset = params.focusOffset;
118       this.#createOutlines();
119       this.#addToDrawLayer();
120       this.rotate(this.rotation);
121     }
122   }
123 
124   /** @inheritdoc */
125   get telemetryInitialData() {
126     return {
127       action: "added",
128       type: this.#isFreeHighlight ? "free_highlight" : "highlight",
129       color: this._uiManager.highlightColorNames.get(this.color),
130       thickness: this.#thickness,
131       methodOfCreation: this.#methodOfCreation,
132     };
133   }
134 
135   /** @inheritdoc */
136   get telemetryFinalData() {
137     return {
138       type: "highlight",
139       color: this._uiManager.highlightColorNames.get(this.color),
140     };
141   }
142 
143   static computeTelemetryFinalData(data) {
144     // We want to know how many colors have been used.
145     return { numberOfColors: data.get("color").size };
146   }
147 
148   #createOutlines() {
149     const outliner = new Outliner(this.#boxes, /* borderWidth = */ 0.001);
150     this.#highlightOutlines = outliner.getOutlines();
151     ({
152       x: this.x,
153       y: this.y,
154       width: this.width,
155       height: this.height,
156     } = this.#highlightOutlines.box);
157 
158     const outlinerForOutline = new Outliner(
159       this.#boxes,
160       /* borderWidth = */ 0.0025,
161       /* innerMargin = */ 0.001,
162       this._uiManager.direction === "ltr"
163     );
164     this.#focusOutlines = outlinerForOutline.getOutlines();
165 
166     // The last point is in the pages coordinate system.
167     const { lastPoint } = this.#focusOutlines.box;
168     this.#lastPoint = [
169       (lastPoint[0] - this.x) / this.width,
170       (lastPoint[1] - this.y) / this.height,
171     ];
172   }
173 
174   #createFreeOutlines({ highlightOutlines, highlightId, clipPathId }) {
175     this.#highlightOutlines = highlightOutlines;
176     const extraThickness = 1.5;
177     this.#focusOutlines = highlightOutlines.getNewOutline(
178       /* Slightly bigger than the highlight in order to have a little
179          space between the highlight and the outline. */
180       this.#thickness / 2 + extraThickness,
181       /* innerMargin = */ 0.0025
182     );
183 
184     if (highlightId >= 0) {
185       this.#id = highlightId;
186       this.#clipPathId = clipPathId;
187       // We need to redraw the highlight because we change the coordinates to be
188       // in the box coordinate system.
189       this.parent.drawLayer.finalizeLine(highlightId, highlightOutlines);
190       this.#outlineId = this.parent.drawLayer.highlightOutline(
191         this.#focusOutlines
192       );
193     } else if (this.parent) {
194       const angle = this.parent.viewport.rotation;
195       this.parent.drawLayer.updateLine(this.#id, highlightOutlines);
196       this.parent.drawLayer.updateBox(
197         this.#id,
198         HighlightEditor.#rotateBbox(
199           this.#highlightOutlines.box,
200           (angle - this.rotation + 360) % 360
201         )
202       );
203 
204       this.parent.drawLayer.updateLine(this.#outlineId, this.#focusOutlines);
205       this.parent.drawLayer.updateBox(
206         this.#outlineId,
207         HighlightEditor.#rotateBbox(this.#focusOutlines.box, angle)
208       );
209     }
210     const { x, y, width, height } = highlightOutlines.box;
211     switch (this.rotation) {
212       case 0:
213         this.x = x;
214         this.y = y;
215         this.width = width;
216         this.height = height;
217         break;
218       case 90: {
219         const [pageWidth, pageHeight] = this.parentDimensions;
220         this.x = y;
221         this.y = 1 - x;
222         this.width = (width * pageHeight) / pageWidth;
223         this.height = (height * pageWidth) / pageHeight;
224         break;
225       }
226       case 180:
227         this.x = 1 - x;
228         this.y = 1 - y;
229         this.width = width;
230         this.height = height;
231         break;
232       case 270: {
233         const [pageWidth, pageHeight] = this.parentDimensions;
234         this.x = 1 - y;
235         this.y = x;
236         this.width = (width * pageHeight) / pageWidth;
237         this.height = (height * pageWidth) / pageHeight;
238         break;
239       }
240     }
241 
242     const { lastPoint } = this.#focusOutlines.box;
243     this.#lastPoint = [(lastPoint[0] - x) / width, (lastPoint[1] - y) / height];
244   }
245 
246   /** @inheritdoc */
247   static initialize(l10n, uiManager) {
248     AnnotationEditor.initialize(l10n, uiManager);
249     HighlightEditor._defaultColor ||=
250       uiManager.highlightColors?.values().next().value || "#fff066";
251   }
252 
253   /** @inheritdoc */
254   static updateDefaultParams(type, value) {
255     switch (type) {
256       case AnnotationEditorParamsType.HIGHLIGHT_DEFAULT_COLOR:
257         HighlightEditor._defaultColor = value;
258         break;
259       case AnnotationEditorParamsType.HIGHLIGHT_THICKNESS:
260         HighlightEditor._defaultThickness = value;
261         break;
262     }
263   }
264 
265   /** @inheritdoc */
266   translateInPage(x, y) {}
267 
268   /** @inheritdoc */
269   get toolbarPosition() {
270     return this.#lastPoint;
271   }
272 
273   /** @inheritdoc */
274   updateParams(type, value) {
275     switch (type) {
276       case AnnotationEditorParamsType.HIGHLIGHT_COLOR:
277         this.#updateColor(value);
278         break;
279       case AnnotationEditorParamsType.HIGHLIGHT_THICKNESS:
280         this.#updateThickness(value);
281         break;
282     }
283   }
284 
285   static get defaultPropertiesToUpdate() {
286     return [
287       [
288         AnnotationEditorParamsType.HIGHLIGHT_DEFAULT_COLOR,
289         HighlightEditor._defaultColor,
290       ],
291       [
292         AnnotationEditorParamsType.HIGHLIGHT_THICKNESS,
293         HighlightEditor._defaultThickness,
294       ],
295     ];
296   }
297 
298   /** @inheritdoc */
299   get propertiesToUpdate() {
300     return [
301       [
302         AnnotationEditorParamsType.HIGHLIGHT_COLOR,
303         this.color || HighlightEditor._defaultColor,
304       ],
305       [
306         AnnotationEditorParamsType.HIGHLIGHT_THICKNESS,
307         this.#thickness || HighlightEditor._defaultThickness,
308       ],
309       [AnnotationEditorParamsType.HIGHLIGHT_FREE, this.#isFreeHighlight],
310     ];
311   }
312 
313   /**
314    * Update the color and make this action undoable.
315    * @param {string} color
316    */
317   #updateColor(color) {
318     const setColor = col => {
319       this.color = col;
320       this.parent?.drawLayer.changeColor(this.#id, col);
321       this.#colorPicker?.updateColor(col);
322     };
323     const savedColor = this.color;
324     this.addCommands({
325       cmd: setColor.bind(this, color),
326       undo: setColor.bind(this, savedColor),
327       post: this._uiManager.updateUI.bind(this._uiManager, this),
328       mustExec: true,
329       type: AnnotationEditorParamsType.HIGHLIGHT_COLOR,
330       overwriteIfSameType: true,
331       keepUndo: true,
332     });
333 
334     this._reportTelemetry(
335       {
336         action: "color_changed",
337         color: this._uiManager.highlightColorNames.get(color),
338       },
339       /* mustWait = */ true
340     );
341   }
342 
343   /**
344    * Update the thickness and make this action undoable.
345    * @param {number} thickness
346    */
347   #updateThickness(thickness) {
348     const savedThickness = this.#thickness;
349     const setThickness = th => {
350       this.#thickness = th;
351       this.#changeThickness(th);
352     };
353     this.addCommands({
354       cmd: setThickness.bind(this, thickness),
355       undo: setThickness.bind(this, savedThickness),
356       post: this._uiManager.updateUI.bind(this._uiManager, this),
357       mustExec: true,
358       type: AnnotationEditorParamsType.INK_THICKNESS,
359       overwriteIfSameType: true,
360       keepUndo: true,
361     });
362     this._reportTelemetry(
363       { action: "thickness_changed", thickness },
364       /* mustWait = */ true
365     );
366   }
367 
368   /** @inheritdoc */
369   async addEditToolbar() {
370     const toolbar = await super.addEditToolbar();
371     if (!toolbar) {
372       return null;
373     }
374     if (this._uiManager.highlightColors) {
375       this.#colorPicker = new ColorPicker({ editor: this });
376       toolbar.addColorPicker(this.#colorPicker);
377     }
378     return toolbar;
379   }
380 
381   /** @inheritdoc */
382   disableEditing() {
383     super.disableEditing();
384     this.div.classList.toggle("disabled", true);
385   }
386 
387   /** @inheritdoc */
388   enableEditing() {
389     super.enableEditing();
390     this.div.classList.toggle("disabled", false);
391   }
392 
393   /** @inheritdoc */
394   fixAndSetPosition() {
395     return super.fixAndSetPosition(this.#getRotation());
396   }
397 
398   /** @inheritdoc */
399   getBaseTranslation() {
400     // The editor itself doesn't have any CSS border (we're drawing one
401     // ourselves in using SVG).
402     return [0, 0];
403   }
404 
405   /** @inheritdoc */
406   getRect(tx, ty) {
407     return super.getRect(tx, ty, this.#getRotation());
408   }
409 
410   /** @inheritdoc */
411   onceAdded() {
412     this.parent.addUndoableEditor(this);
413     this.div.focus();
414   }
415 
416   /** @inheritdoc */
417   remove() {
418     super.remove();
419     this.#cleanDrawLayer();
420     this._reportTelemetry({
421       action: "deleted",
422     });
423   }
424 
425   /** @inheritdoc */
426   rebuild() {
427     if (!this.parent) {
428       return;
429     }
430     super.rebuild();
431     if (this.div === null) {
432       return;
433     }
434 
435     this.#addToDrawLayer();
436 
437     if (!this.isAttachedToDOM) {
438       // At some point this editor was removed and we're rebuilding it,
439       // hence we must add it to its parent.
440       this.parent.add(this);
441     }
442   }
443 
444   setParent(parent) {
445     let mustBeSelected = false;
446     if (this.parent && !parent) {
447       this.#cleanDrawLayer();
448     } else if (parent) {
449       this.#addToDrawLayer(parent);
450       // If mustBeSelected is true it means that this editor was selected
451       // when its parent has been destroyed, hence we must select it again.
452       mustBeSelected =
453         !this.parent && this.div?.classList.contains("selectedEditor");
454     }
455     super.setParent(parent);
456     this.show(this._isVisible);
457     if (mustBeSelected) {
458       // We select it after the parent has been set.
459       this.select();
460     }
461   }
462 
463   #changeThickness(thickness) {
464     if (!this.#isFreeHighlight) {
465       return;
466     }
467     this.#createFreeOutlines({
468       highlightOutlines: this.#highlightOutlines.getNewOutline(thickness / 2),
469     });
470     this.fixAndSetPosition();
471     const [parentWidth, parentHeight] = this.parentDimensions;
472     this.setDims(this.width * parentWidth, this.height * parentHeight);
473   }
474 
475   #cleanDrawLayer() {
476     if (this.#id === null || !this.parent) {
477       return;
478     }
479     this.parent.drawLayer.remove(this.#id);
480     this.#id = null;
481     this.parent.drawLayer.remove(this.#outlineId);
482     this.#outlineId = null;
483   }
484 
485   #addToDrawLayer(parent = this.parent) {
486     if (this.#id !== null) {
487       return;
488     }
489     ({ id: this.#id, clipPathId: this.#clipPathId } =
490       parent.drawLayer.highlight(
491         this.#highlightOutlines,
492         this.color,
493         this.#opacity
494       ));
495     this.#outlineId = parent.drawLayer.highlightOutline(this.#focusOutlines);
496     if (this.#highlightDiv) {
497       this.#highlightDiv.style.clipPath = this.#clipPathId;
498     }
499   }
500 
501   static #rotateBbox({ x, y, width, height }, angle) {
502     switch (angle) {
503       case 90:
504         return {
505           x: 1 - y - height,
506           y: x,
507           width: height,
508           height: width,
509         };
510       case 180:
511         return {
512           x: 1 - x - width,
513           y: 1 - y - height,
514           width,
515           height,
516         };
517       case 270:
518         return {
519           x: y,
520           y: 1 - x - width,
521           width: height,
522           height: width,
523         };
524     }
525     return {
526       x,
527       y,
528       width,
529       height,
530     };
531   }
532 
533   /** @inheritdoc */
534   rotate(angle) {
535     // We need to rotate the svgs because of the coordinates system.
536     const { drawLayer } = this.parent;
537     let box;
538     if (this.#isFreeHighlight) {
539       angle = (angle - this.rotation + 360) % 360;
540       box = HighlightEditor.#rotateBbox(this.#highlightOutlines.box, angle);
541     } else {
542       // An highlight annotation is always drawn horizontally.
543       box = HighlightEditor.#rotateBbox(this, angle);
544     }
545     drawLayer.rotate(this.#id, angle);
546     drawLayer.rotate(this.#outlineId, angle);
547     drawLayer.updateBox(this.#id, box);
548     drawLayer.updateBox(
549       this.#outlineId,
550       HighlightEditor.#rotateBbox(this.#focusOutlines.box, angle)
551     );
552   }
553 
554   /** @inheritdoc */
555   render() {
556     if (this.div) {
557       return this.div;
558     }
559 
560     const div = super.render();
561     if (this.#isFreeHighlight) {
562       div.classList.add("free");
563     } else {
564       this.div.addEventListener("keydown", this.#boundKeydown);
565     }
566     const highlightDiv = (this.#highlightDiv = document.createElement("div"));
567     div.append(highlightDiv);
568     highlightDiv.className = "internal";
569     highlightDiv.style.clipPath = this.#clipPathId;
570     const [parentWidth, parentHeight] = this.parentDimensions;
571     this.setDims(this.width * parentWidth, this.height * parentHeight);
572 
573     bindEvents(this, this.#highlightDiv, ["pointerover", "pointerleave"]);
574     this.enableEditing();
575 
576     return div;
577   }
578 
579   pointerover() {
580     this.parent.drawLayer.addClass(this.#outlineId, "hovered");
581   }
582 
583   pointerleave() {
584     this.parent.drawLayer.removeClass(this.#outlineId, "hovered");
585   }
586 
587   #keydown(event) {
588     HighlightEditor._keyboardManager.exec(this, event);
589   }
590 
591   _moveCaret(direction) {
592     this.parent.unselect(this);
593     switch (direction) {
594       case 0 /* left */:
595       case 2 /* up */:
596         this.#setCaret(/* start = */ true);
597         break;
598       case 1 /* right */:
599       case 3 /* down */:
600         this.#setCaret(/* start = */ false);
601         break;
602     }
603   }
604 
605   #setCaret(start) {
606     if (!this.#anchorNode) {
607       return;
608     }
609     const selection = window.getSelection();
610     if (start) {
611       selection.setPosition(this.#anchorNode, this.#anchorOffset);
612     } else {
613       selection.setPosition(this.#focusNode, this.#focusOffset);
614     }
615   }
616 
617   /** @inheritdoc */
618   select() {
619     super.select();
620     this.parent?.drawLayer.removeClass(this.#outlineId, "hovered");
621     this.parent?.drawLayer.addClass(this.#outlineId, "selected");
622   }
623 
624   /** @inheritdoc */
625   unselect() {
626     super.unselect();
627     this.parent?.drawLayer.removeClass(this.#outlineId, "selected");
628     if (!this.#isFreeHighlight) {
629       this.#setCaret(/* start = */ false);
630     }
631   }
632 
633   /** @inheritdoc */
634   get _mustFixPosition() {
635     return !this.#isFreeHighlight;
636   }
637 
638   show(visible) {
639     super.show(visible);
640     if (this.parent) {
641       this.parent.drawLayer.show(this.#id, visible);
642       this.parent.drawLayer.show(this.#outlineId, visible);
643     }
644   }
645 
646   #getRotation() {
647     // Highlight annotations are always drawn horizontally but if
648     // a free highlight annotation can be rotated.
649     return this.#isFreeHighlight ? this.rotation : 0;
650   }
651 
652   #serializeBoxes() {
653     if (this.#isFreeHighlight) {
654       return null;
655     }
656     const [pageWidth, pageHeight] = this.pageDimensions;
657     const boxes = this.#boxes;
658     const quadPoints = new Array(boxes.length * 8);
659     let i = 0;
660     for (const { x, y, width, height } of boxes) {
661       const sx = x * pageWidth;
662       const sy = (1 - y - height) * pageHeight;
663       // The specifications say that the rectangle should start from the bottom
664       // left corner and go counter-clockwise.
665       // But when opening the file in Adobe Acrobat it appears that this isn't
666       // correct hence the 4th and 6th numbers are just swapped.
667       quadPoints[i] = quadPoints[i + 4] = sx;
668       quadPoints[i + 1] = quadPoints[i + 3] = sy;
669       quadPoints[i + 2] = quadPoints[i + 6] = sx + width * pageWidth;
670       quadPoints[i + 5] = quadPoints[i + 7] = sy + height * pageHeight;
671       i += 8;
672     }
673     return quadPoints;
674   }
675 
676   #serializeOutlines(rect) {
677     return this.#highlightOutlines.serialize(rect, this.#getRotation());
678   }
679 
680   static startHighlighting(parent, isLTR, { target: textLayer, x, y }) {
681     const {
682       x: layerX,
683       y: layerY,
684       width: parentWidth,
685       height: parentHeight,
686     } = textLayer.getBoundingClientRect();
687     const pointerMove = e => {
688       this.#highlightMove(parent, e);
689     };
690     const pointerDownOptions = { capture: true, passive: false };
691     const pointerDown = e => {
692       // Avoid to have undesired clicks during the drawing.
693       e.preventDefault();
694       e.stopPropagation();
695     };
696     const pointerUpCallback = e => {
697       textLayer.removeEventListener("pointermove", pointerMove);
698       window.removeEventListener("blur", pointerUpCallback);
699       window.removeEventListener("pointerup", pointerUpCallback);
700       window.removeEventListener(
701         "pointerdown",
702         pointerDown,
703         pointerDownOptions
704       );
705       window.removeEventListener("contextmenu", noContextMenu);
706       this.#endHighlight(parent, e);
707     };
708     window.addEventListener("blur", pointerUpCallback);
709     window.addEventListener("pointerup", pointerUpCallback);
710     window.addEventListener("pointerdown", pointerDown, pointerDownOptions);
711     window.addEventListener("contextmenu", noContextMenu);
712 
713     textLayer.addEventListener("pointermove", pointerMove);
714     this._freeHighlight = new FreeOutliner(
715       { x, y },
716       [layerX, layerY, parentWidth, parentHeight],
717       parent.scale,
718       this._defaultThickness / 2,
719       isLTR,
720       /* innerMargin = */ 0.001
721     );
722     ({ id: this._freeHighlightId, clipPathId: this._freeHighlightClipId } =
723       parent.drawLayer.highlight(
724         this._freeHighlight,
725         this._defaultColor,
726         this._defaultOpacity,
727         /* isPathUpdatable = */ true
728       ));
729   }
730 
731   static #highlightMove(parent, event) {
732     if (this._freeHighlight.add(event)) {
733       // Redraw only if the point has been added.
734       parent.drawLayer.updatePath(this._freeHighlightId, this._freeHighlight);
735     }
736   }
737 
738   static #endHighlight(parent, event) {
739     if (!this._freeHighlight.isEmpty()) {
740       parent.createAndAddNewEditor(event, false, {
741         highlightId: this._freeHighlightId,
742         highlightOutlines: this._freeHighlight.getOutlines(),
743         clipPathId: this._freeHighlightClipId,
744         methodOfCreation: "main_toolbar",
745       });
746     } else {
747       parent.drawLayer.removeFreeHighlight(this._freeHighlightId);
748     }
749     this._freeHighlightId = -1;
750     this._freeHighlight = null;
751     this._freeHighlightClipId = "";
752   }
753 
754   /** @inheritdoc */
755   static deserialize(data, parent, uiManager) {
756     const editor = super.deserialize(data, parent, uiManager);
757 
758     const {
759       rect: [blX, blY, trX, trY],
760       color,
761       quadPoints,
762     } = data;
763     editor.color = Util.makeHexColor(...color);
764     editor.#opacity = data.opacity;
765 
766     const [pageWidth, pageHeight] = editor.pageDimensions;
767     editor.width = (trX - blX) / pageWidth;
768     editor.height = (trY - blY) / pageHeight;
769     const boxes = (editor.#boxes = []);
770     for (let i = 0; i < quadPoints.length; i += 8) {
771       boxes.push({
772         x: (quadPoints[4] - trX) / pageWidth,
773         y: (trY - (1 - quadPoints[i + 5])) / pageHeight,
774         width: (quadPoints[i + 2] - quadPoints[i]) / pageWidth,
775         height: (quadPoints[i + 5] - quadPoints[i + 1]) / pageHeight,
776       });
777     }
778     editor.#createOutlines();
779 
780     return editor;
781   }
782 
783   /** @inheritdoc */
784   serialize(isForCopying = false) {
785     // It doesn't make sense to copy/paste a highlight annotation.
786     if (this.isEmpty() || isForCopying) {
787       return null;
788     }
789 
790     const rect = this.getRect(0, 0);
791     const color = AnnotationEditor._colorManager.convert(this.color);
792 
793     return {
794       annotationType: AnnotationEditorType.HIGHLIGHT,
795       color,
796       opacity: this.#opacity,
797       thickness: this.#thickness,
798       quadPoints: this.#serializeBoxes(),
799       outlines: this.#serializeOutlines(rect),
800       pageIndex: this.pageIndex,
801       rect,
802       rotation: this.#getRotation(),
803       structTreeParentId: this._structTreeParentId,
804     };
805   }
806 
807   static canCreateNewEmptyEditor() {
808     return false;
809   }
810 }
811 
812 export { HighlightEditor };
File:
src/display/editor/toolbar.js
1 /* Copyright 2023 Mozilla Foundation
2  *
3  * Licensed under the Apache License, Version 2.0 (the "License");
4  * you may not use this file except in compliance with the License.
5  * You may obtain a copy of the License at
6  *
7  *     http://www.apache.org/licenses/LICENSE-2.0
8  *
9  * Unless required by applicable law or agreed to in writing, software
10  * distributed under the License is distributed on an "AS IS" BASIS,
11  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
12  * See the License for the specific language governing permissions and
13  * limitations under the License.
14  */
15 
16 import { noContextMenu } from "../display_utils.js";
17 
18 class EditorToolbar {
19   #toolbar = null;
20 
21   #colorPicker = null;
22 
23   #editor;
24 
25   #buttons = null;
26 
27   constructor(editor) {
28     this.#editor = editor;
29   }
30 
31   render() {
32     const editToolbar = (this.#toolbar = document.createElement("div"));
33     editToolbar.className = "editToolbar";
34     editToolbar.addEventListener("contextmenu", noContextMenu);
35     editToolbar.addEventListener("pointerdown", EditorToolbar.#pointerDown);
36 
37     const buttons = (this.#buttons = document.createElement("div"));
38     buttons.className = "buttons";
39     editToolbar.append(buttons);
40 
41     const position = this.#editor.toolbarPosition;
42     if (position) {
43       const { style } = editToolbar;
44       const x =
45         this.#editor._uiManager.direction === "ltr"
46           ? 1 - position[0]
47           : position[0];
48       style.insetInlineEnd = `${100 * x}%`;
49       style.top = `calc(${
50         100 * position[1]
51       }% + var(--editor-toolbar-vert-offset))`;
52     }
53 
54     this.#addDeleteButton();
55 
56     return editToolbar;
57   }
58 
59   static #pointerDown(e) {
60     e.stopPropagation();
61   }
62 
63   #focusIn(e) {
64     this.#editor._focusEventsAllowed = false;
65     e.preventDefault();
66     e.stopPropagation();
67   }
68 
69   #focusOut(e) {
70     this.#editor._focusEventsAllowed = true;
71     e.preventDefault();
72     e.stopPropagation();
73   }
74 
75   #addListenersToElement(element) {
76     // If we're clicking on a button with the keyboard or with
77     // the mouse, we don't want to trigger any focus events on
78     // the editor.
79     element.addEventListener("focusin", this.#focusIn.bind(this), {
80       capture: true,
81     });
82     element.addEventListener("focusout", this.#focusOut.bind(this), {
83       capture: true,
84     });
85     element.addEventListener("contextmenu", noContextMenu);
86   }
87 
88   hide() {
89     this.#toolbar.classList.add("hidden");
90     this.#colorPicker?.hideDropdown();
91   }
92 
93   show() {
94     this.#toolbar.classList.remove("hidden");
95   }
96 
97   #addDeleteButton() {
98     const button = document.createElement("button");
99     button.className = "delete";
100     button.tabIndex = 0;
101     button.setAttribute(
102       "data-l10n-id",
103       `pdfjs-editor-remove-${this.#editor.editorType}-button`
104     );
105     this.#addListenersToElement(button);
106     button.addEventListener("click", e => {
107       this.#editor._uiManager.delete();
108     });
109     this.#buttons.append(button);
110   }
111 
112   get #divider() {
113     const divider = document.createElement("div");
114     divider.className = "divider";
115     return divider;
116   }
117 
118   addAltTextButton(button) {
119     this.#addListenersToElement(button);
120     this.#buttons.prepend(button, this.#divider);
121   }
122 
123   addColorPicker(colorPicker) {
124     this.#colorPicker = colorPicker;
125     const button = colorPicker.renderButton();
126     this.#addListenersToElement(button);
127     this.#buttons.prepend(button, this.#divider);
128   }
129 
130   remove() {
131     this.#toolbar.remove();
132     this.#colorPicker?.destroy();
133     this.#colorPicker = null;
134   }
135 }
136 
137 export { EditorToolbar };
File:
src/display/editor/tools.js
1 /* Copyright 2022 Mozilla Foundation
2  *
3  * Licensed under the Apache License, Version 2.0 (the "License");
4  * you may not use this file except in compliance with the License.
5  * You may obtain a copy of the License at
6  *
7  *     http://www.apache.org/licenses/LICENSE-2.0
8  *
9  * Unless required by applicable law or agreed to in writing, software
10  * distributed under the License is distributed on an "AS IS" BASIS,
11  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
12  * See the License for the specific language governing permissions and
13  * limitations under the License.
14  */
15 
16 /** @typedef {import("./editor.js").AnnotationEditor} AnnotationEditor */
17 // eslint-disable-next-line max-len
18 /** @typedef {import("./annotation_editor_layer.js").AnnotationEditorLayer} AnnotationEditorLayer */
19 
20 import {
21   AnnotationEditorParamsType,
22   AnnotationEditorPrefix,
23   AnnotationEditorType,
24   FeatureTest,
25   getUuid,
26   shadow,
27   Util,
28   warn,
29 } from "../../shared/util.js";
30 import {
31   fetchData,
32   getColorValues,
33   getRGB,
34   PixelsPerInch,
35 } from "../display_utils.js";
36 
37 function bindEvents(obj, element, names) {
38   for (const name of names) {
39     element.addEventListener(name, obj[name].bind(obj));
40   }
41 }
42 
43 /**
44  * Convert a number between 0 and 100 into an hex number between 0 and 255.
45  * @param {number} opacity
46  * @return {string}
47  */
48 function opacityToHex(opacity) {
49   return Math.round(Math.min(255, Math.max(1, 255 * opacity)))
50     .toString(16)
51     .padStart(2, "0");
52 }
53 
54 /**
55  * Class to create some unique ids for the different editors.
56  */
57 class IdManager {
58   #id = 0;
59 
60   constructor() {
61     if (typeof PDFJSDev !== "undefined" && PDFJSDev.test("TESTING")) {
62       Object.defineProperty(this, "reset", {
63         value: () => (this.#id = 0),
64       });
65     }
66   }
67 
68   /**
69    * Get a unique id.
70    * @returns {string}
71    */
72   get id() {
73     return `${AnnotationEditorPrefix}${this.#id++}`;
74   }
75 }
76 
77 /**
78  * Class to manage the images used by the editors.
79  * The main idea is to try to minimize the memory used by the images.
80  * The images are cached and reused when possible
81  * We use a refCounter to know when an image is not used anymore but we need to
82  * be able to restore an image after a remove+undo, so we keep a file reference
83  * or an url one.
84  */
85 class ImageManager {
86   #baseId = getUuid();
87 
88   #id = 0;
89 
90   #cache = null;
91 
92   static get _isSVGFittingCanvas() {
93     // By default, Firefox doesn't rescale without preserving the aspect ratio
94     // when drawing an SVG image on a canvas, see https://bugzilla.mozilla.org/1547776.
95     // The "workaround" is to append "svgView(preserveAspectRatio(none))" to the
96     // url, but according to comment #15, it seems that it leads to unexpected
97     // behavior in Safari.
98     const svg = `data:image/svg+xml;charset=UTF-8,<svg viewBox="0 0 1 1" width="1" height="1" xmlns="http://www.w3.org/2000/svg"><rect width="1" height="1" style="fill:red;"/></svg>`;
99     const canvas = new OffscreenCanvas(1, 3);
100     const ctx = canvas.getContext("2d");
101     const image = new Image();
102     image.src = svg;
103     const promise = image.decode().then(() => {
104       ctx.drawImage(image, 0, 0, 1, 1, 0, 0, 1, 3);
105       return new Uint32Array(ctx.getImageData(0, 0, 1, 1).data.buffer)[0] === 0;
106     });
107 
108     return shadow(this, "_isSVGFittingCanvas", promise);
109   }
110 
111   async #get(key, rawData) {
112     this.#cache ||= new Map();
113     let data = this.#cache.get(key);
114     if (data === null) {
115       // We already tried to load the image but it failed.
116       return null;
117     }
118     if (data?.bitmap) {
119       data.refCounter += 1;
120       return data;
121     }
122     try {
123       data ||= {
124         bitmap: null,
125         id: `image_${this.#baseId}_${this.#id++}`,
126         refCounter: 0,
127         isSvg: false,
128       };
129       let image;
130       if (typeof rawData === "string") {
131         data.url = rawData;
132         image = await fetchData(rawData, "blob");
133       } else {
134         image = data.file = rawData;
135       }
136 
137       if (image.type === "image/svg+xml") {
138         // Unfortunately, createImageBitmap doesn't work with SVG images.
139         // (see https://bugzilla.mozilla.org/1841972).
140         const mustRemoveAspectRatioPromise = ImageManager._isSVGFittingCanvas;
141         const fileReader = new FileReader();
142         const imageElement = new Image();
143         const imagePromise = new Promise((resolve, reject) => {
144           imageElement.onload = () => {
145             data.bitmap = imageElement;
146             data.isSvg = true;
147             resolve();
148           };
149           fileReader.onload = async () => {
150             const url = (data.svgUrl = fileReader.result);
151             // We need to set the preserveAspectRatio to none in order to let
152             // the image fits the canvas when resizing.
153             imageElement.src = (await mustRemoveAspectRatioPromise)
154               ? `${url}#svgView(preserveAspectRatio(none))`
155               : url;
156           };
157           imageElement.onerror = fileReader.onerror = reject;
158         });
159         fileReader.readAsDataURL(image);
160         await imagePromise;
161       } else {
162         data.bitmap = await createImageBitmap(image);
163       }
164       data.refCounter = 1;
165     } catch (e) {
166       console.error(e);
167       data = null;
168     }
169     this.#cache.set(key, data);
170     if (data) {
171       this.#cache.set(data.id, data);
172     }
173     return data;
174   }
175 
176   async getFromFile(file) {
177     const { lastModified, name, size, type } = file;
178     return this.#get(`${lastModified}_${name}_${size}_${type}`, file);
179   }
180 
181   async getFromUrl(url) {
182     return this.#get(url, url);
183   }
184 
185   async getFromId(id) {
186     this.#cache ||= new Map();
187     const data = this.#cache.get(id);
188     if (!data) {
189       return null;
190     }
191     if (data.bitmap) {
192       data.refCounter += 1;
193       return data;
194     }
195 
196     if (data.file) {
197       return this.getFromFile(data.file);
198     }
199     return this.getFromUrl(data.url);
200   }
201 
202   getSvgUrl(id) {
203     const data = this.#cache.get(id);
204     if (!data?.isSvg) {
205       return null;
206     }
207     return data.svgUrl;
208   }
209 
210   deleteId(id) {
211     this.#cache ||= new Map();
212     const data = this.#cache.get(id);
213     if (!data) {
214       return;
215     }
216     data.refCounter -= 1;
217     if (data.refCounter !== 0) {
218       return;
219     }
220     data.bitmap = null;
221   }
222 
223   // We can use the id only if it belongs this manager.
224   // We must take care of having the right manager because we can copy/paste
225   // some images from other documents, hence it'd be a pity to use an id from an
226   // other manager.
227   isValidId(id) {
228     return id.startsWith(`image_${this.#baseId}_`);
229   }
230 }
231 
232 /**
233  * Class to handle undo/redo.
234  * Commands are just saved in a buffer.
235  * If we hit some memory issues we could likely use a circular buffer.
236  * It has to be used as a singleton.
237  */
238 class CommandManager {
239   #commands = [];
240 
241   #locked = false;
242 
243   #maxSize;
244 
245   #position = -1;
246 
247   constructor(maxSize = 128) {
248     this.#maxSize = maxSize;
249   }
250 
251   /**
252    * @typedef {Object} addOptions
253    * @property {function} cmd
254    * @property {function} undo
255    * @property {function} [post]
256    * @property {boolean} mustExec
257    * @property {number} type
258    * @property {boolean} overwriteIfSameType
259    * @property {boolean} keepUndo
260    */
261 
262   /**
263    * Add a new couple of commands to be used in case of redo/undo.
264    * @param {addOptions} options
265    */
266   add({
267     cmd,
268     undo,
269     post,
270     mustExec,
271     type = NaN,
272     overwriteIfSameType = false,
273     keepUndo = false,
274   }) {
275     if (mustExec) {
276       cmd();
277     }
278 
279     if (this.#locked) {
280       return;
281     }
282 
283     const save = { cmd, undo, post, type };
284     if (this.#position === -1) {
285       if (this.#commands.length > 0) {
286         // All the commands have been undone and then a new one is added
287         // hence we clear the queue.
288         this.#commands.length = 0;
289       }
290       this.#position = 0;
291       this.#commands.push(save);
292       return;
293     }
294 
295     if (overwriteIfSameType && this.#commands[this.#position].type === type) {
296       // For example when we change a color we don't want to
297       // be able to undo all the steps, hence we only want to
298       // keep the last undoable action in this sequence of actions.
299       if (keepUndo) {
300         save.undo = this.#commands[this.#position].undo;
301       }
302       this.#commands[this.#position] = save;
303       return;
304     }
305 
306     const next = this.#position + 1;
307     if (next === this.#maxSize) {
308       this.#commands.splice(0, 1);
309     } else {
310       this.#position = next;
311       if (next < this.#commands.length) {
312         this.#commands.splice(next);
313       }
314     }
315 
316     this.#commands.push(save);
317   }
318 
319   /**
320    * Undo the last command.
321    */
322   undo() {
323     if (this.#position === -1) {
324       // Nothing to undo.
325       return;
326     }
327 
328     // Avoid to insert something during the undo execution.
329     this.#locked = true;
330     const { undo, post } = this.#commands[this.#position];
331     undo();
332     post?.();
333     this.#locked = false;
334 
335     this.#position -= 1;
336   }
337 
338   /**
339    * Redo the last command.
340    */
341   redo() {
342     if (this.#position < this.#commands.length - 1) {
343       this.#position += 1;
344 
345       // Avoid to insert something during the redo execution.
346       this.#locked = true;
347       const { cmd, post } = this.#commands[this.#position];
348       cmd();
349       post?.();
350       this.#locked = false;
351     }
352   }
353 
354   /**
355    * Check if there is something to undo.
356    * @returns {boolean}
357    */
358   hasSomethingToUndo() {
359     return this.#position !== -1;
360   }
361 
362   /**
363    * Check if there is something to redo.
364    * @returns {boolean}
365    */
366   hasSomethingToRedo() {
367     return this.#position < this.#commands.length - 1;
368   }
369 
370   destroy() {
371     this.#commands = null;
372   }
373 }
374 
375 /**
376  * Class to handle the different keyboards shortcuts we can have on mac or
377  * non-mac OSes.
378  */
379 class KeyboardManager {
380   /**
381    * Create a new keyboard manager class.
382    * @param {Array<Array>} callbacks - an array containing an array of shortcuts
383    * and a callback to call.
384    * A shortcut is a string like `ctrl+c` or `mac+ctrl+c` for mac OS.
385    */
386   constructor(callbacks) {
387     this.buffer = [];
388     this.callbacks = new Map();
389     this.allKeys = new Set();
390 
391     const { isMac } = FeatureTest.platform;
392     for (const [keys, callback, options = {}] of callbacks) {
393       for (const key of keys) {
394         const isMacKey = key.startsWith("mac+");
395         if (isMac && isMacKey) {
396           this.callbacks.set(key.slice(4), { callback, options });
397           this.allKeys.add(key.split("+").at(-1));
398         } else if (!isMac && !isMacKey) {
399           this.callbacks.set(key, { callback, options });
400           this.allKeys.add(key.split("+").at(-1));
401         }
402       }
403     }
404   }
405 
406   /**
407    * Serialize an event into a string in order to match a
408    * potential key for a callback.
409    * @param {KeyboardEvent} event
410    * @returns {string}
411    */
412   #serialize(event) {
413     if (event.altKey) {
414       this.buffer.push("alt");
415     }
416     if (event.ctrlKey) {
417       this.buffer.push("ctrl");
418     }
419     if (event.metaKey) {
420       this.buffer.push("meta");
421     }
422     if (event.shiftKey) {
423       this.buffer.push("shift");
424     }
425     this.buffer.push(event.key);
426     const str = this.buffer.join("+");
427     this.buffer.length = 0;
428 
429     return str;
430   }
431 
432   /**
433    * Execute a callback, if any, for a given keyboard event.
434    * The self is used as `this` in the callback.
435    * @param {Object} self
436    * @param {KeyboardEvent} event
437    * @returns
438    */
439   exec(self, event) {
440     if (!this.allKeys.has(event.key)) {
441       return;
442     }
443     const info = this.callbacks.get(this.#serialize(event));
444     if (!info) {
445       return;
446     }
447     const {
448       callback,
449       options: { bubbles = false, args = [], checker = null },
450     } = info;
451 
452     if (checker && !checker(self, event)) {
453       return;
454     }
455     callback.bind(self, ...args, event)();
456 
457     // For example, ctrl+s in a FreeText must be handled by the viewer, hence
458     // the event must bubble.
459     if (!bubbles) {
460       event.stopPropagation();
461       event.preventDefault();
462     }
463   }
464 }
465 
466 class ColorManager {
467   static _colorsMapping = new Map([
468     ["CanvasText", [0, 0, 0]],
469     ["Canvas", [255, 255, 255]],
470   ]);
471 
472   get _colors() {
473     if (
474       typeof PDFJSDev !== "undefined" &&
475       PDFJSDev.test("LIB") &&
476       typeof document === "undefined"
477     ) {
478       return shadow(this, "_colors", ColorManager._colorsMapping);
479     }
480 
481     const colors = new Map([
482       ["CanvasText", null],
483       ["Canvas", null],
484     ]);
485     getColorValues(colors);
486     return shadow(this, "_colors", colors);
487   }
488 
489   /**
490    * In High Contrast Mode, the color on the screen is not always the
491    * real color used in the pdf.
492    * For example in some cases white can appear to be black but when saving
493    * we want to have white.
494    * @param {string} color
495    * @returns {Array<number>}
496    */
497   convert(color) {
498     const rgb = getRGB(color);
499     if (!window.matchMedia("(forced-colors: active)").matches) {
500       return rgb;
501     }
502 
503     for (const [name, RGB] of this._colors) {
504       if (RGB.every((x, i) => x === rgb[i])) {
505         return ColorManager._colorsMapping.get(name);
506       }
507     }
508     return rgb;
509   }
510 
511   /**
512    * An input element must have its color value as a hex string
513    * and not as color name.
514    * So this function converts a name into an hex string.
515    * @param {string} name
516    * @returns {string}
517    */
518   getHexCode(name) {
519     const rgb = this._colors.get(name);
520     if (!rgb) {
521       return name;
522     }
523     return Util.makeHexColor(...rgb);
524   }
525 }
526 
527 /**
528  * A pdf has several pages and each of them when it will rendered
529  * will have an AnnotationEditorLayer which will contain the some
530  * new Annotations associated to an editor in order to modify them.
531  *
532  * This class is used to manage all the different layers, editors and
533  * some action like copy/paste, undo/redo, ...
534  */
535 class AnnotationEditorUIManager {
536   #activeEditor = null;
537 
538   #allEditors = new Map();
539 
540   #allLayers = new Map();
541 
542   #altTextManager = null;
543 
544   #annotationStorage = null;
545 
546   #commandManager = new CommandManager();
547 
548   #currentPageIndex = 0;
549 
550   #deletedAnnotationsElementIds = new Set();
551 
552   #draggingEditors = null;
553 
554   #editorTypes = null;
555 
556   #editorsToRescale = new Set();
557 
558   #filterFactory = null;
559 
560   #focusMainContainerTimeoutId = null;
561 
562   #highlightColors = null;
563 
564   #highlightWhenShiftUp = false;
565 
566   #idManager = new IdManager();
567 
568   #isEnabled = false;
569 
570   #isWaiting = false;
571 
572   #lastActiveElement = null;
573 
574   #mainHighlightColorPicker = null;
575 
576   #mlManager = null;
577 
578   #mode = AnnotationEditorType.NONE;
579 
580   #selectedEditors = new Set();
581 
582   #selectedTextNode = null;
583 
584   #pageColors = null;
585 
586   #showAllStates = null;
587 
588   #boundBlur = this.blur.bind(this);
589 
590   #boundFocus = this.focus.bind(this);
591 
592   #boundCopy = this.copy.bind(this);
593 
594   #boundCut = this.cut.bind(this);
595 
596   #boundPaste = this.paste.bind(this);
597 
598   #boundKeydown = this.keydown.bind(this);
599 
600   #boundKeyup = this.keyup.bind(this);
601 
602   #boundOnEditingAction = this.onEditingAction.bind(this);
603 
604   #boundOnPageChanging = this.onPageChanging.bind(this);
605 
606   #boundOnScaleChanging = this.onScaleChanging.bind(this);
607 
608   #boundSelectionChange = this.#selectionChange.bind(this);
609 
610   #boundOnRotationChanging = this.onRotationChanging.bind(this);
611 
612   #previousStates = {
613     isEditing: false,
614     isEmpty: true,
615     hasSomethingToUndo: false,
616     hasSomethingToRedo: false,
617     hasSelectedEditor: false,
618     hasSelectedText: false,
619   };
620 
621   #translation = [0, 0];
622 
623   #translationTimeoutId = null;
624 
625   #container = null;
626 
627   #viewer = null;
628 
629   static TRANSLATE_SMALL = 1; // page units.
630 
631   static TRANSLATE_BIG = 10; // page units.
632 
633   static get _keyboardManager() {
634     const proto = AnnotationEditorUIManager.prototype;
635 
636     /**
637      * If the focused element is an input, we don't want to handle the arrow.
638      * For example, sliders can be controlled with the arrow keys.
639      */
640     const arrowChecker = self =>
641       self.#container.contains(document.activeElement) &&
642       document.activeElement.tagName !== "BUTTON" &&
643       self.hasSomethingToControl();
644 
645     const textInputChecker = (_self, { target: el }) => {
646       if (el instanceof HTMLInputElement) {
647         const { type } = el;
648         return type !== "text" && type !== "number";
649       }
650       return true;
651     };
652 
653     const small = this.TRANSLATE_SMALL;
654     const big = this.TRANSLATE_BIG;
655 
656     return shadow(
657       this,
658       "_keyboardManager",
659       new KeyboardManager([
660         [
661           ["ctrl+a", "mac+meta+a"],
662           proto.selectAll,
663           { checker: textInputChecker },
664         ],
665         [["ctrl+z", "mac+meta+z"], proto.undo, { checker: textInputChecker }],
666         [
667           // On mac, depending of the OS version, the event.key is either "z" or
668           // "Z" when the user presses "meta+shift+z".
669           [
670             "ctrl+y",
671             "ctrl+shift+z",
672             "mac+meta+shift+z",
673             "ctrl+shift+Z",
674             "mac+meta+shift+Z",
675           ],
676           proto.redo,
677           { checker: textInputChecker },
678         ],
679         [
680           [
681             "Backspace",
682             "alt+Backspace",
683             "ctrl+Backspace",
684             "shift+Backspace",
685             "mac+Backspace",
686             "mac+alt+Backspace",
687             "mac+ctrl+Backspace",
688             "Delete",
689             "ctrl+Delete",
690             "shift+Delete",
691             "mac+Delete",
692           ],
693           proto.delete,
694           { checker: textInputChecker },
695         ],
696         [
697           ["Enter", "mac+Enter"],
698           proto.addNewEditorFromKeyboard,
699           {
700             // Those shortcuts can be used in the toolbar for some other actions
701             // like zooming, hence we need to check if the container has the
702             // focus.
703             checker: (self, { target: el }) =>
704               !(el instanceof HTMLButtonElement) &&
705               self.#container.contains(el) &&
706               !self.isEnterHandled,
707           },
708         ],
709         [
710           [" ", "mac+ "],
711           proto.addNewEditorFromKeyboard,
712           {
713             // Those shortcuts can be used in the toolbar for some other actions
714             // like zooming, hence we need to check if the container has the
715             // focus.
716             checker: (self, { target: el }) =>
717               !(el instanceof HTMLButtonElement) &&
718               self.#container.contains(document.activeElement),
719           },
720         ],
721         [["Escape", "mac+Escape"], proto.unselectAll],
722         [
723           ["ArrowLeft", "mac+ArrowLeft"],
724           proto.translateSelectedEditors,
725           { args: [-small, 0], checker: arrowChecker },
726         ],
727         [
728           ["ctrl+ArrowLeft", "mac+shift+ArrowLeft"],
729           proto.translateSelectedEditors,
730           { args: [-big, 0], checker: arrowChecker },
731         ],
732         [
733           ["ArrowRight", "mac+ArrowRight"],
734           proto.translateSelectedEditors,
735           { args: [small, 0], checker: arrowChecker },
736         ],
737         [
738           ["ctrl+ArrowRight", "mac+shift+ArrowRight"],
739           proto.translateSelectedEditors,
740           { args: [big, 0], checker: arrowChecker },
741         ],
742         [
743           ["ArrowUp", "mac+ArrowUp"],
744           proto.translateSelectedEditors,
745           { args: [0, -small], checker: arrowChecker },
746         ],
747         [
748           ["ctrl+ArrowUp", "mac+shift+ArrowUp"],
749           proto.translateSelectedEditors,
750           { args: [0, -big], checker: arrowChecker },
751         ],
752         [
753           ["ArrowDown", "mac+ArrowDown"],
754           proto.translateSelectedEditors,
755           { args: [0, small], checker: arrowChecker },
756         ],
757         [
758           ["ctrl+ArrowDown", "mac+shift+ArrowDown"],
759           proto.translateSelectedEditors,
760           { args: [0, big], checker: arrowChecker },
761         ],
762       ])
763     );
764   }
765 
766   constructor(
767     container,
768     viewer,
769     altTextManager,
770     eventBus,
771     pdfDocument,
772     pageColors,
773     highlightColors,
774     mlManager
775   ) {
776     this.#container = container;
777     this.#viewer = viewer;
778     this.#altTextManager = altTextManager;
779     this._eventBus = eventBus;
780     this._eventBus._on("editingaction", this.#boundOnEditingAction);
781     this._eventBus._on("pagechanging", this.#boundOnPageChanging);
782     this._eventBus._on("scalechanging", this.#boundOnScaleChanging);
783     this._eventBus._on("rotationchanging", this.#boundOnRotationChanging);
784     this.#addSelectionListener();
785     this.#annotationStorage = pdfDocument.annotationStorage;
786     this.#filterFactory = pdfDocument.filterFactory;
787     this.#pageColors = pageColors;
788     this.#highlightColors = highlightColors || null;
789     this.#mlManager = mlManager || null;
790     this.viewParameters = {
791       realScale: PixelsPerInch.PDF_TO_CSS_UNITS,
792       rotation: 0,
793     };
794     this.isShiftKeyDown = false;
795 
796     if (typeof PDFJSDev !== "undefined" && PDFJSDev.test("TESTING")) {
797       Object.defineProperty(this, "reset", {
798         value: () => {
799           this.selectAll();
800           this.delete();
801           this.#idManager.reset();
802         },
803       });
804     }
805   }
806 
807   destroy() {
808     this.#removeKeyboardManager();
809     this.#removeFocusManager();
810     this._eventBus._off("editingaction", this.#boundOnEditingAction);
811     this._eventBus._off("pagechanging", this.#boundOnPageChanging);
812     this._eventBus._off("scalechanging", this.#boundOnScaleChanging);
813     this._eventBus._off("rotationchanging", this.#boundOnRotationChanging);
814     for (const layer of this.#allLayers.values()) {
815       layer.destroy();
816     }
817     this.#allLayers.clear();
818     this.#allEditors.clear();
819     this.#editorsToRescale.clear();
820     this.#activeEditor = null;
821     this.#selectedEditors.clear();
822     this.#commandManager.destroy();
823     this.#altTextManager?.destroy();
824     if (this.#focusMainContainerTimeoutId) {
825       clearTimeout(this.#focusMainContainerTimeoutId);
826       this.#focusMainContainerTimeoutId = null;
827     }
828     if (this.#translationTimeoutId) {
829       clearTimeout(this.#translationTimeoutId);
830       this.#translationTimeoutId = null;
831     }
832     this.#removeSelectionListener();
833   }
834 
835   async mlGuess(data) {
836     return this.#mlManager?.guess(data) || null;
837   }
838 
839   get hasMLManager() {
840     return !!this.#mlManager;
841   }
842 
843   get hcmFilter() {
844     return shadow(
845       this,
846       "hcmFilter",
847       this.#pageColors
848         ? this.#filterFactory.addHCMFilter(
849             this.#pageColors.foreground,
850             this.#pageColors.background
851           )
852         : "none"
853     );
854   }
855 
856   get direction() {
857     return shadow(
858       this,
859       "direction",
860       getComputedStyle(this.#container).direction
861     );
862   }
863 
864   get highlightColors() {
865     return shadow(
866       this,
867       "highlightColors",
868       this.#highlightColors
869         ? new Map(
870             this.#highlightColors
871               .split(",")
872               .map(pair => pair.split("=").map(x => x.trim()))
873           )
874         : null
875     );
876   }
877 
878   get highlightColorNames() {
879     return shadow(
880       this,
881       "highlightColorNames",
882       this.highlightColors
883         ? new Map(Array.from(this.highlightColors, e => e.reverse()))
884         : null
885     );
886   }
887 
888   setMainHighlightColorPicker(colorPicker) {
889     this.#mainHighlightColorPicker = colorPicker;
890   }
891 
892   editAltText(editor) {
893     this.#altTextManager?.editAltText(this, editor);
894   }
895 
896   onPageChanging({ pageNumber }) {
897     this.#currentPageIndex = pageNumber - 1;
898   }
899 
900   focusMainContainer() {
901     this.#container.focus();
902   }
903 
904   findParent(x, y) {
905     for (const layer of this.#allLayers.values()) {
906       const {
907         x: layerX,
908         y: layerY,
909         width,
910         height,
911       } = layer.div.getBoundingClientRect();
912       if (
913         x >= layerX &&
914         x <= layerX + width &&
915         y >= layerY &&
916         y <= layerY + height
917       ) {
918         return layer;
919       }
920     }
921     return null;
922   }
923 
924   disableUserSelect(value = false) {
925     this.#viewer.classList.toggle("noUserSelect", value);
926   }
927 
928   addShouldRescale(editor) {
929     this.#editorsToRescale.add(editor);
930   }
931 
932   removeShouldRescale(editor) {
933     this.#editorsToRescale.delete(editor);
934   }
935 
936   onScaleChanging({ scale }) {
937     this.commitOrRemove();
938     this.viewParameters.realScale = scale * PixelsPerInch.PDF_TO_CSS_UNITS;
939     for (const editor of this.#editorsToRescale) {
940       editor.onScaleChanging();
941     }
942   }
943 
944   onRotationChanging({ pagesRotation }) {
945     this.commitOrRemove();
946     this.viewParameters.rotation = pagesRotation;
947   }
948 
949   highlightSelection(methodOfCreation = "") {
950     const selection = document.getSelection();
951     if (!selection || selection.isCollapsed) {
952       return;
953     }
954     const { anchorNode, anchorOffset, focusNode, focusOffset } = selection;
955     const anchorElement =
956       anchorNode.nodeType === Node.TEXT_NODE
957         ? anchorNode.parentElement
958         : anchorNode;
959     const textLayer = anchorElement.closest(".textLayer");
960     const boxes = this.getSelectionBoxes(textLayer);
961     selection.empty();
962     if (this.#mode === AnnotationEditorType.NONE) {
963       this._eventBus.dispatch("showannotationeditorui", {
964         source: this,
965         mode: AnnotationEditorType.HIGHLIGHT,
966       });
967     }
968     for (const layer of this.#allLayers.values()) {
969       if (layer.hasTextLayer(textLayer)) {
970         layer.createAndAddNewEditor({ x: 0, y: 0 }, false, {
971           methodOfCreation,
972           boxes,
973           anchorNode,
974           anchorOffset,
975           focusNode,
976           focusOffset,
977         });
978         break;
979       }
980     }
981   }
982 
983   /**
984    * Add an editor in the annotation storage.
985    * @param {AnnotationEditor} editor
986    */
987   addToAnnotationStorage(editor) {
988     if (
989       !editor.isEmpty() &&
990       this.#annotationStorage &&
991       !this.#annotationStorage.has(editor.id)
992     ) {
993       this.#annotationStorage.setValue(editor.id, editor);
994     }
995   }
996 
997   #selectionChange() {
998     const selection = document.getSelection();
999     if (!selection || selection.isCollapsed) {
1000       if (this.#selectedTextNode) {
1001         this.#selectedTextNode = null;
1002         this.#dispatchUpdateStates({
1003           hasSelectedText: false,
1004         });
1005       }
1006       return;
1007     }
1008     const { anchorNode } = selection;
1009     if (anchorNode === this.#selectedTextNode) {
1010       return;
1011     }
1012 
1013     const anchorElement =
1014       anchorNode.nodeType === Node.TEXT_NODE
1015         ? anchorNode.parentElement
1016         : anchorNode;
1017     if (!anchorElement.closest(".textLayer")) {
1018       if (this.#selectedTextNode) {
1019         this.#selectedTextNode = null;
1020         this.#dispatchUpdateStates({
1021           hasSelectedText: false,
1022         });
1023       }
1024       return;
1025     }
1026     this.#selectedTextNode = anchorNode;
1027     this.#dispatchUpdateStates({
1028       hasSelectedText: true,
1029     });
1030 
1031     if (this.#mode !== AnnotationEditorType.HIGHLIGHT) {
1032       return;
1033     }
1034 
1035     this.showAllEditors("highlight", true, /* updateButton = */ true);
1036 
1037     this.#highlightWhenShiftUp = this.isShiftKeyDown;
1038     if (!this.isShiftKeyDown) {
1039       const pointerup = e => {
1040         if (e.type === "pointerup" && e.button !== 0) {
1041           // Do nothing on right click.
1042           return;
1043         }
1044         window.removeEventListener("pointerup", pointerup);
1045         window.removeEventListener("blur", pointerup);
1046         if (e.type === "pointerup") {
1047           this.highlightSelection("main_toolbar");
1048         }
1049       };
1050       window.addEventListener("pointerup", pointerup);
1051       window.addEventListener("blur", pointerup);
1052     }
1053   }
1054 
1055   #addSelectionListener() {
1056     document.addEventListener("selectionchange", this.#boundSelectionChange);
1057   }
1058 
1059   #removeSelectionListener() {
1060     document.removeEventListener("selectionchange", this.#boundSelectionChange);
1061   }
1062 
1063   #addFocusManager() {
1064     window.addEventListener("focus", this.#boundFocus);
1065     window.addEventListener("blur", this.#boundBlur);
1066   }
1067 
1068   #removeFocusManager() {
1069     window.removeEventListener("focus", this.#boundFocus);
1070     window.removeEventListener("blur", this.#boundBlur);
1071   }
1072 
1073   blur() {
1074     this.isShiftKeyDown = false;
1075     if (this.#highlightWhenShiftUp) {
1076       this.#highlightWhenShiftUp = false;
1077       this.highlightSelection("main_toolbar");
1078     }
1079     if (!this.hasSelection) {
1080       return;
1081     }
1082     // When several editors are selected and the window loses focus, we want to
1083     // keep the last active element in order to be able to focus it again when
1084     // the window gets the focus back but we don't want to trigger any focus
1085     // callbacks else only one editor will be selected.
1086     const { activeElement } = document;
1087     for (const editor of this.#selectedEditors) {
1088       if (editor.div.contains(activeElement)) {
1089         this.#lastActiveElement = [editor, activeElement];
1090         editor._focusEventsAllowed = false;
1091         break;
1092       }
1093     }
1094   }
1095 
1096   focus() {
1097     if (!this.#lastActiveElement) {
1098       return;
1099     }
1100     const [lastEditor, lastActiveElement] = this.#lastActiveElement;
1101     this.#lastActiveElement = null;
1102     lastActiveElement.addEventListener(
1103       "focusin",
1104       () => {
1105         lastEditor._focusEventsAllowed = true;
1106       },
1107       { once: true }
1108     );
1109     lastActiveElement.focus();
1110   }
1111 
1112   #addKeyboardManager() {
1113     // The keyboard events are caught at the container level in order to be able
1114     // to execute some callbacks even if the current page doesn't have focus.
1115     window.addEventListener("keydown", this.#boundKeydown);
1116     window.addEventListener("keyup", this.#boundKeyup);
1117   }
1118 
1119   #removeKeyboardManager() {
1120     window.removeEventListener("keydown", this.#boundKeydown);
1121     window.removeEventListener("keyup", this.#boundKeyup);
1122   }
1123 
1124   #addCopyPasteListeners() {
1125     document.addEventListener("copy", this.#boundCopy);
1126     document.addEventListener("cut", this.#boundCut);
1127     document.addEventListener("paste", this.#boundPaste);
1128   }
1129 
1130   #removeCopyPasteListeners() {
1131     document.removeEventListener("copy", this.#boundCopy);
1132     document.removeEventListener("cut", this.#boundCut);
1133     document.removeEventListener("paste", this.#boundPaste);
1134   }
1135 
1136   addEditListeners() {
1137     this.#addKeyboardManager();
1138     this.#addCopyPasteListeners();
1139   }
1140 
1141   removeEditListeners() {
1142     this.#removeKeyboardManager();
1143     this.#removeCopyPasteListeners();
1144   }
1145 
1146   /**
1147    * Copy callback.
1148    * @param {ClipboardEvent} event
1149    */
1150   copy(event) {
1151     event.preventDefault();
1152 
1153     // An editor is being edited so just commit it.
1154     this.#activeEditor?.commitOrRemove();
1155 
1156     if (!this.hasSelection) {
1157       return;
1158     }
1159 
1160     const editors = [];
1161     for (const editor of this.#selectedEditors) {
1162       const serialized = editor.serialize(/* isForCopying = */ true);
1163       if (serialized) {
1164         editors.push(serialized);
1165       }
1166     }
1167     if (editors.length === 0) {
1168       return;
1169     }
1170 
1171     event.clipboardData.setData("application/pdfjs", JSON.stringify(editors));
1172   }
1173 
1174   /**
1175    * Cut callback.
1176    * @param {ClipboardEvent} event
1177    */
1178   cut(event) {
1179     this.copy(event);
1180     this.delete();
1181   }
1182 
1183   /**
1184    * Paste callback.
1185    * @param {ClipboardEvent} event
1186    */
1187   paste(event) {
1188     event.preventDefault();
1189     const { clipboardData } = event;
1190     for (const item of clipboardData.items) {
1191       for (const editorType of this.#editorTypes) {
1192         if (editorType.isHandlingMimeForPasting(item.type)) {
1193           editorType.paste(item, this.currentLayer);
1194           return;
1195         }
1196       }
1197     }
1198 
1199     let data = clipboardData.getData("application/pdfjs");
1200     if (!data) {
1201       return;
1202     }
1203 
1204     try {
1205       data = JSON.parse(data);
1206     } catch (ex) {
1207       warn(`paste: "${ex.message}".`);
1208       return;
1209     }
1210 
1211     if (!Array.isArray(data)) {
1212       return;
1213     }
1214 
1215     this.unselectAll();
1216     const layer = this.currentLayer;
1217 
1218     try {
1219       const newEditors = [];
1220       for (const editor of data) {
1221         const deserializedEditor = layer.deserialize(editor);
1222         if (!deserializedEditor) {
1223           return;
1224         }
1225         newEditors.push(deserializedEditor);
1226       }
1227 
1228       const cmd = () => {
1229         for (const editor of newEditors) {
1230           this.#addEditorToLayer(editor);
1231         }
1232         this.#selectEditors(newEditors);
1233       };
1234       const undo = () => {
1235         for (const editor of newEditors) {
1236           editor.remove();
1237         }
1238       };
1239       this.addCommands({ cmd, undo, mustExec: true });
1240     } catch (ex) {
1241       warn(`paste: "${ex.message}".`);
1242     }
1243   }
1244 
1245   /**
1246    * Keydown callback.
1247    * @param {KeyboardEvent} event
1248    */
1249   keydown(event) {
1250     if (!this.isShiftKeyDown && event.key === "Shift") {
1251       this.isShiftKeyDown = true;
1252     }
1253     if (!this.isEditorHandlingKeyboard) {
1254       AnnotationEditorUIManager._keyboardManager.exec(this, event);
1255     }
1256   }
1257 
1258   /**
1259    * Keyup callback.
1260    * @param {KeyboardEvent} event
1261    */
1262   keyup(event) {
1263     if (this.isShiftKeyDown && event.key === "Shift") {
1264       this.isShiftKeyDown = false;
1265       if (this.#highlightWhenShiftUp) {
1266         this.#highlightWhenShiftUp = false;
1267         this.highlightSelection("main_toolbar");
1268       }
1269     }
1270   }
1271 
1272   /**
1273    * Execute an action for a given name.
1274    * For example, the user can click on the "Undo" entry in the context menu
1275    * and it'll trigger the undo action.
1276    */
1277   onEditingAction({ name }) {
1278     switch (name) {
1279       case "undo":
1280       case "redo":
1281       case "delete":
1282       case "selectAll":
1283         this[name]();
1284         break;
1285       case "highlightSelection":
1286         this.highlightSelection("context_menu");
1287         break;
1288     }
1289   }
1290 
1291   /**
1292    * Update the different possible states of this manager, e.g. is there
1293    * something to undo, redo, ...
1294    * @param {Object} details
1295    */
1296   #dispatchUpdateStates(details) {
1297     const hasChanged = Object.entries(details).some(
1298       ([key, value]) => this.#previousStates[key] !== value
1299     );
1300 
1301     if (hasChanged) {
1302       this._eventBus.dispatch("annotationeditorstateschanged", {
1303         source: this,
1304         details: Object.assign(this.#previousStates, details),
1305       });
1306       // We could listen on our own event but it sounds like a bit weird and
1307       // it's a way to simpler to handle that stuff here instead of having to
1308       // add something in every place where an editor can be unselected.
1309       if (
1310         this.#mode === AnnotationEditorType.HIGHLIGHT &&
1311         details.hasSelectedEditor === false
1312       ) {
1313         this.#dispatchUpdateUI([
1314           [AnnotationEditorParamsType.HIGHLIGHT_FREE, true],
1315         ]);
1316       }
1317     }
1318   }
1319 
1320   #dispatchUpdateUI(details) {
1321     this._eventBus.dispatch("annotationeditorparamschanged", {
1322       source: this,
1323       details,
1324     });
1325   }
1326 
1327   /**
1328    * Set the editing state.
1329    * It can be useful to temporarily disable it when the user is editing a
1330    * FreeText annotation.
1331    * @param {boolean} isEditing
1332    */
1333   setEditingState(isEditing) {
1334     if (isEditing) {
1335       this.#addFocusManager();
1336       this.#addKeyboardManager();
1337       this.#addCopyPasteListeners();
1338       this.#dispatchUpdateStates({
1339         isEditing: this.#mode !== AnnotationEditorType.NONE,
1340         isEmpty: this.#isEmpty(),
1341         hasSomethingToUndo: this.#commandManager.hasSomethingToUndo(),
1342         hasSomethingToRedo: this.#commandManager.hasSomethingToRedo(),
1343         hasSelectedEditor: false,
1344       });
1345     } else {
1346       this.#removeFocusManager();
1347       this.#removeKeyboardManager();
1348       this.#removeCopyPasteListeners();
1349       this.#dispatchUpdateStates({
1350         isEditing: false,
1351       });
1352       this.disableUserSelect(false);
1353     }
1354   }
1355 
1356   registerEditorTypes(types) {
1357     if (this.#editorTypes) {
1358       return;
1359     }
1360     this.#editorTypes = types;
1361     for (const editorType of this.#editorTypes) {
1362       this.#dispatchUpdateUI(editorType.defaultPropertiesToUpdate);
1363     }
1364   }
1365 
1366   /**
1367    * Get an id.
1368    * @returns {string}
1369    */
1370   getId() {
1371     return this.#idManager.id;
1372   }
1373 
1374   get currentLayer() {
1375     return this.#allLayers.get(this.#currentPageIndex);
1376   }
1377 
1378   getLayer(pageIndex) {
1379     return this.#allLayers.get(pageIndex);
1380   }
1381 
1382   get currentPageIndex() {
1383     return this.#currentPageIndex;
1384   }
1385 
1386   /**
1387    * Add a new layer for a page which will contains the editors.
1388    * @param {AnnotationEditorLayer} layer
1389    */
1390   addLayer(layer) {
1391     this.#allLayers.set(layer.pageIndex, layer);
1392     if (this.#isEnabled) {
1393       layer.enable();
1394     } else {
1395       layer.disable();
1396     }
1397   }
1398 
1399   /**
1400    * Remove a layer.
1401    * @param {AnnotationEditorLayer} layer
1402    */
1403   removeLayer(layer) {
1404     this.#allLayers.delete(layer.pageIndex);
1405   }
1406 
1407   /**
1408    * Change the editor mode (None, FreeText, Ink, ...)
1409    * @param {number} mode
1410    * @param {string|null} editId
1411    * @param {boolean} [isFromKeyboard] - true if the mode change is due to a
1412    *   keyboard action.
1413    */
1414   updateMode(mode, editId = null, isFromKeyboard = false) {
1415     if (this.#mode === mode) {
1416       return;
1417     }
1418     this.#mode = mode;
1419     if (mode === AnnotationEditorType.NONE) {
1420       this.setEditingState(false);
1421       this.#disableAll();
1422       return;
1423     }
1424     this.setEditingState(true);
1425     this.#enableAll();
1426     this.unselectAll();
1427     for (const layer of this.#allLayers.values()) {
1428       layer.updateMode(mode);
1429     }
1430     if (!editId && isFromKeyboard) {
1431       this.addNewEditorFromKeyboard();
1432       return;
1433     }
1434 
1435     if (!editId) {
1436       return;
1437     }
1438     for (const editor of this.#allEditors.values()) {
1439       if (editor.annotationElementId === editId) {
1440         this.setSelected(editor);
1441         editor.enterInEditMode();
1442         break;
1443       }
1444     }
1445   }
1446 
1447   addNewEditorFromKeyboard() {
1448     if (this.currentLayer.canCreateNewEmptyEditor()) {
1449       this.currentLayer.addNewEditor();
1450     }
1451   }
1452 
1453   /**
1454    * Update the toolbar if it's required to reflect the tool currently used.
1455    * @param {number} mode
1456    * @returns {undefined}
1457    */
1458   updateToolbar(mode) {
1459     if (mode === this.#mode) {
1460       return;
1461     }
1462     this._eventBus.dispatch("switchannotationeditormode", {
1463       source: this,
1464       mode,
1465     });
1466   }
1467 
1468   /**
1469    * Update a parameter in the current editor or globally.
1470    * @param {number} type
1471    * @param {*} value
1472    */
1473   updateParams(type, value) {
1474     if (!this.#editorTypes) {
1475       return;
1476     }
1477 
1478     switch (type) {
1479       case AnnotationEditorParamsType.CREATE:
1480         this.currentLayer.addNewEditor();
1481         return;
1482       case AnnotationEditorParamsType.HIGHLIGHT_DEFAULT_COLOR:
1483         this.#mainHighlightColorPicker?.updateColor(value);
1484         break;
1485       case AnnotationEditorParamsType.HIGHLIGHT_SHOW_ALL:
1486         this._eventBus.dispatch("reporttelemetry", {
1487           source: this,
1488           details: {
1489             type: "editing",
1490             data: {
1491               type: "highlight",
1492               action: "toggle_visibility",
1493             },
1494           },
1495         });
1496         (this.#showAllStates ||= new Map()).set(type, value);
1497         this.showAllEditors("highlight", value);
1498         break;
1499     }
1500 
1501     for (const editor of this.#selectedEditors) {
1502       editor.updateParams(type, value);
1503     }
1504 
1505     for (const editorType of this.#editorTypes) {
1506       editorType.updateDefaultParams(type, value);
1507     }
1508   }
1509 
1510   showAllEditors(type, visible, updateButton = false) {
1511     for (const editor of this.#allEditors.values()) {
1512       if (editor.editorType === type) {
1513         editor.show(visible);
1514       }
1515     }
1516     const state =
1517       this.#showAllStates?.get(AnnotationEditorParamsType.HIGHLIGHT_SHOW_ALL) ??
1518       true;
1519     if (state !== visible) {
1520       this.#dispatchUpdateUI([
1521         [AnnotationEditorParamsType.HIGHLIGHT_SHOW_ALL, visible],
1522       ]);
1523     }
1524   }
1525 
1526   enableWaiting(mustWait = false) {
1527     if (this.#isWaiting === mustWait) {
1528       return;
1529     }
1530     this.#isWaiting = mustWait;
1531     for (const layer of this.#allLayers.values()) {
1532       if (mustWait) {
1533         layer.disableClick();
1534       } else {
1535         layer.enableClick();
1536       }
1537       layer.div.classList.toggle("waiting", mustWait);
1538     }
1539   }
1540 
1541   /**
1542    * Enable all the layers.
1543    */
1544   #enableAll() {
1545     if (!this.#isEnabled) {
1546       this.#isEnabled = true;
1547       for (const layer of this.#allLayers.values()) {
1548         layer.enable();
1549       }
1550     }
1551   }
1552 
1553   /**
1554    * Disable all the layers.
1555    */
1556   #disableAll() {
1557     this.unselectAll();
1558     if (this.#isEnabled) {
1559       this.#isEnabled = false;
1560       for (const layer of this.#allLayers.values()) {
1561         layer.disable();
1562       }
1563     }
1564   }
1565 
1566   /**
1567    * Get all the editors belonging to a given page.
1568    * @param {number} pageIndex
1569    * @returns {Array<AnnotationEditor>}
1570    */
1571   getEditors(pageIndex) {
1572     const editors = [];
1573     for (const editor of this.#allEditors.values()) {
1574       if (editor.pageIndex === pageIndex) {
1575         editors.push(editor);
1576       }
1577     }
1578     return editors;
1579   }
1580 
1581   /**
1582    * Get an editor with the given id.
1583    * @param {string} id
1584    * @returns {AnnotationEditor}
1585    */
1586   getEditor(id) {
1587     return this.#allEditors.get(id);
1588   }
1589 
1590   /**
1591    * Add a new editor.
1592    * @param {AnnotationEditor} editor
1593    */
1594   addEditor(editor) {
1595     this.#allEditors.set(editor.id, editor);
1596   }
1597 
1598   /**
1599    * Remove an editor.
1600    * @param {AnnotationEditor} editor
1601    */
1602   removeEditor(editor) {
1603     if (editor.div.contains(document.activeElement)) {
1604       if (this.#focusMainContainerTimeoutId) {
1605         clearTimeout(this.#focusMainContainerTimeoutId);
1606       }
1607       this.#focusMainContainerTimeoutId = setTimeout(() => {
1608         // When the div is removed from DOM the focus can move on the
1609         // document.body, so we need to move it back to the main container.
1610         this.focusMainContainer();
1611         this.#focusMainContainerTimeoutId = null;
1612       }, 0);
1613     }
1614     this.#allEditors.delete(editor.id);
1615     this.unselect(editor);
1616     if (
1617       !editor.annotationElementId ||
1618       !this.#deletedAnnotationsElementIds.has(editor.annotationElementId)
1619     ) {
1620       this.#annotationStorage?.remove(editor.id);
1621     }
1622   }
1623 
1624   /**
1625    * The annotation element with the given id has been deleted.
1626    * @param {AnnotationEditor} editor
1627    */
1628   addDeletedAnnotationElement(editor) {
1629     this.#deletedAnnotationsElementIds.add(editor.annotationElementId);
1630     editor.deleted = true;
1631   }
1632 
1633   /**
1634    * Check if the annotation element with the given id has been deleted.
1635    * @param {string} annotationElementId
1636    * @returns {boolean}
1637    */
1638   isDeletedAnnotationElement(annotationElementId) {
1639     return this.#deletedAnnotationsElementIds.has(annotationElementId);
1640   }
1641 
1642   /**
1643    * The annotation element with the given id have been restored.
1644    * @param {AnnotationEditor} editor
1645    */
1646   removeDeletedAnnotationElement(editor) {
1647     this.#deletedAnnotationsElementIds.delete(editor.annotationElementId);
1648     editor.deleted = false;
1649   }
1650 
1651   /**
1652    * Add an editor to the layer it belongs to or add it to the global map.
1653    * @param {AnnotationEditor} editor
1654    */
1655   #addEditorToLayer(editor) {
1656     const layer = this.#allLayers.get(editor.pageIndex);
1657     if (layer) {
1658       layer.addOrRebuild(editor);
1659     } else {
1660       this.addEditor(editor);
1661     }
1662   }
1663 
1664   /**
1665    * Set the given editor as the active one.
1666    * @param {AnnotationEditor} editor
1667    */
1668   setActiveEditor(editor) {
1669     if (this.#activeEditor === editor) {
1670       return;
1671     }
1672 
1673     this.#activeEditor = editor;
1674     if (editor) {
1675       this.#dispatchUpdateUI(editor.propertiesToUpdate);
1676     }
1677   }
1678 
1679   get #lastSelectedEditor() {
1680     let ed = null;
1681     for (ed of this.#selectedEditors) {
1682       // Iterate to get the last element.
1683     }
1684     return ed;
1685   }
1686 
1687   /**
1688    * Update the UI of the active editor.
1689    * @param {AnnotationEditor} editor
1690    */
1691   updateUI(editor) {
1692     if (this.#lastSelectedEditor === editor) {
1693       this.#dispatchUpdateUI(editor.propertiesToUpdate);
1694     }
1695   }
1696 
1697   /**
1698    * Add or remove an editor the current selection.
1699    * @param {AnnotationEditor} editor
1700    */
1701   toggleSelected(editor) {
1702     if (this.#selectedEditors.has(editor)) {
1703       this.#selectedEditors.delete(editor);
1704       editor.unselect();
1705       this.#dispatchUpdateStates({
1706         hasSelectedEditor: this.hasSelection,
1707       });
1708       return;
1709     }
1710     this.#selectedEditors.add(editor);
1711     editor.select();
1712     this.#dispatchUpdateUI(editor.propertiesToUpdate);
1713     this.#dispatchUpdateStates({
1714       hasSelectedEditor: true,
1715     });
1716   }
1717 
1718   /**
1719    * Set the last selected editor.
1720    * @param {AnnotationEditor} editor
1721    */
1722   setSelected(editor) {
1723     for (const ed of this.#selectedEditors) {
1724       if (ed !== editor) {
1725         ed.unselect();
1726       }
1727     }
1728     this.#selectedEditors.clear();
1729 
1730     this.#selectedEditors.add(editor);
1731     editor.select();
1732     this.#dispatchUpdateUI(editor.propertiesToUpdate);
1733     this.#dispatchUpdateStates({
1734       hasSelectedEditor: true,
1735     });
1736   }
1737 
1738   /**
1739    * Check if the editor is selected.
1740    * @param {AnnotationEditor} editor
1741    */
1742   isSelected(editor) {
1743     return this.#selectedEditors.has(editor);
1744   }
1745 
1746   get firstSelectedEditor() {
1747     return this.#selectedEditors.values().next().value;
1748   }
1749 
1750   /**
1751    * Unselect an editor.
1752    * @param {AnnotationEditor} editor
1753    */
1754   unselect(editor) {
1755     editor.unselect();
1756     this.#selectedEditors.delete(editor);
1757     this.#dispatchUpdateStates({
1758       hasSelectedEditor: this.hasSelection,
1759     });
1760   }
1761 
1762   get hasSelection() {
1763     return this.#selectedEditors.size !== 0;
1764   }
1765 
1766   get isEnterHandled() {
1767     return (
1768       this.#selectedEditors.size === 1 &&
1769       this.firstSelectedEditor.isEnterHandled
1770     );
1771   }
1772 
1773   /**
1774    * Undo the last command.
1775    */
1776   undo() {
1777     this.#commandManager.undo();
1778     this.#dispatchUpdateStates({
1779       hasSomethingToUndo: this.#commandManager.hasSomethingToUndo(),
1780       hasSomethingToRedo: true,
1781       isEmpty: this.#isEmpty(),
1782     });
1783   }
1784 
1785   /**
1786    * Redo the last undoed command.
1787    */
1788   redo() {
1789     this.#commandManager.redo();
1790     this.#dispatchUpdateStates({
1791       hasSomethingToUndo: true,
1792       hasSomethingToRedo: this.#commandManager.hasSomethingToRedo(),
1793       isEmpty: this.#isEmpty(),
1794     });
1795   }
1796 
1797   /**
1798    * Add a command to execute (cmd) and another one to undo it.
1799    * @param {Object} params
1800    */
1801   addCommands(params) {
1802     this.#commandManager.add(params);
1803     this.#dispatchUpdateStates({
1804       hasSomethingToUndo: true,
1805       hasSomethingToRedo: false,
1806       isEmpty: this.#isEmpty(),
1807     });
1808   }
1809 
1810   #isEmpty() {
1811     if (this.#allEditors.size === 0) {
1812       return true;
1813     }
1814 
1815     if (this.#allEditors.size === 1) {
1816       for (const editor of this.#allEditors.values()) {
1817         return editor.isEmpty();
1818       }
1819     }
1820 
1821     return false;
1822   }
1823 
1824   /**
1825    * Delete the current editor or all.
1826    */
1827   delete() {
1828     this.commitOrRemove();
1829     if (!this.hasSelection) {
1830       return;
1831     }
1832 
1833     const editors = [...this.#selectedEditors];
1834     const cmd = () => {
1835       for (const editor of editors) {
1836         editor.remove();
1837       }
1838     };
1839     const undo = () => {
1840       for (const editor of editors) {
1841         this.#addEditorToLayer(editor);
1842       }
1843     };
1844 
1845     this.addCommands({ cmd, undo, mustExec: true });
1846   }
1847 
1848   commitOrRemove() {
1849     // An editor is being edited so just commit it.
1850     this.#activeEditor?.commitOrRemove();
1851   }
1852 
1853   hasSomethingToControl() {
1854     return this.#activeEditor || this.hasSelection;
1855   }
1856 
1857   /**
1858    * Select the editors.
1859    * @param {Array<AnnotationEditor>} editors
1860    */
1861   #selectEditors(editors) {
1862     for (const editor of this.#selectedEditors) {
1863       editor.unselect();
1864     }
1865     this.#selectedEditors.clear();
1866     for (const editor of editors) {
1867       if (editor.isEmpty()) {
1868         continue;
1869       }
1870       this.#selectedEditors.add(editor);
1871       editor.select();
1872     }
1873     this.#dispatchUpdateStates({ hasSelectedEditor: this.hasSelection });
1874   }
1875 
1876   /**
1877    * Select all the editors.
1878    */
1879   selectAll() {
1880     for (const editor of this.#selectedEditors) {
1881       editor.commit();
1882     }
1883     this.#selectEditors(this.#allEditors.values());
1884   }
1885 
1886   /**
1887    * Unselect all the selected editors.
1888    */
1889   unselectAll() {
1890     if (this.#activeEditor) {
1891       // An editor is being edited so just commit it.
1892       this.#activeEditor.commitOrRemove();
1893       if (this.#mode !== AnnotationEditorType.NONE) {
1894         // If the mode is NONE, we want to really unselect the editor, hence we
1895         // mustn't return here.
1896         return;
1897       }
1898     }
1899 
1900     if (!this.hasSelection) {
1901       return;
1902     }
1903     for (const editor of this.#selectedEditors) {
1904       editor.unselect();
1905     }
1906     this.#selectedEditors.clear();
1907     this.#dispatchUpdateStates({
1908       hasSelectedEditor: false,
1909     });
1910   }
1911 
1912   translateSelectedEditors(x, y, noCommit = false) {
1913     if (!noCommit) {
1914       this.commitOrRemove();
1915     }
1916     if (!this.hasSelection) {
1917       return;
1918     }
1919 
1920     this.#translation[0] += x;
1921     this.#translation[1] += y;
1922     const [totalX, totalY] = this.#translation;
1923     const editors = [...this.#selectedEditors];
1924 
1925     // We don't want to have an undo/redo for each translation so we wait a bit
1926     // before adding the command to the command manager.
1927     const TIME_TO_WAIT = 1000;
1928 
1929     if (this.#translationTimeoutId) {
1930       clearTimeout(this.#translationTimeoutId);
1931     }
1932 
1933     this.#translationTimeoutId = setTimeout(() => {
1934       this.#translationTimeoutId = null;
1935       this.#translation[0] = this.#translation[1] = 0;
1936 
1937       this.addCommands({
1938         cmd: () => {
1939           for (const editor of editors) {
1940             if (this.#allEditors.has(editor.id)) {
1941               editor.translateInPage(totalX, totalY);
1942             }
1943           }
1944         },
1945         undo: () => {
1946           for (const editor of editors) {
1947             if (this.#allEditors.has(editor.id)) {
1948               editor.translateInPage(-totalX, -totalY);
1949             }
1950           }
1951         },
1952         mustExec: false,
1953       });
1954     }, TIME_TO_WAIT);
1955 
1956     for (const editor of editors) {
1957       editor.translateInPage(x, y);
1958     }
1959   }
1960 
1961   /**
1962    * Set up the drag session for moving the selected editors.
1963    */
1964   setUpDragSession() {
1965     // Note: don't use any references to the editor's parent which can be null
1966     // if the editor belongs to a destroyed page.
1967     if (!this.hasSelection) {
1968       return;
1969     }
1970     // Avoid to have spurious text selection in the text layer when dragging.
1971     this.disableUserSelect(true);
1972     this.#draggingEditors = new Map();
1973     for (const editor of this.#selectedEditors) {
1974       this.#draggingEditors.set(editor, {
1975         savedX: editor.x,
1976         savedY: editor.y,
1977         savedPageIndex: editor.pageIndex,
1978         newX: 0,
1979         newY: 0,
1980         newPageIndex: -1,
1981       });
1982     }
1983   }
1984 
1985   /**
1986    * Ends the drag session.
1987    * @returns {boolean} true if at least one editor has been moved.
1988    */
1989   endDragSession() {
1990     if (!this.#draggingEditors) {
1991       return false;
1992     }
1993     this.disableUserSelect(false);
1994     const map = this.#draggingEditors;
1995     this.#draggingEditors = null;
1996     let mustBeAddedInUndoStack = false;
1997 
1998     for (const [{ x, y, pageIndex }, value] of map) {
1999       value.newX = x;
2000       value.newY = y;
2001       value.newPageIndex = pageIndex;
2002       mustBeAddedInUndoStack ||=
2003         x !== value.savedX ||
2004         y !== value.savedY ||
2005         pageIndex !== value.savedPageIndex;
2006     }
2007 
2008     if (!mustBeAddedInUndoStack) {
2009       return false;
2010     }
2011 
2012     const move = (editor, x, y, pageIndex) => {
2013       if (this.#allEditors.has(editor.id)) {
2014         // The editor can be undone/redone on a page which is not visible (and
2015         // which potentially has no annotation editor layer), hence we need to
2016         // use the pageIndex instead of the parent.
2017         const parent = this.#allLayers.get(pageIndex);
2018         if (parent) {
2019           editor._setParentAndPosition(parent, x, y);
2020         } else {
2021           editor.pageIndex = pageIndex;
2022           editor.x = x;
2023           editor.y = y;
2024         }
2025       }
2026     };
2027 
2028     this.addCommands({
2029       cmd: () => {
2030         for (const [editor, { newX, newY, newPageIndex }] of map) {
2031           move(editor, newX, newY, newPageIndex);
2032         }
2033       },
2034       undo: () => {
2035         for (const [editor, { savedX, savedY, savedPageIndex }] of map) {
2036           move(editor, savedX, savedY, savedPageIndex);
2037         }
2038       },
2039       mustExec: true,
2040     });
2041 
2042     return true;
2043   }
2044 
2045   /**
2046    * Drag the set of selected editors.
2047    * @param {number} tx
2048    * @param {number} ty
2049    */
2050   dragSelectedEditors(tx, ty) {
2051     if (!this.#draggingEditors) {
2052       return;
2053     }
2054     for (const editor of this.#draggingEditors.keys()) {
2055       editor.drag(tx, ty);
2056     }
2057   }
2058 
2059   /**
2060    * Rebuild the editor (usually on undo/redo actions) on a potentially
2061    * non-rendered page.
2062    * @param {AnnotationEditor} editor
2063    */
2064   rebuild(editor) {
2065     if (editor.parent === null) {
2066       const parent = this.getLayer(editor.pageIndex);
2067       if (parent) {
2068         parent.changeParent(editor);
2069         parent.addOrRebuild(editor);
2070       } else {
2071         this.addEditor(editor);
2072         this.addToAnnotationStorage(editor);
2073         editor.rebuild();
2074       }
2075     } else {
2076       editor.parent.addOrRebuild(editor);
2077     }
2078   }
2079 
2080   get isEditorHandlingKeyboard() {
2081     return (
2082       this.getActive()?.shouldGetKeyboardEvents() ||
2083       (this.#selectedEditors.size === 1 &&
2084         this.firstSelectedEditor.shouldGetKeyboardEvents())
2085     );
2086   }
2087 
2088   /**
2089    * Is the current editor the one passed as argument?
2090    * @param {AnnotationEditor} editor
2091    * @returns
2092    */
2093   isActive(editor) {
2094     return this.#activeEditor === editor;
2095   }
2096 
2097   /**
2098    * Get the current active editor.
2099    * @returns {AnnotationEditor|null}
2100    */
2101   getActive() {
2102     return this.#activeEditor;
2103   }
2104 
2105   /**
2106    * Get the current editor mode.
2107    * @returns {number}
2108    */
2109   getMode() {
2110     return this.#mode;
2111   }
2112 
2113   get imageManager() {
2114     return shadow(this, "imageManager", new ImageManager());
2115   }
2116 
2117   getSelectionBoxes(textLayer) {
2118     if (!textLayer) {
2119       return null;
2120     }
2121     const selection = document.getSelection();
2122     for (let i = 0, ii = selection.rangeCount; i < ii; i++) {
2123       if (
2124         !textLayer.contains(selection.getRangeAt(i).commonAncestorContainer)
2125       ) {
2126         return null;
2127       }
2128     }
2129 
2130     const {
2131       x: layerX,
2132       y: layerY,
2133       width: parentWidth,
2134       height: parentHeight,
2135     } = textLayer.getBoundingClientRect();
2136 
2137     // We must rotate the boxes because we want to have them in the non-rotated
2138     // page coordinates.
2139     let rotator;
2140     switch (textLayer.getAttribute("data-main-rotation")) {
2141       case "90":
2142         rotator = (x, y, w, h) => ({
2143           x: (y - layerY) / parentHeight,
2144           y: 1 - (x + w - layerX) / parentWidth,
2145           width: h / parentHeight,
2146           height: w / parentWidth,
2147         });
2148         break;
2149       case "180":
2150         rotator = (x, y, w, h) => ({
2151           x: 1 - (x + w - layerX) / parentWidth,
2152           y: 1 - (y + h - layerY) / parentHeight,
2153           width: w / parentWidth,
2154           height: h / parentHeight,
2155         });
2156         break;
2157       case "270":
2158         rotator = (x, y, w, h) => ({
2159           x: 1 - (y + h - layerY) / parentHeight,
2160           y: (x - layerX) / parentWidth,
2161           width: h / parentHeight,
2162           height: w / parentWidth,
2163         });
2164         break;
2165       default:
2166         rotator = (x, y, w, h) => ({
2167           x: (x - layerX) / parentWidth,
2168           y: (y - layerY) / parentHeight,
2169           width: w / parentWidth,
2170           height: h / parentHeight,
2171         });
2172         break;
2173     }
2174 
2175     const boxes = [];
2176     for (let i = 0, ii = selection.rangeCount; i < ii; i++) {
2177       const range = selection.getRangeAt(i);
2178       if (range.collapsed) {
2179         continue;
2180       }
2181       for (const { x, y, width, height } of range.getClientRects()) {
2182         if (width === 0 || height === 0) {
2183           continue;
2184         }
2185         boxes.push(rotator(x, y, width, height));
2186       }
2187     }
2188     return boxes.length === 0 ? null : boxes;
2189   }
2190 }
2191 
2192 export {
2193   AnnotationEditorUIManager,
2194   bindEvents,
2195   ColorManager,
2196   CommandManager,
2197   KeyboardManager,
2198   opacityToHex,
2199 };
</code>

Your task:
You are a software tester at pdf.js.
1. Write exactly one javascript test `it("...", async () => {...})` block.
2. Your test must fail on the code before the patch, and pass after, hence the test will verify that the patch resolves the issue.
3. The test must be self-contained and to-the-point.
4. Use only the provided imports (respect the paths exactly how they are given) by importing dynamically for compatibility with Node.js — no new dependencies. 
5. Return only the javascript code (no comments or explanations).

Example structure:
it("should <describe behavior>", async () => {
  const { example } = await import("../../src/core/example.js");
  <initialize required variables>;
  <define expected variable>;
  <generate actual variables>;
  <compare expected with actual>;
});

