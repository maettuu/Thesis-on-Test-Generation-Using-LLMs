Before you begin:
- Keep going until the job is completely solved — don’t stop halfway.
- If you’re unsure about the behavior, reread the provided patch carefully; do not hallucinate.
- Plan your approach before writing code by reflecting on whether the test truly fails before and passes after.

Issue:
<issue>
[Bug]: PDF causes TypeError and doesn't fully render.
### Attach (recommended) or Link to PDF file

[\[QAID-481\]-test3-01-bug.pdf](https://github.com/user-attachments/files/20409577/QAID-481.-test3-01-bug.pdf)

### Web browser and its version

Chrome 137.0.7151.41 (Official Build) (arm64)

### Operating system and its version

macOS 15.4.1 (24E263)

### PDF.js version

PDF 110dd61fd57444010b1ab5ff38782f0f [1.4 pdfeTeX-1.21a / TeX] (PDF.js: 5.3.17 [a8e05d82e])

### Is the bug present in the latest PDF.js version?

Yes

### Is a browser extension

No

### Steps to reproduce the problem

1. Open the provided PDF with the online demo.
2. Warnings appear in the browser console, and the PDF rendering is incomplete when compared to Preview or Adobe Acrobat Reader.

Incomplete rendering in PDF.js:

<img width="1724" alt="Image" src="https://github.com/user-attachments/assets/2fd84dee-b290-4ea1-a244-1f8091bb21bb" />

### What is the expected behavior?

It looks like this in Preview or Adobe Acrobat:

<img width="1413" alt="Image" src="https://github.com/user-attachments/assets/cd41ede8-3212-4118-a213-03f8f9b25738" />

### What went wrong?

Incomplete rendering.

### Link to a viewer

_No response_

### Additional context

_No response_
</issue>

Patch:
<patch>
diff --git a/src/core/operator_list.js b/src/core/operator_list.js
--- a/src/core/operator_list.js
+++ b/src/core/operator_list.js
@@ -519,18 +519,20 @@ addState(
     const transform = argsArray[iFirstTransform];
     const [, [buffer], minMax] = args;
 
-    Util.scaleMinMax(transform, minMax);
-    for (let k = 0, kk = buffer.length; k < kk; ) {
-      switch (buffer[k++]) {
-        case DrawOPS.moveTo:
-        case DrawOPS.lineTo:
-          Util.applyTransform(buffer, transform, k);
-          k += 2;
-          break;
-        case DrawOPS.curveTo:
-          Util.applyTransformToBezier(buffer, transform, k);
-          k += 6;
-          break;
+    if (minMax) {
+      Util.scaleMinMax(transform, minMax);
+      for (let k = 0, kk = buffer.length; k < kk; ) {
+        switch (buffer[k++]) {
+          case DrawOPS.moveTo:
+          case DrawOPS.lineTo:
+            Util.applyTransform(buffer, transform, k);
+            k += 2;
+            break;
+          case DrawOPS.curveTo:
+            Util.applyTransformToBezier(buffer, transform, k);
+            k += 6;
+            break;
+        }
       }
     }
     // Replace queue items.


</patch>

Imports:
<imports>
Available Packages
Dev Dependencies:
- @babel/core: ^7.27.1
- @babel/preset-env: ^7.27.2
- @babel/runtime: ^7.27.1
- @csstools/postcss-light-dark-function: ^2.0.8
- @fluent/bundle: ^0.19.1
- @fluent/dom: ^0.10.1
- @metalsmith/layouts: ^3.0.0
- @metalsmith/markdown: ^1.10.0
- @napi-rs/canvas: ^0.1.70
- @types/node: ^22.15.18
- autoprefixer: ^10.4.21
- babel-loader: ^10.0.0
- caniuse-lite: ^1.0.30001718
- core-js: ^3.42.0
- eslint: ^9.27.0
- eslint-plugin-import: ^2.31.0
- eslint-plugin-jasmine: ^4.2.2
- eslint-plugin-json: ^4.0.1
- eslint-plugin-no-unsanitized: ^4.1.2
- eslint-plugin-perfectionist: ^4.13.0
- eslint-plugin-prettier: ^5.4.0
- eslint-plugin-unicorn: ^59.0.1
- globals: ^16.1.0
- gulp: ^5.0.0
- gulp-cli: ^3.0.0
- gulp-postcss: ^10.0.0
- gulp-rename: ^2.0.0
- gulp-replace: ^1.1.4
- gulp-zip: ^6.1.0
- highlight.js: ^11.11.1
- jasmine: ^5.7.1
- jsdoc: ^4.0.4
- jstransformer-nunjucks: ^1.2.0
- metalsmith: ^2.6.3
- metalsmith-html-relative: ^2.0.6
- ordered-read-streams: ^2.0.0
- pngjs: ^7.0.0
- postcss: ^8.5.3
- postcss-dir-pseudo-class: ^9.0.1
- postcss-discard-comments: ^7.0.4
- postcss-nesting: ^13.0.1
- prettier: ^3.5.3
- puppeteer: ^24.8.2
- stylelint: ^16.19.1
- stylelint-prettier: ^5.0.3
- svglint: ^3.1.0
- terser-webpack-plugin: ^5.3.14
- tsc-alias: ^1.8.16
- ttest: ^4.0.0
- typescript: ^5.8.3
- vinyl: ^3.0.0
- webpack: ^5.99.8
- webpack-stream: ^7.0.0
- yargs: ^17.7.2

Engines:
- node: >=20.16.0 || >=22.3.0

Available Relative Imports:
- `../../src/core/annotation.js`: Annotation, AnnotationBorderStyle, AnnotationFactory, MarkupAnnotation, getQuadPoints
- `../../src/core/bidi.js`: bidi
- `../../src/core/calculate_md5.js`: calculateMD5
- `../../src/core/calculate_sha256.js`: calculateSHA256
- `../../src/core/calculate_sha_other.js`: calculateSHA384, calculateSHA512
- `../../src/core/cff_parser.js`: CFFCharset, CFFCompiler, CFFFDSelect, CFFParser, CFFStrings
- `../../src/core/cmap.js`: CMap, CMapFactory, IdentityCMap
- `../../src/core/colorspace.js`: ColorSpace
- `../../src/core/colorspace_utils.js`: ColorSpaceUtils
- `../../src/core/core_utils.js`: arrayBuffersToBytes, encodeToXmlString, escapePDFName, escapeString, getInheritableProperty, getSizeInBytes, isAscii, isWhiteSpace, log2, numberToString, parseXFAPath, recoverJsURL, stringToUTF16HexString, stringToUTF16String, toRomanNumerals, validateCSSFont
- `../../src/core/crypto.js`: AES128Cipher, AES256Cipher, ARCFourCipher, CipherTransformFactory, PDF17, PDF20
- `../../src/core/default_appearance.js`: createDefaultAppearance, parseAppearanceStream, parseDefaultAppearance
- `../../src/core/document.js`: PDFDocument, Page
- `../../src/core/encodings.js`: getEncoding
- `../../src/core/evaluator.js`: PartialEvaluator
- `../../src/core/flate_stream.js`: FlateStream
- `../../src/core/font_substitutions.js`: getFontSubstitution
- `../../src/core/fonts_utils.js`: SEAC_ANALYSIS_ENABLED
- `../../src/core/function.js`: PDFFunctionFactory, PostScriptCompiler, PostScriptEvaluator
- `../../src/core/glyphlist.js`: getDingbatsGlyphsUnicode, getGlyphsUnicode
- `../../src/core/image_utils.js`: GlobalColorSpaceCache, GlobalImageCache, LocalColorSpaceCache
- `../../src/core/jbig2.js`: Jbig2Error, Jbig2Image
- `../../src/core/jpg.js`: JpegError, JpegImage
- `../../src/core/jpx.js`: JpxError, JpxImage
- `../../src/core/metadata_parser.js`: MetadataParser
- `../../src/core/operator_list.js`: OperatorList
- `../../src/core/parser.js`: Lexer, Linearization, Parser
- `../../src/core/predictor_stream.js`: PredictorStream
- `../../src/core/primitives.js`: Cmd, Dict, EOF, Name, Ref, RefSet, RefSetCache, isCmd, isDict, isName, isRefsEqual
- `../../src/core/ps_parser.js`: PostScriptLexer, PostScriptParser
- `../../src/core/stream.js`: NullStream, Stream, StringStream
- `../../src/core/type1_parser.js`: Type1Parser
- `../../src/core/unicode.js`: getCharUnicodeCategory, getUnicodeForGlyph, getUnicodeRangeFor, mapSpecialUnicodeValues
- `../../src/core/worker.js`: WorkerMessageHandler, WorkerTask
- `../../src/core/writer.js`: incrementalUpdate, writeChanges, writeDict
- `../../src/core/xfa/bind.js`: Binder
- `../../src/core/xfa/data.js`: DataHandler
- `../../src/core/xfa/factory.js`: XFAFactory
- `../../src/core/xfa/formcalc_lexer.js`: Lexer, TOKEN, Token
- `../../src/core/xfa/formcalc_parser.js`: Errors, Parser
- `../../src/core/xfa/parser.js`: XFAParser
- `../../src/core/xfa/som.js`: searchNode
- `../../src/core/xfa/symbol_utils.js`: $dump, $getChildren, $getChildrenByClass, $getChildrenByName, $text, $uid
- `../../src/core/xml_parser.js`: SimpleXMLParser, XMLParserBase
- `../../src/display/annotation_layer.js`: AnnotationLayer
- `../../src/display/annotation_storage.js`: AnnotationStorage
- `../../src/display/api.js`: LoopbackPort, PDFDataRangeTransport, PDFDocumentLoadingTask, PDFDocumentProxy, PDFPageProxy, PDFWorker, RenderTask, build, getDocument, isValidExplicitDest, version
- `../../src/display/canvas_factory.js`: DOMCanvasFactory
- `../../src/display/cmap_reader_factory.js`: DOMCMapReaderFactory
- `../../src/display/display_utils.js`: OutputScale, PDFDateString, PageViewport, PixelsPerInch, RenderingCancelledException, StatTimer, SupportedImageMimeTypes, fetchData, getFilenameFromUrl, getPdfFilenameFromUrl, getXfaPageViewport, isDataScheme, isPdfFile, isValidFetchUrl, noContextMenu, setLayerDimensions, stopEvent
- `../../src/display/draw_layer.js`: DrawLayer
- `../../src/display/editor/annotation_editor_layer.js`: AnnotationEditorLayer
- `../../src/display/editor/color_picker.js`: ColorPicker
- `../../src/display/editor/drawers/signaturedraw.js`: SignatureExtractor
- `../../src/display/editor/tools.js`: AnnotationEditorUIManager, CommandManager
- `../../src/display/fetch_stream.js`: PDFFetchStream
- `../../src/display/metadata.js`: Metadata
- `../../src/display/network.js`: PDFNetworkStream
- `../../src/display/network_utils.js`: createHeaders, createResponseError, extractFilenameFromHeader, validateRangeRequestCapabilities, validateResponseStatus
- `../../src/display/node_stream.js`: PDFNodeStream
- `../../src/display/node_utils.js`: NodeCMapReaderFactory, NodeStandardFontDataFactory, fetchData
- `../../src/display/standard_fontdata_factory.js`: DOMStandardFontDataFactory
- `../../src/display/svg_factory.js`: DOMSVGFactory
- `../../src/display/text_layer.js`: TextLayer
- `../../src/display/touch_manager.js`: TouchManager
- `../../src/display/worker_options.js`: GlobalWorkerOptions
- `../../src/display/xfa_layer.js`: XfaLayer
- `../../src/shared/message_handler.js`: MessageHandler
- `../../src/shared/murmurhash3.js`: MurmurHash3_64
- `../../src/shared/util.js`: AbortException, AnnotationBorderStyleType, AnnotationEditorParamsType, AnnotationEditorType, AnnotationFieldFlag, AnnotationFlag, AnnotationMode, AnnotationType, BaseException, DrawOPS, FeatureTest, FormatError, ImageKind, InvalidPDFException, MathClamp, OPS, PasswordException, PasswordResponses, PermissionFlag, RenderingIntentFlag, ResponseException, UnknownErrorException, Util, VerbosityLevel, assert, bytesToString, createValidAbsoluteUrl, getModificationDate, getUuid, getVerbosityLevel, isNodeJS, normalizeUnicode, objectSize, setVerbosityLevel, shadow, string32, stringToBytes, stringToPDFString, stringToUTF8String, toBase64Util, updateUrlHash
- `../../web/annotation_layer_builder.js`: AnnotationLayerBuilder
- `../../web/app_options.js`: AppOptions, OptionKind
- `../../web/autolinker.js`: Autolinker
- `../../web/download_manager.js`: DownloadManager
- `../../web/event_utils.js`: EventBus, WaitOnType, waitOnEventOrTimeout
- `../../web/genericl10n.js`: GenericL10n
- `../../web/pdf_find_controller.js`: FindState, PDFFindController
- `../../web/pdf_find_utils.js`: CharacterType, getCharacterType
- `../../web/pdf_history.js`: PDFHistory, isDestArraysEqual, isDestHashesEqual
- `../../web/pdf_link_service.js`: LinkTarget, PDFLinkService, SimpleLinkService
- `../../web/pdf_page_view.js`: PDFPageView
- `../../web/pdf_scripting_manager.component.js`: PDFScriptingManager
- `../../web/pdf_single_page_viewer.js`: PDFSinglePageViewer
- `../../web/pdf_viewer.js`: PDFPageViewBuffer, PDFViewer
- `../../web/struct_tree_layer_builder.js`: StructTreeLayerBuilder
- `../../web/text_layer_builder.js`: TextLayerBuilder
- `../../web/ui_utils.js`: AutoPrintRegExp, ProgressBar, RenderingStates, ScrollMode, SpreadMode, backtrackBeforeAllVisibleElements, binarySearchFirstItem, calcRound, getPageSizeInches, getVisibleElements, isPortraitOrientation, isValidRotation, parseQueryString, removeNullCharacters
- `../../web/xfa_layer_builder.js`: XfaLayerBuilder
- `../reporter.js`: TestReporter
- `./common_pdfstream_tests.js`: testCrossOriginRedirects
- `./test_utils.js`: CMAP_URL, DefaultCMapReaderFactory, DefaultFileReaderFactory, DefaultStandardFontDataFactory, STANDARD_FONT_DATA_URL, TEST_PDFS_PATH, TestPdfsServer, XRefMock, buildGetDocumentParams, createIdFactory, getCrossOriginHostname
</imports>

Code:
<code>
File:
src/core/operator_list.js
1 /* Copyright 2017 Mozilla Foundation
2  *
3  * Licensed under the Apache License, Version 2.0 (the "License");
4  * you may not use this file except in compliance with the License.
5  * You may obtain a copy of the License at
6  *
7  *     http://www.apache.org/licenses/LICENSE-2.0
8  *
9  * Unless required by applicable law or agreed to in writing, software
10  * distributed under the License is distributed on an "AS IS" BASIS,
11  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
12  * See the License for the specific language governing permissions and
13  * limitations under the License.
14  */
15 
16 import {
17   DrawOPS,
18   ImageKind,
19   OPS,
20   RenderingIntentFlag,
21   Util,
22   warn,
23 } from "../shared/util.js";
24 
25 function addState(parentState, pattern, checkFn, iterateFn, processFn) {
26   let state = parentState;
27   for (let i = 0, ii = pattern.length - 1; i < ii; i++) {
28     const item = pattern[i];
29     state = state[item] ||= [];
30   }
31   state[pattern.at(-1)] = {
32     checkFn,
33     iterateFn,
34     processFn,
35   };
36 }
37 
38 const InitialState = [];
39 
40 // This replaces (save, transform, paintInlineImageXObject, restore)+
41 // sequences with one |paintInlineImageXObjectGroup| operation.
42 addState(
43   InitialState,
44   [OPS.save, OPS.transform, OPS.paintInlineImageXObject, OPS.restore],
45   null,
46   function iterateInlineImageGroup(context, i) {
47     const fnArray = context.fnArray;
48     const iFirstSave = context.iCurr - 3;
49     const pos = (i - iFirstSave) % 4;
50     switch (pos) {
51       case 0:
52         return fnArray[i] === OPS.save;
53       case 1:
54         return fnArray[i] === OPS.transform;
55       case 2:
56         return fnArray[i] === OPS.paintInlineImageXObject;
57       case 3:
58         return fnArray[i] === OPS.restore;
59     }
60     throw new Error(`iterateInlineImageGroup - invalid pos: ${pos}`);
61   },
62   function foundInlineImageGroup(context, i) {
63     const MIN_IMAGES_IN_INLINE_IMAGES_BLOCK = 10;
64     const MAX_IMAGES_IN_INLINE_IMAGES_BLOCK = 200;
65     const MAX_WIDTH = 1000;
66     const IMAGE_PADDING = 1;
67 
68     const fnArray = context.fnArray,
69       argsArray = context.argsArray;
70     const curr = context.iCurr;
71     const iFirstSave = curr - 3;
72     const iFirstTransform = curr - 2;
73     const iFirstPIIXO = curr - 1;
74 
75     const count = Math.min(
76       Math.floor((i - iFirstSave) / 4),
77       MAX_IMAGES_IN_INLINE_IMAGES_BLOCK
78     );
79     if (count < MIN_IMAGES_IN_INLINE_IMAGES_BLOCK) {
80       return i - ((i - iFirstSave) % 4);
81     }
82 
83     // assuming that heights of those image is too small (~1 pixel)
84     // packing as much as possible by lines
85     let maxX = 0;
86     const map = [];
87     let maxLineHeight = 0;
88     let currentX = IMAGE_PADDING,
89       currentY = IMAGE_PADDING;
90     for (let q = 0; q < count; q++) {
91       const transform = argsArray[iFirstTransform + (q << 2)];
92       const img = argsArray[iFirstPIIXO + (q << 2)][0];
93       if (currentX + img.width > MAX_WIDTH) {
94         // starting new line
95         maxX = Math.max(maxX, currentX);
96         currentY += maxLineHeight + 2 * IMAGE_PADDING;
97         currentX = 0;
98         maxLineHeight = 0;
99       }
100       map.push({
101         transform,
102         x: currentX,
103         y: currentY,
104         w: img.width,
105         h: img.height,
106       });
107       currentX += img.width + 2 * IMAGE_PADDING;
108       maxLineHeight = Math.max(maxLineHeight, img.height);
109     }
110     const imgWidth = Math.max(maxX, currentX) + IMAGE_PADDING;
111     const imgHeight = currentY + maxLineHeight + IMAGE_PADDING;
112     const imgData = new Uint8Array(imgWidth * imgHeight * 4);
113     const imgRowSize = imgWidth << 2;
114     for (let q = 0; q < count; q++) {
115       const data = argsArray[iFirstPIIXO + (q << 2)][0].data;
116       // Copy image by lines and extends pixels into padding.
117       const rowSize = map[q].w << 2;
118       let dataOffset = 0;
119       let offset = (map[q].x + map[q].y * imgWidth) << 2;
120       imgData.set(data.subarray(0, rowSize), offset - imgRowSize);
121       for (let k = 0, kk = map[q].h; k < kk; k++) {
122         imgData.set(data.subarray(dataOffset, dataOffset + rowSize), offset);
123         dataOffset += rowSize;
124         offset += imgRowSize;
125       }
126       imgData.set(data.subarray(dataOffset - rowSize, dataOffset), offset);
127       while (offset >= 0) {
128         data[offset - 4] = data[offset];
129         data[offset - 3] = data[offset + 1];
130         data[offset - 2] = data[offset + 2];
131         data[offset - 1] = data[offset + 3];
132         data[offset + rowSize] = data[offset + rowSize - 4];
133         data[offset + rowSize + 1] = data[offset + rowSize - 3];
134         data[offset + rowSize + 2] = data[offset + rowSize - 2];
135         data[offset + rowSize + 3] = data[offset + rowSize - 1];
136         offset -= imgRowSize;
137       }
138     }
139 
140     const img = {
141       width: imgWidth,
142       height: imgHeight,
143     };
144     if (context.isOffscreenCanvasSupported) {
145       const canvas = new OffscreenCanvas(imgWidth, imgHeight);
146       const ctx = canvas.getContext("2d");
147       ctx.putImageData(
148         new ImageData(
149           new Uint8ClampedArray(imgData.buffer),
150           imgWidth,
151           imgHeight
152         ),
153         0,
154         0
155       );
156       img.bitmap = canvas.transferToImageBitmap();
157       img.data = null;
158     } else {
159       img.kind = ImageKind.RGBA_32BPP;
160       img.data = imgData;
161     }
162 
163     // Replace queue items.
164     fnArray.splice(iFirstSave, count * 4, OPS.paintInlineImageXObjectGroup);
165     argsArray.splice(iFirstSave, count * 4, [img, map]);
166 
167     return iFirstSave + 1;
168   }
169 );
170 
171 // This replaces (save, transform, paintImageMaskXObject, restore)+
172 // sequences with one |paintImageMaskXObjectGroup| or one
173 // |paintImageMaskXObjectRepeat| operation.
174 addState(
175   InitialState,
176   [OPS.save, OPS.transform, OPS.paintImageMaskXObject, OPS.restore],
177   null,
178   function iterateImageMaskGroup(context, i) {
179     const fnArray = context.fnArray;
180     const iFirstSave = context.iCurr - 3;
181     const pos = (i - iFirstSave) % 4;
182     switch (pos) {
183       case 0:
184         return fnArray[i] === OPS.save;
185       case 1:
186         return fnArray[i] === OPS.transform;
187       case 2:
188         return fnArray[i] === OPS.paintImageMaskXObject;
189       case 3:
190         return fnArray[i] === OPS.restore;
191     }
192     throw new Error(`iterateImageMaskGroup - invalid pos: ${pos}`);
193   },
194   function foundImageMaskGroup(context, i) {
195     const MIN_IMAGES_IN_MASKS_BLOCK = 10;
196     const MAX_IMAGES_IN_MASKS_BLOCK = 100;
197     const MAX_SAME_IMAGES_IN_MASKS_BLOCK = 1000;
198 
199     const fnArray = context.fnArray,
200       argsArray = context.argsArray;
201     const curr = context.iCurr;
202     const iFirstSave = curr - 3;
203     const iFirstTransform = curr - 2;
204     const iFirstPIMXO = curr - 1;
205 
206     // At this point, i is the index of the first op past the last valid
207     // quartet.
208     let count = Math.floor((i - iFirstSave) / 4);
209     if (count < MIN_IMAGES_IN_MASKS_BLOCK) {
210       return i - ((i - iFirstSave) % 4);
211     }
212 
213     let isSameImage = false;
214     let iTransform, transformArgs;
215     const firstPIMXOArg0 = argsArray[iFirstPIMXO][0];
216     const firstTransformArg0 = argsArray[iFirstTransform][0],
217       firstTransformArg1 = argsArray[iFirstTransform][1],
218       firstTransformArg2 = argsArray[iFirstTransform][2],
219       firstTransformArg3 = argsArray[iFirstTransform][3];
220 
221     if (firstTransformArg1 === firstTransformArg2) {
222       isSameImage = true;
223       iTransform = iFirstTransform + 4;
224       let iPIMXO = iFirstPIMXO + 4;
225       for (let q = 1; q < count; q++, iTransform += 4, iPIMXO += 4) {
226         transformArgs = argsArray[iTransform];
227         if (
228           argsArray[iPIMXO][0] !== firstPIMXOArg0 ||
229           transformArgs[0] !== firstTransformArg0 ||
230           transformArgs[1] !== firstTransformArg1 ||
231           transformArgs[2] !== firstTransformArg2 ||
232           transformArgs[3] !== firstTransformArg3
233         ) {
234           if (q < MIN_IMAGES_IN_MASKS_BLOCK) {
235             isSameImage = false;
236           } else {
237             count = q;
238           }
239           break; // different image or transform
240         }
241       }
242     }
243 
244     if (isSameImage) {
245       count = Math.min(count, MAX_SAME_IMAGES_IN_MASKS_BLOCK);
246       const positions = new Float32Array(count * 2);
247       iTransform = iFirstTransform;
248       for (let q = 0; q < count; q++, iTransform += 4) {
249         transformArgs = argsArray[iTransform];
250         positions[q << 1] = transformArgs[4];
251         positions[(q << 1) + 1] = transformArgs[5];
252       }
253 
254       // Replace queue items.
255       fnArray.splice(iFirstSave, count * 4, OPS.paintImageMaskXObjectRepeat);
256       argsArray.splice(iFirstSave, count * 4, [
257         firstPIMXOArg0,
258         firstTransformArg0,
259         firstTransformArg1,
260         firstTransformArg2,
261         firstTransformArg3,
262         positions,
263       ]);
264     } else {
265       count = Math.min(count, MAX_IMAGES_IN_MASKS_BLOCK);
266       const images = [];
267       for (let q = 0; q < count; q++) {
268         transformArgs = argsArray[iFirstTransform + (q << 2)];
269         const maskParams = argsArray[iFirstPIMXO + (q << 2)][0];
270         images.push({
271           data: maskParams.data,
272           width: maskParams.width,
273           height: maskParams.height,
274           interpolate: maskParams.interpolate,
275           count: maskParams.count,
276           transform: transformArgs,
277         });
278       }
279 
280       // Replace queue items.
281       fnArray.splice(iFirstSave, count * 4, OPS.paintImageMaskXObjectGroup);
282       argsArray.splice(iFirstSave, count * 4, [images]);
283     }
284 
285     return iFirstSave + 1;
286   }
287 );
288 
289 // This replaces (save, transform, paintImageXObject, restore)+ sequences
290 // with one paintImageXObjectRepeat operation, if the |transform| and
291 // |paintImageXObjectRepeat| ops are appropriate.
292 addState(
293   InitialState,
294   [OPS.save, OPS.transform, OPS.paintImageXObject, OPS.restore],
295   function (context) {
296     const argsArray = context.argsArray;
297     const iFirstTransform = context.iCurr - 2;
298     return (
299       argsArray[iFirstTransform][1] === 0 && argsArray[iFirstTransform][2] === 0
300     );
301   },
302   function iterateImageGroup(context, i) {
303     const fnArray = context.fnArray,
304       argsArray = context.argsArray;
305     const iFirstSave = context.iCurr - 3;
306     const pos = (i - iFirstSave) % 4;
307     switch (pos) {
308       case 0:
309         return fnArray[i] === OPS.save;
310       case 1:
311         if (fnArray[i] !== OPS.transform) {
312           return false;
313         }
314         const iFirstTransform = context.iCurr - 2;
315         const firstTransformArg0 = argsArray[iFirstTransform][0];
316         const firstTransformArg3 = argsArray[iFirstTransform][3];
317         if (
318           argsArray[i][0] !== firstTransformArg0 ||
319           argsArray[i][1] !== 0 ||
320           argsArray[i][2] !== 0 ||
321           argsArray[i][3] !== firstTransformArg3
322         ) {
323           return false; // transforms don't match
324         }
325         return true;
326       case 2:
327         if (fnArray[i] !== OPS.paintImageXObject) {
328           return false;
329         }
330         const iFirstPIXO = context.iCurr - 1;
331         const firstPIXOArg0 = argsArray[iFirstPIXO][0];
332         if (argsArray[i][0] !== firstPIXOArg0) {
333           return false; // images don't match
334         }
335         return true;
336       case 3:
337         return fnArray[i] === OPS.restore;
338     }
339     throw new Error(`iterateImageGroup - invalid pos: ${pos}`);
340   },
341   function (context, i) {
342     const MIN_IMAGES_IN_BLOCK = 3;
343     const MAX_IMAGES_IN_BLOCK = 1000;
344 
345     const fnArray = context.fnArray,
346       argsArray = context.argsArray;
347     const curr = context.iCurr;
348     const iFirstSave = curr - 3;
349     const iFirstTransform = curr - 2;
350     const iFirstPIXO = curr - 1;
351     const firstPIXOArg0 = argsArray[iFirstPIXO][0];
352     const firstTransformArg0 = argsArray[iFirstTransform][0];
353     const firstTransformArg3 = argsArray[iFirstTransform][3];
354 
355     // At this point, i is the index of the first op past the last valid
356     // quartet.
357     const count = Math.min(
358       Math.floor((i - iFirstSave) / 4),
359       MAX_IMAGES_IN_BLOCK
360     );
361     if (count < MIN_IMAGES_IN_BLOCK) {
362       return i - ((i - iFirstSave) % 4);
363     }
364 
365     // Extract the (x,y) positions from all of the matching transforms.
366     const positions = new Float32Array(count * 2);
367     let iTransform = iFirstTransform;
368     for (let q = 0; q < count; q++, iTransform += 4) {
369       const transformArgs = argsArray[iTransform];
370       positions[q << 1] = transformArgs[4];
371       positions[(q << 1) + 1] = transformArgs[5];
372     }
373 
374     // Replace queue items.
375     const args = [
376       firstPIXOArg0,
377       firstTransformArg0,
378       firstTransformArg3,
379       positions,
380     ];
381     fnArray.splice(iFirstSave, count * 4, OPS.paintImageXObjectRepeat);
382     argsArray.splice(iFirstSave, count * 4, args);
383 
384     return iFirstSave + 1;
385   }
386 );
387 
388 // This replaces (beginText, setFont, setTextMatrix, showText, endText)+
389 // sequences with (beginText, setFont, (setTextMatrix, showText)+, endText)+
390 // sequences, if the font for each one is the same.
391 addState(
392   InitialState,
393   [OPS.beginText, OPS.setFont, OPS.setTextMatrix, OPS.showText, OPS.endText],
394   null,
395   function iterateShowTextGroup(context, i) {
396     const fnArray = context.fnArray,
397       argsArray = context.argsArray;
398     const iFirstSave = context.iCurr - 4;
399     const pos = (i - iFirstSave) % 5;
400     switch (pos) {
401       case 0:
402         return fnArray[i] === OPS.beginText;
403       case 1:
404         return fnArray[i] === OPS.setFont;
405       case 2:
406         return fnArray[i] === OPS.setTextMatrix;
407       case 3:
408         if (fnArray[i] !== OPS.showText) {
409           return false;
410         }
411         const iFirstSetFont = context.iCurr - 3;
412         const firstSetFontArg0 = argsArray[iFirstSetFont][0];
413         const firstSetFontArg1 = argsArray[iFirstSetFont][1];
414         if (
415           argsArray[i][0] !== firstSetFontArg0 ||
416           argsArray[i][1] !== firstSetFontArg1
417         ) {
418           return false; // fonts don't match
419         }
420         return true;
421       case 4:
422         return fnArray[i] === OPS.endText;
423     }
424     throw new Error(`iterateShowTextGroup - invalid pos: ${pos}`);
425   },
426   function (context, i) {
427     const MIN_CHARS_IN_BLOCK = 3;
428     const MAX_CHARS_IN_BLOCK = 1000;
429 
430     const fnArray = context.fnArray,
431       argsArray = context.argsArray;
432     const curr = context.iCurr;
433     const iFirstBeginText = curr - 4;
434     const iFirstSetFont = curr - 3;
435     const iFirstSetTextMatrix = curr - 2;
436     const iFirstShowText = curr - 1;
437     const iFirstEndText = curr;
438     const firstSetFontArg0 = argsArray[iFirstSetFont][0];
439     const firstSetFontArg1 = argsArray[iFirstSetFont][1];
440 
441     // At this point, i is the index of the first op past the last valid
442     // quintet.
443     let count = Math.min(
444       Math.floor((i - iFirstBeginText) / 5),
445       MAX_CHARS_IN_BLOCK
446     );
447     if (count < MIN_CHARS_IN_BLOCK) {
448       return i - ((i - iFirstBeginText) % 5);
449     }
450 
451     // If the preceding quintet is (<something>, setFont, setTextMatrix,
452     // showText, endText), include that as well. (E.g. <something> might be
453     // |dependency|.)
454     let iFirst = iFirstBeginText;
455     if (
456       iFirstBeginText >= 4 &&
457       fnArray[iFirstBeginText - 4] === fnArray[iFirstSetFont] &&
458       fnArray[iFirstBeginText - 3] === fnArray[iFirstSetTextMatrix] &&
459       fnArray[iFirstBeginText - 2] === fnArray[iFirstShowText] &&
460       fnArray[iFirstBeginText - 1] === fnArray[iFirstEndText] &&
461       argsArray[iFirstBeginText - 4][0] === firstSetFontArg0 &&
462       argsArray[iFirstBeginText - 4][1] === firstSetFontArg1
463     ) {
464       count++;
465       iFirst -= 5;
466     }
467 
468     // Remove (endText, beginText, setFont) trios.
469     let iEndText = iFirst + 4;
470     for (let q = 1; q < count; q++) {
471       fnArray.splice(iEndText, 3);
472       argsArray.splice(iEndText, 3);
473       iEndText += 2;
474     }
475 
476     return iEndText + 1;
477   }
478 );
479 
480 // This replaces (save, transform, constructPath, restore)
481 // sequences with |constructPath| operation.
482 addState(
483   InitialState,
484   [OPS.save, OPS.transform, OPS.constructPath, OPS.restore],
485   context => {
486     const argsArray = context.argsArray;
487     const iFirstConstructPath = context.iCurr - 1;
488     const op = argsArray[iFirstConstructPath][0];
489 
490     // When stroking the transform has to be applied to the line width too.
491     // So we can only optimize if the transform is an identity.
492     if (
493       op !== OPS.stroke &&
494       op !== OPS.closeStroke &&
495       op !== OPS.fillStroke &&
496       op !== OPS.eoFillStroke &&
497       op !== OPS.closeFillStroke &&
498       op !== OPS.closeEOFillStroke
499     ) {
500       return true;
501     }
502     const iFirstTransform = context.iCurr - 2;
503     const transform = argsArray[iFirstTransform];
504     return (
505       transform[0] === 1 &&
506       transform[1] === 0 &&
507       transform[2] === 0 &&
508       transform[3] === 1
509     );
510   },
511   () => false,
512   (context, i) => {
513     const { fnArray, argsArray } = context;
514     const curr = context.iCurr;
515     const iFirstSave = curr - 3;
516     const iFirstTransform = curr - 2;
517     const iFirstConstructPath = curr - 1;
518     const args = argsArray[iFirstConstructPath];
519     const transform = argsArray[iFirstTransform];
520     const [, [buffer], minMax] = args;
521 
522     Util.scaleMinMax(transform, minMax);
523     for (let k = 0, kk = buffer.length; k < kk; ) {
524       switch (buffer[k++]) {
525         case DrawOPS.moveTo:
526         case DrawOPS.lineTo:
527           Util.applyTransform(buffer, transform, k);
528           k += 2;
529           break;
530         case DrawOPS.curveTo:
531           Util.applyTransformToBezier(buffer, transform, k);
532           k += 6;
533           break;
534       }
535     }
536     // Replace queue items.
537     fnArray.splice(iFirstSave, 4, OPS.constructPath);
538     argsArray.splice(iFirstSave, 4, args);
539 
540     return iFirstSave + 1;
541   }
542 );
543 
544 class NullOptimizer {
545   constructor(queue) {
546     this.queue = queue;
547   }
548 
549   _optimize() {}
550 
551   push(fn, args) {
552     this.queue.fnArray.push(fn);
553     this.queue.argsArray.push(args);
554     this._optimize();
555   }
556 
557   flush() {}
558 
559   reset() {}
560 }
561 
562 class QueueOptimizer extends NullOptimizer {
563   constructor(queue) {
564     super(queue);
565     this.state = null;
566     this.context = {
567       iCurr: 0,
568       fnArray: queue.fnArray,
569       argsArray: queue.argsArray,
570       isOffscreenCanvasSupported: OperatorList.isOffscreenCanvasSupported,
571     };
572     this.match = null;
573     this.lastProcessed = 0;
574   }
575 
576   _optimize() {
577     // Process new fnArray item(s) chunk.
578     const fnArray = this.queue.fnArray;
579     let i = this.lastProcessed,
580       ii = fnArray.length;
581     let state = this.state;
582     let match = this.match;
583     if (!state && !match && i + 1 === ii && !InitialState[fnArray[i]]) {
584       // Micro-optimization for the common case: last item is not
585       // optimizable, just skipping it.
586       this.lastProcessed = ii;
587       return;
588     }
589 
590     const context = this.context;
591     while (i < ii) {
592       if (match) {
593         // Already find a block of potentially optimizable items, iterating...
594         const iterate = (0, match.iterateFn)(context, i);
595         if (iterate) {
596           i++;
597           continue;
598         }
599         // Found last items for the block, processing...
600         i = (0, match.processFn)(context, i + 1);
601         ii = fnArray.length;
602         match = null;
603         state = null;
604         if (i >= ii) {
605           break;
606         }
607       }
608       // Find the potentially optimizable items.
609       state = (state || InitialState)[fnArray[i]];
610       if (!state || Array.isArray(state)) {
611         i++;
612         continue;
613       }
614       // Found a start of the block based on addState rules.
615       context.iCurr = i;
616       i++;
617       if (state.checkFn && !(0, state.checkFn)(context)) {
618         // Check failed, continue search...
619         state = null;
620         continue;
621       }
622       match = state;
623       state = null;
624     }
625     this.state = state;
626     this.match = match;
627     this.lastProcessed = i;
628   }
629 
630   flush() {
631     while (this.match) {
632       const length = this.queue.fnArray.length;
633       this.lastProcessed = (0, this.match.processFn)(this.context, length);
634       this.match = null;
635       this.state = null;
636       // Repeat optimization until all chunks are exhausted.
637       this._optimize();
638     }
639   }
640 
641   reset() {
642     this.state = null;
643     this.match = null;
644     this.lastProcessed = 0;
645   }
646 }
647 
648 class OperatorList {
649   static CHUNK_SIZE = 1000;
650 
651   // Close to chunk size.
652   static CHUNK_SIZE_ABOUT = this.CHUNK_SIZE - 5;
653 
654   static isOffscreenCanvasSupported = false;
655 
656   constructor(intent = 0, streamSink) {
657     this._streamSink = streamSink;
658     this.fnArray = [];
659     this.argsArray = [];
660     this.optimizer =
661       streamSink && !(intent & RenderingIntentFlag.OPLIST)
662         ? new QueueOptimizer(this)
663         : new NullOptimizer(this);
664     this.dependencies = new Set();
665     this._totalLength = 0;
666     this.weight = 0;
667     this._resolved = streamSink ? null : Promise.resolve();
668   }
669 
670   static setOptions({ isOffscreenCanvasSupported }) {
671     this.isOffscreenCanvasSupported = isOffscreenCanvasSupported;
672   }
673 
674   get length() {
675     return this.argsArray.length;
676   }
677 
678   get ready() {
679     return this._resolved || this._streamSink.ready;
680   }
681 
682   /**
683    * @type {number} The total length of the entire operator list, since
684    *                `this.length === 0` after flushing.
685    */
686   get totalLength() {
687     return this._totalLength + this.length;
688   }
689 
690   addOp(fn, args) {
691     this.optimizer.push(fn, args);
692     this.weight++;
693     if (this._streamSink) {
694       if (this.weight >= OperatorList.CHUNK_SIZE) {
695         this.flush();
696       } else if (
697         this.weight >= OperatorList.CHUNK_SIZE_ABOUT &&
698         (fn === OPS.restore || fn === OPS.endText)
699       ) {
700         // Heuristic to flush on boundary of restore or endText.
701         this.flush();
702       }
703     }
704   }
705 
706   addImageOps(fn, args, optionalContent, hasMask = false) {
707     if (hasMask) {
708       this.addOp(OPS.save);
709       this.addOp(OPS.setGState, [[["SMask", false]]]);
710     }
711     if (optionalContent !== undefined) {
712       this.addOp(OPS.beginMarkedContentProps, ["OC", optionalContent]);
713     }
714 
715     this.addOp(fn, args);
716 
717     if (optionalContent !== undefined) {
718       this.addOp(OPS.endMarkedContent, []);
719     }
720     if (hasMask) {
721       this.addOp(OPS.restore);
722     }
723   }
724 
725   addDependency(dependency) {
726     if (this.dependencies.has(dependency)) {
727       return;
728     }
729     this.dependencies.add(dependency);
730     this.addOp(OPS.dependency, [dependency]);
731   }
732 
733   addDependencies(dependencies) {
734     for (const dependency of dependencies) {
735       this.addDependency(dependency);
736     }
737   }
738 
739   addOpList(opList) {
740     if (!(opList instanceof OperatorList)) {
741       warn('addOpList - ignoring invalid "opList" parameter.');
742       return;
743     }
744     for (const dependency of opList.dependencies) {
745       this.dependencies.add(dependency);
746     }
747     for (let i = 0, ii = opList.length; i < ii; i++) {
748       this.addOp(opList.fnArray[i], opList.argsArray[i]);
749     }
750   }
751 
752   getIR() {
753     return {
754       fnArray: this.fnArray,
755       argsArray: this.argsArray,
756       length: this.length,
757     };
758   }
759 
760   get _transfers() {
761     const transfers = [];
762     const { fnArray, argsArray, length } = this;
763     for (let i = 0; i < length; i++) {
764       switch (fnArray[i]) {
765         case OPS.paintInlineImageXObject:
766         case OPS.paintInlineImageXObjectGroup:
767         case OPS.paintImageMaskXObject: {
768           const { bitmap, data } = argsArray[i][0]; // First parameter in imgData.
769           if (bitmap || data?.buffer) {
770             transfers.push(bitmap || data.buffer);
771           }
772           break;
773         }
774         case OPS.constructPath: {
775           const [, [data], minMax] = argsArray[i];
776           if (data) {
777             transfers.push(data.buffer, minMax.buffer);
778           }
779           break;
780         }
781         case OPS.paintFormXObjectBegin:
782           const [matrix, bbox] = argsArray[i];
783           if (matrix) {
784             transfers.push(matrix.buffer);
785           }
786           if (bbox) {
787             transfers.push(bbox.buffer);
788           }
789           break;
790         case OPS.setTextMatrix:
791           transfers.push(argsArray[i][0].buffer);
792           break;
793       }
794     }
795     return transfers;
796   }
797 
798   flush(lastChunk = false, separateAnnots = null) {
799     this.optimizer.flush();
800     const length = this.length;
801     this._totalLength += length;
802 
803     this._streamSink.enqueue(
804       {
805         fnArray: this.fnArray,
806         argsArray: this.argsArray,
807         lastChunk,
808         separateAnnots,
809         length,
810       },
811       1,
812       this._transfers
813     );
814 
815     this.dependencies.clear();
816     this.fnArray.length = 0;
817     this.argsArray.length = 0;
818     this.weight = 0;
819     this.optimizer.reset();
820   }
821 }
822 
823 export { OperatorList };
</code>

Test file:
<test_file>
File:
test/unit/api_spec.js
/* Copyright 2017 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import {
  AnnotationEditorType,
  AnnotationMode,
  AnnotationType,
  DrawOPS,
  ImageKind,
  InvalidPDFException,
  isNodeJS,
  objectSize,
  OPS,
  PasswordException,
  PasswordResponses,
  PermissionFlag,
  ResponseException,
  UnknownErrorException,
} from "../../src/shared/util.js";
import {
  buildGetDocumentParams,
  CMAP_URL,
  DefaultFileReaderFactory,
  getCrossOriginHostname,
  TEST_PDFS_PATH,
  TestPdfsServer,
} from "./test_utils.js";
import {
  fetchData as fetchDataDOM,
  PageViewport,
  RenderingCancelledException,
  StatTimer,
} from "../../src/display/display_utils.js";
import {
  getDocument,
  PDFDataRangeTransport,
  PDFDocumentLoadingTask,
  PDFDocumentProxy,
  PDFPageProxy,
  PDFWorker,
  RenderTask,
} from "../../src/display/api.js";
import { AutoPrintRegExp } from "../../web/ui_utils.js";
import { GlobalImageCache } from "../../src/core/image_utils.js";
import { GlobalWorkerOptions } from "../../src/display/worker_options.js";
import { Metadata } from "../../src/display/metadata.js";
const WORKER_SRC = "../../build/generic/build/pdf.worker.mjs";
</test_file>

Your task:
You are a software tester at pdf.js.
1. Examine the existing test file. You may reuse any imports, helpers or setup blocks it already has.
2. Write exactly one javascript test `it("...", async () => {...})` block.
3. Your test must fail on the code before the patch, and pass after, hence the test will verify that the patch resolves the issue.
4. The test must be self-contained and to-the-point.
5. If you need something new use only the provided imports (respect the paths exactly how they are given) by importing dynamically for compatibility with Node.js — no new dependencies. 
6. Return only the javascript code for the new `it(...)` block (no comments or explanations).

Example structure:
it("should <describe behavior>", async () => {
  const { example } = await import("../../src/core/example.js");
  <initialize required variables>;
  <define expected variable>;
  <generate actual variables>;
  <compare expected with actual>;
});

