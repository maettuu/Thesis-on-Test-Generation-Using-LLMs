Before you begin:
- Keep going until the job is completely solved — don’t stop halfway.
- If you’re unsure about the behavior, reread the provided patch carefully; do not hallucinate.
- Plan your approach before writing code by reflecting on whether the test truly fails before and passes after.

Issue:
<issue>
Firefox does not show correctly a PDF
</issue>

Patch:
<patch>
diff --git a/src/core/evaluator.js b/src/core/evaluator.js
--- a/src/core/evaluator.js
+++ b/src/core/evaluator.js
@@ -1261,7 +1261,11 @@ class PartialEvaluator {
         return this.fontCache.get(fontRef);
       }
 
-      font = this.xref.fetchIfRef(fontRef);
+      try {
+        font = this.xref.fetchIfRef(fontRef);
+      } catch (ex) {
+        warn(`loadFont - lookup failed: "${ex}".`);
+      }
     }
 
     if (!(font instanceof Dict)) {


</patch>

Imports:
<imports>
Available Packages
Dev Dependencies:
- @babel/core: ^7.24.5
- @babel/preset-env: ^7.24.5
- @babel/runtime: ^7.24.5
- @fluent/bundle: ^0.18.0
- @fluent/dom: ^0.9.0
- @jazzer.js/core: ^2.1.0
- autoprefixer: ^10.4.19
- babel-loader: ^9.1.3
- caniuse-lite: ^1.0.30001621
- canvas: ^2.11.2
- core-js: ^3.37.1
- cross-env: ^7.0.3
- eslint: ^8.57.0
- eslint-config-prettier: ^9.1.0
- eslint-plugin-fetch-options: ^0.0.5
- eslint-plugin-html: ^8.1.1
- eslint-plugin-import: ^2.29.1
- eslint-plugin-jasmine: ^4.1.3
- eslint-plugin-json: ^3.1.0
- eslint-plugin-mozilla: ^3.7.4
- eslint-plugin-no-unsanitized: ^4.0.2
- eslint-plugin-prettier: ^5.1.3
- eslint-plugin-sort-exports: ^0.9.1
- eslint-plugin-unicorn: ^53.0.0
- globals: ^15.3.0
- gulp: ^4.0.2
- gulp-cli: ^3.0.0
- gulp-postcss: ^10.0.0
- gulp-rename: ^2.0.0
- gulp-replace: ^1.1.4
- gulp-zip: ^6.0.0
- jasmine: ^5.1.0
- jsdoc: ^4.0.3
- jstransformer-markdown-it: ^3.0.0
- ordered-read-streams: ^2.0.0
- path2d: ^0.2.0
- pngjs: ^7.0.0
- postcss: ^8.4.38
- postcss-dark-theme-class: ^1.3.0
- postcss-dir-pseudo-class: ^8.0.1
- postcss-discard-comments: ^7.0.0
- postcss-nesting: ^12.1.4
- prettier: ^3.2.5
- puppeteer: ^22.9.0
- streamqueue: ^1.1.2
- stylelint: ^16.5.0
- stylelint-prettier: ^5.0.0
- terser-webpack-plugin: ^5.3.10
- tsc-alias: ^1.8.10
- ttest: ^4.0.0
- typescript: ^5.4.5
- typogr: ^0.6.8
- vinyl: ^3.0.0
- webpack: ^5.91.0
- webpack-stream: ^7.0.0
- wintersmith: ^2.5.0
- yargs: ^17.7.2

Engines:
- node: >=18

Available Relative Imports:
- `../../src/core/annotation.js`: Annotation, AnnotationBorderStyle, AnnotationFactory, MarkupAnnotation, getQuadPoints
- `../../src/core/bidi.js`: bidi
- `../../src/core/cff_parser.js`: CFFCharset, CFFCompiler, CFFFDSelect, CFFParser, CFFStrings
- `../../src/core/cmap.js`: CMap, CMapFactory, IdentityCMap
- `../../src/core/colorspace.js`: ColorSpace
- `../../src/core/core_utils.js`: arrayBuffersToBytes, encodeToXmlString, escapePDFName, escapeString, getInheritableProperty, getSizeInBytes, isAscii, isWhiteSpace, log2, numberToString, parseXFAPath, recoverJsURL, stringToUTF16HexString, stringToUTF16String, toRomanNumerals, validateCSSFont
- `../../src/core/crypto.js`: AES128Cipher, AES256Cipher, ARCFourCipher, CipherTransformFactory, PDF17, PDF20, calculateMD5, calculateSHA256, calculateSHA384, calculateSHA512
- `../../src/core/default_appearance.js`: createDefaultAppearance, parseAppearanceStream, parseDefaultAppearance
- `../../src/core/document.js`: PDFDocument, Page
- `../../src/core/encodings.js`: getEncoding
- `../../src/core/evaluator.js`: PartialEvaluator
- `../../src/core/flate_stream.js`: FlateStream
- `../../src/core/font_substitutions.js`: getFontSubstitution
- `../../src/core/fonts_utils.js`: SEAC_ANALYSIS_ENABLED
- `../../src/core/function.js`: PDFFunctionFactory, PostScriptCompiler, PostScriptEvaluator
- `../../src/core/glyphlist.js`: getDingbatsGlyphsUnicode, getGlyphsUnicode
- `../../src/core/image_utils.js`: GlobalImageCache, LocalColorSpaceCache
- `../../src/core/jbig2.js`: Jbig2Error, Jbig2Image
- `../../src/core/jpg.js`: JpegError, JpegImage
- `../../src/core/jpx.js`: JpxError, JpxImage
- `../../src/core/metadata_parser.js`: MetadataParser
- `../../src/core/operator_list.js`: OperatorList
- `../../src/core/parser.js`: Lexer, Linearization, Parser
- `../../src/core/predictor_stream.js`: PredictorStream
- `../../src/core/primitives.js`: Cmd, Dict, EOF, Name, Ref, RefSet, RefSetCache, isCmd, isDict, isName, isRefsEqual
- `../../src/core/ps_parser.js`: PostScriptLexer, PostScriptParser
- `../../src/core/stream.js`: NullStream, Stream, StringStream
- `../../src/core/type1_parser.js`: Type1Parser
- `../../src/core/unicode.js`: getCharUnicodeCategory, getUnicodeForGlyph, getUnicodeRangeFor, mapSpecialUnicodeValues
- `../../src/core/worker.js`: WorkerMessageHandler, WorkerTask
- `../../src/core/writer.js`: incrementalUpdate, writeDict
- `../../src/core/xfa/bind.js`: Binder
- `../../src/core/xfa/data.js`: DataHandler
- `../../src/core/xfa/factory.js`: XFAFactory
- `../../src/core/xfa/formcalc_lexer.js`: Lexer, TOKEN, Token
- `../../src/core/xfa/formcalc_parser.js`: Errors, Parser
- `../../src/core/xfa/parser.js`: XFAParser
- `../../src/core/xfa/som.js`: searchNode
- `../../src/core/xfa/symbol_utils.js`: $dump, $getChildren, $getChildrenByClass, $getChildrenByName, $text, $uid
- `../../src/core/xml_parser.js`: SimpleXMLParser, XMLParserBase
- `../../src/display/annotation_layer.js`: AnnotationLayer
- `../../src/display/annotation_storage.js`: AnnotationStorage
- `../../src/display/api.js`: DefaultCMapReaderFactory, DefaultCanvasFactory, DefaultStandardFontDataFactory, LoopbackPort, PDFDataRangeTransport, PDFDocumentLoadingTask, PDFDocumentProxy, PDFPageProxy, PDFWorker, PDFWorkerUtil, RenderTask, build, getDocument, version
- `../../src/display/display_utils.js`: DOMCanvasFactory, DOMSVGFactory, PDFDateString, PageViewport, PixelsPerInch, RenderingCancelledException, StatTimer, fetchData, getFilenameFromUrl, getPdfFilenameFromUrl, getXfaPageViewport, isDataScheme, isPdfFile, isValidFetchUrl, noContextMenu, setLayerDimensions
- `../../src/display/draw_layer.js`: DrawLayer
- `../../src/display/editor/annotation_editor_layer.js`: AnnotationEditorLayer
- `../../src/display/editor/color_picker.js`: ColorPicker
- `../../src/display/editor/outliner.js`: Outliner
- `../../src/display/editor/tools.js`: AnnotationEditorUIManager, CommandManager
- `../../src/display/fetch_stream.js`: PDFFetchStream
- `../../src/display/metadata.js`: Metadata
- `../../src/display/network.js`: PDFNetworkStream
- `../../src/display/network_utils.js`: createResponseStatusError, extractFilenameFromHeader, validateRangeRequestCapabilities, validateResponseStatus
- `../../src/display/node_stream.js`: PDFNodeStream
- `../../src/display/node_utils.js`: NodePackages
- `../../src/display/text_layer.js`: TextLayer, renderTextLayer, updateTextLayer
- `../../src/display/worker_options.js`: GlobalWorkerOptions
- `../../src/display/xfa_layer.js`: XfaLayer
- `../../src/shared/message_handler.js`: MessageHandler
- `../../src/shared/murmurhash3.js`: MurmurHash3_64
- `../../src/shared/util.js`: AbortException, AnnotationBorderStyleType, AnnotationEditorParamsType, AnnotationEditorType, AnnotationFieldFlag, AnnotationFlag, AnnotationMode, AnnotationType, BaseException, CMapCompressionType, FeatureTest, FormatError, ImageKind, InvalidPDFException, MissingPDFException, OPS, PasswordException, PasswordResponses, PermissionFlag, RenderingIntentFlag, UnexpectedResponseException, UnknownErrorException, Util, VerbosityLevel, assert, bytesToString, createValidAbsoluteUrl, getModificationDate, getVerbosityLevel, isNodeJS, normalizeUnicode, objectSize, setVerbosityLevel, shadow, string32, stringToBytes, stringToPDFString, stringToUTF8String
- `../../web/annotation_layer_builder.js`: AnnotationLayerBuilder
- `../../web/app_options.js`: AppOptions, OptionKind
- `../../web/download_manager.js`: DownloadManager
- `../../web/event_utils.js`: EventBus, WaitOnType, waitOnEventOrTimeout
- `../../web/genericl10n.js`: GenericL10n
- `../../web/pdf_find_controller.js`: FindState, PDFFindController
- `../../web/pdf_find_utils.js`: CharacterType, getCharacterType
- `../../web/pdf_history.js`: PDFHistory, isDestArraysEqual, isDestHashesEqual
- `../../web/pdf_link_service.js`: LinkTarget, PDFLinkService, SimpleLinkService
- `../../web/pdf_page_view.js`: PDFPageView
- `../../web/pdf_scripting_manager.component.js`: PDFScriptingManager
- `../../web/pdf_single_page_viewer.js`: PDFSinglePageViewer
- `../../web/pdf_viewer.js`: PDFPageViewBuffer, PDFViewer
- `../../web/struct_tree_layer_builder.js`: StructTreeLayerBuilder
- `../../web/text_layer_builder.js`: TextLayerBuilder
- `../../web/ui_utils.js`: AutoPrintRegExp, ProgressBar, RenderingStates, ScrollMode, SpreadMode, backtrackBeforeAllVisibleElements, binarySearchFirstItem, getPageSizeInches, getVisibleElements, isPortraitOrientation, isValidRotation, parseQueryString, removeNullCharacters
- `../../web/xfa_layer_builder.js`: XfaLayerBuilder
- `./test_utils.js`: CMAP_URL, DefaultFileReaderFactory, STANDARD_FONT_DATA_URL, TEST_PDFS_PATH, XRefMock, buildGetDocumentParams, createIdFactory, createTemporaryNodeServer
- `./testreporter.js`: TestReporter
</imports>

Code:
<code>
File:
src/core/evaluator.js
1 /* Copyright 2012 Mozilla Foundation
2  *
3  * Licensed under the Apache License, Version 2.0 (the "License");
4  * you may not use this file except in compliance with the License.
5  * You may obtain a copy of the License at
6  *
7  *     http://www.apache.org/licenses/LICENSE-2.0
8  *
9  * Unless required by applicable law or agreed to in writing, software
10  * distributed under the License is distributed on an "AS IS" BASIS,
11  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
12  * See the License for the specific language governing permissions and
13  * limitations under the License.
14  */
15 /* eslint-disable no-var */
16 
17 import {
18   AbortException,
19   assert,
20   CMapCompressionType,
21   FONT_IDENTITY_MATRIX,
22   FormatError,
23   IDENTITY_MATRIX,
24   info,
25   isArrayEqual,
26   normalizeUnicode,
27   OPS,
28   shadow,
29   stringToPDFString,
30   TextRenderingMode,
31   Util,
32   warn,
33 } from "../shared/util.js";
34 import { CMapFactory, IdentityCMap } from "./cmap.js";
35 import { Cmd, Dict, EOF, isName, Name, Ref, RefSet } from "./primitives.js";
36 import { ErrorFont, Font } from "./fonts.js";
37 import {
38   getEncoding,
39   MacRomanEncoding,
40   StandardEncoding,
41   SymbolSetEncoding,
42   WinAnsiEncoding,
43   ZapfDingbatsEncoding,
44 } from "./encodings.js";
45 import {
46   getFontNameToFileMap,
47   getSerifFonts,
48   getStandardFontName,
49   getStdFontMap,
50   getSymbolsFonts,
51   isKnownFontName,
52 } from "./standard_fonts.js";
53 import { getTilingPatternIR, Pattern } from "./pattern.js";
54 import { getXfaFontDict, getXfaFontName } from "./xfa_fonts.js";
55 import { IdentityToUnicodeMap, ToUnicodeMap } from "./to_unicode_map.js";
56 import { isNumberArray, lookupMatrix, lookupNormalRect } from "./core_utils.js";
57 import { isPDFFunction, PDFFunctionFactory } from "./function.js";
58 import { Lexer, Parser } from "./parser.js";
59 import {
60   LocalColorSpaceCache,
61   LocalGStateCache,
62   LocalImageCache,
63   LocalTilingPatternCache,
64   RegionalImageCache,
65 } from "./image_utils.js";
66 import { NullStream, Stream } from "./stream.js";
67 import { BaseStream } from "./base_stream.js";
68 import { bidi } from "./bidi.js";
69 import { ColorSpace } from "./colorspace.js";
70 import { DecodeStream } from "./decode_stream.js";
71 import { FontFlags } from "./fonts_utils.js";
72 import { getFontSubstitution } from "./font_substitutions.js";
73 import { getGlyphsUnicode } from "./glyphlist.js";
74 import { getMetrics } from "./metrics.js";
75 import { getUnicodeForGlyph } from "./unicode.js";
76 import { ImageResizer } from "./image_resizer.js";
77 import { MurmurHash3_64 } from "../shared/murmurhash3.js";
78 import { OperatorList } from "./operator_list.js";
79 import { PDFImage } from "./image.js";
80 
81 const DefaultPartialEvaluatorOptions = Object.freeze({
82   maxImageSize: -1,
83   disableFontFace: false,
84   ignoreErrors: false,
85   isEvalSupported: true,
86   isOffscreenCanvasSupported: false,
87   canvasMaxAreaInBytes: -1,
88   fontExtraProperties: false,
89   useSystemFonts: true,
90   cMapUrl: null,
91   standardFontDataUrl: null,
92 });
93 
94 const PatternType = {
95   TILING: 1,
96   SHADING: 2,
97 };
98 
99 // Optionally avoid sending individual, or very few, text chunks to reduce
100 // `postMessage` overhead with ReadableStream (see issue 13962).
101 //
102 // PLEASE NOTE: This value should *not* be too large (it's used as a lower limit
103 // in `enqueueChunk`), since that would cause streaming of textContent to become
104 // essentially useless in practice by sending all (or most) chunks at once.
105 // Also, a too large value would (indirectly) affect the main-thread `textLayer`
106 // building negatively by forcing all textContent to be handled at once, which
107 // could easily end up hurting *overall* performance (e.g. rendering as well).
108 const TEXT_CHUNK_BATCH_SIZE = 10;
109 
110 const deferred = Promise.resolve();
111 
112 // Convert PDF blend mode names to HTML5 blend mode names.
113 function normalizeBlendMode(value, parsingArray = false) {
114   if (Array.isArray(value)) {
115     // Use the first *supported* BM value in the Array (fixes issue11279.pdf).
116     for (const val of value) {
117       const maybeBM = normalizeBlendMode(val, /* parsingArray = */ true);
118       if (maybeBM) {
119         return maybeBM;
120       }
121     }
122     warn(`Unsupported blend mode Array: ${value}`);
123     return "source-over";
124   }
125 
126   if (!(value instanceof Name)) {
127     if (parsingArray) {
128       return null;
129     }
130     return "source-over";
131   }
132   switch (value.name) {
133     case "Normal":
134     case "Compatible":
135       return "source-over";
136     case "Multiply":
137       return "multiply";
138     case "Screen":
139       return "screen";
140     case "Overlay":
141       return "overlay";
142     case "Darken":
143       return "darken";
144     case "Lighten":
145       return "lighten";
146     case "ColorDodge":
147       return "color-dodge";
148     case "ColorBurn":
149       return "color-burn";
150     case "HardLight":
151       return "hard-light";
152     case "SoftLight":
153       return "soft-light";
154     case "Difference":
155       return "difference";
156     case "Exclusion":
157       return "exclusion";
158     case "Hue":
159       return "hue";
160     case "Saturation":
161       return "saturation";
162     case "Color":
163       return "color";
164     case "Luminosity":
165       return "luminosity";
166   }
167   if (parsingArray) {
168     return null;
169   }
170   warn(`Unsupported blend mode: ${value.name}`);
171   return "source-over";
172 }
173 
174 function incrementCachedImageMaskCount(data) {
175   if (data.fn === OPS.paintImageMaskXObject && data.args[0]?.count > 0) {
176     data.args[0].count++;
177   }
178 }
179 
180 // Trying to minimize Date.now() usage and check every 100 time.
181 class TimeSlotManager {
182   static TIME_SLOT_DURATION_MS = 20;
183 
184   static CHECK_TIME_EVERY = 100;
185 
186   constructor() {
187     this.reset();
188   }
189 
190   check() {
191     if (++this.checked < TimeSlotManager.CHECK_TIME_EVERY) {
192       return false;
193     }
194     this.checked = 0;
195     return this.endTime <= Date.now();
196   }
197 
198   reset() {
199     this.endTime = Date.now() + TimeSlotManager.TIME_SLOT_DURATION_MS;
200     this.checked = 0;
201   }
202 }
203 
204 class PartialEvaluator {
205   constructor({
206     xref,
207     handler,
208     pageIndex,
209     idFactory,
210     fontCache,
211     builtInCMapCache,
212     standardFontDataCache,
213     globalImageCache,
214     systemFontCache,
215     options = null,
216   }) {
217     this.xref = xref;
218     this.handler = handler;
219     this.pageIndex = pageIndex;
220     this.idFactory = idFactory;
221     this.fontCache = fontCache;
222     this.builtInCMapCache = builtInCMapCache;
223     this.standardFontDataCache = standardFontDataCache;
224     this.globalImageCache = globalImageCache;
225     this.systemFontCache = systemFontCache;
226     this.options = options || DefaultPartialEvaluatorOptions;
227     this.parsingType3Font = false;
228 
229     this._regionalImageCache = new RegionalImageCache();
230     this._fetchBuiltInCMapBound = this.fetchBuiltInCMap.bind(this);
231     ImageResizer.setMaxArea(this.options.canvasMaxAreaInBytes);
232   }
233 
234   /**
235    * Since Functions are only cached (locally) by reference, we can share one
236    * `PDFFunctionFactory` instance within this `PartialEvaluator` instance.
237    */
238   get _pdfFunctionFactory() {
239     const pdfFunctionFactory = new PDFFunctionFactory({
240       xref: this.xref,
241       isEvalSupported: this.options.isEvalSupported,
242     });
243     return shadow(this, "_pdfFunctionFactory", pdfFunctionFactory);
244   }
245 
246   clone(newOptions = null) {
247     const newEvaluator = Object.create(this);
248     newEvaluator.options = Object.assign(
249       Object.create(null),
250       this.options,
251       newOptions
252     );
253     return newEvaluator;
254   }
255 
256   hasBlendModes(resources, nonBlendModesSet) {
257     if (!(resources instanceof Dict)) {
258       return false;
259     }
260     if (resources.objId && nonBlendModesSet.has(resources.objId)) {
261       return false;
262     }
263 
264     const processed = new RefSet(nonBlendModesSet);
265     if (resources.objId) {
266       processed.put(resources.objId);
267     }
268 
269     const nodes = [resources],
270       xref = this.xref;
271     while (nodes.length) {
272       const node = nodes.shift();
273       // First check the current resources for blend modes.
274       const graphicStates = node.get("ExtGState");
275       if (graphicStates instanceof Dict) {
276         for (let graphicState of graphicStates.getRawValues()) {
277           if (graphicState instanceof Ref) {
278             if (processed.has(graphicState)) {
279               continue; // The ExtGState has already been processed.
280             }
281             try {
282               graphicState = xref.fetch(graphicState);
283             } catch (ex) {
284               // Avoid parsing a corrupt ExtGState more than once.
285               processed.put(graphicState);
286 
287               info(`hasBlendModes - ignoring ExtGState: "${ex}".`);
288               continue;
289             }
290           }
291           if (!(graphicState instanceof Dict)) {
292             continue;
293           }
294           if (graphicState.objId) {
295             processed.put(graphicState.objId);
296           }
297 
298           const bm = graphicState.get("BM");
299           if (bm instanceof Name) {
300             if (bm.name !== "Normal") {
301               return true;
302             }
303             continue;
304           }
305           if (bm !== undefined && Array.isArray(bm)) {
306             for (const element of bm) {
307               if (element instanceof Name && element.name !== "Normal") {
308                 return true;
309               }
310             }
311           }
312         }
313       }
314       // Descend into the XObjects to look for more resources and blend modes.
315       const xObjects = node.get("XObject");
316       if (!(xObjects instanceof Dict)) {
317         continue;
318       }
319       for (let xObject of xObjects.getRawValues()) {
320         if (xObject instanceof Ref) {
321           if (processed.has(xObject)) {
322             // The XObject has already been processed, and by avoiding a
323             // redundant `xref.fetch` we can *significantly* reduce the load
324             // time for badly generated PDF files (fixes issue6961.pdf).
325             continue;
326           }
327           try {
328             xObject = xref.fetch(xObject);
329           } catch (ex) {
330             // Avoid parsing a corrupt XObject more than once.
331             processed.put(xObject);
332 
333             info(`hasBlendModes - ignoring XObject: "${ex}".`);
334             continue;
335           }
336         }
337         if (!(xObject instanceof BaseStream)) {
338           continue;
339         }
340         if (xObject.dict.objId) {
341           processed.put(xObject.dict.objId);
342         }
343         const xResources = xObject.dict.get("Resources");
344         if (!(xResources instanceof Dict)) {
345           continue;
346         }
347         // Checking objId to detect an infinite loop.
348         if (xResources.objId && processed.has(xResources.objId)) {
349           continue;
350         }
351 
352         nodes.push(xResources);
353         if (xResources.objId) {
354           processed.put(xResources.objId);
355         }
356       }
357     }
358 
359     // When no blend modes exist, there's no need re-fetch/re-parse any of the
360     // processed `Ref`s again for subsequent pages. This helps reduce redundant
361     // `XRef.fetch` calls for some documents (e.g. issue6961.pdf).
362     for (const ref of processed) {
363       nonBlendModesSet.put(ref);
364     }
365     return false;
366   }
367 
368   async fetchBuiltInCMap(name) {
369     const cachedData = this.builtInCMapCache.get(name);
370     if (cachedData) {
371       return cachedData;
372     }
373     let data;
374 
375     if (this.options.cMapUrl !== null) {
376       // Only compressed CMaps are (currently) supported here.
377       const url = `${this.options.cMapUrl}${name}.bcmap`;
378       const response = await fetch(url);
379       if (!response.ok) {
380         throw new Error(
381           `fetchBuiltInCMap: failed to fetch file "${url}" with "${response.statusText}".`
382         );
383       }
384       data = {
385         cMapData: new Uint8Array(await response.arrayBuffer()),
386         compressionType: CMapCompressionType.BINARY,
387       };
388     } else {
389       // Get the data on the main-thread instead.
390       data = await this.handler.sendWithPromise("FetchBuiltInCMap", { name });
391     }
392 
393     if (data.compressionType !== CMapCompressionType.NONE) {
394       // Given the size of uncompressed CMaps, only cache compressed ones.
395       this.builtInCMapCache.set(name, data);
396     }
397     return data;
398   }
399 
400   async fetchStandardFontData(name) {
401     const cachedData = this.standardFontDataCache.get(name);
402     if (cachedData) {
403       return new Stream(cachedData);
404     }
405 
406     // The symbol fonts are not consistent across platforms, always load the
407     // standard font data for them.
408     if (
409       this.options.useSystemFonts &&
410       name !== "Symbol" &&
411       name !== "ZapfDingbats"
412     ) {
413       return null;
414     }
415 
416     const standardFontNameToFileName = getFontNameToFileMap(),
417       filename = standardFontNameToFileName[name];
418     let data;
419 
420     if (this.options.standardFontDataUrl !== null) {
421       const url = `${this.options.standardFontDataUrl}${filename}`;
422       const response = await fetch(url);
423       if (!response.ok) {
424         warn(
425           `fetchStandardFontData: failed to fetch file "${url}" with "${response.statusText}".`
426         );
427       } else {
428         data = new Uint8Array(await response.arrayBuffer());
429       }
430     } else {
431       // Get the data on the main-thread instead.
432       try {
433         data = await this.handler.sendWithPromise("FetchStandardFontData", {
434           filename,
435         });
436       } catch (e) {
437         warn(
438           `fetchStandardFontData: failed to fetch file "${filename}" with "${e}".`
439         );
440       }
441     }
442 
443     if (!data) {
444       return null;
445     }
446     // Cache the "raw" standard font data, to avoid fetching it repeatedly
447     // (see e.g. issue 11399).
448     this.standardFontDataCache.set(name, data);
449 
450     return new Stream(data);
451   }
452 
453   async buildFormXObject(
454     resources,
455     xobj,
456     smask,
457     operatorList,
458     task,
459     initialState,
460     localColorSpaceCache
461   ) {
462     const dict = xobj.dict;
463     const matrix = lookupMatrix(dict.getArray("Matrix"), null);
464     const bbox = lookupNormalRect(dict.getArray("BBox"), null);
465 
466     let optionalContent, groupOptions;
467     if (dict.has("OC")) {
468       optionalContent = await this.parseMarkedContentProps(
469         dict.get("OC"),
470         resources
471       );
472     }
473     if (optionalContent !== undefined) {
474       operatorList.addOp(OPS.beginMarkedContentProps, ["OC", optionalContent]);
475     }
476     const group = dict.get("Group");
477     if (group) {
478       groupOptions = {
479         matrix,
480         bbox,
481         smask,
482         isolated: false,
483         knockout: false,
484       };
485 
486       const groupSubtype = group.get("S");
487       let colorSpace = null;
488       if (isName(groupSubtype, "Transparency")) {
489         groupOptions.isolated = group.get("I") || false;
490         groupOptions.knockout = group.get("K") || false;
491         if (group.has("CS")) {
492           const cs = group.getRaw("CS");
493 
494           const cachedColorSpace = ColorSpace.getCached(
495             cs,
496             this.xref,
497             localColorSpaceCache
498           );
499           if (cachedColorSpace) {
500             colorSpace = cachedColorSpace;
501           } else {
502             colorSpace = await this.parseColorSpace({
503               cs,
504               resources,
505               localColorSpaceCache,
506             });
507           }
508         }
509       }
510 
511       if (smask?.backdrop) {
512         colorSpace ||= ColorSpace.singletons.rgb;
513         smask.backdrop = colorSpace.getRgb(smask.backdrop, 0);
514       }
515 
516       operatorList.addOp(OPS.beginGroup, [groupOptions]);
517     }
518 
519     // If it's a group, a new canvas will be created that is the size of the
520     // bounding box and translated to the correct position so we don't need to
521     // apply the bounding box to it.
522     const args = group ? [matrix, null] : [matrix, bbox];
523     operatorList.addOp(OPS.paintFormXObjectBegin, args);
524 
525     await this.getOperatorList({
526       stream: xobj,
527       task,
528       resources: dict.get("Resources") || resources,
529       operatorList,
530       initialState,
531     });
532     operatorList.addOp(OPS.paintFormXObjectEnd, []);
533 
534     if (group) {
535       operatorList.addOp(OPS.endGroup, [groupOptions]);
536     }
537 
538     if (optionalContent !== undefined) {
539       operatorList.addOp(OPS.endMarkedContent, []);
540     }
541   }
542 
543   _sendImgData(objId, imgData, cacheGlobally = false) {
544     if (
545       (typeof PDFJSDev === "undefined" || PDFJSDev.test("TESTING")) &&
546       imgData
547     ) {
548       assert(Number.isInteger(imgData.dataLen), "Expected dataLen to be set.");
549     }
550     const transfers = imgData ? [imgData.bitmap || imgData.data.buffer] : null;
551 
552     if (this.parsingType3Font || cacheGlobally) {
553       return this.handler.send(
554         "commonobj",
555         [objId, "Image", imgData],
556         transfers
557       );
558     }
559     return this.handler.send(
560       "obj",
561       [objId, this.pageIndex, "Image", imgData],
562       transfers
563     );
564   }
565 
566   async buildPaintImageXObject({
567     resources,
568     image,
569     isInline = false,
570     operatorList,
571     cacheKey,
572     localImageCache,
573     localColorSpaceCache,
574   }) {
575     const dict = image.dict;
576     const imageRef = dict.objId;
577     const w = dict.get("W", "Width");
578     const h = dict.get("H", "Height");
579 
580     if (!(w && typeof w === "number") || !(h && typeof h === "number")) {
581       warn("Image dimensions are missing, or not numbers.");
582       return;
583     }
584     const maxImageSize = this.options.maxImageSize;
585     if (maxImageSize !== -1 && w * h > maxImageSize) {
586       const msg = "Image exceeded maximum allowed size and was removed.";
587 
588       if (this.options.ignoreErrors) {
589         warn(msg);
590         return;
591       }
592       throw new Error(msg);
593     }
594 
595     let optionalContent;
596     if (dict.has("OC")) {
597       optionalContent = await this.parseMarkedContentProps(
598         dict.get("OC"),
599         resources
600       );
601     }
602 
603     const imageMask = dict.get("IM", "ImageMask") || false;
604     let imgData, args;
605     if (imageMask) {
606       // This depends on a tmpCanvas being filled with the
607       // current fillStyle, such that processing the pixel
608       // data can't be done here. Instead of creating a
609       // complete PDFImage, only read the information needed
610       // for later.
611       const interpolate = dict.get("I", "Interpolate");
612       const bitStrideLength = (w + 7) >> 3;
613       const imgArray = image.getBytes(bitStrideLength * h);
614       const decode = dict.getArray("D", "Decode");
615 
616       if (this.parsingType3Font) {
617         imgData = PDFImage.createRawMask({
618           imgArray,
619           width: w,
620           height: h,
621           imageIsFromDecodeStream: image instanceof DecodeStream,
622           inverseDecode: decode?.[0] > 0,
623           interpolate,
624         });
625 
626         imgData.cached = !!cacheKey;
627         args = [imgData];
628 
629         operatorList.addImageOps(
630           OPS.paintImageMaskXObject,
631           args,
632           optionalContent
633         );
634 
635         if (cacheKey) {
636           const cacheData = {
637             fn: OPS.paintImageMaskXObject,
638             args,
639             optionalContent,
640           };
641           localImageCache.set(cacheKey, imageRef, cacheData);
642 
643           if (imageRef) {
644             this._regionalImageCache.set(
645               /* name = */ null,
646               imageRef,
647               cacheData
648             );
649           }
650         }
651         return;
652       }
653 
654       imgData = await PDFImage.createMask({
655         imgArray,
656         width: w,
657         height: h,
658         imageIsFromDecodeStream: image instanceof DecodeStream,
659         inverseDecode: decode?.[0] > 0,
660         interpolate,
661         isOffscreenCanvasSupported: this.options.isOffscreenCanvasSupported,
662       });
663 
664       if (imgData.isSingleOpaquePixel) {
665         // Handles special case of mainly LaTeX documents which use image
666         // masks to draw lines with the current fill style.
667         operatorList.addImageOps(
668           OPS.paintSolidColorImageMask,
669           [],
670           optionalContent
671         );
672 
673         if (cacheKey) {
674           const cacheData = {
675             fn: OPS.paintSolidColorImageMask,
676             args: [],
677             optionalContent,
678           };
679           localImageCache.set(cacheKey, imageRef, cacheData);
680 
681           if (imageRef) {
682             this._regionalImageCache.set(
683               /* name = */ null,
684               imageRef,
685               cacheData
686             );
687           }
688         }
689         return;
690       }
691 
692       const objId = `mask_${this.idFactory.createObjId()}`;
693       operatorList.addDependency(objId);
694 
695       imgData.dataLen = imgData.bitmap
696         ? imgData.width * imgData.height * 4
697         : imgData.data.length;
698       this._sendImgData(objId, imgData);
699 
700       args = [
701         {
702           data: objId,
703           width: imgData.width,
704           height: imgData.height,
705           interpolate: imgData.interpolate,
706           count: 1,
707         },
708       ];
709       operatorList.addImageOps(
710         OPS.paintImageMaskXObject,
711         args,
712         optionalContent
713       );
714 
715       if (cacheKey) {
716         const cacheData = {
717           fn: OPS.paintImageMaskXObject,
718           args,
719           optionalContent,
720         };
721         localImageCache.set(cacheKey, imageRef, cacheData);
722 
723         if (imageRef) {
724           this._regionalImageCache.set(/* name = */ null, imageRef, cacheData);
725         }
726       }
727       return;
728     }
729 
730     const SMALL_IMAGE_DIMENSIONS = 200;
731     // Inlining small images into the queue as RGB data
732     if (
733       isInline &&
734       w + h < SMALL_IMAGE_DIMENSIONS &&
735       !dict.has("SMask") &&
736       !dict.has("Mask")
737     ) {
738       try {
739         const imageObj = new PDFImage({
740           xref: this.xref,
741           res: resources,
742           image,
743           isInline,
744           pdfFunctionFactory: this._pdfFunctionFactory,
745           localColorSpaceCache,
746         });
747         // We force the use of RGBA_32BPP images here, because we can't handle
748         // any other kind.
749         imgData = await imageObj.createImageData(
750           /* forceRGBA = */ true,
751           /* isOffscreenCanvasSupported = */ false
752         );
753         operatorList.isOffscreenCanvasSupported =
754           this.options.isOffscreenCanvasSupported;
755         operatorList.addImageOps(
756           OPS.paintInlineImageXObject,
757           [imgData],
758           optionalContent
759         );
760       } catch (reason) {
761         const msg = `Unable to decode inline image: "${reason}".`;
762 
763         if (!this.options.ignoreErrors) {
764           throw new Error(msg);
765         }
766         warn(msg);
767       }
768       return;
769     }
770 
771     // If there is no imageMask, create the PDFImage and a lot
772     // of image processing can be done here.
773     let objId = `img_${this.idFactory.createObjId()}`,
774       cacheGlobally = false;
775 
776     if (this.parsingType3Font) {
777       objId = `${this.idFactory.getDocId()}_type3_${objId}`;
778     } else if (cacheKey && imageRef) {
779       cacheGlobally = this.globalImageCache.shouldCache(
780         imageRef,
781         this.pageIndex
782       );
783 
784       if (cacheGlobally) {
785         assert(!isInline, "Cannot cache an inline image globally.");
786 
787         objId = `${this.idFactory.getDocId()}_${objId}`;
788       }
789     }
790 
791     // Ensure that the dependency is added before the image is decoded.
792     operatorList.addDependency(objId);
793     args = [objId, w, h];
794     operatorList.addImageOps(OPS.paintImageXObject, args, optionalContent);
795 
796     if (cacheGlobally) {
797       if (this.globalImageCache.hasDecodeFailed(imageRef)) {
798         this.globalImageCache.setData(imageRef, {
799           objId,
800           fn: OPS.paintImageXObject,
801           args,
802           optionalContent,
803           byteSize: 0, // Data is `null`, since decoding failed previously.
804         });
805 
806         this._sendImgData(objId, /* imgData = */ null, cacheGlobally);
807         return;
808       }
809 
810       // For large (at least 500x500) or more complex images that we'll cache
811       // globally, check if the image is still cached locally on the main-thread
812       // to avoid having to re-parse the image (since that can be slow).
813       if (w * h > 250000 || dict.has("SMask") || dict.has("Mask")) {
814         const localLength = await this.handler.sendWithPromise("commonobj", [
815           objId,
816           "CopyLocalImage",
817           { imageRef },
818         ]);
819 
820         if (localLength) {
821           this.globalImageCache.setData(imageRef, {
822             objId,
823             fn: OPS.paintImageXObject,
824             args,
825             optionalContent,
826             byteSize: 0, // Temporary entry, to avoid `setData` returning early.
827           });
828           this.globalImageCache.addByteSize(imageRef, localLength);
829           return;
830         }
831       }
832     }
833 
834     PDFImage.buildImage({
835       xref: this.xref,
836       res: resources,
837       image,
838       isInline,
839       pdfFunctionFactory: this._pdfFunctionFactory,
840       localColorSpaceCache,
841     })
842       .then(async imageObj => {
843         imgData = await imageObj.createImageData(
844           /* forceRGBA = */ false,
845           /* isOffscreenCanvasSupported = */ this.options
846             .isOffscreenCanvasSupported
847         );
848         imgData.dataLen = imgData.bitmap
849           ? imgData.width * imgData.height * 4
850           : imgData.data.length;
851         imgData.ref = imageRef;
852 
853         if (cacheGlobally) {
854           this.globalImageCache.addByteSize(imageRef, imgData.dataLen);
855         }
856         return this._sendImgData(objId, imgData, cacheGlobally);
857       })
858       .catch(reason => {
859         warn(`Unable to decode image "${objId}": "${reason}".`);
860 
861         if (imageRef) {
862           this.globalImageCache.addDecodeFailed(imageRef);
863         }
864         return this._sendImgData(objId, /* imgData = */ null, cacheGlobally);
865       });
866 
867     if (cacheKey) {
868       const cacheData = {
869         fn: OPS.paintImageXObject,
870         args,
871         optionalContent,
872       };
873       localImageCache.set(cacheKey, imageRef, cacheData);
874 
875       if (imageRef) {
876         this._regionalImageCache.set(/* name = */ null, imageRef, cacheData);
877 
878         if (cacheGlobally) {
879           this.globalImageCache.setData(imageRef, {
880             objId,
881             fn: OPS.paintImageXObject,
882             args,
883             optionalContent,
884             byteSize: 0, // Temporary entry, note `addByteSize` above.
885           });
886         }
887       }
888     }
889   }
890 
891   handleSMask(
892     smask,
893     resources,
894     operatorList,
895     task,
896     stateManager,
897     localColorSpaceCache
898   ) {
899     const smaskContent = smask.get("G");
900     const smaskOptions = {
901       subtype: smask.get("S").name,
902       backdrop: smask.get("BC"),
903     };
904 
905     // The SMask might have a alpha/luminosity value transfer function --
906     // we will build a map of integer values in range 0..255 to be fast.
907     const transferObj = smask.get("TR");
908     if (isPDFFunction(transferObj)) {
909       const transferFn = this._pdfFunctionFactory.create(transferObj);
910       const transferMap = new Uint8Array(256);
911       const tmp = new Float32Array(1);
912       for (let i = 0; i < 256; i++) {
913         tmp[0] = i / 255;
914         transferFn(tmp, 0, tmp, 0);
915         transferMap[i] = (tmp[0] * 255) | 0;
916       }
917       smaskOptions.transferMap = transferMap;
918     }
919 
920     return this.buildFormXObject(
921       resources,
922       smaskContent,
923       smaskOptions,
924       operatorList,
925       task,
926       stateManager.state.clone(),
927       localColorSpaceCache
928     );
929   }
930 
931   handleTransferFunction(tr) {
932     let transferArray;
933     if (Array.isArray(tr)) {
934       transferArray = tr;
935     } else if (isPDFFunction(tr)) {
936       transferArray = [tr];
937     } else {
938       return null; // Not a valid transfer function entry.
939     }
940 
941     const transferMaps = [];
942     let numFns = 0,
943       numEffectfulFns = 0;
944     for (const entry of transferArray) {
945       const transferObj = this.xref.fetchIfRef(entry);
946       numFns++;
947 
948       if (isName(transferObj, "Identity")) {
949         transferMaps.push(null);
950         continue;
951       } else if (!isPDFFunction(transferObj)) {
952         return null; // Not a valid transfer function object.
953       }
954 
955       const transferFn = this._pdfFunctionFactory.create(transferObj);
956       const transferMap = new Uint8Array(256),
957         tmp = new Float32Array(1);
958       for (let j = 0; j < 256; j++) {
959         tmp[0] = j / 255;
960         transferFn(tmp, 0, tmp, 0);
961         transferMap[j] = (tmp[0] * 255) | 0;
962       }
963       transferMaps.push(transferMap);
964       numEffectfulFns++;
965     }
966 
967     if (!(numFns === 1 || numFns === 4)) {
968       return null; // Only 1 or 4 functions are supported, by the specification.
969     }
970     if (numEffectfulFns === 0) {
971       return null; // Only /Identity transfer functions found, which are no-ops.
972     }
973     return transferMaps;
974   }
975 
976   handleTilingType(
977     fn,
978     color,
979     resources,
980     pattern,
981     patternDict,
982     operatorList,
983     task,
984     localTilingPatternCache
985   ) {
986     // Create an IR of the pattern code.
987     const tilingOpList = new OperatorList();
988     // Merge the available resources, to prevent issues when the patternDict
989     // is missing some /Resources entries (fixes issue6541.pdf).
990     const patternResources = Dict.merge({
991       xref: this.xref,
992       dictArray: [patternDict.get("Resources"), resources],
993     });
994 
995     return this.getOperatorList({
996       stream: pattern,
997       task,
998       resources: patternResources,
999       operatorList: tilingOpList,
1000     })
1001       .then(function () {
1002         const operatorListIR = tilingOpList.getIR();
1003         const tilingPatternIR = getTilingPatternIR(
1004           operatorListIR,
1005           patternDict,
1006           color
1007         );
1008         // Add the dependencies to the parent operator list so they are
1009         // resolved before the sub operator list is executed synchronously.
1010         operatorList.addDependencies(tilingOpList.dependencies);
1011         operatorList.addOp(fn, tilingPatternIR);
1012 
1013         if (patternDict.objId) {
1014           localTilingPatternCache.set(/* name = */ null, patternDict.objId, {
1015             operatorListIR,
1016             dict: patternDict,
1017           });
1018         }
1019       })
1020       .catch(reason => {
1021         if (reason instanceof AbortException) {
1022           return;
1023         }
1024         if (this.options.ignoreErrors) {
1025           warn(`handleTilingType - ignoring pattern: "${reason}".`);
1026           return;
1027         }
1028         throw reason;
1029       });
1030   }
1031 
1032   async handleSetFont(
1033     resources,
1034     fontArgs,
1035     fontRef,
1036     operatorList,
1037     task,
1038     state,
1039     fallbackFontDict = null,
1040     cssFontInfo = null
1041   ) {
1042     const fontName = fontArgs?.[0] instanceof Name ? fontArgs[0].name : null;
1043 
1044     let translated = await this.loadFont(
1045       fontName,
1046       fontRef,
1047       resources,
1048       fallbackFontDict,
1049       cssFontInfo
1050     );
1051 
1052     if (translated.font.isType3Font) {
1053       try {
1054         await translated.loadType3Data(this, resources, task);
1055         // Add the dependencies to the parent operatorList so they are
1056         // resolved before Type3 operatorLists are executed synchronously.
1057         operatorList.addDependencies(translated.type3Dependencies);
1058       } catch (reason) {
1059         translated = new TranslatedFont({
1060           loadedName: "g_font_error",
1061           font: new ErrorFont(`Type3 font load error: ${reason}`),
1062           dict: translated.font,
1063           evaluatorOptions: this.options,
1064         });
1065       }
1066     }
1067 
1068     state.font = translated.font;
1069     translated.send(this.handler);
1070     return translated.loadedName;
1071   }
1072 
1073   handleText(chars, state) {
1074     const font = state.font;
1075     const glyphs = font.charsToGlyphs(chars);
1076 
1077     if (font.data) {
1078       const isAddToPathSet = !!(
1079         state.textRenderingMode & TextRenderingMode.ADD_TO_PATH_FLAG
1080       );
1081       if (
1082         isAddToPathSet ||
1083         state.fillColorSpace.name === "Pattern" ||
1084         font.disableFontFace ||
1085         this.options.disableFontFace
1086       ) {
1087         PartialEvaluator.buildFontPaths(
1088           font,
1089           glyphs,
1090           this.handler,
1091           this.options
1092         );
1093       }
1094     }
1095     return glyphs;
1096   }
1097 
1098   ensureStateFont(state) {
1099     if (state.font) {
1100       return;
1101     }
1102     const reason = new FormatError(
1103       "Missing setFont (Tf) operator before text rendering operator."
1104     );
1105 
1106     if (this.options.ignoreErrors) {
1107       warn(`ensureStateFont: "${reason}".`);
1108       return;
1109     }
1110     throw reason;
1111   }
1112 
1113   async setGState({
1114     resources,
1115     gState,
1116     operatorList,
1117     cacheKey,
1118     task,
1119     stateManager,
1120     localGStateCache,
1121     localColorSpaceCache,
1122   }) {
1123     const gStateRef = gState.objId;
1124     let isSimpleGState = true;
1125     // This array holds the converted/processed state data.
1126     const gStateObj = [];
1127     let promise = Promise.resolve();
1128     for (const key of gState.getKeys()) {
1129       const value = gState.get(key);
1130       switch (key) {
1131         case "Type":
1132           break;
1133         case "LW":
1134         case "LC":
1135         case "LJ":
1136         case "ML":
1137         case "D":
1138         case "RI":
1139         case "FL":
1140         case "CA":
1141         case "ca":
1142           gStateObj.push([key, value]);
1143           break;
1144         case "Font":
1145           isSimpleGState = false;
1146 
1147           promise = promise.then(() =>
1148             this.handleSetFont(
1149               resources,
1150               null,
1151               value[0],
1152               operatorList,
1153               task,
1154               stateManager.state
1155             ).then(function (loadedName) {
1156               operatorList.addDependency(loadedName);
1157               gStateObj.push([key, [loadedName, value[1]]]);
1158             })
1159           );
1160           break;
1161         case "BM":
1162           gStateObj.push([key, normalizeBlendMode(value)]);
1163           break;
1164         case "SMask":
1165           if (isName(value, "None")) {
1166             gStateObj.push([key, false]);
1167             break;
1168           }
1169           if (value instanceof Dict) {
1170             isSimpleGState = false;
1171 
1172             promise = promise.then(() =>
1173               this.handleSMask(
1174                 value,
1175                 resources,
1176                 operatorList,
1177                 task,
1178                 stateManager,
1179                 localColorSpaceCache
1180               )
1181             );
1182             gStateObj.push([key, true]);
1183           } else {
1184             warn("Unsupported SMask type");
1185           }
1186           break;
1187         case "TR":
1188           const transferMaps = this.handleTransferFunction(value);
1189           gStateObj.push([key, transferMaps]);
1190           break;
1191         // Only generate info log messages for the following since
1192         // they are unlikely to have a big impact on the rendering.
1193         case "OP":
1194         case "op":
1195         case "OPM":
1196         case "BG":
1197         case "BG2":
1198         case "UCR":
1199         case "UCR2":
1200         case "TR2":
1201         case "HT":
1202         case "SM":
1203         case "SA":
1204         case "AIS":
1205         case "TK":
1206           // TODO implement these operators.
1207           info("graphic state operator " + key);
1208           break;
1209         default:
1210           info("Unknown graphic state operator " + key);
1211           break;
1212       }
1213     }
1214     await promise;
1215 
1216     if (gStateObj.length > 0) {
1217       operatorList.addOp(OPS.setGState, [gStateObj]);
1218     }
1219 
1220     if (isSimpleGState) {
1221       localGStateCache.set(cacheKey, gStateRef, gStateObj);
1222     }
1223   }
1224 
1225   loadFont(
1226     fontName,
1227     font,
1228     resources,
1229     fallbackFontDict = null,
1230     cssFontInfo = null
1231   ) {
1232     // eslint-disable-next-line arrow-body-style
1233     const errorFont = async () => {
1234       return new TranslatedFont({
1235         loadedName: "g_font_error",
1236         font: new ErrorFont(`Font "${fontName}" is not available.`),
1237         dict: font,
1238         evaluatorOptions: this.options,
1239       });
1240     };
1241 
1242     let fontRef;
1243     if (font) {
1244       // Loading by ref.
1245       if (font instanceof Ref) {
1246         fontRef = font;
1247       }
1248     } else {
1249       // Loading by name.
1250       const fontRes = resources.get("Font");
1251       if (fontRes) {
1252         fontRef = fontRes.getRaw(fontName);
1253       }
1254     }
1255     if (fontRef) {
1256       if (this.parsingType3Font && this.type3FontRefs.has(fontRef)) {
1257         return errorFont();
1258       }
1259 
1260       if (this.fontCache.has(fontRef)) {
1261         return this.fontCache.get(fontRef);
1262       }
1263 
1264       font = this.xref.fetchIfRef(fontRef);
1265     }
1266 
1267     if (!(font instanceof Dict)) {
1268       if (!this.options.ignoreErrors && !this.parsingType3Font) {
1269         warn(`Font "${fontName}" is not available.`);
1270         return errorFont();
1271       }
1272       warn(
1273         `Font "${fontName}" is not available -- attempting to fallback to a default font.`
1274       );
1275 
1276       // Falling back to a default font to avoid completely broken rendering,
1277       // but note that there're no guarantees that things will look "correct".
1278       font = fallbackFontDict || PartialEvaluator.fallbackFontDict;
1279     }
1280 
1281     // We are holding `font.cacheKey` references only for `fontRef`s that
1282     // are not actually `Ref`s, but rather `Dict`s. See explanation below.
1283     if (font.cacheKey && this.fontCache.has(font.cacheKey)) {
1284       return this.fontCache.get(font.cacheKey);
1285     }
1286 
1287     const { promise, resolve } = Promise.withResolvers();
1288 
1289     let preEvaluatedFont;
1290     try {
1291       preEvaluatedFont = this.preEvaluateFont(font);
1292       preEvaluatedFont.cssFontInfo = cssFontInfo;
1293     } catch (reason) {
1294       warn(`loadFont - preEvaluateFont failed: "${reason}".`);
1295       return errorFont();
1296     }
1297     const { descriptor, hash } = preEvaluatedFont;
1298 
1299     const fontRefIsRef = fontRef instanceof Ref;
1300     let fontID;
1301 
1302     if (hash && descriptor instanceof Dict) {
1303       const fontAliases = (descriptor.fontAliases ||= Object.create(null));
1304 
1305       if (fontAliases[hash]) {
1306         const aliasFontRef = fontAliases[hash].aliasRef;
1307         if (fontRefIsRef && aliasFontRef && this.fontCache.has(aliasFontRef)) {
1308           this.fontCache.putAlias(fontRef, aliasFontRef);
1309           return this.fontCache.get(fontRef);
1310         }
1311       } else {
1312         fontAliases[hash] = {
1313           fontID: this.idFactory.createFontId(),
1314         };
1315       }
1316 
1317       if (fontRefIsRef) {
1318         fontAliases[hash].aliasRef = fontRef;
1319       }
1320       fontID = fontAliases[hash].fontID;
1321     } else {
1322       fontID = this.idFactory.createFontId();
1323     }
1324     assert(
1325       fontID?.startsWith("f"),
1326       'The "fontID" must be (correctly) defined.'
1327     );
1328 
1329     // Workaround for bad PDF generators that reference fonts incorrectly,
1330     // where `fontRef` is a `Dict` rather than a `Ref` (fixes bug946506.pdf).
1331     // In this case we cannot put the font into `this.fontCache` (which is
1332     // a `RefSetCache`), since it's not possible to use a `Dict` as a key.
1333     //
1334     // However, if we don't cache the font it's not possible to remove it
1335     // when `cleanup` is triggered from the API, which causes issues on
1336     // subsequent rendering operations (see issue7403.pdf) and would force us
1337     // to unnecessarily load the same fonts over and over.
1338     //
1339     // Instead, we cheat a bit by using a modified `fontID` as a key in
1340     // `this.fontCache`, to allow the font to be cached.
1341     // NOTE: This works because `RefSetCache` calls `toString()` on provided
1342     //       keys. Also, since `fontRef` is used when getting cached fonts,
1343     //       we'll not accidentally match fonts cached with the `fontID`.
1344     if (fontRefIsRef) {
1345       this.fontCache.put(fontRef, promise);
1346     } else {
1347       font.cacheKey = `cacheKey_${fontID}`;
1348       this.fontCache.put(font.cacheKey, promise);
1349     }
1350 
1351     // Keep track of each font we translated so the caller can
1352     // load them asynchronously before calling display on a page.
1353     font.loadedName = `${this.idFactory.getDocId()}_${fontID}`;
1354 
1355     this.translateFont(preEvaluatedFont)
1356       .then(translatedFont => {
1357         resolve(
1358           new TranslatedFont({
1359             loadedName: font.loadedName,
1360             font: translatedFont,
1361             dict: font,
1362             evaluatorOptions: this.options,
1363           })
1364         );
1365       })
1366       .catch(reason => {
1367         // TODO reject?
1368         warn(`loadFont - translateFont failed: "${reason}".`);
1369 
1370         resolve(
1371           new TranslatedFont({
1372             loadedName: font.loadedName,
1373             font: new ErrorFont(
1374               reason instanceof Error ? reason.message : reason
1375             ),
1376             dict: font,
1377             evaluatorOptions: this.options,
1378           })
1379         );
1380       });
1381     return promise;
1382   }
1383 
1384   buildPath(operatorList, fn, args, parsingText = false) {
1385     const lastIndex = operatorList.length - 1;
1386     if (!args) {
1387       args = [];
1388     }
1389     if (
1390       lastIndex < 0 ||
1391       operatorList.fnArray[lastIndex] !== OPS.constructPath
1392     ) {
1393       // Handle corrupt PDF documents that contains path operators inside of
1394       // text objects, which may shift subsequent text, by enclosing the path
1395       // operator in save/restore operators (fixes issue10542_reduced.pdf).
1396       //
1397       // Note that this will effectively disable the optimization in the
1398       // `else` branch below, but given that this type of corruption is
1399       // *extremely* rare that shouldn't really matter much in practice.
1400       if (parsingText) {
1401         warn(`Encountered path operator "${fn}" inside of a text object.`);
1402         operatorList.addOp(OPS.save, null);
1403       }
1404 
1405       let minMax;
1406       switch (fn) {
1407         case OPS.rectangle:
1408           const x = args[0] + args[2];
1409           const y = args[1] + args[3];
1410           minMax = [
1411             Math.min(args[0], x),
1412             Math.min(args[1], y),
1413             Math.max(args[0], x),
1414             Math.max(args[1], y),
1415           ];
1416           break;
1417         case OPS.moveTo:
1418         case OPS.lineTo:
1419           minMax = [args[0], args[1], args[0], args[1]];
1420           break;
1421         default:
1422           minMax = [Infinity, Infinity, -Infinity, -Infinity];
1423           break;
1424       }
1425       operatorList.addOp(OPS.constructPath, [[fn], args, minMax]);
1426 
1427       if (parsingText) {
1428         operatorList.addOp(OPS.restore, null);
1429       }
1430     } else {
1431       const opArgs = operatorList.argsArray[lastIndex];
1432       opArgs[0].push(fn);
1433       opArgs[1].push(...args);
1434       const minMax = opArgs[2];
1435 
1436       // Compute min/max in the worker instead of the main thread.
1437       // If the current matrix (when drawing) is a scaling one
1438       // then min/max can be easily computed in using those values.
1439       // Only rectangle, lineTo and moveTo are handled here since
1440       // Bezier stuff requires to have the starting point.
1441       switch (fn) {
1442         case OPS.rectangle:
1443           const x = args[0] + args[2];
1444           const y = args[1] + args[3];
1445           minMax[0] = Math.min(minMax[0], args[0], x);
1446           minMax[1] = Math.min(minMax[1], args[1], y);
1447           minMax[2] = Math.max(minMax[2], args[0], x);
1448           minMax[3] = Math.max(minMax[3], args[1], y);
1449           break;
1450         case OPS.moveTo:
1451         case OPS.lineTo:
1452           minMax[0] = Math.min(minMax[0], args[0]);
1453           minMax[1] = Math.min(minMax[1], args[1]);
1454           minMax[2] = Math.max(minMax[2], args[0]);
1455           minMax[3] = Math.max(minMax[3], args[1]);
1456           break;
1457       }
1458     }
1459   }
1460 
1461   parseColorSpace({ cs, resources, localColorSpaceCache }) {
1462     return ColorSpace.parseAsync({
1463       cs,
1464       xref: this.xref,
1465       resources,
1466       pdfFunctionFactory: this._pdfFunctionFactory,
1467       localColorSpaceCache,
1468     }).catch(reason => {
1469       if (reason instanceof AbortException) {
1470         return null;
1471       }
1472       if (this.options.ignoreErrors) {
1473         warn(`parseColorSpace - ignoring ColorSpace: "${reason}".`);
1474         return null;
1475       }
1476       throw reason;
1477     });
1478   }
1479 
1480   parseShading({
1481     shading,
1482     resources,
1483     localColorSpaceCache,
1484     localShadingPatternCache,
1485   }) {
1486     // Shadings and patterns may be referenced by the same name but the resource
1487     // dictionary could be different so we can't use the name for the cache key.
1488     let id = localShadingPatternCache.get(shading);
1489     if (id) {
1490       return id;
1491     }
1492     let patternIR;
1493 
1494     try {
1495       const shadingFill = Pattern.parseShading(
1496         shading,
1497         this.xref,
1498         resources,
1499         this._pdfFunctionFactory,
1500         localColorSpaceCache
1501       );
1502       patternIR = shadingFill.getIR();
1503     } catch (reason) {
1504       if (reason instanceof AbortException) {
1505         return null;
1506       }
1507       if (this.options.ignoreErrors) {
1508         warn(`parseShading - ignoring shading: "${reason}".`);
1509 
1510         localShadingPatternCache.set(shading, null);
1511         return null;
1512       }
1513       throw reason;
1514     }
1515 
1516     id = `pattern_${this.idFactory.createObjId()}`;
1517     if (this.parsingType3Font) {
1518       id = `${this.idFactory.getDocId()}_type3_${id}`;
1519     }
1520     localShadingPatternCache.set(shading, id);
1521 
1522     if (this.parsingType3Font) {
1523       this.handler.send("commonobj", [id, "Pattern", patternIR]);
1524     } else {
1525       this.handler.send("obj", [id, this.pageIndex, "Pattern", patternIR]);
1526     }
1527     return id;
1528   }
1529 
1530   handleColorN(
1531     operatorList,
1532     fn,
1533     args,
1534     cs,
1535     patterns,
1536     resources,
1537     task,
1538     localColorSpaceCache,
1539     localTilingPatternCache,
1540     localShadingPatternCache
1541   ) {
1542     // compile tiling patterns
1543     const patternName = args.pop();
1544     // SCN/scn applies patterns along with normal colors
1545     if (patternName instanceof Name) {
1546       const rawPattern = patterns.getRaw(patternName.name);
1547 
1548       const localTilingPattern =
1549         rawPattern instanceof Ref &&
1550         localTilingPatternCache.getByRef(rawPattern);
1551       if (localTilingPattern) {
1552         try {
1553           const color = cs.base ? cs.base.getRgb(args, 0) : null;
1554           const tilingPatternIR = getTilingPatternIR(
1555             localTilingPattern.operatorListIR,
1556             localTilingPattern.dict,
1557             color
1558           );
1559           operatorList.addOp(fn, tilingPatternIR);
1560           return undefined;
1561         } catch {
1562           // Handle any errors during normal TilingPattern parsing.
1563         }
1564       }
1565 
1566       const pattern = this.xref.fetchIfRef(rawPattern);
1567       if (pattern) {
1568         const dict = pattern instanceof BaseStream ? pattern.dict : pattern;
1569         const typeNum = dict.get("PatternType");
1570 
1571         if (typeNum === PatternType.TILING) {
1572           const color = cs.base ? cs.base.getRgb(args, 0) : null;
1573           return this.handleTilingType(
1574             fn,
1575             color,
1576             resources,
1577             pattern,
1578             dict,
1579             operatorList,
1580             task,
1581             localTilingPatternCache
1582           );
1583         } else if (typeNum === PatternType.SHADING) {
1584           const shading = dict.get("Shading");
1585           const objId = this.parseShading({
1586             shading,
1587             resources,
1588             localColorSpaceCache,
1589             localShadingPatternCache,
1590           });
1591           if (objId) {
1592             const matrix = lookupMatrix(dict.getArray("Matrix"), null);
1593             operatorList.addOp(fn, ["Shading", objId, matrix]);
1594           }
1595           return undefined;
1596         }
1597         throw new FormatError(`Unknown PatternType: ${typeNum}`);
1598       }
1599     }
1600     throw new FormatError(`Unknown PatternName: ${patternName}`);
1601   }
1602 
1603   _parseVisibilityExpression(array, nestingCounter, currentResult) {
1604     const MAX_NESTING = 10;
1605     if (++nestingCounter > MAX_NESTING) {
1606       warn("Visibility expression is too deeply nested");
1607       return;
1608     }
1609     const length = array.length;
1610     const operator = this.xref.fetchIfRef(array[0]);
1611     if (length < 2 || !(operator instanceof Name)) {
1612       warn("Invalid visibility expression");
1613       return;
1614     }
1615     switch (operator.name) {
1616       case "And":
1617       case "Or":
1618       case "Not":
1619         currentResult.push(operator.name);
1620         break;
1621       default:
1622         warn(`Invalid operator ${operator.name} in visibility expression`);
1623         return;
1624     }
1625     for (let i = 1; i < length; i++) {
1626       const raw = array[i];
1627       const object = this.xref.fetchIfRef(raw);
1628       if (Array.isArray(object)) {
1629         const nestedResult = [];
1630         currentResult.push(nestedResult);
1631         // Recursively parse a subarray.
1632         this._parseVisibilityExpression(object, nestingCounter, nestedResult);
1633       } else if (raw instanceof Ref) {
1634         // Reference to an OCG dictionary.
1635         currentResult.push(raw.toString());
1636       }
1637     }
1638   }
1639 
1640   async parseMarkedContentProps(contentProperties, resources) {
1641     let optionalContent;
1642     if (contentProperties instanceof Name) {
1643       const properties = resources.get("Properties");
1644       optionalContent = properties.get(contentProperties.name);
1645     } else if (contentProperties instanceof Dict) {
1646       optionalContent = contentProperties;
1647     } else {
1648       throw new FormatError("Optional content properties malformed.");
1649     }
1650 
1651     const optionalContentType = optionalContent.get("Type")?.name;
1652     if (optionalContentType === "OCG") {
1653       return {
1654         type: optionalContentType,
1655         id: optionalContent.objId,
1656       };
1657     } else if (optionalContentType === "OCMD") {
1658       const expression = optionalContent.get("VE");
1659       if (Array.isArray(expression)) {
1660         const result = [];
1661         this._parseVisibilityExpression(expression, 0, result);
1662         if (result.length > 0) {
1663           return {
1664             type: "OCMD",
1665             expression: result,
1666           };
1667         }
1668       }
1669 
1670       const optionalContentGroups = optionalContent.get("OCGs");
1671       if (
1672         Array.isArray(optionalContentGroups) ||
1673         optionalContentGroups instanceof Dict
1674       ) {
1675         const groupIds = [];
1676         if (Array.isArray(optionalContentGroups)) {
1677           for (const ocg of optionalContentGroups) {
1678             groupIds.push(ocg.toString());
1679           }
1680         } else {
1681           // Dictionary, just use the obj id.
1682           groupIds.push(optionalContentGroups.objId);
1683         }
1684 
1685         return {
1686           type: optionalContentType,
1687           ids: groupIds,
1688           policy:
1689             optionalContent.get("P") instanceof Name
1690               ? optionalContent.get("P").name
1691               : null,
1692           expression: null,
1693         };
1694       } else if (optionalContentGroups instanceof Ref) {
1695         return {
1696           type: optionalContentType,
1697           id: optionalContentGroups.toString(),
1698         };
1699       }
1700     }
1701     return null;
1702   }
1703 
1704   getOperatorList({
1705     stream,
1706     task,
1707     resources,
1708     operatorList,
1709     initialState = null,
1710     fallbackFontDict = null,
1711   }) {
1712     // Ensure that `resources`/`initialState` is correctly initialized,
1713     // even if the provided parameter is e.g. `null`.
1714     resources ||= Dict.empty;
1715     initialState ||= new EvalState();
1716 
1717     if (!operatorList) {
1718       throw new Error('getOperatorList: missing "operatorList" parameter');
1719     }
1720 
1721     const self = this;
1722     const xref = this.xref;
1723     let parsingText = false;
1724     const localImageCache = new LocalImageCache();
1725     const localColorSpaceCache = new LocalColorSpaceCache();
1726     const localGStateCache = new LocalGStateCache();
1727     const localTilingPatternCache = new LocalTilingPatternCache();
1728     const localShadingPatternCache = new Map();
1729 
1730     const xobjs = resources.get("XObject") || Dict.empty;
1731     const patterns = resources.get("Pattern") || Dict.empty;
1732     const stateManager = new StateManager(initialState);
1733     const preprocessor = new EvaluatorPreprocessor(stream, xref, stateManager);
1734     const timeSlotManager = new TimeSlotManager();
1735 
1736     function closePendingRestoreOPS(argument) {
1737       for (let i = 0, ii = preprocessor.savedStatesDepth; i < ii; i++) {
1738         operatorList.addOp(OPS.restore, []);
1739       }
1740     }
1741 
1742     return new Promise(function promiseBody(resolve, reject) {
1743       const next = function (promise) {
1744         Promise.all([promise, operatorList.ready]).then(function () {
1745           try {
1746             promiseBody(resolve, reject);
1747           } catch (ex) {
1748             reject(ex);
1749           }
1750         }, reject);
1751       };
1752       task.ensureNotTerminated();
1753       timeSlotManager.reset();
1754 
1755       const operation = {};
1756       let stop, i, ii, cs, name, isValidName;
1757       while (!(stop = timeSlotManager.check())) {
1758         // The arguments parsed by read() are used beyond this loop, so we
1759         // cannot reuse the same array on each iteration. Therefore we pass
1760         // in |null| as the initial value (see the comment on
1761         // EvaluatorPreprocessor_read() for why).
1762         operation.args = null;
1763         if (!preprocessor.read(operation)) {
1764           break;
1765         }
1766         let args = operation.args;
1767         let fn = operation.fn;
1768 
1769         switch (fn | 0) {
1770           case OPS.paintXObject:
1771             // eagerly compile XForm objects
1772             isValidName = args[0] instanceof Name;
1773             name = args[0].name;
1774 
1775             if (isValidName) {
1776               const localImage = localImageCache.getByName(name);
1777               if (localImage) {
1778                 operatorList.addImageOps(
1779                   localImage.fn,
1780                   localImage.args,
1781                   localImage.optionalContent
1782                 );
1783 
1784                 incrementCachedImageMaskCount(localImage);
1785                 args = null;
1786                 continue;
1787               }
1788             }
1789 
1790             next(
1791               new Promise(function (resolveXObject, rejectXObject) {
1792                 if (!isValidName) {
1793                   throw new FormatError("XObject must be referred to by name.");
1794                 }
1795 
1796                 let xobj = xobjs.getRaw(name);
1797                 if (xobj instanceof Ref) {
1798                   const localImage =
1799                     localImageCache.getByRef(xobj) ||
1800                     self._regionalImageCache.getByRef(xobj);
1801                   if (localImage) {
1802                     operatorList.addImageOps(
1803                       localImage.fn,
1804                       localImage.args,
1805                       localImage.optionalContent
1806                     );
1807 
1808                     incrementCachedImageMaskCount(localImage);
1809                     resolveXObject();
1810                     return;
1811                   }
1812 
1813                   const globalImage = self.globalImageCache.getData(
1814                     xobj,
1815                     self.pageIndex
1816                   );
1817                   if (globalImage) {
1818                     operatorList.addDependency(globalImage.objId);
1819                     operatorList.addImageOps(
1820                       globalImage.fn,
1821                       globalImage.args,
1822                       globalImage.optionalContent
1823                     );
1824 
1825                     resolveXObject();
1826                     return;
1827                   }
1828 
1829                   xobj = xref.fetch(xobj);
1830                 }
1831 
1832                 if (!(xobj instanceof BaseStream)) {
1833                   throw new FormatError("XObject should be a stream");
1834                 }
1835 
1836                 const type = xobj.dict.get("Subtype");
1837                 if (!(type instanceof Name)) {
1838                   throw new FormatError("XObject should have a Name subtype");
1839                 }
1840 
1841                 if (type.name === "Form") {
1842                   stateManager.save();
1843                   self
1844                     .buildFormXObject(
1845                       resources,
1846                       xobj,
1847                       null,
1848                       operatorList,
1849                       task,
1850                       stateManager.state.clone(),
1851                       localColorSpaceCache
1852                     )
1853                     .then(function () {
1854                       stateManager.restore();
1855                       resolveXObject();
1856                     }, rejectXObject);
1857                   return;
1858                 } else if (type.name === "Image") {
1859                   self
1860                     .buildPaintImageXObject({
1861                       resources,
1862                       image: xobj,
1863                       operatorList,
1864                       cacheKey: name,
1865                       localImageCache,
1866                       localColorSpaceCache,
1867                     })
1868                     .then(resolveXObject, rejectXObject);
1869                   return;
1870                 } else if (type.name === "PS") {
1871                   // PostScript XObjects are unused when viewing documents.
1872                   // See section 4.7.1 of Adobe's PDF reference.
1873                   info("Ignored XObject subtype PS");
1874                 } else {
1875                   throw new FormatError(
1876                     `Unhandled XObject subtype ${type.name}`
1877                   );
1878                 }
1879                 resolveXObject();
1880               }).catch(function (reason) {
1881                 if (reason instanceof AbortException) {
1882                   return;
1883                 }
1884                 if (self.options.ignoreErrors) {
1885                   warn(`getOperatorList - ignoring XObject: "${reason}".`);
1886                   return;
1887                 }
1888                 throw reason;
1889               })
1890             );
1891             return;
1892           case OPS.setFont:
1893             var fontSize = args[1];
1894             // eagerly collect all fonts
1895             next(
1896               self
1897                 .handleSetFont(
1898                   resources,
1899                   args,
1900                   null,
1901                   operatorList,
1902                   task,
1903                   stateManager.state,
1904                   fallbackFontDict
1905                 )
1906                 .then(function (loadedName) {
1907                   operatorList.addDependency(loadedName);
1908                   operatorList.addOp(OPS.setFont, [loadedName, fontSize]);
1909                 })
1910             );
1911             return;
1912           case OPS.beginText:
1913             parsingText = true;
1914             break;
1915           case OPS.endText:
1916             parsingText = false;
1917             break;
1918           case OPS.endInlineImage:
1919             var cacheKey = args[0].cacheKey;
1920             if (cacheKey) {
1921               const localImage = localImageCache.getByName(cacheKey);
1922               if (localImage) {
1923                 operatorList.addImageOps(
1924                   localImage.fn,
1925                   localImage.args,
1926                   localImage.optionalContent
1927                 );
1928 
1929                 incrementCachedImageMaskCount(localImage);
1930                 args = null;
1931                 continue;
1932               }
1933             }
1934             next(
1935               self.buildPaintImageXObject({
1936                 resources,
1937                 image: args[0],
1938                 isInline: true,
1939                 operatorList,
1940                 cacheKey,
1941                 localImageCache,
1942                 localColorSpaceCache,
1943               })
1944             );
1945             return;
1946           case OPS.showText:
1947             if (!stateManager.state.font) {
1948               self.ensureStateFont(stateManager.state);
1949               continue;
1950             }
1951             args[0] = self.handleText(args[0], stateManager.state);
1952             break;
1953           case OPS.showSpacedText:
1954             if (!stateManager.state.font) {
1955               self.ensureStateFont(stateManager.state);
1956               continue;
1957             }
1958             var combinedGlyphs = [];
1959             var state = stateManager.state;
1960             for (const arrItem of args[0]) {
1961               if (typeof arrItem === "string") {
1962                 combinedGlyphs.push(...self.handleText(arrItem, state));
1963               } else if (typeof arrItem === "number") {
1964                 combinedGlyphs.push(arrItem);
1965               }
1966             }
1967             args[0] = combinedGlyphs;
1968             fn = OPS.showText;
1969             break;
1970           case OPS.nextLineShowText:
1971             if (!stateManager.state.font) {
1972               self.ensureStateFont(stateManager.state);
1973               continue;
1974             }
1975             operatorList.addOp(OPS.nextLine);
1976             args[0] = self.handleText(args[0], stateManager.state);
1977             fn = OPS.showText;
1978             break;
1979           case OPS.nextLineSetSpacingShowText:
1980             if (!stateManager.state.font) {
1981               self.ensureStateFont(stateManager.state);
1982               continue;
1983             }
1984             operatorList.addOp(OPS.nextLine);
1985             operatorList.addOp(OPS.setWordSpacing, [args.shift()]);
1986             operatorList.addOp(OPS.setCharSpacing, [args.shift()]);
1987             args[0] = self.handleText(args[0], stateManager.state);
1988             fn = OPS.showText;
1989             break;
1990           case OPS.setTextRenderingMode:
1991             stateManager.state.textRenderingMode = args[0];
1992             break;
1993 
1994           case OPS.setFillColorSpace: {
1995             const cachedColorSpace = ColorSpace.getCached(
1996               args[0],
1997               xref,
1998               localColorSpaceCache
1999             );
2000             if (cachedColorSpace) {
2001               stateManager.state.fillColorSpace = cachedColorSpace;
2002               continue;
2003             }
2004 
2005             next(
2006               self
2007                 .parseColorSpace({
2008                   cs: args[0],
2009                   resources,
2010                   localColorSpaceCache,
2011                 })
2012                 .then(function (colorSpace) {
2013                   if (colorSpace) {
2014                     stateManager.state.fillColorSpace = colorSpace;
2015                   }
2016                 })
2017             );
2018             return;
2019           }
2020           case OPS.setStrokeColorSpace: {
2021             const cachedColorSpace = ColorSpace.getCached(
2022               args[0],
2023               xref,
2024               localColorSpaceCache
2025             );
2026             if (cachedColorSpace) {
2027               stateManager.state.strokeColorSpace = cachedColorSpace;
2028               continue;
2029             }
2030 
2031             next(
2032               self
2033                 .parseColorSpace({
2034                   cs: args[0],
2035                   resources,
2036                   localColorSpaceCache,
2037                 })
2038                 .then(function (colorSpace) {
2039                   if (colorSpace) {
2040                     stateManager.state.strokeColorSpace = colorSpace;
2041                   }
2042                 })
2043             );
2044             return;
2045           }
2046           case OPS.setFillColor:
2047             cs = stateManager.state.fillColorSpace;
2048             args = cs.getRgb(args, 0);
2049             fn = OPS.setFillRGBColor;
2050             break;
2051           case OPS.setStrokeColor:
2052             cs = stateManager.state.strokeColorSpace;
2053             args = cs.getRgb(args, 0);
2054             fn = OPS.setStrokeRGBColor;
2055             break;
2056           case OPS.setFillGray:
2057             stateManager.state.fillColorSpace = ColorSpace.singletons.gray;
2058             args = ColorSpace.singletons.gray.getRgb(args, 0);
2059             fn = OPS.setFillRGBColor;
2060             break;
2061           case OPS.setStrokeGray:
2062             stateManager.state.strokeColorSpace = ColorSpace.singletons.gray;
2063             args = ColorSpace.singletons.gray.getRgb(args, 0);
2064             fn = OPS.setStrokeRGBColor;
2065             break;
2066           case OPS.setFillCMYKColor:
2067             stateManager.state.fillColorSpace = ColorSpace.singletons.cmyk;
2068             args = ColorSpace.singletons.cmyk.getRgb(args, 0);
2069             fn = OPS.setFillRGBColor;
2070             break;
2071           case OPS.setStrokeCMYKColor:
2072             stateManager.state.strokeColorSpace = ColorSpace.singletons.cmyk;
2073             args = ColorSpace.singletons.cmyk.getRgb(args, 0);
2074             fn = OPS.setStrokeRGBColor;
2075             break;
2076           case OPS.setFillRGBColor:
2077             stateManager.state.fillColorSpace = ColorSpace.singletons.rgb;
2078             args = ColorSpace.singletons.rgb.getRgb(args, 0);
2079             break;
2080           case OPS.setStrokeRGBColor:
2081             stateManager.state.strokeColorSpace = ColorSpace.singletons.rgb;
2082             args = ColorSpace.singletons.rgb.getRgb(args, 0);
2083             break;
2084           case OPS.setFillColorN:
2085             cs = stateManager.state.fillColorSpace;
2086             if (cs.name === "Pattern") {
2087               next(
2088                 self.handleColorN(
2089                   operatorList,
2090                   OPS.setFillColorN,
2091                   args,
2092                   cs,
2093                   patterns,
2094                   resources,
2095                   task,
2096                   localColorSpaceCache,
2097                   localTilingPatternCache,
2098                   localShadingPatternCache
2099                 )
2100               );
2101               return;
2102             }
2103             args = cs.getRgb(args, 0);
2104             fn = OPS.setFillRGBColor;
2105             break;
2106           case OPS.setStrokeColorN:
2107             cs = stateManager.state.strokeColorSpace;
2108             if (cs.name === "Pattern") {
2109               next(
2110                 self.handleColorN(
2111                   operatorList,
2112                   OPS.setStrokeColorN,
2113                   args,
2114                   cs,
2115                   patterns,
2116                   resources,
2117                   task,
2118                   localColorSpaceCache,
2119                   localTilingPatternCache,
2120                   localShadingPatternCache
2121                 )
2122               );
2123               return;
2124             }
2125             args = cs.getRgb(args, 0);
2126             fn = OPS.setStrokeRGBColor;
2127             break;
2128 
2129           case OPS.shadingFill:
2130             var shadingRes = resources.get("Shading");
2131             if (!shadingRes) {
2132               throw new FormatError("No shading resource found");
2133             }
2134 
2135             var shading = shadingRes.get(args[0].name);
2136             if (!shading) {
2137               throw new FormatError("No shading object found");
2138             }
2139             const patternId = self.parseShading({
2140               shading,
2141               resources,
2142               localColorSpaceCache,
2143               localShadingPatternCache,
2144             });
2145             if (!patternId) {
2146               continue;
2147             }
2148             args = [patternId];
2149             fn = OPS.shadingFill;
2150             break;
2151           case OPS.setGState:
2152             isValidName = args[0] instanceof Name;
2153             name = args[0].name;
2154 
2155             if (isValidName) {
2156               const localGStateObj = localGStateCache.getByName(name);
2157               if (localGStateObj) {
2158                 if (localGStateObj.length > 0) {
2159                   operatorList.addOp(OPS.setGState, [localGStateObj]);
2160                 }
2161                 args = null;
2162                 continue;
2163               }
2164             }
2165 
2166             next(
2167               new Promise(function (resolveGState, rejectGState) {
2168                 if (!isValidName) {
2169                   throw new FormatError("GState must be referred to by name.");
2170                 }
2171 
2172                 const extGState = resources.get("ExtGState");
2173                 if (!(extGState instanceof Dict)) {
2174                   throw new FormatError("ExtGState should be a dictionary.");
2175                 }
2176 
2177                 const gState = extGState.get(name);
2178                 // TODO: Attempt to lookup cached GStates by reference as well,
2179                 //       if and only if there are PDF documents where doing so
2180                 //       would significantly improve performance.
2181                 if (!(gState instanceof Dict)) {
2182                   throw new FormatError("GState should be a dictionary.");
2183                 }
2184 
2185                 self
2186                   .setGState({
2187                     resources,
2188                     gState,
2189                     operatorList,
2190                     cacheKey: name,
2191                     task,
2192                     stateManager,
2193                     localGStateCache,
2194                     localColorSpaceCache,
2195                   })
2196                   .then(resolveGState, rejectGState);
2197               }).catch(function (reason) {
2198                 if (reason instanceof AbortException) {
2199                   return;
2200                 }
2201                 if (self.options.ignoreErrors) {
2202                   warn(`getOperatorList - ignoring ExtGState: "${reason}".`);
2203                   return;
2204                 }
2205                 throw reason;
2206               })
2207             );
2208             return;
2209           case OPS.moveTo:
2210           case OPS.lineTo:
2211           case OPS.curveTo:
2212           case OPS.curveTo2:
2213           case OPS.curveTo3:
2214           case OPS.closePath:
2215           case OPS.rectangle:
2216             self.buildPath(operatorList, fn, args, parsingText);
2217             continue;
2218           case OPS.markPoint:
2219           case OPS.markPointProps:
2220           case OPS.beginCompat:
2221           case OPS.endCompat:
2222             // Ignore operators where the corresponding handlers are known to
2223             // be no-op in CanvasGraphics (display/canvas.js). This prevents
2224             // serialization errors and is also a bit more efficient.
2225             // We could also try to serialize all objects in a general way,
2226             // e.g. as done in https://github.com/mozilla/pdf.js/pull/6266,
2227             // but doing so is meaningless without knowing the semantics.
2228             continue;
2229           case OPS.beginMarkedContentProps:
2230             if (!(args[0] instanceof Name)) {
2231               warn(`Expected name for beginMarkedContentProps arg0=${args[0]}`);
2232               operatorList.addOp(OPS.beginMarkedContentProps, ["OC", null]);
2233               continue;
2234             }
2235             if (args[0].name === "OC") {
2236               next(
2237                 self
2238                   .parseMarkedContentProps(args[1], resources)
2239                   .then(data => {
2240                     operatorList.addOp(OPS.beginMarkedContentProps, [
2241                       "OC",
2242                       data,
2243                     ]);
2244                   })
2245                   .catch(reason => {
2246                     if (reason instanceof AbortException) {
2247                       return;
2248                     }
2249                     if (self.options.ignoreErrors) {
2250                       warn(
2251                         `getOperatorList - ignoring beginMarkedContentProps: "${reason}".`
2252                       );
2253                       operatorList.addOp(OPS.beginMarkedContentProps, [
2254                         "OC",
2255                         null,
2256                       ]);
2257                       return;
2258                     }
2259                     throw reason;
2260                   })
2261               );
2262               return;
2263             }
2264             // Other marked content types aren't supported yet.
2265             args = [
2266               args[0].name,
2267               args[1] instanceof Dict ? args[1].get("MCID") : null,
2268             ];
2269 
2270             break;
2271           case OPS.beginMarkedContent:
2272           case OPS.endMarkedContent:
2273           default:
2274             // Note: Ignore the operator if it has `Dict` arguments, since
2275             // those are non-serializable, otherwise postMessage will throw
2276             // "An object could not be cloned.".
2277             if (args !== null) {
2278               for (i = 0, ii = args.length; i < ii; i++) {
2279                 if (args[i] instanceof Dict) {
2280                   break;
2281                 }
2282               }
2283               if (i < ii) {
2284                 warn("getOperatorList - ignoring operator: " + fn);
2285                 continue;
2286               }
2287             }
2288         }
2289         operatorList.addOp(fn, args);
2290       }
2291       if (stop) {
2292         next(deferred);
2293         return;
2294       }
2295       // Some PDFs don't close all restores inside object/form.
2296       // Closing those for them.
2297       closePendingRestoreOPS();
2298       resolve();
2299     }).catch(reason => {
2300       if (reason instanceof AbortException) {
2301         return;
2302       }
2303       if (this.options.ignoreErrors) {
2304         warn(
2305           `getOperatorList - ignoring errors during "${task.name}" ` +
2306             `task: "${reason}".`
2307         );
2308 
2309         closePendingRestoreOPS();
2310         return;
2311       }
2312       throw reason;
2313     });
2314   }
2315 
2316   getTextContent({
2317     stream,
2318     task,
2319     resources,
2320     stateManager = null,
2321     includeMarkedContent = false,
2322     sink,
2323     seenStyles = new Set(),
2324     viewBox,
2325     lang = null,
2326     markedContentData = null,
2327     disableNormalization = false,
2328     keepWhiteSpace = false,
2329   }) {
2330     // Ensure that `resources`/`stateManager` is correctly initialized,
2331     // even if the provided parameter is e.g. `null`.
2332     resources ||= Dict.empty;
2333     stateManager ||= new StateManager(new TextState());
2334 
2335     if (includeMarkedContent) {
2336       markedContentData ||= { level: 0 };
2337     }
2338 
2339     const textContent = {
2340       items: [],
2341       styles: Object.create(null),
2342       lang,
2343     };
2344     const textContentItem = {
2345       initialized: false,
2346       str: [],
2347       totalWidth: 0,
2348       totalHeight: 0,
2349       width: 0,
2350       height: 0,
2351       vertical: false,
2352       prevTransform: null,
2353       textAdvanceScale: 0,
2354       spaceInFlowMin: 0,
2355       spaceInFlowMax: 0,
2356       trackingSpaceMin: Infinity,
2357       negativeSpaceMax: -Infinity,
2358       notASpace: -Infinity,
2359       transform: null,
2360       fontName: null,
2361       hasEOL: false,
2362     };
2363 
2364     // Use a circular buffer (length === 2) to save the last chars in the
2365     // text stream.
2366     // This implementation of the circular buffer is using a fixed array
2367     // and the position of the next element:
2368     // function addElement(x) {
2369     //   buffer[pos] = x;
2370     //   pos = (pos + 1) % buffer.length;
2371     // }
2372     // It's a way faster than:
2373     // function addElement(x) {
2374     //   buffer.push(x);
2375     //   buffer.shift();
2376     // }
2377     //
2378     // It's useful to know when we need to add a whitespace in the
2379     // text chunk.
2380     const twoLastChars = [" ", " "];
2381     let twoLastCharsPos = 0;
2382 
2383     /**
2384      * Save the last char.
2385      * @param {string} char
2386      * @returns {boolean} true when the two last chars before adding the new one
2387      * are a non-whitespace followed by a whitespace.
2388      */
2389     function saveLastChar(char) {
2390       const nextPos = (twoLastCharsPos + 1) % 2;
2391       const ret =
2392         twoLastChars[twoLastCharsPos] !== " " && twoLastChars[nextPos] === " ";
2393       twoLastChars[twoLastCharsPos] = char;
2394       twoLastCharsPos = nextPos;
2395 
2396       return !keepWhiteSpace && ret;
2397     }
2398 
2399     function shouldAddWhitepsace() {
2400       return (
2401         !keepWhiteSpace &&
2402         twoLastChars[twoLastCharsPos] !== " " &&
2403         twoLastChars[(twoLastCharsPos + 1) % 2] === " "
2404       );
2405     }
2406 
2407     function resetLastChars() {
2408       twoLastChars[0] = twoLastChars[1] = " ";
2409       twoLastCharsPos = 0;
2410     }
2411 
2412     // Used in addFakeSpaces.
2413 
2414     // A white <= fontSize * TRACKING_SPACE_FACTOR is a tracking space
2415     // so it doesn't count as a space.
2416     const TRACKING_SPACE_FACTOR = 0.102;
2417 
2418     // When a white <= fontSize * NOT_A_SPACE_FACTOR, there is no space
2419     // even if one is present in the text stream.
2420     const NOT_A_SPACE_FACTOR = 0.03;
2421 
2422     // A negative white < fontSize * NEGATIVE_SPACE_FACTOR induces
2423     // a break (a new chunk of text is created).
2424     // It doesn't change anything when the text is copied but
2425     // it improves potential mismatch between text layer and canvas.
2426     const NEGATIVE_SPACE_FACTOR = -0.2;
2427 
2428     // A white with a width in [fontSize * MIN_FACTOR; fontSize * MAX_FACTOR]
2429     // is a space which will be inserted in the current flow of words.
2430     // If the width is outside of this range then the flow is broken
2431     // (which means a new span in the text layer).
2432     // It's useful to adjust the best as possible the span in the layer
2433     // to what is displayed in the canvas.
2434     const SPACE_IN_FLOW_MIN_FACTOR = 0.102;
2435     const SPACE_IN_FLOW_MAX_FACTOR = 0.6;
2436 
2437     // If a char is too high/too low compared to the previous we just create
2438     // a new chunk.
2439     // If the advance isn't in the +/-VERTICAL_SHIFT_RATIO * height range then
2440     // a new chunk is created.
2441     const VERTICAL_SHIFT_RATIO = 0.25;
2442 
2443     const self = this;
2444     const xref = this.xref;
2445     const showSpacedTextBuffer = [];
2446 
2447     // The xobj is parsed iff it's needed, e.g. if there is a `DO` cmd.
2448     let xobjs = null;
2449     const emptyXObjectCache = new LocalImageCache();
2450     const emptyGStateCache = new LocalGStateCache();
2451 
2452     const preprocessor = new EvaluatorPreprocessor(stream, xref, stateManager);
2453 
2454     let textState;
2455 
2456     function pushWhitespace({
2457       width = 0,
2458       height = 0,
2459       transform = textContentItem.prevTransform,
2460       fontName = textContentItem.fontName,
2461     }) {
2462       textContent.items.push({
2463         str: " ",
2464         dir: "ltr",
2465         width,
2466         height,
2467         transform,
2468         fontName,
2469         hasEOL: false,
2470       });
2471     }
2472 
2473     function getCurrentTextTransform() {
2474       // 9.4.4 Text Space Details
2475       const font = textState.font;
2476       const tsm = [
2477         textState.fontSize * textState.textHScale,
2478         0,
2479         0,
2480         textState.fontSize,
2481         0,
2482         textState.textRise,
2483       ];
2484 
2485       if (
2486         font.isType3Font &&
2487         (textState.fontSize <= 1 || font.isCharBBox) &&
2488         !isArrayEqual(textState.fontMatrix, FONT_IDENTITY_MATRIX)
2489       ) {
2490         const glyphHeight = font.bbox[3] - font.bbox[1];
2491         if (glyphHeight > 0) {
2492           tsm[3] *= glyphHeight * textState.fontMatrix[3];
2493         }
2494       }
2495 
2496       return Util.transform(
2497         textState.ctm,
2498         Util.transform(textState.textMatrix, tsm)
2499       );
2500     }
2501 
2502     function ensureTextContentItem() {
2503       if (textContentItem.initialized) {
2504         return textContentItem;
2505       }
2506       const { font, loadedName } = textState;
2507       if (!seenStyles.has(loadedName)) {
2508         seenStyles.add(loadedName);
2509         textContent.styles[loadedName] = {
2510           fontFamily: font.fallbackName,
2511           ascent: font.ascent,
2512           descent: font.descent,
2513           vertical: font.vertical,
2514         };
2515         if (self.options.fontExtraProperties && font.systemFontInfo) {
2516           const style = textContent.styles[loadedName];
2517           style.fontSubstitution = font.systemFontInfo.css;
2518           style.fontSubstitutionLoadedName = font.systemFontInfo.loadedName;
2519         }
2520       }
2521       textContentItem.fontName = loadedName;
2522 
2523       const trm = (textContentItem.transform = getCurrentTextTransform());
2524       if (!font.vertical) {
2525         textContentItem.width = textContentItem.totalWidth = 0;
2526         textContentItem.height = textContentItem.totalHeight = Math.hypot(
2527           trm[2],
2528           trm[3]
2529         );
2530         textContentItem.vertical = false;
2531       } else {
2532         textContentItem.width = textContentItem.totalWidth = Math.hypot(
2533           trm[0],
2534           trm[1]
2535         );
2536         textContentItem.height = textContentItem.totalHeight = 0;
2537         textContentItem.vertical = true;
2538       }
2539 
2540       const scaleLineX = Math.hypot(
2541         textState.textLineMatrix[0],
2542         textState.textLineMatrix[1]
2543       );
2544       const scaleCtmX = Math.hypot(textState.ctm[0], textState.ctm[1]);
2545       textContentItem.textAdvanceScale = scaleCtmX * scaleLineX;
2546 
2547       const { fontSize } = textState;
2548       textContentItem.trackingSpaceMin = fontSize * TRACKING_SPACE_FACTOR;
2549       textContentItem.notASpace = fontSize * NOT_A_SPACE_FACTOR;
2550       textContentItem.negativeSpaceMax = fontSize * NEGATIVE_SPACE_FACTOR;
2551       textContentItem.spaceInFlowMin = fontSize * SPACE_IN_FLOW_MIN_FACTOR;
2552       textContentItem.spaceInFlowMax = fontSize * SPACE_IN_FLOW_MAX_FACTOR;
2553       textContentItem.hasEOL = false;
2554 
2555       textContentItem.initialized = true;
2556       return textContentItem;
2557     }
2558 
2559     function updateAdvanceScale() {
2560       if (!textContentItem.initialized) {
2561         return;
2562       }
2563 
2564       const scaleLineX = Math.hypot(
2565         textState.textLineMatrix[0],
2566         textState.textLineMatrix[1]
2567       );
2568       const scaleCtmX = Math.hypot(textState.ctm[0], textState.ctm[1]);
2569       const scaleFactor = scaleCtmX * scaleLineX;
2570       if (scaleFactor === textContentItem.textAdvanceScale) {
2571         return;
2572       }
2573 
2574       if (!textContentItem.vertical) {
2575         textContentItem.totalWidth +=
2576           textContentItem.width * textContentItem.textAdvanceScale;
2577         textContentItem.width = 0;
2578       } else {
2579         textContentItem.totalHeight +=
2580           textContentItem.height * textContentItem.textAdvanceScale;
2581         textContentItem.height = 0;
2582       }
2583 
2584       textContentItem.textAdvanceScale = scaleFactor;
2585     }
2586 
2587     function runBidiTransform(textChunk) {
2588       let text = textChunk.str.join("");
2589       if (!disableNormalization) {
2590         text = normalizeUnicode(text);
2591       }
2592       const bidiResult = bidi(text, -1, textChunk.vertical);
2593       return {
2594         str: bidiResult.str,
2595         dir: bidiResult.dir,
2596         width: Math.abs(textChunk.totalWidth),
2597         height: Math.abs(textChunk.totalHeight),
2598         transform: textChunk.transform,
2599         fontName: textChunk.fontName,
2600         hasEOL: textChunk.hasEOL,
2601       };
2602     }
2603 
2604     async function handleSetFont(fontName, fontRef) {
2605       const translated = await self.loadFont(fontName, fontRef, resources);
2606 
2607       if (translated.font.isType3Font) {
2608         try {
2609           await translated.loadType3Data(self, resources, task);
2610         } catch {
2611           // Ignore Type3-parsing errors, since we only use `loadType3Data`
2612           // here to ensure that we'll always obtain a useful /FontBBox.
2613         }
2614       }
2615 
2616       textState.loadedName = translated.loadedName;
2617       textState.font = translated.font;
2618       textState.fontMatrix = translated.font.fontMatrix || FONT_IDENTITY_MATRIX;
2619     }
2620 
2621     function applyInverseRotation(x, y, matrix) {
2622       const scale = Math.hypot(matrix[0], matrix[1]);
2623       return [
2624         (matrix[0] * x + matrix[1] * y) / scale,
2625         (matrix[2] * x + matrix[3] * y) / scale,
2626       ];
2627     }
2628 
2629     function compareWithLastPosition(glyphWidth) {
2630       const currentTransform = getCurrentTextTransform();
2631       let posX = currentTransform[4];
2632       let posY = currentTransform[5];
2633 
2634       // Check if the glyph is in the viewbox.
2635       if (textState.font?.vertical) {
2636         if (
2637           posX < viewBox[0] ||
2638           posX > viewBox[2] ||
2639           posY + glyphWidth < viewBox[1] ||
2640           posY > viewBox[3]
2641         ) {
2642           return false;
2643         }
2644       } else if (
2645         posX + glyphWidth < viewBox[0] ||
2646         posX > viewBox[2] ||
2647         posY < viewBox[1] ||
2648         posY > viewBox[3]
2649       ) {
2650         return false;
2651       }
2652 
2653       if (!textState.font || !textContentItem.prevTransform) {
2654         return true;
2655       }
2656 
2657       let lastPosX = textContentItem.prevTransform[4];
2658       let lastPosY = textContentItem.prevTransform[5];
2659 
2660       if (lastPosX === posX && lastPosY === posY) {
2661         return true;
2662       }
2663 
2664       let rotate = -1;
2665       // Take into account the rotation is the current transform.
2666       if (
2667         currentTransform[0] &&
2668         currentTransform[1] === 0 &&
2669         currentTransform[2] === 0
2670       ) {
2671         rotate = currentTransform[0] > 0 ? 0 : 180;
2672       } else if (
2673         currentTransform[1] &&
2674         currentTransform[0] === 0 &&
2675         currentTransform[3] === 0
2676       ) {
2677         rotate = currentTransform[1] > 0 ? 90 : 270;
2678       }
2679 
2680       switch (rotate) {
2681         case 0:
2682           break;
2683         case 90:
2684           [posX, posY] = [posY, posX];
2685           [lastPosX, lastPosY] = [lastPosY, lastPosX];
2686           break;
2687         case 180:
2688           [posX, posY, lastPosX, lastPosY] = [
2689             -posX,
2690             -posY,
2691             -lastPosX,
2692             -lastPosY,
2693           ];
2694           break;
2695         case 270:
2696           [posX, posY] = [-posY, -posX];
2697           [lastPosX, lastPosY] = [-lastPosY, -lastPosX];
2698           break;
2699         default:
2700           // This is not a 0, 90, 180, 270 rotation so:
2701           //  - remove the scale factor from the matrix to get a rotation matrix
2702           //  - apply the inverse (which is the transposed) to the positions
2703           // and we can then compare positions of the glyphes to detect
2704           // a whitespace.
2705           [posX, posY] = applyInverseRotation(posX, posY, currentTransform);
2706           [lastPosX, lastPosY] = applyInverseRotation(
2707             lastPosX,
2708             lastPosY,
2709             textContentItem.prevTransform
2710           );
2711       }
2712 
2713       if (textState.font.vertical) {
2714         const advanceY = (lastPosY - posY) / textContentItem.textAdvanceScale;
2715         const advanceX = posX - lastPosX;
2716 
2717         // When the total height of the current chunk is negative
2718         // then we're writing from bottom to top.
2719         const textOrientation = Math.sign(textContentItem.height);
2720         if (advanceY < textOrientation * textContentItem.negativeSpaceMax) {
2721           if (
2722             Math.abs(advanceX) >
2723             0.5 * textContentItem.width /* not the same column */
2724           ) {
2725             appendEOL();
2726             return true;
2727           }
2728 
2729           resetLastChars();
2730           flushTextContentItem();
2731           return true;
2732         }
2733 
2734         if (Math.abs(advanceX) > textContentItem.width) {
2735           appendEOL();
2736           return true;
2737         }
2738 
2739         if (advanceY <= textOrientation * textContentItem.notASpace) {
2740           // The real spacing between 2 consecutive chars is thin enough to be
2741           // considered a non-space.
2742           resetLastChars();
2743         }
2744 
2745         if (advanceY <= textOrientation * textContentItem.trackingSpaceMin) {
2746           if (shouldAddWhitepsace()) {
2747             // The space is very thin, hence it deserves to have its own span in
2748             // order to avoid too much shift between the canvas and the text
2749             // layer.
2750             resetLastChars();
2751             flushTextContentItem();
2752             pushWhitespace({ height: Math.abs(advanceY) });
2753           } else {
2754             textContentItem.height += advanceY;
2755           }
2756         } else if (
2757           !addFakeSpaces(
2758             advanceY,
2759             textContentItem.prevTransform,
2760             textOrientation
2761           )
2762         ) {
2763           if (textContentItem.str.length === 0) {
2764             resetLastChars();
2765             pushWhitespace({ height: Math.abs(advanceY) });
2766           } else {
2767             textContentItem.height += advanceY;
2768           }
2769         }
2770 
2771         if (Math.abs(advanceX) > textContentItem.width * VERTICAL_SHIFT_RATIO) {
2772           flushTextContentItem();
2773         }
2774 
2775         return true;
2776       }
2777 
2778       const advanceX = (posX - lastPosX) / textContentItem.textAdvanceScale;
2779       const advanceY = posY - lastPosY;
2780 
2781       // When the total width of the current chunk is negative
2782       // then we're writing from right to left.
2783       const textOrientation = Math.sign(textContentItem.width);
2784       if (advanceX < textOrientation * textContentItem.negativeSpaceMax) {
2785         if (
2786           Math.abs(advanceY) >
2787           0.5 * textContentItem.height /* not the same line */
2788         ) {
2789           appendEOL();
2790           return true;
2791         }
2792 
2793         // We're moving back so in case the last char was a whitespace
2794         // we cancel it: it doesn't make sense to insert it.
2795         resetLastChars();
2796         flushTextContentItem();
2797         return true;
2798       }
2799 
2800       if (Math.abs(advanceY) > textContentItem.height) {
2801         appendEOL();
2802         return true;
2803       }
2804 
2805       if (advanceX <= textOrientation * textContentItem.notASpace) {
2806         // The real spacing between 2 consecutive chars is thin enough to be
2807         // considered a non-space.
2808         resetLastChars();
2809       }
2810 
2811       if (advanceX <= textOrientation * textContentItem.trackingSpaceMin) {
2812         if (shouldAddWhitepsace()) {
2813           // The space is very thin, hence it deserves to have its own span in
2814           // order to avoid too much shift between the canvas and the text
2815           // layer.
2816           resetLastChars();
2817           flushTextContentItem();
2818           pushWhitespace({ width: Math.abs(advanceX) });
2819         } else {
2820           textContentItem.width += advanceX;
2821         }
2822       } else if (
2823         !addFakeSpaces(advanceX, textContentItem.prevTransform, textOrientation)
2824       ) {
2825         if (textContentItem.str.length === 0) {
2826           resetLastChars();
2827           pushWhitespace({ width: Math.abs(advanceX) });
2828         } else {
2829           textContentItem.width += advanceX;
2830         }
2831       }
2832 
2833       if (Math.abs(advanceY) > textContentItem.height * VERTICAL_SHIFT_RATIO) {
2834         flushTextContentItem();
2835       }
2836 
2837       return true;
2838     }
2839 
2840     function buildTextContentItem({ chars, extraSpacing }) {
2841       const font = textState.font;
2842       if (!chars) {
2843         // Just move according to the space we have.
2844         const charSpacing = textState.charSpacing + extraSpacing;
2845         if (charSpacing) {
2846           if (!font.vertical) {
2847             textState.translateTextMatrix(
2848               charSpacing * textState.textHScale,
2849               0
2850             );
2851           } else {
2852             textState.translateTextMatrix(0, -charSpacing);
2853           }
2854         }
2855 
2856         if (keepWhiteSpace) {
2857           compareWithLastPosition(0);
2858         }
2859 
2860         return;
2861       }
2862 
2863       const glyphs = font.charsToGlyphs(chars);
2864       const scale = textState.fontMatrix[0] * textState.fontSize;
2865 
2866       for (let i = 0, ii = glyphs.length; i < ii; i++) {
2867         const glyph = glyphs[i];
2868         const { category } = glyph;
2869 
2870         if (category.isInvisibleFormatMark) {
2871           continue;
2872         }
2873         let charSpacing =
2874           textState.charSpacing + (i + 1 === ii ? extraSpacing : 0);
2875 
2876         let glyphWidth = glyph.width;
2877         if (font.vertical) {
2878           glyphWidth = glyph.vmetric ? glyph.vmetric[0] : -glyphWidth;
2879         }
2880         let scaledDim = glyphWidth * scale;
2881 
2882         if (!keepWhiteSpace && category.isWhitespace) {
2883           // Don't push a " " in the textContentItem
2884           // (except when it's between two non-spaces chars),
2885           // it will be done (if required) in next call to
2886           // compareWithLastPosition.
2887           // This way we can merge real spaces and spaces due to cursor moves.
2888           if (!font.vertical) {
2889             charSpacing += scaledDim + textState.wordSpacing;
2890             textState.translateTextMatrix(
2891               charSpacing * textState.textHScale,
2892               0
2893             );
2894           } else {
2895             charSpacing += -scaledDim + textState.wordSpacing;
2896             textState.translateTextMatrix(0, -charSpacing);
2897           }
2898           saveLastChar(" ");
2899           continue;
2900         }
2901 
2902         if (
2903           !category.isZeroWidthDiacritic &&
2904           !compareWithLastPosition(scaledDim)
2905         ) {
2906           // The glyph is not in page so just skip it but move the cursor.
2907           if (!font.vertical) {
2908             textState.translateTextMatrix(scaledDim * textState.textHScale, 0);
2909           } else {
2910             textState.translateTextMatrix(0, scaledDim);
2911           }
2912           continue;
2913         }
2914 
2915         // Must be called after compareWithLastPosition because
2916         // the textContentItem could have been flushed.
2917         const textChunk = ensureTextContentItem();
2918         if (category.isZeroWidthDiacritic) {
2919           scaledDim = 0;
2920         }
2921 
2922         if (!font.vertical) {
2923           scaledDim *= textState.textHScale;
2924           textState.translateTextMatrix(scaledDim, 0);
2925           textChunk.width += scaledDim;
2926         } else {
2927           textState.translateTextMatrix(0, scaledDim);
2928           scaledDim = Math.abs(scaledDim);
2929           textChunk.height += scaledDim;
2930         }
2931 
2932         if (scaledDim) {
2933           // Save the position of the last visible character.
2934           textChunk.prevTransform = getCurrentTextTransform();
2935         }
2936 
2937         const glyphUnicode = glyph.unicode;
2938         if (saveLastChar(glyphUnicode)) {
2939           // The two last chars are a non-whitespace followed by a whitespace
2940           // and then this non-whitespace, so we insert a whitespace here.
2941           // Replaces all whitespaces with standard spaces (0x20), to avoid
2942           // alignment issues between the textLayer and the canvas if the text
2943           // contains e.g. tabs (fixes issue6612.pdf).
2944           textChunk.str.push(" ");
2945         }
2946         textChunk.str.push(glyphUnicode);
2947 
2948         if (charSpacing) {
2949           if (!font.vertical) {
2950             textState.translateTextMatrix(
2951               charSpacing * textState.textHScale,
2952               0
2953             );
2954           } else {
2955             textState.translateTextMatrix(0, -charSpacing);
2956           }
2957         }
2958       }
2959     }
2960 
2961     function appendEOL() {
2962       resetLastChars();
2963       if (textContentItem.initialized) {
2964         textContentItem.hasEOL = true;
2965         flushTextContentItem();
2966       } else {
2967         textContent.items.push({
2968           str: "",
2969           dir: "ltr",
2970           width: 0,
2971           height: 0,
2972           transform: getCurrentTextTransform(),
2973           fontName: textState.loadedName,
2974           hasEOL: true,
2975         });
2976       }
2977     }
2978 
2979     function addFakeSpaces(width, transf, textOrientation) {
2980       if (
2981         textOrientation * textContentItem.spaceInFlowMin <= width &&
2982         width <= textOrientation * textContentItem.spaceInFlowMax
2983       ) {
2984         if (textContentItem.initialized) {
2985           resetLastChars();
2986           textContentItem.str.push(" ");
2987         }
2988         return false;
2989       }
2990 
2991       const fontName = textContentItem.fontName;
2992 
2993       let height = 0;
2994       if (textContentItem.vertical) {
2995         height = width;
2996         width = 0;
2997       }
2998 
2999       flushTextContentItem();
3000       resetLastChars();
3001       pushWhitespace({
3002         width: Math.abs(width),
3003         height: Math.abs(height),
3004         transform: transf || getCurrentTextTransform(),
3005         fontName,
3006       });
3007 
3008       return true;
3009     }
3010 
3011     function flushTextContentItem() {
3012       if (!textContentItem.initialized || !textContentItem.str) {
3013         return;
3014       }
3015 
3016       // Do final text scaling.
3017       if (!textContentItem.vertical) {
3018         textContentItem.totalWidth +=
3019           textContentItem.width * textContentItem.textAdvanceScale;
3020       } else {
3021         textContentItem.totalHeight +=
3022           textContentItem.height * textContentItem.textAdvanceScale;
3023       }
3024 
3025       textContent.items.push(runBidiTransform(textContentItem));
3026       textContentItem.initialized = false;
3027       textContentItem.str.length = 0;
3028     }
3029 
3030     function enqueueChunk(batch = false) {
3031       const length = textContent.items.length;
3032       if (length === 0) {
3033         return;
3034       }
3035       if (batch && length < TEXT_CHUNK_BATCH_SIZE) {
3036         return;
3037       }
3038       sink.enqueue(textContent, length);
3039       textContent.items = [];
3040       textContent.styles = Object.create(null);
3041     }
3042 
3043     const timeSlotManager = new TimeSlotManager();
3044 
3045     return new Promise(function promiseBody(resolve, reject) {
3046       const next = function (promise) {
3047         enqueueChunk(/* batch = */ true);
3048         Promise.all([promise, sink.ready]).then(function () {
3049           try {
3050             promiseBody(resolve, reject);
3051           } catch (ex) {
3052             reject(ex);
3053           }
3054         }, reject);
3055       };
3056       task.ensureNotTerminated();
3057       timeSlotManager.reset();
3058 
3059       const operation = {};
3060       let stop,
3061         args = [];
3062       while (!(stop = timeSlotManager.check())) {
3063         // The arguments parsed by read() are not used beyond this loop, so
3064         // we can reuse the same array on every iteration, thus avoiding
3065         // unnecessary allocations.
3066         args.length = 0;
3067         operation.args = args;
3068         if (!preprocessor.read(operation)) {
3069           break;
3070         }
3071 
3072         const previousState = textState;
3073         textState = stateManager.state;
3074         const fn = operation.fn;
3075         args = operation.args;
3076 
3077         switch (fn | 0) {
3078           case OPS.setFont:
3079             // Optimization to ignore multiple identical Tf commands.
3080             var fontNameArg = args[0].name,
3081               fontSizeArg = args[1];
3082             if (
3083               textState.font &&
3084               fontNameArg === textState.fontName &&
3085               fontSizeArg === textState.fontSize
3086             ) {
3087               break;
3088             }
3089 
3090             flushTextContentItem();
3091             textState.fontName = fontNameArg;
3092             textState.fontSize = fontSizeArg;
3093             next(handleSetFont(fontNameArg, null));
3094             return;
3095           case OPS.setTextRise:
3096             textState.textRise = args[0];
3097             break;
3098           case OPS.setHScale:
3099             textState.textHScale = args[0] / 100;
3100             break;
3101           case OPS.setLeading:
3102             textState.leading = args[0];
3103             break;
3104           case OPS.moveText:
3105             textState.translateTextLineMatrix(args[0], args[1]);
3106             textState.textMatrix = textState.textLineMatrix.slice();
3107             break;
3108           case OPS.setLeadingMoveText:
3109             textState.leading = -args[1];
3110             textState.translateTextLineMatrix(args[0], args[1]);
3111             textState.textMatrix = textState.textLineMatrix.slice();
3112             break;
3113           case OPS.nextLine:
3114             textState.carriageReturn();
3115             break;
3116           case OPS.setTextMatrix:
3117             textState.setTextMatrix(
3118               args[0],
3119               args[1],
3120               args[2],
3121               args[3],
3122               args[4],
3123               args[5]
3124             );
3125             textState.setTextLineMatrix(
3126               args[0],
3127               args[1],
3128               args[2],
3129               args[3],
3130               args[4],
3131               args[5]
3132             );
3133             updateAdvanceScale();
3134             break;
3135           case OPS.setCharSpacing:
3136             textState.charSpacing = args[0];
3137             break;
3138           case OPS.setWordSpacing:
3139             textState.wordSpacing = args[0];
3140             break;
3141           case OPS.beginText:
3142             textState.textMatrix = IDENTITY_MATRIX.slice();
3143             textState.textLineMatrix = IDENTITY_MATRIX.slice();
3144             break;
3145           case OPS.showSpacedText:
3146             if (!stateManager.state.font) {
3147               self.ensureStateFont(stateManager.state);
3148               continue;
3149             }
3150 
3151             const spaceFactor =
3152               ((textState.font.vertical ? 1 : -1) * textState.fontSize) / 1000;
3153             const elements = args[0];
3154             for (let i = 0, ii = elements.length; i < ii; i++) {
3155               const item = elements[i];
3156               if (typeof item === "string") {
3157                 showSpacedTextBuffer.push(item);
3158               } else if (typeof item === "number" && item !== 0) {
3159                 // PDF Specification 5.3.2 states:
3160                 // The number is expressed in thousandths of a unit of text
3161                 // space.
3162                 // This amount is subtracted from the current horizontal or
3163                 // vertical coordinate, depending on the writing mode.
3164                 // In the default coordinate system, a positive adjustment
3165                 // has the effect of moving the next glyph painted either to
3166                 // the left or down by the given amount.
3167                 const str = showSpacedTextBuffer.join("");
3168                 showSpacedTextBuffer.length = 0;
3169                 buildTextContentItem({
3170                   chars: str,
3171                   extraSpacing: item * spaceFactor,
3172                 });
3173               }
3174             }
3175 
3176             if (showSpacedTextBuffer.length > 0) {
3177               const str = showSpacedTextBuffer.join("");
3178               showSpacedTextBuffer.length = 0;
3179               buildTextContentItem({
3180                 chars: str,
3181                 extraSpacing: 0,
3182               });
3183             }
3184             break;
3185           case OPS.showText:
3186             if (!stateManager.state.font) {
3187               self.ensureStateFont(stateManager.state);
3188               continue;
3189             }
3190             buildTextContentItem({
3191               chars: args[0],
3192               extraSpacing: 0,
3193             });
3194             break;
3195           case OPS.nextLineShowText:
3196             if (!stateManager.state.font) {
3197               self.ensureStateFont(stateManager.state);
3198               continue;
3199             }
3200             textState.carriageReturn();
3201             buildTextContentItem({
3202               chars: args[0],
3203               extraSpacing: 0,
3204             });
3205             break;
3206           case OPS.nextLineSetSpacingShowText:
3207             if (!stateManager.state.font) {
3208               self.ensureStateFont(stateManager.state);
3209               continue;
3210             }
3211             textState.wordSpacing = args[0];
3212             textState.charSpacing = args[1];
3213             textState.carriageReturn();
3214             buildTextContentItem({
3215               chars: args[2],
3216               extraSpacing: 0,
3217             });
3218             break;
3219           case OPS.paintXObject:
3220             flushTextContentItem();
3221             if (!xobjs) {
3222               xobjs = resources.get("XObject") || Dict.empty;
3223             }
3224 
3225             var isValidName = args[0] instanceof Name;
3226             var name = args[0].name;
3227 
3228             if (isValidName && emptyXObjectCache.getByName(name)) {
3229               break;
3230             }
3231 
3232             next(
3233               new Promise(function (resolveXObject, rejectXObject) {
3234                 if (!isValidName) {
3235                   throw new FormatError("XObject must be referred to by name.");
3236                 }
3237 
3238                 let xobj = xobjs.getRaw(name);
3239                 if (xobj instanceof Ref) {
3240                   if (emptyXObjectCache.getByRef(xobj)) {
3241                     resolveXObject();
3242                     return;
3243                   }
3244 
3245                   const globalImage = self.globalImageCache.getData(
3246                     xobj,
3247                     self.pageIndex
3248                   );
3249                   if (globalImage) {
3250                     resolveXObject();
3251                     return;
3252                   }
3253 
3254                   xobj = xref.fetch(xobj);
3255                 }
3256 
3257                 if (!(xobj instanceof BaseStream)) {
3258                   throw new FormatError("XObject should be a stream");
3259                 }
3260 
3261                 const type = xobj.dict.get("Subtype");
3262                 if (!(type instanceof Name)) {
3263                   throw new FormatError("XObject should have a Name subtype");
3264                 }
3265 
3266                 if (type.name !== "Form") {
3267                   emptyXObjectCache.set(name, xobj.dict.objId, true);
3268 
3269                   resolveXObject();
3270                   return;
3271                 }
3272 
3273                 // Use a new `StateManager` to prevent incorrect positioning
3274                 // of textItems *after* the Form XObject, since errors in the
3275                 // data can otherwise prevent `restore` operators from
3276                 // executing.
3277                 // NOTE: Only an issue when `options.ignoreErrors === true`.
3278                 const currentState = stateManager.state.clone();
3279                 const xObjStateManager = new StateManager(currentState);
3280 
3281                 const matrix = lookupMatrix(xobj.dict.getArray("Matrix"), null);
3282                 if (matrix) {
3283                   xObjStateManager.transform(matrix);
3284                 }
3285 
3286                 // Enqueue the `textContent` chunk before parsing the /Form
3287                 // XObject.
3288                 enqueueChunk();
3289                 const sinkWrapper = {
3290                   enqueueInvoked: false,
3291 
3292                   enqueue(chunk, size) {
3293                     this.enqueueInvoked = true;
3294                     sink.enqueue(chunk, size);
3295                   },
3296 
3297                   get desiredSize() {
3298                     return sink.desiredSize;
3299                   },
3300 
3301                   get ready() {
3302                     return sink.ready;
3303                   },
3304                 };
3305 
3306                 self
3307                   .getTextContent({
3308                     stream: xobj,
3309                     task,
3310                     resources: xobj.dict.get("Resources") || resources,
3311                     stateManager: xObjStateManager,
3312                     includeMarkedContent,
3313                     sink: sinkWrapper,
3314                     seenStyles,
3315                     viewBox,
3316                     lang,
3317                     markedContentData,
3318                     disableNormalization,
3319                     keepWhiteSpace,
3320                   })
3321                   .then(function () {
3322                     if (!sinkWrapper.enqueueInvoked) {
3323                       emptyXObjectCache.set(name, xobj.dict.objId, true);
3324                     }
3325                     resolveXObject();
3326                   }, rejectXObject);
3327               }).catch(function (reason) {
3328                 if (reason instanceof AbortException) {
3329                   return;
3330                 }
3331                 if (self.options.ignoreErrors) {
3332                   // Error(s) in the XObject -- allow text-extraction to
3333                   // continue.
3334                   warn(`getTextContent - ignoring XObject: "${reason}".`);
3335                   return;
3336                 }
3337                 throw reason;
3338               })
3339             );
3340             return;
3341           case OPS.setGState:
3342             isValidName = args[0] instanceof Name;
3343             name = args[0].name;
3344 
3345             if (isValidName && emptyGStateCache.getByName(name)) {
3346               break;
3347             }
3348 
3349             next(
3350               new Promise(function (resolveGState, rejectGState) {
3351                 if (!isValidName) {
3352                   throw new FormatError("GState must be referred to by name.");
3353                 }
3354 
3355                 const extGState = resources.get("ExtGState");
3356                 if (!(extGState instanceof Dict)) {
3357                   throw new FormatError("ExtGState should be a dictionary.");
3358                 }
3359 
3360                 const gState = extGState.get(name);
3361                 // TODO: Attempt to lookup cached GStates by reference as well,
3362                 //       if and only if there are PDF documents where doing so
3363                 //       would significantly improve performance.
3364                 if (!(gState instanceof Dict)) {
3365                   throw new FormatError("GState should be a dictionary.");
3366                 }
3367 
3368                 const gStateFont = gState.get("Font");
3369                 if (!gStateFont) {
3370                   emptyGStateCache.set(name, gState.objId, true);
3371 
3372                   resolveGState();
3373                   return;
3374                 }
3375                 flushTextContentItem();
3376 
3377                 textState.fontName = null;
3378                 textState.fontSize = gStateFont[1];
3379                 handleSetFont(null, gStateFont[0]).then(
3380                   resolveGState,
3381                   rejectGState
3382                 );
3383               }).catch(function (reason) {
3384                 if (reason instanceof AbortException) {
3385                   return;
3386                 }
3387                 if (self.options.ignoreErrors) {
3388                   // Error(s) in the ExtGState -- allow text-extraction to
3389                   // continue.
3390                   warn(`getTextContent - ignoring ExtGState: "${reason}".`);
3391                   return;
3392                 }
3393                 throw reason;
3394               })
3395             );
3396             return;
3397           case OPS.beginMarkedContent:
3398             flushTextContentItem();
3399             if (includeMarkedContent) {
3400               markedContentData.level++;
3401 
3402               textContent.items.push({
3403                 type: "beginMarkedContent",
3404                 tag: args[0] instanceof Name ? args[0].name : null,
3405               });
3406             }
3407             break;
3408           case OPS.beginMarkedContentProps:
3409             flushTextContentItem();
3410             if (includeMarkedContent) {
3411               markedContentData.level++;
3412 
3413               let mcid = null;
3414               if (args[1] instanceof Dict) {
3415                 mcid = args[1].get("MCID");
3416               }
3417               textContent.items.push({
3418                 type: "beginMarkedContentProps",
3419                 id: Number.isInteger(mcid)
3420                   ? `${self.idFactory.getPageObjId()}_mc${mcid}`
3421                   : null,
3422                 tag: args[0] instanceof Name ? args[0].name : null,
3423               });
3424             }
3425             break;
3426           case OPS.endMarkedContent:
3427             flushTextContentItem();
3428             if (includeMarkedContent) {
3429               if (markedContentData.level === 0) {
3430                 // Handle unbalanced beginMarkedContent/endMarkedContent
3431                 // operators (fixes issue15629.pdf).
3432                 break;
3433               }
3434               markedContentData.level--;
3435 
3436               textContent.items.push({
3437                 type: "endMarkedContent",
3438               });
3439             }
3440             break;
3441           case OPS.restore:
3442             if (
3443               previousState &&
3444               (previousState.font !== textState.font ||
3445                 previousState.fontSize !== textState.fontSize ||
3446                 previousState.fontName !== textState.fontName)
3447             ) {
3448               flushTextContentItem();
3449             }
3450             break;
3451         } // switch
3452         if (textContent.items.length >= sink.desiredSize) {
3453           // Wait for ready, if we reach highWaterMark.
3454           stop = true;
3455           break;
3456         }
3457       } // while
3458       if (stop) {
3459         next(deferred);
3460         return;
3461       }
3462       flushTextContentItem();
3463       enqueueChunk();
3464       resolve();
3465     }).catch(reason => {
3466       if (reason instanceof AbortException) {
3467         return;
3468       }
3469       if (this.options.ignoreErrors) {
3470         // Error(s) in the TextContent -- allow text-extraction to continue.
3471         warn(
3472           `getTextContent - ignoring errors during "${task.name}" ` +
3473             `task: "${reason}".`
3474         );
3475 
3476         flushTextContentItem();
3477         enqueueChunk();
3478         return;
3479       }
3480       throw reason;
3481     });
3482   }
3483 
3484   async extractDataStructures(dict, properties) {
3485     const xref = this.xref;
3486     let cidToGidBytes;
3487     // 9.10.2
3488     const toUnicodePromise = this.readToUnicode(properties.toUnicode);
3489 
3490     if (properties.composite) {
3491       // CIDSystemInfo helps to match CID to glyphs
3492       const cidSystemInfo = dict.get("CIDSystemInfo");
3493       if (cidSystemInfo instanceof Dict) {
3494         properties.cidSystemInfo = {
3495           registry: stringToPDFString(cidSystemInfo.get("Registry")),
3496           ordering: stringToPDFString(cidSystemInfo.get("Ordering")),
3497           supplement: cidSystemInfo.get("Supplement"),
3498         };
3499       }
3500 
3501       try {
3502         const cidToGidMap = dict.get("CIDToGIDMap");
3503         if (cidToGidMap instanceof BaseStream) {
3504           cidToGidBytes = cidToGidMap.getBytes();
3505         }
3506       } catch (ex) {
3507         if (!this.options.ignoreErrors) {
3508           throw ex;
3509         }
3510         warn(`extractDataStructures - ignoring CIDToGIDMap data: "${ex}".`);
3511       }
3512     }
3513 
3514     // Based on 9.6.6 of the spec the encoding can come from multiple places
3515     // and depends on the font type. The base encoding and differences are
3516     // read here, but the encoding that is actually used is chosen during
3517     // glyph mapping in the font.
3518     // TODO: Loading the built in encoding in the font would allow the
3519     // differences to be merged in here not require us to hold on to it.
3520     const differences = [];
3521     let baseEncodingName = null;
3522     let encoding;
3523     if (dict.has("Encoding")) {
3524       encoding = dict.get("Encoding");
3525       if (encoding instanceof Dict) {
3526         baseEncodingName = encoding.get("BaseEncoding");
3527         baseEncodingName =
3528           baseEncodingName instanceof Name ? baseEncodingName.name : null;
3529         // Load the differences between the base and original
3530         if (encoding.has("Differences")) {
3531           const diffEncoding = encoding.get("Differences");
3532           let index = 0;
3533           for (const entry of diffEncoding) {
3534             const data = xref.fetchIfRef(entry);
3535             if (typeof data === "number") {
3536               index = data;
3537             } else if (data instanceof Name) {
3538               differences[index++] = data.name;
3539             } else {
3540               throw new FormatError(
3541                 `Invalid entry in 'Differences' array: ${data}`
3542               );
3543             }
3544           }
3545         }
3546       } else if (encoding instanceof Name) {
3547         baseEncodingName = encoding.name;
3548       } else {
3549         const msg = "Encoding is not a Name nor a Dict";
3550 
3551         if (!this.options.ignoreErrors) {
3552           throw new FormatError(msg);
3553         }
3554         warn(msg);
3555       }
3556       // According to table 114 if the encoding is a named encoding it must be
3557       // one of these predefined encodings.
3558       if (
3559         baseEncodingName !== "MacRomanEncoding" &&
3560         baseEncodingName !== "MacExpertEncoding" &&
3561         baseEncodingName !== "WinAnsiEncoding"
3562       ) {
3563         baseEncodingName = null;
3564       }
3565     }
3566 
3567     const nonEmbeddedFont = !properties.file || properties.isInternalFont,
3568       isSymbolsFontName = getSymbolsFonts()[properties.name];
3569     // Ignore an incorrectly specified named encoding for non-embedded
3570     // symbol fonts (fixes issue16464.pdf).
3571     if (baseEncodingName && nonEmbeddedFont && isSymbolsFontName) {
3572       baseEncodingName = null;
3573     }
3574 
3575     if (baseEncodingName) {
3576       properties.defaultEncoding = getEncoding(baseEncodingName);
3577     } else {
3578       const isSymbolicFont = !!(properties.flags & FontFlags.Symbolic);
3579       const isNonsymbolicFont = !!(properties.flags & FontFlags.Nonsymbolic);
3580       // According to "Table 114" in section "9.6.6.1 General" (under
3581       // "9.6.6 Character Encoding") of the PDF specification, a Nonsymbolic
3582       // font should use the `StandardEncoding` if no encoding is specified.
3583       encoding = StandardEncoding;
3584       if (properties.type === "TrueType" && !isNonsymbolicFont) {
3585         encoding = WinAnsiEncoding;
3586       }
3587       // The Symbolic attribute can be misused for regular fonts
3588       // Heuristic: we have to check if the font is a standard one also
3589       if (isSymbolicFont || isSymbolsFontName) {
3590         encoding = MacRomanEncoding;
3591         if (nonEmbeddedFont) {
3592           if (/Symbol/i.test(properties.name)) {
3593             encoding = SymbolSetEncoding;
3594           } else if (/Dingbats/i.test(properties.name)) {
3595             encoding = ZapfDingbatsEncoding;
3596           } else if (/Wingdings/i.test(properties.name)) {
3597             encoding = WinAnsiEncoding;
3598           }
3599         }
3600       }
3601       properties.defaultEncoding = encoding;
3602     }
3603 
3604     properties.differences = differences;
3605     properties.baseEncodingName = baseEncodingName;
3606     properties.hasEncoding = !!baseEncodingName || differences.length > 0;
3607     properties.dict = dict;
3608 
3609     properties.toUnicode = await toUnicodePromise;
3610 
3611     const builtToUnicode = await this.buildToUnicode(properties);
3612     properties.toUnicode = builtToUnicode;
3613 
3614     if (cidToGidBytes) {
3615       properties.cidToGidMap = this.readCidToGidMap(
3616         cidToGidBytes,
3617         builtToUnicode
3618       );
3619     }
3620     return properties;
3621   }
3622 
3623   /**
3624    * @returns {Array}
3625    * @private
3626    */
3627   _simpleFontToUnicode(properties, forceGlyphs = false) {
3628     assert(!properties.composite, "Must be a simple font.");
3629 
3630     const toUnicode = [];
3631     const encoding = properties.defaultEncoding.slice();
3632     const baseEncodingName = properties.baseEncodingName;
3633     // Merge in the differences array.
3634     const differences = properties.differences;
3635     for (const charcode in differences) {
3636       const glyphName = differences[charcode];
3637       if (glyphName === ".notdef") {
3638         // Skip .notdef to prevent rendering errors, e.g. boxes appearing
3639         // where there should be spaces (fixes issue5256.pdf).
3640         continue;
3641       }
3642       encoding[charcode] = glyphName;
3643     }
3644     const glyphsUnicodeMap = getGlyphsUnicode();
3645     for (const charcode in encoding) {
3646       // a) Map the character code to a character name.
3647       let glyphName = encoding[charcode];
3648       if (glyphName === "") {
3649         continue;
3650       }
3651       // b) Look up the character name in the Adobe Glyph List (see the
3652       //    Bibliography) to obtain the corresponding Unicode value.
3653       let unicode = glyphsUnicodeMap[glyphName];
3654       if (unicode !== undefined) {
3655         toUnicode[charcode] = String.fromCharCode(unicode);
3656         continue;
3657       }
3658       // (undocumented) c) Few heuristics to recognize unknown glyphs
3659       // NOTE: Adobe Reader does not do this step, but OSX Preview does
3660       let code = 0;
3661       switch (glyphName[0]) {
3662         case "G": // Gxx glyph
3663           if (glyphName.length === 3) {
3664             code = parseInt(glyphName.substring(1), 16);
3665           }
3666           break;
3667         case "g": // g00xx glyph
3668           if (glyphName.length === 5) {
3669             code = parseInt(glyphName.substring(1), 16);
3670           }
3671           break;
3672         case "C": // Cdd{d} glyph
3673         case "c": // cdd{d} glyph
3674           if (glyphName.length >= 3 && glyphName.length <= 4) {
3675             const codeStr = glyphName.substring(1);
3676 
3677             if (forceGlyphs) {
3678               code = parseInt(codeStr, 16);
3679               break;
3680             }
3681             // Normally the Cdd{d}/cdd{d} glyphName format will contain
3682             // regular, i.e. base 10, charCodes (see issue4550.pdf)...
3683             code = +codeStr;
3684 
3685             // ... however some PDF generators violate that assumption by
3686             // containing glyph, i.e. base 16, codes instead.
3687             // In that case we need to re-parse the *entire* encoding to
3688             // prevent broken text-selection (fixes issue9655_reduced.pdf).
3689             if (Number.isNaN(code) && Number.isInteger(parseInt(codeStr, 16))) {
3690               return this._simpleFontToUnicode(
3691                 properties,
3692                 /* forceGlyphs */ true
3693               );
3694             }
3695           }
3696           break;
3697         case "u": // 'uniXXXX'/'uXXXX{XX}' glyphs
3698           unicode = getUnicodeForGlyph(glyphName, glyphsUnicodeMap);
3699           if (unicode !== -1) {
3700             code = unicode;
3701           }
3702           break;
3703         default:
3704           // Support (some) non-standard ligatures.
3705           switch (glyphName) {
3706             case "f_h":
3707             case "f_t":
3708             case "T_h":
3709               toUnicode[charcode] = glyphName.replaceAll("_", "");
3710               continue;
3711           }
3712           break;
3713       }
3714       if (code > 0 && code <= 0x10ffff && Number.isInteger(code)) {
3715         // If `baseEncodingName` is one the predefined encodings, and `code`
3716         // equals `charcode`, using the glyph defined in the baseEncoding
3717         // seems to yield a better `toUnicode` mapping (fixes issue 5070).
3718         if (baseEncodingName && code === +charcode) {
3719           const baseEncoding = getEncoding(baseEncodingName);
3720           if (baseEncoding && (glyphName = baseEncoding[charcode])) {
3721             toUnicode[charcode] = String.fromCharCode(
3722               glyphsUnicodeMap[glyphName]
3723             );
3724             continue;
3725           }
3726         }
3727         toUnicode[charcode] = String.fromCodePoint(code);
3728       }
3729     }
3730     return toUnicode;
3731   }
3732 
3733   /**
3734    * Builds a char code to unicode map based on section 9.10 of the spec.
3735    * @param {Object} properties Font properties object.
3736    * @returns {Promise} A Promise that is resolved with a
3737    *   {ToUnicodeMap|IdentityToUnicodeMap} object.
3738    */
3739   async buildToUnicode(properties) {
3740     properties.hasIncludedToUnicodeMap = properties.toUnicode?.length > 0;
3741 
3742     // Section 9.10.2 Mapping Character Codes to Unicode Values
3743     if (properties.hasIncludedToUnicodeMap) {
3744       // Some fonts contain incomplete ToUnicode data, causing issues with
3745       // text-extraction. For simple fonts, containing encoding information,
3746       // use a fallback ToUnicode map to improve this (fixes issue8229.pdf).
3747       if (!properties.composite && properties.hasEncoding) {
3748         properties.fallbackToUnicode = this._simpleFontToUnicode(properties);
3749       }
3750       return properties.toUnicode;
3751     }
3752 
3753     // According to the spec if the font is a simple font we should only map
3754     // to unicode if the base encoding is MacRoman, MacExpert, or WinAnsi or
3755     // the differences array only contains adobe standard or symbol set names,
3756     // in pratice it seems better to always try to create a toUnicode map
3757     // based of the default encoding.
3758     if (!properties.composite /* is simple font */) {
3759       return new ToUnicodeMap(this._simpleFontToUnicode(properties));
3760     }
3761 
3762     // If the font is a composite font that uses one of the predefined CMaps
3763     // listed in Table 118 (except Identity–H and Identity–V) or whose
3764     // descendant CIDFont uses the Adobe-GB1, Adobe-CNS1, Adobe-Japan1, or
3765     // Adobe-Korea1 character collection:
3766     if (
3767       properties.composite &&
3768       ((properties.cMap.builtInCMap &&
3769         !(properties.cMap instanceof IdentityCMap)) ||
3770         // The font is supposed to have a CIDSystemInfo dictionary, but some
3771         // PDFs don't include it (fixes issue 17689), hence the `?'.
3772         (properties.cidSystemInfo?.registry === "Adobe" &&
3773           (properties.cidSystemInfo.ordering === "GB1" ||
3774             properties.cidSystemInfo.ordering === "CNS1" ||
3775             properties.cidSystemInfo.ordering === "Japan1" ||
3776             properties.cidSystemInfo.ordering === "Korea1")))
3777     ) {
3778       // Then:
3779       // a) Map the character code to a character identifier (CID) according
3780       // to the font’s CMap.
3781       // b) Obtain the registry and ordering of the character collection used
3782       // by the font’s CMap (for example, Adobe and Japan1) from its
3783       // CIDSystemInfo dictionary.
3784       const { registry, ordering } = properties.cidSystemInfo;
3785       // c) Construct a second CMap name by concatenating the registry and
3786       // ordering obtained in step (b) in the format registry–ordering–UCS2
3787       // (for example, Adobe–Japan1–UCS2).
3788       const ucs2CMapName = Name.get(`${registry}-${ordering}-UCS2`);
3789       // d) Obtain the CMap with the name constructed in step (c) (available
3790       // from the ASN Web site; see the Bibliography).
3791       const ucs2CMap = await CMapFactory.create({
3792         encoding: ucs2CMapName,
3793         fetchBuiltInCMap: this._fetchBuiltInCMapBound,
3794         useCMap: null,
3795       });
3796       const toUnicode = [],
3797         buf = [];
3798       properties.cMap.forEach(function (charcode, cid) {
3799         if (cid > 0xffff) {
3800           throw new FormatError("Max size of CID is 65,535");
3801         }
3802         // e) Map the CID obtained in step (a) according to the CMap
3803         // obtained in step (d), producing a Unicode value.
3804         const ucs2 = ucs2CMap.lookup(cid);
3805         if (ucs2) {
3806           buf.length = 0;
3807           // Support multi-byte entries (fixes issue16176.pdf).
3808           for (let i = 0, ii = ucs2.length; i < ii; i += 2) {
3809             buf.push((ucs2.charCodeAt(i) << 8) + ucs2.charCodeAt(i + 1));
3810           }
3811           toUnicode[charcode] = String.fromCharCode(...buf);
3812         }
3813       });
3814       return new ToUnicodeMap(toUnicode);
3815     }
3816 
3817     // The viewer's choice, just use an identity map.
3818     return new IdentityToUnicodeMap(properties.firstChar, properties.lastChar);
3819   }
3820 
3821   async readToUnicode(cmapObj) {
3822     if (!cmapObj) {
3823       return null;
3824     }
3825     if (cmapObj instanceof Name) {
3826       const cmap = await CMapFactory.create({
3827         encoding: cmapObj,
3828         fetchBuiltInCMap: this._fetchBuiltInCMapBound,
3829         useCMap: null,
3830       });
3831 
3832       if (cmap instanceof IdentityCMap) {
3833         return new IdentityToUnicodeMap(0, 0xffff);
3834       }
3835       return new ToUnicodeMap(cmap.getMap());
3836     }
3837     if (cmapObj instanceof BaseStream) {
3838       try {
3839         const cmap = await CMapFactory.create({
3840           encoding: cmapObj,
3841           fetchBuiltInCMap: this._fetchBuiltInCMapBound,
3842           useCMap: null,
3843         });
3844 
3845         if (cmap instanceof IdentityCMap) {
3846           return new IdentityToUnicodeMap(0, 0xffff);
3847         }
3848         const map = new Array(cmap.length);
3849         // Convert UTF-16BE
3850         // NOTE: cmap can be a sparse array, so use forEach instead of
3851         // `for(;;)` to iterate over all keys.
3852         cmap.forEach(function (charCode, token) {
3853           // Some cmaps contain *only* CID characters (fixes issue9367.pdf).
3854           if (typeof token === "number") {
3855             map[charCode] = String.fromCodePoint(token);
3856             return;
3857           }
3858           const str = [];
3859           for (let k = 0; k < token.length; k += 2) {
3860             const w1 = (token.charCodeAt(k) << 8) | token.charCodeAt(k + 1);
3861             if ((w1 & 0xf800) !== 0xd800) {
3862               // w1 < 0xD800 || w1 > 0xDFFF
3863               str.push(w1);
3864               continue;
3865             }
3866             k += 2;
3867             const w2 = (token.charCodeAt(k) << 8) | token.charCodeAt(k + 1);
3868             str.push(((w1 & 0x3ff) << 10) + (w2 & 0x3ff) + 0x10000);
3869           }
3870           map[charCode] = String.fromCodePoint(...str);
3871         });
3872         return new ToUnicodeMap(map);
3873       } catch (reason) {
3874         if (reason instanceof AbortException) {
3875           return null;
3876         }
3877         if (this.options.ignoreErrors) {
3878           warn(`readToUnicode - ignoring ToUnicode data: "${reason}".`);
3879           return null;
3880         }
3881         throw reason;
3882       }
3883     }
3884     return null;
3885   }
3886 
3887   readCidToGidMap(glyphsData, toUnicode) {
3888     // Extract the encoding from the CIDToGIDMap
3889 
3890     // Set encoding 0 to later verify the font has an encoding
3891     const result = [];
3892     for (let j = 0, jj = glyphsData.length; j < jj; j++) {
3893       const glyphID = (glyphsData[j++] << 8) | glyphsData[j];
3894       const code = j >> 1;
3895       if (glyphID === 0 && !toUnicode.has(code)) {
3896         continue;
3897       }
3898       result[code] = glyphID;
3899     }
3900     return result;
3901   }
3902 
3903   extractWidths(dict, descriptor, properties) {
3904     const xref = this.xref;
3905     let glyphsWidths = [];
3906     let defaultWidth = 0;
3907     const glyphsVMetrics = [];
3908     let defaultVMetrics;
3909     if (properties.composite) {
3910       const dw = dict.get("DW");
3911       defaultWidth = Number.isInteger(dw) ? dw : 1000;
3912 
3913       const widths = dict.get("W");
3914       if (Array.isArray(widths)) {
3915         for (let i = 0, ii = widths.length; i < ii; i++) {
3916           let start = xref.fetchIfRef(widths[i++]);
3917           if (!Number.isInteger(start)) {
3918             break; // Invalid /W data.
3919           }
3920           const code = xref.fetchIfRef(widths[i]);
3921 
3922           if (Array.isArray(code)) {
3923             for (const c of code) {
3924               const width = xref.fetchIfRef(c);
3925               if (typeof width === "number") {
3926                 glyphsWidths[start] = width;
3927               }
3928               start++;
3929             }
3930           } else if (Number.isInteger(code)) {
3931             const width = xref.fetchIfRef(widths[++i]);
3932             if (typeof width !== "number") {
3933               continue;
3934             }
3935             for (let j = start; j <= code; j++) {
3936               glyphsWidths[j] = width;
3937             }
3938           } else {
3939             break; // Invalid /W data.
3940           }
3941         }
3942       }
3943 
3944       if (properties.vertical) {
3945         const dw2 = dict.getArray("DW2");
3946         let vmetrics = isNumberArray(dw2, 2) ? dw2 : [880, -1000];
3947         defaultVMetrics = [vmetrics[1], defaultWidth * 0.5, vmetrics[0]];
3948         vmetrics = dict.get("W2");
3949         if (Array.isArray(vmetrics)) {
3950           for (let i = 0, ii = vmetrics.length; i < ii; i++) {
3951             let start = xref.fetchIfRef(vmetrics[i++]);
3952             if (!Number.isInteger(start)) {
3953               break; // Invalid /W2 data.
3954             }
3955             const code = xref.fetchIfRef(vmetrics[i]);
3956 
3957             if (Array.isArray(code)) {
3958               for (let j = 0, jj = code.length; j < jj; j++) {
3959                 const vmetric = [
3960                   xref.fetchIfRef(code[j++]),
3961                   xref.fetchIfRef(code[j++]),
3962                   xref.fetchIfRef(code[j]),
3963                 ];
3964                 if (isNumberArray(vmetric, null)) {
3965                   glyphsVMetrics[start] = vmetric;
3966                 }
3967                 start++;
3968               }
3969             } else if (Number.isInteger(code)) {
3970               const vmetric = [
3971                 xref.fetchIfRef(vmetrics[++i]),
3972                 xref.fetchIfRef(vmetrics[++i]),
3973                 xref.fetchIfRef(vmetrics[++i]),
3974               ];
3975               if (!isNumberArray(vmetric, null)) {
3976                 continue;
3977               }
3978               for (let j = start; j <= code; j++) {
3979                 glyphsVMetrics[j] = vmetric;
3980               }
3981             } else {
3982               break; // Invalid /W2 data.
3983             }
3984           }
3985         }
3986       }
3987     } else {
3988       const widths = dict.get("Widths");
3989       if (Array.isArray(widths)) {
3990         let j = properties.firstChar;
3991         for (const w of widths) {
3992           const width = xref.fetchIfRef(w);
3993           if (typeof width === "number") {
3994             glyphsWidths[j] = width;
3995           }
3996           j++;
3997         }
3998         const missingWidth = descriptor.get("MissingWidth");
3999         defaultWidth = typeof missingWidth === "number" ? missingWidth : 0;
4000       } else {
4001         // Trying get the BaseFont metrics (see comment above).
4002         const baseFontName = dict.get("BaseFont");
4003         if (baseFontName instanceof Name) {
4004           const metrics = this.getBaseFontMetrics(baseFontName.name);
4005 
4006           glyphsWidths = this.buildCharCodeToWidth(metrics.widths, properties);
4007           defaultWidth = metrics.defaultWidth;
4008         }
4009       }
4010     }
4011 
4012     // Heuristic: detection of monospace font by checking all non-zero widths
4013     let isMonospace = true;
4014     let firstWidth = defaultWidth;
4015     for (const glyph in glyphsWidths) {
4016       const glyphWidth = glyphsWidths[glyph];
4017       if (!glyphWidth) {
4018         continue;
4019       }
4020       if (!firstWidth) {
4021         firstWidth = glyphWidth;
4022         continue;
4023       }
4024       if (firstWidth !== glyphWidth) {
4025         isMonospace = false;
4026         break;
4027       }
4028     }
4029     if (isMonospace) {
4030       properties.flags |= FontFlags.FixedPitch;
4031     } else {
4032       // Clear the flag.
4033       properties.flags &= ~FontFlags.FixedPitch;
4034     }
4035 
4036     properties.defaultWidth = defaultWidth;
4037     properties.widths = glyphsWidths;
4038     properties.defaultVMetrics = defaultVMetrics;
4039     properties.vmetrics = glyphsVMetrics;
4040   }
4041 
4042   isSerifFont(baseFontName) {
4043     // Simulating descriptor flags attribute
4044     const fontNameWoStyle = baseFontName.split("-", 1)[0];
4045     return (
4046       fontNameWoStyle in getSerifFonts() || /serif/gi.test(fontNameWoStyle)
4047     );
4048   }
4049 
4050   getBaseFontMetrics(name) {
4051     let defaultWidth = 0;
4052     let widths = Object.create(null);
4053     let monospace = false;
4054     const stdFontMap = getStdFontMap();
4055     let lookupName = stdFontMap[name] || name;
4056     const Metrics = getMetrics();
4057 
4058     if (!(lookupName in Metrics)) {
4059       // Use default fonts for looking up font metrics if the passed
4060       // font is not a base font
4061       lookupName = this.isSerifFont(name) ? "Times-Roman" : "Helvetica";
4062     }
4063     const glyphWidths = Metrics[lookupName];
4064 
4065     if (typeof glyphWidths === "number") {
4066       defaultWidth = glyphWidths;
4067       monospace = true;
4068     } else {
4069       widths = glyphWidths(); // expand lazy widths array
4070     }
4071 
4072     return {
4073       defaultWidth,
4074       monospace,
4075       widths,
4076     };
4077   }
4078 
4079   buildCharCodeToWidth(widthsByGlyphName, properties) {
4080     const widths = Object.create(null);
4081     const differences = properties.differences;
4082     const encoding = properties.defaultEncoding;
4083     for (let charCode = 0; charCode < 256; charCode++) {
4084       if (charCode in differences && widthsByGlyphName[differences[charCode]]) {
4085         widths[charCode] = widthsByGlyphName[differences[charCode]];
4086         continue;
4087       }
4088       if (charCode in encoding && widthsByGlyphName[encoding[charCode]]) {
4089         widths[charCode] = widthsByGlyphName[encoding[charCode]];
4090         continue;
4091       }
4092     }
4093     return widths;
4094   }
4095 
4096   preEvaluateFont(dict) {
4097     const baseDict = dict;
4098     let type = dict.get("Subtype");
4099     if (!(type instanceof Name)) {
4100       throw new FormatError("invalid font Subtype");
4101     }
4102 
4103     let composite = false;
4104     let hash;
4105     if (type.name === "Type0") {
4106       // If font is a composite
4107       //  - get the descendant font
4108       //  - set the type according to the descendant font
4109       //  - get the FontDescriptor from the descendant font
4110       const df = dict.get("DescendantFonts");
4111       if (!df) {
4112         throw new FormatError("Descendant fonts are not specified");
4113       }
4114       dict = Array.isArray(df) ? this.xref.fetchIfRef(df[0]) : df;
4115 
4116       if (!(dict instanceof Dict)) {
4117         throw new FormatError("Descendant font is not a dictionary.");
4118       }
4119       type = dict.get("Subtype");
4120       if (!(type instanceof Name)) {
4121         throw new FormatError("invalid font Subtype");
4122       }
4123       composite = true;
4124     }
4125 
4126     let firstChar = dict.get("FirstChar");
4127     if (!Number.isInteger(firstChar)) {
4128       firstChar = 0;
4129     }
4130     let lastChar = dict.get("LastChar");
4131     if (!Number.isInteger(lastChar)) {
4132       lastChar = composite ? 0xffff : 0xff;
4133     }
4134     const descriptor = dict.get("FontDescriptor");
4135     const toUnicode = dict.get("ToUnicode") || baseDict.get("ToUnicode");
4136 
4137     if (descriptor) {
4138       hash = new MurmurHash3_64();
4139 
4140       const encoding = baseDict.getRaw("Encoding");
4141       if (encoding instanceof Name) {
4142         hash.update(encoding.name);
4143       } else if (encoding instanceof Ref) {
4144         hash.update(encoding.toString());
4145       } else if (encoding instanceof Dict) {
4146         for (const entry of encoding.getRawValues()) {
4147           if (entry instanceof Name) {
4148             hash.update(entry.name);
4149           } else if (entry instanceof Ref) {
4150             hash.update(entry.toString());
4151           } else if (Array.isArray(entry)) {
4152             // 'Differences' array (fixes bug1157493.pdf).
4153             const diffLength = entry.length,
4154               diffBuf = new Array(diffLength);
4155 
4156             for (let j = 0; j < diffLength; j++) {
4157               const diffEntry = entry[j];
4158               if (diffEntry instanceof Name) {
4159                 diffBuf[j] = diffEntry.name;
4160               } else if (
4161                 typeof diffEntry === "number" ||
4162                 diffEntry instanceof Ref
4163               ) {
4164                 diffBuf[j] = diffEntry.toString();
4165               }
4166             }
4167             hash.update(diffBuf.join());
4168           }
4169         }
4170       }
4171 
4172       hash.update(`${firstChar}-${lastChar}`); // Fixes issue10665_reduced.pdf
4173 
4174       if (toUnicode instanceof BaseStream) {
4175         const stream = toUnicode.str || toUnicode;
4176         const uint8array = stream.buffer
4177           ? new Uint8Array(stream.buffer.buffer, 0, stream.bufferLength)
4178           : new Uint8Array(
4179               stream.bytes.buffer,
4180               stream.start,
4181               stream.end - stream.start
4182             );
4183         hash.update(uint8array);
4184       } else if (toUnicode instanceof Name) {
4185         hash.update(toUnicode.name);
4186       }
4187 
4188       const widths = dict.get("Widths") || baseDict.get("Widths");
4189       if (Array.isArray(widths)) {
4190         const widthsBuf = [];
4191         for (const entry of widths) {
4192           if (typeof entry === "number" || entry instanceof Ref) {
4193             widthsBuf.push(entry.toString());
4194           }
4195         }
4196         hash.update(widthsBuf.join());
4197       }
4198 
4199       if (composite) {
4200         hash.update("compositeFont");
4201 
4202         const compositeWidths = dict.get("W") || baseDict.get("W");
4203         if (Array.isArray(compositeWidths)) {
4204           const widthsBuf = [];
4205           for (const entry of compositeWidths) {
4206             if (typeof entry === "number" || entry instanceof Ref) {
4207               widthsBuf.push(entry.toString());
4208             } else if (Array.isArray(entry)) {
4209               const subWidthsBuf = [];
4210               for (const element of entry) {
4211                 if (typeof element === "number" || element instanceof Ref) {
4212                   subWidthsBuf.push(element.toString());
4213                 }
4214               }
4215               widthsBuf.push(`[${subWidthsBuf.join()}]`);
4216             }
4217           }
4218           hash.update(widthsBuf.join());
4219         }
4220 
4221         const cidToGidMap =
4222           dict.getRaw("CIDToGIDMap") || baseDict.getRaw("CIDToGIDMap");
4223         if (cidToGidMap instanceof Name) {
4224           hash.update(cidToGidMap.name);
4225         } else if (cidToGidMap instanceof Ref) {
4226           hash.update(cidToGidMap.toString());
4227         } else if (cidToGidMap instanceof BaseStream) {
4228           hash.update(cidToGidMap.peekBytes());
4229         }
4230       }
4231     }
4232 
4233     return {
4234       descriptor,
4235       dict,
4236       baseDict,
4237       composite,
4238       type: type.name,
4239       firstChar,
4240       lastChar,
4241       toUnicode,
4242       hash: hash ? hash.hexdigest() : "",
4243     };
4244   }
4245 
4246   async translateFont({
4247     descriptor,
4248     dict,
4249     baseDict,
4250     composite,
4251     type,
4252     firstChar,
4253     lastChar,
4254     toUnicode,
4255     cssFontInfo,
4256   }) {
4257     const isType3Font = type === "Type3";
4258 
4259     if (!descriptor) {
4260       if (isType3Font) {
4261         const bbox = lookupNormalRect(dict.getArray("FontBBox"), [0, 0, 0, 0]);
4262         // FontDescriptor is only required for Type3 fonts when the document
4263         // is a tagged pdf. Create a barbebones one to get by.
4264         descriptor = new Dict(null);
4265         descriptor.set("FontName", Name.get(type));
4266         descriptor.set("FontBBox", bbox);
4267       } else {
4268         // Before PDF 1.5 if the font was one of the base 14 fonts, having a
4269         // FontDescriptor was not required.
4270         // This case is here for compatibility.
4271         let baseFontName = dict.get("BaseFont");
4272         if (!(baseFontName instanceof Name)) {
4273           throw new FormatError("Base font is not specified");
4274         }
4275 
4276         // Using base font name as a font name.
4277         baseFontName = baseFontName.name.replaceAll(/[,_]/g, "-");
4278         const metrics = this.getBaseFontMetrics(baseFontName);
4279 
4280         // Simulating descriptor flags attribute
4281         const fontNameWoStyle = baseFontName.split("-", 1)[0];
4282         const flags =
4283           (this.isSerifFont(fontNameWoStyle) ? FontFlags.Serif : 0) |
4284           (metrics.monospace ? FontFlags.FixedPitch : 0) |
4285           (getSymbolsFonts()[fontNameWoStyle]
4286             ? FontFlags.Symbolic
4287             : FontFlags.Nonsymbolic);
4288 
4289         const properties = {
4290           type,
4291           name: baseFontName,
4292           loadedName: baseDict.loadedName,
4293           systemFontInfo: null,
4294           widths: metrics.widths,
4295           defaultWidth: metrics.defaultWidth,
4296           isSimulatedFlags: true,
4297           flags,
4298           firstChar,
4299           lastChar,
4300           toUnicode,
4301           xHeight: 0,
4302           capHeight: 0,
4303           italicAngle: 0,
4304           isType3Font,
4305         };
4306         const widths = dict.get("Widths");
4307 
4308         const standardFontName = getStandardFontName(baseFontName);
4309         let file = null;
4310         if (standardFontName) {
4311           file = await this.fetchStandardFontData(standardFontName);
4312           properties.isInternalFont = !!file;
4313         }
4314         if (!properties.isInternalFont && this.options.useSystemFonts) {
4315           properties.systemFontInfo = getFontSubstitution(
4316             this.systemFontCache,
4317             this.idFactory,
4318             this.options.standardFontDataUrl,
4319             baseFontName,
4320             standardFontName,
4321             type
4322           );
4323         }
4324 
4325         const newProperties = await this.extractDataStructures(
4326           dict,
4327           properties
4328         );
4329         if (Array.isArray(widths)) {
4330           const glyphWidths = [];
4331           let j = firstChar;
4332           for (const w of widths) {
4333             const width = this.xref.fetchIfRef(w);
4334             if (typeof width === "number") {
4335               glyphWidths[j] = width;
4336             }
4337             j++;
4338           }
4339           newProperties.widths = glyphWidths;
4340         } else {
4341           newProperties.widths = this.buildCharCodeToWidth(
4342             metrics.widths,
4343             newProperties
4344           );
4345         }
4346         return new Font(baseFontName, file, newProperties);
4347       }
4348     }
4349 
4350     // According to the spec if 'FontDescriptor' is declared, 'FirstChar',
4351     // 'LastChar' and 'Widths' should exist too, but some PDF encoders seem
4352     // to ignore this rule when a variant of a standard font is used.
4353     // TODO Fill the width array depending on which of the base font this is
4354     // a variant.
4355 
4356     let fontName = descriptor.get("FontName");
4357     let baseFont = dict.get("BaseFont");
4358     // Some bad PDFs have a string as the font name.
4359     if (typeof fontName === "string") {
4360       fontName = Name.get(fontName);
4361     }
4362     if (typeof baseFont === "string") {
4363       baseFont = Name.get(baseFont);
4364     }
4365 
4366     const fontNameStr = fontName?.name;
4367     const baseFontStr = baseFont?.name;
4368     if (!isType3Font && fontNameStr !== baseFontStr) {
4369       info(
4370         `The FontDescriptor's FontName is "${fontNameStr}" but ` +
4371           `should be the same as the Font's BaseFont "${baseFontStr}".`
4372       );
4373       // - Workaround for cases where e.g. fontNameStr = 'Arial' and
4374       //   baseFontStr = 'Arial,Bold' (needed when no font file is embedded).
4375       //
4376       // - Workaround for cases where e.g. fontNameStr = 'wg09np' and
4377       //   baseFontStr = 'Wingdings-Regular' (fixes issue7454.pdf).
4378       if (
4379         fontNameStr &&
4380         baseFontStr &&
4381         (baseFontStr.startsWith(fontNameStr) ||
4382           (!isKnownFontName(fontNameStr) && isKnownFontName(baseFontStr)))
4383       ) {
4384         fontName = null;
4385       }
4386     }
4387     fontName ||= baseFont;
4388 
4389     if (!(fontName instanceof Name)) {
4390       throw new FormatError("invalid font name");
4391     }
4392 
4393     let fontFile, subtype, length1, length2, length3;
4394     try {
4395       fontFile = descriptor.get("FontFile", "FontFile2", "FontFile3");
4396     } catch (ex) {
4397       if (!this.options.ignoreErrors) {
4398         throw ex;
4399       }
4400       warn(`translateFont - fetching "${fontName.name}" font file: "${ex}".`);
4401       fontFile = new NullStream();
4402     }
4403     let isInternalFont = false;
4404     let glyphScaleFactors = null;
4405     let systemFontInfo = null;
4406     if (fontFile) {
4407       if (fontFile.dict) {
4408         const subtypeEntry = fontFile.dict.get("Subtype");
4409         if (subtypeEntry instanceof Name) {
4410           subtype = subtypeEntry.name;
4411         }
4412         length1 = fontFile.dict.get("Length1");
4413         length2 = fontFile.dict.get("Length2");
4414         length3 = fontFile.dict.get("Length3");
4415       }
4416     } else if (cssFontInfo) {
4417       // We've a missing XFA font.
4418       const standardFontName = getXfaFontName(fontName.name);
4419       if (standardFontName) {
4420         cssFontInfo.fontFamily = `${cssFontInfo.fontFamily}-PdfJS-XFA`;
4421         cssFontInfo.metrics = standardFontName.metrics || null;
4422         glyphScaleFactors = standardFontName.factors || null;
4423         fontFile = await this.fetchStandardFontData(standardFontName.name);
4424         isInternalFont = !!fontFile;
4425 
4426         // We're using a substitution font but for example widths (if any)
4427         // are related to the glyph positions in the font.
4428         // So we overwrite everything here to be sure that widths are
4429         // correct.
4430         baseDict = dict = getXfaFontDict(fontName.name);
4431         composite = true;
4432       }
4433     } else if (!isType3Font) {
4434       const standardFontName = getStandardFontName(fontName.name);
4435       if (standardFontName) {
4436         fontFile = await this.fetchStandardFontData(standardFontName);
4437         isInternalFont = !!fontFile;
4438       }
4439       if (!isInternalFont && this.options.useSystemFonts) {
4440         systemFontInfo = getFontSubstitution(
4441           this.systemFontCache,
4442           this.idFactory,
4443           this.options.standardFontDataUrl,
4444           fontName.name,
4445           standardFontName,
4446           type
4447         );
4448       }
4449     }
4450 
4451     const fontMatrix = lookupMatrix(
4452       dict.getArray("FontMatrix"),
4453       FONT_IDENTITY_MATRIX
4454     );
4455     const bbox = lookupNormalRect(
4456       descriptor.getArray("FontBBox") || dict.getArray("FontBBox"),
4457       undefined
4458     );
4459     let ascent = descriptor.get("Ascent");
4460     if (typeof ascent !== "number") {
4461       ascent = undefined;
4462     }
4463     let descent = descriptor.get("Descent");
4464     if (typeof descent !== "number") {
4465       descent = undefined;
4466     }
4467     let xHeight = descriptor.get("XHeight");
4468     if (typeof xHeight !== "number") {
4469       xHeight = 0;
4470     }
4471     let capHeight = descriptor.get("CapHeight");
4472     if (typeof capHeight !== "number") {
4473       capHeight = 0;
4474     }
4475     let flags = descriptor.get("Flags");
4476     if (!Number.isInteger(flags)) {
4477       flags = 0;
4478     }
4479     let italicAngle = descriptor.get("ItalicAngle");
4480     if (typeof italicAngle !== "number") {
4481       italicAngle = 0;
4482     }
4483 
4484     const properties = {
4485       type,
4486       name: fontName.name,
4487       subtype,
4488       file: fontFile,
4489       length1,
4490       length2,
4491       length3,
4492       isInternalFont,
4493       loadedName: baseDict.loadedName,
4494       composite,
4495       fixedPitch: false,
4496       fontMatrix,
4497       firstChar,
4498       lastChar,
4499       toUnicode,
4500       bbox,
4501       ascent,
4502       descent,
4503       xHeight,
4504       capHeight,
4505       flags,
4506       italicAngle,
4507       isType3Font,
4508       cssFontInfo,
4509       scaleFactors: glyphScaleFactors,
4510       systemFontInfo,
4511     };
4512 
4513     if (composite) {
4514       const cidEncoding = baseDict.get("Encoding");
4515       if (cidEncoding instanceof Name) {
4516         properties.cidEncoding = cidEncoding.name;
4517       }
4518       const cMap = await CMapFactory.create({
4519         encoding: cidEncoding,
4520         fetchBuiltInCMap: this._fetchBuiltInCMapBound,
4521         useCMap: null,
4522       });
4523       properties.cMap = cMap;
4524       properties.vertical = properties.cMap.vertical;
4525     }
4526 
4527     const newProperties = await this.extractDataStructures(dict, properties);
4528     this.extractWidths(dict, descriptor, newProperties);
4529 
4530     return new Font(fontName.name, fontFile, newProperties);
4531   }
4532 
4533   static buildFontPaths(font, glyphs, handler, evaluatorOptions) {
4534     function buildPath(fontChar) {
4535       const glyphName = `${font.loadedName}_path_${fontChar}`;
4536       try {
4537         if (font.renderer.hasBuiltPath(fontChar)) {
4538           return;
4539         }
4540         handler.send("commonobj", [
4541           glyphName,
4542           "FontPath",
4543           font.renderer.getPathJs(fontChar),
4544         ]);
4545       } catch (reason) {
4546         if (evaluatorOptions.ignoreErrors) {
4547           warn(`buildFontPaths - ignoring ${glyphName} glyph: "${reason}".`);
4548           return;
4549         }
4550         throw reason;
4551       }
4552     }
4553 
4554     for (const glyph of glyphs) {
4555       buildPath(glyph.fontChar);
4556 
4557       // If the glyph has an accent we need to build a path for its
4558       // fontChar too, otherwise CanvasGraphics_paintChar will fail.
4559       const accent = glyph.accent;
4560       if (accent?.fontChar) {
4561         buildPath(accent.fontChar);
4562       }
4563     }
4564   }
4565 
4566   static get fallbackFontDict() {
4567     const dict = new Dict();
4568     dict.set("BaseFont", Name.get("Helvetica"));
4569     dict.set("Type", Name.get("FallbackType"));
4570     dict.set("Subtype", Name.get("FallbackType"));
4571     dict.set("Encoding", Name.get("WinAnsiEncoding"));
4572 
4573     return shadow(this, "fallbackFontDict", dict);
4574   }
4575 }
4576 
4577 class TranslatedFont {
4578   constructor({ loadedName, font, dict, evaluatorOptions }) {
4579     this.loadedName = loadedName;
4580     this.font = font;
4581     this.dict = dict;
4582     this._evaluatorOptions = evaluatorOptions || DefaultPartialEvaluatorOptions;
4583     this.type3Loaded = null;
4584     this.type3Dependencies = font.isType3Font ? new Set() : null;
4585     this.sent = false;
4586   }
4587 
4588   send(handler) {
4589     if (this.sent) {
4590       return;
4591     }
4592     this.sent = true;
4593 
4594     handler.send("commonobj", [
4595       this.loadedName,
4596       "Font",
4597       this.font.exportData(this._evaluatorOptions.fontExtraProperties),
4598     ]);
4599   }
4600 
4601   fallback(handler) {
4602     if (!this.font.data) {
4603       return;
4604     }
4605     // When font loading failed, fall back to the built-in font renderer.
4606     this.font.disableFontFace = true;
4607     // An arbitrary number of text rendering operators could have been
4608     // encountered between the point in time when the 'Font' message was sent
4609     // to the main-thread, and the point in time when the 'FontFallback'
4610     // message was received on the worker-thread.
4611     // To ensure that all 'FontPath's are available on the main-thread, when
4612     // font loading failed, attempt to resend *all* previously parsed glyphs.
4613     PartialEvaluator.buildFontPaths(
4614       this.font,
4615       /* glyphs = */ this.font.glyphCacheValues,
4616       handler,
4617       this._evaluatorOptions
4618     );
4619   }
4620 
4621   loadType3Data(evaluator, resources, task) {
4622     if (this.type3Loaded) {
4623       return this.type3Loaded;
4624     }
4625     if (!this.font.isType3Font) {
4626       throw new Error("Must be a Type3 font.");
4627     }
4628     // When parsing Type3 glyphs, always ignore them if there are errors.
4629     // Compared to the parsing of e.g. an entire page, it doesn't really
4630     // make sense to only be able to render a Type3 glyph partially.
4631     const type3Evaluator = evaluator.clone({ ignoreErrors: false });
4632     type3Evaluator.parsingType3Font = true;
4633     // Prevent circular references in Type3 fonts.
4634     const type3FontRefs = new RefSet(evaluator.type3FontRefs);
4635     if (this.dict.objId && !type3FontRefs.has(this.dict.objId)) {
4636       type3FontRefs.put(this.dict.objId);
4637     }
4638     type3Evaluator.type3FontRefs = type3FontRefs;
4639 
4640     const translatedFont = this.font,
4641       type3Dependencies = this.type3Dependencies;
4642     let loadCharProcsPromise = Promise.resolve();
4643     const charProcs = this.dict.get("CharProcs");
4644     const fontResources = this.dict.get("Resources") || resources;
4645     const charProcOperatorList = Object.create(null);
4646 
4647     const fontBBox = Util.normalizeRect(translatedFont.bbox || [0, 0, 0, 0]),
4648       width = fontBBox[2] - fontBBox[0],
4649       height = fontBBox[3] - fontBBox[1];
4650     const fontBBoxSize = Math.hypot(width, height);
4651 
4652     for (const key of charProcs.getKeys()) {
4653       loadCharProcsPromise = loadCharProcsPromise.then(() => {
4654         const glyphStream = charProcs.get(key);
4655         const operatorList = new OperatorList();
4656         return type3Evaluator
4657           .getOperatorList({
4658             stream: glyphStream,
4659             task,
4660             resources: fontResources,
4661             operatorList,
4662           })
4663           .then(() => {
4664             // According to the PDF specification, section "9.6.5 Type 3 Fonts"
4665             // and "Table 113":
4666             //  "A glyph description that begins with the d1 operator should
4667             //   not execute any operators that set the colour (or other
4668             //   colour-related parameters) in the graphics state;
4669             //   any use of such operators shall be ignored."
4670             if (operatorList.fnArray[0] === OPS.setCharWidthAndBounds) {
4671               this._removeType3ColorOperators(operatorList, fontBBoxSize);
4672             }
4673             charProcOperatorList[key] = operatorList.getIR();
4674 
4675             for (const dependency of operatorList.dependencies) {
4676               type3Dependencies.add(dependency);
4677             }
4678           })
4679           .catch(function (reason) {
4680             warn(`Type3 font resource "${key}" is not available.`);
4681             const dummyOperatorList = new OperatorList();
4682             charProcOperatorList[key] = dummyOperatorList.getIR();
4683           });
4684       });
4685     }
4686     this.type3Loaded = loadCharProcsPromise.then(() => {
4687       translatedFont.charProcOperatorList = charProcOperatorList;
4688       if (this._bbox) {
4689         translatedFont.isCharBBox = true;
4690         translatedFont.bbox = this._bbox;
4691       }
4692     });
4693     return this.type3Loaded;
4694   }
4695 
4696   /**
4697    * @private
4698    */
4699   _removeType3ColorOperators(operatorList, fontBBoxSize = NaN) {
4700     if (typeof PDFJSDev === "undefined" || PDFJSDev.test("TESTING")) {
4701       assert(
4702         operatorList.fnArray[0] === OPS.setCharWidthAndBounds,
4703         "Type3 glyph shall start with the d1 operator."
4704       );
4705     }
4706     const charBBox = Util.normalizeRect(operatorList.argsArray[0].slice(2)),
4707       width = charBBox[2] - charBBox[0],
4708       height = charBBox[3] - charBBox[1];
4709     const charBBoxSize = Math.hypot(width, height);
4710 
4711     if (width === 0 || height === 0) {
4712       // Skip the d1 operator when its bounds are bogus (fixes issue14953.pdf).
4713       operatorList.fnArray.splice(0, 1);
4714       operatorList.argsArray.splice(0, 1);
4715     } else if (
4716       fontBBoxSize === 0 ||
4717       Math.round(charBBoxSize / fontBBoxSize) >= 10
4718     ) {
4719       // Override the fontBBox when it's undefined/empty, or when it's at least
4720       // (approximately) one order of magnitude smaller than the charBBox
4721       // (fixes issue14999_reduced.pdf).
4722       if (!this._bbox) {
4723         this._bbox = [Infinity, Infinity, -Infinity, -Infinity];
4724       }
4725       this._bbox[0] = Math.min(this._bbox[0], charBBox[0]);
4726       this._bbox[1] = Math.min(this._bbox[1], charBBox[1]);
4727       this._bbox[2] = Math.max(this._bbox[2], charBBox[2]);
4728       this._bbox[3] = Math.max(this._bbox[3], charBBox[3]);
4729     }
4730 
4731     let i = 0,
4732       ii = operatorList.length;
4733     while (i < ii) {
4734       switch (operatorList.fnArray[i]) {
4735         case OPS.setCharWidthAndBounds:
4736           break; // Handled above.
4737         case OPS.setStrokeColorSpace:
4738         case OPS.setFillColorSpace:
4739         case OPS.setStrokeColor:
4740         case OPS.setStrokeColorN:
4741         case OPS.setFillColor:
4742         case OPS.setFillColorN:
4743         case OPS.setStrokeGray:
4744         case OPS.setFillGray:
4745         case OPS.setStrokeRGBColor:
4746         case OPS.setFillRGBColor:
4747         case OPS.setStrokeCMYKColor:
4748         case OPS.setFillCMYKColor:
4749         case OPS.shadingFill:
4750         case OPS.setRenderingIntent:
4751           operatorList.fnArray.splice(i, 1);
4752           operatorList.argsArray.splice(i, 1);
4753           ii--;
4754           continue;
4755 
4756         case OPS.setGState:
4757           const [gStateObj] = operatorList.argsArray[i];
4758           let j = 0,
4759             jj = gStateObj.length;
4760           while (j < jj) {
4761             const [gStateKey] = gStateObj[j];
4762             switch (gStateKey) {
4763               case "TR":
4764               case "TR2":
4765               case "HT":
4766               case "BG":
4767               case "BG2":
4768               case "UCR":
4769               case "UCR2":
4770                 gStateObj.splice(j, 1);
4771                 jj--;
4772                 continue;
4773             }
4774             j++;
4775           }
4776           break;
4777       }
4778       i++;
4779     }
4780   }
4781 }
4782 
4783 class StateManager {
4784   constructor(initialState = new EvalState()) {
4785     this.state = initialState;
4786     this.stateStack = [];
4787   }
4788 
4789   save() {
4790     const old = this.state;
4791     this.stateStack.push(this.state);
4792     this.state = old.clone();
4793   }
4794 
4795   restore() {
4796     const prev = this.stateStack.pop();
4797     if (prev) {
4798       this.state = prev;
4799     }
4800   }
4801 
4802   transform(args) {
4803     this.state.ctm = Util.transform(this.state.ctm, args);
4804   }
4805 }
4806 
4807 class TextState {
4808   constructor() {
4809     this.ctm = new Float32Array(IDENTITY_MATRIX);
4810     this.fontName = null;
4811     this.fontSize = 0;
4812     this.loadedName = null;
4813     this.font = null;
4814     this.fontMatrix = FONT_IDENTITY_MATRIX;
4815     this.textMatrix = IDENTITY_MATRIX.slice();
4816     this.textLineMatrix = IDENTITY_MATRIX.slice();
4817     this.charSpacing = 0;
4818     this.wordSpacing = 0;
4819     this.leading = 0;
4820     this.textHScale = 1;
4821     this.textRise = 0;
4822   }
4823 
4824   setTextMatrix(a, b, c, d, e, f) {
4825     const m = this.textMatrix;
4826     m[0] = a;
4827     m[1] = b;
4828     m[2] = c;
4829     m[3] = d;
4830     m[4] = e;
4831     m[5] = f;
4832   }
4833 
4834   setTextLineMatrix(a, b, c, d, e, f) {
4835     const m = this.textLineMatrix;
4836     m[0] = a;
4837     m[1] = b;
4838     m[2] = c;
4839     m[3] = d;
4840     m[4] = e;
4841     m[5] = f;
4842   }
4843 
4844   translateTextMatrix(x, y) {
4845     const m = this.textMatrix;
4846     m[4] = m[0] * x + m[2] * y + m[4];
4847     m[5] = m[1] * x + m[3] * y + m[5];
4848   }
4849 
4850   translateTextLineMatrix(x, y) {
4851     const m = this.textLineMatrix;
4852     m[4] = m[0] * x + m[2] * y + m[4];
4853     m[5] = m[1] * x + m[3] * y + m[5];
4854   }
4855 
4856   carriageReturn() {
4857     this.translateTextLineMatrix(0, -this.leading);
4858     this.textMatrix = this.textLineMatrix.slice();
4859   }
4860 
4861   clone() {
4862     const clone = Object.create(this);
4863     clone.textMatrix = this.textMatrix.slice();
4864     clone.textLineMatrix = this.textLineMatrix.slice();
4865     clone.fontMatrix = this.fontMatrix.slice();
4866     return clone;
4867   }
4868 }
4869 
4870 class EvalState {
4871   constructor() {
4872     this.ctm = new Float32Array(IDENTITY_MATRIX);
4873     this.font = null;
4874     this.textRenderingMode = TextRenderingMode.FILL;
4875     this.fillColorSpace = ColorSpace.singletons.gray;
4876     this.strokeColorSpace = ColorSpace.singletons.gray;
4877   }
4878 
4879   clone() {
4880     return Object.create(this);
4881   }
4882 }
4883 
4884 class EvaluatorPreprocessor {
4885   static get opMap() {
4886     // Specifies properties for each command
4887     //
4888     // If variableArgs === true: [0, `numArgs`] expected
4889     // If variableArgs === false: exactly `numArgs` expected
4890     return shadow(
4891       this,
4892       "opMap",
4893       Object.assign(Object.create(null), {
4894         // Graphic state
4895         w: { id: OPS.setLineWidth, numArgs: 1, variableArgs: false },
4896         J: { id: OPS.setLineCap, numArgs: 1, variableArgs: false },
4897         j: { id: OPS.setLineJoin, numArgs: 1, variableArgs: false },
4898         M: { id: OPS.setMiterLimit, numArgs: 1, variableArgs: false },
4899         d: { id: OPS.setDash, numArgs: 2, variableArgs: false },
4900         ri: { id: OPS.setRenderingIntent, numArgs: 1, variableArgs: false },
4901         i: { id: OPS.setFlatness, numArgs: 1, variableArgs: false },
4902         gs: { id: OPS.setGState, numArgs: 1, variableArgs: false },
4903         q: { id: OPS.save, numArgs: 0, variableArgs: false },
4904         Q: { id: OPS.restore, numArgs: 0, variableArgs: false },
4905         cm: { id: OPS.transform, numArgs: 6, variableArgs: false },
4906 
4907         // Path
4908         m: { id: OPS.moveTo, numArgs: 2, variableArgs: false },
4909         l: { id: OPS.lineTo, numArgs: 2, variableArgs: false },
4910         c: { id: OPS.curveTo, numArgs: 6, variableArgs: false },
4911         v: { id: OPS.curveTo2, numArgs: 4, variableArgs: false },
4912         y: { id: OPS.curveTo3, numArgs: 4, variableArgs: false },
4913         h: { id: OPS.closePath, numArgs: 0, variableArgs: false },
4914         re: { id: OPS.rectangle, numArgs: 4, variableArgs: false },
4915         S: { id: OPS.stroke, numArgs: 0, variableArgs: false },
4916         s: { id: OPS.closeStroke, numArgs: 0, variableArgs: false },
4917         f: { id: OPS.fill, numArgs: 0, variableArgs: false },
4918         F: { id: OPS.fill, numArgs: 0, variableArgs: false },
4919         "f*": { id: OPS.eoFill, numArgs: 0, variableArgs: false },
4920         B: { id: OPS.fillStroke, numArgs: 0, variableArgs: false },
4921         "B*": { id: OPS.eoFillStroke, numArgs: 0, variableArgs: false },
4922         b: { id: OPS.closeFillStroke, numArgs: 0, variableArgs: false },
4923         "b*": { id: OPS.closeEOFillStroke, numArgs: 0, variableArgs: false },
4924         n: { id: OPS.endPath, numArgs: 0, variableArgs: false },
4925 
4926         // Clipping
4927         W: { id: OPS.clip, numArgs: 0, variableArgs: false },
4928         "W*": { id: OPS.eoClip, numArgs: 0, variableArgs: false },
4929 
4930         // Text
4931         BT: { id: OPS.beginText, numArgs: 0, variableArgs: false },
4932         ET: { id: OPS.endText, numArgs: 0, variableArgs: false },
4933         Tc: { id: OPS.setCharSpacing, numArgs: 1, variableArgs: false },
4934         Tw: { id: OPS.setWordSpacing, numArgs: 1, variableArgs: false },
4935         Tz: { id: OPS.setHScale, numArgs: 1, variableArgs: false },
4936         TL: { id: OPS.setLeading, numArgs: 1, variableArgs: false },
4937         Tf: { id: OPS.setFont, numArgs: 2, variableArgs: false },
4938         Tr: { id: OPS.setTextRenderingMode, numArgs: 1, variableArgs: false },
4939         Ts: { id: OPS.setTextRise, numArgs: 1, variableArgs: false },
4940         Td: { id: OPS.moveText, numArgs: 2, variableArgs: false },
4941         TD: { id: OPS.setLeadingMoveText, numArgs: 2, variableArgs: false },
4942         Tm: { id: OPS.setTextMatrix, numArgs: 6, variableArgs: false },
4943         "T*": { id: OPS.nextLine, numArgs: 0, variableArgs: false },
4944         Tj: { id: OPS.showText, numArgs: 1, variableArgs: false },
4945         TJ: { id: OPS.showSpacedText, numArgs: 1, variableArgs: false },
4946         "'": { id: OPS.nextLineShowText, numArgs: 1, variableArgs: false },
4947         '"': {
4948           id: OPS.nextLineSetSpacingShowText,
4949           numArgs: 3,
4950           variableArgs: false,
4951         },
4952 
4953         // Type3 fonts
4954         d0: { id: OPS.setCharWidth, numArgs: 2, variableArgs: false },
4955         d1: {
4956           id: OPS.setCharWidthAndBounds,
4957           numArgs: 6,
4958           variableArgs: false,
4959         },
4960 
4961         // Color
4962         CS: { id: OPS.setStrokeColorSpace, numArgs: 1, variableArgs: false },
4963         cs: { id: OPS.setFillColorSpace, numArgs: 1, variableArgs: false },
4964         SC: { id: OPS.setStrokeColor, numArgs: 4, variableArgs: true },
4965         SCN: { id: OPS.setStrokeColorN, numArgs: 33, variableArgs: true },
4966         sc: { id: OPS.setFillColor, numArgs: 4, variableArgs: true },
4967         scn: { id: OPS.setFillColorN, numArgs: 33, variableArgs: true },
4968         G: { id: OPS.setStrokeGray, numArgs: 1, variableArgs: false },
4969         g: { id: OPS.setFillGray, numArgs: 1, variableArgs: false },
4970         RG: { id: OPS.setStrokeRGBColor, numArgs: 3, variableArgs: false },
4971         rg: { id: OPS.setFillRGBColor, numArgs: 3, variableArgs: false },
4972         K: { id: OPS.setStrokeCMYKColor, numArgs: 4, variableArgs: false },
4973         k: { id: OPS.setFillCMYKColor, numArgs: 4, variableArgs: false },
4974 
4975         // Shading
4976         sh: { id: OPS.shadingFill, numArgs: 1, variableArgs: false },
4977 
4978         // Images
4979         BI: { id: OPS.beginInlineImage, numArgs: 0, variableArgs: false },
4980         ID: { id: OPS.beginImageData, numArgs: 0, variableArgs: false },
4981         EI: { id: OPS.endInlineImage, numArgs: 1, variableArgs: false },
4982 
4983         // XObjects
4984         Do: { id: OPS.paintXObject, numArgs: 1, variableArgs: false },
4985         MP: { id: OPS.markPoint, numArgs: 1, variableArgs: false },
4986         DP: { id: OPS.markPointProps, numArgs: 2, variableArgs: false },
4987         BMC: { id: OPS.beginMarkedContent, numArgs: 1, variableArgs: false },
4988         BDC: {
4989           id: OPS.beginMarkedContentProps,
4990           numArgs: 2,
4991           variableArgs: false,
4992         },
4993         EMC: { id: OPS.endMarkedContent, numArgs: 0, variableArgs: false },
4994 
4995         // Compatibility
4996         BX: { id: OPS.beginCompat, numArgs: 0, variableArgs: false },
4997         EX: { id: OPS.endCompat, numArgs: 0, variableArgs: false },
4998 
4999         // (reserved partial commands for the lexer)
5000         BM: null,
5001         BD: null,
5002         true: null,
5003         fa: null,
5004         fal: null,
5005         fals: null,
5006         false: null,
5007         nu: null,
5008         nul: null,
5009         null: null,
5010       })
5011     );
5012   }
5013 
5014   static MAX_INVALID_PATH_OPS = 10;
5015 
5016   constructor(stream, xref, stateManager = new StateManager()) {
5017     // TODO(mduan): pass array of knownCommands rather than this.opMap
5018     // dictionary
5019     this.parser = new Parser({
5020       lexer: new Lexer(stream, EvaluatorPreprocessor.opMap),
5021       xref,
5022     });
5023     this.stateManager = stateManager;
5024     this.nonProcessedArgs = [];
5025     this._isPathOp = false;
5026     this._numInvalidPathOPS = 0;
5027   }
5028 
5029   get savedStatesDepth() {
5030     return this.stateManager.stateStack.length;
5031   }
5032 
5033   // |operation| is an object with two fields:
5034   //
5035   // - |fn| is an out param.
5036   //
5037   // - |args| is an inout param. On entry, it should have one of two values.
5038   //
5039   //   - An empty array. This indicates that the caller is providing the
5040   //     array in which the args will be stored in. The caller should use
5041   //     this value if it can reuse a single array for each call to read().
5042   //
5043   //   - |null|. This indicates that the caller needs this function to create
5044   //     the array in which any args are stored in. If there are zero args,
5045   //     this function will leave |operation.args| as |null| (thus avoiding
5046   //     allocations that would occur if we used an empty array to represent
5047   //     zero arguments). Otherwise, it will replace |null| with a new array
5048   //     containing the arguments. The caller should use this value if it
5049   //     cannot reuse an array for each call to read().
5050   //
5051   // These two modes are present because this function is very hot and so
5052   // avoiding allocations where possible is worthwhile.
5053   //
5054   read(operation) {
5055     let args = operation.args;
5056     while (true) {
5057       const obj = this.parser.getObj();
5058       if (obj instanceof Cmd) {
5059         const cmd = obj.cmd;
5060         // Check that the command is valid
5061         const opSpec = EvaluatorPreprocessor.opMap[cmd];
5062         if (!opSpec) {
5063           warn(`Unknown command "${cmd}".`);
5064           continue;
5065         }
5066 
5067         const fn = opSpec.id;
5068         const numArgs = opSpec.numArgs;
5069         let argsLength = args !== null ? args.length : 0;
5070 
5071         // If the *previous* command wasn't a path operator, reset the heuristic
5072         // used with incomplete path operators below (fixes issue14917.pdf).
5073         if (!this._isPathOp) {
5074           this._numInvalidPathOPS = 0;
5075         }
5076         this._isPathOp = fn >= OPS.moveTo && fn <= OPS.endPath;
5077 
5078         if (!opSpec.variableArgs) {
5079           // Postscript commands can be nested, e.g. /F2 /GS2 gs 5.711 Tf
5080           if (argsLength !== numArgs) {
5081             const nonProcessedArgs = this.nonProcessedArgs;
5082             while (argsLength > numArgs) {
5083               nonProcessedArgs.push(args.shift());
5084               argsLength--;
5085             }
5086             while (argsLength < numArgs && nonProcessedArgs.length !== 0) {
5087               if (args === null) {
5088                 args = [];
5089               }
5090               args.unshift(nonProcessedArgs.pop());
5091               argsLength++;
5092             }
5093           }
5094 
5095           if (argsLength < numArgs) {
5096             const partialMsg =
5097               `command ${cmd}: expected ${numArgs} args, ` +
5098               `but received ${argsLength} args.`;
5099 
5100             // Incomplete path operators, in particular, can result in fairly
5101             // chaotic rendering artifacts. Hence the following heuristics is
5102             // used to error, rather than just warn, once a number of invalid
5103             // path operators have been encountered (fixes bug1443140.pdf).
5104             if (
5105               this._isPathOp &&
5106               ++this._numInvalidPathOPS >
5107                 EvaluatorPreprocessor.MAX_INVALID_PATH_OPS
5108             ) {
5109               throw new FormatError(`Invalid ${partialMsg}`);
5110             }
5111             // If we receive too few arguments, it's not possible to execute
5112             // the command, hence we skip the command.
5113             warn(`Skipping ${partialMsg}`);
5114             if (args !== null) {
5115               args.length = 0;
5116             }
5117             continue;
5118           }
5119         } else if (argsLength > numArgs) {
5120           info(
5121             `Command ${cmd}: expected [0, ${numArgs}] args, ` +
5122               `but received ${argsLength} args.`
5123           );
5124         }
5125 
5126         // TODO figure out how to type-check vararg functions
5127         this.preprocessCommand(fn, args);
5128 
5129         operation.fn = fn;
5130         operation.args = args;
5131         return true;
5132       }
5133       if (obj === EOF) {
5134         return false; // no more commands
5135       }
5136       // argument
5137       if (obj !== null) {
5138         if (args === null) {
5139           args = [];
5140         }
5141         args.push(obj);
5142         if (args.length > 33) {
5143           throw new FormatError("Too many arguments");
5144         }
5145       }
5146     }
5147   }
5148 
5149   preprocessCommand(fn, args) {
5150     switch (fn | 0) {
5151       case OPS.save:
5152         this.stateManager.save();
5153         break;
5154       case OPS.restore:
5155         this.stateManager.restore();
5156         break;
5157       case OPS.transform:
5158         this.stateManager.transform(args);
5159         break;
5160     }
5161   }
5162 }
5163 
5164 export { EvaluatorPreprocessor, PartialEvaluator };
</code>

Test file:
<test_file>
File:
test/unit/evaluator_spec.js
/* Copyright 2017 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import { createIdFactory, XRefMock } from "./test_utils.js";
import { Dict, Name } from "../../src/core/primitives.js";
import { FormatError, OPS } from "../../src/shared/util.js";
import { Stream, StringStream } from "../../src/core/stream.js";
import { OperatorList } from "../../src/core/operator_list.js";
import { PartialEvaluator } from "../../src/core/evaluator.js";
import { WorkerTask } from "../../src/core/worker.js";
</test_file>

Your task:
You are a software tester at pdf.js.
1. Examine the existing test file. You may reuse any imports, helpers or setup blocks it already has.
2. Write exactly one javascript test `it("...", async () => {...})` block.
3. Your test must fail on the code before the patch, and pass after, hence the test will verify that the patch resolves the issue.
4. The test must be self-contained and to-the-point.
5. If you need something new use only the provided imports (respect the paths exactly how they are given) by importing dynamically for compatibility with Node.js — no new dependencies. 
6. Return only the javascript code for the new `it(...)` block (no comments or explanations).

Example structure:
it("should <describe behavior>", async () => {
  const { example } = await import("../../src/core/example.js");
  <initialize required variables>;
  <define expected variable>;
  <generate actual variables>;
  <compare expected with actual>;
});

