Before you begin:
- Keep going until the job is completely solved — don’t stop halfway.
- If you’re unsure about the behavior, reread the provided patch carefully; do not hallucinate.
- Plan your approach before writing code by reflecting on whether the test truly fails before and passes after.

Issue:
<issue>
Extra line breaks are missing when PDF is loaded
Sample PDF file to reproduce this issue:
[sample.pdf](https://github.com/mozilla/pdf.js/files/15180747/sample.pdf)

It seems that the issue https://github.com/mozilla/pdf.js/issues/17492 was not fully fixed.
It's the same steps to reproduce.
1. Load this PDF file at https://mozilla.github.io/pdf.js/web/viewer.html
Actual result:
There is no missing blank line between rows 1 and 2, 3 and 4.
![image](https://github.com/mozilla/pdf.js/assets/2846956/4bef68fb-ee7b-4084-a161-ea3b0a91536f)

Expected result:
The extra line breaks are available if you open this file in Foxit PDF viewer or Google Chrome.
![image](https://github.com/mozilla/pdf.js/assets/2846956/23780db8-79d0-4afa-96f1-4ff882d44877)


</issue>

Patch:
<patch>
diff --git a/src/core/annotation.js b/src/core/annotation.js
--- a/src/core/annotation.js
+++ b/src/core/annotation.js
@@ -2299,7 +2299,7 @@ class WidgetAnnotation extends Annotation {
     }
 
     assert(typeof value === "string", "Expected `value` to be a string.");
-    value = value.trim();
+    value = value.trimEnd();
 
     if (this.data.combo) {
       // The value can be one of the exportValue or any other values.
@@ -2934,6 +2934,28 @@ class TextWidgetAnnotation extends WidgetAnnotation {
     return chunks;
   }
 
+  async extractTextContent(evaluator, task, viewBox) {
+    await super.extractTextContent(evaluator, task, viewBox);
+    const text = this.data.textContent;
+    if (!text) {
+      return;
+    }
+
+    // The text extractor doesn't handle empty lines correctly, so if the
+    // content we get is more or less (modulo whitespaces) the same as the
+    // field value we just ignore it.
+    const allText = text.join("\n");
+    if (allText === this.data.fieldValue) {
+      return;
+    }
+    const regex = allText.replaceAll(/([.*+?^${}()|[\]\\])|(\s+)/g, (_m, p1) =>
+      p1 ? `\\${p1}` : "\\s+"
+    );
+    if (new RegExp(`^\\s*${regex}\\s*$`).test(this.data.fieldValue)) {
+      this.data.textContent = this.data.fieldValue.split("\n");
+    }
+  }
+
   getFieldObject() {
     return {
       id: this.data.id,


</patch>

Imports:
<imports>
Available Packages
Dev Dependencies:
- @babel/core: ^7.25.2
- @babel/preset-env: ^7.25.4
- @babel/runtime: ^7.25.6
- @fluent/bundle: ^0.18.0
- @fluent/dom: ^0.10.0
- @jazzer.js/core: ^2.1.0
- @metalsmith/layouts: ^2.7.0
- @metalsmith/markdown: ^1.10.0
- autoprefixer: ^10.4.20
- babel-loader: ^9.2.1
- caniuse-lite: ^1.0.30001662
- canvas: ^2.11.2
- core-js: ^3.38.1
- eslint: ^8.57.0
- eslint-config-prettier: ^9.1.0
- eslint-plugin-fetch-options: ^0.0.5
- eslint-plugin-html: ^8.1.1
- eslint-plugin-import: ^2.30.0
- eslint-plugin-jasmine: ^4.2.2
- eslint-plugin-json: ^3.1.0
- eslint-plugin-no-unsanitized: ^4.1.0
- eslint-plugin-prettier: ^5.2.1
- eslint-plugin-sort-exports: ^0.9.1
- eslint-plugin-unicorn: ^55.0.0
- gulp: ^5.0.0
- gulp-cli: ^3.0.0
- gulp-postcss: ^10.0.0
- gulp-rename: ^2.0.0
- gulp-replace: ^1.1.4
- gulp-zip: ^6.0.0
- highlight.js: ^11.10.0
- jasmine: ^5.3.0
- jsdoc: ^4.0.3
- jstransformer-nunjucks: ^1.2.0
- metalsmith: ^2.6.3
- metalsmith-html-relative: ^2.0.4
- ordered-read-streams: ^2.0.0
- path2d: ^0.2.1
- pngjs: ^7.0.0
- postcss: ^8.4.47
- postcss-dark-theme-class: ^1.3.0
- postcss-dir-pseudo-class: ^9.0.0
- postcss-discard-comments: ^7.0.3
- postcss-nesting: ^13.0.0
- prettier: ^3.3.3
- puppeteer: 23.3.1
- stylelint: ^16.9.0
- stylelint-prettier: ^5.0.2
- svglint: ^3.0.0
- terser-webpack-plugin: ^5.3.10
- tsc-alias: ^1.8.10
- ttest: ^4.0.0
- typescript: ^5.6.2
- vinyl: ^3.0.0
- webpack: ^5.94.0
- webpack-stream: ^7.0.0
- yargs: ^17.7.2

Engines:
- node: >=18

Available Relative Imports:
- `../../src/core/annotation.js`: Annotation, AnnotationBorderStyle, AnnotationFactory, MarkupAnnotation, getQuadPoints
- `../../src/core/bidi.js`: bidi
- `../../src/core/cff_parser.js`: CFFCharset, CFFCompiler, CFFFDSelect, CFFParser, CFFStrings
- `../../src/core/cmap.js`: CMap, CMapFactory, IdentityCMap
- `../../src/core/colorspace.js`: ColorSpace
- `../../src/core/core_utils.js`: arrayBuffersToBytes, encodeToXmlString, escapePDFName, escapeString, getInheritableProperty, getSizeInBytes, isAscii, isWhiteSpace, log2, numberToString, parseXFAPath, recoverJsURL, stringToUTF16HexString, stringToUTF16String, toRomanNumerals, validateCSSFont
- `../../src/core/crypto.js`: AES128Cipher, AES256Cipher, ARCFourCipher, CipherTransformFactory, PDF17, PDF20, calculateMD5, calculateSHA256, calculateSHA384, calculateSHA512
- `../../src/core/default_appearance.js`: createDefaultAppearance, parseAppearanceStream, parseDefaultAppearance
- `../../src/core/document.js`: PDFDocument, Page
- `../../src/core/encodings.js`: getEncoding
- `../../src/core/evaluator.js`: PartialEvaluator
- `../../src/core/flate_stream.js`: FlateStream
- `../../src/core/font_substitutions.js`: getFontSubstitution
- `../../src/core/fonts_utils.js`: SEAC_ANALYSIS_ENABLED
- `../../src/core/function.js`: PDFFunctionFactory, PostScriptCompiler, PostScriptEvaluator
- `../../src/core/glyphlist.js`: getDingbatsGlyphsUnicode, getGlyphsUnicode
- `../../src/core/image_utils.js`: GlobalImageCache, LocalColorSpaceCache
- `../../src/core/jbig2.js`: Jbig2Error, Jbig2Image
- `../../src/core/jpg.js`: JpegError, JpegImage
- `../../src/core/jpx.js`: JpxError, JpxImage
- `../../src/core/metadata_parser.js`: MetadataParser
- `../../src/core/operator_list.js`: OperatorList
- `../../src/core/parser.js`: Lexer, Linearization, Parser
- `../../src/core/predictor_stream.js`: PredictorStream
- `../../src/core/primitives.js`: Cmd, Dict, EOF, Name, Ref, RefSet, RefSetCache, isCmd, isDict, isName, isRefsEqual
- `../../src/core/ps_parser.js`: PostScriptLexer, PostScriptParser
- `../../src/core/stream.js`: NullStream, Stream, StringStream
- `../../src/core/type1_parser.js`: Type1Parser
- `../../src/core/unicode.js`: getCharUnicodeCategory, getUnicodeForGlyph, getUnicodeRangeFor, mapSpecialUnicodeValues
- `../../src/core/worker.js`: WorkerMessageHandler, WorkerTask
- `../../src/core/writer.js`: incrementalUpdate, writeDict
- `../../src/core/xfa/bind.js`: Binder
- `../../src/core/xfa/data.js`: DataHandler
- `../../src/core/xfa/factory.js`: XFAFactory
- `../../src/core/xfa/formcalc_lexer.js`: Lexer, TOKEN, Token
- `../../src/core/xfa/formcalc_parser.js`: Errors, Parser
- `../../src/core/xfa/parser.js`: XFAParser
- `../../src/core/xfa/som.js`: searchNode
- `../../src/core/xfa/symbol_utils.js`: $dump, $getChildren, $getChildrenByClass, $getChildrenByName, $text, $uid
- `../../src/core/xml_parser.js`: SimpleXMLParser, XMLParserBase
- `../../src/display/annotation_layer.js`: AnnotationLayer
- `../../src/display/annotation_storage.js`: AnnotationStorage
- `../../src/display/api.js`: DefaultCMapReaderFactory, DefaultCanvasFactory, DefaultStandardFontDataFactory, LoopbackPort, PDFDataRangeTransport, PDFDocumentLoadingTask, PDFDocumentProxy, PDFPageProxy, PDFWorker, RenderTask, build, getDocument, version
- `../../src/display/display_utils.js`: DOMCanvasFactory, DOMSVGFactory, OutputScale, PDFDateString, PageViewport, PixelsPerInch, RenderingCancelledException, StatTimer, fetchData, getFilenameFromUrl, getPdfFilenameFromUrl, getXfaPageViewport, isDataScheme, isPdfFile, isValidFetchUrl, noContextMenu, setLayerDimensions
- `../../src/display/draw_layer.js`: DrawLayer
- `../../src/display/editor/annotation_editor_layer.js`: AnnotationEditorLayer
- `../../src/display/editor/color_picker.js`: ColorPicker
- `../../src/display/editor/tools.js`: AnnotationEditorUIManager, CommandManager
- `../../src/display/fetch_stream.js`: PDFFetchStream
- `../../src/display/metadata.js`: Metadata
- `../../src/display/network.js`: PDFNetworkStream
- `../../src/display/network_utils.js`: createHeaders, createResponseStatusError, extractFilenameFromHeader, validateRangeRequestCapabilities, validateResponseStatus
- `../../src/display/node_stream.js`: PDFNodeStream
- `../../src/display/node_utils.js`: NodePackages
- `../../src/display/text_layer.js`: TextLayer
- `../../src/display/worker_options.js`: GlobalWorkerOptions
- `../../src/display/xfa_layer.js`: XfaLayer
- `../../src/shared/message_handler.js`: MessageHandler
- `../../src/shared/murmurhash3.js`: MurmurHash3_64
- `../../src/shared/util.js`: AbortException, AnnotationBorderStyleType, AnnotationEditorParamsType, AnnotationEditorType, AnnotationFieldFlag, AnnotationFlag, AnnotationMode, AnnotationType, BaseException, CMapCompressionType, FeatureTest, FormatError, ImageKind, InvalidPDFException, MissingPDFException, OPS, PasswordException, PasswordResponses, PermissionFlag, RenderingIntentFlag, UnexpectedResponseException, UnknownErrorException, Util, VerbosityLevel, assert, bytesToString, createValidAbsoluteUrl, getModificationDate, getVerbosityLevel, isNodeJS, normalizeUnicode, objectSize, setVerbosityLevel, shadow, string32, stringToBytes, stringToPDFString, stringToUTF8String
- `../../web/annotation_layer_builder.js`: AnnotationLayerBuilder
- `../../web/app_options.js`: AppOptions, OptionKind
- `../../web/download_manager.js`: DownloadManager
- `../../web/event_utils.js`: EventBus, WaitOnType, waitOnEventOrTimeout
- `../../web/genericl10n.js`: GenericL10n
- `../../web/pdf_find_controller.js`: FindState, PDFFindController
- `../../web/pdf_find_utils.js`: CharacterType, getCharacterType
- `../../web/pdf_history.js`: PDFHistory, isDestArraysEqual, isDestHashesEqual
- `../../web/pdf_link_service.js`: LinkTarget, PDFLinkService, SimpleLinkService
- `../../web/pdf_page_view.js`: PDFPageView
- `../../web/pdf_scripting_manager.component.js`: PDFScriptingManager
- `../../web/pdf_single_page_viewer.js`: PDFSinglePageViewer
- `../../web/pdf_viewer.js`: PDFPageViewBuffer, PDFViewer
- `../../web/struct_tree_layer_builder.js`: StructTreeLayerBuilder
- `../../web/text_layer_builder.js`: TextLayerBuilder
- `../../web/ui_utils.js`: AutoPrintRegExp, ProgressBar, RenderingStates, ScrollMode, SpreadMode, backtrackBeforeAllVisibleElements, binarySearchFirstItem, calcRound, getPageSizeInches, getVisibleElements, isPortraitOrientation, isValidRotation, parseQueryString, removeNullCharacters
- `../../web/xfa_layer_builder.js`: XfaLayerBuilder
- `./test_utils.js`: CMAP_URL, DefaultFileReaderFactory, STANDARD_FONT_DATA_URL, TEST_PDFS_PATH, XRefMock, buildGetDocumentParams, createIdFactory, createTemporaryNodeServer
- `./testreporter.js`: TestReporter
</imports>

Code:
<code>
File:
src/core/annotation.js
1 /* Copyright 2012 Mozilla Foundation
2  *
3  * Licensed under the Apache License, Version 2.0 (the "License");
4  * you may not use this file except in compliance with the License.
5  * You may obtain a copy of the License at
6  *
7  *     http://www.apache.org/licenses/LICENSE-2.0
8  *
9  * Unless required by applicable law or agreed to in writing, software
10  * distributed under the License is distributed on an "AS IS" BASIS,
11  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
12  * See the License for the specific language governing permissions and
13  * limitations under the License.
14  */
15 
16 import {
17   AnnotationActionEventType,
18   AnnotationBorderStyleType,
19   AnnotationEditorType,
20   AnnotationFieldFlag,
21   AnnotationFlag,
22   AnnotationReplyType,
23   AnnotationType,
24   assert,
25   BASELINE_FACTOR,
26   FeatureTest,
27   getModificationDate,
28   IDENTITY_MATRIX,
29   info,
30   isArrayEqual,
31   LINE_DESCENT_FACTOR,
32   LINE_FACTOR,
33   OPS,
34   RenderingIntentFlag,
35   shadow,
36   stringToPDFString,
37   unreachable,
38   Util,
39   warn,
40 } from "../shared/util.js";
41 import {
42   collectActions,
43   escapeString,
44   getInheritableProperty,
45   getRotationMatrix,
46   isNumberArray,
47   lookupMatrix,
48   lookupNormalRect,
49   lookupRect,
50   numberToString,
51   stringToAsciiOrUTF16BE,
52   stringToUTF16String,
53 } from "./core_utils.js";
54 import {
55   createDefaultAppearance,
56   FakeUnicodeFont,
57   getPdfColor,
58   parseAppearanceStream,
59   parseDefaultAppearance,
60 } from "./default_appearance.js";
61 import { Dict, isName, isRefsEqual, Name, Ref, RefSet } from "./primitives.js";
62 import { Stream, StringStream } from "./stream.js";
63 import { BaseStream } from "./base_stream.js";
64 import { bidi } from "./bidi.js";
65 import { Catalog } from "./catalog.js";
66 import { ColorSpace } from "./colorspace.js";
67 import { FileSpec } from "./file_spec.js";
68 import { JpegStream } from "./jpeg_stream.js";
69 import { ObjectLoader } from "./object_loader.js";
70 import { OperatorList } from "./operator_list.js";
71 import { writeObject } from "./writer.js";
72 import { XFAFactory } from "./xfa/factory.js";
73 
74 class AnnotationFactory {
75   static createGlobals(pdfManager) {
76     return Promise.all([
77       pdfManager.ensureCatalog("acroForm"),
78       pdfManager.ensureDoc("xfaDatasets"),
79       pdfManager.ensureCatalog("structTreeRoot"),
80       // Only necessary to prevent the `Catalog.baseUrl`-getter, used
81       // with some Annotations, from throwing and thus breaking parsing:
82       pdfManager.ensureCatalog("baseUrl"),
83       // Only necessary to prevent the `Catalog.attachments`-getter, used
84       // with "GoToE" actions, from throwing and thus breaking parsing:
85       pdfManager.ensureCatalog("attachments"),
86     ]).then(
87       // eslint-disable-next-line arrow-body-style
88       ([acroForm, xfaDatasets, structTreeRoot, baseUrl, attachments]) => {
89         return {
90           pdfManager,
91           acroForm: acroForm instanceof Dict ? acroForm : Dict.empty,
92           xfaDatasets,
93           structTreeRoot,
94           baseUrl,
95           attachments,
96         };
97       },
98       reason => {
99         warn(`createGlobals: "${reason}".`);
100         return null;
101       }
102     );
103   }
104 
105   /**
106    * Create an `Annotation` object of the correct type for the given reference
107    * to an annotation dictionary. This yields a promise that is resolved when
108    * the `Annotation` object is constructed.
109    *
110    * @param {XRef} xref
111    * @param {Object} ref
112    * @params {Object} annotationGlobals
113    * @param {Object} idFactory
114    * @param {boolean} [collectFields]
115    * @param {Object} [orphanFields]
116    * @param {Object} [pageRef]
117    * @returns {Promise} A promise that is resolved with an {Annotation}
118    *   instance.
119    */
120   static async create(
121     xref,
122     ref,
123     annotationGlobals,
124     idFactory,
125     collectFields,
126     orphanFields,
127     pageRef
128   ) {
129     const pageIndex = collectFields
130       ? await this._getPageIndex(xref, ref, annotationGlobals.pdfManager)
131       : null;
132 
133     return annotationGlobals.pdfManager.ensure(this, "_create", [
134       xref,
135       ref,
136       annotationGlobals,
137       idFactory,
138       collectFields,
139       orphanFields,
140       pageIndex,
141       pageRef,
142     ]);
143   }
144 
145   /**
146    * @private
147    */
148   static _create(
149     xref,
150     ref,
151     annotationGlobals,
152     idFactory,
153     collectFields = false,
154     orphanFields = null,
155     pageIndex = null,
156     pageRef = null
157   ) {
158     const dict = xref.fetchIfRef(ref);
159     if (!(dict instanceof Dict)) {
160       return undefined;
161     }
162 
163     const { acroForm, pdfManager } = annotationGlobals;
164     const id =
165       ref instanceof Ref ? ref.toString() : `annot_${idFactory.createObjId()}`;
166 
167     // Determine the annotation's subtype.
168     let subtype = dict.get("Subtype");
169     subtype = subtype instanceof Name ? subtype.name : null;
170 
171     // Return the right annotation object based on the subtype and field type.
172     const parameters = {
173       xref,
174       ref,
175       dict,
176       subtype,
177       id,
178       annotationGlobals,
179       collectFields,
180       orphanFields,
181       needAppearances:
182         !collectFields && acroForm.get("NeedAppearances") === true,
183       pageIndex,
184       evaluatorOptions: pdfManager.evaluatorOptions,
185       pageRef,
186     };
187 
188     switch (subtype) {
189       case "Link":
190         return new LinkAnnotation(parameters);
191 
192       case "Text":
193         return new TextAnnotation(parameters);
194 
195       case "Widget":
196         let fieldType = getInheritableProperty({ dict, key: "FT" });
197         fieldType = fieldType instanceof Name ? fieldType.name : null;
198 
199         switch (fieldType) {
200           case "Tx":
201             return new TextWidgetAnnotation(parameters);
202           case "Btn":
203             return new ButtonWidgetAnnotation(parameters);
204           case "Ch":
205             return new ChoiceWidgetAnnotation(parameters);
206           case "Sig":
207             return new SignatureWidgetAnnotation(parameters);
208         }
209         warn(
210           `Unimplemented widget field type "${fieldType}", ` +
211             "falling back to base field type."
212         );
213         return new WidgetAnnotation(parameters);
214 
215       case "Popup":
216         return new PopupAnnotation(parameters);
217 
218       case "FreeText":
219         return new FreeTextAnnotation(parameters);
220 
221       case "Line":
222         return new LineAnnotation(parameters);
223 
224       case "Square":
225         return new SquareAnnotation(parameters);
226 
227       case "Circle":
228         return new CircleAnnotation(parameters);
229 
230       case "PolyLine":
231         return new PolylineAnnotation(parameters);
232 
233       case "Polygon":
234         return new PolygonAnnotation(parameters);
235 
236       case "Caret":
237         return new CaretAnnotation(parameters);
238 
239       case "Ink":
240         return new InkAnnotation(parameters);
241 
242       case "Highlight":
243         return new HighlightAnnotation(parameters);
244 
245       case "Underline":
246         return new UnderlineAnnotation(parameters);
247 
248       case "Squiggly":
249         return new SquigglyAnnotation(parameters);
250 
251       case "StrikeOut":
252         return new StrikeOutAnnotation(parameters);
253 
254       case "Stamp":
255         return new StampAnnotation(parameters);
256 
257       case "FileAttachment":
258         return new FileAttachmentAnnotation(parameters);
259 
260       default:
261         if (!collectFields) {
262           if (!subtype) {
263             warn("Annotation is missing the required /Subtype.");
264           } else {
265             warn(
266               `Unimplemented annotation type "${subtype}", ` +
267                 "falling back to base annotation."
268             );
269           }
270         }
271         return new Annotation(parameters);
272     }
273   }
274 
275   static async _getPageIndex(xref, ref, pdfManager) {
276     try {
277       const annotDict = await xref.fetchIfRefAsync(ref);
278       if (!(annotDict instanceof Dict)) {
279         return -1;
280       }
281       const pageRef = annotDict.getRaw("P");
282       if (pageRef instanceof Ref) {
283         try {
284           const pageIndex = await pdfManager.ensureCatalog("getPageIndex", [
285             pageRef,
286           ]);
287           return pageIndex;
288         } catch (ex) {
289           info(`_getPageIndex -- not a valid page reference: "${ex}".`);
290         }
291       }
292       if (annotDict.has("Kids")) {
293         return -1; // Not an annotation reference.
294       }
295       // Fallback to, potentially, checking the annotations of all pages.
296       // PLEASE NOTE: This could force the *entire* PDF document to load,
297       //              hence it absolutely cannot be done unconditionally.
298       const numPages = await pdfManager.ensureDoc("numPages");
299 
300       for (let pageIndex = 0; pageIndex < numPages; pageIndex++) {
301         const page = await pdfManager.getPage(pageIndex);
302         const annotations = await pdfManager.ensure(page, "annotations");
303 
304         for (const annotRef of annotations) {
305           if (annotRef instanceof Ref && isRefsEqual(annotRef, ref)) {
306             return pageIndex;
307           }
308         }
309       }
310     } catch (ex) {
311       warn(`_getPageIndex: "${ex}".`);
312     }
313     return -1;
314   }
315 
316   static generateImages(annotations, xref, isOffscreenCanvasSupported) {
317     if (!isOffscreenCanvasSupported) {
318       warn(
319         "generateImages: OffscreenCanvas is not supported, cannot save or print some annotations with images."
320       );
321       return null;
322     }
323     let imagePromises;
324     for (const { bitmapId, bitmap } of annotations) {
325       if (!bitmap) {
326         continue;
327       }
328       imagePromises ||= new Map();
329       imagePromises.set(bitmapId, StampAnnotation.createImage(bitmap, xref));
330     }
331 
332     return imagePromises;
333   }
334 
335   static async saveNewAnnotations(evaluator, task, annotations, imagePromises) {
336     const xref = evaluator.xref;
337     let baseFontRef;
338     const dependencies = [];
339     const promises = [];
340     const { isOffscreenCanvasSupported } = evaluator.options;
341 
342     for (const annotation of annotations) {
343       if (annotation.deleted) {
344         continue;
345       }
346       switch (annotation.annotationType) {
347         case AnnotationEditorType.FREETEXT:
348           if (!baseFontRef) {
349             const baseFont = new Dict(xref);
350             baseFont.set("BaseFont", Name.get("Helvetica"));
351             baseFont.set("Type", Name.get("Font"));
352             baseFont.set("Subtype", Name.get("Type1"));
353             baseFont.set("Encoding", Name.get("WinAnsiEncoding"));
354             const buffer = [];
355             baseFontRef = xref.getNewTemporaryRef();
356             await writeObject(baseFontRef, baseFont, buffer, xref);
357             dependencies.push({ ref: baseFontRef, data: buffer.join("") });
358           }
359           promises.push(
360             FreeTextAnnotation.createNewAnnotation(
361               xref,
362               annotation,
363               dependencies,
364               { evaluator, task, baseFontRef }
365             )
366           );
367           break;
368         case AnnotationEditorType.HIGHLIGHT:
369           if (annotation.quadPoints) {
370             promises.push(
371               HighlightAnnotation.createNewAnnotation(
372                 xref,
373                 annotation,
374                 dependencies
375               )
376             );
377           } else {
378             promises.push(
379               InkAnnotation.createNewAnnotation(xref, annotation, dependencies)
380             );
381           }
382           break;
383         case AnnotationEditorType.INK:
384           promises.push(
385             InkAnnotation.createNewAnnotation(xref, annotation, dependencies)
386           );
387           break;
388         case AnnotationEditorType.STAMP:
389           const image = isOffscreenCanvasSupported
390             ? await imagePromises?.get(annotation.bitmapId)
391             : null;
392           if (image?.imageStream) {
393             const { imageStream, smaskStream } = image;
394             const buffer = [];
395             if (smaskStream) {
396               const smaskRef = xref.getNewTemporaryRef();
397               await writeObject(smaskRef, smaskStream, buffer, xref);
398               dependencies.push({ ref: smaskRef, data: buffer.join("") });
399               imageStream.dict.set("SMask", smaskRef);
400               buffer.length = 0;
401             }
402             const imageRef = (image.imageRef = xref.getNewTemporaryRef());
403             await writeObject(imageRef, imageStream, buffer, xref);
404             dependencies.push({ ref: imageRef, data: buffer.join("") });
405             image.imageStream = image.smaskStream = null;
406           }
407           promises.push(
408             StampAnnotation.createNewAnnotation(
409               xref,
410               annotation,
411               dependencies,
412               { image }
413             )
414           );
415           break;
416       }
417     }
418 
419     return {
420       annotations: await Promise.all(promises),
421       dependencies,
422     };
423   }
424 
425   static async printNewAnnotations(
426     annotationGlobals,
427     evaluator,
428     task,
429     annotations,
430     imagePromises
431   ) {
432     if (!annotations) {
433       return null;
434     }
435 
436     const { options, xref } = evaluator;
437     const promises = [];
438     for (const annotation of annotations) {
439       if (annotation.deleted) {
440         continue;
441       }
442       switch (annotation.annotationType) {
443         case AnnotationEditorType.FREETEXT:
444           promises.push(
445             FreeTextAnnotation.createNewPrintAnnotation(
446               annotationGlobals,
447               xref,
448               annotation,
449               {
450                 evaluator,
451                 task,
452                 evaluatorOptions: options,
453               }
454             )
455           );
456           break;
457         case AnnotationEditorType.HIGHLIGHT:
458           if (annotation.quadPoints) {
459             promises.push(
460               HighlightAnnotation.createNewPrintAnnotation(
461                 annotationGlobals,
462                 xref,
463                 annotation,
464                 {
465                   evaluatorOptions: options,
466                 }
467               )
468             );
469           } else {
470             promises.push(
471               InkAnnotation.createNewPrintAnnotation(
472                 annotationGlobals,
473                 xref,
474                 annotation,
475                 {
476                   evaluatorOptions: options,
477                 }
478               )
479             );
480           }
481           break;
482         case AnnotationEditorType.INK:
483           promises.push(
484             InkAnnotation.createNewPrintAnnotation(
485               annotationGlobals,
486               xref,
487               annotation,
488               {
489                 evaluatorOptions: options,
490               }
491             )
492           );
493           break;
494         case AnnotationEditorType.STAMP:
495           const image = options.isOffscreenCanvasSupported
496             ? await imagePromises?.get(annotation.bitmapId)
497             : null;
498           if (image?.imageStream) {
499             const { imageStream, smaskStream } = image;
500             if (smaskStream) {
501               imageStream.dict.set("SMask", smaskStream);
502             }
503             image.imageRef = new JpegStream(imageStream, imageStream.length);
504             image.imageStream = image.smaskStream = null;
505           }
506           promises.push(
507             StampAnnotation.createNewPrintAnnotation(
508               annotationGlobals,
509               xref,
510               annotation,
511               {
512                 image,
513                 evaluatorOptions: options,
514               }
515             )
516           );
517           break;
518       }
519     }
520 
521     return Promise.all(promises);
522   }
523 }
524 
525 function getRgbColor(color, defaultColor = new Uint8ClampedArray(3)) {
526   if (!Array.isArray(color)) {
527     return defaultColor;
528   }
529 
530   const rgbColor = defaultColor || new Uint8ClampedArray(3);
531   switch (color.length) {
532     case 0: // Transparent, which we indicate with a null value
533       return null;
534 
535     case 1: // Convert grayscale to RGB
536       ColorSpace.singletons.gray.getRgbItem(color, 0, rgbColor, 0);
537       return rgbColor;
538 
539     case 3: // Convert RGB percentages to RGB
540       ColorSpace.singletons.rgb.getRgbItem(color, 0, rgbColor, 0);
541       return rgbColor;
542 
543     case 4: // Convert CMYK to RGB
544       ColorSpace.singletons.cmyk.getRgbItem(color, 0, rgbColor, 0);
545       return rgbColor;
546 
547     default:
548       return defaultColor;
549   }
550 }
551 
552 function getPdfColorArray(color) {
553   return Array.from(color, c => c / 255);
554 }
555 
556 function getQuadPoints(dict, rect) {
557   // The region is described as a number of quadrilaterals.
558   // Each quadrilateral must consist of eight coordinates.
559   const quadPoints = dict.getArray("QuadPoints");
560   if (
561     !isNumberArray(quadPoints, null) ||
562     quadPoints.length === 0 ||
563     quadPoints.length % 8 > 0
564   ) {
565     return null;
566   }
567 
568   const newQuadPoints = new Float32Array(quadPoints.length);
569   for (let i = 0, ii = quadPoints.length; i < ii; i += 8) {
570     // Each series of eight numbers represents the coordinates for one
571     // quadrilateral in the order [x1, y1, x2, y2, x3, y3, x4, y4].
572     // Convert this to an array of objects with x and y coordinates.
573     const [x1, y1, x2, y2, x3, y3, x4, y4] = quadPoints.slice(i, i + 8);
574     const minX = Math.min(x1, x2, x3, x4);
575     const maxX = Math.max(x1, x2, x3, x4);
576     const minY = Math.min(y1, y2, y3, y4);
577     const maxY = Math.max(y1, y2, y3, y4);
578     // The quadpoints should be ignored if any coordinate in the array
579     // lies outside the region specified by the rectangle. The rectangle
580     // can be `null` for markup annotations since their rectangle may be
581     // incorrect (fixes bug 1538111).
582     if (
583       rect !== null &&
584       (minX < rect[0] || maxX > rect[2] || minY < rect[1] || maxY > rect[3])
585     ) {
586       return null;
587     }
588     // The PDF specification states in section 12.5.6.10 (figure 64) that the
589     // order of the quadpoints should be bottom left, bottom right, top right
590     // and top left. However, in practice PDF files use a different order,
591     // namely bottom left, bottom right, top left and top right (this is also
592     // mentioned on https://github.com/highkite/pdfAnnotate#QuadPoints), so
593     // this is the actual order we should work with. However, the situation is
594     // even worse since Adobe's own applications and other applications violate
595     // the specification and create annotations with other orders, namely top
596     // left, top right, bottom left and bottom right or even top left,
597     // top right, bottom right and bottom left. To avoid inconsistency and
598     // broken rendering, we normalize all lists to put the quadpoints in the
599     // same standard order (see https://stackoverflow.com/a/10729881).
600     newQuadPoints.set([minX, maxY, maxX, maxY, minX, minY, maxX, minY], i);
601   }
602   return newQuadPoints;
603 }
604 
605 function getTransformMatrix(rect, bbox, matrix) {
606   // 12.5.5: Algorithm: Appearance streams
607   const [minX, minY, maxX, maxY] = Util.getAxialAlignedBoundingBox(
608     bbox,
609     matrix
610   );
611   if (minX === maxX || minY === maxY) {
612     // From real-life file, bbox was [0, 0, 0, 0]. In this case,
613     // just apply the transform for rect
614     return [1, 0, 0, 1, rect[0], rect[1]];
615   }
616 
617   const xRatio = (rect[2] - rect[0]) / (maxX - minX);
618   const yRatio = (rect[3] - rect[1]) / (maxY - minY);
619   return [
620     xRatio,
621     0,
622     0,
623     yRatio,
624     rect[0] - minX * xRatio,
625     rect[1] - minY * yRatio,
626   ];
627 }
628 
629 class Annotation {
630   constructor(params) {
631     const { dict, xref, annotationGlobals, ref, orphanFields } = params;
632     const parentRef = orphanFields?.get(ref);
633     if (parentRef) {
634       dict.set("Parent", parentRef);
635     }
636 
637     this.setTitle(dict.get("T"));
638     this.setContents(dict.get("Contents"));
639     this.setModificationDate(dict.get("M"));
640     this.setFlags(dict.get("F"));
641     this.setRectangle(dict.getArray("Rect"));
642     this.setColor(dict.getArray("C"));
643     this.setBorderStyle(dict);
644     this.setAppearance(dict);
645     this.setOptionalContent(dict);
646 
647     const MK = dict.get("MK");
648     this.setBorderAndBackgroundColors(MK);
649     this.setRotation(MK, dict);
650     this.ref = params.ref instanceof Ref ? params.ref : null;
651 
652     this._streams = [];
653     if (this.appearance) {
654       this._streams.push(this.appearance);
655     }
656 
657     // The annotation cannot be changed (neither its position/visibility nor its
658     // contents), hence we can just display its appearance and don't generate
659     // a HTML element for it.
660     const isLocked = !!(this.flags & AnnotationFlag.LOCKED);
661     const isContentLocked = !!(this.flags & AnnotationFlag.LOCKEDCONTENTS);
662 
663     // Expose public properties using a data object.
664     this.data = {
665       annotationFlags: this.flags,
666       borderStyle: this.borderStyle,
667       color: this.color,
668       backgroundColor: this.backgroundColor,
669       borderColor: this.borderColor,
670       rotation: this.rotation,
671       contentsObj: this._contents,
672       hasAppearance: !!this.appearance,
673       id: params.id,
674       modificationDate: this.modificationDate,
675       rect: this.rectangle,
676       subtype: params.subtype,
677       hasOwnCanvas: false,
678       noRotate: !!(this.flags & AnnotationFlag.NOROTATE),
679       noHTML: isLocked && isContentLocked,
680       isEditable: false,
681       structParent: -1,
682     };
683 
684     if (annotationGlobals.structTreeRoot) {
685       let structParent = dict.get("StructParent");
686       this.data.structParent = structParent =
687         Number.isInteger(structParent) && structParent >= 0 ? structParent : -1;
688 
689       annotationGlobals.structTreeRoot.addAnnotationIdToPage(
690         params.pageRef,
691         structParent
692       );
693     }
694 
695     if (params.collectFields) {
696       // Fields can act as container for other fields and have
697       // some actions even if no Annotation inherit from them.
698       // Those fields can be referenced by CO (calculation order).
699       const kids = dict.get("Kids");
700       if (Array.isArray(kids)) {
701         const kidIds = [];
702         for (const kid of kids) {
703           if (kid instanceof Ref) {
704             kidIds.push(kid.toString());
705           }
706         }
707         if (kidIds.length !== 0) {
708           this.data.kidIds = kidIds;
709         }
710       }
711 
712       this.data.actions = collectActions(xref, dict, AnnotationActionEventType);
713       this.data.fieldName = this._constructFieldName(dict);
714       this.data.pageIndex = params.pageIndex;
715     }
716 
717     const it = dict.get("IT");
718     if (it instanceof Name) {
719       this.data.it = it.name;
720     }
721 
722     this._isOffscreenCanvasSupported =
723       params.evaluatorOptions.isOffscreenCanvasSupported;
724     this._fallbackFontDict = null;
725     this._needAppearances = false;
726   }
727 
728   /**
729    * @private
730    */
731   _hasFlag(flags, flag) {
732     return !!(flags & flag);
733   }
734 
735   _buildFlags(noView, noPrint) {
736     let { flags } = this;
737     if (noView === undefined) {
738       if (noPrint === undefined) {
739         return undefined;
740       }
741       if (noPrint) {
742         return flags & ~AnnotationFlag.PRINT;
743       }
744       return (flags & ~AnnotationFlag.HIDDEN) | AnnotationFlag.PRINT;
745     }
746 
747     if (noView) {
748       flags |= AnnotationFlag.PRINT;
749       if (noPrint) {
750         // display === 1.
751         return (flags & ~AnnotationFlag.NOVIEW) | AnnotationFlag.HIDDEN;
752       }
753       // display === 3.
754       return (flags & ~AnnotationFlag.HIDDEN) | AnnotationFlag.NOVIEW;
755     }
756 
757     flags &= ~(AnnotationFlag.HIDDEN | AnnotationFlag.NOVIEW);
758     if (noPrint) {
759       // display === 2.
760       return flags & ~AnnotationFlag.PRINT;
761     }
762 
763     // display === 0.
764     return flags | AnnotationFlag.PRINT;
765   }
766 
767   /**
768    * @private
769    */
770   _isViewable(flags) {
771     return (
772       !this._hasFlag(flags, AnnotationFlag.INVISIBLE) &&
773       !this._hasFlag(flags, AnnotationFlag.NOVIEW)
774     );
775   }
776 
777   /**
778    * @private
779    */
780   _isPrintable(flags) {
781     // In Acrobat, hidden flag cancels the print one
782     // (see annotation_hidden_print.pdf).
783     return (
784       this._hasFlag(flags, AnnotationFlag.PRINT) &&
785       !this._hasFlag(flags, AnnotationFlag.HIDDEN) &&
786       !this._hasFlag(flags, AnnotationFlag.INVISIBLE)
787     );
788   }
789 
790   /**
791    * Check if the annotation must be displayed by taking into account
792    * the value found in the annotationStorage which may have been set
793    * through JS.
794    *
795    * @public
796    * @memberof Annotation
797    * @param {AnnotationStorage} [annotationStorage] - Storage for annotation
798    * @param {boolean} [_renderForms] - if true widgets are rendered thanks to
799    *                                   the annotation layer.
800    */
801   mustBeViewed(annotationStorage, _renderForms) {
802     const noView = annotationStorage?.get(this.data.id)?.noView;
803     if (noView !== undefined) {
804       return !noView;
805     }
806     return this.viewable && !this._hasFlag(this.flags, AnnotationFlag.HIDDEN);
807   }
808 
809   /**
810    * Check if the annotation must be printed by taking into account
811    * the value found in the annotationStorage which may have been set
812    * through JS.
813    *
814    * @public
815    * @memberof Annotation
816    * @param {AnnotationStorage} [annotationStorage] - Storage for annotation
817    */
818   mustBePrinted(annotationStorage) {
819     const noPrint = annotationStorage?.get(this.data.id)?.noPrint;
820     if (noPrint !== undefined) {
821       return !noPrint;
822     }
823     return this.printable;
824   }
825 
826   mustBeViewedWhenEditing(isEditing, modifiedIds = null) {
827     return isEditing ? !this.data.isEditable : !modifiedIds?.has(this.data.id);
828   }
829 
830   /**
831    * @type {boolean}
832    */
833   get viewable() {
834     if (this.data.quadPoints === null) {
835       return false;
836     }
837     if (this.flags === 0) {
838       return true;
839     }
840     return this._isViewable(this.flags);
841   }
842 
843   /**
844    * @type {boolean}
845    */
846   get printable() {
847     if (this.data.quadPoints === null) {
848       return false;
849     }
850     if (this.flags === 0) {
851       return false;
852     }
853     return this._isPrintable(this.flags);
854   }
855 
856   /**
857    * @private
858    */
859   _parseStringHelper(data) {
860     const str = typeof data === "string" ? stringToPDFString(data) : "";
861     const dir = str && bidi(str).dir === "rtl" ? "rtl" : "ltr";
862 
863     return { str, dir };
864   }
865 
866   setDefaultAppearance(params) {
867     const { dict, annotationGlobals } = params;
868 
869     const defaultAppearance =
870       getInheritableProperty({ dict, key: "DA" }) ||
871       annotationGlobals.acroForm.get("DA");
872     this._defaultAppearance =
873       typeof defaultAppearance === "string" ? defaultAppearance : "";
874     this.data.defaultAppearanceData = parseDefaultAppearance(
875       this._defaultAppearance
876     );
877   }
878 
879   /**
880    * Set the title.
881    *
882    * @param {string} title - The title of the annotation, used e.g. with
883    *   PopupAnnotations.
884    */
885   setTitle(title) {
886     this._title = this._parseStringHelper(title);
887   }
888 
889   /**
890    * Set the contents.
891    *
892    * @param {string} contents - Text to display for the annotation or, if the
893    *                            type of annotation does not display text, a
894    *                            description of the annotation's contents
895    */
896   setContents(contents) {
897     this._contents = this._parseStringHelper(contents);
898   }
899 
900   /**
901    * Set the modification date.
902    *
903    * @public
904    * @memberof Annotation
905    * @param {string} modificationDate - PDF date string that indicates when the
906    *                                    annotation was last modified
907    */
908   setModificationDate(modificationDate) {
909     this.modificationDate =
910       typeof modificationDate === "string" ? modificationDate : null;
911   }
912 
913   /**
914    * Set the flags.
915    *
916    * @public
917    * @memberof Annotation
918    * @param {number} flags - Unsigned 32-bit integer specifying annotation
919    *                         characteristics
920    * @see {@link shared/util.js}
921    */
922   setFlags(flags) {
923     this.flags = Number.isInteger(flags) && flags > 0 ? flags : 0;
924     if (
925       this.flags & AnnotationFlag.INVISIBLE &&
926       this.constructor.name !== "Annotation"
927     ) {
928       // From the pdf spec v1.7, section 12.5.3 (Annotation Flags):
929       //   If set, do not display the annotation if it does not belong to one of
930       //   the standard annotation types and no annotation handler is available.
931       //
932       // So we can remove the flag in case we have a known annotation type.
933       this.flags ^= AnnotationFlag.INVISIBLE;
934     }
935   }
936 
937   /**
938    * Check if a provided flag is set.
939    *
940    * @public
941    * @memberof Annotation
942    * @param {number} flag - Hexadecimal representation for an annotation
943    *                        characteristic
944    * @returns {boolean}
945    * @see {@link shared/util.js}
946    */
947   hasFlag(flag) {
948     return this._hasFlag(this.flags, flag);
949   }
950 
951   /**
952    * Set the rectangle.
953    *
954    * @public
955    * @memberof Annotation
956    * @param {Array} rectangle - The rectangle array with exactly four entries
957    */
958   setRectangle(rectangle) {
959     this.rectangle = lookupNormalRect(rectangle, [0, 0, 0, 0]);
960   }
961 
962   /**
963    * Set the color and take care of color space conversion.
964    * The default value is black, in RGB color space.
965    *
966    * @public
967    * @memberof Annotation
968    * @param {Array} color - The color array containing either 0
969    *                        (transparent), 1 (grayscale), 3 (RGB) or
970    *                        4 (CMYK) elements
971    */
972   setColor(color) {
973     this.color = getRgbColor(color);
974   }
975 
976   /**
977    * Set the line endings; should only be used with specific annotation types.
978    * @param {Array} lineEndings - The line endings array.
979    */
980   setLineEndings(lineEndings) {
981     if (typeof PDFJSDev !== "undefined" && PDFJSDev.test("MOZCENTRAL")) {
982       throw new Error("Not implemented: setLineEndings");
983     }
984     this.lineEndings = ["None", "None"]; // The default values.
985 
986     if (Array.isArray(lineEndings) && lineEndings.length === 2) {
987       for (let i = 0; i < 2; i++) {
988         const obj = lineEndings[i];
989 
990         if (obj instanceof Name) {
991           switch (obj.name) {
992             case "None":
993               continue;
994             case "Square":
995             case "Circle":
996             case "Diamond":
997             case "OpenArrow":
998             case "ClosedArrow":
999             case "Butt":
1000             case "ROpenArrow":
1001             case "RClosedArrow":
1002             case "Slash":
1003               this.lineEndings[i] = obj.name;
1004               continue;
1005           }
1006         }
1007         warn(`Ignoring invalid lineEnding: ${obj}`);
1008       }
1009     }
1010   }
1011 
1012   setRotation(mk, dict) {
1013     this.rotation = 0;
1014     let angle = mk instanceof Dict ? mk.get("R") || 0 : dict.get("Rotate") || 0;
1015     if (Number.isInteger(angle) && angle !== 0) {
1016       angle %= 360;
1017       if (angle < 0) {
1018         angle += 360;
1019       }
1020       if (angle % 90 === 0) {
1021         this.rotation = angle;
1022       }
1023     }
1024   }
1025 
1026   /**
1027    * Set the color for background and border if any.
1028    * The default values are transparent.
1029    *
1030    * @public
1031    * @memberof Annotation
1032    * @param {Dict} mk - The MK dictionary
1033    */
1034   setBorderAndBackgroundColors(mk) {
1035     if (mk instanceof Dict) {
1036       this.borderColor = getRgbColor(mk.getArray("BC"), null);
1037       this.backgroundColor = getRgbColor(mk.getArray("BG"), null);
1038     } else {
1039       this.borderColor = this.backgroundColor = null;
1040     }
1041   }
1042 
1043   /**
1044    * Set the border style (as AnnotationBorderStyle object).
1045    *
1046    * @public
1047    * @memberof Annotation
1048    * @param {Dict} borderStyle - The border style dictionary
1049    */
1050   setBorderStyle(borderStyle) {
1051     if (typeof PDFJSDev === "undefined" || PDFJSDev.test("TESTING")) {
1052       assert(this.rectangle, "setRectangle must have been called previously.");
1053     }
1054 
1055     this.borderStyle = new AnnotationBorderStyle();
1056     if (!(borderStyle instanceof Dict)) {
1057       return;
1058     }
1059     if (borderStyle.has("BS")) {
1060       const dict = borderStyle.get("BS");
1061 
1062       if (dict instanceof Dict) {
1063         const dictType = dict.get("Type");
1064 
1065         if (!dictType || isName(dictType, "Border")) {
1066           this.borderStyle.setWidth(dict.get("W"), this.rectangle);
1067           this.borderStyle.setStyle(dict.get("S"));
1068           this.borderStyle.setDashArray(dict.getArray("D"));
1069         }
1070       }
1071     } else if (borderStyle.has("Border")) {
1072       const array = borderStyle.getArray("Border");
1073       if (Array.isArray(array) && array.length >= 3) {
1074         this.borderStyle.setHorizontalCornerRadius(array[0]);
1075         this.borderStyle.setVerticalCornerRadius(array[1]);
1076         this.borderStyle.setWidth(array[2], this.rectangle);
1077 
1078         if (array.length === 4) {
1079           // Dash array available
1080           this.borderStyle.setDashArray(array[3], /* forceStyle = */ true);
1081         }
1082       }
1083     } else {
1084       // There are no border entries in the dictionary. According to the
1085       // specification, we should draw a solid border of width 1 in that
1086       // case, but Adobe Reader did not implement that part of the
1087       // specification and instead draws no border at all, so we do the same.
1088       // See also https://github.com/mozilla/pdf.js/issues/6179.
1089       this.borderStyle.setWidth(0);
1090     }
1091   }
1092 
1093   /**
1094    * Set the (normal) appearance.
1095    *
1096    * @public
1097    * @memberof Annotation
1098    * @param {Dict} dict - The annotation's data dictionary
1099    */
1100   setAppearance(dict) {
1101     this.appearance = null;
1102 
1103     const appearanceStates = dict.get("AP");
1104     if (!(appearanceStates instanceof Dict)) {
1105       return;
1106     }
1107 
1108     // In case the normal appearance is a stream, then it is used directly.
1109     const normalAppearanceState = appearanceStates.get("N");
1110     if (normalAppearanceState instanceof BaseStream) {
1111       this.appearance = normalAppearanceState;
1112       return;
1113     }
1114     if (!(normalAppearanceState instanceof Dict)) {
1115       return;
1116     }
1117 
1118     // In case the normal appearance is a dictionary, the `AS` entry provides
1119     // the key of the stream in this dictionary.
1120     const as = dict.get("AS");
1121     if (!(as instanceof Name) || !normalAppearanceState.has(as.name)) {
1122       return;
1123     }
1124     const appearance = normalAppearanceState.get(as.name);
1125     if (appearance instanceof BaseStream) {
1126       this.appearance = appearance;
1127     }
1128   }
1129 
1130   setOptionalContent(dict) {
1131     this.oc = null;
1132 
1133     const oc = dict.get("OC");
1134     if (oc instanceof Name) {
1135       warn("setOptionalContent: Support for /Name-entry is not implemented.");
1136     } else if (oc instanceof Dict) {
1137       this.oc = oc;
1138     }
1139   }
1140 
1141   loadResources(keys, appearance) {
1142     return appearance.dict.getAsync("Resources").then(resources => {
1143       if (!resources) {
1144         return undefined;
1145       }
1146 
1147       const objectLoader = new ObjectLoader(resources, keys, resources.xref);
1148       return objectLoader.load().then(function () {
1149         return resources;
1150       });
1151     });
1152   }
1153 
1154   async getOperatorList(evaluator, task, intent, annotationStorage) {
1155     const { hasOwnCanvas, id, rect } = this.data;
1156     let appearance = this.appearance;
1157     const isUsingOwnCanvas = !!(
1158       hasOwnCanvas && intent & RenderingIntentFlag.DISPLAY
1159     );
1160     if (isUsingOwnCanvas && (rect[0] === rect[2] || rect[1] === rect[3])) {
1161       // Empty annotation, don't draw anything.
1162       this.data.hasOwnCanvas = false;
1163       return {
1164         opList: new OperatorList(),
1165         separateForm: false,
1166         separateCanvas: false,
1167       };
1168     }
1169     if (!appearance) {
1170       if (!isUsingOwnCanvas) {
1171         return {
1172           opList: new OperatorList(),
1173           separateForm: false,
1174           separateCanvas: false,
1175         };
1176       }
1177       appearance = new StringStream("");
1178       appearance.dict = new Dict();
1179     }
1180 
1181     const appearanceDict = appearance.dict;
1182     const resources = await this.loadResources(
1183       ["ExtGState", "ColorSpace", "Pattern", "Shading", "XObject", "Font"],
1184       appearance
1185     );
1186     const bbox = lookupRect(appearanceDict.getArray("BBox"), [0, 0, 1, 1]);
1187     const matrix = lookupMatrix(
1188       appearanceDict.getArray("Matrix"),
1189       IDENTITY_MATRIX
1190     );
1191     const transform = getTransformMatrix(rect, bbox, matrix);
1192 
1193     const opList = new OperatorList();
1194 
1195     let optionalContent;
1196     if (this.oc) {
1197       optionalContent = await evaluator.parseMarkedContentProps(
1198         this.oc,
1199         /* resources = */ null
1200       );
1201     }
1202     if (optionalContent !== undefined) {
1203       opList.addOp(OPS.beginMarkedContentProps, ["OC", optionalContent]);
1204     }
1205 
1206     opList.addOp(OPS.beginAnnotation, [
1207       id,
1208       rect,
1209       transform,
1210       matrix,
1211       isUsingOwnCanvas,
1212     ]);
1213 
1214     await evaluator.getOperatorList({
1215       stream: appearance,
1216       task,
1217       resources,
1218       operatorList: opList,
1219       fallbackFontDict: this._fallbackFontDict,
1220     });
1221     opList.addOp(OPS.endAnnotation, []);
1222 
1223     if (optionalContent !== undefined) {
1224       opList.addOp(OPS.endMarkedContent, []);
1225     }
1226     this.reset();
1227     return { opList, separateForm: false, separateCanvas: isUsingOwnCanvas };
1228   }
1229 
1230   async save(evaluator, task, annotationStorage) {
1231     return null;
1232   }
1233 
1234   get hasTextContent() {
1235     return false;
1236   }
1237 
1238   async extractTextContent(evaluator, task, viewBox) {
1239     if (!this.appearance) {
1240       return;
1241     }
1242 
1243     const resources = await this.loadResources(
1244       ["ExtGState", "Font", "Properties", "XObject"],
1245       this.appearance
1246     );
1247 
1248     const text = [];
1249     const buffer = [];
1250     let firstPosition = null;
1251     const sink = {
1252       desiredSize: Math.Infinity,
1253       ready: true,
1254 
1255       enqueue(chunk, size) {
1256         for (const item of chunk.items) {
1257           if (item.str === undefined) {
1258             continue;
1259           }
1260           firstPosition ||= item.transform.slice(-2);
1261           buffer.push(item.str);
1262           if (item.hasEOL) {
1263             text.push(buffer.join("").trimEnd());
1264             buffer.length = 0;
1265           }
1266         }
1267       },
1268     };
1269 
1270     await evaluator.getTextContent({
1271       stream: this.appearance,
1272       task,
1273       resources,
1274       includeMarkedContent: true,
1275       keepWhiteSpace: true,
1276       sink,
1277       viewBox,
1278     });
1279     this.reset();
1280 
1281     if (buffer.length) {
1282       text.push(buffer.join("").trimEnd());
1283     }
1284 
1285     if (text.length > 1 || text[0]) {
1286       const appearanceDict = this.appearance.dict;
1287       const bbox = lookupRect(appearanceDict.getArray("BBox"), null);
1288       const matrix = lookupMatrix(appearanceDict.getArray("Matrix"), null);
1289 
1290       this.data.textPosition = this._transformPoint(
1291         firstPosition,
1292         bbox,
1293         matrix
1294       );
1295       this.data.textContent = text;
1296     }
1297   }
1298 
1299   _transformPoint(coords, bbox, matrix) {
1300     const { rect } = this.data;
1301     bbox ||= [0, 0, 1, 1];
1302     matrix ||= [1, 0, 0, 1, 0, 0];
1303     const transform = getTransformMatrix(rect, bbox, matrix);
1304     transform[4] -= rect[0];
1305     transform[5] -= rect[1];
1306     coords = Util.applyTransform(coords, transform);
1307     return Util.applyTransform(coords, matrix);
1308   }
1309 
1310   /**
1311    * Get field data for usage in JS sandbox.
1312    *
1313    * Field object is defined here:
1314    * https://www.adobe.com/content/dam/acom/en/devnet/acrobat/pdfs/js_api_reference.pdf#page=16
1315    *
1316    * @public
1317    * @memberof Annotation
1318    * @returns {Object | null}
1319    */
1320   getFieldObject() {
1321     if (this.data.kidIds) {
1322       return {
1323         id: this.data.id,
1324         actions: this.data.actions,
1325         name: this.data.fieldName,
1326         strokeColor: this.data.borderColor,
1327         fillColor: this.data.backgroundColor,
1328         type: "",
1329         kidIds: this.data.kidIds,
1330         page: this.data.pageIndex,
1331         rotation: this.rotation,
1332       };
1333     }
1334     return null;
1335   }
1336 
1337   /**
1338    * Reset the annotation.
1339    *
1340    * This involves resetting the various streams that are either cached on the
1341    * annotation instance or created during its construction.
1342    *
1343    * @public
1344    * @memberof Annotation
1345    */
1346   reset() {
1347     if (
1348       (typeof PDFJSDev === "undefined" || PDFJSDev.test("TESTING")) &&
1349       this.appearance &&
1350       !this._streams.includes(this.appearance)
1351     ) {
1352       unreachable("The appearance stream should always be reset.");
1353     }
1354 
1355     for (const stream of this._streams) {
1356       stream.reset();
1357     }
1358   }
1359 
1360   /**
1361    * Construct the (fully qualified) field name from the (partial) field
1362    * names of the field and its ancestors.
1363    *
1364    * @private
1365    * @memberof Annotation
1366    * @param {Dict} dict - Complete widget annotation dictionary
1367    * @returns {string}
1368    */
1369   _constructFieldName(dict) {
1370     // Both the `Parent` and `T` fields are optional. While at least one of
1371     // them should be provided, bad PDF generators may fail to do so.
1372     if (!dict.has("T") && !dict.has("Parent")) {
1373       warn("Unknown field name, falling back to empty field name.");
1374       return "";
1375     }
1376 
1377     // If no parent exists, the partial and fully qualified names are equal.
1378     if (!dict.has("Parent")) {
1379       return stringToPDFString(dict.get("T"));
1380     }
1381 
1382     // Form the fully qualified field name by appending the partial name to
1383     // the parent's fully qualified name, separated by a period.
1384     const fieldName = [];
1385     if (dict.has("T")) {
1386       fieldName.unshift(stringToPDFString(dict.get("T")));
1387     }
1388 
1389     let loopDict = dict;
1390     const visited = new RefSet();
1391     if (dict.objId) {
1392       visited.put(dict.objId);
1393     }
1394     while (loopDict.has("Parent")) {
1395       loopDict = loopDict.get("Parent");
1396       if (
1397         !(loopDict instanceof Dict) ||
1398         (loopDict.objId && visited.has(loopDict.objId))
1399       ) {
1400         // Even though it is not allowed according to the PDF specification,
1401         // bad PDF generators may provide a `Parent` entry that is not a
1402         // dictionary, but `null` for example (issue 8143).
1403         //
1404         // If parent has been already visited, it means that we're
1405         // in an infinite loop.
1406         break;
1407       }
1408       if (loopDict.objId) {
1409         visited.put(loopDict.objId);
1410       }
1411 
1412       if (loopDict.has("T")) {
1413         fieldName.unshift(stringToPDFString(loopDict.get("T")));
1414       }
1415     }
1416     return fieldName.join(".");
1417   }
1418 }
1419 
1420 /**
1421  * Contains all data regarding an annotation's border style.
1422  */
1423 class AnnotationBorderStyle {
1424   constructor() {
1425     this.width = 1;
1426     this.rawWidth = 1;
1427     this.style = AnnotationBorderStyleType.SOLID;
1428     this.dashArray = [3];
1429     this.horizontalCornerRadius = 0;
1430     this.verticalCornerRadius = 0;
1431   }
1432 
1433   /**
1434    * Set the width.
1435    *
1436    * @public
1437    * @memberof AnnotationBorderStyle
1438    * @param {number} width - The width.
1439    * @param {Array} rect - The annotation `Rect` entry.
1440    */
1441   setWidth(width, rect = [0, 0, 0, 0]) {
1442     if (typeof PDFJSDev === "undefined" || PDFJSDev.test("TESTING")) {
1443       assert(
1444         isNumberArray(rect, 4),
1445         "A valid `rect` parameter must be provided."
1446       );
1447     }
1448 
1449     // Some corrupt PDF generators may provide the width as a `Name`,
1450     // rather than as a number (fixes issue 10385).
1451     if (width instanceof Name) {
1452       this.width = 0; // This is consistent with the behaviour in Adobe Reader.
1453       return;
1454     }
1455     if (typeof width === "number") {
1456       if (width > 0) {
1457         this.rawWidth = width;
1458         const maxWidth = (rect[2] - rect[0]) / 2;
1459         const maxHeight = (rect[3] - rect[1]) / 2;
1460 
1461         // Ignore large `width`s, since they lead to the Annotation overflowing
1462         // the size set by the `Rect` entry thus causing the `annotationLayer`
1463         // to render it over the surrounding document (fixes bug1552113.pdf).
1464         if (
1465           maxWidth > 0 &&
1466           maxHeight > 0 &&
1467           (width > maxWidth || width > maxHeight)
1468         ) {
1469           warn(`AnnotationBorderStyle.setWidth - ignoring width: ${width}`);
1470           width = 1;
1471         }
1472       }
1473       this.width = width;
1474     }
1475   }
1476 
1477   /**
1478    * Set the style.
1479    *
1480    * @public
1481    * @memberof AnnotationBorderStyle
1482    * @param {Name} style - The annotation style.
1483    * @see {@link shared/util.js}
1484    */
1485   setStyle(style) {
1486     if (!(style instanceof Name)) {
1487       return;
1488     }
1489     switch (style.name) {
1490       case "S":
1491         this.style = AnnotationBorderStyleType.SOLID;
1492         break;
1493 
1494       case "D":
1495         this.style = AnnotationBorderStyleType.DASHED;
1496         break;
1497 
1498       case "B":
1499         this.style = AnnotationBorderStyleType.BEVELED;
1500         break;
1501 
1502       case "I":
1503         this.style = AnnotationBorderStyleType.INSET;
1504         break;
1505 
1506       case "U":
1507         this.style = AnnotationBorderStyleType.UNDERLINE;
1508         break;
1509 
1510       default:
1511         break;
1512     }
1513   }
1514 
1515   /**
1516    * Set the dash array.
1517    *
1518    * @public
1519    * @memberof AnnotationBorderStyle
1520    * @param {Array} dashArray - The dash array with at least one element
1521    * @param {boolean} [forceStyle]
1522    */
1523   setDashArray(dashArray, forceStyle = false) {
1524     // We validate the dash array, but we do not use it because CSS does not
1525     // allow us to change spacing of dashes. For more information, visit
1526     // http://www.w3.org/TR/css3-background/#the-border-style.
1527     if (Array.isArray(dashArray)) {
1528       // The PDF specification states that elements in the dash array, if
1529       // present, must be non-negative numbers and must not all equal zero.
1530       let isValid = true;
1531       let allZeros = true;
1532       for (const element of dashArray) {
1533         const validNumber = +element >= 0;
1534         if (!validNumber) {
1535           isValid = false;
1536           break;
1537         } else if (element > 0) {
1538           allZeros = false;
1539         }
1540       }
1541       if (dashArray.length === 0 || (isValid && !allZeros)) {
1542         this.dashArray = dashArray;
1543 
1544         if (forceStyle) {
1545           // Even though we cannot use the dash array in the display layer,
1546           // at least ensure that we use the correct border-style.
1547           this.setStyle(Name.get("D"));
1548         }
1549       } else {
1550         this.width = 0; // Adobe behavior when the array is invalid.
1551       }
1552     } else if (dashArray) {
1553       this.width = 0; // Adobe behavior when the array is invalid.
1554     }
1555   }
1556 
1557   /**
1558    * Set the horizontal corner radius (from a Border dictionary).
1559    *
1560    * @public
1561    * @memberof AnnotationBorderStyle
1562    * @param {number} radius - The horizontal corner radius.
1563    */
1564   setHorizontalCornerRadius(radius) {
1565     if (Number.isInteger(radius)) {
1566       this.horizontalCornerRadius = radius;
1567     }
1568   }
1569 
1570   /**
1571    * Set the vertical corner radius (from a Border dictionary).
1572    *
1573    * @public
1574    * @memberof AnnotationBorderStyle
1575    * @param {number} radius - The vertical corner radius.
1576    */
1577   setVerticalCornerRadius(radius) {
1578     if (Number.isInteger(radius)) {
1579       this.verticalCornerRadius = radius;
1580     }
1581   }
1582 }
1583 
1584 class MarkupAnnotation extends Annotation {
1585   constructor(params) {
1586     super(params);
1587 
1588     const { dict } = params;
1589 
1590     if (dict.has("IRT")) {
1591       const rawIRT = dict.getRaw("IRT");
1592       this.data.inReplyTo = rawIRT instanceof Ref ? rawIRT.toString() : null;
1593 
1594       const rt = dict.get("RT");
1595       this.data.replyType =
1596         rt instanceof Name ? rt.name : AnnotationReplyType.REPLY;
1597     }
1598     let popupRef = null;
1599 
1600     if (this.data.replyType === AnnotationReplyType.GROUP) {
1601       // Subordinate annotations in a group should inherit
1602       // the group attributes from the primary annotation.
1603       const parent = dict.get("IRT");
1604 
1605       this.setTitle(parent.get("T"));
1606       this.data.titleObj = this._title;
1607 
1608       this.setContents(parent.get("Contents"));
1609       this.data.contentsObj = this._contents;
1610 
1611       if (!parent.has("CreationDate")) {
1612         this.data.creationDate = null;
1613       } else {
1614         this.setCreationDate(parent.get("CreationDate"));
1615         this.data.creationDate = this.creationDate;
1616       }
1617 
1618       if (!parent.has("M")) {
1619         this.data.modificationDate = null;
1620       } else {
1621         this.setModificationDate(parent.get("M"));
1622         this.data.modificationDate = this.modificationDate;
1623       }
1624 
1625       popupRef = parent.getRaw("Popup");
1626 
1627       if (!parent.has("C")) {
1628         // Fall back to the default background color.
1629         this.data.color = null;
1630       } else {
1631         this.setColor(parent.getArray("C"));
1632         this.data.color = this.color;
1633       }
1634     } else {
1635       this.data.titleObj = this._title;
1636 
1637       this.setCreationDate(dict.get("CreationDate"));
1638       this.data.creationDate = this.creationDate;
1639 
1640       popupRef = dict.getRaw("Popup");
1641 
1642       if (!dict.has("C")) {
1643         // Fall back to the default background color.
1644         this.data.color = null;
1645       }
1646     }
1647 
1648     this.data.popupRef = popupRef instanceof Ref ? popupRef.toString() : null;
1649 
1650     if (dict.has("RC")) {
1651       this.data.richText = XFAFactory.getRichTextAsHtml(dict.get("RC"));
1652     }
1653   }
1654 
1655   /**
1656    * Set the creation date.
1657    *
1658    * @public
1659    * @memberof MarkupAnnotation
1660    * @param {string} creationDate - PDF date string that indicates when the
1661    *                                annotation was originally created
1662    */
1663   setCreationDate(creationDate) {
1664     this.creationDate = typeof creationDate === "string" ? creationDate : null;
1665   }
1666 
1667   _setDefaultAppearance({
1668     xref,
1669     extra,
1670     strokeColor,
1671     fillColor,
1672     blendMode,
1673     strokeAlpha,
1674     fillAlpha,
1675     pointsCallback,
1676   }) {
1677     let minX = Number.MAX_VALUE;
1678     let minY = Number.MAX_VALUE;
1679     let maxX = Number.MIN_VALUE;
1680     let maxY = Number.MIN_VALUE;
1681 
1682     const buffer = ["q"];
1683     if (extra) {
1684       buffer.push(extra);
1685     }
1686     if (strokeColor) {
1687       buffer.push(`${strokeColor[0]} ${strokeColor[1]} ${strokeColor[2]} RG`);
1688     }
1689     if (fillColor) {
1690       buffer.push(`${fillColor[0]} ${fillColor[1]} ${fillColor[2]} rg`);
1691     }
1692 
1693     let pointsArray = this.data.quadPoints;
1694     if (!pointsArray) {
1695       // If there are no quadpoints, the rectangle should be used instead.
1696       // Convert the rectangle definition to a points array similar to how the
1697       // quadpoints are defined.
1698       pointsArray = Float32Array.from([
1699         this.rectangle[0],
1700         this.rectangle[3],
1701         this.rectangle[2],
1702         this.rectangle[3],
1703         this.rectangle[0],
1704         this.rectangle[1],
1705         this.rectangle[2],
1706         this.rectangle[1],
1707       ]);
1708     }
1709 
1710     for (let i = 0, ii = pointsArray.length; i < ii; i += 8) {
1711       const [mX, MX, mY, MY] = pointsCallback(
1712         buffer,
1713         pointsArray.subarray(i, i + 8)
1714       );
1715       minX = Math.min(minX, mX);
1716       maxX = Math.max(maxX, MX);
1717       minY = Math.min(minY, mY);
1718       maxY = Math.max(maxY, MY);
1719     }
1720     buffer.push("Q");
1721 
1722     const formDict = new Dict(xref);
1723     const appearanceStreamDict = new Dict(xref);
1724     appearanceStreamDict.set("Subtype", Name.get("Form"));
1725 
1726     const appearanceStream = new StringStream(buffer.join(" "));
1727     appearanceStream.dict = appearanceStreamDict;
1728     formDict.set("Fm0", appearanceStream);
1729 
1730     const gsDict = new Dict(xref);
1731     if (blendMode) {
1732       gsDict.set("BM", Name.get(blendMode));
1733     }
1734     if (typeof strokeAlpha === "number") {
1735       gsDict.set("CA", strokeAlpha);
1736     }
1737     if (typeof fillAlpha === "number") {
1738       gsDict.set("ca", fillAlpha);
1739     }
1740 
1741     const stateDict = new Dict(xref);
1742     stateDict.set("GS0", gsDict);
1743 
1744     const resources = new Dict(xref);
1745     resources.set("ExtGState", stateDict);
1746     resources.set("XObject", formDict);
1747 
1748     const appearanceDict = new Dict(xref);
1749     appearanceDict.set("Resources", resources);
1750     const bbox = (this.data.rect = [minX, minY, maxX, maxY]);
1751     appearanceDict.set("BBox", bbox);
1752 
1753     this.appearance = new StringStream("/GS0 gs /Fm0 Do");
1754     this.appearance.dict = appearanceDict;
1755 
1756     // This method is only called if there is no appearance for the annotation,
1757     // so `this.appearance` is not pushed yet in the `Annotation` constructor.
1758     this._streams.push(this.appearance, appearanceStream);
1759   }
1760 
1761   static async createNewAnnotation(xref, annotation, dependencies, params) {
1762     if (!annotation.ref) {
1763       annotation.ref = xref.getNewTemporaryRef();
1764     }
1765 
1766     const annotationRef = annotation.ref;
1767     const ap = await this.createNewAppearanceStream(annotation, xref, params);
1768     const buffer = [];
1769     let annotationDict;
1770 
1771     if (ap) {
1772       const apRef = xref.getNewTemporaryRef();
1773       annotationDict = this.createNewDict(annotation, xref, {
1774         apRef,
1775       });
1776       await writeObject(apRef, ap, buffer, xref);
1777       dependencies.push({ ref: apRef, data: buffer.join("") });
1778     } else {
1779       annotationDict = this.createNewDict(annotation, xref, {});
1780     }
1781     if (Number.isInteger(annotation.parentTreeId)) {
1782       annotationDict.set("StructParent", annotation.parentTreeId);
1783     }
1784 
1785     buffer.length = 0;
1786     await writeObject(annotationRef, annotationDict, buffer, xref);
1787 
1788     return { ref: annotationRef, data: buffer.join("") };
1789   }
1790 
1791   static async createNewPrintAnnotation(
1792     annotationGlobals,
1793     xref,
1794     annotation,
1795     params
1796   ) {
1797     const ap = await this.createNewAppearanceStream(annotation, xref, params);
1798     const annotationDict = this.createNewDict(
1799       annotation,
1800       xref,
1801       ap ? { ap } : {}
1802     );
1803 
1804     const newAnnotation = new this.prototype.constructor({
1805       dict: annotationDict,
1806       xref,
1807       annotationGlobals,
1808       evaluatorOptions: params.evaluatorOptions,
1809     });
1810 
1811     if (annotation.ref) {
1812       newAnnotation.ref = newAnnotation.refToReplace = annotation.ref;
1813     }
1814 
1815     return newAnnotation;
1816   }
1817 }
1818 
1819 class WidgetAnnotation extends Annotation {
1820   constructor(params) {
1821     super(params);
1822 
1823     const { dict, xref, annotationGlobals } = params;
1824     const data = this.data;
1825     this._needAppearances = params.needAppearances;
1826 
1827     data.annotationType = AnnotationType.WIDGET;
1828     if (data.fieldName === undefined) {
1829       data.fieldName = this._constructFieldName(dict);
1830     }
1831 
1832     if (data.actions === undefined) {
1833       data.actions = collectActions(xref, dict, AnnotationActionEventType);
1834     }
1835 
1836     let fieldValue = getInheritableProperty({
1837       dict,
1838       key: "V",
1839       getArray: true,
1840     });
1841     data.fieldValue = this._decodeFormValue(fieldValue);
1842 
1843     const defaultFieldValue = getInheritableProperty({
1844       dict,
1845       key: "DV",
1846       getArray: true,
1847     });
1848     data.defaultFieldValue = this._decodeFormValue(defaultFieldValue);
1849 
1850     if (fieldValue === undefined && annotationGlobals.xfaDatasets) {
1851       // Try to figure out if we have something in the xfa dataset.
1852       const path = this._title.str;
1853       if (path) {
1854         this._hasValueFromXFA = true;
1855         data.fieldValue = fieldValue =
1856           annotationGlobals.xfaDatasets.getValue(path);
1857       }
1858     }
1859 
1860     // When no "V" entry exists, let the fieldValue fallback to the "DV" entry
1861     // (fixes issue13823.pdf).
1862     if (fieldValue === undefined && data.defaultFieldValue !== null) {
1863       data.fieldValue = data.defaultFieldValue;
1864     }
1865 
1866     data.alternativeText = stringToPDFString(dict.get("TU") || "");
1867 
1868     this.setDefaultAppearance(params);
1869 
1870     data.hasAppearance ||=
1871       this._needAppearances &&
1872       data.fieldValue !== undefined &&
1873       data.fieldValue !== null;
1874 
1875     const fieldType = getInheritableProperty({ dict, key: "FT" });
1876     data.fieldType = fieldType instanceof Name ? fieldType.name : null;
1877 
1878     const localResources = getInheritableProperty({ dict, key: "DR" });
1879     const acroFormResources = annotationGlobals.acroForm.get("DR");
1880     const appearanceResources = this.appearance?.dict.get("Resources");
1881 
1882     this._fieldResources = {
1883       localResources,
1884       acroFormResources,
1885       appearanceResources,
1886       mergedResources: Dict.merge({
1887         xref,
1888         dictArray: [localResources, appearanceResources, acroFormResources],
1889         mergeSubDicts: true,
1890       }),
1891     };
1892 
1893     data.fieldFlags = getInheritableProperty({ dict, key: "Ff" });
1894     if (!Number.isInteger(data.fieldFlags) || data.fieldFlags < 0) {
1895       data.fieldFlags = 0;
1896     }
1897 
1898     data.readOnly = this.hasFieldFlag(AnnotationFieldFlag.READONLY);
1899     data.required = this.hasFieldFlag(AnnotationFieldFlag.REQUIRED);
1900     data.hidden =
1901       this._hasFlag(data.annotationFlags, AnnotationFlag.HIDDEN) ||
1902       this._hasFlag(data.annotationFlags, AnnotationFlag.NOVIEW);
1903   }
1904 
1905   /**
1906    * Decode the given form value.
1907    *
1908    * @private
1909    * @memberof WidgetAnnotation
1910    * @param {Array<string>|Name|string} formValue - The (possibly encoded)
1911    *   form value.
1912    * @returns {Array<string>|string|null}
1913    */
1914   _decodeFormValue(formValue) {
1915     if (Array.isArray(formValue)) {
1916       return formValue
1917         .filter(item => typeof item === "string")
1918         .map(item => stringToPDFString(item));
1919     } else if (formValue instanceof Name) {
1920       return stringToPDFString(formValue.name);
1921     } else if (typeof formValue === "string") {
1922       return stringToPDFString(formValue);
1923     }
1924     return null;
1925   }
1926 
1927   /**
1928    * Check if a provided field flag is set.
1929    *
1930    * @public
1931    * @memberof WidgetAnnotation
1932    * @param {number} flag - Hexadecimal representation for an annotation
1933    *                        field characteristic
1934    * @returns {boolean}
1935    * @see {@link shared/util.js}
1936    */
1937   hasFieldFlag(flag) {
1938     return !!(this.data.fieldFlags & flag);
1939   }
1940 
1941   /** @inheritdoc */
1942   _isViewable(flags) {
1943     // We don't take into account the `NOVIEW` or `HIDDEN` flags here,
1944     // since the visibility can be changed by js code, hence in case
1945     // it's made viewable, we should render it (with visibility set to
1946     // hidden).
1947     // We don't take into account the `INVISIBLE` flag here, since we've a known
1948     // annotation type.
1949     return true;
1950   }
1951 
1952   /** @inheritdoc */
1953   mustBeViewed(annotationStorage, renderForms) {
1954     if (renderForms) {
1955       return this.viewable;
1956     }
1957     return (
1958       super.mustBeViewed(annotationStorage, renderForms) &&
1959       !this._hasFlag(this.flags, AnnotationFlag.NOVIEW)
1960     );
1961   }
1962 
1963   getRotationMatrix(annotationStorage) {
1964     let rotation = annotationStorage?.get(this.data.id)?.rotation;
1965     if (rotation === undefined) {
1966       rotation = this.rotation;
1967     }
1968 
1969     if (rotation === 0) {
1970       return IDENTITY_MATRIX;
1971     }
1972 
1973     const width = this.data.rect[2] - this.data.rect[0];
1974     const height = this.data.rect[3] - this.data.rect[1];
1975 
1976     return getRotationMatrix(rotation, width, height);
1977   }
1978 
1979   getBorderAndBackgroundAppearances(annotationStorage) {
1980     let rotation = annotationStorage?.get(this.data.id)?.rotation;
1981     if (rotation === undefined) {
1982       rotation = this.rotation;
1983     }
1984 
1985     if (!this.backgroundColor && !this.borderColor) {
1986       return "";
1987     }
1988     const width = this.data.rect[2] - this.data.rect[0];
1989     const height = this.data.rect[3] - this.data.rect[1];
1990     const rect =
1991       rotation === 0 || rotation === 180
1992         ? `0 0 ${width} ${height} re`
1993         : `0 0 ${height} ${width} re`;
1994 
1995     let str = "";
1996     if (this.backgroundColor) {
1997       str = `${getPdfColor(
1998         this.backgroundColor,
1999         /* isFill */ true
2000       )} ${rect} f `;
2001     }
2002 
2003     if (this.borderColor) {
2004       const borderWidth = this.borderStyle.width || 1;
2005       str += `${borderWidth} w ${getPdfColor(
2006         this.borderColor,
2007         /* isFill */ false
2008       )} ${rect} S `;
2009     }
2010 
2011     return str;
2012   }
2013 
2014   async getOperatorList(evaluator, task, intent, annotationStorage) {
2015     // Do not render form elements on the canvas when interactive forms are
2016     // enabled. The display layer is responsible for rendering them instead.
2017     if (
2018       intent & RenderingIntentFlag.ANNOTATIONS_FORMS &&
2019       !(this instanceof SignatureWidgetAnnotation) &&
2020       !this.data.noHTML &&
2021       !this.data.hasOwnCanvas
2022     ) {
2023       return {
2024         opList: new OperatorList(),
2025         separateForm: true,
2026         separateCanvas: false,
2027       };
2028     }
2029 
2030     if (!this._hasText) {
2031       return super.getOperatorList(evaluator, task, intent, annotationStorage);
2032     }
2033 
2034     const content = await this._getAppearance(
2035       evaluator,
2036       task,
2037       intent,
2038       annotationStorage
2039     );
2040     if (this.appearance && content === null) {
2041       return super.getOperatorList(evaluator, task, intent, annotationStorage);
2042     }
2043 
2044     const opList = new OperatorList();
2045 
2046     // Even if there is an appearance stream, ignore it. This is the
2047     // behaviour used by Adobe Reader.
2048     if (!this._defaultAppearance || content === null) {
2049       return { opList, separateForm: false, separateCanvas: false };
2050     }
2051 
2052     const isUsingOwnCanvas = !!(
2053       this.data.hasOwnCanvas && intent & RenderingIntentFlag.DISPLAY
2054     );
2055 
2056     const matrix = [1, 0, 0, 1, 0, 0];
2057     const bbox = [
2058       0,
2059       0,
2060       this.data.rect[2] - this.data.rect[0],
2061       this.data.rect[3] - this.data.rect[1],
2062     ];
2063     const transform = getTransformMatrix(this.data.rect, bbox, matrix);
2064 
2065     let optionalContent;
2066     if (this.oc) {
2067       optionalContent = await evaluator.parseMarkedContentProps(
2068         this.oc,
2069         /* resources = */ null
2070       );
2071     }
2072     if (optionalContent !== undefined) {
2073       opList.addOp(OPS.beginMarkedContentProps, ["OC", optionalContent]);
2074     }
2075 
2076     opList.addOp(OPS.beginAnnotation, [
2077       this.data.id,
2078       this.data.rect,
2079       transform,
2080       this.getRotationMatrix(annotationStorage),
2081       isUsingOwnCanvas,
2082     ]);
2083 
2084     const stream = new StringStream(content);
2085     await evaluator.getOperatorList({
2086       stream,
2087       task,
2088       resources: this._fieldResources.mergedResources,
2089       operatorList: opList,
2090     });
2091     opList.addOp(OPS.endAnnotation, []);
2092 
2093     if (optionalContent !== undefined) {
2094       opList.addOp(OPS.endMarkedContent, []);
2095     }
2096     return { opList, separateForm: false, separateCanvas: isUsingOwnCanvas };
2097   }
2098 
2099   _getMKDict(rotation) {
2100     const mk = new Dict(null);
2101     if (rotation) {
2102       mk.set("R", rotation);
2103     }
2104     if (this.borderColor) {
2105       mk.set("BC", getPdfColorArray(this.borderColor));
2106     }
2107     if (this.backgroundColor) {
2108       mk.set("BG", getPdfColorArray(this.backgroundColor));
2109     }
2110     return mk.size > 0 ? mk : null;
2111   }
2112 
2113   amendSavedDict(annotationStorage, dict) {}
2114 
2115   async save(evaluator, task, annotationStorage) {
2116     const storageEntry = annotationStorage?.get(this.data.id);
2117     const flags = this._buildFlags(storageEntry?.noView, storageEntry?.noPrint);
2118     let value = storageEntry?.value,
2119       rotation = storageEntry?.rotation;
2120     if (value === this.data.fieldValue || value === undefined) {
2121       if (
2122         !this._hasValueFromXFA &&
2123         rotation === undefined &&
2124         flags === undefined
2125       ) {
2126         return null;
2127       }
2128       value ||= this.data.fieldValue;
2129     }
2130 
2131     // Value can be an array (with choice list and multiple selections)
2132     if (
2133       rotation === undefined &&
2134       !this._hasValueFromXFA &&
2135       Array.isArray(value) &&
2136       Array.isArray(this.data.fieldValue) &&
2137       isArrayEqual(value, this.data.fieldValue) &&
2138       flags === undefined
2139     ) {
2140       return null;
2141     }
2142 
2143     if (rotation === undefined) {
2144       rotation = this.rotation;
2145     }
2146 
2147     let appearance = null;
2148     if (!this._needAppearances) {
2149       appearance = await this._getAppearance(
2150         evaluator,
2151         task,
2152         RenderingIntentFlag.SAVE,
2153         annotationStorage
2154       );
2155       if (appearance === null && flags === undefined) {
2156         // Appearance didn't change.
2157         return null;
2158       }
2159     } else {
2160       // No need to create an appearance: the pdf has the flag /NeedAppearances
2161       // which means that it's up to the reader to produce an appearance.
2162     }
2163 
2164     let needAppearances = false;
2165     if (appearance?.needAppearances) {
2166       needAppearances = true;
2167       appearance = null;
2168     }
2169 
2170     const { xref } = evaluator;
2171 
2172     const originalDict = xref.fetchIfRef(this.ref);
2173     if (!(originalDict instanceof Dict)) {
2174       return null;
2175     }
2176 
2177     const dict = new Dict(xref);
2178     for (const key of originalDict.getKeys()) {
2179       if (key !== "AP") {
2180         dict.set(key, originalDict.getRaw(key));
2181       }
2182     }
2183     if (flags !== undefined) {
2184       dict.set("F", flags);
2185       if (appearance === null && !needAppearances) {
2186         const ap = originalDict.getRaw("AP");
2187         if (ap) {
2188           dict.set("AP", ap);
2189         }
2190       }
2191     }
2192 
2193     const xfa = {
2194       path: this.data.fieldName,
2195       value,
2196     };
2197 
2198     dict.set(
2199       "V",
2200       Array.isArray(value)
2201         ? value.map(stringToAsciiOrUTF16BE)
2202         : stringToAsciiOrUTF16BE(value)
2203     );
2204     this.amendSavedDict(annotationStorage, dict);
2205 
2206     const maybeMK = this._getMKDict(rotation);
2207     if (maybeMK) {
2208       dict.set("MK", maybeMK);
2209     }
2210 
2211     const buffer = [];
2212     const changes = [
2213       // data for the original object
2214       // V field changed + reference for new AP
2215       { ref: this.ref, data: "", xfa, needAppearances },
2216     ];
2217     if (appearance !== null) {
2218       const newRef = xref.getNewTemporaryRef();
2219       const AP = new Dict(xref);
2220       dict.set("AP", AP);
2221       AP.set("N", newRef);
2222 
2223       const resources = this._getSaveFieldResources(xref);
2224       const appearanceStream = new StringStream(appearance);
2225       const appearanceDict = (appearanceStream.dict = new Dict(xref));
2226       appearanceDict.set("Subtype", Name.get("Form"));
2227       appearanceDict.set("Resources", resources);
2228       appearanceDict.set("BBox", [
2229         0,
2230         0,
2231         this.data.rect[2] - this.data.rect[0],
2232         this.data.rect[3] - this.data.rect[1],
2233       ]);
2234 
2235       const rotationMatrix = this.getRotationMatrix(annotationStorage);
2236       if (rotationMatrix !== IDENTITY_MATRIX) {
2237         // The matrix isn't the identity one.
2238         appearanceDict.set("Matrix", rotationMatrix);
2239       }
2240 
2241       await writeObject(newRef, appearanceStream, buffer, xref);
2242 
2243       changes.push(
2244         // data for the new AP
2245         {
2246           ref: newRef,
2247           data: buffer.join(""),
2248           xfa: null,
2249           needAppearances: false,
2250         }
2251       );
2252       buffer.length = 0;
2253     }
2254 
2255     dict.set("M", `D:${getModificationDate()}`);
2256     await writeObject(this.ref, dict, buffer, xref);
2257 
2258     changes[0].data = buffer.join("");
2259 
2260     return changes;
2261   }
2262 
2263   async _getAppearance(evaluator, task, intent, annotationStorage) {
2264     const isPassword = this.hasFieldFlag(AnnotationFieldFlag.PASSWORD);
2265     if (isPassword) {
2266       return null;
2267     }
2268     const storageEntry = annotationStorage?.get(this.data.id);
2269     let value, rotation;
2270     if (storageEntry) {
2271       value = storageEntry.formattedValue || storageEntry.value;
2272       rotation = storageEntry.rotation;
2273     }
2274 
2275     if (
2276       rotation === undefined &&
2277       value === undefined &&
2278       !this._needAppearances
2279     ) {
2280       if (!this._hasValueFromXFA || this.appearance) {
2281         // The annotation hasn't been rendered so use the appearance.
2282         return null;
2283       }
2284     }
2285 
2286     // Empty or it has a trailing whitespace.
2287     const colors = this.getBorderAndBackgroundAppearances(annotationStorage);
2288 
2289     if (value === undefined) {
2290       // The annotation has its value in XFA datasets but not in the V field.
2291       value = this.data.fieldValue;
2292       if (!value) {
2293         return `/Tx BMC q ${colors}Q EMC`;
2294       }
2295     }
2296 
2297     if (Array.isArray(value) && value.length === 1) {
2298       value = value[0];
2299     }
2300 
2301     assert(typeof value === "string", "Expected `value` to be a string.");
2302     value = value.trim();
2303 
2304     if (this.data.combo) {
2305       // The value can be one of the exportValue or any other values.
2306       const option = this.data.options.find(
2307         ({ exportValue }) => value === exportValue
2308       );
2309       value = option?.displayValue || value;
2310     }
2311 
2312     if (value === "") {
2313       // the field is empty: nothing to render
2314       return `/Tx BMC q ${colors}Q EMC`;
2315     }
2316 
2317     if (rotation === undefined) {
2318       rotation = this.rotation;
2319     }
2320 
2321     let lineCount = -1;
2322     let lines;
2323 
2324     // We could have a text containing for example some sequences of chars and
2325     // their diacritics (e.g. "é".normalize("NFKD") shows 1 char when it's 2).
2326     // Positioning diacritics is really something we don't want to do here.
2327     // So if a font has a glyph for a acute accent and one for "e" then we won't
2328     // get any encoding issues but we'll render "e" and then "´".
2329     // It's why we normalize the string. We use NFC to preserve the initial
2330     // string, (e.g. "²".normalize("NFC") === "²"
2331     // but "²".normalize("NFKC") === "2").
2332     //
2333     // TODO: it isn't a perfect solution, some chars like "ẹ́" will be
2334     // decomposed into two chars ("ẹ" and "´"), so we should detect such
2335     // situations and then use either FakeUnicodeFont or set the
2336     // /NeedAppearances flag.
2337     if (this.data.multiLine) {
2338       lines = value.split(/\r\n?|\n/).map(line => line.normalize("NFC"));
2339       lineCount = lines.length;
2340     } else {
2341       lines = [value.replace(/\r\n?|\n/, "").normalize("NFC")];
2342     }
2343 
2344     const defaultPadding = 1;
2345     const defaultHPadding = 2;
2346     let totalHeight = this.data.rect[3] - this.data.rect[1];
2347     let totalWidth = this.data.rect[2] - this.data.rect[0];
2348 
2349     if (rotation === 90 || rotation === 270) {
2350       [totalWidth, totalHeight] = [totalHeight, totalWidth];
2351     }
2352 
2353     if (!this._defaultAppearance) {
2354       // The DA is required and must be a string.
2355       // If there is no font named Helvetica in the resource dictionary,
2356       // the evaluator will fall back to a default font.
2357       // Doing so prevents exceptions and allows saving/printing
2358       // the file as expected.
2359       this.data.defaultAppearanceData = parseDefaultAppearance(
2360         (this._defaultAppearance = "/Helvetica 0 Tf 0 g")
2361       );
2362     }
2363 
2364     let font = await WidgetAnnotation._getFontData(
2365       evaluator,
2366       task,
2367       this.data.defaultAppearanceData,
2368       this._fieldResources.mergedResources
2369     );
2370 
2371     let defaultAppearance, fontSize, lineHeight;
2372     const encodedLines = [];
2373     let encodingError = false;
2374     for (const line of lines) {
2375       const encodedString = font.encodeString(line);
2376       if (encodedString.length > 1) {
2377         encodingError = true;
2378       }
2379       encodedLines.push(encodedString.join(""));
2380     }
2381 
2382     if (encodingError && intent & RenderingIntentFlag.SAVE) {
2383       // We don't have a way to render the field, so we just rely on the
2384       // /NeedAppearances trick to let the different sofware correctly render
2385       // this pdf.
2386       return { needAppearances: true };
2387     }
2388 
2389     // We check that the font is able to encode the string.
2390     if (encodingError && this._isOffscreenCanvasSupported) {
2391       // If it can't then we fallback on fake unicode font (mapped to sans-serif
2392       // for the rendering).
2393       // It means that a printed form can be rendered differently (it depends on
2394       // the sans-serif font) but at least we've something to render.
2395       // In an ideal world the associated font should correctly handle the
2396       // possible chars but a user can add a smiley or whatever.
2397       // We could try to embed a font but it means that we must have access
2398       // to the raw font file.
2399       const fontFamily = this.data.comb ? "monospace" : "sans-serif";
2400       const fakeUnicodeFont = new FakeUnicodeFont(evaluator.xref, fontFamily);
2401       const resources = fakeUnicodeFont.createFontResources(lines.join(""));
2402       const newFont = resources.getRaw("Font");
2403 
2404       if (this._fieldResources.mergedResources.has("Font")) {
2405         const oldFont = this._fieldResources.mergedResources.get("Font");
2406         for (const key of newFont.getKeys()) {
2407           oldFont.set(key, newFont.getRaw(key));
2408         }
2409       } else {
2410         this._fieldResources.mergedResources.set("Font", newFont);
2411       }
2412 
2413       const fontName = fakeUnicodeFont.fontName.name;
2414       font = await WidgetAnnotation._getFontData(
2415         evaluator,
2416         task,
2417         { fontName, fontSize: 0 },
2418         resources
2419       );
2420 
2421       for (let i = 0, ii = encodedLines.length; i < ii; i++) {
2422         encodedLines[i] = stringToUTF16String(lines[i]);
2423       }
2424 
2425       const savedDefaultAppearance = Object.assign(
2426         Object.create(null),
2427         this.data.defaultAppearanceData
2428       );
2429       this.data.defaultAppearanceData.fontSize = 0;
2430       this.data.defaultAppearanceData.fontName = fontName;
2431 
2432       [defaultAppearance, fontSize, lineHeight] = this._computeFontSize(
2433         totalHeight - 2 * defaultPadding,
2434         totalWidth - 2 * defaultHPadding,
2435         value,
2436         font,
2437         lineCount
2438       );
2439 
2440       this.data.defaultAppearanceData = savedDefaultAppearance;
2441     } else {
2442       if (!this._isOffscreenCanvasSupported) {
2443         warn(
2444           "_getAppearance: OffscreenCanvas is not supported, annotation may not render correctly."
2445         );
2446       }
2447 
2448       [defaultAppearance, fontSize, lineHeight] = this._computeFontSize(
2449         totalHeight - 2 * defaultPadding,
2450         totalWidth - 2 * defaultHPadding,
2451         value,
2452         font,
2453         lineCount
2454       );
2455     }
2456 
2457     let descent = font.descent;
2458     if (isNaN(descent)) {
2459       descent = BASELINE_FACTOR * lineHeight;
2460     } else {
2461       descent = Math.max(
2462         BASELINE_FACTOR * lineHeight,
2463         Math.abs(descent) * fontSize
2464       );
2465     }
2466 
2467     // Take into account the space we have to compute the default vertical
2468     // padding.
2469     const defaultVPadding = Math.min(
2470       Math.floor((totalHeight - fontSize) / 2),
2471       defaultPadding
2472     );
2473     const alignment = this.data.textAlignment;
2474 
2475     if (this.data.multiLine) {
2476       return this._getMultilineAppearance(
2477         defaultAppearance,
2478         encodedLines,
2479         font,
2480         fontSize,
2481         totalWidth,
2482         totalHeight,
2483         alignment,
2484         defaultHPadding,
2485         defaultVPadding,
2486         descent,
2487         lineHeight,
2488         annotationStorage
2489       );
2490     }
2491 
2492     if (this.data.comb) {
2493       return this._getCombAppearance(
2494         defaultAppearance,
2495         font,
2496         encodedLines[0],
2497         fontSize,
2498         totalWidth,
2499         totalHeight,
2500         defaultHPadding,
2501         defaultVPadding,
2502         descent,
2503         lineHeight,
2504         annotationStorage
2505       );
2506     }
2507 
2508     const bottomPadding = defaultVPadding + descent;
2509     if (alignment === 0 || alignment > 2) {
2510       // Left alignment: nothing to do
2511       return (
2512         `/Tx BMC q ${colors}BT ` +
2513         defaultAppearance +
2514         ` 1 0 0 1 ${numberToString(defaultHPadding)} ${numberToString(
2515           bottomPadding
2516         )} Tm (${escapeString(encodedLines[0])}) Tj` +
2517         " ET Q EMC"
2518       );
2519     }
2520 
2521     const prevInfo = { shift: 0 };
2522     const renderedText = this._renderText(
2523       encodedLines[0],
2524       font,
2525       fontSize,
2526       totalWidth,
2527       alignment,
2528       prevInfo,
2529       defaultHPadding,
2530       bottomPadding
2531     );
2532     return (
2533       `/Tx BMC q ${colors}BT ` +
2534       defaultAppearance +
2535       ` 1 0 0 1 0 0 Tm ${renderedText}` +
2536       " ET Q EMC"
2537     );
2538   }
2539 
2540   static async _getFontData(evaluator, task, appearanceData, resources) {
2541     const operatorList = new OperatorList();
2542     const initialState = {
2543       font: null,
2544       clone() {
2545         return this;
2546       },
2547     };
2548 
2549     const { fontName, fontSize } = appearanceData;
2550     await evaluator.handleSetFont(
2551       resources,
2552       [fontName && Name.get(fontName), fontSize],
2553       /* fontRef = */ null,
2554       operatorList,
2555       task,
2556       initialState,
2557       /* fallbackFontDict = */ null
2558     );
2559 
2560     return initialState.font;
2561   }
2562 
2563   _getTextWidth(text, font) {
2564     return (
2565       font
2566         .charsToGlyphs(text)
2567         .reduce((width, glyph) => width + glyph.width, 0) / 1000
2568     );
2569   }
2570 
2571   _computeFontSize(height, width, text, font, lineCount) {
2572     let { fontSize } = this.data.defaultAppearanceData;
2573     let lineHeight = (fontSize || 12) * LINE_FACTOR,
2574       numberOfLines = Math.round(height / lineHeight);
2575 
2576     if (!fontSize) {
2577       // A zero value for size means that the font shall be auto-sized:
2578       // its size shall be computed as a function of the height of the
2579       // annotation rectangle (see 12.7.3.3).
2580 
2581       const roundWithTwoDigits = x => Math.floor(x * 100) / 100;
2582 
2583       if (lineCount === -1) {
2584         // Get the text width for a font size of 1.
2585         const textWidth = this._getTextWidth(text, font);
2586 
2587         // width / textWidth is the max font size to fit the width.
2588         // height / LINE_FACTOR is the max font size to fit the height.
2589         fontSize = roundWithTwoDigits(
2590           Math.min(height / LINE_FACTOR, width / textWidth)
2591         );
2592         numberOfLines = 1;
2593       } else {
2594         const lines = text.split(/\r\n?|\n/);
2595         const cachedLines = [];
2596         for (const line of lines) {
2597           const encoded = font.encodeString(line).join("");
2598           const glyphs = font.charsToGlyphs(encoded);
2599           const positions = font.getCharPositions(encoded);
2600           cachedLines.push({
2601             line: encoded,
2602             glyphs,
2603             positions,
2604           });
2605         }
2606 
2607         const isTooBig = fsize => {
2608           // Return true when the text doesn't fit the given height.
2609           let totalHeight = 0;
2610           for (const cache of cachedLines) {
2611             const chunks = this._splitLine(null, font, fsize, width, cache);
2612             totalHeight += chunks.length * fsize;
2613             if (totalHeight > height) {
2614               return true;
2615             }
2616           }
2617           return false;
2618         };
2619 
2620         // Hard to guess how many lines there are.
2621         // The field may have been sized to have 10 lines
2622         // and the user entered only 1 so if we get font size from
2623         // height and number of lines then we'll get something too big.
2624         // So we compute a fake number of lines based on height and
2625         // a font size equal to 12 (this is the default font size in
2626         // Acrobat).
2627         // Then we'll adjust font size to what we have really.
2628         numberOfLines = Math.max(numberOfLines, lineCount);
2629 
2630         while (true) {
2631           lineHeight = height / numberOfLines;
2632           fontSize = roundWithTwoDigits(lineHeight / LINE_FACTOR);
2633 
2634           if (isTooBig(fontSize)) {
2635             numberOfLines++;
2636             continue;
2637           }
2638 
2639           break;
2640         }
2641       }
2642 
2643       const { fontName, fontColor } = this.data.defaultAppearanceData;
2644       this._defaultAppearance = createDefaultAppearance({
2645         fontSize,
2646         fontName,
2647         fontColor,
2648       });
2649     }
2650 
2651     return [this._defaultAppearance, fontSize, height / numberOfLines];
2652   }
2653 
2654   _renderText(
2655     text,
2656     font,
2657     fontSize,
2658     totalWidth,
2659     alignment,
2660     prevInfo,
2661     hPadding,
2662     vPadding
2663   ) {
2664     // TODO: we need to take into account (if possible) how the text
2665     // is rendered. For example in arabic, the cumulated width of some
2666     // glyphs isn't equal to the width of the rendered glyphs because
2667     // of ligatures.
2668     let shift;
2669     if (alignment === 1) {
2670       // Center
2671       const width = this._getTextWidth(text, font) * fontSize;
2672       shift = (totalWidth - width) / 2;
2673     } else if (alignment === 2) {
2674       // Right
2675       const width = this._getTextWidth(text, font) * fontSize;
2676       shift = totalWidth - width - hPadding;
2677     } else {
2678       shift = hPadding;
2679     }
2680     const shiftStr = numberToString(shift - prevInfo.shift);
2681     prevInfo.shift = shift;
2682     vPadding = numberToString(vPadding);
2683 
2684     return `${shiftStr} ${vPadding} Td (${escapeString(text)}) Tj`;
2685   }
2686 
2687   /**
2688    * @private
2689    */
2690   _getSaveFieldResources(xref) {
2691     if (typeof PDFJSDev === "undefined" || PDFJSDev.test("TESTING")) {
2692       assert(
2693         this.data.defaultAppearanceData,
2694         "Expected `_defaultAppearanceData` to have been set."
2695       );
2696     }
2697     const { localResources, appearanceResources, acroFormResources } =
2698       this._fieldResources;
2699 
2700     const fontName = this.data.defaultAppearanceData?.fontName;
2701     if (!fontName) {
2702       return localResources || Dict.empty;
2703     }
2704 
2705     for (const resources of [localResources, appearanceResources]) {
2706       if (resources instanceof Dict) {
2707         const localFont = resources.get("Font");
2708         if (localFont instanceof Dict && localFont.has(fontName)) {
2709           return resources;
2710         }
2711       }
2712     }
2713     if (acroFormResources instanceof Dict) {
2714       const acroFormFont = acroFormResources.get("Font");
2715       if (acroFormFont instanceof Dict && acroFormFont.has(fontName)) {
2716         const subFontDict = new Dict(xref);
2717         subFontDict.set(fontName, acroFormFont.getRaw(fontName));
2718 
2719         const subResourcesDict = new Dict(xref);
2720         subResourcesDict.set("Font", subFontDict);
2721 
2722         return Dict.merge({
2723           xref,
2724           dictArray: [subResourcesDict, localResources],
2725           mergeSubDicts: true,
2726         });
2727       }
2728     }
2729     return localResources || Dict.empty;
2730   }
2731 
2732   getFieldObject() {
2733     return null;
2734   }
2735 }
2736 
2737 class TextWidgetAnnotation extends WidgetAnnotation {
2738   constructor(params) {
2739     super(params);
2740 
2741     const { dict } = params;
2742 
2743     if (dict.has("PMD")) {
2744       // It's used to display a barcode but it isn't specified so we just hide
2745       // it to avoid any confusion.
2746       this.flags |= AnnotationFlag.HIDDEN;
2747       this.data.hidden = true;
2748       warn("Barcodes are not supported");
2749     }
2750 
2751     this.data.hasOwnCanvas = this.data.readOnly && !this.data.noHTML;
2752     this._hasText = true;
2753 
2754     // The field value is always a string.
2755     if (typeof this.data.fieldValue !== "string") {
2756       this.data.fieldValue = "";
2757     }
2758 
2759     // Determine the alignment of text in the field.
2760     let alignment = getInheritableProperty({ dict, key: "Q" });
2761     if (!Number.isInteger(alignment) || alignment < 0 || alignment > 2) {
2762       alignment = null;
2763     }
2764     this.data.textAlignment = alignment;
2765 
2766     // Determine the maximum length of text in the field.
2767     let maximumLength = getInheritableProperty({ dict, key: "MaxLen" });
2768     if (!Number.isInteger(maximumLength) || maximumLength < 0) {
2769       maximumLength = 0;
2770     }
2771     this.data.maxLen = maximumLength;
2772 
2773     // Process field flags for the display layer.
2774     this.data.multiLine = this.hasFieldFlag(AnnotationFieldFlag.MULTILINE);
2775     this.data.comb =
2776       this.hasFieldFlag(AnnotationFieldFlag.COMB) &&
2777       !this.hasFieldFlag(AnnotationFieldFlag.MULTILINE) &&
2778       !this.hasFieldFlag(AnnotationFieldFlag.PASSWORD) &&
2779       !this.hasFieldFlag(AnnotationFieldFlag.FILESELECT) &&
2780       this.data.maxLen !== 0;
2781     this.data.doNotScroll = this.hasFieldFlag(AnnotationFieldFlag.DONOTSCROLL);
2782   }
2783 
2784   get hasTextContent() {
2785     return !!this.appearance && !this._needAppearances;
2786   }
2787 
2788   _getCombAppearance(
2789     defaultAppearance,
2790     font,
2791     text,
2792     fontSize,
2793     width,
2794     height,
2795     hPadding,
2796     vPadding,
2797     descent,
2798     lineHeight,
2799     annotationStorage
2800   ) {
2801     const combWidth = width / this.data.maxLen;
2802     // Empty or it has a trailing whitespace.
2803     const colors = this.getBorderAndBackgroundAppearances(annotationStorage);
2804 
2805     const buf = [];
2806     const positions = font.getCharPositions(text);
2807     for (const [start, end] of positions) {
2808       buf.push(`(${escapeString(text.substring(start, end))}) Tj`);
2809     }
2810 
2811     const renderedComb = buf.join(` ${numberToString(combWidth)} 0 Td `);
2812     return (
2813       `/Tx BMC q ${colors}BT ` +
2814       defaultAppearance +
2815       ` 1 0 0 1 ${numberToString(hPadding)} ${numberToString(
2816         vPadding + descent
2817       )} Tm ${renderedComb}` +
2818       " ET Q EMC"
2819     );
2820   }
2821 
2822   _getMultilineAppearance(
2823     defaultAppearance,
2824     lines,
2825     font,
2826     fontSize,
2827     width,
2828     height,
2829     alignment,
2830     hPadding,
2831     vPadding,
2832     descent,
2833     lineHeight,
2834     annotationStorage
2835   ) {
2836     const buf = [];
2837     const totalWidth = width - 2 * hPadding;
2838     const prevInfo = { shift: 0 };
2839     for (let i = 0, ii = lines.length; i < ii; i++) {
2840       const line = lines[i];
2841       const chunks = this._splitLine(line, font, fontSize, totalWidth);
2842       for (let j = 0, jj = chunks.length; j < jj; j++) {
2843         const chunk = chunks[j];
2844         const vShift =
2845           i === 0 && j === 0 ? -vPadding - (lineHeight - descent) : -lineHeight;
2846         buf.push(
2847           this._renderText(
2848             chunk,
2849             font,
2850             fontSize,
2851             width,
2852             alignment,
2853             prevInfo,
2854             hPadding,
2855             vShift
2856           )
2857         );
2858       }
2859     }
2860 
2861     // Empty or it has a trailing whitespace.
2862     const colors = this.getBorderAndBackgroundAppearances(annotationStorage);
2863     const renderedText = buf.join("\n");
2864 
2865     return (
2866       `/Tx BMC q ${colors}BT ` +
2867       defaultAppearance +
2868       ` 1 0 0 1 0 ${numberToString(height)} Tm ${renderedText}` +
2869       " ET Q EMC"
2870     );
2871   }
2872 
2873   _splitLine(line, font, fontSize, width, cache = {}) {
2874     line = cache.line || line;
2875 
2876     const glyphs = cache.glyphs || font.charsToGlyphs(line);
2877 
2878     if (glyphs.length <= 1) {
2879       // Nothing to split
2880       return [line];
2881     }
2882 
2883     const positions = cache.positions || font.getCharPositions(line);
2884     const scale = fontSize / 1000;
2885     const chunks = [];
2886 
2887     let lastSpacePosInStringStart = -1,
2888       lastSpacePosInStringEnd = -1,
2889       lastSpacePos = -1,
2890       startChunk = 0,
2891       currentWidth = 0;
2892 
2893     for (let i = 0, ii = glyphs.length; i < ii; i++) {
2894       const [start, end] = positions[i];
2895       const glyph = glyphs[i];
2896       const glyphWidth = glyph.width * scale;
2897       if (glyph.unicode === " ") {
2898         if (currentWidth + glyphWidth > width) {
2899           // We can break here
2900           chunks.push(line.substring(startChunk, start));
2901           startChunk = start;
2902           currentWidth = glyphWidth;
2903           lastSpacePosInStringStart = -1;
2904           lastSpacePos = -1;
2905         } else {
2906           currentWidth += glyphWidth;
2907           lastSpacePosInStringStart = start;
2908           lastSpacePosInStringEnd = end;
2909           lastSpacePos = i;
2910         }
2911       } else if (currentWidth + glyphWidth > width) {
2912         // We must break to the last white position (if available)
2913         if (lastSpacePosInStringStart !== -1) {
2914           chunks.push(line.substring(startChunk, lastSpacePosInStringEnd));
2915           startChunk = lastSpacePosInStringEnd;
2916           i = lastSpacePos + 1;
2917           lastSpacePosInStringStart = -1;
2918           currentWidth = 0;
2919         } else {
2920           // Just break in the middle of the word
2921           chunks.push(line.substring(startChunk, start));
2922           startChunk = start;
2923           currentWidth = glyphWidth;
2924         }
2925       } else {
2926         currentWidth += glyphWidth;
2927       }
2928     }
2929 
2930     if (startChunk < line.length) {
2931       chunks.push(line.substring(startChunk, line.length));
2932     }
2933 
2934     return chunks;
2935   }
2936 
2937   getFieldObject() {
2938     return {
2939       id: this.data.id,
2940       value: this.data.fieldValue,
2941       defaultValue: this.data.defaultFieldValue || "",
2942       multiline: this.data.multiLine,
2943       password: this.hasFieldFlag(AnnotationFieldFlag.PASSWORD),
2944       charLimit: this.data.maxLen,
2945       comb: this.data.comb,
2946       editable: !this.data.readOnly,
2947       hidden: this.data.hidden,
2948       name: this.data.fieldName,
2949       rect: this.data.rect,
2950       actions: this.data.actions,
2951       page: this.data.pageIndex,
2952       strokeColor: this.data.borderColor,
2953       fillColor: this.data.backgroundColor,
2954       rotation: this.rotation,
2955       type: "text",
2956     };
2957   }
2958 }
2959 
2960 class ButtonWidgetAnnotation extends WidgetAnnotation {
2961   constructor(params) {
2962     super(params);
2963 
2964     this.checkedAppearance = null;
2965     this.uncheckedAppearance = null;
2966 
2967     this.data.checkBox =
2968       !this.hasFieldFlag(AnnotationFieldFlag.RADIO) &&
2969       !this.hasFieldFlag(AnnotationFieldFlag.PUSHBUTTON);
2970     this.data.radioButton =
2971       this.hasFieldFlag(AnnotationFieldFlag.RADIO) &&
2972       !this.hasFieldFlag(AnnotationFieldFlag.PUSHBUTTON);
2973     this.data.pushButton = this.hasFieldFlag(AnnotationFieldFlag.PUSHBUTTON);
2974     this.data.isTooltipOnly = false;
2975 
2976     if (this.data.checkBox) {
2977       this._processCheckBox(params);
2978     } else if (this.data.radioButton) {
2979       this._processRadioButton(params);
2980     } else if (this.data.pushButton) {
2981       this.data.hasOwnCanvas = true;
2982       this.data.noHTML = false;
2983       this._processPushButton(params);
2984     } else {
2985       warn("Invalid field flags for button widget annotation");
2986     }
2987   }
2988 
2989   async getOperatorList(evaluator, task, intent, annotationStorage) {
2990     if (this.data.pushButton) {
2991       return super.getOperatorList(
2992         evaluator,
2993         task,
2994         intent,
2995         false, // we use normalAppearance to render the button
2996         annotationStorage
2997       );
2998     }
2999 
3000     let value = null;
3001     let rotation = null;
3002     if (annotationStorage) {
3003       const storageEntry = annotationStorage.get(this.data.id);
3004       value = storageEntry ? storageEntry.value : null;
3005       rotation = storageEntry ? storageEntry.rotation : null;
3006     }
3007 
3008     if (value === null && this.appearance) {
3009       // Nothing in the annotationStorage.
3010       // But we've a default appearance so use it.
3011       return super.getOperatorList(evaluator, task, intent, annotationStorage);
3012     }
3013 
3014     if (value === null || value === undefined) {
3015       // There is no default appearance so use the one derived
3016       // from the field value.
3017       value = this.data.checkBox
3018         ? this.data.fieldValue === this.data.exportValue
3019         : this.data.fieldValue === this.data.buttonValue;
3020     }
3021 
3022     const appearance = value
3023       ? this.checkedAppearance
3024       : this.uncheckedAppearance;
3025     if (appearance) {
3026       const savedAppearance = this.appearance;
3027       const savedMatrix = lookupMatrix(
3028         appearance.dict.getArray("Matrix"),
3029         IDENTITY_MATRIX
3030       );
3031 
3032       if (rotation) {
3033         appearance.dict.set(
3034           "Matrix",
3035           this.getRotationMatrix(annotationStorage)
3036         );
3037       }
3038 
3039       this.appearance = appearance;
3040       const operatorList = super.getOperatorList(
3041         evaluator,
3042         task,
3043         intent,
3044         annotationStorage
3045       );
3046       this.appearance = savedAppearance;
3047       appearance.dict.set("Matrix", savedMatrix);
3048       return operatorList;
3049     }
3050 
3051     // No appearance
3052     return {
3053       opList: new OperatorList(),
3054       separateForm: false,
3055       separateCanvas: false,
3056     };
3057   }
3058 
3059   async save(evaluator, task, annotationStorage) {
3060     if (this.data.checkBox) {
3061       return this._saveCheckbox(evaluator, task, annotationStorage);
3062     }
3063 
3064     if (this.data.radioButton) {
3065       return this._saveRadioButton(evaluator, task, annotationStorage);
3066     }
3067 
3068     // Nothing to save
3069     return null;
3070   }
3071 
3072   async _saveCheckbox(evaluator, task, annotationStorage) {
3073     if (!annotationStorage) {
3074       return null;
3075     }
3076     const storageEntry = annotationStorage.get(this.data.id);
3077     const flags = this._buildFlags(storageEntry?.noView, storageEntry?.noPrint);
3078     let rotation = storageEntry?.rotation,
3079       value = storageEntry?.value;
3080 
3081     if (rotation === undefined && flags === undefined) {
3082       if (value === undefined) {
3083         return null;
3084       }
3085 
3086       const defaultValue = this.data.fieldValue === this.data.exportValue;
3087       if (defaultValue === value) {
3088         return null;
3089       }
3090     }
3091 
3092     let dict = evaluator.xref.fetchIfRef(this.ref);
3093     if (!(dict instanceof Dict)) {
3094       return null;
3095     }
3096     dict = dict.clone();
3097 
3098     if (rotation === undefined) {
3099       rotation = this.rotation;
3100     }
3101     if (value === undefined) {
3102       value = this.data.fieldValue === this.data.exportValue;
3103     }
3104 
3105     const xfa = {
3106       path: this.data.fieldName,
3107       value: value ? this.data.exportValue : "",
3108     };
3109 
3110     const name = Name.get(value ? this.data.exportValue : "Off");
3111     dict.set("V", name);
3112     dict.set("AS", name);
3113     dict.set("M", `D:${getModificationDate()}`);
3114     if (flags !== undefined) {
3115       dict.set("F", flags);
3116     }
3117 
3118     const maybeMK = this._getMKDict(rotation);
3119     if (maybeMK) {
3120       dict.set("MK", maybeMK);
3121     }
3122 
3123     const buffer = [];
3124     await writeObject(this.ref, dict, buffer, evaluator.xref);
3125 
3126     return [{ ref: this.ref, data: buffer.join(""), xfa }];
3127   }
3128 
3129   async _saveRadioButton(evaluator, task, annotationStorage) {
3130     if (!annotationStorage) {
3131       return null;
3132     }
3133     const storageEntry = annotationStorage.get(this.data.id);
3134     const flags = this._buildFlags(storageEntry?.noView, storageEntry?.noPrint);
3135     let rotation = storageEntry?.rotation,
3136       value = storageEntry?.value;
3137 
3138     if (rotation === undefined && flags === undefined) {
3139       if (value === undefined) {
3140         return null;
3141       }
3142 
3143       const defaultValue = this.data.fieldValue === this.data.buttonValue;
3144       if (defaultValue === value) {
3145         return null;
3146       }
3147     }
3148 
3149     let dict = evaluator.xref.fetchIfRef(this.ref);
3150     if (!(dict instanceof Dict)) {
3151       return null;
3152     }
3153     dict = dict.clone();
3154 
3155     if (value === undefined) {
3156       value = this.data.fieldValue === this.data.buttonValue;
3157     }
3158 
3159     if (rotation === undefined) {
3160       rotation = this.rotation;
3161     }
3162 
3163     const xfa = {
3164       path: this.data.fieldName,
3165       value: value ? this.data.buttonValue : "",
3166     };
3167 
3168     const name = Name.get(value ? this.data.buttonValue : "Off");
3169     const buffer = [];
3170     let parentData = null;
3171 
3172     if (value) {
3173       if (this.parent instanceof Ref) {
3174         const parent = evaluator.xref.fetch(this.parent);
3175         parent.set("V", name);
3176         await writeObject(this.parent, parent, buffer, evaluator.xref);
3177         parentData = buffer.join("");
3178         buffer.length = 0;
3179       } else if (this.parent instanceof Dict) {
3180         this.parent.set("V", name);
3181       }
3182     }
3183 
3184     if (!this.parent) {
3185       // If there is no parent then we must set the value in the field.
3186       dict.set("V", name);
3187     }
3188 
3189     dict.set("AS", name);
3190     dict.set("M", `D:${getModificationDate()}`);
3191     if (flags !== undefined) {
3192       dict.set("F", flags);
3193     }
3194 
3195     const maybeMK = this._getMKDict(rotation);
3196     if (maybeMK) {
3197       dict.set("MK", maybeMK);
3198     }
3199 
3200     await writeObject(this.ref, dict, buffer, evaluator.xref);
3201     const newRefs = [{ ref: this.ref, data: buffer.join(""), xfa }];
3202     if (parentData) {
3203       newRefs.push({ ref: this.parent, data: parentData, xfa: null });
3204     }
3205 
3206     return newRefs;
3207   }
3208 
3209   _getDefaultCheckedAppearance(params, type) {
3210     const width = this.data.rect[2] - this.data.rect[0];
3211     const height = this.data.rect[3] - this.data.rect[1];
3212     const bbox = [0, 0, width, height];
3213 
3214     // Ratio used to have a mark slightly smaller than the bbox.
3215     const FONT_RATIO = 0.8;
3216     const fontSize = Math.min(width, height) * FONT_RATIO;
3217 
3218     // Char Metrics
3219     // Widths came from widths for ZapfDingbats.
3220     // Heights are guessed with Fontforge and FoxitDingbats.pfb.
3221     let metrics, char;
3222     if (type === "check") {
3223       // Char 33 (2713 in unicode)
3224       metrics = {
3225         width: 0.755 * fontSize,
3226         height: 0.705 * fontSize,
3227       };
3228       char = "\x33";
3229     } else if (type === "disc") {
3230       // Char 6C (25CF in unicode)
3231       metrics = {
3232         width: 0.791 * fontSize,
3233         height: 0.705 * fontSize,
3234       };
3235       char = "\x6C";
3236     } else {
3237       unreachable(`_getDefaultCheckedAppearance - unsupported type: ${type}`);
3238     }
3239 
3240     // Values to center the glyph in the bbox.
3241     const xShift = numberToString((width - metrics.width) / 2);
3242     const yShift = numberToString((height - metrics.height) / 2);
3243 
3244     const appearance = `q BT /PdfJsZaDb ${fontSize} Tf 0 g ${xShift} ${yShift} Td (${char}) Tj ET Q`;
3245 
3246     const appearanceStreamDict = new Dict(params.xref);
3247     appearanceStreamDict.set("FormType", 1);
3248     appearanceStreamDict.set("Subtype", Name.get("Form"));
3249     appearanceStreamDict.set("Type", Name.get("XObject"));
3250     appearanceStreamDict.set("BBox", bbox);
3251     appearanceStreamDict.set("Matrix", [1, 0, 0, 1, 0, 0]);
3252     appearanceStreamDict.set("Length", appearance.length);
3253 
3254     const resources = new Dict(params.xref);
3255     const font = new Dict(params.xref);
3256     font.set("PdfJsZaDb", this.fallbackFontDict);
3257     resources.set("Font", font);
3258 
3259     appearanceStreamDict.set("Resources", resources);
3260 
3261     this.checkedAppearance = new StringStream(appearance);
3262     this.checkedAppearance.dict = appearanceStreamDict;
3263 
3264     this._streams.push(this.checkedAppearance);
3265   }
3266 
3267   _processCheckBox(params) {
3268     const customAppearance = params.dict.get("AP");
3269     if (!(customAppearance instanceof Dict)) {
3270       return;
3271     }
3272 
3273     const normalAppearance = customAppearance.get("N");
3274     if (!(normalAppearance instanceof Dict)) {
3275       return;
3276     }
3277 
3278     // See https://bugzilla.mozilla.org/show_bug.cgi?id=1722036.
3279     // If we've an AS and a V then take AS.
3280     const asValue = this._decodeFormValue(params.dict.get("AS"));
3281     if (typeof asValue === "string") {
3282       this.data.fieldValue = asValue;
3283     }
3284 
3285     const yes =
3286       this.data.fieldValue !== null && this.data.fieldValue !== "Off"
3287         ? this.data.fieldValue
3288         : "Yes";
3289 
3290     const exportValues = normalAppearance.getKeys();
3291     if (exportValues.length === 0) {
3292       exportValues.push("Off", yes);
3293     } else if (exportValues.length === 1) {
3294       if (exportValues[0] === "Off") {
3295         exportValues.push(yes);
3296       } else {
3297         exportValues.unshift("Off");
3298       }
3299     } else if (exportValues.includes(yes)) {
3300       exportValues.length = 0;
3301       exportValues.push("Off", yes);
3302     } else {
3303       const otherYes = exportValues.find(v => v !== "Off");
3304       exportValues.length = 0;
3305       exportValues.push("Off", otherYes);
3306     }
3307 
3308     // Don't use a "V" entry pointing to a non-existent appearance state,
3309     // see e.g. bug1720411.pdf where it's an *empty* Name-instance.
3310     if (!exportValues.includes(this.data.fieldValue)) {
3311       this.data.fieldValue = "Off";
3312     }
3313 
3314     this.data.exportValue = exportValues[1];
3315 
3316     const checkedAppearance = normalAppearance.get(this.data.exportValue);
3317     this.checkedAppearance =
3318       checkedAppearance instanceof BaseStream ? checkedAppearance : null;
3319     const uncheckedAppearance = normalAppearance.get("Off");
3320     this.uncheckedAppearance =
3321       uncheckedAppearance instanceof BaseStream ? uncheckedAppearance : null;
3322 
3323     if (this.checkedAppearance) {
3324       this._streams.push(this.checkedAppearance);
3325     } else {
3326       this._getDefaultCheckedAppearance(params, "check");
3327     }
3328     if (this.uncheckedAppearance) {
3329       this._streams.push(this.uncheckedAppearance);
3330     }
3331     this._fallbackFontDict = this.fallbackFontDict;
3332     if (this.data.defaultFieldValue === null) {
3333       this.data.defaultFieldValue = "Off";
3334     }
3335   }
3336 
3337   _processRadioButton(params) {
3338     this.data.buttonValue = null;
3339 
3340     // The parent field's `V` entry holds a `Name` object with the appearance
3341     // state of whichever child field is currently in the "on" state.
3342     const fieldParent = params.dict.get("Parent");
3343     if (fieldParent instanceof Dict) {
3344       this.parent = params.dict.getRaw("Parent");
3345       const fieldParentValue = fieldParent.get("V");
3346       if (fieldParentValue instanceof Name) {
3347         this.data.fieldValue = this._decodeFormValue(fieldParentValue);
3348       }
3349     }
3350 
3351     // The button's value corresponds to its appearance state.
3352     const appearanceStates = params.dict.get("AP");
3353     if (!(appearanceStates instanceof Dict)) {
3354       return;
3355     }
3356     const normalAppearance = appearanceStates.get("N");
3357     if (!(normalAppearance instanceof Dict)) {
3358       return;
3359     }
3360     for (const key of normalAppearance.getKeys()) {
3361       if (key !== "Off") {
3362         this.data.buttonValue = this._decodeFormValue(key);
3363         break;
3364       }
3365     }
3366 
3367     const checkedAppearance = normalAppearance.get(this.data.buttonValue);
3368     this.checkedAppearance =
3369       checkedAppearance instanceof BaseStream ? checkedAppearance : null;
3370     const uncheckedAppearance = normalAppearance.get("Off");
3371     this.uncheckedAppearance =
3372       uncheckedAppearance instanceof BaseStream ? uncheckedAppearance : null;
3373 
3374     if (this.checkedAppearance) {
3375       this._streams.push(this.checkedAppearance);
3376     } else {
3377       this._getDefaultCheckedAppearance(params, "disc");
3378     }
3379     if (this.uncheckedAppearance) {
3380       this._streams.push(this.uncheckedAppearance);
3381     }
3382     this._fallbackFontDict = this.fallbackFontDict;
3383     if (this.data.defaultFieldValue === null) {
3384       this.data.defaultFieldValue = "Off";
3385     }
3386   }
3387 
3388   _processPushButton(params) {
3389     const { dict, annotationGlobals } = params;
3390 
3391     if (!dict.has("A") && !dict.has("AA") && !this.data.alternativeText) {
3392       warn("Push buttons without action dictionaries are not supported");
3393       return;
3394     }
3395 
3396     this.data.isTooltipOnly = !dict.has("A") && !dict.has("AA");
3397 
3398     Catalog.parseDestDictionary({
3399       destDict: dict,
3400       resultObj: this.data,
3401       docBaseUrl: annotationGlobals.baseUrl,
3402       docAttachments: annotationGlobals.attachments,
3403     });
3404   }
3405 
3406   getFieldObject() {
3407     let type = "button";
3408     let exportValues;
3409     if (this.data.checkBox) {
3410       type = "checkbox";
3411       exportValues = this.data.exportValue;
3412     } else if (this.data.radioButton) {
3413       type = "radiobutton";
3414       exportValues = this.data.buttonValue;
3415     }
3416     return {
3417       id: this.data.id,
3418       value: this.data.fieldValue || "Off",
3419       defaultValue: this.data.defaultFieldValue,
3420       exportValues,
3421       editable: !this.data.readOnly,
3422       name: this.data.fieldName,
3423       rect: this.data.rect,
3424       hidden: this.data.hidden,
3425       actions: this.data.actions,
3426       page: this.data.pageIndex,
3427       strokeColor: this.data.borderColor,
3428       fillColor: this.data.backgroundColor,
3429       rotation: this.rotation,
3430       type,
3431     };
3432   }
3433 
3434   get fallbackFontDict() {
3435     const dict = new Dict();
3436     dict.set("BaseFont", Name.get("ZapfDingbats"));
3437     dict.set("Type", Name.get("FallbackType"));
3438     dict.set("Subtype", Name.get("FallbackType"));
3439     dict.set("Encoding", Name.get("ZapfDingbatsEncoding"));
3440 
3441     return shadow(this, "fallbackFontDict", dict);
3442   }
3443 }
3444 
3445 class ChoiceWidgetAnnotation extends WidgetAnnotation {
3446   constructor(params) {
3447     super(params);
3448 
3449     const { dict, xref } = params;
3450 
3451     this.indices = dict.getArray("I");
3452     this.hasIndices = Array.isArray(this.indices) && this.indices.length > 0;
3453 
3454     // Determine the options. The options array may consist of strings or
3455     // arrays. If the array consists of arrays, then the first element of
3456     // each array is the export value and the second element of each array is
3457     // the display value. If the array consists of strings, then these
3458     // represent both the export and display value. In this case, we convert
3459     // it to an array of arrays as well for convenience in the display layer.
3460     // Note that the specification does not state that the `Opt` field is
3461     // inheritable, but in practice PDF generators do make annotations
3462     // inherit the options from a parent annotation (issue 8094).
3463     this.data.options = [];
3464 
3465     const options = getInheritableProperty({ dict, key: "Opt" });
3466     if (Array.isArray(options)) {
3467       for (let i = 0, ii = options.length; i < ii; i++) {
3468         const option = xref.fetchIfRef(options[i]);
3469         const isOptionArray = Array.isArray(option);
3470 
3471         this.data.options[i] = {
3472           exportValue: this._decodeFormValue(
3473             isOptionArray ? xref.fetchIfRef(option[0]) : option
3474           ),
3475           displayValue: this._decodeFormValue(
3476             isOptionArray ? xref.fetchIfRef(option[1]) : option
3477           ),
3478         };
3479       }
3480     }
3481 
3482     if (!this.hasIndices) {
3483       // The field value can be `null` if no item is selected, a string if one
3484       // item is selected or an array of strings if multiple items are selected.
3485       // For consistency in the API and convenience in the display layer, we
3486       // always make the field value an array with zero, one or multiple items.
3487       if (typeof this.data.fieldValue === "string") {
3488         this.data.fieldValue = [this.data.fieldValue];
3489       } else if (!this.data.fieldValue) {
3490         this.data.fieldValue = [];
3491       }
3492     } else {
3493       // The specs say that we should have an indices array only with
3494       // multiselectable Choice and the "V" entry should have the
3495       // precedence, but Acrobat itself is using it whatever the
3496       // the "V" entry is (see bug 1770750).
3497       this.data.fieldValue = [];
3498       const ii = this.data.options.length;
3499       for (const i of this.indices) {
3500         if (Number.isInteger(i) && i >= 0 && i < ii) {
3501           this.data.fieldValue.push(this.data.options[i].exportValue);
3502         }
3503       }
3504     }
3505 
3506     // Process field flags for the display layer.
3507     this.data.combo = this.hasFieldFlag(AnnotationFieldFlag.COMBO);
3508     this.data.multiSelect = this.hasFieldFlag(AnnotationFieldFlag.MULTISELECT);
3509     this._hasText = true;
3510   }
3511 
3512   getFieldObject() {
3513     const type = this.data.combo ? "combobox" : "listbox";
3514     const value =
3515       this.data.fieldValue.length > 0 ? this.data.fieldValue[0] : null;
3516     return {
3517       id: this.data.id,
3518       value,
3519       defaultValue: this.data.defaultFieldValue,
3520       editable: !this.data.readOnly,
3521       name: this.data.fieldName,
3522       rect: this.data.rect,
3523       numItems: this.data.fieldValue.length,
3524       multipleSelection: this.data.multiSelect,
3525       hidden: this.data.hidden,
3526       actions: this.data.actions,
3527       items: this.data.options,
3528       page: this.data.pageIndex,
3529       strokeColor: this.data.borderColor,
3530       fillColor: this.data.backgroundColor,
3531       rotation: this.rotation,
3532       type,
3533     };
3534   }
3535 
3536   amendSavedDict(annotationStorage, dict) {
3537     if (!this.hasIndices) {
3538       return;
3539     }
3540     let values = annotationStorage?.get(this.data.id)?.value;
3541     if (!Array.isArray(values)) {
3542       values = [values];
3543     }
3544     const indices = [];
3545     const { options } = this.data;
3546     for (let i = 0, j = 0, ii = options.length; i < ii; i++) {
3547       if (options[i].exportValue === values[j]) {
3548         indices.push(i);
3549         j += 1;
3550       }
3551     }
3552     dict.set("I", indices);
3553   }
3554 
3555   async _getAppearance(evaluator, task, intent, annotationStorage) {
3556     if (this.data.combo) {
3557       return super._getAppearance(evaluator, task, intent, annotationStorage);
3558     }
3559 
3560     let exportedValue, rotation;
3561     const storageEntry = annotationStorage?.get(this.data.id);
3562     if (storageEntry) {
3563       rotation = storageEntry.rotation;
3564       exportedValue = storageEntry.value;
3565     }
3566 
3567     if (
3568       rotation === undefined &&
3569       exportedValue === undefined &&
3570       !this._needAppearances
3571     ) {
3572       // The annotation hasn't been rendered so use the appearance
3573       return null;
3574     }
3575 
3576     if (exportedValue === undefined) {
3577       exportedValue = this.data.fieldValue;
3578     } else if (!Array.isArray(exportedValue)) {
3579       exportedValue = [exportedValue];
3580     }
3581 
3582     const defaultPadding = 1;
3583     const defaultHPadding = 2;
3584     let totalHeight = this.data.rect[3] - this.data.rect[1];
3585     let totalWidth = this.data.rect[2] - this.data.rect[0];
3586 
3587     if (rotation === 90 || rotation === 270) {
3588       [totalWidth, totalHeight] = [totalHeight, totalWidth];
3589     }
3590 
3591     const lineCount = this.data.options.length;
3592     const valueIndices = [];
3593     for (let i = 0; i < lineCount; i++) {
3594       const { exportValue } = this.data.options[i];
3595       if (exportedValue.includes(exportValue)) {
3596         valueIndices.push(i);
3597       }
3598     }
3599 
3600     if (!this._defaultAppearance) {
3601       // The DA is required and must be a string.
3602       // If there is no font named Helvetica in the resource dictionary,
3603       // the evaluator will fall back to a default font.
3604       // Doing so prevents exceptions and allows saving/printing
3605       // the file as expected.
3606       this.data.defaultAppearanceData = parseDefaultAppearance(
3607         (this._defaultAppearance = "/Helvetica 0 Tf 0 g")
3608       );
3609     }
3610 
3611     const font = await WidgetAnnotation._getFontData(
3612       evaluator,
3613       task,
3614       this.data.defaultAppearanceData,
3615       this._fieldResources.mergedResources
3616     );
3617 
3618     let defaultAppearance;
3619     let { fontSize } = this.data.defaultAppearanceData;
3620     if (!fontSize) {
3621       const lineHeight = (totalHeight - defaultPadding) / lineCount;
3622       let lineWidth = -1;
3623       let value;
3624       for (const { displayValue } of this.data.options) {
3625         const width = this._getTextWidth(displayValue, font);
3626         if (width > lineWidth) {
3627           lineWidth = width;
3628           value = displayValue;
3629         }
3630       }
3631 
3632       [defaultAppearance, fontSize] = this._computeFontSize(
3633         lineHeight,
3634         totalWidth - 2 * defaultHPadding,
3635         value,
3636         font,
3637         -1
3638       );
3639     } else {
3640       defaultAppearance = this._defaultAppearance;
3641     }
3642 
3643     const lineHeight = fontSize * LINE_FACTOR;
3644     const vPadding = (lineHeight - fontSize) / 2;
3645     const numberOfVisibleLines = Math.floor(totalHeight / lineHeight);
3646 
3647     let firstIndex = 0;
3648     if (valueIndices.length > 0) {
3649       const minIndex = Math.min(...valueIndices);
3650       const maxIndex = Math.max(...valueIndices);
3651 
3652       firstIndex = Math.max(0, maxIndex - numberOfVisibleLines + 1);
3653       if (firstIndex > minIndex) {
3654         firstIndex = minIndex;
3655       }
3656     }
3657     const end = Math.min(firstIndex + numberOfVisibleLines + 1, lineCount);
3658 
3659     const buf = ["/Tx BMC q", `1 1 ${totalWidth} ${totalHeight} re W n`];
3660 
3661     if (valueIndices.length) {
3662       // This value has been copied/pasted from annotation-choice-widget.pdf.
3663       // It corresponds to rgb(153, 193, 218).
3664       buf.push("0.600006 0.756866 0.854904 rg");
3665 
3666       // Highlight the lines in filling a blue rectangle at the selected
3667       // positions.
3668       for (const index of valueIndices) {
3669         if (firstIndex <= index && index < end) {
3670           buf.push(
3671             `1 ${
3672               totalHeight - (index - firstIndex + 1) * lineHeight
3673             } ${totalWidth} ${lineHeight} re f`
3674           );
3675         }
3676       }
3677     }
3678     buf.push("BT", defaultAppearance, `1 0 0 1 0 ${totalHeight} Tm`);
3679 
3680     const prevInfo = { shift: 0 };
3681     for (let i = firstIndex; i < end; i++) {
3682       const { displayValue } = this.data.options[i];
3683       const vpadding = i === firstIndex ? vPadding : 0;
3684       buf.push(
3685         this._renderText(
3686           displayValue,
3687           font,
3688           fontSize,
3689           totalWidth,
3690           0,
3691           prevInfo,
3692           defaultHPadding,
3693           -lineHeight + vpadding
3694         )
3695       );
3696     }
3697 
3698     buf.push("ET Q EMC");
3699 
3700     return buf.join("\n");
3701   }
3702 }
3703 
3704 class SignatureWidgetAnnotation extends WidgetAnnotation {
3705   constructor(params) {
3706     super(params);
3707 
3708     // Unset the fieldValue since it's (most likely) a `Dict` which is
3709     // non-serializable and will thus cause errors when sending annotations
3710     // to the main-thread (issue 10347).
3711     this.data.fieldValue = null;
3712     this.data.hasOwnCanvas = this.data.noRotate;
3713     this.data.noHTML = !this.data.hasOwnCanvas;
3714   }
3715 
3716   getFieldObject() {
3717     return {
3718       id: this.data.id,
3719       value: null,
3720       page: this.data.pageIndex,
3721       type: "signature",
3722     };
3723   }
3724 }
3725 
3726 class TextAnnotation extends MarkupAnnotation {
3727   constructor(params) {
3728     const DEFAULT_ICON_SIZE = 22; // px
3729 
3730     super(params);
3731 
3732     // No rotation for Text (see 12.5.6.4).
3733     this.data.noRotate = true;
3734     this.data.hasOwnCanvas = this.data.noRotate;
3735     this.data.noHTML = false;
3736 
3737     const { dict } = params;
3738     this.data.annotationType = AnnotationType.TEXT;
3739 
3740     if (this.data.hasAppearance) {
3741       this.data.name = "NoIcon";
3742     } else {
3743       this.data.rect[1] = this.data.rect[3] - DEFAULT_ICON_SIZE;
3744       this.data.rect[2] = this.data.rect[0] + DEFAULT_ICON_SIZE;
3745       this.data.name = dict.has("Name") ? dict.get("Name").name : "Note";
3746     }
3747 
3748     if (dict.has("State")) {
3749       this.data.state = dict.get("State") || null;
3750       this.data.stateModel = dict.get("StateModel") || null;
3751     } else {
3752       this.data.state = null;
3753       this.data.stateModel = null;
3754     }
3755   }
3756 }
3757 
3758 class LinkAnnotation extends Annotation {
3759   constructor(params) {
3760     super(params);
3761 
3762     const { dict, annotationGlobals } = params;
3763     this.data.annotationType = AnnotationType.LINK;
3764 
3765     // A link is never rendered on the main canvas so we must render its HTML
3766     // version.
3767     this.data.noHTML = false;
3768 
3769     const quadPoints = getQuadPoints(dict, this.rectangle);
3770     if (quadPoints) {
3771       this.data.quadPoints = quadPoints;
3772     }
3773 
3774     // The color entry for a link annotation is the color of the border.
3775     this.data.borderColor ||= this.data.color;
3776 
3777     Catalog.parseDestDictionary({
3778       destDict: dict,
3779       resultObj: this.data,
3780       docBaseUrl: annotationGlobals.baseUrl,
3781       docAttachments: annotationGlobals.attachments,
3782     });
3783   }
3784 }
3785 
3786 class PopupAnnotation extends Annotation {
3787   constructor(params) {
3788     super(params);
3789 
3790     const { dict } = params;
3791     this.data.annotationType = AnnotationType.POPUP;
3792 
3793     // A pop-up is never rendered on the main canvas so we must render its HTML
3794     // version.
3795     this.data.noHTML = false;
3796 
3797     if (
3798       this.data.rect[0] === this.data.rect[2] ||
3799       this.data.rect[1] === this.data.rect[3]
3800     ) {
3801       this.data.rect = null;
3802     }
3803 
3804     let parentItem = dict.get("Parent");
3805     if (!parentItem) {
3806       warn("Popup annotation has a missing or invalid parent annotation.");
3807       return;
3808     }
3809     this.data.parentRect = lookupNormalRect(parentItem.getArray("Rect"), null);
3810 
3811     const rt = parentItem.get("RT");
3812     if (isName(rt, AnnotationReplyType.GROUP)) {
3813       // Subordinate annotations in a group should inherit
3814       // the group attributes from the primary annotation.
3815       parentItem = parentItem.get("IRT");
3816     }
3817 
3818     if (!parentItem.has("M")) {
3819       this.data.modificationDate = null;
3820     } else {
3821       this.setModificationDate(parentItem.get("M"));
3822       this.data.modificationDate = this.modificationDate;
3823     }
3824 
3825     if (!parentItem.has("C")) {
3826       // Fall back to the default background color.
3827       this.data.color = null;
3828     } else {
3829       this.setColor(parentItem.getArray("C"));
3830       this.data.color = this.color;
3831     }
3832 
3833     // If the Popup annotation is not viewable, but the parent annotation is,
3834     // that is most likely a bug. Fallback to inherit the flags from the parent
3835     // annotation (this is consistent with the behaviour in Adobe Reader).
3836     if (!this.viewable) {
3837       const parentFlags = parentItem.get("F");
3838       if (this._isViewable(parentFlags)) {
3839         this.setFlags(parentFlags);
3840       }
3841     }
3842 
3843     this.setTitle(parentItem.get("T"));
3844     this.data.titleObj = this._title;
3845 
3846     this.setContents(parentItem.get("Contents"));
3847     this.data.contentsObj = this._contents;
3848 
3849     if (parentItem.has("RC")) {
3850       this.data.richText = XFAFactory.getRichTextAsHtml(parentItem.get("RC"));
3851     }
3852 
3853     this.data.open = !!dict.get("Open");
3854   }
3855 }
3856 
3857 class FreeTextAnnotation extends MarkupAnnotation {
3858   constructor(params) {
3859     super(params);
3860 
3861     // It uses its own canvas in order to be hidden if edited.
3862     // But if it has the noHTML flag, it means that we don't want to be able
3863     // to modify it so we can just draw it on the main canvas.
3864     this.data.hasOwnCanvas = this.data.noRotate;
3865     this.data.isEditable = !this.data.noHTML;
3866     // We want to be able to add mouse listeners to the annotation.
3867     this.data.noHTML = false;
3868 
3869     const { evaluatorOptions, xref } = params;
3870     this.data.annotationType = AnnotationType.FREETEXT;
3871     this.setDefaultAppearance(params);
3872     this._hasAppearance = !!this.appearance;
3873 
3874     if (this._hasAppearance) {
3875       const { fontColor, fontSize } = parseAppearanceStream(
3876         this.appearance,
3877         evaluatorOptions,
3878         xref
3879       );
3880       this.data.defaultAppearanceData.fontColor = fontColor;
3881       this.data.defaultAppearanceData.fontSize = fontSize || 10;
3882     } else {
3883       this.data.defaultAppearanceData.fontSize ||= 10;
3884       const { fontColor, fontSize } = this.data.defaultAppearanceData;
3885       if (this._contents.str) {
3886         this.data.textContent = this._contents.str
3887           .split(/\r\n?|\n/)
3888           .map(line => line.trimEnd());
3889         const { coords, bbox, matrix } = FakeUnicodeFont.getFirstPositionInfo(
3890           this.rectangle,
3891           this.rotation,
3892           fontSize
3893         );
3894         this.data.textPosition = this._transformPoint(coords, bbox, matrix);
3895       }
3896       if (this._isOffscreenCanvasSupported) {
3897         const strokeAlpha = params.dict.get("CA");
3898         const fakeUnicodeFont = new FakeUnicodeFont(xref, "sans-serif");
3899         this.appearance = fakeUnicodeFont.createAppearance(
3900           this._contents.str,
3901           this.rectangle,
3902           this.rotation,
3903           fontSize,
3904           fontColor,
3905           strokeAlpha
3906         );
3907         this._streams.push(this.appearance);
3908       } else {
3909         warn(
3910           "FreeTextAnnotation: OffscreenCanvas is not supported, annotation may not render correctly."
3911         );
3912       }
3913     }
3914   }
3915 
3916   get hasTextContent() {
3917     return this._hasAppearance;
3918   }
3919 
3920   static createNewDict(annotation, xref, { apRef, ap }) {
3921     const { color, fontSize, oldAnnotation, rect, rotation, user, value } =
3922       annotation;
3923     const freetext = oldAnnotation || new Dict(xref);
3924     freetext.set("Type", Name.get("Annot"));
3925     freetext.set("Subtype", Name.get("FreeText"));
3926     if (oldAnnotation) {
3927       freetext.set("M", `D:${getModificationDate()}`);
3928       // TODO: We should try to generate a new RC from the content we've.
3929       // For now we can just remove it to avoid any issues.
3930       freetext.delete("RC");
3931     } else {
3932       freetext.set("CreationDate", `D:${getModificationDate()}`);
3933     }
3934     freetext.set("Rect", rect);
3935     const da = `/Helv ${fontSize} Tf ${getPdfColor(color, /* isFill */ true)}`;
3936     freetext.set("DA", da);
3937     freetext.set("Contents", stringToAsciiOrUTF16BE(value));
3938     freetext.set("F", 4);
3939     freetext.set("Border", [0, 0, 0]);
3940     freetext.set("Rotate", rotation);
3941 
3942     if (user) {
3943       freetext.set("T", stringToAsciiOrUTF16BE(user));
3944     }
3945 
3946     if (apRef || ap) {
3947       const n = new Dict(xref);
3948       freetext.set("AP", n);
3949 
3950       if (apRef) {
3951         n.set("N", apRef);
3952       } else {
3953         n.set("N", ap);
3954       }
3955     }
3956 
3957     return freetext;
3958   }
3959 
3960   static async createNewAppearanceStream(annotation, xref, params) {
3961     const { baseFontRef, evaluator, task } = params;
3962     const { color, fontSize, rect, rotation, value } = annotation;
3963 
3964     const resources = new Dict(xref);
3965     const font = new Dict(xref);
3966 
3967     if (baseFontRef) {
3968       font.set("Helv", baseFontRef);
3969     } else {
3970       const baseFont = new Dict(xref);
3971       baseFont.set("BaseFont", Name.get("Helvetica"));
3972       baseFont.set("Type", Name.get("Font"));
3973       baseFont.set("Subtype", Name.get("Type1"));
3974       baseFont.set("Encoding", Name.get("WinAnsiEncoding"));
3975       font.set("Helv", baseFont);
3976     }
3977     resources.set("Font", font);
3978 
3979     const helv = await WidgetAnnotation._getFontData(
3980       evaluator,
3981       task,
3982       {
3983         fontName: "Helv",
3984         fontSize,
3985       },
3986       resources
3987     );
3988 
3989     const [x1, y1, x2, y2] = rect;
3990     let w = x2 - x1;
3991     let h = y2 - y1;
3992 
3993     if (rotation % 180 !== 0) {
3994       [w, h] = [h, w];
3995     }
3996 
3997     const lines = value.split("\n");
3998     const scale = fontSize / 1000;
3999     let totalWidth = -Infinity;
4000     const encodedLines = [];
4001     for (let line of lines) {
4002       const encoded = helv.encodeString(line);
4003       if (encoded.length > 1) {
4004         // The font doesn't contain all the chars.
4005         return null;
4006       }
4007       line = encoded.join("");
4008       encodedLines.push(line);
4009       let lineWidth = 0;
4010       const glyphs = helv.charsToGlyphs(line);
4011       for (const glyph of glyphs) {
4012         lineWidth += glyph.width * scale;
4013       }
4014       totalWidth = Math.max(totalWidth, lineWidth);
4015     }
4016 
4017     let hscale = 1;
4018     if (totalWidth > w) {
4019       hscale = w / totalWidth;
4020     }
4021     let vscale = 1;
4022     const lineHeight = LINE_FACTOR * fontSize;
4023     const lineAscent = (LINE_FACTOR - LINE_DESCENT_FACTOR) * fontSize;
4024     const totalHeight = lineHeight * lines.length;
4025     if (totalHeight > h) {
4026       vscale = h / totalHeight;
4027     }
4028     const fscale = Math.min(hscale, vscale);
4029     const newFontSize = fontSize * fscale;
4030     let firstPoint, clipBox, matrix;
4031     switch (rotation) {
4032       case 0:
4033         matrix = [1, 0, 0, 1];
4034         clipBox = [rect[0], rect[1], w, h];
4035         firstPoint = [rect[0], rect[3] - lineAscent];
4036         break;
4037       case 90:
4038         matrix = [0, 1, -1, 0];
4039         clipBox = [rect[1], -rect[2], w, h];
4040         firstPoint = [rect[1], -rect[0] - lineAscent];
4041         break;
4042       case 180:
4043         matrix = [-1, 0, 0, -1];
4044         clipBox = [-rect[2], -rect[3], w, h];
4045         firstPoint = [-rect[2], -rect[1] - lineAscent];
4046         break;
4047       case 270:
4048         matrix = [0, -1, 1, 0];
4049         clipBox = [-rect[3], rect[0], w, h];
4050         firstPoint = [-rect[3], rect[2] - lineAscent];
4051         break;
4052     }
4053 
4054     const buffer = [
4055       "q",
4056       `${matrix.join(" ")} 0 0 cm`,
4057       `${clipBox.join(" ")} re W n`,
4058       `BT`,
4059       `${getPdfColor(color, /* isFill */ true)}`,
4060       `0 Tc /Helv ${numberToString(newFontSize)} Tf`,
4061     ];
4062 
4063     buffer.push(
4064       `${firstPoint.join(" ")} Td (${escapeString(encodedLines[0])}) Tj`
4065     );
4066     const vShift = numberToString(lineHeight);
4067     for (let i = 1, ii = encodedLines.length; i < ii; i++) {
4068       const line = encodedLines[i];
4069       buffer.push(`0 -${vShift} Td (${escapeString(line)}) Tj`);
4070     }
4071     buffer.push("ET", "Q");
4072     const appearance = buffer.join("\n");
4073 
4074     const appearanceStreamDict = new Dict(xref);
4075     appearanceStreamDict.set("FormType", 1);
4076     appearanceStreamDict.set("Subtype", Name.get("Form"));
4077     appearanceStreamDict.set("Type", Name.get("XObject"));
4078     appearanceStreamDict.set("BBox", rect);
4079     appearanceStreamDict.set("Resources", resources);
4080     appearanceStreamDict.set("Matrix", [1, 0, 0, 1, -rect[0], -rect[1]]);
4081 
4082     const ap = new StringStream(appearance);
4083     ap.dict = appearanceStreamDict;
4084 
4085     return ap;
4086   }
4087 }
4088 
4089 class LineAnnotation extends MarkupAnnotation {
4090   constructor(params) {
4091     super(params);
4092 
4093     const { dict, xref } = params;
4094     this.data.annotationType = AnnotationType.LINE;
4095     this.data.hasOwnCanvas = this.data.noRotate;
4096     this.data.noHTML = false;
4097 
4098     const lineCoordinates = lookupRect(dict.getArray("L"), [0, 0, 0, 0]);
4099     this.data.lineCoordinates = Util.normalizeRect(lineCoordinates);
4100 
4101     if (typeof PDFJSDev === "undefined" || !PDFJSDev.test("MOZCENTRAL")) {
4102       this.setLineEndings(dict.getArray("LE"));
4103       this.data.lineEndings = this.lineEndings;
4104     }
4105 
4106     if (!this.appearance) {
4107       // The default stroke color is black.
4108       const strokeColor = this.color ? getPdfColorArray(this.color) : [0, 0, 0];
4109       const strokeAlpha = dict.get("CA");
4110 
4111       const interiorColor = getRgbColor(dict.getArray("IC"), null);
4112       // The default fill color is transparent. Setting the fill colour is
4113       // necessary if/when we want to add support for non-default line endings.
4114       const fillColor = interiorColor ? getPdfColorArray(interiorColor) : null;
4115       const fillAlpha = fillColor ? strokeAlpha : null;
4116 
4117       const borderWidth = this.borderStyle.width || 1,
4118         borderAdjust = 2 * borderWidth;
4119 
4120       // If the /Rect-entry is empty/wrong, create a fallback rectangle so that
4121       // we get similar rendering/highlighting behaviour as in Adobe Reader.
4122       const bbox = [
4123         this.data.lineCoordinates[0] - borderAdjust,
4124         this.data.lineCoordinates[1] - borderAdjust,
4125         this.data.lineCoordinates[2] + borderAdjust,
4126         this.data.lineCoordinates[3] + borderAdjust,
4127       ];
4128       if (!Util.intersect(this.rectangle, bbox)) {
4129         this.rectangle = bbox;
4130       }
4131 
4132       this._setDefaultAppearance({
4133         xref,
4134         extra: `${borderWidth} w`,
4135         strokeColor,
4136         fillColor,
4137         strokeAlpha,
4138         fillAlpha,
4139         pointsCallback: (buffer, points) => {
4140           buffer.push(
4141             `${lineCoordinates[0]} ${lineCoordinates[1]} m`,
4142             `${lineCoordinates[2]} ${lineCoordinates[3]} l`,
4143             "S"
4144           );
4145           return [
4146             points[0] - borderWidth,
4147             points[2] + borderWidth,
4148             points[7] - borderWidth,
4149             points[3] + borderWidth,
4150           ];
4151         },
4152       });
4153     }
4154   }
4155 }
4156 
4157 class SquareAnnotation extends MarkupAnnotation {
4158   constructor(params) {
4159     super(params);
4160 
4161     const { dict, xref } = params;
4162     this.data.annotationType = AnnotationType.SQUARE;
4163     this.data.hasOwnCanvas = this.data.noRotate;
4164     this.data.noHTML = false;
4165 
4166     if (!this.appearance) {
4167       // The default stroke color is black.
4168       const strokeColor = this.color ? getPdfColorArray(this.color) : [0, 0, 0];
4169       const strokeAlpha = dict.get("CA");
4170 
4171       const interiorColor = getRgbColor(dict.getArray("IC"), null);
4172       // The default fill color is transparent.
4173       const fillColor = interiorColor ? getPdfColorArray(interiorColor) : null;
4174       const fillAlpha = fillColor ? strokeAlpha : null;
4175 
4176       if (this.borderStyle.width === 0 && !fillColor) {
4177         // Prevent rendering a "hairline" border (fixes issue14164.pdf).
4178         return;
4179       }
4180 
4181       this._setDefaultAppearance({
4182         xref,
4183         extra: `${this.borderStyle.width} w`,
4184         strokeColor,
4185         fillColor,
4186         strokeAlpha,
4187         fillAlpha,
4188         pointsCallback: (buffer, points) => {
4189           const x = points[4] + this.borderStyle.width / 2;
4190           const y = points[5] + this.borderStyle.width / 2;
4191           const width = points[6] - points[4] - this.borderStyle.width;
4192           const height = points[3] - points[7] - this.borderStyle.width;
4193           buffer.push(`${x} ${y} ${width} ${height} re`);
4194           if (fillColor) {
4195             buffer.push("B");
4196           } else {
4197             buffer.push("S");
4198           }
4199           return [points[0], points[2], points[7], points[3]];
4200         },
4201       });
4202     }
4203   }
4204 }
4205 
4206 class CircleAnnotation extends MarkupAnnotation {
4207   constructor(params) {
4208     super(params);
4209 
4210     const { dict, xref } = params;
4211     this.data.annotationType = AnnotationType.CIRCLE;
4212 
4213     if (!this.appearance) {
4214       // The default stroke color is black.
4215       const strokeColor = this.color ? getPdfColorArray(this.color) : [0, 0, 0];
4216       const strokeAlpha = dict.get("CA");
4217 
4218       const interiorColor = getRgbColor(dict.getArray("IC"), null);
4219       // The default fill color is transparent.
4220       const fillColor = interiorColor ? getPdfColorArray(interiorColor) : null;
4221       const fillAlpha = fillColor ? strokeAlpha : null;
4222 
4223       if (this.borderStyle.width === 0 && !fillColor) {
4224         // Prevent rendering a "hairline" border (fixes issue14164.pdf).
4225         return;
4226       }
4227 
4228       // Circles are approximated by Bézier curves with four segments since
4229       // there is no circle primitive in the PDF specification. For the control
4230       // points distance, see https://stackoverflow.com/a/27863181.
4231       const controlPointsDistance = (4 / 3) * Math.tan(Math.PI / (2 * 4));
4232 
4233       this._setDefaultAppearance({
4234         xref,
4235         extra: `${this.borderStyle.width} w`,
4236         strokeColor,
4237         fillColor,
4238         strokeAlpha,
4239         fillAlpha,
4240         pointsCallback: (buffer, points) => {
4241           const x0 = points[0] + this.borderStyle.width / 2;
4242           const y0 = points[1] - this.borderStyle.width / 2;
4243           const x1 = points[6] - this.borderStyle.width / 2;
4244           const y1 = points[7] + this.borderStyle.width / 2;
4245           const xMid = x0 + (x1 - x0) / 2;
4246           const yMid = y0 + (y1 - y0) / 2;
4247           const xOffset = ((x1 - x0) / 2) * controlPointsDistance;
4248           const yOffset = ((y1 - y0) / 2) * controlPointsDistance;
4249 
4250           buffer.push(
4251             `${xMid} ${y1} m`,
4252             `${xMid + xOffset} ${y1} ${x1} ${yMid + yOffset} ${x1} ${yMid} c`,
4253             `${x1} ${yMid - yOffset} ${xMid + xOffset} ${y0} ${xMid} ${y0} c`,
4254             `${xMid - xOffset} ${y0} ${x0} ${yMid - yOffset} ${x0} ${yMid} c`,
4255             `${x0} ${yMid + yOffset} ${xMid - xOffset} ${y1} ${xMid} ${y1} c`,
4256             "h"
4257           );
4258           if (fillColor) {
4259             buffer.push("B");
4260           } else {
4261             buffer.push("S");
4262           }
4263           return [points[0], points[2], points[7], points[3]];
4264         },
4265       });
4266     }
4267   }
4268 }
4269 
4270 class PolylineAnnotation extends MarkupAnnotation {
4271   constructor(params) {
4272     super(params);
4273 
4274     const { dict, xref } = params;
4275     this.data.annotationType = AnnotationType.POLYLINE;
4276     this.data.hasOwnCanvas = this.data.noRotate;
4277     this.data.noHTML = false;
4278     this.data.vertices = null;
4279 
4280     if (
4281       (typeof PDFJSDev === "undefined" || !PDFJSDev.test("MOZCENTRAL")) &&
4282       !(this instanceof PolygonAnnotation)
4283     ) {
4284       // Only meaningful for polyline annotations.
4285       this.setLineEndings(dict.getArray("LE"));
4286       this.data.lineEndings = this.lineEndings;
4287     }
4288 
4289     // The vertices array is an array of numbers representing the alternating
4290     // horizontal and vertical coordinates, respectively, of each vertex.
4291     // Convert this to an array of objects with x and y coordinates.
4292     const rawVertices = dict.getArray("Vertices");
4293     if (!isNumberArray(rawVertices, null)) {
4294       return;
4295     }
4296     const vertices = (this.data.vertices = Float32Array.from(rawVertices));
4297 
4298     if (!this.appearance) {
4299       // The default stroke color is black.
4300       const strokeColor = this.color ? getPdfColorArray(this.color) : [0, 0, 0];
4301       const strokeAlpha = dict.get("CA");
4302 
4303       const borderWidth = this.borderStyle.width || 1,
4304         borderAdjust = 2 * borderWidth;
4305 
4306       // If the /Rect-entry is empty/wrong, create a fallback rectangle so that
4307       // we get similar rendering/highlighting behaviour as in Adobe Reader.
4308       const bbox = [Infinity, Infinity, -Infinity, -Infinity];
4309       for (let i = 0, ii = vertices.length; i < ii; i += 2) {
4310         bbox[0] = Math.min(bbox[0], vertices[i] - borderAdjust);
4311         bbox[1] = Math.min(bbox[1], vertices[i + 1] - borderAdjust);
4312         bbox[2] = Math.max(bbox[2], vertices[i] + borderAdjust);
4313         bbox[3] = Math.max(bbox[3], vertices[i + 1] + borderAdjust);
4314       }
4315       if (!Util.intersect(this.rectangle, bbox)) {
4316         this.rectangle = bbox;
4317       }
4318 
4319       this._setDefaultAppearance({
4320         xref,
4321         extra: `${borderWidth} w`,
4322         strokeColor,
4323         strokeAlpha,
4324         pointsCallback: (buffer, points) => {
4325           for (let i = 0, ii = vertices.length; i < ii; i += 2) {
4326             buffer.push(
4327               `${vertices[i]} ${vertices[i + 1]} ${i === 0 ? "m" : "l"}`
4328             );
4329           }
4330           buffer.push("S");
4331           return [points[0], points[2], points[7], points[3]];
4332         },
4333       });
4334     }
4335   }
4336 }
4337 
4338 class PolygonAnnotation extends PolylineAnnotation {
4339   constructor(params) {
4340     // Polygons are specific forms of polylines, so reuse their logic.
4341     super(params);
4342 
4343     this.data.annotationType = AnnotationType.POLYGON;
4344   }
4345 }
4346 
4347 class CaretAnnotation extends MarkupAnnotation {
4348   constructor(params) {
4349     super(params);
4350 
4351     this.data.annotationType = AnnotationType.CARET;
4352   }
4353 }
4354 
4355 class InkAnnotation extends MarkupAnnotation {
4356   constructor(params) {
4357     super(params);
4358 
4359     this.data.hasOwnCanvas = this.data.noRotate;
4360     this.data.noHTML = false;
4361 
4362     const { dict, xref } = params;
4363     this.data.annotationType = AnnotationType.INK;
4364     this.data.inkLists = [];
4365     this.data.isEditable = !this.data.noHTML && this.data.it === "InkHighlight";
4366     // We want to be able to add mouse listeners to the annotation.
4367     this.data.noHTML = false;
4368     this.data.opacity = dict.get("CA") || 1;
4369 
4370     const rawInkLists = dict.getArray("InkList");
4371     if (!Array.isArray(rawInkLists)) {
4372       return;
4373     }
4374     for (let i = 0, ii = rawInkLists.length; i < ii; ++i) {
4375       // The raw ink lists array contains arrays of numbers representing
4376       // the alternating horizontal and vertical coordinates, respectively,
4377       // of each vertex. Convert this to an array of objects with x and y
4378       // coordinates.
4379       if (!Array.isArray(rawInkLists[i])) {
4380         continue;
4381       }
4382       const inkList = new Float32Array(rawInkLists[i].length);
4383       this.data.inkLists.push(inkList);
4384       for (let j = 0, jj = rawInkLists[i].length; j < jj; j += 2) {
4385         const x = xref.fetchIfRef(rawInkLists[i][j]),
4386           y = xref.fetchIfRef(rawInkLists[i][j + 1]);
4387         if (typeof x === "number" && typeof y === "number") {
4388           inkList[j] = x;
4389           inkList[j + 1] = y;
4390         }
4391       }
4392     }
4393 
4394     if (!this.appearance) {
4395       // The default stroke color is black.
4396       const strokeColor = this.color ? getPdfColorArray(this.color) : [0, 0, 0];
4397       const strokeAlpha = dict.get("CA");
4398 
4399       const borderWidth = this.borderStyle.width || 1,
4400         borderAdjust = 2 * borderWidth;
4401 
4402       // If the /Rect-entry is empty/wrong, create a fallback rectangle so that
4403       // we get similar rendering/highlighting behaviour as in Adobe Reader.
4404       const bbox = [Infinity, Infinity, -Infinity, -Infinity];
4405       for (const inkList of this.data.inkLists) {
4406         for (let i = 0, ii = inkList.length; i < ii; i += 2) {
4407           bbox[0] = Math.min(bbox[0], inkList[i] - borderAdjust);
4408           bbox[1] = Math.min(bbox[1], inkList[i + 1] - borderAdjust);
4409           bbox[2] = Math.max(bbox[2], inkList[i] + borderAdjust);
4410           bbox[3] = Math.max(bbox[3], inkList[i + 1] + borderAdjust);
4411         }
4412       }
4413       if (!Util.intersect(this.rectangle, bbox)) {
4414         this.rectangle = bbox;
4415       }
4416 
4417       this._setDefaultAppearance({
4418         xref,
4419         extra: `${borderWidth} w`,
4420         strokeColor,
4421         strokeAlpha,
4422         pointsCallback: (buffer, points) => {
4423           // According to the specification, see "12.5.6.13 Ink Annotations":
4424           //   When drawn, the points shall be connected by straight lines or
4425           //   curves in an implementation-dependent way.
4426           // In order to simplify things, we utilize straight lines for now.
4427           for (const inkList of this.data.inkLists) {
4428             for (let i = 0, ii = inkList.length; i < ii; i += 2) {
4429               buffer.push(
4430                 `${inkList[i]} ${inkList[i + 1]} ${i === 0 ? "m" : "l"}`
4431               );
4432             }
4433             buffer.push("S");
4434           }
4435           return [points[0], points[2], points[7], points[3]];
4436         },
4437       });
4438     }
4439   }
4440 
4441   static createNewDict(annotation, xref, { apRef, ap }) {
4442     const { color, opacity, paths, outlines, rect, rotation, thickness } =
4443       annotation;
4444     const ink = new Dict(xref);
4445     ink.set("Type", Name.get("Annot"));
4446     ink.set("Subtype", Name.get("Ink"));
4447     ink.set("CreationDate", `D:${getModificationDate()}`);
4448     ink.set("Rect", rect);
4449     ink.set("InkList", outlines?.points || paths.map(p => p.points));
4450     ink.set("F", 4);
4451     ink.set("Rotate", rotation);
4452 
4453     if (outlines) {
4454       // Free highlight.
4455       // There's nothing about this in the spec, but it's used when highlighting
4456       // in Edge's viewer. Acrobat takes into account this parameter to indicate
4457       // that the Ink is used for highlighting.
4458       ink.set("IT", Name.get("InkHighlight"));
4459     }
4460 
4461     // Line thickness.
4462     const bs = new Dict(xref);
4463     ink.set("BS", bs);
4464     bs.set("W", thickness);
4465 
4466     // Color.
4467     ink.set(
4468       "C",
4469       Array.from(color, c => c / 255)
4470     );
4471 
4472     // Opacity.
4473     ink.set("CA", opacity);
4474 
4475     const n = new Dict(xref);
4476     ink.set("AP", n);
4477 
4478     if (apRef) {
4479       n.set("N", apRef);
4480     } else {
4481       n.set("N", ap);
4482     }
4483 
4484     return ink;
4485   }
4486 
4487   static async createNewAppearanceStream(annotation, xref, params) {
4488     if (annotation.outlines) {
4489       return this.createNewAppearanceStreamForHighlight(
4490         annotation,
4491         xref,
4492         params
4493       );
4494     }
4495     const { color, rect, paths, thickness, opacity } = annotation;
4496 
4497     const appearanceBuffer = [
4498       `${thickness} w 1 J 1 j`,
4499       `${getPdfColor(color, /* isFill */ false)}`,
4500     ];
4501 
4502     if (opacity !== 1) {
4503       appearanceBuffer.push("/R0 gs");
4504     }
4505 
4506     const buffer = [];
4507     for (const { bezier } of paths) {
4508       buffer.length = 0;
4509       buffer.push(
4510         `${numberToString(bezier[0])} ${numberToString(bezier[1])} m`
4511       );
4512       if (bezier.length === 2) {
4513         buffer.push(
4514           `${numberToString(bezier[0])} ${numberToString(bezier[1])} l S`
4515         );
4516       } else {
4517         for (let i = 2, ii = bezier.length; i < ii; i += 6) {
4518           const curve = bezier
4519             .slice(i, i + 6)
4520             .map(numberToString)
4521             .join(" ");
4522           buffer.push(`${curve} c`);
4523         }
4524         buffer.push("S");
4525       }
4526       appearanceBuffer.push(buffer.join("\n"));
4527     }
4528     const appearance = appearanceBuffer.join("\n");
4529 
4530     const appearanceStreamDict = new Dict(xref);
4531     appearanceStreamDict.set("FormType", 1);
4532     appearanceStreamDict.set("Subtype", Name.get("Form"));
4533     appearanceStreamDict.set("Type", Name.get("XObject"));
4534     appearanceStreamDict.set("BBox", rect);
4535     appearanceStreamDict.set("Length", appearance.length);
4536 
4537     if (opacity !== 1) {
4538       const resources = new Dict(xref);
4539       const extGState = new Dict(xref);
4540       const r0 = new Dict(xref);
4541       r0.set("CA", opacity);
4542       r0.set("Type", Name.get("ExtGState"));
4543       extGState.set("R0", r0);
4544       resources.set("ExtGState", extGState);
4545       appearanceStreamDict.set("Resources", resources);
4546     }
4547 
4548     const ap = new StringStream(appearance);
4549     ap.dict = appearanceStreamDict;
4550 
4551     return ap;
4552   }
4553 
4554   static async createNewAppearanceStreamForHighlight(annotation, xref, params) {
4555     const {
4556       color,
4557       rect,
4558       outlines: { outline },
4559       opacity,
4560     } = annotation;
4561     const appearanceBuffer = [
4562       `${getPdfColor(color, /* isFill */ true)}`,
4563       "/R0 gs",
4564     ];
4565 
4566     appearanceBuffer.push(
4567       `${numberToString(outline[4])} ${numberToString(outline[5])} m`
4568     );
4569     for (let i = 6, ii = outline.length; i < ii; i += 6) {
4570       if (isNaN(outline[i]) || outline[i] === null) {
4571         appearanceBuffer.push(
4572           `${numberToString(outline[i + 4])} ${numberToString(
4573             outline[i + 5]
4574           )} l`
4575         );
4576       } else {
4577         const curve = outline
4578           .slice(i, i + 6)
4579           .map(numberToString)
4580           .join(" ");
4581         appearanceBuffer.push(`${curve} c`);
4582       }
4583     }
4584     appearanceBuffer.push("h f");
4585     const appearance = appearanceBuffer.join("\n");
4586 
4587     const appearanceStreamDict = new Dict(xref);
4588     appearanceStreamDict.set("FormType", 1);
4589     appearanceStreamDict.set("Subtype", Name.get("Form"));
4590     appearanceStreamDict.set("Type", Name.get("XObject"));
4591     appearanceStreamDict.set("BBox", rect);
4592     appearanceStreamDict.set("Length", appearance.length);
4593 
4594     const resources = new Dict(xref);
4595     const extGState = new Dict(xref);
4596     resources.set("ExtGState", extGState);
4597     appearanceStreamDict.set("Resources", resources);
4598     const r0 = new Dict(xref);
4599     extGState.set("R0", r0);
4600     r0.set("BM", Name.get("Multiply"));
4601 
4602     if (opacity !== 1) {
4603       r0.set("ca", opacity);
4604       r0.set("Type", Name.get("ExtGState"));
4605     }
4606 
4607     const ap = new StringStream(appearance);
4608     ap.dict = appearanceStreamDict;
4609 
4610     return ap;
4611   }
4612 }
4613 
4614 class HighlightAnnotation extends MarkupAnnotation {
4615   constructor(params) {
4616     super(params);
4617 
4618     const { dict, xref } = params;
4619     this.data.annotationType = AnnotationType.HIGHLIGHT;
4620     this.data.isEditable = !this.data.noHTML;
4621     // We want to be able to add mouse listeners to the annotation.
4622     this.data.noHTML = false;
4623     this.data.opacity = dict.get("CA") || 1;
4624 
4625     const quadPoints = (this.data.quadPoints = getQuadPoints(dict, null));
4626     if (quadPoints) {
4627       const resources = this.appearance?.dict.get("Resources");
4628 
4629       if (!this.appearance || !resources?.has("ExtGState")) {
4630         if (this.appearance) {
4631           // Workaround for cases where there's no /ExtGState-entry directly
4632           // available, e.g. when the appearance stream contains a /XObject of
4633           // the /Form-type, since that causes the highlighting to completely
4634           // obscure the PDF content below it (fixes issue13242.pdf).
4635           warn("HighlightAnnotation - ignoring built-in appearance stream.");
4636         }
4637         // Default color is yellow in Acrobat Reader
4638         const fillColor = this.color ? getPdfColorArray(this.color) : [1, 1, 0];
4639         const fillAlpha = dict.get("CA");
4640 
4641         this._setDefaultAppearance({
4642           xref,
4643           fillColor,
4644           blendMode: "Multiply",
4645           fillAlpha,
4646           pointsCallback: (buffer, points) => {
4647             buffer.push(
4648               `${points[0]} ${points[1]} m`,
4649               `${points[2]} ${points[3]} l`,
4650               `${points[6]} ${points[7]} l`,
4651               `${points[4]} ${points[5]} l`,
4652               "f"
4653             );
4654             return [points[0], points[2], points[7], points[3]];
4655           },
4656         });
4657       }
4658     } else {
4659       this.data.popupRef = null;
4660     }
4661   }
4662 
4663   static createNewDict(annotation, xref, { apRef, ap }) {
4664     const { color, oldAnnotation, opacity, rect, rotation, user, quadPoints } =
4665       annotation;
4666     const highlight = oldAnnotation || new Dict(xref);
4667     highlight.set("Type", Name.get("Annot"));
4668     highlight.set("Subtype", Name.get("Highlight"));
4669     highlight.set(
4670       oldAnnotation ? "M" : "CreationDate",
4671       `D:${getModificationDate()}`
4672     );
4673     highlight.set("CreationDate", `D:${getModificationDate()}`);
4674     highlight.set("Rect", rect);
4675     highlight.set("F", 4);
4676     highlight.set("Border", [0, 0, 0]);
4677     highlight.set("Rotate", rotation);
4678     highlight.set("QuadPoints", quadPoints);
4679 
4680     // Color.
4681     highlight.set(
4682       "C",
4683       Array.from(color, c => c / 255)
4684     );
4685 
4686     // Opacity.
4687     highlight.set("CA", opacity);
4688 
4689     if (user) {
4690       highlight.set("T", stringToAsciiOrUTF16BE(user));
4691     }
4692 
4693     if (apRef || ap) {
4694       const n = new Dict(xref);
4695       highlight.set("AP", n);
4696       n.set("N", apRef || ap);
4697     }
4698 
4699     return highlight;
4700   }
4701 
4702   static async createNewAppearanceStream(annotation, xref, params) {
4703     const { color, rect, outlines, opacity } = annotation;
4704 
4705     const appearanceBuffer = [
4706       `${getPdfColor(color, /* isFill */ true)}`,
4707       "/R0 gs",
4708     ];
4709 
4710     const buffer = [];
4711     for (const outline of outlines) {
4712       buffer.length = 0;
4713       buffer.push(
4714         `${numberToString(outline[0])} ${numberToString(outline[1])} m`
4715       );
4716       for (let i = 2, ii = outline.length; i < ii; i += 2) {
4717         buffer.push(
4718           `${numberToString(outline[i])} ${numberToString(outline[i + 1])} l`
4719         );
4720       }
4721       buffer.push("h");
4722       appearanceBuffer.push(buffer.join("\n"));
4723     }
4724     appearanceBuffer.push("f*");
4725     const appearance = appearanceBuffer.join("\n");
4726 
4727     const appearanceStreamDict = new Dict(xref);
4728     appearanceStreamDict.set("FormType", 1);
4729     appearanceStreamDict.set("Subtype", Name.get("Form"));
4730     appearanceStreamDict.set("Type", Name.get("XObject"));
4731     appearanceStreamDict.set("BBox", rect);
4732     appearanceStreamDict.set("Length", appearance.length);
4733 
4734     const resources = new Dict(xref);
4735     const extGState = new Dict(xref);
4736     resources.set("ExtGState", extGState);
4737     appearanceStreamDict.set("Resources", resources);
4738     const r0 = new Dict(xref);
4739     extGState.set("R0", r0);
4740     r0.set("BM", Name.get("Multiply"));
4741 
4742     if (opacity !== 1) {
4743       r0.set("ca", opacity);
4744       r0.set("Type", Name.get("ExtGState"));
4745     }
4746 
4747     const ap = new StringStream(appearance);
4748     ap.dict = appearanceStreamDict;
4749 
4750     return ap;
4751   }
4752 }
4753 
4754 class UnderlineAnnotation extends MarkupAnnotation {
4755   constructor(params) {
4756     super(params);
4757 
4758     const { dict, xref } = params;
4759     this.data.annotationType = AnnotationType.UNDERLINE;
4760 
4761     const quadPoints = (this.data.quadPoints = getQuadPoints(dict, null));
4762     if (quadPoints) {
4763       if (!this.appearance) {
4764         // Default color is black
4765         const strokeColor = this.color
4766           ? getPdfColorArray(this.color)
4767           : [0, 0, 0];
4768         const strokeAlpha = dict.get("CA");
4769 
4770         // The values 0.571 and 1.3 below corresponds to what Acrobat is doing.
4771         this._setDefaultAppearance({
4772           xref,
4773           extra: "[] 0 d 0.571 w",
4774           strokeColor,
4775           strokeAlpha,
4776           pointsCallback: (buffer, points) => {
4777             buffer.push(
4778               `${points[4]} ${points[5] + 1.3} m`,
4779               `${points[6]} ${points[7] + 1.3} l`,
4780               "S"
4781             );
4782             return [points[0], points[2], points[7], points[3]];
4783           },
4784         });
4785       }
4786     } else {
4787       this.data.popupRef = null;
4788     }
4789   }
4790 }
4791 
4792 class SquigglyAnnotation extends MarkupAnnotation {
4793   constructor(params) {
4794     super(params);
4795 
4796     const { dict, xref } = params;
4797     this.data.annotationType = AnnotationType.SQUIGGLY;
4798 
4799     const quadPoints = (this.data.quadPoints = getQuadPoints(dict, null));
4800     if (quadPoints) {
4801       if (!this.appearance) {
4802         // Default color is black
4803         const strokeColor = this.color
4804           ? getPdfColorArray(this.color)
4805           : [0, 0, 0];
4806         const strokeAlpha = dict.get("CA");
4807 
4808         this._setDefaultAppearance({
4809           xref,
4810           extra: "[] 0 d 1 w",
4811           strokeColor,
4812           strokeAlpha,
4813           pointsCallback: (buffer, points) => {
4814             const dy = (points[1] - points[5]) / 6;
4815             let shift = dy;
4816             let x = points[4];
4817             const y = points[5];
4818             const xEnd = points[6];
4819             buffer.push(`${x} ${y + shift} m`);
4820             do {
4821               x += 2;
4822               shift = shift === 0 ? dy : 0;
4823               buffer.push(`${x} ${y + shift} l`);
4824             } while (x < xEnd);
4825             buffer.push("S");
4826             return [points[4], xEnd, y - 2 * dy, y + 2 * dy];
4827           },
4828         });
4829       }
4830     } else {
4831       this.data.popupRef = null;
4832     }
4833   }
4834 }
4835 
4836 class StrikeOutAnnotation extends MarkupAnnotation {
4837   constructor(params) {
4838     super(params);
4839 
4840     const { dict, xref } = params;
4841     this.data.annotationType = AnnotationType.STRIKEOUT;
4842 
4843     const quadPoints = (this.data.quadPoints = getQuadPoints(dict, null));
4844     if (quadPoints) {
4845       if (!this.appearance) {
4846         // Default color is black
4847         const strokeColor = this.color
4848           ? getPdfColorArray(this.color)
4849           : [0, 0, 0];
4850         const strokeAlpha = dict.get("CA");
4851 
4852         this._setDefaultAppearance({
4853           xref,
4854           extra: "[] 0 d 1 w",
4855           strokeColor,
4856           strokeAlpha,
4857           pointsCallback: (buffer, points) => {
4858             buffer.push(
4859               `${(points[0] + points[4]) / 2} ` +
4860                 `${(points[1] + points[5]) / 2} m`,
4861               `${(points[2] + points[6]) / 2} ` +
4862                 `${(points[3] + points[7]) / 2} l`,
4863               "S"
4864             );
4865             return [points[0], points[2], points[7], points[3]];
4866           },
4867         });
4868       }
4869     } else {
4870       this.data.popupRef = null;
4871     }
4872   }
4873 }
4874 
4875 class StampAnnotation extends MarkupAnnotation {
4876   #savedHasOwnCanvas;
4877 
4878   constructor(params) {
4879     super(params);
4880 
4881     this.data.annotationType = AnnotationType.STAMP;
4882     this.#savedHasOwnCanvas = this.data.hasOwnCanvas = this.data.noRotate;
4883     this.data.isEditable = !this.data.noHTML;
4884     // We want to be able to add mouse listeners to the annotation.
4885     this.data.noHTML = false;
4886   }
4887 
4888   mustBeViewedWhenEditing(isEditing, modifiedIds = null) {
4889     if (isEditing) {
4890       if (!this.data.isEditable) {
4891         return false;
4892       }
4893       // When we're editing, we want to ensure that the stamp annotation is
4894       // drawn on a canvas in order to use it in the annotation editor layer.
4895       this.#savedHasOwnCanvas = this.data.hasOwnCanvas;
4896       this.data.hasOwnCanvas = true;
4897       return true;
4898     }
4899     this.data.hasOwnCanvas = this.#savedHasOwnCanvas;
4900 
4901     return !modifiedIds?.has(this.data.id);
4902   }
4903 
4904   static async createImage(bitmap, xref) {
4905     // TODO: when printing, we could have a specific internal colorspace
4906     // (e.g. something like DeviceRGBA) in order avoid any conversion (i.e. no
4907     // jpeg, no rgba to rgb conversion, etc...)
4908 
4909     const { width, height } = bitmap;
4910     const canvas = new OffscreenCanvas(width, height);
4911     const ctx = canvas.getContext("2d", { alpha: true });
4912 
4913     // Draw the image and get the data in order to extract the transparency.
4914     ctx.drawImage(bitmap, 0, 0);
4915     const data = ctx.getImageData(0, 0, width, height).data;
4916     const buf32 = new Uint32Array(data.buffer);
4917     const hasAlpha = buf32.some(
4918       FeatureTest.isLittleEndian
4919         ? x => x >>> 24 !== 0xff
4920         : x => (x & 0xff) !== 0xff
4921     );
4922 
4923     if (hasAlpha) {
4924       // Redraw the image on a white background in order to remove the thin gray
4925       // line which can appear when exporting to jpeg.
4926       ctx.fillStyle = "white";
4927       ctx.fillRect(0, 0, width, height);
4928       ctx.drawImage(bitmap, 0, 0);
4929     }
4930 
4931     const jpegBufferPromise = canvas
4932       .convertToBlob({ type: "image/jpeg", quality: 1 })
4933       .then(blob => blob.arrayBuffer());
4934 
4935     const xobjectName = Name.get("XObject");
4936     const imageName = Name.get("Image");
4937     const image = new Dict(xref);
4938     image.set("Type", xobjectName);
4939     image.set("Subtype", imageName);
4940     image.set("BitsPerComponent", 8);
4941     image.set("ColorSpace", Name.get("DeviceRGB"));
4942     image.set("Filter", Name.get("DCTDecode"));
4943     image.set("BBox", [0, 0, width, height]);
4944     image.set("Width", width);
4945     image.set("Height", height);
4946 
4947     let smaskStream = null;
4948     if (hasAlpha) {
4949       const alphaBuffer = new Uint8Array(buf32.length);
4950       if (FeatureTest.isLittleEndian) {
4951         for (let i = 0, ii = buf32.length; i < ii; i++) {
4952           alphaBuffer[i] = buf32[i] >>> 24;
4953         }
4954       } else {
4955         for (let i = 0, ii = buf32.length; i < ii; i++) {
4956           alphaBuffer[i] = buf32[i] & 0xff;
4957         }
4958       }
4959 
4960       const smask = new Dict(xref);
4961       smask.set("Type", xobjectName);
4962       smask.set("Subtype", imageName);
4963       smask.set("BitsPerComponent", 8);
4964       smask.set("ColorSpace", Name.get("DeviceGray"));
4965       smask.set("Width", width);
4966       smask.set("Height", height);
4967 
4968       smaskStream = new Stream(alphaBuffer, 0, 0, smask);
4969     }
4970     const imageStream = new Stream(await jpegBufferPromise, 0, 0, image);
4971 
4972     return {
4973       imageStream,
4974       smaskStream,
4975       width,
4976       height,
4977     };
4978   }
4979 
4980   static createNewDict(annotation, xref, { apRef, ap }) {
4981     const { oldAnnotation, rect, rotation, user } = annotation;
4982     const stamp = oldAnnotation || new Dict(xref);
4983     stamp.set("Type", Name.get("Annot"));
4984     stamp.set("Subtype", Name.get("Stamp"));
4985     stamp.set(
4986       oldAnnotation ? "M" : "CreationDate",
4987       `D:${getModificationDate()}`
4988     );
4989     stamp.set("CreationDate", `D:${getModificationDate()}`);
4990     stamp.set("Rect", rect);
4991     stamp.set("F", 4);
4992     stamp.set("Border", [0, 0, 0]);
4993     stamp.set("Rotate", rotation);
4994 
4995     if (user) {
4996       stamp.set("T", stringToAsciiOrUTF16BE(user));
4997     }
4998 
4999     if (apRef || ap) {
5000       const n = new Dict(xref);
5001       stamp.set("AP", n);
5002 
5003       if (apRef) {
5004         n.set("N", apRef);
5005       } else {
5006         n.set("N", ap);
5007       }
5008     }
5009 
5010     return stamp;
5011   }
5012 
5013   static async createNewAppearanceStream(annotation, xref, params) {
5014     if (annotation.oldAnnotation) {
5015       // We'll use the AP we already have.
5016       return null;
5017     }
5018 
5019     const { rotation } = annotation;
5020     const { imageRef, width, height } = params.image;
5021     const resources = new Dict(xref);
5022     const xobject = new Dict(xref);
5023     resources.set("XObject", xobject);
5024     xobject.set("Im0", imageRef);
5025     const appearance = `q ${width} 0 0 ${height} 0 0 cm /Im0 Do Q`;
5026 
5027     const appearanceStreamDict = new Dict(xref);
5028     appearanceStreamDict.set("FormType", 1);
5029     appearanceStreamDict.set("Subtype", Name.get("Form"));
5030     appearanceStreamDict.set("Type", Name.get("XObject"));
5031     appearanceStreamDict.set("BBox", [0, 0, width, height]);
5032     appearanceStreamDict.set("Resources", resources);
5033 
5034     if (rotation) {
5035       const matrix = getRotationMatrix(rotation, width, height);
5036       appearanceStreamDict.set("Matrix", matrix);
5037     }
5038 
5039     const ap = new StringStream(appearance);
5040     ap.dict = appearanceStreamDict;
5041 
5042     return ap;
5043   }
5044 }
5045 
5046 class FileAttachmentAnnotation extends MarkupAnnotation {
5047   constructor(params) {
5048     super(params);
5049 
5050     const { dict, xref } = params;
5051     const file = new FileSpec(dict.get("FS"), xref);
5052 
5053     this.data.annotationType = AnnotationType.FILEATTACHMENT;
5054     this.data.hasOwnCanvas = this.data.noRotate;
5055     this.data.noHTML = false;
5056     this.data.file = file.serializable;
5057 
5058     const name = dict.get("Name");
5059     this.data.name =
5060       name instanceof Name ? stringToPDFString(name.name) : "PushPin";
5061 
5062     const fillAlpha = dict.get("ca");
5063     this.data.fillAlpha =
5064       typeof fillAlpha === "number" && fillAlpha >= 0 && fillAlpha <= 1
5065         ? fillAlpha
5066         : null;
5067   }
5068 }
5069 
5070 export {
5071   Annotation,
5072   AnnotationBorderStyle,
5073   AnnotationFactory,
5074   getQuadPoints,
5075   MarkupAnnotation,
5076   PopupAnnotation,
5077   WidgetAnnotation,
5078 };
</code>

Your task:
You are a software tester at pdf.js.
1. Write exactly one javascript test `it("...", async () => {...})` block.
2. Your test must fail on the code before the patch, and pass after, hence the test will verify that the patch resolves the issue.
3. The test must be self-contained and to-the-point.
4. Use only the provided imports (respect the paths exactly how they are given) by importing dynamically for compatibility with Node.js — no new dependencies. 
5. Return only the javascript code (no comments or explanations).

Example structure:
it("should <describe behavior>", async () => {
  const { example } = await import("../../src/core/example.js");
  <initialize required variables>;
  <define expected variable>;
  <generate actual variables>;
  <compare expected with actual>;
});

