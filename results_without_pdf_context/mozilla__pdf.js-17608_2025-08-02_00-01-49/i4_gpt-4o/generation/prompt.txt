Before you begin:
- Keep going until the job is completely solved — don’t stop halfway.
- If you’re unsure about the behavior, reread the provided patch carefully; do not hallucinate.
- Plan your approach before writing code by reflecting on whether the test truly fails before and passes after.

Issue:
<issue>
Make downloadManager optional in JSDoc types
Reading from the source code:

https://github.com/mozilla/pdf.js/blob/57d196e3497e77c81c19f852715ce79d9fb91492/src/display/annotation_layer.js#L2846

it appears to me it was not an intention to mark downloadManager as a required parameter in AnnotationLayerParameters:

https://github.com/mozilla/pdf.js/blob/57d196e3497e77c81c19f852715ce79d9fb91492/src/display/annotation_layer.js#L63

and AnnotationLayerBuilderOptions:

https://github.com/mozilla/pdf.js/blob/57d196e3497e77c81c19f852715ce79d9fb91492/web/annotation_layer_builder.js#L40

and it should be optional, similarly to accessibilityManager for example:

https://github.com/mozilla/pdf.js/blob/57d196e3497e77c81c19f852715ce79d9fb91492/web/text_layer_builder.js#L30

**Configuration:**
- PDF.js version: 2.11.174
- Is a browser extension: no

**What is the expected behavior? (add screenshot)**

`downloadManager` to be optional

**What went wrong? (add screenshot)**

`downloadManager` marked as required

Link to a viewer (if hosted on a site other than mozilla.github.io/pdf.js or as Firefox/Chrome extension):

</issue>

Patch:
<patch>
diff --git a/src/display/annotation_layer.js b/src/display/annotation_layer.js
--- a/src/display/annotation_layer.js
+++ b/src/display/annotation_layer.js
@@ -2890,7 +2890,7 @@ class FileAttachmentAnnotationElement extends AnnotationElement {
  * @property {Array} annotations
  * @property {PDFPageProxy} page
  * @property {IPDFLinkService} linkService
- * @property {IDownloadManager} downloadManager
+ * @property {IDownloadManager} [downloadManager]
  * @property {AnnotationStorage} [annotationStorage]
  * @property {string} [imageResourcesPath] - Path for image resources, mainly
  *   for annotation icons. Include trailing slash.


</patch>

Imports:
<imports>
Available Packages
Dev Dependencies:
- @babel/core: ^7.23.9
- @babel/preset-env: ^7.23.9
- @babel/runtime: ^7.23.9
- @fluent/bundle: ^0.18.0
- @fluent/dom: ^0.9.0
- @jazzer.js/core: ^2.1.0
- autoprefixer: ^10.4.17
- babel-loader: ^9.1.3
- caniuse-lite: ^1.0.30001580
- canvas: ^2.11.2
- core-js: ^3.35.1
- cross-env: ^7.0.3
- eslint: ^8.56.0
- eslint-config-prettier: ^8.10.0
- eslint-plugin-fetch-options: ^0.0.5
- eslint-plugin-html: ^7.1.0
- eslint-plugin-import: ^2.29.1
- eslint-plugin-jasmine: ^4.1.3
- eslint-plugin-json: ^3.1.0
- eslint-plugin-mozilla: ^3.3.2
- eslint-plugin-no-unsanitized: ^4.0.2
- eslint-plugin-prettier: ^5.1.3
- eslint-plugin-sort-exports: ^0.9.1
- eslint-plugin-unicorn: ^50.0.1
- globals: ^13.24.0
- gulp: ^4.0.2
- gulp-cli: ^2.3.0
- gulp-postcss: ^9.1.0
- gulp-rename: ^2.0.0
- gulp-replace: ^1.1.4
- gulp-zip: ^6.0.0
- jasmine: ^5.1.0
- jsdoc: ^4.0.2
- jstransformer-markdown-it: ^3.0.0
- merge-stream: ^2.0.0
- mkdirp: ^3.0.1
- needle: ^3.3.1
- path2d-polyfill: ^2.0.1
- pngjs: ^7.0.0
- postcss: ^8.4.33
- postcss-dark-theme-class: ^1.1.0
- postcss-dir-pseudo-class: ^8.0.1
- postcss-discard-comments: ^6.0.1
- postcss-nesting: ^12.0.2
- prettier: ^3.2.4
- puppeteer: ^21.9.0
- rimraf: ^3.0.2
- streamqueue: ^1.1.2
- stylelint: ^16.2.0
- stylelint-prettier: ^5.0.0
- terser: ^5.27.0
- through2: ^4.0.2
- tsc-alias: ^1.8.8
- ttest: ^4.0.0
- typescript: ^5.3.3
- typogr: ^0.6.8
- vinyl: ^3.0.0
- webpack: ^5.90.0
- webpack-stream: ^7.0.0
- wintersmith: ^2.5.0
- yargs: ^17.7.2

Engines:
- node: >=18

Available Relative Imports:
- `../../src/core/annotation.js`: Annotation, AnnotationBorderStyle, AnnotationFactory, MarkupAnnotation, getQuadPoints
- `../../src/core/bidi.js`: bidi
- `../../src/core/cff_parser.js`: CFFCharset, CFFCompiler, CFFFDSelect, CFFParser, CFFStrings
- `../../src/core/cmap.js`: CMap, CMapFactory, IdentityCMap
- `../../src/core/colorspace.js`: ColorSpace
- `../../src/core/core_utils.js`: arrayBuffersToBytes, encodeToXmlString, escapePDFName, escapeString, getInheritableProperty, isAscii, isWhiteSpace, log2, numberToString, parseXFAPath, recoverJsURL, stringToUTF16HexString, stringToUTF16String, toRomanNumerals, validateCSSFont
- `../../src/core/crypto.js`: AES128Cipher, AES256Cipher, ARCFourCipher, CipherTransformFactory, PDF17, PDF20, calculateMD5, calculateSHA256, calculateSHA384, calculateSHA512
- `../../src/core/default_appearance.js`: createDefaultAppearance, parseAppearanceStream, parseDefaultAppearance
- `../../src/core/document.js`: PDFDocument, Page
- `../../src/core/encodings.js`: getEncoding
- `../../src/core/evaluator.js`: PartialEvaluator
- `../../src/core/flate_stream.js`: FlateStream
- `../../src/core/font_substitutions.js`: getFontSubstitution
- `../../src/core/fonts_utils.js`: SEAC_ANALYSIS_ENABLED
- `../../src/core/function.js`: PDFFunctionFactory, PostScriptCompiler, PostScriptEvaluator
- `../../src/core/glyphlist.js`: getDingbatsGlyphsUnicode, getGlyphsUnicode
- `../../src/core/image_utils.js`: GlobalImageCache, LocalColorSpaceCache
- `../../src/core/jbig2.js`: Jbig2Image
- `../../src/core/jpg.js`: JpegImage
- `../../src/core/jpx.js`: JpxImage
- `../../src/core/metadata_parser.js`: MetadataParser
- `../../src/core/operator_list.js`: OperatorList
- `../../src/core/parser.js`: Lexer, Linearization, Parser
- `../../src/core/predictor_stream.js`: PredictorStream
- `../../src/core/primitives.js`: Cmd, Dict, EOF, Name, Ref, RefSet, RefSetCache, isCmd, isDict, isName, isRefsEqual
- `../../src/core/ps_parser.js`: PostScriptLexer, PostScriptParser
- `../../src/core/stream.js`: NullStream, Stream, StringStream
- `../../src/core/type1_parser.js`: Type1Parser
- `../../src/core/unicode.js`: getCharUnicodeCategory, getUnicodeForGlyph, getUnicodeRangeFor, mapSpecialUnicodeValues
- `../../src/core/worker.js`: WorkerMessageHandler, WorkerTask
- `../../src/core/writer.js`: incrementalUpdate, writeDict
- `../../src/core/xfa/bind.js`: Binder
- `../../src/core/xfa/data.js`: DataHandler
- `../../src/core/xfa/factory.js`: XFAFactory
- `../../src/core/xfa/formcalc_lexer.js`: Lexer, TOKEN, Token
- `../../src/core/xfa/formcalc_parser.js`: Errors, Parser
- `../../src/core/xfa/parser.js`: XFAParser
- `../../src/core/xfa/som.js`: searchNode
- `../../src/core/xfa/symbol_utils.js`: $dump, $getChildren, $getChildrenByClass, $getChildrenByName, $text, $uid
- `../../src/core/xml_parser.js`: SimpleXMLParser, XMLParserBase
- `../../src/display/annotation_layer.js`: AnnotationLayer
- `../../src/display/annotation_storage.js`: AnnotationStorage
- `../../src/display/api.js`: DefaultCMapReaderFactory, DefaultCanvasFactory, DefaultStandardFontDataFactory, LoopbackPort, PDFDataRangeTransport, PDFDocumentLoadingTask, PDFDocumentProxy, PDFPageProxy, PDFWorker, PDFWorkerUtil, RenderTask, build, getDocument, version
- `../../src/display/display_utils.js`: DOMCanvasFactory, DOMSVGFactory, PDFDateString, PageViewport, PixelsPerInch, RenderingCancelledException, StatTimer, fetchData, getFilenameFromUrl, getPdfFilenameFromUrl, getXfaPageViewport, isDataScheme, isPdfFile, isValidFetchUrl, noContextMenu, setLayerDimensions
- `../../src/display/draw_layer.js`: DrawLayer
- `../../src/display/editor/annotation_editor_layer.js`: AnnotationEditorLayer
- `../../src/display/editor/color_picker.js`: ColorPicker
- `../../src/display/editor/outliner.js`: Outliner
- `../../src/display/editor/tools.js`: AnnotationEditorUIManager, CommandManager
- `../../src/display/fetch_stream.js`: PDFFetchStream
- `../../src/display/metadata.js`: Metadata
- `../../src/display/network.js`: PDFNetworkStream
- `../../src/display/network_utils.js`: createResponseStatusError, extractFilenameFromHeader, validateRangeRequestCapabilities, validateResponseStatus
- `../../src/display/node_stream.js`: PDFNodeStream
- `../../src/display/text_layer.js`: TextLayerRenderTask, renderTextLayer, updateTextLayer
- `../../src/display/worker_options.js`: GlobalWorkerOptions
- `../../src/display/xfa_layer.js`: XfaLayer
- `../../src/shared/message_handler.js`: MessageHandler
- `../../src/shared/murmurhash3.js`: MurmurHash3_64
- `../../src/shared/util.js`: AbortException, AnnotationBorderStyleType, AnnotationEditorParamsType, AnnotationEditorType, AnnotationFieldFlag, AnnotationFlag, AnnotationMode, AnnotationType, CMapCompressionType, FeatureTest, FormatError, ImageKind, InvalidPDFException, MissingPDFException, OPS, PasswordException, PasswordResponses, PermissionFlag, PromiseCapability, RenderingIntentFlag, UnexpectedResponseException, UnknownErrorException, Util, VerbosityLevel, bytesToString, createValidAbsoluteUrl, getModificationDate, getVerbosityLevel, isNodeJS, normalizeUnicode, objectSize, setVerbosityLevel, shadow, string32, stringToBytes, stringToPDFString, stringToUTF8String
- `../../web/annotation_layer_builder.js`: AnnotationLayerBuilder
- `../../web/download_manager.js`: DownloadManager
- `../../web/event_utils.js`: EventBus, WaitOnType, waitOnEventOrTimeout
- `../../web/genericl10n.js`: GenericL10n
- `../../web/pdf_find_controller.js`: FindState, PDFFindController
- `../../web/pdf_find_utils.js`: CharacterType, getCharacterType
- `../../web/pdf_history.js`: PDFHistory, isDestArraysEqual, isDestHashesEqual
- `../../web/pdf_link_service.js`: LinkTarget, PDFLinkService, SimpleLinkService
- `../../web/pdf_page_view.js`: PDFPageView
- `../../web/pdf_scripting_manager.component.js`: PDFScriptingManager
- `../../web/pdf_single_page_viewer.js`: PDFSinglePageViewer
- `../../web/pdf_viewer.js`: PDFPageViewBuffer, PDFViewer
- `../../web/struct_tree_layer_builder.js`: StructTreeLayerBuilder
- `../../web/text_layer_builder.js`: TextLayerBuilder
- `../../web/ui_utils.js`: AutoPrintRegExp, ProgressBar, RenderingStates, ScrollMode, SpreadMode, backtrackBeforeAllVisibleElements, binarySearchFirstItem, getPageSizeInches, getVisibleElements, isPortraitOrientation, isValidRotation, parseQueryString, removeNullCharacters
- `../../web/xfa_layer_builder.js`: XfaLayerBuilder
- `./test_utils.js`: CMAP_URL, DefaultFileReaderFactory, STANDARD_FONT_DATA_URL, TEST_PDFS_PATH, XRefMock, buildGetDocumentParams, createIdFactory
- `./testreporter.js`: TestReporter
</imports>

Code:
<code>
File:
src/display/annotation_layer.js
1 /* Copyright 2014 Mozilla Foundation
2  *
3  * Licensed under the Apache License, Version 2.0 (the "License");
4  * you may not use this file except in compliance with the License.
5  * You may obtain a copy of the License at
6  *
7  *     http://www.apache.org/licenses/LICENSE-2.0
8  *
9  * Unless required by applicable law or agreed to in writing, software
10  * distributed under the License is distributed on an "AS IS" BASIS,
11  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
12  * See the License for the specific language governing permissions and
13  * limitations under the License.
14  */
15 
16 /** @typedef {import("./api").PDFPageProxy} PDFPageProxy */
17 /** @typedef {import("./display_utils").PageViewport} PageViewport */
18 // eslint-disable-next-line max-len
19 /** @typedef {import("../../web/text_accessibility.js").TextAccessibilityManager} TextAccessibilityManager */
20 // eslint-disable-next-line max-len
21 /** @typedef {import("../../web/interfaces").IDownloadManager} IDownloadManager */
22 /** @typedef {import("../../web/interfaces").IPDFLinkService} IPDFLinkService */
23 
24 import {
25   AnnotationBorderStyleType,
26   AnnotationEditorType,
27   AnnotationPrefix,
28   AnnotationType,
29   FeatureTest,
30   LINE_FACTOR,
31   shadow,
32   unreachable,
33   Util,
34   warn,
35 } from "../shared/util.js";
36 import {
37   DOMSVGFactory,
38   getFilenameFromUrl,
39   PDFDateString,
40   setLayerDimensions,
41 } from "./display_utils.js";
42 import { AnnotationStorage } from "./annotation_storage.js";
43 import { ColorConverters } from "../shared/scripting_utils.js";
44 import { XfaLayer } from "./xfa_layer.js";
45 
46 const DEFAULT_TAB_INDEX = 1000;
47 const DEFAULT_FONT_SIZE = 9;
48 const GetElementsByNameSet = new WeakSet();
49 
50 function getRectDims(rect) {
51   return {
52     width: rect[2] - rect[0],
53     height: rect[3] - rect[1],
54   };
55 }
56 
57 /**
58  * @typedef {Object} AnnotationElementParameters
59  * @property {Object} data
60  * @property {HTMLDivElement} layer
61  * @property {IPDFLinkService} linkService
62  * @property {IDownloadManager} [downloadManager]
63  * @property {AnnotationStorage} [annotationStorage]
64  * @property {string} [imageResourcesPath] - Path for image resources, mainly
65  *   for annotation icons. Include trailing slash.
66  * @property {boolean} renderForms
67  * @property {Object} svgFactory
68  * @property {boolean} [enableScripting]
69  * @property {boolean} [hasJSActions]
70  * @property {Object} [fieldObjects]
71  */
72 
73 class AnnotationElementFactory {
74   /**
75    * @param {AnnotationElementParameters} parameters
76    * @returns {AnnotationElement}
77    */
78   static create(parameters) {
79     const subtype = parameters.data.annotationType;
80 
81     switch (subtype) {
82       case AnnotationType.LINK:
83         return new LinkAnnotationElement(parameters);
84 
85       case AnnotationType.TEXT:
86         return new TextAnnotationElement(parameters);
87 
88       case AnnotationType.WIDGET:
89         const fieldType = parameters.data.fieldType;
90 
91         switch (fieldType) {
92           case "Tx":
93             return new TextWidgetAnnotationElement(parameters);
94           case "Btn":
95             if (parameters.data.radioButton) {
96               return new RadioButtonWidgetAnnotationElement(parameters);
97             } else if (parameters.data.checkBox) {
98               return new CheckboxWidgetAnnotationElement(parameters);
99             }
100             return new PushButtonWidgetAnnotationElement(parameters);
101           case "Ch":
102             return new ChoiceWidgetAnnotationElement(parameters);
103           case "Sig":
104             return new SignatureWidgetAnnotationElement(parameters);
105         }
106         return new WidgetAnnotationElement(parameters);
107 
108       case AnnotationType.POPUP:
109         return new PopupAnnotationElement(parameters);
110 
111       case AnnotationType.FREETEXT:
112         return new FreeTextAnnotationElement(parameters);
113 
114       case AnnotationType.LINE:
115         return new LineAnnotationElement(parameters);
116 
117       case AnnotationType.SQUARE:
118         return new SquareAnnotationElement(parameters);
119 
120       case AnnotationType.CIRCLE:
121         return new CircleAnnotationElement(parameters);
122 
123       case AnnotationType.POLYLINE:
124         return new PolylineAnnotationElement(parameters);
125 
126       case AnnotationType.CARET:
127         return new CaretAnnotationElement(parameters);
128 
129       case AnnotationType.INK:
130         return new InkAnnotationElement(parameters);
131 
132       case AnnotationType.POLYGON:
133         return new PolygonAnnotationElement(parameters);
134 
135       case AnnotationType.HIGHLIGHT:
136         return new HighlightAnnotationElement(parameters);
137 
138       case AnnotationType.UNDERLINE:
139         return new UnderlineAnnotationElement(parameters);
140 
141       case AnnotationType.SQUIGGLY:
142         return new SquigglyAnnotationElement(parameters);
143 
144       case AnnotationType.STRIKEOUT:
145         return new StrikeOutAnnotationElement(parameters);
146 
147       case AnnotationType.STAMP:
148         return new StampAnnotationElement(parameters);
149 
150       case AnnotationType.FILEATTACHMENT:
151         return new FileAttachmentAnnotationElement(parameters);
152 
153       default:
154         return new AnnotationElement(parameters);
155     }
156   }
157 }
158 
159 class AnnotationElement {
160   #hasBorder = false;
161 
162   constructor(
163     parameters,
164     {
165       isRenderable = false,
166       ignoreBorder = false,
167       createQuadrilaterals = false,
168     } = {}
169   ) {
170     this.isRenderable = isRenderable;
171     this.data = parameters.data;
172     this.layer = parameters.layer;
173     this.linkService = parameters.linkService;
174     this.downloadManager = parameters.downloadManager;
175     this.imageResourcesPath = parameters.imageResourcesPath;
176     this.renderForms = parameters.renderForms;
177     this.svgFactory = parameters.svgFactory;
178     this.annotationStorage = parameters.annotationStorage;
179     this.enableScripting = parameters.enableScripting;
180     this.hasJSActions = parameters.hasJSActions;
181     this._fieldObjects = parameters.fieldObjects;
182     this.parent = parameters.parent;
183 
184     if (isRenderable) {
185       this.container = this._createContainer(ignoreBorder);
186     }
187     if (createQuadrilaterals) {
188       this._createQuadrilaterals();
189     }
190   }
191 
192   static _hasPopupData({ titleObj, contentsObj, richText }) {
193     return !!(titleObj?.str || contentsObj?.str || richText?.str);
194   }
195 
196   get hasPopupData() {
197     return AnnotationElement._hasPopupData(this.data);
198   }
199 
200   /**
201    * Create an empty container for the annotation's HTML element.
202    *
203    * @private
204    * @param {boolean} ignoreBorder
205    * @memberof AnnotationElement
206    * @returns {HTMLElement} A section element.
207    */
208   _createContainer(ignoreBorder) {
209     const {
210       data,
211       parent: { page, viewport },
212     } = this;
213 
214     const container = document.createElement("section");
215     container.setAttribute("data-annotation-id", data.id);
216     if (!(this instanceof WidgetAnnotationElement)) {
217       container.tabIndex = DEFAULT_TAB_INDEX;
218     }
219 
220     // The accessibility manager will move the annotation in the DOM in
221     // order to match the visual ordering.
222     // But if an annotation is above an other one, then we must draw it
223     // after the other one whatever the order is in the DOM, hence the
224     // use of the z-index.
225     container.style.zIndex = this.parent.zIndex++;
226 
227     if (this.data.popupRef) {
228       container.setAttribute("aria-haspopup", "dialog");
229     }
230 
231     if (data.noRotate) {
232       container.classList.add("norotate");
233     }
234 
235     const { pageWidth, pageHeight, pageX, pageY } = viewport.rawDims;
236 
237     if (!data.rect || this instanceof PopupAnnotationElement) {
238       const { rotation } = data;
239       if (!data.hasOwnCanvas && rotation !== 0) {
240         this.setRotation(rotation, container);
241       }
242       return container;
243     }
244 
245     const { width, height } = getRectDims(data.rect);
246 
247     // Do *not* modify `data.rect`, since that will corrupt the annotation
248     // position on subsequent calls to `_createContainer` (see issue 6804).
249     const rect = Util.normalizeRect([
250       data.rect[0],
251       page.view[3] - data.rect[1] + page.view[1],
252       data.rect[2],
253       page.view[3] - data.rect[3] + page.view[1],
254     ]);
255 
256     if (!ignoreBorder && data.borderStyle.width > 0) {
257       container.style.borderWidth = `${data.borderStyle.width}px`;
258 
259       const horizontalRadius = data.borderStyle.horizontalCornerRadius;
260       const verticalRadius = data.borderStyle.verticalCornerRadius;
261       if (horizontalRadius > 0 || verticalRadius > 0) {
262         const radius = `calc(${horizontalRadius}px * var(--scale-factor)) / calc(${verticalRadius}px * var(--scale-factor))`;
263         container.style.borderRadius = radius;
264       } else if (this instanceof RadioButtonWidgetAnnotationElement) {
265         const radius = `calc(${width}px * var(--scale-factor)) / calc(${height}px * var(--scale-factor))`;
266         container.style.borderRadius = radius;
267       }
268 
269       switch (data.borderStyle.style) {
270         case AnnotationBorderStyleType.SOLID:
271           container.style.borderStyle = "solid";
272           break;
273 
274         case AnnotationBorderStyleType.DASHED:
275           container.style.borderStyle = "dashed";
276           break;
277 
278         case AnnotationBorderStyleType.BEVELED:
279           warn("Unimplemented border style: beveled");
280           break;
281 
282         case AnnotationBorderStyleType.INSET:
283           warn("Unimplemented border style: inset");
284           break;
285 
286         case AnnotationBorderStyleType.UNDERLINE:
287           container.style.borderBottomStyle = "solid";
288           break;
289 
290         default:
291           break;
292       }
293 
294       const borderColor = data.borderColor || null;
295       if (borderColor) {
296         this.#hasBorder = true;
297         container.style.borderColor = Util.makeHexColor(
298           borderColor[0] | 0,
299           borderColor[1] | 0,
300           borderColor[2] | 0
301         );
302       } else {
303         // Transparent (invisible) border, so do not draw it at all.
304         container.style.borderWidth = 0;
305       }
306     }
307 
308     container.style.left = `${(100 * (rect[0] - pageX)) / pageWidth}%`;
309     container.style.top = `${(100 * (rect[1] - pageY)) / pageHeight}%`;
310 
311     const { rotation } = data;
312     if (data.hasOwnCanvas || rotation === 0) {
313       container.style.width = `${(100 * width) / pageWidth}%`;
314       container.style.height = `${(100 * height) / pageHeight}%`;
315     } else {
316       this.setRotation(rotation, container);
317     }
318 
319     return container;
320   }
321 
322   setRotation(angle, container = this.container) {
323     if (!this.data.rect) {
324       return;
325     }
326     const { pageWidth, pageHeight } = this.parent.viewport.rawDims;
327     const { width, height } = getRectDims(this.data.rect);
328 
329     let elementWidth, elementHeight;
330     if (angle % 180 === 0) {
331       elementWidth = (100 * width) / pageWidth;
332       elementHeight = (100 * height) / pageHeight;
333     } else {
334       elementWidth = (100 * height) / pageWidth;
335       elementHeight = (100 * width) / pageHeight;
336     }
337 
338     container.style.width = `${elementWidth}%`;
339     container.style.height = `${elementHeight}%`;
340 
341     container.setAttribute("data-main-rotation", (360 - angle) % 360);
342   }
343 
344   get _commonActions() {
345     const setColor = (jsName, styleName, event) => {
346       const color = event.detail[jsName];
347       const colorType = color[0];
348       const colorArray = color.slice(1);
349       event.target.style[styleName] =
350         ColorConverters[`${colorType}_HTML`](colorArray);
351       this.annotationStorage.setValue(this.data.id, {
352         [styleName]: ColorConverters[`${colorType}_rgb`](colorArray),
353       });
354     };
355 
356     return shadow(this, "_commonActions", {
357       display: event => {
358         const { display } = event.detail;
359         // See scripting/constants.js for the values of `Display`.
360         // 0 = visible, 1 = hidden, 2 = noPrint and 3 = noView.
361         const hidden = display % 2 === 1;
362         this.container.style.visibility = hidden ? "hidden" : "visible";
363         this.annotationStorage.setValue(this.data.id, {
364           noView: hidden,
365           noPrint: display === 1 || display === 2,
366         });
367       },
368       print: event => {
369         this.annotationStorage.setValue(this.data.id, {
370           noPrint: !event.detail.print,
371         });
372       },
373       hidden: event => {
374         const { hidden } = event.detail;
375         this.container.style.visibility = hidden ? "hidden" : "visible";
376         this.annotationStorage.setValue(this.data.id, {
377           noPrint: hidden,
378           noView: hidden,
379         });
380       },
381       focus: event => {
382         setTimeout(() => event.target.focus({ preventScroll: false }), 0);
383       },
384       userName: event => {
385         // tooltip
386         event.target.title = event.detail.userName;
387       },
388       readonly: event => {
389         event.target.disabled = event.detail.readonly;
390       },
391       required: event => {
392         this._setRequired(event.target, event.detail.required);
393       },
394       bgColor: event => {
395         setColor("bgColor", "backgroundColor", event);
396       },
397       fillColor: event => {
398         setColor("fillColor", "backgroundColor", event);
399       },
400       fgColor: event => {
401         setColor("fgColor", "color", event);
402       },
403       textColor: event => {
404         setColor("textColor", "color", event);
405       },
406       borderColor: event => {
407         setColor("borderColor", "borderColor", event);
408       },
409       strokeColor: event => {
410         setColor("strokeColor", "borderColor", event);
411       },
412       rotation: event => {
413         const angle = event.detail.rotation;
414         this.setRotation(angle);
415         this.annotationStorage.setValue(this.data.id, {
416           rotation: angle,
417         });
418       },
419     });
420   }
421 
422   _dispatchEventFromSandbox(actions, jsEvent) {
423     const commonActions = this._commonActions;
424     for (const name of Object.keys(jsEvent.detail)) {
425       const action = actions[name] || commonActions[name];
426       action?.(jsEvent);
427     }
428   }
429 
430   _setDefaultPropertiesFromJS(element) {
431     if (!this.enableScripting) {
432       return;
433     }
434 
435     // Some properties may have been updated thanks to JS.
436     const storedData = this.annotationStorage.getRawValue(this.data.id);
437     if (!storedData) {
438       return;
439     }
440 
441     const commonActions = this._commonActions;
442     for (const [actionName, detail] of Object.entries(storedData)) {
443       const action = commonActions[actionName];
444       if (action) {
445         const eventProxy = {
446           detail: {
447             [actionName]: detail,
448           },
449           target: element,
450         };
451         action(eventProxy);
452         // The action has been consumed: no need to keep it.
453         delete storedData[actionName];
454       }
455     }
456   }
457 
458   /**
459    * Create quadrilaterals from the annotation's quadpoints.
460    *
461    * @private
462    * @memberof AnnotationElement
463    */
464   _createQuadrilaterals() {
465     if (!this.container) {
466       return;
467     }
468     const { quadPoints } = this.data;
469     if (!quadPoints) {
470       return;
471     }
472 
473     const [rectBlX, rectBlY, rectTrX, rectTrY] = this.data.rect;
474 
475     if (quadPoints.length === 1) {
476       const [, { x: trX, y: trY }, { x: blX, y: blY }] = quadPoints[0];
477       if (
478         rectTrX === trX &&
479         rectTrY === trY &&
480         rectBlX === blX &&
481         rectBlY === blY
482       ) {
483         // The quadpoints cover the whole annotation rectangle, so no need to
484         // create a quadrilateral.
485         return;
486       }
487     }
488 
489     const { style } = this.container;
490     let svgBuffer;
491     if (this.#hasBorder) {
492       const { borderColor, borderWidth } = style;
493       style.borderWidth = 0;
494       svgBuffer = [
495         "url('data:image/svg+xml;utf8,",
496         `<svg xmlns="http://www.w3.org/2000/svg"`,
497         ` preserveAspectRatio="none" viewBox="0 0 1 1">`,
498         `<g fill="transparent" stroke="${borderColor}" stroke-width="${borderWidth}">`,
499       ];
500       this.container.classList.add("hasBorder");
501     }
502 
503     if (typeof PDFJSDev !== "undefined" && PDFJSDev.test("TESTING")) {
504       this.container.classList.add("hasClipPath");
505     }
506 
507     const width = rectTrX - rectBlX;
508     const height = rectTrY - rectBlY;
509 
510     const { svgFactory } = this;
511     const svg = svgFactory.createElement("svg");
512     svg.classList.add("quadrilateralsContainer");
513     svg.setAttribute("width", 0);
514     svg.setAttribute("height", 0);
515     const defs = svgFactory.createElement("defs");
516     svg.append(defs);
517     const clipPath = svgFactory.createElement("clipPath");
518     const id = `clippath_${this.data.id}`;
519     clipPath.setAttribute("id", id);
520     clipPath.setAttribute("clipPathUnits", "objectBoundingBox");
521     defs.append(clipPath);
522 
523     for (const [, { x: trX, y: trY }, { x: blX, y: blY }] of quadPoints) {
524       const rect = svgFactory.createElement("rect");
525       const x = (blX - rectBlX) / width;
526       const y = (rectTrY - trY) / height;
527       const rectWidth = (trX - blX) / width;
528       const rectHeight = (trY - blY) / height;
529       rect.setAttribute("x", x);
530       rect.setAttribute("y", y);
531       rect.setAttribute("width", rectWidth);
532       rect.setAttribute("height", rectHeight);
533       clipPath.append(rect);
534       svgBuffer?.push(
535         `<rect vector-effect="non-scaling-stroke" x="${x}" y="${y}" width="${rectWidth}" height="${rectHeight}"/>`
536       );
537     }
538 
539     if (this.#hasBorder) {
540       svgBuffer.push(`</g></svg>')`);
541       style.backgroundImage = svgBuffer.join("");
542     }
543 
544     this.container.append(svg);
545     this.container.style.clipPath = `url(#${id})`;
546   }
547 
548   /**
549    * Create a popup for the annotation's HTML element. This is used for
550    * annotations that do not have a Popup entry in the dictionary, but
551    * are of a type that works with popups (such as Highlight annotations).
552    *
553    * @private
554    * @memberof AnnotationElement
555    */
556   _createPopup() {
557     const { container, data } = this;
558     container.setAttribute("aria-haspopup", "dialog");
559 
560     const popup = new PopupAnnotationElement({
561       data: {
562         color: data.color,
563         titleObj: data.titleObj,
564         modificationDate: data.modificationDate,
565         contentsObj: data.contentsObj,
566         richText: data.richText,
567         parentRect: data.rect,
568         borderStyle: 0,
569         id: `popup_${data.id}`,
570         rotation: data.rotation,
571       },
572       parent: this.parent,
573       elements: [this],
574     });
575     this.parent.div.append(popup.render());
576   }
577 
578   /**
579    * Render the annotation's HTML element(s).
580    *
581    * @public
582    * @memberof AnnotationElement
583    */
584   render() {
585     unreachable("Abstract method `AnnotationElement.render` called");
586   }
587 
588   /**
589    * @private
590    * @returns {Array}
591    */
592   _getElementsByName(name, skipId = null) {
593     const fields = [];
594 
595     if (this._fieldObjects) {
596       const fieldObj = this._fieldObjects[name];
597       if (fieldObj) {
598         for (const { page, id, exportValues } of fieldObj) {
599           if (page === -1) {
600             continue;
601           }
602           if (id === skipId) {
603             continue;
604           }
605           const exportValue =
606             typeof exportValues === "string" ? exportValues : null;
607 
608           const domElement = document.querySelector(
609             `[data-element-id="${id}"]`
610           );
611           if (domElement && !GetElementsByNameSet.has(domElement)) {
612             warn(`_getElementsByName - element not allowed: ${id}`);
613             continue;
614           }
615           fields.push({ id, exportValue, domElement });
616         }
617       }
618       return fields;
619     }
620     // Fallback to a regular DOM lookup, to ensure that the standalone
621     // viewer components won't break.
622     for (const domElement of document.getElementsByName(name)) {
623       const { exportValue } = domElement;
624       const id = domElement.getAttribute("data-element-id");
625       if (id === skipId) {
626         continue;
627       }
628       if (!GetElementsByNameSet.has(domElement)) {
629         continue;
630       }
631       fields.push({ id, exportValue, domElement });
632     }
633     return fields;
634   }
635 
636   show() {
637     if (this.container) {
638       this.container.hidden = false;
639     }
640     this.popup?.maybeShow();
641   }
642 
643   hide() {
644     if (this.container) {
645       this.container.hidden = true;
646     }
647     this.popup?.forceHide();
648   }
649 
650   /**
651    * Get the HTML element(s) which can trigger a popup when clicked or hovered.
652    *
653    * @public
654    * @memberof AnnotationElement
655    * @returns {Array<HTMLElement>|HTMLElement} An array of elements or an
656    *          element.
657    */
658   getElementsToTriggerPopup() {
659     return this.container;
660   }
661 
662   addHighlightArea() {
663     const triggers = this.getElementsToTriggerPopup();
664     if (Array.isArray(triggers)) {
665       for (const element of triggers) {
666         element.classList.add("highlightArea");
667       }
668     } else {
669       triggers.classList.add("highlightArea");
670     }
671   }
672 
673   get _isEditable() {
674     return false;
675   }
676 
677   _editOnDoubleClick() {
678     if (!this._isEditable) {
679       return;
680     }
681     const {
682       annotationEditorType: mode,
683       data: { id: editId },
684     } = this;
685     this.container.addEventListener("dblclick", () => {
686       this.linkService.eventBus?.dispatch("switchannotationeditormode", {
687         source: this,
688         mode,
689         editId,
690       });
691     });
692   }
693 }
694 
695 class LinkAnnotationElement extends AnnotationElement {
696   constructor(parameters, options = null) {
697     super(parameters, {
698       isRenderable: true,
699       ignoreBorder: !!options?.ignoreBorder,
700       createQuadrilaterals: true,
701     });
702     this.isTooltipOnly = parameters.data.isTooltipOnly;
703   }
704 
705   render() {
706     const { data, linkService } = this;
707     const link = document.createElement("a");
708     link.setAttribute("data-element-id", data.id);
709     let isBound = false;
710 
711     if (data.url) {
712       linkService.addLinkAttributes(link, data.url, data.newWindow);
713       isBound = true;
714     } else if (data.action) {
715       this._bindNamedAction(link, data.action);
716       isBound = true;
717     } else if (data.attachment) {
718       this.#bindAttachment(link, data.attachment, data.attachmentDest);
719       isBound = true;
720     } else if (data.setOCGState) {
721       this.#bindSetOCGState(link, data.setOCGState);
722       isBound = true;
723     } else if (data.dest) {
724       this._bindLink(link, data.dest);
725       isBound = true;
726     } else {
727       if (
728         data.actions &&
729         (data.actions.Action ||
730           data.actions["Mouse Up"] ||
731           data.actions["Mouse Down"]) &&
732         this.enableScripting &&
733         this.hasJSActions
734       ) {
735         this._bindJSAction(link, data);
736         isBound = true;
737       }
738 
739       if (data.resetForm) {
740         this._bindResetFormAction(link, data.resetForm);
741         isBound = true;
742       } else if (this.isTooltipOnly && !isBound) {
743         this._bindLink(link, "");
744         isBound = true;
745       }
746     }
747 
748     this.container.classList.add("linkAnnotation");
749     if (isBound) {
750       this.container.append(link);
751     }
752 
753     return this.container;
754   }
755 
756   #setInternalLink() {
757     this.container.setAttribute("data-internal-link", "");
758   }
759 
760   /**
761    * Bind internal links to the link element.
762    *
763    * @private
764    * @param {Object} link
765    * @param {Object} destination
766    * @memberof LinkAnnotationElement
767    */
768   _bindLink(link, destination) {
769     link.href = this.linkService.getDestinationHash(destination);
770     link.onclick = () => {
771       if (destination) {
772         this.linkService.goToDestination(destination);
773       }
774       return false;
775     };
776     if (destination || destination === /* isTooltipOnly = */ "") {
777       this.#setInternalLink();
778     }
779   }
780 
781   /**
782    * Bind named actions to the link element.
783    *
784    * @private
785    * @param {Object} link
786    * @param {Object} action
787    * @memberof LinkAnnotationElement
788    */
789   _bindNamedAction(link, action) {
790     link.href = this.linkService.getAnchorUrl("");
791     link.onclick = () => {
792       this.linkService.executeNamedAction(action);
793       return false;
794     };
795     this.#setInternalLink();
796   }
797 
798   /**
799    * Bind attachments to the link element.
800    * @param {Object} link
801    * @param {Object} attachment
802    * @param {str} [dest]
803    */
804   #bindAttachment(link, attachment, dest = null) {
805     link.href = this.linkService.getAnchorUrl("");
806     link.onclick = () => {
807       this.downloadManager?.openOrDownloadData(
808         attachment.content,
809         attachment.filename,
810         dest
811       );
812       return false;
813     };
814     this.#setInternalLink();
815   }
816 
817   /**
818    * Bind SetOCGState actions to the link element.
819    * @param {Object} link
820    * @param {Object} action
821    */
822   #bindSetOCGState(link, action) {
823     link.href = this.linkService.getAnchorUrl("");
824     link.onclick = () => {
825       this.linkService.executeSetOCGState(action);
826       return false;
827     };
828     this.#setInternalLink();
829   }
830 
831   /**
832    * Bind JS actions to the link element.
833    *
834    * @private
835    * @param {Object} link
836    * @param {Object} data
837    * @memberof LinkAnnotationElement
838    */
839   _bindJSAction(link, data) {
840     link.href = this.linkService.getAnchorUrl("");
841     const map = new Map([
842       ["Action", "onclick"],
843       ["Mouse Up", "onmouseup"],
844       ["Mouse Down", "onmousedown"],
845     ]);
846     for (const name of Object.keys(data.actions)) {
847       const jsName = map.get(name);
848       if (!jsName) {
849         continue;
850       }
851       link[jsName] = () => {
852         this.linkService.eventBus?.dispatch("dispatcheventinsandbox", {
853           source: this,
854           detail: {
855             id: data.id,
856             name,
857           },
858         });
859         return false;
860       };
861     }
862 
863     if (!link.onclick) {
864       link.onclick = () => false;
865     }
866     this.#setInternalLink();
867   }
868 
869   _bindResetFormAction(link, resetForm) {
870     const otherClickAction = link.onclick;
871     if (!otherClickAction) {
872       link.href = this.linkService.getAnchorUrl("");
873     }
874     this.#setInternalLink();
875 
876     if (!this._fieldObjects) {
877       warn(
878         `_bindResetFormAction - "resetForm" action not supported, ` +
879           "ensure that the `fieldObjects` parameter is provided."
880       );
881       if (!otherClickAction) {
882         link.onclick = () => false;
883       }
884       return;
885     }
886 
887     link.onclick = () => {
888       otherClickAction?.();
889 
890       const {
891         fields: resetFormFields,
892         refs: resetFormRefs,
893         include,
894       } = resetForm;
895 
896       const allFields = [];
897       if (resetFormFields.length !== 0 || resetFormRefs.length !== 0) {
898         const fieldIds = new Set(resetFormRefs);
899         for (const fieldName of resetFormFields) {
900           const fields = this._fieldObjects[fieldName] || [];
901           for (const { id } of fields) {
902             fieldIds.add(id);
903           }
904         }
905         for (const fields of Object.values(this._fieldObjects)) {
906           for (const field of fields) {
907             if (fieldIds.has(field.id) === include) {
908               allFields.push(field);
909             }
910           }
911         }
912       } else {
913         for (const fields of Object.values(this._fieldObjects)) {
914           allFields.push(...fields);
915         }
916       }
917 
918       const storage = this.annotationStorage;
919       const allIds = [];
920       for (const field of allFields) {
921         const { id } = field;
922         allIds.push(id);
923         switch (field.type) {
924           case "text": {
925             const value = field.defaultValue || "";
926             storage.setValue(id, { value });
927             break;
928           }
929           case "checkbox":
930           case "radiobutton": {
931             const value = field.defaultValue === field.exportValues;
932             storage.setValue(id, { value });
933             break;
934           }
935           case "combobox":
936           case "listbox": {
937             const value = field.defaultValue || "";
938             storage.setValue(id, { value });
939             break;
940           }
941           default:
942             continue;
943         }
944 
945         const domElement = document.querySelector(`[data-element-id="${id}"]`);
946         if (!domElement) {
947           continue;
948         } else if (!GetElementsByNameSet.has(domElement)) {
949           warn(`_bindResetFormAction - element not allowed: ${id}`);
950           continue;
951         }
952         domElement.dispatchEvent(new Event("resetform"));
953       }
954 
955       if (this.enableScripting) {
956         // Update the values in the sandbox.
957         this.linkService.eventBus?.dispatch("dispatcheventinsandbox", {
958           source: this,
959           detail: {
960             id: "app",
961             ids: allIds,
962             name: "ResetForm",
963           },
964         });
965       }
966 
967       return false;
968     };
969   }
970 }
971 
972 class TextAnnotationElement extends AnnotationElement {
973   constructor(parameters) {
974     super(parameters, { isRenderable: true });
975   }
976 
977   render() {
978     this.container.classList.add("textAnnotation");
979 
980     const image = document.createElement("img");
981     image.src =
982       this.imageResourcesPath +
983       "annotation-" +
984       this.data.name.toLowerCase() +
985       ".svg";
986     image.setAttribute("data-l10n-id", "pdfjs-text-annotation-type");
987     image.setAttribute(
988       "data-l10n-args",
989       JSON.stringify({ type: this.data.name })
990     );
991 
992     if (!this.data.popupRef && this.hasPopupData) {
993       this._createPopup();
994     }
995 
996     this.container.append(image);
997     return this.container;
998   }
999 }
1000 
1001 class WidgetAnnotationElement extends AnnotationElement {
1002   render() {
1003     // Show only the container for unsupported field types.
1004     if (this.data.alternativeText) {
1005       this.container.title = this.data.alternativeText;
1006     }
1007 
1008     return this.container;
1009   }
1010 
1011   showElementAndHideCanvas(element) {
1012     if (this.data.hasOwnCanvas) {
1013       if (element.previousSibling?.nodeName === "CANVAS") {
1014         element.previousSibling.hidden = true;
1015       }
1016       element.hidden = false;
1017     }
1018   }
1019 
1020   _getKeyModifier(event) {
1021     return FeatureTest.platform.isMac ? event.metaKey : event.ctrlKey;
1022   }
1023 
1024   _setEventListener(element, elementData, baseName, eventName, valueGetter) {
1025     if (baseName.includes("mouse")) {
1026       // Mouse events
1027       element.addEventListener(baseName, event => {
1028         this.linkService.eventBus?.dispatch("dispatcheventinsandbox", {
1029           source: this,
1030           detail: {
1031             id: this.data.id,
1032             name: eventName,
1033             value: valueGetter(event),
1034             shift: event.shiftKey,
1035             modifier: this._getKeyModifier(event),
1036           },
1037         });
1038       });
1039     } else {
1040       // Non-mouse events
1041       element.addEventListener(baseName, event => {
1042         if (baseName === "blur") {
1043           if (!elementData.focused || !event.relatedTarget) {
1044             return;
1045           }
1046           elementData.focused = false;
1047         } else if (baseName === "focus") {
1048           if (elementData.focused) {
1049             return;
1050           }
1051           elementData.focused = true;
1052         }
1053 
1054         if (!valueGetter) {
1055           return;
1056         }
1057 
1058         this.linkService.eventBus?.dispatch("dispatcheventinsandbox", {
1059           source: this,
1060           detail: {
1061             id: this.data.id,
1062             name: eventName,
1063             value: valueGetter(event),
1064           },
1065         });
1066       });
1067     }
1068   }
1069 
1070   _setEventListeners(element, elementData, names, getter) {
1071     for (const [baseName, eventName] of names) {
1072       if (eventName === "Action" || this.data.actions?.[eventName]) {
1073         if (eventName === "Focus" || eventName === "Blur") {
1074           elementData ||= { focused: false };
1075         }
1076         this._setEventListener(
1077           element,
1078           elementData,
1079           baseName,
1080           eventName,
1081           getter
1082         );
1083         if (eventName === "Focus" && !this.data.actions?.Blur) {
1084           // Ensure that elementData will have the correct value.
1085           this._setEventListener(element, elementData, "blur", "Blur", null);
1086         } else if (eventName === "Blur" && !this.data.actions?.Focus) {
1087           this._setEventListener(element, elementData, "focus", "Focus", null);
1088         }
1089       }
1090     }
1091   }
1092 
1093   _setBackgroundColor(element) {
1094     const color = this.data.backgroundColor || null;
1095     element.style.backgroundColor =
1096       color === null
1097         ? "transparent"
1098         : Util.makeHexColor(color[0], color[1], color[2]);
1099   }
1100 
1101   /**
1102    * Apply text styles to the text in the element.
1103    *
1104    * @private
1105    * @param {HTMLDivElement} element
1106    * @memberof TextWidgetAnnotationElement
1107    */
1108   _setTextStyle(element) {
1109     const TEXT_ALIGNMENT = ["left", "center", "right"];
1110     const { fontColor } = this.data.defaultAppearanceData;
1111     const fontSize =
1112       this.data.defaultAppearanceData.fontSize || DEFAULT_FONT_SIZE;
1113 
1114     const style = element.style;
1115 
1116     // TODO: If the font-size is zero, calculate it based on the height and
1117     //       width of the element.
1118     // Not setting `style.fontSize` will use the default font-size for now.
1119 
1120     // We don't use the font, as specified in the PDF document, for the <input>
1121     // element. Hence using the original `fontSize` could look bad, which is why
1122     // it's instead based on the field height.
1123     // If the height is "big" then it could lead to a too big font size
1124     // so in this case use the one we've in the pdf (hence the min).
1125     let computedFontSize;
1126     const BORDER_SIZE = 2;
1127     const roundToOneDecimal = x => Math.round(10 * x) / 10;
1128     if (this.data.multiLine) {
1129       const height = Math.abs(
1130         this.data.rect[3] - this.data.rect[1] - BORDER_SIZE
1131       );
1132       const numberOfLines = Math.round(height / (LINE_FACTOR * fontSize)) || 1;
1133       const lineHeight = height / numberOfLines;
1134       computedFontSize = Math.min(
1135         fontSize,
1136         roundToOneDecimal(lineHeight / LINE_FACTOR)
1137       );
1138     } else {
1139       const height = Math.abs(
1140         this.data.rect[3] - this.data.rect[1] - BORDER_SIZE
1141       );
1142       computedFontSize = Math.min(
1143         fontSize,
1144         roundToOneDecimal(height / LINE_FACTOR)
1145       );
1146     }
1147     style.fontSize = `calc(${computedFontSize}px * var(--scale-factor))`;
1148 
1149     style.color = Util.makeHexColor(fontColor[0], fontColor[1], fontColor[2]);
1150 
1151     if (this.data.textAlignment !== null) {
1152       style.textAlign = TEXT_ALIGNMENT[this.data.textAlignment];
1153     }
1154   }
1155 
1156   _setRequired(element, isRequired) {
1157     if (isRequired) {
1158       element.setAttribute("required", true);
1159     } else {
1160       element.removeAttribute("required");
1161     }
1162     element.setAttribute("aria-required", isRequired);
1163   }
1164 }
1165 
1166 class TextWidgetAnnotationElement extends WidgetAnnotationElement {
1167   constructor(parameters) {
1168     const isRenderable =
1169       parameters.renderForms ||
1170       parameters.data.hasOwnCanvas ||
1171       (!parameters.data.hasAppearance && !!parameters.data.fieldValue);
1172     super(parameters, { isRenderable });
1173   }
1174 
1175   setPropertyOnSiblings(base, key, value, keyInStorage) {
1176     const storage = this.annotationStorage;
1177     for (const element of this._getElementsByName(
1178       base.name,
1179       /* skipId = */ base.id
1180     )) {
1181       if (element.domElement) {
1182         element.domElement[key] = value;
1183       }
1184       storage.setValue(element.id, { [keyInStorage]: value });
1185     }
1186   }
1187 
1188   render() {
1189     const storage = this.annotationStorage;
1190     const id = this.data.id;
1191 
1192     this.container.classList.add("textWidgetAnnotation");
1193 
1194     let element = null;
1195     if (this.renderForms) {
1196       // NOTE: We cannot set the values using `element.value` below, since it
1197       //       prevents the AnnotationLayer rasterizer in `test/driver.js`
1198       //       from parsing the elements correctly for the reference tests.
1199       const storedData = storage.getValue(id, {
1200         value: this.data.fieldValue,
1201       });
1202       let textContent = storedData.value || "";
1203       const maxLen = storage.getValue(id, {
1204         charLimit: this.data.maxLen,
1205       }).charLimit;
1206       if (maxLen && textContent.length > maxLen) {
1207         textContent = textContent.slice(0, maxLen);
1208       }
1209 
1210       let fieldFormattedValues =
1211         storedData.formattedValue || this.data.textContent?.join("\n") || null;
1212       if (fieldFormattedValues && this.data.comb) {
1213         fieldFormattedValues = fieldFormattedValues.replaceAll(/\s+/g, "");
1214       }
1215 
1216       const elementData = {
1217         userValue: textContent,
1218         formattedValue: fieldFormattedValues,
1219         lastCommittedValue: null,
1220         commitKey: 1,
1221         focused: false,
1222       };
1223 
1224       if (this.data.multiLine) {
1225         element = document.createElement("textarea");
1226         element.textContent = fieldFormattedValues ?? textContent;
1227         if (this.data.doNotScroll) {
1228           element.style.overflowY = "hidden";
1229         }
1230       } else {
1231         element = document.createElement("input");
1232         element.type = "text";
1233         element.setAttribute("value", fieldFormattedValues ?? textContent);
1234         if (this.data.doNotScroll) {
1235           element.style.overflowX = "hidden";
1236         }
1237       }
1238       if (this.data.hasOwnCanvas) {
1239         element.hidden = true;
1240       }
1241       GetElementsByNameSet.add(element);
1242       element.setAttribute("data-element-id", id);
1243 
1244       element.disabled = this.data.readOnly;
1245       element.name = this.data.fieldName;
1246       element.tabIndex = DEFAULT_TAB_INDEX;
1247 
1248       this._setRequired(element, this.data.required);
1249 
1250       if (maxLen) {
1251         element.maxLength = maxLen;
1252       }
1253 
1254       element.addEventListener("input", event => {
1255         storage.setValue(id, { value: event.target.value });
1256         this.setPropertyOnSiblings(
1257           element,
1258           "value",
1259           event.target.value,
1260           "value"
1261         );
1262         elementData.formattedValue = null;
1263       });
1264 
1265       element.addEventListener("resetform", event => {
1266         const defaultValue = this.data.defaultFieldValue ?? "";
1267         element.value = elementData.userValue = defaultValue;
1268         elementData.formattedValue = null;
1269       });
1270 
1271       let blurListener = event => {
1272         const { formattedValue } = elementData;
1273         if (formattedValue !== null && formattedValue !== undefined) {
1274           event.target.value = formattedValue;
1275         }
1276         // Reset the cursor position to the start of the field (issue 12359).
1277         event.target.scrollLeft = 0;
1278       };
1279 
1280       if (this.enableScripting && this.hasJSActions) {
1281         element.addEventListener("focus", event => {
1282           if (elementData.focused) {
1283             return;
1284           }
1285           const { target } = event;
1286           if (elementData.userValue) {
1287             target.value = elementData.userValue;
1288           }
1289           elementData.lastCommittedValue = target.value;
1290           elementData.commitKey = 1;
1291           if (!this.data.actions?.Focus) {
1292             elementData.focused = true;
1293           }
1294         });
1295 
1296         element.addEventListener("updatefromsandbox", jsEvent => {
1297           this.showElementAndHideCanvas(jsEvent.target);
1298           const actions = {
1299             value(event) {
1300               elementData.userValue = event.detail.value ?? "";
1301               storage.setValue(id, { value: elementData.userValue.toString() });
1302               event.target.value = elementData.userValue;
1303             },
1304             formattedValue(event) {
1305               const { formattedValue } = event.detail;
1306               elementData.formattedValue = formattedValue;
1307               if (
1308                 formattedValue !== null &&
1309                 formattedValue !== undefined &&
1310                 event.target !== document.activeElement
1311               ) {
1312                 // Input hasn't the focus so display formatted string
1313                 event.target.value = formattedValue;
1314               }
1315               storage.setValue(id, {
1316                 formattedValue,
1317               });
1318             },
1319             selRange(event) {
1320               event.target.setSelectionRange(...event.detail.selRange);
1321             },
1322             charLimit: event => {
1323               const { charLimit } = event.detail;
1324               const { target } = event;
1325               if (charLimit === 0) {
1326                 target.removeAttribute("maxLength");
1327                 return;
1328               }
1329 
1330               target.setAttribute("maxLength", charLimit);
1331               let value = elementData.userValue;
1332               if (!value || value.length <= charLimit) {
1333                 return;
1334               }
1335               value = value.slice(0, charLimit);
1336               target.value = elementData.userValue = value;
1337               storage.setValue(id, { value });
1338 
1339               this.linkService.eventBus?.dispatch("dispatcheventinsandbox", {
1340                 source: this,
1341                 detail: {
1342                   id,
1343                   name: "Keystroke",
1344                   value,
1345                   willCommit: true,
1346                   commitKey: 1,
1347                   selStart: target.selectionStart,
1348                   selEnd: target.selectionEnd,
1349                 },
1350               });
1351             },
1352           };
1353           this._dispatchEventFromSandbox(actions, jsEvent);
1354         });
1355 
1356         // Even if the field hasn't any actions
1357         // leaving it can still trigger some actions with Calculate
1358         element.addEventListener("keydown", event => {
1359           elementData.commitKey = 1;
1360           // If the key is one of Escape, Enter then the data are committed.
1361           // If we've a Tab then data will be committed on blur.
1362           let commitKey = -1;
1363           if (event.key === "Escape") {
1364             commitKey = 0;
1365           } else if (event.key === "Enter" && !this.data.multiLine) {
1366             // When we've a multiline field, "Enter" key is a key as the other
1367             // hence we don't commit the data (Acrobat behaves the same way)
1368             // (see issue #15627).
1369             commitKey = 2;
1370           } else if (event.key === "Tab") {
1371             elementData.commitKey = 3;
1372           }
1373           if (commitKey === -1) {
1374             return;
1375           }
1376           const { value } = event.target;
1377           if (elementData.lastCommittedValue === value) {
1378             return;
1379           }
1380           elementData.lastCommittedValue = value;
1381           // Save the entered value
1382           elementData.userValue = value;
1383           this.linkService.eventBus?.dispatch("dispatcheventinsandbox", {
1384             source: this,
1385             detail: {
1386               id,
1387               name: "Keystroke",
1388               value,
1389               willCommit: true,
1390               commitKey,
1391               selStart: event.target.selectionStart,
1392               selEnd: event.target.selectionEnd,
1393             },
1394           });
1395         });
1396         const _blurListener = blurListener;
1397         blurListener = null;
1398         element.addEventListener("blur", event => {
1399           if (!elementData.focused || !event.relatedTarget) {
1400             return;
1401           }
1402           if (!this.data.actions?.Blur) {
1403             elementData.focused = false;
1404           }
1405           const { value } = event.target;
1406           elementData.userValue = value;
1407           if (elementData.lastCommittedValue !== value) {
1408             this.linkService.eventBus?.dispatch("dispatcheventinsandbox", {
1409               source: this,
1410               detail: {
1411                 id,
1412                 name: "Keystroke",
1413                 value,
1414                 willCommit: true,
1415                 commitKey: elementData.commitKey,
1416                 selStart: event.target.selectionStart,
1417                 selEnd: event.target.selectionEnd,
1418               },
1419             });
1420           }
1421           _blurListener(event);
1422         });
1423 
1424         if (this.data.actions?.Keystroke) {
1425           element.addEventListener("beforeinput", event => {
1426             elementData.lastCommittedValue = null;
1427             const { data, target } = event;
1428             const { value, selectionStart, selectionEnd } = target;
1429 
1430             let selStart = selectionStart,
1431               selEnd = selectionEnd;
1432 
1433             switch (event.inputType) {
1434               // https://rawgit.com/w3c/input-events/v1/index.html#interface-InputEvent-Attributes
1435               case "deleteWordBackward": {
1436                 const match = value
1437                   .substring(0, selectionStart)
1438                   .match(/\w*[^\w]*$/);
1439                 if (match) {
1440                   selStart -= match[0].length;
1441                 }
1442                 break;
1443               }
1444               case "deleteWordForward": {
1445                 const match = value
1446                   .substring(selectionStart)
1447                   .match(/^[^\w]*\w*/);
1448                 if (match) {
1449                   selEnd += match[0].length;
1450                 }
1451                 break;
1452               }
1453               case "deleteContentBackward":
1454                 if (selectionStart === selectionEnd) {
1455                   selStart -= 1;
1456                 }
1457                 break;
1458               case "deleteContentForward":
1459                 if (selectionStart === selectionEnd) {
1460                   selEnd += 1;
1461                 }
1462                 break;
1463             }
1464 
1465             // We handle the event ourselves.
1466             event.preventDefault();
1467             this.linkService.eventBus?.dispatch("dispatcheventinsandbox", {
1468               source: this,
1469               detail: {
1470                 id,
1471                 name: "Keystroke",
1472                 value,
1473                 change: data || "",
1474                 willCommit: false,
1475                 selStart,
1476                 selEnd,
1477               },
1478             });
1479           });
1480         }
1481 
1482         this._setEventListeners(
1483           element,
1484           elementData,
1485           [
1486             ["focus", "Focus"],
1487             ["blur", "Blur"],
1488             ["mousedown", "Mouse Down"],
1489             ["mouseenter", "Mouse Enter"],
1490             ["mouseleave", "Mouse Exit"],
1491             ["mouseup", "Mouse Up"],
1492           ],
1493           event => event.target.value
1494         );
1495       }
1496 
1497       if (blurListener) {
1498         element.addEventListener("blur", blurListener);
1499       }
1500 
1501       if (this.data.comb) {
1502         const fieldWidth = this.data.rect[2] - this.data.rect[0];
1503         const combWidth = fieldWidth / maxLen;
1504 
1505         element.classList.add("comb");
1506         element.style.letterSpacing = `calc(${combWidth}px * var(--scale-factor) - 1ch)`;
1507       }
1508     } else {
1509       element = document.createElement("div");
1510       element.textContent = this.data.fieldValue;
1511       element.style.verticalAlign = "middle";
1512       element.style.display = "table-cell";
1513 
1514       if (this.data.hasOwnCanvas) {
1515         element.hidden = true;
1516       }
1517     }
1518 
1519     this._setTextStyle(element);
1520     this._setBackgroundColor(element);
1521     this._setDefaultPropertiesFromJS(element);
1522 
1523     this.container.append(element);
1524     return this.container;
1525   }
1526 }
1527 
1528 class SignatureWidgetAnnotationElement extends WidgetAnnotationElement {
1529   constructor(parameters) {
1530     super(parameters, { isRenderable: !!parameters.data.hasOwnCanvas });
1531   }
1532 }
1533 
1534 class CheckboxWidgetAnnotationElement extends WidgetAnnotationElement {
1535   constructor(parameters) {
1536     super(parameters, { isRenderable: parameters.renderForms });
1537   }
1538 
1539   render() {
1540     const storage = this.annotationStorage;
1541     const data = this.data;
1542     const id = data.id;
1543     let value = storage.getValue(id, {
1544       value: data.exportValue === data.fieldValue,
1545     }).value;
1546     if (typeof value === "string") {
1547       // The value has been changed through js and set in annotationStorage.
1548       value = value !== "Off";
1549       storage.setValue(id, { value });
1550     }
1551 
1552     this.container.classList.add("buttonWidgetAnnotation", "checkBox");
1553 
1554     const element = document.createElement("input");
1555     GetElementsByNameSet.add(element);
1556     element.setAttribute("data-element-id", id);
1557 
1558     element.disabled = data.readOnly;
1559     this._setRequired(element, this.data.required);
1560     element.type = "checkbox";
1561     element.name = data.fieldName;
1562     if (value) {
1563       element.setAttribute("checked", true);
1564     }
1565     element.setAttribute("exportValue", data.exportValue);
1566     element.tabIndex = DEFAULT_TAB_INDEX;
1567 
1568     element.addEventListener("change", event => {
1569       const { name, checked } = event.target;
1570       for (const checkbox of this._getElementsByName(name, /* skipId = */ id)) {
1571         const curChecked = checked && checkbox.exportValue === data.exportValue;
1572         if (checkbox.domElement) {
1573           checkbox.domElement.checked = curChecked;
1574         }
1575         storage.setValue(checkbox.id, { value: curChecked });
1576       }
1577       storage.setValue(id, { value: checked });
1578     });
1579 
1580     element.addEventListener("resetform", event => {
1581       const defaultValue = data.defaultFieldValue || "Off";
1582       event.target.checked = defaultValue === data.exportValue;
1583     });
1584 
1585     if (this.enableScripting && this.hasJSActions) {
1586       element.addEventListener("updatefromsandbox", jsEvent => {
1587         const actions = {
1588           value(event) {
1589             event.target.checked = event.detail.value !== "Off";
1590             storage.setValue(id, { value: event.target.checked });
1591           },
1592         };
1593         this._dispatchEventFromSandbox(actions, jsEvent);
1594       });
1595 
1596       this._setEventListeners(
1597         element,
1598         null,
1599         [
1600           ["change", "Validate"],
1601           ["change", "Action"],
1602           ["focus", "Focus"],
1603           ["blur", "Blur"],
1604           ["mousedown", "Mouse Down"],
1605           ["mouseenter", "Mouse Enter"],
1606           ["mouseleave", "Mouse Exit"],
1607           ["mouseup", "Mouse Up"],
1608         ],
1609         event => event.target.checked
1610       );
1611     }
1612 
1613     this._setBackgroundColor(element);
1614     this._setDefaultPropertiesFromJS(element);
1615 
1616     this.container.append(element);
1617     return this.container;
1618   }
1619 }
1620 
1621 class RadioButtonWidgetAnnotationElement extends WidgetAnnotationElement {
1622   constructor(parameters) {
1623     super(parameters, { isRenderable: parameters.renderForms });
1624   }
1625 
1626   render() {
1627     this.container.classList.add("buttonWidgetAnnotation", "radioButton");
1628     const storage = this.annotationStorage;
1629     const data = this.data;
1630     const id = data.id;
1631     let value = storage.getValue(id, {
1632       value: data.fieldValue === data.buttonValue,
1633     }).value;
1634     if (typeof value === "string") {
1635       // The value has been changed through js and set in annotationStorage.
1636       value = value !== data.buttonValue;
1637       storage.setValue(id, { value });
1638     }
1639 
1640     if (value) {
1641       // It's possible that multiple radio buttons are checked.
1642       // So if this one is checked we just reset the other ones.
1643       // (see bug 1864136). Then when the other ones will be rendered they will
1644       // unchecked (because of their value in the storage).
1645       // Consequently, the first checked radio button will be the only checked
1646       // one.
1647       for (const radio of this._getElementsByName(
1648         data.fieldName,
1649         /* skipId = */ id
1650       )) {
1651         storage.setValue(radio.id, { value: false });
1652       }
1653     }
1654 
1655     const element = document.createElement("input");
1656     GetElementsByNameSet.add(element);
1657     element.setAttribute("data-element-id", id);
1658 
1659     element.disabled = data.readOnly;
1660     this._setRequired(element, this.data.required);
1661     element.type = "radio";
1662     element.name = data.fieldName;
1663     if (value) {
1664       element.setAttribute("checked", true);
1665     }
1666     element.tabIndex = DEFAULT_TAB_INDEX;
1667 
1668     element.addEventListener("change", event => {
1669       const { name, checked } = event.target;
1670       for (const radio of this._getElementsByName(name, /* skipId = */ id)) {
1671         storage.setValue(radio.id, { value: false });
1672       }
1673       storage.setValue(id, { value: checked });
1674     });
1675 
1676     element.addEventListener("resetform", event => {
1677       const defaultValue = data.defaultFieldValue;
1678       event.target.checked =
1679         defaultValue !== null &&
1680         defaultValue !== undefined &&
1681         defaultValue === data.buttonValue;
1682     });
1683 
1684     if (this.enableScripting && this.hasJSActions) {
1685       const pdfButtonValue = data.buttonValue;
1686       element.addEventListener("updatefromsandbox", jsEvent => {
1687         const actions = {
1688           value: event => {
1689             const checked = pdfButtonValue === event.detail.value;
1690             for (const radio of this._getElementsByName(event.target.name)) {
1691               const curChecked = checked && radio.id === id;
1692               if (radio.domElement) {
1693                 radio.domElement.checked = curChecked;
1694               }
1695               storage.setValue(radio.id, { value: curChecked });
1696             }
1697           },
1698         };
1699         this._dispatchEventFromSandbox(actions, jsEvent);
1700       });
1701 
1702       this._setEventListeners(
1703         element,
1704         null,
1705         [
1706           ["change", "Validate"],
1707           ["change", "Action"],
1708           ["focus", "Focus"],
1709           ["blur", "Blur"],
1710           ["mousedown", "Mouse Down"],
1711           ["mouseenter", "Mouse Enter"],
1712           ["mouseleave", "Mouse Exit"],
1713           ["mouseup", "Mouse Up"],
1714         ],
1715         event => event.target.checked
1716       );
1717     }
1718 
1719     this._setBackgroundColor(element);
1720     this._setDefaultPropertiesFromJS(element);
1721 
1722     this.container.append(element);
1723     return this.container;
1724   }
1725 }
1726 
1727 class PushButtonWidgetAnnotationElement extends LinkAnnotationElement {
1728   constructor(parameters) {
1729     super(parameters, { ignoreBorder: parameters.data.hasAppearance });
1730   }
1731 
1732   render() {
1733     // The rendering and functionality of a push button widget annotation is
1734     // equal to that of a link annotation, but may have more functionality, such
1735     // as performing actions on form fields (resetting, submitting, et cetera).
1736     const container = super.render();
1737     container.classList.add("buttonWidgetAnnotation", "pushButton");
1738 
1739     if (this.data.alternativeText) {
1740       container.title = this.data.alternativeText;
1741     }
1742 
1743     const linkElement = container.lastChild;
1744     if (this.enableScripting && this.hasJSActions && linkElement) {
1745       this._setDefaultPropertiesFromJS(linkElement);
1746 
1747       linkElement.addEventListener("updatefromsandbox", jsEvent => {
1748         this._dispatchEventFromSandbox({}, jsEvent);
1749       });
1750     }
1751 
1752     return container;
1753   }
1754 }
1755 
1756 class ChoiceWidgetAnnotationElement extends WidgetAnnotationElement {
1757   constructor(parameters) {
1758     super(parameters, { isRenderable: parameters.renderForms });
1759   }
1760 
1761   render() {
1762     this.container.classList.add("choiceWidgetAnnotation");
1763     const storage = this.annotationStorage;
1764     const id = this.data.id;
1765 
1766     const storedData = storage.getValue(id, {
1767       value: this.data.fieldValue,
1768     });
1769 
1770     const selectElement = document.createElement("select");
1771     GetElementsByNameSet.add(selectElement);
1772     selectElement.setAttribute("data-element-id", id);
1773 
1774     selectElement.disabled = this.data.readOnly;
1775     this._setRequired(selectElement, this.data.required);
1776     selectElement.name = this.data.fieldName;
1777     selectElement.tabIndex = DEFAULT_TAB_INDEX;
1778 
1779     let addAnEmptyEntry = this.data.combo && this.data.options.length > 0;
1780 
1781     if (!this.data.combo) {
1782       // List boxes have a size and (optionally) multiple selection.
1783       selectElement.size = this.data.options.length;
1784       if (this.data.multiSelect) {
1785         selectElement.multiple = true;
1786       }
1787     }
1788 
1789     selectElement.addEventListener("resetform", event => {
1790       const defaultValue = this.data.defaultFieldValue;
1791       for (const option of selectElement.options) {
1792         option.selected = option.value === defaultValue;
1793       }
1794     });
1795 
1796     // Insert the options into the choice field.
1797     for (const option of this.data.options) {
1798       const optionElement = document.createElement("option");
1799       optionElement.textContent = option.displayValue;
1800       optionElement.value = option.exportValue;
1801       if (storedData.value.includes(option.exportValue)) {
1802         optionElement.setAttribute("selected", true);
1803         addAnEmptyEntry = false;
1804       }
1805       selectElement.append(optionElement);
1806     }
1807 
1808     let removeEmptyEntry = null;
1809     if (addAnEmptyEntry) {
1810       const noneOptionElement = document.createElement("option");
1811       noneOptionElement.value = " ";
1812       noneOptionElement.setAttribute("hidden", true);
1813       noneOptionElement.setAttribute("selected", true);
1814       selectElement.prepend(noneOptionElement);
1815 
1816       removeEmptyEntry = () => {
1817         noneOptionElement.remove();
1818         selectElement.removeEventListener("input", removeEmptyEntry);
1819         removeEmptyEntry = null;
1820       };
1821       selectElement.addEventListener("input", removeEmptyEntry);
1822     }
1823 
1824     const getValue = isExport => {
1825       const name = isExport ? "value" : "textContent";
1826       const { options, multiple } = selectElement;
1827       if (!multiple) {
1828         return options.selectedIndex === -1
1829           ? null
1830           : options[options.selectedIndex][name];
1831       }
1832       return Array.prototype.filter
1833         .call(options, option => option.selected)
1834         .map(option => option[name]);
1835     };
1836 
1837     let selectedValues = getValue(/* isExport */ false);
1838 
1839     const getItems = event => {
1840       const options = event.target.options;
1841       return Array.prototype.map.call(options, option => ({
1842         displayValue: option.textContent,
1843         exportValue: option.value,
1844       }));
1845     };
1846 
1847     if (this.enableScripting && this.hasJSActions) {
1848       selectElement.addEventListener("updatefromsandbox", jsEvent => {
1849         const actions = {
1850           value(event) {
1851             removeEmptyEntry?.();
1852             const value = event.detail.value;
1853             const values = new Set(Array.isArray(value) ? value : [value]);
1854             for (const option of selectElement.options) {
1855               option.selected = values.has(option.value);
1856             }
1857             storage.setValue(id, {
1858               value: getValue(/* isExport */ true),
1859             });
1860             selectedValues = getValue(/* isExport */ false);
1861           },
1862           multipleSelection(event) {
1863             selectElement.multiple = true;
1864           },
1865           remove(event) {
1866             const options = selectElement.options;
1867             const index = event.detail.remove;
1868             options[index].selected = false;
1869             selectElement.remove(index);
1870             if (options.length > 0) {
1871               const i = Array.prototype.findIndex.call(
1872                 options,
1873                 option => option.selected
1874               );
1875               if (i === -1) {
1876                 options[0].selected = true;
1877               }
1878             }
1879             storage.setValue(id, {
1880               value: getValue(/* isExport */ true),
1881               items: getItems(event),
1882             });
1883             selectedValues = getValue(/* isExport */ false);
1884           },
1885           clear(event) {
1886             while (selectElement.length !== 0) {
1887               selectElement.remove(0);
1888             }
1889             storage.setValue(id, { value: null, items: [] });
1890             selectedValues = getValue(/* isExport */ false);
1891           },
1892           insert(event) {
1893             const { index, displayValue, exportValue } = event.detail.insert;
1894             const selectChild = selectElement.children[index];
1895             const optionElement = document.createElement("option");
1896             optionElement.textContent = displayValue;
1897             optionElement.value = exportValue;
1898 
1899             if (selectChild) {
1900               selectChild.before(optionElement);
1901             } else {
1902               selectElement.append(optionElement);
1903             }
1904             storage.setValue(id, {
1905               value: getValue(/* isExport */ true),
1906               items: getItems(event),
1907             });
1908             selectedValues = getValue(/* isExport */ false);
1909           },
1910           items(event) {
1911             const { items } = event.detail;
1912             while (selectElement.length !== 0) {
1913               selectElement.remove(0);
1914             }
1915             for (const item of items) {
1916               const { displayValue, exportValue } = item;
1917               const optionElement = document.createElement("option");
1918               optionElement.textContent = displayValue;
1919               optionElement.value = exportValue;
1920               selectElement.append(optionElement);
1921             }
1922             if (selectElement.options.length > 0) {
1923               selectElement.options[0].selected = true;
1924             }
1925             storage.setValue(id, {
1926               value: getValue(/* isExport */ true),
1927               items: getItems(event),
1928             });
1929             selectedValues = getValue(/* isExport */ false);
1930           },
1931           indices(event) {
1932             const indices = new Set(event.detail.indices);
1933             for (const option of event.target.options) {
1934               option.selected = indices.has(option.index);
1935             }
1936             storage.setValue(id, {
1937               value: getValue(/* isExport */ true),
1938             });
1939             selectedValues = getValue(/* isExport */ false);
1940           },
1941           editable(event) {
1942             event.target.disabled = !event.detail.editable;
1943           },
1944         };
1945         this._dispatchEventFromSandbox(actions, jsEvent);
1946       });
1947 
1948       selectElement.addEventListener("input", event => {
1949         const exportValue = getValue(/* isExport */ true);
1950         storage.setValue(id, { value: exportValue });
1951 
1952         event.preventDefault();
1953 
1954         this.linkService.eventBus?.dispatch("dispatcheventinsandbox", {
1955           source: this,
1956           detail: {
1957             id,
1958             name: "Keystroke",
1959             value: selectedValues,
1960             changeEx: exportValue,
1961             willCommit: false,
1962             commitKey: 1,
1963             keyDown: false,
1964           },
1965         });
1966       });
1967 
1968       this._setEventListeners(
1969         selectElement,
1970         null,
1971         [
1972           ["focus", "Focus"],
1973           ["blur", "Blur"],
1974           ["mousedown", "Mouse Down"],
1975           ["mouseenter", "Mouse Enter"],
1976           ["mouseleave", "Mouse Exit"],
1977           ["mouseup", "Mouse Up"],
1978           ["input", "Action"],
1979           ["input", "Validate"],
1980         ],
1981         event => event.target.value
1982       );
1983     } else {
1984       selectElement.addEventListener("input", function (event) {
1985         storage.setValue(id, { value: getValue(/* isExport */ true) });
1986       });
1987     }
1988 
1989     if (this.data.combo) {
1990       this._setTextStyle(selectElement);
1991     } else {
1992       // Just use the default font size...
1993       // it's a bit hard to guess what is a good size.
1994     }
1995     this._setBackgroundColor(selectElement);
1996     this._setDefaultPropertiesFromJS(selectElement);
1997 
1998     this.container.append(selectElement);
1999     return this.container;
2000   }
2001 }
2002 
2003 class PopupAnnotationElement extends AnnotationElement {
2004   constructor(parameters) {
2005     const { data, elements } = parameters;
2006     super(parameters, { isRenderable: AnnotationElement._hasPopupData(data) });
2007     this.elements = elements;
2008   }
2009 
2010   render() {
2011     this.container.classList.add("popupAnnotation");
2012 
2013     const popup = new PopupElement({
2014       container: this.container,
2015       color: this.data.color,
2016       titleObj: this.data.titleObj,
2017       modificationDate: this.data.modificationDate,
2018       contentsObj: this.data.contentsObj,
2019       richText: this.data.richText,
2020       rect: this.data.rect,
2021       parentRect: this.data.parentRect || null,
2022       parent: this.parent,
2023       elements: this.elements,
2024       open: this.data.open,
2025     });
2026 
2027     const elementIds = [];
2028     for (const element of this.elements) {
2029       element.popup = popup;
2030       elementIds.push(element.data.id);
2031       element.addHighlightArea();
2032     }
2033 
2034     this.container.setAttribute(
2035       "aria-controls",
2036       elementIds.map(id => `${AnnotationPrefix}${id}`).join(",")
2037     );
2038 
2039     return this.container;
2040   }
2041 }
2042 
2043 class PopupElement {
2044   #boundKeyDown = this.#keyDown.bind(this);
2045 
2046   #boundHide = this.#hide.bind(this);
2047 
2048   #boundShow = this.#show.bind(this);
2049 
2050   #boundToggle = this.#toggle.bind(this);
2051 
2052   #color = null;
2053 
2054   #container = null;
2055 
2056   #contentsObj = null;
2057 
2058   #dateObj = null;
2059 
2060   #elements = null;
2061 
2062   #parent = null;
2063 
2064   #parentRect = null;
2065 
2066   #pinned = false;
2067 
2068   #popup = null;
2069 
2070   #rect = null;
2071 
2072   #richText = null;
2073 
2074   #titleObj = null;
2075 
2076   #wasVisible = false;
2077 
2078   constructor({
2079     container,
2080     color,
2081     elements,
2082     titleObj,
2083     modificationDate,
2084     contentsObj,
2085     richText,
2086     parent,
2087     rect,
2088     parentRect,
2089     open,
2090   }) {
2091     this.#container = container;
2092     this.#titleObj = titleObj;
2093     this.#contentsObj = contentsObj;
2094     this.#richText = richText;
2095     this.#parent = parent;
2096     this.#color = color;
2097     this.#rect = rect;
2098     this.#parentRect = parentRect;
2099     this.#elements = elements;
2100 
2101     // The modification date is shown in the popup instead of the creation
2102     // date if it is available and can be parsed correctly, which is
2103     // consistent with other viewers such as Adobe Acrobat.
2104     this.#dateObj = PDFDateString.toDateObject(modificationDate);
2105 
2106     this.trigger = elements.flatMap(e => e.getElementsToTriggerPopup());
2107     // Attach the event listeners to the trigger element.
2108     for (const element of this.trigger) {
2109       element.addEventListener("click", this.#boundToggle);
2110       element.addEventListener("mouseenter", this.#boundShow);
2111       element.addEventListener("mouseleave", this.#boundHide);
2112       element.classList.add("popupTriggerArea");
2113     }
2114 
2115     // Attach the event listener to toggle the popup with the keyboard.
2116     for (const element of elements) {
2117       element.container?.addEventListener("keydown", this.#boundKeyDown);
2118     }
2119 
2120     this.#container.hidden = true;
2121     if (open) {
2122       this.#toggle();
2123     }
2124 
2125     if (typeof PDFJSDev !== "undefined" && PDFJSDev.test("TESTING")) {
2126       // Since the popup is lazily created, we need to ensure that it'll be
2127       // created and displayed during reference tests.
2128       this.#parent.popupShow.push(async () => {
2129         if (this.#container.hidden) {
2130           this.#show();
2131         }
2132       });
2133     }
2134   }
2135 
2136   render() {
2137     if (this.#popup) {
2138       return;
2139     }
2140 
2141     const {
2142       page: { view },
2143       viewport: {
2144         rawDims: { pageWidth, pageHeight, pageX, pageY },
2145       },
2146     } = this.#parent;
2147     const popup = (this.#popup = document.createElement("div"));
2148     popup.className = "popup";
2149 
2150     if (this.#color) {
2151       const baseColor = (popup.style.outlineColor = Util.makeHexColor(
2152         ...this.#color
2153       ));
2154       if (
2155         (typeof PDFJSDev !== "undefined" && PDFJSDev.test("MOZCENTRAL")) ||
2156         CSS.supports("background-color", "color-mix(in srgb, red 30%, white)")
2157       ) {
2158         popup.style.backgroundColor = `color-mix(in srgb, ${baseColor} 30%, white)`;
2159       } else {
2160         // color-mix isn't supported in some browsers hence this version.
2161         // See https://developer.mozilla.org/en-US/docs/Web/CSS/color_value/color-mix#browser_compatibility
2162         // TODO: Use color-mix when it's supported everywhere.
2163         // Enlighten the color.
2164         const BACKGROUND_ENLIGHT = 0.7;
2165         popup.style.backgroundColor = Util.makeHexColor(
2166           ...this.#color.map(c =>
2167             Math.floor(BACKGROUND_ENLIGHT * (255 - c) + c)
2168           )
2169         );
2170       }
2171     }
2172 
2173     const header = document.createElement("span");
2174     header.className = "header";
2175     const title = document.createElement("h1");
2176     header.append(title);
2177     ({ dir: title.dir, str: title.textContent } = this.#titleObj);
2178     popup.append(header);
2179 
2180     if (this.#dateObj) {
2181       const modificationDate = document.createElement("span");
2182       modificationDate.classList.add("popupDate");
2183       modificationDate.setAttribute(
2184         "data-l10n-id",
2185         "pdfjs-annotation-date-string"
2186       );
2187       modificationDate.setAttribute(
2188         "data-l10n-args",
2189         JSON.stringify({
2190           date: this.#dateObj.toLocaleDateString(),
2191           time: this.#dateObj.toLocaleTimeString(),
2192         })
2193       );
2194       header.append(modificationDate);
2195     }
2196 
2197     const contentsObj = this.#contentsObj;
2198     const richText = this.#richText;
2199     if (
2200       richText?.str &&
2201       (!contentsObj?.str || contentsObj.str === richText.str)
2202     ) {
2203       XfaLayer.render({
2204         xfaHtml: richText.html,
2205         intent: "richText",
2206         div: popup,
2207       });
2208       popup.lastChild.classList.add("richText", "popupContent");
2209     } else {
2210       const contents = this._formatContents(contentsObj);
2211       popup.append(contents);
2212     }
2213 
2214     let useParentRect = !!this.#parentRect;
2215     let rect = useParentRect ? this.#parentRect : this.#rect;
2216     for (const element of this.#elements) {
2217       if (!rect || Util.intersect(element.data.rect, rect) !== null) {
2218         rect = element.data.rect;
2219         useParentRect = true;
2220         break;
2221       }
2222     }
2223 
2224     const normalizedRect = Util.normalizeRect([
2225       rect[0],
2226       view[3] - rect[1] + view[1],
2227       rect[2],
2228       view[3] - rect[3] + view[1],
2229     ]);
2230 
2231     const HORIZONTAL_SPACE_AFTER_ANNOTATION = 5;
2232     const parentWidth = useParentRect
2233       ? rect[2] - rect[0] + HORIZONTAL_SPACE_AFTER_ANNOTATION
2234       : 0;
2235     const popupLeft = normalizedRect[0] + parentWidth;
2236     const popupTop = normalizedRect[1];
2237 
2238     const { style } = this.#container;
2239     style.left = `${(100 * (popupLeft - pageX)) / pageWidth}%`;
2240     style.top = `${(100 * (popupTop - pageY)) / pageHeight}%`;
2241 
2242     this.#container.append(popup);
2243   }
2244 
2245   /**
2246    * Format the contents of the popup by adding newlines where necessary.
2247    *
2248    * @private
2249    * @param {Object<string, string>} contentsObj
2250    * @memberof PopupElement
2251    * @returns {HTMLParagraphElement}
2252    */
2253   _formatContents({ str, dir }) {
2254     const p = document.createElement("p");
2255     p.classList.add("popupContent");
2256     p.dir = dir;
2257     const lines = str.split(/(?:\r\n?|\n)/);
2258     for (let i = 0, ii = lines.length; i < ii; ++i) {
2259       const line = lines[i];
2260       p.append(document.createTextNode(line));
2261       if (i < ii - 1) {
2262         p.append(document.createElement("br"));
2263       }
2264     }
2265     return p;
2266   }
2267 
2268   #keyDown(event) {
2269     if (event.altKey || event.shiftKey || event.ctrlKey || event.metaKey) {
2270       return;
2271     }
2272 
2273     if (event.key === "Enter" || (event.key === "Escape" && this.#pinned)) {
2274       this.#toggle();
2275     }
2276   }
2277 
2278   /**
2279    * Toggle the visibility of the popup.
2280    */
2281   #toggle() {
2282     this.#pinned = !this.#pinned;
2283     if (this.#pinned) {
2284       this.#show();
2285       this.#container.addEventListener("click", this.#boundToggle);
2286       this.#container.addEventListener("keydown", this.#boundKeyDown);
2287     } else {
2288       this.#hide();
2289       this.#container.removeEventListener("click", this.#boundToggle);
2290       this.#container.removeEventListener("keydown", this.#boundKeyDown);
2291     }
2292   }
2293 
2294   /**
2295    * Show the popup.
2296    */
2297   #show() {
2298     if (!this.#popup) {
2299       this.render();
2300     }
2301     if (!this.isVisible) {
2302       this.#container.hidden = false;
2303       this.#container.style.zIndex =
2304         parseInt(this.#container.style.zIndex) + 1000;
2305     } else if (this.#pinned) {
2306       this.#container.classList.add("focused");
2307     }
2308   }
2309 
2310   /**
2311    * Hide the popup.
2312    */
2313   #hide() {
2314     this.#container.classList.remove("focused");
2315     if (this.#pinned || !this.isVisible) {
2316       return;
2317     }
2318     this.#container.hidden = true;
2319     this.#container.style.zIndex =
2320       parseInt(this.#container.style.zIndex) - 1000;
2321   }
2322 
2323   forceHide() {
2324     this.#wasVisible = this.isVisible;
2325     if (!this.#wasVisible) {
2326       return;
2327     }
2328     this.#container.hidden = true;
2329   }
2330 
2331   maybeShow() {
2332     if (!this.#wasVisible) {
2333       return;
2334     }
2335     this.#wasVisible = false;
2336     this.#container.hidden = false;
2337   }
2338 
2339   get isVisible() {
2340     return this.#container.hidden === false;
2341   }
2342 }
2343 
2344 class FreeTextAnnotationElement extends AnnotationElement {
2345   constructor(parameters) {
2346     super(parameters, { isRenderable: true, ignoreBorder: true });
2347     this.textContent = parameters.data.textContent;
2348     this.textPosition = parameters.data.textPosition;
2349     this.annotationEditorType = AnnotationEditorType.FREETEXT;
2350   }
2351 
2352   render() {
2353     this.container.classList.add("freeTextAnnotation");
2354 
2355     if (this.textContent) {
2356       const content = document.createElement("div");
2357       content.classList.add("annotationTextContent");
2358       content.setAttribute("role", "comment");
2359       for (const line of this.textContent) {
2360         const lineSpan = document.createElement("span");
2361         lineSpan.textContent = line;
2362         content.append(lineSpan);
2363       }
2364       this.container.append(content);
2365     }
2366 
2367     if (!this.data.popupRef && this.hasPopupData) {
2368       this._createPopup();
2369     }
2370 
2371     this._editOnDoubleClick();
2372 
2373     return this.container;
2374   }
2375 
2376   get _isEditable() {
2377     return this.data.hasOwnCanvas;
2378   }
2379 }
2380 
2381 class LineAnnotationElement extends AnnotationElement {
2382   #line = null;
2383 
2384   constructor(parameters) {
2385     super(parameters, { isRenderable: true, ignoreBorder: true });
2386   }
2387 
2388   render() {
2389     this.container.classList.add("lineAnnotation");
2390 
2391     // Create an invisible line with the same starting and ending coordinates
2392     // that acts as the trigger for the popup. Only the line itself should
2393     // trigger the popup, not the entire container.
2394     const data = this.data;
2395     const { width, height } = getRectDims(data.rect);
2396     const svg = this.svgFactory.create(
2397       width,
2398       height,
2399       /* skipDimensions = */ true
2400     );
2401 
2402     // PDF coordinates are calculated from a bottom left origin, so transform
2403     // the line coordinates to a top left origin for the SVG element.
2404     const line = (this.#line = this.svgFactory.createElement("svg:line"));
2405     line.setAttribute("x1", data.rect[2] - data.lineCoordinates[0]);
2406     line.setAttribute("y1", data.rect[3] - data.lineCoordinates[1]);
2407     line.setAttribute("x2", data.rect[2] - data.lineCoordinates[2]);
2408     line.setAttribute("y2", data.rect[3] - data.lineCoordinates[3]);
2409     // Ensure that the 'stroke-width' is always non-zero, since otherwise it
2410     // won't be possible to open/close the popup (note e.g. issue 11122).
2411     line.setAttribute("stroke-width", data.borderStyle.width || 1);
2412     line.setAttribute("stroke", "transparent");
2413     line.setAttribute("fill", "transparent");
2414 
2415     svg.append(line);
2416     this.container.append(svg);
2417 
2418     // Create the popup ourselves so that we can bind it to the line instead
2419     // of to the entire container (which is the default).
2420     if (!data.popupRef && this.hasPopupData) {
2421       this._createPopup();
2422     }
2423 
2424     return this.container;
2425   }
2426 
2427   getElementsToTriggerPopup() {
2428     return this.#line;
2429   }
2430 
2431   addHighlightArea() {
2432     this.container.classList.add("highlightArea");
2433   }
2434 }
2435 
2436 class SquareAnnotationElement extends AnnotationElement {
2437   #square = null;
2438 
2439   constructor(parameters) {
2440     super(parameters, { isRenderable: true, ignoreBorder: true });
2441   }
2442 
2443   render() {
2444     this.container.classList.add("squareAnnotation");
2445 
2446     // Create an invisible square with the same rectangle that acts as the
2447     // trigger for the popup. Only the square itself should trigger the
2448     // popup, not the entire container.
2449     const data = this.data;
2450     const { width, height } = getRectDims(data.rect);
2451     const svg = this.svgFactory.create(
2452       width,
2453       height,
2454       /* skipDimensions = */ true
2455     );
2456 
2457     // The browser draws half of the borders inside the square and half of
2458     // the borders outside the square by default. This behavior cannot be
2459     // changed programmatically, so correct for that here.
2460     const borderWidth = data.borderStyle.width;
2461     const square = (this.#square = this.svgFactory.createElement("svg:rect"));
2462     square.setAttribute("x", borderWidth / 2);
2463     square.setAttribute("y", borderWidth / 2);
2464     square.setAttribute("width", width - borderWidth);
2465     square.setAttribute("height", height - borderWidth);
2466     // Ensure that the 'stroke-width' is always non-zero, since otherwise it
2467     // won't be possible to open/close the popup (note e.g. issue 11122).
2468     square.setAttribute("stroke-width", borderWidth || 1);
2469     square.setAttribute("stroke", "transparent");
2470     square.setAttribute("fill", "transparent");
2471 
2472     svg.append(square);
2473     this.container.append(svg);
2474 
2475     // Create the popup ourselves so that we can bind it to the square instead
2476     // of to the entire container (which is the default).
2477     if (!data.popupRef && this.hasPopupData) {
2478       this._createPopup();
2479     }
2480 
2481     return this.container;
2482   }
2483 
2484   getElementsToTriggerPopup() {
2485     return this.#square;
2486   }
2487 
2488   addHighlightArea() {
2489     this.container.classList.add("highlightArea");
2490   }
2491 }
2492 
2493 class CircleAnnotationElement extends AnnotationElement {
2494   #circle = null;
2495 
2496   constructor(parameters) {
2497     super(parameters, { isRenderable: true, ignoreBorder: true });
2498   }
2499 
2500   render() {
2501     this.container.classList.add("circleAnnotation");
2502 
2503     // Create an invisible circle with the same ellipse that acts as the
2504     // trigger for the popup. Only the circle itself should trigger the
2505     // popup, not the entire container.
2506     const data = this.data;
2507     const { width, height } = getRectDims(data.rect);
2508     const svg = this.svgFactory.create(
2509       width,
2510       height,
2511       /* skipDimensions = */ true
2512     );
2513 
2514     // The browser draws half of the borders inside the circle and half of
2515     // the borders outside the circle by default. This behavior cannot be
2516     // changed programmatically, so correct for that here.
2517     const borderWidth = data.borderStyle.width;
2518     const circle = (this.#circle =
2519       this.svgFactory.createElement("svg:ellipse"));
2520     circle.setAttribute("cx", width / 2);
2521     circle.setAttribute("cy", height / 2);
2522     circle.setAttribute("rx", width / 2 - borderWidth / 2);
2523     circle.setAttribute("ry", height / 2 - borderWidth / 2);
2524     // Ensure that the 'stroke-width' is always non-zero, since otherwise it
2525     // won't be possible to open/close the popup (note e.g. issue 11122).
2526     circle.setAttribute("stroke-width", borderWidth || 1);
2527     circle.setAttribute("stroke", "transparent");
2528     circle.setAttribute("fill", "transparent");
2529 
2530     svg.append(circle);
2531     this.container.append(svg);
2532 
2533     // Create the popup ourselves so that we can bind it to the circle instead
2534     // of to the entire container (which is the default).
2535     if (!data.popupRef && this.hasPopupData) {
2536       this._createPopup();
2537     }
2538 
2539     return this.container;
2540   }
2541 
2542   getElementsToTriggerPopup() {
2543     return this.#circle;
2544   }
2545 
2546   addHighlightArea() {
2547     this.container.classList.add("highlightArea");
2548   }
2549 }
2550 
2551 class PolylineAnnotationElement extends AnnotationElement {
2552   #polyline = null;
2553 
2554   constructor(parameters) {
2555     super(parameters, { isRenderable: true, ignoreBorder: true });
2556 
2557     this.containerClassName = "polylineAnnotation";
2558     this.svgElementName = "svg:polyline";
2559   }
2560 
2561   render() {
2562     this.container.classList.add(this.containerClassName);
2563 
2564     // Create an invisible polyline with the same points that acts as the
2565     // trigger for the popup. Only the polyline itself should trigger the
2566     // popup, not the entire container.
2567     const data = this.data;
2568     const { width, height } = getRectDims(data.rect);
2569     const svg = this.svgFactory.create(
2570       width,
2571       height,
2572       /* skipDimensions = */ true
2573     );
2574 
2575     // Convert the vertices array to a single points string that the SVG
2576     // polyline element expects ("x1,y1 x2,y2 ..."). PDF coordinates are
2577     // calculated from a bottom left origin, so transform the polyline
2578     // coordinates to a top left origin for the SVG element.
2579     let points = [];
2580     for (const coordinate of data.vertices) {
2581       const x = coordinate.x - data.rect[0];
2582       const y = data.rect[3] - coordinate.y;
2583       points.push(x + "," + y);
2584     }
2585     points = points.join(" ");
2586 
2587     const polyline = (this.#polyline = this.svgFactory.createElement(
2588       this.svgElementName
2589     ));
2590     polyline.setAttribute("points", points);
2591     // Ensure that the 'stroke-width' is always non-zero, since otherwise it
2592     // won't be possible to open/close the popup (note e.g. issue 11122).
2593     polyline.setAttribute("stroke-width", data.borderStyle.width || 1);
2594     polyline.setAttribute("stroke", "transparent");
2595     polyline.setAttribute("fill", "transparent");
2596 
2597     svg.append(polyline);
2598     this.container.append(svg);
2599 
2600     // Create the popup ourselves so that we can bind it to the polyline
2601     // instead of to the entire container (which is the default).
2602     if (!data.popupRef && this.hasPopupData) {
2603       this._createPopup();
2604     }
2605 
2606     return this.container;
2607   }
2608 
2609   getElementsToTriggerPopup() {
2610     return this.#polyline;
2611   }
2612 
2613   addHighlightArea() {
2614     this.container.classList.add("highlightArea");
2615   }
2616 }
2617 
2618 class PolygonAnnotationElement extends PolylineAnnotationElement {
2619   constructor(parameters) {
2620     // Polygons are specific forms of polylines, so reuse their logic.
2621     super(parameters);
2622 
2623     this.containerClassName = "polygonAnnotation";
2624     this.svgElementName = "svg:polygon";
2625   }
2626 }
2627 
2628 class CaretAnnotationElement extends AnnotationElement {
2629   constructor(parameters) {
2630     super(parameters, { isRenderable: true, ignoreBorder: true });
2631   }
2632 
2633   render() {
2634     this.container.classList.add("caretAnnotation");
2635 
2636     if (!this.data.popupRef && this.hasPopupData) {
2637       this._createPopup();
2638     }
2639     return this.container;
2640   }
2641 }
2642 
2643 class InkAnnotationElement extends AnnotationElement {
2644   #polylines = [];
2645 
2646   constructor(parameters) {
2647     super(parameters, { isRenderable: true, ignoreBorder: true });
2648 
2649     this.containerClassName = "inkAnnotation";
2650 
2651     // Use the polyline SVG element since it allows us to use coordinates
2652     // directly and to draw both straight lines and curves.
2653     this.svgElementName = "svg:polyline";
2654     this.annotationEditorType = AnnotationEditorType.INK;
2655   }
2656 
2657   render() {
2658     this.container.classList.add(this.containerClassName);
2659 
2660     // Create an invisible polyline with the same points that acts as the
2661     // trigger for the popup.
2662     const data = this.data;
2663     const { width, height } = getRectDims(data.rect);
2664     const svg = this.svgFactory.create(
2665       width,
2666       height,
2667       /* skipDimensions = */ true
2668     );
2669 
2670     for (const inkList of data.inkLists) {
2671       // Convert the ink list to a single points string that the SVG
2672       // polyline element expects ("x1,y1 x2,y2 ..."). PDF coordinates are
2673       // calculated from a bottom left origin, so transform the polyline
2674       // coordinates to a top left origin for the SVG element.
2675       let points = [];
2676       for (const coordinate of inkList) {
2677         const x = coordinate.x - data.rect[0];
2678         const y = data.rect[3] - coordinate.y;
2679         points.push(`${x},${y}`);
2680       }
2681       points = points.join(" ");
2682 
2683       const polyline = this.svgFactory.createElement(this.svgElementName);
2684       this.#polylines.push(polyline);
2685       polyline.setAttribute("points", points);
2686       // Ensure that the 'stroke-width' is always non-zero, since otherwise it
2687       // won't be possible to open/close the popup (note e.g. issue 11122).
2688       polyline.setAttribute("stroke-width", data.borderStyle.width || 1);
2689       polyline.setAttribute("stroke", "transparent");
2690       polyline.setAttribute("fill", "transparent");
2691 
2692       // Create the popup ourselves so that we can bind it to the polyline
2693       // instead of to the entire container (which is the default).
2694       if (!data.popupRef && this.hasPopupData) {
2695         this._createPopup();
2696       }
2697 
2698       svg.append(polyline);
2699     }
2700 
2701     this.container.append(svg);
2702     return this.container;
2703   }
2704 
2705   getElementsToTriggerPopup() {
2706     return this.#polylines;
2707   }
2708 
2709   addHighlightArea() {
2710     this.container.classList.add("highlightArea");
2711   }
2712 }
2713 
2714 class HighlightAnnotationElement extends AnnotationElement {
2715   constructor(parameters) {
2716     super(parameters, {
2717       isRenderable: true,
2718       ignoreBorder: true,
2719       createQuadrilaterals: true,
2720     });
2721   }
2722 
2723   render() {
2724     if (!this.data.popupRef && this.hasPopupData) {
2725       this._createPopup();
2726     }
2727 
2728     this.container.classList.add("highlightAnnotation");
2729     return this.container;
2730   }
2731 }
2732 
2733 class UnderlineAnnotationElement extends AnnotationElement {
2734   constructor(parameters) {
2735     super(parameters, {
2736       isRenderable: true,
2737       ignoreBorder: true,
2738       createQuadrilaterals: true,
2739     });
2740   }
2741 
2742   render() {
2743     if (!this.data.popupRef && this.hasPopupData) {
2744       this._createPopup();
2745     }
2746 
2747     this.container.classList.add("underlineAnnotation");
2748     return this.container;
2749   }
2750 }
2751 
2752 class SquigglyAnnotationElement extends AnnotationElement {
2753   constructor(parameters) {
2754     super(parameters, {
2755       isRenderable: true,
2756       ignoreBorder: true,
2757       createQuadrilaterals: true,
2758     });
2759   }
2760 
2761   render() {
2762     if (!this.data.popupRef && this.hasPopupData) {
2763       this._createPopup();
2764     }
2765 
2766     this.container.classList.add("squigglyAnnotation");
2767     return this.container;
2768   }
2769 }
2770 
2771 class StrikeOutAnnotationElement extends AnnotationElement {
2772   constructor(parameters) {
2773     super(parameters, {
2774       isRenderable: true,
2775       ignoreBorder: true,
2776       createQuadrilaterals: true,
2777     });
2778   }
2779 
2780   render() {
2781     if (!this.data.popupRef && this.hasPopupData) {
2782       this._createPopup();
2783     }
2784 
2785     this.container.classList.add("strikeoutAnnotation");
2786     return this.container;
2787   }
2788 }
2789 
2790 class StampAnnotationElement extends AnnotationElement {
2791   constructor(parameters) {
2792     super(parameters, { isRenderable: true, ignoreBorder: true });
2793   }
2794 
2795   render() {
2796     this.container.classList.add("stampAnnotation");
2797 
2798     if (!this.data.popupRef && this.hasPopupData) {
2799       this._createPopup();
2800     }
2801     return this.container;
2802   }
2803 }
2804 
2805 class FileAttachmentAnnotationElement extends AnnotationElement {
2806   #trigger = null;
2807 
2808   constructor(parameters) {
2809     super(parameters, { isRenderable: true });
2810 
2811     const { filename, content } = this.data.file;
2812     this.filename = getFilenameFromUrl(filename, /* onlyStripPath = */ true);
2813     this.content = content;
2814 
2815     this.linkService.eventBus?.dispatch("fileattachmentannotation", {
2816       source: this,
2817       filename,
2818       content,
2819     });
2820   }
2821 
2822   render() {
2823     this.container.classList.add("fileAttachmentAnnotation");
2824 
2825     const { container, data } = this;
2826     let trigger;
2827     if (data.hasAppearance || data.fillAlpha === 0) {
2828       trigger = document.createElement("div");
2829     } else {
2830       // Unfortunately it seems that it's not clearly specified exactly what
2831       // names are actually valid, since Table 184 contains:
2832       //   Conforming readers shall provide predefined icon appearances for at
2833       //   least the following standard names: GraphPushPin, PaperclipTag.
2834       //   Additional names may be supported as well. Default value: PushPin.
2835       trigger = document.createElement("img");
2836       trigger.src = `${this.imageResourcesPath}annotation-${
2837         /paperclip/i.test(data.name) ? "paperclip" : "pushpin"
2838       }.svg`;
2839 
2840       if (data.fillAlpha && data.fillAlpha < 1) {
2841         trigger.style = `filter: opacity(${Math.round(
2842           data.fillAlpha * 100
2843         )}%);`;
2844 
2845         if (typeof PDFJSDev !== "undefined" && PDFJSDev.test("TESTING")) {
2846           this.container.classList.add("hasFillAlpha");
2847         }
2848       }
2849     }
2850     trigger.addEventListener("dblclick", this.#download.bind(this));
2851     this.#trigger = trigger;
2852 
2853     const { isMac } = FeatureTest.platform;
2854     container.addEventListener("keydown", evt => {
2855       if (evt.key === "Enter" && (isMac ? evt.metaKey : evt.ctrlKey)) {
2856         this.#download();
2857       }
2858     });
2859 
2860     if (!data.popupRef && this.hasPopupData) {
2861       this._createPopup();
2862     } else {
2863       trigger.classList.add("popupTriggerArea");
2864     }
2865 
2866     container.append(trigger);
2867     return container;
2868   }
2869 
2870   getElementsToTriggerPopup() {
2871     return this.#trigger;
2872   }
2873 
2874   addHighlightArea() {
2875     this.container.classList.add("highlightArea");
2876   }
2877 
2878   /**
2879    * Download the file attachment associated with this annotation.
2880    */
2881   #download() {
2882     this.downloadManager?.openOrDownloadData(this.content, this.filename);
2883   }
2884 }
2885 
2886 /**
2887  * @typedef {Object} AnnotationLayerParameters
2888  * @property {PageViewport} viewport
2889  * @property {HTMLDivElement} div
2890  * @property {Array} annotations
2891  * @property {PDFPageProxy} page
2892  * @property {IPDFLinkService} linkService
2893  * @property {IDownloadManager} downloadManager
2894  * @property {AnnotationStorage} [annotationStorage]
2895  * @property {string} [imageResourcesPath] - Path for image resources, mainly
2896  *   for annotation icons. Include trailing slash.
2897  * @property {boolean} renderForms
2898  * @property {boolean} [enableScripting] - Enable embedded script execution.
2899  * @property {boolean} [hasJSActions] - Some fields have JS actions.
2900  *   The default value is `false`.
2901  * @property {Object<string, Array<Object>> | null} [fieldObjects]
2902  * @property {Map<string, HTMLCanvasElement>} [annotationCanvasMap]
2903  * @property {TextAccessibilityManager} [accessibilityManager]
2904  */
2905 
2906 /**
2907  * Manage the layer containing all the annotations.
2908  */
2909 class AnnotationLayer {
2910   #accessibilityManager = null;
2911 
2912   #annotationCanvasMap = null;
2913 
2914   #editableAnnotations = new Map();
2915 
2916   constructor({
2917     div,
2918     accessibilityManager,
2919     annotationCanvasMap,
2920     page,
2921     viewport,
2922   }) {
2923     this.div = div;
2924     this.#accessibilityManager = accessibilityManager;
2925     this.#annotationCanvasMap = annotationCanvasMap;
2926     this.page = page;
2927     this.viewport = viewport;
2928     this.zIndex = 0;
2929 
2930     if (typeof PDFJSDev !== "undefined" && PDFJSDev.test("TESTING")) {
2931       // For testing purposes.
2932       Object.defineProperty(this, "showPopups", {
2933         value: async () => {
2934           for (const show of this.popupShow) {
2935             await show();
2936           }
2937         },
2938       });
2939       this.popupShow = [];
2940     }
2941   }
2942 
2943   #appendElement(element, id) {
2944     const contentElement = element.firstChild || element;
2945     contentElement.id = `${AnnotationPrefix}${id}`;
2946 
2947     this.div.append(element);
2948     this.#accessibilityManager?.moveElementInDOM(
2949       this.div,
2950       element,
2951       contentElement,
2952       /* isRemovable = */ false
2953     );
2954   }
2955 
2956   /**
2957    * Render a new annotation layer with all annotation elements.
2958    *
2959    * @param {AnnotationLayerParameters} params
2960    * @memberof AnnotationLayer
2961    */
2962   async render(params) {
2963     const { annotations } = params;
2964     const layer = this.div;
2965     setLayerDimensions(layer, this.viewport);
2966 
2967     const popupToElements = new Map();
2968     const elementParams = {
2969       data: null,
2970       layer,
2971       linkService: params.linkService,
2972       downloadManager: params.downloadManager,
2973       imageResourcesPath: params.imageResourcesPath || "",
2974       renderForms: params.renderForms !== false,
2975       svgFactory: new DOMSVGFactory(),
2976       annotationStorage: params.annotationStorage || new AnnotationStorage(),
2977       enableScripting: params.enableScripting === true,
2978       hasJSActions: params.hasJSActions,
2979       fieldObjects: params.fieldObjects,
2980       parent: this,
2981       elements: null,
2982     };
2983 
2984     for (const data of annotations) {
2985       if (data.noHTML) {
2986         continue;
2987       }
2988       const isPopupAnnotation = data.annotationType === AnnotationType.POPUP;
2989       if (!isPopupAnnotation) {
2990         const { width, height } = getRectDims(data.rect);
2991         if (width <= 0 || height <= 0) {
2992           continue; // Ignore empty annotations.
2993         }
2994       } else {
2995         const elements = popupToElements.get(data.id);
2996         if (!elements) {
2997           // Ignore popup annotations without a corresponding annotation.
2998           continue;
2999         }
3000         elementParams.elements = elements;
3001       }
3002       elementParams.data = data;
3003       const element = AnnotationElementFactory.create(elementParams);
3004 
3005       if (!element.isRenderable) {
3006         continue;
3007       }
3008 
3009       if (!isPopupAnnotation && data.popupRef) {
3010         const elements = popupToElements.get(data.popupRef);
3011         if (!elements) {
3012           popupToElements.set(data.popupRef, [element]);
3013         } else {
3014           elements.push(element);
3015         }
3016       }
3017 
3018       if (element.annotationEditorType > 0) {
3019         this.#editableAnnotations.set(element.data.id, element);
3020       }
3021 
3022       const rendered = element.render();
3023       if (data.hidden) {
3024         rendered.style.visibility = "hidden";
3025       }
3026       this.#appendElement(rendered, data.id);
3027     }
3028 
3029     this.#setAnnotationCanvasMap();
3030   }
3031 
3032   /**
3033    * Update the annotation elements on existing annotation layer.
3034    *
3035    * @param {AnnotationLayerParameters} viewport
3036    * @memberof AnnotationLayer
3037    */
3038   update({ viewport }) {
3039     const layer = this.div;
3040     this.viewport = viewport;
3041     setLayerDimensions(layer, { rotation: viewport.rotation });
3042 
3043     this.#setAnnotationCanvasMap();
3044     layer.hidden = false;
3045   }
3046 
3047   #setAnnotationCanvasMap() {
3048     if (!this.#annotationCanvasMap) {
3049       return;
3050     }
3051     const layer = this.div;
3052     for (const [id, canvas] of this.#annotationCanvasMap) {
3053       const element = layer.querySelector(`[data-annotation-id="${id}"]`);
3054       if (!element) {
3055         continue;
3056       }
3057 
3058       const { firstChild } = element;
3059       if (!firstChild) {
3060         element.append(canvas);
3061       } else if (firstChild.nodeName === "CANVAS") {
3062         firstChild.replaceWith(canvas);
3063       } else {
3064         firstChild.before(canvas);
3065       }
3066     }
3067     this.#annotationCanvasMap.clear();
3068   }
3069 
3070   getEditableAnnotations() {
3071     return Array.from(this.#editableAnnotations.values());
3072   }
3073 
3074   getEditableAnnotation(id) {
3075     return this.#editableAnnotations.get(id);
3076   }
3077 }
3078 
3079 export {
3080   AnnotationLayer,
3081   FreeTextAnnotationElement,
3082   InkAnnotationElement,
3083   StampAnnotationElement,
3084 };
</code>

Your task:
You are a software tester at pdf.js.
1. Write exactly one javascript test `it("...", async () => {...})` block.
2. Your test must fail on the code before the patch, and pass after, hence the test will verify that the patch resolves the issue.
3. The test must be self-contained and to-the-point.
4. Use only the provided imports (respect the paths exactly how they are given) by importing dynamically for compatibility with Node.js — no new dependencies. 
5. Return only the javascript code (no comments or explanations).

Example structure:
it("should <describe behavior>", async () => {
  const { example } = await import("../../src/core/example.js");
  <initialize required variables>;
  <define expected variable>;
  <generate actual variables>;
  <compare expected with actual>;
});

