Before you begin:
- Keep going until the job is completely solved — don’t stop halfway.
- If you’re unsure about the behavior, reread the provided patch carefully; do not hallucinate.
- Plan your approach before writing code by reflecting on whether the test truly fails before and passes after.

Issue:
<issue>
PDF Display Issue Due to adjustMapping Function
I have a PDF whose charstrings are encoded in UTF-8, and it uses Unicode characters beyond 0xFFFF. This PDF displays correctly in both Chrome and Adobe Reader DC, but it does not display correctly in Firefox.

Upon reviewing the code, I found an issue in the adjustMapping function at line 488 in the `src/core/fonts.js` file:
```
originalCharCode |= 0;
```

If originalCharCode is greater than 2147483647, this will cause it to become a negative value, resulting in an error. Commenting out this line allows the PDF to display correctly.

Since I am not fully familiar with the details, I am just submitting an issue here.

Attach (recommended) or Link to PDF file here: [document.pdf](https://github.com/mozilla/pdf.js/files/15374281/document.pdf)

Configuration:
- Web browser and its version: FireFox 126.0
- Operating system and its version: Windows 11
- PDF.js version: [63b66b4](https://github.com/mozilla/pdf.js/commit/63b66b412cb3be6919c14436487c667a1597a732)

Steps to reproduce the problem:
1. Clone this repository 
2. Open web/viewer.html
3. Open the pdf

What is the expected behavior? (add screenshot)
![圖片](https://github.com/mozilla/pdf.js/assets/15166082/944ce8bf-2dbe-4076-8f0a-e9c6b0ead337)

What went wrong? (add screenshot)
![圖片](https://github.com/mozilla/pdf.js/assets/15166082/a1db52cb-0a6f-472e-9661-bcf0527b4193)
</issue>

Patch:
<patch>
diff --git a/src/core/fonts.js b/src/core/fonts.js
--- a/src/core/fonts.js
+++ b/src/core/fonts.js
@@ -484,8 +484,7 @@ function adjustMapping(charCodeToGlyphId, hasGlyph, newGlyphZeroId, toUnicode) {
   const isInPrivateArea = code =>
     (PRIVATE_USE_AREAS[0][0] <= code && code <= PRIVATE_USE_AREAS[0][1]) ||
     (PRIVATE_USE_AREAS[1][0] <= code && code <= PRIVATE_USE_AREAS[1][1]);
-  for (let originalCharCode in charCodeToGlyphId) {
-    originalCharCode |= 0;
+  for (const originalCharCode in charCodeToGlyphId) {
     let glyphId = charCodeToGlyphId[originalCharCode];
     // For missing glyphs don't create the mappings so the glyph isn't
     // drawn.
@@ -2834,7 +2833,7 @@ class Font {
       data: createPostTable(properties),
     };
 
-    const charCodeToGlyphId = [];
+    const charCodeToGlyphId = Object.create(null);
 
     // Helper function to try to skip mapping of empty glyphs.
     function hasGlyph(glyphId) {


</patch>

Imports:
<imports>
Available Packages
Dev Dependencies:
- @babel/core: ^7.24.5
- @babel/preset-env: ^7.24.5
- @babel/runtime: ^7.24.5
- @fluent/bundle: ^0.18.0
- @fluent/dom: ^0.9.0
- @jazzer.js/core: ^2.1.0
- autoprefixer: ^10.4.19
- babel-loader: ^9.1.3
- caniuse-lite: ^1.0.30001618
- canvas: ^2.11.2
- core-js: ^3.37.1
- cross-env: ^7.0.3
- eslint: ^8.57.0
- eslint-config-prettier: ^9.1.0
- eslint-plugin-fetch-options: ^0.0.5
- eslint-plugin-html: ^8.1.1
- eslint-plugin-import: ^2.29.1
- eslint-plugin-jasmine: ^4.1.3
- eslint-plugin-json: ^3.1.0
- eslint-plugin-mozilla: ^3.7.3
- eslint-plugin-no-unsanitized: ^4.0.2
- eslint-plugin-prettier: ^5.1.3
- eslint-plugin-sort-exports: ^0.9.1
- eslint-plugin-unicorn: ^53.0.0
- globals: ^15.2.0
- gulp: ^4.0.2
- gulp-cli: ^3.0.0
- gulp-postcss: ^10.0.0
- gulp-rename: ^2.0.0
- gulp-replace: ^1.1.4
- gulp-zip: ^6.0.0
- jasmine: ^5.1.0
- jsdoc: ^4.0.3
- jstransformer-markdown-it: ^3.0.0
- merge-stream: ^2.0.0
- path2d: ^0.2.0
- pngjs: ^7.0.0
- postcss: ^8.4.38
- postcss-dark-theme-class: ^1.3.0
- postcss-dir-pseudo-class: ^8.0.1
- postcss-discard-comments: ^7.0.0
- postcss-nesting: ^12.1.4
- prettier: ^3.2.5
- puppeteer: ^22.8.1
- streamqueue: ^1.1.2
- stylelint: ^16.5.0
- stylelint-prettier: ^5.0.0
- terser-webpack-plugin: ^5.3.10
- through2: ^4.0.2
- tsc-alias: ^1.8.10
- ttest: ^4.0.0
- typescript: ^5.4.5
- typogr: ^0.6.8
- vinyl: ^3.0.0
- webpack: ^5.91.0
- webpack-stream: ^7.0.0
- wintersmith: ^2.5.0
- yargs: ^17.7.2

Engines:
- node: >=18

Available Relative Imports:
- `../../src/core/annotation.js`: Annotation, AnnotationBorderStyle, AnnotationFactory, MarkupAnnotation, getQuadPoints
- `../../src/core/bidi.js`: bidi
- `../../src/core/cff_parser.js`: CFFCharset, CFFCompiler, CFFFDSelect, CFFParser, CFFStrings
- `../../src/core/cmap.js`: CMap, CMapFactory, IdentityCMap
- `../../src/core/colorspace.js`: ColorSpace
- `../../src/core/core_utils.js`: arrayBuffersToBytes, encodeToXmlString, escapePDFName, escapeString, getInheritableProperty, getSizeInBytes, isAscii, isWhiteSpace, log2, numberToString, parseXFAPath, recoverJsURL, stringToUTF16HexString, stringToUTF16String, toRomanNumerals, validateCSSFont
- `../../src/core/crypto.js`: AES128Cipher, AES256Cipher, ARCFourCipher, CipherTransformFactory, PDF17, PDF20, calculateMD5, calculateSHA256, calculateSHA384, calculateSHA512
- `../../src/core/default_appearance.js`: createDefaultAppearance, parseAppearanceStream, parseDefaultAppearance
- `../../src/core/document.js`: PDFDocument, Page
- `../../src/core/encodings.js`: getEncoding
- `../../src/core/evaluator.js`: PartialEvaluator
- `../../src/core/flate_stream.js`: FlateStream
- `../../src/core/font_substitutions.js`: getFontSubstitution
- `../../src/core/fonts_utils.js`: SEAC_ANALYSIS_ENABLED
- `../../src/core/function.js`: PDFFunctionFactory, PostScriptCompiler, PostScriptEvaluator
- `../../src/core/glyphlist.js`: getDingbatsGlyphsUnicode, getGlyphsUnicode
- `../../src/core/image_utils.js`: GlobalImageCache, LocalColorSpaceCache
- `../../src/core/jbig2.js`: Jbig2Error, Jbig2Image
- `../../src/core/jpg.js`: JpegError, JpegImage
- `../../src/core/jpx.js`: JpxError, JpxImage
- `../../src/core/metadata_parser.js`: MetadataParser
- `../../src/core/operator_list.js`: OperatorList
- `../../src/core/parser.js`: Lexer, Linearization, Parser
- `../../src/core/predictor_stream.js`: PredictorStream
- `../../src/core/primitives.js`: Cmd, Dict, EOF, Name, Ref, RefSet, RefSetCache, isCmd, isDict, isName, isRefsEqual
- `../../src/core/ps_parser.js`: PostScriptLexer, PostScriptParser
- `../../src/core/stream.js`: NullStream, Stream, StringStream
- `../../src/core/type1_parser.js`: Type1Parser
- `../../src/core/unicode.js`: getCharUnicodeCategory, getUnicodeForGlyph, getUnicodeRangeFor, mapSpecialUnicodeValues
- `../../src/core/worker.js`: WorkerMessageHandler, WorkerTask
- `../../src/core/writer.js`: incrementalUpdate, writeDict
- `../../src/core/xfa/bind.js`: Binder
- `../../src/core/xfa/data.js`: DataHandler
- `../../src/core/xfa/factory.js`: XFAFactory
- `../../src/core/xfa/formcalc_lexer.js`: Lexer, TOKEN, Token
- `../../src/core/xfa/formcalc_parser.js`: Errors, Parser
- `../../src/core/xfa/parser.js`: XFAParser
- `../../src/core/xfa/som.js`: searchNode
- `../../src/core/xfa/symbol_utils.js`: $dump, $getChildren, $getChildrenByClass, $getChildrenByName, $text, $uid
- `../../src/core/xml_parser.js`: SimpleXMLParser, XMLParserBase
- `../../src/display/annotation_layer.js`: AnnotationLayer
- `../../src/display/annotation_storage.js`: AnnotationStorage
- `../../src/display/api.js`: DefaultCMapReaderFactory, DefaultCanvasFactory, DefaultStandardFontDataFactory, LoopbackPort, PDFDataRangeTransport, PDFDocumentLoadingTask, PDFDocumentProxy, PDFPageProxy, PDFWorker, PDFWorkerUtil, RenderTask, build, getDocument, version
- `../../src/display/display_utils.js`: DOMCanvasFactory, DOMSVGFactory, PDFDateString, PageViewport, PixelsPerInch, RenderingCancelledException, StatTimer, fetchData, getFilenameFromUrl, getPdfFilenameFromUrl, getXfaPageViewport, isDataScheme, isPdfFile, isValidFetchUrl, noContextMenu, setLayerDimensions
- `../../src/display/draw_layer.js`: DrawLayer
- `../../src/display/editor/annotation_editor_layer.js`: AnnotationEditorLayer
- `../../src/display/editor/color_picker.js`: ColorPicker
- `../../src/display/editor/outliner.js`: Outliner
- `../../src/display/editor/tools.js`: AnnotationEditorUIManager, CommandManager
- `../../src/display/fetch_stream.js`: PDFFetchStream
- `../../src/display/metadata.js`: Metadata
- `../../src/display/network.js`: PDFNetworkStream
- `../../src/display/network_utils.js`: createResponseStatusError, extractFilenameFromHeader, validateRangeRequestCapabilities, validateResponseStatus
- `../../src/display/node_stream.js`: PDFNodeStream
- `../../src/display/node_utils.js`: NodePackages
- `../../src/display/text_layer.js`: TextLayerRenderTask, renderTextLayer, updateTextLayer
- `../../src/display/worker_options.js`: GlobalWorkerOptions
- `../../src/display/xfa_layer.js`: XfaLayer
- `../../src/shared/message_handler.js`: MessageHandler
- `../../src/shared/murmurhash3.js`: MurmurHash3_64
- `../../src/shared/util.js`: AbortException, AnnotationBorderStyleType, AnnotationEditorParamsType, AnnotationEditorType, AnnotationFieldFlag, AnnotationFlag, AnnotationMode, AnnotationType, BaseException, CMapCompressionType, FeatureTest, FormatError, ImageKind, InvalidPDFException, MissingPDFException, OPS, PasswordException, PasswordResponses, PermissionFlag, RenderingIntentFlag, UnexpectedResponseException, UnknownErrorException, Util, VerbosityLevel, assert, bytesToString, createValidAbsoluteUrl, getModificationDate, getVerbosityLevel, isNodeJS, normalizeUnicode, objectSize, setVerbosityLevel, shadow, string32, stringToBytes, stringToPDFString, stringToUTF8String
- `../../web/annotation_layer_builder.js`: AnnotationLayerBuilder
- `../../web/app_options.js`: AppOptions, OptionKind
- `../../web/download_manager.js`: DownloadManager
- `../../web/event_utils.js`: EventBus, WaitOnType, waitOnEventOrTimeout
- `../../web/genericl10n.js`: GenericL10n
- `../../web/pdf_find_controller.js`: FindState, PDFFindController
- `../../web/pdf_find_utils.js`: CharacterType, getCharacterType
- `../../web/pdf_history.js`: PDFHistory, isDestArraysEqual, isDestHashesEqual
- `../../web/pdf_link_service.js`: LinkTarget, PDFLinkService, SimpleLinkService
- `../../web/pdf_page_view.js`: PDFPageView
- `../../web/pdf_scripting_manager.component.js`: PDFScriptingManager
- `../../web/pdf_single_page_viewer.js`: PDFSinglePageViewer
- `../../web/pdf_viewer.js`: PDFPageViewBuffer, PDFViewer
- `../../web/struct_tree_layer_builder.js`: StructTreeLayerBuilder
- `../../web/text_layer_builder.js`: TextLayerBuilder
- `../../web/ui_utils.js`: AutoPrintRegExp, ProgressBar, RenderingStates, ScrollMode, SpreadMode, backtrackBeforeAllVisibleElements, binarySearchFirstItem, getPageSizeInches, getVisibleElements, isPortraitOrientation, isValidRotation, parseQueryString, removeNullCharacters
- `../../web/xfa_layer_builder.js`: XfaLayerBuilder
- `./test_utils.js`: CMAP_URL, DefaultFileReaderFactory, STANDARD_FONT_DATA_URL, TEST_PDFS_PATH, XRefMock, buildGetDocumentParams, createIdFactory, createTemporaryNodeServer
- `./testreporter.js`: TestReporter
</imports>

Code:
<code>
File:
src/core/fonts.js
1 /* Copyright 2012 Mozilla Foundation
2  *
3  * Licensed under the Apache License, Version 2.0 (the "License");
4  * you may not use this file except in compliance with the License.
5  * You may obtain a copy of the License at
6  *
7  *     http://www.apache.org/licenses/LICENSE-2.0
8  *
9  * Unless required by applicable law or agreed to in writing, software
10  * distributed under the License is distributed on an "AS IS" BASIS,
11  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
12  * See the License for the specific language governing permissions and
13  * limitations under the License.
14  */
15 
16 import {
17   assert,
18   bytesToString,
19   FONT_IDENTITY_MATRIX,
20   FormatError,
21   info,
22   shadow,
23   string32,
24   warn,
25 } from "../shared/util.js";
26 import { CFFCompiler, CFFParser } from "./cff_parser.js";
27 import {
28   FontFlags,
29   MacStandardGlyphOrdering,
30   normalizeFontName,
31   recoverGlyphName,
32   SEAC_ANALYSIS_ENABLED,
33 } from "./fonts_utils.js";
34 import {
35   getCharUnicodeCategory,
36   getUnicodeForGlyph,
37   getUnicodeRangeFor,
38   mapSpecialUnicodeValues,
39 } from "./unicode.js";
40 import { getDingbatsGlyphsUnicode, getGlyphsUnicode } from "./glyphlist.js";
41 import {
42   getEncoding,
43   MacRomanEncoding,
44   StandardEncoding,
45   SymbolSetEncoding,
46   WinAnsiEncoding,
47   ZapfDingbatsEncoding,
48 } from "./encodings.js";
49 import {
50   getGlyphMapForStandardFonts,
51   getNonStdFontMap,
52   getSerifFonts,
53   getStdFontMap,
54   getSupplementalGlyphMapForArialBlack,
55   getSupplementalGlyphMapForCalibri,
56 } from "./standard_fonts.js";
57 import { IdentityToUnicodeMap, ToUnicodeMap } from "./to_unicode_map.js";
58 import { CFFFont } from "./cff_font.js";
59 import { FontRendererFactory } from "./font_renderer.js";
60 import { getFontBasicMetrics } from "./metrics.js";
61 import { GlyfTable } from "./glyf.js";
62 import { IdentityCMap } from "./cmap.js";
63 import { OpenTypeFileBuilder } from "./opentype_file_builder.js";
64 import { readUint32 } from "./core_utils.js";
65 import { Stream } from "./stream.js";
66 import { Type1Font } from "./type1_font.js";
67 
68 // Unicode Private Use Areas:
69 const PRIVATE_USE_AREAS = [
70   [0xe000, 0xf8ff], // BMP (0)
71   [0x100000, 0x10fffd], // PUP (16)
72 ];
73 
74 // PDF Glyph Space Units are one Thousandth of a TextSpace Unit
75 // except for Type 3 fonts
76 const PDF_GLYPH_SPACE_UNITS = 1000;
77 
78 const EXPORT_DATA_PROPERTIES = [
79   "ascent",
80   "bbox",
81   "black",
82   "bold",
83   "charProcOperatorList",
84   "composite",
85   "cssFontInfo",
86   "data",
87   "defaultVMetrics",
88   "defaultWidth",
89   "descent",
90   "fallbackName",
91   "fontMatrix",
92   "isInvalidPDFjsFont",
93   "isType3Font",
94   "italic",
95   "loadedName",
96   "mimetype",
97   "missingFile",
98   "name",
99   "remeasure",
100   "subtype",
101   "systemFontInfo",
102   "type",
103   "vertical",
104 ];
105 
106 const EXPORT_DATA_EXTRA_PROPERTIES = [
107   "cMap",
108   "defaultEncoding",
109   "differences",
110   "isMonospace",
111   "isSerifFont",
112   "isSymbolicFont",
113   "seacMap",
114   "toFontChar",
115   "toUnicode",
116   "vmetrics",
117   "widths",
118 ];
119 
436 // Please refer to:
437 //  - https://developer.apple.com/fonts/TrueType-Reference-Manual/RM06/Chap6name.html
441 
442 // Please refer to:
443 //  - https://developer.apple.com/fonts/TrueType-Reference-Manual/RM06/Chap6name.html
444 //  - https://learn.microsoft.com/en-us/typography/opentype/spec/name#windows-language-ids
448 
464 /**
465  * Rebuilds the char code to glyph ID map by moving all char codes to the
466  * private use area. This is done to avoid issues with various problematic
467  * unicode areas where either a glyph won't be drawn or is deformed by a
468  * shaper.
469  * @returns {Object} Two properties:
470  * 'toFontChar' - maps original char codes(the value that will be read
471  * from commands such as show text) to the char codes that will be used in the
472  * font that we build
473  * 'charCodeToGlyphId' - maps the new font char codes to glyph ids
474  */
475 function adjustMapping(charCodeToGlyphId, hasGlyph, newGlyphZeroId, toUnicode) {
476   const newMap = Object.create(null);
477   const toUnicodeExtraMap = new Map();
478   const toFontChar = [];
479   const usedGlyphIds = new Set();
480   let privateUseAreaIndex = 0;
481   const privateUseOffetStart = PRIVATE_USE_AREAS[privateUseAreaIndex][0];
482   let nextAvailableFontCharCode = privateUseOffetStart;
483   let privateUseOffetEnd = PRIVATE_USE_AREAS[privateUseAreaIndex][1];
484   const isInPrivateArea = code =>
485     (PRIVATE_USE_AREAS[0][0] <= code && code <= PRIVATE_USE_AREAS[0][1]) ||
486     (PRIVATE_USE_AREAS[1][0] <= code && code <= PRIVATE_USE_AREAS[1][1]);
487   for (let originalCharCode in charCodeToGlyphId) {
488     originalCharCode |= 0;
489     let glyphId = charCodeToGlyphId[originalCharCode];
490     // For missing glyphs don't create the mappings so the glyph isn't
491     // drawn.
492     if (!hasGlyph(glyphId)) {
493       continue;
494     }
495     if (nextAvailableFontCharCode > privateUseOffetEnd) {
496       privateUseAreaIndex++;
497       if (privateUseAreaIndex >= PRIVATE_USE_AREAS.length) {
498         warn("Ran out of space in font private use area.");
499         break;
500       }
501       nextAvailableFontCharCode = PRIVATE_USE_AREAS[privateUseAreaIndex][0];
502       privateUseOffetEnd = PRIVATE_USE_AREAS[privateUseAreaIndex][1];
503     }
504     const fontCharCode = nextAvailableFontCharCode++;
505     if (glyphId === 0) {
506       glyphId = newGlyphZeroId;
507     }
508 
509     // Fix for bug 1778484:
510     // The charcodes are moved into a private use area to fix some rendering
511     // issues (https://github.com/mozilla/pdf.js/pull/9340) but when printing
512     // to PDF the generated font will contain wrong chars. We can avoid that by
513     // adding the unicode to the cmap and the print backend will then map the
514     // glyph ids to the correct unicode.
515     let unicode = toUnicode.get(originalCharCode);
516     if (typeof unicode === "string") {
517       unicode = unicode.codePointAt(0);
518     }
519     if (unicode && !isInPrivateArea(unicode) && !usedGlyphIds.has(glyphId)) {
520       toUnicodeExtraMap.set(unicode, glyphId);
521       usedGlyphIds.add(glyphId);
522     }
523 
524     newMap[fontCharCode] = glyphId;
525     toFontChar[originalCharCode] = fontCharCode;
526   }
527   return {
528     toFontChar,
529     charCodeToGlyphId: newMap,
530     toUnicodeExtraMap,
531     nextAvailableFontCharCode,
532   };
533 }
534 
948 /**
949  * 'Font' is the class the outside world should use, it encapsulate all the font
950  * decoding logics whatever type it is (assuming the font type is supported).
951  */
952 class Font {
953   constructor(name, file, properties) {
954     this.name = name;
955     this.psName = null;
956     this.mimetype = null;
957     this.disableFontFace = false;
958 
959     this.loadedName = properties.loadedName;
960     this.isType3Font = properties.isType3Font;
961     this.missingFile = false;
962     this.cssFontInfo = properties.cssFontInfo;
963 
964     this._charsCache = Object.create(null);
965     this._glyphCache = Object.create(null);
966 
967     let isSerifFont = !!(properties.flags & FontFlags.Serif);
968     // Fallback to checking the font name, in order to improve text-selection,
969     // since the /Flags-entry is often wrong (fixes issue13845.pdf).
970     if (!isSerifFont && !properties.isSimulatedFlags) {
971       const baseName = name.replaceAll(/[,_]/g, "-").split("-", 1)[0],
972         serifFonts = getSerifFonts();
973       for (const namePart of baseName.split("+")) {
974         if (serifFonts[namePart]) {
975           isSerifFont = true;
976           break;
977         }
978       }
979     }
980     this.isSerifFont = isSerifFont;
981 
982     this.isSymbolicFont = !!(properties.flags & FontFlags.Symbolic);
983     this.isMonospace = !!(properties.flags & FontFlags.FixedPitch);
984 
985     let { type, subtype } = properties;
986     this.type = type;
987     this.subtype = subtype;
988     this.systemFontInfo = properties.systemFontInfo;
989 
990     const matches = name.match(/^InvalidPDFjsFont_(.*)_\d+$/);
991     this.isInvalidPDFjsFont = !!matches;
992     if (this.isInvalidPDFjsFont) {
993       this.fallbackName = matches[1];
994     } else if (this.isMonospace) {
995       this.fallbackName = "monospace";
996     } else if (this.isSerifFont) {
997       this.fallbackName = "serif";
998     } else {
999       this.fallbackName = "sans-serif";
1000     }
1001 
1002     if (this.systemFontInfo?.guessFallback) {
1003       // Once the fallback name is guessed, we don't want to guess it again.
1004       this.systemFontInfo.guessFallback = false;
1005       this.systemFontInfo.css += `,${this.fallbackName}`;
1006     }
1007 
1008     this.differences = properties.differences;
1009     this.widths = properties.widths;
1010     this.defaultWidth = properties.defaultWidth;
1011     this.composite = properties.composite;
1012     this.cMap = properties.cMap;
1013     this.capHeight = properties.capHeight / PDF_GLYPH_SPACE_UNITS;
1014     this.ascent = properties.ascent / PDF_GLYPH_SPACE_UNITS;
1015     this.descent = properties.descent / PDF_GLYPH_SPACE_UNITS;
1016     this.lineHeight = this.ascent - this.descent;
1017     this.fontMatrix = properties.fontMatrix;
1018     this.bbox = properties.bbox;
1019     this.defaultEncoding = properties.defaultEncoding;
1020 
1021     this.toUnicode = properties.toUnicode;
1022     this.toFontChar = [];
1023 
1024     if (properties.type === "Type3") {
1025       for (let charCode = 0; charCode < 256; charCode++) {
1026         this.toFontChar[charCode] =
1027           this.differences[charCode] || properties.defaultEncoding[charCode];
1028       }
1029       return;
1030     }
1031 
1032     this.cidEncoding = properties.cidEncoding || "";
1033     this.vertical = !!properties.vertical;
1034     if (this.vertical) {
1035       this.vmetrics = properties.vmetrics;
1036       this.defaultVMetrics = properties.defaultVMetrics;
1037     }
1038 
1039     if (!file || file.isEmpty) {
1040       if (file) {
1041         // Some bad PDF generators will include empty font files,
1042         // attempting to recover by assuming that no file exists.
1043         warn('Font file is empty in "' + name + '" (' + this.loadedName + ")");
1044       }
1045       this.fallbackToSystemFont(properties);
1046       return;
1047     }
1048 
1049     // Parse the font file to determine the correct type/subtype, rather than
1050     // relying on the (often incorrect) data in the font dictionary; (see e.g.
1051     //  issue6782.pdf, issue7598.pdf, and issue9949.pdf).
1052     [type, subtype] = getFontFileType(file, properties);
1053 
1054     if (type !== this.type || subtype !== this.subtype) {
1055       info(
1056         "Inconsistent font file Type/SubType, expected: " +
1057           `${this.type}/${this.subtype} but found: ${type}/${subtype}.`
1058       );
1059     }
1060 
1061     let data;
1062     try {
1063       switch (type) {
1064         case "MMType1":
1065           info("MMType1 font (" + name + "), falling back to Type1.");
1066         /* falls through */
1067         case "Type1":
1068         case "CIDFontType0":
1069           this.mimetype = "font/opentype";
1070 
1071           const cff =
1072             subtype === "Type1C" || subtype === "CIDFontType0C"
1073               ? new CFFFont(file, properties)
1074               : new Type1Font(name, file, properties);
1075 
1076           adjustWidths(properties);
1077 
1078           // Wrap the CFF data inside an OTF font file
1079           data = this.convert(name, cff, properties);
1080           break;
1081 
1082         case "OpenType":
1083         case "TrueType":
1084         case "CIDFontType2":
1085           this.mimetype = "font/opentype";
1086 
1087           // Repair the TrueType file. It is can be damaged in the point of
1088           // view of the sanitizer
1089           data = this.checkAndRepair(name, file, properties);
1090           if (this.isOpenType) {
1091             adjustWidths(properties);
1092 
1093             type = "OpenType";
1094           }
1095           break;
1096 
1097         default:
1098           throw new FormatError(`Font ${type} is not supported`);
1099       }
1100     } catch (e) {
1101       warn(e);
1102       this.fallbackToSystemFont(properties);
1103       return;
1104     }
1105 
1106     amendFallbackToUnicode(properties);
1107     this.data = data;
1108 
1109     // Transfer some properties again that could change during font conversion
1110     this.type = type;
1111     this.subtype = subtype;
1112     this.fontMatrix = properties.fontMatrix;
1113     this.widths = properties.widths;
1114     this.defaultWidth = properties.defaultWidth;
1115     this.toUnicode = properties.toUnicode;
1116     this.seacMap = properties.seacMap;
1117   }
1118 
1292   checkAndRepair(name, font, properties) {
1293     const VALID_TABLES = [
1294       "OS/2",
1295       "cmap",
1296       "head",
1297       "hhea",
1298       "hmtx",
1299       "maxp",
1300       "name",
1301       "post",
1302       "loca",
1303       "glyf",
1304       "fpgm",
1305       "prep",
1306       "cvt ",
1307       "CFF ",
1308     ];
1309 
1310     function readTables(file, numTables) {
1311       const tables = Object.create(null);
1312       tables["OS/2"] = null;
1313       tables.cmap = null;
1314       tables.head = null;
1315       tables.hhea = null;
1316       tables.hmtx = null;
1317       tables.maxp = null;
1318       tables.name = null;
1319       tables.post = null;
1320 
1321       for (let i = 0; i < numTables; i++) {
1322         const table = readTableEntry(file);
1323         if (!VALID_TABLES.includes(table.tag)) {
1324           continue; // skipping table if it's not a required or optional table
1325         }
1326         if (table.length === 0) {
1327           continue; // skipping empty tables
1328         }
1329         tables[table.tag] = table;
1330       }
1331       return tables;
1332     }
1333 
1334     function readTableEntry(file) {
1335       const tag = file.getString(4);
1336 
1337       const checksum = file.getInt32() >>> 0;
1338       const offset = file.getInt32() >>> 0;
1339       const length = file.getInt32() >>> 0;
1340 
1341       // Read the table associated data
1342       const previousPosition = file.pos;
1343       file.pos = file.start || 0;
1344       file.skip(offset);
1345       const data = file.getBytes(length);
1346       file.pos = previousPosition;
1347 
1348       if (tag === "head") {
1349         // clearing checksum adjustment
1350         data[8] = data[9] = data[10] = data[11] = 0;
1351         data[17] |= 0x20; // Set font optimized for cleartype flag.
1352       }
1353 
1354       return {
1355         tag,
1356         checksum,
1357         length,
1358         offset,
1359         data,
1360       };
1361     }
1362 
1363     function readOpenTypeHeader(ttf) {
1364       return {
1365         version: ttf.getString(4),
1366         numTables: ttf.getUint16(),
1367         searchRange: ttf.getUint16(),
1368         entrySelector: ttf.getUint16(),
1369         rangeShift: ttf.getUint16(),
1370       };
1371     }
1372 
1373     function readTrueTypeCollectionHeader(ttc) {
1374       const ttcTag = ttc.getString(4);
1375       assert(ttcTag === "ttcf", "Must be a TrueType Collection font.");
1376 
1377       const majorVersion = ttc.getUint16();
1378       const minorVersion = ttc.getUint16();
1379       const numFonts = ttc.getInt32() >>> 0;
1380       const offsetTable = [];
1381       for (let i = 0; i < numFonts; i++) {
1382         offsetTable.push(ttc.getInt32() >>> 0);
1383       }
1384 
1385       const header = {
1386         ttcTag,
1387         majorVersion,
1388         minorVersion,
1389         numFonts,
1390         offsetTable,
1391       };
1392       switch (majorVersion) {
1393         case 1:
1394           return header;
1395         case 2:
1396           header.dsigTag = ttc.getInt32() >>> 0;
1397           header.dsigLength = ttc.getInt32() >>> 0;
1398           header.dsigOffset = ttc.getInt32() >>> 0;
1399           return header;
1400       }
1401       throw new FormatError(
1402         `Invalid TrueType Collection majorVersion: ${majorVersion}.`
1403       );
1404     }
1405 
1406     function readTrueTypeCollectionData(ttc, fontName) {
1407       const { numFonts, offsetTable } = readTrueTypeCollectionHeader(ttc);
1408       const fontNameParts = fontName.split("+");
1409       let fallbackData;
1410 
1411       for (let i = 0; i < numFonts; i++) {
1412         ttc.pos = (ttc.start || 0) + offsetTable[i];
1413         const potentialHeader = readOpenTypeHeader(ttc);
1414         const potentialTables = readTables(ttc, potentialHeader.numTables);
1415 
1416         if (!potentialTables.name) {
1417           throw new FormatError(
1418             'TrueType Collection font must contain a "name" table.'
1419           );
1420         }
1421         const [nameTable] = readNameTable(potentialTables.name);
1422 
1423         for (let j = 0, jj = nameTable.length; j < jj; j++) {
1424           for (let k = 0, kk = nameTable[j].length; k < kk; k++) {
1425             const nameEntry = nameTable[j][k]?.replaceAll(/\s/g, "");
1426             if (!nameEntry) {
1427               continue;
1428             }
1429             if (nameEntry === fontName) {
1430               return {
1431                 header: potentialHeader,
1432                 tables: potentialTables,
1433               };
1434             }
1435             if (fontNameParts.length < 2) {
1436               continue;
1437             }
1438             for (const part of fontNameParts) {
1439               if (nameEntry === part) {
1440                 fallbackData = {
1441                   name: part,
1442                   header: potentialHeader,
1443                   tables: potentialTables,
1444                 };
1445               }
1446             }
1447           }
1448         }
1449       }
1450       if (fallbackData) {
1451         warn(
1452           `TrueType Collection does not contain "${fontName}" font, ` +
1453             `falling back to "${fallbackData.name}" font instead.`
1454         );
1455         return {
1456           header: fallbackData.header,
1457           tables: fallbackData.tables,
1458         };
1459       }
1460       throw new FormatError(
1461         `TrueType Collection does not contain "${fontName}" font.`
1462       );
1463     }
1464 
1465     /**
1466      * Read the appropriate subtable from the cmap according to 9.6.6.4 from
1467      * PDF spec
1468      */
1469     function readCmapTable(cmap, file, isSymbolicFont, hasEncoding) {
1470       if (!cmap) {
1471         warn("No cmap table available.");
1472         return {
1473           platformId: -1,
1474           encodingId: -1,
1475           mappings: [],
1476           hasShortCmap: false,
1477         };
1478       }
1479       let segment;
1480       let start = (file.start || 0) + cmap.offset;
1481       file.pos = start;
1482 
1483       file.skip(2); // version
1484       const numTables = file.getUint16();
1485 
1486       let potentialTable;
1487       let canBreak = false;
1488       // There's an order of preference in terms of which cmap subtable to
1489       // use:
1490       // - non-symbolic fonts the preference is a 3,1 table then a 1,0 table
1491       // - symbolic fonts the preference is a 3,0 table then a 1,0 table
1492       // The following takes advantage of the fact that the tables are sorted
1493       // to work.
1494       for (let i = 0; i < numTables; i++) {
1495         const platformId = file.getUint16();
1496         const encodingId = file.getUint16();
1497         const offset = file.getInt32() >>> 0;
1498         let useTable = false;
1499 
1500         // Sometimes there are multiple of the same type of table. Default
1501         // to choosing the first table and skip the rest.
1502         if (
1503           potentialTable?.platformId === platformId &&
1504           potentialTable?.encodingId === encodingId
1505         ) {
1506           continue;
1507         }
1508 
1509         if (
1510           platformId === 0 &&
1511           (encodingId === /* Unicode Default */ 0 ||
1512             encodingId === /* Unicode 1.1 */ 1 ||
1513             encodingId === /* Unicode BMP */ 3)
1514         ) {
1515           useTable = true;
1516           // Continue the loop since there still may be a higher priority
1517           // table.
1518         } else if (platformId === 1 && encodingId === 0) {
1519           useTable = true;
1520           // Continue the loop since there still may be a higher priority
1521           // table.
1522         } else if (
1523           platformId === 3 &&
1524           encodingId === 1 &&
1525           (hasEncoding || !potentialTable)
1526         ) {
1527           useTable = true;
1528           if (!isSymbolicFont) {
1529             canBreak = true;
1530           }
1531         } else if (isSymbolicFont && platformId === 3 && encodingId === 0) {
1532           useTable = true;
1533 
1534           let correctlySorted = true;
1535           if (i < numTables - 1) {
1536             const nextBytes = file.peekBytes(2),
1537               nextPlatformId = int16(nextBytes[0], nextBytes[1]);
1538             if (nextPlatformId < platformId) {
1539               correctlySorted = false;
1540             }
1541           }
1542           if (correctlySorted) {
1543             canBreak = true;
1544           }
1545         }
1546 
1547         if (useTable) {
1548           potentialTable = {
1549             platformId,
1550             encodingId,
1551             offset,
1552           };
1553         }
1554         if (canBreak) {
1555           break;
1556         }
1557       }
1558 
1559       if (potentialTable) {
1560         file.pos = start + potentialTable.offset;
1561       }
1562       if (!potentialTable || file.peekByte() === -1) {
1563         warn("Could not find a preferred cmap table.");
1564         return {
1565           platformId: -1,
1566           encodingId: -1,
1567           mappings: [],
1568           hasShortCmap: false,
1569         };
1570       }
1571 
1572       const format = file.getUint16();
1573       let hasShortCmap = false;
1574       const mappings = [];
1575       let j, glyphId;
1576 
1577       // TODO(mack): refactor this cmap subtable reading logic out
1578       if (format === 0) {
1579         file.skip(2 + 2); // length + language
1580 
1581         for (j = 0; j < 256; j++) {
1582           const index = file.getByte();
1583           if (!index) {
1584             continue;
1585           }
1586           mappings.push({
1587             charCode: j,
1588             glyphId: index,
1589           });
1590         }
1591         hasShortCmap = true;
1592       } else if (format === 2) {
1593         file.skip(2 + 2); // length + language
1594 
1595         const subHeaderKeys = [];
1596         let maxSubHeaderKey = 0;
1597         // Read subHeaderKeys. If subHeaderKeys[i] === 0, then i is a
1598         // single-byte character. Otherwise, i is the first byte of a
1599         // multi-byte character, and the value is 8*index into
1600         // subHeaders.
1601         for (let i = 0; i < 256; i++) {
1602           const subHeaderKey = file.getUint16() >> 3;
1603           subHeaderKeys.push(subHeaderKey);
1604           maxSubHeaderKey = Math.max(subHeaderKey, maxSubHeaderKey);
1605         }
1606         // Read subHeaders. The number of entries is determined
1607         // dynamically based on the subHeaderKeys found above.
1608         const subHeaders = [];
1609         for (let i = 0; i <= maxSubHeaderKey; i++) {
1610           subHeaders.push({
1611             firstCode: file.getUint16(),
1612             entryCount: file.getUint16(),
1613             idDelta: signedInt16(file.getByte(), file.getByte()),
1614             idRangePos: file.pos + file.getUint16(),
1615           });
1616         }
1617         for (let i = 0; i < 256; i++) {
1618           if (subHeaderKeys[i] === 0) {
1619             // i is a single-byte code.
1620             file.pos = subHeaders[0].idRangePos + 2 * i;
1621             glyphId = file.getUint16();
1622             mappings.push({
1623               charCode: i,
1624               glyphId,
1625             });
1626           } else {
1627             // i is the first byte of a two-byte code.
1628             const s = subHeaders[subHeaderKeys[i]];
1629             for (j = 0; j < s.entryCount; j++) {
1630               const charCode = (i << 8) + j + s.firstCode;
1631               file.pos = s.idRangePos + 2 * j;
1632               glyphId = file.getUint16();
1633               if (glyphId !== 0) {
1634                 glyphId = (glyphId + s.idDelta) % 65536;
1635               }
1636               mappings.push({
1637                 charCode,
1638                 glyphId,
1639               });
1640             }
1641           }
1642         }
1643       } else if (format === 4) {
1644         file.skip(2 + 2); // length + language
1645 
1646         // re-creating the table in format 4 since the encoding
1647         // might be changed
1648         const segCount = file.getUint16() >> 1;
1649         file.skip(6); // skipping range fields
1650         const segments = [];
1651         let segIndex;
1652         for (segIndex = 0; segIndex < segCount; segIndex++) {
1653           segments.push({ end: file.getUint16() });
1654         }
1655         file.skip(2);
1656         for (segIndex = 0; segIndex < segCount; segIndex++) {
1657           segments[segIndex].start = file.getUint16();
1658         }
1659 
1660         for (segIndex = 0; segIndex < segCount; segIndex++) {
1661           segments[segIndex].delta = file.getUint16();
1662         }
1663 
1664         let offsetsCount = 0,
1665           offsetIndex;
1666         for (segIndex = 0; segIndex < segCount; segIndex++) {
1667           segment = segments[segIndex];
1668           const rangeOffset = file.getUint16();
1669           if (!rangeOffset) {
1670             segment.offsetIndex = -1;
1671             continue;
1672           }
1673 
1674           offsetIndex = (rangeOffset >> 1) - (segCount - segIndex);
1675           segment.offsetIndex = offsetIndex;
1676           offsetsCount = Math.max(
1677             offsetsCount,
1678             offsetIndex + segment.end - segment.start + 1
1679           );
1680         }
1681 
1682         const offsets = [];
1683         for (j = 0; j < offsetsCount; j++) {
1684           offsets.push(file.getUint16());
1685         }
1686 
1687         for (segIndex = 0; segIndex < segCount; segIndex++) {
1688           segment = segments[segIndex];
1689           start = segment.start;
1690           const end = segment.end;
1691           const delta = segment.delta;
1692           offsetIndex = segment.offsetIndex;
1693 
1694           for (j = start; j <= end; j++) {
1695             if (j === 0xffff) {
1696               continue;
1697             }
1698 
1699             glyphId = offsetIndex < 0 ? j : offsets[offsetIndex + j - start];
1700             glyphId = (glyphId + delta) & 0xffff;
1701             mappings.push({
1702               charCode: j,
1703               glyphId,
1704             });
1705           }
1706         }
1707       } else if (format === 6) {
1708         file.skip(2 + 2); // length + language
1709 
1710         // Format 6 is a 2-bytes dense mapping, which means the font data
1711         // lives glue together even if they are pretty far in the unicode
1712         // table. (This looks weird, so I can have missed something), this
1713         // works on Linux but seems to fails on Mac so let's rewrite the
1714         // cmap table to a 3-1-4 style
1715         const firstCode = file.getUint16();
1716         const entryCount = file.getUint16();
1717 
1718         for (j = 0; j < entryCount; j++) {
1719           glyphId = file.getUint16();
1720           const charCode = firstCode + j;
1721 
1722           mappings.push({
1723             charCode,
1724             glyphId,
1725           });
1726         }
1727       } else if (format === 12) {
1728         file.skip(2 + 4 + 4); // reserved + length + language
1729 
1730         const nGroups = file.getInt32() >>> 0;
1731         for (j = 0; j < nGroups; j++) {
1732           const startCharCode = file.getInt32() >>> 0;
1733           const endCharCode = file.getInt32() >>> 0;
1734           let glyphCode = file.getInt32() >>> 0;
1735 
1736           for (
1737             let charCode = startCharCode;
1738             charCode <= endCharCode;
1739             charCode++
1740           ) {
1741             mappings.push({
1742               charCode,
1743               glyphId: glyphCode++,
1744             });
1745           }
1746         }
1747       } else {
1748         warn("cmap table has unsupported format: " + format);
1749         return {
1750           platformId: -1,
1751           encodingId: -1,
1752           mappings: [],
1753           hasShortCmap: false,
1754         };
1755       }
1756 
1757       // removing duplicate entries
1758       mappings.sort(function (a, b) {
1759         return a.charCode - b.charCode;
1760       });
1761       for (let i = 1; i < mappings.length; i++) {
1762         if (mappings[i - 1].charCode === mappings[i].charCode) {
1763           mappings.splice(i, 1);
1764           i--;
1765         }
1766       }
1767 
1768       return {
1769         platformId: potentialTable.platformId,
1770         encodingId: potentialTable.encodingId,
1771         mappings,
1772         hasShortCmap,
1773       };
1774     }
1775 
1776     function sanitizeMetrics(
1777       file,
1778       header,
1779       metrics,
1780       headTable,
1781       numGlyphs,
1782       dupFirstEntry
1783     ) {
1784       if (!header) {
1785         if (metrics) {
1786           metrics.data = null;
1787         }
1788         return;
1789       }
1790 
1791       file.pos = (file.start || 0) + header.offset;
1792       file.pos += 4; // version
1793       file.pos += 2; // ascent
1794       file.pos += 2; // descent
1795       file.pos += 2; // linegap
1796       file.pos += 2; // adv_width_max
1797       file.pos += 2; // min_sb1
1798       file.pos += 2; // min_sb2
1799       file.pos += 2; // max_extent
1800       file.pos += 2; // caret_slope_rise
1801       file.pos += 2; // caret_slope_run
1802       const caretOffset = file.getUint16();
1803       file.pos += 8; // reserved
1804       file.pos += 2; // format
1805       let numOfMetrics = file.getUint16();
1806 
1807       if (caretOffset !== 0) {
1808         const macStyle = int16(headTable.data[44], headTable.data[45]);
1809         if (!(macStyle & 2)) {
1810           // Suppress OTS warnings about the `caretOffset` in the hhea-table.
1811           header.data[22] = 0;
1812           header.data[23] = 0;
1813         }
1814       }
1815 
1816       if (numOfMetrics > numGlyphs) {
1817         info(
1818           `The numOfMetrics (${numOfMetrics}) should not be ` +
1819             `greater than the numGlyphs (${numGlyphs}).`
1820         );
1821         // Reduce numOfMetrics if it is greater than numGlyphs
1822         numOfMetrics = numGlyphs;
1823         header.data[34] = (numOfMetrics & 0xff00) >> 8;
1824         header.data[35] = numOfMetrics & 0x00ff;
1825       }
1826 
1827       const numOfSidebearings = numGlyphs - numOfMetrics;
1828       const numMissing =
1829         numOfSidebearings - ((metrics.length - numOfMetrics * 4) >> 1);
1830 
1831       if (numMissing > 0) {
1832         // For each missing glyph, we set both the width and lsb to 0 (zero).
1833         // Since we need to add two properties for each glyph, this explains
1834         // the use of |numMissing * 2| when initializing the typed array.
1835         const entries = new Uint8Array(metrics.length + numMissing * 2);
1836         entries.set(metrics.data);
1837         if (dupFirstEntry) {
1838           // Set the sidebearing value of the duplicated glyph.
1839           entries[metrics.length] = metrics.data[2];
1840           entries[metrics.length + 1] = metrics.data[3];
1841         }
1842         metrics.data = entries;
1843       }
1844     }
1845 
1846     function sanitizeGlyph(
1847       source,
1848       sourceStart,
1849       sourceEnd,
1850       dest,
1851       destStart,
1852       hintsValid
1853     ) {
1854       const glyphProfile = {
1855         length: 0,
1856         sizeOfInstructions: 0,
1857       };
1858       if (
1859         sourceStart < 0 ||
1860         sourceStart >= source.length ||
1861         sourceEnd > source.length ||
1862         sourceEnd - sourceStart <= 12
1863       ) {
1864         // If the offsets are wrong or the glyph is too small, remove it.
1865         return glyphProfile;
1866       }
1867       const glyf = source.subarray(sourceStart, sourceEnd);
1868 
1869       // Sanitize the glyph bounding box.
1870       const xMin = signedInt16(glyf[2], glyf[3]);
1871       const yMin = signedInt16(glyf[4], glyf[5]);
1872       const xMax = signedInt16(glyf[6], glyf[7]);
1873       const yMax = signedInt16(glyf[8], glyf[9]);
1874 
1875       if (xMin > xMax) {
1876         writeSignedInt16(glyf, 2, xMax);
1877         writeSignedInt16(glyf, 6, xMin);
1878       }
1879       if (yMin > yMax) {
1880         writeSignedInt16(glyf, 4, yMax);
1881         writeSignedInt16(glyf, 8, yMin);
1882       }
1883 
1884       const contoursCount = signedInt16(glyf[0], glyf[1]);
1885       if (contoursCount < 0) {
1886         if (contoursCount < -1) {
1887           // OTS doesn't like contour count to be less than -1.
1888           // The glyph data offsets are very likely wrong and
1889           // having something lower than -1, very likely, implies
1890           // to have some garbage data.
1891           return glyphProfile;
1892         }
1893         // complex glyph, writing as is
1894         dest.set(glyf, destStart);
1895         glyphProfile.length = glyf.length;
1896         return glyphProfile;
1897       }
1898 
1899       let i,
1900         j = 10,
1901         flagsCount = 0;
1902       for (i = 0; i < contoursCount; i++) {
1903         const endPoint = (glyf[j] << 8) | glyf[j + 1];
1904         flagsCount = endPoint + 1;
1905         j += 2;
1906       }
1907       // skipping instructions
1908       const instructionsStart = j;
1909       const instructionsLength = (glyf[j] << 8) | glyf[j + 1];
1910       glyphProfile.sizeOfInstructions = instructionsLength;
1911       j += 2 + instructionsLength;
1912       const instructionsEnd = j;
1913       // validating flags
1914       let coordinatesLength = 0;
1915       for (i = 0; i < flagsCount; i++) {
1916         const flag = glyf[j++];
1917         if (flag & 0xc0) {
1918           // reserved flags must be zero, cleaning up
1919           glyf[j - 1] = flag & 0x3f;
1920         }
1921         let xLength = 2;
1922         if (flag & 2) {
1923           xLength = 1;
1924         } else if (flag & 16) {
1925           xLength = 0;
1926         }
1927         let yLength = 2;
1928         if (flag & 4) {
1929           yLength = 1;
1930         } else if (flag & 32) {
1931           yLength = 0;
1932         }
1933         const xyLength = xLength + yLength;
1934         coordinatesLength += xyLength;
1935         if (flag & 8) {
1936           const repeat = glyf[j++];
1937           if (repeat === 0) {
1938             // The repeat count should be non-zero when the repeat flag is set.
1939             glyf[j - 1] ^= 8;
1940           }
1941           i += repeat;
1942           coordinatesLength += repeat * xyLength;
1943         }
1944       }
1945       // glyph without coordinates will be rejected
1946       if (coordinatesLength === 0) {
1947         return glyphProfile;
1948       }
1949       let glyphDataLength = j + coordinatesLength;
1950       if (glyphDataLength > glyf.length) {
1951         // not enough data for coordinates
1952         return glyphProfile;
1953       }
1954       if (!hintsValid && instructionsLength > 0) {
1955         dest.set(glyf.subarray(0, instructionsStart), destStart);
1956         dest.set([0, 0], destStart + instructionsStart);
1957         dest.set(
1958           glyf.subarray(instructionsEnd, glyphDataLength),
1959           destStart + instructionsStart + 2
1960         );
1961         glyphDataLength -= instructionsLength;
1962         if (glyf.length - glyphDataLength > 3) {
1963           glyphDataLength = (glyphDataLength + 3) & ~3;
1964         }
1965         glyphProfile.length = glyphDataLength;
1966         return glyphProfile;
1967       }
1968       if (glyf.length - glyphDataLength > 3) {
1969         // truncating and aligning to 4 bytes the long glyph data
1970         glyphDataLength = (glyphDataLength + 3) & ~3;
1971         dest.set(glyf.subarray(0, glyphDataLength), destStart);
1972         glyphProfile.length = glyphDataLength;
1973         return glyphProfile;
1974       }
1975       // glyph data is fine
1976       dest.set(glyf, destStart);
1977       glyphProfile.length = glyf.length;
1978       return glyphProfile;
1979     }
1980 
1981     function sanitizeHead(head, numGlyphs, locaLength) {
1982       const data = head.data;
1983 
1984       // Validate version:
1985       // Should always be 0x00010000
1986       const version = int32(data[0], data[1], data[2], data[3]);
1987       if (version >> 16 !== 1) {
1988         info("Attempting to fix invalid version in head table: " + version);
1989         data[0] = 0;
1990         data[1] = 1;
1991         data[2] = 0;
1992         data[3] = 0;
1993       }
1994 
1995       const indexToLocFormat = int16(data[50], data[51]);
1996       if (indexToLocFormat < 0 || indexToLocFormat > 1) {
1997         info(
1998           "Attempting to fix invalid indexToLocFormat in head table: " +
1999             indexToLocFormat
2000         );
2001 
2002         // The value of indexToLocFormat should be 0 if the loca table
2003         // consists of short offsets, and should be 1 if the loca table
2004         // consists of long offsets.
2005         //
2006         // The number of entries in the loca table should be numGlyphs + 1.
2007         //
2008         // Using this information, we can work backwards to deduce if the
2009         // size of each offset in the loca table, and thus figure out the
2010         // appropriate value for indexToLocFormat.
2011 
2012         const numGlyphsPlusOne = numGlyphs + 1;
2013         if (locaLength === numGlyphsPlusOne << 1) {
2014           // 0x0000 indicates the loca table consists of short offsets
2015           data[50] = 0;
2016           data[51] = 0;
2017         } else if (locaLength === numGlyphsPlusOne << 2) {
2018           // 0x0001 indicates the loca table consists of long offsets
2019           data[50] = 0;
2020           data[51] = 1;
2021         } else {
2022           throw new FormatError(
2023             "Could not fix indexToLocFormat: " + indexToLocFormat
2024           );
2025         }
2026       }
2027     }
2028 
2029     function sanitizeGlyphLocations(
2030       loca,
2031       glyf,
2032       numGlyphs,
2033       isGlyphLocationsLong,
2034       hintsValid,
2035       dupFirstEntry,
2036       maxSizeOfInstructions
2037     ) {
2038       let itemSize, itemDecode, itemEncode;
2039       if (isGlyphLocationsLong) {
2040         itemSize = 4;
2041         itemDecode = function fontItemDecodeLong(data, offset) {
2042           return (
2043             (data[offset] << 24) |
2044             (data[offset + 1] << 16) |
2045             (data[offset + 2] << 8) |
2046             data[offset + 3]
2047           );
2048         };
2049         itemEncode = function fontItemEncodeLong(data, offset, value) {
2050           data[offset] = (value >>> 24) & 0xff;
2051           data[offset + 1] = (value >> 16) & 0xff;
2052           data[offset + 2] = (value >> 8) & 0xff;
2053           data[offset + 3] = value & 0xff;
2054         };
2055       } else {
2056         itemSize = 2;
2057         itemDecode = function fontItemDecode(data, offset) {
2058           return (data[offset] << 9) | (data[offset + 1] << 1);
2059         };
2060         itemEncode = function fontItemEncode(data, offset, value) {
2061           data[offset] = (value >> 9) & 0xff;
2062           data[offset + 1] = (value >> 1) & 0xff;
2063         };
2064       }
2065       // The first glyph is duplicated.
2066       const numGlyphsOut = dupFirstEntry ? numGlyphs + 1 : numGlyphs;
2067       const locaDataSize = itemSize * (1 + numGlyphsOut);
2068       // Resize loca table to account for duplicated glyph.
2069       const locaData = new Uint8Array(locaDataSize);
2070       locaData.set(loca.data.subarray(0, locaDataSize));
2071       loca.data = locaData;
2072       // removing the invalid glyphs
2073       const oldGlyfData = glyf.data;
2074       const oldGlyfDataLength = oldGlyfData.length;
2075       const newGlyfData = new Uint8Array(oldGlyfDataLength);
2076 
2077       // The spec says the offsets should be in ascending order, however
2078       // this is not true for some fonts or they use the offset of 0 to mark a
2079       // glyph as missing. OTS requires the offsets to be in order and not to
2080       // be zero, so we must sort and rebuild the loca table and potentially
2081       // re-arrange the glyf data.
2082       let i, j;
2083       const locaEntries = [];
2084       // There are numGlyphs + 1 loca table entries.
2085       for (i = 0, j = 0; i < numGlyphs + 1; i++, j += itemSize) {
2086         let offset = itemDecode(locaData, j);
2087         if (offset > oldGlyfDataLength) {
2088           offset = oldGlyfDataLength;
2089         }
2090         locaEntries.push({
2091           index: i,
2092           offset,
2093           endOffset: 0,
2094         });
2095       }
2096       locaEntries.sort((a, b) => a.offset - b.offset);
2097       // Now the offsets are sorted, calculate the end offset of each glyph.
2098       // The last loca entry's endOffset is not calculated since it's the end
2099       // of the data and will be stored on the previous entry's endOffset.
2100       for (i = 0; i < numGlyphs; i++) {
2101         locaEntries[i].endOffset = locaEntries[i + 1].offset;
2102       }
2103       // Re-sort so glyphs aren't out of order.
2104       locaEntries.sort((a, b) => a.index - b.index);
2105       // Calculate the endOffset of the "first" glyph correctly when there are
2106       // *multiple* empty ones at the start of the data (fixes issue14618.pdf).
2107       for (i = 0; i < numGlyphs; i++) {
2108         const { offset, endOffset } = locaEntries[i];
2109         if (offset !== 0 || endOffset !== 0) {
2110           break;
2111         }
2112         const nextOffset = locaEntries[i + 1].offset;
2113         if (nextOffset === 0) {
2114           continue;
2115         }
2116         locaEntries[i].endOffset = nextOffset;
2117         break;
2118       }
2119 
2120       // If the last offset is 0 in the loca table then we can't compute the
2121       // endOffset for the last glyph. So in such a case we set the endOffset
2122       // to the end of the data (fixes issue #17671).
2123       const last = locaEntries.at(-2);
2124       if (last.offset !== 0 && last.endOffset === 0) {
2125         last.endOffset = oldGlyfDataLength;
2126       }
2127 
2128       const missingGlyphs = Object.create(null);
2129       let writeOffset = 0;
2130       itemEncode(locaData, 0, writeOffset);
2131       for (i = 0, j = itemSize; i < numGlyphs; i++, j += itemSize) {
2132         const glyphProfile = sanitizeGlyph(
2133           oldGlyfData,
2134           locaEntries[i].offset,
2135           locaEntries[i].endOffset,
2136           newGlyfData,
2137           writeOffset,
2138           hintsValid
2139         );
2140         const newLength = glyphProfile.length;
2141         if (newLength === 0) {
2142           missingGlyphs[i] = true;
2143         }
2144         if (glyphProfile.sizeOfInstructions > maxSizeOfInstructions) {
2145           maxSizeOfInstructions = glyphProfile.sizeOfInstructions;
2146         }
2147         writeOffset += newLength;
2148         itemEncode(locaData, j, writeOffset);
2149       }
2150 
2151       if (writeOffset === 0) {
2152         // glyf table cannot be empty -- redoing the glyf and loca tables
2153         // to have single glyph with one point
2154         const simpleGlyph = new Uint8Array([
2155           0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 49, 0,
2156         ]);
2157         for (i = 0, j = itemSize; i < numGlyphsOut; i++, j += itemSize) {
2158           itemEncode(locaData, j, simpleGlyph.length);
2159         }
2160         glyf.data = simpleGlyph;
2161       } else if (dupFirstEntry) {
2162         // Browsers will not display a glyph at position 0. Typically glyph 0
2163         // is notdef, but a number of fonts put a valid glyph there so it must
2164         // be duplicated and appended.
2165         const firstEntryLength = itemDecode(locaData, itemSize);
2166         if (newGlyfData.length > firstEntryLength + writeOffset) {
2167           glyf.data = newGlyfData.subarray(0, firstEntryLength + writeOffset);
2168         } else {
2169           glyf.data = new Uint8Array(firstEntryLength + writeOffset);
2170           glyf.data.set(newGlyfData.subarray(0, writeOffset));
2171         }
2172         glyf.data.set(newGlyfData.subarray(0, firstEntryLength), writeOffset);
2173         itemEncode(
2174           loca.data,
2175           locaData.length - itemSize,
2176           writeOffset + firstEntryLength
2177         );
2178       } else {
2179         glyf.data = newGlyfData.subarray(0, writeOffset);
2180       }
2181       return {
2182         missingGlyphs,
2183         maxSizeOfInstructions,
2184       };
2185     }
2186 
2187     function readPostScriptTable(post, propertiesObj, maxpNumGlyphs) {
2188       const start = (font.start || 0) + post.offset;
2189       font.pos = start;
2190 
2191       const length = post.length,
2192         end = start + length;
2193       const version = font.getInt32();
2194       // skip rest to the tables
2195       font.skip(28);
2196 
2197       let glyphNames;
2198       let valid = true;
2199       let i;
2200 
2201       switch (version) {
2202         case 0x00010000:
2203           glyphNames = MacStandardGlyphOrdering;
2204           break;
2205         case 0x00020000:
2206           const numGlyphs = font.getUint16();
2207           if (numGlyphs !== maxpNumGlyphs) {
2208             valid = false;
2209             break;
2210           }
2211           const glyphNameIndexes = [];
2212           for (i = 0; i < numGlyphs; ++i) {
2213             const index = font.getUint16();
2214             if (index >= 32768) {
2215               valid = false;
2216               break;
2217             }
2218             glyphNameIndexes.push(index);
2219           }
2220           if (!valid) {
2221             break;
2222           }
2223           const customNames = [],
2224             strBuf = [];
2225           while (font.pos < end) {
2226             const stringLength = font.getByte();
2227             strBuf.length = stringLength;
2228             for (i = 0; i < stringLength; ++i) {
2229               strBuf[i] = String.fromCharCode(font.getByte());
2230             }
2231             customNames.push(strBuf.join(""));
2232           }
2233           glyphNames = [];
2234           for (i = 0; i < numGlyphs; ++i) {
2235             const j = glyphNameIndexes[i];
2236             if (j < 258) {
2237               glyphNames.push(MacStandardGlyphOrdering[j]);
2238               continue;
2239             }
2240             glyphNames.push(customNames[j - 258]);
2241           }
2242           break;
2243         case 0x00030000:
2244           break;
2245         default:
2246           warn("Unknown/unsupported post table version " + version);
2247           valid = false;
2248           if (propertiesObj.defaultEncoding) {
2249             glyphNames = propertiesObj.defaultEncoding;
2250           }
2251           break;
2252       }
2253       propertiesObj.glyphNames = glyphNames;
2254       return valid;
2255     }
2256 
2257     function readNameTable(nameTable) {
2258       const start = (font.start || 0) + nameTable.offset;
2259       font.pos = start;
2260 
2261       const names = [[], []],
2262         records = [];
2263       const length = nameTable.length,
2264         end = start + length;
2265       const format = font.getUint16();
2266       const FORMAT_0_HEADER_LENGTH = 6;
2267       if (format !== 0 || length < FORMAT_0_HEADER_LENGTH) {
2268         // unsupported name table format or table "too" small
2269         return [names, records];
2270       }
2271       const numRecords = font.getUint16();
2272       const stringsStart = font.getUint16();
2273       const NAME_RECORD_LENGTH = 12;
2274       let i, ii;
2275 
2276       for (i = 0; i < numRecords && font.pos + NAME_RECORD_LENGTH <= end; i++) {
2277         const r = {
2278           platform: font.getUint16(),
2279           encoding: font.getUint16(),
2280           language: font.getUint16(),
2281           name: font.getUint16(),
2282           length: font.getUint16(),
2283           offset: font.getUint16(),
2284         };
2285         // using only Macintosh and Windows platform/encoding names
2286         if (isMacNameRecord(r) || isWinNameRecord(r)) {
2287           records.push(r);
2288         }
2289       }
2290       for (i = 0, ii = records.length; i < ii; i++) {
2291         const record = records[i];
2292         if (record.length <= 0) {
2293           continue; // Nothing to process, ignoring.
2294         }
2295         const pos = start + stringsStart + record.offset;
2296         if (pos + record.length > end) {
2297           continue; // outside of name table, ignoring
2298         }
2299         font.pos = pos;
2300         const nameIndex = record.name;
2301         if (record.encoding) {
2302           // unicode
2303           let str = "";
2304           for (let j = 0, jj = record.length; j < jj; j += 2) {
2305             str += String.fromCharCode(font.getUint16());
2306           }
2307           names[1][nameIndex] = str;
2308         } else {
2309           names[0][nameIndex] = font.getString(record.length);
2310         }
2311       }
2312       return [names, records];
2313     }
2314 
2315     // prettier-ignore
2316     const TTOpsStackDeltas = [
2317       0, 0, 0, 0, 0, 0, 0, 0, -2, -2, -2, -2, 0, 0, -2, -5,
2318       -1, -1, -1, -1, -1, -1, -1, -1, 0, 0, -1, 0, -1, -1, -1, -1,
2319       1, -1, -999, 0, 1, 0, -1, -2, 0, -1, -2, -1, -1, 0, -1, -1,
2320       0, 0, -999, -999, -1, -1, -1, -1, -2, -999, -2, -2, -999, 0, -2, -2,
2321       0, 0, -2, 0, -2, 0, 0, 0, -2, -1, -1, 1, 1, 0, 0, -1,
2322       -1, -1, -1, -1, -1, -1, 0, 0, -1, 0, -1, -1, 0, -999, -1, -1,
2323       -1, -1, -1, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
2324       -2, -999, -999, -999, -999, -999, -1, -1, -2, -2, 0, 0, 0, 0, -1, -1,
2325       -999, -2, -2, 0, 0, -1, -2, -2, 0, 0, 0, -1, -1, -1, -2];
2326     // 0xC0-DF == -1 and 0xE0-FF == -2
2327 
2328     function sanitizeTTProgram(table, ttContext) {
2329       let data = table.data;
2330       let i = 0,
2331         j,
2332         n,
2333         b,
2334         funcId,
2335         pc,
2336         lastEndf = 0,
2337         lastDeff = 0;
2338       const stack = [];
2339       const callstack = [];
2340       const functionsCalled = [];
2341       let tooComplexToFollowFunctions = ttContext.tooComplexToFollowFunctions;
2342       let inFDEF = false,
2343         ifLevel = 0,
2344         inELSE = 0;
2345       for (let ii = data.length; i < ii; ) {
2346         const op = data[i++];
2347         // The TrueType instruction set docs can be found at
2348         // https://developer.apple.com/fonts/TTRefMan/RM05/Chap5.html
2349         if (op === 0x40) {
2350           // NPUSHB - pushes n bytes
2351           n = data[i++];
2352           if (inFDEF || inELSE) {
2353             i += n;
2354           } else {
2355             for (j = 0; j < n; j++) {
2356               stack.push(data[i++]);
2357             }
2358           }
2359         } else if (op === 0x41) {
2360           // NPUSHW - pushes n words
2361           n = data[i++];
2362           if (inFDEF || inELSE) {
2363             i += n * 2;
2364           } else {
2365             for (j = 0; j < n; j++) {
2366               b = data[i++];
2367               stack.push((b << 8) | data[i++]);
2368             }
2369           }
2370         } else if ((op & 0xf8) === 0xb0) {
2371           // PUSHB - pushes bytes
2372           n = op - 0xb0 + 1;
2373           if (inFDEF || inELSE) {
2374             i += n;
2375           } else {
2376             for (j = 0; j < n; j++) {
2377               stack.push(data[i++]);
2378             }
2379           }
2380         } else if ((op & 0xf8) === 0xb8) {
2381           // PUSHW - pushes words
2382           n = op - 0xb8 + 1;
2383           if (inFDEF || inELSE) {
2384             i += n * 2;
2385           } else {
2386             for (j = 0; j < n; j++) {
2387               b = data[i++];
2388               stack.push((b << 8) | data[i++]);
2389             }
2390           }
2391         } else if (op === 0x2b && !tooComplexToFollowFunctions) {
2392           // CALL
2393           if (!inFDEF && !inELSE) {
2394             // collecting information about which functions are used
2395             funcId = stack.at(-1);
2396             if (isNaN(funcId)) {
2397               info("TT: CALL empty stack (or invalid entry).");
2398             } else {
2399               ttContext.functionsUsed[funcId] = true;
2400               if (funcId in ttContext.functionsStackDeltas) {
2401                 const newStackLength =
2402                   stack.length + ttContext.functionsStackDeltas[funcId];
2403                 if (newStackLength < 0) {
2404                   warn("TT: CALL invalid functions stack delta.");
2405                   ttContext.hintsValid = false;
2406                   return;
2407                 }
2408                 stack.length = newStackLength;
2409               } else if (
2410                 funcId in ttContext.functionsDefined &&
2411                 !functionsCalled.includes(funcId)
2412               ) {
2413                 callstack.push({ data, i, stackTop: stack.length - 1 });
2414                 functionsCalled.push(funcId);
2415                 pc = ttContext.functionsDefined[funcId];
2416                 if (!pc) {
2417                   warn("TT: CALL non-existent function");
2418                   ttContext.hintsValid = false;
2419                   return;
2420                 }
2421                 data = pc.data;
2422                 i = pc.i;
2423               }
2424             }
2425           }
2426         } else if (op === 0x2c && !tooComplexToFollowFunctions) {
2427           // FDEF
2428           if (inFDEF || inELSE) {
2429             warn("TT: nested FDEFs not allowed");
2430             tooComplexToFollowFunctions = true;
2431           }
2432           inFDEF = true;
2433           // collecting information about which functions are defined
2434           lastDeff = i;
2435           funcId = stack.pop();
2436           ttContext.functionsDefined[funcId] = { data, i };
2437         } else if (op === 0x2d) {
2438           // ENDF - end of function
2439           if (inFDEF) {
2440             inFDEF = false;
2441             lastEndf = i;
2442           } else {
2443             pc = callstack.pop();
2444             if (!pc) {
2445               warn("TT: ENDF bad stack");
2446               ttContext.hintsValid = false;
2447               return;
2448             }
2449             funcId = functionsCalled.pop();
2450             data = pc.data;
2451             i = pc.i;
2452             ttContext.functionsStackDeltas[funcId] = stack.length - pc.stackTop;
2453           }
2454         } else if (op === 0x89) {
2455           // IDEF - instruction definition
2456           if (inFDEF || inELSE) {
2457             warn("TT: nested IDEFs not allowed");
2458             tooComplexToFollowFunctions = true;
2459           }
2460           inFDEF = true;
2461           // recording it as a function to track ENDF
2462           lastDeff = i;
2463         } else if (op === 0x58) {
2464           // IF
2465           ++ifLevel;
2466         } else if (op === 0x1b) {
2467           // ELSE
2468           inELSE = ifLevel;
2469         } else if (op === 0x59) {
2470           // EIF
2471           if (inELSE === ifLevel) {
2472             inELSE = 0;
2473           }
2474           --ifLevel;
2475         } else if (op === 0x1c) {
2476           // JMPR
2477           if (!inFDEF && !inELSE) {
2478             const offset = stack.at(-1);
2479             // only jumping forward to prevent infinite loop
2480             if (offset > 0) {
2481               i += offset - 1;
2482             }
2483           }
2484         }
2485         // Adjusting stack not extactly, but just enough to get function id
2486         if (!inFDEF && !inELSE) {
2487           let stackDelta = 0;
2488           if (op <= 0x8e) {
2489             stackDelta = TTOpsStackDeltas[op];
2490           } else if (op >= 0xc0 && op <= 0xdf) {
2491             stackDelta = -1;
2492           } else if (op >= 0xe0) {
2493             stackDelta = -2;
2494           }
2495           if (op >= 0x71 && op <= 0x75) {
2496             n = stack.pop();
2497             if (!isNaN(n)) {
2498               stackDelta = -n * 2;
2499             }
2500           }
2501           while (stackDelta < 0 && stack.length > 0) {
2502             stack.pop();
2503             stackDelta++;
2504           }
2505           while (stackDelta > 0) {
2506             stack.push(NaN); // pushing any number into stack
2507             stackDelta--;
2508           }
2509         }
2510       }
2511       ttContext.tooComplexToFollowFunctions = tooComplexToFollowFunctions;
2512       const content = [data];
2513       if (i > data.length) {
2514         content.push(new Uint8Array(i - data.length));
2515       }
2516       if (lastDeff > lastEndf) {
2517         warn("TT: complementing a missing function tail");
2518         // new function definition started, but not finished
2519         // complete function by [CLEAR, ENDF]
2520         content.push(new Uint8Array([0x22, 0x2d]));
2521       }
2522       foldTTTable(table, content);
2523     }
2524 
2525     function checkInvalidFunctions(ttContext, maxFunctionDefs) {
2526       if (ttContext.tooComplexToFollowFunctions) {
2527         return;
2528       }
2529       if (ttContext.functionsDefined.length > maxFunctionDefs) {
2530         warn("TT: more functions defined than expected");
2531         ttContext.hintsValid = false;
2532         return;
2533       }
2534       for (let j = 0, jj = ttContext.functionsUsed.length; j < jj; j++) {
2535         if (j > maxFunctionDefs) {
2536           warn("TT: invalid function id: " + j);
2537           ttContext.hintsValid = false;
2538           return;
2539         }
2540         if (ttContext.functionsUsed[j] && !ttContext.functionsDefined[j]) {
2541           warn("TT: undefined function: " + j);
2542           ttContext.hintsValid = false;
2543           return;
2544         }
2545       }
2546     }
2547 
2548     function foldTTTable(table, content) {
2549       if (content.length > 1) {
2550         // concatenating the content items
2551         let newLength = 0;
2552         let j, jj;
2553         for (j = 0, jj = content.length; j < jj; j++) {
2554           newLength += content[j].length;
2555         }
2556         newLength = (newLength + 3) & ~3;
2557         const result = new Uint8Array(newLength);
2558         let pos = 0;
2559         for (j = 0, jj = content.length; j < jj; j++) {
2560           result.set(content[j], pos);
2561           pos += content[j].length;
2562         }
2563         table.data = result;
2564         table.length = newLength;
2565       }
2566     }
2567 
2568     function sanitizeTTPrograms(fpgm, prep, cvt, maxFunctionDefs) {
2569       const ttContext = {
2570         functionsDefined: [],
2571         functionsUsed: [],
2572         functionsStackDeltas: [],
2573         tooComplexToFollowFunctions: false,
2574         hintsValid: true,
2575       };
2576       if (fpgm) {
2577         sanitizeTTProgram(fpgm, ttContext);
2578       }
2579       if (prep) {
2580         sanitizeTTProgram(prep, ttContext);
2581       }
2582       if (fpgm) {
2583         checkInvalidFunctions(ttContext, maxFunctionDefs);
2584       }
2585       if (cvt && cvt.length & 1) {
2586         const cvtData = new Uint8Array(cvt.length + 1);
2587         cvtData.set(cvt.data);
2588         cvt.data = cvtData;
2589       }
2590       return ttContext.hintsValid;
2591     }
2592 
2593     // The following steps modify the original font data, making copy
2594     font = new Stream(new Uint8Array(font.getBytes()));
2595 
2596     let header, tables;
2597     if (isTrueTypeCollectionFile(font)) {
2598       const ttcData = readTrueTypeCollectionData(font, this.name);
2599       header = ttcData.header;
2600       tables = ttcData.tables;
2601     } else {
2602       header = readOpenTypeHeader(font);
2603       tables = readTables(font, header.numTables);
2604     }
2605     let cff, cffFile;
2606 
2607     const isTrueType = !tables["CFF "];
2608     if (!isTrueType) {
2609       const isComposite =
2610         properties.composite &&
2611         (properties.cidToGidMap?.length > 0 ||
2612           !(properties.cMap instanceof IdentityCMap));
2613       // OpenType font (skip composite fonts with non-default glyph mapping).
2614       if (
2615         (header.version === "OTTO" && !isComposite) ||
2616         !tables.head ||
2617         !tables.hhea ||
2618         !tables.maxp ||
2619         !tables.post
2620       ) {
2621         // No major tables: throwing everything at `CFFFont`.
2622         cffFile = new Stream(tables["CFF "].data);
2623         cff = new CFFFont(cffFile, properties);
2624 
2625         adjustWidths(properties);
2626 
2627         return this.convert(name, cff, properties);
2628       }
2629 
2630       delete tables.glyf;
2631       delete tables.loca;
2632       delete tables.fpgm;
2633       delete tables.prep;
2634       delete tables["cvt "];
2635       this.isOpenType = true;
2636     } else {
2637       if (!tables.loca) {
2638         throw new FormatError('Required "loca" table is not found');
2639       }
2640       if (!tables.glyf) {
2641         warn('Required "glyf" table is not found -- trying to recover.');
2642         // Note: We use `sanitizeGlyphLocations` to add dummy glyf data below.
2643         tables.glyf = {
2644           tag: "glyf",
2645           data: new Uint8Array(0),
2646         };
2647       }
2648       this.isOpenType = false;
2649     }
2650 
2651     if (!tables.maxp) {
2652       throw new FormatError('Required "maxp" table is not found');
2653     }
2654 
2655     font.pos = (font.start || 0) + tables.maxp.offset;
2656     let version = font.getInt32();
2657     const numGlyphs = font.getUint16();
2658 
2659     if (version !== 0x00010000 && version !== 0x00005000) {
2660       // https://learn.microsoft.com/en-us/typography/opentype/spec/maxp
2661       if (tables.maxp.length === 6) {
2662         version = 0x0005000;
2663       } else if (tables.maxp.length >= 32) {
2664         version = 0x00010000;
2665       } else {
2666         throw new FormatError(`"maxp" table has a wrong version number`);
2667       }
2668       writeUint32(tables.maxp.data, 0, version);
2669     }
2670 
2671     if (properties.scaleFactors?.length === numGlyphs && isTrueType) {
2672       const { scaleFactors } = properties;
2673       const isGlyphLocationsLong = int16(
2674         tables.head.data[50],
2675         tables.head.data[51]
2676       );
2677 
2678       const glyphs = new GlyfTable({
2679         glyfTable: tables.glyf.data,
2680         isGlyphLocationsLong,
2681         locaTable: tables.loca.data,
2682         numGlyphs,
2683       });
2684       glyphs.scale(scaleFactors);
2685 
2686       const { glyf, loca, isLocationLong } = glyphs.write();
2687       tables.glyf.data = glyf;
2688       tables.loca.data = loca;
2689 
2690       if (isLocationLong !== !!isGlyphLocationsLong) {
2691         tables.head.data[50] = 0;
2692         tables.head.data[51] = isLocationLong ? 1 : 0;
2693       }
2694 
2695       const metrics = tables.hmtx.data;
2696 
2697       for (let i = 0; i < numGlyphs; i++) {
2698         const j = 4 * i;
2699         const advanceWidth = Math.round(
2700           scaleFactors[i] * int16(metrics[j], metrics[j + 1])
2701         );
2702         metrics[j] = (advanceWidth >> 8) & 0xff;
2703         metrics[j + 1] = advanceWidth & 0xff;
2704         const lsb = Math.round(
2705           scaleFactors[i] * signedInt16(metrics[j + 2], metrics[j + 3])
2706         );
2707         writeSignedInt16(metrics, j + 2, lsb);
2708       }
2709     }
2710 
2711     // Glyph 0 is duplicated and appended.
2712     let numGlyphsOut = numGlyphs + 1;
2713     let dupFirstEntry = true;
2714     if (numGlyphsOut > 0xffff) {
2715       dupFirstEntry = false;
2716       numGlyphsOut = numGlyphs;
2717       warn("Not enough space in glyfs to duplicate first glyph.");
2718     }
2719     let maxFunctionDefs = 0;
2720     let maxSizeOfInstructions = 0;
2721     if (version >= 0x00010000 && tables.maxp.length >= 32) {
2722       // maxZones can be invalid
2723       font.pos += 8;
2724       const maxZones = font.getUint16();
2725       if (maxZones > 2) {
2726         // reset to 2 if font has invalid maxZones
2727         tables.maxp.data[14] = 0;
2728         tables.maxp.data[15] = 2;
2729       }
2730       font.pos += 4;
2731       maxFunctionDefs = font.getUint16();
2732       font.pos += 4;
2733       maxSizeOfInstructions = font.getUint16();
2734     }
2735 
2736     tables.maxp.data[4] = numGlyphsOut >> 8;
2737     tables.maxp.data[5] = numGlyphsOut & 255;
2738 
2739     const hintsValid = sanitizeTTPrograms(
2740       tables.fpgm,
2741       tables.prep,
2742       tables["cvt "],
2743       maxFunctionDefs
2744     );
2745     if (!hintsValid) {
2746       delete tables.fpgm;
2747       delete tables.prep;
2748       delete tables["cvt "];
2749     }
2750 
2751     // Ensure the hmtx table contains the advance width and
2752     // sidebearings information for numGlyphs in the maxp table
2753     sanitizeMetrics(
2754       font,
2755       tables.hhea,
2756       tables.hmtx,
2757       tables.head,
2758       numGlyphsOut,
2759       dupFirstEntry
2760     );
2761 
2762     if (!tables.head) {
2763       throw new FormatError('Required "head" table is not found');
2764     }
2765 
2766     sanitizeHead(tables.head, numGlyphs, isTrueType ? tables.loca.length : 0);
2767 
2768     let missingGlyphs = Object.create(null);
2769     if (isTrueType) {
2770       const isGlyphLocationsLong = int16(
2771         tables.head.data[50],
2772         tables.head.data[51]
2773       );
2774       const glyphsInfo = sanitizeGlyphLocations(
2775         tables.loca,
2776         tables.glyf,
2777         numGlyphs,
2778         isGlyphLocationsLong,
2779         hintsValid,
2780         dupFirstEntry,
2781         maxSizeOfInstructions
2782       );
2783       missingGlyphs = glyphsInfo.missingGlyphs;
2784 
2785       // Some fonts have incorrect maxSizeOfInstructions values, so we use
2786       // the computed value instead.
2787       if (version >= 0x00010000 && tables.maxp.length >= 32) {
2788         tables.maxp.data[26] = glyphsInfo.maxSizeOfInstructions >> 8;
2789         tables.maxp.data[27] = glyphsInfo.maxSizeOfInstructions & 255;
2790       }
2791     }
2792     if (!tables.hhea) {
2793       throw new FormatError('Required "hhea" table is not found');
2794     }
2795 
2796     // Sanitizer reduces the glyph advanceWidth to the maxAdvanceWidth
2797     // Sometimes it's 0. That needs to be fixed
2798     if (tables.hhea.data[10] === 0 && tables.hhea.data[11] === 0) {
2799       tables.hhea.data[10] = 0xff;
2800       tables.hhea.data[11] = 0xff;
2801     }
2802 
2803     // Extract some more font properties from the OpenType head and
2804     // hhea tables; yMin and descent value are always negative.
2805     const metricsOverride = {
2806       unitsPerEm: int16(tables.head.data[18], tables.head.data[19]),
2807       yMax: signedInt16(tables.head.data[42], tables.head.data[43]),
2808       yMin: signedInt16(tables.head.data[38], tables.head.data[39]),
2809       ascent: signedInt16(tables.hhea.data[4], tables.hhea.data[5]),
2810       descent: signedInt16(tables.hhea.data[6], tables.hhea.data[7]),
2811       lineGap: signedInt16(tables.hhea.data[8], tables.hhea.data[9]),
2812     };
2813 
2814     // PDF FontDescriptor metrics lie -- using data from actual font.
2815     this.ascent = metricsOverride.ascent / metricsOverride.unitsPerEm;
2816     this.descent = metricsOverride.descent / metricsOverride.unitsPerEm;
2817     this.lineGap = metricsOverride.lineGap / metricsOverride.unitsPerEm;
2818 
2819     if (this.cssFontInfo?.lineHeight) {
2820       this.lineHeight = this.cssFontInfo.metrics.lineHeight;
2821       this.lineGap = this.cssFontInfo.metrics.lineGap;
2822     } else {
2823       this.lineHeight = this.ascent - this.descent + this.lineGap;
2824     }
2825 
2826     // The 'post' table has glyphs names.
2827     if (tables.post) {
2828       readPostScriptTable(tables.post, properties, numGlyphs);
2829     }
2830 
2831     // The original 'post' table is not needed, replace it.
2832     tables.post = {
2833       tag: "post",
2834       data: createPostTable(properties),
2835     };
2836 
2837     const charCodeToGlyphId = [];
2838 
2839     // Helper function to try to skip mapping of empty glyphs.
2840     function hasGlyph(glyphId) {
2841       return !missingGlyphs[glyphId];
2842     }
2843 
2844     if (properties.composite) {
2845       const cidToGidMap = properties.cidToGidMap || [];
2846       const isCidToGidMapEmpty = cidToGidMap.length === 0;
2847 
2848       properties.cMap.forEach(function (charCode, cid) {
2849         if (typeof cid === "string") {
2850           cid = convertCidString(charCode, cid, /* shouldThrow = */ true);
2851         }
2852         if (cid > 0xffff) {
2853           throw new FormatError("Max size of CID is 65,535");
2854         }
2855         let glyphId = -1;
2856         if (isCidToGidMapEmpty) {
2857           glyphId = cid;
2858         } else if (cidToGidMap[cid] !== undefined) {
2859           glyphId = cidToGidMap[cid];
2860         }
2861 
2862         if (glyphId >= 0 && glyphId < numGlyphs && hasGlyph(glyphId)) {
2863           charCodeToGlyphId[charCode] = glyphId;
2864         }
2865       });
2866     } else {
2867       // Most of the following logic in this code branch is based on the
2868       // 9.6.6.4 of the PDF spec.
2869       const cmapTable = readCmapTable(
2870         tables.cmap,
2871         font,
2872         this.isSymbolicFont,
2873         properties.hasEncoding
2874       );
2875       const cmapPlatformId = cmapTable.platformId;
2876       const cmapEncodingId = cmapTable.encodingId;
2877       const cmapMappings = cmapTable.mappings;
2878       let baseEncoding = [],
2879         forcePostTable = false;
2880       if (
2881         properties.hasEncoding &&
2882         (properties.baseEncodingName === "MacRomanEncoding" ||
2883           properties.baseEncodingName === "WinAnsiEncoding")
2884       ) {
2885         baseEncoding = getEncoding(properties.baseEncodingName);
2886       }
2887 
2888       // If the font has an encoding and is not symbolic then follow the rules
2889       // in section 9.6.6.4 of the spec on how to map 3,1 and 1,0 cmaps.
2890       if (
2891         properties.hasEncoding &&
2892         !this.isSymbolicFont &&
2893         ((cmapPlatformId === 3 && cmapEncodingId === 1) ||
2894           (cmapPlatformId === 1 && cmapEncodingId === 0))
2895       ) {
2896         const glyphsUnicodeMap = getGlyphsUnicode();
2897         for (let charCode = 0; charCode < 256; charCode++) {
2898           let glyphName;
2899           if (this.differences[charCode] !== undefined) {
2900             glyphName = this.differences[charCode];
2901           } else if (baseEncoding.length && baseEncoding[charCode] !== "") {
2902             glyphName = baseEncoding[charCode];
2903           } else {
2904             glyphName = StandardEncoding[charCode];
2905           }
2906           if (!glyphName) {
2907             continue;
2908           }
2909           // Ensure that non-standard glyph names are resolved to valid ones.
2910           const standardGlyphName = recoverGlyphName(
2911             glyphName,
2912             glyphsUnicodeMap
2913           );
2914 
2915           let unicodeOrCharCode;
2916           if (cmapPlatformId === 3 && cmapEncodingId === 1) {
2917             unicodeOrCharCode = glyphsUnicodeMap[standardGlyphName];
2918           } else if (cmapPlatformId === 1 && cmapEncodingId === 0) {
2919             // TODO: the encoding needs to be updated with mac os table.
2920             unicodeOrCharCode = MacRomanEncoding.indexOf(standardGlyphName);
2921           }
2922 
2923           if (unicodeOrCharCode === undefined) {
2924             // Not a valid glyph name, fallback to using the /ToUnicode map
2925             // when no post-table exists (fixes issue13316_reduced.pdf).
2926             if (
2927               !properties.glyphNames &&
2928               properties.hasIncludedToUnicodeMap &&
2929               !(this.toUnicode instanceof IdentityToUnicodeMap)
2930             ) {
2931               const unicode = this.toUnicode.get(charCode);
2932               if (unicode) {
2933                 unicodeOrCharCode = unicode.codePointAt(0);
2934               }
2935             }
2936 
2937             if (unicodeOrCharCode === undefined) {
2938               continue; // No valid glyph mapping found.
2939             }
2940           }
2941 
2942           for (const mapping of cmapMappings) {
2943             if (mapping.charCode !== unicodeOrCharCode) {
2944               continue;
2945             }
2946             charCodeToGlyphId[charCode] = mapping.glyphId;
2947             break;
2948           }
2949         }
2950       } else if (cmapPlatformId === 0) {
2951         // Default Unicode semantics, use the charcodes as is.
2952         for (const mapping of cmapMappings) {
2953           charCodeToGlyphId[mapping.charCode] = mapping.glyphId;
2954         }
2955         // Always prefer the BaseEncoding/Differences arrays, when they exist
2956         // (fixes issue13433.pdf).
2957         forcePostTable = true;
2958       } else if (cmapPlatformId === 3 && cmapEncodingId === 0) {
2959         // When a (3, 0) cmap table is present, it is used instead but the
2960         // spec has special rules for char codes in the range of 0xF000 to
2961         // 0xF0FF and it says the (3, 0) table should map the values from
2962         // the (1, 0) table by prepending 0xF0 to the char codes. To reverse
2963         // this, the upper bits of the char code are cleared, but only for the
2964         // special range since some PDFs have char codes outside of this range
2965         // (e.g. 0x2013) which when masked would overwrite other values in the
2966         // cmap.
2967         for (const mapping of cmapMappings) {
2968           let charCode = mapping.charCode;
2969           if (charCode >= 0xf000 && charCode <= 0xf0ff) {
2970             charCode &= 0xff;
2971           }
2972           charCodeToGlyphId[charCode] = mapping.glyphId;
2973         }
2974       } else {
2975         // When there is only a (1, 0) cmap table, the char code is a single
2976         // byte and it is used directly as the char code.
2977         for (const mapping of cmapMappings) {
2978           charCodeToGlyphId[mapping.charCode] = mapping.glyphId;
2979         }
2980       }
2981 
2982       // Last, try to map any missing charcodes using the post table.
2983       if (
2984         properties.glyphNames &&
2985         (baseEncoding.length || this.differences.length)
2986       ) {
2987         for (let i = 0; i < 256; ++i) {
2988           if (!forcePostTable && charCodeToGlyphId[i] !== undefined) {
2989             continue;
2990           }
2991           const glyphName = this.differences[i] || baseEncoding[i];
2992           if (!glyphName) {
2993             continue;
2994           }
2995           const glyphId = properties.glyphNames.indexOf(glyphName);
2996           if (glyphId > 0 && hasGlyph(glyphId)) {
2997             charCodeToGlyphId[i] = glyphId;
2998           }
2999         }
3000       }
3001     }
3002 
3003     if (charCodeToGlyphId.length === 0) {
3004       // defines at least one glyph
3005       charCodeToGlyphId[0] = 0;
3006     }
3007 
3008     // Typically glyph 0 is duplicated and the mapping must be updated, but if
3009     // there isn't enough room to duplicate, the glyph id is left the same. In
3010     // this case, glyph 0 may not work correctly, but that is better than
3011     // having the whole font fail.
3012     let glyphZeroId = numGlyphsOut - 1;
3013     if (!dupFirstEntry) {
3014       glyphZeroId = 0;
3015     }
3016 
3017     // When `cssFontInfo` is set, the font is used to render text in the HTML
3018     // view (e.g. with Xfa) so nothing must be moved in the private use area.
3019     if (!properties.cssFontInfo) {
3020       // Converting glyphs and ids into font's cmap table
3021       const newMapping = adjustMapping(
3022         charCodeToGlyphId,
3023         hasGlyph,
3024         glyphZeroId,
3025         this.toUnicode
3026       );
3027       this.toFontChar = newMapping.toFontChar;
3028       tables.cmap = {
3029         tag: "cmap",
3030         data: createCmapTable(
3031           newMapping.charCodeToGlyphId,
3032           newMapping.toUnicodeExtraMap,
3033           numGlyphsOut
3034         ),
3035       };
3036 
3037       if (!tables["OS/2"] || !validateOS2Table(tables["OS/2"], font)) {
3038         tables["OS/2"] = {
3039           tag: "OS/2",
3040           data: createOS2Table(
3041             properties,
3042             newMapping.charCodeToGlyphId,
3043             metricsOverride
3044           ),
3045         };
3046       }
3047     }
3048 
3049     if (!isTrueType) {
3050       try {
3051         // Trying to repair CFF file
3052         cffFile = new Stream(tables["CFF "].data);
3053         const parser = new CFFParser(
3054           cffFile,
3055           properties,
3056           SEAC_ANALYSIS_ENABLED
3057         );
3058         cff = parser.parse();
3059         cff.duplicateFirstGlyph();
3060         const compiler = new CFFCompiler(cff);
3061         tables["CFF "].data = compiler.compile();
3062       } catch {
3063         warn("Failed to compile font " + properties.loadedName);
3064       }
3065     }
3066 
3067     // Re-creating 'name' table
3068     if (!tables.name) {
3069       tables.name = {
3070         tag: "name",
3071         data: createNameTable(this.name),
3072       };
3073     } else {
3074       // ... using existing 'name' table as prototype
3075       const [namePrototype, nameRecords] = readNameTable(tables.name);
3076 
3077       tables.name.data = createNameTable(name, namePrototype);
3078       this.psName = namePrototype[0][6] || null;
3079 
3080       if (!properties.composite) {
3081         // For TrueType fonts that do not include `ToUnicode` or `Encoding`
3082         // data, attempt to use the name-table to improve text selection.
3083         adjustTrueTypeToUnicode(properties, this.isSymbolicFont, nameRecords);
3084       }
3085     }
3086 
3087     const builder = new OpenTypeFileBuilder(header.version);
3088     for (const tableTag in tables) {
3089       builder.addTable(tableTag, tables[tableTag].data);
3090     }
3091     return builder.toArray();
3092   }
3093 
3506 }
3507 
3527 
</code>

Test file:
<test_file>
File:
test/unit/api_spec.js
/* Copyright 2017 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import {
  AnnotationEditorType,
  AnnotationMode,
  AnnotationType,
  ImageKind,
  InvalidPDFException,
  isNodeJS,
  MissingPDFException,
  objectSize,
  OPS,
  PasswordException,
  PasswordResponses,
  PermissionFlag,
  UnknownErrorException,
} from "../../src/shared/util.js";
import {
  buildGetDocumentParams,
  CMAP_URL,
  createTemporaryNodeServer,
  DefaultFileReaderFactory,
  TEST_PDFS_PATH,
} from "./test_utils.js";
import {
  DefaultCanvasFactory,
  getDocument,
  PDFDataRangeTransport,
  PDFDocumentLoadingTask,
  PDFDocumentProxy,
  PDFPageProxy,
  PDFWorker,
  PDFWorkerUtil,
  RenderTask,
} from "../../src/display/api.js";
import {
  PageViewport,
  RenderingCancelledException,
  StatTimer,
} from "../../src/display/display_utils.js";
import { AutoPrintRegExp } from "../../web/ui_utils.js";
import { GlobalImageCache } from "../../src/core/image_utils.js";
import { GlobalWorkerOptions } from "../../src/display/worker_options.js";
import { Metadata } from "../../src/display/metadata.js";
const WORKER_SRC = "../../build/generic/build/pdf.worker.mjs";
</test_file>

Your task:
You are a software tester at pdf.js.
1. Examine the existing test file. You may reuse any imports, helpers or setup blocks it already has.
2. Write exactly one javascript test `it("...", async () => {...})` block.
3. Your test must fail on the code before the patch, and pass after, hence the test will verify that the patch resolves the issue.
4. The test must be self-contained and to-the-point.
5. If you need something new use only the provided imports (respect the paths exactly how they are given) by importing dynamically for compatibility with Node.js — no new dependencies. 
6. Return only the javascript code for the new `it(...)` block (no comments or explanations).

Example structure:
it("should <describe behavior>", async () => {
  const { example } = await import("../../src/core/example.js");
  <initialize required variables>;
  <define expected variable>;
  <generate actual variables>;
  <compare expected with actual>;
});

