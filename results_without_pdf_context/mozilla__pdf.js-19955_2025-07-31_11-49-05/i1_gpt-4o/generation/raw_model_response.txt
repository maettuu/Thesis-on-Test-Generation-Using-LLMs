```javascript
it("should correctly handle missing text in PDF with broken font", async () => {
  const { PartialEvaluator } = await import("../../src/core/evaluator.js");
  const { Dict, Name } = await import("../../src/core/primitives.js");
  const { FormatError } = await import("../../src/shared/util.js");

  const evaluator = new PartialEvaluator({
    xref: new XRefMock(),
    handler: null,
    pageIndex: 0,
    idFactory: createIdFactory(0),
    fontCache: new Map(),
    builtInCMapCache: new Map(),
    standardFontDataCache: new Map(),
    globalColorSpaceCache: new Map(),
    globalImageCache: new Map(),
    systemFontCache: new Map(),
  });

  const dict = new Dict();
  dict.set("BaseFont", Name.get("InvalidFontName"));
  dict.set("FontBBox", [0, 0, 0, 0]);

  const baseDict = new Dict();
  baseDict.set("loadedName", "testFont");

  const descriptor = new Dict();
  descriptor.set("FontName", Name.get("InvalidFontName"));

  let error = null;
  try {
    await evaluator.translateFont({
      descriptor,
      dict,
      baseDict,
      composite: false,
      type: "Type3",
      firstChar: 0,
      lastChar: 255,
      toUnicode: null,
      cssFontInfo: null,
    });
  } catch (e) {
    error = e;
  }

  expect(error).toBeInstanceOf(FormatError);
  expect(error.message).toBe("invalid font name");
});
```