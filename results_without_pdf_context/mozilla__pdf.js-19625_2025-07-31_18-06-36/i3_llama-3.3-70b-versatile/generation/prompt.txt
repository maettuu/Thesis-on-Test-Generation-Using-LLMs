Before you begin:
- Keep going until the job is completely solved — don’t stop halfway.
- If you’re unsure about the behavior, reread the provided patch carefully; do not hallucinate.
- Plan your approach before writing code by reflecting on whether the test truly fails before and passes after.

Issue:
<issue>
[Bug]: Some pdf texts are not shown and can not be selected when is shown by pdf.js
### Attach (recommended) or Link to PDF file

When PDF.js renders the attached PDF, the text 'D-FLT-020153-2060' cannot be selected with the cursor, while other text can be selected without issue.

[okm2500682934750615600.pdf](https://github.com/user-attachments/files/19126771/okm2500682934750615600.pdf)

### Web browser and its version

Firefox, Chrome

### Operating system and its version

Windows 10

### PDF.js version

pdfjsVersion = "4.5.136";pdfjsBuild = "3a21f03b0";

### Is the bug present in the latest PDF.js version?

Yes

### Is a browser extension

No

### Steps to reproduce the problem

1- Preview attached pdf with pdf.js
2- Try to select 'D-FLT-020153-2060' text with cursor which is positioned at the end of pdf

### What is the expected behavior?

Text be selected and can be copied to clipboard

### What went wrong?

Text can not be selected

### Link to a viewer

_No response_

### Additional context

_No response_
</issue>

Patch:
<patch>
diff --git a/src/core/evaluator.js b/src/core/evaluator.js
--- a/src/core/evaluator.js
+++ b/src/core/evaluator.js
@@ -4679,8 +4679,15 @@ class TranslatedFont {
             //   not execute any operators that set the colour (or other
             //   colour-related parameters) in the graphics state;
             //   any use of such operators shall be ignored."
-            if (operatorList.fnArray[0] === OPS.setCharWidthAndBounds) {
-              this.#removeType3ColorOperators(operatorList, fontBBoxSize);
+            switch (operatorList.fnArray[0]) {
+              case OPS.setCharWidthAndBounds:
+                this.#removeType3ColorOperators(operatorList, fontBBoxSize);
+                break;
+              case OPS.setCharWidth:
+                if (!fontBBoxSize) {
+                  this.#guessType3FontBBox(operatorList);
+                }
+                break;
             }
             charProcOperatorList[key] = operatorList.getIR();
 
@@ -4728,13 +4735,7 @@ class TranslatedFont {
       // Override the fontBBox when it's undefined/empty, or when it's at least
       // (approximately) one order of magnitude smaller than the charBBox
       // (fixes issue14999_reduced.pdf).
-      if (!this._bbox) {
-        this._bbox = [Infinity, Infinity, -Infinity, -Infinity];
-      }
-      this._bbox[0] = Math.min(this._bbox[0], charBBox[0]);
-      this._bbox[1] = Math.min(this._bbox[1], charBBox[1]);
-      this._bbox[2] = Math.max(this._bbox[2], charBBox[2]);
-      this._bbox[3] = Math.max(this._bbox[3], charBBox[3]);
+      this.#computeCharBBox(charBBox);
     }
 
     let i = 0,
@@ -4787,6 +4788,37 @@ class TranslatedFont {
       i++;
     }
   }
+
+  #guessType3FontBBox(operatorList) {
+    if (typeof PDFJSDev === "undefined" || PDFJSDev.test("TESTING")) {
+      assert(
+        operatorList.fnArray[0] === OPS.setCharWidth,
+        "Type3 glyph shall start with the d0 operator."
+      );
+    }
+
+    let i = 1;
+    const ii = operatorList.length;
+    while (i < ii) {
+      switch (operatorList.fnArray[i]) {
+        case OPS.constructPath:
+          const minMax = operatorList.argsArray[i][2];
+          // Override the fontBBox when it's undefined/empty (fixes 19624.pdf).
+          this.#computeCharBBox(minMax);
+          break;
+      }
+      i++;
+    }
+  }
+
+  #computeCharBBox(bbox) {
+    this._bbox ||= [Infinity, Infinity, -Infinity, -Infinity];
+
+    this._bbox[0] = Math.min(this._bbox[0], bbox[0]);
+    this._bbox[1] = Math.min(this._bbox[1], bbox[1]);
+    this._bbox[2] = Math.max(this._bbox[2], bbox[2]);
+    this._bbox[3] = Math.max(this._bbox[3], bbox[3]);
+  }
 }
 
 class StateManager {


</patch>

Imports:
<imports>
Available Packages
Dev Dependencies:
- @babel/core: ^7.26.9
- @babel/preset-env: ^7.26.9
- @babel/runtime: ^7.26.9
- @fluent/bundle: ^0.18.0
- @fluent/dom: ^0.10.0
- @metalsmith/layouts: ^2.7.0
- @metalsmith/markdown: ^1.10.0
- @napi-rs/canvas: ^0.1.67
- @types/node: ^22.13.5
- autoprefixer: ^10.4.20
- babel-loader: ^9.2.1
- caniuse-lite: ^1.0.30001700
- core-js: ^3.40.0
- eslint: ^9.21.0
- eslint-plugin-import: ^2.31.0
- eslint-plugin-jasmine: ^4.2.2
- eslint-plugin-json: ^4.0.1
- eslint-plugin-no-unsanitized: ^4.1.2
- eslint-plugin-perfectionist: ^4.9.0
- eslint-plugin-prettier: ^5.2.3
- eslint-plugin-unicorn: ^57.0.0
- globals: ^16.0.0
- gulp: ^5.0.0
- gulp-cli: ^3.0.0
- gulp-postcss: ^10.0.0
- gulp-rename: ^2.0.0
- gulp-replace: ^1.1.4
- gulp-zip: ^6.1.0
- highlight.js: ^11.11.1
- jasmine: ^5.6.0
- jsdoc: ^4.0.4
- jstransformer-nunjucks: ^1.2.0
- metalsmith: ^2.6.3
- metalsmith-html-relative: ^2.0.6
- ordered-read-streams: ^2.0.0
- pngjs: ^7.0.0
- postcss: ^8.5.3
- postcss-dark-theme-class: ^1.3.0
- postcss-dir-pseudo-class: ^9.0.1
- postcss-discard-comments: ^7.0.3
- postcss-nesting: ^13.0.1
- prettier: ^3.5.2
- puppeteer: ^24.2.1
- stylelint: ^16.14.1
- stylelint-prettier: ^5.0.3
- svglint: ^3.1.0
- terser-webpack-plugin: ^5.3.11
- tsc-alias: ^1.8.10
- ttest: ^4.0.0
- typescript: ^5.7.3
- vinyl: ^3.0.0
- webpack: ^5.98.0
- webpack-stream: ^7.0.0
- yargs: ^17.7.2

Engines:
- node: >=20

Available Relative Imports:
- `../../src/core/annotation.js`: Annotation, AnnotationBorderStyle, AnnotationFactory, MarkupAnnotation, getQuadPoints
- `../../src/core/bidi.js`: bidi
- `../../src/core/calculate_md5.js`: calculateMD5
- `../../src/core/calculate_sha256.js`: calculateSHA256
- `../../src/core/calculate_sha_other.js`: calculateSHA384, calculateSHA512
- `../../src/core/cff_parser.js`: CFFCharset, CFFCompiler, CFFFDSelect, CFFParser, CFFStrings
- `../../src/core/cmap.js`: CMap, CMapFactory, IdentityCMap
- `../../src/core/colorspace.js`: ColorSpace
- `../../src/core/colorspace_utils.js`: ColorSpaceUtils
- `../../src/core/core_utils.js`: arrayBuffersToBytes, encodeToXmlString, escapePDFName, escapeString, getInheritableProperty, getSizeInBytes, isAscii, isWhiteSpace, log2, numberToString, parseXFAPath, recoverJsURL, stringToUTF16HexString, stringToUTF16String, toRomanNumerals, validateCSSFont
- `../../src/core/crypto.js`: AES128Cipher, AES256Cipher, ARCFourCipher, CipherTransformFactory, PDF17, PDF20
- `../../src/core/default_appearance.js`: createDefaultAppearance, parseAppearanceStream, parseDefaultAppearance
- `../../src/core/document.js`: PDFDocument, Page
- `../../src/core/encodings.js`: getEncoding
- `../../src/core/evaluator.js`: PartialEvaluator
- `../../src/core/flate_stream.js`: FlateStream
- `../../src/core/font_substitutions.js`: getFontSubstitution
- `../../src/core/fonts_utils.js`: SEAC_ANALYSIS_ENABLED
- `../../src/core/function.js`: PDFFunctionFactory, PostScriptCompiler, PostScriptEvaluator
- `../../src/core/glyphlist.js`: getDingbatsGlyphsUnicode, getGlyphsUnicode
- `../../src/core/image_utils.js`: GlobalColorSpaceCache, GlobalImageCache, LocalColorSpaceCache
- `../../src/core/jbig2.js`: Jbig2Error, Jbig2Image
- `../../src/core/jpg.js`: JpegError, JpegImage
- `../../src/core/jpx.js`: JpxError, JpxImage
- `../../src/core/metadata_parser.js`: MetadataParser
- `../../src/core/operator_list.js`: OperatorList
- `../../src/core/parser.js`: Lexer, Linearization, Parser
- `../../src/core/predictor_stream.js`: PredictorStream
- `../../src/core/primitives.js`: Cmd, Dict, EOF, Name, Ref, RefSet, RefSetCache, isCmd, isDict, isName, isRefsEqual
- `../../src/core/ps_parser.js`: PostScriptLexer, PostScriptParser
- `../../src/core/stream.js`: NullStream, Stream, StringStream
- `../../src/core/type1_parser.js`: Type1Parser
- `../../src/core/unicode.js`: getCharUnicodeCategory, getUnicodeForGlyph, getUnicodeRangeFor, mapSpecialUnicodeValues
- `../../src/core/worker.js`: WorkerMessageHandler, WorkerTask
- `../../src/core/writer.js`: incrementalUpdate, writeChanges, writeDict
- `../../src/core/xfa/bind.js`: Binder
- `../../src/core/xfa/data.js`: DataHandler
- `../../src/core/xfa/factory.js`: XFAFactory
- `../../src/core/xfa/formcalc_lexer.js`: Lexer, TOKEN, Token
- `../../src/core/xfa/formcalc_parser.js`: Errors, Parser
- `../../src/core/xfa/parser.js`: XFAParser
- `../../src/core/xfa/som.js`: searchNode
- `../../src/core/xfa/symbol_utils.js`: $dump, $getChildren, $getChildrenByClass, $getChildrenByName, $text, $uid
- `../../src/core/xml_parser.js`: SimpleXMLParser, XMLParserBase
- `../../src/display/annotation_layer.js`: AnnotationLayer
- `../../src/display/annotation_storage.js`: AnnotationStorage
- `../../src/display/api.js`: LoopbackPort, PDFDataRangeTransport, PDFDocumentLoadingTask, PDFDocumentProxy, PDFPageProxy, PDFWorker, RenderTask, build, getDocument, isValidExplicitDest, version
- `../../src/display/canvas_factory.js`: DOMCanvasFactory
- `../../src/display/cmap_reader_factory.js`: DOMCMapReaderFactory
- `../../src/display/display_utils.js`: OutputScale, PDFDateString, PageViewport, PixelsPerInch, RenderingCancelledException, StatTimer, SupportedImageMimeTypes, fetchData, getFilenameFromUrl, getPdfFilenameFromUrl, getXfaPageViewport, isDataScheme, isPdfFile, isValidFetchUrl, noContextMenu, setLayerDimensions, stopEvent
- `../../src/display/draw_layer.js`: DrawLayer
- `../../src/display/editor/annotation_editor_layer.js`: AnnotationEditorLayer
- `../../src/display/editor/color_picker.js`: ColorPicker
- `../../src/display/editor/drawers/signaturedraw.js`: SignatureExtractor
- `../../src/display/editor/tools.js`: AnnotationEditorUIManager, CommandManager
- `../../src/display/fetch_stream.js`: PDFFetchStream
- `../../src/display/metadata.js`: Metadata
- `../../src/display/network.js`: PDFNetworkStream
- `../../src/display/network_utils.js`: createHeaders, createResponseError, extractFilenameFromHeader, validateRangeRequestCapabilities, validateResponseStatus
- `../../src/display/node_stream.js`: PDFNodeStream
- `../../src/display/node_utils.js`: NodeCMapReaderFactory, NodeStandardFontDataFactory, fetchData
- `../../src/display/standard_fontdata_factory.js`: DOMStandardFontDataFactory
- `../../src/display/svg_factory.js`: DOMSVGFactory
- `../../src/display/text_layer.js`: TextLayer
- `../../src/display/touch_manager.js`: TouchManager
- `../../src/display/worker_options.js`: GlobalWorkerOptions
- `../../src/display/xfa_layer.js`: XfaLayer
- `../../src/shared/message_handler.js`: MessageHandler
- `../../src/shared/murmurhash3.js`: MurmurHash3_64
- `../../src/shared/util.js`: AbortException, AnnotationBorderStyleType, AnnotationEditorParamsType, AnnotationEditorType, AnnotationFieldFlag, AnnotationFlag, AnnotationMode, AnnotationType, BaseException, FeatureTest, FormatError, ImageKind, InvalidPDFException, MathClamp, OPS, PasswordException, PasswordResponses, PermissionFlag, RenderingIntentFlag, ResponseException, UnknownErrorException, Util, VerbosityLevel, assert, bytesToString, createValidAbsoluteUrl, getModificationDate, getUuid, getVerbosityLevel, isNodeJS, normalizeUnicode, objectSize, setVerbosityLevel, shadow, string32, stringToBytes, stringToPDFString, stringToUTF8String, toBase64Util
- `../../web/annotation_layer_builder.js`: AnnotationLayerBuilder
- `../../web/app_options.js`: AppOptions, OptionKind
- `../../web/autolinker.js`: Autolinker
- `../../web/download_manager.js`: DownloadManager
- `../../web/event_utils.js`: EventBus, WaitOnType, waitOnEventOrTimeout
- `../../web/genericl10n.js`: GenericL10n
- `../../web/pdf_find_controller.js`: FindState, PDFFindController
- `../../web/pdf_find_utils.js`: CharacterType, getCharacterType
- `../../web/pdf_history.js`: PDFHistory, isDestArraysEqual, isDestHashesEqual
- `../../web/pdf_link_service.js`: LinkTarget, PDFLinkService, SimpleLinkService
- `../../web/pdf_page_view.js`: PDFPageView
- `../../web/pdf_scripting_manager.component.js`: PDFScriptingManager
- `../../web/pdf_single_page_viewer.js`: PDFSinglePageViewer
- `../../web/pdf_viewer.js`: PDFPageViewBuffer, PDFViewer
- `../../web/struct_tree_layer_builder.js`: StructTreeLayerBuilder
- `../../web/text_layer_builder.js`: TextLayerBuilder
- `../../web/ui_utils.js`: AutoPrintRegExp, ProgressBar, RenderingStates, ScrollMode, SpreadMode, backtrackBeforeAllVisibleElements, binarySearchFirstItem, calcRound, getPageSizeInches, getVisibleElements, isPortraitOrientation, isValidRotation, parseQueryString, removeNullCharacters
- `../../web/xfa_layer_builder.js`: XfaLayerBuilder
- `../reporter.js`: TestReporter
- `./common_pdfstream_tests.js`: testCrossOriginRedirects
- `./test_utils.js`: CMAP_URL, DefaultCMapReaderFactory, DefaultFileReaderFactory, DefaultStandardFontDataFactory, STANDARD_FONT_DATA_URL, TEST_PDFS_PATH, TestPdfsServer, XRefMock, buildGetDocumentParams, createIdFactory, getCrossOriginHostname
</imports>

Code:
<code>
File:
src/core/evaluator.js
1 /* Copyright 2012 Mozilla Foundation
2  *
3  * Licensed under the Apache License, Version 2.0 (the "License");
4  * you may not use this file except in compliance with the License.
5  * You may obtain a copy of the License at
6  *
7  *     http://www.apache.org/licenses/LICENSE-2.0
8  *
9  * Unless required by applicable law or agreed to in writing, software
10  * distributed under the License is distributed on an "AS IS" BASIS,
11  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
12  * See the License for the specific language governing permissions and
13  * limitations under the License.
14  */
15 
16 import {
17   AbortException,
18   assert,
19   FONT_IDENTITY_MATRIX,
20   FormatError,
21   IDENTITY_MATRIX,
22   info,
23   isArrayEqual,
24   normalizeUnicode,
25   OPS,
26   shadow,
27   stringToPDFString,
28   TextRenderingMode,
29   Util,
30   warn,
31 } from "../shared/util.js";
32 import { CMapFactory, IdentityCMap } from "./cmap.js";
33 import { Cmd, Dict, EOF, isName, Name, Ref, RefSet } from "./primitives.js";
34 import { ErrorFont, Font } from "./fonts.js";
35 import {
36   fetchBinaryData,
37   isNumberArray,
38   lookupMatrix,
39   lookupNormalRect,
40 } from "./core_utils.js";
41 import {
42   getEncoding,
43   MacRomanEncoding,
44   StandardEncoding,
45   SymbolSetEncoding,
46   WinAnsiEncoding,
47   ZapfDingbatsEncoding,
48 } from "./encodings.js";
49 import {
50   getFontNameToFileMap,
51   getSerifFonts,
52   getStandardFontName,
53   getStdFontMap,
54   getSymbolsFonts,
55   isKnownFontName,
56 } from "./standard_fonts.js";
57 import { getTilingPatternIR, Pattern } from "./pattern.js";
58 import { getXfaFontDict, getXfaFontName } from "./xfa_fonts.js";
59 import { IdentityToUnicodeMap, ToUnicodeMap } from "./to_unicode_map.js";
60 import { isPDFFunction, PDFFunctionFactory } from "./function.js";
61 import { Lexer, Parser } from "./parser.js";
62 import {
63   LocalColorSpaceCache,
64   LocalGStateCache,
65   LocalImageCache,
66   LocalTilingPatternCache,
67   RegionalImageCache,
68 } from "./image_utils.js";
69 import { BaseStream } from "./base_stream.js";
70 import { bidi } from "./bidi.js";
71 import { ColorSpace } from "./colorspace.js";
72 import { ColorSpaceUtils } from "./colorspace_utils.js";
73 import { DecodeStream } from "./decode_stream.js";
74 import { FontFlags } from "./fonts_utils.js";
75 import { getFontSubstitution } from "./font_substitutions.js";
76 import { getGlyphsUnicode } from "./glyphlist.js";
77 import { getMetrics } from "./metrics.js";
78 import { getUnicodeForGlyph } from "./unicode.js";
79 import { MurmurHash3_64 } from "../shared/murmurhash3.js";
80 import { OperatorList } from "./operator_list.js";
81 import { PDFImage } from "./image.js";
82 import { Stream } from "./stream.js";
83 
84 const DefaultPartialEvaluatorOptions = Object.freeze({
85   maxImageSize: -1,
86   disableFontFace: false,
87   ignoreErrors: false,
88   isEvalSupported: true,
89   isOffscreenCanvasSupported: false,
90   isImageDecoderSupported: false,
91   canvasMaxAreaInBytes: -1,
92   fontExtraProperties: false,
93   useSystemFonts: true,
94   useWasm: true,
95   useWorkerFetch: true,
96   cMapUrl: null,
97   standardFontDataUrl: null,
98   wasmUrl: null,
99 });
100 
101 const PatternType = {
102   TILING: 1,
103   SHADING: 2,
104 };
105 
106 // Optionally avoid sending individual, or very few, text chunks to reduce
107 // `postMessage` overhead with ReadableStream (see issue 13962).
108 //
109 // PLEASE NOTE: This value should *not* be too large (it's used as a lower limit
110 // in `enqueueChunk`), since that would cause streaming of textContent to become
111 // essentially useless in practice by sending all (or most) chunks at once.
112 // Also, a too large value would (indirectly) affect the main-thread `textLayer`
113 // building negatively by forcing all textContent to be handled at once, which
114 // could easily end up hurting *overall* performance (e.g. rendering as well).
115 const TEXT_CHUNK_BATCH_SIZE = 10;
116 
117 const deferred = Promise.resolve();
118 
119 // Convert PDF blend mode names to HTML5 blend mode names.
120 function normalizeBlendMode(value, parsingArray = false) {
121   if (Array.isArray(value)) {
122     // Use the first *supported* BM value in the Array (fixes issue11279.pdf).
123     for (const val of value) {
124       const maybeBM = normalizeBlendMode(val, /* parsingArray = */ true);
125       if (maybeBM) {
126         return maybeBM;
127       }
128     }
129     warn(`Unsupported blend mode Array: ${value}`);
130     return "source-over";
131   }
132 
133   if (!(value instanceof Name)) {
134     if (parsingArray) {
135       return null;
136     }
137     return "source-over";
138   }
139   switch (value.name) {
140     case "Normal":
141     case "Compatible":
142       return "source-over";
143     case "Multiply":
144       return "multiply";
145     case "Screen":
146       return "screen";
147     case "Overlay":
148       return "overlay";
149     case "Darken":
150       return "darken";
151     case "Lighten":
152       return "lighten";
153     case "ColorDodge":
154       return "color-dodge";
155     case "ColorBurn":
156       return "color-burn";
157     case "HardLight":
158       return "hard-light";
159     case "SoftLight":
160       return "soft-light";
161     case "Difference":
162       return "difference";
163     case "Exclusion":
164       return "exclusion";
165     case "Hue":
166       return "hue";
167     case "Saturation":
168       return "saturation";
169     case "Color":
170       return "color";
171     case "Luminosity":
172       return "luminosity";
173   }
174   if (parsingArray) {
175     return null;
176   }
177   warn(`Unsupported blend mode: ${value.name}`);
178   return "source-over";
179 }
180 
181 function addLocallyCachedImageOps(opList, data) {
182   if (data.objId) {
183     opList.addDependency(data.objId);
184   }
185   opList.addImageOps(data.fn, data.args, data.optionalContent, data.hasMask);
186 
187   if (data.fn === OPS.paintImageMaskXObject && data.args[0]?.count > 0) {
188     data.args[0].count++;
189   }
190 }
191 
192 // Trying to minimize Date.now() usage and check every 100 time.
193 class TimeSlotManager {
194   static TIME_SLOT_DURATION_MS = 20;
195 
196   static CHECK_TIME_EVERY = 100;
197 
198   constructor() {
199     this.reset();
200   }
201 
202   check() {
203     if (++this.checked < TimeSlotManager.CHECK_TIME_EVERY) {
204       return false;
205     }
206     this.checked = 0;
207     return this.endTime <= Date.now();
208   }
209 
210   reset() {
211     this.endTime = Date.now() + TimeSlotManager.TIME_SLOT_DURATION_MS;
212     this.checked = 0;
213   }
214 }
215 
216 class PartialEvaluator {
217   constructor({
218     xref,
219     handler,
220     pageIndex,
221     idFactory,
222     fontCache,
223     builtInCMapCache,
224     standardFontDataCache,
225     globalColorSpaceCache,
226     globalImageCache,
227     systemFontCache,
228     options = null,
229   }) {
230     this.xref = xref;
231     this.handler = handler;
232     this.pageIndex = pageIndex;
233     this.idFactory = idFactory;
234     this.fontCache = fontCache;
235     this.builtInCMapCache = builtInCMapCache;
236     this.standardFontDataCache = standardFontDataCache;
237     this.globalColorSpaceCache = globalColorSpaceCache;
238     this.globalImageCache = globalImageCache;
239     this.systemFontCache = systemFontCache;
240     this.options = options || DefaultPartialEvaluatorOptions;
241     this.type3FontRefs = null;
242 
243     this._regionalImageCache = new RegionalImageCache();
244     this._fetchBuiltInCMapBound = this.fetchBuiltInCMap.bind(this);
245   }
246 
247   /**
248    * Since Functions are only cached (locally) by reference, we can share one
249    * `PDFFunctionFactory` instance within this `PartialEvaluator` instance.
250    */
251   get _pdfFunctionFactory() {
252     const pdfFunctionFactory = new PDFFunctionFactory({
253       xref: this.xref,
254       isEvalSupported: this.options.isEvalSupported,
255     });
256     return shadow(this, "_pdfFunctionFactory", pdfFunctionFactory);
257   }
258 
259   get parsingType3Font() {
260     return !!this.type3FontRefs;
261   }
262 
263   clone(newOptions = null) {
264     const newEvaluator = Object.create(this);
265     newEvaluator.options = Object.assign(
266       Object.create(null),
267       this.options,
268       newOptions
269     );
270     return newEvaluator;
271   }
272 
273   hasBlendModes(resources, nonBlendModesSet) {
274     if (!(resources instanceof Dict)) {
275       return false;
276     }
277     if (resources.objId && nonBlendModesSet.has(resources.objId)) {
278       return false;
279     }
280 
281     const processed = new RefSet(nonBlendModesSet);
282     if (resources.objId) {
283       processed.put(resources.objId);
284     }
285 
286     const nodes = [resources],
287       xref = this.xref;
288     while (nodes.length) {
289       const node = nodes.shift();
290       // First check the current resources for blend modes.
291       const graphicStates = node.get("ExtGState");
292       if (graphicStates instanceof Dict) {
293         for (let graphicState of graphicStates.getRawValues()) {
294           if (graphicState instanceof Ref) {
295             if (processed.has(graphicState)) {
296               continue; // The ExtGState has already been processed.
297             }
298             try {
299               graphicState = xref.fetch(graphicState);
300             } catch (ex) {
301               // Avoid parsing a corrupt ExtGState more than once.
302               processed.put(graphicState);
303 
304               info(`hasBlendModes - ignoring ExtGState: "${ex}".`);
305               continue;
306             }
307           }
308           if (!(graphicState instanceof Dict)) {
309             continue;
310           }
311           if (graphicState.objId) {
312             processed.put(graphicState.objId);
313           }
314 
315           const bm = graphicState.get("BM");
316           if (bm instanceof Name) {
317             if (bm.name !== "Normal") {
318               return true;
319             }
320             continue;
321           }
322           if (bm !== undefined && Array.isArray(bm)) {
323             for (const element of bm) {
324               if (element instanceof Name && element.name !== "Normal") {
325                 return true;
326               }
327             }
328           }
329         }
330       }
331       // Descend into the XObjects to look for more resources and blend modes.
332       const xObjects = node.get("XObject");
333       if (!(xObjects instanceof Dict)) {
334         continue;
335       }
336       for (let xObject of xObjects.getRawValues()) {
337         if (xObject instanceof Ref) {
338           if (processed.has(xObject)) {
339             // The XObject has already been processed, and by avoiding a
340             // redundant `xref.fetch` we can *significantly* reduce the load
341             // time for badly generated PDF files (fixes issue6961.pdf).
342             continue;
343           }
344           try {
345             xObject = xref.fetch(xObject);
346           } catch (ex) {
347             // Avoid parsing a corrupt XObject more than once.
348             processed.put(xObject);
349 
350             info(`hasBlendModes - ignoring XObject: "${ex}".`);
351             continue;
352           }
353         }
354         if (!(xObject instanceof BaseStream)) {
355           continue;
356         }
357         if (xObject.dict.objId) {
358           processed.put(xObject.dict.objId);
359         }
360         const xResources = xObject.dict.get("Resources");
361         if (!(xResources instanceof Dict)) {
362           continue;
363         }
364         // Checking objId to detect an infinite loop.
365         if (xResources.objId && processed.has(xResources.objId)) {
366           continue;
367         }
368 
369         nodes.push(xResources);
370         if (xResources.objId) {
371           processed.put(xResources.objId);
372         }
373       }
374     }
375 
376     // When no blend modes exist, there's no need re-fetch/re-parse any of the
377     // processed `Ref`s again for subsequent pages. This helps reduce redundant
378     // `XRef.fetch` calls for some documents (e.g. issue6961.pdf).
379     for (const ref of processed) {
380       nonBlendModesSet.put(ref);
381     }
382     return false;
383   }
384 
385   async fetchBuiltInCMap(name) {
386     const cachedData = this.builtInCMapCache.get(name);
387     if (cachedData) {
388       return cachedData;
389     }
390     let data;
391 
392     if (this.options.useWorkerFetch) {
393       // Only compressed CMaps are (currently) supported here.
394       data = {
395         cMapData: await fetchBinaryData(`${this.options.cMapUrl}${name}.bcmap`),
396         isCompressed: true,
397       };
398     } else {
399       // Get the data on the main-thread instead.
400       data = await this.handler.sendWithPromise("FetchBinaryData", {
401         type: "cMapReaderFactory",
402         name,
403       });
404     }
405     // Cache the CMap data, to avoid fetching it repeatedly.
406     this.builtInCMapCache.set(name, data);
407 
408     return data;
409   }
410 
411   async fetchStandardFontData(name) {
412     const cachedData = this.standardFontDataCache.get(name);
413     if (cachedData) {
414       return new Stream(cachedData);
415     }
416 
417     // The symbol fonts are not consistent across platforms, always load the
418     // standard font data for them.
419     if (
420       this.options.useSystemFonts &&
421       name !== "Symbol" &&
422       name !== "ZapfDingbats"
423     ) {
424       return null;
425     }
426 
427     const standardFontNameToFileName = getFontNameToFileMap(),
428       filename = standardFontNameToFileName[name];
429     let data;
430 
431     try {
432       if (this.options.useWorkerFetch) {
433         data = await fetchBinaryData(
434           `${this.options.standardFontDataUrl}${filename}`
435         );
436       } else {
437         // Get the data on the main-thread instead.
438         data = await this.handler.sendWithPromise("FetchBinaryData", {
439           type: "standardFontDataFactory",
440           filename,
441         });
442       }
443     } catch (ex) {
444       warn(ex);
445       return null;
446     }
447     // Cache the "raw" standard font data, to avoid fetching it repeatedly
448     // (see e.g. issue 11399).
449     this.standardFontDataCache.set(name, data);
450 
451     return new Stream(data);
452   }
453 
454   async buildFormXObject(
455     resources,
456     xobj,
457     smask,
458     operatorList,
459     task,
460     initialState,
461     localColorSpaceCache
462   ) {
463     const dict = xobj.dict;
464     const matrix = lookupMatrix(dict.getArray("Matrix"), null);
465     const bbox = lookupNormalRect(dict.getArray("BBox"), null);
466 
467     let optionalContent, groupOptions;
468     if (dict.has("OC")) {
469       optionalContent = await this.parseMarkedContentProps(
470         dict.get("OC"),
471         resources
472       );
473     }
474     if (optionalContent !== undefined) {
475       operatorList.addOp(OPS.beginMarkedContentProps, ["OC", optionalContent]);
476     }
477     const group = dict.get("Group");
478     if (group) {
479       groupOptions = {
480         matrix,
481         bbox,
482         smask,
483         isolated: false,
484         knockout: false,
485       };
486 
487       const groupSubtype = group.get("S");
488       let colorSpace = null;
489       if (isName(groupSubtype, "Transparency")) {
490         groupOptions.isolated = group.get("I") || false;
491         groupOptions.knockout = group.get("K") || false;
492         if (group.has("CS")) {
493           const cs = this._getColorSpace(
494             group.getRaw("CS"),
495             resources,
496             localColorSpaceCache
497           );
498           colorSpace =
499             cs instanceof ColorSpace ? cs : await this._handleColorSpace(cs);
500         }
501       }
502 
503       if (smask?.backdrop) {
504         colorSpace ||= ColorSpaceUtils.rgb;
505         smask.backdrop = colorSpace.getRgb(smask.backdrop, 0);
506       }
507 
508       operatorList.addOp(OPS.beginGroup, [groupOptions]);
509     }
510 
511     // If it's a group, a new canvas will be created that is the size of the
512     // bounding box and translated to the correct position so we don't need to
513     // apply the bounding box to it.
514     const args = group ? [matrix, null] : [matrix, bbox];
515     operatorList.addOp(OPS.paintFormXObjectBegin, args);
516 
517     await this.getOperatorList({
518       stream: xobj,
519       task,
520       resources: dict.get("Resources") || resources,
521       operatorList,
522       initialState,
523     });
524     operatorList.addOp(OPS.paintFormXObjectEnd, []);
525 
526     if (group) {
527       operatorList.addOp(OPS.endGroup, [groupOptions]);
528     }
529 
530     if (optionalContent !== undefined) {
531       operatorList.addOp(OPS.endMarkedContent, []);
532     }
533   }
534 
535   _sendImgData(objId, imgData, cacheGlobally = false) {
536     if (
537       (typeof PDFJSDev === "undefined" || PDFJSDev.test("TESTING")) &&
538       imgData
539     ) {
540       assert(Number.isInteger(imgData.dataLen), "Expected dataLen to be set.");
541     }
542     const transfers = imgData ? [imgData.bitmap || imgData.data.buffer] : null;
543 
544     if (this.parsingType3Font || cacheGlobally) {
545       return this.handler.send(
546         "commonobj",
547         [objId, "Image", imgData],
548         transfers
549       );
550     }
551     return this.handler.send(
552       "obj",
553       [objId, this.pageIndex, "Image", imgData],
554       transfers
555     );
556   }
557 
558   async buildPaintImageXObject({
559     resources,
560     image,
561     isInline = false,
562     operatorList,
563     cacheKey,
564     localImageCache,
565     localColorSpaceCache,
566   }) {
567     const dict = image.dict;
568     const imageRef = dict.objId;
569     const w = dict.get("W", "Width");
570     const h = dict.get("H", "Height");
571 
572     if (!(w && typeof w === "number") || !(h && typeof h === "number")) {
573       warn("Image dimensions are missing, or not numbers.");
574       return;
575     }
576     const maxImageSize = this.options.maxImageSize;
577     if (maxImageSize !== -1 && w * h > maxImageSize) {
578       const msg = "Image exceeded maximum allowed size and was removed.";
579 
580       if (this.options.ignoreErrors) {
581         warn(msg);
582         return;
583       }
584       throw new Error(msg);
585     }
586 
587     let optionalContent;
588     if (dict.has("OC")) {
589       optionalContent = await this.parseMarkedContentProps(
590         dict.get("OC"),
591         resources
592       );
593     }
594 
595     const imageMask = dict.get("IM", "ImageMask") || false;
596     let imgData, args;
597     if (imageMask) {
598       // This depends on a tmpCanvas being filled with the
599       // current fillStyle, such that processing the pixel
600       // data can't be done here. Instead of creating a
601       // complete PDFImage, only read the information needed
602       // for later.
603       const interpolate = dict.get("I", "Interpolate");
604       const bitStrideLength = (w + 7) >> 3;
605       const imgArray = image.getBytes(bitStrideLength * h);
606       const decode = dict.getArray("D", "Decode");
607 
608       if (this.parsingType3Font) {
609         imgData = PDFImage.createRawMask({
610           imgArray,
611           width: w,
612           height: h,
613           imageIsFromDecodeStream: image instanceof DecodeStream,
614           inverseDecode: decode?.[0] > 0,
615           interpolate,
616         });
617 
618         imgData.cached = !!cacheKey;
619         args = [imgData];
620 
621         operatorList.addImageOps(
622           OPS.paintImageMaskXObject,
623           args,
624           optionalContent
625         );
626 
627         if (cacheKey) {
628           const cacheData = {
629             fn: OPS.paintImageMaskXObject,
630             args,
631             optionalContent,
632           };
633           localImageCache.set(cacheKey, imageRef, cacheData);
634 
635           if (imageRef) {
636             this._regionalImageCache.set(
637               /* name = */ null,
638               imageRef,
639               cacheData
640             );
641           }
642         }
643         return;
644       }
645 
646       imgData = await PDFImage.createMask({
647         imgArray,
648         width: w,
649         height: h,
650         imageIsFromDecodeStream: image instanceof DecodeStream,
651         inverseDecode: decode?.[0] > 0,
652         interpolate,
653         isOffscreenCanvasSupported: this.options.isOffscreenCanvasSupported,
654       });
655 
656       if (imgData.isSingleOpaquePixel) {
657         // Handles special case of mainly LaTeX documents which use image
658         // masks to draw lines with the current fill style.
659         operatorList.addImageOps(
660           OPS.paintSolidColorImageMask,
661           [],
662           optionalContent
663         );
664 
665         if (cacheKey) {
666           const cacheData = {
667             fn: OPS.paintSolidColorImageMask,
668             args: [],
669             optionalContent,
670           };
671           localImageCache.set(cacheKey, imageRef, cacheData);
672 
673           if (imageRef) {
674             this._regionalImageCache.set(
675               /* name = */ null,
676               imageRef,
677               cacheData
678             );
679           }
680         }
681         return;
682       }
683 
684       const objId = `mask_${this.idFactory.createObjId()}`;
685       operatorList.addDependency(objId);
686 
687       imgData.dataLen = imgData.bitmap
688         ? imgData.width * imgData.height * 4
689         : imgData.data.length;
690       this._sendImgData(objId, imgData);
691 
692       args = [
693         {
694           data: objId,
695           width: imgData.width,
696           height: imgData.height,
697           interpolate: imgData.interpolate,
698           count: 1,
699         },
700       ];
701       operatorList.addImageOps(
702         OPS.paintImageMaskXObject,
703         args,
704         optionalContent
705       );
706 
707       if (cacheKey) {
708         const cacheData = {
709           objId,
710           fn: OPS.paintImageMaskXObject,
711           args,
712           optionalContent,
713         };
714         localImageCache.set(cacheKey, imageRef, cacheData);
715 
716         if (imageRef) {
717           this._regionalImageCache.set(/* name = */ null, imageRef, cacheData);
718         }
719       }
720       return;
721     }
722 
723     const SMALL_IMAGE_DIMENSIONS = 200;
724     const hasMask = dict.has("SMask") || dict.has("Mask");
725     // Inlining small images into the queue as RGB data
726     if (isInline && w + h < SMALL_IMAGE_DIMENSIONS && !hasMask) {
727       try {
728         const imageObj = new PDFImage({
729           xref: this.xref,
730           res: resources,
731           image,
732           isInline,
733           pdfFunctionFactory: this._pdfFunctionFactory,
734           globalColorSpaceCache: this.globalColorSpaceCache,
735           localColorSpaceCache,
736         });
737         // We force the use of RGBA_32BPP images here, because we can't handle
738         // any other kind.
739         imgData = await imageObj.createImageData(
740           /* forceRGBA = */ true,
741           /* isOffscreenCanvasSupported = */ false
742         );
743         operatorList.isOffscreenCanvasSupported =
744           this.options.isOffscreenCanvasSupported;
745         operatorList.addImageOps(
746           OPS.paintInlineImageXObject,
747           [imgData],
748           optionalContent
749         );
750       } catch (reason) {
751         const msg = `Unable to decode inline image: "${reason}".`;
752 
753         if (!this.options.ignoreErrors) {
754           throw new Error(msg);
755         }
756         warn(msg);
757       }
758       return;
759     }
760 
761     // If there is no imageMask, create the PDFImage and a lot
762     // of image processing can be done here.
763     let objId = `img_${this.idFactory.createObjId()}`,
764       cacheGlobally = false;
765 
766     if (this.parsingType3Font) {
767       objId = `${this.idFactory.getDocId()}_type3_${objId}`;
768     } else if (cacheKey && imageRef) {
769       cacheGlobally = this.globalImageCache.shouldCache(
770         imageRef,
771         this.pageIndex
772       );
773 
774       if (cacheGlobally) {
775         assert(!isInline, "Cannot cache an inline image globally.");
776 
777         objId = `${this.idFactory.getDocId()}_${objId}`;
778       }
779     }
780 
781     // Ensure that the dependency is added before the image is decoded.
782     operatorList.addDependency(objId);
783     args = [objId, w, h];
784     operatorList.addImageOps(
785       OPS.paintImageXObject,
786       args,
787       optionalContent,
788       hasMask
789     );
790 
791     if (cacheGlobally) {
792       if (this.globalImageCache.hasDecodeFailed(imageRef)) {
793         this.globalImageCache.setData(imageRef, {
794           objId,
795           fn: OPS.paintImageXObject,
796           args,
797           optionalContent,
798           hasMask,
799           byteSize: 0, // Data is `null`, since decoding failed previously.
800         });
801 
802         this._sendImgData(objId, /* imgData = */ null, cacheGlobally);
803         return;
804       }
805 
806       // For large (at least 500x500) or more complex images that we'll cache
807       // globally, check if the image is still cached locally on the main-thread
808       // to avoid having to re-parse the image (since that can be slow).
809       if (w * h > 250000 || hasMask) {
810         const localLength = await this.handler.sendWithPromise("commonobj", [
811           objId,
812           "CopyLocalImage",
813           { imageRef },
814         ]);
815 
816         if (localLength) {
817           this.globalImageCache.setData(imageRef, {
818             objId,
819             fn: OPS.paintImageXObject,
820             args,
821             optionalContent,
822             hasMask,
823             byteSize: 0, // Temporary entry, to avoid `setData` returning early.
824           });
825           this.globalImageCache.addByteSize(imageRef, localLength);
826           return;
827         }
828       }
829     }
830 
831     PDFImage.buildImage({
832       xref: this.xref,
833       res: resources,
834       image,
835       isInline,
836       pdfFunctionFactory: this._pdfFunctionFactory,
837       globalColorSpaceCache: this.globalColorSpaceCache,
838       localColorSpaceCache,
839     })
840       .then(async imageObj => {
841         imgData = await imageObj.createImageData(
842           /* forceRGBA = */ false,
843           /* isOffscreenCanvasSupported = */ this.options
844             .isOffscreenCanvasSupported
845         );
846         imgData.dataLen = imgData.bitmap
847           ? imgData.width * imgData.height * 4
848           : imgData.data.length;
849         imgData.ref = imageRef;
850 
851         if (cacheGlobally) {
852           this.globalImageCache.addByteSize(imageRef, imgData.dataLen);
853         }
854         return this._sendImgData(objId, imgData, cacheGlobally);
855       })
856       .catch(reason => {
857         warn(`Unable to decode image "${objId}": "${reason}".`);
858 
859         if (imageRef) {
860           this.globalImageCache.addDecodeFailed(imageRef);
861         }
862         return this._sendImgData(objId, /* imgData = */ null, cacheGlobally);
863       });
864 
865     if (cacheKey) {
866       const cacheData = {
867         objId,
868         fn: OPS.paintImageXObject,
869         args,
870         optionalContent,
871         hasMask,
872       };
873       localImageCache.set(cacheKey, imageRef, cacheData);
874 
875       if (imageRef) {
876         this._regionalImageCache.set(/* name = */ null, imageRef, cacheData);
877 
878         if (cacheGlobally) {
879           this.globalImageCache.setData(imageRef, {
880             objId,
881             fn: OPS.paintImageXObject,
882             args,
883             optionalContent,
884             hasMask,
885             byteSize: 0, // Temporary entry, note `addByteSize` above.
886           });
887         }
888       }
889     }
890   }
891 
892   handleSMask(
893     smask,
894     resources,
895     operatorList,
896     task,
897     stateManager,
898     localColorSpaceCache
899   ) {
900     const smaskContent = smask.get("G");
901     const smaskOptions = {
902       subtype: smask.get("S").name,
903       backdrop: smask.get("BC"),
904     };
905 
906     // The SMask might have a alpha/luminosity value transfer function --
907     // we will build a map of integer values in range 0..255 to be fast.
908     const transferObj = smask.get("TR");
909     if (isPDFFunction(transferObj)) {
910       const transferFn = this._pdfFunctionFactory.create(transferObj);
911       const transferMap = new Uint8Array(256);
912       const tmp = new Float32Array(1);
913       for (let i = 0; i < 256; i++) {
914         tmp[0] = i / 255;
915         transferFn(tmp, 0, tmp, 0);
916         transferMap[i] = (tmp[0] * 255) | 0;
917       }
918       smaskOptions.transferMap = transferMap;
919     }
920 
921     return this.buildFormXObject(
922       resources,
923       smaskContent,
924       smaskOptions,
925       operatorList,
926       task,
927       stateManager.state.clone(),
928       localColorSpaceCache
929     );
930   }
931 
932   handleTransferFunction(tr) {
933     let transferArray;
934     if (Array.isArray(tr)) {
935       transferArray = tr;
936     } else if (isPDFFunction(tr)) {
937       transferArray = [tr];
938     } else {
939       return null; // Not a valid transfer function entry.
940     }
941 
942     const transferMaps = [];
943     let numFns = 0,
944       numEffectfulFns = 0;
945     for (const entry of transferArray) {
946       const transferObj = this.xref.fetchIfRef(entry);
947       numFns++;
948 
949       if (isName(transferObj, "Identity")) {
950         transferMaps.push(null);
951         continue;
952       } else if (!isPDFFunction(transferObj)) {
953         return null; // Not a valid transfer function object.
954       }
955 
956       const transferFn = this._pdfFunctionFactory.create(transferObj);
957       const transferMap = new Uint8Array(256),
958         tmp = new Float32Array(1);
959       for (let j = 0; j < 256; j++) {
960         tmp[0] = j / 255;
961         transferFn(tmp, 0, tmp, 0);
962         transferMap[j] = (tmp[0] * 255) | 0;
963       }
964       transferMaps.push(transferMap);
965       numEffectfulFns++;
966     }
967 
968     if (!(numFns === 1 || numFns === 4)) {
969       return null; // Only 1 or 4 functions are supported, by the specification.
970     }
971     if (numEffectfulFns === 0) {
972       return null; // Only /Identity transfer functions found, which are no-ops.
973     }
974     return transferMaps;
975   }
976 
977   handleTilingType(
978     fn,
979     color,
980     resources,
981     pattern,
982     patternDict,
983     operatorList,
984     task,
985     localTilingPatternCache
986   ) {
987     // Create an IR of the pattern code.
988     const tilingOpList = new OperatorList();
989     // Merge the available resources, to prevent issues when the patternDict
990     // is missing some /Resources entries (fixes issue6541.pdf).
991     const patternResources = Dict.merge({
992       xref: this.xref,
993       dictArray: [patternDict.get("Resources"), resources],
994     });
995 
996     return this.getOperatorList({
997       stream: pattern,
998       task,
999       resources: patternResources,
1000       operatorList: tilingOpList,
1001     })
1002       .then(function () {
1003         const operatorListIR = tilingOpList.getIR();
1004         const tilingPatternIR = getTilingPatternIR(
1005           operatorListIR,
1006           patternDict,
1007           color
1008         );
1009         // Add the dependencies to the parent operator list so they are
1010         // resolved before the sub operator list is executed synchronously.
1011         operatorList.addDependencies(tilingOpList.dependencies);
1012         operatorList.addOp(fn, tilingPatternIR);
1013 
1014         if (patternDict.objId) {
1015           localTilingPatternCache.set(/* name = */ null, patternDict.objId, {
1016             operatorListIR,
1017             dict: patternDict,
1018           });
1019         }
1020       })
1021       .catch(reason => {
1022         if (reason instanceof AbortException) {
1023           return;
1024         }
1025         if (this.options.ignoreErrors) {
1026           warn(`handleTilingType - ignoring pattern: "${reason}".`);
1027           return;
1028         }
1029         throw reason;
1030       });
1031   }
1032 
1033   async handleSetFont(
1034     resources,
1035     fontArgs,
1036     fontRef,
1037     operatorList,
1038     task,
1039     state,
1040     fallbackFontDict = null,
1041     cssFontInfo = null
1042   ) {
1043     const fontName = fontArgs?.[0] instanceof Name ? fontArgs[0].name : null;
1044 
1045     const translated = await this.loadFont(
1046       fontName,
1047       fontRef,
1048       resources,
1049       task,
1050       fallbackFontDict,
1051       cssFontInfo
1052     );
1053 
1054     if (translated.font.isType3Font) {
1055       // Add the dependencies to the parent operatorList so they are
1056       // resolved before Type3 operatorLists are executed synchronously.
1057       operatorList.addDependencies(translated.type3Dependencies);
1058     }
1059 
1060     state.font = translated.font;
1061     translated.send(this.handler);
1062     return translated.loadedName;
1063   }
1064 
1065   handleText(chars, state) {
1066     const font = state.font;
1067     const glyphs = font.charsToGlyphs(chars);
1068 
1069     if (font.data) {
1070       const isAddToPathSet = !!(
1071         state.textRenderingMode & TextRenderingMode.ADD_TO_PATH_FLAG
1072       );
1073       if (
1074         isAddToPathSet ||
1075         state.fillColorSpace.name === "Pattern" ||
1076         font.disableFontFace
1077       ) {
1078         PartialEvaluator.buildFontPaths(
1079           font,
1080           glyphs,
1081           this.handler,
1082           this.options
1083         );
1084       }
1085     }
1086     return glyphs;
1087   }
1088 
1089   ensureStateFont(state) {
1090     if (state.font) {
1091       return;
1092     }
1093     const reason = new FormatError(
1094       "Missing setFont (Tf) operator before text rendering operator."
1095     );
1096 
1097     if (this.options.ignoreErrors) {
1098       warn(`ensureStateFont: "${reason}".`);
1099       return;
1100     }
1101     throw reason;
1102   }
1103 
1104   async setGState({
1105     resources,
1106     gState,
1107     operatorList,
1108     cacheKey,
1109     task,
1110     stateManager,
1111     localGStateCache,
1112     localColorSpaceCache,
1113   }) {
1114     const gStateRef = gState.objId;
1115     let isSimpleGState = true;
1116     // This array holds the converted/processed state data.
1117     const gStateObj = [];
1118     let promise = Promise.resolve();
1119     for (const [key, value] of gState) {
1120       switch (key) {
1121         case "Type":
1122           break;
1123         case "LW":
1124         case "LC":
1125         case "LJ":
1126         case "ML":
1127         case "D":
1128         case "RI":
1129         case "FL":
1130         case "CA":
1131         case "ca":
1132           gStateObj.push([key, value]);
1133           break;
1134         case "Font":
1135           isSimpleGState = false;
1136 
1137           promise = promise.then(() =>
1138             this.handleSetFont(
1139               resources,
1140               null,
1141               value[0],
1142               operatorList,
1143               task,
1144               stateManager.state
1145             ).then(function (loadedName) {
1146               operatorList.addDependency(loadedName);
1147               gStateObj.push([key, [loadedName, value[1]]]);
1148             })
1149           );
1150           break;
1151         case "BM":
1152           gStateObj.push([key, normalizeBlendMode(value)]);
1153           break;
1154         case "SMask":
1155           if (isName(value, "None")) {
1156             gStateObj.push([key, false]);
1157             break;
1158           }
1159           if (value instanceof Dict) {
1160             isSimpleGState = false;
1161 
1162             promise = promise.then(() =>
1163               this.handleSMask(
1164                 value,
1165                 resources,
1166                 operatorList,
1167                 task,
1168                 stateManager,
1169                 localColorSpaceCache
1170               )
1171             );
1172             gStateObj.push([key, true]);
1173           } else {
1174             warn("Unsupported SMask type");
1175           }
1176           break;
1177         case "TR":
1178           const transferMaps = this.handleTransferFunction(value);
1179           gStateObj.push([key, transferMaps]);
1180           break;
1181         // Only generate info log messages for the following since
1182         // they are unlikely to have a big impact on the rendering.
1183         case "OP":
1184         case "op":
1185         case "OPM":
1186         case "BG":
1187         case "BG2":
1188         case "UCR":
1189         case "UCR2":
1190         case "TR2":
1191         case "HT":
1192         case "SM":
1193         case "SA":
1194         case "AIS":
1195         case "TK":
1196           // TODO implement these operators.
1197           info("graphic state operator " + key);
1198           break;
1199         default:
1200           info("Unknown graphic state operator " + key);
1201           break;
1202       }
1203     }
1204     await promise;
1205 
1206     if (gStateObj.length > 0) {
1207       operatorList.addOp(OPS.setGState, [gStateObj]);
1208     }
1209 
1210     if (isSimpleGState) {
1211       localGStateCache.set(cacheKey, gStateRef, gStateObj);
1212     }
1213   }
1214 
1215   loadFont(
1216     fontName,
1217     font,
1218     resources,
1219     task,
1220     fallbackFontDict = null,
1221     cssFontInfo = null
1222   ) {
1223     const errorFont = async () =>
1224       new TranslatedFont({
1225         loadedName: "g_font_error",
1226         font: new ErrorFont(`Font "${fontName}" is not available.`),
1227         dict: font,
1228       });
1229 
1230     let fontRef;
1231     if (font) {
1232       // Loading by ref.
1233       if (font instanceof Ref) {
1234         fontRef = font;
1235       }
1236     } else {
1237       // Loading by name.
1238       const fontRes = resources.get("Font");
1239       if (fontRes) {
1240         fontRef = fontRes.getRaw(fontName);
1241       }
1242     }
1243     if (fontRef) {
1244       if (this.type3FontRefs?.has(fontRef)) {
1245         return errorFont();
1246       }
1247 
1248       if (this.fontCache.has(fontRef)) {
1249         return this.fontCache.get(fontRef);
1250       }
1251 
1252       try {
1253         font = this.xref.fetchIfRef(fontRef);
1254       } catch (ex) {
1255         warn(`loadFont - lookup failed: "${ex}".`);
1256       }
1257     }
1258 
1259     if (!(font instanceof Dict)) {
1260       if (!this.options.ignoreErrors && !this.parsingType3Font) {
1261         warn(`Font "${fontName}" is not available.`);
1262         return errorFont();
1263       }
1264       warn(
1265         `Font "${fontName}" is not available -- attempting to fallback to a default font.`
1266       );
1267 
1268       // Falling back to a default font to avoid completely broken rendering,
1269       // but note that there're no guarantees that things will look "correct".
1270       font = fallbackFontDict || PartialEvaluator.fallbackFontDict;
1271     }
1272 
1273     // We are holding `font.cacheKey` references only for `fontRef`s that
1274     // are not actually `Ref`s, but rather `Dict`s. See explanation below.
1275     if (font.cacheKey && this.fontCache.has(font.cacheKey)) {
1276       return this.fontCache.get(font.cacheKey);
1277     }
1278 
1279     const { promise, resolve } = Promise.withResolvers();
1280 
1281     let preEvaluatedFont;
1282     try {
1283       preEvaluatedFont = this.preEvaluateFont(font);
1284       preEvaluatedFont.cssFontInfo = cssFontInfo;
1285     } catch (reason) {
1286       warn(`loadFont - preEvaluateFont failed: "${reason}".`);
1287       return errorFont();
1288     }
1289     const { descriptor, hash } = preEvaluatedFont;
1290 
1291     const fontRefIsRef = fontRef instanceof Ref;
1292     let fontID;
1293 
1294     if (hash && descriptor instanceof Dict) {
1295       const fontAliases = (descriptor.fontAliases ||= Object.create(null));
1296 
1297       if (fontAliases[hash]) {
1298         const aliasFontRef = fontAliases[hash].aliasRef;
1299         if (fontRefIsRef && aliasFontRef && this.fontCache.has(aliasFontRef)) {
1300           this.fontCache.putAlias(fontRef, aliasFontRef);
1301           return this.fontCache.get(fontRef);
1302         }
1303       } else {
1304         fontAliases[hash] = {
1305           fontID: this.idFactory.createFontId(),
1306         };
1307       }
1308 
1309       if (fontRefIsRef) {
1310         fontAliases[hash].aliasRef = fontRef;
1311       }
1312       fontID = fontAliases[hash].fontID;
1313     } else {
1314       fontID = this.idFactory.createFontId();
1315     }
1316     assert(
1317       fontID?.startsWith("f"),
1318       'The "fontID" must be (correctly) defined.'
1319     );
1320 
1321     // Workaround for bad PDF generators that reference fonts incorrectly,
1322     // where `fontRef` is a `Dict` rather than a `Ref` (fixes bug946506.pdf).
1323     // In this case we cannot put the font into `this.fontCache` (which is
1324     // a `RefSetCache`), since it's not possible to use a `Dict` as a key.
1325     //
1326     // However, if we don't cache the font it's not possible to remove it
1327     // when `cleanup` is triggered from the API, which causes issues on
1328     // subsequent rendering operations (see issue7403.pdf) and would force us
1329     // to unnecessarily load the same fonts over and over.
1330     //
1331     // Instead, we cheat a bit by using a modified `fontID` as a key in
1332     // `this.fontCache`, to allow the font to be cached.
1333     // NOTE: This works because `RefSetCache` calls `toString()` on provided
1334     //       keys. Also, since `fontRef` is used when getting cached fonts,
1335     //       we'll not accidentally match fonts cached with the `fontID`.
1336     if (fontRefIsRef) {
1337       this.fontCache.put(fontRef, promise);
1338     } else {
1339       font.cacheKey = `cacheKey_${fontID}`;
1340       this.fontCache.put(font.cacheKey, promise);
1341     }
1342 
1343     // Keep track of each font we translated so the caller can
1344     // load them asynchronously before calling display on a page.
1345     font.loadedName = `${this.idFactory.getDocId()}_${fontID}`;
1346 
1347     this.translateFont(preEvaluatedFont)
1348       .then(async translatedFont => {
1349         const translated = new TranslatedFont({
1350           loadedName: font.loadedName,
1351           font: translatedFont,
1352           dict: font,
1353         });
1354 
1355         if (translatedFont.isType3Font) {
1356           try {
1357             await translated.loadType3Data(this, resources, task);
1358           } catch (reason) {
1359             throw new Error(`Type3 font load error: ${reason}`);
1360           }
1361         }
1362         resolve(translated);
1363       })
1364       .catch(reason => {
1365         // TODO reject?
1366         warn(`loadFont - translateFont failed: "${reason}".`);
1367 
1368         resolve(
1369           new TranslatedFont({
1370             loadedName: font.loadedName,
1371             font: new ErrorFont(reason?.message),
1372             dict: font,
1373           })
1374         );
1375       });
1376     return promise;
1377   }
1378 
1379   buildPath(operatorList, fn, args, parsingText = false) {
1380     const lastIndex = operatorList.length - 1;
1381     if (!args) {
1382       args = [];
1383     }
1384     if (
1385       lastIndex < 0 ||
1386       operatorList.fnArray[lastIndex] !== OPS.constructPath
1387     ) {
1388       // Handle corrupt PDF documents that contains path operators inside of
1389       // text objects, which may shift subsequent text, by enclosing the path
1390       // operator in save/restore operators (fixes issue10542_reduced.pdf).
1391       //
1392       // Note that this will effectively disable the optimization in the
1393       // `else` branch below, but given that this type of corruption is
1394       // *extremely* rare that shouldn't really matter much in practice.
1395       if (parsingText) {
1396         warn(`Encountered path operator "${fn}" inside of a text object.`);
1397         operatorList.addOp(OPS.save, null);
1398       }
1399 
1400       let minMax;
1401       switch (fn) {
1402         case OPS.rectangle:
1403           const x = args[0] + args[2];
1404           const y = args[1] + args[3];
1405           minMax = [
1406             Math.min(args[0], x),
1407             Math.min(args[1], y),
1408             Math.max(args[0], x),
1409             Math.max(args[1], y),
1410           ];
1411           break;
1412         case OPS.moveTo:
1413         case OPS.lineTo:
1414           minMax = [args[0], args[1], args[0], args[1]];
1415           break;
1416         default:
1417           minMax = [Infinity, Infinity, -Infinity, -Infinity];
1418           break;
1419       }
1420       operatorList.addOp(OPS.constructPath, [[fn], args, minMax]);
1421 
1422       if (parsingText) {
1423         operatorList.addOp(OPS.restore, null);
1424       }
1425     } else {
1426       const opArgs = operatorList.argsArray[lastIndex];
1427       opArgs[0].push(fn);
1428       opArgs[1].push(...args);
1429       const minMax = opArgs[2];
1430 
1431       // Compute min/max in the worker instead of the main thread.
1432       // If the current matrix (when drawing) is a scaling one
1433       // then min/max can be easily computed in using those values.
1434       // Only rectangle, lineTo and moveTo are handled here since
1435       // Bezier stuff requires to have the starting point.
1436       switch (fn) {
1437         case OPS.rectangle:
1438           const x = args[0] + args[2];
1439           const y = args[1] + args[3];
1440           minMax[0] = Math.min(minMax[0], args[0], x);
1441           minMax[1] = Math.min(minMax[1], args[1], y);
1442           minMax[2] = Math.max(minMax[2], args[0], x);
1443           minMax[3] = Math.max(minMax[3], args[1], y);
1444           break;
1445         case OPS.moveTo:
1446         case OPS.lineTo:
1447           minMax[0] = Math.min(minMax[0], args[0]);
1448           minMax[1] = Math.min(minMax[1], args[1]);
1449           minMax[2] = Math.max(minMax[2], args[0]);
1450           minMax[3] = Math.max(minMax[3], args[1]);
1451           break;
1452       }
1453     }
1454   }
1455 
1456   _getColorSpace(cs, resources, localColorSpaceCache) {
1457     return ColorSpaceUtils.parse({
1458       cs,
1459       xref: this.xref,
1460       resources,
1461       pdfFunctionFactory: this._pdfFunctionFactory,
1462       globalColorSpaceCache: this.globalColorSpaceCache,
1463       localColorSpaceCache,
1464       asyncIfNotCached: true,
1465     });
1466   }
1467 
1468   async _handleColorSpace(csPromise) {
1469     try {
1470       return await csPromise;
1471     } catch (ex) {
1472       if (ex instanceof AbortException) {
1473         return null;
1474       }
1475       if (this.options.ignoreErrors) {
1476         warn(`_handleColorSpace - ignoring ColorSpace: "${ex}".`);
1477         return null;
1478       }
1479       throw ex;
1480     }
1481   }
1482 
1483   parseShading({
1484     shading,
1485     resources,
1486     localColorSpaceCache,
1487     localShadingPatternCache,
1488   }) {
1489     // Shadings and patterns may be referenced by the same name but the resource
1490     // dictionary could be different so we can't use the name for the cache key.
1491     let id = localShadingPatternCache.get(shading);
1492     if (id) {
1493       return id;
1494     }
1495     let patternIR;
1496 
1497     try {
1498       const shadingFill = Pattern.parseShading(
1499         shading,
1500         this.xref,
1501         resources,
1502         this._pdfFunctionFactory,
1503         this.globalColorSpaceCache,
1504         localColorSpaceCache
1505       );
1506       patternIR = shadingFill.getIR();
1507     } catch (reason) {
1508       if (reason instanceof AbortException) {
1509         return null;
1510       }
1511       if (this.options.ignoreErrors) {
1512         warn(`parseShading - ignoring shading: "${reason}".`);
1513 
1514         localShadingPatternCache.set(shading, null);
1515         return null;
1516       }
1517       throw reason;
1518     }
1519 
1520     id = `pattern_${this.idFactory.createObjId()}`;
1521     if (this.parsingType3Font) {
1522       id = `${this.idFactory.getDocId()}_type3_${id}`;
1523     }
1524     localShadingPatternCache.set(shading, id);
1525 
1526     if (this.parsingType3Font) {
1527       this.handler.send("commonobj", [id, "Pattern", patternIR]);
1528     } else {
1529       this.handler.send("obj", [id, this.pageIndex, "Pattern", patternIR]);
1530     }
1531     return id;
1532   }
1533 
1534   handleColorN(
1535     operatorList,
1536     fn,
1537     args,
1538     cs,
1539     patterns,
1540     resources,
1541     task,
1542     localColorSpaceCache,
1543     localTilingPatternCache,
1544     localShadingPatternCache
1545   ) {
1546     // compile tiling patterns
1547     const patternName = args.pop();
1548     // SCN/scn applies patterns along with normal colors
1549     if (patternName instanceof Name) {
1550       const rawPattern = patterns.getRaw(patternName.name);
1551 
1552       const localTilingPattern =
1553         rawPattern instanceof Ref &&
1554         localTilingPatternCache.getByRef(rawPattern);
1555       if (localTilingPattern) {
1556         try {
1557           const color = cs.base ? cs.base.getRgb(args, 0) : null;
1558           const tilingPatternIR = getTilingPatternIR(
1559             localTilingPattern.operatorListIR,
1560             localTilingPattern.dict,
1561             color
1562           );
1563           operatorList.addOp(fn, tilingPatternIR);
1564           return undefined;
1565         } catch {
1566           // Handle any errors during normal TilingPattern parsing.
1567         }
1568       }
1569 
1570       const pattern = this.xref.fetchIfRef(rawPattern);
1571       if (pattern) {
1572         const dict = pattern instanceof BaseStream ? pattern.dict : pattern;
1573         const typeNum = dict.get("PatternType");
1574 
1575         if (typeNum === PatternType.TILING) {
1576           const color = cs.base ? cs.base.getRgb(args, 0) : null;
1577           return this.handleTilingType(
1578             fn,
1579             color,
1580             resources,
1581             pattern,
1582             dict,
1583             operatorList,
1584             task,
1585             localTilingPatternCache
1586           );
1587         } else if (typeNum === PatternType.SHADING) {
1588           const shading = dict.get("Shading");
1589           const objId = this.parseShading({
1590             shading,
1591             resources,
1592             localColorSpaceCache,
1593             localShadingPatternCache,
1594           });
1595           if (objId) {
1596             const matrix = lookupMatrix(dict.getArray("Matrix"), null);
1597             operatorList.addOp(fn, ["Shading", objId, matrix]);
1598           }
1599           return undefined;
1600         }
1601         throw new FormatError(`Unknown PatternType: ${typeNum}`);
1602       }
1603     }
1604     throw new FormatError(`Unknown PatternName: ${patternName}`);
1605   }
1606 
1607   _parseVisibilityExpression(array, nestingCounter, currentResult) {
1608     const MAX_NESTING = 10;
1609     if (++nestingCounter > MAX_NESTING) {
1610       warn("Visibility expression is too deeply nested");
1611       return;
1612     }
1613     const length = array.length;
1614     const operator = this.xref.fetchIfRef(array[0]);
1615     if (length < 2 || !(operator instanceof Name)) {
1616       warn("Invalid visibility expression");
1617       return;
1618     }
1619     switch (operator.name) {
1620       case "And":
1621       case "Or":
1622       case "Not":
1623         currentResult.push(operator.name);
1624         break;
1625       default:
1626         warn(`Invalid operator ${operator.name} in visibility expression`);
1627         return;
1628     }
1629     for (let i = 1; i < length; i++) {
1630       const raw = array[i];
1631       const object = this.xref.fetchIfRef(raw);
1632       if (Array.isArray(object)) {
1633         const nestedResult = [];
1634         currentResult.push(nestedResult);
1635         // Recursively parse a subarray.
1636         this._parseVisibilityExpression(object, nestingCounter, nestedResult);
1637       } else if (raw instanceof Ref) {
1638         // Reference to an OCG dictionary.
1639         currentResult.push(raw.toString());
1640       }
1641     }
1642   }
1643 
1644   async parseMarkedContentProps(contentProperties, resources) {
1645     let optionalContent;
1646     if (contentProperties instanceof Name) {
1647       const properties = resources.get("Properties");
1648       optionalContent = properties.get(contentProperties.name);
1649     } else if (contentProperties instanceof Dict) {
1650       optionalContent = contentProperties;
1651     } else {
1652       throw new FormatError("Optional content properties malformed.");
1653     }
1654 
1655     const optionalContentType = optionalContent.get("Type")?.name;
1656     if (optionalContentType === "OCG") {
1657       return {
1658         type: optionalContentType,
1659         id: optionalContent.objId,
1660       };
1661     } else if (optionalContentType === "OCMD") {
1662       const expression = optionalContent.get("VE");
1663       if (Array.isArray(expression)) {
1664         const result = [];
1665         this._parseVisibilityExpression(expression, 0, result);
1666         if (result.length > 0) {
1667           return {
1668             type: "OCMD",
1669             expression: result,
1670           };
1671         }
1672       }
1673 
1674       const optionalContentGroups = optionalContent.get("OCGs");
1675       if (
1676         Array.isArray(optionalContentGroups) ||
1677         optionalContentGroups instanceof Dict
1678       ) {
1679         const groupIds = [];
1680         if (Array.isArray(optionalContentGroups)) {
1681           for (const ocg of optionalContentGroups) {
1682             groupIds.push(ocg.toString());
1683           }
1684         } else {
1685           // Dictionary, just use the obj id.
1686           groupIds.push(optionalContentGroups.objId);
1687         }
1688 
1689         return {
1690           type: optionalContentType,
1691           ids: groupIds,
1692           policy:
1693             optionalContent.get("P") instanceof Name
1694               ? optionalContent.get("P").name
1695               : null,
1696           expression: null,
1697         };
1698       } else if (optionalContentGroups instanceof Ref) {
1699         return {
1700           type: optionalContentType,
1701           id: optionalContentGroups.toString(),
1702         };
1703       }
1704     }
1705     return null;
1706   }
1707 
1708   getOperatorList({
1709     stream,
1710     task,
1711     resources,
1712     operatorList,
1713     initialState = null,
1714     fallbackFontDict = null,
1715   }) {
1716     // Ensure that `resources`/`initialState` is correctly initialized,
1717     // even if the provided parameter is e.g. `null`.
1718     resources ||= Dict.empty;
1719     initialState ||= new EvalState();
1720 
1721     if (!operatorList) {
1722       throw new Error('getOperatorList: missing "operatorList" parameter');
1723     }
1724 
1725     const self = this;
1726     const xref = this.xref;
1727     let parsingText = false;
1728     const localImageCache = new LocalImageCache();
1729     const localColorSpaceCache = new LocalColorSpaceCache();
1730     const localGStateCache = new LocalGStateCache();
1731     const localTilingPatternCache = new LocalTilingPatternCache();
1732     const localShadingPatternCache = new Map();
1733 
1734     const xobjs = resources.get("XObject") || Dict.empty;
1735     const patterns = resources.get("Pattern") || Dict.empty;
1736     const stateManager = new StateManager(initialState);
1737     const preprocessor = new EvaluatorPreprocessor(stream, xref, stateManager);
1738     const timeSlotManager = new TimeSlotManager();
1739 
1740     function closePendingRestoreOPS(argument) {
1741       for (let i = 0, ii = preprocessor.savedStatesDepth; i < ii; i++) {
1742         operatorList.addOp(OPS.restore, []);
1743       }
1744     }
1745 
1746     return new Promise(function promiseBody(resolve, reject) {
1747       const next = function (promise) {
1748         Promise.all([promise, operatorList.ready]).then(function () {
1749           try {
1750             promiseBody(resolve, reject);
1751           } catch (ex) {
1752             reject(ex);
1753           }
1754         }, reject);
1755       };
1756       task.ensureNotTerminated();
1757       timeSlotManager.reset();
1758 
1759       const operation = {};
1760       let stop, i, ii, cs, name, isValidName;
1761       while (!(stop = timeSlotManager.check())) {
1762         // The arguments parsed by read() are used beyond this loop, so we
1763         // cannot reuse the same array on each iteration. Therefore we pass
1764         // in |null| as the initial value (see the comment on
1765         // EvaluatorPreprocessor_read() for why).
1766         operation.args = null;
1767         if (!preprocessor.read(operation)) {
1768           break;
1769         }
1770         let args = operation.args;
1771         let fn = operation.fn;
1772 
1773         switch (fn | 0) {
1774           case OPS.paintXObject:
1775             // eagerly compile XForm objects
1776             isValidName = args[0] instanceof Name;
1777             name = args[0].name;
1778 
1779             if (isValidName) {
1780               const localImage = localImageCache.getByName(name);
1781               if (localImage) {
1782                 addLocallyCachedImageOps(operatorList, localImage);
1783                 args = null;
1784                 continue;
1785               }
1786             }
1787 
1788             next(
1789               new Promise(function (resolveXObject, rejectXObject) {
1790                 if (!isValidName) {
1791                   throw new FormatError("XObject must be referred to by name.");
1792                 }
1793 
1794                 let xobj = xobjs.getRaw(name);
1795                 if (xobj instanceof Ref) {
1796                   const localImage =
1797                     localImageCache.getByRef(xobj) ||
1798                     self._regionalImageCache.getByRef(xobj);
1799                   if (localImage) {
1800                     addLocallyCachedImageOps(operatorList, localImage);
1801                     resolveXObject();
1802                     return;
1803                   }
1804 
1805                   const globalImage = self.globalImageCache.getData(
1806                     xobj,
1807                     self.pageIndex
1808                   );
1809                   if (globalImage) {
1810                     operatorList.addDependency(globalImage.objId);
1811                     operatorList.addImageOps(
1812                       globalImage.fn,
1813                       globalImage.args,
1814                       globalImage.optionalContent,
1815                       globalImage.hasMask
1816                     );
1817 
1818                     resolveXObject();
1819                     return;
1820                   }
1821 
1822                   xobj = xref.fetch(xobj);
1823                 }
1824 
1825                 if (!(xobj instanceof BaseStream)) {
1826                   throw new FormatError("XObject should be a stream");
1827                 }
1828 
1829                 const type = xobj.dict.get("Subtype");
1830                 if (!(type instanceof Name)) {
1831                   throw new FormatError("XObject should have a Name subtype");
1832                 }
1833 
1834                 if (type.name === "Form") {
1835                   stateManager.save();
1836                   self
1837                     .buildFormXObject(
1838                       resources,
1839                       xobj,
1840                       null,
1841                       operatorList,
1842                       task,
1843                       stateManager.state.clone(),
1844                       localColorSpaceCache
1845                     )
1846                     .then(function () {
1847                       stateManager.restore();
1848                       resolveXObject();
1849                     }, rejectXObject);
1850                   return;
1851                 } else if (type.name === "Image") {
1852                   self
1853                     .buildPaintImageXObject({
1854                       resources,
1855                       image: xobj,
1856                       operatorList,
1857                       cacheKey: name,
1858                       localImageCache,
1859                       localColorSpaceCache,
1860                     })
1861                     .then(resolveXObject, rejectXObject);
1862                   return;
1863                 } else if (type.name === "PS") {
1864                   // PostScript XObjects are unused when viewing documents.
1865                   // See section 4.7.1 of Adobe's PDF reference.
1866                   info("Ignored XObject subtype PS");
1867                 } else {
1868                   throw new FormatError(
1869                     `Unhandled XObject subtype ${type.name}`
1870                   );
1871                 }
1872                 resolveXObject();
1873               }).catch(function (reason) {
1874                 if (reason instanceof AbortException) {
1875                   return;
1876                 }
1877                 if (self.options.ignoreErrors) {
1878                   warn(`getOperatorList - ignoring XObject: "${reason}".`);
1879                   return;
1880                 }
1881                 throw reason;
1882               })
1883             );
1884             return;
1885           case OPS.setFont:
1886             const fontSize = args[1];
1887             // eagerly collect all fonts
1888             next(
1889               self
1890                 .handleSetFont(
1891                   resources,
1892                   args,
1893                   null,
1894                   operatorList,
1895                   task,
1896                   stateManager.state,
1897                   fallbackFontDict
1898                 )
1899                 .then(function (loadedName) {
1900                   operatorList.addDependency(loadedName);
1901                   operatorList.addOp(OPS.setFont, [loadedName, fontSize]);
1902                 })
1903             );
1904             return;
1905           case OPS.beginText:
1906             parsingText = true;
1907             break;
1908           case OPS.endText:
1909             parsingText = false;
1910             break;
1911           case OPS.endInlineImage:
1912             const cacheKey = args[0].cacheKey;
1913             if (cacheKey) {
1914               const localImage = localImageCache.getByName(cacheKey);
1915               if (localImage) {
1916                 addLocallyCachedImageOps(operatorList, localImage);
1917                 args = null;
1918                 continue;
1919               }
1920             }
1921             next(
1922               self.buildPaintImageXObject({
1923                 resources,
1924                 image: args[0],
1925                 isInline: true,
1926                 operatorList,
1927                 cacheKey,
1928                 localImageCache,
1929                 localColorSpaceCache,
1930               })
1931             );
1932             return;
1933           case OPS.showText:
1934             if (!stateManager.state.font) {
1935               self.ensureStateFont(stateManager.state);
1936               continue;
1937             }
1938             args[0] = self.handleText(args[0], stateManager.state);
1939             break;
1940           case OPS.showSpacedText:
1941             if (!stateManager.state.font) {
1942               self.ensureStateFont(stateManager.state);
1943               continue;
1944             }
1945             const combinedGlyphs = [],
1946               state = stateManager.state;
1947             for (const arrItem of args[0]) {
1948               if (typeof arrItem === "string") {
1949                 combinedGlyphs.push(...self.handleText(arrItem, state));
1950               } else if (typeof arrItem === "number") {
1951                 combinedGlyphs.push(arrItem);
1952               }
1953             }
1954             args[0] = combinedGlyphs;
1955             fn = OPS.showText;
1956             break;
1957           case OPS.nextLineShowText:
1958             if (!stateManager.state.font) {
1959               self.ensureStateFont(stateManager.state);
1960               continue;
1961             }
1962             operatorList.addOp(OPS.nextLine);
1963             args[0] = self.handleText(args[0], stateManager.state);
1964             fn = OPS.showText;
1965             break;
1966           case OPS.nextLineSetSpacingShowText:
1967             if (!stateManager.state.font) {
1968               self.ensureStateFont(stateManager.state);
1969               continue;
1970             }
1971             operatorList.addOp(OPS.nextLine);
1972             operatorList.addOp(OPS.setWordSpacing, [args.shift()]);
1973             operatorList.addOp(OPS.setCharSpacing, [args.shift()]);
1974             args[0] = self.handleText(args[0], stateManager.state);
1975             fn = OPS.showText;
1976             break;
1977           case OPS.setTextRenderingMode:
1978             stateManager.state.textRenderingMode = args[0];
1979             break;
1980 
1981           case OPS.setFillColorSpace: {
1982             const fillCS = self._getColorSpace(
1983               args[0],
1984               resources,
1985               localColorSpaceCache
1986             );
1987             if (fillCS instanceof ColorSpace) {
1988               stateManager.state.fillColorSpace = fillCS;
1989               continue;
1990             }
1991 
1992             next(
1993               self._handleColorSpace(fillCS).then(colorSpace => {
1994                 stateManager.state.fillColorSpace =
1995                   colorSpace || ColorSpaceUtils.gray;
1996               })
1997             );
1998             return;
1999           }
2000           case OPS.setStrokeColorSpace: {
2001             const strokeCS = self._getColorSpace(
2002               args[0],
2003               resources,
2004               localColorSpaceCache
2005             );
2006             if (strokeCS instanceof ColorSpace) {
2007               stateManager.state.strokeColorSpace = strokeCS;
2008               continue;
2009             }
2010 
2011             next(
2012               self._handleColorSpace(strokeCS).then(colorSpace => {
2013                 stateManager.state.strokeColorSpace =
2014                   colorSpace || ColorSpaceUtils.gray;
2015               })
2016             );
2017             return;
2018           }
2019           case OPS.setFillColor:
2020             cs = stateManager.state.fillColorSpace;
2021             args = cs.getRgb(args, 0);
2022             fn = OPS.setFillRGBColor;
2023             break;
2024           case OPS.setStrokeColor:
2025             cs = stateManager.state.strokeColorSpace;
2026             args = cs.getRgb(args, 0);
2027             fn = OPS.setStrokeRGBColor;
2028             break;
2029           case OPS.setFillGray:
2030             stateManager.state.fillColorSpace = ColorSpaceUtils.gray;
2031             args = ColorSpaceUtils.gray.getRgb(args, 0);
2032             fn = OPS.setFillRGBColor;
2033             break;
2034           case OPS.setStrokeGray:
2035             stateManager.state.strokeColorSpace = ColorSpaceUtils.gray;
2036             args = ColorSpaceUtils.gray.getRgb(args, 0);
2037             fn = OPS.setStrokeRGBColor;
2038             break;
2039           case OPS.setFillCMYKColor:
2040             stateManager.state.fillColorSpace = ColorSpaceUtils.cmyk;
2041             args = ColorSpaceUtils.cmyk.getRgb(args, 0);
2042             fn = OPS.setFillRGBColor;
2043             break;
2044           case OPS.setStrokeCMYKColor:
2045             stateManager.state.strokeColorSpace = ColorSpaceUtils.cmyk;
2046             args = ColorSpaceUtils.cmyk.getRgb(args, 0);
2047             fn = OPS.setStrokeRGBColor;
2048             break;
2049           case OPS.setFillRGBColor:
2050             stateManager.state.fillColorSpace = ColorSpaceUtils.rgb;
2051             args = ColorSpaceUtils.rgb.getRgb(args, 0);
2052             break;
2053           case OPS.setStrokeRGBColor:
2054             stateManager.state.strokeColorSpace = ColorSpaceUtils.rgb;
2055             args = ColorSpaceUtils.rgb.getRgb(args, 0);
2056             break;
2057           case OPS.setFillColorN:
2058             cs = stateManager.state.patternFillColorSpace;
2059             if (!cs) {
2060               if (isNumberArray(args, null)) {
2061                 args = ColorSpaceUtils.gray.getRgb(args, 0);
2062                 fn = OPS.setFillRGBColor;
2063                 break;
2064               }
2065               args = [];
2066               fn = OPS.setFillTransparent;
2067               break;
2068             }
2069             if (cs.name === "Pattern") {
2070               next(
2071                 self.handleColorN(
2072                   operatorList,
2073                   OPS.setFillColorN,
2074                   args,
2075                   cs,
2076                   patterns,
2077                   resources,
2078                   task,
2079                   localColorSpaceCache,
2080                   localTilingPatternCache,
2081                   localShadingPatternCache
2082                 )
2083               );
2084               return;
2085             }
2086             args = cs.getRgb(args, 0);
2087             fn = OPS.setFillRGBColor;
2088             break;
2089           case OPS.setStrokeColorN:
2090             cs = stateManager.state.patternStrokeColorSpace;
2091             if (!cs) {
2092               if (isNumberArray(args, null)) {
2093                 args = ColorSpaceUtils.gray.getRgb(args, 0);
2094                 fn = OPS.setStrokeRGBColor;
2095                 break;
2096               }
2097               args = [];
2098               fn = OPS.setStrokeTransparent;
2099               break;
2100             }
2101             if (cs.name === "Pattern") {
2102               next(
2103                 self.handleColorN(
2104                   operatorList,
2105                   OPS.setStrokeColorN,
2106                   args,
2107                   cs,
2108                   patterns,
2109                   resources,
2110                   task,
2111                   localColorSpaceCache,
2112                   localTilingPatternCache,
2113                   localShadingPatternCache
2114                 )
2115               );
2116               return;
2117             }
2118             args = cs.getRgb(args, 0);
2119             fn = OPS.setStrokeRGBColor;
2120             break;
2121 
2122           case OPS.shadingFill:
2123             let shading;
2124             try {
2125               const shadingRes = resources.get("Shading");
2126               if (!shadingRes) {
2127                 throw new FormatError("No shading resource found");
2128               }
2129 
2130               shading = shadingRes.get(args[0].name);
2131               if (!shading) {
2132                 throw new FormatError("No shading object found");
2133               }
2134             } catch (reason) {
2135               if (reason instanceof AbortException) {
2136                 continue;
2137               }
2138               if (self.options.ignoreErrors) {
2139                 warn(`getOperatorList - ignoring Shading: "${reason}".`);
2140                 continue;
2141               }
2142               throw reason;
2143             }
2144             const patternId = self.parseShading({
2145               shading,
2146               resources,
2147               localColorSpaceCache,
2148               localShadingPatternCache,
2149             });
2150             if (!patternId) {
2151               continue;
2152             }
2153             args = [patternId];
2154             fn = OPS.shadingFill;
2155             break;
2156           case OPS.setGState:
2157             isValidName = args[0] instanceof Name;
2158             name = args[0].name;
2159 
2160             if (isValidName) {
2161               const localGStateObj = localGStateCache.getByName(name);
2162               if (localGStateObj) {
2163                 if (localGStateObj.length > 0) {
2164                   operatorList.addOp(OPS.setGState, [localGStateObj]);
2165                 }
2166                 args = null;
2167                 continue;
2168               }
2169             }
2170 
2171             next(
2172               new Promise(function (resolveGState, rejectGState) {
2173                 if (!isValidName) {
2174                   throw new FormatError("GState must be referred to by name.");
2175                 }
2176 
2177                 const extGState = resources.get("ExtGState");
2178                 if (!(extGState instanceof Dict)) {
2179                   throw new FormatError("ExtGState should be a dictionary.");
2180                 }
2181 
2182                 const gState = extGState.get(name);
2183                 // TODO: Attempt to lookup cached GStates by reference as well,
2184                 //       if and only if there are PDF documents where doing so
2185                 //       would significantly improve performance.
2186                 if (!(gState instanceof Dict)) {
2187                   throw new FormatError("GState should be a dictionary.");
2188                 }
2189 
2190                 self
2191                   .setGState({
2192                     resources,
2193                     gState,
2194                     operatorList,
2195                     cacheKey: name,
2196                     task,
2197                     stateManager,
2198                     localGStateCache,
2199                     localColorSpaceCache,
2200                   })
2201                   .then(resolveGState, rejectGState);
2202               }).catch(function (reason) {
2203                 if (reason instanceof AbortException) {
2204                   return;
2205                 }
2206                 if (self.options.ignoreErrors) {
2207                   warn(`getOperatorList - ignoring ExtGState: "${reason}".`);
2208                   return;
2209                 }
2210                 throw reason;
2211               })
2212             );
2213             return;
2214           case OPS.moveTo:
2215           case OPS.lineTo:
2216           case OPS.curveTo:
2217           case OPS.curveTo2:
2218           case OPS.curveTo3:
2219           case OPS.closePath:
2220           case OPS.rectangle:
2221             self.buildPath(operatorList, fn, args, parsingText);
2222             continue;
2223           case OPS.markPoint:
2224           case OPS.markPointProps:
2225           case OPS.beginCompat:
2226           case OPS.endCompat:
2227             // Ignore operators where the corresponding handlers are known to
2228             // be no-op in CanvasGraphics (display/canvas.js). This prevents
2229             // serialization errors and is also a bit more efficient.
2230             // We could also try to serialize all objects in a general way,
2231             // e.g. as done in https://github.com/mozilla/pdf.js/pull/6266,
2232             // but doing so is meaningless without knowing the semantics.
2233             continue;
2234           case OPS.beginMarkedContentProps:
2235             if (!(args[0] instanceof Name)) {
2236               warn(`Expected name for beginMarkedContentProps arg0=${args[0]}`);
2237               operatorList.addOp(OPS.beginMarkedContentProps, ["OC", null]);
2238               continue;
2239             }
2240             if (args[0].name === "OC") {
2241               next(
2242                 self
2243                   .parseMarkedContentProps(args[1], resources)
2244                   .then(data => {
2245                     operatorList.addOp(OPS.beginMarkedContentProps, [
2246                       "OC",
2247                       data,
2248                     ]);
2249                   })
2250                   .catch(reason => {
2251                     if (reason instanceof AbortException) {
2252                       return;
2253                     }
2254                     if (self.options.ignoreErrors) {
2255                       warn(
2256                         `getOperatorList - ignoring beginMarkedContentProps: "${reason}".`
2257                       );
2258                       operatorList.addOp(OPS.beginMarkedContentProps, [
2259                         "OC",
2260                         null,
2261                       ]);
2262                       return;
2263                     }
2264                     throw reason;
2265                   })
2266               );
2267               return;
2268             }
2269             // Other marked content types aren't supported yet.
2270             args = [
2271               args[0].name,
2272               args[1] instanceof Dict ? args[1].get("MCID") : null,
2273             ];
2274 
2275             break;
2276           case OPS.beginMarkedContent:
2277           case OPS.endMarkedContent:
2278           default:
2279             // Note: Ignore the operator if it has `Dict` arguments, since
2280             // those are non-serializable, otherwise postMessage will throw
2281             // "An object could not be cloned.".
2282             if (args !== null) {
2283               for (i = 0, ii = args.length; i < ii; i++) {
2284                 if (args[i] instanceof Dict) {
2285                   break;
2286                 }
2287               }
2288               if (i < ii) {
2289                 warn("getOperatorList - ignoring operator: " + fn);
2290                 continue;
2291               }
2292             }
2293         }
2294         operatorList.addOp(fn, args);
2295       }
2296       if (stop) {
2297         next(deferred);
2298         return;
2299       }
2300       // Some PDFs don't close all restores inside object/form.
2301       // Closing those for them.
2302       closePendingRestoreOPS();
2303       resolve();
2304     }).catch(reason => {
2305       if (reason instanceof AbortException) {
2306         return;
2307       }
2308       if (this.options.ignoreErrors) {
2309         warn(
2310           `getOperatorList - ignoring errors during "${task.name}" ` +
2311             `task: "${reason}".`
2312         );
2313 
2314         closePendingRestoreOPS();
2315         return;
2316       }
2317       throw reason;
2318     });
2319   }
2320 
2321   getTextContent({
2322     stream,
2323     task,
2324     resources,
2325     stateManager = null,
2326     includeMarkedContent = false,
2327     sink,
2328     seenStyles = new Set(),
2329     viewBox,
2330     lang = null,
2331     markedContentData = null,
2332     disableNormalization = false,
2333     keepWhiteSpace = false,
2334   }) {
2335     // Ensure that `resources`/`stateManager` is correctly initialized,
2336     // even if the provided parameter is e.g. `null`.
2337     resources ||= Dict.empty;
2338     stateManager ||= new StateManager(new TextState());
2339 
2340     if (includeMarkedContent) {
2341       markedContentData ||= { level: 0 };
2342     }
2343 
2344     const textContent = {
2345       items: [],
2346       styles: Object.create(null),
2347       lang,
2348     };
2349     const textContentItem = {
2350       initialized: false,
2351       str: [],
2352       totalWidth: 0,
2353       totalHeight: 0,
2354       width: 0,
2355       height: 0,
2356       vertical: false,
2357       prevTransform: null,
2358       textAdvanceScale: 0,
2359       spaceInFlowMin: 0,
2360       spaceInFlowMax: 0,
2361       trackingSpaceMin: Infinity,
2362       negativeSpaceMax: -Infinity,
2363       notASpace: -Infinity,
2364       transform: null,
2365       fontName: null,
2366       hasEOL: false,
2367     };
2368 
2369     // Use a circular buffer (length === 2) to save the last chars in the
2370     // text stream.
2371     // This implementation of the circular buffer is using a fixed array
2372     // and the position of the next element:
2373     // function addElement(x) {
2374     //   buffer[pos] = x;
2375     //   pos = (pos + 1) % buffer.length;
2376     // }
2377     // It's a way faster than:
2378     // function addElement(x) {
2379     //   buffer.push(x);
2380     //   buffer.shift();
2381     // }
2382     //
2383     // It's useful to know when we need to add a whitespace in the
2384     // text chunk.
2385     const twoLastChars = [" ", " "];
2386     let twoLastCharsPos = 0;
2387 
2388     /**
2389      * Save the last char.
2390      * @param {string} char
2391      * @returns {boolean} true when the two last chars before adding the new one
2392      * are a non-whitespace followed by a whitespace.
2393      */
2394     function saveLastChar(char) {
2395       const nextPos = (twoLastCharsPos + 1) % 2;
2396       const ret =
2397         twoLastChars[twoLastCharsPos] !== " " && twoLastChars[nextPos] === " ";
2398       twoLastChars[twoLastCharsPos] = char;
2399       twoLastCharsPos = nextPos;
2400 
2401       return !keepWhiteSpace && ret;
2402     }
2403 
2404     function shouldAddWhitepsace() {
2405       return (
2406         !keepWhiteSpace &&
2407         twoLastChars[twoLastCharsPos] !== " " &&
2408         twoLastChars[(twoLastCharsPos + 1) % 2] === " "
2409       );
2410     }
2411 
2412     function resetLastChars() {
2413       twoLastChars[0] = twoLastChars[1] = " ";
2414       twoLastCharsPos = 0;
2415     }
2416 
2417     // Used in addFakeSpaces.
2418 
2419     // A white <= fontSize * TRACKING_SPACE_FACTOR is a tracking space
2420     // so it doesn't count as a space.
2421     const TRACKING_SPACE_FACTOR = 0.102;
2422 
2423     // When a white <= fontSize * NOT_A_SPACE_FACTOR, there is no space
2424     // even if one is present in the text stream.
2425     const NOT_A_SPACE_FACTOR = 0.03;
2426 
2427     // A negative white < fontSize * NEGATIVE_SPACE_FACTOR induces
2428     // a break (a new chunk of text is created).
2429     // It doesn't change anything when the text is copied but
2430     // it improves potential mismatch between text layer and canvas.
2431     const NEGATIVE_SPACE_FACTOR = -0.2;
2432 
2433     // A white with a width in [fontSize * MIN_FACTOR; fontSize * MAX_FACTOR]
2434     // is a space which will be inserted in the current flow of words.
2435     // If the width is outside of this range then the flow is broken
2436     // (which means a new span in the text layer).
2437     // It's useful to adjust the best as possible the span in the layer
2438     // to what is displayed in the canvas.
2439     const SPACE_IN_FLOW_MIN_FACTOR = 0.102;
2440     const SPACE_IN_FLOW_MAX_FACTOR = 0.6;
2441 
2442     // If a char is too high/too low compared to the previous we just create
2443     // a new chunk.
2444     // If the advance isn't in the +/-VERTICAL_SHIFT_RATIO * height range then
2445     // a new chunk is created.
2446     const VERTICAL_SHIFT_RATIO = 0.25;
2447 
2448     const self = this;
2449     const xref = this.xref;
2450     const showSpacedTextBuffer = [];
2451 
2452     // The xobj is parsed iff it's needed, e.g. if there is a `DO` cmd.
2453     let xobjs = null;
2454     const emptyXObjectCache = new LocalImageCache();
2455     const emptyGStateCache = new LocalGStateCache();
2456 
2457     const preprocessor = new EvaluatorPreprocessor(stream, xref, stateManager);
2458 
2459     let textState;
2460 
2461     function pushWhitespace({
2462       width = 0,
2463       height = 0,
2464       transform = textContentItem.prevTransform,
2465       fontName = textContentItem.fontName,
2466     }) {
2467       textContent.items.push({
2468         str: " ",
2469         dir: "ltr",
2470         width,
2471         height,
2472         transform,
2473         fontName,
2474         hasEOL: false,
2475       });
2476     }
2477 
2478     function getCurrentTextTransform() {
2479       // 9.4.4 Text Space Details
2480       const font = textState.font;
2481       const tsm = [
2482         textState.fontSize * textState.textHScale,
2483         0,
2484         0,
2485         textState.fontSize,
2486         0,
2487         textState.textRise,
2488       ];
2489 
2490       if (
2491         font.isType3Font &&
2492         (textState.fontSize <= 1 || font.isCharBBox) &&
2493         !isArrayEqual(textState.fontMatrix, FONT_IDENTITY_MATRIX)
2494       ) {
2495         const glyphHeight = font.bbox[3] - font.bbox[1];
2496         if (glyphHeight > 0) {
2497           tsm[3] *= glyphHeight * textState.fontMatrix[3];
2498         }
2499       }
2500 
2501       return Util.transform(
2502         textState.ctm,
2503         Util.transform(textState.textMatrix, tsm)
2504       );
2505     }
2506 
2507     function ensureTextContentItem() {
2508       if (textContentItem.initialized) {
2509         return textContentItem;
2510       }
2511       const { font, loadedName } = textState;
2512       if (!seenStyles.has(loadedName)) {
2513         seenStyles.add(loadedName);
2514         textContent.styles[loadedName] = {
2515           fontFamily: font.fallbackName,
2516           ascent: font.ascent,
2517           descent: font.descent,
2518           vertical: font.vertical,
2519         };
2520         if (self.options.fontExtraProperties && font.systemFontInfo) {
2521           const style = textContent.styles[loadedName];
2522           style.fontSubstitution = font.systemFontInfo.css;
2523           style.fontSubstitutionLoadedName = font.systemFontInfo.loadedName;
2524         }
2525       }
2526       textContentItem.fontName = loadedName;
2527 
2528       const trm = (textContentItem.transform = getCurrentTextTransform());
2529       if (!font.vertical) {
2530         textContentItem.width = textContentItem.totalWidth = 0;
2531         textContentItem.height = textContentItem.totalHeight = Math.hypot(
2532           trm[2],
2533           trm[3]
2534         );
2535         textContentItem.vertical = false;
2536       } else {
2537         textContentItem.width = textContentItem.totalWidth = Math.hypot(
2538           trm[0],
2539           trm[1]
2540         );
2541         textContentItem.height = textContentItem.totalHeight = 0;
2542         textContentItem.vertical = true;
2543       }
2544 
2545       const scaleLineX = Math.hypot(
2546         textState.textLineMatrix[0],
2547         textState.textLineMatrix[1]
2548       );
2549       const scaleCtmX = Math.hypot(textState.ctm[0], textState.ctm[1]);
2550       textContentItem.textAdvanceScale = scaleCtmX * scaleLineX;
2551 
2552       const { fontSize } = textState;
2553       textContentItem.trackingSpaceMin = fontSize * TRACKING_SPACE_FACTOR;
2554       textContentItem.notASpace = fontSize * NOT_A_SPACE_FACTOR;
2555       textContentItem.negativeSpaceMax = fontSize * NEGATIVE_SPACE_FACTOR;
2556       textContentItem.spaceInFlowMin = fontSize * SPACE_IN_FLOW_MIN_FACTOR;
2557       textContentItem.spaceInFlowMax = fontSize * SPACE_IN_FLOW_MAX_FACTOR;
2558       textContentItem.hasEOL = false;
2559 
2560       textContentItem.initialized = true;
2561       return textContentItem;
2562     }
2563 
2564     function updateAdvanceScale() {
2565       if (!textContentItem.initialized) {
2566         return;
2567       }
2568 
2569       const scaleLineX = Math.hypot(
2570         textState.textLineMatrix[0],
2571         textState.textLineMatrix[1]
2572       );
2573       const scaleCtmX = Math.hypot(textState.ctm[0], textState.ctm[1]);
2574       const scaleFactor = scaleCtmX * scaleLineX;
2575       if (scaleFactor === textContentItem.textAdvanceScale) {
2576         return;
2577       }
2578 
2579       if (!textContentItem.vertical) {
2580         textContentItem.totalWidth +=
2581           textContentItem.width * textContentItem.textAdvanceScale;
2582         textContentItem.width = 0;
2583       } else {
2584         textContentItem.totalHeight +=
2585           textContentItem.height * textContentItem.textAdvanceScale;
2586         textContentItem.height = 0;
2587       }
2588 
2589       textContentItem.textAdvanceScale = scaleFactor;
2590     }
2591 
2592     function runBidiTransform(textChunk) {
2593       let text = textChunk.str.join("");
2594       if (!disableNormalization) {
2595         text = normalizeUnicode(text);
2596       }
2597       const bidiResult = bidi(text, -1, textChunk.vertical);
2598       return {
2599         str: bidiResult.str,
2600         dir: bidiResult.dir,
2601         width: Math.abs(textChunk.totalWidth),
2602         height: Math.abs(textChunk.totalHeight),
2603         transform: textChunk.transform,
2604         fontName: textChunk.fontName,
2605         hasEOL: textChunk.hasEOL,
2606       };
2607     }
2608 
2609     async function handleSetFont(fontName, fontRef) {
2610       const translated = await self.loadFont(
2611         fontName,
2612         fontRef,
2613         resources,
2614         task
2615       );
2616 
2617       textState.loadedName = translated.loadedName;
2618       textState.font = translated.font;
2619       textState.fontMatrix = translated.font.fontMatrix || FONT_IDENTITY_MATRIX;
2620     }
2621 
2622     function applyInverseRotation(x, y, matrix) {
2623       const scale = Math.hypot(matrix[0], matrix[1]);
2624       return [
2625         (matrix[0] * x + matrix[1] * y) / scale,
2626         (matrix[2] * x + matrix[3] * y) / scale,
2627       ];
2628     }
2629 
2630     function compareWithLastPosition(glyphWidth) {
2631       const currentTransform = getCurrentTextTransform();
2632       let posX = currentTransform[4];
2633       let posY = currentTransform[5];
2634 
2635       // Check if the glyph is in the viewbox.
2636       if (textState.font?.vertical) {
2637         if (
2638           posX < viewBox[0] ||
2639           posX > viewBox[2] ||
2640           posY + glyphWidth < viewBox[1] ||
2641           posY > viewBox[3]
2642         ) {
2643           return false;
2644         }
2645       } else if (
2646         posX + glyphWidth < viewBox[0] ||
2647         posX > viewBox[2] ||
2648         posY < viewBox[1] ||
2649         posY > viewBox[3]
2650       ) {
2651         return false;
2652       }
2653 
2654       if (!textState.font || !textContentItem.prevTransform) {
2655         return true;
2656       }
2657 
2658       let lastPosX = textContentItem.prevTransform[4];
2659       let lastPosY = textContentItem.prevTransform[5];
2660 
2661       if (lastPosX === posX && lastPosY === posY) {
2662         return true;
2663       }
2664 
2665       let rotate = -1;
2666       // Take into account the rotation is the current transform.
2667       if (
2668         currentTransform[0] &&
2669         currentTransform[1] === 0 &&
2670         currentTransform[2] === 0
2671       ) {
2672         rotate = currentTransform[0] > 0 ? 0 : 180;
2673       } else if (
2674         currentTransform[1] &&
2675         currentTransform[0] === 0 &&
2676         currentTransform[3] === 0
2677       ) {
2678         rotate = currentTransform[1] > 0 ? 90 : 270;
2679       }
2680 
2681       switch (rotate) {
2682         case 0:
2683           break;
2684         case 90:
2685           [posX, posY] = [posY, posX];
2686           [lastPosX, lastPosY] = [lastPosY, lastPosX];
2687           break;
2688         case 180:
2689           [posX, posY, lastPosX, lastPosY] = [
2690             -posX,
2691             -posY,
2692             -lastPosX,
2693             -lastPosY,
2694           ];
2695           break;
2696         case 270:
2697           [posX, posY] = [-posY, -posX];
2698           [lastPosX, lastPosY] = [-lastPosY, -lastPosX];
2699           break;
2700         default:
2701           // This is not a 0, 90, 180, 270 rotation so:
2702           //  - remove the scale factor from the matrix to get a rotation matrix
2703           //  - apply the inverse (which is the transposed) to the positions
2704           // and we can then compare positions of the glyphes to detect
2705           // a whitespace.
2706           [posX, posY] = applyInverseRotation(posX, posY, currentTransform);
2707           [lastPosX, lastPosY] = applyInverseRotation(
2708             lastPosX,
2709             lastPosY,
2710             textContentItem.prevTransform
2711           );
2712       }
2713 
2714       if (textState.font.vertical) {
2715         const advanceY = (lastPosY - posY) / textContentItem.textAdvanceScale;
2716         const advanceX = posX - lastPosX;
2717 
2718         // When the total height of the current chunk is negative
2719         // then we're writing from bottom to top.
2720         const textOrientation = Math.sign(textContentItem.height);
2721         if (advanceY < textOrientation * textContentItem.negativeSpaceMax) {
2722           if (
2723             Math.abs(advanceX) >
2724             0.5 * textContentItem.width /* not the same column */
2725           ) {
2726             appendEOL();
2727             return true;
2728           }
2729 
2730           resetLastChars();
2731           flushTextContentItem();
2732           return true;
2733         }
2734 
2735         if (Math.abs(advanceX) > textContentItem.width) {
2736           appendEOL();
2737           return true;
2738         }
2739 
2740         if (advanceY <= textOrientation * textContentItem.notASpace) {
2741           // The real spacing between 2 consecutive chars is thin enough to be
2742           // considered a non-space.
2743           resetLastChars();
2744         }
2745 
2746         if (advanceY <= textOrientation * textContentItem.trackingSpaceMin) {
2747           if (shouldAddWhitepsace()) {
2748             // The space is very thin, hence it deserves to have its own span in
2749             // order to avoid too much shift between the canvas and the text
2750             // layer.
2751             resetLastChars();
2752             flushTextContentItem();
2753             pushWhitespace({ height: Math.abs(advanceY) });
2754           } else {
2755             textContentItem.height += advanceY;
2756           }
2757         } else if (
2758           !addFakeSpaces(
2759             advanceY,
2760             textContentItem.prevTransform,
2761             textOrientation
2762           )
2763         ) {
2764           if (textContentItem.str.length === 0) {
2765             resetLastChars();
2766             pushWhitespace({ height: Math.abs(advanceY) });
2767           } else {
2768             textContentItem.height += advanceY;
2769           }
2770         }
2771 
2772         if (Math.abs(advanceX) > textContentItem.width * VERTICAL_SHIFT_RATIO) {
2773           flushTextContentItem();
2774         }
2775 
2776         return true;
2777       }
2778 
2779       const advanceX = (posX - lastPosX) / textContentItem.textAdvanceScale;
2780       const advanceY = posY - lastPosY;
2781 
2782       // When the total width of the current chunk is negative
2783       // then we're writing from right to left.
2784       const textOrientation = Math.sign(textContentItem.width);
2785       if (advanceX < textOrientation * textContentItem.negativeSpaceMax) {
2786         if (
2787           Math.abs(advanceY) >
2788           0.5 * textContentItem.height /* not the same line */
2789         ) {
2790           appendEOL();
2791           return true;
2792         }
2793 
2794         // We're moving back so in case the last char was a whitespace
2795         // we cancel it: it doesn't make sense to insert it.
2796         resetLastChars();
2797         flushTextContentItem();
2798         return true;
2799       }
2800 
2801       if (Math.abs(advanceY) > textContentItem.height) {
2802         appendEOL();
2803         return true;
2804       }
2805 
2806       if (advanceX <= textOrientation * textContentItem.notASpace) {
2807         // The real spacing between 2 consecutive chars is thin enough to be
2808         // considered a non-space.
2809         resetLastChars();
2810       }
2811 
2812       if (advanceX <= textOrientation * textContentItem.trackingSpaceMin) {
2813         if (shouldAddWhitepsace()) {
2814           // The space is very thin, hence it deserves to have its own span in
2815           // order to avoid too much shift between the canvas and the text
2816           // layer.
2817           resetLastChars();
2818           flushTextContentItem();
2819           pushWhitespace({ width: Math.abs(advanceX) });
2820         } else {
2821           textContentItem.width += advanceX;
2822         }
2823       } else if (
2824         !addFakeSpaces(advanceX, textContentItem.prevTransform, textOrientation)
2825       ) {
2826         if (textContentItem.str.length === 0) {
2827           resetLastChars();
2828           pushWhitespace({ width: Math.abs(advanceX) });
2829         } else {
2830           textContentItem.width += advanceX;
2831         }
2832       }
2833 
2834       if (Math.abs(advanceY) > textContentItem.height * VERTICAL_SHIFT_RATIO) {
2835         flushTextContentItem();
2836       }
2837 
2838       return true;
2839     }
2840 
2841     function buildTextContentItem({ chars, extraSpacing }) {
2842       const font = textState.font;
2843       if (!chars) {
2844         // Just move according to the space we have.
2845         const charSpacing = textState.charSpacing + extraSpacing;
2846         if (charSpacing) {
2847           if (!font.vertical) {
2848             textState.translateTextMatrix(
2849               charSpacing * textState.textHScale,
2850               0
2851             );
2852           } else {
2853             textState.translateTextMatrix(0, -charSpacing);
2854           }
2855         }
2856 
2857         if (keepWhiteSpace) {
2858           compareWithLastPosition(0);
2859         }
2860 
2861         return;
2862       }
2863 
2864       const glyphs = font.charsToGlyphs(chars);
2865       const scale = textState.fontMatrix[0] * textState.fontSize;
2866 
2867       for (let i = 0, ii = glyphs.length; i < ii; i++) {
2868         const glyph = glyphs[i];
2869         const { category } = glyph;
2870 
2871         if (category.isInvisibleFormatMark) {
2872           continue;
2873         }
2874         let charSpacing =
2875           textState.charSpacing + (i + 1 === ii ? extraSpacing : 0);
2876 
2877         let glyphWidth = glyph.width;
2878         if (font.vertical) {
2879           glyphWidth = glyph.vmetric ? glyph.vmetric[0] : -glyphWidth;
2880         }
2881         let scaledDim = glyphWidth * scale;
2882 
2883         if (!keepWhiteSpace && category.isWhitespace) {
2884           // Don't push a " " in the textContentItem
2885           // (except when it's between two non-spaces chars),
2886           // it will be done (if required) in next call to
2887           // compareWithLastPosition.
2888           // This way we can merge real spaces and spaces due to cursor moves.
2889           if (!font.vertical) {
2890             charSpacing += scaledDim + textState.wordSpacing;
2891             textState.translateTextMatrix(
2892               charSpacing * textState.textHScale,
2893               0
2894             );
2895           } else {
2896             charSpacing += -scaledDim + textState.wordSpacing;
2897             textState.translateTextMatrix(0, -charSpacing);
2898           }
2899           saveLastChar(" ");
2900           continue;
2901         }
2902 
2903         if (
2904           !category.isZeroWidthDiacritic &&
2905           !compareWithLastPosition(scaledDim)
2906         ) {
2907           // The glyph is not in page so just skip it but move the cursor.
2908           if (!font.vertical) {
2909             textState.translateTextMatrix(scaledDim * textState.textHScale, 0);
2910           } else {
2911             textState.translateTextMatrix(0, scaledDim);
2912           }
2913           continue;
2914         }
2915 
2916         // Must be called after compareWithLastPosition because
2917         // the textContentItem could have been flushed.
2918         const textChunk = ensureTextContentItem();
2919         if (category.isZeroWidthDiacritic) {
2920           scaledDim = 0;
2921         }
2922 
2923         if (!font.vertical) {
2924           scaledDim *= textState.textHScale;
2925           textState.translateTextMatrix(scaledDim, 0);
2926           textChunk.width += scaledDim;
2927         } else {
2928           textState.translateTextMatrix(0, scaledDim);
2929           scaledDim = Math.abs(scaledDim);
2930           textChunk.height += scaledDim;
2931         }
2932 
2933         if (scaledDim) {
2934           // Save the position of the last visible character.
2935           textChunk.prevTransform = getCurrentTextTransform();
2936         }
2937 
2938         const glyphUnicode = glyph.unicode;
2939         if (saveLastChar(glyphUnicode)) {
2940           // The two last chars are a non-whitespace followed by a whitespace
2941           // and then this non-whitespace, so we insert a whitespace here.
2942           // Replaces all whitespaces with standard spaces (0x20), to avoid
2943           // alignment issues between the textLayer and the canvas if the text
2944           // contains e.g. tabs (fixes issue6612.pdf).
2945           textChunk.str.push(" ");
2946         }
2947         textChunk.str.push(glyphUnicode);
2948 
2949         if (charSpacing) {
2950           if (!font.vertical) {
2951             textState.translateTextMatrix(
2952               charSpacing * textState.textHScale,
2953               0
2954             );
2955           } else {
2956             textState.translateTextMatrix(0, -charSpacing);
2957           }
2958         }
2959       }
2960     }
2961 
2962     function appendEOL() {
2963       resetLastChars();
2964       if (textContentItem.initialized) {
2965         textContentItem.hasEOL = true;
2966         flushTextContentItem();
2967       } else {
2968         textContent.items.push({
2969           str: "",
2970           dir: "ltr",
2971           width: 0,
2972           height: 0,
2973           transform: getCurrentTextTransform(),
2974           fontName: textState.loadedName,
2975           hasEOL: true,
2976         });
2977       }
2978     }
2979 
2980     function addFakeSpaces(width, transf, textOrientation) {
2981       if (
2982         textOrientation * textContentItem.spaceInFlowMin <= width &&
2983         width <= textOrientation * textContentItem.spaceInFlowMax
2984       ) {
2985         if (textContentItem.initialized) {
2986           resetLastChars();
2987           textContentItem.str.push(" ");
2988         }
2989         return false;
2990       }
2991 
2992       const fontName = textContentItem.fontName;
2993 
2994       let height = 0;
2995       if (textContentItem.vertical) {
2996         height = width;
2997         width = 0;
2998       }
2999 
3000       flushTextContentItem();
3001       resetLastChars();
3002       pushWhitespace({
3003         width: Math.abs(width),
3004         height: Math.abs(height),
3005         transform: transf || getCurrentTextTransform(),
3006         fontName,
3007       });
3008 
3009       return true;
3010     }
3011 
3012     function flushTextContentItem() {
3013       if (!textContentItem.initialized || !textContentItem.str) {
3014         return;
3015       }
3016 
3017       // Do final text scaling.
3018       if (!textContentItem.vertical) {
3019         textContentItem.totalWidth +=
3020           textContentItem.width * textContentItem.textAdvanceScale;
3021       } else {
3022         textContentItem.totalHeight +=
3023           textContentItem.height * textContentItem.textAdvanceScale;
3024       }
3025 
3026       textContent.items.push(runBidiTransform(textContentItem));
3027       textContentItem.initialized = false;
3028       textContentItem.str.length = 0;
3029     }
3030 
3031     function enqueueChunk(batch = false) {
3032       const length = textContent.items.length;
3033       if (length === 0) {
3034         return;
3035       }
3036       if (batch && length < TEXT_CHUNK_BATCH_SIZE) {
3037         return;
3038       }
3039       sink.enqueue(textContent, length);
3040       textContent.items = [];
3041       textContent.styles = Object.create(null);
3042     }
3043 
3044     const timeSlotManager = new TimeSlotManager();
3045 
3046     return new Promise(function promiseBody(resolve, reject) {
3047       const next = function (promise) {
3048         enqueueChunk(/* batch = */ true);
3049         Promise.all([promise, sink.ready]).then(function () {
3050           try {
3051             promiseBody(resolve, reject);
3052           } catch (ex) {
3053             reject(ex);
3054           }
3055         }, reject);
3056       };
3057       task.ensureNotTerminated();
3058       timeSlotManager.reset();
3059 
3060       const operation = {};
3061       let stop,
3062         name,
3063         isValidName,
3064         args = [];
3065       while (!(stop = timeSlotManager.check())) {
3066         // The arguments parsed by read() are not used beyond this loop, so
3067         // we can reuse the same array on every iteration, thus avoiding
3068         // unnecessary allocations.
3069         args.length = 0;
3070         operation.args = args;
3071         if (!preprocessor.read(operation)) {
3072           break;
3073         }
3074 
3075         const previousState = textState;
3076         textState = stateManager.state;
3077         const fn = operation.fn;
3078         args = operation.args;
3079 
3080         switch (fn | 0) {
3081           case OPS.setFont:
3082             // Optimization to ignore multiple identical Tf commands.
3083             const fontNameArg = args[0].name,
3084               fontSizeArg = args[1];
3085             if (
3086               textState.font &&
3087               fontNameArg === textState.fontName &&
3088               fontSizeArg === textState.fontSize
3089             ) {
3090               break;
3091             }
3092 
3093             flushTextContentItem();
3094             textState.fontName = fontNameArg;
3095             textState.fontSize = fontSizeArg;
3096             next(handleSetFont(fontNameArg, null));
3097             return;
3098           case OPS.setTextRise:
3099             textState.textRise = args[0];
3100             break;
3101           case OPS.setHScale:
3102             textState.textHScale = args[0] / 100;
3103             break;
3104           case OPS.setLeading:
3105             textState.leading = args[0];
3106             break;
3107           case OPS.moveText:
3108             textState.translateTextLineMatrix(args[0], args[1]);
3109             textState.textMatrix = textState.textLineMatrix.slice();
3110             break;
3111           case OPS.setLeadingMoveText:
3112             textState.leading = -args[1];
3113             textState.translateTextLineMatrix(args[0], args[1]);
3114             textState.textMatrix = textState.textLineMatrix.slice();
3115             break;
3116           case OPS.nextLine:
3117             textState.carriageReturn();
3118             break;
3119           case OPS.setTextMatrix:
3120             textState.setTextMatrix(
3121               args[0],
3122               args[1],
3123               args[2],
3124               args[3],
3125               args[4],
3126               args[5]
3127             );
3128             textState.setTextLineMatrix(
3129               args[0],
3130               args[1],
3131               args[2],
3132               args[3],
3133               args[4],
3134               args[5]
3135             );
3136             updateAdvanceScale();
3137             break;
3138           case OPS.setCharSpacing:
3139             textState.charSpacing = args[0];
3140             break;
3141           case OPS.setWordSpacing:
3142             textState.wordSpacing = args[0];
3143             break;
3144           case OPS.beginText:
3145             textState.textMatrix = IDENTITY_MATRIX.slice();
3146             textState.textLineMatrix = IDENTITY_MATRIX.slice();
3147             break;
3148           case OPS.showSpacedText:
3149             if (!stateManager.state.font) {
3150               self.ensureStateFont(stateManager.state);
3151               continue;
3152             }
3153 
3154             const spaceFactor =
3155               ((textState.font.vertical ? 1 : -1) * textState.fontSize) / 1000;
3156             const elements = args[0];
3157             for (let i = 0, ii = elements.length; i < ii; i++) {
3158               const item = elements[i];
3159               if (typeof item === "string") {
3160                 showSpacedTextBuffer.push(item);
3161               } else if (typeof item === "number" && item !== 0) {
3162                 // PDF Specification 5.3.2 states:
3163                 // The number is expressed in thousandths of a unit of text
3164                 // space.
3165                 // This amount is subtracted from the current horizontal or
3166                 // vertical coordinate, depending on the writing mode.
3167                 // In the default coordinate system, a positive adjustment
3168                 // has the effect of moving the next glyph painted either to
3169                 // the left or down by the given amount.
3170                 const str = showSpacedTextBuffer.join("");
3171                 showSpacedTextBuffer.length = 0;
3172                 buildTextContentItem({
3173                   chars: str,
3174                   extraSpacing: item * spaceFactor,
3175                 });
3176               }
3177             }
3178 
3179             if (showSpacedTextBuffer.length > 0) {
3180               const str = showSpacedTextBuffer.join("");
3181               showSpacedTextBuffer.length = 0;
3182               buildTextContentItem({
3183                 chars: str,
3184                 extraSpacing: 0,
3185               });
3186             }
3187             break;
3188           case OPS.showText:
3189             if (!stateManager.state.font) {
3190               self.ensureStateFont(stateManager.state);
3191               continue;
3192             }
3193             buildTextContentItem({
3194               chars: args[0],
3195               extraSpacing: 0,
3196             });
3197             break;
3198           case OPS.nextLineShowText:
3199             if (!stateManager.state.font) {
3200               self.ensureStateFont(stateManager.state);
3201               continue;
3202             }
3203             textState.carriageReturn();
3204             buildTextContentItem({
3205               chars: args[0],
3206               extraSpacing: 0,
3207             });
3208             break;
3209           case OPS.nextLineSetSpacingShowText:
3210             if (!stateManager.state.font) {
3211               self.ensureStateFont(stateManager.state);
3212               continue;
3213             }
3214             textState.wordSpacing = args[0];
3215             textState.charSpacing = args[1];
3216             textState.carriageReturn();
3217             buildTextContentItem({
3218               chars: args[2],
3219               extraSpacing: 0,
3220             });
3221             break;
3222           case OPS.paintXObject:
3223             flushTextContentItem();
3224             xobjs ??= resources.get("XObject") || Dict.empty;
3225 
3226             isValidName = args[0] instanceof Name;
3227             name = args[0].name;
3228 
3229             if (isValidName && emptyXObjectCache.getByName(name)) {
3230               break;
3231             }
3232 
3233             next(
3234               new Promise(function (resolveXObject, rejectXObject) {
3235                 if (!isValidName) {
3236                   throw new FormatError("XObject must be referred to by name.");
3237                 }
3238 
3239                 let xobj = xobjs.getRaw(name);
3240                 if (xobj instanceof Ref) {
3241                   if (emptyXObjectCache.getByRef(xobj)) {
3242                     resolveXObject();
3243                     return;
3244                   }
3245 
3246                   const globalImage = self.globalImageCache.getData(
3247                     xobj,
3248                     self.pageIndex
3249                   );
3250                   if (globalImage) {
3251                     resolveXObject();
3252                     return;
3253                   }
3254 
3255                   xobj = xref.fetch(xobj);
3256                 }
3257 
3258                 if (!(xobj instanceof BaseStream)) {
3259                   throw new FormatError("XObject should be a stream");
3260                 }
3261 
3262                 const type = xobj.dict.get("Subtype");
3263                 if (!(type instanceof Name)) {
3264                   throw new FormatError("XObject should have a Name subtype");
3265                 }
3266 
3267                 if (type.name !== "Form") {
3268                   emptyXObjectCache.set(name, xobj.dict.objId, true);
3269 
3270                   resolveXObject();
3271                   return;
3272                 }
3273 
3274                 // Use a new `StateManager` to prevent incorrect positioning
3275                 // of textItems *after* the Form XObject, since errors in the
3276                 // data can otherwise prevent `restore` operators from
3277                 // executing.
3278                 // NOTE: Only an issue when `options.ignoreErrors === true`.
3279                 const currentState = stateManager.state.clone();
3280                 const xObjStateManager = new StateManager(currentState);
3281 
3282                 const matrix = lookupMatrix(xobj.dict.getArray("Matrix"), null);
3283                 if (matrix) {
3284                   xObjStateManager.transform(matrix);
3285                 }
3286 
3287                 // Enqueue the `textContent` chunk before parsing the /Form
3288                 // XObject.
3289                 enqueueChunk();
3290                 const sinkWrapper = {
3291                   enqueueInvoked: false,
3292 
3293                   enqueue(chunk, size) {
3294                     this.enqueueInvoked = true;
3295                     sink.enqueue(chunk, size);
3296                   },
3297 
3298                   get desiredSize() {
3299                     return sink.desiredSize;
3300                   },
3301 
3302                   get ready() {
3303                     return sink.ready;
3304                   },
3305                 };
3306 
3307                 self
3308                   .getTextContent({
3309                     stream: xobj,
3310                     task,
3311                     resources: xobj.dict.get("Resources") || resources,
3312                     stateManager: xObjStateManager,
3313                     includeMarkedContent,
3314                     sink: sinkWrapper,
3315                     seenStyles,
3316                     viewBox,
3317                     lang,
3318                     markedContentData,
3319                     disableNormalization,
3320                     keepWhiteSpace,
3321                   })
3322                   .then(function () {
3323                     if (!sinkWrapper.enqueueInvoked) {
3324                       emptyXObjectCache.set(name, xobj.dict.objId, true);
3325                     }
3326                     resolveXObject();
3327                   }, rejectXObject);
3328               }).catch(function (reason) {
3329                 if (reason instanceof AbortException) {
3330                   return;
3331                 }
3332                 if (self.options.ignoreErrors) {
3333                   // Error(s) in the XObject -- allow text-extraction to
3334                   // continue.
3335                   warn(`getTextContent - ignoring XObject: "${reason}".`);
3336                   return;
3337                 }
3338                 throw reason;
3339               })
3340             );
3341             return;
3342           case OPS.setGState:
3343             isValidName = args[0] instanceof Name;
3344             name = args[0].name;
3345 
3346             if (isValidName && emptyGStateCache.getByName(name)) {
3347               break;
3348             }
3349 
3350             next(
3351               new Promise(function (resolveGState, rejectGState) {
3352                 if (!isValidName) {
3353                   throw new FormatError("GState must be referred to by name.");
3354                 }
3355 
3356                 const extGState = resources.get("ExtGState");
3357                 if (!(extGState instanceof Dict)) {
3358                   throw new FormatError("ExtGState should be a dictionary.");
3359                 }
3360 
3361                 const gState = extGState.get(name);
3362                 // TODO: Attempt to lookup cached GStates by reference as well,
3363                 //       if and only if there are PDF documents where doing so
3364                 //       would significantly improve performance.
3365                 if (!(gState instanceof Dict)) {
3366                   throw new FormatError("GState should be a dictionary.");
3367                 }
3368 
3369                 const gStateFont = gState.get("Font");
3370                 if (!gStateFont) {
3371                   emptyGStateCache.set(name, gState.objId, true);
3372 
3373                   resolveGState();
3374                   return;
3375                 }
3376                 flushTextContentItem();
3377 
3378                 textState.fontName = null;
3379                 textState.fontSize = gStateFont[1];
3380                 handleSetFont(null, gStateFont[0]).then(
3381                   resolveGState,
3382                   rejectGState
3383                 );
3384               }).catch(function (reason) {
3385                 if (reason instanceof AbortException) {
3386                   return;
3387                 }
3388                 if (self.options.ignoreErrors) {
3389                   // Error(s) in the ExtGState -- allow text-extraction to
3390                   // continue.
3391                   warn(`getTextContent - ignoring ExtGState: "${reason}".`);
3392                   return;
3393                 }
3394                 throw reason;
3395               })
3396             );
3397             return;
3398           case OPS.beginMarkedContent:
3399             flushTextContentItem();
3400             if (includeMarkedContent) {
3401               markedContentData.level++;
3402 
3403               textContent.items.push({
3404                 type: "beginMarkedContent",
3405                 tag: args[0] instanceof Name ? args[0].name : null,
3406               });
3407             }
3408             break;
3409           case OPS.beginMarkedContentProps:
3410             flushTextContentItem();
3411             if (includeMarkedContent) {
3412               markedContentData.level++;
3413 
3414               let mcid = null;
3415               if (args[1] instanceof Dict) {
3416                 mcid = args[1].get("MCID");
3417               }
3418               textContent.items.push({
3419                 type: "beginMarkedContentProps",
3420                 id: Number.isInteger(mcid)
3421                   ? `${self.idFactory.getPageObjId()}_mc${mcid}`
3422                   : null,
3423                 tag: args[0] instanceof Name ? args[0].name : null,
3424               });
3425             }
3426             break;
3427           case OPS.endMarkedContent:
3428             flushTextContentItem();
3429             if (includeMarkedContent) {
3430               if (markedContentData.level === 0) {
3431                 // Handle unbalanced beginMarkedContent/endMarkedContent
3432                 // operators (fixes issue15629.pdf).
3433                 break;
3434               }
3435               markedContentData.level--;
3436 
3437               textContent.items.push({
3438                 type: "endMarkedContent",
3439               });
3440             }
3441             break;
3442           case OPS.restore:
3443             if (
3444               previousState &&
3445               (previousState.font !== textState.font ||
3446                 previousState.fontSize !== textState.fontSize ||
3447                 previousState.fontName !== textState.fontName)
3448             ) {
3449               flushTextContentItem();
3450             }
3451             break;
3452         } // switch
3453         if (textContent.items.length >= sink.desiredSize) {
3454           // Wait for ready, if we reach highWaterMark.
3455           stop = true;
3456           break;
3457         }
3458       } // while
3459       if (stop) {
3460         next(deferred);
3461         return;
3462       }
3463       flushTextContentItem();
3464       enqueueChunk();
3465       resolve();
3466     }).catch(reason => {
3467       if (reason instanceof AbortException) {
3468         return;
3469       }
3470       if (this.options.ignoreErrors) {
3471         // Error(s) in the TextContent -- allow text-extraction to continue.
3472         warn(
3473           `getTextContent - ignoring errors during "${task.name}" ` +
3474             `task: "${reason}".`
3475         );
3476 
3477         flushTextContentItem();
3478         enqueueChunk();
3479         return;
3480       }
3481       throw reason;
3482     });
3483   }
3484 
3485   async extractDataStructures(dict, properties) {
3486     const xref = this.xref;
3487     let cidToGidBytes;
3488     // 9.10.2
3489     const toUnicodePromise = this.readToUnicode(properties.toUnicode);
3490 
3491     if (properties.composite) {
3492       // CIDSystemInfo helps to match CID to glyphs
3493       const cidSystemInfo = dict.get("CIDSystemInfo");
3494       if (cidSystemInfo instanceof Dict) {
3495         properties.cidSystemInfo = {
3496           registry: stringToPDFString(cidSystemInfo.get("Registry")),
3497           ordering: stringToPDFString(cidSystemInfo.get("Ordering")),
3498           supplement: cidSystemInfo.get("Supplement"),
3499         };
3500       }
3501 
3502       try {
3503         const cidToGidMap = dict.get("CIDToGIDMap");
3504         if (cidToGidMap instanceof BaseStream) {
3505           cidToGidBytes = cidToGidMap.getBytes();
3506         }
3507       } catch (ex) {
3508         if (!this.options.ignoreErrors) {
3509           throw ex;
3510         }
3511         warn(`extractDataStructures - ignoring CIDToGIDMap data: "${ex}".`);
3512       }
3513     }
3514 
3515     // Based on 9.6.6 of the spec the encoding can come from multiple places
3516     // and depends on the font type. The base encoding and differences are
3517     // read here, but the encoding that is actually used is chosen during
3518     // glyph mapping in the font.
3519     // TODO: Loading the built in encoding in the font would allow the
3520     // differences to be merged in here not require us to hold on to it.
3521     const differences = [];
3522     let baseEncodingName = null;
3523     let encoding;
3524     if (dict.has("Encoding")) {
3525       encoding = dict.get("Encoding");
3526       if (encoding instanceof Dict) {
3527         baseEncodingName = encoding.get("BaseEncoding");
3528         baseEncodingName =
3529           baseEncodingName instanceof Name ? baseEncodingName.name : null;
3530         // Load the differences between the base and original
3531         if (encoding.has("Differences")) {
3532           const diffEncoding = encoding.get("Differences");
3533           let index = 0;
3534           for (const entry of diffEncoding) {
3535             const data = xref.fetchIfRef(entry);
3536             if (typeof data === "number") {
3537               index = data;
3538             } else if (data instanceof Name) {
3539               differences[index++] = data.name;
3540             } else {
3541               throw new FormatError(
3542                 `Invalid entry in 'Differences' array: ${data}`
3543               );
3544             }
3545           }
3546         }
3547       } else if (encoding instanceof Name) {
3548         baseEncodingName = encoding.name;
3549       } else {
3550         const msg = "Encoding is not a Name nor a Dict";
3551 
3552         if (!this.options.ignoreErrors) {
3553           throw new FormatError(msg);
3554         }
3555         warn(msg);
3556       }
3557       // According to table 114 if the encoding is a named encoding it must be
3558       // one of these predefined encodings.
3559       if (
3560         baseEncodingName !== "MacRomanEncoding" &&
3561         baseEncodingName !== "MacExpertEncoding" &&
3562         baseEncodingName !== "WinAnsiEncoding"
3563       ) {
3564         baseEncodingName = null;
3565       }
3566     }
3567 
3568     const nonEmbeddedFont = !properties.file || properties.isInternalFont,
3569       isSymbolsFontName = getSymbolsFonts()[properties.name];
3570     // Ignore an incorrectly specified named encoding for non-embedded
3571     // symbol fonts (fixes issue16464.pdf).
3572     if (baseEncodingName && nonEmbeddedFont && isSymbolsFontName) {
3573       baseEncodingName = null;
3574     }
3575 
3576     if (baseEncodingName) {
3577       properties.defaultEncoding = getEncoding(baseEncodingName);
3578     } else {
3579       const isSymbolicFont = !!(properties.flags & FontFlags.Symbolic);
3580       const isNonsymbolicFont = !!(properties.flags & FontFlags.Nonsymbolic);
3581       // According to "Table 114" in section "9.6.6.1 General" (under
3582       // "9.6.6 Character Encoding") of the PDF specification, a Nonsymbolic
3583       // font should use the `StandardEncoding` if no encoding is specified.
3584       encoding = StandardEncoding;
3585       if (properties.type === "TrueType" && !isNonsymbolicFont) {
3586         encoding = WinAnsiEncoding;
3587       }
3588       // The Symbolic attribute can be misused for regular fonts
3589       // Heuristic: we have to check if the font is a standard one also
3590       if (isSymbolicFont || isSymbolsFontName) {
3591         encoding = MacRomanEncoding;
3592         if (nonEmbeddedFont) {
3593           if (/Symbol/i.test(properties.name)) {
3594             encoding = SymbolSetEncoding;
3595           } else if (/Dingbats/i.test(properties.name)) {
3596             encoding = ZapfDingbatsEncoding;
3597           } else if (/Wingdings/i.test(properties.name)) {
3598             encoding = WinAnsiEncoding;
3599           }
3600         }
3601       }
3602       properties.defaultEncoding = encoding;
3603     }
3604 
3605     properties.differences = differences;
3606     properties.baseEncodingName = baseEncodingName;
3607     properties.hasEncoding = !!baseEncodingName || differences.length > 0;
3608     properties.dict = dict;
3609 
3610     properties.toUnicode = await toUnicodePromise;
3611 
3612     const builtToUnicode = await this.buildToUnicode(properties);
3613     properties.toUnicode = builtToUnicode;
3614 
3615     if (cidToGidBytes) {
3616       properties.cidToGidMap = this.readCidToGidMap(
3617         cidToGidBytes,
3618         builtToUnicode
3619       );
3620     }
3621     return properties;
3622   }
3623 
3624   /**
3625    * @returns {Array}
3626    * @private
3627    */
3628   _simpleFontToUnicode(properties, forceGlyphs = false) {
3629     assert(!properties.composite, "Must be a simple font.");
3630 
3631     const toUnicode = [];
3632     const encoding = properties.defaultEncoding.slice();
3633     const baseEncodingName = properties.baseEncodingName;
3634     // Merge in the differences array.
3635     const differences = properties.differences;
3636     for (const charcode in differences) {
3637       const glyphName = differences[charcode];
3638       if (glyphName === ".notdef") {
3639         // Skip .notdef to prevent rendering errors, e.g. boxes appearing
3640         // where there should be spaces (fixes issue5256.pdf).
3641         continue;
3642       }
3643       encoding[charcode] = glyphName;
3644     }
3645     const glyphsUnicodeMap = getGlyphsUnicode();
3646     for (const charcode in encoding) {
3647       // a) Map the character code to a character name.
3648       let glyphName = encoding[charcode];
3649       if (glyphName === "") {
3650         continue;
3651       }
3652       // b) Look up the character name in the Adobe Glyph List (see the
3653       //    Bibliography) to obtain the corresponding Unicode value.
3654       let unicode = glyphsUnicodeMap[glyphName];
3655       if (unicode !== undefined) {
3656         toUnicode[charcode] = String.fromCharCode(unicode);
3657         continue;
3658       }
3659       // (undocumented) c) Few heuristics to recognize unknown glyphs
3660       // NOTE: Adobe Reader does not do this step, but OSX Preview does
3661       let code = 0;
3662       switch (glyphName[0]) {
3663         case "G": // Gxx glyph
3664           if (glyphName.length === 3) {
3665             code = parseInt(glyphName.substring(1), 16);
3666           }
3667           break;
3668         case "g": // g00xx glyph
3669           if (glyphName.length === 5) {
3670             code = parseInt(glyphName.substring(1), 16);
3671           }
3672           break;
3673         case "C": // Cdd{d} glyph
3674         case "c": // cdd{d} glyph
3675           if (glyphName.length >= 3 && glyphName.length <= 4) {
3676             const codeStr = glyphName.substring(1);
3677 
3678             if (forceGlyphs) {
3679               code = parseInt(codeStr, 16);
3680               break;
3681             }
3682             // Normally the Cdd{d}/cdd{d} glyphName format will contain
3683             // regular, i.e. base 10, charCodes (see issue4550.pdf)...
3684             code = +codeStr;
3685 
3686             // ... however some PDF generators violate that assumption by
3687             // containing glyph, i.e. base 16, codes instead.
3688             // In that case we need to re-parse the *entire* encoding to
3689             // prevent broken text-selection (fixes issue9655_reduced.pdf).
3690             if (Number.isNaN(code) && Number.isInteger(parseInt(codeStr, 16))) {
3691               return this._simpleFontToUnicode(
3692                 properties,
3693                 /* forceGlyphs */ true
3694               );
3695             }
3696           }
3697           break;
3698         case "u": // 'uniXXXX'/'uXXXX{XX}' glyphs
3699           unicode = getUnicodeForGlyph(glyphName, glyphsUnicodeMap);
3700           if (unicode !== -1) {
3701             code = unicode;
3702           }
3703           break;
3704         default:
3705           // Support (some) non-standard ligatures.
3706           switch (glyphName) {
3707             case "f_h":
3708             case "f_t":
3709             case "T_h":
3710               toUnicode[charcode] = glyphName.replaceAll("_", "");
3711               continue;
3712           }
3713           break;
3714       }
3715       if (code > 0 && code <= 0x10ffff && Number.isInteger(code)) {
3716         // If `baseEncodingName` is one the predefined encodings, and `code`
3717         // equals `charcode`, using the glyph defined in the baseEncoding
3718         // seems to yield a better `toUnicode` mapping (fixes issue 5070).
3719         if (baseEncodingName && code === +charcode) {
3720           const baseEncoding = getEncoding(baseEncodingName);
3721           if (baseEncoding && (glyphName = baseEncoding[charcode])) {
3722             toUnicode[charcode] = String.fromCharCode(
3723               glyphsUnicodeMap[glyphName]
3724             );
3725             continue;
3726           }
3727         }
3728         toUnicode[charcode] = String.fromCodePoint(code);
3729       }
3730     }
3731     return toUnicode;
3732   }
3733 
3734   /**
3735    * Builds a char code to unicode map based on section 9.10 of the spec.
3736    * @param {Object} properties Font properties object.
3737    * @returns {Promise} A Promise that is resolved with a
3738    *   {ToUnicodeMap|IdentityToUnicodeMap} object.
3739    */
3740   async buildToUnicode(properties) {
3741     properties.hasIncludedToUnicodeMap = properties.toUnicode?.length > 0;
3742 
3743     // Section 9.10.2 Mapping Character Codes to Unicode Values
3744     if (properties.hasIncludedToUnicodeMap) {
3745       // Some fonts contain incomplete ToUnicode data, causing issues with
3746       // text-extraction. For simple fonts, containing encoding information,
3747       // use a fallback ToUnicode map to improve this (fixes issue8229.pdf).
3748       if (!properties.composite && properties.hasEncoding) {
3749         properties.fallbackToUnicode = this._simpleFontToUnicode(properties);
3750       }
3751       return properties.toUnicode;
3752     }
3753 
3754     // According to the spec if the font is a simple font we should only map
3755     // to unicode if the base encoding is MacRoman, MacExpert, or WinAnsi or
3756     // the differences array only contains adobe standard or symbol set names,
3757     // in pratice it seems better to always try to create a toUnicode map
3758     // based of the default encoding.
3759     if (!properties.composite /* is simple font */) {
3760       return new ToUnicodeMap(this._simpleFontToUnicode(properties));
3761     }
3762 
3763     // If the font is a composite font that uses one of the predefined CMaps
3764     // listed in Table 118 (except Identity–H and Identity–V) or whose
3765     // descendant CIDFont uses the Adobe-GB1, Adobe-CNS1, Adobe-Japan1, or
3766     // Adobe-Korea1 character collection:
3767     if (
3768       properties.composite &&
3769       ((properties.cMap.builtInCMap &&
3770         !(properties.cMap instanceof IdentityCMap)) ||
3771         // The font is supposed to have a CIDSystemInfo dictionary, but some
3772         // PDFs don't include it (fixes issue 17689), hence the `?'.
3773         (properties.cidSystemInfo?.registry === "Adobe" &&
3774           (properties.cidSystemInfo.ordering === "GB1" ||
3775             properties.cidSystemInfo.ordering === "CNS1" ||
3776             properties.cidSystemInfo.ordering === "Japan1" ||
3777             properties.cidSystemInfo.ordering === "Korea1")))
3778     ) {
3779       // Then:
3780       // a) Map the character code to a character identifier (CID) according
3781       // to the font’s CMap.
3782       // b) Obtain the registry and ordering of the character collection used
3783       // by the font’s CMap (for example, Adobe and Japan1) from its
3784       // CIDSystemInfo dictionary.
3785       const { registry, ordering } = properties.cidSystemInfo;
3786       // c) Construct a second CMap name by concatenating the registry and
3787       // ordering obtained in step (b) in the format registry–ordering–UCS2
3788       // (for example, Adobe–Japan1–UCS2).
3789       const ucs2CMapName = Name.get(`${registry}-${ordering}-UCS2`);
3790       // d) Obtain the CMap with the name constructed in step (c) (available
3791       // from the ASN Web site; see the Bibliography).
3792       const ucs2CMap = await CMapFactory.create({
3793         encoding: ucs2CMapName,
3794         fetchBuiltInCMap: this._fetchBuiltInCMapBound,
3795         useCMap: null,
3796       });
3797       const toUnicode = [],
3798         buf = [];
3799       properties.cMap.forEach(function (charcode, cid) {
3800         if (cid > 0xffff) {
3801           throw new FormatError("Max size of CID is 65,535");
3802         }
3803         // e) Map the CID obtained in step (a) according to the CMap
3804         // obtained in step (d), producing a Unicode value.
3805         const ucs2 = ucs2CMap.lookup(cid);
3806         if (ucs2) {
3807           buf.length = 0;
3808           // Support multi-byte entries (fixes issue16176.pdf).
3809           for (let i = 0, ii = ucs2.length; i < ii; i += 2) {
3810             buf.push((ucs2.charCodeAt(i) << 8) + ucs2.charCodeAt(i + 1));
3811           }
3812           toUnicode[charcode] = String.fromCharCode(...buf);
3813         }
3814       });
3815       return new ToUnicodeMap(toUnicode);
3816     }
3817 
3818     // The viewer's choice, just use an identity map.
3819     return new IdentityToUnicodeMap(properties.firstChar, properties.lastChar);
3820   }
3821 
3822   async readToUnicode(cmapObj) {
3823     if (!cmapObj) {
3824       return null;
3825     }
3826     if (cmapObj instanceof Name) {
3827       const cmap = await CMapFactory.create({
3828         encoding: cmapObj,
3829         fetchBuiltInCMap: this._fetchBuiltInCMapBound,
3830         useCMap: null,
3831       });
3832 
3833       if (cmap instanceof IdentityCMap) {
3834         return new IdentityToUnicodeMap(0, 0xffff);
3835       }
3836       return new ToUnicodeMap(cmap.getMap());
3837     }
3838     if (cmapObj instanceof BaseStream) {
3839       try {
3840         const cmap = await CMapFactory.create({
3841           encoding: cmapObj,
3842           fetchBuiltInCMap: this._fetchBuiltInCMapBound,
3843           useCMap: null,
3844         });
3845 
3846         if (cmap instanceof IdentityCMap) {
3847           return new IdentityToUnicodeMap(0, 0xffff);
3848         }
3849         const map = new Array(cmap.length);
3850         // Convert UTF-16BE
3851         // NOTE: cmap can be a sparse array, so use forEach instead of
3852         // `for(;;)` to iterate over all keys.
3853         cmap.forEach(function (charCode, token) {
3854           // Some cmaps contain *only* CID characters (fixes issue9367.pdf).
3855           if (typeof token === "number") {
3856             map[charCode] = String.fromCodePoint(token);
3857             return;
3858           }
3859           // Add back omitted leading zeros on odd length tokens
3860           // (fixes issue #18099)
3861           if (token.length % 2 !== 0) {
3862             token = "\u0000" + token;
3863           }
3864           const str = [];
3865           for (let k = 0; k < token.length; k += 2) {
3866             const w1 = (token.charCodeAt(k) << 8) | token.charCodeAt(k + 1);
3867             if ((w1 & 0xf800) !== 0xd800) {
3868               // w1 < 0xD800 || w1 > 0xDFFF
3869               str.push(w1);
3870               continue;
3871             }
3872             k += 2;
3873             const w2 = (token.charCodeAt(k) << 8) | token.charCodeAt(k + 1);
3874             str.push(((w1 & 0x3ff) << 10) + (w2 & 0x3ff) + 0x10000);
3875           }
3876           map[charCode] = String.fromCodePoint(...str);
3877         });
3878         return new ToUnicodeMap(map);
3879       } catch (reason) {
3880         if (reason instanceof AbortException) {
3881           return null;
3882         }
3883         if (this.options.ignoreErrors) {
3884           warn(`readToUnicode - ignoring ToUnicode data: "${reason}".`);
3885           return null;
3886         }
3887         throw reason;
3888       }
3889     }
3890     return null;
3891   }
3892 
3893   readCidToGidMap(glyphsData, toUnicode) {
3894     // Extract the encoding from the CIDToGIDMap
3895 
3896     // Set encoding 0 to later verify the font has an encoding
3897     const result = [];
3898     for (let j = 0, jj = glyphsData.length; j < jj; j++) {
3899       const glyphID = (glyphsData[j++] << 8) | glyphsData[j];
3900       const code = j >> 1;
3901       if (glyphID === 0 && !toUnicode.has(code)) {
3902         continue;
3903       }
3904       result[code] = glyphID;
3905     }
3906     return result;
3907   }
3908 
3909   extractWidths(dict, descriptor, properties) {
3910     const xref = this.xref;
3911     let glyphsWidths = [];
3912     let defaultWidth = 0;
3913     const glyphsVMetrics = [];
3914     let defaultVMetrics;
3915     if (properties.composite) {
3916       const dw = dict.get("DW");
3917       defaultWidth = typeof dw === "number" ? Math.ceil(dw) : 1000;
3918 
3919       const widths = dict.get("W");
3920       if (Array.isArray(widths)) {
3921         for (let i = 0, ii = widths.length; i < ii; i++) {
3922           let start = xref.fetchIfRef(widths[i++]);
3923           if (!Number.isInteger(start)) {
3924             break; // Invalid /W data.
3925           }
3926           const code = xref.fetchIfRef(widths[i]);
3927 
3928           if (Array.isArray(code)) {
3929             for (const c of code) {
3930               const width = xref.fetchIfRef(c);
3931               if (typeof width === "number") {
3932                 glyphsWidths[start] = width;
3933               }
3934               start++;
3935             }
3936           } else if (Number.isInteger(code)) {
3937             const width = xref.fetchIfRef(widths[++i]);
3938             if (typeof width !== "number") {
3939               continue;
3940             }
3941             for (let j = start; j <= code; j++) {
3942               glyphsWidths[j] = width;
3943             }
3944           } else {
3945             break; // Invalid /W data.
3946           }
3947         }
3948       }
3949 
3950       if (properties.vertical) {
3951         const dw2 = dict.getArray("DW2");
3952         let vmetrics = isNumberArray(dw2, 2) ? dw2 : [880, -1000];
3953         defaultVMetrics = [vmetrics[1], defaultWidth * 0.5, vmetrics[0]];
3954         vmetrics = dict.get("W2");
3955         if (Array.isArray(vmetrics)) {
3956           for (let i = 0, ii = vmetrics.length; i < ii; i++) {
3957             let start = xref.fetchIfRef(vmetrics[i++]);
3958             if (!Number.isInteger(start)) {
3959               break; // Invalid /W2 data.
3960             }
3961             const code = xref.fetchIfRef(vmetrics[i]);
3962 
3963             if (Array.isArray(code)) {
3964               for (let j = 0, jj = code.length; j < jj; j++) {
3965                 const vmetric = [
3966                   xref.fetchIfRef(code[j++]),
3967                   xref.fetchIfRef(code[j++]),
3968                   xref.fetchIfRef(code[j]),
3969                 ];
3970                 if (isNumberArray(vmetric, null)) {
3971                   glyphsVMetrics[start] = vmetric;
3972                 }
3973                 start++;
3974               }
3975             } else if (Number.isInteger(code)) {
3976               const vmetric = [
3977                 xref.fetchIfRef(vmetrics[++i]),
3978                 xref.fetchIfRef(vmetrics[++i]),
3979                 xref.fetchIfRef(vmetrics[++i]),
3980               ];
3981               if (!isNumberArray(vmetric, null)) {
3982                 continue;
3983               }
3984               for (let j = start; j <= code; j++) {
3985                 glyphsVMetrics[j] = vmetric;
3986               }
3987             } else {
3988               break; // Invalid /W2 data.
3989             }
3990           }
3991         }
3992       }
3993     } else {
3994       const widths = dict.get("Widths");
3995       if (Array.isArray(widths)) {
3996         let j = properties.firstChar;
3997         for (const w of widths) {
3998           const width = xref.fetchIfRef(w);
3999           if (typeof width === "number") {
4000             glyphsWidths[j] = width;
4001           }
4002           j++;
4003         }
4004         const missingWidth = descriptor.get("MissingWidth");
4005         defaultWidth = typeof missingWidth === "number" ? missingWidth : 0;
4006       } else {
4007         // Trying get the BaseFont metrics (see comment above).
4008         const baseFontName = dict.get("BaseFont");
4009         if (baseFontName instanceof Name) {
4010           const metrics = this.getBaseFontMetrics(baseFontName.name);
4011 
4012           glyphsWidths = this.buildCharCodeToWidth(metrics.widths, properties);
4013           defaultWidth = metrics.defaultWidth;
4014         }
4015       }
4016     }
4017 
4018     // Heuristic: detection of monospace font by checking all non-zero widths
4019     let isMonospace = true;
4020     let firstWidth = defaultWidth;
4021     for (const glyph in glyphsWidths) {
4022       const glyphWidth = glyphsWidths[glyph];
4023       if (!glyphWidth) {
4024         continue;
4025       }
4026       if (!firstWidth) {
4027         firstWidth = glyphWidth;
4028         continue;
4029       }
4030       if (firstWidth !== glyphWidth) {
4031         isMonospace = false;
4032         break;
4033       }
4034     }
4035     if (isMonospace) {
4036       properties.flags |= FontFlags.FixedPitch;
4037     } else {
4038       // Clear the flag.
4039       properties.flags &= ~FontFlags.FixedPitch;
4040     }
4041 
4042     properties.defaultWidth = defaultWidth;
4043     properties.widths = glyphsWidths;
4044     properties.defaultVMetrics = defaultVMetrics;
4045     properties.vmetrics = glyphsVMetrics;
4046   }
4047 
4048   isSerifFont(baseFontName) {
4049     // Simulating descriptor flags attribute
4050     const fontNameWoStyle = baseFontName.split("-", 1)[0];
4051     return (
4052       fontNameWoStyle in getSerifFonts() || /serif/gi.test(fontNameWoStyle)
4053     );
4054   }
4055 
4056   getBaseFontMetrics(name) {
4057     let defaultWidth = 0;
4058     let widths = Object.create(null);
4059     let monospace = false;
4060     const stdFontMap = getStdFontMap();
4061     let lookupName = stdFontMap[name] || name;
4062     const Metrics = getMetrics();
4063 
4064     if (!(lookupName in Metrics)) {
4065       // Use default fonts for looking up font metrics if the passed
4066       // font is not a base font
4067       lookupName = this.isSerifFont(name) ? "Times-Roman" : "Helvetica";
4068     }
4069     const glyphWidths = Metrics[lookupName];
4070 
4071     if (typeof glyphWidths === "number") {
4072       defaultWidth = glyphWidths;
4073       monospace = true;
4074     } else {
4075       widths = glyphWidths(); // expand lazy widths array
4076     }
4077 
4078     return {
4079       defaultWidth,
4080       monospace,
4081       widths,
4082     };
4083   }
4084 
4085   buildCharCodeToWidth(widthsByGlyphName, properties) {
4086     const widths = Object.create(null);
4087     const differences = properties.differences;
4088     const encoding = properties.defaultEncoding;
4089     for (let charCode = 0; charCode < 256; charCode++) {
4090       if (charCode in differences && widthsByGlyphName[differences[charCode]]) {
4091         widths[charCode] = widthsByGlyphName[differences[charCode]];
4092         continue;
4093       }
4094       if (charCode in encoding && widthsByGlyphName[encoding[charCode]]) {
4095         widths[charCode] = widthsByGlyphName[encoding[charCode]];
4096         continue;
4097       }
4098     }
4099     return widths;
4100   }
4101 
4102   preEvaluateFont(dict) {
4103     const baseDict = dict;
4104     let type = dict.get("Subtype");
4105     if (!(type instanceof Name)) {
4106       throw new FormatError("invalid font Subtype");
4107     }
4108 
4109     let composite = false;
4110     let hash;
4111     if (type.name === "Type0") {
4112       // If font is a composite
4113       //  - get the descendant font
4114       //  - set the type according to the descendant font
4115       //  - get the FontDescriptor from the descendant font
4116       const df = dict.get("DescendantFonts");
4117       if (!df) {
4118         throw new FormatError("Descendant fonts are not specified");
4119       }
4120       dict = Array.isArray(df) ? this.xref.fetchIfRef(df[0]) : df;
4121 
4122       if (!(dict instanceof Dict)) {
4123         throw new FormatError("Descendant font is not a dictionary.");
4124       }
4125       type = dict.get("Subtype");
4126       if (!(type instanceof Name)) {
4127         throw new FormatError("invalid font Subtype");
4128       }
4129       composite = true;
4130     }
4131 
4132     let firstChar = dict.get("FirstChar");
4133     if (!Number.isInteger(firstChar)) {
4134       firstChar = 0;
4135     }
4136     let lastChar = dict.get("LastChar");
4137     if (!Number.isInteger(lastChar)) {
4138       lastChar = composite ? 0xffff : 0xff;
4139     }
4140     const descriptor = dict.get("FontDescriptor");
4141     const toUnicode = dict.get("ToUnicode") || baseDict.get("ToUnicode");
4142 
4143     if (descriptor) {
4144       hash = new MurmurHash3_64();
4145 
4146       const encoding = baseDict.getRaw("Encoding");
4147       if (encoding instanceof Name) {
4148         hash.update(encoding.name);
4149       } else if (encoding instanceof Ref) {
4150         hash.update(encoding.toString());
4151       } else if (encoding instanceof Dict) {
4152         for (const entry of encoding.getRawValues()) {
4153           if (entry instanceof Name) {
4154             hash.update(entry.name);
4155           } else if (entry instanceof Ref) {
4156             hash.update(entry.toString());
4157           } else if (Array.isArray(entry)) {
4158             // 'Differences' array (fixes bug1157493.pdf).
4159             const diffLength = entry.length,
4160               diffBuf = new Array(diffLength);
4161 
4162             for (let j = 0; j < diffLength; j++) {
4163               const diffEntry = entry[j];
4164               if (diffEntry instanceof Name) {
4165                 diffBuf[j] = diffEntry.name;
4166               } else if (
4167                 typeof diffEntry === "number" ||
4168                 diffEntry instanceof Ref
4169               ) {
4170                 diffBuf[j] = diffEntry.toString();
4171               }
4172             }
4173             hash.update(diffBuf.join());
4174           }
4175         }
4176       }
4177 
4178       hash.update(`${firstChar}-${lastChar}`); // Fixes issue10665_reduced.pdf
4179 
4180       if (toUnicode instanceof BaseStream) {
4181         const stream = toUnicode.str || toUnicode;
4182         const uint8array = stream.buffer
4183           ? new Uint8Array(stream.buffer.buffer, 0, stream.bufferLength)
4184           : new Uint8Array(
4185               stream.bytes.buffer,
4186               stream.start,
4187               stream.end - stream.start
4188             );
4189         hash.update(uint8array);
4190       } else if (toUnicode instanceof Name) {
4191         hash.update(toUnicode.name);
4192       }
4193 
4194       const widths = dict.get("Widths") || baseDict.get("Widths");
4195       if (Array.isArray(widths)) {
4196         const widthsBuf = [];
4197         for (const entry of widths) {
4198           if (typeof entry === "number" || entry instanceof Ref) {
4199             widthsBuf.push(entry.toString());
4200           }
4201         }
4202         hash.update(widthsBuf.join());
4203       }
4204 
4205       if (composite) {
4206         hash.update("compositeFont");
4207 
4208         const compositeWidths = dict.get("W") || baseDict.get("W");
4209         if (Array.isArray(compositeWidths)) {
4210           const widthsBuf = [];
4211           for (const entry of compositeWidths) {
4212             if (typeof entry === "number" || entry instanceof Ref) {
4213               widthsBuf.push(entry.toString());
4214             } else if (Array.isArray(entry)) {
4215               const subWidthsBuf = [];
4216               for (const element of entry) {
4217                 if (typeof element === "number" || element instanceof Ref) {
4218                   subWidthsBuf.push(element.toString());
4219                 }
4220               }
4221               widthsBuf.push(`[${subWidthsBuf.join()}]`);
4222             }
4223           }
4224           hash.update(widthsBuf.join());
4225         }
4226 
4227         const cidToGidMap =
4228           dict.getRaw("CIDToGIDMap") || baseDict.getRaw("CIDToGIDMap");
4229         if (cidToGidMap instanceof Name) {
4230           hash.update(cidToGidMap.name);
4231         } else if (cidToGidMap instanceof Ref) {
4232           hash.update(cidToGidMap.toString());
4233         } else if (cidToGidMap instanceof BaseStream) {
4234           hash.update(cidToGidMap.peekBytes());
4235         }
4236       }
4237     }
4238 
4239     return {
4240       descriptor,
4241       dict,
4242       baseDict,
4243       composite,
4244       type: type.name,
4245       firstChar,
4246       lastChar,
4247       toUnicode,
4248       hash: hash ? hash.hexdigest() : "",
4249     };
4250   }
4251 
4252   async translateFont({
4253     descriptor,
4254     dict,
4255     baseDict,
4256     composite,
4257     type,
4258     firstChar,
4259     lastChar,
4260     toUnicode,
4261     cssFontInfo,
4262   }) {
4263     const isType3Font = type === "Type3";
4264 
4265     if (!descriptor) {
4266       if (isType3Font) {
4267         const bbox = lookupNormalRect(dict.getArray("FontBBox"), [0, 0, 0, 0]);
4268         // FontDescriptor is only required for Type3 fonts when the document
4269         // is a tagged pdf. Create a barbebones one to get by.
4270         descriptor = new Dict(null);
4271         descriptor.set("FontName", Name.get(type));
4272         descriptor.set("FontBBox", bbox);
4273       } else {
4274         // Before PDF 1.5 if the font was one of the base 14 fonts, having a
4275         // FontDescriptor was not required.
4276         // This case is here for compatibility.
4277         let baseFontName = dict.get("BaseFont");
4278         if (!(baseFontName instanceof Name)) {
4279           throw new FormatError("Base font is not specified");
4280         }
4281 
4282         // Using base font name as a font name.
4283         baseFontName = baseFontName.name.replaceAll(/[,_]/g, "-");
4284         const metrics = this.getBaseFontMetrics(baseFontName);
4285 
4286         // Simulating descriptor flags attribute
4287         const fontNameWoStyle = baseFontName.split("-", 1)[0];
4288         const flags =
4289           (this.isSerifFont(fontNameWoStyle) ? FontFlags.Serif : 0) |
4290           (metrics.monospace ? FontFlags.FixedPitch : 0) |
4291           (getSymbolsFonts()[fontNameWoStyle]
4292             ? FontFlags.Symbolic
4293             : FontFlags.Nonsymbolic);
4294 
4295         const properties = {
4296           type,
4297           name: baseFontName,
4298           loadedName: baseDict.loadedName,
4299           systemFontInfo: null,
4300           widths: metrics.widths,
4301           defaultWidth: metrics.defaultWidth,
4302           isSimulatedFlags: true,
4303           flags,
4304           firstChar,
4305           lastChar,
4306           toUnicode,
4307           xHeight: 0,
4308           capHeight: 0,
4309           italicAngle: 0,
4310           isType3Font,
4311         };
4312         const widths = dict.get("Widths");
4313 
4314         const standardFontName = getStandardFontName(baseFontName);
4315         let file = null;
4316         if (standardFontName) {
4317           file = await this.fetchStandardFontData(standardFontName);
4318           properties.isInternalFont = !!file;
4319         }
4320         if (!properties.isInternalFont && this.options.useSystemFonts) {
4321           properties.systemFontInfo = getFontSubstitution(
4322             this.systemFontCache,
4323             this.idFactory,
4324             this.options.standardFontDataUrl,
4325             baseFontName,
4326             standardFontName,
4327             type
4328           );
4329         }
4330 
4331         const newProperties = await this.extractDataStructures(
4332           dict,
4333           properties
4334         );
4335         if (Array.isArray(widths)) {
4336           const glyphWidths = [];
4337           let j = firstChar;
4338           for (const w of widths) {
4339             const width = this.xref.fetchIfRef(w);
4340             if (typeof width === "number") {
4341               glyphWidths[j] = width;
4342             }
4343             j++;
4344           }
4345           newProperties.widths = glyphWidths;
4346         } else {
4347           newProperties.widths = this.buildCharCodeToWidth(
4348             metrics.widths,
4349             newProperties
4350           );
4351         }
4352         return new Font(baseFontName, file, newProperties, this.options);
4353       }
4354     }
4355 
4356     // According to the spec if 'FontDescriptor' is declared, 'FirstChar',
4357     // 'LastChar' and 'Widths' should exist too, but some PDF encoders seem
4358     // to ignore this rule when a variant of a standard font is used.
4359     // TODO Fill the width array depending on which of the base font this is
4360     // a variant.
4361 
4362     let fontName = descriptor.get("FontName");
4363     let baseFont = dict.get("BaseFont");
4364     // Some bad PDFs have a string as the font name.
4365     if (typeof fontName === "string") {
4366       fontName = Name.get(fontName);
4367     }
4368     if (typeof baseFont === "string") {
4369       baseFont = Name.get(baseFont);
4370     }
4371 
4372     const fontNameStr = fontName?.name;
4373     const baseFontStr = baseFont?.name;
4374     if (!isType3Font && fontNameStr !== baseFontStr) {
4375       info(
4376         `The FontDescriptor's FontName is "${fontNameStr}" but ` +
4377           `should be the same as the Font's BaseFont "${baseFontStr}".`
4378       );
4379       // - Workaround for cases where e.g. fontNameStr = 'Arial' and
4380       //   baseFontStr = 'Arial,Bold' (needed when no font file is embedded).
4381       //
4382       // - Workaround for cases where e.g. fontNameStr = 'wg09np' and
4383       //   baseFontStr = 'Wingdings-Regular' (fixes issue7454.pdf).
4384       if (
4385         fontNameStr &&
4386         baseFontStr &&
4387         (baseFontStr.startsWith(fontNameStr) ||
4388           (!isKnownFontName(fontNameStr) && isKnownFontName(baseFontStr)))
4389       ) {
4390         fontName = null;
4391       }
4392     }
4393     fontName ||= baseFont;
4394 
4395     if (!(fontName instanceof Name)) {
4396       throw new FormatError("invalid font name");
4397     }
4398 
4399     let fontFile, subtype, length1, length2, length3;
4400     try {
4401       fontFile = descriptor.get("FontFile", "FontFile2", "FontFile3");
4402 
4403       if (fontFile) {
4404         if (!(fontFile instanceof BaseStream)) {
4405           throw new FormatError("FontFile should be a stream");
4406         } else if (fontFile.isEmpty) {
4407           throw new FormatError("FontFile is empty");
4408         }
4409       }
4410     } catch (ex) {
4411       if (!this.options.ignoreErrors) {
4412         throw ex;
4413       }
4414       warn(`translateFont - fetching "${fontName.name}" font file: "${ex}".`);
4415       fontFile = null;
4416     }
4417     let isInternalFont = false;
4418     let glyphScaleFactors = null;
4419     let systemFontInfo = null;
4420     if (fontFile) {
4421       if (fontFile.dict) {
4422         const subtypeEntry = fontFile.dict.get("Subtype");
4423         if (subtypeEntry instanceof Name) {
4424           subtype = subtypeEntry.name;
4425         }
4426         length1 = fontFile.dict.get("Length1");
4427         length2 = fontFile.dict.get("Length2");
4428         length3 = fontFile.dict.get("Length3");
4429       }
4430     } else if (cssFontInfo) {
4431       // We've a missing XFA font.
4432       const standardFontName = getXfaFontName(fontName.name);
4433       if (standardFontName) {
4434         cssFontInfo.fontFamily = `${cssFontInfo.fontFamily}-PdfJS-XFA`;
4435         cssFontInfo.metrics = standardFontName.metrics || null;
4436         glyphScaleFactors = standardFontName.factors || null;
4437         fontFile = await this.fetchStandardFontData(standardFontName.name);
4438         isInternalFont = !!fontFile;
4439 
4440         // We're using a substitution font but for example widths (if any)
4441         // are related to the glyph positions in the font.
4442         // So we overwrite everything here to be sure that widths are
4443         // correct.
4444         baseDict = dict = getXfaFontDict(fontName.name);
4445         composite = true;
4446       }
4447     } else if (!isType3Font) {
4448       const standardFontName = getStandardFontName(fontName.name);
4449       if (standardFontName) {
4450         fontFile = await this.fetchStandardFontData(standardFontName);
4451         isInternalFont = !!fontFile;
4452       }
4453       if (!isInternalFont && this.options.useSystemFonts) {
4454         systemFontInfo = getFontSubstitution(
4455           this.systemFontCache,
4456           this.idFactory,
4457           this.options.standardFontDataUrl,
4458           fontName.name,
4459           standardFontName,
4460           type
4461         );
4462       }
4463     }
4464 
4465     const fontMatrix = lookupMatrix(
4466       dict.getArray("FontMatrix"),
4467       FONT_IDENTITY_MATRIX
4468     );
4469     const bbox = lookupNormalRect(
4470       descriptor.getArray("FontBBox") || dict.getArray("FontBBox"),
4471       undefined
4472     );
4473     let ascent = descriptor.get("Ascent");
4474     if (typeof ascent !== "number") {
4475       ascent = undefined;
4476     }
4477     let descent = descriptor.get("Descent");
4478     if (typeof descent !== "number") {
4479       descent = undefined;
4480     }
4481     let xHeight = descriptor.get("XHeight");
4482     if (typeof xHeight !== "number") {
4483       xHeight = 0;
4484     }
4485     let capHeight = descriptor.get("CapHeight");
4486     if (typeof capHeight !== "number") {
4487       capHeight = 0;
4488     }
4489     let flags = descriptor.get("Flags");
4490     if (!Number.isInteger(flags)) {
4491       flags = 0;
4492     }
4493     let italicAngle = descriptor.get("ItalicAngle");
4494     if (typeof italicAngle !== "number") {
4495       italicAngle = 0;
4496     }
4497 
4498     const properties = {
4499       type,
4500       name: fontName.name,
4501       subtype,
4502       file: fontFile,
4503       length1,
4504       length2,
4505       length3,
4506       isInternalFont,
4507       loadedName: baseDict.loadedName,
4508       composite,
4509       fixedPitch: false,
4510       fontMatrix,
4511       firstChar,
4512       lastChar,
4513       toUnicode,
4514       bbox,
4515       ascent,
4516       descent,
4517       xHeight,
4518       capHeight,
4519       flags,
4520       italicAngle,
4521       isType3Font,
4522       cssFontInfo,
4523       scaleFactors: glyphScaleFactors,
4524       systemFontInfo,
4525     };
4526 
4527     if (composite) {
4528       const cidEncoding = baseDict.get("Encoding");
4529       if (cidEncoding instanceof Name) {
4530         properties.cidEncoding = cidEncoding.name;
4531       }
4532       const cMap = await CMapFactory.create({
4533         encoding: cidEncoding,
4534         fetchBuiltInCMap: this._fetchBuiltInCMapBound,
4535         useCMap: null,
4536       });
4537       properties.cMap = cMap;
4538       properties.vertical = properties.cMap.vertical;
4539     }
4540 
4541     const newProperties = await this.extractDataStructures(dict, properties);
4542     this.extractWidths(dict, descriptor, newProperties);
4543 
4544     return new Font(fontName.name, fontFile, newProperties, this.options);
4545   }
4546 
4547   static buildFontPaths(font, glyphs, handler, evaluatorOptions) {
4548     function buildPath(fontChar) {
4549       const glyphName = `${font.loadedName}_path_${fontChar}`;
4550       try {
4551         if (font.renderer.hasBuiltPath(fontChar)) {
4552           return;
4553         }
4554         handler.send("commonobj", [
4555           glyphName,
4556           "FontPath",
4557           font.renderer.getPathJs(fontChar),
4558         ]);
4559       } catch (reason) {
4560         if (evaluatorOptions.ignoreErrors) {
4561           warn(`buildFontPaths - ignoring ${glyphName} glyph: "${reason}".`);
4562           return;
4563         }
4564         throw reason;
4565       }
4566     }
4567 
4568     for (const glyph of glyphs) {
4569       buildPath(glyph.fontChar);
4570 
4571       // If the glyph has an accent we need to build a path for its
4572       // fontChar too, otherwise CanvasGraphics_paintChar will fail.
4573       const accent = glyph.accent;
4574       if (accent?.fontChar) {
4575         buildPath(accent.fontChar);
4576       }
4577     }
4578   }
4579 
4580   static get fallbackFontDict() {
4581     const dict = new Dict();
4582     dict.set("BaseFont", Name.get("Helvetica"));
4583     dict.set("Type", Name.get("FallbackType"));
4584     dict.set("Subtype", Name.get("FallbackType"));
4585     dict.set("Encoding", Name.get("WinAnsiEncoding"));
4586 
4587     return shadow(this, "fallbackFontDict", dict);
4588   }
4589 }
4590 
4591 class TranslatedFont {
4592   #sent = false;
4593 
4594   #type3Loaded = null;
4595 
4596   constructor({ loadedName, font, dict }) {
4597     this.loadedName = loadedName;
4598     this.font = font;
4599     this.dict = dict;
4600     this.type3Dependencies = font.isType3Font ? new Set() : null;
4601   }
4602 
4603   send(handler) {
4604     if (this.#sent) {
4605       return;
4606     }
4607     this.#sent = true;
4608 
4609     handler.send("commonobj", [
4610       this.loadedName,
4611       "Font",
4612       this.font.exportData(),
4613     ]);
4614   }
4615 
4616   fallback(handler, evaluatorOptions) {
4617     if (!this.font.data) {
4618       return;
4619     }
4620     // When font loading failed, fall back to the built-in font renderer.
4621     this.font.disableFontFace = true;
4622     // An arbitrary number of text rendering operators could have been
4623     // encountered between the point in time when the 'Font' message was sent
4624     // to the main-thread, and the point in time when the 'FontFallback'
4625     // message was received on the worker-thread.
4626     // To ensure that all 'FontPath's are available on the main-thread, when
4627     // font loading failed, attempt to resend *all* previously parsed glyphs.
4628     PartialEvaluator.buildFontPaths(
4629       this.font,
4630       /* glyphs = */ this.font.glyphCacheValues,
4631       handler,
4632       evaluatorOptions
4633     );
4634   }
4635 
4636   loadType3Data(evaluator, resources, task) {
4637     if (this.#type3Loaded) {
4638       return this.#type3Loaded;
4639     }
4640     const { font, type3Dependencies } = this;
4641     assert(font.isType3Font, "Must be a Type3 font.");
4642 
4643     // When parsing Type3 glyphs, always ignore them if there are errors.
4644     // Compared to the parsing of e.g. an entire page, it doesn't really
4645     // make sense to only be able to render a Type3 glyph partially.
4646     const type3Evaluator = evaluator.clone({ ignoreErrors: false });
4647     // Prevent circular references in Type3 fonts.
4648     const type3FontRefs = new RefSet(evaluator.type3FontRefs);
4649     if (this.dict.objId && !type3FontRefs.has(this.dict.objId)) {
4650       type3FontRefs.put(this.dict.objId);
4651     }
4652     type3Evaluator.type3FontRefs = type3FontRefs;
4653 
4654     let loadCharProcsPromise = Promise.resolve();
4655     const charProcs = this.dict.get("CharProcs");
4656     const fontResources = this.dict.get("Resources") || resources;
4657     const charProcOperatorList = Object.create(null);
4658 
4659     const fontBBox = Util.normalizeRect(font.bbox || [0, 0, 0, 0]),
4660       width = fontBBox[2] - fontBBox[0],
4661       height = fontBBox[3] - fontBBox[1];
4662     const fontBBoxSize = Math.hypot(width, height);
4663 
4664     for (const key of charProcs.getKeys()) {
4665       loadCharProcsPromise = loadCharProcsPromise.then(() => {
4666         const glyphStream = charProcs.get(key);
4667         const operatorList = new OperatorList();
4668         return type3Evaluator
4669           .getOperatorList({
4670             stream: glyphStream,
4671             task,
4672             resources: fontResources,
4673             operatorList,
4674           })
4675           .then(() => {
4676             // According to the PDF specification, section "9.6.5 Type 3 Fonts"
4677             // and "Table 113":
4678             //  "A glyph description that begins with the d1 operator should
4679             //   not execute any operators that set the colour (or other
4680             //   colour-related parameters) in the graphics state;
4681             //   any use of such operators shall be ignored."
4682             if (operatorList.fnArray[0] === OPS.setCharWidthAndBounds) {
4683               this.#removeType3ColorOperators(operatorList, fontBBoxSize);
4684             }
4685             charProcOperatorList[key] = operatorList.getIR();
4686 
4687             for (const dependency of operatorList.dependencies) {
4688               type3Dependencies.add(dependency);
4689             }
4690           })
4691           .catch(function (reason) {
4692             warn(`Type3 font resource "${key}" is not available.`);
4693             const dummyOperatorList = new OperatorList();
4694             charProcOperatorList[key] = dummyOperatorList.getIR();
4695           });
4696       });
4697     }
4698     this.#type3Loaded = loadCharProcsPromise.then(() => {
4699       font.charProcOperatorList = charProcOperatorList;
4700       if (this._bbox) {
4701         font.isCharBBox = true;
4702         font.bbox = this._bbox;
4703       }
4704     });
4705     return this.#type3Loaded;
4706   }
4707 
4708   #removeType3ColorOperators(operatorList, fontBBoxSize = NaN) {
4709     if (typeof PDFJSDev === "undefined" || PDFJSDev.test("TESTING")) {
4710       assert(
4711         operatorList.fnArray[0] === OPS.setCharWidthAndBounds,
4712         "Type3 glyph shall start with the d1 operator."
4713       );
4714     }
4715     const charBBox = Util.normalizeRect(operatorList.argsArray[0].slice(2)),
4716       width = charBBox[2] - charBBox[0],
4717       height = charBBox[3] - charBBox[1];
4718     const charBBoxSize = Math.hypot(width, height);
4719 
4720     if (width === 0 || height === 0) {
4721       // Skip the d1 operator when its bounds are bogus (fixes issue14953.pdf).
4722       operatorList.fnArray.splice(0, 1);
4723       operatorList.argsArray.splice(0, 1);
4724     } else if (
4725       fontBBoxSize === 0 ||
4726       Math.round(charBBoxSize / fontBBoxSize) >= 10
4727     ) {
4728       // Override the fontBBox when it's undefined/empty, or when it's at least
4729       // (approximately) one order of magnitude smaller than the charBBox
4730       // (fixes issue14999_reduced.pdf).
4731       if (!this._bbox) {
4732         this._bbox = [Infinity, Infinity, -Infinity, -Infinity];
4733       }
4734       this._bbox[0] = Math.min(this._bbox[0], charBBox[0]);
4735       this._bbox[1] = Math.min(this._bbox[1], charBBox[1]);
4736       this._bbox[2] = Math.max(this._bbox[2], charBBox[2]);
4737       this._bbox[3] = Math.max(this._bbox[3], charBBox[3]);
4738     }
4739 
4740     let i = 0,
4741       ii = operatorList.length;
4742     while (i < ii) {
4743       switch (operatorList.fnArray[i]) {
4744         case OPS.setCharWidthAndBounds:
4745           break; // Handled above.
4746         case OPS.setStrokeColorSpace:
4747         case OPS.setFillColorSpace:
4748         case OPS.setStrokeColor:
4749         case OPS.setStrokeColorN:
4750         case OPS.setFillColor:
4751         case OPS.setFillColorN:
4752         case OPS.setStrokeGray:
4753         case OPS.setFillGray:
4754         case OPS.setStrokeRGBColor:
4755         case OPS.setFillRGBColor:
4756         case OPS.setStrokeCMYKColor:
4757         case OPS.setFillCMYKColor:
4758         case OPS.shadingFill:
4759         case OPS.setRenderingIntent:
4760           operatorList.fnArray.splice(i, 1);
4761           operatorList.argsArray.splice(i, 1);
4762           ii--;
4763           continue;
4764 
4765         case OPS.setGState:
4766           const [gStateObj] = operatorList.argsArray[i];
4767           let j = 0,
4768             jj = gStateObj.length;
4769           while (j < jj) {
4770             const [gStateKey] = gStateObj[j];
4771             switch (gStateKey) {
4772               case "TR":
4773               case "TR2":
4774               case "HT":
4775               case "BG":
4776               case "BG2":
4777               case "UCR":
4778               case "UCR2":
4779                 gStateObj.splice(j, 1);
4780                 jj--;
4781                 continue;
4782             }
4783             j++;
4784           }
4785           break;
4786       }
4787       i++;
4788     }
4789   }
4790 }
4791 
4792 class StateManager {
4793   constructor(initialState = new EvalState()) {
4794     this.state = initialState;
4795     this.stateStack = [];
4796   }
4797 
4798   save() {
4799     const old = this.state;
4800     this.stateStack.push(this.state);
4801     this.state = old.clone();
4802   }
4803 
4804   restore() {
4805     const prev = this.stateStack.pop();
4806     if (prev) {
4807       this.state = prev;
4808     }
4809   }
4810 
4811   transform(args) {
4812     this.state.ctm = Util.transform(this.state.ctm, args);
4813   }
4814 }
4815 
4816 class TextState {
4817   constructor() {
4818     this.ctm = new Float32Array(IDENTITY_MATRIX);
4819     this.fontName = null;
4820     this.fontSize = 0;
4821     this.loadedName = null;
4822     this.font = null;
4823     this.fontMatrix = FONT_IDENTITY_MATRIX;
4824     this.textMatrix = IDENTITY_MATRIX.slice();
4825     this.textLineMatrix = IDENTITY_MATRIX.slice();
4826     this.charSpacing = 0;
4827     this.wordSpacing = 0;
4828     this.leading = 0;
4829     this.textHScale = 1;
4830     this.textRise = 0;
4831   }
4832 
4833   setTextMatrix(a, b, c, d, e, f) {
4834     const m = this.textMatrix;
4835     m[0] = a;
4836     m[1] = b;
4837     m[2] = c;
4838     m[3] = d;
4839     m[4] = e;
4840     m[5] = f;
4841   }
4842 
4843   setTextLineMatrix(a, b, c, d, e, f) {
4844     const m = this.textLineMatrix;
4845     m[0] = a;
4846     m[1] = b;
4847     m[2] = c;
4848     m[3] = d;
4849     m[4] = e;
4850     m[5] = f;
4851   }
4852 
4853   translateTextMatrix(x, y) {
4854     const m = this.textMatrix;
4855     m[4] = m[0] * x + m[2] * y + m[4];
4856     m[5] = m[1] * x + m[3] * y + m[5];
4857   }
4858 
4859   translateTextLineMatrix(x, y) {
4860     const m = this.textLineMatrix;
4861     m[4] = m[0] * x + m[2] * y + m[4];
4862     m[5] = m[1] * x + m[3] * y + m[5];
4863   }
4864 
4865   carriageReturn() {
4866     this.translateTextLineMatrix(0, -this.leading);
4867     this.textMatrix = this.textLineMatrix.slice();
4868   }
4869 
4870   clone() {
4871     const clone = Object.create(this);
4872     clone.textMatrix = this.textMatrix.slice();
4873     clone.textLineMatrix = this.textLineMatrix.slice();
4874     clone.fontMatrix = this.fontMatrix.slice();
4875     return clone;
4876   }
4877 }
4878 
4879 class EvalState {
4880   constructor() {
4881     this.ctm = new Float32Array(IDENTITY_MATRIX);
4882     this.font = null;
4883     this.textRenderingMode = TextRenderingMode.FILL;
4884     this._fillColorSpace = this._strokeColorSpace = ColorSpaceUtils.gray;
4885     this.patternFillColorSpace = null;
4886     this.patternStrokeColorSpace = null;
4887   }
4888 
4889   get fillColorSpace() {
4890     return this._fillColorSpace;
4891   }
4892 
4893   set fillColorSpace(colorSpace) {
4894     this._fillColorSpace = this.patternFillColorSpace = colorSpace;
4895   }
4896 
4897   get strokeColorSpace() {
4898     return this._strokeColorSpace;
4899   }
4900 
4901   set strokeColorSpace(colorSpace) {
4902     this._strokeColorSpace = this.patternStrokeColorSpace = colorSpace;
4903   }
4904 
4905   clone() {
4906     return Object.create(this);
4907   }
4908 }
4909 
4910 class EvaluatorPreprocessor {
4911   static get opMap() {
4912     // Specifies properties for each command
4913     //
4914     // If variableArgs === true: [0, `numArgs`] expected
4915     // If variableArgs === false: exactly `numArgs` expected
4916     return shadow(
4917       this,
4918       "opMap",
4919       Object.assign(Object.create(null), {
4920         // Graphic state
4921         w: { id: OPS.setLineWidth, numArgs: 1, variableArgs: false },
4922         J: { id: OPS.setLineCap, numArgs: 1, variableArgs: false },
4923         j: { id: OPS.setLineJoin, numArgs: 1, variableArgs: false },
4924         M: { id: OPS.setMiterLimit, numArgs: 1, variableArgs: false },
4925         d: { id: OPS.setDash, numArgs: 2, variableArgs: false },
4926         ri: { id: OPS.setRenderingIntent, numArgs: 1, variableArgs: false },
4927         i: { id: OPS.setFlatness, numArgs: 1, variableArgs: false },
4928         gs: { id: OPS.setGState, numArgs: 1, variableArgs: false },
4929         q: { id: OPS.save, numArgs: 0, variableArgs: false },
4930         Q: { id: OPS.restore, numArgs: 0, variableArgs: false },
4931         cm: { id: OPS.transform, numArgs: 6, variableArgs: false },
4932 
4933         // Path
4934         m: { id: OPS.moveTo, numArgs: 2, variableArgs: false },
4935         l: { id: OPS.lineTo, numArgs: 2, variableArgs: false },
4936         c: { id: OPS.curveTo, numArgs: 6, variableArgs: false },
4937         v: { id: OPS.curveTo2, numArgs: 4, variableArgs: false },
4938         y: { id: OPS.curveTo3, numArgs: 4, variableArgs: false },
4939         h: { id: OPS.closePath, numArgs: 0, variableArgs: false },
4940         re: { id: OPS.rectangle, numArgs: 4, variableArgs: false },
4941         S: { id: OPS.stroke, numArgs: 0, variableArgs: false },
4942         s: { id: OPS.closeStroke, numArgs: 0, variableArgs: false },
4943         f: { id: OPS.fill, numArgs: 0, variableArgs: false },
4944         F: { id: OPS.fill, numArgs: 0, variableArgs: false },
4945         "f*": { id: OPS.eoFill, numArgs: 0, variableArgs: false },
4946         B: { id: OPS.fillStroke, numArgs: 0, variableArgs: false },
4947         "B*": { id: OPS.eoFillStroke, numArgs: 0, variableArgs: false },
4948         b: { id: OPS.closeFillStroke, numArgs: 0, variableArgs: false },
4949         "b*": { id: OPS.closeEOFillStroke, numArgs: 0, variableArgs: false },
4950         n: { id: OPS.endPath, numArgs: 0, variableArgs: false },
4951 
4952         // Clipping
4953         W: { id: OPS.clip, numArgs: 0, variableArgs: false },
4954         "W*": { id: OPS.eoClip, numArgs: 0, variableArgs: false },
4955 
4956         // Text
4957         BT: { id: OPS.beginText, numArgs: 0, variableArgs: false },
4958         ET: { id: OPS.endText, numArgs: 0, variableArgs: false },
4959         Tc: { id: OPS.setCharSpacing, numArgs: 1, variableArgs: false },
4960         Tw: { id: OPS.setWordSpacing, numArgs: 1, variableArgs: false },
4961         Tz: { id: OPS.setHScale, numArgs: 1, variableArgs: false },
4962         TL: { id: OPS.setLeading, numArgs: 1, variableArgs: false },
4963         Tf: { id: OPS.setFont, numArgs: 2, variableArgs: false },
4964         Tr: { id: OPS.setTextRenderingMode, numArgs: 1, variableArgs: false },
4965         Ts: { id: OPS.setTextRise, numArgs: 1, variableArgs: false },
4966         Td: { id: OPS.moveText, numArgs: 2, variableArgs: false },
4967         TD: { id: OPS.setLeadingMoveText, numArgs: 2, variableArgs: false },
4968         Tm: { id: OPS.setTextMatrix, numArgs: 6, variableArgs: false },
4969         "T*": { id: OPS.nextLine, numArgs: 0, variableArgs: false },
4970         Tj: { id: OPS.showText, numArgs: 1, variableArgs: false },
4971         TJ: { id: OPS.showSpacedText, numArgs: 1, variableArgs: false },
4972         "'": { id: OPS.nextLineShowText, numArgs: 1, variableArgs: false },
4973         '"': {
4974           id: OPS.nextLineSetSpacingShowText,
4975           numArgs: 3,
4976           variableArgs: false,
4977         },
4978 
4979         // Type3 fonts
4980         d0: { id: OPS.setCharWidth, numArgs: 2, variableArgs: false },
4981         d1: {
4982           id: OPS.setCharWidthAndBounds,
4983           numArgs: 6,
4984           variableArgs: false,
4985         },
4986 
4987         // Color
4988         CS: { id: OPS.setStrokeColorSpace, numArgs: 1, variableArgs: false },
4989         cs: { id: OPS.setFillColorSpace, numArgs: 1, variableArgs: false },
4990         SC: { id: OPS.setStrokeColor, numArgs: 4, variableArgs: true },
4991         SCN: { id: OPS.setStrokeColorN, numArgs: 33, variableArgs: true },
4992         sc: { id: OPS.setFillColor, numArgs: 4, variableArgs: true },
4993         scn: { id: OPS.setFillColorN, numArgs: 33, variableArgs: true },
4994         G: { id: OPS.setStrokeGray, numArgs: 1, variableArgs: false },
4995         g: { id: OPS.setFillGray, numArgs: 1, variableArgs: false },
4996         RG: { id: OPS.setStrokeRGBColor, numArgs: 3, variableArgs: false },
4997         rg: { id: OPS.setFillRGBColor, numArgs: 3, variableArgs: false },
4998         K: { id: OPS.setStrokeCMYKColor, numArgs: 4, variableArgs: false },
4999         k: { id: OPS.setFillCMYKColor, numArgs: 4, variableArgs: false },
5000 
5001         // Shading
5002         sh: { id: OPS.shadingFill, numArgs: 1, variableArgs: false },
5003 
5004         // Images
5005         BI: { id: OPS.beginInlineImage, numArgs: 0, variableArgs: false },
5006         ID: { id: OPS.beginImageData, numArgs: 0, variableArgs: false },
5007         EI: { id: OPS.endInlineImage, numArgs: 1, variableArgs: false },
5008 
5009         // XObjects
5010         Do: { id: OPS.paintXObject, numArgs: 1, variableArgs: false },
5011         MP: { id: OPS.markPoint, numArgs: 1, variableArgs: false },
5012         DP: { id: OPS.markPointProps, numArgs: 2, variableArgs: false },
5013         BMC: { id: OPS.beginMarkedContent, numArgs: 1, variableArgs: false },
5014         BDC: {
5015           id: OPS.beginMarkedContentProps,
5016           numArgs: 2,
5017           variableArgs: false,
5018         },
5019         EMC: { id: OPS.endMarkedContent, numArgs: 0, variableArgs: false },
5020 
5021         // Compatibility
5022         BX: { id: OPS.beginCompat, numArgs: 0, variableArgs: false },
5023         EX: { id: OPS.endCompat, numArgs: 0, variableArgs: false },
5024 
5025         // (reserved partial commands for the lexer)
5026         BM: null,
5027         BD: null,
5028         true: null,
5029         fa: null,
5030         fal: null,
5031         fals: null,
5032         false: null,
5033         nu: null,
5034         nul: null,
5035         null: null,
5036       })
5037     );
5038   }
5039 
5040   static MAX_INVALID_PATH_OPS = 10;
5041 
5042   constructor(stream, xref, stateManager = new StateManager()) {
5043     // TODO(mduan): pass array of knownCommands rather than this.opMap
5044     // dictionary
5045     this.parser = new Parser({
5046       lexer: new Lexer(stream, EvaluatorPreprocessor.opMap),
5047       xref,
5048     });
5049     this.stateManager = stateManager;
5050     this.nonProcessedArgs = [];
5051     this._isPathOp = false;
5052     this._numInvalidPathOPS = 0;
5053   }
5054 
5055   get savedStatesDepth() {
5056     return this.stateManager.stateStack.length;
5057   }
5058 
5059   // |operation| is an object with two fields:
5060   //
5061   // - |fn| is an out param.
5062   //
5063   // - |args| is an inout param. On entry, it should have one of two values.
5064   //
5065   //   - An empty array. This indicates that the caller is providing the
5066   //     array in which the args will be stored in. The caller should use
5067   //     this value if it can reuse a single array for each call to read().
5068   //
5069   //   - |null|. This indicates that the caller needs this function to create
5070   //     the array in which any args are stored in. If there are zero args,
5071   //     this function will leave |operation.args| as |null| (thus avoiding
5072   //     allocations that would occur if we used an empty array to represent
5073   //     zero arguments). Otherwise, it will replace |null| with a new array
5074   //     containing the arguments. The caller should use this value if it
5075   //     cannot reuse an array for each call to read().
5076   //
5077   // These two modes are present because this function is very hot and so
5078   // avoiding allocations where possible is worthwhile.
5079   //
5080   read(operation) {
5081     let args = operation.args;
5082     while (true) {
5083       const obj = this.parser.getObj();
5084       if (obj instanceof Cmd) {
5085         const cmd = obj.cmd;
5086         // Check that the command is valid
5087         const opSpec = EvaluatorPreprocessor.opMap[cmd];
5088         if (!opSpec) {
5089           warn(`Unknown command "${cmd}".`);
5090           continue;
5091         }
5092 
5093         const fn = opSpec.id;
5094         const numArgs = opSpec.numArgs;
5095         let argsLength = args !== null ? args.length : 0;
5096 
5097         // If the *previous* command wasn't a path operator, reset the heuristic
5098         // used with incomplete path operators below (fixes issue14917.pdf).
5099         if (!this._isPathOp) {
5100           this._numInvalidPathOPS = 0;
5101         }
5102         this._isPathOp = fn >= OPS.moveTo && fn <= OPS.endPath;
5103 
5104         if (!opSpec.variableArgs) {
5105           // Postscript commands can be nested, e.g. /F2 /GS2 gs 5.711 Tf
5106           if (argsLength !== numArgs) {
5107             const nonProcessedArgs = this.nonProcessedArgs;
5108             while (argsLength > numArgs) {
5109               nonProcessedArgs.push(args.shift());
5110               argsLength--;
5111             }
5112             while (argsLength < numArgs && nonProcessedArgs.length !== 0) {
5113               if (args === null) {
5114                 args = [];
5115               }
5116               args.unshift(nonProcessedArgs.pop());
5117               argsLength++;
5118             }
5119           }
5120 
5121           if (argsLength < numArgs) {
5122             const partialMsg =
5123               `command ${cmd}: expected ${numArgs} args, ` +
5124               `but received ${argsLength} args.`;
5125 
5126             // Incomplete path operators, in particular, can result in fairly
5127             // chaotic rendering artifacts. Hence the following heuristics is
5128             // used to error, rather than just warn, once a number of invalid
5129             // path operators have been encountered (fixes bug1443140.pdf).
5130             if (
5131               this._isPathOp &&
5132               ++this._numInvalidPathOPS >
5133                 EvaluatorPreprocessor.MAX_INVALID_PATH_OPS
5134             ) {
5135               throw new FormatError(`Invalid ${partialMsg}`);
5136             }
5137             // If we receive too few arguments, it's not possible to execute
5138             // the command, hence we skip the command.
5139             warn(`Skipping ${partialMsg}`);
5140             if (args !== null) {
5141               args.length = 0;
5142             }
5143             continue;
5144           }
5145         } else if (argsLength > numArgs) {
5146           info(
5147             `Command ${cmd}: expected [0, ${numArgs}] args, ` +
5148               `but received ${argsLength} args.`
5149           );
5150         }
5151 
5152         // TODO figure out how to type-check vararg functions
5153         this.preprocessCommand(fn, args);
5154 
5155         operation.fn = fn;
5156         operation.args = args;
5157         return true;
5158       }
5159       if (obj === EOF) {
5160         return false; // no more commands
5161       }
5162       // argument
5163       if (obj !== null) {
5164         if (args === null) {
5165           args = [];
5166         }
5167         args.push(obj);
5168         if (args.length > 33) {
5169           throw new FormatError("Too many arguments");
5170         }
5171       }
5172     }
5173   }
5174 
5175   preprocessCommand(fn, args) {
5176     switch (fn | 0) {
5177       case OPS.save:
5178         this.stateManager.save();
5179         break;
5180       case OPS.restore:
5181         this.stateManager.restore();
5182         break;
5183       case OPS.transform:
5184         this.stateManager.transform(args);
5185         break;
5186     }
5187   }
5188 }
5189 
5190 export { EvaluatorPreprocessor, PartialEvaluator };
</code>

Test file:
<test_file>
File:
test/unit/evaluator_spec.js
/* Copyright 2017 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import { createIdFactory, XRefMock } from "./test_utils.js";
import { Dict, Name } from "../../src/core/primitives.js";
import { FormatError, OPS } from "../../src/shared/util.js";
import { Stream, StringStream } from "../../src/core/stream.js";
import { OperatorList } from "../../src/core/operator_list.js";
import { PartialEvaluator } from "../../src/core/evaluator.js";
import { WorkerTask } from "../../src/core/worker.js";
</test_file>

Your task:
You are a software tester at pdf.js.
1. Examine the existing test file. You may reuse any imports, helpers or setup blocks it already has.
2. Write exactly one javascript test `it("...", async () => {...})` block.
3. Your test must fail on the code before the patch, and pass after, hence the test will verify that the patch resolves the issue.
4. The test must be self-contained and to-the-point.
5. If you need something new use only the provided imports (respect the paths exactly how they are given) by importing dynamically for compatibility with Node.js — no new dependencies. 
6. Return only the javascript code for the new `it(...)` block (no comments or explanations).

Example structure:
it("should <describe behavior>", async () => {
  const { example } = await import("../../src/core/example.js");
  <initialize required variables>;
  <define expected variable>;
  <generate actual variables>;
  <compare expected with actual>;
});

